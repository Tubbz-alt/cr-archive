<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContextBase.idl</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 24  */
 25 
 26 typedef unsigned long GLenum;
 27 typedef boolean GLboolean;
 28 typedef unsigned long GLbitfield;
 29 typedef byte GLbyte; /* &#39;byte&#39; should be a signed 8 bit type. */
 30 typedef short GLshort;
 31 typedef long GLint;
 32 typedef long GLsizei;
 33 typedef long long GLintptr;
 34 typedef long long GLsizeiptr;
 35 typedef octet GLubyte; /* &#39;octet&#39; should be an unsigned 8 bit type. */
 36 typedef unsigned short GLushort;
 37 typedef unsigned long GLuint;
 38 typedef unrestricted float GLfloat;
 39 typedef unrestricted float GLclampf;
 40 typedef (ArrayBuffer or ArrayBufferView) BufferDataSource;
 41 typedef (Float32Array or sequence&lt;GLfloat&gt;) Float32List;
 42 typedef (Int32Array or sequence&lt;GLint&gt;) Int32List;
 43 
 44 #if defined(ENABLE_OFFSCREEN_CANVAS)
 45 typedef (HTMLCanvasElement or OffscreenCanvas) WebGLCanvas;
 46 #else
 47 typedef (HTMLCanvasElement) WebGLCanvas;
 48 #endif
 49 
 50 [
 51     Conditional=WEBGL,
 52     CustomIsReachable,
 53     CustomToJSObject,
 54     DoNotCheckConstants,
 55     JSCustomMarkFunction,
 56     NoInterfaceObject,
 57     ExportMacro=WEBCORE_EXPORT,
 58 ] interface WebGLRenderingContextBase {
 59 
 60     readonly attribute WebGLCanvas canvas;
 61 
 62     /* ClearBufferMask */
 63     const GLenum DEPTH_BUFFER_BIT = 0x00000100;
 64     const GLenum STENCIL_BUFFER_BIT = 0x00000400;
 65     const GLenum COLOR_BUFFER_BIT = 0x00004000;
 66 
 67     /* BeginMode */
 68     const GLenum POINTS = 0x0000;
 69     const GLenum LINES = 0x0001;
 70     const GLenum LINE_LOOP = 0x0002;
 71     const GLenum LINE_STRIP = 0x0003;
 72     const GLenum TRIANGLES = 0x0004;
 73     const GLenum TRIANGLE_STRIP = 0x0005;
 74     const GLenum TRIANGLE_FAN = 0x0006;
 75 
 76     /* AlphaFunction (not supported in ES20) */
 77     /*  NEVER */
 78     /*  LESS */
 79     /*  EQUAL */
 80     /*  LEQUAL */
 81     /*  GREATER */
 82     /*  NOTEQUAL */
 83     /*  GEQUAL */
 84     /*  ALWAYS */
 85 
 86     /* BlendingFactorDest */
 87     const GLenum ZERO = 0;
 88     const GLenum ONE = 1;
 89     const GLenum SRC_COLOR = 0x0300;
 90     const GLenum ONE_MINUS_SRC_COLOR = 0x0301;
 91     const GLenum SRC_ALPHA = 0x0302;
 92     const GLenum ONE_MINUS_SRC_ALPHA = 0x0303;
 93     const GLenum DST_ALPHA = 0x0304;
 94     const GLenum ONE_MINUS_DST_ALPHA = 0x0305;
 95 
 96     /* BlendingFactorSrc */
 97     /*  ZERO */
 98     /*  ONE */
 99     const GLenum DST_COLOR = 0x0306;
100     const GLenum ONE_MINUS_DST_COLOR = 0x0307;
101     const GLenum SRC_ALPHA_SATURATE = 0x0308;
102     /*  SRC_ALPHA */
103     /*  ONE_MINUS_SRC_ALPHA */
104     /*  DST_ALPHA */
105     /*  ONE_MINUS_DST_ALPHA */
106 
107     /* BlendEquationSeparate */
108     const GLenum FUNC_ADD = 0x8006;
109     const GLenum BLEND_EQUATION = 0x8009;
110     const GLenum BLEND_EQUATION_RGB = 0x8009;   /* same as BLEND_EQUATION */
111     const GLenum BLEND_EQUATION_ALPHA = 0x883D;
112 
113     /* BlendSubtract */
114     const GLenum FUNC_SUBTRACT = 0x800A;
115     const GLenum FUNC_REVERSE_SUBTRACT = 0x800B;
116 
117     /* Separate Blend Functions */
118     const GLenum BLEND_DST_RGB = 0x80C8;
119     const GLenum BLEND_SRC_RGB = 0x80C9;
120     const GLenum BLEND_DST_ALPHA = 0x80CA;
121     const GLenum BLEND_SRC_ALPHA = 0x80CB;
122     const GLenum CONSTANT_COLOR = 0x8001;
123     const GLenum ONE_MINUS_CONSTANT_COLOR = 0x8002;
124     const GLenum CONSTANT_ALPHA = 0x8003;
125     const GLenum ONE_MINUS_CONSTANT_ALPHA = 0x8004;
126     const GLenum BLEND_COLOR = 0x8005;
127 
128     /* Buffer Objects */
129     const GLenum ARRAY_BUFFER = 0x8892;
130     const GLenum ELEMENT_ARRAY_BUFFER = 0x8893;
131     const GLenum ARRAY_BUFFER_BINDING = 0x8894;
132     const GLenum ELEMENT_ARRAY_BUFFER_BINDING = 0x8895;
133 
134     const GLenum STREAM_DRAW = 0x88E0;
135     const GLenum STATIC_DRAW = 0x88E4;
136     const GLenum DYNAMIC_DRAW = 0x88E8;
137 
138     const GLenum BUFFER_SIZE = 0x8764;
139     const GLenum BUFFER_USAGE = 0x8765;
140 
141     const GLenum CURRENT_VERTEX_ATTRIB = 0x8626;
142 
143     /* CullFaceMode */
144     const GLenum FRONT = 0x0404;
145     const GLenum BACK = 0x0405;
146     const GLenum FRONT_AND_BACK = 0x0408;
147 
148     /* DepthFunction */
149     /*  NEVER */
150     /*  LESS */
151     /*  EQUAL */
152     /*  LEQUAL */
153     /*  GREATER */
154     /*  NOTEQUAL */
155     /*  GEQUAL */
156     /*  ALWAYS */
157 
158     /* EnableCap */
159     const GLenum TEXTURE_2D = 0x0DE1;
160     const GLenum CULL_FACE = 0x0B44;
161     const GLenum BLEND = 0x0BE2;
162     const GLenum DITHER = 0x0BD0;
163     const GLenum STENCIL_TEST = 0x0B90;
164     const GLenum DEPTH_TEST = 0x0B71;
165     const GLenum SCISSOR_TEST = 0x0C11;
166     const GLenum POLYGON_OFFSET_FILL = 0x8037;
167     const GLenum SAMPLE_ALPHA_TO_COVERAGE = 0x809E;
168     const GLenum SAMPLE_COVERAGE = 0x80A0;
169 
170     /* ErrorCode */
171     const GLenum NO_ERROR = 0;
172     const GLenum INVALID_ENUM = 0x0500;
173     const GLenum INVALID_VALUE = 0x0501;
174     const GLenum INVALID_OPERATION = 0x0502;
175     const GLenum OUT_OF_MEMORY = 0x0505;
176 
177     /* FrontFaceDirection */
178     const GLenum CW = 0x0900;
179     const GLenum CCW = 0x0901;
180 
181     /* GetPName */
182     const GLenum LINE_WIDTH = 0x0B21;
183     const GLenum ALIASED_POINT_SIZE_RANGE = 0x846D;
184     const GLenum ALIASED_LINE_WIDTH_RANGE = 0x846E;
185     const GLenum CULL_FACE_MODE = 0x0B45;
186     const GLenum FRONT_FACE = 0x0B46;
187     const GLenum DEPTH_RANGE = 0x0B70;
188     const GLenum DEPTH_WRITEMASK = 0x0B72;
189     const GLenum DEPTH_CLEAR_VALUE = 0x0B73;
190     const GLenum DEPTH_FUNC = 0x0B74;
191     const GLenum STENCIL_CLEAR_VALUE = 0x0B91;
192     const GLenum STENCIL_FUNC = 0x0B92;
193     const GLenum STENCIL_FAIL = 0x0B94;
194     const GLenum STENCIL_PASS_DEPTH_FAIL = 0x0B95;
195     const GLenum STENCIL_PASS_DEPTH_PASS = 0x0B96;
196     const GLenum STENCIL_REF = 0x0B97;
197     const GLenum STENCIL_VALUE_MASK = 0x0B93;
198     const GLenum STENCIL_WRITEMASK = 0x0B98;
199     const GLenum STENCIL_BACK_FUNC = 0x8800;
200     const GLenum STENCIL_BACK_FAIL = 0x8801;
201     const GLenum STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802;
202     const GLenum STENCIL_BACK_PASS_DEPTH_PASS = 0x8803;
203     const GLenum STENCIL_BACK_REF = 0x8CA3;
204     const GLenum STENCIL_BACK_VALUE_MASK = 0x8CA4;
205     const GLenum STENCIL_BACK_WRITEMASK = 0x8CA5;
206     const GLenum VIEWPORT = 0x0BA2;
207     const GLenum SCISSOR_BOX = 0x0C10;
208     /*  SCISSOR_TEST */
209     const GLenum COLOR_CLEAR_VALUE = 0x0C22;
210     const GLenum COLOR_WRITEMASK = 0x0C23;
211     const GLenum UNPACK_ALIGNMENT = 0x0CF5;
212     const GLenum PACK_ALIGNMENT = 0x0D05;
213     const GLenum MAX_TEXTURE_SIZE = 0x0D33;
214     const GLenum MAX_VIEWPORT_DIMS = 0x0D3A;
215     const GLenum SUBPIXEL_BITS = 0x0D50;
216     const GLenum RED_BITS = 0x0D52;
217     const GLenum GREEN_BITS = 0x0D53;
218     const GLenum BLUE_BITS = 0x0D54;
219     const GLenum ALPHA_BITS = 0x0D55;
220     const GLenum DEPTH_BITS = 0x0D56;
221     const GLenum STENCIL_BITS = 0x0D57;
222     const GLenum POLYGON_OFFSET_UNITS = 0x2A00;
223     /*  POLYGON_OFFSET_FILL */
224     const GLenum POLYGON_OFFSET_FACTOR = 0x8038;
225     const GLenum TEXTURE_BINDING_2D = 0x8069;
226     const GLenum SAMPLE_BUFFERS = 0x80A8;
227     const GLenum SAMPLES = 0x80A9;
228     const GLenum SAMPLE_COVERAGE_VALUE = 0x80AA;
229     const GLenum SAMPLE_COVERAGE_INVERT = 0x80AB;
230 
231     /* GetTextureParameter */
232     /*  TEXTURE_MAG_FILTER */
233     /*  TEXTURE_MIN_FILTER */
234     /*  TEXTURE_WRAP_S */
235     /*  TEXTURE_WRAP_T */
236 
237     const GLenum COMPRESSED_TEXTURE_FORMATS = 0x86A3;
238 
239     /* HintMode */
240     const GLenum DONT_CARE = 0x1100;
241     const GLenum FASTEST = 0x1101;
242     const GLenum NICEST = 0x1102;
243 
244     /* HintTarget */
245     const GLenum GENERATE_MIPMAP_HINT = 0x8192;
246 
247     /* DataType */
248     const GLenum BYTE = 0x1400;
249     const GLenum UNSIGNED_BYTE = 0x1401;
250     const GLenum SHORT = 0x1402;
251     const GLenum UNSIGNED_SHORT = 0x1403;
252     const GLenum INT = 0x1404;
253     const GLenum UNSIGNED_INT = 0x1405;
254     const GLenum FLOAT = 0x1406;
255 
256     /* PixelFormat */
257     const GLenum DEPTH_COMPONENT = 0x1902;
258     const GLenum ALPHA = 0x1906;
259     const GLenum RGB = 0x1907;
260     const GLenum RGBA = 0x1908;
261     const GLenum LUMINANCE = 0x1909;
262     const GLenum LUMINANCE_ALPHA = 0x190A;
263 
264     /* PixelType */
265     /*  UNSIGNED_BYTE */
266     const GLenum UNSIGNED_SHORT_4_4_4_4 = 0x8033;
267     const GLenum UNSIGNED_SHORT_5_5_5_1 = 0x8034;
268     const GLenum UNSIGNED_SHORT_5_6_5 = 0x8363;
269 
270     /* Shaders */
271     const GLenum FRAGMENT_SHADER = 0x8B30;
272     const GLenum VERTEX_SHADER = 0x8B31;
273     const GLenum MAX_VERTEX_ATTRIBS = 0x8869;
274     const GLenum MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;
275     const GLenum MAX_VARYING_VECTORS = 0x8DFC;
276     const GLenum MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;
277     const GLenum MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;
278     const GLenum MAX_TEXTURE_IMAGE_UNITS = 0x8872;
279     const GLenum MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;
280     const GLenum SHADER_TYPE = 0x8B4F;
281     const GLenum DELETE_STATUS = 0x8B80;
282     const GLenum LINK_STATUS = 0x8B82;
283     const GLenum VALIDATE_STATUS = 0x8B83;
284     const GLenum ATTACHED_SHADERS = 0x8B85;
285     const GLenum ACTIVE_UNIFORMS = 0x8B86;
286     const GLenum ACTIVE_ATTRIBUTES = 0x8B89;
287     const GLenum SHADING_LANGUAGE_VERSION = 0x8B8C;
288     const GLenum CURRENT_PROGRAM = 0x8B8D;
289 
290     /* StencilFunction */
291     const GLenum NEVER = 0x0200;
292     const GLenum LESS = 0x0201;
293     const GLenum EQUAL = 0x0202;
294     const GLenum LEQUAL = 0x0203;
295     const GLenum GREATER = 0x0204;
296     const GLenum NOTEQUAL = 0x0205;
297     const GLenum GEQUAL = 0x0206;
298     const GLenum ALWAYS = 0x0207;
299 
300     /* StencilOp */
301     /*  ZERO */
302     const GLenum KEEP = 0x1E00;
303     const GLenum REPLACE = 0x1E01;
304     const GLenum INCR = 0x1E02;
305     const GLenum DECR = 0x1E03;
306     const GLenum INVERT = 0x150A;
307     const GLenum INCR_WRAP = 0x8507;
308     const GLenum DECR_WRAP = 0x8508;
309 
310     /* StringName */
311     const GLenum VENDOR = 0x1F00;
312     const GLenum RENDERER = 0x1F01;
313     const GLenum VERSION = 0x1F02;
314 
315     /* TextureMagFilter */
316     const GLenum NEAREST = 0x2600;
317     const GLenum LINEAR = 0x2601;
318 
319     /* TextureMinFilter */
320     /*  NEAREST */
321     /*  LINEAR */
322     const GLenum NEAREST_MIPMAP_NEAREST = 0x2700;
323     const GLenum LINEAR_MIPMAP_NEAREST = 0x2701;
324     const GLenum NEAREST_MIPMAP_LINEAR = 0x2702;
325     const GLenum LINEAR_MIPMAP_LINEAR = 0x2703;
326 
327     /* TextureParameterName */
328     const GLenum TEXTURE_MAG_FILTER = 0x2800;
329     const GLenum TEXTURE_MIN_FILTER = 0x2801;
330     const GLenum TEXTURE_WRAP_S = 0x2802;
331     const GLenum TEXTURE_WRAP_T = 0x2803;
332 
333     /* TextureTarget */
334     /*  TEXTURE_2D */
335     const GLenum TEXTURE = 0x1702;
336 
337     const GLenum TEXTURE_CUBE_MAP = 0x8513;
338     const GLenum TEXTURE_BINDING_CUBE_MAP = 0x8514;
339     const GLenum TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;
340     const GLenum TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;
341     const GLenum TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;
342     const GLenum TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;
343     const GLenum TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;
344     const GLenum TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;
345     const GLenum MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;
346 
347     /* TextureUnit */
348     const GLenum TEXTURE0 = 0x84C0;
349     const GLenum TEXTURE1 = 0x84C1;
350     const GLenum TEXTURE2 = 0x84C2;
351     const GLenum TEXTURE3 = 0x84C3;
352     const GLenum TEXTURE4 = 0x84C4;
353     const GLenum TEXTURE5 = 0x84C5;
354     const GLenum TEXTURE6 = 0x84C6;
355     const GLenum TEXTURE7 = 0x84C7;
356     const GLenum TEXTURE8 = 0x84C8;
357     const GLenum TEXTURE9 = 0x84C9;
358     const GLenum TEXTURE10 = 0x84CA;
359     const GLenum TEXTURE11 = 0x84CB;
360     const GLenum TEXTURE12 = 0x84CC;
361     const GLenum TEXTURE13 = 0x84CD;
362     const GLenum TEXTURE14 = 0x84CE;
363     const GLenum TEXTURE15 = 0x84CF;
364     const GLenum TEXTURE16 = 0x84D0;
365     const GLenum TEXTURE17 = 0x84D1;
366     const GLenum TEXTURE18 = 0x84D2;
367     const GLenum TEXTURE19 = 0x84D3;
368     const GLenum TEXTURE20 = 0x84D4;
369     const GLenum TEXTURE21 = 0x84D5;
370     const GLenum TEXTURE22 = 0x84D6;
371     const GLenum TEXTURE23 = 0x84D7;
372     const GLenum TEXTURE24 = 0x84D8;
373     const GLenum TEXTURE25 = 0x84D9;
374     const GLenum TEXTURE26 = 0x84DA;
375     const GLenum TEXTURE27 = 0x84DB;
376     const GLenum TEXTURE28 = 0x84DC;
377     const GLenum TEXTURE29 = 0x84DD;
378     const GLenum TEXTURE30 = 0x84DE;
379     const GLenum TEXTURE31 = 0x84DF;
380     const GLenum ACTIVE_TEXTURE = 0x84E0;
381 
382     /* TextureWrapMode */
383     const GLenum REPEAT = 0x2901;
384     const GLenum CLAMP_TO_EDGE = 0x812F;
385     const GLenum MIRRORED_REPEAT = 0x8370;
386 
387     /* Uniform Types */
388     const GLenum FLOAT_VEC2 = 0x8B50;
389     const GLenum FLOAT_VEC3 = 0x8B51;
390     const GLenum FLOAT_VEC4 = 0x8B52;
391     const GLenum INT_VEC2 = 0x8B53;
392     const GLenum INT_VEC3 = 0x8B54;
393     const GLenum INT_VEC4 = 0x8B55;
394     const GLenum BOOL = 0x8B56;
395     const GLenum BOOL_VEC2 = 0x8B57;
396     const GLenum BOOL_VEC3 = 0x8B58;
397     const GLenum BOOL_VEC4 = 0x8B59;
398     const GLenum FLOAT_MAT2 = 0x8B5A;
399     const GLenum FLOAT_MAT3 = 0x8B5B;
400     const GLenum FLOAT_MAT4 = 0x8B5C;
401     const GLenum SAMPLER_2D = 0x8B5E;
402     const GLenum SAMPLER_CUBE = 0x8B60;
403 
404     /* Vertex Arrays */
405     const GLenum VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622;
406     const GLenum VERTEX_ATTRIB_ARRAY_SIZE = 0x8623;
407     const GLenum VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624;
408     const GLenum VERTEX_ATTRIB_ARRAY_TYPE = 0x8625;
409     const GLenum VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A;
410     const GLenum VERTEX_ATTRIB_ARRAY_POINTER = 0x8645;
411     const GLenum VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;
412 
413     /* Read Format */
414     const GLenum IMPLEMENTATION_COLOR_READ_TYPE = 0x8B9A;
415     const GLenum IMPLEMENTATION_COLOR_READ_FORMAT = 0x8B9B;
416 
417     /* Shader Source */
418     const GLenum COMPILE_STATUS = 0x8B81;
419 
420     /* Shader Precision-Specified Types */
421     const GLenum LOW_FLOAT = 0x8DF0;
422     const GLenum MEDIUM_FLOAT = 0x8DF1;
423     const GLenum HIGH_FLOAT = 0x8DF2;
424     const GLenum LOW_INT = 0x8DF3;
425     const GLenum MEDIUM_INT = 0x8DF4;
426     const GLenum HIGH_INT = 0x8DF5;
427 
428     /* Framebuffer Object. */
429     const GLenum FRAMEBUFFER = 0x8D40;
430     const GLenum RENDERBUFFER = 0x8D41;
431 
432     const GLenum RGBA4 = 0x8056;
433     const GLenum RGB5_A1 = 0x8057;
434     const GLenum RGB565 = 0x8D62;
435     const GLenum DEPTH_COMPONENT16 = 0x81A5;
436     const GLenum STENCIL_INDEX = 0x1901;
437     const GLenum STENCIL_INDEX8 = 0x8D48;
438     const GLenum DEPTH_STENCIL = 0x84F9;
439 
440     const GLenum RENDERBUFFER_WIDTH = 0x8D42;
441     const GLenum RENDERBUFFER_HEIGHT = 0x8D43;
442     const GLenum RENDERBUFFER_INTERNAL_FORMAT = 0x8D44;
443     const GLenum RENDERBUFFER_RED_SIZE = 0x8D50;
444     const GLenum RENDERBUFFER_GREEN_SIZE = 0x8D51;
445     const GLenum RENDERBUFFER_BLUE_SIZE = 0x8D52;
446     const GLenum RENDERBUFFER_ALPHA_SIZE = 0x8D53;
447     const GLenum RENDERBUFFER_DEPTH_SIZE = 0x8D54;
448     const GLenum RENDERBUFFER_STENCIL_SIZE = 0x8D55;
449 
450     const GLenum FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0;
451     const GLenum FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1;
452     const GLenum FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2;
453     const GLenum FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;
454 
455     const GLenum COLOR_ATTACHMENT0 = 0x8CE0;
456     const GLenum DEPTH_ATTACHMENT = 0x8D00;
457     const GLenum STENCIL_ATTACHMENT = 0x8D20;
458     const GLenum DEPTH_STENCIL_ATTACHMENT = 0x821A;
459 
460     const GLenum NONE = 0;
461 
462     const GLenum FRAMEBUFFER_COMPLETE = 0x8CD5;
463     const GLenum FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;
464     const GLenum FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;
465     const GLenum FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9;
466     const GLenum FRAMEBUFFER_UNSUPPORTED = 0x8CDD;
467 
468     const GLenum FRAMEBUFFER_BINDING = 0x8CA6;
469     const GLenum RENDERBUFFER_BINDING = 0x8CA7;
470     const GLenum MAX_RENDERBUFFER_SIZE = 0x84E8;
471 
472     const GLenum INVALID_FRAMEBUFFER_OPERATION = 0x0506;
473 
474     /* WebGL-specific enums */
475     const GLenum UNPACK_FLIP_Y_WEBGL = 0x9240;
476     const GLenum UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;
477     const GLenum CONTEXT_LOST_WEBGL = 0x9242;
478     const GLenum UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;
479     const GLenum BROWSER_DEFAULT_WEBGL = 0x9244;
480 
481     readonly attribute GLsizei drawingBufferWidth;
482     readonly attribute GLsizei drawingBufferHeight;
483 
484     void activeTexture(GLenum texture);
485     void attachShader(WebGLProgram? program, WebGLShader? shader);
486     void bindAttribLocation(WebGLProgram? program, GLuint index, DOMString name);
487     void bindBuffer(GLenum target, WebGLBuffer? buffer);
488     void bindFramebuffer(GLenum target, WebGLFramebuffer? framebuffer);
489     void bindRenderbuffer(GLenum target, WebGLRenderbuffer? renderbuffer);
490     void bindTexture(GLenum target, WebGLTexture? texture);
491     void blendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
492     void blendEquation(GLenum mode);
493     void blendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);
494     void blendFunc(GLenum sfactor, GLenum dfactor);
495     void blendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
496     void bufferData(GLenum target, BufferDataSource? data, GLenum usage);
497     void bufferData(GLenum target, GLsizeiptr size, GLenum usage);
498     void bufferSubData(GLenum target, GLintptr offset, BufferDataSource? data);
499 
500     GLenum checkFramebufferStatus(GLenum target);
501     void clear(GLbitfield mask);
502     void clearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
503     void clearDepth(GLclampf depth);
504     void clearStencil(GLint s);
505     void colorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
506     void compileShader(WebGLShader? shader);
507 
508     void texImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels);
509     [MayThrowException] void texImage2D(GLenum target, GLint level, GLenum internalformat, GLenum format, GLenum type, TexImageSource? source);
510 
511     void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, ArrayBufferView? pixels);
512     [MayThrowException] void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLenum format, GLenum type, TexImageSource? source);
513 
514     void compressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, ArrayBufferView data);
515     void compressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, ArrayBufferView data);
516 
517     void copyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
518     void copyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
519 
520     WebGLBuffer createBuffer();
521     WebGLFramebuffer createFramebuffer();
522     WebGLProgram createProgram();
523     WebGLRenderbuffer createRenderbuffer();
524     WebGLShader createShader(GLenum type);
525     WebGLTexture createTexture();
526 
527     void cullFace(GLenum mode);
528 
529     void deleteBuffer(WebGLBuffer? buffer);
530     void deleteFramebuffer(WebGLFramebuffer? framebuffer);
531     void deleteProgram(WebGLProgram? program);
532     void deleteRenderbuffer(WebGLRenderbuffer? renderbuffer);
533     void deleteShader(WebGLShader? shader);
534     void deleteTexture(WebGLTexture? texture);
535 
536     void depthFunc(GLenum func);
537     void depthMask(GLboolean flag);
538     void depthRange(GLclampf zNear, GLclampf zFar);
539     void detachShader(WebGLProgram? program, WebGLShader? shader);
540     void disable(GLenum cap);
541     void disableVertexAttribArray(GLuint index);
542     void drawArrays(GLenum mode, GLint first, GLsizei count);
543     void drawElements(GLenum mode, GLsizei count, GLenum type, GLintptr offset);
544 
545     void enable(GLenum cap);
546     void enableVertexAttribArray(GLuint index);
547     void finish();
548     void flush();
549     void framebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, WebGLRenderbuffer? renderbuffer);
550     void framebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, WebGLTexture? texture, GLint level);
551     void frontFace(GLenum mode);
552     void generateMipmap(GLenum target);
553     
554     WebGLActiveInfo getActiveAttrib(WebGLProgram? program, GLuint index);
555     WebGLActiveInfo getActiveUniform(WebGLProgram? program, GLuint index);
556 
557     // FIXME: The spec says this should not take a nullable WebGLProgram.
558     sequence&lt;WebGLShader&gt;? getAttachedShaders(WebGLProgram? program);
559 
560     GLint getAttribLocation(WebGLProgram? program, DOMString name);
561 
562     [OverrideIDLType=IDLWebGLAny] any getBufferParameter(GLenum target, GLenum pname);
563 
564     WebGLContextAttributes? getContextAttributes();
565 
566     GLenum getError();
567 
568     sequence&lt;DOMString&gt;? getSupportedExtensions();
569     [OverrideIDLType=IDLWebGLExtension] object? getExtension(DOMString name);
570 
571     [OverrideIDLType=IDLWebGLAny] any getFramebufferAttachmentParameter(GLenum target, GLenum attachment, GLenum pname);
572     [OverrideIDLType=IDLWebGLAny] any getParameter(GLenum pname);
573     [OverrideIDLType=IDLWebGLAny] any getProgramParameter(WebGLProgram? program, GLenum pname);
574     DOMString? getProgramInfoLog(WebGLProgram? program);
575     [OverrideIDLType=IDLWebGLAny] any getRenderbufferParameter(GLenum target, GLenum pname);
576     [OverrideIDLType=IDLWebGLAny] any getShaderParameter(WebGLShader? shader, GLenum pname);
577 
578     DOMString? getShaderInfoLog(WebGLShader? shader);
579 
580     WebGLShaderPrecisionFormat getShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype);
581 
582     DOMString? getShaderSource(WebGLShader? shader);
583 
584     [OverrideIDLType=IDLWebGLAny] any getTexParameter(GLenum target, GLenum pname);
585 
586     [OverrideIDLType=IDLWebGLAny] any getUniform(WebGLProgram? program, WebGLUniformLocation? location);
587 
588     WebGLUniformLocation getUniformLocation(WebGLProgram? program, DOMString name);
589 
590     [OverrideIDLType=IDLWebGLAny] any getVertexAttrib(GLuint index, GLenum pname);
591 
592     GLsizeiptr getVertexAttribOffset(GLuint index, GLenum pname);
593 
594     void hint(GLenum target, GLenum mode);
595     GLboolean isBuffer(WebGLBuffer? buffer);
596     GLboolean isContextLost();
597     GLboolean isEnabled(GLenum cap);
598     GLboolean isFramebuffer(WebGLFramebuffer? framebuffer);
599     GLboolean isProgram(WebGLProgram? program);
600     GLboolean isRenderbuffer(WebGLRenderbuffer? renderbuffer);
601     GLboolean isShader(WebGLShader? shader);
602     GLboolean isTexture(WebGLTexture? texture);
603     void lineWidth(GLfloat width);
604     void linkProgram(WebGLProgram? program);
605     void pixelStorei(GLenum pname, GLint param);
606     void polygonOffset(GLfloat factor, GLfloat units);
607 
608     void readPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, ArrayBufferView pixels);
609     
610     void releaseShaderCompiler();
611     void renderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
612     void sampleCoverage(GLclampf value, GLboolean invert);
613     void scissor(GLint x, GLint y, GLsizei width, GLsizei height);
614     void shaderSource(WebGLShader? shader, DOMString string);
615     void stencilFunc(GLenum func, GLint ref, GLuint mask);
616     void stencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask);
617     void stencilMask(GLuint mask);
618     void stencilMaskSeparate(GLenum face, GLuint mask);
619     void stencilOp(GLenum fail, GLenum zfail, GLenum zpass);
620     void stencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass);
621 
622     void texParameterf(GLenum target, GLenum pname, GLfloat param);
623     void texParameteri(GLenum target, GLenum pname, GLint param);
624 
625     void uniform1f(WebGLUniformLocation? location, GLfloat x);
626     void uniform2f(WebGLUniformLocation? location, GLfloat x, GLfloat y);
627     void uniform3f(WebGLUniformLocation? location, GLfloat x, GLfloat y, GLfloat z);
628     void uniform4f(WebGLUniformLocation? location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
629 
630     void uniform1i(WebGLUniformLocation? location, GLint x);
631     void uniform2i(WebGLUniformLocation? location, GLint x, GLint y);
632     void uniform3i(WebGLUniformLocation? location, GLint x, GLint y, GLint z);
633     void uniform4i(WebGLUniformLocation? location, GLint x, GLint y, GLint z, GLint w);
634 
635     void uniform1fv(WebGLUniformLocation? location, Float32List v);
636     void uniform2fv(WebGLUniformLocation? location, Float32List v);
637     void uniform3fv(WebGLUniformLocation? location, Float32List v);
638     void uniform4fv(WebGLUniformLocation? location, Float32List v);
639 
640     void uniform1iv(WebGLUniformLocation? location, Int32List v);
641     void uniform2iv(WebGLUniformLocation? location, Int32List v);
642     void uniform3iv(WebGLUniformLocation? location, Int32List v);
643     void uniform4iv(WebGLUniformLocation? location, Int32List v);
644 
645     void uniformMatrix2fv(WebGLUniformLocation? location, GLboolean transpose, Float32List array);
646     void uniformMatrix3fv(WebGLUniformLocation? location, GLboolean transpose, Float32List array);
647     void uniformMatrix4fv(WebGLUniformLocation? location, GLboolean transpose, Float32List array);
648 
649     void useProgram(WebGLProgram? program);
650     void validateProgram(WebGLProgram? program);
651 
652     void vertexAttrib1f(GLuint index, GLfloat x);
653     void vertexAttrib2f(GLuint index, GLfloat x, GLfloat y);
654     void vertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z);
655     void vertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
656 
657     void vertexAttrib1fv(GLuint index, Float32List values);
658     void vertexAttrib2fv(GLuint index, Float32List values);
659     void vertexAttrib3fv(GLuint index, Float32List values);
660     void vertexAttrib4fv(GLuint index, Float32List values);
661 
662     void vertexAttribPointer(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset);
663 
664     void viewport(GLint x, GLint y, GLsizei width, GLsizei height);
665 };
    </pre>
  </body>
</html>
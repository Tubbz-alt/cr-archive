<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/LiteralParser.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LiteralParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Lookup.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/LiteralParser.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 75     const CharType* end;
 76     union {
 77         double numberToken;
 78         struct {
 79             union {
 80                 const LChar* stringToken8;
 81                 const UChar* stringToken16;
 82             };
 83             unsigned stringIs8Bit : 1;
 84             unsigned stringLength : 31;
 85         };
 86     };
 87 };
 88 
 89 template &lt;typename CharType&gt;
 90 ALWAYS_INLINE void setParserTokenString(LiteralParserToken&lt;CharType&gt;&amp;, const CharType* string);
 91 
 92 template &lt;typename CharType&gt;
 93 class LiteralParser {
 94 public:
<span class="line-modified"> 95     LiteralParser(ExecState* exec, const CharType* characters, unsigned length, ParserMode mode)</span>
<span class="line-modified"> 96         : m_exec(exec)</span>

 97         , m_lexer(characters, length, mode)
 98         , m_mode(mode)
 99     {
100     }
101 
102     String getErrorMessage()
103     {
104         if (!m_lexer.getErrorMessage().isEmpty())
105             return &quot;JSON Parse error: &quot; + m_lexer.getErrorMessage();
106         if (!m_parseErrorMessage.isEmpty())
107             return &quot;JSON Parse error: &quot; + m_parseErrorMessage;
108         return &quot;JSON Parse error: Unable to parse JSON string&quot;_s;
109     }
110 
111     JSValue tryLiteralParse()
112     {
113         m_lexer.next();
114         JSValue result = parse(m_mode == StrictJSON ? StartParseExpression : StartParseStatement);
115         if (m_lexer.currentToken()-&gt;type == TokSemi)
116             m_lexer.next();
117         if (m_lexer.currentToken()-&gt;type != TokEnd)
118             return JSValue();
119         return result;
120     }
121 
122     bool tryJSONPParse(Vector&lt;JSONPData&gt;&amp;, bool needsFullSourceInfo);
123 
124 private:
125     class Lexer {
126     public:
127         Lexer(const CharType* characters, unsigned length, ParserMode mode)
128             : m_mode(mode)
129             , m_ptr(characters)
130             , m_end(characters + length)
131         {
132         }
133 
134         TokenType next();
135 
<span class="line-modified">136 #if ASSERT_DISABLED</span>
137         typedef const LiteralParserToken&lt;CharType&gt;* LiteralParserTokenPtr;
138 
139         LiteralParserTokenPtr currentToken()
140         {
141             return &amp;m_currentToken;
142         }
143 #else
144         class LiteralParserTokenPtr;
145         friend class LiteralParserTokenPtr;
146         class LiteralParserTokenPtr {
147         public:
148             LiteralParserTokenPtr(Lexer&amp; lexer)
149                 : m_lexer(lexer)
150                 , m_tokenID(lexer.m_currentTokenID)
151             {
152             }
153 
154             ALWAYS_INLINE const LiteralParserToken&lt;CharType&gt;* operator-&gt;() const
155             {
156                 ASSERT(m_tokenID == m_lexer.m_currentTokenID);
157                 return &amp;m_lexer.m_currentToken;
158             }
159 
160         private:
161             Lexer&amp; m_lexer;
162             unsigned m_tokenID;
163         };
164 
165         LiteralParserTokenPtr currentToken()
166         {
167             return LiteralParserTokenPtr(*this);
168         }
<span class="line-modified">169 #endif</span>
170 
171         String getErrorMessage() { return m_lexErrorMessage; }
172 
173     private:
174         String m_lexErrorMessage;
175         TokenType lex(LiteralParserToken&lt;CharType&gt;&amp;);
176         ALWAYS_INLINE TokenType lexIdentifier(LiteralParserToken&lt;CharType&gt;&amp;);
177         ALWAYS_INLINE TokenType lexString(LiteralParserToken&lt;CharType&gt;&amp;, CharType terminator);
178         TokenType lexStringSlow(LiteralParserToken&lt;CharType&gt;&amp;, const CharType* runStart, CharType terminator);
179         ALWAYS_INLINE TokenType lexNumber(LiteralParserToken&lt;CharType&gt;&amp;);
180         LiteralParserToken&lt;CharType&gt; m_currentToken;
181         ParserMode m_mode;
182         const CharType* m_ptr;
183         const CharType* m_end;
184         StringBuilder m_builder;
<span class="line-modified">185 #if !ASSERT_DISABLED</span>
186         unsigned m_currentTokenID { 0 };
187 #endif
188     };
189 
190     class StackGuard;
191     JSValue parse(ParserState);
192 
<span class="line-modified">193     ExecState* m_exec;</span>

194     typename LiteralParser&lt;CharType&gt;::Lexer m_lexer;
195     ParserMode m_mode;
196     String m_parseErrorMessage;
197     static unsigned const MaximumCachableCharacter = 128;
198     std::array&lt;Identifier, MaximumCachableCharacter&gt; m_shortIdentifiers;
199     std::array&lt;Identifier, MaximumCachableCharacter&gt; m_recentIdentifiers;
200     ALWAYS_INLINE const Identifier makeIdentifier(const LChar* characters, size_t length);
201     ALWAYS_INLINE const Identifier makeIdentifier(const UChar* characters, size_t length);
202 };
203 
204 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 75     const CharType* end;
 76     union {
 77         double numberToken;
 78         struct {
 79             union {
 80                 const LChar* stringToken8;
 81                 const UChar* stringToken16;
 82             };
 83             unsigned stringIs8Bit : 1;
 84             unsigned stringLength : 31;
 85         };
 86     };
 87 };
 88 
 89 template &lt;typename CharType&gt;
 90 ALWAYS_INLINE void setParserTokenString(LiteralParserToken&lt;CharType&gt;&amp;, const CharType* string);
 91 
 92 template &lt;typename CharType&gt;
 93 class LiteralParser {
 94 public:
<span class="line-modified"> 95     LiteralParser(JSGlobalObject* globalObject, const CharType* characters, unsigned length, ParserMode mode, CodeBlock* nullOrCodeBlock = nullptr)</span>
<span class="line-modified"> 96         : m_globalObject(globalObject)</span>
<span class="line-added"> 97         , m_nullOrCodeBlock(nullOrCodeBlock)</span>
 98         , m_lexer(characters, length, mode)
 99         , m_mode(mode)
100     {
101     }
102 
103     String getErrorMessage()
104     {
105         if (!m_lexer.getErrorMessage().isEmpty())
106             return &quot;JSON Parse error: &quot; + m_lexer.getErrorMessage();
107         if (!m_parseErrorMessage.isEmpty())
108             return &quot;JSON Parse error: &quot; + m_parseErrorMessage;
109         return &quot;JSON Parse error: Unable to parse JSON string&quot;_s;
110     }
111 
112     JSValue tryLiteralParse()
113     {
114         m_lexer.next();
115         JSValue result = parse(m_mode == StrictJSON ? StartParseExpression : StartParseStatement);
116         if (m_lexer.currentToken()-&gt;type == TokSemi)
117             m_lexer.next();
118         if (m_lexer.currentToken()-&gt;type != TokEnd)
119             return JSValue();
120         return result;
121     }
122 
123     bool tryJSONPParse(Vector&lt;JSONPData&gt;&amp;, bool needsFullSourceInfo);
124 
125 private:
126     class Lexer {
127     public:
128         Lexer(const CharType* characters, unsigned length, ParserMode mode)
129             : m_mode(mode)
130             , m_ptr(characters)
131             , m_end(characters + length)
132         {
133         }
134 
135         TokenType next();
136 
<span class="line-modified">137 #if !ASSERT_ENABLED</span>
138         typedef const LiteralParserToken&lt;CharType&gt;* LiteralParserTokenPtr;
139 
140         LiteralParserTokenPtr currentToken()
141         {
142             return &amp;m_currentToken;
143         }
144 #else
145         class LiteralParserTokenPtr;
146         friend class LiteralParserTokenPtr;
147         class LiteralParserTokenPtr {
148         public:
149             LiteralParserTokenPtr(Lexer&amp; lexer)
150                 : m_lexer(lexer)
151                 , m_tokenID(lexer.m_currentTokenID)
152             {
153             }
154 
155             ALWAYS_INLINE const LiteralParserToken&lt;CharType&gt;* operator-&gt;() const
156             {
157                 ASSERT(m_tokenID == m_lexer.m_currentTokenID);
158                 return &amp;m_lexer.m_currentToken;
159             }
160 
161         private:
162             Lexer&amp; m_lexer;
163             unsigned m_tokenID;
164         };
165 
166         LiteralParserTokenPtr currentToken()
167         {
168             return LiteralParserTokenPtr(*this);
169         }
<span class="line-modified">170 #endif // ASSERT_ENABLED</span>
171 
172         String getErrorMessage() { return m_lexErrorMessage; }
173 
174     private:
175         String m_lexErrorMessage;
176         TokenType lex(LiteralParserToken&lt;CharType&gt;&amp;);
177         ALWAYS_INLINE TokenType lexIdentifier(LiteralParserToken&lt;CharType&gt;&amp;);
178         ALWAYS_INLINE TokenType lexString(LiteralParserToken&lt;CharType&gt;&amp;, CharType terminator);
179         TokenType lexStringSlow(LiteralParserToken&lt;CharType&gt;&amp;, const CharType* runStart, CharType terminator);
180         ALWAYS_INLINE TokenType lexNumber(LiteralParserToken&lt;CharType&gt;&amp;);
181         LiteralParserToken&lt;CharType&gt; m_currentToken;
182         ParserMode m_mode;
183         const CharType* m_ptr;
184         const CharType* m_end;
185         StringBuilder m_builder;
<span class="line-modified">186 #if ASSERT_ENABLED</span>
187         unsigned m_currentTokenID { 0 };
188 #endif
189     };
190 
191     class StackGuard;
192     JSValue parse(ParserState);
193 
<span class="line-modified">194     JSGlobalObject* m_globalObject;</span>
<span class="line-added">195     CodeBlock* m_nullOrCodeBlock;</span>
196     typename LiteralParser&lt;CharType&gt;::Lexer m_lexer;
197     ParserMode m_mode;
198     String m_parseErrorMessage;
199     static unsigned const MaximumCachableCharacter = 128;
200     std::array&lt;Identifier, MaximumCachableCharacter&gt; m_shortIdentifiers;
201     std::array&lt;Identifier, MaximumCachableCharacter&gt; m_recentIdentifiers;
202     ALWAYS_INLINE const Identifier makeIdentifier(const LChar* characters, size_t length);
203     ALWAYS_INLINE const Identifier makeIdentifier(const UChar* characters, size_t length);
204 };
205 
206 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="LiteralParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Lookup.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
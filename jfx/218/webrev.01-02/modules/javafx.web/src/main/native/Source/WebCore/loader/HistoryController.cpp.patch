diff a/modules/javafx.web/src/main/native/Source/WebCore/loader/HistoryController.cpp b/modules/javafx.web/src/main/native/Source/WebCore/loader/HistoryController.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/loader/HistoryController.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/loader/HistoryController.cpp
@@ -29,10 +29,11 @@
  */
 
 #include "config.h"
 #include "HistoryController.h"
 
+#include "BackForwardCache.h"
 #include "BackForwardController.h"
 #include "CachedPage.h"
 #include "Document.h"
 #include "DocumentLoader.h"
 #include "Frame.h"
@@ -42,11 +43,10 @@
 #include "FrameTree.h"
 #include "FrameView.h"
 #include "HistoryItem.h"
 #include "Logging.h"
 #include "Page.h"
-#include "PageCache.h"
 #include "ScrollingCoordinator.h"
 #include "SerializedScriptValue.h"
 #include "SharedStringHash.h"
 #include "ShouldTreatAsContinuingLoad.h"
 #include "VisitedLinkStore.h"
@@ -72,11 +72,11 @@
 {
     FrameView* frameView = m_frame.view();
     if (!item || !frameView)
         return;
 
-    if (m_frame.document()->pageCacheState() != Document::NotInPageCache)
+    if (m_frame.document()->backForwardCacheState() != Document::NotInBackForwardCache)
         item->setScrollPosition(frameView->cachedScrollPosition());
     else
         item->setScrollPosition(frameView->scrollPosition());
 
 #if PLATFORM(IOS_FAMILY)
@@ -135,13 +135,13 @@
         return;
 
     auto view = makeRefPtr(m_frame.view());
 
     // FIXME: There is some scrolling related work that needs to happen whenever a page goes into the
-    // page cache and similar work that needs to occur when it comes out. This is where we do the work
+    // back/forward cache and similar work that needs to occur when it comes out. This is where we do the work
     // that needs to happen when we exit, and the work that needs to happen when we enter is in
-    // Document::setIsInPageCache(bool). It would be nice if there was more symmetry in these spots.
+    // Document::setIsInBackForwardCache(bool). It would be nice if there was more symmetry in these spots.
     // https://bugs.webkit.org/show_bug.cgi?id=98698
     if (view) {
         Page* page = m_frame.page();
         if (page && m_frame.isMainFrame()) {
             if (ScrollingCoordinator* scrollingCoordinator = page->scrollingCoordinator())
@@ -259,22 +259,22 @@
 void HistoryController::invalidateCurrentItemCachedPage()
 {
     if (!currentItem())
         return;
 
-    // When we are pre-commit, the currentItem is where any page cache data resides.
-    std::unique_ptr<CachedPage> cachedPage = PageCache::singleton().take(*currentItem(), m_frame.page());
+    // When we are pre-commit, the currentItem is where any back/forward cache data resides.
+    std::unique_ptr<CachedPage> cachedPage = BackForwardCache::singleton().take(*currentItem(), m_frame.page());
     if (!cachedPage)
         return;
 
     // FIXME: This is a grotesque hack to fix <rdar://problem/4059059> Crash in RenderFlow::detach
     // Somehow the PageState object is not properly updated, and is holding onto a stale document.
     // Both Xcode and FileMaker see this crash, Safari does not.
 
     ASSERT(cachedPage->document() == m_frame.document());
     if (cachedPage->document() == m_frame.document()) {
-        cachedPage->document()->setPageCacheState(Document::NotInPageCache);
+        cachedPage->document()->setBackForwardCacheState(Document::NotInBackForwardCache);
         cachedPage->clear();
     }
 }
 
 bool HistoryController::shouldStopLoadingForHistoryItem(HistoryItem& targetItem) const
@@ -353,11 +353,11 @@
 void HistoryController::updateForReload()
 {
     LOG(History, "HistoryController %p updateForReload: Updating History for reload in frame %p (main frame %d) %s", this, &m_frame, m_frame.isMainFrame(), m_frame.loader().documentLoader() ? m_frame.loader().documentLoader()->url().string().utf8().data() : "");
 
     if (m_currentItem) {
-        PageCache::singleton().remove(*m_currentItem);
+        BackForwardCache::singleton().remove(*m_currentItem);
 
         if (m_frame.loader().loadType() == FrameLoadType::Reload || m_frame.loader().loadType() == FrameLoadType::ReloadFromOrigin)
             saveScrollPositionAndViewStateToItem(m_currentItem.get());
 
         // Rebuild the history item tree when reloading as trying to re-associate everything is too error-prone.
@@ -379,18 +379,18 @@
 {
     LOG(History, "HistoryController %p updateForStandardLoad: Updating History for standard load in frame %p (main frame %d) %s", this, &m_frame, m_frame.isMainFrame(), m_frame.loader().documentLoader()->url().string().ascii().data());
 
     FrameLoader& frameLoader = m_frame.loader();
 
-    bool needPrivacy = m_frame.page() ? m_frame.page()->usesEphemeralSession() : true;
+    bool usesEphemeralSession = m_frame.page() ? m_frame.page()->usesEphemeralSession() : true;
     const URL& historyURL = frameLoader.documentLoader()->urlForHistory();
 
     if (!frameLoader.documentLoader()->isClientRedirect()) {
         if (!historyURL.isEmpty()) {
             if (updateType != UpdateAllExceptBackForwardList)
                 updateBackForwardListClippedAtTarget(true);
-            if (!needPrivacy) {
+            if (!usesEphemeralSession) {
                 frameLoader.client().updateGlobalHistory();
                 frameLoader.documentLoader()->setDidCreateGlobalHistoryEntry(true);
                 if (frameLoader.documentLoader()->unreachableURL().isEmpty())
                     frameLoader.client().updateGlobalHistoryRedirectLinks();
             }
@@ -398,11 +398,11 @@
     } else {
         // The client redirect replaces the current history item.
         updateCurrentItem();
     }
 
-    if (!historyURL.isEmpty() && !needPrivacy) {
+    if (!historyURL.isEmpty() && !usesEphemeralSession) {
         if (Page* page = m_frame.page())
             addVisitedLink(*page, historyURL);
 
         if (!frameLoader.documentLoader()->didCreateGlobalHistoryEntry() && frameLoader.documentLoader()->unreachableURL().isEmpty() && !m_frame.document()->url().isEmpty())
             frameLoader.client().updateGlobalHistoryRedirectLinks();
@@ -411,18 +411,18 @@
 
 void HistoryController::updateForRedirectWithLockedBackForwardList()
 {
     LOG(History, "HistoryController %p updateForRedirectWithLockedBackForwardList: Updating History for redirect load in frame %p (main frame %d) %s", this, &m_frame, m_frame.isMainFrame(), m_frame.loader().documentLoader() ? m_frame.loader().documentLoader()->url().string().utf8().data() : "");
 
-    bool needPrivacy = m_frame.page() ? m_frame.page()->usesEphemeralSession() : true;
+    bool usesEphemeralSession = m_frame.page() ? m_frame.page()->usesEphemeralSession() : true;
     const URL& historyURL = m_frame.loader().documentLoader()->urlForHistory();
 
     if (m_frame.loader().documentLoader()->isClientRedirect()) {
         if (!m_currentItem && !m_frame.tree().parent()) {
             if (!historyURL.isEmpty()) {
                 updateBackForwardListClippedAtTarget(true);
-                if (!needPrivacy) {
+                if (!usesEphemeralSession) {
                     m_frame.loader().client().updateGlobalHistory();
                     m_frame.loader().documentLoader()->setDidCreateGlobalHistoryEntry(true);
                     if (m_frame.loader().documentLoader()->unreachableURL().isEmpty())
                         m_frame.loader().client().updateGlobalHistoryRedirectLinks();
                 }
@@ -434,11 +434,11 @@
         Frame* parentFrame = m_frame.tree().parent();
         if (parentFrame && parentFrame->loader().history().currentItem())
             parentFrame->loader().history().currentItem()->setChildItem(createItem());
     }
 
-    if (!historyURL.isEmpty() && !needPrivacy) {
+    if (!historyURL.isEmpty() && !usesEphemeralSession) {
         if (Page* page = m_frame.page())
             addVisitedLink(*page, historyURL);
 
         if (!m_frame.loader().documentLoader()->didCreateGlobalHistoryEntry() && m_frame.loader().documentLoader()->unreachableURL().isEmpty())
             m_frame.loader().client().updateGlobalHistoryRedirectLinks();
@@ -454,14 +454,14 @@
     if (m_currentItem) {
         m_currentItem->clearDocumentState();
         m_currentItem->clearScrollPosition();
     }
 
-    bool needPrivacy = m_frame.page() ? m_frame.page()->usesEphemeralSession() : true;
+    bool usesEphemeralSession = m_frame.page() ? m_frame.page()->usesEphemeralSession() : true;
     const URL& historyURL = m_frame.loader().documentLoader()->urlForHistory();
 
-    if (!historyURL.isEmpty() && !needPrivacy) {
+    if (!historyURL.isEmpty() && !usesEphemeralSession) {
         if (Page* page = m_frame.page())
             addVisitedLink(*page, historyURL);
     }
 }
 
@@ -549,19 +549,20 @@
 
     Page* page = m_frame.page();
     if (!page)
         return;
 
-    if (page->usesEphemeralSession())
-        return;
+    bool usesEphemeralSession = page->usesEphemeralSession();
+    if (!usesEphemeralSession)
+        addVisitedLink(*page, m_frame.document()->url());
 
-    addVisitedLink(*page, m_frame.document()->url());
     m_frame.mainFrame().loader().history().recursiveUpdateForSameDocumentNavigation();
 
     if (m_currentItem) {
         m_currentItem->setURL(m_frame.document()->url());
-        m_frame.loader().client().updateGlobalHistory();
+        if (!usesEphemeralSession)
+            m_frame.loader().client().updateGlobalHistory();
     }
 }
 
 void HistoryController::recursiveUpdateForSameDocumentNavigation()
 {

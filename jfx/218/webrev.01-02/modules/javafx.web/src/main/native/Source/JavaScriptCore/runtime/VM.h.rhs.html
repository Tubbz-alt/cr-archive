<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/VM.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2008-2020 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  *
   8  * 1.  Redistributions of source code must retain the above copyright
   9  *     notice, this list of conditions and the following disclaimer.
  10  * 2.  Redistributions in binary form must reproduce the above copyright
  11  *     notice, this list of conditions and the following disclaimer in the
  12  *     documentation and/or other materials provided with the distribution.
  13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  14  *     its contributors may be used to endorse or promote products derived
  15  *     from this software without specific prior written permission.
  16  *
  17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #pragma once
  30 
  31 #include &quot;CallData.h&quot;
  32 #include &quot;CodeSpecializationKind.h&quot;
  33 #include &quot;CompleteSubspace.h&quot;
  34 #include &quot;ConcurrentJSLock.h&quot;
  35 #include &quot;ControlFlowProfiler.h&quot;
  36 #include &quot;DateInstanceCache.h&quot;
  37 #include &quot;DeleteAllCodeEffort.h&quot;
  38 #include &quot;ExceptionEventLocation.h&quot;
  39 #include &quot;ExecutableAllocator.h&quot;
  40 #include &quot;FunctionHasExecutedCache.h&quot;
  41 #include &quot;FuzzerAgent.h&quot;
  42 #include &quot;Heap.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  43 #include &quot;Integrity.h&quot;</span>
  44 #include &quot;Intrinsic.h&quot;
  45 #include &quot;IsoCellSet.h&quot;
  46 #include &quot;IsoSubspace.h&quot;
  47 #include &quot;JITThunks.h&quot;
  48 #include &quot;JSCJSValue.h&quot;
  49 #include &quot;JSLock.h&quot;
  50 #include &quot;MacroAssemblerCodeRef.h&quot;
  51 #include &quot;Microtask.h&quot;
  52 #include &quot;NumericStrings.h&quot;
  53 #include &quot;SmallStrings.h&quot;
  54 #include &quot;Strong.h&quot;
  55 #include &quot;StructureCache.h&quot;
  56 #include &quot;SubspaceAccess.h&quot;
  57 #include &quot;VMTraps.h&quot;
  58 #include &quot;WasmContext.h&quot;
  59 #include &quot;Watchpoint.h&quot;
  60 #include &lt;wtf/BumpPointerAllocator.h&gt;
  61 #include &lt;wtf/CheckedArithmetic.h&gt;
  62 #include &lt;wtf/DateMath.h&gt;
  63 #include &lt;wtf/Deque.h&gt;
  64 #include &lt;wtf/DoublyLinkedList.h&gt;
  65 #include &lt;wtf/Forward.h&gt;
  66 #include &lt;wtf/Gigacage.h&gt;
  67 #include &lt;wtf/HashMap.h&gt;
  68 #include &lt;wtf/HashSet.h&gt;
  69 #include &lt;wtf/SetForScope.h&gt;
  70 #include &lt;wtf/StackBounds.h&gt;
  71 #include &lt;wtf/StackPointer.h&gt;
  72 #include &lt;wtf/Stopwatch.h&gt;
  73 #include &lt;wtf/ThreadSafeRefCounted.h&gt;
  74 #include &lt;wtf/ThreadSpecific.h&gt;
  75 #include &lt;wtf/UniqueArray.h&gt;
  76 #include &lt;wtf/text/SymbolRegistry.h&gt;
  77 #include &lt;wtf/text/WTFString.h&gt;
  78 #if ENABLE(REGEXP_TRACING)
  79 #include &lt;wtf/ListHashSet.h&gt;
  80 #endif
  81 
  82 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
  83 #include &lt;wtf/StackTrace.h&gt;
  84 #endif
  85 
  86 // Enable the Objective-C API for platforms with a modern runtime. This has to match exactly what we
  87 // have in JSBase.h.
  88 #if !defined(JSC_OBJC_API_ENABLED)
<a name="3" id="anc3"></a><span class="line-modified">  89 #if (defined(__clang__) &amp;&amp; defined(__APPLE__) &amp;&amp; (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) || (defined(TARGET_OS_IPHONE) &amp;&amp; TARGET_OS_IPHONE)))</span>
  90 #define JSC_OBJC_API_ENABLED 1
  91 #else
  92 #define JSC_OBJC_API_ENABLED 0
  93 #endif
  94 #endif
  95 
  96 namespace WTF {
  97 class SimpleStats;
  98 } // namespace WTF
  99 using WTF::SimpleStats;
 100 
 101 namespace JSC {
 102 
 103 class BuiltinExecutables;
 104 class BytecodeIntrinsicRegistry;
<a name="4" id="anc4"></a><span class="line-added"> 105 class CallFrame;</span>
<span class="line-added"> 106 struct CheckpointOSRExitSideState;</span>
 107 class CodeBlock;
 108 class CodeCache;
 109 class CommonIdentifiers;
 110 class CompactVariableMap;
<a name="5" id="anc5"></a><span class="line-added"> 111 class ConservativeRoots;</span>
 112 class CustomGetterSetter;
 113 class DOMAttributeGetterSetter;
<a name="6" id="anc6"></a><span class="line-modified"> 114 class DateInstance;</span>
<span class="line-added"> 115 class ErrorInstance;</span>
 116 class Exception;
 117 class ExceptionScope;
 118 class FastMallocAlignedMemoryAllocator;
 119 class GigacageAlignedMemoryAllocator;
 120 class HandleStack;
 121 class TypeProfiler;
 122 class TypeProfilerLog;
 123 class HasOwnPropertyCache;
 124 class HeapProfiler;
 125 class Identifier;
 126 class Interpreter;
<a name="7" id="anc7"></a><span class="line-added"> 127 class IntlCollator;</span>
<span class="line-added"> 128 class IntlDateTimeFormat;</span>
<span class="line-added"> 129 class IntlNumberFormat;</span>
<span class="line-added"> 130 class IntlPluralRules;</span>
<span class="line-added"> 131 class JSAPIGlobalObject;</span>
<span class="line-added"> 132 class JSAPIWrapperGlobalObject;</span>
<span class="line-added"> 133 class JSAPIWrapperObject;</span>
<span class="line-added"> 134 class JSCCallbackFunction;</span>
<span class="line-added"> 135 class JSCallbackConstructor;</span>
 136 class JSCustomGetterSetterFunction;
 137 class JSDestructibleObjectHeapCellType;
 138 class JSGlobalObject;
<a name="8" id="anc8"></a><span class="line-added"> 139 class JSGlobalLexicalEnvironment;</span>
<span class="line-added"> 140 class JSModuleNamespaceObject;</span>
<span class="line-added"> 141 class JSModuleRecord;</span>
<span class="line-added"> 142 class JSNativeStdFunction;</span>
<span class="line-added"> 143 class JSNonFinalObject;</span>
 144 class JSObject;
 145 class JSPromise;
 146 class JSPropertyNameEnumerator;
 147 class JSRunLoopTimer;
<a name="9" id="anc9"></a><span class="line-modified"> 148 class JSWeakMap;</span>
<span class="line-modified"> 149 class JSWeakSet;</span>
<span class="line-added"> 150 class JSWebAssemblyCodeBlock;</span>
<span class="line-added"> 151 class JSWebAssemblyGlobal;</span>
 152 class JSWebAssemblyInstance;
<a name="10" id="anc10"></a><span class="line-added"> 153 class JSWebAssemblyMemory;</span>
<span class="line-added"> 154 class JSWebAssemblyModule;</span>
<span class="line-added"> 155 class JSWebAssemblyTable;</span>
 156 class LLIntOffsetsExtractor;
 157 class NativeExecutable;
<a name="11" id="anc11"></a><span class="line-modified"> 158 class ObjCCallbackFunction;</span>
<span class="line-added"> 159 class PromiseTimer;</span>
 160 class RegExp;
 161 class RegExpCache;
 162 class Register;
 163 class RegisterAtOffsetList;
 164 #if ENABLE(SAMPLING_PROFILER)
 165 class SamplingProfiler;
 166 #endif
 167 class ShadowChicken;
 168 class ScriptExecutable;
 169 class SourceProvider;
 170 class SourceProviderCache;
 171 class StackFrame;
 172 class Structure;
 173 #if ENABLE(REGEXP_TRACING)
 174 class RegExp;
 175 #endif
 176 class Symbol;
 177 class TypedArrayController;
 178 class UnlinkedCodeBlock;
 179 class UnlinkedEvalCodeBlock;
 180 class UnlinkedFunctionExecutable;
 181 class UnlinkedProgramCodeBlock;
 182 class UnlinkedModuleProgramCodeBlock;
 183 class VirtualRegister;
 184 class VMEntryScope;
<a name="12" id="anc12"></a><span class="line-added"> 185 class TopLevelGlobalObjectScope;</span>
 186 class Watchdog;
 187 class Watchpoint;
 188 class WatchpointSet;
<a name="13" id="anc13"></a><span class="line-modified"> 189 class WebAssemblyFunction;</span>
<span class="line-added"> 190 class WebAssemblyModuleRecord;</span>
<span class="line-added"> 191 </span>
<span class="line-added"> 192 class IsoHeapCellType;</span>
<span class="line-added"> 193 template&lt;typename CellType&gt; class IsoInlinedHeapCellType;</span>
<span class="line-added"> 194 template&lt;typename Parent&gt; class JSCallbackObject;</span>
 195 
 196 #if ENABLE(FTL_JIT)
 197 namespace FTL {
 198 class Thunks;
 199 }
 200 #endif // ENABLE(FTL_JIT)
 201 namespace Profiler {
 202 class Database;
 203 }
 204 namespace DOMJIT {
 205 class Signature;
 206 }
 207 
 208 struct EntryFrame;
 209 struct HashTable;
 210 struct Instruction;
 211 struct ValueProfile;
 212 
<a name="14" id="anc14"></a>

 213 struct LocalTimeOffsetCache {
 214     LocalTimeOffsetCache()
 215         : start(0.0)
 216         , end(-1.0)
 217         , increment(0.0)
 218     {
 219     }
 220 
 221     void reset()
 222     {
 223         offset = LocalTimeOffset();
 224         start = 0.0;
 225         end = -1.0;
 226         increment = 0.0;
 227     }
 228 
 229     LocalTimeOffset offset;
 230     double start;
 231     double end;
 232     double increment;
 233 };
 234 
 235 class QueuedTask {
 236     WTF_MAKE_NONCOPYABLE(QueuedTask);
 237     WTF_MAKE_FAST_ALLOCATED;
 238 public:
 239     void run();
 240 
 241     QueuedTask(VM&amp; vm, JSGlobalObject* globalObject, Ref&lt;Microtask&gt;&amp;&amp; microtask)
 242         : m_globalObject(vm, globalObject)
 243         , m_microtask(WTFMove(microtask))
 244     {
 245     }
 246 
 247 private:
 248     Strong&lt;JSGlobalObject&gt; m_globalObject;
 249     Ref&lt;Microtask&gt; m_microtask;
 250 };
 251 
 252 class ConservativeRoots;
 253 
<a name="15" id="anc15"></a><span class="line-added"> 254 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(VM);</span>
<span class="line-added"> 255 </span>
 256 #if COMPILER(MSVC)
 257 #pragma warning(push)
 258 #pragma warning(disable: 4200) // Disable &quot;zero-sized array in struct/union&quot; warning
 259 #endif
 260 struct ScratchBuffer {
 261     ScratchBuffer()
 262     {
 263         u.m_activeLength = 0;
 264     }
 265 
 266     static ScratchBuffer* create(size_t size)
 267     {
<a name="16" id="anc16"></a><span class="line-modified"> 268         ScratchBuffer* result = new (VMMalloc::malloc(ScratchBuffer::allocationSize(size))) ScratchBuffer;</span>

 269         return result;
 270     }
 271 
 272     static size_t allocationSize(Checked&lt;size_t&gt; bufferSize) { return (sizeof(ScratchBuffer) + bufferSize).unsafeGet(); }
 273     void setActiveLength(size_t activeLength) { u.m_activeLength = activeLength; }
 274     size_t activeLength() const { return u.m_activeLength; };
 275     size_t* addressOfActiveLength() { return &amp;u.m_activeLength; };
 276     void* dataBuffer() { return m_buffer; }
 277 
 278     union {
 279         size_t m_activeLength;
 280         double pad; // Make sure m_buffer is double aligned.
 281     } u;
 282 #if CPU(MIPS) &amp;&amp; (defined WTF_MIPS_ARCH_REV &amp;&amp; WTF_MIPS_ARCH_REV == 2)
 283     alignas(8) void* m_buffer[0];
 284 #else
 285     void* m_buffer[0];
 286 #endif
 287 };
 288 #if COMPILER(MSVC)
 289 #pragma warning(pop)
 290 #endif
 291 
 292 class VM : public ThreadSafeRefCounted&lt;VM&gt;, public DoublyLinkedListNode&lt;VM&gt; {
 293 public:
 294     // WebCore has a one-to-one mapping of threads to VMs;
 295     // create() should only be called once
 296     // on a thread, this is the &#39;default&#39; VM (it uses the
 297     // thread&#39;s default string uniquing table from Thread::current()).
 298     // API contexts created using the new context group aware interface
 299     // create APIContextGroup objects which require less locking of JSC
 300     // than the old singleton APIShared VM created for use by
 301     // the original API.
 302     enum VMType { Default, APIContextGroup, APIShared };
 303 
 304     struct ClientData {
 305         JS_EXPORT_PRIVATE virtual ~ClientData() = 0;
 306     };
 307 
 308     bool isSharedInstance() { return vmType == APIShared; }
 309     bool usingAPI() { return vmType != Default; }
 310     JS_EXPORT_PRIVATE static bool sharedInstanceExists();
 311     JS_EXPORT_PRIVATE static VM&amp; sharedInstance();
 312 
 313     JS_EXPORT_PRIVATE static Ref&lt;VM&gt; create(HeapType = SmallHeap);
 314     static Ref&lt;VM&gt; createContextGroup(HeapType = SmallHeap);
 315     JS_EXPORT_PRIVATE ~VM();
 316 
 317     Watchdog&amp; ensureWatchdog();
 318     Watchdog* watchdog() { return m_watchdog.get(); }
 319 
 320     HeapProfiler* heapProfiler() const { return m_heapProfiler.get(); }
 321     JS_EXPORT_PRIVATE HeapProfiler&amp; ensureHeapProfiler();
 322 
 323 #if ENABLE(SAMPLING_PROFILER)
 324     SamplingProfiler* samplingProfiler() { return m_samplingProfiler.get(); }
 325     JS_EXPORT_PRIVATE SamplingProfiler&amp; ensureSamplingProfiler(RefPtr&lt;Stopwatch&gt;&amp;&amp;);
 326 #endif
 327 
 328     FuzzerAgent* fuzzerAgent() const { return m_fuzzerAgent.get(); }
 329     void setFuzzerAgent(std::unique_ptr&lt;FuzzerAgent&gt;&amp;&amp; fuzzerAgent)
 330     {
<a name="17" id="anc17"></a><span class="line-added"> 331         RELEASE_ASSERT_WITH_MESSAGE(!m_fuzzerAgent, &quot;Only one FuzzerAgent can be specified at a time.&quot;);</span>
 332         m_fuzzerAgent = WTFMove(fuzzerAgent);
 333     }
 334 
 335     static unsigned numberOfIDs() { return s_numberOfIDs.load(); }
 336     unsigned id() const { return m_id; }
 337     bool isEntered() const { return !!entryScope; }
 338 
 339     inline CallFrame* topJSCallFrame() const;
 340 
 341     // Global object in which execution began.
<a name="18" id="anc18"></a><span class="line-modified"> 342     JS_EXPORT_PRIVATE JSGlobalObject* deprecatedVMEntryGlobalObject(JSGlobalObject*) const;</span>
<span class="line-added"> 343 </span>
<span class="line-added"> 344     WeakRandom&amp; random() { return m_random; }</span>
<span class="line-added"> 345     Integrity::Random&amp; integrityRandom() { return m_integrityRandom; }</span>
 346 
 347 private:
 348     unsigned nextID();
 349 
 350     static Atomic&lt;unsigned&gt; s_numberOfIDs;
 351 
 352     unsigned m_id;
 353     RefPtr&lt;JSLock&gt; m_apiLock;
 354 #if USE(CF)
 355     // These need to be initialized before heap below.
 356     RetainPtr&lt;CFRunLoopRef&gt; m_runLoop;
 357 #endif
 358 
<a name="19" id="anc19"></a><span class="line-added"> 359     WeakRandom m_random;</span>
<span class="line-added"> 360     Integrity::Random m_integrityRandom;</span>
<span class="line-added"> 361 </span>
 362 public:
 363     Heap heap;
 364 
 365     std::unique_ptr&lt;FastMallocAlignedMemoryAllocator&gt; fastMallocAllocator;
 366     std::unique_ptr&lt;GigacageAlignedMemoryAllocator&gt; primitiveGigacageAllocator;
 367     std::unique_ptr&lt;GigacageAlignedMemoryAllocator&gt; jsValueGigacageAllocator;
 368 
 369     std::unique_ptr&lt;HeapCellType&gt; auxiliaryHeapCellType;
 370     std::unique_ptr&lt;HeapCellType&gt; immutableButterflyHeapCellType;
 371     std::unique_ptr&lt;HeapCellType&gt; cellHeapCellType;
 372     std::unique_ptr&lt;HeapCellType&gt; destructibleCellHeapCellType;
<a name="20" id="anc20"></a><span class="line-modified"> 373     std::unique_ptr&lt;IsoHeapCellType&gt; apiGlobalObjectHeapCellType;</span>
<span class="line-added"> 374     std::unique_ptr&lt;IsoHeapCellType&gt; callbackConstructorHeapCellType;</span>
<span class="line-added"> 375     std::unique_ptr&lt;IsoHeapCellType&gt; callbackGlobalObjectHeapCellType;</span>
<span class="line-added"> 376     std::unique_ptr&lt;IsoHeapCellType&gt; callbackObjectHeapCellType;</span>
<span class="line-added"> 377     std::unique_ptr&lt;IsoHeapCellType&gt; dateInstanceHeapCellType;</span>
<span class="line-added"> 378     std::unique_ptr&lt;IsoHeapCellType&gt; errorInstanceHeapCellType;</span>
<span class="line-added"> 379     std::unique_ptr&lt;IsoHeapCellType&gt; globalLexicalEnvironmentHeapCellType;</span>
<span class="line-added"> 380     std::unique_ptr&lt;IsoHeapCellType&gt; globalObjectHeapCellType;</span>
<span class="line-added"> 381     std::unique_ptr&lt;IsoHeapCellType&gt; jsModuleRecordHeapCellType;</span>
<span class="line-added"> 382     std::unique_ptr&lt;IsoHeapCellType&gt; moduleNamespaceObjectHeapCellType;</span>
<span class="line-added"> 383     std::unique_ptr&lt;IsoHeapCellType&gt; nativeStdFunctionHeapCellType;</span>
<span class="line-added"> 384     std::unique_ptr&lt;IsoInlinedHeapCellType&lt;JSString&gt;&gt; stringHeapCellType;</span>
<span class="line-added"> 385     std::unique_ptr&lt;IsoHeapCellType&gt; weakMapHeapCellType;</span>
<span class="line-added"> 386     std::unique_ptr&lt;IsoHeapCellType&gt; weakSetHeapCellType;</span>
 387     std::unique_ptr&lt;JSDestructibleObjectHeapCellType&gt; destructibleObjectHeapCellType;
<a name="21" id="anc21"></a><span class="line-added"> 388 #if JSC_OBJC_API_ENABLED</span>
<span class="line-added"> 389     std::unique_ptr&lt;IsoHeapCellType&gt; apiWrapperObjectHeapCellType;</span>
<span class="line-added"> 390     std::unique_ptr&lt;IsoHeapCellType&gt; objCCallbackFunctionHeapCellType;</span>
<span class="line-added"> 391 #endif</span>
<span class="line-added"> 392 #ifdef JSC_GLIB_API_ENABLED</span>
<span class="line-added"> 393     std::unique_ptr&lt;IsoHeapCellType&gt; apiWrapperObjectHeapCellType;</span>
<span class="line-added"> 394     std::unique_ptr&lt;IsoHeapCellType&gt; callbackAPIWrapperGlobalObjectHeapCellType;</span>
<span class="line-added"> 395     std::unique_ptr&lt;IsoHeapCellType&gt; jscCallbackFunctionHeapCellType;</span>
<span class="line-added"> 396 #endif</span>
<span class="line-added"> 397 #if ENABLE(INTL)</span>
<span class="line-added"> 398     std::unique_ptr&lt;IsoHeapCellType&gt; intlCollatorHeapCellType;</span>
<span class="line-added"> 399     std::unique_ptr&lt;IsoHeapCellType&gt; intlDateTimeFormatHeapCellType;</span>
<span class="line-added"> 400     std::unique_ptr&lt;IsoHeapCellType&gt; intlNumberFormatHeapCellType;</span>
<span class="line-added"> 401     std::unique_ptr&lt;IsoHeapCellType&gt; intlPluralRulesHeapCellType;</span>
<span class="line-added"> 402 #endif</span>
 403 #if ENABLE(WEBASSEMBLY)
<a name="22" id="anc22"></a><span class="line-modified"> 404     std::unique_ptr&lt;IsoHeapCellType&gt; webAssemblyCodeBlockHeapCellType;</span>
<span class="line-modified"> 405     std::unique_ptr&lt;IsoHeapCellType&gt; webAssemblyFunctionHeapCellType;</span>
<span class="line-added"> 406     std::unique_ptr&lt;IsoHeapCellType&gt; webAssemblyGlobalHeapCellType;</span>
<span class="line-added"> 407     std::unique_ptr&lt;IsoHeapCellType&gt; webAssemblyInstanceHeapCellType;</span>
<span class="line-added"> 408     std::unique_ptr&lt;IsoHeapCellType&gt; webAssemblyMemoryHeapCellType;</span>
<span class="line-added"> 409     std::unique_ptr&lt;IsoHeapCellType&gt; webAssemblyModuleHeapCellType;</span>
<span class="line-added"> 410     std::unique_ptr&lt;IsoHeapCellType&gt; webAssemblyModuleRecordHeapCellType;</span>
<span class="line-added"> 411     std::unique_ptr&lt;IsoHeapCellType&gt; webAssemblyTableHeapCellType;</span>
 412 #endif
 413 
 414     CompleteSubspace primitiveGigacageAuxiliarySpace; // Typed arrays, strings, bitvectors, etc go here.
 415     CompleteSubspace jsValueGigacageAuxiliarySpace; // Butterflies, arrays of JSValues, etc go here.
 416     CompleteSubspace immutableButterflyJSValueGigacageAuxiliarySpace; // JSImmutableButterfly goes here.
 417 
 418     // We make cross-cutting assumptions about typed arrays being in the primitive Gigacage and butterflies
 419     // being in the JSValue gigacage. For some types, it&#39;s super obvious where they should go, and so we
 420     // can hardcode that fact. But sometimes it&#39;s not clear, so we abstract it by having a Gigacage::Kind
 421     // constant somewhere.
 422     // FIXME: Maybe it would be better if everyone abstracted this?
 423     // https://bugs.webkit.org/show_bug.cgi?id=175248
 424     ALWAYS_INLINE CompleteSubspace&amp; gigacageAuxiliarySpace(Gigacage::Kind kind)
 425     {
 426         switch (kind) {
<a name="23" id="anc23"></a>

 427         case Gigacage::Primitive:
 428             return primitiveGigacageAuxiliarySpace;
 429         case Gigacage::JSValue:
 430             return jsValueGigacageAuxiliarySpace;
<a name="24" id="anc24"></a><span class="line-added"> 431         case Gigacage::NumberOfKinds:</span>
<span class="line-added"> 432             break;</span>
 433         }
 434         RELEASE_ASSERT_NOT_REACHED();
 435         return primitiveGigacageAuxiliarySpace;
 436     }
 437 
 438     // Whenever possible, use subspaceFor&lt;CellType&gt;(vm) to get one of these subspaces.
 439     CompleteSubspace cellSpace;
<a name="25" id="anc25"></a><span class="line-modified"> 440     CompleteSubspace variableSizedCellSpace; // FIXME: This space is problematic because we have things in here like DirectArguments and ScopedArguments; those should be split into JSValueOOB cells and JSValueStrict auxiliaries. https://bugs.webkit.org/show_bug.cgi?id=182858</span>


 441     CompleteSubspace destructibleObjectSpace;
<a name="26" id="anc26"></a>
 442 
<a name="27" id="anc27"></a><span class="line-added"> 443     IsoSubspace bigIntSpace;</span>
<span class="line-added"> 444     IsoSubspace calleeSpace;</span>
<span class="line-added"> 445     IsoSubspace clonedArgumentsSpace;</span>
<span class="line-added"> 446     IsoSubspace customGetterSetterSpace;</span>
<span class="line-added"> 447     IsoSubspace dateInstanceSpace;</span>
<span class="line-added"> 448     IsoSubspace domAttributeGetterSetterSpace;</span>
<span class="line-added"> 449     IsoSubspace exceptionSpace;</span>
 450     IsoSubspace executableToCodeBlockEdgeSpace;
 451     IsoSubspace functionSpace;
<a name="28" id="anc28"></a><span class="line-added"> 452     IsoSubspace getterSetterSpace;</span>
<span class="line-added"> 453     IsoSubspace globalLexicalEnvironmentSpace;</span>
 454     IsoSubspace internalFunctionSpace;
<a name="29" id="anc29"></a><span class="line-added"> 455     IsoSubspace jsProxySpace;</span>
 456     IsoSubspace nativeExecutableSpace;
<a name="30" id="anc30"></a><span class="line-added"> 457     IsoSubspace numberObjectSpace;</span>
<span class="line-added"> 458     IsoSubspace promiseSpace;</span>
<span class="line-added"> 459     IsoSubspace propertyNameEnumeratorSpace;</span>
 460     IsoSubspace propertyTableSpace;
<a name="31" id="anc31"></a><span class="line-added"> 461     IsoSubspace regExpSpace;</span>
<span class="line-added"> 462     IsoSubspace regExpObjectSpace;</span>
<span class="line-added"> 463     IsoSubspace ropeStringSpace;</span>
<span class="line-added"> 464     IsoSubspace scopedArgumentsSpace;</span>
<span class="line-added"> 465     IsoSubspace sparseArrayValueMapSpace;</span>
<span class="line-added"> 466     IsoSubspace stringSpace;</span>
<span class="line-added"> 467     IsoSubspace stringObjectSpace;</span>
<span class="line-added"> 468     IsoSubspace structureChainSpace;</span>
 469     IsoSubspace structureRareDataSpace;
 470     IsoSubspace structureSpace;
 471     IsoSubspace symbolTableSpace;
 472 
 473 #define DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(name) \
 474     template&lt;SubspaceAccess mode&gt; \
 475     IsoSubspace* name() \
 476     { \
 477         if (m_##name || mode == SubspaceAccess::Concurrently) \
 478             return m_##name.get(); \
 479         return name##Slow(); \
 480     } \
<a name="32" id="anc32"></a><span class="line-modified"> 481     JS_EXPORT_PRIVATE IsoSubspace* name##Slow(); \</span>
 482     std::unique_ptr&lt;IsoSubspace&gt; m_##name;
 483 
 484 
 485 #if JSC_OBJC_API_ENABLED
<a name="33" id="anc33"></a><span class="line-added"> 486     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(apiWrapperObjectSpace)</span>
 487     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(objCCallbackFunctionSpace)
 488 #endif
<a name="34" id="anc34"></a><span class="line-added"> 489 #ifdef JSC_GLIB_API_ENABLED</span>
<span class="line-added"> 490     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(apiWrapperObjectSpace)</span>
<span class="line-added"> 491     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(jscCallbackFunctionSpace)</span>
<span class="line-added"> 492     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(callbackAPIWrapperGlobalObjectSpace)</span>
<span class="line-added"> 493 #endif</span>
<span class="line-added"> 494     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(apiGlobalObjectSpace)</span>
<span class="line-added"> 495     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(apiValueWrapperSpace)</span>
<span class="line-added"> 496     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(arrayBufferSpace)</span>
<span class="line-added"> 497     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(arrayIteratorSpace)</span>
<span class="line-added"> 498     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(asyncGeneratorSpace)</span>
<span class="line-added"> 499     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(bigIntObjectSpace)</span>
<span class="line-added"> 500     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(booleanObjectSpace)</span>
 501     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(boundFunctionSpace)
<a name="35" id="anc35"></a><span class="line-added"> 502     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(callbackConstructorSpace)</span>
<span class="line-added"> 503     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(callbackGlobalObjectSpace)</span>
 504     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(callbackFunctionSpace)
<a name="36" id="anc36"></a><span class="line-added"> 505     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(callbackObjectSpace)</span>
 506     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(customGetterSetterFunctionSpace)
<a name="37" id="anc37"></a><span class="line-added"> 507     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(dataViewSpace)</span>
<span class="line-added"> 508     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(debuggerScopeSpace)</span>
 509     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(errorInstanceSpace)
<a name="38" id="anc38"></a><span class="line-added"> 510     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(float32ArraySpace)</span>
<span class="line-added"> 511     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(float64ArraySpace)</span>
<span class="line-added"> 512     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(functionRareDataSpace)</span>
<span class="line-added"> 513     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(generatorSpace)</span>
<span class="line-added"> 514     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(globalObjectSpace)</span>
<span class="line-added"> 515     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(int8ArraySpace)</span>
<span class="line-added"> 516     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(int16ArraySpace)</span>
<span class="line-added"> 517     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(int32ArraySpace)</span>
<span class="line-added"> 518     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(jsModuleRecordSpace)</span>
<span class="line-added"> 519     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(mapBucketSpace)</span>
<span class="line-added"> 520     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(mapIteratorSpace)</span>
<span class="line-added"> 521     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(mapSpace)</span>
<span class="line-added"> 522     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(moduleNamespaceObjectSpace)</span>
 523     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(nativeStdFunctionSpace)
<a name="39" id="anc39"></a><span class="line-added"> 524     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(proxyObjectSpace)</span>
 525     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(proxyRevokeSpace)
<a name="40" id="anc40"></a><span class="line-added"> 526     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(scopedArgumentsTableSpace)</span>
<span class="line-added"> 527     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(scriptFetchParametersSpace)</span>
<span class="line-added"> 528     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(scriptFetcherSpace)</span>
<span class="line-added"> 529     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(setBucketSpace)</span>
<span class="line-added"> 530     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(setIteratorSpace)</span>
<span class="line-added"> 531     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(setSpace)</span>
<span class="line-added"> 532     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(strictEvalActivationSpace)</span>
<span class="line-added"> 533     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(stringIteratorSpace)</span>
<span class="line-added"> 534     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(sourceCodeSpace)</span>
<span class="line-added"> 535     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(symbolSpace)</span>
<span class="line-added"> 536     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(symbolObjectSpace)</span>
<span class="line-added"> 537     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(templateObjectDescriptorSpace)</span>
<span class="line-added"> 538     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(uint8ArraySpace)</span>
<span class="line-added"> 539     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(uint8ClampedArraySpace)</span>
<span class="line-added"> 540     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(uint16ArraySpace)</span>
<span class="line-added"> 541     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(uint32ArraySpace)</span>
<span class="line-added"> 542     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(unlinkedEvalCodeBlockSpace)</span>
<span class="line-added"> 543     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(unlinkedFunctionCodeBlockSpace)</span>
<span class="line-added"> 544     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(unlinkedModuleProgramCodeBlockSpace)</span>
<span class="line-added"> 545     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(unlinkedProgramCodeBlockSpace)</span>
 546     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(weakObjectRefSpace)
 547     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(weakSetSpace)
 548     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(weakMapSpace)
<a name="41" id="anc41"></a><span class="line-added"> 549     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(withScopeSpace)</span>
<span class="line-added"> 550 #if ENABLE(INTL)</span>
<span class="line-added"> 551     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(intlCollatorSpace)</span>
<span class="line-added"> 552     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(intlDateTimeFormatSpace)</span>
<span class="line-added"> 553     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(intlNumberFormatSpace)</span>
<span class="line-added"> 554     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(intlPluralRulesSpace)</span>
<span class="line-added"> 555 #endif</span>
 556 #if ENABLE(WEBASSEMBLY)
<a name="42" id="anc42"></a><span class="line-added"> 557     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(jsToWasmICCalleeSpace)</span>
 558     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyCodeBlockSpace)
 559     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyFunctionSpace)
<a name="43" id="anc43"></a><span class="line-added"> 560     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyGlobalSpace)</span>
<span class="line-added"> 561     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyInstanceSpace)</span>
<span class="line-added"> 562     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyMemorySpace)</span>
<span class="line-added"> 563     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyModuleSpace)</span>
<span class="line-added"> 564     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyModuleRecordSpace)</span>
<span class="line-added"> 565     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyTableSpace)</span>
 566     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyWrapperFunctionSpace)
 567 #endif
 568 
 569 #undef DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER
 570 
 571     IsoCellSet executableToCodeBlockEdgesWithConstraints;
 572     IsoCellSet executableToCodeBlockEdgesWithFinalizers;
 573 
 574 #define DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER(name) \
 575     template&lt;SubspaceAccess mode&gt; \
 576     IsoSubspace* name() \
 577     { \
 578         if (auto* spaceAndSet = m_##name.get()) \
 579             return &amp;spaceAndSet-&gt;space; \
 580         if (mode == SubspaceAccess::Concurrently) \
 581             return nullptr; \
 582         return name##Slow(); \
 583     } \
 584     IsoSubspace* name##Slow(); \
 585     std::unique_ptr&lt;SpaceAndSet&gt; m_##name;
 586 
 587     struct SpaceAndSet {
 588         WTF_MAKE_STRUCT_FAST_ALLOCATED;
 589 
 590         IsoSubspace space;
 591         IsoCellSet set;
 592 
 593         template&lt;typename... Arguments&gt;
 594         SpaceAndSet(Arguments&amp;&amp;... arguments)
 595             : space(std::forward&lt;Arguments&gt;(arguments)...)
 596             , set(space)
 597         {
 598         }
 599 
 600         static IsoCellSet&amp; setFor(Subspace&amp; space)
 601         {
 602             return *bitwise_cast&lt;IsoCellSet*&gt;(
 603                 bitwise_cast&lt;char*&gt;(&amp;space) -
 604                 OBJECT_OFFSETOF(SpaceAndSet, space) +
 605                 OBJECT_OFFSETOF(SpaceAndSet, set));
 606         }
 607     };
 608 
 609     SpaceAndSet codeBlockSpace;
 610 
 611     template&lt;typename Func&gt;
 612     void forEachCodeBlockSpace(const Func&amp; func)
 613     {
 614         // This should not include webAssemblyCodeBlockSpace because this is about subsclasses of
 615         // JSC::CodeBlock.
 616         func(codeBlockSpace);
 617     }
 618 
 619     DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER(evalExecutableSpace)
 620     DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER(moduleProgramExecutableSpace)
 621     SpaceAndSet functionExecutableSpace;
 622     SpaceAndSet programExecutableSpace;
 623 
 624     template&lt;typename Func&gt;
 625     void forEachScriptExecutableSpace(const Func&amp; func)
 626     {
 627         if (m_evalExecutableSpace)
 628             func(*m_evalExecutableSpace);
 629         func(functionExecutableSpace);
 630         if (m_moduleProgramExecutableSpace)
 631             func(*m_moduleProgramExecutableSpace);
 632         func(programExecutableSpace);
 633     }
 634 
 635     SpaceAndSet unlinkedFunctionExecutableSpace;
 636 
 637 #undef DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER
 638 
 639     VMType vmType;
 640     ClientData* clientData;
<a name="44" id="anc44"></a><span class="line-modified"> 641     EntryFrame* topEntryFrame { nullptr };</span>
 642     // NOTE: When throwing an exception while rolling back the call frame, this may be equal to
 643     // topEntryFrame.
 644     // FIXME: This should be a void*, because it might not point to a CallFrame.
 645     // https://bugs.webkit.org/show_bug.cgi?id=160441
<a name="45" id="anc45"></a><span class="line-modified"> 646     CallFrame* topCallFrame { nullptr };</span>
 647 #if ENABLE(WEBASSEMBLY)
 648     Wasm::Context wasmContext;
 649 #endif
 650     Strong&lt;Structure&gt; structureStructure;
 651     Strong&lt;Structure&gt; structureRareDataStructure;
 652     Strong&lt;Structure&gt; terminatedExecutionErrorStructure;
 653     Strong&lt;Structure&gt; stringStructure;
 654     Strong&lt;Structure&gt; propertyNameEnumeratorStructure;
<a name="46" id="anc46"></a><span class="line-added"> 655     Strong&lt;Structure&gt; getterSetterStructure;</span>
 656     Strong&lt;Structure&gt; customGetterSetterStructure;
 657     Strong&lt;Structure&gt; domAttributeGetterSetterStructure;
 658     Strong&lt;Structure&gt; scopedArgumentsTableStructure;
 659     Strong&lt;Structure&gt; apiWrapperStructure;
 660     Strong&lt;Structure&gt; nativeExecutableStructure;
 661     Strong&lt;Structure&gt; evalExecutableStructure;
 662     Strong&lt;Structure&gt; programExecutableStructure;
 663     Strong&lt;Structure&gt; functionExecutableStructure;
 664 #if ENABLE(WEBASSEMBLY)
 665     Strong&lt;Structure&gt; webAssemblyCodeBlockStructure;
 666 #endif
 667     Strong&lt;Structure&gt; moduleProgramExecutableStructure;
 668     Strong&lt;Structure&gt; regExpStructure;
 669     Strong&lt;Structure&gt; symbolStructure;
 670     Strong&lt;Structure&gt; symbolTableStructure;
<a name="47" id="anc47"></a>
 671     Strong&lt;Structure&gt; immutableButterflyStructures[NumberOfCopyOnWriteIndexingModes];
 672     Strong&lt;Structure&gt; sourceCodeStructure;
 673     Strong&lt;Structure&gt; scriptFetcherStructure;
 674     Strong&lt;Structure&gt; scriptFetchParametersStructure;
 675     Strong&lt;Structure&gt; structureChainStructure;
 676     Strong&lt;Structure&gt; sparseArrayValueMapStructure;
 677     Strong&lt;Structure&gt; templateObjectDescriptorStructure;
<a name="48" id="anc48"></a>
 678     Strong&lt;Structure&gt; unlinkedFunctionExecutableStructure;
 679     Strong&lt;Structure&gt; unlinkedProgramCodeBlockStructure;
 680     Strong&lt;Structure&gt; unlinkedEvalCodeBlockStructure;
 681     Strong&lt;Structure&gt; unlinkedFunctionCodeBlockStructure;
 682     Strong&lt;Structure&gt; unlinkedModuleProgramCodeBlockStructure;
 683     Strong&lt;Structure&gt; propertyTableStructure;
 684     Strong&lt;Structure&gt; functionRareDataStructure;
 685     Strong&lt;Structure&gt; exceptionStructure;
<a name="49" id="anc49"></a>


 686     Strong&lt;Structure&gt; programCodeBlockStructure;
 687     Strong&lt;Structure&gt; moduleProgramCodeBlockStructure;
 688     Strong&lt;Structure&gt; evalCodeBlockStructure;
 689     Strong&lt;Structure&gt; functionCodeBlockStructure;
 690     Strong&lt;Structure&gt; hashMapBucketSetStructure;
 691     Strong&lt;Structure&gt; hashMapBucketMapStructure;
 692     Strong&lt;Structure&gt; bigIntStructure;
 693     Strong&lt;Structure&gt; executableToCodeBlockEdgeStructure;
 694 
 695     Strong&lt;Structure&gt; m_setIteratorStructure;
 696     Strong&lt;Structure&gt; m_mapIteratorStructure;
 697 
 698     Strong&lt;JSPropertyNameEnumerator&gt; m_emptyPropertyNameEnumerator;
 699 
 700     Strong&lt;JSCell&gt; m_sentinelSetBucket;
 701     Strong&lt;JSCell&gt; m_sentinelMapBucket;
 702 
<a name="50" id="anc50"></a><span class="line-modified"> 703     Weak&lt;NativeExecutable&gt; m_fastBoundExecutable;</span>
<span class="line-added"> 704     Weak&lt;NativeExecutable&gt; m_fastCanConstructBoundExecutable;</span>
<span class="line-added"> 705     Weak&lt;NativeExecutable&gt; m_slowBoundExecutable;</span>
<span class="line-added"> 706     Weak&lt;NativeExecutable&gt; m_slowCanConstructBoundExecutable;</span>
<span class="line-added"> 707 </span>
<span class="line-added"> 708     Ref&lt;PromiseTimer&gt; promiseTimer;</span>
 709 
 710     JSCell* currentlyDestructingCallbackObject;
 711     const ClassInfo* currentlyDestructingCallbackObjectClassInfo { nullptr };
 712 
 713     AtomStringTable* m_atomStringTable;
 714     WTF::SymbolRegistry m_symbolRegistry;
 715     CommonIdentifiers* propertyNames;
 716     const ArgList* emptyList;
 717     SmallStrings smallStrings;
 718     NumericStrings numericStrings;
 719     DateInstanceCache dateInstanceCache;
 720     std::unique_ptr&lt;SimpleStats&gt; machineCodeBytesPerBytecodeWordForBaselineJIT;
 721     WeakGCMap&lt;std::pair&lt;CustomGetterSetter*, int&gt;, JSCustomGetterSetterFunction&gt; customGetterSetterFunctionMap;
 722     WeakGCMap&lt;StringImpl*, JSString, PtrHash&lt;StringImpl*&gt;&gt; stringCache;
 723     Strong&lt;JSString&gt; lastCachedString;
 724 
 725     AtomStringTable* atomStringTable() const { return m_atomStringTable; }
 726     WTF::SymbolRegistry&amp; symbolRegistry() { return m_symbolRegistry; }
 727 
<a name="51" id="anc51"></a><span class="line-added"> 728     Strong&lt;JSBigInt&gt; bigIntConstantOne;</span>
<span class="line-added"> 729 </span>
 730     Structure* setIteratorStructure()
 731     {
 732         if (LIKELY(m_setIteratorStructure))
 733             return m_setIteratorStructure.get();
 734         return setIteratorStructureSlow();
 735     }
 736 
 737     Structure* mapIteratorStructure()
 738     {
 739         if (LIKELY(m_mapIteratorStructure))
 740             return m_mapIteratorStructure.get();
 741         return mapIteratorStructureSlow();
 742     }
 743 
 744     JSCell* sentinelSetBucket()
 745     {
 746         if (LIKELY(m_sentinelSetBucket))
 747             return m_sentinelSetBucket.get();
 748         return sentinelSetBucketSlow();
 749     }
 750 
 751     JSCell* sentinelMapBucket()
 752     {
 753         if (LIKELY(m_sentinelMapBucket))
 754             return m_sentinelMapBucket.get();
 755         return sentinelMapBucketSlow();
 756     }
 757 
 758     JSPropertyNameEnumerator* emptyPropertyNameEnumerator()
 759     {
 760         if (LIKELY(m_emptyPropertyNameEnumerator))
 761             return m_emptyPropertyNameEnumerator.get();
 762         return emptyPropertyNameEnumeratorSlow();
 763     }
 764 
 765     WeakGCMap&lt;SymbolImpl*, Symbol, PtrHash&lt;SymbolImpl*&gt;&gt; symbolImplToSymbolMap;
 766 
 767     enum class DeletePropertyMode {
 768         // Default behaviour of deleteProperty, matching the spec.
 769         Default,
 770         // This setting causes deleteProperty to force deletion of all
 771         // properties including those that are non-configurable (DontDelete).
 772         IgnoreConfigurable
 773     };
 774 
 775     DeletePropertyMode deletePropertyMode()
 776     {
 777         return m_deletePropertyMode;
 778     }
 779 
 780     class DeletePropertyModeScope {
 781     public:
 782         DeletePropertyModeScope(VM&amp; vm, DeletePropertyMode mode)
 783             : m_vm(vm)
 784             , m_previousMode(vm.m_deletePropertyMode)
 785         {
 786             m_vm.m_deletePropertyMode = mode;
 787         }
 788 
 789         ~DeletePropertyModeScope()
 790         {
 791             m_vm.m_deletePropertyMode = m_previousMode;
 792         }
 793 
 794     private:
 795         VM&amp; m_vm;
 796         DeletePropertyMode m_previousMode;
 797     };
 798 
 799     static JS_EXPORT_PRIVATE bool canUseAssembler();
 800     static bool isInMiniMode()
 801     {
 802         return !canUseJIT() || Options::forceMiniVMMode();
 803     }
 804 
 805     static bool useUnlinkedCodeBlockJettisoning()
 806     {
 807         return Options::useUnlinkedCodeBlockJettisoning() || isInMiniMode();
 808     }
 809 
 810     static void computeCanUseJIT();
 811     ALWAYS_INLINE static bool canUseJIT()
 812     {
 813 #if ENABLE(JIT)
<a name="52" id="anc52"></a><span class="line-modified"> 814         ASSERT(s_canUseJITIsSet);</span>


 815         return s_canUseJIT;
 816 #else
 817         return false;
 818 #endif
 819     }
 820 
 821     SourceProviderCache* addSourceProviderCache(SourceProvider*);
 822     void clearSourceProviderCaches();
 823 
 824     StructureCache structureCache;
 825 
 826     typedef HashMap&lt;RefPtr&lt;SourceProvider&gt;, RefPtr&lt;SourceProviderCache&gt;&gt; SourceProviderCacheMap;
 827     SourceProviderCacheMap sourceProviderCacheMap;
 828     Interpreter* interpreter;
 829 #if ENABLE(JIT)
 830     std::unique_ptr&lt;JITThunks&gt; jitStubs;
 831     MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; getCTIStub(ThunkGenerator generator)
 832     {
 833         return jitStubs-&gt;ctiStub(*this, generator);
 834     }
 835 
 836 #endif // ENABLE(JIT)
 837 #if ENABLE(FTL_JIT)
 838     std::unique_ptr&lt;FTL::Thunks&gt; ftlThunks;
 839 #endif
 840     NativeExecutable* getHostFunction(NativeFunction, NativeFunction constructor, const String&amp; name);
 841     NativeExecutable* getHostFunction(NativeFunction, Intrinsic, NativeFunction constructor, const DOMJIT::Signature*, const String&amp; name);
 842 
<a name="53" id="anc53"></a><span class="line-added"> 843     NativeExecutable* getBoundFunction(bool isJSFunction, bool canConstruct);</span>
<span class="line-added"> 844 </span>
 845     MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; getCTIInternalFunctionTrampolineFor(CodeSpecializationKind);
 846 
 847     static ptrdiff_t exceptionOffset()
 848     {
 849         return OBJECT_OFFSETOF(VM, m_exception);
 850     }
 851 
 852     static ptrdiff_t callFrameForCatchOffset()
 853     {
 854         return OBJECT_OFFSETOF(VM, callFrameForCatch);
 855     }
 856 
 857     static ptrdiff_t topEntryFrameOffset()
 858     {
 859         return OBJECT_OFFSETOF(VM, topEntryFrame);
 860     }
 861 
 862     static ptrdiff_t offsetOfHeapBarrierThreshold()
 863     {
 864         return OBJECT_OFFSETOF(VM, heap) + OBJECT_OFFSETOF(Heap, m_barrierThreshold);
 865     }
 866 
 867     static ptrdiff_t offsetOfHeapMutatorShouldBeFenced()
 868     {
 869         return OBJECT_OFFSETOF(VM, heap) + OBJECT_OFFSETOF(Heap, m_mutatorShouldBeFenced);
 870     }
 871 
 872     void restorePreviousException(Exception* exception) { setException(exception); }
 873 
 874     void clearLastException() { m_lastException = nullptr; }
 875 
<a name="54" id="anc54"></a><span class="line-modified"> 876     CallFrame** addressOfCallFrameForCatch() { return &amp;callFrameForCatch; }</span>
 877 
 878     JSCell** addressOfException() { return reinterpret_cast&lt;JSCell**&gt;(&amp;m_exception); }
 879 
 880     Exception* lastException() const { return m_lastException; }
 881     JSCell** addressOfLastException() { return reinterpret_cast&lt;JSCell**&gt;(&amp;m_lastException); }
 882 
 883     // This should only be used for test or assertion code that wants to inspect
 884     // the pending exception without interfering with Throw/CatchScopes.
 885     Exception* exceptionForInspection() const { return m_exception; }
 886 
 887     void setFailNextNewCodeBlock() { m_failNextNewCodeBlock = true; }
 888     bool getAndClearFailNextNewCodeBlock()
 889     {
 890         bool result = m_failNextNewCodeBlock;
 891         m_failNextNewCodeBlock = false;
 892         return result;
 893     }
 894 
 895     ALWAYS_INLINE Structure* getStructure(StructureID id)
 896     {
 897         return heap.structureIDTable().get(decontaminate(id));
 898     }
 899 
 900     void* stackPointerAtVMEntry() const { return m_stackPointerAtVMEntry; }
 901     void setStackPointerAtVMEntry(void*);
 902 
 903     size_t softReservedZoneSize() const { return m_currentSoftReservedZoneSize; }
 904     size_t updateSoftReservedZoneSize(size_t softReservedZoneSize);
 905 
 906     static size_t committedStackByteCount();
 907     inline bool ensureStackCapacityFor(Register* newTopOfStack);
 908 
 909     void* stackLimit() { return m_stackLimit; }
 910     void* softStackLimit() { return m_softStackLimit; }
 911     void** addressOfSoftStackLimit() { return &amp;m_softStackLimit; }
 912 #if ENABLE(C_LOOP)
 913     void* cloopStackLimit() { return m_cloopStackLimit; }
 914     void setCLoopStackLimit(void* limit) { m_cloopStackLimit = limit; }
 915     JS_EXPORT_PRIVATE void* currentCLoopStackPointer() const;
 916 #endif
 917 
 918     inline bool isSafeToRecurseSoft() const;
 919     bool isSafeToRecurse() const
 920     {
 921         return isSafeToRecurse(m_stackLimit);
 922     }
 923 
 924     void** addressOfLastStackTop() { return &amp;m_lastStackTop; }
 925     void* lastStackTop() { return m_lastStackTop; }
 926     void setLastStackTop(void*);
 927 
 928     void firePrimitiveGigacageEnabledIfNecessary()
 929     {
 930         if (m_needToFirePrimitiveGigacageEnabled) {
 931             m_needToFirePrimitiveGigacageEnabled = false;
 932             m_primitiveGigacageEnabled.fireAll(*this, &quot;Primitive gigacage disabled asynchronously&quot;);
 933         }
 934     }
 935 
 936     JSValue hostCallReturnValue;
 937     unsigned varargsLength;
<a name="55" id="anc55"></a><span class="line-modified"> 938     CallFrame* newCallFrameReturnValue;</span>
<span class="line-modified"> 939     CallFrame* callFrameForCatch;</span>
 940     void* targetMachinePCForThrow;
 941     const Instruction* targetInterpreterPCForThrow;
 942     uint32_t osrExitIndex;
 943     void* osrExitJumpDestination;
 944     bool isExecutingInRegExpJIT { false };
 945 
 946     // The threading protocol here is as follows:
 947     // - You can call scratchBufferForSize from any thread.
 948     // - You can only set the ScratchBuffer&#39;s activeLength from the main thread.
 949     // - You can only write to entries in the ScratchBuffer from the main thread.
 950     ScratchBuffer* scratchBufferForSize(size_t size);
 951     void clearScratchBuffers();
 952 
 953     EncodedJSValue* exceptionFuzzingBuffer(size_t size)
 954     {
 955         ASSERT(Options::useExceptionFuzz());
 956         if (!m_exceptionFuzzBuffer)
<a name="56" id="anc56"></a><span class="line-modified"> 957             m_exceptionFuzzBuffer = MallocPtr&lt;EncodedJSValue, VMMalloc&gt;::malloc(size);</span>
 958         return m_exceptionFuzzBuffer.get();
 959     }
 960 
 961     void gatherScratchBufferRoots(ConservativeRoots&amp;);
 962 
<a name="57" id="anc57"></a><span class="line-added"> 963     void addCheckpointOSRSideState(CallFrame*, std::unique_ptr&lt;CheckpointOSRExitSideState&gt;&amp;&amp;);</span>
<span class="line-added"> 964     std::unique_ptr&lt;CheckpointOSRExitSideState&gt; findCheckpointOSRSideState(CallFrame*);</span>
<span class="line-added"> 965     bool hasCheckpointOSRSideState() const { return m_checkpointSideState.size(); }</span>
<span class="line-added"> 966     void scanSideState(ConservativeRoots&amp;) const;</span>
<span class="line-added"> 967 </span>
 968     VMEntryScope* entryScope;
 969 
 970     JSObject* stringRecursionCheckFirstObject { nullptr };
 971     HashSet&lt;JSObject*&gt; stringRecursionCheckVisitedObjects;
 972 
 973     LocalTimeOffsetCache utcTimeOffsetCache;
 974     LocalTimeOffsetCache localTimeOffsetCache;
 975 
 976     String cachedDateString;
 977     double cachedDateStringValue;
 978 
 979     std::unique_ptr&lt;Profiler::Database&gt; m_perBytecodeProfiler;
 980     RefPtr&lt;TypedArrayController&gt; m_typedArrayController;
 981     RegExpCache* m_regExpCache;
 982     BumpPointerAllocator m_regExpAllocator;
 983     ConcurrentJSLock m_regExpAllocatorLock;
 984 
 985 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
 986     static constexpr size_t patternContextBufferSize = 8192; // Space allocated to save nested parenthesis context
 987     UniqueArray&lt;char&gt; m_regExpPatternContexBuffer;
 988     Lock m_regExpPatternContextLock;
 989     char* acquireRegExpPatternContexBuffer();
 990     void releaseRegExpPatternContexBuffer();
 991 #else
 992     static constexpr size_t patternContextBufferSize = 0; // Space allocated to save nested parenthesis context
 993 #endif
 994 
 995     Ref&lt;CompactVariableMap&gt; m_compactVariableMap;
 996 
 997     std::unique_ptr&lt;HasOwnPropertyCache&gt; m_hasOwnPropertyCache;
 998     ALWAYS_INLINE HasOwnPropertyCache* hasOwnPropertyCache() { return m_hasOwnPropertyCache.get(); }
 999     HasOwnPropertyCache* ensureHasOwnPropertyCache();
1000 
1001 #if ENABLE(REGEXP_TRACING)
1002     typedef ListHashSet&lt;RegExp*&gt; RTTraceList;
1003     RTTraceList* m_rtTraceList;
1004 #endif
1005 
1006     JS_EXPORT_PRIVATE void resetDateCache();
1007 
1008     RegExpCache* regExpCache() { return m_regExpCache; }
1009 #if ENABLE(REGEXP_TRACING)
1010     void addRegExpToTrace(RegExp*);
1011 #endif
1012     JS_EXPORT_PRIVATE void dumpRegExpTrace();
1013 
1014     bool isCollectorBusyOnCurrentThread() { return heap.isCurrentThreadBusy(); }
1015 
1016 #if ENABLE(GC_VALIDATION)
1017     bool isInitializingObject() const;
1018     void setInitializingObjectClass(const ClassInfo*);
1019 #endif
1020 
1021     bool currentThreadIsHoldingAPILock() const { return m_apiLock-&gt;currentThreadIsHoldingLock(); }
1022 
1023     JSLock&amp; apiLock() { return *m_apiLock; }
1024     CodeCache* codeCache() { return m_codeCache.get(); }
1025 
1026     JS_EXPORT_PRIVATE void whenIdle(Function&lt;void()&gt;&amp;&amp;);
1027 
1028     JS_EXPORT_PRIVATE void deleteAllCode(DeleteAllCodeEffort);
1029     JS_EXPORT_PRIVATE void deleteAllLinkedCode(DeleteAllCodeEffort);
1030 
1031     void shrinkFootprintWhenIdle();
1032 
<a name="58" id="anc58"></a><span class="line-modified">1033     WatchpointSet* ensureWatchpointSetForImpureProperty(UniquedStringImpl*);</span>

1034 
1035     // FIXME: Use AtomString once it got merged with Identifier.
<a name="59" id="anc59"></a><span class="line-modified">1036     JS_EXPORT_PRIVATE void addImpureProperty(UniquedStringImpl*);</span>
1037 
1038     InlineWatchpointSet&amp; primitiveGigacageEnabled() { return m_primitiveGigacageEnabled; }
1039 
1040     BuiltinExecutables* builtinExecutables() { return m_builtinExecutables.get(); }
1041 
1042     bool enableTypeProfiler();
1043     bool disableTypeProfiler();
1044     TypeProfilerLog* typeProfilerLog() { return m_typeProfilerLog.get(); }
1045     TypeProfiler* typeProfiler() { return m_typeProfiler.get(); }
1046     JS_EXPORT_PRIVATE void dumpTypeProfilerData();
1047 
1048     FunctionHasExecutedCache* functionHasExecutedCache() { return &amp;m_functionHasExecutedCache; }
1049 
1050     ControlFlowProfiler* controlFlowProfiler() { return m_controlFlowProfiler.get(); }
1051     bool enableControlFlowProfiler();
1052     bool disableControlFlowProfiler();
1053 
1054     void queueMicrotask(JSGlobalObject&amp;, Ref&lt;Microtask&gt;&amp;&amp;);
1055     JS_EXPORT_PRIVATE void drainMicrotasks();
1056     void setOnEachMicrotaskTick(WTF::Function&lt;void(VM&amp;)&gt;&amp;&amp; func) { m_onEachMicrotaskTick = WTFMove(func); }
1057     void finalizeSynchronousJSExecution() { ASSERT(currentThreadIsHoldingAPILock()); m_currentWeakRefVersion++; }
1058     uintptr_t currentWeakRefVersion() const { return m_currentWeakRefVersion; }
1059 
1060     void setGlobalConstRedeclarationShouldThrow(bool globalConstRedeclarationThrow) { m_globalConstRedeclarationShouldThrow = globalConstRedeclarationThrow; }
1061     ALWAYS_INLINE bool globalConstRedeclarationShouldThrow() const { return m_globalConstRedeclarationShouldThrow; }
1062 
1063     void setShouldBuildPCToCodeOriginMapping() { m_shouldBuildPCToCodeOriginMapping = true; }
1064     bool shouldBuilderPCToCodeOriginMapping() const { return m_shouldBuildPCToCodeOriginMapping; }
1065 
1066     BytecodeIntrinsicRegistry&amp; bytecodeIntrinsicRegistry() { return *m_bytecodeIntrinsicRegistry; }
1067 
1068     ShadowChicken* shadowChicken() { return m_shadowChicken.get(); }
1069     void ensureShadowChicken();
1070 
1071     template&lt;typename Func&gt;
1072     void logEvent(CodeBlock*, const char* summary, const Func&amp; func);
1073 
1074     Optional&lt;RefPtr&lt;Thread&gt;&gt; ownerThread() const { return m_apiLock-&gt;ownerThread(); }
1075 
1076     VMTraps&amp; traps() { return m_traps; }
1077 
<a name="60" id="anc60"></a><span class="line-modified">1078     void handleTraps(JSGlobalObject* globalObject, CallFrame* callFrame, VMTraps::Mask mask = VMTraps::Mask::allEventTypes()) { m_traps.handleTraps(globalObject, callFrame, mask); }</span>
1079 
1080     bool needTrapHandling() { return m_traps.needTrapHandling(); }
1081     bool needTrapHandling(VMTraps::Mask mask) { return m_traps.needTrapHandling(mask); }
1082     void* needTrapHandlingAddress() { return m_traps.needTrapHandlingAddress(); }
1083 
1084     void notifyNeedDebuggerBreak() { m_traps.fireTrap(VMTraps::NeedDebuggerBreak); }
<a name="61" id="anc61"></a><span class="line-added">1085     void notifyNeedShellTimeoutCheck() { m_traps.fireTrap(VMTraps::NeedShellTimeoutCheck); }</span>
1086     void notifyNeedTermination() { m_traps.fireTrap(VMTraps::NeedTermination); }
1087     void notifyNeedWatchdogCheck() { m_traps.fireTrap(VMTraps::NeedWatchdogCheck); }
1088 
1089     void promiseRejected(JSPromise*);
1090 
1091 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
1092     StackTrace* nativeStackTraceOfLastThrow() const { return m_nativeStackTraceOfLastThrow.get(); }
1093     Thread* throwingThread() const { return m_throwingThread.get(); }
1094     bool needExceptionCheck() const { return m_needExceptionCheck; }
1095 #endif
1096 
1097 #if USE(CF)
1098     CFRunLoopRef runLoop() const { return m_runLoop.get(); }
1099     JS_EXPORT_PRIVATE void setRunLoop(CFRunLoopRef);
1100 #endif // USE(CF)
1101 
1102     static void setCrashOnVMCreation(bool);
1103 
1104     class DeferExceptionScope {
1105     public:
1106         DeferExceptionScope(VM&amp; vm)
1107             : m_savedException(vm.m_exception, nullptr)
1108             , m_savedLastException(vm.m_lastException, nullptr)
1109         {
1110         }
1111 
1112     private:
1113         SetForScope&lt;Exception*&gt; m_savedException;
1114         SetForScope&lt;Exception*&gt; m_savedLastException;
1115     };
1116 
1117 private:
1118     friend class LLIntOffsetsExtractor;
1119 
1120     VM(VMType, HeapType);
1121     static VM*&amp; sharedInstanceInternal();
1122     void createNativeThunk();
1123 
1124     JS_EXPORT_PRIVATE Structure* setIteratorStructureSlow();
1125     JS_EXPORT_PRIVATE Structure* mapIteratorStructureSlow();
1126     JSCell* sentinelSetBucketSlow();
1127     JSCell* sentinelMapBucketSlow();
1128     JSPropertyNameEnumerator* emptyPropertyNameEnumeratorSlow();
1129 
1130     void updateStackLimits();
1131 
1132     bool isSafeToRecurse(void* stackLimit) const
1133     {
<a name="62" id="anc62"></a>
1134         void* curr = currentStackPointer();
1135         return curr &gt;= stackLimit;
1136     }
1137 
1138     void setException(Exception* exception)
1139     {
1140         m_exception = exception;
1141         m_lastException = exception;
1142     }
1143     Exception* exception() const
1144     {
1145 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
1146         m_needExceptionCheck = false;
1147 #endif
1148         return m_exception;
1149     }
1150     void clearException()
1151     {
1152 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
1153         m_needExceptionCheck = false;
1154         m_nativeStackTraceOfLastThrow = nullptr;
1155         m_throwingThread = nullptr;
1156 #endif
1157         m_exception = nullptr;
1158     }
1159 
1160 #if ENABLE(C_LOOP)
1161     bool ensureStackCapacityForCLoop(Register* newTopOfStack);
1162     bool isSafeToRecurseSoftCLoop() const;
1163 #endif // ENABLE(C_LOOP)
1164 
<a name="63" id="anc63"></a><span class="line-modified">1165     JS_EXPORT_PRIVATE Exception* throwException(JSGlobalObject*, Exception*);</span>
<span class="line-modified">1166     JS_EXPORT_PRIVATE Exception* throwException(JSGlobalObject*, JSValue);</span>
<span class="line-modified">1167     JS_EXPORT_PRIVATE Exception* throwException(JSGlobalObject*, JSObject*);</span>
1168 
1169 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
1170     void verifyExceptionCheckNeedIsSatisfied(unsigned depth, ExceptionEventLocation&amp;);
1171 #endif
1172 
1173     static void primitiveGigacageDisabledCallback(void*);
1174     void primitiveGigacageDisabled();
1175 
1176     void callPromiseRejectionCallback(Strong&lt;JSPromise&gt;&amp;);
1177     void didExhaustMicrotaskQueue();
1178 
1179 #if ENABLE(GC_VALIDATION)
1180     const ClassInfo* m_initializingObjectClass;
1181 #endif
1182 
1183     void* m_stackPointerAtVMEntry;
1184     size_t m_currentSoftReservedZoneSize;
1185     void* m_stackLimit { nullptr };
1186     void* m_softStackLimit { nullptr };
1187 #if ENABLE(C_LOOP)
1188     void* m_cloopStackLimit { nullptr };
1189 #endif
1190     void* m_lastStackTop { nullptr };
1191 
1192     Exception* m_exception { nullptr };
1193     Exception* m_lastException { nullptr };
1194 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
1195     ExceptionScope* m_topExceptionScope { nullptr };
1196     ExceptionEventLocation m_simulatedThrowPointLocation;
1197     unsigned m_simulatedThrowPointRecursionDepth { 0 };
1198     mutable bool m_needExceptionCheck { false };
1199     std::unique_ptr&lt;StackTrace&gt; m_nativeStackTraceOfLastThrow;
1200     std::unique_ptr&lt;StackTrace&gt; m_nativeStackTraceOfLastSimulatedThrow;
1201     RefPtr&lt;Thread&gt; m_throwingThread;
1202 #endif
1203 
1204     bool m_failNextNewCodeBlock { false };
1205     DeletePropertyMode m_deletePropertyMode { DeletePropertyMode::Default };
1206     bool m_globalConstRedeclarationShouldThrow { true };
1207     bool m_shouldBuildPCToCodeOriginMapping { false };
1208     std::unique_ptr&lt;CodeCache&gt; m_codeCache;
1209     std::unique_ptr&lt;BuiltinExecutables&gt; m_builtinExecutables;
<a name="64" id="anc64"></a><span class="line-modified">1210     HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, RefPtr&lt;WatchpointSet&gt;&gt; m_impurePropertyWatchpointSets;</span>
1211     std::unique_ptr&lt;TypeProfiler&gt; m_typeProfiler;
1212     std::unique_ptr&lt;TypeProfilerLog&gt; m_typeProfilerLog;
1213     unsigned m_typeProfilerEnabledCount;
1214     bool m_needToFirePrimitiveGigacageEnabled { false };
1215     Lock m_scratchBufferLock;
1216     Vector&lt;ScratchBuffer*&gt; m_scratchBuffers;
1217     size_t m_sizeOfLastScratchBuffer { 0 };
<a name="65" id="anc65"></a><span class="line-added">1218     HashMap&lt;CallFrame*, std::unique_ptr&lt;CheckpointOSRExitSideState&gt;&gt; m_checkpointSideState;</span>
1219     InlineWatchpointSet m_primitiveGigacageEnabled;
1220     FunctionHasExecutedCache m_functionHasExecutedCache;
1221     std::unique_ptr&lt;ControlFlowProfiler&gt; m_controlFlowProfiler;
1222     unsigned m_controlFlowProfilerEnabledCount;
1223     Deque&lt;std::unique_ptr&lt;QueuedTask&gt;&gt; m_microtaskQueue;
<a name="66" id="anc66"></a><span class="line-modified">1224     MallocPtr&lt;EncodedJSValue, VMMalloc&gt; m_exceptionFuzzBuffer;</span>
1225     VMTraps m_traps;
1226     RefPtr&lt;Watchdog&gt; m_watchdog;
1227     std::unique_ptr&lt;HeapProfiler&gt; m_heapProfiler;
1228 #if ENABLE(SAMPLING_PROFILER)
1229     RefPtr&lt;SamplingProfiler&gt; m_samplingProfiler;
1230 #endif
1231     std::unique_ptr&lt;FuzzerAgent&gt; m_fuzzerAgent;
1232     std::unique_ptr&lt;ShadowChicken&gt; m_shadowChicken;
1233     std::unique_ptr&lt;BytecodeIntrinsicRegistry&gt; m_bytecodeIntrinsicRegistry;
1234 
1235     // FIXME: We should remove handled promises from this list at GC flip. &lt;https://webkit.org/b/201005&gt;
1236     Vector&lt;Strong&lt;JSPromise&gt;&gt; m_aboutToBeNotifiedRejectedPromises;
1237 
1238     WTF::Function&lt;void(VM&amp;)&gt; m_onEachMicrotaskTick;
1239     uintptr_t m_currentWeakRefVersion { 0 };
1240 
1241 #if ENABLE(JIT)
<a name="67" id="anc67"></a><span class="line-modified">1242 #if ASSERT_ENABLED</span>
1243     JS_EXPORT_PRIVATE static bool s_canUseJITIsSet;
1244 #endif
1245     JS_EXPORT_PRIVATE static bool s_canUseJIT;
1246 #endif
1247 
1248     VM* m_prev; // Required by DoublyLinkedListNode.
1249     VM* m_next; // Required by DoublyLinkedListNode.
1250 
1251     // Friends for exception checking purpose only.
1252     friend class Heap;
1253     friend class CatchScope;
1254     friend class ExceptionScope;
<a name="68" id="anc68"></a><span class="line-added">1255     friend class JSDollarVMHelper;</span>
1256     friend class ThrowScope;
1257     friend class VMTraps;
1258     friend class WTF::DoublyLinkedListNode&lt;VM&gt;;
1259 };
1260 
1261 #if ENABLE(GC_VALIDATION)
1262 inline bool VM::isInitializingObject() const
1263 {
1264     return !!m_initializingObjectClass;
1265 }
1266 
1267 inline void VM::setInitializingObjectClass(const ClassInfo* initializingObjectClass)
1268 {
1269     m_initializingObjectClass = initializingObjectClass;
1270 }
1271 #endif
1272 
1273 inline Heap* WeakSet::heap() const
1274 {
<a name="69" id="anc69"></a><span class="line-modified">1275     return &amp;m_vm-&gt;heap;</span>
1276 }
1277 
1278 #if !ENABLE(C_LOOP)
1279 extern &quot;C&quot; void sanitizeStackForVMImpl(VM*);
1280 #endif
1281 
1282 JS_EXPORT_PRIVATE void sanitizeStackForVM(VM&amp;);
1283 void logSanitizeStack(VM&amp;);
1284 
1285 } // namespace JSC
<a name="70" id="anc70"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="70" type="hidden" />
</body>
</html>
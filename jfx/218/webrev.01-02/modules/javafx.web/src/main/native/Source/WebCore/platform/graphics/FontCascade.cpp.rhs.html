<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FontCascade.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2000 Dirk Mueller (mueller@kde.org)
   5  * Copyright (C) 2003-2017 Apple Inc. All rights reserved.
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Library General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Library General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Library General Public License
  18  * along with this library; see the file COPYING.LIB.  If not, write to
  19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  20  * Boston, MA 02110-1301, USA.
  21  *
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;FontCascade.h&quot;
  26 
  27 #include &quot;CharacterProperties.h&quot;
  28 #include &quot;ComplexTextController.h&quot;
  29 #include &quot;DisplayListRecorder.h&quot;
  30 #include &quot;FloatRect.h&quot;
  31 #include &quot;FontCache.h&quot;
  32 #include &quot;GlyphBuffer.h&quot;
  33 #include &quot;GraphicsContext.h&quot;
  34 #include &quot;LayoutRect.h&quot;
  35 #include &quot;SurrogatePairAwareTextIterator.h&quot;
  36 #include &quot;TextRun.h&quot;
  37 #include &quot;WidthIterator.h&quot;
  38 #include &lt;wtf/MainThread.h&gt;
  39 #include &lt;wtf/MathExtras.h&gt;
  40 #include &lt;wtf/NeverDestroyed.h&gt;
  41 #include &lt;wtf/text/AtomStringHash.h&gt;
  42 #include &lt;wtf/text/StringBuilder.h&gt;
  43 
<a name="1" id="anc1"></a>



  44 namespace WebCore {
  45 
  46 using namespace WTF::Unicode;
  47 
  48 static bool useBackslashAsYenSignForFamily(const AtomString&amp; family)
  49 {
  50     if (family.isEmpty())
  51         return false;
  52     static const auto set = makeNeverDestroyed([] {
  53         HashSet&lt;AtomString&gt; set;
  54         auto add = [&amp;set] (const char* name, std::initializer_list&lt;UChar&gt; unicodeName) {
  55             unsigned nameLength = strlen(name);
  56             set.add(AtomString { name, nameLength, AtomString::ConstructFromLiteral });
  57             unsigned unicodeNameLength = unicodeName.size();
  58             set.add(AtomString { unicodeName.begin(), unicodeNameLength });
  59         };
  60         add(&quot;MS PGothic&quot;, { 0xFF2D, 0xFF33, 0x0020, 0xFF30, 0x30B4, 0x30B7, 0x30C3, 0x30AF });
  61         add(&quot;MS PMincho&quot;, { 0xFF2D, 0xFF33, 0x0020, 0xFF30, 0x660E, 0x671D });
  62         add(&quot;MS Gothic&quot;, { 0xFF2D, 0xFF33, 0x0020, 0x30B4, 0x30B7, 0x30C3, 0x30AF });
  63         add(&quot;MS Mincho&quot;, { 0xFF2D, 0xFF33, 0x0020, 0x660E, 0x671D });
  64         add(&quot;Meiryo&quot;, { 0x30E1, 0x30A4, 0x30EA, 0x30AA });
  65         return set;
  66     }());
  67     return set.get().contains(family);
  68 }
  69 
  70 FontCascade::CodePath FontCascade::s_codePath = Auto;
  71 
  72 // ============================================================================================
  73 // FontCascade Implementation (Cross-Platform Portion)
  74 // ============================================================================================
  75 
  76 FontCascade::FontCascade()
  77 {
  78 }
  79 
  80 FontCascade::FontCascade(FontCascadeDescription&amp;&amp; fd, float letterSpacing, float wordSpacing)
  81     : m_fontDescription(WTFMove(fd))
  82     , m_letterSpacing(letterSpacing)
  83     , m_wordSpacing(wordSpacing)
  84     , m_useBackslashAsYenSymbol(useBackslashAsYenSignForFamily(m_fontDescription.firstFamily()))
  85     , m_enableKerning(computeEnableKerning())
  86     , m_requiresShaping(computeRequiresShaping())
  87 {
  88 }
  89 
  90 // FIXME: We should make this constructor platform-independent.
  91 FontCascade::FontCascade(const FontPlatformData&amp; fontData, FontSmoothingMode fontSmoothingMode)
  92     : m_fonts(FontCascadeFonts::createForPlatformFont(fontData))
  93     , m_enableKerning(computeEnableKerning())
  94     , m_requiresShaping(computeRequiresShaping())
  95 {
  96     m_fontDescription.setFontSmoothing(fontSmoothingMode);
  97 #if PLATFORM(IOS_FAMILY)
  98     m_fontDescription.setSpecifiedSize(CTFontGetSize(fontData.font()));
  99     m_fontDescription.setComputedSize(CTFontGetSize(fontData.font()));
 100     m_fontDescription.setIsItalic(CTFontGetSymbolicTraits(fontData.font()) &amp; kCTFontTraitItalic);
 101     m_fontDescription.setWeight((CTFontGetSymbolicTraits(fontData.font()) &amp; kCTFontTraitBold) ? boldWeightValue() : normalWeightValue());
 102 #endif
 103 }
 104 
 105 FontCascade::FontCascade(const FontCascade&amp; other)
 106     : m_fontDescription(other.m_fontDescription)
 107     , m_fonts(other.m_fonts)
 108     , m_letterSpacing(other.m_letterSpacing)
 109     , m_wordSpacing(other.m_wordSpacing)
 110     , m_useBackslashAsYenSymbol(other.m_useBackslashAsYenSymbol)
 111     , m_enableKerning(computeEnableKerning())
 112     , m_requiresShaping(computeRequiresShaping())
 113 {
 114 }
 115 
 116 FontCascade&amp; FontCascade::operator=(const FontCascade&amp; other)
 117 {
 118     m_fontDescription = other.m_fontDescription;
 119     m_fonts = other.m_fonts;
 120     m_letterSpacing = other.m_letterSpacing;
 121     m_wordSpacing = other.m_wordSpacing;
 122     m_useBackslashAsYenSymbol = other.m_useBackslashAsYenSymbol;
 123     m_enableKerning = other.m_enableKerning;
 124     m_requiresShaping = other.m_requiresShaping;
 125     return *this;
 126 }
 127 
 128 bool FontCascade::operator==(const FontCascade&amp; other) const
 129 {
 130     if (isLoadingCustomFonts() || other.isLoadingCustomFonts())
 131         return false;
 132 
 133     if (m_fontDescription != other.m_fontDescription || m_letterSpacing != other.m_letterSpacing || m_wordSpacing != other.m_wordSpacing)
 134         return false;
 135     if (m_fonts == other.m_fonts)
 136         return true;
 137     if (!m_fonts || !other.m_fonts)
 138         return false;
 139     if (m_fonts-&gt;fontSelector() != other.m_fonts-&gt;fontSelector())
 140         return false;
 141     // Can these cases actually somehow occur? All fonts should get wiped out by full style recalc.
 142     if (m_fonts-&gt;fontSelectorVersion() != other.m_fonts-&gt;fontSelectorVersion())
 143         return false;
 144     if (m_fonts-&gt;generation() != other.m_fonts-&gt;generation())
 145         return false;
 146     return true;
 147 }
 148 
 149 struct FontCascadeCacheKey {
 150     FontDescriptionKey fontDescriptionKey; // Shared with the lower level FontCache (caching Font objects)
 151     Vector&lt;AtomString, 3&gt; families;
 152     unsigned fontSelectorId;
 153     unsigned fontSelectorVersion;
 154 };
 155 
 156 struct FontCascadeCacheEntry {
 157     WTF_MAKE_FAST_ALLOCATED;
 158 public:
 159     FontCascadeCacheEntry(FontCascadeCacheKey&amp;&amp; key, Ref&lt;FontCascadeFonts&gt;&amp;&amp; fonts)
 160         : key(WTFMove(key))
 161         , fonts(WTFMove(fonts))
 162     { }
 163     FontCascadeCacheKey key;
 164     Ref&lt;FontCascadeFonts&gt; fonts;
 165 };
 166 
 167 // FIXME: Should make hash traits for FontCascadeCacheKey instead of using a hash as the key (so we hash a hash).
 168 typedef HashMap&lt;unsigned, std::unique_ptr&lt;FontCascadeCacheEntry&gt;, AlreadyHashed&gt; FontCascadeCache;
 169 
 170 static bool keysMatch(const FontCascadeCacheKey&amp; a, const FontCascadeCacheKey&amp; b)
 171 {
 172     if (a.fontDescriptionKey != b.fontDescriptionKey)
 173         return false;
 174     if (a.fontSelectorId != b.fontSelectorId || a.fontSelectorVersion != b.fontSelectorVersion)
 175         return false;
 176     unsigned size = a.families.size();
 177     if (size != b.families.size())
 178         return false;
 179     for (unsigned i = 0; i &lt; size; ++i) {
 180         if (!FontCascadeDescription::familyNamesAreEqual(a.families[i], b.families[i]))
 181             return false;
 182     }
 183     return true;
 184 }
 185 
 186 static FontCascadeCache&amp; fontCascadeCache()
 187 {
 188     static NeverDestroyed&lt;FontCascadeCache&gt; cache;
 189     return cache.get();
 190 }
 191 
 192 void invalidateFontCascadeCache()
 193 {
 194     fontCascadeCache().clear();
 195 }
 196 
 197 void clearWidthCaches()
 198 {
 199     for (auto&amp; value : fontCascadeCache().values())
 200         value-&gt;fonts.get().widthCache().clear();
 201 }
 202 
 203 static FontCascadeCacheKey makeFontCascadeCacheKey(const FontCascadeDescription&amp; description, FontSelector* fontSelector)
 204 {
 205     FontCascadeCacheKey key;
 206     key.fontDescriptionKey = FontDescriptionKey(description);
 207     unsigned familyCount = description.familyCount();
 208     key.families.reserveInitialCapacity(familyCount);
 209     for (unsigned i = 0; i &lt; familyCount; ++i)
 210         key.families.uncheckedAppend(description.familyAt(i));
 211     key.fontSelectorId = fontSelector ? fontSelector-&gt;uniqueId() : 0;
 212     key.fontSelectorVersion = fontSelector ? fontSelector-&gt;version() : 0;
 213     return key;
 214 }
 215 
 216 static unsigned computeFontCascadeCacheHash(const FontCascadeCacheKey&amp; key)
 217 {
 218     // FIXME: Should hash the key and the family name characters rather than making a hash out of other hashes.
 219     IntegerHasher hasher;
 220     hasher.add(key.fontDescriptionKey.computeHash());
 221     hasher.add(key.fontSelectorId);
 222     hasher.add(key.fontSelectorVersion);
 223     for (unsigned i = 0; i &lt; key.families.size(); ++i) {
 224         auto&amp; family = key.families[i];
 225         hasher.add(family.isNull() ? 0 : FontCascadeDescription::familyNameHash(family));
 226     }
 227     return hasher.hash();
 228 }
 229 
 230 void pruneUnreferencedEntriesFromFontCascadeCache()
 231 {
 232     fontCascadeCache().removeIf([](auto&amp; entry) {
 233         return entry.value-&gt;fonts.get().hasOneRef();
 234     });
 235 }
 236 
 237 void pruneSystemFallbackFonts()
 238 {
 239     for (auto&amp; entry : fontCascadeCache().values())
 240         entry-&gt;fonts-&gt;pruneSystemFallbacks();
 241 }
 242 
 243 static Ref&lt;FontCascadeFonts&gt; retrieveOrAddCachedFonts(const FontCascadeDescription&amp; fontDescription, RefPtr&lt;FontSelector&gt;&amp;&amp; fontSelector)
 244 {
 245     auto key = makeFontCascadeCacheKey(fontDescription, fontSelector.get());
 246 
 247     unsigned hash = computeFontCascadeCacheHash(key);
 248     auto addResult = fontCascadeCache().add(hash, nullptr);
 249     if (!addResult.isNewEntry &amp;&amp; keysMatch(addResult.iterator-&gt;value-&gt;key, key))
 250         return addResult.iterator-&gt;value-&gt;fonts.get();
 251 
 252     auto&amp; newEntry = addResult.iterator-&gt;value;
 253     newEntry = makeUnique&lt;FontCascadeCacheEntry&gt;(WTFMove(key), FontCascadeFonts::create(WTFMove(fontSelector)));
 254     Ref&lt;FontCascadeFonts&gt; glyphs = newEntry-&gt;fonts.get();
 255 
 256     static const unsigned unreferencedPruneInterval = 50;
 257     static const int maximumEntries = 400;
 258     static unsigned pruneCounter;
 259     // Referenced FontCascadeFonts would exist anyway so pruning them saves little memory.
 260     if (!(++pruneCounter % unreferencedPruneInterval))
 261         pruneUnreferencedEntriesFromFontCascadeCache();
 262     // Prevent pathological growth.
 263     if (fontCascadeCache().size() &gt; maximumEntries)
 264         fontCascadeCache().remove(fontCascadeCache().random());
 265     return glyphs;
 266 }
 267 
<a name="2" id="anc2"></a><span class="line-added"> 268 bool FontCascade::isCurrent(const FontSelector&amp; fontSelector) const</span>
<span class="line-added"> 269 {</span>
<span class="line-added"> 270     if (!m_fonts)</span>
<span class="line-added"> 271         return false;</span>
<span class="line-added"> 272     if (m_fonts-&gt;generation() != FontCache::singleton().generation())</span>
<span class="line-added"> 273         return false;</span>
<span class="line-added"> 274     if (m_fonts-&gt;fontSelectorVersion() != fontSelector.version())</span>
<span class="line-added"> 275         return false;</span>
<span class="line-added"> 276 </span>
<span class="line-added"> 277     return true;</span>
<span class="line-added"> 278 }</span>
<span class="line-added"> 279 </span>
 280 void FontCascade::update(RefPtr&lt;FontSelector&gt;&amp;&amp; fontSelector) const
 281 {
 282     m_fonts = retrieveOrAddCachedFonts(m_fontDescription, WTFMove(fontSelector));
 283     m_useBackslashAsYenSymbol = useBackslashAsYenSignForFamily(firstFamily());
 284     m_enableKerning = computeEnableKerning();
 285     m_requiresShaping = computeRequiresShaping();
 286 }
 287 
<a name="3" id="anc3"></a><span class="line-modified"> 288 FloatSize FontCascade::glyphBufferForTextRun(CodePath codePathToUse, const TextRun&amp; run, unsigned from, unsigned to, GlyphBuffer&amp; glyphBuffer) const</span>
 289 {
 290     if (codePathToUse != Complex)
<a name="4" id="anc4"></a><span class="line-modified"> 291         return { getGlyphsAndAdvancesForSimpleText(run, from, to, glyphBuffer), 0 };</span>
 292     return getGlyphsAndAdvancesForComplexText(run, from, to, glyphBuffer);
 293 }
 294 
 295 float FontCascade::drawText(GraphicsContext&amp; context, const TextRun&amp; run, const FloatPoint&amp; point, unsigned from, Optional&lt;unsigned&gt; to, CustomFontNotReadyAction customFontNotReadyAction) const
 296 {
 297     unsigned destination = to.valueOr(run.length());
 298     GlyphBuffer glyphBuffer;
<a name="5" id="anc5"></a><span class="line-modified"> 299     FloatPoint startPoint = point + glyphBufferForTextRun(codePath(run, from, to), run, from, destination, glyphBuffer);</span>
 300     // We couldn&#39;t generate any glyphs for the run. Give up.
 301     if (glyphBuffer.isEmpty())
 302         return 0;
 303     // Draw the glyph buffer now at the starting point returned in startX.
<a name="6" id="anc6"></a><span class="line-modified"> 304     float oldStartX = startPoint.x();</span>
 305     drawGlyphBuffer(context, glyphBuffer, startPoint, customFontNotReadyAction);
<a name="7" id="anc7"></a><span class="line-modified"> 306     return startPoint.x() - oldStartX;</span>
 307 }
 308 
 309 void FontCascade::drawEmphasisMarks(GraphicsContext&amp; context, const TextRun&amp; run, const AtomString&amp; mark, const FloatPoint&amp; point, unsigned from, Optional&lt;unsigned&gt; to) const
 310 {
 311     if (isLoadingCustomFonts())
 312         return;
 313 
 314     unsigned destination = to.valueOr(run.length());
 315     if (codePath(run, from, to) != Complex)
 316         drawEmphasisMarksForSimpleText(context, run, mark, point, from, destination);
 317     else
 318         drawEmphasisMarksForComplexText(context, run, mark, point, from, destination);
 319 }
 320 
 321 std::unique_ptr&lt;DisplayList::DisplayList&gt; FontCascade::displayListForTextRun(GraphicsContext&amp; context, const TextRun&amp; run, unsigned from, Optional&lt;unsigned&gt; to, CustomFontNotReadyAction customFontNotReadyAction) const
 322 {
 323     ASSERT(!context.paintingDisabled());
 324     unsigned destination = to.valueOr(run.length());
 325 
 326     // FIXME: Use the fast code path once it handles partial runs with kerning and ligatures. See http://webkit.org/b/100050
 327     CodePath codePathToUse = codePath(run);
 328     if (codePathToUse != Complex &amp;&amp; (enableKerning() || requiresShaping()) &amp;&amp; (from || destination != run.length()))
 329         codePathToUse = Complex;
 330 
 331     GlyphBuffer glyphBuffer;
<a name="8" id="anc8"></a><span class="line-modified"> 332     FloatPoint startPoint = toFloatPoint(glyphBufferForTextRun(codePathToUse, run, from, destination, glyphBuffer));</span>
 333     // We couldn&#39;t generate any glyphs for the run. Give up.
 334     if (glyphBuffer.isEmpty())
 335         return nullptr;
 336 
 337     std::unique_ptr&lt;DisplayList::DisplayList&gt; displayList = makeUnique&lt;DisplayList::DisplayList&gt;();
 338     GraphicsContext recordingContext([&amp;](GraphicsContext&amp; displayListContext) {
 339         return makeUnique&lt;DisplayList::Recorder&gt;(displayListContext, *displayList, context.state(), FloatRect(), AffineTransform());
 340     });
 341 
<a name="9" id="anc9"></a>
 342     drawGlyphBuffer(recordingContext, glyphBuffer, startPoint, customFontNotReadyAction);
 343     return displayList;
 344 }
 345 
 346 float FontCascade::widthOfTextRange(const TextRun&amp; run, unsigned from, unsigned to, HashSet&lt;const Font*&gt;* fallbackFonts, float* outWidthBeforeRange, float* outWidthAfterRange) const
 347 {
 348     ASSERT(from &lt;= to);
 349     ASSERT(to &lt;= run.length());
 350 
 351     if (!run.length())
 352         return 0;
 353 
 354     float offsetBeforeRange = 0;
 355     float offsetAfterRange = 0;
 356     float totalWidth = 0;
 357 
 358     auto codePathToUse = codePath(run);
 359     if (codePathToUse == Complex) {
<a name="10" id="anc10"></a>








 360         ComplexTextController complexIterator(*this, run, false, fallbackFonts);
 361         complexIterator.advance(from, nullptr, IncludePartialGlyphs, fallbackFonts);
 362         offsetBeforeRange = complexIterator.runWidthSoFar();
 363         complexIterator.advance(to, nullptr, IncludePartialGlyphs, fallbackFonts);
 364         offsetAfterRange = complexIterator.runWidthSoFar();
 365         complexIterator.advance(run.length(), nullptr, IncludePartialGlyphs, fallbackFonts);
 366         totalWidth = complexIterator.runWidthSoFar();
<a name="11" id="anc11"></a>
 367     } else {
 368         WidthIterator simpleIterator(this, run, fallbackFonts);
 369         simpleIterator.advance(from, nullptr);
 370         offsetBeforeRange = simpleIterator.runWidthSoFar();
 371         simpleIterator.advance(to, nullptr);
 372         offsetAfterRange = simpleIterator.runWidthSoFar();
 373         simpleIterator.advance(run.length(), nullptr);
 374         totalWidth = simpleIterator.runWidthSoFar();
 375     }
 376 
 377     if (outWidthBeforeRange)
 378         *outWidthBeforeRange = offsetBeforeRange;
 379 
 380     if (outWidthAfterRange)
 381         *outWidthAfterRange = totalWidth - offsetAfterRange;
 382 
 383     return offsetAfterRange - offsetBeforeRange;
 384 }
 385 
 386 float FontCascade::width(const TextRun&amp; run, HashSet&lt;const Font*&gt;* fallbackFonts, GlyphOverflow* glyphOverflow) const
 387 {
 388     if (!run.length())
 389         return 0;
 390 
 391     CodePath codePathToUse = codePath(run);
 392     if (codePathToUse != Complex) {
 393         // The complex path is more restrictive about returning fallback fonts than the simple path, so we need an explicit test to make their behaviors match.
 394         if (!canReturnFallbackFontsForComplexText())
 395             fallbackFonts = nullptr;
 396         // The simple path can optimize the case where glyph overflow is not observable.
 397         if (codePathToUse != SimpleWithGlyphOverflow &amp;&amp; (glyphOverflow &amp;&amp; !glyphOverflow-&gt;computeBounds))
 398             glyphOverflow = nullptr;
 399     }
 400 
 401     bool hasWordSpacingOrLetterSpacing = wordSpacing() || letterSpacing();
 402     float* cacheEntry = m_fonts-&gt;widthCache().add(run, std::numeric_limits&lt;float&gt;::quiet_NaN(), enableKerning() || requiresShaping(), hasWordSpacingOrLetterSpacing, glyphOverflow);
 403     if (cacheEntry &amp;&amp; !std::isnan(*cacheEntry))
 404         return *cacheEntry;
 405 
 406     HashSet&lt;const Font*&gt; localFallbackFonts;
 407     if (!fallbackFonts)
 408         fallbackFonts = &amp;localFallbackFonts;
 409 
 410     float result;
 411     if (codePathToUse == Complex)
 412         result = floatWidthForComplexText(run, fallbackFonts, glyphOverflow);
 413     else
 414         result = floatWidthForSimpleText(run, fallbackFonts, glyphOverflow);
 415 
 416     if (cacheEntry &amp;&amp; fallbackFonts-&gt;isEmpty())
 417         *cacheEntry = result;
 418     return result;
 419 }
 420 
 421 float FontCascade::widthForSimpleText(StringView text) const
 422 {
 423     if (text.isNull() || text.isEmpty())
 424         return 0;
 425     ASSERT(codePath(TextRun(text)) != FontCascade::Complex);
 426     float* cacheEntry = m_fonts-&gt;widthCache().add(text, std::numeric_limits&lt;float&gt;::quiet_NaN());
 427     if (cacheEntry &amp;&amp; !std::isnan(*cacheEntry))
 428         return *cacheEntry;
 429 
<a name="12" id="anc12"></a><span class="line-added"> 430     GlyphBuffer glyphBuffer;</span>
 431     Vector&lt;GlyphBufferGlyph, 16&gt; glyphs;
 432     Vector&lt;GlyphBufferAdvance, 16&gt; advances;
 433     bool hasKerningOrLigatures = enableKerning() || requiresShaping();
 434     float runWidth = 0;
 435     auto&amp; font = primaryFont();
 436     for (unsigned i = 0; i &lt; text.length(); ++i) {
 437         auto glyph = glyphDataForCharacter(text[i], false).glyph;
 438         auto glyphWidth = font.widthForGlyph(glyph);
 439         runWidth += glyphWidth;
 440         if (!hasKerningOrLigatures)
 441             continue;
<a name="13" id="anc13"></a><span class="line-modified"> 442         glyphBuffer.add(glyph, &amp;font, glyphWidth);</span>

 443     }
 444     if (hasKerningOrLigatures) {
<a name="14" id="anc14"></a><span class="line-modified"> 445         font.applyTransforms(glyphBuffer, 0, enableKerning(), requiresShaping(), fontDescription().locale());</span>
 446         // This is needed only to match the result of the slow path. Same glyph widths but different floating point arithmentics can
 447         // produce different run width.
 448         float runWidthDifferenceWithTransformApplied = -runWidth;
<a name="15" id="anc15"></a><span class="line-modified"> 449         for (size_t i = 0; i &lt; glyphBuffer.size(); ++i)</span>
<span class="line-modified"> 450             runWidthDifferenceWithTransformApplied += glyphBuffer.advanceAt(i).width();</span>
 451         runWidth += runWidthDifferenceWithTransformApplied;
 452     }
 453 
 454     if (cacheEntry)
 455         *cacheEntry = runWidth;
 456     return runWidth;
 457 }
 458 
 459 GlyphData FontCascade::glyphDataForCharacter(UChar32 c, bool mirror, FontVariant variant) const
 460 {
 461     if (variant == AutoVariant) {
 462         if (m_fontDescription.variantCaps() == FontVariantCaps::Small) {
 463             UChar32 upperC = u_toupper(c);
 464             if (upperC != c) {
 465                 c = upperC;
 466                 variant = SmallCapsVariant;
 467             } else
 468                 variant = NormalVariant;
 469         } else
 470             variant = NormalVariant;
 471     }
 472 
 473     if (mirror)
 474         c = u_charMirror(c);
 475 
 476     return m_fonts-&gt;glyphDataForCharacter(c, m_fontDescription, variant);
 477 }
 478 
 479 // For font families where any of the fonts don&#39;t have a valid entry in the OS/2 table
 480 // for avgCharWidth, fallback to the legacy webkit behavior of getting the avgCharWidth
 481 // from the width of a &#39;0&#39;. This only seems to apply to a fixed number of Mac fonts,
 482 // but, in order to get similar rendering across platforms, we do this check for
 483 // all platforms.
 484 bool FontCascade::hasValidAverageCharWidth() const
 485 {
 486     const AtomString&amp; family = firstFamily();
 487     if (family.isEmpty())
 488         return false;
 489 
 490 #if PLATFORM(COCOA)
 491     // Internal fonts on macOS and iOS also have an invalid entry in the table for avgCharWidth.
 492     if (primaryFontIsSystemFont())
 493         return false;
 494 #endif
 495 
 496     static const auto map = makeNeverDestroyed(HashSet&lt;AtomString&gt; {
 497         &quot;American Typewriter&quot;,
 498         &quot;Arial Hebrew&quot;,
 499         &quot;Chalkboard&quot;,
 500         &quot;Cochin&quot;,
 501         &quot;Corsiva Hebrew&quot;,
 502         &quot;Courier&quot;,
 503         &quot;Euphemia UCAS&quot;,
 504         &quot;Geneva&quot;,
 505         &quot;Gill Sans&quot;,
 506         &quot;Hei&quot;,
 507         &quot;Helvetica&quot;,
 508         &quot;Hoefler Text&quot;,
 509         &quot;InaiMathi&quot;,
 510         &quot;Kai&quot;,
 511         &quot;Lucida Grande&quot;,
 512         &quot;Marker Felt&quot;,
 513         &quot;Monaco&quot;,
 514         &quot;Mshtakan&quot;,
 515         &quot;New Peninim MT&quot;,
 516         &quot;Osaka&quot;,
 517         &quot;Raanana&quot;,
 518         &quot;STHeiti&quot;,
 519         &quot;Symbol&quot;,
 520         &quot;Times&quot;,
 521         &quot;Apple Braille&quot;,
 522         &quot;Apple LiGothic&quot;,
 523         &quot;Apple LiSung&quot;,
 524         &quot;Apple Symbols&quot;,
 525         &quot;AppleGothic&quot;,
 526         &quot;AppleMyungjo&quot;,
 527         &quot;#GungSeo&quot;,
 528         &quot;#HeadLineA&quot;,
 529         &quot;#PCMyungjo&quot;,
 530         &quot;#PilGi&quot;,
 531     });
 532     return !map.get().contains(family);
 533 }
 534 
 535 bool FontCascade::fastAverageCharWidthIfAvailable(float&amp; width) const
 536 {
 537     bool success = hasValidAverageCharWidth();
 538     if (success)
 539         width = roundf(primaryFont().avgCharWidth()); // FIXME: primaryFont() might not correspond to firstFamily().
 540     return success;
 541 }
 542 
 543 void FontCascade::adjustSelectionRectForText(const TextRun&amp; run, LayoutRect&amp; selectionRect, unsigned from, Optional&lt;unsigned&gt; to) const
 544 {
 545     unsigned destination = to.valueOr(run.length());
 546     if (codePath(run, from, to) != Complex)
 547         return adjustSelectionRectForSimpleText(run, selectionRect, from, destination);
 548 
 549     return adjustSelectionRectForComplexText(run, selectionRect, from, destination);
 550 }
 551 
 552 int FontCascade::offsetForPosition(const TextRun&amp; run, float x, bool includePartialGlyphs) const
 553 {
 554     if (codePath(run, x) != Complex)
 555         return offsetForPositionForSimpleText(run, x, includePartialGlyphs);
 556 
 557     return offsetForPositionForComplexText(run, x, includePartialGlyphs);
 558 }
 559 
 560 template &lt;typename CharacterType&gt;
 561 static inline String normalizeSpacesInternal(const CharacterType* characters, unsigned length)
 562 {
 563     StringBuilder normalized;
 564     normalized.reserveCapacity(length);
 565 
 566     for (unsigned i = 0; i &lt; length; ++i)
 567         normalized.append(FontCascade::normalizeSpaces(characters[i]));
 568 
 569     return normalized.toString();
 570 }
 571 
 572 String FontCascade::normalizeSpaces(const LChar* characters, unsigned length)
 573 {
 574     return normalizeSpacesInternal(characters, length);
 575 }
 576 
 577 String FontCascade::normalizeSpaces(const UChar* characters, unsigned length)
 578 {
 579     return normalizeSpacesInternal(characters, length);
 580 }
 581 
 582 static bool shouldUseFontSmoothing = true;
 583 
 584 void FontCascade::setShouldUseSmoothing(bool shouldUseSmoothing)
 585 {
 586     ASSERT(isMainThread());
 587     shouldUseFontSmoothing = shouldUseSmoothing;
 588 }
 589 
 590 bool FontCascade::shouldUseSmoothing()
 591 {
 592     return shouldUseFontSmoothing;
 593 }
 594 
 595 #if !PLATFORM(COCOA)
 596 bool FontCascade::isSubpixelAntialiasingAvailable()
 597 {
 598     return false;
 599 }
 600 #endif
 601 
 602 void FontCascade::setCodePath(CodePath p)
 603 {
 604     s_codePath = p;
 605 }
 606 
 607 FontCascade::CodePath FontCascade::codePath()
 608 {
 609     return s_codePath;
 610 }
 611 
 612 FontCascade::CodePath FontCascade::codePath(const TextRun&amp; run, Optional&lt;unsigned&gt; from, Optional&lt;unsigned&gt; to) const
 613 {
 614     if (s_codePath != Auto)
 615         return s_codePath;
 616 
 617 #if !USE(FREETYPE)
 618     // FIXME: Use the fast code path once it handles partial runs with kerning and ligatures. See http://webkit.org/b/100050
 619     if ((enableKerning() || requiresShaping()) &amp;&amp; (from.valueOr(0) || to.valueOr(run.length()) != run.length()))
 620         return Complex;
 621 #else
 622     UNUSED_PARAM(from);
 623     UNUSED_PARAM(to);
 624 #endif
 625 
 626 #if PLATFORM(COCOA) || USE(FREETYPE)
 627     // Because Font::applyTransforms() doesn&#39;t know which features to enable/disable in the simple code path, it can&#39;t properly handle feature or variant settings.
 628     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=150791: @font-face features should also cause this to be complex.
 629     if (m_fontDescription.featureSettings().size() &gt; 0 || !m_fontDescription.variantSettings().isAllNormal())
 630         return Complex;
 631 
 632 #else
 633 
 634     if (run.length() &gt; 1 &amp;&amp; (enableKerning() || requiresShaping()))
 635         return Complex;
 636 #endif
 637 
 638     if (!run.characterScanForCodePath())
 639         return Simple;
 640 
 641     if (run.is8Bit())
 642         return Simple;
 643 
 644     // Start from 0 since drawing and highlighting also measure the characters before run-&gt;from.
 645     return characterRangeCodePath(run.characters16(), run.length());
 646 }
 647 
 648 FontCascade::CodePath FontCascade::characterRangeCodePath(const UChar* characters, unsigned len)
 649 {
 650     // FIXME: Should use a UnicodeSet in ports where ICU is used. Note that we
 651     // can&#39;t simply use UnicodeCharacter Property/class because some characters
 652     // are not &#39;combining&#39;, but still need to go to the complex path.
 653     // Alternatively, we may as well consider binary search over a sorted
 654     // list of ranges.
 655     CodePath result = Simple;
 656     bool previousCharacterIsEmojiGroupCandidate = false;
 657     for (unsigned i = 0; i &lt; len; i++) {
 658         const UChar c = characters[i];
 659         if (c == zeroWidthJoiner &amp;&amp; previousCharacterIsEmojiGroupCandidate)
 660             return Complex;
 661 
 662         previousCharacterIsEmojiGroupCandidate = false;
 663         if (c &lt; 0x2E5) // U+02E5 through U+02E9 (Modifier Letters : Tone letters)
 664             continue;
 665         if (c &lt;= 0x2E9)
 666             return Complex;
 667 
 668         if (c &lt; 0x300) // U+0300 through U+036F Combining diacritical marks
 669             continue;
 670         if (c &lt;= 0x36F)
 671             return Complex;
 672 
 673         if (c &lt; 0x0591 || c == 0x05BE) // U+0591 through U+05CF excluding U+05BE Hebrew combining marks, Hebrew punctuation Paseq, Sof Pasuq and Nun Hafukha
 674             continue;
 675         if (c &lt;= 0x05CF)
 676             return Complex;
 677 
 678         // U+0600 through U+109F Arabic, Syriac, Thaana, NKo, Samaritan, Mandaic,
 679         // Devanagari, Bengali, Gurmukhi, Gujarati, Oriya, Tamil, Telugu, Kannada,
 680         // Malayalam, Sinhala, Thai, Lao, Tibetan, Myanmar
 681         if (c &lt; 0x0600)
 682             continue;
 683         if (c &lt;= 0x109F)
 684             return Complex;
 685 
 686         // U+1100 through U+11FF Hangul Jamo (only Ancient Korean should be left here if you precompose;
 687         // Modern Korean will be precomposed as a result of step A)
 688         if (c &lt; 0x1100)
 689             continue;
 690         if (c &lt;= 0x11FF)
 691             return Complex;
 692 
 693         if (c &lt; 0x135D) // U+135D through U+135F Ethiopic combining marks
 694             continue;
 695         if (c &lt;= 0x135F)
 696             return Complex;
 697 
 698         if (c &lt; 0x1700) // U+1780 through U+18AF Tagalog, Hanunoo, Buhid, Taghanwa,Khmer, Mongolian
 699             continue;
 700         if (c &lt;= 0x18AF)
 701             return Complex;
 702 
 703         if (c &lt; 0x1900) // U+1900 through U+194F Limbu (Unicode 4.0)
 704             continue;
 705         if (c &lt;= 0x194F)
 706             return Complex;
 707 
 708         if (c &lt; 0x1980) // U+1980 through U+19DF New Tai Lue
 709             continue;
 710         if (c &lt;= 0x19DF)
 711             return Complex;
 712 
 713         if (c &lt; 0x1A00) // U+1A00 through U+1CFF Buginese, Tai Tham, Balinese, Batak, Lepcha, Vedic
 714             continue;
 715         if (c &lt;= 0x1CFF)
 716             return Complex;
 717 
 718         if (c &lt; 0x1DC0) // U+1DC0 through U+1DFF Comining diacritical mark supplement
 719             continue;
 720         if (c &lt;= 0x1DFF)
 721             return Complex;
 722 
 723         // U+1E00 through U+2000 characters with diacritics and stacked diacritics
 724         if (c &lt;= 0x2000) {
 725             result = SimpleWithGlyphOverflow;
 726             continue;
 727         }
 728 
 729         if (c &lt; 0x20D0) // U+20D0 through U+20FF Combining marks for symbols
 730             continue;
 731         if (c &lt;= 0x20FF)
 732             return Complex;
 733 
 734         if (c &lt; 0x26F9)
 735             continue;
 736         if (c &lt; 0x26FA)
 737             return Complex;
 738 
 739         if (c &lt; 0x2CEF) // U+2CEF through U+2CF1 Combining marks for Coptic
 740             continue;
 741         if (c &lt;= 0x2CF1)
 742             return Complex;
 743 
 744         if (c &lt; 0x302A) // U+302A through U+302F Ideographic and Hangul Tone marks
 745             continue;
 746         if (c &lt;= 0x302F)
 747             return Complex;
 748 
 749         if (c &lt; 0xA67C) // U+A67C through U+A67D Combining marks for old Cyrillic
 750             continue;
 751         if (c &lt;= 0xA67D)
 752             return Complex;
 753 
 754         if (c &lt; 0xA6F0) // U+A6F0 through U+A6F1 Combining mark for Bamum
 755             continue;
 756         if (c &lt;= 0xA6F1)
 757             return Complex;
 758 
 759         // U+A800 through U+ABFF Nagri, Phags-pa, Saurashtra, Devanagari Extended,
 760         // Hangul Jamo Ext. A, Javanese, Myanmar Extended A, Tai Viet, Meetei Mayek,
 761         if (c &lt; 0xA800)
 762             continue;
 763         if (c &lt;= 0xABFF)
 764             return Complex;
 765 
 766         if (c &lt; 0xD7B0) // U+D7B0 through U+D7FF Hangul Jamo Ext. B
 767             continue;
 768         if (c &lt;= 0xD7FF)
 769             return Complex;
 770 
 771         if (c &lt;= 0xDBFF) {
 772             // High surrogate
 773 
 774             if (i == len - 1)
 775                 continue;
 776 
 777             UChar next = characters[++i];
 778             if (!U16_IS_TRAIL(next))
 779                 continue;
 780 
 781             UChar32 supplementaryCharacter = U16_GET_SUPPLEMENTARY(c, next);
 782 
 783             if (supplementaryCharacter &lt; 0x10A00)
 784                 continue;
 785             if (supplementaryCharacter &lt; 0x10A60) // Kharoshthi
 786                 return Complex;
 787             if (supplementaryCharacter &lt; 0x11000)
 788                 continue;
 789             if (supplementaryCharacter &lt; 0x11080) // Brahmi
 790                 return Complex;
 791             if (supplementaryCharacter &lt; 0x110D0) // Kaithi
 792                 return Complex;
 793             if (supplementaryCharacter &lt; 0x11100)
 794                 continue;
 795             if (supplementaryCharacter &lt; 0x11150) // Chakma
 796                 return Complex;
 797             if (supplementaryCharacter &lt; 0x11180) // Mahajani
 798                 return Complex;
 799             if (supplementaryCharacter &lt; 0x111E0) // Sharada
 800                 return Complex;
 801             if (supplementaryCharacter &lt; 0x11200)
 802                 continue;
 803             if (supplementaryCharacter &lt; 0x11250) // Khojki
 804                 return Complex;
 805             if (supplementaryCharacter &lt; 0x112B0)
 806                 continue;
 807             if (supplementaryCharacter &lt; 0x11300) // Khudawadi
 808                 return Complex;
 809             if (supplementaryCharacter &lt; 0x11380) // Grantha
 810                 return Complex;
 811             if (supplementaryCharacter &lt; 0x11400)
 812                 continue;
 813             if (supplementaryCharacter &lt; 0x11480) // Newa
 814                 return Complex;
 815             if (supplementaryCharacter &lt; 0x114E0) // Tirhuta
 816                 return Complex;
 817             if (supplementaryCharacter &lt; 0x11580)
 818                 continue;
 819             if (supplementaryCharacter &lt; 0x11600) // Siddham
 820                 return Complex;
 821             if (supplementaryCharacter &lt; 0x11660) // Modi
 822                 return Complex;
 823             if (supplementaryCharacter &lt; 0x11680)
 824                 continue;
 825             if (supplementaryCharacter &lt; 0x116D0) // Takri
 826                 return Complex;
 827             if (supplementaryCharacter &lt; 0x11C00)
 828                 continue;
 829             if (supplementaryCharacter &lt; 0x11C70) // Bhaiksuki
 830                 return Complex;
 831             if (supplementaryCharacter &lt; 0x11CC0) // Marchen
 832                 return Complex;
 833             if (supplementaryCharacter &lt; 0x1E900)
 834                 continue;
 835             if (supplementaryCharacter &lt; 0x1E960) // Adlam
 836                 return Complex;
 837             if (supplementaryCharacter &lt; 0x1F1E6) // U+1F1E6 through U+1F1FF Regional Indicator Symbols
 838                 continue;
 839             if (supplementaryCharacter &lt;= 0x1F1FF)
 840                 return Complex;
 841 
 842             if (isEmojiFitzpatrickModifier(supplementaryCharacter))
 843                 return Complex;
 844             if (isEmojiGroupCandidate(supplementaryCharacter)) {
 845                 previousCharacterIsEmojiGroupCandidate = true;
 846                 continue;
 847             }
 848 
 849             if (supplementaryCharacter &lt; 0xE0000)
 850                 continue;
 851             if (supplementaryCharacter &lt; 0xE0080) // Tags
 852                 return Complex;
 853             if (supplementaryCharacter &lt; 0xE0100) // U+E0100 through U+E01EF Unicode variation selectors.
 854                 continue;
 855             if (supplementaryCharacter &lt;= 0xE01EF)
 856                 return Complex;
 857 
 858             // FIXME: Check for Brahmi (U+11000 block), Kaithi (U+11080 block) and other complex scripts
 859             // in plane 1 or higher.
 860 
 861             continue;
 862         }
 863 
 864         if (c &lt; 0xFE00) // U+FE00 through U+FE0F Unicode variation selectors
 865             continue;
 866         if (c &lt;= 0xFE0F)
 867             return Complex;
 868 
 869         if (c &lt; 0xFE20) // U+FE20 through U+FE2F Combining half marks
 870             continue;
 871         if (c &lt;= 0xFE2F)
 872             return Complex;
 873     }
 874     return result;
 875 }
 876 
 877 bool FontCascade::isCJKIdeograph(UChar32 c)
 878 {
 879     // The basic CJK Unified Ideographs block.
 880     if (c &gt;= 0x4E00 &amp;&amp; c &lt;= 0x9FFF)
 881         return true;
 882 
 883     // CJK Unified Ideographs Extension A.
 884     if (c &gt;= 0x3400 &amp;&amp; c &lt;= 0x4DBF)
 885         return true;
 886 
 887     // CJK Radicals Supplement.
 888     if (c &gt;= 0x2E80 &amp;&amp; c &lt;= 0x2EFF)
 889         return true;
 890 
 891     // Kangxi Radicals.
 892     if (c &gt;= 0x2F00 &amp;&amp; c &lt;= 0x2FDF)
 893         return true;
 894 
 895     // CJK Strokes.
 896     if (c &gt;= 0x31C0 &amp;&amp; c &lt;= 0x31EF)
 897         return true;
 898 
 899     // CJK Compatibility Ideographs.
 900     if (c &gt;= 0xF900 &amp;&amp; c &lt;= 0xFAFF)
 901         return true;
 902 
 903     // CJK Unified Ideographs Extension B.
 904     if (c &gt;= 0x20000 &amp;&amp; c &lt;= 0x2A6DF)
 905         return true;
 906 
 907     // CJK Unified Ideographs Extension C.
 908     if (c &gt;= 0x2A700 &amp;&amp; c &lt;= 0x2B73F)
 909         return true;
 910 
 911     // CJK Unified Ideographs Extension D.
 912     if (c &gt;= 0x2B740 &amp;&amp; c &lt;= 0x2B81F)
 913         return true;
 914 
 915     // CJK Compatibility Ideographs Supplement.
 916     if (c &gt;= 0x2F800 &amp;&amp; c &lt;= 0x2FA1F)
 917         return true;
 918 
 919     return false;
 920 }
 921 
 922 bool FontCascade::isCJKIdeographOrSymbol(UChar32 c)
 923 {
 924     // 0x2C7 Caron, Mandarin Chinese 3rd Tone
 925     // 0x2CA Modifier Letter Acute Accent, Mandarin Chinese 2nd Tone
 926     // 0x2CB Modifier Letter Grave Access, Mandarin Chinese 4th Tone
 927     // 0x2D9 Dot Above, Mandarin Chinese 5th Tone
 928     if ((c == 0x2C7) || (c == 0x2CA) || (c == 0x2CB) || (c == 0x2D9))
 929         return true;
 930 
 931     if ((c == 0x2020) || (c == 0x2021) || (c == 0x2030) || (c == 0x203B) || (c == 0x203C)
 932         || (c == 0x2042) || (c == 0x2047) || (c == 0x2048) || (c == 0x2049) || (c == 0x2051)
 933         || (c == 0x20DD) || (c == 0x20DE) || (c == 0x2100) || (c == 0x2103) || (c == 0x2105)
 934         || (c == 0x2109) || (c == 0x210A) || (c == 0x2113) || (c == 0x2116) || (c == 0x2121)
 935         || (c == 0x212B) || (c == 0x213B) || (c == 0x2150) || (c == 0x2151) || (c == 0x2152))
 936         return true;
 937 
 938     if (c &gt;= 0x2156 &amp;&amp; c &lt;= 0x215A)
 939         return true;
 940 
 941     if (c &gt;= 0x2160 &amp;&amp; c &lt;= 0x216B)
 942         return true;
 943 
 944     if (c &gt;= 0x2170 &amp;&amp; c &lt;= 0x217B)
 945         return true;
 946 
 947     if ((c == 0x217F) || (c == 0x2189) || (c == 0x2307) || (c == 0x2312) || (c == 0x23BE) || (c == 0x23BF))
 948         return true;
 949 
 950     if (c &gt;= 0x23C0 &amp;&amp; c &lt;= 0x23CC)
 951         return true;
 952 
 953     if ((c == 0x23CE) || (c == 0x2423))
 954         return true;
 955 
 956     if (c &gt;= 0x2460 &amp;&amp; c &lt;= 0x2492)
 957         return true;
 958 
 959     if (c &gt;= 0x249C &amp;&amp; c &lt;= 0x24FF)
 960         return true;
 961 
 962     if ((c == 0x25A0) || (c == 0x25A1) || (c == 0x25A2) || (c == 0x25AA) || (c == 0x25AB))
 963         return true;
 964 
 965     if ((c == 0x25B1) || (c == 0x25B2) || (c == 0x25B3) || (c == 0x25B6) || (c == 0x25B7) || (c == 0x25BC) || (c == 0x25BD))
 966         return true;
 967 
 968     if ((c == 0x25C0) || (c == 0x25C1) || (c == 0x25C6) || (c == 0x25C7) || (c == 0x25C9) || (c == 0x25CB) || (c == 0x25CC))
 969         return true;
 970 
 971     if (c &gt;= 0x25CE &amp;&amp; c &lt;= 0x25D3)
 972         return true;
 973 
 974     if (c &gt;= 0x25E2 &amp;&amp; c &lt;= 0x25E6)
 975         return true;
 976 
 977     if (c == 0x25EF)
 978         return true;
 979 
 980     if (c &gt;= 0x2600 &amp;&amp; c &lt;= 0x2603)
 981         return true;
 982 
 983     if ((c == 0x2605) || (c == 0x2606) || (c == 0x260E) || (c == 0x2616) || (c == 0x2617) || (c == 0x2640) || (c == 0x2642))
 984         return true;
 985 
 986     if (c &gt;= 0x2660 &amp;&amp; c &lt;= 0x266F)
 987         return true;
 988 
 989     if (c &gt;= 0x2672 &amp;&amp; c &lt;= 0x267D)
 990         return true;
 991 
 992     if ((c == 0x26A0) || (c == 0x26BD) || (c == 0x26BE) || (c == 0x2713) || (c == 0x271A) || (c == 0x273F) || (c == 0x2740) || (c == 0x2756))
 993         return true;
 994 
 995     if (c &gt;= 0x2776 &amp;&amp; c &lt;= 0x277F)
 996         return true;
 997 
 998     if (c == 0x2B1A)
 999         return true;
1000 
1001     // Ideographic Description Characters.
1002     if (c &gt;= 0x2FF0 &amp;&amp; c &lt;= 0x2FFF)
1003         return true;
1004 
1005     // CJK Symbols and Punctuation, excluding 0x3030.
1006     if (c &gt;= 0x3000 &amp;&amp; c &lt; 0x3030)
1007         return true;
1008 
1009     if (c &gt; 0x3030 &amp;&amp; c &lt;= 0x303F)
1010         return true;
1011 
1012     // Hiragana
1013     if (c &gt;= 0x3040 &amp;&amp; c &lt;= 0x309F)
1014         return true;
1015 
1016     // Katakana
1017     if (c &gt;= 0x30A0 &amp;&amp; c &lt;= 0x30FF)
1018         return true;
1019 
1020     // Bopomofo
1021     if (c &gt;= 0x3100 &amp;&amp; c &lt;= 0x312F)
1022         return true;
1023 
1024     if (c &gt;= 0x3190 &amp;&amp; c &lt;= 0x319F)
1025         return true;
1026 
1027     // Bopomofo Extended
1028     if (c &gt;= 0x31A0 &amp;&amp; c &lt;= 0x31BF)
1029         return true;
1030 
1031     // Enclosed CJK Letters and Months.
1032     if (c &gt;= 0x3200 &amp;&amp; c &lt;= 0x32FF)
1033         return true;
1034 
1035     // CJK Compatibility.
1036     if (c &gt;= 0x3300 &amp;&amp; c &lt;= 0x33FF)
1037         return true;
1038 
1039     if (c &gt;= 0xF860 &amp;&amp; c &lt;= 0xF862)
1040         return true;
1041 
1042     // CJK Compatibility Forms.
1043     if (c &gt;= 0xFE30 &amp;&amp; c &lt;= 0xFE4F)
1044         return true;
1045 
1046     if ((c == 0xFE10) || (c == 0xFE11) || (c == 0xFE12) || (c == 0xFE19))
1047         return true;
1048 
1049     if ((c == 0xFF0D) || (c == 0xFF1B) || (c == 0xFF1C) || (c == 0xFF1E))
1050         return false;
1051 
1052     // Halfwidth and Fullwidth Forms
1053     // Usually only used in CJK
1054     if (c &gt;= 0xFF00 &amp;&amp; c &lt;= 0xFFEF)
1055         return true;
1056 
1057     // Emoji.
1058     if (c == 0x1F100)
1059         return true;
1060 
1061     if (c &gt;= 0x1F110 &amp;&amp; c &lt;= 0x1F129)
1062         return true;
1063 
1064     if (c &gt;= 0x1F130 &amp;&amp; c &lt;= 0x1F149)
1065         return true;
1066 
1067     if (c &gt;= 0x1F150 &amp;&amp; c &lt;= 0x1F169)
1068         return true;
1069 
1070     if (c &gt;= 0x1F170 &amp;&amp; c &lt;= 0x1F189)
1071         return true;
1072 
1073     if (c &gt;= 0x1F200 &amp;&amp; c &lt;= 0x1F6C5)
1074         return true;
1075 
1076     return isCJKIdeograph(c);
1077 }
1078 
1079 std::pair&lt;unsigned, bool&gt; FontCascade::expansionOpportunityCountInternal(const LChar* characters, unsigned length, TextDirection direction, ExpansionBehavior expansionBehavior)
1080 {
1081     unsigned count = 0;
1082     bool isAfterExpansion = (expansionBehavior &amp; LeadingExpansionMask) == ForbidLeadingExpansion;
1083     if ((expansionBehavior &amp; LeadingExpansionMask) == ForceLeadingExpansion) {
1084         ++count;
1085         isAfterExpansion = true;
1086     }
1087     if (direction == TextDirection::LTR) {
1088         for (unsigned i = 0; i &lt; length; ++i) {
1089             if (treatAsSpace(characters[i])) {
1090                 count++;
1091                 isAfterExpansion = true;
1092             } else
1093                 isAfterExpansion = false;
1094         }
1095     } else {
1096         for (unsigned i = length; i &gt; 0; --i) {
1097             if (treatAsSpace(characters[i - 1])) {
1098                 count++;
1099                 isAfterExpansion = true;
1100             } else
1101                 isAfterExpansion = false;
1102         }
1103     }
1104     if (!isAfterExpansion &amp;&amp; (expansionBehavior &amp; TrailingExpansionMask) == ForceTrailingExpansion) {
1105         ++count;
1106         isAfterExpansion = true;
1107     } else if (isAfterExpansion &amp;&amp; (expansionBehavior &amp; TrailingExpansionMask) == ForbidTrailingExpansion) {
1108         ASSERT(count);
1109         --count;
1110         isAfterExpansion = false;
1111     }
1112     return std::make_pair(count, isAfterExpansion);
1113 }
1114 
1115 std::pair&lt;unsigned, bool&gt; FontCascade::expansionOpportunityCountInternal(const UChar* characters, unsigned length, TextDirection direction, ExpansionBehavior expansionBehavior)
1116 {
1117     static bool expandAroundIdeographs = canExpandAroundIdeographsInComplexText();
1118     unsigned count = 0;
1119     bool isAfterExpansion = (expansionBehavior &amp; LeadingExpansionMask) == ForbidLeadingExpansion;
1120     if ((expansionBehavior &amp; LeadingExpansionMask) == ForceLeadingExpansion) {
1121         ++count;
1122         isAfterExpansion = true;
1123     }
1124     if (direction == TextDirection::LTR) {
1125         for (unsigned i = 0; i &lt; length; ++i) {
1126             UChar32 character = characters[i];
1127             if (treatAsSpace(character)) {
1128                 count++;
1129                 isAfterExpansion = true;
1130                 continue;
1131             }
1132             if (U16_IS_LEAD(character) &amp;&amp; i + 1 &lt; length &amp;&amp; U16_IS_TRAIL(characters[i + 1])) {
1133                 character = U16_GET_SUPPLEMENTARY(character, characters[i + 1]);
1134                 i++;
1135             }
1136             if (expandAroundIdeographs &amp;&amp; isCJKIdeographOrSymbol(character)) {
1137                 if (!isAfterExpansion)
1138                     count++;
1139                 count++;
1140                 isAfterExpansion = true;
1141                 continue;
1142             }
1143             isAfterExpansion = false;
1144         }
1145     } else {
1146         for (unsigned i = length; i &gt; 0; --i) {
1147             UChar32 character = characters[i - 1];
1148             if (treatAsSpace(character)) {
1149                 count++;
1150                 isAfterExpansion = true;
1151                 continue;
1152             }
1153             if (U16_IS_TRAIL(character) &amp;&amp; i &gt; 1 &amp;&amp; U16_IS_LEAD(characters[i - 2])) {
1154                 character = U16_GET_SUPPLEMENTARY(characters[i - 2], character);
1155                 i--;
1156             }
1157             if (expandAroundIdeographs &amp;&amp; isCJKIdeographOrSymbol(character)) {
1158                 if (!isAfterExpansion)
1159                     count++;
1160                 count++;
1161                 isAfterExpansion = true;
1162                 continue;
1163             }
1164             isAfterExpansion = false;
1165         }
1166     }
1167     if (!isAfterExpansion &amp;&amp; (expansionBehavior &amp; TrailingExpansionMask) == ForceTrailingExpansion) {
1168         ++count;
1169         isAfterExpansion = true;
1170     } else if (isAfterExpansion &amp;&amp; (expansionBehavior &amp; TrailingExpansionMask) == ForbidTrailingExpansion) {
1171         ASSERT(count);
1172         --count;
1173         isAfterExpansion = false;
1174     }
1175     return std::make_pair(count, isAfterExpansion);
1176 }
1177 
1178 std::pair&lt;unsigned, bool&gt; FontCascade::expansionOpportunityCount(const StringView&amp; stringView, TextDirection direction, ExpansionBehavior expansionBehavior)
1179 {
1180     // For each character, iterating from left to right:
1181     //   If it is recognized as a space, insert an opportunity after it
1182     //   If it is an ideograph, insert one opportunity before it and one opportunity after it
1183     // Do this such a way so that there are not two opportunities next to each other.
1184     if (stringView.is8Bit())
1185         return expansionOpportunityCountInternal(stringView.characters8(), stringView.length(), direction, expansionBehavior);
1186     return expansionOpportunityCountInternal(stringView.characters16(), stringView.length(), direction, expansionBehavior);
1187 }
1188 
1189 bool FontCascade::leadingExpansionOpportunity(const StringView&amp; stringView, TextDirection direction)
1190 {
1191     if (!stringView.length())
1192         return false;
1193 
1194     UChar32 initialCharacter;
1195     if (direction == TextDirection::LTR) {
1196         initialCharacter = stringView[0];
1197         if (U16_IS_LEAD(initialCharacter) &amp;&amp; stringView.length() &gt; 1 &amp;&amp; U16_IS_TRAIL(stringView[1]))
1198             initialCharacter = U16_GET_SUPPLEMENTARY(initialCharacter, stringView[1]);
1199     } else {
1200         initialCharacter = stringView[stringView.length() - 1];
1201         if (U16_IS_TRAIL(initialCharacter) &amp;&amp; stringView.length() &gt; 1 &amp;&amp; U16_IS_LEAD(stringView[stringView.length() - 2]))
1202             initialCharacter = U16_GET_SUPPLEMENTARY(stringView[stringView.length() - 2], initialCharacter);
1203     }
1204 
1205     return canExpandAroundIdeographsInComplexText() &amp;&amp; isCJKIdeographOrSymbol(initialCharacter);
1206 }
1207 
1208 bool FontCascade::trailingExpansionOpportunity(const StringView&amp; stringView, TextDirection direction)
1209 {
1210     if (!stringView.length())
1211         return false;
1212 
1213     UChar32 finalCharacter;
1214     if (direction == TextDirection::LTR) {
1215         finalCharacter = stringView[stringView.length() - 1];
1216         if (U16_IS_TRAIL(finalCharacter) &amp;&amp; stringView.length() &gt; 1 &amp;&amp; U16_IS_LEAD(stringView[stringView.length() - 2]))
1217             finalCharacter = U16_GET_SUPPLEMENTARY(stringView[stringView.length() - 2], finalCharacter);
1218     } else {
1219         finalCharacter = stringView[0];
1220         if (U16_IS_LEAD(finalCharacter) &amp;&amp; stringView.length() &gt; 1 &amp;&amp; U16_IS_TRAIL(stringView[1]))
1221             finalCharacter = U16_GET_SUPPLEMENTARY(finalCharacter, stringView[1]);
1222     }
1223 
1224     return treatAsSpace(finalCharacter) || (canExpandAroundIdeographsInComplexText() &amp;&amp; isCJKIdeographOrSymbol(finalCharacter));
1225 }
1226 
1227 bool FontCascade::canReceiveTextEmphasis(UChar32 c)
1228 {
1229     if (U_GET_GC_MASK(c) &amp; (U_GC_Z_MASK | U_GC_CN_MASK | U_GC_CC_MASK | U_GC_CF_MASK))
1230         return false;
1231 
1232     // Additional word-separator characters listed in CSS Text Level 3 Editor&#39;s Draft 3 November 2010.
1233     if (c == ethiopicWordspace || c == aegeanWordSeparatorLine || c == aegeanWordSeparatorDot
1234         || c == ugariticWordDivider || c == tibetanMarkIntersyllabicTsheg || c == tibetanMarkDelimiterTshegBstar)
1235         return false;
1236 
1237     return true;
1238 }
1239 
1240 bool FontCascade::isLoadingCustomFonts() const
1241 {
1242     return m_fonts &amp;&amp; m_fonts-&gt;isLoadingCustomFonts();
1243 }
1244 
1245 enum class GlyphUnderlineType : uint8_t {
1246     SkipDescenders,
1247     SkipGlyph,
1248     DrawOverGlyph
1249 };
1250 
1251 static GlyphUnderlineType computeUnderlineType(const TextRun&amp; textRun, const GlyphBuffer&amp; glyphBuffer, unsigned index)
1252 {
1253     // In general, we want to skip descenders. However, skipping descenders on CJK characters leads to undesirable renderings,
1254     // so we want to draw through CJK characters (on a character-by-character basis).
1255     // FIXME: The CSS spec says this should instead be done by the user-agent stylesheet using the lang= attribute.
1256     UChar32 baseCharacter;
1257     unsigned offsetInString = glyphBuffer.offsetInString(index);
1258 
1259     if (offsetInString == GlyphBuffer::noOffset || offsetInString &gt;= textRun.length()) {
1260         // We have no idea which character spawned this glyph. Bail.
1261         ASSERT_WITH_SECURITY_IMPLICATION(offsetInString &lt; textRun.length());
1262         return GlyphUnderlineType::DrawOverGlyph;
1263     }
1264 
1265     if (textRun.is8Bit())
1266         baseCharacter = textRun.characters8()[offsetInString];
1267     else
1268         U16_NEXT(textRun.characters16(), offsetInString, textRun.length(), baseCharacter);
1269 
1270     // u_getIntPropertyValue with UCHAR_IDEOGRAPHIC doesn&#39;t return true for Japanese or Korean codepoints.
1271     // Instead, we can use the &quot;Unicode allocation block&quot; for the character.
1272     UBlockCode blockCode = ublock_getCode(baseCharacter);
1273     switch (blockCode) {
1274     case UBLOCK_CJK_RADICALS_SUPPLEMENT:
1275     case UBLOCK_CJK_SYMBOLS_AND_PUNCTUATION:
1276     case UBLOCK_ENCLOSED_CJK_LETTERS_AND_MONTHS:
1277     case UBLOCK_CJK_COMPATIBILITY:
1278     case UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A:
1279     case UBLOCK_CJK_UNIFIED_IDEOGRAPHS:
1280     case UBLOCK_CJK_COMPATIBILITY_IDEOGRAPHS:
1281     case UBLOCK_CJK_COMPATIBILITY_FORMS:
1282     case UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B:
1283     case UBLOCK_CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT:
1284     case UBLOCK_CJK_STROKES:
1285     case UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_C:
1286     case UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_D:
1287     case UBLOCK_IDEOGRAPHIC_DESCRIPTION_CHARACTERS:
1288     case UBLOCK_LINEAR_B_IDEOGRAMS:
1289     case UBLOCK_ENCLOSED_IDEOGRAPHIC_SUPPLEMENT:
1290     case UBLOCK_HIRAGANA:
1291     case UBLOCK_KATAKANA:
1292     case UBLOCK_BOPOMOFO:
1293     case UBLOCK_BOPOMOFO_EXTENDED:
1294     case UBLOCK_HANGUL_JAMO:
1295     case UBLOCK_HANGUL_COMPATIBILITY_JAMO:
1296     case UBLOCK_HANGUL_SYLLABLES:
1297     case UBLOCK_HANGUL_JAMO_EXTENDED_A:
1298     case UBLOCK_HANGUL_JAMO_EXTENDED_B:
1299         return GlyphUnderlineType::DrawOverGlyph;
1300     default:
1301         return GlyphUnderlineType::SkipDescenders;
1302     }
1303 }
1304 
1305 // FIXME: This function may not work if the emphasis mark uses a complex script, but none of the
1306 // standard emphasis marks do so.
1307 Optional&lt;GlyphData&gt; FontCascade::getEmphasisMarkGlyphData(const AtomString&amp; mark) const
1308 {
1309     if (mark.isEmpty())
1310         return WTF::nullopt;
1311 
1312     UChar32 character;
1313     if (!mark.is8Bit()) {
1314         SurrogatePairAwareTextIterator iterator(mark.characters16(), 0, mark.length(), mark.length());
1315         unsigned clusterLength;
1316         if (!iterator.consume(character, clusterLength))
1317             return WTF::nullopt;
1318     } else
1319         character = mark[0];
1320 
1321     Optional&lt;GlyphData&gt; glyphData(glyphDataForCharacter(character, false, EmphasisMarkVariant));
1322     return glyphData.value().isValid() ? glyphData : WTF::nullopt;
1323 }
1324 
1325 int FontCascade::emphasisMarkAscent(const AtomString&amp; mark) const
1326 {
1327     Optional&lt;GlyphData&gt; markGlyphData = getEmphasisMarkGlyphData(mark);
1328     if (!markGlyphData)
1329         return 0;
1330 
1331     const Font* markFontData = markGlyphData.value().font;
1332     ASSERT(markFontData);
1333     if (!markFontData)
1334         return 0;
1335 
1336     return markFontData-&gt;fontMetrics().ascent();
1337 }
1338 
1339 int FontCascade::emphasisMarkDescent(const AtomString&amp; mark) const
1340 {
1341     Optional&lt;GlyphData&gt; markGlyphData = getEmphasisMarkGlyphData(mark);
1342     if (!markGlyphData)
1343         return 0;
1344 
1345     const Font* markFontData = markGlyphData.value().font;
1346     ASSERT(markFontData);
1347     if (!markFontData)
1348         return 0;
1349 
1350     return markFontData-&gt;fontMetrics().descent();
1351 }
1352 
1353 int FontCascade::emphasisMarkHeight(const AtomString&amp; mark) const
1354 {
1355     Optional&lt;GlyphData&gt; markGlyphData = getEmphasisMarkGlyphData(mark);
1356     if (!markGlyphData)
1357         return 0;
1358 
1359     const Font* markFontData = markGlyphData.value().font;
1360     ASSERT(markFontData);
1361     if (!markFontData)
1362         return 0;
1363 
1364     return markFontData-&gt;fontMetrics().height();
1365 }
1366 
1367 float FontCascade::getGlyphsAndAdvancesForSimpleText(const TextRun&amp; run, unsigned from, unsigned to, GlyphBuffer&amp; glyphBuffer, ForTextEmphasisOrNot forTextEmphasis) const
1368 {
1369     float initialAdvance;
1370 
1371     WidthIterator it(this, run, 0, false, forTextEmphasis);
1372     // FIXME: Using separate glyph buffers for the prefix and the suffix is incorrect when kerning or
1373     // ligatures are enabled.
1374     GlyphBuffer localGlyphBuffer;
1375     it.advance(from, &amp;localGlyphBuffer);
1376     float beforeWidth = it.m_runWidthSoFar;
1377     it.advance(to, &amp;glyphBuffer);
1378 
1379     if (glyphBuffer.isEmpty())
1380         return 0;
1381 
1382     float afterWidth = it.m_runWidthSoFar;
1383 
1384     if (run.rtl()) {
1385         float finalRoundingWidth = it.m_finalRoundingWidth;
1386         it.advance(run.length(), &amp;localGlyphBuffer);
1387         initialAdvance = finalRoundingWidth + it.m_runWidthSoFar - afterWidth;
1388     } else
1389         initialAdvance = beforeWidth;
1390 
1391     if (run.rtl())
1392         glyphBuffer.reverse(0, glyphBuffer.size());
1393 
1394     return initialAdvance;
1395 }
1396 
<a name="16" id="anc16"></a><span class="line-modified">1397 FloatSize FontCascade::getGlyphsAndAdvancesForComplexText(const TextRun&amp; run, unsigned from, unsigned to, GlyphBuffer&amp; glyphBuffer, ForTextEmphasisOrNot forTextEmphasis) const</span>

1398 {
<a name="17" id="anc17"></a><span class="line-modified">1399     FloatSize initialAdvance;</span>
1400 
1401     ComplexTextController controller(*this, run, false, 0, forTextEmphasis);
1402     GlyphBuffer dummyGlyphBuffer;
1403     controller.advance(from, &amp;dummyGlyphBuffer);
1404     controller.advance(to, &amp;glyphBuffer);
1405 
1406     if (glyphBuffer.isEmpty())
<a name="18" id="anc18"></a><span class="line-modified">1407         return { };</span>
1408 
1409     if (run.rtl()) {
1410         // Exploit the fact that the sum of the paint advances is equal to
1411         // the sum of the layout advances.
<a name="19" id="anc19"></a><span class="line-modified">1412         initialAdvance = controller.totalAdvance();</span>
1413         for (unsigned i = 0; i &lt; dummyGlyphBuffer.size(); ++i)
<a name="20" id="anc20"></a><span class="line-modified">1414             initialAdvance -= toFloatSize(dummyGlyphBuffer.advanceAt(i));</span>
1415         for (unsigned i = 0; i &lt; glyphBuffer.size(); ++i)
<a name="21" id="anc21"></a><span class="line-modified">1416             initialAdvance -= toFloatSize(glyphBuffer.advanceAt(i));</span>
1417         glyphBuffer.reverse(0, glyphBuffer.size());
1418     } else {
<a name="22" id="anc22"></a><span class="line-modified">1419         initialAdvance = toFloatSize(dummyGlyphBuffer.initialAdvance());</span>
1420         for (unsigned i = 0; i &lt; dummyGlyphBuffer.size(); ++i)
<a name="23" id="anc23"></a><span class="line-modified">1421             initialAdvance += toFloatSize(dummyGlyphBuffer.advanceAt(i));</span>
1422     }
1423 
1424     return initialAdvance;
1425 }
<a name="24" id="anc24"></a>
1426 
1427 void FontCascade::drawEmphasisMarksForSimpleText(GraphicsContext&amp; context, const TextRun&amp; run, const AtomString&amp; mark, const FloatPoint&amp; point, unsigned from, unsigned to) const
1428 {
1429     GlyphBuffer glyphBuffer;
1430     float initialAdvance = getGlyphsAndAdvancesForSimpleText(run, from, to, glyphBuffer, ForTextEmphasis);
1431 
1432     if (glyphBuffer.isEmpty())
1433         return;
1434 
1435     drawEmphasisMarks(context, glyphBuffer, mark, FloatPoint(point.x() + initialAdvance, point.y()));
1436 }
1437 
1438 inline bool shouldDrawIfLoading(const Font&amp; font, FontCascade::CustomFontNotReadyAction customFontNotReadyAction)
1439 {
1440     // Don&#39;t draw anything while we are using custom fonts that are in the process of loading,
1441     // except if the &#39;customFontNotReadyAction&#39; argument is set to UseFallbackIfFontNotReady
1442     // (in which case &quot;font&quot; will be a fallback font).
1443     return !font.isInterstitial() || font.visibility() == Font::Visibility::Visible || customFontNotReadyAction == FontCascade::CustomFontNotReadyAction::UseFallbackIfFontNotReady;
1444 }
1445 
1446 void FontCascade::drawGlyphBuffer(GraphicsContext&amp; context, const GlyphBuffer&amp; glyphBuffer, FloatPoint&amp; point, CustomFontNotReadyAction customFontNotReadyAction) const
1447 {
1448     // Draw each contiguous run of glyphs that use the same font data.
1449     const Font* fontData = glyphBuffer.fontAt(0);
<a name="25" id="anc25"></a><span class="line-modified">1450     FloatPoint startPoint = point;</span>






1451     float nextX = startPoint.x() + glyphBuffer.advanceAt(0).width();
1452     float nextY = startPoint.y() + glyphBuffer.advanceAt(0).height();
1453     unsigned lastFrom = 0;
1454     unsigned nextGlyph = 1;
1455     while (nextGlyph &lt; glyphBuffer.size()) {
1456         const Font* nextFontData = glyphBuffer.fontAt(nextGlyph);
1457 
1458         if (nextFontData != fontData) {
1459             if (shouldDrawIfLoading(*fontData, customFontNotReadyAction))
1460                 context.drawGlyphs(*fontData, glyphBuffer, lastFrom, nextGlyph - lastFrom, startPoint, m_fontDescription.fontSmoothing());
1461 
1462             lastFrom = nextGlyph;
1463             fontData = nextFontData;
1464             startPoint.setX(nextX);
1465             startPoint.setY(nextY);
1466         }
1467         nextX += glyphBuffer.advanceAt(nextGlyph).width();
1468         nextY += glyphBuffer.advanceAt(nextGlyph).height();
1469         nextGlyph++;
1470     }
1471 
1472     if (shouldDrawIfLoading(*fontData, customFontNotReadyAction))
1473         context.drawGlyphs(*fontData, glyphBuffer, lastFrom, nextGlyph - lastFrom, startPoint, m_fontDescription.fontSmoothing());
1474     point.setX(nextX);
1475 }
1476 
1477 inline static float offsetToMiddleOfGlyph(const Font* fontData, Glyph glyph)
1478 {
1479     if (fontData-&gt;platformData().orientation() == FontOrientation::Horizontal) {
1480         FloatRect bounds = fontData-&gt;boundsForGlyph(glyph);
1481         return bounds.x() + bounds.width() / 2;
1482     }
1483     // FIXME: Use glyph bounds once they make sense for vertical fonts.
1484     return fontData-&gt;widthForGlyph(glyph) / 2;
1485 }
1486 
1487 inline static float offsetToMiddleOfGlyphAtIndex(const GlyphBuffer&amp; glyphBuffer, unsigned i)
1488 {
1489     return offsetToMiddleOfGlyph(glyphBuffer.fontAt(i), glyphBuffer.glyphAt(i));
1490 }
1491 
1492 void FontCascade::drawEmphasisMarks(GraphicsContext&amp; context, const GlyphBuffer&amp; glyphBuffer, const AtomString&amp; mark, const FloatPoint&amp; point) const
1493 {
1494     Optional&lt;GlyphData&gt; markGlyphData = getEmphasisMarkGlyphData(mark);
1495     if (!markGlyphData)
1496         return;
1497 
1498     const Font* markFontData = markGlyphData.value().font;
1499     ASSERT(markFontData);
1500     if (!markFontData)
1501         return;
1502 
1503     Glyph markGlyph = markGlyphData.value().glyph;
1504     Glyph spaceGlyph = markFontData-&gt;spaceGlyph();
1505 
1506     float middleOfLastGlyph = offsetToMiddleOfGlyphAtIndex(glyphBuffer, 0);
1507     FloatPoint startPoint(point.x() + middleOfLastGlyph - offsetToMiddleOfGlyph(markFontData, markGlyph), point.y());
1508 
1509     GlyphBuffer markBuffer;
1510     for (unsigned i = 0; i + 1 &lt; glyphBuffer.size(); ++i) {
1511         float middleOfNextGlyph = offsetToMiddleOfGlyphAtIndex(glyphBuffer, i + 1);
1512         float advance = glyphBuffer.advanceAt(i).width() - middleOfLastGlyph + middleOfNextGlyph;
1513         markBuffer.add(glyphBuffer.glyphAt(i) ? markGlyph : spaceGlyph, markFontData, advance);
1514         middleOfLastGlyph = middleOfNextGlyph;
1515     }
1516     markBuffer.add(glyphBuffer.glyphAt(glyphBuffer.size() - 1) ? markGlyph : spaceGlyph, markFontData, 0);
1517 
1518     drawGlyphBuffer(context, markBuffer, startPoint, CustomFontNotReadyAction::DoNotPaintIfFontNotReady);
1519 }
1520 
1521 float FontCascade::floatWidthForSimpleText(const TextRun&amp; run, HashSet&lt;const Font*&gt;* fallbackFonts, GlyphOverflow* glyphOverflow) const
1522 {
1523     WidthIterator it(this, run, fallbackFonts, glyphOverflow);
1524     GlyphBuffer glyphBuffer;
1525     it.advance(run.length(), (enableKerning() || requiresShaping()) ? &amp;glyphBuffer : nullptr);
1526 
1527     if (glyphOverflow) {
1528         glyphOverflow-&gt;top = std::max&lt;int&gt;(glyphOverflow-&gt;top, ceilf(-it.minGlyphBoundingBoxY()) - (glyphOverflow-&gt;computeBounds ? 0 : fontMetrics().ascent()));
1529         glyphOverflow-&gt;bottom = std::max&lt;int&gt;(glyphOverflow-&gt;bottom, ceilf(it.maxGlyphBoundingBoxY()) - (glyphOverflow-&gt;computeBounds ? 0 : fontMetrics().descent()));
1530         glyphOverflow-&gt;left = ceilf(it.firstGlyphOverflow());
1531         glyphOverflow-&gt;right = ceilf(it.lastGlyphOverflow());
1532     }
1533 
1534     return it.m_runWidthSoFar;
1535 }
1536 
<a name="26" id="anc26"></a>
1537 float FontCascade::floatWidthForComplexText(const TextRun&amp; run, HashSet&lt;const Font*&gt;* fallbackFonts, GlyphOverflow* glyphOverflow) const
1538 {
1539     ComplexTextController controller(*this, run, true, fallbackFonts);
1540     if (glyphOverflow) {
1541         glyphOverflow-&gt;top = std::max&lt;int&gt;(glyphOverflow-&gt;top, ceilf(-controller.minGlyphBoundingBoxY()) - (glyphOverflow-&gt;computeBounds ? 0 : fontMetrics().ascent()));
1542         glyphOverflow-&gt;bottom = std::max&lt;int&gt;(glyphOverflow-&gt;bottom, ceilf(controller.maxGlyphBoundingBoxY()) - (glyphOverflow-&gt;computeBounds ? 0 : fontMetrics().descent()));
1543         glyphOverflow-&gt;left = std::max&lt;int&gt;(0, ceilf(-controller.minGlyphBoundingBoxX()));
<a name="27" id="anc27"></a><span class="line-modified">1544         glyphOverflow-&gt;right = std::max&lt;int&gt;(0, ceilf(controller.maxGlyphBoundingBoxX() - controller.totalAdvance().width()));</span>
1545     }
<a name="28" id="anc28"></a><span class="line-modified">1546     return controller.totalAdvance().width();</span>
1547 }
<a name="29" id="anc29"></a>
1548 
1549 void FontCascade::adjustSelectionRectForSimpleText(const TextRun&amp; run, LayoutRect&amp; selectionRect, unsigned from, unsigned to) const
1550 {
1551     GlyphBuffer glyphBuffer;
1552     WidthIterator it(this, run);
1553     it.advance(from, &amp;glyphBuffer);
1554     float beforeWidth = it.m_runWidthSoFar;
1555     it.advance(to, &amp;glyphBuffer);
1556     float afterWidth = it.m_runWidthSoFar;
1557     float totalWidth = -1;
1558 
1559     if (run.rtl()) {
1560         it.advance(run.length(), &amp;glyphBuffer);
1561         totalWidth = it.m_runWidthSoFar;
1562         selectionRect.move(totalWidth - afterWidth, 0);
1563     } else
1564         selectionRect.move(beforeWidth, 0);
1565     selectionRect.setWidth(LayoutUnit::fromFloatCeil(afterWidth - beforeWidth));
1566 }
1567 
<a name="30" id="anc30"></a>
1568 void FontCascade::adjustSelectionRectForComplexText(const TextRun&amp; run, LayoutRect&amp; selectionRect, unsigned from, unsigned to) const
1569 {
1570     ComplexTextController controller(*this, run);
1571     controller.advance(from);
1572     float beforeWidth = controller.runWidthSoFar();
1573     controller.advance(to);
1574     float afterWidth = controller.runWidthSoFar();
1575 
1576     if (run.rtl())
<a name="31" id="anc31"></a><span class="line-modified">1577         selectionRect.move(controller.totalAdvance().width() - afterWidth, 0);</span>
1578     else
1579         selectionRect.move(beforeWidth, 0);
1580     selectionRect.setWidth(LayoutUnit::fromFloatCeil(afterWidth - beforeWidth));
1581 }
<a name="32" id="anc32"></a>
1582 
1583 int FontCascade::offsetForPositionForSimpleText(const TextRun&amp; run, float x, bool includePartialGlyphs) const
1584 {
1585     float delta = x;
1586 
1587     WidthIterator it(this, run);
1588     GlyphBuffer localGlyphBuffer;
1589     unsigned offset;
1590     if (run.rtl()) {
1591         delta -= floatWidthForSimpleText(run);
1592         while (1) {
1593             offset = it.m_currentCharacter;
1594             float w;
1595             if (!it.advanceOneCharacter(w, localGlyphBuffer))
1596                 break;
1597             delta += w;
1598             if (includePartialGlyphs) {
1599                 if (delta - w / 2 &gt;= 0)
1600                     break;
1601             } else {
1602                 if (delta &gt;= 0)
1603                     break;
1604             }
1605         }
1606     } else {
1607         while (1) {
1608             offset = it.m_currentCharacter;
1609             float w;
1610             if (!it.advanceOneCharacter(w, localGlyphBuffer))
1611                 break;
1612             delta -= w;
1613             if (includePartialGlyphs) {
1614                 if (delta + w / 2 &lt;= 0)
1615                     break;
1616             } else {
1617                 if (delta &lt;= 0)
1618                     break;
1619             }
1620         }
1621     }
1622 
1623     return offset;
1624 }
1625 
<a name="33" id="anc33"></a>
1626 int FontCascade::offsetForPositionForComplexText(const TextRun&amp; run, float x, bool includePartialGlyphs) const
1627 {
1628     ComplexTextController controller(*this, run);
1629     return controller.offsetForPosition(x, includePartialGlyphs);
1630 }
<a name="34" id="anc34"></a>
1631 
1632 #if !PLATFORM(COCOA) &amp;&amp; !USE(HARFBUZZ)
1633 // FIXME: Unify this with the macOS and iOS implementation.
1634 const Font* FontCascade::fontForCombiningCharacterSequence(const UChar* characters, size_t length) const
1635 {
1636     UChar32 baseCharacter;
1637     size_t baseCharacterLength = 0;
1638     U16_NEXT(characters, baseCharacterLength, length, baseCharacter);
1639     GlyphData baseCharacterGlyphData = glyphDataForCharacter(baseCharacter, false, NormalVariant);
1640 
1641     if (!baseCharacterGlyphData.glyph)
1642         return nullptr;
1643     return baseCharacterGlyphData.font;
1644 }
1645 #endif
1646 
1647 void FontCascade::drawEmphasisMarksForComplexText(GraphicsContext&amp; context, const TextRun&amp; run, const AtomString&amp; mark, const FloatPoint&amp; point, unsigned from, unsigned to) const
1648 {
1649     GlyphBuffer glyphBuffer;
<a name="35" id="anc35"></a><span class="line-modified">1650     auto initialAdvance = getGlyphsAndAdvancesForComplexText(run, from, to, glyphBuffer, ForTextEmphasis);</span>
1651 
1652     if (glyphBuffer.isEmpty())
1653         return;
1654 
<a name="36" id="anc36"></a><span class="line-modified">1655     drawEmphasisMarks(context, glyphBuffer, mark, point + initialAdvance);</span>
1656 }
1657 
1658 struct GlyphIterationState {
1659     FloatPoint startingPoint;
1660     FloatPoint currentPoint;
1661     float y1;
1662     float y2;
1663     float minX;
1664     float maxX;
1665 };
1666 
1667 static Optional&lt;float&gt; findIntersectionPoint(float y, FloatPoint p1, FloatPoint p2)
1668 {
1669     if ((p1.y() &lt; y &amp;&amp; p2.y() &gt; y) || (p1.y() &gt; y &amp;&amp; p2.y() &lt; y))
1670         return p1.x() + (y - p1.y()) * (p2.x() - p1.x()) / (p2.y() - p1.y());
1671     return WTF::nullopt;
1672 }
1673 
1674 static void updateX(GlyphIterationState&amp; state, float x)
1675 {
1676     state.minX = std::min(state.minX, x);
1677     state.maxX = std::max(state.maxX, x);
1678 }
1679 
1680 // This function is called by CGPathApply and is therefore invoked for each
1681 // contour in a glyph. This function models each contours as a straight line
1682 // and calculates the intersections between each pseudo-contour and
1683 // two horizontal lines (the upper and lower bounds of an underline) found in
1684 // GlyphIterationState::y1 and GlyphIterationState::y2. It keeps track of the
1685 // leftmost and rightmost intersection in GlyphIterationState::minX and
1686 // GlyphIterationState::maxX.
1687 static void findPathIntersections(GlyphIterationState&amp; state, const PathElement&amp; element)
1688 {
1689     bool doIntersection = false;
1690     FloatPoint point = FloatPoint();
1691     switch (element.type) {
<a name="37" id="anc37"></a><span class="line-modified">1692     case PathElement::Type::MoveToPoint:</span>
1693         state.startingPoint = element.points[0];
1694         state.currentPoint = element.points[0];
1695         break;
<a name="38" id="anc38"></a><span class="line-modified">1696     case PathElement::Type::AddLineToPoint:</span>
1697         doIntersection = true;
1698         point = element.points[0];
1699         break;
<a name="39" id="anc39"></a><span class="line-modified">1700     case PathElement::Type::AddQuadCurveToPoint:</span>
1701         doIntersection = true;
1702         point = element.points[1];
1703         break;
<a name="40" id="anc40"></a><span class="line-modified">1704     case PathElement::Type::AddCurveToPoint:</span>
1705         doIntersection = true;
1706         point = element.points[2];
1707         break;
<a name="41" id="anc41"></a><span class="line-modified">1708     case PathElement::Type::CloseSubpath:</span>
1709         doIntersection = true;
1710         point = state.startingPoint;
1711         break;
1712     }
1713     if (!doIntersection)
1714         return;
1715     if (auto intersectionPoint = findIntersectionPoint(state.y1, state.currentPoint, point))
1716         updateX(state, *intersectionPoint);
1717     if (auto intersectionPoint = findIntersectionPoint(state.y2, state.currentPoint, point))
1718         updateX(state, *intersectionPoint);
1719     if ((state.currentPoint.y() &gt;= state.y1 &amp;&amp; state.currentPoint.y() &lt;= state.y2)
1720         || (state.currentPoint.y() &lt;= state.y1 &amp;&amp; state.currentPoint.y() &gt;= state.y2))
1721         updateX(state, state.currentPoint.x());
1722     state.currentPoint = point;
1723 }
1724 
1725 class GlyphToPathTranslator {
1726 public:
1727     GlyphToPathTranslator(const TextRun&amp; textRun, const GlyphBuffer&amp; glyphBuffer, const FloatPoint&amp; textOrigin)
1728         : m_index(0)
1729         , m_textRun(textRun)
1730         , m_glyphBuffer(glyphBuffer)
1731         , m_fontData(glyphBuffer.fontAt(m_index))
1732         , m_translation(AffineTransform::translation(textOrigin.x(), textOrigin.y()))
1733     {
1734 #if USE(CG)
1735         m_translation.flipY();
1736 #endif
1737     }
1738 
1739     bool containsMorePaths() { return m_index != m_glyphBuffer.size(); }
1740     Path path();
1741     std::pair&lt;float, float&gt; extents();
1742     GlyphUnderlineType underlineType();
1743     void advance();
1744 
1745 private:
1746     unsigned m_index;
1747     const TextRun&amp; m_textRun;
1748     const GlyphBuffer&amp; m_glyphBuffer;
1749     const Font* m_fontData;
1750     AffineTransform m_translation;
1751 };
1752 
1753 Path GlyphToPathTranslator::path()
1754 {
1755     Path path = m_fontData-&gt;pathForGlyph(m_glyphBuffer.glyphAt(m_index));
1756     path.transform(m_translation);
1757     return path;
1758 }
1759 
1760 std::pair&lt;float, float&gt; GlyphToPathTranslator::extents()
1761 {
1762     auto beginning = m_translation.mapPoint(FloatPoint(0, 0));
1763     auto advance = m_glyphBuffer.advanceAt(m_index);
1764     auto end = m_translation.mapSize(FloatSize(advance.width(), advance.height()));
1765     return std::make_pair(beginning.x(), beginning.x() + end.width());
1766 }
1767 
1768 auto GlyphToPathTranslator::underlineType() -&gt; GlyphUnderlineType
1769 {
1770     return computeUnderlineType(m_textRun, m_glyphBuffer, m_index);
1771 }
1772 
1773 void GlyphToPathTranslator::advance()
1774 {
1775     GlyphBufferAdvance advance = m_glyphBuffer.advanceAt(m_index);
1776     m_translation.translate(FloatSize(advance.width(), advance.height()));
1777     ++m_index;
1778     if (m_index &lt; m_glyphBuffer.size())
1779         m_fontData = m_glyphBuffer.fontAt(m_index);
1780 }
1781 
1782 DashArray FontCascade::dashesForIntersectionsWithRect(const TextRun&amp; run, const FloatPoint&amp; textOrigin, const FloatRect&amp; lineExtents) const
1783 {
1784     if (isLoadingCustomFonts())
1785         return DashArray();
1786 
1787     GlyphBuffer glyphBuffer;
1788     glyphBuffer.saveOffsetsInString();
1789     float deltaX;
1790     if (codePath(run) != FontCascade::Complex)
1791         deltaX = getGlyphsAndAdvancesForSimpleText(run, 0, run.length(), glyphBuffer);
1792     else
<a name="42" id="anc42"></a><span class="line-modified">1793         deltaX = getGlyphsAndAdvancesForComplexText(run, 0, run.length(), glyphBuffer).width();</span>
1794 
1795     if (!glyphBuffer.size())
1796         return DashArray();
1797 
1798     FloatPoint origin = FloatPoint(textOrigin.x() + deltaX, textOrigin.y());
1799     GlyphToPathTranslator translator(run, glyphBuffer, origin);
1800     DashArray result;
1801     for (unsigned index = 0; translator.containsMorePaths(); ++index, translator.advance()) {
1802         GlyphIterationState info = { FloatPoint(0, 0), FloatPoint(0, 0), lineExtents.y(), lineExtents.y() + lineExtents.height(), lineExtents.x() + lineExtents.width(), lineExtents.x() };
1803         const Font* localFont = glyphBuffer.fontAt(index);
1804         if (!localFont) {
1805             // The advances will get all messed up if we do anything other than bail here.
1806             result.clear();
1807             break;
1808         }
1809         switch (translator.underlineType()) {
1810         case GlyphUnderlineType::SkipDescenders: {
1811             Path path = translator.path();
1812             path.apply([&amp;](const PathElement&amp; element) {
1813                 findPathIntersections(info, element);
1814             });
1815             if (info.minX &lt; info.maxX) {
1816                 result.append(info.minX - lineExtents.x());
1817                 result.append(info.maxX - lineExtents.x());
1818             }
1819             break;
1820         }
1821         case GlyphUnderlineType::SkipGlyph: {
1822             std::pair&lt;float, float&gt; extents = translator.extents();
1823             result.append(extents.first - lineExtents.x());
1824             result.append(extents.second - lineExtents.x());
1825             break;
1826         }
1827         case GlyphUnderlineType::DrawOverGlyph:
1828             // Nothing to do
1829             break;
1830         }
1831     }
1832     return result;
1833 }
1834 
1835 }
<a name="43" id="anc43"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="43" type="hidden" />
</body>
</html>
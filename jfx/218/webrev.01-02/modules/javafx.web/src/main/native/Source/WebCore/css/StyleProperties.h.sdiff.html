<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/StyleProperties.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StyleProperties.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleRule.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/StyleProperties.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 33 
 34 namespace WebCore {
 35 
 36 class CSSDeferredParser;
 37 class CSSStyleDeclaration;
 38 class CachedResource;
 39 class Color;
 40 class ImmutableStyleProperties;
 41 class MutableStyleProperties;
 42 class PropertySetCSSStyleDeclaration;
 43 class StyledElement;
 44 class StylePropertyShorthand;
 45 class StyleSheetContents;
 46 
 47 enum StylePropertiesType { ImmutablePropertiesType, MutablePropertiesType, DeferredPropertiesType };
 48 
 49 class StylePropertiesBase : public RefCounted&lt;StylePropertiesBase&gt; {
 50 public:
 51     // Override RefCounted&#39;s deref() to ensure operator delete is called on
 52     // the appropriate subclass type.
<span class="line-modified"> 53     void deref();</span>
 54 
 55     StylePropertiesType type() const { return static_cast&lt;StylePropertiesType&gt;(m_type); }
 56 
 57     CSSParserMode cssParserMode() const { return static_cast&lt;CSSParserMode&gt;(m_cssParserMode); }
 58 
 59 protected:
 60     StylePropertiesBase(CSSParserMode cssParserMode, StylePropertiesType type)
 61         : m_cssParserMode(cssParserMode)
 62         , m_type(type)
 63         , m_arraySize(0)
 64     { }
 65 
 66     StylePropertiesBase(CSSParserMode cssParserMode, unsigned immutableArraySize)
 67         : m_cssParserMode(cssParserMode)
 68         , m_type(ImmutablePropertiesType)
 69         , m_arraySize(immutableArraySize)
 70     { }
 71 
 72     unsigned m_cssParserMode : 3;
 73     mutable unsigned m_type : 2;
 74     unsigned m_arraySize : 27;
 75 };
 76 

 77 class StyleProperties : public StylePropertiesBase {

 78     friend class PropertyReference;
 79 public:
 80     class PropertyReference {
 81     public:
 82         PropertyReference(const StylePropertyMetadata&amp; metadata, const CSSValue* value)
 83             : m_metadata(metadata)
 84             , m_value(value)
 85         { }
 86 
 87         CSSPropertyID id() const { return static_cast&lt;CSSPropertyID&gt;(m_metadata.m_propertyID); }
 88         CSSPropertyID shorthandID() const { return m_metadata.shorthandID(); }
 89 
 90         bool isImportant() const { return m_metadata.m_important; }
 91         bool isInherited() const { return m_metadata.m_inherited; }
 92         bool isImplicit() const { return m_metadata.m_implicit; }
 93 
 94         String cssName() const;
 95         String cssText() const;
 96 
 97         const CSSValue* value() const { return m_value; }
</pre>
<hr />
<pre>
142 
143 #ifndef NDEBUG
144     void showStyle();
145 #endif
146 
147     bool propertyMatches(CSSPropertyID, const CSSValue*) const;
148 
149 protected:
150     StyleProperties(CSSParserMode cssParserMode, StylePropertiesType type)
151         : StylePropertiesBase(cssParserMode, type)
152     { }
153 
154     StyleProperties(CSSParserMode cssParserMode, unsigned immutableArraySize)
155         : StylePropertiesBase(cssParserMode, immutableArraySize)
156     { }
157 
158     int findPropertyIndex(CSSPropertyID) const;
159     int findCustomPropertyIndex(const String&amp; propertyName) const;
160 
161 private:
<span class="line-modified">162     String getShorthandValue(const StylePropertyShorthand&amp;) const;</span>

163     String getCommonValue(const StylePropertyShorthand&amp;) const;
164     String getAlignmentShorthandValue(const StylePropertyShorthand&amp;) const;
165     String borderPropertyValue(const StylePropertyShorthand&amp;, const StylePropertyShorthand&amp;, const StylePropertyShorthand&amp;) const;
166     String pageBreakPropertyValue(const StylePropertyShorthand&amp;) const;
167     String getLayeredShorthandValue(const StylePropertyShorthand&amp;) const;
168     String get2Values(const StylePropertyShorthand&amp;) const;
169     String get4Values(const StylePropertyShorthand&amp;) const;
170     String borderSpacingValue(const StylePropertyShorthand&amp;) const;
171     String fontValue() const;
172     void appendFontLonghandValueIfExplicit(CSSPropertyID, StringBuilder&amp; result, String&amp; value) const;
173 
174     RefPtr&lt;CSSValue&gt; getPropertyCSSValueInternal(CSSPropertyID) const;
175 
176     friend class PropertySetCSSStyleDeclaration;
177 };
178 

179 class ImmutableStyleProperties final : public StyleProperties {

180 public:
181     WEBCORE_EXPORT ~ImmutableStyleProperties();
182     static Ref&lt;ImmutableStyleProperties&gt; create(const CSSProperty* properties, unsigned count, CSSParserMode);
183 
184     unsigned propertyCount() const { return m_arraySize; }
185     bool isEmpty() const { return !propertyCount(); }
186     PropertyReference propertyAt(unsigned index) const;
187 
<span class="line-removed">188     const CSSValue** valueArray() const;</span>
<span class="line-removed">189     const StylePropertyMetadata* metadataArray() const;</span>
190     int findPropertyIndex(CSSPropertyID) const;
191     int findCustomPropertyIndex(const String&amp; propertyName) const;
192 
193     void* m_storage;
194 
195 private:


196     ImmutableStyleProperties(const CSSProperty*, unsigned count, CSSParserMode);
197 };
198 
<span class="line-modified">199 inline const CSSValue** ImmutableStyleProperties::valueArray() const</span>
200 {
<span class="line-modified">201     return reinterpret_cast&lt;const CSSValue**&gt;(const_cast&lt;const void**&gt;((&amp;(this-&gt;m_storage))));</span>
202 }
203 
204 inline const StylePropertyMetadata* ImmutableStyleProperties::metadataArray() const
205 {
<span class="line-modified">206     return reinterpret_cast_ptr&lt;const StylePropertyMetadata*&gt;(&amp;reinterpret_cast_ptr&lt;const char*&gt;(&amp;(this-&gt;m_storage))[m_arraySize * sizeof(CSSValue*)]);</span>
207 }
208 

209 class MutableStyleProperties final : public StyleProperties {

210 public:
211     WEBCORE_EXPORT static Ref&lt;MutableStyleProperties&gt; create(CSSParserMode = HTMLQuirksMode);
<span class="line-modified">212     static Ref&lt;MutableStyleProperties&gt; create(const CSSProperty* properties, unsigned count);</span>
213 
214     WEBCORE_EXPORT ~MutableStyleProperties();
215 
216     unsigned propertyCount() const { return m_propertyVector.size(); }
217     bool isEmpty() const { return !propertyCount(); }
218     PropertyReference propertyAt(unsigned index) const;
219 
220     PropertySetCSSStyleDeclaration* cssStyleDeclaration();
221 
222     bool addParsedProperties(const ParsedPropertyVector&amp;);
223     bool addParsedProperty(const CSSProperty&amp;);
224 
225     // These expand shorthand properties into multiple properties.
226     bool setProperty(CSSPropertyID, const String&amp; value, bool important, CSSParserContext);
227     bool setProperty(CSSPropertyID, const String&amp; value, bool important = false);
228     void setProperty(CSSPropertyID, RefPtr&lt;CSSValue&gt;&amp;&amp;, bool important = false);
229 
230     // These do not. FIXME: This is too messy, we can do better.
231     bool setProperty(CSSPropertyID, CSSValueID identifier, bool important = false);
232     bool setProperty(CSSPropertyID, CSSPropertyID identifier, bool important = false);
</pre>
<hr />
<pre>
239     void mergeAndOverrideOnConflict(const StyleProperties&amp;);
240 
241     void clear();
242     bool parseDeclaration(const String&amp; styleDeclaration, CSSParserContext);
243 
244     WEBCORE_EXPORT CSSStyleDeclaration&amp; ensureCSSStyleDeclaration();
245     CSSStyleDeclaration&amp; ensureInlineCSSStyleDeclaration(StyledElement&amp; parentElement);
246 
247     int findPropertyIndex(CSSPropertyID) const;
248     int findCustomPropertyIndex(const String&amp; propertyName) const;
249 
250     Vector&lt;CSSProperty, 4&gt; m_propertyVector;
251 
252     // Methods for querying and altering CSS custom properties.
253     bool setCustomProperty(const Document*, const String&amp; propertyName, const String&amp; value, bool important, CSSParserContext);
254     bool removeCustomProperty(const String&amp; propertyName, String* returnText = nullptr);
255 
256 private:
257     explicit MutableStyleProperties(CSSParserMode);
258     explicit MutableStyleProperties(const StyleProperties&amp;);
<span class="line-modified">259     MutableStyleProperties(const CSSProperty* properties, unsigned count);</span>
260 
261     bool removeShorthandProperty(CSSPropertyID);
262     CSSProperty* findCSSPropertyWithID(CSSPropertyID);
263     CSSProperty* findCustomCSSPropertyWithName(const String&amp;);
264     std::unique_ptr&lt;PropertySetCSSStyleDeclaration&gt; m_cssomWrapper;
265 
266     friend class StyleProperties;
267 };
268 
269 class DeferredStyleProperties final : public StylePropertiesBase {
270 public:
271     WEBCORE_EXPORT ~DeferredStyleProperties();
272     static Ref&lt;DeferredStyleProperties&gt; create(const CSSParserTokenRange&amp;, CSSDeferredParser&amp;);
273 
274     Ref&lt;ImmutableStyleProperties&gt; parseDeferredProperties();
275 
276 private:
277     DeferredStyleProperties(const CSSParserTokenRange&amp;, CSSDeferredParser&amp;);
278 
279     Vector&lt;CSSParserToken&gt; m_tokens;
280     Ref&lt;CSSDeferredParser&gt; m_parser;
281 };
282 
283 inline ImmutableStyleProperties::PropertyReference ImmutableStyleProperties::propertyAt(unsigned index) const
284 {
<span class="line-modified">285     return PropertyReference(metadataArray()[index], valueArray()[index]);</span>
286 }
287 
288 inline MutableStyleProperties::PropertyReference MutableStyleProperties::propertyAt(unsigned index) const
289 {
290     const CSSProperty&amp; property = m_propertyVector[index];
291     return PropertyReference(property.metadata(), property.value());
292 }
293 
294 inline StyleProperties::PropertyReference StyleProperties::propertyAt(unsigned index) const
295 {
296     if (is&lt;MutableStyleProperties&gt;(*this))
297         return downcast&lt;MutableStyleProperties&gt;(*this).propertyAt(index);
298     return downcast&lt;ImmutableStyleProperties&gt;(*this).propertyAt(index);
299 }
300 
301 inline unsigned StyleProperties::propertyCount() const
302 {
303     if (is&lt;MutableStyleProperties&gt;(*this))
304         return downcast&lt;MutableStyleProperties&gt;(*this).propertyCount();
305     return downcast&lt;ImmutableStyleProperties&gt;(*this).propertyCount();
306 }
307 
<span class="line-modified">308 inline void StylePropertiesBase::deref()</span>
309 {
310     if (!derefBase())
311         return;
312 
313     if (is&lt;MutableStyleProperties&gt;(*this))
314         delete downcast&lt;MutableStyleProperties&gt;(this);
315     else if (is&lt;ImmutableStyleProperties&gt;(*this))
316         delete downcast&lt;ImmutableStyleProperties&gt;(this);
317     else
318         delete downcast&lt;DeferredStyleProperties&gt;(this);
319 }
320 
321 inline int StyleProperties::findPropertyIndex(CSSPropertyID propertyID) const
322 {
323     if (is&lt;MutableStyleProperties&gt;(*this))
324         return downcast&lt;MutableStyleProperties&gt;(*this).findPropertyIndex(propertyID);
325     return downcast&lt;ImmutableStyleProperties&gt;(*this).findPropertyIndex(propertyID);
326 }
327 
328 inline int StyleProperties::findCustomPropertyIndex(const String&amp; propertyName) const
</pre>
</td>
<td>
<hr />
<pre>
 33 
 34 namespace WebCore {
 35 
 36 class CSSDeferredParser;
 37 class CSSStyleDeclaration;
 38 class CachedResource;
 39 class Color;
 40 class ImmutableStyleProperties;
 41 class MutableStyleProperties;
 42 class PropertySetCSSStyleDeclaration;
 43 class StyledElement;
 44 class StylePropertyShorthand;
 45 class StyleSheetContents;
 46 
 47 enum StylePropertiesType { ImmutablePropertiesType, MutablePropertiesType, DeferredPropertiesType };
 48 
 49 class StylePropertiesBase : public RefCounted&lt;StylePropertiesBase&gt; {
 50 public:
 51     // Override RefCounted&#39;s deref() to ensure operator delete is called on
 52     // the appropriate subclass type.
<span class="line-modified"> 53     void deref() const;</span>
 54 
 55     StylePropertiesType type() const { return static_cast&lt;StylePropertiesType&gt;(m_type); }
 56 
 57     CSSParserMode cssParserMode() const { return static_cast&lt;CSSParserMode&gt;(m_cssParserMode); }
 58 
 59 protected:
 60     StylePropertiesBase(CSSParserMode cssParserMode, StylePropertiesType type)
 61         : m_cssParserMode(cssParserMode)
 62         , m_type(type)
 63         , m_arraySize(0)
 64     { }
 65 
 66     StylePropertiesBase(CSSParserMode cssParserMode, unsigned immutableArraySize)
 67         : m_cssParserMode(cssParserMode)
 68         , m_type(ImmutablePropertiesType)
 69         , m_arraySize(immutableArraySize)
 70     { }
 71 
 72     unsigned m_cssParserMode : 3;
 73     mutable unsigned m_type : 2;
 74     unsigned m_arraySize : 27;
 75 };
 76 
<span class="line-added"> 77 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(StyleProperties);</span>
 78 class StyleProperties : public StylePropertiesBase {
<span class="line-added"> 79     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(StyleProperties);</span>
 80     friend class PropertyReference;
 81 public:
 82     class PropertyReference {
 83     public:
 84         PropertyReference(const StylePropertyMetadata&amp; metadata, const CSSValue* value)
 85             : m_metadata(metadata)
 86             , m_value(value)
 87         { }
 88 
 89         CSSPropertyID id() const { return static_cast&lt;CSSPropertyID&gt;(m_metadata.m_propertyID); }
 90         CSSPropertyID shorthandID() const { return m_metadata.shorthandID(); }
 91 
 92         bool isImportant() const { return m_metadata.m_important; }
 93         bool isInherited() const { return m_metadata.m_inherited; }
 94         bool isImplicit() const { return m_metadata.m_implicit; }
 95 
 96         String cssName() const;
 97         String cssText() const;
 98 
 99         const CSSValue* value() const { return m_value; }
</pre>
<hr />
<pre>
144 
145 #ifndef NDEBUG
146     void showStyle();
147 #endif
148 
149     bool propertyMatches(CSSPropertyID, const CSSValue*) const;
150 
151 protected:
152     StyleProperties(CSSParserMode cssParserMode, StylePropertiesType type)
153         : StylePropertiesBase(cssParserMode, type)
154     { }
155 
156     StyleProperties(CSSParserMode cssParserMode, unsigned immutableArraySize)
157         : StylePropertiesBase(cssParserMode, immutableArraySize)
158     { }
159 
160     int findPropertyIndex(CSSPropertyID) const;
161     int findCustomPropertyIndex(const String&amp; propertyName) const;
162 
163 private:
<span class="line-modified">164     String getGridShorthandValue(const StylePropertyShorthand&amp;) const;</span>
<span class="line-added">165     String getShorthandValue(const StylePropertyShorthand&amp;, const char* separator = &quot; &quot;) const;</span>
166     String getCommonValue(const StylePropertyShorthand&amp;) const;
167     String getAlignmentShorthandValue(const StylePropertyShorthand&amp;) const;
168     String borderPropertyValue(const StylePropertyShorthand&amp;, const StylePropertyShorthand&amp;, const StylePropertyShorthand&amp;) const;
169     String pageBreakPropertyValue(const StylePropertyShorthand&amp;) const;
170     String getLayeredShorthandValue(const StylePropertyShorthand&amp;) const;
171     String get2Values(const StylePropertyShorthand&amp;) const;
172     String get4Values(const StylePropertyShorthand&amp;) const;
173     String borderSpacingValue(const StylePropertyShorthand&amp;) const;
174     String fontValue() const;
175     void appendFontLonghandValueIfExplicit(CSSPropertyID, StringBuilder&amp; result, String&amp; value) const;
176 
177     RefPtr&lt;CSSValue&gt; getPropertyCSSValueInternal(CSSPropertyID) const;
178 
179     friend class PropertySetCSSStyleDeclaration;
180 };
181 
<span class="line-added">182 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(ImmutableStyleProperties);</span>
183 class ImmutableStyleProperties final : public StyleProperties {
<span class="line-added">184     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(ImmutableStyleProperties);</span>
185 public:
186     WEBCORE_EXPORT ~ImmutableStyleProperties();
187     static Ref&lt;ImmutableStyleProperties&gt; create(const CSSProperty* properties, unsigned count, CSSParserMode);
188 
189     unsigned propertyCount() const { return m_arraySize; }
190     bool isEmpty() const { return !propertyCount(); }
191     PropertyReference propertyAt(unsigned index) const;
192 


193     int findPropertyIndex(CSSPropertyID) const;
194     int findCustomPropertyIndex(const String&amp; propertyName) const;
195 
196     void* m_storage;
197 
198 private:
<span class="line-added">199     PackedPtr&lt;const CSSValue&gt;* valueArray() const;</span>
<span class="line-added">200     const StylePropertyMetadata* metadataArray() const;</span>
201     ImmutableStyleProperties(const CSSProperty*, unsigned count, CSSParserMode);
202 };
203 
<span class="line-modified">204 inline PackedPtr&lt;const CSSValue&gt;* ImmutableStyleProperties::valueArray() const</span>
205 {
<span class="line-modified">206     return bitwise_cast&lt;PackedPtr&lt;const CSSValue&gt;*&gt;(bitwise_cast&lt;const uint8_t*&gt;(metadataArray()) + (m_arraySize * sizeof(StylePropertyMetadata)));</span>
207 }
208 
209 inline const StylePropertyMetadata* ImmutableStyleProperties::metadataArray() const
210 {
<span class="line-modified">211     return reinterpret_cast&lt;const StylePropertyMetadata*&gt;(const_cast&lt;const void**&gt;((&amp;(this-&gt;m_storage))));</span>
212 }
213 
<span class="line-added">214 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(MutableStyleProperties);</span>
215 class MutableStyleProperties final : public StyleProperties {
<span class="line-added">216     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(MutableStyleProperties);</span>
217 public:
218     WEBCORE_EXPORT static Ref&lt;MutableStyleProperties&gt; create(CSSParserMode = HTMLQuirksMode);
<span class="line-modified">219     static Ref&lt;MutableStyleProperties&gt; create(Vector&lt;CSSProperty&gt;&amp;&amp;);</span>
220 
221     WEBCORE_EXPORT ~MutableStyleProperties();
222 
223     unsigned propertyCount() const { return m_propertyVector.size(); }
224     bool isEmpty() const { return !propertyCount(); }
225     PropertyReference propertyAt(unsigned index) const;
226 
227     PropertySetCSSStyleDeclaration* cssStyleDeclaration();
228 
229     bool addParsedProperties(const ParsedPropertyVector&amp;);
230     bool addParsedProperty(const CSSProperty&amp;);
231 
232     // These expand shorthand properties into multiple properties.
233     bool setProperty(CSSPropertyID, const String&amp; value, bool important, CSSParserContext);
234     bool setProperty(CSSPropertyID, const String&amp; value, bool important = false);
235     void setProperty(CSSPropertyID, RefPtr&lt;CSSValue&gt;&amp;&amp;, bool important = false);
236 
237     // These do not. FIXME: This is too messy, we can do better.
238     bool setProperty(CSSPropertyID, CSSValueID identifier, bool important = false);
239     bool setProperty(CSSPropertyID, CSSPropertyID identifier, bool important = false);
</pre>
<hr />
<pre>
246     void mergeAndOverrideOnConflict(const StyleProperties&amp;);
247 
248     void clear();
249     bool parseDeclaration(const String&amp; styleDeclaration, CSSParserContext);
250 
251     WEBCORE_EXPORT CSSStyleDeclaration&amp; ensureCSSStyleDeclaration();
252     CSSStyleDeclaration&amp; ensureInlineCSSStyleDeclaration(StyledElement&amp; parentElement);
253 
254     int findPropertyIndex(CSSPropertyID) const;
255     int findCustomPropertyIndex(const String&amp; propertyName) const;
256 
257     Vector&lt;CSSProperty, 4&gt; m_propertyVector;
258 
259     // Methods for querying and altering CSS custom properties.
260     bool setCustomProperty(const Document*, const String&amp; propertyName, const String&amp; value, bool important, CSSParserContext);
261     bool removeCustomProperty(const String&amp; propertyName, String* returnText = nullptr);
262 
263 private:
264     explicit MutableStyleProperties(CSSParserMode);
265     explicit MutableStyleProperties(const StyleProperties&amp;);
<span class="line-modified">266     MutableStyleProperties(Vector&lt;CSSProperty&gt;&amp;&amp;);</span>
267 
268     bool removeShorthandProperty(CSSPropertyID);
269     CSSProperty* findCSSPropertyWithID(CSSPropertyID);
270     CSSProperty* findCustomCSSPropertyWithName(const String&amp;);
271     std::unique_ptr&lt;PropertySetCSSStyleDeclaration&gt; m_cssomWrapper;
272 
273     friend class StyleProperties;
274 };
275 
276 class DeferredStyleProperties final : public StylePropertiesBase {
277 public:
278     WEBCORE_EXPORT ~DeferredStyleProperties();
279     static Ref&lt;DeferredStyleProperties&gt; create(const CSSParserTokenRange&amp;, CSSDeferredParser&amp;);
280 
281     Ref&lt;ImmutableStyleProperties&gt; parseDeferredProperties();
282 
283 private:
284     DeferredStyleProperties(const CSSParserTokenRange&amp;, CSSDeferredParser&amp;);
285 
286     Vector&lt;CSSParserToken&gt; m_tokens;
287     Ref&lt;CSSDeferredParser&gt; m_parser;
288 };
289 
290 inline ImmutableStyleProperties::PropertyReference ImmutableStyleProperties::propertyAt(unsigned index) const
291 {
<span class="line-modified">292     return PropertyReference(metadataArray()[index], valueArray()[index].get());</span>
293 }
294 
295 inline MutableStyleProperties::PropertyReference MutableStyleProperties::propertyAt(unsigned index) const
296 {
297     const CSSProperty&amp; property = m_propertyVector[index];
298     return PropertyReference(property.metadata(), property.value());
299 }
300 
301 inline StyleProperties::PropertyReference StyleProperties::propertyAt(unsigned index) const
302 {
303     if (is&lt;MutableStyleProperties&gt;(*this))
304         return downcast&lt;MutableStyleProperties&gt;(*this).propertyAt(index);
305     return downcast&lt;ImmutableStyleProperties&gt;(*this).propertyAt(index);
306 }
307 
308 inline unsigned StyleProperties::propertyCount() const
309 {
310     if (is&lt;MutableStyleProperties&gt;(*this))
311         return downcast&lt;MutableStyleProperties&gt;(*this).propertyCount();
312     return downcast&lt;ImmutableStyleProperties&gt;(*this).propertyCount();
313 }
314 
<span class="line-modified">315 inline void StylePropertiesBase::deref() const</span>
316 {
317     if (!derefBase())
318         return;
319 
320     if (is&lt;MutableStyleProperties&gt;(*this))
321         delete downcast&lt;MutableStyleProperties&gt;(this);
322     else if (is&lt;ImmutableStyleProperties&gt;(*this))
323         delete downcast&lt;ImmutableStyleProperties&gt;(this);
324     else
325         delete downcast&lt;DeferredStyleProperties&gt;(this);
326 }
327 
328 inline int StyleProperties::findPropertyIndex(CSSPropertyID propertyID) const
329 {
330     if (is&lt;MutableStyleProperties&gt;(*this))
331         return downcast&lt;MutableStyleProperties&gt;(*this).findPropertyIndex(propertyID);
332     return downcast&lt;ImmutableStyleProperties&gt;(*this).findPropertyIndex(propertyID);
333 }
334 
335 inline int StyleProperties::findCustomPropertyIndex(const String&amp; propertyName) const
</pre>
</td>
</tr>
</table>
<center><a href="StyleProperties.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleRule.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractValue.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGAbstractValue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGArgumentPosition.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractValue.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2011-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
266     void fixTypeForRepresentation(Graph&amp;, NodeFlags representation, Node* = nullptr);
267     void fixTypeForRepresentation(Graph&amp;, Node*);
268 
269     bool operator==(const AbstractValue&amp; other) const
270     {
271         return m_type == other.m_type
272             &amp;&amp; m_arrayModes == other.m_arrayModes
273             &amp;&amp; m_structure == other.m_structure
274             &amp;&amp; m_value == other.m_value;
275     }
276     bool operator!=(const AbstractValue&amp; other) const
277     {
278         return !(*this == other);
279     }
280 
281     ALWAYS_INLINE bool merge(const AbstractValue&amp; other)
282     {
283         if (other.isClear())
284             return false;
285 
<span class="line-modified">286 #if !ASSERT_DISABLED</span>
287         AbstractValue oldMe = *this;
288 #endif
289         bool result = false;
290         if (isClear()) {
291             *this = other;
292             result = !other.isClear();
293         } else {
294             result |= mergeSpeculation(m_type, other.m_type);
295             result |= mergeArrayModes(m_arrayModes, other.m_arrayModes);
296             result |= m_structure.merge(other.m_structure);
297             if (m_value != other.m_value) {
298                 result |= !!m_value;
299                 m_value = JSValue();
300             }
301         }
302         checkConsistency();
303         ASSERT(result == (*this != oldMe));
304         return result;
305     }
306 
</pre>
<hr />
<pre>
319         checkConsistency();
320     }
321 
322     bool couldBeType(SpeculatedType desiredType) const
323     {
324         return !!(m_type &amp; desiredType);
325     }
326 
327     bool isType(SpeculatedType desiredType) const
328     {
329         return !(m_type &amp; ~desiredType);
330     }
331 
332     // Filters the value using the given structure set. If the admittedTypes argument is not passed, this
333     // implicitly filters by the types implied by the structure set, which are usually a subset of
334     // SpecCell. Hence, after this call, the value will no longer have any non-cell members. But, you can
335     // use admittedTypes to preserve some non-cell types. Note that it&#39;s wrong for admittedTypes to overlap
336     // with SpecCell.
337     FiltrationResult filter(Graph&amp;, const RegisteredStructureSet&amp;, SpeculatedType admittedTypes = SpecNone);
338 
<span class="line-modified">339     FiltrationResult filterArrayModes(ArrayModes);</span>
340 
341     ALWAYS_INLINE FiltrationResult filter(SpeculatedType type)
342     {
343         if ((m_type &amp; type) == m_type)
344             return FiltrationOK;
345 
346         // Fast path for the case that we don&#39;t even have a cell.
347         if (!(m_type &amp; SpecCell)) {
348             m_type &amp;= type;
349             FiltrationResult result;
350             if (m_type == SpecNone) {
351                 clear();
352                 result = Contradiction;
353             } else
354                 result = FiltrationOK;
355             checkConsistency();
356             return result;
357         }
358 
359         return filterSlow(type);
</pre>
<hr />
<pre>
414                 return true;
415             }
416         }
417 
418         if (!!value &amp;&amp; value.isCell()) {
419             ASSERT(m_type &amp; SpecCell);
420             Structure* structure = value.asCell()-&gt;structure();
421             return m_structure.contains(structure)
422                 &amp;&amp; (m_arrayModes &amp; arrayModesFromStructure(structure));
423         }
424 
425         return true;
426     }
427 
428     bool hasClobberableState() const
429     {
430         return m_structure.isNeitherClearNorTop()
431             || !arrayModesAreClearOrTop(m_arrayModes);
432     }
433 
<span class="line-modified">434 #if ASSERT_DISABLED</span>
<span class="line-removed">435     void checkConsistency() const { }</span>
<span class="line-removed">436     void assertIsRegistered(Graph&amp;) const { }</span>
<span class="line-removed">437 #else</span>
438     JS_EXPORT_PRIVATE void checkConsistency() const;
439     void assertIsRegistered(Graph&amp;) const;



440 #endif
441 
442     ResultType resultType() const;
443 
444     void dumpInContext(PrintStream&amp;, DumpContext*) const;
445     void dump(PrintStream&amp;) const;
446 
447     void validateReferences(const TrackedReferences&amp;);
448 
449     // This is a proven constraint on the structures that this value can have right
450     // now. The structure of the current value must belong to this set. The set may
451     // be TOP, indicating that it is the set of all possible structures, in which
452     // case the current value can have any structure. The set may be BOTTOM (empty)
453     // in which case this value cannot be a cell. This is all subject to change
454     // anytime a new value is assigned to this one, anytime there is a control flow
455     // merge, or most crucially, anytime a side-effect or structure check happens.
456     // In case of a side-effect, we must assume that any value with a structure that
457     // isn&#39;t being watched may have had its structure changed, hence contravening
458     // our proof. In such a case we make the proof valid again by switching this to
459     // TOP (i.e. claiming that we have proved that this value may have any
</pre>
<hr />
<pre>
550     FiltrationResult fastForwardToAndFilterSlow(AbstractValueClobberEpoch, SpeculatedType);
551 
552     void filterValueByType();
553     void filterArrayModesByType();
554 
555 #if USE(JSVALUE64) &amp;&amp; !defined(NDEBUG)
556     JS_EXPORT_PRIVATE void ensureCanInitializeWithZeros();
557 #endif
558 
559     bool shouldBeClear() const;
560     FiltrationResult normalizeClarity();
561     FiltrationResult normalizeClarity(Graph&amp;);
562 };
563 
564 } } // namespace JSC::DFG
565 
566 #if USE(JSVALUE64)
567 namespace WTF {
568 template &lt;&gt;
569 struct VectorTraits&lt;JSC::DFG::AbstractValue&gt; : VectorTraitsBase&lt;false, JSC::DFG::AbstractValue&gt; {
<span class="line-modified">570     static const bool canInitializeWithMemset = true;</span>
571 };
572 
573 template &lt;&gt;
574 struct HashTraits&lt;JSC::DFG::AbstractValue&gt; : GenericHashTraits&lt;JSC::DFG::AbstractValue&gt; {
<span class="line-modified">575     static const bool emptyValueIsZero = true;</span>
576 };
577 };
578 #endif // USE(JSVALUE64)
579 
580 #endif // ENABLE(DFG_JIT)
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
266     void fixTypeForRepresentation(Graph&amp;, NodeFlags representation, Node* = nullptr);
267     void fixTypeForRepresentation(Graph&amp;, Node*);
268 
269     bool operator==(const AbstractValue&amp; other) const
270     {
271         return m_type == other.m_type
272             &amp;&amp; m_arrayModes == other.m_arrayModes
273             &amp;&amp; m_structure == other.m_structure
274             &amp;&amp; m_value == other.m_value;
275     }
276     bool operator!=(const AbstractValue&amp; other) const
277     {
278         return !(*this == other);
279     }
280 
281     ALWAYS_INLINE bool merge(const AbstractValue&amp; other)
282     {
283         if (other.isClear())
284             return false;
285 
<span class="line-modified">286 #if ASSERT_ENABLED</span>
287         AbstractValue oldMe = *this;
288 #endif
289         bool result = false;
290         if (isClear()) {
291             *this = other;
292             result = !other.isClear();
293         } else {
294             result |= mergeSpeculation(m_type, other.m_type);
295             result |= mergeArrayModes(m_arrayModes, other.m_arrayModes);
296             result |= m_structure.merge(other.m_structure);
297             if (m_value != other.m_value) {
298                 result |= !!m_value;
299                 m_value = JSValue();
300             }
301         }
302         checkConsistency();
303         ASSERT(result == (*this != oldMe));
304         return result;
305     }
306 
</pre>
<hr />
<pre>
319         checkConsistency();
320     }
321 
322     bool couldBeType(SpeculatedType desiredType) const
323     {
324         return !!(m_type &amp; desiredType);
325     }
326 
327     bool isType(SpeculatedType desiredType) const
328     {
329         return !(m_type &amp; ~desiredType);
330     }
331 
332     // Filters the value using the given structure set. If the admittedTypes argument is not passed, this
333     // implicitly filters by the types implied by the structure set, which are usually a subset of
334     // SpecCell. Hence, after this call, the value will no longer have any non-cell members. But, you can
335     // use admittedTypes to preserve some non-cell types. Note that it&#39;s wrong for admittedTypes to overlap
336     // with SpecCell.
337     FiltrationResult filter(Graph&amp;, const RegisteredStructureSet&amp;, SpeculatedType admittedTypes = SpecNone);
338 
<span class="line-modified">339     FiltrationResult filterArrayModes(ArrayModes, SpeculatedType admittedTypes = SpecNone);</span>
340 
341     ALWAYS_INLINE FiltrationResult filter(SpeculatedType type)
342     {
343         if ((m_type &amp; type) == m_type)
344             return FiltrationOK;
345 
346         // Fast path for the case that we don&#39;t even have a cell.
347         if (!(m_type &amp; SpecCell)) {
348             m_type &amp;= type;
349             FiltrationResult result;
350             if (m_type == SpecNone) {
351                 clear();
352                 result = Contradiction;
353             } else
354                 result = FiltrationOK;
355             checkConsistency();
356             return result;
357         }
358 
359         return filterSlow(type);
</pre>
<hr />
<pre>
414                 return true;
415             }
416         }
417 
418         if (!!value &amp;&amp; value.isCell()) {
419             ASSERT(m_type &amp; SpecCell);
420             Structure* structure = value.asCell()-&gt;structure();
421             return m_structure.contains(structure)
422                 &amp;&amp; (m_arrayModes &amp; arrayModesFromStructure(structure));
423         }
424 
425         return true;
426     }
427 
428     bool hasClobberableState() const
429     {
430         return m_structure.isNeitherClearNorTop()
431             || !arrayModesAreClearOrTop(m_arrayModes);
432     }
433 
<span class="line-modified">434 #if ASSERT_ENABLED</span>



435     JS_EXPORT_PRIVATE void checkConsistency() const;
436     void assertIsRegistered(Graph&amp;) const;
<span class="line-added">437 #else</span>
<span class="line-added">438     void checkConsistency() const { }</span>
<span class="line-added">439     void assertIsRegistered(Graph&amp;) const { }</span>
440 #endif
441 
442     ResultType resultType() const;
443 
444     void dumpInContext(PrintStream&amp;, DumpContext*) const;
445     void dump(PrintStream&amp;) const;
446 
447     void validateReferences(const TrackedReferences&amp;);
448 
449     // This is a proven constraint on the structures that this value can have right
450     // now. The structure of the current value must belong to this set. The set may
451     // be TOP, indicating that it is the set of all possible structures, in which
452     // case the current value can have any structure. The set may be BOTTOM (empty)
453     // in which case this value cannot be a cell. This is all subject to change
454     // anytime a new value is assigned to this one, anytime there is a control flow
455     // merge, or most crucially, anytime a side-effect or structure check happens.
456     // In case of a side-effect, we must assume that any value with a structure that
457     // isn&#39;t being watched may have had its structure changed, hence contravening
458     // our proof. In such a case we make the proof valid again by switching this to
459     // TOP (i.e. claiming that we have proved that this value may have any
</pre>
<hr />
<pre>
550     FiltrationResult fastForwardToAndFilterSlow(AbstractValueClobberEpoch, SpeculatedType);
551 
552     void filterValueByType();
553     void filterArrayModesByType();
554 
555 #if USE(JSVALUE64) &amp;&amp; !defined(NDEBUG)
556     JS_EXPORT_PRIVATE void ensureCanInitializeWithZeros();
557 #endif
558 
559     bool shouldBeClear() const;
560     FiltrationResult normalizeClarity();
561     FiltrationResult normalizeClarity(Graph&amp;);
562 };
563 
564 } } // namespace JSC::DFG
565 
566 #if USE(JSVALUE64)
567 namespace WTF {
568 template &lt;&gt;
569 struct VectorTraits&lt;JSC::DFG::AbstractValue&gt; : VectorTraitsBase&lt;false, JSC::DFG::AbstractValue&gt; {
<span class="line-modified">570     static constexpr bool canInitializeWithMemset = true;</span>
571 };
572 
573 template &lt;&gt;
574 struct HashTraits&lt;JSC::DFG::AbstractValue&gt; : GenericHashTraits&lt;JSC::DFG::AbstractValue&gt; {
<span class="line-modified">575     static constexpr bool emptyValueIsZero = true;</span>
576 };
577 };
578 #endif // USE(JSVALUE64)
579 
580 #endif // ENABLE(DFG_JIT)
</pre>
</td>
</tr>
</table>
<center><a href="DFGAbstractValue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGArgumentPosition.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
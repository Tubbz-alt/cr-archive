<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/displaylists/DisplayListItems.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DisplayListItems.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="DisplayListRecorder.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/displaylists/DisplayListItems.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 23,151 ***</span>
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  #pragma once
  
  #include &quot;FloatPoint.h&quot;
<span class="line-removed">- #include &quot;FloatRect.h&quot;</span>
  #include &quot;FloatRoundedRect.h&quot;
  #include &quot;Font.h&quot;
  #include &quot;GlyphBuffer.h&quot;
<span class="line-removed">- #include &quot;GraphicsContext.h&quot;</span>
  #include &quot;Image.h&quot;
  #include &lt;wtf/RefCounted.h&gt;
  #include &lt;wtf/TypeCasts.h&gt;
  
<span class="line-removed">- #if USE(CG)</span>
<span class="line-removed">- #include &quot;GraphicsContextPlatformPrivateCG.h&quot;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  namespace WTF {
  class TextStream;
  }
  
  namespace WebCore {
  
  struct ImagePaintingOptions;
  
  namespace DisplayList {
  
<span class="line-removed">- enum class ItemType {</span>
<span class="line-removed">-     Save,</span>
<span class="line-removed">-     Restore,</span>
<span class="line-removed">-     Translate,</span>
<span class="line-removed">-     Rotate,</span>
<span class="line-removed">-     Scale,</span>
<span class="line-removed">-     ConcatenateCTM,</span>
<span class="line-removed">-     SetState,</span>
<span class="line-removed">-     SetLineCap,</span>
<span class="line-removed">-     SetLineDash,</span>
<span class="line-removed">-     SetLineJoin,</span>
<span class="line-removed">-     SetMiterLimit,</span>
<span class="line-removed">-     ClearShadow,</span>
<span class="line-removed">-     Clip,</span>
<span class="line-removed">-     ClipOut,</span>
<span class="line-removed">-     ClipOutToPath,</span>
<span class="line-removed">-     ClipPath,</span>
<span class="line-removed">-     DrawGlyphs,</span>
<span class="line-removed">-     DrawImage,</span>
<span class="line-removed">-     DrawTiledImage,</span>
<span class="line-removed">-     DrawTiledScaledImage,</span>
<span class="line-removed">- #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)</span>
<span class="line-removed">-     DrawNativeImage,</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     DrawPattern,</span>
<span class="line-removed">-     DrawRect,</span>
<span class="line-removed">-     DrawLine,</span>
<span class="line-removed">-     DrawLinesForText,</span>
<span class="line-removed">-     DrawDotsForDocumentMarker,</span>
<span class="line-removed">-     DrawEllipse,</span>
<span class="line-removed">-     DrawPath,</span>
<span class="line-removed">-     DrawFocusRingPath,</span>
<span class="line-removed">-     DrawFocusRingRects,</span>
<span class="line-removed">-     FillRect,</span>
<span class="line-removed">-     FillRectWithColor,</span>
<span class="line-removed">-     FillRectWithGradient,</span>
<span class="line-removed">-     FillCompositedRect,</span>
<span class="line-removed">-     FillRoundedRect,</span>
<span class="line-removed">-     FillRectWithRoundedHole,</span>
<span class="line-removed">-     FillPath,</span>
<span class="line-removed">-     FillEllipse,</span>
<span class="line-removed">-     StrokeRect,</span>
<span class="line-removed">-     StrokePath,</span>
<span class="line-removed">-     StrokeEllipse,</span>
<span class="line-removed">-     ClearRect,</span>
<span class="line-removed">-     BeginTransparencyLayer,</span>
<span class="line-removed">-     EndTransparencyLayer,</span>
<span class="line-removed">- #if USE(CG)</span>
<span class="line-removed">-     ApplyStrokePattern, // FIXME: should not be a recorded item.</span>
<span class="line-removed">-     ApplyFillPattern, // FIXME: should not be a recorded item.</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     ApplyDeviceScaleFactor,</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- class Item : public RefCounted&lt;Item&gt; {</span>
<span class="line-removed">- public:</span>
<span class="line-removed">-     Item() = delete;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Item(ItemType type)</span>
<span class="line-removed">-         : m_type(type)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     virtual ~Item() = default;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ItemType type() const</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         return m_type;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     virtual void apply(GraphicsContext&amp;) const = 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     static constexpr bool isDisplayListItem = true;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     virtual bool isDrawingItem() const { return false; }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // A state item is one preserved by Save/Restore.</span>
<span class="line-removed">-     bool isStateItem() const</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         return isStateItemType(m_type);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     static bool isStateItemType(ItemType itemType)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         switch (itemType) {</span>
<span class="line-removed">-         case ItemType:: Translate:</span>
<span class="line-removed">-         case ItemType:: Rotate:</span>
<span class="line-removed">-         case ItemType:: Scale:</span>
<span class="line-removed">-         case ItemType:: ConcatenateCTM:</span>
<span class="line-removed">-         case ItemType:: SetState:</span>
<span class="line-removed">-         case ItemType:: SetLineCap:</span>
<span class="line-removed">-         case ItemType:: SetLineDash:</span>
<span class="line-removed">-         case ItemType:: SetLineJoin:</span>
<span class="line-removed">-         case ItemType:: SetMiterLimit:</span>
<span class="line-removed">-         case ItemType:: ClearShadow:</span>
<span class="line-removed">-             return true;</span>
<span class="line-removed">-         default:</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if !defined(NDEBUG) || !LOG_DISABLED</span>
<span class="line-removed">-     WTF::CString description() const;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     static size_t sizeInBytes(const Item&amp;);</span>
<span class="line-removed">- </span>
<span class="line-removed">- private:</span>
<span class="line-removed">-     ItemType m_type;</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
  class DrawingItem : public Item {
  public:
<span class="line-modified">!     explicit DrawingItem(ItemType type)</span>
<span class="line-modified">!         : Item(type)</span>
<span class="line-modified">!     {</span>
<span class="line-removed">-     }</span>
  
      void setExtent(const FloatRect&amp; r) { m_extent = r; }
      const FloatRect&amp; extent() const { return m_extent.value(); }
  
      bool extentKnown() const { return static_cast&lt;bool&gt;(m_extent); }
<span class="line-new-header">--- 23,35 ---</span>
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  #pragma once
  
<span class="line-added">+ #include &quot;DisplayList.h&quot;</span>
  #include &quot;FloatPoint.h&quot;
  #include &quot;FloatRoundedRect.h&quot;
  #include &quot;Font.h&quot;
  #include &quot;GlyphBuffer.h&quot;
  #include &quot;Image.h&quot;
<span class="line-added">+ #include &quot;Pattern.h&quot;</span>
  #include &lt;wtf/RefCounted.h&gt;
  #include &lt;wtf/TypeCasts.h&gt;
  
  namespace WTF {
  class TextStream;
  }
  
  namespace WebCore {
  
  struct ImagePaintingOptions;
  
  namespace DisplayList {
  
  class DrawingItem : public Item {
  public:
<span class="line-modified">!     WEBCORE_EXPORT explicit DrawingItem(ItemType);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     WEBCORE_EXPORT virtual ~DrawingItem();</span>
  
      void setExtent(const FloatRect&amp; r) { m_extent = r; }
      const FloatRect&amp; extent() const { return m_extent.value(); }
  
      bool extentKnown() const { return static_cast&lt;bool&gt;(m_extent); }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 187,361 ***</span>
      static Ref&lt;Save&gt; create()
      {
          return adoptRef(*new Save);
      }
  
      // Index in the display list of the corresponding Restore item. 0 if unmatched.
      size_t restoreIndex() const { return m_restoreIndex; }
      void setRestoreIndex(size_t index) { m_restoreIndex = index; }
  
  private:
<span class="line-modified">!     Save()</span>
<span class="line-removed">-         : Item(ItemType::Save)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      size_t m_restoreIndex { 0 };
  };
  
  class Restore : public Item {
  public:
      static Ref&lt;Restore&gt; create()
      {
          return adoptRef(*new Restore);
      }
  
  private:
<span class="line-modified">!     Restore()</span>
<span class="line-removed">-         : Item(ItemType::Restore)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
  };
  
  class Translate : public Item {
  public:
      static Ref&lt;Translate&gt; create(float x, float y)
      {
          return adoptRef(*new Translate(x, y));
      }
  
      float x() const { return m_x; }
      float y() const { return m_y; }
  
  private:
<span class="line-modified">!     Translate(float x, float y)</span>
<span class="line-removed">-         : Item(ItemType::Translate)</span>
<span class="line-removed">-         , m_x(x)</span>
<span class="line-removed">-         , m_y(y)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      float m_x;
      float m_y;
  };
  
  class Rotate : public Item {
  public:
      static Ref&lt;Rotate&gt; create(float angleInRadians)
      {
          return adoptRef(*new Rotate(angleInRadians));
      }
  
      float angle() const { return m_angle; }
  
  private:
<span class="line-modified">!     Rotate(float angle)</span>
<span class="line-removed">-         : Item(ItemType::Rotate)</span>
<span class="line-removed">-         , m_angle(angle)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      float m_angle; // In radians.
  };
  
  class Scale : public Item {
  public:
      static Ref&lt;Scale&gt; create(const FloatSize&amp; size)
      {
          return adoptRef(*new Scale(size));
      }
  
      const FloatSize&amp; amount() const { return m_size; }
  
  private:
<span class="line-modified">!     Scale(const FloatSize&amp; size)</span>
<span class="line-modified">!         : Item(ItemType::Scale)</span>
<span class="line-modified">!         , m_size(size)</span>
      {
      }
  
      void apply(GraphicsContext&amp;) const override;
  
<span class="line-modified">!     FloatSize m_size;</span>
  };
  
  class ConcatenateCTM : public Item {
  public:
      static Ref&lt;ConcatenateCTM&gt; create(const AffineTransform&amp; matrix)
      {
          return adoptRef(*new ConcatenateCTM(matrix));
      }
  
      const AffineTransform&amp; transform() const { return m_transform; }
  
  private:
<span class="line-modified">!     ConcatenateCTM(const AffineTransform&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      AffineTransform m_transform;
  };
  
  class SetState : public Item {
  public:
      static Ref&lt;SetState&gt; create(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
      {
          return adoptRef(*new SetState(state, flags));
      }
  
      const GraphicsContextStateChange&amp; state() const { return m_state; }
  
      void accumulate(const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);
  
      void accumulate(GraphicsContextState&amp;) const;
  
<span class="line-modified">!     static void applyState(GraphicsContext&amp;, const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);</span>
  
      static void dumpStateChanges(WTF::TextStream&amp;, const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);
  private:
<span class="line-modified">!     SetState(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)</span>
<span class="line-modified">!         : Item(ItemType::SetState)</span>
<span class="line-removed">-         , m_state(state, flags)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      GraphicsContextStateChange m_state;
  };
  
  class SetLineCap : public Item {
  public:
      static Ref&lt;SetLineCap&gt; create(LineCap lineCap)
      {
          return adoptRef(*new SetLineCap(lineCap));
      }
  
      LineCap lineCap() const { return m_lineCap; }
  
  private:
<span class="line-modified">!     SetLineCap(LineCap lineCap)</span>
<span class="line-removed">-         : Item(ItemType::SetLineCap)</span>
<span class="line-removed">-         , m_lineCap(lineCap)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      LineCap m_lineCap;
  };
  
  class SetLineDash : public Item {
  public:
      static Ref&lt;SetLineDash&gt; create(const DashArray&amp; dashArray, float dashOffset)
      {
          return adoptRef(*new SetLineDash(dashArray, dashOffset));
      }
  
      const DashArray&amp; dashArray() const { return m_dashArray; }
      float dashOffset() const { return m_dashOffset; }
  
  private:
<span class="line-modified">!     SetLineDash(const DashArray&amp; dashArray, float dashOffset)</span>
<span class="line-removed">-         : Item(ItemType::SetLineDash)</span>
<span class="line-removed">-         , m_dashArray(dashArray)</span>
<span class="line-removed">-         , m_dashOffset(dashOffset)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      DashArray m_dashArray;
      float m_dashOffset;
  };
  
  class SetLineJoin : public Item {
  public:
      static Ref&lt;SetLineJoin&gt; create(LineJoin lineJoin)
      {
          return adoptRef(*new SetLineJoin(lineJoin));
      }
  
      LineJoin lineJoin() const { return m_lineJoin; }
  
  private:
<span class="line-modified">!     SetLineJoin(LineJoin lineJoin)</span>
<span class="line-removed">-         : Item(ItemType::SetLineJoin)</span>
<span class="line-removed">-         , m_lineJoin(lineJoin)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      LineJoin m_lineJoin;
  };
  
  class SetMiterLimit : public Item {
  public:
      static Ref&lt;SetMiterLimit&gt; create(float limit)
      {
          return adoptRef(*new SetMiterLimit(limit));
      }
  
      float miterLimit() const { return m_miterLimit; }
  
  private:
<span class="line-modified">!     SetMiterLimit(float miterLimit)</span>
<span class="line-removed">-         : Item(ItemType::SetMiterLimit)</span>
<span class="line-removed">-         , m_miterLimit(miterLimit)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      float m_miterLimit;
  };
  
  class ClearShadow : public Item {
  public:
      static Ref&lt;ClearShadow&gt; create()
      {
          return adoptRef(*new ClearShadow);
      }
  
  private:
<span class="line-modified">!     ClearShadow()</span>
<span class="line-removed">-         : Item(ItemType::ClearShadow)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
  };
  
  // FIXME: treat as DrawingItem?
  class Clip : public Item {
  public:
      static Ref&lt;Clip&gt; create(const FloatRect&amp; rect)
      {
          return adoptRef(*new Clip(rect));
      }
  
      FloatRect rect() const { return m_rect; }
  
  private:
<span class="line-modified">!     Clip(const FloatRect&amp; rect)</span>
<span class="line-removed">-         : Item(ItemType::Clip)</span>
<span class="line-removed">-         , m_rect(rect)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      FloatRect m_rect;
  };
  
  class ClipOut : public Item {
  public:
      static Ref&lt;ClipOut&gt; create(const FloatRect&amp; rect)
      {
          return adoptRef(*new ClipOut(rect));
      }
  
      FloatRect rect() const { return m_rect; }
  
  private:
<span class="line-modified">!     ClipOut(const FloatRect&amp; rect)</span>
<span class="line-removed">-         : Item(ItemType::ClipOut)</span>
<span class="line-removed">-         , m_rect(rect)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      FloatRect m_rect;
  };
  
  class ClipOutToPath : public Item {
  public:
      static Ref&lt;ClipOutToPath&gt; create(const Path&amp; path)
      {
          return adoptRef(*new ClipOutToPath(path));
      }
  
      const Path&amp; path() const { return m_path; }
  
  private:
<span class="line-modified">!     ClipOutToPath(const Path&amp; path)</span>
<span class="line-removed">-         : Item(ItemType::ClipOutToPath)</span>
<span class="line-removed">-         , m_path(path)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      const Path m_path;
  };
  
  class ClipPath : public Item {
  public:
      static Ref&lt;ClipPath&gt; create(const Path&amp; path, WindRule windRule)
      {
          return adoptRef(*new ClipPath(path, windRule));
      }
  
      const Path&amp; path() const { return m_path; }
      WindRule windRule() const { return m_windRule; }
  
  private:
<span class="line-modified">!     ClipPath(const Path&amp; path, WindRule windRule)</span>
<span class="line-removed">-         : Item(ItemType::ClipPath)</span>
<span class="line-removed">-         , m_path(path)</span>
<span class="line-removed">-         , m_windRule(windRule)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      const Path m_path;
      WindRule m_windRule;
  };
  
  class DrawGlyphs : public DrawingItem {
  public:
      static Ref&lt;DrawGlyphs&gt; create(const Font&amp; font, const GlyphBufferGlyph* glyphs, const GlyphBufferAdvance* advances, unsigned count, const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, FontSmoothingMode smoothingMode)
      {
          return adoptRef(*new DrawGlyphs(font, glyphs, advances, count, blockLocation, localAnchor, smoothingMode));
      }
  
      const FloatPoint&amp; blockLocation() const { return m_blockLocation; }
      void setBlockLocation(const FloatPoint&amp; blockLocation) { m_blockLocation = blockLocation; }
  
      const FloatSize&amp; localAnchor() const { return m_localAnchor; }
  
      FloatPoint anchorPoint() const { return m_blockLocation + m_localAnchor; }
  
      const Vector&lt;GlyphBufferGlyph, 128&gt;&amp; glyphs() const { return m_glyphs; }
  
  private:
      DrawGlyphs(const Font&amp;, const GlyphBufferGlyph*, const GlyphBufferAdvance*, unsigned count, const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, FontSmoothingMode);
  
      void computeBounds();
  
      void apply(GraphicsContext&amp;) const override;
  
<span class="line-new-header">--- 71,1016 ---</span>
      static Ref&lt;Save&gt; create()
      {
          return adoptRef(*new Save);
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~Save();</span>
<span class="line-added">+ </span>
      // Index in the display list of the corresponding Restore item. 0 if unmatched.
      size_t restoreIndex() const { return m_restoreIndex; }
      void setRestoreIndex(size_t index) { m_restoreIndex = index; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;Save&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT Save();</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      size_t m_restoreIndex { 0 };
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void Save::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; static_cast&lt;uint64_t&gt;(m_restoreIndex);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;Save&gt;&gt; Save::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;uint64_t&gt; restoreIndex;</span>
<span class="line-added">+     decoder &gt;&gt; restoreIndex;</span>
<span class="line-added">+     if (!restoreIndex)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // FIXME: Validate restoreIndex? But we don&#39;t have the list context here.</span>
<span class="line-added">+     auto save = Save::create();</span>
<span class="line-added">+     save-&gt;setRestoreIndex(static_cast&lt;size_t&gt;(*restoreIndex));</span>
<span class="line-added">+     return save;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class Restore : public Item {
  public:
      static Ref&lt;Restore&gt; create()
      {
          return adoptRef(*new Restore);
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~Restore();</span>
<span class="line-added">+ </span>
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;Restore&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT Restore();</span>
  
      void apply(GraphicsContext&amp;) const override;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void Restore::encode(Encoder&amp;) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;Restore&gt;&gt; Restore::decode(Decoder&amp;)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return Restore::create();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class Translate : public Item {
  public:
      static Ref&lt;Translate&gt; create(float x, float y)
      {
          return adoptRef(*new Translate(x, y));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~Translate();</span>
<span class="line-added">+ </span>
      float x() const { return m_x; }
      float y() const { return m_y; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;Translate&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT Translate(float x, float y);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      float m_x;
      float m_y;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void Translate::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_x;</span>
<span class="line-added">+     encoder &lt;&lt; m_y;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;Translate&gt;&gt; Translate::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;float&gt; x;</span>
<span class="line-added">+     decoder &gt;&gt; x;</span>
<span class="line-added">+     if (!x)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;float&gt; y;</span>
<span class="line-added">+     decoder &gt;&gt; y;</span>
<span class="line-added">+     if (!y)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return Translate::create(*x, *y);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class Rotate : public Item {
  public:
      static Ref&lt;Rotate&gt; create(float angleInRadians)
      {
          return adoptRef(*new Rotate(angleInRadians));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~Rotate();</span>
<span class="line-added">+ </span>
      float angle() const { return m_angle; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;Rotate&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT Rotate(float angle);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      float m_angle; // In radians.
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void Rotate::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_angle;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;Rotate&gt;&gt; Rotate::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;float&gt; angle;</span>
<span class="line-added">+     decoder &gt;&gt; angle;</span>
<span class="line-added">+     if (!angle)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return Rotate::create(*angle);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class Scale : public Item {
  public:
      static Ref&lt;Scale&gt; create(const FloatSize&amp; size)
      {
          return adoptRef(*new Scale(size));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~Scale();</span>
<span class="line-added">+ </span>
      const FloatSize&amp; amount() const { return m_size; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;Scale&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT Scale(const FloatSize&amp;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     void apply(GraphicsContext&amp;) const override;</span>
<span class="line-added">+ </span>
<span class="line-added">+     FloatSize m_size;</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void Scale::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_size;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;Scale&gt;&gt; Scale::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;FloatSize&gt; scale;</span>
<span class="line-added">+     decoder &gt;&gt; scale;</span>
<span class="line-added">+     if (!scale)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return Scale::create(*scale);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ class SetCTM : public Item {</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     static Ref&lt;SetCTM&gt; create(const AffineTransform&amp; matrix)</span>
      {
<span class="line-added">+         return adoptRef(*new SetCTM(matrix));</span>
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~SetCTM();</span>
<span class="line-added">+ </span>
<span class="line-added">+     const AffineTransform&amp; transform() const { return m_transform; }</span>
<span class="line-added">+ </span>
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;SetCTM&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
<span class="line-added">+ private:</span>
<span class="line-added">+     WEBCORE_EXPORT SetCTM(const AffineTransform&amp;);</span>
<span class="line-added">+ </span>
      void apply(GraphicsContext&amp;) const override;
  
<span class="line-modified">!     AffineTransform m_transform;</span>
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void SetCTM::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_transform;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;SetCTM&gt;&gt; SetCTM::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;AffineTransform&gt; transform;</span>
<span class="line-added">+     decoder &gt;&gt; transform;</span>
<span class="line-added">+     if (!transform)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return SetCTM::create(*transform);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class ConcatenateCTM : public Item {
  public:
      static Ref&lt;ConcatenateCTM&gt; create(const AffineTransform&amp; matrix)
      {
          return adoptRef(*new ConcatenateCTM(matrix));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~ConcatenateCTM();</span>
<span class="line-added">+ </span>
      const AffineTransform&amp; transform() const { return m_transform; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ConcatenateCTM&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT ConcatenateCTM(const AffineTransform&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      AffineTransform m_transform;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void ConcatenateCTM::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_transform;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;ConcatenateCTM&gt;&gt; ConcatenateCTM::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;AffineTransform&gt; transform;</span>
<span class="line-added">+     decoder &gt;&gt; transform;</span>
<span class="line-added">+     if (!transform)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return ConcatenateCTM::create(*transform);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class SetState : public Item {
  public:
      static Ref&lt;SetState&gt; create(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
      {
          return adoptRef(*new SetState(state, flags));
      }
  
<span class="line-added">+     static Ref&lt;SetState&gt; create(const GraphicsContextStateChange&amp; stateChange)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         return adoptRef(*new SetState(stateChange));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     WEBCORE_EXPORT virtual ~SetState();</span>
<span class="line-added">+ </span>
      const GraphicsContextStateChange&amp; state() const { return m_state; }
  
      void accumulate(const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);
  
      void accumulate(GraphicsContextState&amp;) const;
  
<span class="line-modified">!     static void builderState(GraphicsContext&amp;, const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);</span>
  
      static void dumpStateChanges(WTF::TextStream&amp;, const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);
<span class="line-added">+ </span>
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;SetState&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT SetState(const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);</span>
<span class="line-modified">!     WEBCORE_EXPORT SetState(const GraphicsContextStateChange&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      GraphicsContextStateChange m_state;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void SetState::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto changeFlags = m_state.m_changeFlags;</span>
<span class="line-added">+     encoder &lt;&lt; changeFlags;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto&amp; state = m_state.m_state;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (changeFlags.contains(GraphicsContextState::StrokeGradientChange)) {</span>
<span class="line-added">+         encoder &lt;&lt; !!state.strokeGradient;</span>
<span class="line-added">+         if (state.strokeGradient)</span>
<span class="line-added">+             encoder &lt;&lt; *state.strokeGradient;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (changeFlags.contains(GraphicsContextState::StrokePatternChange)) {</span>
<span class="line-added">+         encoder &lt;&lt; !!state.strokePattern;</span>
<span class="line-added">+         if (state.strokePattern)</span>
<span class="line-added">+             encoder &lt;&lt; *state.strokePattern;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (changeFlags.contains(GraphicsContextState::FillGradientChange)) {</span>
<span class="line-added">+         encoder &lt;&lt; !!state.fillGradient;</span>
<span class="line-added">+         if (state.fillGradient)</span>
<span class="line-added">+             encoder &lt;&lt; *state.fillGradient;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (changeFlags.contains(GraphicsContextState::FillPatternChange)) {</span>
<span class="line-added">+         encoder &lt;&lt; !!state.fillPattern;</span>
<span class="line-added">+         if (state.fillPattern)</span>
<span class="line-added">+             encoder &lt;&lt; *state.fillPattern;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (changeFlags.contains(GraphicsContextState::ShadowChange)) {</span>
<span class="line-added">+         encoder &lt;&lt; state.shadowOffset;</span>
<span class="line-added">+         encoder &lt;&lt; state.shadowBlur;</span>
<span class="line-added">+         encoder &lt;&lt; state.shadowColor;</span>
<span class="line-added">+ #if USE(CG)</span>
<span class="line-added">+         encoder &lt;&lt; state.shadowsUseLegacyRadius;</span>
<span class="line-added">+ #endif // USE(CG)</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (changeFlags.contains(GraphicsContextState::StrokeThicknessChange))</span>
<span class="line-added">+         encoder &lt;&lt; state.strokeThickness;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (changeFlags.contains(GraphicsContextState::TextDrawingModeChange))</span>
<span class="line-added">+         encoder.encodeEnum(state.textDrawingMode);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (changeFlags.contains(GraphicsContextState::StrokeColorChange))</span>
<span class="line-added">+         encoder &lt;&lt; state.strokeColor;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (changeFlags.contains(GraphicsContextState::FillColorChange))</span>
<span class="line-added">+         encoder &lt;&lt; state.fillColor;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (changeFlags.contains(GraphicsContextState::StrokeStyleChange))</span>
<span class="line-added">+         encoder.encodeEnum(state.strokeStyle);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (changeFlags.contains(GraphicsContextState::FillRuleChange))</span>
<span class="line-added">+         encoder &lt;&lt; state.fillRule;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (changeFlags.contains(GraphicsContextState::CompositeOperationChange))</span>
<span class="line-added">+         encoder &lt;&lt; state.compositeOperator;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (changeFlags.contains(GraphicsContextState::BlendModeChange))</span>
<span class="line-added">+         encoder &lt;&lt; state.blendMode;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (changeFlags.contains(GraphicsContextState::ImageInterpolationQualityChange))</span>
<span class="line-added">+         encoder &lt;&lt; state.imageInterpolationQuality;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (changeFlags.contains(GraphicsContextState::AlphaChange))</span>
<span class="line-added">+         encoder &lt;&lt; state.alpha;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (changeFlags.contains(GraphicsContextState::ShouldAntialiasChange))</span>
<span class="line-added">+         encoder &lt;&lt; state.shouldAntialias;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (changeFlags.contains(GraphicsContextState::ShouldSmoothFontsChange))</span>
<span class="line-added">+         encoder &lt;&lt; state.shouldSmoothFonts;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (changeFlags.contains(GraphicsContextState::ShouldSubpixelQuantizeFontsChange))</span>
<span class="line-added">+         encoder &lt;&lt; state.shouldSubpixelQuantizeFonts;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (changeFlags.contains(GraphicsContextState::ShadowsIgnoreTransformsChange))</span>
<span class="line-added">+         encoder &lt;&lt; state.shadowsIgnoreTransforms;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;SetState&gt;&gt; SetState::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;GraphicsContextState::StateChangeFlags&gt; changeFlags;</span>
<span class="line-added">+     decoder &gt;&gt; changeFlags;</span>
<span class="line-added">+     if (!changeFlags)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     GraphicsContextStateChange stateChange;</span>
<span class="line-added">+     stateChange.m_changeFlags = *changeFlags;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (stateChange.m_changeFlags.contains(GraphicsContextState::StrokeGradientChange)) {</span>
<span class="line-added">+         Optional&lt;bool&gt; hasStrokeGradient;</span>
<span class="line-added">+         decoder &gt;&gt; hasStrokeGradient;</span>
<span class="line-added">+         if (!hasStrokeGradient.hasValue())</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (hasStrokeGradient.value()) {</span>
<span class="line-added">+             auto strokeGradient = Gradient::decode(decoder);</span>
<span class="line-added">+             if (!strokeGradient)</span>
<span class="line-added">+                 return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+             stateChange.m_state.strokeGradient = WTFMove(*strokeGradient);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (stateChange.m_changeFlags.contains(GraphicsContextState::StrokePatternChange)) {</span>
<span class="line-added">+         Optional&lt;bool&gt; hasStrokePattern;</span>
<span class="line-added">+         decoder &gt;&gt; hasStrokePattern;</span>
<span class="line-added">+         if (!hasStrokePattern.hasValue())</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (hasStrokePattern.value()) {</span>
<span class="line-added">+             auto strokePattern = Pattern::decode(decoder);</span>
<span class="line-added">+             if (!strokePattern)</span>
<span class="line-added">+                 return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+             stateChange.m_state.strokePattern = WTFMove(*strokePattern);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (stateChange.m_changeFlags.contains(GraphicsContextState::FillGradientChange)) {</span>
<span class="line-added">+         Optional&lt;bool&gt; hasFillGradient;</span>
<span class="line-added">+         decoder &gt;&gt; hasFillGradient;</span>
<span class="line-added">+         if (!hasFillGradient.hasValue())</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (hasFillGradient.value()) {</span>
<span class="line-added">+             auto fillGradient = Gradient::decode(decoder);</span>
<span class="line-added">+             if (!fillGradient)</span>
<span class="line-added">+                 return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+             stateChange.m_state.fillGradient = WTFMove(*fillGradient);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (stateChange.m_changeFlags.contains(GraphicsContextState::FillPatternChange)) {</span>
<span class="line-added">+         Optional&lt;bool&gt; hasFillPattern;</span>
<span class="line-added">+         decoder &gt;&gt; hasFillPattern;</span>
<span class="line-added">+         if (!hasFillPattern.hasValue())</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (hasFillPattern.value()) {</span>
<span class="line-added">+             auto fillPattern = Pattern::decode(decoder);</span>
<span class="line-added">+             if (!fillPattern)</span>
<span class="line-added">+                 return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+             stateChange.m_state.fillPattern = WTFMove(*fillPattern);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (stateChange.m_changeFlags.contains(GraphicsContextState::ShadowChange)) {</span>
<span class="line-added">+         Optional&lt;FloatSize&gt; shadowOffset;</span>
<span class="line-added">+         decoder &gt;&gt; shadowOffset;</span>
<span class="line-added">+         if (!shadowOffset)</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         stateChange.m_state.shadowOffset = *shadowOffset;</span>
<span class="line-added">+ </span>
<span class="line-added">+         Optional&lt;float&gt; shadowBlur;</span>
<span class="line-added">+         decoder &gt;&gt; shadowBlur;</span>
<span class="line-added">+         if (!shadowBlur)</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         stateChange.m_state.shadowBlur = *shadowBlur;</span>
<span class="line-added">+ </span>
<span class="line-added">+         Optional&lt;Color&gt; shadowColor;</span>
<span class="line-added">+         decoder &gt;&gt; shadowColor;</span>
<span class="line-added">+         if (!shadowColor)</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         stateChange.m_state.shadowColor = *shadowColor;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if USE(CG)</span>
<span class="line-added">+         Optional&lt;bool&gt; shadowsUseLegacyRadius;</span>
<span class="line-added">+         decoder &gt;&gt; shadowsUseLegacyRadius;</span>
<span class="line-added">+         if (!shadowsUseLegacyRadius)</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         stateChange.m_state.shadowsUseLegacyRadius = *shadowsUseLegacyRadius;</span>
<span class="line-added">+ #endif // USE(CG)</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (stateChange.m_changeFlags.contains(GraphicsContextState::StrokeThicknessChange)) {</span>
<span class="line-added">+         Optional&lt;float&gt; strokeThickness;</span>
<span class="line-added">+         decoder &gt;&gt; strokeThickness;</span>
<span class="line-added">+         if (!strokeThickness)</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         stateChange.m_state.strokeThickness = *strokeThickness;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (stateChange.m_changeFlags.contains(GraphicsContextState::TextDrawingModeChange)) {</span>
<span class="line-added">+         TextDrawingModeFlags textDrawingMode;</span>
<span class="line-added">+         if (!decoder.decodeEnum(textDrawingMode))</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         stateChange.m_state.textDrawingMode = textDrawingMode;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (stateChange.m_changeFlags.contains(GraphicsContextState::StrokeColorChange)) {</span>
<span class="line-added">+         Optional&lt;Color&gt; strokeColor;</span>
<span class="line-added">+         decoder &gt;&gt; strokeColor;</span>
<span class="line-added">+         if (!strokeColor)</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         stateChange.m_state.strokeColor = *strokeColor;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (stateChange.m_changeFlags.contains(GraphicsContextState::FillColorChange)) {</span>
<span class="line-added">+         Optional&lt;Color&gt; fillColor;</span>
<span class="line-added">+         decoder &gt;&gt; fillColor;</span>
<span class="line-added">+         if (!fillColor)</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         stateChange.m_state.fillColor = *fillColor;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (stateChange.m_changeFlags.contains(GraphicsContextState::StrokeStyleChange)) {</span>
<span class="line-added">+         StrokeStyle strokeStyle;</span>
<span class="line-added">+         if (!decoder.decodeEnum(strokeStyle))</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         stateChange.m_state.strokeStyle = strokeStyle;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (stateChange.m_changeFlags.contains(GraphicsContextState::FillRuleChange)) {</span>
<span class="line-added">+         Optional&lt;WindRule&gt; fillRule;</span>
<span class="line-added">+         decoder &gt;&gt; fillRule;</span>
<span class="line-added">+         if (!fillRule)</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         stateChange.m_state.fillRule = *fillRule;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (stateChange.m_changeFlags.contains(GraphicsContextState::CompositeOperationChange)) {</span>
<span class="line-added">+         Optional&lt;CompositeOperator&gt; compositeOperator;</span>
<span class="line-added">+         decoder &gt;&gt; compositeOperator;</span>
<span class="line-added">+         if (!compositeOperator)</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         stateChange.m_state.compositeOperator = *compositeOperator;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (stateChange.m_changeFlags.contains(GraphicsContextState::BlendModeChange)) {</span>
<span class="line-added">+         Optional&lt;BlendMode&gt; blendMode;</span>
<span class="line-added">+         decoder &gt;&gt; blendMode;</span>
<span class="line-added">+         if (!blendMode)</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         stateChange.m_state.blendMode = *blendMode;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (stateChange.m_changeFlags.contains(GraphicsContextState::ImageInterpolationQualityChange)) {</span>
<span class="line-added">+         Optional&lt;InterpolationQuality&gt; imageInterpolationQuality;</span>
<span class="line-added">+         decoder &gt;&gt; imageInterpolationQuality;</span>
<span class="line-added">+         if (!imageInterpolationQuality)</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         stateChange.m_state.imageInterpolationQuality = *imageInterpolationQuality;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (stateChange.m_changeFlags.contains(GraphicsContextState::AlphaChange)) {</span>
<span class="line-added">+         Optional&lt;float&gt; alpha;</span>
<span class="line-added">+         decoder &gt;&gt; alpha;</span>
<span class="line-added">+         if (!alpha)</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         stateChange.m_state.alpha = *alpha;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (stateChange.m_changeFlags.contains(GraphicsContextState::ShouldAntialiasChange)) {</span>
<span class="line-added">+         Optional&lt;bool&gt; shouldAntialias;</span>
<span class="line-added">+         decoder &gt;&gt; shouldAntialias;</span>
<span class="line-added">+         if (!shouldAntialias)</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         stateChange.m_state.shouldAntialias = *shouldAntialias;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (stateChange.m_changeFlags.contains(GraphicsContextState::ShouldSmoothFontsChange)) {</span>
<span class="line-added">+         Optional&lt;bool&gt; shouldSmoothFonts;</span>
<span class="line-added">+         decoder &gt;&gt; shouldSmoothFonts;</span>
<span class="line-added">+         if (!shouldSmoothFonts)</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         stateChange.m_state.shouldSmoothFonts = *shouldSmoothFonts;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (stateChange.m_changeFlags.contains(GraphicsContextState::ShouldSubpixelQuantizeFontsChange)) {</span>
<span class="line-added">+         Optional&lt;bool&gt; shouldSubpixelQuantizeFonts;</span>
<span class="line-added">+         decoder &gt;&gt; shouldSubpixelQuantizeFonts;</span>
<span class="line-added">+         if (!shouldSubpixelQuantizeFonts)</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         stateChange.m_state.shouldSubpixelQuantizeFonts = *shouldSubpixelQuantizeFonts;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (stateChange.m_changeFlags.contains(GraphicsContextState::ShadowsIgnoreTransformsChange)) {</span>
<span class="line-added">+         Optional&lt;bool&gt; shadowsIgnoreTransforms;</span>
<span class="line-added">+         decoder &gt;&gt; shadowsIgnoreTransforms;</span>
<span class="line-added">+         if (!shadowsIgnoreTransforms)</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         stateChange.m_state.shadowsIgnoreTransforms = *shadowsIgnoreTransforms;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return SetState::create(stateChange);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class SetLineCap : public Item {
  public:
      static Ref&lt;SetLineCap&gt; create(LineCap lineCap)
      {
          return adoptRef(*new SetLineCap(lineCap));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~SetLineCap();</span>
<span class="line-added">+ </span>
      LineCap lineCap() const { return m_lineCap; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;SetLineCap&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT SetLineCap(LineCap);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      LineCap m_lineCap;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void SetLineCap::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_lineCap;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;SetLineCap&gt;&gt; SetLineCap::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;LineCap&gt; lineCap;</span>
<span class="line-added">+     decoder &gt;&gt; lineCap;</span>
<span class="line-added">+     if (!lineCap)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return SetLineCap::create(*lineCap);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class SetLineDash : public Item {
  public:
      static Ref&lt;SetLineDash&gt; create(const DashArray&amp; dashArray, float dashOffset)
      {
          return adoptRef(*new SetLineDash(dashArray, dashOffset));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~SetLineDash();</span>
<span class="line-added">+ </span>
      const DashArray&amp; dashArray() const { return m_dashArray; }
      float dashOffset() const { return m_dashOffset; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;SetLineDash&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT SetLineDash(const DashArray&amp;, float dashOffset);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      DashArray m_dashArray;
      float m_dashOffset;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void SetLineDash::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_dashArray;</span>
<span class="line-added">+     encoder &lt;&lt; m_dashOffset;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;SetLineDash&gt;&gt; SetLineDash::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;DashArray&gt; dashArray;</span>
<span class="line-added">+     decoder &gt;&gt; dashArray;</span>
<span class="line-added">+     if (!dashArray)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;float&gt; dashOffset;</span>
<span class="line-added">+     decoder &gt;&gt; dashOffset;</span>
<span class="line-added">+     if (!dashOffset)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return SetLineDash::create(*dashArray, *dashOffset);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class SetLineJoin : public Item {
  public:
      static Ref&lt;SetLineJoin&gt; create(LineJoin lineJoin)
      {
          return adoptRef(*new SetLineJoin(lineJoin));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~SetLineJoin();</span>
<span class="line-added">+ </span>
      LineJoin lineJoin() const { return m_lineJoin; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;SetLineJoin&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT SetLineJoin(LineJoin);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      LineJoin m_lineJoin;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void SetLineJoin::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_lineJoin;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;SetLineJoin&gt;&gt; SetLineJoin::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;LineJoin&gt; lineJoin;</span>
<span class="line-added">+     decoder &gt;&gt; lineJoin;</span>
<span class="line-added">+     if (!lineJoin)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return SetLineJoin::create(*lineJoin);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class SetMiterLimit : public Item {
  public:
      static Ref&lt;SetMiterLimit&gt; create(float limit)
      {
          return adoptRef(*new SetMiterLimit(limit));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~SetMiterLimit();</span>
<span class="line-added">+ </span>
      float miterLimit() const { return m_miterLimit; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;SetMiterLimit&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT SetMiterLimit(float);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      float m_miterLimit;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void SetMiterLimit::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_miterLimit;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;SetMiterLimit&gt;&gt; SetMiterLimit::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;float&gt; miterLimit;</span>
<span class="line-added">+     decoder &gt;&gt; miterLimit;</span>
<span class="line-added">+     if (!miterLimit)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return SetMiterLimit::create(*miterLimit);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class ClearShadow : public Item {
  public:
      static Ref&lt;ClearShadow&gt; create()
      {
          return adoptRef(*new ClearShadow);
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~ClearShadow();</span>
<span class="line-added">+ </span>
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ClearShadow&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT ClearShadow();</span>
  
      void apply(GraphicsContext&amp;) const override;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void ClearShadow::encode(Encoder&amp;) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;ClearShadow&gt;&gt; ClearShadow::decode(Decoder&amp;)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return ClearShadow::create();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // FIXME: treat as DrawingItem?
  class Clip : public Item {
  public:
      static Ref&lt;Clip&gt; create(const FloatRect&amp; rect)
      {
          return adoptRef(*new Clip(rect));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~Clip();</span>
<span class="line-added">+ </span>
      FloatRect rect() const { return m_rect; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;Clip&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT Clip(const FloatRect&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      FloatRect m_rect;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void Clip::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_rect;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;Clip&gt;&gt; Clip::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">+     decoder &gt;&gt; rect;</span>
<span class="line-added">+     if (!rect)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return Clip::create(*rect);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class ClipOut : public Item {
  public:
      static Ref&lt;ClipOut&gt; create(const FloatRect&amp; rect)
      {
          return adoptRef(*new ClipOut(rect));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~ClipOut();</span>
<span class="line-added">+ </span>
      FloatRect rect() const { return m_rect; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ClipOut&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT ClipOut(const FloatRect&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      FloatRect m_rect;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void ClipOut::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_rect;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;ClipOut&gt;&gt; ClipOut::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">+     decoder &gt;&gt; rect;</span>
<span class="line-added">+     if (!rect)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return ClipOut::create(*rect);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class ClipOutToPath : public Item {
  public:
      static Ref&lt;ClipOutToPath&gt; create(const Path&amp; path)
      {
          return adoptRef(*new ClipOutToPath(path));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~ClipOutToPath();</span>
<span class="line-added">+ </span>
      const Path&amp; path() const { return m_path; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ClipOutToPath&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT ClipOutToPath(const Path&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      const Path m_path;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void ClipOutToPath::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_path;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;ClipOutToPath&gt;&gt; ClipOutToPath::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;Path&gt; path;</span>
<span class="line-added">+     decoder &gt;&gt; path;</span>
<span class="line-added">+     if (!path)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return ClipOutToPath::create(*path);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class ClipPath : public Item {
  public:
      static Ref&lt;ClipPath&gt; create(const Path&amp; path, WindRule windRule)
      {
          return adoptRef(*new ClipPath(path, windRule));
      }
  
<span class="line-added">+     WEBCORE_EXPORT ~ClipPath();</span>
<span class="line-added">+ </span>
      const Path&amp; path() const { return m_path; }
      WindRule windRule() const { return m_windRule; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ClipPath&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT ClipPath(const Path&amp;, WindRule);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      const Path m_path;
      WindRule m_windRule;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void ClipPath::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_path;</span>
<span class="line-added">+     encoder &lt;&lt; m_windRule;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;ClipPath&gt;&gt; ClipPath::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;Path&gt; path;</span>
<span class="line-added">+     decoder &gt;&gt; path;</span>
<span class="line-added">+     if (!path)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;WindRule&gt; windRule;</span>
<span class="line-added">+     decoder &gt;&gt; windRule;</span>
<span class="line-added">+     if (!windRule)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return ClipPath::create(*path, *windRule);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class DrawGlyphs : public DrawingItem {
  public:
      static Ref&lt;DrawGlyphs&gt; create(const Font&amp; font, const GlyphBufferGlyph* glyphs, const GlyphBufferAdvance* advances, unsigned count, const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, FontSmoothingMode smoothingMode)
      {
          return adoptRef(*new DrawGlyphs(font, glyphs, advances, count, blockLocation, localAnchor, smoothingMode));
      }
  
<span class="line-added">+     static Ref&lt;DrawGlyphs&gt; create(const Font&amp; font, Vector&lt;GlyphBufferGlyph, 128&gt;&amp;&amp; glyphs, Vector&lt;GlyphBufferAdvance, 128&gt;&amp;&amp; advances, const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, FontSmoothingMode smoothingMode)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         return adoptRef(*new DrawGlyphs(font, WTFMove(glyphs), WTFMove(advances), blockLocation, localAnchor, smoothingMode));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     WEBCORE_EXPORT virtual ~DrawGlyphs();</span>
<span class="line-added">+ </span>
      const FloatPoint&amp; blockLocation() const { return m_blockLocation; }
      void setBlockLocation(const FloatPoint&amp; blockLocation) { m_blockLocation = blockLocation; }
  
      const FloatSize&amp; localAnchor() const { return m_localAnchor; }
  
      FloatPoint anchorPoint() const { return m_blockLocation + m_localAnchor; }
  
      const Vector&lt;GlyphBufferGlyph, 128&gt;&amp; glyphs() const { return m_glyphs; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawGlyphs&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
      DrawGlyphs(const Font&amp;, const GlyphBufferGlyph*, const GlyphBufferAdvance*, unsigned count, const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, FontSmoothingMode);
<span class="line-added">+     WEBCORE_EXPORT DrawGlyphs(const Font&amp;, Vector&lt;GlyphBufferGlyph, 128&gt;&amp;&amp;, Vector&lt;GlyphBufferAdvance, 128&gt;&amp;&amp;, const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, FontSmoothingMode);</span>
  
      void computeBounds();
  
      void apply(GraphicsContext&amp;) const override;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 556,23 ***</span>
      FloatPoint m_blockLocation;
      FloatSize m_localAnchor;
      FontSmoothingMode m_smoothingMode;
  };
  
  class DrawImage : public DrawingItem {
  public:
      static Ref&lt;DrawImage&gt; create(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; imagePaintingOptions)
      {
          return adoptRef(*new DrawImage(image, destination, source, imagePaintingOptions));
      }
  
      const Image&amp; image() const { return m_image.get(); }
      FloatRect source() const { return m_source; }
      FloatRect destination() const { return m_destination; }
  
  private:
<span class="line-modified">!     DrawImage(Image&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }
  
<span class="line-new-header">--- 1095,80 ---</span>
      FloatPoint m_blockLocation;
      FloatSize m_localAnchor;
      FontSmoothingMode m_smoothingMode;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void DrawGlyphs::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     FontHandle handle;</span>
<span class="line-added">+     handle.font = m_font.ptr();</span>
<span class="line-added">+     encoder &lt;&lt; handle;</span>
<span class="line-added">+     encoder &lt;&lt; m_glyphs;</span>
<span class="line-added">+     encoder &lt;&lt; m_advances;</span>
<span class="line-added">+     encoder &lt;&lt; m_blockLocation;</span>
<span class="line-added">+     encoder &lt;&lt; m_localAnchor;</span>
<span class="line-added">+     encoder &lt;&lt; m_smoothingMode;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;DrawGlyphs&gt;&gt; DrawGlyphs::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;FontHandle&gt; handle;</span>
<span class="line-added">+     decoder &gt;&gt; handle;</span>
<span class="line-added">+     if (!handle || !handle-&gt;font)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;Vector&lt;GlyphBufferGlyph, 128&gt;&gt; glyphs;</span>
<span class="line-added">+     decoder &gt;&gt; glyphs;</span>
<span class="line-added">+     if (!glyphs)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;Vector&lt;GlyphBufferAdvance, 128&gt;&gt; advances;</span>
<span class="line-added">+     decoder &gt;&gt; advances;</span>
<span class="line-added">+     if (!advances)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (glyphs-&gt;size() != advances-&gt;size())</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;FloatPoint&gt; blockLocation;</span>
<span class="line-added">+     decoder &gt;&gt; blockLocation;</span>
<span class="line-added">+     if (!blockLocation)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;FloatSize&gt; localAnchor;</span>
<span class="line-added">+     decoder &gt;&gt; localAnchor;</span>
<span class="line-added">+     if (!localAnchor)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;FontSmoothingMode&gt; smoothingMode;</span>
<span class="line-added">+     decoder &gt;&gt; smoothingMode;</span>
<span class="line-added">+     if (!smoothingMode)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return DrawGlyphs::create(handle-&gt;font.releaseNonNull(), WTFMove(*glyphs), WTFMove(*advances), *blockLocation, *localAnchor, *smoothingMode);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class DrawImage : public DrawingItem {
  public:
      static Ref&lt;DrawImage&gt; create(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; imagePaintingOptions)
      {
          return adoptRef(*new DrawImage(image, destination, source, imagePaintingOptions));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~DrawImage();</span>
<span class="line-added">+ </span>
      const Image&amp; image() const { return m_image.get(); }
      FloatRect source() const { return m_source; }
      FloatRect destination() const { return m_destination; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawImage&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT DrawImage(Image&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 580,26 ***</span>
      FloatRect m_destination;
      FloatRect m_source;
      ImagePaintingOptions m_imagePaintingOptions;
  };
  
  class DrawTiledImage : public DrawingItem {
  public:
      static Ref&lt;DrawTiledImage&gt; create(Image&amp; image, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; imagePaintingOptions)
      {
          return adoptRef(*new DrawTiledImage(image, destination, source, tileSize, spacing, imagePaintingOptions));
      }
  
      const Image&amp; image() const { return m_image.get(); }
      FloatPoint source() const { return m_source; }
      FloatRect destination() const { return m_destination; }
  
      FloatSize tileSize() const { return m_tileSize; }
      FloatSize spacing() const { return m_spacing; }
  
  private:
<span class="line-modified">!     DrawTiledImage(Image&amp;, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }
  
<span class="line-new-header">--- 1176,69 ---</span>
      FloatRect m_destination;
      FloatRect m_source;
      ImagePaintingOptions m_imagePaintingOptions;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void DrawImage::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ImageHandle imageHandle;</span>
<span class="line-added">+     imageHandle.image = m_image.ptr();</span>
<span class="line-added">+ </span>
<span class="line-added">+     encoder &lt;&lt; imageHandle;</span>
<span class="line-added">+     encoder &lt;&lt; m_destination;</span>
<span class="line-added">+     encoder &lt;&lt; m_source;</span>
<span class="line-added">+     encoder &lt;&lt; m_imagePaintingOptions;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;DrawImage&gt;&gt; DrawImage::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;ImageHandle&gt; imageHandle;</span>
<span class="line-added">+     decoder &gt;&gt; imageHandle;</span>
<span class="line-added">+     if (!imageHandle)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;FloatRect&gt; destination;</span>
<span class="line-added">+     decoder &gt;&gt; destination;</span>
<span class="line-added">+     if (!destination)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;FloatRect&gt; source;</span>
<span class="line-added">+     decoder &gt;&gt; source;</span>
<span class="line-added">+     if (!source)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;ImagePaintingOptions&gt; imagePaintingOptions;</span>
<span class="line-added">+     decoder &gt;&gt; imagePaintingOptions;</span>
<span class="line-added">+     if (!imagePaintingOptions)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return DrawImage::create(*imageHandle-&gt;image, *destination, *source, *imagePaintingOptions);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class DrawTiledImage : public DrawingItem {
  public:
      static Ref&lt;DrawTiledImage&gt; create(Image&amp; image, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; imagePaintingOptions)
      {
          return adoptRef(*new DrawTiledImage(image, destination, source, tileSize, spacing, imagePaintingOptions));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~DrawTiledImage();</span>
<span class="line-added">+ </span>
      const Image&amp; image() const { return m_image.get(); }
      FloatPoint source() const { return m_source; }
      FloatRect destination() const { return m_destination; }
  
      FloatSize tileSize() const { return m_tileSize; }
      FloatSize spacing() const { return m_spacing; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawTiledImage&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT DrawTiledImage(Image&amp;, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 609,23 ***</span>
      FloatSize m_tileSize;
      FloatSize m_spacing;
      ImagePaintingOptions m_imagePaintingOptions;
  };
  
  class DrawTiledScaledImage : public DrawingItem {
  public:
      static Ref&lt;DrawTiledScaledImage&gt; create(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor, Image::TileRule hRule, Image::TileRule vRule, const ImagePaintingOptions&amp; imagePaintingOptions)
      {
          return adoptRef(*new DrawTiledScaledImage(image, destination, source, tileScaleFactor, hRule, vRule, imagePaintingOptions));
      }
  
      const Image&amp; image() const { return m_image.get(); }
      FloatRect source() const { return m_source; }
      FloatRect destination() const { return m_destination; }
  
  private:
<span class="line-modified">!     DrawTiledScaledImage(Image&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor, Image::TileRule hRule, Image::TileRule vRule, const ImagePaintingOptions&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }
  
<span class="line-new-header">--- 1248,77 ---</span>
      FloatSize m_tileSize;
      FloatSize m_spacing;
      ImagePaintingOptions m_imagePaintingOptions;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void DrawTiledImage::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ImageHandle imageHandle;</span>
<span class="line-added">+     imageHandle.image = m_image.ptr();</span>
<span class="line-added">+     encoder &lt;&lt; imageHandle;</span>
<span class="line-added">+     encoder &lt;&lt; m_destination;</span>
<span class="line-added">+     encoder &lt;&lt; m_source;</span>
<span class="line-added">+     encoder &lt;&lt; m_tileSize;</span>
<span class="line-added">+     encoder &lt;&lt; m_spacing;</span>
<span class="line-added">+     encoder &lt;&lt; m_imagePaintingOptions;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;DrawTiledImage&gt;&gt; DrawTiledImage::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;ImageHandle&gt; imageHandle;</span>
<span class="line-added">+     decoder &gt;&gt; imageHandle;</span>
<span class="line-added">+     if (!imageHandle)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;FloatRect&gt; destination;</span>
<span class="line-added">+     decoder &gt;&gt; destination;</span>
<span class="line-added">+     if (!destination)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;FloatPoint&gt; source;</span>
<span class="line-added">+     decoder &gt;&gt; source;</span>
<span class="line-added">+     if (!source)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;FloatSize&gt; tileSize;</span>
<span class="line-added">+     decoder &gt;&gt; tileSize;</span>
<span class="line-added">+     if (!tileSize)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;FloatSize&gt; spacing;</span>
<span class="line-added">+     decoder &gt;&gt; spacing;</span>
<span class="line-added">+     if (!spacing)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;ImagePaintingOptions&gt; imagePaintingOptions;</span>
<span class="line-added">+     decoder &gt;&gt; imagePaintingOptions;</span>
<span class="line-added">+     if (!imagePaintingOptions)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return DrawTiledImage::create(*imageHandle-&gt;image, *destination, *source, *tileSize, *spacing, *imagePaintingOptions);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class DrawTiledScaledImage : public DrawingItem {
  public:
      static Ref&lt;DrawTiledScaledImage&gt; create(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor, Image::TileRule hRule, Image::TileRule vRule, const ImagePaintingOptions&amp; imagePaintingOptions)
      {
          return adoptRef(*new DrawTiledScaledImage(image, destination, source, tileScaleFactor, hRule, vRule, imagePaintingOptions));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~DrawTiledScaledImage();</span>
<span class="line-added">+ </span>
      const Image&amp; image() const { return m_image.get(); }
      FloatRect source() const { return m_source; }
      FloatRect destination() const { return m_destination; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawTiledScaledImage&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT DrawTiledScaledImage(Image&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor, Image::TileRule hRule, Image::TileRule vRule, const ImagePaintingOptions&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 636,54 ***</span>
      Image::TileRule m_hRule;
      Image::TileRule m_vRule;
      ImagePaintingOptions m_imagePaintingOptions;
  };
  
  #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)
  class DrawNativeImage : public DrawingItem {
  public:
      static Ref&lt;DrawNativeImage&gt; create(const NativeImagePtr&amp; image, const FloatSize&amp; imageSize, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp; options)
      {
          return adoptRef(*new DrawNativeImage(image, imageSize, destRect, srcRect, options));
      }
  
      FloatRect source() const { return m_srcRect; }
<span class="line-modified">!     FloatRect destination() const { return m_destination; }</span>
  
  private:
<span class="line-modified">!     DrawNativeImage(const NativeImagePtr&amp;, const FloatSize&amp; selfSize, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
<span class="line-modified">!     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }</span>
  
  #if USE(CG)
<span class="line-modified">!     RetainPtr&lt;CGImageRef&gt; m_image;</span>
  #endif
      FloatSize m_imageSize;
<span class="line-modified">!     FloatRect m_destination;</span>
      FloatRect m_srcRect;
      ImagePaintingOptions m_options;
  };
  #endif
  
  class DrawPattern : public DrawingItem {
  public:
      static Ref&lt;DrawPattern&gt; create(Image&amp; image, const FloatRect&amp; destRect, const FloatRect&amp; tileRect, const AffineTransform&amp; patternTransform, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; options)
      {
          return adoptRef(*new DrawPattern(image, destRect, tileRect, patternTransform, phase, spacing, options));
      }
  
      const Image&amp; image() const { return m_image.get(); }
      const AffineTransform&amp; patternTransform() const { return m_patternTransform; }
      FloatRect tileRect() const { return m_tileRect; }
      FloatRect destRect() const { return m_destination; }
      FloatPoint phase() const { return m_phase; }
      FloatSize spacing() const { return m_spacing; }
  
  private:
<span class="line-modified">!     DrawPattern(Image&amp;, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const AffineTransform&amp;, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; = { });</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }
  
<span class="line-new-header">--- 1329,168 ---</span>
      Image::TileRule m_hRule;
      Image::TileRule m_vRule;
      ImagePaintingOptions m_imagePaintingOptions;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void DrawTiledScaledImage::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ImageHandle imageHandle;</span>
<span class="line-added">+     imageHandle.image = m_image.ptr();</span>
<span class="line-added">+     encoder &lt;&lt; imageHandle;</span>
<span class="line-added">+     encoder &lt;&lt; m_destination;</span>
<span class="line-added">+     encoder &lt;&lt; m_source;</span>
<span class="line-added">+     encoder &lt;&lt; m_tileScaleFactor;</span>
<span class="line-added">+     encoder.encodeEnum(m_hRule);</span>
<span class="line-added">+     encoder.encodeEnum(m_vRule);</span>
<span class="line-added">+     encoder &lt;&lt; m_imagePaintingOptions;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;DrawTiledScaledImage&gt;&gt; DrawTiledScaledImage::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;ImageHandle&gt; imageHandle;</span>
<span class="line-added">+     decoder &gt;&gt; imageHandle;</span>
<span class="line-added">+     if (!imageHandle)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;FloatRect&gt; destination;</span>
<span class="line-added">+     decoder &gt;&gt; destination;</span>
<span class="line-added">+     if (!destination)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;FloatRect&gt; source;</span>
<span class="line-added">+     decoder &gt;&gt; source;</span>
<span class="line-added">+     if (!source)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;FloatSize&gt; tileScaleFactor;</span>
<span class="line-added">+     decoder &gt;&gt; tileScaleFactor;</span>
<span class="line-added">+     if (!tileScaleFactor)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Image::TileRule hRule;</span>
<span class="line-added">+     if (!decoder.decodeEnum(hRule))</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Image::TileRule vRule;</span>
<span class="line-added">+     if (!decoder.decodeEnum(vRule))</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;ImagePaintingOptions&gt; imagePaintingOptions;</span>
<span class="line-added">+     decoder &gt;&gt; imagePaintingOptions;</span>
<span class="line-added">+     if (!imagePaintingOptions)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return DrawTiledScaledImage::create(*imageHandle-&gt;image, *destination, *source, *tileScaleFactor, hRule, vRule, *imagePaintingOptions);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)
  class DrawNativeImage : public DrawingItem {
  public:
      static Ref&lt;DrawNativeImage&gt; create(const NativeImagePtr&amp; image, const FloatSize&amp; imageSize, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp; options)
      {
          return adoptRef(*new DrawNativeImage(image, imageSize, destRect, srcRect, options));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~DrawNativeImage();</span>
<span class="line-added">+ </span>
      FloatRect source() const { return m_srcRect; }
<span class="line-modified">!     FloatRect destinationRect() const { return m_destinationRect; }</span>
<span class="line-added">+ </span>
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawNativeImage&gt;&gt; decode(Decoder&amp;);</span>
  
  private:
<span class="line-modified">!     WEBCORE_EXPORT DrawNativeImage(const NativeImagePtr&amp;, const FloatSize&amp; selfSize, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
<span class="line-modified">!     Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destinationRect; }</span>
  
  #if USE(CG)
<span class="line-modified">!     NativeImagePtr m_image;</span>
  #endif
      FloatSize m_imageSize;
<span class="line-modified">!     FloatRect m_destinationRect;</span>
      FloatRect m_srcRect;
      ImagePaintingOptions m_options;
  };
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void DrawNativeImage::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+ #if USE(CG)</span>
<span class="line-added">+     NativeImageHandle handle { m_image };</span>
<span class="line-added">+     encoder &lt;&lt; handle;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     encoder &lt;&lt; m_imageSize;</span>
<span class="line-added">+     encoder &lt;&lt; m_destinationRect;</span>
<span class="line-added">+     encoder &lt;&lt; m_srcRect;</span>
<span class="line-added">+     encoder &lt;&lt; m_options;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;DrawNativeImage&gt;&gt; DrawNativeImage::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+ #if USE(CG)</span>
<span class="line-added">+     Optional&lt;NativeImageHandle&gt; handle;</span>
<span class="line-added">+     decoder &gt;&gt; handle;</span>
<span class="line-added">+     if (!handle)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;FloatSize&gt; imageSize;</span>
<span class="line-added">+     decoder &gt;&gt; imageSize;</span>
<span class="line-added">+     if (!imageSize)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;FloatRect&gt; destinationRect;</span>
<span class="line-added">+     decoder &gt;&gt; destinationRect;</span>
<span class="line-added">+     if (!destinationRect)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;FloatRect&gt; srcRect;</span>
<span class="line-added">+     decoder &gt;&gt; srcRect;</span>
<span class="line-added">+     if (!srcRect)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;ImagePaintingOptions&gt; options;</span>
<span class="line-added">+     decoder &gt;&gt; options;</span>
<span class="line-added">+     if (!options)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if USE(CG)</span>
<span class="line-added">+     NativeImagePtr image = handle-&gt;image;</span>
<span class="line-added">+ #else</span>
<span class="line-added">+     NativeImagePtr image = nullptr;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     return DrawNativeImage::create(image, *imageSize, *destinationRect, *srcRect, *options);</span>
<span class="line-added">+ }</span>
  #endif
  
  class DrawPattern : public DrawingItem {
  public:
      static Ref&lt;DrawPattern&gt; create(Image&amp; image, const FloatRect&amp; destRect, const FloatRect&amp; tileRect, const AffineTransform&amp; patternTransform, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; options)
      {
          return adoptRef(*new DrawPattern(image, destRect, tileRect, patternTransform, phase, spacing, options));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~DrawPattern();</span>
<span class="line-added">+ </span>
      const Image&amp; image() const { return m_image.get(); }
      const AffineTransform&amp; patternTransform() const { return m_patternTransform; }
      FloatRect tileRect() const { return m_tileRect; }
      FloatRect destRect() const { return m_destination; }
      FloatPoint phase() const { return m_phase; }
      FloatSize spacing() const { return m_spacing; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawPattern&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT DrawPattern(Image&amp;, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const AffineTransform&amp;, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; = { });</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_destination; }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 694,125 ***</span>
      FloatPoint m_phase;
      FloatSize m_spacing;
      ImagePaintingOptions m_options;
  };
  
  // Is DrawingItem because the size of the transparency layer is implicitly the clip bounds.
  class BeginTransparencyLayer : public DrawingItem {
  public:
      static Ref&lt;BeginTransparencyLayer&gt; create(float opacity)
      {
          return adoptRef(*new BeginTransparencyLayer(opacity));
      }
  
      float opacity() const { return m_opacity; }
  
  private:
<span class="line-modified">!     BeginTransparencyLayer(float opacity)</span>
<span class="line-removed">-         : DrawingItem(ItemType::BeginTransparencyLayer)</span>
<span class="line-removed">-         , m_opacity(opacity)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      float m_opacity;
  };
  
  class EndTransparencyLayer : public DrawingItem {
  public:
      static Ref&lt;EndTransparencyLayer&gt; create()
      {
          return adoptRef(*new EndTransparencyLayer);
      }
  
  private:
<span class="line-modified">!     EndTransparencyLayer()</span>
<span class="line-removed">-         : DrawingItem(ItemType::EndTransparencyLayer)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
  };
  
  class DrawRect : public DrawingItem {
  public:
      static Ref&lt;DrawRect&gt; create(const FloatRect&amp; rect, float borderThickness)
      {
          return adoptRef(*new DrawRect(rect, borderThickness));
      }
  
      FloatRect rect() const { return m_rect; }
      float borderThickness() const { return m_borderThickness; }
  
  private:
<span class="line-modified">!     DrawRect(const FloatRect&amp; rect, float borderThickness)</span>
<span class="line-removed">-         : DrawingItem(ItemType::DrawRect)</span>
<span class="line-removed">-         , m_rect(rect)</span>
<span class="line-removed">-         , m_borderThickness(borderThickness)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
  
      FloatRect m_rect;
      float m_borderThickness;
  };
  
  class DrawLine : public DrawingItem {
  public:
      static Ref&lt;DrawLine&gt; create(const FloatPoint&amp; point1, const FloatPoint&amp; point2)
      {
          return adoptRef(*new DrawLine(point1, point2));
      }
  
      FloatPoint point1() const { return m_point1; }
      FloatPoint point2() const { return m_point2; }
  
  private:
<span class="line-modified">!     DrawLine(const FloatPoint&amp; point1, const FloatPoint&amp; point2)</span>
<span class="line-removed">-         : DrawingItem(ItemType::DrawLine)</span>
<span class="line-removed">-         , m_point1(point1)</span>
<span class="line-removed">-         , m_point2(point2)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
  
      FloatPoint m_point1;
      FloatPoint m_point2;
  };
  
  class DrawLinesForText : public DrawingItem {
  public:
      static Ref&lt;DrawLinesForText&gt; create(const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, float thickness, const DashArray&amp; widths, bool printing, bool doubleLines)
      {
          return adoptRef(*new DrawLinesForText(blockLocation, localAnchor, thickness, widths, printing, doubleLines));
      }
  
      void setBlockLocation(const FloatPoint&amp; blockLocation) { m_blockLocation = blockLocation; }
      const FloatPoint&amp; blockLocation() const { return m_blockLocation; }
      const FloatSize&amp; localAnchor() const { return m_localAnchor; }
      FloatPoint point() const { return m_blockLocation + m_localAnchor; }
      float thickness() const { return m_thickness; }
      const DashArray&amp; widths() const { return m_widths; }
      bool isPrinting() const { return m_printing; }
      bool doubleLines() const { return m_doubleLines; }
  
  private:
<span class="line-modified">!     DrawLinesForText(const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, float thickness, const DashArray&amp; widths, bool printing, bool doubleLines)</span>
<span class="line-removed">-         : DrawingItem(ItemType::DrawLinesForText)</span>
<span class="line-removed">-         , m_blockLocation(blockLocation)</span>
<span class="line-removed">-         , m_localAnchor(localAnchor)</span>
<span class="line-removed">-         , m_widths(widths)</span>
<span class="line-removed">-         , m_thickness(thickness)</span>
<span class="line-removed">-         , m_printing(printing)</span>
<span class="line-removed">-         , m_doubleLines(doubleLines)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
  
<span class="line-new-header">--- 1501,253 ---</span>
      FloatPoint m_phase;
      FloatSize m_spacing;
      ImagePaintingOptions m_options;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void DrawPattern::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ImageHandle imageHandle;</span>
<span class="line-added">+     imageHandle.image = m_image.ptr();</span>
<span class="line-added">+     encoder &lt;&lt; imageHandle;</span>
<span class="line-added">+     encoder &lt;&lt; m_patternTransform;</span>
<span class="line-added">+     encoder &lt;&lt; m_tileRect;</span>
<span class="line-added">+     encoder &lt;&lt; m_destination;</span>
<span class="line-added">+     encoder &lt;&lt; m_phase;</span>
<span class="line-added">+     encoder &lt;&lt; m_spacing;</span>
<span class="line-added">+     encoder &lt;&lt; m_options;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;DrawPattern&gt;&gt; DrawPattern::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;ImageHandle&gt; imageHandle;</span>
<span class="line-added">+     decoder &gt;&gt; imageHandle;</span>
<span class="line-added">+     if (!imageHandle)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;AffineTransform&gt; patternTransform;</span>
<span class="line-added">+     decoder &gt;&gt; patternTransform;</span>
<span class="line-added">+     if (!patternTransform)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;FloatRect&gt; tileRect;</span>
<span class="line-added">+     decoder &gt;&gt; tileRect;</span>
<span class="line-added">+     if (!tileRect)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;FloatRect&gt; destination;</span>
<span class="line-added">+     decoder &gt;&gt; destination;</span>
<span class="line-added">+     if (!destination)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;FloatPoint&gt; phase;</span>
<span class="line-added">+     decoder &gt;&gt; phase;</span>
<span class="line-added">+     if (!phase)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;FloatSize&gt; spacing;</span>
<span class="line-added">+     decoder &gt;&gt; spacing;</span>
<span class="line-added">+     if (!spacing)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;ImagePaintingOptions&gt; options;</span>
<span class="line-added">+     decoder &gt;&gt; options;</span>
<span class="line-added">+     if (!options)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return DrawPattern::create(*imageHandle-&gt;image, *destination, *tileRect, *patternTransform, *phase, *spacing, *options);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Is DrawingItem because the size of the transparency layer is implicitly the clip bounds.
  class BeginTransparencyLayer : public DrawingItem {
  public:
      static Ref&lt;BeginTransparencyLayer&gt; create(float opacity)
      {
          return adoptRef(*new BeginTransparencyLayer(opacity));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~BeginTransparencyLayer();</span>
<span class="line-added">+ </span>
      float opacity() const { return m_opacity; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;BeginTransparencyLayer&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT BeginTransparencyLayer(float opacity);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      float m_opacity;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void BeginTransparencyLayer::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_opacity;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;BeginTransparencyLayer&gt;&gt; BeginTransparencyLayer::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;float&gt; opacity;</span>
<span class="line-added">+     decoder &gt;&gt; opacity;</span>
<span class="line-added">+     if (!opacity)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return BeginTransparencyLayer::create(*opacity);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class EndTransparencyLayer : public DrawingItem {
  public:
      static Ref&lt;EndTransparencyLayer&gt; create()
      {
          return adoptRef(*new EndTransparencyLayer);
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~EndTransparencyLayer();</span>
<span class="line-added">+ </span>
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;EndTransparencyLayer&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT EndTransparencyLayer();</span>
  
      void apply(GraphicsContext&amp;) const override;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void EndTransparencyLayer::encode(Encoder&amp;) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;EndTransparencyLayer&gt;&gt; EndTransparencyLayer::decode(Decoder&amp;)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return EndTransparencyLayer::create();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class DrawRect : public DrawingItem {
  public:
      static Ref&lt;DrawRect&gt; create(const FloatRect&amp; rect, float borderThickness)
      {
          return adoptRef(*new DrawRect(rect, borderThickness));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~DrawRect();</span>
<span class="line-added">+ </span>
      FloatRect rect() const { return m_rect; }
      float borderThickness() const { return m_borderThickness; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawRect&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT DrawRect(const FloatRect&amp;, float borderThickness);</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
  
      FloatRect m_rect;
      float m_borderThickness;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void DrawRect::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_rect;</span>
<span class="line-added">+     encoder &lt;&lt; m_borderThickness;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;DrawRect&gt;&gt; DrawRect::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">+     decoder &gt;&gt; rect;</span>
<span class="line-added">+     if (!rect)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;float&gt; borderThickness;</span>
<span class="line-added">+     decoder &gt;&gt; borderThickness;</span>
<span class="line-added">+     if (!borderThickness)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return DrawRect::create(*rect, *borderThickness);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class DrawLine : public DrawingItem {
  public:
      static Ref&lt;DrawLine&gt; create(const FloatPoint&amp; point1, const FloatPoint&amp; point2)
      {
          return adoptRef(*new DrawLine(point1, point2));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~DrawLine();</span>
<span class="line-added">+ </span>
      FloatPoint point1() const { return m_point1; }
      FloatPoint point2() const { return m_point2; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawLine&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT DrawLine(const FloatPoint&amp;, const FloatPoint&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
  
      FloatPoint m_point1;
      FloatPoint m_point2;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void DrawLine::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_point1;</span>
<span class="line-added">+     encoder &lt;&lt; m_point2;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;DrawLine&gt;&gt; DrawLine::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;FloatPoint&gt; point1;</span>
<span class="line-added">+     decoder &gt;&gt; point1;</span>
<span class="line-added">+     if (!point1)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;FloatPoint&gt; point2;</span>
<span class="line-added">+     decoder &gt;&gt; point2;</span>
<span class="line-added">+     if (!point2)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return DrawLine::create(*point1, *point2);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class DrawLinesForText : public DrawingItem {
  public:
      static Ref&lt;DrawLinesForText&gt; create(const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, float thickness, const DashArray&amp; widths, bool printing, bool doubleLines)
      {
          return adoptRef(*new DrawLinesForText(blockLocation, localAnchor, thickness, widths, printing, doubleLines));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~DrawLinesForText();</span>
<span class="line-added">+ </span>
      void setBlockLocation(const FloatPoint&amp; blockLocation) { m_blockLocation = blockLocation; }
      const FloatPoint&amp; blockLocation() const { return m_blockLocation; }
      const FloatSize&amp; localAnchor() const { return m_localAnchor; }
      FloatPoint point() const { return m_blockLocation + m_localAnchor; }
      float thickness() const { return m_thickness; }
      const DashArray&amp; widths() const { return m_widths; }
      bool isPrinting() const { return m_printing; }
      bool doubleLines() const { return m_doubleLines; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawLinesForText&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT DrawLinesForText(const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, float thickness, const DashArray&amp; widths, bool printing, bool doubleLines);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 822,101 ***</span>
      float m_thickness;
      bool m_printing;
      bool m_doubleLines;
  };
  
  class DrawDotsForDocumentMarker : public DrawingItem {
  public:
      static Ref&lt;DrawDotsForDocumentMarker&gt; create(const FloatRect&amp; rect, DocumentMarkerLineStyle style)
      {
          return adoptRef(*new DrawDotsForDocumentMarker(rect, style));
      }
  
      FloatRect rect() const { return m_rect; }
  
  private:
<span class="line-modified">!     DrawDotsForDocumentMarker(const FloatRect&amp; rect, DocumentMarkerLineStyle style)</span>
<span class="line-removed">-         : DrawingItem(ItemType::DrawDotsForDocumentMarker)</span>
<span class="line-removed">-         , m_rect(rect)</span>
<span class="line-removed">-         , m_style(style)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
  
      FloatRect m_rect;
      DocumentMarkerLineStyle m_style;
  };
  
  class DrawEllipse : public DrawingItem {
  public:
      static Ref&lt;DrawEllipse&gt; create(const FloatRect&amp; rect)
      {
          return adoptRef(*new DrawEllipse(rect));
      }
  
      FloatRect rect() const { return m_rect; }
  
  private:
<span class="line-modified">!     DrawEllipse(const FloatRect&amp; rect)</span>
<span class="line-removed">-         : DrawingItem(ItemType::DrawEllipse)</span>
<span class="line-removed">-         , m_rect(rect)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
  
      FloatRect m_rect;
  };
  
  class DrawPath : public DrawingItem {
  public:
      static Ref&lt;DrawPath&gt; create(const Path&amp; path)
      {
          return adoptRef(*new DrawPath(path));
      }
  
      const Path&amp; path() const { return m_path; }
  
  private:
<span class="line-modified">!     DrawPath(const Path&amp; path)</span>
<span class="line-removed">-         : DrawingItem(ItemType::DrawPath)</span>
<span class="line-removed">-         , m_path(path)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_path.fastBoundingRect(); }
  
      const Path m_path;
  };
  
  class DrawFocusRingPath : public DrawingItem {
  public:
      static Ref&lt;DrawFocusRingPath&gt; create(const Path&amp; path, float width, float offset, const Color&amp; color)
      {
          return adoptRef(*new DrawFocusRingPath(path, width, offset, color));
      }
  
      const Path&amp; path() const { return m_path; }
      float width() const { return m_width; }
      float offset() const { return m_offset; }
      const Color&amp; color() const { return m_color; }
  
  private:
<span class="line-modified">!     DrawFocusRingPath(const Path&amp; path, float width, float offset, const Color&amp; color)</span>
<span class="line-removed">-         : DrawingItem(ItemType::DrawFocusRingPath)</span>
<span class="line-removed">-         , m_path(path)</span>
<span class="line-removed">-         , m_width(width)</span>
<span class="line-removed">-         , m_offset(offset)</span>
<span class="line-removed">-         , m_color(color)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
  
<span class="line-new-header">--- 1757,205 ---</span>
      float m_thickness;
      bool m_printing;
      bool m_doubleLines;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void DrawLinesForText::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_blockLocation;</span>
<span class="line-added">+     encoder &lt;&lt; m_localAnchor;</span>
<span class="line-added">+     encoder &lt;&lt; m_widths;</span>
<span class="line-added">+     encoder &lt;&lt; m_thickness;</span>
<span class="line-added">+     encoder &lt;&lt; m_printing;</span>
<span class="line-added">+     encoder &lt;&lt; m_doubleLines;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;DrawLinesForText&gt;&gt; DrawLinesForText::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;FloatPoint&gt; blockLocation;</span>
<span class="line-added">+     decoder &gt;&gt; blockLocation;</span>
<span class="line-added">+     if (!blockLocation)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;FloatSize&gt; localAnchor;</span>
<span class="line-added">+     decoder &gt;&gt; localAnchor;</span>
<span class="line-added">+     if (!localAnchor)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;DashArray&gt; widths;</span>
<span class="line-added">+     decoder &gt;&gt; widths;</span>
<span class="line-added">+     if (!widths)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;float&gt; thickness;</span>
<span class="line-added">+     decoder &gt;&gt; thickness;</span>
<span class="line-added">+     if (!thickness)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;bool&gt; printing;</span>
<span class="line-added">+     decoder &gt;&gt; printing;</span>
<span class="line-added">+     if (!printing)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;bool&gt; doubleLines;</span>
<span class="line-added">+     decoder &gt;&gt; doubleLines;</span>
<span class="line-added">+     if (!doubleLines)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return DrawLinesForText::create(*blockLocation, *localAnchor, *thickness, *widths, *printing, *doubleLines);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class DrawDotsForDocumentMarker : public DrawingItem {
  public:
      static Ref&lt;DrawDotsForDocumentMarker&gt; create(const FloatRect&amp; rect, DocumentMarkerLineStyle style)
      {
          return adoptRef(*new DrawDotsForDocumentMarker(rect, style));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~DrawDotsForDocumentMarker();</span>
<span class="line-added">+ </span>
      FloatRect rect() const { return m_rect; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawDotsForDocumentMarker&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT DrawDotsForDocumentMarker(const FloatRect&amp;, DocumentMarkerLineStyle);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
  
      FloatRect m_rect;
      DocumentMarkerLineStyle m_style;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void DrawDotsForDocumentMarker::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_rect;</span>
<span class="line-added">+     encoder &lt;&lt; m_style;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;DrawDotsForDocumentMarker&gt;&gt; DrawDotsForDocumentMarker::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">+     decoder &gt;&gt; rect;</span>
<span class="line-added">+     if (!rect)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;DocumentMarkerLineStyle&gt; style;</span>
<span class="line-added">+     decoder &gt;&gt; style;</span>
<span class="line-added">+     if (!style)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return DrawDotsForDocumentMarker::create(*rect, *style);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class DrawEllipse : public DrawingItem {
  public:
      static Ref&lt;DrawEllipse&gt; create(const FloatRect&amp; rect)
      {
          return adoptRef(*new DrawEllipse(rect));
      }
  
<span class="line-added">+     WEBCORE_EXPORT ~DrawEllipse();</span>
<span class="line-added">+ </span>
      FloatRect rect() const { return m_rect; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawEllipse&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT DrawEllipse(const FloatRect&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
  
      FloatRect m_rect;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void DrawEllipse::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_rect;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;DrawEllipse&gt;&gt; DrawEllipse::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">+     decoder &gt;&gt; rect;</span>
<span class="line-added">+     if (!rect)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return DrawEllipse::create(*rect);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class DrawPath : public DrawingItem {
  public:
      static Ref&lt;DrawPath&gt; create(const Path&amp; path)
      {
          return adoptRef(*new DrawPath(path));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~DrawPath();</span>
<span class="line-added">+ </span>
      const Path&amp; path() const { return m_path; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawPath&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT DrawPath(const Path&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_path.fastBoundingRect(); }
  
      const Path m_path;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void DrawPath::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_path;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;DrawPath&gt;&gt; DrawPath::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;Path&gt; path;</span>
<span class="line-added">+     decoder &gt;&gt; path;</span>
<span class="line-added">+     if (!path)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return DrawPath::create(*path);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class DrawFocusRingPath : public DrawingItem {
  public:
      static Ref&lt;DrawFocusRingPath&gt; create(const Path&amp; path, float width, float offset, const Color&amp; color)
      {
          return adoptRef(*new DrawFocusRingPath(path, width, offset, color));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~DrawFocusRingPath();</span>
<span class="line-added">+ </span>
      const Path&amp; path() const { return m_path; }
      float width() const { return m_width; }
      float offset() const { return m_offset; }
      const Color&amp; color() const { return m_color; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawFocusRingPath&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT DrawFocusRingPath(const Path&amp;, float width, float offset, const Color&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 924,31 ***</span>
      float m_width;
      float m_offset;
      Color m_color;
  };
  
  class DrawFocusRingRects : public DrawingItem {
  public:
      static Ref&lt;DrawFocusRingRects&gt; create(const Vector&lt;FloatRect&gt;&amp; rects, float width, float offset, const Color&amp; color)
      {
          return adoptRef(*new DrawFocusRingRects(rects, width, offset, color));
      }
  
      const Vector&lt;FloatRect&gt; rects() const { return m_rects; }
      float width() const { return m_width; }
      float offset() const { return m_offset; }
      const Color&amp; color() const { return m_color; }
  
  private:
<span class="line-modified">!     DrawFocusRingRects(const Vector&lt;FloatRect&gt;&amp; rects, float width, float offset, const Color&amp; color)</span>
<span class="line-removed">-         : DrawingItem(ItemType::DrawFocusRingRects)</span>
<span class="line-removed">-         , m_rects(rects)</span>
<span class="line-removed">-         , m_width(width)</span>
<span class="line-removed">-         , m_offset(offset)</span>
<span class="line-removed">-         , m_color(color)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
  
<span class="line-new-header">--- 1963,64 ---</span>
      float m_width;
      float m_offset;
      Color m_color;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void DrawFocusRingPath::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_path;</span>
<span class="line-added">+     encoder &lt;&lt; m_width;</span>
<span class="line-added">+     encoder &lt;&lt; m_offset;</span>
<span class="line-added">+     encoder &lt;&lt; m_color;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;DrawFocusRingPath&gt;&gt; DrawFocusRingPath::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;Path&gt; path;</span>
<span class="line-added">+     decoder &gt;&gt; path;</span>
<span class="line-added">+     if (!path)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;float&gt; width;</span>
<span class="line-added">+     decoder &gt;&gt; width;</span>
<span class="line-added">+     if (!width)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;float&gt; offset;</span>
<span class="line-added">+     decoder &gt;&gt; offset;</span>
<span class="line-added">+     if (!offset)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;Color&gt; color;</span>
<span class="line-added">+     decoder &gt;&gt; color;</span>
<span class="line-added">+     if (!color)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return DrawFocusRingPath::create(*path, *width, *offset, *color);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class DrawFocusRingRects : public DrawingItem {
  public:
      static Ref&lt;DrawFocusRingRects&gt; create(const Vector&lt;FloatRect&gt;&amp; rects, float width, float offset, const Color&amp; color)
      {
          return adoptRef(*new DrawFocusRingRects(rects, width, offset, color));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~DrawFocusRingRects();</span>
<span class="line-added">+ </span>
      const Vector&lt;FloatRect&gt; rects() const { return m_rects; }
      float width() const { return m_width; }
      float offset() const { return m_offset; }
      const Color&amp; color() const { return m_color; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;DrawFocusRingRects&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT DrawFocusRingRects(const Vector&lt;FloatRect&gt;&amp;, float width, float offset, const Color&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 956,363 ***</span>
      float m_width;
      float m_offset;
      Color m_color;
  };
  
  class FillRect : public DrawingItem {
  public:
      static Ref&lt;FillRect&gt; create(const FloatRect&amp; rect)
      {
          return adoptRef(*new FillRect(rect));
      }
  
      FloatRect rect() const { return m_rect; }
  
  private:
<span class="line-modified">!     FillRect(const FloatRect&amp; rect)</span>
<span class="line-removed">-         : DrawingItem(ItemType::FillRect)</span>
<span class="line-removed">-         , m_rect(rect)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
  
      FloatRect m_rect;
  };
  
  // FIXME: Make these inherit from FillRect proper.
  class FillRectWithColor : public DrawingItem {
  public:
      static Ref&lt;FillRectWithColor&gt; create(const FloatRect&amp; rect, const Color&amp; color)
      {
          return adoptRef(*new FillRectWithColor(rect, color));
      }
  
      FloatRect rect() const { return m_rect; }
      const Color&amp; color() const { return m_color; }
  
  private:
<span class="line-modified">!     FillRectWithColor(const FloatRect&amp; rect, const Color&amp; color)</span>
<span class="line-removed">-         : DrawingItem(ItemType::FillRectWithColor)</span>
<span class="line-removed">-         , m_rect(rect)</span>
<span class="line-removed">-         , m_color(color)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
  
      FloatRect m_rect;
      Color m_color;
  };
  
  class FillRectWithGradient : public DrawingItem {
  public:
      static Ref&lt;FillRectWithGradient&gt; create(const FloatRect&amp; rect, Gradient&amp; gradient)
      {
          return adoptRef(*new FillRectWithGradient(rect, gradient));
      }
  
      FloatRect rect() const { return m_rect; }
  
  private:
<span class="line-modified">!     FillRectWithGradient(const FloatRect&amp; rect, Gradient&amp; gradient)</span>
<span class="line-removed">-         : DrawingItem(ItemType::FillRectWithGradient)</span>
<span class="line-removed">-         , m_rect(rect)</span>
<span class="line-removed">-         , m_gradient(gradient)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
  
      FloatRect m_rect;
      mutable Ref&lt;Gradient&gt; m_gradient; // FIXME: Make this not mutable
  };
  
  class FillCompositedRect : public DrawingItem {
  public:
      static Ref&lt;FillCompositedRect&gt; create(const FloatRect&amp; rect, const Color&amp; color, CompositeOperator op, BlendMode blendMode)
      {
          return adoptRef(*new FillCompositedRect(rect, color, op, blendMode));
      }
  
      FloatRect rect() const { return m_rect; }
      const Color&amp; color() const { return m_color; }
      CompositeOperator compositeOperator() const { return m_op; }
      BlendMode blendMode() const { return m_blendMode; }
  
  private:
<span class="line-modified">!     FillCompositedRect(const FloatRect&amp; rect, const Color&amp; color, CompositeOperator op, BlendMode blendMode)</span>
<span class="line-removed">-         : DrawingItem(ItemType::FillCompositedRect)</span>
<span class="line-removed">-         , m_rect(rect)</span>
<span class="line-removed">-         , m_color(color)</span>
<span class="line-removed">-         , m_op(op)</span>
<span class="line-removed">-         , m_blendMode(blendMode)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
  
      FloatRect m_rect;
      Color m_color;
      CompositeOperator m_op;
      BlendMode m_blendMode;
  };
  
  class FillRoundedRect : public DrawingItem {
  public:
      static Ref&lt;FillRoundedRect&gt; create(const FloatRoundedRect&amp; rect, const Color&amp; color, BlendMode blendMode)
      {
          return adoptRef(*new FillRoundedRect(rect, color, blendMode));
      }
  
      const FloatRoundedRect&amp; roundedRect() const { return m_rect; }
      const Color&amp; color() const { return m_color; }
      BlendMode blendMode() const { return m_blendMode; }
  
  private:
<span class="line-modified">!     FillRoundedRect(const FloatRoundedRect&amp; rect, const Color&amp; color, BlendMode blendMode)</span>
<span class="line-removed">-         : DrawingItem(ItemType::FillRoundedRect)</span>
<span class="line-removed">-         , m_rect(rect)</span>
<span class="line-removed">-         , m_color(color)</span>
<span class="line-removed">-         , m_blendMode(blendMode)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect.rect(); }
  
      FloatRoundedRect m_rect;
      Color m_color;
      BlendMode m_blendMode;
  };
  
  class FillRectWithRoundedHole : public DrawingItem {
  public:
      static Ref&lt;FillRectWithRoundedHole&gt; create(const FloatRect&amp; rect, const FloatRoundedRect&amp; roundedHoleRect, const Color&amp; color)
      {
          return adoptRef(*new FillRectWithRoundedHole(rect, roundedHoleRect, color));
      }
  
      const FloatRect&amp; rect() const { return m_rect; }
      const FloatRoundedRect&amp; roundedHoleRect() const { return m_roundedHoleRect; }
      const Color&amp; color() const { return m_color; }
  
  private:
<span class="line-modified">!     FillRectWithRoundedHole(const FloatRect&amp; rect, const FloatRoundedRect&amp; roundedHoleRect, const Color&amp; color)</span>
<span class="line-removed">-         : DrawingItem(ItemType::FillRectWithRoundedHole)</span>
<span class="line-removed">-         , m_rect(rect)</span>
<span class="line-removed">-         , m_roundedHoleRect(roundedHoleRect)</span>
<span class="line-removed">-         , m_color(color)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
  
      FloatRect m_rect;
      FloatRoundedRect m_roundedHoleRect;
      Color m_color;
  };
  
  class FillPath : public DrawingItem {
  public:
      static Ref&lt;FillPath&gt; create(const Path&amp; path)
      {
          return adoptRef(*new FillPath(path));
      }
  
      const Path&amp; path() const { return m_path; }
  
  private:
<span class="line-modified">!     FillPath(const Path&amp; path)</span>
<span class="line-removed">-         : DrawingItem(ItemType::FillPath)</span>
<span class="line-removed">-         , m_path(path)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_path.fastBoundingRect(); }
  
      const Path m_path;
  };
  
  class FillEllipse : public DrawingItem {
  public:
      static Ref&lt;FillEllipse&gt; create(const FloatRect&amp; rect)
      {
          return adoptRef(*new FillEllipse(rect));
      }
  
      FloatRect rect() const { return m_rect; }
  
  private:
<span class="line-modified">!     FillEllipse(const FloatRect&amp; rect)</span>
<span class="line-removed">-         : DrawingItem(ItemType::FillEllipse)</span>
<span class="line-removed">-         , m_rect(rect)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
  
      FloatRect m_rect;
  };
  
  class StrokeRect : public DrawingItem {
  public:
      static Ref&lt;StrokeRect&gt; create(const FloatRect&amp; rect, float lineWidth)
      {
          return adoptRef(*new StrokeRect(rect, lineWidth));
      }
  
      FloatRect rect() const { return m_rect; }
      float lineWidth() const { return m_lineWidth; }
  
  private:
<span class="line-modified">!     StrokeRect(const FloatRect&amp; rect, float lineWidth)</span>
<span class="line-removed">-         : DrawingItem(ItemType::StrokeRect)</span>
<span class="line-removed">-         , m_rect(rect)</span>
<span class="line-removed">-         , m_lineWidth(lineWidth)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
  
      FloatRect m_rect;
      float m_lineWidth;
  };
  
  class StrokePath : public DrawingItem {
  public:
      static Ref&lt;StrokePath&gt; create(const Path&amp; path)
      {
          return adoptRef(*new StrokePath(path));
      }
  
      const Path&amp; path() const { return m_path; }
  
  private:
<span class="line-modified">!     StrokePath(const Path&amp; path)</span>
<span class="line-removed">-         : DrawingItem(ItemType::StrokePath)</span>
<span class="line-removed">-         , m_path(path)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
  
      const Path m_path;
<span class="line-removed">-     FloatPoint m_blockLocation;</span>
  };
  
  class StrokeEllipse : public DrawingItem {
  public:
      static Ref&lt;StrokeEllipse&gt; create(const FloatRect&amp; rect)
      {
          return adoptRef(*new StrokeEllipse(rect));
      }
  
      FloatRect rect() const { return m_rect; }
  
  private:
<span class="line-modified">!     StrokeEllipse(const FloatRect&amp; rect)</span>
<span class="line-removed">-         : DrawingItem(ItemType::StrokeEllipse)</span>
<span class="line-removed">-         , m_rect(rect)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
  
      FloatRect m_rect;
  };
  
  class ClearRect : public DrawingItem {
  public:
      static Ref&lt;ClearRect&gt; create(const FloatRect&amp; rect)
      {
          return adoptRef(*new ClearRect(rect));
      }
  
      FloatRect rect() const { return m_rect; }
  
  private:
<span class="line-modified">!     ClearRect(const FloatRect&amp; rect)</span>
<span class="line-removed">-         : DrawingItem(ItemType::ClearRect)</span>
<span class="line-removed">-         , m_rect(rect)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
  
      FloatRect m_rect;
  };
  
  #if USE(CG)
  class ApplyStrokePattern : public Item {
  public:
      static Ref&lt;ApplyStrokePattern&gt; create()
      {
          return adoptRef(*new ApplyStrokePattern);
      }
  
  private:
<span class="line-modified">!     ApplyStrokePattern()</span>
<span class="line-removed">-         : Item(ItemType::ApplyStrokePattern)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
  };
  
  class ApplyFillPattern : public Item {
  public:
      static Ref&lt;ApplyFillPattern&gt; create()
      {
          return adoptRef(*new ApplyFillPattern);
      }
  
  private:
<span class="line-modified">!     ApplyFillPattern()</span>
<span class="line-removed">-         : Item(ItemType::ApplyFillPattern)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
  };
  #endif
  
  class ApplyDeviceScaleFactor : public Item {
  public:
      static Ref&lt;ApplyDeviceScaleFactor&gt; create(float scaleFactor)
      {
          return adoptRef(*new ApplyDeviceScaleFactor(scaleFactor));
      }
  
      float scaleFactor() const { return m_scaleFactor; }
  
  private:
<span class="line-modified">!     ApplyDeviceScaleFactor(float scaleFactor)</span>
<span class="line-removed">-         : Item(ItemType::ApplyDeviceScaleFactor)</span>
<span class="line-removed">-         , m_scaleFactor(scaleFactor)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      float m_scaleFactor;
  };
  
  WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const Item&amp;);
  
  } // namespace DisplayList
  } // namespace WebCore
  
  
  #define SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_DRAWINGITEM(ToValueTypeName, predicate) \
<span class="line-new-header">--- 2028,1074 ---</span>
      float m_width;
      float m_offset;
      Color m_color;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void DrawFocusRingRects::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_rects;</span>
<span class="line-added">+     encoder &lt;&lt; m_width;</span>
<span class="line-added">+     encoder &lt;&lt; m_offset;</span>
<span class="line-added">+     encoder &lt;&lt; m_color;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;DrawFocusRingRects&gt;&gt; DrawFocusRingRects::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;Vector&lt;FloatRect&gt;&gt; rects;</span>
<span class="line-added">+     decoder &gt;&gt; rects;</span>
<span class="line-added">+     if (!rects)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;float&gt; width;</span>
<span class="line-added">+     decoder &gt;&gt; width;</span>
<span class="line-added">+     if (!width)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;float&gt; offset;</span>
<span class="line-added">+     decoder &gt;&gt; offset;</span>
<span class="line-added">+     if (!offset)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;Color&gt; color;</span>
<span class="line-added">+     decoder &gt;&gt; color;</span>
<span class="line-added">+     if (!color)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return DrawFocusRingRects::create(*rects, *width, *offset, *color);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class FillRect : public DrawingItem {
  public:
      static Ref&lt;FillRect&gt; create(const FloatRect&amp; rect)
      {
          return adoptRef(*new FillRect(rect));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~FillRect();</span>
<span class="line-added">+ </span>
      FloatRect rect() const { return m_rect; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;FillRect&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT FillRect(const FloatRect&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
  
      FloatRect m_rect;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void FillRect::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_rect;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;FillRect&gt;&gt; FillRect::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">+     decoder &gt;&gt; rect;</span>
<span class="line-added">+     if (!rect)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return FillRect::create(*rect);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // FIXME: Make these inherit from FillRect proper.
  class FillRectWithColor : public DrawingItem {
  public:
      static Ref&lt;FillRectWithColor&gt; create(const FloatRect&amp; rect, const Color&amp; color)
      {
          return adoptRef(*new FillRectWithColor(rect, color));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~FillRectWithColor();</span>
<span class="line-added">+ </span>
      FloatRect rect() const { return m_rect; }
      const Color&amp; color() const { return m_color; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;FillRectWithColor&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT FillRectWithColor(const FloatRect&amp;, const Color&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
  
      FloatRect m_rect;
      Color m_color;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void FillRectWithColor::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_rect;</span>
<span class="line-added">+     encoder &lt;&lt; m_color;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;FillRectWithColor&gt;&gt; FillRectWithColor::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">+     decoder &gt;&gt; rect;</span>
<span class="line-added">+     if (!rect)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;Color&gt; color;</span>
<span class="line-added">+     decoder &gt;&gt; color;</span>
<span class="line-added">+     if (!color)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return FillRectWithColor::create(*rect, *color);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class FillRectWithGradient : public DrawingItem {
  public:
      static Ref&lt;FillRectWithGradient&gt; create(const FloatRect&amp; rect, Gradient&amp; gradient)
      {
          return adoptRef(*new FillRectWithGradient(rect, gradient));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~FillRectWithGradient();</span>
<span class="line-added">+ </span>
      FloatRect rect() const { return m_rect; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;FillRectWithGradient&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT FillRectWithGradient(const FloatRect&amp;, Gradient&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
  
      FloatRect m_rect;
      mutable Ref&lt;Gradient&gt; m_gradient; // FIXME: Make this not mutable
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void FillRectWithGradient::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_rect;</span>
<span class="line-added">+     encoder &lt;&lt; m_gradient.get();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;FillRectWithGradient&gt;&gt; FillRectWithGradient::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">+     decoder &gt;&gt; rect;</span>
<span class="line-added">+     if (!rect)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto gradient = Gradient::decode(decoder);</span>
<span class="line-added">+     if (!gradient)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return FillRectWithGradient::create(*rect, gradient-&gt;get());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class FillCompositedRect : public DrawingItem {
  public:
      static Ref&lt;FillCompositedRect&gt; create(const FloatRect&amp; rect, const Color&amp; color, CompositeOperator op, BlendMode blendMode)
      {
          return adoptRef(*new FillCompositedRect(rect, color, op, blendMode));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~FillCompositedRect();</span>
<span class="line-added">+ </span>
      FloatRect rect() const { return m_rect; }
      const Color&amp; color() const { return m_color; }
      CompositeOperator compositeOperator() const { return m_op; }
      BlendMode blendMode() const { return m_blendMode; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;FillCompositedRect&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT FillCompositedRect(const FloatRect&amp;, const Color&amp;, CompositeOperator, BlendMode);</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
  
      FloatRect m_rect;
      Color m_color;
      CompositeOperator m_op;
      BlendMode m_blendMode;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void FillCompositedRect::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_rect;</span>
<span class="line-added">+     encoder &lt;&lt; m_color;</span>
<span class="line-added">+     encoder &lt;&lt; m_op;</span>
<span class="line-added">+     encoder &lt;&lt; m_blendMode;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;FillCompositedRect&gt;&gt; FillCompositedRect::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">+     decoder &gt;&gt; rect;</span>
<span class="line-added">+     if (!rect)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;Color&gt; color;</span>
<span class="line-added">+     decoder &gt;&gt; color;</span>
<span class="line-added">+     if (!color)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;CompositeOperator&gt; op;</span>
<span class="line-added">+     decoder &gt;&gt; op;</span>
<span class="line-added">+     if (!op)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;BlendMode&gt; blendMode;</span>
<span class="line-added">+     decoder &gt;&gt; blendMode;</span>
<span class="line-added">+     if (!blendMode)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return FillCompositedRect::create(*rect, *color, *op, *blendMode);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class FillRoundedRect : public DrawingItem {
  public:
      static Ref&lt;FillRoundedRect&gt; create(const FloatRoundedRect&amp; rect, const Color&amp; color, BlendMode blendMode)
      {
          return adoptRef(*new FillRoundedRect(rect, color, blendMode));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~FillRoundedRect();</span>
<span class="line-added">+ </span>
      const FloatRoundedRect&amp; roundedRect() const { return m_rect; }
      const Color&amp; color() const { return m_color; }
      BlendMode blendMode() const { return m_blendMode; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;FillRoundedRect&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT FillRoundedRect(const FloatRoundedRect&amp;, const Color&amp;, BlendMode);</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect.rect(); }
  
      FloatRoundedRect m_rect;
      Color m_color;
      BlendMode m_blendMode;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void FillRoundedRect::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_rect;</span>
<span class="line-added">+     encoder &lt;&lt; m_color;</span>
<span class="line-added">+     encoder &lt;&lt; m_blendMode;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;FillRoundedRect&gt;&gt; FillRoundedRect::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;FloatRoundedRect&gt; rect;</span>
<span class="line-added">+     decoder &gt;&gt; rect;</span>
<span class="line-added">+     if (!rect)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;Color&gt; color;</span>
<span class="line-added">+     decoder &gt;&gt; color;</span>
<span class="line-added">+     if (!color)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;BlendMode&gt; blendMode;</span>
<span class="line-added">+     decoder &gt;&gt; blendMode;</span>
<span class="line-added">+     if (!blendMode)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return FillRoundedRect::create(*rect, *color, *blendMode);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class FillRectWithRoundedHole : public DrawingItem {
  public:
      static Ref&lt;FillRectWithRoundedHole&gt; create(const FloatRect&amp; rect, const FloatRoundedRect&amp; roundedHoleRect, const Color&amp; color)
      {
          return adoptRef(*new FillRectWithRoundedHole(rect, roundedHoleRect, color));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~FillRectWithRoundedHole();</span>
<span class="line-added">+ </span>
      const FloatRect&amp; rect() const { return m_rect; }
      const FloatRoundedRect&amp; roundedHoleRect() const { return m_roundedHoleRect; }
      const Color&amp; color() const { return m_color; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;FillRectWithRoundedHole&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT FillRectWithRoundedHole(const FloatRect&amp;, const FloatRoundedRect&amp;, const Color&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
  
      FloatRect m_rect;
      FloatRoundedRect m_roundedHoleRect;
      Color m_color;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void FillRectWithRoundedHole::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_rect;</span>
<span class="line-added">+     encoder &lt;&lt; m_roundedHoleRect;</span>
<span class="line-added">+     encoder &lt;&lt; m_color;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;FillRectWithRoundedHole&gt;&gt; FillRectWithRoundedHole::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">+     decoder &gt;&gt; rect;</span>
<span class="line-added">+     if (!rect)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;FloatRoundedRect&gt; roundedHoleRect;</span>
<span class="line-added">+     decoder &gt;&gt; roundedHoleRect;</span>
<span class="line-added">+     if (!roundedHoleRect)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;Color&gt; color;</span>
<span class="line-added">+     decoder &gt;&gt; color;</span>
<span class="line-added">+     if (!color)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return FillRectWithRoundedHole::create(*rect, *roundedHoleRect, *color);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class FillPath : public DrawingItem {
  public:
      static Ref&lt;FillPath&gt; create(const Path&amp; path)
      {
          return adoptRef(*new FillPath(path));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~FillPath();</span>
<span class="line-added">+ </span>
      const Path&amp; path() const { return m_path; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;FillPath&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT FillPath(const Path&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_path.fastBoundingRect(); }
  
      const Path m_path;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void FillPath::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_path;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;FillPath&gt;&gt; FillPath::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;Path&gt; path;</span>
<span class="line-added">+     decoder &gt;&gt; path;</span>
<span class="line-added">+     if (!path)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return FillPath::create(*path);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class FillEllipse : public DrawingItem {
  public:
      static Ref&lt;FillEllipse&gt; create(const FloatRect&amp; rect)
      {
          return adoptRef(*new FillEllipse(rect));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~FillEllipse();</span>
<span class="line-added">+ </span>
      FloatRect rect() const { return m_rect; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;FillEllipse&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT FillEllipse(const FloatRect&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
  
      FloatRect m_rect;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void FillEllipse::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_rect;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;FillEllipse&gt;&gt; FillEllipse::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">+     decoder &gt;&gt; rect;</span>
<span class="line-added">+     if (!rect)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return FillEllipse::create(*rect);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class StrokeRect : public DrawingItem {
  public:
      static Ref&lt;StrokeRect&gt; create(const FloatRect&amp; rect, float lineWidth)
      {
          return adoptRef(*new StrokeRect(rect, lineWidth));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~StrokeRect();</span>
<span class="line-added">+ </span>
      FloatRect rect() const { return m_rect; }
      float lineWidth() const { return m_lineWidth; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;StrokeRect&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT StrokeRect(const FloatRect&amp;, float);</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
  
      FloatRect m_rect;
      float m_lineWidth;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void StrokeRect::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_rect;</span>
<span class="line-added">+     encoder &lt;&lt; m_lineWidth;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;StrokeRect&gt;&gt; StrokeRect::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">+     decoder &gt;&gt; rect;</span>
<span class="line-added">+     if (!rect)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;float&gt; lineWidth;</span>
<span class="line-added">+     decoder &gt;&gt; lineWidth;</span>
<span class="line-added">+     if (!lineWidth)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return StrokeRect::create(*rect, *lineWidth);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class StrokePath : public DrawingItem {
  public:
      static Ref&lt;StrokePath&gt; create(const Path&amp; path)
      {
          return adoptRef(*new StrokePath(path));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~StrokePath();</span>
<span class="line-added">+ </span>
      const Path&amp; path() const { return m_path; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;StrokePath&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT StrokePath(const Path&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
  
      const Path m_path;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void StrokePath::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_path;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;StrokePath&gt;&gt; StrokePath::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;Path&gt; path;</span>
<span class="line-added">+     decoder &gt;&gt; path;</span>
<span class="line-added">+     if (!path)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return StrokePath::create(*path);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class StrokeEllipse : public DrawingItem {
  public:
      static Ref&lt;StrokeEllipse&gt; create(const FloatRect&amp; rect)
      {
          return adoptRef(*new StrokeEllipse(rect));
      }
  
<span class="line-added">+     WEBCORE_EXPORT ~StrokeEllipse();</span>
<span class="line-added">+ </span>
      FloatRect rect() const { return m_rect; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;StrokeEllipse&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT StrokeEllipse(const FloatRect&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override;
  
      FloatRect m_rect;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void StrokeEllipse::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_rect;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;StrokeEllipse&gt;&gt; StrokeEllipse::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">+     decoder &gt;&gt; rect;</span>
<span class="line-added">+     if (!rect)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return StrokeEllipse::create(*rect);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class ClearRect : public DrawingItem {
  public:
      static Ref&lt;ClearRect&gt; create(const FloatRect&amp; rect)
      {
          return adoptRef(*new ClearRect(rect));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~ClearRect();</span>
<span class="line-added">+ </span>
      FloatRect rect() const { return m_rect; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ClearRect&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT ClearRect(const FloatRect&amp;);</span>
  
      void apply(GraphicsContext&amp;) const override;
      Optional&lt;FloatRect&gt; localBounds(const GraphicsContext&amp;) const override { return m_rect; }
  
      FloatRect m_rect;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void ClearRect::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_rect;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;ClearRect&gt;&gt; ClearRect::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;FloatRect&gt; rect;</span>
<span class="line-added">+     decoder &gt;&gt; rect;</span>
<span class="line-added">+     if (!rect)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return ClearRect::create(*rect);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #if USE(CG)
  class ApplyStrokePattern : public Item {
  public:
      static Ref&lt;ApplyStrokePattern&gt; create()
      {
          return adoptRef(*new ApplyStrokePattern);
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~ApplyStrokePattern();</span>
<span class="line-added">+ </span>
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ApplyStrokePattern&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT ApplyStrokePattern();</span>
  
      void apply(GraphicsContext&amp;) const override;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void ApplyStrokePattern::encode(Encoder&amp;) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;ApplyStrokePattern&gt;&gt; ApplyStrokePattern::decode(Decoder&amp;)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return ApplyStrokePattern::create();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class ApplyFillPattern : public Item {
  public:
      static Ref&lt;ApplyFillPattern&gt; create()
      {
          return adoptRef(*new ApplyFillPattern);
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~ApplyFillPattern();</span>
<span class="line-added">+ </span>
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ApplyFillPattern&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT ApplyFillPattern();</span>
  
      void apply(GraphicsContext&amp;) const override;
  };
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void ApplyFillPattern::encode(Encoder&amp;) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;ApplyFillPattern&gt;&gt; ApplyFillPattern::decode(Decoder&amp;)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return ApplyFillPattern::create();</span>
<span class="line-added">+ }</span>
  #endif
  
  class ApplyDeviceScaleFactor : public Item {
  public:
      static Ref&lt;ApplyDeviceScaleFactor&gt; create(float scaleFactor)
      {
          return adoptRef(*new ApplyDeviceScaleFactor(scaleFactor));
      }
  
<span class="line-added">+     WEBCORE_EXPORT virtual ~ApplyDeviceScaleFactor();</span>
<span class="line-added">+ </span>
      float scaleFactor() const { return m_scaleFactor; }
  
<span class="line-added">+     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">+     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;ApplyDeviceScaleFactor&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     WEBCORE_EXPORT ApplyDeviceScaleFactor(float scaleFactor);</span>
  
      void apply(GraphicsContext&amp;) const override;
  
      float m_scaleFactor;
  };
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void ApplyDeviceScaleFactor::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_scaleFactor;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;ApplyDeviceScaleFactor&gt;&gt; ApplyDeviceScaleFactor::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;float&gt; scaleFactor;</span>
<span class="line-added">+     decoder &gt;&gt; scaleFactor;</span>
<span class="line-added">+     if (!scaleFactor)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return ApplyDeviceScaleFactor::create(*scaleFactor);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const Item&amp;);
  
<span class="line-added">+ template&lt;class Encoder&gt;</span>
<span class="line-added">+ void Item::encode(Encoder&amp; encoder) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     encoder &lt;&lt; m_type;</span>
<span class="line-added">+ </span>
<span class="line-added">+     switch (m_type) {</span>
<span class="line-added">+     case ItemType::Save:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;Save&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::Restore:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;Restore&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::Translate:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;Translate&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::Rotate:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;Rotate&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::Scale:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;Scale&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::SetCTM:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;SetCTM&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::ConcatenateCTM:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;ConcatenateCTM&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::SetState:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;SetState&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::SetLineCap:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;SetLineCap&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::SetLineDash:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;SetLineDash&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::SetLineJoin:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;SetLineJoin&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::SetMiterLimit:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;SetMiterLimit&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::ClearShadow:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;ClearShadow&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::Clip:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;Clip&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::ClipOut:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;ClipOut&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::ClipOutToPath:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;ClipOutToPath&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::ClipPath:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;ClipPath&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::DrawGlyphs:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;DrawGlyphs&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::DrawImage:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;DrawImage&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::DrawTiledImage:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;DrawTiledImage&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::DrawTiledScaledImage:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;DrawTiledScaledImage&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+ #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)</span>
<span class="line-added">+     case ItemType::DrawNativeImage:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;DrawNativeImage&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     case ItemType::DrawPattern:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;DrawPattern&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::DrawRect:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;DrawRect&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::DrawLine:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;DrawLine&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::DrawLinesForText:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;DrawLinesForText&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::DrawDotsForDocumentMarker:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;DrawDotsForDocumentMarker&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::DrawEllipse:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;DrawEllipse&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::DrawPath:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;DrawPath&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::DrawFocusRingPath:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;DrawFocusRingPath&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::DrawFocusRingRects:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;DrawFocusRingRects&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::FillRect:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;FillRect&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::FillRectWithColor:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;FillRectWithColor&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::FillRectWithGradient:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;FillRectWithGradient&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::FillCompositedRect:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;FillCompositedRect&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::FillRoundedRect:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;FillRoundedRect&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::FillRectWithRoundedHole:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;FillRectWithRoundedHole&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::FillPath:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;FillPath&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::FillEllipse:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;FillEllipse&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::StrokeRect:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;StrokeRect&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::StrokePath:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;StrokePath&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::StrokeEllipse:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;StrokeEllipse&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::ClearRect:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;ClearRect&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::BeginTransparencyLayer:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;BeginTransparencyLayer&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::EndTransparencyLayer:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;EndTransparencyLayer&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+ #if USE(CG)</span>
<span class="line-added">+     case ItemType::ApplyStrokePattern:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;ApplyStrokePattern&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::ApplyFillPattern:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;ApplyFillPattern&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     case ItemType::ApplyDeviceScaleFactor:</span>
<span class="line-added">+         encoder &lt;&lt; downcast&lt;ApplyDeviceScaleFactor&gt;(*this);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Decoder&gt;</span>
<span class="line-added">+ Optional&lt;Ref&lt;Item&gt;&gt; Item::decode(Decoder&amp; decoder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Optional&lt;ItemType&gt; itemType;</span>
<span class="line-added">+     decoder &gt;&gt; itemType;</span>
<span class="line-added">+     if (!itemType)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     switch (*itemType) {</span>
<span class="line-added">+     case ItemType::Save:</span>
<span class="line-added">+         if (auto item = Save::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::Restore:</span>
<span class="line-added">+         if (auto item = Restore::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::Translate:</span>
<span class="line-added">+         if (auto item = Translate::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::Rotate:</span>
<span class="line-added">+         if (auto item = Rotate::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::Scale:</span>
<span class="line-added">+         if (auto item = Scale::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::SetCTM:</span>
<span class="line-added">+         if (auto item = SetCTM::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::ConcatenateCTM:</span>
<span class="line-added">+         if (auto item = ConcatenateCTM::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::SetState:</span>
<span class="line-added">+         if (auto item = SetState::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::SetLineCap:</span>
<span class="line-added">+         if (auto item = SetLineCap::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::SetLineDash:</span>
<span class="line-added">+         if (auto item = SetLineDash::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::SetLineJoin:</span>
<span class="line-added">+         if (auto item = SetLineJoin::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::SetMiterLimit:</span>
<span class="line-added">+         if (auto item = SetMiterLimit::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::ClearShadow:</span>
<span class="line-added">+         if (auto item = ClearShadow::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::Clip:</span>
<span class="line-added">+         if (auto item = Clip::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::ClipOut:</span>
<span class="line-added">+         if (auto item = ClipOut::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::ClipOutToPath:</span>
<span class="line-added">+         if (auto item = ClipOutToPath::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::ClipPath:</span>
<span class="line-added">+         if (auto item = ClipPath::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::DrawGlyphs:</span>
<span class="line-added">+         if (auto item = DrawGlyphs::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::DrawImage:</span>
<span class="line-added">+         if (auto item = DrawImage::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::DrawTiledImage:</span>
<span class="line-added">+         if (auto item = DrawTiledImage::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::DrawTiledScaledImage:</span>
<span class="line-added">+         if (auto item = DrawTiledScaledImage::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+ #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)</span>
<span class="line-added">+     case ItemType::DrawNativeImage:</span>
<span class="line-added">+         if (auto item = DrawNativeImage::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     case ItemType::DrawPattern:</span>
<span class="line-added">+         if (auto item = DrawPattern::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::DrawRect:</span>
<span class="line-added">+         if (auto item = DrawRect::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::DrawLine:</span>
<span class="line-added">+         if (auto item = DrawLine::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::DrawLinesForText:</span>
<span class="line-added">+         if (auto item = DrawLinesForText::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::DrawDotsForDocumentMarker:</span>
<span class="line-added">+         if (auto item = DrawDotsForDocumentMarker::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::DrawEllipse:</span>
<span class="line-added">+         if (auto item = DrawEllipse::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::DrawPath:</span>
<span class="line-added">+         if (auto item = DrawPath::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::DrawFocusRingPath:</span>
<span class="line-added">+         if (auto item = DrawFocusRingPath::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::DrawFocusRingRects:</span>
<span class="line-added">+         if (auto item = DrawFocusRingRects::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::FillRect:</span>
<span class="line-added">+         if (auto item = FillRect::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::FillRectWithColor:</span>
<span class="line-added">+         if (auto item = FillRectWithColor::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::FillRectWithGradient:</span>
<span class="line-added">+         if (auto item = FillRectWithGradient::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::FillCompositedRect:</span>
<span class="line-added">+         if (auto item = FillCompositedRect::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::FillRoundedRect:</span>
<span class="line-added">+         if (auto item = FillRoundedRect::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::FillRectWithRoundedHole:</span>
<span class="line-added">+         if (auto item = FillRectWithRoundedHole::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::FillPath:</span>
<span class="line-added">+         if (auto item = FillPath::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::FillEllipse:</span>
<span class="line-added">+         if (auto item = FillEllipse::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::StrokeRect:</span>
<span class="line-added">+         if (auto item = StrokeRect::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::StrokePath:</span>
<span class="line-added">+         if (auto item = StrokePath::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::StrokeEllipse:</span>
<span class="line-added">+         if (auto item = StrokeEllipse::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::ClearRect:</span>
<span class="line-added">+         if (auto item = ClearRect::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::BeginTransparencyLayer:</span>
<span class="line-added">+         if (auto item = BeginTransparencyLayer::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::EndTransparencyLayer:</span>
<span class="line-added">+         if (auto item = EndTransparencyLayer::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+ #if USE(CG)</span>
<span class="line-added">+     case ItemType::ApplyStrokePattern:</span>
<span class="line-added">+         if (auto item = ApplyStrokePattern::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ItemType::ApplyFillPattern:</span>
<span class="line-added">+         if (auto item = ApplyFillPattern::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     case ItemType::ApplyDeviceScaleFactor:</span>
<span class="line-added">+         if (auto item = ApplyDeviceScaleFactor::decode(decoder))</span>
<span class="line-added">+             return static_reference_cast&lt;Item&gt;(WTFMove(*item));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return WTF::nullopt;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  } // namespace DisplayList
  } // namespace WebCore
  
  
  #define SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_DRAWINGITEM(ToValueTypeName, predicate) \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1330,10 ***</span>
<span class="line-new-header">--- 3113,11 ---</span>
  SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Save)
  SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Restore)
  SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Translate)
  SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Rotate)
  SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(Scale)
<span class="line-added">+ SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetCTM)</span>
  SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ConcatenateCTM)
  SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetState)
  SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetLineCap)
  SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetLineDash)
  SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(SetLineJoin)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1377,5 ***</span>
<span class="line-new-header">--- 3161,66 ---</span>
  SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ApplyFillPattern)
  #endif
  SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ApplyDeviceScaleFactor)
  SPECIALIZE_TYPE_TRAITS_DISPLAYLIST_ITEM(ClearShadow)
  
<span class="line-added">+ namespace WTF {</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;&gt; struct EnumTraits&lt;WebCore::DisplayList::ItemType&gt; {</span>
<span class="line-added">+     using values = EnumValues&lt;</span>
<span class="line-added">+     WebCore::DisplayList::ItemType,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::Save,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::Restore,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::Translate,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::Rotate,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::Scale,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::SetCTM,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::ConcatenateCTM,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::SetState,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::SetLineCap,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::SetLineDash,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::SetLineJoin,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::SetMiterLimit,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::ClearShadow,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::Clip,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::ClipOut,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::ClipOutToPath,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::ClipPath,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::DrawGlyphs,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::DrawImage,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::DrawTiledImage,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::DrawTiledScaledImage,</span>
<span class="line-added">+ #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::DrawNativeImage,</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::DrawPattern,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::DrawRect,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::DrawLine,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::DrawLinesForText,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::DrawDotsForDocumentMarker,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::DrawEllipse,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::DrawPath,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::DrawFocusRingPath,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::DrawFocusRingRects,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::FillRect,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::FillRectWithColor,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::FillRectWithGradient,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::FillCompositedRect,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::FillRoundedRect,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::FillRectWithRoundedHole,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::FillPath,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::FillEllipse,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::StrokeRect,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::StrokePath,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::StrokeEllipse,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::ClearRect,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::BeginTransparencyLayer,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::EndTransparencyLayer,</span>
<span class="line-added">+ #if USE(CG)</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::ApplyStrokePattern,</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::ApplyFillPattern,</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     WebCore::DisplayList::ItemType::ApplyDeviceScaleFactor</span>
<span class="line-added">+     &gt;;</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ } // namespace WTF</span>
</pre>
<center><a href="DisplayListItems.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="DisplayListRecorder.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGArrayMode.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGArrayMode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGArrayifySlowPathGenerator.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGArrayMode.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
413     Structure* originalArrayStructure(Graph&amp;, const CodeOrigin&amp;) const;
414     Structure* originalArrayStructure(Graph&amp;, Node*) const;
415 
416     bool doesConversion() const
417     {
418         return conversion() != Array::AsIs;
419     }
420 
421     bool structureWouldPassArrayModeFiltering(Structure* structure)
422     {
423         return arrayModesAlreadyChecked(arrayModesFromStructure(structure), arrayModesThatPassFiltering());
424     }
425 
426     ArrayModes arrayModesThatPassFiltering() const
427     {
428         ArrayModes result;
429         switch (type()) {
430         case Array::Generic:
431             return ALL_ARRAY_MODES;
432         case Array::Int32:
<span class="line-modified">433             result = arrayModesWithIndexingShape(Int32Shape);</span>
434             break;
435         case Array::Double:
<span class="line-modified">436             result = arrayModesWithIndexingShape(DoubleShape);</span>
437             break;
438         case Array::Contiguous:
<span class="line-modified">439             result = arrayModesWithIndexingShape(ContiguousShape);</span>
440             break;
441         case Array::ArrayStorage:
<span class="line-modified">442             return arrayModesWithIndexingShape(ArrayStorageShape);</span>
443         case Array::SlowPutArrayStorage:
444             return arrayModesWithIndexingShapes(SlowPutArrayStorageShape, ArrayStorageShape);
445         case Array::DirectArguments:
446         case Array::ScopedArguments:
<span class="line-modified">447             return arrayModesWithIndexingShapes(ArrayStorageShape, NonArray);</span>
448         case Array::Int8Array:
449             return Int8ArrayMode;
450         case Array::Int16Array:
451             return Int16ArrayMode;
452         case Array::Int32Array:
453             return Int32ArrayMode;
454         case Array::Uint8Array:
455             return Uint8ArrayMode;
456         case Array::Uint8ClampedArray:
457             return Uint8ClampedArrayMode;
458         case Array::Uint16Array:
459             return Uint16ArrayMode;
460         case Array::Uint32Array:
461             return Uint32ArrayMode;
462         case Array::Float32Array:
463             return Float32ArrayMode;
464         case Array::Float64Array:
465             return Float64ArrayMode;
466         case Array::AnyTypedArray:
467             return ALL_TYPED_ARRAY_MODES;
</pre>
<hr />
<pre>
495     }
496 
497     bool operator==(const ArrayMode&amp; other) const
498     {
499         return type() == other.type()
500             &amp;&amp; arrayClass() == other.arrayClass()
501             &amp;&amp; speculation() == other.speculation()
502             &amp;&amp; conversion() == other.conversion();
503     }
504 
505     bool operator!=(const ArrayMode&amp; other) const
506     {
507         return !(*this == other);
508     }
509 private:
510     explicit ArrayMode(unsigned word)
511     {
512         u.asWord = word;
513     }
514 
<span class="line-modified">515     ArrayModes arrayModesWithIndexingShape(IndexingType shape) const</span>
516     {
517         switch (arrayClass()) {
518         case Array::NonArray:
519         case Array::OriginalNonArray:
520             return asArrayModesIgnoringTypedArrays(shape);
521         case Array::OriginalCopyOnWriteArray:
522             ASSERT(hasInt32(shape) || hasDouble(shape) || hasContiguous(shape));
523             return asArrayModesIgnoringTypedArrays(shape | IsArray) | asArrayModesIgnoringTypedArrays(shape | IsArray | CopyOnWrite);
524         case Array::Array:
525             if (hasInt32(shape) || hasDouble(shape) || hasContiguous(shape))
526                 return asArrayModesIgnoringTypedArrays(shape | IsArray) | asArrayModesIgnoringTypedArrays(shape | IsArray | CopyOnWrite);
527             FALLTHROUGH;
528         case Array::OriginalArray:
529             return asArrayModesIgnoringTypedArrays(shape | IsArray);
530         case Array::PossiblyArray:
531             if (hasInt32(shape) || hasDouble(shape) || hasContiguous(shape))
532                 return asArrayModesIgnoringTypedArrays(shape) | asArrayModesIgnoringTypedArrays(shape | IsArray) | asArrayModesIgnoringTypedArrays(shape | IsArray | CopyOnWrite);
533             return asArrayModesIgnoringTypedArrays(shape) | asArrayModesIgnoringTypedArrays(shape | IsArray);
534         default:
535             // This is only necessary for C++ compilers that don&#39;t understand enums.
536             return 0;
537         }
538     }
539 
<span class="line-modified">540     ArrayModes arrayModesWithIndexingShapes(IndexingType shape1, IndexingType shape2) const</span>

541     {
<span class="line-modified">542         ArrayModes arrayMode1 = arrayModesWithIndexingShape(shape1);</span>
<span class="line-modified">543         ArrayModes arrayMode2 = arrayModesWithIndexingShape(shape2);</span>
544         return arrayMode1 | arrayMode2;
545     }
546 
547     bool alreadyChecked(Graph&amp;, Node*, const AbstractValue&amp;, IndexingType shape) const;
548 
549     union {
550         struct {
551             uint8_t type;
552             uint8_t arrayClass;
553             uint8_t speculation;
554             uint8_t conversion : 4;
555             uint8_t action : 4;
556         } asBytes;
557         unsigned asWord;
558     } u;
559     static_assert(sizeof(decltype(u.asBytes)) == sizeof(decltype(u.asWord)), &quot;the word form of ArrayMode should have the same size as the individual slices&quot;);
560 };
561 
562 static inline bool canCSEStorage(const ArrayMode&amp; arrayMode)
563 {
</pre>
</td>
<td>
<hr />
<pre>
413     Structure* originalArrayStructure(Graph&amp;, const CodeOrigin&amp;) const;
414     Structure* originalArrayStructure(Graph&amp;, Node*) const;
415 
416     bool doesConversion() const
417     {
418         return conversion() != Array::AsIs;
419     }
420 
421     bool structureWouldPassArrayModeFiltering(Structure* structure)
422     {
423         return arrayModesAlreadyChecked(arrayModesFromStructure(structure), arrayModesThatPassFiltering());
424     }
425 
426     ArrayModes arrayModesThatPassFiltering() const
427     {
428         ArrayModes result;
429         switch (type()) {
430         case Array::Generic:
431             return ALL_ARRAY_MODES;
432         case Array::Int32:
<span class="line-modified">433             result = arrayModesWithIndexingShapes(Int32Shape);</span>
434             break;
435         case Array::Double:
<span class="line-modified">436             result = arrayModesWithIndexingShapes(DoubleShape);</span>
437             break;
438         case Array::Contiguous:
<span class="line-modified">439             result = arrayModesWithIndexingShapes(ContiguousShape);</span>
440             break;
441         case Array::ArrayStorage:
<span class="line-modified">442             return arrayModesWithIndexingShapes(ArrayStorageShape);</span>
443         case Array::SlowPutArrayStorage:
444             return arrayModesWithIndexingShapes(SlowPutArrayStorageShape, ArrayStorageShape);
445         case Array::DirectArguments:
446         case Array::ScopedArguments:
<span class="line-modified">447             return arrayModesWithIndexingShapes(ArrayStorageShape, SlowPutArrayStorageShape, NonArray);</span>
448         case Array::Int8Array:
449             return Int8ArrayMode;
450         case Array::Int16Array:
451             return Int16ArrayMode;
452         case Array::Int32Array:
453             return Int32ArrayMode;
454         case Array::Uint8Array:
455             return Uint8ArrayMode;
456         case Array::Uint8ClampedArray:
457             return Uint8ClampedArrayMode;
458         case Array::Uint16Array:
459             return Uint16ArrayMode;
460         case Array::Uint32Array:
461             return Uint32ArrayMode;
462         case Array::Float32Array:
463             return Float32ArrayMode;
464         case Array::Float64Array:
465             return Float64ArrayMode;
466         case Array::AnyTypedArray:
467             return ALL_TYPED_ARRAY_MODES;
</pre>
<hr />
<pre>
495     }
496 
497     bool operator==(const ArrayMode&amp; other) const
498     {
499         return type() == other.type()
500             &amp;&amp; arrayClass() == other.arrayClass()
501             &amp;&amp; speculation() == other.speculation()
502             &amp;&amp; conversion() == other.conversion();
503     }
504 
505     bool operator!=(const ArrayMode&amp; other) const
506     {
507         return !(*this == other);
508     }
509 private:
510     explicit ArrayMode(unsigned word)
511     {
512         u.asWord = word;
513     }
514 
<span class="line-modified">515     ArrayModes arrayModesWithIndexingShapes(IndexingType shape) const</span>
516     {
517         switch (arrayClass()) {
518         case Array::NonArray:
519         case Array::OriginalNonArray:
520             return asArrayModesIgnoringTypedArrays(shape);
521         case Array::OriginalCopyOnWriteArray:
522             ASSERT(hasInt32(shape) || hasDouble(shape) || hasContiguous(shape));
523             return asArrayModesIgnoringTypedArrays(shape | IsArray) | asArrayModesIgnoringTypedArrays(shape | IsArray | CopyOnWrite);
524         case Array::Array:
525             if (hasInt32(shape) || hasDouble(shape) || hasContiguous(shape))
526                 return asArrayModesIgnoringTypedArrays(shape | IsArray) | asArrayModesIgnoringTypedArrays(shape | IsArray | CopyOnWrite);
527             FALLTHROUGH;
528         case Array::OriginalArray:
529             return asArrayModesIgnoringTypedArrays(shape | IsArray);
530         case Array::PossiblyArray:
531             if (hasInt32(shape) || hasDouble(shape) || hasContiguous(shape))
532                 return asArrayModesIgnoringTypedArrays(shape) | asArrayModesIgnoringTypedArrays(shape | IsArray) | asArrayModesIgnoringTypedArrays(shape | IsArray | CopyOnWrite);
533             return asArrayModesIgnoringTypedArrays(shape) | asArrayModesIgnoringTypedArrays(shape | IsArray);
534         default:
535             // This is only necessary for C++ compilers that don&#39;t understand enums.
536             return 0;
537         }
538     }
539 
<span class="line-modified">540     template &lt;typename... Args&gt;</span>
<span class="line-added">541     ArrayModes arrayModesWithIndexingShapes(IndexingType shape1, Args... args) const</span>
542     {
<span class="line-modified">543         ArrayModes arrayMode1 = arrayModesWithIndexingShapes(shape1);</span>
<span class="line-modified">544         ArrayModes arrayMode2 = arrayModesWithIndexingShapes(args...);</span>
545         return arrayMode1 | arrayMode2;
546     }
547 
548     bool alreadyChecked(Graph&amp;, Node*, const AbstractValue&amp;, IndexingType shape) const;
549 
550     union {
551         struct {
552             uint8_t type;
553             uint8_t arrayClass;
554             uint8_t speculation;
555             uint8_t conversion : 4;
556             uint8_t action : 4;
557         } asBytes;
558         unsigned asWord;
559     } u;
560     static_assert(sizeof(decltype(u.asBytes)) == sizeof(decltype(u.asWord)), &quot;the word form of ArrayMode should have the same size as the individual slices&quot;);
561 };
562 
563 static inline bool canCSEStorage(const ArrayMode&amp; arrayMode)
564 {
</pre>
</td>
</tr>
</table>
<center><a href="DFGArrayMode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGArrayifySlowPathGenerator.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
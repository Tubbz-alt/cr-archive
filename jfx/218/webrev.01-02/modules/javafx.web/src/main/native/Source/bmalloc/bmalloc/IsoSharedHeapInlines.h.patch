diff a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoSharedHeapInlines.h b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoSharedHeapInlines.h
--- a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoSharedHeapInlines.h
+++ b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoSharedHeapInlines.h
@@ -49,20 +49,20 @@
 }
 
 template<unsigned passedObjectSize>
 void* IsoSharedHeap::allocateNew(bool abortOnFailure)
 {
-    std::lock_guard<Mutex> locker(mutex());
+    LockHolder locker(mutex());
     constexpr unsigned objectSize = computeObjectSizeForSharedCell(passedObjectSize);
     return m_allocator.template allocate<objectSize>(
         [&] () -> void* {
-            return allocateSlow<passedObjectSize>(abortOnFailure);
+            return allocateSlow<passedObjectSize>(locker, abortOnFailure);
         });
 }
 
 template<unsigned passedObjectSize>
-BNO_INLINE void* IsoSharedHeap::allocateSlow(bool abortOnFailure)
+BNO_INLINE void* IsoSharedHeap::allocateSlow(const LockHolder& locker, bool abortOnFailure)
 {
     Scavenger& scavenger = *Scavenger::get();
     scavenger.didStartGrowing();
     scavenger.scheduleIfUnderMemoryPressure(IsoSharedPage::pageSize);
 
@@ -71,14 +71,14 @@
         RELEASE_BASSERT(!abortOnFailure);
         return nullptr;
     }
 
     if (m_currentPage)
-        m_currentPage->stopAllocating();
+        m_currentPage->stopAllocating(locker);
 
     m_currentPage = page;
-    m_allocator = m_currentPage->startAllocating();
+    m_allocator = m_currentPage->startAllocating(locker);
 
     constexpr unsigned objectSize = computeObjectSizeForSharedCell(passedObjectSize);
     return m_allocator.allocate<objectSize>([] () { BCRASH(); return nullptr; });
 }
 

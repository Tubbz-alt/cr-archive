<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/xml/parser/XMLDocumentParserLibxml2.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="XMLDocumentParser.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../WebKitLegacy/CMakeLists.txt.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/xml/parser/XMLDocumentParserLibxml2.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  27 
  28 #include &quot;config.h&quot;
  29 #include &quot;XMLDocumentParser.h&quot;
  30 
  31 #include &quot;CDATASection.h&quot;
  32 #include &quot;Comment.h&quot;
  33 #include &quot;CachedResourceLoader.h&quot;
  34 #include &quot;Document.h&quot;
  35 #include &quot;DocumentFragment.h&quot;
  36 #include &quot;DocumentType.h&quot;
  37 #include &quot;Frame.h&quot;
  38 #include &quot;FrameLoader.h&quot;
  39 #include &quot;HTMLEntityParser.h&quot;
  40 #include &quot;HTMLHtmlElement.h&quot;
  41 #include &quot;HTMLTemplateElement.h&quot;
  42 #include &quot;InlineClassicScript.h&quot;
  43 #include &quot;PendingScript.h&quot;
  44 #include &quot;ProcessingInstruction.h&quot;
  45 #include &quot;ResourceError.h&quot;
  46 #include &quot;ResourceResponse.h&quot;

  47 #include &quot;ScriptElement.h&quot;
  48 #include &quot;ScriptSourceCode.h&quot;
  49 #include &quot;Settings.h&quot;
  50 #include &quot;SharedBuffer.h&quot;
  51 #include &quot;StyleScope.h&quot;
  52 #include &quot;TransformSource.h&quot;
  53 #include &quot;XMLNSNames.h&quot;
  54 #include &quot;XMLDocumentParserScope.h&quot;
  55 #include &lt;libxml/parserInternals.h&gt;
  56 #include &lt;wtf/unicode/UTF8Conversion.h&gt;
  57 
  58 #if ENABLE(XSLT)
  59 #include &quot;XMLTreeViewer.h&quot;
  60 #include &lt;libxslt/xslt.h&gt;
  61 #endif
  62 
  63 namespace WebCore {
  64 
  65 #if ENABLE(XSLT)
  66 
</pre>
<hr />
<pre>
 554 
 555     return adoptRef(*new XMLParserContext(parser));
 556 }
 557 
 558 // --------------------------------
 559 
 560 bool XMLDocumentParser::supportsXMLVersion(const String&amp; version)
 561 {
 562     return version == &quot;1.0&quot;;
 563 }
 564 
 565 XMLDocumentParser::XMLDocumentParser(Document&amp; document, FrameView* frameView)
 566     : ScriptableDocumentParser(document)
 567     , m_view(frameView)
 568     , m_pendingCallbacks(makeUnique&lt;PendingCallbacks&gt;())
 569     , m_currentNode(&amp;document)
 570     , m_scriptStartPosition(TextPosition::belowRangePosition())
 571 {
 572 }
 573 
<span class="line-modified"> 574 XMLDocumentParser::XMLDocumentParser(DocumentFragment&amp; fragment, Element* parentElement, ParserContentPolicy parserContentPolicy)</span>
 575     : ScriptableDocumentParser(fragment.document(), parserContentPolicy)
 576     , m_pendingCallbacks(makeUnique&lt;PendingCallbacks&gt;())
 577     , m_currentNode(&amp;fragment)
 578     , m_scriptStartPosition(TextPosition::belowRangePosition())
 579     , m_parsingFragment(true)


 580 {
 581     fragment.ref();
<span class="line-removed"> 582 </span>
<span class="line-removed"> 583     // Add namespaces based on the parent node</span>
<span class="line-removed"> 584     Vector&lt;Element*&gt; elemStack;</span>
<span class="line-removed"> 585     while (parentElement) {</span>
<span class="line-removed"> 586         elemStack.append(parentElement);</span>
<span class="line-removed"> 587 </span>
<span class="line-removed"> 588         ContainerNode* node = parentElement-&gt;parentNode();</span>
<span class="line-removed"> 589         if (!is&lt;Element&gt;(node))</span>
<span class="line-removed"> 590             break;</span>
<span class="line-removed"> 591         parentElement = downcast&lt;Element&gt;(node);</span>
<span class="line-removed"> 592     }</span>
<span class="line-removed"> 593 </span>
<span class="line-removed"> 594     if (elemStack.isEmpty())</span>
<span class="line-removed"> 595         return;</span>
<span class="line-removed"> 596 </span>
<span class="line-removed"> 597     // FIXME: Share code with isDefaultNamespace() per http://www.whatwg.org/specs/web-apps/current-work/multipage/the-xhtml-syntax.html#parsing-xhtml-fragments</span>
<span class="line-removed"> 598     for (; !elemStack.isEmpty(); elemStack.removeLast()) {</span>
<span class="line-removed"> 599         Element* element = elemStack.last();</span>
<span class="line-removed"> 600         if (element-&gt;hasAttributes()) {</span>
<span class="line-removed"> 601             for (const Attribute&amp; attribute : element-&gt;attributesIterator()) {</span>
<span class="line-removed"> 602                 if (attribute.localName() == xmlnsAtom())</span>
<span class="line-removed"> 603                     m_defaultNamespaceURI = attribute.value();</span>
<span class="line-removed"> 604                 else if (attribute.prefix() == xmlnsAtom())</span>
<span class="line-removed"> 605                     m_prefixToNamespaceMap.set(attribute.localName(), attribute.value());</span>
<span class="line-removed"> 606             }</span>
<span class="line-removed"> 607         }</span>
<span class="line-removed"> 608     }</span>
<span class="line-removed"> 609 </span>
<span class="line-removed"> 610     if (m_defaultNamespaceURI.isNull())</span>
<span class="line-removed"> 611         m_defaultNamespaceURI = parentElement-&gt;namespaceURI();</span>
 612 }
 613 
 614 XMLParserContext::~XMLParserContext()
 615 {
 616     if (m_context-&gt;myDoc)
 617         xmlFreeDoc(m_context-&gt;myDoc);
 618     xmlFreeParserCtxt(m_context);
 619 }
 620 
 621 XMLDocumentParser::~XMLDocumentParser()
 622 {
 623     // The XMLDocumentParser will always be detached before being destroyed.
 624     ASSERT(m_currentNodeStack.isEmpty());
 625     ASSERT(!m_currentNode);
 626 
 627     // FIXME: m_pendingScript handling should be moved into XMLDocumentParser.cpp!
 628     if (m_pendingScript)
 629         m_pendingScript-&gt;clearClient();
 630 }
 631 
</pre>
<hr />
<pre>
 752 void XMLDocumentParser::startElementNs(const xmlChar* xmlLocalName, const xmlChar* xmlPrefix, const xmlChar* xmlURI, int numNamespaces, const xmlChar** libxmlNamespaces, int numAttributes, int numDefaulted, const xmlChar** libxmlAttributes)
 753 {
 754     if (isStopped())
 755         return;
 756 
 757     if (m_parserPaused) {
 758         m_pendingCallbacks-&gt;appendStartElementNSCallback(xmlLocalName, xmlPrefix, xmlURI, numNamespaces, libxmlNamespaces, numAttributes, numDefaulted, libxmlAttributes);
 759         return;
 760     }
 761 
 762     if (!updateLeafTextNode())
 763         return;
 764 
 765     AtomString localName = toAtomString(xmlLocalName);
 766     AtomString uri = toAtomString(xmlURI);
 767     AtomString prefix = toAtomString(xmlPrefix);
 768 
 769     if (m_parsingFragment &amp;&amp; uri.isNull()) {
 770         if (!prefix.isNull())
 771             uri = m_prefixToNamespaceMap.get(prefix);


 772         else
 773             uri = m_defaultNamespaceURI;
 774     }
 775 
 776     // If libxml entity parsing is broken, transfer the currentNodes&#39; namespaceURI to the new node,
 777     // if we&#39;re currently expanding elements which originate from an entity declaration.
 778     if (hackAroundLibXMLEntityParsingBug() &amp;&amp; depthTriggeringEntityExpansion() != -1 &amp;&amp; context()-&gt;depth &gt; depthTriggeringEntityExpansion() &amp;&amp; uri.isNull() &amp;&amp; prefix.isNull())
 779         uri = m_currentNode-&gt;namespaceURI();
 780 
 781     bool isFirstElement = !m_sawFirstElement;
 782     m_sawFirstElement = true;
 783 
 784     QualifiedName qName(prefix, localName, uri);
 785     auto newElement = m_currentNode-&gt;document().createElement(qName, true);
 786 
 787     Vector&lt;Attribute&gt; prefixedAttributes;
 788     if (!handleNamespaceAttributes(prefixedAttributes, libxmlNamespaces, numNamespaces)) {
 789         setAttributes(newElement.ptr(), prefixedAttributes, parserContentPolicy());
 790         stopParsing();
 791         return;
</pre>
</td>
<td>
<hr />
<pre>
  27 
  28 #include &quot;config.h&quot;
  29 #include &quot;XMLDocumentParser.h&quot;
  30 
  31 #include &quot;CDATASection.h&quot;
  32 #include &quot;Comment.h&quot;
  33 #include &quot;CachedResourceLoader.h&quot;
  34 #include &quot;Document.h&quot;
  35 #include &quot;DocumentFragment.h&quot;
  36 #include &quot;DocumentType.h&quot;
  37 #include &quot;Frame.h&quot;
  38 #include &quot;FrameLoader.h&quot;
  39 #include &quot;HTMLEntityParser.h&quot;
  40 #include &quot;HTMLHtmlElement.h&quot;
  41 #include &quot;HTMLTemplateElement.h&quot;
  42 #include &quot;InlineClassicScript.h&quot;
  43 #include &quot;PendingScript.h&quot;
  44 #include &quot;ProcessingInstruction.h&quot;
  45 #include &quot;ResourceError.h&quot;
  46 #include &quot;ResourceResponse.h&quot;
<span class="line-added">  47 #include &quot;SVGElement.h&quot;</span>
  48 #include &quot;ScriptElement.h&quot;
  49 #include &quot;ScriptSourceCode.h&quot;
  50 #include &quot;Settings.h&quot;
  51 #include &quot;SharedBuffer.h&quot;
  52 #include &quot;StyleScope.h&quot;
  53 #include &quot;TransformSource.h&quot;
  54 #include &quot;XMLNSNames.h&quot;
  55 #include &quot;XMLDocumentParserScope.h&quot;
  56 #include &lt;libxml/parserInternals.h&gt;
  57 #include &lt;wtf/unicode/UTF8Conversion.h&gt;
  58 
  59 #if ENABLE(XSLT)
  60 #include &quot;XMLTreeViewer.h&quot;
  61 #include &lt;libxslt/xslt.h&gt;
  62 #endif
  63 
  64 namespace WebCore {
  65 
  66 #if ENABLE(XSLT)
  67 
</pre>
<hr />
<pre>
 555 
 556     return adoptRef(*new XMLParserContext(parser));
 557 }
 558 
 559 // --------------------------------
 560 
 561 bool XMLDocumentParser::supportsXMLVersion(const String&amp; version)
 562 {
 563     return version == &quot;1.0&quot;;
 564 }
 565 
 566 XMLDocumentParser::XMLDocumentParser(Document&amp; document, FrameView* frameView)
 567     : ScriptableDocumentParser(document)
 568     , m_view(frameView)
 569     , m_pendingCallbacks(makeUnique&lt;PendingCallbacks&gt;())
 570     , m_currentNode(&amp;document)
 571     , m_scriptStartPosition(TextPosition::belowRangePosition())
 572 {
 573 }
 574 
<span class="line-modified"> 575 XMLDocumentParser::XMLDocumentParser(DocumentFragment&amp; fragment, HashMap&lt;AtomString, AtomString&gt;&amp;&amp; prefixToNamespaceMap, const AtomString&amp; defaultNamespaceURI, ParserContentPolicy parserContentPolicy)</span>
 576     : ScriptableDocumentParser(fragment.document(), parserContentPolicy)
 577     , m_pendingCallbacks(makeUnique&lt;PendingCallbacks&gt;())
 578     , m_currentNode(&amp;fragment)
 579     , m_scriptStartPosition(TextPosition::belowRangePosition())
 580     , m_parsingFragment(true)
<span class="line-added"> 581     , m_prefixToNamespaceMap(WTFMove(prefixToNamespaceMap))</span>
<span class="line-added"> 582     , m_defaultNamespaceURI(defaultNamespaceURI)</span>
 583 {
 584     fragment.ref();






























 585 }
 586 
 587 XMLParserContext::~XMLParserContext()
 588 {
 589     if (m_context-&gt;myDoc)
 590         xmlFreeDoc(m_context-&gt;myDoc);
 591     xmlFreeParserCtxt(m_context);
 592 }
 593 
 594 XMLDocumentParser::~XMLDocumentParser()
 595 {
 596     // The XMLDocumentParser will always be detached before being destroyed.
 597     ASSERT(m_currentNodeStack.isEmpty());
 598     ASSERT(!m_currentNode);
 599 
 600     // FIXME: m_pendingScript handling should be moved into XMLDocumentParser.cpp!
 601     if (m_pendingScript)
 602         m_pendingScript-&gt;clearClient();
 603 }
 604 
</pre>
<hr />
<pre>
 725 void XMLDocumentParser::startElementNs(const xmlChar* xmlLocalName, const xmlChar* xmlPrefix, const xmlChar* xmlURI, int numNamespaces, const xmlChar** libxmlNamespaces, int numAttributes, int numDefaulted, const xmlChar** libxmlAttributes)
 726 {
 727     if (isStopped())
 728         return;
 729 
 730     if (m_parserPaused) {
 731         m_pendingCallbacks-&gt;appendStartElementNSCallback(xmlLocalName, xmlPrefix, xmlURI, numNamespaces, libxmlNamespaces, numAttributes, numDefaulted, libxmlAttributes);
 732         return;
 733     }
 734 
 735     if (!updateLeafTextNode())
 736         return;
 737 
 738     AtomString localName = toAtomString(xmlLocalName);
 739     AtomString uri = toAtomString(xmlURI);
 740     AtomString prefix = toAtomString(xmlPrefix);
 741 
 742     if (m_parsingFragment &amp;&amp; uri.isNull()) {
 743         if (!prefix.isNull())
 744             uri = m_prefixToNamespaceMap.get(prefix);
<span class="line-added"> 745         else if (is&lt;SVGElement&gt;(m_currentNode) || localName == SVGNames::svgTag-&gt;localName())</span>
<span class="line-added"> 746             uri = SVGNames::svgNamespaceURI;</span>
 747         else
 748             uri = m_defaultNamespaceURI;
 749     }
 750 
 751     // If libxml entity parsing is broken, transfer the currentNodes&#39; namespaceURI to the new node,
 752     // if we&#39;re currently expanding elements which originate from an entity declaration.
 753     if (hackAroundLibXMLEntityParsingBug() &amp;&amp; depthTriggeringEntityExpansion() != -1 &amp;&amp; context()-&gt;depth &gt; depthTriggeringEntityExpansion() &amp;&amp; uri.isNull() &amp;&amp; prefix.isNull())
 754         uri = m_currentNode-&gt;namespaceURI();
 755 
 756     bool isFirstElement = !m_sawFirstElement;
 757     m_sawFirstElement = true;
 758 
 759     QualifiedName qName(prefix, localName, uri);
 760     auto newElement = m_currentNode-&gt;document().createElement(qName, true);
 761 
 762     Vector&lt;Attribute&gt; prefixedAttributes;
 763     if (!handleNamespaceAttributes(prefixedAttributes, libxmlNamespaces, numNamespaces)) {
 764         setAttributes(newElement.ptr(), prefixedAttributes, parserContentPolicy());
 765         stopParsing();
 766         return;
</pre>
</td>
</tr>
</table>
<center><a href="XMLDocumentParser.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../WebKitLegacy/CMakeLists.txt.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
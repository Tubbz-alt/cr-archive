<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/LayoutPoint.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, Google Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions are
  6  * met:
  7  *
  8  *     * Redistributions of source code must retain the above copyright
  9  * notice, this list of conditions and the following disclaimer.
 10  *     * Redistributions in binary form must reproduce the above
 11  * copyright notice, this list of conditions and the following disclaimer
 12  * in the documentation and/or other materials provided with the
 13  * distribution.
 14  *     * Neither the name of Google Inc. nor the names of its
 15  * contributors may be used to endorse or promote products derived from
 16  * this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29  */
 30 
 31 #pragma once
 32 
 33 #include &quot;FloatPoint.h&quot;
 34 #include &quot;LayoutSize.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 class LayoutPoint {
 39 public:
 40     LayoutPoint() : m_x(0), m_y(0) { }
 41     template&lt;typename T, typename U&gt; LayoutPoint(T x, U y) : m_x(x), m_y(y) { }
 42     LayoutPoint(const IntPoint&amp; point) : m_x(point.x()), m_y(point.y()) { }
 43     explicit LayoutPoint(const FloatPoint&amp; size) : m_x(size.x()), m_y(size.y()) { }
 44     explicit LayoutPoint(const LayoutSize&amp; size) : m_x(size.width()), m_y(size.height()) { }
 45 
 46     static LayoutPoint zero() { return LayoutPoint(); }
 47     bool isZero() const { return !m_x &amp;&amp; !m_y; }
 48 
 49     LayoutUnit x() const { return m_x; }
 50     LayoutUnit y() const { return m_y; }
 51 
 52     template&lt;typename T&gt; void setX(T x) { m_x = x; }
 53     template&lt;typename T&gt; void setY(T y) { m_y = y; }
 54 
 55     void move(const LayoutSize&amp; s) { move(s.width(), s.height()); }
 56     void moveBy(const LayoutPoint&amp; offset) { move(offset.x(), offset.y()); }
 57     template&lt;typename T, typename U&gt; void move(T dx, U dy) { m_x += dx; m_y += dy; }
 58 
 59     void scale(float s)
 60     {
 61         m_x *= s;
 62         m_y *= s;
 63     }
 64 
 65     void scale(float sx, float sy)
 66     {
 67         m_x *= sx;
 68         m_y *= sy;
 69     }
 70 
 71     LayoutPoint scaled(float s) const
 72     {
 73         return { m_x * s, m_y * s };
 74     }
 75 
 76     LayoutPoint scaled(float sx, float sy) const
 77     {
 78         return { m_x * sx, m_y * sy };
 79     }
 80 
 81     LayoutPoint constrainedBetween(const LayoutPoint&amp; min, const LayoutPoint&amp; max) const;
 82 
 83     LayoutPoint expandedTo(const LayoutPoint&amp; other) const
 84     {
 85         return { std::max(m_x, other.m_x), std::max(m_y, other.m_y) };
 86     }
 87 
 88     LayoutPoint shrunkTo(const LayoutPoint&amp; other) const
 89     {
 90         return { std::min(m_x, other.m_x), std::min(m_y, other.m_y) };
 91     }
 92 
 93     void clampNegativeToZero()
 94     {
 95         *this = expandedTo(zero());
 96     }
 97 
 98     LayoutPoint transposedPoint() const
 99     {
100         return { m_y, m_x };
101     }
102 
103     LayoutPoint fraction() const
104     {
105         return { m_x.fraction(), m_y.fraction() };
106     }
107 
108     operator FloatPoint() const { return { m_x, m_y }; }
109 
110 private:
111     LayoutUnit m_x, m_y;
112 };
113 
114 inline LayoutPoint&amp; operator+=(LayoutPoint&amp; a, const LayoutSize&amp; b)
115 {
116     a.move(b.width(), b.height());
117     return a;
118 }
119 
120 inline LayoutPoint&amp; operator-=(LayoutPoint&amp; a, const LayoutSize&amp; b)
121 {
122     a.move(-b.width(), -b.height());
123     return a;
124 }
125 
126 inline LayoutPoint operator+(const LayoutPoint&amp; a, const LayoutSize&amp; b)
127 {
128     return LayoutPoint(a.x() + b.width(), a.y() + b.height());
129 }
130 
131 inline LayoutPoint operator+(const LayoutPoint&amp; a, const LayoutPoint&amp; b)
132 {
133     return LayoutPoint(a.x() + b.x(), a.y() + b.y());
134 }
135 
136 inline LayoutSize operator-(const LayoutPoint&amp; a, const LayoutPoint&amp; b)
137 {
138     return LayoutSize(a.x() - b.x(), a.y() - b.y());
139 }
140 
141 inline LayoutPoint operator-(const LayoutPoint&amp; a, const LayoutSize&amp; b)
142 {
143     return LayoutPoint(a.x() - b.width(), a.y() - b.height());
144 }
145 
146 inline LayoutPoint operator-(const LayoutPoint&amp; point)
147 {
148     return LayoutPoint(-point.x(), -point.y());
149 }
150 
151 inline bool operator==(const LayoutPoint&amp; a, const LayoutPoint&amp; b)
152 {
153     return a.x() == b.x() &amp;&amp; a.y() == b.y();
154 }
155 
156 inline bool operator!=(const LayoutPoint&amp; a, const LayoutPoint&amp; b)
157 {
158     return a.x() != b.x() || a.y() != b.y();
159 }
160 
161 inline LayoutPoint toLayoutPoint(const LayoutSize&amp; size)
162 {
163     return LayoutPoint(size.width(), size.height());
164 }
165 
166 inline LayoutSize toLayoutSize(const LayoutPoint&amp; point)
167 {
168     return LayoutSize(point.x(), point.y());
169 }
170 
171 inline IntPoint flooredIntPoint(const LayoutPoint&amp; point)
172 {
173     return IntPoint(point.x().floor(), point.y().floor());
174 }
175 
176 inline IntPoint roundedIntPoint(const LayoutPoint&amp; point)
177 {
178     return IntPoint(point.x().round(), point.y().round());
179 }
180 
181 inline IntPoint roundedIntPoint(const LayoutSize&amp; size)
182 {
183     return roundedIntPoint(toLayoutPoint(size));
184 }
185 
186 inline IntPoint ceiledIntPoint(const LayoutPoint&amp; point)
187 {
188     return IntPoint(point.x().ceil(), point.y().ceil());
189 }
190 
191 inline LayoutPoint flooredLayoutPoint(const FloatPoint&amp; p)
192 {
193     return LayoutPoint(LayoutUnit::fromFloatFloor(p.x()), LayoutUnit::fromFloatFloor(p.y()));
194 }
195 
196 inline LayoutPoint ceiledLayoutPoint(const FloatPoint&amp; p)
197 {
198     return LayoutPoint(LayoutUnit::fromFloatCeil(p.x()), LayoutUnit::fromFloatCeil(p.y()));
199 }
200 
201 inline IntSize snappedIntSize(const LayoutSize&amp; size, const LayoutPoint&amp; location)
202 {
203     auto snap = [] (LayoutUnit a, LayoutUnit b) {
204         LayoutUnit fraction = b.fraction();
205         return roundToInt(fraction + a) - roundToInt(fraction);
206     };
207     return IntSize(snap(size.width(), location.x()), snap(size.height(), location.y()));
208 }
209 
210 inline FloatPoint roundPointToDevicePixels(const LayoutPoint&amp; point, float pixelSnappingFactor, bool directionalRoundingToRight = true, bool directionalRoundingToBottom = true)
211 {
212     return FloatPoint(roundToDevicePixel(point.x(), pixelSnappingFactor, !directionalRoundingToRight), roundToDevicePixel(point.y(), pixelSnappingFactor, !directionalRoundingToBottom));
213 }
214 
215 inline FloatPoint floorPointToDevicePixels(const LayoutPoint&amp; point, float pixelSnappingFactor)
216 {
217     return FloatPoint(floorToDevicePixel(point.x(), pixelSnappingFactor), floorToDevicePixel(point.y(), pixelSnappingFactor));
218 }
219 
220 inline FloatPoint ceilPointToDevicePixels(const LayoutPoint&amp; point, float pixelSnappingFactor)
221 {
222     return FloatPoint(ceilToDevicePixel(point.x(), pixelSnappingFactor), ceilToDevicePixel(point.y(), pixelSnappingFactor));
223 }
224 
225 inline FloatSize snapSizeToDevicePixel(const LayoutSize&amp; size, const LayoutPoint&amp; location, float pixelSnappingFactor)
226 {
227     auto snap = [&amp;] (LayoutUnit a, LayoutUnit b) {
228         LayoutUnit fraction = b.fraction();
229         return roundToDevicePixel(fraction + a, pixelSnappingFactor) - roundToDevicePixel(fraction, pixelSnappingFactor);
230     };
231     return FloatSize(snap(size.width(), location.x()), snap(size.height(), location.y()));
232 }
233 
234 WEBCORE_EXPORT WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const LayoutPoint&amp;);
235 
236 } // namespace WebCore
237 
    </pre>
  </body>
</html>
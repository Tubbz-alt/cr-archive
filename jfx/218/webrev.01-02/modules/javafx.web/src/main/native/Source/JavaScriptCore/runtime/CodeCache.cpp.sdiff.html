<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CodeCache.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ClonedArguments.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CodeCache.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CodeCache.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;CodeCache.h&quot;
 28 

 29 #include &quot;IndirectEvalExecutable.h&quot;
 30 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 31 
 32 namespace JSC {
 33 
<span class="line-removed"> 34 const Seconds CodeCacheMap::workingSetTime = 10_s;</span>
<span class="line-removed"> 35 </span>
 36 void CodeCacheMap::pruneSlowCase()
 37 {
 38     m_minCapacity = std::max(m_size - m_sizeAtLastPrune, static_cast&lt;int64_t&gt;(0));
 39     m_sizeAtLastPrune = m_size;
 40     m_timeAtLastPrune = MonotonicTime::now();
 41 
 42     if (m_capacity &lt; m_minCapacity)
 43         m_capacity = m_minCapacity;
 44 
 45     while (m_size &gt; m_capacity || !canPruneQuickly()) {
 46         MapType::iterator it = m_map.begin();
 47 
 48         writeCodeBlock(it-&gt;value.cell-&gt;vm(), it-&gt;key, it-&gt;value);
 49 
 50         m_size -= it-&gt;key.length();
 51         m_map.remove(it);
 52     }
 53 }
 54 






























































































 55 template &lt;class UnlinkedCodeBlockType, class ExecutableType&gt;
 56 UnlinkedCodeBlockType* CodeCache::getUnlinkedGlobalCodeBlock(VM&amp; vm, ExecutableType* executable, const SourceCode&amp; source, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error, EvalContextType evalContextType)
 57 {
 58     DerivedContextType derivedContextType = executable-&gt;derivedContextType();
 59     bool isArrowFunctionContext = executable-&gt;isArrowFunctionContext();
 60     SourceCodeKey key(
 61         source, String(), CacheTypes&lt;UnlinkedCodeBlockType&gt;::codeType, strictMode, scriptMode,
 62         derivedContextType, evalContextType, isArrowFunctionContext, codeGenerationMode,
 63         WTF::nullopt);
 64     UnlinkedCodeBlockType* unlinkedCodeBlock = m_sourceCode.findCacheAndUpdateAge&lt;UnlinkedCodeBlockType&gt;(vm, key);
 65     if (unlinkedCodeBlock &amp;&amp; Options::useCodeCache()) {
 66         unsigned lineCount = unlinkedCodeBlock-&gt;lineCount();
 67         unsigned startColumn = unlinkedCodeBlock-&gt;startColumn() + source.startColumn().oneBasedInt();
 68         bool endColumnIsOnStartLine = !lineCount;
 69         unsigned endColumn = unlinkedCodeBlock-&gt;endColumn() + (endColumnIsOnStartLine ? startColumn : 1);
 70         executable-&gt;recordParse(unlinkedCodeBlock-&gt;codeFeatures(), unlinkedCodeBlock-&gt;hasCapturedVariables(), source.firstLine().oneBasedInt() + lineCount, endColumn);
<span class="line-modified"> 71         if (!unlinkedCodeBlock-&gt;sourceURLDirective().isNull())</span>
 72             source.provider()-&gt;setSourceURLDirective(unlinkedCodeBlock-&gt;sourceURLDirective());
<span class="line-modified"> 73         if (!unlinkedCodeBlock-&gt;sourceMappingURLDirective().isNull())</span>
 74             source.provider()-&gt;setSourceMappingURLDirective(unlinkedCodeBlock-&gt;sourceMappingURLDirective());
 75         return unlinkedCodeBlock;
 76     }
 77 
 78     VariableEnvironment variablesUnderTDZ;
 79     unlinkedCodeBlock = generateUnlinkedCodeBlock&lt;UnlinkedCodeBlockType, ExecutableType&gt;(vm, executable, source, strictMode, scriptMode, codeGenerationMode, error, evalContextType, &amp;variablesUnderTDZ);
 80 
 81     if (unlinkedCodeBlock &amp;&amp; Options::useCodeCache()) {
 82         m_sourceCode.addCache(key, SourceCodeValue(vm, unlinkedCodeBlock, m_sourceCode.age()));
 83 
 84         key.source().provider().cacheBytecode([&amp;] {
 85             return encodeCodeBlock(vm, key, unlinkedCodeBlock);
 86         });
 87     }
 88 
 89     return unlinkedCodeBlock;
 90 }
 91 
 92 UnlinkedProgramCodeBlock* CodeCache::getUnlinkedProgramCodeBlock(VM&amp; vm, ProgramExecutable* executable, const SourceCode&amp; source, JSParserStrictMode strictMode, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error)
 93 {
</pre>
<hr />
<pre>
134 
135     // This function assumes an input string that would result in a single function declaration.
136     StatementNode* funcDecl = program-&gt;singleStatement();
137     if (UNLIKELY(!funcDecl)) {
138         JSToken token;
139         error = ParserError(ParserError::SyntaxError, ParserError::SyntaxErrorIrrecoverable, token, &quot;Parser error&quot;, -1);
140         return nullptr;
141     }
142     ASSERT(funcDecl-&gt;isFuncDeclNode());
143 
144     FunctionMetadataNode* metadata = static_cast&lt;FuncDeclNode*&gt;(funcDecl)-&gt;metadata();
145     ASSERT(metadata);
146     if (!metadata)
147         return nullptr;
148 
149     metadata-&gt;overrideName(name);
150     metadata-&gt;setEndPosition(positionBeforeLastNewline);
151     // The Function constructor only has access to global variables, so no variables will be under TDZ unless they&#39;re
152     // in the global lexical environment, which we always TDZ check accesses from.
153     ConstructAbility constructAbility = constructAbilityForParseMode(metadata-&gt;parseMode());
<span class="line-modified">154     UnlinkedFunctionExecutable* functionExecutable = UnlinkedFunctionExecutable::create(vm, source, metadata, UnlinkedNormalFunction, constructAbility, JSParserScriptMode::Classic, WTF::nullopt, DerivedContextType::None);</span>
155 
156     if (!source.provider()-&gt;sourceURLDirective().isNull())
157         functionExecutable-&gt;setSourceURLDirective(source.provider()-&gt;sourceURLDirective());
158     if (!source.provider()-&gt;sourceMappingURLDirective().isNull())
159         functionExecutable-&gt;setSourceMappingURLDirective(source.provider()-&gt;sourceMappingURLDirective());
160 
161     if (Options::useCodeCache())
162         m_sourceCode.addCache(key, SourceCodeValue(vm, functionExecutable, m_sourceCode.age()));
163     return functionExecutable;
164 }
165 
166 void CodeCache::updateCache(const UnlinkedFunctionExecutable* executable, const SourceCode&amp; parentSource, CodeSpecializationKind kind, const UnlinkedFunctionCodeBlock* codeBlock)
167 {
168     parentSource.provider()-&gt;updateCache(executable, parentSource, kind, codeBlock);
169 }
170 
171 void CodeCache::write(VM&amp; vm)
172 {
173     for (auto&amp; it : m_sourceCode)
174         writeCodeBlock(vm, it.key, it.value);
175 }
176 
<span class="line-removed">177 void generateUnlinkedCodeBlockForFunctions(VM&amp; vm, UnlinkedCodeBlock* unlinkedCodeBlock, const SourceCode&amp; parentSource, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error)</span>
<span class="line-removed">178 {</span>
<span class="line-removed">179     auto generate = [&amp;](UnlinkedFunctionExecutable* unlinkedExecutable, CodeSpecializationKind constructorKind) {</span>
<span class="line-removed">180         if (constructorKind == CodeForConstruct &amp;&amp; SourceParseModeSet(SourceParseMode::AsyncArrowFunctionMode, SourceParseMode::AsyncMethodMode, SourceParseMode::AsyncFunctionMode).contains(unlinkedExecutable-&gt;parseMode()))</span>
<span class="line-removed">181             return;</span>
<span class="line-removed">182 </span>
<span class="line-removed">183         SourceCode source = unlinkedExecutable-&gt;linkedSourceCode(parentSource);</span>
<span class="line-removed">184         UnlinkedFunctionCodeBlock* unlinkedFunctionCodeBlock = unlinkedExecutable-&gt;unlinkedCodeBlockFor(vm, source, constructorKind, codeGenerationMode, error, unlinkedExecutable-&gt;parseMode());</span>
<span class="line-removed">185         if (unlinkedFunctionCodeBlock)</span>
<span class="line-removed">186             generateUnlinkedCodeBlockForFunctions(vm, unlinkedFunctionCodeBlock, source, codeGenerationMode, error);</span>
<span class="line-removed">187     };</span>
<span class="line-removed">188 </span>
<span class="line-removed">189     // FIXME: We should also generate CodeBlocks for CodeForConstruct</span>
<span class="line-removed">190     // https://bugs.webkit.org/show_bug.cgi?id=193823</span>
<span class="line-removed">191     for (unsigned i = 0; i &lt; unlinkedCodeBlock-&gt;numberOfFunctionDecls(); i++)</span>
<span class="line-removed">192         generate(unlinkedCodeBlock-&gt;functionDecl(i), CodeForCall);</span>
<span class="line-removed">193     for (unsigned i = 0; i &lt; unlinkedCodeBlock-&gt;numberOfFunctionExprs(); i++)</span>
<span class="line-removed">194         generate(unlinkedCodeBlock-&gt;functionExpr(i), CodeForCall);</span>
<span class="line-removed">195 }</span>
<span class="line-removed">196 </span>
197 void writeCodeBlock(VM&amp; vm, const SourceCodeKey&amp; key, const SourceCodeValue&amp; value)
198 {
199     UnlinkedCodeBlock* codeBlock = jsDynamicCast&lt;UnlinkedCodeBlock*&gt;(vm, value.cell.get());
200     if (!codeBlock)
201         return;
202 
203     key.source().provider().commitCachedBytecode();
204 }
205 
206 static SourceCodeKey sourceCodeKeyForSerializedBytecode(VM&amp;, const SourceCode&amp; sourceCode, SourceCodeType codeType, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode)
207 {
208     return SourceCodeKey(
209         sourceCode, String(), codeType, strictMode, scriptMode,
210         DerivedContextType::None, EvalContextType::None, false, codeGenerationMode,
211         WTF::nullopt);
212 }
213 
214 SourceCodeKey sourceCodeKeyForSerializedProgram(VM&amp; vm, const SourceCode&amp; sourceCode)
215 {
216     JSParserStrictMode strictMode = JSParserStrictMode::NotStrict;
</pre>
</td>
<td>
<hr />
<pre>
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;CodeCache.h&quot;
 28 
<span class="line-added"> 29 #include &quot;BytecodeGenerator.h&quot;</span>
 30 #include &quot;IndirectEvalExecutable.h&quot;
 31 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 32 
 33 namespace JSC {
 34 


 35 void CodeCacheMap::pruneSlowCase()
 36 {
 37     m_minCapacity = std::max(m_size - m_sizeAtLastPrune, static_cast&lt;int64_t&gt;(0));
 38     m_sizeAtLastPrune = m_size;
 39     m_timeAtLastPrune = MonotonicTime::now();
 40 
 41     if (m_capacity &lt; m_minCapacity)
 42         m_capacity = m_minCapacity;
 43 
 44     while (m_size &gt; m_capacity || !canPruneQuickly()) {
 45         MapType::iterator it = m_map.begin();
 46 
 47         writeCodeBlock(it-&gt;value.cell-&gt;vm(), it-&gt;key, it-&gt;value);
 48 
 49         m_size -= it-&gt;key.length();
 50         m_map.remove(it);
 51     }
 52 }
 53 
<span class="line-added"> 54 static void generateUnlinkedCodeBlockForFunctions(VM&amp; vm, UnlinkedCodeBlock* unlinkedCodeBlock, const SourceCode&amp; parentSource, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error)</span>
<span class="line-added"> 55 {</span>
<span class="line-added"> 56     auto generate = [&amp;](UnlinkedFunctionExecutable* unlinkedExecutable, CodeSpecializationKind constructorKind) {</span>
<span class="line-added"> 57         if (constructorKind == CodeForConstruct &amp;&amp; SourceParseModeSet(SourceParseMode::AsyncArrowFunctionMode, SourceParseMode::AsyncMethodMode, SourceParseMode::AsyncFunctionMode).contains(unlinkedExecutable-&gt;parseMode()))</span>
<span class="line-added"> 58             return;</span>
<span class="line-added"> 59 </span>
<span class="line-added"> 60         SourceCode source = unlinkedExecutable-&gt;linkedSourceCode(parentSource);</span>
<span class="line-added"> 61         UnlinkedFunctionCodeBlock* unlinkedFunctionCodeBlock = unlinkedExecutable-&gt;unlinkedCodeBlockFor(vm, source, constructorKind, codeGenerationMode, error, unlinkedExecutable-&gt;parseMode());</span>
<span class="line-added"> 62         if (unlinkedFunctionCodeBlock)</span>
<span class="line-added"> 63             generateUnlinkedCodeBlockForFunctions(vm, unlinkedFunctionCodeBlock, source, codeGenerationMode, error);</span>
<span class="line-added"> 64     };</span>
<span class="line-added"> 65 </span>
<span class="line-added"> 66     // FIXME: We should also generate CodeBlocks for CodeForConstruct</span>
<span class="line-added"> 67     // https://bugs.webkit.org/show_bug.cgi?id=193823</span>
<span class="line-added"> 68     for (unsigned i = 0; i &lt; unlinkedCodeBlock-&gt;numberOfFunctionDecls(); i++)</span>
<span class="line-added"> 69         generate(unlinkedCodeBlock-&gt;functionDecl(i), CodeForCall);</span>
<span class="line-added"> 70     for (unsigned i = 0; i &lt; unlinkedCodeBlock-&gt;numberOfFunctionExprs(); i++)</span>
<span class="line-added"> 71         generate(unlinkedCodeBlock-&gt;functionExpr(i), CodeForCall);</span>
<span class="line-added"> 72 }</span>
<span class="line-added"> 73 </span>
<span class="line-added"> 74 template &lt;class UnlinkedCodeBlockType, class ExecutableType = ScriptExecutable&gt;</span>
<span class="line-added"> 75 UnlinkedCodeBlockType* generateUnlinkedCodeBlockImpl(VM&amp; vm, const SourceCode&amp; source, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error, EvalContextType evalContextType, DerivedContextType derivedContextType, bool isArrowFunctionContext, const VariableEnvironment* variablesUnderTDZ, ExecutableType* executable = nullptr)</span>
<span class="line-added"> 76 {</span>
<span class="line-added"> 77     typedef typename CacheTypes&lt;UnlinkedCodeBlockType&gt;::RootNode RootNode;</span>
<span class="line-added"> 78     std::unique_ptr&lt;RootNode&gt; rootNode = parse&lt;RootNode&gt;(</span>
<span class="line-added"> 79         vm, source, Identifier(), JSParserBuiltinMode::NotBuiltin, strictMode, scriptMode, CacheTypes&lt;UnlinkedCodeBlockType&gt;::parseMode, SuperBinding::NotNeeded, error, nullptr, ConstructorKind::None, derivedContextType, evalContextType);</span>
<span class="line-added"> 80     if (!rootNode)</span>
<span class="line-added"> 81         return nullptr;</span>
<span class="line-added"> 82 </span>
<span class="line-added"> 83     unsigned lineCount = rootNode-&gt;lastLine() - rootNode-&gt;firstLine();</span>
<span class="line-added"> 84     unsigned startColumn = rootNode-&gt;startColumn() + 1;</span>
<span class="line-added"> 85     bool endColumnIsOnStartLine = !lineCount;</span>
<span class="line-added"> 86     unsigned unlinkedEndColumn = rootNode-&gt;endColumn();</span>
<span class="line-added"> 87     unsigned endColumn = unlinkedEndColumn + (endColumnIsOnStartLine ? startColumn : 1);</span>
<span class="line-added"> 88     unsigned arrowContextFeature = isArrowFunctionContext ? ArrowFunctionContextFeature : 0;</span>
<span class="line-added"> 89     if (executable)</span>
<span class="line-added"> 90         executable-&gt;recordParse(rootNode-&gt;features() | arrowContextFeature, rootNode-&gt;hasCapturedVariables(), rootNode-&gt;lastLine(), endColumn);</span>
<span class="line-added"> 91 </span>
<span class="line-added"> 92     bool usesEval = rootNode-&gt;features() &amp; EvalFeature;</span>
<span class="line-added"> 93     bool isStrictMode = rootNode-&gt;features() &amp; StrictModeFeature;</span>
<span class="line-added"> 94     NeedsClassFieldInitializer needsClassFieldInitializer = NeedsClassFieldInitializer::No;</span>
<span class="line-added"> 95     if constexpr (std::is_same_v&lt;ExecutableType, DirectEvalExecutable&gt;)</span>
<span class="line-added"> 96         needsClassFieldInitializer = executable-&gt;needsClassFieldInitializer();</span>
<span class="line-added"> 97     ExecutableInfo executableInfo(usesEval, isStrictMode, false, false, ConstructorKind::None, scriptMode, SuperBinding::NotNeeded, CacheTypes&lt;UnlinkedCodeBlockType&gt;::parseMode, derivedContextType, needsClassFieldInitializer, isArrowFunctionContext, false, evalContextType);</span>
<span class="line-added"> 98 </span>
<span class="line-added"> 99     UnlinkedCodeBlockType* unlinkedCodeBlock = UnlinkedCodeBlockType::create(vm, executableInfo, codeGenerationMode);</span>
<span class="line-added">100     unlinkedCodeBlock-&gt;recordParse(rootNode-&gt;features(), rootNode-&gt;hasCapturedVariables(), lineCount, unlinkedEndColumn);</span>
<span class="line-added">101     if (!source.provider()-&gt;sourceURLDirective().isNull())</span>
<span class="line-added">102         unlinkedCodeBlock-&gt;setSourceURLDirective(source.provider()-&gt;sourceURLDirective());</span>
<span class="line-added">103     if (!source.provider()-&gt;sourceMappingURLDirective().isNull())</span>
<span class="line-added">104         unlinkedCodeBlock-&gt;setSourceMappingURLDirective(source.provider()-&gt;sourceMappingURLDirective());</span>
<span class="line-added">105 </span>
<span class="line-added">106     error = BytecodeGenerator::generate(vm, rootNode.get(), source, unlinkedCodeBlock, codeGenerationMode, variablesUnderTDZ);</span>
<span class="line-added">107 </span>
<span class="line-added">108     if (error.isValid())</span>
<span class="line-added">109         return nullptr;</span>
<span class="line-added">110 </span>
<span class="line-added">111     return unlinkedCodeBlock;</span>
<span class="line-added">112 }</span>
<span class="line-added">113 </span>
<span class="line-added">114 template &lt;class UnlinkedCodeBlockType, class ExecutableType&gt;</span>
<span class="line-added">115 UnlinkedCodeBlockType* generateUnlinkedCodeBlock(VM&amp; vm, ExecutableType* executable, const SourceCode&amp; source, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error, EvalContextType evalContextType, const VariableEnvironment* variablesUnderTDZ)</span>
<span class="line-added">116 {</span>
<span class="line-added">117     return generateUnlinkedCodeBlockImpl&lt;UnlinkedCodeBlockType, ExecutableType&gt;(vm, source, strictMode, scriptMode, codeGenerationMode, error, evalContextType, executable-&gt;derivedContextType(), executable-&gt;isArrowFunctionContext(), variablesUnderTDZ, executable);</span>
<span class="line-added">118 }</span>
<span class="line-added">119 </span>
<span class="line-added">120 UnlinkedEvalCodeBlock* generateUnlinkedCodeBlockForDirectEval(VM&amp; vm, DirectEvalExecutable* executable, const SourceCode&amp; source, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error, EvalContextType evalContextType, const VariableEnvironment* variablesUnderTDZ)</span>
<span class="line-added">121 {</span>
<span class="line-added">122     return generateUnlinkedCodeBlock&lt;UnlinkedEvalCodeBlock&gt;(vm, executable, source, strictMode, scriptMode, codeGenerationMode, error, evalContextType, variablesUnderTDZ);</span>
<span class="line-added">123 }</span>
<span class="line-added">124 </span>
<span class="line-added">125 template &lt;class UnlinkedCodeBlockType&gt;</span>
<span class="line-added">126 std::enable_if_t&lt;!std::is_same&lt;UnlinkedCodeBlockType, UnlinkedEvalCodeBlock&gt;::value, UnlinkedCodeBlockType*&gt;</span>
<span class="line-added">127 recursivelyGenerateUnlinkedCodeBlock(VM&amp; vm, const SourceCode&amp; source, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error, EvalContextType evalContextType, const VariableEnvironment* variablesUnderTDZ)</span>
<span class="line-added">128 {</span>
<span class="line-added">129     bool isArrowFunctionContext = false;</span>
<span class="line-added">130     UnlinkedCodeBlockType* unlinkedCodeBlock = generateUnlinkedCodeBlockImpl&lt;UnlinkedCodeBlockType&gt;(vm, source, strictMode, scriptMode, codeGenerationMode, error, evalContextType, DerivedContextType::None, isArrowFunctionContext, variablesUnderTDZ);</span>
<span class="line-added">131     if (!unlinkedCodeBlock)</span>
<span class="line-added">132         return nullptr;</span>
<span class="line-added">133 </span>
<span class="line-added">134     generateUnlinkedCodeBlockForFunctions(vm, unlinkedCodeBlock, source, codeGenerationMode, error);</span>
<span class="line-added">135     return unlinkedCodeBlock;</span>
<span class="line-added">136 }</span>
<span class="line-added">137 </span>
<span class="line-added">138 UnlinkedProgramCodeBlock* recursivelyGenerateUnlinkedCodeBlockForProgram(VM&amp; vm, const SourceCode&amp; source, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error, EvalContextType evalContextType, const VariableEnvironment* variablesUnderTDZ)</span>
<span class="line-added">139 {</span>
<span class="line-added">140     return recursivelyGenerateUnlinkedCodeBlock&lt;UnlinkedProgramCodeBlock&gt;(vm, source, strictMode, scriptMode, codeGenerationMode, error, evalContextType, variablesUnderTDZ);</span>
<span class="line-added">141 }</span>
<span class="line-added">142 </span>
<span class="line-added">143 UnlinkedModuleProgramCodeBlock* recursivelyGenerateUnlinkedCodeBlockForModuleProgram(VM&amp; vm, const SourceCode&amp; source, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error, EvalContextType evalContextType, const VariableEnvironment* variablesUnderTDZ)</span>
<span class="line-added">144 {</span>
<span class="line-added">145     return recursivelyGenerateUnlinkedCodeBlock&lt;UnlinkedModuleProgramCodeBlock&gt;(vm, source, strictMode, scriptMode, codeGenerationMode, error, evalContextType, variablesUnderTDZ);</span>
<span class="line-added">146 }</span>
<span class="line-added">147 </span>
148 template &lt;class UnlinkedCodeBlockType, class ExecutableType&gt;
149 UnlinkedCodeBlockType* CodeCache::getUnlinkedGlobalCodeBlock(VM&amp; vm, ExecutableType* executable, const SourceCode&amp; source, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error, EvalContextType evalContextType)
150 {
151     DerivedContextType derivedContextType = executable-&gt;derivedContextType();
152     bool isArrowFunctionContext = executable-&gt;isArrowFunctionContext();
153     SourceCodeKey key(
154         source, String(), CacheTypes&lt;UnlinkedCodeBlockType&gt;::codeType, strictMode, scriptMode,
155         derivedContextType, evalContextType, isArrowFunctionContext, codeGenerationMode,
156         WTF::nullopt);
157     UnlinkedCodeBlockType* unlinkedCodeBlock = m_sourceCode.findCacheAndUpdateAge&lt;UnlinkedCodeBlockType&gt;(vm, key);
158     if (unlinkedCodeBlock &amp;&amp; Options::useCodeCache()) {
159         unsigned lineCount = unlinkedCodeBlock-&gt;lineCount();
160         unsigned startColumn = unlinkedCodeBlock-&gt;startColumn() + source.startColumn().oneBasedInt();
161         bool endColumnIsOnStartLine = !lineCount;
162         unsigned endColumn = unlinkedCodeBlock-&gt;endColumn() + (endColumnIsOnStartLine ? startColumn : 1);
163         executable-&gt;recordParse(unlinkedCodeBlock-&gt;codeFeatures(), unlinkedCodeBlock-&gt;hasCapturedVariables(), source.firstLine().oneBasedInt() + lineCount, endColumn);
<span class="line-modified">164         if (unlinkedCodeBlock-&gt;sourceURLDirective())</span>
165             source.provider()-&gt;setSourceURLDirective(unlinkedCodeBlock-&gt;sourceURLDirective());
<span class="line-modified">166         if (unlinkedCodeBlock-&gt;sourceMappingURLDirective())</span>
167             source.provider()-&gt;setSourceMappingURLDirective(unlinkedCodeBlock-&gt;sourceMappingURLDirective());
168         return unlinkedCodeBlock;
169     }
170 
171     VariableEnvironment variablesUnderTDZ;
172     unlinkedCodeBlock = generateUnlinkedCodeBlock&lt;UnlinkedCodeBlockType, ExecutableType&gt;(vm, executable, source, strictMode, scriptMode, codeGenerationMode, error, evalContextType, &amp;variablesUnderTDZ);
173 
174     if (unlinkedCodeBlock &amp;&amp; Options::useCodeCache()) {
175         m_sourceCode.addCache(key, SourceCodeValue(vm, unlinkedCodeBlock, m_sourceCode.age()));
176 
177         key.source().provider().cacheBytecode([&amp;] {
178             return encodeCodeBlock(vm, key, unlinkedCodeBlock);
179         });
180     }
181 
182     return unlinkedCodeBlock;
183 }
184 
185 UnlinkedProgramCodeBlock* CodeCache::getUnlinkedProgramCodeBlock(VM&amp; vm, ProgramExecutable* executable, const SourceCode&amp; source, JSParserStrictMode strictMode, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error)
186 {
</pre>
<hr />
<pre>
227 
228     // This function assumes an input string that would result in a single function declaration.
229     StatementNode* funcDecl = program-&gt;singleStatement();
230     if (UNLIKELY(!funcDecl)) {
231         JSToken token;
232         error = ParserError(ParserError::SyntaxError, ParserError::SyntaxErrorIrrecoverable, token, &quot;Parser error&quot;, -1);
233         return nullptr;
234     }
235     ASSERT(funcDecl-&gt;isFuncDeclNode());
236 
237     FunctionMetadataNode* metadata = static_cast&lt;FuncDeclNode*&gt;(funcDecl)-&gt;metadata();
238     ASSERT(metadata);
239     if (!metadata)
240         return nullptr;
241 
242     metadata-&gt;overrideName(name);
243     metadata-&gt;setEndPosition(positionBeforeLastNewline);
244     // The Function constructor only has access to global variables, so no variables will be under TDZ unless they&#39;re
245     // in the global lexical environment, which we always TDZ check accesses from.
246     ConstructAbility constructAbility = constructAbilityForParseMode(metadata-&gt;parseMode());
<span class="line-modified">247     UnlinkedFunctionExecutable* functionExecutable = UnlinkedFunctionExecutable::create(vm, source, metadata, UnlinkedNormalFunction, constructAbility, JSParserScriptMode::Classic, WTF::nullopt, DerivedContextType::None, NeedsClassFieldInitializer::No);</span>
248 
249     if (!source.provider()-&gt;sourceURLDirective().isNull())
250         functionExecutable-&gt;setSourceURLDirective(source.provider()-&gt;sourceURLDirective());
251     if (!source.provider()-&gt;sourceMappingURLDirective().isNull())
252         functionExecutable-&gt;setSourceMappingURLDirective(source.provider()-&gt;sourceMappingURLDirective());
253 
254     if (Options::useCodeCache())
255         m_sourceCode.addCache(key, SourceCodeValue(vm, functionExecutable, m_sourceCode.age()));
256     return functionExecutable;
257 }
258 
259 void CodeCache::updateCache(const UnlinkedFunctionExecutable* executable, const SourceCode&amp; parentSource, CodeSpecializationKind kind, const UnlinkedFunctionCodeBlock* codeBlock)
260 {
261     parentSource.provider()-&gt;updateCache(executable, parentSource, kind, codeBlock);
262 }
263 
264 void CodeCache::write(VM&amp; vm)
265 {
266     for (auto&amp; it : m_sourceCode)
267         writeCodeBlock(vm, it.key, it.value);
268 }
269 




















270 void writeCodeBlock(VM&amp; vm, const SourceCodeKey&amp; key, const SourceCodeValue&amp; value)
271 {
272     UnlinkedCodeBlock* codeBlock = jsDynamicCast&lt;UnlinkedCodeBlock*&gt;(vm, value.cell.get());
273     if (!codeBlock)
274         return;
275 
276     key.source().provider().commitCachedBytecode();
277 }
278 
279 static SourceCodeKey sourceCodeKeyForSerializedBytecode(VM&amp;, const SourceCode&amp; sourceCode, SourceCodeType codeType, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode)
280 {
281     return SourceCodeKey(
282         sourceCode, String(), codeType, strictMode, scriptMode,
283         DerivedContextType::None, EvalContextType::None, false, codeGenerationMode,
284         WTF::nullopt);
285 }
286 
287 SourceCodeKey sourceCodeKeyForSerializedProgram(VM&amp; vm, const SourceCode&amp; sourceCode)
288 {
289     JSParserStrictMode strictMode = JSParserStrictMode::NotStrict;
</pre>
</td>
</tr>
</table>
<center><a href="ClonedArguments.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CodeCache.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
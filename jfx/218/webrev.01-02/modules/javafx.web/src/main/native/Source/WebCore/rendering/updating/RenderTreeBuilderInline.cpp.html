<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilderInline.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderTreeBuilderInline.h&quot;
 28 
 29 #include &quot;FullscreenManager.h&quot;
 30 #include &quot;RenderBlockFlow.h&quot;
 31 #include &quot;RenderChildIterator.h&quot;
 32 #include &quot;RenderFullScreen.h&quot;
 33 #include &quot;RenderInline.h&quot;
 34 #include &quot;RenderTable.h&quot;
 35 #include &quot;RenderTreeBuilderMultiColumn.h&quot;
 36 #include &quot;RenderTreeBuilderTable.h&quot;
 37 
 38 namespace WebCore {
 39 
 40 static bool canUseAsParentForContinuation(const RenderObject* renderer)
 41 {
 42     if (!renderer)
 43         return false;
 44     if (!is&lt;RenderBlock&gt;(renderer) &amp;&amp; renderer-&gt;isAnonymous())
 45         return false;
 46     if (is&lt;RenderTable&gt;(renderer))
 47         return false;
 48     return true;
 49 }
 50 
 51 static RenderBoxModelObject* nextContinuation(RenderObject* renderer)
 52 {
 53     if (is&lt;RenderInline&gt;(*renderer) &amp;&amp; !renderer-&gt;isReplaced())
 54         return downcast&lt;RenderInline&gt;(*renderer).continuation();
 55     return downcast&lt;RenderBlock&gt;(*renderer).inlineContinuation();
 56 }
 57 
 58 static RenderBoxModelObject* continuationBefore(RenderInline&amp; parent, RenderObject* beforeChild)
 59 {
 60     if (beforeChild &amp;&amp; beforeChild-&gt;parent() == &amp;parent)
 61         return &amp;parent;
 62 
 63     RenderBoxModelObject* curr = nextContinuation(&amp;parent);
 64     RenderBoxModelObject* nextToLast = &amp;parent;
 65     RenderBoxModelObject* last = &amp;parent;
 66     while (curr) {
 67         if (beforeChild &amp;&amp; beforeChild-&gt;parent() == curr) {
 68             if (curr-&gt;firstChild() == beforeChild)
 69                 return last;
 70             return curr;
 71         }
 72 
 73         nextToLast = last;
 74         last = curr;
 75         curr = nextContinuation(curr);
 76     }
 77 
 78     if (!beforeChild &amp;&amp; !last-&gt;firstChild())
 79         return nextToLast;
 80     return last;
 81 }
 82 
 83 static RenderPtr&lt;RenderInline&gt; cloneAsContinuation(RenderInline&amp; renderer)
 84 {
 85     RenderPtr&lt;RenderInline&gt; cloneInline = createRenderer&lt;RenderInline&gt;(*renderer.element(), RenderStyle::clone(renderer.style()));
 86     cloneInline-&gt;initializeStyle();
 87     cloneInline-&gt;setFragmentedFlowState(renderer.fragmentedFlowState());
 88     cloneInline-&gt;setHasOutlineAutoAncestor(renderer.hasOutlineAutoAncestor());
 89     cloneInline-&gt;setIsContinuation();
 90     return cloneInline;
 91 }
 92 
 93 static RenderElement* inFlowPositionedInlineAncestor(RenderElement&amp; renderer)
 94 {
 95     auto* ancestor = &amp;renderer;
 96     while (ancestor &amp;&amp; ancestor-&gt;isRenderInline()) {
 97         if (ancestor-&gt;isInFlowPositioned())
 98             return ancestor;
 99         ancestor = ancestor-&gt;parent();
100     }
101     return nullptr;
102 }
103 
104 RenderTreeBuilder::Inline::Inline(RenderTreeBuilder&amp; builder)
105     : m_builder(builder)
106 {
107 }
108 
109 void RenderTreeBuilder::Inline::attach(RenderInline&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
110 {
111     auto* beforeChildOrPlaceholder = beforeChild;
112     if (auto* fragmentedFlow = parent.enclosingFragmentedFlow())
113         beforeChildOrPlaceholder = m_builder.multiColumnBuilder().resolveMovedChild(*fragmentedFlow, beforeChild);
114     if (parent.continuation()) {
115         insertChildToContinuation(parent, WTFMove(child), beforeChildOrPlaceholder);
116         return;
117     }
118     attachIgnoringContinuation(parent, WTFMove(child), beforeChildOrPlaceholder);
119 }
120 
121 void RenderTreeBuilder::Inline::insertChildToContinuation(RenderInline&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
122 {
123     auto* flow = continuationBefore(parent, beforeChild);
124     // It may or may not be the direct parent of the beforeChild.
125     RenderBoxModelObject* beforeChildAncestor = nullptr;
126     if (!beforeChild) {
127         auto* continuation = nextContinuation(flow);
128         beforeChildAncestor = continuation ? continuation : flow;
129     } else if (canUseAsParentForContinuation(beforeChild-&gt;parent()))
130         beforeChildAncestor = downcast&lt;RenderBoxModelObject&gt;(beforeChild-&gt;parent());
131     else if (beforeChild-&gt;parent()) {
132         // In case of anonymous wrappers, the parent of the beforeChild is mostly irrelevant. What we need is the topmost wrapper.
133         auto* parent = beforeChild-&gt;parent();
134         while (parent &amp;&amp; parent-&gt;parent() &amp;&amp; parent-&gt;parent()-&gt;isAnonymous()) {
135             // The ancestor candidate needs to be inside the continuation.
136             if (parent-&gt;isContinuation())
137                 break;
138             parent = parent-&gt;parent();
139         }
140         ASSERT(parent &amp;&amp; parent-&gt;parent());
141         beforeChildAncestor = downcast&lt;RenderBoxModelObject&gt;(parent-&gt;parent());
142     } else
143         ASSERT_NOT_REACHED();
144 
145     if (child-&gt;isFloatingOrOutOfFlowPositioned())
146         return m_builder.attachIgnoringContinuation(*beforeChildAncestor, WTFMove(child), beforeChild);
147 
148     if (flow == beforeChildAncestor)
149         return m_builder.attachIgnoringContinuation(*flow, WTFMove(child), beforeChild);
150     // A continuation always consists of two potential candidates: an inline or an anonymous
151     // block box holding block children.
152     bool childInline = newChildIsInline(parent, *child);
153     // The goal here is to match up if we can, so that we can coalesce and create the
154     // minimal # of continuations needed for the inline.
155     if (childInline == beforeChildAncestor-&gt;isInline())
156         return m_builder.attachIgnoringContinuation(*beforeChildAncestor, WTFMove(child), beforeChild);
157     if (flow-&gt;isInline() == childInline)
158         return m_builder.attachIgnoringContinuation(*flow, WTFMove(child)); // Just treat like an append.
159     return m_builder.attachIgnoringContinuation(*beforeChildAncestor, WTFMove(child), beforeChild);
160 }
161 
162 void RenderTreeBuilder::Inline::attachIgnoringContinuation(RenderInline&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
163 {
164     // Make sure we don&#39;t append things after :after-generated content if we have it.
165     if (!beforeChild &amp;&amp; parent.isAfterContent(parent.lastChild()))
166         beforeChild = parent.lastChild();
167 
168     bool childInline = newChildIsInline(parent, *child);
169     // This code is for the old block-inside-inline model that uses continuations.
170     if (!childInline &amp;&amp; !child-&gt;isFloatingOrOutOfFlowPositioned()) {
171         // We are placing a block inside an inline. We have to perform a split of this
172         // inline into continuations. This involves creating an anonymous block box to hold
173         // |newChild|. We then make that block box a continuation of this inline. We take all of
174         // the children after |beforeChild| and put them in a clone of this object.
175         auto newStyle = RenderStyle::createAnonymousStyleWithDisplay(parent.style(), DisplayType::Block);
176 
177         // If inside an inline affected by in-flow positioning the block needs to be affected by it too.
178         // Giving the block a layer like this allows it to collect the x/y offsets from inline parents later.
179         if (auto positionedAncestor = inFlowPositionedInlineAncestor(parent))
180             newStyle.setPosition(positionedAncestor-&gt;style().position());
181 
182         auto newBox = createRenderer&lt;RenderBlockFlow&gt;(parent.document(), WTFMove(newStyle));
183         newBox-&gt;initializeStyle();
184         newBox-&gt;setIsContinuation();
185         RenderBoxModelObject* oldContinuation = parent.continuation();
186         if (oldContinuation)
187             oldContinuation-&gt;removeFromContinuationChain();
188         newBox-&gt;insertIntoContinuationChainAfter(parent);
189 
190         splitFlow(parent, beforeChild, WTFMove(newBox), WTFMove(child), oldContinuation);
191         return;
192     }
193 
194     auto&amp; childToAdd = *child;
195     m_builder.attachToRenderElement(parent, WTFMove(child), beforeChild);
196     childToAdd.setNeedsLayoutAndPrefWidthsRecalc();
197 }
198 
199 void RenderTreeBuilder::Inline::splitFlow(RenderInline&amp; parent, RenderObject* beforeChild, RenderPtr&lt;RenderBlock&gt; newBlockBox, RenderPtr&lt;RenderObject&gt; child, RenderBoxModelObject* oldCont)
200 {
201     auto&amp; addedBlockBox = *newBlockBox;
202     RenderBlock* pre = nullptr;
203     RenderBlock* block = parent.containingBlock();
204 
205     // Delete our line boxes before we do the inline split into continuations.
206     block-&gt;deleteLines();
207 
208     RenderPtr&lt;RenderBlock&gt; createdPre;
209     bool madeNewBeforeBlock = false;
210     if (block-&gt;isAnonymousBlock() &amp;&amp; (!block-&gt;parent() || !block-&gt;parent()-&gt;createsAnonymousWrapper())) {
211         // We can reuse this block and make it the preBlock of the next continuation.
212         pre = block;
213         pre-&gt;removePositionedObjects(nullptr);
214         // FIXME-BLOCKFLOW: The enclosing method should likely be switched over
215         // to only work on RenderBlockFlow, in which case this conversion can be
216         // removed.
217         if (is&lt;RenderBlockFlow&gt;(*pre))
218             downcast&lt;RenderBlockFlow&gt;(*pre).removeFloatingObjects();
219         block = block-&gt;containingBlock();
220     } else {
221         // No anonymous block available for use. Make one.
222         createdPre = block-&gt;createAnonymousBlock();
223         pre = createdPre.get();
224         madeNewBeforeBlock = true;
225     }
226 
227     auto createdPost = pre-&gt;createAnonymousBoxWithSameTypeAs(*block);
228     auto&amp; post = downcast&lt;RenderBlock&gt;(*createdPost);
229 
230     RenderObject* boxFirst = madeNewBeforeBlock ? block-&gt;firstChild() : pre-&gt;nextSibling();
231     if (createdPre)
232         m_builder.attachToRenderElementInternal(*block, WTFMove(createdPre), boxFirst);
233     m_builder.attachToRenderElementInternal(*block, WTFMove(newBlockBox), boxFirst);
234     m_builder.attachToRenderElementInternal(*block, WTFMove(createdPost), boxFirst);
235     block-&gt;setChildrenInline(false);
236 
237     if (madeNewBeforeBlock) {
238         RenderObject* o = boxFirst;
239         while (o) {
240             RenderObject* no = o;
241             o = no-&gt;nextSibling();
242             auto childToMove = m_builder.detachFromRenderElement(*block, *no);
243             m_builder.attachToRenderElementInternal(*pre, WTFMove(childToMove));
244             no-&gt;setNeedsLayoutAndPrefWidthsRecalc();
245         }
246     }
247 
248     splitInlines(parent, pre, &amp;post, &amp;addedBlockBox, beforeChild, oldCont);
249 
250     // We already know the newBlockBox isn&#39;t going to contain inline kids, so avoid wasting
251     // time in makeChildrenNonInline by just setting this explicitly up front.
252     addedBlockBox.setChildrenInline(false);
253 
254     // We delayed adding the newChild until now so that the |newBlockBox| would be fully
255     // connected, thus allowing newChild access to a renderArena should it need
256     // to wrap itself in additional boxes (e.g., table construction).
257     m_builder.attach(addedBlockBox, WTFMove(child));
258 
259     // Always just do a full layout in order to ensure that line boxes (especially wrappers for images)
260     // get deleted properly. Because objects moves from the pre block into the post block, we want to
261     // make new line boxes instead of leaving the old line boxes around.
262     pre-&gt;setNeedsLayoutAndPrefWidthsRecalc();
263     block-&gt;setNeedsLayoutAndPrefWidthsRecalc();
264     post.setNeedsLayoutAndPrefWidthsRecalc();
265 }
266 
267 void RenderTreeBuilder::Inline::splitInlines(RenderInline&amp; parent, RenderBlock* fromBlock, RenderBlock* toBlock, RenderBlock* middleBlock, RenderObject* beforeChild, RenderBoxModelObject* oldCont)
268 {
269     // Create a clone of this inline.
270     RenderPtr&lt;RenderInline&gt; cloneInline = cloneAsContinuation(parent);
271 #if ENABLE(FULLSCREEN_API)
272     // If we&#39;re splitting the inline containing the fullscreened element,
273     // |beforeChild| may be the renderer for the fullscreened element. However,
274     // that renderer is wrapped in a RenderFullScreen, so |this| is not its
275     // parent. Since the splitting logic expects |this| to be the parent, set
276     // |beforeChild| to be the RenderFullScreen.
277     const Element* fullScreenElement = parent.document().fullscreenManager().currentFullscreenElement();
278     if (fullScreenElement &amp;&amp; beforeChild &amp;&amp; beforeChild-&gt;node() == fullScreenElement)
279         beforeChild = parent.document().fullscreenManager().fullscreenRenderer();
280 #endif
281     // Now take all of the children from beforeChild to the end and remove
282     // them from |this| and place them in the clone.
283     for (RenderObject* rendererToMove = beforeChild; rendererToMove;) {
284         RenderObject* nextSibling = rendererToMove-&gt;nextSibling();
285         // When anonymous wrapper is present, we might need to move the whole subtree instead.
286         if (rendererToMove-&gt;parent() != &amp;parent) {
287             auto* anonymousParent = rendererToMove-&gt;parent();
288             while (anonymousParent &amp;&amp; anonymousParent-&gt;parent() != &amp;parent) {
289                 ASSERT(anonymousParent-&gt;isAnonymous());
290                 anonymousParent = anonymousParent-&gt;parent();
291             }
292             if (!anonymousParent) {
293                 ASSERT_NOT_REACHED();
294                 break;
295             }
296             // If beforeChild is the first child in the subtree, we could just move the whole subtree.
297             if (!rendererToMove-&gt;previousSibling()) {
298                 // Reparent the whole anonymous wrapper tree.
299                 rendererToMove = anonymousParent;
300                 // Skip to the next sibling that is not in this subtree.
301                 nextSibling = anonymousParent-&gt;nextSibling();
302             } else if (!rendererToMove-&gt;nextSibling()) {
303                 // This is the last renderer in the subtree. We need to jump out of the wrapper subtree, so that
304                 // the siblings are getting reparented too.
305                 nextSibling = anonymousParent-&gt;nextSibling();
306             }
307             // Otherwise just move the renderer to the inline clone. Should the renderer need an anon
308             // wrapper, the addChild() will generate one for it.
309             // FIXME: When the anonymous wrapper has multiple children, we end up traversing up to the topmost wrapper
310             // every time, which is a bit wasteful.
311         }
312         auto childToMove = m_builder.detachFromRenderElement(*rendererToMove-&gt;parent(), *rendererToMove);
313         m_builder.attachIgnoringContinuation(*cloneInline, WTFMove(childToMove));
314         rendererToMove-&gt;setNeedsLayoutAndPrefWidthsRecalc();
315         rendererToMove = nextSibling;
316     }
317     // Hook |clone| up as the continuation of the middle block.
318     cloneInline-&gt;insertIntoContinuationChainAfter(*middleBlock);
319     if (oldCont)
320         oldCont-&gt;insertIntoContinuationChainAfter(*cloneInline);
321 
322     // We have been reparented and are now under the fromBlock. We need
323     // to walk up our inline parent chain until we hit the containing block.
324     // Once we hit the containing block we&#39;re done.
325     RenderBoxModelObject* current = downcast&lt;RenderBoxModelObject&gt;(parent.parent());
326     RenderBoxModelObject* currentChild = &amp;parent;
327 
328     // FIXME: Because splitting is O(n^2) as tags nest pathologically, we cap the depth at which we&#39;re willing to clone.
329     // There will eventually be a better approach to this problem that will let us nest to a much
330     // greater depth (see bugzilla bug 13430) but for now we have a limit. This *will* result in
331     // incorrect rendering, but the alternative is to hang forever.
332     unsigned splitDepth = 1;
333     const unsigned cMaxSplitDepth = 200;
334     while (current &amp;&amp; current != fromBlock) {
335         if (splitDepth &lt; cMaxSplitDepth) {
336             // Create a new clone.
337             RenderPtr&lt;RenderInline&gt; cloneChild = WTFMove(cloneInline);
338             cloneInline = cloneAsContinuation(downcast&lt;RenderInline&gt;(*current));
339 
340             // Insert our child clone as the first child.
341             m_builder.attachIgnoringContinuation(*cloneInline, WTFMove(cloneChild));
342 
343             // Hook the clone up as a continuation of |curr|.
344             cloneInline-&gt;insertIntoContinuationChainAfter(*current);
345 
346             // Now we need to take all of the children starting from the first child
347             // *after* currentChild and append them all to the clone.
348             for (auto* sibling = currentChild-&gt;nextSibling(); sibling;) {
349                 auto* next = sibling-&gt;nextSibling();
350                 auto childToMove = m_builder.detachFromRenderElement(*current, *sibling);
351                 m_builder.attachIgnoringContinuation(*cloneInline, WTFMove(childToMove));
352                 sibling-&gt;setNeedsLayoutAndPrefWidthsRecalc();
353                 sibling = next;
354             }
355         }
356 
357         // Keep walking up the chain.
358         currentChild = current;
359         current = downcast&lt;RenderBoxModelObject&gt;(current-&gt;parent());
360         ++splitDepth;
361     }
362 
363     // Clear the flow thread containing blocks cached during the detached state insertions.
364     for (auto&amp; cloneBlockChild : childrenOfType&lt;RenderBlock&gt;(*cloneInline))
365         cloneBlockChild.resetEnclosingFragmentedFlowAndChildInfoIncludingDescendants();
366 
367     // Now we are at the block level. We need to put the clone into the toBlock.
368     m_builder.attachToRenderElementInternal(*toBlock, WTFMove(cloneInline));
369 
370     // Now take all the children after currentChild and remove them from the fromBlock
371     // and put them in the toBlock.
372     for (auto* current = currentChild-&gt;nextSibling(); current;) {
373         auto* next = current-&gt;nextSibling();
374         auto childToMove = m_builder.detachFromRenderElement(*fromBlock, *current);
375         m_builder.attachToRenderElementInternal(*toBlock, WTFMove(childToMove));
376         current = next;
377     }
378 }
379 
380 bool RenderTreeBuilder::Inline::newChildIsInline(const RenderInline&amp; parent, const RenderObject&amp; child)
381 {
382     // inline parent generates inline-table.
383     return child.isInline() || (m_builder.tableBuilder().childRequiresTable(parent, child) &amp;&amp; parent.style().display() == DisplayType::Inline);
384 }
385 
386 void RenderTreeBuilder::Inline::childBecameNonInline(RenderInline&amp; parent, RenderElement&amp; child)
387 {
388     // We have to split the parent flow.
389     auto newBox = parent.containingBlock()-&gt;createAnonymousBlock();
390     newBox-&gt;setIsContinuation();
391     auto* oldContinuation = parent.continuation();
392     if (oldContinuation)
393         oldContinuation-&gt;removeFromContinuationChain();
394     newBox-&gt;insertIntoContinuationChainAfter(parent);
395     auto* beforeChild = child.nextSibling();
396     auto removedChild = m_builder.detachFromRenderElement(parent, child);
397     splitFlow(parent, beforeChild, WTFMove(newBox), WTFMove(removedChild), oldContinuation);
398 }
399 
400 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/PromiseConstructor.js</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ObjectConstructor.js.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PromiseOperations.js.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/PromiseConstructor.js</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 function all(iterable)
 27 {
 28     &quot;use strict&quot;;
 29 
 30     if (!@isObject(this))
 31         @throwTypeError(&quot;|this| is not an object&quot;);
 32 
 33     var promiseCapability = @newPromiseCapability(this);
 34 
 35     var values = [];
 36     var index = 0;
 37     var remainingElementsCount = 1;
 38 
 39     function newResolveElement(index)
 40     {
 41         var alreadyCalled = false;
<span class="line-modified"> 42         return function @resolve(argument)</span>
 43         {
 44             if (alreadyCalled)
 45                 return @undefined;
 46             alreadyCalled = true;
 47 
 48             @putByValDirect(values, index, argument);
 49 
 50             --remainingElementsCount;
 51             if (remainingElementsCount === 0)
 52                 return promiseCapability.@resolve.@call(@undefined, values);
 53 
 54             return @undefined;
 55         }
 56     }
 57 
 58     try {
 59         var promiseResolve = this.resolve;
 60         if (typeof promiseResolve !== &quot;function&quot;)
 61             @throwTypeError(&quot;Promise resolve is not a function&quot;);
 62 
</pre>
<hr />
<pre>
 79     return promiseCapability.@promise;
 80 }
 81 
 82 function allSettled(iterable)
 83 {
 84     &quot;use strict&quot;;
 85 
 86     if (!@isObject(this))
 87         @throwTypeError(&quot;|this| is not an object&quot;);
 88 
 89     var promiseCapability = @newPromiseCapability(this);
 90 
 91     var values = [];
 92     var remainingElementsCount = 1;
 93     var index = 0;
 94 
 95     function newResolveRejectElements(index)
 96     {
 97         var alreadyCalled = false;
 98 
<span class="line-modified"> 99         var resolveElement = function @resolve(x)</span>
<span class="line-modified">100         {</span>
<span class="line-modified">101             if (alreadyCalled)</span>
<span class="line-modified">102                 return @undefined;</span>
<span class="line-modified">103             alreadyCalled = true;</span>
<span class="line-removed">104 </span>
<span class="line-removed">105             var obj = {</span>
<span class="line-removed">106                 status: &quot;fulfilled&quot;,</span>
<span class="line-removed">107                 value: x</span>
<span class="line-removed">108             };</span>
109 
<span class="line-modified">110             @putByValDirect(values, index, obj);</span>



111 
<span class="line-modified">112             --remainingElementsCount;</span>
<span class="line-removed">113             if (remainingElementsCount === 0)</span>
<span class="line-removed">114                 return promiseCapability.@resolve.@call(@undefined, values);</span>
115 
<span class="line-modified">116             return @undefined;</span>
<span class="line-modified">117         };</span>

118 
<span class="line-removed">119         var rejectElement = function @reject(x)</span>
<span class="line-removed">120         {</span>
<span class="line-removed">121             if (alreadyCalled)</span>
122                 return @undefined;
<span class="line-modified">123             alreadyCalled = true;</span>
124 
<span class="line-modified">125             var obj = {</span>
<span class="line-modified">126                 status: &quot;rejected&quot;,</span>
<span class="line-modified">127                 reason: x</span>
<span class="line-modified">128             };</span>
129 
<span class="line-modified">130             @putByValDirect(values, index, obj);</span>



131 
<span class="line-modified">132             --remainingElementsCount;</span>
<span class="line-removed">133             if (remainingElementsCount === 0)</span>
<span class="line-removed">134                 return promiseCapability.@resolve.@call(@undefined, values);</span>
135 
<span class="line-modified">136             return @undefined;</span>
<span class="line-modified">137         };</span>

138 
<span class="line-modified">139         return [resolveElement, rejectElement];</span>


140     }
141 
142     try {
143         var promiseResolve = this.resolve;
144         if (typeof promiseResolve !== &quot;function&quot;)
145             @throwTypeError(&quot;Promise resolve is not a function&quot;);
146 
147         for (var value of iterable) {
148             @putByValDirect(values, index, @undefined);
149             var nextPromise = promiseResolve.@call(this, value);
150             var [resolveElement, rejectElement] = newResolveRejectElements(index);
151             ++remainingElementsCount;
152             nextPromise.then(resolveElement, rejectElement);
153             ++index;
154         }
155 
156         --remainingElementsCount;
157         if (remainingElementsCount === 0)
158             promiseCapability.@resolve.@call(@undefined, values);
159     } catch (error) {
</pre>
<hr />
<pre>
178             @throwTypeError(&quot;Promise resolve is not a function&quot;);
179 
180         for (var value of iterable) {
181             var nextPromise = promiseResolve.@call(this, value);
182             nextPromise.then(promiseCapability.@resolve, promiseCapability.@reject);
183         }
184     } catch (error) {
185         promiseCapability.@reject.@call(@undefined, error);
186     }
187 
188     return promiseCapability.@promise;
189 }
190 
191 function reject(reason)
192 {
193     &quot;use strict&quot;;
194 
195     if (!@isObject(this))
196         @throwTypeError(&quot;|this| is not an object&quot;);
197 
<span class="line-modified">198     var promiseCapability = @newPromiseCapability(this);</span>
<span class="line-modified">199 </span>
<span class="line-modified">200     promiseCapability.@reject.@call(@undefined, reason);</span>


201 
<span class="line-modified">202     return promiseCapability.@promise;</span>
203 }
204 
205 function resolve(value)
206 {
207     &quot;use strict&quot;;
208 
209     if (!@isObject(this))
210         @throwTypeError(&quot;|this| is not an object&quot;);
211 
212     if (@isPromise(value)) {
213         var valueConstructor = value.constructor;
214         if (valueConstructor === this)
215             return value;
216     }
217 
<span class="line-modified">218     var promiseCapability = @newPromiseCapability(this);</span>




219 
<span class="line-modified">220     promiseCapability.@resolve.@call(@undefined, value);</span>

221 
<span class="line-modified">222     return promiseCapability.@promise;</span>

















































223 }
</pre>
</td>
<td>
<hr />
<pre>
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 function all(iterable)
 27 {
 28     &quot;use strict&quot;;
 29 
 30     if (!@isObject(this))
 31         @throwTypeError(&quot;|this| is not an object&quot;);
 32 
 33     var promiseCapability = @newPromiseCapability(this);
 34 
 35     var values = [];
 36     var index = 0;
 37     var remainingElementsCount = 1;
 38 
 39     function newResolveElement(index)
 40     {
 41         var alreadyCalled = false;
<span class="line-modified"> 42         return function (argument)</span>
 43         {
 44             if (alreadyCalled)
 45                 return @undefined;
 46             alreadyCalled = true;
 47 
 48             @putByValDirect(values, index, argument);
 49 
 50             --remainingElementsCount;
 51             if (remainingElementsCount === 0)
 52                 return promiseCapability.@resolve.@call(@undefined, values);
 53 
 54             return @undefined;
 55         }
 56     }
 57 
 58     try {
 59         var promiseResolve = this.resolve;
 60         if (typeof promiseResolve !== &quot;function&quot;)
 61             @throwTypeError(&quot;Promise resolve is not a function&quot;);
 62 
</pre>
<hr />
<pre>
 79     return promiseCapability.@promise;
 80 }
 81 
 82 function allSettled(iterable)
 83 {
 84     &quot;use strict&quot;;
 85 
 86     if (!@isObject(this))
 87         @throwTypeError(&quot;|this| is not an object&quot;);
 88 
 89     var promiseCapability = @newPromiseCapability(this);
 90 
 91     var values = [];
 92     var remainingElementsCount = 1;
 93     var index = 0;
 94 
 95     function newResolveRejectElements(index)
 96     {
 97         var alreadyCalled = false;
 98 
<span class="line-modified"> 99         return [</span>
<span class="line-modified">100             function (value) {</span>
<span class="line-modified">101                 if (alreadyCalled)</span>
<span class="line-modified">102                     return @undefined;</span>
<span class="line-modified">103                 alreadyCalled = true;</span>





104 
<span class="line-modified">105                 var obj = {</span>
<span class="line-added">106                     status: &quot;fulfilled&quot;,</span>
<span class="line-added">107                     value</span>
<span class="line-added">108                 };</span>
109 
<span class="line-modified">110                 @putByValDirect(values, index, obj);</span>


111 
<span class="line-modified">112                 --remainingElementsCount;</span>
<span class="line-modified">113                 if (remainingElementsCount === 0)</span>
<span class="line-added">114                     return promiseCapability.@resolve.@call(@undefined, values);</span>
115 



116                 return @undefined;
<span class="line-modified">117             },</span>
118 
<span class="line-modified">119             function (reason) {</span>
<span class="line-modified">120                 if (alreadyCalled)</span>
<span class="line-modified">121                     return @undefined;</span>
<span class="line-modified">122                 alreadyCalled = true;</span>
123 
<span class="line-modified">124                 var obj = {</span>
<span class="line-added">125                     status: &quot;rejected&quot;,</span>
<span class="line-added">126                     reason</span>
<span class="line-added">127                 };</span>
128 
<span class="line-modified">129                 @putByValDirect(values, index, obj);</span>


130 
<span class="line-modified">131                 --remainingElementsCount;</span>
<span class="line-modified">132                 if (remainingElementsCount === 0)</span>
<span class="line-added">133                     return promiseCapability.@resolve.@call(@undefined, values);</span>
134 
<span class="line-modified">135                 return @undefined;</span>
<span class="line-added">136             }</span>
<span class="line-added">137         ];</span>
138     }
139 
140     try {
141         var promiseResolve = this.resolve;
142         if (typeof promiseResolve !== &quot;function&quot;)
143             @throwTypeError(&quot;Promise resolve is not a function&quot;);
144 
145         for (var value of iterable) {
146             @putByValDirect(values, index, @undefined);
147             var nextPromise = promiseResolve.@call(this, value);
148             var [resolveElement, rejectElement] = newResolveRejectElements(index);
149             ++remainingElementsCount;
150             nextPromise.then(resolveElement, rejectElement);
151             ++index;
152         }
153 
154         --remainingElementsCount;
155         if (remainingElementsCount === 0)
156             promiseCapability.@resolve.@call(@undefined, values);
157     } catch (error) {
</pre>
<hr />
<pre>
176             @throwTypeError(&quot;Promise resolve is not a function&quot;);
177 
178         for (var value of iterable) {
179             var nextPromise = promiseResolve.@call(this, value);
180             nextPromise.then(promiseCapability.@resolve, promiseCapability.@reject);
181         }
182     } catch (error) {
183         promiseCapability.@reject.@call(@undefined, error);
184     }
185 
186     return promiseCapability.@promise;
187 }
188 
189 function reject(reason)
190 {
191     &quot;use strict&quot;;
192 
193     if (!@isObject(this))
194         @throwTypeError(&quot;|this| is not an object&quot;);
195 
<span class="line-modified">196     if (this === @Promise) {</span>
<span class="line-modified">197         var promise = @newPromise();</span>
<span class="line-modified">198         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, reason);</span>
<span class="line-added">199         return promise;</span>
<span class="line-added">200     }</span>
201 
<span class="line-modified">202     return @promiseRejectSlow(this, reason);</span>
203 }
204 
205 function resolve(value)
206 {
207     &quot;use strict&quot;;
208 
209     if (!@isObject(this))
210         @throwTypeError(&quot;|this| is not an object&quot;);
211 
212     if (@isPromise(value)) {
213         var valueConstructor = value.constructor;
214         if (valueConstructor === this)
215             return value;
216     }
217 
<span class="line-modified">218     if (this === @Promise) {</span>
<span class="line-added">219         var promise = @newPromise();</span>
<span class="line-added">220         @resolvePromiseWithFirstResolvingFunctionCallCheck(promise, value);</span>
<span class="line-added">221         return promise;</span>
<span class="line-added">222     }</span>
223 
<span class="line-modified">224     return @promiseResolveSlow(this, value);</span>
<span class="line-added">225 }</span>
226 
<span class="line-modified">227 @nakedConstructor</span>
<span class="line-added">228 function Promise(executor)</span>
<span class="line-added">229 {</span>
<span class="line-added">230     &quot;use strict&quot;;</span>
<span class="line-added">231 </span>
<span class="line-added">232     if (typeof executor !== &quot;function&quot;)</span>
<span class="line-added">233         @throwTypeError(&quot;Promise constructor takes a function argument&quot;);</span>
<span class="line-added">234 </span>
<span class="line-added">235     var promise = @createPromise(this, /* isInternalPromise */ false);</span>
<span class="line-added">236     var capturedPromise = promise;</span>
<span class="line-added">237 </span>
<span class="line-added">238     try {</span>
<span class="line-added">239         executor(</span>
<span class="line-added">240             function (resolution) {</span>
<span class="line-added">241                 return @resolvePromiseWithFirstResolvingFunctionCallCheck(capturedPromise, resolution);</span>
<span class="line-added">242             },</span>
<span class="line-added">243             function (reason) {</span>
<span class="line-added">244                 return @rejectPromiseWithFirstResolvingFunctionCallCheck(capturedPromise, reason);</span>
<span class="line-added">245             });</span>
<span class="line-added">246     } catch (error) {</span>
<span class="line-added">247         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, error);</span>
<span class="line-added">248     }</span>
<span class="line-added">249 </span>
<span class="line-added">250     return promise;</span>
<span class="line-added">251 }</span>
<span class="line-added">252 </span>
<span class="line-added">253 @nakedConstructor</span>
<span class="line-added">254 function InternalPromise(executor)</span>
<span class="line-added">255 {</span>
<span class="line-added">256     &quot;use strict&quot;;</span>
<span class="line-added">257 </span>
<span class="line-added">258     if (typeof executor !== &quot;function&quot;)</span>
<span class="line-added">259         @throwTypeError(&quot;InternalPromise constructor takes a function argument&quot;);</span>
<span class="line-added">260 </span>
<span class="line-added">261     var promise = @createPromise(this, /* isInternalPromise */ true);</span>
<span class="line-added">262     var capturedPromise = promise;</span>
<span class="line-added">263 </span>
<span class="line-added">264     try {</span>
<span class="line-added">265         executor(</span>
<span class="line-added">266             function (resolution) {</span>
<span class="line-added">267                 return @resolvePromiseWithFirstResolvingFunctionCallCheck(capturedPromise, resolution);</span>
<span class="line-added">268             },</span>
<span class="line-added">269             function (reason) {</span>
<span class="line-added">270                 return @rejectPromiseWithFirstResolvingFunctionCallCheck(capturedPromise, reason);</span>
<span class="line-added">271             });</span>
<span class="line-added">272     } catch (error) {</span>
<span class="line-added">273         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, error);</span>
<span class="line-added">274     }</span>
<span class="line-added">275 </span>
<span class="line-added">276     return promise;</span>
277 }
</pre>
</td>
</tr>
</table>
<center><a href="ObjectConstructor.js.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PromiseOperations.js.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
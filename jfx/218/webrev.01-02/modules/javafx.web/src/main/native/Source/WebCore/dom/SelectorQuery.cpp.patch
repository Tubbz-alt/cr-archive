diff a/modules/javafx.web/src/main/native/Source/WebCore/dom/SelectorQuery.cpp b/modules/javafx.web/src/main/native/Source/WebCore/dom/SelectorQuery.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/dom/SelectorQuery.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/dom/SelectorQuery.cpp
@@ -34,21 +34,21 @@
 #include "StaticNodeList.h"
 #include "StyledElement.h"
 
 namespace WebCore {
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
 static bool isSingleTagNameSelector(const CSSSelector& selector)
 {
     return selector.isLastInTagHistory() && selector.match() == CSSSelector::Tag;
 }
 
 static bool isSingleClassNameSelector(const CSSSelector& selector)
 {
     return selector.isLastInTagHistory() && selector.match() == CSSSelector::Class;
 }
-#endif
+#endif // ASSERT_ENABLED
 
 enum class IdMatchingType : uint8_t {
     None,
     Rightmost,
     Filter
@@ -81,11 +81,11 @@
     for (const CSSSelector* selector = selectorList.first(); selector; selector = CSSSelectorList::next(selector))
         selectorCount++;
 
     m_selectors.reserveInitialCapacity(selectorCount);
     for (const CSSSelector* selector = selectorList.first(); selector; selector = CSSSelectorList::next(selector))
-        m_selectors.uncheckedAppend(SelectorData(selector));
+        m_selectors.uncheckedAppend({ selector });
 
     if (selectorCount == 1) {
         const CSSSelector& selector = *m_selectors.first().selector;
         if (selector.isLastInTagHistory()) {
             switch (selector.match()) {
@@ -403,15 +403,12 @@
 #if ENABLE(CSS_SELECTOR_JIT)
 template <typename SelectorQueryTrait>
 ALWAYS_INLINE void SelectorDataList::executeCompiledSimpleSelectorChecker(const ContainerNode& searchRootNode, SelectorCompiler::QuerySelectorSimpleSelectorChecker selectorChecker, typename SelectorQueryTrait::OutputType& output, const SelectorData& selectorData) const
 {
     for (auto& element : elementDescendants(const_cast<ContainerNode&>(searchRootNode))) {
-#if CSS_SELECTOR_JIT_PROFILING
-        selectorData.compiledSelectorUsed();
-#else
-        UNUSED_PARAM(selectorData);
-#endif
+        selectorData.compiledSelector.wasUsed();
+
         if (selectorChecker(&element)) {
             SelectorQueryTrait::appendOutputForElement(output, &element);
             if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
                 return;
         }
@@ -423,15 +420,12 @@
 {
     SelectorChecker::CheckingContext checkingContext(SelectorChecker::Mode::QueryingRules);
     checkingContext.scope = rootNode.isDocumentNode() ? nullptr : &rootNode;
 
     for (auto& element : elementDescendants(const_cast<ContainerNode&>(searchRootNode))) {
-#if CSS_SELECTOR_JIT_PROFILING
-        selectorData.compiledSelectorUsed();
-#else
-        UNUSED_PARAM(selectorData);
-#endif
+        selectorData.compiledSelector.wasUsed();
+
         if (selectorChecker(&element, &checkingContext)) {
             SelectorQueryTrait::appendOutputForElement(output, &element);
             if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
                 return;
         }
@@ -443,21 +437,19 @@
 {
     SelectorChecker::CheckingContext checkingContext(SelectorChecker::Mode::QueryingRules);
     checkingContext.scope = rootNode.isDocumentNode() ? nullptr : &rootNode;
     for (auto& element : elementDescendants(const_cast<ContainerNode&>(rootNode))) {
         for (auto& selector : m_selectors) {
-#if CSS_SELECTOR_JIT_PROFILING
-            selector.compiledSelectorUsed();
-#endif
+            selector.compiledSelector.wasUsed();
+
             bool matched = false;
-            void* compiledSelectorChecker = selector.compiledSelectorCodeRef.code().executableAddress();
-            if (selector.compilationStatus == SelectorCompilationStatus::SimpleSelectorChecker) {
-                auto selectorChecker = SelectorCompiler::querySelectorSimpleSelectorCheckerFunction(compiledSelectorChecker, selector.compilationStatus);
+            if (selector.compiledSelector.status == SelectorCompilationStatus::SimpleSelectorChecker) {
+                auto selectorChecker = SelectorCompiler::querySelectorSimpleSelectorCheckerFunction(selector.compiledSelector);
                 matched = selectorChecker(&element);
             } else {
-                ASSERT(selector.compilationStatus == SelectorCompilationStatus::SelectorCheckerWithCheckingContext);
-                auto selectorChecker = SelectorCompiler::querySelectorSelectorCheckerFunctionWithCheckingContext(compiledSelectorChecker, selector.compilationStatus);
+                ASSERT(selector.compiledSelector.status == SelectorCompilationStatus::SelectorCheckerWithCheckingContext);
+                auto selectorChecker = SelectorCompiler::querySelectorSelectorCheckerFunctionWithCheckingContext(selector.compiledSelector);
                 matched = selectorChecker(&element, &checkingContext);
             }
             if (matched) {
                 SelectorQueryTrait::appendOutputForElement(output, &element);
                 if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
@@ -466,24 +458,19 @@
             }
         }
     }
 }
 
-static bool isCompiledSelector(SelectorCompilationStatus compilationStatus)
-{
-    return compilationStatus == SelectorCompilationStatus::SimpleSelectorChecker || compilationStatus == SelectorCompilationStatus::SelectorCheckerWithCheckingContext;
-}
-
 bool SelectorDataList::compileSelector(const SelectorData& selectorData)
 {
-    if (selectorData.compilationStatus != SelectorCompilationStatus::NotCompiled)
-        return isCompiledSelector(selectorData.compilationStatus);
+    auto& compiledSelector = selectorData.compiledSelector;
 
-    selectorData.compilationStatus = SelectorCompiler::compileSelector(selectorData.selector, SelectorCompiler::SelectorContext::QuerySelector, selectorData.compiledSelectorCodeRef);
-    return isCompiledSelector(selectorData.compilationStatus);
-}
+    if (compiledSelector.status == SelectorCompilationStatus::NotCompiled)
+        SelectorCompiler::compileSelector(compiledSelector, selectorData.selector, SelectorCompiler::SelectorContext::QuerySelector);
 
+    return compiledSelector.status != SelectorCompilationStatus::CannotCompile;
+}
 
 #endif // ENABLE(CSS_SELECTOR_JIT)
 
 template <typename SelectorQueryTrait>
 ALWAYS_INLINE void SelectorDataList::execute(ContainerNode& rootNode, typename SelectorQueryTrait::OutputType& output) const
@@ -508,11 +495,11 @@
     case CompilableSingleWithRootFilter:
     case CompilableSingle:
         {
 #if ENABLE(CSS_SELECTOR_JIT)
         const SelectorData& selectorData = m_selectors.first();
-        ASSERT(selectorData.compilationStatus == SelectorCompilationStatus::NotCompiled);
+        ASSERT(selectorData.compiledSelector.status == SelectorCompilationStatus::NotCompiled);
         ASSERT(m_matchType == CompilableSingle || m_matchType == CompilableSingleWithRootFilter);
         if (compileSelector(selectorData)) {
             if (m_matchType == CompilableSingle) {
                 m_matchType = CompiledSingle;
                 goto CompiledSingleCase;
@@ -539,26 +526,25 @@
         FALLTHROUGH;
     case CompiledSingle:
         {
         CompiledSingleCase:
         const SelectorData& selectorData = m_selectors.first();
-        void* compiledSelectorChecker = selectorData.compiledSelectorCodeRef.code().executableAddress();
-        if (selectorData.compilationStatus == SelectorCompilationStatus::SimpleSelectorChecker) {
-            SelectorCompiler::QuerySelectorSimpleSelectorChecker selectorChecker = SelectorCompiler::querySelectorSimpleSelectorCheckerFunction(compiledSelectorChecker, selectorData.compilationStatus);
+        if (selectorData.compiledSelector.status == SelectorCompilationStatus::SimpleSelectorChecker) {
+            auto selectorChecker = SelectorCompiler::querySelectorSimpleSelectorCheckerFunction(selectorData.compiledSelector);
             executeCompiledSimpleSelectorChecker<SelectorQueryTrait>(*searchRootNode, selectorChecker, output, selectorData);
         } else {
-            ASSERT(selectorData.compilationStatus == SelectorCompilationStatus::SelectorCheckerWithCheckingContext);
-            SelectorCompiler::QuerySelectorSelectorCheckerWithCheckingContext selectorChecker = SelectorCompiler::querySelectorSelectorCheckerFunctionWithCheckingContext(compiledSelectorChecker, selectorData.compilationStatus);
+            ASSERT(selectorData.compiledSelector.status == SelectorCompilationStatus::SelectorCheckerWithCheckingContext);
+            auto selectorChecker = SelectorCompiler::querySelectorSelectorCheckerFunctionWithCheckingContext(selectorData.compiledSelector);
             executeCompiledSelectorCheckerWithCheckingContext<SelectorQueryTrait>(rootNode, *searchRootNode, selectorChecker, output, selectorData);
         }
         break;
         }
 #else
     case CompiledSingleWithRootFilter:
     case CompiledSingle:
         ASSERT_NOT_REACHED();
-#if ASSERT_DISABLED
+#if !ASSERT_ENABLED
         FALLTHROUGH;
 #endif
 #endif // ENABLE(CSS_SELECTOR_JIT)
 
     case SingleSelectorWithRootFilter:

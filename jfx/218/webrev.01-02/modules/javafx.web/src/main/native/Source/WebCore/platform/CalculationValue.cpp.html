<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/CalculationValue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011 Google Inc. All rights reserved.
  3  * Copyright (C) 2014 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;CalculationValue.h&quot;
 34 
 35 #include &quot;LengthFunctions.h&quot;
 36 #include &lt;limits&gt;
 37 #include &lt;wtf/text/TextStream.h&gt;
 38 
 39 namespace WebCore {
 40 
 41 Ref&lt;CalculationValue&gt; CalculationValue::create(std::unique_ptr&lt;CalcExpressionNode&gt; value, ValueRange range)
 42 {
 43     return adoptRef(*new CalculationValue(WTFMove(value), range));
 44 }
 45 
 46 float CalcExpressionNumber::evaluate(float) const
 47 {
 48     return m_value;
 49 }
 50 
 51 void CalcExpressionNumber::dump(TextStream&amp; ts) const
 52 {
 53     ts &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_value);
 54 }
 55 
 56 bool CalcExpressionNumber::operator==(const CalcExpressionNode&amp; other) const
 57 {
 58     return is&lt;CalcExpressionNumber&gt;(other) &amp;&amp; *this == downcast&lt;CalcExpressionNumber&gt;(other);
 59 }
 60 
 61 float CalculationValue::evaluate(float maxValue) const
 62 {
 63     float result = m_expression-&gt;evaluate(maxValue);
 64     // FIXME: This test was originally needed when we did not detect division by zero at parse time.
 65     // It&#39;s possible that this is now unneeded code and can be removed.
 66     if (std::isnan(result))
 67         return 0;
 68     return m_shouldClampToNonNegative &amp;&amp; result &lt; 0 ? 0 : result;
 69 }
 70 
 71 float CalcExpressionNegation::evaluate(float maxValue) const
 72 {
 73     return -m_child-&gt;evaluate(maxValue);
 74 }
 75 
 76 bool CalcExpressionNegation::operator==(const CalcExpressionNode&amp; other) const
 77 {
 78     return is&lt;CalcExpressionNegation&gt;(other) &amp;&amp; *this == downcast&lt;CalcExpressionNegation&gt;(other);
 79 }
 80 
 81 void CalcExpressionNegation::dump(TextStream&amp; ts) const
 82 {
 83     ts &lt;&lt; &quot;-(&quot;;
 84     ts &lt;&lt; *m_child;
 85     ts &lt;&lt; &quot;)&quot;;
 86 }
 87 
 88 bool operator==(const CalcExpressionNegation&amp; a, const CalcExpressionNegation&amp; b)
 89 {
 90     return *a.child() == *b.child();
 91 }
 92 
 93 float CalcExpressionInversion::evaluate(float maxValue) const
 94 {
 95     return 1.0f / m_child-&gt;evaluate(maxValue);
 96 }
 97 
 98 void CalcExpressionInversion::dump(TextStream&amp; ts) const
 99 {
100     ts &lt;&lt; &quot;1.0 / &quot; &lt;&lt; &quot;(&quot;;
101     ts &lt;&lt; *m_child;
102     ts &lt;&lt; &quot;)&quot;;
103 }
104 
105 bool CalcExpressionInversion::operator==(const CalcExpressionNode&amp; other) const
106 {
107     return is&lt;CalcExpressionInversion&gt;(other) &amp;&amp; *this == downcast&lt;CalcExpressionInversion&gt;(other);
108 }
109 
110 bool operator==(const CalcExpressionInversion&amp; a, const CalcExpressionInversion&amp; b)
111 {
112     return *a.child() == *b.child();
113 }
114 
115 float CalcExpressionOperation::evaluate(float maxValue) const
116 {
117     switch (m_operator) {
118     case CalcOperator::Add: {
119         float sum = 0;
120         for (auto&amp; child : m_children)
121             sum += child-&gt;evaluate(maxValue);
122         return sum;
123     }
124     case CalcOperator::Subtract: {
125         // FIXME
126         ASSERT(m_children.size() == 2);
127         float left = m_children[0]-&gt;evaluate(maxValue);
128         float right = m_children[1]-&gt;evaluate(maxValue);
129         return left - right;
130     }
131     case CalcOperator::Multiply: {
132         float product = 1;
133         for (auto&amp; child : m_children)
134             product *= child-&gt;evaluate(maxValue);
135         return product;
136     }
137     case CalcOperator::Divide: {
138         // FIXME
139         ASSERT(m_children.size() == 1 || m_children.size() == 2);
140         if (m_children.size() == 1)
141             return std::numeric_limits&lt;float&gt;::quiet_NaN();
142         float left = m_children[0]-&gt;evaluate(maxValue);
143         float right = m_children[1]-&gt;evaluate(maxValue);
144         return left / right;
145     }
146     case CalcOperator::Min: {
147         if (m_children.isEmpty())
148             return std::numeric_limits&lt;float&gt;::quiet_NaN();
149         float minimum = m_children[0]-&gt;evaluate(maxValue);
150         for (auto&amp; child : m_children)
151             minimum = std::min(minimum, child-&gt;evaluate(maxValue));
152         return minimum;
153     }
154     case CalcOperator::Max: {
155         if (m_children.isEmpty())
156             return std::numeric_limits&lt;float&gt;::quiet_NaN();
157         float maximum = m_children[0]-&gt;evaluate(maxValue);
158         for (auto&amp; child : m_children)
159             maximum = std::max(maximum, child-&gt;evaluate(maxValue));
160         return maximum;
161     }
162     case CalcOperator::Clamp: {
163         if (m_children.size() != 3)
164             return std::numeric_limits&lt;float&gt;::quiet_NaN();
165 
166         float min = m_children[0]-&gt;evaluate(maxValue);
167         float value = m_children[1]-&gt;evaluate(maxValue);
168         float max = m_children[2]-&gt;evaluate(maxValue);
169         return std::max(min, std::min(value, max));
170     }
171     }
172     ASSERT_NOT_REACHED();
173     return std::numeric_limits&lt;float&gt;::quiet_NaN();
174 }
175 
176 bool CalcExpressionOperation::operator==(const CalcExpressionNode&amp; other) const
177 {
178     return is&lt;CalcExpressionOperation&gt;(other) &amp;&amp; *this == downcast&lt;CalcExpressionOperation&gt;(other);
179 }
180 
181 bool operator==(const CalcExpressionOperation&amp; a, const CalcExpressionOperation&amp; b)
182 {
183     if (a.getOperator() != b.getOperator())
184         return false;
185     // Maybe Vectors of unique_ptrs should always do deep compare?
186     if (a.children().size() != b.children().size())
187         return false;
188     for (unsigned i = 0; i &lt; a.children().size(); ++i) {
189         if (!(*a.children()[i] == *b.children()[i]))
190             return false;
191     }
192     return true;
193 }
194 
195 void CalcExpressionOperation::dump(TextStream&amp; ts) const
196 {
197     if (m_operator == CalcOperator::Min || m_operator == CalcOperator::Max) {
198         ts &lt;&lt; m_operator &lt;&lt; &quot;(&quot;;
199         size_t childrenCount = m_children.size();
200         for (size_t i = 0; i &lt; childrenCount; i++) {
201             ts &lt;&lt; m_children[i].get();
202             if (i &lt; childrenCount - 1)
203                 ts &lt;&lt; &quot;, &quot;;
204         }
205         ts &lt;&lt; &quot;)&quot;;
206     } else
207         ts &lt;&lt; m_children[0].get() &lt;&lt; &quot; &quot; &lt;&lt; m_operator &lt;&lt; &quot; &quot; &lt;&lt; m_children[1].get();
208 }
209 
210 float CalcExpressionLength::evaluate(float maxValue) const
211 {
212     return floatValueForLength(m_length, maxValue);
213 }
214 
215 bool CalcExpressionLength::operator==(const CalcExpressionNode&amp; other) const
216 {
217     return is&lt;CalcExpressionLength&gt;(other) &amp;&amp; *this == downcast&lt;CalcExpressionLength&gt;(other);
218 }
219 
220 void CalcExpressionLength::dump(TextStream&amp; ts) const
221 {
222     ts &lt;&lt; m_length;
223 }
224 
225 CalcExpressionBlendLength::CalcExpressionBlendLength(Length from, Length to, float progress)
226     : CalcExpressionNode(CalcExpressionNodeType::BlendLength)
227     , m_from(from)
228     , m_to(to)
229     , m_progress(progress)
230 {
231     // Flatten nesting of CalcExpressionBlendLength as a speculative fix for rdar://problem/30533005.
232     // CalcExpressionBlendLength is only used as a result of animation and they don&#39;t nest in normal cases.
233     if (m_from.isCalculated() &amp;&amp; m_from.calculationValue().expression().type() == CalcExpressionNodeType::BlendLength)
234         m_from = downcast&lt;CalcExpressionBlendLength&gt;(m_from.calculationValue().expression()).from();
235     if (m_to.isCalculated() &amp;&amp; m_to.calculationValue().expression().type() == CalcExpressionNodeType::BlendLength)
236         m_to = downcast&lt;CalcExpressionBlendLength&gt;(m_to.calculationValue().expression()).to();
237 }
238 
239 float CalcExpressionBlendLength::evaluate(float maxValue) const
240 {
241     return (1.0f - m_progress) * floatValueForLength(m_from, maxValue) + m_progress * floatValueForLength(m_to, maxValue);
242 }
243 
244 bool CalcExpressionBlendLength::operator==(const CalcExpressionNode&amp; other) const
245 {
246     return is&lt;CalcExpressionBlendLength&gt;(other) &amp;&amp; *this == downcast&lt;CalcExpressionBlendLength&gt;(other);
247 }
248 
249 void CalcExpressionBlendLength::dump(TextStream&amp; ts) const
250 {
251     ts &lt;&lt; &quot;blend(&quot; &lt;&lt; m_from &lt;&lt; &quot;, &quot; &lt;&lt; m_to &lt;&lt; &quot;, &quot; &lt;&lt; m_progress &lt;&lt; &quot;)&quot;;
252 }
253 
254 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, CalcOperator op)
255 {
256     switch (op) {
257     case CalcOperator::Add: ts &lt;&lt; &quot;+&quot;; break;
258     case CalcOperator::Subtract: ts &lt;&lt; &quot;-&quot;; break;
259     case CalcOperator::Multiply: ts &lt;&lt; &quot;*&quot;; break;
260     case CalcOperator::Divide: ts &lt;&lt; &quot;/&quot;; break;
261     case CalcOperator::Min: ts &lt;&lt; &quot;min&quot;; break;
262     case CalcOperator::Max: ts &lt;&lt; &quot;max&quot;; break;
263     case CalcOperator::Clamp: ts &lt;&lt; &quot;clamp&quot;; break;
264     }
265     return ts;
266 }
267 
268 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const CalculationValue&amp; value)
269 {
270     ts &lt;&lt; &quot;calc(&quot;;
271     ts &lt;&lt; value.expression();
272     ts &lt;&lt; &quot;)&quot;;
273     return ts;
274 }
275 
276 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const CalcExpressionNode&amp; expressionNode)
277 {
278     expressionNode.dump(ts);
279     return ts;
280 }
281 
282 } // namespace WebCore
    </pre>
  </body>
</html>
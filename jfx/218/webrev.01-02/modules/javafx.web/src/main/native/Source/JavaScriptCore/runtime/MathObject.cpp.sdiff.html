<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/MathObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MathCommon.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MathObject.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/MathObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 16  *  License along with this library; if not, write to the Free Software
 17  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 18  *
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;MathObject.h&quot;
 23 
 24 #include &quot;JSCInlines.h&quot;
 25 #include &quot;MathCommon.h&quot;
 26 #include &quot;ObjectPrototype.h&quot;
 27 #include &lt;time.h&gt;
 28 #include &lt;wtf/Assertions.h&gt;
 29 #include &lt;wtf/MathExtras.h&gt;
 30 #include &lt;wtf/Vector.h&gt;
 31 
 32 namespace JSC {
 33 
 34 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(MathObject);
 35 
<span class="line-modified"> 36 EncodedJSValue JSC_HOST_CALL mathProtoFuncACos(ExecState*);</span>
<span class="line-modified"> 37 EncodedJSValue JSC_HOST_CALL mathProtoFuncACosh(ExecState*);</span>
<span class="line-modified"> 38 EncodedJSValue JSC_HOST_CALL mathProtoFuncASin(ExecState*);</span>
<span class="line-modified"> 39 EncodedJSValue JSC_HOST_CALL mathProtoFuncASinh(ExecState*);</span>
<span class="line-modified"> 40 EncodedJSValue JSC_HOST_CALL mathProtoFuncATan(ExecState*);</span>
<span class="line-modified"> 41 EncodedJSValue JSC_HOST_CALL mathProtoFuncATanh(ExecState*);</span>
<span class="line-modified"> 42 EncodedJSValue JSC_HOST_CALL mathProtoFuncATan2(ExecState*);</span>
<span class="line-modified"> 43 EncodedJSValue JSC_HOST_CALL mathProtoFuncCbrt(ExecState*);</span>
<span class="line-modified"> 44 EncodedJSValue JSC_HOST_CALL mathProtoFuncCeil(ExecState*);</span>
<span class="line-modified"> 45 EncodedJSValue JSC_HOST_CALL mathProtoFuncClz32(ExecState*);</span>
<span class="line-modified"> 46 EncodedJSValue JSC_HOST_CALL mathProtoFuncCos(ExecState*);</span>
<span class="line-modified"> 47 EncodedJSValue JSC_HOST_CALL mathProtoFuncCosh(ExecState*);</span>
<span class="line-modified"> 48 EncodedJSValue JSC_HOST_CALL mathProtoFuncExp(ExecState*);</span>
<span class="line-modified"> 49 EncodedJSValue JSC_HOST_CALL mathProtoFuncExpm1(ExecState*);</span>
<span class="line-modified"> 50 EncodedJSValue JSC_HOST_CALL mathProtoFuncFround(ExecState*);</span>
<span class="line-modified"> 51 EncodedJSValue JSC_HOST_CALL mathProtoFuncHypot(ExecState*);</span>
<span class="line-modified"> 52 EncodedJSValue JSC_HOST_CALL mathProtoFuncLog(ExecState*);</span>
<span class="line-modified"> 53 EncodedJSValue JSC_HOST_CALL mathProtoFuncLog1p(ExecState*);</span>
<span class="line-modified"> 54 EncodedJSValue JSC_HOST_CALL mathProtoFuncLog10(ExecState*);</span>
<span class="line-modified"> 55 EncodedJSValue JSC_HOST_CALL mathProtoFuncLog2(ExecState*);</span>
<span class="line-modified"> 56 EncodedJSValue JSC_HOST_CALL mathProtoFuncMax(ExecState*);</span>
<span class="line-modified"> 57 EncodedJSValue JSC_HOST_CALL mathProtoFuncMin(ExecState*);</span>
<span class="line-modified"> 58 EncodedJSValue JSC_HOST_CALL mathProtoFuncPow(ExecState*);</span>
<span class="line-modified"> 59 EncodedJSValue JSC_HOST_CALL mathProtoFuncRandom(ExecState*);</span>
<span class="line-modified"> 60 EncodedJSValue JSC_HOST_CALL mathProtoFuncRound(ExecState*);</span>
<span class="line-modified"> 61 EncodedJSValue JSC_HOST_CALL mathProtoFuncSign(ExecState*);</span>
<span class="line-modified"> 62 EncodedJSValue JSC_HOST_CALL mathProtoFuncSin(ExecState*);</span>
<span class="line-modified"> 63 EncodedJSValue JSC_HOST_CALL mathProtoFuncSinh(ExecState*);</span>
<span class="line-modified"> 64 EncodedJSValue JSC_HOST_CALL mathProtoFuncSqrt(ExecState*);</span>
<span class="line-modified"> 65 EncodedJSValue JSC_HOST_CALL mathProtoFuncTan(ExecState*);</span>
<span class="line-modified"> 66 EncodedJSValue JSC_HOST_CALL mathProtoFuncTanh(ExecState*);</span>
<span class="line-modified"> 67 EncodedJSValue JSC_HOST_CALL mathProtoFuncIMul(ExecState*);</span>
 68 
 69 const ClassInfo MathObject::s_info = { &quot;Math&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(MathObject) };
 70 
 71 MathObject::MathObject(VM&amp; vm, Structure* structure)
 72     : JSNonFinalObject(vm, structure)
 73 {
 74 }
 75 
 76 void MathObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 77 {
 78     Base::finishCreation(vm);
 79     ASSERT(inherits(vm, info()));
 80 
 81     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;E&quot;), jsNumber(Math::exp(1.0)), PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 82     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;LN2&quot;), jsNumber(Math::log(2.0)), PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 83     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;LN10&quot;), jsNumber(Math::log(10.0)), PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 84     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;LOG2E&quot;), jsNumber(1.0 / Math::log(2.0)), PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 85     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;LOG10E&quot;), jsNumber(0.4342944819032518), PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 86     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;PI&quot;), jsNumber(piDouble), PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 87     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;SQRT1_2&quot;), jsNumber(sqrt(0.5)), PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 88     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;SQRT2&quot;), jsNumber(sqrt(2.0)), PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
<span class="line-modified"> 89     putDirectWithoutTransition(vm, vm.propertyNames-&gt;toStringTagSymbol, jsString(vm, &quot;Math&quot;), PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);</span>
 90 
 91     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;abs&quot;), 1, mathProtoFuncAbs, AbsIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 92     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;acos&quot;), 1, mathProtoFuncACos, ACosIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 93     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;asin&quot;), 1, mathProtoFuncASin, ASinIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 94     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;atan&quot;), 1, mathProtoFuncATan, ATanIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 95     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;acosh&quot;), 1, mathProtoFuncACosh, ACoshIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 96     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;asinh&quot;), 1, mathProtoFuncASinh, ASinhIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 97     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;atanh&quot;), 1, mathProtoFuncATanh, ATanhIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 98     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;atan2&quot;), 2, mathProtoFuncATan2, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 99     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;cbrt&quot;), 1, mathProtoFuncCbrt, CbrtIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
100     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;ceil&quot;), 1, mathProtoFuncCeil, CeilIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
101     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;clz32&quot;), 1, mathProtoFuncClz32, Clz32Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
102     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;cos&quot;), 1, mathProtoFuncCos, CosIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
103     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;cosh&quot;), 1, mathProtoFuncCosh, CoshIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
104     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;exp&quot;), 1, mathProtoFuncExp, ExpIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
105     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;expm1&quot;), 1, mathProtoFuncExpm1, Expm1Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
106     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;floor&quot;), 1, mathProtoFuncFloor, FloorIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
107     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;fround&quot;), 1, mathProtoFuncFround, FRoundIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
108     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;hypot&quot;), 2, mathProtoFuncHypot, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
109     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;log&quot;), 1, mathProtoFuncLog, LogIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
110     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;log10&quot;), 1, mathProtoFuncLog10, Log10Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
111     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;log1p&quot;), 1, mathProtoFuncLog1p, Log1pIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
112     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;log2&quot;), 1, mathProtoFuncLog2, Log2Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
113     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;max&quot;), 2, mathProtoFuncMax, MaxIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
114     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;min&quot;), 2, mathProtoFuncMin, MinIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
115     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;pow&quot;), 2, mathProtoFuncPow, PowIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
116     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;random&quot;), 0, mathProtoFuncRandom, RandomIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
117     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;round&quot;), 1, mathProtoFuncRound, RoundIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
118     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;sign&quot;), 1, mathProtoFuncSign, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
119     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;sin&quot;), 1, mathProtoFuncSin, SinIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
120     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;sinh&quot;), 1, mathProtoFuncSinh, SinhIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
121     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;sqrt&quot;), 1, mathProtoFuncSqrt, SqrtIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
122     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;tan&quot;), 1, mathProtoFuncTan, TanIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
123     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;tanh&quot;), 1, mathProtoFuncTanh, TanhIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
124     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;trunc&quot;), 1, mathProtoFuncTrunc, TruncIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
125     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;imul&quot;), 2, mathProtoFuncIMul, IMulIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
126 }
127 
128 // ------------------------------ Functions --------------------------------
129 
<span class="line-modified">130 EncodedJSValue JSC_HOST_CALL mathProtoFuncAbs(ExecState* exec)</span>
131 {
<span class="line-modified">132     return JSValue::encode(jsNumber(fabs(exec-&gt;argument(0).toNumber(exec))));</span>
133 }
134 
<span class="line-modified">135 EncodedJSValue JSC_HOST_CALL mathProtoFuncACos(ExecState* exec)</span>
136 {
<span class="line-modified">137     return JSValue::encode(jsDoubleNumber(Math::acos(exec-&gt;argument(0).toNumber(exec))));</span>
138 }
139 
<span class="line-modified">140 EncodedJSValue JSC_HOST_CALL mathProtoFuncASin(ExecState* exec)</span>
141 {
<span class="line-modified">142     return JSValue::encode(jsDoubleNumber(Math::asin(exec-&gt;argument(0).toNumber(exec))));</span>
143 }
144 
<span class="line-modified">145 EncodedJSValue JSC_HOST_CALL mathProtoFuncATan(ExecState* exec)</span>
146 {
<span class="line-modified">147     return JSValue::encode(jsDoubleNumber(Math::atan(exec-&gt;argument(0).toNumber(exec))));</span>
148 }
149 
<span class="line-modified">150 EncodedJSValue JSC_HOST_CALL mathProtoFuncATan2(ExecState* exec)</span>
151 {
<span class="line-modified">152     VM&amp; vm = exec-&gt;vm();</span>
153     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">154     double arg0 = exec-&gt;argument(0).toNumber(exec);</span>
155     RETURN_IF_EXCEPTION(scope, encodedJSValue());
156     scope.release();
<span class="line-modified">157     double arg1 = exec-&gt;argument(1).toNumber(exec);</span>
158     return JSValue::encode(jsDoubleNumber(atan2(arg0, arg1)));
159 }
160 
<span class="line-modified">161 EncodedJSValue JSC_HOST_CALL mathProtoFuncCeil(ExecState* exec)</span>
162 {
<span class="line-modified">163     return JSValue::encode(jsNumber(ceil(exec-&gt;argument(0).toNumber(exec))));</span>
164 }
165 
<span class="line-modified">166 EncodedJSValue JSC_HOST_CALL mathProtoFuncClz32(ExecState* exec)</span>
167 {
<span class="line-modified">168     VM&amp; vm = exec-&gt;vm();</span>
169     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">170     uint32_t value = exec-&gt;argument(0).toUInt32(exec);</span>
171     RETURN_IF_EXCEPTION(scope, encodedJSValue());
172     return JSValue::encode(JSValue(clz(value)));
173 }
174 
<span class="line-modified">175 EncodedJSValue JSC_HOST_CALL mathProtoFuncCos(ExecState* exec)</span>
176 {
<span class="line-modified">177     return JSValue::encode(jsDoubleNumber(Math::cos(exec-&gt;argument(0).toNumber(exec))));</span>
178 }
179 
<span class="line-modified">180 EncodedJSValue JSC_HOST_CALL mathProtoFuncExp(ExecState* exec)</span>
181 {
<span class="line-modified">182     return JSValue::encode(jsDoubleNumber(Math::exp(exec-&gt;argument(0).toNumber(exec))));</span>
183 }
184 
<span class="line-modified">185 EncodedJSValue JSC_HOST_CALL mathProtoFuncFloor(ExecState* exec)</span>
186 {
<span class="line-modified">187     return JSValue::encode(jsNumber(floor(exec-&gt;argument(0).toNumber(exec))));</span>
188 }
189 
<span class="line-modified">190 EncodedJSValue JSC_HOST_CALL mathProtoFuncHypot(ExecState* exec)</span>
191 {
<span class="line-modified">192     VM&amp; vm = exec-&gt;vm();</span>
193     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">194     unsigned argsCount = exec-&gt;argumentCount();</span>
195     double max = 0;
196     Vector&lt;double, 8&gt; args;
197     args.reserveInitialCapacity(argsCount);
198     for (unsigned i = 0; i &lt; argsCount; ++i) {
<span class="line-modified">199         args.uncheckedAppend(exec-&gt;uncheckedArgument(i).toNumber(exec));</span>
200         RETURN_IF_EXCEPTION(scope, encodedJSValue());
201         if (std::isinf(args[i]))
202             return JSValue::encode(jsDoubleNumber(+std::numeric_limits&lt;double&gt;::infinity()));
203         max = std::max(fabs(args[i]), max);
204     }
205     if (!max)
206         max = 1;
207     // Kahan summation algorithm significantly reduces the numerical error in the total obtained.
208     double sum = 0;
209     double compensation = 0;
210     for (double argument : args) {
211         double scaledArgument = argument / max;
212         double summand = scaledArgument * scaledArgument - compensation;
213         double preliminary = sum + summand;
214         compensation = (preliminary - sum) - summand;
215         sum = preliminary;
216     }
217     return JSValue::encode(jsDoubleNumber(sqrt(sum) * max));
218 }
219 
<span class="line-modified">220 EncodedJSValue JSC_HOST_CALL mathProtoFuncLog(ExecState* exec)</span>
221 {
<span class="line-modified">222     return JSValue::encode(jsDoubleNumber(Math::log(exec-&gt;argument(0).toNumber(exec))));</span>
223 }
224 
<span class="line-modified">225 EncodedJSValue JSC_HOST_CALL mathProtoFuncMax(ExecState* exec)</span>
226 {
<span class="line-modified">227     VM&amp; vm = exec-&gt;vm();</span>
228     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">229     unsigned argsCount = exec-&gt;argumentCount();</span>
230     double result = -std::numeric_limits&lt;double&gt;::infinity();
231     for (unsigned k = 0; k &lt; argsCount; ++k) {
<span class="line-modified">232         double val = exec-&gt;uncheckedArgument(k).toNumber(exec);</span>
233         RETURN_IF_EXCEPTION(scope, encodedJSValue());
234         if (std::isnan(val)) {
235             result = PNaN;
236         } else if (val &gt; result || (!val &amp;&amp; !result &amp;&amp; !std::signbit(val)))
237             result = val;
238     }
239     return JSValue::encode(jsNumber(result));
240 }
241 
<span class="line-modified">242 EncodedJSValue JSC_HOST_CALL mathProtoFuncMin(ExecState* exec)</span>
243 {
<span class="line-modified">244     VM&amp; vm = exec-&gt;vm();</span>
245     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">246     unsigned argsCount = exec-&gt;argumentCount();</span>
247     double result = +std::numeric_limits&lt;double&gt;::infinity();
248     for (unsigned k = 0; k &lt; argsCount; ++k) {
<span class="line-modified">249         double val = exec-&gt;uncheckedArgument(k).toNumber(exec);</span>
250         RETURN_IF_EXCEPTION(scope, encodedJSValue());
251         if (std::isnan(val)) {
252             result = PNaN;
253         } else if (val &lt; result || (!val &amp;&amp; !result &amp;&amp; std::signbit(val)))
254             result = val;
255     }
256     return JSValue::encode(jsNumber(result));
257 }
258 
<span class="line-modified">259 EncodedJSValue JSC_HOST_CALL mathProtoFuncPow(ExecState* exec)</span>
260 {
261     // ECMA 15.8.2.1.13
262 
<span class="line-modified">263     VM&amp; vm = exec-&gt;vm();</span>
264     auto scope = DECLARE_THROW_SCOPE(vm);
265 
<span class="line-modified">266     double arg = exec-&gt;argument(0).toNumber(exec);</span>
267     RETURN_IF_EXCEPTION(scope, encodedJSValue());
268     scope.release();
<span class="line-modified">269     double arg2 = exec-&gt;argument(1).toNumber(exec);</span>
270 
271     return JSValue::encode(JSValue(operationMathPow(arg, arg2)));
272 }
273 
<span class="line-modified">274 EncodedJSValue JSC_HOST_CALL mathProtoFuncRandom(ExecState* exec)</span>
275 {
<span class="line-modified">276     return JSValue::encode(jsDoubleNumber(exec-&gt;lexicalGlobalObject()-&gt;weakRandomNumber()));</span>
277 }
278 
<span class="line-modified">279 EncodedJSValue JSC_HOST_CALL mathProtoFuncRound(ExecState* exec)</span>
280 {
<span class="line-modified">281     return JSValue::encode(jsNumber(jsRound(exec-&gt;argument(0).toNumber(exec))));</span>
282 }
283 
<span class="line-modified">284 EncodedJSValue JSC_HOST_CALL mathProtoFuncSign(ExecState* exec)</span>
285 {
<span class="line-modified">286     double arg = exec-&gt;argument(0).toNumber(exec);</span>
287     if (std::isnan(arg))
288         return JSValue::encode(jsNaN());
289     if (!arg)
290         return JSValue::encode(std::signbit(arg) ? jsNumber(-0.0) : jsNumber(0));
291     return JSValue::encode(jsNumber(std::signbit(arg) ? -1 : 1));
292 }
293 
<span class="line-modified">294 EncodedJSValue JSC_HOST_CALL mathProtoFuncSin(ExecState* exec)</span>
295 {
<span class="line-modified">296     return JSValue::encode(jsDoubleNumber(Math::sin(exec-&gt;argument(0).toNumber(exec))));</span>
297 }
298 
<span class="line-modified">299 EncodedJSValue JSC_HOST_CALL mathProtoFuncSqrt(ExecState* exec)</span>
300 {
<span class="line-modified">301     return JSValue::encode(jsDoubleNumber(sqrt(exec-&gt;argument(0).toNumber(exec))));</span>
302 }
303 
<span class="line-modified">304 EncodedJSValue JSC_HOST_CALL mathProtoFuncTan(ExecState* exec)</span>
305 {
<span class="line-modified">306     return JSValue::encode(jsDoubleNumber(Math::tan(exec-&gt;argument(0).toNumber(exec))));</span>
307 }
308 
<span class="line-modified">309 EncodedJSValue JSC_HOST_CALL mathProtoFuncIMul(ExecState* exec)</span>
310 {
<span class="line-modified">311     VM&amp; vm = exec-&gt;vm();</span>
312     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">313     int32_t left = exec-&gt;argument(0).toInt32(exec);</span>
314     RETURN_IF_EXCEPTION(scope, encodedJSValue());
315     scope.release();
<span class="line-modified">316     int32_t right = exec-&gt;argument(1).toInt32(exec);</span>
317     return JSValue::encode(jsNumber(left * right));
318 }
319 
<span class="line-modified">320 EncodedJSValue JSC_HOST_CALL mathProtoFuncACosh(ExecState* exec)</span>
321 {
<span class="line-modified">322     return JSValue::encode(jsDoubleNumber(Math::acosh(exec-&gt;argument(0).toNumber(exec))));</span>
323 }
324 
<span class="line-modified">325 EncodedJSValue JSC_HOST_CALL mathProtoFuncASinh(ExecState* exec)</span>
326 {
<span class="line-modified">327     return JSValue::encode(jsDoubleNumber(Math::asinh(exec-&gt;argument(0).toNumber(exec))));</span>
328 }
329 
<span class="line-modified">330 EncodedJSValue JSC_HOST_CALL mathProtoFuncATanh(ExecState* exec)</span>
331 {
<span class="line-modified">332     return JSValue::encode(jsDoubleNumber(Math::atanh(exec-&gt;argument(0).toNumber(exec))));</span>
333 }
334 
<span class="line-modified">335 EncodedJSValue JSC_HOST_CALL mathProtoFuncCbrt(ExecState* exec)</span>
336 {
<span class="line-modified">337     return JSValue::encode(jsDoubleNumber(Math::cbrt(exec-&gt;argument(0).toNumber(exec))));</span>
338 }
339 
<span class="line-modified">340 EncodedJSValue JSC_HOST_CALL mathProtoFuncCosh(ExecState* exec)</span>
341 {
<span class="line-modified">342     return JSValue::encode(jsDoubleNumber(Math::cosh(exec-&gt;argument(0).toNumber(exec))));</span>
343 }
344 
<span class="line-modified">345 EncodedJSValue JSC_HOST_CALL mathProtoFuncExpm1(ExecState* exec)</span>
346 {
<span class="line-modified">347     return JSValue::encode(jsDoubleNumber(Math::expm1(exec-&gt;argument(0).toNumber(exec))));</span>
348 }
349 
<span class="line-modified">350 EncodedJSValue JSC_HOST_CALL mathProtoFuncFround(ExecState* exec)</span>
351 {
<span class="line-modified">352     return JSValue::encode(jsDoubleNumber(static_cast&lt;float&gt;(exec-&gt;argument(0).toNumber(exec))));</span>
353 }
354 
<span class="line-modified">355 EncodedJSValue JSC_HOST_CALL mathProtoFuncLog1p(ExecState* exec)</span>
356 {
<span class="line-modified">357     return JSValue::encode(jsDoubleNumber(Math::log1p(exec-&gt;argument(0).toNumber(exec))));</span>
358 }
359 
<span class="line-modified">360 EncodedJSValue JSC_HOST_CALL mathProtoFuncLog10(ExecState* exec)</span>
361 {
<span class="line-modified">362     return JSValue::encode(jsDoubleNumber(Math::log10(exec-&gt;argument(0).toNumber(exec))));</span>
363 }
364 
<span class="line-modified">365 EncodedJSValue JSC_HOST_CALL mathProtoFuncLog2(ExecState* exec)</span>
366 {
<span class="line-modified">367     return JSValue::encode(jsDoubleNumber(Math::log2(exec-&gt;argument(0).toNumber(exec))));</span>
368 }
369 
<span class="line-modified">370 EncodedJSValue JSC_HOST_CALL mathProtoFuncSinh(ExecState* exec)</span>
371 {
<span class="line-modified">372     return JSValue::encode(jsDoubleNumber(Math::sinh(exec-&gt;argument(0).toNumber(exec))));</span>
373 }
374 
<span class="line-modified">375 EncodedJSValue JSC_HOST_CALL mathProtoFuncTanh(ExecState* exec)</span>
376 {
<span class="line-modified">377     return JSValue::encode(jsDoubleNumber(Math::tanh(exec-&gt;argument(0).toNumber(exec))));</span>
378 }
379 
<span class="line-modified">380 EncodedJSValue JSC_HOST_CALL mathProtoFuncTrunc(ExecState*exec)</span>
381 {
<span class="line-modified">382     return JSValue::encode(jsNumber(exec-&gt;argument(0).toIntegerPreserveNaN(exec)));</span>
383 }
384 
385 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 16  *  License along with this library; if not, write to the Free Software
 17  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 18  *
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;MathObject.h&quot;
 23 
 24 #include &quot;JSCInlines.h&quot;
 25 #include &quot;MathCommon.h&quot;
 26 #include &quot;ObjectPrototype.h&quot;
 27 #include &lt;time.h&gt;
 28 #include &lt;wtf/Assertions.h&gt;
 29 #include &lt;wtf/MathExtras.h&gt;
 30 #include &lt;wtf/Vector.h&gt;
 31 
 32 namespace JSC {
 33 
 34 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(MathObject);
 35 
<span class="line-modified"> 36 EncodedJSValue JSC_HOST_CALL mathProtoFuncACos(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 37 EncodedJSValue JSC_HOST_CALL mathProtoFuncACosh(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 38 EncodedJSValue JSC_HOST_CALL mathProtoFuncASin(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 39 EncodedJSValue JSC_HOST_CALL mathProtoFuncASinh(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 40 EncodedJSValue JSC_HOST_CALL mathProtoFuncATan(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 41 EncodedJSValue JSC_HOST_CALL mathProtoFuncATanh(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 42 EncodedJSValue JSC_HOST_CALL mathProtoFuncATan2(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 43 EncodedJSValue JSC_HOST_CALL mathProtoFuncCbrt(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 44 EncodedJSValue JSC_HOST_CALL mathProtoFuncCeil(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 45 EncodedJSValue JSC_HOST_CALL mathProtoFuncClz32(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 46 EncodedJSValue JSC_HOST_CALL mathProtoFuncCos(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 47 EncodedJSValue JSC_HOST_CALL mathProtoFuncCosh(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 48 EncodedJSValue JSC_HOST_CALL mathProtoFuncExp(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 49 EncodedJSValue JSC_HOST_CALL mathProtoFuncExpm1(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 50 EncodedJSValue JSC_HOST_CALL mathProtoFuncFround(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 51 EncodedJSValue JSC_HOST_CALL mathProtoFuncHypot(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 52 EncodedJSValue JSC_HOST_CALL mathProtoFuncLog(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 53 EncodedJSValue JSC_HOST_CALL mathProtoFuncLog1p(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 54 EncodedJSValue JSC_HOST_CALL mathProtoFuncLog10(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 55 EncodedJSValue JSC_HOST_CALL mathProtoFuncLog2(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 56 EncodedJSValue JSC_HOST_CALL mathProtoFuncMax(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 57 EncodedJSValue JSC_HOST_CALL mathProtoFuncMin(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 58 EncodedJSValue JSC_HOST_CALL mathProtoFuncPow(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 59 EncodedJSValue JSC_HOST_CALL mathProtoFuncRandom(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 60 EncodedJSValue JSC_HOST_CALL mathProtoFuncRound(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 61 EncodedJSValue JSC_HOST_CALL mathProtoFuncSign(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 62 EncodedJSValue JSC_HOST_CALL mathProtoFuncSin(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 63 EncodedJSValue JSC_HOST_CALL mathProtoFuncSinh(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 64 EncodedJSValue JSC_HOST_CALL mathProtoFuncSqrt(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 65 EncodedJSValue JSC_HOST_CALL mathProtoFuncTan(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 66 EncodedJSValue JSC_HOST_CALL mathProtoFuncTanh(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 67 EncodedJSValue JSC_HOST_CALL mathProtoFuncIMul(JSGlobalObject*, CallFrame*);</span>
 68 
 69 const ClassInfo MathObject::s_info = { &quot;Math&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(MathObject) };
 70 
 71 MathObject::MathObject(VM&amp; vm, Structure* structure)
 72     : JSNonFinalObject(vm, structure)
 73 {
 74 }
 75 
 76 void MathObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 77 {
 78     Base::finishCreation(vm);
 79     ASSERT(inherits(vm, info()));
 80 
 81     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;E&quot;), jsNumber(Math::exp(1.0)), PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 82     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;LN2&quot;), jsNumber(Math::log(2.0)), PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 83     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;LN10&quot;), jsNumber(Math::log(10.0)), PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 84     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;LOG2E&quot;), jsNumber(1.0 / Math::log(2.0)), PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 85     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;LOG10E&quot;), jsNumber(0.4342944819032518), PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 86     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;PI&quot;), jsNumber(piDouble), PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 87     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;SQRT1_2&quot;), jsNumber(sqrt(0.5)), PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 88     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;SQRT2&quot;), jsNumber(sqrt(2.0)), PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
<span class="line-modified"> 89     putDirectWithoutTransition(vm, vm.propertyNames-&gt;toStringTagSymbol, jsNontrivialString(vm, &quot;Math&quot;_s), PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);</span>
 90 
 91     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;abs&quot;), 1, mathProtoFuncAbs, AbsIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 92     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;acos&quot;), 1, mathProtoFuncACos, ACosIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 93     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;asin&quot;), 1, mathProtoFuncASin, ASinIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 94     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;atan&quot;), 1, mathProtoFuncATan, ATanIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 95     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;acosh&quot;), 1, mathProtoFuncACosh, ACoshIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 96     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;asinh&quot;), 1, mathProtoFuncASinh, ASinhIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 97     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;atanh&quot;), 1, mathProtoFuncATanh, ATanhIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 98     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;atan2&quot;), 2, mathProtoFuncATan2, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 99     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;cbrt&quot;), 1, mathProtoFuncCbrt, CbrtIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
100     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;ceil&quot;), 1, mathProtoFuncCeil, CeilIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
101     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;clz32&quot;), 1, mathProtoFuncClz32, Clz32Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
102     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;cos&quot;), 1, mathProtoFuncCos, CosIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
103     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;cosh&quot;), 1, mathProtoFuncCosh, CoshIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
104     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;exp&quot;), 1, mathProtoFuncExp, ExpIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
105     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;expm1&quot;), 1, mathProtoFuncExpm1, Expm1Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
106     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;floor&quot;), 1, mathProtoFuncFloor, FloorIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
107     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;fround&quot;), 1, mathProtoFuncFround, FRoundIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
108     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;hypot&quot;), 2, mathProtoFuncHypot, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
109     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;log&quot;), 1, mathProtoFuncLog, LogIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
110     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;log10&quot;), 1, mathProtoFuncLog10, Log10Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
111     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;log1p&quot;), 1, mathProtoFuncLog1p, Log1pIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
112     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;log2&quot;), 1, mathProtoFuncLog2, Log2Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
113     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;max&quot;), 2, mathProtoFuncMax, MaxIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
114     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;min&quot;), 2, mathProtoFuncMin, MinIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
115     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;pow&quot;), 2, mathProtoFuncPow, PowIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
116     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;random&quot;), 0, mathProtoFuncRandom, RandomIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
117     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;round&quot;), 1, mathProtoFuncRound, RoundIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
118     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;sign&quot;), 1, mathProtoFuncSign, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
119     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;sin&quot;), 1, mathProtoFuncSin, SinIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
120     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;sinh&quot;), 1, mathProtoFuncSinh, SinhIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
121     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;sqrt&quot;), 1, mathProtoFuncSqrt, SqrtIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
122     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;tan&quot;), 1, mathProtoFuncTan, TanIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
123     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;tanh&quot;), 1, mathProtoFuncTanh, TanhIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
124     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;trunc&quot;), 1, mathProtoFuncTrunc, TruncIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
125     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, &quot;imul&quot;), 2, mathProtoFuncIMul, IMulIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
126 }
127 
128 // ------------------------------ Functions --------------------------------
129 
<span class="line-modified">130 EncodedJSValue JSC_HOST_CALL mathProtoFuncAbs(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
131 {
<span class="line-modified">132     return JSValue::encode(jsNumber(fabs(callFrame-&gt;argument(0).toNumber(globalObject))));</span>
133 }
134 
<span class="line-modified">135 EncodedJSValue JSC_HOST_CALL mathProtoFuncACos(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
136 {
<span class="line-modified">137     return JSValue::encode(jsDoubleNumber(Math::acos(callFrame-&gt;argument(0).toNumber(globalObject))));</span>
138 }
139 
<span class="line-modified">140 EncodedJSValue JSC_HOST_CALL mathProtoFuncASin(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
141 {
<span class="line-modified">142     return JSValue::encode(jsDoubleNumber(Math::asin(callFrame-&gt;argument(0).toNumber(globalObject))));</span>
143 }
144 
<span class="line-modified">145 EncodedJSValue JSC_HOST_CALL mathProtoFuncATan(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
146 {
<span class="line-modified">147     return JSValue::encode(jsDoubleNumber(Math::atan(callFrame-&gt;argument(0).toNumber(globalObject))));</span>
148 }
149 
<span class="line-modified">150 EncodedJSValue JSC_HOST_CALL mathProtoFuncATan2(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
151 {
<span class="line-modified">152     VM&amp; vm = globalObject-&gt;vm();</span>
153     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">154     double arg0 = callFrame-&gt;argument(0).toNumber(globalObject);</span>
155     RETURN_IF_EXCEPTION(scope, encodedJSValue());
156     scope.release();
<span class="line-modified">157     double arg1 = callFrame-&gt;argument(1).toNumber(globalObject);</span>
158     return JSValue::encode(jsDoubleNumber(atan2(arg0, arg1)));
159 }
160 
<span class="line-modified">161 EncodedJSValue JSC_HOST_CALL mathProtoFuncCeil(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
162 {
<span class="line-modified">163     return JSValue::encode(jsNumber(ceil(callFrame-&gt;argument(0).toNumber(globalObject))));</span>
164 }
165 
<span class="line-modified">166 EncodedJSValue JSC_HOST_CALL mathProtoFuncClz32(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
167 {
<span class="line-modified">168     VM&amp; vm = globalObject-&gt;vm();</span>
169     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">170     uint32_t value = callFrame-&gt;argument(0).toUInt32(globalObject);</span>
171     RETURN_IF_EXCEPTION(scope, encodedJSValue());
172     return JSValue::encode(JSValue(clz(value)));
173 }
174 
<span class="line-modified">175 EncodedJSValue JSC_HOST_CALL mathProtoFuncCos(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
176 {
<span class="line-modified">177     return JSValue::encode(jsDoubleNumber(Math::cos(callFrame-&gt;argument(0).toNumber(globalObject))));</span>
178 }
179 
<span class="line-modified">180 EncodedJSValue JSC_HOST_CALL mathProtoFuncExp(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
181 {
<span class="line-modified">182     return JSValue::encode(jsDoubleNumber(Math::exp(callFrame-&gt;argument(0).toNumber(globalObject))));</span>
183 }
184 
<span class="line-modified">185 EncodedJSValue JSC_HOST_CALL mathProtoFuncFloor(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
186 {
<span class="line-modified">187     return JSValue::encode(jsNumber(floor(callFrame-&gt;argument(0).toNumber(globalObject))));</span>
188 }
189 
<span class="line-modified">190 EncodedJSValue JSC_HOST_CALL mathProtoFuncHypot(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
191 {
<span class="line-modified">192     VM&amp; vm = globalObject-&gt;vm();</span>
193     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">194     unsigned argsCount = callFrame-&gt;argumentCount();</span>
195     double max = 0;
196     Vector&lt;double, 8&gt; args;
197     args.reserveInitialCapacity(argsCount);
198     for (unsigned i = 0; i &lt; argsCount; ++i) {
<span class="line-modified">199         args.uncheckedAppend(callFrame-&gt;uncheckedArgument(i).toNumber(globalObject));</span>
200         RETURN_IF_EXCEPTION(scope, encodedJSValue());
201         if (std::isinf(args[i]))
202             return JSValue::encode(jsDoubleNumber(+std::numeric_limits&lt;double&gt;::infinity()));
203         max = std::max(fabs(args[i]), max);
204     }
205     if (!max)
206         max = 1;
207     // Kahan summation algorithm significantly reduces the numerical error in the total obtained.
208     double sum = 0;
209     double compensation = 0;
210     for (double argument : args) {
211         double scaledArgument = argument / max;
212         double summand = scaledArgument * scaledArgument - compensation;
213         double preliminary = sum + summand;
214         compensation = (preliminary - sum) - summand;
215         sum = preliminary;
216     }
217     return JSValue::encode(jsDoubleNumber(sqrt(sum) * max));
218 }
219 
<span class="line-modified">220 EncodedJSValue JSC_HOST_CALL mathProtoFuncLog(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
221 {
<span class="line-modified">222     return JSValue::encode(jsDoubleNumber(Math::log(callFrame-&gt;argument(0).toNumber(globalObject))));</span>
223 }
224 
<span class="line-modified">225 EncodedJSValue JSC_HOST_CALL mathProtoFuncMax(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
226 {
<span class="line-modified">227     VM&amp; vm = globalObject-&gt;vm();</span>
228     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">229     unsigned argsCount = callFrame-&gt;argumentCount();</span>
230     double result = -std::numeric_limits&lt;double&gt;::infinity();
231     for (unsigned k = 0; k &lt; argsCount; ++k) {
<span class="line-modified">232         double val = callFrame-&gt;uncheckedArgument(k).toNumber(globalObject);</span>
233         RETURN_IF_EXCEPTION(scope, encodedJSValue());
234         if (std::isnan(val)) {
235             result = PNaN;
236         } else if (val &gt; result || (!val &amp;&amp; !result &amp;&amp; !std::signbit(val)))
237             result = val;
238     }
239     return JSValue::encode(jsNumber(result));
240 }
241 
<span class="line-modified">242 EncodedJSValue JSC_HOST_CALL mathProtoFuncMin(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
243 {
<span class="line-modified">244     VM&amp; vm = globalObject-&gt;vm();</span>
245     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">246     unsigned argsCount = callFrame-&gt;argumentCount();</span>
247     double result = +std::numeric_limits&lt;double&gt;::infinity();
248     for (unsigned k = 0; k &lt; argsCount; ++k) {
<span class="line-modified">249         double val = callFrame-&gt;uncheckedArgument(k).toNumber(globalObject);</span>
250         RETURN_IF_EXCEPTION(scope, encodedJSValue());
251         if (std::isnan(val)) {
252             result = PNaN;
253         } else if (val &lt; result || (!val &amp;&amp; !result &amp;&amp; std::signbit(val)))
254             result = val;
255     }
256     return JSValue::encode(jsNumber(result));
257 }
258 
<span class="line-modified">259 EncodedJSValue JSC_HOST_CALL mathProtoFuncPow(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
260 {
261     // ECMA 15.8.2.1.13
262 
<span class="line-modified">263     VM&amp; vm = globalObject-&gt;vm();</span>
264     auto scope = DECLARE_THROW_SCOPE(vm);
265 
<span class="line-modified">266     double arg = callFrame-&gt;argument(0).toNumber(globalObject);</span>
267     RETURN_IF_EXCEPTION(scope, encodedJSValue());
268     scope.release();
<span class="line-modified">269     double arg2 = callFrame-&gt;argument(1).toNumber(globalObject);</span>
270 
271     return JSValue::encode(JSValue(operationMathPow(arg, arg2)));
272 }
273 
<span class="line-modified">274 EncodedJSValue JSC_HOST_CALL mathProtoFuncRandom(JSGlobalObject* globalObject, CallFrame*)</span>
275 {
<span class="line-modified">276     return JSValue::encode(jsDoubleNumber(globalObject-&gt;weakRandomNumber()));</span>
277 }
278 
<span class="line-modified">279 EncodedJSValue JSC_HOST_CALL mathProtoFuncRound(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
280 {
<span class="line-modified">281     return JSValue::encode(jsNumber(jsRound(callFrame-&gt;argument(0).toNumber(globalObject))));</span>
282 }
283 
<span class="line-modified">284 EncodedJSValue JSC_HOST_CALL mathProtoFuncSign(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
285 {
<span class="line-modified">286     double arg = callFrame-&gt;argument(0).toNumber(globalObject);</span>
287     if (std::isnan(arg))
288         return JSValue::encode(jsNaN());
289     if (!arg)
290         return JSValue::encode(std::signbit(arg) ? jsNumber(-0.0) : jsNumber(0));
291     return JSValue::encode(jsNumber(std::signbit(arg) ? -1 : 1));
292 }
293 
<span class="line-modified">294 EncodedJSValue JSC_HOST_CALL mathProtoFuncSin(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
295 {
<span class="line-modified">296     return JSValue::encode(jsDoubleNumber(Math::sin(callFrame-&gt;argument(0).toNumber(globalObject))));</span>
297 }
298 
<span class="line-modified">299 EncodedJSValue JSC_HOST_CALL mathProtoFuncSqrt(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
300 {
<span class="line-modified">301     return JSValue::encode(jsDoubleNumber(sqrt(callFrame-&gt;argument(0).toNumber(globalObject))));</span>
302 }
303 
<span class="line-modified">304 EncodedJSValue JSC_HOST_CALL mathProtoFuncTan(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
305 {
<span class="line-modified">306     return JSValue::encode(jsDoubleNumber(Math::tan(callFrame-&gt;argument(0).toNumber(globalObject))));</span>
307 }
308 
<span class="line-modified">309 EncodedJSValue JSC_HOST_CALL mathProtoFuncIMul(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
310 {
<span class="line-modified">311     VM&amp; vm = globalObject-&gt;vm();</span>
312     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">313     int32_t left = callFrame-&gt;argument(0).toInt32(globalObject);</span>
314     RETURN_IF_EXCEPTION(scope, encodedJSValue());
315     scope.release();
<span class="line-modified">316     int32_t right = callFrame-&gt;argument(1).toInt32(globalObject);</span>
317     return JSValue::encode(jsNumber(left * right));
318 }
319 
<span class="line-modified">320 EncodedJSValue JSC_HOST_CALL mathProtoFuncACosh(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
321 {
<span class="line-modified">322     return JSValue::encode(jsDoubleNumber(Math::acosh(callFrame-&gt;argument(0).toNumber(globalObject))));</span>
323 }
324 
<span class="line-modified">325 EncodedJSValue JSC_HOST_CALL mathProtoFuncASinh(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
326 {
<span class="line-modified">327     return JSValue::encode(jsDoubleNumber(Math::asinh(callFrame-&gt;argument(0).toNumber(globalObject))));</span>
328 }
329 
<span class="line-modified">330 EncodedJSValue JSC_HOST_CALL mathProtoFuncATanh(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
331 {
<span class="line-modified">332     return JSValue::encode(jsDoubleNumber(Math::atanh(callFrame-&gt;argument(0).toNumber(globalObject))));</span>
333 }
334 
<span class="line-modified">335 EncodedJSValue JSC_HOST_CALL mathProtoFuncCbrt(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
336 {
<span class="line-modified">337     return JSValue::encode(jsDoubleNumber(Math::cbrt(callFrame-&gt;argument(0).toNumber(globalObject))));</span>
338 }
339 
<span class="line-modified">340 EncodedJSValue JSC_HOST_CALL mathProtoFuncCosh(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
341 {
<span class="line-modified">342     return JSValue::encode(jsDoubleNumber(Math::cosh(callFrame-&gt;argument(0).toNumber(globalObject))));</span>
343 }
344 
<span class="line-modified">345 EncodedJSValue JSC_HOST_CALL mathProtoFuncExpm1(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
346 {
<span class="line-modified">347     return JSValue::encode(jsDoubleNumber(Math::expm1(callFrame-&gt;argument(0).toNumber(globalObject))));</span>
348 }
349 
<span class="line-modified">350 EncodedJSValue JSC_HOST_CALL mathProtoFuncFround(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
351 {
<span class="line-modified">352     return JSValue::encode(jsDoubleNumber(static_cast&lt;float&gt;(callFrame-&gt;argument(0).toNumber(globalObject))));</span>
353 }
354 
<span class="line-modified">355 EncodedJSValue JSC_HOST_CALL mathProtoFuncLog1p(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
356 {
<span class="line-modified">357     return JSValue::encode(jsDoubleNumber(Math::log1p(callFrame-&gt;argument(0).toNumber(globalObject))));</span>
358 }
359 
<span class="line-modified">360 EncodedJSValue JSC_HOST_CALL mathProtoFuncLog10(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
361 {
<span class="line-modified">362     return JSValue::encode(jsDoubleNumber(Math::log10(callFrame-&gt;argument(0).toNumber(globalObject))));</span>
363 }
364 
<span class="line-modified">365 EncodedJSValue JSC_HOST_CALL mathProtoFuncLog2(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
366 {
<span class="line-modified">367     return JSValue::encode(jsDoubleNumber(Math::log2(callFrame-&gt;argument(0).toNumber(globalObject))));</span>
368 }
369 
<span class="line-modified">370 EncodedJSValue JSC_HOST_CALL mathProtoFuncSinh(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
371 {
<span class="line-modified">372     return JSValue::encode(jsDoubleNumber(Math::sinh(callFrame-&gt;argument(0).toNumber(globalObject))));</span>
373 }
374 
<span class="line-modified">375 EncodedJSValue JSC_HOST_CALL mathProtoFuncTanh(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
376 {
<span class="line-modified">377     return JSValue::encode(jsDoubleNumber(Math::tanh(callFrame-&gt;argument(0).toNumber(globalObject))));</span>
378 }
379 
<span class="line-modified">380 EncodedJSValue JSC_HOST_CALL mathProtoFuncTrunc(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
381 {
<span class="line-modified">382     return JSValue::encode(jsNumber(callFrame-&gt;argument(0).toIntegerPreserveNaN(globalObject)));</span>
383 }
384 
385 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="MathCommon.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MathObject.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/page/FrameView.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 1998, 1999 Torben Weis &lt;weis@kde.org&gt;
   3  *                     1999 Lars Knoll &lt;knoll@kde.org&gt;
   4  *                     1999 Antti Koivisto &lt;koivisto@kde.org&gt;
   5  *                     2000 Dirk Mueller &lt;mueller@kde.org&gt;
   6  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   7  *           (C) 2006 Graham Dennis (graham.dennis@gmail.com)
   8  *           (C) 2006 Alexey Proskuryakov (ap@nypop.com)
   9  * Copyright (C) 2009 Google Inc. All rights reserved.
  10  *
  11  * This library is free software; you can redistribute it and/or
  12  * modify it under the terms of the GNU Library General Public
  13  * License as published by the Free Software Foundation; either
  14  * version 2 of the License, or (at your option) any later version.
  15  *
  16  * This library is distributed in the hope that it will be useful,
  17  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  18  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  19  * Library General Public License for more details.
  20  *
  21  * You should have received a copy of the GNU Library General Public License
  22  * along with this library; see the file COPYING.LIB.  If not, write to
  23  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  24  * Boston, MA 02110-1301, USA.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;FrameView.h&quot;
  29 
  30 #include &quot;AXObjectCache.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  31 #include &quot;BackForwardCache.h&quot;</span>
  32 #include &quot;BackForwardController.h&quot;
  33 #include &quot;CSSAnimationController.h&quot;
  34 #include &quot;CachedImage.h&quot;
  35 #include &quot;CachedResourceLoader.h&quot;
  36 #include &quot;Chrome.h&quot;
  37 #include &quot;ChromeClient.h&quot;
  38 #include &quot;CustomHeaderFields.h&quot;
  39 #include &quot;DOMWindow.h&quot;
  40 #include &quot;DebugPageOverlays.h&quot;
  41 #include &quot;DeprecatedGlobalSettings.h&quot;
  42 #include &quot;DocumentLoader.h&quot;
  43 #include &quot;DocumentMarkerController.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  44 #include &quot;Editor.h&quot;</span>
  45 #include &quot;EventHandler.h&quot;
  46 #include &quot;EventNames.h&quot;
  47 #include &quot;FloatRect.h&quot;
  48 #include &quot;FocusController.h&quot;
  49 #include &quot;Frame.h&quot;
  50 #include &quot;FrameLoader.h&quot;
  51 #include &quot;FrameLoaderClient.h&quot;
  52 #include &quot;FrameSelection.h&quot;
  53 #include &quot;FrameTree.h&quot;
  54 #include &quot;GraphicsContext.h&quot;
  55 #include &quot;HTMLBodyElement.h&quot;
  56 #include &quot;HTMLEmbedElement.h&quot;
  57 #include &quot;HTMLFrameElement.h&quot;
  58 #include &quot;HTMLFrameSetElement.h&quot;
  59 #include &quot;HTMLHtmlElement.h&quot;
  60 #include &quot;HTMLIFrameElement.h&quot;
  61 #include &quot;HTMLNames.h&quot;
  62 #include &quot;HTMLObjectElement.h&quot;
  63 #include &quot;HTMLParserIdioms.h&quot;
  64 #include &quot;HTMLPlugInImageElement.h&quot;
  65 #include &quot;ImageDocument.h&quot;
  66 #include &quot;InspectorClient.h&quot;
  67 #include &quot;InspectorController.h&quot;
  68 #include &quot;InspectorInstrumentation.h&quot;
  69 #include &quot;Logging.h&quot;
  70 #include &quot;MemoryCache.h&quot;
  71 #include &quot;OverflowEvent.h&quot;
  72 #include &quot;Page.h&quot;
<a name="3" id="anc3"></a>
  73 #include &quot;PageOverlayController.h&quot;
  74 #include &quot;ProgressTracker.h&quot;
  75 #include &quot;RenderEmbeddedObject.h&quot;
  76 #include &quot;RenderFullScreen.h&quot;
  77 #include &quot;RenderIFrame.h&quot;
  78 #include &quot;RenderInline.h&quot;
  79 #include &quot;RenderLayer.h&quot;
  80 #include &quot;RenderLayerBacking.h&quot;
  81 #include &quot;RenderLayerCompositor.h&quot;
  82 #include &quot;RenderSVGRoot.h&quot;
  83 #include &quot;RenderScrollbar.h&quot;
  84 #include &quot;RenderScrollbarPart.h&quot;
  85 #include &quot;RenderStyle.h&quot;
  86 #include &quot;RenderText.h&quot;
  87 #include &quot;RenderTheme.h&quot;
  88 #include &quot;RenderView.h&quot;
  89 #include &quot;RenderWidget.h&quot;
  90 #include &quot;ResizeObserver.h&quot;
  91 #include &quot;RuntimeEnabledFeatures.h&quot;
  92 #include &quot;SVGDocument.h&quot;
  93 #include &quot;SVGSVGElement.h&quot;
  94 #include &quot;ScriptRunner.h&quot;
  95 #include &quot;ScriptedAnimationController.h&quot;
  96 #include &quot;ScrollAnimator.h&quot;
  97 #include &quot;ScrollingCoordinator.h&quot;
  98 #include &quot;Settings.h&quot;
  99 #include &quot;StyleResolver.h&quot;
 100 #include &quot;StyleScope.h&quot;
 101 #include &quot;TextResourceDecoder.h&quot;
 102 #include &quot;TiledBacking.h&quot;
 103 #include &quot;VelocityData.h&quot;
 104 #include &quot;VisualViewport.h&quot;
<a name="4" id="anc4"></a><span class="line-modified"> 105 #include &quot;WheelEventTestMonitor.h&quot;</span>
 106 #include &lt;wtf/text/TextStream.h&gt;
 107 
 108 #include &lt;wtf/IsoMallocInlines.h&gt;
 109 #include &lt;wtf/MemoryPressureHandler.h&gt;
 110 #include &lt;wtf/Ref.h&gt;
 111 #include &lt;wtf/SetForScope.h&gt;
 112 #include &lt;wtf/SystemTracing.h&gt;
 113 
 114 #if USE(COORDINATED_GRAPHICS)
 115 #include &quot;TiledBackingStore.h&quot;
 116 #endif
 117 
 118 #if ENABLE(CSS_SCROLL_SNAP)
 119 #include &quot;AxisScrollSnapOffsets.h&quot;
 120 #endif
 121 
 122 #if PLATFORM(IOS_FAMILY)
 123 #include &quot;DocumentLoader.h&quot;
 124 #include &quot;LegacyTileCache.h&quot;
 125 #endif
 126 
 127 #if PLATFORM(MAC)
 128 #include &quot;LocalDefaultSystemAppearance.h&quot;
 129 #endif
 130 
<a name="5" id="anc5"></a><span class="line-modified"> 131 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added"> 132 #include &quot;LayoutContext.h&quot;</span>
<span class="line-added"> 133 #endif</span>
<span class="line-added"> 134 </span>
<span class="line-added"> 135 #define FRAMEVIEW_RELEASE_LOG_IF_ALLOWED(channel, fmt, ...) RELEASE_LOG_IF(frame().page() &amp;&amp; frame().page()-&gt;isAlwaysOnLoggingAllowed(), channel, &quot;%p - [frame=%p, main=%d] FrameView::&quot; fmt, this, &amp;frame(), frame().isMainFrame(), ##__VA_ARGS__)</span>
 136 
 137 namespace WebCore {
 138 
 139 using namespace HTMLNames;
 140 
 141 WTF_MAKE_ISO_ALLOCATED_IMPL(FrameView);
 142 
 143 MonotonicTime FrameView::sCurrentPaintTimeStamp { };
 144 
 145 // The maximum number of updateEmbeddedObjects iterations that should be done before returning.
 146 static const unsigned maxUpdateEmbeddedObjectsIterations = 2;
 147 
 148 static constexpr unsigned defaultSignificantRenderedTextCharacterThreshold = 3000;
 149 static constexpr float defaultSignificantRenderedTextMeanLength = 50;
 150 static constexpr unsigned mainArticleSignificantRenderedTextCharacterThreshold = 1500;
 151 static constexpr float mainArticleSignificantRenderedTextMeanLength = 25;
 152 
 153 Pagination::Mode paginationModeForRenderStyle(const RenderStyle&amp; style)
 154 {
 155     Overflow overflow = style.overflowY();
 156     if (overflow != Overflow::PagedX &amp;&amp; overflow != Overflow::PagedY)
 157         return Pagination::Unpaginated;
 158 
 159     bool isHorizontalWritingMode = style.isHorizontalWritingMode();
 160     TextDirection textDirection = style.direction();
 161     WritingMode writingMode = style.writingMode();
 162 
 163     // paged-x always corresponds to LeftToRightPaginated or RightToLeftPaginated. If the WritingMode
 164     // is horizontal, then we use TextDirection to choose between those options. If the WritingMode
 165     // is vertical, then the direction of the verticality dictates the choice.
 166     if (overflow == Overflow::PagedX) {
 167         if ((isHorizontalWritingMode &amp;&amp; textDirection == TextDirection::LTR) || writingMode == LeftToRightWritingMode)
 168             return Pagination::LeftToRightPaginated;
 169         return Pagination::RightToLeftPaginated;
 170     }
 171 
 172     // paged-y always corresponds to TopToBottomPaginated or BottomToTopPaginated. If the WritingMode
 173     // is horizontal, then the direction of the horizontality dictates the choice. If the WritingMode
 174     // is vertical, then we use TextDirection to choose between those options.
 175     if (writingMode == TopToBottomWritingMode || (!isHorizontalWritingMode &amp;&amp; textDirection == TextDirection::RTL))
 176         return Pagination::TopToBottomPaginated;
 177     return Pagination::BottomToTopPaginated;
 178 }
 179 
 180 FrameView::FrameView(Frame&amp; frame)
 181     : m_frame(frame)
 182     , m_layoutContext(*this)
 183     , m_updateEmbeddedObjectsTimer(*this, &amp;FrameView::updateEmbeddedObjectsTimerFired)
 184     , m_updateWidgetPositionsTimer(*this, &amp;FrameView::updateWidgetPositionsTimerFired)
 185     , m_delayedScrollEventTimer(*this, &amp;FrameView::sendScrollEvent)
 186     , m_delayedScrollToFocusedElementTimer(*this, &amp;FrameView::scrollToFocusedElementTimerFired)
 187     , m_speculativeTilingEnableTimer(*this, &amp;FrameView::speculativeTilingEnableTimerFired)
 188 {
 189     init();
 190 
 191 #if ENABLE(RUBBER_BANDING)
 192     ScrollElasticity verticalElasticity = ScrollElasticityNone;
 193     ScrollElasticity horizontalElasticity = ScrollElasticityNone;
 194     if (m_frame-&gt;isMainFrame()) {
 195         verticalElasticity = m_frame-&gt;page() ? m_frame-&gt;page()-&gt;verticalScrollElasticity() : ScrollElasticityAllowed;
 196         horizontalElasticity = m_frame-&gt;page() ? m_frame-&gt;page()-&gt;horizontalScrollElasticity() : ScrollElasticityAllowed;
 197     } else if (m_frame-&gt;settings().rubberBandingForSubScrollableRegionsEnabled()) {
 198         verticalElasticity = ScrollElasticityAutomatic;
 199         horizontalElasticity = ScrollElasticityAutomatic;
 200     }
 201 
 202     ScrollableArea::setVerticalScrollElasticity(verticalElasticity);
 203     ScrollableArea::setHorizontalScrollElasticity(horizontalElasticity);
 204 #endif
 205 }
 206 
 207 Ref&lt;FrameView&gt; FrameView::create(Frame&amp; frame)
 208 {
 209     Ref&lt;FrameView&gt; view = adoptRef(*new FrameView(frame));
 210     if (frame.page() &amp;&amp; frame.page()-&gt;isVisible())
 211         view-&gt;show();
 212     return view;
 213 }
 214 
 215 Ref&lt;FrameView&gt; FrameView::create(Frame&amp; frame, const IntSize&amp; initialSize)
 216 {
 217     Ref&lt;FrameView&gt; view = adoptRef(*new FrameView(frame));
 218     view-&gt;Widget::setFrameRect(IntRect(view-&gt;location(), initialSize));
 219     if (frame.page() &amp;&amp; frame.page()-&gt;isVisible())
 220         view-&gt;show();
 221     return view;
 222 }
 223 
 224 FrameView::~FrameView()
 225 {
 226     removeFromAXObjectCache();
 227     resetScrollbars();
 228 
 229     // Custom scrollbars should already be destroyed at this point
 230     ASSERT(!horizontalScrollbar() || !horizontalScrollbar()-&gt;isCustomScrollbar());
 231     ASSERT(!verticalScrollbar() || !verticalScrollbar()-&gt;isCustomScrollbar());
 232 
 233     setHasHorizontalScrollbar(false); // Remove native scrollbars now before we lose the connection to the HostWindow.
 234     setHasVerticalScrollbar(false);
 235 
 236     ASSERT(!m_scrollCorner);
 237 
 238     ASSERT(frame().view() != this || !frame().contentRenderer());
 239 }
 240 
 241 void FrameView::reset()
 242 {
 243     m_cannotBlitToWindow = false;
 244     m_isOverlapped = false;
 245     m_contentIsOpaque = false;
 246     m_updateEmbeddedObjectsTimer.stop();
 247     m_wasScrolledByUser = false;
 248     m_delayedScrollEventTimer.stop();
 249     m_shouldScrollToFocusedElement = false;
 250     m_delayedScrollToFocusedElementTimer.stop();
 251     m_lastViewportSize = IntSize();
 252     m_lastZoomFactor = 1.0f;
 253     m_isTrackingRepaints = false;
 254     m_trackedRepaintRects.clear();
 255     m_lastPaintTime = MonotonicTime();
 256     m_paintBehavior = PaintBehavior::Normal;
 257     m_isPainting = false;
 258     m_needsDeferredScrollbarsUpdate = false;
 259     m_maintainScrollPositionAnchor = nullptr;
 260     resetLayoutMilestones();
 261     layoutContext().reset();
 262 }
 263 
 264 void FrameView::resetLayoutMilestones()
 265 {
 266     m_firstLayoutCallbackPending = false;
 267     m_isVisuallyNonEmpty = false;
 268     m_hasReachedSignificantRenderedTextThreshold = false;
 269     m_renderedSignificantAmountOfText = false;
 270     m_visuallyNonEmptyCharacterCount = 0;
 271     m_visuallyNonEmptyPixelCount = 0;
 272     m_textRendererCountForVisuallyNonEmptyCharacters = 0;
 273 }
 274 
 275 void FrameView::removeFromAXObjectCache()
 276 {
 277     if (AXObjectCache* cache = axObjectCache()) {
 278         if (HTMLFrameOwnerElement* owner = frame().ownerElement())
 279             cache-&gt;childrenChanged(owner-&gt;renderer());
 280         cache-&gt;remove(this);
 281     }
 282 }
 283 
 284 void FrameView::resetScrollbars()
 285 {
 286     // FIXME: Do we really need this?
 287     layoutContext().resetFirstLayoutFlag();
 288     // Reset the document&#39;s scrollbars back to our defaults before we yield the floor.
 289     setScrollbarsSuppressed(true);
 290     if (m_canHaveScrollbars)
 291         setScrollbarModes(ScrollbarAuto, ScrollbarAuto);
 292     else
 293         setScrollbarModes(ScrollbarAlwaysOff, ScrollbarAlwaysOff);
 294     setScrollbarsSuppressed(false);
 295 }
 296 
 297 void FrameView::resetScrollbarsAndClearContentsSize()
 298 {
 299     resetScrollbars();
 300 
 301     LOG(Layout, &quot;FrameView %p resetScrollbarsAndClearContentsSize&quot;, this);
 302 
 303     setScrollbarsSuppressed(true);
 304     setContentsSize(IntSize());
 305     setScrollbarsSuppressed(false);
 306 }
 307 
 308 void FrameView::init()
 309 {
 310     reset();
 311 
 312     m_size = LayoutSize();
 313 
 314     // Propagate the scrolling mode to the view.
 315     auto* ownerElement = frame().ownerElement();
 316     if (is&lt;HTMLFrameElementBase&gt;(ownerElement) &amp;&amp; downcast&lt;HTMLFrameElementBase&gt;(*ownerElement).scrollingMode() == ScrollbarAlwaysOff)
 317         setCanHaveScrollbars(false);
 318 
 319     Page* page = frame().page();
 320     if (page &amp;&amp; page-&gt;chrome().client().shouldPaintEntireContents())
 321         setPaintsEntireContents(true);
 322 }
 323 
 324 void FrameView::prepareForDetach()
 325 {
 326     detachCustomScrollbars();
 327     // When the view is no longer associated with a frame, it needs to be removed from the ax object cache
 328     // right now, otherwise it won&#39;t be able to reach the topDocument()&#39;s axObject cache later.
 329     removeFromAXObjectCache();
 330 
 331     if (frame().page()) {
 332         if (ScrollingCoordinator* scrollingCoordinator = frame().page()-&gt;scrollingCoordinator())
 333             scrollingCoordinator-&gt;willDestroyScrollableArea(*this);
 334     }
 335 }
 336 
 337 void FrameView::detachCustomScrollbars()
 338 {
 339     Scrollbar* horizontalBar = horizontalScrollbar();
 340     if (horizontalBar &amp;&amp; horizontalBar-&gt;isCustomScrollbar())
 341         setHasHorizontalScrollbar(false);
 342 
 343     Scrollbar* verticalBar = verticalScrollbar();
 344     if (verticalBar &amp;&amp; verticalBar-&gt;isCustomScrollbar())
 345         setHasVerticalScrollbar(false);
 346 
 347     m_scrollCorner = nullptr;
 348 }
 349 
 350 void FrameView::recalculateScrollbarOverlayStyle()
 351 {
 352     ScrollbarOverlayStyle oldOverlayStyle = scrollbarOverlayStyle();
 353     Optional&lt;ScrollbarOverlayStyle&gt; clientOverlayStyle = frame().page() ? frame().page()-&gt;chrome().client().preferredScrollbarOverlayStyle() : WTF::nullopt;
 354     if (clientOverlayStyle) {
 355         if (clientOverlayStyle.value() != oldOverlayStyle)
 356             setScrollbarOverlayStyle(clientOverlayStyle.value());
 357         return;
 358     }
 359 
 360     ScrollbarOverlayStyle computedOverlayStyle = ScrollbarOverlayStyleDefault;
 361 
 362     Color backgroundColor = documentBackgroundColor();
 363     if (backgroundColor.isValid()) {
 364         // Reduce the background color from RGB to a lightness value
 365         // and determine which scrollbar style to use based on a lightness
 366         // heuristic.
 367         double hue, saturation, lightness;
 368         backgroundColor.getHSL(hue, saturation, lightness);
 369         if (lightness &lt;= .5 &amp;&amp; backgroundColor.isVisible())
 370             computedOverlayStyle = ScrollbarOverlayStyleLight;
 371         else if (!backgroundColor.isVisible() &amp;&amp; useDarkAppearance())
 372             computedOverlayStyle = ScrollbarOverlayStyleLight;
 373     }
 374 
 375     if (oldOverlayStyle != computedOverlayStyle)
 376         setScrollbarOverlayStyle(computedOverlayStyle);
 377 }
 378 
 379 #if ENABLE(DARK_MODE_CSS)
 380 void FrameView::recalculateBaseBackgroundColor()
 381 {
 382     bool usingDarkAppearance = useDarkAppearance();
 383     if (m_usesDarkAppearance == usingDarkAppearance)
 384         return;
 385 
 386     m_usesDarkAppearance = usingDarkAppearance;
 387     Optional&lt;Color&gt; backgroundColor;
 388     if (m_isTransparent)
 389         backgroundColor = Color(Color::transparent);
 390     updateBackgroundRecursively(backgroundColor);
 391 }
 392 #endif
 393 
 394 void FrameView::clear()
 395 {
 396     setCanBlitOnScroll(true);
 397 
 398     reset();
 399 
 400     setScrollbarsSuppressed(true);
 401 
 402 #if PLATFORM(IOS_FAMILY)
 403     // To avoid flashes of white, disable tile updates immediately when view is cleared at the beginning of a page load.
 404     // Tiling will be re-enabled from UIKit via [WAKWindow setTilingMode:] when we have content to draw.
 405     if (LegacyTileCache* tileCache = legacyTileCache())
 406         tileCache-&gt;setTilingMode(LegacyTileCache::Disabled);
 407 #endif
 408 }
 409 
 410 #if PLATFORM(IOS_FAMILY)
 411 void FrameView::didReplaceMultipartContent()
 412 {
 413     // Re-enable tile updates that were disabled in clear().
 414     if (LegacyTileCache* tileCache = legacyTileCache())
 415         tileCache-&gt;setTilingMode(LegacyTileCache::Normal);
 416 }
 417 #endif
 418 
 419 bool FrameView::didFirstLayout() const
 420 {
 421     return layoutContext().didFirstLayout();
 422 }
 423 
 424 void FrameView::invalidateRect(const IntRect&amp; rect)
 425 {
 426     if (!parent()) {
 427         if (auto* page = frame().page())
 428             page-&gt;chrome().invalidateContentsAndRootView(rect);
 429         return;
 430     }
 431 
 432     auto* renderer = frame().ownerRenderer();
 433     if (!renderer)
 434         return;
 435 
 436     IntRect repaintRect = rect;
 437     repaintRect.moveBy(roundedIntPoint(renderer-&gt;contentBoxLocation()));
 438     renderer-&gt;repaintRectangle(repaintRect);
 439 }
 440 
 441 void FrameView::setFrameRect(const IntRect&amp; newRect)
 442 {
 443     Ref&lt;FrameView&gt; protectedThis(*this);
 444     IntRect oldRect = frameRect();
 445     if (newRect == oldRect)
 446         return;
 447 
 448     // Every scroll that happens as the result of frame size change is programmatic.
 449     auto oldScrollType = currentScrollType();
 450     setCurrentScrollType(ScrollType::Programmatic);
 451 
 452     ScrollView::setFrameRect(newRect);
 453 
 454     updateScrollableAreaSet();
 455 
 456     if (RenderView* renderView = this-&gt;renderView()) {
 457         if (renderView-&gt;usesCompositing())
 458             renderView-&gt;compositor().frameViewDidChangeSize();
 459     }
 460 
 461     if (frame().isMainFrame() &amp;&amp; frame().page())
 462         frame().page()-&gt;pageOverlayController().didChangeViewSize();
 463 
 464     viewportContentsChanged();
 465     setCurrentScrollType(oldScrollType);
 466 }
 467 
 468 bool FrameView::scheduleAnimation()
 469 {
 470     auto* page = frame().page();
 471     if (!page)
 472         return false;
 473     page-&gt;chrome().scheduleAnimation();
 474     return true;
 475 }
 476 
 477 FrameFlattening FrameView::effectiveFrameFlattening() const
 478 {
 479 #if PLATFORM(IOS_FAMILY)
 480     // On iOS when async frame scrolling is enabled, it does not make sense to use full frame flattening.
 481     // In that case, we just consider that frame flattening is disabled. This allows people to test
 482     // frame scrolling on iOS by enabling &quot;Async Frame Scrolling&quot; via the Safari menu.
 483     if (frame().settings().asyncFrameScrollingEnabled() &amp;&amp; frame().settings().frameFlattening() == FrameFlattening::FullyEnabled)
 484         return FrameFlattening::Disabled;
 485 #endif
 486     return frame().settings().frameFlattening();
 487 }
 488 
 489 bool FrameView::frameFlatteningEnabled() const
 490 {
 491     return effectiveFrameFlattening() != FrameFlattening::Disabled;
 492 }
 493 
 494 bool FrameView::isFrameFlatteningValidForThisFrame() const
 495 {
 496     if (!frameFlatteningEnabled())
 497         return false;
 498 
 499     HTMLFrameOwnerElement* owner = frame().ownerElement();
 500     if (!owner)
 501         return false;
 502 
 503     // Frame flattening is valid only for &lt;frame&gt; and &lt;iframe&gt;.
 504     return owner-&gt;hasTagName(frameTag) || owner-&gt;hasTagName(iframeTag);
 505 }
 506 
 507 bool FrameView::avoidScrollbarCreation() const
 508 {
 509     // with frame flattening no subframe can have scrollbars
 510     // but we also cannot turn scrollbars off as we determine
 511     // our flattening policy using that.
 512     return isFrameFlatteningValidForThisFrame();
 513 }
 514 
 515 void FrameView::setCanHaveScrollbars(bool canHaveScrollbars)
 516 {
 517     m_canHaveScrollbars = canHaveScrollbars;
 518     ScrollView::setCanHaveScrollbars(canHaveScrollbars);
 519 }
 520 
 521 void FrameView::updateCanHaveScrollbars()
 522 {
 523     ScrollbarMode hMode;
 524     ScrollbarMode vMode;
 525     scrollbarModes(hMode, vMode);
 526     if (hMode == ScrollbarAlwaysOff &amp;&amp; vMode == ScrollbarAlwaysOff)
 527         setCanHaveScrollbars(false);
 528     else
 529         setCanHaveScrollbars(true);
 530 }
 531 
<a name="6" id="anc6"></a><span class="line-modified"> 532 RefPtr&lt;Element&gt; FrameView::rootElementForCustomScrollbarPartStyle(PseudoId partPseudoId) const</span>
 533 {
 534     // FIXME: We need to update the scrollbar dynamically as documents change (or as doc elements and bodies get discovered that have custom styles).
<a name="7" id="anc7"></a><span class="line-modified"> 535     auto* document = frame().document();</span>
<span class="line-added"> 536     if (!document)</span>
<span class="line-added"> 537         return nullptr;</span>
 538 
 539     // Try the &lt;body&gt; element first as a scrollbar source.
<a name="8" id="anc8"></a><span class="line-modified"> 540     auto* body = document-&gt;bodyOrFrameset();</span>
<span class="line-modified"> 541     if (body &amp;&amp; body-&gt;renderer() &amp;&amp; body-&gt;renderer()-&gt;style().hasPseudoStyle(partPseudoId))</span>
<span class="line-modified"> 542         return body;</span>
 543 
 544     // If the &lt;body&gt; didn&#39;t have a custom style, then the root element might.
<a name="9" id="anc9"></a><span class="line-modified"> 545     auto* docElement = document-&gt;documentElement();</span>
<span class="line-modified"> 546     if (docElement &amp;&amp; docElement-&gt;renderer() &amp;&amp; docElement-&gt;renderer()-&gt;style().hasPseudoStyle(partPseudoId))</span>
<span class="line-modified"> 547         return docElement;</span>
<span class="line-added"> 548 </span>
<span class="line-added"> 549     return nullptr;</span>
<span class="line-added"> 550 }</span>
<span class="line-added"> 551 </span>
<span class="line-added"> 552 Ref&lt;Scrollbar&gt; FrameView::createScrollbar(ScrollbarOrientation orientation)</span>
<span class="line-added"> 553 {</span>
<span class="line-added"> 554     if (auto element = rootElementForCustomScrollbarPartStyle(PseudoId::Scrollbar))</span>
<span class="line-added"> 555         return RenderScrollbar::createCustomScrollbar(*this, orientation, element.get());</span>
 556 
 557     // If we have an owning iframe/frame element, then it can set the custom scrollbar also.
<a name="10" id="anc10"></a><span class="line-added"> 558     // FIXME: Seems bad to do this for cross-origin frames.</span>
 559     RenderWidget* frameRenderer = frame().ownerRenderer();
 560     if (frameRenderer &amp;&amp; frameRenderer-&gt;style().hasPseudoStyle(PseudoId::Scrollbar))
 561         return RenderScrollbar::createCustomScrollbar(*this, orientation, nullptr, &amp;frame());
 562 
 563     // Nobody set a custom style, so we just use a native scrollbar.
 564     return ScrollView::createScrollbar(orientation);
 565 }
 566 
<a name="11" id="anc11"></a><span class="line-modified"> 567 void FrameView::didRestoreFromBackForwardCache()</span>
 568 {
<a name="12" id="anc12"></a><span class="line-modified"> 569     // When restoring from back/forward cache, the main frame stays in place while subframes get swapped in.</span>
 570     // We update the scrollable area set to ensure that scrolling data structures get invalidated.
 571     updateScrollableAreaSet();
 572 }
 573 
 574 void FrameView::willDestroyRenderTree()
 575 {
 576     detachCustomScrollbars();
 577     layoutContext().clearSubtreeLayoutRoot();
 578 }
 579 
 580 void FrameView::didDestroyRenderTree()
 581 {
 582     ASSERT(!layoutContext().subtreeLayoutRoot());
 583     ASSERT(m_widgetsInRenderTree.isEmpty());
 584 
 585     // If the render tree is destroyed below FrameView::updateEmbeddedObjects(), there will still be a null sentinel in the set.
 586     // Everything else should have removed itself as the tree was felled.
 587     ASSERT(!m_embeddedObjectsToUpdate || m_embeddedObjectsToUpdate-&gt;isEmpty() || (m_embeddedObjectsToUpdate-&gt;size() == 1 &amp;&amp; m_embeddedObjectsToUpdate-&gt;first() == nullptr));
 588 
 589     ASSERT(!m_viewportConstrainedObjects || m_viewportConstrainedObjects-&gt;isEmpty());
 590     ASSERT(!m_slowRepaintObjects || m_slowRepaintObjects-&gt;isEmpty());
 591 
 592     ASSERT(!frame().animation().hasAnimations());
 593 }
 594 
 595 void FrameView::setContentsSize(const IntSize&amp; size)
 596 {
 597     if (size == contentsSize())
 598         return;
 599 
 600     layoutContext().disableSetNeedsLayout();
 601 
 602     ScrollView::setContentsSize(size);
 603     contentsResized();
 604 
 605     Page* page = frame().page();
 606     if (!page)
 607         return;
 608 
 609     updateScrollableAreaSet();
 610 
 611     page-&gt;chrome().contentsSizeChanged(frame(), size); // Notify only.
 612 
 613     if (frame().isMainFrame()) {
 614         page-&gt;pageOverlayController().didChangeDocumentSize();
<a name="13" id="anc13"></a><span class="line-modified"> 615         BackForwardCache::singleton().markPagesForContentsSizeChanged(*page);</span>
 616     }
 617     layoutContext().enableSetNeedsLayout();
 618 }
 619 
 620 void FrameView::adjustViewSize()
 621 {
 622     RenderView* renderView = this-&gt;renderView();
 623     if (!renderView)
 624         return;
 625 
 626     ASSERT(frame().view() == this);
 627 
 628     const IntRect rect = renderView-&gt;documentRect();
 629     const IntSize&amp; size = rect.size();
 630     ScrollView::setScrollOrigin(IntPoint(-rect.x(), -rect.y()), !frame().document()-&gt;printing(), size == contentsSize());
 631 
 632     LOG_WITH_STREAM(Layout, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; this &lt;&lt; &quot; adjustViewSize: unscaled document rect changed to &quot; &lt;&lt; renderView-&gt;unscaledDocumentRect() &lt;&lt; &quot; (scaled to &quot; &lt;&lt; size &lt;&lt; &quot;)&quot;);
 633 
 634     setContentsSize(size);
 635 }
 636 
 637 void FrameView::applyOverflowToViewport(const RenderElement&amp; renderer, ScrollbarMode&amp; hMode, ScrollbarMode&amp; vMode)
 638 {
 639     // Handle the overflow:hidden/scroll case for the body/html elements.  WinIE treats
 640     // overflow:hidden and overflow:scroll on &lt;body&gt; as applying to the document&#39;s
 641     // scrollbars.  The CSS2.1 draft states that HTML UAs should use the &lt;html&gt; or &lt;body&gt; element and XML/XHTML UAs should
 642     // use the root element.
 643 
 644     // To combat the inability to scroll on a page with overflow:hidden on the root when scaled, disregard hidden when
 645     // there is a frameScaleFactor that is greater than one on the main frame. Also disregard hidden if there is a
 646     // header or footer.
 647 
 648     bool overrideHidden = frame().isMainFrame() &amp;&amp; ((frame().frameScaleFactor() &gt; 1) || headerHeight() || footerHeight());
 649 
 650     Overflow overflowX = renderer.style().overflowX();
 651     Overflow overflowY = renderer.style().overflowY();
 652 
 653     if (is&lt;RenderSVGRoot&gt;(renderer)) {
 654         // FIXME: evaluate if we can allow overflow for these cases too.
 655         // Overflow is always hidden when stand-alone SVG documents are embedded.
 656         if (downcast&lt;RenderSVGRoot&gt;(renderer).isEmbeddedThroughFrameContainingSVGDocument()) {
 657             overflowX = Overflow::Hidden;
 658             overflowY = Overflow::Hidden;
 659         }
 660     }
 661 
 662     switch (overflowX) {
 663     case Overflow::Hidden:
 664         if (overrideHidden)
 665             hMode = ScrollbarAuto;
 666         else
 667             hMode = ScrollbarAlwaysOff;
 668         break;
 669     case Overflow::Scroll:
 670         hMode = ScrollbarAlwaysOn;
 671         break;
 672     case Overflow::Auto:
 673         hMode = ScrollbarAuto;
 674         break;
 675     default:
 676         // Don&#39;t set it at all.
 677         ;
 678     }
 679 
 680     switch (overflowY) {
 681     case Overflow::Hidden:
 682         if (overrideHidden)
 683             vMode = ScrollbarAuto;
 684         else
 685             vMode = ScrollbarAlwaysOff;
 686         break;
 687     case Overflow::Scroll:
 688         vMode = ScrollbarAlwaysOn;
 689         break;
 690     case Overflow::Auto:
 691         vMode = ScrollbarAuto;
 692         break;
 693     default:
 694         // Don&#39;t set it at all. Values of Overflow::PagedX and Overflow::PagedY are handled by applyPaginationToViewPort().
 695         ;
 696     }
 697 }
 698 
 699 void FrameView::applyPaginationToViewport()
 700 {
 701     auto* document = frame().document();
 702     auto* documentElement = document ? document-&gt;documentElement() : nullptr;
 703     if (!documentElement || !documentElement-&gt;renderer()) {
 704         setPagination(Pagination());
 705         return;
 706     }
 707 
 708     auto&amp; documentRenderer = *documentElement-&gt;renderer();
 709     auto* documentOrBodyRenderer = &amp;documentRenderer;
 710 
 711     auto* body = document-&gt;body();
 712     if (body &amp;&amp; body-&gt;renderer()) {
 713         documentOrBodyRenderer = documentRenderer.style().overflowX() == Overflow::Visible &amp;&amp; is&lt;HTMLHtmlElement&gt;(*documentElement) ?
 714             body-&gt;renderer() : &amp;documentRenderer;
 715     }
 716 
 717     Pagination pagination;
 718     Overflow overflowY = documentOrBodyRenderer-&gt;style().overflowY();
 719     if (overflowY == Overflow::PagedX || overflowY == Overflow::PagedY) {
 720         pagination.mode = WebCore::paginationModeForRenderStyle(documentOrBodyRenderer-&gt;style());
 721         GapLength columnGapLength = documentOrBodyRenderer-&gt;style().columnGap();
 722         pagination.gap = 0;
 723         if (!columnGapLength.isNormal()) {
 724             if (auto* containerForPaginationGap = is&lt;RenderBox&gt;(documentOrBodyRenderer) ? downcast&lt;RenderBox&gt;(documentOrBodyRenderer) : documentOrBodyRenderer-&gt;containingBlock())
 725                 pagination.gap = valueForLength(columnGapLength.length(), containerForPaginationGap-&gt;availableLogicalWidth()).toUnsigned();
 726         }
 727     }
 728     setPagination(pagination);
 729 }
 730 
 731 void FrameView::calculateScrollbarModesForLayout(ScrollbarMode&amp; hMode, ScrollbarMode&amp; vMode, ScrollbarModesCalculationStrategy strategy)
 732 {
 733     m_viewportRendererType = ViewportRendererType::None;
 734 
 735     const HTMLFrameOwnerElement* owner = frame().ownerElement();
 736     if (owner &amp;&amp; (owner-&gt;scrollingMode() == ScrollbarAlwaysOff)) {
 737         hMode = ScrollbarAlwaysOff;
 738         vMode = ScrollbarAlwaysOff;
 739         return;
 740     }
 741 
 742     if (m_canHaveScrollbars || strategy == RulesFromWebContentOnly) {
 743         hMode = ScrollbarAuto;
 744         vMode = ScrollbarAuto;
 745     } else {
 746         hMode = ScrollbarAlwaysOff;
 747         vMode = ScrollbarAlwaysOff;
 748     }
 749 
 750     if (layoutContext().subtreeLayoutRoot())
 751         return;
 752 
 753     auto* document = frame().document();
 754     if (!document)
 755         return;
 756 
 757     auto* documentElement = document-&gt;documentElement();
 758     if (!documentElement)
 759         return;
 760 
 761     auto* bodyOrFrameset = document-&gt;bodyOrFrameset();
 762     auto* rootRenderer = documentElement-&gt;renderer();
 763     if (!bodyOrFrameset || !bodyOrFrameset-&gt;renderer()) {
 764         if (rootRenderer) {
 765             applyOverflowToViewport(*rootRenderer, hMode, vMode);
 766             m_viewportRendererType = ViewportRendererType::Document;
 767         }
 768         return;
 769     }
 770 
 771     if (is&lt;HTMLFrameSetElement&gt;(*bodyOrFrameset) &amp;&amp; !frameFlatteningEnabled()) {
 772         vMode = ScrollbarAlwaysOff;
 773         hMode = ScrollbarAlwaysOff;
 774         return;
 775     }
 776 
 777     if (is&lt;HTMLBodyElement&gt;(*bodyOrFrameset) &amp;&amp; rootRenderer) {
 778         // It&#39;s sufficient to just check the X overflow,
 779         // since it&#39;s illegal to have visible in only one direction.
 780         if (rootRenderer-&gt;style().overflowX() == Overflow::Visible &amp;&amp; is&lt;HTMLHtmlElement&gt;(documentElement)) {
 781             auto* bodyRenderer = bodyOrFrameset-&gt;renderer();
 782             if (bodyRenderer) {
 783                 applyOverflowToViewport(*bodyRenderer, hMode, vMode);
 784                 m_viewportRendererType = ViewportRendererType::Body;
 785             }
 786         } else {
 787             applyOverflowToViewport(*rootRenderer, hMode, vMode);
 788             m_viewportRendererType = ViewportRendererType::Document;
 789         }
 790     }
 791 }
 792 
 793 void FrameView::willRecalcStyle()
 794 {
 795     RenderView* renderView = this-&gt;renderView();
 796     if (!renderView)
 797         return;
 798 
 799     renderView-&gt;compositor().willRecalcStyle();
 800 }
 801 
<a name="14" id="anc14"></a><span class="line-added"> 802 void FrameView::styleDidChange()</span>
<span class="line-added"> 803 {</span>
<span class="line-added"> 804     ScrollView::styleDidChange();</span>
<span class="line-added"> 805     RenderView* renderView = this-&gt;renderView();</span>
<span class="line-added"> 806     if (!renderView)</span>
<span class="line-added"> 807         return;</span>
<span class="line-added"> 808 </span>
<span class="line-added"> 809     RenderLayer* layerTreeMutationRoot = renderView-&gt;takeStyleChangeLayerTreeMutationRoot();</span>
<span class="line-added"> 810     if (layerTreeMutationRoot &amp;&amp; !needsLayout())</span>
<span class="line-added"> 811         layerTreeMutationRoot-&gt;updateLayerPositionsAfterStyleChange();</span>
<span class="line-added"> 812 }</span>
<span class="line-added"> 813 </span>
 814 bool FrameView::updateCompositingLayersAfterStyleChange()
 815 {
 816     // If we expect to update compositing after an incipient layout, don&#39;t do so here.
 817     if (!renderView() || needsLayout() || layoutContext().isInLayout())
 818         return false;
 819     return renderView()-&gt;compositor().didRecalcStyleWithNoPendingLayout();
 820 }
 821 
 822 void FrameView::updateCompositingLayersAfterLayout()
 823 {
 824     RenderView* renderView = this-&gt;renderView();
 825     if (!renderView)
 826         return;
 827 
 828     renderView-&gt;compositor().updateCompositingLayers(CompositingUpdateType::AfterLayout);
 829 }
 830 
 831 GraphicsLayer* FrameView::layerForHorizontalScrollbar() const
 832 {
 833     RenderView* renderView = this-&gt;renderView();
 834     if (!renderView)
 835         return nullptr;
 836     return renderView-&gt;compositor().layerForHorizontalScrollbar();
 837 }
 838 
 839 GraphicsLayer* FrameView::layerForVerticalScrollbar() const
 840 {
 841     RenderView* renderView = this-&gt;renderView();
 842     if (!renderView)
 843         return nullptr;
 844     return renderView-&gt;compositor().layerForVerticalScrollbar();
 845 }
 846 
 847 GraphicsLayer* FrameView::layerForScrollCorner() const
 848 {
 849     RenderView* renderView = this-&gt;renderView();
 850     if (!renderView)
 851         return nullptr;
 852     return renderView-&gt;compositor().layerForScrollCorner();
 853 }
 854 
 855 TiledBacking* FrameView::tiledBacking() const
 856 {
 857     RenderView* renderView = this-&gt;renderView();
 858     if (!renderView)
 859         return nullptr;
 860 
 861     RenderLayerBacking* backing = renderView-&gt;layer()-&gt;backing();
 862     if (!backing)
 863         return nullptr;
 864 
 865     return backing-&gt;tiledBacking();
 866 }
 867 
 868 ScrollingNodeID FrameView::scrollingNodeID() const
 869 {
 870     RenderView* renderView = this-&gt;renderView();
 871     if (!renderView)
 872         return 0;
 873 
 874     RenderLayerBacking* backing = renderView-&gt;layer()-&gt;backing();
 875     if (!backing)
 876         return 0;
 877 
 878     return backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling);
 879 }
 880 
 881 ScrollableArea* FrameView::scrollableAreaForScrollLayerID(uint64_t nodeID) const
 882 {
 883     RenderView* renderView = this-&gt;renderView();
 884     if (!renderView)
 885         return nullptr;
 886 
 887     return renderView-&gt;compositor().scrollableAreaForScrollLayerID(nodeID);
 888 }
 889 
 890 #if ENABLE(RUBBER_BANDING)
 891 GraphicsLayer* FrameView::layerForOverhangAreas() const
 892 {
 893     RenderView* renderView = this-&gt;renderView();
 894     if (!renderView)
 895         return nullptr;
 896     return renderView-&gt;compositor().layerForOverhangAreas();
 897 }
 898 
 899 GraphicsLayer* FrameView::setWantsLayerForTopOverHangArea(bool wantsLayer) const
 900 {
 901     RenderView* renderView = this-&gt;renderView();
 902     if (!renderView)
 903         return nullptr;
 904 
 905     return renderView-&gt;compositor().updateLayerForTopOverhangArea(wantsLayer);
 906 }
 907 
 908 GraphicsLayer* FrameView::setWantsLayerForBottomOverHangArea(bool wantsLayer) const
 909 {
 910     RenderView* renderView = this-&gt;renderView();
 911     if (!renderView)
 912         return nullptr;
 913 
 914     return renderView-&gt;compositor().updateLayerForBottomOverhangArea(wantsLayer);
 915 }
 916 
 917 #endif // ENABLE(RUBBER_BANDING)
 918 
 919 #if ENABLE(CSS_SCROLL_SNAP)
 920 void FrameView::updateSnapOffsets()
 921 {
 922     if (!frame().document())
 923         return;
 924 
 925     // FIXME: Should we allow specifying snap points through &lt;html&gt; tags too?
 926     HTMLElement* body = frame().document()-&gt;bodyOrFrameset();
 927     if (!renderView() || !body || !body-&gt;renderer())
 928         return;
 929 
 930     updateSnapOffsetsForScrollableArea(*this, *body, *renderView(), body-&gt;renderer()-&gt;style());
 931 }
 932 
 933 bool FrameView::isScrollSnapInProgress() const
 934 {
 935     if (scrollbarsSuppressed())
 936         return false;
 937 
 938     // If the scrolling thread updates the scroll position for this FrameView, then we should return
 939     // ScrollingCoordinator::isScrollSnapInProgress().
 940     if (Page* page = frame().page()) {
 941         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator()) {
 942             if (!scrollingCoordinator-&gt;shouldUpdateScrollLayerPositionSynchronously(*this))
 943                 return scrollingCoordinator-&gt;isScrollSnapInProgress();
 944         }
 945     }
 946 
 947     // If the main thread updates the scroll position for this FrameView, we should return
 948     // ScrollAnimator::isScrollSnapInProgress().
 949     if (ScrollAnimator* scrollAnimator = existingScrollAnimator())
 950         return scrollAnimator-&gt;isScrollSnapInProgress();
 951 
 952     return false;
 953 }
 954 
 955 void FrameView::updateScrollingCoordinatorScrollSnapProperties() const
 956 {
 957     renderView()-&gt;compositor().updateScrollSnapPropertiesWithFrameView(*this);
 958 }
 959 #endif
 960 
 961 bool FrameView::flushCompositingStateForThisFrame(const Frame&amp; rootFrameForFlush)
 962 {
 963     RenderView* renderView = this-&gt;renderView();
 964     if (!renderView)
 965         return true; // We don&#39;t want to keep trying to update layers if we have no renderer.
 966 
 967     ASSERT(frame().view() == this);
 968 
 969     // If we sync compositing layers when a layout is pending, we may cause painting of compositing
 970     // layer content to occur before layout has happened, which will cause paintContents() to bail.
 971     if (needsLayout())
 972         return false;
 973 
 974 #if PLATFORM(IOS_FAMILY)
 975     if (LegacyTileCache* tileCache = legacyTileCache())
 976         tileCache-&gt;doPendingRepaints();
 977 #endif
 978 
 979     renderView-&gt;compositor().flushPendingLayerChanges(&amp;rootFrameForFlush == m_frame.ptr());
 980 
 981     return true;
 982 }
 983 
 984 void FrameView::setNeedsOneShotDrawingSynchronization()
 985 {
 986     if (Page* page = frame().page())
 987         page-&gt;chrome().client().setNeedsOneShotDrawingSynchronization();
 988 }
 989 
 990 GraphicsLayer* FrameView::graphicsLayerForPlatformWidget(PlatformWidget platformWidget)
 991 {
 992     // To find the Widget that corresponds with platformWidget we have to do a linear
 993     // search of our child widgets.
 994     const Widget* foundWidget = nullptr;
 995     for (auto&amp; widget : children()) {
 996         if (widget-&gt;platformWidget() != platformWidget)
 997             continue;
 998         foundWidget = widget.ptr();
 999         break;
1000     }
1001 
1002     if (!foundWidget)
1003         return nullptr;
1004 
1005     auto* renderWidget = RenderWidget::find(*foundWidget);
1006     if (!renderWidget)
1007         return nullptr;
1008 
1009     auto* widgetLayer = renderWidget-&gt;layer();
1010     if (!widgetLayer || !widgetLayer-&gt;isComposited())
1011         return nullptr;
1012 
1013     return widgetLayer-&gt;backing()-&gt;parentForSublayers();
1014 }
1015 
1016 void FrameView::scheduleLayerFlushAllowingThrottling()
1017 {
1018     RenderView* view = this-&gt;renderView();
1019     if (!view)
1020         return;
1021     view-&gt;compositor().scheduleLayerFlush(true /* canThrottle */);
1022 }
1023 
1024 LayoutRect FrameView::fixedScrollableAreaBoundsInflatedForScrolling(const LayoutRect&amp; uninflatedBounds) const
1025 {
1026     LayoutPoint scrollPosition;
1027     LayoutSize topLeftExpansion;
1028     LayoutSize bottomRightExpansion;
1029 
1030     if (frame().settings().visualViewportEnabled()) {
1031         // FIXME: this is wrong under zooming; uninflatedBounds is scaled but the scroll positions are not.
1032         scrollPosition = layoutViewportRect().location();
1033         topLeftExpansion = scrollPosition - unscaledMinimumScrollPosition();
1034         bottomRightExpansion = unscaledMaximumScrollPosition() - scrollPosition;
1035     } else {
1036         scrollPosition = scrollPositionRespectingCustomFixedPosition();
1037         topLeftExpansion = scrollPosition - minimumScrollPosition();
1038         bottomRightExpansion = maximumScrollPosition() - scrollPosition;
1039     }
1040 
1041     return LayoutRect(uninflatedBounds.location() - topLeftExpansion, uninflatedBounds.size() + topLeftExpansion + bottomRightExpansion);
1042 }
1043 
1044 LayoutPoint FrameView::scrollPositionRespectingCustomFixedPosition() const
1045 {
1046 #if PLATFORM(IOS_FAMILY)
1047     if (!frame().settings().visualViewportEnabled())
1048         return useCustomFixedPositionLayoutRect() ? customFixedPositionLayoutRect().location() : scrollPosition();
1049 #endif
1050 
1051     return scrollPositionForFixedPosition();
1052 }
1053 
1054 int FrameView::headerHeight() const
1055 {
1056     if (!frame().isMainFrame())
1057         return 0;
1058     Page* page = frame().page();
1059     return page ? page-&gt;headerHeight() : 0;
1060 }
1061 
1062 int FrameView::footerHeight() const
1063 {
1064     if (!frame().isMainFrame())
1065         return 0;
1066     Page* page = frame().page();
1067     return page ? page-&gt;footerHeight() : 0;
1068 }
1069 
1070 float FrameView::topContentInset(TopContentInsetType contentInsetTypeToReturn) const
1071 {
1072     if (platformWidget() &amp;&amp; contentInsetTypeToReturn == TopContentInsetType::WebCoreOrPlatformContentInset)
1073         return platformTopContentInset();
1074 
1075     if (!frame().isMainFrame())
1076         return 0;
1077 
1078     Page* page = frame().page();
1079     return page ? page-&gt;topContentInset() : 0;
1080 }
1081 
1082 void FrameView::topContentInsetDidChange(float newTopContentInset)
1083 {
1084     RenderView* renderView = this-&gt;renderView();
1085     if (!renderView)
1086         return;
1087 
1088     if (platformWidget())
1089         platformSetTopContentInset(newTopContentInset);
1090 
1091     layoutContext().layout();
1092     // Every scroll that happens as the result of content inset change is programmatic.
1093     auto oldScrollType = currentScrollType();
1094     setCurrentScrollType(ScrollType::Programmatic);
1095 
1096     updateScrollbars(scrollPosition());
1097     if (renderView-&gt;usesCompositing())
1098         renderView-&gt;compositor().frameViewDidChangeSize();
1099 
1100     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
1101         tiledBacking-&gt;setTopContentInset(newTopContentInset);
1102 
1103     setCurrentScrollType(oldScrollType);
1104 }
1105 
1106 void FrameView::topContentDirectionDidChange()
1107 {
1108     m_needsDeferredScrollbarsUpdate = true;
1109 }
1110 
1111 void FrameView::handleDeferredScrollbarsUpdateAfterDirectionChange()
1112 {
1113     if (!m_needsDeferredScrollbarsUpdate)
1114         return;
1115 
1116     m_needsDeferredScrollbarsUpdate = false;
1117 
1118     updateScrollbars(scrollPosition());
1119     positionScrollbarLayers();
1120 }
1121 
1122 // Sometimes (for plug-ins) we need to eagerly go into compositing mode.
1123 void FrameView::enterCompositingMode()
1124 {
1125     if (RenderView* renderView = this-&gt;renderView()) {
1126         renderView-&gt;compositor().enableCompositingMode();
1127         if (!needsLayout())
1128             renderView-&gt;compositor().scheduleCompositingLayerUpdate();
1129     }
1130 }
1131 
1132 bool FrameView::isEnclosedInCompositingLayer() const
1133 {
1134     auto frameOwnerRenderer = frame().ownerRenderer();
1135     if (frameOwnerRenderer &amp;&amp; frameOwnerRenderer-&gt;containerForRepaint())
1136         return true;
1137 
1138     if (FrameView* parentView = parentFrameView())
1139         return parentView-&gt;isEnclosedInCompositingLayer();
1140     return false;
1141 }
1142 
1143 bool FrameView::flushCompositingStateIncludingSubframes()
1144 {
1145     bool allFramesFlushed = flushCompositingStateForThisFrame(frame());
1146 
1147     for (Frame* child = frame().tree().firstRenderedChild(); child; child = child-&gt;tree().traverseNextRendered(m_frame.ptr())) {
1148         if (!child-&gt;view())
1149             continue;
1150         bool flushed = child-&gt;view()-&gt;flushCompositingStateForThisFrame(frame());
1151         allFramesFlushed &amp;= flushed;
1152     }
1153     return allFramesFlushed;
1154 }
1155 
1156 bool FrameView::isSoftwareRenderable() const
1157 {
1158     RenderView* renderView = this-&gt;renderView();
1159     return !renderView || !renderView-&gt;compositor().has3DContent();
1160 }
1161 
1162 void FrameView::setIsInWindow(bool isInWindow)
1163 {
1164     if (RenderView* renderView = this-&gt;renderView())
1165         renderView-&gt;setIsInWindow(isInWindow);
1166 }
1167 
1168 void FrameView::forceLayoutParentViewIfNeeded()
1169 {
1170     RenderWidget* ownerRenderer = frame().ownerRenderer();
1171     if (!ownerRenderer)
1172         return;
1173 
1174     RenderBox* contentBox = embeddedContentBox();
1175     if (!contentBox)
1176         return;
1177 
1178     auto&amp; svgRoot = downcast&lt;RenderSVGRoot&gt;(*contentBox);
1179     if (svgRoot.everHadLayout() &amp;&amp; !svgRoot.needsLayout())
1180         return;
1181 
1182     LOG(Layout, &quot;FrameView %p forceLayoutParentViewIfNeeded scheduling layout on parent FrameView %p&quot;, this, &amp;ownerRenderer-&gt;view().frameView());
1183 
1184     // If the embedded SVG document appears the first time, the ownerRenderer has already finished
1185     // layout without knowing about the existence of the embedded SVG document, because RenderReplaced
1186     // embeddedContentBox() returns nullptr, as long as the embedded document isn&#39;t loaded yet. Before
1187     // bothering to lay out the SVG document, mark the ownerRenderer needing layout and ask its
1188     // FrameView for a layout. After that the RenderEmbeddedObject (ownerRenderer) carries the
1189     // correct size, which RenderSVGRoot::computeReplacedLogicalWidth/Height rely on, when laying
1190     // out for the first time, or when the RenderSVGRoot size has changed dynamically (eg. via &lt;script&gt;).
1191 
1192     ownerRenderer-&gt;setNeedsLayoutAndPrefWidthsRecalc();
1193     ownerRenderer-&gt;view().frameView().layoutContext().scheduleLayout();
1194 }
1195 
1196 void FrameView::markRootOrBodyRendererDirty() const
1197 {
1198     auto&amp; document = *frame().document();
1199     RenderBox* rootRenderer = document.documentElement() ? document.documentElement()-&gt;renderBox() : nullptr;
1200     auto* body = document.bodyOrFrameset();
1201     RenderBox* bodyRenderer = rootRenderer &amp;&amp; body ? body-&gt;renderBox() : nullptr;
1202     if (bodyRenderer &amp;&amp; bodyRenderer-&gt;stretchesToViewport())
1203         bodyRenderer-&gt;setChildNeedsLayout();
1204     else if (rootRenderer &amp;&amp; rootRenderer-&gt;stretchesToViewport())
1205         rootRenderer-&gt;setChildNeedsLayout();
1206 }
1207 
1208 void FrameView::adjustScrollbarsForLayout(bool isFirstLayout)
1209 {
1210     ScrollbarMode hMode;
1211     ScrollbarMode vMode;
1212     calculateScrollbarModesForLayout(hMode, vMode);
1213     if (isFirstLayout &amp;&amp; !layoutContext().isLayoutNested()) {
1214         setScrollbarsSuppressed(true);
1215         // Set the initial vMode to AlwaysOn if we&#39;re auto.
1216         if (vMode == ScrollbarAuto)
1217             setVerticalScrollbarMode(ScrollbarAlwaysOn); // This causes a vertical scrollbar to appear.
1218         // Set the initial hMode to AlwaysOff if we&#39;re auto.
1219         if (hMode == ScrollbarAuto)
1220             setHorizontalScrollbarMode(ScrollbarAlwaysOff); // This causes a horizontal scrollbar to disappear.
1221         ASSERT(frame().page());
<a name="15" id="anc15"></a><span class="line-modified">1222         if (frame().page()-&gt;isMonitoringWheelEvents())</span>
<span class="line-modified">1223             scrollAnimator().setWheelEventTestMonitor(frame().page()-&gt;wheelEventTestMonitor());</span>
1224         setScrollbarModes(hMode, vMode);
1225         setScrollbarsSuppressed(false, true);
1226     } else if (hMode != horizontalScrollbarMode() || vMode != verticalScrollbarMode())
1227         setScrollbarModes(hMode, vMode);
1228 }
1229 
1230 void FrameView::willDoLayout(WeakPtr&lt;RenderElement&gt; layoutRoot)
1231 {
1232     bool subtreeLayout = !is&lt;RenderView&gt;(*layoutRoot);
1233     if (subtreeLayout)
1234         return;
1235 
1236     if (auto* body = frame().document()-&gt;bodyOrFrameset()) {
1237         if (is&lt;HTMLFrameSetElement&gt;(*body) &amp;&amp; !frameFlatteningEnabled() &amp;&amp; body-&gt;renderer())
1238             body-&gt;renderer()-&gt;setChildNeedsLayout();
1239     }
1240     auto firstLayout = !layoutContext().didFirstLayout();
1241     if (firstLayout) {
1242         m_lastViewportSize = sizeForResizeEvent();
1243         m_lastZoomFactor = layoutRoot-&gt;style().zoom();
1244         m_firstLayoutCallbackPending = true;
1245     }
1246     adjustScrollbarsForLayout(firstLayout);
1247 
1248     auto oldSize = m_size;
1249     LayoutSize newSize = layoutSize();
1250     if (oldSize != newSize) {
1251         m_size = newSize;
1252         LOG(Layout, &quot;  layout size changed from %.3fx%.3f to %.3fx%.3f&quot;, oldSize.width().toFloat(), oldSize.height().toFloat(),     newSize.width().toFloat(), newSize.height().toFloat());
1253         layoutContext().setNeedsFullRepaint();
1254         if (!firstLayout)
1255             markRootOrBodyRendererDirty();
1256     }
1257     forceLayoutParentViewIfNeeded();
1258 }
1259 
1260 void FrameView::didLayout(WeakPtr&lt;RenderElement&gt; layoutRoot)
1261 {
1262     renderView()-&gt;releaseProtectedRenderWidgets();
1263     auto* layoutRootEnclosingLayer = layoutRoot-&gt;enclosingLayer();
1264     layoutRootEnclosingLayer-&gt;updateLayerPositionsAfterLayout(!is&lt;RenderView&gt;(*layoutRoot), layoutContext().needsFullRepaint());
1265 
1266     updateCompositingLayersAfterLayout();
1267 
1268 #if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)
1269     if (auto* cache = frame().document()-&gt;existingAXObjectCache())
1270         cache-&gt;postNotification(layoutRoot.get(), AXObjectCache::AXLayoutComplete);
1271 #endif
1272 
1273     frame().document()-&gt;invalidateRenderingDependentRegions();
1274 
1275     updateCanBlitOnScrollRecursively();
1276 
1277     handleDeferredScrollUpdateAfterContentSizeChange();
1278 
1279     handleDeferredScrollbarsUpdateAfterDirectionChange();
1280 
1281     if (frame().document()-&gt;hasListenerType(Document::OVERFLOWCHANGED_LISTENER))
1282         updateOverflowStatus(layoutWidth() &lt; contentsWidth(), layoutHeight() &lt; contentsHeight());
1283 
1284     frame().document()-&gt;markers().invalidateRectsForAllMarkers();
1285 }
1286 
1287 bool FrameView::shouldDeferScrollUpdateAfterContentSizeChange()
1288 {
1289     return (layoutContext().layoutPhase() &lt; FrameViewLayoutContext::LayoutPhase::InPostLayout) &amp;&amp; (layoutContext().layoutPhase() != FrameViewLayoutContext::LayoutPhase::OutsideLayout);
1290 }
1291 
1292 RenderBox* FrameView::embeddedContentBox() const
1293 {
1294     RenderView* renderView = this-&gt;renderView();
1295     if (!renderView)
1296         return nullptr;
1297 
1298     RenderObject* firstChild = renderView-&gt;firstChild();
1299 
1300     // Curently only embedded SVG documents participate in the size-negotiation logic.
1301     if (is&lt;RenderSVGRoot&gt;(firstChild))
1302         return downcast&lt;RenderSVGRoot&gt;(firstChild);
1303 
1304     return nullptr;
1305 }
1306 
1307 void FrameView::addEmbeddedObjectToUpdate(RenderEmbeddedObject&amp; embeddedObject)
1308 {
1309     if (!m_embeddedObjectsToUpdate)
1310         m_embeddedObjectsToUpdate = makeUnique&lt;ListHashSet&lt;RenderEmbeddedObject*&gt;&gt;();
1311 
1312     HTMLFrameOwnerElement&amp; element = embeddedObject.frameOwnerElement();
1313     if (is&lt;HTMLObjectElement&gt;(element) || is&lt;HTMLEmbedElement&gt;(element)) {
1314         // Tell the DOM element that it needs a widget update.
1315         HTMLPlugInImageElement&amp; pluginElement = downcast&lt;HTMLPlugInImageElement&gt;(element);
1316         if (!pluginElement.needsCheckForSizeChange())
1317             pluginElement.setNeedsWidgetUpdate(true);
1318     }
1319 
1320     m_embeddedObjectsToUpdate-&gt;add(&amp;embeddedObject);
1321 }
1322 
1323 void FrameView::removeEmbeddedObjectToUpdate(RenderEmbeddedObject&amp; embeddedObject)
1324 {
1325     if (!m_embeddedObjectsToUpdate)
1326         return;
1327 
1328     m_embeddedObjectsToUpdate-&gt;remove(&amp;embeddedObject);
1329 }
1330 
1331 void FrameView::setMediaType(const String&amp; mediaType)
1332 {
1333     m_mediaType = mediaType;
1334 }
1335 
1336 String FrameView::mediaType() const
1337 {
1338     // See if we have an override type.
1339     String overrideType = frame().loader().client().overrideMediaType();
1340     InspectorInstrumentation::applyEmulatedMedia(frame(), overrideType);
1341     if (!overrideType.isNull())
1342         return overrideType;
1343     return m_mediaType;
1344 }
1345 
1346 void FrameView::adjustMediaTypeForPrinting(bool printing)
1347 {
1348     if (printing) {
1349         if (m_mediaTypeWhenNotPrinting.isNull())
1350             m_mediaTypeWhenNotPrinting = mediaType();
1351         setMediaType(&quot;print&quot;);
1352     } else {
1353         if (!m_mediaTypeWhenNotPrinting.isNull())
1354             setMediaType(m_mediaTypeWhenNotPrinting);
1355         m_mediaTypeWhenNotPrinting = String();
1356     }
1357 }
1358 
1359 bool FrameView::useSlowRepaints(bool considerOverlap) const
1360 {
1361     bool mustBeSlow = hasSlowRepaintObjects() || (platformWidget() &amp;&amp; hasViewportConstrainedObjects());
1362 
1363     // FIXME: WidgetMac.mm makes the assumption that useSlowRepaints ==
1364     // m_contentIsOpaque, so don&#39;t take the fast path for composited layers
1365     // if they are a platform widget in order to get painting correctness
1366     // for transparent layers. See the comment in WidgetMac::paint.
1367     if (usesCompositedScrolling() &amp;&amp; !platformWidget())
1368         return mustBeSlow;
1369 
1370     bool isOverlapped = m_isOverlapped &amp;&amp; considerOverlap;
1371 
1372     if (mustBeSlow || m_cannotBlitToWindow || isOverlapped || !m_contentIsOpaque)
1373         return true;
1374 
1375     if (FrameView* parentView = parentFrameView())
1376         return parentView-&gt;useSlowRepaints(considerOverlap);
1377 
1378     return false;
1379 }
1380 
1381 bool FrameView::useSlowRepaintsIfNotOverlapped() const
1382 {
1383     return useSlowRepaints(false);
1384 }
1385 
1386 void FrameView::updateCanBlitOnScrollRecursively()
1387 {
1388     for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr())) {
1389         if (FrameView* view = frame-&gt;view())
1390             view-&gt;setCanBlitOnScroll(!view-&gt;useSlowRepaints());
1391     }
1392 }
1393 
1394 bool FrameView::usesCompositedScrolling() const
1395 {
1396     RenderView* renderView = this-&gt;renderView();
1397     if (renderView &amp;&amp; renderView-&gt;isComposited()) {
1398         GraphicsLayer* layer = renderView-&gt;layer()-&gt;backing()-&gt;graphicsLayer();
1399         if (layer &amp;&amp; layer-&gt;drawsContent())
1400             return true;
1401     }
1402 
1403     return false;
1404 }
1405 
1406 bool FrameView::usesAsyncScrolling() const
1407 {
1408 #if ENABLE(ASYNC_SCROLLING)
1409     if (Page* page = frame().page()) {
1410         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
1411             return scrollingCoordinator-&gt;coordinatesScrollingForFrameView(*this);
1412     }
1413 #endif
1414     return false;
1415 }
1416 
1417 bool FrameView::usesMockScrollAnimator() const
1418 {
1419     return DeprecatedGlobalSettings::usesMockScrollAnimator();
1420 }
1421 
1422 void FrameView::logMockScrollAnimatorMessage(const String&amp; message) const
1423 {
1424     Document* document = frame().document();
1425     if (!document)
1426         return;
1427     StringBuilder builder;
1428     if (frame().isMainFrame())
1429         builder.appendLiteral(&quot;Main&quot;);
1430     builder.appendLiteral(&quot;FrameView: &quot;);
1431     builder.append(message);
1432     document-&gt;addConsoleMessage(MessageSource::Other, MessageLevel::Debug, builder.toString());
1433 }
1434 
<a name="16" id="anc16"></a><span class="line-added">1435 bool FrameView::styleHidesScrollbarWithOrientation(ScrollbarOrientation orientation) const</span>
<span class="line-added">1436 {</span>
<span class="line-added">1437     auto element = rootElementForCustomScrollbarPartStyle(PseudoId::Scrollbar);</span>
<span class="line-added">1438     if (!element)</span>
<span class="line-added">1439         return false;</span>
<span class="line-added">1440     auto* renderer = element-&gt;renderer();</span>
<span class="line-added">1441     ASSERT(renderer); // rootElementForCustomScrollbarPart assures that it&#39;s not null.</span>
<span class="line-added">1442 </span>
<span class="line-added">1443     StyleScrollbarState scrollbarState;</span>
<span class="line-added">1444     scrollbarState.scrollbarPart = ScrollbarBGPart;</span>
<span class="line-added">1445     scrollbarState.orientation = orientation;</span>
<span class="line-added">1446     auto scrollbarStyle = renderer-&gt;getUncachedPseudoStyle({ PseudoId::Scrollbar, scrollbarState }, &amp;renderer-&gt;style());</span>
<span class="line-added">1447     return scrollbarStyle &amp;&amp; scrollbarStyle-&gt;display() == DisplayType::None;</span>
<span class="line-added">1448 }</span>
<span class="line-added">1449 </span>
<span class="line-added">1450 bool FrameView::horizontalScrollbarHiddenByStyle() const</span>
<span class="line-added">1451 {</span>
<span class="line-added">1452     if (managesScrollbars()) {</span>
<span class="line-added">1453         auto* scrollbar = horizontalScrollbar();</span>
<span class="line-added">1454         return scrollbar &amp;&amp; scrollbar-&gt;isHiddenByStyle();</span>
<span class="line-added">1455     }</span>
<span class="line-added">1456 </span>
<span class="line-added">1457     return styleHidesScrollbarWithOrientation(HorizontalScrollbar);</span>
<span class="line-added">1458 }</span>
<span class="line-added">1459 </span>
<span class="line-added">1460 bool FrameView::verticalScrollbarHiddenByStyle() const</span>
<span class="line-added">1461 {</span>
<span class="line-added">1462     if (managesScrollbars()) {</span>
<span class="line-added">1463         auto* scrollbar = verticalScrollbar();</span>
<span class="line-added">1464         return scrollbar &amp;&amp; scrollbar-&gt;isHiddenByStyle();</span>
<span class="line-added">1465     }</span>
<span class="line-added">1466 </span>
<span class="line-added">1467     return styleHidesScrollbarWithOrientation(VerticalScrollbar);</span>
<span class="line-added">1468 }</span>
<span class="line-added">1469 </span>
1470 void FrameView::setCannotBlitToWindow()
1471 {
1472     m_cannotBlitToWindow = true;
1473     updateCanBlitOnScrollRecursively();
1474 }
1475 
1476 void FrameView::addSlowRepaintObject(RenderElement&amp; renderer)
1477 {
1478     bool hadSlowRepaintObjects = hasSlowRepaintObjects();
1479 
1480     if (!m_slowRepaintObjects)
1481         m_slowRepaintObjects = makeUnique&lt;HashSet&lt;const RenderElement*&gt;&gt;();
1482 
1483     m_slowRepaintObjects-&gt;add(&amp;renderer);
1484     if (hadSlowRepaintObjects)
1485         return;
1486 
1487     updateCanBlitOnScrollRecursively();
1488 
1489     if (auto* page = frame().page()) {
1490         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
1491             scrollingCoordinator-&gt;frameViewHasSlowRepaintObjectsDidChange(*this);
1492     }
1493 }
1494 
1495 void FrameView::removeSlowRepaintObject(RenderElement&amp; renderer)
1496 {
1497     if (!m_slowRepaintObjects)
1498         return;
1499 
1500     m_slowRepaintObjects-&gt;remove(&amp;renderer);
1501     if (!m_slowRepaintObjects-&gt;isEmpty())
1502         return;
1503 
1504     m_slowRepaintObjects = nullptr;
1505     updateCanBlitOnScrollRecursively();
1506 
1507     if (auto* page = frame().page()) {
1508         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
1509             scrollingCoordinator-&gt;frameViewHasSlowRepaintObjectsDidChange(*this);
1510     }
1511 }
1512 
1513 void FrameView::addViewportConstrainedObject(RenderLayerModelObject* object)
1514 {
1515     if (!m_viewportConstrainedObjects)
1516         m_viewportConstrainedObjects = makeUnique&lt;ViewportConstrainedObjectSet&gt;();
1517 
1518     if (!m_viewportConstrainedObjects-&gt;contains(object)) {
1519         m_viewportConstrainedObjects-&gt;add(object);
1520         if (platformWidget())
1521             updateCanBlitOnScrollRecursively();
1522 
1523         if (Page* page = frame().page()) {
1524             if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
1525                 scrollingCoordinator-&gt;frameViewFixedObjectsDidChange(*this);
1526         }
1527     }
1528 }
1529 
1530 void FrameView::removeViewportConstrainedObject(RenderLayerModelObject* object)
1531 {
1532     if (m_viewportConstrainedObjects &amp;&amp; m_viewportConstrainedObjects-&gt;remove(object)) {
1533         if (Page* page = frame().page()) {
1534             if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
1535                 scrollingCoordinator-&gt;frameViewFixedObjectsDidChange(*this);
1536         }
1537 
1538         // FIXME: In addFixedObject() we only call this if there&#39;s a platform widget,
1539         // why isn&#39;t the same check being made here?
1540         updateCanBlitOnScrollRecursively();
1541     }
1542 }
1543 
1544 LayoutSize FrameView::expandedLayoutViewportSize(const LayoutSize&amp; baseLayoutViewportSize, const LayoutSize&amp; documentSize, double heightExpansionFactor)
1545 {
1546     if (!heightExpansionFactor)
1547         return baseLayoutViewportSize;
1548 
1549     auto documentHeight = documentSize.height();
1550     auto layoutViewportHeight = baseLayoutViewportSize.height();
1551     if (layoutViewportHeight &gt; documentHeight)
1552         return baseLayoutViewportSize;
1553 
1554     return { baseLayoutViewportSize.width(), std::min(documentHeight, LayoutUnit((1 + heightExpansionFactor) * layoutViewportHeight)) };
1555 }
1556 
1557 LayoutRect FrameView::computeUpdatedLayoutViewportRect(const LayoutRect&amp; layoutViewport, const LayoutRect&amp; documentRect, const LayoutSize&amp; unobscuredContentSize, const LayoutRect&amp; unobscuredContentRect, const LayoutSize&amp; baseLayoutViewportSize, const LayoutPoint&amp; stableLayoutViewportOriginMin, const LayoutPoint&amp; stableLayoutViewportOriginMax, LayoutViewportConstraint constraint)
1558 {
1559     LayoutRect layoutViewportRect = layoutViewport;
1560 
1561     // The layout viewport is never smaller than baseLayoutViewportSize, and never be smaller than the unobscuredContentRect.
1562     LayoutSize constrainedSize = baseLayoutViewportSize;
1563     layoutViewportRect.setSize(constrainedSize.expandedTo(unobscuredContentSize));
1564 
1565     LayoutPoint layoutViewportOrigin = computeLayoutViewportOrigin(unobscuredContentRect, stableLayoutViewportOriginMin, stableLayoutViewportOriginMax, layoutViewportRect, StickToViewportBounds);
1566 
1567     // FIXME: Is this equivalent to calling computeLayoutViewportOrigin() with StickToDocumentBounds?
1568     if (constraint == LayoutViewportConstraint::ConstrainedToDocumentRect) {
1569         // The max stable layout viewport origin really depends on the size of the layout viewport itself, so we need to adjust the location of the layout viewport one final time to make sure it does not end up out of bounds of the document.
1570         // Without this adjustment (and with using the non-constrained unobscuredContentRect&#39;s size as the size of the layout viewport) the layout viewport can be pushed past the bounds of the document during rubber-banding, and cannot be pushed
1571         // back in until the user scrolls back in the other direction.
1572         layoutViewportOrigin.setX(clampTo&lt;float&gt;(layoutViewportOrigin.x().toFloat(), 0, documentRect.width() - layoutViewportRect.width()));
1573         layoutViewportOrigin.setY(clampTo&lt;float&gt;(layoutViewportOrigin.y().toFloat(), 0, documentRect.height() - layoutViewportRect.height()));
1574     }
1575     layoutViewportRect.setLocation(layoutViewportOrigin);
1576 
1577     return layoutViewportRect;
1578 }
1579 
1580 // visualViewport and layoutViewport are both in content coordinates (unzoomed).
1581 LayoutPoint FrameView::computeLayoutViewportOrigin(const LayoutRect&amp; visualViewport, const LayoutPoint&amp; stableLayoutViewportOriginMin, const LayoutPoint&amp; stableLayoutViewportOriginMax, const LayoutRect&amp; layoutViewport, ScrollBehaviorForFixedElements fixedBehavior)
1582 {
1583     LayoutPoint layoutViewportOrigin = layoutViewport.location();
1584     bool allowRubberBanding = fixedBehavior == StickToViewportBounds;
1585 
1586     if (visualViewport.width() &gt; layoutViewport.width()) {
1587         layoutViewportOrigin.setX(visualViewport.x());
1588         if (!allowRubberBanding) {
1589             if (layoutViewportOrigin.x() &lt; stableLayoutViewportOriginMin.x())
1590                 layoutViewportOrigin.setX(stableLayoutViewportOriginMin.x());
1591             else if (layoutViewportOrigin.x() &gt; stableLayoutViewportOriginMax.x())
1592                 layoutViewportOrigin.setX(stableLayoutViewportOriginMax.x());
1593         }
1594     } else {
1595         bool rubberbandingAtLeft = allowRubberBanding &amp;&amp; visualViewport.x() &lt; stableLayoutViewportOriginMin.x();
1596         bool rubberbandingAtRight = allowRubberBanding &amp;&amp; (visualViewport.maxX() - layoutViewport.width()) &gt; stableLayoutViewportOriginMax.x();
1597 
1598         if (visualViewport.x() &lt; layoutViewport.x() || rubberbandingAtLeft)
1599             layoutViewportOrigin.setX(visualViewport.x());
1600 
1601         if (visualViewport.maxX() &gt; layoutViewport.maxX() || rubberbandingAtRight)
1602             layoutViewportOrigin.setX(visualViewport.maxX() - layoutViewport.width());
1603 
1604         if (!rubberbandingAtLeft &amp;&amp; layoutViewportOrigin.x() &lt; stableLayoutViewportOriginMin.x())
1605             layoutViewportOrigin.setX(stableLayoutViewportOriginMin.x());
1606 
1607         if (!rubberbandingAtRight &amp;&amp; layoutViewportOrigin.x() &gt; stableLayoutViewportOriginMax.x())
1608             layoutViewportOrigin.setX(stableLayoutViewportOriginMax.x());
1609     }
1610 
1611     if (visualViewport.height() &gt; layoutViewport.height()) {
1612         layoutViewportOrigin.setY(visualViewport.y());
1613         if (!allowRubberBanding) {
1614             if (layoutViewportOrigin.y() &lt; stableLayoutViewportOriginMin.y())
1615                 layoutViewportOrigin.setY(stableLayoutViewportOriginMin.y());
1616             else if (layoutViewportOrigin.y() &gt; stableLayoutViewportOriginMax.y())
1617                 layoutViewportOrigin.setY(stableLayoutViewportOriginMax.y());
1618         }
1619     } else {
1620         bool rubberbandingAtTop = allowRubberBanding &amp;&amp; visualViewport.y() &lt; stableLayoutViewportOriginMin.y();
1621         bool rubberbandingAtBottom = allowRubberBanding &amp;&amp; (visualViewport.maxY() - layoutViewport.height()) &gt; stableLayoutViewportOriginMax.y();
1622 
1623         if (visualViewport.y() &lt; layoutViewport.y() || rubberbandingAtTop)
1624             layoutViewportOrigin.setY(visualViewport.y());
1625 
1626         if (visualViewport.maxY() &gt; layoutViewport.maxY() || rubberbandingAtBottom)
1627             layoutViewportOrigin.setY(visualViewport.maxY() - layoutViewport.height());
1628 
1629         if (!rubberbandingAtTop &amp;&amp; layoutViewportOrigin.y() &lt; stableLayoutViewportOriginMin.y())
1630             layoutViewportOrigin.setY(stableLayoutViewportOriginMin.y());
1631 
1632         if (!rubberbandingAtBottom &amp;&amp; layoutViewportOrigin.y() &gt; stableLayoutViewportOriginMax.y())
1633             layoutViewportOrigin.setY(stableLayoutViewportOriginMax.y());
1634     }
1635 
1636     return layoutViewportOrigin;
1637 }
1638 
1639 void FrameView::setBaseLayoutViewportOrigin(LayoutPoint origin, TriggerLayoutOrNot layoutTriggering)
1640 {
1641     ASSERT(frame().settings().visualViewportEnabled());
1642 
1643     if (origin == m_layoutViewportOrigin)
1644         return;
1645 
1646     m_layoutViewportOrigin = origin;
1647     if (layoutTriggering == TriggerLayoutOrNot::Yes)
1648         setViewportConstrainedObjectsNeedLayout();
1649 
1650     if (TiledBacking* tiledBacking = this-&gt;tiledBacking()) {
1651         FloatRect layoutViewport = layoutViewportRect();
1652         layoutViewport.moveBy(unscaledScrollOrigin()); // tiledBacking deals in top-left relative coordinates.
1653         tiledBacking-&gt;setLayoutViewportRect(layoutViewport);
1654     }
1655 }
1656 
1657 void FrameView::setLayoutViewportOverrideRect(Optional&lt;LayoutRect&gt; rect, TriggerLayoutOrNot layoutTriggering)
1658 {
1659     if (rect == m_layoutViewportOverrideRect)
1660         return;
1661 
1662     LayoutRect oldRect = layoutViewportRect();
1663     m_layoutViewportOverrideRect = rect;
1664 
1665     // Triggering layout on height changes is necessary to make bottom-fixed elements behave correctly.
1666     if (oldRect.height() != layoutViewportRect().height())
1667         layoutTriggering = TriggerLayoutOrNot::Yes;
1668 
1669     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;\nFrameView &quot; &lt;&lt; this &lt;&lt; &quot; setLayoutViewportOverrideRect() - changing override layout viewport from &quot; &lt;&lt; oldRect &lt;&lt; &quot; to &quot; &lt;&lt; m_layoutViewportOverrideRect.valueOr(LayoutRect()) &lt;&lt; &quot; layoutTriggering &quot; &lt;&lt; (layoutTriggering == TriggerLayoutOrNot::Yes ? &quot;yes&quot; : &quot;no&quot;));
1670 
1671     if (oldRect != layoutViewportRect() &amp;&amp; layoutTriggering == TriggerLayoutOrNot::Yes)
1672         setViewportConstrainedObjectsNeedLayout();
1673 }
1674 
1675 void FrameView::setVisualViewportOverrideRect(Optional&lt;LayoutRect&gt; rect)
1676 {
1677     m_visualViewportOverrideRect = rect;
1678 }
1679 
1680 LayoutSize FrameView::baseLayoutViewportSize() const
1681 {
1682     return renderView() ? renderView()-&gt;size() : size();
1683 }
1684 
1685 void FrameView::updateLayoutViewport()
1686 {
1687     if (!frame().settings().visualViewportEnabled())
1688         return;
1689 
1690     // Don&#39;t update the layout viewport if we&#39;re in the middle of adjusting scrollbars. We&#39;ll get another call
1691     // as a post-layout task.
1692     if (layoutContext().layoutPhase() == FrameViewLayoutContext::LayoutPhase::InViewSizeAdjust)
1693         return;
1694 
1695     LayoutRect layoutViewport = layoutViewportRect();
1696 
1697     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;\nFrameView &quot; &lt;&lt; this &lt;&lt; &quot; updateLayoutViewport() totalContentSize &quot; &lt;&lt; totalContentsSize() &lt;&lt; &quot; unscaledDocumentRect &quot; &lt;&lt; (renderView() ? renderView()-&gt;unscaledDocumentRect() : IntRect()) &lt;&lt; &quot; header height &quot; &lt;&lt; headerHeight() &lt;&lt; &quot; footer height &quot; &lt;&lt; footerHeight() &lt;&lt; &quot; fixed behavior &quot; &lt;&lt; scrollBehaviorForFixedElements());
1698     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;layoutViewport: &quot; &lt;&lt; layoutViewport);
1699     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;visualViewport: &quot; &lt;&lt; visualViewportRect() &lt;&lt; &quot; (is override &quot; &lt;&lt; (bool)m_visualViewportOverrideRect &lt;&lt; &quot;)&quot;);
1700     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;stable origins: min: &quot; &lt;&lt; minStableLayoutViewportOrigin() &lt;&lt; &quot; max: &quot;&lt;&lt; maxStableLayoutViewportOrigin());
1701 
1702     if (m_layoutViewportOverrideRect) {
1703         if (currentScrollType() == ScrollType::Programmatic) {
1704             LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;computing new override layout viewport because of programmatic scrolling&quot;);
1705             LayoutPoint newOrigin = computeLayoutViewportOrigin(visualViewportRect(), minStableLayoutViewportOrigin(), maxStableLayoutViewportOrigin(), layoutViewport, StickToDocumentBounds);
1706             setLayoutViewportOverrideRect(LayoutRect(newOrigin, m_layoutViewportOverrideRect.value().size()));
1707         }
1708         layoutOrVisualViewportChanged();
1709         return;
1710     }
1711 
1712     LayoutPoint newLayoutViewportOrigin = computeLayoutViewportOrigin(visualViewportRect(), minStableLayoutViewportOrigin(), maxStableLayoutViewportOrigin(), layoutViewport, scrollBehaviorForFixedElements());
1713     if (newLayoutViewportOrigin != m_layoutViewportOrigin) {
1714         setBaseLayoutViewportOrigin(newLayoutViewportOrigin);
1715         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;layoutViewport changed to &quot; &lt;&lt; layoutViewportRect());
1716     }
1717     layoutOrVisualViewportChanged();
1718 }
1719 
1720 LayoutPoint FrameView::minStableLayoutViewportOrigin() const
1721 {
1722     return unscaledMinimumScrollPosition();
1723 }
1724 
1725 LayoutPoint FrameView::maxStableLayoutViewportOrigin() const
1726 {
1727     LayoutPoint maxPosition = unscaledMaximumScrollPosition();
1728     maxPosition = (maxPosition - LayoutSize(0, headerHeight() + footerHeight())).expandedTo({ });
1729     return maxPosition;
1730 }
1731 
1732 IntPoint FrameView::unscaledScrollOrigin() const
1733 {
1734     if (RenderView* renderView = this-&gt;renderView())
1735         return -renderView-&gt;unscaledDocumentRect().location(); // Akin to code in adjustViewSize().
1736 
1737     return { };
1738 }
1739 
1740 LayoutRect FrameView::layoutViewportRect() const
1741 {
1742     if (m_layoutViewportOverrideRect)
1743         return m_layoutViewportOverrideRect.value();
1744 
1745     // Size of initial containing block, anchored at scroll position, in document coordinates (unchanged by scale factor).
1746     return LayoutRect(m_layoutViewportOrigin, baseLayoutViewportSize());
1747 }
1748 
1749 // visibleContentRect is in the bounds of the scroll view content. That consists of an
1750 // optional header, the document, and an optional footer. Only the document is scaled,
1751 // so we have to compute the visible part of the document in unscaled document coordinates.
1752 // On iOS, pageScaleFactor is always 1 here, and we never have headers and footers.
1753 LayoutRect FrameView::visibleDocumentRect(const FloatRect&amp; visibleContentRect, float headerHeight, float footerHeight, const FloatSize&amp; totalContentsSize, float pageScaleFactor)
1754 {
1755     float contentsHeight = totalContentsSize.height() - headerHeight - footerHeight;
1756 
1757     float rubberBandTop = std::min&lt;float&gt;(visibleContentRect.y(), 0);
1758     float visibleScaledDocumentTop = std::max&lt;float&gt;(visibleContentRect.y() - headerHeight, 0) + rubberBandTop;
1759 
1760     float rubberBandBottom = std::min&lt;float&gt;((totalContentsSize.height() - visibleContentRect.y()) - visibleContentRect.height(), 0);
1761     float visibleScaledDocumentBottom = std::min&lt;float&gt;(visibleContentRect.maxY() - headerHeight, contentsHeight) - rubberBandBottom;
1762 
1763     FloatRect visibleDocumentRect = visibleContentRect;
1764     visibleDocumentRect.setY(visibleScaledDocumentTop);
1765     visibleDocumentRect.setHeight(std::max&lt;float&gt;(visibleScaledDocumentBottom - visibleScaledDocumentTop, 0));
1766     visibleDocumentRect.scale(1 / pageScaleFactor);
1767 
1768     return LayoutRect(visibleDocumentRect);
1769 }
1770 
1771 LayoutRect FrameView::visualViewportRect() const
1772 {
1773     if (m_visualViewportOverrideRect)
1774         return m_visualViewportOverrideRect.value();
1775 
1776     FloatRect visibleContentRect = this-&gt;visibleContentRect(LegacyIOSDocumentVisibleRect);
1777     return visibleDocumentRect(visibleContentRect, headerHeight(), footerHeight(), totalContentsSize(), frameScaleFactor());
1778 }
1779 
1780 LayoutRect FrameView::viewportConstrainedVisibleContentRect() const
1781 {
1782     ASSERT(!frame().settings().visualViewportEnabled());
1783 
1784 #if PLATFORM(IOS_FAMILY)
1785     if (useCustomFixedPositionLayoutRect())
1786         return customFixedPositionLayoutRect();
1787 #endif
1788     LayoutRect viewportRect = visibleContentRect();
1789 
1790     viewportRect.setLocation(scrollPositionForFixedPosition());
1791     return viewportRect;
1792 }
1793 
1794 LayoutRect FrameView::rectForFixedPositionLayout() const
1795 {
1796     if (frame().settings().visualViewportEnabled())
1797         return layoutViewportRect();
1798 
1799     return viewportConstrainedVisibleContentRect();
1800 }
1801 
1802 float FrameView::frameScaleFactor() const
1803 {
1804     return frame().frameScaleFactor();
1805 }
1806 
1807 LayoutPoint FrameView::scrollPositionForFixedPosition() const
1808 {
1809     if (frame().settings().visualViewportEnabled())
1810         return layoutViewportRect().location();
1811 
1812     return scrollPositionForFixedPosition(visibleContentRect(), totalContentsSize(), scrollPosition(), scrollOrigin(), frameScaleFactor(), fixedElementsLayoutRelativeToFrame(), scrollBehaviorForFixedElements(), headerHeight(), footerHeight());
1813 }
1814 
1815 LayoutPoint FrameView::scrollPositionForFixedPosition(const LayoutRect&amp; visibleContentRect, const LayoutSize&amp; totalContentsSize, const LayoutPoint&amp; scrollPosition, const LayoutPoint&amp; scrollOrigin, float frameScaleFactor, bool fixedElementsLayoutRelativeToFrame, ScrollBehaviorForFixedElements behaviorForFixed, int headerHeight, int footerHeight)
1816 {
1817     LayoutPoint position;
1818     if (behaviorForFixed == StickToDocumentBounds)
1819         position = ScrollableArea::constrainScrollPositionForOverhang(visibleContentRect, totalContentsSize, scrollPosition, scrollOrigin, headerHeight, footerHeight);
1820     else {
1821         position = scrollPosition;
1822         position.setY(position.y() - headerHeight);
1823     }
1824 
1825     LayoutSize maxSize = totalContentsSize - visibleContentRect.size();
1826 
1827     float dragFactorX = (fixedElementsLayoutRelativeToFrame || !maxSize.width()) ? 1 : (totalContentsSize.width() - visibleContentRect.width() * frameScaleFactor) / maxSize.width();
1828     float dragFactorY = (fixedElementsLayoutRelativeToFrame || !maxSize.height()) ? 1 : (totalContentsSize.height() - visibleContentRect.height() * frameScaleFactor) / maxSize.height();
1829 
1830     return LayoutPoint(position.x() * dragFactorX / frameScaleFactor, position.y() * dragFactorY / frameScaleFactor);
1831 }
1832 
1833 float FrameView::yPositionForInsetClipLayer(const FloatPoint&amp; scrollPosition, float topContentInset)
1834 {
1835     if (!topContentInset)
1836         return 0;
1837 
1838     // The insetClipLayer should not move for negative scroll values.
1839     float scrollY = std::max&lt;float&gt;(0, scrollPosition.y());
1840 
1841     if (scrollY &gt;= topContentInset)
1842         return 0;
1843 
1844     return topContentInset - scrollY;
1845 }
1846 
1847 float FrameView::yPositionForHeaderLayer(const FloatPoint&amp; scrollPosition, float topContentInset)
1848 {
1849     if (!topContentInset)
1850         return 0;
1851 
1852     float scrollY = std::max&lt;float&gt;(0, scrollPosition.y());
1853 
1854     if (scrollY &gt;= topContentInset)
1855         return topContentInset;
1856 
1857     return scrollY;
1858 }
1859 
1860 float FrameView::yPositionForFooterLayer(const FloatPoint&amp; scrollPosition, float topContentInset, float totalContentsHeight, float footerHeight)
1861 {
1862     return yPositionForHeaderLayer(scrollPosition, topContentInset) + totalContentsHeight - footerHeight;
1863 }
1864 
1865 FloatPoint FrameView::positionForRootContentLayer(const FloatPoint&amp; scrollPosition, const FloatPoint&amp; scrollOrigin, float topContentInset, float headerHeight)
1866 {
1867     return FloatPoint(0, yPositionForHeaderLayer(scrollPosition, topContentInset) + headerHeight) - toFloatSize(scrollOrigin);
1868 }
1869 
1870 FloatPoint FrameView::positionForRootContentLayer() const
1871 {
1872     return positionForRootContentLayer(scrollPosition(), scrollOrigin(), topContentInset(), headerHeight());
1873 }
1874 
1875 #if PLATFORM(IOS_FAMILY)
1876 LayoutRect FrameView::rectForViewportConstrainedObjects(const LayoutRect&amp; visibleContentRect, const LayoutSize&amp; totalContentsSize, float frameScaleFactor, bool fixedElementsLayoutRelativeToFrame, ScrollBehaviorForFixedElements scrollBehavior)
1877 {
1878     if (fixedElementsLayoutRelativeToFrame)
1879         return visibleContentRect;
1880 
1881     if (totalContentsSize.isEmpty())
1882         return visibleContentRect;
1883 
1884     // We impose an lower limit on the size (so an upper limit on the scale) of
1885     // the rect used to position fixed objects so that they don&#39;t crowd into the
1886     // center of the screen at larger scales.
1887     const LayoutUnit maxContentWidthForZoomThreshold = 1024_lu;
1888     float zoomedOutScale = frameScaleFactor * visibleContentRect.width() / std::min(maxContentWidthForZoomThreshold, totalContentsSize.width());
1889     float constraintThresholdScale = 1.5 * zoomedOutScale;
1890     float maxPostionedObjectsRectScale = std::min(frameScaleFactor, constraintThresholdScale);
1891 
1892     LayoutRect viewportConstrainedObjectsRect = visibleContentRect;
1893 
1894     if (frameScaleFactor &gt; constraintThresholdScale) {
1895         FloatRect contentRect(FloatPoint(), totalContentsSize);
1896         FloatRect viewportRect = visibleContentRect;
1897 
1898         // Scale the rect up from a point that is relative to its position in the viewport.
1899         FloatSize sizeDelta = contentRect.size() - viewportRect.size();
1900 
1901         FloatPoint scaleOrigin;
1902         scaleOrigin.setX(contentRect.x() + sizeDelta.width() &gt; 0 ? contentRect.width() * (viewportRect.x() - contentRect.x()) / sizeDelta.width() : 0);
1903         scaleOrigin.setY(contentRect.y() + sizeDelta.height() &gt; 0 ? contentRect.height() * (viewportRect.y() - contentRect.y()) / sizeDelta.height() : 0);
1904 
1905         AffineTransform rescaleTransform = AffineTransform::translation(scaleOrigin.x(), scaleOrigin.y());
1906         rescaleTransform.scale(frameScaleFactor / maxPostionedObjectsRectScale, frameScaleFactor / maxPostionedObjectsRectScale);
1907         rescaleTransform = CGAffineTransformTranslate(rescaleTransform, -scaleOrigin.x(), -scaleOrigin.y());
1908 
1909         viewportConstrainedObjectsRect = enclosingLayoutRect(rescaleTransform.mapRect(visibleContentRect));
1910     }
1911 
1912     if (scrollBehavior == StickToDocumentBounds) {
1913         LayoutRect documentBounds(LayoutPoint(), totalContentsSize);
1914         viewportConstrainedObjectsRect.intersect(documentBounds);
1915     }
1916 
1917     return viewportConstrainedObjectsRect;
1918 }
1919 
1920 LayoutRect FrameView::viewportConstrainedObjectsRect() const
1921 {
1922     return rectForViewportConstrainedObjects(visibleContentRect(), totalContentsSize(), frame().frameScaleFactor(), fixedElementsLayoutRelativeToFrame(), scrollBehaviorForFixedElements());
1923 }
1924 #endif
1925 
1926 ScrollPosition FrameView::minimumScrollPosition() const
1927 {
1928     ScrollPosition minimumPosition = ScrollView::minimumScrollPosition();
1929 
1930     if (frame().isMainFrame() &amp;&amp; m_scrollPinningBehavior == PinToBottom)
1931         minimumPosition.setY(maximumScrollPosition().y());
1932 
1933     return minimumPosition;
1934 }
1935 
1936 ScrollPosition FrameView::maximumScrollPosition() const
1937 {
1938     ScrollPosition maximumPosition = ScrollView::maximumScrollPosition();
1939 
1940     if (frame().isMainFrame() &amp;&amp; m_scrollPinningBehavior == PinToTop)
1941         maximumPosition.setY(minimumScrollPosition().y());
1942 
1943     return maximumPosition;
1944 }
1945 
1946 ScrollPosition FrameView::unscaledMinimumScrollPosition() const
1947 {
1948     if (RenderView* renderView = this-&gt;renderView()) {
1949         IntRect unscaledDocumentRect = renderView-&gt;unscaledDocumentRect();
1950         ScrollPosition minimumPosition = unscaledDocumentRect.location();
1951 
1952         if (frame().isMainFrame() &amp;&amp; m_scrollPinningBehavior == PinToBottom)
1953             minimumPosition.setY(unscaledMaximumScrollPosition().y());
1954 
1955         return minimumPosition;
1956     }
1957 
1958     return minimumScrollPosition();
1959 }
1960 
1961 ScrollPosition FrameView::unscaledMaximumScrollPosition() const
1962 {
1963     if (RenderView* renderView = this-&gt;renderView()) {
1964         IntRect unscaledDocumentRect = renderView-&gt;unscaledDocumentRect();
1965         unscaledDocumentRect.expand(0, headerHeight() + footerHeight());
1966         ScrollPosition maximumPosition = ScrollPosition(unscaledDocumentRect.maxXMaxYCorner() - visibleSize()).expandedTo({ 0, 0 });
1967         if (frame().isMainFrame() &amp;&amp; m_scrollPinningBehavior == PinToTop)
1968             maximumPosition.setY(unscaledMinimumScrollPosition().y());
1969 
1970         return maximumPosition;
1971     }
1972 
1973     return maximumScrollPosition();
1974 }
1975 
1976 void FrameView::viewportContentsChanged()
1977 {
1978     if (!frame().view()) {
1979         // The frame is being destroyed.
1980         return;
1981     }
1982 
1983     if (auto* page = frame().page())
1984         page-&gt;updateValidationBubbleStateIfNeeded();
1985 
1986     // When the viewport contents changes (scroll, resize, style recalc, layout, ...),
1987     // check if we should resume animated images or unthrottle DOM timers.
1988     applyRecursivelyWithVisibleRect([] (FrameView&amp; frameView, const IntRect&amp; visibleRect) {
1989         frameView.resumeVisibleImageAnimations(visibleRect);
1990         frameView.updateScriptedAnimationsAndTimersThrottlingState(visibleRect);
1991 
1992         if (auto* renderView = frameView.frame().contentRenderer())
1993             renderView-&gt;updateVisibleViewportRect(visibleRect);
1994     });
1995 }
1996 
1997 IntRect FrameView::viewRectExpandedByContentInsets() const
1998 {
1999     FloatRect viewRect;
2000     if (delegatesScrolling() &amp;&amp; platformWidget())
2001         viewRect = unobscuredContentRect();
2002     else
2003         viewRect = visualViewportRect();
2004 
2005     if (auto* page = frame().page())
2006         viewRect.expand(page-&gt;contentInsets());
2007 
2008     return IntRect(viewRect);
2009 }
2010 
2011 bool FrameView::fixedElementsLayoutRelativeToFrame() const
2012 {
2013     return frame().settings().fixedElementsLayoutRelativeToFrame();
2014 }
2015 
2016 IntPoint FrameView::lastKnownMousePosition() const
2017 {
2018     return frame().eventHandler().lastKnownMousePosition();
2019 }
2020 
2021 bool FrameView::isHandlingWheelEvent() const
2022 {
2023     return frame().eventHandler().isHandlingWheelEvent();
2024 }
2025 
2026 bool FrameView::shouldSetCursor() const
2027 {
2028     Page* page = frame().page();
2029     return page &amp;&amp; page-&gt;isVisible() &amp;&amp; page-&gt;focusController().isActive();
2030 }
2031 
2032 #if ENABLE(DARK_MODE_CSS)
2033 RenderObject* FrameView::rendererForColorScheme() const
2034 {
2035     auto* document = frame().document();
2036     auto* documentElement = document ? document-&gt;documentElement() : nullptr;
2037     auto* documentElementRenderer = documentElement ? documentElement-&gt;renderer() : nullptr;
2038     if (documentElementRenderer &amp;&amp; documentElementRenderer-&gt;style().hasExplicitlySetColorScheme())
2039         return documentElementRenderer;
2040     auto* bodyElement = document ? document-&gt;bodyOrFrameset() : nullptr;
2041     return bodyElement ? bodyElement-&gt;renderer() : nullptr;
2042 }
2043 #endif
2044 
2045 bool FrameView::useDarkAppearance() const
2046 {
2047 #if ENABLE(DARK_MODE_CSS)
2048     if (auto* renderer = rendererForColorScheme())
2049         return renderer-&gt;useDarkAppearance();
2050 #endif
2051     if (auto* document = frame().document())
2052         return document-&gt;useDarkAppearance(nullptr);
2053     return false;
2054 }
2055 
2056 OptionSet&lt;StyleColor::Options&gt; FrameView::styleColorOptions() const
2057 {
2058 #if ENABLE(DARK_MODE_CSS)
2059     if (auto* renderer = rendererForColorScheme())
2060         return renderer-&gt;styleColorOptions();
2061 #endif
2062     if (auto* document = frame().document())
2063         return document-&gt;styleColorOptions(nullptr);
2064     return { };
2065 }
2066 
2067 bool FrameView::scrollContentsFastPath(const IntSize&amp; scrollDelta, const IntRect&amp; rectToScroll, const IntRect&amp; clipRect)
2068 {
2069     if (!m_viewportConstrainedObjects || m_viewportConstrainedObjects-&gt;isEmpty()) {
2070         frame().page()-&gt;chrome().scroll(scrollDelta, rectToScroll, clipRect);
2071         return true;
2072     }
2073 
2074     bool isCompositedContentLayer = usesCompositedScrolling();
2075 
2076     // Get the rects of the fixed objects visible in the rectToScroll
2077     Region regionToUpdate;
2078     for (auto&amp; renderer : *m_viewportConstrainedObjects) {
2079         if (!renderer-&gt;style().hasViewportConstrainedPosition())
2080             continue;
2081         if (renderer-&gt;isComposited())
2082             continue;
2083 
2084         // Fixed items should always have layers.
2085         ASSERT(renderer-&gt;hasLayer());
2086         RenderLayer* layer = downcast&lt;RenderBoxModelObject&gt;(*renderer).layer();
2087 
2088         if (layer-&gt;viewportConstrainedNotCompositedReason() == RenderLayer::NotCompositedForBoundsOutOfView
2089             || layer-&gt;viewportConstrainedNotCompositedReason() == RenderLayer::NotCompositedForNoVisibleContent) {
2090             // Don&#39;t invalidate for invisible fixed layers.
2091             continue;
2092         }
2093 
2094         if (layer-&gt;hasAncestorWithFilterOutsets()) {
2095             // If the fixed layer has a blur/drop-shadow filter applied on at least one of its parents, we cannot
2096             // scroll using the fast path, otherwise the outsets of the filter will be moved around the page.
2097             return false;
2098         }
2099 
2100         // FIXME: use pixel snapping instead of enclosing when ScrollView has finished transitioning from IntRect to Float/LayoutRect.
2101         IntRect updateRect = enclosingIntRect(layer-&gt;repaintRectIncludingNonCompositingDescendants());
2102         updateRect = contentsToRootView(updateRect);
2103         if (!isCompositedContentLayer)
2104             updateRect.intersect(rectToScroll);
2105         if (!updateRect.isEmpty())
2106             regionToUpdate.unite(updateRect);
2107     }
2108 
2109     // 1) scroll
2110     frame().page()-&gt;chrome().scroll(scrollDelta, rectToScroll, clipRect);
2111 
2112     // 2) update the area of fixed objects that has been invalidated
2113     for (auto&amp; updateRect : regionToUpdate.rects()) {
2114         IntRect scrolledRect = updateRect;
2115         scrolledRect.move(scrollDelta);
2116         updateRect.unite(scrolledRect);
2117         if (isCompositedContentLayer) {
2118             updateRect = rootViewToContents(updateRect);
2119             ASSERT(renderView());
2120             renderView()-&gt;layer()-&gt;setBackingNeedsRepaintInRect(updateRect);
2121             continue;
2122         }
2123         updateRect.intersect(rectToScroll);
2124         frame().page()-&gt;chrome().invalidateContentsAndRootView(updateRect);
2125     }
2126 
2127     return true;
2128 }
2129 
2130 void FrameView::scrollContentsSlowPath(const IntRect&amp; updateRect)
2131 {
2132     repaintSlowRepaintObjects();
2133 
2134     if (!usesCompositedScrolling() &amp;&amp; isEnclosedInCompositingLayer()) {
2135         if (RenderWidget* frameRenderer = frame().ownerRenderer()) {
2136             LayoutRect rect(frameRenderer-&gt;borderLeft() + frameRenderer-&gt;paddingLeft(), frameRenderer-&gt;borderTop() + frameRenderer-&gt;paddingTop(),
2137                 visibleWidth(), visibleHeight());
2138             frameRenderer-&gt;repaintRectangle(rect);
2139             return;
2140         }
2141     }
2142 
2143     ScrollView::scrollContentsSlowPath(updateRect);
2144 }
2145 
2146 void FrameView::repaintSlowRepaintObjects()
2147 {
2148     if (!m_slowRepaintObjects)
2149         return;
2150 
2151     // Renderers with fixed backgrounds may be in compositing layers, so we need to explicitly
2152     // repaint them after scrolling.
2153     for (auto&amp; renderer : *m_slowRepaintObjects)
2154         renderer-&gt;repaintSlowRepaintObject();
2155 }
2156 
2157 // Note that this gets called at painting time.
2158 void FrameView::setIsOverlapped(bool isOverlapped)
2159 {
2160     if (isOverlapped == m_isOverlapped)
2161         return;
2162 
2163     m_isOverlapped = isOverlapped;
2164     updateCanBlitOnScrollRecursively();
2165 }
2166 
2167 void FrameView::setContentIsOpaque(bool contentIsOpaque)
2168 {
2169     if (contentIsOpaque == m_contentIsOpaque)
2170         return;
2171 
2172     m_contentIsOpaque = contentIsOpaque;
2173     updateCanBlitOnScrollRecursively();
2174 }
2175 
2176 void FrameView::restoreScrollbar()
2177 {
2178     setScrollbarsSuppressed(false);
2179 }
2180 
2181 bool FrameView::scrollToFragment(const URL&amp; url)
2182 {
2183     String fragmentIdentifier = url.fragmentIdentifier();
<a name="17" id="anc17"></a><span class="line-modified">2184     if (scrollToFragmentInternal(fragmentIdentifier))</span>
2185         return true;
2186 
2187     // Try again after decoding the ref, based on the document&#39;s encoding.
2188     if (TextResourceDecoder* decoder = frame().document()-&gt;decoder()) {
<a name="18" id="anc18"></a><span class="line-modified">2189         if (scrollToFragmentInternal(decodeURLEscapeSequences(fragmentIdentifier, decoder-&gt;encoding())))</span>
2190             return true;
2191     }
2192 
2193     resetScrollAnchor();
2194     return false;
2195 }
2196 
<a name="19" id="anc19"></a><span class="line-modified">2197 bool FrameView::scrollToFragmentInternal(const String&amp; fragmentIdentifier)</span>
2198 {
2199     LOG(Scrolling, &quot;FrameView::scrollToAnchor %s&quot;, fragmentIdentifier.utf8().data());
2200 
2201     // If our URL has no ref, then we have no place we need to jump to.
2202     if (fragmentIdentifier.isNull())
2203         return false;
2204 
2205     ASSERT(frame().document());
2206     auto&amp; document = *frame().document();
<a name="20" id="anc20"></a><span class="line-modified">2207     RELEASE_ASSERT(document.haveStylesheetsLoaded());</span>






2208 
2209     Element* anchorElement = document.findAnchor(fragmentIdentifier);
2210 
2211     LOG(Scrolling, &quot; anchorElement is %p&quot;, anchorElement);
2212 
2213     // Setting to null will clear the current target.
2214     document.setCSSTarget(anchorElement);
2215 
2216     if (is&lt;SVGDocument&gt;(document)) {
2217         if (fragmentIdentifier.isEmpty())
2218             return false;
2219         if (auto rootElement = SVGDocument::rootElement(document)) {
2220             if (rootElement-&gt;scrollToFragment(fragmentIdentifier))
2221                 return true;
2222             // If SVG failed to scrollToAnchor() and anchorElement is null, no other scrolling will be possible.
2223             if (!anchorElement)
2224                 return false;
2225         }
2226     } else if (!anchorElement &amp;&amp; !(fragmentIdentifier.isEmpty() || equalLettersIgnoringASCIICase(fragmentIdentifier, &quot;top&quot;))) {
2227         // Implement the rule that &quot;&quot; and &quot;top&quot; both mean top of page as in other browsers.
2228         return false;
2229     }
2230 
2231     ContainerNode* scrollPositionAnchor = anchorElement;
2232     if (!scrollPositionAnchor)
2233         scrollPositionAnchor = frame().document();
2234     maintainScrollPositionAtAnchor(scrollPositionAnchor);
2235 
2236     // If the anchor accepts keyboard focus, move focus there to aid users relying on keyboard navigation.
2237     if (anchorElement) {
2238         if (anchorElement-&gt;isFocusable())
2239             document.setFocusedElement(anchorElement);
2240         else {
2241             document.setFocusedElement(nullptr);
2242             document.setFocusNavigationStartingNode(anchorElement);
2243         }
2244     }
2245 
2246     return true;
2247 }
2248 
2249 void FrameView::maintainScrollPositionAtAnchor(ContainerNode* anchorNode)
2250 {
2251     LOG(Scrolling, &quot;FrameView::maintainScrollPositionAtAnchor at %p&quot;, anchorNode);
2252 
2253     m_maintainScrollPositionAnchor = anchorNode;
2254     if (!m_maintainScrollPositionAnchor)
2255         return;
2256     m_shouldScrollToFocusedElement = false;
2257     m_delayedScrollToFocusedElementTimer.stop();
2258 
2259     // We need to update the layout before scrolling, otherwise we could
2260     // really mess things up if an anchor scroll comes at a bad moment.
2261     frame().document()-&gt;updateStyleIfNeeded();
2262     // Only do a layout if changes have occurred that make it necessary.
2263     RenderView* renderView = this-&gt;renderView();
2264     if (renderView &amp;&amp; renderView-&gt;needsLayout())
2265         layoutContext().layout();
2266     else
2267         scrollToAnchor();
2268 }
2269 
2270 void FrameView::scrollElementToRect(const Element&amp; element, const IntRect&amp; rect)
2271 {
2272     frame().document()-&gt;updateLayoutIgnorePendingStylesheets();
2273 
2274     LayoutRect bounds;
2275     if (RenderElement* renderer = element.renderer())
2276         bounds = renderer-&gt;absoluteAnchorRect();
2277     int centeringOffsetX = (rect.width() - bounds.width()) / 2;
2278     int centeringOffsetY = (rect.height() - bounds.height()) / 2;
2279     setScrollPosition(IntPoint(bounds.x() - centeringOffsetX - rect.x(), bounds.y() - centeringOffsetY - rect.y()));
2280 }
2281 
<a name="21" id="anc21"></a><span class="line-modified">2282 void FrameView::setScrollPosition(const ScrollPosition&amp; scrollPosition, ScrollClamping clamping)</span>
2283 {
2284     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView::setScrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; , clearing anchor&quot;);
2285 
2286     auto oldScrollType = currentScrollType();
2287     setCurrentScrollType(ScrollType::Programmatic);
2288 
2289     m_maintainScrollPositionAnchor = nullptr;
2290     m_shouldScrollToFocusedElement = false;
2291     m_delayedScrollToFocusedElementTimer.stop();
2292     Page* page = frame().page();
<a name="22" id="anc22"></a><span class="line-modified">2293     if (page &amp;&amp; page-&gt;isMonitoringWheelEvents())</span>
<span class="line-modified">2294         scrollAnimator().setWheelEventTestMonitor(page-&gt;wheelEventTestMonitor());</span>
<span class="line-modified">2295     ScrollView::setScrollPosition(scrollPosition, clamping);</span>
2296 
2297     setCurrentScrollType(oldScrollType);
2298 }
2299 
2300 void FrameView::resetScrollAnchor()
2301 {
2302     ASSERT(frame().document());
2303     auto&amp; document = *frame().document();
2304 
2305     // If CSS target was set previously, we want to set it to 0, recalc
2306     // and possibly repaint because :target pseudo class may have been
2307     // set (see bug 11321).
2308     document.setCSSTarget(nullptr);
2309 
2310     if (is&lt;SVGDocument&gt;(document)) {
2311         if (auto rootElement = SVGDocument::rootElement(document)) {
2312             // We need to update the layout before resetScrollAnchor(), otherwise we
2313             // could really mess things up if resetting the anchor comes at a bad moment.
2314             document.updateStyleIfNeeded();
2315             rootElement-&gt;resetScrollAnchor();
2316         }
2317     }
2318 }
2319 
2320 void FrameView::scheduleScrollToFocusedElement(SelectionRevealMode selectionRevealMode)
2321 {
2322     if (selectionRevealMode == SelectionRevealMode::DoNotReveal)
2323         return;
2324 
2325     m_selectionRevealModeForFocusedElement = selectionRevealMode;
2326     if (m_shouldScrollToFocusedElement)
2327         return;
2328     m_shouldScrollToFocusedElement = true;
2329     m_delayedScrollToFocusedElementTimer.startOneShot(0_s);
2330 }
2331 
2332 void FrameView::scrollToFocusedElementImmediatelyIfNeeded()
2333 {
2334     if (!m_shouldScrollToFocusedElement)
2335         return;
2336 
2337     m_delayedScrollToFocusedElementTimer.stop();
2338     scrollToFocusedElementInternal();
2339 }
2340 
2341 void FrameView::scrollToFocusedElementTimerFired()
2342 {
2343     auto protectedThis = makeRef(*this);
2344     scrollToFocusedElementInternal();
2345 }
2346 
2347 void FrameView::scrollToFocusedElementInternal()
2348 {
2349     RELEASE_ASSERT(m_shouldScrollToFocusedElement);
2350     auto document = makeRefPtr(frame().document());
2351     if (!document)
2352         return;
2353 
2354     document-&gt;updateLayoutIgnorePendingStylesheets();
2355     if (!m_shouldScrollToFocusedElement)
2356         return; // Updating the layout may have ran scripts.
2357     m_shouldScrollToFocusedElement = false;
2358 
2359     auto focusedElement = makeRefPtr(document-&gt;focusedElement());
2360     if (!focusedElement)
2361         return;
2362     auto updateTarget = focusedElement-&gt;focusAppearanceUpdateTarget();
2363     if (!updateTarget)
2364         return;
2365 
2366     auto* renderer = updateTarget-&gt;renderer();
2367     if (!renderer || renderer-&gt;isWidget())
2368         return;
2369 
2370     bool insideFixed;
2371     LayoutRect absoluteBounds = renderer-&gt;absoluteAnchorRect(&amp;insideFixed);
2372     renderer-&gt;scrollRectToVisible(absoluteBounds, insideFixed, { m_selectionRevealModeForFocusedElement, ScrollAlignment::alignCenterIfNeeded, ScrollAlignment::alignCenterIfNeeded, ShouldAllowCrossOriginScrolling::No });
2373 }
2374 
2375 void FrameView::contentsResized()
2376 {
2377     // For non-delegated scrolling, updateTiledBackingAdaptiveSizing() is called via addedOrRemovedScrollbar() which occurs less often.
2378     if (delegatesScrolling())
2379         updateTiledBackingAdaptiveSizing();
2380 }
2381 
2382 void FrameView::delegatesScrollingDidChange()
2383 {
2384     RenderView* renderView = this-&gt;renderView();
2385     if (!renderView)
2386         return;
2387 
2388     RenderLayerCompositor&amp; compositor = renderView-&gt;compositor();
2389     // When we switch to delegatesScrolling mode, we should destroy the scrolling/clipping layers in RenderLayerCompositor.
2390     if (compositor.usesCompositing()) {
2391         ASSERT(compositor.usesCompositing());
2392         compositor.enableCompositingMode(false);
2393         compositor.clearBackingForAllLayers();
2394     }
2395 }
2396 
2397 #if USE(COORDINATED_GRAPHICS)
2398 void FrameView::setFixedVisibleContentRect(const IntRect&amp; visibleContentRect)
2399 {
2400     bool visibleContentSizeDidChange = false;
2401     if (visibleContentRect.size() != this-&gt;fixedVisibleContentRect().size()) {
2402         // When the viewport size changes or the content is scaled, we need to
2403         // reposition the fixed and sticky positioned elements.
2404         setViewportConstrainedObjectsNeedLayout();
2405         visibleContentSizeDidChange = true;
2406     }
2407 
2408     IntPoint oldPosition = scrollPosition();
2409     ScrollView::setFixedVisibleContentRect(visibleContentRect);
2410     IntPoint newPosition = scrollPosition();
2411     if (oldPosition != newPosition) {
2412         updateLayerPositionsAfterScrolling();
2413         if (frame().settings().acceleratedCompositingForFixedPositionEnabled())
2414             updateCompositingLayersAfterScrolling();
2415         scrollAnimator().setCurrentPosition(newPosition);
2416         scrollPositionChanged(oldPosition, newPosition);
2417     }
2418     if (visibleContentSizeDidChange) {
2419         // Update the scroll-bars to calculate new page-step size.
2420         updateScrollbars(scrollPosition());
2421     }
2422     didChangeScrollOffset();
2423 }
2424 #endif
2425 
2426 void FrameView::setViewportConstrainedObjectsNeedLayout()
2427 {
2428     if (!hasViewportConstrainedObjects())
2429         return;
2430 
2431     for (auto&amp; renderer : *m_viewportConstrainedObjects) {
2432         renderer-&gt;setNeedsLayout();
2433         if (renderer-&gt;hasLayer()) {
2434             auto* layer = downcast&lt;RenderBoxModelObject&gt;(*renderer).layer();
2435             layer-&gt;setNeedsCompositingGeometryUpdate();
2436         }
2437     }
2438 }
2439 
2440 void FrameView::didChangeScrollOffset()
2441 {
2442     if (auto* page = frame().page())
2443         page-&gt;pageOverlayController().didScrollFrame(frame());
2444     frame().loader().client().didChangeScrollOffset();
2445 }
2446 
2447 void FrameView::scrollOffsetChangedViaPlatformWidgetImpl(const ScrollOffset&amp; oldOffset, const ScrollOffset&amp; newOffset)
2448 {
2449     updateLayerPositionsAfterScrolling();
2450     updateCompositingLayersAfterScrolling();
2451     repaintSlowRepaintObjects();
2452     scrollPositionChanged(scrollPositionFromOffset(oldOffset), scrollPositionFromOffset(newOffset));
2453 
2454     if (auto* renderView = this-&gt;renderView()) {
2455         if (renderView-&gt;usesCompositing())
2456             renderView-&gt;compositor().didChangeVisibleRect();
2457     }
2458 }
2459 
2460 // These scroll positions are affected by zooming.
2461 void FrameView::scrollPositionChanged(const ScrollPosition&amp; oldPosition, const ScrollPosition&amp; newPosition)
2462 {
2463     UNUSED_PARAM(oldPosition);
2464     UNUSED_PARAM(newPosition);
2465 
2466     Page* page = frame().page();
2467     Seconds throttlingDelay = page ? page-&gt;chrome().client().eventThrottlingDelay() : 0_s;
2468 
2469     if (throttlingDelay == 0_s) {
2470         m_delayedScrollEventTimer.stop();
2471         sendScrollEvent();
2472     } else if (!m_delayedScrollEventTimer.isActive())
2473         m_delayedScrollEventTimer.startOneShot(throttlingDelay);
2474 
2475     if (RenderView* renderView = this-&gt;renderView()) {
2476         if (renderView-&gt;usesCompositing())
2477             renderView-&gt;compositor().frameViewDidScroll();
2478     }
2479 
2480     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; this &lt;&lt; &quot; scrollPositionChanged from &quot; &lt;&lt; oldPosition &lt;&lt; &quot; to &quot; &lt;&lt; newPosition &lt;&lt; &quot; (scale &quot; &lt;&lt; frameScaleFactor() &lt;&lt; &quot; )&quot;);
2481     updateLayoutViewport();
2482     viewportContentsChanged();
<a name="23" id="anc23"></a><span class="line-added">2483 </span>
<span class="line-added">2484     if (auto* renderView = this-&gt;renderView()) {</span>
<span class="line-added">2485         if (auto* layer = renderView-&gt;layer())</span>
<span class="line-added">2486             frame().editor().renderLayerDidScroll(*layer);</span>
<span class="line-added">2487     }</span>
2488 }
2489 
2490 void FrameView::applyRecursivelyWithVisibleRect(const WTF::Function&lt;void (FrameView&amp; frameView, const IntRect&amp; visibleRect)&gt;&amp; apply)
2491 {
2492     IntRect windowClipRect = this-&gt;windowClipRect();
2493     auto visibleRect = windowToContents(windowClipRect);
2494     apply(*this, visibleRect);
2495 
2496     // Recursive call for subframes. We cache the current FrameView&#39;s windowClipRect to avoid recomputing it for every subframe.
2497     SetForScope&lt;IntRect*&gt; windowClipRectCache(m_cachedWindowClipRect, &amp;windowClipRect);
2498     for (Frame* childFrame = frame().tree().firstChild(); childFrame; childFrame = childFrame-&gt;tree().nextSibling()) {
2499         if (auto* childView = childFrame-&gt;view())
2500             childView-&gt;applyRecursivelyWithVisibleRect(apply);
2501     }
2502 }
2503 
2504 void FrameView::resumeVisibleImageAnimations(const IntRect&amp; visibleRect)
2505 {
2506     if (visibleRect.isEmpty())
2507         return;
2508 
2509     if (auto* renderView = frame().contentRenderer())
2510         renderView-&gt;resumePausedImageAnimationsIfNeeded(visibleRect);
2511 }
2512 
2513 void FrameView::updateScriptedAnimationsAndTimersThrottlingState(const IntRect&amp; visibleRect)
2514 {
2515     if (frame().isMainFrame())
2516         return;
2517 
2518     auto* document = frame().document();
2519     if (!document)
2520         return;
2521 
2522     // We don&#39;t throttle zero-size or display:none frames because those are usually utility frames.
2523     bool shouldThrottle = visibleRect.isEmpty() &amp;&amp; !m_size.isEmpty() &amp;&amp; frame().ownerRenderer();
2524 
2525     if (auto* scriptedAnimationController = document-&gt;scriptedAnimationController()) {
2526         if (shouldThrottle)
2527             scriptedAnimationController-&gt;addThrottlingReason(ScriptedAnimationController::ThrottlingReason::OutsideViewport);
2528         else
2529             scriptedAnimationController-&gt;removeThrottlingReason(ScriptedAnimationController::ThrottlingReason::OutsideViewport);
2530     }
2531 
2532     document-&gt;setTimerThrottlingEnabled(shouldThrottle);
2533 }
2534 
2535 
2536 void FrameView::resumeVisibleImageAnimationsIncludingSubframes()
2537 {
2538     applyRecursivelyWithVisibleRect([] (FrameView&amp; frameView, const IntRect&amp; visibleRect) {
2539         frameView.resumeVisibleImageAnimations(visibleRect);
2540     });
2541 }
2542 
2543 void FrameView::updateLayerPositionsAfterScrolling()
2544 {
2545     // If we&#39;re scrolling as a result of updating the view size after layout, we&#39;ll update widgets and layer positions soon anyway.
2546     if (layoutContext().layoutPhase() == FrameViewLayoutContext::LayoutPhase::InViewSizeAdjust)
2547         return;
2548 
2549     if (!layoutContext().isLayoutNested() &amp;&amp; hasViewportConstrainedObjects()) {
2550         if (RenderView* renderView = this-&gt;renderView()) {
2551             updateWidgetPositions();
2552             renderView-&gt;layer()-&gt;updateLayerPositionsAfterDocumentScroll();
2553         }
2554     }
2555 }
2556 
2557 bool FrameView::shouldUpdateCompositingLayersAfterScrolling() const
2558 {
2559 #if ENABLE(ASYNC_SCROLLING)
2560     // If the scrolling thread is updating the fixed elements, then the FrameView should not update them as well.
2561 
2562     Page* page = frame().page();
2563     if (!page)
2564         return true;
2565 
2566     if (&amp;page-&gt;mainFrame() != m_frame.ptr())
2567         return true;
2568 
2569     ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator();
2570     if (!scrollingCoordinator)
2571         return true;
2572 
2573     if (scrollingCoordinator-&gt;shouldUpdateScrollLayerPositionSynchronously(*this))
2574         return true;
2575 
2576     if (currentScrollType() == ScrollType::Programmatic)
2577         return true;
2578 
2579     return false;
2580 #endif
2581     return true;
2582 }
2583 
2584 void FrameView::updateCompositingLayersAfterScrolling()
2585 {
2586     ASSERT(layoutContext().layoutPhase() &gt;= FrameViewLayoutContext::LayoutPhase::InPostLayout || layoutContext().layoutPhase() == FrameViewLayoutContext::LayoutPhase::OutsideLayout);
2587 
2588     if (!shouldUpdateCompositingLayersAfterScrolling())
2589         return;
2590 
2591     if (!layoutContext().isLayoutNested() &amp;&amp; hasViewportConstrainedObjects()) {
2592         if (RenderView* renderView = this-&gt;renderView())
2593             renderView-&gt;compositor().updateCompositingLayers(CompositingUpdateType::OnScroll);
2594     }
2595 }
2596 
2597 bool FrameView::isRubberBandInProgress() const
2598 {
2599     if (scrollbarsSuppressed())
2600         return false;
2601 
2602     // If the scrolling thread updates the scroll position for this FrameView, then we should return
2603     // ScrollingCoordinator::isRubberBandInProgress().
2604     if (Page* page = frame().page()) {
2605         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator()) {
2606             if (!scrollingCoordinator-&gt;shouldUpdateScrollLayerPositionSynchronously(*this))
2607                 return scrollingCoordinator-&gt;isRubberBandInProgress();
2608         }
2609     }
2610 
2611     // If the main thread updates the scroll position for this FrameView, we should return
2612     // ScrollAnimator::isRubberBandInProgress().
2613     if (ScrollAnimator* scrollAnimator = existingScrollAnimator())
2614         return scrollAnimator-&gt;isRubberBandInProgress();
2615 
2616     return false;
2617 }
2618 
<a name="24" id="anc24"></a><span class="line-modified">2619 bool FrameView::requestScrollPositionUpdate(const ScrollPosition&amp; position, ScrollType scrollType, ScrollClamping clamping)</span>
2620 {
2621     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView::requestScrollPositionUpdate &quot; &lt;&lt; position);
2622 
2623 #if ENABLE(ASYNC_SCROLLING)
2624     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
2625         tiledBacking-&gt;prepopulateRect(FloatRect(position, visibleContentRect().size()));
2626 #endif
2627 
2628 #if ENABLE(ASYNC_SCROLLING) || USE(COORDINATED_GRAPHICS)
2629     if (Page* page = frame().page()) {
2630         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
<a name="25" id="anc25"></a><span class="line-modified">2631             return scrollingCoordinator-&gt;requestScrollPositionUpdate(*this, position, scrollType, clamping);</span>
2632     }
2633 #else
2634     UNUSED_PARAM(position);
2635 #endif
2636 
2637     return false;
2638 }
2639 
2640 HostWindow* FrameView::hostWindow() const
2641 {
2642     auto* page = frame().page();
2643     if (!page)
2644         return nullptr;
2645     return &amp;page-&gt;chrome();
2646 }
2647 
2648 void FrameView::addTrackedRepaintRect(const FloatRect&amp; r)
2649 {
2650     if (!m_isTrackingRepaints || r.isEmpty())
2651         return;
2652 
2653     FloatRect repaintRect = r;
2654     repaintRect.moveBy(-scrollPosition());
2655     m_trackedRepaintRects.append(repaintRect);
2656 }
2657 
2658 void FrameView::repaintContentRectangle(const IntRect&amp; r)
2659 {
2660     ASSERT(!frame().ownerElement());
2661 
2662     if (!shouldUpdate())
2663         return;
2664 
2665     ScrollView::repaintContentRectangle(r);
2666 }
2667 
2668 static unsigned countRenderedCharactersInRenderObjectWithThreshold(const RenderElement&amp; renderer, unsigned threshold)
2669 {
2670     unsigned count = 0;
2671     for (const RenderObject* descendant = &amp;renderer; descendant; descendant = descendant-&gt;nextInPreOrder()) {
2672         if (is&lt;RenderText&gt;(*descendant)) {
2673             count += downcast&lt;RenderText&gt;(*descendant).text().length();
2674             if (count &gt;= threshold)
2675                 break;
2676         }
2677     }
2678     return count;
2679 }
2680 
2681 bool FrameView::renderedCharactersExceed(unsigned threshold)
2682 {
2683     if (!frame().contentRenderer())
2684         return false;
2685     return countRenderedCharactersInRenderObjectWithThreshold(*frame().contentRenderer(), threshold) &gt;= threshold;
2686 }
2687 
2688 void FrameView::availableContentSizeChanged(AvailableSizeChangeReason reason)
2689 {
2690     if (Document* document = frame().document()) {
2691         // FIXME: Merge this logic with m_setNeedsLayoutWasDeferred and find a more appropriate
2692         // way of handling potential recursive layouts when the viewport is resized to accomodate
2693         // the content but the content always overflows the viewport. See webkit.org/b/165781.
2694         if (!(layoutContext().layoutPhase() == FrameViewLayoutContext::LayoutPhase::InViewSizeAdjust &amp;&amp; useFixedLayout()))
2695             document-&gt;updateViewportUnitsOnResize();
2696     }
2697 
2698     updateLayoutViewport();
2699     setNeedsLayoutAfterViewConfigurationChange();
2700     ScrollView::availableContentSizeChanged(reason);
2701 }
2702 
2703 bool FrameView::shouldLayoutAfterContentsResized() const
2704 {
2705     return !useFixedLayout() || useCustomFixedPositionLayoutRect();
2706 }
2707 
2708 void FrameView::updateContentsSize()
2709 {
2710     // We check to make sure the view is attached to a frame() as this method can
2711     // be triggered before the view is attached by Frame::createView(...) setting
2712     // various values such as setScrollBarModes(...) for example.  An ASSERT is
2713     // triggered when a view is layout before being attached to a frame().
2714     if (!frame().view())
2715         return;
2716 
2717 #if PLATFORM(IOS_FAMILY)
2718     if (RenderView* root = m_frame-&gt;contentRenderer()) {
2719         if (useCustomFixedPositionLayoutRect() &amp;&amp; hasViewportConstrainedObjects()) {
2720             setViewportConstrainedObjectsNeedLayout();
2721             // We must eagerly enter compositing mode because fixed position elements
2722             // will not have been made compositing via a preceding style change before
2723             // m_useCustomFixedPositionLayoutRect was true.
2724             root-&gt;compositor().enableCompositingMode();
2725         }
2726     }
2727 #endif
2728 
2729     if (shouldLayoutAfterContentsResized() &amp;&amp; needsLayout())
2730         layoutContext().layout();
2731 
2732     if (RenderView* renderView = this-&gt;renderView()) {
2733         if (renderView-&gt;usesCompositing())
2734             renderView-&gt;compositor().frameViewDidChangeSize();
2735     }
2736 }
2737 
2738 void FrameView::addedOrRemovedScrollbar()
2739 {
2740     if (RenderView* renderView = this-&gt;renderView()) {
2741         if (renderView-&gt;usesCompositing())
2742             renderView-&gt;compositor().frameViewDidAddOrRemoveScrollbars();
2743     }
2744 
2745     updateTiledBackingAdaptiveSizing();
2746 }
2747 
2748 TiledBacking::Scrollability FrameView::computeScrollability() const
2749 {
2750     auto* page = frame().page();
2751 
2752     // Use smaller square tiles if the Window is not active to facilitate app napping.
2753     if (!page || !page-&gt;isWindowActive())
2754         return TiledBacking::HorizontallyScrollable | TiledBacking::VerticallyScrollable;
2755 
2756     bool horizontallyScrollable;
2757     bool verticallyScrollable;
2758     bool clippedByAncestorView = static_cast&lt;bool&gt;(m_viewExposedRect);
2759 
2760 #if PLATFORM(IOS_FAMILY)
2761     if (page)
2762         clippedByAncestorView |= page-&gt;enclosedInScrollableAncestorView();
2763 #endif
2764 
2765     if (delegatesScrolling()) {
2766         IntSize documentSize = contentsSize();
2767         IntSize visibleSize = this-&gt;visibleSize();
2768 
2769         horizontallyScrollable = clippedByAncestorView || documentSize.width() &gt; visibleSize.width();
2770         verticallyScrollable = clippedByAncestorView || documentSize.height() &gt; visibleSize.height();
2771     } else {
2772         horizontallyScrollable = clippedByAncestorView || horizontalScrollbar();
2773         verticallyScrollable = clippedByAncestorView || verticalScrollbar();
2774     }
2775 
2776     TiledBacking::Scrollability scrollability = TiledBacking::NotScrollable;
2777     if (horizontallyScrollable)
2778         scrollability = TiledBacking::HorizontallyScrollable;
2779 
2780     if (verticallyScrollable)
2781         scrollability |= TiledBacking::VerticallyScrollable;
2782 
2783     return scrollability;
2784 }
2785 
2786 void FrameView::updateTiledBackingAdaptiveSizing()
2787 {
2788     auto* tiledBacking = this-&gt;tiledBacking();
2789     if (!tiledBacking)
2790         return;
2791 
2792     tiledBacking-&gt;setScrollability(computeScrollability());
2793 }
2794 
2795 // FIXME: This shouldn&#39;t be called from outside; FrameView should call it when the relevant viewports change.
2796 void FrameView::layoutOrVisualViewportChanged()
2797 {
2798     if (!frame().settings().visualViewportAPIEnabled())
2799         return;
2800 
2801     if (auto* window = frame().window())
2802         window-&gt;visualViewport().update();
2803 
2804     if (auto* page = frame().page()) {
2805         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
2806             scrollingCoordinator-&gt;frameViewVisualViewportChanged(*this);
2807     }
2808 }
2809 
<a name="26" id="anc26"></a>

2810 void FrameView::unobscuredContentSizeChanged()
2811 {
<a name="27" id="anc27"></a><span class="line-added">2812 #if PLATFORM(IOS_FAMILY)</span>
2813     updateTiledBackingAdaptiveSizing();
<a name="28" id="anc28"></a>

2814 #endif
<a name="29" id="anc29"></a><span class="line-added">2815 }</span>
2816 
2817 static LayerFlushThrottleState::Flags determineLayerFlushThrottleState(Page&amp; page)
2818 {
2819     // We only throttle when constantly receiving new data during the inital page load.
2820     if (!page.progress().isMainLoadProgressing())
2821         return 0;
2822     // Scrolling during page loading disables throttling.
2823     if (page.mainFrame().view()-&gt;wasScrolledByUser())
2824         return 0;
2825     // Disable for image documents so large GIF animations don&#39;t get throttled during loading.
2826     auto* document = page.mainFrame().document();
2827     if (!document || is&lt;ImageDocument&gt;(*document))
2828         return 0;
2829     return LayerFlushThrottleState::Enabled;
2830 }
2831 
2832 void FrameView::disableLayerFlushThrottlingTemporarilyForInteraction()
2833 {
2834     if (!frame().page())
2835         return;
2836     auto&amp; page = *frame().page();
2837 
2838     LayerFlushThrottleState::Flags flags = LayerFlushThrottleState::UserIsInteracting | determineLayerFlushThrottleState(page);
2839     if (page.chrome().client().adjustLayerFlushThrottling(flags))
2840         return;
2841 
2842     if (RenderView* view = renderView())
2843         view-&gt;compositor().disableLayerFlushThrottlingTemporarilyForInteraction();
2844 }
2845 
2846 void FrameView::loadProgressingStatusChanged()
2847 {
2848     if (!m_isVisuallyNonEmpty &amp;&amp; frame().loader().isComplete())
2849         fireLayoutRelatedMilestonesIfNeeded();
2850     updateLayerFlushThrottling();
2851     adjustTiledBackingCoverage();
2852 }
2853 
2854 void FrameView::updateLayerFlushThrottling()
2855 {
2856     Page* page = frame().page();
2857     if (!page)
2858         return;
2859 
2860     ASSERT(frame().isMainFrame());
2861 
2862     LayerFlushThrottleState::Flags flags = determineLayerFlushThrottleState(*page);
2863 
2864     // See if the client is handling throttling.
2865     if (page-&gt;chrome().client().adjustLayerFlushThrottling(flags))
2866         return;
2867 
2868     for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr())) {
2869         if (RenderView* renderView = frame-&gt;contentRenderer())
2870             renderView-&gt;compositor().setLayerFlushThrottlingEnabled(flags &amp; LayerFlushThrottleState::Enabled);
2871     }
2872 }
2873 
2874 void FrameView::adjustTiledBackingCoverage()
2875 {
2876     if (!m_speculativeTilingEnabled)
2877         enableSpeculativeTilingIfNeeded();
2878 
2879     RenderView* renderView = this-&gt;renderView();
2880     if (renderView &amp;&amp; renderView-&gt;layer() &amp;&amp; renderView-&gt;layer()-&gt;backing())
2881         renderView-&gt;layer()-&gt;backing()-&gt;adjustTiledBackingCoverage();
2882 #if PLATFORM(IOS_FAMILY)
2883     if (LegacyTileCache* tileCache = legacyTileCache())
2884         tileCache-&gt;setSpeculativeTileCreationEnabled(m_speculativeTilingEnabled);
2885 #endif
2886 }
2887 
2888 static bool shouldEnableSpeculativeTilingDuringLoading(const FrameView&amp; view)
2889 {
2890     Page* page = view.frame().page();
2891     return page &amp;&amp; view.isVisuallyNonEmpty() &amp;&amp; !page-&gt;progress().isMainLoadProgressing();
2892 }
2893 
2894 void FrameView::enableSpeculativeTilingIfNeeded()
2895 {
2896     ASSERT(!m_speculativeTilingEnabled);
2897     if (m_wasScrolledByUser) {
2898         m_speculativeTilingEnabled = true;
2899         return;
2900     }
2901     if (!shouldEnableSpeculativeTilingDuringLoading(*this))
2902         return;
2903 
2904     if (m_speculativeTilingDelayDisabledForTesting) {
2905         speculativeTilingEnableTimerFired();
2906         return;
2907     }
2908 
2909     if (m_speculativeTilingEnableTimer.isActive())
2910         return;
2911     // Delay enabling a bit as load completion may trigger further loading from scripts.
2912     static const Seconds speculativeTilingEnableDelay { 500_ms };
2913     m_speculativeTilingEnableTimer.startOneShot(speculativeTilingEnableDelay);
2914 }
2915 
2916 void FrameView::speculativeTilingEnableTimerFired()
2917 {
2918     if (m_speculativeTilingEnabled)
2919         return;
2920     m_speculativeTilingEnabled = shouldEnableSpeculativeTilingDuringLoading(*this);
2921     adjustTiledBackingCoverage();
2922 }
2923 
2924 void FrameView::show()
2925 {
2926     ScrollView::show();
2927 
2928     if (frame().isMainFrame()) {
2929         // Turn off speculative tiling for a brief moment after a FrameView appears on screen.
2930         // Note that adjustTiledBackingCoverage() kicks the (500ms) timer to re-enable it.
2931         m_speculativeTilingEnabled = false;
2932         m_wasScrolledByUser = false;
2933         adjustTiledBackingCoverage();
2934     }
2935 }
2936 
2937 void FrameView::hide()
2938 {
2939     ScrollView::hide();
2940     adjustTiledBackingCoverage();
2941 }
2942 
2943 bool FrameView::needsLayout() const
2944 {
2945     return layoutContext().needsLayout();
2946 }
2947 
2948 void FrameView::setNeedsLayoutAfterViewConfigurationChange()
2949 {
2950     layoutContext().setNeedsLayoutAfterViewConfigurationChange();
2951 }
2952 
2953 void FrameView::setNeedsCompositingConfigurationUpdate()
2954 {
2955     RenderView* renderView = this-&gt;renderView();
2956     if (renderView &amp;&amp; renderView-&gt;usesCompositing()) {
2957         if (auto* rootLayer = renderView-&gt;layer())
2958             rootLayer-&gt;setNeedsCompositingConfigurationUpdate();
2959         renderView-&gt;compositor().scheduleCompositingLayerUpdate();
2960     }
2961 }
2962 
2963 void FrameView::setNeedsCompositingGeometryUpdate()
2964 {
2965     RenderView* renderView = this-&gt;renderView();
2966     if (renderView-&gt;usesCompositing()) {
2967         if (auto* rootLayer = renderView-&gt;layer())
2968             rootLayer-&gt;setNeedsCompositingGeometryUpdate();
2969         renderView-&gt;compositor().scheduleCompositingLayerUpdate();
2970     }
2971 }
2972 
2973 void FrameView::scheduleSelectionUpdate()
2974 {
2975     if (needsLayout())
2976         return;
2977     // FIXME: We should not need to go through the layout process since selection update does not change dimension/geometry.
2978     // However we can&#39;t tell at this point if the tree is stable yet, so let&#39;s just schedule a root only layout for now.
2979     setNeedsLayoutAfterViewConfigurationChange();
2980 }
2981 
2982 bool FrameView::isTransparent() const
2983 {
2984     return m_isTransparent;
2985 }
2986 
2987 void FrameView::setTransparent(bool isTransparent)
2988 {
2989     if (m_isTransparent == isTransparent)
2990         return;
2991 
2992     m_isTransparent = isTransparent;
2993 
2994     // setTransparent can be called in the window between FrameView initialization
2995     // and switching in the new Document; this means that the RenderView that we
2996     // retrieve is actually attached to the previous Document, which is going away,
2997     // and must not update compositing layers.
2998     if (!isViewForDocumentInFrame())
2999         return;
3000 
3001     setNeedsLayoutAfterViewConfigurationChange();
3002     setNeedsCompositingConfigurationUpdate();
3003 }
3004 
3005 bool FrameView::hasOpaqueBackground() const
3006 {
3007     return !m_isTransparent &amp;&amp; m_baseBackgroundColor.isOpaque();
3008 }
3009 
3010 Color FrameView::baseBackgroundColor() const
3011 {
3012     return m_baseBackgroundColor;
3013 }
3014 
3015 void FrameView::setBaseBackgroundColor(const Color&amp; backgroundColor)
3016 {
3017     Color newBaseBackgroundColor = backgroundColor.isValid() ? backgroundColor : Color::white;
3018     if (m_baseBackgroundColor == newBaseBackgroundColor)
3019         return;
3020 
3021     m_baseBackgroundColor = newBaseBackgroundColor;
3022 
3023     if (!isViewForDocumentInFrame())
3024         return;
3025 
3026     recalculateScrollbarOverlayStyle();
3027     setNeedsLayoutAfterViewConfigurationChange();
3028     setNeedsCompositingConfigurationUpdate();
3029 }
3030 
3031 void FrameView::updateBackgroundRecursively(const Optional&lt;Color&gt;&amp; backgroundColor)
3032 {
3033 #if HAVE(OS_DARK_MODE_SUPPORT)
3034     Color baseBackgroundColor = backgroundColor.valueOr(RenderTheme::singleton().systemColor(CSSValueAppleSystemControlBackground, styleColorOptions()));
3035 #else
3036     Color baseBackgroundColor = backgroundColor.valueOr(Color::white);
3037 #endif
3038 
3039     for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr())) {
3040         if (FrameView* view = frame-&gt;view()) {
3041             view-&gt;setTransparent(!baseBackgroundColor.isVisible());
3042             view-&gt;setBaseBackgroundColor(baseBackgroundColor);
3043             if (view-&gt;needsLayout())
3044                 view-&gt;layoutContext().scheduleLayout();
3045         }
3046     }
3047 }
3048 
3049 bool FrameView::hasExtendedBackgroundRectForPainting() const
3050 {
3051     TiledBacking* tiledBacking = this-&gt;tiledBacking();
3052     if (!tiledBacking)
3053         return false;
3054 
3055     return tiledBacking-&gt;hasMargins();
3056 }
3057 
3058 void FrameView::updateExtendBackgroundIfNecessary()
3059 {
3060     ExtendedBackgroundMode mode = calculateExtendedBackgroundMode();
3061     if (mode == ExtendedBackgroundModeNone)
3062         return;
3063 
3064     updateTilesForExtendedBackgroundMode(mode);
3065 }
3066 
3067 FrameView::ExtendedBackgroundMode FrameView::calculateExtendedBackgroundMode() const
3068 {
3069 #if PLATFORM(IOS_FAMILY)
3070     // &lt;rdar://problem/16201373&gt;
3071     return ExtendedBackgroundModeNone;
3072 #else
3073     if (!frame().settings().backgroundShouldExtendBeyondPage())
3074         return ExtendedBackgroundModeNone;
3075 
3076     // Just because Settings::backgroundShouldExtendBeyondPage() is true does not necessarily mean
3077     // that the background rect needs to be extended for painting. Simple backgrounds can be extended
3078     // just with RenderLayerCompositor&#39;s rootExtendedBackgroundColor. More complicated backgrounds,
3079     // such as images, require extending the background rect to continue painting into the extended
3080     // region. This function finds out if it is necessary to extend the background rect for painting.
3081 
3082     if (!frame().isMainFrame())
3083         return ExtendedBackgroundModeNone;
3084 
3085     Document* document = frame().document();
3086     if (!document)
3087         return ExtendedBackgroundModeNone;
3088 
3089     if (!renderView())
3090         return ExtendedBackgroundModeNone;
3091 
3092     auto* rootBackgroundRenderer = renderView()-&gt;rendererForRootBackground();
3093     if (!rootBackgroundRenderer)
3094         return ExtendedBackgroundModeNone;
3095 
3096     if (!rootBackgroundRenderer-&gt;style().hasBackgroundImage())
3097         return ExtendedBackgroundModeNone;
3098 
3099     ExtendedBackgroundMode mode = ExtendedBackgroundModeNone;
3100     if (rootBackgroundRenderer-&gt;style().backgroundRepeatX() == FillRepeat::Repeat)
3101         mode |= ExtendedBackgroundModeHorizontal;
3102     if (rootBackgroundRenderer-&gt;style().backgroundRepeatY() == FillRepeat::Repeat)
3103         mode |= ExtendedBackgroundModeVertical;
3104 
3105     return mode;
3106 #endif
3107 }
3108 
3109 void FrameView::updateTilesForExtendedBackgroundMode(ExtendedBackgroundMode mode)
3110 {
3111     RenderView* renderView = this-&gt;renderView();
3112     if (!renderView)
3113         return;
3114 
3115     RenderLayerBacking* backing = renderView-&gt;layer()-&gt;backing();
3116     if (!backing)
3117         return;
3118 
3119     TiledBacking* tiledBacking = backing-&gt;tiledBacking();
3120     if (!tiledBacking)
3121         return;
3122 
3123     ExtendedBackgroundMode existingMode = ExtendedBackgroundModeNone;
3124     if (tiledBacking-&gt;hasVerticalMargins())
3125         existingMode |= ExtendedBackgroundModeVertical;
3126     if (tiledBacking-&gt;hasHorizontalMargins())
3127         existingMode |= ExtendedBackgroundModeHorizontal;
3128 
3129     if (existingMode == mode)
3130         return;
3131 
3132     backing-&gt;setTiledBackingHasMargins(mode &amp; ExtendedBackgroundModeHorizontal, mode &amp; ExtendedBackgroundModeVertical);
3133 }
3134 
3135 IntRect FrameView::extendedBackgroundRectForPainting() const
3136 {
3137     TiledBacking* tiledBacking = this-&gt;tiledBacking();
3138     if (!tiledBacking)
3139         return IntRect();
3140 
3141     RenderView* renderView = this-&gt;renderView();
3142     if (!renderView)
3143         return IntRect();
3144 
3145     LayoutRect extendedRect = renderView-&gt;unextendedBackgroundRect();
3146     if (!tiledBacking-&gt;hasMargins())
3147         return snappedIntRect(extendedRect);
3148 
3149     extendedRect.moveBy(LayoutPoint(-tiledBacking-&gt;leftMarginWidth(), -tiledBacking-&gt;topMarginHeight()));
3150     extendedRect.expand(LayoutSize(tiledBacking-&gt;leftMarginWidth() + tiledBacking-&gt;rightMarginWidth(), tiledBacking-&gt;topMarginHeight() + tiledBacking-&gt;bottomMarginHeight()));
3151     return snappedIntRect(extendedRect);
3152 }
3153 
3154 bool FrameView::shouldUpdateWhileOffscreen() const
3155 {
3156     return m_shouldUpdateWhileOffscreen;
3157 }
3158 
3159 void FrameView::setShouldUpdateWhileOffscreen(bool shouldUpdateWhileOffscreen)
3160 {
3161     m_shouldUpdateWhileOffscreen = shouldUpdateWhileOffscreen;
3162 }
3163 
3164 bool FrameView::shouldUpdate() const
3165 {
3166     if (isOffscreen() &amp;&amp; !shouldUpdateWhileOffscreen())
3167         return false;
3168     return true;
3169 }
3170 
3171 bool FrameView::safeToPropagateScrollToParent() const
3172 {
3173     auto* document = frame().document();
3174     if (!document)
3175         return false;
3176 
3177     auto* parentFrame = frame().tree().parent();
3178     if (!parentFrame)
3179         return false;
3180 
3181     auto* parentDocument = parentFrame-&gt;document();
3182     if (!parentDocument)
3183         return false;
3184 
3185     return document-&gt;securityOrigin().canAccess(parentDocument-&gt;securityOrigin());
3186 }
3187 
3188 void FrameView::scrollToAnchor()
3189 {
3190     RefPtr&lt;ContainerNode&gt; anchorNode = m_maintainScrollPositionAnchor;
3191 
3192     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView::scrollToAnchor() &quot; &lt;&lt; anchorNode.get());
3193 
3194     if (!anchorNode)
3195         return;
3196 
3197     if (!anchorNode-&gt;renderer())
3198         return;
3199     m_shouldScrollToFocusedElement = false;
3200     m_delayedScrollToFocusedElementTimer.stop();
3201 
3202     LayoutRect rect;
3203     bool insideFixed = false;
3204     if (anchorNode != frame().document() &amp;&amp; anchorNode-&gt;renderer())
3205         rect = anchorNode-&gt;renderer()-&gt;absoluteAnchorRect(&amp;insideFixed);
3206 
3207     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot; anchor node rect &quot; &lt;&lt; rect);
3208 
3209     // Scroll nested layers and frames to reveal the anchor.
3210     // Align to the top and to the closest side (this matches other browsers).
3211     if (anchorNode-&gt;renderer()-&gt;style().isHorizontalWritingMode())
3212         anchorNode-&gt;renderer()-&gt;scrollRectToVisible(rect, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignToEdgeIfNeeded, ScrollAlignment::alignTopAlways, ShouldAllowCrossOriginScrolling::No });
3213     else if (anchorNode-&gt;renderer()-&gt;style().isFlippedBlocksWritingMode())
3214         anchorNode-&gt;renderer()-&gt;scrollRectToVisible(rect, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignRightAlways, ScrollAlignment::alignToEdgeIfNeeded, ShouldAllowCrossOriginScrolling::No });
3215     else
3216         anchorNode-&gt;renderer()-&gt;scrollRectToVisible(rect, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignLeftAlways, ScrollAlignment::alignToEdgeIfNeeded, ShouldAllowCrossOriginScrolling::No });
3217 
3218     if (AXObjectCache* cache = frame().document()-&gt;existingAXObjectCache())
3219         cache-&gt;handleScrolledToAnchor(anchorNode.get());
3220 
3221     // scrollRectToVisible can call into setScrollPosition(), which resets m_maintainScrollPositionAnchor.
3222     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot; restoring anchor node to &quot; &lt;&lt; anchorNode.get());
3223     m_maintainScrollPositionAnchor = anchorNode;
3224     m_shouldScrollToFocusedElement = false;
3225     m_delayedScrollToFocusedElementTimer.stop();
3226 }
3227 
3228 void FrameView::updateEmbeddedObject(RenderEmbeddedObject&amp; embeddedObject)
3229 {
3230     // No need to update if it&#39;s already crashed or known to be missing.
3231     if (embeddedObject.isPluginUnavailable())
3232         return;
3233 
3234     HTMLFrameOwnerElement&amp; element = embeddedObject.frameOwnerElement();
3235 
3236     if (embeddedObject.isSnapshottedPlugIn()) {
3237         if (is&lt;HTMLObjectElement&gt;(element) || is&lt;HTMLEmbedElement&gt;(element)) {
3238             HTMLPlugInImageElement&amp; pluginElement = downcast&lt;HTMLPlugInImageElement&gt;(element);
3239             pluginElement.checkSnapshotStatus();
3240         }
3241         return;
3242     }
3243 
3244     auto weakRenderer = makeWeakPtr(embeddedObject);
3245 
3246     // FIXME: This could turn into a real virtual dispatch if we defined
3247     // updateWidget(PluginCreationOption) on HTMLElement.
3248     if (is&lt;HTMLPlugInImageElement&gt;(element)) {
3249         HTMLPlugInImageElement&amp; pluginElement = downcast&lt;HTMLPlugInImageElement&gt;(element);
3250         if (pluginElement.needsCheckForSizeChange()) {
3251             pluginElement.checkSnapshotStatus();
3252             return;
3253         }
3254         if (pluginElement.needsWidgetUpdate())
3255             pluginElement.updateWidget(CreatePlugins::Yes);
3256     } else
3257         ASSERT_NOT_REACHED();
3258 
3259     // It&#39;s possible the renderer was destroyed below updateWidget() since loading a plugin may execute arbitrary JavaScript.
3260     if (!weakRenderer)
3261         return;
3262 
3263     auto ignoreWidgetState = embeddedObject.updateWidgetPosition();
3264     UNUSED_PARAM(ignoreWidgetState);
3265 }
3266 
3267 bool FrameView::updateEmbeddedObjects()
3268 {
3269     if (layoutContext().isLayoutNested() || !m_embeddedObjectsToUpdate || m_embeddedObjectsToUpdate-&gt;isEmpty())
3270         return true;
3271 
3272     WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
3273 
3274     // Insert a marker for where we should stop.
3275     ASSERT(!m_embeddedObjectsToUpdate-&gt;contains(nullptr));
3276     m_embeddedObjectsToUpdate-&gt;add(nullptr);
3277 
3278     while (!m_embeddedObjectsToUpdate-&gt;isEmpty()) {
3279         RenderEmbeddedObject* embeddedObject = m_embeddedObjectsToUpdate-&gt;takeFirst();
3280         if (!embeddedObject)
3281             break;
3282         updateEmbeddedObject(*embeddedObject);
3283     }
3284 
3285     return m_embeddedObjectsToUpdate-&gt;isEmpty();
3286 }
3287 
3288 void FrameView::updateEmbeddedObjectsTimerFired()
3289 {
3290     RefPtr&lt;FrameView&gt; protectedThis(this);
3291     m_updateEmbeddedObjectsTimer.stop();
3292     for (unsigned i = 0; i &lt; maxUpdateEmbeddedObjectsIterations; i++) {
3293         if (updateEmbeddedObjects())
3294             break;
3295     }
3296 }
3297 
3298 void FrameView::flushAnyPendingPostLayoutTasks()
3299 {
3300     layoutContext().flushAsynchronousTasks();
3301     if (m_updateEmbeddedObjectsTimer.isActive())
3302         updateEmbeddedObjectsTimerFired();
3303 }
3304 
3305 void FrameView::queuePostLayoutCallback(Function&lt;void()&gt;&amp;&amp; callback)
3306 {
3307     m_postLayoutCallbackQueue.append(WTFMove(callback));
3308 }
3309 
3310 void FrameView::flushPostLayoutTasksQueue()
3311 {
3312     if (layoutContext().isLayoutNested())
3313         return;
3314 
3315     if (!m_postLayoutCallbackQueue.size())
3316         return;
3317 
3318     Vector&lt;Function&lt;void()&gt;&gt; queue = WTFMove(m_postLayoutCallbackQueue);
3319     for (auto&amp; task : queue)
3320         task();
3321 }
3322 
3323 void FrameView::performPostLayoutTasks()
3324 {
3325     // FIXME: We should not run any JavaScript code in this function.
3326     LOG(Layout, &quot;FrameView %p performPostLayoutTasks&quot;, this);
3327     updateHasReachedSignificantRenderedTextThreshold();
3328     frame().selection().updateAppearanceAfterLayout();
3329 
3330     flushPostLayoutTasksQueue();
3331 
3332     if (!layoutContext().isLayoutNested() &amp;&amp; frame().document()-&gt;documentElement())
3333         fireLayoutRelatedMilestonesIfNeeded();
3334 
3335 #if PLATFORM(IOS_FAMILY)
3336     // Only send layout-related delegate callbacks synchronously for the main frame to
3337     // avoid re-entering layout for the main frame while delivering a layout-related delegate
3338     // callback for a subframe.
3339     if (frame().isMainFrame()) {
3340         if (Page* page = frame().page())
3341             page-&gt;chrome().client().didLayout();
3342     }
3343 #endif
3344 
3345     // FIXME: We should consider adding DidLayout as a LayoutMilestone. That would let us merge this
3346     // with didLayout(LayoutMilestones).
3347     frame().loader().client().dispatchDidLayout();
3348 
3349     updateWidgetPositions();
3350 
3351 #if ENABLE(CSS_SCROLL_SNAP)
3352     updateSnapOffsets();
3353 #endif
3354     m_updateEmbeddedObjectsTimer.startOneShot(0_s);
3355 
3356     if (auto* page = frame().page()) {
3357         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
3358             scrollingCoordinator-&gt;frameViewLayoutUpdated(*this);
3359     }
3360 
3361     if (RenderView* renderView = this-&gt;renderView()) {
3362         if (renderView-&gt;usesCompositing())
3363             renderView-&gt;compositor().frameViewDidLayout();
3364     }
3365 
3366     scrollToAnchor();
3367 
3368     sendResizeEventIfNeeded();
3369 
3370     updateLayoutViewport();
3371     viewportContentsChanged();
3372 
3373     updateScrollSnapState();
3374 
3375     if (AXObjectCache* cache = frame().document()-&gt;existingAXObjectCache())
3376         cache-&gt;performDeferredCacheUpdate();
3377 }
3378 
3379 IntSize FrameView::sizeForResizeEvent() const
3380 {
3381 #if PLATFORM(IOS_FAMILY)
3382     if (m_useCustomSizeForResizeEvent)
3383         return m_customSizeForResizeEvent;
3384 #endif
3385     if (useFixedLayout() &amp;&amp; !fixedLayoutSize().isEmpty() &amp;&amp; delegatesScrolling())
3386         return fixedLayoutSize();
3387     return visibleContentRectIncludingScrollbars().size();
3388 }
3389 
3390 void FrameView::sendResizeEventIfNeeded()
3391 {
3392     if (layoutContext().isInRenderTreeLayout() || needsLayout())
3393         return;
3394 
3395     RenderView* renderView = this-&gt;renderView();
3396     if (!renderView || renderView-&gt;printing())
3397         return;
3398 
3399     if (frame().page() &amp;&amp; frame().page()-&gt;chrome().client().isSVGImageChromeClient())
3400         return;
3401 
3402     IntSize currentSize = sizeForResizeEvent();
3403     float currentZoomFactor = renderView-&gt;style().zoom();
3404 
3405     if (currentSize == m_lastViewportSize &amp;&amp; currentZoomFactor == m_lastZoomFactor)
3406         return;
3407 
3408     m_lastViewportSize = currentSize;
3409     m_lastZoomFactor = currentZoomFactor;
3410 
3411     if (!layoutContext().didFirstLayout())
3412         return;
3413 
3414 #if PLATFORM(IOS_FAMILY)
3415     // Don&#39;t send the resize event if the document is loading. Some pages automatically reload
3416     // when the window is resized; Safari on iOS often resizes the window while setting up its
3417     // viewport. This obviously can cause problems.
3418     if (DocumentLoader* documentLoader = frame().loader().documentLoader()) {
3419         if (documentLoader-&gt;isLoadingInAPISense())
3420             return;
3421     }
3422 #endif
3423 
<a name="30" id="anc30"></a><span class="line-modified">3424     LOG_WITH_STREAM(Events, stream &lt;&lt; &quot;FrameView&quot; &lt;&lt; this &lt;&lt; &quot;sendResizeEventIfNeeded scheduling resize event for document&quot; &lt;&lt; frame().document() &lt;&lt; &quot;, size &quot; &lt;&lt; currentSize);</span>
<span class="line-modified">3425     frame().document()-&gt;setNeedsDOMWindowResizeEvent();</span>












3426 
<a name="31" id="anc31"></a><span class="line-added">3427     bool isMainFrame = frame().isMainFrame();</span>
3428     if (InspectorInstrumentation::hasFrontends() &amp;&amp; isMainFrame) {
3429         if (Page* page = frame().page()) {
3430             if (InspectorClient* inspectorClient = page-&gt;inspectorController().inspectorClient())
3431                 inspectorClient-&gt;didResizeMainFrame(&amp;frame());
3432         }
3433     }
3434 }
3435 
3436 void FrameView::willStartLiveResize()
3437 {
3438     ScrollView::willStartLiveResize();
3439     adjustTiledBackingCoverage();
3440 }
3441 
3442 void FrameView::willEndLiveResize()
3443 {
3444     ScrollView::willEndLiveResize();
3445     adjustTiledBackingCoverage();
3446 }
3447 
3448 void FrameView::autoSizeIfEnabled()
3449 {
3450     if (!m_shouldAutoSize)
3451         return;
3452 
3453     if (m_inAutoSize)
3454         return;
3455 
3456     auto* document = frame().document();
3457     if (!document)
3458         return;
3459 
3460     auto* renderView = document-&gt;renderView();
3461     if (!renderView)
3462         return;
3463 
3464     auto* firstChild = renderView-&gt;firstChild();
3465     if (!firstChild)
3466         return;
3467 
3468     LOG(Layout, &quot;FrameView %p autoSizeIfEnabled&quot;, this);
3469     SetForScope&lt;bool&gt; changeInAutoSize(m_inAutoSize, true);
3470     if (layoutContext().subtreeLayoutRoot())
3471         layoutContext().convertSubtreeLayoutToFullLayout();
3472 
3473     ScrollbarMode horizonalScrollbarMode = ScrollbarAlwaysOff;
3474     ScrollbarMode verticalScrollbarMode = ScrollbarAlwaysOff;
3475     setVerticalScrollbarLock(false);
3476     setHorizontalScrollbarLock(false);
3477     setScrollbarModes(horizonalScrollbarMode, verticalScrollbarMode, true, true);
3478 
3479     ASSERT(is&lt;RenderElement&gt;(*firstChild));
3480     auto&amp; documentRenderer = downcast&lt;RenderElement&gt;(*firstChild);
3481     documentRenderer.mutableStyle().setMaxWidth(Length(m_autoSizeConstraint.width(), Fixed));
3482     resize(m_autoSizeConstraint.width(), m_autoSizeConstraint.height());
3483 
3484     Ref&lt;FrameView&gt; protectedThis(*this);
3485     document-&gt;updateStyleIfNeeded();
3486     document-&gt;updateLayoutIgnorePendingStylesheets();
3487     // While the final content size could slightly be different after the next resize/layout (see below), we intentionally save and report
3488     // the current value to avoid unstable layout (e.g. content &quot;height: 100%&quot;).
3489     // See also webkit.org/b/173561
3490     m_autoSizeContentSize = contentsSize();
3491 
3492     auto finalWidth = std::max(m_autoSizeConstraint.width(), m_autoSizeContentSize.width());
3493     auto finalHeight = m_autoSizeFixedMinimumHeight ? std::max(m_autoSizeFixedMinimumHeight, m_autoSizeContentSize.height()) : m_autoSizeContentSize.height();
3494     resize(finalWidth, finalHeight);
3495     document-&gt;updateLayoutIgnorePendingStylesheets();
3496     if (auto* page = frame().page())
3497         page-&gt;chrome().client().intrinsicContentsSizeChanged(m_autoSizeContentSize);
3498     m_didRunAutosize = true;
3499 }
3500 
3501 void FrameView::setAutoSizeFixedMinimumHeight(int fixedMinimumHeight)
3502 {
3503     if (m_autoSizeFixedMinimumHeight == fixedMinimumHeight)
3504         return;
3505 
3506     m_autoSizeFixedMinimumHeight = fixedMinimumHeight;
3507 
3508     setNeedsLayoutAfterViewConfigurationChange();
3509 }
3510 
3511 RenderElement* FrameView::viewportRenderer() const
3512 {
3513     if (m_viewportRendererType == ViewportRendererType::None)
3514         return nullptr;
3515 
3516     auto* document = frame().document();
3517     if (!document)
3518         return nullptr;
3519 
3520     if (m_viewportRendererType == ViewportRendererType::Document) {
3521         auto* documentElement = document-&gt;documentElement();
3522         if (!documentElement)
3523             return nullptr;
3524         return documentElement-&gt;renderer();
3525     }
3526 
3527     if (m_viewportRendererType == ViewportRendererType::Body) {
3528         auto* body = document-&gt;body();
3529         if (!body)
3530             return nullptr;
3531         return body-&gt;renderer();
3532     }
3533 
3534     ASSERT_NOT_REACHED();
3535     return nullptr;
3536 }
3537 
3538 void FrameView::updateOverflowStatus(bool horizontalOverflow, bool verticalOverflow)
3539 {
3540     auto* viewportRenderer = this-&gt;viewportRenderer();
3541     if (!viewportRenderer)
3542         return;
3543 
3544     if (m_overflowStatusDirty) {
3545         m_horizontalOverflow = horizontalOverflow;
3546         m_verticalOverflow = verticalOverflow;
3547         m_overflowStatusDirty = false;
3548         return;
3549     }
3550 
3551     bool horizontalOverflowChanged = (m_horizontalOverflow != horizontalOverflow);
3552     bool verticalOverflowChanged = (m_verticalOverflow != verticalOverflow);
3553 
3554     if (horizontalOverflowChanged || verticalOverflowChanged) {
3555         m_horizontalOverflow = horizontalOverflow;
3556         m_verticalOverflow = verticalOverflow;
3557 
3558         Ref&lt;OverflowEvent&gt; overflowEvent = OverflowEvent::create(horizontalOverflowChanged, horizontalOverflow,
3559             verticalOverflowChanged, verticalOverflow);
3560         overflowEvent-&gt;setTarget(viewportRenderer-&gt;element());
3561 
3562         frame().document()-&gt;enqueueOverflowEvent(WTFMove(overflowEvent));
3563     }
3564 }
3565 
3566 const Pagination&amp; FrameView::pagination() const
3567 {
3568     if (m_pagination != Pagination())
3569         return m_pagination;
3570 
3571     if (frame().isMainFrame()) {
3572         if (Page* page = frame().page())
3573             return page-&gt;pagination();
3574     }
3575 
3576     return m_pagination;
3577 }
3578 
3579 void FrameView::setPagination(const Pagination&amp; pagination)
3580 {
3581     if (m_pagination == pagination)
3582         return;
3583 
3584     m_pagination = pagination;
3585 
3586     frame().document()-&gt;styleScope().didChangeStyleSheetEnvironment();
3587 }
3588 
3589 IntRect FrameView::windowClipRect() const
3590 {
3591     ASSERT(frame().view() == this);
3592 
3593     if (m_cachedWindowClipRect)
3594         return *m_cachedWindowClipRect;
3595 
3596     if (paintsEntireContents())
3597         return contentsToWindow(IntRect(IntPoint(), totalContentsSize()));
3598 
3599     // Set our clip rect to be our contents.
3600     IntRect clipRect = contentsToWindow(visibleContentRect(LegacyIOSDocumentVisibleRect));
3601 
3602     if (!frame().ownerElement())
3603         return clipRect;
3604 
3605     // Take our owner element and get its clip rect.
3606     HTMLFrameOwnerElement* ownerElement = frame().ownerElement();
3607     if (FrameView* parentView = ownerElement-&gt;document().view())
3608         clipRect.intersect(parentView-&gt;windowClipRectForFrameOwner(ownerElement, true));
3609     return clipRect;
3610 }
3611 
3612 IntRect FrameView::windowClipRectForFrameOwner(const HTMLFrameOwnerElement* ownerElement, bool clipToLayerContents) const
3613 {
3614     // The renderer can sometimes be null when style=&quot;display:none&quot; interacts
3615     // with external content and plugins.
3616     if (!ownerElement-&gt;renderer())
3617         return windowClipRect();
3618 
3619     // If we have no layer, just return our window clip rect.
3620     const RenderLayer* enclosingLayer = ownerElement-&gt;renderer()-&gt;enclosingLayer();
3621     if (!enclosingLayer)
3622         return windowClipRect();
3623 
3624     // Apply the clip from the layer.
3625     IntRect clipRect;
3626     if (clipToLayerContents)
3627         clipRect = snappedIntRect(enclosingLayer-&gt;childrenClipRect());
3628     else
3629         clipRect = snappedIntRect(enclosingLayer-&gt;selfClipRect());
3630     clipRect = contentsToWindow(clipRect);
3631     return intersection(clipRect, windowClipRect());
3632 }
3633 
3634 bool FrameView::isActive() const
3635 {
3636     Page* page = frame().page();
3637     return page &amp;&amp; page-&gt;focusController().isActive();
3638 }
3639 
3640 bool FrameView::forceUpdateScrollbarsOnMainThreadForPerformanceTesting() const
3641 {
3642     Page* page = frame().page();
3643     return page &amp;&amp; page-&gt;settings().forceUpdateScrollbarsOnMainThreadForPerformanceTesting();
3644 }
3645 
3646 void FrameView::scrollTo(const ScrollPosition&amp; newPosition)
3647 {
3648     IntPoint oldPosition = scrollPosition();
3649     ScrollView::scrollTo(newPosition);
3650     if (oldPosition != scrollPosition())
3651         scrollPositionChanged(oldPosition, scrollPosition());
3652 
3653     didChangeScrollOffset();
3654 }
3655 
3656 float FrameView::adjustScrollStepForFixedContent(float step, ScrollbarOrientation orientation, ScrollGranularity granularity)
3657 {
3658     if (granularity != ScrollByPage || orientation == HorizontalScrollbar)
3659         return step;
3660 
3661     TrackedRendererListHashSet* positionedObjects = nullptr;
3662     if (RenderView* root = frame().contentRenderer()) {
3663         if (!root-&gt;hasPositionedObjects())
3664             return step;
3665         positionedObjects = root-&gt;positionedObjects();
3666     }
3667 
3668     FloatRect unobscuredContentRect = this-&gt;unobscuredContentRect();
3669     float topObscuredArea = 0;
3670     float bottomObscuredArea = 0;
3671     for (const auto&amp; positionedObject : *positionedObjects) {
3672         const RenderStyle&amp; style = positionedObject-&gt;style();
3673         if (style.position() != PositionType::Fixed || style.visibility() == Visibility::Hidden || !style.opacity())
3674             continue;
3675 
3676         FloatQuad contentQuad = positionedObject-&gt;absoluteContentQuad();
3677         if (!contentQuad.isRectilinear())
3678             continue;
3679 
3680         FloatRect contentBoundingBox = contentQuad.boundingBox();
3681         FloatRect fixedRectInView = intersection(unobscuredContentRect, contentBoundingBox);
3682 
3683         if (fixedRectInView.width() &lt; unobscuredContentRect.width())
3684             continue;
3685 
3686         if (fixedRectInView.y() == unobscuredContentRect.y())
3687             topObscuredArea = std::max(topObscuredArea, fixedRectInView.height());
3688         else if (fixedRectInView.maxY() == unobscuredContentRect.maxY())
3689             bottomObscuredArea = std::max(bottomObscuredArea, fixedRectInView.height());
3690     }
3691 
3692     return Scrollbar::pageStep(unobscuredContentRect.height(), unobscuredContentRect.height() - topObscuredArea - bottomObscuredArea);
3693 }
3694 
3695 void FrameView::invalidateScrollbarRect(Scrollbar&amp; scrollbar, const IntRect&amp; rect)
3696 {
3697     // Add in our offset within the FrameView.
3698     IntRect dirtyRect = rect;
3699     dirtyRect.moveBy(scrollbar.location());
3700     invalidateRect(dirtyRect);
3701 }
3702 
3703 float FrameView::visibleContentScaleFactor() const
3704 {
<a name="32" id="anc32"></a><span class="line-modified">3705     if (!frame().isMainFrame())</span>
3706         return 1;
3707 
3708     Page* page = frame().page();
<a name="33" id="anc33"></a><span class="line-modified">3709     // FIXME: This !delegatesScaling() is confusing, and the opposite behavior to Frame::frameScaleFactor().</span>
<span class="line-added">3710     // This function should probably be renamed to delegatedPageScaleFactor().</span>
<span class="line-added">3711     if (!page || !page-&gt;delegatesScaling())</span>
3712         return 1;
3713 
3714     return page-&gt;pageScaleFactor();
3715 }
3716 
3717 void FrameView::setVisibleScrollerThumbRect(const IntRect&amp; scrollerThumb)
3718 {
3719     if (!frame().isMainFrame())
3720         return;
3721 
3722     if (Page* page = frame().page())
3723         page-&gt;chrome().client().notifyScrollerThumbIsVisibleInRect(scrollerThumb);
3724 }
3725 
3726 ScrollableArea* FrameView::enclosingScrollableArea() const
3727 {
3728     // FIXME: Walk up the frame tree and look for a scrollable parent frame or RenderLayer.
3729     return nullptr;
3730 }
3731 
3732 IntRect FrameView::scrollableAreaBoundingBox(bool*) const
3733 {
3734     RenderWidget* ownerRenderer = frame().ownerRenderer();
3735     if (!ownerRenderer)
3736         return frameRect();
3737 
3738     return ownerRenderer-&gt;absoluteContentQuad().enclosingBoundingBox();
3739 }
3740 
3741 bool FrameView::isScrollable(Scrollability definitionOfScrollable)
3742 {
3743     // Check for:
3744     // 1) If there an actual overflow.
3745     // 2) display:none or visibility:hidden set to self or inherited.
3746     // 3) overflow{-x,-y}: hidden;
3747     // 4) scrolling: no;
3748     if (!didFirstLayout())
3749         return false;
3750 
3751     bool requiresActualOverflowToBeConsideredScrollable = !frame().isMainFrame() || definitionOfScrollable != Scrollability::ScrollableOrRubberbandable;
3752 #if !ENABLE(RUBBER_BANDING)
3753     requiresActualOverflowToBeConsideredScrollable = true;
3754 #endif
3755 
3756     // Covers #1
3757     if (requiresActualOverflowToBeConsideredScrollable) {
3758         IntSize totalContentsSize = this-&gt;totalContentsSize();
3759         IntSize visibleContentSize = visibleContentRect(LegacyIOSDocumentVisibleRect).size();
3760         if (totalContentsSize.height() &lt;= visibleContentSize.height() &amp;&amp; totalContentsSize.width() &lt;= visibleContentSize.width())
3761             return false;
3762     }
3763 
3764     // Covers #2.
3765     HTMLFrameOwnerElement* owner = frame().ownerElement();
3766     if (owner &amp;&amp; (!owner-&gt;renderer() || !owner-&gt;renderer()-&gt;visibleToHitTesting()))
3767         return false;
3768 
3769     // Cover #3 and #4.
3770     ScrollbarMode horizontalMode;
3771     ScrollbarMode verticalMode;
3772     calculateScrollbarModesForLayout(horizontalMode, verticalMode, RulesFromWebContentOnly);
3773     if (horizontalMode == ScrollbarAlwaysOff &amp;&amp; verticalMode == ScrollbarAlwaysOff)
3774         return false;
3775 
3776     return true;
3777 }
3778 
3779 bool FrameView::isScrollableOrRubberbandable()
3780 {
3781     return isScrollable(Scrollability::ScrollableOrRubberbandable);
3782 }
3783 
3784 bool FrameView::hasScrollableOrRubberbandableAncestor()
3785 {
3786     if (frame().isMainFrame())
3787         return isScrollableOrRubberbandable();
3788 
3789     for (FrameView* parent = this-&gt;parentFrameView(); parent; parent = parent-&gt;parentFrameView()) {
3790         Scrollability frameScrollability = parent-&gt;frame().isMainFrame() ? Scrollability::ScrollableOrRubberbandable : Scrollability::Scrollable;
3791         if (parent-&gt;isScrollable(frameScrollability))
3792             return true;
3793     }
3794 
3795     return false;
3796 }
3797 
3798 void FrameView::updateScrollableAreaSet()
3799 {
3800     // That ensures that only inner frames are cached.
3801     FrameView* parentFrameView = this-&gt;parentFrameView();
3802     if (!parentFrameView)
3803         return;
3804 
3805     if (!isScrollable()) {
3806         parentFrameView-&gt;removeScrollableArea(this);
3807         return;
3808     }
3809 
3810     parentFrameView-&gt;addScrollableArea(this);
3811 }
3812 
3813 bool FrameView::shouldSuspendScrollAnimations() const
3814 {
3815     return frame().loader().state() != FrameStateComplete;
3816 }
3817 
3818 void FrameView::scrollbarStyleChanged(ScrollbarStyle newStyle, bool forceUpdate)
3819 {
3820     if (!frame().isMainFrame())
3821         return;
3822 
3823     if (Page* page = frame().page())
3824         page-&gt;chrome().client().recommendedScrollbarStyleDidChange(newStyle);
3825 
3826     ScrollView::scrollbarStyleChanged(newStyle, forceUpdate);
3827 }
3828 
3829 void FrameView::notifyPageThatContentAreaWillPaint() const
3830 {
3831     Page* page = frame().page();
3832     if (!page)
3833         return;
3834 
3835     contentAreaWillPaint();
3836 
3837     if (!m_scrollableAreas)
3838         return;
3839 
3840     for (auto&amp; scrollableArea : *m_scrollableAreas)
3841         scrollableArea-&gt;contentAreaWillPaint();
3842 }
3843 
3844 bool FrameView::scrollAnimatorEnabled() const
3845 {
3846 #if ENABLE(SMOOTH_SCROLLING)
3847     if (Page* page = frame().page())
3848         return page-&gt;settings().scrollAnimatorEnabled();
3849 #endif
3850 
3851     return false;
3852 }
3853 
3854 void FrameView::updateScrollCorner()
3855 {
3856     RenderElement* renderer = nullptr;
3857     std::unique_ptr&lt;RenderStyle&gt; cornerStyle;
3858     IntRect cornerRect = scrollCornerRect();
3859 
3860     if (!cornerRect.isEmpty()) {
3861         // Try the &lt;body&gt; element first as a scroll corner source.
3862         Document* doc = frame().document();
3863         Element* body = doc ? doc-&gt;bodyOrFrameset() : nullptr;
3864         if (body &amp;&amp; body-&gt;renderer()) {
3865             renderer = body-&gt;renderer();
<a name="34" id="anc34"></a><span class="line-modified">3866             cornerStyle = renderer-&gt;getUncachedPseudoStyle({ PseudoId::ScrollbarCorner }, &amp;renderer-&gt;style());</span>
3867         }
3868 
3869         if (!cornerStyle) {
3870             // If the &lt;body&gt; didn&#39;t have a custom style, then the root element might.
3871             Element* docElement = doc ? doc-&gt;documentElement() : nullptr;
3872             if (docElement &amp;&amp; docElement-&gt;renderer()) {
3873                 renderer = docElement-&gt;renderer();
<a name="35" id="anc35"></a><span class="line-modified">3874                 cornerStyle = renderer-&gt;getUncachedPseudoStyle({ PseudoId::ScrollbarCorner }, &amp;renderer-&gt;style());</span>
3875             }
3876         }
3877 
3878         if (!cornerStyle) {
3879             // If we have an owning iframe/frame element, then it can set the custom scrollbar also.
<a name="36" id="anc36"></a><span class="line-added">3880             // FIXME: Seems wrong to do this for cross-origin frames.</span>
3881             if (RenderWidget* renderer = frame().ownerRenderer())
<a name="37" id="anc37"></a><span class="line-modified">3882                 cornerStyle = renderer-&gt;getUncachedPseudoStyle({ PseudoId::ScrollbarCorner }, &amp;renderer-&gt;style());</span>
3883         }
3884     }
3885 
3886     if (!cornerStyle)
3887         m_scrollCorner = nullptr;
3888     else {
3889         if (!m_scrollCorner) {
3890             m_scrollCorner = createRenderer&lt;RenderScrollbarPart&gt;(renderer-&gt;document(), WTFMove(*cornerStyle));
3891             m_scrollCorner-&gt;initializeStyle();
3892         } else
3893             m_scrollCorner-&gt;setStyle(WTFMove(*cornerStyle));
3894         invalidateScrollCorner(cornerRect);
3895     }
3896 }
3897 
3898 void FrameView::paintScrollCorner(GraphicsContext&amp; context, const IntRect&amp; cornerRect)
3899 {
3900     if (context.invalidatingControlTints()) {
3901         updateScrollCorner();
3902         return;
3903     }
3904 
3905     if (m_scrollCorner) {
3906         if (frame().isMainFrame())
3907             context.fillRect(cornerRect, baseBackgroundColor());
3908         m_scrollCorner-&gt;paintIntoRect(context, cornerRect.location(), cornerRect);
3909         return;
3910     }
3911 
3912 #if PLATFORM(MAC)
3913     // Keep this in sync with ScrollAnimatorMac&#39;s effectiveAppearanceForScrollerImp:.
3914     LocalDefaultSystemAppearance localAppearance(useDarkAppearanceForScrollbars());
3915 #endif
3916 
3917     ScrollView::paintScrollCorner(context, cornerRect);
3918 }
3919 
3920 void FrameView::paintScrollbar(GraphicsContext&amp; context, Scrollbar&amp; bar, const IntRect&amp; rect)
3921 {
3922     if (bar.isCustomScrollbar() &amp;&amp; frame().isMainFrame()) {
3923         IntRect toFill = bar.frameRect();
3924         toFill.intersect(rect);
3925         context.fillRect(toFill, baseBackgroundColor());
3926     }
3927 
3928     ScrollView::paintScrollbar(context, bar, rect);
3929 }
3930 
3931 Color FrameView::documentBackgroundColor() const
3932 {
3933     // &lt;https://bugs.webkit.org/show_bug.cgi?id=59540&gt; We blend the background color of
3934     // the document and the body against the base background color of the frame view.
3935     // Background images are unfortunately impractical to include.
3936 
3937     // Return invalid Color objects whenever there is insufficient information.
3938     if (!frame().document())
3939         return Color();
3940 
3941     auto* htmlElement = frame().document()-&gt;documentElement();
3942     auto* bodyElement = frame().document()-&gt;bodyOrFrameset();
3943 
3944     // Start with invalid colors.
3945     Color htmlBackgroundColor;
3946     Color bodyBackgroundColor;
3947     if (htmlElement &amp;&amp; htmlElement-&gt;renderer())
3948         htmlBackgroundColor = htmlElement-&gt;renderer()-&gt;style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
3949     if (bodyElement &amp;&amp; bodyElement-&gt;renderer())
3950         bodyBackgroundColor = bodyElement-&gt;renderer()-&gt;style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
3951 
3952     if (!bodyBackgroundColor.isValid()) {
3953         if (!htmlBackgroundColor.isValid())
3954             return Color();
3955         return baseBackgroundColor().blend(htmlBackgroundColor);
3956     }
3957 
3958     if (!htmlBackgroundColor.isValid())
3959         return baseBackgroundColor().blend(bodyBackgroundColor);
3960 
3961     // We take the aggregate of the base background color
3962     // the &lt;html&gt; background color, and the &lt;body&gt;
3963     // background color to find the document color. The
3964     // addition of the base background color is not
3965     // technically part of the document background, but it
3966     // otherwise poses problems when the aggregate is not
3967     // fully opaque.
3968     return baseBackgroundColor().blend(htmlBackgroundColor).blend(bodyBackgroundColor);
3969 }
3970 
3971 bool FrameView::hasCustomScrollbars() const
3972 {
3973     for (auto&amp; widget : children()) {
3974         if (is&lt;FrameView&gt;(widget)) {
3975             if (downcast&lt;FrameView&gt;(widget.get()).hasCustomScrollbars())
3976                 return true;
3977         } else if (is&lt;Scrollbar&gt;(widget)) {
3978             if (downcast&lt;Scrollbar&gt;(widget.get()).isCustomScrollbar())
3979                 return true;
3980         }
3981     }
3982     return false;
3983 }
3984 
3985 FrameView* FrameView::parentFrameView() const
3986 {
3987     if (!parent())
3988         return nullptr;
3989     auto* parentFrame = frame().tree().parent();
3990     if (!parentFrame)
3991         return nullptr;
3992     return parentFrame-&gt;view();
3993 }
3994 
3995 bool FrameView::isInChildFrameWithFrameFlattening() const
3996 {
3997     if (!frameFlatteningEnabled())
3998         return false;
3999 
4000     if (!parent())
4001         return false;
4002 
4003     HTMLFrameOwnerElement* ownerElement = frame().ownerElement();
4004     if (!ownerElement)
4005         return false;
4006 
4007     if (!ownerElement-&gt;renderWidget())
4008         return false;
4009 
4010     // Frame flattening applies when the owner element is either in a frameset or
4011     // an iframe with flattening parameters.
4012     if (is&lt;HTMLIFrameElement&gt;(*ownerElement))
4013         return downcast&lt;RenderIFrame&gt;(*ownerElement-&gt;renderWidget()).flattenFrame();
4014 
4015     if (is&lt;HTMLFrameElement&gt;(*ownerElement))
4016         return true;
4017 
4018     return false;
4019 }
4020 
4021 void FrameView::updateControlTints()
4022 {
4023     // This is called when control tints are changed from aqua/graphite to clear and vice versa.
4024     // We do a &quot;fake&quot; paint, and when the theme gets a paint call, it can then do an invalidate.
4025     // This is only done if the theme supports control tinting. It&#39;s up to the theme and platform
4026     // to define when controls get the tint and to call this function when that changes.
4027 
4028     // Optimize the common case where we bring a window to the front while it&#39;s still empty.
4029     if (frame().document()-&gt;url().isEmpty())
4030         return;
4031 
4032     // As noted above, this is a &quot;fake&quot; paint, so we should pause counting relevant repainted objects.
4033     Page* page = frame().page();
4034     bool isCurrentlyCountingRelevantRepaintedObject = false;
4035     if (page) {
4036         isCurrentlyCountingRelevantRepaintedObject = page-&gt;isCountingRelevantRepaintedObjects();
4037         page-&gt;setIsCountingRelevantRepaintedObjects(false);
4038     }
4039 
4040     RenderView* renderView = this-&gt;renderView();
4041     if ((renderView &amp;&amp; renderView-&gt;theme().supportsControlTints()) || hasCustomScrollbars())
4042         invalidateControlTints();
4043 
4044     if (page)
4045         page-&gt;setIsCountingRelevantRepaintedObjects(isCurrentlyCountingRelevantRepaintedObject);
4046 }
4047 
4048 void FrameView::traverseForPaintInvalidation(GraphicsContext::PaintInvalidationReasons paintInvalidationReasons)
4049 {
4050     if (needsLayout())
4051         layoutContext().layout();
4052 
4053     GraphicsContext context(paintInvalidationReasons);
4054     if (platformWidget()) {
4055         // FIXME: consult paintsEntireContents().
4056         paintContents(context, visibleContentRect(LegacyIOSDocumentVisibleRect));
4057     } else
4058         paint(context, frameRect());
4059 }
4060 
4061 bool FrameView::wasScrolledByUser() const
4062 {
4063     return m_wasScrolledByUser;
4064 }
4065 
4066 void FrameView::setWasScrolledByUser(bool wasScrolledByUser)
4067 {
4068     LOG(Scrolling, &quot;FrameView::setWasScrolledByUser at %d&quot;, wasScrolledByUser);
4069 
4070     m_shouldScrollToFocusedElement = false;
4071     m_delayedScrollToFocusedElementTimer.stop();
4072     if (currentScrollType() == ScrollType::Programmatic)
4073         return;
4074     m_maintainScrollPositionAnchor = nullptr;
4075     if (m_wasScrolledByUser == wasScrolledByUser)
4076         return;
4077     m_wasScrolledByUser = wasScrolledByUser;
4078     if (frame().isMainFrame())
4079         updateLayerFlushThrottling();
4080     adjustTiledBackingCoverage();
4081 }
4082 
4083 void FrameView::willPaintContents(GraphicsContext&amp; context, const IntRect&amp;, PaintingState&amp; paintingState)
4084 {
4085     Document* document = frame().document();
4086 
4087     if (!context.paintingDisabled())
4088         InspectorInstrumentation::willPaint(*renderView());
4089 
4090     paintingState.isTopLevelPainter = !sCurrentPaintTimeStamp;
4091 
4092     if (paintingState.isTopLevelPainter)
4093         sCurrentPaintTimeStamp = MonotonicTime::now();
4094 
4095     paintingState.paintBehavior = m_paintBehavior;
4096 
4097     if (FrameView* parentView = parentFrameView()) {
4098         if (parentView-&gt;paintBehavior() &amp; PaintBehavior::FlattenCompositingLayers)
4099             m_paintBehavior.add(PaintBehavior::FlattenCompositingLayers);
4100 
4101         if (parentView-&gt;paintBehavior() &amp; PaintBehavior::Snapshotting)
4102             m_paintBehavior.add(PaintBehavior::Snapshotting);
4103 
4104         if (parentView-&gt;paintBehavior() &amp; PaintBehavior::TileFirstPaint)
4105             m_paintBehavior.add(PaintBehavior::TileFirstPaint);
4106     }
4107 
4108     if (document-&gt;printing()) {
4109         m_paintBehavior.add(PaintBehavior::FlattenCompositingLayers);
4110         m_paintBehavior.add(PaintBehavior::Snapshotting);
4111     }
4112 
4113     paintingState.isFlatteningPaintOfRootFrame = (m_paintBehavior &amp; PaintBehavior::FlattenCompositingLayers) &amp;&amp; !frame().ownerElement();
4114     if (paintingState.isFlatteningPaintOfRootFrame)
4115         notifyWidgetsInAllFrames(WillPaintFlattened);
4116 
4117     ASSERT(!m_isPainting);
4118     m_isPainting = true;
4119 }
4120 
4121 void FrameView::didPaintContents(GraphicsContext&amp; context, const IntRect&amp; dirtyRect, PaintingState&amp; paintingState)
4122 {
4123     m_isPainting = false;
4124 
4125     if (paintingState.isFlatteningPaintOfRootFrame)
4126         notifyWidgetsInAllFrames(DidPaintFlattened);
4127 
4128     m_paintBehavior = paintingState.paintBehavior;
4129     m_lastPaintTime = MonotonicTime::now();
4130 
4131     if (paintingState.isTopLevelPainter)
4132         sCurrentPaintTimeStamp = MonotonicTime();
4133 
4134     if (!context.paintingDisabled()) {
4135         InspectorInstrumentation::didPaint(*renderView(), dirtyRect);
4136         // FIXME: should probably not fire milestones for snapshot painting. https://bugs.webkit.org/show_bug.cgi?id=117623
4137         firePaintRelatedMilestonesIfNeeded();
4138     }
4139 }
4140 
4141 void FrameView::paintContents(GraphicsContext&amp; context, const IntRect&amp; dirtyRect, SecurityOriginPaintPolicy securityOriginPaintPolicy)
4142 {
4143 #ifndef NDEBUG
4144     bool fillWithWarningColor;
4145     if (frame().document()-&gt;printing())
4146         fillWithWarningColor = false; // Printing, don&#39;t fill with red (can&#39;t remember why).
4147     else if (frame().ownerElement())
4148         fillWithWarningColor = false; // Subframe, don&#39;t fill with red.
4149     else if (isTransparent())
4150         fillWithWarningColor = false; // Transparent, don&#39;t fill with red.
4151     else if (m_paintBehavior &amp; PaintBehavior::SelectionOnly)
4152         fillWithWarningColor = false; // Selections are transparent, don&#39;t fill with red.
4153     else if (m_nodeToDraw)
4154         fillWithWarningColor = false; // Element images are transparent, don&#39;t fill with red.
4155     else
4156         fillWithWarningColor = true;
4157 
<a name="38" id="anc38"></a><span class="line-modified">4158     if (fillWithWarningColor) {</span>
<span class="line-modified">4159         IntRect debugRect = frameRect();</span>
<span class="line-added">4160         debugRect.intersect(dirtyRect);</span>
<span class="line-added">4161         context.fillRect(debugRect, Color(255, 64, 255));</span>
<span class="line-added">4162     }</span>
4163 #endif
4164 
4165     RenderView* renderView = this-&gt;renderView();
4166     if (!renderView) {
4167         LOG_ERROR(&quot;called FrameView::paint with nil renderer&quot;);
4168         return;
4169     }
4170 
<a name="39" id="anc39"></a><span class="line-added">4171 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">4172     if (RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextEnabled()) {</span>
<span class="line-added">4173         if (auto* layoutState = layoutContext().layoutFormattingState())</span>
<span class="line-added">4174             Layout::LayoutContext::paint(*layoutState, context, dirtyRect);</span>
<span class="line-added">4175         return;</span>
<span class="line-added">4176     }</span>
<span class="line-added">4177 #endif</span>
<span class="line-added">4178 </span>
4179     if (!layoutContext().inPaintableState())
4180         return;
4181 
4182     ASSERT(!needsLayout());
4183     if (needsLayout()) {
<a name="40" id="anc40"></a><span class="line-modified">4184         FRAMEVIEW_RELEASE_LOG_IF_ALLOWED(Layout, &quot;paintContents: Not painting because render tree needs layout&quot;);</span>
4185         return;
4186     }
4187 
4188     PaintingState paintingState;
4189     willPaintContents(context, dirtyRect, paintingState);
4190 
4191     // m_nodeToDraw is used to draw only one element (and its descendants)
4192     RenderObject* renderer = m_nodeToDraw ? m_nodeToDraw-&gt;renderer() : nullptr;
4193     RenderLayer* rootLayer = renderView-&gt;layer();
4194 
4195 #ifndef NDEBUG
4196     RenderElement::SetLayoutNeededForbiddenScope forbidSetNeedsLayout(&amp;rootLayer-&gt;renderer());
4197 #endif
4198 
4199     // To work around http://webkit.org/b/135106, ensure that the paint root isn&#39;t an inline with culled line boxes.
4200     // FIXME: This can cause additional content to be included in the snapshot, so remove this once that bug is fixed.
4201     while (is&lt;RenderInline&gt;(renderer) &amp;&amp; !downcast&lt;RenderInline&gt;(*renderer).firstLineBox())
4202         renderer = renderer-&gt;parent();
4203 
4204     rootLayer-&gt;paint(context, dirtyRect, LayoutSize(), m_paintBehavior, renderer, { }, securityOriginPaintPolicy == SecurityOriginPaintPolicy::AnyOrigin ? RenderLayer::SecurityOriginPaintPolicy::AnyOrigin : RenderLayer::SecurityOriginPaintPolicy::AccessibleOriginOnly);
4205     if (rootLayer-&gt;containsDirtyOverlayScrollbars())
4206         rootLayer-&gt;paintOverlayScrollbars(context, dirtyRect, m_paintBehavior, renderer);
4207 
4208     didPaintContents(context, dirtyRect, paintingState);
4209 }
4210 
4211 void FrameView::setPaintBehavior(OptionSet&lt;PaintBehavior&gt; behavior)
4212 {
4213     m_paintBehavior = behavior;
4214 }
4215 
4216 OptionSet&lt;PaintBehavior&gt; FrameView::paintBehavior() const
4217 {
4218     return m_paintBehavior;
4219 }
4220 
4221 bool FrameView::isPainting() const
4222 {
4223     return m_isPainting;
4224 }
4225 
4226 // FIXME: change this to use the subtreePaint terminology.
4227 void FrameView::setNodeToDraw(Node* node)
4228 {
4229     m_nodeToDraw = node;
4230 }
4231 
4232 void FrameView::paintContentsForSnapshot(GraphicsContext&amp; context, const IntRect&amp; imageRect, SelectionInSnapshot shouldPaintSelection, CoordinateSpaceForSnapshot coordinateSpace)
4233 {
4234     updateLayoutAndStyleIfNeededRecursive();
4235 
4236     // Cache paint behavior and set a new behavior appropriate for snapshots.
4237     auto oldBehavior = paintBehavior();
4238     setPaintBehavior(oldBehavior | PaintBehavior::FlattenCompositingLayers | PaintBehavior::Snapshotting);
4239 
4240     // If the snapshot should exclude selection, then we&#39;ll clear the current selection
4241     // in the render tree only. This will allow us to restore the selection from the DOM
4242     // after we paint the snapshot.
4243     if (shouldPaintSelection == ExcludeSelection) {
4244         for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr())) {
4245             if (auto* renderView = frame-&gt;contentRenderer())
4246                 renderView-&gt;selection().clear();
4247         }
4248     }
4249 
4250     if (coordinateSpace == DocumentCoordinates)
4251         paintContents(context, imageRect);
4252     else {
4253         // A snapshot in ViewCoordinates will include a scrollbar, and the snapshot will contain
4254         // whatever content the document is currently scrolled to.
4255         paint(context, imageRect);
4256     }
4257 
4258     // Restore selection.
4259     if (shouldPaintSelection == ExcludeSelection) {
4260         for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr()))
4261             frame-&gt;selection().updateAppearance();
4262     }
4263 
4264     // Restore cached paint behavior.
4265     setPaintBehavior(oldBehavior);
4266 }
4267 
4268 void FrameView::paintOverhangAreas(GraphicsContext&amp; context, const IntRect&amp; horizontalOverhangArea, const IntRect&amp; verticalOverhangArea, const IntRect&amp; dirtyRect)
4269 {
4270     if (context.paintingDisabled())
4271         return;
4272 
4273     if (frame().document()-&gt;printing())
4274         return;
4275 
4276     ScrollView::paintOverhangAreas(context, horizontalOverhangArea, verticalOverhangArea, dirtyRect);
4277 }
4278 
4279 void FrameView::updateLayoutAndStyleIfNeededRecursive()
4280 {
4281     // Style updating, render tree creation, and layout needs to be done multiple times
4282     // for more than one reason. But one reason is that when an &lt;object&gt; element determines
4283     // what it needs to load a subframe, a second pass is needed. That requires update
4284     // passes equal to the number of levels of DOM nesting. That is why this number is large.
4285     // There are test cases where we have roughly 10 levels of DOM nesting, so this needs to
4286     // be greater than that. We have a limit to avoid the possibility of an infinite loop.
4287     // Typical calls will run the loop 2 times (once to do work, once to detect no further work
4288     // is needed).
4289     // FIXME: We should find an approach that does not require a loop at all.
4290     const unsigned maxUpdatePasses = 25;
4291 
4292     // Style updates can trigger script, which can cause this FrameView to be destroyed.
4293     Ref&lt;FrameView&gt; protectedThis(*this);
4294 
4295     AnimationUpdateBlock animationUpdateBlock(&amp;frame().animation());
4296 
4297     using DescendantsDeque = Deque&lt;Ref&lt;FrameView&gt;, 16&gt;;
4298     auto nextRenderedDescendant = [this] (DescendantsDeque&amp; descendantsDeque) -&gt; RefPtr&lt;FrameView&gt; {
4299         if (descendantsDeque.isEmpty())
4300             descendantsDeque.append(*this);
4301         else {
4302             // Append renderered children after processing the parent, in case the processing
4303             // affects the set of rendered children.
4304             auto previousView = descendantsDeque.takeFirst();
4305             for (auto* frame = previousView-&gt;frame().tree().firstRenderedChild(); frame; frame = frame-&gt;tree().nextRenderedSibling()) {
4306                 if (auto* view = frame-&gt;view())
4307                     descendantsDeque.append(*view);
4308             }
4309             if (descendantsDeque.isEmpty())
4310                 return nullptr;
4311         }
4312         return descendantsDeque.first().ptr();
4313     };
4314 
4315     for (unsigned i = 0; i &lt; maxUpdatePasses; ++i) {
4316         bool didWork = false;
4317         DescendantsDeque deque;
4318         while (auto view = nextRenderedDescendant(deque)) {
4319             if (view-&gt;frame().document()-&gt;updateStyleIfNeeded())
4320                 didWork = true;
4321             if (view-&gt;needsLayout()) {
4322                 view-&gt;layoutContext().layout();
4323                 didWork = true;
4324             }
4325         }
4326         if (!didWork)
4327             break;
4328     }
4329 
<a name="41" id="anc41"></a><span class="line-modified">4330 #if ASSERT_ENABLED</span>
4331     auto needsStyleRecalc = [&amp;] {
4332         DescendantsDeque deque;
4333         while (auto view = nextRenderedDescendant(deque)) {
4334             auto* document = view-&gt;frame().document();
4335             if (document &amp;&amp; document-&gt;childNeedsStyleRecalc())
4336                 return true;
4337         }
4338         return false;
4339     };
4340 
4341     auto needsLayout = [&amp;] {
4342         DescendantsDeque deque;
4343         while (auto view = nextRenderedDescendant(deque)) {
4344             if (view-&gt;needsLayout())
4345                 return true;
4346         }
4347         return false;
4348     };
<a name="42" id="anc42"></a><span class="line-modified">4349 #endif // ASSERT_ENABLED</span>
4350 
4351     ASSERT(!needsStyleRecalc());
4352     ASSERT(!needsLayout());
4353 }
4354 
4355 void FrameView::incrementVisuallyNonEmptyCharacterCount(const String&amp; inlineText)
4356 {
4357     if (m_visuallyNonEmptyCharacterCount &gt; visualCharacterThreshold &amp;&amp; m_hasReachedSignificantRenderedTextThreshold)
4358         return;
4359 
4360     auto nonWhitespaceLength = [](auto&amp; inlineText) {
4361         auto length = inlineText.length();
4362         for (unsigned i = 0; i &lt; inlineText.length(); ++i) {
4363             if (isNotHTMLSpace(inlineText[i]))
4364                 continue;
4365             --length;
4366         }
4367         return length;
4368     };
4369     m_visuallyNonEmptyCharacterCount += nonWhitespaceLength(inlineText);
4370     ++m_textRendererCountForVisuallyNonEmptyCharacters;
4371 }
4372 
4373 static bool elementOverflowRectIsLargerThanThreshold(const Element&amp; element)
4374 {
4375     // Require the document to grow a bit.
4376     // Using a value of 48 allows the header on Google&#39;s search page to render immediately before search results populate later.
4377     static const int documentHeightThreshold = 48;
4378     if (auto* elementRenderBox = element.renderBox())
4379         return snappedIntRect(elementRenderBox-&gt;layoutOverflowRect()).height() &gt;= documentHeightThreshold;
4380 
4381     return false;
4382 }
4383 
4384 void FrameView::updateHasReachedSignificantRenderedTextThreshold()
4385 {
4386     if (m_hasReachedSignificantRenderedTextThreshold)
4387         return;
4388 
4389     auto* page = frame().page();
4390     if (!page || !page-&gt;requestedLayoutMilestones().contains(DidRenderSignificantAmountOfText))
4391         return;
4392 
4393     auto* document = frame().document();
4394     if (!document)
4395         return;
4396 
4397     document-&gt;updateMainArticleElementAfterLayout();
4398     auto hasMainArticleElement = document-&gt;hasMainArticleElement();
4399     auto characterThreshold = hasMainArticleElement ? mainArticleSignificantRenderedTextCharacterThreshold : defaultSignificantRenderedTextCharacterThreshold;
4400     if (m_visuallyNonEmptyCharacterCount &lt; characterThreshold)
4401         return;
4402 
4403     auto meanLength = hasMainArticleElement ? mainArticleSignificantRenderedTextMeanLength : defaultSignificantRenderedTextMeanLength;
4404     if (!m_textRendererCountForVisuallyNonEmptyCharacters || m_visuallyNonEmptyCharacterCount / static_cast&lt;float&gt;(m_textRendererCountForVisuallyNonEmptyCharacters) &lt; meanLength)
4405         return;
4406 
4407     m_hasReachedSignificantRenderedTextThreshold = true;
4408 }
4409 
4410 bool FrameView::qualifiesAsSignificantRenderedText() const
4411 {
4412     ASSERT(!m_renderedSignificantAmountOfText);
4413     auto* document = frame().document();
4414     if (!document || document-&gt;styleScope().hasPendingSheetsBeforeBody())
4415         return false;
4416 
4417     auto* documentElement = document-&gt;documentElement();
4418     if (!documentElement || !elementOverflowRectIsLargerThanThreshold(*documentElement))
4419         return false;
4420 
4421     return m_hasReachedSignificantRenderedTextThreshold;
4422 }
4423 
4424 bool FrameView::qualifiesAsVisuallyNonEmpty() const
4425 {
4426     // No content yet.
4427     Element* documentElement = frame().document()-&gt;documentElement();
4428     if (!documentElement || !documentElement-&gt;renderer())
4429         return false;
4430 
4431     // FIXME: We should also ignore renderers with non-final style.
4432     if (frame().document()-&gt;styleScope().hasPendingSheetsBeforeBody())
4433         return false;
4434 
4435     auto finishedParsingMainDocument = frame().loader().stateMachine().committedFirstRealDocumentLoad() &amp;&amp; (frame().document()-&gt;readyState() == Document::Interactive || frame().document()-&gt;readyState() == Document::Complete);
4436     // Ensure that we always fire visually non-empty milestone eventually.
4437     if (finishedParsingMainDocument &amp;&amp; frame().loader().isComplete())
4438         return true;
4439 
4440     auto isVisible = [](const Element* element) {
4441         if (!element || !element-&gt;renderer())
4442             return false;
4443         if (!element-&gt;renderer()-&gt;opacity())
4444             return false;
4445         return element-&gt;renderer()-&gt;style().visibility() == Visibility::Visible;
4446     };
4447 
4448     if (!isVisible(documentElement))
4449         return false;
4450 
4451     if (!isVisible(frame().document()-&gt;body()))
4452         return false;
4453 
4454     if (!elementOverflowRectIsLargerThanThreshold(*documentElement))
4455         return false;
4456 
4457     // The first few hundred characters rarely contain the interesting content of the page.
4458     if (m_visuallyNonEmptyCharacterCount &gt; visualCharacterThreshold)
4459         return true;
4460 
4461     // Use a threshold value to prevent very small amounts of visible content from triggering didFirstVisuallyNonEmptyLayout
4462     if (m_visuallyNonEmptyPixelCount &gt; visualPixelThreshold)
4463         return true;
4464 
4465     auto isMoreContentExpected = [&amp;]() {
4466         ASSERT(finishedParsingMainDocument);
4467         // Pending css/font loading means we should wait a little longer. Classic non-async, non-defer scripts are all processed by now.
4468         auto* documentLoader = frame().loader().documentLoader();
4469         if (!documentLoader)
4470             return false;
4471 
4472         auto&amp; resourceLoader = documentLoader-&gt;cachedResourceLoader();
4473         if (!resourceLoader.requestCount())
4474             return false;
4475 
4476         auto&amp; resources = resourceLoader.allCachedResources();
4477         for (auto&amp; resource : resources) {
4478             if (resource.value-&gt;isLoaded())
4479                 continue;
4480             if (resource.value-&gt;type() == CachedResource::Type::CSSStyleSheet || resource.value-&gt;type() == CachedResource::Type::FontResource)
4481                 return true;
4482         }
4483         return false;
4484     };
4485 
4486     // Finished parsing the main document and we still don&#39;t yet have enough content. Check if we might be getting some more.
4487     if (finishedParsingMainDocument)
4488         return !isMoreContentExpected();
4489 
4490     return false;
4491 }
4492 
4493 bool FrameView::isViewForDocumentInFrame() const
4494 {
4495     RenderView* renderView = this-&gt;renderView();
4496     if (!renderView)
4497         return false;
4498 
4499     return &amp;renderView-&gt;frameView() == this;
4500 }
4501 
4502 void FrameView::enableAutoSizeMode(bool enable, const IntSize&amp; viewSize)
4503 {
4504     ASSERT(!enable || !viewSize.isEmpty());
4505     if (m_shouldAutoSize == enable &amp;&amp; m_autoSizeConstraint == viewSize)
4506         return;
4507 
4508     m_shouldAutoSize = enable;
4509     m_autoSizeConstraint = viewSize;
4510     m_autoSizeContentSize = contentsSize();
4511     m_didRunAutosize = false;
4512 
4513     setNeedsLayoutAfterViewConfigurationChange();
4514     layoutContext().scheduleLayout();
4515     if (m_shouldAutoSize) {
4516         overrideViewportSizeForCSSViewportUnits({ m_autoSizeConstraint.width(), m_overrideViewportSize ? m_overrideViewportSize-&gt;height : WTF::nullopt });
4517         return;
4518     }
4519 
4520     clearViewportSizeOverrideForCSSViewportUnits();
4521     // Since autosize mode forces the scrollbar mode, change them to being auto.
4522     setVerticalScrollbarLock(false);
4523     setHorizontalScrollbarLock(false);
4524     setScrollbarModes(ScrollbarAuto, ScrollbarAuto);
4525 }
4526 
4527 void FrameView::forceLayout(bool allowSubtreeLayout)
4528 {
4529     if (!allowSubtreeLayout &amp;&amp; layoutContext().subtreeLayoutRoot())
4530         layoutContext().convertSubtreeLayoutToFullLayout();
4531     layoutContext().layout();
4532 }
4533 
4534 void FrameView::forceLayoutForPagination(const FloatSize&amp; pageSize, const FloatSize&amp; originalPageSize, float maximumShrinkFactor, AdjustViewSizeOrNot shouldAdjustViewSize)
4535 {
4536     if (!renderView())
4537         return;
4538 
4539     Ref&lt;FrameView&gt; protectedThis(*this);
4540     auto&amp; renderView = *this-&gt;renderView();
4541 
4542     // Dumping externalRepresentation(frame().renderer()).ascii() is a good trick to see
4543     // the state of things before and after the layout
4544     float pageLogicalWidth = renderView.style().isHorizontalWritingMode() ? pageSize.width() : pageSize.height();
4545     float pageLogicalHeight = renderView.style().isHorizontalWritingMode() ? pageSize.height() : pageSize.width();
4546 
4547     renderView.setPageLogicalSize({ floor(pageLogicalWidth), floor(pageLogicalHeight) });
4548     renderView.setNeedsLayoutAndPrefWidthsRecalc();
4549     forceLayout();
4550     if (hasOneRef())
4551         return;
4552 
4553     // If we don&#39;t fit in the given page width, we&#39;ll lay out again. If we don&#39;t fit in the
4554     // page width when shrunk, we will lay out at maximum shrink and clip extra content.
4555     // FIXME: We are assuming a shrink-to-fit printing implementation. A cropping
4556     // implementation should not do this!
4557     bool horizontalWritingMode = renderView.style().isHorizontalWritingMode();
4558     const LayoutRect&amp; documentRect = renderView.documentRect();
4559     LayoutUnit docLogicalWidth = horizontalWritingMode ? documentRect.width() : documentRect.height();
4560     if (docLogicalWidth &gt; pageLogicalWidth) {
4561         int expectedPageWidth = std::min&lt;float&gt;(documentRect.width(), pageSize.width() * maximumShrinkFactor);
4562         int expectedPageHeight = std::min&lt;float&gt;(documentRect.height(), pageSize.height() * maximumShrinkFactor);
4563         FloatSize maxPageSize = frame().resizePageRectsKeepingRatio(FloatSize(originalPageSize.width(), originalPageSize.height()), FloatSize(expectedPageWidth, expectedPageHeight));
4564         pageLogicalWidth = horizontalWritingMode ? maxPageSize.width() : maxPageSize.height();
4565         pageLogicalHeight = horizontalWritingMode ? maxPageSize.height() : maxPageSize.width();
4566 
4567         renderView.setPageLogicalSize({ floor(pageLogicalWidth), floor(pageLogicalHeight) });
4568         renderView.setNeedsLayoutAndPrefWidthsRecalc();
4569         forceLayout();
4570         if (hasOneRef())
4571             return;
4572 
4573         const LayoutRect&amp; updatedDocumentRect = renderView.documentRect();
4574         LayoutUnit docLogicalHeight = horizontalWritingMode ? updatedDocumentRect.height() : updatedDocumentRect.width();
4575         LayoutUnit docLogicalTop = horizontalWritingMode ? updatedDocumentRect.y() : updatedDocumentRect.x();
4576         LayoutUnit docLogicalRight = horizontalWritingMode ? updatedDocumentRect.maxX() : updatedDocumentRect.maxY();
4577         LayoutUnit clippedLogicalLeft;
4578         if (!renderView.style().isLeftToRightDirection())
4579             clippedLogicalLeft = docLogicalRight - pageLogicalWidth;
4580         LayoutRect overflow { clippedLogicalLeft, docLogicalTop, LayoutUnit(pageLogicalWidth), docLogicalHeight };
4581 
4582         if (!horizontalWritingMode)
4583             overflow = overflow.transposedRect();
4584         renderView.clearLayoutOverflow();
4585         renderView.addLayoutOverflow(overflow); // This is how we clip in case we overflow again.
4586     }
4587 
4588     if (shouldAdjustViewSize)
4589         adjustViewSize();
4590 }
4591 
4592 void FrameView::adjustPageHeightDeprecated(float *newBottom, float oldTop, float oldBottom, float /*bottomLimit*/)
4593 {
4594     RenderView* renderView = this-&gt;renderView();
4595     if (!renderView) {
4596         *newBottom = oldBottom;
4597         return;
4598 
4599     }
4600     // Use a context with painting disabled.
4601     GraphicsContext context(GraphicsContext::PaintInvalidationReasons::None);
4602     renderView-&gt;setTruncatedAt(static_cast&lt;int&gt;(floorf(oldBottom)));
4603     IntRect dirtyRect(0, static_cast&lt;int&gt;(floorf(oldTop)), renderView-&gt;layoutOverflowRect().maxX(), static_cast&lt;int&gt;(ceilf(oldBottom - oldTop)));
4604     renderView-&gt;setPrintRect(dirtyRect);
4605     renderView-&gt;layer()-&gt;paint(context, dirtyRect);
4606     *newBottom = renderView-&gt;bestTruncatedAt();
4607     if (!*newBottom)
4608         *newBottom = oldBottom;
4609     renderView-&gt;setPrintRect(IntRect());
4610 }
4611 
4612 IntRect FrameView::convertFromRendererToContainingView(const RenderElement* renderer, const IntRect&amp; rendererRect) const
4613 {
4614     IntRect rect = snappedIntRect(enclosingLayoutRect(renderer-&gt;localToAbsoluteQuad(FloatRect(rendererRect)).boundingBox()));
4615 
4616     return contentsToView(rect);
4617 }
4618 
4619 IntRect FrameView::convertFromContainingViewToRenderer(const RenderElement* renderer, const IntRect&amp; viewRect) const
4620 {
4621     IntRect rect = viewToContents(viewRect);
4622 
4623     // FIXME: we don&#39;t have a way to map an absolute rect down to a local quad, so just
4624     // move the rect for now.
4625     rect.setLocation(roundedIntPoint(renderer-&gt;absoluteToLocal(rect.location(), UseTransforms)));
4626     return rect;
4627 }
4628 
4629 FloatRect FrameView::convertFromContainingViewToRenderer(const RenderElement* renderer, const FloatRect&amp; viewRect) const
4630 {
4631     FloatRect rect = viewToContents(viewRect);
4632 
4633     return (renderer-&gt;absoluteToLocalQuad(rect)).boundingBox();
4634 }
4635 
4636 IntPoint FrameView::convertFromRendererToContainingView(const RenderElement* renderer, const IntPoint&amp; rendererPoint) const
4637 {
4638     IntPoint point = roundedIntPoint(renderer-&gt;localToAbsolute(rendererPoint, UseTransforms));
4639 
4640     return contentsToView(point);
4641 }
4642 
4643 IntPoint FrameView::convertFromContainingViewToRenderer(const RenderElement* renderer, const IntPoint&amp; viewPoint) const
4644 {
4645     IntPoint point = viewPoint;
4646 
4647     // Convert from FrameView coords into page (&quot;absolute&quot;) coordinates.
4648     if (!delegatesScrolling())
4649         point = viewToContents(point);
4650 
4651     return roundedIntPoint(renderer-&gt;absoluteToLocal(point, UseTransforms));
4652 }
4653 
4654 IntRect FrameView::convertToContainingView(const IntRect&amp; localRect) const
4655 {
4656     if (const ScrollView* parentScrollView = parent()) {
4657         if (is&lt;FrameView&gt;(*parentScrollView)) {
4658             const FrameView&amp; parentView = downcast&lt;FrameView&gt;(*parentScrollView);
4659             // Get our renderer in the parent view
4660             RenderWidget* renderer = frame().ownerRenderer();
4661             if (!renderer)
4662                 return localRect;
4663 
4664             auto rect = localRect;
4665             rect.moveBy(roundedIntPoint(renderer-&gt;contentBoxLocation()));
4666             return parentView.convertFromRendererToContainingView(renderer, rect);
4667         }
4668 
4669         return Widget::convertToContainingView(localRect);
4670     }
4671 
4672     return localRect;
4673 }
4674 
4675 IntRect FrameView::convertFromContainingView(const IntRect&amp; parentRect) const
4676 {
4677     if (const ScrollView* parentScrollView = parent()) {
4678         if (is&lt;FrameView&gt;(*parentScrollView)) {
4679             const FrameView&amp; parentView = downcast&lt;FrameView&gt;(*parentScrollView);
4680 
4681             // Get our renderer in the parent view
4682             RenderWidget* renderer = frame().ownerRenderer();
4683             if (!renderer)
4684                 return parentRect;
4685 
4686             auto rect = parentView.convertFromContainingViewToRenderer(renderer, parentRect);
4687             rect.moveBy(-roundedIntPoint(renderer-&gt;contentBoxLocation()));
4688             return rect;
4689         }
4690 
4691         return Widget::convertFromContainingView(parentRect);
4692     }
4693 
4694     return parentRect;
4695 }
4696 
4697 FloatRect FrameView::convertFromContainingView(const FloatRect&amp; parentRect) const
4698 {
4699     if (const ScrollView* parentScrollView = parent()) {
4700         if (is&lt;FrameView&gt;(*parentScrollView)) {
4701             const FrameView&amp; parentView = downcast&lt;FrameView&gt;(*parentScrollView);
4702 
4703             // Get our renderer in the parent view
4704             RenderWidget* renderer = frame().ownerRenderer();
4705             if (!renderer)
4706                 return parentRect;
4707 
4708             auto rect = parentView.convertFromContainingViewToRenderer(renderer, parentRect);
4709             rect.moveBy(-renderer-&gt;contentBoxLocation());
4710             return rect;
4711         }
4712 
4713         return Widget::convertFromContainingView(parentRect);
4714     }
4715 
4716     return parentRect;
4717 }
4718 
4719 IntPoint FrameView::convertToContainingView(const IntPoint&amp; localPoint) const
4720 {
4721     if (const ScrollView* parentScrollView = parent()) {
4722         if (is&lt;FrameView&gt;(*parentScrollView)) {
4723             const FrameView&amp; parentView = downcast&lt;FrameView&gt;(*parentScrollView);
4724 
4725             // Get our renderer in the parent view
4726             RenderWidget* renderer = frame().ownerRenderer();
4727             if (!renderer)
4728                 return localPoint;
4729 
4730             auto point = localPoint;
4731             point.moveBy(roundedIntPoint(renderer-&gt;contentBoxLocation()));
4732             return parentView.convertFromRendererToContainingView(renderer, point);
4733         }
4734 
4735         return Widget::convertToContainingView(localPoint);
4736     }
4737 
4738     return localPoint;
4739 }
4740 
4741 IntPoint FrameView::convertFromContainingView(const IntPoint&amp; parentPoint) const
4742 {
4743     if (const ScrollView* parentScrollView = parent()) {
4744         if (is&lt;FrameView&gt;(*parentScrollView)) {
4745             const FrameView&amp; parentView = downcast&lt;FrameView&gt;(*parentScrollView);
4746 
4747             // Get our renderer in the parent view
4748             RenderWidget* renderer = frame().ownerRenderer();
4749             if (!renderer)
4750                 return parentPoint;
4751 
4752             auto point = parentView.convertFromContainingViewToRenderer(renderer, parentPoint);
4753             point.moveBy(-roundedIntPoint(renderer-&gt;contentBoxLocation()));
4754             return point;
4755         }
4756 
4757         return Widget::convertFromContainingView(parentPoint);
4758     }
4759 
4760     return parentPoint;
4761 }
4762 
4763 float FrameView::documentToAbsoluteScaleFactor(Optional&lt;float&gt; effectiveZoom) const
4764 {
4765     // If effectiveZoom is passed, it already factors in pageZoomFactor().
4766     return effectiveZoom.valueOr(frame().pageZoomFactor()) * frame().frameScaleFactor();
4767 }
4768 
4769 float FrameView::absoluteToDocumentScaleFactor(Optional&lt;float&gt; effectiveZoom) const
4770 {
4771     // If effectiveZoom is passed, it already factors in pageZoomFactor().
4772     return 1 / documentToAbsoluteScaleFactor(effectiveZoom);
4773 }
4774 
4775 FloatRect FrameView::absoluteToDocumentRect(FloatRect rect, Optional&lt;float&gt; effectiveZoom) const
4776 {
4777     rect.scale(absoluteToDocumentScaleFactor(effectiveZoom));
4778     return rect;
4779 }
4780 
4781 FloatPoint FrameView::absoluteToDocumentPoint(FloatPoint p, Optional&lt;float&gt; effectiveZoom) const
4782 {
4783     return p.scaled(absoluteToDocumentScaleFactor(effectiveZoom));
4784 }
4785 
4786 FloatRect FrameView::absoluteToClientRect(FloatRect rect, Optional&lt;float&gt; effectiveZoom) const
4787 {
4788     return documentToClientRect(absoluteToDocumentRect(rect, effectiveZoom));
4789 }
4790 
4791 FloatSize FrameView::documentToClientOffset() const
4792 {
4793     FloatSize clientOrigin = -toFloatSize(visibleContentRect().location());
4794 
4795     // Layout and visual viewports are affected by page zoom, so we need to factor that out.
4796     return clientOrigin.scaled(1 / (frame().pageZoomFactor() * frame().frameScaleFactor()));
4797 }
4798 
4799 FloatRect FrameView::documentToClientRect(FloatRect rect) const
4800 {
4801     rect.move(documentToClientOffset());
4802     return rect;
4803 }
4804 
4805 FloatPoint FrameView::documentToClientPoint(FloatPoint p) const
4806 {
4807     p.move(documentToClientOffset());
4808     return p;
4809 }
4810 
4811 FloatRect FrameView::clientToDocumentRect(FloatRect rect) const
4812 {
4813     rect.move(-documentToClientOffset());
4814     return rect;
4815 }
4816 
4817 FloatPoint FrameView::clientToDocumentPoint(FloatPoint point) const
4818 {
4819     point.move(-documentToClientOffset());
4820     return point;
4821 }
4822 
4823 FloatPoint FrameView::absoluteToLayoutViewportPoint(FloatPoint p) const
4824 {
4825     ASSERT(frame().settings().visualViewportEnabled());
4826     p.scale(1 / frame().frameScaleFactor());
4827     p.moveBy(-layoutViewportRect().location());
4828     return p;
4829 }
4830 
4831 FloatPoint FrameView::layoutViewportToAbsolutePoint(FloatPoint p) const
4832 {
4833     ASSERT(frame().settings().visualViewportEnabled());
4834     p.moveBy(layoutViewportRect().location());
4835     return p.scaled(frame().frameScaleFactor());
4836 }
4837 
4838 FloatRect FrameView::layoutViewportToAbsoluteRect(FloatRect rect) const
4839 {
4840     ASSERT(frame().settings().visualViewportEnabled());
4841     rect.moveBy(layoutViewportRect().location());
4842     rect.scale(frame().frameScaleFactor());
4843     return rect;
4844 }
4845 
4846 FloatRect FrameView::absoluteToLayoutViewportRect(FloatRect rect) const
4847 {
4848     ASSERT(frame().settings().visualViewportEnabled());
4849     rect.scale(1 / frame().frameScaleFactor());
4850     rect.moveBy(-layoutViewportRect().location());
4851     return rect;
4852 }
4853 
4854 FloatRect FrameView::clientToLayoutViewportRect(FloatRect rect) const
4855 {
4856     ASSERT(frame().settings().visualViewportEnabled());
4857     rect.scale(frame().pageZoomFactor());
4858     return rect;
4859 }
4860 
4861 FloatPoint FrameView::clientToLayoutViewportPoint(FloatPoint p) const
4862 {
4863     ASSERT(frame().settings().visualViewportEnabled());
4864     return p.scaled(frame().pageZoomFactor());
4865 }
4866 
4867 void FrameView::setTracksRepaints(bool trackRepaints)
4868 {
4869     if (trackRepaints == m_isTrackingRepaints)
4870         return;
4871 
4872     // Force layout to flush out any pending repaints.
4873     if (trackRepaints) {
4874         if (frame().document())
4875             frame().document()-&gt;updateLayout();
4876     }
4877 
4878     for (Frame* frame = &amp;m_frame-&gt;tree().top(); frame; frame = frame-&gt;tree().traverseNext()) {
4879         if (RenderView* renderView = frame-&gt;contentRenderer())
4880             renderView-&gt;compositor().setTracksRepaints(trackRepaints);
4881     }
4882 
4883     resetTrackedRepaints();
4884     m_isTrackingRepaints = trackRepaints;
4885 }
4886 
4887 void FrameView::resetTrackedRepaints()
4888 {
4889     m_trackedRepaintRects.clear();
4890     if (RenderView* renderView = this-&gt;renderView())
4891         renderView-&gt;compositor().resetTrackedRepaintRects();
4892 }
4893 
4894 String FrameView::trackedRepaintRectsAsText() const
4895 {
4896     Frame&amp; frame = this-&gt;frame();
4897     Ref&lt;Frame&gt; protector(frame);
4898 
4899     if (auto* document = frame.document())
4900         document-&gt;updateLayout();
4901 
4902     TextStream ts;
4903     if (!m_trackedRepaintRects.isEmpty()) {
4904         ts &lt;&lt; &quot;(repaint rects\n&quot;;
4905         for (auto&amp; rect : m_trackedRepaintRects)
4906             ts &lt;&lt; &quot;  (rect &quot; &lt;&lt; LayoutUnit(rect.x()) &lt;&lt; &quot; &quot; &lt;&lt; LayoutUnit(rect.y()) &lt;&lt; &quot; &quot; &lt;&lt; LayoutUnit(rect.width()) &lt;&lt; &quot; &quot; &lt;&lt; LayoutUnit(rect.height()) &lt;&lt; &quot;)\n&quot;;
4907         ts &lt;&lt; &quot;)\n&quot;;
4908     }
4909     return ts.release();
4910 }
4911 
4912 bool FrameView::addScrollableArea(ScrollableArea* scrollableArea)
4913 {
4914     if (!m_scrollableAreas)
4915         m_scrollableAreas = makeUnique&lt;ScrollableAreaSet&gt;();
4916 
4917     if (m_scrollableAreas-&gt;add(scrollableArea).isNewEntry) {
4918         scrollableAreaSetChanged();
4919         return true;
4920     }
4921 
4922     return false;
4923 }
4924 
4925 bool FrameView::removeScrollableArea(ScrollableArea* scrollableArea)
4926 {
4927     if (m_scrollableAreas &amp;&amp; m_scrollableAreas-&gt;remove(scrollableArea)) {
4928         scrollableAreaSetChanged();
4929         return true;
4930     }
4931     return false;
4932 }
4933 
4934 bool FrameView::containsScrollableArea(ScrollableArea* scrollableArea) const
4935 {
4936     return m_scrollableAreas &amp;&amp; m_scrollableAreas-&gt;contains(scrollableArea);
4937 }
4938 
4939 void FrameView::scrollableAreaSetChanged()
4940 {
4941     if (auto* page = frame().page()) {
4942         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
4943             scrollingCoordinator-&gt;frameViewEventTrackingRegionsChanged(*this);
4944     }
4945 }
4946 
4947 void FrameView::sendScrollEvent()
4948 {
4949     frame().eventHandler().sendScrollEvent();
4950     frame().eventHandler().dispatchFakeMouseMoveEventSoon();
4951 }
4952 
4953 void FrameView::addChild(Widget&amp; widget)
4954 {
4955     if (is&lt;FrameView&gt;(widget)) {
4956         auto&amp; childFrameView = downcast&lt;FrameView&gt;(widget);
4957         if (childFrameView.isScrollable())
4958             addScrollableArea(&amp;childFrameView);
4959     }
4960 
4961     ScrollView::addChild(widget);
4962 }
4963 
4964 void FrameView::removeChild(Widget&amp; widget)
4965 {
4966     if (is&lt;FrameView&gt;(widget))
4967         removeScrollableArea(&amp;downcast&lt;FrameView&gt;(widget));
4968 
4969     ScrollView::removeChild(widget);
4970 }
4971 
4972 bool FrameView::wheelEvent(const PlatformWheelEvent&amp; wheelEvent)
4973 {
4974     // Note that to allow for rubber-band over-scroll behavior, even non-scrollable views
4975     // should handle wheel events.
4976 #if !ENABLE(RUBBER_BANDING)
4977     if (!isScrollable())
4978         return false;
4979 #endif
4980 
4981     if (delegatesScrolling()) {
4982         ScrollPosition oldPosition = scrollPosition();
4983         ScrollPosition newPosition = oldPosition - IntSize(wheelEvent.deltaX(), wheelEvent.deltaY());
4984         if (oldPosition != newPosition) {
4985             ScrollView::scrollTo(newPosition);
4986             scrollPositionChanged(oldPosition, scrollPosition());
4987             didChangeScrollOffset();
4988         }
4989         return true;
4990     }
4991 
4992     // We don&#39;t allow mouse wheeling to happen in a ScrollView that has had its scrollbars explicitly disabled.
4993     if (!canHaveScrollbars())
4994         return false;
4995 
4996     if (platformWidget())
4997         return false;
4998 
4999 #if ENABLE(ASYNC_SCROLLING)
5000     if (Page* page = frame().page()) {
5001         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator()) {
5002             if (scrollingCoordinator-&gt;coordinatesScrollingForFrameView(*this))
5003                 return scrollingCoordinator-&gt;handleWheelEvent(*this, wheelEvent) != ScrollingEventResult::DidNotHandleEvent;
5004         }
5005     }
5006 #endif
5007 
5008     return ScrollableArea::handleWheelEvent(wheelEvent);
5009 }
5010 
5011 
5012 bool FrameView::isVerticalDocument() const
5013 {
5014     RenderView* renderView = this-&gt;renderView();
5015     if (!renderView)
5016         return true;
5017 
5018     return renderView-&gt;style().isHorizontalWritingMode();
5019 }
5020 
5021 bool FrameView::isFlippedDocument() const
5022 {
5023     RenderView* renderView = this-&gt;renderView();
5024     if (!renderView)
5025         return false;
5026 
5027     return renderView-&gt;style().isFlippedBlocksWritingMode();
5028 }
5029 
5030 void FrameView::notifyWidgetsInAllFrames(WidgetNotification notification)
5031 {
5032     for (auto* frame = m_frame.ptr(); frame; frame = frame-&gt;tree().traverseNext(m_frame.ptr())) {
5033         if (FrameView* view = frame-&gt;view())
5034             view-&gt;notifyWidgets(notification);
5035     }
5036 }
5037 
5038 AXObjectCache* FrameView::axObjectCache() const
5039 {
5040     if (frame().document())
5041         return frame().document()-&gt;existingAXObjectCache();
5042     return nullptr;
5043 }
5044 
5045 #if PLATFORM(IOS_FAMILY)
5046 bool FrameView::useCustomFixedPositionLayoutRect() const
5047 {
5048     return !frame().settings().visualViewportEnabled() &amp;&amp; m_useCustomFixedPositionLayoutRect;
5049 }
5050 
5051 void FrameView::setCustomFixedPositionLayoutRect(const IntRect&amp; rect)
5052 {
5053     if (m_useCustomFixedPositionLayoutRect &amp;&amp; m_customFixedPositionLayoutRect == rect)
5054         return;
5055     m_useCustomFixedPositionLayoutRect = true;
5056     m_customFixedPositionLayoutRect = rect;
5057     updateContentsSize();
5058 }
5059 
5060 bool FrameView::updateFixedPositionLayoutRect()
5061 {
5062     if (!m_useCustomFixedPositionLayoutRect)
5063         return false;
5064 
5065     IntRect newRect;
5066     Page* page = frame().page();
5067     if (!page || !page-&gt;chrome().client().fetchCustomFixedPositionLayoutRect(newRect))
5068         return false;
5069 
5070     if (newRect != m_customFixedPositionLayoutRect) {
5071         m_customFixedPositionLayoutRect = newRect;
5072         setViewportConstrainedObjectsNeedLayout();
5073         return true;
5074     }
5075     return false;
5076 }
5077 
5078 void FrameView::setCustomSizeForResizeEvent(IntSize customSize)
5079 {
5080     m_useCustomSizeForResizeEvent = true;
5081     m_customSizeForResizeEvent = customSize;
5082     sendResizeEventIfNeeded();
5083 }
5084 
5085 void FrameView::setScrollVelocity(const VelocityData&amp; velocityData)
5086 {
5087     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
5088         tiledBacking-&gt;setVelocity(velocityData);
5089 }
5090 #endif // PLATFORM(IOS_FAMILY)
5091 
5092 void FrameView::setScrollingPerformanceLoggingEnabled(bool flag)
5093 {
5094     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
5095         tiledBacking-&gt;setScrollingPerformanceLoggingEnabled(flag);
5096 }
5097 
5098 void FrameView::didAddScrollbar(Scrollbar* scrollbar, ScrollbarOrientation orientation)
5099 {
5100     ScrollableArea::didAddScrollbar(scrollbar, orientation);
5101     Page* page = frame().page();
<a name="43" id="anc43"></a><span class="line-modified">5102     if (page &amp;&amp; page-&gt;isMonitoringWheelEvents())</span>
<span class="line-modified">5103         scrollAnimator().setWheelEventTestMonitor(page-&gt;wheelEventTestMonitor());</span>
5104     if (AXObjectCache* cache = axObjectCache())
5105         cache-&gt;handleScrollbarUpdate(this);
5106 }
5107 
5108 void FrameView::willRemoveScrollbar(Scrollbar* scrollbar, ScrollbarOrientation orientation)
5109 {
5110     ScrollableArea::willRemoveScrollbar(scrollbar, orientation);
5111     if (AXObjectCache* cache = axObjectCache()) {
5112         cache-&gt;remove(scrollbar);
5113         cache-&gt;handleScrollbarUpdate(this);
5114     }
5115 }
5116 
5117 void FrameView::addPaintPendingMilestones(OptionSet&lt;LayoutMilestone&gt; milestones)
5118 {
5119     m_milestonesPendingPaint.add(milestones);
5120 }
5121 
5122 void FrameView::fireLayoutRelatedMilestonesIfNeeded()
5123 {
5124     OptionSet&lt;LayoutMilestone&gt; requestedMilestones;
5125     OptionSet&lt;LayoutMilestone&gt; milestonesAchieved;
5126     Page* page = frame().page();
5127     if (page)
5128         requestedMilestones = page-&gt;requestedLayoutMilestones();
5129 
5130     if (m_firstLayoutCallbackPending) {
5131         m_firstLayoutCallbackPending = false;
5132         frame().loader().didFirstLayout();
5133         if (requestedMilestones &amp; DidFirstLayout)
5134             milestonesAchieved.add(DidFirstLayout);
5135         if (frame().isMainFrame())
5136             page-&gt;startCountingRelevantRepaintedObjects();
5137     }
5138 
5139     if (!m_isVisuallyNonEmpty &amp;&amp; qualifiesAsVisuallyNonEmpty()) {
5140         m_isVisuallyNonEmpty = true;
5141         addPaintPendingMilestones(DidFirstMeaningfulPaint);
5142         if (requestedMilestones &amp; DidFirstVisuallyNonEmptyLayout)
5143             milestonesAchieved.add(DidFirstVisuallyNonEmptyLayout);
5144     }
5145 
5146     if (!m_renderedSignificantAmountOfText &amp;&amp; qualifiesAsSignificantRenderedText()) {
5147         m_renderedSignificantAmountOfText = true;
5148         if (requestedMilestones &amp; DidRenderSignificantAmountOfText)
5149             milestonesAchieved.add(DidRenderSignificantAmountOfText);
5150     }
5151 
5152     if (milestonesAchieved &amp;&amp; frame().isMainFrame()) {
5153         if (milestonesAchieved.contains(DidFirstVisuallyNonEmptyLayout))
<a name="44" id="anc44"></a><span class="line-modified">5154             FRAMEVIEW_RELEASE_LOG_IF_ALLOWED(Layout, &quot;fireLayoutRelatedMilestonesIfNeeded: Firing first visually non-empty layout milestone on the main frame&quot;);</span>
5155         frame().loader().didReachLayoutMilestone(milestonesAchieved);
5156     }
5157 }
5158 
5159 void FrameView::firePaintRelatedMilestonesIfNeeded()
5160 {
5161     Page* page = frame().page();
5162     if (!page)
5163         return;
5164 
5165     OptionSet&lt;LayoutMilestone&gt; milestonesAchieved;
5166 
5167     // Make sure the pending paint milestones have actually been requested before we send them.
5168     if (m_milestonesPendingPaint &amp; DidFirstFlushForHeaderLayer) {
5169         if (page-&gt;requestedLayoutMilestones() &amp; DidFirstFlushForHeaderLayer)
5170             milestonesAchieved.add(DidFirstFlushForHeaderLayer);
5171     }
5172 
5173     if (m_milestonesPendingPaint &amp; DidFirstPaintAfterSuppressedIncrementalRendering) {
5174         if (page-&gt;requestedLayoutMilestones() &amp; DidFirstPaintAfterSuppressedIncrementalRendering)
5175             milestonesAchieved.add(DidFirstPaintAfterSuppressedIncrementalRendering);
5176     }
5177 
5178     if (m_milestonesPendingPaint &amp; DidFirstMeaningfulPaint) {
5179         if (page-&gt;requestedLayoutMilestones() &amp; DidFirstMeaningfulPaint)
5180             milestonesAchieved.add(DidFirstMeaningfulPaint);
5181     }
5182 
5183     m_milestonesPendingPaint = { };
5184 
5185     if (milestonesAchieved)
5186         page-&gt;mainFrame().loader().didReachLayoutMilestone(milestonesAchieved);
5187 }
5188 
5189 void FrameView::setVisualUpdatesAllowedByClient(bool visualUpdatesAllowed)
5190 {
5191     if (m_visualUpdatesAllowedByClient == visualUpdatesAllowed)
5192         return;
5193 
5194     m_visualUpdatesAllowedByClient = visualUpdatesAllowed;
5195 
5196     frame().document()-&gt;setVisualUpdatesAllowedByClient(visualUpdatesAllowed);
5197 }
5198 
5199 void FrameView::setScrollPinningBehavior(ScrollPinningBehavior pinning)
5200 {
5201     m_scrollPinningBehavior = pinning;
5202 
5203     if (Page* page = frame().page()) {
5204         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
5205             scrollingCoordinator-&gt;setScrollPinningBehavior(pinning);
5206     }
5207 
5208     updateScrollbars(scrollPosition());
5209 }
5210 
5211 ScrollBehaviorForFixedElements FrameView::scrollBehaviorForFixedElements() const
5212 {
5213     return frame().settings().backgroundShouldExtendBeyondPage() ? StickToViewportBounds : StickToDocumentBounds;
5214 }
5215 
5216 RenderView* FrameView::renderView() const
5217 {
5218     return frame().contentRenderer();
5219 }
5220 
5221 int FrameView::mapFromLayoutToCSSUnits(LayoutUnit value) const
5222 {
5223     return value / (frame().pageZoomFactor() * frame().frameScaleFactor());
5224 }
5225 
5226 LayoutUnit FrameView::mapFromCSSToLayoutUnits(int value) const
5227 {
5228     return LayoutUnit(value * frame().pageZoomFactor() * frame().frameScaleFactor());
5229 }
5230 
5231 void FrameView::didAddWidgetToRenderTree(Widget&amp; widget)
5232 {
5233     ASSERT(!m_widgetsInRenderTree.contains(&amp;widget));
5234     m_widgetsInRenderTree.add(&amp;widget);
5235 }
5236 
5237 void FrameView::willRemoveWidgetFromRenderTree(Widget&amp; widget)
5238 {
5239     ASSERT(m_widgetsInRenderTree.contains(&amp;widget));
5240     m_widgetsInRenderTree.remove(&amp;widget);
5241 }
5242 
5243 static Vector&lt;RefPtr&lt;Widget&gt;&gt; collectAndProtectWidgets(const HashSet&lt;Widget*&gt;&amp; set)
5244 {
5245     return copyToVectorOf&lt;RefPtr&lt;Widget&gt;&gt;(set);
5246 }
5247 
5248 void FrameView::updateWidgetPositions()
5249 {
5250     m_updateWidgetPositionsTimer.stop();
5251     // updateWidgetPosition() can possibly cause layout to be re-entered (via plug-ins running
5252     // scripts in response to NPP_SetWindow, for example), so we need to keep the Widgets
5253     // alive during enumeration.
5254     for (auto&amp; widget : collectAndProtectWidgets(m_widgetsInRenderTree)) {
5255         if (auto* renderer = RenderWidget::find(*widget)) {
5256             auto ignoreWidgetState = renderer-&gt;updateWidgetPosition();
5257             UNUSED_PARAM(ignoreWidgetState);
5258         }
5259     }
5260 }
5261 
5262 void FrameView::scheduleUpdateWidgetPositions()
5263 {
5264     if (!m_updateWidgetPositionsTimer.isActive())
5265         m_updateWidgetPositionsTimer.startOneShot(0_s);
5266 }
5267 
5268 void FrameView::updateWidgetPositionsTimerFired()
5269 {
5270     updateWidgetPositions();
5271 }
5272 
5273 void FrameView::notifyWidgets(WidgetNotification notification)
5274 {
5275     for (auto&amp; widget : collectAndProtectWidgets(m_widgetsInRenderTree))
5276         widget-&gt;notifyWidget(notification);
5277 }
5278 
5279 void FrameView::setViewExposedRect(Optional&lt;FloatRect&gt; viewExposedRect)
5280 {
5281     if (m_viewExposedRect == viewExposedRect)
5282         return;
5283 
5284     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; this &lt;&lt; &quot; setViewExposedRect &quot; &lt;&lt; (viewExposedRect ? viewExposedRect.value() : FloatRect()));
5285 
5286     bool hasRectChanged = !m_viewExposedRect == !viewExposedRect;
5287     m_viewExposedRect = viewExposedRect;
5288 
5289     // FIXME: We should support clipping to the exposed rect for subframes as well.
5290     if (!frame().isMainFrame())
5291         return;
5292 
5293     if (TiledBacking* tiledBacking = this-&gt;tiledBacking()) {
5294         if (hasRectChanged)
5295             updateTiledBackingAdaptiveSizing();
5296         adjustTiledBackingCoverage();
5297         tiledBacking-&gt;setTiledScrollingIndicatorPosition(m_viewExposedRect ? m_viewExposedRect.value().location() : FloatPoint());
5298     }
5299 
5300     if (auto* view = renderView())
5301         view-&gt;compositor().scheduleLayerFlush(false /* canThrottle */);
5302 
5303     if (auto* page = frame().page())
5304         page-&gt;pageOverlayController().didChangeViewExposedRect();
5305 }
5306 
5307 void FrameView::clearViewportSizeOverrideForCSSViewportUnits()
5308 {
5309     if (!m_overrideViewportSize)
5310         return;
5311 
5312     m_overrideViewportSize = WTF::nullopt;
5313     if (auto* document = frame().document())
5314         document-&gt;styleScope().didChangeStyleSheetEnvironment();
5315 }
5316 
5317 void FrameView::setViewportSizeForCSSViewportUnits(IntSize size)
5318 {
5319     overrideViewportSizeForCSSViewportUnits({ size.width(), size.height() });
5320 }
5321 
5322 void FrameView::overrideViewportSizeForCSSViewportUnits(OverrideViewportSize size)
5323 {
5324     if (m_overrideViewportSize &amp;&amp; *m_overrideViewportSize == size)
5325         return;
5326 
5327     m_overrideViewportSize = size;
5328 
5329     if (auto* document = frame().document())
5330         document-&gt;styleScope().didChangeStyleSheetEnvironment();
5331 }
5332 
5333 IntSize FrameView::viewportSizeForCSSViewportUnits() const
5334 {
5335     OverrideViewportSize viewportSize;
5336 
5337     if (m_overrideViewportSize) {
5338         viewportSize = *m_overrideViewportSize;
5339         // auto-size overrides the width only, so we can&#39;t always bail out early here.
5340         if (viewportSize.width &amp;&amp; viewportSize.height)
5341             return { *viewportSize.width, *viewportSize.height };
5342     }
5343 
5344     if (useFixedLayout()) {
5345         auto fixedLayoutSize = this-&gt;fixedLayoutSize();
5346         viewportSize.width = viewportSize.width.valueOr(fixedLayoutSize.width());
5347         viewportSize.height = viewportSize.height.valueOr(fixedLayoutSize.height());
5348         return { *viewportSize.width, *viewportSize.height };
5349     }
5350 
5351     // FIXME: the value returned should take into account the value of the overflow
5352     // property on the root element.
5353     auto visibleContentSizeIncludingScrollbars = visibleContentRectIncludingScrollbars().size();
5354     viewportSize.width = viewportSize.width.valueOr(visibleContentSizeIncludingScrollbars.width());
5355     viewportSize.height = viewportSize.height.valueOr(visibleContentSizeIncludingScrollbars.height());
5356     return { *viewportSize.width, *viewportSize.height };
5357 }
5358 
5359 bool FrameView::shouldPlaceBlockDirectionScrollbarOnLeft() const
5360 {
5361     return renderView() &amp;&amp; renderView()-&gt;shouldPlaceBlockDirectionScrollbarOnLeft();
5362 }
5363 
5364 } // namespace WebCore
<a name="45" id="anc45"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="45" type="hidden" />
</body>
</html>
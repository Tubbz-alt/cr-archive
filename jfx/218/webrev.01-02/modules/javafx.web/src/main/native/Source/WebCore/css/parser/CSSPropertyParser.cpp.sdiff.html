<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSPropertyParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSParserToken.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSPropertyParser.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSPropertyParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  55 #include &quot;CSSParserIdioms.h&quot;
  56 #include &quot;CSSPendingSubstitutionValue.h&quot;
  57 #include &quot;CSSPrimitiveValueMappings.h&quot;
  58 #include &quot;CSSPropertyParserHelpers.h&quot;
  59 #include &quot;CSSReflectValue.h&quot;
  60 #include &quot;CSSShadowValue.h&quot;
  61 #include &quot;CSSTimingFunctionValue.h&quot;
  62 #include &quot;CSSUnicodeRangeValue.h&quot;
  63 #include &quot;CSSVariableParser.h&quot;
  64 #include &quot;CSSVariableReferenceValue.h&quot;
  65 #include &quot;Counter.h&quot;
  66 #include &quot;FontFace.h&quot;
  67 #include &quot;HashTools.h&quot;
  68 // FIXME-NEWPARSER: Replace Pair and Rect with actual CSSValue subclasses (CSSValuePair and CSSQuadValue).
  69 #include &quot;Pair.h&quot;
  70 #include &quot;Rect.h&quot;
  71 #include &quot;RenderTheme.h&quot;
  72 #include &quot;RuntimeEnabledFeatures.h&quot;
  73 #include &quot;SVGPathByteStream.h&quot;
  74 #include &quot;SVGPathUtilities.h&quot;

  75 #include &quot;StyleBuilderConverter.h&quot;
  76 #include &quot;StylePropertyShorthand.h&quot;
  77 #include &quot;StylePropertyShorthandFunctions.h&quot;
<span class="line-removed">  78 #include &quot;StyleResolver.h&quot;</span>
  79 #include &lt;bitset&gt;
  80 #include &lt;memory&gt;
  81 #include &lt;wtf/text/StringBuilder.h&gt;
  82 
  83 namespace WebCore {
  84 
  85 bool isCustomPropertyName(const String&amp; propertyName)
  86 {
  87     return propertyName.length() &gt; 2 &amp;&amp; propertyName.characterAt(0) == &#39;-&#39; &amp;&amp; propertyName.characterAt(1) == &#39;-&#39;;
  88 }
  89 
  90 static bool hasPrefix(const char* string, unsigned length, const char* prefix)
  91 {
  92     for (unsigned i = 0; i &lt; length; ++i) {
  93         if (!prefix[i])
  94             return true;
  95         if (string[i] != prefix[i])
  96             return false;
  97     }
  98     return false;
</pre>
<hr />
<pre>
 138 #if PLATFORM(IOS_FAMILY)
 139         cssPropertyNameIOSAliasing(buffer, name, length);
 140 #endif
 141     }
 142 
 143     const Property* hashTableEntry = findProperty(name, length);
 144     if (hashTableEntry) {
 145         auto propertyID = static_cast&lt;CSSPropertyID&gt;(hashTableEntry-&gt;id);
 146         if (isEnabledCSSProperty(propertyID))
 147             return propertyID;
 148     }
 149     return CSSPropertyInvalid;
 150 }
 151 
 152 static bool isAppleLegacyCssValueKeyword(const char* valueKeyword, unsigned length)
 153 {
 154     static const char applePrefix[] = &quot;-apple-&quot;;
 155     static const char appleSystemPrefix[] = &quot;-apple-system&quot;;
 156     static const char applePayPrefix[] = &quot;-apple-pay&quot;;
 157 
<span class="line-modified"> 158 #if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)</span>
 159     static const char* appleWirelessPlaybackTargetActive = getValueName(CSSValueAppleWirelessPlaybackTargetActive);
 160 #endif
 161 
 162     return hasPrefix(valueKeyword, length, applePrefix)
 163     &amp;&amp; !hasPrefix(valueKeyword, length, appleSystemPrefix)
 164     &amp;&amp; !hasPrefix(valueKeyword, length, applePayPrefix)
<span class="line-modified"> 165 #if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)</span>
 166     &amp;&amp; !WTF::equal(reinterpret_cast&lt;const LChar*&gt;(valueKeyword), reinterpret_cast&lt;const LChar*&gt;(appleWirelessPlaybackTargetActive), length)
 167 #endif
 168     ;
 169 }
 170 
 171 template &lt;typename CharacterType&gt;
 172 static CSSValueID cssValueKeywordID(const CharacterType* valueKeyword, unsigned length)
 173 {
 174     char buffer[maxCSSValueKeywordLength + 1 + 1]; // 1 to turn &quot;apple&quot;/&quot;khtml&quot; into &quot;webkit&quot;, 1 for null character
 175 
 176     for (unsigned i = 0; i != length; ++i) {
 177         CharacterType c = valueKeyword[i];
 178         if (!c || c &gt;= 0x7F)
 179             return CSSValueInvalid; // illegal keyword.
 180         buffer[i] = WTF::toASCIILower(c);
 181     }
 182     buffer[length] = &#39;\0&#39;;
 183 
 184     if (buffer[0] == &#39;-&#39;) {
 185         // If the prefix is -apple- or -khtml-, change it to -webkit-.
</pre>
<hr />
<pre>
 242     if (currentShorthand) {
 243         auto shorthands = matchingShorthandsForLonghand(property);
 244         setFromShorthand = true;
 245         if (shorthands.size() &gt; 1)
 246             shorthandIndex = indexOfShorthandForLonghand(currentShorthand, shorthands);
 247     }
 248 
 249     m_parsedProperties-&gt;append(CSSProperty(property, WTFMove(value), important, setFromShorthand, shorthandIndex, implicit));
 250 }
 251 
 252 void CSSPropertyParser::addExpandedPropertyForValue(CSSPropertyID property, Ref&lt;CSSValue&gt;&amp;&amp; value, bool important)
 253 {
 254     const StylePropertyShorthand&amp; shorthand = shorthandForProperty(property);
 255     unsigned shorthandLength = shorthand.length();
 256     ASSERT(shorthandLength);
 257     const CSSPropertyID* longhands = shorthand.properties();
 258     for (unsigned i = 0; i &lt; shorthandLength; ++i)
 259         addProperty(longhands[i], property, value.copyRef(), important);
 260 }
 261 
<span class="line-modified"> 262 bool CSSPropertyParser::parseValue(CSSPropertyID propertyID, bool important, const CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, ParsedPropertyVector&amp; parsedProperties, StyleRule::Type ruleType)</span>
 263 {
 264     int parsedPropertiesSize = parsedProperties.size();
 265 
 266     CSSPropertyParser parser(range, context, &amp;parsedProperties);
 267     bool parseSuccess;
 268 
 269 #if ENABLE(CSS_DEVICE_ADAPTATION)
<span class="line-modified"> 270     if (ruleType == StyleRule::Viewport)</span>
 271         parseSuccess = parser.parseViewportDescriptor(propertyID, important);
 272     else
 273 #endif
<span class="line-modified"> 274     if (ruleType == StyleRule::FontFace)</span>
 275         parseSuccess = parser.parseFontFaceDescriptor(propertyID);
 276     else
 277         parseSuccess = parser.parseValueStart(propertyID, important);
 278 
 279     if (!parseSuccess)
 280         parsedProperties.shrink(parsedPropertiesSize);
 281 
 282     return parseSuccess;
 283 }
 284 
 285 RefPtr&lt;CSSValue&gt; CSSPropertyParser::parseSingleValue(CSSPropertyID property, const CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
 286 {
 287     CSSPropertyParser parser(range, context, nullptr);
 288     RefPtr&lt;CSSValue&gt; value = parser.parseSingleValue(property);
 289     if (!value || !parser.m_range.atEnd())
 290         return nullptr;
 291     return value;
 292 }
 293 
 294 bool CSSPropertyParser::canParseTypedCustomPropertyValue(const String&amp; syntax, const CSSParserTokenRange&amp; tokens, const CSSParserContext&amp; context)
 295 {
 296     CSSPropertyParser parser(tokens, context, nullptr);
 297     return parser.canParseTypedCustomPropertyValue(syntax);
 298 }
 299 
<span class="line-modified"> 300 RefPtr&lt;CSSCustomPropertyValue&gt; CSSPropertyParser::parseTypedCustomPropertyValue(const String&amp; name, const String&amp; syntax, const CSSParserTokenRange&amp; tokens, const StyleResolver&amp; styleResolver, const CSSParserContext&amp; context)</span>
 301 {
 302     CSSPropertyParser parser(tokens, context, nullptr, false);
<span class="line-modified"> 303     RefPtr&lt;CSSCustomPropertyValue&gt; value = parser.parseTypedCustomPropertyValue(name, syntax, styleResolver);</span>
 304     if (!value || !parser.m_range.atEnd())
 305         return nullptr;
 306     return value;
 307 }
 308 
 309 void CSSPropertyParser::collectParsedCustomPropertyValueDependencies(const String&amp; syntax, bool isRoot, HashSet&lt;CSSPropertyID&gt;&amp; dependencies, const CSSParserTokenRange&amp; tokens, const CSSParserContext&amp; context)
 310 {
 311     CSSPropertyParser parser(tokens, context, nullptr);
 312     parser.collectParsedCustomPropertyValueDependencies(syntax, isRoot, dependencies);
 313 }
 314 
 315 bool CSSPropertyParser::parseValueStart(CSSPropertyID propertyID, bool important)
 316 {
 317     if (consumeCSSWideKeyword(propertyID, important))
 318         return true;
 319 
 320     CSSParserTokenRange originalRange = m_range;
 321     bool isShorthand = isShorthandCSSProperty(propertyID);
 322 
 323     if (isShorthand) {
</pre>
<hr />
<pre>
 372         addProperty(propertyID, CSSPropertyInvalid, value.releaseNonNull(), important);
 373     } else
 374         addExpandedPropertyForValue(propertyID, value.releaseNonNull(), important);
 375     m_range = rangeCopy;
 376     return true;
 377 }
 378 
 379 bool CSSPropertyParser::consumeTransformOrigin(bool important)
 380 {
 381     RefPtr&lt;CSSPrimitiveValue&gt; resultX;
 382     RefPtr&lt;CSSPrimitiveValue&gt; resultY;
 383     if (consumeOneOrTwoValuedPosition(m_range, m_context.mode, UnitlessQuirk::Forbid, resultX, resultY)) {
 384         m_range.consumeWhitespace();
 385         bool atEnd = m_range.atEnd();
 386         RefPtr&lt;CSSPrimitiveValue&gt; resultZ = consumeLength(m_range, m_context.mode, ValueRangeAll);
 387         bool hasZ = resultZ;
 388         if (!hasZ &amp;&amp; !atEnd)
 389             return false;
 390         addProperty(CSSPropertyTransformOriginX, CSSPropertyTransformOrigin, resultX.releaseNonNull(), important);
 391         addProperty(CSSPropertyTransformOriginY, CSSPropertyTransformOrigin, resultY.releaseNonNull(), important);
<span class="line-modified"> 392         addProperty(CSSPropertyTransformOriginZ, CSSPropertyTransformOrigin, resultZ ? resultZ.releaseNonNull() : CSSValuePool::singleton().createValue(0, CSSPrimitiveValue::UnitType::CSS_PX), important, !hasZ);</span>
 393 
 394         return true;
 395     }
 396     return false;
 397 }
 398 
 399 bool CSSPropertyParser::consumePerspectiveOrigin(bool important)
 400 {
 401     RefPtr&lt;CSSPrimitiveValue&gt; resultX;
 402     RefPtr&lt;CSSPrimitiveValue&gt; resultY;
<span class="line-modified"> 403     if (consumePosition(m_range, m_context.mode, UnitlessQuirk::Forbid, resultX, resultY)) {</span>
 404         addProperty(CSSPropertyPerspectiveOriginX, CSSPropertyPerspectiveOrigin, resultX.releaseNonNull(), important);
 405         addProperty(CSSPropertyPerspectiveOriginY, CSSPropertyPerspectiveOrigin, resultY.releaseNonNull(), important);
 406         return true;
 407     }
 408     return false;
 409 }
 410 
 411 // Methods for consuming non-shorthand properties starts here.
 412 static RefPtr&lt;CSSValue&gt; consumeWillChange(CSSParserTokenRange&amp; range)
 413 {
 414     if (range.peek().id() == CSSValueAuto)
 415         return consumeIdent(range);
 416 
 417     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createCommaSeparated();
 418     // Every comma-separated list of identifiers is a valid will-change value,
 419     // unless the list includes an explicitly disallowed identifier.
 420     while (true) {
 421         if (range.peek().type() != IdentToken)
 422             return nullptr;
 423         CSSPropertyID propertyID = cssPropertyID(range.peek().value());
</pre>
<hr />
<pre>
 953 #if ENABLE(VARIATION_FONTS)
 954 static bool fontStyleIsWithinRange(float oblique)
 955 {
 956     return oblique &gt; -90 &amp;&amp; oblique &lt; 90;
 957 }
 958 #endif
 959 
 960 static RefPtr&lt;CSSFontStyleValue&gt; consumeFontStyle(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
 961 {
 962     auto result = consumeFontStyleKeywordValue(range);
 963     if (!result)
 964         return nullptr;
 965 
 966     auto valueID = result-&gt;valueID();
 967     if (valueID == CSSValueNormal || valueID == CSSValueItalic)
 968         return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(valueID));
 969     ASSERT(result-&gt;valueID() == CSSValueOblique);
 970 #if ENABLE(VARIATION_FONTS)
 971     if (!range.atEnd()) {
 972         if (auto angle = consumeAngle(range, cssParserMode)) {
<span class="line-modified"> 973             if (fontStyleIsWithinRange(angle-&gt;value&lt;float&gt;(CSSPrimitiveValue::CSS_DEG)))</span>
 974                 return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueOblique), WTFMove(angle));
 975             return nullptr;
 976         }
 977     }
 978 #else
 979     UNUSED_PARAM(cssParserMode);
 980 #endif
 981     return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueOblique));
 982 }
 983 
 984 #if ENABLE(VARIATION_FONTS)
 985 static RefPtr&lt;CSSFontStyleRangeValue&gt; consumeFontStyleRange(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
 986 {
 987     auto keyword = consumeFontStyleKeywordValue(range);
 988     if (!keyword)
 989         return nullptr;
 990 
 991     if (keyword-&gt;valueID() != CSSValueOblique || range.atEnd())
 992         return CSSFontStyleRangeValue::create(keyword.releaseNonNull());
 993 
 994     if (auto firstAngle = consumeAngle(range, cssParserMode)) {
<span class="line-modified"> 995         if (!fontStyleIsWithinRange(firstAngle-&gt;value&lt;float&gt;(CSSPrimitiveValue::CSS_DEG)))</span>
 996             return nullptr;
 997         if (range.atEnd()) {
 998             auto result = CSSValueList::createSpaceSeparated();
 999             result-&gt;append(firstAngle.releaseNonNull());
1000             return CSSFontStyleRangeValue::create(keyword.releaseNonNull(), WTFMove(result));
1001         }
1002         auto secondAngle = consumeAngle(range, cssParserMode);
<span class="line-modified">1003         if (!secondAngle || !fontStyleIsWithinRange(secondAngle-&gt;value&lt;float&gt;(CSSPrimitiveValue::CSS_DEG)) || firstAngle-&gt;floatValue(CSSPrimitiveValue::CSS_DEG) &gt; secondAngle-&gt;floatValue(CSSPrimitiveValue::CSS_DEG))</span>
1004             return nullptr;
1005         auto result = CSSValueList::createSpaceSeparated();
1006         result-&gt;append(firstAngle.releaseNonNull());
1007         result-&gt;append(secondAngle.releaseNonNull());
1008         return CSSFontStyleRangeValue::create(keyword.releaseNonNull(), WTFMove(result));
1009     }
1010 
1011     return nullptr;
1012 }
1013 #endif
1014 
1015 static String concatenateFamilyName(CSSParserTokenRange&amp; range)
1016 {
1017     StringBuilder builder;
1018     bool addedSpace = false;
1019     const CSSParserToken&amp; firstToken = range.peek();
1020     while (range.peek().type() == IdentToken) {
1021         if (!builder.isEmpty()) {
1022             builder.append(&#39; &#39;);
1023             addedSpace = true;
</pre>
<hr />
<pre>
1158 template&lt;typename... Args&gt;
1159 static Ref&lt;CSSPrimitiveValue&gt; createPrimitiveValuePair(Args&amp;&amp;... args)
1160 {
1161     return CSSValuePool::singleton().createValue(Pair::create(std::forward&lt;Args&gt;(args)...));
1162 }
1163 
1164 
1165 static RefPtr&lt;CSSValue&gt; consumeCounter(CSSParserTokenRange&amp; range, int defaultValue)
1166 {
1167     if (range.peek().id() == CSSValueNone)
1168         return consumeIdent(range);
1169 
1170     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
1171     do {
1172         RefPtr&lt;CSSPrimitiveValue&gt; counterName = consumeCustomIdent(range);
1173         if (!counterName)
1174             return nullptr;
1175         int i = defaultValue;
1176         if (RefPtr&lt;CSSPrimitiveValue&gt; counterValue = consumeInteger(range))
1177             i = counterValue-&gt;intValue();
<span class="line-modified">1178         list-&gt;append(createPrimitiveValuePair(counterName.releaseNonNull(), CSSPrimitiveValue::create(i, CSSPrimitiveValue::UnitType::CSS_NUMBER), Pair::IdenticalValueEncoding::Coalesce));</span>
1179     } while (!range.atEnd());
1180     return list;
1181 }
1182 
1183 static RefPtr&lt;CSSValue&gt; consumePageSize(CSSParserTokenRange&amp; range)
1184 {
1185     return consumeIdent&lt;CSSValueA3, CSSValueA4, CSSValueA5, CSSValueB4, CSSValueB5, CSSValueLedger, CSSValueLegal, CSSValueLetter&gt;(range);
1186 }
1187 
1188 static RefPtr&lt;CSSValueList&gt; consumeSize(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1189 {
1190     RefPtr&lt;CSSValueList&gt; result = CSSValueList::createSpaceSeparated();
1191 
1192     if (range.peek().id() == CSSValueAuto) {
1193         result-&gt;append(consumeIdent(range).releaseNonNull());
1194         return result;
1195     }
1196 
1197     if (RefPtr&lt;CSSValue&gt; width = consumeLength(range, cssParserMode, ValueRangeNonNegative)) {
1198         RefPtr&lt;CSSValue&gt; height = consumeLength(range, cssParserMode, ValueRangeNonNegative);
</pre>
<hr />
<pre>
1363 {
1364     if (range.peek().id() == CSSValueAuto)
1365         return consumeIdent(range);
1366     return consumeString(range);
1367 }
1368 
1369 static RefPtr&lt;CSSValue&gt; consumeHyphenateLimit(CSSParserTokenRange&amp; range, CSSValueID valueID)
1370 {
1371     if (range.peek().id() == valueID)
1372         return consumeIdent(range);
1373     return consumeNumber(range, ValueRangeNonNegative);
1374 }
1375 
1376 static RefPtr&lt;CSSValue&gt; consumeColumnWidth(CSSParserTokenRange&amp; range)
1377 {
1378     if (range.peek().id() == CSSValueAuto)
1379         return consumeIdent(range);
1380     // Always parse lengths in strict mode here, since it would be ambiguous otherwise when used in
1381     // the &#39;columns&#39; shorthand property.
1382     RefPtr&lt;CSSPrimitiveValue&gt; columnWidth = consumeLength(range, HTMLStandardMode, ValueRangeNonNegative);
<span class="line-modified">1383     if (!columnWidth || (!columnWidth-&gt;isCalculated() &amp;&amp; !columnWidth-&gt;doubleValue()) || (columnWidth-&gt;cssCalcValue() &amp;&amp; !columnWidth-&gt;cssCalcValue()-&gt;doubleValue()))</span>
1384         return nullptr;

1385     return columnWidth;
1386 }
1387 
1388 static RefPtr&lt;CSSValue&gt; consumeColumnCount(CSSParserTokenRange&amp; range)
1389 {
1390     if (range.peek().id() == CSSValueAuto)
1391         return consumeIdent(range);
1392     return consumePositiveInteger(range);
1393 }
1394 
1395 static RefPtr&lt;CSSValue&gt; consumeGapLength(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1396 {
1397     if (range.peek().id() == CSSValueNormal)
1398         return consumeIdent(range);
1399     return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
1400 }
1401 
1402 static RefPtr&lt;CSSValue&gt; consumeColumnSpan(CSSParserTokenRange&amp; range)
1403 {
1404     return consumeIdent&lt;CSSValueAll, CSSValueNone&gt;(range);
</pre>
<hr />
<pre>
1418     return zoom;
1419 }
1420 
1421 static RefPtr&lt;CSSValue&gt; consumeAnimationIterationCount(CSSParserTokenRange&amp; range)
1422 {
1423     if (range.peek().id() == CSSValueInfinite)
1424         return consumeIdent(range);
1425     return consumeNumber(range, ValueRangeNonNegative);
1426 }
1427 
1428 static RefPtr&lt;CSSValue&gt; consumeAnimationName(CSSParserTokenRange&amp; range)
1429 {
1430     if (range.peek().id() == CSSValueNone)
1431         return consumeIdent(range);
1432 
1433     if (range.peek().type() == StringToken) {
1434         const CSSParserToken&amp; token = range.consumeIncludingWhitespace();
1435         if (equalIgnoringASCIICase(token.value(), &quot;none&quot;))
1436             return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1437         // FIXME-NEWPARSER: Want to use a CSSCustomIdentValue here eventually.
<span class="line-modified">1438         return CSSValuePool::singleton().createValue(token.value().toString(), CSSPrimitiveValue::UnitType::CSS_STRING);</span>
1439     }
1440 
1441     return consumeCustomIdent(range);
1442 }
1443 
1444 static RefPtr&lt;CSSValue&gt; consumeTransitionProperty(CSSParserTokenRange&amp; range)
1445 {
1446     const CSSParserToken&amp; token = range.peek();
1447     if (token.type() != IdentToken)
1448         return nullptr;
1449     if (token.id() == CSSValueNone)
1450         return consumeIdent(range);
1451 
1452     if (CSSPropertyID property = token.parseAsCSSPropertyID()) {
1453         range.consumeIncludingWhitespace();
1454 
1455         // FIXME-NEWPARSER: No reason why we can&#39;t use the &quot;all&quot; property now that it exists.
1456         // The old parser used a value keyword for &quot;all&quot;, though, since it predated support for
1457         // the property.
1458         if (property == CSSPropertyAll)
</pre>
<hr />
<pre>
1846 static bool consumeNumbers(CSSParserTokenRange&amp; args, RefPtr&lt;CSSFunctionValue&gt;&amp; transformValue, unsigned numberOfArguments)
1847 {
1848     do {
1849         RefPtr&lt;CSSPrimitiveValue&gt; parsedValue = consumeNumber(args, ValueRangeAll);
1850         if (!parsedValue)
1851             return false;
1852         transformValue-&gt;append(parsedValue.releaseNonNull());
1853         if (--numberOfArguments &amp;&amp; !consumeCommaIncludingWhitespace(args))
1854             return false;
1855     } while (numberOfArguments);
1856     return true;
1857 }
1858 
1859 static bool consumePerspective(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode, RefPtr&lt;CSSFunctionValue&gt;&amp; transformValue)
1860 {
1861     RefPtr&lt;CSSPrimitiveValue&gt; parsedValue = consumeLength(args, cssParserMode, ValueRangeNonNegative);
1862     if (!parsedValue) {
1863         double perspective;
1864         if (!consumeNumberRaw(args, perspective) || perspective &lt; 0)
1865             return false;
<span class="line-modified">1866         parsedValue = CSSPrimitiveValue::create(perspective, CSSPrimitiveValue::UnitType::CSS_PX);</span>
1867     }
1868     if (!parsedValue)
1869         return false;
1870     transformValue-&gt;append(parsedValue.releaseNonNull());
1871     return true;
1872 }
1873 
1874 static RefPtr&lt;CSSValue&gt; consumeTransformValue(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1875 {
1876     CSSValueID functionId = range.peek().functionId();
1877     if (functionId == CSSValueInvalid)
1878         return nullptr;
1879     CSSParserTokenRange args = consumeFunction(range);
1880     if (args.atEnd())
1881         return nullptr;
1882 
1883     RefPtr&lt;CSSFunctionValue&gt; transformValue = CSSFunctionValue::create(functionId);
1884     RefPtr&lt;CSSValue&gt; parsedValue;
1885     switch (functionId) {
1886     case CSSValueRotate:
</pre>
<hr />
<pre>
1978     } while (!range.atEnd());
1979 
1980     return list;
1981 }
1982 
1983 template &lt;CSSValueID start, CSSValueID end&gt;
1984 static RefPtr&lt;CSSPrimitiveValue&gt; consumePositionLonghand(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1985 {
1986     if (range.peek().type() == IdentToken) {
1987         CSSValueID id = range.peek().id();
1988         int percent;
1989         if (id == start)
1990             percent = 0;
1991         else if (id == CSSValueCenter)
1992             percent = 50;
1993         else if (id == end)
1994             percent = 100;
1995         else
1996             return nullptr;
1997         range.consumeIncludingWhitespace();
<span class="line-modified">1998         return CSSPrimitiveValue::create(percent, CSSPrimitiveValue::UnitType::CSS_PERCENTAGE);</span>
1999     }
2000     return consumeLengthOrPercent(range, cssParserMode, ValueRangeAll);
2001 }
2002 
2003 static RefPtr&lt;CSSPrimitiveValue&gt; consumePositionX(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2004 {
2005     return consumePositionLonghand&lt;CSSValueLeft, CSSValueRight&gt;(range, cssParserMode);
2006 }
2007 
2008 static RefPtr&lt;CSSPrimitiveValue&gt; consumePositionY(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2009 {
2010     return consumePositionLonghand&lt;CSSValueTop, CSSValueBottom&gt;(range, cssParserMode);
2011 }
2012 
2013 static RefPtr&lt;CSSValue&gt; consumePaintStroke(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2014 {
2015     if (range.peek().id() == CSSValueNone)
2016         return consumeIdent(range);
2017     RefPtr&lt;CSSPrimitiveValue&gt; url = consumeUrl(range);
2018     if (url) {
</pre>
<hr />
<pre>
2123         return consumeIdent(range);
2124 
2125     RefPtr&lt;CSSValueList&gt; dashes = CSSValueList::createCommaSeparated();
2126     do {
2127         RefPtr&lt;CSSPrimitiveValue&gt; dash = consumeLengthOrPercent(range, SVGAttributeMode, ValueRangeNonNegative);
2128         if (!dash || (consumeCommaIncludingWhitespace(range) &amp;&amp; range.atEnd()))
2129             return nullptr;
2130         dashes-&gt;append(dash.releaseNonNull());
2131     } while (!range.atEnd());
2132     return dashes;
2133 }
2134 
2135 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBaselineShift(CSSParserTokenRange&amp; range)
2136 {
2137     CSSValueID id = range.peek().id();
2138     if (id == CSSValueBaseline || id == CSSValueSub || id == CSSValueSuper)
2139         return consumeIdent(range);
2140     return consumeLengthOrPercent(range, SVGAttributeMode, ValueRangeAll);
2141 }
2142 
<span class="line-modified">2143 static RefPtr&lt;CSSPrimitiveValue&gt; consumeRxOrRy(CSSParserTokenRange&amp; range)</span>
2144 {
<span class="line-modified">2145     // FIXME-NEWPARSER: We don&#39;t support auto values when mapping, so for now turn this</span>
<span class="line-modified">2146     // off until we can figure out if we&#39;re even supposed to support it.</span>
<span class="line-modified">2147     // if (range.peek().id() == CSSValueAuto)</span>
<span class="line-removed">2148     //     return consumeIdent(range);</span>
<span class="line-removed">2149     return consumeLengthOrPercent(range, SVGAttributeMode, ValueRangeAll, UnitlessQuirk::Forbid);</span>
2150 }
2151 
2152 static RefPtr&lt;CSSValue&gt; consumeCursor(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, bool inQuirksMode)
2153 {
2154     RefPtr&lt;CSSValueList&gt; list;
<span class="line-modified">2155     while (RefPtr&lt;CSSValue&gt; image = consumeImage(range, context, ConsumeGeneratedImage::Forbid)) {</span>
2156         double num;
2157         IntPoint hotSpot(-1, -1);
2158         bool hotSpotSpecified = false;
2159         if (consumeNumberRaw(range, num)) {
2160             hotSpot.setX(int(num));
2161             if (!consumeNumberRaw(range, num))
2162                 return nullptr;
2163             hotSpot.setY(int(num));
2164             hotSpotSpecified = true;
2165         }
2166 
2167         if (!list)
2168             list = CSSValueList::createCommaSeparated();
2169 
2170         list-&gt;append(CSSCursorImageValue::create(image.releaseNonNull(), hotSpotSpecified, hotSpot, context.isContentOpaque ? LoadedFromOpaqueSource::Yes : LoadedFromOpaqueSource::No));
2171         if (!consumeCommaIncludingWhitespace(range))
2172             return nullptr;
2173     }
2174 
2175     CSSValueID id = range.peek().id();
</pre>
<hr />
<pre>
2190     list-&gt;append(cursorType.releaseNonNull());
2191     return list;
2192 }
2193 
2194 static RefPtr&lt;CSSValue&gt; consumeAttr(CSSParserTokenRange args, CSSParserContext context)
2195 {
2196     if (args.peek().type() != IdentToken)
2197         return nullptr;
2198 
2199     CSSParserToken token = args.consumeIncludingWhitespace();
2200     auto attrName = token.value().toAtomString();
2201     if (context.isHTMLDocument)
2202         attrName = attrName.convertToASCIILowercase();
2203 
2204     if (!args.atEnd())
2205         return nullptr;
2206 
2207     // FIXME-NEWPARSER: We want to use a CSSCustomIdentValue here eventually for the attrName.
2208     // FIXME-NEWPARSER: We want to use a CSSFunctionValue rather than relying on a custom
2209     // attr() primitive value.
<span class="line-modified">2210     return CSSValuePool::singleton().createValue(attrName, CSSPrimitiveValue::CSS_ATTR);</span>
2211 }
2212 
2213 static RefPtr&lt;CSSValue&gt; consumeCounterContent(CSSParserTokenRange args, bool counters)
2214 {
2215     RefPtr&lt;CSSPrimitiveValue&gt; identifier = consumeCustomIdent(args);
2216     if (!identifier)
2217         return nullptr;
2218 
2219     RefPtr&lt;CSSPrimitiveValue&gt; separator;
2220     if (!counters)
<span class="line-modified">2221         separator = CSSPrimitiveValue::create(String(), CSSPrimitiveValue::UnitType::CSS_STRING);</span>
2222     else {
2223         if (!consumeCommaIncludingWhitespace(args) || args.peek().type() != StringToken)
2224             return nullptr;
<span class="line-modified">2225         separator = CSSPrimitiveValue::create(args.consumeIncludingWhitespace().value().toString(), CSSPrimitiveValue::UnitType::CSS_STRING);</span>
2226     }
2227 
2228     RefPtr&lt;CSSPrimitiveValue&gt; listStyle;
2229     if (consumeCommaIncludingWhitespace(args)) {
2230         CSSValueID id = args.peek().id();
2231         if ((id != CSSValueNone &amp;&amp; (id &lt; CSSValueDisc || id &gt; CSSValueKatakanaIroha)))
2232             return nullptr;
2233         listStyle = consumeIdent(args);
2234     } else
2235         listStyle = CSSValuePool::singleton().createIdentifierValue(CSSValueDecimal);
2236 
2237     if (!args.atEnd())
2238         return nullptr;
2239 
2240     // FIXME-NEWPARSER: Should just have a CSSCounterValue.
2241     return CSSValuePool::singleton().createValue(Counter::create(identifier.releaseNonNull(), listStyle.releaseNonNull(), separator.releaseNonNull()));
2242 }
2243 
2244 static RefPtr&lt;CSSValue&gt; consumeContent(CSSParserTokenRange&amp; range, CSSParserContext context)
2245 {
</pre>
<hr />
<pre>
2263                 parsedValue = consumeCounterContent(consumeFunction(range), true);
2264             if (!parsedValue)
2265                 return nullptr;
2266         }
2267         values-&gt;append(parsedValue.releaseNonNull());
2268     } while (!range.atEnd());
2269 
2270     return values;
2271 }
2272 
2273 static RefPtr&lt;CSSPrimitiveValue&gt; consumePerspective(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2274 {
2275     if (range.peek().id() == CSSValueNone)
2276         return consumeIdent(range);
2277     RefPtr&lt;CSSPrimitiveValue&gt; parsedValue = consumeLength(range, cssParserMode, ValueRangeAll);
2278     if (!parsedValue) {
2279         // FIXME: Make this quirk only apply to the webkit prefixed version of the property.
2280         double perspective;
2281         if (!consumeNumberRaw(range, perspective))
2282             return nullptr;
<span class="line-modified">2283         parsedValue = CSSPrimitiveValue::create(perspective, CSSPrimitiveValue::UnitType::CSS_PX);</span>
2284     }
<span class="line-modified">2285     if (parsedValue &amp;&amp; (parsedValue-&gt;isCalculated() || parsedValue-&gt;doubleValue() &gt; 0))</span>




2286         return parsedValue;

2287     return nullptr;
2288 }
2289 
2290 #if ENABLE(CSS_SCROLL_SNAP)
2291 
2292 static RefPtr&lt;CSSValueList&gt; consumeScrollSnapAlign(CSSParserTokenRange&amp; range)
2293 {
2294     RefPtr&lt;CSSValueList&gt; alignmentValue = CSSValueList::createSpaceSeparated();
2295     if (RefPtr&lt;CSSPrimitiveValue&gt; firstValue = consumeIdent&lt;CSSValueNone, CSSValueStart, CSSValueCenter, CSSValueEnd&gt;(range)) {
2296         alignmentValue-&gt;append(firstValue.releaseNonNull());
2297         if (auto secondValue = consumeIdent&lt;CSSValueNone, CSSValueStart, CSSValueCenter, CSSValueEnd&gt;(range))
2298             alignmentValue-&gt;append(secondValue.releaseNonNull());
2299     }
2300     return alignmentValue-&gt;length() ? alignmentValue : nullptr;
2301 }
2302 
2303 static RefPtr&lt;CSSValueList&gt; consumeScrollSnapType(CSSParserTokenRange&amp; range)
2304 {
2305     RefPtr&lt;CSSValueList&gt; typeValue = CSSValueList::createSpaceSeparated();
2306     RefPtr&lt;CSSPrimitiveValue&gt; secondValue;
2307 
2308     auto firstValue = consumeIdent&lt;CSSValueX, CSSValueY, CSSValueBlock, CSSValueInline, CSSValueBoth&gt;(range);
2309     if (firstValue)
2310         secondValue = consumeIdent&lt;CSSValueProximity, CSSValueMandatory&gt;(range);
2311     else
2312         firstValue = consumeIdent&lt;CSSValueNone, CSSValueProximity, CSSValueMandatory&gt;(range);
2313 
2314     if (!firstValue)
2315         return nullptr;
2316 
2317     typeValue-&gt;append(firstValue.releaseNonNull());
2318     if (secondValue)
2319         typeValue-&gt;append(secondValue.releaseNonNull());
2320 
2321     return typeValue;
2322 }
2323 
2324 #endif
2325 








2326 static RefPtr&lt;CSSValue&gt; consumeBorderRadiusCorner(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2327 {
2328     RefPtr&lt;CSSPrimitiveValue&gt; parsedValue1 = consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
2329     if (!parsedValue1)
2330         return nullptr;
2331     RefPtr&lt;CSSPrimitiveValue&gt; parsedValue2 = consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
2332     if (!parsedValue2)
2333         parsedValue2 = parsedValue1;
2334     return createPrimitiveValuePair(parsedValue1.releaseNonNull(), parsedValue2.releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce);
2335 }
2336 
2337 static RefPtr&lt;CSSValue&gt; consumeTextUnderlineOffset(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2338 {
2339     if (auto value = consumeIdent&lt;CSSValueAuto&gt;(range))
2340         return value;
2341     return consumeLength(range, cssParserMode, ValueRangeAll);
2342 }
2343 
2344 static RefPtr&lt;CSSValue&gt; consumeTextDecorationThickness(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2345 {
</pre>
<hr />
<pre>
2356     return parsedValue;
2357 }
2358 
2359 static RefPtr&lt;CSSPrimitiveValue&gt; consumeShapeRadius(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode)
2360 {
2361     if (identMatches&lt;CSSValueClosestSide, CSSValueFarthestSide&gt;(args.peek().id()))
2362         return consumeIdent(args);
2363     return consumeLengthOrPercent(args, cssParserMode, ValueRangeNonNegative);
2364 }
2365 
2366 static RefPtr&lt;CSSBasicShapeCircle&gt; consumeBasicShapeCircle(CSSParserTokenRange&amp; args, const CSSParserContext&amp; context)
2367 {
2368     // spec: https://drafts.csswg.org/css-shapes/#supported-basic-shapes
2369     // circle( [&lt;shape-radius&gt;]? [at &lt;position&gt;]? )
2370     RefPtr&lt;CSSBasicShapeCircle&gt; shape = CSSBasicShapeCircle::create();
2371     if (RefPtr&lt;CSSPrimitiveValue&gt; radius = consumeShapeRadius(args, context.mode))
2372         shape-&gt;setRadius(radius.releaseNonNull());
2373     if (consumeIdent&lt;CSSValueAt&gt;(args)) {
2374         RefPtr&lt;CSSPrimitiveValue&gt; centerX;
2375         RefPtr&lt;CSSPrimitiveValue&gt; centerY;
<span class="line-modified">2376         if (!consumePosition(args, context.mode, UnitlessQuirk::Forbid, centerX, centerY))</span>
2377             return nullptr;
2378         shape-&gt;setCenterX(centerX.releaseNonNull());
2379         shape-&gt;setCenterY(centerY.releaseNonNull());
2380     }
2381     return shape;
2382 }
2383 
2384 static RefPtr&lt;CSSBasicShapeEllipse&gt; consumeBasicShapeEllipse(CSSParserTokenRange&amp; args, const CSSParserContext&amp; context)
2385 {
2386     // spec: https://drafts.csswg.org/css-shapes/#supported-basic-shapes
2387     // ellipse( [&lt;shape-radius&gt;{2}]? [at &lt;position&gt;]? )
<span class="line-modified">2388     RefPtr&lt;CSSBasicShapeEllipse&gt; shape = CSSBasicShapeEllipse::create();</span>
<span class="line-modified">2389     if (RefPtr&lt;CSSPrimitiveValue&gt; radiusX = consumeShapeRadius(args, context.mode)) {</span>



2390         shape-&gt;setRadiusX(radiusX.releaseNonNull());
<span class="line-modified">2391         if (RefPtr&lt;CSSPrimitiveValue&gt; radiusY = consumeShapeRadius(args, context.mode))</span>
<span class="line-removed">2392             shape-&gt;setRadiusY(radiusY.releaseNonNull());</span>
2393     }
2394     if (consumeIdent&lt;CSSValueAt&gt;(args)) {
2395         RefPtr&lt;CSSPrimitiveValue&gt; centerX;
2396         RefPtr&lt;CSSPrimitiveValue&gt; centerY;
<span class="line-modified">2397         if (!consumePosition(args, context.mode, UnitlessQuirk::Forbid, centerX, centerY))</span>
2398             return nullptr;
2399         shape-&gt;setCenterX(centerX.releaseNonNull());
2400         shape-&gt;setCenterY(centerY.releaseNonNull());
2401     }
2402     return shape;
2403 }
2404 
2405 static RefPtr&lt;CSSBasicShapePolygon&gt; consumeBasicShapePolygon(CSSParserTokenRange&amp; args, const CSSParserContext&amp; context)
2406 {
2407     RefPtr&lt;CSSBasicShapePolygon&gt; shape = CSSBasicShapePolygon::create();
2408     if (identMatches&lt;CSSValueEvenodd, CSSValueNonzero&gt;(args.peek().id())) {
2409         shape-&gt;setWindRule(args.consumeIncludingWhitespace().id() == CSSValueEvenodd ? WindRule::EvenOdd : WindRule::NonZero);
2410         if (!consumeCommaIncludingWhitespace(args))
2411             return nullptr;
2412     }
2413 
2414     do {
2415         RefPtr&lt;CSSPrimitiveValue&gt; xLength = consumeLengthOrPercent(args, context.mode, ValueRangeAll);
2416         if (!xLength)
2417             return nullptr;
</pre>
<hr />
<pre>
2513     else if (bottom)
2514         shape-&gt;updateShapeSize3Values(top.releaseNonNull(), right.releaseNonNull(), bottom.releaseNonNull());
2515     else if (right)
2516         shape-&gt;updateShapeSize2Values(top.releaseNonNull(), right.releaseNonNull());
2517     else
2518         shape-&gt;updateShapeSize1Value(top.releaseNonNull());
2519 
2520     if (consumeIdent&lt;CSSValueRound&gt;(args)) {
2521         RefPtr&lt;CSSPrimitiveValue&gt; horizontalRadii[4] = { 0 };
2522         RefPtr&lt;CSSPrimitiveValue&gt; verticalRadii[4] = { 0 };
2523         if (!consumeRadii(horizontalRadii, verticalRadii, args, context.mode, false))
2524             return nullptr;
2525         shape-&gt;setTopLeftRadius(createPrimitiveValuePair(horizontalRadii[0].releaseNonNull(), verticalRadii[0].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce));
2526         shape-&gt;setTopRightRadius(createPrimitiveValuePair(horizontalRadii[1].releaseNonNull(), verticalRadii[1].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce));
2527         shape-&gt;setBottomRightRadius(createPrimitiveValuePair(horizontalRadii[2].releaseNonNull(), verticalRadii[2].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce));
2528         shape-&gt;setBottomLeftRadius(createPrimitiveValuePair(horizontalRadii[3].releaseNonNull(), verticalRadii[3].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce));
2529     }
2530     return shape;
2531 }
2532 
<span class="line-modified">2533 static RefPtr&lt;CSSValue&gt; consumeBasicShape(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)</span>
2534 {
<span class="line-removed">2535     RefPtr&lt;CSSValue&gt; result;</span>
2536     if (range.peek().type() != FunctionToken)
2537         return nullptr;
2538     CSSValueID id = range.peek().functionId();
2539     CSSParserTokenRange rangeCopy = range;
2540     CSSParserTokenRange args = consumeFunction(rangeCopy);
2541 
2542     // FIXME-NEWPARSER: CSSBasicShape should be a CSSValue, and shapes should not be primitive values.
2543     RefPtr&lt;CSSBasicShape&gt; shape;
2544     if (id == CSSValueCircle)
2545         shape = consumeBasicShapeCircle(args, context);
2546     else if (id == CSSValueEllipse)
2547         shape = consumeBasicShapeEllipse(args, context);
2548     else if (id == CSSValuePolygon)
2549         shape = consumeBasicShapePolygon(args, context);
2550     else if (id == CSSValueInset)
2551         shape = consumeBasicShapeInset(args, context);
2552     else if (id == CSSValuePath)
2553         shape = consumeBasicShapePath(args);
2554     if (!shape)
2555         return nullptr;
</pre>
<hr />
<pre>
2569     while (!range.atEnd() &amp;&amp; !(shapeFound &amp;&amp; boxFound)) {
2570         RefPtr&lt;CSSValue&gt; componentValue;
2571         if (range.peek().type() == FunctionToken &amp;&amp; !shapeFound) {
2572             componentValue = consumeBasicShape(range, context);
2573             shapeFound = true;
2574         } else if (range.peek().type() == IdentToken &amp;&amp; !boxFound) {
2575             componentValue = consumeIdent&lt;CSSValueContentBox, CSSValuePaddingBox, CSSValueBorderBox, CSSValueMarginBox, CSSValueFillBox, CSSValueStrokeBox, CSSValueViewBox&gt;(range);
2576             boxFound = true;
2577         }
2578         if (!componentValue)
2579             return nullptr;
2580         list-&gt;append(componentValue.releaseNonNull());
2581     }
2582 
2583     if (!range.atEnd() || !list-&gt;length())
2584         return nullptr;
2585 
2586     return list;
2587 }
2588 
<span class="line-modified">2589 static RefPtr&lt;CSSValue&gt; consumeWebkitClipPath(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)</span>
2590 {
2591     if (range.peek().id() == CSSValueNone)
2592         return consumeIdent(range);
2593     if (RefPtr&lt;CSSPrimitiveValue&gt; url = consumeUrl(range))
2594         return url;
2595     return consumeBasicShapeOrBox(range, context);
2596 }
2597 
2598 static RefPtr&lt;CSSValue&gt; consumeShapeOutside(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
2599 {
2600     if (RefPtr&lt;CSSValue&gt; imageValue = consumeImageOrNone(range, context))
2601         return imageValue;
2602     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
2603     if (RefPtr&lt;CSSValue&gt; boxValue = consumeIdent&lt;CSSValueContentBox, CSSValuePaddingBox, CSSValueBorderBox, CSSValueMarginBox&gt;(range))
2604         list-&gt;append(boxValue.releaseNonNull());
<span class="line-modified">2605     if (RefPtr&lt;CSSValue&gt; shapeValue = consumeBasicShape(range, context)) {</span>


2606         list-&gt;append(shapeValue.releaseNonNull());
2607         if (list-&gt;length() &lt; 2) {
2608             if (RefPtr&lt;CSSValue&gt; boxValue = consumeIdent&lt;CSSValueContentBox, CSSValuePaddingBox, CSSValueBorderBox, CSSValueMarginBox&gt;(range))
2609                 list-&gt;append(boxValue.releaseNonNull());
2610         }
2611     }
2612     if (!list-&gt;length())
2613         return nullptr;
2614     return list;
2615 }
2616 
2617 static bool isAuto(CSSValueID id)
2618 {
2619     return identMatches&lt;CSSValueAuto&gt;(id);
2620 }
2621 
2622 static bool isNormalOrStretch(CSSValueID id)
2623 {
2624     return identMatches&lt;CSSValueNormal, CSSValueStretch&gt;(id);
2625 }
</pre>
<hr />
<pre>
2862     RefPtr&lt;CSSValue&gt; slice;
2863     RefPtr&lt;CSSValue&gt; width;
2864     RefPtr&lt;CSSValue&gt; outset;
2865     RefPtr&lt;CSSValue&gt; repeat;
2866     if (consumeBorderImageComponents(property, range, context, source, slice, width, outset, repeat))
2867         return createBorderImageValue(WTFMove(source), WTFMove(slice), WTFMove(width), WTFMove(outset), WTFMove(repeat));
2868     return nullptr;
2869 }
2870 
2871 static RefPtr&lt;CSSValue&gt; consumeReflect(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
2872 {
2873     if (range.peek().id() == CSSValueNone)
2874         return consumeIdent(range);
2875 
2876     RefPtr&lt;CSSPrimitiveValue&gt; direction = consumeIdent&lt;CSSValueAbove, CSSValueBelow, CSSValueLeft, CSSValueRight&gt;(range);
2877     if (!direction)
2878         return nullptr;
2879 
2880     RefPtr&lt;CSSPrimitiveValue&gt; offset;
2881     if (range.atEnd())
<span class="line-modified">2882         offset = CSSValuePool::singleton().createValue(0, CSSPrimitiveValue::UnitType::CSS_PX);</span>
2883     else {
2884         offset = consumeLengthOrPercent(range, context.mode, ValueRangeAll, UnitlessQuirk::Forbid);
2885         if (!offset)
2886             return nullptr;
2887     }
2888 
2889     RefPtr&lt;CSSValue&gt; mask;
2890     if (!range.atEnd()) {
2891         mask = consumeWebkitBorderImage(CSSPropertyWebkitBoxReflect, range, context);
2892         if (!mask)
2893             return nullptr;
2894     }
2895     return CSSReflectValue::create(direction.releaseNonNull(), offset.releaseNonNull(), WTFMove(mask));
2896 }
2897 
<span class="line-removed">2898 #if ENABLE(CSS_IMAGE_ORIENTATION)</span>
<span class="line-removed">2899 static RefPtr&lt;CSSValue&gt; consumeImageOrientation(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless = UnitlessQuirk::Forbid)</span>
<span class="line-removed">2900 {</span>
<span class="line-removed">2901     if (range.peek().type() != NumberToken) {</span>
<span class="line-removed">2902         RefPtr&lt;CSSPrimitiveValue&gt; angle = consumeAngle(range, cssParserMode, unitless);</span>
<span class="line-removed">2903         if (angle &amp;&amp; angle-&gt;doubleValue() == 0)</span>
<span class="line-removed">2904             return angle;</span>
<span class="line-removed">2905     }</span>
<span class="line-removed">2906     return nullptr;</span>
<span class="line-removed">2907 }</span>
<span class="line-removed">2908 #endif</span>
<span class="line-removed">2909 </span>
2910 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBackgroundBlendMode(CSSParserTokenRange&amp; range)
2911 {
2912     CSSValueID id = range.peek().id();
2913     if (id == CSSValueNormal || id == CSSValueOverlay || (id &gt;= CSSValueMultiply &amp;&amp; id &lt;= CSSValueLuminosity))
2914         return consumeIdent(range);
2915     return nullptr;
2916 }
2917 
2918 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBackgroundAttachment(CSSParserTokenRange&amp; range)
2919 {
2920     return consumeIdent&lt;CSSValueScroll, CSSValueFixed, CSSValueLocal&gt;(range);
2921 }
2922 
2923 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBackgroundBox(CSSParserTokenRange&amp; range)
2924 {
2925     return consumeIdent&lt;CSSValueBorderBox, CSSValuePaddingBox, CSSValueContentBox, CSSValueWebkitText&gt;(range);
2926 }
2927 
2928 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBackgroundComposite(CSSParserTokenRange&amp; range)
2929 {
</pre>
<hr />
<pre>
3288             if (currentColumn != gridArea.columns.startLine())
3289                 return false;
3290 
3291             // 3. The new area ends at the same position as the previously parsed area.
3292             if (lookAheadColumn != gridArea.columns.endLine())
3293                 return false;
3294 
3295             gridArea.rows = GridSpan::translatedDefiniteGridSpan(gridArea.rows.startLine(), gridArea.rows.endLine() + 1);
3296         }
3297         currentColumn = lookAheadColumn - 1;
3298     }
3299 
3300     return true;
3301 }
3302 
3303 static RefPtr&lt;CSSPrimitiveValue&gt; consumeGridBreadth(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3304 {
3305     const CSSParserToken&amp; token = range.peek();
3306     if (identMatches&lt;CSSValueMinContent, CSSValueWebkitMinContent, CSSValueMaxContent, CSSValueWebkitMaxContent, CSSValueAuto&gt;(token.id()))
3307         return consumeIdent(range);
<span class="line-modified">3308     if (token.type() == DimensionToken &amp;&amp; token.unitType() == CSSPrimitiveValue::UnitType::CSS_FR) {</span>
3309         if (range.peek().numericValue() &lt; 0)
3310             return nullptr;
<span class="line-modified">3311         return CSSPrimitiveValue::create(range.consumeIncludingWhitespace().numericValue(), CSSPrimitiveValue::UnitType::CSS_FR);</span>
3312     }
3313     return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative, UnitlessQuirk::Allow);
3314 }
3315 
3316 static RefPtr&lt;CSSValue&gt; consumeGridTrackSize(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3317 {
3318     const CSSParserToken&amp; token = range.peek();
3319     if (identMatches&lt;CSSValueAuto&gt;(token.id()))
3320         return consumeIdent(range);
3321 
3322     if (token.functionId() == CSSValueMinmax) {
3323         CSSParserTokenRange rangeCopy = range;
3324         CSSParserTokenRange args = consumeFunction(rangeCopy);
3325         RefPtr&lt;CSSPrimitiveValue&gt; minTrackBreadth = consumeGridBreadth(args, cssParserMode);
3326         if (!minTrackBreadth || minTrackBreadth-&gt;isFlex() || !consumeCommaIncludingWhitespace(args))
3327             return nullptr;
3328         RefPtr&lt;CSSPrimitiveValue&gt; maxTrackBreadth = consumeGridBreadth(args, cssParserMode);
3329         if (!maxTrackBreadth || !args.atEnd())
3330             return nullptr;
3331         range = rangeCopy;
3332         RefPtr&lt;CSSFunctionValue&gt; result = CSSFunctionValue::create(CSSValueMinmax);
3333         result-&gt;append(minTrackBreadth.releaseNonNull());
3334         result-&gt;append(maxTrackBreadth.releaseNonNull());
3335         return result;
3336     }
3337 
3338     if (token.functionId() == CSSValueFitContent)
3339         return consumeFitContent(range, cssParserMode);
3340 
3341     return consumeGridBreadth(range, cssParserMode);
3342 }
3343 
<span class="line-modified">3344 // Appends to the passed in CSSGridLineNamesValue if any, otherwise creates a new one.</span>
3345 static RefPtr&lt;CSSGridLineNamesValue&gt; consumeGridLineNames(CSSParserTokenRange&amp; range, CSSGridLineNamesValue* lineNames = nullptr)
3346 {
3347     CSSParserTokenRange rangeCopy = range;
3348     if (rangeCopy.consumeIncludingWhitespace().type() != LeftBracketToken)
3349         return nullptr;
3350 
3351     RefPtr&lt;CSSGridLineNamesValue&gt; result = lineNames;
3352     if (!result)
3353         result = CSSGridLineNamesValue::create();
3354     while (RefPtr&lt;CSSPrimitiveValue&gt; lineName = consumeCustomIdentForGridLine(rangeCopy))
3355         result-&gt;append(lineName.releaseNonNull());
3356     if (rangeCopy.consumeIncludingWhitespace().type() != RightBracketToken)
3357         return nullptr;
3358     range = rangeCopy;
<span class="line-modified">3359     return result;</span>
3360 }
3361 
3362 static bool consumeGridTrackRepeatFunction(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, CSSValueList&amp; list, bool&amp; isAutoRepeat, bool&amp; allTracksAreFixedSized)
3363 {
3364     CSSParserTokenRange args = consumeFunction(range);
3365     // The number of repetitions for &lt;auto-repeat&gt; is not important at parsing level
3366     // because it will be computed later, let&#39;s set it to 1.
3367     size_t repetitions = 1;
3368     isAutoRepeat = identMatches&lt;CSSValueAutoFill, CSSValueAutoFit&gt;(args.peek().id());
3369     RefPtr&lt;CSSValueList&gt; repeatedValues;
3370     if (isAutoRepeat)
3371         repeatedValues = CSSGridAutoRepeatValue::create(args.consumeIncludingWhitespace().id());
3372     else {
3373         // FIXME: a consumeIntegerRaw would be more efficient here.
3374         RefPtr&lt;CSSPrimitiveValue&gt; repetition = consumePositiveInteger(args);
3375         if (!repetition)
3376             return false;
3377         repetitions = clampTo&lt;size_t&gt;(repetition-&gt;doubleValue(), 0, GridPosition::max());
3378         repeatedValues = CSSValueList::createSpaceSeparated();
3379     }
</pre>
<hr />
<pre>
3402 
3403     if (isAutoRepeat)
3404         list.append(repeatedValues.releaseNonNull());
3405     else {
3406         // We clamp the repetitions to a multiple of the repeat() track list&#39;s size, while staying below the max grid size.
3407         repetitions = std::min(repetitions, GridPosition::max() / numberOfTracks);
3408         RefPtr&lt;CSSValueList&gt; integerRepeatedValues = CSSGridIntegerRepeatValue::create(repetitions);
3409         for (size_t i = 0; i &lt; repeatedValues-&gt;length(); ++i)
3410             integerRepeatedValues-&gt;append(*repeatedValues-&gt;itemWithoutBoundsCheck(i));
3411         list.append(integerRepeatedValues.releaseNonNull());
3412     }
3413     return true;
3414 }
3415 
3416 enum TrackListType { GridTemplate, GridTemplateNoRepeat, GridAuto };
3417 
3418 static RefPtr&lt;CSSValue&gt; consumeGridTrackList(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, TrackListType trackListType)
3419 {
3420     bool allowGridLineNames = trackListType != GridAuto;
3421     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();


3422     RefPtr&lt;CSSGridLineNamesValue&gt; lineNames = consumeGridLineNames(range);
<span class="line-modified">3423     if (lineNames) {</span>
<span class="line-removed">3424         if (!allowGridLineNames)</span>
<span class="line-removed">3425             return nullptr;</span>
3426         values-&gt;append(lineNames.releaseNonNull());
<span class="line-removed">3427     }</span>
3428 
3429     bool allowRepeat = trackListType == GridTemplate;
3430     bool seenAutoRepeat = false;
3431     bool allTracksAreFixedSized = true;
3432     do {
3433         bool isAutoRepeat;
3434         if (range.peek().functionId() == CSSValueRepeat) {
3435             if (!allowRepeat)
3436                 return nullptr;
3437             if (!consumeGridTrackRepeatFunction(range, cssParserMode, *values, isAutoRepeat, allTracksAreFixedSized))
3438                 return nullptr;
3439             if (isAutoRepeat &amp;&amp; seenAutoRepeat)
3440                 return nullptr;
3441             seenAutoRepeat = seenAutoRepeat || isAutoRepeat;
3442         } else if (RefPtr&lt;CSSValue&gt; value = consumeGridTrackSize(range, cssParserMode)) {
3443             if (allTracksAreFixedSized)
3444                 allTracksAreFixedSized = isGridTrackFixedSized(*value);
3445             values-&gt;append(value.releaseNonNull());
3446         } else {
3447             return nullptr;
3448         }
3449         if (seenAutoRepeat &amp;&amp; !allTracksAreFixedSized)
3450             return nullptr;


3451         lineNames = consumeGridLineNames(range);
<span class="line-modified">3452         if (lineNames) {</span>
<span class="line-removed">3453             if (!allowGridLineNames)</span>
<span class="line-removed">3454                 return nullptr;</span>
3455             values-&gt;append(lineNames.releaseNonNull());
<span class="line-removed">3456         }</span>
3457     } while (!range.atEnd() &amp;&amp; range.peek().type() != DelimiterToken);
3458     return values;
3459 }
3460 
3461 static RefPtr&lt;CSSValue&gt; consumeGridTemplatesRowsOrColumns(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3462 {
3463     if (range.peek().id() == CSSValueNone)
3464         return consumeIdent(range);
3465     return consumeGridTrackList(range, cssParserMode, GridTemplate);
3466 }
3467 
3468 static RefPtr&lt;CSSValue&gt; consumeGridTemplateAreas(CSSParserTokenRange&amp; range)
3469 {
3470     if (range.peek().id() == CSSValueNone)
3471         return consumeIdent(range);
3472 
3473     NamedGridAreaMap gridAreaMap;
3474     size_t rowCount = 0;
3475     size_t columnCount = 0;
3476 
3477     while (range.peek().type() == StringToken) {
3478         if (!parseGridTemplateAreasRow(range.consumeIncludingWhitespace().value().toString(), gridAreaMap, rowCount, columnCount))
3479             return nullptr;
3480         ++rowCount;
3481     }
3482 
3483     if (rowCount == 0)
3484         return nullptr;
3485     ASSERT(columnCount);
3486     return CSSGridTemplateAreasValue::create(gridAreaMap, rowCount, columnCount);
3487 }
3488 
3489 static RefPtr&lt;CSSValue&gt; consumeLineBoxContain(CSSParserTokenRange&amp; range)
3490 {
3491     if (range.peek().id() == CSSValueNone)
3492         return consumeIdent(range);
3493 
<span class="line-modified">3494     LineBoxContain lineBoxContain = LineBoxContainNone;</span>
3495 
3496     while (range.peek().type() == IdentToken) {
3497         auto id = range.peek().id();
3498         if (id == CSSValueBlock) {
<span class="line-modified">3499             if (lineBoxContain &amp; LineBoxContainBlock)</span>
3500                 return nullptr;
<span class="line-modified">3501             lineBoxContain |= LineBoxContainBlock;</span>
3502         } else if (id == CSSValueInline) {
<span class="line-modified">3503             if (lineBoxContain &amp; LineBoxContainInline)</span>
3504                 return nullptr;
<span class="line-modified">3505             lineBoxContain |= LineBoxContainInline;</span>
3506         } else if (id == CSSValueFont) {
<span class="line-modified">3507             if (lineBoxContain &amp; LineBoxContainFont)</span>
3508                 return nullptr;
<span class="line-modified">3509             lineBoxContain |= LineBoxContainFont;</span>
3510         } else if (id == CSSValueGlyphs) {
<span class="line-modified">3511             if (lineBoxContain &amp; LineBoxContainGlyphs)</span>
3512                 return nullptr;
<span class="line-modified">3513             lineBoxContain |= LineBoxContainGlyphs;</span>
3514         } else if (id == CSSValueReplaced) {
<span class="line-modified">3515             if (lineBoxContain &amp; LineBoxContainReplaced)</span>
3516                 return nullptr;
<span class="line-modified">3517             lineBoxContain |= LineBoxContainReplaced;</span>
3518         } else if (id == CSSValueInlineBox) {
<span class="line-modified">3519             if (lineBoxContain &amp; LineBoxContainInlineBox)</span>
3520                 return nullptr;
<span class="line-modified">3521             lineBoxContain |= LineBoxContainInlineBox;</span>
3522         } else if (id == CSSValueInitialLetter) {
<span class="line-modified">3523             if (lineBoxContain &amp; LineBoxContainInitialLetter)</span>
3524                 return nullptr;
<span class="line-modified">3525             lineBoxContain |= LineBoxContainInitialLetter;</span>
3526         } else
3527             return nullptr;
3528         range.consumeIncludingWhitespace();
3529     }
3530 
3531     if (!lineBoxContain)
3532         return nullptr;
3533 
3534     return CSSLineBoxContainValue::create(lineBoxContain);
3535 }
3536 
3537 static RefPtr&lt;CSSValue&gt; consumeLineGrid(CSSParserTokenRange&amp; range)
3538 {
3539     if (range.peek().id() == CSSValueNone)
3540         return consumeIdent(range);
3541     return consumeCustomIdent(range);
3542 }
3543 
3544 static RefPtr&lt;CSSValue&gt; consumeInitialLetter(CSSParserTokenRange&amp; range)
3545 {
</pre>
<hr />
<pre>
3636         case CSSValueForceEnd:
3637             seenForceEnd = true;
3638             break;
3639         case CSSValueFirst:
3640             seenFirst = true;
3641             break;
3642         case CSSValueLast:
3643             seenLast = true;
3644             break;
3645         default:
3646             break;
3647         }
3648         list-&gt;append(ident.releaseNonNull());
3649     }
3650 
3651     return list-&gt;length() ? list : nullptr;
3652 }
3653 
3654 static RefPtr&lt;CSSValue&gt; consumeWebkitMarqueeIncrement(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3655 {
<span class="line-removed">3656     if (range.peek().type() == IdentToken)</span>
<span class="line-removed">3657         return consumeIdent&lt;CSSValueSmall, CSSValueMedium, CSSValueLarge&gt;(range);</span>
3658     return consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
3659 }
3660 
3661 static RefPtr&lt;CSSValue&gt; consumeWebkitMarqueeRepetition(CSSParserTokenRange&amp; range)
3662 {
<span class="line-removed">3663     if (range.peek().type() == IdentToken)</span>
<span class="line-removed">3664         return consumeIdent&lt;CSSValueInfinite&gt;(range);</span>
3665     return consumeNumber(range, ValueRangeNonNegative);
3666 }
3667 
3668 static RefPtr&lt;CSSValue&gt; consumeWebkitMarqueeSpeed(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3669 {
<span class="line-removed">3670     if (range.peek().type() == IdentToken)</span>
<span class="line-removed">3671         return consumeIdent&lt;CSSValueSlow, CSSValueNormal, CSSValueFast&gt;(range);</span>
3672     return consumeTime(range, cssParserMode, ValueRangeNonNegative, UnitlessQuirk::Allow);
3673 }
3674 
3675 static RefPtr&lt;CSSValue&gt; consumeAlt(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
3676 {
3677     if (range.peek().type() == StringToken)
3678         return consumeString(range);
3679 
3680     if (range.peek().functionId() != CSSValueAttr)
3681         return nullptr;
3682 
3683     return consumeAttr(consumeFunction(range), context);
3684 }
3685 
3686 static RefPtr&lt;CSSValue&gt; consumeWebkitAspectRatio(CSSParserTokenRange&amp; range)
3687 {
3688     if (range.peek().type() == IdentToken)
3689         return consumeIdent&lt;CSSValueAuto, CSSValueFromDimensions, CSSValueFromIntrinsic&gt;(range);
3690 
3691     RefPtr&lt;CSSPrimitiveValue&gt; leftValue = consumeNumber(range, ValueRangeNonNegative);
<span class="line-modified">3692     if (!leftValue || !leftValue-&gt;floatValue() || range.atEnd() || !consumeSlashIncludingWhitespace(range))</span>
3693         return nullptr;

3694     RefPtr&lt;CSSPrimitiveValue&gt; rightValue = consumeNumber(range, ValueRangeNonNegative);
<span class="line-modified">3695     if (!rightValue || !rightValue-&gt;floatValue())</span>
3696         return nullptr;
3697 
3698     return CSSAspectRatioValue::create(leftValue-&gt;floatValue(), rightValue-&gt;floatValue());
3699 }
3700 
3701 static RefPtr&lt;CSSValue&gt; consumeTextEmphasisPosition(CSSParserTokenRange&amp; range)
3702 {
3703     bool foundOverOrUnder = false;
3704     CSSValueID overUnderValueID = CSSValueOver;
3705     bool foundLeftOrRight = false;
3706     CSSValueID leftRightValueID = CSSValueRight;
3707     while (!range.atEnd()) {
3708         switch (range.peek().id()) {
3709         case CSSValueOver:
3710             if (foundOverOrUnder)
3711                 return nullptr;
3712             foundOverOrUnder = true;
3713             overUnderValueID = CSSValueOver;
3714             break;
3715         case CSSValueUnder:
</pre>
<hr />
<pre>
3905     case CSSPropertyPaddingInlineEnd:
3906     case CSSPropertyPaddingBlockStart:
3907     case CSSPropertyPaddingBlockEnd:
3908         return consumeLengthOrPercent(m_range, m_context.mode, ValueRangeNonNegative, UnitlessQuirk::Forbid);
3909 #if ENABLE(CSS_SCROLL_SNAP)
3910     case CSSPropertyScrollSnapMarginBottom:
3911     case CSSPropertyScrollSnapMarginLeft:
3912     case CSSPropertyScrollSnapMarginRight:
3913     case CSSPropertyScrollSnapMarginTop:
3914         return consumeLength(m_range, m_context.mode, ValueRangeAll);
3915     case CSSPropertyScrollPaddingBottom:
3916     case CSSPropertyScrollPaddingLeft:
3917     case CSSPropertyScrollPaddingRight:
3918     case CSSPropertyScrollPaddingTop:
3919         return consumeLengthOrPercent(m_range, m_context.mode, ValueRangeAll);
3920     case CSSPropertyScrollSnapAlign:
3921         return consumeScrollSnapAlign(m_range);
3922     case CSSPropertyScrollSnapType:
3923         return consumeScrollSnapType(m_range);
3924 #endif




3925     case CSSPropertyClip:
3926         return consumeClip(m_range, m_context.mode);
3927 #if ENABLE(POINTER_EVENTS)
3928     case CSSPropertyTouchAction:
3929         return consumeTouchAction(m_range);
3930 #endif
3931     case CSSPropertyObjectPosition:
<span class="line-modified">3932         return consumePosition(m_range, m_context.mode, UnitlessQuirk::Forbid);</span>
3933     case CSSPropertyWebkitLineClamp:
3934         return consumeLineClamp(m_range);
3935     case CSSPropertyWebkitFontSizeDelta:
3936         return consumeLength(m_range, m_context.mode, ValueRangeAll, UnitlessQuirk::Allow);
3937     case CSSPropertyWebkitHyphenateCharacter:
3938     case CSSPropertyWebkitLocale:
3939         return consumeAutoOrString(m_range);
3940     case CSSPropertyWebkitHyphenateLimitBefore:
3941     case CSSPropertyWebkitHyphenateLimitAfter:
3942         return consumeHyphenateLimit(m_range, CSSValueAuto);
3943     case CSSPropertyWebkitHyphenateLimitLines:
3944         return consumeHyphenateLimit(m_range, CSSValueNoLimit);
3945     case CSSPropertyColumnWidth:
3946         return consumeColumnWidth(m_range);
3947     case CSSPropertyColumnCount:
3948         return consumeColumnCount(m_range);
3949     case CSSPropertyColumnGap:
3950         return consumeGapLength(m_range, m_context.mode);
3951     case CSSPropertyRowGap:
3952         return consumeGapLength(m_range, m_context.mode);
</pre>
<hr />
<pre>
4037         return consumeFilter(m_range, m_context, AllowedFilterFunctions::PixelFilters);
4038     case CSSPropertyAppleColorFilter:
4039         if (!m_context.colorFilterEnabled)
4040             return nullptr;
4041         return consumeFilter(m_range, m_context, AllowedFilterFunctions::ColorFilters);
4042     case CSSPropertyTextDecoration:
4043     case CSSPropertyWebkitTextDecorationsInEffect:
4044     case CSSPropertyTextDecorationLine:
4045         return consumeTextDecorationLine(m_range);
4046     case CSSPropertyWebkitTextEmphasisStyle:
4047         return consumeTextEmphasisStyle(m_range);
4048     case CSSPropertyOutlineColor:
4049         return consumeOutlineColor(m_range, m_context.mode);
4050     case CSSPropertyOutlineOffset:
4051         return consumeLength(m_range, m_context.mode, ValueRangeAll);
4052     case CSSPropertyOutlineWidth:
4053         return consumeLineWidth(m_range, m_context.mode, UnitlessQuirk::Forbid);
4054     case CSSPropertyTransform:
4055         return consumeTransform(m_range, m_context.mode);
4056     case CSSPropertyTransformBox:
<span class="line-modified">4057         return consumeIdent&lt;CSSValueBorderBox, CSSValueViewBox, CSSValueFillBox&gt;(m_range);</span>
4058     case CSSPropertyTransformOriginX:
4059     case CSSPropertyPerspectiveOriginX:
4060         return consumePositionX(m_range, m_context.mode);
4061     case CSSPropertyTransformOriginY:
4062     case CSSPropertyPerspectiveOriginY:
4063         return consumePositionY(m_range, m_context.mode);
4064     case CSSPropertyTransformOriginZ:
4065         return consumeLength(m_range, m_context.mode, ValueRangeAll);
4066     case CSSPropertyFill:
4067     case CSSPropertyStroke:
4068         return consumePaintStroke(m_range, m_context.mode);
4069     case CSSPropertyGlyphOrientationVertical:
4070     case CSSPropertyGlyphOrientationHorizontal:
4071         return consumeGlyphOrientation(m_range, m_context.mode, property);
4072     case CSSPropertyPaintOrder:
4073         return consumePaintOrder(m_range);
4074     case CSSPropertyMarkerStart:
4075     case CSSPropertyMarkerMid:
4076     case CSSPropertyMarkerEnd:
<span class="line-removed">4077     case CSSPropertyClipPath:</span>
4078     case CSSPropertyMask:
4079         return consumeNoneOrURI(m_range);
4080     case CSSPropertyFlexBasis:
4081         return consumeFlexBasis(m_range, m_context.mode);
4082     case CSSPropertyFlexGrow:
4083     case CSSPropertyFlexShrink:
4084         return consumeNumber(m_range, ValueRangeNonNegative);
4085     case CSSPropertyStrokeDasharray:
4086         return consumeStrokeDasharray(m_range);
4087     case CSSPropertyColumnRuleWidth:
4088         return consumeColumnRuleWidth(m_range, m_context.mode);
4089     case CSSPropertyStrokeOpacity:
4090     case CSSPropertyFillOpacity:
4091     case CSSPropertyStopOpacity:
4092     case CSSPropertyFloodOpacity:
4093     case CSSPropertyOpacity:






4094     case CSSPropertyWebkitBoxFlex:
4095         return consumeNumber(m_range, ValueRangeAll);
4096     case CSSPropertyBaselineShift:
4097         return consumeBaselineShift(m_range);
4098     case CSSPropertyKerning:
4099         return consumeKerning(m_range, m_context.mode);
4100     case CSSPropertyStrokeMiterlimit:
4101         return consumeNumber(m_range, ValueRangeNonNegative);
4102     case CSSPropertyStrokeWidth:
4103     case CSSPropertyStrokeDashoffset:
4104     case CSSPropertyCx:
4105     case CSSPropertyCy:
4106     case CSSPropertyX:
4107     case CSSPropertyY:
<span class="line-removed">4108     case CSSPropertyR:</span>
4109         return consumeLengthOrPercent(m_range, SVGAttributeMode, ValueRangeAll, UnitlessQuirk::Forbid);


4110     case CSSPropertyRx:
4111     case CSSPropertyRy:
<span class="line-modified">4112         return consumeRxOrRy(m_range);</span>
4113     case CSSPropertyCursor:
4114         return consumeCursor(m_range, m_context, inQuirksMode());
4115     case CSSPropertyContent:
4116         return consumeContent(m_range, m_context);
4117     case CSSPropertyListStyleImage:
4118     case CSSPropertyBorderImageSource:
4119     case CSSPropertyWebkitMaskBoxImageSource:
4120         return consumeImageOrNone(m_range, m_context);
4121     case CSSPropertyPerspective:
4122         return consumePerspective(m_range, m_context.mode);
4123     case CSSPropertyBorderTopRightRadius:
4124     case CSSPropertyBorderTopLeftRadius:
4125     case CSSPropertyBorderBottomLeftRadius:
4126     case CSSPropertyBorderBottomRightRadius:
4127         return consumeBorderRadiusCorner(m_range, m_context.mode);
4128     case CSSPropertyWebkitBoxFlexGroup:
4129         return consumeInteger(m_range, 0);
4130     case CSSPropertyOrder:
4131         return consumeInteger(m_range);
4132     case CSSPropertyTextUnderlinePosition:
4133         // auto | [ [ under | from-font ] || [ left | right ] ], but we only support auto | under | from-font for now
4134         return consumeIdent&lt;CSSValueAuto, CSSValueUnder, CSSValueFromFont&gt;(m_range);
4135     case CSSPropertyTextUnderlineOffset:
4136         return consumeTextUnderlineOffset(m_range, m_context.mode);
4137     case CSSPropertyTextDecorationThickness:
4138         return consumeTextDecorationThickness(m_range, m_context.mode);
4139     case CSSPropertyVerticalAlign:
4140         return consumeVerticalAlign(m_range, m_context.mode);
4141     case CSSPropertyShapeOutside:
4142         return consumeShapeOutside(m_range, m_context);
<span class="line-modified">4143     case CSSPropertyWebkitClipPath:</span>
<span class="line-modified">4144         return consumeWebkitClipPath(m_range, m_context);</span>
4145     case CSSPropertyJustifyContent:
4146         // justify-content property does not allow the &lt;baseline-position&gt; values.
4147         if (isBaselineKeyword(m_range.peek().id()))
4148             return nullptr;
4149         return consumeContentDistributionOverflowPosition(m_range, isContentPositionOrLeftOrRightKeyword);
4150     case CSSPropertyAlignContent:
4151         return consumeContentDistributionOverflowPosition(m_range, isContentPositionKeyword);
4152     case CSSPropertyBorderImageRepeat:
4153     case CSSPropertyWebkitMaskBoxImageRepeat:
4154         return consumeBorderImageRepeat(m_range);
4155     case CSSPropertyBorderImageSlice:
4156     case CSSPropertyWebkitMaskBoxImageSlice:
4157         return consumeBorderImageSlice(property, m_range);
4158     case CSSPropertyBorderImageOutset:
4159     case CSSPropertyWebkitMaskBoxImageOutset:
4160         return consumeBorderImageOutset(m_range);
4161     case CSSPropertyBorderImageWidth:
4162     case CSSPropertyWebkitMaskBoxImageWidth:
4163         return consumeBorderImageWidth(m_range);
4164     case CSSPropertyWebkitBorderImage:
4165     case CSSPropertyWebkitMaskBoxImage:
4166         return consumeWebkitBorderImage(property, m_range, m_context);
4167     case CSSPropertyWebkitBoxReflect:
4168         return consumeReflect(m_range, m_context);
4169     case CSSPropertyWebkitLineBoxContain:
4170         return consumeLineBoxContain(m_range);
<span class="line-removed">4171 #if ENABLE(CSS_IMAGE_ORIENTATION)</span>
<span class="line-removed">4172     case CSSPropertyImageOrientation:</span>
<span class="line-removed">4173         return consumeImageOrientation(m_range, m_context.mode);</span>
<span class="line-removed">4174 #endif</span>
4175     case CSSPropertyBackgroundAttachment:
4176     case CSSPropertyBackgroundBlendMode:
4177     case CSSPropertyBackgroundClip:
4178     case CSSPropertyBackgroundImage:
4179     case CSSPropertyBackgroundOrigin:
4180     case CSSPropertyBackgroundPositionX:
4181     case CSSPropertyBackgroundPositionY:
4182     case CSSPropertyBackgroundSize:
4183     case CSSPropertyWebkitBackgroundClip:
4184     case CSSPropertyWebkitBackgroundOrigin:
4185     case CSSPropertyWebkitBackgroundComposite:
4186     case CSSPropertyWebkitBackgroundSize:
4187     case CSSPropertyWebkitMaskClip:
4188     case CSSPropertyWebkitMaskComposite:
4189     case CSSPropertyWebkitMaskImage:
4190     case CSSPropertyWebkitMaskOrigin:
4191     case CSSPropertyWebkitMaskPositionX:
4192     case CSSPropertyWebkitMaskPositionY:
4193     case CSSPropertyWebkitMaskSize:
4194     case CSSPropertyWebkitMaskSourceType:
</pre>
<hr />
<pre>
4272     }
4273 
4274     return true;
4275 }
4276 
4277 void CSSPropertyParser::collectParsedCustomPropertyValueDependencies(const String&amp; syntax, bool isRoot, HashSet&lt;CSSPropertyID&gt;&amp; dependencies)
4278 {
4279     if (syntax != &quot;*&quot;) {
4280         m_range.consumeWhitespace();
4281         auto primitiveVal = consumeWidthOrHeight(m_range, m_context);
4282         if (!m_range.atEnd())
4283             return;
4284         if (primitiveVal &amp;&amp; primitiveVal-&gt;isPrimitiveValue()) {
4285             primitiveVal-&gt;collectDirectComputationalDependencies(dependencies);
4286             if (isRoot)
4287                 primitiveVal-&gt;collectDirectRootComputationalDependencies(dependencies);
4288         }
4289     }
4290 }
4291 
<span class="line-modified">4292 RefPtr&lt;CSSCustomPropertyValue&gt; CSSPropertyParser::parseTypedCustomPropertyValue(const String&amp; name, const String&amp; syntax, const StyleResolver&amp; styleResolver)</span>
4293 {
4294     if (syntax != &quot;*&quot;) {
4295         m_range.consumeWhitespace();
4296         auto primitiveVal = consumeWidthOrHeight(m_range, m_context);
4297         if (primitiveVal &amp;&amp; primitiveVal-&gt;isPrimitiveValue() &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(*primitiveVal).isLength()) {
<span class="line-modified">4298             auto length = StyleBuilderConverter::convertLength(styleResolver, *primitiveVal);</span>
4299             if (!length.isCalculated() &amp;&amp; !length.isUndefined())
4300                 return CSSCustomPropertyValue::createSyntaxLength(name, WTFMove(length));
4301         }
4302     } else {
4303         auto propertyValue = CSSCustomPropertyValue::createSyntaxAll(name, CSSVariableData::create(m_range));
4304         while (!m_range.atEnd())
4305             m_range.consume();
4306         return { WTFMove(propertyValue) };
4307     }
4308 
4309     return nullptr;
4310 }
4311 
4312 static RefPtr&lt;CSSValueList&gt; consumeFontFaceUnicodeRange(CSSParserTokenRange&amp; range)
4313 {
4314     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createCommaSeparated();
4315 
4316     do {
4317         const CSSParserToken&amp; token = range.consumeIncludingWhitespace();
4318         if (token.type() != UnicodeRangeToken)
</pre>
<hr />
<pre>
4461         return false;
4462 
4463     addProperty(propId, CSSPropertyInvalid, *parsedValue, false);
4464     return true;
4465 }
4466 
4467 bool CSSPropertyParser::consumeSystemFont(bool important)
4468 {
4469     CSSValueID systemFontID = m_range.consumeIncludingWhitespace().id();
4470     ASSERT(systemFontID &gt;= CSSValueCaption &amp;&amp; systemFontID &lt;= CSSValueStatusBar);
4471     if (!m_range.atEnd())
4472         return false;
4473 
4474     FontCascadeDescription fontDescription;
4475     RenderTheme::singleton().systemFont(systemFontID, fontDescription);
4476     if (!fontDescription.isAbsoluteSize())
4477         return false;
4478 
4479     addProperty(CSSPropertyFontStyle, CSSPropertyFont, CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(isItalic(fontDescription.italic()) ? CSSValueItalic : CSSValueNormal)), important);
4480     addProperty(CSSPropertyFontWeight, CSSPropertyFont, CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(fontDescription.weight())), important);
<span class="line-modified">4481     addProperty(CSSPropertyFontSize, CSSPropertyFont, CSSValuePool::singleton().createValue(fontDescription.specifiedSize(), CSSPrimitiveValue::CSS_PX), important);</span>
4482     Ref&lt;CSSValueList&gt; fontFamilyList = CSSValueList::createCommaSeparated();
4483     fontFamilyList-&gt;append(CSSValuePool::singleton().createFontFamilyValue(fontDescription.familyAt(0), FromSystemFontID::Yes));
4484     addProperty(CSSPropertyFontFamily, CSSPropertyFont, WTFMove(fontFamilyList), important);
4485     addProperty(CSSPropertyFontVariantCaps, CSSPropertyFont, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4486     addProperty(CSSPropertyLineHeight, CSSPropertyFont, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4487 
4488     // FIXME_NEWPARSER: What about FontVariantNumeric and FontVariantLigatures?
4489 
4490     return true;
4491 }
4492 
4493 bool CSSPropertyParser::consumeFont(bool important)
4494 {
4495     // Let&#39;s check if there is an inherit or initial somewhere in the shorthand.
4496     CSSParserTokenRange range = m_range;
4497     while (!range.atEnd()) {
4498         CSSValueID id = range.consumeIncludingWhitespace().id();
4499         if (id == CSSValueInherit || id == CSSValueInitial)
4500             return false;
4501     }
</pre>
<hr />
<pre>
4830     double flexShrink = unsetValue;
4831     RefPtr&lt;CSSPrimitiveValue&gt; flexBasis;
4832 
4833     if (m_range.peek().id() == CSSValueNone) {
4834         flexGrow = 0;
4835         flexShrink = 0;
4836         flexBasis = CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
4837         m_range.consumeIncludingWhitespace();
4838     } else {
4839         unsigned index = 0;
4840         while (!m_range.atEnd() &amp;&amp; index++ &lt; 3) {
4841             double num;
4842             if (consumeNumberRaw(m_range, num)) {
4843                 if (num &lt; 0)
4844                     return false;
4845                 if (flexGrow == unsetValue)
4846                     flexGrow = num;
4847                 else if (flexShrink == unsetValue)
4848                     flexShrink = num;
4849                 else if (!num) // flex only allows a basis of 0 (sans units) if flex-grow and flex-shrink values have already been set.
<span class="line-modified">4850                     flexBasis = CSSPrimitiveValue::create(0, CSSPrimitiveValue::UnitType::CSS_PX);</span>
4851                 else
4852                     return false;
4853             } else if (!flexBasis) {
4854                 if (m_range.peek().id() == CSSValueAuto)
4855                     flexBasis = consumeIdent(m_range);
4856                 if (!flexBasis)
4857                     flexBasis = consumeLengthOrPercent(m_range, m_context.mode, ValueRangeNonNegative);
4858                 if (index == 2 &amp;&amp; !m_range.atEnd())
4859                     return false;
4860             }
4861         }
4862         if (index == 0)
4863             return false;
4864         if (flexGrow == unsetValue)
4865             flexGrow = 1;
4866         if (flexShrink == unsetValue)
4867             flexShrink = 1;
4868 
4869         // FIXME: Using % here is a hack to work around intrinsic sizing implementation being
4870         // a mess (e.g., turned off for nested column flexboxes, failing to relayout properly even
4871         // if turned back on for nested columns, etc.). We have layout test coverage of both
4872         // scenarios.
4873         if (!flexBasis)
<span class="line-modified">4874             flexBasis = CSSPrimitiveValue::create(0, CSSPrimitiveValue::UnitType::CSS_PERCENTAGE);</span>
4875     }
4876 
4877     if (!m_range.atEnd())
4878         return false;
<span class="line-modified">4879     addProperty(CSSPropertyFlexGrow, CSSPropertyFlex, CSSPrimitiveValue::create(clampTo&lt;float&gt;(flexGrow), CSSPrimitiveValue::UnitType::CSS_NUMBER), important);</span>
<span class="line-modified">4880     addProperty(CSSPropertyFlexShrink, CSSPropertyFlex, CSSPrimitiveValue::create(clampTo&lt;float&gt;(flexShrink), CSSPrimitiveValue::UnitType::CSS_NUMBER), important);</span>
4881     addProperty(CSSPropertyFlexBasis, CSSPropertyFlex, flexBasis.releaseNonNull(), important);
4882     return true;
4883 }
4884 
4885 bool CSSPropertyParser::consumeBorder(RefPtr&lt;CSSValue&gt;&amp; width, RefPtr&lt;CSSValue&gt;&amp; style, RefPtr&lt;CSSValue&gt;&amp; color)
4886 {
4887     while (!width || !style || !color) {
4888         if (!width) {
4889             width = consumeLineWidth(m_range, m_context.mode, UnitlessQuirk::Forbid);
4890             if (width)
4891                 continue;
4892         }
4893         if (!style) {
4894             style = parseSingleValue(CSSPropertyBorderLeftStyle, CSSPropertyBorder);
4895             if (style)
4896                 continue;
4897         }
4898         if (!color) {
4899             color = consumeColor(m_range, m_context.mode);
4900             if (color)
</pre>
<hr />
<pre>
5072     case CSSPropertyPageBreakInside:
5073     case CSSPropertyWebkitColumnBreakInside:
5074         value = mapFromColumnRegionOrPageBreakInside(value);
5075         break;
5076     default:
5077         ASSERT_NOT_REACHED();
5078     }
5079     if (value == CSSValueInvalid)
5080         return false;
5081 
5082     CSSPropertyID genericBreakProperty = mapFromLegacyBreakProperty(property);
5083     addProperty(genericBreakProperty, property, CSSValuePool::singleton().createIdentifierValue(value), important);
5084     return true;
5085 }
5086 
5087 static bool consumeBackgroundPosition(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, UnitlessQuirk unitless, RefPtr&lt;CSSValue&gt;&amp; resultX, RefPtr&lt;CSSValue&gt;&amp; resultY)
5088 {
5089     do {
5090         RefPtr&lt;CSSPrimitiveValue&gt; positionX;
5091         RefPtr&lt;CSSPrimitiveValue&gt; positionY;
<span class="line-modified">5092         if (!consumePosition(range, context.mode, unitless, positionX, positionY))</span>
5093             return false;
5094         addBackgroundValue(resultX, positionX.releaseNonNull());
5095         addBackgroundValue(resultY, positionY.releaseNonNull());
5096     } while (consumeCommaIncludingWhitespace(range));
5097     return true;
5098 }
5099 
5100 static bool consumeRepeatStyleComponent(CSSParserTokenRange&amp; range, RefPtr&lt;CSSPrimitiveValue&gt;&amp; value1, RefPtr&lt;CSSPrimitiveValue&gt;&amp; value2, bool&amp; implicit)
5101 {
5102     if (consumeIdent&lt;CSSValueRepeatX&gt;(range)) {
5103         value1 = CSSValuePool::singleton().createIdentifierValue(CSSValueRepeat);
5104         value2 = CSSValuePool::singleton().createIdentifierValue(CSSValueNoRepeat);
5105         implicit = true;
5106         return true;
5107     }
5108     if (consumeIdent&lt;CSSValueRepeatY&gt;(range)) {
5109         value1 = CSSValuePool::singleton().createIdentifierValue(CSSValueNoRepeat);
5110         value2 = CSSValuePool::singleton().createIdentifierValue(CSSValueRepeat);
5111         implicit = true;
5112         return true;
</pre>
<hr />
<pre>
5150         RefPtr&lt;CSSValue&gt; originValue;
5151         do {
5152             bool foundProperty = false;
5153             for (size_t i = 0; i &lt; longhandCount; ++i) {
5154                 if (parsedLonghand[i])
5155                     continue;
5156 
5157                 RefPtr&lt;CSSValue&gt; value;
5158                 RefPtr&lt;CSSValue&gt; valueY;
5159                 CSSPropertyID property = shorthand.properties()[i];
5160                 if (property == CSSPropertyBackgroundRepeatX || property == CSSPropertyWebkitMaskRepeatX) {
5161                     RefPtr&lt;CSSPrimitiveValue&gt; primitiveValue;
5162                     RefPtr&lt;CSSPrimitiveValue&gt; primitiveValueY;
5163                     consumeRepeatStyleComponent(m_range, primitiveValue, primitiveValueY, implicit);
5164                     value = primitiveValue;
5165                     valueY = primitiveValueY;
5166                 } else if (property == CSSPropertyBackgroundPositionX || property == CSSPropertyWebkitMaskPositionX) {
5167                     CSSParserTokenRange rangeCopy = m_range;
5168                     RefPtr&lt;CSSPrimitiveValue&gt; primitiveValue;
5169                     RefPtr&lt;CSSPrimitiveValue&gt; primitiveValueY;
<span class="line-modified">5170                     if (!consumePosition(rangeCopy, m_context.mode, UnitlessQuirk::Forbid, primitiveValue, primitiveValueY))</span>
5171                         continue;
5172                     value = primitiveValue;
5173                     valueY = primitiveValueY;
5174                     m_range = rangeCopy;
5175                 } else if (property == CSSPropertyBackgroundSize || property == CSSPropertyWebkitMaskSize) {
5176                     if (!consumeSlashIncludingWhitespace(m_range))
5177                         continue;
5178                     value = consumeBackgroundSize(property, m_range, m_context.mode);
5179                     if (!value || !parsedLonghand[i - 1]) // Position must have been parsed in the current layer.
5180                         return false;
5181                 } else if (property == CSSPropertyBackgroundPositionY || property == CSSPropertyBackgroundRepeatY
5182                     || property == CSSPropertyWebkitMaskPositionY || property == CSSPropertyWebkitMaskRepeatY) {
5183                     continue;
5184                 } else {
5185                     value = consumeBackgroundComponent(property, m_range, m_context);
5186                 }
5187                 if (value) {
5188                     if (property == CSSPropertyBackgroundOrigin || property == CSSPropertyWebkitMaskOrigin)
5189                         originValue = value;
5190                     parsedLonghand[i] = true;
</pre>
<hr />
<pre>
5211             if ((property == CSSPropertyBackgroundClip || property == CSSPropertyWebkitMaskClip) &amp;&amp; !parsedLonghand[i] &amp;&amp; originValue) {
5212                 addBackgroundValue(longhands[i], originValue.releaseNonNull());
5213                 continue;
5214             }
5215             if (!parsedLonghand[i])
5216                 addBackgroundValue(longhands[i], CSSValuePool::singleton().createImplicitInitialValue());
5217         }
5218     } while (consumeCommaIncludingWhitespace(m_range));
5219     if (!m_range.atEnd())
5220         return false;
5221 
5222     for (size_t i = 0; i &lt; longhandCount; ++i) {
5223         CSSPropertyID property = shorthand.properties()[i];
5224         if (property == CSSPropertyBackgroundSize &amp;&amp; longhands[i] &amp;&amp; m_context.useLegacyBackgroundSizeShorthandBehavior)
5225             continue;
5226         addProperty(property, shorthand.id(), *longhands[i], important, implicit);
5227     }
5228     return true;
5229 }
5230 





























5231 // FIXME-NEWPARSER: Hack to work around the fact that we aren&#39;t using CSSCustomIdentValue
5232 // for stuff yet. This can be replaced by CSSValue::isCustomIdentValue() once we switch
5233 // to using CSSCustomIdentValue everywhere.
5234 static bool isCustomIdentValue(const CSSValue&amp; value)
5235 {
5236     return is&lt;CSSPrimitiveValue&gt;(value) &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(value).isString();
5237 }
5238 
5239 bool CSSPropertyParser::consumeGridItemPositionShorthand(CSSPropertyID shorthandId, bool important)
5240 {
5241     const StylePropertyShorthand&amp; shorthand = shorthandForProperty(shorthandId);
5242     ASSERT(shorthand.length() == 2);
5243     RefPtr&lt;CSSValue&gt; startValue = consumeGridLine(m_range);
5244     if (!startValue)
5245         return false;
5246 
5247     RefPtr&lt;CSSValue&gt; endValue;
5248     if (consumeSlashIncludingWhitespace(m_range)) {
5249         endValue = consumeGridLine(m_range);
5250         if (!endValue)
</pre>
<hr />
<pre>
5570 }
5571 
5572 bool CSSPropertyParser::parseShorthand(CSSPropertyID property, bool important)
5573 {
5574     switch (property) {
5575     case CSSPropertyWebkitMarginCollapse: {
5576         CSSValueID id = m_range.consumeIncludingWhitespace().id();
5577         if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyWebkitMarginBeforeCollapse, id, m_context))
5578             return false;
5579         addProperty(CSSPropertyWebkitMarginBeforeCollapse, CSSPropertyWebkitMarginCollapse, CSSValuePool::singleton().createIdentifierValue(id), important);
5580         if (m_range.atEnd()) {
5581             addProperty(CSSPropertyWebkitMarginAfterCollapse, CSSPropertyWebkitMarginCollapse, CSSValuePool::singleton().createIdentifierValue(id), important);
5582             return true;
5583         }
5584         id = m_range.consumeIncludingWhitespace().id();
5585         if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyWebkitMarginAfterCollapse, id, m_context))
5586             return false;
5587         addProperty(CSSPropertyWebkitMarginAfterCollapse, CSSPropertyWebkitMarginCollapse, CSSValuePool::singleton().createIdentifierValue(id), important);
5588         return true;
5589     }
<span class="line-modified">5590     case CSSPropertyOverflow: {</span>
<span class="line-modified">5591         CSSValueID id = m_range.consumeIncludingWhitespace().id();</span>
<span class="line-removed">5592         if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyOverflowY, id, m_context))</span>
<span class="line-removed">5593             return false;</span>
<span class="line-removed">5594         if (!m_range.atEnd())</span>
<span class="line-removed">5595             return false;</span>
<span class="line-removed">5596         RefPtr&lt;CSSValue&gt; overflowYValue = CSSValuePool::singleton().createIdentifierValue(id);</span>
<span class="line-removed">5597         RefPtr&lt;CSSValue&gt; overflowXValue;</span>
<span class="line-removed">5598 </span>
<span class="line-removed">5599         // FIXME: -webkit-paged-x or -webkit-paged-y only apply to overflow-y. If this value has been</span>
<span class="line-removed">5600         // set using the shorthand, then for now overflow-x will default to auto, but once we implement</span>
<span class="line-removed">5601         // pagination controls, it should default to hidden. If the overflow-y value is anything but</span>
<span class="line-removed">5602         // paged-x or paged-y, then overflow-x and overflow-y should have the same value.</span>
<span class="line-removed">5603         if (id == CSSValueWebkitPagedX || id == CSSValueWebkitPagedY)</span>
<span class="line-removed">5604             overflowXValue = CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);</span>
<span class="line-removed">5605         else</span>
<span class="line-removed">5606             overflowXValue = overflowYValue;</span>
<span class="line-removed">5607         addProperty(CSSPropertyOverflowX, CSSPropertyOverflow, *overflowXValue, important);</span>
<span class="line-removed">5608         addProperty(CSSPropertyOverflowY, CSSPropertyOverflow, *overflowYValue, important);</span>
<span class="line-removed">5609         return true;</span>
<span class="line-removed">5610     }</span>
5611     case CSSPropertyFont: {
5612         const CSSParserToken&amp; token = m_range.peek();
5613         if (token.id() &gt;= CSSValueCaption &amp;&amp; token.id() &lt;= CSSValueStatusBar)
5614             return consumeSystemFont(important);
5615         return consumeFont(important);
5616     }
5617     case CSSPropertyFontVariant:
5618         return consumeFontVariantShorthand(important);
5619     case CSSPropertyBorderSpacing:
5620         return consumeBorderSpacing(important);
5621     case CSSPropertyColumns:
5622         return consumeColumns(important);
5623     case CSSPropertyAnimation:
5624         return consumeAnimationShorthand(animationShorthandForParsing(), important);
5625     case CSSPropertyTransition:
5626         return consumeAnimationShorthand(transitionShorthandForParsing(), important);
5627     case CSSPropertyTextDecoration:
5628     case CSSPropertyWebkitTextDecoration:
5629         // FIXME-NEWPARSER: We need to unprefix -line/-style/-color ASAP and get rid
5630         // of -webkit-text-decoration completely.
</pre>
<hr />
<pre>
5807             columnGap = rowGap;
5808         addProperty(CSSPropertyRowGap, CSSPropertyGap, rowGap.releaseNonNull(), important);
5809         addProperty(CSSPropertyColumnGap, CSSPropertyGap, columnGap.releaseNonNull(), important);
5810         return true;
5811     }
5812     case CSSPropertyGridColumn:
5813     case CSSPropertyGridRow:
5814         return consumeGridItemPositionShorthand(property, important);
5815     case CSSPropertyGridArea:
5816         return consumeGridAreaShorthand(important);
5817     case CSSPropertyGridTemplate:
5818         return consumeGridTemplateShorthand(CSSPropertyGridTemplate, important);
5819     case CSSPropertyGrid:
5820         return consumeGridShorthand(important);
5821     case CSSPropertyPlaceContent:
5822         return consumePlaceContentShorthand(important);
5823     case CSSPropertyPlaceItems:
5824         return consumePlaceItemsShorthand(important);
5825     case CSSPropertyPlaceSelf:
5826         return consumePlaceSelfShorthand(important);
<span class="line-removed">5827     case CSSPropertyWebkitMarquee:</span>
<span class="line-removed">5828         return consumeShorthandGreedily(webkitMarqueeShorthand(), important);</span>
5829     default:
5830         return false;
5831     }
5832 }
5833 
5834 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  55 #include &quot;CSSParserIdioms.h&quot;
  56 #include &quot;CSSPendingSubstitutionValue.h&quot;
  57 #include &quot;CSSPrimitiveValueMappings.h&quot;
  58 #include &quot;CSSPropertyParserHelpers.h&quot;
  59 #include &quot;CSSReflectValue.h&quot;
  60 #include &quot;CSSShadowValue.h&quot;
  61 #include &quot;CSSTimingFunctionValue.h&quot;
  62 #include &quot;CSSUnicodeRangeValue.h&quot;
  63 #include &quot;CSSVariableParser.h&quot;
  64 #include &quot;CSSVariableReferenceValue.h&quot;
  65 #include &quot;Counter.h&quot;
  66 #include &quot;FontFace.h&quot;
  67 #include &quot;HashTools.h&quot;
  68 // FIXME-NEWPARSER: Replace Pair and Rect with actual CSSValue subclasses (CSSValuePair and CSSQuadValue).
  69 #include &quot;Pair.h&quot;
  70 #include &quot;Rect.h&quot;
  71 #include &quot;RenderTheme.h&quot;
  72 #include &quot;RuntimeEnabledFeatures.h&quot;
  73 #include &quot;SVGPathByteStream.h&quot;
  74 #include &quot;SVGPathUtilities.h&quot;
<span class="line-added">  75 #include &quot;StyleBuilder.h&quot;</span>
  76 #include &quot;StyleBuilderConverter.h&quot;
  77 #include &quot;StylePropertyShorthand.h&quot;
  78 #include &quot;StylePropertyShorthandFunctions.h&quot;

  79 #include &lt;bitset&gt;
  80 #include &lt;memory&gt;
  81 #include &lt;wtf/text/StringBuilder.h&gt;
  82 
  83 namespace WebCore {
  84 
  85 bool isCustomPropertyName(const String&amp; propertyName)
  86 {
  87     return propertyName.length() &gt; 2 &amp;&amp; propertyName.characterAt(0) == &#39;-&#39; &amp;&amp; propertyName.characterAt(1) == &#39;-&#39;;
  88 }
  89 
  90 static bool hasPrefix(const char* string, unsigned length, const char* prefix)
  91 {
  92     for (unsigned i = 0; i &lt; length; ++i) {
  93         if (!prefix[i])
  94             return true;
  95         if (string[i] != prefix[i])
  96             return false;
  97     }
  98     return false;
</pre>
<hr />
<pre>
 138 #if PLATFORM(IOS_FAMILY)
 139         cssPropertyNameIOSAliasing(buffer, name, length);
 140 #endif
 141     }
 142 
 143     const Property* hashTableEntry = findProperty(name, length);
 144     if (hashTableEntry) {
 145         auto propertyID = static_cast&lt;CSSPropertyID&gt;(hashTableEntry-&gt;id);
 146         if (isEnabledCSSProperty(propertyID))
 147             return propertyID;
 148     }
 149     return CSSPropertyInvalid;
 150 }
 151 
 152 static bool isAppleLegacyCssValueKeyword(const char* valueKeyword, unsigned length)
 153 {
 154     static const char applePrefix[] = &quot;-apple-&quot;;
 155     static const char appleSystemPrefix[] = &quot;-apple-system&quot;;
 156     static const char applePayPrefix[] = &quot;-apple-pay&quot;;
 157 
<span class="line-modified"> 158 #if PLATFORM(COCOA)</span>
 159     static const char* appleWirelessPlaybackTargetActive = getValueName(CSSValueAppleWirelessPlaybackTargetActive);
 160 #endif
 161 
 162     return hasPrefix(valueKeyword, length, applePrefix)
 163     &amp;&amp; !hasPrefix(valueKeyword, length, appleSystemPrefix)
 164     &amp;&amp; !hasPrefix(valueKeyword, length, applePayPrefix)
<span class="line-modified"> 165 #if PLATFORM(COCOA)</span>
 166     &amp;&amp; !WTF::equal(reinterpret_cast&lt;const LChar*&gt;(valueKeyword), reinterpret_cast&lt;const LChar*&gt;(appleWirelessPlaybackTargetActive), length)
 167 #endif
 168     ;
 169 }
 170 
 171 template &lt;typename CharacterType&gt;
 172 static CSSValueID cssValueKeywordID(const CharacterType* valueKeyword, unsigned length)
 173 {
 174     char buffer[maxCSSValueKeywordLength + 1 + 1]; // 1 to turn &quot;apple&quot;/&quot;khtml&quot; into &quot;webkit&quot;, 1 for null character
 175 
 176     for (unsigned i = 0; i != length; ++i) {
 177         CharacterType c = valueKeyword[i];
 178         if (!c || c &gt;= 0x7F)
 179             return CSSValueInvalid; // illegal keyword.
 180         buffer[i] = WTF::toASCIILower(c);
 181     }
 182     buffer[length] = &#39;\0&#39;;
 183 
 184     if (buffer[0] == &#39;-&#39;) {
 185         // If the prefix is -apple- or -khtml-, change it to -webkit-.
</pre>
<hr />
<pre>
 242     if (currentShorthand) {
 243         auto shorthands = matchingShorthandsForLonghand(property);
 244         setFromShorthand = true;
 245         if (shorthands.size() &gt; 1)
 246             shorthandIndex = indexOfShorthandForLonghand(currentShorthand, shorthands);
 247     }
 248 
 249     m_parsedProperties-&gt;append(CSSProperty(property, WTFMove(value), important, setFromShorthand, shorthandIndex, implicit));
 250 }
 251 
 252 void CSSPropertyParser::addExpandedPropertyForValue(CSSPropertyID property, Ref&lt;CSSValue&gt;&amp;&amp; value, bool important)
 253 {
 254     const StylePropertyShorthand&amp; shorthand = shorthandForProperty(property);
 255     unsigned shorthandLength = shorthand.length();
 256     ASSERT(shorthandLength);
 257     const CSSPropertyID* longhands = shorthand.properties();
 258     for (unsigned i = 0; i &lt; shorthandLength; ++i)
 259         addProperty(longhands[i], property, value.copyRef(), important);
 260 }
 261 
<span class="line-modified"> 262 bool CSSPropertyParser::parseValue(CSSPropertyID propertyID, bool important, const CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, ParsedPropertyVector&amp; parsedProperties, StyleRuleType ruleType)</span>
 263 {
 264     int parsedPropertiesSize = parsedProperties.size();
 265 
 266     CSSPropertyParser parser(range, context, &amp;parsedProperties);
 267     bool parseSuccess;
 268 
 269 #if ENABLE(CSS_DEVICE_ADAPTATION)
<span class="line-modified"> 270     if (ruleType == StyleRuleType::Viewport)</span>
 271         parseSuccess = parser.parseViewportDescriptor(propertyID, important);
 272     else
 273 #endif
<span class="line-modified"> 274     if (ruleType == StyleRuleType::FontFace)</span>
 275         parseSuccess = parser.parseFontFaceDescriptor(propertyID);
 276     else
 277         parseSuccess = parser.parseValueStart(propertyID, important);
 278 
 279     if (!parseSuccess)
 280         parsedProperties.shrink(parsedPropertiesSize);
 281 
 282     return parseSuccess;
 283 }
 284 
 285 RefPtr&lt;CSSValue&gt; CSSPropertyParser::parseSingleValue(CSSPropertyID property, const CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
 286 {
 287     CSSPropertyParser parser(range, context, nullptr);
 288     RefPtr&lt;CSSValue&gt; value = parser.parseSingleValue(property);
 289     if (!value || !parser.m_range.atEnd())
 290         return nullptr;
 291     return value;
 292 }
 293 
 294 bool CSSPropertyParser::canParseTypedCustomPropertyValue(const String&amp; syntax, const CSSParserTokenRange&amp; tokens, const CSSParserContext&amp; context)
 295 {
 296     CSSPropertyParser parser(tokens, context, nullptr);
 297     return parser.canParseTypedCustomPropertyValue(syntax);
 298 }
 299 
<span class="line-modified"> 300 RefPtr&lt;CSSCustomPropertyValue&gt; CSSPropertyParser::parseTypedCustomPropertyValue(const String&amp; name, const String&amp; syntax, const CSSParserTokenRange&amp; tokens, const Style::BuilderState&amp; builderState, const CSSParserContext&amp; context)</span>
 301 {
 302     CSSPropertyParser parser(tokens, context, nullptr, false);
<span class="line-modified"> 303     RefPtr&lt;CSSCustomPropertyValue&gt; value = parser.parseTypedCustomPropertyValue(name, syntax, builderState);</span>
 304     if (!value || !parser.m_range.atEnd())
 305         return nullptr;
 306     return value;
 307 }
 308 
 309 void CSSPropertyParser::collectParsedCustomPropertyValueDependencies(const String&amp; syntax, bool isRoot, HashSet&lt;CSSPropertyID&gt;&amp; dependencies, const CSSParserTokenRange&amp; tokens, const CSSParserContext&amp; context)
 310 {
 311     CSSPropertyParser parser(tokens, context, nullptr);
 312     parser.collectParsedCustomPropertyValueDependencies(syntax, isRoot, dependencies);
 313 }
 314 
 315 bool CSSPropertyParser::parseValueStart(CSSPropertyID propertyID, bool important)
 316 {
 317     if (consumeCSSWideKeyword(propertyID, important))
 318         return true;
 319 
 320     CSSParserTokenRange originalRange = m_range;
 321     bool isShorthand = isShorthandCSSProperty(propertyID);
 322 
 323     if (isShorthand) {
</pre>
<hr />
<pre>
 372         addProperty(propertyID, CSSPropertyInvalid, value.releaseNonNull(), important);
 373     } else
 374         addExpandedPropertyForValue(propertyID, value.releaseNonNull(), important);
 375     m_range = rangeCopy;
 376     return true;
 377 }
 378 
 379 bool CSSPropertyParser::consumeTransformOrigin(bool important)
 380 {
 381     RefPtr&lt;CSSPrimitiveValue&gt; resultX;
 382     RefPtr&lt;CSSPrimitiveValue&gt; resultY;
 383     if (consumeOneOrTwoValuedPosition(m_range, m_context.mode, UnitlessQuirk::Forbid, resultX, resultY)) {
 384         m_range.consumeWhitespace();
 385         bool atEnd = m_range.atEnd();
 386         RefPtr&lt;CSSPrimitiveValue&gt; resultZ = consumeLength(m_range, m_context.mode, ValueRangeAll);
 387         bool hasZ = resultZ;
 388         if (!hasZ &amp;&amp; !atEnd)
 389             return false;
 390         addProperty(CSSPropertyTransformOriginX, CSSPropertyTransformOrigin, resultX.releaseNonNull(), important);
 391         addProperty(CSSPropertyTransformOriginY, CSSPropertyTransformOrigin, resultY.releaseNonNull(), important);
<span class="line-modified"> 392         addProperty(CSSPropertyTransformOriginZ, CSSPropertyTransformOrigin, resultZ ? resultZ.releaseNonNull() : CSSValuePool::singleton().createValue(0, CSSUnitType::CSS_PX), important, !hasZ);</span>
 393 
 394         return true;
 395     }
 396     return false;
 397 }
 398 
 399 bool CSSPropertyParser::consumePerspectiveOrigin(bool important)
 400 {
 401     RefPtr&lt;CSSPrimitiveValue&gt; resultX;
 402     RefPtr&lt;CSSPrimitiveValue&gt; resultY;
<span class="line-modified"> 403     if (consumePosition(m_range, m_context.mode, UnitlessQuirk::Forbid, PositionSyntax::Position, resultX, resultY)) {</span>
 404         addProperty(CSSPropertyPerspectiveOriginX, CSSPropertyPerspectiveOrigin, resultX.releaseNonNull(), important);
 405         addProperty(CSSPropertyPerspectiveOriginY, CSSPropertyPerspectiveOrigin, resultY.releaseNonNull(), important);
 406         return true;
 407     }
 408     return false;
 409 }
 410 
 411 // Methods for consuming non-shorthand properties starts here.
 412 static RefPtr&lt;CSSValue&gt; consumeWillChange(CSSParserTokenRange&amp; range)
 413 {
 414     if (range.peek().id() == CSSValueAuto)
 415         return consumeIdent(range);
 416 
 417     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createCommaSeparated();
 418     // Every comma-separated list of identifiers is a valid will-change value,
 419     // unless the list includes an explicitly disallowed identifier.
 420     while (true) {
 421         if (range.peek().type() != IdentToken)
 422             return nullptr;
 423         CSSPropertyID propertyID = cssPropertyID(range.peek().value());
</pre>
<hr />
<pre>
 953 #if ENABLE(VARIATION_FONTS)
 954 static bool fontStyleIsWithinRange(float oblique)
 955 {
 956     return oblique &gt; -90 &amp;&amp; oblique &lt; 90;
 957 }
 958 #endif
 959 
 960 static RefPtr&lt;CSSFontStyleValue&gt; consumeFontStyle(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
 961 {
 962     auto result = consumeFontStyleKeywordValue(range);
 963     if (!result)
 964         return nullptr;
 965 
 966     auto valueID = result-&gt;valueID();
 967     if (valueID == CSSValueNormal || valueID == CSSValueItalic)
 968         return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(valueID));
 969     ASSERT(result-&gt;valueID() == CSSValueOblique);
 970 #if ENABLE(VARIATION_FONTS)
 971     if (!range.atEnd()) {
 972         if (auto angle = consumeAngle(range, cssParserMode)) {
<span class="line-modified"> 973             if (fontStyleIsWithinRange(angle-&gt;value&lt;float&gt;(CSSUnitType::CSS_DEG)))</span>
 974                 return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueOblique), WTFMove(angle));
 975             return nullptr;
 976         }
 977     }
 978 #else
 979     UNUSED_PARAM(cssParserMode);
 980 #endif
 981     return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueOblique));
 982 }
 983 
 984 #if ENABLE(VARIATION_FONTS)
 985 static RefPtr&lt;CSSFontStyleRangeValue&gt; consumeFontStyleRange(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
 986 {
 987     auto keyword = consumeFontStyleKeywordValue(range);
 988     if (!keyword)
 989         return nullptr;
 990 
 991     if (keyword-&gt;valueID() != CSSValueOblique || range.atEnd())
 992         return CSSFontStyleRangeValue::create(keyword.releaseNonNull());
 993 
 994     if (auto firstAngle = consumeAngle(range, cssParserMode)) {
<span class="line-modified"> 995         if (!fontStyleIsWithinRange(firstAngle-&gt;value&lt;float&gt;(CSSUnitType::CSS_DEG)))</span>
 996             return nullptr;
 997         if (range.atEnd()) {
 998             auto result = CSSValueList::createSpaceSeparated();
 999             result-&gt;append(firstAngle.releaseNonNull());
1000             return CSSFontStyleRangeValue::create(keyword.releaseNonNull(), WTFMove(result));
1001         }
1002         auto secondAngle = consumeAngle(range, cssParserMode);
<span class="line-modified">1003         if (!secondAngle || !fontStyleIsWithinRange(secondAngle-&gt;value&lt;float&gt;(CSSUnitType::CSS_DEG)) || firstAngle-&gt;floatValue(CSSUnitType::CSS_DEG) &gt; secondAngle-&gt;floatValue(CSSUnitType::CSS_DEG))</span>
1004             return nullptr;
1005         auto result = CSSValueList::createSpaceSeparated();
1006         result-&gt;append(firstAngle.releaseNonNull());
1007         result-&gt;append(secondAngle.releaseNonNull());
1008         return CSSFontStyleRangeValue::create(keyword.releaseNonNull(), WTFMove(result));
1009     }
1010 
1011     return nullptr;
1012 }
1013 #endif
1014 
1015 static String concatenateFamilyName(CSSParserTokenRange&amp; range)
1016 {
1017     StringBuilder builder;
1018     bool addedSpace = false;
1019     const CSSParserToken&amp; firstToken = range.peek();
1020     while (range.peek().type() == IdentToken) {
1021         if (!builder.isEmpty()) {
1022             builder.append(&#39; &#39;);
1023             addedSpace = true;
</pre>
<hr />
<pre>
1158 template&lt;typename... Args&gt;
1159 static Ref&lt;CSSPrimitiveValue&gt; createPrimitiveValuePair(Args&amp;&amp;... args)
1160 {
1161     return CSSValuePool::singleton().createValue(Pair::create(std::forward&lt;Args&gt;(args)...));
1162 }
1163 
1164 
1165 static RefPtr&lt;CSSValue&gt; consumeCounter(CSSParserTokenRange&amp; range, int defaultValue)
1166 {
1167     if (range.peek().id() == CSSValueNone)
1168         return consumeIdent(range);
1169 
1170     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
1171     do {
1172         RefPtr&lt;CSSPrimitiveValue&gt; counterName = consumeCustomIdent(range);
1173         if (!counterName)
1174             return nullptr;
1175         int i = defaultValue;
1176         if (RefPtr&lt;CSSPrimitiveValue&gt; counterValue = consumeInteger(range))
1177             i = counterValue-&gt;intValue();
<span class="line-modified">1178         list-&gt;append(createPrimitiveValuePair(counterName.releaseNonNull(), CSSPrimitiveValue::create(i, CSSUnitType::CSS_NUMBER), Pair::IdenticalValueEncoding::Coalesce));</span>
1179     } while (!range.atEnd());
1180     return list;
1181 }
1182 
1183 static RefPtr&lt;CSSValue&gt; consumePageSize(CSSParserTokenRange&amp; range)
1184 {
1185     return consumeIdent&lt;CSSValueA3, CSSValueA4, CSSValueA5, CSSValueB4, CSSValueB5, CSSValueLedger, CSSValueLegal, CSSValueLetter&gt;(range);
1186 }
1187 
1188 static RefPtr&lt;CSSValueList&gt; consumeSize(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1189 {
1190     RefPtr&lt;CSSValueList&gt; result = CSSValueList::createSpaceSeparated();
1191 
1192     if (range.peek().id() == CSSValueAuto) {
1193         result-&gt;append(consumeIdent(range).releaseNonNull());
1194         return result;
1195     }
1196 
1197     if (RefPtr&lt;CSSValue&gt; width = consumeLength(range, cssParserMode, ValueRangeNonNegative)) {
1198         RefPtr&lt;CSSValue&gt; height = consumeLength(range, cssParserMode, ValueRangeNonNegative);
</pre>
<hr />
<pre>
1363 {
1364     if (range.peek().id() == CSSValueAuto)
1365         return consumeIdent(range);
1366     return consumeString(range);
1367 }
1368 
1369 static RefPtr&lt;CSSValue&gt; consumeHyphenateLimit(CSSParserTokenRange&amp; range, CSSValueID valueID)
1370 {
1371     if (range.peek().id() == valueID)
1372         return consumeIdent(range);
1373     return consumeNumber(range, ValueRangeNonNegative);
1374 }
1375 
1376 static RefPtr&lt;CSSValue&gt; consumeColumnWidth(CSSParserTokenRange&amp; range)
1377 {
1378     if (range.peek().id() == CSSValueAuto)
1379         return consumeIdent(range);
1380     // Always parse lengths in strict mode here, since it would be ambiguous otherwise when used in
1381     // the &#39;columns&#39; shorthand property.
1382     RefPtr&lt;CSSPrimitiveValue&gt; columnWidth = consumeLength(range, HTMLStandardMode, ValueRangeNonNegative);
<span class="line-modified">1383     if (!columnWidth || columnWidth-&gt;isZero().valueOr(false))</span>
1384         return nullptr;
<span class="line-added">1385 </span>
1386     return columnWidth;
1387 }
1388 
1389 static RefPtr&lt;CSSValue&gt; consumeColumnCount(CSSParserTokenRange&amp; range)
1390 {
1391     if (range.peek().id() == CSSValueAuto)
1392         return consumeIdent(range);
1393     return consumePositiveInteger(range);
1394 }
1395 
1396 static RefPtr&lt;CSSValue&gt; consumeGapLength(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1397 {
1398     if (range.peek().id() == CSSValueNormal)
1399         return consumeIdent(range);
1400     return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
1401 }
1402 
1403 static RefPtr&lt;CSSValue&gt; consumeColumnSpan(CSSParserTokenRange&amp; range)
1404 {
1405     return consumeIdent&lt;CSSValueAll, CSSValueNone&gt;(range);
</pre>
<hr />
<pre>
1419     return zoom;
1420 }
1421 
1422 static RefPtr&lt;CSSValue&gt; consumeAnimationIterationCount(CSSParserTokenRange&amp; range)
1423 {
1424     if (range.peek().id() == CSSValueInfinite)
1425         return consumeIdent(range);
1426     return consumeNumber(range, ValueRangeNonNegative);
1427 }
1428 
1429 static RefPtr&lt;CSSValue&gt; consumeAnimationName(CSSParserTokenRange&amp; range)
1430 {
1431     if (range.peek().id() == CSSValueNone)
1432         return consumeIdent(range);
1433 
1434     if (range.peek().type() == StringToken) {
1435         const CSSParserToken&amp; token = range.consumeIncludingWhitespace();
1436         if (equalIgnoringASCIICase(token.value(), &quot;none&quot;))
1437             return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1438         // FIXME-NEWPARSER: Want to use a CSSCustomIdentValue here eventually.
<span class="line-modified">1439         return CSSValuePool::singleton().createValue(token.value().toString(), CSSUnitType::CSS_STRING);</span>
1440     }
1441 
1442     return consumeCustomIdent(range);
1443 }
1444 
1445 static RefPtr&lt;CSSValue&gt; consumeTransitionProperty(CSSParserTokenRange&amp; range)
1446 {
1447     const CSSParserToken&amp; token = range.peek();
1448     if (token.type() != IdentToken)
1449         return nullptr;
1450     if (token.id() == CSSValueNone)
1451         return consumeIdent(range);
1452 
1453     if (CSSPropertyID property = token.parseAsCSSPropertyID()) {
1454         range.consumeIncludingWhitespace();
1455 
1456         // FIXME-NEWPARSER: No reason why we can&#39;t use the &quot;all&quot; property now that it exists.
1457         // The old parser used a value keyword for &quot;all&quot;, though, since it predated support for
1458         // the property.
1459         if (property == CSSPropertyAll)
</pre>
<hr />
<pre>
1847 static bool consumeNumbers(CSSParserTokenRange&amp; args, RefPtr&lt;CSSFunctionValue&gt;&amp; transformValue, unsigned numberOfArguments)
1848 {
1849     do {
1850         RefPtr&lt;CSSPrimitiveValue&gt; parsedValue = consumeNumber(args, ValueRangeAll);
1851         if (!parsedValue)
1852             return false;
1853         transformValue-&gt;append(parsedValue.releaseNonNull());
1854         if (--numberOfArguments &amp;&amp; !consumeCommaIncludingWhitespace(args))
1855             return false;
1856     } while (numberOfArguments);
1857     return true;
1858 }
1859 
1860 static bool consumePerspective(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode, RefPtr&lt;CSSFunctionValue&gt;&amp; transformValue)
1861 {
1862     RefPtr&lt;CSSPrimitiveValue&gt; parsedValue = consumeLength(args, cssParserMode, ValueRangeNonNegative);
1863     if (!parsedValue) {
1864         double perspective;
1865         if (!consumeNumberRaw(args, perspective) || perspective &lt; 0)
1866             return false;
<span class="line-modified">1867         parsedValue = CSSPrimitiveValue::create(perspective, CSSUnitType::CSS_PX);</span>
1868     }
1869     if (!parsedValue)
1870         return false;
1871     transformValue-&gt;append(parsedValue.releaseNonNull());
1872     return true;
1873 }
1874 
1875 static RefPtr&lt;CSSValue&gt; consumeTransformValue(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1876 {
1877     CSSValueID functionId = range.peek().functionId();
1878     if (functionId == CSSValueInvalid)
1879         return nullptr;
1880     CSSParserTokenRange args = consumeFunction(range);
1881     if (args.atEnd())
1882         return nullptr;
1883 
1884     RefPtr&lt;CSSFunctionValue&gt; transformValue = CSSFunctionValue::create(functionId);
1885     RefPtr&lt;CSSValue&gt; parsedValue;
1886     switch (functionId) {
1887     case CSSValueRotate:
</pre>
<hr />
<pre>
1979     } while (!range.atEnd());
1980 
1981     return list;
1982 }
1983 
1984 template &lt;CSSValueID start, CSSValueID end&gt;
1985 static RefPtr&lt;CSSPrimitiveValue&gt; consumePositionLonghand(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1986 {
1987     if (range.peek().type() == IdentToken) {
1988         CSSValueID id = range.peek().id();
1989         int percent;
1990         if (id == start)
1991             percent = 0;
1992         else if (id == CSSValueCenter)
1993             percent = 50;
1994         else if (id == end)
1995             percent = 100;
1996         else
1997             return nullptr;
1998         range.consumeIncludingWhitespace();
<span class="line-modified">1999         return CSSPrimitiveValue::create(percent, CSSUnitType::CSS_PERCENTAGE);</span>
2000     }
2001     return consumeLengthOrPercent(range, cssParserMode, ValueRangeAll);
2002 }
2003 
2004 static RefPtr&lt;CSSPrimitiveValue&gt; consumePositionX(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2005 {
2006     return consumePositionLonghand&lt;CSSValueLeft, CSSValueRight&gt;(range, cssParserMode);
2007 }
2008 
2009 static RefPtr&lt;CSSPrimitiveValue&gt; consumePositionY(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2010 {
2011     return consumePositionLonghand&lt;CSSValueTop, CSSValueBottom&gt;(range, cssParserMode);
2012 }
2013 
2014 static RefPtr&lt;CSSValue&gt; consumePaintStroke(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2015 {
2016     if (range.peek().id() == CSSValueNone)
2017         return consumeIdent(range);
2018     RefPtr&lt;CSSPrimitiveValue&gt; url = consumeUrl(range);
2019     if (url) {
</pre>
<hr />
<pre>
2124         return consumeIdent(range);
2125 
2126     RefPtr&lt;CSSValueList&gt; dashes = CSSValueList::createCommaSeparated();
2127     do {
2128         RefPtr&lt;CSSPrimitiveValue&gt; dash = consumeLengthOrPercent(range, SVGAttributeMode, ValueRangeNonNegative);
2129         if (!dash || (consumeCommaIncludingWhitespace(range) &amp;&amp; range.atEnd()))
2130             return nullptr;
2131         dashes-&gt;append(dash.releaseNonNull());
2132     } while (!range.atEnd());
2133     return dashes;
2134 }
2135 
2136 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBaselineShift(CSSParserTokenRange&amp; range)
2137 {
2138     CSSValueID id = range.peek().id();
2139     if (id == CSSValueBaseline || id == CSSValueSub || id == CSSValueSuper)
2140         return consumeIdent(range);
2141     return consumeLengthOrPercent(range, SVGAttributeMode, ValueRangeAll);
2142 }
2143 
<span class="line-modified">2144 static RefPtr&lt;CSSPrimitiveValue&gt; consumeRxOrRy(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)</span>
2145 {
<span class="line-modified">2146     if (range.peek().id() == CSSValueAuto)</span>
<span class="line-modified">2147         return consumeIdent(range);</span>
<span class="line-modified">2148     return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative, UnitlessQuirk::Forbid);</span>


2149 }
2150 
2151 static RefPtr&lt;CSSValue&gt; consumeCursor(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, bool inQuirksMode)
2152 {
2153     RefPtr&lt;CSSValueList&gt; list;
<span class="line-modified">2154     while (RefPtr&lt;CSSValue&gt; image = consumeImage(range, context, { AllowedImageType::URLFunction, AllowedImageType::ImageSet })) {</span>
2155         double num;
2156         IntPoint hotSpot(-1, -1);
2157         bool hotSpotSpecified = false;
2158         if (consumeNumberRaw(range, num)) {
2159             hotSpot.setX(int(num));
2160             if (!consumeNumberRaw(range, num))
2161                 return nullptr;
2162             hotSpot.setY(int(num));
2163             hotSpotSpecified = true;
2164         }
2165 
2166         if (!list)
2167             list = CSSValueList::createCommaSeparated();
2168 
2169         list-&gt;append(CSSCursorImageValue::create(image.releaseNonNull(), hotSpotSpecified, hotSpot, context.isContentOpaque ? LoadedFromOpaqueSource::Yes : LoadedFromOpaqueSource::No));
2170         if (!consumeCommaIncludingWhitespace(range))
2171             return nullptr;
2172     }
2173 
2174     CSSValueID id = range.peek().id();
</pre>
<hr />
<pre>
2189     list-&gt;append(cursorType.releaseNonNull());
2190     return list;
2191 }
2192 
2193 static RefPtr&lt;CSSValue&gt; consumeAttr(CSSParserTokenRange args, CSSParserContext context)
2194 {
2195     if (args.peek().type() != IdentToken)
2196         return nullptr;
2197 
2198     CSSParserToken token = args.consumeIncludingWhitespace();
2199     auto attrName = token.value().toAtomString();
2200     if (context.isHTMLDocument)
2201         attrName = attrName.convertToASCIILowercase();
2202 
2203     if (!args.atEnd())
2204         return nullptr;
2205 
2206     // FIXME-NEWPARSER: We want to use a CSSCustomIdentValue here eventually for the attrName.
2207     // FIXME-NEWPARSER: We want to use a CSSFunctionValue rather than relying on a custom
2208     // attr() primitive value.
<span class="line-modified">2209     return CSSValuePool::singleton().createValue(attrName, CSSUnitType::CSS_ATTR);</span>
2210 }
2211 
2212 static RefPtr&lt;CSSValue&gt; consumeCounterContent(CSSParserTokenRange args, bool counters)
2213 {
2214     RefPtr&lt;CSSPrimitiveValue&gt; identifier = consumeCustomIdent(args);
2215     if (!identifier)
2216         return nullptr;
2217 
2218     RefPtr&lt;CSSPrimitiveValue&gt; separator;
2219     if (!counters)
<span class="line-modified">2220         separator = CSSPrimitiveValue::create(String(), CSSUnitType::CSS_STRING);</span>
2221     else {
2222         if (!consumeCommaIncludingWhitespace(args) || args.peek().type() != StringToken)
2223             return nullptr;
<span class="line-modified">2224         separator = CSSPrimitiveValue::create(args.consumeIncludingWhitespace().value().toString(), CSSUnitType::CSS_STRING);</span>
2225     }
2226 
2227     RefPtr&lt;CSSPrimitiveValue&gt; listStyle;
2228     if (consumeCommaIncludingWhitespace(args)) {
2229         CSSValueID id = args.peek().id();
2230         if ((id != CSSValueNone &amp;&amp; (id &lt; CSSValueDisc || id &gt; CSSValueKatakanaIroha)))
2231             return nullptr;
2232         listStyle = consumeIdent(args);
2233     } else
2234         listStyle = CSSValuePool::singleton().createIdentifierValue(CSSValueDecimal);
2235 
2236     if (!args.atEnd())
2237         return nullptr;
2238 
2239     // FIXME-NEWPARSER: Should just have a CSSCounterValue.
2240     return CSSValuePool::singleton().createValue(Counter::create(identifier.releaseNonNull(), listStyle.releaseNonNull(), separator.releaseNonNull()));
2241 }
2242 
2243 static RefPtr&lt;CSSValue&gt; consumeContent(CSSParserTokenRange&amp; range, CSSParserContext context)
2244 {
</pre>
<hr />
<pre>
2262                 parsedValue = consumeCounterContent(consumeFunction(range), true);
2263             if (!parsedValue)
2264                 return nullptr;
2265         }
2266         values-&gt;append(parsedValue.releaseNonNull());
2267     } while (!range.atEnd());
2268 
2269     return values;
2270 }
2271 
2272 static RefPtr&lt;CSSPrimitiveValue&gt; consumePerspective(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2273 {
2274     if (range.peek().id() == CSSValueNone)
2275         return consumeIdent(range);
2276     RefPtr&lt;CSSPrimitiveValue&gt; parsedValue = consumeLength(range, cssParserMode, ValueRangeAll);
2277     if (!parsedValue) {
2278         // FIXME: Make this quirk only apply to the webkit prefixed version of the property.
2279         double perspective;
2280         if (!consumeNumberRaw(range, perspective))
2281             return nullptr;
<span class="line-modified">2282         parsedValue = CSSPrimitiveValue::create(perspective, CSSUnitType::CSS_PX);</span>
2283     }
<span class="line-modified">2284 </span>
<span class="line-added">2285     if (!parsedValue)</span>
<span class="line-added">2286         return nullptr;</span>
<span class="line-added">2287 </span>
<span class="line-added">2288     if (parsedValue-&gt;isPositive().valueOr(true))</span>
2289         return parsedValue;
<span class="line-added">2290 </span>
2291     return nullptr;
2292 }
2293 
2294 #if ENABLE(CSS_SCROLL_SNAP)
2295 
2296 static RefPtr&lt;CSSValueList&gt; consumeScrollSnapAlign(CSSParserTokenRange&amp; range)
2297 {
2298     RefPtr&lt;CSSValueList&gt; alignmentValue = CSSValueList::createSpaceSeparated();
2299     if (RefPtr&lt;CSSPrimitiveValue&gt; firstValue = consumeIdent&lt;CSSValueNone, CSSValueStart, CSSValueCenter, CSSValueEnd&gt;(range)) {
2300         alignmentValue-&gt;append(firstValue.releaseNonNull());
2301         if (auto secondValue = consumeIdent&lt;CSSValueNone, CSSValueStart, CSSValueCenter, CSSValueEnd&gt;(range))
2302             alignmentValue-&gt;append(secondValue.releaseNonNull());
2303     }
2304     return alignmentValue-&gt;length() ? alignmentValue : nullptr;
2305 }
2306 
2307 static RefPtr&lt;CSSValueList&gt; consumeScrollSnapType(CSSParserTokenRange&amp; range)
2308 {
2309     RefPtr&lt;CSSValueList&gt; typeValue = CSSValueList::createSpaceSeparated();
2310     RefPtr&lt;CSSPrimitiveValue&gt; secondValue;
2311 
2312     auto firstValue = consumeIdent&lt;CSSValueX, CSSValueY, CSSValueBlock, CSSValueInline, CSSValueBoth&gt;(range);
2313     if (firstValue)
2314         secondValue = consumeIdent&lt;CSSValueProximity, CSSValueMandatory&gt;(range);
2315     else
2316         firstValue = consumeIdent&lt;CSSValueNone, CSSValueProximity, CSSValueMandatory&gt;(range);
2317 
2318     if (!firstValue)
2319         return nullptr;
2320 
2321     typeValue-&gt;append(firstValue.releaseNonNull());
2322     if (secondValue)
2323         typeValue-&gt;append(secondValue.releaseNonNull());
2324 
2325     return typeValue;
2326 }
2327 
2328 #endif
2329 
<span class="line-added">2330 static RefPtr&lt;CSSPrimitiveValue&gt; consumeScrollBehavior(CSSParserTokenRange&amp; range)</span>
<span class="line-added">2331 {</span>
<span class="line-added">2332     auto valueID = range.peek().id();</span>
<span class="line-added">2333     if (valueID != CSSValueAuto &amp;&amp; valueID != CSSValueSmooth)</span>
<span class="line-added">2334         return nullptr;</span>
<span class="line-added">2335     return consumeIdent(range);</span>
<span class="line-added">2336 }</span>
<span class="line-added">2337 </span>
2338 static RefPtr&lt;CSSValue&gt; consumeBorderRadiusCorner(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2339 {
2340     RefPtr&lt;CSSPrimitiveValue&gt; parsedValue1 = consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
2341     if (!parsedValue1)
2342         return nullptr;
2343     RefPtr&lt;CSSPrimitiveValue&gt; parsedValue2 = consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
2344     if (!parsedValue2)
2345         parsedValue2 = parsedValue1;
2346     return createPrimitiveValuePair(parsedValue1.releaseNonNull(), parsedValue2.releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce);
2347 }
2348 
2349 static RefPtr&lt;CSSValue&gt; consumeTextUnderlineOffset(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2350 {
2351     if (auto value = consumeIdent&lt;CSSValueAuto&gt;(range))
2352         return value;
2353     return consumeLength(range, cssParserMode, ValueRangeAll);
2354 }
2355 
2356 static RefPtr&lt;CSSValue&gt; consumeTextDecorationThickness(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2357 {
</pre>
<hr />
<pre>
2368     return parsedValue;
2369 }
2370 
2371 static RefPtr&lt;CSSPrimitiveValue&gt; consumeShapeRadius(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode)
2372 {
2373     if (identMatches&lt;CSSValueClosestSide, CSSValueFarthestSide&gt;(args.peek().id()))
2374         return consumeIdent(args);
2375     return consumeLengthOrPercent(args, cssParserMode, ValueRangeNonNegative);
2376 }
2377 
2378 static RefPtr&lt;CSSBasicShapeCircle&gt; consumeBasicShapeCircle(CSSParserTokenRange&amp; args, const CSSParserContext&amp; context)
2379 {
2380     // spec: https://drafts.csswg.org/css-shapes/#supported-basic-shapes
2381     // circle( [&lt;shape-radius&gt;]? [at &lt;position&gt;]? )
2382     RefPtr&lt;CSSBasicShapeCircle&gt; shape = CSSBasicShapeCircle::create();
2383     if (RefPtr&lt;CSSPrimitiveValue&gt; radius = consumeShapeRadius(args, context.mode))
2384         shape-&gt;setRadius(radius.releaseNonNull());
2385     if (consumeIdent&lt;CSSValueAt&gt;(args)) {
2386         RefPtr&lt;CSSPrimitiveValue&gt; centerX;
2387         RefPtr&lt;CSSPrimitiveValue&gt; centerY;
<span class="line-modified">2388         if (!consumePosition(args, context.mode, UnitlessQuirk::Forbid, PositionSyntax::Position, centerX, centerY))</span>
2389             return nullptr;
2390         shape-&gt;setCenterX(centerX.releaseNonNull());
2391         shape-&gt;setCenterY(centerY.releaseNonNull());
2392     }
2393     return shape;
2394 }
2395 
2396 static RefPtr&lt;CSSBasicShapeEllipse&gt; consumeBasicShapeEllipse(CSSParserTokenRange&amp; args, const CSSParserContext&amp; context)
2397 {
2398     // spec: https://drafts.csswg.org/css-shapes/#supported-basic-shapes
2399     // ellipse( [&lt;shape-radius&gt;{2}]? [at &lt;position&gt;]? )
<span class="line-modified">2400     auto shape = CSSBasicShapeEllipse::create();</span>
<span class="line-modified">2401     if (auto radiusX = consumeShapeRadius(args, context.mode)) {</span>
<span class="line-added">2402         auto radiusY = consumeShapeRadius(args, context.mode);</span>
<span class="line-added">2403         if (!radiusY)</span>
<span class="line-added">2404             return nullptr;</span>
2405         shape-&gt;setRadiusX(radiusX.releaseNonNull());
<span class="line-modified">2406         shape-&gt;setRadiusY(radiusY.releaseNonNull());</span>

2407     }
2408     if (consumeIdent&lt;CSSValueAt&gt;(args)) {
2409         RefPtr&lt;CSSPrimitiveValue&gt; centerX;
2410         RefPtr&lt;CSSPrimitiveValue&gt; centerY;
<span class="line-modified">2411         if (!consumePosition(args, context.mode, UnitlessQuirk::Forbid, PositionSyntax::Position, centerX, centerY))</span>
2412             return nullptr;
2413         shape-&gt;setCenterX(centerX.releaseNonNull());
2414         shape-&gt;setCenterY(centerY.releaseNonNull());
2415     }
2416     return shape;
2417 }
2418 
2419 static RefPtr&lt;CSSBasicShapePolygon&gt; consumeBasicShapePolygon(CSSParserTokenRange&amp; args, const CSSParserContext&amp; context)
2420 {
2421     RefPtr&lt;CSSBasicShapePolygon&gt; shape = CSSBasicShapePolygon::create();
2422     if (identMatches&lt;CSSValueEvenodd, CSSValueNonzero&gt;(args.peek().id())) {
2423         shape-&gt;setWindRule(args.consumeIncludingWhitespace().id() == CSSValueEvenodd ? WindRule::EvenOdd : WindRule::NonZero);
2424         if (!consumeCommaIncludingWhitespace(args))
2425             return nullptr;
2426     }
2427 
2428     do {
2429         RefPtr&lt;CSSPrimitiveValue&gt; xLength = consumeLengthOrPercent(args, context.mode, ValueRangeAll);
2430         if (!xLength)
2431             return nullptr;
</pre>
<hr />
<pre>
2527     else if (bottom)
2528         shape-&gt;updateShapeSize3Values(top.releaseNonNull(), right.releaseNonNull(), bottom.releaseNonNull());
2529     else if (right)
2530         shape-&gt;updateShapeSize2Values(top.releaseNonNull(), right.releaseNonNull());
2531     else
2532         shape-&gt;updateShapeSize1Value(top.releaseNonNull());
2533 
2534     if (consumeIdent&lt;CSSValueRound&gt;(args)) {
2535         RefPtr&lt;CSSPrimitiveValue&gt; horizontalRadii[4] = { 0 };
2536         RefPtr&lt;CSSPrimitiveValue&gt; verticalRadii[4] = { 0 };
2537         if (!consumeRadii(horizontalRadii, verticalRadii, args, context.mode, false))
2538             return nullptr;
2539         shape-&gt;setTopLeftRadius(createPrimitiveValuePair(horizontalRadii[0].releaseNonNull(), verticalRadii[0].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce));
2540         shape-&gt;setTopRightRadius(createPrimitiveValuePair(horizontalRadii[1].releaseNonNull(), verticalRadii[1].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce));
2541         shape-&gt;setBottomRightRadius(createPrimitiveValuePair(horizontalRadii[2].releaseNonNull(), verticalRadii[2].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce));
2542         shape-&gt;setBottomLeftRadius(createPrimitiveValuePair(horizontalRadii[3].releaseNonNull(), verticalRadii[3].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce));
2543     }
2544     return shape;
2545 }
2546 
<span class="line-modified">2547 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBasicShape(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)</span>
2548 {

2549     if (range.peek().type() != FunctionToken)
2550         return nullptr;
2551     CSSValueID id = range.peek().functionId();
2552     CSSParserTokenRange rangeCopy = range;
2553     CSSParserTokenRange args = consumeFunction(rangeCopy);
2554 
2555     // FIXME-NEWPARSER: CSSBasicShape should be a CSSValue, and shapes should not be primitive values.
2556     RefPtr&lt;CSSBasicShape&gt; shape;
2557     if (id == CSSValueCircle)
2558         shape = consumeBasicShapeCircle(args, context);
2559     else if (id == CSSValueEllipse)
2560         shape = consumeBasicShapeEllipse(args, context);
2561     else if (id == CSSValuePolygon)
2562         shape = consumeBasicShapePolygon(args, context);
2563     else if (id == CSSValueInset)
2564         shape = consumeBasicShapeInset(args, context);
2565     else if (id == CSSValuePath)
2566         shape = consumeBasicShapePath(args);
2567     if (!shape)
2568         return nullptr;
</pre>
<hr />
<pre>
2582     while (!range.atEnd() &amp;&amp; !(shapeFound &amp;&amp; boxFound)) {
2583         RefPtr&lt;CSSValue&gt; componentValue;
2584         if (range.peek().type() == FunctionToken &amp;&amp; !shapeFound) {
2585             componentValue = consumeBasicShape(range, context);
2586             shapeFound = true;
2587         } else if (range.peek().type() == IdentToken &amp;&amp; !boxFound) {
2588             componentValue = consumeIdent&lt;CSSValueContentBox, CSSValuePaddingBox, CSSValueBorderBox, CSSValueMarginBox, CSSValueFillBox, CSSValueStrokeBox, CSSValueViewBox&gt;(range);
2589             boxFound = true;
2590         }
2591         if (!componentValue)
2592             return nullptr;
2593         list-&gt;append(componentValue.releaseNonNull());
2594     }
2595 
2596     if (!range.atEnd() || !list-&gt;length())
2597         return nullptr;
2598 
2599     return list;
2600 }
2601 
<span class="line-modified">2602 static RefPtr&lt;CSSValue&gt; consumeClipPath(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)</span>
2603 {
2604     if (range.peek().id() == CSSValueNone)
2605         return consumeIdent(range);
2606     if (RefPtr&lt;CSSPrimitiveValue&gt; url = consumeUrl(range))
2607         return url;
2608     return consumeBasicShapeOrBox(range, context);
2609 }
2610 
2611 static RefPtr&lt;CSSValue&gt; consumeShapeOutside(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
2612 {
2613     if (RefPtr&lt;CSSValue&gt; imageValue = consumeImageOrNone(range, context))
2614         return imageValue;
2615     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
2616     if (RefPtr&lt;CSSValue&gt; boxValue = consumeIdent&lt;CSSValueContentBox, CSSValuePaddingBox, CSSValueBorderBox, CSSValueMarginBox&gt;(range))
2617         list-&gt;append(boxValue.releaseNonNull());
<span class="line-modified">2618     if (RefPtr&lt;CSSPrimitiveValue&gt; shapeValue = consumeBasicShape(range, context)) {</span>
<span class="line-added">2619         if (shapeValue-&gt;shapeValue()-&gt;type() == CSSBasicShapeCircle::CSSBasicShapePathType)</span>
<span class="line-added">2620             return nullptr;</span>
2621         list-&gt;append(shapeValue.releaseNonNull());
2622         if (list-&gt;length() &lt; 2) {
2623             if (RefPtr&lt;CSSValue&gt; boxValue = consumeIdent&lt;CSSValueContentBox, CSSValuePaddingBox, CSSValueBorderBox, CSSValueMarginBox&gt;(range))
2624                 list-&gt;append(boxValue.releaseNonNull());
2625         }
2626     }
2627     if (!list-&gt;length())
2628         return nullptr;
2629     return list;
2630 }
2631 
2632 static bool isAuto(CSSValueID id)
2633 {
2634     return identMatches&lt;CSSValueAuto&gt;(id);
2635 }
2636 
2637 static bool isNormalOrStretch(CSSValueID id)
2638 {
2639     return identMatches&lt;CSSValueNormal, CSSValueStretch&gt;(id);
2640 }
</pre>
<hr />
<pre>
2877     RefPtr&lt;CSSValue&gt; slice;
2878     RefPtr&lt;CSSValue&gt; width;
2879     RefPtr&lt;CSSValue&gt; outset;
2880     RefPtr&lt;CSSValue&gt; repeat;
2881     if (consumeBorderImageComponents(property, range, context, source, slice, width, outset, repeat))
2882         return createBorderImageValue(WTFMove(source), WTFMove(slice), WTFMove(width), WTFMove(outset), WTFMove(repeat));
2883     return nullptr;
2884 }
2885 
2886 static RefPtr&lt;CSSValue&gt; consumeReflect(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
2887 {
2888     if (range.peek().id() == CSSValueNone)
2889         return consumeIdent(range);
2890 
2891     RefPtr&lt;CSSPrimitiveValue&gt; direction = consumeIdent&lt;CSSValueAbove, CSSValueBelow, CSSValueLeft, CSSValueRight&gt;(range);
2892     if (!direction)
2893         return nullptr;
2894 
2895     RefPtr&lt;CSSPrimitiveValue&gt; offset;
2896     if (range.atEnd())
<span class="line-modified">2897         offset = CSSValuePool::singleton().createValue(0, CSSUnitType::CSS_PX);</span>
2898     else {
2899         offset = consumeLengthOrPercent(range, context.mode, ValueRangeAll, UnitlessQuirk::Forbid);
2900         if (!offset)
2901             return nullptr;
2902     }
2903 
2904     RefPtr&lt;CSSValue&gt; mask;
2905     if (!range.atEnd()) {
2906         mask = consumeWebkitBorderImage(CSSPropertyWebkitBoxReflect, range, context);
2907         if (!mask)
2908             return nullptr;
2909     }
2910     return CSSReflectValue::create(direction.releaseNonNull(), offset.releaseNonNull(), WTFMove(mask));
2911 }
2912 












2913 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBackgroundBlendMode(CSSParserTokenRange&amp; range)
2914 {
2915     CSSValueID id = range.peek().id();
2916     if (id == CSSValueNormal || id == CSSValueOverlay || (id &gt;= CSSValueMultiply &amp;&amp; id &lt;= CSSValueLuminosity))
2917         return consumeIdent(range);
2918     return nullptr;
2919 }
2920 
2921 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBackgroundAttachment(CSSParserTokenRange&amp; range)
2922 {
2923     return consumeIdent&lt;CSSValueScroll, CSSValueFixed, CSSValueLocal&gt;(range);
2924 }
2925 
2926 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBackgroundBox(CSSParserTokenRange&amp; range)
2927 {
2928     return consumeIdent&lt;CSSValueBorderBox, CSSValuePaddingBox, CSSValueContentBox, CSSValueWebkitText&gt;(range);
2929 }
2930 
2931 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBackgroundComposite(CSSParserTokenRange&amp; range)
2932 {
</pre>
<hr />
<pre>
3291             if (currentColumn != gridArea.columns.startLine())
3292                 return false;
3293 
3294             // 3. The new area ends at the same position as the previously parsed area.
3295             if (lookAheadColumn != gridArea.columns.endLine())
3296                 return false;
3297 
3298             gridArea.rows = GridSpan::translatedDefiniteGridSpan(gridArea.rows.startLine(), gridArea.rows.endLine() + 1);
3299         }
3300         currentColumn = lookAheadColumn - 1;
3301     }
3302 
3303     return true;
3304 }
3305 
3306 static RefPtr&lt;CSSPrimitiveValue&gt; consumeGridBreadth(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3307 {
3308     const CSSParserToken&amp; token = range.peek();
3309     if (identMatches&lt;CSSValueMinContent, CSSValueWebkitMinContent, CSSValueMaxContent, CSSValueWebkitMaxContent, CSSValueAuto&gt;(token.id()))
3310         return consumeIdent(range);
<span class="line-modified">3311     if (token.type() == DimensionToken &amp;&amp; token.unitType() == CSSUnitType::CSS_FR) {</span>
3312         if (range.peek().numericValue() &lt; 0)
3313             return nullptr;
<span class="line-modified">3314         return CSSPrimitiveValue::create(range.consumeIncludingWhitespace().numericValue(), CSSUnitType::CSS_FR);</span>
3315     }
3316     return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative, UnitlessQuirk::Allow);
3317 }
3318 
3319 static RefPtr&lt;CSSValue&gt; consumeGridTrackSize(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3320 {
3321     const CSSParserToken&amp; token = range.peek();
3322     if (identMatches&lt;CSSValueAuto&gt;(token.id()))
3323         return consumeIdent(range);
3324 
3325     if (token.functionId() == CSSValueMinmax) {
3326         CSSParserTokenRange rangeCopy = range;
3327         CSSParserTokenRange args = consumeFunction(rangeCopy);
3328         RefPtr&lt;CSSPrimitiveValue&gt; minTrackBreadth = consumeGridBreadth(args, cssParserMode);
3329         if (!minTrackBreadth || minTrackBreadth-&gt;isFlex() || !consumeCommaIncludingWhitespace(args))
3330             return nullptr;
3331         RefPtr&lt;CSSPrimitiveValue&gt; maxTrackBreadth = consumeGridBreadth(args, cssParserMode);
3332         if (!maxTrackBreadth || !args.atEnd())
3333             return nullptr;
3334         range = rangeCopy;
3335         RefPtr&lt;CSSFunctionValue&gt; result = CSSFunctionValue::create(CSSValueMinmax);
3336         result-&gt;append(minTrackBreadth.releaseNonNull());
3337         result-&gt;append(maxTrackBreadth.releaseNonNull());
3338         return result;
3339     }
3340 
3341     if (token.functionId() == CSSValueFitContent)
3342         return consumeFitContent(range, cssParserMode);
3343 
3344     return consumeGridBreadth(range, cssParserMode);
3345 }
3346 
<span class="line-modified">3347 // Appends to the passed in CSSGridLineNamesValue if any, otherwise creates a new one. Returns nullptr if an empty list is consumed.</span>
3348 static RefPtr&lt;CSSGridLineNamesValue&gt; consumeGridLineNames(CSSParserTokenRange&amp; range, CSSGridLineNamesValue* lineNames = nullptr)
3349 {
3350     CSSParserTokenRange rangeCopy = range;
3351     if (rangeCopy.consumeIncludingWhitespace().type() != LeftBracketToken)
3352         return nullptr;
3353 
3354     RefPtr&lt;CSSGridLineNamesValue&gt; result = lineNames;
3355     if (!result)
3356         result = CSSGridLineNamesValue::create();
3357     while (RefPtr&lt;CSSPrimitiveValue&gt; lineName = consumeCustomIdentForGridLine(rangeCopy))
3358         result-&gt;append(lineName.releaseNonNull());
3359     if (rangeCopy.consumeIncludingWhitespace().type() != RightBracketToken)
3360         return nullptr;
3361     range = rangeCopy;
<span class="line-modified">3362     return result-&gt;length() ? result : nullptr;</span>
3363 }
3364 
3365 static bool consumeGridTrackRepeatFunction(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, CSSValueList&amp; list, bool&amp; isAutoRepeat, bool&amp; allTracksAreFixedSized)
3366 {
3367     CSSParserTokenRange args = consumeFunction(range);
3368     // The number of repetitions for &lt;auto-repeat&gt; is not important at parsing level
3369     // because it will be computed later, let&#39;s set it to 1.
3370     size_t repetitions = 1;
3371     isAutoRepeat = identMatches&lt;CSSValueAutoFill, CSSValueAutoFit&gt;(args.peek().id());
3372     RefPtr&lt;CSSValueList&gt; repeatedValues;
3373     if (isAutoRepeat)
3374         repeatedValues = CSSGridAutoRepeatValue::create(args.consumeIncludingWhitespace().id());
3375     else {
3376         // FIXME: a consumeIntegerRaw would be more efficient here.
3377         RefPtr&lt;CSSPrimitiveValue&gt; repetition = consumePositiveInteger(args);
3378         if (!repetition)
3379             return false;
3380         repetitions = clampTo&lt;size_t&gt;(repetition-&gt;doubleValue(), 0, GridPosition::max());
3381         repeatedValues = CSSValueList::createSpaceSeparated();
3382     }
</pre>
<hr />
<pre>
3405 
3406     if (isAutoRepeat)
3407         list.append(repeatedValues.releaseNonNull());
3408     else {
3409         // We clamp the repetitions to a multiple of the repeat() track list&#39;s size, while staying below the max grid size.
3410         repetitions = std::min(repetitions, GridPosition::max() / numberOfTracks);
3411         RefPtr&lt;CSSValueList&gt; integerRepeatedValues = CSSGridIntegerRepeatValue::create(repetitions);
3412         for (size_t i = 0; i &lt; repeatedValues-&gt;length(); ++i)
3413             integerRepeatedValues-&gt;append(*repeatedValues-&gt;itemWithoutBoundsCheck(i));
3414         list.append(integerRepeatedValues.releaseNonNull());
3415     }
3416     return true;
3417 }
3418 
3419 enum TrackListType { GridTemplate, GridTemplateNoRepeat, GridAuto };
3420 
3421 static RefPtr&lt;CSSValue&gt; consumeGridTrackList(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, TrackListType trackListType)
3422 {
3423     bool allowGridLineNames = trackListType != GridAuto;
3424     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();
<span class="line-added">3425     if (!allowGridLineNames &amp;&amp; range.peek().type() == LeftBracketToken)</span>
<span class="line-added">3426         return nullptr;</span>
3427     RefPtr&lt;CSSGridLineNamesValue&gt; lineNames = consumeGridLineNames(range);
<span class="line-modified">3428     if (lineNames)</span>


3429         values-&gt;append(lineNames.releaseNonNull());

3430 
3431     bool allowRepeat = trackListType == GridTemplate;
3432     bool seenAutoRepeat = false;
3433     bool allTracksAreFixedSized = true;
3434     do {
3435         bool isAutoRepeat;
3436         if (range.peek().functionId() == CSSValueRepeat) {
3437             if (!allowRepeat)
3438                 return nullptr;
3439             if (!consumeGridTrackRepeatFunction(range, cssParserMode, *values, isAutoRepeat, allTracksAreFixedSized))
3440                 return nullptr;
3441             if (isAutoRepeat &amp;&amp; seenAutoRepeat)
3442                 return nullptr;
3443             seenAutoRepeat = seenAutoRepeat || isAutoRepeat;
3444         } else if (RefPtr&lt;CSSValue&gt; value = consumeGridTrackSize(range, cssParserMode)) {
3445             if (allTracksAreFixedSized)
3446                 allTracksAreFixedSized = isGridTrackFixedSized(*value);
3447             values-&gt;append(value.releaseNonNull());
3448         } else {
3449             return nullptr;
3450         }
3451         if (seenAutoRepeat &amp;&amp; !allTracksAreFixedSized)
3452             return nullptr;
<span class="line-added">3453         if (!allowGridLineNames &amp;&amp; range.peek().type() == LeftBracketToken)</span>
<span class="line-added">3454             return nullptr;</span>
3455         lineNames = consumeGridLineNames(range);
<span class="line-modified">3456         if (lineNames)</span>


3457             values-&gt;append(lineNames.releaseNonNull());

3458     } while (!range.atEnd() &amp;&amp; range.peek().type() != DelimiterToken);
3459     return values;
3460 }
3461 
3462 static RefPtr&lt;CSSValue&gt; consumeGridTemplatesRowsOrColumns(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3463 {
3464     if (range.peek().id() == CSSValueNone)
3465         return consumeIdent(range);
3466     return consumeGridTrackList(range, cssParserMode, GridTemplate);
3467 }
3468 
3469 static RefPtr&lt;CSSValue&gt; consumeGridTemplateAreas(CSSParserTokenRange&amp; range)
3470 {
3471     if (range.peek().id() == CSSValueNone)
3472         return consumeIdent(range);
3473 
3474     NamedGridAreaMap gridAreaMap;
3475     size_t rowCount = 0;
3476     size_t columnCount = 0;
3477 
3478     while (range.peek().type() == StringToken) {
3479         if (!parseGridTemplateAreasRow(range.consumeIncludingWhitespace().value().toString(), gridAreaMap, rowCount, columnCount))
3480             return nullptr;
3481         ++rowCount;
3482     }
3483 
3484     if (rowCount == 0)
3485         return nullptr;
3486     ASSERT(columnCount);
3487     return CSSGridTemplateAreasValue::create(gridAreaMap, rowCount, columnCount);
3488 }
3489 
3490 static RefPtr&lt;CSSValue&gt; consumeLineBoxContain(CSSParserTokenRange&amp; range)
3491 {
3492     if (range.peek().id() == CSSValueNone)
3493         return consumeIdent(range);
3494 
<span class="line-modified">3495     OptionSet&lt;LineBoxContain&gt; lineBoxContain;</span>
3496 
3497     while (range.peek().type() == IdentToken) {
3498         auto id = range.peek().id();
3499         if (id == CSSValueBlock) {
<span class="line-modified">3500             if (lineBoxContain.contains(LineBoxContain::Block))</span>
3501                 return nullptr;
<span class="line-modified">3502             lineBoxContain.add(LineBoxContain::Block);</span>
3503         } else if (id == CSSValueInline) {
<span class="line-modified">3504             if (lineBoxContain.contains(LineBoxContain::Inline))</span>
3505                 return nullptr;
<span class="line-modified">3506             lineBoxContain.add(LineBoxContain::Inline);</span>
3507         } else if (id == CSSValueFont) {
<span class="line-modified">3508             if (lineBoxContain.contains(LineBoxContain::Font))</span>
3509                 return nullptr;
<span class="line-modified">3510             lineBoxContain.add(LineBoxContain::Font);</span>
3511         } else if (id == CSSValueGlyphs) {
<span class="line-modified">3512             if (lineBoxContain.contains(LineBoxContain::Glyphs))</span>
3513                 return nullptr;
<span class="line-modified">3514             lineBoxContain.add(LineBoxContain::Glyphs);</span>
3515         } else if (id == CSSValueReplaced) {
<span class="line-modified">3516             if (lineBoxContain.contains(LineBoxContain::Replaced))</span>
3517                 return nullptr;
<span class="line-modified">3518             lineBoxContain.add(LineBoxContain::Replaced);</span>
3519         } else if (id == CSSValueInlineBox) {
<span class="line-modified">3520             if (lineBoxContain.contains(LineBoxContain::InlineBox))</span>
3521                 return nullptr;
<span class="line-modified">3522             lineBoxContain.add(LineBoxContain::InlineBox);</span>
3523         } else if (id == CSSValueInitialLetter) {
<span class="line-modified">3524             if (lineBoxContain.contains(LineBoxContain::InitialLetter))</span>
3525                 return nullptr;
<span class="line-modified">3526             lineBoxContain.add(LineBoxContain::InitialLetter);</span>
3527         } else
3528             return nullptr;
3529         range.consumeIncludingWhitespace();
3530     }
3531 
3532     if (!lineBoxContain)
3533         return nullptr;
3534 
3535     return CSSLineBoxContainValue::create(lineBoxContain);
3536 }
3537 
3538 static RefPtr&lt;CSSValue&gt; consumeLineGrid(CSSParserTokenRange&amp; range)
3539 {
3540     if (range.peek().id() == CSSValueNone)
3541         return consumeIdent(range);
3542     return consumeCustomIdent(range);
3543 }
3544 
3545 static RefPtr&lt;CSSValue&gt; consumeInitialLetter(CSSParserTokenRange&amp; range)
3546 {
</pre>
<hr />
<pre>
3637         case CSSValueForceEnd:
3638             seenForceEnd = true;
3639             break;
3640         case CSSValueFirst:
3641             seenFirst = true;
3642             break;
3643         case CSSValueLast:
3644             seenLast = true;
3645             break;
3646         default:
3647             break;
3648         }
3649         list-&gt;append(ident.releaseNonNull());
3650     }
3651 
3652     return list-&gt;length() ? list : nullptr;
3653 }
3654 
3655 static RefPtr&lt;CSSValue&gt; consumeWebkitMarqueeIncrement(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3656 {


3657     return consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
3658 }
3659 
3660 static RefPtr&lt;CSSValue&gt; consumeWebkitMarqueeRepetition(CSSParserTokenRange&amp; range)
3661 {


3662     return consumeNumber(range, ValueRangeNonNegative);
3663 }
3664 
3665 static RefPtr&lt;CSSValue&gt; consumeWebkitMarqueeSpeed(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3666 {


3667     return consumeTime(range, cssParserMode, ValueRangeNonNegative, UnitlessQuirk::Allow);
3668 }
3669 
3670 static RefPtr&lt;CSSValue&gt; consumeAlt(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
3671 {
3672     if (range.peek().type() == StringToken)
3673         return consumeString(range);
3674 
3675     if (range.peek().functionId() != CSSValueAttr)
3676         return nullptr;
3677 
3678     return consumeAttr(consumeFunction(range), context);
3679 }
3680 
3681 static RefPtr&lt;CSSValue&gt; consumeWebkitAspectRatio(CSSParserTokenRange&amp; range)
3682 {
3683     if (range.peek().type() == IdentToken)
3684         return consumeIdent&lt;CSSValueAuto, CSSValueFromDimensions, CSSValueFromIntrinsic&gt;(range);
3685 
3686     RefPtr&lt;CSSPrimitiveValue&gt; leftValue = consumeNumber(range, ValueRangeNonNegative);
<span class="line-modified">3687     if (!leftValue || leftValue-&gt;isZero().valueOr(false) || range.atEnd() || !consumeSlashIncludingWhitespace(range))</span>
3688         return nullptr;
<span class="line-added">3689 </span>
3690     RefPtr&lt;CSSPrimitiveValue&gt; rightValue = consumeNumber(range, ValueRangeNonNegative);
<span class="line-modified">3691     if (!rightValue || rightValue-&gt;isZero().valueOr(false))</span>
3692         return nullptr;
3693 
3694     return CSSAspectRatioValue::create(leftValue-&gt;floatValue(), rightValue-&gt;floatValue());
3695 }
3696 
3697 static RefPtr&lt;CSSValue&gt; consumeTextEmphasisPosition(CSSParserTokenRange&amp; range)
3698 {
3699     bool foundOverOrUnder = false;
3700     CSSValueID overUnderValueID = CSSValueOver;
3701     bool foundLeftOrRight = false;
3702     CSSValueID leftRightValueID = CSSValueRight;
3703     while (!range.atEnd()) {
3704         switch (range.peek().id()) {
3705         case CSSValueOver:
3706             if (foundOverOrUnder)
3707                 return nullptr;
3708             foundOverOrUnder = true;
3709             overUnderValueID = CSSValueOver;
3710             break;
3711         case CSSValueUnder:
</pre>
<hr />
<pre>
3901     case CSSPropertyPaddingInlineEnd:
3902     case CSSPropertyPaddingBlockStart:
3903     case CSSPropertyPaddingBlockEnd:
3904         return consumeLengthOrPercent(m_range, m_context.mode, ValueRangeNonNegative, UnitlessQuirk::Forbid);
3905 #if ENABLE(CSS_SCROLL_SNAP)
3906     case CSSPropertyScrollSnapMarginBottom:
3907     case CSSPropertyScrollSnapMarginLeft:
3908     case CSSPropertyScrollSnapMarginRight:
3909     case CSSPropertyScrollSnapMarginTop:
3910         return consumeLength(m_range, m_context.mode, ValueRangeAll);
3911     case CSSPropertyScrollPaddingBottom:
3912     case CSSPropertyScrollPaddingLeft:
3913     case CSSPropertyScrollPaddingRight:
3914     case CSSPropertyScrollPaddingTop:
3915         return consumeLengthOrPercent(m_range, m_context.mode, ValueRangeAll);
3916     case CSSPropertyScrollSnapAlign:
3917         return consumeScrollSnapAlign(m_range);
3918     case CSSPropertyScrollSnapType:
3919         return consumeScrollSnapType(m_range);
3920 #endif
<span class="line-added">3921     case CSSPropertyScrollBehavior:</span>
<span class="line-added">3922         if (!m_context.scrollBehaviorEnabled)</span>
<span class="line-added">3923             return nullptr;</span>
<span class="line-added">3924         return consumeScrollBehavior(m_range);</span>
3925     case CSSPropertyClip:
3926         return consumeClip(m_range, m_context.mode);
3927 #if ENABLE(POINTER_EVENTS)
3928     case CSSPropertyTouchAction:
3929         return consumeTouchAction(m_range);
3930 #endif
3931     case CSSPropertyObjectPosition:
<span class="line-modified">3932         return consumePosition(m_range, m_context.mode, UnitlessQuirk::Forbid, PositionSyntax::Position);</span>
3933     case CSSPropertyWebkitLineClamp:
3934         return consumeLineClamp(m_range);
3935     case CSSPropertyWebkitFontSizeDelta:
3936         return consumeLength(m_range, m_context.mode, ValueRangeAll, UnitlessQuirk::Allow);
3937     case CSSPropertyWebkitHyphenateCharacter:
3938     case CSSPropertyWebkitLocale:
3939         return consumeAutoOrString(m_range);
3940     case CSSPropertyWebkitHyphenateLimitBefore:
3941     case CSSPropertyWebkitHyphenateLimitAfter:
3942         return consumeHyphenateLimit(m_range, CSSValueAuto);
3943     case CSSPropertyWebkitHyphenateLimitLines:
3944         return consumeHyphenateLimit(m_range, CSSValueNoLimit);
3945     case CSSPropertyColumnWidth:
3946         return consumeColumnWidth(m_range);
3947     case CSSPropertyColumnCount:
3948         return consumeColumnCount(m_range);
3949     case CSSPropertyColumnGap:
3950         return consumeGapLength(m_range, m_context.mode);
3951     case CSSPropertyRowGap:
3952         return consumeGapLength(m_range, m_context.mode);
</pre>
<hr />
<pre>
4037         return consumeFilter(m_range, m_context, AllowedFilterFunctions::PixelFilters);
4038     case CSSPropertyAppleColorFilter:
4039         if (!m_context.colorFilterEnabled)
4040             return nullptr;
4041         return consumeFilter(m_range, m_context, AllowedFilterFunctions::ColorFilters);
4042     case CSSPropertyTextDecoration:
4043     case CSSPropertyWebkitTextDecorationsInEffect:
4044     case CSSPropertyTextDecorationLine:
4045         return consumeTextDecorationLine(m_range);
4046     case CSSPropertyWebkitTextEmphasisStyle:
4047         return consumeTextEmphasisStyle(m_range);
4048     case CSSPropertyOutlineColor:
4049         return consumeOutlineColor(m_range, m_context.mode);
4050     case CSSPropertyOutlineOffset:
4051         return consumeLength(m_range, m_context.mode, ValueRangeAll);
4052     case CSSPropertyOutlineWidth:
4053         return consumeLineWidth(m_range, m_context.mode, UnitlessQuirk::Forbid);
4054     case CSSPropertyTransform:
4055         return consumeTransform(m_range, m_context.mode);
4056     case CSSPropertyTransformBox:
<span class="line-modified">4057         return consumeIdent&lt;CSSValueBorderBox, CSSValueViewBox, CSSValueFillBox, CSSValueStrokeBox, CSSValueContentBox&gt;(m_range);</span>
4058     case CSSPropertyTransformOriginX:
4059     case CSSPropertyPerspectiveOriginX:
4060         return consumePositionX(m_range, m_context.mode);
4061     case CSSPropertyTransformOriginY:
4062     case CSSPropertyPerspectiveOriginY:
4063         return consumePositionY(m_range, m_context.mode);
4064     case CSSPropertyTransformOriginZ:
4065         return consumeLength(m_range, m_context.mode, ValueRangeAll);
4066     case CSSPropertyFill:
4067     case CSSPropertyStroke:
4068         return consumePaintStroke(m_range, m_context.mode);
4069     case CSSPropertyGlyphOrientationVertical:
4070     case CSSPropertyGlyphOrientationHorizontal:
4071         return consumeGlyphOrientation(m_range, m_context.mode, property);
4072     case CSSPropertyPaintOrder:
4073         return consumePaintOrder(m_range);
4074     case CSSPropertyMarkerStart:
4075     case CSSPropertyMarkerMid:
4076     case CSSPropertyMarkerEnd:

4077     case CSSPropertyMask:
4078         return consumeNoneOrURI(m_range);
4079     case CSSPropertyFlexBasis:
4080         return consumeFlexBasis(m_range, m_context.mode);
4081     case CSSPropertyFlexGrow:
4082     case CSSPropertyFlexShrink:
4083         return consumeNumber(m_range, ValueRangeNonNegative);
4084     case CSSPropertyStrokeDasharray:
4085         return consumeStrokeDasharray(m_range);
4086     case CSSPropertyColumnRuleWidth:
4087         return consumeColumnRuleWidth(m_range, m_context.mode);
4088     case CSSPropertyStrokeOpacity:
4089     case CSSPropertyFillOpacity:
4090     case CSSPropertyStopOpacity:
4091     case CSSPropertyFloodOpacity:
4092     case CSSPropertyOpacity:
<span class="line-added">4093     {</span>
<span class="line-added">4094         RefPtr&lt;CSSValue&gt; parsedValue = consumeNumber(m_range, ValueRangeAll);</span>
<span class="line-added">4095         if (parsedValue)</span>
<span class="line-added">4096             return parsedValue;</span>
<span class="line-added">4097         return consumePercent(m_range, ValueRangeAll);</span>
<span class="line-added">4098     }</span>
4099     case CSSPropertyWebkitBoxFlex:
4100         return consumeNumber(m_range, ValueRangeAll);
4101     case CSSPropertyBaselineShift:
4102         return consumeBaselineShift(m_range);
4103     case CSSPropertyKerning:
4104         return consumeKerning(m_range, m_context.mode);
4105     case CSSPropertyStrokeMiterlimit:
4106         return consumeNumber(m_range, ValueRangeNonNegative);
4107     case CSSPropertyStrokeWidth:
4108     case CSSPropertyStrokeDashoffset:
4109     case CSSPropertyCx:
4110     case CSSPropertyCy:
4111     case CSSPropertyX:
4112     case CSSPropertyY:

4113         return consumeLengthOrPercent(m_range, SVGAttributeMode, ValueRangeAll, UnitlessQuirk::Forbid);
<span class="line-added">4114     case CSSPropertyR:</span>
<span class="line-added">4115         return consumeLengthOrPercent(m_range, m_context.mode, ValueRangeNonNegative, UnitlessQuirk::Forbid);</span>
4116     case CSSPropertyRx:
4117     case CSSPropertyRy:
<span class="line-modified">4118         return consumeRxOrRy(m_range, m_context.mode);</span>
4119     case CSSPropertyCursor:
4120         return consumeCursor(m_range, m_context, inQuirksMode());
4121     case CSSPropertyContent:
4122         return consumeContent(m_range, m_context);
4123     case CSSPropertyListStyleImage:
4124     case CSSPropertyBorderImageSource:
4125     case CSSPropertyWebkitMaskBoxImageSource:
4126         return consumeImageOrNone(m_range, m_context);
4127     case CSSPropertyPerspective:
4128         return consumePerspective(m_range, m_context.mode);
4129     case CSSPropertyBorderTopRightRadius:
4130     case CSSPropertyBorderTopLeftRadius:
4131     case CSSPropertyBorderBottomLeftRadius:
4132     case CSSPropertyBorderBottomRightRadius:
4133         return consumeBorderRadiusCorner(m_range, m_context.mode);
4134     case CSSPropertyWebkitBoxFlexGroup:
4135         return consumeInteger(m_range, 0);
4136     case CSSPropertyOrder:
4137         return consumeInteger(m_range);
4138     case CSSPropertyTextUnderlinePosition:
4139         // auto | [ [ under | from-font ] || [ left | right ] ], but we only support auto | under | from-font for now
4140         return consumeIdent&lt;CSSValueAuto, CSSValueUnder, CSSValueFromFont&gt;(m_range);
4141     case CSSPropertyTextUnderlineOffset:
4142         return consumeTextUnderlineOffset(m_range, m_context.mode);
4143     case CSSPropertyTextDecorationThickness:
4144         return consumeTextDecorationThickness(m_range, m_context.mode);
4145     case CSSPropertyVerticalAlign:
4146         return consumeVerticalAlign(m_range, m_context.mode);
4147     case CSSPropertyShapeOutside:
4148         return consumeShapeOutside(m_range, m_context);
<span class="line-modified">4149     case CSSPropertyClipPath:</span>
<span class="line-modified">4150         return consumeClipPath(m_range, m_context);</span>
4151     case CSSPropertyJustifyContent:
4152         // justify-content property does not allow the &lt;baseline-position&gt; values.
4153         if (isBaselineKeyword(m_range.peek().id()))
4154             return nullptr;
4155         return consumeContentDistributionOverflowPosition(m_range, isContentPositionOrLeftOrRightKeyword);
4156     case CSSPropertyAlignContent:
4157         return consumeContentDistributionOverflowPosition(m_range, isContentPositionKeyword);
4158     case CSSPropertyBorderImageRepeat:
4159     case CSSPropertyWebkitMaskBoxImageRepeat:
4160         return consumeBorderImageRepeat(m_range);
4161     case CSSPropertyBorderImageSlice:
4162     case CSSPropertyWebkitMaskBoxImageSlice:
4163         return consumeBorderImageSlice(property, m_range);
4164     case CSSPropertyBorderImageOutset:
4165     case CSSPropertyWebkitMaskBoxImageOutset:
4166         return consumeBorderImageOutset(m_range);
4167     case CSSPropertyBorderImageWidth:
4168     case CSSPropertyWebkitMaskBoxImageWidth:
4169         return consumeBorderImageWidth(m_range);
4170     case CSSPropertyWebkitBorderImage:
4171     case CSSPropertyWebkitMaskBoxImage:
4172         return consumeWebkitBorderImage(property, m_range, m_context);
4173     case CSSPropertyWebkitBoxReflect:
4174         return consumeReflect(m_range, m_context);
4175     case CSSPropertyWebkitLineBoxContain:
4176         return consumeLineBoxContain(m_range);




4177     case CSSPropertyBackgroundAttachment:
4178     case CSSPropertyBackgroundBlendMode:
4179     case CSSPropertyBackgroundClip:
4180     case CSSPropertyBackgroundImage:
4181     case CSSPropertyBackgroundOrigin:
4182     case CSSPropertyBackgroundPositionX:
4183     case CSSPropertyBackgroundPositionY:
4184     case CSSPropertyBackgroundSize:
4185     case CSSPropertyWebkitBackgroundClip:
4186     case CSSPropertyWebkitBackgroundOrigin:
4187     case CSSPropertyWebkitBackgroundComposite:
4188     case CSSPropertyWebkitBackgroundSize:
4189     case CSSPropertyWebkitMaskClip:
4190     case CSSPropertyWebkitMaskComposite:
4191     case CSSPropertyWebkitMaskImage:
4192     case CSSPropertyWebkitMaskOrigin:
4193     case CSSPropertyWebkitMaskPositionX:
4194     case CSSPropertyWebkitMaskPositionY:
4195     case CSSPropertyWebkitMaskSize:
4196     case CSSPropertyWebkitMaskSourceType:
</pre>
<hr />
<pre>
4274     }
4275 
4276     return true;
4277 }
4278 
4279 void CSSPropertyParser::collectParsedCustomPropertyValueDependencies(const String&amp; syntax, bool isRoot, HashSet&lt;CSSPropertyID&gt;&amp; dependencies)
4280 {
4281     if (syntax != &quot;*&quot;) {
4282         m_range.consumeWhitespace();
4283         auto primitiveVal = consumeWidthOrHeight(m_range, m_context);
4284         if (!m_range.atEnd())
4285             return;
4286         if (primitiveVal &amp;&amp; primitiveVal-&gt;isPrimitiveValue()) {
4287             primitiveVal-&gt;collectDirectComputationalDependencies(dependencies);
4288             if (isRoot)
4289                 primitiveVal-&gt;collectDirectRootComputationalDependencies(dependencies);
4290         }
4291     }
4292 }
4293 
<span class="line-modified">4294 RefPtr&lt;CSSCustomPropertyValue&gt; CSSPropertyParser::parseTypedCustomPropertyValue(const String&amp; name, const String&amp; syntax, const Style::BuilderState&amp; builderState)</span>
4295 {
4296     if (syntax != &quot;*&quot;) {
4297         m_range.consumeWhitespace();
4298         auto primitiveVal = consumeWidthOrHeight(m_range, m_context);
4299         if (primitiveVal &amp;&amp; primitiveVal-&gt;isPrimitiveValue() &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(*primitiveVal).isLength()) {
<span class="line-modified">4300             auto length = Style::BuilderConverter::convertLength(builderState, *primitiveVal);</span>
4301             if (!length.isCalculated() &amp;&amp; !length.isUndefined())
4302                 return CSSCustomPropertyValue::createSyntaxLength(name, WTFMove(length));
4303         }
4304     } else {
4305         auto propertyValue = CSSCustomPropertyValue::createSyntaxAll(name, CSSVariableData::create(m_range));
4306         while (!m_range.atEnd())
4307             m_range.consume();
4308         return { WTFMove(propertyValue) };
4309     }
4310 
4311     return nullptr;
4312 }
4313 
4314 static RefPtr&lt;CSSValueList&gt; consumeFontFaceUnicodeRange(CSSParserTokenRange&amp; range)
4315 {
4316     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createCommaSeparated();
4317 
4318     do {
4319         const CSSParserToken&amp; token = range.consumeIncludingWhitespace();
4320         if (token.type() != UnicodeRangeToken)
</pre>
<hr />
<pre>
4463         return false;
4464 
4465     addProperty(propId, CSSPropertyInvalid, *parsedValue, false);
4466     return true;
4467 }
4468 
4469 bool CSSPropertyParser::consumeSystemFont(bool important)
4470 {
4471     CSSValueID systemFontID = m_range.consumeIncludingWhitespace().id();
4472     ASSERT(systemFontID &gt;= CSSValueCaption &amp;&amp; systemFontID &lt;= CSSValueStatusBar);
4473     if (!m_range.atEnd())
4474         return false;
4475 
4476     FontCascadeDescription fontDescription;
4477     RenderTheme::singleton().systemFont(systemFontID, fontDescription);
4478     if (!fontDescription.isAbsoluteSize())
4479         return false;
4480 
4481     addProperty(CSSPropertyFontStyle, CSSPropertyFont, CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(isItalic(fontDescription.italic()) ? CSSValueItalic : CSSValueNormal)), important);
4482     addProperty(CSSPropertyFontWeight, CSSPropertyFont, CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(fontDescription.weight())), important);
<span class="line-modified">4483     addProperty(CSSPropertyFontSize, CSSPropertyFont, CSSValuePool::singleton().createValue(fontDescription.specifiedSize(), CSSUnitType::CSS_PX), important);</span>
4484     Ref&lt;CSSValueList&gt; fontFamilyList = CSSValueList::createCommaSeparated();
4485     fontFamilyList-&gt;append(CSSValuePool::singleton().createFontFamilyValue(fontDescription.familyAt(0), FromSystemFontID::Yes));
4486     addProperty(CSSPropertyFontFamily, CSSPropertyFont, WTFMove(fontFamilyList), important);
4487     addProperty(CSSPropertyFontVariantCaps, CSSPropertyFont, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4488     addProperty(CSSPropertyLineHeight, CSSPropertyFont, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4489 
4490     // FIXME_NEWPARSER: What about FontVariantNumeric and FontVariantLigatures?
4491 
4492     return true;
4493 }
4494 
4495 bool CSSPropertyParser::consumeFont(bool important)
4496 {
4497     // Let&#39;s check if there is an inherit or initial somewhere in the shorthand.
4498     CSSParserTokenRange range = m_range;
4499     while (!range.atEnd()) {
4500         CSSValueID id = range.consumeIncludingWhitespace().id();
4501         if (id == CSSValueInherit || id == CSSValueInitial)
4502             return false;
4503     }
</pre>
<hr />
<pre>
4832     double flexShrink = unsetValue;
4833     RefPtr&lt;CSSPrimitiveValue&gt; flexBasis;
4834 
4835     if (m_range.peek().id() == CSSValueNone) {
4836         flexGrow = 0;
4837         flexShrink = 0;
4838         flexBasis = CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
4839         m_range.consumeIncludingWhitespace();
4840     } else {
4841         unsigned index = 0;
4842         while (!m_range.atEnd() &amp;&amp; index++ &lt; 3) {
4843             double num;
4844             if (consumeNumberRaw(m_range, num)) {
4845                 if (num &lt; 0)
4846                     return false;
4847                 if (flexGrow == unsetValue)
4848                     flexGrow = num;
4849                 else if (flexShrink == unsetValue)
4850                     flexShrink = num;
4851                 else if (!num) // flex only allows a basis of 0 (sans units) if flex-grow and flex-shrink values have already been set.
<span class="line-modified">4852                     flexBasis = CSSPrimitiveValue::create(0, CSSUnitType::CSS_PX);</span>
4853                 else
4854                     return false;
4855             } else if (!flexBasis) {
4856                 if (m_range.peek().id() == CSSValueAuto)
4857                     flexBasis = consumeIdent(m_range);
4858                 if (!flexBasis)
4859                     flexBasis = consumeLengthOrPercent(m_range, m_context.mode, ValueRangeNonNegative);
4860                 if (index == 2 &amp;&amp; !m_range.atEnd())
4861                     return false;
4862             }
4863         }
4864         if (index == 0)
4865             return false;
4866         if (flexGrow == unsetValue)
4867             flexGrow = 1;
4868         if (flexShrink == unsetValue)
4869             flexShrink = 1;
4870 
4871         // FIXME: Using % here is a hack to work around intrinsic sizing implementation being
4872         // a mess (e.g., turned off for nested column flexboxes, failing to relayout properly even
4873         // if turned back on for nested columns, etc.). We have layout test coverage of both
4874         // scenarios.
4875         if (!flexBasis)
<span class="line-modified">4876             flexBasis = CSSPrimitiveValue::create(0, CSSUnitType::CSS_PERCENTAGE);</span>
4877     }
4878 
4879     if (!m_range.atEnd())
4880         return false;
<span class="line-modified">4881     addProperty(CSSPropertyFlexGrow, CSSPropertyFlex, CSSPrimitiveValue::create(clampTo&lt;float&gt;(flexGrow), CSSUnitType::CSS_NUMBER), important);</span>
<span class="line-modified">4882     addProperty(CSSPropertyFlexShrink, CSSPropertyFlex, CSSPrimitiveValue::create(clampTo&lt;float&gt;(flexShrink), CSSUnitType::CSS_NUMBER), important);</span>
4883     addProperty(CSSPropertyFlexBasis, CSSPropertyFlex, flexBasis.releaseNonNull(), important);
4884     return true;
4885 }
4886 
4887 bool CSSPropertyParser::consumeBorder(RefPtr&lt;CSSValue&gt;&amp; width, RefPtr&lt;CSSValue&gt;&amp; style, RefPtr&lt;CSSValue&gt;&amp; color)
4888 {
4889     while (!width || !style || !color) {
4890         if (!width) {
4891             width = consumeLineWidth(m_range, m_context.mode, UnitlessQuirk::Forbid);
4892             if (width)
4893                 continue;
4894         }
4895         if (!style) {
4896             style = parseSingleValue(CSSPropertyBorderLeftStyle, CSSPropertyBorder);
4897             if (style)
4898                 continue;
4899         }
4900         if (!color) {
4901             color = consumeColor(m_range, m_context.mode);
4902             if (color)
</pre>
<hr />
<pre>
5074     case CSSPropertyPageBreakInside:
5075     case CSSPropertyWebkitColumnBreakInside:
5076         value = mapFromColumnRegionOrPageBreakInside(value);
5077         break;
5078     default:
5079         ASSERT_NOT_REACHED();
5080     }
5081     if (value == CSSValueInvalid)
5082         return false;
5083 
5084     CSSPropertyID genericBreakProperty = mapFromLegacyBreakProperty(property);
5085     addProperty(genericBreakProperty, property, CSSValuePool::singleton().createIdentifierValue(value), important);
5086     return true;
5087 }
5088 
5089 static bool consumeBackgroundPosition(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, UnitlessQuirk unitless, RefPtr&lt;CSSValue&gt;&amp; resultX, RefPtr&lt;CSSValue&gt;&amp; resultY)
5090 {
5091     do {
5092         RefPtr&lt;CSSPrimitiveValue&gt; positionX;
5093         RefPtr&lt;CSSPrimitiveValue&gt; positionY;
<span class="line-modified">5094         if (!consumePosition(range, context.mode, unitless, PositionSyntax::BackgroundPosition, positionX, positionY))</span>
5095             return false;
5096         addBackgroundValue(resultX, positionX.releaseNonNull());
5097         addBackgroundValue(resultY, positionY.releaseNonNull());
5098     } while (consumeCommaIncludingWhitespace(range));
5099     return true;
5100 }
5101 
5102 static bool consumeRepeatStyleComponent(CSSParserTokenRange&amp; range, RefPtr&lt;CSSPrimitiveValue&gt;&amp; value1, RefPtr&lt;CSSPrimitiveValue&gt;&amp; value2, bool&amp; implicit)
5103 {
5104     if (consumeIdent&lt;CSSValueRepeatX&gt;(range)) {
5105         value1 = CSSValuePool::singleton().createIdentifierValue(CSSValueRepeat);
5106         value2 = CSSValuePool::singleton().createIdentifierValue(CSSValueNoRepeat);
5107         implicit = true;
5108         return true;
5109     }
5110     if (consumeIdent&lt;CSSValueRepeatY&gt;(range)) {
5111         value1 = CSSValuePool::singleton().createIdentifierValue(CSSValueNoRepeat);
5112         value2 = CSSValuePool::singleton().createIdentifierValue(CSSValueRepeat);
5113         implicit = true;
5114         return true;
</pre>
<hr />
<pre>
5152         RefPtr&lt;CSSValue&gt; originValue;
5153         do {
5154             bool foundProperty = false;
5155             for (size_t i = 0; i &lt; longhandCount; ++i) {
5156                 if (parsedLonghand[i])
5157                     continue;
5158 
5159                 RefPtr&lt;CSSValue&gt; value;
5160                 RefPtr&lt;CSSValue&gt; valueY;
5161                 CSSPropertyID property = shorthand.properties()[i];
5162                 if (property == CSSPropertyBackgroundRepeatX || property == CSSPropertyWebkitMaskRepeatX) {
5163                     RefPtr&lt;CSSPrimitiveValue&gt; primitiveValue;
5164                     RefPtr&lt;CSSPrimitiveValue&gt; primitiveValueY;
5165                     consumeRepeatStyleComponent(m_range, primitiveValue, primitiveValueY, implicit);
5166                     value = primitiveValue;
5167                     valueY = primitiveValueY;
5168                 } else if (property == CSSPropertyBackgroundPositionX || property == CSSPropertyWebkitMaskPositionX) {
5169                     CSSParserTokenRange rangeCopy = m_range;
5170                     RefPtr&lt;CSSPrimitiveValue&gt; primitiveValue;
5171                     RefPtr&lt;CSSPrimitiveValue&gt; primitiveValueY;
<span class="line-modified">5172                     if (!consumePosition(rangeCopy, m_context.mode, UnitlessQuirk::Forbid, PositionSyntax::BackgroundPosition, primitiveValue, primitiveValueY))</span>
5173                         continue;
5174                     value = primitiveValue;
5175                     valueY = primitiveValueY;
5176                     m_range = rangeCopy;
5177                 } else if (property == CSSPropertyBackgroundSize || property == CSSPropertyWebkitMaskSize) {
5178                     if (!consumeSlashIncludingWhitespace(m_range))
5179                         continue;
5180                     value = consumeBackgroundSize(property, m_range, m_context.mode);
5181                     if (!value || !parsedLonghand[i - 1]) // Position must have been parsed in the current layer.
5182                         return false;
5183                 } else if (property == CSSPropertyBackgroundPositionY || property == CSSPropertyBackgroundRepeatY
5184                     || property == CSSPropertyWebkitMaskPositionY || property == CSSPropertyWebkitMaskRepeatY) {
5185                     continue;
5186                 } else {
5187                     value = consumeBackgroundComponent(property, m_range, m_context);
5188                 }
5189                 if (value) {
5190                     if (property == CSSPropertyBackgroundOrigin || property == CSSPropertyWebkitMaskOrigin)
5191                         originValue = value;
5192                     parsedLonghand[i] = true;
</pre>
<hr />
<pre>
5213             if ((property == CSSPropertyBackgroundClip || property == CSSPropertyWebkitMaskClip) &amp;&amp; !parsedLonghand[i] &amp;&amp; originValue) {
5214                 addBackgroundValue(longhands[i], originValue.releaseNonNull());
5215                 continue;
5216             }
5217             if (!parsedLonghand[i])
5218                 addBackgroundValue(longhands[i], CSSValuePool::singleton().createImplicitInitialValue());
5219         }
5220     } while (consumeCommaIncludingWhitespace(m_range));
5221     if (!m_range.atEnd())
5222         return false;
5223 
5224     for (size_t i = 0; i &lt; longhandCount; ++i) {
5225         CSSPropertyID property = shorthand.properties()[i];
5226         if (property == CSSPropertyBackgroundSize &amp;&amp; longhands[i] &amp;&amp; m_context.useLegacyBackgroundSizeShorthandBehavior)
5227             continue;
5228         addProperty(property, shorthand.id(), *longhands[i], important, implicit);
5229     }
5230     return true;
5231 }
5232 
<span class="line-added">5233 bool CSSPropertyParser::consumeOverflowShorthand(bool important)</span>
<span class="line-added">5234 {</span>
<span class="line-added">5235     CSSValueID xValueID = m_range.consumeIncludingWhitespace().id();</span>
<span class="line-added">5236     if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyOverflowY, xValueID, m_context))</span>
<span class="line-added">5237         return false;</span>
<span class="line-added">5238 </span>
<span class="line-added">5239     CSSValueID yValueID;</span>
<span class="line-added">5240     if (m_range.atEnd()) {</span>
<span class="line-added">5241         yValueID = xValueID;</span>
<span class="line-added">5242 </span>
<span class="line-added">5243         // FIXME: -webkit-paged-x or -webkit-paged-y only apply to overflow-y. If this value has been</span>
<span class="line-added">5244         // set using the shorthand, then for now overflow-x will default to auto, but once we implement</span>
<span class="line-added">5245         // pagination controls, it should default to hidden. If the overflow-y value is anything but</span>
<span class="line-added">5246         // paged-x or paged-y, then overflow-x and overflow-y should have the same value.</span>
<span class="line-added">5247         if (xValueID == CSSValueWebkitPagedX || xValueID == CSSValueWebkitPagedY)</span>
<span class="line-added">5248             xValueID = CSSValueAuto;</span>
<span class="line-added">5249     } else</span>
<span class="line-added">5250         yValueID = m_range.consumeIncludingWhitespace().id();</span>
<span class="line-added">5251 </span>
<span class="line-added">5252     if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyOverflowY, yValueID, m_context))</span>
<span class="line-added">5253         return false;</span>
<span class="line-added">5254     if (!m_range.atEnd())</span>
<span class="line-added">5255         return false;</span>
<span class="line-added">5256 </span>
<span class="line-added">5257     addProperty(CSSPropertyOverflowX, CSSPropertyOverflow, CSSValuePool::singleton().createIdentifierValue(xValueID), important);</span>
<span class="line-added">5258     addProperty(CSSPropertyOverflowY, CSSPropertyOverflow, CSSValuePool::singleton().createIdentifierValue(yValueID), important);</span>
<span class="line-added">5259     return true;</span>
<span class="line-added">5260 }</span>
<span class="line-added">5261 </span>
5262 // FIXME-NEWPARSER: Hack to work around the fact that we aren&#39;t using CSSCustomIdentValue
5263 // for stuff yet. This can be replaced by CSSValue::isCustomIdentValue() once we switch
5264 // to using CSSCustomIdentValue everywhere.
5265 static bool isCustomIdentValue(const CSSValue&amp; value)
5266 {
5267     return is&lt;CSSPrimitiveValue&gt;(value) &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(value).isString();
5268 }
5269 
5270 bool CSSPropertyParser::consumeGridItemPositionShorthand(CSSPropertyID shorthandId, bool important)
5271 {
5272     const StylePropertyShorthand&amp; shorthand = shorthandForProperty(shorthandId);
5273     ASSERT(shorthand.length() == 2);
5274     RefPtr&lt;CSSValue&gt; startValue = consumeGridLine(m_range);
5275     if (!startValue)
5276         return false;
5277 
5278     RefPtr&lt;CSSValue&gt; endValue;
5279     if (consumeSlashIncludingWhitespace(m_range)) {
5280         endValue = consumeGridLine(m_range);
5281         if (!endValue)
</pre>
<hr />
<pre>
5601 }
5602 
5603 bool CSSPropertyParser::parseShorthand(CSSPropertyID property, bool important)
5604 {
5605     switch (property) {
5606     case CSSPropertyWebkitMarginCollapse: {
5607         CSSValueID id = m_range.consumeIncludingWhitespace().id();
5608         if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyWebkitMarginBeforeCollapse, id, m_context))
5609             return false;
5610         addProperty(CSSPropertyWebkitMarginBeforeCollapse, CSSPropertyWebkitMarginCollapse, CSSValuePool::singleton().createIdentifierValue(id), important);
5611         if (m_range.atEnd()) {
5612             addProperty(CSSPropertyWebkitMarginAfterCollapse, CSSPropertyWebkitMarginCollapse, CSSValuePool::singleton().createIdentifierValue(id), important);
5613             return true;
5614         }
5615         id = m_range.consumeIncludingWhitespace().id();
5616         if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyWebkitMarginAfterCollapse, id, m_context))
5617             return false;
5618         addProperty(CSSPropertyWebkitMarginAfterCollapse, CSSPropertyWebkitMarginCollapse, CSSValuePool::singleton().createIdentifierValue(id), important);
5619         return true;
5620     }
<span class="line-modified">5621     case CSSPropertyOverflow:</span>
<span class="line-modified">5622         return consumeOverflowShorthand(important);</span>



















5623     case CSSPropertyFont: {
5624         const CSSParserToken&amp; token = m_range.peek();
5625         if (token.id() &gt;= CSSValueCaption &amp;&amp; token.id() &lt;= CSSValueStatusBar)
5626             return consumeSystemFont(important);
5627         return consumeFont(important);
5628     }
5629     case CSSPropertyFontVariant:
5630         return consumeFontVariantShorthand(important);
5631     case CSSPropertyBorderSpacing:
5632         return consumeBorderSpacing(important);
5633     case CSSPropertyColumns:
5634         return consumeColumns(important);
5635     case CSSPropertyAnimation:
5636         return consumeAnimationShorthand(animationShorthandForParsing(), important);
5637     case CSSPropertyTransition:
5638         return consumeAnimationShorthand(transitionShorthandForParsing(), important);
5639     case CSSPropertyTextDecoration:
5640     case CSSPropertyWebkitTextDecoration:
5641         // FIXME-NEWPARSER: We need to unprefix -line/-style/-color ASAP and get rid
5642         // of -webkit-text-decoration completely.
</pre>
<hr />
<pre>
5819             columnGap = rowGap;
5820         addProperty(CSSPropertyRowGap, CSSPropertyGap, rowGap.releaseNonNull(), important);
5821         addProperty(CSSPropertyColumnGap, CSSPropertyGap, columnGap.releaseNonNull(), important);
5822         return true;
5823     }
5824     case CSSPropertyGridColumn:
5825     case CSSPropertyGridRow:
5826         return consumeGridItemPositionShorthand(property, important);
5827     case CSSPropertyGridArea:
5828         return consumeGridAreaShorthand(important);
5829     case CSSPropertyGridTemplate:
5830         return consumeGridTemplateShorthand(CSSPropertyGridTemplate, important);
5831     case CSSPropertyGrid:
5832         return consumeGridShorthand(important);
5833     case CSSPropertyPlaceContent:
5834         return consumePlaceContentShorthand(important);
5835     case CSSPropertyPlaceItems:
5836         return consumePlaceItemsShorthand(important);
5837     case CSSPropertyPlaceSelf:
5838         return consumePlaceSelfShorthand(important);


5839     default:
5840         return false;
5841     }
5842 }
5843 
5844 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="CSSParserToken.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSPropertyParser.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
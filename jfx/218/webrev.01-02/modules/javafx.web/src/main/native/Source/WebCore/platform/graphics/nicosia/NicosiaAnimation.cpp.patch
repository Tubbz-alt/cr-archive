diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/nicosia/NicosiaAnimation.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/nicosia/NicosiaAnimation.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/nicosia/NicosiaAnimation.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/nicosia/NicosiaAnimation.cpp
@@ -200,23 +200,41 @@
     , m_lastRefreshedTime(other.m_lastRefreshedTime)
     , m_state(other.m_state)
 {
 }
 
+Animation& Animation::operator=(const Animation& other)
+{
+    m_name = other.m_name.isSafeToSendToAnotherThread() ? other.m_name : other.m_name.isolatedCopy();
+    m_keyframes = other.m_keyframes;
+    m_boxSize = other.m_boxSize;
+    m_timingFunction = other.m_timingFunction->clone();
+    m_iterationCount = other.m_iterationCount;
+    m_duration = other.m_duration;
+    m_direction = other.m_direction;
+    m_fillsForwards = other.m_fillsForwards;
+    m_listsMatch = other.m_listsMatch;
+    m_startTime = other.m_startTime;
+    m_pauseTime = other.m_pauseTime;
+    m_totalRunningTime = other.m_totalRunningTime;
+    m_lastRefreshedTime = other.m_lastRefreshedTime;
+    m_state = other.m_state;
+    return *this;
+}
+
 void Animation::apply(ApplicationResult& applicationResults, MonotonicTime time)
 {
-    if (!isActive())
-        return;
+    // Even when m_state == AnimationState::Stopped && !m_fillsForwards, we should calculate the last value to avoid a flash.
+    // CoordinatedGraphicsScene will soon remove the stopped animation and update the value instead of this function.
 
     Seconds totalRunningTime = computeTotalRunningTime(time);
     double normalizedValue = normalizedAnimationValue(totalRunningTime.seconds(), m_duration, m_direction, m_iterationCount);
 
     if (m_iterationCount != WebCore::Animation::IterationCountInfinite && totalRunningTime.seconds() >= m_duration * m_iterationCount) {
         m_state = AnimationState::Stopped;
         m_pauseTime = 0_s;
-        if (m_fillsForwards)
-            normalizedValue = normalizedAnimationValueForFillsForwards(m_iterationCount, m_direction);
+        normalizedValue = normalizedAnimationValueForFillsForwards(m_iterationCount, m_direction);
     }
 
     applicationResults.hasRunningAnimations |= (m_state == AnimationState::Playing);
 
     if (!normalizedValue) {
@@ -287,15 +305,10 @@
     m_lastRefreshedTime = time;
     m_totalRunningTime += m_lastRefreshedTime - oldLastRefreshedTime;
     return m_totalRunningTime;
 }
 
-bool Animation::isActive() const
-{
-    return m_state != AnimationState::Stopped || m_fillsForwards;
-}
-
 void Animation::applyInternal(ApplicationResult& applicationResults, const AnimationValue& from, const AnimationValue& to, float progress)
 {
     switch (m_keyframes.property()) {
     case AnimatedPropertyTransform:
         applicationResults.transform = applyTransformAnimation(static_cast<const TransformAnimationValue&>(from).value(), static_cast<const TransformAnimationValue&>(to).value(), progress, m_boxSize, m_listsMatch);
@@ -369,11 +382,11 @@
 
 bool Animations::hasActiveAnimationsOfType(AnimatedPropertyID type) const
 {
     return std::any_of(m_animations.begin(), m_animations.end(),
         [&type](const Animation& animation) {
-            return animation.isActive() && animation.keyframes().property() == type;
+            return animation.keyframes().property() == type;
         });
 }
 
 bool Animations::hasRunningAnimations() const
 {
@@ -381,16 +394,6 @@
         [](const Animation& animation) {
             return animation.state() == Animation::AnimationState::Playing;
         });
 }
 
-Animations Animations::getActiveAnimations() const
-{
-    Animations active;
-    for (auto& animation : m_animations) {
-        if (animation.isActive())
-            active.add(animation);
-    }
-    return active;
-}
-
 } // namespace Nicosia

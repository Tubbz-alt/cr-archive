diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Path.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Path.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Path.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Path.cpp
@@ -51,30 +51,24 @@
 
     return traversalState.totalLength();
 }
 #endif
 
-PathTraversalState Path::traversalStateAtLength(float length, bool& success) const
+PathTraversalState Path::traversalStateAtLength(float length) const
 {
     PathTraversalState traversalState(PathTraversalState::Action::VectorAtLength, length);
 
     apply([&traversalState](const PathElement& element) {
         traversalState.processPathElement(element);
     });
 
-    success = traversalState.success();
     return traversalState;
 }
 
-FloatPoint Path::pointAtLength(float length, bool& success) const
+FloatPoint Path::pointAtLength(float length) const
 {
-    return traversalStateAtLength(length, success).current();
-}
-
-float Path::normalAngleAtLength(float length, bool& success) const
-{
-    return traversalStateAtLength(length, success).normalAngle();
+    return traversalStateAtLength(length).current();
 }
 
 void Path::addRoundedRect(const FloatRect& rect, const FloatSize& roundingRadii, RoundedRectStrategy strategy)
 {
     if (rect.isEmpty())
@@ -115,11 +109,11 @@
         // If all the radii cannot be accommodated, return a rect.
         addRect(rect);
         return;
     }
 
-    if (strategy == PreferNativeRoundedRect) {
+    if (strategy == RoundedRectStrategy::PreferNative) {
 #if USE(CG) || USE(DIRECT2D)
         platformAddPathForRoundedRect(rect, radii.topLeft(), radii.topRight(), radii.bottomLeft(), radii.bottomRight());
         return;
 #endif
     }
@@ -196,23 +190,23 @@
     path.apply([&stream, &isFirst](const PathElement& element) {
         if (!isFirst)
             stream << ", ";
         isFirst = false;
         switch (element.type) {
-        case PathElementMoveToPoint: // The points member will contain 1 value.
+        case PathElement::Type::MoveToPoint: // The points member will contain 1 value.
             stream << "move to " << element.points[0];
             break;
-        case PathElementAddLineToPoint: // The points member will contain 1 value.
+        case PathElement::Type::AddLineToPoint: // The points member will contain 1 value.
             stream << "add line to " << element.points[0];
             break;
-        case PathElementAddQuadCurveToPoint: // The points member will contain 2 values.
+        case PathElement::Type::AddQuadCurveToPoint: // The points member will contain 2 values.
             stream << "add quad curve to " << element.points[0] << " " << element.points[1];
             break;
-        case PathElementAddCurveToPoint: // The points member will contain 3 values.
+        case PathElement::Type::AddCurveToPoint: // The points member will contain 3 values.
             stream << "add curve to " << element.points[0] << " " << element.points[1] << " " << element.points[2];
             break;
-        case PathElementCloseSubpath: // The points member will contain no values.
+        case PathElement::Type::CloseSubpath: // The points member will contain no values.
             stream << "close subpath";
             break;
         }
     });
 

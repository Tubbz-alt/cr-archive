<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/HashMapImpl.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GlobalExecutable.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Identifier.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/HashMapImpl.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 36 JS_EXPORT_PRIVATE const ClassInfo* getHashMapImplKeyClassInfo();
 37 JS_EXPORT_PRIVATE const ClassInfo* getHashMapImplKeyValueClassInfo();
 38 
 39 enum class HashTableType {
 40     Key,
 41     KeyValue
 42 };
 43 
 44 struct HashMapBucketDataKey {
 45     static const HashTableType Type = HashTableType::Key;
 46     WriteBarrier&lt;Unknown&gt; key;
 47 };
 48 
 49 struct HashMapBucketDataKeyValue {
 50     static const HashTableType Type = HashTableType::KeyValue;
 51     WriteBarrier&lt;Unknown&gt; key;
 52     WriteBarrier&lt;Unknown&gt; value;
 53 };
 54 
 55 template &lt;typename Data&gt;
<span class="line-modified"> 56 class HashMapBucket : public JSCell {</span>
<span class="line-modified"> 57     typedef JSCell Base;</span>
 58 
 59     template &lt;typename T = Data&gt;
 60     static typename std::enable_if&lt;std::is_same&lt;T, HashMapBucketDataKey&gt;::value, Structure*&gt;::type selectStructure(VM&amp; vm)
 61     {
 62         return vm.hashMapBucketSetStructure.get();
 63     }
 64 
 65     template &lt;typename T = Data&gt;
 66     static typename std::enable_if&lt;std::is_same&lt;T, HashMapBucketDataKeyValue&gt;::value, Structure*&gt;::type selectStructure(VM&amp; vm)
 67     {
 68         return vm.hashMapBucketMapStructure.get();
 69     }
 70 
 71 public:
 72     static const HashTableType Type = Data::Type;
 73     static const ClassInfo s_info; // This is never accessed directly, since that would break linkage on some compilers.
 74 








 75 
 76     static const ClassInfo* info()
 77     {
<span class="line-modified"> 78         switch (Type) {</span>
<span class="line-removed"> 79         case HashTableType::Key:</span>
 80             return getHashMapBucketKeyClassInfo();
<span class="line-modified"> 81         case HashTableType::KeyValue:</span>
 82             return getHashMapBucketKeyValueClassInfo();
<span class="line-removed"> 83         }</span>
<span class="line-removed"> 84         RELEASE_ASSERT_NOT_REACHED();</span>
 85     }
 86 
 87     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 88     {
 89         return Structure::create(vm, globalObject, prototype, TypeInfo(CellType, StructureFlags), info());
 90     }
 91 
 92     static HashMapBucket* create(VM&amp; vm)
 93     {
 94         HashMapBucket* bucket = new (NotNull, allocateCell&lt;HashMapBucket&lt;Data&gt;&gt;(vm.heap)) HashMapBucket(vm, selectStructure(vm));
 95         bucket-&gt;finishCreation(vm);
 96         ASSERT(!bucket-&gt;next());
 97         ASSERT(!bucket-&gt;prev());
 98         return bucket;
 99     }
100 
101     static HashMapBucket* createSentinel(VM&amp; vm)
102     {
103         auto* bucket = create(vm);
104         bucket-&gt;setKey(vm, jsUndefined());
</pre>
<hr />
<pre>
187     WriteBarrier&lt;HashMapBucket&gt; m_next;
188     WriteBarrier&lt;HashMapBucket&gt; m_prev;
189     Data m_data;
190 };
191 
192 template &lt;typename BucketType&gt;
193 class HashMapBuffer {
194 public:
195     HashMapBuffer() = delete;
196 
197     static size_t allocationSize(Checked&lt;size_t&gt; capacity)
198     {
199         return (capacity * sizeof(BucketType*)).unsafeGet();
200     }
201 
202     ALWAYS_INLINE BucketType** buffer() const
203     {
204         return bitwise_cast&lt;BucketType**&gt;(this);
205     }
206 
<span class="line-modified">207     static HashMapBuffer* create(ExecState* exec, VM&amp; vm, JSCell*, uint32_t capacity)</span>
208     {
209         auto scope = DECLARE_THROW_SCOPE(vm);
210         size_t allocationSize = HashMapBuffer::allocationSize(capacity);
211         void* data = vm.jsValueGigacageAuxiliarySpace.allocateNonVirtual(vm, allocationSize, nullptr, AllocationFailureMode::ReturnNull);
212         if (!data) {
<span class="line-modified">213             throwOutOfMemoryError(exec, scope);</span>
214             return nullptr;
215         }
216 
217         HashMapBuffer* buffer = static_cast&lt;HashMapBuffer*&gt;(data);
218         buffer-&gt;reset(capacity);
219         return buffer;
220     }
221 
222     ALWAYS_INLINE void reset(uint32_t capacity)
223     {
224         memset(this, -1, allocationSize(capacity));
225     }
226 };
227 
<span class="line-modified">228 ALWAYS_INLINE static bool areKeysEqual(ExecState* exec, JSValue a, JSValue b)</span>
229 {
230     // We want +0 and -0 to be compared to true here. sameValue() itself doesn&#39;t
231     // guarantee that, however, we normalize all keys before comparing and storing
232     // them in the map. The normalization will convert -0.0 and 0.0 to the integer
233     // representation for 0.
<span class="line-modified">234     return sameValue(exec, a, b);</span>
235 }
236 
237 // Note that normalization is inlined in DFG&#39;s NormalizeMapKey.
238 // Keep in sync with the implementation of DFG and FTL normalization.
239 ALWAYS_INLINE JSValue normalizeMapKey(JSValue key)
240 {
241     if (!key.isNumber())
242         return key;
243 
244     if (key.isInt32())
245         return key;
246 
247     double d = key.asDouble();
248     if (std::isnan(d))
249         return jsNaN();
250 
251     int i = static_cast&lt;int&gt;(d);
252     if (i == d) {
253         // When a key is -0, we convert it to positive zero.
254         // When a key is the double representation for an integer, we convert it to an integer.
255         return jsNumber(i);
256     }
257     // This means key is definitely not negative zero, and it&#39;s definitely not a double representation of an integer.
258     return key;
259 }
260 
261 static ALWAYS_INLINE uint32_t wangsInt64Hash(uint64_t key)
262 {
263     key += ~(key &lt;&lt; 32);
264     key ^= (key &gt;&gt; 22);
265     key += ~(key &lt;&lt; 13);
266     key ^= (key &gt;&gt; 8);
267     key += (key &lt;&lt; 3);
268     key ^= (key &gt;&gt; 15);
269     key += ~(key &lt;&lt; 27);
270     key ^= (key &gt;&gt; 31);
271     return static_cast&lt;unsigned&gt;(key);
272 }
273 
<span class="line-modified">274 ALWAYS_INLINE uint32_t jsMapHash(ExecState* exec, VM&amp; vm, JSValue value)</span>
275 {
276     ASSERT_WITH_MESSAGE(normalizeMapKey(value) == value, &quot;We expect normalized values flowing into this function.&quot;);
277 
278     if (value.isString()) {
279         auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">280         const String&amp; wtfString = asString(value)-&gt;value(exec);</span>
281         RETURN_IF_EXCEPTION(scope, UINT_MAX);
282         return wtfString.impl()-&gt;hash();
283     }
284 
285     return wangsInt64Hash(JSValue::encode(value));
286 }
287 
288 ALWAYS_INLINE Optional&lt;uint32_t&gt; concurrentJSMapHash(JSValue key)
289 {
290     key = normalizeMapKey(key);
291     if (key.isString()) {
292         JSString* string = asString(key);
293         if (string-&gt;length() &gt; 10 * 1024)
294             return WTF::nullopt;
295         const StringImpl* impl = string-&gt;tryGetValueImpl();
296         if (!impl)
297             return WTF::nullopt;
298         return impl-&gt;concurrentHash();
299     }
300 
</pre>
<hr />
<pre>
355         , m_deleteCount(0)
356         , m_capacity(4)
357     {
358     }
359 
360     HashMapImpl(VM&amp; vm, Structure* structure, uint32_t sizeHint)
361         : Base(vm, structure)
362         , m_keyCount(0)
363         , m_deleteCount(0)
364     {
365         uint32_t capacity = ((Checked&lt;uint32_t&gt;(sizeHint) * 2) + 1).unsafeGet();
366         capacity = std::max&lt;uint32_t&gt;(WTF::roundUpToPowerOfTwo(capacity), 4U);
367         m_capacity = capacity;
368     }
369 
370     ALWAYS_INLINE HashMapBucketType** buffer() const
371     {
372         return m_buffer-&gt;buffer();
373     }
374 
<span class="line-modified">375     void finishCreation(ExecState* exec, VM&amp; vm)</span>
376     {
377         ASSERT_WITH_MESSAGE(HashMapBucket&lt;HashMapBucketDataKey&gt;::offsetOfKey() == HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey(), &quot;We assume this to be true in the DFG and FTL JIT.&quot;);
378 
379         auto scope = DECLARE_THROW_SCOPE(vm);
380         Base::finishCreation(vm);
381 
<span class="line-modified">382         makeAndSetNewBuffer(exec, vm);</span>
383         RETURN_IF_EXCEPTION(scope, void());
384 
<span class="line-modified">385         setUpHeadAndTail(exec, vm);</span>
386     }
387 
<span class="line-modified">388     void finishCreation(ExecState* exec, VM&amp; vm, HashMapImpl* base)</span>
389     {
390         auto scope = DECLARE_THROW_SCOPE(vm);
391         Base::finishCreation(vm);
392 
393         // This size should be the same to the case when you clone the map by calling add() repeatedly.
394         uint32_t capacity = ((Checked&lt;uint32_t&gt;(base-&gt;m_keyCount) * 2) + 1).unsafeGet();
395         RELEASE_ASSERT(capacity &lt;= (1U &lt;&lt; 31));
396         capacity = std::max&lt;uint32_t&gt;(WTF::roundUpToPowerOfTwo(capacity), 4U);
397         m_capacity = capacity;
<span class="line-modified">398         makeAndSetNewBuffer(exec, vm);</span>
399         RETURN_IF_EXCEPTION(scope, void());
400 
<span class="line-modified">401         setUpHeadAndTail(exec, vm);</span>
402 
403         HashMapBucketType* bucket = base-&gt;m_head.get()-&gt;next();
404         while (bucket) {
405             if (!bucket-&gt;deleted()) {
<span class="line-modified">406                 addNormalizedNonExistingForCloning(exec, bucket-&gt;key(), HashMapBucketType::extractValue(*bucket));</span>
407                 RETURN_IF_EXCEPTION(scope, void());
408             }
409             bucket = bucket-&gt;next();
410         }
411         checkConsistency();
412     }
413 
414     static HashMapBucketType* emptyValue()
415     {
416         return bitwise_cast&lt;HashMapBucketType*&gt;(static_cast&lt;uintptr_t&gt;(-1));
417     }
418 
419     static ALWAYS_INLINE bool isEmpty(HashMapBucketType* bucket)
420     {
421         return bucket == emptyValue();
422     }
423 
424     static HashMapBucketType* deletedValue()
425     {
426         return bitwise_cast&lt;HashMapBucketType*&gt;(static_cast&lt;uintptr_t&gt;(-3));
427     }
428 
429     static ALWAYS_INLINE bool isDeleted(HashMapBucketType* bucket)
430     {
431         return bucket == deletedValue();
432     }
433 
<span class="line-modified">434     ALWAYS_INLINE HashMapBucketType** findBucket(ExecState* exec, JSValue key)</span>
435     {
<span class="line-modified">436         VM&amp; vm = exec-&gt;vm();</span>
437         auto scope = DECLARE_THROW_SCOPE(vm);
438         key = normalizeMapKey(key);
<span class="line-modified">439         uint32_t hash = jsMapHash(exec, vm, key);</span>
440         RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">441         return findBucket(exec, key, hash);</span>
442     }
443 
<span class="line-modified">444     ALWAYS_INLINE HashMapBucketType** findBucket(ExecState* exec, JSValue key, uint32_t hash)</span>
445     {
446         ASSERT_WITH_MESSAGE(normalizeMapKey(key) == key, &quot;We expect normalized values flowing into this function.&quot;);
<span class="line-modified">447         return findBucketAlreadyHashedAndNormalized(exec, key, hash);</span>
448     }
449 
450     template &lt;typename T = HashMapBucketType&gt;
<span class="line-modified">451     ALWAYS_INLINE typename std::enable_if&lt;std::is_same&lt;T, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;&gt;::value, JSValue&gt;::type get(ExecState* exec, JSValue key)</span>
452     {
<span class="line-modified">453         if (HashMapBucketType** bucket = findBucket(exec, key))</span>
454             return (*bucket)-&gt;value();
455         return jsUndefined();
456     }
457 
<span class="line-modified">458     ALWAYS_INLINE bool has(ExecState* exec, JSValue key)</span>
459     {
<span class="line-modified">460         return !!findBucket(exec, key);</span>
461     }
462 
<span class="line-modified">463     ALWAYS_INLINE void add(ExecState* exec, JSValue key, JSValue value = JSValue())</span>
464     {
465         key = normalizeMapKey(key);
<span class="line-modified">466         addNormalizedInternal(exec, key, value, [&amp;] (HashMapBucketType* bucket) {</span>
<span class="line-modified">467             return !isDeleted(bucket) &amp;&amp; areKeysEqual(exec, key, bucket-&gt;key());</span>
468         });
469         if (shouldRehashAfterAdd())
<span class="line-modified">470             rehash(exec);</span>
471     }
472 
<span class="line-modified">473     ALWAYS_INLINE HashMapBucketType* addNormalized(ExecState* exec, JSValue key, JSValue value, uint32_t hash)</span>
474     {
475         ASSERT_WITH_MESSAGE(normalizeMapKey(key) == key, &quot;We expect normalized values flowing into this function.&quot;);
<span class="line-modified">476         ASSERT_WITH_MESSAGE(jsMapHash(exec, exec-&gt;vm(), key) == hash, &quot;We expect hash value is what we expect.&quot;);</span>
477 
<span class="line-modified">478         auto* bucket = addNormalizedInternal(exec-&gt;vm(), key, value, hash, [&amp;] (HashMapBucketType* bucket) {</span>
<span class="line-modified">479             return !isDeleted(bucket) &amp;&amp; areKeysEqual(exec, key, bucket-&gt;key());</span>
480         });
481         if (shouldRehashAfterAdd())
<span class="line-modified">482             rehash(exec);</span>
483         return bucket;
484     }
485 
<span class="line-modified">486     ALWAYS_INLINE bool remove(ExecState* exec, JSValue key)</span>
487     {
<span class="line-modified">488         HashMapBucketType** bucket = findBucket(exec, key);</span>
489         if (!bucket)
490             return false;
491 
<span class="line-modified">492         VM&amp; vm = exec-&gt;vm();</span>
493         HashMapBucketType* impl = *bucket;
494         impl-&gt;next()-&gt;setPrev(vm, impl-&gt;prev());
495         impl-&gt;prev()-&gt;setNext(vm, impl-&gt;next());
496         impl-&gt;makeDeleted(vm);
497 
498         *bucket = deletedValue();
499 
500         ++m_deleteCount;
501         ASSERT(m_keyCount &gt; 0);
502         --m_keyCount;
503 
504         if (shouldShrink())
<span class="line-modified">505             rehash(exec);</span>
506 
507         return true;
508     }
509 
510     ALWAYS_INLINE uint32_t size() const
511     {
512         return m_keyCount;
513     }
514 
<span class="line-modified">515     ALWAYS_INLINE void clear(ExecState* exec)</span>
516     {
<span class="line-modified">517         VM&amp; vm = exec-&gt;vm();</span>
518         m_keyCount = 0;
519         m_deleteCount = 0;
520         HashMapBucketType* head = m_head.get();
521         HashMapBucketType* bucket = m_head-&gt;next();
522         HashMapBucketType* tail = m_tail.get();
523         while (bucket != tail) {
524             HashMapBucketType* next = bucket-&gt;next();
525             // We restart each iterator by pointing it to the head of the list.
526             bucket-&gt;setNext(vm, head);
527             bucket-&gt;makeDeleted(vm);
528             bucket = next;
529         }
530         m_head-&gt;setNext(vm, m_tail.get());
531         m_tail-&gt;setPrev(vm, m_head.get());
532         m_capacity = 4;
<span class="line-modified">533         makeAndSetNewBuffer(exec, vm);</span>
534         checkConsistency();
535     }
536 
537     ALWAYS_INLINE size_t bufferSizeInBytes() const
538     {
539         return m_capacity * sizeof(HashMapBucketType*);
540     }
541 
542     static ptrdiff_t offsetOfHead()
543     {
544         return OBJECT_OFFSETOF(HashMapImpl&lt;HashMapBucketType&gt;, m_head);
545     }
546 
547     static ptrdiff_t offsetOfBuffer()
548     {
549         return OBJECT_OFFSETOF(HashMapImpl&lt;HashMapBucketType&gt;, m_buffer);
550     }
551 
552     static ptrdiff_t offsetOfCapacity()
553     {
</pre>
<hr />
<pre>
560     size_t approximateSize() const
561     {
562         size_t size = sizeof(HashMapImpl);
563         size += bufferSizeInBytes();
564         size += 2 * sizeof(HashMapBucketType); // Head and tail members.
565         size += m_keyCount * sizeof(HashMapBucketType); // Number of members that are on the list.
566         return size;
567     }
568 
569 private:
570     ALWAYS_INLINE uint32_t shouldRehashAfterAdd() const
571     {
572         return JSC::shouldRehashAfterAdd(m_capacity, m_keyCount, m_deleteCount);
573     }
574 
575     ALWAYS_INLINE uint32_t shouldShrink() const
576     {
577         return JSC::shouldShrink(m_capacity, m_keyCount);
578     }
579 
<span class="line-modified">580     ALWAYS_INLINE void setUpHeadAndTail(ExecState*, VM&amp; vm)</span>
581     {
582         m_head.set(vm, this, HashMapBucketType::create(vm));
583         m_tail.set(vm, this, HashMapBucketType::create(vm));
584 
585         m_head-&gt;setNext(vm, m_tail.get());
586         m_tail-&gt;setPrev(vm, m_head.get());
587         ASSERT(m_head-&gt;deleted());
588         ASSERT(m_tail-&gt;deleted());
589     }
590 
<span class="line-modified">591     ALWAYS_INLINE void addNormalizedNonExistingForCloning(ExecState* exec, JSValue key, JSValue value = JSValue())</span>
592     {
<span class="line-modified">593         addNormalizedInternal(exec, key, value, [&amp;] (HashMapBucketType*) {</span>
594             return false;
595         });
596     }
597 
598     template&lt;typename CanUseBucket&gt;
<span class="line-modified">599     ALWAYS_INLINE void addNormalizedInternal(ExecState* exec, JSValue key, JSValue value, const CanUseBucket&amp; canUseBucket)</span>
600     {
<span class="line-modified">601         VM&amp; vm = exec-&gt;vm();</span>
602         auto scope = DECLARE_THROW_SCOPE(vm);
603 
<span class="line-modified">604         uint32_t hash = jsMapHash(exec, vm, key);</span>
605         RETURN_IF_EXCEPTION(scope, void());
606         scope.release();
607         addNormalizedInternal(vm, key, value, hash, canUseBucket);
608     }
609 
610     template&lt;typename CanUseBucket&gt;
611     ALWAYS_INLINE HashMapBucketType* addNormalizedInternal(VM&amp; vm, JSValue key, JSValue value, uint32_t hash, const CanUseBucket&amp; canUseBucket)
612     {
613         ASSERT_WITH_MESSAGE(normalizeMapKey(key) == key, &quot;We expect normalized values flowing into this function.&quot;);
614 
615         const uint32_t mask = m_capacity - 1;
616         uint32_t index = hash &amp; mask;
617         HashMapBucketType** buffer = this-&gt;buffer();
618         HashMapBucketType* bucket = buffer[index];
619         while (!isEmpty(bucket)) {
620             if (canUseBucket(bucket)) {
621                 bucket-&gt;setValue(vm, value);
622                 return bucket;
623             }
624             index = (index + 1) &amp; mask;
625             bucket = buffer[index];
626         }
627 
628         HashMapBucketType* newEntry = m_tail.get();
629         buffer[index] = newEntry;
630         newEntry-&gt;setKey(vm, key);
631         newEntry-&gt;setValue(vm, value);
632         ASSERT(!newEntry-&gt;deleted());
633         HashMapBucketType* newTail = HashMapBucketType::create(vm);
634         m_tail.set(vm, this, newTail);
635         newTail-&gt;setPrev(vm, newEntry);
636         ASSERT(newTail-&gt;deleted());
637         newEntry-&gt;setNext(vm, newTail);
638 
639         ++m_keyCount;
640         return newEntry;
641     }
642 
<span class="line-modified">643     ALWAYS_INLINE HashMapBucketType** findBucketAlreadyHashedAndNormalized(ExecState* exec, JSValue key, uint32_t hash)</span>
644     {
645         const uint32_t mask = m_capacity - 1;
646         uint32_t index = hash &amp; mask;
647         HashMapBucketType** buffer = this-&gt;buffer();
648         HashMapBucketType* bucket = buffer[index];
649 
650         while (!isEmpty(bucket)) {
<span class="line-modified">651             if (!isDeleted(bucket) &amp;&amp; areKeysEqual(exec, key, bucket-&gt;key()))</span>
652                 return buffer + index;
653             index = (index + 1) &amp; mask;
654             bucket = buffer[index];
655         }
656         return nullptr;
657     }
658 
<span class="line-modified">659     void rehash(ExecState* exec)</span>
660     {
<span class="line-modified">661         VM&amp; vm = exec-&gt;vm();</span>
662         auto scope = DECLARE_THROW_SCOPE(vm);
663 
664         uint32_t oldCapacity = m_capacity;
665         m_capacity = nextCapacity(m_capacity, m_keyCount);
666 
667         if (m_capacity != oldCapacity) {
<span class="line-modified">668             makeAndSetNewBuffer(exec, vm);</span>
669             RETURN_IF_EXCEPTION(scope, void());
670         } else {
671             m_buffer-&gt;reset(m_capacity);
672             assertBufferIsEmpty();
673         }
674 
675         HashMapBucketType* iter = m_head-&gt;next();
676         HashMapBucketType* end = m_tail.get();
677         const uint32_t mask = m_capacity - 1;
678         RELEASE_ASSERT(!(m_capacity &amp; (m_capacity - 1)));
679         HashMapBucketType** buffer = this-&gt;buffer();
680         while (iter != end) {
<span class="line-modified">681             uint32_t index = jsMapHash(exec, vm, iter-&gt;key()) &amp; mask;</span>
682             EXCEPTION_ASSERT_WITH_MESSAGE(!scope.exception(), &quot;All keys should already be hashed before, so this should not throw because it won&#39;t resolve ropes.&quot;);
683             {
684                 HashMapBucketType* bucket = buffer[index];
685                 while (!isEmpty(bucket)) {
686                     index = (index + 1) &amp; mask;
687                     bucket = buffer[index];
688                 }
689             }
690             buffer[index] = iter;
691             iter = iter-&gt;next();
692         }
693 
694         m_deleteCount = 0;
695 
696         checkConsistency();
697     }
698 
699     ALWAYS_INLINE void checkConsistency() const
700     {
<span class="line-modified">701         if (!ASSERT_DISABLED) {</span>
702             HashMapBucketType* iter = m_head-&gt;next();
703             HashMapBucketType* end = m_tail.get();
704             uint32_t size = 0;
705             while (iter != end) {
706                 ++size;
707                 iter = iter-&gt;next();
708             }
709             ASSERT(size == m_keyCount);
710         }
711     }
712 
<span class="line-modified">713     void makeAndSetNewBuffer(ExecState* exec, VM&amp; vm)</span>
714     {
715         ASSERT(!(m_capacity &amp; (m_capacity - 1)));
716 
<span class="line-modified">717         HashMapBufferType* buffer = HashMapBufferType::create(exec, vm, this, m_capacity);</span>
718         if (UNLIKELY(!buffer))
719             return;
720 
721         m_buffer.set(vm, this, buffer);
722         assertBufferIsEmpty();
723     }
724 
725     ALWAYS_INLINE void assertBufferIsEmpty() const
726     {
<span class="line-modified">727         if (!ASSERT_DISABLED) {</span>
728             for (unsigned i = 0; i &lt; m_capacity; i++)
729                 ASSERT(isEmpty(buffer()[i]));
730         }
731     }
732 
733     WriteBarrier&lt;HashMapBucketType&gt; m_head;
734     WriteBarrier&lt;HashMapBucketType&gt; m_tail;
735     AuxiliaryBarrier&lt;HashMapBufferType*&gt; m_buffer;
736     uint32_t m_keyCount;
737     uint32_t m_deleteCount;
738     uint32_t m_capacity;
739 };
740 
741 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 36 JS_EXPORT_PRIVATE const ClassInfo* getHashMapImplKeyClassInfo();
 37 JS_EXPORT_PRIVATE const ClassInfo* getHashMapImplKeyValueClassInfo();
 38 
 39 enum class HashTableType {
 40     Key,
 41     KeyValue
 42 };
 43 
 44 struct HashMapBucketDataKey {
 45     static const HashTableType Type = HashTableType::Key;
 46     WriteBarrier&lt;Unknown&gt; key;
 47 };
 48 
 49 struct HashMapBucketDataKeyValue {
 50     static const HashTableType Type = HashTableType::KeyValue;
 51     WriteBarrier&lt;Unknown&gt; key;
 52     WriteBarrier&lt;Unknown&gt; value;
 53 };
 54 
 55 template &lt;typename Data&gt;
<span class="line-modified"> 56 class HashMapBucket final : public JSCell {</span>
<span class="line-modified"> 57     using Base = JSCell;</span>
 58 
 59     template &lt;typename T = Data&gt;
 60     static typename std::enable_if&lt;std::is_same&lt;T, HashMapBucketDataKey&gt;::value, Structure*&gt;::type selectStructure(VM&amp; vm)
 61     {
 62         return vm.hashMapBucketSetStructure.get();
 63     }
 64 
 65     template &lt;typename T = Data&gt;
 66     static typename std::enable_if&lt;std::is_same&lt;T, HashMapBucketDataKeyValue&gt;::value, Structure*&gt;::type selectStructure(VM&amp; vm)
 67     {
 68         return vm.hashMapBucketMapStructure.get();
 69     }
 70 
 71 public:
 72     static const HashTableType Type = Data::Type;
 73     static const ClassInfo s_info; // This is never accessed directly, since that would break linkage on some compilers.
 74 
<span class="line-added"> 75     template&lt;typename CellType, SubspaceAccess mode&gt;</span>
<span class="line-added"> 76     static IsoSubspace* subspaceFor(VM&amp; vm)</span>
<span class="line-added"> 77     {</span>
<span class="line-added"> 78         if constexpr (Type == HashTableType::Key)</span>
<span class="line-added"> 79             return vm.setBucketSpace&lt;mode&gt;();</span>
<span class="line-added"> 80         else</span>
<span class="line-added"> 81             return vm.mapBucketSpace&lt;mode&gt;();</span>
<span class="line-added"> 82     }</span>
 83 
 84     static const ClassInfo* info()
 85     {
<span class="line-modified"> 86         if constexpr (Type == HashTableType::Key)</span>

 87             return getHashMapBucketKeyClassInfo();
<span class="line-modified"> 88         else</span>
 89             return getHashMapBucketKeyValueClassInfo();


 90     }
 91 
 92     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 93     {
 94         return Structure::create(vm, globalObject, prototype, TypeInfo(CellType, StructureFlags), info());
 95     }
 96 
 97     static HashMapBucket* create(VM&amp; vm)
 98     {
 99         HashMapBucket* bucket = new (NotNull, allocateCell&lt;HashMapBucket&lt;Data&gt;&gt;(vm.heap)) HashMapBucket(vm, selectStructure(vm));
100         bucket-&gt;finishCreation(vm);
101         ASSERT(!bucket-&gt;next());
102         ASSERT(!bucket-&gt;prev());
103         return bucket;
104     }
105 
106     static HashMapBucket* createSentinel(VM&amp; vm)
107     {
108         auto* bucket = create(vm);
109         bucket-&gt;setKey(vm, jsUndefined());
</pre>
<hr />
<pre>
192     WriteBarrier&lt;HashMapBucket&gt; m_next;
193     WriteBarrier&lt;HashMapBucket&gt; m_prev;
194     Data m_data;
195 };
196 
197 template &lt;typename BucketType&gt;
198 class HashMapBuffer {
199 public:
200     HashMapBuffer() = delete;
201 
202     static size_t allocationSize(Checked&lt;size_t&gt; capacity)
203     {
204         return (capacity * sizeof(BucketType*)).unsafeGet();
205     }
206 
207     ALWAYS_INLINE BucketType** buffer() const
208     {
209         return bitwise_cast&lt;BucketType**&gt;(this);
210     }
211 
<span class="line-modified">212     static HashMapBuffer* create(JSGlobalObject* globalObject, VM&amp; vm, JSCell*, uint32_t capacity)</span>
213     {
214         auto scope = DECLARE_THROW_SCOPE(vm);
215         size_t allocationSize = HashMapBuffer::allocationSize(capacity);
216         void* data = vm.jsValueGigacageAuxiliarySpace.allocateNonVirtual(vm, allocationSize, nullptr, AllocationFailureMode::ReturnNull);
217         if (!data) {
<span class="line-modified">218             throwOutOfMemoryError(globalObject, scope);</span>
219             return nullptr;
220         }
221 
222         HashMapBuffer* buffer = static_cast&lt;HashMapBuffer*&gt;(data);
223         buffer-&gt;reset(capacity);
224         return buffer;
225     }
226 
227     ALWAYS_INLINE void reset(uint32_t capacity)
228     {
229         memset(this, -1, allocationSize(capacity));
230     }
231 };
232 
<span class="line-modified">233 ALWAYS_INLINE static bool areKeysEqual(JSGlobalObject* globalObject, JSValue a, JSValue b)</span>
234 {
235     // We want +0 and -0 to be compared to true here. sameValue() itself doesn&#39;t
236     // guarantee that, however, we normalize all keys before comparing and storing
237     // them in the map. The normalization will convert -0.0 and 0.0 to the integer
238     // representation for 0.
<span class="line-modified">239     return sameValue(globalObject, a, b);</span>
240 }
241 
242 // Note that normalization is inlined in DFG&#39;s NormalizeMapKey.
243 // Keep in sync with the implementation of DFG and FTL normalization.
244 ALWAYS_INLINE JSValue normalizeMapKey(JSValue key)
245 {
246     if (!key.isNumber())
247         return key;
248 
249     if (key.isInt32())
250         return key;
251 
252     double d = key.asDouble();
253     if (std::isnan(d))
254         return jsNaN();
255 
256     int i = static_cast&lt;int&gt;(d);
257     if (i == d) {
258         // When a key is -0, we convert it to positive zero.
259         // When a key is the double representation for an integer, we convert it to an integer.
260         return jsNumber(i);
261     }
262     // This means key is definitely not negative zero, and it&#39;s definitely not a double representation of an integer.
263     return key;
264 }
265 
266 static ALWAYS_INLINE uint32_t wangsInt64Hash(uint64_t key)
267 {
268     key += ~(key &lt;&lt; 32);
269     key ^= (key &gt;&gt; 22);
270     key += ~(key &lt;&lt; 13);
271     key ^= (key &gt;&gt; 8);
272     key += (key &lt;&lt; 3);
273     key ^= (key &gt;&gt; 15);
274     key += ~(key &lt;&lt; 27);
275     key ^= (key &gt;&gt; 31);
276     return static_cast&lt;unsigned&gt;(key);
277 }
278 
<span class="line-modified">279 ALWAYS_INLINE uint32_t jsMapHash(JSGlobalObject* globalObject, VM&amp; vm, JSValue value)</span>
280 {
281     ASSERT_WITH_MESSAGE(normalizeMapKey(value) == value, &quot;We expect normalized values flowing into this function.&quot;);
282 
283     if (value.isString()) {
284         auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">285         const String&amp; wtfString = asString(value)-&gt;value(globalObject);</span>
286         RETURN_IF_EXCEPTION(scope, UINT_MAX);
287         return wtfString.impl()-&gt;hash();
288     }
289 
290     return wangsInt64Hash(JSValue::encode(value));
291 }
292 
293 ALWAYS_INLINE Optional&lt;uint32_t&gt; concurrentJSMapHash(JSValue key)
294 {
295     key = normalizeMapKey(key);
296     if (key.isString()) {
297         JSString* string = asString(key);
298         if (string-&gt;length() &gt; 10 * 1024)
299             return WTF::nullopt;
300         const StringImpl* impl = string-&gt;tryGetValueImpl();
301         if (!impl)
302             return WTF::nullopt;
303         return impl-&gt;concurrentHash();
304     }
305 
</pre>
<hr />
<pre>
360         , m_deleteCount(0)
361         , m_capacity(4)
362     {
363     }
364 
365     HashMapImpl(VM&amp; vm, Structure* structure, uint32_t sizeHint)
366         : Base(vm, structure)
367         , m_keyCount(0)
368         , m_deleteCount(0)
369     {
370         uint32_t capacity = ((Checked&lt;uint32_t&gt;(sizeHint) * 2) + 1).unsafeGet();
371         capacity = std::max&lt;uint32_t&gt;(WTF::roundUpToPowerOfTwo(capacity), 4U);
372         m_capacity = capacity;
373     }
374 
375     ALWAYS_INLINE HashMapBucketType** buffer() const
376     {
377         return m_buffer-&gt;buffer();
378     }
379 
<span class="line-modified">380     void finishCreation(JSGlobalObject* globalObject, VM&amp; vm)</span>
381     {
382         ASSERT_WITH_MESSAGE(HashMapBucket&lt;HashMapBucketDataKey&gt;::offsetOfKey() == HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey(), &quot;We assume this to be true in the DFG and FTL JIT.&quot;);
383 
384         auto scope = DECLARE_THROW_SCOPE(vm);
385         Base::finishCreation(vm);
386 
<span class="line-modified">387         makeAndSetNewBuffer(globalObject, vm);</span>
388         RETURN_IF_EXCEPTION(scope, void());
389 
<span class="line-modified">390         setUpHeadAndTail(globalObject, vm);</span>
391     }
392 
<span class="line-modified">393     void finishCreation(JSGlobalObject* globalObject, VM&amp; vm, HashMapImpl* base)</span>
394     {
395         auto scope = DECLARE_THROW_SCOPE(vm);
396         Base::finishCreation(vm);
397 
398         // This size should be the same to the case when you clone the map by calling add() repeatedly.
399         uint32_t capacity = ((Checked&lt;uint32_t&gt;(base-&gt;m_keyCount) * 2) + 1).unsafeGet();
400         RELEASE_ASSERT(capacity &lt;= (1U &lt;&lt; 31));
401         capacity = std::max&lt;uint32_t&gt;(WTF::roundUpToPowerOfTwo(capacity), 4U);
402         m_capacity = capacity;
<span class="line-modified">403         makeAndSetNewBuffer(globalObject, vm);</span>
404         RETURN_IF_EXCEPTION(scope, void());
405 
<span class="line-modified">406         setUpHeadAndTail(globalObject, vm);</span>
407 
408         HashMapBucketType* bucket = base-&gt;m_head.get()-&gt;next();
409         while (bucket) {
410             if (!bucket-&gt;deleted()) {
<span class="line-modified">411                 addNormalizedNonExistingForCloning(globalObject, bucket-&gt;key(), HashMapBucketType::extractValue(*bucket));</span>
412                 RETURN_IF_EXCEPTION(scope, void());
413             }
414             bucket = bucket-&gt;next();
415         }
416         checkConsistency();
417     }
418 
419     static HashMapBucketType* emptyValue()
420     {
421         return bitwise_cast&lt;HashMapBucketType*&gt;(static_cast&lt;uintptr_t&gt;(-1));
422     }
423 
424     static ALWAYS_INLINE bool isEmpty(HashMapBucketType* bucket)
425     {
426         return bucket == emptyValue();
427     }
428 
429     static HashMapBucketType* deletedValue()
430     {
431         return bitwise_cast&lt;HashMapBucketType*&gt;(static_cast&lt;uintptr_t&gt;(-3));
432     }
433 
434     static ALWAYS_INLINE bool isDeleted(HashMapBucketType* bucket)
435     {
436         return bucket == deletedValue();
437     }
438 
<span class="line-modified">439     ALWAYS_INLINE HashMapBucketType** findBucket(JSGlobalObject* globalObject, JSValue key)</span>
440     {
<span class="line-modified">441         VM&amp; vm = getVM(globalObject);</span>
442         auto scope = DECLARE_THROW_SCOPE(vm);
443         key = normalizeMapKey(key);
<span class="line-modified">444         uint32_t hash = jsMapHash(globalObject, vm, key);</span>
445         RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">446         return findBucket(globalObject, key, hash);</span>
447     }
448 
<span class="line-modified">449     ALWAYS_INLINE HashMapBucketType** findBucket(JSGlobalObject* globalObject, JSValue key, uint32_t hash)</span>
450     {
451         ASSERT_WITH_MESSAGE(normalizeMapKey(key) == key, &quot;We expect normalized values flowing into this function.&quot;);
<span class="line-modified">452         return findBucketAlreadyHashedAndNormalized(globalObject, key, hash);</span>
453     }
454 
455     template &lt;typename T = HashMapBucketType&gt;
<span class="line-modified">456     ALWAYS_INLINE typename std::enable_if&lt;std::is_same&lt;T, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;&gt;::value, JSValue&gt;::type get(JSGlobalObject* globalObject, JSValue key)</span>
457     {
<span class="line-modified">458         if (HashMapBucketType** bucket = findBucket(globalObject, key))</span>
459             return (*bucket)-&gt;value();
460         return jsUndefined();
461     }
462 
<span class="line-modified">463     ALWAYS_INLINE bool has(JSGlobalObject* globalObject, JSValue key)</span>
464     {
<span class="line-modified">465         return !!findBucket(globalObject, key);</span>
466     }
467 
<span class="line-modified">468     ALWAYS_INLINE void add(JSGlobalObject* globalObject, JSValue key, JSValue value = JSValue())</span>
469     {
470         key = normalizeMapKey(key);
<span class="line-modified">471         addNormalizedInternal(globalObject, key, value, [&amp;] (HashMapBucketType* bucket) {</span>
<span class="line-modified">472             return !isDeleted(bucket) &amp;&amp; areKeysEqual(globalObject, key, bucket-&gt;key());</span>
473         });
474         if (shouldRehashAfterAdd())
<span class="line-modified">475             rehash(globalObject);</span>
476     }
477 
<span class="line-modified">478     ALWAYS_INLINE HashMapBucketType* addNormalized(JSGlobalObject* globalObject, JSValue key, JSValue value, uint32_t hash)</span>
479     {
480         ASSERT_WITH_MESSAGE(normalizeMapKey(key) == key, &quot;We expect normalized values flowing into this function.&quot;);
<span class="line-modified">481         ASSERT_WITH_MESSAGE(jsMapHash(globalObject, getVM(globalObject), key) == hash, &quot;We expect hash value is what we expect.&quot;);</span>
482 
<span class="line-modified">483         auto* bucket = addNormalizedInternal(getVM(globalObject), key, value, hash, [&amp;] (HashMapBucketType* bucket) {</span>
<span class="line-modified">484             return !isDeleted(bucket) &amp;&amp; areKeysEqual(globalObject, key, bucket-&gt;key());</span>
485         });
486         if (shouldRehashAfterAdd())
<span class="line-modified">487             rehash(globalObject);</span>
488         return bucket;
489     }
490 
<span class="line-modified">491     ALWAYS_INLINE bool remove(JSGlobalObject* globalObject, JSValue key)</span>
492     {
<span class="line-modified">493         HashMapBucketType** bucket = findBucket(globalObject, key);</span>
494         if (!bucket)
495             return false;
496 
<span class="line-modified">497         VM&amp; vm = getVM(globalObject);</span>
498         HashMapBucketType* impl = *bucket;
499         impl-&gt;next()-&gt;setPrev(vm, impl-&gt;prev());
500         impl-&gt;prev()-&gt;setNext(vm, impl-&gt;next());
501         impl-&gt;makeDeleted(vm);
502 
503         *bucket = deletedValue();
504 
505         ++m_deleteCount;
506         ASSERT(m_keyCount &gt; 0);
507         --m_keyCount;
508 
509         if (shouldShrink())
<span class="line-modified">510             rehash(globalObject);</span>
511 
512         return true;
513     }
514 
515     ALWAYS_INLINE uint32_t size() const
516     {
517         return m_keyCount;
518     }
519 
<span class="line-modified">520     ALWAYS_INLINE void clear(JSGlobalObject* globalObject)</span>
521     {
<span class="line-modified">522         VM&amp; vm = getVM(globalObject);</span>
523         m_keyCount = 0;
524         m_deleteCount = 0;
525         HashMapBucketType* head = m_head.get();
526         HashMapBucketType* bucket = m_head-&gt;next();
527         HashMapBucketType* tail = m_tail.get();
528         while (bucket != tail) {
529             HashMapBucketType* next = bucket-&gt;next();
530             // We restart each iterator by pointing it to the head of the list.
531             bucket-&gt;setNext(vm, head);
532             bucket-&gt;makeDeleted(vm);
533             bucket = next;
534         }
535         m_head-&gt;setNext(vm, m_tail.get());
536         m_tail-&gt;setPrev(vm, m_head.get());
537         m_capacity = 4;
<span class="line-modified">538         makeAndSetNewBuffer(globalObject, vm);</span>
539         checkConsistency();
540     }
541 
542     ALWAYS_INLINE size_t bufferSizeInBytes() const
543     {
544         return m_capacity * sizeof(HashMapBucketType*);
545     }
546 
547     static ptrdiff_t offsetOfHead()
548     {
549         return OBJECT_OFFSETOF(HashMapImpl&lt;HashMapBucketType&gt;, m_head);
550     }
551 
552     static ptrdiff_t offsetOfBuffer()
553     {
554         return OBJECT_OFFSETOF(HashMapImpl&lt;HashMapBucketType&gt;, m_buffer);
555     }
556 
557     static ptrdiff_t offsetOfCapacity()
558     {
</pre>
<hr />
<pre>
565     size_t approximateSize() const
566     {
567         size_t size = sizeof(HashMapImpl);
568         size += bufferSizeInBytes();
569         size += 2 * sizeof(HashMapBucketType); // Head and tail members.
570         size += m_keyCount * sizeof(HashMapBucketType); // Number of members that are on the list.
571         return size;
572     }
573 
574 private:
575     ALWAYS_INLINE uint32_t shouldRehashAfterAdd() const
576     {
577         return JSC::shouldRehashAfterAdd(m_capacity, m_keyCount, m_deleteCount);
578     }
579 
580     ALWAYS_INLINE uint32_t shouldShrink() const
581     {
582         return JSC::shouldShrink(m_capacity, m_keyCount);
583     }
584 
<span class="line-modified">585     ALWAYS_INLINE void setUpHeadAndTail(JSGlobalObject*, VM&amp; vm)</span>
586     {
587         m_head.set(vm, this, HashMapBucketType::create(vm));
588         m_tail.set(vm, this, HashMapBucketType::create(vm));
589 
590         m_head-&gt;setNext(vm, m_tail.get());
591         m_tail-&gt;setPrev(vm, m_head.get());
592         ASSERT(m_head-&gt;deleted());
593         ASSERT(m_tail-&gt;deleted());
594     }
595 
<span class="line-modified">596     ALWAYS_INLINE void addNormalizedNonExistingForCloning(JSGlobalObject* globalObject, JSValue key, JSValue value = JSValue())</span>
597     {
<span class="line-modified">598         addNormalizedInternal(globalObject, key, value, [&amp;] (HashMapBucketType*) {</span>
599             return false;
600         });
601     }
602 
603     template&lt;typename CanUseBucket&gt;
<span class="line-modified">604     ALWAYS_INLINE void addNormalizedInternal(JSGlobalObject* globalObject, JSValue key, JSValue value, const CanUseBucket&amp; canUseBucket)</span>
605     {
<span class="line-modified">606         VM&amp; vm = getVM(globalObject);</span>
607         auto scope = DECLARE_THROW_SCOPE(vm);
608 
<span class="line-modified">609         uint32_t hash = jsMapHash(globalObject, vm, key);</span>
610         RETURN_IF_EXCEPTION(scope, void());
611         scope.release();
612         addNormalizedInternal(vm, key, value, hash, canUseBucket);
613     }
614 
615     template&lt;typename CanUseBucket&gt;
616     ALWAYS_INLINE HashMapBucketType* addNormalizedInternal(VM&amp; vm, JSValue key, JSValue value, uint32_t hash, const CanUseBucket&amp; canUseBucket)
617     {
618         ASSERT_WITH_MESSAGE(normalizeMapKey(key) == key, &quot;We expect normalized values flowing into this function.&quot;);
619 
620         const uint32_t mask = m_capacity - 1;
621         uint32_t index = hash &amp; mask;
622         HashMapBucketType** buffer = this-&gt;buffer();
623         HashMapBucketType* bucket = buffer[index];
624         while (!isEmpty(bucket)) {
625             if (canUseBucket(bucket)) {
626                 bucket-&gt;setValue(vm, value);
627                 return bucket;
628             }
629             index = (index + 1) &amp; mask;
630             bucket = buffer[index];
631         }
632 
633         HashMapBucketType* newEntry = m_tail.get();
634         buffer[index] = newEntry;
635         newEntry-&gt;setKey(vm, key);
636         newEntry-&gt;setValue(vm, value);
637         ASSERT(!newEntry-&gt;deleted());
638         HashMapBucketType* newTail = HashMapBucketType::create(vm);
639         m_tail.set(vm, this, newTail);
640         newTail-&gt;setPrev(vm, newEntry);
641         ASSERT(newTail-&gt;deleted());
642         newEntry-&gt;setNext(vm, newTail);
643 
644         ++m_keyCount;
645         return newEntry;
646     }
647 
<span class="line-modified">648     ALWAYS_INLINE HashMapBucketType** findBucketAlreadyHashedAndNormalized(JSGlobalObject* globalObject, JSValue key, uint32_t hash)</span>
649     {
650         const uint32_t mask = m_capacity - 1;
651         uint32_t index = hash &amp; mask;
652         HashMapBucketType** buffer = this-&gt;buffer();
653         HashMapBucketType* bucket = buffer[index];
654 
655         while (!isEmpty(bucket)) {
<span class="line-modified">656             if (!isDeleted(bucket) &amp;&amp; areKeysEqual(globalObject, key, bucket-&gt;key()))</span>
657                 return buffer + index;
658             index = (index + 1) &amp; mask;
659             bucket = buffer[index];
660         }
661         return nullptr;
662     }
663 
<span class="line-modified">664     void rehash(JSGlobalObject* globalObject)</span>
665     {
<span class="line-modified">666         VM&amp; vm = getVM(globalObject);</span>
667         auto scope = DECLARE_THROW_SCOPE(vm);
668 
669         uint32_t oldCapacity = m_capacity;
670         m_capacity = nextCapacity(m_capacity, m_keyCount);
671 
672         if (m_capacity != oldCapacity) {
<span class="line-modified">673             makeAndSetNewBuffer(globalObject, vm);</span>
674             RETURN_IF_EXCEPTION(scope, void());
675         } else {
676             m_buffer-&gt;reset(m_capacity);
677             assertBufferIsEmpty();
678         }
679 
680         HashMapBucketType* iter = m_head-&gt;next();
681         HashMapBucketType* end = m_tail.get();
682         const uint32_t mask = m_capacity - 1;
683         RELEASE_ASSERT(!(m_capacity &amp; (m_capacity - 1)));
684         HashMapBucketType** buffer = this-&gt;buffer();
685         while (iter != end) {
<span class="line-modified">686             uint32_t index = jsMapHash(globalObject, vm, iter-&gt;key()) &amp; mask;</span>
687             EXCEPTION_ASSERT_WITH_MESSAGE(!scope.exception(), &quot;All keys should already be hashed before, so this should not throw because it won&#39;t resolve ropes.&quot;);
688             {
689                 HashMapBucketType* bucket = buffer[index];
690                 while (!isEmpty(bucket)) {
691                     index = (index + 1) &amp; mask;
692                     bucket = buffer[index];
693                 }
694             }
695             buffer[index] = iter;
696             iter = iter-&gt;next();
697         }
698 
699         m_deleteCount = 0;
700 
701         checkConsistency();
702     }
703 
704     ALWAYS_INLINE void checkConsistency() const
705     {
<span class="line-modified">706         if (ASSERT_ENABLED) {</span>
707             HashMapBucketType* iter = m_head-&gt;next();
708             HashMapBucketType* end = m_tail.get();
709             uint32_t size = 0;
710             while (iter != end) {
711                 ++size;
712                 iter = iter-&gt;next();
713             }
714             ASSERT(size == m_keyCount);
715         }
716     }
717 
<span class="line-modified">718     void makeAndSetNewBuffer(JSGlobalObject* globalObject, VM&amp; vm)</span>
719     {
720         ASSERT(!(m_capacity &amp; (m_capacity - 1)));
721 
<span class="line-modified">722         HashMapBufferType* buffer = HashMapBufferType::create(globalObject, vm, this, m_capacity);</span>
723         if (UNLIKELY(!buffer))
724             return;
725 
726         m_buffer.set(vm, this, buffer);
727         assertBufferIsEmpty();
728     }
729 
730     ALWAYS_INLINE void assertBufferIsEmpty() const
731     {
<span class="line-modified">732         if (ASSERT_ENABLED) {</span>
733             for (unsigned i = 0; i &lt; m_capacity; i++)
734                 ASSERT(isEmpty(buffer()[i]));
735         }
736     }
737 
738     WriteBarrier&lt;HashMapBucketType&gt; m_head;
739     WriteBarrier&lt;HashMapBucketType&gt; m_tail;
740     AuxiliaryBarrier&lt;HashMapBufferType*&gt; m_buffer;
741     uint32_t m_keyCount;
742     uint32_t m_deleteCount;
743     uint32_t m_capacity;
744 };
745 
746 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="GlobalExecutable.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Identifier.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
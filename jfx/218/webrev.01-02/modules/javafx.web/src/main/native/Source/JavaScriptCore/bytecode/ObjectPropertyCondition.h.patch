diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/ObjectPropertyCondition.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/ObjectPropertyCondition.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/ObjectPropertyCondition.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/ObjectPropertyCondition.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2015-2018 Apple Inc. All rights reserved.
+ * Copyright (C) 2015-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -120,10 +120,21 @@
         if (owner)
             vm.heap.writeBarrier(owner);
         return equivalenceWithoutBarrier(object, uid, value);
     }
 
+    static ObjectPropertyCondition customFunctionEquivalence(
+        VM& vm, JSCell* owner, JSObject* object, UniquedStringImpl* uid)
+    {
+        ObjectPropertyCondition result;
+        result.m_object = object;
+        result.m_condition = PropertyCondition::customFunctionEquivalence(uid);
+        if (owner)
+            vm.heap.writeBarrier(owner);
+        return result;
+    }
+
     static ObjectPropertyCondition hasPrototypeWithoutBarrier(JSObject* object, JSObject* prototype)
     {
         ObjectPropertyCondition result;
         result.m_object = object;
         result.m_condition = PropertyCondition::hasPrototypeWithoutBarrier(prototype);
@@ -191,11 +202,10 @@
     // that take an explicit Structure* because you want the compiler to optimize for the same
     // structure that you validated (i.e. avoid a TOCTOU race).
 
     // Checks if the object's structure claims that the property won't be intercepted. Validity
     // does not require watchpoints on the object.
-    bool structureEnsuresValidityAssumingImpurePropertyWatchpoint(Structure*) const;
     bool structureEnsuresValidityAssumingImpurePropertyWatchpoint() const;
 
     // Returns true if we need an impure property watchpoint to ensure validity even if
     // isStillValidAccordingToStructure() returned true.
     bool validityRequiresImpurePropertyWatchpoint(Structure*) const;
@@ -225,11 +235,11 @@
         PropertyCondition::WatchabilityEffort = PropertyCondition::MakeNoChanges) const;
     bool isWatchableAssumingImpurePropertyWatchpoint(
         PropertyCondition::WatchabilityEffort = PropertyCondition::MakeNoChanges) const;
 
     // This means that it's still valid and we could enforce validity by setting a transition
-    // watchpoint on the structure.
+    // watchpoint on the structure, and a value change watchpoint if we're Equivalence.
     bool isWatchable(
         Structure*,
         PropertyCondition::WatchabilityEffort = PropertyCondition::MakeNoChanges) const;
     bool isWatchable(
         PropertyCondition::WatchabilityEffort = PropertyCondition::MakeNoChanges) const;
@@ -241,10 +251,17 @@
     bool watchingRequiresReplacementWatchpoint() const
     {
         return condition().watchingRequiresReplacementWatchpoint();
     }
 
+    template<typename Functor>
+    void forEachDependentCell(const Functor& functor) const
+    {
+        functor(m_object);
+        m_condition.forEachDependentCell(functor);
+    }
+
     // This means that the objects involved in this are still live.
     bool isStillLive(VM&) const;
 
     void validateReferences(const TrackedReferences&) const;
 
@@ -265,11 +282,11 @@
     static bool equal(
         const ObjectPropertyCondition& a, const ObjectPropertyCondition& b)
     {
         return a == b;
     }
-    static const bool safeToCompareToEmptyOrDeleted = true;
+    static constexpr bool safeToCompareToEmptyOrDeleted = true;
 };
 
 } // namespace JSC
 
 namespace WTF {

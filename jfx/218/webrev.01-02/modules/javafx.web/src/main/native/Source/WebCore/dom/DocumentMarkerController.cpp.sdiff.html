<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/DocumentMarkerController.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DocumentFullscreen.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DocumentMarkerController.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/DocumentMarkerController.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 43 namespace WebCore {
 44 
 45 inline bool DocumentMarkerController::possiblyHasMarkers(OptionSet&lt;DocumentMarker::MarkerType&gt; types)
 46 {
 47     return m_possiblyExistingMarkerTypes.containsAny(types);
 48 }
 49 
 50 DocumentMarkerController::DocumentMarkerController(Document&amp; document)
 51     : m_document(document)
 52 {
 53 }
 54 
 55 DocumentMarkerController::~DocumentMarkerController() = default;
 56 
 57 void DocumentMarkerController::detach()
 58 {
 59     m_markers.clear();
 60     m_possiblyExistingMarkerTypes = { };
 61 }
 62 








 63 void DocumentMarkerController::addMarker(Range&amp; range, DocumentMarker::MarkerType type, const String&amp; description)
 64 {
<span class="line-modified"> 65     for (TextIterator markedText(&amp;range); !markedText.atEnd(); markedText.advance()) {</span>
<span class="line-removed"> 66         RefPtr&lt;Range&gt; textPiece = markedText.range();</span>
 67         addMarker(textPiece-&gt;startContainer(), DocumentMarker(type, textPiece-&gt;startOffset(), textPiece-&gt;endOffset(), description));
<span class="line-removed"> 68     }</span>
 69 }
 70 
 71 void DocumentMarkerController::addMarker(Range&amp; range, DocumentMarker::MarkerType type)
 72 {
<span class="line-modified"> 73     for (TextIterator markedText(&amp;range); !markedText.atEnd(); markedText.advance()) {</span>
<span class="line-removed"> 74         RefPtr&lt;Range&gt; textPiece = markedText.range();</span>
 75         addMarker(textPiece-&gt;startContainer(), DocumentMarker(type, textPiece-&gt;startOffset(), textPiece-&gt;endOffset()));
<span class="line-removed"> 76     }</span>
<span class="line-removed"> 77 </span>
 78 }
 79 
 80 void DocumentMarkerController::addMarkerToNode(Node&amp; node, unsigned startOffset, unsigned length, DocumentMarker::MarkerType type)
 81 {
 82     addMarker(node, DocumentMarker(type, startOffset, startOffset + length));
 83 }
 84 
 85 void DocumentMarkerController::addMarkerToNode(Node&amp; node, unsigned startOffset, unsigned length, DocumentMarker::MarkerType type, DocumentMarker::Data&amp;&amp; data)
 86 {
 87     addMarker(node, DocumentMarker(type, startOffset, startOffset + length, WTFMove(data)));
 88 }
 89 
 90 void DocumentMarkerController::addTextMatchMarker(const Range&amp; range, bool activeMatch)
 91 {
<span class="line-modified"> 92     for (TextIterator markedText(&amp;range); !markedText.atEnd(); markedText.advance()) {</span>
<span class="line-removed"> 93         RefPtr&lt;Range&gt; textPiece = markedText.range();</span>
 94         unsigned startOffset = textPiece-&gt;startOffset();
 95         unsigned endOffset = textPiece-&gt;endOffset();
 96         addMarker(textPiece-&gt;startContainer(), DocumentMarker(startOffset, endOffset, activeMatch));
 97     }
 98 }
 99 
100 #if PLATFORM(IOS_FAMILY)
101 
102 void DocumentMarkerController::addMarker(Range&amp; range, DocumentMarker::MarkerType type, const String&amp; description, const Vector&lt;String&gt;&amp; interpretations, const RetainPtr&lt;id&gt;&amp; metadata)
103 {
<span class="line-modified">104     for (TextIterator markedText(&amp;range); !markedText.atEnd(); markedText.advance()) {</span>
<span class="line-removed">105         RefPtr&lt;Range&gt; textPiece = markedText.range();</span>
106         addMarker(textPiece-&gt;startContainer(), DocumentMarker(type, textPiece-&gt;startOffset(), textPiece-&gt;endOffset(), description, interpretations, metadata));
<span class="line-removed">107     }</span>
108 }
109 
110 void DocumentMarkerController::addDictationPhraseWithAlternativesMarker(Range&amp; range, const Vector&lt;String&gt;&amp; interpretations)
111 {
112     ASSERT(interpretations.size() &gt; 1);
113     if (interpretations.size() &lt;= 1)
114         return;
115 
116     size_t numberOfAlternatives = interpretations.size() - 1;
<span class="line-modified">117     for (TextIterator markedText(&amp;range); !markedText.atEnd(); markedText.advance()) {</span>
<span class="line-removed">118         RefPtr&lt;Range&gt; textPiece = markedText.range();</span>
119         DocumentMarker marker(DocumentMarker::DictationPhraseWithAlternatives, textPiece-&gt;startOffset(), textPiece-&gt;endOffset(), emptyString(), Vector&lt;String&gt;(numberOfAlternatives), RetainPtr&lt;id&gt;());
120         for (size_t i = 0; i &lt; numberOfAlternatives; ++i)
121             marker.setAlternative(interpretations[i + 1], i);
122         addMarker(textPiece-&gt;startContainer(), marker);
123     }
124 }
125 
126 void DocumentMarkerController::addDictationResultMarker(Range&amp; range, const RetainPtr&lt;id&gt;&amp; metadata)
127 {
<span class="line-modified">128     for (TextIterator markedText(&amp;range); !markedText.atEnd(); markedText.advance()) {</span>
<span class="line-removed">129         RefPtr&lt;Range&gt; textPiece = markedText.range();</span>
130         addMarker(textPiece-&gt;startContainer(), DocumentMarker(DocumentMarker::DictationResult, textPiece-&gt;startOffset(), textPiece-&gt;endOffset(), String(), Vector&lt;String&gt;(), metadata));
<span class="line-removed">131     }</span>
132 }
133 
134 #endif
135 
136 void DocumentMarkerController::addDraggedContentMarker(Range&amp; range)
137 {
<span class="line-modified">138     for (TextIterator markedText(&amp;range); !markedText.atEnd(); markedText.advance()) {</span>
<span class="line-modified">139         auto textPiece = markedText.range();</span>
<span class="line-removed">140         DocumentMarker::DraggedContentData draggedContentData { markedText.node() };</span>
141         addMarker(textPiece-&gt;startContainer(), { DocumentMarker::DraggedContent, textPiece-&gt;startOffset(), textPiece-&gt;endOffset(), WTFMove(draggedContentData) });
142     }
143 }
144 
145 #if ENABLE(PLATFORM_DRIVEN_TEXT_CHECKING)
146 void DocumentMarkerController::addPlatformTextCheckingMarker(Range&amp; range, const String&amp; key, const String&amp; value)
147 {
<span class="line-modified">148     for (TextIterator markedText(&amp;range); !markedText.atEnd(); markedText.advance()) {</span>
<span class="line-removed">149         auto textPiece = markedText.range();</span>
150         DocumentMarker::PlatformTextCheckingData textCheckingData { key, value };
151         addMarker(textPiece-&gt;startContainer(), { DocumentMarker::PlatformTextChecking, textPiece-&gt;startOffset(), textPiece-&gt;endOffset(), WTFMove(textCheckingData) });
152     }
153 }
154 #endif
155 
156 void DocumentMarkerController::removeMarkers(Range&amp; range, OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypes, RemovePartiallyOverlappingMarkerOrNot shouldRemovePartiallyOverlappingMarker)
157 {
<span class="line-modified">158     for (TextIterator markedText(&amp;range); !markedText.atEnd(); markedText.advance()) {</span>
159         if (!possiblyHasMarkers(markerTypes))
160             return;
161         ASSERT(!m_markers.isEmpty());
<span class="line-removed">162 </span>
<span class="line-removed">163         auto textPiece = markedText.range();</span>
164         unsigned startOffset = textPiece-&gt;startOffset();
165         unsigned endOffset = textPiece-&gt;endOffset();
166         removeMarkers(textPiece-&gt;startContainer(), startOffset, endOffset - startOffset, markerTypes, nullptr, shouldRemovePartiallyOverlappingMarker);
167     }
168 }
169 
170 void DocumentMarkerController::filterMarkers(Range&amp; range, std::function&lt;bool(DocumentMarker*)&gt; filterFunction, OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypes, RemovePartiallyOverlappingMarkerOrNot shouldRemovePartiallyOverlappingMarker)
171 {
<span class="line-modified">172     for (TextIterator markedText(&amp;range); !markedText.atEnd(); markedText.advance()) {</span>
173         if (!possiblyHasMarkers(markerTypes))
174             return;
175         ASSERT(!m_markers.isEmpty());
176 
<span class="line-removed">177         auto textPiece = markedText.range();</span>
178         unsigned startOffset = textPiece-&gt;startOffset();
179         unsigned endOffset = textPiece-&gt;endOffset();
180         removeMarkers(textPiece-&gt;startContainer(), startOffset, endOffset - startOffset, markerTypes, filterFunction, shouldRemovePartiallyOverlappingMarker);
181     }
182 }
183 
184 static void updateRenderedRectsForMarker(RenderedDocumentMarker&amp; marker, Node&amp; node)
185 {
186     ASSERT(!node.document().view() || !node.document().view()-&gt;needsLayout());
187 
188     // FIXME: We should refactor this so that we don&#39;t use Range (because we only have one Node), but still share code with absoluteTextQuads().
189     auto markerRange = Range::create(node.document(), &amp;node, marker.startOffset(), &amp;node, marker.endOffset());
190     Vector&lt;FloatQuad&gt; absoluteMarkerQuads;
191     markerRange-&gt;absoluteTextQuads(absoluteMarkerQuads, true);
192 
193     Vector&lt;FloatRect&gt; absoluteMarkerRects;
194     absoluteMarkerRects.reserveInitialCapacity(absoluteMarkerQuads.size());
195     for (const auto&amp; quad : absoluteMarkerQuads)
196         absoluteMarkerRects.uncheckedAppend(quad.boundingBox());
197 
</pre>
</td>
<td>
<hr />
<pre>
 43 namespace WebCore {
 44 
 45 inline bool DocumentMarkerController::possiblyHasMarkers(OptionSet&lt;DocumentMarker::MarkerType&gt; types)
 46 {
 47     return m_possiblyExistingMarkerTypes.containsAny(types);
 48 }
 49 
 50 DocumentMarkerController::DocumentMarkerController(Document&amp; document)
 51     : m_document(document)
 52 {
 53 }
 54 
 55 DocumentMarkerController::~DocumentMarkerController() = default;
 56 
 57 void DocumentMarkerController::detach()
 58 {
 59     m_markers.clear();
 60     m_possiblyExistingMarkerTypes = { };
 61 }
 62 
<span class="line-added"> 63 Vector&lt;RefPtr&lt;Range&gt;&gt; DocumentMarkerController::collectTextRanges(const Range&amp; range)</span>
<span class="line-added"> 64 {</span>
<span class="line-added"> 65     Vector&lt;RefPtr&lt;Range&gt;&gt; textRange;</span>
<span class="line-added"> 66     for (TextIterator textIterator(&amp;range); !textIterator.atEnd(); textIterator.advance())</span>
<span class="line-added"> 67         textRange.append(textIterator.range());</span>
<span class="line-added"> 68     return textRange;</span>
<span class="line-added"> 69 }</span>
<span class="line-added"> 70 </span>
 71 void DocumentMarkerController::addMarker(Range&amp; range, DocumentMarker::MarkerType type, const String&amp; description)
 72 {
<span class="line-modified"> 73     for (auto textPiece : collectTextRanges(range))</span>

 74         addMarker(textPiece-&gt;startContainer(), DocumentMarker(type, textPiece-&gt;startOffset(), textPiece-&gt;endOffset(), description));

 75 }
 76 
 77 void DocumentMarkerController::addMarker(Range&amp; range, DocumentMarker::MarkerType type)
 78 {
<span class="line-modified"> 79     for (auto textPiece : collectTextRanges(range))</span>

 80         addMarker(textPiece-&gt;startContainer(), DocumentMarker(type, textPiece-&gt;startOffset(), textPiece-&gt;endOffset()));


 81 }
 82 
 83 void DocumentMarkerController::addMarkerToNode(Node&amp; node, unsigned startOffset, unsigned length, DocumentMarker::MarkerType type)
 84 {
 85     addMarker(node, DocumentMarker(type, startOffset, startOffset + length));
 86 }
 87 
 88 void DocumentMarkerController::addMarkerToNode(Node&amp; node, unsigned startOffset, unsigned length, DocumentMarker::MarkerType type, DocumentMarker::Data&amp;&amp; data)
 89 {
 90     addMarker(node, DocumentMarker(type, startOffset, startOffset + length, WTFMove(data)));
 91 }
 92 
 93 void DocumentMarkerController::addTextMatchMarker(const Range&amp; range, bool activeMatch)
 94 {
<span class="line-modified"> 95     for (auto textPiece : collectTextRanges(range)) {</span>

 96         unsigned startOffset = textPiece-&gt;startOffset();
 97         unsigned endOffset = textPiece-&gt;endOffset();
 98         addMarker(textPiece-&gt;startContainer(), DocumentMarker(startOffset, endOffset, activeMatch));
 99     }
100 }
101 
102 #if PLATFORM(IOS_FAMILY)
103 
104 void DocumentMarkerController::addMarker(Range&amp; range, DocumentMarker::MarkerType type, const String&amp; description, const Vector&lt;String&gt;&amp; interpretations, const RetainPtr&lt;id&gt;&amp; metadata)
105 {
<span class="line-modified">106     for (auto textPiece : collectTextRanges(range))</span>

107         addMarker(textPiece-&gt;startContainer(), DocumentMarker(type, textPiece-&gt;startOffset(), textPiece-&gt;endOffset(), description, interpretations, metadata));

108 }
109 
110 void DocumentMarkerController::addDictationPhraseWithAlternativesMarker(Range&amp; range, const Vector&lt;String&gt;&amp; interpretations)
111 {
112     ASSERT(interpretations.size() &gt; 1);
113     if (interpretations.size() &lt;= 1)
114         return;
115 
116     size_t numberOfAlternatives = interpretations.size() - 1;
<span class="line-modified">117     for (auto textPiece : collectTextRanges(range)) {</span>

118         DocumentMarker marker(DocumentMarker::DictationPhraseWithAlternatives, textPiece-&gt;startOffset(), textPiece-&gt;endOffset(), emptyString(), Vector&lt;String&gt;(numberOfAlternatives), RetainPtr&lt;id&gt;());
119         for (size_t i = 0; i &lt; numberOfAlternatives; ++i)
120             marker.setAlternative(interpretations[i + 1], i);
121         addMarker(textPiece-&gt;startContainer(), marker);
122     }
123 }
124 
125 void DocumentMarkerController::addDictationResultMarker(Range&amp; range, const RetainPtr&lt;id&gt;&amp; metadata)
126 {
<span class="line-modified">127     for (auto textPiece : collectTextRanges(range))</span>

128         addMarker(textPiece-&gt;startContainer(), DocumentMarker(DocumentMarker::DictationResult, textPiece-&gt;startOffset(), textPiece-&gt;endOffset(), String(), Vector&lt;String&gt;(), metadata));

129 }
130 
131 #endif
132 
133 void DocumentMarkerController::addDraggedContentMarker(Range&amp; range)
134 {
<span class="line-modified">135     for (auto textPiece : collectTextRanges(range)) {</span>
<span class="line-modified">136         DocumentMarker::DraggedContentData draggedContentData { textPiece-&gt;firstNode() };</span>

137         addMarker(textPiece-&gt;startContainer(), { DocumentMarker::DraggedContent, textPiece-&gt;startOffset(), textPiece-&gt;endOffset(), WTFMove(draggedContentData) });
138     }
139 }
140 
141 #if ENABLE(PLATFORM_DRIVEN_TEXT_CHECKING)
142 void DocumentMarkerController::addPlatformTextCheckingMarker(Range&amp; range, const String&amp; key, const String&amp; value)
143 {
<span class="line-modified">144     for (auto textPiece : collectTextRanges(range)) {</span>

145         DocumentMarker::PlatformTextCheckingData textCheckingData { key, value };
146         addMarker(textPiece-&gt;startContainer(), { DocumentMarker::PlatformTextChecking, textPiece-&gt;startOffset(), textPiece-&gt;endOffset(), WTFMove(textCheckingData) });
147     }
148 }
149 #endif
150 
151 void DocumentMarkerController::removeMarkers(Range&amp; range, OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypes, RemovePartiallyOverlappingMarkerOrNot shouldRemovePartiallyOverlappingMarker)
152 {
<span class="line-modified">153     for (auto textPiece : collectTextRanges(range)) {</span>
154         if (!possiblyHasMarkers(markerTypes))
155             return;
156         ASSERT(!m_markers.isEmpty());


157         unsigned startOffset = textPiece-&gt;startOffset();
158         unsigned endOffset = textPiece-&gt;endOffset();
159         removeMarkers(textPiece-&gt;startContainer(), startOffset, endOffset - startOffset, markerTypes, nullptr, shouldRemovePartiallyOverlappingMarker);
160     }
161 }
162 
163 void DocumentMarkerController::filterMarkers(Range&amp; range, std::function&lt;bool(DocumentMarker*)&gt; filterFunction, OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypes, RemovePartiallyOverlappingMarkerOrNot shouldRemovePartiallyOverlappingMarker)
164 {
<span class="line-modified">165     for (auto textPiece : collectTextRanges(range)) {</span>
166         if (!possiblyHasMarkers(markerTypes))
167             return;
168         ASSERT(!m_markers.isEmpty());
169 

170         unsigned startOffset = textPiece-&gt;startOffset();
171         unsigned endOffset = textPiece-&gt;endOffset();
172         removeMarkers(textPiece-&gt;startContainer(), startOffset, endOffset - startOffset, markerTypes, filterFunction, shouldRemovePartiallyOverlappingMarker);
173     }
174 }
175 
176 static void updateRenderedRectsForMarker(RenderedDocumentMarker&amp; marker, Node&amp; node)
177 {
178     ASSERT(!node.document().view() || !node.document().view()-&gt;needsLayout());
179 
180     // FIXME: We should refactor this so that we don&#39;t use Range (because we only have one Node), but still share code with absoluteTextQuads().
181     auto markerRange = Range::create(node.document(), &amp;node, marker.startOffset(), &amp;node, marker.endOffset());
182     Vector&lt;FloatQuad&gt; absoluteMarkerQuads;
183     markerRange-&gt;absoluteTextQuads(absoluteMarkerQuads, true);
184 
185     Vector&lt;FloatRect&gt; absoluteMarkerRects;
186     absoluteMarkerRects.reserveInitialCapacity(absoluteMarkerQuads.size());
187     for (const auto&amp; quad : absoluteMarkerQuads)
188         absoluteMarkerRects.uncheckedAppend(quad.boundingBox());
189 
</pre>
</td>
</tr>
</table>
<center><a href="DocumentFullscreen.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DocumentMarkerController.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
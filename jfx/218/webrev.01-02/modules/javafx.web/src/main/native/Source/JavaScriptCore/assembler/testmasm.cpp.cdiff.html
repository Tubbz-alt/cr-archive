<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/testmasm.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="X86Registers.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../b3/B3Bank.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/testmasm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2017-2018 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2017-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 175,28 ***</span>
  T compileAndRun(Generator&amp;&amp; generator, Arguments... arguments)
  {
      return invoke&lt;T&gt;(compile(WTFMove(generator)), arguments...);
  }
  
  void testSimple()
  {
      CHECK_EQ(compileAndRun&lt;int&gt;([] (CCallHelpers&amp; jit) {
<span class="line-modified">!         jit.emitFunctionPrologue();</span>
          jit.move(CCallHelpers::TrustedImm32(42), GPRInfo::returnValueGPR);
<span class="line-modified">!         jit.emitFunctionEpilogue();</span>
          jit.ret();
      }), 42);
  }
  
  void testGetEffectiveAddress(size_t pointer, ptrdiff_t length, int32_t offset, CCallHelpers::Scale scale)
  {
      CHECK_EQ(compileAndRun&lt;size_t&gt;([=] (CCallHelpers&amp; jit) {
<span class="line-modified">!         jit.emitFunctionPrologue();</span>
          jit.move(CCallHelpers::TrustedImmPtr(bitwise_cast&lt;void*&gt;(pointer)), GPRInfo::regT0);
          jit.move(CCallHelpers::TrustedImmPtr(bitwise_cast&lt;void*&gt;(length)), GPRInfo::regT1);
          jit.getEffectiveAddress(CCallHelpers::BaseIndex(GPRInfo::regT0, GPRInfo::regT1, scale, offset), GPRInfo::returnValueGPR);
<span class="line-modified">!         jit.emitFunctionEpilogue();</span>
          jit.ret();
      }), pointer + offset + (static_cast&lt;size_t&gt;(1) &lt;&lt; static_cast&lt;int&gt;(scale)) * length);
  }
  
  // branchTruncateDoubleToInt32(), when encountering Infinity, -Infinity or a
<span class="line-new-header">--- 175,48 ---</span>
  T compileAndRun(Generator&amp;&amp; generator, Arguments... arguments)
  {
      return invoke&lt;T&gt;(compile(WTFMove(generator)), arguments...);
  }
  
<span class="line-added">+ void emitFunctionPrologue(CCallHelpers&amp; jit)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     jit.emitFunctionPrologue();</span>
<span class="line-added">+ #if CPU(ARM_THUMB2)</span>
<span class="line-added">+     // MacroAssemblerARMv7 uses r6 as a temporary register, which is a</span>
<span class="line-added">+     // callee-saved register, see 5.1.1 of the Procedure Call Standard for</span>
<span class="line-added">+     // the ARM Architecture.</span>
<span class="line-added">+     // http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042f/IHI0042F_aapcs.pdf</span>
<span class="line-added">+     jit.push(ARMRegisters::r6);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void emitFunctionEpilogue(CCallHelpers&amp; jit)</span>
<span class="line-added">+ {</span>
<span class="line-added">+ #if CPU(ARM_THUMB2)</span>
<span class="line-added">+     jit.pop(ARMRegisters::r6);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     jit.emitFunctionEpilogue();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void testSimple()
  {
      CHECK_EQ(compileAndRun&lt;int&gt;([] (CCallHelpers&amp; jit) {
<span class="line-modified">!         emitFunctionPrologue(jit);</span>
          jit.move(CCallHelpers::TrustedImm32(42), GPRInfo::returnValueGPR);
<span class="line-modified">!         emitFunctionEpilogue(jit);</span>
          jit.ret();
      }), 42);
  }
  
  void testGetEffectiveAddress(size_t pointer, ptrdiff_t length, int32_t offset, CCallHelpers::Scale scale)
  {
      CHECK_EQ(compileAndRun&lt;size_t&gt;([=] (CCallHelpers&amp; jit) {
<span class="line-modified">!         emitFunctionPrologue(jit);</span>
          jit.move(CCallHelpers::TrustedImmPtr(bitwise_cast&lt;void*&gt;(pointer)), GPRInfo::regT0);
          jit.move(CCallHelpers::TrustedImmPtr(bitwise_cast&lt;void*&gt;(length)), GPRInfo::regT1);
          jit.getEffectiveAddress(CCallHelpers::BaseIndex(GPRInfo::regT0, GPRInfo::regT1, scale, offset), GPRInfo::returnValueGPR);
<span class="line-modified">!         emitFunctionEpilogue(jit);</span>
          jit.ret();
      }), pointer + offset + (static_cast&lt;size_t&gt;(1) &lt;&lt; static_cast&lt;int&gt;(scale)) * length);
  }
  
  // branchTruncateDoubleToInt32(), when encountering Infinity, -Infinity or a
</pre>
<hr />
<pre>
<span class="line-old-header">*** 208,11 ***</span>
      const bool isBigEndian = true;
  #else
      const bool isBigEndian = false;
  #endif
      CHECK_EQ(compileAndRun&lt;int&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified">!         jit.emitFunctionPrologue();</span>
          jit.subPtr(CCallHelpers::TrustedImm32(stackAlignmentBytes()), MacroAssembler::stackPointerRegister);
          if (isBigEndian) {
              jit.store32(CCallHelpers::TrustedImm32(valAsUInt &gt;&gt; 32),
                  MacroAssembler::stackPointerRegister);
              jit.store32(CCallHelpers::TrustedImm32(valAsUInt &amp; 0xffffffff),
<span class="line-new-header">--- 228,11 ---</span>
      const bool isBigEndian = true;
  #else
      const bool isBigEndian = false;
  #endif
      CHECK_EQ(compileAndRun&lt;int&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified">!         emitFunctionPrologue(jit);</span>
          jit.subPtr(CCallHelpers::TrustedImm32(stackAlignmentBytes()), MacroAssembler::stackPointerRegister);
          if (isBigEndian) {
              jit.store32(CCallHelpers::TrustedImm32(valAsUInt &gt;&gt; 32),
                  MacroAssembler::stackPointerRegister);
              jit.store32(CCallHelpers::TrustedImm32(valAsUInt &amp; 0xffffffff),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 230,11 ***</span>
  
          jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
  
          done.link(&amp;jit);
          jit.addPtr(CCallHelpers::TrustedImm32(stackAlignmentBytes()), MacroAssembler::stackPointerRegister);
<span class="line-modified">!         jit.emitFunctionEpilogue();</span>
          jit.ret();
      }), expected);
  }
  
  
<span class="line-new-header">--- 250,11 ---</span>
  
          jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
  
          done.link(&amp;jit);
          jit.addPtr(CCallHelpers::TrustedImm32(stackAlignmentBytes()), MacroAssembler::stackPointerRegister);
<span class="line-modified">!         emitFunctionEpilogue(jit);</span>
          jit.ret();
      }), expected);
  }
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 314,136 ***</span>
  #endif
  
  #if CPU(X86_64)
  void testBranchTestBit32RegReg()
  {
<span class="line-modified">!     for (uint32_t value : int32Operands()) {</span>
          auto test = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified">!             jit.emitFunctionPrologue();</span>
  
              auto branch = jit.branchTestBit32(MacroAssembler::NonZero, GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
              jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
              auto done = jit.jump();
              branch.link(&amp;jit);
              jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
              done.link(&amp;jit);
  
<span class="line-modified">!             jit.emitFunctionEpilogue();</span>
              jit.ret();
          });
  
<span class="line-modified">!         for (uint32_t value2 : int32Operands())</span>
              CHECK_EQ(invoke&lt;int&gt;(test, value, value2), (value&gt;&gt;(value2%32))&amp;1);
      }
  }
  
  void testBranchTestBit32RegImm()
  {
<span class="line-modified">!     for (uint32_t value : int32Operands()) {</span>
          auto test = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified">!             jit.emitFunctionPrologue();</span>
  
              auto branch = jit.branchTestBit32(MacroAssembler::NonZero, GPRInfo::argumentGPR0, CCallHelpers::TrustedImm32(value));
              jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
              auto done = jit.jump();
              branch.link(&amp;jit);
              jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
              done.link(&amp;jit);
  
<span class="line-modified">!             jit.emitFunctionEpilogue();</span>
              jit.ret();
          });
  
<span class="line-modified">!         for (uint32_t value2 : int32Operands())</span>
              CHECK_EQ(invoke&lt;int&gt;(test, value2), (value2&gt;&gt;(value%32))&amp;1);
      }
  }
  
  void testBranchTestBit32AddrImm()
  {
<span class="line-modified">!     for (uint32_t value : int32Operands()) {</span>
          auto test = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified">!             jit.emitFunctionPrologue();</span>
  
              auto branch = jit.branchTestBit32(MacroAssembler::NonZero, MacroAssembler::Address(GPRInfo::argumentGPR0, 0), CCallHelpers::TrustedImm32(value));
              jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
              auto done = jit.jump();
              branch.link(&amp;jit);
              jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
              done.link(&amp;jit);
  
<span class="line-modified">!             jit.emitFunctionEpilogue();</span>
              jit.ret();
          });
  
<span class="line-modified">!         for (uint32_t value2 : int32Operands())</span>
              CHECK_EQ(invoke&lt;int&gt;(test, &amp;value2), (value2&gt;&gt;(value%32))&amp;1);
      }
  }
  
  void testBranchTestBit64RegReg()
  {
<span class="line-modified">!     for (uint64_t value : int64Operands()) {</span>
          auto test = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified">!             jit.emitFunctionPrologue();</span>
  
              auto branch = jit.branchTestBit64(MacroAssembler::NonZero, GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
              jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::returnValueGPR);
              auto done = jit.jump();
              branch.link(&amp;jit);
              jit.move(CCallHelpers::TrustedImm64(1), GPRInfo::returnValueGPR);
              done.link(&amp;jit);
  
<span class="line-modified">!             jit.emitFunctionEpilogue();</span>
              jit.ret();
          });
  
<span class="line-modified">!         for (uint64_t value2 : int64Operands())</span>
              CHECK_EQ(invoke&lt;long int&gt;(test, value, value2), (value&gt;&gt;(value2%64))&amp;1);
      }
  }
  
  void testBranchTestBit64RegImm()
  {
<span class="line-modified">!     for (uint64_t value : int64Operands()) {</span>
          auto test = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified">!             jit.emitFunctionPrologue();</span>
  
              auto branch = jit.branchTestBit64(MacroAssembler::NonZero, GPRInfo::argumentGPR0, CCallHelpers::TrustedImm32(value));
              jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::returnValueGPR);
              auto done = jit.jump();
              branch.link(&amp;jit);
              jit.move(CCallHelpers::TrustedImm64(1), GPRInfo::returnValueGPR);
              done.link(&amp;jit);
  
<span class="line-modified">!             jit.emitFunctionEpilogue();</span>
              jit.ret();
          });
  
<span class="line-modified">!         for (uint64_t value2 : int64Operands())</span>
              CHECK_EQ(invoke&lt;long int&gt;(test, value2), (value2&gt;&gt;(value%64))&amp;1);
      }
  }
  
  void testBranchTestBit64AddrImm()
  {
<span class="line-modified">!     for (uint64_t value : int64Operands()) {</span>
          auto test = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified">!             jit.emitFunctionPrologue();</span>
  
              auto branch = jit.branchTestBit64(MacroAssembler::NonZero, MacroAssembler::Address(GPRInfo::argumentGPR0, 0), CCallHelpers::TrustedImm32(value));
              jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::returnValueGPR);
              auto done = jit.jump();
              branch.link(&amp;jit);
              jit.move(CCallHelpers::TrustedImm64(1), GPRInfo::returnValueGPR);
              done.link(&amp;jit);
  
<span class="line-modified">!             jit.emitFunctionEpilogue();</span>
              jit.ret();
          });
  
<span class="line-modified">!         for (uint64_t value2 : int64Operands())</span>
              CHECK_EQ(invoke&lt;long int&gt;(test, &amp;value2), (value2&gt;&gt;(value%64))&amp;1);
      }
  }
  
  #endif
<span class="line-new-header">--- 334,136 ---</span>
  #endif
  
  #if CPU(X86_64)
  void testBranchTestBit32RegReg()
  {
<span class="line-modified">!     for (auto value : int32Operands()) {</span>
          auto test = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified">!             emitFunctionPrologue(jit);</span>
  
              auto branch = jit.branchTestBit32(MacroAssembler::NonZero, GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
              jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
              auto done = jit.jump();
              branch.link(&amp;jit);
              jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
              done.link(&amp;jit);
  
<span class="line-modified">!             emitFunctionEpilogue(jit);</span>
              jit.ret();
          });
  
<span class="line-modified">!         for (auto value2 : int32Operands())</span>
              CHECK_EQ(invoke&lt;int&gt;(test, value, value2), (value&gt;&gt;(value2%32))&amp;1);
      }
  }
  
  void testBranchTestBit32RegImm()
  {
<span class="line-modified">!     for (auto value : int32Operands()) {</span>
          auto test = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified">!             emitFunctionPrologue(jit);</span>
  
              auto branch = jit.branchTestBit32(MacroAssembler::NonZero, GPRInfo::argumentGPR0, CCallHelpers::TrustedImm32(value));
              jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
              auto done = jit.jump();
              branch.link(&amp;jit);
              jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
              done.link(&amp;jit);
  
<span class="line-modified">!             emitFunctionEpilogue(jit);</span>
              jit.ret();
          });
  
<span class="line-modified">!         for (auto value2 : int32Operands())</span>
              CHECK_EQ(invoke&lt;int&gt;(test, value2), (value2&gt;&gt;(value%32))&amp;1);
      }
  }
  
  void testBranchTestBit32AddrImm()
  {
<span class="line-modified">!     for (auto value : int32Operands()) {</span>
          auto test = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified">!             emitFunctionPrologue(jit);</span>
  
              auto branch = jit.branchTestBit32(MacroAssembler::NonZero, MacroAssembler::Address(GPRInfo::argumentGPR0, 0), CCallHelpers::TrustedImm32(value));
              jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
              auto done = jit.jump();
              branch.link(&amp;jit);
              jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
              done.link(&amp;jit);
  
<span class="line-modified">!             emitFunctionEpilogue(jit);</span>
              jit.ret();
          });
  
<span class="line-modified">!         for (auto value2 : int32Operands())</span>
              CHECK_EQ(invoke&lt;int&gt;(test, &amp;value2), (value2&gt;&gt;(value%32))&amp;1);
      }
  }
  
  void testBranchTestBit64RegReg()
  {
<span class="line-modified">!     for (auto value : int64Operands()) {</span>
          auto test = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified">!             emitFunctionPrologue(jit);</span>
  
              auto branch = jit.branchTestBit64(MacroAssembler::NonZero, GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
              jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::returnValueGPR);
              auto done = jit.jump();
              branch.link(&amp;jit);
              jit.move(CCallHelpers::TrustedImm64(1), GPRInfo::returnValueGPR);
              done.link(&amp;jit);
  
<span class="line-modified">!             emitFunctionEpilogue(jit);</span>
              jit.ret();
          });
  
<span class="line-modified">!         for (auto value2 : int64Operands())</span>
              CHECK_EQ(invoke&lt;long int&gt;(test, value, value2), (value&gt;&gt;(value2%64))&amp;1);
      }
  }
  
  void testBranchTestBit64RegImm()
  {
<span class="line-modified">!     for (auto value : int64Operands()) {</span>
          auto test = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified">!             emitFunctionPrologue(jit);</span>
  
              auto branch = jit.branchTestBit64(MacroAssembler::NonZero, GPRInfo::argumentGPR0, CCallHelpers::TrustedImm32(value));
              jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::returnValueGPR);
              auto done = jit.jump();
              branch.link(&amp;jit);
              jit.move(CCallHelpers::TrustedImm64(1), GPRInfo::returnValueGPR);
              done.link(&amp;jit);
  
<span class="line-modified">!             emitFunctionEpilogue(jit);</span>
              jit.ret();
          });
  
<span class="line-modified">!         for (auto value2 : int64Operands())</span>
              CHECK_EQ(invoke&lt;long int&gt;(test, value2), (value2&gt;&gt;(value%64))&amp;1);
      }
  }
  
  void testBranchTestBit64AddrImm()
  {
<span class="line-modified">!     for (auto value : int64Operands()) {</span>
          auto test = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified">!             emitFunctionPrologue(jit);</span>
  
              auto branch = jit.branchTestBit64(MacroAssembler::NonZero, MacroAssembler::Address(GPRInfo::argumentGPR0, 0), CCallHelpers::TrustedImm32(value));
              jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::returnValueGPR);
              auto done = jit.jump();
              branch.link(&amp;jit);
              jit.move(CCallHelpers::TrustedImm64(1), GPRInfo::returnValueGPR);
              done.link(&amp;jit);
  
<span class="line-modified">!             emitFunctionEpilogue(jit);</span>
              jit.ret();
          });
  
<span class="line-modified">!         for (auto value2 : int64Operands())</span>
              CHECK_EQ(invoke&lt;long int&gt;(test, &amp;value2), (value2&gt;&gt;(value%64))&amp;1);
      }
  }
  
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 452,32 ***</span>
  {
      double arg1 = 0;
      double arg2 = 0;
  
      auto compareDouble = compile([&amp;, condition] (CCallHelpers&amp; jit) {
<span class="line-modified">!         jit.emitFunctionPrologue();</span>
  
          jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT0);
          jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT1);
          jit.move(CCallHelpers::TrustedImm32(-1), GPRInfo::returnValueGPR);
          jit.compareDouble(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1, GPRInfo::returnValueGPR);
  
<span class="line-modified">!         jit.emitFunctionEpilogue();</span>
          jit.ret();
      });
  
      auto compareDoubleGeneric = compile([&amp;, condition] (CCallHelpers&amp; jit) {
<span class="line-modified">!         jit.emitFunctionPrologue();</span>
  
          jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT0);
          jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT1);
          jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
          auto jump = jit.branchDouble(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1);
          jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
          jump.link(&amp;jit);
  
<span class="line-modified">!         jit.emitFunctionEpilogue();</span>
          jit.ret();
      });
  
      auto operands = doubleOperands();
      for (auto a : operands) {
<span class="line-new-header">--- 472,32 ---</span>
  {
      double arg1 = 0;
      double arg2 = 0;
  
      auto compareDouble = compile([&amp;, condition] (CCallHelpers&amp; jit) {
<span class="line-modified">!         emitFunctionPrologue(jit);</span>
  
          jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT0);
          jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT1);
          jit.move(CCallHelpers::TrustedImm32(-1), GPRInfo::returnValueGPR);
          jit.compareDouble(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1, GPRInfo::returnValueGPR);
  
<span class="line-modified">!         emitFunctionEpilogue(jit);</span>
          jit.ret();
      });
  
      auto compareDoubleGeneric = compile([&amp;, condition] (CCallHelpers&amp; jit) {
<span class="line-modified">!         emitFunctionPrologue(jit);</span>
  
          jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT0);
          jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT1);
          jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
          auto jump = jit.branchDouble(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1);
          jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
          jump.link(&amp;jit);
  
<span class="line-modified">!         emitFunctionEpilogue(jit);</span>
          jit.ret();
      });
  
      auto operands = doubleOperands();
      for (auto a : operands) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 491,15 ***</span>
  
  void testMul32WithImmediates()
  {
      for (auto immediate : int32Operands()) {
          auto mul = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified">!             jit.emitFunctionPrologue();</span>
  
              jit.mul32(CCallHelpers::TrustedImm32(immediate), GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
  
<span class="line-modified">!             jit.emitFunctionEpilogue();</span>
              jit.ret();
          });
  
          for (auto value : int32Operands())
              CHECK_EQ(invoke&lt;int&gt;(mul, value), immediate * value);
<span class="line-new-header">--- 511,15 ---</span>
  
  void testMul32WithImmediates()
  {
      for (auto immediate : int32Operands()) {
          auto mul = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified">!             emitFunctionPrologue(jit);</span>
  
              jit.mul32(CCallHelpers::TrustedImm32(immediate), GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
  
<span class="line-modified">!             emitFunctionEpilogue(jit);</span>
              jit.ret();
          });
  
          for (auto value : int32Operands())
              CHECK_EQ(invoke&lt;int&gt;(mul, value), immediate * value);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 509,15 ***</span>
  #if CPU(ARM64)
  void testMul32SignExtend()
  {
      for (auto value : int32Operands()) {
          auto mul = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified">!             jit.emitFunctionPrologue();</span>
  
              jit.multiplySignExtend32(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1, GPRInfo::returnValueGPR);
  
<span class="line-modified">!             jit.emitFunctionEpilogue();</span>
              jit.ret();
          });
  
          for (auto value2 : int32Operands())
              CHECK_EQ(invoke&lt;long int&gt;(mul, value, value2), ((long int) value) * ((long int) value2));
<span class="line-new-header">--- 529,15 ---</span>
  #if CPU(ARM64)
  void testMul32SignExtend()
  {
      for (auto value : int32Operands()) {
          auto mul = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified">!             emitFunctionPrologue(jit);</span>
  
              jit.multiplySignExtend32(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1, GPRInfo::returnValueGPR);
  
<span class="line-modified">!             emitFunctionEpilogue(jit);</span>
              jit.ret();
          });
  
          for (auto value2 : int32Operands())
              CHECK_EQ(invoke&lt;long int&gt;(mul, value, value2), ((long int) value) * ((long int) value2));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 530,32 ***</span>
  {
      float arg1 = 0;
      float arg2 = 0;
  
      auto compareFloat = compile([&amp;, condition] (CCallHelpers&amp; jit) {
<span class="line-modified">!         jit.emitFunctionPrologue();</span>
  
          jit.loadFloat(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT0);
          jit.loadFloat(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT1);
          jit.move(CCallHelpers::TrustedImm32(-1), GPRInfo::returnValueGPR);
          jit.compareFloat(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1, GPRInfo::returnValueGPR);
  
<span class="line-modified">!         jit.emitFunctionEpilogue();</span>
          jit.ret();
      });
  
      auto compareFloatGeneric = compile([&amp;, condition] (CCallHelpers&amp; jit) {
<span class="line-modified">!         jit.emitFunctionPrologue();</span>
  
          jit.loadFloat(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT0);
          jit.loadFloat(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT1);
          jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
          auto jump = jit.branchFloat(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1);
          jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
          jump.link(&amp;jit);
  
<span class="line-modified">!         jit.emitFunctionEpilogue();</span>
          jit.ret();
      });
  
      auto operands = floatOperands();
      for (auto a : operands) {
<span class="line-new-header">--- 550,32 ---</span>
  {
      float arg1 = 0;
      float arg2 = 0;
  
      auto compareFloat = compile([&amp;, condition] (CCallHelpers&amp; jit) {
<span class="line-modified">!         emitFunctionPrologue(jit);</span>
  
          jit.loadFloat(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT0);
          jit.loadFloat(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT1);
          jit.move(CCallHelpers::TrustedImm32(-1), GPRInfo::returnValueGPR);
          jit.compareFloat(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1, GPRInfo::returnValueGPR);
  
<span class="line-modified">!         emitFunctionEpilogue(jit);</span>
          jit.ret();
      });
  
      auto compareFloatGeneric = compile([&amp;, condition] (CCallHelpers&amp; jit) {
<span class="line-modified">!         emitFunctionPrologue(jit);</span>
  
          jit.loadFloat(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT0);
          jit.loadFloat(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT1);
          jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
          auto jump = jit.branchFloat(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1);
          jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
          jump.link(&amp;jit);
  
<span class="line-modified">!         emitFunctionEpilogue(jit);</span>
          jit.ret();
      });
  
      auto operands = floatOperands();
      for (auto a : operands) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 571,11 ***</span>
  #if ENABLE(MASM_PROBE)
  void testProbeReadsArgumentRegisters()
  {
      bool probeWasCalled = false;
      compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified">!         jit.emitFunctionPrologue();</span>
  
          jit.pushPair(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
          jit.pushPair(GPRInfo::argumentGPR2, GPRInfo::argumentGPR3);
  
          jit.move(CCallHelpers::TrustedImm32(testWord32(0)), GPRInfo::argumentGPR0);
<span class="line-new-header">--- 591,11 ---</span>
  #if ENABLE(MASM_PROBE)
  void testProbeReadsArgumentRegisters()
  {
      bool probeWasCalled = false;
      compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified">!         emitFunctionPrologue(jit);</span>
  
          jit.pushPair(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
          jit.pushPair(GPRInfo::argumentGPR2, GPRInfo::argumentGPR3);
  
          jit.move(CCallHelpers::TrustedImm32(testWord32(0)), GPRInfo::argumentGPR0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 607,11 ***</span>
          });
  
          jit.popPair(GPRInfo::argumentGPR2, GPRInfo::argumentGPR3);
          jit.popPair(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
  
<span class="line-modified">!         jit.emitFunctionEpilogue();</span>
          jit.ret();
      });
      CHECK_EQ(probeWasCalled, true);
  }
  
<span class="line-new-header">--- 627,11 ---</span>
          });
  
          jit.popPair(GPRInfo::argumentGPR2, GPRInfo::argumentGPR3);
          jit.popPair(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
  
<span class="line-modified">!         emitFunctionEpilogue(jit);</span>
          jit.ret();
      });
      CHECK_EQ(probeWasCalled, true);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 620,11 ***</span>
      // This test relies on testProbeReadsArgumentRegisters() having already validated
      // that we can read from argument registers. We&#39;ll use that ability to validate
      // that our writes did take effect.
      unsigned probeCallCount = 0;
      compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified">!         jit.emitFunctionPrologue();</span>
  
          jit.pushPair(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
          jit.pushPair(GPRInfo::argumentGPR2, GPRInfo::argumentGPR3);
  
          // Pre-initialize with non-expected values.
<span class="line-new-header">--- 640,11 ---</span>
      // This test relies on testProbeReadsArgumentRegisters() having already validated
      // that we can read from argument registers. We&#39;ll use that ability to validate
      // that our writes did take effect.
      unsigned probeCallCount = 0;
      compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified">!         emitFunctionPrologue(jit);</span>
  
          jit.pushPair(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
          jit.pushPair(GPRInfo::argumentGPR2, GPRInfo::argumentGPR3);
  
          // Pre-initialize with non-expected values.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 669,11 ***</span>
          });
  
          jit.popPair(GPRInfo::argumentGPR2, GPRInfo::argumentGPR3);
          jit.popPair(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
  
<span class="line-modified">!         jit.emitFunctionEpilogue();</span>
          jit.ret();
      });
      CHECK_EQ(probeCallCount, 2);
  }
  
<span class="line-new-header">--- 689,11 ---</span>
          });
  
          jit.popPair(GPRInfo::argumentGPR2, GPRInfo::argumentGPR3);
          jit.popPair(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
  
<span class="line-modified">!         emitFunctionEpilogue(jit);</span>
          jit.ret();
      });
      CHECK_EQ(probeCallCount, 2);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 697,11 ***</span>
      // to validate that the probe preserves register values.
      unsigned probeCallCount = 0;
      CPUState originalState;
  
      compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified">!         jit.emitFunctionPrologue();</span>
  
          // Write expected values into the registers (except for sp, fp, and pc).
          jit.probe([&amp;] (Probe::Context&amp; context) {
              auto&amp; cpu = context.cpu;
              probeCallCount++;
<span class="line-new-header">--- 717,11 ---</span>
      // to validate that the probe preserves register values.
      unsigned probeCallCount = 0;
      CPUState originalState;
  
      compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified">!         emitFunctionPrologue(jit);</span>
  
          // Write expected values into the registers (except for sp, fp, and pc).
          jit.probe([&amp;] (Probe::Context&amp; context) {
              auto&amp; cpu = context.cpu;
              probeCallCount++;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 771,11 ***</span>
                  if (!(id &amp; 1))
  #endif
                  CHECK_EQ(cpu.fpr&lt;uint64_t&gt;(id), originalState.fpr&lt;uint64_t&gt;(id));
          });
  
<span class="line-modified">!         jit.emitFunctionEpilogue();</span>
          jit.ret();
      });
      CHECK_EQ(probeCallCount, 5);
  }
  
<span class="line-new-header">--- 791,11 ---</span>
                  if (!(id &amp; 1))
  #endif
                  CHECK_EQ(cpu.fpr&lt;uint64_t&gt;(id), originalState.fpr&lt;uint64_t&gt;(id));
          });
  
<span class="line-modified">!         emitFunctionEpilogue(jit);</span>
          jit.ret();
      });
      CHECK_EQ(probeCallCount, 5);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 799,11 ***</span>
      auto flagsSPR = ARM64Registers::nzcv;
      uintptr_t flagsMask = 0xf0000000;
  #endif
  
      compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified">!         jit.emitFunctionPrologue();</span>
  
          // Preserve original stack pointer and modify the sp, and
          // write expected values into other registers (except for fp, and pc).
          jit.probe([&amp;] (Probe::Context&amp; context) {
              auto&amp; cpu = context.cpu;
<span class="line-new-header">--- 819,11 ---</span>
      auto flagsSPR = ARM64Registers::nzcv;
      uintptr_t flagsMask = 0xf0000000;
  #endif
  
      compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified">!         emitFunctionPrologue(jit);</span>
  
          // Preserve original stack pointer and modify the sp, and
          // write expected values into other registers (except for fp, and pc).
          jit.probe([&amp;] (Probe::Context&amp; context) {
              auto&amp; cpu = context.cpu;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 889,11 ***</span>
              CHECK_EQ(cpu.spr(flagsSPR) &amp; flagsMask, originalState.spr(flagsSPR) &amp; flagsMask);
  #endif
              CHECK_EQ(cpu.sp(), originalSP);
          });
  
<span class="line-modified">!         jit.emitFunctionEpilogue();</span>
          jit.ret();
      });
      CHECK_EQ(probeCallCount, 4);
  }
  
<span class="line-new-header">--- 909,11 ---</span>
              CHECK_EQ(cpu.spr(flagsSPR) &amp; flagsMask, originalState.spr(flagsSPR) &amp; flagsMask);
  #endif
              CHECK_EQ(cpu.sp(), originalSP);
          });
  
<span class="line-modified">!         emitFunctionEpilogue(jit);</span>
          jit.ret();
      });
      CHECK_EQ(probeCallCount, 4);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 939,16 ***</span>
          jit.probe([&amp;] (Probe::Context&amp;) {
              probeCallCount++;
              continuationWasReached = true;
          });
  
<span class="line-modified">!         jit.emitFunctionEpilogue();</span>
          jit.ret();
      });
  
      compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified">!         jit.emitFunctionPrologue();</span>
  
          // Write expected values into the registers.
          jit.probe([&amp;] (Probe::Context&amp; context) {
              probeCallCount++;
              context.cpu.pc() = untagCodePtr(continuation.code().executableAddress(), JSEntryPtrTag);
<span class="line-new-header">--- 959,16 ---</span>
          jit.probe([&amp;] (Probe::Context&amp;) {
              probeCallCount++;
              continuationWasReached = true;
          });
  
<span class="line-modified">!         emitFunctionEpilogue(jit);</span>
          jit.ret();
      });
  
      compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified">!         emitFunctionPrologue(jit);</span>
  
          // Write expected values into the registers.
          jit.probe([&amp;] (Probe::Context&amp; context) {
              probeCallCount++;
              context.cpu.pc() = untagCodePtr(continuation.code().executableAddress(), JSEntryPtrTag);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 981,11 ***</span>
      MacroAssembler::SPRegisterID flagsSPR = ARM64Registers::nzcv;
      uintptr_t flagsMask = 0xf0000000;
  #endif
  
      compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified">!         jit.emitFunctionPrologue();</span>
  
          // Write expected values into the registers.
          jit.probe([&amp;] (Probe::Context&amp; context) {
              auto&amp; cpu = context.cpu;
              auto&amp; stack = context.stack();
<span class="line-new-header">--- 1001,11 ---</span>
      MacroAssembler::SPRegisterID flagsSPR = ARM64Registers::nzcv;
      uintptr_t flagsMask = 0xf0000000;
  #endif
  
      compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified">!         emitFunctionPrologue(jit);</span>
  
          // Write expected values into the registers.
          jit.probe([&amp;] (Probe::Context&amp; context) {
              auto&amp; cpu = context.cpu;
              auto&amp; stack = context.stack();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1074,46 ***</span>
              cpu.spr(flagsSPR) = originalState.spr(flagsSPR);
  #endif
              cpu.sp() = originalSP;
          });
  
<span class="line-modified">!         jit.emitFunctionEpilogue();</span>
          jit.ret();
      });
  
      CHECK_EQ(probeCallCount, 3);
  }
  #endif // ENABLE(MASM_PROBE)
  
  void testByteSwap()
  {
  #if CPU(X86_64) || CPU(ARM64)
      auto byteSwap16 = compile([] (CCallHelpers&amp; jit) {
<span class="line-modified">!         jit.emitFunctionPrologue();</span>
          jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
          jit.byteSwap16(GPRInfo::returnValueGPR);
<span class="line-modified">!         jit.emitFunctionEpilogue();</span>
          jit.ret();
      });
      CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap16, 0xaabbccddee001122), static_cast&lt;uint64_t&gt;(0x2211));
      CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap16, 0xaabbccddee00ffaa), static_cast&lt;uint64_t&gt;(0xaaff));
  
      auto byteSwap32 = compile([] (CCallHelpers&amp; jit) {
<span class="line-modified">!         jit.emitFunctionPrologue();</span>
          jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
          jit.byteSwap32(GPRInfo::returnValueGPR);
<span class="line-modified">!         jit.emitFunctionEpilogue();</span>
          jit.ret();
      });
      CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap32, 0xaabbccddee001122), static_cast&lt;uint64_t&gt;(0x221100ee));
      CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap32, 0xaabbccddee00ffaa), static_cast&lt;uint64_t&gt;(0xaaff00ee));
  
      auto byteSwap64 = compile([] (CCallHelpers&amp; jit) {
<span class="line-modified">!         jit.emitFunctionPrologue();</span>
          jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
          jit.byteSwap64(GPRInfo::returnValueGPR);
<span class="line-modified">!         jit.emitFunctionEpilogue();</span>
          jit.ret();
      });
      CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap64, 0xaabbccddee001122), static_cast&lt;uint64_t&gt;(0x221100eeddccbbaa));
      CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap64, 0xaabbccddee00ffaa), static_cast&lt;uint64_t&gt;(0xaaff00eeddccbbaa));
  #endif
<span class="line-new-header">--- 1094,81 ---</span>
              cpu.spr(flagsSPR) = originalState.spr(flagsSPR);
  #endif
              cpu.sp() = originalSP;
          });
  
<span class="line-modified">!         emitFunctionEpilogue(jit);</span>
          jit.ret();
      });
  
      CHECK_EQ(probeCallCount, 3);
  }
  #endif // ENABLE(MASM_PROBE)
  
<span class="line-added">+ void testOrImmMem()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // FIXME: this does not test that the or does not touch beyond its width.</span>
<span class="line-added">+     // I am not sure how to do such a test without a lot of complexity (running multiple threads, with a race on the high bits of the memory location).</span>
<span class="line-added">+     uint64_t memoryLocation = 0x12341234;</span>
<span class="line-added">+     auto or32 = compile([&amp;] (CCallHelpers&amp; jit) {</span>
<span class="line-added">+         emitFunctionPrologue(jit);</span>
<span class="line-added">+         jit.or32(CCallHelpers::TrustedImm32(42), CCallHelpers::AbsoluteAddress(&amp;memoryLocation));</span>
<span class="line-added">+         emitFunctionEpilogue(jit);</span>
<span class="line-added">+         jit.ret();</span>
<span class="line-added">+     });</span>
<span class="line-added">+     invoke&lt;void&gt;(or32);</span>
<span class="line-added">+     CHECK_EQ(memoryLocation, 0x12341234 | 42);</span>
<span class="line-added">+ </span>
<span class="line-added">+     memoryLocation = 0x12341234;</span>
<span class="line-added">+     auto or16 = compile([&amp;] (CCallHelpers&amp; jit) {</span>
<span class="line-added">+         emitFunctionPrologue(jit);</span>
<span class="line-added">+         jit.or16(CCallHelpers::TrustedImm32(42), CCallHelpers::AbsoluteAddress(&amp;memoryLocation));</span>
<span class="line-added">+         emitFunctionEpilogue(jit);</span>
<span class="line-added">+         jit.ret();</span>
<span class="line-added">+     });</span>
<span class="line-added">+     invoke&lt;void&gt;(or16);</span>
<span class="line-added">+     CHECK_EQ(memoryLocation, 0x12341234 | 42);</span>
<span class="line-added">+ </span>
<span class="line-added">+     memoryLocation = 0x12341234;</span>
<span class="line-added">+     auto or16InvalidLogicalImmInARM64 = compile([&amp;] (CCallHelpers&amp; jit) {</span>
<span class="line-added">+         emitFunctionPrologue(jit);</span>
<span class="line-added">+         jit.or16(CCallHelpers::TrustedImm32(0), CCallHelpers::AbsoluteAddress(&amp;memoryLocation));</span>
<span class="line-added">+         emitFunctionEpilogue(jit);</span>
<span class="line-added">+         jit.ret();</span>
<span class="line-added">+     });</span>
<span class="line-added">+     invoke&lt;void&gt;(or16InvalidLogicalImmInARM64);</span>
<span class="line-added">+     CHECK_EQ(memoryLocation, 0x12341234);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void testByteSwap()
  {
  #if CPU(X86_64) || CPU(ARM64)
      auto byteSwap16 = compile([] (CCallHelpers&amp; jit) {
<span class="line-modified">!         emitFunctionPrologue(jit);</span>
          jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
          jit.byteSwap16(GPRInfo::returnValueGPR);
<span class="line-modified">!         emitFunctionEpilogue(jit);</span>
          jit.ret();
      });
      CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap16, 0xaabbccddee001122), static_cast&lt;uint64_t&gt;(0x2211));
      CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap16, 0xaabbccddee00ffaa), static_cast&lt;uint64_t&gt;(0xaaff));
  
      auto byteSwap32 = compile([] (CCallHelpers&amp; jit) {
<span class="line-modified">!         emitFunctionPrologue(jit);</span>
          jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
          jit.byteSwap32(GPRInfo::returnValueGPR);
<span class="line-modified">!         emitFunctionEpilogue(jit);</span>
          jit.ret();
      });
      CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap32, 0xaabbccddee001122), static_cast&lt;uint64_t&gt;(0x221100ee));
      CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap32, 0xaabbccddee00ffaa), static_cast&lt;uint64_t&gt;(0xaaff00ee));
  
      auto byteSwap64 = compile([] (CCallHelpers&amp; jit) {
<span class="line-modified">!         emitFunctionPrologue(jit);</span>
          jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
          jit.byteSwap64(GPRInfo::returnValueGPR);
<span class="line-modified">!         emitFunctionEpilogue(jit);</span>
          jit.ret();
      });
      CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap64, 0xaabbccddee001122), static_cast&lt;uint64_t&gt;(0x221100eeddccbbaa));
      CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap64, 0xaabbccddee00ffaa), static_cast&lt;uint64_t&gt;(0xaaff00eeddccbbaa));
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1128,19 ***</span>
  
      const double chosenDouble = 6.00000059604644775390625;
      CHECK_EQ(static_cast&lt;double&gt;(static_cast&lt;float&gt;(chosenDouble)) == chosenDouble, false);
  
      auto sel = compile([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified">!         jit.emitFunctionPrologue();</span>
          jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;zero), FPRInfo::returnValueFPR);
          jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT1);
          jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT2);
  
          jit.move(MacroAssembler::TrustedImm32(-1), GPRInfo::regT0);
          jit.moveDoubleConditionally32(MacroAssembler::Equal, GPRInfo::regT0, GPRInfo::regT0, FPRInfo::fpRegT1, FPRInfo::fpRegT2, FPRInfo::returnValueFPR);
  
<span class="line-modified">!         jit.emitFunctionEpilogue();</span>
          jit.ret();
      });
  
      arg1 = chosenDouble;
      arg2 = 43;
<span class="line-new-header">--- 1183,19 ---</span>
  
      const double chosenDouble = 6.00000059604644775390625;
      CHECK_EQ(static_cast&lt;double&gt;(static_cast&lt;float&gt;(chosenDouble)) == chosenDouble, false);
  
      auto sel = compile([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified">!         emitFunctionPrologue(jit);</span>
          jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;zero), FPRInfo::returnValueFPR);
          jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT1);
          jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT2);
  
          jit.move(MacroAssembler::TrustedImm32(-1), GPRInfo::regT0);
          jit.moveDoubleConditionally32(MacroAssembler::Equal, GPRInfo::regT0, GPRInfo::regT0, FPRInfo::fpRegT1, FPRInfo::fpRegT2, FPRInfo::returnValueFPR);
  
<span class="line-modified">!         emitFunctionEpilogue(jit);</span>
          jit.ret();
      });
  
      arg1 = chosenDouble;
      arg2 = 43;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1162,19 ***</span>
  
      const double chosenDouble = 6.00000059604644775390625;
      CHECK_EQ(static_cast&lt;double&gt;(static_cast&lt;float&gt;(chosenDouble)) == chosenDouble, false);
  
      auto sel = compile([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified">!         jit.emitFunctionPrologue();</span>
          jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;zero), FPRInfo::returnValueFPR);
          jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT1);
          jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT2);
  
          jit.move(MacroAssembler::TrustedImm64(-1), GPRInfo::regT0);
          jit.moveDoubleConditionally64(MacroAssembler::Equal, GPRInfo::regT0, GPRInfo::regT0, FPRInfo::fpRegT1, FPRInfo::fpRegT2, FPRInfo::returnValueFPR);
  
<span class="line-modified">!         jit.emitFunctionEpilogue();</span>
          jit.ret();
      });
  
      arg1 = chosenDouble;
      arg2 = 43;
<span class="line-new-header">--- 1217,19 ---</span>
  
      const double chosenDouble = 6.00000059604644775390625;
      CHECK_EQ(static_cast&lt;double&gt;(static_cast&lt;float&gt;(chosenDouble)) == chosenDouble, false);
  
      auto sel = compile([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified">!         emitFunctionPrologue(jit);</span>
          jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;zero), FPRInfo::returnValueFPR);
          jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT1);
          jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT2);
  
          jit.move(MacroAssembler::TrustedImm64(-1), GPRInfo::regT0);
          jit.moveDoubleConditionally64(MacroAssembler::Equal, GPRInfo::regT0, GPRInfo::regT0, FPRInfo::fpRegT1, FPRInfo::fpRegT2, FPRInfo::returnValueFPR);
  
<span class="line-modified">!         emitFunctionEpilogue(jit);</span>
          jit.ret();
      });
  
      arg1 = chosenDouble;
      arg2 = 43;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1188,22 ***</span>
  }
  
  static void testCagePreservesPACFailureBit()
  {
  #if GIGACAGE_ENABLED
<span class="line-modified">!     ASSERT(!Gigacage::isDisablingPrimitiveGigacageDisabled());</span>
      auto cage = compile([] (CCallHelpers&amp; jit) {
<span class="line-modified">!         jit.emitFunctionPrologue();</span>
          jit.cageConditionally(Gigacage::Primitive, GPRInfo::argumentGPR0, GPRInfo::argumentGPR1, GPRInfo::argumentGPR2);
          jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
<span class="line-modified">!         jit.emitFunctionEpilogue();</span>
          jit.ret();
      });
  
      void* ptr = Gigacage::tryMalloc(Gigacage::Primitive, 1);
      void* taggedPtr = tagArrayPtr(ptr, 1);
<span class="line-modified">!     ASSERT(hasOneBitSet(Gigacage::size(Gigacage::Primitive) &lt;&lt; 2));</span>
      void* notCagedPtr = reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;uintptr_t&gt;(ptr) + (Gigacage::size(Gigacage::Primitive) &lt;&lt; 2));
      CHECK_NOT_EQ(Gigacage::caged(Gigacage::Primitive, notCagedPtr), notCagedPtr);
      void* taggedNotCagedPtr = tagArrayPtr(notCagedPtr, 1);
  
      if (isARM64E()) {
<span class="line-new-header">--- 1243,26 ---</span>
  }
  
  static void testCagePreservesPACFailureBit()
  {
  #if GIGACAGE_ENABLED
<span class="line-modified">!     // Placate ASan builds and any environments that disables the Gigacage.</span>
<span class="line-added">+     if (!Gigacage::shouldBeEnabled())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     RELEASE_ASSERT(!Gigacage::isDisablingPrimitiveGigacageForbidden());</span>
      auto cage = compile([] (CCallHelpers&amp; jit) {
<span class="line-modified">!         emitFunctionPrologue(jit);</span>
          jit.cageConditionally(Gigacage::Primitive, GPRInfo::argumentGPR0, GPRInfo::argumentGPR1, GPRInfo::argumentGPR2);
          jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
<span class="line-modified">!         emitFunctionEpilogue(jit);</span>
          jit.ret();
      });
  
      void* ptr = Gigacage::tryMalloc(Gigacage::Primitive, 1);
      void* taggedPtr = tagArrayPtr(ptr, 1);
<span class="line-modified">!     RELEASE_ASSERT(hasOneBitSet(Gigacage::size(Gigacage::Primitive) &lt;&lt; 2));</span>
      void* notCagedPtr = reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;uintptr_t&gt;(ptr) + (Gigacage::size(Gigacage::Primitive) &lt;&lt; 2));
      CHECK_NOT_EQ(Gigacage::caged(Gigacage::Primitive, notCagedPtr), notCagedPtr);
      void* taggedNotCagedPtr = tagArrayPtr(notCagedPtr, 1);
  
      if (isARM64E()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1214,14 ***</span>
          CHECK_EQ(invoke&lt;void*&gt;(cage, taggedPtr, 2), ptr);
  
      CHECK_EQ(invoke&lt;void*&gt;(cage, taggedPtr, 1), ptr);
  
      auto cageWithoutAuthentication = compile([] (CCallHelpers&amp; jit) {
<span class="line-modified">!         jit.emitFunctionPrologue();</span>
          jit.cageWithoutUntagging(Gigacage::Primitive, GPRInfo::argumentGPR0);
          jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
<span class="line-modified">!         jit.emitFunctionEpilogue();</span>
          jit.ret();
      });
  
      CHECK_EQ(invoke&lt;void*&gt;(cageWithoutAuthentication, taggedPtr), taggedPtr);
      if (isARM64E()) {
<span class="line-new-header">--- 1273,14 ---</span>
          CHECK_EQ(invoke&lt;void*&gt;(cage, taggedPtr, 2), ptr);
  
      CHECK_EQ(invoke&lt;void*&gt;(cage, taggedPtr, 1), ptr);
  
      auto cageWithoutAuthentication = compile([] (CCallHelpers&amp; jit) {
<span class="line-modified">!         emitFunctionPrologue(jit);</span>
          jit.cageWithoutUntagging(Gigacage::Primitive, GPRInfo::argumentGPR0);
          jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
<span class="line-modified">!         emitFunctionEpilogue(jit);</span>
          jit.ret();
      });
  
      CHECK_EQ(invoke&lt;void*&gt;(cageWithoutAuthentication, taggedPtr), taggedPtr);
      if (isARM64E()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1334,10 ***</span>
<span class="line-new-header">--- 1393,12 ---</span>
      RUN(testMoveDoubleConditionally32());
      RUN(testMoveDoubleConditionally64());
  
      RUN(testCagePreservesPACFailureBit());
  
<span class="line-added">+     RUN(testOrImmMem());</span>
<span class="line-added">+ </span>
      if (tasks.isEmpty())
          usage();
  
      Lock lock;
  
</pre>
<center><a href="X86Registers.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../b3/B3Bank.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
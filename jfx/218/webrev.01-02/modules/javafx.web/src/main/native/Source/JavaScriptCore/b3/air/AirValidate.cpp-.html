<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirValidate.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;AirValidate.h&quot;
 28 
 29 #if ENABLE(B3_JIT)
 30 
 31 #include &quot;AirCode.h&quot;
 32 #include &quot;AirInstInlines.h&quot;
 33 #include &quot;B3Procedure.h&quot;
 34 
 35 namespace JSC { namespace B3 { namespace Air {
 36 
 37 namespace {
 38 
 39 class Validater {
 40 public:
 41     Validater(Code&amp; code, const char* dumpBefore)
 42         : m_code(code)
 43         , m_dumpBefore(dumpBefore)
 44     {
 45     }
 46 
 47 #define VALIDATE(condition, message) do {                               \
 48         if (condition)                                                  \
 49             break;                                                      \
 50         fail(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #condition, toCString message); \
 51     } while (false)
 52 
 53     void run()
 54     {
 55         HashSet&lt;StackSlot*&gt; validSlots;
 56         HashSet&lt;BasicBlock*&gt; validBlocks;
 57         HashSet&lt;Special*&gt; validSpecials;
 58 
 59         for (BasicBlock* block : m_code)
 60             validBlocks.add(block);
 61         for (StackSlot* slot : m_code.stackSlots())
 62             validSlots.add(slot);
 63         for (Special* special : m_code.specials())
 64             validSpecials.add(special);
 65 
 66         for (BasicBlock* block : m_code) {
 67             // Blocks that are entrypoints must not have predecessors.
 68             if (m_code.isEntrypoint(block))
 69                 VALIDATE(!block-&gt;numPredecessors(), (&quot;At entrypoint &quot;, *block));
 70 
 71             for (unsigned instIndex = 0; instIndex &lt; block-&gt;size(); ++instIndex) {
 72                 Inst&amp; inst = block-&gt;at(instIndex);
 73                 for (Arg&amp; arg : inst.args) {
 74                     switch (arg.kind()) {
 75                     case Arg::Stack:
 76                         VALIDATE(validSlots.contains(arg.stackSlot()), (&quot;At &quot;, inst, &quot; in &quot;, *block));
 77                         break;
 78                     case Arg::Special:
 79                         VALIDATE(validSpecials.contains(arg.special()), (&quot;At &quot;, inst, &quot; in &quot;, *block));
 80                         break;
 81                     default:
 82                         break;
 83                     }
 84                 }
 85                 VALIDATE(inst.isValidForm(), (&quot;At &quot;, inst, &quot; in &quot;, *block));
 86                 if (instIndex == block-&gt;size() - 1)
 87                     VALIDATE(inst.isTerminal(), (&quot;At &quot;, inst, &quot; in &quot;, *block));
 88                 else
 89                     VALIDATE(!inst.isTerminal(), (&quot;At &quot;, inst, &quot; in &quot;, *block));
 90 
 91                 // forEachArg must return Arg&amp;&#39;s that point into the args array.
 92                 inst.forEachArg(
 93                     [&amp;] (Arg&amp; arg, Arg::Role, Bank, Width) {
 94                         VALIDATE(&amp;arg &gt;= &amp;inst.args[0], (&quot;At &quot;, arg, &quot; in &quot;, inst, &quot; in &quot;, *block));
 95                         VALIDATE(&amp;arg &lt;= &amp;inst.args.last(), (&quot;At &quot;, arg, &quot; in &quot;, inst, &quot; in &quot;, *block));
 96                     });
 97 
 98                 switch (inst.kind.opcode) {
 99                 case EntrySwitch:
100                     VALIDATE(block-&gt;numSuccessors() == m_code.proc().numEntrypoints(), (&quot;At &quot;, inst, &quot; in &quot;, *block));
101                     break;
102                 case Shuffle:
103                     // We can&#39;t handle trapping shuffles because of how we lower them. That could
104                     // be fixed though. Ditto for shuffles that would do fences, which is the other
105                     // use of this bit.
106                     VALIDATE(!inst.kind.effects, (&quot;At &quot;, inst, &quot; in &quot;, *block));
107                     break;
108                 default:
109                     break;
110                 }
111             }
112             for (BasicBlock* successor : block-&gt;successorBlocks())
113                 VALIDATE(validBlocks.contains(successor), (&quot;In &quot;, *block));
114         }
115 
116         for (BasicBlock* block : m_code) {
117             // We expect the predecessor list to be de-duplicated.
118             HashSet&lt;BasicBlock*&gt; predecessors;
119             for (BasicBlock* predecessor : block-&gt;predecessors())
120                 predecessors.add(predecessor);
121             VALIDATE(block-&gt;numPredecessors() == predecessors.size(), (&quot;At &quot;, *block));
122         }
123     }
124 
125 private:
126     NO_RETURN_DUE_TO_CRASH void fail(
127         const char* filename, int lineNumber, const char* function, const char* condition,
128         CString message)
129     {
130         CString failureMessage;
131         {
132             StringPrintStream out;
133             out.print(&quot;AIR VALIDATION FAILURE\n&quot;);
134             out.print(&quot;    &quot;, condition, &quot; (&quot;, filename, &quot;:&quot;, lineNumber, &quot;)\n&quot;);
135             out.print(&quot;    &quot;, message, &quot;\n&quot;);
136             out.print(&quot;    After &quot;, m_code.lastPhaseName(), &quot;\n&quot;);
137             failureMessage = out.toCString();
138         }
139 
140         dataLog(failureMessage);
141         if (m_dumpBefore) {
142             dataLog(&quot;Before &quot;, m_code.lastPhaseName(), &quot;:\n&quot;);
143             dataLog(m_dumpBefore);
144         }
145         dataLog(&quot;At time of failure:\n&quot;);
146         dataLog(m_code);
147 
148         dataLog(failureMessage);
149         WTFReportAssertionFailure(filename, lineNumber, function, condition);
150         CRASH();
151     }
152 
153     Code&amp; m_code;
154     const char* m_dumpBefore;
155 };
156 
157 } // anonymous namespace
158 
159 void validate(Code&amp; code, const char* dumpBefore)
160 {
161     Validater validater(code, dumpBefore);
162     validater.run();
163 }
164 
165 } } } // namespace JSC::B3::Air
166 
167 #endif // ENABLE(B3_JIT)
168 
    </pre>
  </body>
</html>
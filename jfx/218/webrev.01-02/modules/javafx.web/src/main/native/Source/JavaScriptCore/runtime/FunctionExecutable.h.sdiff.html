<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/FunctionExecutable.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FunctionExecutable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FunctionPrototype.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/FunctionExecutable.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2009-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;ExecutableToCodeBlockEdge.h&quot;
 29 #include &quot;ScriptExecutable.h&quot;
 30 #include &quot;SourceCode.h&quot;
 31 #include &lt;wtf/Box.h&gt;
 32 #include &lt;wtf/Markable.h&gt;
 33 
 34 namespace JSC {
 35 
 36 struct FunctionOverrideInfo;
 37 
 38 class FunctionExecutable final : public ScriptExecutable {
 39     friend class JIT;
 40     friend class LLIntOffsetsExtractor;
 41 public:
 42     typedef ScriptExecutable Base;
<span class="line-modified"> 43     static const unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;</span>
 44 
 45     template&lt;typename CellType, SubspaceAccess&gt;
 46     static IsoSubspace* subspaceFor(VM&amp; vm)
 47     {
 48         return &amp;vm.functionExecutableSpace.space;
 49     }
 50 
 51     static FunctionExecutable* create(VM&amp; vm, ScriptExecutable* topLevelExecutable, const SourceCode&amp; source, UnlinkedFunctionExecutable* unlinkedExecutable, Intrinsic intrinsic)
 52     {
 53         FunctionExecutable* executable = new (NotNull, allocateCell&lt;FunctionExecutable&gt;(vm.heap)) FunctionExecutable(vm, source, unlinkedExecutable, intrinsic);
 54         executable-&gt;finishCreation(vm, topLevelExecutable);
 55         return executable;
 56     }
 57     static FunctionExecutable* fromGlobalCode(
<span class="line-modified"> 58         const Identifier&amp; name, ExecState&amp;, const SourceCode&amp;,</span>
 59         JSObject*&amp; exception, int overrideLineNumber, Optional&lt;int&gt; functionConstructorParametersEndPosition);
 60 
 61     static void destroy(JSCell*);
 62 
 63     UnlinkedFunctionExecutable* unlinkedExecutable() const
 64     {
 65         return m_unlinkedExecutable.get();
 66     }
 67 
 68     // Returns either call or construct bytecode. This can be appropriate
 69     // for answering questions that that don&#39;t vary between call and construct --
 70     // for example, argumentsRegister().
 71     FunctionCodeBlock* eitherCodeBlock()
 72     {
 73         ExecutableToCodeBlockEdge* edge;
 74         if (m_codeBlockForCall)
 75             edge = m_codeBlockForCall.get();
 76         else
 77             edge = m_codeBlockForConstruct.get();
 78         return bitwise_cast&lt;FunctionCodeBlock*&gt;(ExecutableToCodeBlockEdge::unwrap(edge));
</pre>
<hr />
<pre>
114         return codeBlockForConstruct();
115     }
116 
117     FunctionCodeBlock* baselineCodeBlockFor(CodeSpecializationKind);
118 
119     FunctionCodeBlock* profiledCodeBlockFor(CodeSpecializationKind kind)
120     {
121         return baselineCodeBlockFor(kind);
122     }
123 
124     RefPtr&lt;TypeSet&gt; returnStatementTypeSet()
125     {
126         RareData&amp; rareData = ensureRareData();
127         if (!rareData.m_returnStatementTypeSet)
128             rareData.m_returnStatementTypeSet = TypeSet::create();
129         return rareData.m_returnStatementTypeSet;
130     }
131 
132     FunctionMode functionMode() { return m_unlinkedExecutable-&gt;functionMode(); }
133     bool isBuiltinFunction() const { return m_unlinkedExecutable-&gt;isBuiltinFunction(); }
<span class="line-removed">134     bool isAnonymousBuiltinFunction() const { return m_unlinkedExecutable-&gt;isAnonymousBuiltinFunction(); }</span>
135     ConstructAbility constructAbility() const { return m_unlinkedExecutable-&gt;constructAbility(); }
136     bool isClass() const { return m_unlinkedExecutable-&gt;isClass(); }
137     bool isArrowFunction() const { return parseMode() == SourceParseMode::ArrowFunctionMode; }
138     bool isGetter() const { return parseMode() == SourceParseMode::GetterMode; }
139     bool isSetter() const { return parseMode() == SourceParseMode::SetterMode; }
140     bool isGenerator() const { return isGeneratorParseMode(parseMode()); }
141     bool isAsyncGenerator() const { return isAsyncGeneratorParseMode(parseMode()); }
142     bool isMethod() const { return parseMode() == SourceParseMode::MethodMode; }
143     bool hasCallerAndArgumentsProperties() const
144     {
145         // Per https://tc39.github.io/ecma262/#sec-forbidden-extensions, only sloppy-mode non-builtin functions in old-style (pre-ES6) syntactic forms can contain
146         // &quot;caller&quot; and &quot;arguments&quot;.
147         return !isStrictMode() &amp;&amp; parseMode() == SourceParseMode::NormalFunctionMode &amp;&amp; !isClassConstructorFunction();
148     }
149     bool hasPrototypeProperty() const
150     {
151         return SourceParseModeSet(
152             SourceParseMode::NormalFunctionMode,
153             SourceParseMode::GeneratorBodyMode,
154             SourceParseMode::GeneratorWrapperFunctionMode,
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2009-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;ExecutableToCodeBlockEdge.h&quot;
 29 #include &quot;ScriptExecutable.h&quot;
 30 #include &quot;SourceCode.h&quot;
 31 #include &lt;wtf/Box.h&gt;
 32 #include &lt;wtf/Markable.h&gt;
 33 
 34 namespace JSC {
 35 
 36 struct FunctionOverrideInfo;
 37 
 38 class FunctionExecutable final : public ScriptExecutable {
 39     friend class JIT;
 40     friend class LLIntOffsetsExtractor;
 41 public:
 42     typedef ScriptExecutable Base;
<span class="line-modified"> 43     static constexpr unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;</span>
 44 
 45     template&lt;typename CellType, SubspaceAccess&gt;
 46     static IsoSubspace* subspaceFor(VM&amp; vm)
 47     {
 48         return &amp;vm.functionExecutableSpace.space;
 49     }
 50 
 51     static FunctionExecutable* create(VM&amp; vm, ScriptExecutable* topLevelExecutable, const SourceCode&amp; source, UnlinkedFunctionExecutable* unlinkedExecutable, Intrinsic intrinsic)
 52     {
 53         FunctionExecutable* executable = new (NotNull, allocateCell&lt;FunctionExecutable&gt;(vm.heap)) FunctionExecutable(vm, source, unlinkedExecutable, intrinsic);
 54         executable-&gt;finishCreation(vm, topLevelExecutable);
 55         return executable;
 56     }
 57     static FunctionExecutable* fromGlobalCode(
<span class="line-modified"> 58         const Identifier&amp; name, JSGlobalObject*, const SourceCode&amp;,</span>
 59         JSObject*&amp; exception, int overrideLineNumber, Optional&lt;int&gt; functionConstructorParametersEndPosition);
 60 
 61     static void destroy(JSCell*);
 62 
 63     UnlinkedFunctionExecutable* unlinkedExecutable() const
 64     {
 65         return m_unlinkedExecutable.get();
 66     }
 67 
 68     // Returns either call or construct bytecode. This can be appropriate
 69     // for answering questions that that don&#39;t vary between call and construct --
 70     // for example, argumentsRegister().
 71     FunctionCodeBlock* eitherCodeBlock()
 72     {
 73         ExecutableToCodeBlockEdge* edge;
 74         if (m_codeBlockForCall)
 75             edge = m_codeBlockForCall.get();
 76         else
 77             edge = m_codeBlockForConstruct.get();
 78         return bitwise_cast&lt;FunctionCodeBlock*&gt;(ExecutableToCodeBlockEdge::unwrap(edge));
</pre>
<hr />
<pre>
114         return codeBlockForConstruct();
115     }
116 
117     FunctionCodeBlock* baselineCodeBlockFor(CodeSpecializationKind);
118 
119     FunctionCodeBlock* profiledCodeBlockFor(CodeSpecializationKind kind)
120     {
121         return baselineCodeBlockFor(kind);
122     }
123 
124     RefPtr&lt;TypeSet&gt; returnStatementTypeSet()
125     {
126         RareData&amp; rareData = ensureRareData();
127         if (!rareData.m_returnStatementTypeSet)
128             rareData.m_returnStatementTypeSet = TypeSet::create();
129         return rareData.m_returnStatementTypeSet;
130     }
131 
132     FunctionMode functionMode() { return m_unlinkedExecutable-&gt;functionMode(); }
133     bool isBuiltinFunction() const { return m_unlinkedExecutable-&gt;isBuiltinFunction(); }

134     ConstructAbility constructAbility() const { return m_unlinkedExecutable-&gt;constructAbility(); }
135     bool isClass() const { return m_unlinkedExecutable-&gt;isClass(); }
136     bool isArrowFunction() const { return parseMode() == SourceParseMode::ArrowFunctionMode; }
137     bool isGetter() const { return parseMode() == SourceParseMode::GetterMode; }
138     bool isSetter() const { return parseMode() == SourceParseMode::SetterMode; }
139     bool isGenerator() const { return isGeneratorParseMode(parseMode()); }
140     bool isAsyncGenerator() const { return isAsyncGeneratorParseMode(parseMode()); }
141     bool isMethod() const { return parseMode() == SourceParseMode::MethodMode; }
142     bool hasCallerAndArgumentsProperties() const
143     {
144         // Per https://tc39.github.io/ecma262/#sec-forbidden-extensions, only sloppy-mode non-builtin functions in old-style (pre-ES6) syntactic forms can contain
145         // &quot;caller&quot; and &quot;arguments&quot;.
146         return !isStrictMode() &amp;&amp; parseMode() == SourceParseMode::NormalFunctionMode &amp;&amp; !isClassConstructorFunction();
147     }
148     bool hasPrototypeProperty() const
149     {
150         return SourceParseModeSet(
151             SourceParseMode::NormalFunctionMode,
152             SourceParseMode::GeneratorBodyMode,
153             SourceParseMode::GeneratorWrapperFunctionMode,
</pre>
</td>
</tr>
</table>
<center><a href="FunctionExecutable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FunctionPrototype.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3ReduceStrength.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="B3ReduceLoopStrength.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="B3StackmapGenerationParams.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3ReduceStrength.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2015-2018 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
  73 // up running forever. We don&#39;t want that.
  74 //
  75 // Therefore, we need to prioritize certain canonical forms over others. Naively, we want strength
  76 // reduction to reduce the number of values, and so a form involving fewer total values is more
  77 // canonical. But we might break this, for example when reducing strength of Mul(x, 9). This could be
  78 // better written as Add(Shl(x, 3), x), which also happens to be representable using a single
  79 // instruction on x86.
  80 //
  81 // Here are some of the rules we have:
  82 //
  83 // Canonical form of logical not: BitXor(value, 1). We may have to avoid using this form if we don&#39;t
  84 // know for sure that &#39;value&#39; is 0-or-1 (i.e. returnsBool). In that case we fall back on
  85 // Equal(value, 0).
  86 //
  87 // Canonical form of commutative operations: if the operation involves a constant, the constant must
  88 // come second. Add(x, constant) is canonical, while Add(constant, x) is not. If there are no
  89 // constants then the canonical form involves the lower-indexed value first. Given Add(x, y), it&#39;s
  90 // canonical if x-&gt;index() &lt;= y-&gt;index().
  91 
  92 namespace B3ReduceStrengthInternal {
<span class="line-modified">  93 static const bool verbose = false;</span>
  94 }
  95 
  96 // FIXME: This IntRange stuff should be refactored into a general constant propagator. It&#39;s weird
  97 // that it&#39;s just sitting here in this file.
  98 class IntRange {
  99 public:
 100     IntRange()
 101     {
 102     }
 103 
 104     IntRange(int64_t min, int64_t max)
 105         : m_min(min)
 106         , m_max(max)
 107     {
 108     }
 109 
 110     template&lt;typename T&gt;
 111     static IntRange top()
 112     {
 113         return IntRange(std::numeric_limits&lt;T&gt;::min(), std::numeric_limits&lt;T&gt;::max());
</pre>
<hr />
<pre>
 374                 std::min(m_min * other.m_min, m_min * other.m_max),
 375                 std::min(m_max * other.m_min, m_max * other.m_max)),
 376             std::max(
 377                 std::max(m_min * other.m_min, m_min * other.m_max),
 378                 std::max(m_max * other.m_min, m_max * other.m_max)));
 379     }
 380 
 381     IntRange mul(const IntRange&amp; other, Type type)
 382     {
 383         switch (type.kind()) {
 384         case Int32:
 385             return mul&lt;int32_t&gt;(other);
 386         case Int64:
 387             return mul&lt;int64_t&gt;(other);
 388         default:
 389             RELEASE_ASSERT_NOT_REACHED();
 390             return IntRange();
 391         }
 392     }
 393 









 394 private:
 395     int64_t m_min { 0 };
 396     int64_t m_max { 0 };
 397 };
 398 
 399 class ReduceStrength {
 400 public:
 401     ReduceStrength(Procedure&amp; proc)
 402         : m_proc(proc)
 403         , m_insertionSet(proc)
 404         , m_blockInsertionSet(proc)
 405         , m_root(proc.at(0))
 406     {
 407     }
 408 
 409     bool run()
 410     {
 411         bool result = false;
 412         bool first = true;
 413         unsigned index = 0;
</pre>
<hr />
<pre>
1016                     m_changed = true;
1017                 }
1018             }
1019 
1020             // Turn this: BitAnd(valueX, valueX)
1021             // Into this: valueX.
1022             if (m_value-&gt;child(0) == m_value-&gt;child(1)) {
1023                 replaceWithIdentity(m_value-&gt;child(0));
1024                 break;
1025             }
1026 
1027             // Turn this: BitAnd(value, zero-constant)
1028             // Into this: zero-constant.
1029             if (m_value-&gt;child(1)-&gt;isInt(0)) {
1030                 replaceWithIdentity(m_value-&gt;child(1));
1031                 break;
1032             }
1033 
1034             // Turn this: BitAnd(value, all-ones)
1035             // Into this: value.
<span class="line-modified">1036             if ((m_value-&gt;type() == Int64 &amp;&amp; m_value-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint64_t&gt;::max()))</span>
<span class="line-modified">1037                 || (m_value-&gt;type() == Int32 &amp;&amp; m_value-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint32_t&gt;::max()))) {</span>
1038                 replaceWithIdentity(m_value-&gt;child(0));
1039                 break;
1040             }
1041 
1042             // Turn this: BitAnd(64-bit value, 32 ones)
1043             // Into this: ZExt32(Trunc(64-bit value))
1044             if (m_value-&gt;child(1)-&gt;isInt64(0xffffffffllu)) {
1045                 Value* newValue = m_insertionSet.insert&lt;Value&gt;(
1046                     m_index, ZExt32, m_value-&gt;origin(),
1047                     m_insertionSet.insert&lt;Value&gt;(m_index, Trunc, m_value-&gt;origin(), m_value-&gt;child(0)));
1048                 replaceWithIdentity(newValue);
1049                 break;
1050             }
1051 
1052             // Turn this: BitAnd(SExt8(value), mask) where (mask &amp; 0xffffff00) == 0
1053             // Into this: BitAnd(value, mask)
1054             if (m_value-&gt;child(0)-&gt;opcode() == SExt8 &amp;&amp; m_value-&gt;child(1)-&gt;hasInt32()
1055                 &amp;&amp; !(m_value-&gt;child(1)-&gt;asInt32() &amp; 0xffffff00)) {
1056                 m_value-&gt;child(0) = m_value-&gt;child(0)-&gt;child(0);
1057                 m_changed = true;
</pre>
<hr />
<pre>
1066                 m_changed = true;
1067                 break;
1068             }
1069 
1070             // Turn this: BitAnd(SExt32(value), mask) where (mask &amp; 0xffffffff00000000) == 0
1071             // Into this: BitAnd(ZExt32(value), mask)
1072             if (m_value-&gt;child(0)-&gt;opcode() == SExt32 &amp;&amp; m_value-&gt;child(1)-&gt;hasInt32()
1073                 &amp;&amp; !(m_value-&gt;child(1)-&gt;asInt32() &amp; 0xffffffff00000000llu)) {
1074                 m_value-&gt;child(0) = m_insertionSet.insert&lt;Value&gt;(
1075                     m_index, ZExt32, m_value-&gt;origin(),
1076                     m_value-&gt;child(0)-&gt;child(0), m_value-&gt;child(0)-&gt;child(1));
1077                 m_changed = true;
1078                 break;
1079             }
1080 
1081             // Turn this: BitAnd(Op(value, constant1), constant2)
1082             //     where !(constant1 &amp; constant2)
1083             //       and Op is BitOr or BitXor
1084             // into this: BitAnd(value, constant2)
1085             if (m_value-&gt;child(1)-&gt;hasInt()) {

1086                 int64_t constant2 = m_value-&gt;child(1)-&gt;asInt();
1087                 switch (m_value-&gt;child(0)-&gt;opcode()) {
1088                 case BitOr:
1089                 case BitXor:
1090                     if (m_value-&gt;child(0)-&gt;child(1)-&gt;hasInt()
1091                         &amp;&amp; !(m_value-&gt;child(0)-&gt;child(1)-&gt;asInt() &amp; constant2)) {
1092                         m_value-&gt;child(0) = m_value-&gt;child(0)-&gt;child(0);
1093                         m_changed = true;

1094                         break;
1095                     }
1096                     break;
1097                 default:
1098                     break;
1099                 }
<span class="line-modified">1100                 break;</span>

1101             }
1102 
1103             // Turn this: BitAnd(BitXor(x1, allOnes), BitXor(x2, allOnes)
1104             // Into this: BitXor(BitOr(x1, x2), allOnes)
1105             // By applying De Morgan laws
1106             if (m_value-&gt;child(0)-&gt;opcode() == BitXor
1107                 &amp;&amp; m_value-&gt;child(1)-&gt;opcode() == BitXor
1108                 &amp;&amp; ((m_value-&gt;type() == Int64
<span class="line-modified">1109                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint64_t&gt;::max())</span>
<span class="line-modified">1110                         &amp;&amp; m_value-&gt;child(1)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint64_t&gt;::max()))</span>
1111                     || (m_value-&gt;type() == Int32
<span class="line-modified">1112                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint32_t&gt;::max())</span>
<span class="line-modified">1113                         &amp;&amp; m_value-&gt;child(1)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint32_t&gt;::max())))) {</span>
1114                 Value* bitOr = m_insertionSet.insert&lt;Value&gt;(m_index, BitOr, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), m_value-&gt;child(1)-&gt;child(0));
1115                 replaceWithNew&lt;Value&gt;(BitXor, m_value-&gt;origin(), bitOr, m_value-&gt;child(1)-&gt;child(1));
1116                 break;
1117             }
1118 
1119             // Turn this: BitAnd(BitXor(x, allOnes), c)
1120             // Into this: BitXor(BitOr(x, ~c), allOnes)
1121             // This is a variation on the previous optimization, treating c as if it were BitXor(~c, allOnes)
1122             // It does not reduce the number of operations, but provides some normalization (we try to get BitXor by allOnes at the outermost point), and some chance to float Xors to a place where they might get eliminated.
1123             if (m_value-&gt;child(0)-&gt;opcode() == BitXor
1124                 &amp;&amp; m_value-&gt;child(1)-&gt;hasInt()
1125                 &amp;&amp; ((m_value-&gt;type() == Int64
<span class="line-modified">1126                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint64_t&gt;::max()))</span>
1127                     || (m_value-&gt;type() == Int32
<span class="line-modified">1128                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint32_t&gt;::max())))) {</span>
<span class="line-modified">1129                 Value* bitOr = m_insertionSet.insert&lt;Value&gt;(m_index, BitOr, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), m_value-&gt;child(1)-&gt;bitXorConstant(m_proc, m_value-&gt;child(0)-&gt;child(1)));</span>



1130                 replaceWithNew&lt;Value&gt;(BitXor, m_value-&gt;origin(), bitOr, m_value-&gt;child(0)-&gt;child(1));
1131                 break;
1132             }
1133 
1134             break;
1135 
1136         case BitOr:
1137             handleCommutativity();
1138 
1139             // Turn this: BitOr(constant1, constant2)
1140             // Into this: constant1 | constant2
1141             if (Value* constantBitOr = m_value-&gt;child(0)-&gt;bitOrConstant(m_proc, m_value-&gt;child(1))) {
1142                 replaceWithNewValue(constantBitOr);
1143                 break;
1144             }
1145 
1146             // Turn this: BitOr(BitOr(value, constant1), constant2)
1147             // Into this: BitOr(value, constant1 &amp; constant2).
1148             if (m_value-&gt;child(0)-&gt;opcode() == BitOr) {
1149                 Value* newConstant = m_value-&gt;child(1)-&gt;bitOrConstant(m_proc, m_value-&gt;child(0)-&gt;child(1));
</pre>
<hr />
<pre>
1154                     m_changed = true;
1155                 }
1156             }
1157 
1158             // Turn this: BitOr(valueX, valueX)
1159             // Into this: valueX.
1160             if (m_value-&gt;child(0) == m_value-&gt;child(1)) {
1161                 replaceWithIdentity(m_value-&gt;child(0));
1162                 break;
1163             }
1164 
1165             // Turn this: BitOr(value, zero-constant)
1166             // Into this: value.
1167             if (m_value-&gt;child(1)-&gt;isInt(0)) {
1168                 replaceWithIdentity(m_value-&gt;child(0));
1169                 break;
1170             }
1171 
1172             // Turn this: BitOr(value, all-ones)
1173             // Into this: all-ones.
<span class="line-modified">1174             if ((m_value-&gt;type() == Int64 &amp;&amp; m_value-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint64_t&gt;::max()))</span>
<span class="line-modified">1175                 || (m_value-&gt;type() == Int32 &amp;&amp; m_value-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint32_t&gt;::max()))) {</span>
1176                 replaceWithIdentity(m_value-&gt;child(1));
1177                 break;
1178             }
1179 
1180             // Turn this: BitOr(BitXor(x1, allOnes), BitXor(x2, allOnes)
1181             // Into this: BitXor(BitAnd(x1, x2), allOnes)
1182             // By applying De Morgan laws
1183             if (m_value-&gt;child(0)-&gt;opcode() == BitXor
1184                 &amp;&amp; m_value-&gt;child(1)-&gt;opcode() == BitXor
1185                 &amp;&amp; ((m_value-&gt;type() == Int64
<span class="line-modified">1186                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint64_t&gt;::max())</span>
<span class="line-modified">1187                         &amp;&amp; m_value-&gt;child(1)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint64_t&gt;::max()))</span>
1188                     || (m_value-&gt;type() == Int32
<span class="line-modified">1189                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint32_t&gt;::max())</span>
<span class="line-modified">1190                         &amp;&amp; m_value-&gt;child(1)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint32_t&gt;::max())))) {</span>
1191                 Value* bitAnd = m_insertionSet.insert&lt;Value&gt;(m_index, BitAnd, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), m_value-&gt;child(1)-&gt;child(0));
1192                 replaceWithNew&lt;Value&gt;(BitXor, m_value-&gt;origin(), bitAnd, m_value-&gt;child(1)-&gt;child(1));
1193                 break;
1194             }
1195 
1196             // Turn this: BitOr(BitXor(x, allOnes), c)
1197             // Into this: BitXor(BitAnd(x, ~c), allOnes)
1198             // This is a variation on the previous optimization, treating c as if it were BitXor(~c, allOnes)
1199             // It does not reduce the number of operations, but provides some normalization (we try to get BitXor by allOnes at the outermost point), and some chance to float Xors to a place where they might get eliminated.
1200             if (m_value-&gt;child(0)-&gt;opcode() == BitXor
1201                 &amp;&amp; m_value-&gt;child(1)-&gt;hasInt()
1202                 &amp;&amp; ((m_value-&gt;type() == Int64
<span class="line-modified">1203                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint64_t&gt;::max()))</span>
1204                     || (m_value-&gt;type() == Int32
<span class="line-modified">1205                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint32_t&gt;::max())))) {</span>
<span class="line-modified">1206                 Value* bitAnd = m_insertionSet.insert&lt;Value&gt;(m_index, BitAnd, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), m_value-&gt;child(1)-&gt;bitXorConstant(m_proc, m_value-&gt;child(0)-&gt;child(1)));</span>



1207                 replaceWithNew&lt;Value&gt;(BitXor, m_value-&gt;origin(), bitAnd, m_value-&gt;child(0)-&gt;child(1));
1208                 break;
1209             }
1210 
1211             if (handleBitAndDistributivity())
1212                 break;
1213 
1214             break;
1215 
1216         case BitXor:
1217             handleCommutativity();
1218 
1219             // Turn this: BitXor(constant1, constant2)
1220             // Into this: constant1 ^ constant2
1221             if (Value* constantBitXor = m_value-&gt;child(0)-&gt;bitXorConstant(m_proc, m_value-&gt;child(1))) {
1222                 replaceWithNewValue(constantBitXor);
1223                 break;
1224             }
1225 
1226             // Turn this: BitXor(BitXor(value, constant1), constant2)
</pre>
<hr />
<pre>
2076             //     Check(@b_truecase)
2077             //     Upsilon(@x, ^a)
2078             //     Upsilon(@b_truecase, ^b)
2079             //     Jump(#continuation)
2080             //
2081             //   BB#falsecase:
2082             //     @b_falsecase = Add(42, 35)
2083             //     Check(@b_falsecase)
2084             //     Upsilon(42, ^a)
2085             //     Upsilon(@b_falsecase, ^b)
2086             //     Jump(#continuation)
2087             //
2088             //   BB#continuation:
2089             //     @a = Phi()
2090             //     @b = Phi()
2091             //
2092             // The goal of this optimization is to kill a lot of code in one of those basic
2093             // blocks. This is pretty much guaranteed since one of those blocks will replace all
2094             // uses of the Select with a constant, and that constant will be transitively used
2095             // from the check.
<span class="line-modified">2096             static const unsigned selectSpecializationBound = 3;</span>
2097             Value* select = findRecentNodeMatching(
2098                 m_value-&gt;child(0), selectSpecializationBound,
2099                 [&amp;] (Value* value) -&gt; bool {
2100                     return value-&gt;opcode() == Select
2101                         &amp;&amp; (value-&gt;child(1)-&gt;isConstant() &amp;&amp; value-&gt;child(2)-&gt;isConstant());
2102                 });
2103 
2104             if (select) {
2105                 specializeSelect(select);
2106                 break;
2107             }
2108             break;
2109         }
2110 
2111         case Branch: {
2112             // Turn this: Branch(NotEqual(x, 0))
2113             // Into this: Branch(x)
2114             if (m_value-&gt;child(0)-&gt;opcode() == NotEqual &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(0)) {
2115                 m_value-&gt;child(0) = m_value-&gt;child(0)-&gt;child(0);
2116                 m_changed = true;
</pre>
<hr />
<pre>
2260         // chopped off.
2261         BasicBlock* predecessor = m_blockInsertionSet.splitForward(m_block, m_index, &amp;m_insertionSet);
2262         if (m_block == m_root) {
2263             m_root = predecessor;
2264             m_valueForConstant.clear();
2265         }
2266 
2267         // Splitting will commit the insertion set, which changes the exact position of the
2268         // source. That&#39;s why we do the search after splitting.
2269         unsigned startIndex = UINT_MAX;
2270         for (unsigned i = predecessor-&gt;size(); i--;) {
2271             if (predecessor-&gt;at(i) == source) {
2272                 startIndex = i;
2273                 break;
2274             }
2275         }
2276 
2277         RELEASE_ASSERT(startIndex != UINT_MAX);
2278 
2279         // By BasicBlock convention, caseIndex == 0 =&gt; then, caseIndex == 1 =&gt; else.
<span class="line-modified">2280         static const unsigned numCases = 2;</span>
2281         BasicBlock* cases[numCases];
2282         for (unsigned i = 0; i &lt; numCases; ++i)
2283             cases[i] = m_blockInsertionSet.insertBefore(m_block);
2284 
2285         HashMap&lt;Value*, Value*&gt; mappings[2];
2286 
2287         // Save things we want to know about the source.
2288         Value* predicate = source-&gt;child(0);
2289 
2290         for (unsigned i = 0; i &lt; numCases; ++i)
2291             mappings[i].add(source, source-&gt;child(1 + i));
2292 
2293         auto cloneValue = [&amp;] (Value* value) {
2294             ASSERT(value != source);
2295 
2296             for (unsigned i = 0; i &lt; numCases; ++i) {
2297                 Value* clone = m_proc.clone(value);
2298                 for (Value*&amp; child : clone-&gt;children()) {
2299                     if (Value* newChild = mappings[i].get(child))
2300                         child = newChild;
</pre>
<hr />
<pre>
2569 
2570         case Shl:
2571             if (value-&gt;child(1)-&gt;hasInt32()) {
2572                 return rangeFor(value-&gt;child(0), timeToLive - 1).shl(
2573                     value-&gt;child(1)-&gt;asInt32(), value-&gt;type());
2574             }
2575             break;
2576 
2577         case Add:
2578             return rangeFor(value-&gt;child(0), timeToLive - 1).add(
2579                 rangeFor(value-&gt;child(1), timeToLive - 1), value-&gt;type());
2580 
2581         case Sub:
2582             return rangeFor(value-&gt;child(0), timeToLive - 1).sub(
2583                 rangeFor(value-&gt;child(1), timeToLive - 1), value-&gt;type());
2584 
2585         case Mul:
2586             return rangeFor(value-&gt;child(0), timeToLive - 1).mul(
2587                 rangeFor(value-&gt;child(1), timeToLive - 1), value-&gt;type());
2588 








2589         default:
2590             break;
2591         }
2592 
2593         return IntRange::top(value-&gt;type());
2594     }
2595 
2596     template&lt;typename ValueType, typename... Arguments&gt;
2597     void replaceWithNew(Arguments... arguments)
2598     {
2599         replaceWithNewValue(m_proc.add&lt;ValueType&gt;(arguments...));
2600     }
2601 
2602     bool replaceWithNewValue(Value* newValue)
2603     {
2604         if (!newValue)
2605             return false;
2606         m_insertionSet.insertValue(m_index, newValue);
2607         m_value-&gt;replaceWithIdentity(newValue);
2608         m_changed = true;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
  73 // up running forever. We don&#39;t want that.
  74 //
  75 // Therefore, we need to prioritize certain canonical forms over others. Naively, we want strength
  76 // reduction to reduce the number of values, and so a form involving fewer total values is more
  77 // canonical. But we might break this, for example when reducing strength of Mul(x, 9). This could be
  78 // better written as Add(Shl(x, 3), x), which also happens to be representable using a single
  79 // instruction on x86.
  80 //
  81 // Here are some of the rules we have:
  82 //
  83 // Canonical form of logical not: BitXor(value, 1). We may have to avoid using this form if we don&#39;t
  84 // know for sure that &#39;value&#39; is 0-or-1 (i.e. returnsBool). In that case we fall back on
  85 // Equal(value, 0).
  86 //
  87 // Canonical form of commutative operations: if the operation involves a constant, the constant must
  88 // come second. Add(x, constant) is canonical, while Add(constant, x) is not. If there are no
  89 // constants then the canonical form involves the lower-indexed value first. Given Add(x, y), it&#39;s
  90 // canonical if x-&gt;index() &lt;= y-&gt;index().
  91 
  92 namespace B3ReduceStrengthInternal {
<span class="line-modified">  93 static constexpr bool verbose = false;</span>
  94 }
  95 
  96 // FIXME: This IntRange stuff should be refactored into a general constant propagator. It&#39;s weird
  97 // that it&#39;s just sitting here in this file.
  98 class IntRange {
  99 public:
 100     IntRange()
 101     {
 102     }
 103 
 104     IntRange(int64_t min, int64_t max)
 105         : m_min(min)
 106         , m_max(max)
 107     {
 108     }
 109 
 110     template&lt;typename T&gt;
 111     static IntRange top()
 112     {
 113         return IntRange(std::numeric_limits&lt;T&gt;::min(), std::numeric_limits&lt;T&gt;::max());
</pre>
<hr />
<pre>
 374                 std::min(m_min * other.m_min, m_min * other.m_max),
 375                 std::min(m_max * other.m_min, m_max * other.m_max)),
 376             std::max(
 377                 std::max(m_min * other.m_min, m_min * other.m_max),
 378                 std::max(m_max * other.m_min, m_max * other.m_max)));
 379     }
 380 
 381     IntRange mul(const IntRange&amp; other, Type type)
 382     {
 383         switch (type.kind()) {
 384         case Int32:
 385             return mul&lt;int32_t&gt;(other);
 386         case Int64:
 387             return mul&lt;int64_t&gt;(other);
 388         default:
 389             RELEASE_ASSERT_NOT_REACHED();
 390             return IntRange();
 391         }
 392     }
 393 
<span class="line-added"> 394     IntRange zExt32()</span>
<span class="line-added"> 395     {</span>
<span class="line-added"> 396         ASSERT(m_min &gt;= INT32_MIN);</span>
<span class="line-added"> 397         ASSERT(m_max &lt;= INT32_MAX);</span>
<span class="line-added"> 398         int32_t min = m_min;</span>
<span class="line-added"> 399         int32_t max = m_max;</span>
<span class="line-added"> 400         return IntRange(static_cast&lt;uint64_t&gt;(static_cast&lt;uint32_t&gt;(min)), static_cast&lt;uint64_t&gt;(static_cast&lt;uint32_t&gt;(max)));</span>
<span class="line-added"> 401     }</span>
<span class="line-added"> 402 </span>
 403 private:
 404     int64_t m_min { 0 };
 405     int64_t m_max { 0 };
 406 };
 407 
 408 class ReduceStrength {
 409 public:
 410     ReduceStrength(Procedure&amp; proc)
 411         : m_proc(proc)
 412         , m_insertionSet(proc)
 413         , m_blockInsertionSet(proc)
 414         , m_root(proc.at(0))
 415     {
 416     }
 417 
 418     bool run()
 419     {
 420         bool result = false;
 421         bool first = true;
 422         unsigned index = 0;
</pre>
<hr />
<pre>
1025                     m_changed = true;
1026                 }
1027             }
1028 
1029             // Turn this: BitAnd(valueX, valueX)
1030             // Into this: valueX.
1031             if (m_value-&gt;child(0) == m_value-&gt;child(1)) {
1032                 replaceWithIdentity(m_value-&gt;child(0));
1033                 break;
1034             }
1035 
1036             // Turn this: BitAnd(value, zero-constant)
1037             // Into this: zero-constant.
1038             if (m_value-&gt;child(1)-&gt;isInt(0)) {
1039                 replaceWithIdentity(m_value-&gt;child(1));
1040                 break;
1041             }
1042 
1043             // Turn this: BitAnd(value, all-ones)
1044             // Into this: value.
<span class="line-modified">1045             if ((m_value-&gt;type() == Int64 &amp;&amp; m_value-&gt;child(1)-&gt;isInt64(std::numeric_limits&lt;uint64_t&gt;::max()))</span>
<span class="line-modified">1046                 || (m_value-&gt;type() == Int32 &amp;&amp; m_value-&gt;child(1)-&gt;isInt32(std::numeric_limits&lt;uint32_t&gt;::max()))) {</span>
1047                 replaceWithIdentity(m_value-&gt;child(0));
1048                 break;
1049             }
1050 
1051             // Turn this: BitAnd(64-bit value, 32 ones)
1052             // Into this: ZExt32(Trunc(64-bit value))
1053             if (m_value-&gt;child(1)-&gt;isInt64(0xffffffffllu)) {
1054                 Value* newValue = m_insertionSet.insert&lt;Value&gt;(
1055                     m_index, ZExt32, m_value-&gt;origin(),
1056                     m_insertionSet.insert&lt;Value&gt;(m_index, Trunc, m_value-&gt;origin(), m_value-&gt;child(0)));
1057                 replaceWithIdentity(newValue);
1058                 break;
1059             }
1060 
1061             // Turn this: BitAnd(SExt8(value), mask) where (mask &amp; 0xffffff00) == 0
1062             // Into this: BitAnd(value, mask)
1063             if (m_value-&gt;child(0)-&gt;opcode() == SExt8 &amp;&amp; m_value-&gt;child(1)-&gt;hasInt32()
1064                 &amp;&amp; !(m_value-&gt;child(1)-&gt;asInt32() &amp; 0xffffff00)) {
1065                 m_value-&gt;child(0) = m_value-&gt;child(0)-&gt;child(0);
1066                 m_changed = true;
</pre>
<hr />
<pre>
1075                 m_changed = true;
1076                 break;
1077             }
1078 
1079             // Turn this: BitAnd(SExt32(value), mask) where (mask &amp; 0xffffffff00000000) == 0
1080             // Into this: BitAnd(ZExt32(value), mask)
1081             if (m_value-&gt;child(0)-&gt;opcode() == SExt32 &amp;&amp; m_value-&gt;child(1)-&gt;hasInt32()
1082                 &amp;&amp; !(m_value-&gt;child(1)-&gt;asInt32() &amp; 0xffffffff00000000llu)) {
1083                 m_value-&gt;child(0) = m_insertionSet.insert&lt;Value&gt;(
1084                     m_index, ZExt32, m_value-&gt;origin(),
1085                     m_value-&gt;child(0)-&gt;child(0), m_value-&gt;child(0)-&gt;child(1));
1086                 m_changed = true;
1087                 break;
1088             }
1089 
1090             // Turn this: BitAnd(Op(value, constant1), constant2)
1091             //     where !(constant1 &amp; constant2)
1092             //       and Op is BitOr or BitXor
1093             // into this: BitAnd(value, constant2)
1094             if (m_value-&gt;child(1)-&gt;hasInt()) {
<span class="line-added">1095                 bool replaced = false;</span>
1096                 int64_t constant2 = m_value-&gt;child(1)-&gt;asInt();
1097                 switch (m_value-&gt;child(0)-&gt;opcode()) {
1098                 case BitOr:
1099                 case BitXor:
1100                     if (m_value-&gt;child(0)-&gt;child(1)-&gt;hasInt()
1101                         &amp;&amp; !(m_value-&gt;child(0)-&gt;child(1)-&gt;asInt() &amp; constant2)) {
1102                         m_value-&gt;child(0) = m_value-&gt;child(0)-&gt;child(0);
1103                         m_changed = true;
<span class="line-added">1104                         replaced = true;</span>
1105                         break;
1106                     }
1107                     break;
1108                 default:
1109                     break;
1110                 }
<span class="line-modified">1111                 if (replaced)</span>
<span class="line-added">1112                     break;</span>
1113             }
1114 
1115             // Turn this: BitAnd(BitXor(x1, allOnes), BitXor(x2, allOnes)
1116             // Into this: BitXor(BitOr(x1, x2), allOnes)
1117             // By applying De Morgan laws
1118             if (m_value-&gt;child(0)-&gt;opcode() == BitXor
1119                 &amp;&amp; m_value-&gt;child(1)-&gt;opcode() == BitXor
1120                 &amp;&amp; ((m_value-&gt;type() == Int64
<span class="line-modified">1121                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt64(std::numeric_limits&lt;uint64_t&gt;::max())</span>
<span class="line-modified">1122                         &amp;&amp; m_value-&gt;child(1)-&gt;child(1)-&gt;isInt64(std::numeric_limits&lt;uint64_t&gt;::max()))</span>
1123                     || (m_value-&gt;type() == Int32
<span class="line-modified">1124                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt32(std::numeric_limits&lt;uint32_t&gt;::max())</span>
<span class="line-modified">1125                         &amp;&amp; m_value-&gt;child(1)-&gt;child(1)-&gt;isInt32(std::numeric_limits&lt;uint32_t&gt;::max())))) {</span>
1126                 Value* bitOr = m_insertionSet.insert&lt;Value&gt;(m_index, BitOr, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), m_value-&gt;child(1)-&gt;child(0));
1127                 replaceWithNew&lt;Value&gt;(BitXor, m_value-&gt;origin(), bitOr, m_value-&gt;child(1)-&gt;child(1));
1128                 break;
1129             }
1130 
1131             // Turn this: BitAnd(BitXor(x, allOnes), c)
1132             // Into this: BitXor(BitOr(x, ~c), allOnes)
1133             // This is a variation on the previous optimization, treating c as if it were BitXor(~c, allOnes)
1134             // It does not reduce the number of operations, but provides some normalization (we try to get BitXor by allOnes at the outermost point), and some chance to float Xors to a place where they might get eliminated.
1135             if (m_value-&gt;child(0)-&gt;opcode() == BitXor
1136                 &amp;&amp; m_value-&gt;child(1)-&gt;hasInt()
1137                 &amp;&amp; ((m_value-&gt;type() == Int64
<span class="line-modified">1138                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt64(std::numeric_limits&lt;uint64_t&gt;::max()))</span>
1139                     || (m_value-&gt;type() == Int32
<span class="line-modified">1140                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt32(std::numeric_limits&lt;uint32_t&gt;::max())))) {</span>
<span class="line-modified">1141                 Value* newConstant = m_value-&gt;child(1)-&gt;bitXorConstant(m_proc, m_value-&gt;child(0)-&gt;child(1));</span>
<span class="line-added">1142                 ASSERT(newConstant);</span>
<span class="line-added">1143                 m_insertionSet.insertValue(m_index, newConstant);</span>
<span class="line-added">1144                 Value* bitOr = m_insertionSet.insert&lt;Value&gt;(m_index, BitOr, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), newConstant);</span>
1145                 replaceWithNew&lt;Value&gt;(BitXor, m_value-&gt;origin(), bitOr, m_value-&gt;child(0)-&gt;child(1));
1146                 break;
1147             }
1148 
1149             break;
1150 
1151         case BitOr:
1152             handleCommutativity();
1153 
1154             // Turn this: BitOr(constant1, constant2)
1155             // Into this: constant1 | constant2
1156             if (Value* constantBitOr = m_value-&gt;child(0)-&gt;bitOrConstant(m_proc, m_value-&gt;child(1))) {
1157                 replaceWithNewValue(constantBitOr);
1158                 break;
1159             }
1160 
1161             // Turn this: BitOr(BitOr(value, constant1), constant2)
1162             // Into this: BitOr(value, constant1 &amp; constant2).
1163             if (m_value-&gt;child(0)-&gt;opcode() == BitOr) {
1164                 Value* newConstant = m_value-&gt;child(1)-&gt;bitOrConstant(m_proc, m_value-&gt;child(0)-&gt;child(1));
</pre>
<hr />
<pre>
1169                     m_changed = true;
1170                 }
1171             }
1172 
1173             // Turn this: BitOr(valueX, valueX)
1174             // Into this: valueX.
1175             if (m_value-&gt;child(0) == m_value-&gt;child(1)) {
1176                 replaceWithIdentity(m_value-&gt;child(0));
1177                 break;
1178             }
1179 
1180             // Turn this: BitOr(value, zero-constant)
1181             // Into this: value.
1182             if (m_value-&gt;child(1)-&gt;isInt(0)) {
1183                 replaceWithIdentity(m_value-&gt;child(0));
1184                 break;
1185             }
1186 
1187             // Turn this: BitOr(value, all-ones)
1188             // Into this: all-ones.
<span class="line-modified">1189             if ((m_value-&gt;type() == Int64 &amp;&amp; m_value-&gt;child(1)-&gt;isInt64(std::numeric_limits&lt;uint64_t&gt;::max()))</span>
<span class="line-modified">1190                 || (m_value-&gt;type() == Int32 &amp;&amp; m_value-&gt;child(1)-&gt;isInt32(std::numeric_limits&lt;uint32_t&gt;::max()))) {</span>
1191                 replaceWithIdentity(m_value-&gt;child(1));
1192                 break;
1193             }
1194 
1195             // Turn this: BitOr(BitXor(x1, allOnes), BitXor(x2, allOnes)
1196             // Into this: BitXor(BitAnd(x1, x2), allOnes)
1197             // By applying De Morgan laws
1198             if (m_value-&gt;child(0)-&gt;opcode() == BitXor
1199                 &amp;&amp; m_value-&gt;child(1)-&gt;opcode() == BitXor
1200                 &amp;&amp; ((m_value-&gt;type() == Int64
<span class="line-modified">1201                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt64(std::numeric_limits&lt;uint64_t&gt;::max())</span>
<span class="line-modified">1202                         &amp;&amp; m_value-&gt;child(1)-&gt;child(1)-&gt;isInt64(std::numeric_limits&lt;uint64_t&gt;::max()))</span>
1203                     || (m_value-&gt;type() == Int32
<span class="line-modified">1204                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt32(std::numeric_limits&lt;uint32_t&gt;::max())</span>
<span class="line-modified">1205                         &amp;&amp; m_value-&gt;child(1)-&gt;child(1)-&gt;isInt32(std::numeric_limits&lt;uint32_t&gt;::max())))) {</span>
1206                 Value* bitAnd = m_insertionSet.insert&lt;Value&gt;(m_index, BitAnd, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), m_value-&gt;child(1)-&gt;child(0));
1207                 replaceWithNew&lt;Value&gt;(BitXor, m_value-&gt;origin(), bitAnd, m_value-&gt;child(1)-&gt;child(1));
1208                 break;
1209             }
1210 
1211             // Turn this: BitOr(BitXor(x, allOnes), c)
1212             // Into this: BitXor(BitAnd(x, ~c), allOnes)
1213             // This is a variation on the previous optimization, treating c as if it were BitXor(~c, allOnes)
1214             // It does not reduce the number of operations, but provides some normalization (we try to get BitXor by allOnes at the outermost point), and some chance to float Xors to a place where they might get eliminated.
1215             if (m_value-&gt;child(0)-&gt;opcode() == BitXor
1216                 &amp;&amp; m_value-&gt;child(1)-&gt;hasInt()
1217                 &amp;&amp; ((m_value-&gt;type() == Int64
<span class="line-modified">1218                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt64(std::numeric_limits&lt;uint64_t&gt;::max()))</span>
1219                     || (m_value-&gt;type() == Int32
<span class="line-modified">1220                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt32(std::numeric_limits&lt;uint32_t&gt;::max())))) {</span>
<span class="line-modified">1221                 Value* newConstant = m_value-&gt;child(1)-&gt;bitXorConstant(m_proc, m_value-&gt;child(0)-&gt;child(1));</span>
<span class="line-added">1222                 ASSERT(newConstant);</span>
<span class="line-added">1223                 m_insertionSet.insertValue(m_index, newConstant);</span>
<span class="line-added">1224                 Value* bitAnd = m_insertionSet.insert&lt;Value&gt;(m_index, BitAnd, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), newConstant);</span>
1225                 replaceWithNew&lt;Value&gt;(BitXor, m_value-&gt;origin(), bitAnd, m_value-&gt;child(0)-&gt;child(1));
1226                 break;
1227             }
1228 
1229             if (handleBitAndDistributivity())
1230                 break;
1231 
1232             break;
1233 
1234         case BitXor:
1235             handleCommutativity();
1236 
1237             // Turn this: BitXor(constant1, constant2)
1238             // Into this: constant1 ^ constant2
1239             if (Value* constantBitXor = m_value-&gt;child(0)-&gt;bitXorConstant(m_proc, m_value-&gt;child(1))) {
1240                 replaceWithNewValue(constantBitXor);
1241                 break;
1242             }
1243 
1244             // Turn this: BitXor(BitXor(value, constant1), constant2)
</pre>
<hr />
<pre>
2094             //     Check(@b_truecase)
2095             //     Upsilon(@x, ^a)
2096             //     Upsilon(@b_truecase, ^b)
2097             //     Jump(#continuation)
2098             //
2099             //   BB#falsecase:
2100             //     @b_falsecase = Add(42, 35)
2101             //     Check(@b_falsecase)
2102             //     Upsilon(42, ^a)
2103             //     Upsilon(@b_falsecase, ^b)
2104             //     Jump(#continuation)
2105             //
2106             //   BB#continuation:
2107             //     @a = Phi()
2108             //     @b = Phi()
2109             //
2110             // The goal of this optimization is to kill a lot of code in one of those basic
2111             // blocks. This is pretty much guaranteed since one of those blocks will replace all
2112             // uses of the Select with a constant, and that constant will be transitively used
2113             // from the check.
<span class="line-modified">2114             static constexpr unsigned selectSpecializationBound = 3;</span>
2115             Value* select = findRecentNodeMatching(
2116                 m_value-&gt;child(0), selectSpecializationBound,
2117                 [&amp;] (Value* value) -&gt; bool {
2118                     return value-&gt;opcode() == Select
2119                         &amp;&amp; (value-&gt;child(1)-&gt;isConstant() &amp;&amp; value-&gt;child(2)-&gt;isConstant());
2120                 });
2121 
2122             if (select) {
2123                 specializeSelect(select);
2124                 break;
2125             }
2126             break;
2127         }
2128 
2129         case Branch: {
2130             // Turn this: Branch(NotEqual(x, 0))
2131             // Into this: Branch(x)
2132             if (m_value-&gt;child(0)-&gt;opcode() == NotEqual &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(0)) {
2133                 m_value-&gt;child(0) = m_value-&gt;child(0)-&gt;child(0);
2134                 m_changed = true;
</pre>
<hr />
<pre>
2278         // chopped off.
2279         BasicBlock* predecessor = m_blockInsertionSet.splitForward(m_block, m_index, &amp;m_insertionSet);
2280         if (m_block == m_root) {
2281             m_root = predecessor;
2282             m_valueForConstant.clear();
2283         }
2284 
2285         // Splitting will commit the insertion set, which changes the exact position of the
2286         // source. That&#39;s why we do the search after splitting.
2287         unsigned startIndex = UINT_MAX;
2288         for (unsigned i = predecessor-&gt;size(); i--;) {
2289             if (predecessor-&gt;at(i) == source) {
2290                 startIndex = i;
2291                 break;
2292             }
2293         }
2294 
2295         RELEASE_ASSERT(startIndex != UINT_MAX);
2296 
2297         // By BasicBlock convention, caseIndex == 0 =&gt; then, caseIndex == 1 =&gt; else.
<span class="line-modified">2298         static constexpr unsigned numCases = 2;</span>
2299         BasicBlock* cases[numCases];
2300         for (unsigned i = 0; i &lt; numCases; ++i)
2301             cases[i] = m_blockInsertionSet.insertBefore(m_block);
2302 
2303         HashMap&lt;Value*, Value*&gt; mappings[2];
2304 
2305         // Save things we want to know about the source.
2306         Value* predicate = source-&gt;child(0);
2307 
2308         for (unsigned i = 0; i &lt; numCases; ++i)
2309             mappings[i].add(source, source-&gt;child(1 + i));
2310 
2311         auto cloneValue = [&amp;] (Value* value) {
2312             ASSERT(value != source);
2313 
2314             for (unsigned i = 0; i &lt; numCases; ++i) {
2315                 Value* clone = m_proc.clone(value);
2316                 for (Value*&amp; child : clone-&gt;children()) {
2317                     if (Value* newChild = mappings[i].get(child))
2318                         child = newChild;
</pre>
<hr />
<pre>
2587 
2588         case Shl:
2589             if (value-&gt;child(1)-&gt;hasInt32()) {
2590                 return rangeFor(value-&gt;child(0), timeToLive - 1).shl(
2591                     value-&gt;child(1)-&gt;asInt32(), value-&gt;type());
2592             }
2593             break;
2594 
2595         case Add:
2596             return rangeFor(value-&gt;child(0), timeToLive - 1).add(
2597                 rangeFor(value-&gt;child(1), timeToLive - 1), value-&gt;type());
2598 
2599         case Sub:
2600             return rangeFor(value-&gt;child(0), timeToLive - 1).sub(
2601                 rangeFor(value-&gt;child(1), timeToLive - 1), value-&gt;type());
2602 
2603         case Mul:
2604             return rangeFor(value-&gt;child(0), timeToLive - 1).mul(
2605                 rangeFor(value-&gt;child(1), timeToLive - 1), value-&gt;type());
2606 
<span class="line-added">2607         case SExt8:</span>
<span class="line-added">2608         case SExt16:</span>
<span class="line-added">2609         case SExt32:</span>
<span class="line-added">2610             return rangeFor(value-&gt;child(0), timeToLive - 1);</span>
<span class="line-added">2611 </span>
<span class="line-added">2612         case ZExt32:</span>
<span class="line-added">2613             return rangeFor(value-&gt;child(0), timeToLive - 1).zExt32();</span>
<span class="line-added">2614 </span>
2615         default:
2616             break;
2617         }
2618 
2619         return IntRange::top(value-&gt;type());
2620     }
2621 
2622     template&lt;typename ValueType, typename... Arguments&gt;
2623     void replaceWithNew(Arguments... arguments)
2624     {
2625         replaceWithNewValue(m_proc.add&lt;ValueType&gt;(arguments...));
2626     }
2627 
2628     bool replaceWithNewValue(Value* newValue)
2629     {
2630         if (!newValue)
2631             return false;
2632         m_insertionSet.insertValue(m_index, newValue);
2633         m_value-&gt;replaceWithIdentity(newValue);
2634         m_changed = true;
</pre>
</td>
</tr>
</table>
<center><a href="B3ReduceLoopStrength.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="B3StackmapGenerationParams.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
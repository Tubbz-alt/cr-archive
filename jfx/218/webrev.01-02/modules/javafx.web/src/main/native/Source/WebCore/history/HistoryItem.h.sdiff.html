<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/history/HistoryItem.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HistoryItem.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../html/Autocapitalize.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/history/HistoryItem.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 46 #endif
 47 
 48 #if PLATFORM(COCOA)
 49 #import &lt;wtf/RetainPtr.h&gt;
 50 typedef struct objc_object* id;
 51 #endif
 52 
 53 namespace WebCore {
 54 
 55 class CachedPage;
 56 class Document;
 57 class FormData;
 58 class HistoryItem;
 59 class Image;
 60 class ResourceRequest;
 61 enum class PruningReason;
 62 
 63 WEBCORE_EXPORT extern void (*notifyHistoryItemChanged)(HistoryItem&amp;);
 64 
 65 class HistoryItem : public RefCounted&lt;HistoryItem&gt; {
<span class="line-modified"> 66     friend class PageCache;</span>
 67 
 68 public:
 69     static Ref&lt;HistoryItem&gt; create()
 70     {
 71         return adoptRef(*new HistoryItem);
 72     }
 73 
 74     static Ref&lt;HistoryItem&gt; create(const String&amp; urlString, const String&amp; title)
 75     {
 76         return adoptRef(*new HistoryItem(urlString, title));
 77     }
 78 
 79     static Ref&lt;HistoryItem&gt; create(const String&amp; urlString, const String&amp; title, const String&amp; alternateTitle)
 80     {
 81         return adoptRef(*new HistoryItem(urlString, title, alternateTitle));
 82     }
 83 
 84     static Ref&lt;HistoryItem&gt; create(const String&amp; urlString, const String&amp; title, const String&amp; alternateTitle, BackForwardItemIdentifier identifier)
 85     {
 86         return adoptRef(*new HistoryItem(urlString, title, alternateTitle, identifier));
 87     }
 88 
 89     WEBCORE_EXPORT ~HistoryItem();
 90 
 91     WEBCORE_EXPORT Ref&lt;HistoryItem&gt; copy() const;
 92 
 93     const BackForwardItemIdentifier&amp; identifier() const { return m_identifier; }
 94 
 95     // Resets the HistoryItem to its initial state, as returned by create().
 96     void reset();
 97 
 98     WEBCORE_EXPORT const String&amp; originalURLString() const;
 99     WEBCORE_EXPORT const String&amp; urlString() const;
100     WEBCORE_EXPORT const String&amp; title() const;
101 
<span class="line-modified">102     bool isInPageCache() const { return m_cachedPage.get(); }</span>
103     WEBCORE_EXPORT bool hasCachedPageExpired() const;
104 
105     WEBCORE_EXPORT void setAlternateTitle(const String&amp;);
106     WEBCORE_EXPORT const String&amp; alternateTitle() const;
107 
108     WEBCORE_EXPORT URL url() const;
109     WEBCORE_EXPORT URL originalURL() const;
110     WEBCORE_EXPORT const String&amp; referrer() const;
111     WEBCORE_EXPORT const String&amp; target() const;
112     WEBCORE_EXPORT bool isTargetItem() const;
113 
114     WEBCORE_EXPORT FormData* formData();
115     WEBCORE_EXPORT String formContentType() const;
116 
117     bool lastVisitWasFailure() const { return m_lastVisitWasFailure; }
118 
119     WEBCORE_EXPORT const IntPoint&amp; scrollPosition() const;
120     WEBCORE_EXPORT void setScrollPosition(const IntPoint&amp;);
121     void clearScrollPosition();
122 
</pre>
<hr />
<pre>
210 
211     const ViewportArguments&amp; viewportArguments() const { return m_viewportArguments; }
212     void setViewportArguments(const ViewportArguments&amp; viewportArguments) { m_viewportArguments = viewportArguments; }
213 #endif
214 
215     void notifyChanged();
216 
217     void setWasRestoredFromSession(bool wasRestoredFromSession) { m_wasRestoredFromSession = wasRestoredFromSession; }
218     bool wasRestoredFromSession() const { return m_wasRestoredFromSession; }
219 
220 #if !LOG_DISABLED
221     const char* logString() const;
222 #endif
223 
224 private:
225     WEBCORE_EXPORT HistoryItem();
226     WEBCORE_EXPORT HistoryItem(const String&amp; urlString, const String&amp; title);
227     WEBCORE_EXPORT HistoryItem(const String&amp; urlString, const String&amp; title, const String&amp; alternateTitle);
228     WEBCORE_EXPORT HistoryItem(const String&amp; urlString, const String&amp; title, const String&amp; alternateTitle, BackForwardItemIdentifier);
229 



230     HistoryItem(const HistoryItem&amp;);
231 
232     static int64_t generateSequenceNumber();
233 
234     bool hasSameDocumentTree(HistoryItem&amp; otherItem) const;
235 
236     String m_urlString;
237     String m_originalURLString;
238     String m_referrer;
239     String m_target;
240     String m_title;
241     String m_displayTitle;
242 
243     IntPoint m_scrollPosition;
244     float m_pageScaleFactor { 0 }; // 0 indicates &quot;unset&quot;.
245     Vector&lt;String&gt; m_documentState;
246 
247     ShouldOpenExternalURLsPolicy m_shouldOpenExternalURLsPolicy { ShouldOpenExternalURLsPolicy::ShouldNotAllow };
248 
249     Vector&lt;Ref&lt;HistoryItem&gt;&gt; m_children;
</pre>
<hr />
<pre>
254     bool m_shouldRestoreScrollPosition { true };
255 
256     // If two HistoryItems have the same item sequence number, then they are
257     // clones of one another.  Traversing history from one such HistoryItem to
258     // another is a no-op.  HistoryItem clones are created for parent and
259     // sibling frames when only a subframe navigates.
260     int64_t m_itemSequenceNumber { generateSequenceNumber() };
261 
262     // If two HistoryItems have the same document sequence number, then they
263     // refer to the same instance of a document.  Traversing history from one
264     // such HistoryItem to another preserves the document.
265     int64_t m_documentSequenceNumber { generateSequenceNumber() };
266 
267     // Support for HTML5 History
268     RefPtr&lt;SerializedScriptValue&gt; m_stateObject;
269 
270     // info used to repost form data
271     RefPtr&lt;FormData&gt; m_formData;
272     String m_formContentType;
273 
<span class="line-modified">274     // PageCache controls these fields.</span>
275     std::unique_ptr&lt;CachedPage&gt; m_cachedPage;
276     PruningReason m_pruningReason;
277 
278 #if PLATFORM(IOS_FAMILY)
279     FloatRect m_exposedContentRect;
280     IntRect m_unobscuredContentRect;
281     FloatSize m_minimumLayoutSizeInScrollViewCoordinates;
282     IntSize m_contentSize;
283     FloatBoxExtent m_obscuredInsets;
284     float m_scale { 0 }; // Note that UIWebView looks for a non-zero value, so this has to start as 0.
285     bool m_scaleIsInitial { false };
286     ViewportArguments m_viewportArguments;
287 #endif
288 
289 #if PLATFORM(JAVA)
290     JGObject m_hostObject { nullptr };
291 #endif
292 
293 #if PLATFORM(COCOA)
294     RetainPtr&lt;id&gt; m_viewState;
</pre>
</td>
<td>
<hr />
<pre>
 46 #endif
 47 
 48 #if PLATFORM(COCOA)
 49 #import &lt;wtf/RetainPtr.h&gt;
 50 typedef struct objc_object* id;
 51 #endif
 52 
 53 namespace WebCore {
 54 
 55 class CachedPage;
 56 class Document;
 57 class FormData;
 58 class HistoryItem;
 59 class Image;
 60 class ResourceRequest;
 61 enum class PruningReason;
 62 
 63 WEBCORE_EXPORT extern void (*notifyHistoryItemChanged)(HistoryItem&amp;);
 64 
 65 class HistoryItem : public RefCounted&lt;HistoryItem&gt; {
<span class="line-modified"> 66     friend class BackForwardCache;</span>
 67 
 68 public:
 69     static Ref&lt;HistoryItem&gt; create()
 70     {
 71         return adoptRef(*new HistoryItem);
 72     }
 73 
 74     static Ref&lt;HistoryItem&gt; create(const String&amp; urlString, const String&amp; title)
 75     {
 76         return adoptRef(*new HistoryItem(urlString, title));
 77     }
 78 
 79     static Ref&lt;HistoryItem&gt; create(const String&amp; urlString, const String&amp; title, const String&amp; alternateTitle)
 80     {
 81         return adoptRef(*new HistoryItem(urlString, title, alternateTitle));
 82     }
 83 
 84     static Ref&lt;HistoryItem&gt; create(const String&amp; urlString, const String&amp; title, const String&amp; alternateTitle, BackForwardItemIdentifier identifier)
 85     {
 86         return adoptRef(*new HistoryItem(urlString, title, alternateTitle, identifier));
 87     }
 88 
 89     WEBCORE_EXPORT ~HistoryItem();
 90 
 91     WEBCORE_EXPORT Ref&lt;HistoryItem&gt; copy() const;
 92 
 93     const BackForwardItemIdentifier&amp; identifier() const { return m_identifier; }
 94 
 95     // Resets the HistoryItem to its initial state, as returned by create().
 96     void reset();
 97 
 98     WEBCORE_EXPORT const String&amp; originalURLString() const;
 99     WEBCORE_EXPORT const String&amp; urlString() const;
100     WEBCORE_EXPORT const String&amp; title() const;
101 
<span class="line-modified">102     bool isInBackForwardCache() const { return m_cachedPage.get(); }</span>
103     WEBCORE_EXPORT bool hasCachedPageExpired() const;
104 
105     WEBCORE_EXPORT void setAlternateTitle(const String&amp;);
106     WEBCORE_EXPORT const String&amp; alternateTitle() const;
107 
108     WEBCORE_EXPORT URL url() const;
109     WEBCORE_EXPORT URL originalURL() const;
110     WEBCORE_EXPORT const String&amp; referrer() const;
111     WEBCORE_EXPORT const String&amp; target() const;
112     WEBCORE_EXPORT bool isTargetItem() const;
113 
114     WEBCORE_EXPORT FormData* formData();
115     WEBCORE_EXPORT String formContentType() const;
116 
117     bool lastVisitWasFailure() const { return m_lastVisitWasFailure; }
118 
119     WEBCORE_EXPORT const IntPoint&amp; scrollPosition() const;
120     WEBCORE_EXPORT void setScrollPosition(const IntPoint&amp;);
121     void clearScrollPosition();
122 
</pre>
<hr />
<pre>
210 
211     const ViewportArguments&amp; viewportArguments() const { return m_viewportArguments; }
212     void setViewportArguments(const ViewportArguments&amp; viewportArguments) { m_viewportArguments = viewportArguments; }
213 #endif
214 
215     void notifyChanged();
216 
217     void setWasRestoredFromSession(bool wasRestoredFromSession) { m_wasRestoredFromSession = wasRestoredFromSession; }
218     bool wasRestoredFromSession() const { return m_wasRestoredFromSession; }
219 
220 #if !LOG_DISABLED
221     const char* logString() const;
222 #endif
223 
224 private:
225     WEBCORE_EXPORT HistoryItem();
226     WEBCORE_EXPORT HistoryItem(const String&amp; urlString, const String&amp; title);
227     WEBCORE_EXPORT HistoryItem(const String&amp; urlString, const String&amp; title, const String&amp; alternateTitle);
228     WEBCORE_EXPORT HistoryItem(const String&amp; urlString, const String&amp; title, const String&amp; alternateTitle, BackForwardItemIdentifier);
229 
<span class="line-added">230     void setCachedPage(std::unique_ptr&lt;CachedPage&gt;&amp;&amp;);</span>
<span class="line-added">231     std::unique_ptr&lt;CachedPage&gt; takeCachedPage();</span>
<span class="line-added">232 </span>
233     HistoryItem(const HistoryItem&amp;);
234 
235     static int64_t generateSequenceNumber();
236 
237     bool hasSameDocumentTree(HistoryItem&amp; otherItem) const;
238 
239     String m_urlString;
240     String m_originalURLString;
241     String m_referrer;
242     String m_target;
243     String m_title;
244     String m_displayTitle;
245 
246     IntPoint m_scrollPosition;
247     float m_pageScaleFactor { 0 }; // 0 indicates &quot;unset&quot;.
248     Vector&lt;String&gt; m_documentState;
249 
250     ShouldOpenExternalURLsPolicy m_shouldOpenExternalURLsPolicy { ShouldOpenExternalURLsPolicy::ShouldNotAllow };
251 
252     Vector&lt;Ref&lt;HistoryItem&gt;&gt; m_children;
</pre>
<hr />
<pre>
257     bool m_shouldRestoreScrollPosition { true };
258 
259     // If two HistoryItems have the same item sequence number, then they are
260     // clones of one another.  Traversing history from one such HistoryItem to
261     // another is a no-op.  HistoryItem clones are created for parent and
262     // sibling frames when only a subframe navigates.
263     int64_t m_itemSequenceNumber { generateSequenceNumber() };
264 
265     // If two HistoryItems have the same document sequence number, then they
266     // refer to the same instance of a document.  Traversing history from one
267     // such HistoryItem to another preserves the document.
268     int64_t m_documentSequenceNumber { generateSequenceNumber() };
269 
270     // Support for HTML5 History
271     RefPtr&lt;SerializedScriptValue&gt; m_stateObject;
272 
273     // info used to repost form data
274     RefPtr&lt;FormData&gt; m_formData;
275     String m_formContentType;
276 
<span class="line-modified">277     // BackForwardCache controls these fields.</span>
278     std::unique_ptr&lt;CachedPage&gt; m_cachedPage;
279     PruningReason m_pruningReason;
280 
281 #if PLATFORM(IOS_FAMILY)
282     FloatRect m_exposedContentRect;
283     IntRect m_unobscuredContentRect;
284     FloatSize m_minimumLayoutSizeInScrollViewCoordinates;
285     IntSize m_contentSize;
286     FloatBoxExtent m_obscuredInsets;
287     float m_scale { 0 }; // Note that UIWebView looks for a non-zero value, so this has to start as 0.
288     bool m_scaleIsInitial { false };
289     ViewportArguments m_viewportArguments;
290 #endif
291 
292 #if PLATFORM(JAVA)
293     JGObject m_hostObject { nullptr };
294 #endif
295 
296 #if PLATFORM(COCOA)
297     RetainPtr&lt;id&gt; m_viewState;
</pre>
</td>
</tr>
</table>
<center><a href="HistoryItem.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../html/Autocapitalize.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
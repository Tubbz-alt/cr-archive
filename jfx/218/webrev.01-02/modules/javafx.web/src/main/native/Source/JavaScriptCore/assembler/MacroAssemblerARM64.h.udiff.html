<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/MacroAssemblerARM64.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MacroAssembler.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MacroAssemblerARM64E.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/MacroAssemblerARM64.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (C) 2012-2018 Apple Inc. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (C) 2012-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -33,15 +33,16 @@</span>
  #include &lt;wtf/Optional.h&gt;
  
  namespace JSC {
  
  using Assembler = TARGET_ASSEMBLER;
<span class="udiff-line-added">+ class Reg;</span>
  
  class MacroAssemblerARM64 : public AbstractMacroAssembler&lt;Assembler&gt; {
  public:
<span class="udiff-line-modified-removed">-     static const unsigned numGPRs = 32;</span>
<span class="udiff-line-modified-removed">-     static const unsigned numFPRs = 32;</span>
<span class="udiff-line-modified-added">+     static constexpr unsigned numGPRs = 32;</span>
<span class="udiff-line-modified-added">+     static constexpr unsigned numFPRs = 32;</span>
  
      static constexpr RegisterID dataTempRegister = ARM64Registers::ip0;
      static constexpr RegisterID memoryTempRegister = ARM64Registers::ip1;
  
      RegisterID scratchRegister()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -49,15 +50,15 @@</span>
          RELEASE_ASSERT(m_allowScratchRegister);
          return getCachedDataTempRegisterIDAndInvalidate();
      }
  
  protected:
<span class="udiff-line-modified-removed">-     static const ARM64Registers::FPRegisterID fpTempRegister = ARM64Registers::q31;</span>
<span class="udiff-line-modified-removed">-     static const Assembler::SetFlags S = Assembler::S;</span>
<span class="udiff-line-modified-removed">-     static const int64_t maskHalfWord0 = 0xffffl;</span>
<span class="udiff-line-modified-removed">-     static const int64_t maskHalfWord1 = 0xffff0000l;</span>
<span class="udiff-line-modified-removed">-     static const int64_t maskUpperWord = 0xffffffff00000000l;</span>
<span class="udiff-line-modified-added">+     static constexpr ARM64Registers::FPRegisterID fpTempRegister = ARM64Registers::q31;</span>
<span class="udiff-line-modified-added">+     static constexpr Assembler::SetFlags S = Assembler::S;</span>
<span class="udiff-line-modified-added">+     static constexpr int64_t maskHalfWord0 = 0xffffl;</span>
<span class="udiff-line-modified-added">+     static constexpr int64_t maskHalfWord1 = 0xffff0000l;</span>
<span class="udiff-line-modified-added">+     static constexpr int64_t maskUpperWord = 0xffffffff00000000l;</span>
  
      static constexpr size_t INSTRUCTION_SIZE = 4;
  
      // N instructions to load the pointer + 1 call instruction.
      static constexpr ptrdiff_t REPATCH_OFFSET_CALL_TO_POINTER = -((Assembler::MAX_POINTER_BITS / 16 + 1) * INSTRUCTION_SIZE);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -73,22 +74,22 @@</span>
      typedef Assembler::LinkRecord LinkRecord;
      typedef Assembler::JumpType JumpType;
      typedef Assembler::JumpLinkType JumpLinkType;
      typedef Assembler::Condition Condition;
  
<span class="udiff-line-modified-removed">-     static const Assembler::Condition DefaultCondition = Assembler::ConditionInvalid;</span>
<span class="udiff-line-modified-removed">-     static const Assembler::JumpType DefaultJump = Assembler::JumpNoConditionFixedSize;</span>
<span class="udiff-line-modified-added">+     static constexpr Assembler::Condition DefaultCondition = Assembler::ConditionInvalid;</span>
<span class="udiff-line-modified-added">+     static constexpr Assembler::JumpType DefaultJump = Assembler::JumpNoConditionFixedSize;</span>
  
      Vector&lt;LinkRecord, 0, UnsafeVectorOverflow&gt;&amp; jumpsToLink() { return m_assembler.jumpsToLink(); }
      static bool canCompact(JumpType jumpType) { return Assembler::canCompact(jumpType); }
      static JumpLinkType computeJumpType(JumpType jumpType, const uint8_t* from, const uint8_t* to) { return Assembler::computeJumpType(jumpType, from, to); }
      static JumpLinkType computeJumpType(LinkRecord&amp; record, const uint8_t* from, const uint8_t* to) { return Assembler::computeJumpType(record, from, to); }
      static int jumpSizeDelta(JumpType jumpType, JumpLinkType jumpLinkType) { return Assembler::jumpSizeDelta(jumpType, jumpLinkType); }
<span class="udiff-line-modified-removed">-     template &lt;typename CopyFunction&gt;</span>
<span class="udiff-line-modified-removed">-     static void link(LinkRecord&amp; record, uint8_t* from, const uint8_t* fromInstruction, uint8_t* to, CopyFunction copy) { return Assembler::link(record, from, fromInstruction, to, copy); }</span>
<span class="udiff-line-modified-added">+     template &lt;Assembler::CopyFunction copy&gt;</span>
<span class="udiff-line-modified-added">+     static void link(LinkRecord&amp; record, uint8_t* from, const uint8_t* fromInstruction, uint8_t* to) { return Assembler::link&lt;copy&gt;(record, from, fromInstruction, to); }</span>
  
<span class="udiff-line-modified-removed">-     static const Scale ScalePtr = TimesEight;</span>
<span class="udiff-line-modified-added">+     static constexpr Scale ScalePtr = TimesEight;</span>
  
      static bool isCompactPtrAlignedAddressOffset(ptrdiff_t value)
      {
          // This is the largest 32-bit access allowed, aligned to 64-bit boundary.
          return !(value &amp; ~0x3ff8);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -135,13 +136,13 @@</span>
          DoubleGreaterThanOrEqualOrUnordered = Assembler::ConditionHS,
          DoubleLessThanOrUnordered = Assembler::ConditionLT,
          DoubleLessThanOrEqualOrUnordered = Assembler::ConditionLE,
      };
  
<span class="udiff-line-modified-removed">-     static const RegisterID stackPointerRegister = ARM64Registers::sp;</span>
<span class="udiff-line-modified-removed">-     static const RegisterID framePointerRegister = ARM64Registers::fp;</span>
<span class="udiff-line-modified-removed">-     static const RegisterID linkRegister = ARM64Registers::lr;</span>
<span class="udiff-line-modified-added">+     static constexpr RegisterID stackPointerRegister = ARM64Registers::sp;</span>
<span class="udiff-line-modified-added">+     static constexpr RegisterID framePointerRegister = ARM64Registers::fp;</span>
<span class="udiff-line-modified-added">+     static constexpr RegisterID linkRegister = ARM64Registers::lr;</span>
  
      // FIXME: Get reasonable implementations for these
      static bool shouldBlindForSpecificArch(uint32_t value) { return value &gt;= 0x00ffffff; }
      static bool shouldBlindForSpecificArch(uint64_t value) { return value &gt;= 0x00ffffff; }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -612,10 +613,24 @@</span>
      void neg64(RegisterID src, RegisterID dest)
      {
          m_assembler.neg&lt;64&gt;(dest, src);
      }
  
<span class="udiff-line-added">+     void or16(TrustedImm32 imm, AbsoluteAddress address)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         LogicalImmediate logicalImm = LogicalImmediate::create32(imm.m_value);</span>
<span class="udiff-line-added">+         if (logicalImm.isValid()) {</span>
<span class="udiff-line-added">+             load16(address.m_ptr, getCachedDataTempRegisterIDAndInvalidate());</span>
<span class="udiff-line-added">+             m_assembler.orr&lt;32&gt;(dataTempRegister, dataTempRegister, logicalImm);</span>
<span class="udiff-line-added">+             store16(dataTempRegister, address.m_ptr);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             load16(address.m_ptr, getCachedMemoryTempRegisterIDAndInvalidate());</span>
<span class="udiff-line-added">+             or32(imm, memoryTempRegister, getCachedDataTempRegisterIDAndInvalidate());</span>
<span class="udiff-line-added">+             store16(dataTempRegister, address.m_ptr);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      void or32(RegisterID src, RegisterID dest)
      {
          or32(dest, src, dest);
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1235,10 +1250,15 @@</span>
          m_assembler.ldrh(dest, memoryTempRegister, address.base, Assembler::UXTX, 1);
          if (dest == memoryTempRegister)
              cachedMemoryTempRegister().invalidate();
      }
  
<span class="udiff-line-added">+     void load16(const void* address, RegisterID dest)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         load&lt;16&gt;(address, dest);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      void load16Unaligned(ImplicitAddress address, RegisterID dest)
      {
          load16(address, dest);
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1543,10 +1563,26 @@</span>
          signExtend32ToPtr(TrustedImm32(address.offset), getCachedMemoryTempRegisterIDAndInvalidate());
          m_assembler.add&lt;64&gt;(memoryTempRegister, memoryTempRegister, address.index, Assembler::UXTX, address.scale);
          m_assembler.strh(src, address.base, memoryTempRegister);
      }
  
<span class="udiff-line-added">+     void store16(RegisterID src, const void* address)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         store&lt;16&gt;(src, address);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     void store16(TrustedImm32 imm, const void* address)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         if (!imm.m_value) {</span>
<span class="udiff-line-added">+             store16(ARM64Registers::zr, address);</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         moveToCachedReg(imm, dataMemoryTempRegister());</span>
<span class="udiff-line-added">+         store16(dataTempRegister, address);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      void storeZero16(ImplicitAddress address)
      {
          store16(ARM64Registers::zr, address);
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3207,10 +3243,17 @@</span>
  
      ALWAYS_INLINE Call call(RegisterID callTag) { return UNUSED_PARAM(callTag), call(NoPtrTag); }
      ALWAYS_INLINE Call call(RegisterID target, RegisterID callTag) { return UNUSED_PARAM(callTag), call(target, NoPtrTag); }
      ALWAYS_INLINE Call call(Address address, RegisterID callTag) { return UNUSED_PARAM(callTag), call(address, NoPtrTag); }
  
<span class="udiff-line-added">+     ALWAYS_INLINE void callOperation(const FunctionPtr&lt;OperationPtrTag&gt; operation)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         auto tmp = getCachedDataTempRegisterIDAndInvalidate();</span>
<span class="udiff-line-added">+         move(TrustedImmPtr(operation.executableAddress()), tmp);</span>
<span class="udiff-line-added">+         call(tmp, OperationPtrTag);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      ALWAYS_INLINE Jump jump()
      {
          AssemblerLabel label = m_assembler.label();
          m_assembler.b();
          return Jump(label, m_makeJumpPatchable ? Assembler::JumpNoConditionFixedSize : Assembler::JumpNoCondition);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3245,10 +3288,11 @@</span>
      ALWAYS_INLINE void farJump(BaseIndex address, RegisterID jumpTag) { UNUSED_PARAM(jumpTag), farJump(address, NoPtrTag); }
      ALWAYS_INLINE void farJump(AbsoluteAddress address, RegisterID jumpTag) { UNUSED_PARAM(jumpTag), farJump(address, NoPtrTag); }
  
      ALWAYS_INLINE Call nearCall()
      {
<span class="udiff-line-added">+         invalidateAllTempRegisters();</span>
          m_assembler.bl();
          return Call(m_assembler.label(), Call::LinkableNear);
      }
  
      ALWAYS_INLINE Call nearTailCall()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3258,10 +3302,11 @@</span>
          return Call(label, Call::LinkableNearTail);
      }
  
      ALWAYS_INLINE Call threadSafePatchableNearCall()
      {
<span class="udiff-line-added">+         invalidateAllTempRegisters();</span>
          m_assembler.bl();
          return Call(m_assembler.label(), Call::LinkableNear);
      }
  
      ALWAYS_INLINE void ret()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4171,34 +4216,40 @@</span>
              if (dest == memoryTempRegister)
                  cachedMemoryTempRegister().invalidate();
  
              if (isInt&lt;32&gt;(addressDelta)) {
                  if (Assembler::canEncodeSImmOffset(addressDelta)) {
<span class="udiff-line-modified-removed">-                     m_assembler.ldur&lt;datasize&gt;(dest,  memoryTempRegister, addressDelta);</span>
<span class="udiff-line-modified-added">+                     loadUnscaledImmediate&lt;datasize&gt;(dest, memoryTempRegister, addressDelta);</span>
                      return;
                  }
  
                  if (Assembler::canEncodePImmOffset&lt;datasize&gt;(addressDelta)) {
<span class="udiff-line-modified-removed">-                     m_assembler.ldr&lt;datasize&gt;(dest,  memoryTempRegister, addressDelta);</span>
<span class="udiff-line-modified-added">+                     loadUnsignedImmediate&lt;datasize&gt;(dest, memoryTempRegister, addressDelta);</span>
                      return;
                  }
              }
  
              if ((addressAsInt &amp; (~maskHalfWord0)) == (currentRegisterContents &amp; (~maskHalfWord0))) {
                  m_assembler.movk&lt;64&gt;(memoryTempRegister, addressAsInt &amp; maskHalfWord0, 0);
                  cachedMemoryTempRegister().setValue(reinterpret_cast&lt;intptr_t&gt;(address));
<span class="udiff-line-modified-removed">-                 m_assembler.ldr&lt;datasize&gt;(dest, memoryTempRegister, ARM64Registers::zr);</span>
<span class="udiff-line-modified-added">+                 if constexpr (datasize == 16)</span>
<span class="udiff-line-added">+                     m_assembler.ldrh(dest, memoryTempRegister, ARM64Registers::zr);</span>
<span class="udiff-line-added">+                 else</span>
<span class="udiff-line-added">+                     m_assembler.ldr&lt;datasize&gt;(dest, memoryTempRegister, ARM64Registers::zr);</span>
                  return;
              }
          }
  
          move(TrustedImmPtr(address), memoryTempRegister);
          if (dest == memoryTempRegister)
              cachedMemoryTempRegister().invalidate();
          else
              cachedMemoryTempRegister().setValue(reinterpret_cast&lt;intptr_t&gt;(address));
<span class="udiff-line-modified-removed">-         m_assembler.ldr&lt;datasize&gt;(dest, memoryTempRegister, ARM64Registers::zr);</span>
<span class="udiff-line-modified-added">+         if constexpr (datasize == 16)</span>
<span class="udiff-line-added">+             m_assembler.ldrh(dest, memoryTempRegister, ARM64Registers::zr);</span>
<span class="udiff-line-added">+         else</span>
<span class="udiff-line-added">+             m_assembler.ldr&lt;datasize&gt;(dest, memoryTempRegister, ARM64Registers::zr);</span>
      }
  
      template&lt;int datasize&gt;
      ALWAYS_INLINE void store(RegisterID src, const void* address)
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4208,31 +4259,37 @@</span>
              intptr_t addressAsInt = reinterpret_cast&lt;intptr_t&gt;(address);
              intptr_t addressDelta = addressAsInt - currentRegisterContents;
  
              if (isInt&lt;32&gt;(addressDelta)) {
                  if (Assembler::canEncodeSImmOffset(addressDelta)) {
<span class="udiff-line-modified-removed">-                     m_assembler.stur&lt;datasize&gt;(src, memoryTempRegister, addressDelta);</span>
<span class="udiff-line-modified-added">+                     storeUnscaledImmediate&lt;datasize&gt;(src, memoryTempRegister, addressDelta);</span>
                      return;
                  }
  
                  if (Assembler::canEncodePImmOffset&lt;datasize&gt;(addressDelta)) {
<span class="udiff-line-modified-removed">-                     m_assembler.str&lt;datasize&gt;(src, memoryTempRegister, addressDelta);</span>
<span class="udiff-line-modified-added">+                     storeUnsignedImmediate&lt;datasize&gt;(src, memoryTempRegister, addressDelta);</span>
                      return;
                  }
              }
  
              if ((addressAsInt &amp; (~maskHalfWord0)) == (currentRegisterContents &amp; (~maskHalfWord0))) {
                  m_assembler.movk&lt;64&gt;(memoryTempRegister, addressAsInt &amp; maskHalfWord0, 0);
                  cachedMemoryTempRegister().setValue(reinterpret_cast&lt;intptr_t&gt;(address));
<span class="udiff-line-modified-removed">-                 m_assembler.str&lt;datasize&gt;(src, memoryTempRegister, ARM64Registers::zr);</span>
<span class="udiff-line-modified-added">+                 if constexpr (datasize == 16)</span>
<span class="udiff-line-added">+                     m_assembler.strh(src, memoryTempRegister, ARM64Registers::zr);</span>
<span class="udiff-line-added">+                 else</span>
<span class="udiff-line-added">+                     m_assembler.str&lt;datasize&gt;(src, memoryTempRegister, ARM64Registers::zr);</span>
                  return;
              }
          }
  
          move(TrustedImmPtr(address), memoryTempRegister);
          cachedMemoryTempRegister().setValue(reinterpret_cast&lt;intptr_t&gt;(address));
<span class="udiff-line-modified-removed">-         m_assembler.str&lt;datasize&gt;(src, memoryTempRegister, ARM64Registers::zr);</span>
<span class="udiff-line-modified-added">+         if constexpr (datasize == 16)</span>
<span class="udiff-line-added">+             m_assembler.strh(src, memoryTempRegister, ARM64Registers::zr);</span>
<span class="udiff-line-added">+         else</span>
<span class="udiff-line-added">+             m_assembler.str&lt;datasize&gt;(src, memoryTempRegister, ARM64Registers::zr);</span>
      }
  
      template &lt;int dataSize&gt;
      ALWAYS_INLINE bool tryMoveUsingCacheRegisterContents(intptr_t immediate, CachedTempRegister&amp; dest)
      {
</pre>
<center><a href="MacroAssembler.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MacroAssemblerARM64E.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
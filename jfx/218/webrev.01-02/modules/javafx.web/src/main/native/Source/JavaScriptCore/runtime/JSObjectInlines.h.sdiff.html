<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSObjectInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSPromise.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSObjectInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">  4  *  Copyright (C) 2003-2017 Apple Inc. All rights reserved.</span>
  5  *  Copyright (C) 2007 Eric Seidel (eric@webkit.org)
  6  *
  7  *  This library is free software; you can redistribute it and/or
  8  *  modify it under the terms of the GNU Library General Public
  9  *  License as published by the Free Software Foundation; either
 10  *  version 2 of the License, or (at your option) any later version.
 11  *
 12  *  This library is distributed in the hope that it will be useful,
 13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  *  Library General Public License for more details.
 16  *
 17  *  You should have received a copy of the GNU Library General Public License
 18  *  along with this library; see the file COPYING.LIB.  If not, write to
 19  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  *  Boston, MA 02110-1301, USA.
 21  *
 22  */
 23 
 24 #pragma once
 25 
 26 #include &quot;AuxiliaryBarrierInlines.h&quot;

 27 #include &quot;Error.h&quot;

 28 #include &quot;JSObject.h&quot;
 29 #include &quot;JSTypedArrays.h&quot;
 30 #include &quot;Lookup.h&quot;
 31 #include &quot;StructureInlines.h&quot;
 32 #include &quot;TypedArrayType.h&quot;
 33 
 34 namespace JSC {
 35 







 36 // Section 7.3.17 of the spec.
 37 template &lt;typename AddFunction&gt; // Add function should have a type like: (JSValue, RuntimeType) -&gt; bool
<span class="line-modified"> 38 void createListFromArrayLike(ExecState* exec, JSValue arrayLikeValue, RuntimeTypeMask legalTypesFilter, const String&amp; notAnObjectErroMessage, const String&amp; illegalTypeErrorMessage, AddFunction addFunction)</span>
 39 {
<span class="line-modified"> 40     VM&amp; vm = exec-&gt;vm();</span>
 41     auto scope = DECLARE_THROW_SCOPE(vm);
 42 
 43     if (!arrayLikeValue.isObject()) {
<span class="line-modified"> 44         throwTypeError(exec, scope, notAnObjectErroMessage);</span>
 45         return;
 46     }
 47 
 48     Vector&lt;JSValue&gt; result;
<span class="line-modified"> 49     JSValue lengthProperty = arrayLikeValue.get(exec, vm.propertyNames-&gt;length);</span>
 50     RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified"> 51     double lengthAsDouble = lengthProperty.toLength(exec);</span>
 52     RETURN_IF_EXCEPTION(scope, void());
 53     RELEASE_ASSERT(lengthAsDouble &gt;= 0.0 &amp;&amp; lengthAsDouble == std::trunc(lengthAsDouble));
 54     uint64_t length = static_cast&lt;uint64_t&gt;(lengthAsDouble);
 55     for (uint64_t index = 0; index &lt; length; index++) {
<span class="line-modified"> 56         JSValue next = arrayLikeValue.get(exec, index);</span>
 57         RETURN_IF_EXCEPTION(scope, void());
 58 
 59         RuntimeType type = runtimeTypeForValue(vm, next);
 60         if (!(type &amp; legalTypesFilter)) {
<span class="line-modified"> 61             throwTypeError(exec, scope, illegalTypeErrorMessage);</span>
 62             return;
 63         }
 64 
 65         bool exitEarly = addFunction(next, type);
 66         if (exitEarly)
 67             return;
 68     }
 69 }
 70 
 71 ALWAYS_INLINE bool JSObject::canPerformFastPutInlineExcludingProto(VM&amp; vm)
 72 {
 73     // Check if there are any setters or getters in the prototype chain
 74     JSValue prototype;
 75     JSObject* obj = this;
 76     while (true) {
 77         MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
 78         if (obj-&gt;structure(vm)-&gt;hasReadOnlyOrGetterSetterPropertiesExcludingProto() || obj-&gt;methodTable(vm)-&gt;getPrototype != defaultGetPrototype)
 79             return false;
 80 
 81         prototype = obj-&gt;getPrototypeDirect(vm);
 82         if (prototype.isNull())
 83             return true;
 84 
 85         obj = asObject(prototype);
 86     }
 87 
 88     ASSERT_NOT_REACHED();
 89 }
 90 
 91 ALWAYS_INLINE bool JSObject::canPerformFastPutInline(VM&amp; vm, PropertyName propertyName)
 92 {
 93     if (UNLIKELY(propertyName == vm.propertyNames-&gt;underscoreProto))
 94         return false;
 95     return canPerformFastPutInlineExcludingProto(vm);
 96 }
 97 
 98 template&lt;typename CallbackWhenNoException&gt;
<span class="line-modified"> 99 ALWAYS_INLINE typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type JSObject::getPropertySlot(ExecState* exec, PropertyName propertyName, CallbackWhenNoException callback) const</span>
100 {
101     PropertySlot slot(this, PropertySlot::InternalMethodType::Get);
<span class="line-modified">102     return getPropertySlot(exec, propertyName, slot, callback);</span>
103 }
104 
105 template&lt;typename CallbackWhenNoException&gt;
<span class="line-modified">106 ALWAYS_INLINE typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type JSObject::getPropertySlot(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot, CallbackWhenNoException callback) const</span>
107 {
<span class="line-modified">108     VM&amp; vm = exec-&gt;vm();</span>
109     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">110     bool found = const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(exec, propertyName, slot);</span>
111     RETURN_IF_EXCEPTION(scope, { });
112     RELEASE_AND_RETURN(scope, callback(found, slot));
113 }
114 
<span class="line-modified">115 ALWAYS_INLINE bool JSObject::getPropertySlot(ExecState* exec, unsigned propertyName, PropertySlot&amp; slot)</span>
116 {
<span class="line-modified">117     VM&amp; vm = exec-&gt;vm();</span>
118     auto scope = DECLARE_THROW_SCOPE(vm);
119     auto&amp; structureIDTable = vm.heap.structureIDTable();
120     JSObject* object = this;
121     MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
122     while (true) {
123         Structure* structure = structureIDTable.get(object-&gt;structureID());
<span class="line-modified">124         bool hasSlot = structure-&gt;classInfo()-&gt;methodTable.getOwnPropertySlotByIndex(object, exec, propertyName, slot);</span>
125         RETURN_IF_EXCEPTION(scope, false);
126         if (hasSlot)
127             return true;


128         JSValue prototype;
129         if (LIKELY(structure-&gt;classInfo()-&gt;methodTable.getPrototype == defaultGetPrototype || slot.internalMethodType() == PropertySlot::InternalMethodType::VMInquiry))
130             prototype = object-&gt;getPrototypeDirect(vm);
131         else {
<span class="line-modified">132             prototype = object-&gt;getPrototype(vm, exec);</span>
133             RETURN_IF_EXCEPTION(scope, false);
134         }
135         if (!prototype.isObject())
136             return false;
137         object = asObject(prototype);
138     }
139 }
140 
<span class="line-modified">141 ALWAYS_INLINE bool JSObject::getNonIndexPropertySlot(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
142 {
143     // This method only supports non-index PropertyNames.
144     ASSERT(!parseIndex(propertyName));
145 
<span class="line-modified">146     VM&amp; vm = exec-&gt;vm();</span>
147     auto scope = DECLARE_THROW_SCOPE(vm);
148     auto&amp; structureIDTable = vm.heap.structureIDTable();
149     JSObject* object = this;
150     MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
151     while (true) {
152         Structure* structure = structureIDTable.get(object-&gt;structureID());
153         if (LIKELY(!TypeInfo::overridesGetOwnPropertySlot(object-&gt;inlineTypeFlags()))) {
154             if (object-&gt;getOwnNonIndexPropertySlot(vm, structure, propertyName, slot))
155                 return true;
156         } else {
<span class="line-modified">157             bool hasSlot = structure-&gt;classInfo()-&gt;methodTable.getOwnPropertySlot(object, exec, propertyName, slot);</span>
158             RETURN_IF_EXCEPTION(scope, false);
159             if (hasSlot)
160                 return true;


161         }
162         JSValue prototype;
163         if (LIKELY(structure-&gt;classInfo()-&gt;methodTable.getPrototype == defaultGetPrototype || slot.internalMethodType() == PropertySlot::InternalMethodType::VMInquiry))
164             prototype = object-&gt;getPrototypeDirect(vm);
165         else {
<span class="line-modified">166             prototype = object-&gt;getPrototype(vm, exec);</span>
167             RETURN_IF_EXCEPTION(scope, false);
168         }
169         if (!prototype.isObject())
170             return false;
171         object = asObject(prototype);
172     }
173 }
174 
<span class="line-modified">175 inline bool JSObject::getOwnPropertySlotInline(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
176 {
<span class="line-modified">177     VM&amp; vm = exec-&gt;vm();</span>
178     if (UNLIKELY(TypeInfo::overridesGetOwnPropertySlot(inlineTypeFlags())))
<span class="line-modified">179         return methodTable(vm)-&gt;getOwnPropertySlot(this, exec, propertyName, slot);</span>
<span class="line-modified">180     return JSObject::getOwnPropertySlot(this, exec, propertyName, slot);</span>
181 }
182 
183 inline bool JSObject::mayInterceptIndexedAccesses(VM&amp; vm)
184 {
185     return structure(vm)-&gt;mayInterceptIndexedAccesses();
186 }
187 
188 inline void JSObject::putDirectWithoutTransition(VM&amp; vm, PropertyName propertyName, JSValue value, unsigned attributes)
189 {
190     ASSERT(!value.isGetterSetter() &amp;&amp; !(attributes &amp; PropertyAttribute::Accessor));
191     ASSERT(!value.isCustomGetterSetter());
192     StructureID structureID = this-&gt;structureID();
193     Structure* structure = vm.heap.structureIDTable().get(structureID);
194     PropertyOffset offset = prepareToPutDirectWithoutTransition(vm, propertyName, attributes, structureID, structure);
195     putDirect(vm, offset, value);
196     if (attributes &amp; PropertyAttribute::ReadOnly)
197         structure-&gt;setContainsReadOnlyProperties();
198 }
199 
200 ALWAYS_INLINE PropertyOffset JSObject::prepareToPutDirectWithoutTransition(VM&amp; vm, PropertyName propertyName, unsigned attributes, StructureID structureID, Structure* structure)
201 {
202     unsigned oldOutOfLineCapacity = structure-&gt;outOfLineCapacity();
203     PropertyOffset result;
204     structure-&gt;addPropertyWithoutTransition(
205         vm, propertyName, attributes,
<span class="line-modified">206         [&amp;] (const GCSafeConcurrentJSLocker&amp;, PropertyOffset offset, PropertyOffset newLastOffset) {</span>
<span class="line-modified">207             unsigned newOutOfLineCapacity = Structure::outOfLineCapacity(newLastOffset);</span>
208             if (newOutOfLineCapacity != oldOutOfLineCapacity) {
209                 Butterfly* butterfly = allocateMoreOutOfLineStorage(vm, oldOutOfLineCapacity, newOutOfLineCapacity);
210                 nukeStructureAndSetButterfly(vm, structureID, butterfly);
<span class="line-modified">211                 structure-&gt;setLastOffset(newLastOffset);</span>
212                 WTF::storeStoreFence();
213                 setStructureIDDirectly(structureID);
214             } else
<span class="line-modified">215                 structure-&gt;setLastOffset(newLastOffset);</span>
216 
217             // This assertion verifies that the concurrent GC won&#39;t read garbage if the concurrentGC
218             // is running at the same time we put without transitioning.
219             ASSERT(!getDirect(offset) || !JSValue::encode(getDirect(offset)));
220             result = offset;
221         });
222     return result;
223 }
224 
225 // ECMA 8.6.2.2
<span class="line-modified">226 ALWAYS_INLINE bool JSObject::putInlineForJSObject(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
227 {
<span class="line-modified">228     VM&amp; vm = exec-&gt;vm();</span>
229     auto scope = DECLARE_THROW_SCOPE(vm);
230 
231     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
232     ASSERT(value);
233     ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(thisObject));
234 
235     if (UNLIKELY(isThisValueAltered(slot, thisObject)))
<span class="line-modified">236         RELEASE_AND_RETURN(scope, ordinarySetSlow(exec, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode()));</span>
237 
238     // Try indexed put first. This is required for correctness, since loads on property names that appear like
239     // valid indices will never look in the named property storage.
240     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="line-modified">241         RELEASE_AND_RETURN(scope, putByIndex(thisObject, exec, index.value(), value, slot.isStrictMode()));</span>
242 
243     if (thisObject-&gt;canPerformFastPutInline(vm, propertyName)) {
244         ASSERT(!thisObject-&gt;prototypeChainMayInterceptStoreTo(vm, propertyName));
245         if (!thisObject-&gt;putDirectInternal&lt;PutModePut&gt;(vm, propertyName, value, 0, slot))
<span class="line-modified">246             return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);</span>
247         return true;
248     }
249 
<span class="line-modified">250     RELEASE_AND_RETURN(scope, thisObject-&gt;putInlineSlow(exec, propertyName, value, slot));</span>
251 }
252 
253 // HasOwnProperty(O, P) from section 7.3.11 in the spec.
254 // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-hasownproperty
<span class="line-modified">255 ALWAYS_INLINE bool JSObject::hasOwnProperty(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot) const</span>
256 {
<span class="line-modified">257     VM&amp; vm = exec-&gt;vm();</span>
258     ASSERT(slot.internalMethodType() == PropertySlot::InternalMethodType::GetOwnProperty);
259     if (LIKELY(const_cast&lt;JSObject*&gt;(this)-&gt;methodTable(vm)-&gt;getOwnPropertySlot == JSObject::getOwnPropertySlot))
<span class="line-modified">260         return JSObject::getOwnPropertySlot(const_cast&lt;JSObject*&gt;(this), exec, propertyName, slot);</span>
<span class="line-modified">261     return const_cast&lt;JSObject*&gt;(this)-&gt;methodTable(vm)-&gt;getOwnPropertySlot(const_cast&lt;JSObject*&gt;(this), exec, propertyName, slot);</span>
262 }
263 
<span class="line-modified">264 ALWAYS_INLINE bool JSObject::hasOwnProperty(ExecState* exec, PropertyName propertyName) const</span>
265 {
266     PropertySlot slot(this, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">267     return hasOwnProperty(exec, propertyName, slot);</span>
268 }
269 
<span class="line-modified">270 ALWAYS_INLINE bool JSObject::hasOwnProperty(ExecState* exec, unsigned propertyName) const</span>
271 {
272     PropertySlot slot(this, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">273     return const_cast&lt;JSObject*&gt;(this)-&gt;methodTable(exec-&gt;vm())-&gt;getOwnPropertySlotByIndex(const_cast&lt;JSObject*&gt;(this), exec, propertyName, slot);</span>
274 }
275 
276 template&lt;JSObject::PutMode mode&gt;
277 ALWAYS_INLINE bool JSObject::putDirectInternal(VM&amp; vm, PropertyName propertyName, JSValue value, unsigned attributes, PutPropertySlot&amp; slot)
278 {
279     ASSERT(value);
280     ASSERT(value.isGetterSetter() == !!(attributes &amp; PropertyAttribute::Accessor));
281     ASSERT(value.isCustomGetterSetter() == !!(attributes &amp; PropertyAttribute::CustomAccessorOrValue));
282     ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(this));
283     ASSERT(!parseIndex(propertyName));
284 
285     StructureID structureID = this-&gt;structureID();
286     Structure* structure = vm.heap.structureIDTable().get(structureID);
287     if (structure-&gt;isDictionary()) {
288         ASSERT(!isCopyOnWrite(indexingMode()));
289 
290         unsigned currentAttributes;
291         PropertyOffset offset = structure-&gt;get(vm, propertyName, currentAttributes);
292         if (offset != invalidOffset) {
293             if ((mode == PutModePut) &amp;&amp; currentAttributes &amp; PropertyAttribute::ReadOnly)
</pre>
<hr />
<pre>
445 }
446 
447 inline void JSObject::setIndexQuicklyForTypedArray(unsigned i, JSValue value)
448 {
449     switch (type()) {
450 #define CASE_TYPED_ARRAY_TYPE(name) \
451     case name ## ArrayType : {\
452         auto* typedArray = jsCast&lt;JS ## name ## Array *&gt;(this);\
453         RELEASE_ASSERT(typedArray-&gt;canSetIndexQuickly(i, value));\
454         typedArray-&gt;setIndexQuickly(i, value);\
455         break;\
456     }
457         FOR_EACH_TYPED_ARRAY_TYPE_EXCLUDING_DATA_VIEW(CASE_TYPED_ARRAY_TYPE)
458 #undef CASE_TYPED_ARRAY_TYPE
459     default:
460         RELEASE_ASSERT_NOT_REACHED();
461         return;
462     }
463 }
464 



























































465 
466 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">  4  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.</span>
  5  *  Copyright (C) 2007 Eric Seidel (eric@webkit.org)
  6  *
  7  *  This library is free software; you can redistribute it and/or
  8  *  modify it under the terms of the GNU Library General Public
  9  *  License as published by the Free Software Foundation; either
 10  *  version 2 of the License, or (at your option) any later version.
 11  *
 12  *  This library is distributed in the hope that it will be useful,
 13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  *  Library General Public License for more details.
 16  *
 17  *  You should have received a copy of the GNU Library General Public License
 18  *  along with this library; see the file COPYING.LIB.  If not, write to
 19  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  *  Boston, MA 02110-1301, USA.
 21  *
 22  */
 23 
 24 #pragma once
 25 
 26 #include &quot;AuxiliaryBarrierInlines.h&quot;
<span class="line-added"> 27 #include &quot;ButterflyInlines.h&quot;</span>
 28 #include &quot;Error.h&quot;
<span class="line-added"> 29 #include &quot;JSFunction.h&quot;</span>
 30 #include &quot;JSObject.h&quot;
 31 #include &quot;JSTypedArrays.h&quot;
 32 #include &quot;Lookup.h&quot;
 33 #include &quot;StructureInlines.h&quot;
 34 #include &quot;TypedArrayType.h&quot;
 35 
 36 namespace JSC {
 37 
<span class="line-added"> 38 template&lt;typename CellType, SubspaceAccess&gt;</span>
<span class="line-added"> 39 CompleteSubspace* JSObject::subspaceFor(VM&amp; vm)</span>
<span class="line-added"> 40 {</span>
<span class="line-added"> 41     static_assert(!CellType::needsDestruction);</span>
<span class="line-added"> 42     return &amp;vm.cellSpace;</span>
<span class="line-added"> 43 }</span>
<span class="line-added"> 44 </span>
 45 // Section 7.3.17 of the spec.
 46 template &lt;typename AddFunction&gt; // Add function should have a type like: (JSValue, RuntimeType) -&gt; bool
<span class="line-modified"> 47 void createListFromArrayLike(JSGlobalObject* globalObject, JSValue arrayLikeValue, RuntimeTypeMask legalTypesFilter, const String&amp; notAnObjectErroMessage, const String&amp; illegalTypeErrorMessage, AddFunction addFunction)</span>
 48 {
<span class="line-modified"> 49     VM&amp; vm = getVM(globalObject);</span>
 50     auto scope = DECLARE_THROW_SCOPE(vm);
 51 
 52     if (!arrayLikeValue.isObject()) {
<span class="line-modified"> 53         throwTypeError(globalObject, scope, notAnObjectErroMessage);</span>
 54         return;
 55     }
 56 
 57     Vector&lt;JSValue&gt; result;
<span class="line-modified"> 58     JSValue lengthProperty = arrayLikeValue.get(globalObject, vm.propertyNames-&gt;length);</span>
 59     RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified"> 60     double lengthAsDouble = lengthProperty.toLength(globalObject);</span>
 61     RETURN_IF_EXCEPTION(scope, void());
 62     RELEASE_ASSERT(lengthAsDouble &gt;= 0.0 &amp;&amp; lengthAsDouble == std::trunc(lengthAsDouble));
 63     uint64_t length = static_cast&lt;uint64_t&gt;(lengthAsDouble);
 64     for (uint64_t index = 0; index &lt; length; index++) {
<span class="line-modified"> 65         JSValue next = arrayLikeValue.get(globalObject, index);</span>
 66         RETURN_IF_EXCEPTION(scope, void());
 67 
 68         RuntimeType type = runtimeTypeForValue(vm, next);
 69         if (!(type &amp; legalTypesFilter)) {
<span class="line-modified"> 70             throwTypeError(globalObject, scope, illegalTypeErrorMessage);</span>
 71             return;
 72         }
 73 
 74         bool exitEarly = addFunction(next, type);
 75         if (exitEarly)
 76             return;
 77     }
 78 }
 79 
 80 ALWAYS_INLINE bool JSObject::canPerformFastPutInlineExcludingProto(VM&amp; vm)
 81 {
 82     // Check if there are any setters or getters in the prototype chain
 83     JSValue prototype;
 84     JSObject* obj = this;
 85     while (true) {
 86         MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
 87         if (obj-&gt;structure(vm)-&gt;hasReadOnlyOrGetterSetterPropertiesExcludingProto() || obj-&gt;methodTable(vm)-&gt;getPrototype != defaultGetPrototype)
 88             return false;
 89 
 90         prototype = obj-&gt;getPrototypeDirect(vm);
 91         if (prototype.isNull())
 92             return true;
 93 
 94         obj = asObject(prototype);
 95     }
 96 
 97     ASSERT_NOT_REACHED();
 98 }
 99 
100 ALWAYS_INLINE bool JSObject::canPerformFastPutInline(VM&amp; vm, PropertyName propertyName)
101 {
102     if (UNLIKELY(propertyName == vm.propertyNames-&gt;underscoreProto))
103         return false;
104     return canPerformFastPutInlineExcludingProto(vm);
105 }
106 
107 template&lt;typename CallbackWhenNoException&gt;
<span class="line-modified">108 ALWAYS_INLINE typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type JSObject::getPropertySlot(JSGlobalObject* globalObject, PropertyName propertyName, CallbackWhenNoException callback) const</span>
109 {
110     PropertySlot slot(this, PropertySlot::InternalMethodType::Get);
<span class="line-modified">111     return getPropertySlot(globalObject, propertyName, slot, callback);</span>
112 }
113 
114 template&lt;typename CallbackWhenNoException&gt;
<span class="line-modified">115 ALWAYS_INLINE typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type JSObject::getPropertySlot(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot, CallbackWhenNoException callback) const</span>
116 {
<span class="line-modified">117     VM&amp; vm = getVM(globalObject);</span>
118     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">119     bool found = const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(globalObject, propertyName, slot);</span>
120     RETURN_IF_EXCEPTION(scope, { });
121     RELEASE_AND_RETURN(scope, callback(found, slot));
122 }
123 
<span class="line-modified">124 ALWAYS_INLINE bool JSObject::getPropertySlot(JSGlobalObject* globalObject, unsigned propertyName, PropertySlot&amp; slot)</span>
125 {
<span class="line-modified">126     VM&amp; vm = getVM(globalObject);</span>
127     auto scope = DECLARE_THROW_SCOPE(vm);
128     auto&amp; structureIDTable = vm.heap.structureIDTable();
129     JSObject* object = this;
130     MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
131     while (true) {
132         Structure* structure = structureIDTable.get(object-&gt;structureID());
<span class="line-modified">133         bool hasSlot = structure-&gt;classInfo()-&gt;methodTable.getOwnPropertySlotByIndex(object, globalObject, propertyName, slot);</span>
134         RETURN_IF_EXCEPTION(scope, false);
135         if (hasSlot)
136             return true;
<span class="line-added">137         if (object-&gt;type() == ProxyObjectType &amp;&amp; slot.internalMethodType() == PropertySlot::InternalMethodType::HasProperty)</span>
<span class="line-added">138             return false;</span>
139         JSValue prototype;
140         if (LIKELY(structure-&gt;classInfo()-&gt;methodTable.getPrototype == defaultGetPrototype || slot.internalMethodType() == PropertySlot::InternalMethodType::VMInquiry))
141             prototype = object-&gt;getPrototypeDirect(vm);
142         else {
<span class="line-modified">143             prototype = object-&gt;getPrototype(vm, globalObject);</span>
144             RETURN_IF_EXCEPTION(scope, false);
145         }
146         if (!prototype.isObject())
147             return false;
148         object = asObject(prototype);
149     }
150 }
151 
<span class="line-modified">152 ALWAYS_INLINE bool JSObject::getNonIndexPropertySlot(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
153 {
154     // This method only supports non-index PropertyNames.
155     ASSERT(!parseIndex(propertyName));
156 
<span class="line-modified">157     VM&amp; vm = getVM(globalObject);</span>
158     auto scope = DECLARE_THROW_SCOPE(vm);
159     auto&amp; structureIDTable = vm.heap.structureIDTable();
160     JSObject* object = this;
161     MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
162     while (true) {
163         Structure* structure = structureIDTable.get(object-&gt;structureID());
164         if (LIKELY(!TypeInfo::overridesGetOwnPropertySlot(object-&gt;inlineTypeFlags()))) {
165             if (object-&gt;getOwnNonIndexPropertySlot(vm, structure, propertyName, slot))
166                 return true;
167         } else {
<span class="line-modified">168             bool hasSlot = structure-&gt;classInfo()-&gt;methodTable.getOwnPropertySlot(object, globalObject, propertyName, slot);</span>
169             RETURN_IF_EXCEPTION(scope, false);
170             if (hasSlot)
171                 return true;
<span class="line-added">172             if (object-&gt;type() == ProxyObjectType &amp;&amp; slot.internalMethodType() == PropertySlot::InternalMethodType::HasProperty)</span>
<span class="line-added">173                 return false;</span>
174         }
175         JSValue prototype;
176         if (LIKELY(structure-&gt;classInfo()-&gt;methodTable.getPrototype == defaultGetPrototype || slot.internalMethodType() == PropertySlot::InternalMethodType::VMInquiry))
177             prototype = object-&gt;getPrototypeDirect(vm);
178         else {
<span class="line-modified">179             prototype = object-&gt;getPrototype(vm, globalObject);</span>
180             RETURN_IF_EXCEPTION(scope, false);
181         }
182         if (!prototype.isObject())
183             return false;
184         object = asObject(prototype);
185     }
186 }
187 
<span class="line-modified">188 inline bool JSObject::getOwnPropertySlotInline(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
189 {
<span class="line-modified">190     VM&amp; vm = getVM(globalObject);</span>
191     if (UNLIKELY(TypeInfo::overridesGetOwnPropertySlot(inlineTypeFlags())))
<span class="line-modified">192         return methodTable(vm)-&gt;getOwnPropertySlot(this, globalObject, propertyName, slot);</span>
<span class="line-modified">193     return JSObject::getOwnPropertySlot(this, globalObject, propertyName, slot);</span>
194 }
195 
196 inline bool JSObject::mayInterceptIndexedAccesses(VM&amp; vm)
197 {
198     return structure(vm)-&gt;mayInterceptIndexedAccesses();
199 }
200 
201 inline void JSObject::putDirectWithoutTransition(VM&amp; vm, PropertyName propertyName, JSValue value, unsigned attributes)
202 {
203     ASSERT(!value.isGetterSetter() &amp;&amp; !(attributes &amp; PropertyAttribute::Accessor));
204     ASSERT(!value.isCustomGetterSetter());
205     StructureID structureID = this-&gt;structureID();
206     Structure* structure = vm.heap.structureIDTable().get(structureID);
207     PropertyOffset offset = prepareToPutDirectWithoutTransition(vm, propertyName, attributes, structureID, structure);
208     putDirect(vm, offset, value);
209     if (attributes &amp; PropertyAttribute::ReadOnly)
210         structure-&gt;setContainsReadOnlyProperties();
211 }
212 
213 ALWAYS_INLINE PropertyOffset JSObject::prepareToPutDirectWithoutTransition(VM&amp; vm, PropertyName propertyName, unsigned attributes, StructureID structureID, Structure* structure)
214 {
215     unsigned oldOutOfLineCapacity = structure-&gt;outOfLineCapacity();
216     PropertyOffset result;
217     structure-&gt;addPropertyWithoutTransition(
218         vm, propertyName, attributes,
<span class="line-modified">219         [&amp;] (const GCSafeConcurrentJSLocker&amp;, PropertyOffset offset, PropertyOffset newMaxOffset) {</span>
<span class="line-modified">220             unsigned newOutOfLineCapacity = Structure::outOfLineCapacity(newMaxOffset);</span>
221             if (newOutOfLineCapacity != oldOutOfLineCapacity) {
222                 Butterfly* butterfly = allocateMoreOutOfLineStorage(vm, oldOutOfLineCapacity, newOutOfLineCapacity);
223                 nukeStructureAndSetButterfly(vm, structureID, butterfly);
<span class="line-modified">224                 structure-&gt;setMaxOffset(vm, newMaxOffset);</span>
225                 WTF::storeStoreFence();
226                 setStructureIDDirectly(structureID);
227             } else
<span class="line-modified">228                 structure-&gt;setMaxOffset(vm, newMaxOffset);</span>
229 
230             // This assertion verifies that the concurrent GC won&#39;t read garbage if the concurrentGC
231             // is running at the same time we put without transitioning.
232             ASSERT(!getDirect(offset) || !JSValue::encode(getDirect(offset)));
233             result = offset;
234         });
235     return result;
236 }
237 
238 // ECMA 8.6.2.2
<span class="line-modified">239 ALWAYS_INLINE bool JSObject::putInlineForJSObject(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
240 {
<span class="line-modified">241     VM&amp; vm = getVM(globalObject);</span>
242     auto scope = DECLARE_THROW_SCOPE(vm);
243 
244     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
245     ASSERT(value);
246     ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(thisObject));
247 
248     if (UNLIKELY(isThisValueAltered(slot, thisObject)))
<span class="line-modified">249         RELEASE_AND_RETURN(scope, ordinarySetSlow(globalObject, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode()));</span>
250 
251     // Try indexed put first. This is required for correctness, since loads on property names that appear like
252     // valid indices will never look in the named property storage.
253     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="line-modified">254         RELEASE_AND_RETURN(scope, putByIndex(thisObject, globalObject, index.value(), value, slot.isStrictMode()));</span>
255 
256     if (thisObject-&gt;canPerformFastPutInline(vm, propertyName)) {
257         ASSERT(!thisObject-&gt;prototypeChainMayInterceptStoreTo(vm, propertyName));
258         if (!thisObject-&gt;putDirectInternal&lt;PutModePut&gt;(vm, propertyName, value, 0, slot))
<span class="line-modified">259             return typeError(globalObject, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);</span>
260         return true;
261     }
262 
<span class="line-modified">263     RELEASE_AND_RETURN(scope, thisObject-&gt;putInlineSlow(globalObject, propertyName, value, slot));</span>
264 }
265 
266 // HasOwnProperty(O, P) from section 7.3.11 in the spec.
267 // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-hasownproperty
<span class="line-modified">268 ALWAYS_INLINE bool JSObject::hasOwnProperty(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot) const</span>
269 {
<span class="line-modified">270     VM&amp; vm = getVM(globalObject);</span>
271     ASSERT(slot.internalMethodType() == PropertySlot::InternalMethodType::GetOwnProperty);
272     if (LIKELY(const_cast&lt;JSObject*&gt;(this)-&gt;methodTable(vm)-&gt;getOwnPropertySlot == JSObject::getOwnPropertySlot))
<span class="line-modified">273         return JSObject::getOwnPropertySlot(const_cast&lt;JSObject*&gt;(this), globalObject, propertyName, slot);</span>
<span class="line-modified">274     return const_cast&lt;JSObject*&gt;(this)-&gt;methodTable(vm)-&gt;getOwnPropertySlot(const_cast&lt;JSObject*&gt;(this), globalObject, propertyName, slot);</span>
275 }
276 
<span class="line-modified">277 ALWAYS_INLINE bool JSObject::hasOwnProperty(JSGlobalObject* globalObject, PropertyName propertyName) const</span>
278 {
279     PropertySlot slot(this, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">280     return hasOwnProperty(globalObject, propertyName, slot);</span>
281 }
282 
<span class="line-modified">283 ALWAYS_INLINE bool JSObject::hasOwnProperty(JSGlobalObject* globalObject, unsigned propertyName) const</span>
284 {
285     PropertySlot slot(this, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">286     return const_cast&lt;JSObject*&gt;(this)-&gt;methodTable(getVM(globalObject))-&gt;getOwnPropertySlotByIndex(const_cast&lt;JSObject*&gt;(this), globalObject, propertyName, slot);</span>
287 }
288 
289 template&lt;JSObject::PutMode mode&gt;
290 ALWAYS_INLINE bool JSObject::putDirectInternal(VM&amp; vm, PropertyName propertyName, JSValue value, unsigned attributes, PutPropertySlot&amp; slot)
291 {
292     ASSERT(value);
293     ASSERT(value.isGetterSetter() == !!(attributes &amp; PropertyAttribute::Accessor));
294     ASSERT(value.isCustomGetterSetter() == !!(attributes &amp; PropertyAttribute::CustomAccessorOrValue));
295     ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(this));
296     ASSERT(!parseIndex(propertyName));
297 
298     StructureID structureID = this-&gt;structureID();
299     Structure* structure = vm.heap.structureIDTable().get(structureID);
300     if (structure-&gt;isDictionary()) {
301         ASSERT(!isCopyOnWrite(indexingMode()));
302 
303         unsigned currentAttributes;
304         PropertyOffset offset = structure-&gt;get(vm, propertyName, currentAttributes);
305         if (offset != invalidOffset) {
306             if ((mode == PutModePut) &amp;&amp; currentAttributes &amp; PropertyAttribute::ReadOnly)
</pre>
<hr />
<pre>
458 }
459 
460 inline void JSObject::setIndexQuicklyForTypedArray(unsigned i, JSValue value)
461 {
462     switch (type()) {
463 #define CASE_TYPED_ARRAY_TYPE(name) \
464     case name ## ArrayType : {\
465         auto* typedArray = jsCast&lt;JS ## name ## Array *&gt;(this);\
466         RELEASE_ASSERT(typedArray-&gt;canSetIndexQuickly(i, value));\
467         typedArray-&gt;setIndexQuickly(i, value);\
468         break;\
469     }
470         FOR_EACH_TYPED_ARRAY_TYPE_EXCLUDING_DATA_VIEW(CASE_TYPED_ARRAY_TYPE)
471 #undef CASE_TYPED_ARRAY_TYPE
472     default:
473         RELEASE_ASSERT_NOT_REACHED();
474         return;
475     }
476 }
477 
<span class="line-added">478 inline void JSObject::validatePutOwnDataProperty(VM&amp; vm, PropertyName propertyName, JSValue value)</span>
<span class="line-added">479 {</span>
<span class="line-added">480 #if ASSERT_ENABLED</span>
<span class="line-added">481     ASSERT(value);</span>
<span class="line-added">482     ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(this));</span>
<span class="line-added">483     unsigned attributes;</span>
<span class="line-added">484     PropertyOffset offset = structure(vm)-&gt;get(vm, propertyName, attributes);</span>
<span class="line-added">485     if (isValidOffset(offset))</span>
<span class="line-added">486         ASSERT(!(attributes &amp; (PropertyAttribute::Accessor | PropertyAttribute::CustomAccessor | PropertyAttribute::ReadOnly)));</span>
<span class="line-added">487     else if (TypeInfo::hasStaticPropertyTable(inlineTypeFlags())) {</span>
<span class="line-added">488         if (auto entry = findPropertyHashEntry(vm, propertyName))</span>
<span class="line-added">489             ASSERT(!(entry-&gt;value-&gt;attributes() &amp; (PropertyAttribute::Accessor | PropertyAttribute::CustomAccessor | PropertyAttribute::ReadOnly)));</span>
<span class="line-added">490     }</span>
<span class="line-added">491 #else // not ASSERT_ENABLED</span>
<span class="line-added">492     UNUSED_PARAM(vm);</span>
<span class="line-added">493     UNUSED_PARAM(propertyName);</span>
<span class="line-added">494     UNUSED_PARAM(value);</span>
<span class="line-added">495 #endif // not ASSERT_ENABLED</span>
<span class="line-added">496 }</span>
<span class="line-added">497 </span>
<span class="line-added">498 inline bool JSObject::putOwnDataProperty(VM&amp; vm, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
<span class="line-added">499 {</span>
<span class="line-added">500     validatePutOwnDataProperty(vm, propertyName, value);</span>
<span class="line-added">501     return putDirectInternal&lt;PutModePut&gt;(vm, propertyName, value, 0, slot);</span>
<span class="line-added">502 }</span>
<span class="line-added">503 </span>
<span class="line-added">504 inline bool JSObject::putOwnDataPropertyMayBeIndex(JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
<span class="line-added">505 {</span>
<span class="line-added">506     VM&amp; vm = getVM(globalObject);</span>
<span class="line-added">507     validatePutOwnDataProperty(vm, propertyName, value);</span>
<span class="line-added">508     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))</span>
<span class="line-added">509         return putDirectIndex(globalObject, index.value(), value, 0, PutDirectIndexLikePutDirect);</span>
<span class="line-added">510 </span>
<span class="line-added">511     return putDirectInternal&lt;PutModePut&gt;(vm, propertyName, value, 0, slot);</span>
<span class="line-added">512 }</span>
<span class="line-added">513 </span>
<span class="line-added">514 inline CallType getCallData(VM&amp; vm, JSValue value, CallData&amp; callData)</span>
<span class="line-added">515 {</span>
<span class="line-added">516     if (!value.isCell())</span>
<span class="line-added">517         return CallType::None;</span>
<span class="line-added">518     JSCell* cell = value.asCell();</span>
<span class="line-added">519     if (cell-&gt;type() == JSFunctionType)</span>
<span class="line-added">520         return JSFunction::getCallData(cell, callData);</span>
<span class="line-added">521     CallType result = cell-&gt;methodTable(vm)-&gt;getCallData(cell, callData);</span>
<span class="line-added">522     ASSERT(result == CallType::None || value.isValidCallee());</span>
<span class="line-added">523     return result;</span>
<span class="line-added">524 }</span>
<span class="line-added">525 </span>
<span class="line-added">526 inline ConstructType getConstructData(VM&amp; vm, JSValue value, ConstructData&amp; constructData)</span>
<span class="line-added">527 {</span>
<span class="line-added">528     if (!value.isCell())</span>
<span class="line-added">529         return ConstructType::None;</span>
<span class="line-added">530     JSCell* cell = value.asCell();</span>
<span class="line-added">531     if (cell-&gt;type() == JSFunctionType)</span>
<span class="line-added">532         return JSFunction::getConstructData(cell, constructData);</span>
<span class="line-added">533     ConstructType result = cell-&gt;methodTable(vm)-&gt;getConstructData(cell, constructData);</span>
<span class="line-added">534     ASSERT(result == ConstructType::None || value.isValidCallee());</span>
<span class="line-added">535     return result;</span>
<span class="line-added">536 }</span>
537 
538 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="JSObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSPromise.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingTree.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2012-2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ScrollingTree.h&quot;
 28 
 29 #if ENABLE(ASYNC_SCROLLING)
 30 
 31 #include &quot;EventNames.h&quot;
 32 #include &quot;Logging.h&quot;
 33 #include &quot;PlatformWheelEvent.h&quot;
 34 #include &quot;ScrollingStateFrameScrollingNode.h&quot;
 35 #include &quot;ScrollingStateTree.h&quot;
 36 #include &quot;ScrollingTreeFrameScrollingNode.h&quot;
 37 #include &quot;ScrollingTreeNode.h&quot;
 38 #include &quot;ScrollingTreeOverflowScrollProxyNode.h&quot;
 39 #include &quot;ScrollingTreeOverflowScrollingNode.h&quot;
 40 #include &quot;ScrollingTreePositionedNode.h&quot;
 41 #include &quot;ScrollingTreeScrollingNode.h&quot;
 42 #include &lt;wtf/SetForScope.h&gt;
 43 #include &lt;wtf/text/TextStream.h&gt;
 44 
 45 namespace WebCore {
 46 
 47 ScrollingTree::ScrollingTree() = default;
 48 
 49 ScrollingTree::~ScrollingTree() = default;
 50 
 51 bool ScrollingTree::shouldHandleWheelEventSynchronously(const PlatformWheelEvent&amp; wheelEvent)
 52 {
 53     // This method is invoked by the event handling thread
 54     LockHolder lock(m_treeStateMutex);
 55 
 56     bool shouldSetLatch = wheelEvent.shouldConsiderLatching();
 57 
 58     if (hasLatchedNode() &amp;&amp; !shouldSetLatch)
 59         return false;
 60 
 61     if (shouldSetLatch)
 62         m_treeState.latchedNodeID = 0;
 63 
 64     if (!m_treeState.eventTrackingRegions.isEmpty() &amp;&amp; m_rootNode) {
 65         FloatPoint position = wheelEvent.position();
 66         position.move(m_rootNode-&gt;viewToContentsOffset(m_treeState.mainFrameScrollPosition));
 67 
 68         const EventNames&amp; names = eventNames();
 69         IntPoint roundedPosition = roundedIntPoint(position);
 70 
 71         // Event regions are affected by page scale, so no need to map through scale.
 72         bool isSynchronousDispatchRegion = m_treeState.eventTrackingRegions.trackingTypeForPoint(names.wheelEvent, roundedPosition) == TrackingType::Synchronous
 73             || m_treeState.eventTrackingRegions.trackingTypeForPoint(names.mousewheelEvent, roundedPosition) == TrackingType::Synchronous;
<a name="1" id="anc1"></a><span class="line-modified"> 74         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;\n\nScrollingTree::shouldHandleWheelEventSynchronously: wheelEvent &quot; &lt;&lt; wheelEvent &lt;&lt; &quot; mapped to content point &quot; &lt;&lt; position &lt;&lt; &quot;, in non-fast region &quot; &lt;&lt; isSynchronousDispatchRegion);</span>
 75 
 76         if (isSynchronousDispatchRegion)
 77             return true;
 78     }
 79     return false;
 80 }
 81 
 82 void ScrollingTree::setOrClearLatchedNode(const PlatformWheelEvent&amp; wheelEvent, ScrollingNodeID nodeID)
 83 {
 84     if (wheelEvent.shouldConsiderLatching()) {
 85         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollingTree &quot; &lt;&lt; this &lt;&lt; &quot; setOrClearLatchedNode: setting latched node &quot; &lt;&lt; nodeID);
 86         setLatchedNode(nodeID);
 87     } else if (wheelEvent.shouldResetLatching()) {
 88         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollingTree &quot; &lt;&lt; this &lt;&lt; &quot; setOrClearLatchedNode: clearing latched node (was &quot; &lt;&lt; latchedNode() &lt;&lt; &quot;)&quot;);
 89         clearLatchedNode();
 90     }
 91 }
 92 
 93 ScrollingEventResult ScrollingTree::handleWheelEvent(const PlatformWheelEvent&amp; wheelEvent)
 94 {
 95     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollingTree &quot; &lt;&lt; this &lt;&lt; &quot; handleWheelEvent (async scrolling enabled: &quot; &lt;&lt; asyncFrameOrOverflowScrollingEnabled() &lt;&lt; &quot;)&quot;);
 96 
 97     LockHolder locker(m_treeMutex);
 98 
 99     if (!asyncFrameOrOverflowScrollingEnabled()) {
100         if (m_rootNode)
101             m_rootNode-&gt;handleWheelEvent(wheelEvent);
102         return ScrollingEventResult::DidNotHandleEvent;
103     }
104 
105     if (hasLatchedNode()) {
106         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot; has latched node &quot; &lt;&lt; latchedNode());
107         auto* node = nodeForID(latchedNode());
108         if (is&lt;ScrollingTreeScrollingNode&gt;(node))
109             return downcast&lt;ScrollingTreeScrollingNode&gt;(*node).handleWheelEvent(wheelEvent);
110     }
111 
112     if (m_rootNode) {
113         FloatPoint position = wheelEvent.position();
114         ScrollingTreeNode* node = m_rootNode-&gt;scrollingNodeForPoint(LayoutPoint(position));
115 
116         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollingTree::handleWheelEvent found node &quot; &lt;&lt; (node ? node-&gt;scrollingNodeID() : 0) &lt;&lt; &quot; for point &quot; &lt;&lt; position &lt;&lt; &quot;\n&quot;);
117 
118         while (node) {
119             if (is&lt;ScrollingTreeScrollingNode&gt;(*node)) {
120                 auto&amp; scrollingNode = downcast&lt;ScrollingTreeScrollingNode&gt;(*node);
121                 // FIXME: this needs to consult latching logic.
122                 if (scrollingNode.handleWheelEvent(wheelEvent) == ScrollingEventResult::DidHandleEvent)
123                     return ScrollingEventResult::DidHandleEvent;
124             }
125             node = node-&gt;parent();
126         }
127     }
128     return ScrollingEventResult::DidNotHandleEvent;
129 }
130 
131 void ScrollingTree::mainFrameViewportChangedViaDelegatedScrolling(const FloatPoint&amp; scrollPosition, const FloatRect&amp; layoutViewport, double)
132 {
133     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollingTree::viewportChangedViaDelegatedScrolling - layoutViewport &quot; &lt;&lt; layoutViewport);
134 
135     if (!m_rootNode)
136         return;
137 
138     m_rootNode-&gt;wasScrolledByDelegatedScrolling(scrollPosition, layoutViewport);
139 }
140 
141 void ScrollingTree::commitTreeState(std::unique_ptr&lt;ScrollingStateTree&gt; scrollingStateTree)
142 {
<a name="2" id="anc2"></a><span class="line-added">143     SetForScope&lt;bool&gt; inCommitTreeState(m_inCommitTreeState, true);</span>
144     LockHolder locker(m_treeMutex);
145 
146     bool rootStateNodeChanged = scrollingStateTree-&gt;hasNewRootStateNode();
147 
148     LOG(Scrolling, &quot;\nScrollingTree %p commitTreeState&quot;, this);
149 
150     auto* rootNode = scrollingStateTree-&gt;rootStateNode();
151     if (rootNode
152         &amp;&amp; (rootStateNodeChanged
153             || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::EventTrackingRegion)
154             || rootNode-&gt;hasChangedProperty(ScrollingStateScrollingNode::ScrolledContentsLayer)
<a name="3" id="anc3"></a><span class="line-modified">155             || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::AsyncFrameOrOverflowScrollingEnabled)</span>
<span class="line-added">156             || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::IsMonitoringWheelEvents))) {</span>
157         LockHolder lock(m_treeStateMutex);
158 
159         if (rootStateNodeChanged || rootNode-&gt;hasChangedProperty(ScrollingStateScrollingNode::ScrolledContentsLayer))
160             m_treeState.mainFrameScrollPosition = { };
161 
162         if (rootStateNodeChanged || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::EventTrackingRegion))
163             m_treeState.eventTrackingRegions = scrollingStateTree-&gt;rootStateNode()-&gt;eventTrackingRegions();
164 
165         if (rootStateNodeChanged || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::AsyncFrameOrOverflowScrollingEnabled))
166             m_asyncFrameOrOverflowScrollingEnabled = scrollingStateTree-&gt;rootStateNode()-&gt;asyncFrameOrOverflowScrollingEnabled();
<a name="4" id="anc4"></a><span class="line-added">167 </span>
<span class="line-added">168         if (rootStateNodeChanged || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::IsMonitoringWheelEvents))</span>
<span class="line-added">169             m_isMonitoringWheelEvents = scrollingStateTree-&gt;rootStateNode()-&gt;isMonitoringWheelEvents();</span>
170     }
171 
172     // unvisitedNodes starts with all nodes in the map; we remove nodes as we visit them. At the end, it&#39;s the unvisited nodes.
173     // We can&#39;t use orphanNodes for this, because orphanNodes won&#39;t contain descendants of removed nodes.
174     HashSet&lt;ScrollingNodeID&gt; unvisitedNodes;
175     for (auto nodeID : m_nodeMap.keys())
176         unvisitedNodes.add(nodeID);
177 
178     m_overflowRelatedNodesMap.clear();
179     m_activeOverflowScrollProxyNodes.clear();
180     m_activePositionedNodes.clear();
181 
182     // orphanNodes keeps child nodes alive while we rebuild child lists.
183     OrphanScrollingNodeMap orphanNodes;
184     updateTreeFromStateNode(rootNode, orphanNodes, unvisitedNodes);
185 
186     for (auto nodeID : unvisitedNodes) {
187         if (nodeID == m_treeState.latchedNodeID)
188             clearLatchedNode();
189 
190         LOG(Scrolling, &quot;ScrollingTree::commitTreeState - removing unvisited node %&quot; PRIu64, nodeID);
191         m_nodeMap.remove(nodeID);
192     }
193 
194     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;committed ScrollingTree&quot; &lt;&lt; scrollingTreeAsText(ScrollingStateTreeAsTextBehaviorDebug));
195 }
196 
197 void ScrollingTree::updateTreeFromStateNode(const ScrollingStateNode* stateNode, OrphanScrollingNodeMap&amp; orphanNodes, HashSet&lt;ScrollingNodeID&gt;&amp; unvisitedNodes)
198 {
199     if (!stateNode) {
200         m_nodeMap.clear();
201         m_rootNode = nullptr;
202         return;
203     }
204 
205     ScrollingNodeID nodeID = stateNode-&gt;scrollingNodeID();
206     ScrollingNodeID parentNodeID = stateNode-&gt;parentNodeID();
207 
208     auto it = m_nodeMap.find(nodeID);
209 
210     RefPtr&lt;ScrollingTreeNode&gt; node;
211     if (it != m_nodeMap.end()) {
212         node = it-&gt;value;
213         unvisitedNodes.remove(nodeID);
214     } else {
215         node = createScrollingTreeNode(stateNode-&gt;nodeType(), nodeID);
216         if (!parentNodeID) {
217             // This is the root node. Clear the node map.
218             ASSERT(stateNode-&gt;isFrameScrollingNode());
219             m_rootNode = downcast&lt;ScrollingTreeFrameScrollingNode&gt;(node.get());
220             m_nodeMap.clear();
221         }
222         m_nodeMap.set(nodeID, node.get());
223     }
224 
225     if (parentNodeID) {
226         auto parentIt = m_nodeMap.find(parentNodeID);
227         ASSERT_WITH_SECURITY_IMPLICATION(parentIt != m_nodeMap.end());
228         if (parentIt != m_nodeMap.end()) {
229             auto* parent = parentIt-&gt;value.get();
230 
231             auto* oldParent = node-&gt;parent();
232             if (oldParent)
233                 oldParent-&gt;removeChild(*node);
234 
235             if (oldParent != parent)
236                 node-&gt;setParent(parent);
237 
238             parent-&gt;appendChild(*node);
239         } else {
240             // FIXME: Use WeakPtr in m_nodeMap.
241             m_nodeMap.remove(nodeID);
242         }
243     }
244 
245     node-&gt;commitStateBeforeChildren(*stateNode);
246 
247     // Move all children into the orphanNodes map. Live ones will get added back as we recurse over children.
<a name="5" id="anc5"></a><span class="line-modified">248     for (auto&amp; childScrollingNode : node-&gt;children()) {</span>
<span class="line-modified">249         childScrollingNode-&gt;setParent(nullptr);</span>
<span class="line-modified">250         orphanNodes.add(childScrollingNode-&gt;scrollingNodeID(), childScrollingNode.ptr());</span>



251     }
<a name="6" id="anc6"></a><span class="line-added">252     node-&gt;removeAllChildren();</span>
253 
254     // Now update the children if we have any.
255     if (auto children = stateNode-&gt;children()) {
256         for (auto&amp; child : *children)
257             updateTreeFromStateNode(child.get(), orphanNodes, unvisitedNodes);
258     }
259 
260     node-&gt;commitStateAfterChildren(*stateNode);
261 }
262 
263 void ScrollingTree::applyLayerPositionsAfterCommit()
264 {
265     // Scrolling tree needs to make adjustments only if the UI side positions have changed.
266     if (!m_wasScrolledByDelegatedScrollingSincePreviousCommit)
267         return;
268     m_wasScrolledByDelegatedScrollingSincePreviousCommit = false;
269 
270     applyLayerPositions();
271 }
272 
273 void ScrollingTree::applyLayerPositions()
274 {
275     ASSERT(isMainThread());
276     LockHolder locker(m_treeMutex);
277 
278     if (!m_rootNode)
279         return;
280 
281     LOG(Scrolling, &quot;\nScrollingTree %p applyLayerPositions&quot;, this);
282 
283     applyLayerPositionsRecursive(*m_rootNode);
284 
285     LOG(Scrolling, &quot;ScrollingTree %p applyLayerPositions - done\n&quot;, this);
286 }
287 
<a name="7" id="anc7"></a><span class="line-modified">288 void ScrollingTree::applyLayerPositionsRecursive(ScrollingTreeNode&amp; node)</span>
289 {
<a name="8" id="anc8"></a><span class="line-modified">290     node.applyLayerPositions();</span>
291 
<a name="9" id="anc9"></a><span class="line-modified">292     for (auto&amp; child : node.children())</span>
<span class="line-modified">293         applyLayerPositionsRecursive(child.get());</span>


294 }
295 
296 ScrollingTreeNode* ScrollingTree::nodeForID(ScrollingNodeID nodeID) const
297 {
298     if (!nodeID)
299         return nullptr;
300 
301     return m_nodeMap.get(nodeID);
302 }
303 
304 void ScrollingTree::notifyRelatedNodesAfterScrollPositionChange(ScrollingTreeScrollingNode&amp; changedNode)
305 {
306     Vector&lt;ScrollingNodeID&gt; additionalUpdateRoots;
307 
308     if (is&lt;ScrollingTreeOverflowScrollingNode&gt;(changedNode))
309         additionalUpdateRoots = overflowRelatedNodes().get(changedNode.scrollingNodeID());
310 
311     notifyRelatedNodesRecursive(changedNode);
312 
313     for (auto positionedNodeID : additionalUpdateRoots) {
314         auto* positionedNode = nodeForID(positionedNodeID);
315         if (positionedNode)
316             notifyRelatedNodesRecursive(*positionedNode);
317     }
318 }
319 
320 void ScrollingTree::notifyRelatedNodesRecursive(ScrollingTreeNode&amp; node)
321 {
322     node.applyLayerPositions();
323 
<a name="10" id="anc10"></a><span class="line-modified">324     for (auto&amp; child : node.children()) {</span>



325         // Never need to cross frame boundaries, since scroll layer adjustments are isolated to each document.
326         if (is&lt;ScrollingTreeFrameScrollingNode&gt;(child))
327             continue;
328 
<a name="11" id="anc11"></a><span class="line-modified">329         notifyRelatedNodesRecursive(child.get());</span>
330     }
331 }
332 
333 void ScrollingTree::setAsyncFrameOrOverflowScrollingEnabled(bool enabled)
334 {
335     m_asyncFrameOrOverflowScrollingEnabled = enabled;
336 }
337 
338 void ScrollingTree::setMainFrameScrollPosition(FloatPoint position)
339 {
340     LockHolder lock(m_treeStateMutex);
341     m_treeState.mainFrameScrollPosition = position;
342 }
343 
344 TrackingType ScrollingTree::eventTrackingTypeForPoint(const AtomString&amp; eventName, IntPoint p)
345 {
346     LockHolder lock(m_treeStateMutex);
347     return m_treeState.eventTrackingRegions.trackingTypeForPoint(eventName, p);
348 }
349 
350 // Can be called from the main thread.
351 bool ScrollingTree::isRubberBandInProgress()
352 {
353     LockHolder lock(m_treeStateMutex);
354     return m_treeState.mainFrameIsRubberBanding;
355 }
356 
357 void ScrollingTree::setMainFrameIsRubberBanding(bool isRubberBanding)
358 {
359     LockHolder locker(m_treeStateMutex);
360     m_treeState.mainFrameIsRubberBanding = isRubberBanding;
361 }
362 
363 // Can be called from the main thread.
364 bool ScrollingTree::isScrollSnapInProgress()
365 {
366     LockHolder lock(m_treeStateMutex);
367     return m_treeState.mainFrameIsScrollSnapping;
368 }
369 
370 void ScrollingTree::setMainFrameIsScrollSnapping(bool isScrollSnapping)
371 {
372     LockHolder locker(m_treeStateMutex);
373     m_treeState.mainFrameIsScrollSnapping = isScrollSnapping;
374 }
375 
376 void ScrollingTree::setMainFramePinState(bool pinnedToTheLeft, bool pinnedToTheRight, bool pinnedToTheTop, bool pinnedToTheBottom)
377 {
378     LockHolder locker(m_swipeStateMutex);
379 
380     m_swipeState.mainFramePinnedToTheLeft = pinnedToTheLeft;
381     m_swipeState.mainFramePinnedToTheRight = pinnedToTheRight;
382     m_swipeState.mainFramePinnedToTheTop = pinnedToTheTop;
383     m_swipeState.mainFramePinnedToTheBottom = pinnedToTheBottom;
384 }
385 
386 void ScrollingTree::setCanRubberBandState(bool canRubberBandAtLeft, bool canRubberBandAtRight, bool canRubberBandAtTop, bool canRubberBandAtBottom)
387 {
388     LockHolder locker(m_swipeStateMutex);
389 
390     m_swipeState.rubberBandsAtLeft = canRubberBandAtLeft;
391     m_swipeState.rubberBandsAtRight = canRubberBandAtRight;
392     m_swipeState.rubberBandsAtTop = canRubberBandAtTop;
393     m_swipeState.rubberBandsAtBottom = canRubberBandAtBottom;
394 }
395 
396 // Can be called from the main thread.
397 void ScrollingTree::setScrollPinningBehavior(ScrollPinningBehavior pinning)
398 {
399     LockHolder locker(m_swipeStateMutex);
400 
401     m_swipeState.scrollPinningBehavior = pinning;
402 }
403 
404 ScrollPinningBehavior ScrollingTree::scrollPinningBehavior()
405 {
406     LockHolder lock(m_swipeStateMutex);
407 
408     return m_swipeState.scrollPinningBehavior;
409 }
410 
411 bool ScrollingTree::willWheelEventStartSwipeGesture(const PlatformWheelEvent&amp; wheelEvent)
412 {
413     if (wheelEvent.phase() != PlatformWheelEventPhaseBegan)
414         return false;
415 
416     LockHolder lock(m_swipeStateMutex);
417 
418     if (wheelEvent.deltaX() &gt; 0 &amp;&amp; m_swipeState.mainFramePinnedToTheLeft &amp;&amp; !m_swipeState.rubberBandsAtLeft)
419         return true;
420     if (wheelEvent.deltaX() &lt; 0 &amp;&amp; m_swipeState.mainFramePinnedToTheRight &amp;&amp; !m_swipeState.rubberBandsAtRight)
421         return true;
422     if (wheelEvent.deltaY() &gt; 0 &amp;&amp; m_swipeState.mainFramePinnedToTheTop &amp;&amp; !m_swipeState.rubberBandsAtTop)
423         return true;
424     if (wheelEvent.deltaY() &lt; 0 &amp;&amp; m_swipeState.mainFramePinnedToTheBottom &amp;&amp; !m_swipeState.rubberBandsAtBottom)
425         return true;
426 
427     return false;
428 }
429 
430 void ScrollingTree::setScrollingPerformanceLoggingEnabled(bool flag)
431 {
432     m_scrollingPerformanceLoggingEnabled = flag;
433 }
434 
435 bool ScrollingTree::scrollingPerformanceLoggingEnabled()
436 {
437     return m_scrollingPerformanceLoggingEnabled;
438 }
439 
440 ScrollingNodeID ScrollingTree::latchedNode()
441 {
442     LockHolder locker(m_treeStateMutex);
443     return m_treeState.latchedNodeID;
444 }
445 
446 void ScrollingTree::setLatchedNode(ScrollingNodeID node)
447 {
448     LockHolder locker(m_treeStateMutex);
449     m_treeState.latchedNodeID = node;
450 }
451 
452 void ScrollingTree::clearLatchedNode()
453 {
454     LockHolder locker(m_treeStateMutex);
455     m_treeState.latchedNodeID = 0;
456 }
457 
458 String ScrollingTree::scrollingTreeAsText(ScrollingStateTreeAsTextBehavior behavior)
459 {
460     TextStream ts(TextStream::LineMode::MultipleLine);
461 
462     {
463         TextStream::GroupScope scope(ts);
464         ts &lt;&lt; &quot;scrolling tree&quot;;
465 
466         LockHolder locker(m_treeStateMutex);
467 
468         if (m_treeState.latchedNodeID)
469             ts.dumpProperty(&quot;latched node&quot;, m_treeState.latchedNodeID);
470 
471         if (!m_treeState.mainFrameScrollPosition.isZero())
472             ts.dumpProperty(&quot;main frame scroll position&quot;, m_treeState.mainFrameScrollPosition);
473 
474         if (m_rootNode) {
475             TextStream::GroupScope scope(ts);
476             m_rootNode-&gt;dump(ts, behavior | ScrollingStateTreeAsTextBehaviorIncludeLayerPositions);
477         }
478 
479         if (behavior &amp; ScrollingStateTreeAsTextBehaviorIncludeNodeIDs &amp;&amp; !m_overflowRelatedNodesMap.isEmpty()) {
480             TextStream::GroupScope scope(ts);
481             ts &lt;&lt; &quot;overflow related nodes&quot;;
482             {
483                 TextStream::IndentScope indentScope(ts);
484                 for (auto&amp; it : m_overflowRelatedNodesMap)
485                     ts &lt;&lt; &quot;\n&quot; &lt;&lt; indent &lt;&lt; it.key &lt;&lt; &quot; -&gt; &quot; &lt;&lt; it.value;
486             }
487         }
488     }
489     return ts.release();
490 }
491 
492 } // namespace WebCore
493 
494 #endif // ENABLE(ASYNC_SCROLLING)
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
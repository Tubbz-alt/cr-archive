<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/ImageBitmap.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLVideoElement.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ImageBitmap.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/ImageBitmap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ImageBitmap.h&quot;
 28 
 29 #include &quot;BitmapImage.h&quot;
 30 #include &quot;Blob.h&quot;
 31 #include &quot;CachedImage.h&quot;
 32 #include &quot;ExceptionOr.h&quot;
 33 #include &quot;FileReaderLoader.h&quot;
 34 #include &quot;FileReaderLoaderClient.h&quot;
 35 #include &quot;GraphicsContext.h&quot;
 36 #include &quot;HTMLCanvasElement.h&quot;
 37 #include &quot;HTMLImageElement.h&quot;
 38 #include &quot;HTMLVideoElement.h&quot;
 39 #include &quot;ImageBitmapOptions.h&quot;
 40 #include &quot;ImageBuffer.h&quot;
 41 #include &quot;ImageData.h&quot;
 42 #include &quot;IntRect.h&quot;

 43 #include &quot;JSImageBitmap.h&quot;
 44 #include &quot;LayoutSize.h&quot;



 45 #include &quot;RenderElement.h&quot;
 46 #include &quot;SharedBuffer.h&quot;

 47 #include &quot;TypedOMCSSImageValue.h&quot;
 48 #include &lt;wtf/IsoMallocInlines.h&gt;
 49 #include &lt;wtf/Optional.h&gt;

 50 #include &lt;wtf/StdLibExtras.h&gt;
 51 #include &lt;wtf/Variant.h&gt;
 52 
 53 namespace WebCore {
 54 
 55 WTF_MAKE_ISO_ALLOCATED_IMPL(ImageBitmap);
 56 
 57 #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
<span class="line-modified"> 58 static RenderingMode bufferRenderingMode = Accelerated;</span>
 59 #else
<span class="line-modified"> 60 static RenderingMode bufferRenderingMode = Unaccelerated;</span>
 61 #endif
 62 
 63 Ref&lt;ImageBitmap&gt; ImageBitmap::create(IntSize size)
 64 {
 65     return create(ImageBuffer::create(FloatSize(size.width(), size.height()), bufferRenderingMode));
 66 }
 67 
 68 Ref&lt;ImageBitmap&gt; ImageBitmap::create(std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&amp;&amp; buffer)
 69 {
 70     auto imageBitmap = create(WTFMove(buffer.first));
 71     imageBitmap-&gt;m_originClean = buffer.second;
 72     return imageBitmap;
 73 }
 74 
 75 Ref&lt;ImageBitmap&gt; ImageBitmap::create(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp; buffer)
 76 {
 77     return adoptRef(*new ImageBitmap(WTFMove(buffer)));
 78 }
 79 
 80 void ImageBitmap::createPromise(ScriptExecutionContext&amp; scriptExecutionContext, ImageBitmap::Source&amp;&amp; source, ImageBitmapOptions&amp;&amp; options, ImageBitmap::Promise&amp;&amp; promise)
</pre>
<hr />
<pre>
183             return ceil(sourceRectangle.width() * static_cast&lt;double&gt;(options.resizeHeight.value()) / sourceRectangle.height());
184         return sourceRectangle.width();
185     }();
186 
187     // 6. Let outputHeight be determined as follows:
188     auto outputHeight = [&amp;] () -&gt; int {
189         if (options.resizeHeight)
190             return options.resizeHeight.value();
191         if (options.resizeWidth)
192             return ceil(sourceRectangle.height() * static_cast&lt;double&gt;(options.resizeWidth.value()) / sourceRectangle.width());
193         return sourceRectangle.height();
194     }();
195 
196     return { outputWidth, outputHeight };
197 }
198 
199 static InterpolationQuality interpolationQualityForResizeQuality(ImageBitmapOptions::ResizeQuality resizeQuality)
200 {
201     switch (resizeQuality) {
202     case ImageBitmapOptions::ResizeQuality::Pixelated:
<span class="line-modified">203         return InterpolationNone;</span>
204     case ImageBitmapOptions::ResizeQuality::Low:
<span class="line-modified">205         return InterpolationDefault; // Low is the default.</span>
206     case ImageBitmapOptions::ResizeQuality::Medium:
<span class="line-modified">207         return InterpolationMedium;</span>
208     case ImageBitmapOptions::ResizeQuality::High:
<span class="line-modified">209         return InterpolationHigh;</span>
210     }
211     ASSERT_NOT_REACHED();
<span class="line-modified">212     return InterpolationDefault;</span>
213 }
214 
215 // FIXME: More steps from https://html.spec.whatwg.org/multipage/imagebitmap-and-animations.html#cropped-to-the-source-rectangle-with-formatting
216 
217 // 7. Place input on an infinite transparent black grid plane, positioned so that its
218 //    top left corner is at the origin of the plane, with the x-coordinate increasing
219 //    to the right, and the y-coordinate increasing down, and with each pixel in the
220 //    input image data occupying a cell on the plane&#39;s grid.
221 
222 // 8. Let output be the rectangle on the plane denoted by sourceRectangle.
223 
224 // 9. Scale output to the size specified by outputWidth and outputHeight. The user
225 //    agent should use the value of the resizeQuality option to guide the choice of
226 //    scaling algorithm.
227 
228 // 10. If the value of the imageOrientation member of options is &quot;flipY&quot;, output must
229 //     be flipped vertically, disregarding any image orientation metadata of the source
230 //     (such as EXIF metadata), if any.
231 
232 // 11. If image is an img element or a Blob object, let val be the value of the
</pre>
<hr />
<pre>
323     }
324 
325     FloatRect destRect(FloatPoint(), outputSize);
326     bitmapData-&gt;context().drawImage(*imageForRender, destRect, sourceRectangle.releaseReturnValue(), { interpolationQualityForResizeQuality(options.resizeQuality) });
327 
328     // 7. Create a new ImageBitmap object.
329     auto imageBitmap = create(WTFMove(bitmapData));
330 
331     // 9. If the origin of image&#39;s image is not the same origin as the origin specified by the
332     //    entry settings object, then set the origin-clean flag of the ImageBitmap object&#39;s
333     //    bitmap to false.
334 
335     imageBitmap-&gt;m_originClean = !taintsOrigin(*cachedImage);
336 
337     // 10. Return a new promise, but continue running these steps in parallel.
338     // 11. Resolve the promise with the new ImageBitmap object as the value.
339 
340     promise.resolve(WTFMove(imageBitmap));
341 }
342 
<span class="line-modified">343 void ImageBitmap::createPromise(ScriptExecutionContext&amp;, RefPtr&lt;HTMLCanvasElement&gt;&amp; canvasElement, ImageBitmapOptions&amp;&amp; options, Optional&lt;IntRect&gt; rect, ImageBitmap::Promise&amp;&amp; promise)</span>












344 {
345     // 2. If the canvas element&#39;s bitmap has either a horizontal dimension or a vertical
346     //    dimension equal to zero, then return a promise rejected with an &quot;InvalidStateError&quot;
347     //    DOMException and abort these steps.
<span class="line-modified">348     auto size = canvasElement-&gt;size();</span>
349     if (!size.width() || !size.height()) {
350         promise.reject(InvalidStateError, &quot;Cannot create ImageBitmap from a canvas that has zero width or height&quot;);
351         return;
352     }
353 
354     // 4. Let the ImageBitmap object&#39;s bitmap data be a copy of the canvas element&#39;s bitmap
355     //    data, cropped to the source rectangle with formatting.
356 
357     auto sourceRectangle = croppedSourceRectangleWithFormatting(size, options, WTFMove(rect));
358     if (sourceRectangle.hasException()) {
359         promise.reject(sourceRectangle.releaseException());
360         return;
361     }
362 
363     auto outputSize = outputSizeForSourceRectangle(sourceRectangle.returnValue(), options);
364     auto bitmapData = ImageBuffer::create(FloatSize(outputSize.width(), outputSize.height()), bufferRenderingMode);
365 
<span class="line-modified">366     auto imageForRender = canvasElement-&gt;copiedImage();</span>
367     if (!imageForRender) {
368         promise.reject(InvalidStateError, &quot;Cannot create ImageBitmap from canvas that can&#39;t be rendered&quot;);
369         return;
370     }
371 
372     FloatRect destRect(FloatPoint(), outputSize);
373     bitmapData-&gt;context().drawImage(*imageForRender, destRect, sourceRectangle.releaseReturnValue(), { interpolationQualityForResizeQuality(options.resizeQuality) });
374 
375     // 3. Create a new ImageBitmap object.
376     auto imageBitmap = create(WTFMove(bitmapData));
377 
378     // 5. Set the origin-clean flag of the ImageBitmap object&#39;s bitmap to the same value as
379     //    the origin-clean flag of the canvas element&#39;s bitmap.
380 
<span class="line-modified">381     imageBitmap-&gt;m_originClean = canvasElement-&gt;originClean();</span>
382 
383     // 6. Return a new promise, but continue running these steps in parallel.
384     // 7. Resolve the promise with the new ImageBitmap object as the value.
385 
386     promise.resolve(WTFMove(imageBitmap));
387 }
388 
389 #if ENABLE(VIDEO)
390 void ImageBitmap::createPromise(ScriptExecutionContext&amp; scriptExecutionContext, RefPtr&lt;HTMLVideoElement&gt;&amp; video, ImageBitmapOptions&amp;&amp; options, Optional&lt;IntRect&gt; rect, ImageBitmap::Promise&amp;&amp; promise)
391 {
392     // https://html.spec.whatwg.org/multipage/#dom-createimagebitmap
393     // WHATWG HTML 2102913b313078cd8eeac7e81e6a8756cbd3e773
394     // Steps 3-7.
395     // (Step 3 is handled in croppedSourceRectangleWithFormatting.)
396 
397     // 4. Check the usability of the image argument. If this throws an exception
398     //    or returns bad, then return p rejected with an &quot;InvalidStateError&quot;
399     //    DOMException.
400     if (video-&gt;readyState() == HTMLMediaElement::HAVE_NOTHING || video-&gt;readyState() == HTMLMediaElement::HAVE_METADATA) {
401         promise.reject(InvalidStateError, &quot;Cannot create ImageBitmap before the HTMLVideoElement has data&quot;);
</pre>
<hr />
<pre>
507 
508     void didDraw(const Image&amp;) override { }
509 
510     bool canDestroyDecodedData(const Image&amp;) override { return true; }
511     void imageFrameAvailable(const Image&amp;, ImageAnimatingState, const IntRect* = nullptr, DecodingStatus = DecodingStatus::Invalid) override { }
512     void changedInRect(const Image&amp;, const IntRect* = nullptr) override { }
513 
514 private:
515     ImageBitmapImageObserver(String mimeType, long long expectedContentLength, const URL&amp; sourceUrl)
516         : m_mimeType(mimeType)
517         , m_expectedContentLength(expectedContentLength)
518         , m_sourceUrl(sourceUrl)
519     { }
520 
521     String m_mimeType;
522     long long m_expectedContentLength;
523     URL m_sourceUrl;
524 };
525 
526 class PendingImageBitmap final : public ActiveDOMObject, public FileReaderLoaderClient {

527 public:
528     static void fetch(ScriptExecutionContext&amp; scriptExecutionContext, RefPtr&lt;Blob&gt;&amp;&amp; blob, ImageBitmapOptions&amp;&amp; options, Optional&lt;IntRect&gt; rect, ImageBitmap::Promise&amp;&amp; promise)
529     {
530         auto pendingImageBitmap = new PendingImageBitmap(scriptExecutionContext, WTFMove(blob), WTFMove(options), WTFMove(rect), WTFMove(promise));
531         pendingImageBitmap-&gt;start(scriptExecutionContext);
532     }
533 
534 private:
535     PendingImageBitmap(ScriptExecutionContext&amp; scriptExecutionContext, RefPtr&lt;Blob&gt;&amp;&amp; blob, ImageBitmapOptions&amp;&amp; options, Optional&lt;IntRect&gt; rect, ImageBitmap::Promise&amp;&amp; promise)
536         : ActiveDOMObject(&amp;scriptExecutionContext)
537         , m_blobLoader(FileReaderLoader::ReadAsArrayBuffer, this)
538         , m_blob(WTFMove(blob))
539         , m_options(WTFMove(options))
540         , m_rect(WTFMove(rect))
541         , m_promise(WTFMove(promise))

542     {
543         suspendIfNeeded();

544     }
545 
546     void start(ScriptExecutionContext&amp; scriptExecutionContext)
547     {
548         m_blobLoader.start(&amp;scriptExecutionContext, *m_blob);
549     }
550 
551     // ActiveDOMObject
552 
<span class="line-modified">553     const char* activeDOMObjectName() const override</span>
554     {
555         return &quot;PendingImageBitmap&quot;;
556     }
557 
<span class="line-modified">558     bool canSuspendForDocumentSuspension() const override</span>
559     {
<span class="line-modified">560         // FIXME: Deal with suspension.</span>
<span class="line-removed">561         return false;</span>
562     }
563 
564     // FileReaderLoaderClient
565 
566     void didStartLoading() override
567     {
568     }
569 
570     void didReceiveData() override
571     {
572     }
573 
574     void didFinishLoading() override
575     {
<span class="line-modified">576         createImageBitmap(m_blobLoader.arrayBufferResult());</span>
<span class="line-removed">577         delete this;</span>
578     }
579 
580     void didFail(int) override
581     {
<span class="line-modified">582         createImageBitmap(nullptr);</span>
<span class="line-removed">583         delete this;</span>
584     }
585 
<span class="line-modified">586     void createImageBitmap(RefPtr&lt;ArrayBuffer&gt;&amp;&amp; arrayBuffer)</span>
587     {
<span class="line-modified">588         if (!arrayBuffer) {</span>











589             m_promise.reject(InvalidStateError, &quot;An error occured reading the Blob argument to createImageBitmap&quot;);
590             return;
591         }
592 
<span class="line-modified">593         ImageBitmap::createFromBuffer(arrayBuffer.releaseNonNull(), m_blob-&gt;type(), m_blob-&gt;size(), m_blobLoader.url(), WTFMove(m_options), WTFMove(m_rect), WTFMove(m_promise));</span>
594     }
595 
596     FileReaderLoader m_blobLoader;
597     RefPtr&lt;Blob&gt; m_blob;
598     ImageBitmapOptions m_options;
599     Optional&lt;IntRect&gt; m_rect;
600     ImageBitmap::Promise m_promise;


601 };
602 
603 void ImageBitmap::createFromBuffer(
604     Ref&lt;ArrayBuffer&gt;&amp;&amp; arrayBuffer,
605     String mimeType,
606     long long expectedContentLength,
607     const URL&amp; sourceUrl,
608     ImageBitmapOptions&amp;&amp; options,
609     Optional&lt;IntRect&gt; rect,
610     ImageBitmap::Promise&amp;&amp; promise)
611 {
612     if (!arrayBuffer-&gt;byteLength()) {
613         promise.reject(InvalidStateError, &quot;Cannot create an ImageBitmap from an empty buffer&quot;);
614         return;
615     }
616 
617     auto sharedBuffer = SharedBuffer::create(static_cast&lt;const char*&gt;(arrayBuffer-&gt;data()), arrayBuffer-&gt;byteLength());
618     auto observer = ImageBitmapImageObserver::create(mimeType, expectedContentLength, sourceUrl);
619     auto image = Image::create(observer.get());
620     if (!image) {
</pre>
</td>
<td>
<hr />
<pre>
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ImageBitmap.h&quot;
 28 
 29 #include &quot;BitmapImage.h&quot;
 30 #include &quot;Blob.h&quot;
 31 #include &quot;CachedImage.h&quot;
 32 #include &quot;ExceptionOr.h&quot;
 33 #include &quot;FileReaderLoader.h&quot;
 34 #include &quot;FileReaderLoaderClient.h&quot;
 35 #include &quot;GraphicsContext.h&quot;
 36 #include &quot;HTMLCanvasElement.h&quot;
 37 #include &quot;HTMLImageElement.h&quot;
 38 #include &quot;HTMLVideoElement.h&quot;
 39 #include &quot;ImageBitmapOptions.h&quot;
 40 #include &quot;ImageBuffer.h&quot;
 41 #include &quot;ImageData.h&quot;
 42 #include &quot;IntRect.h&quot;
<span class="line-added"> 43 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
 44 #include &quot;JSImageBitmap.h&quot;
 45 #include &quot;LayoutSize.h&quot;
<span class="line-added"> 46 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added"> 47 #include &quot;OffscreenCanvas.h&quot;</span>
<span class="line-added"> 48 #endif</span>
 49 #include &quot;RenderElement.h&quot;
 50 #include &quot;SharedBuffer.h&quot;
<span class="line-added"> 51 #include &quot;SuspendableTimer.h&quot;</span>
 52 #include &quot;TypedOMCSSImageValue.h&quot;
 53 #include &lt;wtf/IsoMallocInlines.h&gt;
 54 #include &lt;wtf/Optional.h&gt;
<span class="line-added"> 55 #include &lt;wtf/Scope.h&gt;</span>
 56 #include &lt;wtf/StdLibExtras.h&gt;
 57 #include &lt;wtf/Variant.h&gt;
 58 
 59 namespace WebCore {
 60 
 61 WTF_MAKE_ISO_ALLOCATED_IMPL(ImageBitmap);
 62 
 63 #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
<span class="line-modified"> 64 static RenderingMode bufferRenderingMode = RenderingMode::Accelerated;</span>
 65 #else
<span class="line-modified"> 66 static RenderingMode bufferRenderingMode = RenderingMode::Unaccelerated;</span>
 67 #endif
 68 
 69 Ref&lt;ImageBitmap&gt; ImageBitmap::create(IntSize size)
 70 {
 71     return create(ImageBuffer::create(FloatSize(size.width(), size.height()), bufferRenderingMode));
 72 }
 73 
 74 Ref&lt;ImageBitmap&gt; ImageBitmap::create(std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&amp;&amp; buffer)
 75 {
 76     auto imageBitmap = create(WTFMove(buffer.first));
 77     imageBitmap-&gt;m_originClean = buffer.second;
 78     return imageBitmap;
 79 }
 80 
 81 Ref&lt;ImageBitmap&gt; ImageBitmap::create(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp; buffer)
 82 {
 83     return adoptRef(*new ImageBitmap(WTFMove(buffer)));
 84 }
 85 
 86 void ImageBitmap::createPromise(ScriptExecutionContext&amp; scriptExecutionContext, ImageBitmap::Source&amp;&amp; source, ImageBitmapOptions&amp;&amp; options, ImageBitmap::Promise&amp;&amp; promise)
</pre>
<hr />
<pre>
189             return ceil(sourceRectangle.width() * static_cast&lt;double&gt;(options.resizeHeight.value()) / sourceRectangle.height());
190         return sourceRectangle.width();
191     }();
192 
193     // 6. Let outputHeight be determined as follows:
194     auto outputHeight = [&amp;] () -&gt; int {
195         if (options.resizeHeight)
196             return options.resizeHeight.value();
197         if (options.resizeWidth)
198             return ceil(sourceRectangle.height() * static_cast&lt;double&gt;(options.resizeWidth.value()) / sourceRectangle.width());
199         return sourceRectangle.height();
200     }();
201 
202     return { outputWidth, outputHeight };
203 }
204 
205 static InterpolationQuality interpolationQualityForResizeQuality(ImageBitmapOptions::ResizeQuality resizeQuality)
206 {
207     switch (resizeQuality) {
208     case ImageBitmapOptions::ResizeQuality::Pixelated:
<span class="line-modified">209         return InterpolationQuality::DoNotInterpolate;</span>
210     case ImageBitmapOptions::ResizeQuality::Low:
<span class="line-modified">211         return InterpolationQuality::Default; // Low is the default.</span>
212     case ImageBitmapOptions::ResizeQuality::Medium:
<span class="line-modified">213         return InterpolationQuality::Medium;</span>
214     case ImageBitmapOptions::ResizeQuality::High:
<span class="line-modified">215         return InterpolationQuality::High;</span>
216     }
217     ASSERT_NOT_REACHED();
<span class="line-modified">218     return InterpolationQuality::Default;</span>
219 }
220 
221 // FIXME: More steps from https://html.spec.whatwg.org/multipage/imagebitmap-and-animations.html#cropped-to-the-source-rectangle-with-formatting
222 
223 // 7. Place input on an infinite transparent black grid plane, positioned so that its
224 //    top left corner is at the origin of the plane, with the x-coordinate increasing
225 //    to the right, and the y-coordinate increasing down, and with each pixel in the
226 //    input image data occupying a cell on the plane&#39;s grid.
227 
228 // 8. Let output be the rectangle on the plane denoted by sourceRectangle.
229 
230 // 9. Scale output to the size specified by outputWidth and outputHeight. The user
231 //    agent should use the value of the resizeQuality option to guide the choice of
232 //    scaling algorithm.
233 
234 // 10. If the value of the imageOrientation member of options is &quot;flipY&quot;, output must
235 //     be flipped vertically, disregarding any image orientation metadata of the source
236 //     (such as EXIF metadata), if any.
237 
238 // 11. If image is an img element or a Blob object, let val be the value of the
</pre>
<hr />
<pre>
329     }
330 
331     FloatRect destRect(FloatPoint(), outputSize);
332     bitmapData-&gt;context().drawImage(*imageForRender, destRect, sourceRectangle.releaseReturnValue(), { interpolationQualityForResizeQuality(options.resizeQuality) });
333 
334     // 7. Create a new ImageBitmap object.
335     auto imageBitmap = create(WTFMove(bitmapData));
336 
337     // 9. If the origin of image&#39;s image is not the same origin as the origin specified by the
338     //    entry settings object, then set the origin-clean flag of the ImageBitmap object&#39;s
339     //    bitmap to false.
340 
341     imageBitmap-&gt;m_originClean = !taintsOrigin(*cachedImage);
342 
343     // 10. Return a new promise, but continue running these steps in parallel.
344     // 11. Resolve the promise with the new ImageBitmap object as the value.
345 
346     promise.resolve(WTFMove(imageBitmap));
347 }
348 
<span class="line-modified">349 void ImageBitmap::createPromise(ScriptExecutionContext&amp; context, RefPtr&lt;HTMLCanvasElement&gt;&amp; canvasElement, ImageBitmapOptions&amp;&amp; options, Optional&lt;IntRect&gt; rect, ImageBitmap::Promise&amp;&amp; promise)</span>
<span class="line-added">350 {</span>
<span class="line-added">351     createPromise(context, *canvasElement, WTFMove(options), WTFMove(rect), WTFMove(promise));</span>
<span class="line-added">352 }</span>
<span class="line-added">353 </span>
<span class="line-added">354 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">355 void ImageBitmap::createPromise(ScriptExecutionContext&amp; context, RefPtr&lt;OffscreenCanvas&gt;&amp; canvasElement, ImageBitmapOptions&amp;&amp; options, Optional&lt;IntRect&gt; rect, ImageBitmap::Promise&amp;&amp; promise)</span>
<span class="line-added">356 {</span>
<span class="line-added">357     createPromise(context, *canvasElement, WTFMove(options), WTFMove(rect), WTFMove(promise));</span>
<span class="line-added">358 }</span>
<span class="line-added">359 #endif</span>
<span class="line-added">360 </span>
<span class="line-added">361 void ImageBitmap::createPromise(ScriptExecutionContext&amp;, CanvasBase&amp; canvas, ImageBitmapOptions&amp;&amp; options, Optional&lt;IntRect&gt; rect, ImageBitmap::Promise&amp;&amp; promise)</span>
362 {
363     // 2. If the canvas element&#39;s bitmap has either a horizontal dimension or a vertical
364     //    dimension equal to zero, then return a promise rejected with an &quot;InvalidStateError&quot;
365     //    DOMException and abort these steps.
<span class="line-modified">366     auto size = canvas.size();</span>
367     if (!size.width() || !size.height()) {
368         promise.reject(InvalidStateError, &quot;Cannot create ImageBitmap from a canvas that has zero width or height&quot;);
369         return;
370     }
371 
372     // 4. Let the ImageBitmap object&#39;s bitmap data be a copy of the canvas element&#39;s bitmap
373     //    data, cropped to the source rectangle with formatting.
374 
375     auto sourceRectangle = croppedSourceRectangleWithFormatting(size, options, WTFMove(rect));
376     if (sourceRectangle.hasException()) {
377         promise.reject(sourceRectangle.releaseException());
378         return;
379     }
380 
381     auto outputSize = outputSizeForSourceRectangle(sourceRectangle.returnValue(), options);
382     auto bitmapData = ImageBuffer::create(FloatSize(outputSize.width(), outputSize.height()), bufferRenderingMode);
383 
<span class="line-modified">384     auto imageForRender = canvas.copiedImage();</span>
385     if (!imageForRender) {
386         promise.reject(InvalidStateError, &quot;Cannot create ImageBitmap from canvas that can&#39;t be rendered&quot;);
387         return;
388     }
389 
390     FloatRect destRect(FloatPoint(), outputSize);
391     bitmapData-&gt;context().drawImage(*imageForRender, destRect, sourceRectangle.releaseReturnValue(), { interpolationQualityForResizeQuality(options.resizeQuality) });
392 
393     // 3. Create a new ImageBitmap object.
394     auto imageBitmap = create(WTFMove(bitmapData));
395 
396     // 5. Set the origin-clean flag of the ImageBitmap object&#39;s bitmap to the same value as
397     //    the origin-clean flag of the canvas element&#39;s bitmap.
398 
<span class="line-modified">399     imageBitmap-&gt;m_originClean = canvas.originClean();</span>
400 
401     // 6. Return a new promise, but continue running these steps in parallel.
402     // 7. Resolve the promise with the new ImageBitmap object as the value.
403 
404     promise.resolve(WTFMove(imageBitmap));
405 }
406 
407 #if ENABLE(VIDEO)
408 void ImageBitmap::createPromise(ScriptExecutionContext&amp; scriptExecutionContext, RefPtr&lt;HTMLVideoElement&gt;&amp; video, ImageBitmapOptions&amp;&amp; options, Optional&lt;IntRect&gt; rect, ImageBitmap::Promise&amp;&amp; promise)
409 {
410     // https://html.spec.whatwg.org/multipage/#dom-createimagebitmap
411     // WHATWG HTML 2102913b313078cd8eeac7e81e6a8756cbd3e773
412     // Steps 3-7.
413     // (Step 3 is handled in croppedSourceRectangleWithFormatting.)
414 
415     // 4. Check the usability of the image argument. If this throws an exception
416     //    or returns bad, then return p rejected with an &quot;InvalidStateError&quot;
417     //    DOMException.
418     if (video-&gt;readyState() == HTMLMediaElement::HAVE_NOTHING || video-&gt;readyState() == HTMLMediaElement::HAVE_METADATA) {
419         promise.reject(InvalidStateError, &quot;Cannot create ImageBitmap before the HTMLVideoElement has data&quot;);
</pre>
<hr />
<pre>
525 
526     void didDraw(const Image&amp;) override { }
527 
528     bool canDestroyDecodedData(const Image&amp;) override { return true; }
529     void imageFrameAvailable(const Image&amp;, ImageAnimatingState, const IntRect* = nullptr, DecodingStatus = DecodingStatus::Invalid) override { }
530     void changedInRect(const Image&amp;, const IntRect* = nullptr) override { }
531 
532 private:
533     ImageBitmapImageObserver(String mimeType, long long expectedContentLength, const URL&amp; sourceUrl)
534         : m_mimeType(mimeType)
535         , m_expectedContentLength(expectedContentLength)
536         , m_sourceUrl(sourceUrl)
537     { }
538 
539     String m_mimeType;
540     long long m_expectedContentLength;
541     URL m_sourceUrl;
542 };
543 
544 class PendingImageBitmap final : public ActiveDOMObject, public FileReaderLoaderClient {
<span class="line-added">545     WTF_MAKE_FAST_ALLOCATED;</span>
546 public:
547     static void fetch(ScriptExecutionContext&amp; scriptExecutionContext, RefPtr&lt;Blob&gt;&amp;&amp; blob, ImageBitmapOptions&amp;&amp; options, Optional&lt;IntRect&gt; rect, ImageBitmap::Promise&amp;&amp; promise)
548     {
549         auto pendingImageBitmap = new PendingImageBitmap(scriptExecutionContext, WTFMove(blob), WTFMove(options), WTFMove(rect), WTFMove(promise));
550         pendingImageBitmap-&gt;start(scriptExecutionContext);
551     }
552 
553 private:
554     PendingImageBitmap(ScriptExecutionContext&amp; scriptExecutionContext, RefPtr&lt;Blob&gt;&amp;&amp; blob, ImageBitmapOptions&amp;&amp; options, Optional&lt;IntRect&gt; rect, ImageBitmap::Promise&amp;&amp; promise)
555         : ActiveDOMObject(&amp;scriptExecutionContext)
556         , m_blobLoader(FileReaderLoader::ReadAsArrayBuffer, this)
557         , m_blob(WTFMove(blob))
558         , m_options(WTFMove(options))
559         , m_rect(WTFMove(rect))
560         , m_promise(WTFMove(promise))
<span class="line-added">561         , m_createImageBitmapTimer(&amp;scriptExecutionContext, *this, &amp;PendingImageBitmap::createImageBitmapAndResolvePromise)</span>
562     {
563         suspendIfNeeded();
<span class="line-added">564         m_createImageBitmapTimer.suspendIfNeeded();</span>
565     }
566 
567     void start(ScriptExecutionContext&amp; scriptExecutionContext)
568     {
569         m_blobLoader.start(&amp;scriptExecutionContext, *m_blob);
570     }
571 
572     // ActiveDOMObject
573 
<span class="line-modified">574     const char* activeDOMObjectName() const final</span>
575     {
576         return &quot;PendingImageBitmap&quot;;
577     }
578 
<span class="line-modified">579     void stop() final</span>
580     {
<span class="line-modified">581         delete this;</span>

582     }
583 
584     // FileReaderLoaderClient
585 
586     void didStartLoading() override
587     {
588     }
589 
590     void didReceiveData() override
591     {
592     }
593 
594     void didFinishLoading() override
595     {
<span class="line-modified">596         createImageBitmapAndResolvePromiseSoon(m_blobLoader.arrayBufferResult());</span>

597     }
598 
599     void didFail(int) override
600     {
<span class="line-modified">601         createImageBitmapAndResolvePromiseSoon(nullptr);</span>

602     }
603 
<span class="line-modified">604     void createImageBitmapAndResolvePromiseSoon(RefPtr&lt;ArrayBuffer&gt;&amp;&amp; arrayBuffer)</span>
605     {
<span class="line-modified">606         ASSERT(!m_createImageBitmapTimer.isActive());</span>
<span class="line-added">607         m_arrayBufferToProcess = WTFMove(arrayBuffer);</span>
<span class="line-added">608         m_createImageBitmapTimer.startOneShot(0_s);</span>
<span class="line-added">609     }</span>
<span class="line-added">610 </span>
<span class="line-added">611     void createImageBitmapAndResolvePromise()</span>
<span class="line-added">612     {</span>
<span class="line-added">613         auto destroyOnExit = makeScopeExit([this] {</span>
<span class="line-added">614             delete this;</span>
<span class="line-added">615         });</span>
<span class="line-added">616 </span>
<span class="line-added">617         if (!m_arrayBufferToProcess) {</span>
618             m_promise.reject(InvalidStateError, &quot;An error occured reading the Blob argument to createImageBitmap&quot;);
619             return;
620         }
621 
<span class="line-modified">622         ImageBitmap::createFromBuffer(m_arrayBufferToProcess.releaseNonNull(), m_blob-&gt;type(), m_blob-&gt;size(), m_blobLoader.url(), WTFMove(m_options), WTFMove(m_rect), WTFMove(m_promise));</span>
623     }
624 
625     FileReaderLoader m_blobLoader;
626     RefPtr&lt;Blob&gt; m_blob;
627     ImageBitmapOptions m_options;
628     Optional&lt;IntRect&gt; m_rect;
629     ImageBitmap::Promise m_promise;
<span class="line-added">630     SuspendableTimer m_createImageBitmapTimer;</span>
<span class="line-added">631     RefPtr&lt;ArrayBuffer&gt; m_arrayBufferToProcess;</span>
632 };
633 
634 void ImageBitmap::createFromBuffer(
635     Ref&lt;ArrayBuffer&gt;&amp;&amp; arrayBuffer,
636     String mimeType,
637     long long expectedContentLength,
638     const URL&amp; sourceUrl,
639     ImageBitmapOptions&amp;&amp; options,
640     Optional&lt;IntRect&gt; rect,
641     ImageBitmap::Promise&amp;&amp; promise)
642 {
643     if (!arrayBuffer-&gt;byteLength()) {
644         promise.reject(InvalidStateError, &quot;Cannot create an ImageBitmap from an empty buffer&quot;);
645         return;
646     }
647 
648     auto sharedBuffer = SharedBuffer::create(static_cast&lt;const char*&gt;(arrayBuffer-&gt;data()), arrayBuffer-&gt;byteLength());
649     auto observer = ImageBitmapImageObserver::create(mimeType, expectedContentLength, sourceUrl);
650     auto image = Image::create(observer.get());
651     if (!image) {
</pre>
</td>
</tr>
</table>
<center><a href="HTMLVideoElement.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ImageBitmap.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderScrollbar.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderReplaced.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderScrollbar.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderScrollbar.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
119 
120     updateScrollbarPart(oldPart);
121     updateScrollbarPart(m_hoveredPart);
122 
123     updateScrollbarPart(ScrollbarBGPart);
124     updateScrollbarPart(TrackBGPart);
125 }
126 
127 void RenderScrollbar::setPressedPart(ScrollbarPart part)
128 {
129     ScrollbarPart oldPart = m_pressedPart;
130     Scrollbar::setPressedPart(part);
131 
132     updateScrollbarPart(oldPart);
133     updateScrollbarPart(part);
134 
135     updateScrollbarPart(ScrollbarBGPart);
136     updateScrollbarPart(TrackBGPart);
137 }
138 
<span class="line-modified">139 std::unique_ptr&lt;RenderStyle&gt; RenderScrollbar::getScrollbarPseudoStyle(ScrollbarPart partType, PseudoId pseudoId)</span>
140 {
141     if (!owningRenderer())
<span class="line-modified">142         return 0;</span>
<span class="line-modified">143 </span>
<span class="line-modified">144     std::unique_ptr&lt;RenderStyle&gt; result = owningRenderer()-&gt;getUncachedPseudoStyle(PseudoStyleRequest(pseudoId, this, partType), &amp;owningRenderer()-&gt;style());</span>









145     // Scrollbars for root frames should always have background color
146     // unless explicitly specified as transparent. So we force it.
147     // This is because WebKit assumes scrollbar to be always painted and missing background
148     // causes visual artifact like non-repainted dirty region.
149     if (result &amp;&amp; m_owningFrame &amp;&amp; m_owningFrame-&gt;view() &amp;&amp; !m_owningFrame-&gt;view()-&gt;isTransparent() &amp;&amp; !result-&gt;hasBackground())
150         result-&gt;setBackgroundColor(Color::white);
151 
152     return result;
153 }
154 
155 void RenderScrollbar::updateScrollbarParts()
156 {
157     updateScrollbarPart(ScrollbarBGPart);
158     updateScrollbarPart(BackButtonStartPart);
159     updateScrollbarPart(ForwardButtonStartPart);
160     updateScrollbarPart(BackTrackPart);
161     updateScrollbarPart(ThumbPart);
162     updateScrollbarPart(ForwardTrackPart);
163     updateScrollbarPart(BackButtonEndPart);
164     updateScrollbarPart(ForwardButtonEndPart);
</pre>
<hr />
<pre>
334 }
335 
336 int RenderScrollbar::minimumThumbLength()
337 {
338     RenderScrollbarPart* partRenderer = m_parts.get(ThumbPart);
339     if (!partRenderer)
340         return 0;
341     partRenderer-&gt;layout();
342     return orientation() == HorizontalScrollbar ? partRenderer-&gt;width() : partRenderer-&gt;height();
343 }
344 
345 float RenderScrollbar::opacity()
346 {
347     RenderScrollbarPart* partRenderer = m_parts.get(ScrollbarBGPart);
348     if (!partRenderer)
349         return 1;
350 
351     return partRenderer-&gt;style().opacity();
352 }
353 






354 }
</pre>
</td>
<td>
<hr />
<pre>
119 
120     updateScrollbarPart(oldPart);
121     updateScrollbarPart(m_hoveredPart);
122 
123     updateScrollbarPart(ScrollbarBGPart);
124     updateScrollbarPart(TrackBGPart);
125 }
126 
127 void RenderScrollbar::setPressedPart(ScrollbarPart part)
128 {
129     ScrollbarPart oldPart = m_pressedPart;
130     Scrollbar::setPressedPart(part);
131 
132     updateScrollbarPart(oldPart);
133     updateScrollbarPart(part);
134 
135     updateScrollbarPart(ScrollbarBGPart);
136     updateScrollbarPart(TrackBGPart);
137 }
138 
<span class="line-modified">139 std::unique_ptr&lt;RenderStyle&gt; RenderScrollbar::getScrollbarPseudoStyle(ScrollbarPart partType, PseudoId pseudoId) const</span>
140 {
141     if (!owningRenderer())
<span class="line-modified">142         return nullptr;</span>
<span class="line-modified">143 </span>
<span class="line-modified">144     StyleScrollbarState scrollbarState;</span>
<span class="line-added">145     scrollbarState.scrollbarPart = partType;</span>
<span class="line-added">146     scrollbarState.hoveredPart = hoveredPart();</span>
<span class="line-added">147     scrollbarState.pressedPart = pressedPart();</span>
<span class="line-added">148     scrollbarState.orientation = orientation();</span>
<span class="line-added">149     scrollbarState.buttonsPlacement = theme().buttonsPlacement();</span>
<span class="line-added">150     scrollbarState.enabled = enabled();</span>
<span class="line-added">151     scrollbarState.scrollCornerIsVisible = scrollableArea().isScrollCornerVisible();</span>
<span class="line-added">152 </span>
<span class="line-added">153     std::unique_ptr&lt;RenderStyle&gt; result = owningRenderer()-&gt;getUncachedPseudoStyle({ pseudoId, scrollbarState }, &amp;owningRenderer()-&gt;style());</span>
154     // Scrollbars for root frames should always have background color
155     // unless explicitly specified as transparent. So we force it.
156     // This is because WebKit assumes scrollbar to be always painted and missing background
157     // causes visual artifact like non-repainted dirty region.
158     if (result &amp;&amp; m_owningFrame &amp;&amp; m_owningFrame-&gt;view() &amp;&amp; !m_owningFrame-&gt;view()-&gt;isTransparent() &amp;&amp; !result-&gt;hasBackground())
159         result-&gt;setBackgroundColor(Color::white);
160 
161     return result;
162 }
163 
164 void RenderScrollbar::updateScrollbarParts()
165 {
166     updateScrollbarPart(ScrollbarBGPart);
167     updateScrollbarPart(BackButtonStartPart);
168     updateScrollbarPart(ForwardButtonStartPart);
169     updateScrollbarPart(BackTrackPart);
170     updateScrollbarPart(ThumbPart);
171     updateScrollbarPart(ForwardTrackPart);
172     updateScrollbarPart(BackButtonEndPart);
173     updateScrollbarPart(ForwardButtonEndPart);
</pre>
<hr />
<pre>
343 }
344 
345 int RenderScrollbar::minimumThumbLength()
346 {
347     RenderScrollbarPart* partRenderer = m_parts.get(ThumbPart);
348     if (!partRenderer)
349         return 0;
350     partRenderer-&gt;layout();
351     return orientation() == HorizontalScrollbar ? partRenderer-&gt;width() : partRenderer-&gt;height();
352 }
353 
354 float RenderScrollbar::opacity()
355 {
356     RenderScrollbarPart* partRenderer = m_parts.get(ScrollbarBGPart);
357     if (!partRenderer)
358         return 1;
359 
360     return partRenderer-&gt;style().opacity();
361 }
362 
<span class="line-added">363 bool RenderScrollbar::isHiddenByStyle() const</span>
<span class="line-added">364 {</span>
<span class="line-added">365     std::unique_ptr&lt;RenderStyle&gt; partStyle = getScrollbarPseudoStyle(ScrollbarBGPart, pseudoForScrollbarPart(ScrollbarBGPart));</span>
<span class="line-added">366     return partStyle &amp;&amp; partStyle-&gt;display() == DisplayType::None;</span>
<span class="line-added">367 }</span>
<span class="line-added">368 </span>
369 }
</pre>
</td>
</tr>
</table>
<center><a href="RenderReplaced.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderScrollbar.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
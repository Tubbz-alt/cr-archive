<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/style/StyleScopeRuleSets.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 2004-2005 Allan Sandfeld Jensen (kde@carewolf.com)
  4  * Copyright (C) 2006, 2007 Nicholas Shanks (webkit@nickshanks.com)
  5  * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012 Apple Inc. All rights reserved.
  6  * Copyright (C) 2007 Alexey Proskuryakov &lt;ap@webkit.org&gt;
  7  * Copyright (C) 2007, 2008 Eric Seidel &lt;eric@webkit.org&gt;
  8  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  9  * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
 10  * Copyright (C) Research In Motion Limited 2011. All rights reserved.
 11  * Copyright (C) 2013 Google Inc. All rights reserved.
 12  *
 13  * This library is free software; you can redistribute it and/or
 14  * modify it under the terms of the GNU Library General Public
 15  * License as published by the Free Software Foundation; either
 16  * version 2 of the License, or (at your option) any later version.
 17  *
 18  * This library is distributed in the hope that it will be useful,
 19  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 20  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 21  * Library General Public License for more details.
 22  *
 23  * You should have received a copy of the GNU Library General Public License
 24  * along with this library; see the file COPYING.LIB.  If not, write to
 25  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 26  * Boston, MA 02110-1301, USA.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;StyleScopeRuleSets.h&quot;
 31 
 32 #include &quot;CSSStyleSheet.h&quot;
 33 #include &quot;ExtensionStyleSheets.h&quot;
 34 #include &quot;MediaQueryEvaluator.h&quot;
 35 #include &quot;StyleResolver.h&quot;
 36 #include &quot;StyleSheetContents.h&quot;
 37 
 38 namespace WebCore {
 39 namespace Style {
 40 
 41 ScopeRuleSets::ScopeRuleSets(Resolver&amp; styleResolver)
 42     : m_styleResolver(styleResolver)
 43 {
 44     m_authorStyle = RuleSet::create();
 45     m_authorStyle-&gt;disableAutoShrinkToFit();
 46 }
 47 
 48 ScopeRuleSets::~ScopeRuleSets()
 49 {
 50     RELEASE_ASSERT(!m_isInvalidatingStyleWithRuleSets);
 51 }
 52 
 53 RuleSet* ScopeRuleSets::userAgentMediaQueryStyle() const
 54 {
 55     updateUserAgentMediaQueryStyleIfNeeded();
 56     return m_userAgentMediaQueryStyle.get();
 57 }
 58 
 59 void ScopeRuleSets::updateUserAgentMediaQueryStyleIfNeeded() const
 60 {
 61     if (!UserAgentStyle::mediaQueryStyleSheet)
 62         return;
 63 
 64     auto ruleCount = UserAgentStyle::mediaQueryStyleSheet-&gt;ruleCount();
 65     if (m_userAgentMediaQueryStyle &amp;&amp; ruleCount == m_userAgentMediaQueryRuleCountOnUpdate)
 66         return;
 67     m_userAgentMediaQueryRuleCountOnUpdate = ruleCount;
 68 
 69     // Media queries on user agent sheet need to evaluated in document context. They behave like author sheets in this respect.
 70     auto&amp; mediaQueryEvaluator = m_styleResolver.mediaQueryEvaluator();
 71     m_userAgentMediaQueryStyle = RuleSet::create();
 72 
 73     m_userAgentMediaQueryStyle-&gt;addRulesFromSheet(*UserAgentStyle::mediaQueryStyleSheet, nullptr, mediaQueryEvaluator, m_styleResolver);
 74 }
 75 
 76 RuleSet* ScopeRuleSets::userStyle() const
 77 {
 78     if (m_usesSharedUserStyle)
 79         return m_styleResolver.document().styleScope().resolver().ruleSets().userStyle();
 80     return m_userStyle.get();
 81 }
 82 
 83 void ScopeRuleSets::initializeUserStyle()
 84 {
 85     auto&amp; extensionStyleSheets = m_styleResolver.document().extensionStyleSheets();
 86     auto&amp; mediaQueryEvaluator = m_styleResolver.mediaQueryEvaluator();
 87     auto tempUserStyle = RuleSet::create();
 88     if (CSSStyleSheet* pageUserSheet = extensionStyleSheets.pageUserSheet())
 89         tempUserStyle-&gt;addRulesFromSheet(pageUserSheet-&gt;contents(), nullptr, mediaQueryEvaluator, m_styleResolver);
 90     collectRulesFromUserStyleSheets(extensionStyleSheets.injectedUserStyleSheets(), tempUserStyle.get(), mediaQueryEvaluator);
 91     collectRulesFromUserStyleSheets(extensionStyleSheets.documentUserStyleSheets(), tempUserStyle.get(), mediaQueryEvaluator);
 92     if (tempUserStyle-&gt;ruleCount() &gt; 0 || tempUserStyle-&gt;pageRules().size() &gt; 0)
 93         m_userStyle = WTFMove(tempUserStyle);
 94 }
 95 
 96 void ScopeRuleSets::collectRulesFromUserStyleSheets(const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; userSheets, RuleSet&amp; userStyle, const MediaQueryEvaluator&amp; medium)
 97 {
 98     for (unsigned i = 0; i &lt; userSheets.size(); ++i) {
 99         ASSERT(userSheets[i]-&gt;contents().isUserStyleSheet());
100         userStyle.addRulesFromSheet(userSheets[i]-&gt;contents(), nullptr, medium, m_styleResolver);
101     }
102 }
103 
104 static RefPtr&lt;RuleSet&gt; makeRuleSet(const Vector&lt;RuleFeature&gt;&amp; rules)
105 {
106     size_t size = rules.size();
107     if (!size)
108         return nullptr;
109     auto ruleSet = RuleSet::create();
110     for (size_t i = 0; i &lt; size; ++i)
111         ruleSet-&gt;addRule(*rules[i].styleRule, rules[i].selectorIndex, rules[i].selectorListIndex);
112     ruleSet-&gt;shrinkToFit();
113     return ruleSet;
114 }
115 
116 void ScopeRuleSets::resetAuthorStyle()
117 {
118     m_isAuthorStyleDefined = true;
119     m_authorStyle = RuleSet::create();
120     m_authorStyle-&gt;disableAutoShrinkToFit();
121 }
122 
123 void ScopeRuleSets::resetUserAgentMediaQueryStyle()
124 {
125     m_userAgentMediaQueryStyle = nullptr;
126 }
127 
128 bool ScopeRuleSets::hasViewportDependentMediaQueries() const
129 {
130     if (m_authorStyle-&gt;hasViewportDependentMediaQueries())
131         return true;
132     if (m_userStyle &amp;&amp; m_userStyle-&gt;hasViewportDependentMediaQueries())
133         return true;
134     if (m_userAgentMediaQueryStyle &amp;&amp; m_userAgentMediaQueryStyle-&gt;hasViewportDependentMediaQueries())
135         return true;
136 
137     return false;
138 }
139 
140 Optional&lt;DynamicMediaQueryEvaluationChanges&gt; ScopeRuleSets::evaluteDynamicMediaQueryRules(const MediaQueryEvaluator&amp; evaluator)
141 {
142     Optional&lt;DynamicMediaQueryEvaluationChanges&gt; evaluationChanges;
143 
144     auto evaluate = [&amp;](auto* ruleSet) {
145         if (!ruleSet)
146             return;
147         if (auto changes = ruleSet-&gt;evaluteDynamicMediaQueryRules(evaluator)) {
148             if (evaluationChanges)
149                 evaluationChanges-&gt;append(WTFMove(*changes));
150             else
151                 evaluationChanges = changes;
152         }
153     };
154 
155     evaluate(&amp;authorStyle());
156     evaluate(userStyle());
157     evaluate(userAgentMediaQueryStyle());
158 
159     return evaluationChanges;
160 }
161 
162 void ScopeRuleSets::appendAuthorStyleSheets(const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; styleSheets, MediaQueryEvaluator* medium, InspectorCSSOMWrappers&amp; inspectorCSSOMWrappers)
163 {
164     for (auto&amp; cssSheet : styleSheets) {
165         ASSERT(!cssSheet-&gt;disabled());
166         m_authorStyle-&gt;addRulesFromSheet(cssSheet-&gt;contents(), cssSheet-&gt;mediaQueries(), *medium, m_styleResolver);
167         inspectorCSSOMWrappers.collectFromStyleSheetIfNeeded(cssSheet.get());
168     }
169 
170     m_authorStyle-&gt;shrinkToFit();
171     collectFeatures();
172 }
173 
174 void ScopeRuleSets::collectFeatures() const
175 {
176     RELEASE_ASSERT(!m_isInvalidatingStyleWithRuleSets);
177 
178     m_features.clear();
179     // Collect all ids and rules using sibling selectors (:first-child and similar)
180     // in the current set of stylesheets. Style sharing code uses this information to reject
181     // sharing candidates.
182     if (UserAgentStyle::defaultStyle)
183         m_features.add(UserAgentStyle::defaultStyle-&gt;features());
184     m_defaultStyleVersionOnFeatureCollection = UserAgentStyle::defaultStyleVersion;
185 
186     if (auto* userAgentMediaQueryStyle = this-&gt;userAgentMediaQueryStyle())
187         m_features.add(userAgentMediaQueryStyle-&gt;features());
188 
189     if (m_authorStyle)
190         m_features.add(m_authorStyle-&gt;features());
191     if (auto* userStyle = this-&gt;userStyle())
192         m_features.add(userStyle-&gt;features());
193 
194     m_siblingRuleSet = makeRuleSet(m_features.siblingRules);
195     m_uncommonAttributeRuleSet = makeRuleSet(m_features.uncommonAttributeRules);
196 
197     m_classInvalidationRuleSets.clear();
198     m_attributeInvalidationRuleSets.clear();
199     m_cachedHasComplexSelectorsForStyleAttribute = WTF::nullopt;
200 
201     m_features.shrinkToFit();
202 }
203 
204 template&lt;typename RuleFeatureType&gt;
205 static Vector&lt;InvalidationRuleSet&gt;* ensureInvalidationRuleSets(const AtomString&amp; key, HashMap&lt;AtomString, std::unique_ptr&lt;Vector&lt;InvalidationRuleSet&gt;&gt;&gt;&amp; ruleSetMap, const HashMap&lt;AtomString, std::unique_ptr&lt;Vector&lt;RuleFeatureType&gt;&gt;&gt;&amp; ruleFeatures)
206 {
207     return ruleSetMap.ensure(key, [&amp;] () -&gt; std::unique_ptr&lt;Vector&lt;InvalidationRuleSet&gt;&gt; {
208         auto* features = ruleFeatures.get(key);
209         if (!features)
210             return nullptr;
211 
212         std::array&lt;RefPtr&lt;RuleSet&gt;, matchElementCount&gt; matchElementArray;
213         std::array&lt;Vector&lt;const CSSSelector*&gt;, matchElementCount&gt; invalidationSelectorArray;
214         for (auto&amp; feature : *features) {
215             auto arrayIndex = static_cast&lt;unsigned&gt;(*feature.matchElement);
216             auto&amp; ruleSet = matchElementArray[arrayIndex];
217             if (!ruleSet)
218                 ruleSet = RuleSet::create();
219             ruleSet-&gt;addRule(*feature.styleRule, feature.selectorIndex, feature.selectorListIndex);
220             /*if constexpr (std::is_same&lt;RuleFeatureType, RuleFeatureWithInvalidationSelector&gt;::value) {
221                 if (feature.invalidationSelector)
222                     invalidationSelectorArray[arrayIndex].append(feature.invalidationSelector);
223             }*/
224         }
225         auto invalidationRuleSets = makeUnique&lt;Vector&lt;InvalidationRuleSet&gt;&gt;();
226         for (unsigned i = 0; i &lt; matchElementArray.size(); ++i) {
227             if (matchElementArray[i])
228                 invalidationRuleSets-&gt;append({ static_cast&lt;MatchElement&gt;(i), *matchElementArray[i], WTFMove(invalidationSelectorArray[i]) });
229         }
230         return invalidationRuleSets;
231     }).iterator-&gt;value.get();
232 }
233 
234 template&lt;&gt;
235 Vector&lt;InvalidationRuleSet&gt;* ensureInvalidationRuleSets&lt;RuleFeatureWithInvalidationSelector&gt;(const AtomString&amp; key, HashMap&lt;AtomString, std::unique_ptr&lt;Vector&lt;InvalidationRuleSet&gt;&gt;&gt;&amp; ruleSetMap, const HashMap&lt;AtomString, std::unique_ptr&lt;Vector&lt;RuleFeatureWithInvalidationSelector&gt;&gt;&gt;&amp; ruleFeatures)
236 {
237     return ruleSetMap.ensure(key, [&amp;]() -&gt; std::unique_ptr&lt;Vector&lt;InvalidationRuleSet&gt;&gt; {
238         auto* features = ruleFeatures.get(key);
239         if (!features)
240             return nullptr;
241 
242         std::array&lt;RefPtr&lt;RuleSet&gt;, matchElementCount&gt; matchElementArray;
243         std::array&lt;Vector&lt;const CSSSelector*&gt;, matchElementCount&gt; invalidationSelectorArray;
244         for (auto&amp; feature : *features) {
245             auto arrayIndex = static_cast&lt;unsigned&gt;(*feature.matchElement);
246             auto&amp; ruleSet = matchElementArray[arrayIndex];
247             if (!ruleSet)
248                 ruleSet = RuleSet::create();
249             ruleSet-&gt;addRule(*feature.styleRule, feature.selectorIndex, feature.selectorListIndex);
250             // TODO : Visual studio 2017 doesn&#39;t support if constexpr in lamda, once updated to 2019, remove this function and uncomment above function&#39;s code
251             //if constexpr (std::is_same&lt;RuleFeatureType, RuleFeatureWithInvalidationSelector&gt;::value) {
252                 if (feature.invalidationSelector)
253                     invalidationSelectorArray[arrayIndex].append(feature.invalidationSelector);
254             //}
255         }
256         auto invalidationRuleSets = makeUnique&lt;Vector&lt;InvalidationRuleSet&gt;&gt;();
257         for (unsigned i = 0; i &lt; matchElementArray.size(); ++i) {
258             if (matchElementArray[i])
259                 invalidationRuleSets-&gt;append({ static_cast&lt;MatchElement&gt;(i), *matchElementArray[i], WTFMove(invalidationSelectorArray[i]) });
260         }
261         return invalidationRuleSets;
262     }).iterator-&gt;value.get();
263 }
264 
265 const Vector&lt;InvalidationRuleSet&gt;* ScopeRuleSets::classInvalidationRuleSets(const AtomString&amp; className) const
266 {
267     return ensureInvalidationRuleSets(className, m_classInvalidationRuleSets, m_features.classRules);
268 }
269 
270 const Vector&lt;InvalidationRuleSet&gt;* ScopeRuleSets::attributeInvalidationRuleSets(const AtomString&amp; attributeName) const
271 {
272     return ensureInvalidationRuleSets(attributeName, m_attributeInvalidationRuleSets, m_features.attributeRules);
273 }
274 
275 bool ScopeRuleSets::hasComplexSelectorsForStyleAttribute() const
276 {
277     auto compute = [&amp;] {
278         auto* ruleSets = attributeInvalidationRuleSets(HTMLNames::styleAttr-&gt;localName());
279         if (!ruleSets)
280             return false;
281         for (auto&amp; ruleSet : *ruleSets) {
282             if (ruleSet.matchElement != MatchElement::Subject)
283                 return true;
284         }
285         return false;
286     };
287 
288     if (!m_cachedHasComplexSelectorsForStyleAttribute)
289         m_cachedHasComplexSelectorsForStyleAttribute = compute();
290 
291     return *m_cachedHasComplexSelectorsForStyleAttribute;
292 }
293 
294 } // namespace Style
295 } // namespace WebCore
    </pre>
  </body>
</html>
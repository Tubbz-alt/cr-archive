<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3ReduceStrength.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="B3ReduceLoopStrength.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="B3StackmapGenerationParams.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3ReduceStrength.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (C) 2015-2018 Apple Inc. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -88,11 +88,11 @@</span>
  // come second. Add(x, constant) is canonical, while Add(constant, x) is not. If there are no
  // constants then the canonical form involves the lower-indexed value first. Given Add(x, y), it&#39;s
  // canonical if x-&gt;index() &lt;= y-&gt;index().
  
  namespace B3ReduceStrengthInternal {
<span class="udiff-line-modified-removed">- static const bool verbose = false;</span>
<span class="udiff-line-modified-added">+ static constexpr bool verbose = false;</span>
  }
  
  // FIXME: This IntRange stuff should be refactored into a general constant propagator. It&#39;s weird
  // that it&#39;s just sitting here in this file.
  class IntRange {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -389,10 +389,19 @@</span>
              RELEASE_ASSERT_NOT_REACHED();
              return IntRange();
          }
      }
  
<span class="udiff-line-added">+     IntRange zExt32()</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         ASSERT(m_min &gt;= INT32_MIN);</span>
<span class="udiff-line-added">+         ASSERT(m_max &lt;= INT32_MAX);</span>
<span class="udiff-line-added">+         int32_t min = m_min;</span>
<span class="udiff-line-added">+         int32_t max = m_max;</span>
<span class="udiff-line-added">+         return IntRange(static_cast&lt;uint64_t&gt;(static_cast&lt;uint32_t&gt;(min)), static_cast&lt;uint64_t&gt;(static_cast&lt;uint32_t&gt;(max)));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
  private:
      int64_t m_min { 0 };
      int64_t m_max { 0 };
  };
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1031,12 +1040,12 @@</span>
                  break;
              }
  
              // Turn this: BitAnd(value, all-ones)
              // Into this: value.
<span class="udiff-line-modified-removed">-             if ((m_value-&gt;type() == Int64 &amp;&amp; m_value-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint64_t&gt;::max()))</span>
<span class="udiff-line-modified-removed">-                 || (m_value-&gt;type() == Int32 &amp;&amp; m_value-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint32_t&gt;::max()))) {</span>
<span class="udiff-line-modified-added">+             if ((m_value-&gt;type() == Int64 &amp;&amp; m_value-&gt;child(1)-&gt;isInt64(std::numeric_limits&lt;uint64_t&gt;::max()))</span>
<span class="udiff-line-modified-added">+                 || (m_value-&gt;type() == Int32 &amp;&amp; m_value-&gt;child(1)-&gt;isInt32(std::numeric_limits&lt;uint32_t&gt;::max()))) {</span>
                  replaceWithIdentity(m_value-&gt;child(0));
                  break;
              }
  
              // Turn this: BitAnd(64-bit value, 32 ones)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1081,38 +1090,41 @@</span>
              // Turn this: BitAnd(Op(value, constant1), constant2)
              //     where !(constant1 &amp; constant2)
              //       and Op is BitOr or BitXor
              // into this: BitAnd(value, constant2)
              if (m_value-&gt;child(1)-&gt;hasInt()) {
<span class="udiff-line-added">+                 bool replaced = false;</span>
                  int64_t constant2 = m_value-&gt;child(1)-&gt;asInt();
                  switch (m_value-&gt;child(0)-&gt;opcode()) {
                  case BitOr:
                  case BitXor:
                      if (m_value-&gt;child(0)-&gt;child(1)-&gt;hasInt()
                          &amp;&amp; !(m_value-&gt;child(0)-&gt;child(1)-&gt;asInt() &amp; constant2)) {
                          m_value-&gt;child(0) = m_value-&gt;child(0)-&gt;child(0);
                          m_changed = true;
<span class="udiff-line-added">+                         replaced = true;</span>
                          break;
                      }
                      break;
                  default:
                      break;
                  }
<span class="udiff-line-modified-removed">-                 break;</span>
<span class="udiff-line-modified-added">+                 if (replaced)</span>
<span class="udiff-line-added">+                     break;</span>
              }
  
              // Turn this: BitAnd(BitXor(x1, allOnes), BitXor(x2, allOnes)
              // Into this: BitXor(BitOr(x1, x2), allOnes)
              // By applying De Morgan laws
              if (m_value-&gt;child(0)-&gt;opcode() == BitXor
                  &amp;&amp; m_value-&gt;child(1)-&gt;opcode() == BitXor
                  &amp;&amp; ((m_value-&gt;type() == Int64
<span class="udiff-line-modified-removed">-                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint64_t&gt;::max())</span>
<span class="udiff-line-modified-removed">-                         &amp;&amp; m_value-&gt;child(1)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint64_t&gt;::max()))</span>
<span class="udiff-line-modified-added">+                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt64(std::numeric_limits&lt;uint64_t&gt;::max())</span>
<span class="udiff-line-modified-added">+                         &amp;&amp; m_value-&gt;child(1)-&gt;child(1)-&gt;isInt64(std::numeric_limits&lt;uint64_t&gt;::max()))</span>
                      || (m_value-&gt;type() == Int32
<span class="udiff-line-modified-removed">-                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint32_t&gt;::max())</span>
<span class="udiff-line-modified-removed">-                         &amp;&amp; m_value-&gt;child(1)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint32_t&gt;::max())))) {</span>
<span class="udiff-line-modified-added">+                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt32(std::numeric_limits&lt;uint32_t&gt;::max())</span>
<span class="udiff-line-modified-added">+                         &amp;&amp; m_value-&gt;child(1)-&gt;child(1)-&gt;isInt32(std::numeric_limits&lt;uint32_t&gt;::max())))) {</span>
                  Value* bitOr = m_insertionSet.insert&lt;Value&gt;(m_index, BitOr, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), m_value-&gt;child(1)-&gt;child(0));
                  replaceWithNew&lt;Value&gt;(BitXor, m_value-&gt;origin(), bitOr, m_value-&gt;child(1)-&gt;child(1));
                  break;
              }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1121,14 +1133,17 @@</span>
              // This is a variation on the previous optimization, treating c as if it were BitXor(~c, allOnes)
              // It does not reduce the number of operations, but provides some normalization (we try to get BitXor by allOnes at the outermost point), and some chance to float Xors to a place where they might get eliminated.
              if (m_value-&gt;child(0)-&gt;opcode() == BitXor
                  &amp;&amp; m_value-&gt;child(1)-&gt;hasInt()
                  &amp;&amp; ((m_value-&gt;type() == Int64
<span class="udiff-line-modified-removed">-                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint64_t&gt;::max()))</span>
<span class="udiff-line-modified-added">+                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt64(std::numeric_limits&lt;uint64_t&gt;::max()))</span>
                      || (m_value-&gt;type() == Int32
<span class="udiff-line-modified-removed">-                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint32_t&gt;::max())))) {</span>
<span class="udiff-line-modified-removed">-                 Value* bitOr = m_insertionSet.insert&lt;Value&gt;(m_index, BitOr, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), m_value-&gt;child(1)-&gt;bitXorConstant(m_proc, m_value-&gt;child(0)-&gt;child(1)));</span>
<span class="udiff-line-modified-added">+                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt32(std::numeric_limits&lt;uint32_t&gt;::max())))) {</span>
<span class="udiff-line-modified-added">+                 Value* newConstant = m_value-&gt;child(1)-&gt;bitXorConstant(m_proc, m_value-&gt;child(0)-&gt;child(1));</span>
<span class="udiff-line-added">+                 ASSERT(newConstant);</span>
<span class="udiff-line-added">+                 m_insertionSet.insertValue(m_index, newConstant);</span>
<span class="udiff-line-added">+                 Value* bitOr = m_insertionSet.insert&lt;Value&gt;(m_index, BitOr, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), newConstant);</span>
                  replaceWithNew&lt;Value&gt;(BitXor, m_value-&gt;origin(), bitOr, m_value-&gt;child(0)-&gt;child(1));
                  break;
              }
  
              break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1169,27 +1184,27 @@</span>
                  break;
              }
  
              // Turn this: BitOr(value, all-ones)
              // Into this: all-ones.
<span class="udiff-line-modified-removed">-             if ((m_value-&gt;type() == Int64 &amp;&amp; m_value-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint64_t&gt;::max()))</span>
<span class="udiff-line-modified-removed">-                 || (m_value-&gt;type() == Int32 &amp;&amp; m_value-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint32_t&gt;::max()))) {</span>
<span class="udiff-line-modified-added">+             if ((m_value-&gt;type() == Int64 &amp;&amp; m_value-&gt;child(1)-&gt;isInt64(std::numeric_limits&lt;uint64_t&gt;::max()))</span>
<span class="udiff-line-modified-added">+                 || (m_value-&gt;type() == Int32 &amp;&amp; m_value-&gt;child(1)-&gt;isInt32(std::numeric_limits&lt;uint32_t&gt;::max()))) {</span>
                  replaceWithIdentity(m_value-&gt;child(1));
                  break;
              }
  
              // Turn this: BitOr(BitXor(x1, allOnes), BitXor(x2, allOnes)
              // Into this: BitXor(BitAnd(x1, x2), allOnes)
              // By applying De Morgan laws
              if (m_value-&gt;child(0)-&gt;opcode() == BitXor
                  &amp;&amp; m_value-&gt;child(1)-&gt;opcode() == BitXor
                  &amp;&amp; ((m_value-&gt;type() == Int64
<span class="udiff-line-modified-removed">-                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint64_t&gt;::max())</span>
<span class="udiff-line-modified-removed">-                         &amp;&amp; m_value-&gt;child(1)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint64_t&gt;::max()))</span>
<span class="udiff-line-modified-added">+                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt64(std::numeric_limits&lt;uint64_t&gt;::max())</span>
<span class="udiff-line-modified-added">+                         &amp;&amp; m_value-&gt;child(1)-&gt;child(1)-&gt;isInt64(std::numeric_limits&lt;uint64_t&gt;::max()))</span>
                      || (m_value-&gt;type() == Int32
<span class="udiff-line-modified-removed">-                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint32_t&gt;::max())</span>
<span class="udiff-line-modified-removed">-                         &amp;&amp; m_value-&gt;child(1)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint32_t&gt;::max())))) {</span>
<span class="udiff-line-modified-added">+                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt32(std::numeric_limits&lt;uint32_t&gt;::max())</span>
<span class="udiff-line-modified-added">+                         &amp;&amp; m_value-&gt;child(1)-&gt;child(1)-&gt;isInt32(std::numeric_limits&lt;uint32_t&gt;::max())))) {</span>
                  Value* bitAnd = m_insertionSet.insert&lt;Value&gt;(m_index, BitAnd, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), m_value-&gt;child(1)-&gt;child(0));
                  replaceWithNew&lt;Value&gt;(BitXor, m_value-&gt;origin(), bitAnd, m_value-&gt;child(1)-&gt;child(1));
                  break;
              }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1198,14 +1213,17 @@</span>
              // This is a variation on the previous optimization, treating c as if it were BitXor(~c, allOnes)
              // It does not reduce the number of operations, but provides some normalization (we try to get BitXor by allOnes at the outermost point), and some chance to float Xors to a place where they might get eliminated.
              if (m_value-&gt;child(0)-&gt;opcode() == BitXor
                  &amp;&amp; m_value-&gt;child(1)-&gt;hasInt()
                  &amp;&amp; ((m_value-&gt;type() == Int64
<span class="udiff-line-modified-removed">-                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint64_t&gt;::max()))</span>
<span class="udiff-line-modified-added">+                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt64(std::numeric_limits&lt;uint64_t&gt;::max()))</span>
                      || (m_value-&gt;type() == Int32
<span class="udiff-line-modified-removed">-                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt(std::numeric_limits&lt;uint32_t&gt;::max())))) {</span>
<span class="udiff-line-modified-removed">-                 Value* bitAnd = m_insertionSet.insert&lt;Value&gt;(m_index, BitAnd, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), m_value-&gt;child(1)-&gt;bitXorConstant(m_proc, m_value-&gt;child(0)-&gt;child(1)));</span>
<span class="udiff-line-modified-added">+                         &amp;&amp; m_value-&gt;child(0)-&gt;child(1)-&gt;isInt32(std::numeric_limits&lt;uint32_t&gt;::max())))) {</span>
<span class="udiff-line-modified-added">+                 Value* newConstant = m_value-&gt;child(1)-&gt;bitXorConstant(m_proc, m_value-&gt;child(0)-&gt;child(1));</span>
<span class="udiff-line-added">+                 ASSERT(newConstant);</span>
<span class="udiff-line-added">+                 m_insertionSet.insertValue(m_index, newConstant);</span>
<span class="udiff-line-added">+                 Value* bitAnd = m_insertionSet.insert&lt;Value&gt;(m_index, BitAnd, m_value-&gt;origin(), m_value-&gt;child(0)-&gt;child(0), newConstant);</span>
                  replaceWithNew&lt;Value&gt;(BitXor, m_value-&gt;origin(), bitAnd, m_value-&gt;child(0)-&gt;child(1));
                  break;
              }
  
              if (handleBitAndDistributivity())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2091,11 +2109,11 @@</span>
              //
              // The goal of this optimization is to kill a lot of code in one of those basic
              // blocks. This is pretty much guaranteed since one of those blocks will replace all
              // uses of the Select with a constant, and that constant will be transitively used
              // from the check.
<span class="udiff-line-modified-removed">-             static const unsigned selectSpecializationBound = 3;</span>
<span class="udiff-line-modified-added">+             static constexpr unsigned selectSpecializationBound = 3;</span>
              Value* select = findRecentNodeMatching(
                  m_value-&gt;child(0), selectSpecializationBound,
                  [&amp;] (Value* value) -&gt; bool {
                      return value-&gt;opcode() == Select
                          &amp;&amp; (value-&gt;child(1)-&gt;isConstant() &amp;&amp; value-&gt;child(2)-&gt;isConstant());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2275,11 +2293,11 @@</span>
          }
  
          RELEASE_ASSERT(startIndex != UINT_MAX);
  
          // By BasicBlock convention, caseIndex == 0 =&gt; then, caseIndex == 1 =&gt; else.
<span class="udiff-line-modified-removed">-         static const unsigned numCases = 2;</span>
<span class="udiff-line-modified-added">+         static constexpr unsigned numCases = 2;</span>
          BasicBlock* cases[numCases];
          for (unsigned i = 0; i &lt; numCases; ++i)
              cases[i] = m_blockInsertionSet.insertBefore(m_block);
  
          HashMap&lt;Value*, Value*&gt; mappings[2];
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2584,10 +2602,18 @@</span>
  
          case Mul:
              return rangeFor(value-&gt;child(0), timeToLive - 1).mul(
                  rangeFor(value-&gt;child(1), timeToLive - 1), value-&gt;type());
  
<span class="udiff-line-added">+         case SExt8:</span>
<span class="udiff-line-added">+         case SExt16:</span>
<span class="udiff-line-added">+         case SExt32:</span>
<span class="udiff-line-added">+             return rangeFor(value-&gt;child(0), timeToLive - 1);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         case ZExt32:</span>
<span class="udiff-line-added">+             return rangeFor(value-&gt;child(0), timeToLive - 1).zExt32();</span>
<span class="udiff-line-added">+ </span>
          default:
              break;
          }
  
          return IntRange::top(value-&gt;type());
</pre>
<center><a href="B3ReduceLoopStrength.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="B3StackmapGenerationParams.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/disassembler/udis86/udis86_syn-att.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /* udis86 - libudis86/syn-att.c
  2  *
  3  * Copyright (c) 2002-2009 Vivek Thampi
  4  * All rights reserved.
  5  *
  6  * Redistribution and use in source and binary forms, with or without modification,
  7  * are permitted provided that the following conditions are met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright notice,
 10  *       this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above copyright notice,
 12  *       this list of conditions and the following disclaimer in the documentation
 13  *       and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 16  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 17  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 18  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 19  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 20  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 21  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 22  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 24  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 
 29 #if ENABLE(UDIS86)
 30 
 31 #include &quot;udis86_types.h&quot;
 32 #include &quot;udis86_extern.h&quot;
 33 #include &quot;udis86_decode.h&quot;
 34 #include &quot;udis86_itab.h&quot;
 35 #include &quot;udis86_syn.h&quot;
 36 #include &quot;udis86_udint.h&quot;
 37 
 38 /* -----------------------------------------------------------------------------
 39  * opr_cast() - Prints an operand cast.
 40  * -----------------------------------------------------------------------------
 41  */
 42 static void
 43 opr_cast(struct ud* u, struct ud_operand* op)
 44 {
 45   switch(op-&gt;size) {
 46   case 16 : case 32 :
 47     ud_asmprintf(u, &quot;*&quot;);   break;
 48   default: break;
 49   }
 50 }
 51 
 52 /* -----------------------------------------------------------------------------
 53  * gen_operand() - Generates assembly output for each operand.
 54  * -----------------------------------------------------------------------------
 55  */
 56 static void
 57 gen_operand(struct ud* u, struct ud_operand* op)
 58 {
 59   switch(op-&gt;type) {
 60   case UD_OP_CONST:
 61     ud_asmprintf(u, &quot;$0x%x&quot;, op-&gt;lval.udword);
 62     break;
 63 
 64   case UD_OP_REG:
 65     ud_asmprintf(u, &quot;%%%s&quot;, ud_reg_tab[op-&gt;base - UD_R_AL]);
 66     break;
 67 
 68   case UD_OP_MEM:
 69     if (u-&gt;br_far) {
 70         opr_cast(u, op);
 71     }
 72     if (u-&gt;pfx_seg) {
 73       ud_asmprintf(u, &quot;%%%s:&quot;, ud_reg_tab[u-&gt;pfx_seg - UD_R_AL]);
 74     }
 75     if (op-&gt;offset != 0) {
 76       ud_syn_print_mem_disp(u, op, 0);
 77     }
 78     if (op-&gt;base) {
 79       ud_asmprintf(u, &quot;(%%%s&quot;, ud_reg_tab[op-&gt;base - UD_R_AL]);
 80     }
 81     if (op-&gt;index) {
 82       if (op-&gt;base) {
 83         ud_asmprintf(u, &quot;,&quot;);
 84       } else {
 85         ud_asmprintf(u, &quot;(&quot;);
 86       }
 87       ud_asmprintf(u, &quot;%%%s&quot;, ud_reg_tab[op-&gt;index - UD_R_AL]);
 88     }
 89     if (op-&gt;scale) {
 90       ud_asmprintf(u, &quot;,%d&quot;, op-&gt;scale);
 91     }
 92     if (op-&gt;base || op-&gt;index) {
 93       ud_asmprintf(u, &quot;)&quot;);
 94     }
 95     break;
 96 
 97   case UD_OP_IMM:
 98     ud_asmprintf(u, &quot;$&quot;);
 99     ud_syn_print_imm(u, op);
100     break;
101 
102   case UD_OP_JIMM:
103     ud_syn_print_addr(u, ud_syn_rel_target(u, op));
104     break;
105 
106   case UD_OP_PTR:
107     switch (op-&gt;size) {
108       case 32:
109         ud_asmprintf(u, &quot;$0x%x, $0x%x&quot;, op-&gt;lval.ptr.seg,
110           op-&gt;lval.ptr.off &amp; 0xFFFF);
111         break;
112       case 48:
113         ud_asmprintf(u, &quot;$0x%x, $0x%x&quot;, op-&gt;lval.ptr.seg,
114           op-&gt;lval.ptr.off);
115         break;
116     }
117     break;
118 
119   default: return;
120   }
121 }
122 
123 /* =============================================================================
124  * translates to AT&amp;T syntax
125  * =============================================================================
126  */
127 extern void
128 ud_translate_att(struct ud *u)
129 {
130   int size = 0;
131   int star = 0;
132 
133   /* check if P_OSO prefix is used */
134   if (! P_OSO(u-&gt;itab_entry-&gt;prefix) &amp;&amp; u-&gt;pfx_opr) {
135   switch (u-&gt;dis_mode) {
136     case 16:
137       ud_asmprintf(u, &quot;o32 &quot;);
138       break;
139     case 32:
140     case 64:
141       ud_asmprintf(u, &quot;o16 &quot;);
142       break;
143   }
144   }
145 
146   /* check if P_ASO prefix was used */
147   if (! P_ASO(u-&gt;itab_entry-&gt;prefix) &amp;&amp; u-&gt;pfx_adr) {
148   switch (u-&gt;dis_mode) {
149     case 16:
150       ud_asmprintf(u, &quot;a32 &quot;);
151       break;
152     case 32:
153       ud_asmprintf(u, &quot;a16 &quot;);
154       break;
155     case 64:
156       ud_asmprintf(u, &quot;a32 &quot;);
157       break;
158   }
159   }
160 
161   if (u-&gt;pfx_lock)
162     ud_asmprintf(u,  &quot;lock &quot;);
163   if (u-&gt;pfx_rep) {
164     ud_asmprintf(u, &quot;rep &quot;);
165   } else if (u-&gt;pfx_repe) {
166     ud_asmprintf(u, &quot;repe &quot;);
167   } else if (u-&gt;pfx_repne) {
168     ud_asmprintf(u, &quot;repne &quot;);
169   }
170 
171   /* special instructions */
172   switch (u-&gt;mnemonic) {
173   case UD_Iretf:
174     ud_asmprintf(u, &quot;lret &quot;);
175     break;
176   case UD_Idb:
177     ud_asmprintf(u, &quot;.byte 0x%x&quot;, u-&gt;operand[0].lval.ubyte);
178     return;
179   case UD_Ijmp:
180   case UD_Icall:
181     if (u-&gt;br_far) ud_asmprintf(u,  &quot;l&quot;);
182         if (u-&gt;operand[0].type == UD_OP_REG) {
183           star = 1;
184         }
185     ud_asmprintf(u, &quot;%s&quot;, ud_lookup_mnemonic(u-&gt;mnemonic));
186     break;
187   case UD_Ibound:
188   case UD_Ienter:
189     if (u-&gt;operand[0].type != UD_NONE)
190       gen_operand(u, &amp;u-&gt;operand[0]);
191     if (u-&gt;operand[1].type != UD_NONE) {
192       ud_asmprintf(u, &quot;,&quot;);
193       gen_operand(u, &amp;u-&gt;operand[1]);
194     }
195     return;
196   default:
197     ud_asmprintf(u, &quot;%s&quot;, ud_lookup_mnemonic(u-&gt;mnemonic));
198   }
199 
200   if (size == 8) {
201     ud_asmprintf(u, &quot;b&quot;);
202   } else if (size == 16) {
203     ud_asmprintf(u, &quot;w&quot;);
204   } else if (size == 64) {
205     ud_asmprintf(u, &quot;q&quot;);
206   }
207 
208   if (star) {
209     ud_asmprintf(u, &quot; *&quot;);
210   } else {
211     ud_asmprintf(u, &quot; &quot;);
212   }
213 
214   if (u-&gt;operand[3].type != UD_NONE) {
215     gen_operand(u, &amp;u-&gt;operand[3]);
216     ud_asmprintf(u, &quot;, &quot;);
217   }
218   if (u-&gt;operand[2].type != UD_NONE) {
219     gen_operand(u, &amp;u-&gt;operand[2]);
220     ud_asmprintf(u, &quot;, &quot;);
221   }
222   if (u-&gt;operand[1].type != UD_NONE) {
223     gen_operand(u, &amp;u-&gt;operand[1]);
224     ud_asmprintf(u, &quot;, &quot;);
225   }
226   if (u-&gt;operand[0].type != UD_NONE) {
227     gen_operand(u, &amp;u-&gt;operand[0]);
228   }
229 }
230 
231 #endif // ENABLE(UDIS86)
232 
233 /*
234 vim: set ts=2 sw=2 expandtab
235 */
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/AccessCaseSnippetParams.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AccessCase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AdaptiveInferredPropertyValueWatchpointBase.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/AccessCaseSnippetParams.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 38 class SlowPathCallGeneratorWithArguments : public AccessCaseSnippetParams::SlowPathCallGenerator {
 39 public:
 40     SlowPathCallGeneratorWithArguments(JumpType from, CCallHelpers::Label to, FunctionType function, ResultType result, std::tuple&lt;Arguments...&gt; arguments)
 41         : m_from(from)
 42         , m_to(to)
 43         , m_function(function)
 44         , m_result(result)
 45         , m_arguments(arguments)
 46     {
 47     }
 48 
 49     template&lt;size_t... ArgumentsIndex&gt;
 50     CCallHelpers::JumpList generateImpl(AccessGenerationState&amp; state, const RegisterSet&amp; usedRegistersBySnippet, CCallHelpers&amp; jit, std::index_sequence&lt;ArgumentsIndex...&gt;)
 51     {
 52         CCallHelpers::JumpList exceptions;
 53         // We spill (1) the used registers by IC and (2) the used registers by Snippet.
 54         AccessGenerationState::SpillState spillState = state.preserveLiveRegistersToStackForCall(usedRegistersBySnippet);
 55 
 56         jit.store32(
 57             CCallHelpers::TrustedImm32(state.callSiteIndexForExceptionHandlingOrOriginal().bits()),
<span class="line-modified"> 58             CCallHelpers::tagFor(static_cast&lt;VirtualRegister&gt;(CallFrameSlot::argumentCount)));</span>
 59 
 60         jit.makeSpaceOnStackForCCall();
 61 
 62         jit.setupArguments&lt;FunctionType&gt;(std::get&lt;ArgumentsIndex&gt;(m_arguments)...);

 63 
 64         CCallHelpers::Call operationCall = jit.call(OperationPtrTag);
 65         auto function = m_function;
 66         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 67             linkBuffer.link(operationCall, FunctionPtr&lt;OperationPtrTag&gt;(function));
 68         });
 69 
 70         jit.setupResults(m_result);
 71         jit.reclaimSpaceOnStackForCCall();
 72 
 73         CCallHelpers::Jump noException = jit.emitExceptionCheck(state.m_vm, CCallHelpers::InvertedExceptionCheck);
 74 
 75         state.restoreLiveRegistersFromStackForCallWithThrownException(spillState);
 76         exceptions.append(jit.jump());
 77 
 78         noException.link(&amp;jit);
 79         RegisterSet dontRestore;
 80         dontRestore.set(m_result);
 81         state.restoreLiveRegistersFromStackForCall(spillState, dontRestore);
 82 
</pre>
</td>
<td>
<hr />
<pre>
 38 class SlowPathCallGeneratorWithArguments : public AccessCaseSnippetParams::SlowPathCallGenerator {
 39 public:
 40     SlowPathCallGeneratorWithArguments(JumpType from, CCallHelpers::Label to, FunctionType function, ResultType result, std::tuple&lt;Arguments...&gt; arguments)
 41         : m_from(from)
 42         , m_to(to)
 43         , m_function(function)
 44         , m_result(result)
 45         , m_arguments(arguments)
 46     {
 47     }
 48 
 49     template&lt;size_t... ArgumentsIndex&gt;
 50     CCallHelpers::JumpList generateImpl(AccessGenerationState&amp; state, const RegisterSet&amp; usedRegistersBySnippet, CCallHelpers&amp; jit, std::index_sequence&lt;ArgumentsIndex...&gt;)
 51     {
 52         CCallHelpers::JumpList exceptions;
 53         // We spill (1) the used registers by IC and (2) the used registers by Snippet.
 54         AccessGenerationState::SpillState spillState = state.preserveLiveRegistersToStackForCall(usedRegistersBySnippet);
 55 
 56         jit.store32(
 57             CCallHelpers::TrustedImm32(state.callSiteIndexForExceptionHandlingOrOriginal().bits()),
<span class="line-modified"> 58             CCallHelpers::tagFor(CallFrameSlot::argumentCountIncludingThis));</span>
 59 
 60         jit.makeSpaceOnStackForCCall();
 61 
 62         jit.setupArguments&lt;FunctionType&gt;(std::get&lt;ArgumentsIndex&gt;(m_arguments)...);
<span class="line-added"> 63         jit.prepareCallOperation(state.m_vm);</span>
 64 
 65         CCallHelpers::Call operationCall = jit.call(OperationPtrTag);
 66         auto function = m_function;
 67         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 68             linkBuffer.link(operationCall, FunctionPtr&lt;OperationPtrTag&gt;(function));
 69         });
 70 
 71         jit.setupResults(m_result);
 72         jit.reclaimSpaceOnStackForCCall();
 73 
 74         CCallHelpers::Jump noException = jit.emitExceptionCheck(state.m_vm, CCallHelpers::InvertedExceptionCheck);
 75 
 76         state.restoreLiveRegistersFromStackForCallWithThrownException(spillState);
 77         exceptions.append(jit.jump());
 78 
 79         noException.link(&amp;jit);
 80         RegisterSet dontRestore;
 81         dontRestore.set(m_result);
 82         state.restoreLiveRegistersFromStackForCall(spillState, dontRestore);
 83 
</pre>
</td>
</tr>
</table>
<center><a href="AccessCase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AdaptiveInferredPropertyValueWatchpointBase.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
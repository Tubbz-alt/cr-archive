<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/layout/layouttree/LayoutBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../inlineformatting/text/TextUtil.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="LayoutBox.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/layouttree/LayoutBox.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,52 ***</span>
  #include &quot;config.h&quot;
  #include &quot;LayoutBox.h&quot;
  
  #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  
  #include &quot;LayoutContainer.h&quot;
  #include &quot;LayoutPhase.h&quot;
  #include &quot;RenderStyle.h&quot;
  #include &lt;wtf/IsoMallocInlines.h&gt;
  
  namespace WebCore {
  namespace Layout {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(Box);
  
<span class="line-modified">! Box::Box(Optional&lt;ElementAttributes&gt; attributes, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)</span>
      : m_style(WTFMove(style))
      , m_elementAttributes(attributes)
      , m_baseTypeFlags(baseTypeFlags)
      , m_hasRareData(false)
      , m_isAnonymous(false)
  {
      if (isReplaced())
          ensureRareData().replaced = makeUnique&lt;Replaced&gt;(*this);
  }
  
  Box::Box(Optional&lt;ElementAttributes&gt; attributes, RenderStyle&amp;&amp; style)
<span class="line-modified">!     : Box(attributes, WTFMove(style), BaseTypeFlag::BoxFlag)</span>
  {
  }
  
<span class="line-modified">! Box::Box(String textContent, RenderStyle&amp;&amp; style)</span>
<span class="line-modified">!     : Box({ }, WTFMove(style), BaseTypeFlag::BoxFlag)</span>
  {
<span class="line-modified">!     setTextContent(textContent);</span>
  }
  
  Box::~Box()
  {
<span class="line-modified">!     removeRareData();</span>
  }
  
  bool Box::establishesFormattingContext() const
  {
      // We need the final tree structure to tell whether a box establishes a certain formatting context.
      ASSERT(!Phase::isInTreeBuilding());
<span class="line-modified">!     return establishesBlockFormattingContext() || establishesInlineFormattingContext() || establishesTableFormattingContext();</span>
  }
  
  bool Box::establishesBlockFormattingContext() const
  {
      // Initial Containing Block always creates a new (inital) block formatting context.
<span class="line-new-header">--- 26,61 ---</span>
  #include &quot;config.h&quot;
  #include &quot;LayoutBox.h&quot;
  
  #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  
<span class="line-added">+ #include &quot;DisplayBox.h&quot;</span>
  #include &quot;LayoutContainer.h&quot;
  #include &quot;LayoutPhase.h&quot;
<span class="line-added">+ #include &quot;LayoutState.h&quot;</span>
  #include &quot;RenderStyle.h&quot;
  #include &lt;wtf/IsoMallocInlines.h&gt;
  
  namespace WebCore {
  namespace Layout {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(Box);
  
<span class="line-modified">! Box::Box(Optional&lt;ElementAttributes&gt; attributes, Optional&lt;TextContext&gt; textContext, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)</span>
      : m_style(WTFMove(style))
      , m_elementAttributes(attributes)
<span class="line-added">+     , m_textContext(textContext)</span>
      , m_baseTypeFlags(baseTypeFlags)
      , m_hasRareData(false)
      , m_isAnonymous(false)
  {
      if (isReplaced())
          ensureRareData().replaced = makeUnique&lt;Replaced&gt;(*this);
  }
  
  Box::Box(Optional&lt;ElementAttributes&gt; attributes, RenderStyle&amp;&amp; style)
<span class="line-modified">!     : Box(attributes, { }, WTFMove(style), BaseTypeFlag::BoxFlag)</span>
  {
  }
  
<span class="line-modified">! Box::Box(TextContext&amp;&amp; textContext, RenderStyle&amp;&amp; style)</span>
<span class="line-modified">!     : Box({ }, WTFMove(textContext), WTFMove(style), BaseTypeFlag::BoxFlag)</span>
  {
<span class="line-modified">!     ASSERT(isInlineLevelBox());</span>
  }
  
  Box::~Box()
  {
<span class="line-modified">!     if (UNLIKELY(m_hasRareData))</span>
<span class="line-added">+         removeRareData();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Box::updateStyle(const RenderStyle&amp; newStyle)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_style = RenderStyle::clone(newStyle);</span>
  }
  
  bool Box::establishesFormattingContext() const
  {
      // We need the final tree structure to tell whether a box establishes a certain formatting context.
      ASSERT(!Phase::isInTreeBuilding());
<span class="line-modified">!     return establishesBlockFormattingContext() || establishesInlineFormattingContext() || establishesTableFormattingContext() || establishesIndependentFormattingContext();</span>
  }
  
  bool Box::establishesBlockFormattingContext() const
  {
      // Initial Containing Block always creates a new (inital) block formatting context.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 89,10 ***</span>
<span class="line-new-header">--- 98,13 ---</span>
          return true;
  
      if (isBlockLevelBox() &amp;&amp; !isOverflowVisible())
          return true;
  
<span class="line-added">+     if (isTableWrapperBox())</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+ </span>
      return false;
  }
  
  bool Box::establishesInlineFormattingContext() const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 110,23 ***</span>
  
      // It&#39;s enough to check the first in-flow child since we can&#39;t have both block and inline level sibling boxes.
      return downcast&lt;Container&gt;(*this).firstInFlowChild()-&gt;isInlineLevelBox();
  }
  
<span class="line-removed">- bool Box::establishesInlineFormattingContextOnly() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return establishesInlineFormattingContext() &amp;&amp; !establishesBlockFormattingContext();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  bool Box::establishesTableFormattingContext() const
  {
      return isTableBox();
  }
  
<span class="line-modified">! bool Box::establishesBlockFormattingContextOnly() const</span>
  {
<span class="line-modified">!     return establishesBlockFormattingContext() &amp;&amp; !establishesInlineFormattingContext();</span>
  }
  
  bool Box::isRelativelyPositioned() const
  {
      return m_style.position() == PositionType::Relative;
<span class="line-new-header">--- 122,19 ---</span>
  
      // It&#39;s enough to check the first in-flow child since we can&#39;t have both block and inline level sibling boxes.
      return downcast&lt;Container&gt;(*this).firstInFlowChild()-&gt;isInlineLevelBox();
  }
  
  bool Box::establishesTableFormattingContext() const
  {
      return isTableBox();
  }
  
<span class="line-modified">! bool Box::establishesIndependentFormattingContext() const</span>
  {
<span class="line-modified">!     // FIXME: This is where we would check for &#39;contain&#39; property.</span>
<span class="line-added">+     return isAbsolutelyPositioned();</span>
  }
  
  bool Box::isRelativelyPositioned() const
  {
      return m_style.position() == PositionType::Relative;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 174,30 ***</span>
      return m_style.clear() != Clear::None;
  }
  
  bool Box::isFloatAvoider() const
  {
<span class="line-modified">!     return establishesBlockFormattingContext() || isFloatingPositioned();</span>
  }
  
  const Container* Box::containingBlock() const
  {
      // Finding the containing block by traversing the tree during tree construction could provide incorrect result.
      ASSERT(!Phase::isInTreeBuilding());
      // The containing block in which the root element lives is a rectangle called the initial containing block.
      // For other elements, if the element&#39;s position is &#39;relative&#39; or &#39;static&#39;, the containing block is formed by the
<span class="line-modified">!     // content edge of the nearest block container ancestor box.</span>
      // If the element has &#39;position: fixed&#39;, the containing block is established by the viewport
      // If the element has &#39;position: absolute&#39;, the containing block is established by the nearest ancestor with a
      // &#39;position&#39; of &#39;absolute&#39;, &#39;relative&#39; or &#39;fixed&#39;.
      if (!parent())
          return nullptr;
  
      if (!isPositioned() || isInFlowPositioned()) {
<span class="line-modified">!         auto* nearestBlockContainer = parent();</span>
<span class="line-modified">!         for (; nearestBlockContainer-&gt;parent() &amp;&amp; !nearestBlockContainer-&gt;isBlockContainerBox(); nearestBlockContainer = nearestBlockContainer-&gt;parent()) { }</span>
<span class="line-modified">!         return nearestBlockContainer;</span>
      }
  
      if (isFixedPositioned()) {
          auto* ancestor = parent();
          for (; ancestor-&gt;parent() &amp;&amp; !ancestor-&gt;style().hasTransform(); ancestor = ancestor-&gt;parent()) { }
<span class="line-new-header">--- 182,35 ---</span>
      return m_style.clear() != Clear::None;
  }
  
  bool Box::isFloatAvoider() const
  {
<span class="line-modified">!     return (establishesBlockFormattingContext() &amp;&amp; !establishesInlineFormattingContext())</span>
<span class="line-added">+         || establishesTableFormattingContext() || establishesIndependentFormattingContext() || hasFloatClear();</span>
  }
  
  const Container* Box::containingBlock() const
  {
      // Finding the containing block by traversing the tree during tree construction could provide incorrect result.
      ASSERT(!Phase::isInTreeBuilding());
      // The containing block in which the root element lives is a rectangle called the initial containing block.
      // For other elements, if the element&#39;s position is &#39;relative&#39; or &#39;static&#39;, the containing block is formed by the
<span class="line-modified">!     // content edge of the nearest block container ancestor box or which establishes a formatting context.</span>
      // If the element has &#39;position: fixed&#39;, the containing block is established by the viewport
      // If the element has &#39;position: absolute&#39;, the containing block is established by the nearest ancestor with a
      // &#39;position&#39; of &#39;absolute&#39;, &#39;relative&#39; or &#39;fixed&#39;.
      if (!parent())
          return nullptr;
  
      if (!isPositioned() || isInFlowPositioned()) {
<span class="line-modified">!         for (auto* nearestBlockContainerOrFormattingContextRoot = parent(); nearestBlockContainerOrFormattingContextRoot; nearestBlockContainerOrFormattingContextRoot = nearestBlockContainerOrFormattingContextRoot-&gt;parent()) {</span>
<span class="line-modified">!             if (nearestBlockContainerOrFormattingContextRoot-&gt;isBlockContainerBox() || nearestBlockContainerOrFormattingContextRoot-&gt;establishesFormattingContext())</span>
<span class="line-modified">!                 return nearestBlockContainerOrFormattingContextRoot;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         // We should always manage to find the ICB.</span>
<span class="line-added">+         ASSERT_NOT_REACHED();</span>
<span class="line-added">+         return nullptr;</span>
      }
  
      if (isFixedPositioned()) {
          auto* ancestor = parent();
          for (; ancestor-&gt;parent() &amp;&amp; !ancestor-&gt;style().hasTransform(); ancestor = ancestor-&gt;parent()) { }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 270,22 ***</span>
  bool Box::isInlineBlockBox() const
  {
      return m_style.display() == DisplayType::InlineBlock;
  }
  
  bool Box::isBlockLevelBox() const
  {
      // Block level elements generate block level boxes.
      auto display = m_style.display();
<span class="line-modified">!     return display == DisplayType::Block || display == DisplayType::ListItem || (display == DisplayType::Table &amp;&amp; !isTableWrapperBox());</span>
  }
  
  bool Box::isInlineLevelBox() const
  {
      // Inline level elements generate inline level boxes.
      auto display = m_style.display();
<span class="line-modified">!     return display == DisplayType::Inline || isInlineBlockBox() || display == DisplayType::InlineTable;</span>
  }
  
  bool Box::isBlockContainerBox() const
  {
      auto display = m_style.display();
<span class="line-new-header">--- 283,41 ---</span>
  bool Box::isInlineBlockBox() const
  {
      return m_style.display() == DisplayType::InlineBlock;
  }
  
<span class="line-added">+ bool Box::isInlineTableBox() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return m_style.display() == DisplayType::InlineTable;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool Box::isBlockLevelBox() const
  {
      // Block level elements generate block level boxes.
      auto display = m_style.display();
<span class="line-modified">!     return display == DisplayType::Block || display == DisplayType::ListItem || display == DisplayType::Table;</span>
  }
  
  bool Box::isInlineLevelBox() const
  {
      // Inline level elements generate inline level boxes.
      auto display = m_style.display();
<span class="line-modified">!     return display == DisplayType::Inline || isInlineBlockBox() || isInlineTableBox();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool Box::isInlineBox() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // An inline box is one that is both inline-level and whose contents participate in its containing inline formatting context.</span>
<span class="line-added">+     // A non-replaced element with a &#39;display&#39; value of &#39;inline&#39; generates an inline box.</span>
<span class="line-added">+     return m_style.display() == DisplayType::Inline &amp;&amp; !isReplaced();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool Box::isAtomicInlineLevelBox() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // Inline-level boxes that are not inline boxes (such as replaced inline-level elements, inline-block elements, and inline-table elements)</span>
<span class="line-added">+     // are called atomic inline-level boxes because they participate in their inline formatting context as a single opaque box.</span>
<span class="line-added">+     return isInlineLevelBox() &amp;&amp; !isInlineBox();</span>
  }
  
  bool Box::isBlockContainerBox() const
  {
      auto display = m_style.display();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 364,36 ***</span>
      // 8.4 Padding properties:
      // Applies to: all elements except table-row-group, table-header-group, table-footer-group, table-row, table-column-group and table-column
      if (isAnonymous())
          return false;
  
<span class="line-modified">!     auto elementType = m_elementAttributes.value().elementType;</span>
<span class="line-modified">!     return elementType != ElementType::TableHeaderGroup</span>
<span class="line-modified">!         &amp;&amp; elementType != ElementType::TableBodyGroup</span>
<span class="line-modified">!         &amp;&amp; elementType != ElementType::TableFooterGroup</span>
<span class="line-modified">!         &amp;&amp; elementType != ElementType::TableRow</span>
<span class="line-modified">!         &amp;&amp; elementType != ElementType::TableColumnGroup</span>
<span class="line-removed">-         &amp;&amp; elementType != ElementType::TableColumn;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Box::setTextContent(String textContent)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isInlineLevelBox());</span>
<span class="line-removed">-     ensureRareData().textContent = textContent;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool Box::hasTextContent() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isInlineLevelBox());</span>
<span class="line-removed">-     return hasRareData() &amp;&amp; !rareData().textContent.isNull();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- String Box::textContent() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(hasRareData());</span>
<span class="line-removed">-     ASSERT(isInlineLevelBox());</span>
<span class="line-removed">-     return rareData().textContent;</span>
  }
  
  const Replaced* Box::replaced() const
  {
      return const_cast&lt;Box*&gt;(this)-&gt;replaced();
<span class="line-new-header">--- 396,16 ---</span>
      // 8.4 Padding properties:
      // Applies to: all elements except table-row-group, table-header-group, table-footer-group, table-row, table-column-group and table-column
      if (isAnonymous())
          return false;
  
<span class="line-modified">!     return !isTableHeader()</span>
<span class="line-modified">!         &amp;&amp; !isTableBody()</span>
<span class="line-modified">!         &amp;&amp; !isTableFooter()</span>
<span class="line-modified">!         &amp;&amp; !isTableRow()</span>
<span class="line-modified">!         &amp;&amp; !isTableColumnGroup()</span>
<span class="line-modified">!         &amp;&amp; !isTableColumn();</span>
  }
  
  const Replaced* Box::replaced() const
  {
      return const_cast&lt;Box*&gt;(this)-&gt;replaced();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 431,10 ***</span>
<span class="line-new-header">--- 443,29 ---</span>
      if (!hasRareData())
          return 1;
      return rareData().columnSpan;
  }
  
<span class="line-added">+ void Box::setColumnWidth(LayoutUnit columnWidth)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ensureRareData().columnWidth = columnWidth;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Optional&lt;LayoutUnit&gt; Box::columnWidth() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!hasRareData())</span>
<span class="line-added">+         return { };</span>
<span class="line-added">+     return rareData().columnWidth;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Box::setCachedDisplayBoxForLayoutState(LayoutState&amp; layoutState, std::unique_ptr&lt;Display::Box&gt; box) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(!m_cachedLayoutState);</span>
<span class="line-added">+     m_cachedLayoutState = makeWeakPtr(layoutState);</span>
<span class="line-added">+     m_cachedDisplayBoxForLayoutState = WTFMove(box);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  Box::RareDataMap&amp; Box::rareDataMap()
  {
      static NeverDestroyed&lt;RareDataMap&gt; map;
      return map;
  }
</pre>
<center><a href="../inlineformatting/text/TextUtil.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="LayoutBox.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
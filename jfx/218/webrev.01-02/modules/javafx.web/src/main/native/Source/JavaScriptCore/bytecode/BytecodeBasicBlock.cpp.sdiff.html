<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeBasicBlock.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ByValInfo.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeBasicBlock.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeBasicBlock.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;BytecodeBasicBlock.h&quot;
 28 
 29 #include &quot;CodeBlock.h&quot;
 30 #include &quot;InterpreterInlines.h&quot;
 31 #include &quot;JSCInlines.h&quot;
 32 #include &quot;PreciseJumpTargets.h&quot;

 33 
 34 namespace JSC {
 35 























 36 void BytecodeBasicBlock::shrinkToFit()
 37 {
<span class="line-modified"> 38     m_offsets.shrinkToFit();</span>
 39     m_successors.shrinkToFit();
 40 }
 41 
 42 static bool isJumpTarget(OpcodeID opcodeID, const Vector&lt;InstructionStream::Offset, 32&gt;&amp; jumpTargets, unsigned bytecodeOffset)
 43 {
 44     if (opcodeID == op_catch)
 45         return true;
 46 
 47     return std::binary_search(jumpTargets.begin(), jumpTargets.end(), bytecodeOffset);
 48 }
 49 
 50 template&lt;typename Block&gt;
<span class="line-modified"> 51 void BytecodeBasicBlock::computeImpl(Block* codeBlock, const InstructionStream&amp; instructions, Vector&lt;std::unique_ptr&lt;BytecodeBasicBlock&gt;&gt;&amp; basicBlocks)</span>
 52 {

 53     Vector&lt;InstructionStream::Offset, 32&gt; jumpTargets;
 54     computePreciseJumpTargets(codeBlock, instructions, jumpTargets);
 55 
<span class="line-modified"> 56     auto appendBlock = [&amp;] (std::unique_ptr&lt;BytecodeBasicBlock&gt;&amp;&amp; block) {</span>
<span class="line-modified"> 57         block-&gt;m_index = basicBlocks.size();</span>
<span class="line-removed"> 58         basicBlocks.append(WTFMove(block));</span>
<span class="line-removed"> 59     };</span>
<span class="line-removed"> 60 </span>
<span class="line-removed"> 61     auto linkBlocks = [&amp;] (BytecodeBasicBlock* from, BytecodeBasicBlock* to) {</span>
<span class="line-removed"> 62         from-&gt;addSuccessor(to);</span>
 63     };
 64 
<span class="line-modified"> 65     // Create the entry and exit basic blocks.</span>
<span class="line-modified"> 66     basicBlocks.reserveCapacity(jumpTargets.size() + 2);</span>
<span class="line-modified"> 67 </span>
<span class="line-modified"> 68     auto entry = makeUnique&lt;BytecodeBasicBlock&gt;(BytecodeBasicBlock::EntryBlock);</span>
<span class="line-modified"> 69     auto firstBlock = makeUnique&lt;BytecodeBasicBlock&gt;(BytecodeBasicBlock::EntryBlock);</span>
<span class="line-modified"> 70     linkBlocks(entry.get(), firstBlock.get());</span>




 71 
<span class="line-modified"> 72     appendBlock(WTFMove(entry));</span>
<span class="line-modified"> 73     BytecodeBasicBlock* current = firstBlock.get();</span>
<span class="line-modified"> 74     appendBlock(WTFMove(firstBlock));</span>






 75 
<span class="line-modified"> 76     auto exit = makeUnique&lt;BytecodeBasicBlock&gt;(BytecodeBasicBlock::ExitBlock);</span>






 77 
<span class="line-modified"> 78     bool nextInstructionIsLeader = false;</span>


 79 
<span class="line-modified"> 80     for (const auto&amp; instruction : instructions) {</span>
<span class="line-modified"> 81         auto bytecodeOffset = instruction.offset();</span>
<span class="line-removed"> 82         OpcodeID opcodeID = instruction-&gt;opcodeID();</span>
 83 
<span class="line-modified"> 84         bool createdBlock = false;</span>
<span class="line-modified"> 85         // If the current bytecode is a jump target, then it&#39;s the leader of its own basic block.</span>
<span class="line-removed"> 86         if (isJumpTarget(opcodeID, jumpTargets, bytecodeOffset) || nextInstructionIsLeader) {</span>
<span class="line-removed"> 87             auto newBlock = makeUnique&lt;BytecodeBasicBlock&gt;(instruction);</span>
<span class="line-removed"> 88             current = newBlock.get();</span>
<span class="line-removed"> 89             appendBlock(WTFMove(newBlock));</span>
<span class="line-removed"> 90             createdBlock = true;</span>
<span class="line-removed"> 91             nextInstructionIsLeader = false;</span>
 92         }
<span class="line-modified"> 93 </span>
<span class="line-modified"> 94         // If the current bytecode is a branch or a return, then the next instruction is the leader of its own basic block.</span>
<span class="line-modified"> 95         if (isBranch(opcodeID) || isTerminal(opcodeID) || isThrow(opcodeID))</span>
<span class="line-modified"> 96             nextInstructionIsLeader = true;</span>
<span class="line-removed"> 97 </span>
<span class="line-removed"> 98         if (createdBlock)</span>
<span class="line-removed"> 99             continue;</span>
<span class="line-removed">100 </span>
<span class="line-removed">101         // Otherwise, just add to the length of the current block.</span>
<span class="line-removed">102         current-&gt;addLength(instruction-&gt;size());</span>
103     }

104 
105     // Link basic blocks together.
106     for (unsigned i = 0; i &lt; basicBlocks.size(); i++) {
<span class="line-modified">107         BytecodeBasicBlock* block = basicBlocks[i].get();</span>
108 
<span class="line-modified">109         if (block-&gt;isEntryBlock() || block-&gt;isExitBlock())</span>
110             continue;
111 
112         bool fallsThrough = true;
<span class="line-modified">113         for (auto bytecodeOffset : block-&gt;offsets()) {</span>
<span class="line-modified">114             auto instruction = instructions.at(bytecodeOffset);</span>
115             OpcodeID opcodeID = instruction-&gt;opcodeID();
116 


117             // If we found a terminal bytecode, link to the exit block.
118             if (isTerminal(opcodeID)) {
<span class="line-modified">119                 ASSERT(bytecodeOffset + instruction-&gt;size() == block-&gt;leaderOffset() + block-&gt;totalLength());</span>
<span class="line-modified">120                 linkBlocks(block, exit.get());</span>
121                 fallsThrough = false;
122                 break;
123             }
124 
125             // If we found a throw, get the HandlerInfo for this instruction to see where we will jump.
126             // If there isn&#39;t one, treat this throw as a terminal. This is true even if we have a finally
127             // block because the finally block will create its own catch, which will generate a HandlerInfo.
128             if (isThrow(opcodeID)) {
<span class="line-modified">129                 ASSERT(bytecodeOffset + instruction-&gt;size() == block-&gt;leaderOffset() + block-&gt;totalLength());</span>
<span class="line-modified">130                 auto* handler = codeBlock-&gt;handlerForBytecodeOffset(instruction.offset());</span>
131                 fallsThrough = false;
132                 if (!handler) {
<span class="line-modified">133                     linkBlocks(block, exit.get());</span>
134                     break;
135                 }
<span class="line-modified">136                 for (unsigned i = 0; i &lt; basicBlocks.size(); i++) {</span>
<span class="line-modified">137                     BytecodeBasicBlock* otherBlock = basicBlocks[i].get();</span>
<span class="line-removed">138                     if (handler-&gt;target == otherBlock-&gt;leaderOffset()) {</span>
139                         linkBlocks(block, otherBlock);
140                         break;
141                     }
142                 }
143                 break;
144             }
145 
146             // If we found a branch, link to the block(s) that we jump to.
147             if (isBranch(opcodeID)) {
<span class="line-modified">148                 ASSERT(bytecodeOffset + instruction-&gt;size() == block-&gt;leaderOffset() + block-&gt;totalLength());</span>
149                 Vector&lt;InstructionStream::Offset, 1&gt; bytecodeOffsetsJumpedTo;
150                 findJumpTargetsForInstruction(codeBlock, instruction, bytecodeOffsetsJumpedTo);
151 
152                 size_t numberOfJumpTargets = bytecodeOffsetsJumpedTo.size();
153                 ASSERT(numberOfJumpTargets);
<span class="line-modified">154                 for (unsigned i = 0; i &lt; basicBlocks.size(); i++) {</span>
<span class="line-modified">155                     BytecodeBasicBlock* otherBlock = basicBlocks[i].get();</span>
<span class="line-removed">156                     if (bytecodeOffsetsJumpedTo.contains(otherBlock-&gt;leaderOffset())) {</span>
157                         linkBlocks(block, otherBlock);
158                         --numberOfJumpTargets;
159                         if (!numberOfJumpTargets)
160                             break;
161                     }
162                 }
163                 // numberOfJumpTargets may not be 0 here if there are multiple jumps targeting the same
164                 // basic blocks (e.g. in a switch type opcode). Since we only decrement numberOfJumpTargets
165                 // once per basic block, the duplicates are not accounted for. For our purpose here,
166                 // that doesn&#39;t matter because we only need to link to the target block once regardless
167                 // of how many ways this block can jump there.
168 
169                 if (isUnconditionalBranch(opcodeID))
170                     fallsThrough = false;
171 
172                 break;
173             }
174         }
175 
176         // If we fall through then link to the next block in program order.
177         if (fallsThrough) {
178             ASSERT(i + 1 &lt; basicBlocks.size());
<span class="line-modified">179             BytecodeBasicBlock* nextBlock = basicBlocks[i + 1].get();</span>
180             linkBlocks(block, nextBlock);
181         }
182     }
183 
<span class="line-modified">184     appendBlock(WTFMove(exit));</span>




185 
<span class="line-modified">186     for (auto&amp; basicBlock : basicBlocks)</span>
<span class="line-removed">187         basicBlock-&gt;shrinkToFit();</span>
188 }
189 
<span class="line-modified">190 void BytecodeBasicBlock::compute(CodeBlock* codeBlock, const InstructionStream&amp; instructions, Vector&lt;std::unique_ptr&lt;BytecodeBasicBlock&gt;&gt;&amp; basicBlocks)</span>
191 {
<span class="line-modified">192     computeImpl(codeBlock, instructions, basicBlocks);</span>
193 }
194 
<span class="line-modified">195 void BytecodeBasicBlock::compute(UnlinkedCodeBlock* codeBlock, const InstructionStream&amp; instructions, Vector&lt;std::unique_ptr&lt;BytecodeBasicBlock&gt;&gt;&amp; basicBlocks)</span>
196 {
<span class="line-modified">197     computeImpl(codeBlock, instructions, basicBlocks);</span>
198 }
199 
200 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;BytecodeBasicBlock.h&quot;
 28 
 29 #include &quot;CodeBlock.h&quot;
 30 #include &quot;InterpreterInlines.h&quot;
 31 #include &quot;JSCInlines.h&quot;
 32 #include &quot;PreciseJumpTargets.h&quot;
<span class="line-added"> 33 #include &quot;UnlinkedCodeBlockGenerator.h&quot;</span>
 34 
 35 namespace JSC {
 36 
<span class="line-added"> 37 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(BytecodeBasicBlock);</span>
<span class="line-added"> 38 </span>
<span class="line-added"> 39 BytecodeBasicBlock::BytecodeBasicBlock(const InstructionStream::Ref&amp; instruction, unsigned blockIndex)</span>
<span class="line-added"> 40     : m_leaderOffset(instruction.offset())</span>
<span class="line-added"> 41     , m_totalLength(0)</span>
<span class="line-added"> 42     , m_index(blockIndex)</span>
<span class="line-added"> 43 {</span>
<span class="line-added"> 44     addLength(instruction-&gt;size());</span>
<span class="line-added"> 45 }</span>
<span class="line-added"> 46 </span>
<span class="line-added"> 47 BytecodeBasicBlock::BytecodeBasicBlock(BytecodeBasicBlock::SpecialBlockType blockType, unsigned blockIndex)</span>
<span class="line-added"> 48     : m_leaderOffset(blockType == BytecodeBasicBlock::EntryBlock ? 0 : UINT_MAX)</span>
<span class="line-added"> 49     , m_totalLength(blockType == BytecodeBasicBlock::EntryBlock ? 0 : UINT_MAX)</span>
<span class="line-added"> 50     , m_index(blockIndex)</span>
<span class="line-added"> 51 {</span>
<span class="line-added"> 52 }</span>
<span class="line-added"> 53 </span>
<span class="line-added"> 54 void BytecodeBasicBlock::addLength(unsigned bytecodeLength)</span>
<span class="line-added"> 55 {</span>
<span class="line-added"> 56     m_delta.append(bytecodeLength);</span>
<span class="line-added"> 57     m_totalLength += bytecodeLength;</span>
<span class="line-added"> 58 }</span>
<span class="line-added"> 59 </span>
 60 void BytecodeBasicBlock::shrinkToFit()
 61 {
<span class="line-modified"> 62     m_delta.shrinkToFit();</span>
 63     m_successors.shrinkToFit();
 64 }
 65 
 66 static bool isJumpTarget(OpcodeID opcodeID, const Vector&lt;InstructionStream::Offset, 32&gt;&amp; jumpTargets, unsigned bytecodeOffset)
 67 {
 68     if (opcodeID == op_catch)
 69         return true;
 70 
 71     return std::binary_search(jumpTargets.begin(), jumpTargets.end(), bytecodeOffset);
 72 }
 73 
 74 template&lt;typename Block&gt;
<span class="line-modified"> 75 auto BytecodeBasicBlock::computeImpl(Block* codeBlock, const InstructionStream&amp; instructions) -&gt; BasicBlockVector</span>
 76 {
<span class="line-added"> 77     BasicBlockVector basicBlocks;</span>
 78     Vector&lt;InstructionStream::Offset, 32&gt; jumpTargets;
 79     computePreciseJumpTargets(codeBlock, instructions, jumpTargets);
 80 
<span class="line-modified"> 81     auto linkBlocks = [&amp;] (BytecodeBasicBlock&amp; from, BytecodeBasicBlock&amp; to) {</span>
<span class="line-modified"> 82         from.addSuccessor(to);</span>





 83     };
 84 
<span class="line-modified"> 85     {</span>
<span class="line-modified"> 86         // Create the entry and exit basic blocks.</span>
<span class="line-modified"> 87         basicBlocks.reserveCapacity(jumpTargets.size() + 2);</span>
<span class="line-modified"> 88         {</span>
<span class="line-modified"> 89             // Entry block.</span>
<span class="line-modified"> 90             basicBlocks.constructAndAppend(BytecodeBasicBlock::EntryBlock, basicBlocks.size());</span>
<span class="line-added"> 91             // First block.</span>
<span class="line-added"> 92             basicBlocks.constructAndAppend(BytecodeBasicBlock::EntryBlock, basicBlocks.size());</span>
<span class="line-added"> 93             linkBlocks(basicBlocks[0], basicBlocks[1]);</span>
<span class="line-added"> 94         }</span>
 95 
<span class="line-modified"> 96         BytecodeBasicBlock* current = &amp;basicBlocks.last();</span>
<span class="line-modified"> 97         auto appendBlock = [&amp;] (const InstructionStream::Ref&amp; instruction) -&gt; BytecodeBasicBlock* {</span>
<span class="line-modified"> 98             basicBlocks.constructAndAppend(instruction, basicBlocks.size());</span>
<span class="line-added"> 99             return &amp;basicBlocks.last();</span>
<span class="line-added">100         };</span>
<span class="line-added">101         bool nextInstructionIsLeader = false;</span>
<span class="line-added">102         for (const auto&amp; instruction : instructions) {</span>
<span class="line-added">103             auto bytecodeOffset = instruction.offset();</span>
<span class="line-added">104             OpcodeID opcodeID = instruction-&gt;opcodeID();</span>
105 
<span class="line-modified">106             bool createdBlock = false;</span>
<span class="line-added">107             // If the current bytecode is a jump target, then it&#39;s the leader of its own basic block.</span>
<span class="line-added">108             if (nextInstructionIsLeader || isJumpTarget(opcodeID, jumpTargets, bytecodeOffset)) {</span>
<span class="line-added">109                 current = appendBlock(instruction);</span>
<span class="line-added">110                 createdBlock = true;</span>
<span class="line-added">111                 nextInstructionIsLeader = false;</span>
<span class="line-added">112             }</span>
113 
<span class="line-modified">114             // If the current bytecode is a branch or a return, then the next instruction is the leader of its own basic block.</span>
<span class="line-added">115             if (isBranch(opcodeID) || isTerminal(opcodeID) || isThrow(opcodeID))</span>
<span class="line-added">116                 nextInstructionIsLeader = true;</span>
117 
<span class="line-modified">118             if (createdBlock)</span>
<span class="line-modified">119                 continue;</span>

120 
<span class="line-modified">121             // Otherwise, just add to the length of the current block.</span>
<span class="line-modified">122             current-&gt;addLength(instruction-&gt;size());</span>






123         }
<span class="line-modified">124         // Exit block.</span>
<span class="line-modified">125         basicBlocks.constructAndAppend(BytecodeBasicBlock::ExitBlock, basicBlocks.size());</span>
<span class="line-modified">126         basicBlocks.shrinkToFit();</span>
<span class="line-modified">127         ASSERT(basicBlocks.last().isExitBlock());</span>






128     }
<span class="line-added">129     // After this point, we never change basicBlocks.</span>
130 
131     // Link basic blocks together.
132     for (unsigned i = 0; i &lt; basicBlocks.size(); i++) {
<span class="line-modified">133         BytecodeBasicBlock&amp; block = basicBlocks[i];</span>
134 
<span class="line-modified">135         if (block.isEntryBlock() || block.isExitBlock())</span>
136             continue;
137 
138         bool fallsThrough = true;
<span class="line-modified">139         for (unsigned visitedLength = 0; visitedLength &lt; block.totalLength();) {</span>
<span class="line-modified">140             InstructionStream::Ref instruction = instructions.at(block.leaderOffset() + visitedLength);</span>
141             OpcodeID opcodeID = instruction-&gt;opcodeID();
142 
<span class="line-added">143             visitedLength += instruction-&gt;size();</span>
<span class="line-added">144 </span>
145             // If we found a terminal bytecode, link to the exit block.
146             if (isTerminal(opcodeID)) {
<span class="line-modified">147                 ASSERT(instruction.offset() + instruction-&gt;size() == block.leaderOffset() + block.totalLength());</span>
<span class="line-modified">148                 linkBlocks(block, basicBlocks.last());</span>
149                 fallsThrough = false;
150                 break;
151             }
152 
153             // If we found a throw, get the HandlerInfo for this instruction to see where we will jump.
154             // If there isn&#39;t one, treat this throw as a terminal. This is true even if we have a finally
155             // block because the finally block will create its own catch, which will generate a HandlerInfo.
156             if (isThrow(opcodeID)) {
<span class="line-modified">157                 ASSERT(instruction.offset() + instruction-&gt;size() == block.leaderOffset() + block.totalLength());</span>
<span class="line-modified">158                 auto* handler = codeBlock-&gt;handlerForBytecodeIndex(BytecodeIndex(instruction.offset()));</span>
159                 fallsThrough = false;
160                 if (!handler) {
<span class="line-modified">161                     linkBlocks(block, basicBlocks.last());</span>
162                     break;
163                 }
<span class="line-modified">164                 for (auto&amp; otherBlock : basicBlocks) {</span>
<span class="line-modified">165                     if (handler-&gt;target == otherBlock.leaderOffset()) {</span>

166                         linkBlocks(block, otherBlock);
167                         break;
168                     }
169                 }
170                 break;
171             }
172 
173             // If we found a branch, link to the block(s) that we jump to.
174             if (isBranch(opcodeID)) {
<span class="line-modified">175                 ASSERT(instruction.offset() + instruction-&gt;size() == block.leaderOffset() + block.totalLength());</span>
176                 Vector&lt;InstructionStream::Offset, 1&gt; bytecodeOffsetsJumpedTo;
177                 findJumpTargetsForInstruction(codeBlock, instruction, bytecodeOffsetsJumpedTo);
178 
179                 size_t numberOfJumpTargets = bytecodeOffsetsJumpedTo.size();
180                 ASSERT(numberOfJumpTargets);
<span class="line-modified">181                 for (auto&amp; otherBlock : basicBlocks) {</span>
<span class="line-modified">182                     if (bytecodeOffsetsJumpedTo.contains(otherBlock.leaderOffset())) {</span>

183                         linkBlocks(block, otherBlock);
184                         --numberOfJumpTargets;
185                         if (!numberOfJumpTargets)
186                             break;
187                     }
188                 }
189                 // numberOfJumpTargets may not be 0 here if there are multiple jumps targeting the same
190                 // basic blocks (e.g. in a switch type opcode). Since we only decrement numberOfJumpTargets
191                 // once per basic block, the duplicates are not accounted for. For our purpose here,
192                 // that doesn&#39;t matter because we only need to link to the target block once regardless
193                 // of how many ways this block can jump there.
194 
195                 if (isUnconditionalBranch(opcodeID))
196                     fallsThrough = false;
197 
198                 break;
199             }
200         }
201 
202         // If we fall through then link to the next block in program order.
203         if (fallsThrough) {
204             ASSERT(i + 1 &lt; basicBlocks.size());
<span class="line-modified">205             BytecodeBasicBlock&amp; nextBlock = basicBlocks[i + 1];</span>
206             linkBlocks(block, nextBlock);
207         }
208     }
209 
<span class="line-modified">210     unsigned index = 0;</span>
<span class="line-added">211     for (auto&amp; basicBlock : basicBlocks) {</span>
<span class="line-added">212         basicBlock.shrinkToFit();</span>
<span class="line-added">213         ASSERT_UNUSED(index, basicBlock.index() == index++);</span>
<span class="line-added">214     }</span>
215 
<span class="line-modified">216     return basicBlocks;</span>

217 }
218 
<span class="line-modified">219 auto BytecodeBasicBlock::compute(CodeBlock* codeBlock, const InstructionStream&amp; instructions) -&gt; BasicBlockVector</span>
220 {
<span class="line-modified">221     return computeImpl(codeBlock, instructions);</span>
222 }
223 
<span class="line-modified">224 auto BytecodeBasicBlock::compute(UnlinkedCodeBlockGenerator* codeBlock, const InstructionStream&amp; instructions) -&gt; BasicBlockVector</span>
225 {
<span class="line-modified">226     return computeImpl(codeBlock, instructions);</span>
227 }
228 
229 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="ByValInfo.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeBasicBlock.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
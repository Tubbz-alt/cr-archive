<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/encryptedmedia/clearkey/CDMClearKey.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../CDMInstance.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="CDMClearKey.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/encryptedmedia/clearkey/CDMClearKey.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 17  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 18  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 19  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 20  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 21  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 22  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 23  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;CDMClearKey.h&quot;
 31 
 32 #if ENABLE(ENCRYPTED_MEDIA)
 33 
 34 #include &quot;CDMKeySystemConfiguration.h&quot;
 35 #include &quot;CDMRestrictions.h&quot;
 36 #include &quot;CDMSessionType.h&quot;

 37 #include &quot;SharedBuffer.h&quot;
 38 #include &lt;wtf/JSONValues.h&gt;
 39 #include &lt;wtf/MainThread.h&gt;
 40 #include &lt;wtf/NeverDestroyed.h&gt;
 41 #include &lt;wtf/text/Base64.h&gt;
 42 
 43 namespace WebCore {
 44 
 45 // ClearKey CENC SystemID.
 46 // https://www.w3.org/TR/eme-initdata-cenc/#common-system
 47 const uint8_t clearKeyCencSystemId[] = { 0x10, 0x77, 0xef, 0xec, 0xc0, 0xb2, 0x4d, 0x02, 0xac, 0xe3, 0x3c, 0x1e, 0x52, 0xe2, 0xfb, 0x4b };
 48 const unsigned clearKeyCencSystemIdSize = sizeof(clearKeyCencSystemId);
 49 const unsigned keyIdSize = 16;
 50 
 51 class ClearKeyState {
 52     using KeyStore = HashMap&lt;String, Vector&lt;CDMInstanceClearKey::Key&gt;&gt;;
 53 
 54 public:
 55     static ClearKeyState&amp; singleton();
 56 
</pre>
<hr />
<pre>
438 
439 RefPtr&lt;SharedBuffer&gt; CDMPrivateClearKey::sanitizeResponse(const SharedBuffer&amp; response) const
440 {
441     // Validate the response buffer as an JSON object.
442     if (!parseJSONObject(response))
443         return nullptr;
444 
445     return response.copy();
446 }
447 
448 Optional&lt;String&gt; CDMPrivateClearKey::sanitizeSessionId(const String&amp; sessionId) const
449 {
450     // Validate the session ID string as an 32-bit integer.
451     bool ok;
452     sessionId.toUIntStrict(&amp;ok);
453     if (!ok)
454         return WTF::nullopt;
455     return sessionId;
456 }
457 

































458 CDMInstanceClearKey::CDMInstanceClearKey()

459 {
460 }
461 
462 CDMInstanceClearKey::~CDMInstanceClearKey() = default;
463 
464 CDMInstance::SuccessValue CDMInstanceClearKey::initializeWithConfiguration(const CDMKeySystemConfiguration&amp;)
465 {
466     // No-op.
467     return Succeeded;
468 }
469 
470 CDMInstance::SuccessValue CDMInstanceClearKey::setDistinctiveIdentifiersAllowed(bool allowed)
471 {
472     // Reject setting distinctive identifiers as allowed.
473     return !allowed ? Succeeded : Failed;
474 }
475 
476 CDMInstance::SuccessValue CDMInstanceClearKey::setPersistentStateAllowed(bool allowed)
477 {
478     // Reject setting persistent state as allowed.
</pre>
<hr />
<pre>
486 }
487 
488 CDMInstance::SuccessValue CDMInstanceClearKey::setStorageDirectory(const String&amp; storageDirectory)
489 {
490     // Reject any persistent state storage.
491     return storageDirectory.isEmpty() ? Succeeded : Failed;
492 }
493 
494 const String&amp; CDMInstanceClearKey::keySystem() const
495 {
496     static const NeverDestroyed&lt;String&gt; s_keySystem { MAKE_STATIC_STRING_IMPL(&quot;org.w3.clearkey&quot;) };
497 
498     return s_keySystem;
499 }
500 
501 RefPtr&lt;CDMInstanceSession&gt; CDMInstanceClearKey::createSession()
502 {
503     return adoptRef(new CDMInstanceSessionClearKey());
504 }
505 
<span class="line-modified">506 const Vector&lt;CDMInstanceClearKey::Key&gt; CDMInstanceClearKey::keys() const</span>
507 {
<span class="line-modified">508     // Return the keys of all sessions.</span>
<span class="line-modified">509     Vector&lt;CDMInstanceClearKey::Key&gt; allKeys { };</span>
<span class="line-modified">510     auto locker = holdLock(m_keysMutex);</span>
<span class="line-modified">511     size_t initialCapacity = 0;</span>
<span class="line-modified">512     for (auto&amp; key : ClearKeyState::singleton().keys().values())</span>
<span class="line-modified">513         initialCapacity += key.size();</span>
<span class="line-modified">514     allKeys.reserveInitialCapacity(initialCapacity);</span>
515 
<span class="line-modified">516     for (auto&amp; key : ClearKeyState::singleton().keys().values())</span>
<span class="line-modified">517         allKeys.appendVector(key);</span>


518 
<span class="line-modified">519     return allKeys;</span>











520 }
521 
522 void CDMInstanceSessionClearKey::requestLicense(LicenseType, const AtomString&amp; initDataType, Ref&lt;SharedBuffer&gt;&amp;&amp; initData, LicenseCallback&amp;&amp; callback)
523 {
524     static uint32_t s_sessionIdValue = 0;
525     ++s_sessionIdValue;
526 
527     if (equalLettersIgnoringASCIICase(initDataType, &quot;cenc&quot;))
528         initData = extractKeyidsFromCencInitData(initData.get());
529 
530     if (equalLettersIgnoringASCIICase(initDataType, &quot;webm&quot;))
531         initData = extractKeyIdFromWebMInitData(initData.get());
532 
533     callOnMainThread(
534         [weakThis = makeWeakPtr(*this), callback = WTFMove(callback), initData = WTFMove(initData), sessionIdValue = s_sessionIdValue]() mutable {
535             if (!weakThis)
536                 return;
537 
538             callback(WTFMove(initData), String::number(sessionIdValue), false, Succeeded);
539         });
540 }
541 
542 void CDMInstanceSessionClearKey::updateLicense(const String&amp; sessionId, LicenseType, const SharedBuffer&amp; response, LicenseUpdateCallback&amp;&amp; callback)
543 {
544     // Use a helper functor that schedules the callback dispatch, avoiding
545     // duplicated callOnMainThread() calls.
546     auto dispatchCallback =
547         [this, &amp;callback](bool sessionWasClosed, Optional&lt;KeyStatusVector&gt;&amp;&amp; changedKeys, SuccessValue succeeded) {
548             callOnMainThread(
549                 [weakThis = makeWeakPtr(*this), callback = WTFMove(callback), sessionWasClosed, changedKeys = WTFMove(changedKeys), succeeded] () mutable {
550                     if (!weakThis)
551                         return;
552 
553                     callback(sessionWasClosed, WTFMove(changedKeys), WTF::nullopt, WTF::nullopt, succeeded);
554                 });
555         };
556 
<span class="line-removed">557     // Parse the response buffer as an JSON object.</span>
558     RefPtr&lt;JSON::Object&gt; root = parseJSONObject(response);
559     if (!root) {
560         dispatchCallback(false, WTF::nullopt, SuccessValue::Failed);
561         return;
562     }
563 
<span class="line-modified">564     // Parse the response using &#39;license&#39; formatting, if possible.</span>

565     if (auto decodedKeys = parseLicenseFormat(*root)) {
566         // Retrieve the target Vector of Key objects for this session.
<span class="line-modified">567         auto&amp; keyVector = ClearKeyState::singleton().keys().ensure(sessionId, [] { return Vector&lt;CDMInstanceClearKey::Key&gt; { }; }).iterator-&gt;value;</span>

568 
<span class="line-removed">569         // For each decoded key, find an existing item for the decoded key&#39;s ID. If none exist,</span>
<span class="line-removed">570         // the key is decoded. Otherwise, the key is updated in case there&#39;s a mismatch between</span>
<span class="line-removed">571         // the size or data of the existing and proposed key.</span>
572         bool keysChanged = false;
<span class="line-modified">573         for (auto&amp; key : *decodedKeys) {</span>
<span class="line-modified">574             auto it = std::find_if(keyVector.begin(), keyVector.end(),</span>
<span class="line-modified">575                 [&amp;key] (const CDMInstanceClearKey::Key&amp; containedKey) {</span>
<span class="line-modified">576                     return containedKey.keyIDData-&gt;size() == key.keyIDData-&gt;size()</span>
<span class="line-modified">577                         &amp;&amp; !std::memcmp(containedKey.keyIDData-&gt;data(), key.keyIDData-&gt;data(), containedKey.keyIDData-&gt;size());</span>
578                 });
<span class="line-modified">579             if (it != keyVector.end()) {</span>
<span class="line-modified">580                 auto&amp; existingKey = it-&gt;keyValueData;</span>
<span class="line-removed">581                 auto&amp; proposedKey = key.keyValueData;</span>
582 
<span class="line-modified">583                 // Update the existing Key if it differs from the proposed key in key value.</span>
<span class="line-modified">584                 if (existingKey-&gt;size() != proposedKey-&gt;size() || std::memcmp(existingKey-&gt;data(), proposedKey-&gt;data(), existingKey-&gt;size())) {</span>
<span class="line-modified">585                     *it = WTFMove(key);</span>
586                     keysChanged = true;
587                 }
588             } else {
<span class="line-modified">589                 // In case a Key for this key ID doesn&#39;t exist yet, append the new one to keyVector.</span>
<span class="line-modified">590                 keyVector.append(WTFMove(key));</span>
591                 keysChanged = true;
592             }
593         }
594 
<span class="line-modified">595         // In case of changed keys, we have to provide a KeyStatusVector of all the keys for</span>
<span class="line-modified">596         // this session.</span>
597         Optional&lt;KeyStatusVector&gt; changedKeys;
598         if (keysChanged) {
<span class="line-modified">599             // First a helper Vector is constructed, cotaining pairs of SharedBuffer RefPtrs</span>
<span class="line-modified">600             // representint key ID data, and the corresponding key statuses.</span>
<span class="line-removed">601             // We can&#39;t use KeyStatusVector here because this Vector has to be sorted, which</span>
<span class="line-removed">602             // is not possible to do on Ref&lt;&gt; objects.</span>
<span class="line-removed">603             Vector&lt;std::pair&lt;RefPtr&lt;SharedBuffer&gt;, KeyStatus&gt;&gt; keys;</span>
<span class="line-removed">604             keys.reserveInitialCapacity(keyVector.size());</span>
<span class="line-removed">605             for (auto&amp; it : keyVector)</span>
<span class="line-removed">606                 keys.uncheckedAppend(std::pair&lt;RefPtr&lt;SharedBuffer&gt;, KeyStatus&gt; { it.keyIDData, it.status });</span>
<span class="line-removed">607 </span>
<span class="line-removed">608             // Sort first by size, second by data.</span>
<span class="line-removed">609             std::sort(keys.begin(), keys.end(),</span>
<span class="line-removed">610                 [] (const auto&amp; a, const auto&amp; b) {</span>
<span class="line-removed">611                     if (a.first-&gt;size() != b.first-&gt;size())</span>
<span class="line-removed">612                         return a.first-&gt;size() &lt; b.first-&gt;size();</span>
<span class="line-removed">613 </span>
<span class="line-removed">614                     return std::memcmp(a.first-&gt;data(), b.first-&gt;data(), a.first-&gt;size()) &lt; 0;</span>
<span class="line-removed">615                 });</span>
616 
<span class="line-removed">617             // Finally construct the mirroring KeyStatusVector object and move it into the</span>
<span class="line-removed">618             // Optional&lt;&gt; object that will be passed to the callback.</span>
619             KeyStatusVector keyStatusVector;
<span class="line-modified">620             keyStatusVector.reserveInitialCapacity(keys.size());</span>
<span class="line-modified">621             for (auto&amp; it : keys)</span>
<span class="line-modified">622                 keyStatusVector.uncheckedAppend(std::pair&lt;Ref&lt;SharedBuffer&gt;, KeyStatus&gt; { *it.first, it.second });</span>
623 
624             changedKeys = WTFMove(keyStatusVector);
625         }
626 
627         dispatchCallback(false, WTFMove(changedKeys), SuccessValue::Succeeded);
628         return;
629     }
630 
<span class="line-removed">631     // Parse the response using &#39;license release acknowledgement&#39; formatting, if possible.</span>
632     if (parseLicenseReleaseAcknowledgementFormat(*root)) {
633         // FIXME: Retrieve the key ID information and use it to validate the keys for this sessionId.
634         ClearKeyState::singleton().keys().remove(sessionId);
635         dispatchCallback(true, WTF::nullopt, SuccessValue::Succeeded);
636         return;
637     }
638 
639     // Bail in case no format was recognized.
640     dispatchCallback(false, WTF::nullopt, SuccessValue::Failed);
641 }
642 
643 void CDMInstanceSessionClearKey::loadSession(LicenseType, const String&amp; sessionId, const String&amp;, LoadSessionCallback&amp;&amp; callback)
644 {
645     // Use a helper functor that schedules the callback dispatch, avoiding duplicated callOnMainThread() calls.
646     auto dispatchCallback =
647         [this, &amp;callback](Optional&lt;KeyStatusVector&gt;&amp;&amp; existingKeys, SuccessValue success, SessionLoadFailure loadFailure) {
648             callOnMainThread(
649                 [weakThis = makeWeakPtr(*this), callback = WTFMove(callback), existingKeys = WTFMove(existingKeys), success, loadFailure]() mutable {
650                     if (!weakThis)
651                         return;
</pre>
</td>
<td>
<hr />
<pre>
 17  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 18  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 19  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 20  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 21  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 22  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 23  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;CDMClearKey.h&quot;
 31 
 32 #if ENABLE(ENCRYPTED_MEDIA)
 33 
 34 #include &quot;CDMKeySystemConfiguration.h&quot;
 35 #include &quot;CDMRestrictions.h&quot;
 36 #include &quot;CDMSessionType.h&quot;
<span class="line-added"> 37 #include &quot;Logging.h&quot;</span>
 38 #include &quot;SharedBuffer.h&quot;
 39 #include &lt;wtf/JSONValues.h&gt;
 40 #include &lt;wtf/MainThread.h&gt;
 41 #include &lt;wtf/NeverDestroyed.h&gt;
 42 #include &lt;wtf/text/Base64.h&gt;
 43 
 44 namespace WebCore {
 45 
 46 // ClearKey CENC SystemID.
 47 // https://www.w3.org/TR/eme-initdata-cenc/#common-system
 48 const uint8_t clearKeyCencSystemId[] = { 0x10, 0x77, 0xef, 0xec, 0xc0, 0xb2, 0x4d, 0x02, 0xac, 0xe3, 0x3c, 0x1e, 0x52, 0xe2, 0xfb, 0x4b };
 49 const unsigned clearKeyCencSystemIdSize = sizeof(clearKeyCencSystemId);
 50 const unsigned keyIdSize = 16;
 51 
 52 class ClearKeyState {
 53     using KeyStore = HashMap&lt;String, Vector&lt;CDMInstanceClearKey::Key&gt;&gt;;
 54 
 55 public:
 56     static ClearKeyState&amp; singleton();
 57 
</pre>
<hr />
<pre>
439 
440 RefPtr&lt;SharedBuffer&gt; CDMPrivateClearKey::sanitizeResponse(const SharedBuffer&amp; response) const
441 {
442     // Validate the response buffer as an JSON object.
443     if (!parseJSONObject(response))
444         return nullptr;
445 
446     return response.copy();
447 }
448 
449 Optional&lt;String&gt; CDMPrivateClearKey::sanitizeSessionId(const String&amp; sessionId) const
450 {
451     // Validate the session ID string as an 32-bit integer.
452     bool ok;
453     sessionId.toUIntStrict(&amp;ok);
454     if (!ok)
455         return WTF::nullopt;
456     return sessionId;
457 }
458 
<span class="line-added">459 // This is for thread-safety during an architectural situation that is</span>
<span class="line-added">460 // less than ideal. The GStreamer decryptors currently need to iterate</span>
<span class="line-added">461 // all known session keys to find the key data for priming</span>
<span class="line-added">462 // GCrypt. Ideally, all decryption would be the responsibility of</span>
<span class="line-added">463 // ProxyCDM object like this one. What the background GStreamer</span>
<span class="line-added">464 // thread was doing was getting copies (i.e. ref()&#39;s) of SharedBuffers</span>
<span class="line-added">465 // created on the main-thread. With the new safety assertions in</span>
<span class="line-added">466 // WebKit, we can no longer do this. Instead, convert the refcounted</span>
<span class="line-added">467 // SharedBuffers into Strings which can be safely copied across</span>
<span class="line-added">468 // threads.</span>
<span class="line-added">469 static ProxyCDMClearKey::Key isolatedKey(const CDMInstanceClearKey::Key&amp; key)</span>
<span class="line-added">470 {</span>
<span class="line-added">471     return { key.status, String(key.keyIDData-&gt;data(), key.keyIDData-&gt;size()), String(key.keyValueData-&gt;data(), key.keyValueData-&gt;size()) };</span>
<span class="line-added">472 }</span>
<span class="line-added">473 </span>
<span class="line-added">474 const Vector&lt;ProxyCDMClearKey::Key&gt; ProxyCDMClearKey::isolatedKeys() const</span>
<span class="line-added">475 {</span>
<span class="line-added">476     // Return the keys of all sessions, may be copied to background threads.</span>
<span class="line-added">477     Vector&lt;ProxyCDMClearKey::Key&gt; allKeys { };</span>
<span class="line-added">478     auto locker = holdLock(m_keysMutex);</span>
<span class="line-added">479     size_t initialCapacity = 0;</span>
<span class="line-added">480     for (auto&amp; keyVector : ClearKeyState::singleton().keys().values())</span>
<span class="line-added">481         initialCapacity += keyVector.size();</span>
<span class="line-added">482     allKeys.reserveInitialCapacity(initialCapacity);</span>
<span class="line-added">483 </span>
<span class="line-added">484     for (auto&amp; keyVector : ClearKeyState::singleton().keys().values()) {</span>
<span class="line-added">485         for (auto&amp; key : keyVector)</span>
<span class="line-added">486             allKeys.uncheckedAppend(isolatedKey(key));</span>
<span class="line-added">487     }</span>
<span class="line-added">488 </span>
<span class="line-added">489     return allKeys;</span>
<span class="line-added">490 }</span>
<span class="line-added">491 </span>
492 CDMInstanceClearKey::CDMInstanceClearKey()
<span class="line-added">493     : m_proxyCDM(adoptRef(*new ProxyCDMClearKey()))</span>
494 {
495 }
496 
497 CDMInstanceClearKey::~CDMInstanceClearKey() = default;
498 
499 CDMInstance::SuccessValue CDMInstanceClearKey::initializeWithConfiguration(const CDMKeySystemConfiguration&amp;)
500 {
501     // No-op.
502     return Succeeded;
503 }
504 
505 CDMInstance::SuccessValue CDMInstanceClearKey::setDistinctiveIdentifiersAllowed(bool allowed)
506 {
507     // Reject setting distinctive identifiers as allowed.
508     return !allowed ? Succeeded : Failed;
509 }
510 
511 CDMInstance::SuccessValue CDMInstanceClearKey::setPersistentStateAllowed(bool allowed)
512 {
513     // Reject setting persistent state as allowed.
</pre>
<hr />
<pre>
521 }
522 
523 CDMInstance::SuccessValue CDMInstanceClearKey::setStorageDirectory(const String&amp; storageDirectory)
524 {
525     // Reject any persistent state storage.
526     return storageDirectory.isEmpty() ? Succeeded : Failed;
527 }
528 
529 const String&amp; CDMInstanceClearKey::keySystem() const
530 {
531     static const NeverDestroyed&lt;String&gt; s_keySystem { MAKE_STATIC_STRING_IMPL(&quot;org.w3.clearkey&quot;) };
532 
533     return s_keySystem;
534 }
535 
536 RefPtr&lt;CDMInstanceSession&gt; CDMInstanceClearKey::createSession()
537 {
538     return adoptRef(new CDMInstanceSessionClearKey());
539 }
540 
<span class="line-modified">541 String CDMInstanceClearKey::Key::keyIDAsString() const</span>
542 {
<span class="line-modified">543     return makeString(&quot;[&quot;, keyIDData-&gt;toHexString(), &quot;]&quot;);</span>
<span class="line-modified">544 }</span>
<span class="line-modified">545 </span>
<span class="line-modified">546 String CDMInstanceClearKey::Key::keyValueAsString() const</span>
<span class="line-modified">547 {</span>
<span class="line-modified">548     return makeString(&quot;[&quot;, keyValueData-&gt;toHexString(), &quot;]&quot;);</span>
<span class="line-modified">549 }</span>
550 
<span class="line-modified">551 bool operator==(const CDMInstanceClearKey::Key&amp; k1, const CDMInstanceClearKey::Key&amp; k2)</span>
<span class="line-modified">552 {</span>
<span class="line-added">553     ASSERT(k1.keyIDData);</span>
<span class="line-added">554     ASSERT(k2.keyIDData);</span>
555 
<span class="line-modified">556     return *k1.keyIDData == *k2.keyIDData;</span>
<span class="line-added">557 }</span>
<span class="line-added">558 </span>
<span class="line-added">559 bool operator&lt;(const CDMInstanceClearKey::Key&amp; k1, const CDMInstanceClearKey::Key&amp; k2)</span>
<span class="line-added">560 {</span>
<span class="line-added">561     ASSERT(k1.keyIDData);</span>
<span class="line-added">562     ASSERT(k2.keyIDData);</span>
<span class="line-added">563 </span>
<span class="line-added">564     if (k1.keyIDData-&gt;size() != k2.keyIDData-&gt;size())</span>
<span class="line-added">565         return k1.keyIDData-&gt;size() &lt; k2.keyIDData-&gt;size();</span>
<span class="line-added">566 </span>
<span class="line-added">567     return memcmp(k1.keyIDData-&gt;data(), k2.keyIDData-&gt;data(), k1.keyIDData-&gt;size());</span>
568 }
569 
570 void CDMInstanceSessionClearKey::requestLicense(LicenseType, const AtomString&amp; initDataType, Ref&lt;SharedBuffer&gt;&amp;&amp; initData, LicenseCallback&amp;&amp; callback)
571 {
572     static uint32_t s_sessionIdValue = 0;
573     ++s_sessionIdValue;
574 
575     if (equalLettersIgnoringASCIICase(initDataType, &quot;cenc&quot;))
576         initData = extractKeyidsFromCencInitData(initData.get());
577 
578     if (equalLettersIgnoringASCIICase(initDataType, &quot;webm&quot;))
579         initData = extractKeyIdFromWebMInitData(initData.get());
580 
581     callOnMainThread(
582         [weakThis = makeWeakPtr(*this), callback = WTFMove(callback), initData = WTFMove(initData), sessionIdValue = s_sessionIdValue]() mutable {
583             if (!weakThis)
584                 return;
585 
586             callback(WTFMove(initData), String::number(sessionIdValue), false, Succeeded);
587         });
588 }
589 
590 void CDMInstanceSessionClearKey::updateLicense(const String&amp; sessionId, LicenseType, const SharedBuffer&amp; response, LicenseUpdateCallback&amp;&amp; callback)
591 {
592     // Use a helper functor that schedules the callback dispatch, avoiding
593     // duplicated callOnMainThread() calls.
594     auto dispatchCallback =
595         [this, &amp;callback](bool sessionWasClosed, Optional&lt;KeyStatusVector&gt;&amp;&amp; changedKeys, SuccessValue succeeded) {
596             callOnMainThread(
597                 [weakThis = makeWeakPtr(*this), callback = WTFMove(callback), sessionWasClosed, changedKeys = WTFMove(changedKeys), succeeded] () mutable {
598                     if (!weakThis)
599                         return;
600 
601                     callback(sessionWasClosed, WTFMove(changedKeys), WTF::nullopt, WTF::nullopt, succeeded);
602                 });
603         };
604 

605     RefPtr&lt;JSON::Object&gt; root = parseJSONObject(response);
606     if (!root) {
607         dispatchCallback(false, WTF::nullopt, SuccessValue::Failed);
608         return;
609     }
610 
<span class="line-modified">611     LOG(EME, &quot;EME - ClearKey - updating license for session %s&quot;, sessionId.utf8().data());</span>
<span class="line-added">612 </span>
613     if (auto decodedKeys = parseLicenseFormat(*root)) {
614         // Retrieve the target Vector of Key objects for this session.
<span class="line-modified">615         // FIXME: Refactor this state management code.</span>
<span class="line-added">616         Vector&lt;CDMInstanceClearKey::Key&gt;&amp; keyVector = ClearKeyState::singleton().keys().ensure(sessionId, [] { return Vector&lt;CDMInstanceClearKey::Key&gt; { }; }).iterator-&gt;value;</span>
617 



618         bool keysChanged = false;
<span class="line-modified">619         for (auto&amp; decodedKey : *decodedKeys) {</span>
<span class="line-modified">620             LOG(EME, &quot;EME - ClearKey - Decoded a key with ID %s and key data %s&quot;, decodedKey.keyIDAsString().utf8().data(), decodedKey.keyValueAsString().utf8().data());</span>
<span class="line-modified">621             auto keyWithMatchingKeyID = std::find_if(keyVector.begin(), keyVector.end(),</span>
<span class="line-modified">622                 [&amp;decodedKey] (const CDMInstanceClearKey::Key&amp; containedKey) {</span>
<span class="line-modified">623                     return containedKey == decodedKey;</span>
624                 });
<span class="line-modified">625             if (keyWithMatchingKeyID != keyVector.end()) {</span>
<span class="line-modified">626                 LOG(EME, &quot;EME - ClearKey - Existing key found with data %s&quot;, keyWithMatchingKeyID-&gt;keyValueAsString().utf8().data());</span>

627 
<span class="line-modified">628                 if (!keyWithMatchingKeyID-&gt;hasSameKeyValue(decodedKey)) {</span>
<span class="line-modified">629                     LOG(EME, &quot;EME - ClearKey - Updating key since the data are different&quot;);</span>
<span class="line-modified">630                     *keyWithMatchingKeyID = WTFMove(decodedKey);</span>
631                     keysChanged = true;
632                 }
633             } else {
<span class="line-modified">634                 LOG(EME, &quot;EME - ClearKey - This is a new key&quot;);</span>
<span class="line-modified">635                 keyVector.append(WTFMove(decodedKey));</span>
636                 keysChanged = true;
637             }
638         }
639 
<span class="line-modified">640         LOG(EME, &quot;EME - ClearKey - Update has provided %zu keys&quot;, keyVector.size());</span>
<span class="line-modified">641 </span>
642         Optional&lt;KeyStatusVector&gt; changedKeys;
643         if (keysChanged) {
<span class="line-modified">644             // Sort by key IDs.</span>
<span class="line-modified">645             std::sort(keyVector.begin(), keyVector.end());</span>















646 


647             KeyStatusVector keyStatusVector;
<span class="line-modified">648             keyStatusVector.reserveInitialCapacity(keyVector.size());</span>
<span class="line-modified">649             for (auto&amp; key : keyVector)</span>
<span class="line-modified">650                 keyStatusVector.uncheckedAppend(std::pair&lt;Ref&lt;SharedBuffer&gt;, KeyStatus&gt; { *key.keyIDData, key.status });</span>
651 
652             changedKeys = WTFMove(keyStatusVector);
653         }
654 
655         dispatchCallback(false, WTFMove(changedKeys), SuccessValue::Succeeded);
656         return;
657     }
658 

659     if (parseLicenseReleaseAcknowledgementFormat(*root)) {
660         // FIXME: Retrieve the key ID information and use it to validate the keys for this sessionId.
661         ClearKeyState::singleton().keys().remove(sessionId);
662         dispatchCallback(true, WTF::nullopt, SuccessValue::Succeeded);
663         return;
664     }
665 
666     // Bail in case no format was recognized.
667     dispatchCallback(false, WTF::nullopt, SuccessValue::Failed);
668 }
669 
670 void CDMInstanceSessionClearKey::loadSession(LicenseType, const String&amp; sessionId, const String&amp;, LoadSessionCallback&amp;&amp; callback)
671 {
672     // Use a helper functor that schedules the callback dispatch, avoiding duplicated callOnMainThread() calls.
673     auto dispatchCallback =
674         [this, &amp;callback](Optional&lt;KeyStatusVector&gt;&amp;&amp; existingKeys, SuccessValue success, SessionLoadFailure loadFailure) {
675             callOnMainThread(
676                 [weakThis = makeWeakPtr(*this), callback = WTFMove(callback), existingKeys = WTFMove(existingKeys), success, loadFailure]() mutable {
677                     if (!weakThis)
678                         return;
</pre>
</td>
</tr>
</table>
<center><a href="../CDMInstance.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="CDMClearKey.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
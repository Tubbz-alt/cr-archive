<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/style/BasicShapes.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2012 Adobe Systems Incorporated. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1. Redistributions of source code must retain the above
  9  *    copyright notice, this list of conditions and the following
 10  *    disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above
 12  *    copyright notice, this list of conditions and the following
 13  *    disclaimer in the documentation and/or other materials
 14  *    provided with the distribution.
 15  *
 16  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER &quot;AS IS&quot; AND ANY
 17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 18  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 19  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
 20  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 21  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 22  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 23  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 25  * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 26  * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 27  * SUCH DAMAGE.
 28  */
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;BasicShapes.h&quot;
 32 
 33 #include &quot;BasicShapeFunctions.h&quot;
 34 #include &quot;CalculationValue.h&quot;
 35 #include &quot;FloatRect.h&quot;
 36 #include &quot;FloatRoundedRect.h&quot;
 37 #include &quot;LengthFunctions.h&quot;
 38 #include &quot;Path.h&quot;
 39 #include &quot;RenderBox.h&quot;
 40 #include &quot;SVGPathByteStream.h&quot;
 41 #include &quot;SVGPathUtilities.h&quot;
 42 #include &lt;wtf/MathExtras.h&gt;
 43 #include &lt;wtf/NeverDestroyed.h&gt;
 44 #include &lt;wtf/TinyLRUCache.h&gt;
 45 #include &lt;wtf/text/TextStream.h&gt;
 46 
 47 namespace WebCore {
 48 
 49 void BasicShapeCenterCoordinate::updateComputedLength()
 50 {
 51     if (m_direction == TopLeft) {
 52         m_computedLength = m_length.isUndefined() ? Length(0, Fixed) : m_length;
 53         return;
 54     }
 55 
 56     if (m_length.isUndefined()) {
 57         m_computedLength = Length(100, Percent);
 58         return;
 59     }
 60 
 61     m_computedLength = convertTo100PercentMinusLength(m_length);
 62 }
 63 
 64 struct SVGPathTranslatedByteStream {
 65     SVGPathTranslatedByteStream(const FloatPoint&amp; offset, const SVGPathByteStream&amp; rawStream)
 66         : m_offset(offset)
 67         , m_rawStream(rawStream)
 68     { }
 69 
 70     bool operator==(const SVGPathTranslatedByteStream&amp; other) const { return other.m_offset == m_offset &amp;&amp; other.m_rawStream == m_rawStream; }
 71     bool operator!=(const SVGPathTranslatedByteStream&amp; other) const { return !(*this == other); }
 72     bool isEmpty() const { return m_rawStream.isEmpty(); }
 73 
 74     Path path() const
 75     {
 76         Path path = buildPathFromByteStream(m_rawStream);
 77         path.translate(toFloatSize(m_offset));
 78         return path;
 79     }
 80 
 81     FloatPoint m_offset;
 82     SVGPathByteStream m_rawStream;
 83 };
 84 
 85 struct EllipsePathPolicy : public TinyLRUCachePolicy&lt;FloatRect, Path&gt; {
 86 public:
 87     static bool isKeyNull(const FloatRect&amp; rect) { return rect.isEmpty(); }
 88 
 89     static Path createValueForKey(const FloatRect&amp; rect)
 90     {
 91         Path path;
 92         path.addEllipse(rect);
 93         return path;
 94     }
 95 };
 96 
 97 struct RoundedRectPathPolicy : public TinyLRUCachePolicy&lt;FloatRoundedRect, Path&gt; {
 98 public:
 99     static bool isKeyNull(const FloatRoundedRect&amp; rect) { return rect.isEmpty(); }
100 
101     static Path createValueForKey(const FloatRoundedRect&amp; rect)
102     {
103         Path path;
104         path.addRoundedRect(rect);
105         return path;
106     }
107 };
108 
109 struct PolygonPathPolicy : public TinyLRUCachePolicy&lt;Vector&lt;FloatPoint&gt;, Path&gt; {
110 public:
111     static bool isKeyNull(const Vector&lt;FloatPoint&gt;&amp; points) { return !points.size(); }
112 
113     static Path createValueForKey(const Vector&lt;FloatPoint&gt;&amp; points) { return Path::polygonPathFromPoints(points); }
114 };
115 
116 struct TranslatedByteStreamPathPolicy : public TinyLRUCachePolicy&lt;SVGPathTranslatedByteStream, Path&gt; {
117 public:
118     static bool isKeyNull(const SVGPathTranslatedByteStream&amp; stream) { return stream.isEmpty(); }
119 
120     static Path createValueForKey(const SVGPathTranslatedByteStream&amp; stream) { return stream.path(); }
121 };
122 
123 static const Path&amp; cachedEllipsePath(const FloatRect&amp; rect)
124 {
125     static NeverDestroyed&lt;TinyLRUCache&lt;FloatRect, Path, 4, EllipsePathPolicy&gt;&gt; cache;
126     return cache.get().get(rect);
127 }
128 
129 static const Path&amp; cachedRoundedRectPath(const FloatRoundedRect&amp; rect)
130 {
131     static NeverDestroyed&lt;TinyLRUCache&lt;FloatRoundedRect, Path, 4, RoundedRectPathPolicy&gt;&gt; cache;
132     return cache.get().get(rect);
133 }
134 
135 static const Path&amp; cachedPolygonPath(const Vector&lt;FloatPoint&gt;&amp; points)
136 {
137     static NeverDestroyed&lt;TinyLRUCache&lt;Vector&lt;FloatPoint&gt;, Path, 4, PolygonPathPolicy&gt;&gt; cache;
138     return cache.get().get(points);
139 }
140 
141 static const Path&amp; cachedTranslatedByteStreamPath(const SVGPathByteStream&amp; stream, const FloatPoint&amp; offset)
142 {
143     static NeverDestroyed&lt;TinyLRUCache&lt;SVGPathTranslatedByteStream, Path, 4, TranslatedByteStreamPathPolicy&gt;&gt; cache;
144     return cache.get().get(SVGPathTranslatedByteStream(offset, stream));
145 }
146 
147 bool BasicShapeCircle::operator==(const BasicShape&amp; other) const
148 {
149     if (type() != other.type())
150         return false;
151 
152     auto&amp; otherCircle = downcast&lt;BasicShapeCircle&gt;(other);
153     return m_centerX == otherCircle.m_centerX
154         &amp;&amp; m_centerY == otherCircle.m_centerY
155         &amp;&amp; m_radius == otherCircle.m_radius;
156 }
157 
158 float BasicShapeCircle::floatValueForRadiusInBox(float boxWidth, float boxHeight) const
159 {
160     if (m_radius.type() == BasicShapeRadius::Value)
161         return floatValueForLength(m_radius.value(), std::hypot(boxWidth, boxHeight) / sqrtOfTwoFloat);
162 
163     float centerX = floatValueForCenterCoordinate(m_centerX, boxWidth);
164     float centerY = floatValueForCenterCoordinate(m_centerY, boxHeight);
165 
166     float widthDelta = std::abs(boxWidth - centerX);
167     float heightDelta = std::abs(boxHeight - centerY);
168     if (m_radius.type() == BasicShapeRadius::ClosestSide)
169         return std::min(std::min(std::abs(centerX), widthDelta), std::min(std::abs(centerY), heightDelta));
170 
171     // If radius.type() == BasicShapeRadius::FarthestSide.
172     return std::max(std::max(std::abs(centerX), widthDelta), std::max(std::abs(centerY), heightDelta));
173 }
174 
175 const Path&amp; BasicShapeCircle::path(const FloatRect&amp; boundingBox)
176 {
177     float centerX = floatValueForCenterCoordinate(m_centerX, boundingBox.width());
178     float centerY = floatValueForCenterCoordinate(m_centerY, boundingBox.height());
179     float radius = floatValueForRadiusInBox(boundingBox.width(), boundingBox.height());
180 
181     return cachedEllipsePath(FloatRect(centerX - radius + boundingBox.x(), centerY - radius + boundingBox.y(), radius * 2, radius * 2));
182 }
183 
184 bool BasicShapeCircle::canBlend(const BasicShape&amp; other) const
185 {
186     if (type() != other.type())
187         return false;
188 
189     return radius().canBlend(downcast&lt;BasicShapeCircle&gt;(other).radius());
190 }
191 
192 Ref&lt;BasicShape&gt; BasicShapeCircle::blend(const BasicShape&amp; other, double progress) const
193 {
194     ASSERT(type() == other.type());
195     auto&amp; otherCircle = downcast&lt;BasicShapeCircle&gt;(other);
196     auto result =  BasicShapeCircle::create();
197 
198     result-&gt;setCenterX(m_centerX.blend(otherCircle.centerX(), progress));
199     result-&gt;setCenterY(m_centerY.blend(otherCircle.centerY(), progress));
200     result-&gt;setRadius(m_radius.blend(otherCircle.radius(), progress));
201     return result;
202 }
203 
204 void BasicShapeCircle::dump(TextStream&amp; ts) const
205 {
206     ts.dumpProperty(&quot;center-x&quot;, centerX());
207     ts.dumpProperty(&quot;center-y&quot;, centerY());
208     ts.dumpProperty(&quot;radius&quot;, radius());
209 }
210 
211 bool BasicShapeEllipse::operator==(const BasicShape&amp; other) const
212 {
213     if (type() != other.type())
214         return false;
215 
216     auto&amp; otherEllipse = downcast&lt;BasicShapeEllipse&gt;(other);
217     return m_centerX == otherEllipse.m_centerX
218         &amp;&amp; m_centerY == otherEllipse.m_centerY
219         &amp;&amp; m_radiusX == otherEllipse.m_radiusX
220         &amp;&amp; m_radiusY == otherEllipse.m_radiusY;
221 }
222 
223 float BasicShapeEllipse::floatValueForRadiusInBox(const BasicShapeRadius&amp; radius, float center, float boxWidthOrHeight) const
224 {
225     if (radius.type() == BasicShapeRadius::Value)
226         return floatValueForLength(radius.value(), std::abs(boxWidthOrHeight));
227 
228     float widthOrHeightDelta = std::abs(boxWidthOrHeight - center);
229     if (radius.type() == BasicShapeRadius::ClosestSide)
230         return std::min(std::abs(center), widthOrHeightDelta);
231 
232     ASSERT(radius.type() == BasicShapeRadius::FarthestSide);
233     return std::max(std::abs(center), widthOrHeightDelta);
234 }
235 
236 const Path&amp; BasicShapeEllipse::path(const FloatRect&amp; boundingBox)
237 {
238     float centerX = floatValueForCenterCoordinate(m_centerX, boundingBox.width());
239     float centerY = floatValueForCenterCoordinate(m_centerY, boundingBox.height());
240     float radiusX = floatValueForRadiusInBox(m_radiusX, centerX, boundingBox.width());
241     float radiusY = floatValueForRadiusInBox(m_radiusY, centerY, boundingBox.height());
242 
243     return cachedEllipsePath(FloatRect(centerX - radiusX + boundingBox.x(), centerY - radiusY + boundingBox.y(), radiusX * 2, radiusY * 2));
244 }
245 
246 bool BasicShapeEllipse::canBlend(const BasicShape&amp; other) const
247 {
248     if (type() != other.type())
249         return false;
250 
251     auto&amp; otherEllipse = downcast&lt;BasicShapeEllipse&gt;(other);
252     return radiusX().canBlend(otherEllipse.radiusX()) &amp;&amp; radiusY().canBlend(otherEllipse.radiusY());
253 }
254 
255 Ref&lt;BasicShape&gt; BasicShapeEllipse::blend(const BasicShape&amp; other, double progress) const
256 {
257     ASSERT(type() == other.type());
258     auto&amp; otherEllipse = downcast&lt;BasicShapeEllipse&gt;(other);
259     auto result = BasicShapeEllipse::create();
260 
261     if (m_radiusX.type() != BasicShapeRadius::Value || otherEllipse.radiusX().type() != BasicShapeRadius::Value
262         || m_radiusY.type() != BasicShapeRadius::Value || otherEllipse.radiusY().type() != BasicShapeRadius::Value) {
263         result-&gt;setCenterX(otherEllipse.centerX());
264         result-&gt;setCenterY(otherEllipse.centerY());
265         result-&gt;setRadiusX(otherEllipse.radiusX());
266         result-&gt;setRadiusY(otherEllipse.radiusY());
267         return result;
268     }
269 
270     result-&gt;setCenterX(m_centerX.blend(otherEllipse.centerX(), progress));
271     result-&gt;setCenterY(m_centerY.blend(otherEllipse.centerY(), progress));
272     result-&gt;setRadiusX(m_radiusX.blend(otherEllipse.radiusX(), progress));
273     result-&gt;setRadiusY(m_radiusY.blend(otherEllipse.radiusY(), progress));
274     return result;
275 }
276 
277 void BasicShapeEllipse::dump(TextStream&amp; ts) const
278 {
279     ts.dumpProperty(&quot;center-x&quot;, centerX());
280     ts.dumpProperty(&quot;center-y&quot;, centerY());
281     ts.dumpProperty(&quot;radius-x&quot;, radiusX());
282     ts.dumpProperty(&quot;radius-y&quot;, radiusY());
283 }
284 
285 bool BasicShapePolygon::operator==(const BasicShape&amp; other) const
286 {
287     if (type() != other.type())
288         return false;
289 
290     auto&amp; otherPolygon = downcast&lt;BasicShapePolygon&gt;(other);
291     return m_windRule == otherPolygon.m_windRule
292         &amp;&amp; m_values == otherPolygon.m_values;
293 }
294 
295 const Path&amp; BasicShapePolygon::path(const FloatRect&amp; boundingBox)
296 {
297     ASSERT(!(m_values.size() % 2));
298     size_t length = m_values.size();
299 
300     Vector&lt;FloatPoint&gt; points(length / 2);
301     for (size_t i = 0; i &lt; points.size(); ++i) {
302         points[i].setX(floatValueForLength(m_values.at(i * 2), boundingBox.width()) + boundingBox.x());
303         points[i].setY(floatValueForLength(m_values.at(i * 2 + 1), boundingBox.height()) + boundingBox.y());
304     }
305 
306     return cachedPolygonPath(points);
307 }
308 
309 bool BasicShapePolygon::canBlend(const BasicShape&amp; other) const
310 {
311     if (type() != other.type())
312         return false;
313 
314     auto&amp; otherPolygon = downcast&lt;BasicShapePolygon&gt;(other);
315     return values().size() == otherPolygon.values().size() &amp;&amp; windRule() == otherPolygon.windRule();
316 }
317 
318 Ref&lt;BasicShape&gt; BasicShapePolygon::blend(const BasicShape&amp; other, double progress) const
319 {
320     ASSERT(type() == other.type());
321 
322     auto&amp; otherPolygon = downcast&lt;BasicShapePolygon&gt;(other);
323     ASSERT(m_values.size() == otherPolygon.values().size());
324     ASSERT(!(m_values.size() % 2));
325 
326     size_t length = m_values.size();
327     auto result = BasicShapePolygon::create();
328     if (!length)
329         return result;
330 
331     result-&gt;setWindRule(otherPolygon.windRule());
332 
333     for (size_t i = 0; i &lt; length; i = i + 2) {
334         result-&gt;appendPoint(
335             WebCore::blend(otherPolygon.values().at(i), m_values.at(i), progress),
336             WebCore::blend(otherPolygon.values().at(i + 1), m_values.at(i + 1), progress));
337     }
338 
339     return result;
340 }
341 
342 void BasicShapePolygon::dump(TextStream&amp; ts) const
343 {
344     ts.dumpProperty(&quot;wind-rule&quot;, windRule());
345     ts.dumpProperty(&quot;path&quot;, values());
346 }
347 
348 BasicShapePath::BasicShapePath(std::unique_ptr&lt;SVGPathByteStream&gt;&amp;&amp; byteStream)
349     : m_byteStream(WTFMove(byteStream))
350 {
351 }
352 
353 const Path&amp; BasicShapePath::path(const FloatRect&amp; boundingBox)
354 {
355     return cachedTranslatedByteStreamPath(*m_byteStream, boundingBox.location());
356 }
357 
358 bool BasicShapePath::operator==(const BasicShape&amp; other) const
359 {
360     if (type() != other.type())
361         return false;
362 
363     auto&amp; otherPath = downcast&lt;BasicShapePath&gt;(other);
364     return m_windRule == otherPath.m_windRule &amp;&amp; *m_byteStream == *otherPath.m_byteStream;
365 }
366 
367 bool BasicShapePath::canBlend(const BasicShape&amp; other) const
368 {
369     if (type() != other.type())
370         return false;
371 
372     auto&amp; otherPath = downcast&lt;BasicShapePath&gt;(other);
373     return windRule() == otherPath.windRule() &amp;&amp; canBlendSVGPathByteStreams(*m_byteStream, *otherPath.pathData());
374 }
375 
376 Ref&lt;BasicShape&gt; BasicShapePath::blend(const BasicShape&amp; from, double progress) const
377 {
378     ASSERT(type() == from.type());
379 
380     auto&amp; fromPath = downcast&lt;BasicShapePath&gt;(from);
381 
382     auto resultingPathBytes = makeUnique&lt;SVGPathByteStream&gt;();
383     buildAnimatedSVGPathByteStream(*fromPath.m_byteStream, *m_byteStream, *resultingPathBytes, progress);
384 
385     auto result = BasicShapePath::create(WTFMove(resultingPathBytes));
386     result-&gt;setWindRule(windRule());
387     return result;
388 }
389 
390 void BasicShapePath::dump(TextStream&amp; ts) const
391 {
392     ts.dumpProperty(&quot;wind-rule&quot;, windRule());
393     // FIXME: print the byte stream?
394 }
395 
396 bool BasicShapeInset::operator==(const BasicShape&amp; other) const
397 {
398     if (type() != other.type())
399         return false;
400 
401     auto&amp; otherInset = downcast&lt;BasicShapeInset&gt;(other);
402     return m_right == otherInset.m_right
403         &amp;&amp; m_top == otherInset.m_top
404         &amp;&amp; m_bottom == otherInset.m_bottom
405         &amp;&amp; m_left == otherInset.m_left
406         &amp;&amp; m_topLeftRadius == otherInset.m_topLeftRadius
407         &amp;&amp; m_topRightRadius == otherInset.m_topRightRadius
408         &amp;&amp; m_bottomRightRadius == otherInset.m_bottomRightRadius
409         &amp;&amp; m_bottomLeftRadius == otherInset.m_bottomLeftRadius;
410 }
411 
412 static FloatSize floatSizeForLengthSize(const LengthSize&amp; lengthSize, const FloatRect&amp; boundingBox)
413 {
414     return { floatValueForLength(lengthSize.width, boundingBox.width()),
415         floatValueForLength(lengthSize.height, boundingBox.height()) };
416 }
417 
418 const Path&amp; BasicShapeInset::path(const FloatRect&amp; boundingBox)
419 {
420     float left = floatValueForLength(m_left, boundingBox.width());
421     float top = floatValueForLength(m_top, boundingBox.height());
422     auto rect = FloatRect(left + boundingBox.x(), top + boundingBox.y(),
423         std::max&lt;float&gt;(boundingBox.width() - left - floatValueForLength(m_right, boundingBox.width()), 0),
424         std::max&lt;float&gt;(boundingBox.height() - top - floatValueForLength(m_bottom, boundingBox.height()), 0));
425     auto radii = FloatRoundedRect::Radii(floatSizeForLengthSize(m_topLeftRadius, boundingBox),
426         floatSizeForLengthSize(m_topRightRadius, boundingBox),
427         floatSizeForLengthSize(m_bottomLeftRadius, boundingBox),
428         floatSizeForLengthSize(m_bottomRightRadius, boundingBox));
429     radii.scale(calcBorderRadiiConstraintScaleFor(rect, radii));
430 
431     return cachedRoundedRectPath(FloatRoundedRect(rect, radii));
432 }
433 
434 bool BasicShapeInset::canBlend(const BasicShape&amp; other) const
435 {
436     return type() == other.type();
437 }
438 
439 Ref&lt;BasicShape&gt; BasicShapeInset::blend(const BasicShape&amp; from, double progress) const
440 {
441     ASSERT(type() == from.type());
442 
443     auto&amp; fromInset = downcast&lt;BasicShapeInset&gt;(from);
444     auto result =  BasicShapeInset::create();
445     result-&gt;setTop(WebCore::blend(fromInset.top(), top(), progress));
446     result-&gt;setRight(WebCore::blend(fromInset.right(), right(), progress));
447     result-&gt;setBottom(WebCore::blend(fromInset.bottom(), bottom(), progress));
448     result-&gt;setLeft(WebCore::blend(fromInset.left(), left(), progress));
449 
450     result-&gt;setTopLeftRadius(WebCore::blend(fromInset.topLeftRadius(), topLeftRadius(), progress));
451     result-&gt;setTopRightRadius(WebCore::blend(fromInset.topRightRadius(), topRightRadius(), progress));
452     result-&gt;setBottomRightRadius(WebCore::blend(fromInset.bottomRightRadius(), bottomRightRadius(), progress));
453     result-&gt;setBottomLeftRadius(WebCore::blend(fromInset.bottomLeftRadius(), bottomLeftRadius(), progress));
454 
455     return result;
456 }
457 
458 void BasicShapeInset::dump(TextStream&amp; ts) const
459 {
460     ts.dumpProperty(&quot;top&quot;, top());
461     ts.dumpProperty(&quot;right&quot;, right());
462     ts.dumpProperty(&quot;bottom&quot;, bottom());
463     ts.dumpProperty(&quot;left&quot;, left());
464 
465     ts.dumpProperty(&quot;top-left-radius&quot;, topLeftRadius());
466     ts.dumpProperty(&quot;top-right-radius&quot;, topRightRadius());
467     ts.dumpProperty(&quot;bottom-right-radius&quot;, bottomRightRadius());
468     ts.dumpProperty(&quot;bottom-left-radius&quot;, bottomLeftRadius());
469 }
470 
471 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, BasicShapeRadius::Type radiusType)
472 {
473     switch (radiusType) {
474     case BasicShapeRadius::Value: ts &lt;&lt; &quot;value&quot;; break;
475     case BasicShapeRadius::ClosestSide: ts &lt;&lt; &quot;closest-side&quot;; break;
476     case BasicShapeRadius::FarthestSide: ts &lt;&lt; &quot;farthest-side&quot;; break;
477     }
478     return ts;
479 }
480 
481 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const BasicShapeRadius&amp; radius)
482 {
483     ts.dumpProperty(&quot;value&quot;, radius.value());
484     ts.dumpProperty(&quot;type&quot;, radius.type());
485     return ts;
486 }
487 
488 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const BasicShapeCenterCoordinate&amp; coordinate)
489 {
490     ts.dumpProperty(&quot;direction&quot;, coordinate.direction() == BasicShapeCenterCoordinate::TopLeft ? &quot;top left&quot; : &quot;bottom right&quot;);
491     ts.dumpProperty(&quot;length&quot;, coordinate.length());
492     return ts;
493 }
494 
495 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const BasicShape&amp; shape)
496 {
497     shape.dump(ts);
498     return ts;
499 }
500 
501 } // namespace WebCore
    </pre>
  </body>
</html>
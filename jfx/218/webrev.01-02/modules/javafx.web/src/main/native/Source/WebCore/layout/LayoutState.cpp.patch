diff a/modules/javafx.web/src/main/native/Source/WebCore/layout/LayoutState.cpp b/modules/javafx.web/src/main/native/Source/WebCore/layout/LayoutState.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/layout/LayoutState.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/layout/LayoutState.cpp
@@ -26,196 +26,189 @@
 #include "config.h"
 #include "LayoutState.h"
 
 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 
-#include "BlockFormattingContext.h"
 #include "BlockFormattingState.h"
-#include "BlockInvalidation.h"
 #include "DisplayBox.h"
-#include "InlineFormattingContext.h"
+#include "FloatingState.h"
 #include "InlineFormattingState.h"
-#include "InlineInvalidation.h"
-#include "Invalidation.h"
 #include "LayoutBox.h"
 #include "LayoutContainer.h"
-#include "LayoutPhase.h"
-#include "LayoutTreeBuilder.h"
-#include "RenderView.h"
-#include "TableFormattingContext.h"
+#include "RenderBox.h"
+#include "RuntimeEnabledFeatures.h"
 #include "TableFormattingState.h"
 #include <wtf/IsoMallocInlines.h>
 
 namespace WebCore {
 namespace Layout {
 
 WTF_MAKE_ISO_ALLOCATED_IMPL(LayoutState);
 
-LayoutState::LayoutState(const Container& initialContainingBlock)
-    : m_initialContainingBlock(makeWeakPtr(initialContainingBlock))
+LayoutState::LayoutState(const Document& document, const Container& rootContainer)
+    : m_rootContainer(makeWeakPtr(rootContainer))
 {
-    // LayoutState is always initiated with the ICB.
-    ASSERT(!initialContainingBlock.parent());
-    ASSERT(initialContainingBlock.establishesBlockFormattingContext());
+    // It makes absolutely no sense to construct a dedicated layout state for a non-formatting context root (layout would be a no-op).
+    ASSERT(root().establishesFormattingContext());
 
-    auto& displayBox = displayBoxForLayoutBox(initialContainingBlock);
-    displayBox.setHorizontalMargin({ });
-    displayBox.setHorizontalComputedMargin({ });
-    displayBox.setVerticalMargin({ });
-    displayBox.setBorder({ });
-    displayBox.setPadding({ });
-    displayBox.setTopLeft({ });
-    displayBox.setContentBoxHeight(LayoutUnit(initialContainingBlock.style().logicalHeight().value()));
-    displayBox.setContentBoxWidth(LayoutUnit(initialContainingBlock.style().logicalWidth().value()));
+    auto quirksMode = [&] {
+        if (document.inLimitedQuirksMode())
+            return LayoutState::QuirksMode::Limited;
+        if (document.inQuirksMode())
+            return LayoutState::QuirksMode::Yes;
+        return LayoutState::QuirksMode::No;
+    };
+    setQuirksMode(quirksMode());
+}
+
+LayoutState::~LayoutState() = default;
 
-    m_formattingContextRootListForLayout.add(&initialContainingBlock);
+Display::Box& LayoutState::displayBoxForRootLayoutBox()
+{
+    return ensureDisplayBoxForLayoutBox(root());
 }
 
-void LayoutState::updateLayout()
+Display::Box& LayoutState::ensureDisplayBoxForLayoutBoxSlow(const Box& layoutBox)
 {
-    PhaseScope scope(Phase::Type::Layout);
+    if (layoutBox.canCacheForLayoutState(*this)) {
+        ASSERT(!layoutBox.cachedDisplayBoxForLayoutState(*this));
+        auto newBox = makeUnique<Display::Box>();
+        auto& newBoxPtr = *newBox;
+        layoutBox.setCachedDisplayBoxForLayoutState(*this, WTFMove(newBox));
+        return newBoxPtr;
+    }
 
-    ASSERT(!m_formattingContextRootListForLayout.isEmpty());
-    for (auto* layoutRoot : m_formattingContextRootListForLayout)
-        layoutFormattingContextSubtree(*layoutRoot);
-    m_formattingContextRootListForLayout.clear();
+    return *m_layoutToDisplayBox.ensure(&layoutBox, [] {
+        return makeUnique<Display::Box>();
+    }).iterator->value;
 }
 
-void LayoutState::layoutFormattingContextSubtree(const Box& layoutRoot)
+FormattingState& LayoutState::formattingStateForBox(const Box& layoutBox) const
 {
-    RELEASE_ASSERT(layoutRoot.establishesFormattingContext());
-    auto formattingContext = createFormattingContext(layoutRoot);
-    formattingContext->layout();
-    formattingContext->layoutOutOfFlowContent();
+    return establishedFormattingState(layoutBox.formattingContextRoot());
 }
 
-Display::Box& LayoutState::displayBoxForLayoutBox(const Box& layoutBox) const
+FormattingState& LayoutState::establishedFormattingState(const Container& formattingContextRoot) const
 {
-    return *m_layoutToDisplayBox.ensure(&layoutBox, [&layoutBox] {
-        return makeUnique<Display::Box>(layoutBox.style());
-    }).iterator->value;
+    if (RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled()) {
+        ASSERT(&formattingContextRoot == m_rootContainer.get());
+        return *m_rootInlineFormattingStateForIntegration;
+    }
+
+    if (auto* formattingState = m_inlineFormattingStates.get(&formattingContextRoot))
+        return *formattingState;
+
+    if (auto* formattingState = m_blockFormattingStates.get(&formattingContextRoot))
+        return *formattingState;
+
+    ASSERT(m_tableFormattingStates.contains(&formattingContextRoot));
+    return *m_tableFormattingStates.get(&formattingContextRoot);
 }
 
-void LayoutState::styleChanged(const Box& layoutBox, StyleDiff styleDiff)
+InlineFormattingState& LayoutState::establishedInlineFormattingState(const Container& formattingContextRoot) const
 {
-    PhaseScope scope(Phase::Type::Invalidation);
+    ASSERT(formattingContextRoot.establishesInlineFormattingContext());
+
+    if (RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled()) {
+        ASSERT(&formattingContextRoot == m_rootContainer.get());
+        return *m_rootInlineFormattingStateForIntegration;
+    }
 
-    auto& formattingState = formattingStateForBox(layoutBox);
-    const Container* invalidationRoot = nullptr;
-    if (is<BlockFormattingState>(formattingState))
-        invalidationRoot = BlockInvalidation::invalidate(layoutBox, styleDiff, *this, downcast<BlockFormattingState>(formattingState)).root;
-    else if (is<InlineFormattingState>(formattingState))
-        invalidationRoot = InlineInvalidation::invalidate(layoutBox, styleDiff, *this, downcast<InlineFormattingState>(formattingState)).root;
-    else
-        ASSERT_NOT_IMPLEMENTED_YET();
-    ASSERT(invalidationRoot);
-    m_formattingContextRootListForLayout.addVoid(invalidationRoot);
+    return *m_inlineFormattingStates.get(&formattingContextRoot);
 }
 
-void LayoutState::markNeedsUpdate(const Box&, OptionSet<UpdateType>)
+BlockFormattingState& LayoutState::establishedBlockFormattingState(const Container& formattingContextRoot) const
 {
+    ASSERT(formattingContextRoot.establishesBlockFormattingContext());
+    return *m_blockFormattingStates.get(&formattingContextRoot);
 }
 
-FormattingState& LayoutState::formattingStateForBox(const Box& layoutBox) const
+TableFormattingState& LayoutState::establishedTableFormattingState(const Container& formattingContextRoot) const
 {
-    auto& root = layoutBox.formattingContextRoot();
-    RELEASE_ASSERT(m_formattingStates.contains(&root));
-    return *m_formattingStates.get(&root);
+    ASSERT(formattingContextRoot.establishesTableFormattingContext());
+    return *m_tableFormattingStates.get(&formattingContextRoot);
 }
 
-FormattingState& LayoutState::establishedFormattingState(const Box& formattingRoot) const
+FormattingState& LayoutState::ensureFormattingState(const Container& formattingContextRoot)
 {
-    ASSERT(formattingRoot.establishesFormattingContext());
-    RELEASE_ASSERT(m_formattingStates.contains(&formattingRoot));
-    return *m_formattingStates.get(&formattingRoot);
+    if (formattingContextRoot.establishesInlineFormattingContext())
+        return ensureInlineFormattingState(formattingContextRoot);
+
+    if (formattingContextRoot.establishesBlockFormattingContext())
+        return ensureBlockFormattingState(formattingContextRoot);
+
+    return ensureTableFormattingState(formattingContextRoot);
 }
 
-FormattingState& LayoutState::createFormattingStateForFormattingRootIfNeeded(const Box& formattingRoot)
+InlineFormattingState& LayoutState::ensureInlineFormattingState(const Container& formattingContextRoot)
 {
-    ASSERT(formattingRoot.establishesFormattingContext());
-
-    if (formattingRoot.establishesInlineFormattingContext()) {
-        return *m_formattingStates.ensure(&formattingRoot, [&] {
-
-            // If the block container box that initiates this inline formatting context also establishes a block context, the floats outside of the formatting root
-            // should not interfere with the content inside.
-            // <div style="float: left"></div><div style="overflow: hidden"> <- is a non-intrusive float, because overflow: hidden triggers new block formatting context.</div>
-            if (formattingRoot.establishesBlockFormattingContext())
-                return makeUnique<InlineFormattingState>(FloatingState::create(*this, formattingRoot), *this);
-
-            // Otherwise, the formatting context inherits the floats from the parent formatting context.
-            // Find the formatting state in which this formatting root lives, not the one it creates and use its floating state.
-            auto& parentFormattingState = createFormattingStateForFormattingRootIfNeeded(formattingRoot.formattingContextRoot());
-            auto& parentFloatingState = parentFormattingState.floatingState();
-            return makeUnique<InlineFormattingState>(parentFloatingState, *this);
-        }).iterator->value;
-    }
-
-    if (formattingRoot.establishesBlockFormattingContext()) {
-        return *m_formattingStates.ensure(&formattingRoot, [&] {
+    ASSERT(formattingContextRoot.establishesInlineFormattingContext());
+
+    auto create = [&] {
+        // If the block container box that initiates this inline formatting context also establishes a block context, the floats outside of the formatting root
+        // should not interfere with the content inside.
+        // <div style="float: left"></div><div style="overflow: hidden"> <- is a non-intrusive float, because overflow: hidden triggers new block formatting context.</div>
+        if (formattingContextRoot.establishesBlockFormattingContext())
+            return makeUnique<InlineFormattingState>(FloatingState::create(*this, formattingContextRoot), *this);
+
+        // Otherwise, the formatting context inherits the floats from the parent formatting context.
+        // Find the formatting state in which this formatting root lives, not the one it creates and use its floating state.
+        auto& parentFormattingState = ensureFormattingState(formattingContextRoot.formattingContextRoot());
+        auto& parentFloatingState = parentFormattingState.floatingState();
+        return makeUnique<InlineFormattingState>(parentFloatingState, *this);
+    };
 
-            // Block formatting context always establishes a new floating state.
-            return makeUnique<BlockFormattingState>(FloatingState::create(*this, formattingRoot), *this);
-        }).iterator->value;
+    if (RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled()) {
+        if (!m_rootInlineFormattingStateForIntegration) {
+            ASSERT(&formattingContextRoot == m_rootContainer.get());
+            m_rootInlineFormattingStateForIntegration = create();
+        }
+        return *m_rootInlineFormattingStateForIntegration;
     }
 
-    if (formattingRoot.establishesTableFormattingContext()) {
-        return *m_formattingStates.ensure(&formattingRoot, [&] {
+    return *m_inlineFormattingStates.ensure(&formattingContextRoot, create).iterator->value;
+}
 
-            // Table formatting context always establishes a new floating state -and it stays empty.
-            return makeUnique<TableFormattingState>(FloatingState::create(*this, formattingRoot), *this);
-        }).iterator->value;
-    }
+BlockFormattingState& LayoutState::ensureBlockFormattingState(const Container& formattingContextRoot)
+{
+    ASSERT(formattingContextRoot.establishesBlockFormattingContext());
 
-    CRASH();
+    auto create = [&] {
+        return makeUnique<BlockFormattingState>(FloatingState::create(*this, formattingContextRoot), *this);
+    };
+
+    return *m_blockFormattingStates.ensure(&formattingContextRoot, create).iterator->value;
 }
 
-std::unique_ptr<FormattingContext> LayoutState::createFormattingContext(const Box& formattingContextRoot)
+TableFormattingState& LayoutState::ensureTableFormattingState(const Container& formattingContextRoot)
 {
-    ASSERT(formattingContextRoot.establishesFormattingContext());
-    if (formattingContextRoot.establishesInlineFormattingContext()) {
-        auto& inlineFormattingState = downcast<InlineFormattingState>(createFormattingStateForFormattingRootIfNeeded(formattingContextRoot));
-        return makeUnique<InlineFormattingContext>(formattingContextRoot, inlineFormattingState);
-    }
+    ASSERT(formattingContextRoot.establishesTableFormattingContext());
 
-    if (formattingContextRoot.establishesBlockFormattingContext()) {
-        ASSERT(formattingContextRoot.establishesBlockFormattingContextOnly());
-        auto& blockFormattingState = downcast<BlockFormattingState>(createFormattingStateForFormattingRootIfNeeded(formattingContextRoot));
-        return makeUnique<BlockFormattingContext>(formattingContextRoot, blockFormattingState);
-    }
+    auto create = [&] {
+        // Table formatting context always establishes a new floating state -and it stays empty.
+        return makeUnique<TableFormattingState>(FloatingState::create(*this, formattingContextRoot), *this);
+    };
 
-    if (formattingContextRoot.establishesTableFormattingContext()) {
-        auto& tableFormattingState = downcast<TableFormattingState>(createFormattingStateForFormattingRootIfNeeded(formattingContextRoot));
-        return makeUnique<TableFormattingContext>(formattingContextRoot, tableFormattingState);
-    }
+    return *m_tableFormattingStates.ensure(&formattingContextRoot, create).iterator->value;
+}
 
-    CRASH();
+void LayoutState::setViewportSize(const LayoutSize& viewportSize)
+{
+    ASSERT(RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled());
+    m_viewportSize = viewportSize;
 }
 
-void LayoutState::run(const RenderView& renderView)
+LayoutSize LayoutState::viewportSize() const
 {
-    auto initialContainingBlock = TreeBuilder::createLayoutTree(renderView);
-    auto layoutState = LayoutState(*initialContainingBlock);
-    // Not efficient, but this is temporary anyway.
-    // Collect the out-of-flow descendants at the formatting root level (as opposed to at the containing block level, though they might be the same).
-    for (auto& descendant : descendantsOfType<Box>(*initialContainingBlock)) {
-        if (!descendant.isOutOfFlowPositioned())
-            continue;
-        auto& formattingState = layoutState.createFormattingStateForFormattingRootIfNeeded(descendant.formattingContextRoot());
-        formattingState.addOutOfFlowBox(descendant);
-    }
-    auto quirksMode = [&] {
-        auto& document = renderView.document();
-        if (document.inLimitedQuirksMode())
-            return QuirksMode::Limited;
-        if (document.inQuirksMode())
-            return QuirksMode::Yes;
-        return QuirksMode::No;
-    };
-    layoutState.setQuirksMode(quirksMode());
-    layoutState.updateLayout();
-    layoutState.verifyAndOutputMismatchingLayoutTree(renderView);
+    ASSERT(RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled());
+    return m_viewportSize;
+}
+
+void LayoutState::setIsIntegratedRootBoxFirstChild(bool value)
+{
+    ASSERT(RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled());
+    m_isIntegratedRootBoxFirstChild = value;
 }
 
 }
 }
 

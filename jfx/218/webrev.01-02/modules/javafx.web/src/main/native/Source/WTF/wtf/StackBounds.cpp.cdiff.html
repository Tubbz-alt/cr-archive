<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WTF/wtf/StackBounds.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SmallPtrSet.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StackBounds.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/StackBounds.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  *  Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.</span>
   *  Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
   *
   *  This library is free software; you can redistribute it and/or
   *  modify it under the terms of the GNU Lesser General Public
   *  License as published by the Free Software Foundation; either
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.</span>
   *  Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
   *
   *  This library is free software; you can redistribute it and/or
   *  modify it under the terms of the GNU Lesser General Public
   *  License as published by the Free Software Foundation; either
</pre>
<hr />
<pre>
<span class="line-old-header">*** 46,69 ***</span>
  namespace WTF {
  
  #if PLATFORM(JAVA)
  // 16K is a safe value to guard java stack red zone
  #define JAVA_RED_ZONE 0x4000
<span class="line-removed">- #if OS(WINDOWS)</span>
<span class="line-removed">- // This is safe for the default stack sizes in all supported Windows</span>
<span class="line-removed">- // configurations, but is not safe for stack sizes lower than the default.</span>
<span class="line-removed">- #if CPU(X86_64)</span>
<span class="line-removed">- static const ptrdiff_t estimatedStackSize = 1024 * 1024;</span>
<span class="line-removed">- #else</span>
<span class="line-removed">- // estimatedStackSize needs to be a little greater than 256KB to keep</span>
<span class="line-removed">- // Interpreter::StackPolicy::StackPolicy happy and less than 320KB</span>
<span class="line-removed">- // to play safe against the default stack size on 32 bit Windows.</span>
<span class="line-removed">- static const ptrdiff_t estimatedStackSize = 272 * 1024;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if CPU(X86) || CPU(X86_64) || CPU(ARM) || CPU(ARM64) || CPU(MIPS)</span>
<span class="line-removed">- ALWAYS_INLINE StackBounds::StackDirection StackBounds::stackDirection()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return StackDirection::Downward;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #else</span>
<span class="line-removed">- static NEVER_INLINE NOT_TAIL_CALLED StackBounds::StackDirection testStackDirection2(volatile const uint8_t* pointer)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     volatile uint8_t* stackValue = bitwise_cast&lt;uint8_t*&gt;(currentStackPointer());</span>
<span class="line-removed">-     return (pointer &lt; stackValue) ? StackBounds::StackDirection::Upward : StackBounds::StackDirection::Downward;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static NEVER_INLINE NOT_TAIL_CALLED StackBounds::StackDirection testStackDirection()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     NO_TAIL_CALLS();</span>
<span class="line-removed">-     volatile uint8_t* stackValue = bitwise_cast&lt;uint8_t*&gt;(currentStackPointer());</span>
<span class="line-removed">-     return testStackDirection2(stackValue);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- NEVER_INLINE StackBounds::StackDirection StackBounds::stackDirection()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     static StackBounds::StackDirection result = StackBounds::StackDirection::Downward;</span>
<span class="line-removed">-     static std::once_flag onceKey;</span>
<span class="line-removed">-     std::call_once(onceKey, [] {</span>
<span class="line-removed">-         NO_TAIL_CALLS();</span>
<span class="line-removed">-         result = testStackDirection();</span>
<span class="line-removed">-     });</span>
<span class="line-removed">-     return result;</span>
<span class="line-removed">- }</span>
  #endif
  
  #if OS(DARWIN)
  
  StackBounds StackBounds::newThreadStackBounds(PlatformThreadHandle thread)
  {
<span class="line-removed">-     ASSERT(stackDirection() == StackDirection::Downward);</span>
      void* origin = pthread_get_stackaddr_np(thread);
      rlim_t size = pthread_get_stacksize_np(thread);
      void* bound = static_cast&lt;char*&gt;(origin) - size;
      return StackBounds { origin, bound };
  }
  
  StackBounds StackBounds::currentThreadStackBoundsInternal()
  {
<span class="line-removed">-     ASSERT(stackDirection() == StackDirection::Downward);</span>
      if (pthread_main_np()) {
          // FIXME: &lt;rdar://problem/13741204&gt;
          // pthread_get_size lies to us when we&#39;re the main thread, use get_rlimit instead
          void* origin = pthread_get_stackaddr_np(pthread_self());
          rlimit limit;
<span class="line-new-header">--- 46,24 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 130,15 ***</span>
  StackBounds StackBounds::newThreadStackBounds(PlatformThreadHandle thread)
  {
      stack_t stack;
      pthread_stackseg_np(thread, &amp;stack);
      void* origin = stack.ss_sp;
<span class="line-modified">!     void* bound = nullptr;</span>
<span class="line-removed">-     if (stackDirection() == StackDirection::Upward)</span>
<span class="line-removed">-         bound = static_cast&lt;char*&gt;(origin) + stack.ss_size;</span>
<span class="line-removed">-     else</span>
<span class="line-removed">-         bound = static_cast&lt;char*&gt;(origin) - stack.ss_size;</span>
      return StackBounds { origin, bound };
  }
  
  #else // !OS(OPENBSD)
  
<span class="line-new-header">--- 85,11 ---</span>
  StackBounds StackBounds::newThreadStackBounds(PlatformThreadHandle thread)
  {
      stack_t stack;
      pthread_stackseg_np(thread, &amp;stack);
      void* origin = stack.ss_sp;
<span class="line-modified">!     void* bound = static_cast&lt;char*&gt;(origin) - stack.ss_size;</span>
      return StackBounds { origin, bound };
  }
  
  #else // !OS(OPENBSD)
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 163,14 ***</span>
      void* origin = static_cast&lt;char*&gt;(bound) + stackSize;
  #if PLATFORM(JAVA)
      bound = static_cast&lt;char*&gt;(bound) + JAVA_RED_ZONE;
  #endif
      // pthread_attr_getstack&#39;s bound is the lowest accessible pointer of the stack.
<span class="line-removed">-     // If stack grows up, origin and bound in this code should be swapped.</span>
<span class="line-removed">-     if (stackDirection() == StackDirection::Upward)</span>
<span class="line-removed">-         std::swap(origin, bound);</span>
<span class="line-removed">- </span>
      return StackBounds { origin, bound };
  }
  
  #endif // OS(OPENBSD)
  
<span class="line-new-header">--- 114,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 181,16 ***</span>
  
  #elif OS(WINDOWS)
  
  StackBounds StackBounds::currentThreadStackBoundsInternal()
  {
<span class="line-removed">-     ASSERT(stackDirection() == StackDirection::Downward);</span>
      MEMORY_BASIC_INFORMATION stackOrigin { };
      VirtualQuery(&amp;stackOrigin, &amp;stackOrigin, sizeof(stackOrigin));
      // stackOrigin.AllocationBase points to the reserved stack memory base address.
  
      void* origin = static_cast&lt;char*&gt;(stackOrigin.BaseAddress) + stackOrigin.RegionSize;
      // The stack on Windows consists out of three parts (uncommitted memory, a guard page and present
      // committed memory). The 3 regions have different BaseAddresses but all have the same AllocationBase
      // since they are all from the same VirtualAlloc. The 3 regions are laid out in memory (from high to
      // low) as follows:
      //
<span class="line-new-header">--- 128,17 ---</span>
  
  #elif OS(WINDOWS)
  
  StackBounds StackBounds::currentThreadStackBoundsInternal()
  {
      MEMORY_BASIC_INFORMATION stackOrigin { };
      VirtualQuery(&amp;stackOrigin, &amp;stackOrigin, sizeof(stackOrigin));
      // stackOrigin.AllocationBase points to the reserved stack memory base address.
  
<span class="line-added">+     const LPVOID theAllocBase = stackOrigin.AllocationBase;</span>
      void* origin = static_cast&lt;char*&gt;(stackOrigin.BaseAddress) + stackOrigin.RegionSize;
<span class="line-added">+ </span>
      // The stack on Windows consists out of three parts (uncommitted memory, a guard page and present
      // committed memory). The 3 regions have different BaseAddresses but all have the same AllocationBase
      // since they are all from the same VirtualAlloc. The 3 regions are laid out in memory (from high to
      // low) as follows:
      //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 202,27 ***</span>
      //         | uncommittedMemory |    v
      //    Low  |-------------------|  ----- &lt;--- stackOrigin.AllocationBase
      //
      // See http://msdn.microsoft.com/en-us/library/ms686774%28VS.85%29.aspx for more information.
  
<span class="line-removed">-     MEMORY_BASIC_INFORMATION uncommittedMemory;</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if PLATFORM(JAVA)</span>
      // look for uncommited memory block.
<span class="line-modified">!     const LPVOID theAllocBase = stackOrigin.AllocationBase;</span>
      LPVOID a = stackOrigin.AllocationBase;
  
      do {
          size_t ret = VirtualQuery(a, &amp;uncommittedMemory, sizeof(uncommittedMemory));
          ASSERT(ret != 0);
          a = (LPVOID)((static_cast&lt;char*&gt;(a)) + uncommittedMemory.RegionSize);
      } while (theAllocBase == uncommittedMemory.AllocationBase &amp;&amp;
          uncommittedMemory.State != MEM_RESERVE);
<span class="line-removed">- #else</span>
<span class="line-removed">-     VirtualQuery(stackOrigin.AllocationBase, &amp;uncommittedMemory, sizeof(uncommittedMemory));</span>
<span class="line-removed">-     ASSERT(uncommittedMemory.State == MEM_RESERVE);</span>
<span class="line-removed">- #endif</span>
  
      MEMORY_BASIC_INFORMATION guardPage;
      VirtualQuery(static_cast&lt;char*&gt;(uncommittedMemory.BaseAddress) + uncommittedMemory.RegionSize, &amp;guardPage, sizeof(guardPage));
      ASSERT(guardPage.Protect &amp; PAGE_GUARD);
  
<span class="line-new-header">--- 150,20 ---</span>
      //         | uncommittedMemory |    v
      //    Low  |-------------------|  ----- &lt;--- stackOrigin.AllocationBase
      //
      // See http://msdn.microsoft.com/en-us/library/ms686774%28VS.85%29.aspx for more information.
  
      // look for uncommited memory block.
<span class="line-modified">!     MEMORY_BASIC_INFORMATION uncommittedMemory;</span>
      LPVOID a = stackOrigin.AllocationBase;
  
      do {
          size_t ret = VirtualQuery(a, &amp;uncommittedMemory, sizeof(uncommittedMemory));
          ASSERT(ret != 0);
          a = (LPVOID)((static_cast&lt;char*&gt;(a)) + uncommittedMemory.RegionSize);
      } while (theAllocBase == uncommittedMemory.AllocationBase &amp;&amp;
          uncommittedMemory.State != MEM_RESERVE);
  
      MEMORY_BASIC_INFORMATION guardPage;
      VirtualQuery(static_cast&lt;char*&gt;(uncommittedMemory.BaseAddress) + uncommittedMemory.RegionSize, &amp;guardPage, sizeof(guardPage));
      ASSERT(guardPage.Protect &amp; PAGE_GUARD);
  
</pre>
<center><a href="SmallPtrSet.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StackBounds.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
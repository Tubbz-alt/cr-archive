<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/platform/encryptedmedia/clearkey/CDMClearKey.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../CDMInstance.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="CDMClearKey.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/encryptedmedia/clearkey/CDMClearKey.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 32,10 ***</span>
<span class="line-new-header">--- 32,11 ---</span>
  #if ENABLE(ENCRYPTED_MEDIA)
  
  #include &quot;CDMKeySystemConfiguration.h&quot;
  #include &quot;CDMRestrictions.h&quot;
  #include &quot;CDMSessionType.h&quot;
<span class="line-added">+ #include &quot;Logging.h&quot;</span>
  #include &quot;SharedBuffer.h&quot;
  #include &lt;wtf/JSONValues.h&gt;
  #include &lt;wtf/MainThread.h&gt;
  #include &lt;wtf/NeverDestroyed.h&gt;
  #include &lt;wtf/text/Base64.h&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 453,11 ***</span>
<span class="line-new-header">--- 454,45 ---</span>
      if (!ok)
          return WTF::nullopt;
      return sessionId;
  }
  
<span class="line-added">+ // This is for thread-safety during an architectural situation that is</span>
<span class="line-added">+ // less than ideal. The GStreamer decryptors currently need to iterate</span>
<span class="line-added">+ // all known session keys to find the key data for priming</span>
<span class="line-added">+ // GCrypt. Ideally, all decryption would be the responsibility of</span>
<span class="line-added">+ // ProxyCDM object like this one. What the background GStreamer</span>
<span class="line-added">+ // thread was doing was getting copies (i.e. ref()&#39;s) of SharedBuffers</span>
<span class="line-added">+ // created on the main-thread. With the new safety assertions in</span>
<span class="line-added">+ // WebKit, we can no longer do this. Instead, convert the refcounted</span>
<span class="line-added">+ // SharedBuffers into Strings which can be safely copied across</span>
<span class="line-added">+ // threads.</span>
<span class="line-added">+ static ProxyCDMClearKey::Key isolatedKey(const CDMInstanceClearKey::Key&amp; key)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return { key.status, String(key.keyIDData-&gt;data(), key.keyIDData-&gt;size()), String(key.keyValueData-&gt;data(), key.keyValueData-&gt;size()) };</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ const Vector&lt;ProxyCDMClearKey::Key&gt; ProxyCDMClearKey::isolatedKeys() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // Return the keys of all sessions, may be copied to background threads.</span>
<span class="line-added">+     Vector&lt;ProxyCDMClearKey::Key&gt; allKeys { };</span>
<span class="line-added">+     auto locker = holdLock(m_keysMutex);</span>
<span class="line-added">+     size_t initialCapacity = 0;</span>
<span class="line-added">+     for (auto&amp; keyVector : ClearKeyState::singleton().keys().values())</span>
<span class="line-added">+         initialCapacity += keyVector.size();</span>
<span class="line-added">+     allKeys.reserveInitialCapacity(initialCapacity);</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (auto&amp; keyVector : ClearKeyState::singleton().keys().values()) {</span>
<span class="line-added">+         for (auto&amp; key : keyVector)</span>
<span class="line-added">+             allKeys.uncheckedAppend(isolatedKey(key));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return allKeys;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  CDMInstanceClearKey::CDMInstanceClearKey()
<span class="line-added">+     : m_proxyCDM(adoptRef(*new ProxyCDMClearKey()))</span>
  {
  }
  
  CDMInstanceClearKey::~CDMInstanceClearKey() = default;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 501,24 ***</span>
  RefPtr&lt;CDMInstanceSession&gt; CDMInstanceClearKey::createSession()
  {
      return adoptRef(new CDMInstanceSessionClearKey());
  }
  
<span class="line-modified">! const Vector&lt;CDMInstanceClearKey::Key&gt; CDMInstanceClearKey::keys() const</span>
  {
<span class="line-modified">!     // Return the keys of all sessions.</span>
<span class="line-modified">!     Vector&lt;CDMInstanceClearKey::Key&gt; allKeys { };</span>
<span class="line-modified">!     auto locker = holdLock(m_keysMutex);</span>
<span class="line-modified">!     size_t initialCapacity = 0;</span>
<span class="line-modified">!     for (auto&amp; key : ClearKeyState::singleton().keys().values())</span>
<span class="line-modified">!         initialCapacity += key.size();</span>
<span class="line-modified">!     allKeys.reserveInitialCapacity(initialCapacity);</span>
  
<span class="line-modified">!     for (auto&amp; key : ClearKeyState::singleton().keys().values())</span>
<span class="line-modified">!         allKeys.appendVector(key);</span>
  
<span class="line-modified">!     return allKeys;</span>
  }
  
  void CDMInstanceSessionClearKey::requestLicense(LicenseType, const AtomString&amp; initDataType, Ref&lt;SharedBuffer&gt;&amp;&amp; initData, LicenseCallback&amp;&amp; callback)
  {
      static uint32_t s_sessionIdValue = 0;
<span class="line-new-header">--- 536,37 ---</span>
  RefPtr&lt;CDMInstanceSession&gt; CDMInstanceClearKey::createSession()
  {
      return adoptRef(new CDMInstanceSessionClearKey());
  }
  
<span class="line-modified">! String CDMInstanceClearKey::Key::keyIDAsString() const</span>
  {
<span class="line-modified">!     return makeString(&quot;[&quot;, keyIDData-&gt;toHexString(), &quot;]&quot;);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! String CDMInstanceClearKey::Key::keyValueAsString() const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     return makeString(&quot;[&quot;, keyValueData-&gt;toHexString(), &quot;]&quot;);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! bool operator==(const CDMInstanceClearKey::Key&amp; k1, const CDMInstanceClearKey::Key&amp; k2)</span>
<span class="line-modified">! {</span>
<span class="line-added">+     ASSERT(k1.keyIDData);</span>
<span class="line-added">+     ASSERT(k2.keyIDData);</span>
  
<span class="line-modified">!     return *k1.keyIDData == *k2.keyIDData;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool operator&lt;(const CDMInstanceClearKey::Key&amp; k1, const CDMInstanceClearKey::Key&amp; k2)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(k1.keyIDData);</span>
<span class="line-added">+     ASSERT(k2.keyIDData);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (k1.keyIDData-&gt;size() != k2.keyIDData-&gt;size())</span>
<span class="line-added">+         return k1.keyIDData-&gt;size() &lt; k2.keyIDData-&gt;size();</span>
<span class="line-added">+ </span>
<span class="line-added">+     return memcmp(k1.keyIDData-&gt;data(), k2.keyIDData-&gt;data(), k1.keyIDData-&gt;size());</span>
  }
  
  void CDMInstanceSessionClearKey::requestLicense(LicenseType, const AtomString&amp; initDataType, Ref&lt;SharedBuffer&gt;&amp;&amp; initData, LicenseCallback&amp;&amp; callback)
  {
      static uint32_t s_sessionIdValue = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 552,85 ***</span>
  
                      callback(sessionWasClosed, WTFMove(changedKeys), WTF::nullopt, WTF::nullopt, succeeded);
                  });
          };
  
<span class="line-removed">-     // Parse the response buffer as an JSON object.</span>
      RefPtr&lt;JSON::Object&gt; root = parseJSONObject(response);
      if (!root) {
          dispatchCallback(false, WTF::nullopt, SuccessValue::Failed);
          return;
      }
  
<span class="line-modified">!     // Parse the response using &#39;license&#39; formatting, if possible.</span>
      if (auto decodedKeys = parseLicenseFormat(*root)) {
          // Retrieve the target Vector of Key objects for this session.
<span class="line-modified">!         auto&amp; keyVector = ClearKeyState::singleton().keys().ensure(sessionId, [] { return Vector&lt;CDMInstanceClearKey::Key&gt; { }; }).iterator-&gt;value;</span>
  
<span class="line-removed">-         // For each decoded key, find an existing item for the decoded key&#39;s ID. If none exist,</span>
<span class="line-removed">-         // the key is decoded. Otherwise, the key is updated in case there&#39;s a mismatch between</span>
<span class="line-removed">-         // the size or data of the existing and proposed key.</span>
          bool keysChanged = false;
<span class="line-modified">!         for (auto&amp; key : *decodedKeys) {</span>
<span class="line-modified">!             auto it = std::find_if(keyVector.begin(), keyVector.end(),</span>
<span class="line-modified">!                 [&amp;key] (const CDMInstanceClearKey::Key&amp; containedKey) {</span>
<span class="line-modified">!                     return containedKey.keyIDData-&gt;size() == key.keyIDData-&gt;size()</span>
<span class="line-modified">!                         &amp;&amp; !std::memcmp(containedKey.keyIDData-&gt;data(), key.keyIDData-&gt;data(), containedKey.keyIDData-&gt;size());</span>
                  });
<span class="line-modified">!             if (it != keyVector.end()) {</span>
<span class="line-modified">!                 auto&amp; existingKey = it-&gt;keyValueData;</span>
<span class="line-removed">-                 auto&amp; proposedKey = key.keyValueData;</span>
  
<span class="line-modified">!                 // Update the existing Key if it differs from the proposed key in key value.</span>
<span class="line-modified">!                 if (existingKey-&gt;size() != proposedKey-&gt;size() || std::memcmp(existingKey-&gt;data(), proposedKey-&gt;data(), existingKey-&gt;size())) {</span>
<span class="line-modified">!                     *it = WTFMove(key);</span>
                      keysChanged = true;
                  }
              } else {
<span class="line-modified">!                 // In case a Key for this key ID doesn&#39;t exist yet, append the new one to keyVector.</span>
<span class="line-modified">!                 keyVector.append(WTFMove(key));</span>
                  keysChanged = true;
              }
          }
  
<span class="line-modified">!         // In case of changed keys, we have to provide a KeyStatusVector of all the keys for</span>
<span class="line-modified">!         // this session.</span>
          Optional&lt;KeyStatusVector&gt; changedKeys;
          if (keysChanged) {
<span class="line-modified">!             // First a helper Vector is constructed, cotaining pairs of SharedBuffer RefPtrs</span>
<span class="line-modified">!             // representint key ID data, and the corresponding key statuses.</span>
<span class="line-removed">-             // We can&#39;t use KeyStatusVector here because this Vector has to be sorted, which</span>
<span class="line-removed">-             // is not possible to do on Ref&lt;&gt; objects.</span>
<span class="line-removed">-             Vector&lt;std::pair&lt;RefPtr&lt;SharedBuffer&gt;, KeyStatus&gt;&gt; keys;</span>
<span class="line-removed">-             keys.reserveInitialCapacity(keyVector.size());</span>
<span class="line-removed">-             for (auto&amp; it : keyVector)</span>
<span class="line-removed">-                 keys.uncheckedAppend(std::pair&lt;RefPtr&lt;SharedBuffer&gt;, KeyStatus&gt; { it.keyIDData, it.status });</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // Sort first by size, second by data.</span>
<span class="line-removed">-             std::sort(keys.begin(), keys.end(),</span>
<span class="line-removed">-                 [] (const auto&amp; a, const auto&amp; b) {</span>
<span class="line-removed">-                     if (a.first-&gt;size() != b.first-&gt;size())</span>
<span class="line-removed">-                         return a.first-&gt;size() &lt; b.first-&gt;size();</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     return std::memcmp(a.first-&gt;data(), b.first-&gt;data(), a.first-&gt;size()) &lt; 0;</span>
<span class="line-removed">-                 });</span>
  
<span class="line-removed">-             // Finally construct the mirroring KeyStatusVector object and move it into the</span>
<span class="line-removed">-             // Optional&lt;&gt; object that will be passed to the callback.</span>
              KeyStatusVector keyStatusVector;
<span class="line-modified">!             keyStatusVector.reserveInitialCapacity(keys.size());</span>
<span class="line-modified">!             for (auto&amp; it : keys)</span>
<span class="line-modified">!                 keyStatusVector.uncheckedAppend(std::pair&lt;Ref&lt;SharedBuffer&gt;, KeyStatus&gt; { *it.first, it.second });</span>
  
              changedKeys = WTFMove(keyStatusVector);
          }
  
          dispatchCallback(false, WTFMove(changedKeys), SuccessValue::Succeeded);
          return;
      }
  
<span class="line-removed">-     // Parse the response using &#39;license release acknowledgement&#39; formatting, if possible.</span>
      if (parseLicenseReleaseAcknowledgementFormat(*root)) {
          // FIXME: Retrieve the key ID information and use it to validate the keys for this sessionId.
          ClearKeyState::singleton().keys().remove(sessionId);
          dispatchCallback(true, WTF::nullopt, SuccessValue::Succeeded);
          return;
<span class="line-new-header">--- 600,64 ---</span>
  
                      callback(sessionWasClosed, WTFMove(changedKeys), WTF::nullopt, WTF::nullopt, succeeded);
                  });
          };
  
      RefPtr&lt;JSON::Object&gt; root = parseJSONObject(response);
      if (!root) {
          dispatchCallback(false, WTF::nullopt, SuccessValue::Failed);
          return;
      }
  
<span class="line-modified">!     LOG(EME, &quot;EME - ClearKey - updating license for session %s&quot;, sessionId.utf8().data());</span>
<span class="line-added">+ </span>
      if (auto decodedKeys = parseLicenseFormat(*root)) {
          // Retrieve the target Vector of Key objects for this session.
<span class="line-modified">!         // FIXME: Refactor this state management code.</span>
<span class="line-added">+         Vector&lt;CDMInstanceClearKey::Key&gt;&amp; keyVector = ClearKeyState::singleton().keys().ensure(sessionId, [] { return Vector&lt;CDMInstanceClearKey::Key&gt; { }; }).iterator-&gt;value;</span>
  
          bool keysChanged = false;
<span class="line-modified">!         for (auto&amp; decodedKey : *decodedKeys) {</span>
<span class="line-modified">!             LOG(EME, &quot;EME - ClearKey - Decoded a key with ID %s and key data %s&quot;, decodedKey.keyIDAsString().utf8().data(), decodedKey.keyValueAsString().utf8().data());</span>
<span class="line-modified">!             auto keyWithMatchingKeyID = std::find_if(keyVector.begin(), keyVector.end(),</span>
<span class="line-modified">!                 [&amp;decodedKey] (const CDMInstanceClearKey::Key&amp; containedKey) {</span>
<span class="line-modified">!                     return containedKey == decodedKey;</span>
                  });
<span class="line-modified">!             if (keyWithMatchingKeyID != keyVector.end()) {</span>
<span class="line-modified">!                 LOG(EME, &quot;EME - ClearKey - Existing key found with data %s&quot;, keyWithMatchingKeyID-&gt;keyValueAsString().utf8().data());</span>
  
<span class="line-modified">!                 if (!keyWithMatchingKeyID-&gt;hasSameKeyValue(decodedKey)) {</span>
<span class="line-modified">!                     LOG(EME, &quot;EME - ClearKey - Updating key since the data are different&quot;);</span>
<span class="line-modified">!                     *keyWithMatchingKeyID = WTFMove(decodedKey);</span>
                      keysChanged = true;
                  }
              } else {
<span class="line-modified">!                 LOG(EME, &quot;EME - ClearKey - This is a new key&quot;);</span>
<span class="line-modified">!                 keyVector.append(WTFMove(decodedKey));</span>
                  keysChanged = true;
              }
          }
  
<span class="line-modified">!         LOG(EME, &quot;EME - ClearKey - Update has provided %zu keys&quot;, keyVector.size());</span>
<span class="line-modified">! </span>
          Optional&lt;KeyStatusVector&gt; changedKeys;
          if (keysChanged) {
<span class="line-modified">!             // Sort by key IDs.</span>
<span class="line-modified">!             std::sort(keyVector.begin(), keyVector.end());</span>
  
              KeyStatusVector keyStatusVector;
<span class="line-modified">!             keyStatusVector.reserveInitialCapacity(keyVector.size());</span>
<span class="line-modified">!             for (auto&amp; key : keyVector)</span>
<span class="line-modified">!                 keyStatusVector.uncheckedAppend(std::pair&lt;Ref&lt;SharedBuffer&gt;, KeyStatus&gt; { *key.keyIDData, key.status });</span>
  
              changedKeys = WTFMove(keyStatusVector);
          }
  
          dispatchCallback(false, WTFMove(changedKeys), SuccessValue::Succeeded);
          return;
      }
  
      if (parseLicenseReleaseAcknowledgementFormat(*root)) {
          // FIXME: Retrieve the key ID information and use it to validate the keys for this sessionId.
          ClearKeyState::singleton().keys().remove(sessionId);
          dispatchCallback(true, WTF::nullopt, SuccessValue::Succeeded);
          return;
</pre>
<center><a href="../CDMInstance.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="CDMClearKey.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
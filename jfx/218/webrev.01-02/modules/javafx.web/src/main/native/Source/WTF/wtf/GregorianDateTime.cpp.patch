diff a/modules/javafx.web/src/main/native/Source/WTF/wtf/GregorianDateTime.cpp b/modules/javafx.web/src/main/native/Source/WTF/wtf/GregorianDateTime.cpp
--- a/modules/javafx.web/src/main/native/Source/WTF/wtf/GregorianDateTime.cpp
+++ b/modules/javafx.web/src/main/native/Source/WTF/wtf/GregorianDateTime.cpp
@@ -33,10 +33,57 @@
 #include <time.h>
 #endif
 
 namespace WTF {
 
+GregorianDateTime::GregorianDateTime(double ms, LocalTimeOffset localTime)
+{
+    if (ms >= 0
+#if OS(WINDOWS) && CPU(X86)
+            // The VS Compiler for 32-bit builds generates a floating point error when attempting to cast
+            // from an infinity to a 64-bit integer. We leave this routine with the floating point error
+            // left in a register, causing undefined behavior in later floating point operations.
+            //
+            // To avoid this issue, we check for infinity here, and return false in that case.
+            && !std::isinf(ms)
+#endif
+        ) {
+        int64_t integer = static_cast<int64_t>(ms);
+        if (static_cast<double>(integer) == ms && integer <= maxECMAScriptTime) {
+            // Positive integer fast path.
+            WTF::TimeClippedPositiveMilliseconds timeClipped(integer);
+            const int year = msToYear(ms);
+            setSecond(msToSeconds(timeClipped));
+            setMinute(msToMinutes(timeClipped));
+            setHour(msToHours(timeClipped));
+            setWeekDay(msToWeekDay(timeClipped));
+            int yearDay = dayInYear(timeClipped, year);
+            bool leapYear = isLeapYear(year);
+            setYearDay(yearDay);
+            setMonthDay(dayInMonthFromDayInYear(yearDay, leapYear));
+            setMonth(monthFromDayInYear(yearDay, leapYear));
+            setYear(year);
+            setIsDST(localTime.isDST);
+            setUTCOffsetInMinute(localTime.offset / WTF::msPerMinute);
+            return;
+        }
+    }
+    const int year = msToYear(ms);
+    setSecond(msToSeconds(ms));
+    setMinute(msToMinutes(ms));
+    setHour(msToHours(ms));
+    setWeekDay(msToWeekDay(ms));
+    int yearDay = dayInYear(ms, year);
+    bool leapYear = isLeapYear(year);
+    setYearDay(yearDay);
+    setMonthDay(dayInMonthFromDayInYear(yearDay, leapYear));
+    setMonth(monthFromDayInYear(yearDay, leapYear));
+    setYear(year);
+    setIsDST(localTime.isDST);
+    setUTCOffsetInMinute(localTime.offset / WTF::msPerMinute);
+}
+
 void GregorianDateTime::setToCurrentLocalTime()
 {
 #if OS(WINDOWS)
     SYSTEMTIME systemTime;
     GetLocalTime(&systemTime);
@@ -60,11 +107,11 @@
     m_yearDay = dayInYear(m_year, m_month, m_monthDay);
     m_weekDay = systemTime.wDayOfWeek;
     m_hour = systemTime.wHour;
     m_minute = systemTime.wMinute;
     m_second = systemTime.wSecond;
-    m_utcOffset = -bias * secondsPerMinute;
+    m_utcOffsetInMinute = -bias;
     m_isDST = timeZoneId == TIME_ZONE_ID_DAYLIGHT ? 1 : 0;
 #else
     tm localTM;
     time_t localTime = time(0);
 #if HAVE(LOCALTIME_R)
@@ -81,13 +128,13 @@
     m_hour = localTM.tm_hour;
     m_minute = localTM.tm_min;
     m_second = localTM.tm_sec;
     m_isDST = localTM.tm_isdst;
 #if HAVE(TM_GMTOFF)
-    m_utcOffset = localTM.tm_gmtoff;
+    m_utcOffsetInMinute = localTM.tm_gmtoff / secondsPerMinute;
 #else
-    m_utcOffset = calculateLocalTimeOffset(localTime * msPerSecond).offset / msPerSecond;
+    m_utcOffsetInMinute = calculateLocalTimeOffset(localTime * msPerSecond).offset / msPerMinute;
 #endif
 #endif
 }
 
 } // namespace WTF

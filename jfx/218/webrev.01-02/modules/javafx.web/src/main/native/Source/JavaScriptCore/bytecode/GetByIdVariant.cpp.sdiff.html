<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/GetByIdVariant.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FullBytecodeLiveness.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="GetByIdVariant.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/GetByIdVariant.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2014-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;GetByIdVariant.h&quot;
 28 

 29 #include &quot;CallLinkStatus.h&quot;
 30 #include &quot;JSCInlines.h&quot;
 31 #include &lt;wtf/ListDump.h&gt;
 32 
 33 namespace JSC {
 34 
 35 GetByIdVariant::GetByIdVariant(

 36     const StructureSet&amp; structureSet, PropertyOffset offset,
 37     const ObjectPropertyConditionSet&amp; conditionSet,
 38     std::unique_ptr&lt;CallLinkStatus&gt; callLinkStatus,
 39     JSFunction* intrinsicFunction,
 40     FunctionPtr&lt;OperationPtrTag&gt; customAccessorGetter,
<span class="line-modified"> 41     Optional&lt;DOMAttributeAnnotation&gt; domAttribute)</span>
 42     : m_structureSet(structureSet)
 43     , m_conditionSet(conditionSet)
 44     , m_offset(offset)
 45     , m_callLinkStatus(WTFMove(callLinkStatus))
 46     , m_intrinsicFunction(intrinsicFunction)
 47     , m_customAccessorGetter(customAccessorGetter)
<span class="line-modified"> 48     , m_domAttribute(domAttribute)</span>

 49 {
 50     if (!structureSet.size()) {
 51         ASSERT(offset == invalidOffset);
 52         ASSERT(conditionSet.isEmpty());
 53     }
 54     if (intrinsicFunction)
 55         ASSERT(intrinsic() != NoIntrinsic);
 56 }
 57 
 58 GetByIdVariant::~GetByIdVariant() { }
 59 
 60 GetByIdVariant::GetByIdVariant(const GetByIdVariant&amp; other)
<span class="line-modified"> 61     : GetByIdVariant()</span>
 62 {
 63     *this = other;
 64 }
 65 
 66 GetByIdVariant&amp; GetByIdVariant::operator=(const GetByIdVariant&amp; other)
 67 {

 68     m_structureSet = other.m_structureSet;
 69     m_conditionSet = other.m_conditionSet;
 70     m_offset = other.m_offset;
 71     m_intrinsicFunction = other.m_intrinsicFunction;
 72     m_customAccessorGetter = other.m_customAccessorGetter;
<span class="line-modified"> 73     m_domAttribute = other.m_domAttribute;</span>



 74     if (other.m_callLinkStatus)
 75         m_callLinkStatus = makeUnique&lt;CallLinkStatus&gt;(*other.m_callLinkStatus);
 76     else
 77         m_callLinkStatus = nullptr;
 78     return *this;
 79 }
 80 
 81 inline bool GetByIdVariant::canMergeIntrinsicStructures(const GetByIdVariant&amp; other) const
 82 {
 83     if (m_intrinsicFunction != other.m_intrinsicFunction)
 84         return false;
 85     switch (intrinsic()) {
 86     case TypedArrayByteLengthIntrinsic: {
 87         // We can merge these sets as long as the element size of the two sets is the same.
 88         TypedArrayType thisType = (*m_structureSet.begin())-&gt;classInfo()-&gt;typedArrayStorageType;
 89         TypedArrayType otherType = (*other.m_structureSet.begin())-&gt;classInfo()-&gt;typedArrayStorageType;
 90 
 91         ASSERT(isTypedView(thisType) &amp;&amp; isTypedView(otherType));
 92 
 93         return logElementSize(thisType) == logElementSize(otherType);
 94     }
 95 
 96     default:
 97         return true;
 98     }
 99     RELEASE_ASSERT_NOT_REACHED();
100 }
101 
102 bool GetByIdVariant::attemptToMerge(const GetByIdVariant&amp; other)
103 {






104     if (m_offset != other.m_offset)
105         return false;
106 
107     if (m_callLinkStatus || other.m_callLinkStatus) {
108         if (!(m_callLinkStatus &amp;&amp; other.m_callLinkStatus))
109             return false;
110     }
111 
112     if (!canMergeIntrinsicStructures(other))
113         return false;
114 
115     if (m_customAccessorGetter != other.m_customAccessorGetter)
116         return false;
117 
118     if (m_domAttribute || other.m_domAttribute) {
119         if (!(m_domAttribute &amp;&amp; other.m_domAttribute))
120             return false;
121         if (*m_domAttribute != *other.m_domAttribute)
122             return false;
123     }
</pre>
<hr />
<pre>
127 
128     ObjectPropertyConditionSet mergedConditionSet;
129     if (!m_conditionSet.isEmpty()) {
130         mergedConditionSet = m_conditionSet.mergedWith(other.m_conditionSet);
131         if (!mergedConditionSet.isValid())
132             return false;
133         // If this is a hit variant, one slot base should exist. If this is not a hit variant, the slot base is not necessary.
134         if (!isPropertyUnset() &amp;&amp; !mergedConditionSet.hasOneSlotBaseCondition())
135             return false;
136     }
137     m_conditionSet = mergedConditionSet;
138 
139     m_structureSet.merge(other.m_structureSet);
140 
141     if (m_callLinkStatus)
142         m_callLinkStatus-&gt;merge(*other.m_callLinkStatus);
143 
144     return true;
145 }
146 





147 void GetByIdVariant::markIfCheap(SlotVisitor&amp; visitor)
148 {
149     m_structureSet.markIfCheap(visitor);
150 }
151 
152 bool GetByIdVariant::finalize(VM&amp; vm)
153 {
154     if (!m_structureSet.isStillAlive(vm))
155         return false;
156     if (!m_conditionSet.areStillLive(vm))
157         return false;
158     if (m_callLinkStatus &amp;&amp; !m_callLinkStatus-&gt;finalize(vm))
159         return false;
160     if (m_intrinsicFunction &amp;&amp; !vm.heap.isMarked(m_intrinsicFunction))
161         return false;
162     return true;
163 }
164 
165 void GetByIdVariant::dump(PrintStream&amp; out) const
166 {
167     dumpInContext(out, 0);
168 }
169 
170 void GetByIdVariant::dumpInContext(PrintStream&amp; out, DumpContext* context) const
171 {


172     if (!isSet()) {
<span class="line-modified">173         out.print(&quot;&lt;empty&gt;&quot;);</span>
174         return;
175     }
<span class="line-modified">176 </span>
<span class="line-removed">177     out.print(</span>
<span class="line-removed">178         &quot;&lt;&quot;, inContext(structureSet(), context), &quot;, &quot;, inContext(m_conditionSet, context));</span>
179     out.print(&quot;, offset = &quot;, offset());
180     if (m_callLinkStatus)
181         out.print(&quot;, call = &quot;, *m_callLinkStatus);
182     if (m_intrinsicFunction)
183         out.print(&quot;, intrinsic = &quot;, *m_intrinsicFunction);
184     if (m_customAccessorGetter)
185         out.print(&quot;, customaccessorgetter = &quot;, RawPointer(m_customAccessorGetter.executableAddress()));
186     if (m_domAttribute) {
187         out.print(&quot;, domclass = &quot;, RawPointer(m_domAttribute-&gt;classInfo));
188         if (m_domAttribute-&gt;domJIT)
189             out.print(&quot;, domjit = &quot;, RawPointer(m_domAttribute-&gt;domJIT));
190     }
191     out.print(&quot;&gt;&quot;);
192 }
193 
194 } // namespace JSC
195 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2014-2020 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;GetByIdVariant.h&quot;
 28 
<span class="line-added"> 29 #include &quot;CacheableIdentifierInlines.h&quot;</span>
 30 #include &quot;CallLinkStatus.h&quot;
 31 #include &quot;JSCInlines.h&quot;
 32 #include &lt;wtf/ListDump.h&gt;
 33 
 34 namespace JSC {
 35 
 36 GetByIdVariant::GetByIdVariant(
<span class="line-added"> 37     CacheableIdentifier identifier,</span>
 38     const StructureSet&amp; structureSet, PropertyOffset offset,
 39     const ObjectPropertyConditionSet&amp; conditionSet,
 40     std::unique_ptr&lt;CallLinkStatus&gt; callLinkStatus,
 41     JSFunction* intrinsicFunction,
 42     FunctionPtr&lt;OperationPtrTag&gt; customAccessorGetter,
<span class="line-modified"> 43     std::unique_ptr&lt;DOMAttributeAnnotation&gt; domAttribute)</span>
 44     : m_structureSet(structureSet)
 45     , m_conditionSet(conditionSet)
 46     , m_offset(offset)
 47     , m_callLinkStatus(WTFMove(callLinkStatus))
 48     , m_intrinsicFunction(intrinsicFunction)
 49     , m_customAccessorGetter(customAccessorGetter)
<span class="line-modified"> 50     , m_domAttribute(WTFMove(domAttribute))</span>
<span class="line-added"> 51     , m_identifier(WTFMove(identifier))</span>
 52 {
 53     if (!structureSet.size()) {
 54         ASSERT(offset == invalidOffset);
 55         ASSERT(conditionSet.isEmpty());
 56     }
 57     if (intrinsicFunction)
 58         ASSERT(intrinsic() != NoIntrinsic);
 59 }
 60 
 61 GetByIdVariant::~GetByIdVariant() { }
 62 
 63 GetByIdVariant::GetByIdVariant(const GetByIdVariant&amp; other)
<span class="line-modified"> 64     : GetByIdVariant(other.m_identifier)</span>
 65 {
 66     *this = other;
 67 }
 68 
 69 GetByIdVariant&amp; GetByIdVariant::operator=(const GetByIdVariant&amp; other)
 70 {
<span class="line-added"> 71     m_identifier = other.m_identifier;</span>
 72     m_structureSet = other.m_structureSet;
 73     m_conditionSet = other.m_conditionSet;
 74     m_offset = other.m_offset;
 75     m_intrinsicFunction = other.m_intrinsicFunction;
 76     m_customAccessorGetter = other.m_customAccessorGetter;
<span class="line-modified"> 77     if (other.m_domAttribute)</span>
<span class="line-added"> 78         m_domAttribute = WTF::makeUnique&lt;DOMAttributeAnnotation&gt;(*other.m_domAttribute);</span>
<span class="line-added"> 79     else</span>
<span class="line-added"> 80         m_domAttribute = nullptr;</span>
 81     if (other.m_callLinkStatus)
 82         m_callLinkStatus = makeUnique&lt;CallLinkStatus&gt;(*other.m_callLinkStatus);
 83     else
 84         m_callLinkStatus = nullptr;
 85     return *this;
 86 }
 87 
 88 inline bool GetByIdVariant::canMergeIntrinsicStructures(const GetByIdVariant&amp; other) const
 89 {
 90     if (m_intrinsicFunction != other.m_intrinsicFunction)
 91         return false;
 92     switch (intrinsic()) {
 93     case TypedArrayByteLengthIntrinsic: {
 94         // We can merge these sets as long as the element size of the two sets is the same.
 95         TypedArrayType thisType = (*m_structureSet.begin())-&gt;classInfo()-&gt;typedArrayStorageType;
 96         TypedArrayType otherType = (*other.m_structureSet.begin())-&gt;classInfo()-&gt;typedArrayStorageType;
 97 
 98         ASSERT(isTypedView(thisType) &amp;&amp; isTypedView(otherType));
 99 
100         return logElementSize(thisType) == logElementSize(otherType);
101     }
102 
103     default:
104         return true;
105     }
106     RELEASE_ASSERT_NOT_REACHED();
107 }
108 
109 bool GetByIdVariant::attemptToMerge(const GetByIdVariant&amp; other)
110 {
<span class="line-added">111     if (!!m_identifier != !!other.m_identifier)</span>
<span class="line-added">112         return false;</span>
<span class="line-added">113 </span>
<span class="line-added">114     if (m_identifier &amp;&amp; (m_identifier != other.m_identifier))</span>
<span class="line-added">115         return false;</span>
<span class="line-added">116 </span>
117     if (m_offset != other.m_offset)
118         return false;
119 
120     if (m_callLinkStatus || other.m_callLinkStatus) {
121         if (!(m_callLinkStatus &amp;&amp; other.m_callLinkStatus))
122             return false;
123     }
124 
125     if (!canMergeIntrinsicStructures(other))
126         return false;
127 
128     if (m_customAccessorGetter != other.m_customAccessorGetter)
129         return false;
130 
131     if (m_domAttribute || other.m_domAttribute) {
132         if (!(m_domAttribute &amp;&amp; other.m_domAttribute))
133             return false;
134         if (*m_domAttribute != *other.m_domAttribute)
135             return false;
136     }
</pre>
<hr />
<pre>
140 
141     ObjectPropertyConditionSet mergedConditionSet;
142     if (!m_conditionSet.isEmpty()) {
143         mergedConditionSet = m_conditionSet.mergedWith(other.m_conditionSet);
144         if (!mergedConditionSet.isValid())
145             return false;
146         // If this is a hit variant, one slot base should exist. If this is not a hit variant, the slot base is not necessary.
147         if (!isPropertyUnset() &amp;&amp; !mergedConditionSet.hasOneSlotBaseCondition())
148             return false;
149     }
150     m_conditionSet = mergedConditionSet;
151 
152     m_structureSet.merge(other.m_structureSet);
153 
154     if (m_callLinkStatus)
155         m_callLinkStatus-&gt;merge(*other.m_callLinkStatus);
156 
157     return true;
158 }
159 
<span class="line-added">160 void GetByIdVariant::visitAggregate(SlotVisitor&amp; visitor)</span>
<span class="line-added">161 {</span>
<span class="line-added">162     m_identifier.visitAggregate(visitor);</span>
<span class="line-added">163 }</span>
<span class="line-added">164 </span>
165 void GetByIdVariant::markIfCheap(SlotVisitor&amp; visitor)
166 {
167     m_structureSet.markIfCheap(visitor);
168 }
169 
170 bool GetByIdVariant::finalize(VM&amp; vm)
171 {
172     if (!m_structureSet.isStillAlive(vm))
173         return false;
174     if (!m_conditionSet.areStillLive(vm))
175         return false;
176     if (m_callLinkStatus &amp;&amp; !m_callLinkStatus-&gt;finalize(vm))
177         return false;
178     if (m_intrinsicFunction &amp;&amp; !vm.heap.isMarked(m_intrinsicFunction))
179         return false;
180     return true;
181 }
182 
183 void GetByIdVariant::dump(PrintStream&amp; out) const
184 {
185     dumpInContext(out, 0);
186 }
187 
188 void GetByIdVariant::dumpInContext(PrintStream&amp; out, DumpContext* context) const
189 {
<span class="line-added">190     out.print(&quot;&lt;&quot;);</span>
<span class="line-added">191     out.print(&quot;id=&#39;&quot;, m_identifier, &quot;&#39;, &quot;);</span>
192     if (!isSet()) {
<span class="line-modified">193         out.print(&quot;empty&gt;&quot;);</span>
194         return;
195     }
<span class="line-modified">196     out.print(inContext(structureSet(), context), &quot;, &quot;, inContext(m_conditionSet, context));</span>


197     out.print(&quot;, offset = &quot;, offset());
198     if (m_callLinkStatus)
199         out.print(&quot;, call = &quot;, *m_callLinkStatus);
200     if (m_intrinsicFunction)
201         out.print(&quot;, intrinsic = &quot;, *m_intrinsicFunction);
202     if (m_customAccessorGetter)
203         out.print(&quot;, customaccessorgetter = &quot;, RawPointer(m_customAccessorGetter.executableAddress()));
204     if (m_domAttribute) {
205         out.print(&quot;, domclass = &quot;, RawPointer(m_domAttribute-&gt;classInfo));
206         if (m_domAttribute-&gt;domJIT)
207             out.print(&quot;, domjit = &quot;, RawPointer(m_domAttribute-&gt;domJIT));
208     }
209     out.print(&quot;&gt;&quot;);
210 }
211 
212 } // namespace JSC
213 
</pre>
</td>
</tr>
</table>
<center><a href="FullBytecodeLiveness.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="GetByIdVariant.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/encryptedmedia/MediaKeySession.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016 Metrological Group B.V.
  3  * Copyright (C) 2016 Igalia S.L.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above
 12  *    copyright notice, this list of conditions and the following
 13  *    disclaimer in the documentation and/or other materials provided
 14  *    with the distribution.
 15  *
 16  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 17  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 18  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 19  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 20  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 21  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 22  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 23  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;MediaKeySession.h&quot;
 31 
 32 #if ENABLE(ENCRYPTED_MEDIA)
 33 
 34 #include &quot;CDM.h&quot;
 35 #include &quot;CDMInstance.h&quot;
 36 #include &quot;DOMPromiseProxy.h&quot;
 37 #include &quot;Document.h&quot;
 38 #include &quot;EventLoop.h&quot;
 39 #include &quot;EventNames.h&quot;
 40 #include &quot;Logging.h&quot;
 41 #include &quot;MediaKeyMessageEvent.h&quot;
 42 #include &quot;MediaKeyMessageType.h&quot;
 43 #include &quot;MediaKeyStatusMap.h&quot;
 44 #include &quot;MediaKeys.h&quot;
 45 #include &quot;NotImplemented.h&quot;
 46 #include &quot;Page.h&quot;
 47 #include &quot;SecurityOrigin.h&quot;
 48 #include &quot;SecurityOriginData.h&quot;
 49 #include &quot;Settings.h&quot;
 50 #include &quot;SharedBuffer.h&quot;
 51 #include &lt;wtf/IsoMallocInlines.h&gt;
 52 
 53 namespace WebCore {
 54 
 55 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaKeySession);
 56 
 57 Ref&lt;MediaKeySession&gt; MediaKeySession::create(ScriptExecutionContext&amp; context, WeakPtr&lt;MediaKeys&gt;&amp;&amp; keys, MediaKeySessionType sessionType, bool useDistinctiveIdentifier, Ref&lt;CDM&gt;&amp;&amp; implementation, Ref&lt;CDMInstanceSession&gt;&amp;&amp; instanceSession)
 58 {
 59     auto session = adoptRef(*new MediaKeySession(context, WTFMove(keys), sessionType, useDistinctiveIdentifier, WTFMove(implementation), WTFMove(instanceSession)));
 60     session-&gt;suspendIfNeeded();
 61     return session;
 62 }
 63 
 64 MediaKeySession::MediaKeySession(ScriptExecutionContext&amp; context, WeakPtr&lt;MediaKeys&gt;&amp;&amp; keys, MediaKeySessionType sessionType, bool useDistinctiveIdentifier, Ref&lt;CDM&gt;&amp;&amp; implementation, Ref&lt;CDMInstanceSession&gt;&amp;&amp; instanceSession)
 65     : ActiveDOMObject(&amp;context)
 66     , m_keys(WTFMove(keys))
 67     , m_expiration(std::numeric_limits&lt;double&gt;::quiet_NaN())
 68     , m_closedPromise(makeUniqueRef&lt;ClosedPromise&gt;())
 69     , m_keyStatuses(MediaKeyStatusMap::create(*this))
 70     , m_useDistinctiveIdentifier(useDistinctiveIdentifier)
 71     , m_sessionType(sessionType)
 72     , m_implementation(WTFMove(implementation))
 73     , m_instanceSession(WTFMove(instanceSession))
 74 {
 75     // https://w3c.github.io/encrypted-media/#dom-mediakeys-createsession
 76     // W3C Editor&#39;s Draft 09 November 2016
 77     // createSession(), ctd.
 78 
 79     LOG(EME, &quot;EME - new session created&quot;);
 80 
 81     // 3.1. Let the sessionId attribute be the empty string.
 82     // 3.2. Let the expiration attribute be NaN.
 83     // 3.3. Let the closed attribute be a new promise.
 84     // 3.4. Let key status be a new empty MediaKeyStatusMap object, and initialize it as follows:
 85     // 3.4.1. Let the size attribute be 0.
 86     // 3.5. Let the session type value be sessionType.
 87     // 3.6. Let the uninitialized value be true.
 88     // 3.7. Let the callable value be false.
 89     // 3.8. Let the use distinctive identifier value be this object&#39;s use distinctive identifier value.
 90     // 3.9. Let the cdm implementation value be this object&#39;s cdm implementation.
 91     // 3.10. Let the cdm instance value be this object&#39;s cdm instance.
 92 
 93     UNUSED_PARAM(m_callable);
 94     UNUSED_PARAM(m_sessionType);
 95     UNUSED_PARAM(m_useDistinctiveIdentifier);
 96     UNUSED_PARAM(m_closed);
 97     UNUSED_PARAM(m_uninitialized);
 98 
 99     m_instanceSession-&gt;setClient(makeWeakPtr(*this));
100 }
101 
102 MediaKeySession::~MediaKeySession()
103 {
104     m_keyStatuses-&gt;detachSession();
105     m_instanceSession-&gt;clearClient();
106 }
107 
108 const String&amp; MediaKeySession::sessionId() const
109 {
110     return m_sessionId;
111 }
112 
113 double MediaKeySession::expiration() const
114 {
115     return m_expiration;
116 }
117 
118 Ref&lt;MediaKeyStatusMap&gt; MediaKeySession::keyStatuses() const
119 {
120     return m_keyStatuses.copyRef();
121 }
122 
123 void MediaKeySession::generateRequest(const AtomString&amp; initDataType, const BufferSource&amp; initData, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
124 {
125     // https://w3c.github.io/encrypted-media/#dom-mediakeysession-generaterequest
126     // W3C Editor&#39;s Draft 09 November 2016
127 
128     // When this method is invoked, the user agent must run the following steps:
129     // 1. If this object is closed, return a promise rejected with an InvalidStateError.
130     // 2. If this object&#39;s uninitialized value is false, return a promise rejected with an InvalidStateError.
131     LOG(EME, &quot;EME - generate request&quot;);
132 
133     if (m_closed || !m_uninitialized) {
134         promise-&gt;reject(InvalidStateError);
135         return;
136     }
137 
138     // 3. Let this object&#39;s uninitialized value be false.
139     m_uninitialized = false;
140 
141     // 4. If initDataType is the empty string, return a promise rejected with a newly created TypeError.
142     // 5. If initData is an empty array, return a promise rejected with a newly created TypeError.
143     if (initDataType.isEmpty() || !initData.length()) {
144         promise-&gt;reject(TypeError);
145         return;
146     }
147 
148     // 6. If the Key System implementation represented by this object&#39;s cdm implementation value does not support
149     //    initDataType as an Initialization Data Type, return a promise rejected with a NotSupportedError. String
150     //    comparison is case-sensitive.
151     if (!m_implementation-&gt;supportsInitDataType(initDataType)) {
152         promise-&gt;reject(NotSupportedError);
153         return;
154     }
155 
156     // 7. Let init data be a copy of the contents of the initData parameter.
157     // 8. Let session type be this object&#39;s session type.
158     // 9. Let promise be a new promise.
159     // 10. Run the following steps in parallel:
160     queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, initData = SharedBuffer::create(initData.data(), initData.length()), initDataType, promise = WTFMove(promise)] () mutable {
161         // 10.1. If the init data is not valid for initDataType, reject promise with a newly created TypeError.
162         // 10.2. Let sanitized init data be a validated and sanitized version of init data.
163         RefPtr&lt;SharedBuffer&gt; sanitizedInitData = m_implementation-&gt;sanitizeInitData(initDataType, initData);
164 
165         // 10.3. If the preceding step failed, reject promise with a newly created TypeError.
166         if (!sanitizedInitData) {
167             promise-&gt;reject(TypeError);
168             return;
169         }
170 
171         // 10.4. If sanitized init data is empty, reject promise with a NotSupportedError.
172         if (sanitizedInitData-&gt;isEmpty()) {
173             promise-&gt;reject(NotSupportedError);
174             return;
175         }
176 
177         // 10.5. Let session id be the empty string.
178         // 10.6. Let message be null.
179         // 10.7. Let message type be null.
180         // 10.8. Let cdm be the CDM instance represented by this object&#39;s cdm instance value.
181         // 10.9. Use the cdm to execute the following steps:
182         // 10.9.1. If the sanitized init data is not supported by the cdm, reject promise with a NotSupportedError.
183         if (!m_implementation-&gt;supportsInitData(initDataType, *sanitizedInitData)) {
184             promise-&gt;reject(NotSupportedError);
185             return;
186         }
187 
188         // 10.9.2 Follow the steps for the value of session type from the following list:
189         //   ↳ &quot;temporary&quot;
190         //     Let requested license type be a temporary non-persistable license.
191         //   ↳ &quot;persistent-license&quot;
192         //     Let requested license type be a persistable license.
193         //   ↳ &quot;persistent-usage-record&quot;
194         //     1. Initialize this object&#39;s record of key usage as follows.
195         //        Set the list of key IDs known to the session to an empty list.
196         //        Set the first decrypt time to null.
197         //        Set the latest decrypt time to null.
198         //     2. Let requested license type be a non-persistable license that will
199         //        persist a record of key usage.
200 
201         if (m_sessionType == MediaKeySessionType::PersistentUsageRecord) {
202             m_recordOfKeyUsage.clear();
203             m_firstDecryptTime = 0;
204             m_latestDecryptTime = 0;
205         }
206 
207         LOG(EME, &quot;EME - request license from CDM implementation&quot;);
208         m_instanceSession-&gt;requestLicense(m_sessionType, initDataType, sanitizedInitData.releaseNonNull(), [this, weakThis = makeWeakPtr(*this), promise = WTFMove(promise)] (Ref&lt;SharedBuffer&gt;&amp;&amp; message, const String&amp; sessionId, bool needsIndividualization, CDMInstanceSession::SuccessValue succeeded) mutable {
209             if (!weakThis)
210                 return;
211 
212             // 10.9.3. Let session id be a unique Session ID string.
213 
214             MediaKeyMessageType messageType;
215             if (!needsIndividualization) {
216                 // 10.9.4. If a license request for the requested license type can be generated based on the sanitized init data:
217                 // 10.9.4.1. Let message be a license request for the requested license type generated based on the sanitized init data interpreted per initDataType.
218                 // 10.9.4.2. Let message type be &quot;license-request&quot;.
219                 messageType = MediaKeyMessageType::LicenseRequest;
220             } else {
221                 // 10.9.5. Otherwise:
222                 // 10.9.5.1. Let message be the request that needs to be processed before a license request request for the requested license
223                 //           type can be generated based on the sanitized init data.
224                 // 10.9.5.2. Let message type reflect the type of message, either &quot;license-request&quot; or &quot;individualization-request&quot;.
225                 messageType = MediaKeyMessageType::IndividualizationRequest;
226             }
227 
228             // 10.10. Queue a task to run the following steps:
229             queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, promise = WTFMove(promise), message = WTFMove(message), messageType, sessionId, succeeded] () mutable {
230                 // 10.10.1. If any of the preceding steps failed, reject promise with a new DOMException whose name is the appropriate error name.
231                 if (succeeded == CDMInstanceSession::SuccessValue::Failed) {
232                     promise-&gt;reject(NotSupportedError);
233                     return;
234                 }
235                 // 10.10.2. Set the sessionId attribute to session id.
236                 m_sessionId = sessionId;
237 
238                 // 10.9.3. Let this object&#39;s callable value be true.
239                 m_callable = true;
240 
241                 // 10.9.3. Run the Queue a &quot;message&quot; Event algorithm on the session, providing message type and message.
242                 enqueueMessage(messageType, message);
243 
244                 // 10.9.3. Resolve promise.
245                 promise-&gt;resolve();
246             });
247         });
248     });
249 
250     // 11. Return promise.
251 }
252 
253 void MediaKeySession::load(const String&amp; sessionId, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
254 {
255     // https://w3c.github.io/encrypted-media/#dom-mediakeysession-load
256     // W3C Editor&#39;s Draft 09 November 2016
257 
258     // 1. If this object is closed, return a promise rejected with an InvalidStateError.
259     // 2. If this object&#39;s uninitialized value is false, return a promise rejected with an InvalidStateError.
260     if (m_closed || !m_uninitialized) {
261         promise-&gt;reject(InvalidStateError);
262         return;
263     }
264 
265     // 3. Let this object&#39;s uninitialized value be false.
266     m_uninitialized = false;
267 
268     // 4. If sessionId is the empty string, return a promise rejected with a newly created TypeError.
269     // 5. If the result of running the Is persistent session type? algorithm on this object&#39;s session type is false, return a promise rejected with a newly created TypeError.
270     if (sessionId.isEmpty() || m_sessionType == MediaKeySessionType::Temporary) {
271         promise-&gt;reject(TypeError);
272         return;
273     }
274 
275     // 6. Let origin be the origin of this object&#39;s Document.
276     // This is retrieved in the following task.
277 
278     // 7. Let promise be a new promise.
279     // 8. Run the following steps in parallel:
280     queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, sessionId, promise = WTFMove(promise)] () mutable {
281         // 8.1. Let sanitized session ID be a validated and/or sanitized version of sessionId.
282         // 8.2. If the preceding step failed, or if sanitized session ID is empty, reject promise with a newly created TypeError.
283         Optional&lt;String&gt; sanitizedSessionId = m_implementation-&gt;sanitizeSessionId(sessionId);
284         if (!sanitizedSessionId || sanitizedSessionId-&gt;isEmpty()) {
285             promise-&gt;reject(TypeError);
286             return;
287         }
288 
289         // 8.3. If there is a MediaKeySession object that is not closed in this object&#39;s Document whose sessionId attribute is sanitized session ID, reject promise with a QuotaExceededError.
290         // FIXME: This needs a global MediaKeySession tracker.
291 
292         String origin;
293         if (auto* document = downcast&lt;Document&gt;(scriptExecutionContext()))
294             origin = document-&gt;securityOrigin().toString();
295 
296         // 8.4. Let expiration time be NaN.
297         // 8.5. Let message be null.
298         // 8.6. Let message type be null.
299         // 8.7. Let cdm be the CDM instance represented by this object&#39;s cdm instance value.
300         // 8.8. Use the cdm to execute the following steps:
301         m_instanceSession-&gt;loadSession(m_sessionType, *sanitizedSessionId, origin, [this, weakThis = makeWeakPtr(*this), promise = WTFMove(promise), sanitizedSessionId = *sanitizedSessionId] (Optional&lt;CDMInstanceSession::KeyStatusVector&gt;&amp;&amp; knownKeys, Optional&lt;double&gt;&amp;&amp; expiration, Optional&lt;CDMInstanceSession::Message&gt;&amp;&amp; message, CDMInstanceSession::SuccessValue succeeded, CDMInstanceSession::SessionLoadFailure failure) mutable {
302             // 8.8.1. If there is no data stored for the sanitized session ID in the origin, resolve promise with false and abort these steps.
303             // 8.8.2. If the stored session&#39;s session type is not the same as the current MediaKeySession session type, reject promise with a newly created TypeError.
304             // 8.8.3. Let session data be the data stored for the sanitized session ID in the origin. This must not include data from other origin(s) or that is not associated with an origin.
305             // 8.8.4. If there is a MediaKeySession object that is not closed in any Document and that represents the session data, reject promise with a QuotaExceededError.
306             // 8.8.5. Load the session data.
307             // 8.8.6. If the session data indicates an expiration time for the session, let expiration time be the expiration time in milliseconds since 01 January 1970 UTC.
308             // 8.8.7. If the CDM needs to send a message:
309             //   8.8.7.1. Let message be a message generated by the CDM based on the session data.
310             //   8.8.7.2. Let message type be the appropriate MediaKeyMessageType for the message.
311             // NOTE: Steps 8.8.1. through 8.8.7. should be implemented in CDMInstance.
312 
313             if (succeeded == CDMInstanceSession::SuccessValue::Failed) {
314                 switch (failure) {
315                 case CDMInstanceSession::SessionLoadFailure::NoSessionData:
316                     promise-&gt;resolve&lt;IDLBoolean&gt;(false);
317                     return;
318                 case CDMInstanceSession::SessionLoadFailure::MismatchedSessionType:
319                     promise-&gt;reject(TypeError);
320                     return;
321                 case CDMInstanceSession::SessionLoadFailure::QuotaExceeded:
322                     promise-&gt;reject(QuotaExceededError);
323                     return;
324                 case CDMInstanceSession::SessionLoadFailure::None:
325                 case CDMInstanceSession::SessionLoadFailure::Other:
326                     // In any other case, the session load failure will cause a rejection in the following task.
327                     break;
328                 }
329             }
330 
331             // 8.9. Queue a task to run the following steps:
332             queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, knownKeys = WTFMove(knownKeys), expiration = WTFMove(expiration), message = WTFMove(message), sanitizedSessionId, succeeded, promise = WTFMove(promise)] () mutable {
333                 // 8.9.1. If any of the preceding steps failed, reject promise with a the appropriate error name.
334                 if (succeeded == CDMInstanceSession::SuccessValue::Failed) {
335                     promise-&gt;reject(NotSupportedError);
336                     return;
337                 }
338 
339                 // 8.9.2. Set the sessionId attribute to sanitized session ID.
340                 // 8.9.3. Let this object&#39;s callable value be true.
341                 m_sessionId = sanitizedSessionId;
342                 m_callable = true;
343 
344                 // 8.9.4. If the loaded session contains information about any keys (there are known keys), run the Update Key Statuses algorithm on the session, providing each key&#39;s key ID along with the appropriate MediaKeyStatus.
345                 if (knownKeys)
346                     updateKeyStatuses(WTFMove(*knownKeys));
347 
348                 // 8.9.5. Run the Update Expiration algorithm on the session, providing expiration time.
349                 // This must be run, and NaN is the default value if the CDM instance doesn&#39;t provide one.
350                 updateExpiration(expiration.valueOr(std::numeric_limits&lt;double&gt;::quiet_NaN()));
351 
352                 // 8.9.6. If message is not null, run the Queue a &quot;message&quot; Event algorithm on the session, providing message type and message.
353                 if (message)
354                     enqueueMessage(message-&gt;first, WTFMove(message-&gt;second));
355 
356                 // 8.9.7. Resolve promise with true.
357                 promise-&gt;resolve&lt;IDLBoolean&gt;(true);
358             });
359         });
360     });
361 
362     // 9. Return promise.
363 }
364 
365 void MediaKeySession::update(const BufferSource&amp; response, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
366 {
367     // https://w3c.github.io/encrypted-media/#dom-mediakeysession-update
368     // W3C Editor&#39;s Draft 09 November 2016
369 
370     // When this method is invoked, the user agent must run the following steps:
371     // 1. If this object is closed, return a promise rejected with an InvalidStateError.
372     // 2. If this object&#39;s callable value is false, return a promise rejected with an InvalidStateError.
373     LOG(EME, &quot;EME - update session for %s&quot;, m_sessionId.utf8().data());
374 
375     if (m_closed || !m_callable) {
376         promise-&gt;reject(InvalidStateError);
377         return;
378     }
379 
380     // 3. If response is an empty array, return a promise rejected with a newly created TypeError.
381     if (!response.length()) {
382         promise-&gt;reject(TypeError);
383         return;
384     }
385 
386     // 4. Let response copy be a copy of the contents of the response parameter.
387     // 5. Let promise be a new promise.
388     // 6. Run the following steps in parallel:
389     queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, response = SharedBuffer::create(response.data(), response.length()), promise = WTFMove(promise)] () mutable {
390         // 6.1. Let sanitized response be a validated and/or sanitized version of response copy.
391         RefPtr&lt;SharedBuffer&gt; sanitizedResponse = m_implementation-&gt;sanitizeResponse(response);
392 
393         // 6.2. If the preceding step failed, or if sanitized response is empty, reject promise with a newly created TypeError.
394         if (!sanitizedResponse || sanitizedResponse-&gt;isEmpty()) {
395             promise-&gt;reject(TypeError);
396             return;
397         }
398 
399         // 6.3. Let message be null.
400         // 6.4. Let message type be null.
401         // 6.5. Let session closed be false.
402         // 6.6. Let cdm be the CDM instance represented by this object&#39;s cdm instance value.
403         // 6.7. Use the cdm to execute the following steps:
404         m_instanceSession-&gt;updateLicense(m_sessionId, m_sessionType, *sanitizedResponse, [this, weakThis = makeWeakPtr(*this), promise = WTFMove(promise)] (bool sessionWasClosed, Optional&lt;CDMInstanceSession::KeyStatusVector&gt;&amp;&amp; changedKeys, Optional&lt;double&gt;&amp;&amp; changedExpiration, Optional&lt;CDMInstanceSession::Message&gt;&amp;&amp; message, CDMInstanceSession::SuccessValue succeeded) mutable {
405             if (!weakThis)
406                 return;
407 
408             // 6.7.1. If the format of sanitized response is invalid in any way, reject promise with a newly created TypeError.
409             // 6.7.2. Process sanitized response, following the stipulation for the first matching condition from the following list:
410             //   ↳ If sanitized response contains a license or key(s)
411             //     Process sanitized response, following the stipulation for the first matching condition from the following list:
412             //     ↳ If sessionType is &quot;temporary&quot; and sanitized response does not specify that session data, including any license, key(s), or similar session data it contains, should be stored
413             //       Process sanitized response, not storing any session data.
414             //     ↳ If sessionType is &quot;persistent-license&quot; and sanitized response contains a persistable license
415             //       Process sanitized response, storing the license/key(s) and related session data contained in sanitized response. Such data must be stored such that only the origin of this object&#39;s Document can access it.
416             //     ↳ If sessionType is &quot;persistent-usage-record&quot; and sanitized response contains a non-persistable license
417             //       Run the following steps:
418             //         6.7.2.3.1. Process sanitized response, not storing any session data.
419             //         6.7.2.3.2. If processing sanitized response results in the addition of keys to the set of known keys, add the key IDs of these keys to this object&#39;s record of key usage.
420             //     ↳ Otherwise
421             //       Reject promise with a newly created TypeError.
422             //   ↳ If sanitized response contains a record of license destruction acknowledgement and sessionType is &quot;persistent-license&quot;
423             //     Run the following steps:
424             //       6.7.2.1. Close the key session and clear all stored session data associated with this object, including the sessionId and record of license destruction.
425             //       6.7.2.2. Set session closed to true.
426             //   ↳ Otherwise
427             //     Process sanitized response, not storing any session data.
428             // NOTE: Steps 6.7.1. and 6.7.2. should be implemented in CDMInstance.
429 
430             if (succeeded == CDMInstanceSession::SuccessValue::Failed) {
431                 LOG(EME, &quot;EME - failed to update CDM license for %s&quot;, m_sessionId.utf8().data());
432                 promise-&gt;reject(TypeError);
433                 return;
434             }
435 
436             // 6.7.3. If a message needs to be sent to the server, execute the following steps:
437             //   6.7.3.1. Let message be that message.
438             //   6.7.3.2. Let message type be the appropriate MediaKeyMessageType for the message.
439             // 6.8. Queue a task to run the following steps:
440             queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, sessionWasClosed, changedKeys = WTFMove(changedKeys), changedExpiration = WTFMove(changedExpiration), message = WTFMove(message), promise = WTFMove(promise)] () mutable {
441                 LOG(EME, &quot;EME - updating CDM license succeeded for session %s, sending a message to the license server&quot;, m_sessionId.utf8().data());
442                 // 6.8.1.
443                 if (sessionWasClosed) {
444                     // ↳ If session closed is true:
445                     //   Run the Session Closed algorithm on this object.
446                     sessionClosed();
447                 } else {
448                     // ↳ Otherwise:
449                     //   Run the following steps:
450                     //     6.8.1.1. If the set of keys known to the CDM for this object changed or the status of any key(s) changed, run the Update Key Statuses
451                     //              algorithm on the session, providing each known key&#39;s key ID along with the appropriate MediaKeyStatus. Should additional
452                     //              processing be necessary to determine with certainty the status of a key, use &quot;status-pending&quot;. Once the additional processing
453                     //              for one or more keys has completed, run the Update Key Statuses algorithm again with the actual status(es).
454                     if (changedKeys)
455                         updateKeyStatuses(WTFMove(*changedKeys));
456 
457                     //     6.8.1.2. If the expiration time for the session changed, run the Update Expiration algorithm on the session, providing the new expiration time.
458                     if (changedExpiration)
459                         updateExpiration(*changedExpiration);
460 
461                     //     6.8.1.3. If any of the preceding steps failed, reject promise with a new DOMException whose name is the appropriate error name.
462                     // FIXME: At this point the implementations of preceding steps can&#39;t fail.
463 
464                     //     6.8.1.4. If message is not null, run the Queue a &quot;message&quot; Event algorithm on the session, providing message type and message.
465                     if (message) {
466                         MediaKeyMessageType messageType;
467                         switch (message-&gt;first) {
468                         case CDMInstanceSession::MessageType::LicenseRequest:
469                             messageType = MediaKeyMessageType::LicenseRequest;
470                             break;
471                         case CDMInstanceSession::MessageType::LicenseRenewal:
472                             messageType = MediaKeyMessageType::LicenseRenewal;
473                             break;
474                         case CDMInstanceSession::MessageType::LicenseRelease:
475                             messageType = MediaKeyMessageType::LicenseRelease;
476                             break;
477                         case CDMInstanceSession::MessageType::IndividualizationRequest:
478                             messageType = MediaKeyMessageType::IndividualizationRequest;
479                             break;
480                         }
481 
482                         enqueueMessage(messageType, WTFMove(message-&gt;second));
483                     }
484                 }
485 
486                 // 6.8.2. Resolve promise.
487                 promise-&gt;resolve();
488             });
489         });
490     });
491 
492     // 7. Return promise.
493 }
494 
495 void MediaKeySession::close(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
496 {
497     // https://w3c.github.io/encrypted-media/#dom-mediakeysession-close
498     // W3C Editor&#39;s Draft 09 November 2016
499 
500     // 1. Let session be the associated MediaKeySession object.
501     // 2. If session is closed, return a resolved promise.
502     LOG(EME, &quot;EME - closing session %s&quot;, m_sessionId.utf8().data());
503 
504     if (m_closed) {
505         promise-&gt;resolve();
506         return;
507     }
508 
509     // 3. If session&#39;s callable value is false, return a promise rejected with an InvalidStateError.
510     if (!m_callable) {
511         promise-&gt;reject(InvalidStateError);
512         return;
513     }
514 
515     // 4. Let promise be a new promise.
516     // 5. Run the following steps in parallel:
517     queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, promise = WTFMove(promise)] () mutable {
518         // 5.1. Let cdm be the CDM instance represented by session&#39;s cdm instance value.
519         // 5.2. Use cdm to close the key session associated with session.
520         LOG(EME, &quot;EME - closing CDM session %s&quot;, m_sessionId.utf8().data());
521         m_instanceSession-&gt;closeSession(m_sessionId, [this, weakThis = makeWeakPtr(*this), promise = WTFMove(promise)] () mutable {
522             if (!weakThis)
523                 return;
524 
525             // 5.3. Queue a task to run the following steps:
526             queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, promise = WTFMove(promise)] () mutable {
527                 // 5.3.1. Run the Session Closed algorithm on the session.
528                 sessionClosed();
529 
530                 // 5.3.2. Resolve promise.
531                 promise-&gt;resolve();
532             });
533         });
534     });
535 
536     // 6. Return promise.
537 }
538 
539 void MediaKeySession::remove(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
540 {
541     // https://w3c.github.io/encrypted-media/#dom-mediakeysession-remove
542     // W3C Editor&#39;s Draft 09 November 2016
543 
544     // 1. If this object is closed, return a promise rejected with an InvalidStateError.
545     // 2. If this object&#39;s callable value is false, return a promise rejected with an InvalidStateError.
546     LOG(EME, &quot;EME - removing session %s&quot;, m_sessionId.utf8().data());
547 
548     if (m_closed || !m_callable) {
549         promise-&gt;reject(InvalidStateError);
550         return;
551     }
552 
553     // 3. Let promise be a new promise.
554     // 4. Run the following steps in parallel:
555     queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, promise = WTFMove(promise)] () mutable {
556         // 4.1. Let cdm be the CDM instance represented by this object&#39;s cdm instance value.
557         // 4.2. Let message be null.
558         // 4.3. Let message type be null.
559 
560         // 4.4. Use the cdm to execute the following steps:
561         m_instanceSession-&gt;removeSessionData(m_sessionId, m_sessionType, [this, weakThis = makeWeakPtr(*this), promise = WTFMove(promise)] (CDMInstanceSession::KeyStatusVector&amp;&amp; keys, Optional&lt;Ref&lt;SharedBuffer&gt;&gt;&amp;&amp; message, CDMInstanceSession::SuccessValue succeeded) mutable {
562             if (!weakThis)
563                 return;
564 
565             // 4.4.1. If any license(s) and/or key(s) are associated with the session:
566             //   4.4.1.1. Destroy the license(s) and/or key(s) associated with the session.
567             //   4.4.1.2. Follow the steps for the value of this object&#39;s session type from the following list:
568             //     ↳ &quot;temporary&quot;
569             //       4.4.1.2.1.1 Continue with the following steps.
570             //     ↳ &quot;persistent-license&quot;
571             //       4.4.1.2.2.1. Let record of license destruction be a record of license destruction for the license represented by this object.
572             //       4.4.1.2.2.2. Store the record of license destruction.
573             //       4.4.1.2.2.3. Let message be a message containing or reflecting the record of license destruction.
574             //     ↳ &quot;persistent-usage-record&quot;
575             //       4.4.1.2.3.1. Store this object&#39;s record of key usage.
576             //       4.4.1.2.3.2. Let message be a message containing or reflecting this object&#39;s record of key usage.
577             // NOTE: Step 4.4.1. should be implemented in CDMInstance.
578 
579             // 4.5. Queue a task to run the following steps:
580             queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, keys = WTFMove(keys), message = WTFMove(message), succeeded, promise = WTFMove(promise)] () mutable {
581                 // 4.5.1. Run the Update Key Statuses algorithm on the session, providing all key ID(s) in the session along with the &quot;released&quot; MediaKeyStatus value for each.
582                 updateKeyStatuses(WTFMove(keys));
583 
584                 // 4.5.2. Run the Update Expiration algorithm on the session, providing NaN.
585                 updateExpiration(std::numeric_limits&lt;double&gt;::quiet_NaN());
586 
587                 // 4.5.3. If any of the preceding steps failed, reject promise with a new DOMException whose name is the appropriate error name.
588                 if (succeeded == CDMInstanceSession::SuccessValue::Failed) {
589                     promise-&gt;reject(NotSupportedError);
590                     return;
591                 }
592 
593                 // 4.5.4. Let message type be &quot;license-release&quot;.
594                 // 4.5.5. If message is not null, run the Queue a &quot;message&quot; Event algorithm on the session, providing message type and message.
595                 if (message)
596                     enqueueMessage(MediaKeyMessageType::LicenseRelease, *message);
597 
598                 // 4.5.6. Resolve promise.
599                 promise-&gt;resolve();
600             });
601         });
602     });
603 
604     // 5. Return promise.
605 }
606 
607 void MediaKeySession::enqueueMessage(MediaKeyMessageType messageType, const SharedBuffer&amp; message)
608 {
609     // 6.4.1 Queue a &quot;message&quot; Event
610     // https://w3c.github.io/encrypted-media/#queue-message
611     // W3C Editor&#39;s Draft 09 November 2016
612 
613     // The following steps are run:
614     // 1. Let the session be the specified MediaKeySession object.
615     // 2. Queue a task to create an event named message that does not bubble and is not cancellable using the MediaKeyMessageEvent
616     //    interface with its type attribute set to message and its isTrusted attribute initialized to true, and dispatch it at the
617     //    session.
618     auto messageEvent = MediaKeyMessageEvent::create(eventNames().messageEvent, {messageType, message.tryCreateArrayBuffer()}, Event::IsTrusted::Yes);
619     queueTaskToDispatchEvent(*this, TaskSource::Networking, WTFMove(messageEvent));
620 }
621 
622 void MediaKeySession::updateKeyStatuses(CDMInstanceSession::KeyStatusVector&amp;&amp; inputStatuses)
623 {
624     // https://w3c.github.io/encrypted-media/#update-key-statuses
625     // W3C Editor&#39;s Draft 09 November 2016
626 
627     // 1. Let the session be the associated MediaKeySession object.
628     // 2. Let the input statuses be the sequence of pairs key ID and associated MediaKeyStatus pairs.
629     // 3. Let the statuses be session&#39;s keyStatuses attribute.
630     // 4. Run the following steps to replace the contents of statuses:
631     //   4.1. Empty statuses.
632     //   4.2. For each pair in input statuses.
633     //     4.2.1. Let pair be the pair.
634     //     4.2.2. Insert an entry for pair&#39;s key ID into statuses with the value of pair&#39;s MediaKeyStatus value.
635 
636     static auto toMediaKeyStatus = [] (CDMInstanceSession::KeyStatus status) -&gt; MediaKeyStatus {
637         switch (status) {
638         case CDMInstanceSession::KeyStatus::Usable:
639             return MediaKeyStatus::Usable;
640         case CDMInstanceSession::KeyStatus::Expired:
641             return MediaKeyStatus::Expired;
642         case CDMInstanceSession::KeyStatus::Released:
643             return MediaKeyStatus::Released;
644         case CDMInstanceSession::KeyStatus::OutputRestricted:
645             return MediaKeyStatus::OutputRestricted;
646         case CDMInstanceSession::KeyStatus::OutputDownscaled:
647             return MediaKeyStatus::OutputDownscaled;
648         case CDMInstanceSession::KeyStatus::StatusPending:
649             return MediaKeyStatus::StatusPending;
650         case CDMInstanceSession::KeyStatus::InternalError:
651             return MediaKeyStatus::InternalError;
652         };
653 
654         ASSERT_NOT_REACHED();
655         return MediaKeyStatus::InternalError;
656     };
657 
658     m_statuses.clear();
659     m_statuses.reserveCapacity(inputStatuses.size());
660     for (auto&amp; status : inputStatuses)
661         m_statuses.uncheckedAppend({ WTFMove(status.first), toMediaKeyStatus(status.second) });
662 
663     // 5. Queue a task to fire a simple event named keystatuseschange at the session.
664     queueTaskToDispatchEvent(*this, TaskSource::Networking, Event::create(eventNames().keystatuseschangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
665 
666     // 6. Queue a task to run the Attempt to Resume Playback If Necessary algorithm on each of the media element(s) whose mediaKeys attribute is the MediaKeys object that created the session.
667     queueTaskKeepingObjectAlive(*this, TaskSource::Networking,
668         [this] () mutable {
669             if (m_keys)
670                 m_keys-&gt;attemptToResumePlaybackOnClients();
671         });
672 }
673 
674 void MediaKeySession::sendMessage(CDMMessageType messageType, Ref&lt;SharedBuffer&gt;&amp;&amp; message)
675 {
676     enqueueMessage(messageType, message);
677 }
678 
679 void MediaKeySession::sessionIdChanged(const String&amp; sessionId)
680 {
681     m_sessionId = sessionId;
682 }
683 
684 void MediaKeySession::updateExpiration(double)
685 {
686     notImplemented();
687 }
688 
689 void MediaKeySession::sessionClosed()
690 {
691     // https://w3c.github.io/encrypted-media/#session-closed
692     // W3C Editor&#39;s Draft 09 November 2016
693     LOG(EME, &quot;EME - session %s was closed&quot;, m_sessionId.utf8().data());
694 
695     // 1. Let session be the associated MediaKeySession object.
696     // 2. If session&#39;s session type is &quot;persistent-usage-record&quot;, execute the following steps in parallel:
697     if (m_sessionType == MediaKeySessionType::PersistentUsageRecord) {
698         // 2.1. Let cdm be the CDM instance represented by session&#39;s cdm instance value.
699         // 2.2. Use cdm to store session&#39;s record of key usage, if it exists.
700         m_instanceSession-&gt;storeRecordOfKeyUsage(m_sessionId);
701     }
702 
703     // 3. Run the Update Key Statuses algorithm on the session, providing an empty sequence.
704     updateKeyStatuses({ });
705 
706     // 4. Run the Update Expiration algorithm on the session, providing NaN.
707     updateExpiration(std::numeric_limits&lt;double&gt;::quiet_NaN());
708 
709     // Let&#39;s consider the session closed before any promise on the &#39;closed&#39; attribute is resolved.
710     m_closed = true;
711 
712     // 5. Let promise be the closed attribute of the session.
713     // 6. Resolve promise.
714     m_closedPromise-&gt;resolve();
715 }
716 
717 String MediaKeySession::mediaKeysStorageDirectory() const
718 {
719     auto* document = downcast&lt;Document&gt;(scriptExecutionContext());
720     if (!document)
721         return emptyString();
722 
723     auto* page = document-&gt;page();
724     if (!page || page-&gt;usesEphemeralSession())
725         return emptyString();
726 
727     auto storageDirectory = document-&gt;settings().mediaKeysStorageDirectory();
728     if (storageDirectory.isEmpty())
729         return emptyString();
730 
731     return FileSystem::pathByAppendingComponent(storageDirectory, document-&gt;securityOrigin().data().databaseIdentifier());
732 }
733 
734 bool MediaKeySession::hasPendingActivity() const
735 {
736     // A MediaKeySession object SHALL NOT be destroyed and SHALL continue to receive events if it is not closed and the MediaKeys object that created it remains accessible.
737     return (!m_closed &amp;&amp; m_keys) || ActiveDOMObject::hasPendingActivity();
738 }
739 
740 const char* MediaKeySession::activeDOMObjectName() const
741 {
742     return &quot;MediaKeySession&quot;;
743 }
744 
745 } // namespace WebCore
746 
747 #endif
    </pre>
  </body>
</html>
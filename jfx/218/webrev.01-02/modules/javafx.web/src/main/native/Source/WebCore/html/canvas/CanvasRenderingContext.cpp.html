<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/canvas/CanvasRenderingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2009 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;CanvasRenderingContext.h&quot;
 28 
 29 #include &quot;CachedImage.h&quot;
 30 #include &quot;CanvasPattern.h&quot;
 31 #include &quot;HTMLCanvasElement.h&quot;
 32 #include &quot;HTMLImageElement.h&quot;
 33 #include &quot;HTMLVideoElement.h&quot;
 34 #include &quot;Image.h&quot;
 35 #include &quot;ImageBitmap.h&quot;
 36 #include &quot;SecurityOrigin.h&quot;
 37 #include &lt;wtf/HashSet.h&gt;
 38 #include &lt;wtf/IsoMallocInlines.h&gt;
 39 #include &lt;wtf/Lock.h&gt;
 40 #include &lt;wtf/NeverDestroyed.h&gt;
 41 #include &lt;wtf/URL.h&gt;
 42 
 43 namespace WebCore {
 44 
 45 WTF_MAKE_ISO_ALLOCATED_IMPL(CanvasRenderingContext);
 46 
 47 HashSet&lt;CanvasRenderingContext*&gt;&amp; CanvasRenderingContext::instances(const LockHolder&amp;)
 48 {
 49     static NeverDestroyed&lt;HashSet&lt;CanvasRenderingContext*&gt;&gt; instances;
 50     return instances;
 51 }
 52 
 53 Lock&amp; CanvasRenderingContext::instancesMutex()
 54 {
 55     static LazyNeverDestroyed&lt;Lock&gt; mutex;
 56     static std::once_flag initializeMutex;
 57     std::call_once(initializeMutex, [] {
 58         mutex.construct();
 59     });
 60     return mutex.get();
 61 }
 62 
 63 CanvasRenderingContext::CanvasRenderingContext(CanvasBase&amp; canvas)
 64     : m_canvas(canvas)
 65 {
 66     LockHolder lock(instancesMutex());
 67     instances(lock).add(this);
 68 }
 69 
 70 CanvasRenderingContext::~CanvasRenderingContext()
 71 {
 72     LockHolder lock(instancesMutex());
 73     ASSERT(instances(lock).contains(this));
 74     instances(lock).remove(this);
 75 }
 76 
 77 void CanvasRenderingContext::ref()
 78 {
 79     m_canvas.refCanvasBase();
 80 }
 81 
 82 void CanvasRenderingContext::deref()
 83 {
 84     m_canvas.derefCanvasBase();
 85 }
 86 
 87 bool CanvasRenderingContext::wouldTaintOrigin(const CanvasPattern* pattern)
 88 {
 89     if (m_canvas.originClean() &amp;&amp; pattern &amp;&amp; !pattern-&gt;originClean())
 90         return true;
 91     return false;
 92 }
 93 
 94 bool CanvasRenderingContext::wouldTaintOrigin(const CanvasBase* sourceCanvas)
 95 {
 96     if (m_canvas.originClean() &amp;&amp; sourceCanvas &amp;&amp; !sourceCanvas-&gt;originClean())
 97         return true;
 98     return false;
 99 }
100 
101 bool CanvasRenderingContext::wouldTaintOrigin(const HTMLImageElement* element)
102 {
103     if (!element || !m_canvas.originClean())
104         return false;
105 
106     auto* cachedImage = element-&gt;cachedImage();
107     if (!cachedImage)
108         return false;
109 
110     auto image = makeRefPtr(cachedImage-&gt;image());
111     if (!image)
112         return false;
113 
114     if (image-&gt;sourceURL().protocolIsData())
115         return false;
116 
117     if (!image-&gt;hasSingleSecurityOrigin())
118         return true;
119 
120     if (!cachedImage-&gt;isCORSSameOrigin())
121         return true;
122 
123     ASSERT(m_canvas.securityOrigin());
124     ASSERT(cachedImage-&gt;origin());
125     ASSERT(m_canvas.securityOrigin()-&gt;toString() == cachedImage-&gt;origin()-&gt;toString());
126     return false;
127 }
128 
129 bool CanvasRenderingContext::wouldTaintOrigin(const HTMLVideoElement* video)
130 {
131 #if ENABLE(VIDEO)
132     // FIXME: This check is likely wrong when a redirect is involved. We need
133     // to test the finalURL. Please be careful when fixing this issue not to
134     // make currentSrc be the final URL because then the
135     // HTMLMediaElement.currentSrc DOM API would leak redirect destinations!
136     if (!video || !m_canvas.originClean())
137         return false;
138 
139     if (!video-&gt;hasSingleSecurityOrigin())
140         return true;
141 
142     if (!(video-&gt;player() &amp;&amp; video-&gt;player()-&gt;didPassCORSAccessCheck()) &amp;&amp; video-&gt;wouldTaintOrigin(*m_canvas.securityOrigin()))
143         return true;
144 
145 #else
146     UNUSED_PARAM(video);
147 #endif
148 
149     return false;
150 }
151 
152 bool CanvasRenderingContext::wouldTaintOrigin(const ImageBitmap* imageBitmap)
153 {
154     if (!imageBitmap || !m_canvas.originClean())
155         return false;
156 
157     return !imageBitmap-&gt;originClean();
158 }
159 
160 bool CanvasRenderingContext::wouldTaintOrigin(const URL&amp; url)
161 {
162     if (!m_canvas.originClean())
163         return false;
164 
165     if (url.protocolIsData())
166         return false;
167 
168     return !m_canvas.securityOrigin()-&gt;canRequest(url);
169 }
170 
171 void CanvasRenderingContext::checkOrigin(const URL&amp; url)
172 {
173     if (wouldTaintOrigin(url))
174         m_canvas.setOriginTainted();
175 }
176 
177 void CanvasRenderingContext::checkOrigin(const TypedOMCSSImageValue&amp;)
178 {
179     m_canvas.setOriginTainted();
180 }
181 
182 } // namespace WebCore
    </pre>
  </body>
</html>
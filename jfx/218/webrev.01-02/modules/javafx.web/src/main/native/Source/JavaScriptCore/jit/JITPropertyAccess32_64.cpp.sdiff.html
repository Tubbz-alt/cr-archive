<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITPropertyAccess32_64.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JITPropertyAccess.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITRightShiftGenerator.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITPropertyAccess32_64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  33 #include &quot;DirectArguments.h&quot;
  34 #include &quot;GCAwareJITStubRoutine.h&quot;
  35 #include &quot;InterpreterInlines.h&quot;
  36 #include &quot;JITInlines.h&quot;
  37 #include &quot;JSArray.h&quot;
  38 #include &quot;JSFunction.h&quot;
  39 #include &quot;JSLexicalEnvironment.h&quot;
  40 #include &quot;LinkBuffer.h&quot;
  41 #include &quot;OpcodeInlines.h&quot;
  42 #include &quot;ResultType.h&quot;
  43 #include &quot;SlowPathCall.h&quot;
  44 #include &quot;StructureStubInfo.h&quot;
  45 #include &lt;wtf/StringPrintStream.h&gt;
  46 
  47 
  48 namespace JSC {
  49 
  50 void JIT::emit_op_put_getter_by_id(const Instruction* currentInstruction)
  51 {
  52     auto bytecode = currentInstruction-&gt;as&lt;OpPutGetterById&gt;();
<span class="line-modified">  53     int base = bytecode.m_base.offset();</span>
  54     int property = bytecode.m_property;
  55     int options = bytecode.m_attributes;
<span class="line-modified">  56     int getter = bytecode.m_accessor.offset();</span>
  57 
  58     emitLoadPayload(base, regT1);
  59     emitLoadPayload(getter, regT3);
<span class="line-modified">  60     callOperation(operationPutGetterById, regT1, m_codeBlock-&gt;identifier(property).impl(), options, regT3);</span>
  61 }
  62 
  63 void JIT::emit_op_put_setter_by_id(const Instruction* currentInstruction)
  64 {
  65     auto bytecode = currentInstruction-&gt;as&lt;OpPutSetterById&gt;();
<span class="line-modified">  66     int base = bytecode.m_base.offset();</span>
  67     int property = bytecode.m_property;
  68     int options = bytecode.m_attributes;
<span class="line-modified">  69     int setter = bytecode.m_accessor.offset();</span>
  70 
  71     emitLoadPayload(base, regT1);
  72     emitLoadPayload(setter, regT3);
<span class="line-modified">  73     callOperation(operationPutSetterById, regT1, m_codeBlock-&gt;identifier(property).impl(), options, regT3);</span>
  74 }
  75 
  76 void JIT::emit_op_put_getter_setter_by_id(const Instruction* currentInstruction)
  77 {
  78     auto bytecode = currentInstruction-&gt;as&lt;OpPutGetterSetterById&gt;();
<span class="line-modified">  79     int base = bytecode.m_base.offset();</span>
  80     int property = bytecode.m_property;
  81     int attributes = bytecode.m_attributes;
<span class="line-modified">  82     int getter = bytecode.m_getter.offset();</span>
<span class="line-modified">  83     int setter = bytecode.m_setter.offset();</span>
  84 
  85     emitLoadPayload(base, regT1);
  86     emitLoadPayload(getter, regT3);
  87     emitLoadPayload(setter, regT4);
<span class="line-modified">  88     callOperation(operationPutGetterSetter, regT1, m_codeBlock-&gt;identifier(property).impl(), attributes, regT3, regT4);</span>
  89 }
  90 
  91 void JIT::emit_op_put_getter_by_val(const Instruction* currentInstruction)
  92 {
  93     auto bytecode = currentInstruction-&gt;as&lt;OpPutGetterByVal&gt;();
<span class="line-modified">  94     int base = bytecode.m_base.offset();</span>
<span class="line-modified">  95     int property = bytecode.m_property.offset();</span>
  96     int32_t attributes = bytecode.m_attributes;
<span class="line-modified">  97     int getter = bytecode.m_accessor.offset();</span>
  98 
  99     emitLoadPayload(base, regT2);
 100     emitLoad(property, regT1, regT0);
 101     emitLoadPayload(getter, regT3);
<span class="line-modified"> 102     callOperation(operationPutGetterByVal, regT2, JSValueRegs(regT1, regT0), attributes, regT3);</span>
 103 }
 104 
 105 void JIT::emit_op_put_setter_by_val(const Instruction* currentInstruction)
 106 {
 107     auto bytecode = currentInstruction-&gt;as&lt;OpPutSetterByVal&gt;();
<span class="line-modified"> 108     int base = bytecode.m_base.offset();</span>
<span class="line-modified"> 109     int property = bytecode.m_property.offset();</span>
 110     int32_t attributes = bytecode.m_attributes;
<span class="line-modified"> 111     int setter = bytecode.m_accessor.offset();</span>
 112 
 113     emitLoadPayload(base, regT2);
 114     emitLoad(property, regT1, regT0);
 115     emitLoadPayload(setter, regT3);
<span class="line-modified"> 116     callOperation(operationPutSetterByVal, regT2, JSValueRegs(regT1, regT0), attributes, regT3);</span>
 117 }
 118 
 119 void JIT::emit_op_del_by_id(const Instruction* currentInstruction)
 120 {
 121     auto bytecode = currentInstruction-&gt;as&lt;OpDelById&gt;();
<span class="line-modified"> 122     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified"> 123     int base = bytecode.m_base.offset();</span>
 124     int property = bytecode.m_property;
 125     emitLoad(base, regT1, regT0);
<span class="line-modified"> 126     callOperation(operationDeleteByIdJSResult, dst, JSValueRegs(regT1, regT0), m_codeBlock-&gt;identifier(property).impl());</span>
 127 }
 128 
 129 void JIT::emit_op_del_by_val(const Instruction* currentInstruction)
 130 {
 131     auto bytecode = currentInstruction-&gt;as&lt;OpDelByVal&gt;();
<span class="line-modified"> 132     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified"> 133     int base = bytecode.m_base.offset();</span>
<span class="line-modified"> 134     int property = bytecode.m_property.offset();</span>
 135     emitLoad2(base, regT1, regT0, property, regT3, regT2);
<span class="line-modified"> 136     callOperation(operationDeleteByValJSResult, dst, JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));</span>
 137 }
 138 
 139 void JIT::emit_op_get_by_val(const Instruction* currentInstruction)
 140 {
 141     auto bytecode = currentInstruction-&gt;as&lt;OpGetByVal&gt;();
 142     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified"> 143     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified"> 144     int base = bytecode.m_base.offset();</span>
<span class="line-modified"> 145     int property = bytecode.m_property.offset();</span>
 146     ArrayProfile* profile = &amp;metadata.m_arrayProfile;
<span class="line-removed"> 147     ByValInfo* byValInfo = m_codeBlock-&gt;addByValInfo();</span>
 148 
 149     emitLoad2(base, regT1, regT0, property, regT3, regT2);
 150 
<span class="line-modified"> 151     emitJumpSlowCaseIfNotJSCell(base, regT1);</span>
<span class="line-modified"> 152     PatchableJump notIndex = patchableBranch32(NotEqual, regT3, TrustedImm32(JSValue::Int32Tag));</span>
<span class="line-modified"> 153     addSlowCase(notIndex);</span>
<span class="line-modified"> 154     emitArrayProfilingSiteWithCell(regT0, regT1, profile);</span>
<span class="line-modified"> 155     and32(TrustedImm32(IndexingShapeMask), regT1);</span>
<span class="line-modified"> 156 </span>
<span class="line-modified"> 157     PatchableJump badType;</span>
<span class="line-modified"> 158     JumpList slowCases;</span>
<span class="line-modified"> 159 </span>
<span class="line-modified"> 160     JITArrayMode mode = chooseArrayMode(profile);</span>
<span class="line-modified"> 161     switch (mode) {</span>
<span class="line-modified"> 162     case JITInt32:</span>
<span class="line-modified"> 163         slowCases = emitInt32GetByVal(currentInstruction, badType);</span>
<span class="line-modified"> 164         break;</span>
<span class="line-modified"> 165     case JITDouble:</span>
<span class="line-modified"> 166         slowCases = emitDoubleGetByVal(currentInstruction, badType);</span>
<span class="line-modified"> 167         break;</span>
<span class="line-modified"> 168     case JITContiguous:</span>
<span class="line-modified"> 169         slowCases = emitContiguousGetByVal(currentInstruction, badType);</span>
<span class="line-modified"> 170         break;</span>
<span class="line-removed"> 171     case JITArrayStorage:</span>
<span class="line-removed"> 172         slowCases = emitArrayStorageGetByVal(currentInstruction, badType);</span>
<span class="line-removed"> 173         break;</span>
<span class="line-removed"> 174     default:</span>
<span class="line-removed"> 175         CRASH();</span>
<span class="line-removed"> 176     }</span>
<span class="line-removed"> 177 </span>
<span class="line-removed"> 178     addSlowCase(badType);</span>
<span class="line-removed"> 179     addSlowCase(slowCases);</span>
<span class="line-removed"> 180 </span>
<span class="line-removed"> 181     Label done = label();</span>
<span class="line-removed"> 182 </span>
<span class="line-removed"> 183     if (!ASSERT_DISABLED) {</span>
<span class="line-removed"> 184         Jump resultOK = branchIfNotEmpty(regT1);</span>
<span class="line-removed"> 185         abortWithReason(JITGetByValResultIsNotEmpty);</span>
<span class="line-removed"> 186         resultOK.link(this);</span>
 187     }
<span class="line-removed"> 188 </span>
<span class="line-removed"> 189     emitValueProfilingSite(bytecode.metadata(m_codeBlock));</span>
<span class="line-removed"> 190     emitStore(dst, regT1, regT0);</span>
<span class="line-removed"> 191 </span>
<span class="line-removed"> 192     Label nextHotPath = label();</span>
<span class="line-removed"> 193 </span>
<span class="line-removed"> 194     m_byValCompilationInfo.append(ByValCompilationInfo(byValInfo, m_bytecodeOffset, notIndex, badType, mode, profile, done, nextHotPath));</span>
<span class="line-removed"> 195 }</span>
<span class="line-removed"> 196 </span>
<span class="line-removed"> 197 JITGetByIdGenerator JIT::emitGetByValWithCachedId(ByValInfo* byValInfo, OpGetByVal bytecode, const Identifier&amp; propertyName, Jump&amp; fastDoneCase, Jump&amp; slowDoneCase, JumpList&amp; slowCases)</span>
<span class="line-removed"> 198 {</span>
<span class="line-removed"> 199     // base: tag(regT1), payload(regT0)</span>
<span class="line-removed"> 200     // property: tag(regT3), payload(regT2)</span>
<span class="line-removed"> 201     // scratch: regT4</span>
<span class="line-removed"> 202 </span>
<span class="line-removed"> 203     int dst = bytecode.m_dst.offset();</span>
<span class="line-removed"> 204 </span>
<span class="line-removed"> 205     slowCases.append(branchIfNotCell(regT3));</span>
<span class="line-removed"> 206     emitByValIdentifierCheck(byValInfo, regT2, regT4, propertyName, slowCases);</span>
<span class="line-removed"> 207 </span>
<span class="line-removed"> 208     const Instruction* currentInstruction = m_codeBlock-&gt;instructions().at(byValInfo-&gt;bytecodeIndex).ptr();</span>
<span class="line-removed"> 209     JITGetByIdGenerator gen(</span>
<span class="line-removed"> 210         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(currentInstruction), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-removed"> 211         propertyName.impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0), AccessType::Get);</span>
<span class="line-removed"> 212     gen.generateFastPath(*this);</span>
<span class="line-removed"> 213 </span>
<span class="line-removed"> 214     fastDoneCase = jump();</span>
<span class="line-removed"> 215 </span>
<span class="line-removed"> 216     Label coldPathBegin = label();</span>
<span class="line-removed"> 217     gen.slowPathJump().link(this);</span>
<span class="line-removed"> 218 </span>
<span class="line-removed"> 219     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdOptimize, dst, gen.stubInfo(), JSValueRegs(regT1, regT0), propertyName.impl());</span>
<span class="line-removed"> 220     gen.reportSlowPathCall(coldPathBegin, call);</span>
<span class="line-removed"> 221     slowDoneCase = jump();</span>
<span class="line-removed"> 222 </span>
<span class="line-removed"> 223     return gen;</span>
 224 }
 225 
 226 void JIT::emitSlow_op_get_by_val(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 227 {
<span class="line-modified"> 228     auto bytecode = currentInstruction-&gt;as&lt;OpGetByVal&gt;();</span>
<span class="line-modified"> 229     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified"> 230     int base = bytecode.m_base.offset();</span>
<span class="line-modified"> 231     int property = bytecode.m_property.offset();</span>
<span class="line-modified"> 232     ByValInfo* byValInfo = m_byValCompilationInfo[m_byValInstructionIndex].byValInfo;</span>
<span class="line-removed"> 233 </span>
<span class="line-removed"> 234     linkSlowCaseIfNotJSCell(iter, base); // base cell check</span>
<span class="line-removed"> 235     linkSlowCase(iter); // property int32 check</span>
<span class="line-removed"> 236 </span>
<span class="line-removed"> 237     Jump nonCell = jump();</span>
<span class="line-removed"> 238     linkSlowCase(iter); // base array check</span>
<span class="line-removed"> 239     Jump notString = branchIfNotString(regT0);</span>
<span class="line-removed"> 240     emitNakedCall(CodeLocationLabel&lt;NoPtrTag&gt;(m_vm-&gt;getCTIStub(stringGetByValGenerator).retaggedCode&lt;NoPtrTag&gt;()));</span>
<span class="line-removed"> 241     Jump failed = branchTestPtr(Zero, regT0);</span>
<span class="line-removed"> 242     emitStoreCell(dst, regT0);</span>
<span class="line-removed"> 243     emitJumpSlowToHot(jump(), currentInstruction-&gt;size());</span>
<span class="line-removed"> 244     failed.link(this);</span>
<span class="line-removed"> 245     notString.link(this);</span>
<span class="line-removed"> 246     nonCell.link(this);</span>
<span class="line-removed"> 247 </span>
<span class="line-removed"> 248     linkSlowCase(iter); // vector length check</span>
<span class="line-removed"> 249     linkSlowCase(iter); // empty value</span>
<span class="line-removed"> 250 </span>
<span class="line-removed"> 251     Label slowPath = label();</span>
 252 
<span class="line-modified"> 253     emitLoad(base, regT1, regT0);</span>
<span class="line-modified"> 254     emitLoad(property, regT3, regT2);</span>
<span class="line-removed"> 255     Call call = callOperation(operationGetByValOptimize, dst, JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2), byValInfo);</span>
 256 
<span class="line-modified"> 257     m_byValCompilationInfo[m_byValInstructionIndex].slowPathTarget = slowPath;</span>
<span class="line-removed"> 258     m_byValCompilationInfo[m_byValInstructionIndex].returnAddress = call;</span>
<span class="line-removed"> 259     m_byValInstructionIndex++;</span>
 260 
<span class="line-modified"> 261     emitValueProfilingSite(bytecode.metadata(m_codeBlock));</span>



 262 }
 263 
 264 void JIT::emit_op_put_by_val_direct(const Instruction* currentInstruction)
 265 {
 266     emit_op_put_by_val&lt;OpPutByValDirect&gt;(currentInstruction);
 267 }
 268 
 269 template&lt;typename Op&gt;
 270 void JIT::emit_op_put_by_val(const Instruction* currentInstruction)
 271 {
 272     auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
 273     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified"> 274     int base = bytecode.m_base.offset();</span>
<span class="line-modified"> 275     int property = bytecode.m_property.offset();</span>
 276     ArrayProfile* profile = &amp;metadata.m_arrayProfile;
 277     ByValInfo* byValInfo = m_codeBlock-&gt;addByValInfo();
 278 
 279     emitLoad2(base, regT1, regT0, property, regT3, regT2);
 280 
 281     emitJumpSlowCaseIfNotJSCell(base, regT1);
 282     PatchableJump notIndex = patchableBranch32(NotEqual, regT3, TrustedImm32(JSValue::Int32Tag));
 283     addSlowCase(notIndex);
 284     emitArrayProfilingSiteWithCell(regT0, regT1, profile);
 285 
 286     PatchableJump badType;
 287     JumpList slowCases;
 288 
 289     // FIXME: Maybe we should do this inline?
 290     addSlowCase(branchTest32(NonZero, regT1, TrustedImm32(CopyOnWrite)));
 291     and32(TrustedImm32(IndexingShapeMask), regT1);
 292 
 293     JITArrayMode mode = chooseArrayMode(profile);
 294     switch (mode) {
 295     case JITInt32:
</pre>
<hr />
<pre>
 297         break;
 298     case JITDouble:
 299         slowCases = emitDoublePutByVal(bytecode, badType);
 300         break;
 301     case JITContiguous:
 302         slowCases = emitContiguousPutByVal(bytecode, badType);
 303         break;
 304     case JITArrayStorage:
 305         slowCases = emitArrayStoragePutByVal(bytecode, badType);
 306         break;
 307     default:
 308         CRASH();
 309         break;
 310     }
 311 
 312     addSlowCase(badType);
 313     addSlowCase(slowCases);
 314 
 315     Label done = label();
 316 
<span class="line-modified"> 317     m_byValCompilationInfo.append(ByValCompilationInfo(byValInfo, m_bytecodeOffset, notIndex, badType, mode, profile, done, done));</span>
 318 }
 319 
 320 template &lt;typename Op&gt;
 321 JIT::JumpList JIT::emitGenericContiguousPutByVal(Op bytecode, PatchableJump&amp; badType, IndexingType indexingShape)
 322 {
 323     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified"> 324     int base = bytecode.m_base.offset();</span>
<span class="line-modified"> 325     int value = bytecode.m_value.offset();</span>
 326     ArrayProfile* profile = &amp;metadata.m_arrayProfile;
 327 
 328     JumpList slowCases;
 329 
 330     badType = patchableBranch32(NotEqual, regT1, TrustedImm32(ContiguousShape));
 331 
 332     loadPtr(Address(regT0, JSObject::butterflyOffset()), regT3);
 333     Jump outOfBounds = branch32(AboveOrEqual, regT2, Address(regT3, Butterfly::offsetOfPublicLength()));
 334 
 335     Label storeResult = label();
 336     emitLoad(value, regT1, regT0);
 337     switch (indexingShape) {
 338     case Int32Shape:
 339         slowCases.append(branchIfNotInt32(regT1));
 340         store32(regT0, BaseIndex(regT3, regT2, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
 341         store32(regT1, BaseIndex(regT3, regT2, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
 342         break;
 343     case ContiguousShape:
 344         store32(regT0, BaseIndex(regT3, regT2, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
 345         store32(regT1, BaseIndex(regT3, regT2, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
</pre>
<hr />
<pre>
 365     Jump done = jump();
 366 
 367     outOfBounds.link(this);
 368     slowCases.append(branch32(AboveOrEqual, regT2, Address(regT3, Butterfly::offsetOfVectorLength())));
 369 
 370     emitArrayProfileStoreToHoleSpecialCase(profile);
 371 
 372     add32(TrustedImm32(1), regT2, regT1);
 373     store32(regT1, Address(regT3, Butterfly::offsetOfPublicLength()));
 374     jump().linkTo(storeResult, this);
 375 
 376     done.link(this);
 377 
 378     return slowCases;
 379 }
 380 
 381 template &lt;typename Op&gt;
 382 JIT::JumpList JIT::emitArrayStoragePutByVal(Op bytecode, PatchableJump&amp; badType)
 383 {
 384     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified"> 385     int base = bytecode.m_base.offset();</span>
<span class="line-modified"> 386     int value = bytecode.m_value.offset();</span>
 387     ArrayProfile* profile = &amp;metadata.m_arrayProfile;
 388 
 389     JumpList slowCases;
 390 
 391     badType = patchableBranch32(NotEqual, regT1, TrustedImm32(ArrayStorageShape));
 392 
 393     loadPtr(Address(regT0, JSObject::butterflyOffset()), regT3);
 394     slowCases.append(branch32(AboveOrEqual, regT2, Address(regT3, ArrayStorage::vectorLengthOffset())));
 395 
 396     Jump empty = branch32(Equal, BaseIndex(regT3, regT2, TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), TrustedImm32(JSValue::EmptyValueTag));
 397 
 398     Label storeResult(this);
 399     emitLoad(value, regT1, regT0);
 400     store32(regT0, BaseIndex(regT3, regT2, TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload))); // payload
 401     store32(regT1, BaseIndex(regT3, regT2, TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag))); // tag
 402     Jump end = jump();
 403 
 404     empty.link(this);
 405     emitArrayProfileStoreToHoleSpecialCase(profile);
 406     add32(TrustedImm32(1), Address(regT3, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
 407     branch32(Below, regT2, Address(regT3, ArrayStorage::lengthOffset())).linkTo(storeResult, this);
 408 
 409     add32(TrustedImm32(1), regT2, regT0);
 410     store32(regT0, Address(regT3, ArrayStorage::lengthOffset()));
 411     jump().linkTo(storeResult, this);
 412 
 413     end.link(this);
 414 
 415     emitWriteBarrier(base, value, ShouldFilterValue);
 416 
 417     return slowCases;
 418 }
 419 
 420 template &lt;typename Op&gt;
 421 JITPutByIdGenerator JIT::emitPutByValWithCachedId(ByValInfo* byValInfo, Op bytecode, PutKind putKind, const Identifier&amp; propertyName, JumpList&amp; doneCases, JumpList&amp; slowCases)
 422 {
 423     // base: tag(regT1), payload(regT0)
 424     // property: tag(regT3), payload(regT2)
 425 
<span class="line-modified"> 426     int base = bytecode.m_base.offset();</span>
<span class="line-modified"> 427     int value = bytecode.m_value.offset();</span>
 428 
 429     slowCases.append(branchIfNotCell(regT3));
 430     emitByValIdentifierCheck(byValInfo, regT2, regT2, propertyName, slowCases);
 431 
 432     // Write barrier breaks the registers. So after issuing the write barrier,
 433     // reload the registers.
 434     emitWriteBarrier(base, value, ShouldFilterBase);
 435     emitLoadPayload(base, regT0);
 436     emitLoad(value, regT3, regT2);
 437 
<span class="line-removed"> 438     const Instruction* currentInstruction = m_codeBlock-&gt;instructions().at(byValInfo-&gt;bytecodeIndex).ptr();</span>
 439     JITPutByIdGenerator gen(
<span class="line-modified"> 440         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(currentInstruction), RegisterSet::stubUnavailableRegisters(),</span>
 441         JSValueRegs::payloadOnly(regT0), JSValueRegs(regT3, regT2), regT1, m_codeBlock-&gt;ecmaMode(), putKind);
 442     gen.generateFastPath(*this);
 443     doneCases.append(jump());
 444 
 445     Label coldPathBegin = label();
 446     gen.slowPathJump().link(this);
 447 
 448     // JITPutByIdGenerator only preserve the value and the base&#39;s payload, we have to reload the tag.
 449     emitLoadTag(base, regT1);
 450 
<span class="line-modified"> 451     Call call = callOperation(gen.slowPathFunction(), gen.stubInfo(), JSValueRegs(regT3, regT2), JSValueRegs(regT1, regT0), propertyName.impl());</span>
 452     gen.reportSlowPathCall(coldPathBegin, call);
 453     doneCases.append(jump());
 454 
 455     return gen;
 456 }
 457 
 458 void JIT::emitSlow_op_put_by_val(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 459 {
 460     bool isDirect = currentInstruction-&gt;opcodeID() == op_put_by_val_direct;
<span class="line-modified"> 461     int base;</span>
<span class="line-modified"> 462     int property;</span>
<span class="line-modified"> 463     int value;</span>
 464 
 465     auto load = [&amp;](auto bytecode) {
<span class="line-modified"> 466         base = bytecode.m_base.offset();</span>
<span class="line-modified"> 467         property = bytecode.m_property.offset();</span>
<span class="line-modified"> 468         value = bytecode.m_value.offset();</span>
 469     };
 470 
 471     if (isDirect)
 472         load(currentInstruction-&gt;as&lt;OpPutByValDirect&gt;());
 473     else
 474         load(currentInstruction-&gt;as&lt;OpPutByVal&gt;());
 475 
 476     ByValInfo* byValInfo = m_byValCompilationInfo[m_byValInstructionIndex].byValInfo;
 477 
 478     linkAllSlowCases(iter);
 479     Label slowPath = label();
 480 
 481     // The register selection below is chosen to reduce register swapping on ARM.
 482     // Swapping shouldn&#39;t happen on other platforms.
 483     emitLoad(base, regT2, regT1);
 484     emitLoad(property, regT3, regT0);
 485     emitLoad(value, regT5, regT4);
<span class="line-modified"> 486     Call call = callOperation(isDirect ? operationDirectPutByValOptimize : operationPutByValOptimize, JSValueRegs(regT2, regT1), JSValueRegs(regT3, regT0), JSValueRegs(regT5, regT4), byValInfo);</span>
 487 
 488     m_byValCompilationInfo[m_byValInstructionIndex].slowPathTarget = slowPath;
 489     m_byValCompilationInfo[m_byValInstructionIndex].returnAddress = call;
 490     m_byValInstructionIndex++;
 491 }
 492 
 493 void JIT::emit_op_try_get_by_id(const Instruction* currentInstruction)
 494 {
 495     auto bytecode = currentInstruction-&gt;as&lt;OpTryGetById&gt;();
<span class="line-modified"> 496     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified"> 497     int base = bytecode.m_base.offset();</span>
 498     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 499 
 500     emitLoad(base, regT1, regT0);
 501     emitJumpSlowCaseIfNotJSCell(base, regT1);
 502 
 503     JITGetByIdGenerator gen(
<span class="line-modified"> 504         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(currentInstruction), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified"> 505         ident-&gt;impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0), AccessType::TryGet);</span>
 506     gen.generateFastPath(*this);
 507     addSlowCase(gen.slowPathJump());
 508     m_getByIds.append(gen);
 509 
 510     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
 511     emitStore(dst, regT1, regT0);
 512 }
 513 
 514 void JIT::emitSlow_op_try_get_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 515 {
 516     linkAllSlowCases(iter);
 517 
 518     auto bytecode = currentInstruction-&gt;as&lt;OpTryGetById&gt;();
<span class="line-modified"> 519     int resultVReg = bytecode.m_dst.offset();</span>
 520     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 521 
 522     JITGetByIdGenerator&amp; gen = m_getByIds[m_getByIdIndex++];
 523 
 524     Label coldPathBegin = label();
 525 
<span class="line-modified"> 526     Call call = callOperation(operationTryGetByIdOptimize, resultVReg, gen.stubInfo(), JSValueRegs(regT1, regT0), ident-&gt;impl());</span>
 527 
 528     gen.reportSlowPathCall(coldPathBegin, call);
 529 }
 530 
 531 
 532 void JIT::emit_op_get_by_id_direct(const Instruction* currentInstruction)
 533 {
 534     auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdDirect&gt;();
<span class="line-modified"> 535     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified"> 536     int base = bytecode.m_base.offset();</span>
 537     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 538 
 539     emitLoad(base, regT1, regT0);
 540     emitJumpSlowCaseIfNotJSCell(base, regT1);
 541 
 542     JITGetByIdGenerator gen(
<span class="line-modified"> 543         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(currentInstruction), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified"> 544         ident-&gt;impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0), AccessType::GetDirect);</span>
 545     gen.generateFastPath(*this);
 546     addSlowCase(gen.slowPathJump());
 547     m_getByIds.append(gen);
 548 
 549     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
 550     emitStore(dst, regT1, regT0);
 551 }
 552 
 553 void JIT::emitSlow_op_get_by_id_direct(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 554 {
 555     linkAllSlowCases(iter);
 556 
 557     auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdDirect&gt;();
<span class="line-modified"> 558     int resultVReg = bytecode.m_dst.offset();</span>
 559     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 560 
 561     JITGetByIdGenerator&amp; gen = m_getByIds[m_getByIdIndex++];
 562 
 563     Label coldPathBegin = label();
 564 
<span class="line-modified"> 565     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdDirectOptimize, resultVReg, gen.stubInfo(), JSValueRegs(regT1, regT0), ident-&gt;impl());</span>
 566 
 567     gen.reportSlowPathCall(coldPathBegin, call);
 568 }
 569 
 570 
 571 void JIT::emit_op_get_by_id(const Instruction* currentInstruction)
 572 {
 573     auto bytecode = currentInstruction-&gt;as&lt;OpGetById&gt;();
 574     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified"> 575     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified"> 576     int base = bytecode.m_base.offset();</span>
 577     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 578 
 579     emitLoad(base, regT1, regT0);
 580     emitJumpSlowCaseIfNotJSCell(base, regT1);
 581 
 582     if (*ident == m_vm-&gt;propertyNames-&gt;length &amp;&amp; shouldEmitProfiling()) {
 583         Jump notArrayLengthMode = branch8(NotEqual, AbsoluteAddress(&amp;metadata.m_modeMetadata.mode), TrustedImm32(static_cast&lt;uint8_t&gt;(GetByIdMode::ArrayLength)));
 584         emitArrayProfilingSiteWithCell(regT0, regT2, &amp;metadata.m_modeMetadata.arrayLengthMode.arrayProfile);
 585         notArrayLengthMode.link(this);
 586     }
 587 
 588     JITGetByIdGenerator gen(
<span class="line-modified"> 589         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(currentInstruction), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified"> 590         ident-&gt;impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0), AccessType::Get);</span>
 591     gen.generateFastPath(*this);
 592     addSlowCase(gen.slowPathJump());
 593     m_getByIds.append(gen);
 594 
 595     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
 596     emitStore(dst, regT1, regT0);
 597 }
 598 
 599 void JIT::emitSlow_op_get_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 600 {
 601     linkAllSlowCases(iter);
 602 
 603     auto bytecode = currentInstruction-&gt;as&lt;OpGetById&gt;();
<span class="line-modified"> 604     int resultVReg = bytecode.m_dst.offset();</span>
 605     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 606 
 607     JITGetByIdGenerator&amp; gen = m_getByIds[m_getByIdIndex++];
 608 
 609     Label coldPathBegin = label();
 610 
<span class="line-modified"> 611     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdOptimize, resultVReg, gen.stubInfo(), JSValueRegs(regT1, regT0), ident-&gt;impl());</span>
 612 
 613     gen.reportSlowPathCall(coldPathBegin, call);
 614 }
 615 
 616 void JIT::emit_op_get_by_id_with_this(const Instruction* currentInstruction)
 617 {
 618     auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdWithThis&gt;();
<span class="line-modified"> 619     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified"> 620     int base = bytecode.m_base.offset();</span>
<span class="line-modified"> 621     int thisVReg = bytecode.m_thisValue.offset();</span>
 622     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 623 
 624     emitLoad(base, regT1, regT0);
 625     emitLoad(thisVReg, regT4, regT3);
 626     emitJumpSlowCaseIfNotJSCell(base, regT1);
 627     emitJumpSlowCaseIfNotJSCell(thisVReg, regT4);
 628 
 629     JITGetByIdWithThisGenerator gen(
<span class="line-modified"> 630         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(currentInstruction), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified"> 631         ident-&gt;impl(), JSValueRegs(regT1, regT0), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT4, regT3), AccessType::GetWithThis);</span>
 632     gen.generateFastPath(*this);
 633     addSlowCase(gen.slowPathJump());
 634     m_getByIdsWithThis.append(gen);
 635 
 636     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
 637     emitStore(dst, regT1, regT0);
 638 }
 639 
 640 void JIT::emitSlow_op_get_by_id_with_this(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 641 {
 642     linkAllSlowCases(iter);
 643 
 644     auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdWithThis&gt;();
<span class="line-modified"> 645     int resultVReg = bytecode.m_dst.offset();</span>
 646     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 647 
 648     JITGetByIdWithThisGenerator&amp; gen = m_getByIdsWithThis[m_getByIdWithThisIndex++];
 649 
 650     Label coldPathBegin = label();
 651 
<span class="line-modified"> 652     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdWithThisOptimize, resultVReg, gen.stubInfo(), JSValueRegs(regT1, regT0), JSValueRegs(regT4, regT3), ident-&gt;impl());</span>
 653 
 654     gen.reportSlowPathCall(coldPathBegin, call);
 655 }
 656 
 657 void JIT::emit_op_put_by_id(const Instruction* currentInstruction)
 658 {
 659     // In order to be able to patch both the Structure, and the object offset, we store one pointer,
 660     // to just after the arguments have been loaded into registers &#39;hotPathBegin&#39;, and we generate code
 661     // such that the Structure &amp; offset are always at the same distance from this.
 662 
 663     auto bytecode = currentInstruction-&gt;as&lt;OpPutById&gt;();
<span class="line-modified"> 664     int base = bytecode.m_base.offset();</span>
<span class="line-modified"> 665     int value = bytecode.m_value.offset();</span>
 666     bool direct = !!(bytecode.m_flags &amp; PutByIdIsDirect);
 667 
 668     emitLoad2(base, regT1, regT0, value, regT3, regT2);
 669 
 670     emitJumpSlowCaseIfNotJSCell(base, regT1);
 671 
 672     JITPutByIdGenerator gen(
<span class="line-modified"> 673         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(currentInstruction), RegisterSet::stubUnavailableRegisters(),</span>
 674         JSValueRegs::payloadOnly(regT0), JSValueRegs(regT3, regT2),
 675         regT1, m_codeBlock-&gt;ecmaMode(), direct ? Direct : NotDirect);
 676 
 677     gen.generateFastPath(*this);
 678     addSlowCase(gen.slowPathJump());
 679 
 680     emitWriteBarrier(base, value, ShouldFilterBase);
 681 
 682     m_putByIds.append(gen);
 683 }
 684 
 685 void JIT::emitSlow_op_put_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 686 {
 687     linkAllSlowCases(iter);
 688 
 689     auto bytecode = currentInstruction-&gt;as&lt;OpPutById&gt;();
<span class="line-modified"> 690     int base = bytecode.m_base.offset();</span>
 691     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 692 
 693     Label coldPathBegin(this);
 694 
 695     // JITPutByIdGenerator only preserve the value and the base&#39;s payload, we have to reload the tag.
 696     emitLoadTag(base, regT1);
 697 
 698     JITPutByIdGenerator&amp; gen = m_putByIds[m_putByIdIndex++];
 699 
 700     Call call = callOperation(
<span class="line-modified"> 701         gen.slowPathFunction(), gen.stubInfo(), JSValueRegs(regT3, regT2), JSValueRegs(regT1, regT0), ident-&gt;impl());</span>
 702 
 703     gen.reportSlowPathCall(coldPathBegin, call);
 704 }
 705 
 706 void JIT::emit_op_in_by_id(const Instruction* currentInstruction)
 707 {
 708     auto bytecode = currentInstruction-&gt;as&lt;OpInById&gt;();
<span class="line-modified"> 709     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified"> 710     int base = bytecode.m_base.offset();</span>
 711     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 712 
 713     emitLoad(base, regT1, regT0);
 714     emitJumpSlowCaseIfNotJSCell(base, regT1);
 715 
 716     JITInByIdGenerator gen(
<span class="line-modified"> 717         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(currentInstruction), RegisterSet::stubUnavailableRegisters(),</span>
 718         ident-&gt;impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0));
 719     gen.generateFastPath(*this);
 720     addSlowCase(gen.slowPathJump());
 721     m_inByIds.append(gen);
 722 
 723     emitStore(dst, regT1, regT0);
 724 }
 725 
 726 void JIT::emitSlow_op_in_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 727 {
 728     linkAllSlowCases(iter);
 729 
 730     auto bytecode = currentInstruction-&gt;as&lt;OpInById&gt;();
<span class="line-modified"> 731     int resultVReg = bytecode.m_dst.offset();</span>
 732     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 733 
 734     JITInByIdGenerator&amp; gen = m_inByIds[m_inByIdIndex++];
 735 
 736     Label coldPathBegin = label();
 737 
<span class="line-modified"> 738     Call call = callOperation(operationInByIdOptimize, resultVReg, gen.stubInfo(), JSValueRegs(regT1, regT0), ident-&gt;impl());</span>
 739 
 740     gen.reportSlowPathCall(coldPathBegin, call);
 741 }
 742 
 743 void JIT::emitVarInjectionCheck(bool needsVarInjectionChecks)
 744 {
 745     if (!needsVarInjectionChecks)
 746         return;
 747     addSlowCase(branch8(Equal, AbsoluteAddress(m_codeBlock-&gt;globalObject()-&gt;varInjectionWatchpoint()-&gt;addressOfState()), TrustedImm32(IsInvalidated)));
 748 }
 749 
<span class="line-modified"> 750 void JIT::emitResolveClosure(int dst, int scope, bool needsVarInjectionChecks, unsigned depth)</span>
 751 {
 752     emitVarInjectionCheck(needsVarInjectionChecks);
 753     move(TrustedImm32(JSValue::CellTag), regT1);
 754     emitLoadPayload(scope, regT0);
 755     for (unsigned i = 0; i &lt; depth; ++i)
 756         loadPtr(Address(regT0, JSScope::offsetOfNext()), regT0);
 757     emitStore(dst, regT1, regT0);
 758 }
 759 
 760 void JIT::emit_op_resolve_scope(const Instruction* currentInstruction)
 761 {
 762     auto bytecode = currentInstruction-&gt;as&lt;OpResolveScope&gt;();
 763     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified"> 764     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified"> 765     int scope = bytecode.m_scope.offset();</span>
 766     ResolveType resolveType = metadata.m_resolveType;
 767     unsigned depth = metadata.m_localScopeDepth;
 768 
 769     auto emitCode = [&amp;] (ResolveType resolveType) {
 770         switch (resolveType) {
 771         case GlobalProperty:
 772         case GlobalPropertyWithVarInjectionChecks: {
 773             JSScope* constantScope = JSScope::constantScopeForCodeBlock(resolveType, m_codeBlock);
 774             RELEASE_ASSERT(constantScope);
 775             emitVarInjectionCheck(needsVarInjectionChecks(resolveType));
 776             load32(&amp;metadata.m_globalLexicalBindingEpoch, regT1);
 777             addSlowCase(branch32(NotEqual, AbsoluteAddress(m_codeBlock-&gt;globalObject()-&gt;addressOfGlobalLexicalBindingEpoch()), regT1));
 778             move(TrustedImm32(JSValue::CellTag), regT1);
 779             move(TrustedImmPtr(constantScope), regT0);
 780             emitStore(dst, regT1, regT0);
 781             break;
 782         }
 783 
 784         case GlobalVar:
 785         case GlobalVarWithVarInjectionChecks:
</pre>
<hr />
<pre>
 846         emitCode(GlobalLexicalVar);
 847         skipToEnd.append(jump());
 848         notGlobalLexicalVar.link(this);
 849 
 850         Jump notGlobalLexicalVarWithVarInjections = branch32(NotEqual, regT0, TrustedImm32(GlobalLexicalVarWithVarInjectionChecks));
 851         emitCode(GlobalLexicalVarWithVarInjectionChecks);
 852         skipToEnd.append(jump());
 853         notGlobalLexicalVarWithVarInjections.link(this);
 854 
 855         addSlowCase(jump());
 856         skipToEnd.link(this);
 857         break;
 858     }
 859 
 860     default:
 861         emitCode(resolveType);
 862         break;
 863     }
 864 }
 865 
<span class="line-modified"> 866 void JIT::emitLoadWithStructureCheck(int scope, Structure** structureSlot)</span>
 867 {
 868     emitLoad(scope, regT1, regT0);
 869     loadPtr(structureSlot, regT2);
 870     addSlowCase(branchPtr(NotEqual, Address(regT0, JSCell::structureIDOffset()), regT2));
 871 }
 872 
 873 void JIT::emitGetVarFromPointer(JSValue* operand, GPRReg tag, GPRReg payload)
 874 {
 875     uintptr_t rawAddress = bitwise_cast&lt;uintptr_t&gt;(operand);
 876     load32(bitwise_cast&lt;void*&gt;(rawAddress + TagOffset), tag);
 877     load32(bitwise_cast&lt;void*&gt;(rawAddress + PayloadOffset), payload);
 878 }
 879 void JIT::emitGetVarFromIndirectPointer(JSValue** operand, GPRReg tag, GPRReg payload)
 880 {
 881     loadPtr(operand, payload);
 882     load32(Address(payload, TagOffset), tag);
 883     load32(Address(payload, PayloadOffset), payload);
 884 }
 885 
<span class="line-modified"> 886 void JIT::emitGetClosureVar(int scope, uintptr_t operand)</span>
 887 {
 888     emitLoad(scope, regT1, regT0);
 889     load32(Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register) + TagOffset), regT1);
 890     load32(Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register) + PayloadOffset), regT0);
 891 }
 892 
 893 void JIT::emit_op_get_from_scope(const Instruction* currentInstruction)
 894 {
 895     auto bytecode = currentInstruction-&gt;as&lt;OpGetFromScope&gt;();
 896     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified"> 897     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified"> 898     int scope = bytecode.m_scope.offset();</span>
 899     ResolveType resolveType = metadata.m_getPutInfo.resolveType();
 900     Structure** structureSlot = metadata.m_structure.slot();
 901     uintptr_t* operandSlot = reinterpret_cast&lt;uintptr_t*&gt;(&amp;metadata.m_operand);
 902 
 903     auto emitCode = [&amp;] (ResolveType resolveType, bool indirectLoadForOperand) {
 904         switch (resolveType) {
 905         case GlobalProperty:
 906         case GlobalPropertyWithVarInjectionChecks: {
 907             emitLoadWithStructureCheck(scope, structureSlot); // Structure check covers var injection.
 908             GPRReg base = regT2;
 909             GPRReg resultTag = regT1;
 910             GPRReg resultPayload = regT0;
 911             GPRReg offset = regT3;
 912 
 913             move(regT0, base);
 914             load32(operandSlot, offset);
<span class="line-modified"> 915             if (!ASSERT_DISABLED) {</span>
 916                 Jump isOutOfLine = branch32(GreaterThanOrEqual, offset, TrustedImm32(firstOutOfLineOffset));
 917                 abortWithReason(JITOffsetIsNotOutOfLine);
 918                 isOutOfLine.link(this);
 919             }
 920             loadPtr(Address(base, JSObject::butterflyOffset()), base);
 921             neg32(offset);
 922             load32(BaseIndex(base, offset, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload) + (firstOutOfLineOffset - 2) * sizeof(EncodedJSValue)), resultPayload);
 923             load32(BaseIndex(base, offset, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag) + (firstOutOfLineOffset - 2) * sizeof(EncodedJSValue)), resultTag);
 924             break;
 925         }
 926         case GlobalVar:
 927         case GlobalVarWithVarInjectionChecks:
 928         case GlobalLexicalVar:
 929         case GlobalLexicalVarWithVarInjectionChecks:
 930             emitVarInjectionCheck(needsVarInjectionChecks(resolveType));
 931             if (indirectLoadForOperand)
 932                 emitGetVarFromIndirectPointer(bitwise_cast&lt;JSValue**&gt;(operandSlot), regT1, regT0);
 933             else
 934                 emitGetVarFromPointer(bitwise_cast&lt;JSValue*&gt;(*operandSlot), regT1, regT0);
 935             if (resolveType == GlobalLexicalVar || resolveType == GlobalLexicalVarWithVarInjectionChecks) // TDZ check.
</pre>
<hr />
<pre>
 992 
 993         addSlowCase(jump());
 994 
 995         skipToEnd.link(this);
 996         break;
 997     }
 998 
 999     default:
1000         emitCode(resolveType, false);
1001         break;
1002     }
1003     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
1004     emitStore(dst, regT1, regT0);
1005 }
1006 
1007 void JIT::emitSlow_op_get_from_scope(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
1008 {
1009     linkAllSlowCases(iter);
1010 
1011     auto bytecode = currentInstruction-&gt;as&lt;OpGetFromScope&gt;();
<span class="line-modified">1012     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">1013     callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetFromScope, dst, currentInstruction);</span>
1014 }
1015 
<span class="line-modified">1016 void JIT::emitPutGlobalVariable(JSValue* operand, int value, WatchpointSet* set)</span>
1017 {
1018     emitLoad(value, regT1, regT0);
1019     emitNotifyWrite(set);
1020     uintptr_t rawAddress = bitwise_cast&lt;uintptr_t&gt;(operand);
1021     store32(regT1, bitwise_cast&lt;void*&gt;(rawAddress + TagOffset));
1022     store32(regT0, bitwise_cast&lt;void*&gt;(rawAddress + PayloadOffset));
1023 }
1024 
<span class="line-modified">1025 void JIT::emitPutGlobalVariableIndirect(JSValue** addressOfOperand, int value, WatchpointSet** indirectWatchpointSet)</span>
1026 {
1027     emitLoad(value, regT1, regT0);
1028     loadPtr(indirectWatchpointSet, regT2);
1029     emitNotifyWrite(regT2);
1030     loadPtr(addressOfOperand, regT2);
1031     store32(regT1, Address(regT2, TagOffset));
1032     store32(regT0, Address(regT2, PayloadOffset));
1033 }
1034 
<span class="line-modified">1035 void JIT::emitPutClosureVar(int scope, uintptr_t operand, int value, WatchpointSet* set)</span>
1036 {
1037     emitLoad(value, regT3, regT2);
1038     emitLoad(scope, regT1, regT0);
1039     emitNotifyWrite(set);
1040     store32(regT3, Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register) + TagOffset));
1041     store32(regT2, Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register) + PayloadOffset));
1042 }
1043 
1044 void JIT::emit_op_put_to_scope(const Instruction* currentInstruction)
1045 {
1046     auto bytecode = currentInstruction-&gt;as&lt;OpPutToScope&gt;();
1047     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">1048     int scope = bytecode.m_scope.offset();</span>
<span class="line-modified">1049     int value = bytecode.m_value.offset();</span>
1050     GetPutInfo getPutInfo = copiedGetPutInfo(bytecode);
1051     ResolveType resolveType = getPutInfo.resolveType();
1052     Structure** structureSlot = metadata.m_structure.slot();
1053     uintptr_t* operandSlot = reinterpret_cast&lt;uintptr_t*&gt;(&amp;metadata.m_operand);
1054 
1055     auto emitCode = [&amp;] (ResolveType resolveType, bool indirectLoadForOperand) {
1056         switch (resolveType) {
1057         case GlobalProperty:
1058         case GlobalPropertyWithVarInjectionChecks: {
1059             emitWriteBarrier(m_codeBlock-&gt;globalObject(), value, ShouldFilterValue);
1060             emitLoadWithStructureCheck(scope, structureSlot); // Structure check covers var injection.
1061             emitLoad(value, regT3, regT2);
1062 
1063             loadPtr(Address(regT0, JSObject::butterflyOffset()), regT0);
1064             loadPtr(operandSlot, regT1);
1065             negPtr(regT1);
1066             store32(regT3, BaseIndex(regT0, regT1, TimesEight, (firstOutOfLineOffset - 2) * sizeof(EncodedJSValue) + OBJECT_OFFSETOF(EncodedValueDescriptor, asBits.tag)));
1067             store32(regT2, BaseIndex(regT0, regT1, TimesEight, (firstOutOfLineOffset - 2) * sizeof(EncodedJSValue) + OBJECT_OFFSETOF(EncodedValueDescriptor, asBits.payload)));
1068             break;
1069         }
</pre>
<hr />
<pre>
1154         skipToEnd.link(this);
1155         break;
1156     }
1157 
1158     default:
1159         emitCode(resolveType, false);
1160         break;
1161     }
1162 }
1163 
1164 void JIT::emitSlow_op_put_to_scope(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
1165 {
1166     linkAllSlowCases(iter);
1167 
1168     auto bytecode = currentInstruction-&gt;as&lt;OpPutToScope&gt;();
1169     ResolveType resolveType = copiedGetPutInfo(bytecode).resolveType();
1170     if (resolveType == ModuleVar) {
1171         JITSlowPathCall slowPathCall(this, currentInstruction, slow_path_throw_strict_mode_readonly_property_write_error);
1172         slowPathCall.call();
1173     } else
<span class="line-modified">1174         callOperation(operationPutToScope, currentInstruction);</span>
1175 }
1176 
1177 void JIT::emit_op_get_from_arguments(const Instruction* currentInstruction)
1178 {
1179     auto bytecode = currentInstruction-&gt;as&lt;OpGetFromArguments&gt;();
<span class="line-modified">1180     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">1181     int arguments = bytecode.m_arguments.offset();</span>
1182     int index = bytecode.m_index;
1183 
1184     emitLoadPayload(arguments, regT0);
1185     load32(Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;) + TagOffset), regT1);
1186     load32(Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;) + PayloadOffset), regT0);
1187     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
1188     emitStore(dst, regT1, regT0);
1189 }
1190 
1191 void JIT::emit_op_put_to_arguments(const Instruction* currentInstruction)
1192 {
1193     auto bytecode = currentInstruction-&gt;as&lt;OpPutToArguments&gt;();
<span class="line-modified">1194     int arguments = bytecode.m_arguments.offset();</span>
1195     int index = bytecode.m_index;
<span class="line-modified">1196     int value = bytecode.m_value.offset();</span>
1197 
1198     emitWriteBarrier(arguments, value, ShouldFilterValue);
1199 
1200     emitLoadPayload(arguments, regT0);
1201     emitLoad(value, regT1, regT2);
1202     store32(regT1, Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;) + TagOffset));
1203     store32(regT2, Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;) + PayloadOffset));
1204 }
1205 





























1206 } // namespace JSC
1207 
1208 #endif // USE(JSVALUE32_64)
1209 #endif // ENABLE(JIT)
</pre>
</td>
<td>
<hr />
<pre>
  33 #include &quot;DirectArguments.h&quot;
  34 #include &quot;GCAwareJITStubRoutine.h&quot;
  35 #include &quot;InterpreterInlines.h&quot;
  36 #include &quot;JITInlines.h&quot;
  37 #include &quot;JSArray.h&quot;
  38 #include &quot;JSFunction.h&quot;
  39 #include &quot;JSLexicalEnvironment.h&quot;
  40 #include &quot;LinkBuffer.h&quot;
  41 #include &quot;OpcodeInlines.h&quot;
  42 #include &quot;ResultType.h&quot;
  43 #include &quot;SlowPathCall.h&quot;
  44 #include &quot;StructureStubInfo.h&quot;
  45 #include &lt;wtf/StringPrintStream.h&gt;
  46 
  47 
  48 namespace JSC {
  49 
  50 void JIT::emit_op_put_getter_by_id(const Instruction* currentInstruction)
  51 {
  52     auto bytecode = currentInstruction-&gt;as&lt;OpPutGetterById&gt;();
<span class="line-modified">  53     VirtualRegister base = bytecode.m_base;</span>
  54     int property = bytecode.m_property;
  55     int options = bytecode.m_attributes;
<span class="line-modified">  56     VirtualRegister getter = bytecode.m_accessor;</span>
  57 
  58     emitLoadPayload(base, regT1);
  59     emitLoadPayload(getter, regT3);
<span class="line-modified">  60     callOperation(operationPutGetterById, m_codeBlock-&gt;globalObject(), regT1, m_codeBlock-&gt;identifier(property).impl(), options, regT3);</span>
  61 }
  62 
  63 void JIT::emit_op_put_setter_by_id(const Instruction* currentInstruction)
  64 {
  65     auto bytecode = currentInstruction-&gt;as&lt;OpPutSetterById&gt;();
<span class="line-modified">  66     VirtualRegister base = bytecode.m_base;</span>
  67     int property = bytecode.m_property;
  68     int options = bytecode.m_attributes;
<span class="line-modified">  69     VirtualRegister setter = bytecode.m_accessor;</span>
  70 
  71     emitLoadPayload(base, regT1);
  72     emitLoadPayload(setter, regT3);
<span class="line-modified">  73     callOperation(operationPutSetterById, m_codeBlock-&gt;globalObject(), regT1, m_codeBlock-&gt;identifier(property).impl(), options, regT3);</span>
  74 }
  75 
  76 void JIT::emit_op_put_getter_setter_by_id(const Instruction* currentInstruction)
  77 {
  78     auto bytecode = currentInstruction-&gt;as&lt;OpPutGetterSetterById&gt;();
<span class="line-modified">  79     VirtualRegister base = bytecode.m_base;</span>
  80     int property = bytecode.m_property;
  81     int attributes = bytecode.m_attributes;
<span class="line-modified">  82     VirtualRegister getter = bytecode.m_getter;</span>
<span class="line-modified">  83     VirtualRegister setter = bytecode.m_setter;</span>
  84 
  85     emitLoadPayload(base, regT1);
  86     emitLoadPayload(getter, regT3);
  87     emitLoadPayload(setter, regT4);
<span class="line-modified">  88     callOperation(operationPutGetterSetter, m_codeBlock-&gt;globalObject(), regT1, m_codeBlock-&gt;identifier(property).impl(), attributes, regT3, regT4);</span>
  89 }
  90 
  91 void JIT::emit_op_put_getter_by_val(const Instruction* currentInstruction)
  92 {
  93     auto bytecode = currentInstruction-&gt;as&lt;OpPutGetterByVal&gt;();
<span class="line-modified">  94     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified">  95     VirtualRegister property = bytecode.m_property;</span>
  96     int32_t attributes = bytecode.m_attributes;
<span class="line-modified">  97     VirtualRegister getter = bytecode.m_accessor;</span>
  98 
  99     emitLoadPayload(base, regT2);
 100     emitLoad(property, regT1, regT0);
 101     emitLoadPayload(getter, regT3);
<span class="line-modified"> 102     callOperation(operationPutGetterByVal, m_codeBlock-&gt;globalObject(), regT2, JSValueRegs(regT1, regT0), attributes, regT3);</span>
 103 }
 104 
 105 void JIT::emit_op_put_setter_by_val(const Instruction* currentInstruction)
 106 {
 107     auto bytecode = currentInstruction-&gt;as&lt;OpPutSetterByVal&gt;();
<span class="line-modified"> 108     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified"> 109     VirtualRegister property = bytecode.m_property;</span>
 110     int32_t attributes = bytecode.m_attributes;
<span class="line-modified"> 111     VirtualRegister setter = bytecode.m_accessor;</span>
 112 
 113     emitLoadPayload(base, regT2);
 114     emitLoad(property, regT1, regT0);
 115     emitLoadPayload(setter, regT3);
<span class="line-modified"> 116     callOperation(operationPutSetterByVal, m_codeBlock-&gt;globalObject(), regT2, JSValueRegs(regT1, regT0), attributes, regT3);</span>
 117 }
 118 
 119 void JIT::emit_op_del_by_id(const Instruction* currentInstruction)
 120 {
 121     auto bytecode = currentInstruction-&gt;as&lt;OpDelById&gt;();
<span class="line-modified"> 122     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified"> 123     VirtualRegister base = bytecode.m_base;</span>
 124     int property = bytecode.m_property;
 125     emitLoad(base, regT1, regT0);
<span class="line-modified"> 126     callOperation(operationDeleteByIdJSResult, dst, m_codeBlock-&gt;globalObject(), JSValueRegs(regT1, regT0), m_codeBlock-&gt;identifier(property).impl());</span>
 127 }
 128 
 129 void JIT::emit_op_del_by_val(const Instruction* currentInstruction)
 130 {
 131     auto bytecode = currentInstruction-&gt;as&lt;OpDelByVal&gt;();
<span class="line-modified"> 132     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified"> 133     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified"> 134     VirtualRegister property = bytecode.m_property;</span>
 135     emitLoad2(base, regT1, regT0, property, regT3, regT2);
<span class="line-modified"> 136     callOperation(operationDeleteByValJSResult, dst, m_codeBlock-&gt;globalObject(), JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));</span>
 137 }
 138 
 139 void JIT::emit_op_get_by_val(const Instruction* currentInstruction)
 140 {
 141     auto bytecode = currentInstruction-&gt;as&lt;OpGetByVal&gt;();
 142     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified"> 143     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified"> 144     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified"> 145     VirtualRegister property = bytecode.m_property;</span>
 146     ArrayProfile* profile = &amp;metadata.m_arrayProfile;

 147 
 148     emitLoad2(base, regT1, regT0, property, regT3, regT2);
 149 
<span class="line-modified"> 150     if (metadata.m_seenIdentifiers.count() &gt; Options::getByValICMaxNumberOfIdentifiers()) {</span>
<span class="line-modified"> 151         auto notCell = branchIfNotCell(regT1);</span>
<span class="line-modified"> 152         emitArrayProfilingSiteWithCell(regT0, regT4, profile);</span>
<span class="line-modified"> 153         notCell.link(this);</span>
<span class="line-modified"> 154         callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByVal, dst, TrustedImmPtr(m_codeBlock-&gt;globalObject()), JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));</span>
<span class="line-modified"> 155     } else {</span>
<span class="line-modified"> 156         emitJumpSlowCaseIfNotJSCell(base, regT1);</span>
<span class="line-modified"> 157         emitArrayProfilingSiteWithCell(regT0, regT4, profile);</span>
<span class="line-modified"> 158 </span>
<span class="line-modified"> 159         JITGetByValGenerator gen(</span>
<span class="line-modified"> 160             m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified"> 161             JSValueRegs::payloadOnly(regT0), JSValueRegs(regT3, regT2), JSValueRegs(regT1, regT0));</span>
<span class="line-modified"> 162         if (isOperandConstantInt(property))</span>
<span class="line-modified"> 163             gen.stubInfo()-&gt;propertyIsInt32 = true;</span>
<span class="line-modified"> 164         gen.generateFastPath(*this);</span>
<span class="line-modified"> 165         addSlowCase(gen.slowPathJump());</span>
<span class="line-modified"> 166         m_getByVals.append(gen);</span>
<span class="line-modified"> 167 </span>
<span class="line-modified"> 168         emitValueProfilingSite(bytecode.metadata(m_codeBlock));</span>
<span class="line-modified"> 169         emitStore(dst, regT1, regT0);</span>
















 170     }




































 171 }
 172 
 173 void JIT::emitSlow_op_get_by_val(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 174 {
<span class="line-modified"> 175     if (hasAnySlowCases(iter)) {</span>
<span class="line-modified"> 176         auto bytecode = currentInstruction-&gt;as&lt;OpGetByVal&gt;();</span>
<span class="line-modified"> 177         VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified"> 178         auto&amp; metadata = bytecode.metadata(m_codeBlock);</span>
<span class="line-modified"> 179         ArrayProfile* profile = &amp;metadata.m_arrayProfile;</span>



















 180 
<span class="line-modified"> 181         JITGetByValGenerator&amp; gen = m_getByVals[m_getByValIndex];</span>
<span class="line-modified"> 182         ++m_getByValIndex;</span>

 183 
<span class="line-modified"> 184         linkAllSlowCases(iter);</span>


 185 
<span class="line-modified"> 186         Label coldPathBegin = label();</span>
<span class="line-added"> 187         Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByValOptimize, dst, TrustedImmPtr(m_codeBlock-&gt;globalObject()), gen.stubInfo(), profile, JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));</span>
<span class="line-added"> 188         gen.reportSlowPathCall(coldPathBegin, call);</span>
<span class="line-added"> 189     }</span>
 190 }
 191 
 192 void JIT::emit_op_put_by_val_direct(const Instruction* currentInstruction)
 193 {
 194     emit_op_put_by_val&lt;OpPutByValDirect&gt;(currentInstruction);
 195 }
 196 
 197 template&lt;typename Op&gt;
 198 void JIT::emit_op_put_by_val(const Instruction* currentInstruction)
 199 {
 200     auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
 201     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified"> 202     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified"> 203     VirtualRegister property = bytecode.m_property;</span>
 204     ArrayProfile* profile = &amp;metadata.m_arrayProfile;
 205     ByValInfo* byValInfo = m_codeBlock-&gt;addByValInfo();
 206 
 207     emitLoad2(base, regT1, regT0, property, regT3, regT2);
 208 
 209     emitJumpSlowCaseIfNotJSCell(base, regT1);
 210     PatchableJump notIndex = patchableBranch32(NotEqual, regT3, TrustedImm32(JSValue::Int32Tag));
 211     addSlowCase(notIndex);
 212     emitArrayProfilingSiteWithCell(regT0, regT1, profile);
 213 
 214     PatchableJump badType;
 215     JumpList slowCases;
 216 
 217     // FIXME: Maybe we should do this inline?
 218     addSlowCase(branchTest32(NonZero, regT1, TrustedImm32(CopyOnWrite)));
 219     and32(TrustedImm32(IndexingShapeMask), regT1);
 220 
 221     JITArrayMode mode = chooseArrayMode(profile);
 222     switch (mode) {
 223     case JITInt32:
</pre>
<hr />
<pre>
 225         break;
 226     case JITDouble:
 227         slowCases = emitDoublePutByVal(bytecode, badType);
 228         break;
 229     case JITContiguous:
 230         slowCases = emitContiguousPutByVal(bytecode, badType);
 231         break;
 232     case JITArrayStorage:
 233         slowCases = emitArrayStoragePutByVal(bytecode, badType);
 234         break;
 235     default:
 236         CRASH();
 237         break;
 238     }
 239 
 240     addSlowCase(badType);
 241     addSlowCase(slowCases);
 242 
 243     Label done = label();
 244 
<span class="line-modified"> 245     m_byValCompilationInfo.append(ByValCompilationInfo(byValInfo, m_bytecodeIndex, notIndex, badType, mode, profile, done, done));</span>
 246 }
 247 
 248 template &lt;typename Op&gt;
 249 JIT::JumpList JIT::emitGenericContiguousPutByVal(Op bytecode, PatchableJump&amp; badType, IndexingType indexingShape)
 250 {
 251     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified"> 252     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified"> 253     VirtualRegister value = bytecode.m_value;</span>
 254     ArrayProfile* profile = &amp;metadata.m_arrayProfile;
 255 
 256     JumpList slowCases;
 257 
 258     badType = patchableBranch32(NotEqual, regT1, TrustedImm32(ContiguousShape));
 259 
 260     loadPtr(Address(regT0, JSObject::butterflyOffset()), regT3);
 261     Jump outOfBounds = branch32(AboveOrEqual, regT2, Address(regT3, Butterfly::offsetOfPublicLength()));
 262 
 263     Label storeResult = label();
 264     emitLoad(value, regT1, regT0);
 265     switch (indexingShape) {
 266     case Int32Shape:
 267         slowCases.append(branchIfNotInt32(regT1));
 268         store32(regT0, BaseIndex(regT3, regT2, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
 269         store32(regT1, BaseIndex(regT3, regT2, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
 270         break;
 271     case ContiguousShape:
 272         store32(regT0, BaseIndex(regT3, regT2, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
 273         store32(regT1, BaseIndex(regT3, regT2, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
</pre>
<hr />
<pre>
 293     Jump done = jump();
 294 
 295     outOfBounds.link(this);
 296     slowCases.append(branch32(AboveOrEqual, regT2, Address(regT3, Butterfly::offsetOfVectorLength())));
 297 
 298     emitArrayProfileStoreToHoleSpecialCase(profile);
 299 
 300     add32(TrustedImm32(1), regT2, regT1);
 301     store32(regT1, Address(regT3, Butterfly::offsetOfPublicLength()));
 302     jump().linkTo(storeResult, this);
 303 
 304     done.link(this);
 305 
 306     return slowCases;
 307 }
 308 
 309 template &lt;typename Op&gt;
 310 JIT::JumpList JIT::emitArrayStoragePutByVal(Op bytecode, PatchableJump&amp; badType)
 311 {
 312     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified"> 313     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified"> 314     VirtualRegister value = bytecode.m_value;</span>
 315     ArrayProfile* profile = &amp;metadata.m_arrayProfile;
 316 
 317     JumpList slowCases;
 318 
 319     badType = patchableBranch32(NotEqual, regT1, TrustedImm32(ArrayStorageShape));
 320 
 321     loadPtr(Address(regT0, JSObject::butterflyOffset()), regT3);
 322     slowCases.append(branch32(AboveOrEqual, regT2, Address(regT3, ArrayStorage::vectorLengthOffset())));
 323 
 324     Jump empty = branch32(Equal, BaseIndex(regT3, regT2, TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), TrustedImm32(JSValue::EmptyValueTag));
 325 
 326     Label storeResult(this);
 327     emitLoad(value, regT1, regT0);
 328     store32(regT0, BaseIndex(regT3, regT2, TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload))); // payload
 329     store32(regT1, BaseIndex(regT3, regT2, TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag))); // tag
 330     Jump end = jump();
 331 
 332     empty.link(this);
 333     emitArrayProfileStoreToHoleSpecialCase(profile);
 334     add32(TrustedImm32(1), Address(regT3, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
 335     branch32(Below, regT2, Address(regT3, ArrayStorage::lengthOffset())).linkTo(storeResult, this);
 336 
 337     add32(TrustedImm32(1), regT2, regT0);
 338     store32(regT0, Address(regT3, ArrayStorage::lengthOffset()));
 339     jump().linkTo(storeResult, this);
 340 
 341     end.link(this);
 342 
 343     emitWriteBarrier(base, value, ShouldFilterValue);
 344 
 345     return slowCases;
 346 }
 347 
 348 template &lt;typename Op&gt;
 349 JITPutByIdGenerator JIT::emitPutByValWithCachedId(ByValInfo* byValInfo, Op bytecode, PutKind putKind, const Identifier&amp; propertyName, JumpList&amp; doneCases, JumpList&amp; slowCases)
 350 {
 351     // base: tag(regT1), payload(regT0)
 352     // property: tag(regT3), payload(regT2)
 353 
<span class="line-modified"> 354     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified"> 355     VirtualRegister value = bytecode.m_value;</span>
 356 
 357     slowCases.append(branchIfNotCell(regT3));
 358     emitByValIdentifierCheck(byValInfo, regT2, regT2, propertyName, slowCases);
 359 
 360     // Write barrier breaks the registers. So after issuing the write barrier,
 361     // reload the registers.
 362     emitWriteBarrier(base, value, ShouldFilterBase);
 363     emitLoadPayload(base, regT0);
 364     emitLoad(value, regT3, regT2);
 365 

 366     JITPutByIdGenerator gen(
<span class="line-modified"> 367         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),</span>
 368         JSValueRegs::payloadOnly(regT0), JSValueRegs(regT3, regT2), regT1, m_codeBlock-&gt;ecmaMode(), putKind);
 369     gen.generateFastPath(*this);
 370     doneCases.append(jump());
 371 
 372     Label coldPathBegin = label();
 373     gen.slowPathJump().link(this);
 374 
 375     // JITPutByIdGenerator only preserve the value and the base&#39;s payload, we have to reload the tag.
 376     emitLoadTag(base, regT1);
 377 
<span class="line-modified"> 378     Call call = callOperation(gen.slowPathFunction(), m_codeBlock-&gt;globalObject(), gen.stubInfo(), JSValueRegs(regT3, regT2), JSValueRegs(regT1, regT0), propertyName.impl());</span>
 379     gen.reportSlowPathCall(coldPathBegin, call);
 380     doneCases.append(jump());
 381 
 382     return gen;
 383 }
 384 
 385 void JIT::emitSlow_op_put_by_val(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 386 {
 387     bool isDirect = currentInstruction-&gt;opcodeID() == op_put_by_val_direct;
<span class="line-modified"> 388     VirtualRegister base;</span>
<span class="line-modified"> 389     VirtualRegister property;</span>
<span class="line-modified"> 390     VirtualRegister value;</span>
 391 
 392     auto load = [&amp;](auto bytecode) {
<span class="line-modified"> 393         base = bytecode.m_base;</span>
<span class="line-modified"> 394         property = bytecode.m_property;</span>
<span class="line-modified"> 395         value = bytecode.m_value;</span>
 396     };
 397 
 398     if (isDirect)
 399         load(currentInstruction-&gt;as&lt;OpPutByValDirect&gt;());
 400     else
 401         load(currentInstruction-&gt;as&lt;OpPutByVal&gt;());
 402 
 403     ByValInfo* byValInfo = m_byValCompilationInfo[m_byValInstructionIndex].byValInfo;
 404 
 405     linkAllSlowCases(iter);
 406     Label slowPath = label();
 407 
 408     // The register selection below is chosen to reduce register swapping on ARM.
 409     // Swapping shouldn&#39;t happen on other platforms.
 410     emitLoad(base, regT2, regT1);
 411     emitLoad(property, regT3, regT0);
 412     emitLoad(value, regT5, regT4);
<span class="line-modified"> 413     Call call = callOperation(isDirect ? operationDirectPutByValOptimize : operationPutByValOptimize, m_codeBlock-&gt;globalObject(), JSValueRegs(regT2, regT1), JSValueRegs(regT3, regT0), JSValueRegs(regT5, regT4), byValInfo);</span>
 414 
 415     m_byValCompilationInfo[m_byValInstructionIndex].slowPathTarget = slowPath;
 416     m_byValCompilationInfo[m_byValInstructionIndex].returnAddress = call;
 417     m_byValInstructionIndex++;
 418 }
 419 
 420 void JIT::emit_op_try_get_by_id(const Instruction* currentInstruction)
 421 {
 422     auto bytecode = currentInstruction-&gt;as&lt;OpTryGetById&gt;();
<span class="line-modified"> 423     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified"> 424     VirtualRegister base = bytecode.m_base;</span>
 425     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 426 
 427     emitLoad(base, regT1, regT0);
 428     emitJumpSlowCaseIfNotJSCell(base, regT1);
 429 
 430     JITGetByIdGenerator gen(
<span class="line-modified"> 431         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified"> 432         ident-&gt;impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0), AccessType::TryGetById);</span>
 433     gen.generateFastPath(*this);
 434     addSlowCase(gen.slowPathJump());
 435     m_getByIds.append(gen);
 436 
 437     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
 438     emitStore(dst, regT1, regT0);
 439 }
 440 
 441 void JIT::emitSlow_op_try_get_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 442 {
 443     linkAllSlowCases(iter);
 444 
 445     auto bytecode = currentInstruction-&gt;as&lt;OpTryGetById&gt;();
<span class="line-modified"> 446     VirtualRegister resultVReg = bytecode.m_dst;</span>
 447     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 448 
 449     JITGetByIdGenerator&amp; gen = m_getByIds[m_getByIdIndex++];
 450 
 451     Label coldPathBegin = label();
 452 
<span class="line-modified"> 453     Call call = callOperation(operationTryGetByIdOptimize, resultVReg, m_codeBlock-&gt;globalObject(), gen.stubInfo(), JSValueRegs(regT1, regT0), ident-&gt;impl());</span>
 454 
 455     gen.reportSlowPathCall(coldPathBegin, call);
 456 }
 457 
 458 
 459 void JIT::emit_op_get_by_id_direct(const Instruction* currentInstruction)
 460 {
 461     auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdDirect&gt;();
<span class="line-modified"> 462     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified"> 463     VirtualRegister base = bytecode.m_base;</span>
 464     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 465 
 466     emitLoad(base, regT1, regT0);
 467     emitJumpSlowCaseIfNotJSCell(base, regT1);
 468 
 469     JITGetByIdGenerator gen(
<span class="line-modified"> 470         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified"> 471         ident-&gt;impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0), AccessType::GetByIdDirect);</span>
 472     gen.generateFastPath(*this);
 473     addSlowCase(gen.slowPathJump());
 474     m_getByIds.append(gen);
 475 
 476     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
 477     emitStore(dst, regT1, regT0);
 478 }
 479 
 480 void JIT::emitSlow_op_get_by_id_direct(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 481 {
 482     linkAllSlowCases(iter);
 483 
 484     auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdDirect&gt;();
<span class="line-modified"> 485     VirtualRegister resultVReg = bytecode.m_dst;</span>
 486     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 487 
 488     JITGetByIdGenerator&amp; gen = m_getByIds[m_getByIdIndex++];
 489 
 490     Label coldPathBegin = label();
 491 
<span class="line-modified"> 492     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdDirectOptimize, resultVReg, m_codeBlock-&gt;globalObject(), gen.stubInfo(), JSValueRegs(regT1, regT0), ident-&gt;impl());</span>
 493 
 494     gen.reportSlowPathCall(coldPathBegin, call);
 495 }
 496 
 497 
 498 void JIT::emit_op_get_by_id(const Instruction* currentInstruction)
 499 {
 500     auto bytecode = currentInstruction-&gt;as&lt;OpGetById&gt;();
 501     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified"> 502     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified"> 503     VirtualRegister base = bytecode.m_base;</span>
 504     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 505 
 506     emitLoad(base, regT1, regT0);
 507     emitJumpSlowCaseIfNotJSCell(base, regT1);
 508 
 509     if (*ident == m_vm-&gt;propertyNames-&gt;length &amp;&amp; shouldEmitProfiling()) {
 510         Jump notArrayLengthMode = branch8(NotEqual, AbsoluteAddress(&amp;metadata.m_modeMetadata.mode), TrustedImm32(static_cast&lt;uint8_t&gt;(GetByIdMode::ArrayLength)));
 511         emitArrayProfilingSiteWithCell(regT0, regT2, &amp;metadata.m_modeMetadata.arrayLengthMode.arrayProfile);
 512         notArrayLengthMode.link(this);
 513     }
 514 
 515     JITGetByIdGenerator gen(
<span class="line-modified"> 516         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified"> 517         ident-&gt;impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0), AccessType::GetById);</span>
 518     gen.generateFastPath(*this);
 519     addSlowCase(gen.slowPathJump());
 520     m_getByIds.append(gen);
 521 
 522     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
 523     emitStore(dst, regT1, regT0);
 524 }
 525 
 526 void JIT::emitSlow_op_get_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 527 {
 528     linkAllSlowCases(iter);
 529 
 530     auto bytecode = currentInstruction-&gt;as&lt;OpGetById&gt;();
<span class="line-modified"> 531     VirtualRegister resultVReg = bytecode.m_dst;</span>
 532     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 533 
 534     JITGetByIdGenerator&amp; gen = m_getByIds[m_getByIdIndex++];
 535 
 536     Label coldPathBegin = label();
 537 
<span class="line-modified"> 538     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdOptimize, resultVReg, m_codeBlock-&gt;globalObject(), gen.stubInfo(), JSValueRegs(regT1, regT0), ident-&gt;impl());</span>
 539 
 540     gen.reportSlowPathCall(coldPathBegin, call);
 541 }
 542 
 543 void JIT::emit_op_get_by_id_with_this(const Instruction* currentInstruction)
 544 {
 545     auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdWithThis&gt;();
<span class="line-modified"> 546     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified"> 547     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified"> 548     VirtualRegister thisVReg = bytecode.m_thisValue;</span>
 549     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 550 
 551     emitLoad(base, regT1, regT0);
 552     emitLoad(thisVReg, regT4, regT3);
 553     emitJumpSlowCaseIfNotJSCell(base, regT1);
 554     emitJumpSlowCaseIfNotJSCell(thisVReg, regT4);
 555 
 556     JITGetByIdWithThisGenerator gen(
<span class="line-modified"> 557         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified"> 558         ident-&gt;impl(), JSValueRegs(regT1, regT0), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT4, regT3));</span>
 559     gen.generateFastPath(*this);
 560     addSlowCase(gen.slowPathJump());
 561     m_getByIdsWithThis.append(gen);
 562 
 563     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
 564     emitStore(dst, regT1, regT0);
 565 }
 566 
 567 void JIT::emitSlow_op_get_by_id_with_this(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 568 {
 569     linkAllSlowCases(iter);
 570 
 571     auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdWithThis&gt;();
<span class="line-modified"> 572     VirtualRegister resultVReg = bytecode.m_dst;</span>
 573     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 574 
 575     JITGetByIdWithThisGenerator&amp; gen = m_getByIdsWithThis[m_getByIdWithThisIndex++];
 576 
 577     Label coldPathBegin = label();
 578 
<span class="line-modified"> 579     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdWithThisOptimize, resultVReg, m_codeBlock-&gt;globalObject(), gen.stubInfo(), JSValueRegs(regT1, regT0), JSValueRegs(regT4, regT3), ident-&gt;impl());</span>
 580 
 581     gen.reportSlowPathCall(coldPathBegin, call);
 582 }
 583 
 584 void JIT::emit_op_put_by_id(const Instruction* currentInstruction)
 585 {
 586     // In order to be able to patch both the Structure, and the object offset, we store one pointer,
 587     // to just after the arguments have been loaded into registers &#39;hotPathBegin&#39;, and we generate code
 588     // such that the Structure &amp; offset are always at the same distance from this.
 589 
 590     auto bytecode = currentInstruction-&gt;as&lt;OpPutById&gt;();
<span class="line-modified"> 591     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified"> 592     VirtualRegister value = bytecode.m_value;</span>
 593     bool direct = !!(bytecode.m_flags &amp; PutByIdIsDirect);
 594 
 595     emitLoad2(base, regT1, regT0, value, regT3, regT2);
 596 
 597     emitJumpSlowCaseIfNotJSCell(base, regT1);
 598 
 599     JITPutByIdGenerator gen(
<span class="line-modified"> 600         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),</span>
 601         JSValueRegs::payloadOnly(regT0), JSValueRegs(regT3, regT2),
 602         regT1, m_codeBlock-&gt;ecmaMode(), direct ? Direct : NotDirect);
 603 
 604     gen.generateFastPath(*this);
 605     addSlowCase(gen.slowPathJump());
 606 
 607     emitWriteBarrier(base, value, ShouldFilterBase);
 608 
 609     m_putByIds.append(gen);
 610 }
 611 
 612 void JIT::emitSlow_op_put_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 613 {
 614     linkAllSlowCases(iter);
 615 
 616     auto bytecode = currentInstruction-&gt;as&lt;OpPutById&gt;();
<span class="line-modified"> 617     VirtualRegister base = bytecode.m_base;</span>
 618     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 619 
 620     Label coldPathBegin(this);
 621 
 622     // JITPutByIdGenerator only preserve the value and the base&#39;s payload, we have to reload the tag.
 623     emitLoadTag(base, regT1);
 624 
 625     JITPutByIdGenerator&amp; gen = m_putByIds[m_putByIdIndex++];
 626 
 627     Call call = callOperation(
<span class="line-modified"> 628         gen.slowPathFunction(), m_codeBlock-&gt;globalObject(), gen.stubInfo(), JSValueRegs(regT3, regT2), JSValueRegs(regT1, regT0), ident-&gt;impl());</span>
 629 
 630     gen.reportSlowPathCall(coldPathBegin, call);
 631 }
 632 
 633 void JIT::emit_op_in_by_id(const Instruction* currentInstruction)
 634 {
 635     auto bytecode = currentInstruction-&gt;as&lt;OpInById&gt;();
<span class="line-modified"> 636     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified"> 637     VirtualRegister base = bytecode.m_base;</span>
 638     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 639 
 640     emitLoad(base, regT1, regT0);
 641     emitJumpSlowCaseIfNotJSCell(base, regT1);
 642 
 643     JITInByIdGenerator gen(
<span class="line-modified"> 644         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),</span>
 645         ident-&gt;impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0));
 646     gen.generateFastPath(*this);
 647     addSlowCase(gen.slowPathJump());
 648     m_inByIds.append(gen);
 649 
 650     emitStore(dst, regT1, regT0);
 651 }
 652 
 653 void JIT::emitSlow_op_in_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 654 {
 655     linkAllSlowCases(iter);
 656 
 657     auto bytecode = currentInstruction-&gt;as&lt;OpInById&gt;();
<span class="line-modified"> 658     VirtualRegister resultVReg = bytecode.m_dst;</span>
 659     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 660 
 661     JITInByIdGenerator&amp; gen = m_inByIds[m_inByIdIndex++];
 662 
 663     Label coldPathBegin = label();
 664 
<span class="line-modified"> 665     Call call = callOperation(operationInByIdOptimize, resultVReg, m_codeBlock-&gt;globalObject(), gen.stubInfo(), JSValueRegs(regT1, regT0), ident-&gt;impl());</span>
 666 
 667     gen.reportSlowPathCall(coldPathBegin, call);
 668 }
 669 
 670 void JIT::emitVarInjectionCheck(bool needsVarInjectionChecks)
 671 {
 672     if (!needsVarInjectionChecks)
 673         return;
 674     addSlowCase(branch8(Equal, AbsoluteAddress(m_codeBlock-&gt;globalObject()-&gt;varInjectionWatchpoint()-&gt;addressOfState()), TrustedImm32(IsInvalidated)));
 675 }
 676 
<span class="line-modified"> 677 void JIT::emitResolveClosure(VirtualRegister dst, VirtualRegister scope, bool needsVarInjectionChecks, unsigned depth)</span>
 678 {
 679     emitVarInjectionCheck(needsVarInjectionChecks);
 680     move(TrustedImm32(JSValue::CellTag), regT1);
 681     emitLoadPayload(scope, regT0);
 682     for (unsigned i = 0; i &lt; depth; ++i)
 683         loadPtr(Address(regT0, JSScope::offsetOfNext()), regT0);
 684     emitStore(dst, regT1, regT0);
 685 }
 686 
 687 void JIT::emit_op_resolve_scope(const Instruction* currentInstruction)
 688 {
 689     auto bytecode = currentInstruction-&gt;as&lt;OpResolveScope&gt;();
 690     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified"> 691     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified"> 692     VirtualRegister scope = bytecode.m_scope;</span>
 693     ResolveType resolveType = metadata.m_resolveType;
 694     unsigned depth = metadata.m_localScopeDepth;
 695 
 696     auto emitCode = [&amp;] (ResolveType resolveType) {
 697         switch (resolveType) {
 698         case GlobalProperty:
 699         case GlobalPropertyWithVarInjectionChecks: {
 700             JSScope* constantScope = JSScope::constantScopeForCodeBlock(resolveType, m_codeBlock);
 701             RELEASE_ASSERT(constantScope);
 702             emitVarInjectionCheck(needsVarInjectionChecks(resolveType));
 703             load32(&amp;metadata.m_globalLexicalBindingEpoch, regT1);
 704             addSlowCase(branch32(NotEqual, AbsoluteAddress(m_codeBlock-&gt;globalObject()-&gt;addressOfGlobalLexicalBindingEpoch()), regT1));
 705             move(TrustedImm32(JSValue::CellTag), regT1);
 706             move(TrustedImmPtr(constantScope), regT0);
 707             emitStore(dst, regT1, regT0);
 708             break;
 709         }
 710 
 711         case GlobalVar:
 712         case GlobalVarWithVarInjectionChecks:
</pre>
<hr />
<pre>
 773         emitCode(GlobalLexicalVar);
 774         skipToEnd.append(jump());
 775         notGlobalLexicalVar.link(this);
 776 
 777         Jump notGlobalLexicalVarWithVarInjections = branch32(NotEqual, regT0, TrustedImm32(GlobalLexicalVarWithVarInjectionChecks));
 778         emitCode(GlobalLexicalVarWithVarInjectionChecks);
 779         skipToEnd.append(jump());
 780         notGlobalLexicalVarWithVarInjections.link(this);
 781 
 782         addSlowCase(jump());
 783         skipToEnd.link(this);
 784         break;
 785     }
 786 
 787     default:
 788         emitCode(resolveType);
 789         break;
 790     }
 791 }
 792 
<span class="line-modified"> 793 void JIT::emitLoadWithStructureCheck(VirtualRegister scope, Structure** structureSlot)</span>
 794 {
 795     emitLoad(scope, regT1, regT0);
 796     loadPtr(structureSlot, regT2);
 797     addSlowCase(branchPtr(NotEqual, Address(regT0, JSCell::structureIDOffset()), regT2));
 798 }
 799 
 800 void JIT::emitGetVarFromPointer(JSValue* operand, GPRReg tag, GPRReg payload)
 801 {
 802     uintptr_t rawAddress = bitwise_cast&lt;uintptr_t&gt;(operand);
 803     load32(bitwise_cast&lt;void*&gt;(rawAddress + TagOffset), tag);
 804     load32(bitwise_cast&lt;void*&gt;(rawAddress + PayloadOffset), payload);
 805 }
 806 void JIT::emitGetVarFromIndirectPointer(JSValue** operand, GPRReg tag, GPRReg payload)
 807 {
 808     loadPtr(operand, payload);
 809     load32(Address(payload, TagOffset), tag);
 810     load32(Address(payload, PayloadOffset), payload);
 811 }
 812 
<span class="line-modified"> 813 void JIT::emitGetClosureVar(VirtualRegister scope, uintptr_t operand)</span>
 814 {
 815     emitLoad(scope, regT1, regT0);
 816     load32(Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register) + TagOffset), regT1);
 817     load32(Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register) + PayloadOffset), regT0);
 818 }
 819 
 820 void JIT::emit_op_get_from_scope(const Instruction* currentInstruction)
 821 {
 822     auto bytecode = currentInstruction-&gt;as&lt;OpGetFromScope&gt;();
 823     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified"> 824     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified"> 825     VirtualRegister scope = bytecode.m_scope;</span>
 826     ResolveType resolveType = metadata.m_getPutInfo.resolveType();
 827     Structure** structureSlot = metadata.m_structure.slot();
 828     uintptr_t* operandSlot = reinterpret_cast&lt;uintptr_t*&gt;(&amp;metadata.m_operand);
 829 
 830     auto emitCode = [&amp;] (ResolveType resolveType, bool indirectLoadForOperand) {
 831         switch (resolveType) {
 832         case GlobalProperty:
 833         case GlobalPropertyWithVarInjectionChecks: {
 834             emitLoadWithStructureCheck(scope, structureSlot); // Structure check covers var injection.
 835             GPRReg base = regT2;
 836             GPRReg resultTag = regT1;
 837             GPRReg resultPayload = regT0;
 838             GPRReg offset = regT3;
 839 
 840             move(regT0, base);
 841             load32(operandSlot, offset);
<span class="line-modified"> 842             if (ASSERT_ENABLED) {</span>
 843                 Jump isOutOfLine = branch32(GreaterThanOrEqual, offset, TrustedImm32(firstOutOfLineOffset));
 844                 abortWithReason(JITOffsetIsNotOutOfLine);
 845                 isOutOfLine.link(this);
 846             }
 847             loadPtr(Address(base, JSObject::butterflyOffset()), base);
 848             neg32(offset);
 849             load32(BaseIndex(base, offset, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload) + (firstOutOfLineOffset - 2) * sizeof(EncodedJSValue)), resultPayload);
 850             load32(BaseIndex(base, offset, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag) + (firstOutOfLineOffset - 2) * sizeof(EncodedJSValue)), resultTag);
 851             break;
 852         }
 853         case GlobalVar:
 854         case GlobalVarWithVarInjectionChecks:
 855         case GlobalLexicalVar:
 856         case GlobalLexicalVarWithVarInjectionChecks:
 857             emitVarInjectionCheck(needsVarInjectionChecks(resolveType));
 858             if (indirectLoadForOperand)
 859                 emitGetVarFromIndirectPointer(bitwise_cast&lt;JSValue**&gt;(operandSlot), regT1, regT0);
 860             else
 861                 emitGetVarFromPointer(bitwise_cast&lt;JSValue*&gt;(*operandSlot), regT1, regT0);
 862             if (resolveType == GlobalLexicalVar || resolveType == GlobalLexicalVarWithVarInjectionChecks) // TDZ check.
</pre>
<hr />
<pre>
 919 
 920         addSlowCase(jump());
 921 
 922         skipToEnd.link(this);
 923         break;
 924     }
 925 
 926     default:
 927         emitCode(resolveType, false);
 928         break;
 929     }
 930     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
 931     emitStore(dst, regT1, regT0);
 932 }
 933 
 934 void JIT::emitSlow_op_get_from_scope(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 935 {
 936     linkAllSlowCases(iter);
 937 
 938     auto bytecode = currentInstruction-&gt;as&lt;OpGetFromScope&gt;();
<span class="line-modified"> 939     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified"> 940     callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetFromScope, dst, m_codeBlock-&gt;globalObject(), currentInstruction);</span>
 941 }
 942 
<span class="line-modified"> 943 void JIT::emitPutGlobalVariable(JSValue* operand, VirtualRegister value, WatchpointSet* set)</span>
 944 {
 945     emitLoad(value, regT1, regT0);
 946     emitNotifyWrite(set);
 947     uintptr_t rawAddress = bitwise_cast&lt;uintptr_t&gt;(operand);
 948     store32(regT1, bitwise_cast&lt;void*&gt;(rawAddress + TagOffset));
 949     store32(regT0, bitwise_cast&lt;void*&gt;(rawAddress + PayloadOffset));
 950 }
 951 
<span class="line-modified"> 952 void JIT::emitPutGlobalVariableIndirect(JSValue** addressOfOperand, VirtualRegister value, WatchpointSet** indirectWatchpointSet)</span>
 953 {
 954     emitLoad(value, regT1, regT0);
 955     loadPtr(indirectWatchpointSet, regT2);
 956     emitNotifyWrite(regT2);
 957     loadPtr(addressOfOperand, regT2);
 958     store32(regT1, Address(regT2, TagOffset));
 959     store32(regT0, Address(regT2, PayloadOffset));
 960 }
 961 
<span class="line-modified"> 962 void JIT::emitPutClosureVar(VirtualRegister scope, uintptr_t operand, VirtualRegister value, WatchpointSet* set)</span>
 963 {
 964     emitLoad(value, regT3, regT2);
 965     emitLoad(scope, regT1, regT0);
 966     emitNotifyWrite(set);
 967     store32(regT3, Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register) + TagOffset));
 968     store32(regT2, Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register) + PayloadOffset));
 969 }
 970 
 971 void JIT::emit_op_put_to_scope(const Instruction* currentInstruction)
 972 {
 973     auto bytecode = currentInstruction-&gt;as&lt;OpPutToScope&gt;();
 974     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified"> 975     VirtualRegister scope = bytecode.m_scope;</span>
<span class="line-modified"> 976     VirtualRegister value = bytecode.m_value;</span>
 977     GetPutInfo getPutInfo = copiedGetPutInfo(bytecode);
 978     ResolveType resolveType = getPutInfo.resolveType();
 979     Structure** structureSlot = metadata.m_structure.slot();
 980     uintptr_t* operandSlot = reinterpret_cast&lt;uintptr_t*&gt;(&amp;metadata.m_operand);
 981 
 982     auto emitCode = [&amp;] (ResolveType resolveType, bool indirectLoadForOperand) {
 983         switch (resolveType) {
 984         case GlobalProperty:
 985         case GlobalPropertyWithVarInjectionChecks: {
 986             emitWriteBarrier(m_codeBlock-&gt;globalObject(), value, ShouldFilterValue);
 987             emitLoadWithStructureCheck(scope, structureSlot); // Structure check covers var injection.
 988             emitLoad(value, regT3, regT2);
 989 
 990             loadPtr(Address(regT0, JSObject::butterflyOffset()), regT0);
 991             loadPtr(operandSlot, regT1);
 992             negPtr(regT1);
 993             store32(regT3, BaseIndex(regT0, regT1, TimesEight, (firstOutOfLineOffset - 2) * sizeof(EncodedJSValue) + OBJECT_OFFSETOF(EncodedValueDescriptor, asBits.tag)));
 994             store32(regT2, BaseIndex(regT0, regT1, TimesEight, (firstOutOfLineOffset - 2) * sizeof(EncodedJSValue) + OBJECT_OFFSETOF(EncodedValueDescriptor, asBits.payload)));
 995             break;
 996         }
</pre>
<hr />
<pre>
1081         skipToEnd.link(this);
1082         break;
1083     }
1084 
1085     default:
1086         emitCode(resolveType, false);
1087         break;
1088     }
1089 }
1090 
1091 void JIT::emitSlow_op_put_to_scope(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
1092 {
1093     linkAllSlowCases(iter);
1094 
1095     auto bytecode = currentInstruction-&gt;as&lt;OpPutToScope&gt;();
1096     ResolveType resolveType = copiedGetPutInfo(bytecode).resolveType();
1097     if (resolveType == ModuleVar) {
1098         JITSlowPathCall slowPathCall(this, currentInstruction, slow_path_throw_strict_mode_readonly_property_write_error);
1099         slowPathCall.call();
1100     } else
<span class="line-modified">1101         callOperation(operationPutToScope, m_codeBlock-&gt;globalObject(), currentInstruction);</span>
1102 }
1103 
1104 void JIT::emit_op_get_from_arguments(const Instruction* currentInstruction)
1105 {
1106     auto bytecode = currentInstruction-&gt;as&lt;OpGetFromArguments&gt;();
<span class="line-modified">1107     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">1108     VirtualRegister arguments = bytecode.m_arguments;</span>
1109     int index = bytecode.m_index;
1110 
1111     emitLoadPayload(arguments, regT0);
1112     load32(Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;) + TagOffset), regT1);
1113     load32(Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;) + PayloadOffset), regT0);
1114     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
1115     emitStore(dst, regT1, regT0);
1116 }
1117 
1118 void JIT::emit_op_put_to_arguments(const Instruction* currentInstruction)
1119 {
1120     auto bytecode = currentInstruction-&gt;as&lt;OpPutToArguments&gt;();
<span class="line-modified">1121     VirtualRegister arguments = bytecode.m_arguments;</span>
1122     int index = bytecode.m_index;
<span class="line-modified">1123     VirtualRegister value = bytecode.m_value;</span>
1124 
1125     emitWriteBarrier(arguments, value, ShouldFilterValue);
1126 
1127     emitLoadPayload(arguments, regT0);
1128     emitLoad(value, regT1, regT2);
1129     store32(regT1, Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;) + TagOffset));
1130     store32(regT2, Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;) + PayloadOffset));
1131 }
1132 
<span class="line-added">1133 void JIT::emit_op_get_internal_field(const Instruction* currentInstruction)</span>
<span class="line-added">1134 {</span>
<span class="line-added">1135     auto bytecode = currentInstruction-&gt;as&lt;OpGetInternalField&gt;();</span>
<span class="line-added">1136     auto&amp; metadata = bytecode.metadata(m_codeBlock);</span>
<span class="line-added">1137     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-added">1138     VirtualRegister base = bytecode.m_base;</span>
<span class="line-added">1139     unsigned index = bytecode.m_index;</span>
<span class="line-added">1140 </span>
<span class="line-added">1141     emitLoadPayload(base, regT2);</span>
<span class="line-added">1142     load32(Address(regT2, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(index) + TagOffset), regT1);</span>
<span class="line-added">1143     load32(Address(regT2, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(index) + PayloadOffset), regT0);</span>
<span class="line-added">1144     emitValueProfilingSite(metadata);</span>
<span class="line-added">1145     emitStore(dst, regT1, regT0);</span>
<span class="line-added">1146 }</span>
<span class="line-added">1147 </span>
<span class="line-added">1148 void JIT::emit_op_put_internal_field(const Instruction* currentInstruction)</span>
<span class="line-added">1149 {</span>
<span class="line-added">1150     auto bytecode = currentInstruction-&gt;as&lt;OpPutInternalField&gt;();</span>
<span class="line-added">1151     VirtualRegister base = bytecode.m_base;</span>
<span class="line-added">1152     VirtualRegister value = bytecode.m_value;</span>
<span class="line-added">1153     unsigned index = bytecode.m_index;</span>
<span class="line-added">1154 </span>
<span class="line-added">1155     emitLoadPayload(base, regT0);</span>
<span class="line-added">1156     emitLoad(value, regT1, regT2);</span>
<span class="line-added">1157     store32(regT1, Address(regT0, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(index) + TagOffset));</span>
<span class="line-added">1158     store32(regT2, Address(regT0, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(index) + PayloadOffset));</span>
<span class="line-added">1159     emitWriteBarrier(base, value, ShouldFilterValue);</span>
<span class="line-added">1160 }</span>
<span class="line-added">1161 </span>
1162 } // namespace JSC
1163 
1164 #endif // USE(JSVALUE32_64)
1165 #endif // ENABLE(JIT)
</pre>
</td>
</tr>
</table>
<center><a href="JITPropertyAccess.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITRightShiftGenerator.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
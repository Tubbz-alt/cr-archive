<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/css/SelectorCheckerTestFunctions.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2014-2016 Apple Inc. All rights reserved.
  3  * Copyright (C) 2014 Dhi Aurrahman &lt;diorahman@rockybars.com&gt;
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 15  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 16  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 18  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 19  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 21  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 22  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 23  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 24  * THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;FocusController.h&quot;
 30 #include &quot;FullscreenManager.h&quot;
 31 #include &quot;HTMLFrameElement.h&quot;
 32 #include &quot;HTMLIFrameElement.h&quot;
 33 #include &quot;HTMLInputElement.h&quot;
 34 #include &quot;HTMLOptionElement.h&quot;
 35 #include &quot;SelectorChecker.h&quot;
 36 #include &lt;wtf/Compiler.h&gt;
 37 
 38 #if ENABLE(ATTACHMENT_ELEMENT)
 39 #include &quot;HTMLAttachmentElement.h&quot;
 40 #endif
 41 
 42 #if ENABLE(VIDEO_TRACK)
 43 #include &quot;WebVTTElement.h&quot;
 44 #endif
 45 
 46 #if ENABLE(PICTURE_IN_PICTURE_API)
 47 #include &quot;HTMLVideoElement.h&quot;
 48 #endif
 49 
 50 namespace WebCore {
 51 
 52 ALWAYS_INLINE bool isAutofilled(const Element&amp; element)
 53 {
 54     return is&lt;HTMLInputElement&gt;(element) &amp;&amp; downcast&lt;HTMLInputElement&gt;(element).isAutoFilled();
 55 }
 56 
 57 ALWAYS_INLINE bool isAutofilledStrongPassword(const Element&amp; element)
 58 {
 59     return is&lt;HTMLInputElement&gt;(element) &amp;&amp; downcast&lt;HTMLInputElement&gt;(element).isAutoFilled() &amp;&amp; downcast&lt;HTMLInputElement&gt;(element).hasAutoFillStrongPasswordButton();
 60 }
 61 
 62 ALWAYS_INLINE bool isAutofilledStrongPasswordViewable(const Element&amp; element)
 63 {
 64     return is&lt;HTMLInputElement&gt;(element) &amp;&amp; downcast&lt;HTMLInputElement&gt;(element).isAutoFilledAndViewable();
 65 }
 66 
 67 ALWAYS_INLINE bool matchesDefaultPseudoClass(const Element&amp; element)
 68 {
 69     return element.matchesDefaultPseudoClass();
 70 }
 71 
 72 // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
 73 ALWAYS_INLINE bool matchesDisabledPseudoClass(const Element&amp; element)
 74 {
 75     return is&lt;HTMLElement&gt;(element) &amp;&amp; downcast&lt;HTMLElement&gt;(element).isActuallyDisabled();
 76 }
 77 
 78 // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
 79 ALWAYS_INLINE bool matchesEnabledPseudoClass(const Element&amp; element)
 80 {
 81     return is&lt;HTMLElement&gt;(element) &amp;&amp; downcast&lt;HTMLElement&gt;(element).canBeActuallyDisabled() &amp;&amp; !element.isDisabledFormControl();
 82 }
 83 
 84 ALWAYS_INLINE bool isDefinedElement(const Element&amp; element)
 85 {
 86     return !element.isUndefinedCustomElement();
 87 }
 88 
 89 ALWAYS_INLINE bool isMediaDocument(const Element&amp; element)
 90 {
 91     return element.document().isMediaDocument();
 92 }
 93 
 94 ALWAYS_INLINE bool isChecked(const Element&amp; element)
 95 {
 96     // Even though WinIE allows checked and indeterminate to co-exist, the CSS selector spec says that
 97     // you can&#39;t be both checked and indeterminate. We will behave like WinIE behind the scenes and just
 98     // obey the CSS spec here in the test for matching the pseudo.
 99     if (is&lt;HTMLInputElement&gt;(element)) {
100         auto&amp; inputElement = downcast&lt;HTMLInputElement&gt;(element);
101         return inputElement.shouldAppearChecked() &amp;&amp; !inputElement.shouldAppearIndeterminate();
102     }
103     if (is&lt;HTMLOptionElement&gt;(element))
104         return const_cast&lt;HTMLOptionElement&amp;&gt;(downcast&lt;HTMLOptionElement&gt;(element)).selected();
105 
106     return false;
107 }
108 
109 ALWAYS_INLINE bool isInRange(const Element&amp; element)
110 {
111     return element.isInRange();
112 }
113 
114 ALWAYS_INLINE bool isOutOfRange(const Element&amp; element)
115 {
116     return element.isOutOfRange();
117 }
118 
119 ALWAYS_INLINE bool isInvalid(const Element&amp; element)
120 {
121     return element.matchesInvalidPseudoClass();
122 }
123 
124 ALWAYS_INLINE bool isOptionalFormControl(const Element&amp; element)
125 {
126     return element.isOptionalFormControl();
127 }
128 
129 ALWAYS_INLINE bool isRequiredFormControl(const Element&amp; element)
130 {
131     return element.isRequiredFormControl();
132 }
133 
134 ALWAYS_INLINE bool isValid(const Element&amp; element)
135 {
136     return element.matchesValidPseudoClass();
137 }
138 
139 ALWAYS_INLINE bool isWindowInactive(const Element&amp; element)
140 {
141     auto* page = element.document().page();
142     if (!page)
143         return false;
144     return !page-&gt;focusController().isActive();
145 }
146 
147 #if ENABLE(ATTACHMENT_ELEMENT)
148 ALWAYS_INLINE bool hasAttachment(const Element&amp; element)
149 {
150     return is&lt;HTMLImageElement&gt;(element) &amp;&amp; downcast&lt;HTMLImageElement&gt;(element).attachmentElement();
151 }
152 #endif
153 
154 ALWAYS_INLINE bool containslanguageSubtagMatchingRange(StringView language, StringView range, unsigned languageLength, unsigned&amp; position)
155 {
156     unsigned languageSubtagsStartIndex = position;
157     unsigned languageSubtagsEndIndex = languageLength;
158     bool isAsteriskRange = range == &quot;*&quot;;
159     do {
160         if (languageSubtagsStartIndex &gt; 0)
161             languageSubtagsStartIndex += 1;
162 
163         languageSubtagsEndIndex = std::min&lt;unsigned&gt;(language.find(&#39;-&#39;, languageSubtagsStartIndex), languageLength);
164 
165         if (languageSubtagsStartIndex &gt; languageSubtagsEndIndex)
166             return false;
167 
168         StringView languageSubtag = language.substring(languageSubtagsStartIndex, languageSubtagsEndIndex - languageSubtagsStartIndex);
169         bool isEqual = equalIgnoringASCIICase(range, languageSubtag);
170         if (!isAsteriskRange) {
171             if ((!isEqual &amp;&amp; !languageSubtagsStartIndex) || (languageSubtag.length() == 1 &amp;&amp; languageSubtagsStartIndex &gt; 0))
172                 return false;
173         }
174         languageSubtagsStartIndex = languageSubtagsEndIndex;
175         if (isEqual || isAsteriskRange) {
176             position = languageSubtagsStartIndex;
177             return true;
178         }
179 
180     } while (languageSubtagsStartIndex &lt; languageLength);
181     return false;
182 }
183 
184 ALWAYS_INLINE bool matchesLangPseudoClass(const Element&amp; element, const Vector&lt;AtomString&gt;&amp; argumentList)
185 {
186     AtomString language;
187 #if ENABLE(VIDEO_TRACK)
188     if (is&lt;WebVTTElement&gt;(element))
189         language = downcast&lt;WebVTTElement&gt;(element).language();
190     else
191 #endif
192         language = element.computeInheritedLanguage();
193 
194     if (language.isEmpty())
195         return false;
196 
197     // Implement basic and extended filterings of given language tags
198     // as specified in www.ietf.org/rfc/rfc4647.txt.
199     StringView languageStringView = language.string();
200     unsigned languageLength = language.length();
201     for (const AtomString&amp; range : argumentList) {
202         if (range.isEmpty())
203             continue;
204 
205         if (range == &quot;*&quot;)
206             return true;
207 
208         StringView rangeStringView = range.string();
209         if (equalIgnoringASCIICase(languageStringView, rangeStringView) &amp;&amp; !languageStringView.contains(&#39;-&#39;))
210             return true;
211 
212         unsigned rangeLength = rangeStringView.length();
213         unsigned rangeSubtagsStartIndex = 0;
214         unsigned rangeSubtagsEndIndex = rangeLength;
215         unsigned lastMatchedLanguageSubtagIndex = 0;
216 
217         bool matchedRange = true;
218         do {
219             if (rangeSubtagsStartIndex &gt; 0)
220                 rangeSubtagsStartIndex += 1;
221             if (rangeSubtagsStartIndex &gt; languageLength)
222                 return false;
223             rangeSubtagsEndIndex = std::min&lt;unsigned&gt;(rangeStringView.find(&#39;-&#39;, rangeSubtagsStartIndex), rangeLength);
224             StringView rangeSubtag = rangeStringView.substring(rangeSubtagsStartIndex, rangeSubtagsEndIndex - rangeSubtagsStartIndex);
225             if (!containslanguageSubtagMatchingRange(languageStringView, rangeSubtag, languageLength, lastMatchedLanguageSubtagIndex)) {
226                 matchedRange = false;
227                 break;
228             }
229             rangeSubtagsStartIndex = rangeSubtagsEndIndex;
230         } while (rangeSubtagsStartIndex &lt; rangeLength);
231         if (matchedRange)
232             return true;
233     }
234     return false;
235 }
236 
237 ALWAYS_INLINE bool matchesReadOnlyPseudoClass(const Element&amp; element)
238 {
239     return !element.matchesReadWritePseudoClass();
240 }
241 
242 ALWAYS_INLINE bool matchesReadWritePseudoClass(const Element&amp; element)
243 {
244     return element.matchesReadWritePseudoClass();
245 }
246 
247 ALWAYS_INLINE bool matchesIndeterminatePseudoClass(const Element&amp; element)
248 {
249     return element.matchesIndeterminatePseudoClass();
250 }
251 
252 ALWAYS_INLINE bool scrollbarMatchesEnabledPseudoClass(const SelectorChecker::CheckingContext&amp; context)
253 {
254     return context.scrollbarState &amp;&amp; context.scrollbarState-&gt;enabled;
255 }
256 
257 ALWAYS_INLINE bool scrollbarMatchesDisabledPseudoClass(const SelectorChecker::CheckingContext&amp; context)
258 {
259     return context.scrollbarState &amp;&amp; !context.scrollbarState-&gt;enabled;
260 }
261 
262 ALWAYS_INLINE bool scrollbarMatchesHoverPseudoClass(const SelectorChecker::CheckingContext&amp; context)
263 {
264     if (!context.scrollbarState)
265         return false;
266     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;
267     auto hoveredPart = context.scrollbarState-&gt;hoveredPart;
268     if (scrollbarPart == ScrollbarBGPart)
269         return hoveredPart != NoPart;
270     if (scrollbarPart == TrackBGPart)
271         return hoveredPart == BackTrackPart || hoveredPart == ForwardTrackPart || hoveredPart == ThumbPart;
272     return scrollbarPart == hoveredPart;
273 }
274 
275 ALWAYS_INLINE bool scrollbarMatchesActivePseudoClass(const SelectorChecker::CheckingContext&amp; context)
276 {
277     if (!context.scrollbarState)
278         return false;
279     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;
280     auto pressedPart = context.scrollbarState-&gt;pressedPart;
281     if (scrollbarPart == ScrollbarBGPart)
282         return pressedPart != NoPart;
283     if (scrollbarPart == TrackBGPart)
284         return pressedPart == BackTrackPart || pressedPart == ForwardTrackPart || pressedPart == ThumbPart;
285     return scrollbarPart == pressedPart;
286 }
287 
288 ALWAYS_INLINE bool scrollbarMatchesHorizontalPseudoClass(const SelectorChecker::CheckingContext&amp; context)
289 {
290     return context.scrollbarState &amp;&amp; context.scrollbarState-&gt;orientation == HorizontalScrollbar;
291 }
292 
293 ALWAYS_INLINE bool scrollbarMatchesVerticalPseudoClass(const SelectorChecker::CheckingContext&amp; context)
294 {
295     return context.scrollbarState &amp;&amp; context.scrollbarState-&gt;orientation == VerticalScrollbar;
296 }
297 
298 ALWAYS_INLINE bool scrollbarMatchesDecrementPseudoClass(const SelectorChecker::CheckingContext&amp; context)
299 {
300     if (!context.scrollbarState)
301         return false;
302     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;
303     return scrollbarPart == BackButtonStartPart || scrollbarPart == BackButtonEndPart || scrollbarPart == BackTrackPart;
304 }
305 
306 ALWAYS_INLINE bool scrollbarMatchesIncrementPseudoClass(const SelectorChecker::CheckingContext&amp; context)
307 {
308     if (!context.scrollbarState)
309         return false;
310     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;
311     return scrollbarPart == ForwardButtonStartPart || scrollbarPart == ForwardButtonEndPart || scrollbarPart == ForwardTrackPart;
312 }
313 
314 ALWAYS_INLINE bool scrollbarMatchesStartPseudoClass(const SelectorChecker::CheckingContext&amp; context)
315 {
316     if (!context.scrollbarState)
317         return false;
318     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;
319     return scrollbarPart == BackButtonStartPart || scrollbarPart == ForwardButtonStartPart || scrollbarPart == BackTrackPart;
320 }
321 
322 ALWAYS_INLINE bool scrollbarMatchesEndPseudoClass(const SelectorChecker::CheckingContext&amp; context)
323 {
324     if (!context.scrollbarState)
325         return false;
326     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;
327     return scrollbarPart == BackButtonEndPart || scrollbarPart == ForwardButtonEndPart || scrollbarPart == ForwardTrackPart;
328 }
329 
330 ALWAYS_INLINE bool scrollbarMatchesDoubleButtonPseudoClass(const SelectorChecker::CheckingContext&amp; context)
331 {
332     if (!context.scrollbarState)
333         return false;
334     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;
335     auto buttonsPlacement = context.scrollbarState-&gt;buttonsPlacement;
336     if (scrollbarPart == BackButtonStartPart || scrollbarPart == ForwardButtonStartPart || scrollbarPart == BackTrackPart)
337         return buttonsPlacement == ScrollbarButtonsDoubleStart || buttonsPlacement == ScrollbarButtonsDoubleBoth;
338     if (scrollbarPart == BackButtonEndPart || scrollbarPart == ForwardButtonEndPart || scrollbarPart == ForwardTrackPart)
339         return buttonsPlacement == ScrollbarButtonsDoubleEnd || buttonsPlacement == ScrollbarButtonsDoubleBoth;
340     return false;
341 }
342 
343 ALWAYS_INLINE bool scrollbarMatchesSingleButtonPseudoClass(const SelectorChecker::CheckingContext&amp; context)
344 {
345     if (!context.scrollbarState)
346         return false;
347     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;
348     auto buttonsPlacement = context.scrollbarState-&gt;buttonsPlacement;
349     if (scrollbarPart == BackButtonStartPart || scrollbarPart == ForwardButtonEndPart || scrollbarPart == BackTrackPart || scrollbarPart == ForwardTrackPart)
350         return buttonsPlacement == ScrollbarButtonsSingle;
351     return false;
352 }
353 
354 ALWAYS_INLINE bool scrollbarMatchesNoButtonPseudoClass(const SelectorChecker::CheckingContext&amp; context)
355 {
356     if (!context.scrollbarState)
357         return false;
358     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;
359     auto buttonsPlacement = context.scrollbarState-&gt;buttonsPlacement;
360     if (scrollbarPart == BackTrackPart)
361         return buttonsPlacement == ScrollbarButtonsNone || buttonsPlacement == ScrollbarButtonsDoubleEnd;
362     if (scrollbarPart == ForwardTrackPart)
363         return buttonsPlacement == ScrollbarButtonsNone || buttonsPlacement == ScrollbarButtonsDoubleStart;
364     return false;
365 }
366 
367 ALWAYS_INLINE bool scrollbarMatchesCornerPresentPseudoClass(const SelectorChecker::CheckingContext&amp; context)
368 {
369     return context.scrollbarState &amp;&amp; context.scrollbarState-&gt;scrollCornerIsVisible;
370 }
371 
372 #if ENABLE(FULLSCREEN_API)
373 
374 ALWAYS_INLINE bool matchesFullScreenPseudoClass(const Element&amp; element)
375 {
376     // While a Document is in the fullscreen state, and the document&#39;s current fullscreen
377     // element is an element in the document, the &#39;full-screen&#39; pseudoclass applies to
378     // that element. Also, an &lt;iframe&gt;, &lt;object&gt; or &lt;embed&gt; element whose child browsing
379     // context&#39;s Document is in the fullscreen state has the &#39;full-screen&#39; pseudoclass applied.
380     if (is&lt;HTMLFrameElementBase&gt;(element) &amp;&amp; element.containsFullScreenElement())
381         return true;
382     if (!element.document().fullscreenManager().isFullscreen())
383         return false;
384     return &amp;element == element.document().fullscreenManager().currentFullscreenElement();
385 }
386 
387 ALWAYS_INLINE bool matchesFullScreenAnimatingFullScreenTransitionPseudoClass(const Element&amp; element)
388 {
389     if (&amp;element != element.document().fullscreenManager().currentFullscreenElement())
390         return false;
391     return element.document().fullscreenManager().isAnimatingFullscreen();
392 }
393 
394 ALWAYS_INLINE bool matchesFullScreenAncestorPseudoClass(const Element&amp; element)
395 {
396     return element.containsFullScreenElement();
397 }
398 
399 ALWAYS_INLINE bool matchesFullScreenDocumentPseudoClass(const Element&amp; element)
400 {
401     // While a Document is in the fullscreen state, the &#39;full-screen-document&#39; pseudoclass applies
402     // to all elements of that Document.
403     if (!element.document().fullscreenManager().isFullscreen())
404         return false;
405     return true;
406 }
407 
408 ALWAYS_INLINE bool matchesFullScreenControlsHiddenPseudoClass(const Element&amp; element)
409 {
410     if (&amp;element != element.document().fullscreenManager().currentFullscreenElement())
411         return false;
412     return element.document().fullscreenManager().areFullscreenControlsHidden();
413 }
414 
415 #endif
416 
417 #if ENABLE(PICTURE_IN_PICTURE_API)
418 
419 ALWAYS_INLINE bool matchesPictureInPicturePseudoClass(const Element&amp; element)
420 {
421     return is&lt;HTMLVideoElement&gt;(element) &amp;&amp; element.document().pictureInPictureElement() == &amp;element;
422 }
423 
424 #endif
425 
426 #if ENABLE(VIDEO_TRACK)
427 
428 ALWAYS_INLINE bool matchesFutureCuePseudoClass(const Element&amp; element)
429 {
430     return is&lt;WebVTTElement&gt;(element) &amp;&amp; !downcast&lt;WebVTTElement&gt;(element).isPastNode();
431 }
432 
433 ALWAYS_INLINE bool matchesPastCuePseudoClass(const Element&amp; element)
434 {
435     return is&lt;WebVTTElement&gt;(element) &amp;&amp; downcast&lt;WebVTTElement&gt;(element).isPastNode();
436 }
437 
438 #endif
439 
440 } // namespace WebCore
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSWindowProxy.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2008-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;JSWindowProxy.h&quot;
 31 
 32 #include &quot;AbstractFrame.h&quot;
 33 #include &quot;CommonVM.h&quot;
 34 #include &quot;GCController.h&quot;
 35 #include &quot;JSDOMWindow.h&quot;
 36 #include &quot;JSDOMWindowProperties.h&quot;
 37 #include &quot;JSEventTarget.h&quot;
 38 #include &quot;JSRemoteDOMWindow.h&quot;
 39 #include &quot;ScriptController.h&quot;
 40 #include &quot;WebCoreJSClientData.h&quot;
 41 #include &lt;JavaScriptCore/Debugger.h&gt;
 42 #include &lt;JavaScriptCore/JSObject.h&gt;
 43 #include &lt;JavaScriptCore/StrongInlines.h&gt;
 44 
 45 namespace WebCore {
 46 using namespace JSC;
 47 
 48 using namespace JSC;
 49 
 50 const ClassInfo JSWindowProxy::s_info = { &quot;JSWindowProxy&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSWindowProxy) };
 51 
 52 inline JSWindowProxy::JSWindowProxy(VM&amp; vm, Structure&amp; structure, DOMWrapperWorld&amp; world)
 53     : Base(vm, &amp;structure)
 54     , m_world(world)
 55 {
 56 }
 57 
 58 void JSWindowProxy::finishCreation(VM&amp; vm, AbstractDOMWindow&amp; window)
 59 {
 60     Base::finishCreation(vm);
 61     ASSERT(inherits(vm, info()));
 62     setWindow(window);
 63 }
 64 
 65 JSWindowProxy&amp; JSWindowProxy::create(VM&amp; vm, AbstractDOMWindow&amp; window, DOMWrapperWorld&amp; world)
 66 {
 67     auto&amp; structure = *Structure::create(vm, 0, jsNull(), TypeInfo(PureForwardingProxyType, StructureFlags), info());
 68     auto&amp; proxy = *new (NotNull, allocateCell&lt;JSWindowProxy&gt;(vm.heap)) JSWindowProxy(vm, structure, world);
 69     proxy.finishCreation(vm, window);
 70     return proxy;
 71 }
 72 
 73 void JSWindowProxy::destroy(JSCell* cell)
 74 {
 75     static_cast&lt;JSWindowProxy*&gt;(cell)-&gt;JSWindowProxy::~JSWindowProxy();
 76 }
 77 
 78 void JSWindowProxy::setWindow(VM&amp; vm, JSDOMGlobalObject&amp; window)
 79 {
 80     ASSERT(window.classInfo(vm) == JSDOMWindow::info() || window.classInfo(vm) == JSRemoteDOMWindow::info());
 81     setTarget(vm, &amp;window);
 82     structure(vm)-&gt;setGlobalObject(vm, &amp;window);
 83     GCController::singleton().garbageCollectSoon();
 84 }
 85 
 86 void JSWindowProxy::setWindow(AbstractDOMWindow&amp; domWindow)
 87 {
 88     // Replacing JSDOMWindow via telling JSWindowProxy to use the same DOMWindow it already uses makes no sense,
 89     // so we&#39;d better never try to.
 90     ASSERT(!window() || &amp;domWindow != &amp;wrapped());
 91 
 92     bool isRemoteDOMWindow = is&lt;RemoteDOMWindow&gt;(domWindow);
 93 
 94     VM&amp; vm = commonVM();
 95     auto&amp; prototypeStructure = isRemoteDOMWindow ? *JSRemoteDOMWindowPrototype::createStructure(vm, nullptr, jsNull()) : *JSDOMWindowPrototype::createStructure(vm, nullptr, jsNull());
 96 
 97     // Explicitly protect the prototype so it isn&#39;t collected when we allocate the global object.
 98     // (Once the global object is fully constructed, it will mark its own prototype.)
 99     // FIXME: Why do we need to protect this when there&#39;s a pointer to it on the stack?
100     // Perhaps the issue is that structure objects aren&#39;t seen when scanning the stack?
101     Strong&lt;JSNonFinalObject&gt; prototype(vm, isRemoteDOMWindow ? static_cast&lt;JSNonFinalObject*&gt;(JSRemoteDOMWindowPrototype::create(vm, nullptr, &amp;prototypeStructure)) : static_cast&lt;JSNonFinalObject*&gt;(JSDOMWindowPrototype::create(vm, nullptr, &amp;prototypeStructure)));
102 
103     JSDOMGlobalObject* window = nullptr;
104     if (isRemoteDOMWindow) {
105         auto&amp; windowStructure = *JSRemoteDOMWindow::createStructure(vm, nullptr, prototype.get());
106         window = JSRemoteDOMWindow::create(vm, &amp;windowStructure, downcast&lt;RemoteDOMWindow&gt;(domWindow), this);
107     } else {
108         auto&amp; windowStructure = *JSDOMWindow::createStructure(vm, nullptr, prototype.get());
109         window = JSDOMWindow::create(vm, &amp;windowStructure, downcast&lt;DOMWindow&gt;(domWindow), this);
110     }
111 
112     prototype-&gt;structure(vm)-&gt;setGlobalObject(vm, window);
113 
114     auto&amp; propertiesStructure = *JSDOMWindowProperties::createStructure(vm, window, JSEventTarget::prototype(vm, *window));
115     auto&amp; properties = *JSDOMWindowProperties::create(&amp;propertiesStructure, *window);
116     properties.didBecomePrototype();
117     prototype-&gt;structure(vm)-&gt;setPrototypeWithoutTransition(vm, &amp;properties);
118 
119     setWindow(vm, *window);
120 
121     ASSERT(window-&gt;globalObject() == window);
122     ASSERT(prototype-&gt;globalObject() == window);
123 }
124 
125 WindowProxy* JSWindowProxy::windowProxy() const
126 {
127     auto&amp; window = wrapped();
128     return window.frame() ? &amp;window.frame()-&gt;windowProxy() : nullptr;
129 }
130 
131 void JSWindowProxy::attachDebugger(JSC::Debugger* debugger)
132 {
133     auto* globalObject = window();
134     JSLockHolder lock(globalObject-&gt;vm());
135 
136     if (debugger)
137         debugger-&gt;attach(globalObject);
138     else if (auto* currentDebugger = globalObject-&gt;debugger())
139         currentDebugger-&gt;detach(globalObject, JSC::Debugger::TerminatingDebuggingSession);
140 }
141 
142 AbstractDOMWindow&amp; JSWindowProxy::wrapped() const
143 {
144     auto* window = this-&gt;window();
145     if (auto* jsWindow = jsDynamicCast&lt;JSRemoteDOMWindowBase*&gt;(window-&gt;vm(), window))
146         return jsWindow-&gt;wrapped();
147     return jsCast&lt;JSDOMWindowBase*&gt;(window)-&gt;wrapped();
148 }
149 
150 JSValue toJS(JSGlobalObject* lexicalGlobalObject, WindowProxy&amp; windowProxy)
151 {
152     auto* jsWindowProxy = windowProxy.jsWindowProxy(currentWorld(*lexicalGlobalObject));
153     return jsWindowProxy ? JSValue(jsWindowProxy) : jsNull();
154 }
155 
156 JSWindowProxy* toJSWindowProxy(WindowProxy&amp; windowProxy, DOMWrapperWorld&amp; world)
157 {
158     return windowProxy.jsWindowProxy(world);
159 }
160 
161 WindowProxy* JSWindowProxy::toWrapped(VM&amp; vm, JSValue value)
162 {
163     if (!value.isObject())
164         return nullptr;
165     JSObject* object = asObject(value);
166     if (object-&gt;inherits&lt;JSWindowProxy&gt;(vm))
167         return jsCast&lt;JSWindowProxy*&gt;(object)-&gt;windowProxy();
168     return nullptr;
169 }
170 
171 JSC::IsoSubspace* JSWindowProxy::subspaceForImpl(JSC::VM&amp; vm)
172 {
173     return &amp;static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;windowProxySpace();
174 }
175 
176 } // namespace WebCore
    </pre>
  </body>
</html>
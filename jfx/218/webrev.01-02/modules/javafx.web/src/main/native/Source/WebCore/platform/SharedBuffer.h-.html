<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/platform/SharedBuffer.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.
  3  * Copyright (C) Research In Motion Limited 2009-2010. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &lt;JavaScriptCore/ArrayBuffer.h&gt;
 30 #include &lt;wtf/FileSystem.h&gt;
 31 #include &lt;wtf/Forward.h&gt;
 32 #include &lt;wtf/RefCounted.h&gt;
 33 #include &lt;wtf/ThreadSafeRefCounted.h&gt;
 34 #include &lt;wtf/Variant.h&gt;
 35 #include &lt;wtf/Vector.h&gt;
 36 #include &lt;wtf/text/WTFString.h&gt;
 37 
 38 #if USE(CF)
 39 #include &lt;wtf/RetainPtr.h&gt;
 40 #endif
 41 
 42 #if USE(SOUP)
 43 #include &quot;GUniquePtrSoup.h&quot;
 44 #endif
 45 
 46 #if USE(GLIB)
 47 #include &lt;wtf/glib/GRefPtr.h&gt;
 48 typedef struct _GBytes GBytes;
 49 #endif
 50 
 51 #if USE(GSTREAMER)
 52 #include &quot;GStreamerCommon.h&quot;
 53 #endif
 54 
 55 #if USE(FOUNDATION)
 56 OBJC_CLASS NSArray;
 57 OBJC_CLASS NSData;
 58 #endif
 59 
 60 namespace WebCore {
 61 
 62 class SharedBufferDataView;
 63 
 64 class WEBCORE_EXPORT SharedBuffer : public RefCounted&lt;SharedBuffer&gt; {
 65 public:
 66     static Ref&lt;SharedBuffer&gt; create() { return adoptRef(*new SharedBuffer); }
 67     static Ref&lt;SharedBuffer&gt; create(const char* data, size_t size) { return adoptRef(*new SharedBuffer(data, size)); }
 68     static Ref&lt;SharedBuffer&gt; create(const unsigned char* data, size_t size) { return adoptRef(*new SharedBuffer(data, size)); }
 69     static RefPtr&lt;SharedBuffer&gt; createWithContentsOfFile(const String&amp; filePath);
 70 
 71     static Ref&lt;SharedBuffer&gt; create(Vector&lt;char&gt;&amp;&amp;);
 72     static Ref&lt;SharedBuffer&gt; create(Vector&lt;uint8_t&gt;&amp;&amp;);
 73 
 74 #if USE(FOUNDATION)
 75     RetainPtr&lt;NSData&gt; createNSData() const;
 76     RetainPtr&lt;NSArray&gt; createNSDataArray() const;
 77     static Ref&lt;SharedBuffer&gt; create(NSData *);
 78     void append(NSData *);
 79 #endif
 80 #if USE(CF)
 81     RetainPtr&lt;CFDataRef&gt; createCFData() const;
 82     static Ref&lt;SharedBuffer&gt; create(CFDataRef);
 83     void append(CFDataRef);
 84 #endif
 85 
 86 #if USE(SOUP)
 87     GUniquePtr&lt;SoupBuffer&gt; createSoupBuffer(unsigned offset = 0, unsigned size = 0);
 88     static Ref&lt;SharedBuffer&gt; wrapSoupBuffer(SoupBuffer*);
 89 #endif
 90 
 91 #if USE(GLIB)
 92     static Ref&lt;SharedBuffer&gt; create(GBytes*);
 93 #endif
 94 
 95 #if USE(GSTREAMER)
 96     static Ref&lt;SharedBuffer&gt; create(GstMappedBuffer&amp;);
 97 #endif
 98     // Calling data() causes all the data segments to be copied into one segment if they are not already.
 99     // Iterate the segments using begin() and end() instead.
100     // FIXME: Audit the call sites of this function and replace them with iteration if possible.
101     const char* data() const;
102 
103     // Creates an ArrayBuffer and copies this SharedBuffer&#39;s contents to that
104     // ArrayBuffer without merging segmented buffers into a flat buffer.
105     RefPtr&lt;ArrayBuffer&gt; tryCreateArrayBuffer() const;
106 
107     size_t size() const { return m_size; }
108 
109     bool isEmpty() const { return !size(); }
110 
111     void append(const SharedBuffer&amp;);
112     void append(const char*, size_t);
113     void append(Vector&lt;char&gt;&amp;&amp;);
114 
115     void clear();
116 
117     Ref&lt;SharedBuffer&gt; copy() const;
118 
119     // Data wrapped by a DataSegment should be immutable because it can be referenced by other objects.
120     // To modify or combine the data, allocate a new DataSegment.
121     class DataSegment : public ThreadSafeRefCounted&lt;DataSegment&gt; {
122     public:
123         WEBCORE_EXPORT const char* data() const;
124         WEBCORE_EXPORT size_t size() const;
125 
126         static Ref&lt;DataSegment&gt; create(Vector&lt;char&gt;&amp;&amp; data) { return adoptRef(*new DataSegment(WTFMove(data))); }
127 #if USE(CF)
128         static Ref&lt;DataSegment&gt; create(RetainPtr&lt;CFDataRef&gt;&amp;&amp; data) { return adoptRef(*new DataSegment(WTFMove(data))); }
129 #endif
130 #if USE(SOUP)
131         static Ref&lt;DataSegment&gt; create(GUniquePtr&lt;SoupBuffer&gt;&amp;&amp; data) { return adoptRef(*new DataSegment(WTFMove(data))); }
132 #endif
133 #if USE(GLIB)
134         static Ref&lt;DataSegment&gt; create(GRefPtr&lt;GBytes&gt;&amp;&amp; data) { return adoptRef(*new DataSegment(WTFMove(data))); }
135 #endif
136 #if USE(GSTREAMER)
137         static Ref&lt;DataSegment&gt; create(RefPtr&lt;GstMappedBuffer&gt;&amp;&amp; data) { return adoptRef(*new DataSegment(WTFMove(data))); }
138 #endif
139         static Ref&lt;DataSegment&gt; create(FileSystem::MappedFileData&amp;&amp; data) { return adoptRef(*new DataSegment(WTFMove(data))); }
140 
141     private:
142         DataSegment(Vector&lt;char&gt;&amp;&amp; data)
143             : m_immutableData(WTFMove(data)) { }
144 #if USE(CF)
145         DataSegment(RetainPtr&lt;CFDataRef&gt;&amp;&amp; data)
146             : m_immutableData(WTFMove(data)) { }
147 #endif
148 #if USE(SOUP)
149         DataSegment(GUniquePtr&lt;SoupBuffer&gt;&amp;&amp; data)
150             : m_immutableData(WTFMove(data)) { }
151 #endif
152 #if USE(GLIB)
153         DataSegment(GRefPtr&lt;GBytes&gt;&amp;&amp; data)
154             : m_immutableData(WTFMove(data)) { }
155 #endif
156 #if USE(GSTREAMER)
157         DataSegment(RefPtr&lt;GstMappedBuffer&gt;&amp;&amp; data)
158             : m_immutableData(WTFMove(data)) { }
159 #endif
160         DataSegment(FileSystem::MappedFileData&amp;&amp; data)
161             : m_immutableData(WTFMove(data)) { }
162 
163         Variant&lt;Vector&lt;char&gt;,
164 #if USE(CF)
165             RetainPtr&lt;CFDataRef&gt;,
166 #endif
167 #if USE(SOUP)
168             GUniquePtr&lt;SoupBuffer&gt;,
169 #endif
170 #if USE(GLIB)
171             GRefPtr&lt;GBytes&gt;,
172 #endif
173 #if USE(GSTREAMER)
174             RefPtr&lt;GstMappedBuffer&gt;,
175 #endif
176             FileSystem::MappedFileData&gt; m_immutableData;
177         friend class SharedBuffer;
178     };
179 
180     struct DataSegmentVectorEntry {
181         size_t beginPosition;
182         Ref&lt;DataSegment&gt; segment;
183     };
184     using DataSegmentVector = Vector&lt;DataSegmentVectorEntry, 1&gt;;
185     DataSegmentVector::const_iterator begin() const { return m_segments.begin(); }
186     DataSegmentVector::const_iterator end() const { return m_segments.end(); }
187 
188     // begin and end take O(1) time, this takes O(log(N)) time.
189     SharedBufferDataView getSomeData(size_t position) const;
190 
191     void hintMemoryNotNeededSoon() const;
192 
193     bool operator==(const SharedBuffer&amp;) const;
194     bool operator!=(const SharedBuffer&amp; other) const { return !operator==(other); }
195 
196 private:
197     explicit SharedBuffer() = default;
198     explicit SharedBuffer(const char*, size_t);
199     explicit SharedBuffer(const unsigned char*, size_t);
200     explicit SharedBuffer(Vector&lt;char&gt;&amp;&amp;);
201     explicit SharedBuffer(FileSystem::MappedFileData&amp;&amp;);
202 #if USE(CF)
203     explicit SharedBuffer(CFDataRef);
204 #endif
205 #if USE(SOUP)
206     explicit SharedBuffer(SoupBuffer*);
207 #endif
208 #if USE(GLIB)
209     explicit SharedBuffer(GBytes*);
210 #endif
211 #if USE(GSTREAMER)
212     explicit SharedBuffer(GstMappedBuffer&amp;);
213 #endif
214 
215     void combineIntoOneSegment() const;
216 
217     static RefPtr&lt;SharedBuffer&gt; createFromReadingFile(const String&amp; filePath);
218 
219     size_t m_size { 0 };
220     mutable DataSegmentVector m_segments;
221 
222 #if !ASSERT_DISABLED
223     mutable bool m_hasBeenCombinedIntoOneSegment { false };
224     bool internallyConsistent() const;
225 #endif
226 };
227 
228 inline bool operator==(const Ref&lt;SharedBuffer&gt;&amp; left, const SharedBuffer&amp; right)
229 {
230     return left.get() == right;
231 }
232 
233 inline bool operator!=(const Ref&lt;SharedBuffer&gt;&amp; left, const SharedBuffer&amp; right)
234 {
235     return left.get() != right;
236 }
237 
238 class WEBCORE_EXPORT SharedBufferDataView {
239 public:
240     SharedBufferDataView(Ref&lt;SharedBuffer::DataSegment&gt;&amp;&amp;, size_t);
241     size_t size() const;
242     const char* data() const;
243 private:
244     size_t m_positionWithinSegment;
245     Ref&lt;SharedBuffer::DataSegment&gt; m_segment;
246 };
247 
248 RefPtr&lt;SharedBuffer&gt; utf8Buffer(const String&amp;);
249 
250 } // namespace WebCore
    </pre>
  </body>
</html>
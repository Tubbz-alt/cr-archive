diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSONObject.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSONObject.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSONObject.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSONObject.cpp
@@ -30,10 +30,11 @@
 #include "BigIntObject.h"
 #include "BooleanObject.h"
 #include "Error.h"
 #include "ExceptionHelpers.h"
 #include "JSArray.h"
+#include "JSArrayInlines.h"
 #include "JSGlobalObject.h"
 #include "LiteralParser.h"
 #include "Lookup.h"
 #include "ObjectConstructor.h"
 #include "JSCInlines.h"
@@ -43,12 +44,12 @@
 
 namespace JSC {
 
 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(JSONObject);
 
-EncodedJSValue JSC_HOST_CALL JSONProtoFuncParse(ExecState*);
-EncodedJSValue JSC_HOST_CALL JSONProtoFuncStringify(ExecState*);
+EncodedJSValue JSC_HOST_CALL JSONProtoFuncParse(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL JSONProtoFuncStringify(JSGlobalObject*, CallFrame*);
 
 }
 
 #include "JSONObject.lut.h"
 
@@ -62,20 +63,20 @@
 void JSONObject::finishCreation(VM& vm)
 {
     Base::finishCreation(vm);
     ASSERT(inherits(vm, info()));
 
-    putDirectWithoutTransition(vm, vm.propertyNames->toStringTagSymbol, jsString(vm, "JSON"), PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
+    putDirectWithoutTransition(vm, vm.propertyNames->toStringTagSymbol, jsNontrivialString(vm, "JSON"_s), PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 }
 
 // PropertyNameForFunctionCall objects must be on the stack, since the JSValue that they create is not marked.
 class PropertyNameForFunctionCall {
 public:
     PropertyNameForFunctionCall(const Identifier&);
     PropertyNameForFunctionCall(unsigned);
 
-    JSValue value(ExecState*) const;
+    JSValue value(JSGlobalObject*) const;
 
 private:
     const Identifier* m_identifier;
     unsigned m_number;
     mutable JSValue m_value;
@@ -83,18 +84,18 @@
 
 class Stringifier {
     WTF_MAKE_NONCOPYABLE(Stringifier);
     WTF_FORBID_HEAP_ALLOCATION;
 public:
-    Stringifier(ExecState*, JSValue replacer, JSValue space);
+    Stringifier(JSGlobalObject*, JSValue replacer, JSValue space);
     JSValue stringify(JSValue);
 
 private:
     class Holder {
     public:
         enum RootHolderTag { RootHolder };
-        Holder(ExecState*, JSObject*);
+        Holder(JSGlobalObject*, JSObject*);
         Holder(RootHolderTag, JSObject*);
 
         JSObject* object() const { return m_object; }
         bool isArray() const { return m_isArray; }
 
@@ -121,11 +122,11 @@
     void indent();
     void unindent();
     void startNewLine(StringBuilder&) const;
     bool isCallableReplacer() const { return m_replacerCallType != CallType::None; }
 
-    ExecState* const m_exec;
+    JSGlobalObject* const m_globalObject;
     JSValue m_replacer;
     bool m_usingArrayReplacer { false };
     PropertyNameArray m_arrayReplacerPropertyNames;
     CallType m_replacerCallType { CallType::None };
     CallData m_replacerCallData;
@@ -137,35 +138,35 @@
     String m_indent;
 };
 
 // ------------------------------ helper functions --------------------------------
 
-static inline JSValue unwrapBoxedPrimitive(ExecState* exec, JSValue value)
+static inline JSValue unwrapBoxedPrimitive(JSGlobalObject* globalObject, JSValue value)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     if (!value.isObject())
         return value;
     JSObject* object = asObject(value);
     if (object->inherits<NumberObject>(vm))
-        return jsNumber(object->toNumber(exec));
+        return jsNumber(object->toNumber(globalObject));
     if (object->inherits<StringObject>(vm))
-        return object->toString(exec);
+        return object->toString(globalObject);
     if (object->inherits<BooleanObject>(vm) || object->inherits<BigIntObject>(vm))
         return jsCast<JSWrapperObject*>(object)->internalValue();
 
     // Do not unwrap SymbolObject to Symbol. It is not performed in the spec.
     // http://www.ecma-international.org/ecma-262/6.0/#sec-serializejsonproperty
     return value;
 }
 
-static inline String gap(ExecState* exec, JSValue space)
+static inline String gap(JSGlobalObject* globalObject, JSValue space)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     const unsigned maxGapLength = 10;
-    space = unwrapBoxedPrimitive(exec, space);
+    space = unwrapBoxedPrimitive(globalObject, space);
     RETURN_IF_EXCEPTION(scope, { });
 
     // If the space value is a number, create a gap string with that number of spaces.
     if (space.isNumber()) {
         double spaceCount = space.asNumber();
@@ -181,11 +182,12 @@
             spaces[i] = ' ';
         return String(spaces, count);
     }
 
     // If the space value is a string, use it as the gap string, otherwise use no gap string.
-    String spaces = space.getString(exec);
+    String spaces = space.getString(globalObject);
+    RETURN_IF_EXCEPTION(scope, { });
     if (spaces.length() <= maxGapLength)
         return spaces;
     return spaces.substringSharingImpl(0, maxGapLength);
 }
 
@@ -200,14 +202,14 @@
     : m_identifier(0)
     , m_number(number)
 {
 }
 
-JSValue PropertyNameForFunctionCall::value(ExecState* exec) const
+JSValue PropertyNameForFunctionCall::value(JSGlobalObject* globalObject) const
 {
     if (!m_value) {
-        VM& vm = exec->vm();
+        VM& vm = globalObject->vm();
         if (m_identifier)
             m_value = jsString(vm, m_identifier->string());
         else {
             if (m_number <= 9)
                 return vm.smallStrings.singleCharacterString(m_number + '0');
@@ -217,94 +219,98 @@
     return m_value;
 }
 
 // ------------------------------ Stringifier --------------------------------
 
-Stringifier::Stringifier(ExecState* exec, JSValue replacer, JSValue space)
-    : m_exec(exec)
+Stringifier::Stringifier(JSGlobalObject* globalObject, JSValue replacer, JSValue space)
+    : m_globalObject(globalObject)
     , m_replacer(replacer)
-    , m_arrayReplacerPropertyNames(exec->vm(), PropertyNameMode::Strings, PrivateSymbolMode::Exclude)
+    , m_arrayReplacerPropertyNames(globalObject->vm(), PropertyNameMode::Strings, PrivateSymbolMode::Exclude)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (m_replacer.isObject()) {
         JSObject* replacerObject = asObject(m_replacer);
 
         m_replacerCallType = CallType::None;
         if (!replacerObject->isCallable(vm, m_replacerCallType, m_replacerCallData)) {
-            bool isArrayReplacer = JSC::isArray(exec, replacerObject);
+            bool isArrayReplacer = JSC::isArray(globalObject, replacerObject);
             RETURN_IF_EXCEPTION(scope, );
             if (isArrayReplacer) {
                 m_usingArrayReplacer = true;
-                unsigned length = replacerObject->get(exec, vm.propertyNames->length).toUInt32(exec);
+                unsigned length = toLength(globalObject, replacerObject);
                 RETURN_IF_EXCEPTION(scope, );
-                for (unsigned i = 0; i < length; ++i) {
-                    JSValue name = replacerObject->get(exec, i);
-                    RETURN_IF_EXCEPTION(scope, );
+                for (unsigned index = 0; index < length; ++index) {
+                    JSValue name;
+                    if (isJSArray(replacerObject) && replacerObject->canGetIndexQuickly(index))
+                        name = replacerObject->getIndexQuickly(index);
+                    else {
+                        name = replacerObject->get(globalObject, index);
+                        RETURN_IF_EXCEPTION(scope, );
+                    }
                     if (name.isObject()) {
                         auto* nameObject = jsCast<JSObject*>(name);
                         if (!nameObject->inherits<NumberObject>(vm) && !nameObject->inherits<StringObject>(vm))
                             continue;
                     } else if (!name.isNumber() && !name.isString())
                         continue;
-                    JSString* propertyNameString = name.toString(exec);
+                    JSString* propertyNameString = name.toString(globalObject);
                     RETURN_IF_EXCEPTION(scope, );
-                    auto propertyName = propertyNameString->toIdentifier(exec);
+                    auto propertyName = propertyNameString->toIdentifier(globalObject);
                     RETURN_IF_EXCEPTION(scope, );
                     m_arrayReplacerPropertyNames.add(WTFMove(propertyName));
                 }
             }
         }
     }
 
     scope.release();
-    m_gap = gap(exec, space);
+    m_gap = gap(globalObject, space);
 }
 
 JSValue Stringifier::stringify(JSValue value)
 {
-    VM& vm = m_exec->vm();
+    VM& vm = m_globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     PropertyNameForFunctionCall emptyPropertyName(vm.propertyNames->emptyIdentifier);
 
     // If the replacer is not callable, root object wrapper is non-user-observable.
     // We can skip creating this wrapper object.
     JSObject* object = nullptr;
     if (isCallableReplacer()) {
-        object = constructEmptyObject(m_exec);
-        RETURN_IF_EXCEPTION(scope, jsUndefined());
+        object = constructEmptyObject(m_globalObject);
         object->putDirect(vm, vm.propertyNames->emptyIdentifier, value);
     }
 
     StringBuilder result(StringBuilder::OverflowHandler::RecordOverflow);
     Holder root(Holder::RootHolder, object);
     auto stringifyResult = appendStringifiedValue(result, value, root, emptyPropertyName);
     RETURN_IF_EXCEPTION(scope, jsUndefined());
     if (UNLIKELY(result.hasOverflowed())) {
-        throwOutOfMemoryError(m_exec, scope);
+        throwOutOfMemoryError(m_globalObject, scope);
         return jsUndefined();
     }
     if (UNLIKELY(stringifyResult != StringifySucceeded))
         return jsUndefined();
     RELEASE_AND_RETURN(scope, jsString(vm, result.toString()));
 }
 
 ALWAYS_INLINE JSValue Stringifier::toJSON(JSValue baseValue, const PropertyNameForFunctionCall& propertyName)
 {
-    VM& vm = m_exec->vm();
+    VM& vm = m_globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
     scope.assertNoException();
 
     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::Get);
-    bool hasProperty = baseValue.getPropertySlot(m_exec, vm.propertyNames->toJSON, slot);
+    bool hasProperty = baseValue.getPropertySlot(m_globalObject, vm.propertyNames->toJSON, slot);
     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
     if (!hasProperty)
         return baseValue;
 
-    JSValue toJSONFunction = slot.getValue(m_exec, vm.propertyNames->toJSON);
+    JSValue toJSONFunction = slot.getValue(m_globalObject, vm.propertyNames->toJSON);
     RETURN_IF_EXCEPTION(scope, { });
     RELEASE_AND_RETURN(scope, toJSONImpl(vm, baseValue, toJSONFunction, propertyName));
 }
 
 JSValue Stringifier::toJSONImpl(VM& vm, JSValue baseValue, JSValue toJSONFunction, const PropertyNameForFunctionCall& propertyName)
@@ -313,18 +319,18 @@
     CallData callData;
     if (!toJSONFunction.isCallable(vm, callType, callData))
         return baseValue;
 
     MarkedArgumentBuffer args;
-    args.append(propertyName.value(m_exec));
+    args.append(propertyName.value(m_globalObject));
     ASSERT(!args.hasOverflowed());
-    return call(m_exec, asObject(toJSONFunction), callType, callData, baseValue, args);
+    return call(m_globalObject, asObject(toJSONFunction), callType, callData, baseValue, args);
 }
 
 Stringifier::StringifyResult Stringifier::appendStringifiedValue(StringBuilder& builder, JSValue value, const Holder& holder, const PropertyNameForFunctionCall& propertyName)
 {
-    VM& vm = m_exec->vm();
+    VM& vm = m_globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     // Call the toJSON function.
     if (value.isObject() || value.isBigInt()) {
         value = toJSON(value, propertyName);
@@ -332,15 +338,15 @@
     }
 
     // Call the replacer function.
     if (isCallableReplacer()) {
         MarkedArgumentBuffer args;
-        args.append(propertyName.value(m_exec));
+        args.append(propertyName.value(m_globalObject));
         args.append(value);
         ASSERT(!args.hasOverflowed());
         ASSERT(holder.object());
-        value = call(m_exec, m_replacer, m_replacerCallType, m_replacerCallData, holder.object(), args);
+        value = call(m_globalObject, m_replacer, m_replacerCallType, m_replacerCallData, holder.object(), args);
         RETURN_IF_EXCEPTION(scope, StringifyFailed);
     }
 
     if ((value.isUndefined() || value.isSymbol()) && !holder.isArray())
         return StringifyFailedDueToUndefinedOrSymbolValue;
@@ -348,11 +354,11 @@
     if (value.isNull()) {
         builder.appendLiteral("null");
         return StringifySucceeded;
     }
 
-    value = unwrapBoxedPrimitive(m_exec, value);
+    value = unwrapBoxedPrimitive(m_globalObject, value);
 
     RETURN_IF_EXCEPTION(scope, StringifyFailed);
 
     if (value.isBoolean()) {
         if (value.isTrue())
@@ -361,11 +367,11 @@
             builder.appendLiteral("false");
         return StringifySucceeded;
     }
 
     if (value.isString()) {
-        const String& string = asString(value)->value(m_exec);
+        const String& string = asString(value)->value(m_globalObject);
         RETURN_IF_EXCEPTION(scope, StringifyFailed);
         builder.appendQuotedJSONString(string);
         return StringifySucceeded;
     }
 
@@ -381,11 +387,11 @@
         }
         return StringifySucceeded;
     }
 
     if (value.isBigInt()) {
-        throwTypeError(m_exec, scope, "JSON.stringify cannot serialize BigInt."_s);
+        throwTypeError(m_globalObject, scope, "JSON.stringify cannot serialize BigInt."_s);
         return StringifyFailed;
     }
 
     if (!value.isObject())
         return StringifyFailed;
@@ -403,17 +409,17 @@
         return StringifyFailed;
 
     // Handle cycle detection, and put the holder on the stack.
     for (unsigned i = 0; i < m_holderStack.size(); i++) {
         if (m_holderStack[i].object() == object) {
-            throwTypeError(m_exec, scope, "JSON.stringify cannot serialize cyclic structures."_s);
+            throwTypeError(m_globalObject, scope, "JSON.stringify cannot serialize cyclic structures."_s);
             return StringifyFailed;
         }
     }
 
     bool holderStackWasEmpty = m_holderStack.isEmpty();
-    m_holderStack.append(Holder(m_exec, object));
+    m_holderStack.append(Holder(m_globalObject, object));
     m_objectStack.appendWithCrashOnOverflow(object);
     RETURN_IF_EXCEPTION(scope, StringifyFailed);
     if (!holderStackWasEmpty)
         return StringifySucceeded;
 
@@ -456,14 +462,14 @@
         return;
     builder.append('\n');
     builder.append(m_indent);
 }
 
-inline Stringifier::Holder::Holder(ExecState* exec, JSObject* object)
+inline Stringifier::Holder::Holder(JSGlobalObject* globalObject, JSObject* object)
     : m_object(object)
     , m_isJSArray(isJSArray(object))
-    , m_isArray(JSC::isArray(exec, object))
+    , m_isArray(JSC::isArray(globalObject, object))
 {
 }
 
 inline Stringifier::Holder::Holder(RootHolderTag, JSObject* object)
     : m_object(object)
@@ -474,32 +480,26 @@
 
 bool Stringifier::Holder::appendNextProperty(Stringifier& stringifier, StringBuilder& builder)
 {
     ASSERT(m_index <= m_size);
 
-    ExecState* exec = stringifier.m_exec;
-    VM& vm = exec->vm();
+    JSGlobalObject* globalObject = stringifier.m_globalObject;
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     // First time through, initialize.
     if (!m_index) {
         if (m_isArray) {
-            if (m_isJSArray)
-                m_size = asArray(m_object)->length();
-            else {
-                JSValue value = m_object->get(exec, vm.propertyNames->length);
-                RETURN_IF_EXCEPTION(scope, false);
-                m_size = value.toUInt32(exec);
-                RETURN_IF_EXCEPTION(scope, false);
-            }
+            m_size = toLength(globalObject, m_object);
+            RETURN_IF_EXCEPTION(scope, false);
             builder.append('[');
         } else {
             if (stringifier.m_usingArrayReplacer)
                 m_propertyNames = stringifier.m_arrayReplacerPropertyNames.data();
             else {
                 PropertyNameArray objectPropertyNames(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
-                m_object->methodTable(vm)->getOwnPropertyNames(m_object, exec, objectPropertyNames, EnumerationMode());
+                m_object->methodTable(vm)->getOwnPropertyNames(m_object, globalObject, objectPropertyNames, EnumerationMode());
                 RETURN_IF_EXCEPTION(scope, false);
                 m_propertyNames = objectPropertyNames.releaseData();
             }
             m_size = m_propertyNames->propertyNameVector().size();
             builder.append('{');
@@ -523,18 +523,18 @@
     unsigned rollBackPoint = 0;
     StringifyResult stringifyResult;
     if (m_isArray) {
         // Get the value.
         JSValue value;
-        if (m_isJSArray && asArray(m_object)->canGetIndexQuickly(index))
-            value = asArray(m_object)->getIndexQuickly(index);
+        if (m_isJSArray && m_object->canGetIndexQuickly(index))
+            value = m_object->getIndexQuickly(index);
         else {
             PropertySlot slot(m_object, PropertySlot::InternalMethodType::Get);
-            bool hasProperty = m_object->getPropertySlot(exec, index, slot);
+            bool hasProperty = m_object->getPropertySlot(globalObject, index, slot);
             EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
             if (hasProperty)
-                value = slot.getValue(exec, index);
+                value = slot.getValue(globalObject, index);
             else
                 value = jsUndefined();
             RETURN_IF_EXCEPTION(scope, false);
         }
 
@@ -548,15 +548,15 @@
         ASSERT(stringifyResult != StringifyFailedDueToUndefinedOrSymbolValue);
     } else {
         // Get the value.
         PropertySlot slot(m_object, PropertySlot::InternalMethodType::Get);
         Identifier& propertyName = m_propertyNames->propertyNameVector()[index];
-        bool hasProperty = m_object->getPropertySlot(exec, propertyName, slot);
+        bool hasProperty = m_object->getPropertySlot(globalObject, propertyName, slot);
         EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
         if (!hasProperty)
             return true;
-        JSValue value = slot.getValue(exec, propertyName);
+        JSValue value = slot.getValue(globalObject, propertyName);
         RETURN_IF_EXCEPTION(scope, false);
 
         rollBackPoint = builder.length();
 
         // Append the separator string.
@@ -611,12 +611,12 @@
 
 class Walker {
     WTF_MAKE_NONCOPYABLE(Walker);
     WTF_FORBID_HEAP_ALLOCATION;
 public:
-    Walker(ExecState* exec, JSObject* function, CallType callType, CallData callData)
-        : m_exec(exec)
+    Walker(JSGlobalObject* globalObject, JSObject* function, CallType callType, CallData callData)
+        : m_globalObject(globalObject)
         , m_function(function)
         , m_callType(callType)
         , m_callData(callData)
     {
     }
@@ -626,28 +626,28 @@
     {
         MarkedArgumentBuffer args;
         args.append(property);
         args.append(unfiltered);
         ASSERT(!args.hasOverflowed());
-        return call(m_exec, m_function, m_callType, m_callData, thisObj, args);
+        return call(m_globalObject, m_function, m_callType, m_callData, thisObj, args);
     }
 
     friend class Holder;
 
-    ExecState* m_exec;
+    JSGlobalObject* m_globalObject;
     JSObject* m_function;
     CallType m_callType;
     CallData m_callData;
 };
 
 // We clamp recursion well beyond anything reasonable.
-static const unsigned maximumFilterRecursion = 40000;
+static constexpr unsigned maximumFilterRecursion = 40000;
 enum WalkerState { StateUnknown, ArrayStartState, ArrayStartVisitMember, ArrayEndVisitMember,
                                  ObjectStartState, ObjectStartVisitMember, ObjectEndVisitMember };
 NEVER_INLINE JSValue Walker::walk(JSValue unfiltered)
 {
-    VM& vm = m_exec->vm();
+    VM& vm = m_globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     Vector<PropertyNameArray, 16, UnsafeVectorOverflow> propertyStack;
     Vector<uint32_t, 16, UnsafeVectorOverflow> indexStack;
     MarkedArgumentBuffer markedStack;
@@ -661,23 +661,27 @@
     while (1) {
         switch (state) {
             arrayStartState:
             case ArrayStartState: {
                 ASSERT(inValue.isObject());
-                ASSERT(asObject(inValue)->inherits<JSArray>(vm));
+                ASSERT(isArray(m_globalObject, inValue));
+                EXCEPTION_ASSERT(!scope.exception());
+
                 if (markedStack.size() > maximumFilterRecursion)
-                    return throwStackOverflowError(m_exec, scope);
+                    return throwStackOverflowError(m_globalObject, scope);
 
-                JSArray* array = asArray(inValue);
+                JSObject* array = asObject(inValue);
                 markedStack.appendWithCrashOnOverflow(array);
-                arrayLengthStack.append(array->length());
+                unsigned length = toLength(m_globalObject, array);
+                RETURN_IF_EXCEPTION(scope, { });
+                arrayLengthStack.append(length);
                 indexStack.append(0);
             }
             arrayStartVisitMember:
             FALLTHROUGH;
             case ArrayStartVisitMember: {
-                JSArray* array = jsCast<JSArray*>(markedStack.last());
+                JSObject* array = asObject(markedStack.last());
                 uint32_t index = indexStack.last();
                 unsigned arrayLength = arrayLengthStack.last();
                 if (index == arrayLength) {
                     outValue = array;
                     markedStack.removeLast();
@@ -686,15 +690,11 @@
                     break;
                 }
                 if (isJSArray(array) && array->canGetIndexQuickly(index))
                     inValue = array->getIndexQuickly(index);
                 else {
-                    PropertySlot slot(array, PropertySlot::InternalMethodType::Get);
-                    if (array->methodTable(vm)->getOwnPropertySlotByIndex(array, m_exec, index, slot))
-                        inValue = slot.getValue(m_exec, index);
-                    else
-                        inValue = jsUndefined();
+                    inValue = array->get(m_globalObject, index);
                     RETURN_IF_EXCEPTION(scope, { });
                 }
 
                 if (inValue.isObject()) {
                     stateStack.append(ArrayEndVisitMember);
@@ -702,33 +702,33 @@
                 } else
                     outValue = inValue;
                 FALLTHROUGH;
             }
             case ArrayEndVisitMember: {
-                JSArray* array = jsCast<JSArray*>(markedStack.last());
+                JSObject* array = asObject(markedStack.last());
                 JSValue filteredValue = callReviver(array, jsString(vm, String::number(indexStack.last())), outValue);
                 RETURN_IF_EXCEPTION(scope, { });
                 if (filteredValue.isUndefined())
-                    array->methodTable(vm)->deletePropertyByIndex(array, m_exec, indexStack.last());
+                    array->methodTable(vm)->deletePropertyByIndex(array, m_globalObject, indexStack.last());
                 else
-                    array->putDirectIndex(m_exec, indexStack.last(), filteredValue, 0, PutDirectIndexShouldNotThrow);
+                    array->putDirectIndex(m_globalObject, indexStack.last(), filteredValue, 0, PutDirectIndexShouldNotThrow);
                 RETURN_IF_EXCEPTION(scope, { });
                 indexStack.last()++;
                 goto arrayStartVisitMember;
             }
             objectStartState:
             case ObjectStartState: {
                 ASSERT(inValue.isObject());
-                ASSERT(!asObject(inValue)->inherits<JSArray>(vm));
+                ASSERT(!isJSArray(inValue));
                 if (markedStack.size() > maximumFilterRecursion)
-                    return throwStackOverflowError(m_exec, scope);
+                    return throwStackOverflowError(m_globalObject, scope);
 
                 JSObject* object = asObject(inValue);
                 markedStack.appendWithCrashOnOverflow(object);
                 indexStack.append(0);
                 propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
-                object->methodTable(vm)->getOwnPropertyNames(object, m_exec, propertyStack.last(), EnumerationMode());
+                object->methodTable(vm)->getOwnPropertyNames(object, m_globalObject, propertyStack.last(), EnumerationMode());
                 RETURN_IF_EXCEPTION(scope, { });
             }
             objectStartVisitMember:
             FALLTHROUGH;
             case ObjectStartVisitMember: {
@@ -740,16 +740,11 @@
                     markedStack.removeLast();
                     indexStack.removeLast();
                     propertyStack.removeLast();
                     break;
                 }
-                PropertySlot slot(object, PropertySlot::InternalMethodType::Get);
-                if (object->methodTable(vm)->getOwnPropertySlot(object, m_exec, properties[index], slot))
-                    inValue = slot.getValue(m_exec, properties[index]);
-                else
-                    inValue = jsUndefined();
-
+                inValue = object->get(m_globalObject, properties[index]);
                 // The holder may be modified by the reviver function so any lookup may throw
                 RETURN_IF_EXCEPTION(scope, { });
 
                 if (inValue.isObject()) {
                     stateStack.append(ObjectEndVisitMember);
@@ -763,120 +758,119 @@
                 Identifier prop = propertyStack.last()[indexStack.last()];
                 PutPropertySlot slot(object);
                 JSValue filteredValue = callReviver(object, jsString(vm, prop.string()), outValue);
                 RETURN_IF_EXCEPTION(scope, { });
                 if (filteredValue.isUndefined())
-                    object->methodTable(vm)->deleteProperty(object, m_exec, prop);
+                    object->methodTable(vm)->deleteProperty(object, m_globalObject, prop);
                 else
-                    object->methodTable(vm)->put(object, m_exec, prop, filteredValue, slot);
+                    object->methodTable(vm)->put(object, m_globalObject, prop, filteredValue, slot);
                 RETURN_IF_EXCEPTION(scope, { });
                 indexStack.last()++;
                 goto objectStartVisitMember;
             }
             stateUnknown:
             case StateUnknown:
                 if (!inValue.isObject()) {
                     outValue = inValue;
                     break;
                 }
-                JSObject* object = asObject(inValue);
-                if (object->inherits<JSArray>(vm))
+                bool valueIsArray = isArray(m_globalObject, inValue);
+                RETURN_IF_EXCEPTION(scope, { });
+                if (valueIsArray)
                     goto arrayStartState;
                 goto objectStartState;
         }
         if (stateStack.isEmpty())
             break;
 
         state = stateStack.last();
         stateStack.removeLast();
     }
-    JSObject* finalHolder = constructEmptyObject(m_exec);
-    PutPropertySlot slot(finalHolder);
-    finalHolder->methodTable(vm)->put(finalHolder, m_exec, vm.propertyNames->emptyIdentifier, outValue, slot);
-    RETURN_IF_EXCEPTION(scope, { });
+    JSObject* finalHolder = constructEmptyObject(m_globalObject);
+    finalHolder->putDirect(vm, vm.propertyNames->emptyIdentifier, outValue);
     RELEASE_AND_RETURN(scope, callReviver(finalHolder, jsEmptyString(vm), outValue));
 }
 
 // ECMA-262 v5 15.12.2
-EncodedJSValue JSC_HOST_CALL JSONProtoFuncParse(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL JSONProtoFuncParse(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
-    auto viewWithString = exec->argument(0).toString(exec)->viewWithUnderlyingString(exec);
+    auto viewWithString = callFrame->argument(0).toString(globalObject)->viewWithUnderlyingString(globalObject);
     RETURN_IF_EXCEPTION(scope, { });
     StringView view = viewWithString.view;
 
     JSValue unfiltered;
     if (view.is8Bit()) {
-        LiteralParser<LChar> jsonParser(exec, view.characters8(), view.length(), StrictJSON);
+        LiteralParser<LChar> jsonParser(globalObject, view.characters8(), view.length(), StrictJSON);
         unfiltered = jsonParser.tryLiteralParse();
         EXCEPTION_ASSERT(!scope.exception() || !unfiltered);
         if (!unfiltered) {
             RETURN_IF_EXCEPTION(scope, { });
-            return throwVMError(exec, scope, createSyntaxError(exec, jsonParser.getErrorMessage()));
+            return throwVMError(globalObject, scope, createSyntaxError(globalObject, jsonParser.getErrorMessage()));
         }
     } else {
-        LiteralParser<UChar> jsonParser(exec, view.characters16(), view.length(), StrictJSON);
+        LiteralParser<UChar> jsonParser(globalObject, view.characters16(), view.length(), StrictJSON);
         unfiltered = jsonParser.tryLiteralParse();
         EXCEPTION_ASSERT(!scope.exception() || !unfiltered);
         if (!unfiltered) {
             RETURN_IF_EXCEPTION(scope, { });
-            return throwVMError(exec, scope, createSyntaxError(exec, jsonParser.getErrorMessage()));
+            return throwVMError(globalObject, scope, createSyntaxError(globalObject, jsonParser.getErrorMessage()));
         }
     }
 
-    if (exec->argumentCount() < 2)
+    if (callFrame->argumentCount() < 2)
         return JSValue::encode(unfiltered);
 
-    JSValue function = exec->uncheckedArgument(1);
+    JSValue function = callFrame->uncheckedArgument(1);
     CallData callData;
     CallType callType = getCallData(vm, function, callData);
     if (callType == CallType::None)
         return JSValue::encode(unfiltered);
     scope.release();
-    Walker walker(exec, asObject(function), callType, callData);
+    Walker walker(globalObject, asObject(function), callType, callData);
     return JSValue::encode(walker.walk(unfiltered));
 }
 
 // ECMA-262 v5 15.12.3
-EncodedJSValue JSC_HOST_CALL JSONProtoFuncStringify(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL JSONProtoFuncStringify(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    Stringifier stringifier(exec, exec->argument(1), exec->argument(2));
+    Stringifier stringifier(globalObject, callFrame->argument(1), callFrame->argument(2));
     RETURN_IF_EXCEPTION(scope, { });
-    RELEASE_AND_RETURN(scope, JSValue::encode(stringifier.stringify(exec->argument(0))));
+    RELEASE_AND_RETURN(scope, JSValue::encode(stringifier.stringify(callFrame->argument(0))));
 }
 
-JSValue JSONParse(ExecState* exec, const String& json)
+JSValue JSONParse(JSGlobalObject* globalObject, const String& json)
 {
     if (json.isNull())
         return JSValue();
 
     if (json.is8Bit()) {
-        LiteralParser<LChar> jsonParser(exec, json.characters8(), json.length(), StrictJSON);
+        LiteralParser<LChar> jsonParser(globalObject, json.characters8(), json.length(), StrictJSON);
         return jsonParser.tryLiteralParse();
     }
 
-    LiteralParser<UChar> jsonParser(exec, json.characters16(), json.length(), StrictJSON);
+    LiteralParser<UChar> jsonParser(globalObject, json.characters16(), json.length(), StrictJSON);
     return jsonParser.tryLiteralParse();
 }
 
-String JSONStringify(ExecState* exec, JSValue value, JSValue space)
+String JSONStringify(JSGlobalObject* globalObject, JSValue value, JSValue space)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto throwScope = DECLARE_THROW_SCOPE(vm);
-    Stringifier stringifier(exec, jsNull(), space);
+    Stringifier stringifier(globalObject, jsNull(), space);
     RETURN_IF_EXCEPTION(throwScope, { });
     JSValue result = stringifier.stringify(value);
     if (UNLIKELY(throwScope.exception()) || result.isUndefinedOrNull())
         return String();
-    return result.getString(exec);
+    return result.getString(globalObject);
 }
 
-String JSONStringify(ExecState* exec, JSValue value, unsigned indent)
+String JSONStringify(JSGlobalObject* globalObject, JSValue value, unsigned indent)
 {
-    return JSONStringify(exec, value, jsNumber(indent));
+    return JSONStringify(globalObject, value, jsNumber(indent));
 }
 
 } // namespace JSC

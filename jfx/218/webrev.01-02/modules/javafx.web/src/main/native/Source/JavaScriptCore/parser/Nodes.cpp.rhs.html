<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Nodes.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2 *  Copyright (C) 1999-2002 Harri Porten (porten@kde.org)
  3 *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
  4 *  Copyright (C) 2003-2009, 2013, 2016 Apple Inc. All rights reserved.
  5 *  Copyright (C) 2007 Cameron Zwarich (cwzwarich@uwaterloo.ca)
  6 *  Copyright (C) 2007 Maks Orlovich
  7 *  Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
  8 *
  9 *  This library is free software; you can redistribute it and/or
 10 *  modify it under the terms of the GNU Library General Public
 11 *  License as published by the Free Software Foundation; either
 12 *  version 2 of the License, or (at your option) any later version.
 13 *
 14 *  This library is distributed in the hope that it will be useful,
 15 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 16 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 17 *  Library General Public License for more details.
 18 *
 19 *  You should have received a copy of the GNU Library General Public License
 20 *  along with this library; see the file COPYING.LIB.  If not, write to
 21 *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 22 *  Boston, MA 02110-1301, USA.
 23 *
 24 */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;Nodes.h&quot;
 28 #include &quot;NodeConstructors.h&quot;
 29 
 30 #include &quot;JSCInlines.h&quot;
 31 #include &quot;ModuleScopeData.h&quot;
 32 #include &lt;wtf/Assertions.h&gt;
 33 
 34 namespace JSC {
 35 
<a name="1" id="anc1"></a><span class="line-added"> 36 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(ParserArenaRoot);</span>
<span class="line-added"> 37 </span>
 38 // ------------------------------ StatementNode --------------------------------
 39 
 40 void StatementNode::setLoc(unsigned firstLine, unsigned lastLine, int startOffset, int lineStartOffset)
 41 {
 42     m_lastLine = lastLine;
 43     m_position = JSTextPosition(firstLine, startOffset, lineStartOffset);
 44     ASSERT(m_position.offset &gt;= m_position.lineStartOffset);
 45 }
 46 
 47 // ------------------------------ SourceElements --------------------------------
 48 
 49 void SourceElements::append(StatementNode* statement)
 50 {
 51     if (statement-&gt;isEmptyStatement())
 52         return;
 53 
 54     if (!m_head) {
 55         m_head = statement;
 56         m_tail = statement;
 57         return;
 58     }
 59 
 60     m_tail-&gt;setNext(statement);
 61     m_tail = statement;
 62 }
 63 
 64 StatementNode* SourceElements::singleStatement() const
 65 {
 66     return m_head == m_tail ? m_head : nullptr;
 67 }
 68 
 69 StatementNode* SourceElements::lastStatement() const
 70 {
 71     return m_tail;
 72 }
 73 
 74 bool SourceElements::hasCompletionValue() const
 75 {
 76     for (StatementNode* statement = m_head; statement; statement = statement-&gt;next()) {
 77         if (statement-&gt;hasCompletionValue())
 78             return true;
 79     }
 80 
 81     return false;
 82 }
 83 
 84 bool SourceElements::hasEarlyBreakOrContinue() const
 85 {
 86     for (StatementNode* statement = m_head; statement; statement = statement-&gt;next()) {
 87         if (statement-&gt;isBreak() || statement-&gt;isContinue())
 88             return true;
 89         if (statement-&gt;hasCompletionValue())
 90             return false;
 91     }
 92 
 93     return false;
 94 }
 95 
 96 // ------------------------------ BlockNode ------------------------------------
 97 
 98 StatementNode* BlockNode::lastStatement() const
 99 {
100     return m_statements ? m_statements-&gt;lastStatement() : nullptr;
101 }
102 
103 StatementNode* BlockNode::singleStatement() const
104 {
105     return m_statements ? m_statements-&gt;singleStatement() : nullptr;
106 }
107 
108 bool BlockNode::hasCompletionValue() const
109 {
110     return m_statements ? m_statements-&gt;hasCompletionValue() : false;
111 }
112 
113 bool BlockNode::hasEarlyBreakOrContinue() const
114 {
115     return m_statements ? m_statements-&gt;hasEarlyBreakOrContinue() : false;
116 }
117 
118 // ------------------------------ ScopeNode -----------------------------
119 
120 ScopeNode::ScopeNode(ParserArena&amp; parserArena, const JSTokenLocation&amp; startLocation, const JSTokenLocation&amp; endLocation, bool inStrictContext)
121     : StatementNode(endLocation)
122     , ParserArenaRoot(parserArena)
123     , m_startLineNumber(startLocation.line)
124     , m_startStartOffset(startLocation.startOffset)
125     , m_startLineStartOffset(startLocation.lineStartOffset)
126     , m_features(inStrictContext ? StrictModeFeature : NoFeatures)
127     , m_innerArrowFunctionCodeFeatures(NoInnerArrowFunctionFeatures)
128     , m_numConstants(0)
129     , m_statements(0)
130 {
131 }
132 
133 ScopeNode::ScopeNode(ParserArena&amp; parserArena, const JSTokenLocation&amp; startLocation, const JSTokenLocation&amp; endLocation, const SourceCode&amp; source, SourceElements* children, VariableEnvironment&amp; varEnvironment, FunctionStack&amp;&amp; funcStack, VariableEnvironment&amp; lexicalVariables, UniquedStringImplPtrSet&amp;&amp; sloppyModeHoistedFunctions, CodeFeatures features, InnerArrowFunctionCodeFeatures innerArrowFunctionCodeFeatures, int numConstants)
134     : StatementNode(endLocation)
135     , ParserArenaRoot(parserArena)
136     , VariableEnvironmentNode(lexicalVariables, WTFMove(funcStack))
137     , m_startLineNumber(startLocation.line)
138     , m_startStartOffset(startLocation.startOffset)
139     , m_startLineStartOffset(startLocation.lineStartOffset)
140     , m_features(features)
141     , m_innerArrowFunctionCodeFeatures(innerArrowFunctionCodeFeatures)
142     , m_source(source)
143     , m_sloppyModeHoistedFunctions(WTFMove(sloppyModeHoistedFunctions))
144     , m_numConstants(numConstants)
145     , m_statements(children)
146 {
147     m_varDeclarations.swap(varEnvironment);
148 }
149 
150 StatementNode* ScopeNode::singleStatement() const
151 {
152     return m_statements ? m_statements-&gt;singleStatement() : nullptr;
153 }
154 
155 bool ScopeNode::hasCompletionValue() const
156 {
157     return m_statements ? m_statements-&gt;hasCompletionValue() : false;
158 }
159 
160 bool ScopeNode::hasEarlyBreakOrContinue() const
161 {
162     return m_statements ? m_statements-&gt;hasEarlyBreakOrContinue() : false;
163 }
164 
165 // ------------------------------ ProgramNode -----------------------------
166 
167 ProgramNode::ProgramNode(ParserArena&amp; parserArena, const JSTokenLocation&amp; startLocation, const JSTokenLocation&amp; endLocation, unsigned startColumn, unsigned endColumn, SourceElements* children, VariableEnvironment&amp; varEnvironment, FunctionStack&amp;&amp; funcStack, VariableEnvironment&amp; lexicalVariables, UniquedStringImplPtrSet&amp;&amp; sloppyModeHoistedFunctions, FunctionParameters*, const SourceCode&amp; source, CodeFeatures features, InnerArrowFunctionCodeFeatures innerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;)
168     : ScopeNode(parserArena, startLocation, endLocation, source, children, varEnvironment, WTFMove(funcStack), lexicalVariables, WTFMove(sloppyModeHoistedFunctions), features, innerArrowFunctionCodeFeatures, numConstants)
169     , m_startColumn(startColumn)
170     , m_endColumn(endColumn)
171 {
172 }
173 
174 // ------------------------------ ModuleProgramNode -----------------------------
175 
176 ModuleProgramNode::ModuleProgramNode(ParserArena&amp; parserArena, const JSTokenLocation&amp; startLocation, const JSTokenLocation&amp; endLocation, unsigned startColumn, unsigned endColumn, SourceElements* children, VariableEnvironment&amp; varEnvironment, FunctionStack&amp;&amp; funcStack, VariableEnvironment&amp; lexicalVariables, UniquedStringImplPtrSet&amp;&amp; sloppyModeHoistedFunctions, FunctionParameters*, const SourceCode&amp; source, CodeFeatures features, InnerArrowFunctionCodeFeatures innerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp; moduleScopeData)
177     : ScopeNode(parserArena, startLocation, endLocation, source, children, varEnvironment, WTFMove(funcStack), lexicalVariables, WTFMove(sloppyModeHoistedFunctions), features, innerArrowFunctionCodeFeatures, numConstants)
178     , m_startColumn(startColumn)
179     , m_endColumn(endColumn)
180     , m_moduleScopeData(*WTFMove(moduleScopeData))
181 {
182 }
183 
184 // ------------------------------ EvalNode -----------------------------
185 
186 EvalNode::EvalNode(ParserArena&amp; parserArena, const JSTokenLocation&amp; startLocation, const JSTokenLocation&amp; endLocation, unsigned, unsigned endColumn, SourceElements* children, VariableEnvironment&amp; varEnvironment, FunctionStack&amp;&amp; funcStack, VariableEnvironment&amp; lexicalVariables, UniquedStringImplPtrSet&amp;&amp; sloppyModeHoistedFunctions, FunctionParameters*, const SourceCode&amp; source, CodeFeatures features, InnerArrowFunctionCodeFeatures innerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;)
187     : ScopeNode(parserArena, startLocation, endLocation, source, children, varEnvironment, WTFMove(funcStack), lexicalVariables, WTFMove(sloppyModeHoistedFunctions), features, innerArrowFunctionCodeFeatures, numConstants)
188     , m_endColumn(endColumn)
189 {
190 }
191 
192 // ------------------------------ FunctionMetadataNode -----------------------------
193 
194 FunctionMetadataNode::FunctionMetadataNode(
195     ParserArena&amp;, const JSTokenLocation&amp; startLocation,
196     const JSTokenLocation&amp; endLocation, unsigned startColumn, unsigned endColumn,
197     int functionKeywordStart, int functionNameStart, int parametersStart, bool isInStrictContext,
198     ConstructorKind constructorKind, SuperBinding superBinding, unsigned parameterCount, SourceParseMode mode, bool isArrowFunctionBodyExpression)
199         : Node(endLocation)
200         , m_isInStrictContext(isInStrictContext)
201         , m_superBinding(static_cast&lt;unsigned&gt;(superBinding))
202         , m_constructorKind(static_cast&lt;unsigned&gt;(constructorKind))
<a name="2" id="anc2"></a><span class="line-added">203         , m_needsClassFieldInitializer(static_cast&lt;unsigned&gt;(NeedsClassFieldInitializer::No))</span>
204         , m_isArrowFunctionBodyExpression(isArrowFunctionBodyExpression)
205         , m_parseMode(mode)
206         , m_startColumn(startColumn)
207         , m_endColumn(endColumn)
208         , m_functionKeywordStart(functionKeywordStart)
209         , m_functionNameStart(functionNameStart)
210         , m_parametersStart(parametersStart)
211         , m_startStartOffset(startLocation.startOffset)
212         , m_parameterCount(parameterCount)
213 {
214     ASSERT(m_superBinding == static_cast&lt;unsigned&gt;(superBinding));
215     ASSERT(m_constructorKind == static_cast&lt;unsigned&gt;(constructorKind));
216 }
217 
218 FunctionMetadataNode::FunctionMetadataNode(
219     const JSTokenLocation&amp; startLocation,
220     const JSTokenLocation&amp; endLocation, unsigned startColumn, unsigned endColumn,
221     int functionKeywordStart, int functionNameStart, int parametersStart, bool isInStrictContext,
222     ConstructorKind constructorKind, SuperBinding superBinding, unsigned parameterCount, SourceParseMode mode, bool isArrowFunctionBodyExpression)
223         : Node(endLocation)
224         , m_isInStrictContext(isInStrictContext)
225         , m_superBinding(static_cast&lt;unsigned&gt;(superBinding))
226         , m_constructorKind(static_cast&lt;unsigned&gt;(constructorKind))
<a name="3" id="anc3"></a><span class="line-added">227         , m_needsClassFieldInitializer(static_cast&lt;unsigned&gt;(NeedsClassFieldInitializer::No))</span>
228         , m_isArrowFunctionBodyExpression(isArrowFunctionBodyExpression)
229         , m_parseMode(mode)
230         , m_startColumn(startColumn)
231         , m_endColumn(endColumn)
232         , m_functionKeywordStart(functionKeywordStart)
233         , m_functionNameStart(functionNameStart)
234         , m_parametersStart(parametersStart)
235         , m_startStartOffset(startLocation.startOffset)
236         , m_parameterCount(parameterCount)
237 {
238     ASSERT(m_superBinding == static_cast&lt;unsigned&gt;(superBinding));
239     ASSERT(m_constructorKind == static_cast&lt;unsigned&gt;(constructorKind));
240 }
241 
242 void FunctionMetadataNode::finishParsing(const SourceCode&amp; source, const Identifier&amp; ident, FunctionMode functionMode)
243 {
244     m_source = source;
245     m_ident = ident;
246     m_functionMode = functionMode;
247 }
248 
249 void FunctionMetadataNode::setEndPosition(JSTextPosition position)
250 {
251     m_lastLine = position.line;
252     m_endColumn = position.offset - position.lineStartOffset;
253 }
254 
255 bool FunctionMetadataNode::operator==(const FunctionMetadataNode&amp; other) const
256 {
<a name="4" id="anc4"></a><span class="line-modified">257     return m_parseMode == other.m_parseMode</span>
258         &amp;&amp; m_isInStrictContext == other.m_isInStrictContext
259         &amp;&amp; m_superBinding == other.m_superBinding
260         &amp;&amp; m_constructorKind == other.m_constructorKind
261         &amp;&amp; m_isArrowFunctionBodyExpression == other.m_isArrowFunctionBodyExpression
262         &amp;&amp; m_ident == other.m_ident
263         &amp;&amp; m_ecmaName == other.m_ecmaName
<a name="5" id="anc5"></a><span class="line-modified">264         &amp;&amp; m_functionMode == other.m_functionMode</span>
<span class="line-modified">265         &amp;&amp; m_startColumn == other.m_startColumn</span>
<span class="line-modified">266         &amp;&amp; m_endColumn == other.m_endColumn</span>
<span class="line-modified">267         &amp;&amp; m_functionKeywordStart == other.m_functionKeywordStart</span>
<span class="line-modified">268         &amp;&amp; m_functionNameStart == other.m_functionNameStart</span>
<span class="line-modified">269         &amp;&amp; m_parametersStart == other.m_parametersStart</span>
<span class="line-modified">270         &amp;&amp; m_source == other.m_source</span>
<span class="line-modified">271         &amp;&amp; m_classSource == other.m_classSource</span>
<span class="line-modified">272         &amp;&amp; m_startStartOffset == other.m_startStartOffset</span>
<span class="line-modified">273         &amp;&amp; m_parameterCount == other.m_parameterCount</span>
<span class="line-modified">274         &amp;&amp; m_lastLine == other.m_lastLine</span>
275         &amp;&amp; m_position == other.m_position;
276 }
277 
278 void FunctionMetadataNode::dump(PrintStream&amp; stream) const
279 {
280     stream.println(&quot;m_parseMode &quot;, static_cast&lt;uint32_t&gt;(m_parseMode));
281     stream.println(&quot;m_isInStrictContext &quot;, m_isInStrictContext);
282     stream.println(&quot;m_superBinding &quot;, m_superBinding);
283     stream.println(&quot;m_constructorKind &quot;, m_constructorKind);
284     stream.println(&quot;m_isArrowFunctionBodyExpression &quot;, m_isArrowFunctionBodyExpression);
285     stream.println(&quot;m_ident &quot;, m_ident);
286     stream.println(&quot;m_ecmaName &quot;, m_ecmaName);
287     stream.println(&quot;m_functionMode &quot;, static_cast&lt;uint32_t&gt;(m_functionMode));
288     stream.println(&quot;m_startColumn &quot;, m_startColumn);
289     stream.println(&quot;m_endColumn &quot;, m_endColumn);
290     stream.println(&quot;m_functionKeywordStart &quot;, m_functionKeywordStart);
291     stream.println(&quot;m_functionNameStart &quot;, m_functionNameStart);
292     stream.println(&quot;m_parametersStart &quot;, m_parametersStart);
293     stream.println(&quot;m_classSource.isNull() &quot;, m_classSource.isNull());
294     stream.println(&quot;m_startStartOffset &quot;, m_startStartOffset);
295     stream.println(&quot;m_parameterCount &quot;, m_parameterCount);
296     stream.println(&quot;m_lastLine &quot;, m_lastLine);
297     stream.println(&quot;position().line &quot;, position().line);
298     stream.println(&quot;position().offset &quot;, position().offset);
299     stream.println(&quot;position().lineStartOffset &quot;, position().lineStartOffset);
300 }
301 
302 // ------------------------------ FunctionNode -----------------------------
303 
304 FunctionNode::FunctionNode(ParserArena&amp; parserArena, const JSTokenLocation&amp; startLocation, const JSTokenLocation&amp; endLocation, unsigned startColumn, unsigned endColumn, SourceElements* children, VariableEnvironment&amp; varEnvironment, FunctionStack&amp;&amp; funcStack, VariableEnvironment&amp; lexicalVariables, UniquedStringImplPtrSet&amp;&amp; sloppyModeHoistedFunctions, FunctionParameters* parameters, const SourceCode&amp; sourceCode, CodeFeatures features, InnerArrowFunctionCodeFeatures innerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;)
305     : ScopeNode(parserArena, startLocation, endLocation, sourceCode, children, varEnvironment, WTFMove(funcStack), lexicalVariables, WTFMove(sloppyModeHoistedFunctions), features, innerArrowFunctionCodeFeatures, numConstants)
306     , m_parameters(parameters)
307     , m_startColumn(startColumn)
308     , m_endColumn(endColumn)
309 {
310 }
311 
312 void FunctionNode::finishParsing(const Identifier&amp; ident, FunctionMode functionMode)
313 {
314     ASSERT(!source().isNull());
315     m_ident = ident;
316     m_functionMode = functionMode;
317 }
318 
319 bool PropertyListNode::hasStaticallyNamedProperty(const Identifier&amp; propName)
320 {
321     PropertyListNode* list = this;
322     while (list) {
323         if (list-&gt;m_node-&gt;isStaticClassProperty()) {
324             const Identifier* currentNodeName = list-&gt;m_node-&gt;name();
325             if (currentNodeName &amp;&amp; *currentNodeName == propName)
326                 return true;
327         }
328         list = list-&gt;m_next;
329     }
330     return false;
331 }
332 
<a name="6" id="anc6"></a><span class="line-added">333 // FIXME: calculate this feature once when parsing the property list.</span>
<span class="line-added">334 // https://bugs.webkit.org/show_bug.cgi?id=206174</span>
<span class="line-added">335 bool PropertyListNode::shouldCreateLexicalScopeForClass(PropertyListNode* list)</span>
<span class="line-added">336 {</span>
<span class="line-added">337     while (list) {</span>
<span class="line-added">338         if (list-&gt;m_node-&gt;isComputedClassField())</span>
<span class="line-added">339             return true;</span>
<span class="line-added">340         list = list-&gt;m_next;</span>
<span class="line-added">341     }</span>
<span class="line-added">342     return false;</span>
<span class="line-added">343 }</span>
<span class="line-added">344 </span>
<span class="line-added">345 // ------------------------------ ClassExprNode -----------------------------</span>
<span class="line-added">346 </span>
<span class="line-added">347 // FIXME: calculate this feature once when parsing the property list.</span>
<span class="line-added">348 // https://bugs.webkit.org/show_bug.cgi?id=206174</span>
<span class="line-added">349 bool PropertyListNode::hasInstanceFields() const</span>
<span class="line-added">350 {</span>
<span class="line-added">351     for (auto list = this; list; list = list-&gt;m_next) {</span>
<span class="line-added">352         if (list-&gt;m_node-&gt;isInstanceClassField())</span>
<span class="line-added">353             return true;</span>
<span class="line-added">354     }</span>
<span class="line-added">355     return false;</span>
<span class="line-added">356 }</span>
<span class="line-added">357 </span>
358 VariableEnvironmentNode::VariableEnvironmentNode(VariableEnvironment&amp; lexicalVariables)
359 {
360     m_lexicalVariables.swap(lexicalVariables);
361 }
362 
363 VariableEnvironmentNode::VariableEnvironmentNode(VariableEnvironment&amp; lexicalVariables, FunctionStack&amp;&amp; functionStack)
364 {
365     m_lexicalVariables.swap(lexicalVariables);
366     m_functionStack = WTFMove(functionStack);
367 }
368 
369 } // namespace JSC
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
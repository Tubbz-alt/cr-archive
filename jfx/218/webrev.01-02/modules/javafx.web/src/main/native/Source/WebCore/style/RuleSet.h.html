<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/style/RuleSet.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  * Copyright (C) 2003-2019 Apple Inc. All rights reserved.
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;MediaList.h&quot;
 25 #include &quot;RuleData.h&quot;
 26 #include &quot;RuleFeature.h&quot;
 27 #include &quot;SelectorCompiler.h&quot;
 28 #include &quot;StyleRule.h&quot;
 29 #include &lt;wtf/Forward.h&gt;
 30 #include &lt;wtf/HashMap.h&gt;
 31 #include &lt;wtf/VectorHash.h&gt;
 32 #include &lt;wtf/text/AtomString.h&gt;
 33 #include &lt;wtf/text/AtomStringHash.h&gt;
 34 
 35 namespace WebCore {
 36 
 37 class CSSSelector;
 38 class MediaQueryEvaluator;
 39 class StyleSheetContents;
 40 
 41 namespace Style {
 42 
 43 class Resolver;
 44 class RuleSet;
 45 
 46 using InvalidationRuleSetVector = Vector&lt;RefPtr&lt;const RuleSet&gt;, 1&gt;;
 47 
 48 struct DynamicMediaQueryEvaluationChanges {
 49     enum class Type { InvalidateStyle, ResetStyle };
 50     Type type;
 51     InvalidationRuleSetVector invalidationRuleSets { };
 52 
 53     void append(DynamicMediaQueryEvaluationChanges&amp;&amp; other)
 54     {
 55         type = std::max(type, other.type);
 56         if (type == Type::ResetStyle)
 57             invalidationRuleSets.clear();
 58         else
 59             invalidationRuleSets.appendVector(WTFMove(other.invalidationRuleSets));
 60     };
 61 };
 62 
 63 class RuleSet : public RefCounted&lt;RuleSet&gt; {
 64     WTF_MAKE_NONCOPYABLE(RuleSet);
 65 public:
 66     static Ref&lt;RuleSet&gt; create() { return adoptRef(*new RuleSet); }
 67 
 68     ~RuleSet();
 69 
 70     typedef Vector&lt;RuleData, 1&gt; RuleDataVector;
 71     typedef HashMap&lt;AtomString, std::unique_ptr&lt;RuleDataVector&gt;&gt; AtomRuleMap;
 72 
 73     struct DynamicMediaQueryRules {
 74         Vector&lt;Ref&lt;const MediaQuerySet&gt;&gt; mediaQuerySets;
 75         HashSet&lt;size_t, DefaultHash&lt;size_t&gt;::Hash, WTF::UnsignedWithZeroKeyHashTraits&lt;size_t&gt;&gt; affectedRulePositions;
 76         Vector&lt;RuleFeature&gt; ruleFeatures;
 77         bool requiresFullReset { false };
 78         bool result { true };
 79     };
 80 
 81     struct MediaQueryCollector {
 82         ~MediaQueryCollector();
 83 
 84         const MediaQueryEvaluator&amp; evaluator;
 85         const bool collectDynamic { false };
 86 
 87         struct DynamicContext {
 88             Ref&lt;const MediaQuerySet&gt; set;
 89             Vector&lt;size_t&gt; affectedRulePositions { };
 90             Vector&lt;RuleFeature&gt; ruleFeatures { };
 91         };
 92         Vector&lt;DynamicContext&gt; dynamicContextStack { };
 93 
 94         Vector&lt;DynamicMediaQueryRules&gt; dynamicMediaQueryRules { };
 95         bool didMutateResolverWithinDynamicMediaQuery { false };
 96         bool hasViewportDependentMediaQueries { false };
 97 
 98         bool pushAndEvaluate(const MediaQuerySet*);
 99         void pop(const MediaQuerySet*);
100         void didMutateResolver();
101         void addRuleIfNeeded(const RuleData&amp;);
102     };
103 
104     void addRulesFromSheet(StyleSheetContents&amp;, const MediaQueryEvaluator&amp;);
105     void addRulesFromSheet(StyleSheetContents&amp;, MediaQuerySet* sheetQuery, const MediaQueryEvaluator&amp;, Style::Resolver&amp;);
106 
107     void addStyleRule(const StyleRule&amp;, MediaQueryCollector&amp;);
108     void addRule(const StyleRule&amp;, unsigned selectorIndex, unsigned selectorListIndex, MediaQueryCollector* = nullptr);
109     void addPageRule(StyleRulePage&amp;);
110     void addToRuleSet(const AtomString&amp; key, AtomRuleMap&amp;, const RuleData&amp;);
111     void shrinkToFit();
112     void disableAutoShrinkToFit() { m_autoShrinkToFitEnabled = false; }
113 
114     bool hasViewportDependentMediaQueries() const { return m_hasViewportDependentMediaQueries; }
115 
116     Optional&lt;DynamicMediaQueryEvaluationChanges&gt; evaluteDynamicMediaQueryRules(const MediaQueryEvaluator&amp;);
117 
118     const RuleFeatureSet&amp; features() const { return m_features; }
119 
120     const RuleDataVector* idRules(const AtomString&amp; key) const { return m_idRules.get(key); }
121     const RuleDataVector* classRules(const AtomString&amp; key) const { return m_classRules.get(key); }
122     const RuleDataVector* tagRules(const AtomString&amp; key, bool isHTMLName) const;
123     const RuleDataVector* shadowPseudoElementRules(const AtomString&amp; key) const { return m_shadowPseudoElementRules.get(key); }
124     const RuleDataVector* linkPseudoClassRules() const { return &amp;m_linkPseudoClassRules; }
125 #if ENABLE(VIDEO_TRACK)
126     const RuleDataVector* cuePseudoRules() const { return &amp;m_cuePseudoRules; }
127 #endif
128     const RuleDataVector&amp; hostPseudoClassRules() const { return m_hostPseudoClassRules; }
129     const RuleDataVector&amp; slottedPseudoElementRules() const { return m_slottedPseudoElementRules; }
130     const RuleDataVector&amp; partPseudoElementRules() const { return m_partPseudoElementRules; }
131     const RuleDataVector* focusPseudoClassRules() const { return &amp;m_focusPseudoClassRules; }
132     const RuleDataVector* universalRules() const { return &amp;m_universalRules; }
133 
134     const Vector&lt;StyleRulePage*&gt;&amp; pageRules() const { return m_pageRules; }
135 
136     unsigned ruleCount() const { return m_ruleCount; }
137 
138     bool hasShadowPseudoElementRules() const;
139     bool hasHostPseudoClassRulesMatchingInShadowTree() const { return m_hasHostPseudoClassRulesMatchingInShadowTree; }
140 
141 private:
142     RuleSet();
143 
144     enum class AddRulesMode { Normal, ResolverMutationScan };
145     void addRulesFromSheet(StyleSheetContents&amp;, MediaQueryCollector&amp;, Style::Resolver*, AddRulesMode);
146     void addChildRules(const Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp;, MediaQueryCollector&amp;, Style::Resolver*, AddRulesMode);
147     struct CollectedMediaQueryChanges {
148         bool requiredFullReset { false };
149         Vector&lt;size_t&gt; changedQueryIndexes { };
150         Vector&lt;const Vector&lt;RuleFeature&gt;*&gt; ruleFeatures { };
151     };
152     CollectedMediaQueryChanges evaluteDynamicMediaQueryRules(const MediaQueryEvaluator&amp;, size_t startIndex);
153 
154     template&lt;typename Function&gt; void traverseRuleDatas(Function&amp;&amp;);
155 
156 
157     AtomRuleMap m_idRules;
158     AtomRuleMap m_classRules;
159     AtomRuleMap m_tagLocalNameRules;
160     AtomRuleMap m_tagLowercaseLocalNameRules;
161     AtomRuleMap m_shadowPseudoElementRules;
162     RuleDataVector m_linkPseudoClassRules;
163 #if ENABLE(VIDEO_TRACK)
164     RuleDataVector m_cuePseudoRules;
165 #endif
166     RuleDataVector m_hostPseudoClassRules;
167     RuleDataVector m_slottedPseudoElementRules;
168     RuleDataVector m_partPseudoElementRules;
169     RuleDataVector m_focusPseudoClassRules;
170     RuleDataVector m_universalRules;
171     Vector&lt;StyleRulePage*&gt; m_pageRules;
172     unsigned m_ruleCount { 0 };
173     bool m_hasHostPseudoClassRulesMatchingInShadowTree { false };
174     bool m_autoShrinkToFitEnabled { true };
175     RuleFeatureSet m_features;
176     bool m_hasViewportDependentMediaQueries { false };
177     Vector&lt;DynamicMediaQueryRules&gt; m_dynamicMediaQueryRules;
178     HashMap&lt;Vector&lt;size_t&gt;, Ref&lt;const RuleSet&gt;&gt; m_mediaQueryInvalidationRuleSetCache;
179 };
180 
181 inline const RuleSet::RuleDataVector* RuleSet::tagRules(const AtomString&amp; key, bool isHTMLName) const
182 {
183     const AtomRuleMap* tagRules;
184     if (isHTMLName)
185         tagRules = &amp;m_tagLowercaseLocalNameRules;
186     else
187         tagRules = &amp;m_tagLocalNameRules;
188     return tagRules-&gt;get(key);
189 }
190 
191 } // namespace Style
192 } // namespace WebCore
    </pre>
  </body>
</html>
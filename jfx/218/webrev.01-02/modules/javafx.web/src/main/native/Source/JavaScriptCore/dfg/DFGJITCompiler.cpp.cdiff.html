<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGJITCompiler.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGJITCode.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGJITCompiler.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGJITCompiler.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 58,11 ***</span>
  {
      if (UNLIKELY(shouldDumpDisassembly() || m_graph.m_vm.m_perBytecodeProfiler))
          m_disassembler = makeUnique&lt;Disassembler&gt;(dfg);
  #if ENABLE(FTL_JIT)
      m_jitCode-&gt;tierUpInLoopHierarchy = WTFMove(m_graph.m_plan.tierUpInLoopHierarchy());
<span class="line-modified">!     for (unsigned tierUpBytecode : m_graph.m_plan.tierUpAndOSREnterBytecodes())</span>
          m_jitCode-&gt;tierUpEntryTriggers.add(tierUpBytecode, JITCode::TriggerReason::DontTrigger);
  #endif
  }
  
  JITCompiler::~JITCompiler()
<span class="line-new-header">--- 58,11 ---</span>
  {
      if (UNLIKELY(shouldDumpDisassembly() || m_graph.m_vm.m_perBytecodeProfiler))
          m_disassembler = makeUnique&lt;Disassembler&gt;(dfg);
  #if ENABLE(FTL_JIT)
      m_jitCode-&gt;tierUpInLoopHierarchy = WTFMove(m_graph.m_plan.tierUpInLoopHierarchy());
<span class="line-modified">!     for (BytecodeIndex tierUpBytecode : m_graph.m_plan.tierUpAndOSREnterBytecodes())</span>
          m_jitCode-&gt;tierUpEntryTriggers.add(tierUpBytecode, JITCode::TriggerReason::DontTrigger);
  #endif
  }
  
  JITCompiler::~JITCompiler()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 83,29 ***</span>
                  labels.append(info.m_replacementSource);
              m_exitSiteLabels.append(labels);
          }
      }
  
<span class="line-removed">-     MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; osrExitThunk = vm().getCTIStub(osrExitThunkGenerator);</span>
<span class="line-removed">-     auto osrExitThunkLabel = CodeLocationLabel&lt;JITThunkPtrTag&gt;(osrExitThunk.code());</span>
      for (unsigned i = 0; i &lt; m_jitCode-&gt;osrExit.size(); ++i) {
          OSRExitCompilationInfo&amp; info = m_exitCompilationInfo[i];
          JumpList&amp; failureJumps = info.m_failureJumps;
          if (!failureJumps.empty())
              failureJumps.link(this);
          else
              info.m_replacementDestination = label();
  
          jitAssertHasValidCallFrame();
          store32(TrustedImm32(i), &amp;vm().osrExitIndex);
<span class="line-modified">!         if (Options::useProbeOSRExit()) {</span>
<span class="line-removed">-             Jump target = jump();</span>
<span class="line-removed">-             addLinkTask([target, osrExitThunkLabel] (LinkBuffer&amp; linkBuffer) {</span>
<span class="line-removed">-                 linkBuffer.link(target, osrExitThunkLabel);</span>
<span class="line-removed">-             });</span>
<span class="line-removed">-         } else</span>
<span class="line-removed">-             info.m_patchableJump = patchableJump();</span>
      }
  }
  
  void JITCompiler::compileEntry()
  {
<span class="line-new-header">--- 83,21 ---</span>
                  labels.append(info.m_replacementSource);
              m_exitSiteLabels.append(labels);
          }
      }
  
      for (unsigned i = 0; i &lt; m_jitCode-&gt;osrExit.size(); ++i) {
          OSRExitCompilationInfo&amp; info = m_exitCompilationInfo[i];
          JumpList&amp; failureJumps = info.m_failureJumps;
          if (!failureJumps.empty())
              failureJumps.link(this);
          else
              info.m_replacementDestination = label();
  
          jitAssertHasValidCallFrame();
          store32(TrustedImm32(i), &amp;vm().osrExitIndex);
<span class="line-modified">!         info.m_patchableJump = patchableJump();</span>
      }
  }
  
  void JITCompiler::compileEntry()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 147,40 ***</span>
      if (!m_exceptionChecksWithCallFrameRollback.empty()) {
          m_exceptionChecksWithCallFrameRollback.link(this);
  
          copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm().topEntryFrame);
  
<span class="line-modified">!         // lookupExceptionHandlerFromCallerFrame is passed two arguments, the VM and the exec (the CallFrame*).</span>
          move(TrustedImmPtr(&amp;vm()), GPRInfo::argumentGPR0);
<span class="line-modified">!         move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR1);</span>
          addPtr(TrustedImm32(m_graph.stackPointerOffset() * sizeof(Register)), GPRInfo::callFrameRegister, stackPointerRegister);
  
<span class="line-modified">! #if CPU(X86)</span>
<span class="line-removed">-         // FIXME: should use the call abstraction, but this is currently in the SpeculativeJIT layer!</span>
<span class="line-removed">-         poke(GPRInfo::argumentGPR0);</span>
<span class="line-removed">-         poke(GPRInfo::argumentGPR1, 1);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-         m_calls.append(CallLinkRecord(call(OperationPtrTag), FunctionPtr&lt;OperationPtrTag&gt;(lookupExceptionHandlerFromCallerFrame)));</span>
  
          jumpToExceptionHandler(vm());
      }
  
      if (!m_exceptionChecks.empty()) {
          m_exceptionChecks.link(this);
  
          copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm().topEntryFrame);
  
<span class="line-modified">!         // lookupExceptionHandler is passed two arguments, the VM and the exec (the CallFrame*).</span>
          move(TrustedImmPtr(&amp;vm()), GPRInfo::argumentGPR0);
<span class="line-modified">!         move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR1);</span>
  
<span class="line-modified">! #if CPU(X86)</span>
<span class="line-removed">-         // FIXME: should use the call abstraction, but this is currently in the SpeculativeJIT layer!</span>
<span class="line-removed">-         poke(GPRInfo::argumentGPR0);</span>
<span class="line-removed">-         poke(GPRInfo::argumentGPR1, 1);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-         m_calls.append(CallLinkRecord(call(OperationPtrTag), FunctionPtr&lt;OperationPtrTag&gt;(lookupExceptionHandler)));</span>
  
          jumpToExceptionHandler(vm());
      }
  }
  
<span class="line-new-header">--- 139,30 ---</span>
      if (!m_exceptionChecksWithCallFrameRollback.empty()) {
          m_exceptionChecksWithCallFrameRollback.link(this);
  
          copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm().topEntryFrame);
  
<span class="line-modified">!         // operationLookupExceptionHandlerFromCallerFrame is passed one argument, the VM*.</span>
          move(TrustedImmPtr(&amp;vm()), GPRInfo::argumentGPR0);
<span class="line-modified">!         prepareCallOperation(vm());</span>
          addPtr(TrustedImm32(m_graph.stackPointerOffset() * sizeof(Register)), GPRInfo::callFrameRegister, stackPointerRegister);
  
<span class="line-modified">!         m_calls.append(CallLinkRecord(call(OperationPtrTag), FunctionPtr&lt;OperationPtrTag&gt;(operationLookupExceptionHandlerFromCallerFrame)));</span>
  
          jumpToExceptionHandler(vm());
      }
  
      if (!m_exceptionChecks.empty()) {
          m_exceptionChecks.link(this);
  
          copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm().topEntryFrame);
  
<span class="line-modified">!         // operationLookupExceptionHandler is passed one argument, the VM*.</span>
          move(TrustedImmPtr(&amp;vm()), GPRInfo::argumentGPR0);
<span class="line-modified">!         prepareCallOperation(vm());</span>
  
<span class="line-modified">!         m_calls.append(CallLinkRecord(call(OperationPtrTag), FunctionPtr&lt;OperationPtrTag&gt;(operationLookupExceptionHandler)));</span>
  
          jumpToExceptionHandler(vm());
      }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 260,10 ***</span>
<span class="line-new-header">--- 242,11 ---</span>
      for (unsigned i = 0; i &lt; m_calls.size(); ++i)
          linkBuffer.link(m_calls[i].m_call, m_calls[i].m_function);
  
      finalizeInlineCaches(m_getByIds, linkBuffer);
      finalizeInlineCaches(m_getByIdsWithThis, linkBuffer);
<span class="line-added">+     finalizeInlineCaches(m_getByVals, linkBuffer);</span>
      finalizeInlineCaches(m_putByIds, linkBuffer);
      finalizeInlineCaches(m_inByIds, linkBuffer);
      finalizeInlineCaches(m_instanceOfs, linkBuffer);
  
      auto linkCallThunk = FunctionPtr&lt;NoPtrTag&gt;(vm().getCTIStub(linkCallThunkGenerator).retaggedCode&lt;NoPtrTag&gt;());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 368,12 ***</span>
      // Plant a check that sufficient space is available in the JSStack.
      JumpList stackOverflow;
      emitStackOverflowCheck(*this, stackOverflow);
  
      addPtr(TrustedImm32(-(m_graph.frameRegisterCount() * sizeof(Register))), GPRInfo::callFrameRegister, stackPointerRegister);
<span class="line-removed">-     if (Options::zeroStackFrame())</span>
<span class="line-removed">-         clearStackFrame(GPRInfo::callFrameRegister, stackPointerRegister, GPRInfo::regT0, m_graph.frameRegisterCount() * sizeof(Register));</span>
      checkStackPointerAlignment();
      compileSetupRegistersForEntry();
      compileEntryExecutionFlag();
      compileBody();
      setEndOfMainPath();
<span class="line-new-header">--- 351,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 382,11 ***</span>
      //
      // Generate the stack overflow handling; if the stack check in the entry head fails,
      // we need to call out to a helper function to throw the StackOverflowError.
      stackOverflow.link(this);
  
<span class="line-modified">!     emitStoreCodeOrigin(CodeOrigin(0));</span>
  
      if (maxFrameExtentForSlowPathCall)
          addPtr(TrustedImm32(-static_cast&lt;int32_t&gt;(maxFrameExtentForSlowPathCall)), stackPointerRegister);
  
      m_speculative-&gt;callOperationWithCallFrameRollbackOnException(operationThrowStackOverflowError, m_codeBlock);
<span class="line-new-header">--- 363,11 ---</span>
      //
      // Generate the stack overflow handling; if the stack check in the entry head fails,
      // we need to call out to a helper function to throw the StackOverflowError.
      stackOverflow.link(this);
  
<span class="line-modified">!     emitStoreCodeOrigin(CodeOrigin(BytecodeIndex(0)));</span>
  
      if (maxFrameExtentForSlowPathCall)
          addPtr(TrustedImm32(-static_cast&lt;int32_t&gt;(maxFrameExtentForSlowPathCall)), stackPointerRegister);
  
      m_speculative-&gt;callOperationWithCallFrameRollbackOnException(operationThrowStackOverflowError, m_codeBlock);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 409,13 ***</span>
      }
  
      link(*linkBuffer);
      m_speculative-&gt;linkOSREntries(*linkBuffer);
  
<span class="line-removed">-     m_jitCode-&gt;shrinkToFit();</span>
<span class="line-removed">-     codeBlock()-&gt;shrinkToFit(CodeBlock::LateShrink);</span>
<span class="line-removed">- </span>
      disassemble(*linkBuffer);
  
      m_graph.m_plan.setFinalizer(makeUnique&lt;JITFinalizer&gt;(
          m_graph.m_plan, m_jitCode.releaseNonNull(), WTFMove(linkBuffer)));
  }
<span class="line-new-header">--- 390,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 437,12 ***</span>
      JumpList stackOverflow;
      emitStackOverflowCheck(*this, stackOverflow);
  
      // Move the stack pointer down to accommodate locals
      addPtr(TrustedImm32(-(m_graph.frameRegisterCount() * sizeof(Register))), GPRInfo::callFrameRegister, stackPointerRegister);
<span class="line-removed">-     if (Options::zeroStackFrame())</span>
<span class="line-removed">-         clearStackFrame(GPRInfo::callFrameRegister, stackPointerRegister, GPRInfo::regT0, m_graph.frameRegisterCount() * sizeof(Register));</span>
      checkStackPointerAlignment();
  
      compileSetupRegistersForEntry();
      compileEntryExecutionFlag();
  
<span class="line-new-header">--- 415,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 458,11 ***</span>
      //
      // Generate the stack overflow handling; if the stack check in the function head fails,
      // we need to call out to a helper function to throw the StackOverflowError.
      stackOverflow.link(this);
  
<span class="line-modified">!     emitStoreCodeOrigin(CodeOrigin(0));</span>
  
      if (maxFrameExtentForSlowPathCall)
          addPtr(TrustedImm32(-static_cast&lt;int32_t&gt;(maxFrameExtentForSlowPathCall)), stackPointerRegister);
  
      m_speculative-&gt;callOperationWithCallFrameRollbackOnException(operationThrowStackOverflowError, m_codeBlock);
<span class="line-new-header">--- 434,11 ---</span>
      //
      // Generate the stack overflow handling; if the stack check in the function head fails,
      // we need to call out to a helper function to throw the StackOverflowError.
      stackOverflow.link(this);
  
<span class="line-modified">!     emitStoreCodeOrigin(CodeOrigin(BytecodeIndex(0)));</span>
  
      if (maxFrameExtentForSlowPathCall)
          addPtr(TrustedImm32(-static_cast&lt;int32_t&gt;(maxFrameExtentForSlowPathCall)), stackPointerRegister);
  
      m_speculative-&gt;callOperationWithCallFrameRollbackOnException(operationThrowStackOverflowError, m_codeBlock);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 477,20 ***</span>
      bool requiresArityFixup = m_codeBlock-&gt;numParameters() != 1;
      if (requiresArityFixup) {
          arityCheck = label();
          compileEntry();
  
<span class="line-modified">!         load32(AssemblyHelpers::payloadFor((VirtualRegister)CallFrameSlot::argumentCount), GPRInfo::regT1);</span>
          branch32(AboveOrEqual, GPRInfo::regT1, TrustedImm32(m_codeBlock-&gt;numParameters())).linkTo(fromArityCheck, this);
<span class="line-modified">!         emitStoreCodeOrigin(CodeOrigin(0));</span>
          if (maxFrameExtentForSlowPathCall)
              addPtr(TrustedImm32(-static_cast&lt;int32_t&gt;(maxFrameExtentForSlowPathCall)), stackPointerRegister);
<span class="line-modified">!         m_speculative-&gt;callOperationWithCallFrameRollbackOnException(m_codeBlock-&gt;isConstructor() ? operationConstructArityCheck : operationCallArityCheck, GPRInfo::regT0);</span>
          if (maxFrameExtentForSlowPathCall)
              addPtr(TrustedImm32(maxFrameExtentForSlowPathCall), stackPointerRegister);
          branchTest32(Zero, GPRInfo::returnValueGPR).linkTo(fromArityCheck, this);
<span class="line-modified">!         emitStoreCodeOrigin(CodeOrigin(0));</span>
          move(GPRInfo::returnValueGPR, GPRInfo::argumentGPR0);
          callArityFixup = nearCall();
          jump(fromArityCheck);
      } else
          arityCheck = entryLabel;
<span class="line-new-header">--- 453,20 ---</span>
      bool requiresArityFixup = m_codeBlock-&gt;numParameters() != 1;
      if (requiresArityFixup) {
          arityCheck = label();
          compileEntry();
  
<span class="line-modified">!         load32(AssemblyHelpers::payloadFor((VirtualRegister)CallFrameSlot::argumentCountIncludingThis), GPRInfo::regT1);</span>
          branch32(AboveOrEqual, GPRInfo::regT1, TrustedImm32(m_codeBlock-&gt;numParameters())).linkTo(fromArityCheck, this);
<span class="line-modified">!         emitStoreCodeOrigin(CodeOrigin(BytecodeIndex(0)));</span>
          if (maxFrameExtentForSlowPathCall)
              addPtr(TrustedImm32(-static_cast&lt;int32_t&gt;(maxFrameExtentForSlowPathCall)), stackPointerRegister);
<span class="line-modified">!         m_speculative-&gt;callOperationWithCallFrameRollbackOnException(m_codeBlock-&gt;isConstructor() ? operationConstructArityCheck : operationCallArityCheck, GPRInfo::regT0, m_codeBlock-&gt;globalObject());</span>
          if (maxFrameExtentForSlowPathCall)
              addPtr(TrustedImm32(maxFrameExtentForSlowPathCall), stackPointerRegister);
          branchTest32(Zero, GPRInfo::returnValueGPR).linkTo(fromArityCheck, this);
<span class="line-modified">!         emitStoreCodeOrigin(CodeOrigin(BytecodeIndex(0)));</span>
          move(GPRInfo::returnValueGPR, GPRInfo::argumentGPR0);
          callArityFixup = nearCall();
          jump(fromArityCheck);
      } else
          arityCheck = entryLabel;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 513,13 ***</span>
          return;
      }
      link(*linkBuffer);
      m_speculative-&gt;linkOSREntries(*linkBuffer);
  
<span class="line-removed">-     m_jitCode-&gt;shrinkToFit();</span>
<span class="line-removed">-     codeBlock()-&gt;shrinkToFit(CodeBlock::LateShrink);</span>
<span class="line-removed">- </span>
      if (requiresArityFixup)
          linkBuffer-&gt;link(callArityFixup, FunctionPtr&lt;JITThunkPtrTag&gt;(vm().getCTIStub(arityFixupGenerator).code()));
  
      disassemble(*linkBuffer);
  
<span class="line-new-header">--- 489,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 603,14 ***</span>
                  break;
              default:
                  break;
              }
  
<span class="line-modified">!             if (variable-&gt;local() != variable-&gt;machineLocal()) {</span>
                  entry-&gt;m_reshufflings.append(
                      OSREntryReshuffling(
<span class="line-modified">!                         variable-&gt;local().offset(), variable-&gt;machineLocal().offset()));</span>
              }
          }
      }
  
      entry-&gt;m_reshufflings.shrinkToFit();
<span class="line-new-header">--- 576,15 ---</span>
                  break;
              default:
                  break;
              }
  
<span class="line-modified">!             ASSERT(!variable-&gt;operand().isTmp());</span>
<span class="line-added">+             if (variable-&gt;operand().virtualRegister() != variable-&gt;machineLocal()) {</span>
                  entry-&gt;m_reshufflings.append(
                      OSREntryReshuffling(
<span class="line-modified">!                         variable-&gt;operand().virtualRegister().offset(), variable-&gt;machineLocal().offset()));</span>
              }
          }
      }
  
      entry-&gt;m_reshufflings.shrinkToFit();
</pre>
<center><a href="DFGJITCode.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGJITCompiler.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
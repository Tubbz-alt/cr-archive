<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderObject.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderObject.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderQuote.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderObject.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  36 #include &quot;ScrollAlignment.h&quot;
  37 #include &quot;StyleImage.h&quot;
  38 #include &quot;TextAffinity.h&quot;
  39 #include &lt;wtf/IsoMalloc.h&gt;
  40 #include &lt;wtf/WeakPtr.h&gt;
  41 
  42 namespace WebCore {
  43 
  44 class AffineTransform;
  45 class CSSAnimationController;
  46 class Color;
  47 class Cursor;
  48 class Document;
  49 class DocumentTimeline;
  50 class HitTestLocation;
  51 class HitTestRequest;
  52 class HitTestResult;
  53 class InlineBox;
  54 class Path;
  55 class Position;
<span class="line-removed">  56 class PseudoStyleRequest;</span>
  57 class RenderBoxModelObject;
  58 class RenderInline;
  59 class RenderBlock;
  60 class RenderElement;
  61 class RenderFragmentedFlow;
  62 class RenderGeometryMap;
  63 class RenderLayer;
  64 class RenderLayerModelObject;
  65 class RenderFragmentContainer;
  66 class RenderTheme;
  67 class RenderTreeBuilder;
  68 class SelectionRangeData;
  69 class TransformState;
  70 class VisiblePosition;
  71 
  72 #if PLATFORM(IOS_FAMILY)
  73 class SelectionRect;
  74 #endif
  75 
  76 struct PaintInfo;
  77 
  78 #if PLATFORM(IOS_FAMILY)
  79 const int caretWidth = 2; // This value should be kept in sync with UIKit. See &lt;rdar://problem/15580601&gt;.
  80 #else
  81 const int caretWidth = 1;
  82 #endif
  83 
  84 enum class ShouldAllowCrossOriginScrolling { No, Yes };
  85 
  86 struct ScrollRectToVisibleOptions;
  87 




  88 // Base class for all rendering tree objects.
  89 class RenderObject : public CachedImageClient, public CanMakeWeakPtr&lt;RenderObject&gt; {
  90     WTF_MAKE_ISO_ALLOCATED(RenderObject);
  91     friend class RenderBlock;
  92     friend class RenderBlockFlow;
  93     friend class RenderElement;
  94     friend class RenderLayer;
  95 public:
  96     // Anonymous objects should pass the document as their node, and they will then automatically be
  97     // marked as anonymous in the constructor.
  98     explicit RenderObject(Node&amp;);
  99     virtual ~RenderObject();
 100 
 101     RenderTheme&amp; theme() const;
 102 
 103     virtual const char* renderName() const = 0;
 104 
 105     RenderElement* parent() const { return m_parent; }
 106     bool isDescendantOf(const RenderObject*) const;
 107 
</pre>
<hr />
<pre>
 145     WEBCORE_EXPORT bool scrollRectToVisible(const LayoutRect&amp; absoluteRect, bool insideFixed, const ScrollRectToVisibleOptions&amp;);
 146 
 147     // Convenience function for getting to the nearest enclosing box of a RenderObject.
 148     WEBCORE_EXPORT RenderBox&amp; enclosingBox() const;
 149     RenderBoxModelObject&amp; enclosingBoxModelObject() const;
 150     const RenderBox* enclosingScrollableContainerForSnapping() const;
 151 
 152     // Function to return our enclosing flow thread if we are contained inside one. This
 153     // function follows the containing block chain.
 154     RenderFragmentedFlow* enclosingFragmentedFlow() const
 155     {
 156         if (fragmentedFlowState() == NotInsideFragmentedFlow)
 157             return nullptr;
 158 
 159         return locateEnclosingFragmentedFlow();
 160     }
 161 
 162     WEBCORE_EXPORT bool useDarkAppearance() const;
 163     OptionSet&lt;StyleColor::Options&gt; styleColorOptions() const;
 164 
<span class="line-modified"> 165 #ifndef NDEBUG</span>
 166     void setHasAXObject(bool flag) { m_hasAXObject = flag; }
 167     bool hasAXObject() const { return m_hasAXObject; }
 168 
 169     // Helper class forbidding calls to setNeedsLayout() during its lifetime.
 170     class SetLayoutNeededForbiddenScope {
 171     public:
 172         explicit SetLayoutNeededForbiddenScope(RenderObject*, bool isForbidden = true);
 173         ~SetLayoutNeededForbiddenScope();
 174     private:
 175         RenderObject* m_renderObject;
 176         bool m_preexistingForbidden;
 177     };
<span class="line-modified"> 178 #endif</span>
 179 
 180     // Obtains the nearest enclosing block (including this block) that contributes a first-line style to our inline
 181     // children.
 182     virtual RenderBlock* firstLineBlock() const;
 183 
 184     // RenderObject tree manipulation
 185     //////////////////////////////////////////
 186     virtual bool canHaveChildren() const = 0;
 187     virtual bool canHaveGeneratedChildren() const;
 188     virtual bool createsAnonymousWrapper() const { return false; }
 189     //////////////////////////////////////////
 190 
 191 #if ENABLE(TREE_DEBUGGING)
 192     void showNodeTreeForThis() const;
 193     void showRenderTreeForThis() const;
 194     void showLineTreeForThis() const;
 195 
 196     void outputRenderObject(WTF::TextStream&amp;, bool mark, int depth) const;
 197     void outputRenderSubTreeAndMark(WTF::TextStream&amp;, const RenderObject* markedObject, int depth) const;
 198     void outputRegionsInformation(WTF::TextStream&amp;) const;
</pre>
<hr />
<pre>
 667     enum class VisibleRectContextOption {
 668         UseEdgeInclusiveIntersection = 1 &lt;&lt; 0,
 669         ApplyCompositedClips = 1 &lt;&lt; 1,
 670         ApplyCompositedContainerScrolls  = 1 &lt;&lt; 2,
 671         ApplyContainerClip = 1 &lt;&lt; 3,
 672     };
 673     struct VisibleRectContext {
 674         VisibleRectContext(bool hasPositionFixedDescendant = false, bool dirtyRectIsFlipped = false, OptionSet&lt;VisibleRectContextOption&gt; options = { })
 675             : m_hasPositionFixedDescendant(hasPositionFixedDescendant)
 676             , m_dirtyRectIsFlipped(dirtyRectIsFlipped)
 677             , m_options(options)
 678             {
 679             }
 680         bool m_hasPositionFixedDescendant;
 681         bool m_dirtyRectIsFlipped;
 682         OptionSet&lt;VisibleRectContextOption&gt; m_options;
 683     };
 684     virtual Optional&lt;LayoutRect&gt; computeVisibleRectInContainer(const LayoutRect&amp;, const RenderLayerModelObject* repaintContainer, VisibleRectContext) const;
 685     virtual Optional&lt;FloatRect&gt; computeFloatVisibleRectInContainer(const FloatRect&amp;, const RenderLayerModelObject* repaintContainer, VisibleRectContext) const;
 686 


 687     virtual unsigned int length() const { return 1; }
 688 
 689     bool isFloatingOrOutOfFlowPositioned() const { return (isFloating() || isOutOfFlowPositioned()); }
 690 
 691     enum SelectionState {
 692         SelectionNone, // The object is not selected.
 693         SelectionStart, // The object either contains the start of a selection run or is the start of a run
 694         SelectionInside, // The object is fully encompassed by a selection run
 695         SelectionEnd, // The object either contains the end of a selection run or is the end of a run
 696         SelectionBoth // The object contains an entire run or is the sole selected object in that run
 697     };
 698 
 699     // The current selection state for an object.  For blocks, the state refers to the state of the leaf
 700     // descendants (as described above in the SelectionState enum declaration).
 701     SelectionState selectionState() const { return m_bitfields.selectionState(); }
 702     virtual void setSelectionState(SelectionState state) { m_bitfields.setSelectionState(state); }
 703     inline void setSelectionStateIfNeeded(SelectionState);
 704     bool canUpdateSelectionOnRootLineBoxes();
 705 
 706     // A single rectangle that encompasses all of the selected objects within this object.  Used to determine the tightest
 707     // possible bounding box for the selection.
 708     LayoutRect selectionRect(bool clipToVisibleContent = true) { return selectionRectForRepaint(nullptr, clipToVisibleContent); }
 709     virtual LayoutRect selectionRectForRepaint(const RenderLayerModelObject* /*repaintContainer*/, bool /*clipToVisibleContent*/ = true) { return LayoutRect(); }
 710 
 711     virtual bool canBeSelectionLeaf() const { return false; }
 712 
 713     // Whether or not a given block needs to paint selection gaps.
 714     virtual bool shouldPaintSelectionGaps() const { return false; }
 715 
 716     /**
 717      * Returns the local coordinates of the caret within this render object.
 718      * @param caretOffset zero-based offset determining position within the render object.
 719      * @param extraWidthToEndOfLine optional out arg to give extra width to end of line -
 720      * useful for character range rect computations
 721      */
 722     virtual LayoutRect localCaretRect(InlineBox*, unsigned caretOffset, LayoutUnit* extraWidthToEndOfLine = nullptr);
 723 
<span class="line-modified"> 724     // When performing a global document tear-down, or when going into the page cache, the renderer of the document is cleared.</span>
 725     bool renderTreeBeingDestroyed() const;
 726 
 727     void destroy();
 728 
 729     // Virtual function helpers for the deprecated Flexible Box Layout (display: -webkit-box).
 730     virtual bool isDeprecatedFlexibleBox() const { return false; }
 731 
 732     // Virtual function helper for the new FlexibleBox Layout (display: -webkit-flex).
 733     virtual bool isFlexibleBox() const { return false; }
 734 
 735     bool isFlexibleBoxIncludingDeprecated() const
 736     {
 737         return isFlexibleBox() || isDeprecatedFlexibleBox();
 738     }
 739 
 740     virtual bool isCombineText() const { return false; }
 741 
 742     virtual int caretMinOffset() const;
 743     virtual int caretMaxOffset() const;
 744 
</pre>
<hr />
<pre>
 791     virtual void willBeDestroyed();
 792 
 793     void setNeedsPositionedMovementLayoutBit(bool b) { m_bitfields.setNeedsPositionedMovementLayout(b); }
 794     void setNormalChildNeedsLayoutBit(bool b) { m_bitfields.setNormalChildNeedsLayout(b); }
 795     void setPosChildNeedsLayoutBit(bool b) { m_bitfields.setPosChildNeedsLayout(b); }
 796     void setNeedsSimplifiedNormalFlowLayoutBit(bool b) { m_bitfields.setNeedsSimplifiedNormalFlowLayout(b); }
 797 
 798     virtual RenderFragmentedFlow* locateEnclosingFragmentedFlow() const;
 799     static void calculateBorderStyleColor(const BorderStyle&amp;, const BoxSide&amp;, Color&amp;);
 800 
 801     static FragmentedFlowState computedFragmentedFlowState(const RenderObject&amp;);
 802 
 803     static bool shouldApplyCompositedContainerScrollsForRepaint();
 804 
 805     static VisibleRectContext visibleRectContextForRepaint()
 806     {
 807         return VisibleRectContext(false, false, { VisibleRectContextOption::ApplyContainerClip, VisibleRectContextOption::ApplyCompositedContainerScrolls });
 808     }
 809 
 810 private:
<span class="line-modified"> 811 #ifndef NDEBUG</span>
 812     bool isSetNeedsLayoutForbidden() const { return m_setNeedsLayoutForbidden; }
 813     void setNeedsLayoutIsForbidden(bool flag) { m_setNeedsLayoutForbidden = flag; }
 814 #endif
 815 
 816     void addAbsoluteRectForLayer(LayoutRect&amp; result);
 817     void setLayerNeedsFullRepaint();
 818     void setLayerNeedsFullRepaintForPositionedMovementLayout();
 819 
 820     Node* generatingPseudoHostElement() const;
 821 
 822     void propagateRepaintToParentWithOutlineAutoIfNeeded(const RenderLayerModelObject&amp; repaintContainer, const LayoutRect&amp; repaintRect) const;
 823 
 824     virtual bool isWBR() const { ASSERT_NOT_REACHED(); return false; }
 825 
 826     void setEverHadLayout(bool b) { m_bitfields.setEverHadLayout(b); }
 827 
 828     bool hasRareData() const { return m_bitfields.hasRareData(); }
 829     void setHasRareData(bool b) { m_bitfields.setHasRareData(b); }
 830 
<span class="line-modified"> 831 #ifndef NDEBUG</span>
 832     void checkBlockPositionedObjectsNeedLayout();
 833 #endif
 834 
 835     Node&amp; m_node;
 836 
 837     RenderElement* m_parent;
 838     RenderObject* m_previous;
 839     RenderObject* m_next;
 840 
<span class="line-modified"> 841 #ifndef NDEBUG</span>
 842     bool m_hasAXObject             : 1;
 843     bool m_setNeedsLayoutForbidden : 1;
 844 #endif
 845 
 846 #define ADD_BOOLEAN_BITFIELD(name, Name) \
 847     private:\
 848         unsigned m_##name : 1;\
 849     public:\
 850         bool name() const { return m_##name; }\
 851         void set##Name(bool name) { m_##name = name; }\
 852 
 853 #define ADD_ENUM_BITFIELD(name, Name, Type, width) \
 854     private:\
 855         unsigned m_##name : width;\
 856     public:\
 857         Type name() const { return static_cast&lt;Type&gt;(m_##name); }\
 858         void set##Name(Type name) { m_##name = static_cast&lt;unsigned&gt;(name); }\
 859 
 860     class RenderObjectBitfields {
 861         enum PositionedState {
</pre>
</td>
<td>
<hr />
<pre>
  36 #include &quot;ScrollAlignment.h&quot;
  37 #include &quot;StyleImage.h&quot;
  38 #include &quot;TextAffinity.h&quot;
  39 #include &lt;wtf/IsoMalloc.h&gt;
  40 #include &lt;wtf/WeakPtr.h&gt;
  41 
  42 namespace WebCore {
  43 
  44 class AffineTransform;
  45 class CSSAnimationController;
  46 class Color;
  47 class Cursor;
  48 class Document;
  49 class DocumentTimeline;
  50 class HitTestLocation;
  51 class HitTestRequest;
  52 class HitTestResult;
  53 class InlineBox;
  54 class Path;
  55 class Position;

  56 class RenderBoxModelObject;
  57 class RenderInline;
  58 class RenderBlock;
  59 class RenderElement;
  60 class RenderFragmentedFlow;
  61 class RenderGeometryMap;
  62 class RenderLayer;
  63 class RenderLayerModelObject;
  64 class RenderFragmentContainer;
  65 class RenderTheme;
  66 class RenderTreeBuilder;
  67 class SelectionRangeData;
  68 class TransformState;
  69 class VisiblePosition;
  70 
  71 #if PLATFORM(IOS_FAMILY)
  72 class SelectionRect;
  73 #endif
  74 
  75 struct PaintInfo;
  76 
  77 #if PLATFORM(IOS_FAMILY)
  78 const int caretWidth = 2; // This value should be kept in sync with UIKit. See &lt;rdar://problem/15580601&gt;.
  79 #else
  80 const int caretWidth = 1;
  81 #endif
  82 
  83 enum class ShouldAllowCrossOriginScrolling { No, Yes };
  84 
  85 struct ScrollRectToVisibleOptions;
  86 
<span class="line-added">  87 namespace Style {</span>
<span class="line-added">  88 class PseudoElementRequest;</span>
<span class="line-added">  89 }</span>
<span class="line-added">  90 </span>
  91 // Base class for all rendering tree objects.
  92 class RenderObject : public CachedImageClient, public CanMakeWeakPtr&lt;RenderObject&gt; {
  93     WTF_MAKE_ISO_ALLOCATED(RenderObject);
  94     friend class RenderBlock;
  95     friend class RenderBlockFlow;
  96     friend class RenderElement;
  97     friend class RenderLayer;
  98 public:
  99     // Anonymous objects should pass the document as their node, and they will then automatically be
 100     // marked as anonymous in the constructor.
 101     explicit RenderObject(Node&amp;);
 102     virtual ~RenderObject();
 103 
 104     RenderTheme&amp; theme() const;
 105 
 106     virtual const char* renderName() const = 0;
 107 
 108     RenderElement* parent() const { return m_parent; }
 109     bool isDescendantOf(const RenderObject*) const;
 110 
</pre>
<hr />
<pre>
 148     WEBCORE_EXPORT bool scrollRectToVisible(const LayoutRect&amp; absoluteRect, bool insideFixed, const ScrollRectToVisibleOptions&amp;);
 149 
 150     // Convenience function for getting to the nearest enclosing box of a RenderObject.
 151     WEBCORE_EXPORT RenderBox&amp; enclosingBox() const;
 152     RenderBoxModelObject&amp; enclosingBoxModelObject() const;
 153     const RenderBox* enclosingScrollableContainerForSnapping() const;
 154 
 155     // Function to return our enclosing flow thread if we are contained inside one. This
 156     // function follows the containing block chain.
 157     RenderFragmentedFlow* enclosingFragmentedFlow() const
 158     {
 159         if (fragmentedFlowState() == NotInsideFragmentedFlow)
 160             return nullptr;
 161 
 162         return locateEnclosingFragmentedFlow();
 163     }
 164 
 165     WEBCORE_EXPORT bool useDarkAppearance() const;
 166     OptionSet&lt;StyleColor::Options&gt; styleColorOptions() const;
 167 
<span class="line-modified"> 168 #if ASSERT_ENABLED</span>
 169     void setHasAXObject(bool flag) { m_hasAXObject = flag; }
 170     bool hasAXObject() const { return m_hasAXObject; }
 171 
 172     // Helper class forbidding calls to setNeedsLayout() during its lifetime.
 173     class SetLayoutNeededForbiddenScope {
 174     public:
 175         explicit SetLayoutNeededForbiddenScope(RenderObject*, bool isForbidden = true);
 176         ~SetLayoutNeededForbiddenScope();
 177     private:
 178         RenderObject* m_renderObject;
 179         bool m_preexistingForbidden;
 180     };
<span class="line-modified"> 181 #endif // ASSERT_ENABLED</span>
 182 
 183     // Obtains the nearest enclosing block (including this block) that contributes a first-line style to our inline
 184     // children.
 185     virtual RenderBlock* firstLineBlock() const;
 186 
 187     // RenderObject tree manipulation
 188     //////////////////////////////////////////
 189     virtual bool canHaveChildren() const = 0;
 190     virtual bool canHaveGeneratedChildren() const;
 191     virtual bool createsAnonymousWrapper() const { return false; }
 192     //////////////////////////////////////////
 193 
 194 #if ENABLE(TREE_DEBUGGING)
 195     void showNodeTreeForThis() const;
 196     void showRenderTreeForThis() const;
 197     void showLineTreeForThis() const;
 198 
 199     void outputRenderObject(WTF::TextStream&amp;, bool mark, int depth) const;
 200     void outputRenderSubTreeAndMark(WTF::TextStream&amp;, const RenderObject* markedObject, int depth) const;
 201     void outputRegionsInformation(WTF::TextStream&amp;) const;
</pre>
<hr />
<pre>
 670     enum class VisibleRectContextOption {
 671         UseEdgeInclusiveIntersection = 1 &lt;&lt; 0,
 672         ApplyCompositedClips = 1 &lt;&lt; 1,
 673         ApplyCompositedContainerScrolls  = 1 &lt;&lt; 2,
 674         ApplyContainerClip = 1 &lt;&lt; 3,
 675     };
 676     struct VisibleRectContext {
 677         VisibleRectContext(bool hasPositionFixedDescendant = false, bool dirtyRectIsFlipped = false, OptionSet&lt;VisibleRectContextOption&gt; options = { })
 678             : m_hasPositionFixedDescendant(hasPositionFixedDescendant)
 679             , m_dirtyRectIsFlipped(dirtyRectIsFlipped)
 680             , m_options(options)
 681             {
 682             }
 683         bool m_hasPositionFixedDescendant;
 684         bool m_dirtyRectIsFlipped;
 685         OptionSet&lt;VisibleRectContextOption&gt; m_options;
 686     };
 687     virtual Optional&lt;LayoutRect&gt; computeVisibleRectInContainer(const LayoutRect&amp;, const RenderLayerModelObject* repaintContainer, VisibleRectContext) const;
 688     virtual Optional&lt;FloatRect&gt; computeFloatVisibleRectInContainer(const FloatRect&amp;, const RenderLayerModelObject* repaintContainer, VisibleRectContext) const;
 689 
<span class="line-added"> 690     WEBCORE_EXPORT bool hasNonEmptyVisibleRectRespectingParentFrames() const;</span>
<span class="line-added"> 691 </span>
 692     virtual unsigned int length() const { return 1; }
 693 
 694     bool isFloatingOrOutOfFlowPositioned() const { return (isFloating() || isOutOfFlowPositioned()); }
 695 
 696     enum SelectionState {
 697         SelectionNone, // The object is not selected.
 698         SelectionStart, // The object either contains the start of a selection run or is the start of a run
 699         SelectionInside, // The object is fully encompassed by a selection run
 700         SelectionEnd, // The object either contains the end of a selection run or is the end of a run
 701         SelectionBoth // The object contains an entire run or is the sole selected object in that run
 702     };
 703 
 704     // The current selection state for an object.  For blocks, the state refers to the state of the leaf
 705     // descendants (as described above in the SelectionState enum declaration).
 706     SelectionState selectionState() const { return m_bitfields.selectionState(); }
 707     virtual void setSelectionState(SelectionState state) { m_bitfields.setSelectionState(state); }
 708     inline void setSelectionStateIfNeeded(SelectionState);
 709     bool canUpdateSelectionOnRootLineBoxes();
 710 
 711     // A single rectangle that encompasses all of the selected objects within this object.  Used to determine the tightest
 712     // possible bounding box for the selection.
 713     LayoutRect selectionRect(bool clipToVisibleContent = true) { return selectionRectForRepaint(nullptr, clipToVisibleContent); }
 714     virtual LayoutRect selectionRectForRepaint(const RenderLayerModelObject* /*repaintContainer*/, bool /*clipToVisibleContent*/ = true) { return LayoutRect(); }
 715 
 716     virtual bool canBeSelectionLeaf() const { return false; }
 717 
 718     // Whether or not a given block needs to paint selection gaps.
 719     virtual bool shouldPaintSelectionGaps() const { return false; }
 720 
 721     /**
 722      * Returns the local coordinates of the caret within this render object.
 723      * @param caretOffset zero-based offset determining position within the render object.
 724      * @param extraWidthToEndOfLine optional out arg to give extra width to end of line -
 725      * useful for character range rect computations
 726      */
 727     virtual LayoutRect localCaretRect(InlineBox*, unsigned caretOffset, LayoutUnit* extraWidthToEndOfLine = nullptr);
 728 
<span class="line-modified"> 729     // When performing a global document tear-down, or when going into the back/forward cache, the renderer of the document is cleared.</span>
 730     bool renderTreeBeingDestroyed() const;
 731 
 732     void destroy();
 733 
 734     // Virtual function helpers for the deprecated Flexible Box Layout (display: -webkit-box).
 735     virtual bool isDeprecatedFlexibleBox() const { return false; }
 736 
 737     // Virtual function helper for the new FlexibleBox Layout (display: -webkit-flex).
 738     virtual bool isFlexibleBox() const { return false; }
 739 
 740     bool isFlexibleBoxIncludingDeprecated() const
 741     {
 742         return isFlexibleBox() || isDeprecatedFlexibleBox();
 743     }
 744 
 745     virtual bool isCombineText() const { return false; }
 746 
 747     virtual int caretMinOffset() const;
 748     virtual int caretMaxOffset() const;
 749 
</pre>
<hr />
<pre>
 796     virtual void willBeDestroyed();
 797 
 798     void setNeedsPositionedMovementLayoutBit(bool b) { m_bitfields.setNeedsPositionedMovementLayout(b); }
 799     void setNormalChildNeedsLayoutBit(bool b) { m_bitfields.setNormalChildNeedsLayout(b); }
 800     void setPosChildNeedsLayoutBit(bool b) { m_bitfields.setPosChildNeedsLayout(b); }
 801     void setNeedsSimplifiedNormalFlowLayoutBit(bool b) { m_bitfields.setNeedsSimplifiedNormalFlowLayout(b); }
 802 
 803     virtual RenderFragmentedFlow* locateEnclosingFragmentedFlow() const;
 804     static void calculateBorderStyleColor(const BorderStyle&amp;, const BoxSide&amp;, Color&amp;);
 805 
 806     static FragmentedFlowState computedFragmentedFlowState(const RenderObject&amp;);
 807 
 808     static bool shouldApplyCompositedContainerScrollsForRepaint();
 809 
 810     static VisibleRectContext visibleRectContextForRepaint()
 811     {
 812         return VisibleRectContext(false, false, { VisibleRectContextOption::ApplyContainerClip, VisibleRectContextOption::ApplyCompositedContainerScrolls });
 813     }
 814 
 815 private:
<span class="line-modified"> 816 #if ASSERT_ENABLED</span>
 817     bool isSetNeedsLayoutForbidden() const { return m_setNeedsLayoutForbidden; }
 818     void setNeedsLayoutIsForbidden(bool flag) { m_setNeedsLayoutForbidden = flag; }
 819 #endif
 820 
 821     void addAbsoluteRectForLayer(LayoutRect&amp; result);
 822     void setLayerNeedsFullRepaint();
 823     void setLayerNeedsFullRepaintForPositionedMovementLayout();
 824 
 825     Node* generatingPseudoHostElement() const;
 826 
 827     void propagateRepaintToParentWithOutlineAutoIfNeeded(const RenderLayerModelObject&amp; repaintContainer, const LayoutRect&amp; repaintRect) const;
 828 
 829     virtual bool isWBR() const { ASSERT_NOT_REACHED(); return false; }
 830 
 831     void setEverHadLayout(bool b) { m_bitfields.setEverHadLayout(b); }
 832 
 833     bool hasRareData() const { return m_bitfields.hasRareData(); }
 834     void setHasRareData(bool b) { m_bitfields.setHasRareData(b); }
 835 
<span class="line-modified"> 836 #if ASSERT_ENABLED</span>
 837     void checkBlockPositionedObjectsNeedLayout();
 838 #endif
 839 
 840     Node&amp; m_node;
 841 
 842     RenderElement* m_parent;
 843     RenderObject* m_previous;
 844     RenderObject* m_next;
 845 
<span class="line-modified"> 846 #if ASSERT_ENABLED</span>
 847     bool m_hasAXObject             : 1;
 848     bool m_setNeedsLayoutForbidden : 1;
 849 #endif
 850 
 851 #define ADD_BOOLEAN_BITFIELD(name, Name) \
 852     private:\
 853         unsigned m_##name : 1;\
 854     public:\
 855         bool name() const { return m_##name; }\
 856         void set##Name(bool name) { m_##name = name; }\
 857 
 858 #define ADD_ENUM_BITFIELD(name, Name, Type, width) \
 859     private:\
 860         unsigned m_##name : width;\
 861     public:\
 862         Type name() const { return static_cast&lt;Type&gt;(m_##name); }\
 863         void set##Name(Type name) { m_##name = static_cast&lt;unsigned&gt;(name); }\
 864 
 865     class RenderObjectBitfields {
 866         enum PositionedState {
</pre>
</td>
</tr>
</table>
<center><a href="RenderObject.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderQuote.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
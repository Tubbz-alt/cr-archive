diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirAllocateRegistersAndStackAndGenerateCode.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirAllocateRegistersAndStackAndGenerateCode.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirAllocateRegistersAndStackAndGenerateCode.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirAllocateRegistersAndStackAndGenerateCode.h
@@ -27,10 +27,11 @@
 
 #if ENABLE(B3_JIT)
 
 #include "AirLiveness.h"
 #include "AirTmpMap.h"
+#include <wtf/Nonmovable.h>
 
 namespace JSC {
 
 class CCallHelpers;
 
@@ -41,11 +42,11 @@
 class GenerateAndAllocateRegisters {
     WTF_MAKE_FAST_ALLOCATED;
     WTF_MAKE_NONMOVABLE(GenerateAndAllocateRegisters);
 
     struct TmpData {
-        StackSlot* spillSlot;
+        StackSlot* spillSlot { nullptr };
         Reg reg;
     };
 
 public:
     GenerateAndAllocateRegisters(Code&);
@@ -53,24 +54,27 @@
     void prepareForGeneration();
     void generate(CCallHelpers&);
 
 private:
     void insertBlocksForFlushAfterTerminalPatchpoints();
+    void release(Tmp, Reg);
     void flush(Tmp, Reg);
     void spill(Tmp, Reg);
     void alloc(Tmp, Reg, bool isDef);
     void freeDeadTmpsIfNeeded();
     bool assignTmp(Tmp&, Bank, bool isDef);
     void buildLiveRanges(UnifiedTmpLiveness&);
     bool isDisallowedRegister(Reg);
 
+    void checkConsistency();
+
     Code& m_code;
     CCallHelpers* m_jit { nullptr };
 
     TmpMap<TmpData> m_map;
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     Vector<Tmp> m_allTmps[numBanks];
 #endif
 
     Vector<Reg> m_registers[numBanks];
     RegisterSet m_availableRegs[numBanks];
@@ -79,14 +83,15 @@
     bool m_didAlreadyFreeDeadSlots;
     TmpMap<size_t> m_liveRangeEnd;
     RegisterSet m_namedUsedRegs;
     RegisterSet m_namedDefdRegs;
     RegisterSet m_allowedRegisters;
+    std::unique_ptr<UnifiedTmpLiveness> m_liveness;
 
     struct PatchSpillData {
-        CCallHelpers::Jump jump;
-        CCallHelpers::Label continueLabel;
+        MacroAssembler::Jump jump;
+        MacroAssembler::Label continueLabel;
         HashMap<Tmp, Arg*> defdTmps;
     };
 
     HashMap<BasicBlock*, PatchSpillData> m_blocksAfterTerminalPatchForSpilling;
 };

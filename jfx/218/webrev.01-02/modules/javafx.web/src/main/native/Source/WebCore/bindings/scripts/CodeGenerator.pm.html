<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/CodeGenerator.pm</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 #
   2 # WebKit IDL parser
   3 #
   4 # Copyright (C) 2005 Nikolas Zimmermann &lt;wildfox@kde.org&gt;
   5 # Copyright (C) 2006 Samuel Weinig &lt;sam.weinig@gmail.com&gt;
   6 # Copyright (C) 2007, 2008, 2009, 2010 Apple Inc. All rights reserved.
   7 # Copyright (C) 2009 Cameron McCormack &lt;cam@mcc.id.au&gt;
   8 # Copyright (C) Research In Motion Limited 2010. All rights reserved.
   9 # Copyright (C) 2013 Samsung Electronics. All rights reserved.
  10 #
  11 # This library is free software; you can redistribute it and/or
  12 # modify it under the terms of the GNU Library General Public
  13 # License as published by the Free Software Foundation; either
  14 # version 2 of the License, or (at your option) any later version.
  15 #
  16 # This library is distributed in the hope that it will be useful,
  17 # but WITHOUT ANY WARRANTY; without even the implied warranty of
  18 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  19 # Library General Public License for more details.
  20 #
  21 # You should have received a copy of the GNU Library General Public License
  22 # along with this library; see the file COPYING.LIB.  If not, write to
  23 # the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  24 # Boston, MA 02110-1301, USA.
  25 #
  26 
  27 package CodeGenerator;
  28 
  29 use strict;
  30 
  31 use File::Basename;
  32 use File::Find;
  33 use Carp qw&lt;longmess&gt;;
  34 use Data::Dumper;
  35 
  36 my $useDocument = &quot;&quot;;
  37 my $useGenerator = &quot;&quot;;
  38 my $useOutputDir = &quot;&quot;;
  39 my $useOutputHeadersDir = &quot;&quot;;
  40 my $useDirectories = &quot;&quot;;
  41 my $preprocessor;
  42 my $idlAttributes;
  43 my $writeDependencies = 0;
  44 my $defines = &quot;&quot;;
  45 my $targetIdlFilePath = &quot;&quot;;
  46 my $supplementalDependencies;
  47 
  48 my $codeGenerator = 0;
  49 
  50 my $verbose = 0;
  51 
  52 my %integerTypeHash = (
  53     &quot;byte&quot; =&gt; 1,
  54     &quot;long long&quot; =&gt; 1,
  55     &quot;long&quot; =&gt; 1,
  56     &quot;octet&quot; =&gt; 1,
  57     &quot;short&quot; =&gt; 1,
  58     &quot;unsigned long long&quot; =&gt; 1,
  59     &quot;unsigned long&quot; =&gt; 1,
  60     &quot;unsigned short&quot; =&gt; 1,
  61 );
  62 
  63 my %floatingPointTypeHash = (
  64     &quot;float&quot; =&gt; 1,
  65     &quot;unrestricted float&quot; =&gt; 1,
  66     &quot;double&quot; =&gt; 1,
  67     &quot;unrestricted double&quot; =&gt; 1,
  68 );
  69 
  70 my %stringTypeHash = (
  71     &quot;ByteString&quot; =&gt; 1,
  72     &quot;DOMString&quot; =&gt; 1,
  73     &quot;USVString&quot; =&gt; 1,
  74 );
  75 
  76 my %bufferSourceTypes = (
  77     &quot;ArrayBuffer&quot; =&gt; 1,
  78     &quot;ArrayBufferView&quot; =&gt; 1,
  79     &quot;DataView&quot; =&gt; 1,
  80     &quot;Float32Array&quot; =&gt; 1,
  81     &quot;Float64Array&quot; =&gt; 1,
  82     &quot;Int16Array&quot; =&gt; 1,
  83     &quot;Int32Array&quot; =&gt; 1,
  84     &quot;Int8Array&quot; =&gt; 1,
  85     &quot;Uint16Array&quot; =&gt; 1,
  86     &quot;Uint32Array&quot; =&gt; 1,
  87     &quot;Uint8Array&quot; =&gt; 1,
  88     &quot;Uint8ClampedArray&quot; =&gt; 1,
  89 );
  90 
  91 my %primitiveTypeHash = ( 
  92     &quot;boolean&quot; =&gt; 1, 
  93     &quot;void&quot; =&gt; 1,
  94     &quot;Date&quot; =&gt; 1
  95 );
  96 
  97 my %dictionaryTypeImplementationNameOverrides = ();
  98 my %enumTypeImplementationNameOverrides = ();
  99 
 100 my %svgAttributesInHTMLHash = (
 101     &quot;class&quot; =&gt; 1,
 102     &quot;id&quot; =&gt; 1,
 103     &quot;onabort&quot; =&gt; 1,
 104     &quot;onclick&quot; =&gt; 1,
 105     &quot;onerror&quot; =&gt; 1,
 106     &quot;onload&quot; =&gt; 1,
 107     &quot;onmousedown&quot; =&gt; 1,
 108     &quot;onmouseenter&quot; =&gt; 1,
 109     &quot;onmouseleave&quot; =&gt; 1,
 110     &quot;onmousemove&quot; =&gt; 1,
 111     &quot;onmouseout&quot; =&gt; 1,
 112     &quot;onmouseover&quot; =&gt; 1,
 113     &quot;onmouseup&quot; =&gt; 1,
 114     &quot;onresize&quot; =&gt; 1,
 115     &quot;onscroll&quot; =&gt; 1,
 116     &quot;onunload&quot; =&gt; 1,
 117 );
 118 
 119 # Cache of IDL file pathnames.
 120 my $idlFiles;
 121 my $cachedInterfaces = {};
 122 my $cachedExternalDictionaries = {};
 123 my $cachedExternalEnumerations = {};
 124 my $cachedTypes = {};
 125 
 126 sub assert
 127 {
 128     my $message = shift;
 129     
 130     my $mess = longmess();
 131     print Dumper($mess);
 132 
 133     die $message;
 134 }
 135 
 136 # Default constructor
 137 sub new
 138 {
 139     my $object = shift;
 140     my $reference = { };
 141 
 142     $useDirectories = shift;
 143     $useGenerator = shift;
 144     $useOutputDir = shift;
 145     $useOutputHeadersDir = shift;
 146     $preprocessor = shift;
 147     $writeDependencies = shift;
 148     $verbose = shift;
 149     $targetIdlFilePath = shift;
 150     $idlAttributes = shift;
 151     $supplementalDependencies = shift;
 152 
 153     bless($reference, $object);
 154     return $reference;
 155 }
 156 
 157 sub ProcessDocument
 158 {
 159     my $object = shift;
 160     $useDocument = shift;
 161     $defines = shift;
 162 
 163     $object-&gt;ProcessSupplementalDependencies($useDocument);
 164 
 165     my $ifaceName = &quot;CodeGenerator&quot; . $useGenerator;
 166     require $ifaceName . &quot;.pm&quot;;
 167 
 168     foreach my $dictionary (@{$useDocument-&gt;dictionaries}) {
 169         if ($dictionary-&gt;extendedAttributes-&gt;{&quot;ImplementedAs&quot;}) {
 170             $dictionaryTypeImplementationNameOverrides{$dictionary-&gt;type-&gt;name} = $dictionary-&gt;extendedAttributes-&gt;{&quot;ImplementedAs&quot;};
 171         }
 172     }
 173 
 174     foreach my $enumeration (@{$useDocument-&gt;enumerations}) {
 175         if ($enumeration-&gt;extendedAttributes-&gt;{&quot;ImplementedAs&quot;}) {
 176             $enumTypeImplementationNameOverrides{$enumeration-&gt;type-&gt;name} = $enumeration-&gt;extendedAttributes-&gt;{&quot;ImplementedAs&quot;};
 177         }
 178     }
 179 
 180     # Dynamically load external code generation perl module
 181     $codeGenerator = $ifaceName-&gt;new($object, $writeDependencies, $verbose, $targetIdlFilePath);
 182     unless (defined($codeGenerator)) {
 183         my $interfaces = $useDocument-&gt;interfaces;
 184         foreach my $interface (@$interfaces) {
 185             print &quot;Skipping $useGenerator code generation for IDL interface \&quot;&quot; . $interface-&gt;type-&gt;name . &quot;\&quot;.\n&quot; if $verbose;
 186         }
 187         return;
 188     }
 189 
 190     my $interfaces = $useDocument-&gt;interfaces;
 191     if (@$interfaces) {
 192         die &quot;Multiple interfaces per document are not supported&quot; if @$interfaces &gt; 1;
 193 
 194         my $interface = @$interfaces[0];
 195         print &quot;Generating $useGenerator bindings code for IDL interface \&quot;&quot; . $interface-&gt;type-&gt;name . &quot;\&quot;...\n&quot; if $verbose;
 196         $codeGenerator-&gt;GenerateInterface($interface, $defines, $useDocument-&gt;enumerations, $useDocument-&gt;dictionaries);
 197         $codeGenerator-&gt;WriteData($interface, $useOutputDir, $useOutputHeadersDir);
 198         return;
 199     }
 200 
 201     my $callbackFunctions = $useDocument-&gt;callbackFunctions;
 202     if (@$callbackFunctions) {
 203         die &quot;Multiple standalone callback functions per document are not supported&quot; if @$callbackFunctions &gt; 1;
 204 
 205         my $callbackFunction = @$callbackFunctions[0];
 206         print &quot;Generating $useGenerator bindings code for IDL callback function \&quot;&quot; . $callbackFunction-&gt;type-&gt;name . &quot;\&quot;...\n&quot; if $verbose;
 207         $codeGenerator-&gt;GenerateCallbackFunction($callbackFunction, $useDocument-&gt;enumerations, $useDocument-&gt;dictionaries);
 208         $codeGenerator-&gt;WriteData($callbackFunction, $useOutputDir, $useOutputHeadersDir);
 209         return;
 210     }
 211 
 212     my $dictionaries = $useDocument-&gt;dictionaries;
 213     if (@$dictionaries) {
 214         my $dictionary;
 215         my $otherDictionaries;
 216         if (@$dictionaries == 1) {
 217             $dictionary = @$dictionaries[0];
 218         } else {
 219             my $primaryDictionaryName = fileparse($targetIdlFilePath, &quot;.idl&quot;);
 220             for my $candidate (@$dictionaries) {
 221                 if ($candidate-&gt;type-&gt;name eq $primaryDictionaryName) {
 222                     $dictionary = $candidate;
 223                 } else {
 224                     push @$otherDictionaries, $candidate;
 225                 }
 226             }
 227             die &quot;Multiple dictionaries per document are only supported if one matches the filename&quot; unless $dictionary;
 228         }
 229 
 230         print &quot;Generating $useGenerator bindings code for IDL dictionary \&quot;&quot; . $dictionary-&gt;type-&gt;name . &quot;\&quot;...\n&quot; if $verbose;
 231         $codeGenerator-&gt;GenerateDictionary($dictionary, $useDocument-&gt;enumerations, $otherDictionaries);
 232         $codeGenerator-&gt;WriteData($dictionary, $useOutputDir, $useOutputHeadersDir);
 233         return;
 234     }
 235     
 236     my $enumerations = $useDocument-&gt;enumerations;
 237     if (@$enumerations) {
 238         die &quot;Multiple standalone enumerations per document are not supported&quot; if @$enumerations &gt; 1;
 239 
 240         my $enumeration = @$enumerations[0];
 241         print &quot;Generating $useGenerator bindings code for IDL enumeration \&quot;&quot; . $enumeration-&gt;type-&gt;name . &quot;\&quot;...\n&quot; if $verbose;
 242         $codeGenerator-&gt;GenerateEnumeration($enumeration);
 243         $codeGenerator-&gt;WriteData($enumeration, $useOutputDir, $useOutputHeadersDir);
 244         return;
 245     }
 246 
 247     die &quot;Processing document &quot; . $useDocument-&gt;fileName . &quot; did not generate anything&quot;
 248 }
 249 
 250 sub ProcessSupplementalDependencies
 251 {
 252     my ($object, $targetDocument) = @_;
 253     my $targetFileName = fileparse($targetDocument-&gt;fileName);
 254     my $targetInterfaceName = fileparse($targetFileName, &quot;.idl&quot;);
 255 
 256     if (!$supplementalDependencies) {
 257         return;
 258     }
 259 
 260     foreach my $idlFile (@{$supplementalDependencies-&gt;{$targetFileName}}) {
 261         next if fileparse($idlFile) eq $targetFileName;
 262 
 263         my $interfaceName = fileparse($idlFile, &quot;.idl&quot;);
 264         my $parser = IDLParser-&gt;new(!$verbose);
 265         my $document = $parser-&gt;Parse($idlFile, $defines, $preprocessor, $idlAttributes);
 266 
 267         foreach my $interface (@{$document-&gt;interfaces}) {
 268             next unless !$interface-&gt;isPartial || $interface-&gt;type-&gt;name eq $targetInterfaceName;
 269 
 270             my $targetDataNode;
 271             my @targetGlobalContexts;
 272             foreach my $interface (@{$targetDocument-&gt;interfaces}) {
 273                 if ($interface-&gt;type-&gt;name eq $targetInterfaceName) {
 274                     $targetDataNode = $interface;
 275                     my $exposedAttribute = $targetDataNode-&gt;extendedAttributes-&gt;{&quot;Exposed&quot;} || &quot;Window&quot;;
 276                     $exposedAttribute = substr($exposedAttribute, 1, -1) if substr($exposedAttribute, 0, 1) eq &quot;(&quot;;
 277                     @targetGlobalContexts = split(&quot;,&quot;, $exposedAttribute);
 278                     last;
 279                 }
 280             }
 281             die &quot;Not found an interface ${targetInterfaceName} in ${targetInterfaceName}.idl.&quot; unless defined $targetDataNode;
 282 
 283             # Support for attributes of partial interfaces.
 284             foreach my $attribute (@{$interface-&gt;attributes}) {
 285                 next unless shouldPropertyBeExposed($attribute, \@targetGlobalContexts);
 286 
 287                 # Record that this attribute is implemented by $interfaceName.
 288                 $attribute-&gt;extendedAttributes-&gt;{&quot;ImplementedBy&quot;} = $interfaceName if $interface-&gt;isPartial &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{Reflect};
 289 
 290                 # Add interface-wide extended attributes to each attribute.
 291                 foreach my $extendedAttributeName (keys %{$interface-&gt;extendedAttributes}) {
 292                     $attribute-&gt;extendedAttributes-&gt;{$extendedAttributeName} = $interface-&gt;extendedAttributes-&gt;{$extendedAttributeName};
 293                 }
 294                 push(@{$targetDataNode-&gt;attributes}, $attribute);
 295             }
 296 
 297             # Support for methods of partial interfaces.
 298             foreach my $operation (@{$interface-&gt;operations}) {
 299                 next unless shouldPropertyBeExposed($operation, \@targetGlobalContexts);
 300 
 301                 # Record that this method is implemented by $interfaceName.
 302                 $operation-&gt;extendedAttributes-&gt;{&quot;ImplementedBy&quot;} = $interfaceName if $interface-&gt;isPartial;
 303 
 304                 # Add interface-wide extended attributes to each method.
 305                 foreach my $extendedAttributeName (keys %{$interface-&gt;extendedAttributes}) {
 306                     $operation-&gt;extendedAttributes-&gt;{$extendedAttributeName} = $interface-&gt;extendedAttributes-&gt;{$extendedAttributeName};
 307                 }
 308                 push(@{$targetDataNode-&gt;operations}, $operation);
 309             }
 310 
 311             # Support for constants of partial interfaces.
 312             foreach my $constant (@{$interface-&gt;constants}) {
 313                 next unless shouldPropertyBeExposed($constant, \@targetGlobalContexts);
 314 
 315                 # Record that this constant is implemented by $interfaceName.
 316                 $constant-&gt;extendedAttributes-&gt;{&quot;ImplementedBy&quot;} = $interfaceName if $interface-&gt;isPartial;
 317 
 318                 # Add interface-wide extended attributes to each constant.
 319                 foreach my $extendedAttributeName (keys %{$interface-&gt;extendedAttributes}) {
 320                     $constant-&gt;extendedAttributes-&gt;{$extendedAttributeName} = $interface-&gt;extendedAttributes-&gt;{$extendedAttributeName};
 321                 }
 322                 push(@{$targetDataNode-&gt;constants}, $constant);
 323             }
 324         }
 325 
 326         foreach my $dictionary (@{$document-&gt;dictionaries}) {
 327             next unless $dictionary-&gt;isPartial &amp;&amp; $dictionary-&gt;type-&gt;name eq $targetInterfaceName;
 328 
 329             my $targetDataNode;
 330             my @targetGlobalContexts;
 331             foreach my $dictionary (@{$targetDocument-&gt;dictionaries}) {
 332                 if ($dictionary-&gt;type-&gt;name eq $targetInterfaceName) {
 333                     $targetDataNode = $dictionary;
 334                     my $exposedAttribute = $targetDataNode-&gt;extendedAttributes-&gt;{&quot;Exposed&quot;} || &quot;Window&quot;;
 335                     $exposedAttribute = substr($exposedAttribute, 1, -1) if substr($exposedAttribute, 0, 1) eq &quot;(&quot;;
 336                     @targetGlobalContexts = split(&quot;,&quot;, $exposedAttribute);
 337                     last;
 338                 }
 339             }
 340             die &quot;Could not find dictionary ${targetInterfaceName} in ${targetInterfaceName}.idl.&quot; unless defined $targetDataNode;
 341 
 342             # Support for members of partial dictionaries
 343             foreach my $member (@{$dictionary-&gt;members}) {
 344                 next unless shouldPropertyBeExposed($member, \@targetGlobalContexts);
 345 
 346                 # Record that this member is implemented by $interfaceName.
 347                 $member-&gt;extendedAttributes-&gt;{&quot;ImplementedBy&quot;} = $interfaceName;
 348 
 349                 # Add interface-wide extended attributes to each member.
 350                 foreach my $extendedAttributeName (keys %{$dictionary-&gt;extendedAttributes}) {
 351                     $member-&gt;extendedAttributes-&gt;{$extendedAttributeName} = $dictionary-&gt;extendedAttributes-&gt;{$extendedAttributeName};
 352                 }
 353                 push(@{$targetDataNode-&gt;members}, $member);
 354             }
 355         }
 356     }
 357 }
 358 
 359 # Attributes / Operations / Constants of supplemental interfaces can have an [Exposed=XX] attribute which restricts
 360 # on which global contexts they should be exposed.
 361 sub shouldPropertyBeExposed
 362 {
 363     my ($context, $targetGlobalContexts) = @_;
 364 
 365     my $exposed = $context-&gt;extendedAttributes-&gt;{Exposed};
 366 
 367     return 1 unless $exposed;
 368 
 369     $exposed = substr($exposed, 1, -1) if substr($exposed, 0, 1) eq &quot;(&quot;;
 370     my @sourceGlobalContexts = split(&quot;,&quot;, $exposed);
 371 
 372     for my $targetGlobalContext (@$targetGlobalContexts) {
 373         return 1 if grep(/^$targetGlobalContext$/, @sourceGlobalContexts);
 374     }
 375     return 0;
 376 }
 377 
 378 sub FileNamePrefix
 379 {
 380     my $object = shift;
 381 
 382     my $ifaceName = &quot;CodeGenerator&quot; . $useGenerator;
 383     require $ifaceName . &quot;.pm&quot;;
 384 
 385     # Dynamically load external code generation perl module
 386     $codeGenerator = $ifaceName-&gt;new($object, $writeDependencies, $verbose);
 387     return $codeGenerator-&gt;FileNamePrefix();
 388 }
 389 
 390 sub UpdateFile
 391 {
 392     my $object = shift;
 393     my $fileName = shift;
 394     my $contents = shift;
 395 
 396     # FIXME: We should only write content if it is different from what is in the file.
 397     # But that would mean running more often the binding generator, see https://bugs.webkit.org/show_bug.cgi?id=131756
 398     open FH, &quot;&gt;&quot;, $fileName or die &quot;Couldn&#39;t open $fileName: $!\n&quot;;
 399     print FH $contents;
 400     close FH;
 401 }
 402 
 403 sub ForAllParents
 404 {
 405     my $object = shift;
 406     my $interface = shift;
 407     my $beforeRecursion = shift;
 408     my $afterRecursion = shift;
 409 
 410     my $recurse;
 411     $recurse = sub {
 412         my $outerInterface = shift;
 413         my $currentInterface = shift;
 414 
 415         if  ($currentInterface-&gt;parentType) {
 416             my $interfaceName = $currentInterface-&gt;parentType-&gt;name;
 417             my $parentInterface = $object-&gt;ParseInterface($outerInterface, $interfaceName);
 418 
 419             if ($beforeRecursion) {
 420                 &amp;$beforeRecursion($parentInterface) eq &#39;prune&#39; and next;
 421             }
 422             &amp;$recurse($outerInterface, $parentInterface);
 423             &amp;$afterRecursion($parentInterface) if $afterRecursion;
 424         }
 425     };
 426 
 427     &amp;$recurse($interface, $interface);
 428 }
 429 
 430 sub IDLFileForInterface
 431 {
 432     my $object = shift;
 433     my $interfaceName = shift;
 434 
 435     unless ($idlFiles) {
 436         my $sourceRoot = $ENV{SOURCE_ROOT};
 437         my @directories = map { $_ = &quot;$sourceRoot/$_&quot; if $sourceRoot &amp;&amp; -d &quot;$sourceRoot/$_&quot;; $_ } @$useDirectories;
 438         push(@directories, &quot;.&quot;);
 439 
 440         $idlFiles = { };
 441 
 442         my $wanted = sub {
 443             $idlFiles-&gt;{$1} = $File::Find::name if /^([A-Z].*)\.idl$/;
 444             $File::Find::prune = 1 if /^\../;
 445         };
 446         find($wanted, @directories);
 447     }
 448 
 449     return $idlFiles-&gt;{$interfaceName};
 450 }
 451 
 452 sub GetInterfaceForType
 453 {
 454     my ($object, $currentInterface, $type) = @_;
 455 
 456     return undef unless $object-&gt;IsInterfaceType($type);
 457 
 458     return $object-&gt;ParseInterface($currentInterface, $type-&gt;name);
 459 }
 460 
 461 sub GetAttributeFromInterface
 462 {
 463     my ($object, $outerInterface, $interfaceName, $attributeName) = @_;
 464 
 465     my $interface = $object-&gt;ParseInterface($outerInterface, $interfaceName);
 466     for my $attribute (@{$interface-&gt;attributes}) {
 467         return $attribute if $attribute-&gt;name eq $attributeName;
 468     }
 469     die(&quot;Could not find attribute &#39;$attributeName&#39; on interface &#39;$interfaceName&#39;.&quot;);
 470 }
 471 
 472 sub ParseInterface
 473 {
 474     my $object = shift;
 475     my $outerInterface = shift;
 476     my $interfaceName = shift;
 477 
 478     return undef if $interfaceName eq &#39;Object&#39;;
 479     return undef if $interfaceName eq &#39;UNION&#39;;
 480 
 481     if (exists $cachedInterfaces-&gt;{$interfaceName}) {
 482         return $cachedInterfaces-&gt;{$interfaceName};
 483     }
 484 
 485     # Step #1: Find the IDL file associated with &#39;interface&#39;
 486     my $filename = $object-&gt;IDLFileForInterface($interfaceName)
 487         or assert(&quot;Could NOT find IDL file for interface \&quot;$interfaceName\&quot;, reachable from \&quot;&quot; . $outerInterface-&gt;type-&gt;name . &quot;\&quot;!\n&quot;);
 488 
 489     print &quot;  |  |&gt;  Parsing parent IDL \&quot;$filename\&quot; for interface \&quot;$interfaceName\&quot;\n&quot; if $verbose;
 490 
 491     # Step #2: Parse the found IDL file (in quiet mode).
 492     my $parser = IDLParser-&gt;new(1);
 493     my $document = $parser-&gt;Parse($filename, $defines, $preprocessor, $idlAttributes);
 494 
 495     foreach my $interface (@{$document-&gt;interfaces}) {
 496         if ($interface-&gt;type-&gt;name eq $interfaceName) {
 497             $cachedInterfaces-&gt;{$interfaceName} = $interface;
 498             return $interface;
 499         }
 500     }
 501 
 502     die(&quot;Could NOT find interface definition for $interfaceName in $filename&quot;);
 503 }
 504 
 505 sub ParseType
 506 {
 507     my ($object, $typeString) = @_;
 508 
 509     return $cachedTypes-&gt;{$typeString} if exists($cachedTypes-&gt;{$typeString});
 510 
 511     my $parser = IDLParser-&gt;new(1);
 512     my $type = $parser-&gt;ParseType($typeString, $idlAttributes);
 513 
 514     $cachedTypes-&gt;{$typeString} = $type;
 515 
 516     return $type;
 517 }
 518 
 519 # Helpers for all CodeGenerator***.pm modules
 520 
 521 sub IsNumericType
 522 {
 523     my ($object, $type) = @_;
 524 
 525     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 526 
 527     return 1 if $integerTypeHash{$type-&gt;name};
 528     return 1 if $floatingPointTypeHash{$type-&gt;name};
 529     return 0;
 530 }
 531 
 532 sub IsStringOrEnumType
 533 {
 534     my ($object, $type) = @_;
 535     
 536     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 537 
 538     return 1 if $object-&gt;IsStringType($type);
 539     return 1 if $object-&gt;IsEnumType($type);
 540     return 0;
 541 }
 542 
 543 sub IsIntegerType
 544 {
 545     my ($object, $type) = @_;
 546 
 547     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 548 
 549     return 1 if $integerTypeHash{$type-&gt;name};
 550     return 0;
 551 }
 552 
 553 sub IsFloatingPointType
 554 {
 555     my ($object, $type) = @_;
 556 
 557     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 558 
 559     return 1 if $floatingPointTypeHash{$type-&gt;name};
 560     return 0;
 561 }
 562 
 563 sub IsPrimitiveType
 564 {
 565     my ($object, $type) = @_;
 566 
 567     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 568 
 569     return 1 if $primitiveTypeHash{$type-&gt;name};
 570     return 1 if $object-&gt;IsNumericType($type);
 571     return 0;
 572 }
 573 
 574 sub IsStringType
 575 {
 576     my ($object, $type) = @_;
 577 
 578     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 579 
 580     return 1 if $stringTypeHash{$type-&gt;name};
 581     return 0;
 582 }
 583 
 584 sub IsEnumType
 585 {
 586     my ($object, $type) = @_;
 587 
 588     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 589 
 590     return defined($object-&gt;GetEnumByType($type));
 591 }
 592 
 593 sub GetEnumByType
 594 {
 595     my ($object, $type) = @_;
 596 
 597     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 598 
 599     my $name = $type-&gt;name;
 600 
 601     die &quot;GetEnumByType() was called with an undefined enumeration name&quot; unless defined($name);
 602 
 603     for my $enumeration (@{$useDocument-&gt;enumerations}) {
 604         return $enumeration if $enumeration-&gt;type-&gt;name eq $name;
 605     }
 606 
 607     return $cachedExternalEnumerations-&gt;{$name} if exists($cachedExternalEnumerations-&gt;{$name});
 608 
 609     # Find the IDL file associated with the dictionary.
 610     my $filename = $object-&gt;IDLFileForInterface($name) or return;
 611 
 612     # Do a fast check to see if it seems to contain a dictionary.
 613     my $fileContents = slurp($filename);
 614 
 615     if ($fileContents =~ /\benum\s+$name/gs) {
 616         # Parse the IDL.
 617         my $parser = IDLParser-&gt;new(1);
 618         my $document = $parser-&gt;Parse($filename, $defines, $preprocessor, $idlAttributes);
 619 
 620         foreach my $enumeration (@{$document-&gt;enumerations}) {
 621             next unless $enumeration-&gt;type-&gt;name eq $name;
 622 
 623             $cachedExternalEnumerations-&gt;{$name} = $enumeration;
 624             my $implementedAs = $enumeration-&gt;extendedAttributes-&gt;{ImplementedAs};
 625             $enumTypeImplementationNameOverrides{$enumeration-&gt;type-&gt;name} = $implementedAs if $implementedAs;
 626             return $enumeration;
 627         }
 628     }
 629     $cachedExternalEnumerations-&gt;{$name} = undef;
 630 }
 631 
 632 # An enumeration defined in its own IDL file.
 633 sub IsExternalEnumType
 634 {
 635     my ($object, $type) = @_;
 636 
 637     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 638 
 639     return $object-&gt;IsEnumType($type) &amp;&amp; defined($cachedExternalEnumerations-&gt;{$type-&gt;name});
 640 }
 641 
 642 sub HasEnumImplementationNameOverride
 643 {
 644     my ($object, $type) = @_;
 645 
 646     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 647 
 648     return 1 if exists $enumTypeImplementationNameOverrides{$type-&gt;name};
 649     return 0;
 650 }
 651 
 652 sub GetEnumImplementationNameOverride
 653 {
 654     my ($object, $type) = @_;
 655 
 656     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 657 
 658     return $enumTypeImplementationNameOverrides{$type-&gt;name};
 659 }
 660 
 661 sub GetDictionaryByType
 662 {
 663     my ($object, $type) = @_;
 664 
 665     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 666 
 667     my $name = $type-&gt;name;
 668 
 669     die &quot;GetDictionaryByType() was called with an undefined dictionary name&quot; unless defined($name);
 670 
 671     for my $dictionary (@{$useDocument-&gt;dictionaries}) {
 672         return $dictionary if $dictionary-&gt;type-&gt;name eq $name;
 673     }
 674 
 675     return $cachedExternalDictionaries-&gt;{$name} if exists($cachedExternalDictionaries-&gt;{$name});
 676 
 677     # Find the IDL file associated with the dictionary.
 678     my $filename = $object-&gt;IDLFileForInterface($name) or return;
 679 
 680     # Do a fast check to see if it seems to contain a dictionary.
 681     my $fileContents = slurp($filename);
 682 
 683     if ($fileContents =~ /\bdictionary\s+$name/gs) {
 684         # Parse the IDL.
 685         my $parser = IDLParser-&gt;new(1);
 686         my $document = $parser-&gt;Parse($filename, $defines, $preprocessor, $idlAttributes);
 687 
 688         $object-&gt;ProcessSupplementalDependencies($document);
 689 
 690         foreach my $dictionary (@{$document-&gt;dictionaries}) {
 691             next unless $dictionary-&gt;type-&gt;name eq $name;
 692 
 693             $cachedExternalDictionaries-&gt;{$name} = $dictionary;
 694             my $implementedAs = $dictionary-&gt;extendedAttributes-&gt;{ImplementedAs};
 695             $dictionaryTypeImplementationNameOverrides{$dictionary-&gt;type-&gt;name} = $implementedAs if $implementedAs;
 696             return $dictionary;
 697         }
 698     }
 699     $cachedExternalDictionaries-&gt;{$name} = undef;
 700 }
 701 
 702 sub IsDictionaryType
 703 {
 704     my ($object, $type) = @_;
 705 
 706     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 707 
 708     return $type-&gt;name =~ /^[A-Z]/ &amp;&amp; defined($object-&gt;GetDictionaryByType($type));
 709 }
 710 
 711 # A dictionary defined in its own IDL file.
 712 sub IsExternalDictionaryType
 713 {
 714     my ($object, $type) = @_;
 715 
 716     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 717 
 718     return $object-&gt;IsDictionaryType($type) &amp;&amp; defined($cachedExternalDictionaries-&gt;{$type-&gt;name});
 719 }
 720 
 721 sub HasDictionaryImplementationNameOverride
 722 {
 723     my ($object, $type) = @_;
 724 
 725     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 726 
 727     return 1 if exists $dictionaryTypeImplementationNameOverrides{$type-&gt;name};
 728     return 0;
 729 }
 730 
 731 sub GetDictionaryImplementationNameOverride
 732 {
 733     my ($object, $type) = @_;
 734 
 735     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 736 
 737     return $dictionaryTypeImplementationNameOverrides{$type-&gt;name};
 738 }
 739 
 740 sub IsSVGAnimatedTypeName
 741 {
 742     my ($object, $typeName) = @_;
 743 
 744     return $typeName =~ /^SVGAnimated/;
 745 }
 746 
 747 sub IsSVGAnimatedType
 748 {
 749     my ($object, $type) = @_;
 750 
 751     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 752 
 753     return $object-&gt;IsSVGAnimatedTypeName($type-&gt;name);
 754 }
 755 
 756 sub IsSVGPathSegTypeName
 757 {
 758     my ($object, $typeName) = @_;
 759 
 760     return $typeName =~ /^SVGPathSeg/;
 761 }
 762 
 763 sub IsSVGPathSegType
 764 {
 765     my ($object, $type) = @_;
 766 
 767     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 768 
 769     return $object-&gt;IsSVGPathSegTypeName($type-&gt;name);
 770 }
 771 
 772 sub IsConstructorType
 773 {
 774     my ($object, $type) = @_;
 775 
 776     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 777 
 778     return $type-&gt;name =~ /Constructor$/;
 779 }
 780 
 781 sub IsSequenceType
 782 {
 783     my ($object, $type) = @_;
 784 
 785     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 786 
 787     return $type-&gt;name eq &quot;sequence&quot;;
 788 }
 789 
 790 sub IsFrozenArrayType
 791 {
 792     my ($object, $type) = @_;
 793 
 794     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 795 
 796     return $type-&gt;name eq &quot;FrozenArray&quot;;
 797 }
 798 
 799 sub IsSequenceOrFrozenArrayType
 800 {
 801     my ($object, $type) = @_;
 802 
 803     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 804 
 805     return $object-&gt;IsSequenceType($type) || $object-&gt;IsFrozenArrayType($type);
 806 }
 807 
 808 sub IsRecordType
 809 {
 810     my ($object, $type) = @_;
 811 
 812     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 813 
 814     return $type-&gt;name eq &quot;record&quot;;
 815 }
 816 
 817 sub IsBufferSourceType
 818 {
 819     my ($object, $type) = @_;
 820 
 821     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 822 
 823     return 1 if $bufferSourceTypes{$type-&gt;name};
 824     return 0;
 825 }
 826 
 827 sub IsPromiseType
 828 {
 829     my ($object, $type) = @_;
 830 
 831     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 832 
 833     return $type-&gt;name eq &quot;Promise&quot;;
 834 }
 835 
 836 # These match WK_lcfirst and WK_ucfirst defined in builtins_generator.py.
 837 # Uppercase the first letter while respecting WebKit style guidelines.
 838 # E.g., xmlEncoding becomes XMLEncoding, but xmlllang becomes Xmllang.
 839 sub WK_ucfirst
 840 {
 841     my ($object, $param) = @_;
 842 
 843     my $ret = ucfirst($param);
 844     $ret =~ s/Xml/XML/ if $ret =~ /^Xml[^a-z]/;
 845     $ret =~ s/Svg/SVG/ if $ret =~ /^Svg/;
 846     $ret =~ s/Srgb/SRGB/ if $ret =~ /^Srgb/;
 847     $ret =~ s/Cenc/cenc/ if $ret =~ /^Cenc/;
 848     $ret =~ s/Cbcs/cbcs/ if $ret =~ /^Cbcs/;
 849     $ret =~ s/Pq/PQ/ if $ret =~ /^Pq$/;
 850     $ret =~ s/Hlg/HLG/ if $ret =~ /^Hlg/;
 851 
 852     return $ret;
 853 }
 854 
 855 # Lowercase the first letter while respecting WebKit style guidelines.
 856 # URL becomes url, but SetURL becomes setURL.
 857 sub WK_lcfirst
 858 {
 859     my ($object, $param) = @_;
 860 
 861     my $ret = lcfirst($param);
 862     $ret =~ s/dOM/dom/ if $ret =~ /^dOM/;
 863     $ret =~ s/hTML/html/ if $ret =~ /^hTML/;
 864     $ret =~ s/uRL/url/ if $ret =~ /^uRL/;
 865     $ret =~ s/jS/js/ if $ret =~ /^jS/;
 866     $ret =~ s/xML/xml/ if $ret =~ /^xML/;
 867     $ret =~ s/xSLT/xslt/ if $ret =~ /^xSLT/;
 868     $ret =~ s/cSS/css/ if $ret =~ /^cSS/;
 869     $ret =~ s/rTC/rtc/ if $ret =~ /^rTC/;
 870 
 871     # For HTML5 FileSystem API Flags attributes.
 872     # (create is widely used to instantiate an object and must be avoided.)
 873     $ret =~ s/^create/isCreate/ if $ret =~ /^create$/;
 874     $ret =~ s/^exclusive/isExclusive/ if $ret =~ /^exclusive$/;
 875 
 876     return $ret;
 877 }
 878 
 879 sub slurp
 880 {
 881     my $file = shift;
 882 
 883     open my $fh, &#39;&lt;&#39;, $file or die;
 884     local $/ = undef;
 885     my $content = &lt;$fh&gt;;
 886     close $fh;
 887     return $content;
 888 }
 889 
 890 sub trim
 891 {
 892     my $string = shift;
 893 
 894     $string =~ s/^\s+|\s+$//g;
 895     return $string;
 896 }
 897 
 898 # Return the C++ namespace that a given attribute name string is defined in.
 899 sub NamespaceForAttributeName
 900 {
 901     my ($object, $interfaceName, $attributeName) = @_;
 902 
 903     return &quot;SVGNames&quot; if $interfaceName =~ /^SVG/ &amp;&amp; !$svgAttributesInHTMLHash{$attributeName};
 904     return &quot;HTMLNames&quot;;
 905 }
 906 
 907 # Identifies overloaded functions and for each function adds an array with
 908 # links to its respective overloads (including itself).
 909 sub LinkOverloadedOperations
 910 {
 911     my ($object, $interface) = @_;
 912 
 913     my %nameToOperationsMap = ();
 914     foreach my $operation (@{$interface-&gt;operations}) {
 915         my $name = $operation-&gt;name;
 916         $nameToOperationsMap{$name} = [] if !exists $nameToOperationsMap{$name};
 917         push(@{$nameToOperationsMap{$name}}, $operation);
 918         $operation-&gt;{overloads} = $nameToOperationsMap{$name};
 919         $operation-&gt;{overloadIndex} = @{$nameToOperationsMap{$name}};
 920     }
 921 
 922     my $index = 1;
 923     foreach my $constructor (@{$interface-&gt;constructors}) {
 924         $constructor-&gt;{overloads} = $interface-&gt;constructors;
 925         $constructor-&gt;{overloadIndex} = $index;
 926         $index++;
 927     }
 928 }
 929 
 930 sub AttributeNameForGetterAndSetter
 931 {
 932     my ($generator, $attribute) = @_;
 933 
 934     my $attributeName = $attribute-&gt;name;
 935     if ($attribute-&gt;extendedAttributes-&gt;{&quot;ImplementedAs&quot;}) {
 936         $attributeName = $attribute-&gt;extendedAttributes-&gt;{&quot;ImplementedAs&quot;};
 937     }
 938     my $attributeType = $attribute-&gt;type;
 939 
 940     # SVG animated types need to use a special attribute name.
 941     # The rest of the special casing for SVG animated types is handled in the language-specific code generators.
 942     $attributeName .= &quot;Animated&quot; if $generator-&gt;IsSVGAnimatedType($attributeType);
 943 
 944     return $attributeName;
 945 }
 946 
 947 sub ContentAttributeName
 948 {
 949     my ($generator, $implIncludes, $interfaceName, $attribute) = @_;
 950 
 951     my $contentAttributeName = $attribute-&gt;extendedAttributes-&gt;{&quot;Reflect&quot;};
 952     return undef if !$contentAttributeName;
 953 
 954     $contentAttributeName = lc $generator-&gt;AttributeNameForGetterAndSetter($attribute) if $contentAttributeName eq &quot;VALUE_IS_MISSING&quot;;
 955 
 956     my $namespace = $generator-&gt;NamespaceForAttributeName($interfaceName, $contentAttributeName);
 957 
 958     $implIncludes-&gt;{&quot;${namespace}.h&quot;} = 1;
 959     return &quot;WebCore::${namespace}::${contentAttributeName}Attr&quot;;
 960 }
 961 
 962 sub GetterExpression
 963 {
 964     my ($generator, $implIncludes, $interfaceName, $attribute) = @_;
 965 
 966     my $contentAttributeName = $generator-&gt;ContentAttributeName($implIncludes, $interfaceName, $attribute);
 967 
 968     if (!$contentAttributeName) {
 969         return ($generator-&gt;WK_lcfirst($generator-&gt;AttributeNameForGetterAndSetter($attribute)));
 970     }
 971 
 972     my $attributeType = $attribute-&gt;type;
 973 
 974     my $functionName;
 975     if ($attribute-&gt;extendedAttributes-&gt;{&quot;URL&quot;}) {
 976         $functionName = &quot;getURLAttribute&quot;;
 977     } elsif ($attributeType-&gt;name eq &quot;boolean&quot;) {
 978         $functionName = &quot;hasAttributeWithoutSynchronization&quot;;
 979     } elsif ($attributeType-&gt;name eq &quot;long&quot;) {
 980         $functionName = &quot;getIntegralAttribute&quot;;
 981     } elsif ($attributeType-&gt;name eq &quot;unsigned long&quot;) {
 982         $functionName = &quot;getUnsignedIntegralAttribute&quot;;
 983     } else {
 984         if ($contentAttributeName eq &quot;WebCore::HTMLNames::idAttr&quot;) {
 985             $functionName = &quot;getIdAttribute&quot;;
 986             $contentAttributeName = &quot;&quot;;
 987         } elsif ($contentAttributeName eq &quot;WebCore::HTMLNames::nameAttr&quot;) {
 988             $functionName = &quot;getNameAttribute&quot;;
 989             $contentAttributeName = &quot;&quot;;
 990         } elsif ($generator-&gt;IsSVGAnimatedType($attributeType)) {
 991             $functionName = &quot;getAttribute&quot;;
 992         } else {
 993             $functionName = &quot;attributeWithoutSynchronization&quot;;
 994         }
 995     }
 996 
 997     return ($functionName, $contentAttributeName);
 998 }
 999 
1000 sub SetterExpression
1001 {
1002     my ($generator, $implIncludes, $interfaceName, $attribute) = @_;
1003 
1004     my $contentAttributeName = $generator-&gt;ContentAttributeName($implIncludes, $interfaceName, $attribute);
1005 
1006     if (!$contentAttributeName) {
1007         return (&quot;set&quot; . $generator-&gt;WK_ucfirst($generator-&gt;AttributeNameForGetterAndSetter($attribute)));
1008     }
1009 
1010     my $attributeType = $attribute-&gt;type;
1011 
1012     my $functionName;
1013     if ($attributeType-&gt;name eq &quot;boolean&quot;) {
1014         $functionName = &quot;setBooleanAttribute&quot;;
1015     } elsif ($attributeType-&gt;name eq &quot;long&quot;) {
1016         $functionName = &quot;setIntegralAttribute&quot;;
1017     } elsif ($attributeType-&gt;name eq &quot;unsigned long&quot;) {
1018         $functionName = &quot;setUnsignedIntegralAttribute&quot;;
1019     } elsif ($generator-&gt;IsSVGAnimatedType($attributeType)) {
1020         $functionName = &quot;setAttribute&quot;;
1021     } else {
1022         $functionName = &quot;setAttributeWithoutSynchronization&quot;;
1023     }
1024 
1025     return ($functionName, $contentAttributeName);
1026 }
1027 
1028 sub IsBuiltinType
1029 {
1030     my ($object, $type) = @_;
1031 
1032     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
1033 
1034     return 1 if $object-&gt;IsPrimitiveType($type);
1035     return 1 if $object-&gt;IsSequenceOrFrozenArrayType($type);
1036     return 1 if $object-&gt;IsRecordType($type);
1037     return 1 if $object-&gt;IsStringType($type);
1038     return 1 if $object-&gt;IsBufferSourceType($type);
1039     return 1 if $type-&gt;isUnion;
1040     return 1 if $type-&gt;name eq &quot;EventListener&quot;;
1041     return 1 if $type-&gt;name eq &quot;JSON&quot;;
1042     return 1 if $type-&gt;name eq &quot;Promise&quot;;
1043     return 1 if $type-&gt;name eq &quot;ScheduledAction&quot;;
1044     return 1 if $type-&gt;name eq &quot;SerializedScriptValue&quot;;
1045     return 1 if $type-&gt;name eq &quot;XPathNSResolver&quot;;
1046     return 1 if $type-&gt;name eq &quot;any&quot;;
1047     return 1 if $type-&gt;name eq &quot;object&quot;;
1048 
1049     return 0;
1050 }
1051 
1052 sub IsInterfaceType
1053 {
1054     my ($object, $type) = @_;
1055 
1056     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
1057 
1058     return 0 if $object-&gt;IsBuiltinType($type);
1059     return 0 if $object-&gt;IsDictionaryType($type);
1060     return 0 if $object-&gt;IsEnumType($type);
1061 
1062     return 1;
1063 }
1064 
1065 sub IsWrapperType
1066 {
1067     my ($object, $type) = @_;
1068 
1069     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
1070 
1071     return 1 if $object-&gt;IsInterfaceType($type);
1072     return 1 if $type-&gt;name eq &quot;XPathNSResolver&quot;;
1073 
1074     return 0;
1075 }
1076 
1077 sub InheritsSerializable
1078 {
1079     my ($object, $interface) = @_;
1080 
1081     my $anyParentIsSerializable = 0;
1082     $object-&gt;ForAllParents($interface, sub {
1083         my $parentInterface = shift;
1084         $anyParentIsSerializable = 1 if $parentInterface-&gt;serializable;
1085     }, 0);
1086 
1087     return $anyParentIsSerializable;
1088 }
1089 
1090 sub IsSerializableType
1091 {
1092     my ($object, $interface, $type) = @_;
1093 
1094     # https://heycam.github.io/webidl/#dfn-serializable-type
1095 
1096     return 1 if $type-&gt;name eq &quot;boolean&quot;;
1097     return 1 if $object-&gt;IsNumericType($type);
1098     return 1 if $object-&gt;IsEnumType($type);
1099     return 1 if $object-&gt;IsStringType($type);
1100     return 0 if $type-&gt;name eq &quot;EventHandler&quot;;
1101 
1102     if ($type-&gt;isUnion || $object-&gt;IsDictionaryType($type)) {
1103         die &quot;Serializers for union and dictionary types are not currently supported.\n&quot;;
1104     }
1105 
1106     if ($object-&gt;IsSequenceOrFrozenArrayType($type)) {
1107         my $subtype = @{$type-&gt;subtypes}[0];
1108 
1109         # FIXME: webkit.org/b/194439 [WebIDL] Support serializing sequences and FrozenArrays of interfaces
1110         return 0 if $object-&gt;IsInterfaceType($subtype);
1111 
1112         return $object-&gt;IsSerializableType($interface, $subtype);
1113     }
1114 
1115     return 0 if !$object-&gt;IsInterfaceType($type);
1116 
1117     my $interfaceForType = $object-&gt;GetInterfaceForType($interface, $type);
1118     if ($interfaceForType) {
1119         return 1 if $interfaceForType-&gt;serializable;
1120         return $object-&gt;InheritsSerializable($interfaceForType);
1121     }
1122 
1123     return 0;
1124 }
1125 
1126 sub hasCachedAttributeOrCustomGetterExtendedAttribute
1127 {
1128     my ($attribute) = @_;
1129     return $attribute-&gt;extendedAttributes-&gt;{CachedAttribute} || $attribute-&gt;extendedAttributes-&gt;{CustomGetter};
1130 }
1131 
1132 sub IsSerializableAttribute
1133 {
1134     my ($object, $interface, $attribute) = @_;
1135 
1136     if ($object-&gt;IsSequenceType($attribute-&gt;type) &amp;&amp; hasCachedAttributeOrCustomGetterExtendedAttribute($attribute)) {
1137         die &quot;Serializers for sequence types with CachedAttribute or CustomGetter extended attributes are not currently supported.\n&quot;;
1138     }
1139 
1140     return $object-&gt;IsSerializableType($interface, $attribute-&gt;type);
1141 }
1142 
1143 sub GetInterfaceExtendedAttributesFromName
1144 {
1145     # FIXME: It&#39;s bad to have a function like this that opens another IDL file to answer a question.
1146     # Overusing this kind of function can make things really slow. Lets avoid these if we can.
1147 
1148     my ($object, $interfaceName) = @_;
1149 
1150     my $idlFile = $object-&gt;IDLFileForInterface($interfaceName) or assert(&quot;Could NOT find IDL file for interface \&quot;$interfaceName\&quot;!\n&quot;);
1151 
1152     open FILE, &quot;&lt;&quot;, $idlFile or die;
1153     my @lines = &lt;FILE&gt;;
1154     close FILE;
1155 
1156     my $fileContents = join(&#39;&#39;, @lines);
1157 
1158     my $extendedAttributes = {};
1159 
1160     if ($fileContents =~ /\[(.*)\]\s+(callback interface|interface|exception)\s+(\w+)/gs) {
1161         my @parts = split(&#39;,&#39;, $1);
1162         foreach my $part (@parts) {
1163             my @keyValue = split(&#39;=&#39;, $part);
1164             my $key = trim($keyValue[0]);
1165             next unless length($key);
1166             my $value = &quot;VALUE_IS_MISSING&quot;;
1167             $value = trim($keyValue[1]) if @keyValue &gt; 1;
1168             $extendedAttributes-&gt;{$key} = $value;
1169         }
1170     }
1171 
1172     return $extendedAttributes;
1173 }
1174 
1175 sub ComputeIsCallbackInterface
1176 {
1177     my ($object, $type) = @_;
1178 
1179     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
1180 
1181     return 0 unless $object-&gt;IsInterfaceType($type);
1182     return 0 if $type-&gt;name eq &quot;WindowProxy&quot;;
1183 
1184     my $typeName = $type-&gt;name;
1185     my $idlFile = $object-&gt;IDLFileForInterface($typeName) or assert(&quot;Could NOT find IDL file for interface \&quot;$typeName\&quot;!\n&quot;);
1186 
1187     open FILE, &quot;&lt;&quot;, $idlFile or die;
1188     my @lines = &lt;FILE&gt;;
1189     close FILE;
1190 
1191     my $fileContents = join(&#39;&#39;, @lines);
1192     return ($fileContents =~ /callback\s+interface\s+(\w+)/gs);
1193 }
1194 
1195 my %isCallbackInterface = ();
1196 
1197 sub IsCallbackInterface
1198 {
1199     # FIXME: It&#39;s bad to have a function like this that opens another IDL file to answer a question.
1200     # Overusing this kind of function can make things really slow. Lets avoid these if we can.
1201     # To mitigate that, lets cache what we learn in a hash so we don&#39;t open the same file over and over.
1202 
1203     my ($object, $type) = @_;
1204 
1205     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
1206 
1207     return $isCallbackInterface{$type-&gt;name} if exists $isCallbackInterface{$type-&gt;name};
1208     my $result = $object-&gt;ComputeIsCallbackInterface($type);
1209     $isCallbackInterface{$type-&gt;name} = $result;
1210     return $result;
1211 }
1212 
1213 sub ComputeIsCallbackFunction
1214 {
1215     my ($object, $type) = @_;
1216 
1217     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
1218 
1219     return 0 unless $object-&gt;IsInterfaceType($type);
1220     return 0 if $type-&gt;name eq &quot;WindowProxy&quot;;
1221 
1222     my $typeName = $type-&gt;name;
1223     my $idlFile = $object-&gt;IDLFileForInterface($typeName) or assert(&quot;Could NOT find IDL file for interface \&quot;$typeName\&quot;!\n&quot;);
1224 
1225     open FILE, &quot;&lt;&quot;, $idlFile or die;
1226     my @lines = &lt;FILE&gt;;
1227     close FILE;
1228 
1229     my $fileContents = join(&#39;&#39;, @lines);
1230     return ($fileContents =~ /(.*)callback\s+(\w+)\s+=/gs);
1231 }
1232 
1233 my %isCallbackFunction = ();
1234 
1235 sub IsCallbackFunction
1236 {
1237     # FIXME: It&#39;s bad to have a function like this that opens another IDL file to answer a question.
1238     # Overusing this kind of function can make things really slow. Lets avoid these if we can.
1239     # To mitigate that, lets cache what we learn in a hash so we don&#39;t open the same file over and over.
1240 
1241     my ($object, $type) = @_;
1242 
1243     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
1244 
1245     return $isCallbackFunction{$type-&gt;name} if exists $isCallbackFunction{$type-&gt;name};
1246     my $result = $object-&gt;ComputeIsCallbackFunction($type);
1247     $isCallbackFunction{$type-&gt;name} = $result;
1248     return $result;
1249 }
1250 
1251 sub GenerateConditionalString
1252 {
1253     my ($generator, $node) = @_;
1254 
1255     my $conditional = $node-&gt;extendedAttributes-&gt;{&quot;Conditional&quot;};
1256     if ($conditional) {
1257         return $generator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
1258     } else {
1259         return &quot;&quot;;
1260     }
1261 }
1262 
1263 sub GenerateConditionalStringFromAttributeValue
1264 {
1265     my ($generator, $conditional) = @_;
1266 
1267     my %disjunction;
1268     map {
1269         my $expression = $_;
1270         my %conjunction;
1271         map { $conjunction{$_} = 1; } split(/&amp;/, $expression);
1272         $expression = &quot;ENABLE(&quot; . join(&quot;) &amp;&amp; ENABLE(&quot;, sort keys %conjunction) . &quot;)&quot;;
1273         $disjunction{$expression} = 1
1274     } split(/\|/, $conditional);
1275 
1276     return &quot;1&quot; if keys %disjunction == 0;
1277     return (%disjunction)[0] if keys %disjunction == 1;
1278 
1279     my @parenthesized;
1280     map {
1281         my $expression = $_;
1282         $expression = &quot;($expression)&quot; if $expression =~ / /;
1283         push @parenthesized, $expression;
1284     } sort keys %disjunction;
1285 
1286     return join(&quot; || &quot;, @parenthesized);
1287 }
1288 
1289 sub GenerateCompileTimeCheckForEnumsIfNeeded
1290 {
1291     my ($generator, $interface) = @_;
1292 
1293     return () if $interface-&gt;extendedAttributes-&gt;{&quot;DoNotCheckConstants&quot;} || !@{$interface-&gt;constants};
1294 
1295     my $baseScope = $interface-&gt;extendedAttributes-&gt;{&quot;ConstantsScope&quot;} || $interface-&gt;type-&gt;name;
1296 
1297     my @checks = ();
1298     foreach my $constant (@{$interface-&gt;constants}) {
1299         my $scope = $constant-&gt;extendedAttributes-&gt;{&quot;ImplementedBy&quot;} || $baseScope;
1300         my $name = $constant-&gt;extendedAttributes-&gt;{&quot;Reflect&quot;} || $constant-&gt;name;
1301         my $value = $constant-&gt;value;
1302         my $conditional = $constant-&gt;extendedAttributes-&gt;{&quot;Conditional&quot;};
1303         push(@checks, &quot;#if &quot; . $generator-&gt;GenerateConditionalStringFromAttributeValue($conditional) . &quot;\n&quot;) if $conditional;
1304         push(@checks, &quot;static_assert(${scope}::${name} == ${value}, \&quot;${name} in ${scope} does not match value from IDL\&quot;);\n&quot;);
1305         push(@checks, &quot;#endif\n&quot;) if $conditional;
1306     }
1307     push(@checks, &quot;\n&quot;);
1308     return @checks;
1309 }
1310 
1311 sub ExtendedAttributeContains
1312 {
1313     my $object = shift;
1314     my $callWith = shift;
1315     return 0 unless $callWith;
1316     my $keyword = shift;
1317 
1318     my @callWithKeywords = split /\s*\&amp;\s*/, $callWith;
1319     return grep { $_ eq $keyword } @callWithKeywords;
1320 }
1321 
1322 # FIXME: This is backwards. We currently name the interface and the IDL files with the implementation name. We
1323 # should use the real interface name in the IDL files and then use ImplementedAs to map this to the implementation name.
1324 sub GetVisibleInterfaceName
1325 {
1326     my ($object, $interface) = @_;
1327 
1328     my $interfaceName = $interface-&gt;extendedAttributes-&gt;{&quot;InterfaceName&quot;};
1329     return $interfaceName ? $interfaceName : $interface-&gt;type-&gt;name;
1330 }
1331 
1332 sub InheritsInterface
1333 {
1334     my ($object, $interface, $interfaceName) = @_;
1335 
1336     return 1 if $interfaceName eq $interface-&gt;type-&gt;name;
1337 
1338     my $found = 0;
1339     $object-&gt;ForAllParents($interface, sub {
1340         my $currentInterface = shift;
1341         if ($currentInterface-&gt;type-&gt;name eq $interfaceName) {
1342             $found = 1;
1343         }
1344         return 1 if $found;
1345     }, 0);
1346 
1347     return $found;
1348 }
1349 
1350 sub InheritsExtendedAttribute
1351 {
1352     my ($object, $interface, $extendedAttribute) = @_;
1353 
1354     return 1 if $interface-&gt;extendedAttributes-&gt;{$extendedAttribute};
1355 
1356     my $found = 0;
1357     $object-&gt;ForAllParents($interface, sub {
1358         my $currentInterface = shift;
1359         if ($currentInterface-&gt;extendedAttributes-&gt;{$extendedAttribute}) {
1360             $found = 1;
1361         }
1362         return 1 if $found;
1363     }, 0);
1364 
1365     return $found;
1366 }
1367 
1368 
1369 1;
    </pre>
  </body>
</html>
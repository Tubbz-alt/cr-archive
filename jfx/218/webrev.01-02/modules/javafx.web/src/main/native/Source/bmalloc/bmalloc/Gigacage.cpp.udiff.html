<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Gigacage.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Environment.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Gigacage.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Gigacage.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -33,10 +33,14 @@</span>
  #include &quot;Vector.h&quot;
  #include &quot;bmalloc.h&quot;
  #include &lt;cstdio&gt;
  #include &lt;mutex&gt;
  
<span class="udiff-line-added">+ #if BOS(DARWIN)</span>
<span class="udiff-line-added">+ #include &lt;mach/mach.h&gt;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  #if GIGACAGE_ENABLED
  
  namespace Gigacage {
  
  struct Callback {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -55,11 +59,11 @@</span>
  }
  
  namespace bmalloc {
  
  struct PrimitiveDisableCallbacks : public StaticPerProcess&lt;PrimitiveDisableCallbacks&gt; {
<span class="udiff-line-modified-removed">-     PrimitiveDisableCallbacks(std::lock_guard&lt;Mutex&gt;&amp;) { }</span>
<span class="udiff-line-modified-added">+     PrimitiveDisableCallbacks(const LockHolder&amp;) { }</span>
  
      Vector&lt;Gigacage::Callback&gt; callbacks;
  };
  DECLARE_STATIC_PER_PROCESS_STORAGE(PrimitiveDisableCallbacks);
  DEFINE_STATIC_PER_PROCESS_STORAGE(PrimitiveDisableCallbacks);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -71,59 +75,87 @@</span>
  // This is exactly 32GB because inside JSC, indexed accesses for arrays, typed arrays, etc,
  // use unsigned 32-bit ints as indices. The items those indices access are 8 bytes or less
  // in size. 2^32 * 8 = 32GB. This means if an access on a caged type happens to go out of
  // bounds, the access is guaranteed to land somewhere else in the cage or inside the runway.
  // If this were less than 32GB, those OOB accesses could reach outside of the cage.
<span class="udiff-line-modified-removed">- constexpr size_t gigacageRunway = 32llu * 1024 * 1024 * 1024;</span>
<span class="udiff-line-modified-added">+ constexpr size_t gigacageRunway = 32llu * bmalloc::Sizes::GB;</span>
  
<span class="udiff-line-modified-removed">- // Note: g_gigacageBasePtrs[0] is reserved for storing the wasEnabled flag.</span>
<span class="udiff-line-removed">- // The first gigacageBasePtr will start at g_gigacageBasePtrs[sizeof(void*)].</span>
<span class="udiff-line-removed">- // This is done so that the wasEnabled flag will also be protected along with the</span>
<span class="udiff-line-removed">- // gigacageBasePtrs.</span>
<span class="udiff-line-removed">- alignas(gigacageBasePtrsSize) char g_gigacageBasePtrs[gigacageBasePtrsSize];</span>
<span class="udiff-line-modified-added">+ alignas(configSizeToProtect) Config g_gigacageConfig;</span>
  
  using namespace bmalloc;
  
  namespace {
  
<span class="udiff-line-modified-removed">- bool s_isDisablingPrimitiveGigacageDisabled;</span>
<span class="udiff-line-modified-added">+ #if BOS(DARWIN)</span>
<span class="udiff-line-added">+ enum {</span>
<span class="udiff-line-added">+     AllowPermissionChangesAfterThis = false,</span>
<span class="udiff-line-added">+     DisallowPermissionChangesAfterThis = true</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void freezeGigacageConfig()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     int result;</span>
<span class="udiff-line-added">+ #if BOS(DARWIN)</span>
<span class="udiff-line-added">+     result = vm_protect(mach_task_self(), reinterpret_cast&lt;vm_address_t&gt;(&amp;g_gigacageConfig), configSizeToProtect, AllowPermissionChangesAfterThis, VM_PROT_READ);</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+     result = mprotect(&amp;g_gigacageConfig, configSizeToProtect, PROT_READ);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     RELEASE_BASSERT(!result);</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">- void protectGigacageBasePtrs()</span>
<span class="udiff-line-modified-added">+ static void unfreezeGigacageConfig()</span>
  {
<span class="udiff-line-modified-removed">-     uintptr_t basePtrs = reinterpret_cast&lt;uintptr_t&gt;(g_gigacageBasePtrs);</span>
<span class="udiff-line-modified-removed">-     // We might only get page size alignment, but that&#39;s also the minimum we need.</span>
<span class="udiff-line-modified-removed">-     RELEASE_BASSERT(!(basePtrs &amp; (vmPageSize() - 1)));</span>
<span class="udiff-line-modified-removed">-     mprotect(g_gigacageBasePtrs, gigacageBasePtrsSize, PROT_READ);</span>
<span class="udiff-line-modified-added">+     RELEASE_BASSERT(!g_gigacageConfig.isPermanentlyFrozen);</span>
<span class="udiff-line-modified-added">+     int result;</span>
<span class="udiff-line-modified-added">+ #if BOS(DARWIN)</span>
<span class="udiff-line-modified-added">+     result = vm_protect(mach_task_self(), reinterpret_cast&lt;vm_address_t&gt;(&amp;g_gigacageConfig), configSizeToProtect, AllowPermissionChangesAfterThis, VM_PROT_READ | VM_PROT_WRITE);</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+     result = mprotect(&amp;g_gigacageConfig, configSizeToProtect, PROT_READ | PROT_WRITE);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     RELEASE_BASSERT(!result);</span>
  }
  
<span class="udiff-line-modified-removed">- void unprotectGigacageBasePtrs()</span>
<span class="udiff-line-modified-added">+ static void permanentlyFreezeGigacageConfig()</span>
  {
<span class="udiff-line-modified-removed">-     mprotect(g_gigacageBasePtrs, gigacageBasePtrsSize, PROT_READ | PROT_WRITE);</span>
<span class="udiff-line-modified-added">+     if (!g_gigacageConfig.isPermanentlyFrozen) {</span>
<span class="udiff-line-added">+         unfreezeGigacageConfig();</span>
<span class="udiff-line-added">+         g_gigacageConfig.isPermanentlyFrozen = true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // There&#39;s no going back now!</span>
<span class="udiff-line-added">+     int result;</span>
<span class="udiff-line-added">+ #if BOS(DARWIN)</span>
<span class="udiff-line-added">+     result = vm_protect(mach_task_self(), reinterpret_cast&lt;vm_address_t&gt;(&amp;g_gigacageConfig), configSizeToProtect, DisallowPermissionChangesAfterThis, VM_PROT_READ);</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+     result = mprotect(&amp;g_gigacageConfig, configSizeToProtect, PROT_READ);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     RELEASE_BASSERT(!result);</span>
  }
  
<span class="udiff-line-modified-removed">- class UnprotectGigacageBasePtrsScope {</span>
<span class="udiff-line-modified-added">+ class UnfreezeGigacageConfigScope {</span>
  public:
<span class="udiff-line-modified-removed">-     UnprotectGigacageBasePtrsScope()</span>
<span class="udiff-line-modified-added">+     UnfreezeGigacageConfigScope()</span>
      {
<span class="udiff-line-modified-removed">-         unprotectGigacageBasePtrs();</span>
<span class="udiff-line-modified-added">+         unfreezeGigacageConfig();</span>
      }
  
<span class="udiff-line-modified-removed">-     ~UnprotectGigacageBasePtrsScope()</span>
<span class="udiff-line-modified-added">+     ~UnfreezeGigacageConfigScope()</span>
      {
<span class="udiff-line-modified-removed">-         protectGigacageBasePtrs();</span>
<span class="udiff-line-modified-added">+         freezeGigacageConfig();</span>
      }
  };
  
  size_t runwaySize(Kind kind)
  {
      switch (kind) {
<span class="udiff-line-removed">-     case Kind::ReservedForFlagsAndNotABasePtr:</span>
<span class="udiff-line-removed">-         RELEASE_BASSERT_NOT_REACHED();</span>
      case Kind::Primitive:
          return gigacageRunway;
      case Kind::JSValue:
          return 0;
<span class="udiff-line-added">+     case Kind::NumberOfKinds:</span>
<span class="udiff-line-added">+         RELEASE_BASSERT_NOT_REACHED();</span>
      }
      return 0;
  }
  
  } // anonymous namespace
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -132,24 +164,31 @@</span>
  {
      static std::once_flag onceFlag;
      std::call_once(
          onceFlag,
          [] {
<span class="udiff-line-added">+             RELEASE_BASSERT(!g_gigacageConfig.ensureGigacageHasBeenCalled);</span>
<span class="udiff-line-added">+             g_gigacageConfig.ensureGigacageHasBeenCalled = true;</span>
<span class="udiff-line-added">+ </span>
              if (!shouldBeEnabled())
                  return;
  
<span class="udiff-line-modified-removed">-             Kind shuffledKinds[numKinds];</span>
<span class="udiff-line-modified-removed">-             for (unsigned i = 0; i &lt; numKinds; ++i)</span>
<span class="udiff-line-modified-removed">-                 shuffledKinds[i] = static_cast&lt;Kind&gt;(i + 1); // + 1 to skip Kind::ReservedForFlagsAndNotABasePtr.</span>
<span class="udiff-line-modified-added">+             // We might only get page size alignment, but that&#39;s also the minimum</span>
<span class="udiff-line-modified-added">+             // alignment we need for freezing the Config.</span>
<span class="udiff-line-modified-added">+             RELEASE_BASSERT(!(reinterpret_cast&lt;size_t&gt;(&amp;g_gigacageConfig) &amp; (vmPageSize() - 1)));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             Kind shuffledKinds[NumberOfKinds];</span>
<span class="udiff-line-added">+             for (unsigned i = 0; i &lt; NumberOfKinds; ++i)</span>
<span class="udiff-line-added">+                 shuffledKinds[i] = static_cast&lt;Kind&gt;(i);</span>
  
              // We just go ahead and assume that 64 bits is enough randomness. That&#39;s trivially true right
              // now, but would stop being true if we went crazy with gigacages. Based on my math, 21 is the
              // largest value of n so that n! &lt;= 2^64.
<span class="udiff-line-modified-removed">-             static_assert(numKinds &lt;= 21, &quot;too many kinds&quot;);</span>
<span class="udiff-line-modified-added">+             static_assert(NumberOfKinds &lt;= 21, &quot;too many kinds&quot;);</span>
              uint64_t random;
              cryptoRandom(reinterpret_cast&lt;unsigned char*&gt;(&amp;random), sizeof(random));
<span class="udiff-line-modified-removed">-             for (unsigned i = numKinds; i--;) {</span>
<span class="udiff-line-modified-added">+             for (unsigned i = NumberOfKinds; i--;) {</span>
                  unsigned limit = i + 1;
                  unsigned j = static_cast&lt;unsigned&gt;(random % limit);
                  random /= limit;
                  std::swap(shuffledKinds[i], shuffledKinds[j]);
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -182,103 +221,118 @@</span>
              }
  
              size_t nextCage = 0;
              for (Kind kind : shuffledKinds) {
                  nextCage = alignTo(kind, nextCage);
<span class="udiff-line-modified-removed">-                 basePtr(kind) = reinterpret_cast&lt;char*&gt;(base) + nextCage;</span>
<span class="udiff-line-modified-added">+                 g_gigacageConfig.setBasePtr(kind, reinterpret_cast&lt;char*&gt;(base) + nextCage);</span>
                  nextCage = bump(kind, nextCage);
                  if (runwaySize(kind) &gt; 0) {
                      char* runway = reinterpret_cast&lt;char*&gt;(base) + nextCage;
                      // Make OOB accesses into the runway crash.
                      vmRevokePermissions(runway, runwaySize(kind));
                      nextCage += runwaySize(kind);
                  }
              }
  
<span class="udiff-line-added">+             g_gigacageConfig.start = base;</span>
<span class="udiff-line-added">+             g_gigacageConfig.totalSize = totalSize;</span>
              vmDeallocatePhysicalPages(base, totalSize);
<span class="udiff-line-modified-removed">-             setWasEnabled();</span>
<span class="udiff-line-modified-removed">-             protectGigacageBasePtrs();</span>
<span class="udiff-line-modified-added">+             g_gigacageConfig.isEnabled = true;</span>
<span class="udiff-line-modified-added">+             freezeGigacageConfig();</span>
          });
  }
  
  void disablePrimitiveGigacage()
  {
<span class="udiff-line-added">+     if (g_gigacageConfig.disablingPrimitiveGigacageIsForbidden)</span>
<span class="udiff-line-added">+         fprintf(stderr, &quot;FATAL: Disabling Primitive gigacage is forbidden, but we don&#39;t want that in this process.\n&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     RELEASE_BASSERT(!g_gigacageConfig.disablingPrimitiveGigacageIsForbidden);</span>
<span class="udiff-line-added">+     RELEASE_BASSERT(!g_gigacageConfig.isPermanentlyFrozen);</span>
<span class="udiff-line-added">+ </span>
      ensureGigacage();
<span class="udiff-line-modified-removed">-     if (!basePtrs().primitive) {</span>
<span class="udiff-line-modified-added">+     if (!g_gigacageConfig.basePtrs[Primitive]) {</span>
          // It was never enabled. That means that we never even saved any callbacks. Or, we had already disabled
          // it before, and already called the callbacks.
          return;
      }
  
      PrimitiveDisableCallbacks&amp; callbacks = *PrimitiveDisableCallbacks::get();
<span class="udiff-line-modified-removed">-     std::unique_lock&lt;Mutex&gt; lock(PrimitiveDisableCallbacks::mutex());</span>
<span class="udiff-line-modified-added">+     UniqueLockHolder lock(PrimitiveDisableCallbacks::mutex());</span>
      for (Callback&amp; callback : callbacks.callbacks)
          callback.function(callback.argument);
      callbacks.callbacks.shrink(0);
<span class="udiff-line-modified-removed">-     UnprotectGigacageBasePtrsScope unprotectScope;</span>
<span class="udiff-line-modified-removed">-     basePtrs().primitive = nullptr;</span>
<span class="udiff-line-modified-added">+     UnfreezeGigacageConfigScope unfreezeScope;</span>
<span class="udiff-line-modified-added">+     g_gigacageConfig.basePtrs[Primitive] = nullptr;</span>
  }
  
  void addPrimitiveDisableCallback(void (*function)(void*), void* argument)
  {
      ensureGigacage();
<span class="udiff-line-modified-removed">-     if (!basePtrs().primitive) {</span>
<span class="udiff-line-modified-added">+     if (!g_gigacageConfig.basePtrs[Primitive]) {</span>
          // It was already disabled or we were never able to enable it.
          function(argument);
          return;
      }
  
      PrimitiveDisableCallbacks&amp; callbacks = *PrimitiveDisableCallbacks::get();
<span class="udiff-line-modified-removed">-     std::unique_lock&lt;Mutex&gt; lock(PrimitiveDisableCallbacks::mutex());</span>
<span class="udiff-line-modified-added">+     UniqueLockHolder lock(PrimitiveDisableCallbacks::mutex());</span>
      callbacks.callbacks.push(Callback(function, argument));
  }
  
  void removePrimitiveDisableCallback(void (*function)(void*), void* argument)
  {
      PrimitiveDisableCallbacks&amp; callbacks = *PrimitiveDisableCallbacks::get();
<span class="udiff-line-modified-removed">-     std::unique_lock&lt;Mutex&gt; lock(PrimitiveDisableCallbacks::mutex());</span>
<span class="udiff-line-modified-added">+     UniqueLockHolder lock(PrimitiveDisableCallbacks::mutex());</span>
      for (size_t i = 0; i &lt; callbacks.callbacks.size(); ++i) {
          if (callbacks.callbacks[i].function == function
              &amp;&amp; callbacks.callbacks[i].argument == argument) {
              callbacks.callbacks[i] = callbacks.callbacks.last();
              callbacks.callbacks.pop();
              return;
          }
      }
  }
  
<span class="udiff-line-modified-removed">- static void primitiveGigacageDisabled(void*)</span>
<span class="udiff-line-modified-added">+ static bool verifyGigacageIsEnabled()</span>
  {
<span class="udiff-line-modified-removed">-     if (GIGACAGE_ALLOCATION_CAN_FAIL &amp;&amp; !wasEnabled())</span>
<span class="udiff-line-modified-removed">-         return;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     static bool s_false;</span>
<span class="udiff-line-modified-removed">-     fprintf(stderr, &quot;FATAL: Primitive gigacage disabled, but we don&#39;t want that in this process.\n&quot;);</span>
<span class="udiff-line-modified-removed">-     if (!s_false)</span>
<span class="udiff-line-removed">-         BCRASH();</span>
<span class="udiff-line-modified-added">+     bool isEnabled = g_gigacageConfig.isEnabled;</span>
<span class="udiff-line-modified-added">+     for (size_t i = 0; i &lt; NumberOfKinds; ++i)</span>
<span class="udiff-line-modified-added">+         isEnabled = isEnabled &amp;&amp; g_gigacageConfig.basePtrs[i];</span>
<span class="udiff-line-modified-added">+     isEnabled = isEnabled &amp;&amp; g_gigacageConfig.start;</span>
<span class="udiff-line-modified-added">+     isEnabled = isEnabled &amp;&amp; g_gigacageConfig.totalSize;</span>
<span class="udiff-line-modified-added">+     return isEnabled;</span>
  }
  
<span class="udiff-line-modified-removed">- void disableDisablingPrimitiveGigacageIfShouldBeEnabled()</span>
<span class="udiff-line-modified-added">+ void forbidDisablingPrimitiveGigacage()</span>
  {
<span class="udiff-line-modified-removed">-     if (shouldBeEnabled()) {</span>
<span class="udiff-line-modified-removed">-         addPrimitiveDisableCallback(primitiveGigacageDisabled, nullptr);</span>
<span class="udiff-line-modified-removed">-         s_isDisablingPrimitiveGigacageDisabled = true;</span>
<span class="udiff-line-modified-added">+     ensureGigacage();</span>
<span class="udiff-line-modified-added">+     RELEASE_BASSERT(g_gigacageConfig.shouldBeEnabledHasBeenCalled</span>
<span class="udiff-line-modified-added">+         &amp;&amp; (GIGACAGE_ALLOCATION_CAN_FAIL || !g_gigacageConfig.shouldBeEnabled || verifyGigacageIsEnabled()));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (!g_gigacageConfig.disablingPrimitiveGigacageIsForbidden) {</span>
<span class="udiff-line-added">+         unfreezeGigacageConfig();</span>
<span class="udiff-line-added">+         g_gigacageConfig.disablingPrimitiveGigacageIsForbidden = true;</span>
      }
<span class="udiff-line-added">+     permanentlyFreezeGigacageConfig();</span>
<span class="udiff-line-added">+     RELEASE_BASSERT(isDisablingPrimitiveGigacageForbidden());</span>
  }
  
<span class="udiff-line-modified-removed">- bool isDisablingPrimitiveGigacageDisabled()</span>
<span class="udiff-line-modified-added">+ BNO_INLINE bool isDisablingPrimitiveGigacageForbidden()</span>
  {
<span class="udiff-line-modified-removed">-     return s_isDisablingPrimitiveGigacageDisabled;</span>
<span class="udiff-line-modified-added">+     return g_gigacageConfig.disablingPrimitiveGigacageIsForbidden;</span>
  }
  
  bool shouldBeEnabled()
  {
<span class="udiff-line-removed">-     static bool cached = false;</span>
      static std::once_flag onceFlag;
      std::call_once(
          onceFlag,
          [] {
<span class="udiff-line-added">+             RELEASE_BASSERT(!g_gigacageConfig.shouldBeEnabledHasBeenCalled);</span>
<span class="udiff-line-added">+             g_gigacageConfig.shouldBeEnabledHasBeenCalled = true;</span>
<span class="udiff-line-added">+ </span>
              bool debugHeapEnabled = Environment::get()-&gt;isDebugHeapEnabled();
              if (debugHeapEnabled)
                  return;
  
              if (!gigacageEnabledForProcess())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -290,15 +344,13 @@</span>
                      return;
                  } else if (strcasecmp(gigacageEnabled, &quot;yes&quot;) &amp;&amp; strcasecmp(gigacageEnabled, &quot;true&quot;) &amp;&amp; strcasecmp(gigacageEnabled, &quot;1&quot;))
                      fprintf(stderr, &quot;Warning: invalid argument to GIGACAGE_ENABLED: %s\n&quot;, gigacageEnabled);
              }
  
<span class="udiff-line-modified-removed">-             cached = true;</span>
<span class="udiff-line-modified-added">+             g_gigacageConfig.shouldBeEnabled = true;</span>
          });
<span class="udiff-line-modified-removed">-     return cached;</span>
<span class="udiff-line-modified-added">+     return g_gigacageConfig.shouldBeEnabled;</span>
  }
  
  } // namespace Gigacage
  
  #endif // GIGACAGE_ENABLED
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
</pre>
<center><a href="Environment.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Gigacage.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
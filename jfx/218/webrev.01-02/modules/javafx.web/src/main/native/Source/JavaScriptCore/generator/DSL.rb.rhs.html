<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/generator/DSL.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 # Copyright (C) 2018 Apple Inc. All rights reserved.
  2 #
  3 # Redistribution and use in source and binary forms, with or without
  4 # modification, are permitted provided that the following conditions
  5 # are met:
  6 # 1. Redistributions of source code must retain the above copyright
  7 #    notice, this list of conditions and the following disclaimer.
  8 # 2. Redistributions in binary form must reproduce the above copyright
  9 #    notice, this list of conditions and the following disclaimer in the
 10 #    documentation and/or other materials provided with the distribution.
 11 #
 12 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 13 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 14 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 15 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 16 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 17 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 18 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 19 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 20 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 21 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 22 # THE POSSIBILITY OF SUCH DAMAGE.
 23 
 24 require_relative &#39;Assertion&#39;
<a name="1" id="anc1"></a><span class="line-added"> 25 require_relative &#39;GeneratedFile&#39;</span>
 26 require_relative &#39;Section&#39;
 27 require_relative &#39;Template&#39;
 28 require_relative &#39;Type&#39;
<a name="2" id="anc2"></a><span class="line-modified"> 29 require_relative &#39;Wasm&#39;</span>
 30 
 31 module DSL
 32     @sections = []
<a name="3" id="anc3"></a><span class="line-added"> 33     @wasm_section = nil</span>
 34     @current_section = nil
 35     @context = binding()
 36     @namespaces = []
 37 
 38     def self.begin_section(name, config={})
 39         assert(&quot;must call `end_section` before beginning a new section&quot;) { @current_section.nil? }
 40         @current_section = Section.new name, config
 41     end
 42 
 43     def self.end_section(name)
 44         assert(&quot;current section&#39;s name is `#{@current_section.name}`, but end_section was called with `#{name}`&quot;) { @current_section.name == name }
 45         @current_section.sort!
 46         @sections &lt;&lt; @current_section
<a name="4" id="anc4"></a><span class="line-added"> 47         if @current_section.is_wasm?</span>
<span class="line-added"> 48           assert(&quot;Cannot have 2 wasm sections&quot;) { @wasm_section.nil? }</span>
<span class="line-added"> 49           @wasm_section = @current_section</span>
<span class="line-added"> 50         end</span>
 51         @current_section = nil
 52     end
 53 
 54     def self.op(name, config = {})
 55         assert(&quot;`op` can only be called in between `begin_section` and `end_section`&quot;) { not @current_section.nil? }
 56         @current_section.add_opcode(name, config)
 57     end
 58 
 59     def self.op_group(desc, ops, config)
 60         assert(&quot;`op_group` can only be called in between `begin_section` and `end_section`&quot;) { not @current_section.nil? }
 61         @current_section.add_opcode_group(desc, ops, config)
 62     end
 63 
 64     def self.types(types)
 65         types.map do |type|
 66             type = (@namespaces + [type]).join &quot;::&quot;
 67             @context.eval(&quot;#{type} = Type.new &#39;#{type}&#39;&quot;)
 68         end
 69     end
 70 
 71     def self.templates(types)
 72         types.map do |type|
 73             type = (@namespaces + [type]).join &quot;::&quot;
 74             @context.eval(&quot;#{type} = Template.new &#39;#{type}&#39;&quot;)
 75         end
 76     end
 77 
 78     def self.namespace(name)
 79         @namespaces &lt;&lt; name.to_s
 80         ctx = @context
 81         @context = @context.eval(&quot;
 82             module #{name}
 83               def self.get_binding
 84                 binding()
 85               end
 86             end
 87             #{name}.get_binding
 88          &quot;)
 89         yield
 90         @context = ctx
 91         @namespaces.pop
 92     end
 93 
<a name="5" id="anc5"></a><span class="line-added"> 94     def self.autogenerate_wasm_opcodes()</span>
<span class="line-added"> 95         assert(&quot;`autogenerate_wasm_opcodes` can only be called in between `begin_section` and `end_section`&quot;) { not @current_section.nil? }</span>
<span class="line-added"> 96         assert(&quot;`autogenerate_wasm_opcodes` can only be called from the `Wasm` section&quot;) { @current_section.name == :Wasm }</span>
<span class="line-added"> 97         Wasm::autogenerate_opcodes(@context, @wasm_json)</span>
<span class="line-added"> 98     end</span>
<span class="line-added"> 99 </span>
100     def self.run(options)
<a name="6" id="anc6"></a><span class="line-modified">101         bytecode_list_path = options[:bytecode_list]</span>
<span class="line-modified">102         bytecode_list = File.open(bytecode_list_path).read</span>
<span class="line-modified">103 </span>
<span class="line-added">104         @wasm_json = File.open(options[:wasm_json_filename]).read</span>
<span class="line-added">105 </span>
<span class="line-added">106         @context.eval(bytecode_list, bytecode_list_path)</span>
107         assert(&quot;must end last section&quot;) { @current_section.nil? }
108 
<a name="7" id="anc7"></a><span class="line-modified">109         write_bytecodes(bytecode_list, options[:bytecodes_filename])</span>
<span class="line-modified">110         write_bytecode_structs(bytecode_list, options[:bytecode_structs_filename])</span>
<span class="line-modified">111         write_bytecode_dumper(bytecode_list, options[:bytecode_dumper_filename])</span>
<span class="line-modified">112         write_bytecodes_init(options[:init_asm_filename], bytecode_list)</span>
<span class="line-added">113         write_indices(bytecode_list, options[:bytecode_indices_filename])</span>
<span class="line-added">114         write_llint_generator(options[:wasm_llint_generator_filename], bytecode_list, @wasm_json)</span>
<span class="line-added">115         write_wasm_init(options[:wasm_init_filename], bytecode_list, @wasm_json)</span>
116     end
117 
118     def self.write_bytecodes(bytecode_list, bytecodes_filename)
119         GeneratedFile::create(bytecodes_filename, bytecode_list) do |template|
120             template.prefix = &quot;#pragma once\n&quot;
121             num_opcodes = @sections.map(&amp;:opcodes).flatten.size
<a name="8" id="anc8"></a><span class="line-modified">122             template.body = [</span>
<span class="line-modified">123                 @sections.map { |s| s.header_helpers(num_opcodes) },</span>
<span class="line-modified">124                 @sections.select { |s| s.config[:emit_in_structs_file] }.map(&amp;:for_each_struct)</span>
<span class="line-modified">125             ].flatten.join(&quot;\n&quot;)</span>

126         end
127     end
128 
129     def self.write_bytecode_structs(bytecode_list, bytecode_structs_filename)
130         GeneratedFile::create(bytecode_structs_filename, bytecode_list) do |template|
<a name="9" id="anc9"></a>

131             template.prefix = &lt;&lt;-EOF
132 #pragma once
133 
134 #include &quot;ArithProfile.h&quot;
135 #include &quot;BytecodeDumper.h&quot;
<a name="10" id="anc10"></a>
136 #include &quot;Fits.h&quot;
137 #include &quot;GetByIdMetadata.h&quot;
<a name="11" id="anc11"></a><span class="line-added">138 #include &quot;GetByValHistory.h&quot;</span>
139 #include &quot;Instruction.h&quot;
140 #include &quot;Opcode.h&quot;
141 #include &quot;PutByIdStatus.h&quot;
142 #include &quot;PutByIdFlags.h&quot;
143 #include &quot;ToThisStatus.h&quot;
144 
145 namespace JSC {
<a name="12" id="anc12"></a><span class="line-added">146 </span>
<span class="line-added">147 void dumpBytecode(BytecodeDumperBase* dumper, InstructionStream::Offset, const Instruction*);</span>
<span class="line-added">148 </span>
<span class="line-added">149 #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added">150 void dumpWasm(BytecodeDumperBase* dumper, InstructionStream::Offset, const Instruction*);</span>
<span class="line-added">151 #endif // ENABLE(WEBASSEMBLY)</span>
<span class="line-added">152 </span>
153 EOF
154 
155             template.body = &lt;&lt;-EOF
<a name="13" id="anc13"></a><span class="line-modified">156 #{opcodes_filter { |s| s.config[:emit_in_structs_file] &amp;&amp; !s.is_wasm? }.map(&amp;:struct).join(&quot;\n&quot;)}</span>
<span class="line-modified">157 </span>
<span class="line-added">158 #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added">159 #{opcodes_filter { |s| s.config[:emit_in_structs_file] &amp;&amp; s.is_wasm? }.map(&amp;:struct).join(&quot;\n&quot;)}</span>
<span class="line-added">160 #endif // ENABLE(WEBASSEMBLY)</span>
161 EOF
162             template.suffix = &quot;} // namespace JSC&quot;
163         end
164     end
165 
<a name="14" id="anc14"></a><span class="line-modified">166     def self.write_bytecode_dumper(bytecode_list, bytecode_dumper_filename)</span>
<span class="line-modified">167         GeneratedFile::create(bytecode_dumper_filename, bytecode_list) do |template|</span>
<span class="line-added">168             template.prefix = &lt;&lt;-EOF</span>
<span class="line-added">169 #include &quot;config.h&quot;</span>
<span class="line-added">170 #include &quot;BytecodeDumper.h&quot;</span>
<span class="line-added">171 </span>
<span class="line-added">172 #include &quot;BytecodeStructs.h&quot;</span>
<span class="line-added">173 </span>
<span class="line-added">174 namespace JSC {</span>
<span class="line-added">175 EOF</span>
<span class="line-added">176 </span>
<span class="line-added">177             template.body = &lt;&lt;-EOF</span>
<span class="line-added">178 #{Opcode.dump_bytecode(:Bytecode, :JSOpcodeTraits, opcodes_filter { |s| s.config[:emit_in_structs_file] &amp;&amp; !s.is_wasm? })}</span>
179 
<a name="15" id="anc15"></a><span class="line-modified">180 #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added">181 #{Opcode.dump_bytecode(:Wasm, :WasmOpcodeTraits, opcodes_filter { |s| s.is_wasm? })}</span>
<span class="line-added">182 #endif // ENABLE(WEBASSEMBLY)</span>
<span class="line-added">183 EOF</span>
<span class="line-added">184             template.suffix = &quot;} // namespace JSC&quot;</span>
<span class="line-added">185         end</span>
<span class="line-added">186     end</span>
<span class="line-added">187 </span>
<span class="line-added">188     def self.write_init_asm(opcodes, filename, *dependencies)</span>
<span class="line-added">189         GeneratedFile::create(filename, *dependencies) do |template|</span>
190             template.multiline_comment = nil
191             template.line_comment = &quot;#&quot;
192             template.body = (opcodes.map.with_index(&amp;:set_entry_address) + opcodes.map.with_index(&amp;:set_entry_address_wide16) + opcodes.map.with_index(&amp;:set_entry_address_wide32)) .join(&quot;\n&quot;)
193         end
194     end
195 
<a name="16" id="anc16"></a><span class="line-added">196     def self.write_bytecodes_init(bytecodes_init_filename, *dependencies)</span>
<span class="line-added">197         write_init_asm(opcodes_for(:emit_in_asm_file), bytecodes_init_filename, *dependencies)</span>
<span class="line-added">198     end</span>
<span class="line-added">199 </span>
<span class="line-added">200     def self.write_wasm_init(wasm_init_filename, *dependencies)</span>
<span class="line-added">201         write_init_asm(@wasm_section.opcodes, wasm_init_filename, *dependencies)</span>
<span class="line-added">202     end</span>
<span class="line-added">203 </span>
<span class="line-added">204     def self.write_llint_generator(generator_filename, *dependencies)</span>
<span class="line-added">205         GeneratedFile::create(generator_filename, *dependencies) do |template|</span>
<span class="line-added">206             template.body = Wasm::generate_llint_generator(@wasm_section)</span>
<span class="line-added">207         end</span>
<span class="line-added">208     end</span>
<span class="line-added">209 </span>
210     def self.write_indices(bytecode_list, indices_filename)
211         opcodes = opcodes_for(:emit_in_structs_file)
212 
213         GeneratedFile::create(indices_filename, bytecode_list) do |template|
214             template.prefix = &quot;namespace JSC {\n&quot;
215             template.body = opcodes.map(&amp;:struct_indices).join(&quot;\n&quot;)
216             template.suffix = &quot;\n} // namespace JSC&quot;
217         end
218     end
219 
220     def self.opcodes_for(file)
221         sections = @sections.select { |s| s.config[file] }
222         sections.map(&amp;:opcodes).flatten
223     end
<a name="17" id="anc17"></a><span class="line-added">224 </span>
<span class="line-added">225     def self.opcodes_filter</span>
<span class="line-added">226         sections = @sections.select { |s| yield s }</span>
<span class="line-added">227         sections.map(&amp;:opcodes).flatten</span>
<span class="line-added">228     end</span>
229 end
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/MarkingConstraintSet.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MarkingConstraint.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MarkingConstraintSolver.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/MarkingConstraintSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 66 }
 67 
 68 void MarkingConstraintSet::add(CString abbreviatedName, CString name, ::Function&lt;void(SlotVisitor&amp;)&gt; function, ConstraintVolatility volatility, ConstraintConcurrency concurrency, ConstraintParallelism parallelism)
 69 {
 70     add(makeUnique&lt;SimpleMarkingConstraint&gt;(WTFMove(abbreviatedName), WTFMove(name), WTFMove(function), volatility, concurrency, parallelism));
 71 }
 72 
 73 void MarkingConstraintSet::add(
 74     std::unique_ptr&lt;MarkingConstraint&gt; constraint)
 75 {
 76     constraint-&gt;m_index = m_set.size();
 77     m_ordered.append(constraint.get());
 78     if (constraint-&gt;volatility() == ConstraintVolatility::GreyedByMarking)
 79         m_outgrowths.append(constraint.get());
 80     m_set.append(WTFMove(constraint));
 81 }
 82 
 83 bool MarkingConstraintSet::executeConvergence(SlotVisitor&amp; visitor)
 84 {
 85     bool result = executeConvergenceImpl(visitor);
<span class="line-modified"> 86     if (Options::logGC())</span>
<span class="line-removed"> 87         dataLog(&quot; &quot;);</span>
 88     return result;
 89 }
 90 
 91 bool MarkingConstraintSet::isWavefrontAdvancing(SlotVisitor&amp; visitor)
 92 {
 93     for (MarkingConstraint* outgrowth : m_outgrowths) {
 94         if (outgrowth-&gt;workEstimate(visitor))
 95             return true;
 96     }
 97     return false;
 98 }
 99 
100 bool MarkingConstraintSet::executeConvergenceImpl(SlotVisitor&amp; visitor)
101 {
102     SuperSamplerScope superSamplerScope(false);
103     MarkingConstraintSolver solver(*this);
104 
105     unsigned iteration = m_iteration++;
106 
<span class="line-modified">107     if (Options::logGC())</span>
<span class="line-removed">108         dataLog(&quot;i#&quot;, iteration, &quot;:&quot;);</span>
109 
110     if (iteration == 1) {
111         // First iteration is before any visitor draining, so it&#39;s unlikely to trigger any constraints
112         // other than roots.
113         solver.drain(m_unexecutedRoots);
114         return false;
115     }
116 
117     if (iteration == 2) {
118         solver.drain(m_unexecutedOutgrowths);
119         return false;
120     }
121 
122     // We want to keep preferring the outgrowth constraints - the ones that need to be fixpointed
123     // even in a stop-the-world GC - until they stop producing. They have a tendency to go totally
124     // silent at some point during GC, at which point it makes sense not to run them again until
125     // the end. Outgrowths producing new information corresponds almost exactly to the wavefront
126     // advancing: it usually means that we are marking objects that should be marked based on
127     // other objects that we would have marked anyway. Once the wavefront is no longer advancing,
128     // we want to run mostly the root constraints (based on their predictions of how much work
</pre>
<hr />
<pre>
157             double aWorkEstimate = a-&gt;workEstimate(visitor);
158             double bWorkEstimate = b-&gt;workEstimate(visitor);
159 
160             if (aWorkEstimate != bWorkEstimate)
161                 return aWorkEstimate &gt; bWorkEstimate;
162 
163             // This causes us to use SeldomGreyed vs GreyedByExecution as a final tie-breaker.
164             return a-&gt;volatility() &gt; b-&gt;volatility();
165         });
166 
167     solver.converge(m_ordered);
168 
169     // Return true if we&#39;ve converged. That happens if we did not visit anything.
170     return !solver.didVisitSomething();
171 }
172 
173 void MarkingConstraintSet::executeAll(SlotVisitor&amp; visitor)
174 {
175     for (auto&amp; constraint : m_set)
176         constraint-&gt;execute(visitor);
<span class="line-modified">177     if (Options::logGC())</span>
<span class="line-removed">178         dataLog(&quot; &quot;);</span>
179 }
180 
181 } // namespace JSC
182 
</pre>
</td>
<td>
<hr />
<pre>
 66 }
 67 
 68 void MarkingConstraintSet::add(CString abbreviatedName, CString name, ::Function&lt;void(SlotVisitor&amp;)&gt; function, ConstraintVolatility volatility, ConstraintConcurrency concurrency, ConstraintParallelism parallelism)
 69 {
 70     add(makeUnique&lt;SimpleMarkingConstraint&gt;(WTFMove(abbreviatedName), WTFMove(name), WTFMove(function), volatility, concurrency, parallelism));
 71 }
 72 
 73 void MarkingConstraintSet::add(
 74     std::unique_ptr&lt;MarkingConstraint&gt; constraint)
 75 {
 76     constraint-&gt;m_index = m_set.size();
 77     m_ordered.append(constraint.get());
 78     if (constraint-&gt;volatility() == ConstraintVolatility::GreyedByMarking)
 79         m_outgrowths.append(constraint.get());
 80     m_set.append(WTFMove(constraint));
 81 }
 82 
 83 bool MarkingConstraintSet::executeConvergence(SlotVisitor&amp; visitor)
 84 {
 85     bool result = executeConvergenceImpl(visitor);
<span class="line-modified"> 86     dataLogIf(Options::logGC(), &quot; &quot;);</span>

 87     return result;
 88 }
 89 
 90 bool MarkingConstraintSet::isWavefrontAdvancing(SlotVisitor&amp; visitor)
 91 {
 92     for (MarkingConstraint* outgrowth : m_outgrowths) {
 93         if (outgrowth-&gt;workEstimate(visitor))
 94             return true;
 95     }
 96     return false;
 97 }
 98 
 99 bool MarkingConstraintSet::executeConvergenceImpl(SlotVisitor&amp; visitor)
100 {
101     SuperSamplerScope superSamplerScope(false);
102     MarkingConstraintSolver solver(*this);
103 
104     unsigned iteration = m_iteration++;
105 
<span class="line-modified">106     dataLogIf(Options::logGC(), &quot;i#&quot;, iteration, &quot;:&quot;);</span>

107 
108     if (iteration == 1) {
109         // First iteration is before any visitor draining, so it&#39;s unlikely to trigger any constraints
110         // other than roots.
111         solver.drain(m_unexecutedRoots);
112         return false;
113     }
114 
115     if (iteration == 2) {
116         solver.drain(m_unexecutedOutgrowths);
117         return false;
118     }
119 
120     // We want to keep preferring the outgrowth constraints - the ones that need to be fixpointed
121     // even in a stop-the-world GC - until they stop producing. They have a tendency to go totally
122     // silent at some point during GC, at which point it makes sense not to run them again until
123     // the end. Outgrowths producing new information corresponds almost exactly to the wavefront
124     // advancing: it usually means that we are marking objects that should be marked based on
125     // other objects that we would have marked anyway. Once the wavefront is no longer advancing,
126     // we want to run mostly the root constraints (based on their predictions of how much work
</pre>
<hr />
<pre>
155             double aWorkEstimate = a-&gt;workEstimate(visitor);
156             double bWorkEstimate = b-&gt;workEstimate(visitor);
157 
158             if (aWorkEstimate != bWorkEstimate)
159                 return aWorkEstimate &gt; bWorkEstimate;
160 
161             // This causes us to use SeldomGreyed vs GreyedByExecution as a final tie-breaker.
162             return a-&gt;volatility() &gt; b-&gt;volatility();
163         });
164 
165     solver.converge(m_ordered);
166 
167     // Return true if we&#39;ve converged. That happens if we did not visit anything.
168     return !solver.didVisitSomething();
169 }
170 
171 void MarkingConstraintSet::executeAll(SlotVisitor&amp; visitor)
172 {
173     for (auto&amp; constraint : m_set)
174         constraint-&gt;execute(visitor);
<span class="line-modified">175     dataLogIf(Options::logGC(), &quot; &quot;);</span>

176 }
177 
178 } // namespace JSC
179 
</pre>
</td>
</tr>
</table>
<center><a href="MarkingConstraint.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MarkingConstraintSolver.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
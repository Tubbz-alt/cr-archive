<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/win/ThreadingWin.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RunLoopWin.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../WebCore/CMakeLists.txt.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/win/ThreadingWin.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
142 #endif
143     initializeCurrentThreadEvenIfNonWTFCreated();
144 }
145 
146 void Thread::initializePlatformThreading()
147 {
148 }
149 
150 static unsigned __stdcall wtfThreadEntryPoint(void* data)
151 {
152     Thread::entryPoint(reinterpret_cast&lt;Thread::NewThreadContext*&gt;(data));
153     return 0;
154 }
155 
156 bool Thread::establishHandle(NewThreadContext* data)
157 {
158     size_t stackSize = 0;
159 #if PLATFORM(JAVA) &amp;&amp; USE(JSVALUE32_64)
160     stackSize = 1024 * 1024;
161 #endif
<span class="line-removed">162 </span>
163     unsigned threadIdentifier = 0;
164     unsigned initFlag = stackSize ? STACK_SIZE_PARAM_IS_A_RESERVATION : 0;
165 
166     HANDLE threadHandle = reinterpret_cast&lt;HANDLE&gt;(_beginthreadex(0, stackSize, wtfThreadEntryPoint, data, initFlag, &amp;threadIdentifier));
167     if (!threadHandle) {
168         LOG_ERROR(&quot;Failed to create thread at entry point %p with data %p: %ld&quot;, wtfThreadEntryPoint, data, errno);
169         return false;
170     }
171     establishPlatformSpecificHandle(threadHandle, threadIdentifier);
172     return true;
173 }
174 
175 void Thread::changePriority(int delta)
176 {
177     auto locker = holdLock(m_mutex);
178     SetThreadPriority(m_handle, THREAD_PRIORITY_NORMAL + delta);
179 }
180 
181 int Thread::waitForCompletion()
182 {
</pre>
<hr />
<pre>
253 
254     thread-&gt;establishPlatformSpecificHandle(handle, currentID());
255     thread-&gt;initializeInThread();
256     initializeCurrentThreadEvenIfNonWTFCreated();
257 
258     return initializeTLS(WTFMove(thread));
259 }
260 
261 ThreadIdentifier Thread::currentID()
262 {
263     return static_cast&lt;ThreadIdentifier&gt;(GetCurrentThreadId());
264 }
265 
266 void Thread::establishPlatformSpecificHandle(HANDLE handle, ThreadIdentifier threadID)
267 {
268     auto locker = holdLock(m_mutex);
269     m_handle = handle;
270     m_id = threadID;
271 }
272 
<span class="line-modified">273 #define InvalidThread reinterpret_cast&lt;Thread*&gt;(static_cast&lt;uintptr_t&gt;(0xbbadbeef))</span>










274 
<span class="line-modified">275 static WordLock threadMapMutex;</span>
276 
<span class="line-modified">277 static HashMap&lt;ThreadIdentifier, Thread*&gt;&amp; threadMap()</span>
278 {
<span class="line-modified">279     static NeverDestroyed&lt;HashMap&lt;ThreadIdentifier, Thread*&gt;&gt; map;</span>
<span class="line-removed">280     return map.get();</span>
281 }
282 
<span class="line-modified">283 void Thread::initializeTLSKey()</span>
284 {
<span class="line-modified">285     threadMap();</span>
<span class="line-modified">286     threadSpecificKeyCreate(&amp;s_key, destructTLS);</span>
287 }
288 
<span class="line-modified">289 Thread* Thread::currentDying()</span>



290 {
<span class="line-modified">291     ASSERT(s_key != InvalidThreadSpecificKey);</span>
<span class="line-modified">292     // After FLS is destroyed, this map offers the value until the second thread exit callback is called.</span>
<span class="line-modified">293     auto locker = holdLock(threadMapMutex);</span>
<span class="line-modified">294     return threadMap().get(currentID());</span>




295 }
296 
<span class="line-modified">297 RefPtr&lt;Thread&gt; Thread::get(ThreadIdentifier id)</span>
298 {
<span class="line-modified">299     auto locker = holdLock(threadMapMutex);</span>
<span class="line-removed">300     Thread* thread = threadMap().get(id);</span>
<span class="line-removed">301     if (thread)</span>
<span class="line-removed">302         return thread;</span>
<span class="line-removed">303     return nullptr;</span>
304 }
305 
<span class="line-modified">306 Thread&amp; Thread::initializeTLS(Ref&lt;Thread&gt;&amp;&amp; thread)</span>
307 {
<span class="line-modified">308     ASSERT(s_key != InvalidThreadSpecificKey);</span>
<span class="line-removed">309     // FIXME: Remove this workaround code once &lt;rdar://problem/31793213&gt; is fixed.</span>
<span class="line-removed">310     auto id = thread-&gt;id();</span>
<span class="line-removed">311     // We leak the ref to keep the Thread alive while it is held in TLS. destructTLS will deref it later at thread destruction time.</span>
<span class="line-removed">312     auto&amp; threadInTLS = thread.leakRef();</span>
<span class="line-removed">313     threadSpecificSet(s_key, &amp;threadInTLS);</span>
<span class="line-removed">314     {</span>
<span class="line-removed">315         auto locker = holdLock(threadMapMutex);</span>
<span class="line-removed">316         threadMap().add(id, &amp;threadInTLS);</span>
<span class="line-removed">317     }</span>
<span class="line-removed">318     return threadInTLS;</span>
319 }
320 
<span class="line-modified">321 void Thread::destructTLS(void* data)</span>
322 {
<span class="line-modified">323     if (data == InvalidThread)</span>
<span class="line-modified">324         return;</span>
<span class="line-modified">325 </span>
<span class="line-modified">326     Thread* thread = static_cast&lt;Thread*&gt;(data);</span>
<span class="line-modified">327     ASSERT(thread);</span>
<span class="line-modified">328 </span>
<span class="line-removed">329     // Delay the deallocation of Thread more.</span>
<span class="line-removed">330     // It defers Thread deallocation after the other ThreadSpecific values are deallocated.</span>
<span class="line-removed">331     static thread_local class ThreadExitCallback {</span>
<span class="line-removed">332     public:</span>
<span class="line-removed">333         ThreadExitCallback(Thread* thread)</span>
<span class="line-removed">334             : m_thread(thread)</span>
<span class="line-removed">335         {</span>
<span class="line-removed">336         }</span>
<span class="line-removed">337 </span>
<span class="line-removed">338         ~ThreadExitCallback()</span>
<span class="line-removed">339         {</span>
<span class="line-removed">340             Thread::destructTLS(m_thread);</span>
<span class="line-removed">341         }</span>
<span class="line-removed">342 </span>
<span class="line-removed">343     private:</span>
<span class="line-removed">344         Thread* m_thread;</span>
<span class="line-removed">345     } callback(thread);</span>
<span class="line-removed">346 </span>
<span class="line-removed">347     if (thread-&gt;m_isDestroyedOnce) {</span>
<span class="line-removed">348         {</span>
<span class="line-removed">349             auto locker = holdLock(threadMapMutex);</span>
<span class="line-removed">350             ASSERT(threadMap().contains(thread-&gt;id()));</span>
<span class="line-removed">351             threadMap().remove(thread-&gt;id());</span>
352         }
<span class="line-removed">353         thread-&gt;didExit();</span>
<span class="line-removed">354         thread-&gt;deref();</span>
<span class="line-removed">355 </span>
<span class="line-removed">356         // Fill the FLS with the non-nullptr value. While FLS destructor won&#39;t be called for that,</span>
<span class="line-removed">357         // non-nullptr value tells us that we already destructed Thread. This allows us to</span>
<span class="line-removed">358         // detect incorrect use of Thread::current() after this point because it will crash.</span>
<span class="line-removed">359         threadSpecificSet(s_key, InvalidThread);</span>
<span class="line-removed">360         return;</span>
361     }
<span class="line-removed">362     threadSpecificSet(s_key, InvalidThread);</span>
<span class="line-removed">363     thread-&gt;m_isDestroyedOnce = true;</span>
364 }
365 
366 Mutex::~Mutex()
367 {
368 }
369 
370 void Mutex::lock()
371 {
372     AcquireSRWLockExclusive(&amp;m_mutex);
373 }
374 
375 bool Mutex::tryLock()
376 {
377     return TryAcquireSRWLockExclusive(&amp;m_mutex);
378 }
379 
380 void Mutex::unlock()
381 {
382     ReleaseSRWLockExclusive(&amp;m_mutex);
383 }
</pre>
</td>
<td>
<hr />
<pre>
142 #endif
143     initializeCurrentThreadEvenIfNonWTFCreated();
144 }
145 
146 void Thread::initializePlatformThreading()
147 {
148 }
149 
150 static unsigned __stdcall wtfThreadEntryPoint(void* data)
151 {
152     Thread::entryPoint(reinterpret_cast&lt;Thread::NewThreadContext*&gt;(data));
153     return 0;
154 }
155 
156 bool Thread::establishHandle(NewThreadContext* data)
157 {
158     size_t stackSize = 0;
159 #if PLATFORM(JAVA) &amp;&amp; USE(JSVALUE32_64)
160     stackSize = 1024 * 1024;
161 #endif

162     unsigned threadIdentifier = 0;
163     unsigned initFlag = stackSize ? STACK_SIZE_PARAM_IS_A_RESERVATION : 0;
164 
165     HANDLE threadHandle = reinterpret_cast&lt;HANDLE&gt;(_beginthreadex(0, stackSize, wtfThreadEntryPoint, data, initFlag, &amp;threadIdentifier));
166     if (!threadHandle) {
167         LOG_ERROR(&quot;Failed to create thread at entry point %p with data %p: %ld&quot;, wtfThreadEntryPoint, data, errno);
168         return false;
169     }
170     establishPlatformSpecificHandle(threadHandle, threadIdentifier);
171     return true;
172 }
173 
174 void Thread::changePriority(int delta)
175 {
176     auto locker = holdLock(m_mutex);
177     SetThreadPriority(m_handle, THREAD_PRIORITY_NORMAL + delta);
178 }
179 
180 int Thread::waitForCompletion()
181 {
</pre>
<hr />
<pre>
252 
253     thread-&gt;establishPlatformSpecificHandle(handle, currentID());
254     thread-&gt;initializeInThread();
255     initializeCurrentThreadEvenIfNonWTFCreated();
256 
257     return initializeTLS(WTFMove(thread));
258 }
259 
260 ThreadIdentifier Thread::currentID()
261 {
262     return static_cast&lt;ThreadIdentifier&gt;(GetCurrentThreadId());
263 }
264 
265 void Thread::establishPlatformSpecificHandle(HANDLE handle, ThreadIdentifier threadID)
266 {
267     auto locker = holdLock(m_mutex);
268     m_handle = handle;
269     m_id = threadID;
270 }
271 
<span class="line-modified">272 struct Thread::ThreadHolder {</span>
<span class="line-added">273     ~ThreadHolder()</span>
<span class="line-added">274     {</span>
<span class="line-added">275         if (thread) {</span>
<span class="line-added">276             thread-&gt;specificStorage().destroySlots();</span>
<span class="line-added">277             thread-&gt;didExit();</span>
<span class="line-added">278         }</span>
<span class="line-added">279     }</span>
<span class="line-added">280 </span>
<span class="line-added">281     RefPtr&lt;Thread&gt; thread;</span>
<span class="line-added">282 };</span>
283 
<span class="line-modified">284 thread_local static Thread::ThreadHolder s_threadHolder;</span>
285 
<span class="line-modified">286 Thread* Thread::currentMayBeNull()</span>
287 {
<span class="line-modified">288     return s_threadHolder.thread.get();</span>

289 }
290 
<span class="line-modified">291 Thread&amp; Thread::initializeTLS(Ref&lt;Thread&gt;&amp;&amp; thread)</span>
292 {
<span class="line-modified">293     s_threadHolder.thread = WTFMove(thread);</span>
<span class="line-modified">294     return *s_threadHolder.thread;</span>
295 }
296 
<span class="line-modified">297 Atomic&lt;int&gt; Thread::SpecificStorage::s_numberOfKeys;</span>
<span class="line-added">298 std::array&lt;Atomic&lt;Thread::SpecificStorage::DestroyFunction&gt;, Thread::SpecificStorage::s_maxKeys&gt; Thread::SpecificStorage::s_destroyFunctions;</span>
<span class="line-added">299 </span>
<span class="line-added">300 bool Thread::SpecificStorage::allocateKey(int&amp; key, DestroyFunction destroy)</span>
301 {
<span class="line-modified">302     int k = s_numberOfKeys.exchangeAdd(1);</span>
<span class="line-modified">303     if (k &gt;= s_maxKeys) {</span>
<span class="line-modified">304         s_numberOfKeys.exchangeSub(1);</span>
<span class="line-modified">305         return false;</span>
<span class="line-added">306     }</span>
<span class="line-added">307     key = k;</span>
<span class="line-added">308     s_destroyFunctions[key].store(destroy);</span>
<span class="line-added">309     return true;</span>
310 }
311 
<span class="line-modified">312 void* Thread::SpecificStorage::get(int key)</span>
313 {
<span class="line-modified">314     return m_slots[key];</span>




315 }
316 
<span class="line-modified">317 void Thread::SpecificStorage::set(int key, void* value)</span>
318 {
<span class="line-modified">319     m_slots[key] = value;</span>










320 }
321 
<span class="line-modified">322 void Thread::SpecificStorage::destroySlots()</span>
323 {
<span class="line-modified">324     auto numberOfKeys = s_numberOfKeys.load();</span>
<span class="line-modified">325     for (size_t i = 0; i &lt; numberOfKeys; i++) {</span>
<span class="line-modified">326         auto destroy = s_destroyFunctions[i].load();</span>
<span class="line-modified">327         if (destroy &amp;&amp; m_slots[i]) {</span>
<span class="line-modified">328             destroy(m_slots[i]);</span>
<span class="line-modified">329             m_slots[i] = nullptr;</span>























330         }








331     }


332 }
333 
334 Mutex::~Mutex()
335 {
336 }
337 
338 void Mutex::lock()
339 {
340     AcquireSRWLockExclusive(&amp;m_mutex);
341 }
342 
343 bool Mutex::tryLock()
344 {
345     return TryAcquireSRWLockExclusive(&amp;m_mutex);
346 }
347 
348 void Mutex::unlock()
349 {
350     ReleaseSRWLockExclusive(&amp;m_mutex);
351 }
</pre>
</td>
</tr>
</table>
<center><a href="RunLoopWin.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../WebCore/CMakeLists.txt.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
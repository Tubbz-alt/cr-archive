<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGVariableEventStream.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGVariableEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGVariableEventStream.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGVariableEventStream.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2012-2017 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGVariableEventStream.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;CodeBlock.h&quot;
 32 #include &quot;DFGJITCode.h&quot;
 33 #include &quot;DFGValueSource.h&quot;
 34 #include &quot;InlineCallFrame.h&quot;
 35 #include &quot;JSCInlines.h&quot;

 36 #include &lt;wtf/DataLog.h&gt;
 37 #include &lt;wtf/HashMap.h&gt;
 38 
 39 namespace JSC { namespace DFG {
 40 
 41 void VariableEventStream::logEvent(const VariableEvent&amp; event)
 42 {
 43     dataLogF(&quot;seq#%u:&quot;, static_cast&lt;unsigned&gt;(size()));
 44     event.dump(WTF::dataFile());
<span class="line-modified"> 45     dataLogF(&quot; &quot;);</span>
 46 }
 47 
 48 namespace {
 49 
 50 struct MinifiedGenerationInfo {
 51     bool filled; // true -&gt; in gpr/fpr/pair, false -&gt; spilled
 52     bool alive;
 53     VariableRepresentation u;
 54     DataFormat format;
 55 
 56     MinifiedGenerationInfo()
 57         : filled(false)
 58         , alive(false)
 59         , format(DataFormatNone)
 60     {
 61     }
 62 
 63     void update(const VariableEvent&amp; event)
 64     {
 65         switch (event.kind()) {
</pre>
<hr />
<pre>
102     }
103 
104     if (node-&gt;isPhantomDirectArguments()) {
105         recovery = ValueRecovery::directArgumentsThatWereNotCreated(node-&gt;id());
106         return true;
107     }
108 
109     if (node-&gt;isPhantomClonedArguments()) {
110         recovery = ValueRecovery::clonedArgumentsThatWereNotCreated(node-&gt;id());
111         return true;
112     }
113 
114     return false;
115 }
116 
117 template&lt;VariableEventStream::ReconstructionStyle style&gt;
118 unsigned VariableEventStream::reconstruct(
119     CodeBlock* codeBlock, CodeOrigin codeOrigin, MinifiedGraph&amp; graph,
120     unsigned index, Operands&lt;ValueRecovery&gt;&amp; valueRecoveries, Vector&lt;UndefinedOperandSpan&gt;* undefinedOperandSpans) const
121 {

122     ASSERT(codeBlock-&gt;jitType() == JITType::DFGJIT);
123     CodeBlock* baselineCodeBlock = codeBlock-&gt;baselineVersion();
124 
125     unsigned numVariables;
<span class="line-modified">126     static const unsigned invalidIndex = std::numeric_limits&lt;unsigned&gt;::max();</span>

127     unsigned firstUndefined = invalidIndex;
128     bool firstUndefinedIsArgument = false;
129 
130     auto flushUndefinedOperandSpan = [&amp;] (unsigned i) {
131         if (firstUndefined == invalidIndex)
132             return;
<span class="line-modified">133         int firstOffset = valueRecoveries.virtualRegisterForIndex(firstUndefined).offset();</span>
<span class="line-modified">134         int lastOffset = valueRecoveries.virtualRegisterForIndex(i - 1).offset();</span>
135         int minOffset = std::min(firstOffset, lastOffset);
136         undefinedOperandSpans-&gt;append({ firstUndefined, minOffset, i - firstUndefined });
137         firstUndefined = invalidIndex;
138     };
139     auto recordUndefinedOperand = [&amp;] (unsigned i) {
140         // We want to separate the span of arguments from the span of locals even if they have adjacent operands indexes.
<span class="line-modified">141         if (firstUndefined != invalidIndex &amp;&amp; firstUndefinedIsArgument != valueRecoveries.isArgument(i))</span>
142             flushUndefinedOperandSpan(i);
143 
144         if (firstUndefined == invalidIndex) {
145             firstUndefined = i;
<span class="line-modified">146             firstUndefinedIsArgument = valueRecoveries.isArgument(i);</span>
147         }
148     };
149 
150     auto* inlineCallFrame = codeOrigin.inlineCallFrame();
<span class="line-modified">151     if (inlineCallFrame)</span>
<span class="line-modified">152         numVariables = baselineCodeBlockForInlineCallFrame(inlineCallFrame)-&gt;numCalleeLocals() + VirtualRegister(inlineCallFrame-&gt;stackOffset).toLocal() + 1;</span>
<span class="line-modified">153     else</span>


154         numVariables = baselineCodeBlock-&gt;numCalleeLocals();


155 
156     // Crazy special case: if we&#39;re at index == 0 then this must be an argument check
157     // failure, in which case all variables are already set up. The recoveries should
158     // reflect this.
159     if (!index) {
<span class="line-modified">160         valueRecoveries = Operands&lt;ValueRecovery&gt;(codeBlock-&gt;numParameters(), numVariables);</span>

161         for (size_t i = 0; i &lt; valueRecoveries.size(); ++i) {
162             valueRecoveries[i] = ValueRecovery::displacedInJSStack(
<span class="line-modified">163                 VirtualRegister(valueRecoveries.operandForIndex(i)), DataFormatJS);</span>
164         }
165         return numVariables;
166     }
167 
168     // Step 1: Find the last checkpoint, and figure out the number of virtual registers as we go.
169     unsigned startIndex = index - 1;
170     while (at(startIndex).kind() != Reset)
171         startIndex--;
172 
173     // Step 2: Create a mock-up of the DFG&#39;s state and execute the events.
<span class="line-modified">174     Operands&lt;ValueSource&gt; operandSources(codeBlock-&gt;numParameters(), numVariables);</span>
175     for (unsigned i = operandSources.size(); i--;)
176         operandSources[i] = ValueSource(SourceIsDead);
177     HashMap&lt;MinifiedID, MinifiedGenerationInfo&gt; generationInfos;
178     for (unsigned i = startIndex; i &lt; index; ++i) {
179         const VariableEvent&amp; event = at(i);

180         switch (event.kind()) {
181         case Reset:
182             // nothing to do.
183             break;
184         case BirthToFill:
185         case BirthToSpill:
186         case Birth: {
187             MinifiedGenerationInfo info;
188             info.update(event);
189             generationInfos.add(event.id(), info);
190             break;
191         }
192         case Fill:
193         case Spill:
194         case Death: {
195             HashMap&lt;MinifiedID, MinifiedGenerationInfo&gt;::iterator iter = generationInfos.find(event.id());
196             ASSERT(iter != generationInfos.end());
197             iter-&gt;value.update(event);
198             break;
199         }
200         case MovHintEvent:
<span class="line-modified">201             if (operandSources.hasOperand(event.bytecodeRegister()))</span>
<span class="line-modified">202                 operandSources.setOperand(event.bytecodeRegister(), ValueSource(event.id()));</span>
203             break;
204         case SetLocalEvent:
<span class="line-modified">205             if (operandSources.hasOperand(event.bytecodeRegister()))</span>
<span class="line-modified">206                 operandSources.setOperand(event.bytecodeRegister(), ValueSource::forDataFormat(event.machineRegister(), event.dataFormat()));</span>
207             break;
208         default:
209             RELEASE_ASSERT_NOT_REACHED();
210             break;
211         }
212     }
213 


214     // Step 3: Compute value recoveries!
<span class="line-modified">215     valueRecoveries = Operands&lt;ValueRecovery&gt;(codeBlock-&gt;numParameters(), numVariables);</span>
216     for (unsigned i = 0; i &lt; operandSources.size(); ++i) {
217         ValueSource&amp; source = operandSources[i];
218         if (source.isTriviallyRecoverable()) {
219             valueRecoveries[i] = source.valueRecovery();
220             if (style == ReconstructionStyle::Separated) {
221                 if (valueRecoveries[i].isConstant() &amp;&amp; valueRecoveries[i].constant() == jsUndefined())
222                     recordUndefinedOperand(i);
223                 else
224                     flushUndefinedOperandSpan(i);
225             }
226             continue;
227         }
228 
229         ASSERT(source.kind() == HaveNode);
230         MinifiedNode* node = graph.at(source.id());
231         MinifiedGenerationInfo info = generationInfos.get(source.id());
232         if (!info.alive) {

233             valueRecoveries[i] = ValueRecovery::constant(jsUndefined());
234             if (style == ReconstructionStyle::Separated)
235                 recordUndefinedOperand(i);
236             continue;
237         }
238 
239         if (tryToSetConstantRecovery(valueRecoveries[i], node)) {

240             if (style == ReconstructionStyle::Separated) {
241                 if (node-&gt;hasConstant() &amp;&amp; node-&gt;constant() == jsUndefined())
242                     recordUndefinedOperand(i);
243                 else
244                     flushUndefinedOperandSpan(i);
245             }
246             continue;
247         }
248 
249         ASSERT(info.format != DataFormatNone);
250         if (style == ReconstructionStyle::Separated)
251             flushUndefinedOperandSpan(i);
252 
253         if (info.filled) {
254             if (info.format == DataFormatDouble) {
255                 valueRecoveries[i] = ValueRecovery::inFPR(info.u.fpr, DataFormatDouble);
256                 continue;
257             }
258 #if USE(JSVALUE32_64)
259             if (info.format &amp; DataFormatJS) {
260                 valueRecoveries[i] = ValueRecovery::inPair(info.u.pair.tagGPR, info.u.pair.payloadGPR);
261                 continue;
262             }
263 #endif
264             valueRecoveries[i] = ValueRecovery::inGPR(info.u.gpr, info.format);
265             continue;
266         }
267 
268         valueRecoveries[i] =
<span class="line-modified">269             ValueRecovery::displacedInJSStack(static_cast&lt;VirtualRegister&gt;(info.u.virtualReg), info.format);</span>
270     }
271     if (style == ReconstructionStyle::Separated)
272         flushUndefinedOperandSpan(operandSources.size());
273 
274     return numVariables;
275 }
276 
277 unsigned VariableEventStream::reconstruct(
278     CodeBlock* codeBlock, CodeOrigin codeOrigin, MinifiedGraph&amp; graph,
279     unsigned index, Operands&lt;ValueRecovery&gt;&amp; valueRecoveries) const
280 {
281     return reconstruct&lt;ReconstructionStyle::Combined&gt;(codeBlock, codeOrigin, graph, index, valueRecoveries, nullptr);
282 }
283 
284 unsigned VariableEventStream::reconstruct(
285     CodeBlock* codeBlock, CodeOrigin codeOrigin, MinifiedGraph&amp; graph,
286     unsigned index, Operands&lt;ValueRecovery&gt;&amp; valueRecoveries, Vector&lt;UndefinedOperandSpan&gt;* undefinedOperandSpans) const
287 {
288     return reconstruct&lt;ReconstructionStyle::Separated&gt;(codeBlock, codeOrigin, graph, index, valueRecoveries, undefinedOperandSpans);
289 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2012-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGVariableEventStream.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;CodeBlock.h&quot;
 32 #include &quot;DFGJITCode.h&quot;
 33 #include &quot;DFGValueSource.h&quot;
 34 #include &quot;InlineCallFrame.h&quot;
 35 #include &quot;JSCInlines.h&quot;
<span class="line-added"> 36 #include &quot;OperandsInlines.h&quot;</span>
 37 #include &lt;wtf/DataLog.h&gt;
 38 #include &lt;wtf/HashMap.h&gt;
 39 
 40 namespace JSC { namespace DFG {
 41 
 42 void VariableEventStream::logEvent(const VariableEvent&amp; event)
 43 {
 44     dataLogF(&quot;seq#%u:&quot;, static_cast&lt;unsigned&gt;(size()));
 45     event.dump(WTF::dataFile());
<span class="line-modified"> 46     dataLogLn(&quot; &quot;);</span>
 47 }
 48 
 49 namespace {
 50 
 51 struct MinifiedGenerationInfo {
 52     bool filled; // true -&gt; in gpr/fpr/pair, false -&gt; spilled
 53     bool alive;
 54     VariableRepresentation u;
 55     DataFormat format;
 56 
 57     MinifiedGenerationInfo()
 58         : filled(false)
 59         , alive(false)
 60         , format(DataFormatNone)
 61     {
 62     }
 63 
 64     void update(const VariableEvent&amp; event)
 65     {
 66         switch (event.kind()) {
</pre>
<hr />
<pre>
103     }
104 
105     if (node-&gt;isPhantomDirectArguments()) {
106         recovery = ValueRecovery::directArgumentsThatWereNotCreated(node-&gt;id());
107         return true;
108     }
109 
110     if (node-&gt;isPhantomClonedArguments()) {
111         recovery = ValueRecovery::clonedArgumentsThatWereNotCreated(node-&gt;id());
112         return true;
113     }
114 
115     return false;
116 }
117 
118 template&lt;VariableEventStream::ReconstructionStyle style&gt;
119 unsigned VariableEventStream::reconstruct(
120     CodeBlock* codeBlock, CodeOrigin codeOrigin, MinifiedGraph&amp; graph,
121     unsigned index, Operands&lt;ValueRecovery&gt;&amp; valueRecoveries, Vector&lt;UndefinedOperandSpan&gt;* undefinedOperandSpans) const
122 {
<span class="line-added">123     constexpr bool verbose = false;</span>
124     ASSERT(codeBlock-&gt;jitType() == JITType::DFGJIT);
125     CodeBlock* baselineCodeBlock = codeBlock-&gt;baselineVersion();
126 
127     unsigned numVariables;
<span class="line-modified">128     unsigned numTmps;</span>
<span class="line-added">129     static constexpr unsigned invalidIndex = std::numeric_limits&lt;unsigned&gt;::max();</span>
130     unsigned firstUndefined = invalidIndex;
131     bool firstUndefinedIsArgument = false;
132 
133     auto flushUndefinedOperandSpan = [&amp;] (unsigned i) {
134         if (firstUndefined == invalidIndex)
135             return;
<span class="line-modified">136         int firstOffset = valueRecoveries.operandForIndex(firstUndefined).virtualRegister().offset();</span>
<span class="line-modified">137         int lastOffset = valueRecoveries.operandForIndex(i - 1).virtualRegister().offset();</span>
138         int minOffset = std::min(firstOffset, lastOffset);
139         undefinedOperandSpans-&gt;append({ firstUndefined, minOffset, i - firstUndefined });
140         firstUndefined = invalidIndex;
141     };
142     auto recordUndefinedOperand = [&amp;] (unsigned i) {
143         // We want to separate the span of arguments from the span of locals even if they have adjacent operands indexes.
<span class="line-modified">144         if (firstUndefined != invalidIndex &amp;&amp; firstUndefinedIsArgument != valueRecoveries.operandForIndex(i).isArgument())</span>
145             flushUndefinedOperandSpan(i);
146 
147         if (firstUndefined == invalidIndex) {
148             firstUndefined = i;
<span class="line-modified">149             firstUndefinedIsArgument = valueRecoveries.operandForIndex(i).isArgument();</span>
150         }
151     };
152 
153     auto* inlineCallFrame = codeOrigin.inlineCallFrame();
<span class="line-modified">154     if (inlineCallFrame) {</span>
<span class="line-modified">155         CodeBlock* codeBlock = baselineCodeBlockForInlineCallFrame(inlineCallFrame);</span>
<span class="line-modified">156         numVariables = codeBlock-&gt;numCalleeLocals() + VirtualRegister(inlineCallFrame-&gt;stackOffset).toLocal() + 1;</span>
<span class="line-added">157         numTmps = codeBlock-&gt;numTmps() + inlineCallFrame-&gt;tmpOffset;</span>
<span class="line-added">158     } else {</span>
159         numVariables = baselineCodeBlock-&gt;numCalleeLocals();
<span class="line-added">160         numTmps = baselineCodeBlock-&gt;numTmps();</span>
<span class="line-added">161     }</span>
162 
163     // Crazy special case: if we&#39;re at index == 0 then this must be an argument check
164     // failure, in which case all variables are already set up. The recoveries should
165     // reflect this.
166     if (!index) {
<span class="line-modified">167         // We don&#39;t include tmps here because they can&#39;t be used yet.</span>
<span class="line-added">168         valueRecoveries = Operands&lt;ValueRecovery&gt;(codeBlock-&gt;numParameters(), numVariables, 0);</span>
169         for (size_t i = 0; i &lt; valueRecoveries.size(); ++i) {
170             valueRecoveries[i] = ValueRecovery::displacedInJSStack(
<span class="line-modified">171                 valueRecoveries.operandForIndex(i).virtualRegister(), DataFormatJS);</span>
172         }
173         return numVariables;
174     }
175 
176     // Step 1: Find the last checkpoint, and figure out the number of virtual registers as we go.
177     unsigned startIndex = index - 1;
178     while (at(startIndex).kind() != Reset)
179         startIndex--;
180 
181     // Step 2: Create a mock-up of the DFG&#39;s state and execute the events.
<span class="line-modified">182     Operands&lt;ValueSource&gt; operandSources(codeBlock-&gt;numParameters(), numVariables, numTmps);</span>
183     for (unsigned i = operandSources.size(); i--;)
184         operandSources[i] = ValueSource(SourceIsDead);
185     HashMap&lt;MinifiedID, MinifiedGenerationInfo&gt; generationInfos;
186     for (unsigned i = startIndex; i &lt; index; ++i) {
187         const VariableEvent&amp; event = at(i);
<span class="line-added">188         dataLogLnIf(verbose, &quot;Processing event &quot;, event);</span>
189         switch (event.kind()) {
190         case Reset:
191             // nothing to do.
192             break;
193         case BirthToFill:
194         case BirthToSpill:
195         case Birth: {
196             MinifiedGenerationInfo info;
197             info.update(event);
198             generationInfos.add(event.id(), info);
199             break;
200         }
201         case Fill:
202         case Spill:
203         case Death: {
204             HashMap&lt;MinifiedID, MinifiedGenerationInfo&gt;::iterator iter = generationInfos.find(event.id());
205             ASSERT(iter != generationInfos.end());
206             iter-&gt;value.update(event);
207             break;
208         }
209         case MovHintEvent:
<span class="line-modified">210             if (operandSources.hasOperand(event.operand()))</span>
<span class="line-modified">211                 operandSources.setOperand(event.operand(), ValueSource(event.id()));</span>
212             break;
213         case SetLocalEvent:
<span class="line-modified">214             if (operandSources.hasOperand(event.operand()))</span>
<span class="line-modified">215                 operandSources.setOperand(event.operand(), ValueSource::forDataFormat(event.machineRegister(), event.dataFormat()));</span>
216             break;
217         default:
218             RELEASE_ASSERT_NOT_REACHED();
219             break;
220         }
221     }
222 
<span class="line-added">223     dataLogLnIf(verbose, &quot;Operand sources: &quot;, operandSources);</span>
<span class="line-added">224 </span>
225     // Step 3: Compute value recoveries!
<span class="line-modified">226     valueRecoveries = Operands&lt;ValueRecovery&gt;(OperandsLike, operandSources);</span>
227     for (unsigned i = 0; i &lt; operandSources.size(); ++i) {
228         ValueSource&amp; source = operandSources[i];
229         if (source.isTriviallyRecoverable()) {
230             valueRecoveries[i] = source.valueRecovery();
231             if (style == ReconstructionStyle::Separated) {
232                 if (valueRecoveries[i].isConstant() &amp;&amp; valueRecoveries[i].constant() == jsUndefined())
233                     recordUndefinedOperand(i);
234                 else
235                     flushUndefinedOperandSpan(i);
236             }
237             continue;
238         }
239 
240         ASSERT(source.kind() == HaveNode);
241         MinifiedNode* node = graph.at(source.id());
242         MinifiedGenerationInfo info = generationInfos.get(source.id());
243         if (!info.alive) {
<span class="line-added">244             dataLogLnIf(verbose, &quot;Operand &quot;, valueRecoveries.operandForIndex(i), &quot; is dead.&quot;);</span>
245             valueRecoveries[i] = ValueRecovery::constant(jsUndefined());
246             if (style == ReconstructionStyle::Separated)
247                 recordUndefinedOperand(i);
248             continue;
249         }
250 
251         if (tryToSetConstantRecovery(valueRecoveries[i], node)) {
<span class="line-added">252             dataLogLnIf(verbose, &quot;Operand &quot;, valueRecoveries.operandForIndex(i), &quot; is constant.&quot;);</span>
253             if (style == ReconstructionStyle::Separated) {
254                 if (node-&gt;hasConstant() &amp;&amp; node-&gt;constant() == jsUndefined())
255                     recordUndefinedOperand(i);
256                 else
257                     flushUndefinedOperandSpan(i);
258             }
259             continue;
260         }
261 
262         ASSERT(info.format != DataFormatNone);
263         if (style == ReconstructionStyle::Separated)
264             flushUndefinedOperandSpan(i);
265 
266         if (info.filled) {
267             if (info.format == DataFormatDouble) {
268                 valueRecoveries[i] = ValueRecovery::inFPR(info.u.fpr, DataFormatDouble);
269                 continue;
270             }
271 #if USE(JSVALUE32_64)
272             if (info.format &amp; DataFormatJS) {
273                 valueRecoveries[i] = ValueRecovery::inPair(info.u.pair.tagGPR, info.u.pair.payloadGPR);
274                 continue;
275             }
276 #endif
277             valueRecoveries[i] = ValueRecovery::inGPR(info.u.gpr, info.format);
278             continue;
279         }
280 
281         valueRecoveries[i] =
<span class="line-modified">282             ValueRecovery::displacedInJSStack(info.u.operand.virtualRegister(), info.format);</span>
283     }
284     if (style == ReconstructionStyle::Separated)
285         flushUndefinedOperandSpan(operandSources.size());
286 
287     return numVariables;
288 }
289 
290 unsigned VariableEventStream::reconstruct(
291     CodeBlock* codeBlock, CodeOrigin codeOrigin, MinifiedGraph&amp; graph,
292     unsigned index, Operands&lt;ValueRecovery&gt;&amp; valueRecoveries) const
293 {
294     return reconstruct&lt;ReconstructionStyle::Combined&gt;(codeBlock, codeOrigin, graph, index, valueRecoveries, nullptr);
295 }
296 
297 unsigned VariableEventStream::reconstruct(
298     CodeBlock* codeBlock, CodeOrigin codeOrigin, MinifiedGraph&amp; graph,
299     unsigned index, Operands&lt;ValueRecovery&gt;&amp; valueRecoveries, Vector&lt;UndefinedOperandSpan&gt;* undefinedOperandSpans) const
300 {
301     return reconstruct&lt;ReconstructionStyle::Separated&gt;(codeBlock, codeOrigin, graph, index, valueRecoveries, undefinedOperandSpans);
302 }
</pre>
</td>
</tr>
</table>
<center><a href="DFGVariableEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGVariableEventStream.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
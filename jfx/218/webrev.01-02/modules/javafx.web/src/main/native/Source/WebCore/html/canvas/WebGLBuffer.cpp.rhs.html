<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2009-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebGLBuffer.h&quot;
 28 
 29 #if ENABLE(WEBGL)
 30 
 31 #include &quot;WebGLContextGroup.h&quot;
 32 #include &quot;WebGLRenderingContextBase.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 33 #include &lt;JavaScriptCore/ArrayBuffer.h&gt;</span>
 34 
 35 namespace WebCore {
 36 
 37 Ref&lt;WebGLBuffer&gt; WebGLBuffer::create(WebGLRenderingContextBase&amp; ctx)
 38 {
 39     return adoptRef(*new WebGLBuffer(ctx));
 40 }
 41 
 42 WebGLBuffer::WebGLBuffer(WebGLRenderingContextBase&amp; ctx)
 43     : WebGLSharedObject(ctx)
 44 {
<a name="2" id="anc2"></a><span class="line-modified"> 45     setObject(ctx.graphicsContextGL()-&gt;createBuffer());</span>
 46     clearCachedMaxIndices();
 47 }
 48 
 49 WebGLBuffer::~WebGLBuffer()
 50 {
 51     deleteObject(0);
 52 }
 53 
<a name="3" id="anc3"></a><span class="line-modified"> 54 void WebGLBuffer::deleteObjectImpl(GraphicsContextGLOpenGL* context3d, PlatformGLObject object)</span>
 55 {
 56     context3d-&gt;deleteBuffer(object);
 57 }
 58 
<a name="4" id="anc4"></a><span class="line-modified"> 59 bool WebGLBuffer::associateBufferDataImpl(const void* data, GCGLsizeiptr byteLength)</span>
 60 {
 61     if (byteLength &lt; 0)
 62         return false;
 63 
 64     switch (m_target) {
<a name="5" id="anc5"></a><span class="line-modified"> 65     case GraphicsContextGL::ELEMENT_ARRAY_BUFFER:</span>
 66         if (byteLength &gt; std::numeric_limits&lt;unsigned&gt;::max())
 67             return false;
 68         m_byteLength = byteLength;
 69         clearCachedMaxIndices();
 70         if (byteLength) {
 71             m_elementArrayBuffer = ArrayBuffer::tryCreate(byteLength, 1);
 72             if (!m_elementArrayBuffer) {
 73                 m_byteLength = 0;
 74                 return false;
 75             }
 76             if (data) {
 77                 // We must always clone the incoming data because client-side
 78                 // modifications without calling bufferData or bufferSubData
 79                 // must never be able to change the validation results.
 80                 memcpy(m_elementArrayBuffer-&gt;data(), data, byteLength);
 81             }
 82         } else
 83             m_elementArrayBuffer = nullptr;
 84         return true;
<a name="6" id="anc6"></a><span class="line-modified"> 85     case GraphicsContextGL::ARRAY_BUFFER:</span>
 86         m_byteLength = byteLength;
 87         return true;
 88     default:
 89 #if ENABLE(WEBGL2)
 90         switch (m_target) {
<a name="7" id="anc7"></a><span class="line-modified"> 91         case GraphicsContextGL::COPY_READ_BUFFER:</span>
<span class="line-modified"> 92         case GraphicsContextGL::COPY_WRITE_BUFFER:</span>
<span class="line-modified"> 93         case GraphicsContextGL::PIXEL_PACK_BUFFER:</span>
<span class="line-modified"> 94         case GraphicsContextGL::PIXEL_UNPACK_BUFFER:</span>
<span class="line-modified"> 95         case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:</span>
<span class="line-modified"> 96         case GraphicsContextGL::UNIFORM_BUFFER:</span>
 97             m_byteLength = byteLength;
 98             return true;
 99         }
100 #endif
101         return false;
102     }
103 }
104 
<a name="8" id="anc8"></a><span class="line-modified">105 bool WebGLBuffer::associateBufferData(GCGLsizeiptr size)</span>
106 {
107     return associateBufferDataImpl(nullptr, size);
108 }
109 
110 bool WebGLBuffer::associateBufferData(ArrayBuffer* array)
111 {
112     if (!array)
113         return false;
114     return associateBufferDataImpl(array-&gt;data(), array-&gt;byteLength());
115 }
116 
117 bool WebGLBuffer::associateBufferData(ArrayBufferView* array)
118 {
119     if (!array)
120         return false;
121     return associateBufferDataImpl(array-&gt;baseAddress(), array-&gt;byteLength());
122 }
123 
<a name="9" id="anc9"></a><span class="line-modified">124 bool WebGLBuffer::associateBufferSubDataImpl(GCGLintptr offset, const void* data, GCGLsizeiptr byteLength)</span>
125 {
126     if (!data || offset &lt; 0 || byteLength &lt; 0)
127         return false;
128 
129     if (byteLength) {
<a name="10" id="anc10"></a><span class="line-modified">130         Checked&lt;GCGLintptr, RecordOverflow&gt; checkedBufferOffset(offset);</span>
<span class="line-modified">131         Checked&lt;GCGLsizeiptr, RecordOverflow&gt; checkedDataLength(byteLength);</span>
<span class="line-modified">132         Checked&lt;GCGLintptr, RecordOverflow&gt; checkedBufferMax = checkedBufferOffset + checkedDataLength;</span>
133         if (checkedBufferMax.hasOverflowed() || offset &gt; m_byteLength || checkedBufferMax.unsafeGet() &gt; m_byteLength)
134             return false;
135     }
136 
137     switch (m_target) {
<a name="11" id="anc11"></a><span class="line-modified">138     case GraphicsContextGL::ELEMENT_ARRAY_BUFFER:</span>
139         clearCachedMaxIndices();
140         if (byteLength) {
141             if (!m_elementArrayBuffer)
142                 return false;
143             memcpy(static_cast&lt;unsigned char*&gt;(m_elementArrayBuffer-&gt;data()) + offset, data, byteLength);
144         }
145         return true;
<a name="12" id="anc12"></a><span class="line-modified">146     case GraphicsContextGL::ARRAY_BUFFER:</span>
147         return true;
148     default:
149 #if ENABLE(WEBGL2)
150         switch (m_target) {
<a name="13" id="anc13"></a><span class="line-modified">151         case GraphicsContextGL::COPY_READ_BUFFER:</span>
<span class="line-modified">152         case GraphicsContextGL::COPY_WRITE_BUFFER:</span>
<span class="line-modified">153         case GraphicsContextGL::PIXEL_PACK_BUFFER:</span>
<span class="line-modified">154         case GraphicsContextGL::PIXEL_UNPACK_BUFFER:</span>
<span class="line-modified">155         case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:</span>
<span class="line-modified">156         case GraphicsContextGL::UNIFORM_BUFFER:</span>
157             return true;
158         }
159 #endif
160         return false;
161     }
162 }
163 
<a name="14" id="anc14"></a><span class="line-modified">164 bool WebGLBuffer::associateBufferSubData(GCGLintptr offset, ArrayBuffer* array)</span>
165 {
166     if (!array)
167         return false;
168     return associateBufferSubDataImpl(offset, array-&gt;data(), array-&gt;byteLength());
169 }
170 
<a name="15" id="anc15"></a><span class="line-modified">171 bool WebGLBuffer::associateBufferSubData(GCGLintptr offset, ArrayBufferView* array)</span>
172 {
173     if (!array)
174         return false;
175     return associateBufferSubDataImpl(offset, array-&gt;baseAddress(), array-&gt;byteLength());
176 }
177 
<a name="16" id="anc16"></a><span class="line-modified">178 bool WebGLBuffer::associateCopyBufferSubData(const WebGLBuffer&amp; readBuffer, GCGLintptr readOffset, GCGLintptr writeOffset, GCGLsizeiptr size)</span>
179 {
180     if (readOffset &lt; 0 || writeOffset &lt; 0 || size &lt; 0)
181         return false;
182 
183     if (size) {
<a name="17" id="anc17"></a><span class="line-modified">184         Checked&lt;GCGLintptr, RecordOverflow&gt; checkedReadBufferOffset(readOffset);</span>
<span class="line-modified">185         Checked&lt;GCGLsizeiptr, RecordOverflow&gt; checkedDataLength(size);</span>
<span class="line-modified">186         Checked&lt;GCGLintptr, RecordOverflow&gt; checkedReadBufferMax = checkedReadBufferOffset + checkedDataLength;</span>
187         if (checkedReadBufferMax.hasOverflowed() || readOffset &gt; readBuffer.byteLength() || checkedReadBufferMax.unsafeGet() &gt; readBuffer.byteLength())
188             return false;
189 
<a name="18" id="anc18"></a><span class="line-modified">190         Checked&lt;GCGLintptr, RecordOverflow&gt; checkedWriteBufferOffset(writeOffset);</span>
<span class="line-modified">191         Checked&lt;GCGLintptr, RecordOverflow&gt; checkedWriteBufferMax = checkedWriteBufferOffset + checkedDataLength;</span>
192         if (checkedWriteBufferMax.hasOverflowed() || writeOffset &gt; m_byteLength || checkedWriteBufferMax.unsafeGet() &gt; m_byteLength)
193             return false;
194     }
195 
196     switch (m_target) {
<a name="19" id="anc19"></a><span class="line-modified">197     case GraphicsContextGL::ELEMENT_ARRAY_BUFFER:</span>
198         clearCachedMaxIndices();
199         if (size) {
200             if (!m_elementArrayBuffer)
201                 return false;
202             memcpy(static_cast&lt;unsigned char*&gt;(m_elementArrayBuffer-&gt;data()) + writeOffset, static_cast&lt;const unsigned char*&gt;(readBuffer.elementArrayBuffer()-&gt;data()) + readOffset, size);
203         }
204         return true;
<a name="20" id="anc20"></a><span class="line-modified">205     case GraphicsContextGL::ARRAY_BUFFER:</span>
206         return true;
207     default:
208 #if ENABLE(WEBGL2)
209         switch (m_target) {
<a name="21" id="anc21"></a><span class="line-modified">210         case GraphicsContextGL::COPY_READ_BUFFER:</span>
<span class="line-modified">211         case GraphicsContextGL::COPY_WRITE_BUFFER:</span>
<span class="line-modified">212         case GraphicsContextGL::PIXEL_PACK_BUFFER:</span>
<span class="line-modified">213         case GraphicsContextGL::PIXEL_UNPACK_BUFFER:</span>
<span class="line-modified">214         case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:</span>
<span class="line-modified">215         case GraphicsContextGL::UNIFORM_BUFFER:</span>
216             return true;
217         }
218 #endif
219         return false;
220     }
221 }
222 
223 void WebGLBuffer::disassociateBufferData()
224 {
225     m_byteLength = 0;
226     clearCachedMaxIndices();
227 }
228 
<a name="22" id="anc22"></a><span class="line-modified">229 GCGLsizeiptr WebGLBuffer::byteLength() const</span>
230 {
231     return m_byteLength;
232 }
233 
<a name="23" id="anc23"></a><span class="line-modified">234 Optional&lt;unsigned&gt; WebGLBuffer::getCachedMaxIndex(GCGLenum type)</span>
235 {
236     for (auto&amp; cache : m_maxIndexCache) {
237         if (cache.type == type)
238             return cache.maxIndex;
239     }
240     return WTF::nullopt;
241 }
242 
<a name="24" id="anc24"></a><span class="line-modified">243 void WebGLBuffer::setCachedMaxIndex(GCGLenum type, unsigned value)</span>
244 {
245     for (auto&amp; cache : m_maxIndexCache) {
246         if (cache.type == type) {
247             cache.maxIndex = value;
248             return;
249         }
250     }
251     m_maxIndexCache[m_nextAvailableCacheEntry].type = type;
252     m_maxIndexCache[m_nextAvailableCacheEntry].maxIndex = value;
253     m_nextAvailableCacheEntry = (m_nextAvailableCacheEntry + 1) % WTF_ARRAY_LENGTH(m_maxIndexCache);
254 }
255 
<a name="25" id="anc25"></a><span class="line-modified">256 void WebGLBuffer::setTarget(GCGLenum target)</span>
257 {
<a name="26" id="anc26"></a><span class="line-modified">258     m_target = target;</span>
<span class="line-modified">259 </span>
<span class="line-modified">260     if (target == GraphicsContextGL::ARRAY_BUFFER || target == GraphicsContextGL::ELEMENT_ARRAY_BUFFER) {</span>
<span class="line-modified">261         ASSERT(!m_arrayBufferOrElementArrayBuffer || target == m_arrayBufferOrElementArrayBuffer);</span>
<span class="line-modified">262         m_arrayBufferOrElementArrayBuffer = target;</span>












263     }
264 }
265 
266 void WebGLBuffer::clearCachedMaxIndices()
267 {
268     memset(m_maxIndexCache, 0, sizeof(m_maxIndexCache));
269 }
270 
271 }
272 
273 #endif // ENABLE(WEBGL)
<a name="27" id="anc27"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="27" type="hidden" />
</body>
</html>
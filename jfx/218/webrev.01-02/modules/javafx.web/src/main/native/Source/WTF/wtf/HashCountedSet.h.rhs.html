<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/HashCountedSet.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2005, 2006, 2008, 2013, 2016 Apple Inc. All rights reserved.
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Library General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public License
 15  * along with this library; see the file COPYING.LIB.  If not, write to
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  *
 19  */
 20 
 21 #pragma once
 22 
 23 #include &lt;initializer_list&gt;
 24 #include &lt;wtf/Assertions.h&gt;
 25 #include &lt;wtf/Forward.h&gt;
 26 #include &lt;wtf/HashMap.h&gt;
 27 #include &lt;wtf/Vector.h&gt;
 28 
 29 namespace WTF {
 30 
 31 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
 32 class HashCountedSet final {
 33     WTF_MAKE_FAST_ALLOCATED;
 34 private:
 35     using ImplType = HashMap&lt;Value, unsigned, HashFunctions, Traits&gt;;
 36 public:
 37     using ValueType = Value;
 38     using iterator = typename ImplType::iterator;
 39     using const_iterator = typename ImplType::const_iterator;
 40     using ValuesIteratorRange = typename ImplType::KeysIteratorRange;
 41     using ValuesConstIteratorRange = typename ImplType::KeysConstIteratorRange;
 42     using AddResult = typename ImplType::AddResult;
 43 
 44     HashCountedSet()
 45     {
 46     }
 47 
 48     HashCountedSet(std::initializer_list&lt;typename ImplType::KeyValuePairType&gt; initializerList)
 49     {
 50         for (const auto&amp; keyValuePair : initializerList)
 51             add(keyValuePair.key, keyValuePair.value);
 52     }
 53 
 54     HashCountedSet(std::initializer_list&lt;typename ImplType::KeyType&gt; initializerList)
 55     {
 56         for (const auto&amp; value : initializerList)
 57             add(value);
 58     }
 59 
 60     void swap(HashCountedSet&amp;);
 61 
 62     unsigned size() const;
 63     unsigned capacity() const;
 64     bool isEmpty() const;
 65 
 66     // Iterators iterate over pairs of values and counts.
 67     iterator begin();
 68     iterator end();
 69     const_iterator begin() const;
 70     const_iterator end() const;
 71 
 72     iterator random() { return m_impl.random(); }
 73     const_iterator random() const { return m_impl.random(); }
 74 
 75     ValuesIteratorRange values();
 76     const ValuesConstIteratorRange values() const;
 77 
 78     iterator find(const ValueType&amp;);
 79     const_iterator find(const ValueType&amp;) const;
 80     bool contains(const ValueType&amp;) const;
 81     unsigned count(const ValueType&amp;) const;
 82 
 83     // Increments the count if an equal value is already present.
 84     // The return value includes both an iterator to the value&#39;s location,
 85     // and an isNewEntry bool that indicates whether it is a new or existing entry.
 86     AddResult add(const ValueType&amp;);
 87     AddResult add(ValueType&amp;&amp;);
 88 
 89     // Increments the count of a value by the passed amount.
 90     AddResult add(const ValueType&amp;, unsigned);
 91     AddResult add(ValueType&amp;&amp;, unsigned);
 92 
 93     // Decrements the count of the value, and removes it if count goes down to zero.
 94     // Returns true if the value is removed.
 95     bool remove(const ValueType&amp;);
 96     bool remove(iterator);
 97 
 98     // Removes the value, regardless of its count.
 99     // Returns true if a value was removed.
100     bool removeAll(iterator);
101     bool removeAll(const ValueType&amp;);
102 
103     // Clears the whole set.
104     void clear();
105 
106     // Overloads for smart pointer keys that take the raw pointer type as the parameter.
107     template&lt;typename V = ValueType&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, iterator&gt;::type find(typename GetPtrHelper&lt;V&gt;::PtrType);
108     template&lt;typename V = ValueType&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, const_iterator&gt;::type find(typename GetPtrHelper&lt;V&gt;::PtrType) const;
109     template&lt;typename V = ValueType&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, bool&gt;::type contains(typename GetPtrHelper&lt;V&gt;::PtrType) const;
110     template&lt;typename V = ValueType&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, unsigned&gt;::type count(typename GetPtrHelper&lt;V&gt;::PtrType) const;
111     template&lt;typename V = ValueType&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, bool&gt;::type remove(typename GetPtrHelper&lt;V&gt;::PtrType);
112 
<a name="1" id="anc1"></a><span class="line-added">113     static bool isValidValue(const ValueType&amp; value) { return ImplType::isValidValue(value); }</span>
<span class="line-added">114 </span>
115 private:
116     ImplType m_impl;
117 };
118 
119 
120 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
121 inline void HashCountedSet&lt;Value, HashFunctions, Traits&gt;::swap(HashCountedSet&amp; other)
122 {
123     m_impl.swap(other.m_impl);
124 }
125 
126 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
127 inline unsigned HashCountedSet&lt;Value, HashFunctions, Traits&gt;::size() const
128 {
129     return m_impl.size();
130 }
131 
132 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
133 inline unsigned HashCountedSet&lt;Value, HashFunctions, Traits&gt;::capacity() const
134 {
135     return m_impl.capacity();
136 }
137 
138 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
139 inline bool HashCountedSet&lt;Value, HashFunctions, Traits&gt;::isEmpty() const
140 {
141     return size() == 0;
142 }
143 
144 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
145 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::begin() -&gt; iterator
146 {
147     return m_impl.begin();
148 }
149 
150 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
151 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::end() -&gt; iterator
152 {
153     return m_impl.end();
154 }
155 
156 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
157 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::begin() const -&gt; const_iterator
158 {
159     return m_impl.begin();
160 }
161 
162 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
163 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::end() const -&gt; const_iterator
164 {
165     return m_impl.end();
166 }
167 
168 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
169 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::values() -&gt; ValuesIteratorRange
170 {
171     return m_impl.keys();
172 }
173 
174 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
175 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::values() const -&gt; const ValuesConstIteratorRange
176 {
177     return m_impl.keys();
178 }
179 
180 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
181 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::find(const ValueType&amp; value) -&gt; iterator
182 {
183     return m_impl.find(value);
184 }
185 
186 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
187 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::find(const ValueType&amp; value) const -&gt; const_iterator
188 {
189     return m_impl.find(value);
190 }
191 
192 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
193 inline bool HashCountedSet&lt;Value, HashFunctions, Traits&gt;::contains(const ValueType&amp; value) const
194 {
195     return m_impl.contains(value);
196 }
197 
198 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
199 inline unsigned HashCountedSet&lt;Value, HashFunctions, Traits&gt;::count(const ValueType&amp; value) const
200 {
201     return m_impl.get(value);
202 }
203 
204 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
205 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::add(const ValueType &amp;value) -&gt; AddResult
206 {
207     auto result = m_impl.add(value, 0);
208     ++result.iterator-&gt;value;
209     return result;
210 }
211 
212 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
213 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::add(ValueType&amp;&amp; value) -&gt; AddResult
214 {
215     auto result = m_impl.add(std::forward&lt;Value&gt;(value), 0);
216     ++result.iterator-&gt;value;
217     return result;
218 }
219 
220 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
221 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::add(const ValueType&amp; value, unsigned count) -&gt; AddResult
222 {
223     auto result = m_impl.add(value, 0);
224     result.iterator-&gt;value += count;
225     return result;
226 }
227 
228 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
229 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::add(ValueType&amp;&amp; value, unsigned count) -&gt; AddResult
230 {
231     auto result = m_impl.add(std::forward&lt;Value&gt;(value), 0);
232     result.iterator-&gt;value += count;
233     return result;
234 }
235 
236 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
237 inline bool HashCountedSet&lt;Value, HashFunctions, Traits&gt;::remove(const ValueType&amp; value)
238 {
239     return remove(find(value));
240 }
241 
242 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
243 inline bool HashCountedSet&lt;Value, HashFunctions, Traits&gt;::remove(iterator it)
244 {
245     if (it == end())
246         return false;
247 
248     unsigned oldVal = it-&gt;value;
249     ASSERT(oldVal);
250     unsigned newVal = oldVal - 1;
251     if (newVal) {
252         it-&gt;value = newVal;
253         return false;
254     }
255 
256     m_impl.remove(it);
257     return true;
258 }
259 
260 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
261 inline bool HashCountedSet&lt;Value, HashFunctions, Traits&gt;::removeAll(const ValueType&amp; value)
262 {
263     return removeAll(find(value));
264 }
265 
266 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
267 inline bool HashCountedSet&lt;Value, HashFunctions, Traits&gt;::removeAll(iterator it)
268 {
269     if (it == end())
270         return false;
271 
272     m_impl.remove(it);
273     return true;
274 }
275 
276 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
277 inline void HashCountedSet&lt;Value, HashFunctions, Traits&gt;::clear()
278 {
279     m_impl.clear();
280 }
281 
282 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
283 template&lt;typename V&gt;
284 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::find(typename GetPtrHelper&lt;V&gt;::PtrType value) -&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, iterator&gt;::type
285 {
286     return m_impl.find(value);
287 }
288 
289 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
290 template&lt;typename V&gt;
291 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::find(typename GetPtrHelper&lt;V&gt;::PtrType value) const -&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, const_iterator&gt;::type
292 {
293     return m_impl.find(value);
294 }
295 
296 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
297 template&lt;typename V&gt;
298 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::contains(typename GetPtrHelper&lt;V&gt;::PtrType value) const -&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, bool&gt;::type
299 {
300     return m_impl.contains(value);
301 }
302 
303 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
304 template&lt;typename V&gt;
305 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::count(typename GetPtrHelper&lt;V&gt;::PtrType value) const -&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, unsigned&gt;::type
306 {
307     return m_impl.get(value);
308 }
309 
310 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
311 template&lt;typename V&gt;
312 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::remove(typename GetPtrHelper&lt;V&gt;::PtrType value) -&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, bool&gt;::type
313 {
314     return remove(find(value));
315 }
316 
317 } // namespace WTF
318 
319 using WTF::HashCountedSet;
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/IDBServer.cpp b/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/IDBServer.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/IDBServer.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/IDBServer.cpp
@@ -44,63 +44,57 @@
 #include <wtf/MainThread.h>
 
 namespace WebCore {
 namespace IDBServer {
 
-Ref<IDBServer> IDBServer::create(PAL::SessionID sessionID, IDBBackingStoreTemporaryFileHandler& fileHandler, QuotaManagerGetter&& quotaManagerGetter)
+IDBServer::IDBServer(PAL::SessionID sessionID, const String& databaseDirectoryPath, StorageQuotaManagerSpaceRequester&& spaceRequester)
+    : m_sessionID(sessionID)
+    , m_spaceRequester(WTFMove(spaceRequester))
 {
-    return adoptRef(*new IDBServer(sessionID, fileHandler, WTFMove(quotaManagerGetter)));
-}
-
-Ref<IDBServer> IDBServer::create(PAL::SessionID sessionID, const String& databaseDirectoryPath, IDBBackingStoreTemporaryFileHandler& fileHandler, QuotaManagerGetter&& quotaManagerGetter)
-{
-    return adoptRef(*new IDBServer(sessionID, databaseDirectoryPath, fileHandler, WTFMove(quotaManagerGetter)));
-}
+    ASSERT(!isMainThread());
+    ASSERT(databaseDirectoryPath.isSafeToSendToAnotherThread());
 
-IDBServer::IDBServer(PAL::SessionID sessionID, IDBBackingStoreTemporaryFileHandler& fileHandler, QuotaManagerGetter&& quotaManagerGetter)
-    : CrossThreadTaskHandler("IndexedDatabase Server", AutodrainedPoolForRunLoop::Use)
-    , m_sessionID(sessionID)
-    , m_backingStoreTemporaryFileHandler(fileHandler)
-    , m_quotaManagerGetter(WTFMove(quotaManagerGetter))
-{
+    m_databaseDirectoryPath = databaseDirectoryPath;
+    upgradeFilesIfNecessary();
 }
 
-IDBServer::IDBServer(PAL::SessionID sessionID, const String& databaseDirectoryPath, IDBBackingStoreTemporaryFileHandler& fileHandler, QuotaManagerGetter&& quotaManagerGetter)
-    : CrossThreadTaskHandler("IndexedDatabase Server", AutodrainedPoolForRunLoop::Use)
-    , m_sessionID(sessionID)
-    , m_databaseDirectoryPath(databaseDirectoryPath)
-    , m_backingStoreTemporaryFileHandler(fileHandler)
-    , m_quotaManagerGetter(WTFMove(quotaManagerGetter))
+IDBServer::~IDBServer()
 {
-    LOG(IndexedDB, "IDBServer created at path %s", databaseDirectoryPath.utf8().data());
-    postDatabaseTask(createCrossThreadTask(*this, &IDBServer::upgradeFilesIfNecessary));
+    ASSERT(!isMainThread());
 }
 
 void IDBServer::registerConnection(IDBConnectionToClient& connection)
 {
+    ASSERT(!isMainThread());
     ASSERT(!m_connectionMap.contains(connection.identifier()));
     m_connectionMap.set(connection.identifier(), &connection);
 }
 
 void IDBServer::unregisterConnection(IDBConnectionToClient& connection)
 {
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
     ASSERT(m_connectionMap.contains(connection.identifier()));
     ASSERT(m_connectionMap.get(connection.identifier()) == &connection);
 
     connection.connectionToClientClosed();
 
     m_connectionMap.remove(connection.identifier());
 }
 
 void IDBServer::registerTransaction(UniqueIDBDatabaseTransaction& transaction)
 {
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
     ASSERT(!m_transactions.contains(transaction.info().identifier()));
     m_transactions.set(transaction.info().identifier(), &transaction);
 }
 
 void IDBServer::unregisterTransaction(UniqueIDBDatabaseTransaction& transaction)
 {
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
     ASSERT(m_transactions.contains(transaction.info().identifier()));
     ASSERT(m_transactions.get(transaction.info().identifier()) == &transaction);
 
     m_transactions.remove(transaction.info().identifier());
 }
@@ -117,11 +111,11 @@
     m_databaseConnections.remove(connection.identifier());
 }
 
 UniqueIDBDatabase& IDBServer::getOrCreateUniqueIDBDatabase(const IDBDatabaseIdentifier& identifier)
 {
-    ASSERT(isMainThread());
+    ASSERT(!isMainThread());
 
     auto uniqueIDBDatabase = m_uniqueIDBDatabaseMap.add(identifier, nullptr);
     if (uniqueIDBDatabase.isNewEntry)
         uniqueIDBDatabase.iterator->value = makeUnique<UniqueIDBDatabase>(*this, identifier);
 
@@ -132,18 +126,20 @@
 {
     ASSERT(!isMainThread());
 
     auto databaseDirectoryPath = this->databaseDirectoryPathIsolatedCopy();
     if (databaseDirectoryPath.isEmpty())
-        return MemoryIDBBackingStore::create(m_sessionID, identifier);
+        return makeUnique<MemoryIDBBackingStore>(m_sessionID, identifier);
 
-    return makeUnique<SQLiteIDBBackingStore>(m_sessionID, identifier, databaseDirectoryPath, m_backingStoreTemporaryFileHandler);
+    return makeUnique<SQLiteIDBBackingStore>(m_sessionID, identifier, databaseDirectoryPath);
 }
 
 void IDBServer::openDatabase(const IDBRequestData& requestData)
 {
     LOG(IndexedDB, "IDBServer::openDatabase");
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     auto& uniqueIDBDatabase = getOrCreateUniqueIDBDatabase(requestData.databaseIdentifier());
 
     auto connection = m_connectionMap.get(requestData.requestIdentifier().connectionIdentifier());
     if (!connection) {
@@ -155,12 +151,13 @@
     uniqueIDBDatabase.openDatabaseConnection(*connection, requestData);
 }
 
 void IDBServer::deleteDatabase(const IDBRequestData& requestData)
 {
-    LOG(IndexedDB, "IDBServer::deleteDatabase - %s", requestData.databaseIdentifier().debugString().utf8().data());
-    ASSERT(isMainThread());
+    LOG(IndexedDB, "IDBServer::deleteDatabase - %s", requestData.databaseIdentifier().loggingString().utf8().data());
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     auto connection = m_connectionMap.get(requestData.requestIdentifier().connectionIdentifier());
     if (!connection) {
         // If the connection back to the client is gone, there's no way to delete the database as
         // well as no way to message back failure.
@@ -186,10 +183,12 @@
 }
 
 void IDBServer::abortTransaction(const IDBResourceIdentifier& transactionIdentifier)
 {
     LOG(IndexedDB, "IDBServer::abortTransaction");
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     auto transaction = m_transactions.get(transactionIdentifier);
     if (!transaction) {
         // If there is no transaction there is nothing to abort.
         // We also have no access to a connection over which to message failure-to-abort.
@@ -200,10 +199,12 @@
 }
 
 void IDBServer::createObjectStore(const IDBRequestData& requestData, const IDBObjectStoreInfo& info)
 {
     LOG(IndexedDB, "IDBServer::createObjectStore");
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     auto transaction = m_transactions.get(requestData.transactionIdentifier());
     if (!transaction)
         return;
 
@@ -212,10 +213,12 @@
 }
 
 void IDBServer::deleteObjectStore(const IDBRequestData& requestData, const String& objectStoreName)
 {
     LOG(IndexedDB, "IDBServer::deleteObjectStore");
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     auto transaction = m_transactions.get(requestData.transactionIdentifier());
     if (!transaction)
         return;
 
@@ -224,10 +227,12 @@
 }
 
 void IDBServer::renameObjectStore(const IDBRequestData& requestData, uint64_t objectStoreIdentifier, const String& newName)
 {
     LOG(IndexedDB, "IDBServer::renameObjectStore");
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     auto transaction = m_transactions.get(requestData.transactionIdentifier());
     if (!transaction)
         return;
 
@@ -236,10 +241,12 @@
 }
 
 void IDBServer::clearObjectStore(const IDBRequestData& requestData, uint64_t objectStoreIdentifier)
 {
     LOG(IndexedDB, "IDBServer::clearObjectStore");
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     auto transaction = m_transactions.get(requestData.transactionIdentifier());
     if (!transaction)
         return;
 
@@ -247,10 +254,12 @@
 }
 
 void IDBServer::createIndex(const IDBRequestData& requestData, const IDBIndexInfo& info)
 {
     LOG(IndexedDB, "IDBServer::createIndex");
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     auto transaction = m_transactions.get(requestData.transactionIdentifier());
     if (!transaction)
         return;
 
@@ -259,10 +268,12 @@
 }
 
 void IDBServer::deleteIndex(const IDBRequestData& requestData, uint64_t objectStoreIdentifier, const String& indexName)
 {
     LOG(IndexedDB, "IDBServer::deleteIndex");
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     auto transaction = m_transactions.get(requestData.transactionIdentifier());
     if (!transaction)
         return;
 
@@ -271,10 +282,12 @@
 }
 
 void IDBServer::renameIndex(const IDBRequestData& requestData, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String& newName)
 {
     LOG(IndexedDB, "IDBServer::renameIndex");
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     auto transaction = m_transactions.get(requestData.transactionIdentifier());
     if (!transaction)
         return;
 
@@ -283,10 +296,12 @@
 }
 
 void IDBServer::putOrAdd(const IDBRequestData& requestData, const IDBKeyData& keyData, const IDBValue& value, IndexedDB::ObjectStoreOverwriteMode overwriteMode)
 {
     LOG(IndexedDB, "IDBServer::putOrAdd");
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     auto transaction = m_transactions.get(requestData.transactionIdentifier());
     if (!transaction)
         return;
 
@@ -294,10 +309,12 @@
 }
 
 void IDBServer::getRecord(const IDBRequestData& requestData, const IDBGetRecordData& getRecordData)
 {
     LOG(IndexedDB, "IDBServer::getRecord");
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     auto transaction = m_transactions.get(requestData.transactionIdentifier());
     if (!transaction)
         return;
 
@@ -305,10 +322,12 @@
 }
 
 void IDBServer::getAllRecords(const IDBRequestData& requestData, const IDBGetAllRecordsData& getAllRecordsData)
 {
     LOG(IndexedDB, "IDBServer::getAllRecords");
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     auto transaction = m_transactions.get(requestData.transactionIdentifier());
     if (!transaction)
         return;
 
@@ -316,10 +335,12 @@
 }
 
 void IDBServer::getCount(const IDBRequestData& requestData, const IDBKeyRangeData& keyRangeData)
 {
     LOG(IndexedDB, "IDBServer::getCount");
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     auto transaction = m_transactions.get(requestData.transactionIdentifier());
     if (!transaction)
         return;
 
@@ -327,10 +348,12 @@
 }
 
 void IDBServer::deleteRecord(const IDBRequestData& requestData, const IDBKeyRangeData& keyRangeData)
 {
     LOG(IndexedDB, "IDBServer::deleteRecord");
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     auto transaction = m_transactions.get(requestData.transactionIdentifier());
     if (!transaction)
         return;
 
@@ -338,10 +361,12 @@
 }
 
 void IDBServer::openCursor(const IDBRequestData& requestData, const IDBCursorInfo& info)
 {
     LOG(IndexedDB, "IDBServer::openCursor");
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     auto transaction = m_transactions.get(requestData.transactionIdentifier());
     if (!transaction)
         return;
 
@@ -349,10 +374,12 @@
 }
 
 void IDBServer::iterateCursor(const IDBRequestData& requestData, const IDBIterateCursorData& data)
 {
     LOG(IndexedDB, "IDBServer::iterateCursor");
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     auto transaction = m_transactions.get(requestData.transactionIdentifier());
     if (!transaction)
         return;
 
@@ -360,10 +387,12 @@
 }
 
 void IDBServer::establishTransaction(uint64_t databaseConnectionIdentifier, const IDBTransactionInfo& info)
 {
     LOG(IndexedDB, "IDBServer::establishTransaction");
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier);
     if (!databaseConnection)
         return;
 
@@ -371,10 +400,12 @@
 }
 
 void IDBServer::commitTransaction(const IDBResourceIdentifier& transactionIdentifier)
 {
     LOG(IndexedDB, "IDBServer::commitTransaction");
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     auto transaction = m_transactions.get(transactionIdentifier);
     if (!transaction) {
         // If there is no transaction there is nothing to commit.
         // We also have no access to a connection over which to message failure-to-commit.
@@ -385,10 +416,12 @@
 }
 
 void IDBServer::didFinishHandlingVersionChangeTransaction(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier& transactionIdentifier)
 {
     LOG(IndexedDB, "IDBServer::didFinishHandlingVersionChangeTransaction - %s", transactionIdentifier.loggingString().utf8().data());
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     auto* connection = m_databaseConnections.get(databaseConnectionIdentifier);
     if (!connection)
         return;
 
@@ -396,10 +429,12 @@
 }
 
 void IDBServer::databaseConnectionPendingClose(uint64_t databaseConnectionIdentifier)
 {
     LOG(IndexedDB, "IDBServer::databaseConnectionPendingClose - %" PRIu64, databaseConnectionIdentifier);
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier);
     if (!databaseConnection)
         return;
 
@@ -407,10 +442,12 @@
 }
 
 void IDBServer::databaseConnectionClosed(uint64_t databaseConnectionIdentifier)
 {
     LOG(IndexedDB, "IDBServer::databaseConnectionClosed - %" PRIu64, databaseConnectionIdentifier);
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier);
     if (!databaseConnection)
         return;
 
@@ -418,10 +455,12 @@
 }
 
 void IDBServer::abortOpenAndUpgradeNeeded(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier& transactionIdentifier)
 {
     LOG(IndexedDB, "IDBServer::abortOpenAndUpgradeNeeded");
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     auto transaction = m_transactions.get(transactionIdentifier);
     if (transaction)
         transaction->abortWithoutCallback();
 
@@ -430,45 +469,38 @@
         return;
 
     databaseConnection->connectionClosedFromClient();
 }
 
-void IDBServer::didFireVersionChangeEvent(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier& requestIdentifier)
+void IDBServer::didFireVersionChangeEvent(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier& requestIdentifier, IndexedDB::ConnectionClosedOnBehalfOfServer connectionClosed)
 {
     LOG(IndexedDB, "IDBServer::didFireVersionChangeEvent");
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     if (auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier))
-        databaseConnection->didFireVersionChangeEvent(requestIdentifier);
+        databaseConnection->didFireVersionChangeEvent(requestIdentifier, connectionClosed);
 }
 
 void IDBServer::openDBRequestCancelled(const IDBRequestData& requestData)
 {
     LOG(IndexedDB, "IDBServer::openDBRequestCancelled");
-    ASSERT(isMainThread());
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     auto* uniqueIDBDatabase = m_uniqueIDBDatabaseMap.get(requestData.databaseIdentifier());
     if (!uniqueIDBDatabase)
         return;
 
     uniqueIDBDatabase->openDBRequestCancelled(requestData.requestIdentifier());
 }
 
-void IDBServer::confirmDidCloseFromServer(uint64_t databaseConnectionIdentifier)
+void IDBServer::getAllDatabaseNames(IDBConnectionIdentifier serverConnectionIdentifier, const SecurityOriginData& mainFrameOrigin, const SecurityOriginData& openingOrigin, uint64_t callbackID)
 {
-    LOG(IndexedDB, "IDBServer::confirmDidCloseFromServer");
-
-    if (auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier))
-        databaseConnection->confirmDidCloseFromServer();
-}
-
-void IDBServer::getAllDatabaseNames(uint64_t serverConnectionIdentifier, const SecurityOriginData& mainFrameOrigin, const SecurityOriginData& openingOrigin, uint64_t callbackID)
-{
-    postDatabaseTask(createCrossThreadTask(*this, &IDBServer::performGetAllDatabaseNames, serverConnectionIdentifier, mainFrameOrigin, openingOrigin, callbackID));
-}
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
-void IDBServer::performGetAllDatabaseNames(uint64_t serverConnectionIdentifier, const SecurityOriginData& mainFrameOrigin, const SecurityOriginData& openingOrigin, uint64_t callbackID)
-{
     auto databaseDirectoryPath = this->databaseDirectoryPathIsolatedCopy();
     String oldDirectory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(mainFrameOrigin, openingOrigin, databaseDirectoryPath, "v0");
     Vector<String> files = FileSystem::listDirectory(oldDirectory, "*"_s);
     Vector<String> databases;
     for (auto& file : files) {
@@ -482,66 +514,42 @@
         auto databaseName = SQLiteIDBBackingStore::databaseNameFromFile(SQLiteIDBBackingStore::fullDatabasePathForDirectory(file));
         if (!databaseName.isEmpty())
             databases.append(databaseName);
     }
 
-    postDatabaseTaskReply(createCrossThreadTask(*this, &IDBServer::didGetAllDatabaseNames, serverConnectionIdentifier, callbackID, databases));
-}
-
-void IDBServer::didGetAllDatabaseNames(uint64_t serverConnectionIdentifier, uint64_t callbackID, const Vector<String>& databaseNames)
-{
     auto connection = m_connectionMap.get(serverConnectionIdentifier);
     if (!connection)
         return;
 
-    connection->didGetAllDatabaseNames(callbackID, databaseNames);
-}
-
-void IDBServer::postDatabaseTask(CrossThreadTask&& task)
-{
-    postTask(WTFMove(task));
-}
-
-void IDBServer::postDatabaseTaskReply(CrossThreadTask&& task)
-{
-    postTaskReply(WTFMove(task));
-}
-
-static uint64_t generateDeleteCallbackID()
-{
-    ASSERT(isMainThread());
-    static uint64_t currentID = 0;
-    return ++currentID;
+    connection->didGetAllDatabaseNames(callbackID, databases);
 }
 
-void IDBServer::closeAndDeleteDatabasesModifiedSince(WallTime modificationTime, Function<void ()>&& completionHandler)
+void IDBServer::closeAndDeleteDatabasesModifiedSince(WallTime modificationTime)
 {
-    uint64_t callbackID = generateDeleteCallbackID();
-    auto addResult = m_deleteDatabaseCompletionHandlers.add(callbackID, WTFMove(completionHandler));
-    ASSERT_UNUSED(addResult, addResult.isNewEntry);
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     // If the modification time is in the future, don't both doing anything.
-    if (modificationTime > WallTime::now()) {
-        postDatabaseTaskReply(createCrossThreadTask(*this, &IDBServer::didPerformCloseAndDeleteDatabases, callbackID));
+    if (modificationTime > WallTime::now())
         return;
-    }
 
     HashSet<UniqueIDBDatabase*> openDatabases;
     for (auto& database : m_uniqueIDBDatabaseMap.values())
-        openDatabases.add(database.get());
-
-    for (auto& database : openDatabases)
         database->immediateCloseForUserDelete();
 
-    postDatabaseTask(createCrossThreadTask(*this, &IDBServer::performCloseAndDeleteDatabasesModifiedSince, modificationTime, callbackID));
+    m_uniqueIDBDatabaseMap.clear();
+
+    if (!m_databaseDirectoryPath.isEmpty()) {
+        removeDatabasesModifiedSinceForVersion(modificationTime, "v0");
+        removeDatabasesModifiedSinceForVersion(modificationTime, "v1");
+    }
 }
 
-void IDBServer::closeAndDeleteDatabasesForOrigins(const Vector<SecurityOriginData>& origins, Function<void ()>&& completionHandler)
+void IDBServer::closeAndDeleteDatabasesForOrigins(const Vector<SecurityOriginData>& origins)
 {
-    uint64_t callbackID = generateDeleteCallbackID();
-    auto addResult = m_deleteDatabaseCompletionHandlers.add(callbackID, WTFMove(completionHandler));
-    ASSERT_UNUSED(addResult, addResult.isNewEntry);
+    ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
     HashSet<UniqueIDBDatabase*> openDatabases;
     for (auto& database : m_uniqueIDBDatabaseMap.values()) {
         const auto& identifier = database->identifier();
         for (auto& origin : origins) {
@@ -550,14 +558,19 @@
                 break;
             }
         }
     }
 
-    for (auto& database : openDatabases)
+    for (auto& database : openDatabases) {
         database->immediateCloseForUserDelete();
+        m_uniqueIDBDatabaseMap.remove(database->identifier());
+    }
 
-    postDatabaseTask(createCrossThreadTask(*this, &IDBServer::performCloseAndDeleteDatabasesForOrigins, origins, callbackID));
+    if (!m_databaseDirectoryPath.isEmpty()) {
+        removeDatabasesWithOriginsForVersion(origins, "v0");
+        removeDatabasesWithOriginsForVersion(origins, "v1");
+    }
 }
 
 static void removeAllDatabasesForFullOriginPath(const String& originPath, WallTime modifiedSince)
 {
     LOG(IndexedDB, "removeAllDatabasesForOriginPath with originPath %s", originPath.utf8().data());
@@ -647,20 +660,10 @@
         if (auto securityOrigin = SecurityOriginData::fromDatabaseIdentifier(databaseIdentifier))
             removeAllDatabasesForOriginPath(originPath, modifiedSince);
     }
 }
 
-void IDBServer::performCloseAndDeleteDatabasesModifiedSince(WallTime modifiedSince, uint64_t callbackID)
-{
-    if (!databaseDirectoryPathIsolatedCopy().isEmpty()) {
-        removeDatabasesModifiedSinceForVersion(modifiedSince, "v0");
-        removeDatabasesModifiedSinceForVersion(modifiedSince, "v1");
-    }
-
-    postDatabaseTaskReply(createCrossThreadTask(*this, &IDBServer::didPerformCloseAndDeleteDatabases, callbackID));
-}
-
 void IDBServer::removeDatabasesWithOriginsForVersion(const Vector<SecurityOriginData> &origins, const String& version)
 {
     String versionPath = FileSystem::pathByAppendingComponent(databaseDirectoryPathIsolatedCopy(), version);
     for (const auto& origin : origins) {
         String originPath = FileSystem::pathByAppendingComponent(versionPath, origin.databaseIdentifier());
@@ -671,169 +674,32 @@
             removeAllDatabasesForOriginPath(originPath, -WallTime::infinity());
         }
     }
 }
 
-void IDBServer::performCloseAndDeleteDatabasesForOrigins(const Vector<SecurityOriginData>& origins, uint64_t callbackID)
-{
-    if (!databaseDirectoryPathIsolatedCopy().isEmpty()) {
-        removeDatabasesWithOriginsForVersion(origins, "v0");
-        removeDatabasesWithOriginsForVersion(origins, "v1");
-    }
-
-    postDatabaseTaskReply(createCrossThreadTask(*this, &IDBServer::didPerformCloseAndDeleteDatabases, callbackID));
-}
-
-void IDBServer::didPerformCloseAndDeleteDatabases(uint64_t callbackID)
-{
-    for (auto& user : m_quotaUsers.values())
-        user->resetSpaceUsed();
-
-    auto callback = m_deleteDatabaseCompletionHandlers.take(callbackID);
-    ASSERT(callback);
-    callback();
-}
-
-IDBServer::QuotaUser::QuotaUser(IDBServer& server, StorageQuotaManager* manager, ClientOrigin&& origin)
-    : m_server(server)
-    , m_manager(makeWeakPtr(manager))
-    , m_origin(WTFMove(origin))
-    , m_isInitialized(m_server.m_sessionID.isEphemeral())
-{
-    if (manager)
-        manager->addUser(*this);
-}
-
-IDBServer::QuotaUser::~QuotaUser()
-{
-    if (m_manager)
-        m_manager->removeUser(*this);
-}
-
-void IDBServer::QuotaUser::resetSpaceUsed()
-{
-    m_spaceUsed = 0;
-    m_estimatedSpaceIncrease = 0;
-
-    if (!m_manager)
-        return;
-
-    if (m_server.m_sessionID.isEphemeral())
-        return;
-
-    if (!m_isInitialized)
-        return;
-
-    ASSERT(!m_initializationCallback);
-
-    m_isInitialized = false;
-
-    // Do add/remove to trigger call to whenInitialized.
-    m_manager->removeUser(*this);
-    m_manager->addUser(*this);
-}
-
-void IDBServer::QuotaUser::increaseSpaceUsed(uint64_t size)
-{
-    if (!m_isInitialized)
-        return;
-    ASSERT(m_spaceUsed + size > m_spaceUsed);
-    m_spaceUsed += size;
-}
-void IDBServer::QuotaUser::decreaseSpaceUsed(uint64_t size)
-{
-    if (!m_isInitialized)
-        return;
-    ASSERT(m_spaceUsed >= size);
-    m_spaceUsed -= size;
-}
-
-void IDBServer::QuotaUser::whenInitialized(CompletionHandler<void()>&& callback)
-{
-    if (m_isInitialized) {
-        callback();
-        return;
-    }
-    m_initializationCallback = WTFMove(callback);
-    m_server.startComputingSpaceUsedForOrigin(m_origin);
-}
-
-void IDBServer::QuotaUser::initializeSpaceUsed(uint64_t spaceUsed)
-{
-    ASSERT(m_isInitialized || !m_estimatedSpaceIncrease);
-    m_spaceUsed = spaceUsed;
-    m_isInitialized = true;
-
-    if (auto callback = WTFMove(m_initializationCallback))
-        callback();
-}
-
-IDBServer::QuotaUser& IDBServer::ensureQuotaUser(const ClientOrigin& origin)
-{
-    return *m_quotaUsers.ensure(origin, [this, &origin] {
-        return makeUnique<QuotaUser>(*this, m_quotaManagerGetter(m_sessionID, origin), ClientOrigin { origin });
-    }).iterator->value;
-}
-
-void IDBServer::startComputingSpaceUsedForOrigin(const ClientOrigin& origin)
-{
-    ASSERT(!m_sessionID.isEphemeral());
-    postDatabaseTask(createCrossThreadTask(*this, &IDBServer::computeSpaceUsedForOrigin, origin));
-}
-
-void IDBServer::computeSpaceUsedForOrigin(const ClientOrigin& origin)
+StorageQuotaManager::Decision IDBServer::requestSpace(const ClientOrigin& origin, uint64_t taskSize)
 {
     ASSERT(!isMainThread());
+    ASSERT(m_lock.isHeld());
 
-    auto databaseDirectoryPath = this->databaseDirectoryPathIsolatedCopy();
-    auto oldVersionOriginDirectory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(origin.topOrigin, origin.clientOrigin, databaseDirectoryPath, "v0");
-    auto newVersionOriginDirectory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(origin.topOrigin, origin.clientOrigin, databaseDirectoryPath, "v1");
-    auto size = SQLiteIDBBackingStore::databasesSizeForDirectory(oldVersionOriginDirectory) + SQLiteIDBBackingStore::databasesSizeForDirectory(newVersionOriginDirectory);
-
-    postDatabaseTaskReply(createCrossThreadTask(*this, &IDBServer::finishComputingSpaceUsedForOrigin, origin, size));
-}
-
-void IDBServer::finishComputingSpaceUsedForOrigin(const ClientOrigin& origin, uint64_t spaceUsed)
-{
-    ensureQuotaUser(origin).initializeSpaceUsed(spaceUsed);
-}
-
-void IDBServer::requestSpace(const ClientOrigin& origin, uint64_t taskSize, CompletionHandler<void(StorageQuotaManager::Decision)>&& callback)
-{
-    auto* quotaManager = ensureQuotaUser(origin).manager();
-    if (!quotaManager) {
-        callback(StorageQuotaManager::Decision::Deny);
-        return;
-    }
+    StorageQuotaManager::Decision result = StorageQuotaManager::Decision::Deny;
 
-    quotaManager->requestSpace(taskSize, WTFMove(callback));
-}
+    // Release lock because space requesting could be blocked.
+    m_lock.unlock();
+    result = m_spaceRequester(origin, taskSize);
+    m_lock.lock();
 
-void IDBServer::resetSpaceUsed(const ClientOrigin& origin)
-{
-    if (auto* user = m_quotaUsers.get(origin))
-        user->resetSpaceUsed();
+    return result;
 }
 
-void IDBServer::increaseSpaceUsed(const ClientOrigin& origin, uint64_t size)
+uint64_t IDBServer::diskUsage(const String& rootDirectory, const ClientOrigin& origin)
 {
-    ensureQuotaUser(origin).increaseSpaceUsed(size);
-}
-
-void IDBServer::decreaseSpaceUsed(const ClientOrigin& origin, uint64_t size)
-{
-    ensureQuotaUser(origin).decreaseSpaceUsed(size);
-}
-
-void IDBServer::increasePotentialSpaceUsed(const ClientOrigin& origin, uint64_t taskSize)
-{
-    ensureQuotaUser(origin).increasePotentialSpaceUsed(taskSize);
-}
+    ASSERT(!isMainThread());
 
-void IDBServer::decreasePotentialSpaceUsed(const ClientOrigin& origin, uint64_t spaceUsed)
-{
-    ensureQuotaUser(origin).decreasePotentialSpaceUsed(spaceUsed);
+    auto oldVersionOriginDirectory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(origin.topOrigin, origin.clientOrigin, rootDirectory, "v0"_str);
+    auto newVersionOriginDirectory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(origin.topOrigin, origin.clientOrigin, rootDirectory, "v1"_str);
+    return SQLiteIDBBackingStore::databasesSizeForDirectory(oldVersionOriginDirectory) + SQLiteIDBBackingStore::databasesSizeForDirectory(newVersionOriginDirectory);
 }
 
 void IDBServer::upgradeFilesIfNecessary()
 {
     auto databaseDirectoryPath = this->databaseDirectoryPathIsolatedCopy();
@@ -843,32 +709,21 @@
     String newVersionDirectory = FileSystem::pathByAppendingComponent(databaseDirectoryPath, "v1");
     if (!FileSystem::fileExists(newVersionDirectory))
         FileSystem::makeAllDirectories(newVersionDirectory);
 }
 
-void IDBServer::tryStop(ShouldForceStop shouldForceStop)
+void IDBServer::stopDatabaseActivitiesOnMainThread()
 {
+    ASSERT(isMainThread());
+    ASSERT(m_lock.isHeld());
+
     // Only stop non-ephemeral IDBServers that can hold locked database files.
     if (m_sessionID.isEphemeral())
         return;
 
-    suspendAndWait();
-    if (shouldForceStop == ShouldForceStop::No && SQLiteDatabaseTracker::hasTransactionInProgress()) {
-        CrossThreadTaskHandler::resume();
-        return;
-    }
-
     for (auto& database : m_uniqueIDBDatabaseMap.values())
-        database->finishActiveTransactions();
-}
-
-void IDBServer::resume()
-{
-    if (m_sessionID.isEphemeral())
-        return;
-
-    CrossThreadTaskHandler::resume();
+        database->abortActiveTransactions();
 }
 
 } // namespace IDBServer
 } // namespace WebCore
 

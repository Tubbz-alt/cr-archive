<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebGLAny.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLBuffer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLBuffer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebGLBuffer.h&quot;
 28 
 29 #if ENABLE(WEBGL)
 30 
 31 #include &quot;WebGLContextGroup.h&quot;
 32 #include &quot;WebGLRenderingContextBase.h&quot;

 33 
 34 namespace WebCore {
 35 
 36 Ref&lt;WebGLBuffer&gt; WebGLBuffer::create(WebGLRenderingContextBase&amp; ctx)
 37 {
 38     return adoptRef(*new WebGLBuffer(ctx));
 39 }
 40 
 41 WebGLBuffer::WebGLBuffer(WebGLRenderingContextBase&amp; ctx)
 42     : WebGLSharedObject(ctx)
 43 {
<span class="line-modified"> 44     setObject(ctx.graphicsContext3D()-&gt;createBuffer());</span>
 45     clearCachedMaxIndices();
 46 }
 47 
 48 WebGLBuffer::~WebGLBuffer()
 49 {
 50     deleteObject(0);
 51 }
 52 
<span class="line-modified"> 53 void WebGLBuffer::deleteObjectImpl(GraphicsContext3D* context3d, Platform3DObject object)</span>
 54 {
 55     context3d-&gt;deleteBuffer(object);
 56 }
 57 
<span class="line-modified"> 58 bool WebGLBuffer::associateBufferDataImpl(const void* data, GC3Dsizeiptr byteLength)</span>
 59 {
 60     if (byteLength &lt; 0)
 61         return false;
 62 
 63     switch (m_target) {
<span class="line-modified"> 64     case GraphicsContext3D::ELEMENT_ARRAY_BUFFER:</span>
 65         if (byteLength &gt; std::numeric_limits&lt;unsigned&gt;::max())
 66             return false;
 67         m_byteLength = byteLength;
 68         clearCachedMaxIndices();
 69         if (byteLength) {
 70             m_elementArrayBuffer = ArrayBuffer::tryCreate(byteLength, 1);
 71             if (!m_elementArrayBuffer) {
 72                 m_byteLength = 0;
 73                 return false;
 74             }
 75             if (data) {
 76                 // We must always clone the incoming data because client-side
 77                 // modifications without calling bufferData or bufferSubData
 78                 // must never be able to change the validation results.
 79                 memcpy(m_elementArrayBuffer-&gt;data(), data, byteLength);
 80             }
 81         } else
 82             m_elementArrayBuffer = nullptr;
 83         return true;
<span class="line-modified"> 84     case GraphicsContext3D::ARRAY_BUFFER:</span>
 85         m_byteLength = byteLength;
 86         return true;
 87     default:
 88 #if ENABLE(WEBGL2)
 89         switch (m_target) {
<span class="line-modified"> 90         case GraphicsContext3D::COPY_READ_BUFFER:</span>
<span class="line-modified"> 91         case GraphicsContext3D::COPY_WRITE_BUFFER:</span>
<span class="line-modified"> 92         case GraphicsContext3D::PIXEL_PACK_BUFFER:</span>
<span class="line-modified"> 93         case GraphicsContext3D::PIXEL_UNPACK_BUFFER:</span>
<span class="line-modified"> 94         case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER:</span>
<span class="line-modified"> 95         case GraphicsContext3D::UNIFORM_BUFFER:</span>
 96             m_byteLength = byteLength;
 97             return true;
 98         }
 99 #endif
100         return false;
101     }
102 }
103 
<span class="line-modified">104 bool WebGLBuffer::associateBufferData(GC3Dsizeiptr size)</span>
105 {
106     return associateBufferDataImpl(nullptr, size);
107 }
108 
109 bool WebGLBuffer::associateBufferData(ArrayBuffer* array)
110 {
111     if (!array)
112         return false;
113     return associateBufferDataImpl(array-&gt;data(), array-&gt;byteLength());
114 }
115 
116 bool WebGLBuffer::associateBufferData(ArrayBufferView* array)
117 {
118     if (!array)
119         return false;
120     return associateBufferDataImpl(array-&gt;baseAddress(), array-&gt;byteLength());
121 }
122 
<span class="line-modified">123 bool WebGLBuffer::associateBufferSubDataImpl(GC3Dintptr offset, const void* data, GC3Dsizeiptr byteLength)</span>
124 {
125     if (!data || offset &lt; 0 || byteLength &lt; 0)
126         return false;
127 
128     if (byteLength) {
<span class="line-modified">129         Checked&lt;GC3Dintptr, RecordOverflow&gt; checkedBufferOffset(offset);</span>
<span class="line-modified">130         Checked&lt;GC3Dsizeiptr, RecordOverflow&gt; checkedDataLength(byteLength);</span>
<span class="line-modified">131         Checked&lt;GC3Dintptr, RecordOverflow&gt; checkedBufferMax = checkedBufferOffset + checkedDataLength;</span>
132         if (checkedBufferMax.hasOverflowed() || offset &gt; m_byteLength || checkedBufferMax.unsafeGet() &gt; m_byteLength)
133             return false;
134     }
135 
136     switch (m_target) {
<span class="line-modified">137     case GraphicsContext3D::ELEMENT_ARRAY_BUFFER:</span>
138         clearCachedMaxIndices();
139         if (byteLength) {
140             if (!m_elementArrayBuffer)
141                 return false;
142             memcpy(static_cast&lt;unsigned char*&gt;(m_elementArrayBuffer-&gt;data()) + offset, data, byteLength);
143         }
144         return true;
<span class="line-modified">145     case GraphicsContext3D::ARRAY_BUFFER:</span>
146         return true;
147     default:
148 #if ENABLE(WEBGL2)
149         switch (m_target) {
<span class="line-modified">150         case GraphicsContext3D::COPY_READ_BUFFER:</span>
<span class="line-modified">151         case GraphicsContext3D::COPY_WRITE_BUFFER:</span>
<span class="line-modified">152         case GraphicsContext3D::PIXEL_PACK_BUFFER:</span>
<span class="line-modified">153         case GraphicsContext3D::PIXEL_UNPACK_BUFFER:</span>
<span class="line-modified">154         case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER:</span>
<span class="line-modified">155         case GraphicsContext3D::UNIFORM_BUFFER:</span>
156             return true;
157         }
158 #endif
159         return false;
160     }
161 }
162 
<span class="line-modified">163 bool WebGLBuffer::associateBufferSubData(GC3Dintptr offset, ArrayBuffer* array)</span>
164 {
165     if (!array)
166         return false;
167     return associateBufferSubDataImpl(offset, array-&gt;data(), array-&gt;byteLength());
168 }
169 
<span class="line-modified">170 bool WebGLBuffer::associateBufferSubData(GC3Dintptr offset, ArrayBufferView* array)</span>
171 {
172     if (!array)
173         return false;
174     return associateBufferSubDataImpl(offset, array-&gt;baseAddress(), array-&gt;byteLength());
175 }
176 
<span class="line-modified">177 bool WebGLBuffer::associateCopyBufferSubData(const WebGLBuffer&amp; readBuffer, GC3Dintptr readOffset, GC3Dintptr writeOffset, GC3Dsizeiptr size)</span>
178 {
179     if (readOffset &lt; 0 || writeOffset &lt; 0 || size &lt; 0)
180         return false;
181 
182     if (size) {
<span class="line-modified">183         Checked&lt;GC3Dintptr, RecordOverflow&gt; checkedReadBufferOffset(readOffset);</span>
<span class="line-modified">184         Checked&lt;GC3Dsizeiptr, RecordOverflow&gt; checkedDataLength(size);</span>
<span class="line-modified">185         Checked&lt;GC3Dintptr, RecordOverflow&gt; checkedReadBufferMax = checkedReadBufferOffset + checkedDataLength;</span>
186         if (checkedReadBufferMax.hasOverflowed() || readOffset &gt; readBuffer.byteLength() || checkedReadBufferMax.unsafeGet() &gt; readBuffer.byteLength())
187             return false;
188 
<span class="line-modified">189         Checked&lt;GC3Dintptr, RecordOverflow&gt; checkedWriteBufferOffset(writeOffset);</span>
<span class="line-modified">190         Checked&lt;GC3Dintptr, RecordOverflow&gt; checkedWriteBufferMax = checkedWriteBufferOffset + checkedDataLength;</span>
191         if (checkedWriteBufferMax.hasOverflowed() || writeOffset &gt; m_byteLength || checkedWriteBufferMax.unsafeGet() &gt; m_byteLength)
192             return false;
193     }
194 
195     switch (m_target) {
<span class="line-modified">196     case GraphicsContext3D::ELEMENT_ARRAY_BUFFER:</span>
197         clearCachedMaxIndices();
198         if (size) {
199             if (!m_elementArrayBuffer)
200                 return false;
201             memcpy(static_cast&lt;unsigned char*&gt;(m_elementArrayBuffer-&gt;data()) + writeOffset, static_cast&lt;const unsigned char*&gt;(readBuffer.elementArrayBuffer()-&gt;data()) + readOffset, size);
202         }
203         return true;
<span class="line-modified">204     case GraphicsContext3D::ARRAY_BUFFER:</span>
205         return true;
206     default:
207 #if ENABLE(WEBGL2)
208         switch (m_target) {
<span class="line-modified">209         case GraphicsContext3D::COPY_READ_BUFFER:</span>
<span class="line-modified">210         case GraphicsContext3D::COPY_WRITE_BUFFER:</span>
<span class="line-modified">211         case GraphicsContext3D::PIXEL_PACK_BUFFER:</span>
<span class="line-modified">212         case GraphicsContext3D::PIXEL_UNPACK_BUFFER:</span>
<span class="line-modified">213         case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER:</span>
<span class="line-modified">214         case GraphicsContext3D::UNIFORM_BUFFER:</span>
215             return true;
216         }
217 #endif
218         return false;
219     }
220 }
221 
222 void WebGLBuffer::disassociateBufferData()
223 {
224     m_byteLength = 0;
225     clearCachedMaxIndices();
226 }
227 
<span class="line-modified">228 GC3Dsizeiptr WebGLBuffer::byteLength() const</span>
229 {
230     return m_byteLength;
231 }
232 
<span class="line-modified">233 Optional&lt;unsigned&gt; WebGLBuffer::getCachedMaxIndex(GC3Denum type)</span>
234 {
235     for (auto&amp; cache : m_maxIndexCache) {
236         if (cache.type == type)
237             return cache.maxIndex;
238     }
239     return WTF::nullopt;
240 }
241 
<span class="line-modified">242 void WebGLBuffer::setCachedMaxIndex(GC3Denum type, unsigned value)</span>
243 {
244     for (auto&amp; cache : m_maxIndexCache) {
245         if (cache.type == type) {
246             cache.maxIndex = value;
247             return;
248         }
249     }
250     m_maxIndexCache[m_nextAvailableCacheEntry].type = type;
251     m_maxIndexCache[m_nextAvailableCacheEntry].maxIndex = value;
252     m_nextAvailableCacheEntry = (m_nextAvailableCacheEntry + 1) % WTF_ARRAY_LENGTH(m_maxIndexCache);
253 }
254 
<span class="line-modified">255 void WebGLBuffer::setTarget(GC3Denum target, bool forWebGL2)</span>
256 {
<span class="line-modified">257     // In WebGL, a buffer is bound to one target in its lifetime</span>
<span class="line-modified">258     if (m_target)</span>
<span class="line-modified">259         return;</span>
<span class="line-modified">260     if (target == GraphicsContext3D::ARRAY_BUFFER || target == GraphicsContext3D::ELEMENT_ARRAY_BUFFER)</span>
<span class="line-modified">261         m_target = target;</span>
<span class="line-removed">262     else if (forWebGL2) {</span>
<span class="line-removed">263 #if ENABLE(WEBGL2)</span>
<span class="line-removed">264         switch (target) {</span>
<span class="line-removed">265         case GraphicsContext3D::COPY_READ_BUFFER:</span>
<span class="line-removed">266         case GraphicsContext3D::COPY_WRITE_BUFFER:</span>
<span class="line-removed">267         case GraphicsContext3D::PIXEL_PACK_BUFFER:</span>
<span class="line-removed">268         case GraphicsContext3D::PIXEL_UNPACK_BUFFER:</span>
<span class="line-removed">269         case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER:</span>
<span class="line-removed">270         case GraphicsContext3D::UNIFORM_BUFFER:</span>
<span class="line-removed">271             m_target = target;</span>
<span class="line-removed">272         }</span>
<span class="line-removed">273 #endif</span>
274     }
275 }
276 
277 void WebGLBuffer::clearCachedMaxIndices()
278 {
279     memset(m_maxIndexCache, 0, sizeof(m_maxIndexCache));
280 }
281 
282 }
283 
284 #endif // ENABLE(WEBGL)
</pre>
</td>
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebGLBuffer.h&quot;
 28 
 29 #if ENABLE(WEBGL)
 30 
 31 #include &quot;WebGLContextGroup.h&quot;
 32 #include &quot;WebGLRenderingContextBase.h&quot;
<span class="line-added"> 33 #include &lt;JavaScriptCore/ArrayBuffer.h&gt;</span>
 34 
 35 namespace WebCore {
 36 
 37 Ref&lt;WebGLBuffer&gt; WebGLBuffer::create(WebGLRenderingContextBase&amp; ctx)
 38 {
 39     return adoptRef(*new WebGLBuffer(ctx));
 40 }
 41 
 42 WebGLBuffer::WebGLBuffer(WebGLRenderingContextBase&amp; ctx)
 43     : WebGLSharedObject(ctx)
 44 {
<span class="line-modified"> 45     setObject(ctx.graphicsContextGL()-&gt;createBuffer());</span>
 46     clearCachedMaxIndices();
 47 }
 48 
 49 WebGLBuffer::~WebGLBuffer()
 50 {
 51     deleteObject(0);
 52 }
 53 
<span class="line-modified"> 54 void WebGLBuffer::deleteObjectImpl(GraphicsContextGLOpenGL* context3d, PlatformGLObject object)</span>
 55 {
 56     context3d-&gt;deleteBuffer(object);
 57 }
 58 
<span class="line-modified"> 59 bool WebGLBuffer::associateBufferDataImpl(const void* data, GCGLsizeiptr byteLength)</span>
 60 {
 61     if (byteLength &lt; 0)
 62         return false;
 63 
 64     switch (m_target) {
<span class="line-modified"> 65     case GraphicsContextGL::ELEMENT_ARRAY_BUFFER:</span>
 66         if (byteLength &gt; std::numeric_limits&lt;unsigned&gt;::max())
 67             return false;
 68         m_byteLength = byteLength;
 69         clearCachedMaxIndices();
 70         if (byteLength) {
 71             m_elementArrayBuffer = ArrayBuffer::tryCreate(byteLength, 1);
 72             if (!m_elementArrayBuffer) {
 73                 m_byteLength = 0;
 74                 return false;
 75             }
 76             if (data) {
 77                 // We must always clone the incoming data because client-side
 78                 // modifications without calling bufferData or bufferSubData
 79                 // must never be able to change the validation results.
 80                 memcpy(m_elementArrayBuffer-&gt;data(), data, byteLength);
 81             }
 82         } else
 83             m_elementArrayBuffer = nullptr;
 84         return true;
<span class="line-modified"> 85     case GraphicsContextGL::ARRAY_BUFFER:</span>
 86         m_byteLength = byteLength;
 87         return true;
 88     default:
 89 #if ENABLE(WEBGL2)
 90         switch (m_target) {
<span class="line-modified"> 91         case GraphicsContextGL::COPY_READ_BUFFER:</span>
<span class="line-modified"> 92         case GraphicsContextGL::COPY_WRITE_BUFFER:</span>
<span class="line-modified"> 93         case GraphicsContextGL::PIXEL_PACK_BUFFER:</span>
<span class="line-modified"> 94         case GraphicsContextGL::PIXEL_UNPACK_BUFFER:</span>
<span class="line-modified"> 95         case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:</span>
<span class="line-modified"> 96         case GraphicsContextGL::UNIFORM_BUFFER:</span>
 97             m_byteLength = byteLength;
 98             return true;
 99         }
100 #endif
101         return false;
102     }
103 }
104 
<span class="line-modified">105 bool WebGLBuffer::associateBufferData(GCGLsizeiptr size)</span>
106 {
107     return associateBufferDataImpl(nullptr, size);
108 }
109 
110 bool WebGLBuffer::associateBufferData(ArrayBuffer* array)
111 {
112     if (!array)
113         return false;
114     return associateBufferDataImpl(array-&gt;data(), array-&gt;byteLength());
115 }
116 
117 bool WebGLBuffer::associateBufferData(ArrayBufferView* array)
118 {
119     if (!array)
120         return false;
121     return associateBufferDataImpl(array-&gt;baseAddress(), array-&gt;byteLength());
122 }
123 
<span class="line-modified">124 bool WebGLBuffer::associateBufferSubDataImpl(GCGLintptr offset, const void* data, GCGLsizeiptr byteLength)</span>
125 {
126     if (!data || offset &lt; 0 || byteLength &lt; 0)
127         return false;
128 
129     if (byteLength) {
<span class="line-modified">130         Checked&lt;GCGLintptr, RecordOverflow&gt; checkedBufferOffset(offset);</span>
<span class="line-modified">131         Checked&lt;GCGLsizeiptr, RecordOverflow&gt; checkedDataLength(byteLength);</span>
<span class="line-modified">132         Checked&lt;GCGLintptr, RecordOverflow&gt; checkedBufferMax = checkedBufferOffset + checkedDataLength;</span>
133         if (checkedBufferMax.hasOverflowed() || offset &gt; m_byteLength || checkedBufferMax.unsafeGet() &gt; m_byteLength)
134             return false;
135     }
136 
137     switch (m_target) {
<span class="line-modified">138     case GraphicsContextGL::ELEMENT_ARRAY_BUFFER:</span>
139         clearCachedMaxIndices();
140         if (byteLength) {
141             if (!m_elementArrayBuffer)
142                 return false;
143             memcpy(static_cast&lt;unsigned char*&gt;(m_elementArrayBuffer-&gt;data()) + offset, data, byteLength);
144         }
145         return true;
<span class="line-modified">146     case GraphicsContextGL::ARRAY_BUFFER:</span>
147         return true;
148     default:
149 #if ENABLE(WEBGL2)
150         switch (m_target) {
<span class="line-modified">151         case GraphicsContextGL::COPY_READ_BUFFER:</span>
<span class="line-modified">152         case GraphicsContextGL::COPY_WRITE_BUFFER:</span>
<span class="line-modified">153         case GraphicsContextGL::PIXEL_PACK_BUFFER:</span>
<span class="line-modified">154         case GraphicsContextGL::PIXEL_UNPACK_BUFFER:</span>
<span class="line-modified">155         case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:</span>
<span class="line-modified">156         case GraphicsContextGL::UNIFORM_BUFFER:</span>
157             return true;
158         }
159 #endif
160         return false;
161     }
162 }
163 
<span class="line-modified">164 bool WebGLBuffer::associateBufferSubData(GCGLintptr offset, ArrayBuffer* array)</span>
165 {
166     if (!array)
167         return false;
168     return associateBufferSubDataImpl(offset, array-&gt;data(), array-&gt;byteLength());
169 }
170 
<span class="line-modified">171 bool WebGLBuffer::associateBufferSubData(GCGLintptr offset, ArrayBufferView* array)</span>
172 {
173     if (!array)
174         return false;
175     return associateBufferSubDataImpl(offset, array-&gt;baseAddress(), array-&gt;byteLength());
176 }
177 
<span class="line-modified">178 bool WebGLBuffer::associateCopyBufferSubData(const WebGLBuffer&amp; readBuffer, GCGLintptr readOffset, GCGLintptr writeOffset, GCGLsizeiptr size)</span>
179 {
180     if (readOffset &lt; 0 || writeOffset &lt; 0 || size &lt; 0)
181         return false;
182 
183     if (size) {
<span class="line-modified">184         Checked&lt;GCGLintptr, RecordOverflow&gt; checkedReadBufferOffset(readOffset);</span>
<span class="line-modified">185         Checked&lt;GCGLsizeiptr, RecordOverflow&gt; checkedDataLength(size);</span>
<span class="line-modified">186         Checked&lt;GCGLintptr, RecordOverflow&gt; checkedReadBufferMax = checkedReadBufferOffset + checkedDataLength;</span>
187         if (checkedReadBufferMax.hasOverflowed() || readOffset &gt; readBuffer.byteLength() || checkedReadBufferMax.unsafeGet() &gt; readBuffer.byteLength())
188             return false;
189 
<span class="line-modified">190         Checked&lt;GCGLintptr, RecordOverflow&gt; checkedWriteBufferOffset(writeOffset);</span>
<span class="line-modified">191         Checked&lt;GCGLintptr, RecordOverflow&gt; checkedWriteBufferMax = checkedWriteBufferOffset + checkedDataLength;</span>
192         if (checkedWriteBufferMax.hasOverflowed() || writeOffset &gt; m_byteLength || checkedWriteBufferMax.unsafeGet() &gt; m_byteLength)
193             return false;
194     }
195 
196     switch (m_target) {
<span class="line-modified">197     case GraphicsContextGL::ELEMENT_ARRAY_BUFFER:</span>
198         clearCachedMaxIndices();
199         if (size) {
200             if (!m_elementArrayBuffer)
201                 return false;
202             memcpy(static_cast&lt;unsigned char*&gt;(m_elementArrayBuffer-&gt;data()) + writeOffset, static_cast&lt;const unsigned char*&gt;(readBuffer.elementArrayBuffer()-&gt;data()) + readOffset, size);
203         }
204         return true;
<span class="line-modified">205     case GraphicsContextGL::ARRAY_BUFFER:</span>
206         return true;
207     default:
208 #if ENABLE(WEBGL2)
209         switch (m_target) {
<span class="line-modified">210         case GraphicsContextGL::COPY_READ_BUFFER:</span>
<span class="line-modified">211         case GraphicsContextGL::COPY_WRITE_BUFFER:</span>
<span class="line-modified">212         case GraphicsContextGL::PIXEL_PACK_BUFFER:</span>
<span class="line-modified">213         case GraphicsContextGL::PIXEL_UNPACK_BUFFER:</span>
<span class="line-modified">214         case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:</span>
<span class="line-modified">215         case GraphicsContextGL::UNIFORM_BUFFER:</span>
216             return true;
217         }
218 #endif
219         return false;
220     }
221 }
222 
223 void WebGLBuffer::disassociateBufferData()
224 {
225     m_byteLength = 0;
226     clearCachedMaxIndices();
227 }
228 
<span class="line-modified">229 GCGLsizeiptr WebGLBuffer::byteLength() const</span>
230 {
231     return m_byteLength;
232 }
233 
<span class="line-modified">234 Optional&lt;unsigned&gt; WebGLBuffer::getCachedMaxIndex(GCGLenum type)</span>
235 {
236     for (auto&amp; cache : m_maxIndexCache) {
237         if (cache.type == type)
238             return cache.maxIndex;
239     }
240     return WTF::nullopt;
241 }
242 
<span class="line-modified">243 void WebGLBuffer::setCachedMaxIndex(GCGLenum type, unsigned value)</span>
244 {
245     for (auto&amp; cache : m_maxIndexCache) {
246         if (cache.type == type) {
247             cache.maxIndex = value;
248             return;
249         }
250     }
251     m_maxIndexCache[m_nextAvailableCacheEntry].type = type;
252     m_maxIndexCache[m_nextAvailableCacheEntry].maxIndex = value;
253     m_nextAvailableCacheEntry = (m_nextAvailableCacheEntry + 1) % WTF_ARRAY_LENGTH(m_maxIndexCache);
254 }
255 
<span class="line-modified">256 void WebGLBuffer::setTarget(GCGLenum target)</span>
257 {
<span class="line-modified">258     m_target = target;</span>
<span class="line-modified">259 </span>
<span class="line-modified">260     if (target == GraphicsContextGL::ARRAY_BUFFER || target == GraphicsContextGL::ELEMENT_ARRAY_BUFFER) {</span>
<span class="line-modified">261         ASSERT(!m_arrayBufferOrElementArrayBuffer || target == m_arrayBufferOrElementArrayBuffer);</span>
<span class="line-modified">262         m_arrayBufferOrElementArrayBuffer = target;</span>












263     }
264 }
265 
266 void WebGLBuffer::clearCachedMaxIndices()
267 {
268     memset(m_maxIndexCache, 0, sizeof(m_maxIndexCache));
269 }
270 
271 }
272 
273 #endif // ENABLE(WEBGL)
</pre>
</td>
</tr>
</table>
<center><a href="WebGLAny.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLBuffer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
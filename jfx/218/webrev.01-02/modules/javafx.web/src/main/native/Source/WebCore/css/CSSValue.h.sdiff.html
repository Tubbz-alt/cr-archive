<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/CSSValue.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSValue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSValueKeywords.in.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/CSSValue.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21 #pragma once
 22 
 23 #include &quot;CSSPropertyNames.h&quot;
 24 #include &lt;wtf/Function.h&gt;
 25 #include &lt;wtf/HashMap.h&gt;
 26 #include &lt;wtf/RefCounted.h&gt;
 27 #include &lt;wtf/RefPtr.h&gt;
 28 #include &lt;wtf/TypeCasts.h&gt;
 29 #include &lt;wtf/URLHash.h&gt;
 30 
 31 namespace WebCore {
 32 
 33 class CSSCustomPropertyValue;
 34 class CSSStyleDeclaration;
 35 class CachedResource;
 36 class DeprecatedCSSOMValue;
 37 class StyleSheetContents;
 38 
 39 enum CSSPropertyID : uint16_t;
 40 
<span class="line-modified"> 41 class CSSValue : public RefCounted&lt;CSSValue&gt; {</span>



 42 public:
 43     enum Type {
 44         CSS_INHERIT = 0,
 45         CSS_PRIMITIVE_VALUE = 1,
 46         CSS_VALUE_LIST = 2,
 47         CSS_CUSTOM = 3,
 48         CSS_INITIAL = 4,
 49         CSS_UNSET = 5,
 50         CSS_REVERT = 6
 51     };
 52 
<span class="line-modified"> 53     // Override RefCounted&#39;s deref() to ensure operator delete is called on</span>
<span class="line-modified"> 54     // the appropriate subclass type.</span>








 55     void deref()
 56     {
<span class="line-modified"> 57         if (derefBase())</span>



 58             destroy();



 59     }
 60 
 61     Type cssValueType() const;
 62     String cssText() const;
 63 
 64     bool isPrimitiveValue() const { return m_classType == PrimitiveClass; }
 65     bool isValueList() const { return m_classType &gt;= ValueListClass; }
 66 
 67     bool isBaseValueList() const { return m_classType == ValueListClass; }
 68 
 69 
 70     bool isAspectRatioValue() const { return m_classType == AspectRatioClass; }
 71     bool isBorderImageSliceValue() const { return m_classType == BorderImageSliceClass; }
 72     bool isCanvasValue() const { return m_classType == CanvasClass; }
 73     bool isCrossfadeValue() const { return m_classType == CrossfadeClass; }
 74     bool isCursorImageValue() const { return m_classType == CursorImageClass; }
 75     bool isCustomPropertyValue() const { return m_classType == CustomPropertyClass; }
 76     bool isFunctionValue() const { return m_classType == FunctionClass; }
 77     bool isFontFeatureValue() const { return m_classType == FontFeatureClass; }
 78 #if ENABLE(VARIATION_FONTS)
</pre>
<hr />
<pre>
195         PendingSubstitutionValueClass,
196 
197         // List class types must appear after ValueListClass. Note CSSFunctionValue
198         // is deliberately excluded, since we don&#39;t want it exposed to the CSS OM
199         // as a list.
200         ValueListClass,
201         ImageSetClass,
202         GridLineNamesClass,
203         GridAutoRepeatClass,
204         GridIntegerRepeatClass,
205         // Do not append non-list class types here.
206     };
207 
208 public:
209     static const size_t ValueListSeparatorBits = 2;
210     enum ValueListSeparator {
211         SpaceSeparator,
212         CommaSeparator,
213         SlashSeparator
214     };

215 
216 protected:
217     ClassType classType() const { return static_cast&lt;ClassType&gt;(m_classType); }
218 
219     explicit CSSValue(ClassType classType)
220         : m_primitiveUnitType(0)
221         , m_hasCachedCSSText(false)
222         , m_isQuirkValue(false)
223         , m_valueListSeparator(SpaceSeparator)
224         , m_classType(classType)
225     {
226     }
227 





228     // NOTE: This class is non-virtual for memory and performance reasons.
229     // Don&#39;t go making it virtual again unless you know exactly what you&#39;re doing!
230 
231     ~CSSValue() = default;
232 
233 private:
234     WEBCORE_EXPORT void destroy();
235 

236 protected:
237     // The bits in this section are only used by specific subclasses but kept here
238     // to maximize struct packing.
<span class="line-removed">239 </span>
240     // CSSPrimitiveValue bits:
<span class="line-modified">241     unsigned m_primitiveUnitType : 7; // CSSPrimitiveValue::UnitType</span>
242     mutable unsigned m_hasCachedCSSText : 1;
243     unsigned m_isQuirkValue : 1;
244 
245     unsigned m_valueListSeparator : ValueListSeparatorBits;
246 
247 private:
248     unsigned m_classType : ClassTypeBits; // ClassType
249 
250 friend class CSSValueList;
251 };
252 
253 template&lt;typename CSSValueType&gt;
254 inline bool compareCSSValueVector(const Vector&lt;Ref&lt;CSSValueType&gt;&gt;&amp; firstVector, const Vector&lt;Ref&lt;CSSValueType&gt;&gt;&amp; secondVector)
255 {
256     size_t size = firstVector.size();
257     if (size != secondVector.size())
258         return false;
259 
260     for (size_t i = 0; i &lt; size; ++i) {
261         auto&amp; firstPtr = firstVector[i];
</pre>
</td>
<td>
<hr />
<pre>
 21 #pragma once
 22 
 23 #include &quot;CSSPropertyNames.h&quot;
 24 #include &lt;wtf/Function.h&gt;
 25 #include &lt;wtf/HashMap.h&gt;
 26 #include &lt;wtf/RefCounted.h&gt;
 27 #include &lt;wtf/RefPtr.h&gt;
 28 #include &lt;wtf/TypeCasts.h&gt;
 29 #include &lt;wtf/URLHash.h&gt;
 30 
 31 namespace WebCore {
 32 
 33 class CSSCustomPropertyValue;
 34 class CSSStyleDeclaration;
 35 class CachedResource;
 36 class DeprecatedCSSOMValue;
 37 class StyleSheetContents;
 38 
 39 enum CSSPropertyID : uint16_t;
 40 
<span class="line-modified"> 41 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(CSSValue);</span>
<span class="line-added"> 42 class CSSValue {</span>
<span class="line-added"> 43     WTF_MAKE_NONCOPYABLE(CSSValue);</span>
<span class="line-added"> 44     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(CSSValue);</span>
 45 public:
 46     enum Type {
 47         CSS_INHERIT = 0,
 48         CSS_PRIMITIVE_VALUE = 1,
 49         CSS_VALUE_LIST = 2,
 50         CSS_CUSTOM = 3,
 51         CSS_INITIAL = 4,
 52         CSS_UNSET = 5,
 53         CSS_REVERT = 6
 54     };
 55 
<span class="line-modified"> 56     static constexpr unsigned refCountFlagIsStatic = 0x1;</span>
<span class="line-modified"> 57     static constexpr unsigned refCountIncrement = 0x2; // This allows us to ref / deref without disturbing the static CSSValue flag.</span>
<span class="line-added"> 58     void ref() const</span>
<span class="line-added"> 59     {</span>
<span class="line-added"> 60         m_refCount += refCountIncrement;</span>
<span class="line-added"> 61     }</span>
<span class="line-added"> 62     bool hasOneRef() const { return m_refCount == refCountIncrement; }</span>
<span class="line-added"> 63     unsigned refCount() const { return m_refCount / refCountIncrement; }</span>
<span class="line-added"> 64     bool hasAtLeastOneRef() const { return m_refCount; }</span>
<span class="line-added"> 65 </span>
 66     void deref()
 67     {
<span class="line-modified"> 68         // Customized deref() to ensure operator delete is called on</span>
<span class="line-added"> 69         // the appropriate subclass type.</span>
<span class="line-added"> 70         unsigned tempRefCount = m_refCount - refCountIncrement;</span>
<span class="line-added"> 71         if (!tempRefCount) {</span>
 72             destroy();
<span class="line-added"> 73             return;</span>
<span class="line-added"> 74         }</span>
<span class="line-added"> 75         m_refCount = tempRefCount;</span>
 76     }
 77 
 78     Type cssValueType() const;
 79     String cssText() const;
 80 
 81     bool isPrimitiveValue() const { return m_classType == PrimitiveClass; }
 82     bool isValueList() const { return m_classType &gt;= ValueListClass; }
 83 
 84     bool isBaseValueList() const { return m_classType == ValueListClass; }
 85 
 86 
 87     bool isAspectRatioValue() const { return m_classType == AspectRatioClass; }
 88     bool isBorderImageSliceValue() const { return m_classType == BorderImageSliceClass; }
 89     bool isCanvasValue() const { return m_classType == CanvasClass; }
 90     bool isCrossfadeValue() const { return m_classType == CrossfadeClass; }
 91     bool isCursorImageValue() const { return m_classType == CursorImageClass; }
 92     bool isCustomPropertyValue() const { return m_classType == CustomPropertyClass; }
 93     bool isFunctionValue() const { return m_classType == FunctionClass; }
 94     bool isFontFeatureValue() const { return m_classType == FontFeatureClass; }
 95 #if ENABLE(VARIATION_FONTS)
</pre>
<hr />
<pre>
212         PendingSubstitutionValueClass,
213 
214         // List class types must appear after ValueListClass. Note CSSFunctionValue
215         // is deliberately excluded, since we don&#39;t want it exposed to the CSS OM
216         // as a list.
217         ValueListClass,
218         ImageSetClass,
219         GridLineNamesClass,
220         GridAutoRepeatClass,
221         GridIntegerRepeatClass,
222         // Do not append non-list class types here.
223     };
224 
225 public:
226     static const size_t ValueListSeparatorBits = 2;
227     enum ValueListSeparator {
228         SpaceSeparator,
229         CommaSeparator,
230         SlashSeparator
231     };
<span class="line-added">232     enum StaticCSSValueTag { StaticCSSValue };</span>
233 
234 protected:
235     ClassType classType() const { return static_cast&lt;ClassType&gt;(m_classType); }
236 
237     explicit CSSValue(ClassType classType)
238         : m_primitiveUnitType(0)
239         , m_hasCachedCSSText(false)
240         , m_isQuirkValue(false)
241         , m_valueListSeparator(SpaceSeparator)
242         , m_classType(classType)
243     {
244     }
245 
<span class="line-added">246     void makeStatic()</span>
<span class="line-added">247     {</span>
<span class="line-added">248         m_refCount |= refCountFlagIsStatic;</span>
<span class="line-added">249     }</span>
<span class="line-added">250 </span>
251     // NOTE: This class is non-virtual for memory and performance reasons.
252     // Don&#39;t go making it virtual again unless you know exactly what you&#39;re doing!
253 
254     ~CSSValue() = default;
255 
256 private:
257     WEBCORE_EXPORT void destroy();
258 
<span class="line-added">259     mutable unsigned m_refCount { refCountIncrement };</span>
260 protected:
261     // The bits in this section are only used by specific subclasses but kept here
262     // to maximize struct packing.

263     // CSSPrimitiveValue bits:
<span class="line-modified">264     unsigned m_primitiveUnitType : 7; // CSSUnitType</span>
265     mutable unsigned m_hasCachedCSSText : 1;
266     unsigned m_isQuirkValue : 1;
267 
268     unsigned m_valueListSeparator : ValueListSeparatorBits;
269 
270 private:
271     unsigned m_classType : ClassTypeBits; // ClassType
272 
273 friend class CSSValueList;
274 };
275 
276 template&lt;typename CSSValueType&gt;
277 inline bool compareCSSValueVector(const Vector&lt;Ref&lt;CSSValueType&gt;&gt;&amp; firstVector, const Vector&lt;Ref&lt;CSSValueType&gt;&gt;&amp; secondVector)
278 {
279     size_t size = firstVector.size();
280     if (size != secondVector.size())
281         return false;
282 
283     for (size_t i = 0; i &lt; size; ++i) {
284         auto&amp; firstPtr = firstVector[i];
</pre>
</td>
</tr>
</table>
<center><a href="CSSValue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSValueKeywords.in.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
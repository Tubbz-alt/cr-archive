<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/svg/SVGGraphicsElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2004, 2005, 2008 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  3  * Copyright (C) 2004, 2005, 2006 Rob Buis &lt;buis@kde.org&gt;
  4  * Copyright (C) 2018 Apple Inc. All rights reserved.
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB.  If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;SVGGraphicsElement.h&quot;
 24 
 25 #include &quot;RenderSVGPath.h&quot;
 26 #include &quot;RenderSVGResource.h&quot;
 27 #include &quot;SVGMatrix.h&quot;
 28 #include &quot;SVGNames.h&quot;
 29 #include &quot;SVGPathData.h&quot;
 30 #include &quot;SVGRect.h&quot;
 31 #include &quot;SVGSVGElement.h&quot;
 32 #include &quot;SVGStringList.h&quot;
 33 #include &lt;wtf/IsoMallocInlines.h&gt;
 34 #include &lt;wtf/NeverDestroyed.h&gt;
 35 
 36 namespace WebCore {
 37 
 38 WTF_MAKE_ISO_ALLOCATED_IMPL(SVGGraphicsElement);
 39 
 40 SVGGraphicsElement::SVGGraphicsElement(const QualifiedName&amp; tagName, Document&amp; document)
 41     : SVGElement(tagName, document)
 42     , SVGTests(this)
 43     , m_shouldIsolateBlending(false)
 44 {
 45     static std::once_flag onceFlag;
 46     std::call_once(onceFlag, [] {
 47         PropertyRegistry::registerProperty&lt;SVGNames::transformAttr, &amp;SVGGraphicsElement::m_transform&gt;();
 48     });
 49 }
 50 
 51 SVGGraphicsElement::~SVGGraphicsElement() = default;
 52 
 53 Ref&lt;SVGMatrix&gt; SVGGraphicsElement::getCTMForBindings()
 54 {
 55     return SVGMatrix::create(getCTM());
 56 }
 57 
 58 AffineTransform SVGGraphicsElement::getCTM(StyleUpdateStrategy styleUpdateStrategy)
 59 {
 60     return SVGLocatable::computeCTM(this, SVGLocatable::NearestViewportScope, styleUpdateStrategy);
 61 }
 62 
 63 Ref&lt;SVGMatrix&gt; SVGGraphicsElement::getScreenCTMForBindings()
 64 {
 65     return SVGMatrix::create(getScreenCTM());
 66 }
 67 
 68 AffineTransform SVGGraphicsElement::getScreenCTM(StyleUpdateStrategy styleUpdateStrategy)
 69 {
 70     return SVGLocatable::computeCTM(this, SVGLocatable::ScreenScope, styleUpdateStrategy);
 71 }
 72 
 73 AffineTransform SVGGraphicsElement::animatedLocalTransform() const
 74 {
 75     AffineTransform matrix;
 76     auto* style = renderer() ? &amp;renderer()-&gt;style() : nullptr;
 77 
 78     // If CSS property was set, use that, otherwise fallback to attribute (if set).
 79     if (style &amp;&amp; style-&gt;hasTransform()) {
 80 
 81         FloatRect boundingBox;
 82         switch (style-&gt;transformBox()) {
<a name="1" id="anc1"></a><span class="line-added"> 83         case TransformBox::BorderBox:</span>
<span class="line-added"> 84             // For SVG elements without an associated CSS layout box, the used value for border-box is stroke-box.</span>
<span class="line-added"> 85         case TransformBox::StrokeBox:</span>
<span class="line-added"> 86             boundingBox = renderer()-&gt;strokeBoundingBox();</span>
<span class="line-added"> 87             break;</span>
<span class="line-added"> 88         case TransformBox::ContentBox:</span>
<span class="line-added"> 89             // For SVG elements without an associated CSS layout box, the used value for content-box is fill-box.</span>
 90         case TransformBox::FillBox:
 91             boundingBox = renderer()-&gt;objectBoundingBox();
 92             break;
<a name="2" id="anc2"></a>

 93         case TransformBox::ViewBox: {
 94             FloatSize viewportSize;
 95             SVGLengthContext(this).determineViewport(viewportSize);
 96             boundingBox.setSize(viewportSize);
 97             break;
 98             }
 99         }
100 
101         // Note: objectBoundingBox is an emptyRect for elements like pattern or clipPath.
102         // See the &quot;Object bounding box units&quot; section of http://dev.w3.org/csswg/css3-transforms/
103         TransformationMatrix transform;
104         style-&gt;applyTransform(transform, boundingBox);
105 
106         // Flatten any 3D transform.
107         matrix = transform.toAffineTransform();
108         // CSS bakes the zoom factor into lengths, including translation components.
109         // In order to align CSS &amp; SVG transforms, we need to invert this operation.
110         float zoom = style-&gt;effectiveZoom();
111         if (zoom != 1) {
112             matrix.setE(matrix.e() / zoom);
113             matrix.setF(matrix.f() / zoom);
114         }
115 
116     } else
117         matrix = transform().concatenate();
118 
119     if (m_supplementalTransform)
120         return *m_supplementalTransform * matrix;
121     return matrix;
122 }
123 
124 AffineTransform* SVGGraphicsElement::supplementalTransform()
125 {
126     if (!m_supplementalTransform)
127         m_supplementalTransform = makeUnique&lt;AffineTransform&gt;();
128     return m_supplementalTransform.get();
129 }
130 
131 void SVGGraphicsElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
132 {
133     if (name == SVGNames::transformAttr) {
134         m_transform-&gt;baseVal()-&gt;parse(value);
135         return;
136     }
137 
138     SVGElement::parseAttribute(name, value);
139     SVGTests::parseAttribute(name, value);
140 }
141 
142 void SVGGraphicsElement::svgAttributeChanged(const QualifiedName&amp; attrName)
143 {
144     if (attrName == SVGNames::transformAttr) {
145         InstanceInvalidationGuard guard(*this);
146 
147         if (auto renderer = this-&gt;renderer()) {
148             renderer-&gt;setNeedsTransformUpdate();
149             RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer);
150         }
151 
152         return;
153     }
154 
155     SVGElement::svgAttributeChanged(attrName);
156     SVGTests::svgAttributeChanged(attrName);
157 }
158 
159 SVGElement* SVGGraphicsElement::nearestViewportElement() const
160 {
161     return SVGTransformable::nearestViewportElement(this);
162 }
163 
164 SVGElement* SVGGraphicsElement::farthestViewportElement() const
165 {
166     return SVGTransformable::farthestViewportElement(this);
167 }
168 
169 Ref&lt;SVGRect&gt; SVGGraphicsElement::getBBoxForBindings()
170 {
171     return SVGRect::create(getBBox());
172 }
173 
174 FloatRect SVGGraphicsElement::getBBox(StyleUpdateStrategy styleUpdateStrategy)
175 {
176     return SVGTransformable::getBBox(this, styleUpdateStrategy);
177 }
178 
179 RenderPtr&lt;RenderElement&gt; SVGGraphicsElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
180 {
181     return createRenderer&lt;RenderSVGPath&gt;(*this, WTFMove(style));
182 }
183 
184 Path SVGGraphicsElement::toClipPath()
185 {
186     Path path = pathFromGraphicsElement(this);
187     // FIXME: How do we know the element has done a layout?
188     path.transform(animatedLocalTransform());
189     return path;
190 }
191 
192 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
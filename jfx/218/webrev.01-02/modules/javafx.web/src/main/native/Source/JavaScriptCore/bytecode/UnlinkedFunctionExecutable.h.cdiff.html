<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedFunctionExecutable.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="UnlinkedFunctionExecutable.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UnlinkedMetadataTable.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedFunctionExecutable.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,16 ***</span>
<span class="line-new-header">--- 25,18 ---</span>
  
  #pragma once
  
  #include &quot;CodeSpecializationKind.h&quot;
  #include &quot;ConstructAbility.h&quot;
<span class="line-added">+ #include &quot;ConstructorKind.h&quot;</span>
  #include &quot;ExecutableInfo.h&quot;
  #include &quot;ExpressionRangeInfo.h&quot;
  #include &quot;Identifier.h&quot;
  #include &quot;Intrinsic.h&quot;
  #include &quot;JSCast.h&quot;
  #include &quot;ParserModes.h&quot;
<span class="line-added">+ #include &quot;ParserTokens.h&quot;</span>
  #include &quot;RegExp.h&quot;
  #include &quot;SourceCode.h&quot;
  #include &quot;VariableEnvironment.h&quot;
  #include &lt;wtf/Optional.h&gt;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 58,22 ***</span>
      friend class CodeCache;
      friend class VM;
      friend class CachedFunctionExecutable;
  
      typedef JSCell Base;
<span class="line-modified">!     static const unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;</span>
  
      template&lt;typename CellType, SubspaceAccess&gt;
      static IsoSubspace* subspaceFor(VM&amp; vm)
      {
          return &amp;vm.unlinkedFunctionExecutableSpace.space;
      }
  
<span class="line-modified">!     static UnlinkedFunctionExecutable* create(VM&amp; vm, const SourceCode&amp; source, FunctionMetadataNode* node, UnlinkedFunctionKind unlinkedFunctionKind, ConstructAbility constructAbility, JSParserScriptMode scriptMode, Optional&lt;CompactVariableMap::Handle&gt; parentScopeTDZVariables, DerivedContextType derivedContextType, bool isBuiltinDefaultClassConstructor = false)</span>
      {
          UnlinkedFunctionExecutable* instance = new (NotNull, allocateCell&lt;UnlinkedFunctionExecutable&gt;(vm.heap))
<span class="line-modified">!             UnlinkedFunctionExecutable(vm, vm.unlinkedFunctionExecutableStructure.get(), source, node, unlinkedFunctionKind, constructAbility, scriptMode, WTFMove(parentScopeTDZVariables), derivedContextType, isBuiltinDefaultClassConstructor);</span>
          instance-&gt;finishCreation(vm);
          return instance;
      }
  
      ~UnlinkedFunctionExecutable();
<span class="line-new-header">--- 60,22 ---</span>
      friend class CodeCache;
      friend class VM;
      friend class CachedFunctionExecutable;
  
      typedef JSCell Base;
<span class="line-modified">!     static constexpr unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;</span>
  
      template&lt;typename CellType, SubspaceAccess&gt;
      static IsoSubspace* subspaceFor(VM&amp; vm)
      {
          return &amp;vm.unlinkedFunctionExecutableSpace.space;
      }
  
<span class="line-modified">!     static UnlinkedFunctionExecutable* create(VM&amp; vm, const SourceCode&amp; source, FunctionMetadataNode* node, UnlinkedFunctionKind unlinkedFunctionKind, ConstructAbility constructAbility, JSParserScriptMode scriptMode, Optional&lt;CompactVariableMap::Handle&gt; parentScopeTDZVariables, DerivedContextType derivedContextType, NeedsClassFieldInitializer needsClassFieldInitializer, bool isBuiltinDefaultClassConstructor = false)</span>
      {
          UnlinkedFunctionExecutable* instance = new (NotNull, allocateCell&lt;UnlinkedFunctionExecutable&gt;(vm.heap))
<span class="line-modified">!             UnlinkedFunctionExecutable(vm, vm.unlinkedFunctionExecutableStructure.get(), source, node, unlinkedFunctionKind, constructAbility, scriptMode, WTFMove(parentScopeTDZVariables), derivedContextType, needsClassFieldInitializer, isBuiltinDefaultClassConstructor);</span>
          instance-&gt;finishCreation(vm);
          return instance;
      }
  
      ~UnlinkedFunctionExecutable();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 117,11 ***</span>
      UnlinkedFunctionCodeBlock* unlinkedCodeBlockFor(
          VM&amp;, const SourceCode&amp;, CodeSpecializationKind, OptionSet&lt;CodeGenerationMode&gt;,
          ParserError&amp;, SourceParseMode);
  
      static UnlinkedFunctionExecutable* fromGlobalCode(
<span class="line-modified">!         const Identifier&amp;, ExecState&amp;, const SourceCode&amp;, JSObject*&amp; exception,</span>
          int overrideLineNumber, Optional&lt;int&gt; functionConstructorParametersEndPosition);
  
      SourceCode linkedSourceCode(const SourceCode&amp;) const;
      JS_EXPORT_PRIVATE FunctionExecutable* link(VM&amp;, ScriptExecutable* topLevelExecutable, const SourceCode&amp; parentSource, Optional&lt;int&gt; overrideLineNumber = WTF::nullopt, Intrinsic = NoIntrinsic);
  
<span class="line-new-header">--- 119,11 ---</span>
      UnlinkedFunctionCodeBlock* unlinkedCodeBlockFor(
          VM&amp;, const SourceCode&amp;, CodeSpecializationKind, OptionSet&lt;CodeGenerationMode&gt;,
          ParserError&amp;, SourceParseMode);
  
      static UnlinkedFunctionExecutable* fromGlobalCode(
<span class="line-modified">!         const Identifier&amp;, JSGlobalObject*, const SourceCode&amp;, JSObject*&amp; exception,</span>
          int overrideLineNumber, Optional&lt;int&gt; functionConstructorParametersEndPosition);
  
      SourceCode linkedSourceCode(const SourceCode&amp;) const;
      JS_EXPORT_PRIVATE FunctionExecutable* link(VM&amp;, ScriptExecutable* topLevelExecutable, const SourceCode&amp; parentSource, Optional&lt;int&gt; overrideLineNumber = WTF::nullopt, Intrinsic = NoIntrinsic);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 139,18 ***</span>
      }
  
      CodeFeatures features() const { return m_features; }
      bool hasCapturedVariables() const { return m_hasCapturedVariables; }
  
<span class="line-modified">!     static const bool needsDestruction = true;</span>
      static void destroy(JSCell*);
  
      bool isBuiltinFunction() const { return m_isBuiltinFunction; }
<span class="line-removed">-     bool isAnonymousBuiltinFunction() const { return isBuiltinFunction() &amp;&amp; name().isPrivateName(); }</span>
      ConstructAbility constructAbility() const { return static_cast&lt;ConstructAbility&gt;(m_constructAbility); }
      JSParserScriptMode scriptMode() const { return static_cast&lt;JSParserScriptMode&gt;(m_scriptMode); }
<span class="line-modified">!     bool isClassConstructorFunction() const { return constructorKind() != ConstructorKind::None; }</span>
      bool isClass() const
      {
          if (!m_rareData)
              return false;
          return !m_rareData-&gt;m_classSource.isNull();
<span class="line-new-header">--- 141,28 ---</span>
      }
  
      CodeFeatures features() const { return m_features; }
      bool hasCapturedVariables() const { return m_hasCapturedVariables; }
  
<span class="line-modified">!     static constexpr bool needsDestruction = true;</span>
      static void destroy(JSCell*);
  
      bool isBuiltinFunction() const { return m_isBuiltinFunction; }
      ConstructAbility constructAbility() const { return static_cast&lt;ConstructAbility&gt;(m_constructAbility); }
      JSParserScriptMode scriptMode() const { return static_cast&lt;JSParserScriptMode&gt;(m_scriptMode); }
<span class="line-modified">!     bool isClassConstructorFunction() const</span>
<span class="line-added">+     {</span>
<span class="line-added">+         switch (constructorKind()) {</span>
<span class="line-added">+         case ConstructorKind::None:</span>
<span class="line-added">+         case ConstructorKind::Naked:</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         case ConstructorKind::Base:</span>
<span class="line-added">+         case ConstructorKind::Extends:</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     }</span>
      bool isClass() const
      {
          if (!m_rareData)
              return false;
          return !m_rareData-&gt;m_classSource.isNull();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 195,14 ***</span>
  
          SourceCode m_classSource;
          String m_sourceURLDirective;
          String m_sourceMappingURLDirective;
          CompactVariableMap::Handle m_parentScopeTDZVariables;
      };
  
  private:
<span class="line-modified">!     UnlinkedFunctionExecutable(VM&amp;, Structure*, const SourceCode&amp;, FunctionMetadataNode*, UnlinkedFunctionKind, ConstructAbility, JSParserScriptMode, Optional&lt;CompactVariableMap::Handle&gt;,  JSC::DerivedContextType, bool isBuiltinDefaultClassConstructor);</span>
      UnlinkedFunctionExecutable(Decoder&amp;, const CachedFunctionExecutable&amp;);
  
      void decodeCachedCodeBlocks(VM&amp;);
  
      bool codeBlockEdgeMayBeWeak() const
<span class="line-new-header">--- 207,31 ---</span>
  
          SourceCode m_classSource;
          String m_sourceURLDirective;
          String m_sourceMappingURLDirective;
          CompactVariableMap::Handle m_parentScopeTDZVariables;
<span class="line-added">+         Vector&lt;JSTextPosition&gt; m_instanceFieldLocations;</span>
      };
  
<span class="line-added">+     NeedsClassFieldInitializer needsClassFieldInitializer() const { return static_cast&lt;NeedsClassFieldInitializer&gt;(m_needsClassFieldInitializer); }</span>
<span class="line-added">+ </span>
<span class="line-added">+     Vector&lt;JSTextPosition&gt;* instanceFieldLocations() const</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (m_rareData)</span>
<span class="line-added">+             return &amp;m_rareData-&gt;m_instanceFieldLocations;</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void setInstanceFieldLocations(Vector&lt;JSTextPosition&gt;&amp;&amp; instanceFieldLocations)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (instanceFieldLocations.isEmpty())</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         ensureRareData().m_instanceFieldLocations = WTFMove(instanceFieldLocations);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
  private:
<span class="line-modified">!     UnlinkedFunctionExecutable(VM&amp;, Structure*, const SourceCode&amp;, FunctionMetadataNode*, UnlinkedFunctionKind, ConstructAbility, JSParserScriptMode, Optional&lt;CompactVariableMap::Handle&gt;,  JSC::DerivedContextType, JSC::NeedsClassFieldInitializer, bool isBuiltinDefaultClassConstructor);</span>
      UnlinkedFunctionExecutable(Decoder&amp;, const CachedFunctionExecutable&amp;);
  
      void decodeCachedCodeBlocks(VM&amp;);
  
      bool codeBlockEdgeMayBeWeak() const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 235,10 ***</span>
<span class="line-new-header">--- 264,11 ---</span>
      SourceParseMode m_sourceParseMode;
      unsigned m_constructorKind : 2;
      unsigned m_functionMode : 2; // FunctionMode
      unsigned m_derivedContextType: 2;
      unsigned m_isGeneratedFromCache : 1;
<span class="line-added">+     unsigned m_needsClassFieldInitializer : 1;</span>
  
      union {
          WriteBarrier&lt;UnlinkedFunctionCodeBlock&gt; m_unlinkedCodeBlockForCall;
          RefPtr&lt;Decoder&gt; m_decoder;
      };
</pre>
<center><a href="UnlinkedFunctionExecutable.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UnlinkedMetadataTable.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
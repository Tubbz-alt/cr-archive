<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorStyleSheet.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorShaderProgram.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InspectorStyleSheet.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorStyleSheet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;InspectorStyleSheet.h&quot;
  27 
  28 #include &quot;CSSImportRule.h&quot;
  29 #include &quot;CSSKeyframesRule.h&quot;
  30 #include &quot;CSSMediaRule.h&quot;
  31 #include &quot;CSSParser.h&quot;
  32 #include &quot;CSSParserObserver.h&quot;
  33 #include &quot;CSSPropertyNames.h&quot;
  34 #include &quot;CSSPropertyParser.h&quot;
  35 #include &quot;CSSPropertySourceData.h&quot;
  36 #include &quot;CSSRule.h&quot;
  37 #include &quot;CSSRuleList.h&quot;
  38 #include &quot;CSSStyleRule.h&quot;
  39 #include &quot;CSSStyleSheet.h&quot;
  40 #include &quot;CSSSupportsRule.h&quot;
  41 #include &quot;ContentSecurityPolicy.h&quot;
  42 #include &quot;Document.h&quot;
  43 #include &quot;Element.h&quot;

  44 #include &quot;HTMLHeadElement.h&quot;
  45 #include &quot;HTMLNames.h&quot;
  46 #include &quot;HTMLParserIdioms.h&quot;
  47 #include &quot;HTMLStyleElement.h&quot;
  48 #include &quot;InspectorCSSAgent.h&quot;
  49 #include &quot;InspectorDOMAgent.h&quot;
  50 #include &quot;InspectorPageAgent.h&quot;
  51 #include &quot;MediaList.h&quot;
  52 #include &quot;Node.h&quot;
  53 #include &quot;SVGElement.h&quot;
  54 #include &quot;SVGStyleElement.h&quot;
  55 #include &quot;StyleProperties.h&quot;
  56 #include &quot;StyleResolver.h&quot;
  57 #include &quot;StyleRule.h&quot;
  58 #include &quot;StyleRuleImport.h&quot;
  59 #include &quot;StyleSheetContents.h&quot;
  60 #include &quot;StyleSheetList.h&quot;
  61 #include &lt;JavaScriptCore/ContentSearchUtilities.h&gt;
  62 #include &lt;JavaScriptCore/RegularExpression.h&gt;
  63 #include &lt;wtf/text/StringBuilder.h&gt;
</pre>
<hr />
<pre>
  84     String m_text;
  85     bool m_hasText;
  86     std::unique_ptr&lt;RuleSourceDataList&gt; m_sourceData;
  87 };
  88 
  89 ParsedStyleSheet::ParsedStyleSheet()
  90     : m_hasText(false)
  91 {
  92 }
  93 
  94 void ParsedStyleSheet::setText(const String&amp; text)
  95 {
  96     m_hasText = true;
  97     m_text = text;
  98     setSourceData(nullptr);
  99 }
 100 
 101 static void flattenSourceData(RuleSourceDataList&amp; dataList, RuleSourceDataList&amp; target)
 102 {
 103     for (auto&amp; data : dataList) {
<span class="line-modified"> 104         if (data-&gt;type == WebCore::StyleRule::Style)</span>
 105             target.append(data.copyRef());
<span class="line-modified"> 106         else if (data-&gt;type == WebCore::StyleRule::Media)</span>
 107             flattenSourceData(data-&gt;childRules, target);
<span class="line-modified"> 108         else if (data-&gt;type == WebCore::StyleRule::Supports)</span>
 109             flattenSourceData(data-&gt;childRules, target);
 110     }
 111 }
 112 
 113 void ParsedStyleSheet::setSourceData(std::unique_ptr&lt;RuleSourceDataList&gt; sourceData)
 114 {
 115     if (!sourceData) {
 116         m_sourceData.reset();
 117         return;
 118     }
 119 
 120     m_sourceData = makeUnique&lt;RuleSourceDataList&gt;();
 121 
 122     // FIXME: This is a temporary solution to retain the original flat sourceData structure
 123     // containing only style rules, even though CSSParser now provides the full rule source data tree.
 124     // Normally, we should just assign m_sourceData = sourceData;
 125     flattenSourceData(*sourceData, *m_sourceData);
 126 }
 127 
 128 WebCore::CSSRuleSourceData* ParsedStyleSheet::ruleSourceDataAt(unsigned index) const
</pre>
<hr />
<pre>
 137 namespace WebCore {
 138 
 139 using namespace Inspector;
 140 
 141 static CSSParserContext parserContextForDocument(Document* document)
 142 {
 143     return document ? CSSParserContext(*document) : strictCSSParserContext();
 144 }
 145 
 146 class StyleSheetHandler : public CSSParserObserver {
 147 public:
 148     StyleSheetHandler(const String&amp; parsedText, Document* document, RuleSourceDataList* result)
 149         : m_parsedText(parsedText)
 150         , m_document(document)
 151         , m_ruleSourceDataResult(result)
 152     {
 153         ASSERT(m_ruleSourceDataResult);
 154     }
 155 
 156 private:
<span class="line-modified"> 157     void startRuleHeader(StyleRule::Type, unsigned) override;</span>
 158     void endRuleHeader(unsigned) override;
 159     void observeSelector(unsigned startOffset, unsigned endOffset) override;
 160     void startRuleBody(unsigned) override;
 161     void endRuleBody(unsigned) override;
 162     void observeProperty(unsigned startOffset, unsigned endOffset, bool isImportant, bool isParsed) override;
 163     void observeComment(unsigned startOffset, unsigned endOffset) override;
 164 
 165     Ref&lt;CSSRuleSourceData&gt; popRuleData();
 166     template &lt;typename CharacterType&gt; inline void setRuleHeaderEnd(const CharacterType*, unsigned);
 167     void fixUnparsedPropertyRanges(CSSRuleSourceData*);
 168 
 169     const String&amp; m_parsedText;
 170     Document* m_document;
 171 
 172     RuleSourceDataList m_currentRuleDataStack;
 173     RefPtr&lt;CSSRuleSourceData&gt; m_currentRuleData;
 174     RuleSourceDataList* m_ruleSourceDataResult { nullptr };
 175 };
 176 
<span class="line-modified"> 177 void StyleSheetHandler::startRuleHeader(StyleRule::Type type, unsigned offset)</span>
 178 {
 179     // Pop off data for a previous invalid rule.
 180     if (m_currentRuleData)
 181         m_currentRuleDataStack.removeLast();
 182 
 183     auto data = CSSRuleSourceData::create(type);
 184     data-&gt;ruleHeaderRange.start = offset;
 185     m_currentRuleData = data.copyRef();
 186     m_currentRuleDataStack.append(WTFMove(data));
 187 }
 188 
 189 template &lt;typename CharacterType&gt; inline void StyleSheetHandler::setRuleHeaderEnd(const CharacterType* dataStart, unsigned listEndOffset)
 190 {
 191     while (listEndOffset &gt; 1) {
 192         if (isHTMLSpace&lt;CharacterType&gt;(*(dataStart + listEndOffset - 1)))
 193             --listEndOffset;
 194         else
 195             break;
 196     }
 197 
</pre>
<hr />
<pre>
 524 
 525 RefPtr&lt;Inspector::Protocol::CSS::CSSStyle&gt; InspectorStyle::buildObjectForStyle() const
 526 {
 527     Ref&lt;Inspector::Protocol::CSS::CSSStyle&gt; result = styleWithProperties();
 528     if (!m_styleId.isEmpty())
 529         result-&gt;setStyleId(m_styleId.asProtocolValue&lt;Inspector::Protocol::CSS::CSSStyleId&gt;());
 530 
 531     result-&gt;setWidth(m_style-&gt;getPropertyValue(&quot;width&quot;));
 532     result-&gt;setHeight(m_style-&gt;getPropertyValue(&quot;height&quot;));
 533 
 534     RefPtr&lt;CSSRuleSourceData&gt; sourceData = extractSourceData();
 535     if (sourceData)
 536         result-&gt;setRange(buildSourceRangeObject(sourceData-&gt;ruleBodyRange, m_parentStyleSheet-&gt;lineEndings()));
 537 
 538     return result;
 539 }
 540 
 541 Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSComputedStyleProperty&gt;&gt; InspectorStyle::buildArrayForComputedStyle() const
 542 {
 543     auto result = JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSComputedStyleProperty&gt;::create();
<span class="line-modified"> 544     Vector&lt;InspectorStyleProperty&gt; properties;</span>
<span class="line-removed"> 545     populateAllProperties(&amp;properties);</span>
<span class="line-removed"> 546 </span>
<span class="line-removed"> 547     for (auto&amp; property : properties) {</span>
 548         const CSSPropertySourceData&amp; propertyEntry = property.sourceData;
 549         auto entry = Inspector::Protocol::CSS::CSSComputedStyleProperty::create()
 550             .setName(propertyEntry.name)
 551             .setValue(propertyEntry.value)
 552             .release();
 553         result-&gt;addItem(WTFMove(entry));
 554     }
<span class="line-removed"> 555 </span>
 556     return result;
 557 }
 558 
 559 ExceptionOr&lt;String&gt; InspectorStyle::text() const
 560 {
 561     // Precondition: m_parentStyleSheet-&gt;ensureParsedDataReady() has been called successfully.
 562     auto sourceData = extractSourceData();
 563     if (!sourceData)
 564         return Exception { NotFoundError };
 565 
 566     auto result = m_parentStyleSheet-&gt;text();
 567     if (result.hasException())
 568         return result.releaseException();
 569 
 570     auto&amp; bodyRange = sourceData-&gt;ruleBodyRange;
 571     return result.releaseReturnValue().substring(bodyRange.start, bodyRange.end - bodyRange.start);
 572 }
 573 
 574 static String lowercasePropertyName(const String&amp; name)
 575 {
 576     // Custom properties are case-sensitive.
 577     if (name.startsWith(&quot;--&quot;))
 578         return name;
 579     return name.convertToASCIILowercase();
 580 }
 581 
<span class="line-modified"> 582 void InspectorStyle::populateAllProperties(Vector&lt;InspectorStyleProperty&gt;* result) const</span>
 583 {

 584     HashSet&lt;String&gt; sourcePropertyNames;
 585 
 586     auto sourceData = extractSourceData();
 587     auto* sourcePropertyData = sourceData ? &amp;sourceData-&gt;styleSourceData-&gt;propertyData : nullptr;
 588     if (sourcePropertyData) {
 589         auto styleDeclarationOrException = text();
 590         ASSERT(!styleDeclarationOrException.hasException());
 591         String styleDeclaration = styleDeclarationOrException.hasException() ? emptyString() : styleDeclarationOrException.releaseReturnValue();
 592         for (auto&amp; sourceData : *sourcePropertyData) {
 593             InspectorStyleProperty p(sourceData, true, sourceData.disabled);
 594             p.setRawTextFromStyleDeclaration(styleDeclaration);
<span class="line-modified"> 595             result-&gt;append(p);</span>
 596             sourcePropertyNames.add(lowercasePropertyName(sourceData.name));
 597         }
 598     }
 599 
 600     for (int i = 0, size = m_style-&gt;length(); i &lt; size; ++i) {
 601         String name = m_style-&gt;item(i);
 602         if (sourcePropertyNames.add(lowercasePropertyName(name)))
<span class="line-modified"> 603             result-&gt;append(InspectorStyleProperty(CSSPropertySourceData(name, m_style-&gt;getPropertyValue(name), !m_style-&gt;getPropertyPriority(name).isEmpty(), false, true, SourceRange()), false, false));</span>
 604     }




















 605 }
 606 
 607 Ref&lt;Inspector::Protocol::CSS::CSSStyle&gt; InspectorStyle::styleWithProperties() const
 608 {
<span class="line-modified"> 609     Vector&lt;InspectorStyleProperty&gt; properties;</span>
<span class="line-removed"> 610     populateAllProperties(&amp;properties);</span>
 611 
 612     auto propertiesObject = JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSProperty&gt;::create();
 613     auto shorthandEntries = ArrayOf&lt;Inspector::Protocol::CSS::ShorthandEntry&gt;::create();
 614     HashMap&lt;String, RefPtr&lt;Inspector::Protocol::CSS::CSSProperty&gt;&gt; propertyNameToPreviousActiveProperty;
 615     HashSet&lt;String&gt; foundShorthands;
 616     String previousPriority;
 617     String previousStatus;
 618     Vector&lt;size_t&gt; lineEndings = m_parentStyleSheet ? m_parentStyleSheet-&gt;lineEndings() : Vector&lt;size_t&gt; { };
 619     auto sourceData = extractSourceData();
 620     unsigned ruleBodyRangeStart = sourceData ? sourceData-&gt;ruleBodyRange.start : 0;
 621 
 622     for (Vector&lt;InspectorStyleProperty&gt;::iterator it = properties.begin(), itEnd = properties.end(); it != itEnd; ++it) {
 623         const CSSPropertySourceData&amp; propertyEntry = it-&gt;sourceData;
 624         const String&amp; name = propertyEntry.name;
 625 
 626         auto status = it-&gt;disabled ? Inspector::Protocol::CSS::CSSPropertyStatus::Disabled : Inspector::Protocol::CSS::CSSPropertyStatus::Active;
 627 
 628         auto property = Inspector::Protocol::CSS::CSSProperty::create()
 629             .setName(name.convertToASCIILowercase())
 630             .setValue(propertyEntry.value)
</pre>
<hr />
<pre>
1134         .release();
1135     if (sourceData)
1136         result-&gt;setRange(buildSourceRangeObject(sourceData-&gt;ruleHeaderRange, lineEndings(), &amp;endingLine));
1137     return result;
1138 }
1139 
1140 RefPtr&lt;Inspector::Protocol::CSS::CSSRule&gt; InspectorStyleSheet::buildObjectForRule(CSSStyleRule* rule, Element* element)
1141 {
1142     CSSStyleSheet* styleSheet = pageStyleSheet();
1143     if (!styleSheet)
1144         return nullptr;
1145 
1146     int endingLine = 0;
1147     auto result = Inspector::Protocol::CSS::CSSRule::create()
1148         .setSelectorList(buildObjectForSelectorList(rule, element, endingLine))
1149         .setSourceLine(endingLine)
1150         .setOrigin(m_origin)
1151         .setStyle(buildObjectForStyle(&amp;rule-&gt;style()))
1152         .release();
1153 
<span class="line-modified">1154     // &quot;sourceURL&quot; is present only for regular rules, otherwise &quot;origin&quot; should be used in the frontend.</span>
<span class="line-removed">1155     if (m_origin == Inspector::Protocol::CSS::StyleSheetOrigin::Regular)</span>
1156         result-&gt;setSourceURL(finalURL());
1157 
1158     if (canBind()) {
1159         InspectorCSSId id(ruleId(rule));
1160         if (!id.isEmpty())
1161             result-&gt;setRuleId(id.asProtocolValue&lt;Inspector::Protocol::CSS::CSSRuleId&gt;());
1162     }
1163 
1164     auto groupingsPayload = buildArrayForGroupings(*rule);
1165     if (groupingsPayload-&gt;length())
1166         result-&gt;setGroupings(WTFMove(groupingsPayload));
1167 
1168     return result;
1169 }
1170 
1171 RefPtr&lt;Inspector::Protocol::CSS::CSSStyle&gt; InspectorStyleSheet::buildObjectForStyle(CSSStyleDeclaration* style)
1172 {
1173     RefPtr&lt;CSSRuleSourceData&gt; sourceData;
1174     if (ensureParsedDataReady())
1175         sourceData = ruleSourceDataFor(style);
</pre>
<hr />
<pre>
1371     RefPtr&lt;CSSRuleSourceData&gt; sourceData = ruleSourceDataFor(style);
1372     unsigned bodyStart = sourceData-&gt;ruleBodyRange.start;
1373     unsigned bodyEnd = sourceData-&gt;ruleBodyRange.end;
1374     ASSERT(bodyStart &lt;= bodyEnd);
1375 
1376     String text = m_parsedStyleSheet-&gt;text();
1377     ASSERT_WITH_SECURITY_IMPLICATION(bodyEnd &lt;= text.length()); // bodyEnd is exclusive
1378 
1379     text.replace(bodyStart, bodyEnd - bodyStart, newStyleText);
1380     *result = text;
1381     return true;
1382 }
1383 
1384 InspectorCSSId InspectorStyleSheet::ruleId(CSSStyleRule* rule) const
1385 {
1386     return ruleOrStyleId(&amp;rule-&gt;style());
1387 }
1388 
1389 bool InspectorStyleSheet::originalStyleSheetText(String* result) const
1390 {
<span class="line-modified">1391     bool success = inlineStyleSheetText(result);</span>
<span class="line-modified">1392     if (!success)</span>
<span class="line-modified">1393         success = resourceStyleSheetText(result);</span>
<span class="line-removed">1394     return success;</span>
1395 }
1396 
1397 bool InspectorStyleSheet::resourceStyleSheetText(String* result) const
1398 {
<span class="line-modified">1399     if (m_origin == Inspector::Protocol::CSS::StyleSheetOrigin::User || m_origin == Inspector::Protocol::CSS::StyleSheetOrigin::UserAgent)</span>
<span class="line-removed">1400         return false;</span>
<span class="line-removed">1401 </span>
<span class="line-removed">1402     if (!m_pageStyleSheet || !ownerDocument() || !ownerDocument()-&gt;frame())</span>
1403         return false;
1404 
1405     String error;
1406     bool base64Encoded;
1407     InspectorPageAgent::resourceContent(error, ownerDocument()-&gt;frame(), URL({ }, m_pageStyleSheet-&gt;href()), result, &amp;base64Encoded);
1408     return error.isEmpty() &amp;&amp; !base64Encoded;
1409 }
1410 
1411 bool InspectorStyleSheet::inlineStyleSheetText(String* result) const
1412 {
<span class="line-modified">1413     if (!m_pageStyleSheet)</span>
<span class="line-removed">1414         return false;</span>
<span class="line-removed">1415 </span>
<span class="line-removed">1416     Node* ownerNode = m_pageStyleSheet-&gt;ownerNode();</span>
1417     if (!is&lt;Element&gt;(ownerNode))
1418         return false;
<span class="line-removed">1419     Element&amp; ownerElement = downcast&lt;Element&gt;(*ownerNode);</span>
1420 

1421     if (!is&lt;HTMLStyleElement&gt;(ownerElement) &amp;&amp; !is&lt;SVGStyleElement&gt;(ownerElement))
1422         return false;

1423     *result = ownerElement.textContent();
1424     return true;
1425 }
1426 













1427 Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSRule&gt;&gt; InspectorStyleSheet::buildArrayForRuleList(CSSRuleList* ruleList)
1428 {
1429     auto result = JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSRule&gt;::create();
1430     if (!ruleList)
1431         return result;
1432 
1433     RefPtr&lt;CSSRuleList&gt; refRuleList = ruleList;
1434     CSSStyleRuleVector rules;
1435     collectFlatRules(WTFMove(refRuleList), &amp;rules);
1436 
1437     for (auto&amp; rule : rules)
1438         result-&gt;addItem(buildObjectForRule(rule.get(), nullptr));
1439 
1440     return result;
1441 }
1442 
1443 void InspectorStyleSheet::collectFlatRules(RefPtr&lt;CSSRuleList&gt;&amp;&amp; ruleList, CSSStyleRuleVector* result)
1444 {
1445     if (!ruleList)
1446         return;
</pre>
<hr />
<pre>
1535 
1536 RefPtr&lt;InspectorStyle&gt; InspectorStyleSheetForInlineStyle::inspectorStyleForId(const InspectorCSSId&amp; id)
1537 {
1538     ASSERT_UNUSED(id, !id.ordinal());
1539     return m_inspectorStyle.copyRef();
1540 }
1541 
1542 CSSStyleDeclaration&amp; InspectorStyleSheetForInlineStyle::inlineStyle() const
1543 {
1544     return m_element-&gt;cssomStyle();
1545 }
1546 
1547 const String&amp; InspectorStyleSheetForInlineStyle::elementStyleText() const
1548 {
1549     return m_element-&gt;getAttribute(&quot;style&quot;).string();
1550 }
1551 
1552 Ref&lt;CSSRuleSourceData&gt; InspectorStyleSheetForInlineStyle::ruleSourceData() const
1553 {
1554     if (m_styleText.isEmpty()) {
<span class="line-modified">1555         auto result = CSSRuleSourceData::create(StyleRule::Style);</span>
1556         result-&gt;ruleBodyRange.start = 0;
1557         result-&gt;ruleBodyRange.end = 0;
1558         return result;
1559     }
1560 
1561     CSSParserContext context(parserContextForDocument(&amp;m_element-&gt;document()));
1562     RuleSourceDataList ruleSourceDataResult;
1563     StyleSheetHandler handler(m_styleText, &amp;m_element-&gt;document(), &amp;ruleSourceDataResult);
1564     CSSParser::parseDeclarationForInspector(context, m_styleText, handler);
1565     return WTFMove(ruleSourceDataResult.first());
1566 }
1567 
1568 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;InspectorStyleSheet.h&quot;
  27 
  28 #include &quot;CSSImportRule.h&quot;
  29 #include &quot;CSSKeyframesRule.h&quot;
  30 #include &quot;CSSMediaRule.h&quot;
  31 #include &quot;CSSParser.h&quot;
  32 #include &quot;CSSParserObserver.h&quot;
  33 #include &quot;CSSPropertyNames.h&quot;
  34 #include &quot;CSSPropertyParser.h&quot;
  35 #include &quot;CSSPropertySourceData.h&quot;
  36 #include &quot;CSSRule.h&quot;
  37 #include &quot;CSSRuleList.h&quot;
  38 #include &quot;CSSStyleRule.h&quot;
  39 #include &quot;CSSStyleSheet.h&quot;
  40 #include &quot;CSSSupportsRule.h&quot;
  41 #include &quot;ContentSecurityPolicy.h&quot;
  42 #include &quot;Document.h&quot;
  43 #include &quot;Element.h&quot;
<span class="line-added">  44 #include &quot;ExtensionStyleSheets.h&quot;</span>
  45 #include &quot;HTMLHeadElement.h&quot;
  46 #include &quot;HTMLNames.h&quot;
  47 #include &quot;HTMLParserIdioms.h&quot;
  48 #include &quot;HTMLStyleElement.h&quot;
  49 #include &quot;InspectorCSSAgent.h&quot;
  50 #include &quot;InspectorDOMAgent.h&quot;
  51 #include &quot;InspectorPageAgent.h&quot;
  52 #include &quot;MediaList.h&quot;
  53 #include &quot;Node.h&quot;
  54 #include &quot;SVGElement.h&quot;
  55 #include &quot;SVGStyleElement.h&quot;
  56 #include &quot;StyleProperties.h&quot;
  57 #include &quot;StyleResolver.h&quot;
  58 #include &quot;StyleRule.h&quot;
  59 #include &quot;StyleRuleImport.h&quot;
  60 #include &quot;StyleSheetContents.h&quot;
  61 #include &quot;StyleSheetList.h&quot;
  62 #include &lt;JavaScriptCore/ContentSearchUtilities.h&gt;
  63 #include &lt;JavaScriptCore/RegularExpression.h&gt;
  64 #include &lt;wtf/text/StringBuilder.h&gt;
</pre>
<hr />
<pre>
  85     String m_text;
  86     bool m_hasText;
  87     std::unique_ptr&lt;RuleSourceDataList&gt; m_sourceData;
  88 };
  89 
  90 ParsedStyleSheet::ParsedStyleSheet()
  91     : m_hasText(false)
  92 {
  93 }
  94 
  95 void ParsedStyleSheet::setText(const String&amp; text)
  96 {
  97     m_hasText = true;
  98     m_text = text;
  99     setSourceData(nullptr);
 100 }
 101 
 102 static void flattenSourceData(RuleSourceDataList&amp; dataList, RuleSourceDataList&amp; target)
 103 {
 104     for (auto&amp; data : dataList) {
<span class="line-modified"> 105         if (data-&gt;type == WebCore::StyleRuleType::Style)</span>
 106             target.append(data.copyRef());
<span class="line-modified"> 107         else if (data-&gt;type == WebCore::StyleRuleType::Media)</span>
 108             flattenSourceData(data-&gt;childRules, target);
<span class="line-modified"> 109         else if (data-&gt;type == WebCore::StyleRuleType::Supports)</span>
 110             flattenSourceData(data-&gt;childRules, target);
 111     }
 112 }
 113 
 114 void ParsedStyleSheet::setSourceData(std::unique_ptr&lt;RuleSourceDataList&gt; sourceData)
 115 {
 116     if (!sourceData) {
 117         m_sourceData.reset();
 118         return;
 119     }
 120 
 121     m_sourceData = makeUnique&lt;RuleSourceDataList&gt;();
 122 
 123     // FIXME: This is a temporary solution to retain the original flat sourceData structure
 124     // containing only style rules, even though CSSParser now provides the full rule source data tree.
 125     // Normally, we should just assign m_sourceData = sourceData;
 126     flattenSourceData(*sourceData, *m_sourceData);
 127 }
 128 
 129 WebCore::CSSRuleSourceData* ParsedStyleSheet::ruleSourceDataAt(unsigned index) const
</pre>
<hr />
<pre>
 138 namespace WebCore {
 139 
 140 using namespace Inspector;
 141 
 142 static CSSParserContext parserContextForDocument(Document* document)
 143 {
 144     return document ? CSSParserContext(*document) : strictCSSParserContext();
 145 }
 146 
 147 class StyleSheetHandler : public CSSParserObserver {
 148 public:
 149     StyleSheetHandler(const String&amp; parsedText, Document* document, RuleSourceDataList* result)
 150         : m_parsedText(parsedText)
 151         , m_document(document)
 152         , m_ruleSourceDataResult(result)
 153     {
 154         ASSERT(m_ruleSourceDataResult);
 155     }
 156 
 157 private:
<span class="line-modified"> 158     void startRuleHeader(StyleRuleType, unsigned) override;</span>
 159     void endRuleHeader(unsigned) override;
 160     void observeSelector(unsigned startOffset, unsigned endOffset) override;
 161     void startRuleBody(unsigned) override;
 162     void endRuleBody(unsigned) override;
 163     void observeProperty(unsigned startOffset, unsigned endOffset, bool isImportant, bool isParsed) override;
 164     void observeComment(unsigned startOffset, unsigned endOffset) override;
 165 
 166     Ref&lt;CSSRuleSourceData&gt; popRuleData();
 167     template &lt;typename CharacterType&gt; inline void setRuleHeaderEnd(const CharacterType*, unsigned);
 168     void fixUnparsedPropertyRanges(CSSRuleSourceData*);
 169 
 170     const String&amp; m_parsedText;
 171     Document* m_document;
 172 
 173     RuleSourceDataList m_currentRuleDataStack;
 174     RefPtr&lt;CSSRuleSourceData&gt; m_currentRuleData;
 175     RuleSourceDataList* m_ruleSourceDataResult { nullptr };
 176 };
 177 
<span class="line-modified"> 178 void StyleSheetHandler::startRuleHeader(StyleRuleType type, unsigned offset)</span>
 179 {
 180     // Pop off data for a previous invalid rule.
 181     if (m_currentRuleData)
 182         m_currentRuleDataStack.removeLast();
 183 
 184     auto data = CSSRuleSourceData::create(type);
 185     data-&gt;ruleHeaderRange.start = offset;
 186     m_currentRuleData = data.copyRef();
 187     m_currentRuleDataStack.append(WTFMove(data));
 188 }
 189 
 190 template &lt;typename CharacterType&gt; inline void StyleSheetHandler::setRuleHeaderEnd(const CharacterType* dataStart, unsigned listEndOffset)
 191 {
 192     while (listEndOffset &gt; 1) {
 193         if (isHTMLSpace&lt;CharacterType&gt;(*(dataStart + listEndOffset - 1)))
 194             --listEndOffset;
 195         else
 196             break;
 197     }
 198 
</pre>
<hr />
<pre>
 525 
 526 RefPtr&lt;Inspector::Protocol::CSS::CSSStyle&gt; InspectorStyle::buildObjectForStyle() const
 527 {
 528     Ref&lt;Inspector::Protocol::CSS::CSSStyle&gt; result = styleWithProperties();
 529     if (!m_styleId.isEmpty())
 530         result-&gt;setStyleId(m_styleId.asProtocolValue&lt;Inspector::Protocol::CSS::CSSStyleId&gt;());
 531 
 532     result-&gt;setWidth(m_style-&gt;getPropertyValue(&quot;width&quot;));
 533     result-&gt;setHeight(m_style-&gt;getPropertyValue(&quot;height&quot;));
 534 
 535     RefPtr&lt;CSSRuleSourceData&gt; sourceData = extractSourceData();
 536     if (sourceData)
 537         result-&gt;setRange(buildSourceRangeObject(sourceData-&gt;ruleBodyRange, m_parentStyleSheet-&gt;lineEndings()));
 538 
 539     return result;
 540 }
 541 
 542 Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSComputedStyleProperty&gt;&gt; InspectorStyle::buildArrayForComputedStyle() const
 543 {
 544     auto result = JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSComputedStyleProperty&gt;::create();
<span class="line-modified"> 545     for (auto&amp; property : collectProperties(true)) {</span>



 546         const CSSPropertySourceData&amp; propertyEntry = property.sourceData;
 547         auto entry = Inspector::Protocol::CSS::CSSComputedStyleProperty::create()
 548             .setName(propertyEntry.name)
 549             .setValue(propertyEntry.value)
 550             .release();
 551         result-&gt;addItem(WTFMove(entry));
 552     }

 553     return result;
 554 }
 555 
 556 ExceptionOr&lt;String&gt; InspectorStyle::text() const
 557 {
 558     // Precondition: m_parentStyleSheet-&gt;ensureParsedDataReady() has been called successfully.
 559     auto sourceData = extractSourceData();
 560     if (!sourceData)
 561         return Exception { NotFoundError };
 562 
 563     auto result = m_parentStyleSheet-&gt;text();
 564     if (result.hasException())
 565         return result.releaseException();
 566 
 567     auto&amp; bodyRange = sourceData-&gt;ruleBodyRange;
 568     return result.releaseReturnValue().substring(bodyRange.start, bodyRange.end - bodyRange.start);
 569 }
 570 
 571 static String lowercasePropertyName(const String&amp; name)
 572 {
 573     // Custom properties are case-sensitive.
 574     if (name.startsWith(&quot;--&quot;))
 575         return name;
 576     return name.convertToASCIILowercase();
 577 }
 578 
<span class="line-modified"> 579 Vector&lt;InspectorStyleProperty&gt; InspectorStyle::collectProperties(bool includeAll) const</span>
 580 {
<span class="line-added"> 581     Vector&lt;InspectorStyleProperty&gt; result;</span>
 582     HashSet&lt;String&gt; sourcePropertyNames;
 583 
 584     auto sourceData = extractSourceData();
 585     auto* sourcePropertyData = sourceData ? &amp;sourceData-&gt;styleSourceData-&gt;propertyData : nullptr;
 586     if (sourcePropertyData) {
 587         auto styleDeclarationOrException = text();
 588         ASSERT(!styleDeclarationOrException.hasException());
 589         String styleDeclaration = styleDeclarationOrException.hasException() ? emptyString() : styleDeclarationOrException.releaseReturnValue();
 590         for (auto&amp; sourceData : *sourcePropertyData) {
 591             InspectorStyleProperty p(sourceData, true, sourceData.disabled);
 592             p.setRawTextFromStyleDeclaration(styleDeclaration);
<span class="line-modified"> 593             result.append(p);</span>
 594             sourcePropertyNames.add(lowercasePropertyName(sourceData.name));
 595         }
 596     }
 597 
 598     for (int i = 0, size = m_style-&gt;length(); i &lt; size; ++i) {
 599         String name = m_style-&gt;item(i);
 600         if (sourcePropertyNames.add(lowercasePropertyName(name)))
<span class="line-modified"> 601             result.append(InspectorStyleProperty(CSSPropertySourceData(name, m_style-&gt;getPropertyValue(name), !m_style-&gt;getPropertyPriority(name).isEmpty(), false, true, SourceRange()), false, false));</span>
 602     }
<span class="line-added"> 603 </span>
<span class="line-added"> 604     if (includeAll) {</span>
<span class="line-added"> 605         for (auto i = firstCSSProperty; i &lt; lastCSSProperty; ++i) {</span>
<span class="line-added"> 606             auto id = convertToCSSPropertyID(i);</span>
<span class="line-added"> 607             if (isInternalCSSProperty(id) || !isEnabledCSSProperty(id))</span>
<span class="line-added"> 608                 continue;</span>
<span class="line-added"> 609 </span>
<span class="line-added"> 610             auto name = getPropertyNameString(id);</span>
<span class="line-added"> 611             if (!sourcePropertyNames.add(lowercasePropertyName(name)))</span>
<span class="line-added"> 612                 continue;</span>
<span class="line-added"> 613 </span>
<span class="line-added"> 614             auto value = m_style-&gt;getPropertyValue(name);</span>
<span class="line-added"> 615             if (value.isEmpty())</span>
<span class="line-added"> 616                 continue;</span>
<span class="line-added"> 617 </span>
<span class="line-added"> 618             result.append(InspectorStyleProperty(CSSPropertySourceData(name, value, !m_style-&gt;getPropertyPriority(name).isEmpty(), false, true, SourceRange()), false, false));</span>
<span class="line-added"> 619         }</span>
<span class="line-added"> 620     }</span>
<span class="line-added"> 621 </span>
<span class="line-added"> 622     return result;</span>
 623 }
 624 
 625 Ref&lt;Inspector::Protocol::CSS::CSSStyle&gt; InspectorStyle::styleWithProperties() const
 626 {
<span class="line-modified"> 627     auto properties = collectProperties(false);</span>

 628 
 629     auto propertiesObject = JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSProperty&gt;::create();
 630     auto shorthandEntries = ArrayOf&lt;Inspector::Protocol::CSS::ShorthandEntry&gt;::create();
 631     HashMap&lt;String, RefPtr&lt;Inspector::Protocol::CSS::CSSProperty&gt;&gt; propertyNameToPreviousActiveProperty;
 632     HashSet&lt;String&gt; foundShorthands;
 633     String previousPriority;
 634     String previousStatus;
 635     Vector&lt;size_t&gt; lineEndings = m_parentStyleSheet ? m_parentStyleSheet-&gt;lineEndings() : Vector&lt;size_t&gt; { };
 636     auto sourceData = extractSourceData();
 637     unsigned ruleBodyRangeStart = sourceData ? sourceData-&gt;ruleBodyRange.start : 0;
 638 
 639     for (Vector&lt;InspectorStyleProperty&gt;::iterator it = properties.begin(), itEnd = properties.end(); it != itEnd; ++it) {
 640         const CSSPropertySourceData&amp; propertyEntry = it-&gt;sourceData;
 641         const String&amp; name = propertyEntry.name;
 642 
 643         auto status = it-&gt;disabled ? Inspector::Protocol::CSS::CSSPropertyStatus::Disabled : Inspector::Protocol::CSS::CSSPropertyStatus::Active;
 644 
 645         auto property = Inspector::Protocol::CSS::CSSProperty::create()
 646             .setName(name.convertToASCIILowercase())
 647             .setValue(propertyEntry.value)
</pre>
<hr />
<pre>
1151         .release();
1152     if (sourceData)
1153         result-&gt;setRange(buildSourceRangeObject(sourceData-&gt;ruleHeaderRange, lineEndings(), &amp;endingLine));
1154     return result;
1155 }
1156 
1157 RefPtr&lt;Inspector::Protocol::CSS::CSSRule&gt; InspectorStyleSheet::buildObjectForRule(CSSStyleRule* rule, Element* element)
1158 {
1159     CSSStyleSheet* styleSheet = pageStyleSheet();
1160     if (!styleSheet)
1161         return nullptr;
1162 
1163     int endingLine = 0;
1164     auto result = Inspector::Protocol::CSS::CSSRule::create()
1165         .setSelectorList(buildObjectForSelectorList(rule, element, endingLine))
1166         .setSourceLine(endingLine)
1167         .setOrigin(m_origin)
1168         .setStyle(buildObjectForStyle(&amp;rule-&gt;style()))
1169         .release();
1170 
<span class="line-modified">1171     if (m_origin == Inspector::Protocol::CSS::StyleSheetOrigin::Regular || m_origin == Inspector::Protocol::CSS::StyleSheetOrigin::User)</span>

1172         result-&gt;setSourceURL(finalURL());
1173 
1174     if (canBind()) {
1175         InspectorCSSId id(ruleId(rule));
1176         if (!id.isEmpty())
1177             result-&gt;setRuleId(id.asProtocolValue&lt;Inspector::Protocol::CSS::CSSRuleId&gt;());
1178     }
1179 
1180     auto groupingsPayload = buildArrayForGroupings(*rule);
1181     if (groupingsPayload-&gt;length())
1182         result-&gt;setGroupings(WTFMove(groupingsPayload));
1183 
1184     return result;
1185 }
1186 
1187 RefPtr&lt;Inspector::Protocol::CSS::CSSStyle&gt; InspectorStyleSheet::buildObjectForStyle(CSSStyleDeclaration* style)
1188 {
1189     RefPtr&lt;CSSRuleSourceData&gt; sourceData;
1190     if (ensureParsedDataReady())
1191         sourceData = ruleSourceDataFor(style);
</pre>
<hr />
<pre>
1387     RefPtr&lt;CSSRuleSourceData&gt; sourceData = ruleSourceDataFor(style);
1388     unsigned bodyStart = sourceData-&gt;ruleBodyRange.start;
1389     unsigned bodyEnd = sourceData-&gt;ruleBodyRange.end;
1390     ASSERT(bodyStart &lt;= bodyEnd);
1391 
1392     String text = m_parsedStyleSheet-&gt;text();
1393     ASSERT_WITH_SECURITY_IMPLICATION(bodyEnd &lt;= text.length()); // bodyEnd is exclusive
1394 
1395     text.replace(bodyStart, bodyEnd - bodyStart, newStyleText);
1396     *result = text;
1397     return true;
1398 }
1399 
1400 InspectorCSSId InspectorStyleSheet::ruleId(CSSStyleRule* rule) const
1401 {
1402     return ruleOrStyleId(&amp;rule-&gt;style());
1403 }
1404 
1405 bool InspectorStyleSheet::originalStyleSheetText(String* result) const
1406 {
<span class="line-modified">1407     if (!m_pageStyleSheet || m_origin == Inspector::Protocol::CSS::StyleSheetOrigin::UserAgent)</span>
<span class="line-modified">1408         return false;</span>
<span class="line-modified">1409     return inlineStyleSheetText(result) || resourceStyleSheetText(result) || extensionStyleSheetText(result);</span>

1410 }
1411 
1412 bool InspectorStyleSheet::resourceStyleSheetText(String* result) const
1413 {
<span class="line-modified">1414     if (!ownerDocument() || !ownerDocument()-&gt;frame())</span>



1415         return false;
1416 
1417     String error;
1418     bool base64Encoded;
1419     InspectorPageAgent::resourceContent(error, ownerDocument()-&gt;frame(), URL({ }, m_pageStyleSheet-&gt;href()), result, &amp;base64Encoded);
1420     return error.isEmpty() &amp;&amp; !base64Encoded;
1421 }
1422 
1423 bool InspectorStyleSheet::inlineStyleSheetText(String* result) const
1424 {
<span class="line-modified">1425     auto* ownerNode = m_pageStyleSheet-&gt;ownerNode();</span>



1426     if (!is&lt;Element&gt;(ownerNode))
1427         return false;

1428 
<span class="line-added">1429     auto&amp; ownerElement = downcast&lt;Element&gt;(*ownerNode);</span>
1430     if (!is&lt;HTMLStyleElement&gt;(ownerElement) &amp;&amp; !is&lt;SVGStyleElement&gt;(ownerElement))
1431         return false;
<span class="line-added">1432 </span>
1433     *result = ownerElement.textContent();
1434     return true;
1435 }
1436 
<span class="line-added">1437 bool InspectorStyleSheet::extensionStyleSheetText(String* result) const</span>
<span class="line-added">1438 {</span>
<span class="line-added">1439     if (!ownerDocument())</span>
<span class="line-added">1440         return false;</span>
<span class="line-added">1441 </span>
<span class="line-added">1442     auto content = ownerDocument()-&gt;extensionStyleSheets().contentForInjectedStyleSheet(m_pageStyleSheet);</span>
<span class="line-added">1443     if (content.isEmpty())</span>
<span class="line-added">1444         return false;</span>
<span class="line-added">1445 </span>
<span class="line-added">1446     *result = content;</span>
<span class="line-added">1447     return true;</span>
<span class="line-added">1448 }</span>
<span class="line-added">1449 </span>
1450 Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSRule&gt;&gt; InspectorStyleSheet::buildArrayForRuleList(CSSRuleList* ruleList)
1451 {
1452     auto result = JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSRule&gt;::create();
1453     if (!ruleList)
1454         return result;
1455 
1456     RefPtr&lt;CSSRuleList&gt; refRuleList = ruleList;
1457     CSSStyleRuleVector rules;
1458     collectFlatRules(WTFMove(refRuleList), &amp;rules);
1459 
1460     for (auto&amp; rule : rules)
1461         result-&gt;addItem(buildObjectForRule(rule.get(), nullptr));
1462 
1463     return result;
1464 }
1465 
1466 void InspectorStyleSheet::collectFlatRules(RefPtr&lt;CSSRuleList&gt;&amp;&amp; ruleList, CSSStyleRuleVector* result)
1467 {
1468     if (!ruleList)
1469         return;
</pre>
<hr />
<pre>
1558 
1559 RefPtr&lt;InspectorStyle&gt; InspectorStyleSheetForInlineStyle::inspectorStyleForId(const InspectorCSSId&amp; id)
1560 {
1561     ASSERT_UNUSED(id, !id.ordinal());
1562     return m_inspectorStyle.copyRef();
1563 }
1564 
1565 CSSStyleDeclaration&amp; InspectorStyleSheetForInlineStyle::inlineStyle() const
1566 {
1567     return m_element-&gt;cssomStyle();
1568 }
1569 
1570 const String&amp; InspectorStyleSheetForInlineStyle::elementStyleText() const
1571 {
1572     return m_element-&gt;getAttribute(&quot;style&quot;).string();
1573 }
1574 
1575 Ref&lt;CSSRuleSourceData&gt; InspectorStyleSheetForInlineStyle::ruleSourceData() const
1576 {
1577     if (m_styleText.isEmpty()) {
<span class="line-modified">1578         auto result = CSSRuleSourceData::create(StyleRuleType::Style);</span>
1579         result-&gt;ruleBodyRange.start = 0;
1580         result-&gt;ruleBodyRange.end = 0;
1581         return result;
1582     }
1583 
1584     CSSParserContext context(parserContextForDocument(&amp;m_element-&gt;document()));
1585     RuleSourceDataList ruleSourceDataResult;
1586     StyleSheetHandler handler(m_styleText, &amp;m_element-&gt;document(), &amp;ruleSourceDataResult);
1587     CSSParser::parseDeclarationForInspector(context, m_styleText, handler);
1588     return WTFMove(ruleSourceDataResult.first());
1589 }
1590 
1591 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="InspectorShaderProgram.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InspectorStyleSheet.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
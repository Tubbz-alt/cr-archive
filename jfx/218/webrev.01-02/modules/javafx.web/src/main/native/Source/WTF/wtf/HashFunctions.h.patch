diff a/modules/javafx.web/src/main/native/Source/WTF/wtf/HashFunctions.h b/modules/javafx.web/src/main/native/Source/WTF/wtf/HashFunctions.h
--- a/modules/javafx.web/src/main/native/Source/WTF/wtf/HashFunctions.h
+++ b/modules/javafx.web/src/main/native/Source/WTF/wtf/HashFunctions.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2005, 2006, 2008 Apple Inc. All rights reserved.
+ * Copyright (C) 2005-2019 Apple Inc. All rights reserved.
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
  * License as published by the Free Software Foundation; either
  * version 2 of the License, or (at your option) any later version.
@@ -100,11 +100,11 @@
     }
 
     template<typename T> struct IntHash {
         static unsigned hash(T key) { return intHash(static_cast<typename IntTypes<sizeof(T)>::UnsignedType>(key)); }
         static bool equal(T a, T b) { return a == b; }
-        static const bool safeToCompareToEmptyOrDeleted = true;
+        static constexpr bool safeToCompareToEmptyOrDeleted = true;
     };
 
     template<typename T> struct FloatHash {
         typedef typename IntTypes<sizeof(T)>::UnsignedType Bits;
         static unsigned hash(T key)
@@ -113,11 +113,11 @@
         }
         static bool equal(T a, T b)
         {
             return bitwise_cast<Bits>(a) == bitwise_cast<Bits>(b);
         }
-        static const bool safeToCompareToEmptyOrDeleted = true;
+        static constexpr bool safeToCompareToEmptyOrDeleted = true;
     };
 
     // pointer identity hash function
 
     template<typename T, bool isSmartPointer>
@@ -127,20 +127,20 @@
     struct PtrHashBase<T, false /* isSmartPtr */> {
         typedef T PtrType;
 
         static unsigned hash(PtrType key) { return IntHash<uintptr_t>::hash(reinterpret_cast<uintptr_t>(key)); }
         static bool equal(PtrType a, PtrType b) { return a == b; }
-        static const bool safeToCompareToEmptyOrDeleted = true;
+        static constexpr bool safeToCompareToEmptyOrDeleted = true;
     };
 
     template <typename T>
     struct PtrHashBase<T, true /* isSmartPtr */> {
         typedef typename GetPtrHelper<T>::PtrType PtrType;
 
         static unsigned hash(PtrType key) { return IntHash<uintptr_t>::hash(reinterpret_cast<uintptr_t>(key)); }
         static bool equal(PtrType a, PtrType b) { return a == b; }
-        static const bool safeToCompareToEmptyOrDeleted = true;
+        static constexpr bool safeToCompareToEmptyOrDeleted = true;
 
         static unsigned hash(const T& key) { return hash(getPtr(key)); }
         static bool equal(const T& a, const T& b) { return getPtr(a) == getPtr(b); }
         static bool equal(PtrType a, const T& b) { return a == getPtr(b); }
         static bool equal(const T& a, PtrType b) { return getPtr(a) == b; }
@@ -148,11 +148,11 @@
 
     template<typename T> struct PtrHash : PtrHashBase<T, IsSmartPtr<T>::value> {
     };
 
     template<typename P> struct PtrHash<Ref<P>> : PtrHashBase<Ref<P>, IsSmartPtr<Ref<P>>::value> {
-        static const bool safeToCompareToEmptyOrDeleted = false;
+        static constexpr bool safeToCompareToEmptyOrDeleted = false;
     };
 
     // default hash function for each type
 
     template<typename T> struct DefaultHash;
@@ -164,17 +164,17 @@
         }
         static bool equal(const std::pair<T, U>& a, const std::pair<T, U>& b)
         {
             return DefaultHash<T>::Hash::equal(a.first, b.first) && DefaultHash<U>::Hash::equal(a.second, b.second);
         }
-        static const bool safeToCompareToEmptyOrDeleted = DefaultHash<T>::Hash::safeToCompareToEmptyOrDeleted && DefaultHash<U>::Hash::safeToCompareToEmptyOrDeleted;
+        static constexpr bool safeToCompareToEmptyOrDeleted = DefaultHash<T>::Hash::safeToCompareToEmptyOrDeleted && DefaultHash<U>::Hash::safeToCompareToEmptyOrDeleted;
     };
 
     template<typename T, typename U> struct IntPairHash {
         static unsigned hash(const std::pair<T, U>& p) { return pairIntHash(p.first, p.second); }
         static bool equal(const std::pair<T, U>& a, const std::pair<T, U>& b) { return PairHash<T, T>::equal(a, b); }
-        static const bool safeToCompareToEmptyOrDeleted = PairHash<T, U>::safeToCompareToEmptyOrDeleted;
+        static constexpr bool safeToCompareToEmptyOrDeleted = PairHash<T, U>::safeToCompareToEmptyOrDeleted;
     };
 
     template<typename... Types>
     struct TupleHash {
         template<size_t I = 0>
@@ -209,11 +209,11 @@
         // we switch to C++17. We can't do anything better here right now because GCC can't do C++.
         template<typename BoolType>
         static constexpr bool allTrue(BoolType value) { return value; }
         template<typename BoolType, typename... BoolTypes>
         static constexpr bool allTrue(BoolType value, BoolTypes... values) { return value && allTrue(values...); }
-        static const bool safeToCompareToEmptyOrDeleted = allTrue(DefaultHash<Types>::Hash::safeToCompareToEmptyOrDeleted...);
+        static constexpr bool safeToCompareToEmptyOrDeleted = allTrue(DefaultHash<Types>::Hash::safeToCompareToEmptyOrDeleted...);
     };
 
     // make IntHash the default hash function for many integer types
 
     template<> struct DefaultHash<bool> { typedef IntHash<uint8_t> Hash; };

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsContext.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GraphicsContext.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GraphicsLayer.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsContext.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;DashArray.h&quot;
 30 #include &quot;FloatRect.h&quot;
 31 #include &quot;FontCascade.h&quot;
 32 #include &quot;Gradient.h&quot;
 33 #include &quot;GraphicsTypes.h&quot;
 34 #include &quot;Image.h&quot;
 35 #include &quot;ImageOrientation.h&quot;
 36 #include &quot;ImagePaintingOptions.h&quot;
 37 #include &quot;Pattern.h&quot;

 38 #include &lt;wtf/Function.h&gt;
 39 #include &lt;wtf/Noncopyable.h&gt;

 40 
 41 #if USE(CG)
 42 typedef struct CGContext PlatformGraphicsContext;
 43 #elif USE(DIRECT2D)
 44 interface ID2D1DCRenderTarget;
 45 interface ID2D1RenderTarget;
 46 interface ID2D1Factory;
 47 interface ID2D1SolidColorBrush;
 48 namespace WebCore {
 49 class PlatformContextDirect2D;
 50 }
 51 typedef WebCore::PlatformContextDirect2D PlatformGraphicsContext;
 52 #elif USE(CAIRO)
 53 namespace WebCore {
 54 class PlatformContextCairo;
 55 }
 56 typedef WebCore::PlatformContextCairo PlatformGraphicsContext;
 57 #elif USE(WINGDI)
 58 typedef struct HDC__ PlatformGraphicsContext;
 59 #elif PLATFORM(JAVA)
</pre>
<hr />
<pre>
 79 #if defined(None)
 80 #undef None
 81 #endif
 82 
 83 namespace WebCore {
 84 
 85 #if USE(WINGDI)
 86 class SharedBitmap;
 87 class Font;
 88 class GlyphBuffer;
 89 #endif
 90 
 91 class AffineTransform;
 92 class FloatRoundedRect;
 93 class Gradient;
 94 class GraphicsContextImpl;
 95 class GraphicsContextPlatformPrivate;
 96 class ImageBuffer;
 97 class IntRect;
 98 class RoundedRect;
<span class="line-modified"> 99 class GraphicsContext3D;</span>
100 class Path;
101 class TextRun;
102 class TransformationMatrix;
103 
104 enum TextDrawingMode {
105     TextModeFill = 1 &lt;&lt; 0,
106     TextModeStroke = 1 &lt;&lt; 1,
107 #if ENABLE(LETTERPRESS)
108     TextModeLetterpress = 1 &lt;&lt; 2,
109 #endif
110 };
111 typedef unsigned TextDrawingModeFlags;
112 
113 enum StrokeStyle {
114     NoStroke,
115     SolidStroke,
116     DottedStroke,
117     DashedStroke,
118     DoubleStroke,
119     WavyStroke,
120 };
121 
122 struct DocumentMarkerLineStyle {
123     enum class Mode : uint8_t {
124         TextCheckingDictationPhraseWithAlternatives,
125         Spelling,
126         Grammar,
127         AutocorrectionReplacement,
128         DictationAlternatives
129     } mode;
130     bool shouldUseDarkAppearance { false };



131 };
132 























133 namespace DisplayList {
134 class Recorder;
135 }
136 
137 struct GraphicsContextState {
138     GraphicsContextState()
139         : shouldAntialias(true)
140         , shouldSmoothFonts(true)
141         , shouldSubpixelQuantizeFonts(true)
142         , shadowsIgnoreTransforms(false)
143 #if USE(CG)
144         // Core Graphics incorrectly renders shadows with radius &gt; 8px (&lt;rdar://problem/8103442&gt;),
145         // but we need to preserve this buggy behavior for canvas and -webkit-box-shadow.
146         , shadowsUseLegacyRadius(false)
147 #endif
148 #if PLATFORM(JAVA)
149         , clipBounds(FloatRect::infiniteRect())
150 #endif
151         , drawLuminanceMask(false)
152     {
153     }
154 
155     enum Change : uint32_t {
<span class="line-removed">156         NoChange                                = 0,</span>
157         StrokeGradientChange                    = 1 &lt;&lt; 1,
158         StrokePatternChange                     = 1 &lt;&lt; 2,
159         FillGradientChange                      = 1 &lt;&lt; 3,
160         FillPatternChange                       = 1 &lt;&lt; 4,
161         StrokeThicknessChange                   = 1 &lt;&lt; 5,
162         StrokeColorChange                       = 1 &lt;&lt; 6,
163         StrokeStyleChange                       = 1 &lt;&lt; 7,
164         FillColorChange                         = 1 &lt;&lt; 8,
165         FillRuleChange                          = 1 &lt;&lt; 9,
166         ShadowChange                            = 1 &lt;&lt; 10,
<span class="line-modified">167         ShadowColorChange                       = 1 &lt;&lt; 11,</span>
<span class="line-modified">168         ShadowsIgnoreTransformsChange           = 1 &lt;&lt; 12,</span>
<span class="line-modified">169         AlphaChange                             = 1 &lt;&lt; 13,</span>
<span class="line-modified">170         CompositeOperationChange                = 1 &lt;&lt; 14,</span>
<span class="line-modified">171         BlendModeChange                         = 1 &lt;&lt; 15,</span>
<span class="line-modified">172         TextDrawingModeChange                   = 1 &lt;&lt; 16,</span>
<span class="line-modified">173         ShouldAntialiasChange                   = 1 &lt;&lt; 17,</span>
<span class="line-modified">174         ShouldSmoothFontsChange                 = 1 &lt;&lt; 18,</span>
<span class="line-modified">175         ShouldSubpixelQuantizeFontsChange       = 1 &lt;&lt; 19,</span>
<span class="line-modified">176         DrawLuminanceMaskChange                 = 1 &lt;&lt; 20,</span>
<span class="line-removed">177         ImageInterpolationQualityChange         = 1 &lt;&lt; 21,</span>
178 #if HAVE(OS_DARK_MODE_SUPPORT)
<span class="line-modified">179         UseDarkAppearanceChange                 = 1 &lt;&lt; 22,</span>
180 #endif
181     };
<span class="line-modified">182     typedef uint32_t StateChangeFlags;</span>
183 
184     RefPtr&lt;Gradient&gt; strokeGradient;
185     RefPtr&lt;Pattern&gt; strokePattern;
186 
187     RefPtr&lt;Gradient&gt; fillGradient;
188     RefPtr&lt;Pattern&gt; fillPattern;
189 
190     FloatSize shadowOffset;
191 
192     float strokeThickness { 0 };
193     float shadowBlur { 0 };
194 
195     TextDrawingModeFlags textDrawingMode { TextModeFill };
196 
197     Color strokeColor { Color::black };
198     Color fillColor { Color::black };
199     Color shadowColor;
200 
201     StrokeStyle strokeStyle { SolidStroke };
202     WindRule fillRule { WindRule::NonZero };
203 
204     float alpha { 1 };
<span class="line-modified">205     CompositeOperator compositeOperator { CompositeSourceOver };</span>
206     BlendMode blendMode { BlendMode::Normal };
<span class="line-modified">207     InterpolationQuality imageInterpolationQuality { InterpolationDefault };</span>
208 
209     bool shouldAntialias : 1;
210     bool shouldSmoothFonts : 1;
211     bool shouldSubpixelQuantizeFonts : 1;
212     bool shadowsIgnoreTransforms : 1;
213 #if USE(CG)
214     bool shadowsUseLegacyRadius : 1;
215 #endif
216 #if PLATFORM(JAVA)
217     AffineTransform transform;
218     FloatRect clipBounds;
219 #endif
220     bool drawLuminanceMask : 1;
221 #if HAVE(OS_DARK_MODE_SUPPORT)
222     bool useDarkAppearance : 1;
223 #endif
224 };
225 
226 struct GraphicsContextStateChange {
227     GraphicsContextStateChange() = default;
228     GraphicsContextStateChange(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
229         : m_state(state)
230         , m_changeFlags(flags)
231     {
232     }
233 
234     GraphicsContextState::StateChangeFlags changesFromState(const GraphicsContextState&amp;) const;
235 
236     void accumulate(const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);
237     void apply(GraphicsContext&amp;) const;
238 
239     void dump(WTF::TextStream&amp;) const;
240 
241     GraphicsContextState m_state;
<span class="line-modified">242     GraphicsContextState::StateChangeFlags m_changeFlags { GraphicsContextState::NoChange };</span>
243 };
244 
245 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const GraphicsContextStateChange&amp;);
246 
247 
248 class GraphicsContext {
249     WTF_MAKE_NONCOPYABLE(GraphicsContext); WTF_MAKE_FAST_ALLOCATED;
250 public:
251     WEBCORE_EXPORT GraphicsContext(PlatformGraphicsContext*);
252 
253     using GraphicsContextImplFactory = WTF::Function&lt;std::unique_ptr&lt;GraphicsContextImpl&gt;(GraphicsContext&amp;)&gt;;
254     WEBCORE_EXPORT GraphicsContext(const GraphicsContextImplFactory&amp;);
255 
256     GraphicsContext() = default;
257     WEBCORE_EXPORT ~GraphicsContext();
258 
259     enum class PaintInvalidationReasons : uint8_t {
260         None,
261         InvalidatingControlTints,
262         InvalidatingImagesWithAsyncDecodes
</pre>
<hr />
<pre>
320     void setShouldSubpixelQuantizeFonts(bool);
321     bool shouldSubpixelQuantizeFonts() const { return m_state.shouldSubpixelQuantizeFonts; }
322 
323     const GraphicsContextState&amp; state() const { return m_state; }
324 
325 #if USE(CG) || USE(DIRECT2D) || USE(CAIRO)
326     WEBCORE_EXPORT void drawNativeImage(const NativeImagePtr&amp;, const FloatSize&amp; selfSize, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp; = { });
327 #endif
328 
329 #if USE(CG) || USE(DIRECT2D)
330     void applyStrokePattern();
331     void applyFillPattern();
332     void drawPath(const Path&amp;);
333 
334     WEBCORE_EXPORT void setIsCALayerContext(bool);
335     bool isCALayerContext() const;
336 
337     WEBCORE_EXPORT void setIsAcceleratedContext(bool);
338 #endif
339     bool isAcceleratedContext() const;
<span class="line-modified">340     RenderingMode renderingMode() const { return isAcceleratedContext() ? Accelerated : Unaccelerated; }</span>
341 
342     WEBCORE_EXPORT void save();
343     WEBCORE_EXPORT void restore();
344 
345     unsigned stackSize() const { return m_stack.size(); }
346 
347     // These draw methods will do both stroking and filling.
348     // FIXME: ...except drawRect(), which fills properly but always strokes
349     // using a 1-pixel stroke inset from the rect borders (of the correct
350     // stroke color).
351     void drawRect(const FloatRect&amp;, float borderThickness = 1);
352     void drawLine(const FloatPoint&amp;, const FloatPoint&amp;);
353 
354     void drawEllipse(const FloatRect&amp;);
355     void drawRaisedEllipse(const FloatRect&amp;, const Color&amp; ellipseColor, const Color&amp; shadowColor);
356 
357     WEBCORE_EXPORT void fillPath(const Path&amp;);
358     WEBCORE_EXPORT void strokePath(const Path&amp;);
359 
360     void fillEllipse(const FloatRect&amp;);
361     void strokeEllipse(const FloatRect&amp;);
362 
363     WEBCORE_EXPORT void fillRect(const FloatRect&amp;);
364     WEBCORE_EXPORT void fillRect(const FloatRect&amp;, const Color&amp;);
365     void fillRect(const FloatRect&amp;, Gradient&amp;);
366     void fillRect(const FloatRect&amp;, const Color&amp;, CompositeOperator, BlendMode = BlendMode::Normal);
367     void fillRoundedRect(const FloatRoundedRect&amp;, const Color&amp;, BlendMode = BlendMode::Normal);
368     void fillRectWithRoundedHole(const FloatRect&amp;, const FloatRoundedRect&amp; roundedHoleRect, const Color&amp;);
369 
370     WEBCORE_EXPORT void clearRect(const FloatRect&amp;);
371 
372     WEBCORE_EXPORT void strokeRect(const FloatRect&amp;, float lineWidth);
373 
<span class="line-modified">374     WEBCORE_EXPORT ImageDrawResult drawImage(Image&amp;, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; = { });</span>
<span class="line-modified">375     WEBCORE_EXPORT ImageDrawResult drawImage(Image&amp;, const FloatRect&amp; destination, const ImagePaintingOptions&amp; = { });</span>
<span class="line-modified">376     ImageDrawResult drawImage(Image&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; = { });</span>
377 
378     ImageDrawResult drawTiledImage(Image&amp;, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; = { });
379     ImageDrawResult drawTiledImage(Image&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor, Image::TileRule, Image::TileRule, const ImagePaintingOptions&amp; = { });
380 
381     WEBCORE_EXPORT void drawImageBuffer(ImageBuffer&amp;, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; = { });
382     void drawImageBuffer(ImageBuffer&amp;, const FloatRect&amp; destination, const ImagePaintingOptions&amp; = { });
383     void drawImageBuffer(ImageBuffer&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; = { });
384 
385     void drawPattern(Image&amp;, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const AffineTransform&amp;, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; = { });
386 
387     WEBCORE_EXPORT void drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt;, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; = { });
388     void drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt;, const FloatRect&amp; destination, const ImagePaintingOptions&amp; = { });
389     void drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt;, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; = { });
390 
391     WEBCORE_EXPORT void setImageInterpolationQuality(InterpolationQuality);
392     InterpolationQuality imageInterpolationQuality() const { return m_state.imageInterpolationQuality; }
393 
394     WEBCORE_EXPORT void clip(const FloatRect&amp;);
395     void clipRoundedRect(const FloatRoundedRect&amp;);
396 
397     void clipOut(const FloatRect&amp;);
398     void clipOutRoundedRect(const FloatRoundedRect&amp;);
399     void clipPath(const Path&amp;, WindRule = WindRule::EvenOdd);
400     void clipToImageBuffer(ImageBuffer&amp;, const FloatRect&amp;);
401 
402     IntRect clipBounds() const;
403 
404     void setTextDrawingMode(TextDrawingModeFlags);
405     TextDrawingModeFlags textDrawingMode() const { return m_state.textDrawingMode; }
406 
407 #if HAVE(OS_DARK_MODE_SUPPORT)
408     void setUseDarkAppearance(bool);
409     bool useDarkAppearance() const { return m_state.useDarkAppearance; }
410 #endif
411 
412     float drawText(const FontCascade&amp;, const TextRun&amp;, const FloatPoint&amp;, unsigned from = 0, Optional&lt;unsigned&gt; to = WTF::nullopt);
413     void drawGlyphs(const Font&amp;, const GlyphBuffer&amp;, unsigned from, unsigned numGlyphs, const FloatPoint&amp;, FontSmoothingMode);
414     void drawEmphasisMarks(const FontCascade&amp;, const TextRun&amp;, const AtomString&amp; mark, const FloatPoint&amp;, unsigned from = 0, Optional&lt;unsigned&gt; to = WTF::nullopt);
415     void drawBidiText(const FontCascade&amp;, const TextRun&amp;, const FloatPoint&amp;, FontCascade::CustomFontNotReadyAction = FontCascade::DoNotPaintIfFontNotReady);
416 
<span class="line-modified">417     void applyState(const GraphicsContextState&amp;);</span>
418 
419     enum RoundingMode {
420         RoundAllSides,
421         RoundOriginAndDimensions
422     };
423     FloatRect roundToDevicePixels(const FloatRect&amp;, RoundingMode = RoundAllSides);
424 
425     FloatRect computeUnderlineBoundsForText(const FloatRect&amp;, bool printing);
426     WEBCORE_EXPORT void drawLineForText(const FloatRect&amp;, bool printing, bool doubleLines = false, StrokeStyle = SolidStroke);
427     void drawLinesForText(const FloatPoint&amp;, float thickness, const DashArray&amp; widths, bool printing, bool doubleLines = false, StrokeStyle = SolidStroke);
428     void drawDotsForDocumentMarker(const FloatRect&amp;, DocumentMarkerLineStyle);
429 
430     WEBCORE_EXPORT void beginTransparencyLayer(float opacity);
431     WEBCORE_EXPORT void endTransparencyLayer();
432     bool isInTransparencyLayer() const { return (m_transparencyCount &gt; 0) &amp;&amp; supportsTransparencyLayers(); }
433 
434     WEBCORE_EXPORT void setShadow(const FloatSize&amp;, float blur, const Color&amp;);
435     // Legacy shadow blur radius is used for canvas, and -webkit-box-shadow.
436     // It has different treatment of radii &gt; 8px.
437     void setLegacyShadow(const FloatSize&amp;, float blur, const Color&amp;);
</pre>
<hr />
<pre>
473 
474     void scale(float s)
475     {
476         scale({ s, s });
477     }
478     WEBCORE_EXPORT void scale(const FloatSize&amp;);
479     void rotate(float angleInRadians);
480     void translate(const FloatSize&amp; size) { translate(size.width(), size.height()); }
481     void translate(const FloatPoint&amp; p) { translate(p.x(), p.y()); }
482     WEBCORE_EXPORT void translate(float x, float y);
483 
484     void setURLForRect(const URL&amp;, const FloatRect&amp;);
485 
486     void setDestinationForRect(const String&amp; name, const FloatRect&amp;);
487     void addDestinationAtPoint(const String&amp; name, const FloatPoint&amp;);
488 
489     void concatCTM(const AffineTransform&amp;);
490     void setCTM(const AffineTransform&amp;);
491 
492     enum IncludeDeviceScale { DefinitelyIncludeDeviceScale, PossiblyIncludeDeviceScale };
<span class="line-modified">493     AffineTransform getCTM(IncludeDeviceScale includeScale = PossiblyIncludeDeviceScale) const;</span>
494 
495     // This function applies the device scale factor to the context, making the context capable of
496     // acting as a base-level context for a HiDPI environment.
497     WEBCORE_EXPORT void applyDeviceScaleFactor(float);
498     void platformApplyDeviceScaleFactor(float);
499     FloatSize scaleFactor() const;
500     FloatSize scaleFactorForDrawing(const FloatRect&amp; destRect, const FloatRect&amp; srcRect) const;
501 
502 #if OS(WINDOWS) &amp;&amp; !PLATFORM(JAVA)
503     HDC getWindowsContext(const IntRect&amp;, bool supportAlphaBlend); // The passed in rect is used to create a bitmap for compositing inside transparency layers.
504     void releaseWindowsContext(HDC, const IntRect&amp;, bool supportAlphaBlend); // The passed in HDC should be the one handed back by getWindowsContext.
505     HDC hdc() const;
506 #endif
507 #if PLATFORM(WIN)
508 #if USE(WINGDI)
509     const AffineTransform&amp; affineTransform() const;
510     AffineTransform&amp; affineTransform();
511     void resetAffineTransform();
512     void fillRect(const FloatRect&amp;, const Gradient*);
513     void drawText(const Font&amp;, const GlyphBuffer&amp;, int from, int numGlyphs, const FloatPoint&amp;);
</pre>
<hr />
<pre>
679     }
680 
681     GraphicsContext* context() const { return &amp;m_context; }
682 
683 private:
684     GraphicsContext&amp; m_context;
685     bool m_saveAndRestore;
686 };
687 
688 
689 class GraphicsContextStateStackChecker {
690 public:
691     GraphicsContextStateStackChecker(GraphicsContext&amp; context)
692         : m_context(context)
693         , m_stackSize(context.stackSize())
694     { }
695 
696     ~GraphicsContextStateStackChecker()
697     {
698         if (m_context.stackSize() != m_stackSize)
<span class="line-modified">699             WTFLogAlways(&quot;GraphicsContext %p stack changed by %d&quot;, this, (int)m_context.stackSize() - (int)m_stackSize);</span>
700     }
701 
702 private:
703     GraphicsContext&amp; m_context;
704     unsigned m_stackSize;
705 };
706 
707 
708 
709 class InterpolationQualityMaintainer {
710 public:
711     explicit InterpolationQualityMaintainer(GraphicsContext&amp; graphicsContext, InterpolationQuality interpolationQualityToUse)
712         : m_graphicsContext(graphicsContext)
713         , m_currentInterpolationQuality(graphicsContext.imageInterpolationQuality())
<span class="line-modified">714         , m_interpolationQualityChanged(interpolationQualityToUse != InterpolationDefault &amp;&amp; m_currentInterpolationQuality != interpolationQualityToUse)</span>
715     {
716         if (m_interpolationQualityChanged)
717             m_graphicsContext.setImageInterpolationQuality(interpolationQualityToUse);
718     }
719 
720     explicit InterpolationQualityMaintainer(GraphicsContext&amp; graphicsContext, Optional&lt;InterpolationQuality&gt; interpolationQuality)
721         : InterpolationQualityMaintainer(graphicsContext, interpolationQuality ? interpolationQuality.value() : graphicsContext.imageInterpolationQuality())
722     {
723     }
724 
725     ~InterpolationQualityMaintainer()
726     {
727         if (m_interpolationQualityChanged)
728             m_graphicsContext.setImageInterpolationQuality(m_currentInterpolationQuality);
729     }
730 
731 private:
732     GraphicsContext&amp; m_graphicsContext;
733     InterpolationQuality m_currentInterpolationQuality;
734     bool m_interpolationQualityChanged;
735 };
736 
737 } // namespace WebCore















</pre>
</td>
<td>
<hr />
<pre>
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;DashArray.h&quot;
 30 #include &quot;FloatRect.h&quot;
 31 #include &quot;FontCascade.h&quot;
 32 #include &quot;Gradient.h&quot;
 33 #include &quot;GraphicsTypes.h&quot;
 34 #include &quot;Image.h&quot;
 35 #include &quot;ImageOrientation.h&quot;
 36 #include &quot;ImagePaintingOptions.h&quot;
 37 #include &quot;Pattern.h&quot;
<span class="line-added"> 38 #include &quot;RenderingMode.h&quot;</span>
 39 #include &lt;wtf/Function.h&gt;
 40 #include &lt;wtf/Noncopyable.h&gt;
<span class="line-added"> 41 #include &lt;wtf/OptionSet.h&gt;</span>
 42 
 43 #if USE(CG)
 44 typedef struct CGContext PlatformGraphicsContext;
 45 #elif USE(DIRECT2D)
 46 interface ID2D1DCRenderTarget;
 47 interface ID2D1RenderTarget;
 48 interface ID2D1Factory;
 49 interface ID2D1SolidColorBrush;
 50 namespace WebCore {
 51 class PlatformContextDirect2D;
 52 }
 53 typedef WebCore::PlatformContextDirect2D PlatformGraphicsContext;
 54 #elif USE(CAIRO)
 55 namespace WebCore {
 56 class PlatformContextCairo;
 57 }
 58 typedef WebCore::PlatformContextCairo PlatformGraphicsContext;
 59 #elif USE(WINGDI)
 60 typedef struct HDC__ PlatformGraphicsContext;
 61 #elif PLATFORM(JAVA)
</pre>
<hr />
<pre>
 81 #if defined(None)
 82 #undef None
 83 #endif
 84 
 85 namespace WebCore {
 86 
 87 #if USE(WINGDI)
 88 class SharedBitmap;
 89 class Font;
 90 class GlyphBuffer;
 91 #endif
 92 
 93 class AffineTransform;
 94 class FloatRoundedRect;
 95 class Gradient;
 96 class GraphicsContextImpl;
 97 class GraphicsContextPlatformPrivate;
 98 class ImageBuffer;
 99 class IntRect;
100 class RoundedRect;
<span class="line-modified">101 class GraphicsContextGLOpenGL;</span>
102 class Path;
103 class TextRun;
104 class TransformationMatrix;
105 
106 enum TextDrawingMode {
107     TextModeFill = 1 &lt;&lt; 0,
108     TextModeStroke = 1 &lt;&lt; 1,
109 #if ENABLE(LETTERPRESS)
110     TextModeLetterpress = 1 &lt;&lt; 2,
111 #endif
112 };
113 typedef unsigned TextDrawingModeFlags;
114 
115 enum StrokeStyle {
116     NoStroke,
117     SolidStroke,
118     DottedStroke,
119     DashedStroke,
120     DoubleStroke,
121     WavyStroke,
122 };
123 
124 struct DocumentMarkerLineStyle {
125     enum class Mode : uint8_t {
126         TextCheckingDictationPhraseWithAlternatives,
127         Spelling,
128         Grammar,
129         AutocorrectionReplacement,
130         DictationAlternatives
131     } mode;
132     bool shouldUseDarkAppearance { false };
<span class="line-added">133 </span>
<span class="line-added">134     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">135     template&lt;class Decoder&gt; static Optional&lt;DocumentMarkerLineStyle&gt; decode(Decoder&amp;);</span>
136 };
137 
<span class="line-added">138 template&lt;class Encoder&gt;</span>
<span class="line-added">139 void DocumentMarkerLineStyle::encode(Encoder&amp; encoder) const</span>
<span class="line-added">140 {</span>
<span class="line-added">141     encoder &lt;&lt; mode;</span>
<span class="line-added">142     encoder &lt;&lt; shouldUseDarkAppearance;</span>
<span class="line-added">143 }</span>
<span class="line-added">144 </span>
<span class="line-added">145 template&lt;class Decoder&gt;</span>
<span class="line-added">146 Optional&lt;DocumentMarkerLineStyle&gt; DocumentMarkerLineStyle::decode(Decoder&amp; decoder)</span>
<span class="line-added">147 {</span>
<span class="line-added">148     Optional&lt;Mode&gt; mode;</span>
<span class="line-added">149     decoder &gt;&gt; mode;</span>
<span class="line-added">150     if (!mode)</span>
<span class="line-added">151         return WTF::nullopt;</span>
<span class="line-added">152 </span>
<span class="line-added">153     Optional&lt;bool&gt; shouldUseDarkAppearance;</span>
<span class="line-added">154     decoder &gt;&gt; shouldUseDarkAppearance;</span>
<span class="line-added">155     if (!shouldUseDarkAppearance)</span>
<span class="line-added">156         return WTF::nullopt;</span>
<span class="line-added">157 </span>
<span class="line-added">158     return {{ *mode, *shouldUseDarkAppearance }};</span>
<span class="line-added">159 }</span>
<span class="line-added">160 </span>
161 namespace DisplayList {
162 class Recorder;
163 }
164 
165 struct GraphicsContextState {
166     GraphicsContextState()
167         : shouldAntialias(true)
168         , shouldSmoothFonts(true)
169         , shouldSubpixelQuantizeFonts(true)
170         , shadowsIgnoreTransforms(false)
171 #if USE(CG)
172         // Core Graphics incorrectly renders shadows with radius &gt; 8px (&lt;rdar://problem/8103442&gt;),
173         // but we need to preserve this buggy behavior for canvas and -webkit-box-shadow.
174         , shadowsUseLegacyRadius(false)
175 #endif
176 #if PLATFORM(JAVA)
177         , clipBounds(FloatRect::infiniteRect())
178 #endif
179         , drawLuminanceMask(false)
180     {
181     }
182 
183     enum Change : uint32_t {

184         StrokeGradientChange                    = 1 &lt;&lt; 1,
185         StrokePatternChange                     = 1 &lt;&lt; 2,
186         FillGradientChange                      = 1 &lt;&lt; 3,
187         FillPatternChange                       = 1 &lt;&lt; 4,
188         StrokeThicknessChange                   = 1 &lt;&lt; 5,
189         StrokeColorChange                       = 1 &lt;&lt; 6,
190         StrokeStyleChange                       = 1 &lt;&lt; 7,
191         FillColorChange                         = 1 &lt;&lt; 8,
192         FillRuleChange                          = 1 &lt;&lt; 9,
193         ShadowChange                            = 1 &lt;&lt; 10,
<span class="line-modified">194         ShadowsIgnoreTransformsChange           = 1 &lt;&lt; 11,</span>
<span class="line-modified">195         AlphaChange                             = 1 &lt;&lt; 12,</span>
<span class="line-modified">196         CompositeOperationChange                = 1 &lt;&lt; 13,</span>
<span class="line-modified">197         BlendModeChange                         = 1 &lt;&lt; 14,</span>
<span class="line-modified">198         TextDrawingModeChange                   = 1 &lt;&lt; 15,</span>
<span class="line-modified">199         ShouldAntialiasChange                   = 1 &lt;&lt; 16,</span>
<span class="line-modified">200         ShouldSmoothFontsChange                 = 1 &lt;&lt; 17,</span>
<span class="line-modified">201         ShouldSubpixelQuantizeFontsChange       = 1 &lt;&lt; 18,</span>
<span class="line-modified">202         DrawLuminanceMaskChange                 = 1 &lt;&lt; 19,</span>
<span class="line-modified">203         ImageInterpolationQualityChange         = 1 &lt;&lt; 20,</span>

204 #if HAVE(OS_DARK_MODE_SUPPORT)
<span class="line-modified">205         UseDarkAppearanceChange                 = 1 &lt;&lt; 21,</span>
206 #endif
207     };
<span class="line-modified">208     typedef OptionSet&lt;Change&gt; StateChangeFlags;</span>
209 
210     RefPtr&lt;Gradient&gt; strokeGradient;
211     RefPtr&lt;Pattern&gt; strokePattern;
212 
213     RefPtr&lt;Gradient&gt; fillGradient;
214     RefPtr&lt;Pattern&gt; fillPattern;
215 
216     FloatSize shadowOffset;
217 
218     float strokeThickness { 0 };
219     float shadowBlur { 0 };
220 
221     TextDrawingModeFlags textDrawingMode { TextModeFill };
222 
223     Color strokeColor { Color::black };
224     Color fillColor { Color::black };
225     Color shadowColor;
226 
227     StrokeStyle strokeStyle { SolidStroke };
228     WindRule fillRule { WindRule::NonZero };
229 
230     float alpha { 1 };
<span class="line-modified">231     CompositeOperator compositeOperator { CompositeOperator::SourceOver };</span>
232     BlendMode blendMode { BlendMode::Normal };
<span class="line-modified">233     InterpolationQuality imageInterpolationQuality { InterpolationQuality::Default };</span>
234 
235     bool shouldAntialias : 1;
236     bool shouldSmoothFonts : 1;
237     bool shouldSubpixelQuantizeFonts : 1;
238     bool shadowsIgnoreTransforms : 1;
239 #if USE(CG)
240     bool shadowsUseLegacyRadius : 1;
241 #endif
242 #if PLATFORM(JAVA)
243     AffineTransform transform;
244     FloatRect clipBounds;
245 #endif
246     bool drawLuminanceMask : 1;
247 #if HAVE(OS_DARK_MODE_SUPPORT)
248     bool useDarkAppearance : 1;
249 #endif
250 };
251 
252 struct GraphicsContextStateChange {
253     GraphicsContextStateChange() = default;
254     GraphicsContextStateChange(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
255         : m_state(state)
256         , m_changeFlags(flags)
257     {
258     }
259 
260     GraphicsContextState::StateChangeFlags changesFromState(const GraphicsContextState&amp;) const;
261 
262     void accumulate(const GraphicsContextState&amp;, GraphicsContextState::StateChangeFlags);
263     void apply(GraphicsContext&amp;) const;
264 
265     void dump(WTF::TextStream&amp;) const;
266 
267     GraphicsContextState m_state;
<span class="line-modified">268     GraphicsContextState::StateChangeFlags m_changeFlags;</span>
269 };
270 
271 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const GraphicsContextStateChange&amp;);
272 
273 
274 class GraphicsContext {
275     WTF_MAKE_NONCOPYABLE(GraphicsContext); WTF_MAKE_FAST_ALLOCATED;
276 public:
277     WEBCORE_EXPORT GraphicsContext(PlatformGraphicsContext*);
278 
279     using GraphicsContextImplFactory = WTF::Function&lt;std::unique_ptr&lt;GraphicsContextImpl&gt;(GraphicsContext&amp;)&gt;;
280     WEBCORE_EXPORT GraphicsContext(const GraphicsContextImplFactory&amp;);
281 
282     GraphicsContext() = default;
283     WEBCORE_EXPORT ~GraphicsContext();
284 
285     enum class PaintInvalidationReasons : uint8_t {
286         None,
287         InvalidatingControlTints,
288         InvalidatingImagesWithAsyncDecodes
</pre>
<hr />
<pre>
346     void setShouldSubpixelQuantizeFonts(bool);
347     bool shouldSubpixelQuantizeFonts() const { return m_state.shouldSubpixelQuantizeFonts; }
348 
349     const GraphicsContextState&amp; state() const { return m_state; }
350 
351 #if USE(CG) || USE(DIRECT2D) || USE(CAIRO)
352     WEBCORE_EXPORT void drawNativeImage(const NativeImagePtr&amp;, const FloatSize&amp; selfSize, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp; = { });
353 #endif
354 
355 #if USE(CG) || USE(DIRECT2D)
356     void applyStrokePattern();
357     void applyFillPattern();
358     void drawPath(const Path&amp;);
359 
360     WEBCORE_EXPORT void setIsCALayerContext(bool);
361     bool isCALayerContext() const;
362 
363     WEBCORE_EXPORT void setIsAcceleratedContext(bool);
364 #endif
365     bool isAcceleratedContext() const;
<span class="line-modified">366     RenderingMode renderingMode() const { return isAcceleratedContext() ? RenderingMode::Accelerated : RenderingMode::Unaccelerated; }</span>
367 
368     WEBCORE_EXPORT void save();
369     WEBCORE_EXPORT void restore();
370 
371     unsigned stackSize() const { return m_stack.size(); }
372 
373     // These draw methods will do both stroking and filling.
374     // FIXME: ...except drawRect(), which fills properly but always strokes
375     // using a 1-pixel stroke inset from the rect borders (of the correct
376     // stroke color).
377     void drawRect(const FloatRect&amp;, float borderThickness = 1);
378     void drawLine(const FloatPoint&amp;, const FloatPoint&amp;);
379 
380     void drawEllipse(const FloatRect&amp;);
381     void drawRaisedEllipse(const FloatRect&amp;, const Color&amp; ellipseColor, const Color&amp; shadowColor);
382 
383     WEBCORE_EXPORT void fillPath(const Path&amp;);
384     WEBCORE_EXPORT void strokePath(const Path&amp;);
385 
386     void fillEllipse(const FloatRect&amp;);
387     void strokeEllipse(const FloatRect&amp;);
388 
389     WEBCORE_EXPORT void fillRect(const FloatRect&amp;);
390     WEBCORE_EXPORT void fillRect(const FloatRect&amp;, const Color&amp;);
391     void fillRect(const FloatRect&amp;, Gradient&amp;);
392     void fillRect(const FloatRect&amp;, const Color&amp;, CompositeOperator, BlendMode = BlendMode::Normal);
393     void fillRoundedRect(const FloatRoundedRect&amp;, const Color&amp;, BlendMode = BlendMode::Normal);
394     void fillRectWithRoundedHole(const FloatRect&amp;, const FloatRoundedRect&amp; roundedHoleRect, const Color&amp;);
395 
396     WEBCORE_EXPORT void clearRect(const FloatRect&amp;);
397 
398     WEBCORE_EXPORT void strokeRect(const FloatRect&amp;, float lineWidth);
399 
<span class="line-modified">400     WEBCORE_EXPORT ImageDrawResult drawImage(Image&amp;, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; = { ImageOrientation::FromImage });</span>
<span class="line-modified">401     WEBCORE_EXPORT ImageDrawResult drawImage(Image&amp;, const FloatRect&amp; destination, const ImagePaintingOptions&amp; = { ImageOrientation::FromImage });</span>
<span class="line-modified">402     ImageDrawResult drawImage(Image&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; = { ImageOrientation::FromImage });</span>
403 
404     ImageDrawResult drawTiledImage(Image&amp;, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; = { });
405     ImageDrawResult drawTiledImage(Image&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor, Image::TileRule, Image::TileRule, const ImagePaintingOptions&amp; = { });
406 
407     WEBCORE_EXPORT void drawImageBuffer(ImageBuffer&amp;, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; = { });
408     void drawImageBuffer(ImageBuffer&amp;, const FloatRect&amp; destination, const ImagePaintingOptions&amp; = { });
409     void drawImageBuffer(ImageBuffer&amp;, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; = { });
410 
411     void drawPattern(Image&amp;, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const AffineTransform&amp;, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; = { });
412 
413     WEBCORE_EXPORT void drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt;, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; = { });
414     void drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt;, const FloatRect&amp; destination, const ImagePaintingOptions&amp; = { });
415     void drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt;, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; = { });
416 
417     WEBCORE_EXPORT void setImageInterpolationQuality(InterpolationQuality);
418     InterpolationQuality imageInterpolationQuality() const { return m_state.imageInterpolationQuality; }
419 
420     WEBCORE_EXPORT void clip(const FloatRect&amp;);
421     void clipRoundedRect(const FloatRoundedRect&amp;);
422 
423     void clipOut(const FloatRect&amp;);
424     void clipOutRoundedRect(const FloatRoundedRect&amp;);
425     void clipPath(const Path&amp;, WindRule = WindRule::EvenOdd);
426     void clipToImageBuffer(ImageBuffer&amp;, const FloatRect&amp;);
427 
428     IntRect clipBounds() const;
429 
430     void setTextDrawingMode(TextDrawingModeFlags);
431     TextDrawingModeFlags textDrawingMode() const { return m_state.textDrawingMode; }
432 
433 #if HAVE(OS_DARK_MODE_SUPPORT)
434     void setUseDarkAppearance(bool);
435     bool useDarkAppearance() const { return m_state.useDarkAppearance; }
436 #endif
437 
438     float drawText(const FontCascade&amp;, const TextRun&amp;, const FloatPoint&amp;, unsigned from = 0, Optional&lt;unsigned&gt; to = WTF::nullopt);
439     void drawGlyphs(const Font&amp;, const GlyphBuffer&amp;, unsigned from, unsigned numGlyphs, const FloatPoint&amp;, FontSmoothingMode);
440     void drawEmphasisMarks(const FontCascade&amp;, const TextRun&amp;, const AtomString&amp; mark, const FloatPoint&amp;, unsigned from = 0, Optional&lt;unsigned&gt; to = WTF::nullopt);
441     void drawBidiText(const FontCascade&amp;, const TextRun&amp;, const FloatPoint&amp;, FontCascade::CustomFontNotReadyAction = FontCascade::DoNotPaintIfFontNotReady);
442 
<span class="line-modified">443     void builderState(const GraphicsContextState&amp;);</span>
444 
445     enum RoundingMode {
446         RoundAllSides,
447         RoundOriginAndDimensions
448     };
449     FloatRect roundToDevicePixels(const FloatRect&amp;, RoundingMode = RoundAllSides);
450 
451     FloatRect computeUnderlineBoundsForText(const FloatRect&amp;, bool printing);
452     WEBCORE_EXPORT void drawLineForText(const FloatRect&amp;, bool printing, bool doubleLines = false, StrokeStyle = SolidStroke);
453     void drawLinesForText(const FloatPoint&amp;, float thickness, const DashArray&amp; widths, bool printing, bool doubleLines = false, StrokeStyle = SolidStroke);
454     void drawDotsForDocumentMarker(const FloatRect&amp;, DocumentMarkerLineStyle);
455 
456     WEBCORE_EXPORT void beginTransparencyLayer(float opacity);
457     WEBCORE_EXPORT void endTransparencyLayer();
458     bool isInTransparencyLayer() const { return (m_transparencyCount &gt; 0) &amp;&amp; supportsTransparencyLayers(); }
459 
460     WEBCORE_EXPORT void setShadow(const FloatSize&amp;, float blur, const Color&amp;);
461     // Legacy shadow blur radius is used for canvas, and -webkit-box-shadow.
462     // It has different treatment of radii &gt; 8px.
463     void setLegacyShadow(const FloatSize&amp;, float blur, const Color&amp;);
</pre>
<hr />
<pre>
499 
500     void scale(float s)
501     {
502         scale({ s, s });
503     }
504     WEBCORE_EXPORT void scale(const FloatSize&amp;);
505     void rotate(float angleInRadians);
506     void translate(const FloatSize&amp; size) { translate(size.width(), size.height()); }
507     void translate(const FloatPoint&amp; p) { translate(p.x(), p.y()); }
508     WEBCORE_EXPORT void translate(float x, float y);
509 
510     void setURLForRect(const URL&amp;, const FloatRect&amp;);
511 
512     void setDestinationForRect(const String&amp; name, const FloatRect&amp;);
513     void addDestinationAtPoint(const String&amp; name, const FloatPoint&amp;);
514 
515     void concatCTM(const AffineTransform&amp;);
516     void setCTM(const AffineTransform&amp;);
517 
518     enum IncludeDeviceScale { DefinitelyIncludeDeviceScale, PossiblyIncludeDeviceScale };
<span class="line-modified">519     WEBCORE_EXPORT AffineTransform getCTM(IncludeDeviceScale includeScale = PossiblyIncludeDeviceScale) const;</span>
520 
521     // This function applies the device scale factor to the context, making the context capable of
522     // acting as a base-level context for a HiDPI environment.
523     WEBCORE_EXPORT void applyDeviceScaleFactor(float);
524     void platformApplyDeviceScaleFactor(float);
525     FloatSize scaleFactor() const;
526     FloatSize scaleFactorForDrawing(const FloatRect&amp; destRect, const FloatRect&amp; srcRect) const;
527 
528 #if OS(WINDOWS) &amp;&amp; !PLATFORM(JAVA)
529     HDC getWindowsContext(const IntRect&amp;, bool supportAlphaBlend); // The passed in rect is used to create a bitmap for compositing inside transparency layers.
530     void releaseWindowsContext(HDC, const IntRect&amp;, bool supportAlphaBlend); // The passed in HDC should be the one handed back by getWindowsContext.
531     HDC hdc() const;
532 #endif
533 #if PLATFORM(WIN)
534 #if USE(WINGDI)
535     const AffineTransform&amp; affineTransform() const;
536     AffineTransform&amp; affineTransform();
537     void resetAffineTransform();
538     void fillRect(const FloatRect&amp;, const Gradient*);
539     void drawText(const Font&amp;, const GlyphBuffer&amp;, int from, int numGlyphs, const FloatPoint&amp;);
</pre>
<hr />
<pre>
705     }
706 
707     GraphicsContext* context() const { return &amp;m_context; }
708 
709 private:
710     GraphicsContext&amp; m_context;
711     bool m_saveAndRestore;
712 };
713 
714 
715 class GraphicsContextStateStackChecker {
716 public:
717     GraphicsContextStateStackChecker(GraphicsContext&amp; context)
718         : m_context(context)
719         , m_stackSize(context.stackSize())
720     { }
721 
722     ~GraphicsContextStateStackChecker()
723     {
724         if (m_context.stackSize() != m_stackSize)
<span class="line-modified">725             WTFLogAlways(&quot;GraphicsContext %p stack changed by %d&quot;, &amp;m_context, (int)m_context.stackSize() - (int)m_stackSize);</span>
726     }
727 
728 private:
729     GraphicsContext&amp; m_context;
730     unsigned m_stackSize;
731 };
732 
733 
734 
735 class InterpolationQualityMaintainer {
736 public:
737     explicit InterpolationQualityMaintainer(GraphicsContext&amp; graphicsContext, InterpolationQuality interpolationQualityToUse)
738         : m_graphicsContext(graphicsContext)
739         , m_currentInterpolationQuality(graphicsContext.imageInterpolationQuality())
<span class="line-modified">740         , m_interpolationQualityChanged(interpolationQualityToUse != InterpolationQuality::Default &amp;&amp; m_currentInterpolationQuality != interpolationQualityToUse)</span>
741     {
742         if (m_interpolationQualityChanged)
743             m_graphicsContext.setImageInterpolationQuality(interpolationQualityToUse);
744     }
745 
746     explicit InterpolationQualityMaintainer(GraphicsContext&amp; graphicsContext, Optional&lt;InterpolationQuality&gt; interpolationQuality)
747         : InterpolationQualityMaintainer(graphicsContext, interpolationQuality ? interpolationQuality.value() : graphicsContext.imageInterpolationQuality())
748     {
749     }
750 
751     ~InterpolationQualityMaintainer()
752     {
753         if (m_interpolationQualityChanged)
754             m_graphicsContext.setImageInterpolationQuality(m_currentInterpolationQuality);
755     }
756 
757 private:
758     GraphicsContext&amp; m_graphicsContext;
759     InterpolationQuality m_currentInterpolationQuality;
760     bool m_interpolationQualityChanged;
761 };
762 
763 } // namespace WebCore
<span class="line-added">764 </span>
<span class="line-added">765 namespace WTF {</span>
<span class="line-added">766 </span>
<span class="line-added">767 template&lt;&gt; struct EnumTraits&lt;WebCore::DocumentMarkerLineStyle::Mode&gt; {</span>
<span class="line-added">768     using values = EnumValues&lt;</span>
<span class="line-added">769     WebCore::DocumentMarkerLineStyle::Mode,</span>
<span class="line-added">770     WebCore::DocumentMarkerLineStyle::Mode::TextCheckingDictationPhraseWithAlternatives,</span>
<span class="line-added">771     WebCore::DocumentMarkerLineStyle::Mode::Spelling,</span>
<span class="line-added">772     WebCore::DocumentMarkerLineStyle::Mode::Grammar,</span>
<span class="line-added">773     WebCore::DocumentMarkerLineStyle::Mode::AutocorrectionReplacement,</span>
<span class="line-added">774     WebCore::DocumentMarkerLineStyle::Mode::DictationAlternatives</span>
<span class="line-added">775     &gt;;</span>
<span class="line-added">776 };</span>
<span class="line-added">777 </span>
<span class="line-added">778 } // namespace WTF</span>
</pre>
</td>
</tr>
</table>
<center><a href="GraphicsContext.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GraphicsLayer.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
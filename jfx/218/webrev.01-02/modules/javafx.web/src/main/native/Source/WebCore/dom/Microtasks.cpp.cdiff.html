<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/dom/Microtasks.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MessagePort.idl.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Microtasks.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Microtasks.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 21,90 ***</span>
  
  #include &quot;config.h&quot;
  #include &quot;Microtasks.h&quot;
  
  #include &quot;CommonVM.h&quot;
  #include &quot;WorkerGlobalScope.h&quot;
  #include &lt;wtf/MainThread.h&gt;
  #include &lt;wtf/NeverDestroyed.h&gt;
  #include &lt;wtf/SetForScope.h&gt;
  
  namespace WebCore {
  
<span class="line-removed">- void Microtask::removeSelfFromQueue(MicrotaskQueue&amp; queue)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     queue.remove(*this);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  MicrotaskQueue::MicrotaskQueue(JSC::VM&amp; vm)
      : m_vm(makeRef(vm))
<span class="line-removed">-     , m_timer(*this, &amp;MicrotaskQueue::timerFired)</span>
  {
  }
  
  MicrotaskQueue::~MicrotaskQueue() = default;
  
<span class="line-modified">! MicrotaskQueue&amp; MicrotaskQueue::mainThreadQueue()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     static NeverDestroyed&lt;MicrotaskQueue&gt; queue(commonVM());</span>
<span class="line-removed">-     return queue;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- MicrotaskQueue&amp; MicrotaskQueue::contextQueue(ScriptExecutionContext&amp; context)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // While main thread has many ScriptExecutionContexts, WorkerGlobalScope and worker thread have</span>
<span class="line-removed">-     // one on one correspondence. The lifetime of MicrotaskQueue is aligned to this semantics.</span>
<span class="line-removed">-     // While main thread MicrotaskQueue is persistently held, worker&#39;s MicrotaskQueue is held by</span>
<span class="line-removed">-     // WorkerGlobalScope.</span>
<span class="line-removed">-     if (isMainThread())</span>
<span class="line-removed">-         return mainThreadQueue();</span>
<span class="line-removed">-     return downcast&lt;WorkerGlobalScope&gt;(context).microtaskQueue();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void MicrotaskQueue::append(std::unique_ptr&lt;Microtask&gt;&amp;&amp; task)</span>
  {
      m_microtaskQueue.append(WTFMove(task));
<span class="line-removed">- </span>
<span class="line-removed">-     m_timer.startOneShot(0_s);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void MicrotaskQueue::remove(const Microtask&amp; task)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     for (size_t i = 0; i &lt; m_microtaskQueue.size(); ++i) {</span>
<span class="line-removed">-         if (m_microtaskQueue[i].get() == &amp;task) {</span>
<span class="line-removed">-             m_microtaskQueue.remove(i);</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void MicrotaskQueue::timerFired()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     performMicrotaskCheckpoint();</span>
  }
  
  void MicrotaskQueue::performMicrotaskCheckpoint()
  {
      if (m_performingMicrotaskCheckpoint)
          return;
  
      SetForScope&lt;bool&gt; change(m_performingMicrotaskCheckpoint, true);
      JSC::JSLockHolder locker(vm());
  
<span class="line-modified">!     Vector&lt;std::unique_ptr&lt;Microtask&gt;&gt; toKeep;</span>
      while (!m_microtaskQueue.isEmpty()) {
<span class="line-modified">!         Vector&lt;std::unique_ptr&lt;Microtask&gt;&gt; queue = WTFMove(m_microtaskQueue);</span>
          for (auto&amp; task : queue) {
<span class="line-modified">!             auto result = task-&gt;run();</span>
<span class="line-modified">!             switch (result) {</span>
<span class="line-modified">!             case Microtask::Result::Done:</span>
<span class="line-modified">!                 break;</span>
<span class="line-removed">-             case Microtask::Result::KeepInQueue:</span>
                  toKeep.append(WTFMove(task));
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             }</span>
          }
      }
  
      vm().finalizeSynchronousJSExecution();
      m_microtaskQueue = WTFMove(toKeep);
<span class="line-new-header">--- 21,49 ---</span>
  
  #include &quot;config.h&quot;
  #include &quot;Microtasks.h&quot;
  
  #include &quot;CommonVM.h&quot;
<span class="line-added">+ #include &quot;EventLoop.h&quot;</span>
  #include &quot;WorkerGlobalScope.h&quot;
  #include &lt;wtf/MainThread.h&gt;
  #include &lt;wtf/NeverDestroyed.h&gt;
  #include &lt;wtf/SetForScope.h&gt;
  
  namespace WebCore {
  
  MicrotaskQueue::MicrotaskQueue(JSC::VM&amp; vm)
      : m_vm(makeRef(vm))
  {
  }
  
  MicrotaskQueue::~MicrotaskQueue() = default;
  
<span class="line-modified">! void MicrotaskQueue::append(std::unique_ptr&lt;EventLoopTask&gt;&amp;&amp; task)</span>
  {
      m_microtaskQueue.append(WTFMove(task));
  }
  
  void MicrotaskQueue::performMicrotaskCheckpoint()
  {
      if (m_performingMicrotaskCheckpoint)
          return;
  
      SetForScope&lt;bool&gt; change(m_performingMicrotaskCheckpoint, true);
      JSC::JSLockHolder locker(vm());
  
<span class="line-modified">!     Vector&lt;std::unique_ptr&lt;EventLoopTask&gt;&gt; toKeep;</span>
      while (!m_microtaskQueue.isEmpty()) {
<span class="line-modified">!         Vector&lt;std::unique_ptr&lt;EventLoopTask&gt;&gt; queue = WTFMove(m_microtaskQueue);</span>
          for (auto&amp; task : queue) {
<span class="line-modified">!             auto* group = task-&gt;group();</span>
<span class="line-modified">!             if (!group || group-&gt;isStoppedPermanently())</span>
<span class="line-modified">!                 continue;</span>
<span class="line-modified">!             if (group-&gt;isSuspended())</span>
                  toKeep.append(WTFMove(task));
<span class="line-modified">!             else</span>
<span class="line-modified">!                 task-&gt;execute();</span>
          }
      }
  
      vm().finalizeSynchronousJSExecution();
      m_microtaskQueue = WTFMove(toKeep);
</pre>
<center><a href="MessagePort.idl.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Microtasks.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
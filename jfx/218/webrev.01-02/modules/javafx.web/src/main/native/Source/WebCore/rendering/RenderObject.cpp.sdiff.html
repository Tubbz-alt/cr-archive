<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderMultiColumnFlow.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderObject.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  85 
  86 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderObject);
  87 
  88 #ifndef NDEBUG
  89 
  90 RenderObject::SetLayoutNeededForbiddenScope::SetLayoutNeededForbiddenScope(RenderObject* renderObject, bool isForbidden)
  91     : m_renderObject(renderObject)
  92     , m_preexistingForbidden(m_renderObject-&gt;isSetNeedsLayoutForbidden())
  93 {
  94     m_renderObject-&gt;setNeedsLayoutIsForbidden(isForbidden);
  95 }
  96 
  97 RenderObject::SetLayoutNeededForbiddenScope::~SetLayoutNeededForbiddenScope()
  98 {
  99     m_renderObject-&gt;setNeedsLayoutIsForbidden(m_preexistingForbidden);
 100 }
 101 #endif
 102 
 103 struct SameSizeAsRenderObject {
 104     virtual ~SameSizeAsRenderObject() = default; // Allocate vtable pointer.
<span class="line-modified"> 105 #if !ASSERT_DISABLED</span>
 106     bool weakPtrFactorWasConstructedOnMainThread;
 107 #endif
 108     void* pointers[5];
<span class="line-modified"> 109 #ifndef NDEBUG</span>
 110     unsigned m_debugBitfields : 2;
 111 #endif
 112     unsigned m_bitfields;
 113 };
 114 
 115 COMPILE_ASSERT(sizeof(RenderObject) == sizeof(SameSizeAsRenderObject), RenderObject_should_stay_small);
 116 
 117 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, renderObjectCounter, (&quot;RenderObject&quot;));
 118 
 119 void RenderObjectDeleter::operator() (RenderObject* renderer) const
 120 {
 121     renderer-&gt;destroy();
 122 }
 123 
 124 RenderObject::RenderObject(Node&amp; node)
 125     : CachedImageClient()
 126     , m_node(node)
 127     , m_parent(nullptr)
 128     , m_previous(nullptr)
 129     , m_next(nullptr)
<span class="line-modified"> 130 #ifndef NDEBUG</span>
 131     , m_hasAXObject(false)
 132     , m_setNeedsLayoutForbidden(false)
 133 #endif
 134     , m_bitfields(node)
 135 {
 136     if (RenderView* renderView = node.document().renderView())
 137         renderView-&gt;didCreateRenderer();
 138 #ifndef NDEBUG
 139     renderObjectCounter.increment();
 140 #endif
 141 }
 142 
 143 RenderObject::~RenderObject()
 144 {
 145     view().didDestroyRenderer();
<span class="line-removed"> 146 #ifndef NDEBUG</span>
 147     ASSERT(!m_hasAXObject);

 148     renderObjectCounter.decrement();
 149 #endif
 150     ASSERT(!hasRareData());
 151 }
 152 
 153 RenderTheme&amp; RenderObject::theme() const
 154 {
 155     return RenderTheme::singleton();
 156 }
 157 
 158 bool RenderObject::isDescendantOf(const RenderObject* ancestor) const
 159 {
 160     for (const RenderObject* renderer = this; renderer; renderer = renderer-&gt;m_parent) {
 161         if (renderer == ancestor)
 162             return true;
 163     }
 164     return false;
 165 }
 166 
 167 bool RenderObject::isLegend() const
</pre>
<hr />
<pre>
 477     if (object-&gt;style().width().isIntrinsicOrAuto() || object-&gt;style().height().isIntrinsicOrAuto() || object-&gt;style().height().isPercentOrCalculated())
 478         return false;
 479 
 480     // Table parts can&#39;t be relayout roots since the table is responsible for layouting all the parts.
 481     if (object-&gt;isTablePart())
 482         return false;
 483 
 484     return true;
 485 }
 486 
 487 void RenderObject::clearNeedsLayout()
 488 {
 489     m_bitfields.setNeedsLayout(false);
 490     setEverHadLayout(true);
 491     setPosChildNeedsLayoutBit(false);
 492     setNeedsSimplifiedNormalFlowLayoutBit(false);
 493     setNormalChildNeedsLayoutBit(false);
 494     setNeedsPositionedMovementLayoutBit(false);
 495     if (is&lt;RenderElement&gt;(*this))
 496         downcast&lt;RenderElement&gt;(*this).setAncestorLineBoxDirty(false);
<span class="line-modified"> 497 #ifndef NDEBUG</span>
 498     checkBlockPositionedObjectsNeedLayout();
 499 #endif
 500 }
 501 
 502 static void scheduleRelayoutForSubtree(RenderElement&amp; renderer)
 503 {
 504     if (is&lt;RenderView&gt;(renderer)) {
 505         downcast&lt;RenderView&gt;(renderer).frameView().layoutContext().scheduleLayout();
 506         return;
 507     }
 508 
 509     if (renderer.isRooted())
 510         renderer.view().frameView().layoutContext().scheduleSubtreeLayout(renderer);
 511 }
 512 
 513 void RenderObject::markContainingBlocksForLayout(ScheduleRelayout scheduleRelayout, RenderElement* newRoot)
 514 {
 515     ASSERT(scheduleRelayout == ScheduleRelayout::No || !newRoot);
 516     ASSERT(!isSetNeedsLayoutForbidden());
 517 
</pre>
<hr />
<pre>
 550             if (ancestor-&gt;normalChildNeedsLayout())
 551                 return;
 552             ancestor-&gt;setNormalChildNeedsLayoutBit(true);
 553         }
 554         ASSERT(!ancestor-&gt;isSetNeedsLayoutForbidden());
 555 
 556         if (ancestor == newRoot)
 557             return;
 558 
 559         if (scheduleRelayout == ScheduleRelayout::Yes &amp;&amp; objectIsRelayoutBoundary(ancestor))
 560             break;
 561 
 562         hasOutOfFlowPosition = ancestor-&gt;style().hasOutOfFlowPosition();
 563         ancestor = container;
 564     }
 565 
 566     if (scheduleRelayout == ScheduleRelayout::Yes &amp;&amp; ancestor)
 567         scheduleRelayoutForSubtree(*ancestor);
 568 }
 569 
<span class="line-modified"> 570 #ifndef NDEBUG</span>
 571 void RenderObject::checkBlockPositionedObjectsNeedLayout()
 572 {
 573     ASSERT(!needsLayout());
 574 
 575     if (is&lt;RenderBlock&gt;(*this))
 576         downcast&lt;RenderBlock&gt;(*this).checkPositionedObjectsNeedLayout();
 577 }
<span class="line-modified"> 578 #endif</span>
 579 
 580 void RenderObject::setPreferredLogicalWidthsDirty(bool shouldBeDirty, MarkingBehavior markParents)
 581 {
 582     bool alreadyDirty = preferredLogicalWidthsDirty();
 583     m_bitfields.setPreferredLogicalWidthsDirty(shouldBeDirty);
 584     if (shouldBeDirty &amp;&amp; !alreadyDirty &amp;&amp; markParents == MarkContainingBlockChain &amp;&amp; (isText() || !style().hasOutOfFlowPosition()))
 585         invalidateContainerPreferredLogicalWidths();
 586 }
 587 
 588 void RenderObject::invalidateContainerPreferredLogicalWidths()
 589 {
 590     // In order to avoid pathological behavior when inlines are deeply nested, we do include them
 591     // in the chain that we mark dirty (even though they&#39;re kind of irrelevant).
 592     auto o = isTableCell() ? containingBlock() : container();
 593     while (o &amp;&amp; !o-&gt;preferredLogicalWidthsDirty()) {
 594         // Don&#39;t invalidate the outermost object of an unrooted subtree. That object will be
 595         // invalidated when the subtree is added to the document.
 596         auto container = o-&gt;isTableCell() ? o-&gt;containingBlock() : o-&gt;container();
 597         if (!container &amp;&amp; !o-&gt;isRenderView())
 598             break;
</pre>
<hr />
<pre>
1820 {
1821     static const AffineTransform identity;
1822     return identity;
1823 }
1824 
1825 bool RenderObject::nodeAtFloatPoint(const HitTestRequest&amp;, HitTestResult&amp;, const FloatPoint&amp;, HitTestAction)
1826 {
1827     ASSERT_NOT_REACHED();
1828     return false;
1829 }
1830 
1831 RenderFragmentedFlow* RenderObject::locateEnclosingFragmentedFlow() const
1832 {
1833     RenderBlock* containingBlock = this-&gt;containingBlock();
1834     return containingBlock ? containingBlock-&gt;enclosingFragmentedFlow() : nullptr;
1835 }
1836 
1837 void RenderObject::calculateBorderStyleColor(const BorderStyle&amp; style, const BoxSide&amp; side, Color&amp; color)
1838 {
1839     ASSERT(style == BorderStyle::Inset || style == BorderStyle::Outset);

1840     // This values were derived empirically.
<span class="line-modified">1841     const RGBA32 baseDarkColor = 0xFF202020;</span>
<span class="line-modified">1842     const RGBA32 baseLightColor = 0xFFEBEBEB;</span>

1843     enum Operation { Darken, Lighten };
1844 
1845     Operation operation = (side == BSTop || side == BSLeft) == (style == BorderStyle::Inset) ? Darken : Lighten;
1846 
1847     // Here we will darken the border decoration color when needed. This will yield a similar behavior as in FF.
1848     if (operation == Darken) {
1849         if (differenceSquared(color, Color::black) &gt; differenceSquared(baseDarkColor, Color::black))
1850             color = color.dark();
1851     } else {
1852         if (differenceSquared(color, Color::white) &gt; differenceSquared(baseLightColor, Color::white))
1853             color = color.light();
1854     }
1855 }
1856 
1857 void RenderObject::setIsDragging(bool isDragging)
1858 {
1859     if (isDragging || hasRareData())
1860         ensureRareData().setIsDragging(isDragging);
1861 }
1862 
</pre>
<hr />
<pre>
1885 }
1886 
1887 const RenderObject::RenderObjectRareData&amp; RenderObject::rareData() const
1888 {
1889     ASSERT(hasRareData());
1890     return *rareDataMap().get(this);
1891 }
1892 
1893 RenderObject::RenderObjectRareData&amp; RenderObject::ensureRareData()
1894 {
1895     setHasRareData(true);
1896     return *rareDataMap().ensure(this, [] { return makeUnique&lt;RenderObjectRareData&gt;(); }).iterator-&gt;value;
1897 }
1898 
1899 void RenderObject::removeRareData()
1900 {
1901     rareDataMap().remove(this);
1902     setHasRareData(false);
1903 }
1904 






















1905 #if ENABLE(TREE_DEBUGGING)
1906 
1907 void printRenderTreeForLiveDocuments()
1908 {
1909     for (const auto* document : Document::allDocuments()) {
1910         if (!document-&gt;renderView())
1911             continue;
1912         if (document-&gt;frame() &amp;&amp; document-&gt;frame()-&gt;isMainFrame())
1913             fprintf(stderr, &quot;----------------------main frame--------------------------\n&quot;);
1914         fprintf(stderr, &quot;%s&quot;, document-&gt;url().string().utf8().data());
1915         showRenderTree(document-&gt;renderView());
1916     }
1917 }
1918 
1919 void printLayerTreeForLiveDocuments()
1920 {
1921     for (const auto* document : Document::allDocuments()) {
1922         if (!document-&gt;renderView())
1923             continue;
1924         if (document-&gt;frame() &amp;&amp; document-&gt;frame()-&gt;isMainFrame())
</pre>
</td>
<td>
<hr />
<pre>
  85 
  86 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderObject);
  87 
  88 #ifndef NDEBUG
  89 
  90 RenderObject::SetLayoutNeededForbiddenScope::SetLayoutNeededForbiddenScope(RenderObject* renderObject, bool isForbidden)
  91     : m_renderObject(renderObject)
  92     , m_preexistingForbidden(m_renderObject-&gt;isSetNeedsLayoutForbidden())
  93 {
  94     m_renderObject-&gt;setNeedsLayoutIsForbidden(isForbidden);
  95 }
  96 
  97 RenderObject::SetLayoutNeededForbiddenScope::~SetLayoutNeededForbiddenScope()
  98 {
  99     m_renderObject-&gt;setNeedsLayoutIsForbidden(m_preexistingForbidden);
 100 }
 101 #endif
 102 
 103 struct SameSizeAsRenderObject {
 104     virtual ~SameSizeAsRenderObject() = default; // Allocate vtable pointer.
<span class="line-modified"> 105 #if ASSERT_ENABLED</span>
 106     bool weakPtrFactorWasConstructedOnMainThread;
 107 #endif
 108     void* pointers[5];
<span class="line-modified"> 109 #if ASSERT_ENABLED</span>
 110     unsigned m_debugBitfields : 2;
 111 #endif
 112     unsigned m_bitfields;
 113 };
 114 
 115 COMPILE_ASSERT(sizeof(RenderObject) == sizeof(SameSizeAsRenderObject), RenderObject_should_stay_small);
 116 
 117 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, renderObjectCounter, (&quot;RenderObject&quot;));
 118 
 119 void RenderObjectDeleter::operator() (RenderObject* renderer) const
 120 {
 121     renderer-&gt;destroy();
 122 }
 123 
 124 RenderObject::RenderObject(Node&amp; node)
 125     : CachedImageClient()
 126     , m_node(node)
 127     , m_parent(nullptr)
 128     , m_previous(nullptr)
 129     , m_next(nullptr)
<span class="line-modified"> 130 #if ASSERT_ENABLED</span>
 131     , m_hasAXObject(false)
 132     , m_setNeedsLayoutForbidden(false)
 133 #endif
 134     , m_bitfields(node)
 135 {
 136     if (RenderView* renderView = node.document().renderView())
 137         renderView-&gt;didCreateRenderer();
 138 #ifndef NDEBUG
 139     renderObjectCounter.increment();
 140 #endif
 141 }
 142 
 143 RenderObject::~RenderObject()
 144 {
 145     view().didDestroyRenderer();

 146     ASSERT(!m_hasAXObject);
<span class="line-added"> 147 #ifndef NDEBUG</span>
 148     renderObjectCounter.decrement();
 149 #endif
 150     ASSERT(!hasRareData());
 151 }
 152 
 153 RenderTheme&amp; RenderObject::theme() const
 154 {
 155     return RenderTheme::singleton();
 156 }
 157 
 158 bool RenderObject::isDescendantOf(const RenderObject* ancestor) const
 159 {
 160     for (const RenderObject* renderer = this; renderer; renderer = renderer-&gt;m_parent) {
 161         if (renderer == ancestor)
 162             return true;
 163     }
 164     return false;
 165 }
 166 
 167 bool RenderObject::isLegend() const
</pre>
<hr />
<pre>
 477     if (object-&gt;style().width().isIntrinsicOrAuto() || object-&gt;style().height().isIntrinsicOrAuto() || object-&gt;style().height().isPercentOrCalculated())
 478         return false;
 479 
 480     // Table parts can&#39;t be relayout roots since the table is responsible for layouting all the parts.
 481     if (object-&gt;isTablePart())
 482         return false;
 483 
 484     return true;
 485 }
 486 
 487 void RenderObject::clearNeedsLayout()
 488 {
 489     m_bitfields.setNeedsLayout(false);
 490     setEverHadLayout(true);
 491     setPosChildNeedsLayoutBit(false);
 492     setNeedsSimplifiedNormalFlowLayoutBit(false);
 493     setNormalChildNeedsLayoutBit(false);
 494     setNeedsPositionedMovementLayoutBit(false);
 495     if (is&lt;RenderElement&gt;(*this))
 496         downcast&lt;RenderElement&gt;(*this).setAncestorLineBoxDirty(false);
<span class="line-modified"> 497 #if ASSERT_ENABLED</span>
 498     checkBlockPositionedObjectsNeedLayout();
 499 #endif
 500 }
 501 
 502 static void scheduleRelayoutForSubtree(RenderElement&amp; renderer)
 503 {
 504     if (is&lt;RenderView&gt;(renderer)) {
 505         downcast&lt;RenderView&gt;(renderer).frameView().layoutContext().scheduleLayout();
 506         return;
 507     }
 508 
 509     if (renderer.isRooted())
 510         renderer.view().frameView().layoutContext().scheduleSubtreeLayout(renderer);
 511 }
 512 
 513 void RenderObject::markContainingBlocksForLayout(ScheduleRelayout scheduleRelayout, RenderElement* newRoot)
 514 {
 515     ASSERT(scheduleRelayout == ScheduleRelayout::No || !newRoot);
 516     ASSERT(!isSetNeedsLayoutForbidden());
 517 
</pre>
<hr />
<pre>
 550             if (ancestor-&gt;normalChildNeedsLayout())
 551                 return;
 552             ancestor-&gt;setNormalChildNeedsLayoutBit(true);
 553         }
 554         ASSERT(!ancestor-&gt;isSetNeedsLayoutForbidden());
 555 
 556         if (ancestor == newRoot)
 557             return;
 558 
 559         if (scheduleRelayout == ScheduleRelayout::Yes &amp;&amp; objectIsRelayoutBoundary(ancestor))
 560             break;
 561 
 562         hasOutOfFlowPosition = ancestor-&gt;style().hasOutOfFlowPosition();
 563         ancestor = container;
 564     }
 565 
 566     if (scheduleRelayout == ScheduleRelayout::Yes &amp;&amp; ancestor)
 567         scheduleRelayoutForSubtree(*ancestor);
 568 }
 569 
<span class="line-modified"> 570 #if ASSERT_ENABLED</span>
 571 void RenderObject::checkBlockPositionedObjectsNeedLayout()
 572 {
 573     ASSERT(!needsLayout());
 574 
 575     if (is&lt;RenderBlock&gt;(*this))
 576         downcast&lt;RenderBlock&gt;(*this).checkPositionedObjectsNeedLayout();
 577 }
<span class="line-modified"> 578 #endif // ASSERT_ENABLED</span>
 579 
 580 void RenderObject::setPreferredLogicalWidthsDirty(bool shouldBeDirty, MarkingBehavior markParents)
 581 {
 582     bool alreadyDirty = preferredLogicalWidthsDirty();
 583     m_bitfields.setPreferredLogicalWidthsDirty(shouldBeDirty);
 584     if (shouldBeDirty &amp;&amp; !alreadyDirty &amp;&amp; markParents == MarkContainingBlockChain &amp;&amp; (isText() || !style().hasOutOfFlowPosition()))
 585         invalidateContainerPreferredLogicalWidths();
 586 }
 587 
 588 void RenderObject::invalidateContainerPreferredLogicalWidths()
 589 {
 590     // In order to avoid pathological behavior when inlines are deeply nested, we do include them
 591     // in the chain that we mark dirty (even though they&#39;re kind of irrelevant).
 592     auto o = isTableCell() ? containingBlock() : container();
 593     while (o &amp;&amp; !o-&gt;preferredLogicalWidthsDirty()) {
 594         // Don&#39;t invalidate the outermost object of an unrooted subtree. That object will be
 595         // invalidated when the subtree is added to the document.
 596         auto container = o-&gt;isTableCell() ? o-&gt;containingBlock() : o-&gt;container();
 597         if (!container &amp;&amp; !o-&gt;isRenderView())
 598             break;
</pre>
<hr />
<pre>
1820 {
1821     static const AffineTransform identity;
1822     return identity;
1823 }
1824 
1825 bool RenderObject::nodeAtFloatPoint(const HitTestRequest&amp;, HitTestResult&amp;, const FloatPoint&amp;, HitTestAction)
1826 {
1827     ASSERT_NOT_REACHED();
1828     return false;
1829 }
1830 
1831 RenderFragmentedFlow* RenderObject::locateEnclosingFragmentedFlow() const
1832 {
1833     RenderBlock* containingBlock = this-&gt;containingBlock();
1834     return containingBlock ? containingBlock-&gt;enclosingFragmentedFlow() : nullptr;
1835 }
1836 
1837 void RenderObject::calculateBorderStyleColor(const BorderStyle&amp; style, const BoxSide&amp; side, Color&amp; color)
1838 {
1839     ASSERT(style == BorderStyle::Inset || style == BorderStyle::Outset);
<span class="line-added">1840 </span>
1841     // This values were derived empirically.
<span class="line-modified">1842     constexpr SimpleColor baseDarkColor { 0xFF202020 };</span>
<span class="line-modified">1843     constexpr SimpleColor baseLightColor { 0xFFEBEBEB };</span>
<span class="line-added">1844 </span>
1845     enum Operation { Darken, Lighten };
1846 
1847     Operation operation = (side == BSTop || side == BSLeft) == (style == BorderStyle::Inset) ? Darken : Lighten;
1848 
1849     // Here we will darken the border decoration color when needed. This will yield a similar behavior as in FF.
1850     if (operation == Darken) {
1851         if (differenceSquared(color, Color::black) &gt; differenceSquared(baseDarkColor, Color::black))
1852             color = color.dark();
1853     } else {
1854         if (differenceSquared(color, Color::white) &gt; differenceSquared(baseLightColor, Color::white))
1855             color = color.light();
1856     }
1857 }
1858 
1859 void RenderObject::setIsDragging(bool isDragging)
1860 {
1861     if (isDragging || hasRareData())
1862         ensureRareData().setIsDragging(isDragging);
1863 }
1864 
</pre>
<hr />
<pre>
1887 }
1888 
1889 const RenderObject::RenderObjectRareData&amp; RenderObject::rareData() const
1890 {
1891     ASSERT(hasRareData());
1892     return *rareDataMap().get(this);
1893 }
1894 
1895 RenderObject::RenderObjectRareData&amp; RenderObject::ensureRareData()
1896 {
1897     setHasRareData(true);
1898     return *rareDataMap().ensure(this, [] { return makeUnique&lt;RenderObjectRareData&gt;(); }).iterator-&gt;value;
1899 }
1900 
1901 void RenderObject::removeRareData()
1902 {
1903     rareDataMap().remove(this);
1904     setHasRareData(false);
1905 }
1906 
<span class="line-added">1907 bool RenderObject::hasNonEmptyVisibleRectRespectingParentFrames() const</span>
<span class="line-added">1908 {</span>
<span class="line-added">1909     auto enclosingFrameRenderer = [] (const RenderObject&amp; renderer) {</span>
<span class="line-added">1910         auto* ownerElement = renderer.document().ownerElement();</span>
<span class="line-added">1911         return ownerElement ? ownerElement-&gt;renderer() : nullptr;</span>
<span class="line-added">1912     };</span>
<span class="line-added">1913 </span>
<span class="line-added">1914     auto hasEmptyVisibleRect = [] (const RenderObject&amp; renderer) {</span>
<span class="line-added">1915         VisibleRectContext context { false, false, { VisibleRectContextOption::UseEdgeInclusiveIntersection, VisibleRectContextOption::ApplyCompositedClips }};</span>
<span class="line-added">1916         auto&amp; box = renderer.enclosingBoxModelObject();</span>
<span class="line-added">1917         auto clippedBounds = box.computeVisibleRectInContainer(box.borderBoundingBox(), &amp;box.view(), context);</span>
<span class="line-added">1918         return !clippedBounds || clippedBounds-&gt;isEmpty();</span>
<span class="line-added">1919     };</span>
<span class="line-added">1920 </span>
<span class="line-added">1921     for (auto* renderer = this; renderer; renderer = enclosingFrameRenderer(*renderer)) {</span>
<span class="line-added">1922         if (hasEmptyVisibleRect(*renderer))</span>
<span class="line-added">1923             return true;</span>
<span class="line-added">1924     }</span>
<span class="line-added">1925 </span>
<span class="line-added">1926     return false;</span>
<span class="line-added">1927 }</span>
<span class="line-added">1928 </span>
1929 #if ENABLE(TREE_DEBUGGING)
1930 
1931 void printRenderTreeForLiveDocuments()
1932 {
1933     for (const auto* document : Document::allDocuments()) {
1934         if (!document-&gt;renderView())
1935             continue;
1936         if (document-&gt;frame() &amp;&amp; document-&gt;frame()-&gt;isMainFrame())
1937             fprintf(stderr, &quot;----------------------main frame--------------------------\n&quot;);
1938         fprintf(stderr, &quot;%s&quot;, document-&gt;url().string().utf8().data());
1939         showRenderTree(document-&gt;renderView());
1940     }
1941 }
1942 
1943 void printLayerTreeForLiveDocuments()
1944 {
1945     for (const auto* document : Document::allDocuments()) {
1946         if (!document-&gt;renderView())
1947             continue;
1948         if (document-&gt;frame() &amp;&amp; document-&gt;frame()-&gt;isMainFrame())
</pre>
</td>
</tr>
</table>
<center><a href="RenderMultiColumnFlow.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderObject.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
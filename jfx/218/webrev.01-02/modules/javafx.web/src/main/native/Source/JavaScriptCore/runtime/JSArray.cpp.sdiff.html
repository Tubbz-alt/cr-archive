<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArray.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IteratorPrototype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSArray.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArray.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">   3  *  Copyright (C) 2003-2018 Apple Inc. All rights reserved.</span>
   4  *  Copyright (C) 2003 Peter Kelly (pmk@post.com)
   5  *  Copyright (C) 2006 Alexey Proskuryakov (ap@nypop.com)
   6  *
   7  *  This library is free software; you can redistribute it and/or
   8  *  modify it under the terms of the GNU Lesser General Public
   9  *  License as published by the Free Software Foundation; either
  10  *  version 2 of the License, or (at your option) any later version.
  11  *
  12  *  This library is distributed in the hope that it will be useful,
  13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  *  Lesser General Public License for more details.
  16  *
  17  *  You should have received a copy of the GNU Lesser General Public
  18  *  License along with this library; if not, write to the Free Software
  19  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
</pre>
<hr />
<pre>
  64         void* temp = vm.jsValueGigacageAuxiliarySpace.allocateNonVirtual(
  65             vm,
  66             Butterfly::totalSize(0, outOfLineStorage, true, vectorLength * sizeof(EncodedJSValue)),
  67             deferralContext, AllocationFailureMode::ReturnNull);
  68         if (UNLIKELY(!temp))
  69             return nullptr;
  70         butterfly = Butterfly::fromBase(temp, 0, outOfLineStorage);
  71         butterfly-&gt;setVectorLength(vectorLength);
  72         butterfly-&gt;setPublicLength(initialLength);
  73         if (hasDouble(indexingType)) {
  74             for (unsigned i = initialLength; i &lt; vectorLength; ++i)
  75                 butterfly-&gt;contiguousDouble().atUnsafe(i) = PNaN;
  76         } else {
  77             for (unsigned i = initialLength; i &lt; vectorLength; ++i)
  78                 butterfly-&gt;contiguous().atUnsafe(i).clear();
  79         }
  80     } else {
  81         ASSERT(
  82             indexingType == ArrayWithSlowPutArrayStorage
  83             || indexingType == ArrayWithArrayStorage);
<span class="line-modified">  84         static const unsigned indexBias = 0;</span>
  85         unsigned vectorLength = ArrayStorage::optimalVectorLength(indexBias, structure, initialLength);
  86         void* temp = vm.jsValueGigacageAuxiliarySpace.allocateNonVirtual(
  87             vm,
  88             Butterfly::totalSize(indexBias, outOfLineStorage, true, ArrayStorage::sizeFor(vectorLength)),
  89             deferralContext, AllocationFailureMode::ReturnNull);
  90         if (UNLIKELY(!temp))
  91             return nullptr;
  92         butterfly = Butterfly::fromBase(temp, indexBias, outOfLineStorage);
  93         *butterfly-&gt;indexingHeader() = indexingHeaderForArrayStorage(initialLength, vectorLength);
  94         ArrayStorage* storage = butterfly-&gt;arrayStorage();
  95         storage-&gt;m_indexBias = indexBias;
  96         storage-&gt;m_sparseMap.clear();
  97         storage-&gt;m_numValuesInVector = initialLength;
  98         for (unsigned i = initialLength; i &lt; vectorLength; ++i)
  99             storage-&gt;m_vector[i].clear();
 100     }
 101 
 102     JSArray* result = createWithButterfly(vm, deferralContext, structure, butterfly);
 103 
 104     const bool createUninitialized = true;
</pre>
<hr />
<pre>
 117     // tryCreateUninitializedRestricted() already initialized the elements between
 118     // initialLength and vector length. We just need to do 0 - initialLength.
 119     // ObjectInitializationScope::notifyInitialized() will verify that all elements are
 120     // initialized.
 121     if (LIKELY(!hasAnyArrayStorage(indexingType))) {
 122         if (hasDouble(indexingType)) {
 123             for (unsigned i = 0; i &lt; initialLength; ++i)
 124                 butterfly-&gt;contiguousDouble().atUnsafe(i) = PNaN;
 125         } else {
 126             for (unsigned i = 0; i &lt; initialLength; ++i)
 127                 butterfly-&gt;contiguous().atUnsafe(i).clear();
 128         }
 129     } else {
 130         ArrayStorage* storage = butterfly-&gt;arrayStorage();
 131         for (unsigned i = 0; i &lt; initialLength; ++i)
 132             storage-&gt;m_vector[i].clear();
 133     }
 134     scope.notifyInitialized(array);
 135 }
 136 
<span class="line-modified"> 137 void JSArray::setLengthWritable(ExecState* exec, bool writable)</span>
 138 {
 139     ASSERT(isLengthWritable() || !writable);
 140     if (!isLengthWritable() || writable)
 141         return;
 142 
<span class="line-modified"> 143     enterDictionaryIndexingMode(exec-&gt;vm());</span>
 144 
 145     SparseArrayValueMap* map = arrayStorage()-&gt;m_sparseMap.get();
 146     ASSERT(map);
 147     map-&gt;setLengthIsReadOnly();
 148 }
 149 
 150 // Defined in ES5.1 15.4.5.1
<span class="line-modified"> 151 bool JSArray::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool throwException)</span>
 152 {
<span class="line-modified"> 153     VM&amp; vm = exec-&gt;vm();</span>
 154     auto scope = DECLARE_THROW_SCOPE(vm);
 155 
 156     JSArray* array = jsCast&lt;JSArray*&gt;(object);
 157 
 158     // 3. If P is &quot;length&quot;, then
 159     if (propertyName == vm.propertyNames-&gt;length) {
 160         // All paths through length definition call the default [[DefineOwnProperty]], hence:
 161         // from ES5.1 8.12.9 7.a.
 162         if (descriptor.configurablePresent() &amp;&amp; descriptor.configurable())
<span class="line-modified"> 163             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeConfigurabilityError);</span>
 164         // from ES5.1 8.12.9 7.b.
 165         if (descriptor.enumerablePresent() &amp;&amp; descriptor.enumerable())
<span class="line-modified"> 166             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeEnumerabilityError);</span>
 167 
 168         // a. If the [[Value]] field of Desc is absent, then
 169         // a.i. Return the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, Desc, and Throw as arguments.
 170         if (descriptor.isAccessorDescriptor())
<span class="line-modified"> 171             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);</span>
 172         // from ES5.1 8.12.9 10.a.
 173         if (!array-&gt;isLengthWritable() &amp;&amp; descriptor.writablePresent() &amp;&amp; descriptor.writable())
<span class="line-modified"> 174             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeWritabilityError);</span>
 175         // This descriptor is either just making length read-only, or changing nothing!
 176         if (!descriptor.value()) {
 177             if (descriptor.writablePresent())
<span class="line-modified"> 178                 array-&gt;setLengthWritable(exec, descriptor.writable());</span>
 179             return true;
 180         }
 181 
 182         // b. Let newLenDesc be a copy of Desc.
 183         // c. Let newLen be ToUint32(Desc.[[Value]]).
<span class="line-modified"> 184         unsigned newLen = descriptor.value().toUInt32(exec);</span>
 185         RETURN_IF_EXCEPTION(scope, false);
 186         // d. If newLen is not equal to ToNumber( Desc.[[Value]]), throw a RangeError exception.
<span class="line-modified"> 187         double valueAsNumber = descriptor.value().toNumber(exec);</span>
 188         RETURN_IF_EXCEPTION(scope, false);
 189         if (newLen != valueAsNumber) {
<span class="line-modified"> 190             JSC::throwException(exec, scope, createRangeError(exec, &quot;Invalid array length&quot;_s));</span>
 191             return false;
 192         }
 193 
 194         // Based on SameValue check in 8.12.9, this is always okay.
 195         // FIXME: Nothing prevents this from being called on a RuntimeArray, and the length function will always return 0 in that case.
 196         if (newLen == array-&gt;length()) {
 197             if (descriptor.writablePresent())
<span class="line-modified"> 198                 array-&gt;setLengthWritable(exec, descriptor.writable());</span>
 199             return true;
 200         }
 201 
 202         // e. Set newLenDesc.[[Value] to newLen.
 203         // f. If newLen &gt;= oldLen, then
 204         // f.i. Return the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, newLenDesc, and Throw as arguments.
 205         // g. Reject if oldLenDesc.[[Writable]] is false.
 206         if (!array-&gt;isLengthWritable())
<span class="line-modified"> 207             return typeError(exec, scope, throwException, ReadonlyPropertyChangeError);</span>
 208 
 209         // h. If newLenDesc.[[Writable]] is absent or has the value true, let newWritable be true.
 210         // i. Else,
 211         // i.i. Need to defer setting the [[Writable]] attribute to false in case any elements cannot be deleted.
 212         // i.ii. Let newWritable be false.
 213         // i.iii. Set newLenDesc.[[Writable] to true.
 214         // j. Let succeeded be the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, newLenDesc, and Throw as arguments.
 215         // k. If succeeded is false, return false.
 216         // l. While newLen &lt; oldLen repeat,
 217         // l.i. Set oldLen to oldLen – 1.
 218         // l.ii. Let deleteSucceeded be the result of calling the [[Delete]] internal method of A passing ToString(oldLen) and false as arguments.
 219         // l.iii. If deleteSucceeded is false, then
<span class="line-modified"> 220         bool success = array-&gt;setLength(exec, newLen, throwException);</span>
 221         EXCEPTION_ASSERT(!scope.exception() || !success);
 222         if (!success) {
 223             // 1. Set newLenDesc.[[Value] to oldLen+1.
 224             // 2. If newWritable is false, set newLenDesc.[[Writable] to false.
 225             // 3. Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, newLenDesc, and false as arguments.
 226             // 4. Reject.
 227             if (descriptor.writablePresent())
<span class="line-modified"> 228                 array-&gt;setLengthWritable(exec, descriptor.writable());</span>
 229             return false;
 230         }
 231 
 232         // m. If newWritable is false, then
 233         // i. Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;,
 234         //    Property Descriptor{[[Writable]]: false}, and false as arguments. This call will always
 235         //    return true.
 236         if (descriptor.writablePresent())
<span class="line-modified"> 237             array-&gt;setLengthWritable(exec, descriptor.writable());</span>
 238         // n. Return true.
 239         return true;
 240     }
 241 
 242     // 4. Else if P is an array index (15.4), then
 243     // a. Let index be ToUint32(P).
 244     if (Optional&lt;uint32_t&gt; optionalIndex = parseIndex(propertyName)) {
 245         // b. Reject if index &gt;= oldLen and oldLenDesc.[[Writable]] is false.
 246         uint32_t index = optionalIndex.value();
 247         // FIXME: Nothing prevents this from being called on a RuntimeArray, and the length function will always return 0 in that case.
 248         if (index &gt;= array-&gt;length() &amp;&amp; !array-&gt;isLengthWritable())
<span class="line-modified"> 249             return typeError(exec, scope, throwException, &quot;Attempting to define numeric property on array with non-writable length property.&quot;_s);</span>
 250         // c. Let succeeded be the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing P, Desc, and false as arguments.
 251         // d. Reject if succeeded is false.
 252         // e. If index &gt;= oldLen
 253         // e.i. Set oldLenDesc.[[Value]] to index + 1.
 254         // e.ii. Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, oldLenDesc, and false as arguments. This call will always return true.
 255         // f. Return true.
<span class="line-modified"> 256         RELEASE_AND_RETURN(scope, array-&gt;defineOwnIndexedProperty(exec, index, descriptor, throwException));</span>
 257     }
 258 
<span class="line-modified"> 259     RELEASE_AND_RETURN(scope, array-&gt;JSObject::defineOwnNonIndexProperty(exec, propertyName, descriptor, throwException));</span>
 260 }
 261 
<span class="line-modified"> 262 bool JSArray::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
 263 {
<span class="line-modified"> 264     VM&amp; vm = exec-&gt;vm();</span>
 265     JSArray* thisObject = jsCast&lt;JSArray*&gt;(object);
 266     if (propertyName == vm.propertyNames-&gt;length) {
 267         unsigned attributes = thisObject-&gt;isLengthWritable() ? PropertyAttribute::DontDelete | PropertyAttribute::DontEnum : PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly;
 268         slot.setValue(thisObject, attributes, jsNumber(thisObject-&gt;length()));
 269         return true;
 270     }
 271 
<span class="line-modified"> 272     return JSObject::getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>
 273 }
 274 
 275 // ECMA 15.4.5.1
<span class="line-modified"> 276 bool JSArray::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
 277 {
<span class="line-modified"> 278     VM&amp; vm = exec-&gt;vm();</span>
 279     auto scope = DECLARE_THROW_SCOPE(vm);
 280 
 281     JSArray* thisObject = jsCast&lt;JSArray*&gt;(cell);
 282 
 283     if (UNLIKELY(isThisValueAltered(slot, thisObject)))
<span class="line-modified"> 284         RELEASE_AND_RETURN(scope, ordinarySetSlow(exec, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode()));</span>
 285 
 286     thisObject-&gt;ensureWritable(vm);
 287 
 288     if (propertyName == vm.propertyNames-&gt;length) {
 289         if (!thisObject-&gt;isLengthWritable()) {
 290             if (slot.isStrictMode())
<span class="line-modified"> 291                 throwTypeError(exec, scope, &quot;Array length is not writable&quot;_s);</span>
 292             return false;
 293         }
 294 
<span class="line-modified"> 295         unsigned newLength = value.toUInt32(exec);</span>
 296         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified"> 297         double valueAsNumber = value.toNumber(exec);</span>
 298         RETURN_IF_EXCEPTION(scope, false);
 299         if (valueAsNumber != static_cast&lt;double&gt;(newLength)) {
<span class="line-modified"> 300             throwException(exec, scope, createRangeError(exec, &quot;Invalid array length&quot;_s));</span>
 301             return false;
 302         }
<span class="line-modified"> 303         RELEASE_AND_RETURN(scope, thisObject-&gt;setLength(exec, newLength, slot.isStrictMode()));</span>
 304     }
 305 
<span class="line-modified"> 306     RELEASE_AND_RETURN(scope, JSObject::put(thisObject, exec, propertyName, value, slot));</span>
 307 }
 308 
<span class="line-modified"> 309 bool JSArray::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)</span>
 310 {
<span class="line-modified"> 311     VM&amp; vm = exec-&gt;vm();</span>
 312     JSArray* thisObject = jsCast&lt;JSArray*&gt;(cell);
 313 
 314     if (propertyName == vm.propertyNames-&gt;length)
 315         return false;
 316 
<span class="line-modified"> 317     return JSObject::deleteProperty(thisObject, exec, propertyName);</span>
 318 }
 319 
 320 static int compareKeysForQSort(const void* a, const void* b)
 321 {
 322     unsigned da = *static_cast&lt;const unsigned*&gt;(a);
 323     unsigned db = *static_cast&lt;const unsigned*&gt;(b);
 324     return (da &gt; db) - (da &lt; db);
 325 }
 326 
<span class="line-modified"> 327 void JSArray::getOwnNonIndexPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
 328 {
<span class="line-modified"> 329     VM&amp; vm = exec-&gt;vm();</span>
 330     JSArray* thisObject = jsCast&lt;JSArray*&gt;(object);
 331 
 332     if (mode.includeDontEnumProperties())
 333         propertyNames.add(vm.propertyNames-&gt;length);
 334 
<span class="line-modified"> 335     JSObject::getOwnNonIndexPropertyNames(thisObject, exec, propertyNames, mode);</span>
 336 }
 337 
 338 // This method makes room in the vector, but leaves the new space for count slots uncleared.
 339 bool JSArray::unshiftCountSlowCase(const AbstractLocker&amp;, VM&amp; vm, DeferGC&amp;, bool addToFront, unsigned count)
 340 {
 341     ASSERT(cellLock().isLocked());
 342 
 343     ArrayStorage* storage = ensureArrayStorage(vm);
 344     Butterfly* butterfly = storage-&gt;butterfly();
 345     Structure* structure = this-&gt;structure(vm);
 346     unsigned propertyCapacity = structure-&gt;outOfLineCapacity();
 347     unsigned propertySize = structure-&gt;outOfLineSize();
 348 
 349     // If not, we should have handled this on the fast path.
 350     ASSERT(!addToFront || count &gt; storage-&gt;m_indexBias);
 351 
 352     // Step 1:
 353     // Gather 4 key metrics:
 354     //  * usedVectorLength - how many entries are currently in the vector (conservative estimate - fewer may be in use in sparse vectors).
 355     //  * requiredVectorLength - how many entries are will there be in the vector, after allocating space for &#39;count&#39; more.
</pre>
<hr />
<pre>
 404     // If it did, we calculate the amount that will remain based on an atomic decay - leave the
 405     // vector with half the post-capacity it had previously.
 406     unsigned postCapacity = 0;
 407     if (!addToFront)
 408         postCapacity = newStorageCapacity - requiredVectorLength;
 409     else if (length &lt; storage-&gt;vectorLength()) {
 410         // Atomic decay, + the post-capacity cannot be greater than what is available.
 411         postCapacity = std::min((storage-&gt;vectorLength() - length) &gt;&gt; 1, newStorageCapacity - requiredVectorLength);
 412         // If we&#39;re moving contents within the same allocation, the post-capacity is being reduced.
 413         ASSERT(newAllocBase != butterfly-&gt;base(structure) || postCapacity &lt; storage-&gt;vectorLength() - length);
 414     }
 415 
 416     unsigned newVectorLength = requiredVectorLength + postCapacity;
 417     RELEASE_ASSERT(newVectorLength &lt;= MAX_STORAGE_VECTOR_LENGTH);
 418     unsigned preCapacity = newStorageCapacity - newVectorLength;
 419 
 420     Butterfly* newButterfly = Butterfly::fromBase(newAllocBase, preCapacity, propertyCapacity);
 421 
 422     if (addToFront) {
 423         ASSERT(count + usedVectorLength &lt;= newVectorLength);
<span class="line-modified"> 424         memmove(newButterfly-&gt;arrayStorage()-&gt;m_vector + count, storage-&gt;m_vector, sizeof(JSValue) * usedVectorLength);</span>
<span class="line-modified"> 425         memmove(newButterfly-&gt;propertyStorage() - propertySize, butterfly-&gt;propertyStorage() - propertySize, sizeof(JSValue) * propertySize + sizeof(IndexingHeader) + ArrayStorage::sizeFor(0));</span>
 426 
 427         // We don&#39;t need to zero the pre-capacity for the concurrent GC because it is not available to use as property storage.
<span class="line-modified"> 428         memset(newButterfly-&gt;base(0, propertyCapacity), 0, (propertyCapacity - propertySize) * sizeof(JSValue));</span>
 429 
 430         if (allocatedNewStorage) {
 431             // We will set the vectorLength to newVectorLength. We populated requiredVectorLength
 432             // (usedVectorLength + count), which is less. Clear the difference.
 433             for (unsigned i = requiredVectorLength; i &lt; newVectorLength; ++i)
 434                 newButterfly-&gt;arrayStorage()-&gt;m_vector[i].clear();
 435         }
 436     } else if ((newAllocBase != butterfly-&gt;base(structure)) || (preCapacity != storage-&gt;m_indexBias)) {
<span class="line-modified"> 437         memmove(newButterfly-&gt;propertyStorage() - propertyCapacity, butterfly-&gt;propertyStorage() - propertyCapacity, sizeof(JSValue) * propertyCapacity + sizeof(IndexingHeader) + ArrayStorage::sizeFor(0));</span>
<span class="line-modified"> 438         memmove(newButterfly-&gt;arrayStorage()-&gt;m_vector, storage-&gt;m_vector, sizeof(JSValue) * usedVectorLength);</span>
 439 
 440         for (unsigned i = requiredVectorLength; i &lt; newVectorLength; i++)
 441             newButterfly-&gt;arrayStorage()-&gt;m_vector[i].clear();
 442     }
 443 
 444     newButterfly-&gt;arrayStorage()-&gt;setVectorLength(newVectorLength);
 445     newButterfly-&gt;arrayStorage()-&gt;m_indexBias = preCapacity;
 446 
 447     setButterfly(vm, newButterfly);
 448 
 449     return true;
 450 }
 451 
<span class="line-modified"> 452 bool JSArray::setLengthWithArrayStorage(ExecState* exec, unsigned newLength, bool throwException, ArrayStorage* storage)</span>
 453 {
<span class="line-modified"> 454     VM&amp; vm = exec-&gt;vm();</span>
 455     auto scope = DECLARE_THROW_SCOPE(vm);
 456 
 457     unsigned length = storage-&gt;length();
 458 
 459     // If the length is read only then we enter sparse mode, so should enter the following &#39;if&#39;.
 460     ASSERT(isLengthWritable() || storage-&gt;m_sparseMap);
 461 
 462     if (SparseArrayValueMap* map = storage-&gt;m_sparseMap.get()) {
 463         // Fail if the length is not writable.
 464         if (map-&gt;lengthIsReadOnly())
<span class="line-modified"> 465             return typeError(exec, scope, throwException, ReadonlyPropertyWriteError);</span>
 466 
 467         if (newLength &lt; length) {
 468             // Copy any keys we might be interested in into a vector.
 469             Vector&lt;unsigned, 0, UnsafeVectorOverflow&gt; keys;
 470             keys.reserveInitialCapacity(std::min(map-&gt;size(), static_cast&lt;size_t&gt;(length - newLength)));
 471             SparseArrayValueMap::const_iterator end = map-&gt;end();
 472             for (SparseArrayValueMap::const_iterator it = map-&gt;begin(); it != end; ++it) {
 473                 unsigned index = static_cast&lt;unsigned&gt;(it-&gt;key);
 474                 if (index &lt; length &amp;&amp; index &gt;= newLength)
 475                     keys.append(index);
 476             }
 477 
 478             // Check if the array is in sparse mode. If so there may be non-configurable
 479             // properties, so we have to perform deletion with caution, if not we can
 480             // delete values in any order.
 481             if (map-&gt;sparseMode()) {
 482                 qsort(keys.begin(), keys.size(), sizeof(unsigned), compareKeysForQSort);
 483                 unsigned i = keys.size();
 484                 while (i) {
 485                     unsigned index = keys[--i];
 486                     SparseArrayValueMap::iterator it = map-&gt;find(index);
 487                     ASSERT(it != map-&gt;notFound());
 488                     if (it-&gt;value.attributes() &amp; PropertyAttribute::DontDelete) {
 489                         storage-&gt;setLength(index + 1);
<span class="line-modified"> 490                         return typeError(exec, scope, throwException, UnableToDeletePropertyError);</span>
 491                     }
 492                     map-&gt;remove(it);
 493                 }
 494             } else {
 495                 for (unsigned i = 0; i &lt; keys.size(); ++i)
 496                     map-&gt;remove(keys[i]);
 497                 if (map-&gt;isEmpty())
 498                     deallocateSparseIndexMap();
 499             }
 500         }
 501     }
 502 
 503     if (newLength &lt; length) {
 504         // Delete properties from the vector.
 505         unsigned usedVectorLength = std::min(length, storage-&gt;vectorLength());
 506         for (unsigned i = newLength; i &lt; usedVectorLength; ++i) {
 507             WriteBarrier&lt;Unknown&gt;&amp; valueSlot = storage-&gt;m_vector[i];
 508             bool hadValue = !!valueSlot;
 509             valueSlot.clear();
 510             storage-&gt;m_numValuesInVector -= hadValue;
 511         }
 512     }
 513 
 514     storage-&gt;setLength(newLength);
 515 
 516     return true;
 517 }
 518 
<span class="line-modified"> 519 bool JSArray::appendMemcpy(ExecState* exec, VM&amp; vm, unsigned startIndex, JSC::JSArray* otherArray)</span>
 520 {
 521     auto scope = DECLARE_THROW_SCOPE(vm);
 522 
 523     if (!canFastCopy(vm, otherArray))
 524         return false;
 525 
 526     IndexingType type = indexingType();
 527     IndexingType otherType = otherArray-&gt;indexingType();
 528     IndexingType copyType = mergeIndexingTypeForCopying(otherType);
 529     if (type == ArrayWithUndecided &amp;&amp; copyType != NonArray) {
 530         if (copyType == ArrayWithInt32)
 531             convertUndecidedToInt32(vm);
 532         else if (copyType == ArrayWithDouble)
 533             convertUndecidedToDouble(vm);
 534         else if (copyType == ArrayWithContiguous)
 535             convertUndecidedToContiguous(vm);
 536         else {
 537             ASSERT(copyType == ArrayWithUndecided);
 538             return true;
 539         }
 540     } else if (type != copyType)
 541         return false;
 542 
 543     unsigned otherLength = otherArray-&gt;length();
 544     Checked&lt;unsigned, RecordOverflow&gt; checkedNewLength = startIndex;
 545     checkedNewLength += otherLength;
 546 
 547     unsigned newLength;
 548     if (checkedNewLength.safeGet(newLength) == CheckedState::DidOverflow) {
<span class="line-modified"> 549         throwException(exec, scope, createRangeError(exec, LengthExceededTheMaximumArrayLengthError));</span>
 550         return false;
 551     }
 552 
 553     if (newLength &gt;= MIN_SPARSE_ARRAY_INDEX)
 554         return false;
 555 
 556     if (!ensureLength(vm, newLength)) {
<span class="line-modified"> 557         throwOutOfMemoryError(exec, scope);</span>
 558         return false;
 559     }
 560     ASSERT(copyType == indexingType());
 561 
 562     if (UNLIKELY(otherType == ArrayWithUndecided)) {
 563         auto* butterfly = this-&gt;butterfly();
 564         if (type == ArrayWithDouble) {
 565             for (unsigned i = startIndex; i &lt; newLength; ++i)
 566                 butterfly-&gt;contiguousDouble().at(this, i) = PNaN;
 567         } else {
 568             for (unsigned i = startIndex; i &lt; newLength; ++i)
 569                 butterfly-&gt;contiguousInt32().at(this, i).setWithoutWriteBarrier(JSValue());
 570         }
 571     } else if (type == ArrayWithDouble)
<span class="line-modified"> 572         memcpy(butterfly()-&gt;contiguousDouble().data() + startIndex, otherArray-&gt;butterfly()-&gt;contiguousDouble().data(), sizeof(JSValue) * otherLength);</span>
 573     else {
<span class="line-modified"> 574         memcpy(butterfly()-&gt;contiguous().data() + startIndex, otherArray-&gt;butterfly()-&gt;contiguous().data(), sizeof(JSValue) * otherLength);</span>
 575         vm.heap.writeBarrier(this);
 576     }
 577 
 578     return true;
 579 }
 580 
<span class="line-modified"> 581 bool JSArray::setLength(ExecState* exec, unsigned newLength, bool throwException)</span>
 582 {
<span class="line-modified"> 583     VM&amp; vm = exec-&gt;vm();</span>
 584     auto scope = DECLARE_THROW_SCOPE(vm);
 585 
 586     Butterfly* butterfly = this-&gt;butterfly();
 587     switch (indexingMode()) {
 588     case ArrayClass:
 589         if (!newLength)
 590             return true;
 591         if (newLength &gt;= MIN_SPARSE_ARRAY_INDEX) {
 592             RELEASE_AND_RETURN(scope, setLengthWithArrayStorage(
<span class="line-modified"> 593                 exec, newLength, throwException,</span>
 594                 ensureArrayStorage(vm)));
 595         }
 596         createInitialUndecided(vm, newLength);
 597         return true;
 598 
 599     case CopyOnWriteArrayWithInt32:
 600     case CopyOnWriteArrayWithDouble:
 601     case CopyOnWriteArrayWithContiguous:
 602         if (newLength == butterfly-&gt;publicLength())
 603             return true;
 604         convertFromCopyOnWrite(vm);
 605         butterfly = this-&gt;butterfly();
 606         FALLTHROUGH;
 607 
 608     case ArrayWithUndecided:
 609     case ArrayWithInt32:
 610     case ArrayWithDouble:
 611     case ArrayWithContiguous: {
 612         if (newLength == butterfly-&gt;publicLength())
 613             return true;
 614         if (newLength &gt; MAX_STORAGE_VECTOR_LENGTH // This check ensures that we can do fast push.
 615             || (newLength &gt;= MIN_SPARSE_ARRAY_INDEX
 616                 &amp;&amp; !isDenseEnoughForVector(newLength, countElements()))) {
 617             RELEASE_AND_RETURN(scope, setLengthWithArrayStorage(
<span class="line-modified"> 618                 exec, newLength, throwException,</span>
 619                 ensureArrayStorage(vm)));
 620         }
 621         if (newLength &gt; butterfly-&gt;publicLength()) {
 622             if (!ensureLength(vm, newLength)) {
<span class="line-modified"> 623                 throwOutOfMemoryError(exec, scope);</span>
 624                 return false;
 625             }
 626             return true;
 627         }
 628 
 629         unsigned lengthToClear = butterfly-&gt;publicLength() - newLength;
 630         unsigned costToAllocateNewButterfly = 64; // a heuristic.
 631         if (lengthToClear &gt; newLength &amp;&amp; lengthToClear &gt; costToAllocateNewButterfly) {
 632             reallocateAndShrinkButterfly(vm, newLength);
 633             return true;
 634         }
 635 
 636         if (indexingType() == ArrayWithDouble) {
 637             for (unsigned i = butterfly-&gt;publicLength(); i-- &gt; newLength;)
 638                 butterfly-&gt;contiguousDouble().at(this, i) = PNaN;
 639         } else {
 640             for (unsigned i = butterfly-&gt;publicLength(); i-- &gt; newLength;)
 641                 butterfly-&gt;contiguous().at(this, i).clear();
 642         }
 643         butterfly-&gt;setPublicLength(newLength);
 644         return true;
 645     }
 646 
 647     case ArrayWithArrayStorage:
 648     case ArrayWithSlowPutArrayStorage:
<span class="line-modified"> 649         RELEASE_AND_RETURN(scope, setLengthWithArrayStorage(exec, newLength, throwException, arrayStorage()));</span>
 650 
 651     default:
 652         CRASH();
 653         return false;
 654     }
 655 }
 656 
<span class="line-modified"> 657 JSValue JSArray::pop(ExecState* exec)</span>
 658 {
<span class="line-modified"> 659     VM&amp; vm = exec-&gt;vm();</span>
 660     auto scope = DECLARE_THROW_SCOPE(vm);
 661 
 662     ensureWritable(vm);
 663 
 664     Butterfly* butterfly = this-&gt;butterfly();
 665 
 666     switch (indexingType()) {
 667     case ArrayClass:
 668         return jsUndefined();
 669 
 670     case ArrayWithUndecided:
 671         if (!butterfly-&gt;publicLength())
 672             return jsUndefined();
 673         // We have nothing but holes. So, drop down to the slow version.
 674         break;
 675 
 676     case ArrayWithInt32:
 677     case ArrayWithContiguous: {
 678         unsigned length = butterfly-&gt;publicLength();
 679 
</pre>
<hr />
<pre>
 695 
 696         if (!length--)
 697             return jsUndefined();
 698 
 699         RELEASE_ASSERT(length &lt; butterfly-&gt;vectorLength());
 700         double value = butterfly-&gt;contiguousDouble().at(this, length);
 701         if (value == value) {
 702             butterfly-&gt;contiguousDouble().at(this, length) = PNaN;
 703             butterfly-&gt;setPublicLength(length);
 704             return JSValue(JSValue::EncodeAsDouble, value);
 705         }
 706         break;
 707     }
 708 
 709     case ARRAY_WITH_ARRAY_STORAGE_INDEXING_TYPES: {
 710         ArrayStorage* storage = butterfly-&gt;arrayStorage();
 711 
 712         unsigned length = storage-&gt;length();
 713         if (!length) {
 714             if (!isLengthWritable())
<span class="line-modified"> 715                 throwTypeError(exec, scope, ReadonlyPropertyWriteError);</span>
 716             return jsUndefined();
 717         }
 718 
 719         unsigned index = length - 1;
 720         if (index &lt; storage-&gt;vectorLength()) {
 721             WriteBarrier&lt;Unknown&gt;&amp; valueSlot = storage-&gt;m_vector[index];
 722             if (valueSlot) {
 723                 --storage-&gt;m_numValuesInVector;
 724                 JSValue element = valueSlot.get();
 725                 valueSlot.clear();
 726 
 727                 RELEASE_ASSERT(isLengthWritable());
 728                 storage-&gt;setLength(index);
 729                 return element;
 730             }
 731         }
 732         break;
 733     }
 734 
 735     default:
 736         CRASH();
 737         return JSValue();
 738     }
 739 
 740     unsigned index = getArrayLength() - 1;
 741     // Let element be the result of calling the [[Get]] internal method of O with argument indx.
<span class="line-modified"> 742     JSValue element = get(exec, index);</span>
 743     RETURN_IF_EXCEPTION(scope, JSValue());
 744     // Call the [[Delete]] internal method of O with arguments indx and true.
<span class="line-modified"> 745     bool success = deletePropertyByIndex(this, exec, index);</span>
 746     RETURN_IF_EXCEPTION(scope, JSValue());
 747     if (!success) {
<span class="line-modified"> 748         throwTypeError(exec, scope, UnableToDeletePropertyError);</span>
 749         return jsUndefined();
 750     }
 751     // Call the [[Put]] internal method of O with arguments &quot;length&quot;, indx, and true.
 752     scope.release();
<span class="line-modified"> 753     setLength(exec, index, true);</span>
 754     // Return element.
 755     return element;
 756 }
 757 
 758 // Push &amp; putIndex are almost identical, with two small differences.
 759 //  - we always are writing beyond the current array bounds, so it is always necessary to update m_length &amp; m_numValuesInVector.
 760 //  - pushing to an array of length 2^32-1 stores the property, but throws a range error.
<span class="line-modified"> 761 NEVER_INLINE void JSArray::push(ExecState* exec, JSValue value)</span>
 762 {
<span class="line-modified"> 763     pushInline(exec, value);</span>
 764 }
 765 
<span class="line-modified"> 766 JSArray* JSArray::fastSlice(ExecState&amp; exec, unsigned startIndex, unsigned count)</span>
 767 {
<span class="line-modified"> 768     VM&amp; vm = exec.vm();</span>
 769 
 770     ensureWritable(vm);
 771 
 772     auto arrayType = indexingMode();
 773     switch (arrayType) {
 774     case ArrayWithDouble:
 775     case ArrayWithInt32:
 776     case ArrayWithContiguous: {
 777         if (count &gt;= MIN_SPARSE_ARRAY_INDEX || structure(vm)-&gt;holesMustForwardToPrototype(vm, this))
 778             return nullptr;
 779 
<span class="line-modified"> 780         JSGlobalObject* lexicalGlobalObject = exec.lexicalGlobalObject();</span>
<span class="line-removed"> 781         Structure* resultStructure = lexicalGlobalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(arrayType);</span>
 782         if (UNLIKELY(hasAnyArrayStorage(resultStructure-&gt;indexingType())))
 783             return nullptr;
 784 
<span class="line-modified"> 785         ASSERT(!lexicalGlobalObject-&gt;isHavingABadTime());</span>
 786         ObjectInitializationScope scope(vm);
 787         JSArray* resultArray = JSArray::tryCreateUninitializedRestricted(scope, resultStructure, count);
 788         if (UNLIKELY(!resultArray))
 789             return nullptr;
 790 
 791         auto&amp; resultButterfly = *resultArray-&gt;butterfly();
 792         if (arrayType == ArrayWithDouble)
<span class="line-modified"> 793             memcpy(resultButterfly.contiguousDouble().data(), butterfly()-&gt;contiguousDouble().data() + startIndex, sizeof(JSValue) * count);</span>
 794         else
<span class="line-modified"> 795             memcpy(resultButterfly.contiguous().data(), butterfly()-&gt;contiguous().data() + startIndex, sizeof(JSValue) * count);</span>
<span class="line-removed"> 796         resultButterfly.setPublicLength(count);</span>
 797 

 798         return resultArray;
 799     }
 800     default:
 801         return nullptr;
 802     }
 803 }
 804 
 805 bool JSArray::shiftCountWithArrayStorage(VM&amp; vm, unsigned startIndex, unsigned count, ArrayStorage* storage)
 806 {
 807     unsigned oldLength = storage-&gt;length();
 808     RELEASE_ASSERT(count &lt;= oldLength);
 809 
 810     // If the array contains holes or is otherwise in an abnormal state,
 811     // use the generic algorithm in ArrayPrototype.
 812     if (storage-&gt;hasHoles()
 813         || hasSparseMap()
 814         || shouldUseSlowPut(indexingType())) {
 815         return false;
 816     }
 817 
</pre>
<hr />
<pre>
 833     DisallowGC disallowGC;
 834     auto locker = holdLock(cellLock());
 835 
 836     if (startIndex + count &gt; vectorLength)
 837         count = vectorLength - startIndex;
 838 
 839     unsigned usedVectorLength = std::min(vectorLength, oldLength);
 840 
 841     unsigned numElementsBeforeShiftRegion = startIndex;
 842     unsigned firstIndexAfterShiftRegion = startIndex + count;
 843     unsigned numElementsAfterShiftRegion = usedVectorLength - firstIndexAfterShiftRegion;
 844     ASSERT(numElementsBeforeShiftRegion + count + numElementsAfterShiftRegion == usedVectorLength);
 845 
 846     // The point of this comparison seems to be to minimize the amount of elements that have to
 847     // be moved during a shift operation.
 848     if (numElementsBeforeShiftRegion &lt; numElementsAfterShiftRegion) {
 849         // The number of elements before the shift region is less than the number of elements
 850         // after the shift region, so we move the elements before to the right.
 851         if (numElementsBeforeShiftRegion) {
 852             RELEASE_ASSERT(count + startIndex &lt;= vectorLength);
<span class="line-modified"> 853             memmove(storage-&gt;m_vector + count,</span>
 854                 storage-&gt;m_vector,
 855                 sizeof(JSValue) * startIndex);
 856         }
 857         // Adjust the Butterfly and the index bias. We only need to do this here because we&#39;re changing
 858         // the start of the Butterfly, which needs to point at the first indexed property in the used
 859         // portion of the vector.
 860         Butterfly* butterfly = this-&gt;butterfly()-&gt;shift(structure(vm), count);
 861         storage = butterfly-&gt;arrayStorage();
 862         storage-&gt;m_indexBias += count;
 863 
 864         // Since we&#39;re consuming part of the vector by moving its beginning to the left,
 865         // we need to modify the vector length appropriately.
 866         storage-&gt;setVectorLength(vectorLength - count);
 867         setButterfly(vm, butterfly);
 868     } else {
 869         // The number of elements before the shift region is greater than or equal to the number
 870         // of elements after the shift region, so we move the elements after the shift region to the left.
<span class="line-modified"> 871         memmove(storage-&gt;m_vector + startIndex,</span>
 872             storage-&gt;m_vector + firstIndexAfterShiftRegion,
 873             sizeof(JSValue) * numElementsAfterShiftRegion);
 874 
 875         // Clear the slots of the elements we just moved.
 876         unsigned startOfEmptyVectorTail = usedVectorLength - count;
 877         for (unsigned i = startOfEmptyVectorTail; i &lt; usedVectorLength; ++i)
 878             storage-&gt;m_vector[i].clear();
 879         // We don&#39;t modify the index bias or the Butterfly pointer in this case because we&#39;re not changing
 880         // the start of the Butterfly, which needs to point at the first indexed property in the used
 881         // portion of the vector. We also don&#39;t modify the vector length because we&#39;re not actually changing
 882         // its length; we&#39;re just using less of it.
 883     }
 884 
 885     return true;
 886 }
 887 
<span class="line-modified"> 888 bool JSArray::shiftCountWithAnyIndexingType(ExecState* exec, unsigned&amp; startIndex, unsigned count)</span>
 889 {
<span class="line-modified"> 890     VM&amp; vm = exec-&gt;vm();</span>
 891     RELEASE_ASSERT(count &gt; 0);
 892 
 893     ensureWritable(vm);
 894 
 895     Butterfly* butterfly = this-&gt;butterfly();
 896 
<span class="line-modified"> 897     switch (indexingType()) {</span>

 898     case ArrayClass:
 899         return true;
 900 
 901     case ArrayWithUndecided:
 902         // Don&#39;t handle this because it&#39;s confusing and it shouldn&#39;t come up.
 903         return false;
 904 
 905     case ArrayWithInt32:
 906     case ArrayWithContiguous: {
 907         unsigned oldLength = butterfly-&gt;publicLength();
 908         RELEASE_ASSERT(count &lt;= oldLength);
 909 
 910         // We may have to walk the entire array to do the shift. We&#39;re willing to do
 911         // so only if it&#39;s not horribly slow.
 912         if (oldLength - (startIndex + count) &gt;= MIN_SPARSE_ARRAY_INDEX)
 913             return shiftCountWithArrayStorage(vm, startIndex, count, ensureArrayStorage(vm));
 914 
 915         // Storing to a hole is fine since we&#39;re still having a good time. But reading from a hole
 916         // is totally not fine, since we might have to read from the proto chain.
 917         // We have to check for holes before we start moving things around so that we don&#39;t get halfway
 918         // through shifting and then realize we should have been in ArrayStorage mode.
 919         unsigned end = oldLength - count;
 920         if (this-&gt;structure(vm)-&gt;holesMustForwardToPrototype(vm, this)) {
 921             for (unsigned i = startIndex; i &lt; end; ++i) {
 922                 JSValue v = butterfly-&gt;contiguous().at(this, i + count).get();
 923                 if (UNLIKELY(!v)) {
 924                     startIndex = i;
 925                     return shiftCountWithArrayStorage(vm, startIndex, count, ensureArrayStorage(vm));
 926                 }
 927                 butterfly-&gt;contiguous().at(this, i).setWithoutWriteBarrier(v);
 928             }
 929         } else {
<span class="line-modified"> 930             memmove(butterfly-&gt;contiguous().data() + startIndex,</span>
 931                 butterfly-&gt;contiguous().data() + startIndex + count,
 932                 sizeof(JSValue) * (end - startIndex));
 933         }
 934 
 935         for (unsigned i = end; i &lt; oldLength; ++i)
 936             butterfly-&gt;contiguous().at(this, i).clear();
 937 
 938         butterfly-&gt;setPublicLength(oldLength - count);
 939 
 940         // Our memmoving of values around in the array could have concealed some of them from
 941         // the collector. Let&#39;s make sure that the collector scans this object again.
<span class="line-modified"> 942         vm.heap.writeBarrier(this);</span>

 943 
 944         return true;
 945     }
 946 
 947     case ArrayWithDouble: {
 948         unsigned oldLength = butterfly-&gt;publicLength();
 949         RELEASE_ASSERT(count &lt;= oldLength);
 950 
 951         // We may have to walk the entire array to do the shift. We&#39;re willing to do
 952         // so only if it&#39;s not horribly slow.
 953         if (oldLength - (startIndex + count) &gt;= MIN_SPARSE_ARRAY_INDEX)
 954             return shiftCountWithArrayStorage(vm, startIndex, count, ensureArrayStorage(vm));
 955 
 956         // Storing to a hole is fine since we&#39;re still having a good time. But reading from a hole
 957         // is totally not fine, since we might have to read from the proto chain.
 958         // We have to check for holes before we start moving things around so that we don&#39;t get halfway
 959         // through shifting and then realize we should have been in ArrayStorage mode.
 960         unsigned end = oldLength - count;
 961         if (this-&gt;structure(vm)-&gt;holesMustForwardToPrototype(vm, this)) {
 962             for (unsigned i = startIndex; i &lt; end; ++i) {
 963                 double v = butterfly-&gt;contiguousDouble().at(this, i + count);
 964                 if (UNLIKELY(v != v)) {
 965                     startIndex = i;
 966                     return shiftCountWithArrayStorage(vm, startIndex, count, ensureArrayStorage(vm));
 967                 }
 968                 butterfly-&gt;contiguousDouble().at(this, i) = v;
 969             }
 970         } else {
<span class="line-modified"> 971             memmove(butterfly-&gt;contiguousDouble().data() + startIndex,</span>
 972                 butterfly-&gt;contiguousDouble().data() + startIndex + count,
 973                 sizeof(JSValue) * (end - startIndex));
 974         }
 975         for (unsigned i = end; i &lt; oldLength; ++i)
 976             butterfly-&gt;contiguousDouble().at(this, i) = PNaN;
 977 
 978         butterfly-&gt;setPublicLength(oldLength - count);
 979         return true;
 980     }
 981 
 982     case ArrayWithArrayStorage:
 983     case ArrayWithSlowPutArrayStorage:
 984         return shiftCountWithArrayStorage(vm, startIndex, count, arrayStorage());
 985 
 986     default:
 987         CRASH();
 988         return false;
 989     }
 990 }
 991 
 992 // Returns true if the unshift can be handled, false to fallback.
<span class="line-modified"> 993 bool JSArray::unshiftCountWithArrayStorage(ExecState* exec, unsigned startIndex, unsigned count, ArrayStorage* storage)</span>
 994 {
<span class="line-modified"> 995     VM&amp; vm = exec-&gt;vm();</span>
 996     auto scope = DECLARE_THROW_SCOPE(vm);
 997 
 998     unsigned length = storage-&gt;length();
 999 
1000     RELEASE_ASSERT(startIndex &lt;= length);
1001 
1002     // If the array contains holes or is otherwise in an abnormal state,
1003     // use the generic algorithm in ArrayPrototype.
1004     if (storage-&gt;hasHoles() || storage-&gt;inSparseMode() || shouldUseSlowPut(indexingType()))
1005         return false;
1006 
1007     bool moveFront = !startIndex || startIndex &lt; length / 2;
1008 
1009     unsigned vectorLength = storage-&gt;vectorLength();
1010 
1011     // Need to have GC deferred around the unshiftCountSlowCase(), since that leaves the butterfly in
1012     // a weird state: some parts of it will be left uninitialized, which we will fill in here.
1013     DeferGC deferGC(vm.heap);
1014     auto locker = holdLock(cellLock());
1015 
1016     if (moveFront &amp;&amp; storage-&gt;m_indexBias &gt;= count) {
1017         Butterfly* newButterfly = storage-&gt;butterfly()-&gt;unshift(structure(vm), count);
1018         storage = newButterfly-&gt;arrayStorage();
1019         storage-&gt;m_indexBias -= count;
1020         storage-&gt;setVectorLength(vectorLength + count);
1021         setButterfly(vm, newButterfly);
1022     } else if (!moveFront &amp;&amp; vectorLength - length &gt;= count)
1023         storage = storage-&gt;butterfly()-&gt;arrayStorage();
1024     else if (unshiftCountSlowCase(locker, vm, deferGC, moveFront, count))
1025         storage = arrayStorage();
1026     else {
<span class="line-modified">1027         throwOutOfMemoryError(exec, scope);</span>
1028         return true;
1029     }
1030 
1031     WriteBarrier&lt;Unknown&gt;* vector = storage-&gt;m_vector;
1032 
1033     if (startIndex) {
1034         if (moveFront)
<span class="line-modified">1035             memmove(vector, vector + count, startIndex * sizeof(JSValue));</span>
1036         else if (length - startIndex)
<span class="line-modified">1037             memmove(vector + startIndex + count, vector + startIndex, (length - startIndex) * sizeof(JSValue));</span>
1038     }
1039 
1040     for (unsigned i = 0; i &lt; count; i++)
1041         vector[i + startIndex].clear();
1042 
1043     return true;
1044 }
1045 
<span class="line-modified">1046 bool JSArray::unshiftCountWithAnyIndexingType(ExecState* exec, unsigned startIndex, unsigned count)</span>
1047 {
<span class="line-modified">1048     VM&amp; vm = exec-&gt;vm();</span>
1049     auto scope = DECLARE_THROW_SCOPE(vm);
1050 
1051     ensureWritable(vm);
1052 
1053     Butterfly* butterfly = this-&gt;butterfly();
1054 
1055     switch (indexingType()) {
1056     case ArrayClass:
1057     case ArrayWithUndecided:
1058         // We could handle this. But it shouldn&#39;t ever come up, so we won&#39;t.
1059         return false;
1060 
1061     case ArrayWithInt32:
1062     case ArrayWithContiguous: {
1063         unsigned oldLength = butterfly-&gt;publicLength();
1064 
1065         // We may have to walk the entire array to do the unshift. We&#39;re willing to do so
1066         // only if it&#39;s not horribly slow.
1067         if (oldLength - startIndex &gt;= MIN_SPARSE_ARRAY_INDEX)
<span class="line-modified">1068             RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(exec, startIndex, count, ensureArrayStorage(vm)));</span>
1069 
1070         Checked&lt;unsigned, RecordOverflow&gt; checkedLength(oldLength);
1071         checkedLength += count;
1072         unsigned newLength;
1073         if (CheckedState::DidOverflow == checkedLength.safeGet(newLength)) {
<span class="line-modified">1074             throwOutOfMemoryError(exec, scope);</span>
1075             return true;
1076         }
1077         if (newLength &gt; MAX_STORAGE_VECTOR_LENGTH)
1078             return false;
1079         if (!ensureLength(vm, newLength)) {
<span class="line-modified">1080             throwOutOfMemoryError(exec, scope);</span>
1081             return true;
1082         }
1083         butterfly = this-&gt;butterfly();
1084 
1085         // We have to check for holes before we start moving things around so that we don&#39;t get halfway
1086         // through shifting and then realize we should have been in ArrayStorage mode.
1087         for (unsigned i = oldLength; i-- &gt; startIndex;) {
1088             JSValue v = butterfly-&gt;contiguous().at(this, i).get();
1089             if (UNLIKELY(!v))
<span class="line-modified">1090                 RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(exec, startIndex, count, ensureArrayStorage(vm)));</span>
1091         }
1092 
1093         for (unsigned i = oldLength; i-- &gt; startIndex;) {
1094             JSValue v = butterfly-&gt;contiguous().at(this, i).get();
1095             ASSERT(v);
1096             butterfly-&gt;contiguous().at(this, i + count).setWithoutWriteBarrier(v);
1097         }
1098 
1099         // Our memmoving of values around in the array could have concealed some of them from
1100         // the collector. Let&#39;s make sure that the collector scans this object again.
1101         vm.heap.writeBarrier(this);
1102 
1103         // NOTE: we&#39;re leaving being garbage in the part of the array that we shifted out
1104         // of. This is fine because the caller is required to store over that area, and
1105         // in contiguous mode storing into a hole is guaranteed to behave exactly the same
1106         // as storing over an existing element.
1107 
1108         return true;
1109     }
1110 
1111     case ArrayWithDouble: {
1112         unsigned oldLength = butterfly-&gt;publicLength();
1113 
1114         // We may have to walk the entire array to do the unshift. We&#39;re willing to do so
1115         // only if it&#39;s not horribly slow.
1116         if (oldLength - startIndex &gt;= MIN_SPARSE_ARRAY_INDEX)
<span class="line-modified">1117             RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(exec, startIndex, count, ensureArrayStorage(vm)));</span>
1118 
1119         Checked&lt;unsigned, RecordOverflow&gt; checkedLength(oldLength);
1120         checkedLength += count;
1121         unsigned newLength;
1122         if (CheckedState::DidOverflow == checkedLength.safeGet(newLength)) {
<span class="line-modified">1123             throwOutOfMemoryError(exec, scope);</span>
1124             return true;
1125         }
1126         if (newLength &gt; MAX_STORAGE_VECTOR_LENGTH)
1127             return false;
1128         if (!ensureLength(vm, newLength)) {
<span class="line-modified">1129             throwOutOfMemoryError(exec, scope);</span>
1130             return true;
1131         }
1132         butterfly = this-&gt;butterfly();
1133 
1134         // We have to check for holes before we start moving things around so that we don&#39;t get halfway
1135         // through shifting and then realize we should have been in ArrayStorage mode.
1136         for (unsigned i = oldLength; i-- &gt; startIndex;) {
1137             double v = butterfly-&gt;contiguousDouble().at(this, i);
1138             if (UNLIKELY(v != v))
<span class="line-modified">1139                 RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(exec, startIndex, count, ensureArrayStorage(vm)));</span>
1140         }
1141 
1142         for (unsigned i = oldLength; i-- &gt; startIndex;) {
1143             double v = butterfly-&gt;contiguousDouble().at(this, i);
1144             ASSERT(v == v);
1145             butterfly-&gt;contiguousDouble().at(this, i + count) = v;
1146         }
1147 
1148         // NOTE: we&#39;re leaving being garbage in the part of the array that we shifted out
1149         // of. This is fine because the caller is required to store over that area, and
1150         // in contiguous mode storing into a hole is guaranteed to behave exactly the same
1151         // as storing over an existing element.
1152 
1153         return true;
1154     }
1155 
1156     case ArrayWithArrayStorage:
1157     case ArrayWithSlowPutArrayStorage:
<span class="line-modified">1158         RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(exec, startIndex, count, arrayStorage()));</span>
1159 
1160     default:
1161         CRASH();
1162         return false;
1163     }
1164 }
1165 
<span class="line-modified">1166 void JSArray::fillArgList(ExecState* exec, MarkedArgumentBuffer&amp; args)</span>
1167 {
1168     unsigned i = 0;
1169     unsigned vectorEnd;
1170     WriteBarrier&lt;Unknown&gt;* vector;
1171 
1172     Butterfly* butterfly = this-&gt;butterfly();
1173 
1174     switch (indexingType()) {
1175     case ArrayClass:
1176         return;
1177 
1178     case ArrayWithUndecided: {
1179         vector = 0;
1180         vectorEnd = 0;
1181         break;
1182     }
1183 
1184     case ArrayWithInt32:
1185     case ArrayWithContiguous: {
1186         vectorEnd = butterfly-&gt;publicLength();
</pre>
<hr />
<pre>
1209     }
1210 
1211     default:
1212         CRASH();
1213 #if COMPILER_QUIRK(CONSIDERS_UNREACHABLE_CODE)
1214         vector = 0;
1215         vectorEnd = 0;
1216         break;
1217 #endif
1218     }
1219 
1220     for (; i &lt; vectorEnd; ++i) {
1221         WriteBarrier&lt;Unknown&gt;&amp; v = vector[i];
1222         if (!v)
1223             break;
1224         args.append(v.get());
1225     }
1226 
1227     // FIXME: What prevents this from being called with a RuntimeArray? The length function will always return 0 in that case.
1228     for (; i &lt; length(); ++i)
<span class="line-modified">1229         args.append(get(exec, i));</span>
1230 }
1231 
<span class="line-modified">1232 void JSArray::copyToArguments(ExecState* exec, VirtualRegister firstElementDest, unsigned offset, unsigned length)</span>
1233 {
<span class="line-modified">1234     VM&amp; vm = exec-&gt;vm();</span>
1235     auto scope = DECLARE_THROW_SCOPE(vm);
1236 
1237     unsigned i = offset;
1238     WriteBarrier&lt;Unknown&gt;* vector;
1239     unsigned vectorEnd;
1240     length += offset; // We like to think of the length as being our length, rather than the output length.
1241 
1242     // FIXME: What prevents this from being called with a RuntimeArray? The length function will always return 0 in that case.
1243     ASSERT(length == this-&gt;length());
1244 
1245     Butterfly* butterfly = this-&gt;butterfly();
1246     switch (indexingType()) {
1247     case ArrayClass:
1248         return;
1249 
1250     case ArrayWithUndecided: {
1251         vector = 0;
1252         vectorEnd = 0;
1253         break;
1254     }
1255 
1256     case ArrayWithInt32:
1257     case ArrayWithContiguous: {
1258         vector = butterfly-&gt;contiguous().data();
1259         vectorEnd = butterfly-&gt;publicLength();
1260         break;
1261     }
1262 
1263     case ArrayWithDouble: {
1264         vector = 0;
1265         vectorEnd = 0;
1266         for (; i &lt; butterfly-&gt;publicLength(); ++i) {
1267             ASSERT(i &lt; butterfly-&gt;vectorLength());
1268             double v = butterfly-&gt;contiguousDouble().at(this, i);
1269             if (v != v)
1270                 break;
<span class="line-modified">1271             exec-&gt;r(firstElementDest + i - offset) = JSValue(JSValue::EncodeAsDouble, v);</span>
1272         }
1273         break;
1274     }
1275 
1276     case ARRAY_WITH_ARRAY_STORAGE_INDEXING_TYPES: {
1277         ArrayStorage* storage = butterfly-&gt;arrayStorage();
1278         vector = storage-&gt;m_vector;
1279         vectorEnd = std::min(length, storage-&gt;vectorLength());
1280         break;
1281     }
1282 
1283     default:
1284         CRASH();
1285 #if COMPILER_QUIRK(CONSIDERS_UNREACHABLE_CODE)
1286         vector = 0;
1287         vectorEnd = 0;
1288         break;
1289 #endif
1290     }
1291 
1292     for (; i &lt; vectorEnd; ++i) {
1293         WriteBarrier&lt;Unknown&gt;&amp; v = vector[i];
1294         if (!v)
1295             break;
<span class="line-modified">1296         exec-&gt;r(firstElementDest + i - offset) = v.get();</span>
1297     }
1298 
1299     for (; i &lt; length; ++i) {
<span class="line-modified">1300         exec-&gt;r(firstElementDest + i - offset) = get(exec, i);</span>
1301         RETURN_IF_EXCEPTION(scope, void());
1302     }
1303 }
1304 
1305 bool JSArray::isIteratorProtocolFastAndNonObservable()
1306 {
1307     JSGlobalObject* globalObject = this-&gt;globalObject();
1308     if (!globalObject-&gt;isArrayPrototypeIteratorProtocolFastAndNonObservable())
1309         return false;
1310 
1311     VM&amp; vm = globalObject-&gt;vm();
1312     Structure* structure = this-&gt;structure(vm);
1313     // This is the fast case. Many arrays will be an original array.
1314     if (globalObject-&gt;isOriginalArrayStructure(structure))
1315         return true;
1316 
1317     if (structure-&gt;mayInterceptIndexedAccesses())
1318         return false;
1319 
1320     if (getPrototypeDirect(vm) != globalObject-&gt;arrayPrototype())
</pre>
<hr />
<pre>
1328 
1329 inline JSArray* constructArray(ObjectInitializationScope&amp; scope, Structure* arrayStructure, unsigned length)
1330 {
1331     JSArray* array = JSArray::tryCreateUninitializedRestricted(scope, arrayStructure, length);
1332 
1333     // FIXME: we should probably throw an out of memory error here, but
1334     // when making this change we should check that all clients of this
1335     // function will correctly handle an exception being thrown from here.
1336     // https://bugs.webkit.org/show_bug.cgi?id=169786
1337     RELEASE_ASSERT(array);
1338 
1339     // FIXME: We only need this for subclasses of Array because we might need to allocate a new structure to change
1340     // indexing types while initializing. If this triggered a GC then we might scan our currently uninitialized
1341     // array and crash. https://bugs.webkit.org/show_bug.cgi?id=186811
1342     if (!arrayStructure-&gt;globalObject()-&gt;isOriginalArrayStructure(arrayStructure))
1343         JSArray::eagerlyInitializeButterfly(scope, array, length);
1344 
1345     return array;
1346 }
1347 
<span class="line-modified">1348 JSArray* constructArray(ExecState* exec, Structure* arrayStructure, const ArgList&amp; values)</span>
1349 {
<span class="line-modified">1350     VM&amp; vm = exec-&gt;vm();</span>
1351     unsigned length = values.size();
1352     ObjectInitializationScope scope(vm);
1353 
1354     JSArray* array = constructArray(scope, arrayStructure, length);
1355     for (unsigned i = 0; i &lt; length; ++i)
1356         array-&gt;initializeIndex(scope, i, values.at(i));
1357     return array;
1358 }
1359 
<span class="line-modified">1360 JSArray* constructArray(ExecState* exec, Structure* arrayStructure, const JSValue* values, unsigned length)</span>
1361 {
<span class="line-modified">1362     VM&amp; vm = exec-&gt;vm();</span>
1363     ObjectInitializationScope scope(vm);
1364 
1365     JSArray* array = constructArray(scope, arrayStructure, length);
1366     for (unsigned i = 0; i &lt; length; ++i)
1367         array-&gt;initializeIndex(scope, i, values[i]);
1368     return array;
1369 }
1370 
<span class="line-modified">1371 JSArray* constructArrayNegativeIndexed(ExecState* exec, Structure* arrayStructure, const JSValue* values, unsigned length)</span>
1372 {
<span class="line-modified">1373     VM&amp; vm = exec-&gt;vm();</span>
1374     ObjectInitializationScope scope(vm);
1375 
1376     JSArray* array = constructArray(scope, arrayStructure, length);
1377     for (int i = 0; i &lt; static_cast&lt;int&gt;(length); ++i)
1378         array-&gt;initializeIndex(scope, i, values[-i]);
1379     return array;
1380 }
1381 
1382 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">   3  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.</span>
   4  *  Copyright (C) 2003 Peter Kelly (pmk@post.com)
   5  *  Copyright (C) 2006 Alexey Proskuryakov (ap@nypop.com)
   6  *
   7  *  This library is free software; you can redistribute it and/or
   8  *  modify it under the terms of the GNU Lesser General Public
   9  *  License as published by the Free Software Foundation; either
  10  *  version 2 of the License, or (at your option) any later version.
  11  *
  12  *  This library is distributed in the hope that it will be useful,
  13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  *  Lesser General Public License for more details.
  16  *
  17  *  You should have received a copy of the GNU Lesser General Public
  18  *  License along with this library; if not, write to the Free Software
  19  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
</pre>
<hr />
<pre>
  64         void* temp = vm.jsValueGigacageAuxiliarySpace.allocateNonVirtual(
  65             vm,
  66             Butterfly::totalSize(0, outOfLineStorage, true, vectorLength * sizeof(EncodedJSValue)),
  67             deferralContext, AllocationFailureMode::ReturnNull);
  68         if (UNLIKELY(!temp))
  69             return nullptr;
  70         butterfly = Butterfly::fromBase(temp, 0, outOfLineStorage);
  71         butterfly-&gt;setVectorLength(vectorLength);
  72         butterfly-&gt;setPublicLength(initialLength);
  73         if (hasDouble(indexingType)) {
  74             for (unsigned i = initialLength; i &lt; vectorLength; ++i)
  75                 butterfly-&gt;contiguousDouble().atUnsafe(i) = PNaN;
  76         } else {
  77             for (unsigned i = initialLength; i &lt; vectorLength; ++i)
  78                 butterfly-&gt;contiguous().atUnsafe(i).clear();
  79         }
  80     } else {
  81         ASSERT(
  82             indexingType == ArrayWithSlowPutArrayStorage
  83             || indexingType == ArrayWithArrayStorage);
<span class="line-modified">  84         static constexpr unsigned indexBias = 0;</span>
  85         unsigned vectorLength = ArrayStorage::optimalVectorLength(indexBias, structure, initialLength);
  86         void* temp = vm.jsValueGigacageAuxiliarySpace.allocateNonVirtual(
  87             vm,
  88             Butterfly::totalSize(indexBias, outOfLineStorage, true, ArrayStorage::sizeFor(vectorLength)),
  89             deferralContext, AllocationFailureMode::ReturnNull);
  90         if (UNLIKELY(!temp))
  91             return nullptr;
  92         butterfly = Butterfly::fromBase(temp, indexBias, outOfLineStorage);
  93         *butterfly-&gt;indexingHeader() = indexingHeaderForArrayStorage(initialLength, vectorLength);
  94         ArrayStorage* storage = butterfly-&gt;arrayStorage();
  95         storage-&gt;m_indexBias = indexBias;
  96         storage-&gt;m_sparseMap.clear();
  97         storage-&gt;m_numValuesInVector = initialLength;
  98         for (unsigned i = initialLength; i &lt; vectorLength; ++i)
  99             storage-&gt;m_vector[i].clear();
 100     }
 101 
 102     JSArray* result = createWithButterfly(vm, deferralContext, structure, butterfly);
 103 
 104     const bool createUninitialized = true;
</pre>
<hr />
<pre>
 117     // tryCreateUninitializedRestricted() already initialized the elements between
 118     // initialLength and vector length. We just need to do 0 - initialLength.
 119     // ObjectInitializationScope::notifyInitialized() will verify that all elements are
 120     // initialized.
 121     if (LIKELY(!hasAnyArrayStorage(indexingType))) {
 122         if (hasDouble(indexingType)) {
 123             for (unsigned i = 0; i &lt; initialLength; ++i)
 124                 butterfly-&gt;contiguousDouble().atUnsafe(i) = PNaN;
 125         } else {
 126             for (unsigned i = 0; i &lt; initialLength; ++i)
 127                 butterfly-&gt;contiguous().atUnsafe(i).clear();
 128         }
 129     } else {
 130         ArrayStorage* storage = butterfly-&gt;arrayStorage();
 131         for (unsigned i = 0; i &lt; initialLength; ++i)
 132             storage-&gt;m_vector[i].clear();
 133     }
 134     scope.notifyInitialized(array);
 135 }
 136 
<span class="line-modified"> 137 void JSArray::setLengthWritable(JSGlobalObject* globalObject, bool writable)</span>
 138 {
 139     ASSERT(isLengthWritable() || !writable);
 140     if (!isLengthWritable() || writable)
 141         return;
 142 
<span class="line-modified"> 143     enterDictionaryIndexingMode(globalObject-&gt;vm());</span>
 144 
 145     SparseArrayValueMap* map = arrayStorage()-&gt;m_sparseMap.get();
 146     ASSERT(map);
 147     map-&gt;setLengthIsReadOnly();
 148 }
 149 
 150 // Defined in ES5.1 15.4.5.1
<span class="line-modified"> 151 bool JSArray::defineOwnProperty(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool throwException)</span>
 152 {
<span class="line-modified"> 153     VM&amp; vm = globalObject-&gt;vm();</span>
 154     auto scope = DECLARE_THROW_SCOPE(vm);
 155 
 156     JSArray* array = jsCast&lt;JSArray*&gt;(object);
 157 
 158     // 3. If P is &quot;length&quot;, then
 159     if (propertyName == vm.propertyNames-&gt;length) {
 160         // All paths through length definition call the default [[DefineOwnProperty]], hence:
 161         // from ES5.1 8.12.9 7.a.
 162         if (descriptor.configurablePresent() &amp;&amp; descriptor.configurable())
<span class="line-modified"> 163             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeConfigurabilityError);</span>
 164         // from ES5.1 8.12.9 7.b.
 165         if (descriptor.enumerablePresent() &amp;&amp; descriptor.enumerable())
<span class="line-modified"> 166             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeEnumerabilityError);</span>
 167 
 168         // a. If the [[Value]] field of Desc is absent, then
 169         // a.i. Return the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, Desc, and Throw as arguments.
 170         if (descriptor.isAccessorDescriptor())
<span class="line-modified"> 171             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);</span>
 172         // from ES5.1 8.12.9 10.a.
 173         if (!array-&gt;isLengthWritable() &amp;&amp; descriptor.writablePresent() &amp;&amp; descriptor.writable())
<span class="line-modified"> 174             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeWritabilityError);</span>
 175         // This descriptor is either just making length read-only, or changing nothing!
 176         if (!descriptor.value()) {
 177             if (descriptor.writablePresent())
<span class="line-modified"> 178                 array-&gt;setLengthWritable(globalObject, descriptor.writable());</span>
 179             return true;
 180         }
 181 
 182         // b. Let newLenDesc be a copy of Desc.
 183         // c. Let newLen be ToUint32(Desc.[[Value]]).
<span class="line-modified"> 184         unsigned newLen = descriptor.value().toUInt32(globalObject);</span>
 185         RETURN_IF_EXCEPTION(scope, false);
 186         // d. If newLen is not equal to ToNumber( Desc.[[Value]]), throw a RangeError exception.
<span class="line-modified"> 187         double valueAsNumber = descriptor.value().toNumber(globalObject);</span>
 188         RETURN_IF_EXCEPTION(scope, false);
 189         if (newLen != valueAsNumber) {
<span class="line-modified"> 190             JSC::throwException(globalObject, scope, createRangeError(globalObject, &quot;Invalid array length&quot;_s));</span>
 191             return false;
 192         }
 193 
 194         // Based on SameValue check in 8.12.9, this is always okay.
 195         // FIXME: Nothing prevents this from being called on a RuntimeArray, and the length function will always return 0 in that case.
 196         if (newLen == array-&gt;length()) {
 197             if (descriptor.writablePresent())
<span class="line-modified"> 198                 array-&gt;setLengthWritable(globalObject, descriptor.writable());</span>
 199             return true;
 200         }
 201 
 202         // e. Set newLenDesc.[[Value] to newLen.
 203         // f. If newLen &gt;= oldLen, then
 204         // f.i. Return the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, newLenDesc, and Throw as arguments.
 205         // g. Reject if oldLenDesc.[[Writable]] is false.
 206         if (!array-&gt;isLengthWritable())
<span class="line-modified"> 207             return typeError(globalObject, scope, throwException, ReadonlyPropertyChangeError);</span>
 208 
 209         // h. If newLenDesc.[[Writable]] is absent or has the value true, let newWritable be true.
 210         // i. Else,
 211         // i.i. Need to defer setting the [[Writable]] attribute to false in case any elements cannot be deleted.
 212         // i.ii. Let newWritable be false.
 213         // i.iii. Set newLenDesc.[[Writable] to true.
 214         // j. Let succeeded be the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, newLenDesc, and Throw as arguments.
 215         // k. If succeeded is false, return false.
 216         // l. While newLen &lt; oldLen repeat,
 217         // l.i. Set oldLen to oldLen – 1.
 218         // l.ii. Let deleteSucceeded be the result of calling the [[Delete]] internal method of A passing ToString(oldLen) and false as arguments.
 219         // l.iii. If deleteSucceeded is false, then
<span class="line-modified"> 220         bool success = array-&gt;setLength(globalObject, newLen, throwException);</span>
 221         EXCEPTION_ASSERT(!scope.exception() || !success);
 222         if (!success) {
 223             // 1. Set newLenDesc.[[Value] to oldLen+1.
 224             // 2. If newWritable is false, set newLenDesc.[[Writable] to false.
 225             // 3. Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, newLenDesc, and false as arguments.
 226             // 4. Reject.
 227             if (descriptor.writablePresent())
<span class="line-modified"> 228                 array-&gt;setLengthWritable(globalObject, descriptor.writable());</span>
 229             return false;
 230         }
 231 
 232         // m. If newWritable is false, then
 233         // i. Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;,
 234         //    Property Descriptor{[[Writable]]: false}, and false as arguments. This call will always
 235         //    return true.
 236         if (descriptor.writablePresent())
<span class="line-modified"> 237             array-&gt;setLengthWritable(globalObject, descriptor.writable());</span>
 238         // n. Return true.
 239         return true;
 240     }
 241 
 242     // 4. Else if P is an array index (15.4), then
 243     // a. Let index be ToUint32(P).
 244     if (Optional&lt;uint32_t&gt; optionalIndex = parseIndex(propertyName)) {
 245         // b. Reject if index &gt;= oldLen and oldLenDesc.[[Writable]] is false.
 246         uint32_t index = optionalIndex.value();
 247         // FIXME: Nothing prevents this from being called on a RuntimeArray, and the length function will always return 0 in that case.
 248         if (index &gt;= array-&gt;length() &amp;&amp; !array-&gt;isLengthWritable())
<span class="line-modified"> 249             return typeError(globalObject, scope, throwException, &quot;Attempting to define numeric property on array with non-writable length property.&quot;_s);</span>
 250         // c. Let succeeded be the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing P, Desc, and false as arguments.
 251         // d. Reject if succeeded is false.
 252         // e. If index &gt;= oldLen
 253         // e.i. Set oldLenDesc.[[Value]] to index + 1.
 254         // e.ii. Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, oldLenDesc, and false as arguments. This call will always return true.
 255         // f. Return true.
<span class="line-modified"> 256         RELEASE_AND_RETURN(scope, array-&gt;defineOwnIndexedProperty(globalObject, index, descriptor, throwException));</span>
 257     }
 258 
<span class="line-modified"> 259     RELEASE_AND_RETURN(scope, array-&gt;JSObject::defineOwnNonIndexProperty(globalObject, propertyName, descriptor, throwException));</span>
 260 }
 261 
<span class="line-modified"> 262 bool JSArray::getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
 263 {
<span class="line-modified"> 264     VM&amp; vm = globalObject-&gt;vm();</span>
 265     JSArray* thisObject = jsCast&lt;JSArray*&gt;(object);
 266     if (propertyName == vm.propertyNames-&gt;length) {
 267         unsigned attributes = thisObject-&gt;isLengthWritable() ? PropertyAttribute::DontDelete | PropertyAttribute::DontEnum : PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly;
 268         slot.setValue(thisObject, attributes, jsNumber(thisObject-&gt;length()));
 269         return true;
 270     }
 271 
<span class="line-modified"> 272     return JSObject::getOwnPropertySlot(thisObject, globalObject, propertyName, slot);</span>
 273 }
 274 
 275 // ECMA 15.4.5.1
<span class="line-modified"> 276 bool JSArray::put(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
 277 {
<span class="line-modified"> 278     VM&amp; vm = globalObject-&gt;vm();</span>
 279     auto scope = DECLARE_THROW_SCOPE(vm);
 280 
 281     JSArray* thisObject = jsCast&lt;JSArray*&gt;(cell);
 282 
 283     if (UNLIKELY(isThisValueAltered(slot, thisObject)))
<span class="line-modified"> 284         RELEASE_AND_RETURN(scope, ordinarySetSlow(globalObject, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode()));</span>
 285 
 286     thisObject-&gt;ensureWritable(vm);
 287 
 288     if (propertyName == vm.propertyNames-&gt;length) {
 289         if (!thisObject-&gt;isLengthWritable()) {
 290             if (slot.isStrictMode())
<span class="line-modified"> 291                 throwTypeError(globalObject, scope, &quot;Array length is not writable&quot;_s);</span>
 292             return false;
 293         }
 294 
<span class="line-modified"> 295         unsigned newLength = value.toUInt32(globalObject);</span>
 296         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified"> 297         double valueAsNumber = value.toNumber(globalObject);</span>
 298         RETURN_IF_EXCEPTION(scope, false);
 299         if (valueAsNumber != static_cast&lt;double&gt;(newLength)) {
<span class="line-modified"> 300             throwException(globalObject, scope, createRangeError(globalObject, &quot;Invalid array length&quot;_s));</span>
 301             return false;
 302         }
<span class="line-modified"> 303         RELEASE_AND_RETURN(scope, thisObject-&gt;setLength(globalObject, newLength, slot.isStrictMode()));</span>
 304     }
 305 
<span class="line-modified"> 306     RELEASE_AND_RETURN(scope, JSObject::put(thisObject, globalObject, propertyName, value, slot));</span>
 307 }
 308 
<span class="line-modified"> 309 bool JSArray::deleteProperty(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)</span>
 310 {
<span class="line-modified"> 311     VM&amp; vm = globalObject-&gt;vm();</span>
 312     JSArray* thisObject = jsCast&lt;JSArray*&gt;(cell);
 313 
 314     if (propertyName == vm.propertyNames-&gt;length)
 315         return false;
 316 
<span class="line-modified"> 317     return JSObject::deleteProperty(thisObject, globalObject, propertyName);</span>
 318 }
 319 
 320 static int compareKeysForQSort(const void* a, const void* b)
 321 {
 322     unsigned da = *static_cast&lt;const unsigned*&gt;(a);
 323     unsigned db = *static_cast&lt;const unsigned*&gt;(b);
 324     return (da &gt; db) - (da &lt; db);
 325 }
 326 
<span class="line-modified"> 327 void JSArray::getOwnNonIndexPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
 328 {
<span class="line-modified"> 329     VM&amp; vm = globalObject-&gt;vm();</span>
 330     JSArray* thisObject = jsCast&lt;JSArray*&gt;(object);
 331 
 332     if (mode.includeDontEnumProperties())
 333         propertyNames.add(vm.propertyNames-&gt;length);
 334 
<span class="line-modified"> 335     JSObject::getOwnNonIndexPropertyNames(thisObject, globalObject, propertyNames, mode);</span>
 336 }
 337 
 338 // This method makes room in the vector, but leaves the new space for count slots uncleared.
 339 bool JSArray::unshiftCountSlowCase(const AbstractLocker&amp;, VM&amp; vm, DeferGC&amp;, bool addToFront, unsigned count)
 340 {
 341     ASSERT(cellLock().isLocked());
 342 
 343     ArrayStorage* storage = ensureArrayStorage(vm);
 344     Butterfly* butterfly = storage-&gt;butterfly();
 345     Structure* structure = this-&gt;structure(vm);
 346     unsigned propertyCapacity = structure-&gt;outOfLineCapacity();
 347     unsigned propertySize = structure-&gt;outOfLineSize();
 348 
 349     // If not, we should have handled this on the fast path.
 350     ASSERT(!addToFront || count &gt; storage-&gt;m_indexBias);
 351 
 352     // Step 1:
 353     // Gather 4 key metrics:
 354     //  * usedVectorLength - how many entries are currently in the vector (conservative estimate - fewer may be in use in sparse vectors).
 355     //  * requiredVectorLength - how many entries are will there be in the vector, after allocating space for &#39;count&#39; more.
</pre>
<hr />
<pre>
 404     // If it did, we calculate the amount that will remain based on an atomic decay - leave the
 405     // vector with half the post-capacity it had previously.
 406     unsigned postCapacity = 0;
 407     if (!addToFront)
 408         postCapacity = newStorageCapacity - requiredVectorLength;
 409     else if (length &lt; storage-&gt;vectorLength()) {
 410         // Atomic decay, + the post-capacity cannot be greater than what is available.
 411         postCapacity = std::min((storage-&gt;vectorLength() - length) &gt;&gt; 1, newStorageCapacity - requiredVectorLength);
 412         // If we&#39;re moving contents within the same allocation, the post-capacity is being reduced.
 413         ASSERT(newAllocBase != butterfly-&gt;base(structure) || postCapacity &lt; storage-&gt;vectorLength() - length);
 414     }
 415 
 416     unsigned newVectorLength = requiredVectorLength + postCapacity;
 417     RELEASE_ASSERT(newVectorLength &lt;= MAX_STORAGE_VECTOR_LENGTH);
 418     unsigned preCapacity = newStorageCapacity - newVectorLength;
 419 
 420     Butterfly* newButterfly = Butterfly::fromBase(newAllocBase, preCapacity, propertyCapacity);
 421 
 422     if (addToFront) {
 423         ASSERT(count + usedVectorLength &lt;= newVectorLength);
<span class="line-modified"> 424         gcSafeMemmove(newButterfly-&gt;arrayStorage()-&gt;m_vector + count, storage-&gt;m_vector, sizeof(JSValue) * usedVectorLength);</span>
<span class="line-modified"> 425         gcSafeMemmove(newButterfly-&gt;propertyStorage() - propertySize, butterfly-&gt;propertyStorage() - propertySize, sizeof(JSValue) * propertySize + sizeof(IndexingHeader) + ArrayStorage::sizeFor(0));</span>
 426 
 427         // We don&#39;t need to zero the pre-capacity for the concurrent GC because it is not available to use as property storage.
<span class="line-modified"> 428         gcSafeZeroMemory(static_cast&lt;JSValue*&gt;(newButterfly-&gt;base(0, propertyCapacity)), (propertyCapacity - propertySize) * sizeof(JSValue));</span>
 429 
 430         if (allocatedNewStorage) {
 431             // We will set the vectorLength to newVectorLength. We populated requiredVectorLength
 432             // (usedVectorLength + count), which is less. Clear the difference.
 433             for (unsigned i = requiredVectorLength; i &lt; newVectorLength; ++i)
 434                 newButterfly-&gt;arrayStorage()-&gt;m_vector[i].clear();
 435         }
 436     } else if ((newAllocBase != butterfly-&gt;base(structure)) || (preCapacity != storage-&gt;m_indexBias)) {
<span class="line-modified"> 437         gcSafeMemmove(newButterfly-&gt;propertyStorage() - propertyCapacity, butterfly-&gt;propertyStorage() - propertyCapacity, sizeof(JSValue) * propertyCapacity + sizeof(IndexingHeader) + ArrayStorage::sizeFor(0));</span>
<span class="line-modified"> 438         gcSafeMemmove(newButterfly-&gt;arrayStorage()-&gt;m_vector, storage-&gt;m_vector, sizeof(JSValue) * usedVectorLength);</span>
 439 
 440         for (unsigned i = requiredVectorLength; i &lt; newVectorLength; i++)
 441             newButterfly-&gt;arrayStorage()-&gt;m_vector[i].clear();
 442     }
 443 
 444     newButterfly-&gt;arrayStorage()-&gt;setVectorLength(newVectorLength);
 445     newButterfly-&gt;arrayStorage()-&gt;m_indexBias = preCapacity;
 446 
 447     setButterfly(vm, newButterfly);
 448 
 449     return true;
 450 }
 451 
<span class="line-modified"> 452 bool JSArray::setLengthWithArrayStorage(JSGlobalObject* globalObject, unsigned newLength, bool throwException, ArrayStorage* storage)</span>
 453 {
<span class="line-modified"> 454     VM&amp; vm = globalObject-&gt;vm();</span>
 455     auto scope = DECLARE_THROW_SCOPE(vm);
 456 
 457     unsigned length = storage-&gt;length();
 458 
 459     // If the length is read only then we enter sparse mode, so should enter the following &#39;if&#39;.
 460     ASSERT(isLengthWritable() || storage-&gt;m_sparseMap);
 461 
 462     if (SparseArrayValueMap* map = storage-&gt;m_sparseMap.get()) {
 463         // Fail if the length is not writable.
 464         if (map-&gt;lengthIsReadOnly())
<span class="line-modified"> 465             return typeError(globalObject, scope, throwException, ReadonlyPropertyWriteError);</span>
 466 
 467         if (newLength &lt; length) {
 468             // Copy any keys we might be interested in into a vector.
 469             Vector&lt;unsigned, 0, UnsafeVectorOverflow&gt; keys;
 470             keys.reserveInitialCapacity(std::min(map-&gt;size(), static_cast&lt;size_t&gt;(length - newLength)));
 471             SparseArrayValueMap::const_iterator end = map-&gt;end();
 472             for (SparseArrayValueMap::const_iterator it = map-&gt;begin(); it != end; ++it) {
 473                 unsigned index = static_cast&lt;unsigned&gt;(it-&gt;key);
 474                 if (index &lt; length &amp;&amp; index &gt;= newLength)
 475                     keys.append(index);
 476             }
 477 
 478             // Check if the array is in sparse mode. If so there may be non-configurable
 479             // properties, so we have to perform deletion with caution, if not we can
 480             // delete values in any order.
 481             if (map-&gt;sparseMode()) {
 482                 qsort(keys.begin(), keys.size(), sizeof(unsigned), compareKeysForQSort);
 483                 unsigned i = keys.size();
 484                 while (i) {
 485                     unsigned index = keys[--i];
 486                     SparseArrayValueMap::iterator it = map-&gt;find(index);
 487                     ASSERT(it != map-&gt;notFound());
 488                     if (it-&gt;value.attributes() &amp; PropertyAttribute::DontDelete) {
 489                         storage-&gt;setLength(index + 1);
<span class="line-modified"> 490                         return typeError(globalObject, scope, throwException, UnableToDeletePropertyError);</span>
 491                     }
 492                     map-&gt;remove(it);
 493                 }
 494             } else {
 495                 for (unsigned i = 0; i &lt; keys.size(); ++i)
 496                     map-&gt;remove(keys[i]);
 497                 if (map-&gt;isEmpty())
 498                     deallocateSparseIndexMap();
 499             }
 500         }
 501     }
 502 
 503     if (newLength &lt; length) {
 504         // Delete properties from the vector.
 505         unsigned usedVectorLength = std::min(length, storage-&gt;vectorLength());
 506         for (unsigned i = newLength; i &lt; usedVectorLength; ++i) {
 507             WriteBarrier&lt;Unknown&gt;&amp; valueSlot = storage-&gt;m_vector[i];
 508             bool hadValue = !!valueSlot;
 509             valueSlot.clear();
 510             storage-&gt;m_numValuesInVector -= hadValue;
 511         }
 512     }
 513 
 514     storage-&gt;setLength(newLength);
 515 
 516     return true;
 517 }
 518 
<span class="line-modified"> 519 bool JSArray::appendMemcpy(JSGlobalObject* globalObject, VM&amp; vm, unsigned startIndex, JSC::JSArray* otherArray)</span>
 520 {
 521     auto scope = DECLARE_THROW_SCOPE(vm);
 522 
 523     if (!canFastCopy(vm, otherArray))
 524         return false;
 525 
 526     IndexingType type = indexingType();
 527     IndexingType otherType = otherArray-&gt;indexingType();
 528     IndexingType copyType = mergeIndexingTypeForCopying(otherType);
 529     if (type == ArrayWithUndecided &amp;&amp; copyType != NonArray) {
 530         if (copyType == ArrayWithInt32)
 531             convertUndecidedToInt32(vm);
 532         else if (copyType == ArrayWithDouble)
 533             convertUndecidedToDouble(vm);
 534         else if (copyType == ArrayWithContiguous)
 535             convertUndecidedToContiguous(vm);
 536         else {
 537             ASSERT(copyType == ArrayWithUndecided);
 538             return true;
 539         }
 540     } else if (type != copyType)
 541         return false;
 542 
 543     unsigned otherLength = otherArray-&gt;length();
 544     Checked&lt;unsigned, RecordOverflow&gt; checkedNewLength = startIndex;
 545     checkedNewLength += otherLength;
 546 
 547     unsigned newLength;
 548     if (checkedNewLength.safeGet(newLength) == CheckedState::DidOverflow) {
<span class="line-modified"> 549         throwException(globalObject, scope, createRangeError(globalObject, LengthExceededTheMaximumArrayLengthError));</span>
 550         return false;
 551     }
 552 
 553     if (newLength &gt;= MIN_SPARSE_ARRAY_INDEX)
 554         return false;
 555 
 556     if (!ensureLength(vm, newLength)) {
<span class="line-modified"> 557         throwOutOfMemoryError(globalObject, scope);</span>
 558         return false;
 559     }
 560     ASSERT(copyType == indexingType());
 561 
 562     if (UNLIKELY(otherType == ArrayWithUndecided)) {
 563         auto* butterfly = this-&gt;butterfly();
 564         if (type == ArrayWithDouble) {
 565             for (unsigned i = startIndex; i &lt; newLength; ++i)
 566                 butterfly-&gt;contiguousDouble().at(this, i) = PNaN;
 567         } else {
 568             for (unsigned i = startIndex; i &lt; newLength; ++i)
 569                 butterfly-&gt;contiguousInt32().at(this, i).setWithoutWriteBarrier(JSValue());
 570         }
 571     } else if (type == ArrayWithDouble)
<span class="line-modified"> 572         gcSafeMemcpy(butterfly()-&gt;contiguousDouble().data() + startIndex, otherArray-&gt;butterfly()-&gt;contiguousDouble().data(), sizeof(JSValue) * otherLength);</span>
 573     else {
<span class="line-modified"> 574         gcSafeMemcpy(butterfly()-&gt;contiguous().data() + startIndex, otherArray-&gt;butterfly()-&gt;contiguous().data(), sizeof(JSValue) * otherLength);</span>
 575         vm.heap.writeBarrier(this);
 576     }
 577 
 578     return true;
 579 }
 580 
<span class="line-modified"> 581 bool JSArray::setLength(JSGlobalObject* globalObject, unsigned newLength, bool throwException)</span>
 582 {
<span class="line-modified"> 583     VM&amp; vm = globalObject-&gt;vm();</span>
 584     auto scope = DECLARE_THROW_SCOPE(vm);
 585 
 586     Butterfly* butterfly = this-&gt;butterfly();
 587     switch (indexingMode()) {
 588     case ArrayClass:
 589         if (!newLength)
 590             return true;
 591         if (newLength &gt;= MIN_SPARSE_ARRAY_INDEX) {
 592             RELEASE_AND_RETURN(scope, setLengthWithArrayStorage(
<span class="line-modified"> 593                 globalObject, newLength, throwException,</span>
 594                 ensureArrayStorage(vm)));
 595         }
 596         createInitialUndecided(vm, newLength);
 597         return true;
 598 
 599     case CopyOnWriteArrayWithInt32:
 600     case CopyOnWriteArrayWithDouble:
 601     case CopyOnWriteArrayWithContiguous:
 602         if (newLength == butterfly-&gt;publicLength())
 603             return true;
 604         convertFromCopyOnWrite(vm);
 605         butterfly = this-&gt;butterfly();
 606         FALLTHROUGH;
 607 
 608     case ArrayWithUndecided:
 609     case ArrayWithInt32:
 610     case ArrayWithDouble:
 611     case ArrayWithContiguous: {
 612         if (newLength == butterfly-&gt;publicLength())
 613             return true;
 614         if (newLength &gt; MAX_STORAGE_VECTOR_LENGTH // This check ensures that we can do fast push.
 615             || (newLength &gt;= MIN_SPARSE_ARRAY_INDEX
 616                 &amp;&amp; !isDenseEnoughForVector(newLength, countElements()))) {
 617             RELEASE_AND_RETURN(scope, setLengthWithArrayStorage(
<span class="line-modified"> 618                 globalObject, newLength, throwException,</span>
 619                 ensureArrayStorage(vm)));
 620         }
 621         if (newLength &gt; butterfly-&gt;publicLength()) {
 622             if (!ensureLength(vm, newLength)) {
<span class="line-modified"> 623                 throwOutOfMemoryError(globalObject, scope);</span>
 624                 return false;
 625             }
 626             return true;
 627         }
 628 
 629         unsigned lengthToClear = butterfly-&gt;publicLength() - newLength;
 630         unsigned costToAllocateNewButterfly = 64; // a heuristic.
 631         if (lengthToClear &gt; newLength &amp;&amp; lengthToClear &gt; costToAllocateNewButterfly) {
 632             reallocateAndShrinkButterfly(vm, newLength);
 633             return true;
 634         }
 635 
 636         if (indexingType() == ArrayWithDouble) {
 637             for (unsigned i = butterfly-&gt;publicLength(); i-- &gt; newLength;)
 638                 butterfly-&gt;contiguousDouble().at(this, i) = PNaN;
 639         } else {
 640             for (unsigned i = butterfly-&gt;publicLength(); i-- &gt; newLength;)
 641                 butterfly-&gt;contiguous().at(this, i).clear();
 642         }
 643         butterfly-&gt;setPublicLength(newLength);
 644         return true;
 645     }
 646 
 647     case ArrayWithArrayStorage:
 648     case ArrayWithSlowPutArrayStorage:
<span class="line-modified"> 649         RELEASE_AND_RETURN(scope, setLengthWithArrayStorage(globalObject, newLength, throwException, arrayStorage()));</span>
 650 
 651     default:
 652         CRASH();
 653         return false;
 654     }
 655 }
 656 
<span class="line-modified"> 657 JSValue JSArray::pop(JSGlobalObject* globalObject)</span>
 658 {
<span class="line-modified"> 659     VM&amp; vm = globalObject-&gt;vm();</span>
 660     auto scope = DECLARE_THROW_SCOPE(vm);
 661 
 662     ensureWritable(vm);
 663 
 664     Butterfly* butterfly = this-&gt;butterfly();
 665 
 666     switch (indexingType()) {
 667     case ArrayClass:
 668         return jsUndefined();
 669 
 670     case ArrayWithUndecided:
 671         if (!butterfly-&gt;publicLength())
 672             return jsUndefined();
 673         // We have nothing but holes. So, drop down to the slow version.
 674         break;
 675 
 676     case ArrayWithInt32:
 677     case ArrayWithContiguous: {
 678         unsigned length = butterfly-&gt;publicLength();
 679 
</pre>
<hr />
<pre>
 695 
 696         if (!length--)
 697             return jsUndefined();
 698 
 699         RELEASE_ASSERT(length &lt; butterfly-&gt;vectorLength());
 700         double value = butterfly-&gt;contiguousDouble().at(this, length);
 701         if (value == value) {
 702             butterfly-&gt;contiguousDouble().at(this, length) = PNaN;
 703             butterfly-&gt;setPublicLength(length);
 704             return JSValue(JSValue::EncodeAsDouble, value);
 705         }
 706         break;
 707     }
 708 
 709     case ARRAY_WITH_ARRAY_STORAGE_INDEXING_TYPES: {
 710         ArrayStorage* storage = butterfly-&gt;arrayStorage();
 711 
 712         unsigned length = storage-&gt;length();
 713         if (!length) {
 714             if (!isLengthWritable())
<span class="line-modified"> 715                 throwTypeError(globalObject, scope, ReadonlyPropertyWriteError);</span>
 716             return jsUndefined();
 717         }
 718 
 719         unsigned index = length - 1;
 720         if (index &lt; storage-&gt;vectorLength()) {
 721             WriteBarrier&lt;Unknown&gt;&amp; valueSlot = storage-&gt;m_vector[index];
 722             if (valueSlot) {
 723                 --storage-&gt;m_numValuesInVector;
 724                 JSValue element = valueSlot.get();
 725                 valueSlot.clear();
 726 
 727                 RELEASE_ASSERT(isLengthWritable());
 728                 storage-&gt;setLength(index);
 729                 return element;
 730             }
 731         }
 732         break;
 733     }
 734 
 735     default:
 736         CRASH();
 737         return JSValue();
 738     }
 739 
 740     unsigned index = getArrayLength() - 1;
 741     // Let element be the result of calling the [[Get]] internal method of O with argument indx.
<span class="line-modified"> 742     JSValue element = get(globalObject, index);</span>
 743     RETURN_IF_EXCEPTION(scope, JSValue());
 744     // Call the [[Delete]] internal method of O with arguments indx and true.
<span class="line-modified"> 745     bool success = deletePropertyByIndex(this, globalObject, index);</span>
 746     RETURN_IF_EXCEPTION(scope, JSValue());
 747     if (!success) {
<span class="line-modified"> 748         throwTypeError(globalObject, scope, UnableToDeletePropertyError);</span>
 749         return jsUndefined();
 750     }
 751     // Call the [[Put]] internal method of O with arguments &quot;length&quot;, indx, and true.
 752     scope.release();
<span class="line-modified"> 753     setLength(globalObject, index, true);</span>
 754     // Return element.
 755     return element;
 756 }
 757 
 758 // Push &amp; putIndex are almost identical, with two small differences.
 759 //  - we always are writing beyond the current array bounds, so it is always necessary to update m_length &amp; m_numValuesInVector.
 760 //  - pushing to an array of length 2^32-1 stores the property, but throws a range error.
<span class="line-modified"> 761 NEVER_INLINE void JSArray::push(JSGlobalObject* globalObject, JSValue value)</span>
 762 {
<span class="line-modified"> 763     pushInline(globalObject, value);</span>
 764 }
 765 
<span class="line-modified"> 766 JSArray* JSArray::fastSlice(JSGlobalObject* globalObject, unsigned startIndex, unsigned count)</span>
 767 {
<span class="line-modified"> 768     VM&amp; vm = globalObject-&gt;vm();</span>
 769 
 770     ensureWritable(vm);
 771 
 772     auto arrayType = indexingMode();
 773     switch (arrayType) {
 774     case ArrayWithDouble:
 775     case ArrayWithInt32:
 776     case ArrayWithContiguous: {
 777         if (count &gt;= MIN_SPARSE_ARRAY_INDEX || structure(vm)-&gt;holesMustForwardToPrototype(vm, this))
 778             return nullptr;
 779 
<span class="line-modified"> 780         Structure* resultStructure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(arrayType);</span>

 781         if (UNLIKELY(hasAnyArrayStorage(resultStructure-&gt;indexingType())))
 782             return nullptr;
 783 
<span class="line-modified"> 784         ASSERT(!globalObject-&gt;isHavingABadTime());</span>
 785         ObjectInitializationScope scope(vm);
 786         JSArray* resultArray = JSArray::tryCreateUninitializedRestricted(scope, resultStructure, count);
 787         if (UNLIKELY(!resultArray))
 788             return nullptr;
 789 
 790         auto&amp; resultButterfly = *resultArray-&gt;butterfly();
 791         if (arrayType == ArrayWithDouble)
<span class="line-modified"> 792             gcSafeMemcpy(resultButterfly.contiguousDouble().data(), butterfly()-&gt;contiguousDouble().data() + startIndex, sizeof(JSValue) * count);</span>
 793         else
<span class="line-modified"> 794             gcSafeMemcpy(resultButterfly.contiguous().data(), butterfly()-&gt;contiguous().data() + startIndex, sizeof(JSValue) * count);</span>

 795 
<span class="line-added"> 796         ASSERT(resultButterfly.publicLength() == count);</span>
 797         return resultArray;
 798     }
 799     default:
 800         return nullptr;
 801     }
 802 }
 803 
 804 bool JSArray::shiftCountWithArrayStorage(VM&amp; vm, unsigned startIndex, unsigned count, ArrayStorage* storage)
 805 {
 806     unsigned oldLength = storage-&gt;length();
 807     RELEASE_ASSERT(count &lt;= oldLength);
 808 
 809     // If the array contains holes or is otherwise in an abnormal state,
 810     // use the generic algorithm in ArrayPrototype.
 811     if (storage-&gt;hasHoles()
 812         || hasSparseMap()
 813         || shouldUseSlowPut(indexingType())) {
 814         return false;
 815     }
 816 
</pre>
<hr />
<pre>
 832     DisallowGC disallowGC;
 833     auto locker = holdLock(cellLock());
 834 
 835     if (startIndex + count &gt; vectorLength)
 836         count = vectorLength - startIndex;
 837 
 838     unsigned usedVectorLength = std::min(vectorLength, oldLength);
 839 
 840     unsigned numElementsBeforeShiftRegion = startIndex;
 841     unsigned firstIndexAfterShiftRegion = startIndex + count;
 842     unsigned numElementsAfterShiftRegion = usedVectorLength - firstIndexAfterShiftRegion;
 843     ASSERT(numElementsBeforeShiftRegion + count + numElementsAfterShiftRegion == usedVectorLength);
 844 
 845     // The point of this comparison seems to be to minimize the amount of elements that have to
 846     // be moved during a shift operation.
 847     if (numElementsBeforeShiftRegion &lt; numElementsAfterShiftRegion) {
 848         // The number of elements before the shift region is less than the number of elements
 849         // after the shift region, so we move the elements before to the right.
 850         if (numElementsBeforeShiftRegion) {
 851             RELEASE_ASSERT(count + startIndex &lt;= vectorLength);
<span class="line-modified"> 852             gcSafeMemmove(storage-&gt;m_vector + count,</span>
 853                 storage-&gt;m_vector,
 854                 sizeof(JSValue) * startIndex);
 855         }
 856         // Adjust the Butterfly and the index bias. We only need to do this here because we&#39;re changing
 857         // the start of the Butterfly, which needs to point at the first indexed property in the used
 858         // portion of the vector.
 859         Butterfly* butterfly = this-&gt;butterfly()-&gt;shift(structure(vm), count);
 860         storage = butterfly-&gt;arrayStorage();
 861         storage-&gt;m_indexBias += count;
 862 
 863         // Since we&#39;re consuming part of the vector by moving its beginning to the left,
 864         // we need to modify the vector length appropriately.
 865         storage-&gt;setVectorLength(vectorLength - count);
 866         setButterfly(vm, butterfly);
 867     } else {
 868         // The number of elements before the shift region is greater than or equal to the number
 869         // of elements after the shift region, so we move the elements after the shift region to the left.
<span class="line-modified"> 870         gcSafeMemmove(storage-&gt;m_vector + startIndex,</span>
 871             storage-&gt;m_vector + firstIndexAfterShiftRegion,
 872             sizeof(JSValue) * numElementsAfterShiftRegion);
 873 
 874         // Clear the slots of the elements we just moved.
 875         unsigned startOfEmptyVectorTail = usedVectorLength - count;
 876         for (unsigned i = startOfEmptyVectorTail; i &lt; usedVectorLength; ++i)
 877             storage-&gt;m_vector[i].clear();
 878         // We don&#39;t modify the index bias or the Butterfly pointer in this case because we&#39;re not changing
 879         // the start of the Butterfly, which needs to point at the first indexed property in the used
 880         // portion of the vector. We also don&#39;t modify the vector length because we&#39;re not actually changing
 881         // its length; we&#39;re just using less of it.
 882     }
 883 
 884     return true;
 885 }
 886 
<span class="line-modified"> 887 bool JSArray::shiftCountWithAnyIndexingType(JSGlobalObject* globalObject, unsigned&amp; startIndex, unsigned count)</span>
 888 {
<span class="line-modified"> 889     VM&amp; vm = globalObject-&gt;vm();</span>
 890     RELEASE_ASSERT(count &gt; 0);
 891 
 892     ensureWritable(vm);
 893 
 894     Butterfly* butterfly = this-&gt;butterfly();
 895 
<span class="line-modified"> 896     auto indexingType = this-&gt;indexingType();</span>
<span class="line-added"> 897     switch (indexingType) {</span>
 898     case ArrayClass:
 899         return true;
 900 
 901     case ArrayWithUndecided:
 902         // Don&#39;t handle this because it&#39;s confusing and it shouldn&#39;t come up.
 903         return false;
 904 
 905     case ArrayWithInt32:
 906     case ArrayWithContiguous: {
 907         unsigned oldLength = butterfly-&gt;publicLength();
 908         RELEASE_ASSERT(count &lt;= oldLength);
 909 
 910         // We may have to walk the entire array to do the shift. We&#39;re willing to do
 911         // so only if it&#39;s not horribly slow.
 912         if (oldLength - (startIndex + count) &gt;= MIN_SPARSE_ARRAY_INDEX)
 913             return shiftCountWithArrayStorage(vm, startIndex, count, ensureArrayStorage(vm));
 914 
 915         // Storing to a hole is fine since we&#39;re still having a good time. But reading from a hole
 916         // is totally not fine, since we might have to read from the proto chain.
 917         // We have to check for holes before we start moving things around so that we don&#39;t get halfway
 918         // through shifting and then realize we should have been in ArrayStorage mode.
 919         unsigned end = oldLength - count;
 920         if (this-&gt;structure(vm)-&gt;holesMustForwardToPrototype(vm, this)) {
 921             for (unsigned i = startIndex; i &lt; end; ++i) {
 922                 JSValue v = butterfly-&gt;contiguous().at(this, i + count).get();
 923                 if (UNLIKELY(!v)) {
 924                     startIndex = i;
 925                     return shiftCountWithArrayStorage(vm, startIndex, count, ensureArrayStorage(vm));
 926                 }
 927                 butterfly-&gt;contiguous().at(this, i).setWithoutWriteBarrier(v);
 928             }
 929         } else {
<span class="line-modified"> 930             gcSafeMemmove(butterfly-&gt;contiguous().data() + startIndex,</span>
 931                 butterfly-&gt;contiguous().data() + startIndex + count,
 932                 sizeof(JSValue) * (end - startIndex));
 933         }
 934 
 935         for (unsigned i = end; i &lt; oldLength; ++i)
 936             butterfly-&gt;contiguous().at(this, i).clear();
 937 
 938         butterfly-&gt;setPublicLength(oldLength - count);
 939 
 940         // Our memmoving of values around in the array could have concealed some of them from
 941         // the collector. Let&#39;s make sure that the collector scans this object again.
<span class="line-modified"> 942         if (indexingType == ArrayWithContiguous)</span>
<span class="line-added"> 943             vm.heap.writeBarrier(this);</span>
 944 
 945         return true;
 946     }
 947 
 948     case ArrayWithDouble: {
 949         unsigned oldLength = butterfly-&gt;publicLength();
 950         RELEASE_ASSERT(count &lt;= oldLength);
 951 
 952         // We may have to walk the entire array to do the shift. We&#39;re willing to do
 953         // so only if it&#39;s not horribly slow.
 954         if (oldLength - (startIndex + count) &gt;= MIN_SPARSE_ARRAY_INDEX)
 955             return shiftCountWithArrayStorage(vm, startIndex, count, ensureArrayStorage(vm));
 956 
 957         // Storing to a hole is fine since we&#39;re still having a good time. But reading from a hole
 958         // is totally not fine, since we might have to read from the proto chain.
 959         // We have to check for holes before we start moving things around so that we don&#39;t get halfway
 960         // through shifting and then realize we should have been in ArrayStorage mode.
 961         unsigned end = oldLength - count;
 962         if (this-&gt;structure(vm)-&gt;holesMustForwardToPrototype(vm, this)) {
 963             for (unsigned i = startIndex; i &lt; end; ++i) {
 964                 double v = butterfly-&gt;contiguousDouble().at(this, i + count);
 965                 if (UNLIKELY(v != v)) {
 966                     startIndex = i;
 967                     return shiftCountWithArrayStorage(vm, startIndex, count, ensureArrayStorage(vm));
 968                 }
 969                 butterfly-&gt;contiguousDouble().at(this, i) = v;
 970             }
 971         } else {
<span class="line-modified"> 972             gcSafeMemmove(butterfly-&gt;contiguousDouble().data() + startIndex,</span>
 973                 butterfly-&gt;contiguousDouble().data() + startIndex + count,
 974                 sizeof(JSValue) * (end - startIndex));
 975         }
 976         for (unsigned i = end; i &lt; oldLength; ++i)
 977             butterfly-&gt;contiguousDouble().at(this, i) = PNaN;
 978 
 979         butterfly-&gt;setPublicLength(oldLength - count);
 980         return true;
 981     }
 982 
 983     case ArrayWithArrayStorage:
 984     case ArrayWithSlowPutArrayStorage:
 985         return shiftCountWithArrayStorage(vm, startIndex, count, arrayStorage());
 986 
 987     default:
 988         CRASH();
 989         return false;
 990     }
 991 }
 992 
 993 // Returns true if the unshift can be handled, false to fallback.
<span class="line-modified"> 994 bool JSArray::unshiftCountWithArrayStorage(JSGlobalObject* globalObject, unsigned startIndex, unsigned count, ArrayStorage* storage)</span>
 995 {
<span class="line-modified"> 996     VM&amp; vm = globalObject-&gt;vm();</span>
 997     auto scope = DECLARE_THROW_SCOPE(vm);
 998 
 999     unsigned length = storage-&gt;length();
1000 
1001     RELEASE_ASSERT(startIndex &lt;= length);
1002 
1003     // If the array contains holes or is otherwise in an abnormal state,
1004     // use the generic algorithm in ArrayPrototype.
1005     if (storage-&gt;hasHoles() || storage-&gt;inSparseMode() || shouldUseSlowPut(indexingType()))
1006         return false;
1007 
1008     bool moveFront = !startIndex || startIndex &lt; length / 2;
1009 
1010     unsigned vectorLength = storage-&gt;vectorLength();
1011 
1012     // Need to have GC deferred around the unshiftCountSlowCase(), since that leaves the butterfly in
1013     // a weird state: some parts of it will be left uninitialized, which we will fill in here.
1014     DeferGC deferGC(vm.heap);
1015     auto locker = holdLock(cellLock());
1016 
1017     if (moveFront &amp;&amp; storage-&gt;m_indexBias &gt;= count) {
1018         Butterfly* newButterfly = storage-&gt;butterfly()-&gt;unshift(structure(vm), count);
1019         storage = newButterfly-&gt;arrayStorage();
1020         storage-&gt;m_indexBias -= count;
1021         storage-&gt;setVectorLength(vectorLength + count);
1022         setButterfly(vm, newButterfly);
1023     } else if (!moveFront &amp;&amp; vectorLength - length &gt;= count)
1024         storage = storage-&gt;butterfly()-&gt;arrayStorage();
1025     else if (unshiftCountSlowCase(locker, vm, deferGC, moveFront, count))
1026         storage = arrayStorage();
1027     else {
<span class="line-modified">1028         throwOutOfMemoryError(globalObject, scope);</span>
1029         return true;
1030     }
1031 
1032     WriteBarrier&lt;Unknown&gt;* vector = storage-&gt;m_vector;
1033 
1034     if (startIndex) {
1035         if (moveFront)
<span class="line-modified">1036             gcSafeMemmove(vector, vector + count, startIndex * sizeof(JSValue));</span>
1037         else if (length - startIndex)
<span class="line-modified">1038             gcSafeMemmove(vector + startIndex + count, vector + startIndex, (length - startIndex) * sizeof(JSValue));</span>
1039     }
1040 
1041     for (unsigned i = 0; i &lt; count; i++)
1042         vector[i + startIndex].clear();
1043 
1044     return true;
1045 }
1046 
<span class="line-modified">1047 bool JSArray::unshiftCountWithAnyIndexingType(JSGlobalObject* globalObject, unsigned startIndex, unsigned count)</span>
1048 {
<span class="line-modified">1049     VM&amp; vm = globalObject-&gt;vm();</span>
1050     auto scope = DECLARE_THROW_SCOPE(vm);
1051 
1052     ensureWritable(vm);
1053 
1054     Butterfly* butterfly = this-&gt;butterfly();
1055 
1056     switch (indexingType()) {
1057     case ArrayClass:
1058     case ArrayWithUndecided:
1059         // We could handle this. But it shouldn&#39;t ever come up, so we won&#39;t.
1060         return false;
1061 
1062     case ArrayWithInt32:
1063     case ArrayWithContiguous: {
1064         unsigned oldLength = butterfly-&gt;publicLength();
1065 
1066         // We may have to walk the entire array to do the unshift. We&#39;re willing to do so
1067         // only if it&#39;s not horribly slow.
1068         if (oldLength - startIndex &gt;= MIN_SPARSE_ARRAY_INDEX)
<span class="line-modified">1069             RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(globalObject, startIndex, count, ensureArrayStorage(vm)));</span>
1070 
1071         Checked&lt;unsigned, RecordOverflow&gt; checkedLength(oldLength);
1072         checkedLength += count;
1073         unsigned newLength;
1074         if (CheckedState::DidOverflow == checkedLength.safeGet(newLength)) {
<span class="line-modified">1075             throwOutOfMemoryError(globalObject, scope);</span>
1076             return true;
1077         }
1078         if (newLength &gt; MAX_STORAGE_VECTOR_LENGTH)
1079             return false;
1080         if (!ensureLength(vm, newLength)) {
<span class="line-modified">1081             throwOutOfMemoryError(globalObject, scope);</span>
1082             return true;
1083         }
1084         butterfly = this-&gt;butterfly();
1085 
1086         // We have to check for holes before we start moving things around so that we don&#39;t get halfway
1087         // through shifting and then realize we should have been in ArrayStorage mode.
1088         for (unsigned i = oldLength; i-- &gt; startIndex;) {
1089             JSValue v = butterfly-&gt;contiguous().at(this, i).get();
1090             if (UNLIKELY(!v))
<span class="line-modified">1091                 RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(globalObject, startIndex, count, ensureArrayStorage(vm)));</span>
1092         }
1093 
1094         for (unsigned i = oldLength; i-- &gt; startIndex;) {
1095             JSValue v = butterfly-&gt;contiguous().at(this, i).get();
1096             ASSERT(v);
1097             butterfly-&gt;contiguous().at(this, i + count).setWithoutWriteBarrier(v);
1098         }
1099 
1100         // Our memmoving of values around in the array could have concealed some of them from
1101         // the collector. Let&#39;s make sure that the collector scans this object again.
1102         vm.heap.writeBarrier(this);
1103 
1104         // NOTE: we&#39;re leaving being garbage in the part of the array that we shifted out
1105         // of. This is fine because the caller is required to store over that area, and
1106         // in contiguous mode storing into a hole is guaranteed to behave exactly the same
1107         // as storing over an existing element.
1108 
1109         return true;
1110     }
1111 
1112     case ArrayWithDouble: {
1113         unsigned oldLength = butterfly-&gt;publicLength();
1114 
1115         // We may have to walk the entire array to do the unshift. We&#39;re willing to do so
1116         // only if it&#39;s not horribly slow.
1117         if (oldLength - startIndex &gt;= MIN_SPARSE_ARRAY_INDEX)
<span class="line-modified">1118             RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(globalObject, startIndex, count, ensureArrayStorage(vm)));</span>
1119 
1120         Checked&lt;unsigned, RecordOverflow&gt; checkedLength(oldLength);
1121         checkedLength += count;
1122         unsigned newLength;
1123         if (CheckedState::DidOverflow == checkedLength.safeGet(newLength)) {
<span class="line-modified">1124             throwOutOfMemoryError(globalObject, scope);</span>
1125             return true;
1126         }
1127         if (newLength &gt; MAX_STORAGE_VECTOR_LENGTH)
1128             return false;
1129         if (!ensureLength(vm, newLength)) {
<span class="line-modified">1130             throwOutOfMemoryError(globalObject, scope);</span>
1131             return true;
1132         }
1133         butterfly = this-&gt;butterfly();
1134 
1135         // We have to check for holes before we start moving things around so that we don&#39;t get halfway
1136         // through shifting and then realize we should have been in ArrayStorage mode.
1137         for (unsigned i = oldLength; i-- &gt; startIndex;) {
1138             double v = butterfly-&gt;contiguousDouble().at(this, i);
1139             if (UNLIKELY(v != v))
<span class="line-modified">1140                 RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(globalObject, startIndex, count, ensureArrayStorage(vm)));</span>
1141         }
1142 
1143         for (unsigned i = oldLength; i-- &gt; startIndex;) {
1144             double v = butterfly-&gt;contiguousDouble().at(this, i);
1145             ASSERT(v == v);
1146             butterfly-&gt;contiguousDouble().at(this, i + count) = v;
1147         }
1148 
1149         // NOTE: we&#39;re leaving being garbage in the part of the array that we shifted out
1150         // of. This is fine because the caller is required to store over that area, and
1151         // in contiguous mode storing into a hole is guaranteed to behave exactly the same
1152         // as storing over an existing element.
1153 
1154         return true;
1155     }
1156 
1157     case ArrayWithArrayStorage:
1158     case ArrayWithSlowPutArrayStorage:
<span class="line-modified">1159         RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(globalObject, startIndex, count, arrayStorage()));</span>
1160 
1161     default:
1162         CRASH();
1163         return false;
1164     }
1165 }
1166 
<span class="line-modified">1167 void JSArray::fillArgList(JSGlobalObject* globalObject, MarkedArgumentBuffer&amp; args)</span>
1168 {
1169     unsigned i = 0;
1170     unsigned vectorEnd;
1171     WriteBarrier&lt;Unknown&gt;* vector;
1172 
1173     Butterfly* butterfly = this-&gt;butterfly();
1174 
1175     switch (indexingType()) {
1176     case ArrayClass:
1177         return;
1178 
1179     case ArrayWithUndecided: {
1180         vector = 0;
1181         vectorEnd = 0;
1182         break;
1183     }
1184 
1185     case ArrayWithInt32:
1186     case ArrayWithContiguous: {
1187         vectorEnd = butterfly-&gt;publicLength();
</pre>
<hr />
<pre>
1210     }
1211 
1212     default:
1213         CRASH();
1214 #if COMPILER_QUIRK(CONSIDERS_UNREACHABLE_CODE)
1215         vector = 0;
1216         vectorEnd = 0;
1217         break;
1218 #endif
1219     }
1220 
1221     for (; i &lt; vectorEnd; ++i) {
1222         WriteBarrier&lt;Unknown&gt;&amp; v = vector[i];
1223         if (!v)
1224             break;
1225         args.append(v.get());
1226     }
1227 
1228     // FIXME: What prevents this from being called with a RuntimeArray? The length function will always return 0 in that case.
1229     for (; i &lt; length(); ++i)
<span class="line-modified">1230         args.append(get(globalObject, i));</span>
1231 }
1232 
<span class="line-modified">1233 void JSArray::copyToArguments(JSGlobalObject* globalObject, JSValue* firstElementDest, unsigned offset, unsigned length)</span>
1234 {
<span class="line-modified">1235     VM&amp; vm = globalObject-&gt;vm();</span>
1236     auto scope = DECLARE_THROW_SCOPE(vm);
1237 
1238     unsigned i = offset;
1239     WriteBarrier&lt;Unknown&gt;* vector;
1240     unsigned vectorEnd;
1241     length += offset; // We like to think of the length as being our length, rather than the output length.
1242 
1243     // FIXME: What prevents this from being called with a RuntimeArray? The length function will always return 0 in that case.
1244     ASSERT(length == this-&gt;length());
1245 
1246     Butterfly* butterfly = this-&gt;butterfly();
1247     switch (indexingType()) {
1248     case ArrayClass:
1249         return;
1250 
1251     case ArrayWithUndecided: {
1252         vector = 0;
1253         vectorEnd = 0;
1254         break;
1255     }
1256 
1257     case ArrayWithInt32:
1258     case ArrayWithContiguous: {
1259         vector = butterfly-&gt;contiguous().data();
1260         vectorEnd = butterfly-&gt;publicLength();
1261         break;
1262     }
1263 
1264     case ArrayWithDouble: {
1265         vector = 0;
1266         vectorEnd = 0;
1267         for (; i &lt; butterfly-&gt;publicLength(); ++i) {
1268             ASSERT(i &lt; butterfly-&gt;vectorLength());
1269             double v = butterfly-&gt;contiguousDouble().at(this, i);
1270             if (v != v)
1271                 break;
<span class="line-modified">1272             firstElementDest[i - offset] = JSValue(JSValue::EncodeAsDouble, v);</span>
1273         }
1274         break;
1275     }
1276 
1277     case ARRAY_WITH_ARRAY_STORAGE_INDEXING_TYPES: {
1278         ArrayStorage* storage = butterfly-&gt;arrayStorage();
1279         vector = storage-&gt;m_vector;
1280         vectorEnd = std::min(length, storage-&gt;vectorLength());
1281         break;
1282     }
1283 
1284     default:
1285         CRASH();
1286 #if COMPILER_QUIRK(CONSIDERS_UNREACHABLE_CODE)
1287         vector = 0;
1288         vectorEnd = 0;
1289         break;
1290 #endif
1291     }
1292 
1293     for (; i &lt; vectorEnd; ++i) {
1294         WriteBarrier&lt;Unknown&gt;&amp; v = vector[i];
1295         if (!v)
1296             break;
<span class="line-modified">1297         firstElementDest[i - offset] = v.get();</span>
1298     }
1299 
1300     for (; i &lt; length; ++i) {
<span class="line-modified">1301         firstElementDest[i - offset] = get(globalObject, i);</span>
1302         RETURN_IF_EXCEPTION(scope, void());
1303     }
1304 }
1305 
1306 bool JSArray::isIteratorProtocolFastAndNonObservable()
1307 {
1308     JSGlobalObject* globalObject = this-&gt;globalObject();
1309     if (!globalObject-&gt;isArrayPrototypeIteratorProtocolFastAndNonObservable())
1310         return false;
1311 
1312     VM&amp; vm = globalObject-&gt;vm();
1313     Structure* structure = this-&gt;structure(vm);
1314     // This is the fast case. Many arrays will be an original array.
1315     if (globalObject-&gt;isOriginalArrayStructure(structure))
1316         return true;
1317 
1318     if (structure-&gt;mayInterceptIndexedAccesses())
1319         return false;
1320 
1321     if (getPrototypeDirect(vm) != globalObject-&gt;arrayPrototype())
</pre>
<hr />
<pre>
1329 
1330 inline JSArray* constructArray(ObjectInitializationScope&amp; scope, Structure* arrayStructure, unsigned length)
1331 {
1332     JSArray* array = JSArray::tryCreateUninitializedRestricted(scope, arrayStructure, length);
1333 
1334     // FIXME: we should probably throw an out of memory error here, but
1335     // when making this change we should check that all clients of this
1336     // function will correctly handle an exception being thrown from here.
1337     // https://bugs.webkit.org/show_bug.cgi?id=169786
1338     RELEASE_ASSERT(array);
1339 
1340     // FIXME: We only need this for subclasses of Array because we might need to allocate a new structure to change
1341     // indexing types while initializing. If this triggered a GC then we might scan our currently uninitialized
1342     // array and crash. https://bugs.webkit.org/show_bug.cgi?id=186811
1343     if (!arrayStructure-&gt;globalObject()-&gt;isOriginalArrayStructure(arrayStructure))
1344         JSArray::eagerlyInitializeButterfly(scope, array, length);
1345 
1346     return array;
1347 }
1348 
<span class="line-modified">1349 JSArray* constructArray(JSGlobalObject* globalObject, Structure* arrayStructure, const ArgList&amp; values)</span>
1350 {
<span class="line-modified">1351     VM&amp; vm = globalObject-&gt;vm();</span>
1352     unsigned length = values.size();
1353     ObjectInitializationScope scope(vm);
1354 
1355     JSArray* array = constructArray(scope, arrayStructure, length);
1356     for (unsigned i = 0; i &lt; length; ++i)
1357         array-&gt;initializeIndex(scope, i, values.at(i));
1358     return array;
1359 }
1360 
<span class="line-modified">1361 JSArray* constructArray(JSGlobalObject* globalObject, Structure* arrayStructure, const JSValue* values, unsigned length)</span>
1362 {
<span class="line-modified">1363     VM&amp; vm = globalObject-&gt;vm();</span>
1364     ObjectInitializationScope scope(vm);
1365 
1366     JSArray* array = constructArray(scope, arrayStructure, length);
1367     for (unsigned i = 0; i &lt; length; ++i)
1368         array-&gt;initializeIndex(scope, i, values[i]);
1369     return array;
1370 }
1371 
<span class="line-modified">1372 JSArray* constructArrayNegativeIndexed(JSGlobalObject* globalObject, Structure* arrayStructure, const JSValue* values, unsigned length)</span>
1373 {
<span class="line-modified">1374     VM&amp; vm = globalObject-&gt;vm();</span>
1375     ObjectInitializationScope scope(vm);
1376 
1377     JSArray* array = constructArray(scope, arrayStructure, length);
1378     for (int i = 0; i &lt; static_cast&lt;int&gt;(length); ++i)
1379         array-&gt;initializeIndex(scope, i, values[-i]);
1380     return array;
1381 }
1382 
1383 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="IteratorPrototype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSArray.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
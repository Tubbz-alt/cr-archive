diff a/modules/javafx.web/src/main/native/Source/WebCore/animation/AnimationTimeline.h b/modules/javafx.web/src/main/native/Source/WebCore/animation/AnimationTimeline.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/animation/AnimationTimeline.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/animation/AnimationTimeline.h
@@ -44,11 +44,11 @@
 class CSSAnimation;
 class CSSTransition;
 class DeclarativeAnimation;
 class Element;
 
-class AnimationTimeline : public RefCounted<AnimationTimeline> {
+class AnimationTimeline : public RefCounted<AnimationTimeline>, public CanMakeWeakPtr<AnimationTimeline> {
 public:
     virtual bool isDocumentTimeline() const { return false; }
 
     void forgetAnimation(WebAnimation*);
     virtual void animationTimingDidChange(WebAnimation&);
@@ -57,41 +57,52 @@
     Optional<double> bindingsCurrentTime();
     virtual Optional<Seconds> currentTime() { return m_currentTime; }
 
     enum class Ordering : uint8_t { Sorted, Unsorted };
     Vector<RefPtr<WebAnimation>> animationsForElement(Element&, Ordering ordering = Ordering::Unsorted) const;
+
     void elementWasRemoved(Element&);
     void removeAnimationsForElement(Element&);
+
+    void willChangeRendererForElement(Element&);
+    void willDestroyRendererForElement(Element&);
     void cancelDeclarativeAnimationsForElement(Element&);
+
     virtual void animationWasAddedToElement(WebAnimation&, Element&);
     virtual void animationWasRemovedFromElement(WebAnimation&, Element&);
+
     void removeDeclarativeAnimationFromListsForOwningElement(WebAnimation&, Element&);
 
     void updateCSSAnimationsForElement(Element&, const RenderStyle* currentStyle, const RenderStyle& afterChangeStyle);
     void updateCSSTransitionsForElement(Element&, const RenderStyle& currentStyle, const RenderStyle& afterChangeStyle);
 
-    using ElementToAnimationsMap = HashMap<Element*, ListHashSet<RefPtr<WebAnimation>>>;
+    using AnimationCollection = ListHashSet<RefPtr<WebAnimation>>;
+    using ElementToAnimationsMap = HashMap<Element*, AnimationCollection>;
     using PropertyToTransitionMap = HashMap<CSSPropertyID, RefPtr<CSSTransition>>;
 
     virtual ~AnimationTimeline();
 
 protected:
     explicit AnimationTimeline();
 
     Vector<WeakPtr<WebAnimation>> m_allAnimations;
-    ListHashSet<RefPtr<WebAnimation>> m_animations;
+    AnimationCollection m_animations;
     HashMap<Element*, PropertyToTransitionMap> m_elementToCompletedCSSTransitionByCSSPropertyID;
 
 private:
-    RefPtr<WebAnimation> cssAnimationForElementAndProperty(Element&, CSSPropertyID);
+    using CSSAnimationCollection = ListHashSet<RefPtr<CSSAnimation>>;
+    using ElementToCSSAnimationsMap = HashMap<Element*, CSSAnimationCollection>;
+
+    void updateGlobalPosition(WebAnimation&);
     PropertyToTransitionMap& ensureRunningTransitionsByProperty(Element&);
-    void cancelDeclarativeAnimation(DeclarativeAnimation&);
+    void updateCSSTransitionsForElementAndProperty(Element&, CSSPropertyID, const RenderStyle& currentStyle, const RenderStyle& afterChangeStyle, PropertyToTransitionMap&, PropertyToTransitionMap&, const MonotonicTime);
+    void removeCSSAnimationCreatedByMarkup(Element&, CSSAnimation&);
 
     ElementToAnimationsMap m_elementToAnimationsMap;
     ElementToAnimationsMap m_elementToCSSAnimationsMap;
     ElementToAnimationsMap m_elementToCSSTransitionsMap;
-    HashMap<Element*, HashMap<String, RefPtr<CSSAnimation>>> m_elementToCSSAnimationByName;
+    ElementToCSSAnimationsMap m_elementToCSSAnimationsCreatedByMarkupMap;
     HashMap<Element*, PropertyToTransitionMap> m_elementToRunningCSSTransitionByCSSPropertyID;
 
     Markable<Seconds, Seconds::MarkableTraits> m_currentTime;
 };
 

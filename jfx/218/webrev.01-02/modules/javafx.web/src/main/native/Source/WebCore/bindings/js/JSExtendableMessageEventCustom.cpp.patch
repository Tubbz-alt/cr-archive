diff a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSExtendableMessageEventCustom.cpp b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSExtendableMessageEventCustom.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSExtendableMessageEventCustom.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSExtendableMessageEventCustom.cpp
@@ -34,57 +34,57 @@
 
 namespace WebCore {
 
 using namespace JSC;
 
-JSC::EncodedJSValue constructJSExtendableMessageEvent(JSC::ExecState& state)
+JSC::EncodedJSValue constructJSExtendableMessageEvent(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame& callFrame)
 {
-    VM& vm = state.vm();
+    VM& vm = lexicalGlobalObject->vm();
     auto throwScope = DECLARE_THROW_SCOPE(vm);
     UNUSED_PARAM(throwScope);
 
-    auto* jsConstructor = jsCast<JSDOMConstructorBase*>(state.jsCallee());
+    auto* jsConstructor = jsCast<JSDOMConstructorBase*>(callFrame.jsCallee());
     ASSERT(jsConstructor);
-    if (UNLIKELY(state.argumentCount() < 1))
-        return throwVMError(&state, throwScope, createNotEnoughArgumentsError(&state));
-    auto type = convert<IDLDOMString>(state, state.uncheckedArgument(0));
+    if (UNLIKELY(callFrame.argumentCount() < 1))
+        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
+    auto type = convert<IDLDOMString>(*lexicalGlobalObject, callFrame.uncheckedArgument(0));
     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
-    auto eventInitDict = convert<IDLDictionary<ExtendableMessageEvent::Init>>(state, state.argument(1));
+    auto eventInitDict = convert<IDLDictionary<ExtendableMessageEvent::Init>>(*lexicalGlobalObject, callFrame.argument(1));
     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
 
     JSValue data = eventInitDict.data;
-    auto object = ExtendableMessageEvent::create(state, WTFMove(type), WTFMove(eventInitDict));
+    auto object = ExtendableMessageEvent::create(*lexicalGlobalObject, WTFMove(type), WTFMove(eventInitDict));
     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
 
-    JSValue wrapper = toJSNewlyCreated<IDLInterface<ExtendableMessageEvent>>(state, *jsConstructor->globalObject(), WTFMove(object));
+    JSValue wrapper = toJSNewlyCreated<IDLInterface<ExtendableMessageEvent>>(*lexicalGlobalObject, *jsConstructor->globalObject(), WTFMove(object));
 
     // Cache the JSValue passed in for data parameter in the wrapper so the getter returns the exact value
     // it was initialized too. We do not store the JSValue in the implementation object to avoid leaks.
     auto* jsMessageEvent = jsCast<JSExtendableMessageEvent*>(wrapper);
-    jsMessageEvent->m_data.set(state.vm(), jsMessageEvent, data);
+    jsMessageEvent->m_data.set(vm, jsMessageEvent, data);
 
     return JSValue::encode(wrapper);
 }
 
-JSValue JSExtendableMessageEvent::data(ExecState& state) const
+JSValue JSExtendableMessageEvent::data(JSGlobalObject& lexicalGlobalObject) const
 {
     if (JSValue cachedValue = m_data.get()) {
         // We cannot use a cached object if we are in a different world than the one it was created in.
-        if (isWorldCompatible(state, cachedValue))
+        if (isWorldCompatible(lexicalGlobalObject, cachedValue))
             return cachedValue;
         ASSERT_NOT_REACHED();
     }
 
     auto& event = wrapped();
     JSValue result;
     if (auto* serializedValue = event.data())
-        result = serializedValue->deserialize(state, globalObject(), event.ports(), SerializationErrorMode::NonThrowing);
+        result = serializedValue->deserialize(lexicalGlobalObject, globalObject(), event.ports(), SerializationErrorMode::NonThrowing);
     else
         result = jsNull();
 
     // Save the result so we don't have to deserialize the value again.
-    m_data.set(state.vm(), this, result);
+    m_data.set(lexicalGlobalObject.vm(), this, result);
     return result;
 }
 
 }
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSCustomElementInterface.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSCanvasRenderingContext2DCustom.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSCustomElementInterface.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSCustomElementInterface.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 38 #include &quot;JSExecState.h&quot;
 39 #include &quot;JSExecStateInstrumentation.h&quot;
 40 #include &quot;JSHTMLElement.h&quot;
 41 #include &quot;ScriptExecutionContext.h&quot;
 42 #include &lt;JavaScriptCore/JSLock.h&gt;
 43 #include &lt;JavaScriptCore/WeakInlines.h&gt;
 44 
 45 namespace WebCore {
 46 using namespace JSC;
 47 
 48 JSCustomElementInterface::JSCustomElementInterface(const QualifiedName&amp; name, JSObject* constructor, JSDOMGlobalObject* globalObject)
 49     : ActiveDOMCallback(globalObject-&gt;scriptExecutionContext())
 50     , m_name(name)
 51     , m_constructor(constructor)
 52     , m_isolatedWorld(globalObject-&gt;world())
 53 {
 54 }
 55 
 56 JSCustomElementInterface::~JSCustomElementInterface() = default;
 57 
<span class="line-modified"> 58 static RefPtr&lt;Element&gt; constructCustomElementSynchronously(Document&amp;, VM&amp;, ExecState&amp;, JSObject* constructor, const AtomString&amp; localName);</span>
 59 
 60 Ref&lt;Element&gt; JSCustomElementInterface::constructElementWithFallback(Document&amp; document, const AtomString&amp; localName)
 61 {
 62     if (auto element = tryToConstructCustomElement(document, localName))
 63         return element.releaseNonNull();
 64 
 65     auto element = HTMLUnknownElement::create(QualifiedName(nullAtom(), localName, HTMLNames::xhtmlNamespaceURI), document);
 66     element-&gt;setIsCustomElementUpgradeCandidate();
 67     element-&gt;setIsFailedCustomElement(*this);
 68 
 69     return element;
 70 }
 71 
 72 Ref&lt;Element&gt; JSCustomElementInterface::constructElementWithFallback(Document&amp; document, const QualifiedName&amp; name)
 73 {
 74     if (auto element = tryToConstructCustomElement(document, name.localName())) {
 75         if (!name.prefix().isNull())
 76             element-&gt;setPrefix(name.prefix());
 77         return element.releaseNonNull();
 78     }
</pre>
<hr />
<pre>
 82     element-&gt;setIsFailedCustomElement(*this);
 83 
 84     return element;
 85 }
 86 
 87 RefPtr&lt;Element&gt; JSCustomElementInterface::tryToConstructCustomElement(Document&amp; document, const AtomString&amp; localName)
 88 {
 89     if (!canInvokeCallback())
 90         return nullptr;
 91 
 92     Ref&lt;JSCustomElementInterface&gt; protectedThis(*this);
 93 
 94     VM&amp; vm = m_isolatedWorld-&gt;vm();
 95     JSLockHolder lock(vm);
 96     auto scope = DECLARE_CATCH_SCOPE(vm);
 97 
 98     if (!m_constructor)
 99         return nullptr;
100 
101     ASSERT(&amp;document == scriptExecutionContext());
<span class="line-modified">102     auto&amp; state = *document.execState();</span>
<span class="line-modified">103     auto element = constructCustomElementSynchronously(document, vm, state, m_constructor.get(), localName);</span>
104     EXCEPTION_ASSERT(!!scope.exception() == !element);
105     if (!element) {
106         auto* exception = scope.exception();
107         scope.clearException();
<span class="line-modified">108         reportException(&amp;state, exception);</span>
109         return nullptr;
110     }
111 
112     return element;
113 }
114 
115 // https://dom.spec.whatwg.org/#concept-create-element
116 // 6. 1. If the synchronous custom elements flag is set
<span class="line-modified">117 static RefPtr&lt;Element&gt; constructCustomElementSynchronously(Document&amp; document, VM&amp; vm, ExecState&amp; state, JSObject* constructor, const AtomString&amp; localName)</span>
118 {
119     auto scope = DECLARE_THROW_SCOPE(vm);
120     ConstructData constructData;
121     ConstructType constructType = constructor-&gt;methodTable(vm)-&gt;getConstructData(constructor, constructData);
122     if (constructType == ConstructType::None) {
123         ASSERT_NOT_REACHED();
124         return nullptr;
125     }
126 
<span class="line-modified">127     InspectorInstrumentationCookie cookie = JSExecState::instrumentFunctionConstruct(&amp;document, constructType, constructData);</span>
128     MarkedArgumentBuffer args;
129     ASSERT(!args.hasOverflowed());
<span class="line-modified">130     JSValue newElement = construct(&amp;state, constructor, constructType, constructData, args);</span>
<span class="line-modified">131     InspectorInstrumentation::didCallFunction(cookie, &amp;document);</span>
132     RETURN_IF_EXCEPTION(scope, nullptr);
133 
134     ASSERT(!newElement.isEmpty());
135     HTMLElement* wrappedElement = JSHTMLElement::toWrapped(vm, newElement);
136     if (!wrappedElement) {
<span class="line-modified">137         throwTypeError(&amp;state, scope, &quot;The result of constructing a custom element must be a HTMLElement&quot;_s);</span>
138         return nullptr;
139     }
140 
141     if (wrappedElement-&gt;hasAttributes()) {
<span class="line-modified">142         throwNotSupportedError(state, scope, &quot;A newly constructed custom element must not have attributes&quot;_s);</span>
143         return nullptr;
144     }
145     if (wrappedElement-&gt;hasChildNodes()) {
<span class="line-modified">146         throwNotSupportedError(state, scope, &quot;A newly constructed custom element must not have child nodes&quot;_s);</span>
147         return nullptr;
148     }
149     if (wrappedElement-&gt;parentNode()) {
<span class="line-modified">150         throwNotSupportedError(state, scope, &quot;A newly constructed custom element must not have a parent node&quot;_s);</span>
151         return nullptr;
152     }
153     if (&amp;wrappedElement-&gt;document() != &amp;document) {
<span class="line-modified">154         throwNotSupportedError(state, scope, &quot;A newly constructed custom element belongs to a wrong document&quot;_s);</span>
155         return nullptr;
156     }
157     ASSERT(wrappedElement-&gt;namespaceURI() == HTMLNames::xhtmlNamespaceURI);
158     if (wrappedElement-&gt;localName() != localName) {
<span class="line-modified">159         throwNotSupportedError(state, scope, &quot;A newly constructed custom element has incorrect local name&quot;_s);</span>
160         return nullptr;
161     }
162 
163     return wrappedElement;
164 }
165 
166 void JSCustomElementInterface::upgradeElement(Element&amp; element)
167 {
168     ASSERT(element.tagQName() == name());
169     ASSERT(element.isCustomElementUpgradeCandidate());
170     if (!canInvokeCallback())
171         return;
172 
173     Ref&lt;JSCustomElementInterface&gt; protectedThis(*this);
174     VM&amp; vm = m_isolatedWorld-&gt;vm();
175     JSLockHolder lock(vm);
176     auto scope = DECLARE_THROW_SCOPE(vm);
177 
178     if (!m_constructor)
179         return;
180 
181     auto* context = scriptExecutionContext();
182     if (!context)
183         return;
184     auto* globalObject = toJSDOMWindow(downcast&lt;Document&gt;(*context).frame(), m_isolatedWorld);
185     if (!globalObject)
186         return;
<span class="line-modified">187     ExecState* state = globalObject-&gt;globalExec();</span>
188 
189     ConstructData constructData;
190     ConstructType constructType = m_constructor-&gt;methodTable(vm)-&gt;getConstructData(m_constructor.get(), constructData);
191     if (constructType == ConstructType::None) {
192         ASSERT_NOT_REACHED();
193         return;
194     }
195 
196     CustomElementReactionQueue::enqueuePostUpgradeReactions(element);
197 
198     m_constructionStack.append(&amp;element);
199 
200     MarkedArgumentBuffer args;
201     ASSERT(!args.hasOverflowed());
<span class="line-modified">202     InspectorInstrumentationCookie cookie = JSExecState::instrumentFunctionConstruct(context, constructType, constructData);</span>
<span class="line-modified">203     JSValue returnedElement = construct(state, m_constructor.get(), constructType, constructData, args);</span>
<span class="line-modified">204     InspectorInstrumentation::didCallFunction(cookie, context);</span>
205 
206     m_constructionStack.removeLast();
207 
208     if (UNLIKELY(scope.exception())) {
209         element.setIsFailedCustomElement(*this);
<span class="line-modified">210         reportException(state, scope.exception());</span>
211         return;
212     }
213 
214     Element* wrappedElement = JSElement::toWrapped(vm, returnedElement);
215     if (!wrappedElement || wrappedElement != &amp;element) {
216         element.setIsFailedCustomElement(*this);
<span class="line-modified">217         reportException(state, createDOMException(state, TypeError, &quot;Custom element constructor returned a wrong element&quot;));</span>
218         return;
219     }
220     element.setIsDefinedCustomElement(*this);
221 }
222 
<span class="line-modified">223 void JSCustomElementInterface::invokeCallback(Element&amp; element, JSObject* callback, const WTF::Function&lt;void(ExecState*, JSDOMGlobalObject*, MarkedArgumentBuffer&amp;)&gt;&amp; addArguments)</span>
224 {
225     if (!canInvokeCallback())
226         return;
227 
228     auto* context = scriptExecutionContext();
229     if (!context)
230         return;
231 
232     Ref&lt;JSCustomElementInterface&gt; protectedThis(*this);
233     VM&amp; vm = m_isolatedWorld-&gt;vm();
234     JSLockHolder lock(vm);
235 
236     auto* globalObject = toJSDOMWindow(downcast&lt;Document&gt;(*context).frame(), m_isolatedWorld);
237     if (!globalObject)
238         return;
<span class="line-modified">239     ExecState* state = globalObject-&gt;globalExec();</span>
240 
<span class="line-modified">241     JSObject* jsElement = asObject(toJS(state, globalObject, element));</span>
242 
243     CallData callData;
244     CallType callType = callback-&gt;methodTable(vm)-&gt;getCallData(callback, callData);
245     ASSERT(callType != CallType::None);
246 
247     MarkedArgumentBuffer args;
<span class="line-modified">248     addArguments(state, globalObject, args);</span>
249     RELEASE_ASSERT(!args.hasOverflowed());
250 
<span class="line-modified">251     InspectorInstrumentationCookie cookie = JSExecState::instrumentFunctionCall(context, callType, callData);</span>
252 
253     NakedPtr&lt;JSC::Exception&gt; exception;
<span class="line-modified">254     JSExecState::call(state, callback, callType, callData, jsElement, args, exception);</span>
255 
<span class="line-modified">256     InspectorInstrumentation::didCallFunction(cookie, context);</span>
257 
258     if (exception)
<span class="line-modified">259         reportException(state, exception);</span>
260 }
261 
262 void JSCustomElementInterface::setConnectedCallback(JSC::JSObject* callback)
263 {
264     m_connectedCallback = callback;
265 }
266 
267 void JSCustomElementInterface::invokeConnectedCallback(Element&amp; element)
268 {
269     invokeCallback(element, m_connectedCallback.get());
270 }
271 
272 void JSCustomElementInterface::setDisconnectedCallback(JSC::JSObject* callback)
273 {
274     m_disconnectedCallback = callback;
275 }
276 
277 void JSCustomElementInterface::invokeDisconnectedCallback(Element&amp; element)
278 {
279     invokeCallback(element, m_disconnectedCallback.get());
280 }
281 
282 void JSCustomElementInterface::setAdoptedCallback(JSC::JSObject* callback)
283 {
284     m_adoptedCallback = callback;
285 }
286 
287 void JSCustomElementInterface::invokeAdoptedCallback(Element&amp; element, Document&amp; oldDocument, Document&amp; newDocument)
288 {
<span class="line-modified">289     invokeCallback(element, m_adoptedCallback.get(), [&amp;](ExecState* state, JSDOMGlobalObject* globalObject, MarkedArgumentBuffer&amp; args) {</span>
<span class="line-modified">290         args.append(toJS(state, globalObject, oldDocument));</span>
<span class="line-modified">291         args.append(toJS(state, globalObject, newDocument));</span>
292     });
293 }
294 
295 void JSCustomElementInterface::setAttributeChangedCallback(JSC::JSObject* callback, const Vector&lt;String&gt;&amp; observedAttributes)
296 {
297     m_attributeChangedCallback = callback;
298     m_observedAttributes.clear();
299     for (auto&amp; name : observedAttributes)
300         m_observedAttributes.add(name);
301 }
302 
303 void JSCustomElementInterface::invokeAttributeChangedCallback(Element&amp; element, const QualifiedName&amp; attributeName, const AtomString&amp; oldValue, const AtomString&amp; newValue)
304 {
<span class="line-modified">305     invokeCallback(element, m_attributeChangedCallback.get(), [&amp;](ExecState* state, JSDOMGlobalObject*, MarkedArgumentBuffer&amp; args) {</span>
<span class="line-modified">306         args.append(toJS&lt;IDLDOMString&gt;(*state, attributeName.localName()));</span>
<span class="line-modified">307         args.append(toJS&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(*state, oldValue));</span>
<span class="line-modified">308         args.append(toJS&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(*state, newValue));</span>
<span class="line-modified">309         args.append(toJS&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(*state, attributeName.namespaceURI()));</span>
310     });
311 }
312 
313 void JSCustomElementInterface::didUpgradeLastElementInConstructionStack()
314 {
315     m_constructionStack.last() = nullptr;
316 }
317 
318 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 38 #include &quot;JSExecState.h&quot;
 39 #include &quot;JSExecStateInstrumentation.h&quot;
 40 #include &quot;JSHTMLElement.h&quot;
 41 #include &quot;ScriptExecutionContext.h&quot;
 42 #include &lt;JavaScriptCore/JSLock.h&gt;
 43 #include &lt;JavaScriptCore/WeakInlines.h&gt;
 44 
 45 namespace WebCore {
 46 using namespace JSC;
 47 
 48 JSCustomElementInterface::JSCustomElementInterface(const QualifiedName&amp; name, JSObject* constructor, JSDOMGlobalObject* globalObject)
 49     : ActiveDOMCallback(globalObject-&gt;scriptExecutionContext())
 50     , m_name(name)
 51     , m_constructor(constructor)
 52     , m_isolatedWorld(globalObject-&gt;world())
 53 {
 54 }
 55 
 56 JSCustomElementInterface::~JSCustomElementInterface() = default;
 57 
<span class="line-modified"> 58 static RefPtr&lt;Element&gt; constructCustomElementSynchronously(Document&amp;, VM&amp;, JSGlobalObject&amp;, JSObject* constructor, const AtomString&amp; localName);</span>
 59 
 60 Ref&lt;Element&gt; JSCustomElementInterface::constructElementWithFallback(Document&amp; document, const AtomString&amp; localName)
 61 {
 62     if (auto element = tryToConstructCustomElement(document, localName))
 63         return element.releaseNonNull();
 64 
 65     auto element = HTMLUnknownElement::create(QualifiedName(nullAtom(), localName, HTMLNames::xhtmlNamespaceURI), document);
 66     element-&gt;setIsCustomElementUpgradeCandidate();
 67     element-&gt;setIsFailedCustomElement(*this);
 68 
 69     return element;
 70 }
 71 
 72 Ref&lt;Element&gt; JSCustomElementInterface::constructElementWithFallback(Document&amp; document, const QualifiedName&amp; name)
 73 {
 74     if (auto element = tryToConstructCustomElement(document, name.localName())) {
 75         if (!name.prefix().isNull())
 76             element-&gt;setPrefix(name.prefix());
 77         return element.releaseNonNull();
 78     }
</pre>
<hr />
<pre>
 82     element-&gt;setIsFailedCustomElement(*this);
 83 
 84     return element;
 85 }
 86 
 87 RefPtr&lt;Element&gt; JSCustomElementInterface::tryToConstructCustomElement(Document&amp; document, const AtomString&amp; localName)
 88 {
 89     if (!canInvokeCallback())
 90         return nullptr;
 91 
 92     Ref&lt;JSCustomElementInterface&gt; protectedThis(*this);
 93 
 94     VM&amp; vm = m_isolatedWorld-&gt;vm();
 95     JSLockHolder lock(vm);
 96     auto scope = DECLARE_CATCH_SCOPE(vm);
 97 
 98     if (!m_constructor)
 99         return nullptr;
100 
101     ASSERT(&amp;document == scriptExecutionContext());
<span class="line-modified">102     auto&amp; lexicalGlobalObject = *document.execState();</span>
<span class="line-modified">103     auto element = constructCustomElementSynchronously(document, vm, lexicalGlobalObject, m_constructor.get(), localName);</span>
104     EXCEPTION_ASSERT(!!scope.exception() == !element);
105     if (!element) {
106         auto* exception = scope.exception();
107         scope.clearException();
<span class="line-modified">108         reportException(&amp;lexicalGlobalObject, exception);</span>
109         return nullptr;
110     }
111 
112     return element;
113 }
114 
115 // https://dom.spec.whatwg.org/#concept-create-element
116 // 6. 1. If the synchronous custom elements flag is set
<span class="line-modified">117 static RefPtr&lt;Element&gt; constructCustomElementSynchronously(Document&amp; document, VM&amp; vm, JSGlobalObject&amp; lexicalGlobalObject, JSObject* constructor, const AtomString&amp; localName)</span>
118 {
119     auto scope = DECLARE_THROW_SCOPE(vm);
120     ConstructData constructData;
121     ConstructType constructType = constructor-&gt;methodTable(vm)-&gt;getConstructData(constructor, constructData);
122     if (constructType == ConstructType::None) {
123         ASSERT_NOT_REACHED();
124         return nullptr;
125     }
126 
<span class="line-modified">127     JSExecState::instrumentFunctionConstruct(&amp;document, constructType, constructData);</span>
128     MarkedArgumentBuffer args;
129     ASSERT(!args.hasOverflowed());
<span class="line-modified">130     JSValue newElement = construct(&amp;lexicalGlobalObject, constructor, constructType, constructData, args);</span>
<span class="line-modified">131     InspectorInstrumentation::didCallFunction(&amp;document);</span>
132     RETURN_IF_EXCEPTION(scope, nullptr);
133 
134     ASSERT(!newElement.isEmpty());
135     HTMLElement* wrappedElement = JSHTMLElement::toWrapped(vm, newElement);
136     if (!wrappedElement) {
<span class="line-modified">137         throwTypeError(&amp;lexicalGlobalObject, scope, &quot;The result of constructing a custom element must be a HTMLElement&quot;_s);</span>
138         return nullptr;
139     }
140 
141     if (wrappedElement-&gt;hasAttributes()) {
<span class="line-modified">142         throwNotSupportedError(lexicalGlobalObject, scope, &quot;A newly constructed custom element must not have attributes&quot;_s);</span>
143         return nullptr;
144     }
145     if (wrappedElement-&gt;hasChildNodes()) {
<span class="line-modified">146         throwNotSupportedError(lexicalGlobalObject, scope, &quot;A newly constructed custom element must not have child nodes&quot;_s);</span>
147         return nullptr;
148     }
149     if (wrappedElement-&gt;parentNode()) {
<span class="line-modified">150         throwNotSupportedError(lexicalGlobalObject, scope, &quot;A newly constructed custom element must not have a parent node&quot;_s);</span>
151         return nullptr;
152     }
153     if (&amp;wrappedElement-&gt;document() != &amp;document) {
<span class="line-modified">154         throwNotSupportedError(lexicalGlobalObject, scope, &quot;A newly constructed custom element belongs to a wrong document&quot;_s);</span>
155         return nullptr;
156     }
157     ASSERT(wrappedElement-&gt;namespaceURI() == HTMLNames::xhtmlNamespaceURI);
158     if (wrappedElement-&gt;localName() != localName) {
<span class="line-modified">159         throwNotSupportedError(lexicalGlobalObject, scope, &quot;A newly constructed custom element has incorrect local name&quot;_s);</span>
160         return nullptr;
161     }
162 
163     return wrappedElement;
164 }
165 
166 void JSCustomElementInterface::upgradeElement(Element&amp; element)
167 {
168     ASSERT(element.tagQName() == name());
169     ASSERT(element.isCustomElementUpgradeCandidate());
170     if (!canInvokeCallback())
171         return;
172 
173     Ref&lt;JSCustomElementInterface&gt; protectedThis(*this);
174     VM&amp; vm = m_isolatedWorld-&gt;vm();
175     JSLockHolder lock(vm);
176     auto scope = DECLARE_THROW_SCOPE(vm);
177 
178     if (!m_constructor)
179         return;
180 
181     auto* context = scriptExecutionContext();
182     if (!context)
183         return;
184     auto* globalObject = toJSDOMWindow(downcast&lt;Document&gt;(*context).frame(), m_isolatedWorld);
185     if (!globalObject)
186         return;
<span class="line-modified">187     JSGlobalObject* lexicalGlobalObject = globalObject;</span>
188 
189     ConstructData constructData;
190     ConstructType constructType = m_constructor-&gt;methodTable(vm)-&gt;getConstructData(m_constructor.get(), constructData);
191     if (constructType == ConstructType::None) {
192         ASSERT_NOT_REACHED();
193         return;
194     }
195 
196     CustomElementReactionQueue::enqueuePostUpgradeReactions(element);
197 
198     m_constructionStack.append(&amp;element);
199 
200     MarkedArgumentBuffer args;
201     ASSERT(!args.hasOverflowed());
<span class="line-modified">202     JSExecState::instrumentFunctionConstruct(context, constructType, constructData);</span>
<span class="line-modified">203     JSValue returnedElement = construct(lexicalGlobalObject, m_constructor.get(), constructType, constructData, args);</span>
<span class="line-modified">204     InspectorInstrumentation::didCallFunction(context);</span>
205 
206     m_constructionStack.removeLast();
207 
208     if (UNLIKELY(scope.exception())) {
209         element.setIsFailedCustomElement(*this);
<span class="line-modified">210         reportException(lexicalGlobalObject, scope.exception());</span>
211         return;
212     }
213 
214     Element* wrappedElement = JSElement::toWrapped(vm, returnedElement);
215     if (!wrappedElement || wrappedElement != &amp;element) {
216         element.setIsFailedCustomElement(*this);
<span class="line-modified">217         reportException(lexicalGlobalObject, createDOMException(lexicalGlobalObject, TypeError, &quot;Custom element constructor returned a wrong element&quot;));</span>
218         return;
219     }
220     element.setIsDefinedCustomElement(*this);
221 }
222 
<span class="line-modified">223 void JSCustomElementInterface::invokeCallback(Element&amp; element, JSObject* callback, const WTF::Function&lt;void(JSGlobalObject*, JSDOMGlobalObject*, MarkedArgumentBuffer&amp;)&gt;&amp; addArguments)</span>
224 {
225     if (!canInvokeCallback())
226         return;
227 
228     auto* context = scriptExecutionContext();
229     if (!context)
230         return;
231 
232     Ref&lt;JSCustomElementInterface&gt; protectedThis(*this);
233     VM&amp; vm = m_isolatedWorld-&gt;vm();
234     JSLockHolder lock(vm);
235 
236     auto* globalObject = toJSDOMWindow(downcast&lt;Document&gt;(*context).frame(), m_isolatedWorld);
237     if (!globalObject)
238         return;
<span class="line-modified">239     JSGlobalObject* lexicalGlobalObject = globalObject;</span>
240 
<span class="line-modified">241     JSObject* jsElement = asObject(toJS(lexicalGlobalObject, globalObject, element));</span>
242 
243     CallData callData;
244     CallType callType = callback-&gt;methodTable(vm)-&gt;getCallData(callback, callData);
245     ASSERT(callType != CallType::None);
246 
247     MarkedArgumentBuffer args;
<span class="line-modified">248     addArguments(lexicalGlobalObject, globalObject, args);</span>
249     RELEASE_ASSERT(!args.hasOverflowed());
250 
<span class="line-modified">251     JSExecState::instrumentFunctionCall(context, callType, callData);</span>
252 
253     NakedPtr&lt;JSC::Exception&gt; exception;
<span class="line-modified">254     JSExecState::call(lexicalGlobalObject, callback, callType, callData, jsElement, args, exception);</span>
255 
<span class="line-modified">256     InspectorInstrumentation::didCallFunction(context);</span>
257 
258     if (exception)
<span class="line-modified">259         reportException(lexicalGlobalObject, exception);</span>
260 }
261 
262 void JSCustomElementInterface::setConnectedCallback(JSC::JSObject* callback)
263 {
264     m_connectedCallback = callback;
265 }
266 
267 void JSCustomElementInterface::invokeConnectedCallback(Element&amp; element)
268 {
269     invokeCallback(element, m_connectedCallback.get());
270 }
271 
272 void JSCustomElementInterface::setDisconnectedCallback(JSC::JSObject* callback)
273 {
274     m_disconnectedCallback = callback;
275 }
276 
277 void JSCustomElementInterface::invokeDisconnectedCallback(Element&amp; element)
278 {
279     invokeCallback(element, m_disconnectedCallback.get());
280 }
281 
282 void JSCustomElementInterface::setAdoptedCallback(JSC::JSObject* callback)
283 {
284     m_adoptedCallback = callback;
285 }
286 
287 void JSCustomElementInterface::invokeAdoptedCallback(Element&amp; element, Document&amp; oldDocument, Document&amp; newDocument)
288 {
<span class="line-modified">289     invokeCallback(element, m_adoptedCallback.get(), [&amp;](JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, MarkedArgumentBuffer&amp; args) {</span>
<span class="line-modified">290         args.append(toJS(lexicalGlobalObject, globalObject, oldDocument));</span>
<span class="line-modified">291         args.append(toJS(lexicalGlobalObject, globalObject, newDocument));</span>
292     });
293 }
294 
295 void JSCustomElementInterface::setAttributeChangedCallback(JSC::JSObject* callback, const Vector&lt;String&gt;&amp; observedAttributes)
296 {
297     m_attributeChangedCallback = callback;
298     m_observedAttributes.clear();
299     for (auto&amp; name : observedAttributes)
300         m_observedAttributes.add(name);
301 }
302 
303 void JSCustomElementInterface::invokeAttributeChangedCallback(Element&amp; element, const QualifiedName&amp; attributeName, const AtomString&amp; oldValue, const AtomString&amp; newValue)
304 {
<span class="line-modified">305     invokeCallback(element, m_attributeChangedCallback.get(), [&amp;](JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject*, MarkedArgumentBuffer&amp; args) {</span>
<span class="line-modified">306         args.append(toJS&lt;IDLDOMString&gt;(*lexicalGlobalObject, attributeName.localName()));</span>
<span class="line-modified">307         args.append(toJS&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(*lexicalGlobalObject, oldValue));</span>
<span class="line-modified">308         args.append(toJS&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(*lexicalGlobalObject, newValue));</span>
<span class="line-modified">309         args.append(toJS&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(*lexicalGlobalObject, attributeName.namespaceURI()));</span>
310     });
311 }
312 
313 void JSCustomElementInterface::didUpgradeLastElementInConstructionStack()
314 {
315     m_constructionStack.last() = nullptr;
316 }
317 
318 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="JSCanvasRenderingContext2DCustom.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSCustomElementInterface.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
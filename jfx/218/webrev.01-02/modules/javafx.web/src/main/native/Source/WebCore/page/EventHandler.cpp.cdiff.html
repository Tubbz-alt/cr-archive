<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/page/EventHandler.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="EditorClient.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EventHandler.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/EventHandler.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.</span>
   * Copyright (C) 2006 Alexey Proskuryakov (ap@webkit.org)
   * Copyright (C) 2012 Digia Plc. and/or its subsidiary(-ies)
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2006-2020 Apple Inc. All rights reserved.</span>
   * Copyright (C) 2006 Alexey Proskuryakov (ap@webkit.org)
   * Copyright (C) 2012 Digia Plc. and/or its subsidiary(-ies)
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
</pre>
<hr />
<pre>
<span class="line-old-header">*** 32,13 ***</span>
<span class="line-new-header">--- 32,15 ---</span>
  #include &quot;BackForwardController.h&quot;
  #include &quot;CachedImage.h&quot;
  #include &quot;Chrome.h&quot;
  #include &quot;ChromeClient.h&quot;
  #include &quot;ComposedTreeAncestorIterator.h&quot;
<span class="line-added">+ #include &quot;ComposedTreeIterator.h&quot;</span>
  #include &quot;CursorList.h&quot;
  #include &quot;DocumentMarkerController.h&quot;
  #include &quot;DragController.h&quot;
<span class="line-added">+ #include &quot;DragEvent.h&quot;</span>
  #include &quot;DragState.h&quot;
  #include &quot;Editing.h&quot;
  #include &quot;Editor.h&quot;
  #include &quot;EditorClient.h&quot;
  #include &quot;EventNames.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 125,14 ***</span>
  
  #if ENABLE(POINTER_LOCK)
  #include &quot;PointerLockController.h&quot;
  #endif
  
<span class="line-removed">- #if ENABLE(POINTER_EVENTS)</span>
<span class="line-removed">- #include &quot;RuntimeEnabledFeatures.h&quot;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  #if PLATFORM(IOS_FAMILY)
  #include &quot;DOMTimerHoldingTank.h&quot;
  #endif
  
  namespace WebCore {
<span class="line-new-header">--- 127,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 177,17 ***</span>
  const double fakeMouseMoveDurationThreshold = 0.01;
  const Seconds fakeMouseMoveShortInterval = { 100_ms };
  const Seconds fakeMouseMoveLongInterval = { 250_ms };
  #endif
  
<span class="line-removed">- #if ENABLE(CURSOR_SUPPORT)</span>
  // The amount of time to wait for a cursor update on style and layout changes
  // Set to 50Hz, no need to be faster than common screen refresh rate
  static const Seconds cursorUpdateInterval { 20_ms };
  
  const int maximumCursorSize = 128;
<span class="line-removed">- #endif</span>
  
  #if ENABLE(MOUSE_CURSOR_SCALE)
  // It&#39;s pretty unlikely that a scale of less than one would ever be used. But all we really
  // need to ensure here is that the scale isn&#39;t so small that integer overflow can occur when
  // dividing cursor sizes (limited above) by the scale.
<span class="line-new-header">--- 175,15 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 217,15 ***</span>
  public:
  
      // The default values are based on http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html
      explicit SyntheticTouchPoint(const PlatformMouseEvent&amp; event)
      {
<span class="line-modified">!         const static int idDefaultValue = 0;</span>
<span class="line-modified">!         const static int radiusYDefaultValue = 1;</span>
<span class="line-modified">!         const static int radiusXDefaultValue = 1;</span>
<span class="line-modified">!         const static float rotationAngleDefaultValue = 0.0f;</span>
<span class="line-modified">!         const static float forceDefaultValue = 1.0f;</span>
  
          m_id = idDefaultValue; // There is only one active TouchPoint.
          m_screenPos = event.globalPosition();
          m_pos = event.position();
          m_radiusY = radiusYDefaultValue;
<span class="line-new-header">--- 213,15 ---</span>
  public:
  
      // The default values are based on http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html
      explicit SyntheticTouchPoint(const PlatformMouseEvent&amp; event)
      {
<span class="line-modified">!         static constexpr int idDefaultValue = 0;</span>
<span class="line-modified">!         static constexpr int radiusYDefaultValue = 1;</span>
<span class="line-modified">!         static constexpr int radiusXDefaultValue = 1;</span>
<span class="line-modified">!         static constexpr float rotationAngleDefaultValue = 0.0f;</span>
<span class="line-modified">!         static constexpr float forceDefaultValue = 1.0f;</span>
  
          m_id = idDefaultValue; // There is only one active TouchPoint.
          m_screenPos = event.globalPosition();
          m_pos = event.position();
          m_radiusY = radiusYDefaultValue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 304,11 ***</span>
          didHandleWheelEvent |= scrollableArea-&gt;scroll(wheelEvent.deltaY() &gt; 0 ? ScrollDown : ScrollUp, scrollGranularity, absoluteDelta);
  
      return didHandleWheelEvent;
  }
  
<span class="line-modified">! static inline bool handleWheelEventInAppropriateEnclosingBox(Node* startNode, WheelEvent&amp; wheelEvent, Element** stopElement, const FloatSize&amp; filteredPlatformDelta, const FloatSize&amp; filteredVelocity)</span>
  {
      bool shouldHandleEvent = wheelEvent.deltaX() || wheelEvent.deltaY();
  #if PLATFORM(MAC)
      shouldHandleEvent |= wheelEvent.phase() == PlatformWheelEventPhaseEnded;
  #if ENABLE(CSS_SCROLL_SNAP)
<span class="line-new-header">--- 300,11 ---</span>
          didHandleWheelEvent |= scrollableArea-&gt;scroll(wheelEvent.deltaY() &gt; 0 ? ScrollDown : ScrollUp, scrollGranularity, absoluteDelta);
  
      return didHandleWheelEvent;
  }
  
<span class="line-modified">! static inline bool handleWheelEventInAppropriateEnclosingBox(Node* startNode, WheelEvent&amp; wheelEvent, RefPtr&lt;Element&gt;&amp; stopElement, const FloatSize&amp; filteredPlatformDelta, const FloatSize&amp; filteredVelocity)</span>
  {
      bool shouldHandleEvent = wheelEvent.deltaX() || wheelEvent.deltaY();
  #if PLATFORM(MAC)
      shouldHandleEvent |= wheelEvent.phase() == PlatformWheelEventPhaseEnded;
  #if ENABLE(CSS_SCROLL_SNAP)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 332,17 ***</span>
                  scrollingWasHandled = boxLayer-&gt;handleWheelEvent(copiedEvent);
              } else
                  scrollingWasHandled = didScrollInScrollableArea(boxLayer, wheelEvent);
  
              if (scrollingWasHandled) {
<span class="line-modified">!                 if (stopElement)</span>
<span class="line-removed">-                     *stopElement = currentEnclosingBox-&gt;element();</span>
                  return true;
              }
          }
  
<span class="line-modified">!         if (stopElement &amp;&amp; *stopElement &amp;&amp; *stopElement == currentEnclosingBox-&gt;element())</span>
              return true;
  
          currentEnclosingBox = currentEnclosingBox-&gt;containingBlock();
          if (!currentEnclosingBox || currentEnclosingBox-&gt;isRenderView())
              return false;
<span class="line-new-header">--- 328,16 ---</span>
                  scrollingWasHandled = boxLayer-&gt;handleWheelEvent(copiedEvent);
              } else
                  scrollingWasHandled = didScrollInScrollableArea(boxLayer, wheelEvent);
  
              if (scrollingWasHandled) {
<span class="line-modified">!                 stopElement = currentEnclosingBox-&gt;element();</span>
                  return true;
              }
          }
  
<span class="line-modified">!         if (stopElement.get() &amp;&amp; stopElement.get() == currentEnclosingBox-&gt;element())</span>
              return true;
  
          currentEnclosingBox = currentEnclosingBox-&gt;containingBlock();
          if (!currentEnclosingBox || currentEnclosingBox-&gt;isRenderView())
              return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 377,13 ***</span>
  #endif
  
  EventHandler::EventHandler(Frame&amp; frame)
      : m_frame(frame)
      , m_hoverTimer(*this, &amp;EventHandler::hoverTimerFired)
<span class="line-removed">- #if ENABLE(CURSOR_SUPPORT)</span>
      , m_cursorUpdateTimer(*this, &amp;EventHandler::cursorUpdateTimerFired)
<span class="line-removed">- #endif</span>
  #if PLATFORM(MAC)
      , m_pendingMomentumWheelEventsTimer(*this, &amp;EventHandler::clearLatchedState)
  #endif
      , m_autoscrollController(makeUnique&lt;AutoscrollController&gt;())
  #if !ENABLE(IOS_TOUCH_EVENTS)
<span class="line-new-header">--- 372,11 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 416,13 ***</span>
  #endif
  
  void EventHandler::clear()
  {
      m_hoverTimer.stop();
<span class="line-removed">- #if ENABLE(CURSOR_SUPPORT)</span>
      m_cursorUpdateTimer.stop();
<span class="line-removed">- #endif</span>
  #if !ENABLE(IOS_TOUCH_EVENTS)
      m_fakeMouseMoveEventTimer.stop();
  #endif
  #if ENABLE(CURSOR_VISIBILITY)
      cancelAutoHideCursorTimer();
<span class="line-new-header">--- 409,11 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 738,12 ***</span>
          handled = handlePasteGlobalSelection(event.event()) || handled;
      }
      return handled;
  }
  
<span class="line-modified">! static inline bool canMouseDownStartSelect(Node* node)</span>
  {
      if (!node || !node-&gt;renderer())
          return true;
  
      return node-&gt;canStartSelection() || Position::nodeIsUserSelectAll(node);
  }
<span class="line-new-header">--- 729,19 ---</span>
          handled = handlePasteGlobalSelection(event.event()) || handled;
      }
      return handled;
  }
  
<span class="line-modified">! bool EventHandler::canMouseDownStartSelect(const MouseEventWithHitTestResults&amp; event)</span>
  {
<span class="line-added">+     auto* node = event.targetNode();</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (Page* page = m_frame.page()) {</span>
<span class="line-added">+         if (!page-&gt;chrome().client().shouldUseMouseEventForSelection(event.event()))</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      if (!node || !node-&gt;renderer())
          return true;
  
      return node-&gt;canStartSelection() || Position::nodeIsUserSelectAll(node);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 770,11 ***</span>
  
      bool singleClick = event.event().clickCount() &lt;= 1;
  
      // If we got the event back, that must mean it wasn&#39;t prevented,
      // so it&#39;s allowed to start a drag or selection if it wasn&#39;t in a scrollbar.
<span class="line-modified">!     m_mouseDownMayStartSelect = canMouseDownStartSelect(event.targetNode()) &amp;&amp; !event.scrollbar();</span>
  
  #if ENABLE(DRAG_SUPPORT)
      // Careful that the drag starting logic stays in sync with eventMayStartDrag()
      // FIXME: eventMayStartDrag() does not check for shift key press, link or image event targets.
      // Bug: https://bugs.webkit.org/show_bug.cgi?id=155390
<span class="line-new-header">--- 768,11 ---</span>
  
      bool singleClick = event.event().clickCount() &lt;= 1;
  
      // If we got the event back, that must mean it wasn&#39;t prevented,
      // so it&#39;s allowed to start a drag or selection if it wasn&#39;t in a scrollbar.
<span class="line-modified">!     m_mouseDownMayStartSelect = canMouseDownStartSelect(event) &amp;&amp; !event.scrollbar();</span>
  
  #if ENABLE(DRAG_SUPPORT)
      // Careful that the drag starting logic stays in sync with eventMayStartDrag()
      // FIXME: eventMayStartDrag() does not check for shift key press, link or image event targets.
      // Bug: https://bugs.webkit.org/show_bug.cgi?id=155390
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1341,11 ***</span>
          return nullptr;
  
      return &amp;downcast&lt;FrameView&gt;(*widget).frame();
  }
  
<span class="line-removed">- #if ENABLE(CURSOR_SUPPORT)</span>
  static bool isSubmitImage(Node* node)
  {
      return is&lt;HTMLInputElement&gt;(node) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*node).isImageButton();
  }
  
<span class="line-new-header">--- 1339,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1398,10 ***</span>
<span class="line-new-header">--- 1395,15 ---</span>
  void EventHandler::updateCursor()
  {
      if (m_mousePositionIsUnknown)
          return;
  
<span class="line-added">+     if (Page* page = m_frame.page()) {</span>
<span class="line-added">+         if (!page-&gt;chrome().client().supportsSettingCursor())</span>
<span class="line-added">+             return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      FrameView* view = m_frame.view();
      if (!view)
          return;
  
      auto* document = m_frame.document();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1618,11 ***</span>
      case CursorType::ZoomOut:
          return zoomOutCursor();
      }
      return pointerCursor();
  }
<span class="line-removed">- #endif // ENABLE(CURSOR_SUPPORT)</span>
  
  #if ENABLE(CURSOR_VISIBILITY)
  void EventHandler::startAutoHideCursorTimer()
  {
      Page* page = m_frame.page();
<span class="line-new-header">--- 1620,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1912,11 ***</span>
      if (FrameView* frameView = m_frame.view())
          frameView-&gt;mouseMovedInContentArea();
  
      hoveredNode.setToNonUserAgentShadowAncestor();
      page-&gt;chrome().mouseDidMoveOverElement(hoveredNode, event.modifierFlags());
<span class="line-removed">-     page-&gt;chrome().setToolTip(hoveredNode);</span>
      return result;
  }
  
  bool EventHandler::passMouseMovedEventToScrollbars(const PlatformMouseEvent&amp; event)
  {
<span class="line-new-header">--- 1913,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1945,13 ***</span>
      setLastKnownMousePosition(platformMouseEvent);
  
      if (m_hoverTimer.isActive())
          m_hoverTimer.stop();
  
<span class="line-removed">- #if ENABLE(CURSOR_SUPPORT)</span>
      m_cursorUpdateTimer.stop();
<span class="line-removed">- #endif</span>
  
  #if !ENABLE(IOS_TOUCH_EVENTS)
      cancelFakeMouseMoveEvent();
  #endif
  
<span class="line-new-header">--- 1945,11 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2026,14 ***</span>
          if (newSubframe-&gt;view())
              swallowEvent |= passMouseMoveEventToSubframe(mouseEvent, newSubframe.get(), hoveredNode);
      }
  
      if (!newSubframe || mouseEvent.scrollbar()) {
<span class="line-removed">- #if ENABLE(CURSOR_SUPPORT)</span>
          if (auto* view = m_frame.view())
              updateCursor(*view, mouseEvent.hitTestResult(), platformMouseEvent.shiftKey());
<span class="line-removed">- #endif</span>
      }
  
      m_lastMouseMoveEventSubframe = newSubframe;
  
      if (swallowEvent)
<span class="line-new-header">--- 2024,12 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2260,23 ***</span>
      // FIXME: We might want to dispatch a dragleave even if the view is gone.
      if (!view)
          return false;
  
      view-&gt;disableLayerFlushThrottlingTemporarilyForInteraction();
<span class="line-modified">!     // FIXME: Use MouseEvent::create which takes PlatformMouseEvent.</span>
<span class="line-modified">!     Ref&lt;MouseEvent&gt; me = MouseEvent::create(eventType, Event::CanBubble::Yes, Event::IsCancelable::Yes, Event::IsComposed::Yes,</span>
          event.timestamp().approximateMonotonicTime(), &amp;m_frame.windowProxy(), 0,
          event.globalPosition(), event.position(),
  #if ENABLE(POINTER_LOCK)
          event.movementDelta(),
  #else
          { },
  #endif
          event.modifiers(), 0, 0, nullptr, event.force(), NoTap, &amp;dataTransfer);
  
<span class="line-modified">!     dragTarget.dispatchEvent(me);</span>
<span class="line-modified">!     return me-&gt;defaultPrevented();</span>
  }
  
  static bool targetIsFrame(Node* target, Frame*&amp; frame)
  {
      if (!is&lt;HTMLFrameElementBase&gt;(target))
<span class="line-new-header">--- 2256,23 ---</span>
      // FIXME: We might want to dispatch a dragleave even if the view is gone.
      if (!view)
          return false;
  
      view-&gt;disableLayerFlushThrottlingTemporarilyForInteraction();
<span class="line-modified">! </span>
<span class="line-modified">!     auto dragEvent = DragEvent::create(eventType, Event::CanBubble::Yes, Event::IsCancelable::Yes, Event::IsComposed::Yes,</span>
          event.timestamp().approximateMonotonicTime(), &amp;m_frame.windowProxy(), 0,
          event.globalPosition(), event.position(),
  #if ENABLE(POINTER_LOCK)
          event.movementDelta(),
  #else
          { },
  #endif
          event.modifiers(), 0, 0, nullptr, event.force(), NoTap, &amp;dataTransfer);
  
<span class="line-modified">!     dragTarget.dispatchEvent(dragEvent);</span>
<span class="line-modified">!     return dragEvent-&gt;defaultPrevented();</span>
  }
  
  static bool targetIsFrame(Node* target, Frame*&amp; frame)
  {
      if (!is&lt;HTMLFrameElementBase&gt;(target))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2391,12 ***</span>
          if (targetIsFrame(newTarget.get(), targetFrame)) {
              if (targetFrame)
                  response = targetFrame-&gt;eventHandler().updateDragAndDrop(event, makePasteboard, sourceOperation, draggingFiles);
          } else if (newTarget) {
              // As per section 7.9.4 of the HTML 5 spec., we must always fire a drag event before firing a dragenter, dragleave, or dragover event.
<span class="line-modified">!             if (dragState().source &amp;&amp; dragState().shouldDispatchEvents)</span>
<span class="line-removed">-                 dispatchDragSrcEvent(eventNames().dragEvent, event);</span>
              response = dispatchDragEnterOrDragOverEvent(eventNames().dragenterEvent, *newTarget, event, makePasteboard(), sourceOperation, draggingFiles);
          }
  
          if (targetIsFrame(m_dragTarget.get(), targetFrame)) {
              // FIXME: Recursing again here doesn&#39;t make sense if the newTarget and m_dragTarget were in the same frame.
<span class="line-new-header">--- 2387,11 ---</span>
          if (targetIsFrame(newTarget.get(), targetFrame)) {
              if (targetFrame)
                  response = targetFrame-&gt;eventHandler().updateDragAndDrop(event, makePasteboard, sourceOperation, draggingFiles);
          } else if (newTarget) {
              // As per section 7.9.4 of the HTML 5 spec., we must always fire a drag event before firing a dragenter, dragleave, or dragover event.
<span class="line-modified">!             dispatchEventToDragSourceElement(eventNames().dragEvent, event);</span>
              response = dispatchDragEnterOrDragOverEvent(eventNames().dragenterEvent, *newTarget, event, makePasteboard(), sourceOperation, draggingFiles);
          }
  
          if (targetIsFrame(m_dragTarget.get(), targetFrame)) {
              // FIXME: Recursing again here doesn&#39;t make sense if the newTarget and m_dragTarget were in the same frame.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2418,12 ***</span>
          if (targetIsFrame(newTarget.get(), targetFrame)) {
              if (targetFrame)
                  response = targetFrame-&gt;eventHandler().updateDragAndDrop(event, makePasteboard, sourceOperation, draggingFiles);
          } else if (newTarget) {
              // Note, when dealing with sub-frames, we may need to fire only a dragover event as a drag event may have been fired earlier.
<span class="line-modified">!             if (!m_shouldOnlyFireDragOverEvent &amp;&amp; dragState().source &amp;&amp; dragState().shouldDispatchEvents)</span>
<span class="line-modified">!                 dispatchDragSrcEvent(eventNames().dragEvent, event);</span>
              response = dispatchDragEnterOrDragOverEvent(eventNames().dragoverEvent, *newTarget, event, makePasteboard(), sourceOperation, draggingFiles);
              m_shouldOnlyFireDragOverEvent = false;
          }
      }
      m_dragTarget = WTFMove(newTarget);
<span class="line-new-header">--- 2413,12 ---</span>
          if (targetIsFrame(newTarget.get(), targetFrame)) {
              if (targetFrame)
                  response = targetFrame-&gt;eventHandler().updateDragAndDrop(event, makePasteboard, sourceOperation, draggingFiles);
          } else if (newTarget) {
              // Note, when dealing with sub-frames, we may need to fire only a dragover event as a drag event may have been fired earlier.
<span class="line-modified">!             if (!m_shouldOnlyFireDragOverEvent)</span>
<span class="line-modified">!                 dispatchEventToDragSourceElement(eventNames().dragEvent, event);</span>
              response = dispatchDragEnterOrDragOverEvent(eventNames().dragoverEvent, *newTarget, event, makePasteboard(), sourceOperation, draggingFiles);
              m_shouldOnlyFireDragOverEvent = false;
          }
      }
      m_dragTarget = WTFMove(newTarget);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2437,12 ***</span>
      Frame* targetFrame;
      if (targetIsFrame(m_dragTarget.get(), targetFrame)) {
          if (targetFrame)
              targetFrame-&gt;eventHandler().cancelDragAndDrop(event, WTFMove(pasteboard), sourceOperation, draggingFiles);
      } else if (m_dragTarget) {
<span class="line-modified">!         if (dragState().source &amp;&amp; dragState().shouldDispatchEvents)</span>
<span class="line-removed">-             dispatchDragSrcEvent(eventNames().dragEvent, event);</span>
  
          auto dataTransfer = DataTransfer::createForUpdatingDropTarget(m_dragTarget-&gt;document(), WTFMove(pasteboard), sourceOperation, draggingFiles);
          dispatchDragEvent(eventNames().dragleaveEvent, *m_dragTarget, event, dataTransfer.get());
          dataTransfer-&gt;makeInvalidForSecurity();
      }
<span class="line-new-header">--- 2432,11 ---</span>
      Frame* targetFrame;
      if (targetIsFrame(m_dragTarget.get(), targetFrame)) {
          if (targetFrame)
              targetFrame-&gt;eventHandler().cancelDragAndDrop(event, WTFMove(pasteboard), sourceOperation, draggingFiles);
      } else if (m_dragTarget) {
<span class="line-modified">!         dispatchEventToDragSourceElement(eventNames().dragEvent, event);</span>
  
          auto dataTransfer = DataTransfer::createForUpdatingDropTarget(m_dragTarget-&gt;document(), WTFMove(pasteboard), sourceOperation, draggingFiles);
          dispatchDragEvent(eventNames().dragleaveEvent, *m_dragTarget, event, dataTransfer.get());
          dataTransfer-&gt;makeInvalidForSecurity();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2621,10 ***</span>
<span class="line-new-header">--- 2615,23 ---</span>
          }
          m_lastElementUnderMouse = m_elementUnderMouse;
      }
  }
  
<span class="line-added">+ static RefPtr&lt;Element&gt; findFirstMouseFocusableElementInComposedTree(Element&amp; host)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(host.shadowRoot());</span>
<span class="line-added">+     for (auto&amp; node : composedTreeDescendants(host)) {</span>
<span class="line-added">+         if (!is&lt;Element&gt;(node))</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         auto&amp; element = downcast&lt;Element&gt;(node);</span>
<span class="line-added">+         if (element.isMouseFocusable())</span>
<span class="line-added">+             return &amp;element;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return nullptr;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool EventHandler::dispatchMouseEvent(const AtomString&amp; eventType, Node* targetNode, bool /*cancelable*/, int clickCount, const PlatformMouseEvent&amp; platformMouseEvent, bool setUnder)
  {
      Ref&lt;Frame&gt; protectedFrame(m_frame);
  
      if (auto* view = m_frame.view())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2652,10 ***</span>
<span class="line-new-header">--- 2659,16 ---</span>
      // from the user interface of Windows, where pushing a button moves focus to the button.
  
      // Walk up the DOM tree to search for an element to focus.
      RefPtr&lt;Element&gt; element;
      for (element = m_elementUnderMouse.get(); element; element = element-&gt;parentElementInComposedTree()) {
<span class="line-added">+         if (auto* shadowRoot = element-&gt;shadowRoot()) {</span>
<span class="line-added">+             if (shadowRoot-&gt;delegatesFocus()) {</span>
<span class="line-added">+                 element = findFirstMouseFocusableElementInComposedTree(*element);</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
          if (element-&gt;isMouseFocusable())
              break;
      }
  
      // To fix &lt;rdar://problem/4895428&gt; Can&#39;t drag selected ToDo, we don&#39;t focus an
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2900,30 ***</span>
          filteredPlatformDelta.setHeight(platformWheelEvent-&gt;deltaY());
      }
  
  #if PLATFORM(MAC)
      ScrollLatchingState* latchedState = m_frame.page() ? m_frame.page()-&gt;latchingState() : nullptr;
<span class="line-modified">!     Element* stopElement = latchedState ? latchedState-&gt;previousWheelScrolledElement() : nullptr;</span>
  
      if (m_frame.page() &amp;&amp; m_frame.page()-&gt;wheelEventDeltaFilter()-&gt;isFilteringDeltas()) {
          filteredPlatformDelta = m_frame.page()-&gt;wheelEventDeltaFilter()-&gt;filteredDelta();
          filteredVelocity = m_frame.page()-&gt;wheelEventDeltaFilter()-&gt;filteredVelocity();
      }
  #else
<span class="line-modified">!     Element* stopElement = nullptr;</span>
  #endif
  
<span class="line-modified">!     if (handleWheelEventInAppropriateEnclosingBox(startNode, wheelEvent, &amp;stopElement, filteredPlatformDelta, filteredVelocity))</span>
          wheelEvent.setDefaultHandled();
  
  #if PLATFORM(MAC)
      if (latchedState &amp;&amp; !latchedState-&gt;wheelEventElement())
<span class="line-modified">!         latchedState-&gt;setPreviousWheelScrolledElement(stopElement);</span>
  #endif
  }
  
<span class="line-modified">! #if ENABLE(CONTEXT_MENUS)</span>
  bool EventHandler::sendContextMenuEvent(const PlatformMouseEvent&amp; event)
  {
      Ref&lt;Frame&gt; protectedFrame(m_frame);
  
      Document* doc = m_frame.document();
<span class="line-new-header">--- 2913,30 ---</span>
          filteredPlatformDelta.setHeight(platformWheelEvent-&gt;deltaY());
      }
  
  #if PLATFORM(MAC)
      ScrollLatchingState* latchedState = m_frame.page() ? m_frame.page()-&gt;latchingState() : nullptr;
<span class="line-modified">!     RefPtr&lt;Element&gt; stopElement = latchedState ? latchedState-&gt;previousWheelScrolledElement() : nullptr;</span>
  
      if (m_frame.page() &amp;&amp; m_frame.page()-&gt;wheelEventDeltaFilter()-&gt;isFilteringDeltas()) {
          filteredPlatformDelta = m_frame.page()-&gt;wheelEventDeltaFilter()-&gt;filteredDelta();
          filteredVelocity = m_frame.page()-&gt;wheelEventDeltaFilter()-&gt;filteredVelocity();
      }
  #else
<span class="line-modified">!     RefPtr&lt;Element&gt; stopElement;</span>
  #endif
  
<span class="line-modified">!     if (handleWheelEventInAppropriateEnclosingBox(startNode, wheelEvent, stopElement, filteredPlatformDelta, filteredVelocity))</span>
          wheelEvent.setDefaultHandled();
  
  #if PLATFORM(MAC)
      if (latchedState &amp;&amp; !latchedState-&gt;wheelEventElement())
<span class="line-modified">!         latchedState-&gt;setPreviousWheelScrolledElement(WTFMove(stopElement));</span>
  #endif
  }
  
<span class="line-modified">! #if ENABLE(CONTEXT_MENU_EVENT)</span>
  bool EventHandler::sendContextMenuEvent(const PlatformMouseEvent&amp; event)
  {
      Ref&lt;Frame&gt; protectedFrame(m_frame);
  
      Document* doc = m_frame.document();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3034,25 ***</span>
  
      PlatformMouseEvent platformMouseEvent(position, globalPosition, RightButton, eventType, 1, false, false, false, false, WallTime::now(), ForceAtClick, NoTap);
  
      return sendContextMenuEvent(platformMouseEvent);
  }
<span class="line-modified">! #endif // ENABLE(CONTEXT_MENUS)</span>
  
  void EventHandler::scheduleHoverStateUpdate()
  {
      if (!m_hoverTimer.isActive())
          m_hoverTimer.startOneShot(0_s);
  }
  
<span class="line-removed">- #if ENABLE(CURSOR_SUPPORT)</span>
  void EventHandler::scheduleCursorUpdate()
  {
      if (!m_cursorUpdateTimer.isActive())
          m_cursorUpdateTimer.startOneShot(cursorUpdateInterval);
  }
<span class="line-removed">- #endif</span>
  
  void EventHandler::dispatchFakeMouseMoveEventSoon()
  {
  #if !ENABLE(IOS_TOUCH_EVENTS)
      if (m_mousePressed)
<span class="line-new-header">--- 3047,28 ---</span>
  
      PlatformMouseEvent platformMouseEvent(position, globalPosition, RightButton, eventType, 1, false, false, false, false, WallTime::now(), ForceAtClick, NoTap);
  
      return sendContextMenuEvent(platformMouseEvent);
  }
<span class="line-modified">! #endif // ENABLE(CONTEXT_MENU_EVENT)</span>
  
  void EventHandler::scheduleHoverStateUpdate()
  {
      if (!m_hoverTimer.isActive())
          m_hoverTimer.startOneShot(0_s);
  }
  
  void EventHandler::scheduleCursorUpdate()
  {
<span class="line-added">+     if (Page* page = m_frame.page()) {</span>
<span class="line-added">+         if (!page-&gt;chrome().client().supportsSettingCursor())</span>
<span class="line-added">+             return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      if (!m_cursorUpdateTimer.isActive())
          m_cursorUpdateTimer.startOneShot(cursorUpdateInterval);
  }
  
  void EventHandler::dispatchFakeMouseMoveEventSoon()
  {
  #if !ENABLE(IOS_TOUCH_EVENTS)
      if (m_mousePressed)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3344,12 ***</span>
  #if PLATFORM(IOS_FAMILY)
      DeferDOMTimersForScope deferralScope { m_frame.document()-&gt;quirks().needsDeferKeyDownAndKeyPressTimersUntilNextEditingCommand() };
  #endif
  
      element-&gt;dispatchEvent(keydown);
<span class="line-modified">!     if (handledByInputMethod)</span>
          return true;
  
      // If frame changed as a result of keydown dispatch, then return early to avoid sending a subsequent keypress message to the new frame.
      bool changedFocusedFrame = m_frame.page() &amp;&amp; &amp;m_frame != &amp;m_frame.page()-&gt;focusController().focusedOrMainFrame();
      bool keydownResult = keydown-&gt;defaultHandled() || keydown-&gt;defaultPrevented() || changedFocusedFrame;
      if (keydownResult &amp;&amp; !backwardCompatibilityMode)
<span class="line-new-header">--- 3360,14 ---</span>
  #if PLATFORM(IOS_FAMILY)
      DeferDOMTimersForScope deferralScope { m_frame.document()-&gt;quirks().needsDeferKeyDownAndKeyPressTimersUntilNextEditingCommand() };
  #endif
  
      element-&gt;dispatchEvent(keydown);
<span class="line-modified">!     if (handledByInputMethod) {</span>
<span class="line-added">+         m_frame.editor().didDispatchInputMethodKeydown(keydown.get());</span>
          return true;
<span class="line-added">+     }</span>
  
      // If frame changed as a result of keydown dispatch, then return early to avoid sending a subsequent keypress message to the new frame.
      bool changedFocusedFrame = m_frame.page() &amp;&amp; &amp;m_frame != &amp;m_frame.page()-&gt;focusController().focusedOrMainFrame();
      bool keydownResult = keydown-&gt;defaultHandled() || keydown-&gt;defaultPrevented() || changedFocusedFrame;
      if (keydownResult &amp;&amp; !backwardCompatibilityMode)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3635,13 ***</span>
  {
      // Send a hit test request so that RenderLayer gets a chance to update the :hover and :active pseudoclasses.
      HitTestRequest request(HitTestRequest::Release | HitTestRequest::DisallowUserAgentShadowContent);
      prepareMouseEvent(request, event);
  
<span class="line-modified">!     if (dragState().source &amp;&amp; dragState().shouldDispatchEvents) {</span>
          dragState().dataTransfer-&gt;setDestinationOperation(operation);
<span class="line-modified">!         dispatchDragSrcEvent(eventNames().dragendEvent, event);</span>
      }
      invalidateDataTransfer();
  
      if (mayExtendDragSession == MayExtendDragSession::No) {
          if (auto* page = m_frame.page())
<span class="line-new-header">--- 3653,13 ---</span>
  {
      // Send a hit test request so that RenderLayer gets a chance to update the :hover and :active pseudoclasses.
      HitTestRequest request(HitTestRequest::Release | HitTestRequest::DisallowUserAgentShadowContent);
      prepareMouseEvent(request, event);
  
<span class="line-modified">!     if (shouldDispatchEventsToDragSourceElement()) {</span>
          dragState().dataTransfer-&gt;setDestinationOperation(operation);
<span class="line-modified">!         dispatchEventToDragSourceElement(eventNames().dragendEvent, event);</span>
      }
      invalidateDataTransfer();
  
      if (mayExtendDragSession == MayExtendDragSession::No) {
          if (auto* page = m_frame.page())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3659,14 ***</span>
      // If inserting the dragged contents removed the drag source, we still want to fire dragend at the root editable element.
      if (dragState().source &amp;&amp; !dragState().source-&gt;isConnected())
          dragState().source = &amp;rootEditableElement;
  }
  
<span class="line-modified">! void EventHandler::dispatchDragSrcEvent(const AtomString&amp; eventType, const PlatformMouseEvent&amp; event)</span>
  {
<span class="line-modified">!     ASSERT(dragState().dataTransfer);</span>
<span class="line-modified">!     dispatchDragEvent(eventType, *dragState().source, event, *dragState().dataTransfer);</span>
  }
  
  bool EventHandler::dispatchDragStartEventOnSourceElement(DataTransfer&amp; dataTransfer)
  {
      return !dispatchDragEvent(eventNames().dragstartEvent, *dragState().source, m_mouseDown, dataTransfer) &amp;&amp; !m_frame.selection().selection().isInPasswordField();
<span class="line-new-header">--- 3677,19 ---</span>
      // If inserting the dragged contents removed the drag source, we still want to fire dragend at the root editable element.
      if (dragState().source &amp;&amp; !dragState().source-&gt;isConnected())
          dragState().source = &amp;rootEditableElement;
  }
  
<span class="line-modified">! bool EventHandler::shouldDispatchEventsToDragSourceElement()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return dragState().source &amp;&amp; dragState().dataTransfer &amp;&amp; dragState().shouldDispatchEvents;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void EventHandler::dispatchEventToDragSourceElement(const AtomString&amp; eventType, const PlatformMouseEvent&amp; event)</span>
  {
<span class="line-modified">!     if (shouldDispatchEventsToDragSourceElement())</span>
<span class="line-modified">!         dispatchDragEvent(eventType, *dragState().source, event, *dragState().dataTransfer);</span>
  }
  
  bool EventHandler::dispatchDragStartEventOnSourceElement(DataTransfer&amp; dataTransfer)
  {
      return !dispatchDragEvent(eventNames().dragstartEvent, *dragState().source, m_mouseDown, dataTransfer) &amp;&amp; !m_frame.selection().selection().isInPasswordField();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3764,13 ***</span>
      invalidateClick();
  
      DragOperation srcOp = DragOperationNone;
  
      // This does work only if we missed a dragEnd. Do it anyway, just to make sure the old dataTransfer gets numbed.
      invalidateDataTransfer();
  
<span class="line-modified">!     dragState().dataTransfer = DataTransfer::createForDrag(*m_frame.document());</span>
      HasNonDefaultPasteboardData hasNonDefaultPasteboardData = HasNonDefaultPasteboardData::No;
  
      if (dragState().shouldDispatchEvents) {
          ASSERT(dragState().source);
          auto dragStartDataTransfer = DataTransfer::createForDragStartEvent(dragState().source-&gt;document());
<span class="line-new-header">--- 3787,14 ---</span>
      invalidateClick();
  
      DragOperation srcOp = DragOperationNone;
  
      // This does work only if we missed a dragEnd. Do it anyway, just to make sure the old dataTransfer gets numbed.
<span class="line-added">+     // FIXME: Consider doing this earlier in this function as the earliest point we&#39;re sure it would be safe to drop an old drag.</span>
      invalidateDataTransfer();
  
<span class="line-modified">!     dragState().dataTransfer = DataTransfer::createForDrag();</span>
      HasNonDefaultPasteboardData hasNonDefaultPasteboardData = HasNonDefaultPasteboardData::No;
  
      if (dragState().shouldDispatchEvents) {
          ASSERT(dragState().source);
          auto dragStartDataTransfer = DataTransfer::createForDragStartEvent(dragState().source-&gt;document());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3783,11 ***</span>
              if (auto* renderer = dragState().source-&gt;renderer()) {
                  auto absolutePosition = renderer-&gt;localToAbsolute();
                  auto delta = m_mouseDownPos - roundedIntPoint(absolutePosition);
                  dragState().dataTransfer-&gt;setDragImage(dragState().source.get(), delta.width(), delta.height());
              } else {
<span class="line-modified">!                 dispatchDragSrcEvent(eventNames().dragendEvent, event.event());</span>
                  m_mouseDownMayStartDrag = false;
                  invalidateDataTransfer();
                  dragState().source = nullptr;
                  return true;
              }
<span class="line-new-header">--- 3807,11 ---</span>
              if (auto* renderer = dragState().source-&gt;renderer()) {
                  auto absolutePosition = renderer-&gt;localToAbsolute();
                  auto delta = m_mouseDownPos - roundedIntPoint(absolutePosition);
                  dragState().dataTransfer-&gt;setDragImage(dragState().source.get(), delta.width(), delta.height());
              } else {
<span class="line-modified">!                 dispatchEventToDragSourceElement(eventNames().dragendEvent, event.event());</span>
                  m_mouseDownMayStartDrag = false;
                  invalidateDataTransfer();
                  dragState().source = nullptr;
                  return true;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3813,13 ***</span>
          // On OS X this causes problems with the ownership of the pasteboard and the promised types.
          if (m_didStartDrag) {
              m_mouseDownMayStartDrag = false;
              return true;
          }
<span class="line-modified">!         if (dragState().source &amp;&amp; dragState().shouldDispatchEvents) {</span>
              // Drag was canned at the last minute. We owe dragSource a dragend event.
<span class="line-modified">!             dispatchDragSrcEvent(eventNames().dragendEvent, event.event());</span>
              m_mouseDownMayStartDrag = false;
          }
      }
  
      if (!m_mouseDownMayStartDrag) {
<span class="line-new-header">--- 3837,13 ---</span>
          // On OS X this causes problems with the ownership of the pasteboard and the promised types.
          if (m_didStartDrag) {
              m_mouseDownMayStartDrag = false;
              return true;
          }
<span class="line-modified">!         if (shouldDispatchEventsToDragSourceElement()) {</span>
              // Drag was canned at the last minute. We owe dragSource a dragend event.
<span class="line-modified">!             dispatchEventToDragSourceElement(eventNames().dragendEvent, event.event());</span>
              m_mouseDownMayStartDrag = false;
          }
      }
  
      if (!m_mouseDownMayStartDrag) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4011,12 ***</span>
  
  void EventHandler::sendScrollEvent()
  {
      Ref&lt;Frame&gt; protectedFrame(m_frame);
      setFrameWasScrolledByUser();
<span class="line-modified">!     if (m_frame.view() &amp;&amp; m_frame.document())</span>
<span class="line-modified">!         m_frame.document()-&gt;eventQueue().enqueueOrDispatchScrollEvent(*m_frame.document());</span>
  }
  
  void EventHandler::setFrameWasScrolledByUser()
  {
      FrameView* v = m_frame.view();
<span class="line-new-header">--- 4035,16 ---</span>
  
  void EventHandler::sendScrollEvent()
  {
      Ref&lt;Frame&gt; protectedFrame(m_frame);
      setFrameWasScrolledByUser();
<span class="line-modified">!     if (!m_frame.view())</span>
<span class="line-modified">!         return;</span>
<span class="line-added">+     auto document = makeRefPtr(m_frame.document());</span>
<span class="line-added">+     if (!document)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     document-&gt;addPendingScrollEventTarget(*document);</span>
  }
  
  void EventHandler::setFrameWasScrolledByUser()
  {
      FrameView* v = m_frame.view();
</pre>
<center><a href="EditorClient.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EventHandler.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
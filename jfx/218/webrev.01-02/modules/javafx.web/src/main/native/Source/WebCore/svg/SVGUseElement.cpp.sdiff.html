<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/svg/SVGUseElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGURIReference.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGUseElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/svg/SVGUseElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 31 #include &quot;ElementIterator.h&quot;
 32 #include &quot;Event.h&quot;
 33 #include &quot;EventNames.h&quot;
 34 #include &quot;RenderSVGResource.h&quot;
 35 #include &quot;RenderSVGTransformableContainer.h&quot;
 36 #include &quot;SVGDocumentExtensions.h&quot;
 37 #include &quot;SVGGElement.h&quot;
 38 #include &quot;SVGSVGElement.h&quot;
 39 #include &quot;SVGSymbolElement.h&quot;
 40 #include &quot;ScriptDisallowedScope.h&quot;
 41 #include &quot;ShadowRoot.h&quot;
 42 #include &quot;XLinkNames.h&quot;
 43 #include &lt;wtf/IsoMallocInlines.h&gt;
 44 
 45 namespace WebCore {
 46 
 47 WTF_MAKE_ISO_ALLOCATED_IMPL(SVGUseElement);
 48 
 49 inline SVGUseElement::SVGUseElement(const QualifiedName&amp; tagName, Document&amp; document)
 50     : SVGGraphicsElement(tagName, document)
<span class="line-removed"> 51     , SVGExternalResourcesRequired(this)</span>
 52     , SVGURIReference(this)
<span class="line-modified"> 53     , m_svgLoadEventTimer(*this, &amp;SVGElement::svgLoadEventTimerFired)</span>
 54 {
 55     ASSERT(hasCustomStyleResolveCallbacks());
 56     ASSERT(hasTagName(SVGNames::useTag));
 57 
 58     static std::once_flag onceFlag;
 59     std::call_once(onceFlag, [] {
 60         PropertyRegistry::registerProperty&lt;SVGNames::xAttr, &amp;SVGUseElement::m_x&gt;();
 61         PropertyRegistry::registerProperty&lt;SVGNames::yAttr, &amp;SVGUseElement::m_y&gt;();
 62         PropertyRegistry::registerProperty&lt;SVGNames::widthAttr, &amp;SVGUseElement::m_width&gt;();
 63         PropertyRegistry::registerProperty&lt;SVGNames::heightAttr, &amp;SVGUseElement::m_height&gt;();
 64     });
 65 }
 66 
 67 Ref&lt;SVGUseElement&gt; SVGUseElement::create(const QualifiedName&amp; tagName, Document&amp; document)
 68 {
 69     return adoptRef(*new SVGUseElement(tagName, document));
 70 }
 71 
 72 SVGUseElement::~SVGUseElement()
 73 {
 74     if (m_externalDocument)
 75         m_externalDocument-&gt;removeClient(*this);
 76 }
 77 
 78 void SVGUseElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
 79 {
 80     SVGParsingError parseError = NoError;
 81 
 82     if (name == SVGNames::xAttr)
<span class="line-modified"> 83         m_x-&gt;setBaseValInternal(SVGLengthValue::construct(LengthModeWidth, value, parseError));</span>
 84     else if (name == SVGNames::yAttr)
<span class="line-modified"> 85         m_y-&gt;setBaseValInternal(SVGLengthValue::construct(LengthModeHeight, value, parseError));</span>
 86     else if (name == SVGNames::widthAttr)
<span class="line-modified"> 87         m_width-&gt;setBaseValInternal(SVGLengthValue::construct(LengthModeWidth, value, parseError, ForbidNegativeLengths));</span>
 88     else if (name == SVGNames::heightAttr)
<span class="line-modified"> 89         m_height-&gt;setBaseValInternal(SVGLengthValue::construct(LengthModeHeight, value, parseError, ForbidNegativeLengths));</span>
 90 
 91     reportAttributeParsingError(parseError, name, value);
 92 
<span class="line-removed"> 93     SVGExternalResourcesRequired::parseAttribute(name, value);</span>
 94     SVGGraphicsElement::parseAttribute(name, value);
 95     SVGURIReference::parseAttribute(name, value);
 96 }
 97 
 98 Node::InsertedIntoAncestorResult SVGUseElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
 99 {
100     SVGGraphicsElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
101     if (insertionType.connectedToDocument) {
102         if (m_shadowTreeNeedsUpdate)
103             document().addSVGUseElement(*this);
<span class="line-removed">104         SVGExternalResourcesRequired::insertedIntoDocument();</span>
105         invalidateShadowTree();
106         // FIXME: Move back the call to updateExternalDocument() here once notifyFinished is made always async.
107         return InsertedIntoAncestorResult::NeedsPostInsertionCallback;
108     }
109     return InsertedIntoAncestorResult::Done;
110 }
111 
112 void SVGUseElement::didFinishInsertingNode()
113 {
114     updateExternalDocument();
115 }
116 
117 void SVGUseElement::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
118 {
119     // Check m_shadowTreeNeedsUpdate before calling SVGElement::removedFromAncestor which calls SVGElement::invalidateInstances
120     // and SVGUseElement::updateExternalDocument which calls invalidateShadowTree().
121     if (removalType.disconnectedFromDocument) {
122         if (m_shadowTreeNeedsUpdate)
123             document().removeSVGUseElement(*this);
124     }
</pre>
<hr />
<pre>
160     InstanceInvalidationGuard guard(*this);
161 
162     if (PropertyRegistry::isKnownAttribute(attrName)) {
163         updateRelativeLengthsInformation();
164         if (attrName == SVGNames::widthAttr || attrName == SVGNames::heightAttr) {
165             // FIXME: It&#39;s unnecessarily inefficient to update both width and height each time either is changed.
166             if (auto targetClone = this-&gt;targetClone())
167                 transferSizeAttributesToTargetClone(*targetClone);
168         }
169         if (auto* renderer = this-&gt;renderer())
170             RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer);
171         return;
172     }
173 
174     if (SVGURIReference::isKnownAttribute(attrName)) {
175         updateExternalDocument();
176         invalidateShadowTree();
177         return;
178     }
179 
<span class="line-removed">180     if (SVGLangSpace::isKnownAttribute(attrName) || SVGExternalResourcesRequired::isKnownAttribute(attrName))</span>
<span class="line-removed">181         invalidateShadowTree();</span>
<span class="line-removed">182 </span>
183     SVGGraphicsElement::svgAttributeChanged(attrName);
<span class="line-removed">184     SVGExternalResourcesRequired::svgAttributeChanged(attrName);</span>
185 }
186 
187 static HashSet&lt;AtomString&gt; createAllowedElementSet()
188 {
189     // Spec: &quot;Any &#39;svg&#39;, &#39;symbol&#39;, &#39;g&#39;, graphics element or other &#39;use&#39; is potentially a template object that can be re-used
190     // (i.e., &quot;instanced&quot;) in the SVG document via a &#39;use&#39; element.&quot;
191     // &quot;Graphics Element&quot; is defined as &#39;circle&#39;, &#39;ellipse&#39;, &#39;image&#39;, &#39;line&#39;, &#39;path&#39;, &#39;polygon&#39;, &#39;polyline&#39;, &#39;rect&#39;, &#39;text&#39;
192     // Excluded are anything that is used by reference or that only make sense to appear once in a document.
193     using namespace SVGNames;
194     HashSet&lt;AtomString&gt; set;
195     for (auto&amp; tag : { aTag.get(), circleTag.get(), descTag.get(), ellipseTag.get(), gTag.get(), imageTag.get(), lineTag.get(), metadataTag.get(), pathTag.get(), polygonTag.get(), polylineTag.get(), rectTag.get(), svgTag.get(), switchTag.get(), symbolTag.get(), textTag.get(), textPathTag.get(), titleTag.get(), trefTag.get(), tspanTag.get(), useTag.get() })
196         set.add(tag.localName());
197     return set;
198 }
199 
200 static inline bool isDisallowedElement(const SVGElement&amp; element)
201 {
202     static NeverDestroyed&lt;HashSet&lt;AtomString&gt;&gt; set = createAllowedElementSet();
203     return !set.get().contains(element.localName());
204 }
</pre>
<hr />
<pre>
537 {
538     for (auto* instance : instances()) {
539         if (auto element = instance-&gt;correspondingUseElement())
540             element-&gt;invalidateShadowTree();
541     }
542 }
543 
544 bool SVGUseElement::selfHasRelativeLengths() const
545 {
546     if (x().isRelative() || y().isRelative() || width().isRelative() || height().isRelative())
547         return true;
548 
549     auto targetClone = this-&gt;targetClone();
550     return targetClone &amp;&amp; targetClone-&gt;hasRelativeLengths();
551 }
552 
553 void SVGUseElement::notifyFinished(CachedResource&amp; resource)
554 {
555     ASSERT(ScriptDisallowedScope::InMainThread::isScriptAllowed());
556     invalidateShadowTree();
<span class="line-modified">557     if (resource.errorOccurred())</span>

558         dispatchEvent(Event::create(eventNames().errorEvent, Event::CanBubble::No, Event::IsCancelable::No));
<span class="line-modified">559     else if (!resource.wasCanceled())</span>
<span class="line-modified">560         SVGExternalResourcesRequired::dispatchLoadEvent();</span>
<span class="line-removed">561 }</span>
<span class="line-removed">562 </span>
<span class="line-removed">563 void SVGUseElement::finishParsingChildren()</span>
<span class="line-removed">564 {</span>
<span class="line-removed">565     SVGGraphicsElement::finishParsingChildren();</span>
<span class="line-removed">566     SVGExternalResourcesRequired::finishParsingChildren();</span>
567 }
568 
569 void SVGUseElement::updateExternalDocument()
570 {
571     URL externalDocumentURL;
572     if (isConnected() &amp;&amp; isExternalURIReference(href(), document())) {
573         externalDocumentURL = document().completeURL(href());
574         if (!externalDocumentURL.hasFragmentIdentifier())
575             externalDocumentURL = URL();
576     }
577 
578     if (externalDocumentURL == (m_externalDocument ? m_externalDocument-&gt;url() : URL()))
579         return;
580 
581     if (m_externalDocument)
582         m_externalDocument-&gt;removeClient(*this);
583 
584     if (externalDocumentURL.isNull())
585         m_externalDocument = nullptr;
586     else {
587         ResourceLoaderOptions options = CachedResourceLoader::defaultCachedResourceOptions();
588         options.contentSecurityPolicyImposition = isInUserAgentShadowTree() ? ContentSecurityPolicyImposition::SkipPolicyCheck : ContentSecurityPolicyImposition::DoPolicyCheck;
589         options.mode = FetchOptions::Mode::SameOrigin;
590         CachedResourceRequest request { ResourceRequest { externalDocumentURL }, options };
591         request.setInitiator(*this);
592         m_externalDocument = document().cachedResourceLoader().requestSVGDocument(WTFMove(request)).value_or(nullptr);
593         if (m_externalDocument)
594             m_externalDocument-&gt;addClient(*this);
595     }
596 
597     invalidateShadowTree();
598 }
599 
<span class="line-removed">600 bool SVGUseElement::isValid() const</span>
<span class="line-removed">601 {</span>
<span class="line-removed">602     return SVGTests::isValid();</span>
<span class="line-removed">603 }</span>
<span class="line-removed">604 </span>
<span class="line-removed">605 bool SVGUseElement::haveLoadedRequiredResources()</span>
<span class="line-removed">606 {</span>
<span class="line-removed">607     return SVGExternalResourcesRequired::haveLoadedRequiredResources();</span>
<span class="line-removed">608 }</span>
<span class="line-removed">609 </span>
<span class="line-removed">610 void SVGUseElement::setHaveFiredLoadEvent(bool haveFiredLoadEvent)</span>
<span class="line-removed">611 {</span>
<span class="line-removed">612     m_haveFiredLoadEvent = haveFiredLoadEvent;</span>
<span class="line-removed">613 }</span>
<span class="line-removed">614 </span>
<span class="line-removed">615 bool SVGUseElement::haveFiredLoadEvent() const</span>
<span class="line-removed">616 {</span>
<span class="line-removed">617     return m_haveFiredLoadEvent;</span>
<span class="line-removed">618 }</span>
<span class="line-removed">619 </span>
<span class="line-removed">620 Timer* SVGUseElement::svgLoadEventTimer()</span>
<span class="line-removed">621 {</span>
<span class="line-removed">622     return &amp;m_svgLoadEventTimer;</span>
<span class="line-removed">623 }</span>
<span class="line-removed">624 </span>
625 }
</pre>
</td>
<td>
<hr />
<pre>
 31 #include &quot;ElementIterator.h&quot;
 32 #include &quot;Event.h&quot;
 33 #include &quot;EventNames.h&quot;
 34 #include &quot;RenderSVGResource.h&quot;
 35 #include &quot;RenderSVGTransformableContainer.h&quot;
 36 #include &quot;SVGDocumentExtensions.h&quot;
 37 #include &quot;SVGGElement.h&quot;
 38 #include &quot;SVGSVGElement.h&quot;
 39 #include &quot;SVGSymbolElement.h&quot;
 40 #include &quot;ScriptDisallowedScope.h&quot;
 41 #include &quot;ShadowRoot.h&quot;
 42 #include &quot;XLinkNames.h&quot;
 43 #include &lt;wtf/IsoMallocInlines.h&gt;
 44 
 45 namespace WebCore {
 46 
 47 WTF_MAKE_ISO_ALLOCATED_IMPL(SVGUseElement);
 48 
 49 inline SVGUseElement::SVGUseElement(const QualifiedName&amp; tagName, Document&amp; document)
 50     : SVGGraphicsElement(tagName, document)

 51     , SVGURIReference(this)
<span class="line-modified"> 52     , m_loadEventTimer(*this, &amp;SVGElement::loadEventTimerFired)</span>
 53 {
 54     ASSERT(hasCustomStyleResolveCallbacks());
 55     ASSERT(hasTagName(SVGNames::useTag));
 56 
 57     static std::once_flag onceFlag;
 58     std::call_once(onceFlag, [] {
 59         PropertyRegistry::registerProperty&lt;SVGNames::xAttr, &amp;SVGUseElement::m_x&gt;();
 60         PropertyRegistry::registerProperty&lt;SVGNames::yAttr, &amp;SVGUseElement::m_y&gt;();
 61         PropertyRegistry::registerProperty&lt;SVGNames::widthAttr, &amp;SVGUseElement::m_width&gt;();
 62         PropertyRegistry::registerProperty&lt;SVGNames::heightAttr, &amp;SVGUseElement::m_height&gt;();
 63     });
 64 }
 65 
 66 Ref&lt;SVGUseElement&gt; SVGUseElement::create(const QualifiedName&amp; tagName, Document&amp; document)
 67 {
 68     return adoptRef(*new SVGUseElement(tagName, document));
 69 }
 70 
 71 SVGUseElement::~SVGUseElement()
 72 {
 73     if (m_externalDocument)
 74         m_externalDocument-&gt;removeClient(*this);
 75 }
 76 
 77 void SVGUseElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
 78 {
 79     SVGParsingError parseError = NoError;
 80 
 81     if (name == SVGNames::xAttr)
<span class="line-modified"> 82         m_x-&gt;setBaseValInternal(SVGLengthValue::construct(SVGLengthMode::Width, value, parseError));</span>
 83     else if (name == SVGNames::yAttr)
<span class="line-modified"> 84         m_y-&gt;setBaseValInternal(SVGLengthValue::construct(SVGLengthMode::Height, value, parseError));</span>
 85     else if (name == SVGNames::widthAttr)
<span class="line-modified"> 86         m_width-&gt;setBaseValInternal(SVGLengthValue::construct(SVGLengthMode::Width, value, parseError, SVGLengthNegativeValuesMode::Forbid));</span>
 87     else if (name == SVGNames::heightAttr)
<span class="line-modified"> 88         m_height-&gt;setBaseValInternal(SVGLengthValue::construct(SVGLengthMode::Height, value, parseError, SVGLengthNegativeValuesMode::Forbid));</span>
 89 
 90     reportAttributeParsingError(parseError, name, value);
 91 

 92     SVGGraphicsElement::parseAttribute(name, value);
 93     SVGURIReference::parseAttribute(name, value);
 94 }
 95 
 96 Node::InsertedIntoAncestorResult SVGUseElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
 97 {
 98     SVGGraphicsElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
 99     if (insertionType.connectedToDocument) {
100         if (m_shadowTreeNeedsUpdate)
101             document().addSVGUseElement(*this);

102         invalidateShadowTree();
103         // FIXME: Move back the call to updateExternalDocument() here once notifyFinished is made always async.
104         return InsertedIntoAncestorResult::NeedsPostInsertionCallback;
105     }
106     return InsertedIntoAncestorResult::Done;
107 }
108 
109 void SVGUseElement::didFinishInsertingNode()
110 {
111     updateExternalDocument();
112 }
113 
114 void SVGUseElement::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
115 {
116     // Check m_shadowTreeNeedsUpdate before calling SVGElement::removedFromAncestor which calls SVGElement::invalidateInstances
117     // and SVGUseElement::updateExternalDocument which calls invalidateShadowTree().
118     if (removalType.disconnectedFromDocument) {
119         if (m_shadowTreeNeedsUpdate)
120             document().removeSVGUseElement(*this);
121     }
</pre>
<hr />
<pre>
157     InstanceInvalidationGuard guard(*this);
158 
159     if (PropertyRegistry::isKnownAttribute(attrName)) {
160         updateRelativeLengthsInformation();
161         if (attrName == SVGNames::widthAttr || attrName == SVGNames::heightAttr) {
162             // FIXME: It&#39;s unnecessarily inefficient to update both width and height each time either is changed.
163             if (auto targetClone = this-&gt;targetClone())
164                 transferSizeAttributesToTargetClone(*targetClone);
165         }
166         if (auto* renderer = this-&gt;renderer())
167             RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer);
168         return;
169     }
170 
171     if (SVGURIReference::isKnownAttribute(attrName)) {
172         updateExternalDocument();
173         invalidateShadowTree();
174         return;
175     }
176 



177     SVGGraphicsElement::svgAttributeChanged(attrName);

178 }
179 
180 static HashSet&lt;AtomString&gt; createAllowedElementSet()
181 {
182     // Spec: &quot;Any &#39;svg&#39;, &#39;symbol&#39;, &#39;g&#39;, graphics element or other &#39;use&#39; is potentially a template object that can be re-used
183     // (i.e., &quot;instanced&quot;) in the SVG document via a &#39;use&#39; element.&quot;
184     // &quot;Graphics Element&quot; is defined as &#39;circle&#39;, &#39;ellipse&#39;, &#39;image&#39;, &#39;line&#39;, &#39;path&#39;, &#39;polygon&#39;, &#39;polyline&#39;, &#39;rect&#39;, &#39;text&#39;
185     // Excluded are anything that is used by reference or that only make sense to appear once in a document.
186     using namespace SVGNames;
187     HashSet&lt;AtomString&gt; set;
188     for (auto&amp; tag : { aTag.get(), circleTag.get(), descTag.get(), ellipseTag.get(), gTag.get(), imageTag.get(), lineTag.get(), metadataTag.get(), pathTag.get(), polygonTag.get(), polylineTag.get(), rectTag.get(), svgTag.get(), switchTag.get(), symbolTag.get(), textTag.get(), textPathTag.get(), titleTag.get(), trefTag.get(), tspanTag.get(), useTag.get() })
189         set.add(tag.localName());
190     return set;
191 }
192 
193 static inline bool isDisallowedElement(const SVGElement&amp; element)
194 {
195     static NeverDestroyed&lt;HashSet&lt;AtomString&gt;&gt; set = createAllowedElementSet();
196     return !set.get().contains(element.localName());
197 }
</pre>
<hr />
<pre>
530 {
531     for (auto* instance : instances()) {
532         if (auto element = instance-&gt;correspondingUseElement())
533             element-&gt;invalidateShadowTree();
534     }
535 }
536 
537 bool SVGUseElement::selfHasRelativeLengths() const
538 {
539     if (x().isRelative() || y().isRelative() || width().isRelative() || height().isRelative())
540         return true;
541 
542     auto targetClone = this-&gt;targetClone();
543     return targetClone &amp;&amp; targetClone-&gt;hasRelativeLengths();
544 }
545 
546 void SVGUseElement::notifyFinished(CachedResource&amp; resource)
547 {
548     ASSERT(ScriptDisallowedScope::InMainThread::isScriptAllowed());
549     invalidateShadowTree();
<span class="line-modified">550     if (resource.errorOccurred()) {</span>
<span class="line-added">551         setErrorOccurred(true);</span>
552         dispatchEvent(Event::create(eventNames().errorEvent, Event::CanBubble::No, Event::IsCancelable::No));
<span class="line-modified">553     } else if (!resource.wasCanceled())</span>
<span class="line-modified">554         SVGURIReference::dispatchLoadEvent();</span>






555 }
556 
557 void SVGUseElement::updateExternalDocument()
558 {
559     URL externalDocumentURL;
560     if (isConnected() &amp;&amp; isExternalURIReference(href(), document())) {
561         externalDocumentURL = document().completeURL(href());
562         if (!externalDocumentURL.hasFragmentIdentifier())
563             externalDocumentURL = URL();
564     }
565 
566     if (externalDocumentURL == (m_externalDocument ? m_externalDocument-&gt;url() : URL()))
567         return;
568 
569     if (m_externalDocument)
570         m_externalDocument-&gt;removeClient(*this);
571 
572     if (externalDocumentURL.isNull())
573         m_externalDocument = nullptr;
574     else {
575         ResourceLoaderOptions options = CachedResourceLoader::defaultCachedResourceOptions();
576         options.contentSecurityPolicyImposition = isInUserAgentShadowTree() ? ContentSecurityPolicyImposition::SkipPolicyCheck : ContentSecurityPolicyImposition::DoPolicyCheck;
577         options.mode = FetchOptions::Mode::SameOrigin;
578         CachedResourceRequest request { ResourceRequest { externalDocumentURL }, options };
579         request.setInitiator(*this);
580         m_externalDocument = document().cachedResourceLoader().requestSVGDocument(WTFMove(request)).value_or(nullptr);
581         if (m_externalDocument)
582             m_externalDocument-&gt;addClient(*this);
583     }
584 
585     invalidateShadowTree();
586 }
587 

























588 }
</pre>
</td>
</tr>
</table>
<center><a href="SVGURIReference.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGUseElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
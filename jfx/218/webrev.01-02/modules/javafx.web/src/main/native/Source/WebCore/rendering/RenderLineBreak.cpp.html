<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLineBreak.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /**
  2  * Copyright (C) 2000 Lars Knoll (knoll@kde.org)
  3  * Copyright (C) 2006, 2013 Apple Inc. All rights reserved.
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;RenderLineBreak.h&quot;
 24 
 25 #include &quot;Document.h&quot;
 26 #include &quot;FontMetrics.h&quot;
 27 #include &quot;HTMLElement.h&quot;
 28 #include &quot;HTMLWBRElement.h&quot;
 29 #include &quot;InlineElementBox.h&quot;
 30 #include &quot;LineLayoutTraversal.h&quot;
 31 #include &quot;LogicalSelectionOffsetCaches.h&quot;
 32 #include &quot;RenderBlock.h&quot;
 33 #include &quot;RenderView.h&quot;
 34 #include &quot;RootInlineBox.h&quot;
 35 #include &quot;VisiblePosition.h&quot;
 36 #include &lt;wtf/IsoMallocInlines.h&gt;
 37 
 38 #if PLATFORM(IOS_FAMILY)
 39 #include &quot;SelectionRect.h&quot;
 40 #endif
 41 
 42 namespace WebCore {
 43 
 44 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderLineBreak);
 45 
 46 static const int invalidLineHeight = -1;
 47 
 48 RenderLineBreak::RenderLineBreak(HTMLElement&amp; element, RenderStyle&amp;&amp; style)
 49     : RenderBoxModelObject(element, WTFMove(style), 0)
 50     , m_inlineBoxWrapper(nullptr)
 51     , m_cachedLineHeight(invalidLineHeight)
 52     , m_isWBR(is&lt;HTMLWBRElement&gt;(element))
 53 {
 54     setIsLineBreak();
 55 }
 56 
 57 RenderLineBreak::~RenderLineBreak()
 58 {
 59     delete m_inlineBoxWrapper;
 60 }
 61 
 62 LayoutUnit RenderLineBreak::lineHeight(bool firstLine, LineDirectionMode /*direction*/, LinePositionMode /*linePositionMode*/) const
 63 {
 64     if (firstLine &amp;&amp; view().usesFirstLineRules()) {
 65         const RenderStyle&amp; firstLineStyle = this-&gt;firstLineStyle();
 66         if (&amp;firstLineStyle != &amp;style())
 67             return firstLineStyle.computedLineHeight();
 68     }
 69 
 70     if (m_cachedLineHeight == invalidLineHeight)
 71         m_cachedLineHeight = style().computedLineHeight();
 72 
 73     return m_cachedLineHeight;
 74 }
 75 
 76 int RenderLineBreak::baselinePosition(FontBaseline baselineType, bool firstLine, LineDirectionMode direction, LinePositionMode linePositionMode) const
 77 {
 78     const RenderStyle&amp; style = firstLine ? firstLineStyle() : this-&gt;style();
 79     const FontMetrics&amp; fontMetrics = style.fontMetrics();
 80     return fontMetrics.ascent(baselineType) + (lineHeight(firstLine, direction, linePositionMode) - fontMetrics.height()) / 2;
 81 }
 82 
 83 std::unique_ptr&lt;InlineElementBox&gt; RenderLineBreak::createInlineBox()
 84 {
 85     return makeUnique&lt;InlineElementBox&gt;(*this);
 86 }
 87 
 88 void RenderLineBreak::setInlineBoxWrapper(InlineElementBox* inlineBox)
 89 {
 90     ASSERT(!inlineBox || !m_inlineBoxWrapper);
 91     m_inlineBoxWrapper = inlineBox;
 92 }
 93 
 94 void RenderLineBreak::replaceInlineBoxWrapper(InlineElementBox&amp; inlineBox)
 95 {
 96     deleteInlineBoxWrapper();
 97     setInlineBoxWrapper(&amp;inlineBox);
 98 }
 99 
100 void RenderLineBreak::deleteInlineBoxWrapper()
101 {
102     if (!m_inlineBoxWrapper)
103         return;
104     if (!renderTreeBeingDestroyed())
105         m_inlineBoxWrapper-&gt;removeFromParent();
106     delete m_inlineBoxWrapper;
107     m_inlineBoxWrapper = nullptr;
108 }
109 
110 void RenderLineBreak::dirtyLineBoxes(bool fullLayout)
111 {
112     if (!m_inlineBoxWrapper)
113         return;
114     if (fullLayout) {
115         delete m_inlineBoxWrapper;
116         m_inlineBoxWrapper = nullptr;
117         return;
118     }
119     m_inlineBoxWrapper-&gt;dirtyLineBoxes();
120 }
121 
122 void RenderLineBreak::ensureLineBoxes()
123 {
124     if (!is&lt;RenderBlockFlow&gt;(*parent()))
125         return;
126     downcast&lt;RenderBlockFlow&gt;(*parent()).ensureLineBoxes();
127 }
128 
129 int RenderLineBreak::caretMinOffset() const
130 {
131     return 0;
132 }
133 
134 int RenderLineBreak::caretMaxOffset() const
135 {
136     return 1;
137 }
138 
139 bool RenderLineBreak::canBeSelectionLeaf() const
140 {
141     return true;
142 }
143 
144 VisiblePosition RenderLineBreak::positionForPoint(const LayoutPoint&amp;, const RenderFragmentContainer*)
145 {
146     ensureLineBoxes();
147     return createVisiblePosition(0, DOWNSTREAM);
148 }
149 
150 void RenderLineBreak::setSelectionState(SelectionState state)
151 {
152     if (state != SelectionNone)
153         ensureLineBoxes();
154     RenderBoxModelObject::setSelectionState(state);
155     if (!m_inlineBoxWrapper)
156         return;
157     m_inlineBoxWrapper-&gt;root().setHasSelectedChildren(state != SelectionNone);
158 }
159 
160 LayoutRect RenderLineBreak::localCaretRect(InlineBox* inlineBox, unsigned caretOffset, LayoutUnit* extraWidthToEndOfLine)
161 {
162     ASSERT_UNUSED(caretOffset, !caretOffset);
163     ASSERT_UNUSED(inlineBox, inlineBox == m_inlineBoxWrapper);
164     if (!inlineBox)
165         return LayoutRect();
166 
167     const RootInlineBox&amp; rootBox = inlineBox-&gt;root();
168     return rootBox.computeCaretRect(inlineBox-&gt;logicalLeft(), caretWidth, extraWidthToEndOfLine);
169 }
170 
171 IntRect RenderLineBreak::linesBoundingBox() const
172 {
173     auto box = LineLayoutTraversal::elementBoxFor(*this);
174     if (!box)
175         return { };
176 
177     return enclosingIntRect(box-&gt;rect());
178 }
179 
180 IntRect RenderLineBreak::boundingBoxForRenderTreeDump() const
181 {
182     auto box = LineLayoutTraversal::elementBoxFor(*this);
183     if (!box)
184         return { };
185 
186     auto rect = box-&gt;rect();
187 
188     // FIXME: Remove and rebase the tests.
189     bool inQuirksMode = !document().inNoQuirksMode();
190     if (inQuirksMode &amp;&amp; !isWBR() &amp;&amp; box-&gt;useLineBreakBoxRenderTreeDumpQuirk()) {
191         if (!box-&gt;isHorizontal()) {
192             auto baseline = style().isFlippedBlocksWritingMode() ? rect.x() + box-&gt;baselineOffset() : rect.maxX() - box-&gt;baselineOffset();
193             return enclosingIntRect(FloatRect(FloatPoint(baseline, rect.y()), FloatSize(0, rect.height())));
194         }
195         auto baseline = rect.y() + box-&gt;baselineOffset();
196         return enclosingIntRect(FloatRect(FloatPoint(rect.x(), baseline), FloatSize(rect.width(), 0)));
197     }
198 
199     return enclosingIntRect(rect);
200 }
201 
202 void RenderLineBreak::absoluteRects(Vector&lt;IntRect&gt;&amp; rects, const LayoutPoint&amp; accumulatedOffset) const
203 {
204     auto box = LineLayoutTraversal::elementBoxFor(*this);
205     if (!box)
206         return;
207 
208     auto rect = box-&gt;rect();
209     rects.append(enclosingIntRect(FloatRect(accumulatedOffset + rect.location(), rect.size())));
210 }
211 
212 void RenderLineBreak::absoluteQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const
213 {
214     auto box = LineLayoutTraversal::elementBoxFor(*this);
215     if (!box)
216         return;
217 
218     auto rect = box-&gt;rect();
219     quads.append(localToAbsoluteQuad(FloatRect(rect.location(), rect.size()), UseTransforms, wasFixed));
220 }
221 
222 void RenderLineBreak::updateFromStyle()
223 {
224     m_cachedLineHeight = invalidLineHeight;
225 }
226 
227 #if PLATFORM(IOS_FAMILY)
228 void RenderLineBreak::collectSelectionRects(Vector&lt;SelectionRect&gt;&amp; rects, unsigned, unsigned)
229 {
230     ensureLineBoxes();
231     InlineElementBox* box = m_inlineBoxWrapper;
232     if (!box)
233         return;
234     const RootInlineBox&amp; rootBox = box-&gt;root();
235     LayoutRect rect = rootBox.computeCaretRect(box-&gt;logicalLeft(), 0, nullptr);
236     if (rootBox.isFirstAfterPageBreak()) {
237         if (box-&gt;isHorizontal())
238             rect.shiftYEdgeTo(rootBox.lineTopWithLeading());
239         else
240             rect.shiftXEdgeTo(rootBox.lineTopWithLeading());
241     }
242 
243     auto* containingBlock = containingBlockForObjectInFlow();
244     // Map rect, extended left to leftOffset, and right to rightOffset, through transforms to get minX and maxX.
245     LogicalSelectionOffsetCaches cache(*containingBlock);
246     LayoutUnit leftOffset = containingBlock-&gt;logicalLeftSelectionOffset(*containingBlock, LayoutUnit(box-&gt;logicalTop()), cache);
247     LayoutUnit rightOffset = containingBlock-&gt;logicalRightSelectionOffset(*containingBlock, LayoutUnit(box-&gt;logicalTop()), cache);
248     LayoutRect extentsRect = rect;
249     if (box-&gt;isHorizontal()) {
250         extentsRect.setX(leftOffset);
251         extentsRect.setWidth(rightOffset - leftOffset);
252     } else {
253         extentsRect.setY(leftOffset);
254         extentsRect.setHeight(rightOffset - leftOffset);
255     }
256     extentsRect = localToAbsoluteQuad(FloatRect(extentsRect)).enclosingBoundingBox();
257     if (!box-&gt;isHorizontal())
258         extentsRect = extentsRect.transposedRect();
259     bool isFirstOnLine = !box-&gt;previousOnLineExists();
260     bool isLastOnLine = !box-&gt;nextOnLineExists();
261     if (containingBlock-&gt;isRubyBase() || containingBlock-&gt;isRubyText())
262         isLastOnLine = !containingBlock-&gt;containingBlock()-&gt;inlineBoxWrapper()-&gt;nextOnLineExists();
263 
264     bool isFixed = false;
265     IntRect absRect = localToAbsoluteQuad(FloatRect(rect), UseTransforms, &amp;isFixed).enclosingBoundingBox();
266     bool boxIsHorizontal = !box-&gt;isSVGInlineTextBox() ? box-&gt;isHorizontal() : !style().isVerticalWritingMode();
267     // If the containing block is an inline element, we want to check the inlineBoxWrapper orientation
268     // to determine the orientation of the block. In this case we also use the inlineBoxWrapper to
269     // determine if the element is the last on the line.
270     if (containingBlock-&gt;inlineBoxWrapper()) {
271         if (containingBlock-&gt;inlineBoxWrapper()-&gt;isHorizontal() != boxIsHorizontal) {
272             boxIsHorizontal = containingBlock-&gt;inlineBoxWrapper()-&gt;isHorizontal();
273             isLastOnLine = !containingBlock-&gt;inlineBoxWrapper()-&gt;nextOnLineExists();
274         }
275     }
276 
277     rects.append(SelectionRect(absRect, box-&gt;direction(), extentsRect.x(), extentsRect.maxX(), extentsRect.maxY(), 0, box-&gt;isLineBreak(), isFirstOnLine, isLastOnLine, false, false, boxIsHorizontal, isFixed, containingBlock-&gt;isRubyText(), view().pageNumberForBlockProgressionOffset(absRect.x())));
278 }
279 #endif
280 
281 } // namespace WebCore
    </pre>
  </body>
</html>
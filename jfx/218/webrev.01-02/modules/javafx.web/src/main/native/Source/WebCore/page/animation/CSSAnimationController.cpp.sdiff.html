<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/animation/CSSAnimationController.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AnimationBase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSAnimationController.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/animation/CSSAnimationController.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
133     return result;
134 }
135 
136 Optional&lt;Seconds&gt; CSSAnimationControllerPrivate::updateAnimations(SetChanged callSetChanged/* = DoNotCallSetChanged*/)
137 {
138     AnimationPrivateUpdateBlock updateBlock(*this);
139     Optional&lt;Seconds&gt; timeToNextService;
140     bool calledSetChanged = false;
141 
142     for (auto&amp; compositeAnimation : m_compositeAnimations) {
143         CompositeAnimation&amp; animation = *compositeAnimation.value;
144         if (!animation.isSuspended() &amp;&amp; animation.hasAnimations()) {
145             Optional&lt;Seconds&gt; t = animation.timeToNextService();
146             if (t &amp;&amp; (!timeToNextService || t.value() &lt; timeToNextService.value()))
147                 timeToNextService = t.value();
148             if (timeToNextService &amp;&amp; timeToNextService.value() == 0_s) {
149                 if (callSetChanged != CallSetChanged)
150                     break;
151 
152                 Element&amp; element = *compositeAnimation.key;
<span class="line-modified">153                 ASSERT(element.document().pageCacheState() == Document::NotInPageCache);</span>
154                 element.invalidateStyle();
155                 calledSetChanged = true;
156             }
157         }
158     }
159 
160     if (calledSetChanged)
161         m_frame.document()-&gt;updateStyleIfNeeded();
162 
163     return timeToNextService;
164 }
165 
166 void CSSAnimationControllerPrivate::updateAnimationTimerForElement(Element&amp; element)
167 {
168     Optional&lt;Seconds&gt; timeToNextService;
169 
170     const CompositeAnimation* compositeAnimation = m_compositeAnimations.get(&amp;element);
171     if (!compositeAnimation-&gt;isSuspended() &amp;&amp; compositeAnimation-&gt;hasAnimations())
172         timeToNextService = compositeAnimation-&gt;timeToNextService();
173 
</pre>
<hr />
<pre>
208     m_animationTimer.startOneShot(timeToNextService.value());
209 }
210 
211 void CSSAnimationControllerPrivate::updateStyleIfNeededDispatcherFired()
212 {
213     fireEventsAndUpdateStyle();
214 }
215 
216 void CSSAnimationControllerPrivate::fireEventsAndUpdateStyle()
217 {
218     // Protect the frame from getting destroyed in the event handler
219     Ref&lt;Frame&gt; protector(m_frame);
220 
221     bool updateStyle = !m_eventsToDispatch.isEmpty() || !m_elementChangesToDispatch.isEmpty();
222 
223     // fire all the events
224     Vector&lt;EventToDispatch&gt; eventsToDispatch = WTFMove(m_eventsToDispatch);
225     for (auto&amp; event : eventsToDispatch) {
226         Element&amp; element = event.element;
227         if (event.eventType == eventNames().transitionendEvent)
<span class="line-modified">228             element.dispatchEvent(TransitionEvent::create(event.eventType, event.name, event.elapsedTime, PseudoElement::pseudoElementNameForEvents(element.pseudoId())));</span>
229         else
<span class="line-modified">230             element.dispatchEvent(AnimationEvent::create(event.eventType, event.name, event.elapsedTime));</span>
231     }
232 
233     for (auto&amp; change : m_elementChangesToDispatch)
234         change-&gt;invalidateStyle();
235 
236     m_elementChangesToDispatch.clear();
237 
238     if (updateStyle)
239         m_frame.document()-&gt;updateStyleIfNeeded();
240 }
241 
242 void CSSAnimationControllerPrivate::startUpdateStyleIfNeededDispatcher()
243 {
244     if (!m_updateStyleIfNeededDispatcher.isActive())
245         m_updateStyleIfNeededDispatcher.startOneShot(0_s);
246 }
247 
248 void CSSAnimationControllerPrivate::addEventToDispatch(Element&amp; element, const AtomString&amp; eventType, const String&amp; name, double elapsedTime)
249 {
250     m_eventsToDispatch.append({ element, eventType, name, elapsedTime });
251     startUpdateStyleIfNeededDispatcher();
252 }
253 
254 void CSSAnimationControllerPrivate::addElementChangeToDispatch(Element&amp; element)
255 {
256     m_elementChangesToDispatch.append(element);
<span class="line-modified">257     ASSERT(m_elementChangesToDispatch.last()-&gt;document().pageCacheState() == Document::NotInPageCache);</span>
258     startUpdateStyleIfNeededDispatcher();
259 }
260 
261 void CSSAnimationControllerPrivate::animationFrameCallbackFired()
262 {
263     Optional&lt;Seconds&gt; timeToNextService = updateAnimations(CallSetChanged);
264 
265     if (timeToNextService)
266         m_frame.document()-&gt;view()-&gt;scheduleAnimation();
267 }
268 
269 void CSSAnimationControllerPrivate::animationTimerFired()
270 {
271     // We need to keep the frame alive, since it owns us.
272     Ref&lt;Frame&gt; protector(m_frame);
273 
274     // The animation timer might fire before the layout timer, in
275     // which case we might create some animations with incorrect
276     // values if we don&#39;t layout first.
277     if (m_requiresLayout) {
</pre>
<hr />
<pre>
592     }
593 
594     if (!anyAnimationsWaitingForAsyncStart)
595         m_waitingForAsyncStartNotification = false;
596 }
597 
598 CSSAnimationController::CSSAnimationController(Frame&amp; frame)
599     : m_data(makeUnique&lt;CSSAnimationControllerPrivate&gt;(frame))
600 {
601 }
602 
603 CSSAnimationController::~CSSAnimationController() = default;
604 
605 void CSSAnimationController::cancelAnimations(Element&amp; element)
606 {
607     if (!m_data-&gt;clear(element))
608         return;
609 
610     if (element.document().renderTreeBeingDestroyed())
611         return;
<span class="line-modified">612     ASSERT(element.document().pageCacheState() == Document::NotInPageCache);</span>
613     element.invalidateStyle();
614 }
615 
616 AnimationUpdate CSSAnimationController::updateAnimations(Element&amp; element, const RenderStyle&amp; newStyle, const RenderStyle* oldStyle)
617 {
618     bool hasOrHadAnimations = (oldStyle &amp;&amp; oldStyle-&gt;hasAnimationsOrTransitions()) || newStyle.hasAnimationsOrTransitions();
619     if (!hasOrHadAnimations)
620         return { };
621 
<span class="line-modified">622     if (element.document().pageCacheState() != Document::NotInPageCache)</span>
623         return { };
624 
625     // Don&#39;t run transitions when printing.
626     if (element.document().renderView()-&gt;printing())
627         return { };
628 
629     // Fetch our current set of implicit animations from a hashtable. We then compare them
630     // against the animations in the style and make sure we&#39;re in sync. If destination values
631     // have changed, we reset the animation. We then do a blend to get new values and we return
632     // a new style.
633 
634     CompositeAnimation&amp; compositeAnimation = m_data-&gt;ensureCompositeAnimation(element);
635     auto update = compositeAnimation.animate(element, oldStyle, newStyle);
636 
637     auto* renderer = element.renderer();
638     if ((renderer &amp;&amp; renderer-&gt;parent()) || newStyle.animations() || (oldStyle &amp;&amp; oldStyle-&gt;animations())) {
639         auto&amp; frameView = *element.document().view();
640         if (compositeAnimation.hasAnimationThatDependsOnLayout())
641             m_data-&gt;setRequiresLayout();
642         m_data-&gt;updateAnimationTimerForElement(element);
</pre>
</td>
<td>
<hr />
<pre>
133     return result;
134 }
135 
136 Optional&lt;Seconds&gt; CSSAnimationControllerPrivate::updateAnimations(SetChanged callSetChanged/* = DoNotCallSetChanged*/)
137 {
138     AnimationPrivateUpdateBlock updateBlock(*this);
139     Optional&lt;Seconds&gt; timeToNextService;
140     bool calledSetChanged = false;
141 
142     for (auto&amp; compositeAnimation : m_compositeAnimations) {
143         CompositeAnimation&amp; animation = *compositeAnimation.value;
144         if (!animation.isSuspended() &amp;&amp; animation.hasAnimations()) {
145             Optional&lt;Seconds&gt; t = animation.timeToNextService();
146             if (t &amp;&amp; (!timeToNextService || t.value() &lt; timeToNextService.value()))
147                 timeToNextService = t.value();
148             if (timeToNextService &amp;&amp; timeToNextService.value() == 0_s) {
149                 if (callSetChanged != CallSetChanged)
150                     break;
151 
152                 Element&amp; element = *compositeAnimation.key;
<span class="line-modified">153                 ASSERT(element.document().backForwardCacheState() == Document::NotInBackForwardCache);</span>
154                 element.invalidateStyle();
155                 calledSetChanged = true;
156             }
157         }
158     }
159 
160     if (calledSetChanged)
161         m_frame.document()-&gt;updateStyleIfNeeded();
162 
163     return timeToNextService;
164 }
165 
166 void CSSAnimationControllerPrivate::updateAnimationTimerForElement(Element&amp; element)
167 {
168     Optional&lt;Seconds&gt; timeToNextService;
169 
170     const CompositeAnimation* compositeAnimation = m_compositeAnimations.get(&amp;element);
171     if (!compositeAnimation-&gt;isSuspended() &amp;&amp; compositeAnimation-&gt;hasAnimations())
172         timeToNextService = compositeAnimation-&gt;timeToNextService();
173 
</pre>
<hr />
<pre>
208     m_animationTimer.startOneShot(timeToNextService.value());
209 }
210 
211 void CSSAnimationControllerPrivate::updateStyleIfNeededDispatcherFired()
212 {
213     fireEventsAndUpdateStyle();
214 }
215 
216 void CSSAnimationControllerPrivate::fireEventsAndUpdateStyle()
217 {
218     // Protect the frame from getting destroyed in the event handler
219     Ref&lt;Frame&gt; protector(m_frame);
220 
221     bool updateStyle = !m_eventsToDispatch.isEmpty() || !m_elementChangesToDispatch.isEmpty();
222 
223     // fire all the events
224     Vector&lt;EventToDispatch&gt; eventsToDispatch = WTFMove(m_eventsToDispatch);
225     for (auto&amp; event : eventsToDispatch) {
226         Element&amp; element = event.element;
227         if (event.eventType == eventNames().transitionendEvent)
<span class="line-modified">228             element.dispatchEvent(TransitionEvent::create(event.eventType, event.name, event.elapsedTime, PseudoElement::pseudoElementNameForEvents(element.pseudoId()), WTF::nullopt, nullptr));</span>
229         else
<span class="line-modified">230             element.dispatchEvent(AnimationEvent::create(event.eventType, event.name, event.elapsedTime, PseudoElement::pseudoElementNameForEvents(element.pseudoId()), WTF::nullopt, nullptr));</span>
231     }
232 
233     for (auto&amp; change : m_elementChangesToDispatch)
234         change-&gt;invalidateStyle();
235 
236     m_elementChangesToDispatch.clear();
237 
238     if (updateStyle)
239         m_frame.document()-&gt;updateStyleIfNeeded();
240 }
241 
242 void CSSAnimationControllerPrivate::startUpdateStyleIfNeededDispatcher()
243 {
244     if (!m_updateStyleIfNeededDispatcher.isActive())
245         m_updateStyleIfNeededDispatcher.startOneShot(0_s);
246 }
247 
248 void CSSAnimationControllerPrivate::addEventToDispatch(Element&amp; element, const AtomString&amp; eventType, const String&amp; name, double elapsedTime)
249 {
250     m_eventsToDispatch.append({ element, eventType, name, elapsedTime });
251     startUpdateStyleIfNeededDispatcher();
252 }
253 
254 void CSSAnimationControllerPrivate::addElementChangeToDispatch(Element&amp; element)
255 {
256     m_elementChangesToDispatch.append(element);
<span class="line-modified">257     ASSERT(m_elementChangesToDispatch.last()-&gt;document().backForwardCacheState() == Document::NotInBackForwardCache);</span>
258     startUpdateStyleIfNeededDispatcher();
259 }
260 
261 void CSSAnimationControllerPrivate::animationFrameCallbackFired()
262 {
263     Optional&lt;Seconds&gt; timeToNextService = updateAnimations(CallSetChanged);
264 
265     if (timeToNextService)
266         m_frame.document()-&gt;view()-&gt;scheduleAnimation();
267 }
268 
269 void CSSAnimationControllerPrivate::animationTimerFired()
270 {
271     // We need to keep the frame alive, since it owns us.
272     Ref&lt;Frame&gt; protector(m_frame);
273 
274     // The animation timer might fire before the layout timer, in
275     // which case we might create some animations with incorrect
276     // values if we don&#39;t layout first.
277     if (m_requiresLayout) {
</pre>
<hr />
<pre>
592     }
593 
594     if (!anyAnimationsWaitingForAsyncStart)
595         m_waitingForAsyncStartNotification = false;
596 }
597 
598 CSSAnimationController::CSSAnimationController(Frame&amp; frame)
599     : m_data(makeUnique&lt;CSSAnimationControllerPrivate&gt;(frame))
600 {
601 }
602 
603 CSSAnimationController::~CSSAnimationController() = default;
604 
605 void CSSAnimationController::cancelAnimations(Element&amp; element)
606 {
607     if (!m_data-&gt;clear(element))
608         return;
609 
610     if (element.document().renderTreeBeingDestroyed())
611         return;
<span class="line-modified">612     ASSERT(element.document().backForwardCacheState() == Document::NotInBackForwardCache);</span>
613     element.invalidateStyle();
614 }
615 
616 AnimationUpdate CSSAnimationController::updateAnimations(Element&amp; element, const RenderStyle&amp; newStyle, const RenderStyle* oldStyle)
617 {
618     bool hasOrHadAnimations = (oldStyle &amp;&amp; oldStyle-&gt;hasAnimationsOrTransitions()) || newStyle.hasAnimationsOrTransitions();
619     if (!hasOrHadAnimations)
620         return { };
621 
<span class="line-modified">622     if (element.document().backForwardCacheState() != Document::NotInBackForwardCache)</span>
623         return { };
624 
625     // Don&#39;t run transitions when printing.
626     if (element.document().renderView()-&gt;printing())
627         return { };
628 
629     // Fetch our current set of implicit animations from a hashtable. We then compare them
630     // against the animations in the style and make sure we&#39;re in sync. If destination values
631     // have changed, we reset the animation. We then do a blend to get new values and we return
632     // a new style.
633 
634     CompositeAnimation&amp; compositeAnimation = m_data-&gt;ensureCompositeAnimation(element);
635     auto update = compositeAnimation.animate(element, oldStyle, newStyle);
636 
637     auto* renderer = element.renderer();
638     if ((renderer &amp;&amp; renderer-&gt;parent()) || newStyle.animations() || (oldStyle &amp;&amp; oldStyle-&gt;animations())) {
639         auto&amp; frameView = *element.document().view();
640         if (compositeAnimation.hasAnimationThatDependsOnLayout())
641             m_data-&gt;setRequiresLayout();
642         m_data-&gt;updateAnimationTimerForElement(element);
</pre>
</td>
</tr>
</table>
<center><a href="AnimationBase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSAnimationController.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
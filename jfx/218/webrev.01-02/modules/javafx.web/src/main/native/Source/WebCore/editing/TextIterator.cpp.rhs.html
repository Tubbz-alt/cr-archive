<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/editing/TextIterator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   3  * Copyright (C) 2005 Alexey Proskuryakov.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;TextIterator.h&quot;
  29 
  30 #include &quot;ComposedTreeIterator.h&quot;
  31 #include &quot;Document.h&quot;
  32 #include &quot;Editing.h&quot;
  33 #include &quot;FontCascade.h&quot;
  34 #include &quot;Frame.h&quot;
  35 #include &quot;HTMLBodyElement.h&quot;
  36 #include &quot;HTMLElement.h&quot;
  37 #include &quot;HTMLFrameOwnerElement.h&quot;
  38 #include &quot;HTMLInputElement.h&quot;
  39 #include &quot;HTMLLegendElement.h&quot;
  40 #include &quot;HTMLMeterElement.h&quot;
  41 #include &quot;HTMLNames.h&quot;
  42 #include &quot;HTMLParagraphElement.h&quot;
  43 #include &quot;HTMLProgressElement.h&quot;
  44 #include &quot;HTMLSlotElement.h&quot;
  45 #include &quot;HTMLTextAreaElement.h&quot;
  46 #include &quot;HTMLTextFormControlElement.h&quot;
  47 #include &quot;InlineTextBox.h&quot;
  48 #include &quot;NodeTraversal.h&quot;
  49 #include &quot;RenderImage.h&quot;
  50 #include &quot;RenderIterator.h&quot;
  51 #include &quot;RenderTableCell.h&quot;
  52 #include &quot;RenderTableRow.h&quot;
  53 #include &quot;RenderTextControl.h&quot;
  54 #include &quot;RenderTextFragment.h&quot;
  55 #include &quot;ShadowRoot.h&quot;
  56 #include &quot;SimpleLineLayout.h&quot;
  57 #include &quot;SimpleLineLayoutFunctions.h&quot;
  58 #include &quot;SimpleLineLayoutResolver.h&quot;
  59 #include &quot;TextBoundaries.h&quot;
  60 #include &quot;TextControlInnerElements.h&quot;
  61 #include &quot;VisiblePosition.h&quot;
  62 #include &quot;VisibleUnits.h&quot;
  63 #include &lt;unicode/unorm2.h&gt;
  64 #include &lt;wtf/Function.h&gt;
  65 #include &lt;wtf/text/CString.h&gt;
  66 #include &lt;wtf/text/StringBuilder.h&gt;
  67 #include &lt;wtf/text/TextBreakIterator.h&gt;
  68 #include &lt;wtf/unicode/CharacterNames.h&gt;
  69 
  70 #if !UCONFIG_NO_COLLATION
  71 #include &lt;unicode/usearch.h&gt;
  72 #include &lt;wtf/text/TextBreakIteratorInternalICU.h&gt;
  73 #endif
  74 
  75 namespace WebCore {
  76 
  77 using namespace WTF::Unicode;
  78 using namespace HTMLNames;
  79 
  80 // Buffer that knows how to compare with a search target.
  81 // Keeps enough of the previous text to be able to search in the future, but no more.
  82 // Non-breaking spaces are always equal to normal spaces.
  83 // Case folding is also done if the CaseInsensitive option is specified.
  84 // Matches are further filtered if the AtWordStarts option is specified, although some
  85 // matches inside a word are permitted if TreatMedialCapitalAsWordStart is specified as well.
  86 class SearchBuffer {
  87     WTF_MAKE_NONCOPYABLE(SearchBuffer);
  88 public:
  89     SearchBuffer(const String&amp; target, FindOptions);
  90     ~SearchBuffer();
  91 
  92     // Returns number of characters appended; guaranteed to be in the range [1, length].
  93     size_t append(StringView);
  94     bool needsMoreContext() const;
  95     void prependContext(StringView);
  96     void reachedBreak();
  97 
  98     // Result is the size in characters of what was found.
  99     // And &lt;startOffset&gt; is the number of characters back to the start of what was found.
 100     size_t search(size_t&amp; startOffset);
 101     bool atBreak() const;
 102 
 103 #if !UCONFIG_NO_COLLATION
 104 
 105 private:
 106     bool isBadMatch(const UChar*, size_t length) const;
 107     bool isWordStartMatch(size_t start, size_t length) const;
 108     bool isWordEndMatch(size_t start, size_t length) const;
 109 
 110     const String m_target;
 111     const StringView::UpconvertedCharacters m_targetCharacters;
 112     FindOptions m_options;
 113 
 114     Vector&lt;UChar&gt; m_buffer;
 115     size_t m_overlap;
 116     size_t m_prefixLength;
 117     bool m_atBreak;
 118     bool m_needsMoreContext;
 119 
 120     const bool m_targetRequiresKanaWorkaround;
 121     Vector&lt;UChar&gt; m_normalizedTarget;
 122     mutable Vector&lt;UChar&gt; m_normalizedMatch;
 123 
 124 #else
 125 
 126 private:
 127     void append(UChar, bool isCharacterStart);
 128     size_t length() const;
 129 
 130     String m_target;
 131     FindOptions m_options;
 132 
 133     Vector&lt;UChar&gt; m_buffer;
 134     Vector&lt;bool&gt; m_isCharacterStartBuffer;
 135     bool m_isBufferFull;
 136     size_t m_cursor;
 137 
 138 #endif
 139 };
 140 
 141 // --------
 142 
 143 static const unsigned bitsInWord = sizeof(unsigned) * 8;
 144 static const unsigned bitInWordMask = bitsInWord - 1;
 145 
 146 BitStack::BitStack()
 147     : m_size(0)
 148 {
 149 }
 150 
 151 BitStack::~BitStack() = default;
 152 
 153 void BitStack::push(bool bit)
 154 {
 155     unsigned index = m_size / bitsInWord;
 156     unsigned shift = m_size &amp; bitInWordMask;
 157     if (!shift &amp;&amp; index == m_words.size()) {
 158         m_words.grow(index + 1);
 159         m_words[index] = 0;
 160     }
 161     unsigned&amp; word = m_words[index];
 162     unsigned mask = 1U &lt;&lt; shift;
 163     if (bit)
 164         word |= mask;
 165     else
 166         word &amp;= ~mask;
 167     ++m_size;
 168 }
 169 
 170 void BitStack::pop()
 171 {
 172     if (m_size)
 173         --m_size;
 174 }
 175 
 176 bool BitStack::top() const
 177 {
 178     if (!m_size)
 179         return false;
 180     unsigned shift = (m_size - 1) &amp; bitInWordMask;
 181     return m_words.last() &amp; (1U &lt;&lt; shift);
 182 }
 183 
 184 unsigned BitStack::size() const
 185 {
 186     return m_size;
 187 }
 188 
 189 // --------
 190 
 191 // This function is like Range::pastLastNode, except for the fact that it can climb up out of shadow trees.
 192 static Node* nextInPreOrderCrossingShadowBoundaries(Node&amp; rangeEndContainer, int rangeEndOffset)
 193 {
 194     if (rangeEndOffset &gt;= 0 &amp;&amp; !rangeEndContainer.isCharacterDataNode()) {
 195         if (Node* next = rangeEndContainer.traverseToChildAt(rangeEndOffset))
 196             return next;
 197     }
 198     for (Node* node = &amp;rangeEndContainer; node; node = node-&gt;parentOrShadowHostNode()) {
 199         if (Node* next = node-&gt;nextSibling())
 200             return next;
 201     }
 202     return nullptr;
 203 }
 204 
 205 static inline bool fullyClipsContents(Node&amp; node)
 206 {
 207     auto* renderer = node.renderer();
 208     if (!renderer) {
 209         if (!is&lt;Element&gt;(node))
 210             return false;
 211         return !downcast&lt;Element&gt;(node).hasDisplayContents();
 212     }
 213     if (!is&lt;RenderBox&gt;(*renderer))
 214         return false;
 215     auto&amp; box = downcast&lt;RenderBox&gt;(*renderer);
 216     if (!box.hasOverflowClip())
 217         return false;
 218 
 219     // Quirk to keep copy/paste in the CodeMirror editor version used in Jenkins working.
 220     if (is&lt;HTMLTextAreaElement&gt;(node))
 221         return box.size().isEmpty();
 222 
 223     return box.contentSize().isEmpty();
 224 }
 225 
 226 static inline bool ignoresContainerClip(Node&amp; node)
 227 {
 228     auto* renderer = node.renderer();
 229     if (!renderer || renderer-&gt;isTextOrLineBreak())
 230         return false;
 231     return renderer-&gt;style().hasOutOfFlowPosition();
 232 }
 233 
 234 static void pushFullyClippedState(BitStack&amp; stack, Node&amp; node)
 235 {
 236     // Push true if this node full clips its contents, or if a parent already has fully
 237     // clipped and this is not a node that ignores its container&#39;s clip.
 238     stack.push(fullyClipsContents(node) || (stack.top() &amp;&amp; !ignoresContainerClip(node)));
 239 }
 240 
 241 static void setUpFullyClippedStack(BitStack&amp; stack, Node&amp; node)
 242 {
 243     // Put the nodes in a vector so we can iterate in reverse order.
 244     // FIXME: This (and TextIterator in general) should use ComposedTreeIterator.
 245     Vector&lt;Node*, 100&gt; ancestry;
 246     for (Node* parent = node.parentOrShadowHostNode(); parent; parent = parent-&gt;parentOrShadowHostNode())
 247         ancestry.append(parent);
 248 
 249     // Call pushFullyClippedState on each node starting with the earliest ancestor.
 250     size_t size = ancestry.size();
 251     for (size_t i = 0; i &lt; size; ++i)
 252         pushFullyClippedState(stack, *ancestry[size - i - 1]);
 253     pushFullyClippedState(stack, node);
 254 }
 255 
 256 static bool isClippedByFrameAncestor(const Document&amp; document, TextIteratorBehavior behavior)
 257 {
 258     if (!(behavior &amp; TextIteratorClipsToFrameAncestors))
 259         return false;
 260 
 261     for (auto* owner = document.ownerElement(); owner; owner = owner-&gt;document().ownerElement()) {
 262         BitStack ownerClipStack;
 263         setUpFullyClippedStack(ownerClipStack, *owner);
 264         if (ownerClipStack.top())
 265             return true;
 266     }
 267     return false;
 268 }
 269 
 270 // FIXME: editingIgnoresContent and isRendererReplacedElement try to do the same job.
 271 // It&#39;s not good to have both of them.
 272 bool isRendererReplacedElement(RenderObject* renderer)
 273 {
 274     if (!renderer)
 275         return false;
 276 
 277     bool isAttachment = false;
 278 #if ENABLE(ATTACHMENT_ELEMENT)
 279     isAttachment = renderer-&gt;isAttachment();
 280 #endif
 281     if (renderer-&gt;isImage() || renderer-&gt;isWidget() || renderer-&gt;isMedia() || isAttachment)
 282         return true;
 283 
 284     if (is&lt;Element&gt;(renderer-&gt;node())) {
 285         Element&amp; element = downcast&lt;Element&gt;(*renderer-&gt;node());
 286         if (is&lt;HTMLFormControlElement&gt;(element) || is&lt;HTMLLegendElement&gt;(element) || is&lt;HTMLProgressElement&gt;(element) || element.hasTagName(meterTag))
 287             return true;
 288         if (equalLettersIgnoringASCIICase(element.attributeWithoutSynchronization(roleAttr), &quot;img&quot;))
 289             return true;
 290     }
 291 
 292     return false;
 293 }
 294 
 295 // --------
 296 
 297 inline void TextIteratorCopyableText::reset()
 298 {
 299     m_singleCharacter = 0;
 300     m_string = String();
 301     m_offset = 0;
 302     m_length = 0;
 303 }
 304 
 305 inline void TextIteratorCopyableText::set(String&amp;&amp; string)
 306 {
 307     m_singleCharacter = 0;
 308     m_string = WTFMove(string);
 309     m_offset = 0;
 310     m_length = m_string.length();
 311 }
 312 
 313 inline void TextIteratorCopyableText::set(String&amp;&amp; string, unsigned offset, unsigned length)
 314 {
 315     ASSERT(offset &lt; string.length());
 316     ASSERT(length);
 317     ASSERT(length &lt;= string.length() - offset);
 318 
 319     m_singleCharacter = 0;
 320     m_string = WTFMove(string);
 321     m_offset = offset;
 322     m_length = length;
 323 }
 324 
 325 inline void TextIteratorCopyableText::set(UChar singleCharacter)
 326 {
 327     m_singleCharacter = singleCharacter;
 328     m_string = String();
 329     m_offset = 0;
 330     m_length = 0;
 331 }
 332 
 333 void TextIteratorCopyableText::appendToStringBuilder(StringBuilder&amp; builder) const
 334 {
 335     if (m_singleCharacter)
 336         builder.append(m_singleCharacter);
 337     else
 338         builder.appendSubstring(m_string, m_offset, m_length);
 339 }
 340 
 341 // --------
 342 
 343 
 344 TextIterator::TextIterator(Position start, Position end, TextIteratorBehavior behavior)
 345     : m_behavior(behavior)
 346 {
 347     if (start.isNull() || end.isNull())
 348         return;
 349     ASSERT(comparePositions(start, end) &lt;= 0);
 350 
 351     RELEASE_ASSERT(behavior &amp; TextIteratorTraversesFlatTree || start.treeScope() == end.treeScope());
 352 
 353     start.document()-&gt;updateLayoutIgnorePendingStylesheets();
 354 
 355     // FIXME: Use Position / PositionIterator instead to avoid offset computation.
 356     m_startContainer = start.containerNode();
 357     m_startOffset = start.computeOffsetInContainerNode();
 358 
 359     m_endContainer = end.containerNode();
 360     m_endOffset = end.computeOffsetInContainerNode();
 361 
 362     m_node = start.firstNode().get();
 363     if (!m_node)
 364         return;
 365 
 366     init();
 367 }
 368 
 369 TextIterator::TextIterator(const Range* range, TextIteratorBehavior behavior)
 370     : m_behavior(behavior)
 371 {
 372     if (!range)
 373         return;
 374 
 375     range-&gt;ownerDocument().updateLayoutIgnorePendingStylesheets();
 376 
 377     m_startContainer = &amp;range-&gt;startContainer();
 378 
 379     // Callers should be handing us well-formed ranges. If we discover that this isn&#39;t
 380     // the case, we could consider changing this assertion to an early return.
 381     ASSERT(range-&gt;boundaryPointsValid());
 382 
 383     m_startOffset = range-&gt;startOffset();
 384     m_endContainer = &amp;range-&gt;endContainer();
 385     m_endOffset = range-&gt;endOffset();
 386 
 387     m_node = range-&gt;firstNode();
 388     if (!m_node)
 389         return;
 390 
 391     init();
 392 }
 393 
 394 void TextIterator::init()
 395 {
 396     if (isClippedByFrameAncestor(m_node-&gt;document(), m_behavior))
 397         return;
 398 
 399     setUpFullyClippedStack(m_fullyClippedStack, *m_node);
 400 
 401     m_offset = m_node == m_startContainer ? m_startOffset : 0;
 402 
 403     m_pastEndNode = nextInPreOrderCrossingShadowBoundaries(*m_endContainer, m_endOffset);
 404 
 405     m_positionNode = m_node;
 406 
 407     advance();
 408 }
 409 
 410 TextIterator::~TextIterator() = default;
 411 
 412 // FIXME: Use ComposedTreeIterator instead. These functions are more expensive because they might do O(n) work.
 413 static inline Node* firstChild(TextIteratorBehavior options, Node&amp; node)
 414 {
 415     if (UNLIKELY(options &amp; TextIteratorTraversesFlatTree))
 416         return firstChildInComposedTreeIgnoringUserAgentShadow(node);
 417     return node.firstChild();
 418 }
 419 
 420 static inline Node* nextSibling(TextIteratorBehavior options, Node&amp; node)
 421 {
 422     if (UNLIKELY(options &amp; TextIteratorTraversesFlatTree))
 423         return nextSiblingInComposedTreeIgnoringUserAgentShadow(node);
 424     return node.nextSibling();
 425 }
 426 
 427 static inline Node* nextNode(TextIteratorBehavior options, Node&amp; node)
 428 {
 429     if (UNLIKELY(options &amp; TextIteratorTraversesFlatTree))
 430         return nextInComposedTreeIgnoringUserAgentShadow(node);
 431     return NodeTraversal::next(node);
 432 }
 433 
 434 static inline bool isDescendantOf(TextIteratorBehavior options, Node&amp; node, Node&amp; possibleAncestor)
 435 {
 436     if (UNLIKELY(options &amp; TextIteratorTraversesFlatTree))
 437         return node.isDescendantOrShadowDescendantOf(&amp;possibleAncestor);
 438     return node.isDescendantOf(&amp;possibleAncestor);
 439 }
 440 
 441 static inline Node* parentNodeOrShadowHost(TextIteratorBehavior options, Node&amp; node)
 442 {
 443     if (UNLIKELY(options &amp; TextIteratorTraversesFlatTree))
 444         return node.parentInComposedTree();
 445     return node.parentOrShadowHostNode();
 446 }
 447 
 448 static inline bool hasDisplayContents(Node&amp; node)
 449 {
 450     return is&lt;Element&gt;(node) &amp;&amp; downcast&lt;Element&gt;(node).hasDisplayContents();
 451 }
 452 
 453 void TextIterator::advance()
 454 {
 455     ASSERT(!atEnd());
 456 
 457     // reset the run information
 458     m_positionNode = nullptr;
 459     m_copyableText.reset();
 460     m_text = StringView();
 461 
 462     // handle remembered node that needed a newline after the text node&#39;s newline
 463     if (m_nodeForAdditionalNewline) {
 464         // Emit the extra newline, and position it *inside* m_node, after m_node&#39;s
 465         // contents, in case it&#39;s a block, in the same way that we position the first
 466         // newline. The range for the emitted newline should start where the line
 467         // break begins.
 468         // FIXME: It would be cleaner if we emitted two newlines during the last
 469         // iteration, instead of using m_needsAnotherNewline.
 470         emitCharacter(&#39;\n&#39;, *m_nodeForAdditionalNewline-&gt;parentNode(), m_nodeForAdditionalNewline, 1, 1);
 471         m_nodeForAdditionalNewline = nullptr;
 472         return;
 473     }
 474 
 475     if (!m_textBox &amp;&amp; m_remainingTextBox) {
 476         m_textBox = m_remainingTextBox;
<a name="1" id="anc1"></a><span class="line-modified"> 477         m_remainingTextBox = { };</span>
<span class="line-modified"> 478         m_firstLetterText = { };</span>
 479         m_offset = 0;
 480     }
 481     // handle remembered text box
 482     if (m_textBox) {
 483         handleTextBox();
 484         if (m_positionNode)
 485             return;
 486     }
 487 
 488     while (m_node &amp;&amp; m_node != m_pastEndNode) {
 489         // if the range ends at offset 0 of an element, represent the
 490         // position, but not the content, of that element e.g. if the
 491         // node is a blockflow element, emit a newline that
 492         // precedes the element
 493         if (m_node == m_endContainer &amp;&amp; !m_endOffset) {
 494             representNodeOffsetZero();
 495             m_node = nullptr;
 496             return;
 497         }
 498 
 499         auto* renderer = m_node-&gt;renderer();
 500         if (!m_handledNode) {
 501             if (!renderer) {
 502                 m_handledNode = true;
 503                 m_handledChildren = !hasDisplayContents(*m_node);
 504             } else {
 505                 // handle current node according to its type
 506                 if (renderer-&gt;isText() &amp;&amp; m_node-&gt;isTextNode())
 507                     m_handledNode = handleTextNode();
 508                 else if (isRendererReplacedElement(renderer))
 509                     m_handledNode = handleReplacedElement();
 510                 else
 511                     m_handledNode = handleNonTextNode();
 512                 if (m_positionNode)
 513                     return;
 514             }
 515         }
 516 
 517         // find a new current node to handle in depth-first manner,
 518         // calling exitNode() as we come back thru a parent node
 519         Node* next = m_handledChildren ? nullptr : firstChild(m_behavior, *m_node);
 520         m_offset = 0;
 521         if (!next) {
 522             next = nextSibling(m_behavior, *m_node);
 523             if (!next) {
 524                 bool pastEnd = nextNode(m_behavior, *m_node) == m_pastEndNode;
 525                 Node* parentNode = parentNodeOrShadowHost(m_behavior, *m_node);
 526                 while (!next &amp;&amp; parentNode) {
 527                     if ((pastEnd &amp;&amp; parentNode == m_endContainer) || isDescendantOf(m_behavior, *m_endContainer, *parentNode))
 528                         return;
 529                     bool haveRenderer = m_node-&gt;renderer();
 530                     Node* exitedNode = m_node;
 531                     m_node = parentNode;
 532                     m_fullyClippedStack.pop();
 533                     parentNode = parentNodeOrShadowHost(m_behavior, *m_node);
 534                     if (haveRenderer)
 535                         exitNode(exitedNode);
 536                     if (m_positionNode) {
 537                         m_handledNode = true;
 538                         m_handledChildren = true;
 539                         return;
 540                     }
 541                     next = nextSibling(m_behavior, *m_node);
 542                     if (next &amp;&amp; m_node-&gt;renderer())
 543                         exitNode(m_node);
 544                 }
 545             }
 546             m_fullyClippedStack.pop();
 547         }
 548 
 549         // set the new current node
 550         m_node = next;
 551         if (m_node)
 552             pushFullyClippedState(m_fullyClippedStack, *m_node);
 553         m_handledNode = false;
 554         m_handledChildren = false;
 555         m_handledFirstLetter = false;
 556         m_firstLetterText = nullptr;
 557 
 558         // how would this ever be?
 559         if (m_positionNode)
 560             return;
 561     }
 562 }
 563 
 564 static bool hasVisibleTextNode(RenderText&amp; renderer)
 565 {
 566     if (renderer.style().visibility() == Visibility::Visible)
 567         return true;
 568     if (is&lt;RenderTextFragment&gt;(renderer)) {
 569         if (auto firstLetter = downcast&lt;RenderTextFragment&gt;(renderer).firstLetter()) {
 570             if (firstLetter-&gt;style().visibility() == Visibility::Visible)
 571                 return true;
 572         }
 573     }
 574     return false;
 575 }
 576 
<a name="2" id="anc2"></a>


















 577 bool TextIterator::handleTextNode()
 578 {
 579     Text&amp; textNode = downcast&lt;Text&gt;(*m_node);
 580 
 581     if (m_fullyClippedStack.top() &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
 582         return false;
 583 
 584     auto&amp; renderer = *textNode.renderer();
 585     m_lastTextNode = &amp;textNode;
 586     String rendererText = renderer.text();
 587 
 588     // handle pre-formatted text
 589     if (!renderer.style().collapseWhiteSpace()) {
 590         int runStart = m_offset;
 591         if (m_lastTextNodeEndedWithCollapsedSpace &amp;&amp; hasVisibleTextNode(renderer)) {
 592             emitCharacter(&#39; &#39;, textNode, nullptr, runStart, runStart);
 593             return false;
 594         }
 595         if (!m_handledFirstLetter &amp;&amp; is&lt;RenderTextFragment&gt;(renderer) &amp;&amp; !m_offset) {
 596             handleTextNodeFirstLetter(downcast&lt;RenderTextFragment&gt;(renderer));
 597             if (m_firstLetterText) {
 598                 String firstLetter = m_firstLetterText-&gt;text();
 599                 emitText(textNode, *m_firstLetterText, m_offset, m_offset + firstLetter.length());
 600                 m_firstLetterText = nullptr;
<a name="3" id="anc3"></a><span class="line-modified"> 601                 m_textBox = { };</span>
 602                 return false;
 603             }
 604         }
 605         if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
 606             return false;
 607         int rendererTextLength = rendererText.length();
 608         int end = (&amp;textNode == m_endContainer) ? m_endOffset : INT_MAX;
 609         int runEnd = std::min(rendererTextLength, end);
 610 
 611         if (runStart &gt;= runEnd)
 612             return true;
 613 
 614         emitText(textNode, renderer, runStart, runEnd);
 615         return true;
 616     }
 617 
<a name="4" id="anc4"></a><span class="line-modified"> 618     m_textBox = LineLayoutTraversal::firstTextBoxInTextOrderFor(renderer);</span>

























































































 619 
 620     bool shouldHandleFirstLetter = !m_handledFirstLetter &amp;&amp; is&lt;RenderTextFragment&gt;(renderer) &amp;&amp; !m_offset;
 621     if (shouldHandleFirstLetter)
 622         handleTextNodeFirstLetter(downcast&lt;RenderTextFragment&gt;(renderer));
 623 
<a name="5" id="anc5"></a><span class="line-modified"> 624     if (!m_textBox &amp;&amp; rendererText.length() &amp;&amp; !shouldHandleFirstLetter) {</span>
 625         if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
 626             return false;
 627         m_lastTextNodeEndedWithCollapsedSpace = true; // entire block is collapsed space
 628         return true;
 629     }
 630 
<a name="6" id="anc6"></a>










 631     handleTextBox();
 632     return true;
 633 }
 634 
 635 void TextIterator::handleTextBox()
 636 {
 637     Text&amp; textNode = downcast&lt;Text&gt;(*m_node);
 638 
 639     auto&amp; renderer = m_firstLetterText ? *m_firstLetterText : *textNode.renderer();
 640     if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility)) {
<a name="7" id="anc7"></a><span class="line-modified"> 641         m_textBox = { };</span>
 642         return;
 643     }
<a name="8" id="anc8"></a><span class="line-added"> 644 </span>
<span class="line-added"> 645     auto firstTextBox = LineLayoutTraversal::firstTextBoxInTextOrderFor(renderer);</span>
<span class="line-added"> 646 </span>
 647     String rendererText = renderer.text();
 648     unsigned start = m_offset;
 649     unsigned end = (&amp;textNode == m_endContainer) ? static_cast&lt;unsigned&gt;(m_endOffset) : UINT_MAX;
 650     while (m_textBox) {
<a name="9" id="anc9"></a><span class="line-modified"> 651         unsigned textBoxStart = m_textBox-&gt;localStartOffset();</span>
 652         unsigned runStart = std::max(textBoxStart, start);
 653 
 654         // Check for collapsed space at the start of this run.
<a name="10" id="anc10"></a>
 655         bool needSpace = m_lastTextNodeEndedWithCollapsedSpace || (m_textBox == firstTextBox &amp;&amp; textBoxStart == runStart &amp;&amp; runStart);
 656         if (needSpace &amp;&amp; !renderer.style().isCollapsibleWhiteSpace(m_lastCharacter) &amp;&amp; m_lastCharacter) {
 657             if (m_lastTextNode == &amp;textNode &amp;&amp; runStart &amp;&amp; rendererText[runStart - 1] == &#39; &#39;) {
 658                 unsigned spaceRunStart = runStart - 1;
 659                 while (spaceRunStart &amp;&amp; rendererText[spaceRunStart - 1] == &#39; &#39;)
 660                     --spaceRunStart;
 661                 emitText(textNode, renderer, spaceRunStart, spaceRunStart + 1);
 662             } else
 663                 emitCharacter(&#39; &#39;, textNode, nullptr, runStart, runStart);
 664             return;
 665         }
<a name="11" id="anc11"></a><span class="line-modified"> 666         unsigned textBoxEnd = textBoxStart + m_textBox-&gt;length();</span>
 667         unsigned runEnd = std::min(textBoxEnd, end);
 668 
 669         // Determine what the next text box will be, but don&#39;t advance yet
<a name="12" id="anc12"></a><span class="line-modified"> 670         auto nextTextBox = m_textBox;</span>
<span class="line-modified"> 671         nextTextBox.traverseNextInTextOrder();</span>





 672 
 673         if (runStart &lt; runEnd) {
<a name="13" id="anc13"></a><span class="line-modified"> 674             auto isNewlineOrTab = [&amp;](UChar character) {</span>
<span class="line-modified"> 675                 return character == &#39;\n&#39; || character == &#39;\t&#39;;</span>
<span class="line-modified"> 676             };</span>
<span class="line-modified"> 677             // Handle either a single newline or tab character (which becomes a space),</span>
<span class="line-added"> 678             // or a run of characters that does not include newlines or tabs.</span>
<span class="line-added"> 679             // This effectively translates newlines and tabs to spaces without copying the text.</span>
<span class="line-added"> 680             if (isNewlineOrTab(rendererText[runStart])) {</span>
 681                 emitCharacter(&#39; &#39;, textNode, nullptr, runStart, runStart + 1);
 682                 m_offset = runStart + 1;
 683             } else {
<a name="14" id="anc14"></a><span class="line-modified"> 684                 auto subrunEnd = runStart + 1;</span>
<span class="line-modified"> 685                 for (; subrunEnd &lt; runEnd; ++subrunEnd) {</span>
<span class="line-modified"> 686                     if (isNewlineOrTab(rendererText[subrunEnd]))</span>
<span class="line-modified"> 687                         break;</span>
<span class="line-added"> 688                 }</span>
<span class="line-added"> 689                 if (subrunEnd == runEnd &amp;&amp; (m_behavior &amp; TextIteratorBehavesAsIfNodesFollowing)) {</span>
<span class="line-added"> 690                     bool lastSpaceCollapsedByNextNonTextBox = !nextTextBox &amp;&amp; rendererText.length() &gt; subrunEnd &amp;&amp; rendererText[subrunEnd] == &#39; &#39;;</span>
 691                     if (lastSpaceCollapsedByNextNonTextBox)
 692                         ++subrunEnd; // runEnd stopped before last space. Increment by one to restore the space.
 693                 }
 694                 m_offset = subrunEnd;
 695                 emitText(textNode, renderer, runStart, subrunEnd);
 696             }
 697 
 698             // If we are doing a subrun that doesn&#39;t go to the end of the text box,
 699             // come back again to finish handling this text box; don&#39;t advance to the next one.
 700             if (static_cast&lt;unsigned&gt;(m_positionEndOffset) &lt; textBoxEnd)
 701                 return;
 702 
 703             // Advance and return
<a name="15" id="anc15"></a><span class="line-modified"> 704             unsigned nextRunStart = nextTextBox ? nextTextBox-&gt;localStartOffset() : rendererText.length();</span>
 705             if (nextRunStart &gt; runEnd)
 706                 m_lastTextNodeEndedWithCollapsedSpace = true; // collapsed space between runs or at the end
 707             m_textBox = nextTextBox;
<a name="16" id="anc16"></a>

 708             return;
 709         }
 710         // Advance and continue
 711         m_textBox = nextTextBox;
<a name="17" id="anc17"></a>

 712     }
 713     if (!m_textBox &amp;&amp; m_remainingTextBox) {
 714         m_textBox = m_remainingTextBox;
<a name="18" id="anc18"></a><span class="line-modified"> 715         m_remainingTextBox = { };</span>
<span class="line-modified"> 716         m_firstLetterText = { };</span>
 717         m_offset = 0;
 718         handleTextBox();
 719     }
 720 }
 721 
 722 static inline RenderText* firstRenderTextInFirstLetter(RenderBoxModelObject* firstLetter)
 723 {
 724     if (!firstLetter)
 725         return nullptr;
 726 
 727     // FIXME: Should this check descendent objects?
 728     return childrenOfType&lt;RenderText&gt;(*firstLetter).first();
 729 }
 730 
 731 void TextIterator::handleTextNodeFirstLetter(RenderTextFragment&amp; renderer)
 732 {
 733     if (auto* firstLetter = renderer.firstLetter()) {
 734         if (firstLetter-&gt;style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
 735             return;
 736         if (auto* firstLetterText = firstRenderTextInFirstLetter(firstLetter)) {
 737             m_handledFirstLetter = true;
 738             m_remainingTextBox = m_textBox;
<a name="19" id="anc19"></a><span class="line-modified"> 739             m_textBox = LineLayoutTraversal::firstTextBoxInTextOrderFor(*firstLetterText);</span>

 740             m_firstLetterText = firstLetterText;
 741         }
 742     }
 743     m_handledFirstLetter = true;
 744 }
 745 
 746 bool TextIterator::handleReplacedElement()
 747 {
 748     if (m_fullyClippedStack.top())
 749         return false;
 750 
 751     auto&amp; renderer = *m_node-&gt;renderer();
 752     if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
 753         return false;
 754 
 755     if (m_lastTextNodeEndedWithCollapsedSpace) {
 756         emitCharacter(&#39; &#39;, *m_lastTextNode-&gt;parentNode(), m_lastTextNode, 1, 1);
 757         return false;
 758     }
 759 
 760     if ((m_behavior &amp; TextIteratorEntersTextControls) &amp;&amp; is&lt;RenderTextControl&gt;(renderer)) {
 761         if (auto innerTextElement = downcast&lt;RenderTextControl&gt;(renderer).textFormControlElement().innerTextElement()) {
 762             m_node = innerTextElement-&gt;containingShadowRoot();
 763             pushFullyClippedState(m_fullyClippedStack, *m_node);
 764             m_offset = 0;
 765             return false;
 766         }
 767     }
 768 
 769     m_hasEmitted = true;
 770 
 771     if ((m_behavior &amp; TextIteratorEmitsObjectReplacementCharacters) &amp;&amp; renderer.isReplaced()) {
 772         emitCharacter(objectReplacementCharacter, *m_node-&gt;parentNode(), m_node, 0, 1);
 773         // Don&#39;t process subtrees for embedded objects. If the text there is required,
 774         // it must be explicitly asked by specifying a range falling inside its boundaries.
 775         m_handledChildren = true;
 776         return true;
 777     }
 778 
 779     if (m_behavior &amp; TextIteratorEmitsCharactersBetweenAllVisiblePositions) {
 780         // We want replaced elements to behave like punctuation for boundary
 781         // finding, and to simply take up space for the selection preservation
 782         // code in moveParagraphs, so we use a comma.
 783         emitCharacter(&#39;,&#39;, *m_node-&gt;parentNode(), m_node, 0, 1);
 784         return true;
 785     }
 786 
 787     m_positionNode = m_node-&gt;parentNode();
 788     m_positionOffsetBaseNode = m_node;
 789     m_positionStartOffset = 0;
 790     m_positionEndOffset = 1;
 791 
 792     if ((m_behavior &amp; TextIteratorEmitsImageAltText) &amp;&amp; is&lt;RenderImage&gt;(renderer)) {
 793         String altText = downcast&lt;RenderImage&gt;(renderer).altText();
 794         if (unsigned length = altText.length()) {
 795             m_lastCharacter = altText[length - 1];
 796             m_copyableText.set(WTFMove(altText));
 797             m_text = m_copyableText.text();
 798             return true;
 799         }
 800     }
 801 
 802     m_copyableText.reset();
 803     m_text = StringView();
 804     m_lastCharacter = 0;
 805     return true;
 806 }
 807 
 808 static bool shouldEmitTabBeforeNode(Node&amp; node)
 809 {
 810     auto* renderer = node.renderer();
 811 
 812     // Table cells are delimited by tabs.
 813     if (!renderer || !isTableCell(&amp;node))
 814         return false;
 815 
 816     // Want a tab before every cell other than the first one.
 817     RenderTableCell&amp; cell = downcast&lt;RenderTableCell&gt;(*renderer);
 818     RenderTable* table = cell.table();
 819     return table &amp;&amp; (table-&gt;cellBefore(&amp;cell) || table-&gt;cellAbove(&amp;cell));
 820 }
 821 
 822 static bool shouldEmitNewlineForNode(Node* node, bool emitsOriginalText)
 823 {
 824     auto* renderer = node-&gt;renderer();
 825     if (!(renderer ? renderer-&gt;isBR() : node-&gt;hasTagName(brTag)))
 826         return false;
 827     return emitsOriginalText || !(node-&gt;isInShadowTree() &amp;&amp; is&lt;HTMLInputElement&gt;(*node-&gt;shadowHost()));
 828 }
 829 
 830 static bool hasHeaderTag(HTMLElement&amp; element)
 831 {
 832     return element.hasTagName(h1Tag)
 833         || element.hasTagName(h2Tag)
 834         || element.hasTagName(h3Tag)
 835         || element.hasTagName(h4Tag)
 836         || element.hasTagName(h5Tag)
 837         || element.hasTagName(h6Tag);
 838 }
 839 
 840 static bool shouldEmitNewlinesBeforeAndAfterNode(Node&amp; node)
 841 {
 842     // Block flow (versus inline flow) is represented by having
 843     // a newline both before and after the element.
 844     auto* renderer = node.renderer();
 845     if (!renderer) {
 846         if (!is&lt;HTMLElement&gt;(node))
 847             return false;
 848         auto&amp; element = downcast&lt;HTMLElement&gt;(node);
 849         return hasHeaderTag(element)
 850             || element.hasTagName(blockquoteTag)
 851             || element.hasTagName(ddTag)
 852             || element.hasTagName(divTag)
 853             || element.hasTagName(dlTag)
 854             || element.hasTagName(dtTag)
 855             || element.hasTagName(hrTag)
 856             || element.hasTagName(liTag)
 857             || element.hasTagName(listingTag)
 858             || element.hasTagName(olTag)
 859             || element.hasTagName(pTag)
 860             || element.hasTagName(preTag)
 861             || element.hasTagName(trTag)
 862             || element.hasTagName(ulTag);
 863     }
 864 
 865     // Need to make an exception for table cells, because they are blocks, but we
 866     // want them tab-delimited rather than having newlines before and after.
 867     if (isTableCell(&amp;node))
 868         return false;
 869 
 870     // Need to make an exception for table row elements, because they are neither
 871     // &quot;inline&quot; or &quot;RenderBlock&quot;, but we want newlines for them.
 872     if (is&lt;RenderTableRow&gt;(*renderer)) {
 873         RenderTable* table = downcast&lt;RenderTableRow&gt;(*renderer).table();
 874         if (table &amp;&amp; !table-&gt;isInline())
 875             return true;
 876     }
 877 
 878     return !renderer-&gt;isInline()
 879         &amp;&amp; is&lt;RenderBlock&gt;(*renderer)
 880         &amp;&amp; !renderer-&gt;isFloatingOrOutOfFlowPositioned()
 881         &amp;&amp; !renderer-&gt;isBody()
 882         &amp;&amp; !renderer-&gt;isRubyText();
 883 }
 884 
 885 static bool shouldEmitNewlineAfterNode(Node&amp; node, bool emitsCharactersBetweenAllVisiblePositions = false)
 886 {
 887     // FIXME: It should be better but slower to create a VisiblePosition here.
 888     if (!shouldEmitNewlinesBeforeAndAfterNode(node))
 889         return false;
 890 
 891     // Don&#39;t emit a new line at the end of the document unless we&#39;re matching the behavior of VisiblePosition.
 892     if (emitsCharactersBetweenAllVisiblePositions)
 893         return true;
 894     Node* subsequentNode = &amp;node;
 895     while ((subsequentNode = NodeTraversal::nextSkippingChildren(*subsequentNode))) {
 896         if (subsequentNode-&gt;renderer())
 897             return true;
 898     }
 899     return false;
 900 }
 901 
 902 static bool shouldEmitNewlineBeforeNode(Node&amp; node)
 903 {
 904     return shouldEmitNewlinesBeforeAndAfterNode(node);
 905 }
 906 
 907 static bool shouldEmitExtraNewlineForNode(Node&amp; node)
 908 {
 909     // When there is a significant collapsed bottom margin, emit an extra
 910     // newline for a more realistic result. We end up getting the right
 911     // result even without margin collapsing. For example: &lt;div&gt;&lt;p&gt;text&lt;/p&gt;&lt;/div&gt;
 912     // will work right even if both the &lt;div&gt; and the &lt;p&gt; have bottom margins.
 913 
 914     auto* renderer = node.renderer();
 915     if (!is&lt;RenderBox&gt;(renderer))
 916         return false;
 917 
 918     // NOTE: We only do this for a select set of nodes, and WinIE appears not to do this at all.
 919     if (!is&lt;HTMLElement&gt;(node))
 920         return false;
 921 
 922     HTMLElement&amp; element = downcast&lt;HTMLElement&gt;(node);
 923     if (!hasHeaderTag(element) &amp;&amp; !is&lt;HTMLParagraphElement&gt;(element))
 924         return false;
 925 
 926     auto&amp; renderBox = downcast&lt;RenderBox&gt;(*renderer);
 927     if (!renderBox.height())
 928         return false;
 929 
 930     int bottomMargin = renderBox.collapsedMarginAfter();
 931     int fontSize = renderBox.style().fontDescription().computedPixelSize();
 932     return bottomMargin * 2 &gt;= fontSize;
 933 }
 934 
 935 static int collapsedSpaceLength(RenderText&amp; renderer, int textEnd)
 936 {
 937     StringImpl&amp; text = renderer.text();
 938     unsigned length = text.length();
 939     for (unsigned i = textEnd; i &lt; length; ++i) {
 940         if (!renderer.style().isCollapsibleWhiteSpace(text[i]))
 941             return i - textEnd;
 942     }
 943     return length - textEnd;
 944 }
 945 
 946 static int maxOffsetIncludingCollapsedSpaces(Node&amp; node)
 947 {
 948     int offset = caretMaxOffset(node);
 949     if (auto* renderer = node.renderer()) {
 950         if (is&lt;RenderText&gt;(*renderer))
 951             offset += collapsedSpaceLength(downcast&lt;RenderText&gt;(*renderer), offset);
 952     }
 953     return offset;
 954 }
 955 
 956 // Whether or not we should emit a character as we enter m_node (if it&#39;s a container) or as we hit it (if it&#39;s atomic).
 957 bool TextIterator::shouldRepresentNodeOffsetZero()
 958 {
 959     if ((m_behavior &amp; TextIteratorEmitsCharactersBetweenAllVisiblePositions) &amp;&amp; m_node-&gt;renderer() &amp;&amp; m_node-&gt;renderer()-&gt;isTable())
 960         return true;
 961 
 962     // Leave element positioned flush with start of a paragraph
 963     // (e.g. do not insert tab before a table cell at the start of a paragraph)
 964     if (m_lastCharacter == &#39;\n&#39;)
 965         return false;
 966 
 967     // Otherwise, show the position if we have emitted any characters
 968     if (m_hasEmitted)
 969         return true;
 970 
 971     // We&#39;ve not emitted anything yet. Generally, there is no need for any positioning then.
 972     // The only exception is when the element is visually not in the same line as
 973     // the start of the range (e.g. the range starts at the end of the previous paragraph).
 974     // NOTE: Creating VisiblePositions and comparing them is relatively expensive, so we
 975     // make quicker checks to possibly avoid that. Another check that we could make is
 976     // is whether the inline vs block flow changed since the previous visible element.
 977     // I think we&#39;re already in a special enough case that that won&#39;t be needed, tho.
 978 
 979     // No character needed if this is the first node in the range.
 980     if (m_node == m_startContainer)
 981         return false;
 982 
 983     // If we are outside the start container&#39;s subtree, assume we need to emit.
 984     // FIXME: m_startContainer could be an inline block
 985     if (!m_node-&gt;isDescendantOf(m_startContainer))
 986         return true;
 987 
 988     // If we started as m_startContainer offset 0 and the current node is a descendant of
 989     // the start container, we already had enough context to correctly decide whether to
 990     // emit after a preceding block. We chose not to emit (m_hasEmitted is false),
 991     // so don&#39;t second guess that now.
 992     // NOTE: Is this really correct when m_node is not a leftmost descendant? Probably
 993     // immaterial since we likely would have already emitted something by now.
 994     if (m_startOffset == 0)
 995         return false;
 996 
 997     // If this node is unrendered or invisible the VisiblePosition checks below won&#39;t have much meaning.
 998     // Additionally, if the range we are iterating over contains huge sections of unrendered content,
 999     // we would create VisiblePositions on every call to this function without this check.
1000     if (!m_node-&gt;renderer() || m_node-&gt;renderer()-&gt;style().visibility() != Visibility::Visible
1001         || (is&lt;RenderBlockFlow&gt;(*m_node-&gt;renderer()) &amp;&amp; !downcast&lt;RenderBlockFlow&gt;(*m_node-&gt;renderer()).height() &amp;&amp; !is&lt;HTMLBodyElement&gt;(*m_node)))
1002         return false;
1003 
1004     // The startPos.isNotNull() check is needed because the start could be before the body,
1005     // and in that case we&#39;ll get null. We don&#39;t want to put in newlines at the start in that case.
1006     // The currPos.isNotNull() check is needed because positions in non-HTML content
1007     // (like SVG) do not have visible positions, and we don&#39;t want to emit for them either.
1008     VisiblePosition startPos = VisiblePosition(Position(m_startContainer, m_startOffset, Position::PositionIsOffsetInAnchor), DOWNSTREAM);
1009     VisiblePosition currPos = VisiblePosition(positionBeforeNode(m_node), DOWNSTREAM);
1010     return startPos.isNotNull() &amp;&amp; currPos.isNotNull() &amp;&amp; !inSameLine(startPos, currPos);
1011 }
1012 
1013 bool TextIterator::shouldEmitSpaceBeforeAndAfterNode(Node&amp; node)
1014 {
1015     return node.renderer() &amp;&amp; node.renderer()-&gt;isTable() &amp;&amp; (node.renderer()-&gt;isInline() || (m_behavior &amp; TextIteratorEmitsCharactersBetweenAllVisiblePositions));
1016 }
1017 
1018 void TextIterator::representNodeOffsetZero()
1019 {
1020     // Emit a character to show the positioning of m_node.
1021 
1022     // When we haven&#39;t been emitting any characters, shouldRepresentNodeOffsetZero() can
1023     // create VisiblePositions, which is expensive. So, we perform the inexpensive checks
1024     // on m_node to see if it necessitates emitting a character first and will early return
1025     // before encountering shouldRepresentNodeOffsetZero()s worse case behavior.
1026     if (shouldEmitTabBeforeNode(*m_node)) {
1027         if (shouldRepresentNodeOffsetZero())
1028             emitCharacter(&#39;\t&#39;, *m_node-&gt;parentNode(), m_node, 0, 0);
1029     } else if (shouldEmitNewlineBeforeNode(*m_node)) {
1030         if (shouldRepresentNodeOffsetZero())
1031             emitCharacter(&#39;\n&#39;, *m_node-&gt;parentNode(), m_node, 0, 0);
1032     } else if (shouldEmitSpaceBeforeAndAfterNode(*m_node)) {
1033         if (shouldRepresentNodeOffsetZero())
1034             emitCharacter(&#39; &#39;, *m_node-&gt;parentNode(), m_node, 0, 0);
1035     }
1036 }
1037 
1038 bool TextIterator::handleNonTextNode()
1039 {
1040     if (shouldEmitNewlineForNode(m_node, m_behavior &amp; TextIteratorEmitsOriginalText))
1041         emitCharacter(&#39;\n&#39;, *m_node-&gt;parentNode(), m_node, 0, 1);
1042     else if ((m_behavior &amp; TextIteratorEmitsCharactersBetweenAllVisiblePositions) &amp;&amp; m_node-&gt;renderer() &amp;&amp; m_node-&gt;renderer()-&gt;isHR())
1043         emitCharacter(&#39; &#39;, *m_node-&gt;parentNode(), m_node, 0, 1);
1044     else
1045         representNodeOffsetZero();
1046 
1047     return true;
1048 }
1049 
1050 void TextIterator::exitNode(Node* exitedNode)
1051 {
1052     // prevent emitting a newline when exiting a collapsed block at beginning of the range
1053     // FIXME: !m_hasEmitted does not necessarily mean there was a collapsed block... it could
1054     // have been an hr (e.g.). Also, a collapsed block could have height (e.g. a table) and
1055     // therefore look like a blank line.
1056     if (!m_hasEmitted)
1057         return;
1058 
1059     // Emit with a position *inside* m_node, after m_node&#39;s contents, in
1060     // case it is a block, because the run should start where the
1061     // emitted character is positioned visually.
1062     Node* baseNode = exitedNode;
1063     // FIXME: This shouldn&#39;t require the m_lastTextNode to be true, but we can&#39;t change that without making
1064     // the logic in _web_attributedStringFromRange match. We&#39;ll get that for free when we switch to use
1065     // TextIterator in _web_attributedStringFromRange.
1066     // See &lt;rdar://problem/5428427&gt; for an example of how this mismatch will cause problems.
1067     if (m_lastTextNode &amp;&amp; shouldEmitNewlineAfterNode(*m_node, m_behavior &amp; TextIteratorEmitsCharactersBetweenAllVisiblePositions)) {
1068         // use extra newline to represent margin bottom, as needed
1069         bool addNewline = shouldEmitExtraNewlineForNode(*m_node);
1070 
1071         // FIXME: We need to emit a &#39;\n&#39; as we leave an empty block(s) that
1072         // contain a VisiblePosition when doing selection preservation.
1073         if (m_lastCharacter != &#39;\n&#39;) {
1074             // insert a newline with a position following this block&#39;s contents.
1075             emitCharacter(&#39;\n&#39;, *baseNode-&gt;parentNode(), baseNode, 1, 1);
1076             // remember whether to later add a newline for the current node
1077             ASSERT(!m_nodeForAdditionalNewline);
1078             if (addNewline)
1079                 m_nodeForAdditionalNewline = baseNode;
1080         } else if (addNewline)
1081             // insert a newline with a position following this block&#39;s contents.
1082             emitCharacter(&#39;\n&#39;, *baseNode-&gt;parentNode(), baseNode, 1, 1);
1083     }
1084 
1085     // If nothing was emitted, see if we need to emit a space.
1086     if (!m_positionNode &amp;&amp; shouldEmitSpaceBeforeAndAfterNode(*m_node))
1087         emitCharacter(&#39; &#39;, *baseNode-&gt;parentNode(), baseNode, 1, 1);
1088 }
1089 
1090 void TextIterator::emitCharacter(UChar character, Node&amp; characterNode, Node* offsetBaseNode, int textStartOffset, int textEndOffset)
1091 {
1092     m_hasEmitted = true;
1093 
1094     // remember information with which to construct the TextIterator::range()
1095     m_positionNode = &amp;characterNode;
1096     m_positionOffsetBaseNode = offsetBaseNode;
1097     m_positionStartOffset = textStartOffset;
1098     m_positionEndOffset = textEndOffset;
1099 
1100     m_copyableText.set(character);
1101     m_text = m_copyableText.text();
1102     m_lastCharacter = character;
1103     m_lastTextNodeEndedWithCollapsedSpace = false;
<a name="20" id="anc20"></a>
1104 }
1105 
1106 void TextIterator::emitText(Text&amp; textNode, RenderText&amp; renderer, int textStartOffset, int textEndOffset)
1107 {
1108     ASSERT(textStartOffset &gt;= 0);
1109     ASSERT(textEndOffset &gt;= 0);
1110     ASSERT(textStartOffset &lt;= textEndOffset);
1111 
1112     // FIXME: This probably yields the wrong offsets when text-transform: lowercase turns a single character into two characters.
1113     String string = (m_behavior &amp; TextIteratorEmitsOriginalText) ? renderer.originalText()
1114         : ((m_behavior &amp; TextIteratorEmitsTextsWithoutTranscoding) ? renderer.textWithoutConvertingBackslashToYenSymbol() : renderer.text());
1115 
1116     ASSERT(string.length() &gt;= static_cast&lt;unsigned&gt;(textEndOffset));
1117 
1118     m_positionNode = &amp;textNode;
1119     m_positionOffsetBaseNode = nullptr;
1120     m_positionStartOffset = textStartOffset;
1121     m_positionEndOffset = textEndOffset;
1122 
1123     m_lastCharacter = string[textEndOffset - 1];
1124     m_copyableText.set(WTFMove(string), textStartOffset, textEndOffset - textStartOffset);
1125     m_text = m_copyableText.text();
1126 
1127     m_lastTextNodeEndedWithCollapsedSpace = false;
<a name="21" id="anc21"></a>
1128     m_hasEmitted = true;
1129 }
1130 
1131 Ref&lt;Range&gt; TextIterator::range() const
1132 {
1133     ASSERT(!atEnd());
1134 
1135     // use the current run information, if we have it
1136     if (m_positionOffsetBaseNode) {
1137         unsigned index = m_positionOffsetBaseNode-&gt;computeNodeIndex();
1138         m_positionStartOffset += index;
1139         m_positionEndOffset += index;
1140         m_positionOffsetBaseNode = nullptr;
1141     }
1142     return Range::create(m_positionNode-&gt;document(), m_positionNode, m_positionStartOffset, m_positionNode, m_positionEndOffset);
1143 }
1144 
1145 Node* TextIterator::node() const
1146 {
1147     Ref&lt;Range&gt; textRange = range();
1148 
1149     Node&amp; node = textRange-&gt;startContainer();
1150     if (node.isCharacterDataNode())
1151         return &amp;node;
1152 
1153     return node.traverseToChildAt(textRange-&gt;startOffset());
1154 }
1155 
1156 // --------
1157 
1158 SimplifiedBackwardsTextIterator::SimplifiedBackwardsTextIterator(const Range&amp; range)
1159 {
1160     range.ownerDocument().updateLayoutIgnorePendingStylesheets();
1161 
1162     Node* startNode = &amp;range.startContainer();
1163     Node* endNode = &amp;range.endContainer();
1164     int startOffset = range.startOffset();
1165     int endOffset = range.endOffset();
1166 
1167     if (!startNode-&gt;isCharacterDataNode()) {
1168         if (startOffset &gt;= 0 &amp;&amp; startOffset &lt; static_cast&lt;int&gt;(startNode-&gt;countChildNodes())) {
1169             startNode = startNode-&gt;traverseToChildAt(startOffset);
1170             startOffset = 0;
1171         }
1172     }
1173     if (!endNode-&gt;isCharacterDataNode()) {
1174         if (endOffset &gt; 0 &amp;&amp; endOffset &lt;= static_cast&lt;int&gt;(endNode-&gt;countChildNodes())) {
1175             endNode = endNode-&gt;traverseToChildAt(endOffset - 1);
1176             endOffset = lastOffsetInNode(endNode);
1177         }
1178     }
1179 
1180     m_node = endNode;
1181     setUpFullyClippedStack(m_fullyClippedStack, *m_node);
1182     m_offset = endOffset;
1183     m_handledNode = false;
1184     m_handledChildren = endOffset == 0;
1185 
1186     m_startContainer = startNode;
1187     m_startOffset = startOffset;
1188     m_endContainer = endNode;
1189     m_endOffset = endOffset;
1190 
1191     m_positionNode = endNode;
1192 
1193     m_lastTextNode = nullptr;
1194     m_lastCharacter = &#39;\n&#39;;
1195 
1196     m_havePassedStartContainer = false;
1197 
1198     advance();
1199 }
1200 
1201 void SimplifiedBackwardsTextIterator::advance()
1202 {
1203     ASSERT(!atEnd());
1204 
1205     m_positionNode = nullptr;
1206     m_copyableText.reset();
1207     m_text = StringView();
1208 
1209     while (m_node &amp;&amp; !m_havePassedStartContainer) {
1210         // Don&#39;t handle node if we start iterating at [node, 0].
1211         if (!m_handledNode &amp;&amp; !(m_node == m_endContainer &amp;&amp; !m_endOffset)) {
1212             auto* renderer = m_node-&gt;renderer();
1213             if (renderer &amp;&amp; renderer-&gt;isText() &amp;&amp; m_node-&gt;isTextNode()) {
1214                 if (renderer-&gt;style().visibility() == Visibility::Visible &amp;&amp; m_offset &gt; 0)
1215                     m_handledNode = handleTextNode();
1216             } else if (renderer &amp;&amp; (renderer-&gt;isImage() || renderer-&gt;isWidget())) {
1217                 if (renderer-&gt;style().visibility() == Visibility::Visible &amp;&amp; m_offset &gt; 0)
1218                     m_handledNode = handleReplacedElement();
1219             } else
1220                 m_handledNode = handleNonTextNode();
1221             if (m_positionNode)
1222                 return;
1223         }
1224 
1225         if (!m_handledChildren &amp;&amp; m_node-&gt;hasChildNodes()) {
1226             m_node = m_node-&gt;lastChild();
1227             pushFullyClippedState(m_fullyClippedStack, *m_node);
1228         } else {
1229             // Exit empty containers as we pass over them or containers
1230             // where [container, 0] is where we started iterating.
1231             if (!m_handledNode &amp;&amp; canHaveChildrenForEditing(*m_node) &amp;&amp; m_node-&gt;parentNode() &amp;&amp; (!m_node-&gt;lastChild() || (m_node == m_endContainer &amp;&amp; !m_endOffset))) {
1232                 exitNode();
1233                 if (m_positionNode) {
1234                     m_handledNode = true;
1235                     m_handledChildren = true;
1236                     return;
1237                 }
1238             }
1239 
1240             // Exit all other containers.
1241             while (!m_node-&gt;previousSibling()) {
1242                 if (!advanceRespectingRange(m_node-&gt;parentOrShadowHostNode()))
1243                     break;
1244                 m_fullyClippedStack.pop();
1245                 exitNode();
1246                 if (m_positionNode) {
1247                     m_handledNode = true;
1248                     m_handledChildren = true;
1249                     return;
1250                 }
1251             }
1252 
1253             m_fullyClippedStack.pop();
1254             if (advanceRespectingRange(m_node-&gt;previousSibling()))
1255                 pushFullyClippedState(m_fullyClippedStack, *m_node);
1256             else
1257                 m_node = nullptr;
1258         }
1259 
1260         // For the purpose of word boundary detection,
1261         // we should iterate all visible text and trailing (collapsed) whitespaces.
1262         m_offset = m_node ? maxOffsetIncludingCollapsedSpaces(*m_node) : 0;
1263         m_handledNode = false;
1264         m_handledChildren = false;
1265 
1266         if (m_positionNode)
1267             return;
1268     }
1269 }
1270 
1271 bool SimplifiedBackwardsTextIterator::handleTextNode()
1272 {
1273     Text&amp; textNode = downcast&lt;Text&gt;(*m_node);
1274 
1275     m_lastTextNode = &amp;textNode;
1276 
1277     int startOffset;
1278     int offsetInNode;
1279     RenderText* renderer = handleFirstLetter(startOffset, offsetInNode);
1280     if (!renderer)
1281         return true;
1282 
1283     String text = renderer-&gt;text();
1284     if (!renderer-&gt;hasRenderedText() &amp;&amp; text.length())
1285         return true;
1286 
1287     if (startOffset + offsetInNode == m_offset) {
1288         ASSERT(!m_shouldHandleFirstLetter);
1289         return true;
1290     }
1291 
1292     m_positionEndOffset = m_offset;
1293     m_offset = startOffset + offsetInNode;
1294     m_positionNode = m_node;
1295     m_positionStartOffset = m_offset;
1296 
1297     ASSERT(m_positionStartOffset &lt; m_positionEndOffset);
1298     ASSERT(m_positionStartOffset - offsetInNode &gt;= 0);
1299     ASSERT(m_positionEndOffset - offsetInNode &gt; 0);
1300     ASSERT(m_positionEndOffset - offsetInNode &lt;= static_cast&lt;int&gt;(text.length()));
1301 
1302     m_lastCharacter = text[m_positionEndOffset - offsetInNode - 1];
1303     m_copyableText.set(WTFMove(text), m_positionStartOffset - offsetInNode, m_positionEndOffset - m_positionStartOffset);
1304     m_text = m_copyableText.text();
1305 
1306     return !m_shouldHandleFirstLetter;
1307 }
1308 
1309 RenderText* SimplifiedBackwardsTextIterator::handleFirstLetter(int&amp; startOffset, int&amp; offsetInNode)
1310 {
1311     RenderText&amp; renderer = downcast&lt;RenderText&gt;(*m_node-&gt;renderer());
1312     startOffset = (m_node == m_startContainer) ? m_startOffset : 0;
1313 
1314     if (!is&lt;RenderTextFragment&gt;(renderer)) {
1315         offsetInNode = 0;
1316         return &amp;renderer;
1317     }
1318 
1319     RenderTextFragment&amp; fragment = downcast&lt;RenderTextFragment&gt;(renderer);
1320     int offsetAfterFirstLetter = fragment.start();
1321     if (startOffset &gt;= offsetAfterFirstLetter) {
1322         ASSERT(!m_shouldHandleFirstLetter);
1323         offsetInNode = offsetAfterFirstLetter;
1324         return &amp;renderer;
1325     }
1326 
1327     if (!m_shouldHandleFirstLetter &amp;&amp; startOffset + offsetAfterFirstLetter &lt; m_offset) {
1328         m_shouldHandleFirstLetter = true;
1329         offsetInNode = offsetAfterFirstLetter;
1330         return &amp;renderer;
1331     }
1332 
1333     m_shouldHandleFirstLetter = false;
1334     offsetInNode = 0;
1335     RenderText* firstLetterRenderer = firstRenderTextInFirstLetter(fragment.firstLetter());
1336 
1337     m_offset = firstLetterRenderer-&gt;caretMaxOffset();
1338     m_offset += collapsedSpaceLength(*firstLetterRenderer, m_offset);
1339 
1340     return firstLetterRenderer;
1341 }
1342 
1343 bool SimplifiedBackwardsTextIterator::handleReplacedElement()
1344 {
1345     unsigned index = m_node-&gt;computeNodeIndex();
1346     // We want replaced elements to behave like punctuation for boundary
1347     // finding, and to simply take up space for the selection preservation
1348     // code in moveParagraphs, so we use a comma. Unconditionally emit
1349     // here because this iterator is only used for boundary finding.
1350     emitCharacter(&#39;,&#39;, *m_node-&gt;parentNode(), index, index + 1);
1351     return true;
1352 }
1353 
1354 bool SimplifiedBackwardsTextIterator::handleNonTextNode()
1355 {
1356     // We can use a linefeed in place of a tab because this simple iterator is only used to
1357     // find boundaries, not actual content. A linefeed breaks words, sentences, and paragraphs.
1358     if (shouldEmitNewlineForNode(m_node, m_behavior &amp; TextIteratorEmitsOriginalText) || shouldEmitNewlineAfterNode(*m_node) || shouldEmitTabBeforeNode(*m_node)) {
1359         if (m_lastCharacter != &#39;\n&#39;) {
1360             // Corresponds to the same check in TextIterator::exitNode.
1361             unsigned index = m_node-&gt;computeNodeIndex();
1362             // The start of this emitted range is wrong. Ensuring correctness would require
1363             // VisiblePositions and so would be slow. previousBoundary expects this.
1364             emitCharacter(&#39;\n&#39;, *m_node-&gt;parentNode(), index + 1, index + 1);
1365         }
1366     }
1367     return true;
1368 }
1369 
1370 void SimplifiedBackwardsTextIterator::exitNode()
1371 {
1372     if (shouldEmitNewlineForNode(m_node, m_behavior &amp; TextIteratorEmitsOriginalText) || shouldEmitNewlineBeforeNode(*m_node) || shouldEmitTabBeforeNode(*m_node)) {
1373         // The start of this emitted range is wrong. Ensuring correctness would require
1374         // VisiblePositions and so would be slow. previousBoundary expects this.
1375         emitCharacter(&#39;\n&#39;, *m_node, 0, 0);
1376     }
1377 }
1378 
1379 void SimplifiedBackwardsTextIterator::emitCharacter(UChar c, Node&amp; node, int startOffset, int endOffset)
1380 {
1381     m_positionNode = &amp;node;
1382     m_positionStartOffset = startOffset;
1383     m_positionEndOffset = endOffset;
1384     m_copyableText.set(c);
1385     m_text = m_copyableText.text();
1386     m_lastCharacter = c;
1387 }
1388 
1389 bool SimplifiedBackwardsTextIterator::advanceRespectingRange(Node* next)
1390 {
1391     if (!next)
1392         return false;
1393     m_havePassedStartContainer |= m_node == m_startContainer;
1394     if (m_havePassedStartContainer)
1395         return false;
1396     m_node = next;
1397     return true;
1398 }
1399 
1400 Ref&lt;Range&gt; SimplifiedBackwardsTextIterator::range() const
1401 {
1402     ASSERT(!atEnd());
1403 
1404     return Range::create(m_positionNode-&gt;document(), m_positionNode, m_positionStartOffset, m_positionNode, m_positionEndOffset);
1405 }
1406 
1407 // --------
1408 
1409 CharacterIterator::CharacterIterator(const Range&amp; range, TextIteratorBehavior behavior)
1410     : m_underlyingIterator(&amp;range, behavior)
1411 {
1412     while (!atEnd() &amp;&amp; !m_underlyingIterator.text().length())
1413         m_underlyingIterator.advance();
1414 }
1415 
1416 CharacterIterator::CharacterIterator(Position start, Position end, TextIteratorBehavior behavior)
1417     : m_underlyingIterator(start, end, behavior)
1418 {
1419     while (!atEnd() &amp;&amp; !m_underlyingIterator.text().length())
1420         m_underlyingIterator.advance();
1421 }
1422 
1423 Ref&lt;Range&gt; CharacterIterator::range() const
1424 {
1425     Ref&lt;Range&gt; range = m_underlyingIterator.range();
1426     if (!m_underlyingIterator.atEnd()) {
1427         if (m_underlyingIterator.text().length() &lt;= 1) {
1428             ASSERT(m_runOffset == 0);
1429         } else {
1430             Node&amp; node = range-&gt;startContainer();
1431             ASSERT(&amp;node == &amp;range-&gt;endContainer());
1432             int offset = range-&gt;startOffset() + m_runOffset;
1433             range-&gt;setStart(node, offset);
1434             range-&gt;setEnd(node, offset + 1);
1435         }
1436     }
1437     return range;
1438 }
1439 
1440 void CharacterIterator::advance(int count)
1441 {
1442     if (count &lt;= 0) {
1443         ASSERT(count == 0);
1444         return;
1445     }
1446 
1447     m_atBreak = false;
1448 
1449     // easy if there is enough left in the current m_underlyingIterator run
1450     int remaining = m_underlyingIterator.text().length() - m_runOffset;
1451     if (count &lt; remaining) {
1452         m_runOffset += count;
1453         m_offset += count;
1454         return;
1455     }
1456 
1457     // exhaust the current m_underlyingIterator run
1458     count -= remaining;
1459     m_offset += remaining;
1460 
1461     // move to a subsequent m_underlyingIterator run
1462     for (m_underlyingIterator.advance(); !atEnd(); m_underlyingIterator.advance()) {
1463         int runLength = m_underlyingIterator.text().length();
1464         if (!runLength)
1465             m_atBreak = true;
1466         else {
1467             // see whether this is m_underlyingIterator to use
1468             if (count &lt; runLength) {
1469                 m_runOffset = count;
1470                 m_offset += count;
1471                 return;
1472             }
1473 
1474             // exhaust this m_underlyingIterator run
1475             count -= runLength;
1476             m_offset += runLength;
1477         }
1478     }
1479 
1480     // ran to the end of the m_underlyingIterator... no more runs left
1481     m_atBreak = true;
1482     m_runOffset = 0;
1483 }
1484 
1485 static Ref&lt;Range&gt; characterSubrange(Document&amp; document, CharacterIterator&amp; it, int offset, int length)
1486 {
1487     it.advance(offset);
1488     if (it.atEnd())
1489         return Range::create(document);
1490 
1491     Ref&lt;Range&gt; start = it.range();
1492 
1493     if (length &gt; 1)
1494         it.advance(length - 1);
1495     if (it.atEnd())
1496         return Range::create(document);
1497 
1498     Ref&lt;Range&gt; end = it.range();
1499 
1500     return Range::create(document, &amp;start-&gt;startContainer(), start-&gt;startOffset(), &amp;end-&gt;endContainer(), end-&gt;endOffset());
1501 }
1502 
1503 BackwardsCharacterIterator::BackwardsCharacterIterator(const Range&amp; range)
1504     : m_underlyingIterator(range)
1505     , m_offset(0)
1506     , m_runOffset(0)
1507     , m_atBreak(true)
1508 {
1509     while (!atEnd() &amp;&amp; !m_underlyingIterator.text().length())
1510         m_underlyingIterator.advance();
1511 }
1512 
1513 Ref&lt;Range&gt; BackwardsCharacterIterator::range() const
1514 {
1515     Ref&lt;Range&gt; r = m_underlyingIterator.range();
1516     if (!m_underlyingIterator.atEnd()) {
1517         if (m_underlyingIterator.text().length() &lt;= 1)
1518             ASSERT(m_runOffset == 0);
1519         else {
1520             Node&amp; node = r-&gt;startContainer();
1521             ASSERT(&amp;node == &amp;r-&gt;endContainer());
1522             int offset = r-&gt;endOffset() - m_runOffset;
1523             r-&gt;setStart(node, offset - 1);
1524             r-&gt;setEnd(node, offset);
1525         }
1526     }
1527     return r;
1528 }
1529 
1530 void BackwardsCharacterIterator::advance(int count)
1531 {
1532     if (count &lt;= 0) {
1533         ASSERT(!count);
1534         return;
1535     }
1536 
1537     m_atBreak = false;
1538 
1539     int remaining = m_underlyingIterator.text().length() - m_runOffset;
1540     if (count &lt; remaining) {
1541         m_runOffset += count;
1542         m_offset += count;
1543         return;
1544     }
1545 
1546     count -= remaining;
1547     m_offset += remaining;
1548 
1549     for (m_underlyingIterator.advance(); !atEnd(); m_underlyingIterator.advance()) {
1550         int runLength = m_underlyingIterator.text().length();
1551         if (runLength == 0)
1552             m_atBreak = true;
1553         else {
1554             if (count &lt; runLength) {
1555                 m_runOffset = count;
1556                 m_offset += count;
1557                 return;
1558             }
1559 
1560             count -= runLength;
1561             m_offset += runLength;
1562         }
1563     }
1564 
1565     m_atBreak = true;
1566     m_runOffset = 0;
1567 }
1568 
1569 // --------
1570 
1571 WordAwareIterator::WordAwareIterator(const Range&amp; range)
1572     : m_underlyingIterator(&amp;range)
1573     , m_didLookAhead(true) // so we consider the first chunk from the text iterator
1574 {
1575     advance(); // get in position over the first chunk of text
1576 }
1577 
1578 // We&#39;re always in one of these modes:
1579 // - The current chunk in the text iterator is our current chunk
1580 //      (typically its a piece of whitespace, or text that ended with whitespace)
1581 // - The previous chunk in the text iterator is our current chunk
1582 //      (we looked ahead to the next chunk and found a word boundary)
1583 // - We built up our own chunk of text from many chunks from the text iterator
1584 
1585 // FIXME: Performance could be bad for huge spans next to each other that don&#39;t fall on word boundaries.
1586 
1587 void WordAwareIterator::advance()
1588 {
1589     m_previousText.reset();
1590     m_buffer.clear();
1591 
1592     // If last time we did a look-ahead, start with that looked-ahead chunk now
1593     if (!m_didLookAhead) {
1594         ASSERT(!m_underlyingIterator.atEnd());
1595         m_underlyingIterator.advance();
1596     }
1597     m_didLookAhead = false;
1598 
1599     // Go to next non-empty chunk
1600     while (!m_underlyingIterator.atEnd() &amp;&amp; !m_underlyingIterator.text().length())
1601         m_underlyingIterator.advance();
1602     if (m_underlyingIterator.atEnd())
1603         return;
1604 
1605     while (1) {
1606         // If this chunk ends in whitespace we can just use it as our chunk.
1607         if (isSpaceOrNewline(m_underlyingIterator.text()[m_underlyingIterator.text().length() - 1]))
1608             return;
1609 
1610         // If this is the first chunk that failed, save it in previousText before look ahead
1611         if (m_buffer.isEmpty())
1612             m_previousText = m_underlyingIterator.copyableText();
1613 
1614         // Look ahead to next chunk. If it is whitespace or a break, we can use the previous stuff
1615         m_underlyingIterator.advance();
1616         if (m_underlyingIterator.atEnd() || !m_underlyingIterator.text().length() || isSpaceOrNewline(m_underlyingIterator.text()[0])) {
1617             m_didLookAhead = true;
1618             return;
1619         }
1620 
1621         if (m_buffer.isEmpty()) {
1622             // Start gobbling chunks until we get to a suitable stopping point
1623             append(m_buffer, m_previousText.text());
1624             m_previousText.reset();
1625         }
1626         append(m_buffer, m_underlyingIterator.text());
1627     }
1628 }
1629 
1630 StringView WordAwareIterator::text() const
1631 {
1632     if (!m_buffer.isEmpty())
1633         return StringView(m_buffer.data(), m_buffer.size());
1634     if (m_previousText.text().length())
1635         return m_previousText.text();
1636     return m_underlyingIterator.text();
1637 }
1638 
1639 // --------
1640 
1641 static inline UChar foldQuoteMark(UChar c)
1642 {
1643     switch (c) {
1644         case hebrewPunctuationGershayim:
1645         case leftDoubleQuotationMark:
1646         case leftLowDoubleQuotationMark:
1647         case rightDoubleQuotationMark:
1648             return &#39;&quot;&#39;;
1649         case hebrewPunctuationGeresh:
1650         case leftSingleQuotationMark:
1651         case leftLowSingleQuotationMark:
1652         case rightSingleQuotationMark:
1653             return &#39;\&#39;&#39;;
1654         default:
1655             return c;
1656     }
1657 }
1658 
1659 // FIXME: We&#39;d like to tailor the searcher to fold quote marks for us instead
1660 // of doing it in a separate replacement pass here, but ICU doesn&#39;t offer a way
1661 // to add tailoring on top of the locale-specific tailoring as of this writing.
1662 String foldQuoteMarks(const String&amp; stringToFold)
1663 {
1664     String result(stringToFold);
1665     result.replace(hebrewPunctuationGeresh, &#39;\&#39;&#39;);
1666     result.replace(hebrewPunctuationGershayim, &#39;&quot;&#39;);
1667     result.replace(leftDoubleQuotationMark, &#39;&quot;&#39;);
1668     result.replace(leftLowDoubleQuotationMark, &#39;&quot;&#39;);
1669     result.replace(leftSingleQuotationMark, &#39;\&#39;&#39;);
1670     result.replace(leftLowSingleQuotationMark, &#39;\&#39;&#39;);
1671     result.replace(rightDoubleQuotationMark, &#39;&quot;&#39;);
1672     result.replace(rightSingleQuotationMark, &#39;\&#39;&#39;);
1673 
1674     return result;
1675 }
1676 
1677 #if !UCONFIG_NO_COLLATION
1678 
1679 const size_t minimumSearchBufferSize = 8192;
1680 
1681 #ifndef NDEBUG
1682 static bool searcherInUse;
1683 #endif
1684 
1685 static UStringSearch* createSearcher()
1686 {
1687     // Provide a non-empty pattern and non-empty text so usearch_open will not fail,
1688     // but it doesn&#39;t matter exactly what it is, since we don&#39;t perform any searches
1689     // without setting both the pattern and the text.
1690     UErrorCode status = U_ZERO_ERROR;
1691     String searchCollatorName = makeString(currentSearchLocaleID(), &quot;@collation=search&quot;);
1692     UStringSearch* searcher = usearch_open(&amp;newlineCharacter, 1, &amp;newlineCharacter, 1, searchCollatorName.utf8().data(), 0, &amp;status);
1693     ASSERT(status == U_ZERO_ERROR || status == U_USING_FALLBACK_WARNING || status == U_USING_DEFAULT_WARNING);
1694     return searcher;
1695 }
1696 
1697 static UStringSearch* searcher()
1698 {
1699     static UStringSearch* searcher = createSearcher();
1700     return searcher;
1701 }
1702 
1703 static inline void lockSearcher()
1704 {
1705 #ifndef NDEBUG
1706     ASSERT(!searcherInUse);
1707     searcherInUse = true;
1708 #endif
1709 }
1710 
1711 static inline void unlockSearcher()
1712 {
1713 #ifndef NDEBUG
1714     ASSERT(searcherInUse);
1715     searcherInUse = false;
1716 #endif
1717 }
1718 
1719 // ICU&#39;s search ignores the distinction between small kana letters and ones
1720 // that are not small, and also characters that differ only in the voicing
1721 // marks when considering only primary collation strength differences.
1722 // This is not helpful for end users, since these differences make words
1723 // distinct, so for our purposes we need these to be considered.
1724 // The Unicode folks do not think the collation algorithm should be
1725 // changed. To work around this, we would like to tailor the ICU searcher,
1726 // but we can&#39;t get that to work yet. So instead, we check for cases where
1727 // these differences occur, and skip those matches.
1728 
1729 // We refer to the above technique as the &quot;kana workaround&quot;. The next few
1730 // functions are helper functinos for the kana workaround.
1731 
1732 static inline bool isKanaLetter(UChar character)
1733 {
1734     // Hiragana letters.
1735     if (character &gt;= 0x3041 &amp;&amp; character &lt;= 0x3096)
1736         return true;
1737 
1738     // Katakana letters.
1739     if (character &gt;= 0x30A1 &amp;&amp; character &lt;= 0x30FA)
1740         return true;
1741     if (character &gt;= 0x31F0 &amp;&amp; character &lt;= 0x31FF)
1742         return true;
1743 
1744     // Halfwidth katakana letters.
1745     if (character &gt;= 0xFF66 &amp;&amp; character &lt;= 0xFF9D &amp;&amp; character != 0xFF70)
1746         return true;
1747 
1748     return false;
1749 }
1750 
1751 static inline bool isSmallKanaLetter(UChar character)
1752 {
1753     ASSERT(isKanaLetter(character));
1754 
1755     switch (character) {
1756     case 0x3041: // HIRAGANA LETTER SMALL A
1757     case 0x3043: // HIRAGANA LETTER SMALL I
1758     case 0x3045: // HIRAGANA LETTER SMALL U
1759     case 0x3047: // HIRAGANA LETTER SMALL E
1760     case 0x3049: // HIRAGANA LETTER SMALL O
1761     case 0x3063: // HIRAGANA LETTER SMALL TU
1762     case 0x3083: // HIRAGANA LETTER SMALL YA
1763     case 0x3085: // HIRAGANA LETTER SMALL YU
1764     case 0x3087: // HIRAGANA LETTER SMALL YO
1765     case 0x308E: // HIRAGANA LETTER SMALL WA
1766     case 0x3095: // HIRAGANA LETTER SMALL KA
1767     case 0x3096: // HIRAGANA LETTER SMALL KE
1768     case 0x30A1: // KATAKANA LETTER SMALL A
1769     case 0x30A3: // KATAKANA LETTER SMALL I
1770     case 0x30A5: // KATAKANA LETTER SMALL U
1771     case 0x30A7: // KATAKANA LETTER SMALL E
1772     case 0x30A9: // KATAKANA LETTER SMALL O
1773     case 0x30C3: // KATAKANA LETTER SMALL TU
1774     case 0x30E3: // KATAKANA LETTER SMALL YA
1775     case 0x30E5: // KATAKANA LETTER SMALL YU
1776     case 0x30E7: // KATAKANA LETTER SMALL YO
1777     case 0x30EE: // KATAKANA LETTER SMALL WA
1778     case 0x30F5: // KATAKANA LETTER SMALL KA
1779     case 0x30F6: // KATAKANA LETTER SMALL KE
1780     case 0x31F0: // KATAKANA LETTER SMALL KU
1781     case 0x31F1: // KATAKANA LETTER SMALL SI
1782     case 0x31F2: // KATAKANA LETTER SMALL SU
1783     case 0x31F3: // KATAKANA LETTER SMALL TO
1784     case 0x31F4: // KATAKANA LETTER SMALL NU
1785     case 0x31F5: // KATAKANA LETTER SMALL HA
1786     case 0x31F6: // KATAKANA LETTER SMALL HI
1787     case 0x31F7: // KATAKANA LETTER SMALL HU
1788     case 0x31F8: // KATAKANA LETTER SMALL HE
1789     case 0x31F9: // KATAKANA LETTER SMALL HO
1790     case 0x31FA: // KATAKANA LETTER SMALL MU
1791     case 0x31FB: // KATAKANA LETTER SMALL RA
1792     case 0x31FC: // KATAKANA LETTER SMALL RI
1793     case 0x31FD: // KATAKANA LETTER SMALL RU
1794     case 0x31FE: // KATAKANA LETTER SMALL RE
1795     case 0x31FF: // KATAKANA LETTER SMALL RO
1796     case 0xFF67: // HALFWIDTH KATAKANA LETTER SMALL A
1797     case 0xFF68: // HALFWIDTH KATAKANA LETTER SMALL I
1798     case 0xFF69: // HALFWIDTH KATAKANA LETTER SMALL U
1799     case 0xFF6A: // HALFWIDTH KATAKANA LETTER SMALL E
1800     case 0xFF6B: // HALFWIDTH KATAKANA LETTER SMALL O
1801     case 0xFF6C: // HALFWIDTH KATAKANA LETTER SMALL YA
1802     case 0xFF6D: // HALFWIDTH KATAKANA LETTER SMALL YU
1803     case 0xFF6E: // HALFWIDTH KATAKANA LETTER SMALL YO
1804     case 0xFF6F: // HALFWIDTH KATAKANA LETTER SMALL TU
1805         return true;
1806     }
1807     return false;
1808 }
1809 
1810 enum VoicedSoundMarkType { NoVoicedSoundMark, VoicedSoundMark, SemiVoicedSoundMark };
1811 
1812 static inline VoicedSoundMarkType composedVoicedSoundMark(UChar character)
1813 {
1814     ASSERT(isKanaLetter(character));
1815 
1816     switch (character) {
1817     case 0x304C: // HIRAGANA LETTER GA
1818     case 0x304E: // HIRAGANA LETTER GI
1819     case 0x3050: // HIRAGANA LETTER GU
1820     case 0x3052: // HIRAGANA LETTER GE
1821     case 0x3054: // HIRAGANA LETTER GO
1822     case 0x3056: // HIRAGANA LETTER ZA
1823     case 0x3058: // HIRAGANA LETTER ZI
1824     case 0x305A: // HIRAGANA LETTER ZU
1825     case 0x305C: // HIRAGANA LETTER ZE
1826     case 0x305E: // HIRAGANA LETTER ZO
1827     case 0x3060: // HIRAGANA LETTER DA
1828     case 0x3062: // HIRAGANA LETTER DI
1829     case 0x3065: // HIRAGANA LETTER DU
1830     case 0x3067: // HIRAGANA LETTER DE
1831     case 0x3069: // HIRAGANA LETTER DO
1832     case 0x3070: // HIRAGANA LETTER BA
1833     case 0x3073: // HIRAGANA LETTER BI
1834     case 0x3076: // HIRAGANA LETTER BU
1835     case 0x3079: // HIRAGANA LETTER BE
1836     case 0x307C: // HIRAGANA LETTER BO
1837     case 0x3094: // HIRAGANA LETTER VU
1838     case 0x30AC: // KATAKANA LETTER GA
1839     case 0x30AE: // KATAKANA LETTER GI
1840     case 0x30B0: // KATAKANA LETTER GU
1841     case 0x30B2: // KATAKANA LETTER GE
1842     case 0x30B4: // KATAKANA LETTER GO
1843     case 0x30B6: // KATAKANA LETTER ZA
1844     case 0x30B8: // KATAKANA LETTER ZI
1845     case 0x30BA: // KATAKANA LETTER ZU
1846     case 0x30BC: // KATAKANA LETTER ZE
1847     case 0x30BE: // KATAKANA LETTER ZO
1848     case 0x30C0: // KATAKANA LETTER DA
1849     case 0x30C2: // KATAKANA LETTER DI
1850     case 0x30C5: // KATAKANA LETTER DU
1851     case 0x30C7: // KATAKANA LETTER DE
1852     case 0x30C9: // KATAKANA LETTER DO
1853     case 0x30D0: // KATAKANA LETTER BA
1854     case 0x30D3: // KATAKANA LETTER BI
1855     case 0x30D6: // KATAKANA LETTER BU
1856     case 0x30D9: // KATAKANA LETTER BE
1857     case 0x30DC: // KATAKANA LETTER BO
1858     case 0x30F4: // KATAKANA LETTER VU
1859     case 0x30F7: // KATAKANA LETTER VA
1860     case 0x30F8: // KATAKANA LETTER VI
1861     case 0x30F9: // KATAKANA LETTER VE
1862     case 0x30FA: // KATAKANA LETTER VO
1863         return VoicedSoundMark;
1864     case 0x3071: // HIRAGANA LETTER PA
1865     case 0x3074: // HIRAGANA LETTER PI
1866     case 0x3077: // HIRAGANA LETTER PU
1867     case 0x307A: // HIRAGANA LETTER PE
1868     case 0x307D: // HIRAGANA LETTER PO
1869     case 0x30D1: // KATAKANA LETTER PA
1870     case 0x30D4: // KATAKANA LETTER PI
1871     case 0x30D7: // KATAKANA LETTER PU
1872     case 0x30DA: // KATAKANA LETTER PE
1873     case 0x30DD: // KATAKANA LETTER PO
1874         return SemiVoicedSoundMark;
1875     }
1876     return NoVoicedSoundMark;
1877 }
1878 
1879 static inline bool isCombiningVoicedSoundMark(UChar character)
1880 {
1881     switch (character) {
1882     case 0x3099: // COMBINING KATAKANA-HIRAGANA VOICED SOUND MARK
1883     case 0x309A: // COMBINING KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK
1884         return true;
1885     }
1886     return false;
1887 }
1888 
1889 static inline bool containsKanaLetters(const String&amp; pattern)
1890 {
1891     if (pattern.is8Bit())
1892         return false;
1893     const UChar* characters = pattern.characters16();
1894     unsigned length = pattern.length();
1895     for (unsigned i = 0; i &lt; length; ++i) {
1896         if (isKanaLetter(characters[i]))
1897             return true;
1898     }
1899     return false;
1900 }
1901 
1902 static void normalizeCharacters(const UChar* characters, unsigned length, Vector&lt;UChar&gt;&amp; buffer)
1903 {
1904     UErrorCode status = U_ZERO_ERROR;
1905     const UNormalizer2* normalizer = unorm2_getNFCInstance(&amp;status);
1906     ASSERT(U_SUCCESS(status));
1907 
1908     buffer.resize(length);
1909 
1910     auto normalizedLength = unorm2_normalize(normalizer, characters, length, buffer.data(), length, &amp;status);
1911     ASSERT(U_SUCCESS(status) || status == U_BUFFER_OVERFLOW_ERROR);
1912 
1913     buffer.resize(normalizedLength);
1914 
1915     if (U_SUCCESS(status))
1916         return;
1917 
1918     status = U_ZERO_ERROR;
1919     unorm2_normalize(normalizer, characters, length, buffer.data(), length, &amp;status);
1920     ASSERT(U_SUCCESS(status));
1921 }
1922 
1923 static bool isNonLatin1Separator(UChar32 character)
1924 {
1925     ASSERT_ARG(character, !isLatin1(character));
1926 
1927     return U_GET_GC_MASK(character) &amp; (U_GC_S_MASK | U_GC_P_MASK | U_GC_Z_MASK | U_GC_CF_MASK);
1928 }
1929 
1930 static inline bool isSeparator(UChar32 character)
1931 {
1932     static const bool latin1SeparatorTable[256] = {
1933         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
1934         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
1935         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // space ! &quot; # $ % &amp; &#39; ( ) * + , - . /
1936         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, //                         : ; &lt; = &gt; ?
1937         1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //   @
1938         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, //                         [ \ ] ^ _
1939         1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //   `
1940         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, //                           { | } ~
1941         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
1942         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
1943         0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
1944         1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
1945         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
1946         0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
1947         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
1948         0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0
1949     };
1950 
1951     if (isLatin1(character))
1952         return latin1SeparatorTable[character];
1953 
1954     return isNonLatin1Separator(character);
1955 }
1956 
1957 inline SearchBuffer::SearchBuffer(const String&amp; target, FindOptions options)
1958     : m_target(foldQuoteMarks(target))
1959     , m_targetCharacters(StringView(m_target).upconvertedCharacters())
1960     , m_options(options)
1961     , m_prefixLength(0)
1962     , m_atBreak(true)
1963     , m_needsMoreContext(options.contains(AtWordStarts))
1964     , m_targetRequiresKanaWorkaround(containsKanaLetters(m_target))
1965 {
1966     ASSERT(!m_target.isEmpty());
1967 
1968     size_t targetLength = m_target.length();
1969     m_buffer.reserveInitialCapacity(std::max(targetLength * 8, minimumSearchBufferSize));
1970     m_overlap = m_buffer.capacity() / 4;
1971 
1972     if (m_options.contains(AtWordStarts) &amp;&amp; targetLength) {
1973         UChar32 targetFirstCharacter;
1974         U16_GET(m_target, 0, 0u, targetLength, targetFirstCharacter);
1975         // Characters in the separator category never really occur at the beginning of a word,
1976         // so if the target begins with such a character, we just ignore the AtWordStart option.
1977         if (isSeparator(targetFirstCharacter)) {
1978             m_options.remove(AtWordStarts);
1979             m_needsMoreContext = false;
1980         }
1981     }
1982 
1983     // Grab the single global searcher.
1984     // If we ever have a reason to do more than once search buffer at once, we&#39;ll have
1985     // to move to multiple searchers.
1986     lockSearcher();
1987 
1988     UStringSearch* searcher = WebCore::searcher();
1989     UCollator* collator = usearch_getCollator(searcher);
1990 
1991     UCollationStrength strength;
1992     USearchAttributeValue comparator;
1993     if (m_options.contains(CaseInsensitive)) {
1994         // Without loss of generality, have &#39;e&#39; match {&#39;e&#39;, &#39;E&#39;, &#39;é&#39;, &#39;É&#39;} and &#39;é&#39; match {&#39;é&#39;, &#39;É&#39;}.
1995         strength = UCOL_SECONDARY;
1996         comparator = USEARCH_PATTERN_BASE_WEIGHT_IS_WILDCARD;
1997     } else {
1998         // Without loss of generality, have &#39;e&#39; match {&#39;e&#39;} and &#39;é&#39; match {&#39;é&#39;}.
1999         strength = UCOL_TERTIARY;
2000         comparator = USEARCH_STANDARD_ELEMENT_COMPARISON;
2001     }
2002     if (ucol_getStrength(collator) != strength) {
2003         ucol_setStrength(collator, strength);
2004         usearch_reset(searcher);
2005     }
2006 
2007     UErrorCode status = U_ZERO_ERROR;
2008     usearch_setAttribute(searcher, USEARCH_ELEMENT_COMPARISON, comparator, &amp;status);
2009     ASSERT(status == U_ZERO_ERROR);
2010 
2011     usearch_setPattern(searcher, m_targetCharacters, targetLength, &amp;status);
2012     ASSERT(status == U_ZERO_ERROR);
2013 
2014     // The kana workaround requires a normalized copy of the target string.
2015     if (m_targetRequiresKanaWorkaround)
2016         normalizeCharacters(m_targetCharacters, targetLength, m_normalizedTarget);
2017 }
2018 
2019 inline SearchBuffer::~SearchBuffer()
2020 {
2021     // Leave the static object pointing to a valid string.
2022     UErrorCode status = U_ZERO_ERROR;
2023     usearch_setPattern(WebCore::searcher(), &amp;newlineCharacter, 1, &amp;status);
2024     ASSERT(status == U_ZERO_ERROR);
2025     usearch_setText(WebCore::searcher(), &amp;newlineCharacter, 1, &amp;status);
2026     ASSERT(status == U_ZERO_ERROR);
2027 
2028     unlockSearcher();
2029 }
2030 
2031 inline size_t SearchBuffer::append(StringView text)
2032 {
2033     ASSERT(text.length());
2034 
2035     if (m_atBreak) {
2036         m_buffer.shrink(0);
2037         m_prefixLength = 0;
2038         m_atBreak = false;
2039     } else if (m_buffer.size() == m_buffer.capacity()) {
2040         memcpy(m_buffer.data(), m_buffer.data() + m_buffer.size() - m_overlap, m_overlap * sizeof(UChar));
2041         m_prefixLength -= std::min(m_prefixLength, m_buffer.size() - m_overlap);
2042         m_buffer.shrink(m_overlap);
2043     }
2044 
2045     size_t oldLength = m_buffer.size();
2046     size_t usableLength = std::min&lt;size_t&gt;(m_buffer.capacity() - oldLength, text.length());
2047     ASSERT(usableLength);
2048     m_buffer.grow(oldLength + usableLength);
2049     for (unsigned i = 0; i &lt; usableLength; ++i)
2050         m_buffer[oldLength + i] = foldQuoteMark(text[i]);
2051     return usableLength;
2052 }
2053 
2054 inline bool SearchBuffer::needsMoreContext() const
2055 {
2056     return m_needsMoreContext;
2057 }
2058 
2059 inline void SearchBuffer::prependContext(StringView text)
2060 {
2061     ASSERT(m_needsMoreContext);
2062     ASSERT(m_prefixLength == m_buffer.size());
2063 
2064     if (!text.length())
2065         return;
2066 
2067     m_atBreak = false;
2068 
2069     size_t wordBoundaryContextStart = text.length();
2070     if (wordBoundaryContextStart) {
2071         U16_BACK_1(text, 0, wordBoundaryContextStart);
2072         wordBoundaryContextStart = startOfLastWordBoundaryContext(text.substring(0, wordBoundaryContextStart));
2073     }
2074 
2075     size_t usableLength = std::min(m_buffer.capacity() - m_prefixLength, text.length() - wordBoundaryContextStart);
2076     WTF::append(m_buffer, text.substring(text.length() - usableLength, usableLength));
2077     m_prefixLength += usableLength;
2078 
2079     if (wordBoundaryContextStart || m_prefixLength == m_buffer.capacity())
2080         m_needsMoreContext = false;
2081 }
2082 
2083 inline bool SearchBuffer::atBreak() const
2084 {
2085     return m_atBreak;
2086 }
2087 
2088 inline void SearchBuffer::reachedBreak()
2089 {
2090     m_atBreak = true;
2091 }
2092 
2093 inline bool SearchBuffer::isBadMatch(const UChar* match, size_t matchLength) const
2094 {
2095     // This function implements the kana workaround. If usearch treats
2096     // it as a match, but we do not want to, then it&#39;s a &quot;bad match&quot;.
2097     if (!m_targetRequiresKanaWorkaround)
2098         return false;
2099 
2100     // Normalize into a match buffer. We reuse a single buffer rather than
2101     // creating a new one each time.
2102     normalizeCharacters(match, matchLength, m_normalizedMatch);
2103 
2104     const UChar* a = m_normalizedTarget.begin();
2105     const UChar* aEnd = m_normalizedTarget.end();
2106 
2107     const UChar* b = m_normalizedMatch.begin();
2108     const UChar* bEnd = m_normalizedMatch.end();
2109 
2110     while (true) {
2111         // Skip runs of non-kana-letter characters. This is necessary so we can
2112         // correctly handle strings where the target and match have different-length
2113         // runs of characters that match, while still double checking the correctness
2114         // of matches of kana letters with other kana letters.
2115         while (a != aEnd &amp;&amp; !isKanaLetter(*a))
2116             ++a;
2117         while (b != bEnd &amp;&amp; !isKanaLetter(*b))
2118             ++b;
2119 
2120         // If we reached the end of either the target or the match, we should have
2121         // reached the end of both; both should have the same number of kana letters.
2122         if (a == aEnd || b == bEnd) {
2123             ASSERT(a == aEnd);
2124             ASSERT(b == bEnd);
2125             return false;
2126         }
2127 
2128         // Check for differences in the kana letter character itself.
2129         if (isSmallKanaLetter(*a) != isSmallKanaLetter(*b))
2130             return true;
2131         if (composedVoicedSoundMark(*a) != composedVoicedSoundMark(*b))
2132             return true;
2133         ++a;
2134         ++b;
2135 
2136         // Check for differences in combining voiced sound marks found after the letter.
2137         while (1) {
2138             if (!(a != aEnd &amp;&amp; isCombiningVoicedSoundMark(*a))) {
2139                 if (b != bEnd &amp;&amp; isCombiningVoicedSoundMark(*b))
2140                     return true;
2141                 break;
2142             }
2143             if (!(b != bEnd &amp;&amp; isCombiningVoicedSoundMark(*b)))
2144                 return true;
2145             if (*a != *b)
2146                 return true;
2147             ++a;
2148             ++b;
2149         }
2150     }
2151 }
2152 
2153 inline bool SearchBuffer::isWordEndMatch(size_t start, size_t length) const
2154 {
2155     ASSERT(length);
2156     ASSERT(m_options.contains(AtWordEnds));
2157 
2158     int endWord;
2159     // Start searching at the end of matched search, so that multiple word matches succeed.
2160     findEndWordBoundary(StringView(m_buffer.data(), m_buffer.size()), start + length - 1, &amp;endWord);
2161     return static_cast&lt;size_t&gt;(endWord) == (start + length);
2162 }
2163 
2164 inline bool SearchBuffer::isWordStartMatch(size_t start, size_t length) const
2165 {
2166     ASSERT(m_options.contains(AtWordStarts));
2167 
2168     if (!start)
2169         return true;
2170 
2171     int size = m_buffer.size();
2172     int offset = start;
2173     UChar32 firstCharacter;
2174     U16_GET(m_buffer.data(), 0, offset, size, firstCharacter);
2175 
2176     if (m_options.contains(TreatMedialCapitalAsWordStart)) {
2177         UChar32 previousCharacter;
2178         U16_PREV(m_buffer.data(), 0, offset, previousCharacter);
2179 
2180         if (isSeparator(firstCharacter)) {
2181             // The start of a separator run is a word start (&quot;.org&quot; in &quot;webkit.org&quot;).
2182             if (!isSeparator(previousCharacter))
2183                 return true;
2184         } else if (isASCIIUpper(firstCharacter)) {
2185             // The start of an uppercase run is a word start (&quot;Kit&quot; in &quot;WebKit&quot;).
2186             if (!isASCIIUpper(previousCharacter))
2187                 return true;
2188             // The last character of an uppercase run followed by a non-separator, non-digit
2189             // is a word start (&quot;Request&quot; in &quot;XMLHTTPRequest&quot;).
2190             offset = start;
2191             U16_FWD_1(m_buffer.data(), offset, size);
2192             UChar32 nextCharacter = 0;
2193             if (offset &lt; size)
2194                 U16_GET(m_buffer.data(), 0, offset, size, nextCharacter);
2195             if (!isASCIIUpper(nextCharacter) &amp;&amp; !isASCIIDigit(nextCharacter) &amp;&amp; !isSeparator(nextCharacter))
2196                 return true;
2197         } else if (isASCIIDigit(firstCharacter)) {
2198             // The start of a digit run is a word start (&quot;2&quot; in &quot;WebKit2&quot;).
2199             if (!isASCIIDigit(previousCharacter))
2200                 return true;
2201         } else if (isSeparator(previousCharacter) || isASCIIDigit(previousCharacter)) {
2202             // The start of a non-separator, non-uppercase, non-digit run is a word start,
2203             // except after an uppercase. (&quot;org&quot; in &quot;webkit.org&quot;, but not &quot;ore&quot; in &quot;WebCore&quot;).
2204             return true;
2205         }
2206     }
2207 
2208     // Chinese and Japanese lack word boundary marks, and there is no clear agreement on what constitutes
2209     // a word, so treat the position before any CJK character as a word start.
2210     if (FontCascade::isCJKIdeographOrSymbol(firstCharacter))
2211         return true;
2212 
2213     size_t wordBreakSearchStart = start + length;
2214     while (wordBreakSearchStart &gt; start)
2215         wordBreakSearchStart = findNextWordFromIndex(StringView(m_buffer.data(), m_buffer.size()), wordBreakSearchStart, false /* backwards */);
2216     return wordBreakSearchStart == start;
2217 }
2218 
2219 inline size_t SearchBuffer::search(size_t&amp; start)
2220 {
2221     size_t size = m_buffer.size();
2222     if (m_atBreak) {
2223         if (!size)
2224             return 0;
2225     } else {
2226         if (size != m_buffer.capacity())
2227             return 0;
2228     }
2229 
2230     UStringSearch* searcher = WebCore::searcher();
2231 
2232     UErrorCode status = U_ZERO_ERROR;
2233     usearch_setText(searcher, m_buffer.data(), size, &amp;status);
2234     ASSERT(status == U_ZERO_ERROR);
2235 
2236     usearch_setOffset(searcher, m_prefixLength, &amp;status);
2237     ASSERT(status == U_ZERO_ERROR);
2238 
2239     int matchStart = usearch_next(searcher, &amp;status);
2240     ASSERT(status == U_ZERO_ERROR);
2241 
2242 nextMatch:
2243     if (!(matchStart &gt;= 0 &amp;&amp; static_cast&lt;size_t&gt;(matchStart) &lt; size)) {
2244         ASSERT(matchStart == USEARCH_DONE);
2245         return 0;
2246     }
2247 
2248     // Matches that start in the overlap area are only tentative.
2249     // The same match may appear later, matching more characters,
2250     // possibly including a combining character that&#39;s not yet in the buffer.
2251     if (!m_atBreak &amp;&amp; static_cast&lt;size_t&gt;(matchStart) &gt;= size - m_overlap) {
2252         size_t overlap = m_overlap;
2253         if (m_options.contains(AtWordStarts)) {
2254             // Ensure that there is sufficient context before matchStart the next time around for
2255             // determining if it is at a word boundary.
2256             unsigned wordBoundaryContextStart = matchStart;
2257             U16_BACK_1(m_buffer.data(), 0, wordBoundaryContextStart);
2258             wordBoundaryContextStart = startOfLastWordBoundaryContext(StringView(m_buffer.data(), wordBoundaryContextStart));
2259             overlap = std::min(size - 1, std::max(overlap, size - wordBoundaryContextStart));
2260         }
2261         memcpy(m_buffer.data(), m_buffer.data() + size - overlap, overlap * sizeof(UChar));
2262         m_prefixLength -= std::min(m_prefixLength, size - overlap);
2263         m_buffer.shrink(overlap);
2264         return 0;
2265     }
2266 
2267     size_t matchedLength = usearch_getMatchedLength(searcher);
2268     ASSERT_WITH_SECURITY_IMPLICATION(matchStart + matchedLength &lt;= size);
2269 
2270     // If this match is &quot;bad&quot;, move on to the next match.
2271     if (isBadMatch(m_buffer.data() + matchStart, matchedLength)
2272         || (m_options.contains(AtWordStarts) &amp;&amp; !isWordStartMatch(matchStart, matchedLength))
2273         || (m_options.contains(AtWordEnds) &amp;&amp; !isWordEndMatch(matchStart, matchedLength))) {
2274         matchStart = usearch_next(searcher, &amp;status);
2275         ASSERT(status == U_ZERO_ERROR);
2276         goto nextMatch;
2277     }
2278 
2279     size_t newSize = size - (matchStart + 1);
2280     memmove(m_buffer.data(), m_buffer.data() + matchStart + 1, newSize * sizeof(UChar));
2281     m_prefixLength -= std::min&lt;size_t&gt;(m_prefixLength, matchStart + 1);
2282     m_buffer.shrink(newSize);
2283 
2284     start = size - matchStart;
2285     return matchedLength;
2286 }
2287 
2288 #else
2289 
2290 inline SearchBuffer::SearchBuffer(const String&amp; target, FindOptions options)
2291     : m_target(foldQuoteMarks(options &amp; CaseInsensitive ? target.foldCase() : target))
2292     , m_options(options)
2293     , m_buffer(m_target.length())
2294     , m_isCharacterStartBuffer(m_target.length())
2295     , m_isBufferFull(false)
2296     , m_cursor(0)
2297 {
2298     ASSERT(!m_target.isEmpty());
2299     m_target.replace(noBreakSpace, &#39; &#39;);
2300 }
2301 
2302 inline SearchBuffer::~SearchBuffer() = default;
2303 
2304 inline void SearchBuffer::reachedBreak()
2305 {
2306     m_cursor = 0;
2307     m_isBufferFull = false;
2308 }
2309 
2310 inline bool SearchBuffer::atBreak() const
2311 {
2312     return !m_cursor &amp;&amp; !m_isBufferFull;
2313 }
2314 
2315 inline void SearchBuffer::append(UChar c, bool isStart)
2316 {
2317     m_buffer[m_cursor] = c == noBreakSpace ? &#39; &#39; : foldQuoteMark(c);
2318     m_isCharacterStartBuffer[m_cursor] = isStart;
2319     if (++m_cursor == m_target.length()) {
2320         m_cursor = 0;
2321         m_isBufferFull = true;
2322     }
2323 }
2324 
2325 inline size_t SearchBuffer::append(const UChar* characters, size_t length)
2326 {
2327     ASSERT(length);
2328     if (!(m_options &amp; CaseInsensitive)) {
2329         append(characters[0], true);
2330         return 1;
2331     }
2332     const int maxFoldedCharacters = 16; // sensible maximum is 3, this should be more than enough
2333     UChar foldedCharacters[maxFoldedCharacters];
2334     UErrorCode status = U_ZERO_ERROR;
2335     int numFoldedCharacters = u_strFoldCase(foldedCharacters, maxFoldedCharacters, characters, 1, U_FOLD_CASE_DEFAULT, &amp;status);
2336     ASSERT(U_SUCCESS(status));
2337     ASSERT(numFoldedCharacters);
2338     ASSERT(numFoldedCharacters &lt;= maxFoldedCharacters);
2339     if (U_SUCCESS(status) &amp;&amp; numFoldedCharacters) {
2340         numFoldedCharacters = std::min(numFoldedCharacters, maxFoldedCharacters);
2341         append(foldedCharacters[0], true);
2342         for (int i = 1; i &lt; numFoldedCharacters; ++i)
2343             append(foldedCharacters[i], false);
2344     }
2345     return 1;
2346 }
2347 
2348 inline bool SearchBuffer::needsMoreContext() const
2349 {
2350     return false;
2351 }
2352 
2353 void SearchBuffer::prependContext(const UChar*, size_t)
2354 {
2355     ASSERT_NOT_REACHED();
2356 }
2357 
2358 inline size_t SearchBuffer::search(size_t&amp; start)
2359 {
2360     if (!m_isBufferFull)
2361         return 0;
2362     if (!m_isCharacterStartBuffer[m_cursor])
2363         return 0;
2364 
2365     size_t tailSpace = m_target.length() - m_cursor;
2366     if (memcmp(&amp;m_buffer[m_cursor], m_target.characters(), tailSpace * sizeof(UChar)) != 0)
2367         return 0;
2368     if (memcmp(&amp;m_buffer[0], m_target.characters() + tailSpace, m_cursor * sizeof(UChar)) != 0)
2369         return 0;
2370 
2371     start = length();
2372 
2373     // Now that we&#39;ve found a match once, we don&#39;t want to find it again, because those
2374     // are the SearchBuffer semantics, allowing for a buffer where you append more than one
2375     // character at a time. To do this we take advantage of m_isCharacterStartBuffer, but if
2376     // we want to get rid of that in the future we could track this with a separate boolean
2377     // or even move the characters to the start of the buffer and set m_isBufferFull to false.
2378     m_isCharacterStartBuffer[m_cursor] = false;
2379 
2380     return start;
2381 }
2382 
2383 // Returns the number of characters that were appended to the buffer (what we are searching in).
2384 // That&#39;s not necessarily the same length as the passed-in target string, because case folding
2385 // can make two strings match even though they&#39;re not the same length.
2386 size_t SearchBuffer::length() const
2387 {
2388     size_t bufferSize = m_target.length();
2389     size_t length = 0;
2390     for (size_t i = 0; i &lt; bufferSize; ++i)
2391         length += m_isCharacterStartBuffer[i];
2392     return length;
2393 }
2394 
2395 #endif
2396 
2397 // --------
2398 
2399 int TextIterator::rangeLength(const Range* range, bool forSelectionPreservation)
2400 {
2401     unsigned length = 0;
2402     for (TextIterator it(range, forSelectionPreservation ? TextIteratorEmitsCharactersBetweenAllVisiblePositions : TextIteratorDefaultBehavior); !it.atEnd(); it.advance())
2403         length += it.text().length();
2404     return length;
2405 }
2406 
2407 Ref&lt;Range&gt; TextIterator::subrange(Range&amp; entireRange, int characterOffset, int characterCount)
2408 {
2409     CharacterIterator entireRangeIterator(entireRange);
2410     return characterSubrange(entireRange.ownerDocument(), entireRangeIterator, characterOffset, characterCount);
2411 }
2412 
2413 static inline bool isInsideReplacedElement(TextIterator&amp; iterator)
2414 {
2415     ASSERT(!iterator.atEnd());
2416     ASSERT(iterator.text().length() == 1);
2417     Node* node = iterator.node();
2418     return node &amp;&amp; isRendererReplacedElement(node-&gt;renderer());
2419 }
2420 
2421 RefPtr&lt;Range&gt; TextIterator::rangeFromLocationAndLength(ContainerNode* scope, int rangeLocation, int rangeLength, bool forSelectionPreservation)
2422 {
2423     Ref&lt;Range&gt; resultRange = scope-&gt;document().createRange();
2424 
2425     int docTextPosition = 0;
2426     int rangeEnd = rangeLocation + rangeLength;
2427     bool startRangeFound = false;
2428 
2429     Ref&lt;Range&gt; textRunRange = rangeOfContents(*scope);
2430 
2431     TextIterator it(textRunRange.ptr(), forSelectionPreservation ? TextIteratorEmitsCharactersBetweenAllVisiblePositions : TextIteratorDefaultBehavior);
2432 
2433     // FIXME: the atEnd() check shouldn&#39;t be necessary, workaround for &lt;http://bugs.webkit.org/show_bug.cgi?id=6289&gt;.
2434     if (!rangeLocation &amp;&amp; !rangeLength &amp;&amp; it.atEnd()) {
2435         resultRange-&gt;setStart(textRunRange-&gt;startContainer(), 0);
2436         resultRange-&gt;setEnd(textRunRange-&gt;startContainer(), 0);
2437         return resultRange;
2438     }
2439 
2440     for (; !it.atEnd(); it.advance()) {
2441         int length = it.text().length();
2442         textRunRange = it.range();
2443 
2444         bool foundStart = rangeLocation &gt;= docTextPosition &amp;&amp; rangeLocation &lt;= docTextPosition + length;
2445         bool foundEnd = rangeEnd &gt;= docTextPosition &amp;&amp; rangeEnd &lt;= docTextPosition + length;
2446 
2447         if (foundEnd) {
2448             // FIXME: This is a workaround for the fact that the end of a run is often at the wrong
2449             // position for emitted &#39;\n&#39;s or if the renderer of the current node is a replaced element.
2450             if (length == 1 &amp;&amp; (it.text()[0] == &#39;\n&#39; || isInsideReplacedElement(it))) {
2451                 it.advance();
2452                 if (!it.atEnd()) {
2453                     Ref&lt;Range&gt; range = it.range();
2454                     textRunRange-&gt;setEnd(range-&gt;startContainer(), range-&gt;startOffset());
2455                 } else {
2456                     Position runStart = textRunRange-&gt;startPosition();
2457                     Position runEnd = VisiblePosition(runStart).next().deepEquivalent();
2458                     if (runEnd.isNotNull())
2459                         textRunRange-&gt;setEnd(*runEnd.containerNode(), runEnd.computeOffsetInContainerNode());
2460                 }
2461             }
2462         }
2463 
2464         if (foundStart) {
2465             startRangeFound = true;
2466             if (textRunRange-&gt;startContainer().isTextNode()) {
2467                 int offset = rangeLocation - docTextPosition;
2468                 resultRange-&gt;setStart(textRunRange-&gt;startContainer(), offset + textRunRange-&gt;startOffset());
2469             } else {
2470                 if (rangeLocation == docTextPosition)
2471                     resultRange-&gt;setStart(textRunRange-&gt;startContainer(), textRunRange-&gt;startOffset());
2472                 else
2473                     resultRange-&gt;setStart(textRunRange-&gt;endContainer(), textRunRange-&gt;endOffset());
2474             }
2475         }
2476 
2477         if (foundEnd) {
2478             if (textRunRange-&gt;startContainer().isTextNode()) {
2479                 int offset = rangeEnd - docTextPosition;
2480                 resultRange-&gt;setEnd(textRunRange-&gt;startContainer(), offset + textRunRange-&gt;startOffset());
2481             } else {
2482                 if (rangeEnd == docTextPosition)
2483                     resultRange-&gt;setEnd(textRunRange-&gt;startContainer(), textRunRange-&gt;startOffset());
2484                 else
2485                     resultRange-&gt;setEnd(textRunRange-&gt;endContainer(), textRunRange-&gt;endOffset());
2486             }
2487             docTextPosition += length;
2488             break;
2489         }
2490 
2491         docTextPosition += length;
2492     }
2493 
2494     if (!startRangeFound)
2495         return nullptr;
2496 
2497     if (rangeLength &amp;&amp; rangeEnd &gt; docTextPosition) // rangeEnd is out of bounds
2498         resultRange-&gt;setEnd(textRunRange-&gt;endContainer(), textRunRange-&gt;endOffset());
2499 
2500     return resultRange;
2501 }
2502 
2503 bool TextIterator::getLocationAndLengthFromRange(Node* scope, const Range* range, size_t&amp; location, size_t&amp; length)
2504 {
2505     location = notFound;
2506     length = 0;
2507 
2508     // The critical assumption is that this only gets called with ranges that
2509     // concentrate on a given area containing the selection root. This is done
2510     // because of text fields and textareas. The DOM for those is not
2511     // directly in the document DOM, so ensure that the range does not cross a
2512     // boundary of one of those.
2513     if (&amp;range-&gt;startContainer() != scope &amp;&amp; !range-&gt;startContainer().isDescendantOf(scope))
2514         return false;
2515     if (&amp;range-&gt;endContainer() != scope &amp;&amp; !range-&gt;endContainer().isDescendantOf(scope))
2516         return false;
2517 
2518     Ref&lt;Range&gt; testRange = Range::create(scope-&gt;document(), scope, 0, &amp;range-&gt;startContainer(), range-&gt;startOffset());
2519     ASSERT(&amp;testRange-&gt;startContainer() == scope);
2520     location = TextIterator::rangeLength(testRange.ptr());
2521 
2522     testRange-&gt;setEnd(range-&gt;endContainer(), range-&gt;endOffset());
2523     ASSERT(&amp;testRange-&gt;startContainer() == scope);
2524     length = TextIterator::rangeLength(testRange.ptr()) - location;
2525     return true;
2526 }
2527 
2528 // --------
2529 
2530 bool hasAnyPlainText(const Range&amp; range, TextIteratorBehavior behavior)
2531 {
2532     for (TextIterator iterator { &amp;range, behavior }; !iterator.atEnd(); iterator.advance()) {
2533         if (!iterator.text().isEmpty())
2534             return true;
2535     }
2536     return false;
2537 }
2538 
2539 String plainText(Position start, Position end, TextIteratorBehavior defaultBehavior, bool isDisplayString)
2540 {
2541     // The initial buffer size can be critical for performance: https://bugs.webkit.org/show_bug.cgi?id=81192
2542     static const unsigned initialCapacity = 1 &lt;&lt; 15;
2543 
2544     if (!start.document())
2545         return { };
2546     auto document = makeRef(*start.document());
2547 
2548     unsigned bufferLength = 0;
2549     StringBuilder builder;
2550     builder.reserveCapacity(initialCapacity);
2551     TextIteratorBehavior behavior = defaultBehavior;
2552     if (!isDisplayString)
2553         behavior = static_cast&lt;TextIteratorBehavior&gt;(behavior | TextIteratorEmitsTextsWithoutTranscoding);
2554 
2555     for (TextIterator it(start, end, behavior); !it.atEnd(); it.advance()) {
2556         it.appendTextToStringBuilder(builder);
2557         bufferLength += it.text().length();
2558     }
2559 
2560     if (!bufferLength)
2561         return emptyString();
2562 
2563     String result = builder.toString();
2564 
2565     if (isDisplayString)
2566         document-&gt;displayStringModifiedByEncoding(result);
2567 
2568     return result;
2569 }
2570 
2571 String plainTextReplacingNoBreakSpace(Position start, Position end, TextIteratorBehavior defaultBehavior, bool isDisplayString)
2572 {
2573     return plainText(start, end, defaultBehavior, isDisplayString).replace(noBreakSpace, &#39; &#39;);
2574 }
2575 
2576 String plainText(const Range* range, TextIteratorBehavior defaultBehavior, bool isDisplayString)
2577 {
2578     if (!range)
2579         return emptyString();
2580     return plainText(range-&gt;startPosition(), range-&gt;endPosition(), defaultBehavior, isDisplayString);
2581 }
2582 
2583 String plainTextUsingBackwardsTextIteratorForTesting(const Range&amp; range)
2584 {
2585     String result;
2586     for (SimplifiedBackwardsTextIterator backwardsIterator(range); !backwardsIterator.atEnd(); backwardsIterator.advance())
2587         result.insert(backwardsIterator.text().toString(), 0);
2588     return result;
2589 }
2590 
2591 String plainTextReplacingNoBreakSpace(const Range* range, TextIteratorBehavior defaultBehavior, bool isDisplayString)
2592 {
2593     return plainText(range, defaultBehavior, isDisplayString).replace(noBreakSpace, &#39; &#39;);
2594 }
2595 
2596 static Ref&lt;Range&gt; collapsedToBoundary(const Range&amp; range, bool forward)
2597 {
2598     Ref&lt;Range&gt; result = range.cloneRange();
2599     result-&gt;collapse(!forward);
2600     return result;
2601 }
2602 
2603 static TextIteratorBehavior findIteratorOptions(FindOptions options)
2604 {
2605     TextIteratorBehavior iteratorOptions = TextIteratorEntersTextControls | TextIteratorClipsToFrameAncestors;
2606     if (!options.contains(DoNotTraverseFlatTree))
2607         iteratorOptions |= TextIteratorTraversesFlatTree;
2608     return iteratorOptions;
2609 }
2610 
2611 static void findPlainTextMatches(const Range&amp; range, const String&amp; target, FindOptions options, const WTF::Function&lt;bool(size_t, size_t)&gt;&amp; match)
2612 {
2613     SearchBuffer buffer(target, options);
2614     if (buffer.needsMoreContext()) {
2615         Ref&lt;Range&gt; beforeStartRange = range.ownerDocument().createRange();
2616         beforeStartRange-&gt;setEnd(range.startContainer(), range.startOffset());
2617         for (SimplifiedBackwardsTextIterator backwardsIterator(beforeStartRange.get()); !backwardsIterator.atEnd(); backwardsIterator.advance()) {
2618             buffer.prependContext(backwardsIterator.text());
2619             if (!buffer.needsMoreContext())
2620                 break;
2621         }
2622     }
2623 
2624     CharacterIterator findIterator(range, findIteratorOptions(options));
2625     while (!findIterator.atEnd()) {
2626         findIterator.advance(buffer.append(findIterator.text()));
2627         while (1) {
2628             size_t matchStartOffset;
2629             size_t newMatchLength = buffer.search(matchStartOffset);
2630             if (!newMatchLength) {
2631                 if (findIterator.atBreak() &amp;&amp; !buffer.atBreak()) {
2632                     buffer.reachedBreak();
2633                     continue;
2634                 }
2635                 break;
2636             }
2637             size_t lastCharacterInBufferOffset = findIterator.characterOffset();
2638             ASSERT(lastCharacterInBufferOffset &gt;= matchStartOffset);
2639             if (match(lastCharacterInBufferOffset - matchStartOffset, newMatchLength))
2640                 return;
2641         }
2642     }
2643 }
2644 
2645 static Ref&lt;Range&gt; rangeForMatch(const Range&amp; range, FindOptions options, size_t matchStart, size_t matchLength, bool searchForward)
2646 {
2647     if (!matchLength)
2648         return collapsedToBoundary(range, searchForward);
2649     CharacterIterator rangeComputeIterator(range, findIteratorOptions(options));
2650     return characterSubrange(range.ownerDocument(), rangeComputeIterator, matchStart, matchLength);
2651 }
2652 
2653 Ref&lt;Range&gt; findClosestPlainText(const Range&amp; range, const String&amp; target, FindOptions options, unsigned targetOffset)
2654 {
2655     size_t matchStart = 0;
2656     size_t matchLength = 0;
2657     size_t distance = std::numeric_limits&lt;size_t&gt;::max();
2658     auto match = [targetOffset, &amp;distance, &amp;matchStart, &amp;matchLength] (size_t start, size_t length) {
2659         size_t newDistance = std::min(abs(static_cast&lt;signed&gt;(start - targetOffset)), abs(static_cast&lt;signed&gt;(start + length - targetOffset)));
2660         if (newDistance &lt; distance) {
2661             matchStart = start;
2662             matchLength = length;
2663             distance = newDistance;
2664         }
2665         return false;
2666     };
2667 
2668     findPlainTextMatches(range, target, options, WTFMove(match));
2669     return rangeForMatch(range, options, matchStart, matchLength, !options.contains(Backwards));
2670 }
2671 
2672 Ref&lt;Range&gt; findPlainText(const Range&amp; range, const String&amp; target, FindOptions options)
2673 {
2674     bool searchForward = !options.contains(Backwards);
2675     size_t matchStart = 0;
2676     size_t matchLength = 0;
2677     auto match = [searchForward, &amp;matchStart, &amp;matchLength] (size_t start, size_t length) {
2678         matchStart = start;
2679         matchLength = length;
2680         // Look for the last match when searching backwards instead.
2681         return searchForward;
2682     };
2683 
2684     findPlainTextMatches(range, target, options, WTFMove(match));
2685     return rangeForMatch(range, options, matchStart, matchLength, searchForward);
2686 }
2687 
2688 bool findPlainText(const String&amp; document, const String&amp; target, FindOptions options)
2689 {
2690     SearchBuffer buffer { target, options };
2691     StringView remainingText { document };
2692     while (!remainingText.isEmpty()) {
2693         size_t charactersAppended = buffer.append(document);
2694         remainingText = remainingText.substring(charactersAppended);
2695         if (remainingText.isEmpty())
2696             buffer.reachedBreak();
2697         size_t matchStartOffset;
2698         if (buffer.search(matchStartOffset))
2699             return true;
2700     }
2701     return false;
2702 }
2703 
2704 }
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
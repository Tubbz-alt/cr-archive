<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/AccessCase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../builtins/TypedArrayPrototype.js.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessCase.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/AccessCase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2017-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;AccessCase.h&quot;
  28 
  29 #if ENABLE(JIT)
  30 
  31 #include &quot;CCallHelpers.h&quot;

  32 #include &quot;CallLinkInfo.h&quot;
  33 #include &quot;DOMJITGetterSetter.h&quot;
  34 #include &quot;DirectArguments.h&quot;
  35 #include &quot;GetterSetter.h&quot;
  36 #include &quot;GetterSetterAccessCase.h&quot;
  37 #include &quot;InstanceOfAccessCase.h&quot;
  38 #include &quot;IntrinsicGetterAccessCase.h&quot;
  39 #include &quot;JSCInlines.h&quot;
  40 #include &quot;JSModuleEnvironment.h&quot;
  41 #include &quot;JSModuleNamespaceObject.h&quot;
  42 #include &quot;LinkBuffer.h&quot;
  43 #include &quot;ModuleNamespaceAccessCase.h&quot;
  44 #include &quot;PolymorphicAccess.h&quot;
  45 #include &quot;ScopedArguments.h&quot;
  46 #include &quot;ScratchRegisterAllocator.h&quot;
  47 #include &quot;StructureStubInfo.h&quot;
  48 #include &quot;SuperSampler.h&quot;
  49 #include &quot;ThunkGenerators.h&quot;
  50 
  51 namespace JSC {
  52 
  53 namespace AccessCaseInternal {
<span class="line-modified">  54 static const bool verbose = false;</span>
  55 }
  56 
<span class="line-modified">  57 AccessCase::AccessCase(VM&amp; vm, JSCell* owner, AccessType type, PropertyOffset offset, Structure* structure, const ObjectPropertyConditionSet&amp; conditionSet, std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain)</span>


  58     : m_type(type)
  59     , m_offset(offset)
  60     , m_polyProtoAccessChain(WTFMove(prototypeAccessChain))

  61 {
  62     m_structure.setMayBeNull(vm, owner, structure);
  63     m_conditionSet = conditionSet;

  64 }
  65 
<span class="line-modified">  66 std::unique_ptr&lt;AccessCase&gt; AccessCase::create(VM&amp; vm, JSCell* owner, AccessType type, PropertyOffset offset, Structure* structure, const ObjectPropertyConditionSet&amp; conditionSet, std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain)</span>
  67 {
  68     switch (type) {
  69     case InHit:
  70     case InMiss:
  71         break;
  72     case ArrayLength:
  73     case StringLength:
  74     case DirectArgumentsLength:
  75     case ScopedArgumentsLength:
  76     case ModuleNamespaceLoad:
  77     case Replace:
  78     case InstanceOfGeneric:
















  79         RELEASE_ASSERT(!prototypeAccessChain);
  80         break;
  81     default:
  82         RELEASE_ASSERT_NOT_REACHED();
  83     };
  84 
<span class="line-modified">  85     return std::unique_ptr&lt;AccessCase&gt;(new AccessCase(vm, owner, type, offset, structure, conditionSet, WTFMove(prototypeAccessChain)));</span>
  86 }
  87 
  88 std::unique_ptr&lt;AccessCase&gt; AccessCase::create(
<span class="line-modified">  89     VM&amp; vm, JSCell* owner, PropertyOffset offset, Structure* oldStructure, Structure* newStructure,</span>
  90     const ObjectPropertyConditionSet&amp; conditionSet, std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain)
  91 {
  92     RELEASE_ASSERT(oldStructure == newStructure-&gt;previousID());
  93 
  94     // Skip optimizing the case where we need a realloc, if we don&#39;t have
  95     // enough registers to make it happen.
  96     if (GPRInfo::numberOfRegisters &lt; 6
  97         &amp;&amp; oldStructure-&gt;outOfLineCapacity() != newStructure-&gt;outOfLineCapacity()
  98         &amp;&amp; oldStructure-&gt;outOfLineCapacity()) {
  99         return nullptr;
 100     }
 101 
<span class="line-modified"> 102     return std::unique_ptr&lt;AccessCase&gt;(new AccessCase(vm, owner, Transition, offset, newStructure, conditionSet, WTFMove(prototypeAccessChain)));</span>
 103 }
 104 
 105 AccessCase::~AccessCase()
 106 {
 107 }
 108 
 109 std::unique_ptr&lt;AccessCase&gt; AccessCase::fromStructureStubInfo(
<span class="line-modified"> 110     VM&amp; vm, JSCell* owner, StructureStubInfo&amp; stubInfo)</span>
 111 {
<span class="line-modified"> 112     switch (stubInfo.cacheType) {</span>
 113     case CacheType::GetByIdSelf:
<span class="line-modified"> 114         return ProxyableAccessCase::create(vm, owner, Load, stubInfo.u.byIdSelf.offset, stubInfo.u.byIdSelf.baseObjectStructure.get());</span>

 115 
 116     case CacheType::PutByIdReplace:
<span class="line-modified"> 117         return AccessCase::create(vm, owner, Replace, stubInfo.u.byIdSelf.offset, stubInfo.u.byIdSelf.baseObjectStructure.get());</span>


 118 
 119     case CacheType::InByIdSelf:
<span class="line-modified"> 120         return AccessCase::create(vm, owner, InHit, stubInfo.u.byIdSelf.offset, stubInfo.u.byIdSelf.baseObjectStructure.get());</span>


 121 
 122     case CacheType::ArrayLength:
<span class="line-modified"> 123         return AccessCase::create(vm, owner, AccessCase::ArrayLength);</span>


 124 
 125     case CacheType::StringLength:
<span class="line-modified"> 126         return AccessCase::create(vm, owner, AccessCase::StringLength);</span>


 127 
 128     default:
 129         return nullptr;
 130     }
 131 }
 132 
 133 bool AccessCase::hasAlternateBase() const
 134 {
 135     return !conditionSet().isEmpty();
 136 }
 137 
 138 JSObject* AccessCase::alternateBase() const
 139 {
 140     return conditionSet().slotBaseCondition().object();
 141 }
 142 
 143 std::unique_ptr&lt;AccessCase&gt; AccessCase::clone() const
 144 {
 145     std::unique_ptr&lt;AccessCase&gt; result(new AccessCase(*this));
 146     result-&gt;resetState();
 147     return result;
 148 }
 149 
<span class="line-modified"> 150 Vector&lt;WatchpointSet*, 2&gt; AccessCase::commit(VM&amp; vm, const Identifier&amp; ident)</span>
 151 {
 152     // It&#39;s fine to commit something that is already committed. That arises when we switch to using
 153     // newly allocated watchpoints. When it happens, it&#39;s not efficient - but we think that&#39;s OK
 154     // because most AccessCases have no extra watchpoints anyway.
 155     RELEASE_ASSERT(m_state == Primordial || m_state == Committed);
 156 
 157     Vector&lt;WatchpointSet*, 2&gt; result;
 158     Structure* structure = this-&gt;structure();
 159 
<span class="line-modified"> 160     if (!ident.isNull()) {</span>
 161         if ((structure &amp;&amp; structure-&gt;needImpurePropertyWatchpoint())
 162             || m_conditionSet.needImpurePropertyWatchpoint()
<span class="line-modified"> 163             || (m_polyProtoAccessChain &amp;&amp; m_polyProtoAccessChain-&gt;needImpurePropertyWatchpoint()))</span>
<span class="line-modified"> 164             result.append(vm.ensureWatchpointSetForImpureProperty(ident));</span>
 165     }
 166 
 167     if (additionalSet())
 168         result.append(additionalSet());
 169 
 170     if (structure
 171         &amp;&amp; structure-&gt;hasRareData()
 172         &amp;&amp; structure-&gt;rareData()-&gt;hasSharedPolyProtoWatchpoint()
 173         &amp;&amp; structure-&gt;rareData()-&gt;sharedPolyProtoWatchpoint()-&gt;isStillValid()) {
 174         WatchpointSet* set = structure-&gt;rareData()-&gt;sharedPolyProtoWatchpoint()-&gt;inflate();
 175         result.append(set);
 176     }
 177 
 178     m_state = Committed;
 179 
 180     return result;
 181 }
 182 
<span class="line-modified"> 183 bool AccessCase::guardedByStructureCheck() const</span>







 184 {
 185     if (viaProxy())
 186         return false;
 187 
 188     if (m_polyProtoAccessChain)
 189         return false;
 190 
 191     switch (m_type) {
 192     case ArrayLength:
 193     case StringLength:
 194     case DirectArgumentsLength:
 195     case ScopedArgumentsLength:
 196     case ModuleNamespaceLoad:
 197     case InstanceOfHit:
 198     case InstanceOfMiss:
 199     case InstanceOfGeneric:
















 200         return false;
 201     default:
 202         return true;
 203     }
 204 }
 205 
<span class="line-modified"> 206 bool AccessCase::doesCalls(Vector&lt;JSCell*&gt;* cellsToMark) const</span>
 207 {
<span class="line-modified"> 208     switch (type()) {</span>






 209     case Getter:
 210     case Setter:
 211     case CustomValueGetter:
 212     case CustomAccessorGetter:
 213     case CustomValueSetter:
 214     case CustomAccessorSetter:








 215         return true;




























 216     case Transition:
<span class="line-modified"> 217         if (newStructure()-&gt;outOfLineCapacity() != structure()-&gt;outOfLineCapacity()</span>
<span class="line-modified"> 218             &amp;&amp; structure()-&gt;couldHaveIndexingHeader()) {</span>
<span class="line-modified"> 219             if (cellsToMark)</span>
<span class="line-modified"> 220                 cellsToMark-&gt;append(newStructure());</span>
<span class="line-modified"> 221             return true;</span>
<span class="line-modified"> 222         }</span>














 223         return false;
<span class="line-modified"> 224     default:</span>

























































 225         return false;





















































































 226     }
 227 }
 228 


























































 229 bool AccessCase::couldStillSucceed() const
 230 {
<span class="line-modified"> 231     return m_conditionSet.structuresEnsureValidityAssumingImpurePropertyWatchpoint();</span>









 232 }
 233 
 234 bool AccessCase::canReplace(const AccessCase&amp; other) const
 235 {
 236     // This puts in a good effort to try to figure out if &#39;other&#39; is made superfluous by &#39;*this&#39;.
 237     // It&#39;s fine for this to return false if it&#39;s in doubt.
 238     //
 239     // Note that if A-&gt;guardedByStructureCheck() &amp;&amp; B-&gt;guardedByStructureCheck() then
 240     // A-&gt;canReplace(B) == B-&gt;canReplace(A).
 241 



 242     switch (type()) {




 243     case ArrayLength:
 244     case StringLength:
 245     case DirectArgumentsLength:
 246     case ScopedArgumentsLength:












 247         return other.type() == type();

 248     case ModuleNamespaceLoad: {
 249         if (other.type() != type())
 250             return false;
 251         auto&amp; thisCase = this-&gt;as&lt;ModuleNamespaceAccessCase&gt;();
 252         auto&amp; otherCase = this-&gt;as&lt;ModuleNamespaceAccessCase&gt;();
 253         return thisCase.moduleNamespaceObject() == otherCase.moduleNamespaceObject();
 254     }

 255     case InstanceOfHit:
 256     case InstanceOfMiss: {
 257         if (other.type() != type())
 258             return false;
 259 
 260         if (this-&gt;as&lt;InstanceOfAccessCase&gt;().prototype() != other.as&lt;InstanceOfAccessCase&gt;().prototype())
 261             return false;
 262 
 263         return structure() == other.structure();
 264     }

 265     case InstanceOfGeneric:
 266         switch (other.type()) {
 267         case InstanceOfGeneric:
 268         case InstanceOfHit:
 269         case InstanceOfMiss:
 270             return true;
 271         default:
 272             return false;
 273         }
<span class="line-modified"> 274     default:</span>














 275         if (other.type() != type())
 276             return false;
 277 
 278         if (m_polyProtoAccessChain) {
 279             if (!other.m_polyProtoAccessChain)
 280                 return false;
 281             // This is the only check we need since PolyProtoAccessChain contains the base structure.
 282             // If we ever change it to contain only the prototype chain, we&#39;ll also need to change
 283             // this to check the base structure.
 284             return structure() == other.structure()
 285                 &amp;&amp; *m_polyProtoAccessChain == *other.m_polyProtoAccessChain;
 286         }
 287 
<span class="line-modified"> 288         if (!guardedByStructureCheck() || !other.guardedByStructureCheck())</span>
 289             return false;
 290 
 291         return structure() == other.structure();
 292     }

 293 }
 294 
 295 void AccessCase::dump(PrintStream&amp; out) const
 296 {
 297     out.print(&quot;\n&quot;, m_type, &quot;:(&quot;);
 298 
 299     CommaPrinter comma;
 300 
 301     out.print(comma, m_state);
 302 

 303     if (isValidOffset(m_offset))
 304         out.print(comma, &quot;offset = &quot;, m_offset);
<span class="line-removed"> 305     if (!m_conditionSet.isEmpty())</span>
<span class="line-removed"> 306         out.print(comma, &quot;conditions = &quot;, m_conditionSet);</span>
 307 
 308     if (m_polyProtoAccessChain) {
 309         out.print(comma, &quot;prototype access chain = &quot;);
 310         m_polyProtoAccessChain-&gt;dump(structure(), out);
 311     } else {
 312         if (m_type == Transition)
 313             out.print(comma, &quot;structure = &quot;, pointerDump(structure()), &quot; -&gt; &quot;, pointerDump(newStructure()));
 314         else if (m_structure)
 315             out.print(comma, &quot;structure = &quot;, pointerDump(m_structure.get()));
 316     }
 317 



 318     dumpImpl(out, comma);
 319     out.print(&quot;)&quot;);
 320 }
 321 
 322 bool AccessCase::visitWeak(VM&amp; vm) const
 323 {
<span class="line-removed"> 324     if (m_structure &amp;&amp; !vm.heap.isMarked(m_structure.get()))</span>
<span class="line-removed"> 325         return false;</span>
<span class="line-removed"> 326     if (m_polyProtoAccessChain) {</span>
<span class="line-removed"> 327         for (Structure* structure : m_polyProtoAccessChain-&gt;chain()) {</span>
<span class="line-removed"> 328             if (!vm.heap.isMarked(structure))</span>
<span class="line-removed"> 329                 return false;</span>
<span class="line-removed"> 330         }</span>
<span class="line-removed"> 331     }</span>
<span class="line-removed"> 332     if (!m_conditionSet.areStillLive(vm))</span>
<span class="line-removed"> 333         return false;</span>
 334     if (isAccessor()) {
 335         auto&amp; accessor = this-&gt;as&lt;GetterSetterAccessCase&gt;();
 336         if (accessor.callLinkInfo())
 337             accessor.callLinkInfo()-&gt;visitWeak(vm);
<span class="line-removed"> 338         if (accessor.customSlotBase() &amp;&amp; !vm.heap.isMarked(accessor.customSlotBase()))</span>
<span class="line-removed"> 339             return false;</span>
<span class="line-removed"> 340     } else if (type() == IntrinsicGetter) {</span>
<span class="line-removed"> 341         auto&amp; intrinsic = this-&gt;as&lt;IntrinsicGetterAccessCase&gt;();</span>
<span class="line-removed"> 342         if (intrinsic.intrinsicFunction() &amp;&amp; !vm.heap.isMarked(intrinsic.intrinsicFunction()))</span>
<span class="line-removed"> 343             return false;</span>
<span class="line-removed"> 344     } else if (type() == ModuleNamespaceLoad) {</span>
<span class="line-removed"> 345         auto&amp; accessCase = this-&gt;as&lt;ModuleNamespaceAccessCase&gt;();</span>
<span class="line-removed"> 346         if (accessCase.moduleNamespaceObject() &amp;&amp; !vm.heap.isMarked(accessCase.moduleNamespaceObject()))</span>
<span class="line-removed"> 347             return false;</span>
<span class="line-removed"> 348         if (accessCase.moduleEnvironment() &amp;&amp; !vm.heap.isMarked(accessCase.moduleEnvironment()))</span>
<span class="line-removed"> 349             return false;</span>
<span class="line-removed"> 350     } else if (type() == InstanceOfHit || type() == InstanceOfMiss) {</span>
<span class="line-removed"> 351         if (as&lt;InstanceOfAccessCase&gt;().prototype() &amp;&amp; !vm.heap.isMarked(as&lt;InstanceOfAccessCase&gt;().prototype()))</span>
<span class="line-removed"> 352             return false;</span>
 353     }
 354 
<span class="line-modified"> 355     return true;</span>




 356 }
 357 
 358 bool AccessCase::propagateTransitions(SlotVisitor&amp; visitor) const
 359 {
 360     bool result = true;
 361 
 362     if (m_structure)
 363         result &amp;= m_structure-&gt;markIfCheap(visitor);
 364 
 365     if (m_polyProtoAccessChain) {
<span class="line-modified"> 366         for (Structure* structure : m_polyProtoAccessChain-&gt;chain())</span>
<span class="line-modified"> 367             result &amp;= structure-&gt;markIfCheap(visitor);</span>
 368     }
 369 
 370     switch (m_type) {
 371     case Transition:
 372         if (visitor.vm().heap.isMarked(m_structure-&gt;previousID()))
 373             visitor.appendUnbarriered(m_structure.get());
 374         else
 375             result = false;
 376         break;
 377     default:
 378         break;
 379     }
 380 
 381     return result;
 382 }
 383 





 384 void AccessCase::generateWithGuard(
 385     AccessGenerationState&amp; state, CCallHelpers::JumpList&amp; fallThrough)
 386 {
 387     SuperSamplerScope superSamplerScope(false);
 388 


 389     RELEASE_ASSERT(m_state == Committed);
 390     m_state = Generated;
 391 
 392     CCallHelpers&amp; jit = *state.jit;
 393     StructureStubInfo&amp; stubInfo = *state.stubInfo;
 394     VM&amp; vm = state.m_vm;
 395     JSValueRegs valueRegs = state.valueRegs;
 396     GPRReg baseGPR = state.baseGPR;
<span class="line-removed"> 397     GPRReg thisGPR = state.thisGPR != InvalidGPRReg ? state.thisGPR : baseGPR;</span>
 398     GPRReg scratchGPR = state.scratchGPR;
 399 
<span class="line-modified"> 400     UNUSED_PARAM(vm);</span>










 401 
 402     auto emitDefaultGuard = [&amp;] () {
 403         if (m_polyProtoAccessChain) {
 404             GPRReg baseForAccessGPR = state.scratchGPR;
 405             jit.move(state.baseGPR, baseForAccessGPR);
<span class="line-modified"> 406             m_polyProtoAccessChain-&gt;forEach(structure(), [&amp;] (Structure* structure, bool atEnd) {</span>
 407                 fallThrough.append(
 408                     jit.branchStructure(
 409                         CCallHelpers::NotEqual,
 410                         CCallHelpers::Address(baseForAccessGPR, JSCell::structureIDOffset()),
 411                         structure));
 412                 if (atEnd) {
 413                     if ((m_type == Miss || m_type == InMiss || m_type == Transition) &amp;&amp; structure-&gt;hasPolyProto()) {
 414                         // For a Miss/InMiss/Transition, we must ensure we&#39;re at the end when the last item is poly proto.
 415                         // Transitions must do this because they need to verify there isn&#39;t a setter in the chain.
 416                         // Miss/InMiss need to do this to ensure there isn&#39;t a new item at the end of the chain that
 417                         // has the property.
 418 #if USE(JSVALUE64)
 419                         jit.load64(MacroAssembler::Address(baseForAccessGPR, offsetRelativeToBase(knownPolyProtoOffset)), baseForAccessGPR);
<span class="line-modified"> 420                         fallThrough.append(jit.branch64(CCallHelpers::NotEqual, baseForAccessGPR, CCallHelpers::TrustedImm64(ValueNull)));</span>
 421 #else
 422                         jit.load32(MacroAssembler::Address(baseForAccessGPR, offsetRelativeToBase(knownPolyProtoOffset) + PayloadOffset), baseForAccessGPR);
 423                         fallThrough.append(jit.branchTestPtr(CCallHelpers::NonZero, baseForAccessGPR));
 424 #endif
 425                     }
 426                 } else {
 427                     if (structure-&gt;hasMonoProto()) {
 428                         JSValue prototype = structure-&gt;prototypeForLookup(state.m_globalObject);
 429                         RELEASE_ASSERT(prototype.isObject());
 430                         jit.move(CCallHelpers::TrustedImmPtr(asObject(prototype)), baseForAccessGPR);
 431                     } else {
 432                         RELEASE_ASSERT(structure-&gt;isObject()); // Primitives must have a stored prototype. We use prototypeForLookup for them.
 433 #if USE(JSVALUE64)
 434                         jit.load64(MacroAssembler::Address(baseForAccessGPR, offsetRelativeToBase(knownPolyProtoOffset)), baseForAccessGPR);
<span class="line-modified"> 435                         fallThrough.append(jit.branch64(CCallHelpers::Equal, baseForAccessGPR, CCallHelpers::TrustedImm64(ValueNull)));</span>
 436 #else
 437                         jit.load32(MacroAssembler::Address(baseForAccessGPR, offsetRelativeToBase(knownPolyProtoOffset) + PayloadOffset), baseForAccessGPR);
 438                         fallThrough.append(jit.branchTestPtr(CCallHelpers::Zero, baseForAccessGPR));
 439 #endif
 440                     }
 441                 }
 442             });
 443             return;
 444         }
 445 
 446         if (viaProxy()) {
 447             fallThrough.append(
 448                 jit.branchIfNotType(baseGPR, PureForwardingProxyType));
 449 
 450             jit.loadPtr(CCallHelpers::Address(baseGPR, JSProxy::targetOffset()), scratchGPR);
 451 
 452             fallThrough.append(
 453                 jit.branchStructure(
 454                     CCallHelpers::NotEqual,
 455                     CCallHelpers::Address(scratchGPR, JSCell::structureIDOffset()),
</pre>
<hr />
<pre>
 489         fallThrough.append(
 490             jit.branchIfNotType(baseGPR, DirectArgumentsType));
 491 
 492         fallThrough.append(
 493             jit.branchTestPtr(
 494                 CCallHelpers::NonZero,
 495                 CCallHelpers::Address(baseGPR, DirectArguments::offsetOfMappedArguments())));
 496         jit.load32(
 497             CCallHelpers::Address(baseGPR, DirectArguments::offsetOfLength()),
 498             valueRegs.payloadGPR());
 499         jit.boxInt32(valueRegs.payloadGPR(), valueRegs);
 500         state.succeed();
 501         return;
 502     }
 503 
 504     case ScopedArgumentsLength: {
 505         ASSERT(!viaProxy());
 506         fallThrough.append(
 507             jit.branchIfNotType(baseGPR, ScopedArgumentsType));
 508 
<span class="line-removed"> 509         jit.loadPtr(</span>
<span class="line-removed"> 510             CCallHelpers::Address(baseGPR, ScopedArguments::offsetOfStorage()),</span>
<span class="line-removed"> 511             scratchGPR);</span>
 512         fallThrough.append(
 513             jit.branchTest8(
 514                 CCallHelpers::NonZero,
<span class="line-modified"> 515                 CCallHelpers::Address(scratchGPR, ScopedArguments::offsetOfOverrodeThingsInStorage())));</span>
 516         jit.load32(
<span class="line-modified"> 517             CCallHelpers::Address(scratchGPR, ScopedArguments::offsetOfTotalLengthInStorage()),</span>
 518             valueRegs.payloadGPR());
 519         jit.boxInt32(valueRegs.payloadGPR(), valueRegs);
 520         state.succeed();
 521         return;
 522     }
 523 
 524     case ModuleNamespaceLoad: {
 525         this-&gt;as&lt;ModuleNamespaceAccessCase&gt;().emit(state, fallThrough);
 526         return;
 527     }
 528 



















































































































































































































































































































































 529     case InstanceOfHit:
 530     case InstanceOfMiss:
 531         emitDefaultGuard();
 532 
 533         fallThrough.append(
 534             jit.branchPtr(
<span class="line-modified"> 535                 CCallHelpers::NotEqual, thisGPR,</span>
 536                 CCallHelpers::TrustedImmPtr(as&lt;InstanceOfAccessCase&gt;().prototype())));
 537         break;
 538 
 539     case InstanceOfGeneric: {
<span class="line-modified"> 540         // Legend: value = `base instanceof this`.</span>

 541 
 542         GPRReg valueGPR = valueRegs.payloadGPR();
 543 
<span class="line-modified"> 544         ScratchRegisterAllocator allocator(stubInfo.patch.usedRegisters);</span>
<span class="line-modified"> 545         allocator.lock(baseGPR);</span>
<span class="line-modified"> 546         allocator.lock(valueGPR);</span>
<span class="line-modified"> 547         allocator.lock(thisGPR);</span>
 548         allocator.lock(scratchGPR);
 549 
 550         GPRReg scratch2GPR = allocator.allocateScratchGPR();
 551 
 552         if (!state.stubInfo-&gt;prototypeIsKnownObject)
<span class="line-modified"> 553             state.failAndIgnore.append(jit.branchIfNotObject(thisGPR));</span>
 554 
 555         ScratchRegisterAllocator::PreservedState preservedState =
 556             allocator.preserveReusedRegistersByPushing(
 557                 jit,
 558                 ScratchRegisterAllocator::ExtraStackSpace::NoExtraSpace);
 559         CCallHelpers::Jump failAndIgnore;
 560 
 561         jit.move(baseGPR, valueGPR);
 562 
 563         CCallHelpers::Label loop(&amp;jit);
 564         failAndIgnore = jit.branchIfType(valueGPR, ProxyObjectType);
 565 
 566         jit.emitLoadStructure(vm, valueGPR, scratch2GPR, scratchGPR);
 567 #if USE(JSVALUE64)
 568         jit.load64(CCallHelpers::Address(scratch2GPR, Structure::prototypeOffset()), scratch2GPR);
 569         CCallHelpers::Jump hasMonoProto = jit.branchTest64(CCallHelpers::NonZero, scratch2GPR);
 570         jit.load64(
 571             CCallHelpers::Address(valueGPR, offsetRelativeToBase(knownPolyProtoOffset)),
 572             scratch2GPR);
 573         hasMonoProto.link(&amp;jit);
 574 #else
 575         jit.load32(
 576             CCallHelpers::Address(scratch2GPR, Structure::prototypeOffset() + TagOffset),
 577             scratchGPR);
 578         jit.load32(
 579             CCallHelpers::Address(scratch2GPR, Structure::prototypeOffset() + PayloadOffset),
 580             scratch2GPR);
 581         CCallHelpers::Jump hasMonoProto = jit.branch32(
 582             CCallHelpers::NotEqual, scratchGPR, CCallHelpers::TrustedImm32(JSValue::EmptyValueTag));
 583         jit.load32(
 584             CCallHelpers::Address(
 585                 valueGPR, offsetRelativeToBase(knownPolyProtoOffset) + PayloadOffset),
 586             scratch2GPR);
 587         hasMonoProto.link(&amp;jit);
 588 #endif
 589         jit.move(scratch2GPR, valueGPR);
 590 
<span class="line-modified"> 591         CCallHelpers::Jump isInstance = jit.branchPtr(CCallHelpers::Equal, valueGPR, thisGPR);</span>
 592 
 593 #if USE(JSVALUE64)
 594         jit.branchIfCell(JSValueRegs(valueGPR)).linkTo(loop, &amp;jit);
 595 #else
 596         jit.branchTestPtr(CCallHelpers::NonZero, valueGPR).linkTo(loop, &amp;jit);
 597 #endif
 598 
 599         jit.boxBooleanPayload(false, valueGPR);
 600         allocator.restoreReusedRegistersByPopping(jit, preservedState);
 601         state.succeed();
 602 
 603         isInstance.link(&amp;jit);
 604         jit.boxBooleanPayload(true, valueGPR);
 605         allocator.restoreReusedRegistersByPopping(jit, preservedState);
 606         state.succeed();
 607 
 608         if (allocator.didReuseRegisters()) {
 609             failAndIgnore.link(&amp;jit);
 610             allocator.restoreReusedRegistersByPopping(jit, preservedState);
 611             state.failAndIgnore.append(jit.jump());
 612         } else
 613             state.failAndIgnore.append(failAndIgnore);
 614         return;
 615     }
 616 
 617     default:
 618         emitDefaultGuard();
 619         break;
 620     }
 621 
 622     generateImpl(state);
 623 }
 624 
 625 void AccessCase::generate(AccessGenerationState&amp; state)
 626 {
 627     RELEASE_ASSERT(m_state == Committed);

 628     m_state = Generated;
 629 


 630     generateImpl(state);
 631 }
 632 
 633 void AccessCase::generateImpl(AccessGenerationState&amp; state)
 634 {
 635     SuperSamplerScope superSamplerScope(false);
 636     if (AccessCaseInternal::verbose)
 637         dataLog(&quot;\n\nGenerating code for: &quot;, *this, &quot;\n&quot;);
 638 
 639     ASSERT(m_state == Generated); // We rely on the callers setting this for us.
 640 
 641     CCallHelpers&amp; jit = *state.jit;
 642     VM&amp; vm = state.m_vm;
 643     CodeBlock* codeBlock = jit.codeBlock();
 644     StructureStubInfo&amp; stubInfo = *state.stubInfo;
<span class="line-removed"> 645     const Identifier&amp; ident = *state.ident;</span>
 646     JSValueRegs valueRegs = state.valueRegs;
 647     GPRReg baseGPR = state.baseGPR;
<span class="line-modified"> 648     GPRReg thisGPR = state.thisGPR != InvalidGPRReg ? state.thisGPR : baseGPR;</span>
 649     GPRReg scratchGPR = state.scratchGPR;
 650 
<span class="line-removed"> 651     ASSERT(m_conditionSet.structuresEnsureValidityAssumingImpurePropertyWatchpoint());</span>
<span class="line-removed"> 652 </span>
 653     for (const ObjectPropertyCondition&amp; condition : m_conditionSet) {
 654         RELEASE_ASSERT(!m_polyProtoAccessChain);
 655 
<span class="line-modified"> 656         Structure* structure = condition.object()-&gt;structure(vm);</span>
<span class="line-modified"> 657 </span>
<span class="line-removed"> 658         if (condition.isWatchableAssumingImpurePropertyWatchpoint()) {</span>
<span class="line-removed"> 659             structure-&gt;addTransitionWatchpoint(state.addWatchpoint(condition));</span>
 660             continue;
 661         }
 662 
<span class="line-modified"> 663         if (!condition.structureEnsuresValidityAssumingImpurePropertyWatchpoint(structure)) {</span>



 664             // The reason why this cannot happen is that we require that PolymorphicAccess calls
 665             // AccessCase::generate() only after it has verified that
 666             // AccessCase::couldStillSucceed() returned true.
 667 
 668             dataLog(&quot;This condition is no longer met: &quot;, condition, &quot;\n&quot;);
 669             RELEASE_ASSERT_NOT_REACHED();
 670         }
 671 
 672         // We will emit code that has a weak reference that isn&#39;t otherwise listed anywhere.

 673         state.weakReferences.append(WriteBarrier&lt;JSCell&gt;(vm, codeBlock, structure));
 674 
 675         jit.move(CCallHelpers::TrustedImmPtr(condition.object()), scratchGPR);
 676         state.failAndRepatch.append(
 677             jit.branchStructure(
 678                 CCallHelpers::NotEqual,
 679                 CCallHelpers::Address(scratchGPR, JSCell::structureIDOffset()),
 680                 structure));
 681     }
 682 
 683     switch (m_type) {
 684     case InHit:
 685     case InMiss:
 686         jit.boxBoolean(m_type == InHit, valueRegs);
 687         state.succeed();
 688         return;
 689 
 690     case Miss:
 691         jit.moveTrustedValue(jsUndefined(), valueRegs);
 692         state.succeed();
</pre>
<hr />
<pre>
 812         CCallHelpers::DataLabelPtr addressOfLinkFunctionCheck;
 813         CCallHelpers::Call fastPathCall;
 814         CCallHelpers::Call slowPathCall;
 815 
 816         // This also does the necessary calculations of whether or not we&#39;re an
 817         // exception handling call site.
 818         AccessGenerationState::SpillState spillState = state.preserveLiveRegistersToStackForCall();
 819 
 820         auto restoreLiveRegistersFromStackForCall = [&amp;](AccessGenerationState::SpillState&amp; spillState, bool callHasReturnValue) {
 821             RegisterSet dontRestore;
 822             if (callHasReturnValue) {
 823                 // This is the result value. We don&#39;t want to overwrite the result with what we stored to the stack.
 824                 // We sometimes have to store it to the stack just in case we throw an exception and need the original value.
 825                 dontRestore.set(valueRegs);
 826             }
 827             state.restoreLiveRegistersFromStackForCall(spillState, dontRestore);
 828         };
 829 
 830         jit.store32(
 831             CCallHelpers::TrustedImm32(state.callSiteIndexForExceptionHandlingOrOriginal().bits()),
<span class="line-modified"> 832             CCallHelpers::tagFor(static_cast&lt;VirtualRegister&gt;(CallFrameSlot::argumentCount)));</span>
 833 
 834         if (m_type == Getter || m_type == Setter) {
 835             auto&amp; access = this-&gt;as&lt;GetterSetterAccessCase&gt;();
 836             ASSERT(baseGPR != loadedValueGPR);
 837             ASSERT(m_type != Setter || valueRegsPayloadGPR != loadedValueGPR);
 838 
 839             // Create a JS call using a JS call inline cache. Assume that:
 840             //
 841             // - SP is aligned and represents the extent of the calling compiler&#39;s stack usage.
 842             //
 843             // - FP is set correctly (i.e. it points to the caller&#39;s call frame header).
 844             //
 845             // - SP - FP is an aligned difference.
 846             //
 847             // - Any byte between FP (exclusive) and SP (inclusive) could be live in the calling
 848             //   code.
 849             //
 850             // Therefore, we temporarily grow the stack for the purpose of the call and then
 851             // shrink it after.
 852 
 853             state.setSpillStateForJSGetterSetter(spillState);
 854 
 855             RELEASE_ASSERT(!access.callLinkInfo());
<span class="line-modified"> 856             access.m_callLinkInfo = makeUnique&lt;CallLinkInfo&gt;();</span>

 857 
 858             // FIXME: If we generated a polymorphic call stub that jumped back to the getter
 859             // stub, which then jumped back to the main code, then we&#39;d have a reachability
 860             // situation that the GC doesn&#39;t know about. The GC would ensure that the polymorphic
 861             // call stub stayed alive, and it would ensure that the main code stayed alive, but
 862             // it wouldn&#39;t know that the getter stub was alive. Ideally JIT stub routines would
 863             // be GC objects, and then we&#39;d be able to say that the polymorphic call stub has a
 864             // reference to the getter stub.
 865             // https://bugs.webkit.org/show_bug.cgi?id=148914
<span class="line-modified"> 866             access.callLinkInfo()-&gt;disallowStubs();</span>
 867 
<span class="line-modified"> 868             access.callLinkInfo()-&gt;setUpCall(</span>
<span class="line-removed"> 869                 CallLinkInfo::Call, stubInfo.codeOrigin, loadedValueGPR);</span>
 870 
 871             CCallHelpers::JumpList done;
 872 
 873             // There is a &quot;this&quot; argument.
 874             unsigned numberOfParameters = 1;
 875             // ... and a value argument if we&#39;re calling a setter.
 876             if (m_type == Setter)
 877                 numberOfParameters++;
 878 
 879             // Get the accessor; if there ain&#39;t one then the result is jsUndefined().
 880             if (m_type == Setter) {
 881                 jit.loadPtr(
 882                     CCallHelpers::Address(loadedValueGPR, GetterSetter::offsetOfSetter()),
 883                     loadedValueGPR);
 884             } else {
 885                 jit.loadPtr(
 886                     CCallHelpers::Address(loadedValueGPR, GetterSetter::offsetOfGetter()),
 887                     loadedValueGPR);
 888             }
 889 
 890             CCallHelpers::Jump returnUndefined = jit.branchTestPtr(
 891                 CCallHelpers::Zero, loadedValueGPR);
 892 
<span class="line-modified"> 893             unsigned numberOfRegsForCall = CallFrame::headerSizeInRegisters + numberOfParameters;</span>

 894             unsigned numberOfBytesForCall = numberOfRegsForCall * sizeof(Register) - sizeof(CallerFrameAndPC);
 895 
 896             unsigned alignedNumberOfBytesForCall =
 897             WTF::roundUpToMultipleOf(stackAlignmentBytes(), numberOfBytesForCall);
 898 
 899             jit.subPtr(
 900                 CCallHelpers::TrustedImm32(alignedNumberOfBytesForCall),
 901                 CCallHelpers::stackPointerRegister);
 902 
 903             CCallHelpers::Address calleeFrame = CCallHelpers::Address(
 904                 CCallHelpers::stackPointerRegister,
 905                 -static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC)));
 906 
 907             jit.store32(
 908                 CCallHelpers::TrustedImm32(numberOfParameters),
<span class="line-modified"> 909                 calleeFrame.withOffset(CallFrameSlot::argumentCount * sizeof(Register) + PayloadOffset));</span>
 910 
 911             jit.storeCell(
 912                 loadedValueGPR, calleeFrame.withOffset(CallFrameSlot::callee * sizeof(Register)));
 913 
 914             jit.storeCell(
 915                 thisGPR,
<span class="line-modified"> 916                 calleeFrame.withOffset(virtualRegisterForArgument(0).offset() * sizeof(Register)));</span>
 917 
 918             if (m_type == Setter) {
 919                 jit.storeValue(
 920                     valueRegs,
 921                     calleeFrame.withOffset(
<span class="line-modified"> 922                         virtualRegisterForArgument(1).offset() * sizeof(Register)));</span>
 923             }
 924 
 925             CCallHelpers::Jump slowCase = jit.branchPtrWithPatch(
 926                 CCallHelpers::NotEqual, loadedValueGPR, addressOfLinkFunctionCheck,
 927                 CCallHelpers::TrustedImmPtr(nullptr));
 928 
 929             fastPathCall = jit.nearCall();
 930             if (m_type == Getter)
 931                 jit.setupResults(valueRegs);
 932             done.append(jit.jump());
 933 


 934             slowCase.link(&amp;jit);
 935             jit.move(loadedValueGPR, GPRInfo::regT0);
 936 #if USE(JSVALUE32_64)
 937             // We *always* know that the getter/setter, if non-null, is a cell.
 938             jit.move(CCallHelpers::TrustedImm32(JSValue::CellTag), GPRInfo::regT1);
 939 #endif
 940             jit.move(CCallHelpers::TrustedImmPtr(access.callLinkInfo()), GPRInfo::regT2);

 941             slowPathCall = jit.nearCall();
 942             if (m_type == Getter)
 943                 jit.setupResults(valueRegs);
 944             done.append(jit.jump());
 945 
 946             returnUndefined.link(&amp;jit);
 947             if (m_type == Getter)
 948                 jit.moveTrustedValue(jsUndefined(), valueRegs);
 949 
 950             done.link(&amp;jit);
 951 
 952             jit.addPtr(CCallHelpers::TrustedImm32((codeBlock-&gt;stackPointerOffset() * sizeof(Register)) - state.preservedReusedRegisterState.numberOfBytesPreserved - spillState.numberOfStackBytesUsedForRegisterPreservation),
 953                 GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
 954             bool callHasReturnValue = isGetter();
 955             restoreLiveRegistersFromStackForCall(spillState, callHasReturnValue);
 956 
 957             jit.addLinkTask([=, &amp;vm] (LinkBuffer&amp; linkBuffer) {
 958                 this-&gt;as&lt;GetterSetterAccessCase&gt;().callLinkInfo()-&gt;setCallLocations(
 959                     CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(slowPathCall)),
 960                     CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(addressOfLinkFunctionCheck)),
 961                     linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(fastPathCall));
 962 
 963                 linkBuffer.link(
 964                     slowPathCall,
 965                     CodeLocationLabel&lt;JITThunkPtrTag&gt;(vm.getCTIStub(linkCallThunkGenerator).code()));
 966             });
 967         } else {
 968             ASSERT(m_type == CustomValueGetter || m_type == CustomAccessorGetter || m_type == CustomValueSetter || m_type == CustomAccessorSetter);
 969 
 970             // Need to make room for the C call so any of our stack spillage isn&#39;t overwritten. It&#39;s
 971             // hard to track if someone did spillage or not, so we just assume that we always need
 972             // to make some space here.
 973             jit.makeSpaceOnStackForCCall();
 974 
 975             // Check if it is a super access
 976             GPRReg baseForCustomGetGPR = baseGPR != thisGPR ? thisGPR : baseForGetGPR;
 977 
<span class="line-modified"> 978             // getter: EncodedJSValue (*GetValueFunc)(ExecState*, EncodedJSValue thisValue, PropertyName);</span>
<span class="line-modified"> 979             // setter: void (*PutValueFunc)(ExecState*, EncodedJSValue thisObject, EncodedJSValue value);</span>
 980             // Custom values are passed the slotBase (the property holder), custom accessors are passed the thisVaule (reciever).
 981             // FIXME: Remove this differences in custom values and custom accessors.
 982             // https://bugs.webkit.org/show_bug.cgi?id=158014
 983             GPRReg baseForCustom = m_type == CustomValueGetter || m_type == CustomValueSetter ? baseForAccessGPR : baseForCustomGetGPR;


 984             if (m_type == CustomValueGetter || m_type == CustomAccessorGetter) {

 985                 jit.setupArguments&lt;PropertySlot::GetValueFunc&gt;(

 986                     CCallHelpers::CellValue(baseForCustom),
<span class="line-modified"> 987                     CCallHelpers::TrustedImmPtr(ident.impl()));</span>
 988             } else {
 989                 jit.setupArguments&lt;PutPropertySlot::PutValueFunc&gt;(

 990                     CCallHelpers::CellValue(baseForCustom),
 991                     valueRegs);
 992             }
 993             jit.storePtr(GPRInfo::callFrameRegister, &amp;vm.topCallFrame);
 994 
 995             operationCall = jit.call(OperationPtrTag);
 996             jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 997                 linkBuffer.link(operationCall, this-&gt;as&lt;GetterSetterAccessCase&gt;().m_customAccessor);
 998             });
 999 
1000             if (m_type == CustomValueGetter || m_type == CustomAccessorGetter)
1001                 jit.setupResults(valueRegs);
1002             jit.reclaimSpaceOnStackForCCall();
1003 
1004             CCallHelpers::Jump noException =
1005             jit.emitExceptionCheck(vm, CCallHelpers::InvertedExceptionCheck);
1006 
1007             state.restoreLiveRegistersFromStackForCallWithThrownException(spillState);
1008             state.emitExplicitExceptionHandler();
1009 
</pre>
<hr />
<pre>
1027             jit.loadPtr(CCallHelpers::Address(baseGPR, JSObject::butterflyOffset()), scratchGPR);
1028             jit.storeValue(
1029                 valueRegs,
1030                 CCallHelpers::Address(
1031                     scratchGPR, offsetInButterfly(m_offset) * sizeof(JSValue)));
1032         }
1033         state.succeed();
1034         return;
1035     }
1036 
1037     case Transition: {
1038         // AccessCase::transition() should have returned null if this wasn&#39;t true.
1039         RELEASE_ASSERT(GPRInfo::numberOfRegisters &gt;= 6 || !structure()-&gt;outOfLineCapacity() || structure()-&gt;outOfLineCapacity() == newStructure()-&gt;outOfLineCapacity());
1040 
1041         // NOTE: This logic is duplicated in AccessCase::doesCalls(). It&#39;s important that doesCalls() knows
1042         // exactly when this would make calls.
1043         bool allocating = newStructure()-&gt;outOfLineCapacity() != structure()-&gt;outOfLineCapacity();
1044         bool reallocating = allocating &amp;&amp; structure()-&gt;outOfLineCapacity();
1045         bool allocatingInline = allocating &amp;&amp; !structure()-&gt;couldHaveIndexingHeader();
1046 
<span class="line-modified">1047         ScratchRegisterAllocator allocator(stubInfo.patch.usedRegisters);</span>
<span class="line-modified">1048         allocator.lock(baseGPR);</span>
<span class="line-removed">1049 #if USE(JSVALUE32_64)</span>
<span class="line-removed">1050         allocator.lock(stubInfo.patch.baseTagGPR);</span>
<span class="line-removed">1051 #endif</span>
1052         allocator.lock(valueRegs);
1053         allocator.lock(scratchGPR);
1054 
1055         GPRReg scratchGPR2 = InvalidGPRReg;
1056         GPRReg scratchGPR3 = InvalidGPRReg;
1057         if (allocatingInline) {
1058             scratchGPR2 = allocator.allocateScratchGPR();
1059             scratchGPR3 = allocator.allocateScratchGPR();
1060         }
1061 
1062         ScratchRegisterAllocator::PreservedState preservedState =
1063             allocator.preserveReusedRegistersByPushing(jit, ScratchRegisterAllocator::ExtraStackSpace::SpaceForCCall);
1064 
1065         CCallHelpers::JumpList slowPath;
1066 
1067         ASSERT(structure()-&gt;transitionWatchpointSetHasBeenInvalidated());
1068 
1069         if (allocating) {
1070             size_t newSize = newStructure()-&gt;outOfLineCapacity() * sizeof(JSValue);
1071 
</pre>
<hr />
<pre>
1096                         jit.storePtr(
1097                             scratchGPR2,
1098                             CCallHelpers::Address(
1099                                 scratchGPR,
1100                                 -static_cast&lt;ptrdiff_t&gt;(offset + sizeof(JSValue) + sizeof(void*))));
1101                     }
1102                 }
1103 
1104                 for (size_t offset = oldSize; offset &lt; newSize; offset += sizeof(void*))
1105                     jit.storePtr(CCallHelpers::TrustedImmPtr(nullptr), CCallHelpers::Address(scratchGPR, -static_cast&lt;ptrdiff_t&gt;(offset + sizeof(JSValue) + sizeof(void*))));
1106             } else {
1107                 // Handle the case where we are allocating out-of-line using an operation.
1108                 RegisterSet extraRegistersToPreserve;
1109                 extraRegistersToPreserve.set(baseGPR);
1110                 extraRegistersToPreserve.set(valueRegs);
1111                 AccessGenerationState::SpillState spillState = state.preserveLiveRegistersToStackForCall(extraRegistersToPreserve);
1112 
1113                 jit.store32(
1114                     CCallHelpers::TrustedImm32(
1115                         state.callSiteIndexForExceptionHandlingOrOriginal().bits()),
<span class="line-modified">1116                     CCallHelpers::tagFor(static_cast&lt;VirtualRegister&gt;(CallFrameSlot::argumentCount)));</span>
1117 
1118                 jit.makeSpaceOnStackForCCall();
1119 
1120                 if (!reallocating) {
<span class="line-modified">1121                     jit.setupArguments&lt;decltype(operationReallocateButterflyToHavePropertyStorageWithInitialCapacity)&gt;(baseGPR);</span>

1122 
1123                     CCallHelpers::Call operationCall = jit.call(OperationPtrTag);
1124                     jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
1125                         linkBuffer.link(
1126                             operationCall,
1127                             FunctionPtr&lt;OperationPtrTag&gt;(operationReallocateButterflyToHavePropertyStorageWithInitialCapacity));
1128                     });
1129                 } else {
1130                     // Handle the case where we are reallocating (i.e. the old structure/butterfly
1131                     // already had out-of-line property storage).
<span class="line-modified">1132                     jit.setupArguments&lt;decltype(operationReallocateButterflyToGrowPropertyStorage)&gt;(</span>
<span class="line-modified">1133                         baseGPR, CCallHelpers::TrustedImm32(newSize / sizeof(JSValue)));</span>
1134 
1135                     CCallHelpers::Call operationCall = jit.call(OperationPtrTag);
1136                     jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
1137                         linkBuffer.link(
1138                             operationCall,
1139                             FunctionPtr&lt;OperationPtrTag&gt;(operationReallocateButterflyToGrowPropertyStorage));
1140                     });
1141                 }
1142 
1143                 jit.reclaimSpaceOnStackForCCall();
1144                 jit.move(GPRInfo::returnValueGPR, scratchGPR);
1145 
1146                 CCallHelpers::Jump noException = jit.emitExceptionCheck(vm, CCallHelpers::InvertedExceptionCheck);
1147 
1148                 state.restoreLiveRegistersFromStackForCallWithThrownException(spillState);
1149                 state.emitExplicitExceptionHandler();
1150 
1151                 noException.link(&amp;jit);
1152                 RegisterSet resultRegisterToExclude;
1153                 resultRegisterToExclude.set(scratchGPR);
</pre>
<hr />
<pre>
1228     case IntrinsicGetter: {
1229         RELEASE_ASSERT(isValidOffset(offset()));
1230 
1231         // We need to ensure the getter value does not move from under us. Note that GetterSetters
1232         // are immutable so we just need to watch the property not any value inside it.
1233         Structure* currStructure;
1234         if (!hasAlternateBase())
1235             currStructure = structure();
1236         else
1237             currStructure = alternateBase()-&gt;structure(vm);
1238         currStructure-&gt;startWatchingPropertyForReplacements(vm, offset());
1239 
1240         this-&gt;as&lt;IntrinsicGetterAccessCase&gt;().emitIntrinsicGetter(state);
1241         return;
1242     }
1243 
1244     case DirectArgumentsLength:
1245     case ScopedArgumentsLength:
1246     case ModuleNamespaceLoad:
1247     case InstanceOfGeneric:
















1248         // These need to be handled by generateWithGuard(), since the guard is part of the
1249         // algorithm. We can be sure that nobody will call generate() directly for these since they
1250         // are not guarded by structure checks.
1251         RELEASE_ASSERT_NOT_REACHED();
1252     }
1253 
1254     RELEASE_ASSERT_NOT_REACHED();
1255 }
1256 






































1257 } // namespace JSC
1258 
1259 #endif
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2017-2020 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;AccessCase.h&quot;
  28 
  29 #if ENABLE(JIT)
  30 
  31 #include &quot;CCallHelpers.h&quot;
<span class="line-added">  32 #include &quot;CacheableIdentifierInlines.h&quot;</span>
  33 #include &quot;CallLinkInfo.h&quot;
  34 #include &quot;DOMJITGetterSetter.h&quot;
  35 #include &quot;DirectArguments.h&quot;
  36 #include &quot;GetterSetter.h&quot;
  37 #include &quot;GetterSetterAccessCase.h&quot;
  38 #include &quot;InstanceOfAccessCase.h&quot;
  39 #include &quot;IntrinsicGetterAccessCase.h&quot;
  40 #include &quot;JSCInlines.h&quot;
  41 #include &quot;JSModuleEnvironment.h&quot;
  42 #include &quot;JSModuleNamespaceObject.h&quot;
  43 #include &quot;LinkBuffer.h&quot;
  44 #include &quot;ModuleNamespaceAccessCase.h&quot;
  45 #include &quot;PolymorphicAccess.h&quot;
  46 #include &quot;ScopedArguments.h&quot;
  47 #include &quot;ScratchRegisterAllocator.h&quot;
  48 #include &quot;StructureStubInfo.h&quot;
  49 #include &quot;SuperSampler.h&quot;
  50 #include &quot;ThunkGenerators.h&quot;
  51 
  52 namespace JSC {
  53 
  54 namespace AccessCaseInternal {
<span class="line-modified">  55 static constexpr bool verbose = false;</span>
  56 }
  57 
<span class="line-modified">  58 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(AccessCase);</span>
<span class="line-added">  59 </span>
<span class="line-added">  60 AccessCase::AccessCase(VM&amp; vm, JSCell* owner, AccessType type, CacheableIdentifier identifier, PropertyOffset offset, Structure* structure, const ObjectPropertyConditionSet&amp; conditionSet, std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain)</span>
  61     : m_type(type)
  62     , m_offset(offset)
  63     , m_polyProtoAccessChain(WTFMove(prototypeAccessChain))
<span class="line-added">  64     , m_identifier(identifier)</span>
  65 {
  66     m_structure.setMayBeNull(vm, owner, structure);
  67     m_conditionSet = conditionSet;
<span class="line-added">  68     RELEASE_ASSERT(m_conditionSet.isValid());</span>
  69 }
  70 
<span class="line-modified">  71 std::unique_ptr&lt;AccessCase&gt; AccessCase::create(VM&amp; vm, JSCell* owner, AccessType type, CacheableIdentifier identifier, PropertyOffset offset, Structure* structure, const ObjectPropertyConditionSet&amp; conditionSet, std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain)</span>
  72 {
  73     switch (type) {
  74     case InHit:
  75     case InMiss:
  76         break;
  77     case ArrayLength:
  78     case StringLength:
  79     case DirectArgumentsLength:
  80     case ScopedArgumentsLength:
  81     case ModuleNamespaceLoad:
  82     case Replace:
  83     case InstanceOfGeneric:
<span class="line-added">  84     case IndexedInt32Load:</span>
<span class="line-added">  85     case IndexedDoubleLoad:</span>
<span class="line-added">  86     case IndexedContiguousLoad:</span>
<span class="line-added">  87     case IndexedArrayStorageLoad:</span>
<span class="line-added">  88     case IndexedScopedArgumentsLoad:</span>
<span class="line-added">  89     case IndexedDirectArgumentsLoad:</span>
<span class="line-added">  90     case IndexedTypedArrayInt8Load:</span>
<span class="line-added">  91     case IndexedTypedArrayUint8Load:</span>
<span class="line-added">  92     case IndexedTypedArrayUint8ClampedLoad:</span>
<span class="line-added">  93     case IndexedTypedArrayInt16Load:</span>
<span class="line-added">  94     case IndexedTypedArrayUint16Load:</span>
<span class="line-added">  95     case IndexedTypedArrayInt32Load:</span>
<span class="line-added">  96     case IndexedTypedArrayUint32Load:</span>
<span class="line-added">  97     case IndexedTypedArrayFloat32Load:</span>
<span class="line-added">  98     case IndexedTypedArrayFloat64Load:</span>
<span class="line-added">  99     case IndexedStringLoad:</span>
 100         RELEASE_ASSERT(!prototypeAccessChain);
 101         break;
 102     default:
 103         RELEASE_ASSERT_NOT_REACHED();
 104     };
 105 
<span class="line-modified"> 106     return std::unique_ptr&lt;AccessCase&gt;(new AccessCase(vm, owner, type, identifier, offset, structure, conditionSet, WTFMove(prototypeAccessChain)));</span>
 107 }
 108 
 109 std::unique_ptr&lt;AccessCase&gt; AccessCase::create(
<span class="line-modified"> 110     VM&amp; vm, JSCell* owner, CacheableIdentifier identifier, PropertyOffset offset, Structure* oldStructure, Structure* newStructure,</span>
 111     const ObjectPropertyConditionSet&amp; conditionSet, std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain)
 112 {
 113     RELEASE_ASSERT(oldStructure == newStructure-&gt;previousID());
 114 
 115     // Skip optimizing the case where we need a realloc, if we don&#39;t have
 116     // enough registers to make it happen.
 117     if (GPRInfo::numberOfRegisters &lt; 6
 118         &amp;&amp; oldStructure-&gt;outOfLineCapacity() != newStructure-&gt;outOfLineCapacity()
 119         &amp;&amp; oldStructure-&gt;outOfLineCapacity()) {
 120         return nullptr;
 121     }
 122 
<span class="line-modified"> 123     return std::unique_ptr&lt;AccessCase&gt;(new AccessCase(vm, owner, Transition, identifier, offset, newStructure, conditionSet, WTFMove(prototypeAccessChain)));</span>
 124 }
 125 
 126 AccessCase::~AccessCase()
 127 {
 128 }
 129 
 130 std::unique_ptr&lt;AccessCase&gt; AccessCase::fromStructureStubInfo(
<span class="line-modified"> 131     VM&amp; vm, JSCell* owner, CacheableIdentifier identifier, StructureStubInfo&amp; stubInfo)</span>
 132 {
<span class="line-modified"> 133     switch (stubInfo.cacheType()) {</span>
 134     case CacheType::GetByIdSelf:
<span class="line-modified"> 135         RELEASE_ASSERT(stubInfo.hasConstantIdentifier);</span>
<span class="line-added"> 136         return ProxyableAccessCase::create(vm, owner, Load, identifier, stubInfo.u.byIdSelf.offset, stubInfo.u.byIdSelf.baseObjectStructure.get());</span>
 137 
 138     case CacheType::PutByIdReplace:
<span class="line-modified"> 139         RELEASE_ASSERT(stubInfo.hasConstantIdentifier);</span>
<span class="line-added"> 140         ASSERT(!identifier.isCell());</span>
<span class="line-added"> 141         return AccessCase::create(vm, owner, Replace, identifier, stubInfo.u.byIdSelf.offset, stubInfo.u.byIdSelf.baseObjectStructure.get());</span>
 142 
 143     case CacheType::InByIdSelf:
<span class="line-modified"> 144         RELEASE_ASSERT(stubInfo.hasConstantIdentifier);</span>
<span class="line-added"> 145         ASSERT(!identifier.isCell());</span>
<span class="line-added"> 146         return AccessCase::create(vm, owner, InHit, identifier, stubInfo.u.byIdSelf.offset, stubInfo.u.byIdSelf.baseObjectStructure.get());</span>
 147 
 148     case CacheType::ArrayLength:
<span class="line-modified"> 149         RELEASE_ASSERT(stubInfo.hasConstantIdentifier);</span>
<span class="line-added"> 150         ASSERT(!identifier.isCell());</span>
<span class="line-added"> 151         return AccessCase::create(vm, owner, AccessCase::ArrayLength, identifier);</span>
 152 
 153     case CacheType::StringLength:
<span class="line-modified"> 154         RELEASE_ASSERT(stubInfo.hasConstantIdentifier);</span>
<span class="line-added"> 155         ASSERT(!identifier.isCell());</span>
<span class="line-added"> 156         return AccessCase::create(vm, owner, AccessCase::StringLength, identifier);</span>
 157 
 158     default:
 159         return nullptr;
 160     }
 161 }
 162 
 163 bool AccessCase::hasAlternateBase() const
 164 {
 165     return !conditionSet().isEmpty();
 166 }
 167 
 168 JSObject* AccessCase::alternateBase() const
 169 {
 170     return conditionSet().slotBaseCondition().object();
 171 }
 172 
 173 std::unique_ptr&lt;AccessCase&gt; AccessCase::clone() const
 174 {
 175     std::unique_ptr&lt;AccessCase&gt; result(new AccessCase(*this));
 176     result-&gt;resetState();
 177     return result;
 178 }
 179 
<span class="line-modified"> 180 Vector&lt;WatchpointSet*, 2&gt; AccessCase::commit(VM&amp; vm)</span>
 181 {
 182     // It&#39;s fine to commit something that is already committed. That arises when we switch to using
 183     // newly allocated watchpoints. When it happens, it&#39;s not efficient - but we think that&#39;s OK
 184     // because most AccessCases have no extra watchpoints anyway.
 185     RELEASE_ASSERT(m_state == Primordial || m_state == Committed);
 186 
 187     Vector&lt;WatchpointSet*, 2&gt; result;
 188     Structure* structure = this-&gt;structure();
 189 
<span class="line-modified"> 190     if (m_identifier) {</span>
 191         if ((structure &amp;&amp; structure-&gt;needImpurePropertyWatchpoint())
 192             || m_conditionSet.needImpurePropertyWatchpoint()
<span class="line-modified"> 193             || (m_polyProtoAccessChain &amp;&amp; m_polyProtoAccessChain-&gt;needImpurePropertyWatchpoint(vm)))</span>
<span class="line-modified"> 194             result.append(vm.ensureWatchpointSetForImpureProperty(m_identifier.uid()));</span>
 195     }
 196 
 197     if (additionalSet())
 198         result.append(additionalSet());
 199 
 200     if (structure
 201         &amp;&amp; structure-&gt;hasRareData()
 202         &amp;&amp; structure-&gt;rareData()-&gt;hasSharedPolyProtoWatchpoint()
 203         &amp;&amp; structure-&gt;rareData()-&gt;sharedPolyProtoWatchpoint()-&gt;isStillValid()) {
 204         WatchpointSet* set = structure-&gt;rareData()-&gt;sharedPolyProtoWatchpoint()-&gt;inflate();
 205         result.append(set);
 206     }
 207 
 208     m_state = Committed;
 209 
 210     return result;
 211 }
 212 
<span class="line-modified"> 213 bool AccessCase::guardedByStructureCheck(const StructureStubInfo&amp; stubInfo) const</span>
<span class="line-added"> 214 {</span>
<span class="line-added"> 215     if (!stubInfo.hasConstantIdentifier)</span>
<span class="line-added"> 216         return false;</span>
<span class="line-added"> 217     return guardedByStructureCheckSkippingConstantIdentifierCheck();</span>
<span class="line-added"> 218 }</span>
<span class="line-added"> 219 </span>
<span class="line-added"> 220 bool AccessCase::guardedByStructureCheckSkippingConstantIdentifierCheck() const</span>
 221 {
 222     if (viaProxy())
 223         return false;
 224 
 225     if (m_polyProtoAccessChain)
 226         return false;
 227 
 228     switch (m_type) {
 229     case ArrayLength:
 230     case StringLength:
 231     case DirectArgumentsLength:
 232     case ScopedArgumentsLength:
 233     case ModuleNamespaceLoad:
 234     case InstanceOfHit:
 235     case InstanceOfMiss:
 236     case InstanceOfGeneric:
<span class="line-added"> 237     case IndexedInt32Load:</span>
<span class="line-added"> 238     case IndexedDoubleLoad:</span>
<span class="line-added"> 239     case IndexedContiguousLoad:</span>
<span class="line-added"> 240     case IndexedArrayStorageLoad:</span>
<span class="line-added"> 241     case IndexedScopedArgumentsLoad:</span>
<span class="line-added"> 242     case IndexedDirectArgumentsLoad:</span>
<span class="line-added"> 243     case IndexedTypedArrayInt8Load:</span>
<span class="line-added"> 244     case IndexedTypedArrayUint8Load:</span>
<span class="line-added"> 245     case IndexedTypedArrayUint8ClampedLoad:</span>
<span class="line-added"> 246     case IndexedTypedArrayInt16Load:</span>
<span class="line-added"> 247     case IndexedTypedArrayUint16Load:</span>
<span class="line-added"> 248     case IndexedTypedArrayInt32Load:</span>
<span class="line-added"> 249     case IndexedTypedArrayUint32Load:</span>
<span class="line-added"> 250     case IndexedTypedArrayFloat32Load:</span>
<span class="line-added"> 251     case IndexedTypedArrayFloat64Load:</span>
<span class="line-added"> 252     case IndexedStringLoad:</span>
 253         return false;
 254     default:
 255         return true;
 256     }
 257 }
 258 
<span class="line-modified"> 259 bool AccessCase::requiresIdentifierNameMatch() const</span>
 260 {
<span class="line-modified"> 261     switch (m_type) {</span>
<span class="line-added"> 262     case Load:</span>
<span class="line-added"> 263     // We don&#39;t currently have a by_val for these puts, but we do care about the identifier.</span>
<span class="line-added"> 264     case Transition:</span>
<span class="line-added"> 265     case Replace:</span>
<span class="line-added"> 266     case Miss:</span>
<span class="line-added"> 267     case GetGetter:</span>
 268     case Getter:
 269     case Setter:
 270     case CustomValueGetter:
 271     case CustomAccessorGetter:
 272     case CustomValueSetter:
 273     case CustomAccessorSetter:
<span class="line-added"> 274     case IntrinsicGetter:</span>
<span class="line-added"> 275     case InHit:</span>
<span class="line-added"> 276     case InMiss:</span>
<span class="line-added"> 277     case ArrayLength:</span>
<span class="line-added"> 278     case StringLength:</span>
<span class="line-added"> 279     case DirectArgumentsLength:</span>
<span class="line-added"> 280     case ScopedArgumentsLength:</span>
<span class="line-added"> 281     case ModuleNamespaceLoad:</span>
 282         return true;
<span class="line-added"> 283     case InstanceOfHit:</span>
<span class="line-added"> 284     case InstanceOfMiss:</span>
<span class="line-added"> 285     case InstanceOfGeneric:</span>
<span class="line-added"> 286     case IndexedInt32Load:</span>
<span class="line-added"> 287     case IndexedDoubleLoad:</span>
<span class="line-added"> 288     case IndexedContiguousLoad:</span>
<span class="line-added"> 289     case IndexedArrayStorageLoad:</span>
<span class="line-added"> 290     case IndexedScopedArgumentsLoad:</span>
<span class="line-added"> 291     case IndexedDirectArgumentsLoad:</span>
<span class="line-added"> 292     case IndexedTypedArrayInt8Load:</span>
<span class="line-added"> 293     case IndexedTypedArrayUint8Load:</span>
<span class="line-added"> 294     case IndexedTypedArrayUint8ClampedLoad:</span>
<span class="line-added"> 295     case IndexedTypedArrayInt16Load:</span>
<span class="line-added"> 296     case IndexedTypedArrayUint16Load:</span>
<span class="line-added"> 297     case IndexedTypedArrayInt32Load:</span>
<span class="line-added"> 298     case IndexedTypedArrayUint32Load:</span>
<span class="line-added"> 299     case IndexedTypedArrayFloat32Load:</span>
<span class="line-added"> 300     case IndexedTypedArrayFloat64Load:</span>
<span class="line-added"> 301     case IndexedStringLoad:</span>
<span class="line-added"> 302         return false;</span>
<span class="line-added"> 303     }</span>
<span class="line-added"> 304     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added"> 305 }</span>
<span class="line-added"> 306 </span>
<span class="line-added"> 307 bool AccessCase::requiresInt32PropertyCheck() const</span>
<span class="line-added"> 308 {</span>
<span class="line-added"> 309     switch (m_type) {</span>
<span class="line-added"> 310     case Load:</span>
 311     case Transition:
<span class="line-modified"> 312     case Replace:</span>
<span class="line-modified"> 313     case Miss:</span>
<span class="line-modified"> 314     case GetGetter:</span>
<span class="line-modified"> 315     case Getter:</span>
<span class="line-modified"> 316     case Setter:</span>
<span class="line-modified"> 317     case CustomValueGetter:</span>
<span class="line-added"> 318     case CustomAccessorGetter:</span>
<span class="line-added"> 319     case CustomValueSetter:</span>
<span class="line-added"> 320     case CustomAccessorSetter:</span>
<span class="line-added"> 321     case IntrinsicGetter:</span>
<span class="line-added"> 322     case InHit:</span>
<span class="line-added"> 323     case InMiss:</span>
<span class="line-added"> 324     case ArrayLength:</span>
<span class="line-added"> 325     case StringLength:</span>
<span class="line-added"> 326     case DirectArgumentsLength:</span>
<span class="line-added"> 327     case ScopedArgumentsLength:</span>
<span class="line-added"> 328     case ModuleNamespaceLoad:</span>
<span class="line-added"> 329     case InstanceOfHit:</span>
<span class="line-added"> 330     case InstanceOfMiss:</span>
<span class="line-added"> 331     case InstanceOfGeneric:</span>
 332         return false;
<span class="line-modified"> 333     case IndexedInt32Load:</span>
<span class="line-added"> 334     case IndexedDoubleLoad:</span>
<span class="line-added"> 335     case IndexedContiguousLoad:</span>
<span class="line-added"> 336     case IndexedArrayStorageLoad:</span>
<span class="line-added"> 337     case IndexedScopedArgumentsLoad:</span>
<span class="line-added"> 338     case IndexedDirectArgumentsLoad:</span>
<span class="line-added"> 339     case IndexedTypedArrayInt8Load:</span>
<span class="line-added"> 340     case IndexedTypedArrayUint8Load:</span>
<span class="line-added"> 341     case IndexedTypedArrayUint8ClampedLoad:</span>
<span class="line-added"> 342     case IndexedTypedArrayInt16Load:</span>
<span class="line-added"> 343     case IndexedTypedArrayUint16Load:</span>
<span class="line-added"> 344     case IndexedTypedArrayInt32Load:</span>
<span class="line-added"> 345     case IndexedTypedArrayUint32Load:</span>
<span class="line-added"> 346     case IndexedTypedArrayFloat32Load:</span>
<span class="line-added"> 347     case IndexedTypedArrayFloat64Load:</span>
<span class="line-added"> 348     case IndexedStringLoad:</span>
<span class="line-added"> 349         return true;</span>
<span class="line-added"> 350     }</span>
<span class="line-added"> 351     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added"> 352 }</span>
<span class="line-added"> 353 </span>
<span class="line-added"> 354 bool AccessCase::needsScratchFPR() const</span>
<span class="line-added"> 355 {</span>
<span class="line-added"> 356     switch (m_type) {</span>
<span class="line-added"> 357     case Load:</span>
<span class="line-added"> 358     case Transition:</span>
<span class="line-added"> 359     case Replace:</span>
<span class="line-added"> 360     case Miss:</span>
<span class="line-added"> 361     case GetGetter:</span>
<span class="line-added"> 362     case Getter:</span>
<span class="line-added"> 363     case Setter:</span>
<span class="line-added"> 364     case CustomValueGetter:</span>
<span class="line-added"> 365     case CustomAccessorGetter:</span>
<span class="line-added"> 366     case CustomValueSetter:</span>
<span class="line-added"> 367     case CustomAccessorSetter:</span>
<span class="line-added"> 368     case IntrinsicGetter:</span>
<span class="line-added"> 369     case InHit:</span>
<span class="line-added"> 370     case InMiss:</span>
<span class="line-added"> 371     case ArrayLength:</span>
<span class="line-added"> 372     case StringLength:</span>
<span class="line-added"> 373     case DirectArgumentsLength:</span>
<span class="line-added"> 374     case ScopedArgumentsLength:</span>
<span class="line-added"> 375     case ModuleNamespaceLoad:</span>
<span class="line-added"> 376     case InstanceOfHit:</span>
<span class="line-added"> 377     case InstanceOfMiss:</span>
<span class="line-added"> 378     case InstanceOfGeneric:</span>
<span class="line-added"> 379     case IndexedInt32Load:</span>
<span class="line-added"> 380     case IndexedContiguousLoad:</span>
<span class="line-added"> 381     case IndexedArrayStorageLoad:</span>
<span class="line-added"> 382     case IndexedScopedArgumentsLoad:</span>
<span class="line-added"> 383     case IndexedDirectArgumentsLoad:</span>
<span class="line-added"> 384     case IndexedTypedArrayInt8Load:</span>
<span class="line-added"> 385     case IndexedTypedArrayUint8Load:</span>
<span class="line-added"> 386     case IndexedTypedArrayUint8ClampedLoad:</span>
<span class="line-added"> 387     case IndexedTypedArrayInt16Load:</span>
<span class="line-added"> 388     case IndexedTypedArrayUint16Load:</span>
<span class="line-added"> 389     case IndexedTypedArrayInt32Load:</span>
<span class="line-added"> 390     case IndexedStringLoad:</span>
 391         return false;
<span class="line-added"> 392     case IndexedDoubleLoad:</span>
<span class="line-added"> 393     case IndexedTypedArrayFloat32Load:</span>
<span class="line-added"> 394     case IndexedTypedArrayFloat64Load:</span>
<span class="line-added"> 395     case IndexedTypedArrayUint32Load:</span>
<span class="line-added"> 396         return true;</span>
<span class="line-added"> 397     }</span>
<span class="line-added"> 398     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added"> 399 }</span>
<span class="line-added"> 400 </span>
<span class="line-added"> 401 template&lt;typename Functor&gt;</span>
<span class="line-added"> 402 void AccessCase::forEachDependentCell(VM&amp; vm, const Functor&amp; functor) const</span>
<span class="line-added"> 403 {</span>
<span class="line-added"> 404     m_conditionSet.forEachDependentCell(functor);</span>
<span class="line-added"> 405     if (m_structure)</span>
<span class="line-added"> 406         functor(m_structure.get());</span>
<span class="line-added"> 407     if (m_polyProtoAccessChain) {</span>
<span class="line-added"> 408         for (StructureID structureID : m_polyProtoAccessChain-&gt;chain())</span>
<span class="line-added"> 409             functor(vm.getStructure(structureID));</span>
<span class="line-added"> 410     }</span>
<span class="line-added"> 411 </span>
<span class="line-added"> 412     switch (type()) {</span>
<span class="line-added"> 413     case Getter:</span>
<span class="line-added"> 414     case Setter: {</span>
<span class="line-added"> 415         auto&amp; accessor = this-&gt;as&lt;GetterSetterAccessCase&gt;();</span>
<span class="line-added"> 416         if (accessor.callLinkInfo())</span>
<span class="line-added"> 417             accessor.callLinkInfo()-&gt;forEachDependentCell(functor);</span>
<span class="line-added"> 418         break;</span>
<span class="line-added"> 419     }</span>
<span class="line-added"> 420     case CustomValueGetter:</span>
<span class="line-added"> 421     case CustomValueSetter: {</span>
<span class="line-added"> 422         auto&amp; accessor = this-&gt;as&lt;GetterSetterAccessCase&gt;();</span>
<span class="line-added"> 423         if (accessor.customSlotBase())</span>
<span class="line-added"> 424             functor(accessor.customSlotBase());</span>
<span class="line-added"> 425         break;</span>
<span class="line-added"> 426     }</span>
<span class="line-added"> 427     case IntrinsicGetter: {</span>
<span class="line-added"> 428         auto&amp; intrinsic = this-&gt;as&lt;IntrinsicGetterAccessCase&gt;();</span>
<span class="line-added"> 429         if (intrinsic.intrinsicFunction())</span>
<span class="line-added"> 430             functor(intrinsic.intrinsicFunction());</span>
<span class="line-added"> 431         break;</span>
<span class="line-added"> 432     }</span>
<span class="line-added"> 433     case ModuleNamespaceLoad: {</span>
<span class="line-added"> 434         auto&amp; accessCase = this-&gt;as&lt;ModuleNamespaceAccessCase&gt;();</span>
<span class="line-added"> 435         if (accessCase.moduleNamespaceObject())</span>
<span class="line-added"> 436             functor(accessCase.moduleNamespaceObject());</span>
<span class="line-added"> 437         if (accessCase.moduleEnvironment())</span>
<span class="line-added"> 438             functor(accessCase.moduleEnvironment());</span>
<span class="line-added"> 439         break;</span>
<span class="line-added"> 440     }</span>
<span class="line-added"> 441     case InstanceOfHit:</span>
<span class="line-added"> 442     case InstanceOfMiss:</span>
<span class="line-added"> 443         if (as&lt;InstanceOfAccessCase&gt;().prototype())</span>
<span class="line-added"> 444             functor(as&lt;InstanceOfAccessCase&gt;().prototype());</span>
<span class="line-added"> 445         break;</span>
<span class="line-added"> 446     case CustomAccessorGetter:</span>
<span class="line-added"> 447     case CustomAccessorSetter:</span>
<span class="line-added"> 448     case Load:</span>
<span class="line-added"> 449     case Transition:</span>
<span class="line-added"> 450     case Replace:</span>
<span class="line-added"> 451     case Miss:</span>
<span class="line-added"> 452     case GetGetter:</span>
<span class="line-added"> 453     case InHit:</span>
<span class="line-added"> 454     case InMiss:</span>
<span class="line-added"> 455     case ArrayLength:</span>
<span class="line-added"> 456     case StringLength:</span>
<span class="line-added"> 457     case DirectArgumentsLength:</span>
<span class="line-added"> 458     case ScopedArgumentsLength:</span>
<span class="line-added"> 459     case InstanceOfGeneric:</span>
<span class="line-added"> 460     case IndexedInt32Load:</span>
<span class="line-added"> 461     case IndexedDoubleLoad:</span>
<span class="line-added"> 462     case IndexedContiguousLoad:</span>
<span class="line-added"> 463     case IndexedArrayStorageLoad:</span>
<span class="line-added"> 464     case IndexedScopedArgumentsLoad:</span>
<span class="line-added"> 465     case IndexedDirectArgumentsLoad:</span>
<span class="line-added"> 466     case IndexedTypedArrayInt8Load:</span>
<span class="line-added"> 467     case IndexedTypedArrayUint8Load:</span>
<span class="line-added"> 468     case IndexedTypedArrayUint8ClampedLoad:</span>
<span class="line-added"> 469     case IndexedTypedArrayInt16Load:</span>
<span class="line-added"> 470     case IndexedTypedArrayUint16Load:</span>
<span class="line-added"> 471     case IndexedTypedArrayInt32Load:</span>
<span class="line-added"> 472     case IndexedTypedArrayUint32Load:</span>
<span class="line-added"> 473     case IndexedTypedArrayFloat32Load:</span>
<span class="line-added"> 474     case IndexedTypedArrayFloat64Load:</span>
<span class="line-added"> 475     case IndexedStringLoad:</span>
<span class="line-added"> 476         break;</span>
 477     }
 478 }
 479 
<span class="line-added"> 480 bool AccessCase::doesCalls(VM&amp; vm, Vector&lt;JSCell*&gt;* cellsToMarkIfDoesCalls) const</span>
<span class="line-added"> 481 {</span>
<span class="line-added"> 482     bool doesCalls = false;</span>
<span class="line-added"> 483     switch (type()) {</span>
<span class="line-added"> 484     case Transition:</span>
<span class="line-added"> 485         doesCalls = newStructure()-&gt;outOfLineCapacity() != structure()-&gt;outOfLineCapacity() &amp;&amp; structure()-&gt;couldHaveIndexingHeader();</span>
<span class="line-added"> 486         break;</span>
<span class="line-added"> 487     case Getter:</span>
<span class="line-added"> 488     case Setter:</span>
<span class="line-added"> 489     case CustomValueGetter:</span>
<span class="line-added"> 490     case CustomAccessorGetter:</span>
<span class="line-added"> 491     case CustomValueSetter:</span>
<span class="line-added"> 492     case CustomAccessorSetter:</span>
<span class="line-added"> 493         doesCalls = true;</span>
<span class="line-added"> 494         break;</span>
<span class="line-added"> 495     case Load:</span>
<span class="line-added"> 496     case Replace:</span>
<span class="line-added"> 497     case Miss:</span>
<span class="line-added"> 498     case GetGetter:</span>
<span class="line-added"> 499     case IntrinsicGetter:</span>
<span class="line-added"> 500     case InHit:</span>
<span class="line-added"> 501     case InMiss:</span>
<span class="line-added"> 502     case ArrayLength:</span>
<span class="line-added"> 503     case StringLength:</span>
<span class="line-added"> 504     case DirectArgumentsLength:</span>
<span class="line-added"> 505     case ScopedArgumentsLength:</span>
<span class="line-added"> 506     case ModuleNamespaceLoad:</span>
<span class="line-added"> 507     case InstanceOfHit:</span>
<span class="line-added"> 508     case InstanceOfMiss:</span>
<span class="line-added"> 509     case InstanceOfGeneric:</span>
<span class="line-added"> 510     case IndexedInt32Load:</span>
<span class="line-added"> 511     case IndexedDoubleLoad:</span>
<span class="line-added"> 512     case IndexedContiguousLoad:</span>
<span class="line-added"> 513     case IndexedArrayStorageLoad:</span>
<span class="line-added"> 514     case IndexedScopedArgumentsLoad:</span>
<span class="line-added"> 515     case IndexedDirectArgumentsLoad:</span>
<span class="line-added"> 516     case IndexedTypedArrayInt8Load:</span>
<span class="line-added"> 517     case IndexedTypedArrayUint8Load:</span>
<span class="line-added"> 518     case IndexedTypedArrayUint8ClampedLoad:</span>
<span class="line-added"> 519     case IndexedTypedArrayInt16Load:</span>
<span class="line-added"> 520     case IndexedTypedArrayUint16Load:</span>
<span class="line-added"> 521     case IndexedTypedArrayInt32Load:</span>
<span class="line-added"> 522     case IndexedTypedArrayUint32Load:</span>
<span class="line-added"> 523     case IndexedTypedArrayFloat32Load:</span>
<span class="line-added"> 524     case IndexedTypedArrayFloat64Load:</span>
<span class="line-added"> 525     case IndexedStringLoad:</span>
<span class="line-added"> 526         doesCalls = false;</span>
<span class="line-added"> 527         break;</span>
<span class="line-added"> 528     }</span>
<span class="line-added"> 529 </span>
<span class="line-added"> 530     if (doesCalls &amp;&amp; cellsToMarkIfDoesCalls) {</span>
<span class="line-added"> 531         forEachDependentCell(vm, [&amp;](JSCell* cell) {</span>
<span class="line-added"> 532             cellsToMarkIfDoesCalls-&gt;append(cell);</span>
<span class="line-added"> 533         });</span>
<span class="line-added"> 534     }</span>
<span class="line-added"> 535     return doesCalls;</span>
<span class="line-added"> 536 }</span>
<span class="line-added"> 537 </span>
 538 bool AccessCase::couldStillSucceed() const
 539 {
<span class="line-modified"> 540     for (const ObjectPropertyCondition&amp; condition : m_conditionSet) {</span>
<span class="line-added"> 541         if (condition.condition().kind() == PropertyCondition::Equivalence) {</span>
<span class="line-added"> 542             if (!condition.isWatchableAssumingImpurePropertyWatchpoint(PropertyCondition::WatchabilityEffort::EnsureWatchability))</span>
<span class="line-added"> 543                 return false;</span>
<span class="line-added"> 544         } else {</span>
<span class="line-added"> 545             if (!condition.structureEnsuresValidityAssumingImpurePropertyWatchpoint())</span>
<span class="line-added"> 546                 return false;</span>
<span class="line-added"> 547         }</span>
<span class="line-added"> 548     }</span>
<span class="line-added"> 549     return true;</span>
 550 }
 551 
 552 bool AccessCase::canReplace(const AccessCase&amp; other) const
 553 {
 554     // This puts in a good effort to try to figure out if &#39;other&#39; is made superfluous by &#39;*this&#39;.
 555     // It&#39;s fine for this to return false if it&#39;s in doubt.
 556     //
 557     // Note that if A-&gt;guardedByStructureCheck() &amp;&amp; B-&gt;guardedByStructureCheck() then
 558     // A-&gt;canReplace(B) == B-&gt;canReplace(A).
 559 
<span class="line-added"> 560     if (m_identifier != other.m_identifier)</span>
<span class="line-added"> 561         return false;</span>
<span class="line-added"> 562 </span>
 563     switch (type()) {
<span class="line-added"> 564     case IndexedInt32Load:</span>
<span class="line-added"> 565     case IndexedDoubleLoad:</span>
<span class="line-added"> 566     case IndexedContiguousLoad:</span>
<span class="line-added"> 567     case IndexedArrayStorageLoad:</span>
 568     case ArrayLength:
 569     case StringLength:
 570     case DirectArgumentsLength:
 571     case ScopedArgumentsLength:
<span class="line-added"> 572     case IndexedScopedArgumentsLoad:</span>
<span class="line-added"> 573     case IndexedDirectArgumentsLoad:</span>
<span class="line-added"> 574     case IndexedTypedArrayInt8Load:</span>
<span class="line-added"> 575     case IndexedTypedArrayUint8Load:</span>
<span class="line-added"> 576     case IndexedTypedArrayUint8ClampedLoad:</span>
<span class="line-added"> 577     case IndexedTypedArrayInt16Load:</span>
<span class="line-added"> 578     case IndexedTypedArrayUint16Load:</span>
<span class="line-added"> 579     case IndexedTypedArrayInt32Load:</span>
<span class="line-added"> 580     case IndexedTypedArrayUint32Load:</span>
<span class="line-added"> 581     case IndexedTypedArrayFloat32Load:</span>
<span class="line-added"> 582     case IndexedTypedArrayFloat64Load:</span>
<span class="line-added"> 583     case IndexedStringLoad:</span>
 584         return other.type() == type();
<span class="line-added"> 585 </span>
 586     case ModuleNamespaceLoad: {
 587         if (other.type() != type())
 588             return false;
 589         auto&amp; thisCase = this-&gt;as&lt;ModuleNamespaceAccessCase&gt;();
 590         auto&amp; otherCase = this-&gt;as&lt;ModuleNamespaceAccessCase&gt;();
 591         return thisCase.moduleNamespaceObject() == otherCase.moduleNamespaceObject();
 592     }
<span class="line-added"> 593 </span>
 594     case InstanceOfHit:
 595     case InstanceOfMiss: {
 596         if (other.type() != type())
 597             return false;
 598 
 599         if (this-&gt;as&lt;InstanceOfAccessCase&gt;().prototype() != other.as&lt;InstanceOfAccessCase&gt;().prototype())
 600             return false;
 601 
 602         return structure() == other.structure();
 603     }
<span class="line-added"> 604 </span>
 605     case InstanceOfGeneric:
 606         switch (other.type()) {
 607         case InstanceOfGeneric:
 608         case InstanceOfHit:
 609         case InstanceOfMiss:
 610             return true;
 611         default:
 612             return false;
 613         }
<span class="line-modified"> 614 </span>
<span class="line-added"> 615     case Load:</span>
<span class="line-added"> 616     case Transition:</span>
<span class="line-added"> 617     case Replace:</span>
<span class="line-added"> 618     case Miss:</span>
<span class="line-added"> 619     case GetGetter:</span>
<span class="line-added"> 620     case Getter:</span>
<span class="line-added"> 621     case Setter:</span>
<span class="line-added"> 622     case CustomValueGetter:</span>
<span class="line-added"> 623     case CustomAccessorGetter:</span>
<span class="line-added"> 624     case CustomValueSetter:</span>
<span class="line-added"> 625     case CustomAccessorSetter:</span>
<span class="line-added"> 626     case IntrinsicGetter:</span>
<span class="line-added"> 627     case InHit:</span>
<span class="line-added"> 628     case InMiss:</span>
 629         if (other.type() != type())
 630             return false;
 631 
 632         if (m_polyProtoAccessChain) {
 633             if (!other.m_polyProtoAccessChain)
 634                 return false;
 635             // This is the only check we need since PolyProtoAccessChain contains the base structure.
 636             // If we ever change it to contain only the prototype chain, we&#39;ll also need to change
 637             // this to check the base structure.
 638             return structure() == other.structure()
 639                 &amp;&amp; *m_polyProtoAccessChain == *other.m_polyProtoAccessChain;
 640         }
 641 
<span class="line-modified"> 642         if (!guardedByStructureCheckSkippingConstantIdentifierCheck() || !other.guardedByStructureCheckSkippingConstantIdentifierCheck())</span>
 643             return false;
 644 
 645         return structure() == other.structure();
 646     }
<span class="line-added"> 647     RELEASE_ASSERT_NOT_REACHED();</span>
 648 }
 649 
 650 void AccessCase::dump(PrintStream&amp; out) const
 651 {
 652     out.print(&quot;\n&quot;, m_type, &quot;:(&quot;);
 653 
 654     CommaPrinter comma;
 655 
 656     out.print(comma, m_state);
 657 
<span class="line-added"> 658     out.print(comma, &quot;ident = &#39;&quot;, m_identifier, &quot;&#39;&quot;);</span>
 659     if (isValidOffset(m_offset))
 660         out.print(comma, &quot;offset = &quot;, m_offset);


 661 
 662     if (m_polyProtoAccessChain) {
 663         out.print(comma, &quot;prototype access chain = &quot;);
 664         m_polyProtoAccessChain-&gt;dump(structure(), out);
 665     } else {
 666         if (m_type == Transition)
 667             out.print(comma, &quot;structure = &quot;, pointerDump(structure()), &quot; -&gt; &quot;, pointerDump(newStructure()));
 668         else if (m_structure)
 669             out.print(comma, &quot;structure = &quot;, pointerDump(m_structure.get()));
 670     }
 671 
<span class="line-added"> 672     if (!m_conditionSet.isEmpty())</span>
<span class="line-added"> 673         out.print(comma, &quot;conditions = &quot;, m_conditionSet);</span>
<span class="line-added"> 674 </span>
 675     dumpImpl(out, comma);
 676     out.print(&quot;)&quot;);
 677 }
 678 
 679 bool AccessCase::visitWeak(VM&amp; vm) const
 680 {










 681     if (isAccessor()) {
 682         auto&amp; accessor = this-&gt;as&lt;GetterSetterAccessCase&gt;();
 683         if (accessor.callLinkInfo())
 684             accessor.callLinkInfo()-&gt;visitWeak(vm);















 685     }
 686 
<span class="line-modified"> 687     bool isValid = true;</span>
<span class="line-added"> 688     forEachDependentCell(vm, [&amp;](JSCell* cell) {</span>
<span class="line-added"> 689         isValid &amp;= vm.heap.isMarked(cell);</span>
<span class="line-added"> 690     });</span>
<span class="line-added"> 691     return isValid;</span>
 692 }
 693 
 694 bool AccessCase::propagateTransitions(SlotVisitor&amp; visitor) const
 695 {
 696     bool result = true;
 697 
 698     if (m_structure)
 699         result &amp;= m_structure-&gt;markIfCheap(visitor);
 700 
 701     if (m_polyProtoAccessChain) {
<span class="line-modified"> 702         for (StructureID structureID : m_polyProtoAccessChain-&gt;chain())</span>
<span class="line-modified"> 703             result &amp;= visitor.vm().getStructure(structureID)-&gt;markIfCheap(visitor);</span>
 704     }
 705 
 706     switch (m_type) {
 707     case Transition:
 708         if (visitor.vm().heap.isMarked(m_structure-&gt;previousID()))
 709             visitor.appendUnbarriered(m_structure.get());
 710         else
 711             result = false;
 712         break;
 713     default:
 714         break;
 715     }
 716 
 717     return result;
 718 }
 719 
<span class="line-added"> 720 void AccessCase::visitAggregate(SlotVisitor&amp; visitor) const</span>
<span class="line-added"> 721 {</span>
<span class="line-added"> 722     m_identifier.visitAggregate(visitor);</span>
<span class="line-added"> 723 }</span>
<span class="line-added"> 724 </span>
 725 void AccessCase::generateWithGuard(
 726     AccessGenerationState&amp; state, CCallHelpers::JumpList&amp; fallThrough)
 727 {
 728     SuperSamplerScope superSamplerScope(false);
 729 
<span class="line-added"> 730     checkConsistency(*state.stubInfo);</span>
<span class="line-added"> 731 </span>
 732     RELEASE_ASSERT(m_state == Committed);
 733     m_state = Generated;
 734 
 735     CCallHelpers&amp; jit = *state.jit;
 736     StructureStubInfo&amp; stubInfo = *state.stubInfo;
 737     VM&amp; vm = state.m_vm;
 738     JSValueRegs valueRegs = state.valueRegs;
 739     GPRReg baseGPR = state.baseGPR;

 740     GPRReg scratchGPR = state.scratchGPR;
 741 
<span class="line-modified"> 742     if (requiresIdentifierNameMatch() &amp;&amp; !stubInfo.hasConstantIdentifier) {</span>
<span class="line-added"> 743         RELEASE_ASSERT(m_identifier);</span>
<span class="line-added"> 744         GPRReg propertyGPR = state.u.propertyGPR;</span>
<span class="line-added"> 745         // non-rope string check done inside polymorphic access.</span>
<span class="line-added"> 746 </span>
<span class="line-added"> 747         if (uid()-&gt;isSymbol())</span>
<span class="line-added"> 748             jit.loadPtr(MacroAssembler::Address(propertyGPR, Symbol::offsetOfSymbolImpl()), scratchGPR);</span>
<span class="line-added"> 749         else</span>
<span class="line-added"> 750             jit.loadPtr(MacroAssembler::Address(propertyGPR, JSString::offsetOfValue()), scratchGPR);</span>
<span class="line-added"> 751         fallThrough.append(jit.branchPtr(CCallHelpers::NotEqual, scratchGPR, CCallHelpers::TrustedImmPtr(uid())));</span>
<span class="line-added"> 752     }</span>
 753 
 754     auto emitDefaultGuard = [&amp;] () {
 755         if (m_polyProtoAccessChain) {
 756             GPRReg baseForAccessGPR = state.scratchGPR;
 757             jit.move(state.baseGPR, baseForAccessGPR);
<span class="line-modified"> 758             m_polyProtoAccessChain-&gt;forEach(vm, structure(), [&amp;] (Structure* structure, bool atEnd) {</span>
 759                 fallThrough.append(
 760                     jit.branchStructure(
 761                         CCallHelpers::NotEqual,
 762                         CCallHelpers::Address(baseForAccessGPR, JSCell::structureIDOffset()),
 763                         structure));
 764                 if (atEnd) {
 765                     if ((m_type == Miss || m_type == InMiss || m_type == Transition) &amp;&amp; structure-&gt;hasPolyProto()) {
 766                         // For a Miss/InMiss/Transition, we must ensure we&#39;re at the end when the last item is poly proto.
 767                         // Transitions must do this because they need to verify there isn&#39;t a setter in the chain.
 768                         // Miss/InMiss need to do this to ensure there isn&#39;t a new item at the end of the chain that
 769                         // has the property.
 770 #if USE(JSVALUE64)
 771                         jit.load64(MacroAssembler::Address(baseForAccessGPR, offsetRelativeToBase(knownPolyProtoOffset)), baseForAccessGPR);
<span class="line-modified"> 772                         fallThrough.append(jit.branch64(CCallHelpers::NotEqual, baseForAccessGPR, CCallHelpers::TrustedImm64(JSValue::ValueNull)));</span>
 773 #else
 774                         jit.load32(MacroAssembler::Address(baseForAccessGPR, offsetRelativeToBase(knownPolyProtoOffset) + PayloadOffset), baseForAccessGPR);
 775                         fallThrough.append(jit.branchTestPtr(CCallHelpers::NonZero, baseForAccessGPR));
 776 #endif
 777                     }
 778                 } else {
 779                     if (structure-&gt;hasMonoProto()) {
 780                         JSValue prototype = structure-&gt;prototypeForLookup(state.m_globalObject);
 781                         RELEASE_ASSERT(prototype.isObject());
 782                         jit.move(CCallHelpers::TrustedImmPtr(asObject(prototype)), baseForAccessGPR);
 783                     } else {
 784                         RELEASE_ASSERT(structure-&gt;isObject()); // Primitives must have a stored prototype. We use prototypeForLookup for them.
 785 #if USE(JSVALUE64)
 786                         jit.load64(MacroAssembler::Address(baseForAccessGPR, offsetRelativeToBase(knownPolyProtoOffset)), baseForAccessGPR);
<span class="line-modified"> 787                         fallThrough.append(jit.branch64(CCallHelpers::Equal, baseForAccessGPR, CCallHelpers::TrustedImm64(JSValue::ValueNull)));</span>
 788 #else
 789                         jit.load32(MacroAssembler::Address(baseForAccessGPR, offsetRelativeToBase(knownPolyProtoOffset) + PayloadOffset), baseForAccessGPR);
 790                         fallThrough.append(jit.branchTestPtr(CCallHelpers::Zero, baseForAccessGPR));
 791 #endif
 792                     }
 793                 }
 794             });
 795             return;
 796         }
 797 
 798         if (viaProxy()) {
 799             fallThrough.append(
 800                 jit.branchIfNotType(baseGPR, PureForwardingProxyType));
 801 
 802             jit.loadPtr(CCallHelpers::Address(baseGPR, JSProxy::targetOffset()), scratchGPR);
 803 
 804             fallThrough.append(
 805                 jit.branchStructure(
 806                     CCallHelpers::NotEqual,
 807                     CCallHelpers::Address(scratchGPR, JSCell::structureIDOffset()),
</pre>
<hr />
<pre>
 841         fallThrough.append(
 842             jit.branchIfNotType(baseGPR, DirectArgumentsType));
 843 
 844         fallThrough.append(
 845             jit.branchTestPtr(
 846                 CCallHelpers::NonZero,
 847                 CCallHelpers::Address(baseGPR, DirectArguments::offsetOfMappedArguments())));
 848         jit.load32(
 849             CCallHelpers::Address(baseGPR, DirectArguments::offsetOfLength()),
 850             valueRegs.payloadGPR());
 851         jit.boxInt32(valueRegs.payloadGPR(), valueRegs);
 852         state.succeed();
 853         return;
 854     }
 855 
 856     case ScopedArgumentsLength: {
 857         ASSERT(!viaProxy());
 858         fallThrough.append(
 859             jit.branchIfNotType(baseGPR, ScopedArgumentsType));
 860 



 861         fallThrough.append(
 862             jit.branchTest8(
 863                 CCallHelpers::NonZero,
<span class="line-modified"> 864                 CCallHelpers::Address(baseGPR, ScopedArguments::offsetOfOverrodeThings())));</span>
 865         jit.load32(
<span class="line-modified"> 866             CCallHelpers::Address(baseGPR, ScopedArguments::offsetOfTotalLength()),</span>
 867             valueRegs.payloadGPR());
 868         jit.boxInt32(valueRegs.payloadGPR(), valueRegs);
 869         state.succeed();
 870         return;
 871     }
 872 
 873     case ModuleNamespaceLoad: {
 874         this-&gt;as&lt;ModuleNamespaceAccessCase&gt;().emit(state, fallThrough);
 875         return;
 876     }
 877 
<span class="line-added"> 878     case IndexedScopedArgumentsLoad: {</span>
<span class="line-added"> 879         // This code is written such that the result could alias with the base or the property.</span>
<span class="line-added"> 880         GPRReg propertyGPR = state.u.propertyGPR;</span>
<span class="line-added"> 881 </span>
<span class="line-added"> 882         jit.load8(CCallHelpers::Address(baseGPR, JSCell::typeInfoTypeOffset()), scratchGPR);</span>
<span class="line-added"> 883         fallThrough.append(jit.branch32(CCallHelpers::NotEqual, scratchGPR, CCallHelpers::TrustedImm32(ScopedArgumentsType)));</span>
<span class="line-added"> 884 </span>
<span class="line-added"> 885         ScratchRegisterAllocator allocator(stubInfo.usedRegisters);</span>
<span class="line-added"> 886         allocator.lock(stubInfo.baseRegs());</span>
<span class="line-added"> 887         allocator.lock(valueRegs);</span>
<span class="line-added"> 888         allocator.lock(stubInfo.propertyRegs());</span>
<span class="line-added"> 889         allocator.lock(scratchGPR);</span>
<span class="line-added"> 890 </span>
<span class="line-added"> 891         GPRReg scratch2GPR = allocator.allocateScratchGPR();</span>
<span class="line-added"> 892         GPRReg scratch3GPR = allocator.allocateScratchGPR();</span>
<span class="line-added"> 893 </span>
<span class="line-added"> 894         ScratchRegisterAllocator::PreservedState preservedState = allocator.preserveReusedRegistersByPushing(</span>
<span class="line-added"> 895             jit, ScratchRegisterAllocator::ExtraStackSpace::NoExtraSpace);</span>
<span class="line-added"> 896 </span>
<span class="line-added"> 897         CCallHelpers::JumpList failAndIgnore;</span>
<span class="line-added"> 898 </span>
<span class="line-added"> 899         failAndIgnore.append(jit.branch32(CCallHelpers::AboveOrEqual, propertyGPR, CCallHelpers::Address(baseGPR, ScopedArguments::offsetOfTotalLength())));</span>
<span class="line-added"> 900 </span>
<span class="line-added"> 901         jit.loadPtr(CCallHelpers::Address(baseGPR, ScopedArguments::offsetOfTable()), scratchGPR);</span>
<span class="line-added"> 902         jit.load32(CCallHelpers::Address(scratchGPR, ScopedArgumentsTable::offsetOfLength()), scratch2GPR);</span>
<span class="line-added"> 903         auto overflowCase = jit.branch32(CCallHelpers::AboveOrEqual, propertyGPR, scratch2GPR);</span>
<span class="line-added"> 904 </span>
<span class="line-added"> 905         jit.loadPtr(CCallHelpers::Address(baseGPR, ScopedArguments::offsetOfScope()), scratch2GPR);</span>
<span class="line-added"> 906         jit.loadPtr(CCallHelpers::Address(scratchGPR, ScopedArgumentsTable::offsetOfArguments()), scratchGPR);</span>
<span class="line-added"> 907         jit.zeroExtend32ToPtr(propertyGPR, scratch3GPR);</span>
<span class="line-added"> 908         jit.load32(CCallHelpers::BaseIndex(scratchGPR, scratch3GPR, CCallHelpers::TimesFour), scratchGPR);</span>
<span class="line-added"> 909         failAndIgnore.append(jit.branch32(CCallHelpers::Equal, scratchGPR, CCallHelpers::TrustedImm32(ScopeOffset::invalidOffset)));</span>
<span class="line-added"> 910         jit.loadValue(CCallHelpers::BaseIndex(scratch2GPR, scratchGPR, CCallHelpers::TimesEight, JSLexicalEnvironment::offsetOfVariables()), valueRegs);</span>
<span class="line-added"> 911         auto done = jit.jump();</span>
<span class="line-added"> 912 </span>
<span class="line-added"> 913         overflowCase.link(&amp;jit);</span>
<span class="line-added"> 914         jit.sub32(propertyGPR, scratch2GPR);</span>
<span class="line-added"> 915         jit.neg32(scratch2GPR);</span>
<span class="line-added"> 916         jit.loadPtr(CCallHelpers::Address(baseGPR, ScopedArguments::offsetOfStorage()), scratch3GPR);</span>
<span class="line-added"> 917 #if USE(JSVALUE64)</span>
<span class="line-added"> 918         jit.loadValue(CCallHelpers::BaseIndex(scratch3GPR, scratch2GPR, CCallHelpers::TimesEight), JSValueRegs(scratchGPR));</span>
<span class="line-added"> 919         failAndIgnore.append(jit.branchIfEmpty(scratchGPR));</span>
<span class="line-added"> 920         jit.move(scratchGPR, valueRegs.payloadGPR());</span>
<span class="line-added"> 921 #else</span>
<span class="line-added"> 922         jit.loadValue(CCallHelpers::BaseIndex(scratch3GPR, scratch2GPR, CCallHelpers::TimesEight), JSValueRegs(scratch2GPR, scratchGPR));</span>
<span class="line-added"> 923         failAndIgnore.append(jit.branchIfEmpty(scratch2GPR));</span>
<span class="line-added"> 924         jit.move(scratchGPR, valueRegs.payloadGPR());</span>
<span class="line-added"> 925         jit.move(scratch2GPR, valueRegs.tagGPR());</span>
<span class="line-added"> 926 #endif</span>
<span class="line-added"> 927 </span>
<span class="line-added"> 928         done.link(&amp;jit);</span>
<span class="line-added"> 929 </span>
<span class="line-added"> 930         allocator.restoreReusedRegistersByPopping(jit, preservedState);</span>
<span class="line-added"> 931         state.succeed();</span>
<span class="line-added"> 932 </span>
<span class="line-added"> 933         if (allocator.didReuseRegisters()) {</span>
<span class="line-added"> 934             failAndIgnore.link(&amp;jit);</span>
<span class="line-added"> 935             allocator.restoreReusedRegistersByPopping(jit, preservedState);</span>
<span class="line-added"> 936             state.failAndIgnore.append(jit.jump());</span>
<span class="line-added"> 937         } else</span>
<span class="line-added"> 938             state.failAndIgnore.append(failAndIgnore);</span>
<span class="line-added"> 939 </span>
<span class="line-added"> 940         return;</span>
<span class="line-added"> 941     }</span>
<span class="line-added"> 942 </span>
<span class="line-added"> 943     case IndexedDirectArgumentsLoad: {</span>
<span class="line-added"> 944         // This code is written such that the result could alias with the base or the property.</span>
<span class="line-added"> 945         GPRReg propertyGPR = state.u.propertyGPR;</span>
<span class="line-added"> 946         jit.load8(CCallHelpers::Address(baseGPR, JSCell::typeInfoTypeOffset()), scratchGPR);</span>
<span class="line-added"> 947         fallThrough.append(jit.branch32(CCallHelpers::NotEqual, scratchGPR, CCallHelpers::TrustedImm32(DirectArgumentsType)));</span>
<span class="line-added"> 948 </span>
<span class="line-added"> 949         jit.load32(CCallHelpers::Address(baseGPR, DirectArguments::offsetOfLength()), scratchGPR);</span>
<span class="line-added"> 950         state.failAndRepatch.append(jit.branch32(CCallHelpers::AboveOrEqual, propertyGPR, scratchGPR));</span>
<span class="line-added"> 951         state.failAndRepatch.append(jit.branchTestPtr(CCallHelpers::NonZero, CCallHelpers::Address(baseGPR, DirectArguments::offsetOfMappedArguments())));</span>
<span class="line-added"> 952         jit.zeroExtend32ToPtr(propertyGPR, scratchGPR);</span>
<span class="line-added"> 953         jit.loadValue(CCallHelpers::BaseIndex(baseGPR, scratchGPR, CCallHelpers::TimesEight, DirectArguments::storageOffset()), valueRegs);</span>
<span class="line-added"> 954         state.succeed();</span>
<span class="line-added"> 955         return;</span>
<span class="line-added"> 956     }</span>
<span class="line-added"> 957 </span>
<span class="line-added"> 958     case IndexedTypedArrayInt8Load:</span>
<span class="line-added"> 959     case IndexedTypedArrayUint8Load:</span>
<span class="line-added"> 960     case IndexedTypedArrayUint8ClampedLoad:</span>
<span class="line-added"> 961     case IndexedTypedArrayInt16Load:</span>
<span class="line-added"> 962     case IndexedTypedArrayUint16Load:</span>
<span class="line-added"> 963     case IndexedTypedArrayInt32Load:</span>
<span class="line-added"> 964     case IndexedTypedArrayUint32Load:</span>
<span class="line-added"> 965     case IndexedTypedArrayFloat32Load:</span>
<span class="line-added"> 966     case IndexedTypedArrayFloat64Load: {</span>
<span class="line-added"> 967         // This code is written such that the result could alias with the base or the property.</span>
<span class="line-added"> 968 </span>
<span class="line-added"> 969         TypedArrayType type = toTypedArrayType(m_type);</span>
<span class="line-added"> 970 </span>
<span class="line-added"> 971         GPRReg propertyGPR = state.u.propertyGPR;</span>
<span class="line-added"> 972 </span>
<span class="line-added"> 973 </span>
<span class="line-added"> 974         jit.load8(CCallHelpers::Address(baseGPR, JSCell::typeInfoTypeOffset()), scratchGPR);</span>
<span class="line-added"> 975         fallThrough.append(jit.branch32(CCallHelpers::NotEqual, scratchGPR, CCallHelpers::TrustedImm32(typeForTypedArrayType(type))));</span>
<span class="line-added"> 976 </span>
<span class="line-added"> 977         jit.load32(CCallHelpers::Address(baseGPR, JSArrayBufferView::offsetOfLength()), scratchGPR);</span>
<span class="line-added"> 978         state.failAndRepatch.append(jit.branch32(CCallHelpers::AboveOrEqual, propertyGPR, scratchGPR));</span>
<span class="line-added"> 979 </span>
<span class="line-added"> 980         ScratchRegisterAllocator allocator(stubInfo.usedRegisters);</span>
<span class="line-added"> 981         allocator.lock(stubInfo.baseRegs());</span>
<span class="line-added"> 982         allocator.lock(valueRegs);</span>
<span class="line-added"> 983         allocator.lock(stubInfo.propertyRegs());</span>
<span class="line-added"> 984         allocator.lock(scratchGPR);</span>
<span class="line-added"> 985         GPRReg scratch2GPR = allocator.allocateScratchGPR();</span>
<span class="line-added"> 986 </span>
<span class="line-added"> 987         ScratchRegisterAllocator::PreservedState preservedState = allocator.preserveReusedRegistersByPushing(</span>
<span class="line-added"> 988             jit, ScratchRegisterAllocator::ExtraStackSpace::NoExtraSpace);</span>
<span class="line-added"> 989 </span>
<span class="line-added"> 990         jit.loadPtr(CCallHelpers::Address(baseGPR, JSArrayBufferView::offsetOfVector()), scratch2GPR);</span>
<span class="line-added"> 991         jit.cageConditionally(Gigacage::Primitive, scratch2GPR, scratchGPR, scratchGPR);</span>
<span class="line-added"> 992 </span>
<span class="line-added"> 993         jit.signExtend32ToPtr(propertyGPR, scratchGPR);</span>
<span class="line-added"> 994         if (isInt(type)) {</span>
<span class="line-added"> 995             switch (elementSize(type)) {</span>
<span class="line-added"> 996             case 1:</span>
<span class="line-added"> 997                 if (JSC::isSigned(type))</span>
<span class="line-added"> 998                     jit.load8SignedExtendTo32(CCallHelpers::BaseIndex(scratch2GPR, scratchGPR, CCallHelpers::TimesOne), valueRegs.payloadGPR());</span>
<span class="line-added"> 999                 else</span>
<span class="line-added">1000                     jit.load8(CCallHelpers::BaseIndex(scratch2GPR, scratchGPR, CCallHelpers::TimesOne), valueRegs.payloadGPR());</span>
<span class="line-added">1001                 break;</span>
<span class="line-added">1002             case 2:</span>
<span class="line-added">1003                 if (JSC::isSigned(type))</span>
<span class="line-added">1004                     jit.load16SignedExtendTo32(CCallHelpers::BaseIndex(scratch2GPR, scratchGPR, CCallHelpers::TimesTwo), valueRegs.payloadGPR());</span>
<span class="line-added">1005                 else</span>
<span class="line-added">1006                     jit.load16(CCallHelpers::BaseIndex(scratch2GPR, scratchGPR, CCallHelpers::TimesTwo), valueRegs.payloadGPR());</span>
<span class="line-added">1007                 break;</span>
<span class="line-added">1008             case 4:</span>
<span class="line-added">1009                 jit.load32(CCallHelpers::BaseIndex(scratch2GPR, scratchGPR, CCallHelpers::TimesFour), valueRegs.payloadGPR());</span>
<span class="line-added">1010                 break;</span>
<span class="line-added">1011             default:</span>
<span class="line-added">1012                 CRASH();</span>
<span class="line-added">1013             }</span>
<span class="line-added">1014 </span>
<span class="line-added">1015             CCallHelpers::Jump done;</span>
<span class="line-added">1016             if (type == TypeUint32) {</span>
<span class="line-added">1017                 RELEASE_ASSERT(state.scratchFPR != InvalidFPRReg);</span>
<span class="line-added">1018                 auto canBeInt = jit.branch32(CCallHelpers::GreaterThanOrEqual, valueRegs.payloadGPR(), CCallHelpers::TrustedImm32(0));</span>
<span class="line-added">1019 </span>
<span class="line-added">1020                 jit.convertInt32ToDouble(valueRegs.payloadGPR(), state.scratchFPR);</span>
<span class="line-added">1021                 jit.addDouble(CCallHelpers::AbsoluteAddress(&amp;CCallHelpers::twoToThe32), state.scratchFPR);</span>
<span class="line-added">1022                 jit.boxDouble(state.scratchFPR, valueRegs);</span>
<span class="line-added">1023                 done = jit.jump();</span>
<span class="line-added">1024                 canBeInt.link(&amp;jit);</span>
<span class="line-added">1025             }</span>
<span class="line-added">1026 </span>
<span class="line-added">1027             jit.boxInt32(valueRegs.payloadGPR(), valueRegs);</span>
<span class="line-added">1028             if (done.isSet())</span>
<span class="line-added">1029                 done.link(&amp;jit);</span>
<span class="line-added">1030         } else {</span>
<span class="line-added">1031             ASSERT(isFloat(type));</span>
<span class="line-added">1032             RELEASE_ASSERT(state.scratchFPR != InvalidFPRReg);</span>
<span class="line-added">1033             switch (elementSize(type)) {</span>
<span class="line-added">1034             case 4:</span>
<span class="line-added">1035                 jit.loadFloat(CCallHelpers::BaseIndex(scratch2GPR, scratchGPR, CCallHelpers::TimesFour), state.scratchFPR);</span>
<span class="line-added">1036                 jit.convertFloatToDouble(state.scratchFPR, state.scratchFPR);</span>
<span class="line-added">1037                 break;</span>
<span class="line-added">1038             case 8: {</span>
<span class="line-added">1039                 jit.loadDouble(CCallHelpers::BaseIndex(scratch2GPR, scratchGPR, CCallHelpers::TimesEight), state.scratchFPR);</span>
<span class="line-added">1040                 break;</span>
<span class="line-added">1041             }</span>
<span class="line-added">1042             default:</span>
<span class="line-added">1043                 CRASH();</span>
<span class="line-added">1044             }</span>
<span class="line-added">1045 </span>
<span class="line-added">1046             jit.purifyNaN(state.scratchFPR);</span>
<span class="line-added">1047             jit.boxDouble(state.scratchFPR, valueRegs);</span>
<span class="line-added">1048         }</span>
<span class="line-added">1049 </span>
<span class="line-added">1050         allocator.restoreReusedRegistersByPopping(jit, preservedState);</span>
<span class="line-added">1051         state.succeed();</span>
<span class="line-added">1052 </span>
<span class="line-added">1053         return;</span>
<span class="line-added">1054     }</span>
<span class="line-added">1055 </span>
<span class="line-added">1056     case IndexedStringLoad: {</span>
<span class="line-added">1057         // This code is written such that the result could alias with the base or the property.</span>
<span class="line-added">1058         GPRReg propertyGPR = state.u.propertyGPR;</span>
<span class="line-added">1059 </span>
<span class="line-added">1060         fallThrough.append(jit.branchIfNotString(baseGPR));</span>
<span class="line-added">1061 </span>
<span class="line-added">1062         ScratchRegisterAllocator allocator(stubInfo.usedRegisters);</span>
<span class="line-added">1063         allocator.lock(stubInfo.baseRegs());</span>
<span class="line-added">1064         allocator.lock(valueRegs);</span>
<span class="line-added">1065         allocator.lock(stubInfo.propertyRegs());</span>
<span class="line-added">1066         allocator.lock(scratchGPR);</span>
<span class="line-added">1067         GPRReg scratch2GPR = allocator.allocateScratchGPR();</span>
<span class="line-added">1068 </span>
<span class="line-added">1069         CCallHelpers::JumpList failAndIgnore;</span>
<span class="line-added">1070 </span>
<span class="line-added">1071         ScratchRegisterAllocator::PreservedState preservedState = allocator.preserveReusedRegistersByPushing(</span>
<span class="line-added">1072             jit, ScratchRegisterAllocator::ExtraStackSpace::NoExtraSpace);</span>
<span class="line-added">1073 </span>
<span class="line-added">1074         jit.loadPtr(CCallHelpers::Address(baseGPR, JSString::offsetOfValue()), scratch2GPR);</span>
<span class="line-added">1075         failAndIgnore.append(jit.branchIfRopeStringImpl(scratch2GPR));</span>
<span class="line-added">1076         jit.load32(CCallHelpers::Address(scratch2GPR, StringImpl::lengthMemoryOffset()), scratchGPR);</span>
<span class="line-added">1077 </span>
<span class="line-added">1078         failAndIgnore.append(jit.branch32(CCallHelpers::AboveOrEqual, propertyGPR, scratchGPR));</span>
<span class="line-added">1079 </span>
<span class="line-added">1080         jit.load32(CCallHelpers::Address(scratch2GPR, StringImpl::flagsOffset()), scratchGPR);</span>
<span class="line-added">1081         jit.loadPtr(CCallHelpers::Address(scratch2GPR, StringImpl::dataOffset()), scratch2GPR);</span>
<span class="line-added">1082         auto is16Bit = jit.branchTest32(CCallHelpers::Zero, scratchGPR, CCallHelpers::TrustedImm32(StringImpl::flagIs8Bit()));</span>
<span class="line-added">1083         jit.zeroExtend32ToPtr(propertyGPR, scratchGPR);</span>
<span class="line-added">1084         jit.load8(CCallHelpers::BaseIndex(scratch2GPR, scratchGPR, CCallHelpers::TimesOne, 0), scratch2GPR);</span>
<span class="line-added">1085         auto is8BitLoadDone = jit.jump();</span>
<span class="line-added">1086         is16Bit.link(&amp;jit);</span>
<span class="line-added">1087         jit.zeroExtend32ToPtr(propertyGPR, scratchGPR);</span>
<span class="line-added">1088         jit.load16(CCallHelpers::BaseIndex(scratch2GPR, scratchGPR, CCallHelpers::TimesTwo, 0), scratch2GPR);</span>
<span class="line-added">1089         is8BitLoadDone.link(&amp;jit);</span>
<span class="line-added">1090 </span>
<span class="line-added">1091         failAndIgnore.append(jit.branch32(CCallHelpers::Above, scratch2GPR, CCallHelpers::TrustedImm32(maxSingleCharacterString)));</span>
<span class="line-added">1092         jit.move(CCallHelpers::TrustedImmPtr(vm.smallStrings.singleCharacterStrings()), scratchGPR);</span>
<span class="line-added">1093         jit.loadPtr(CCallHelpers::BaseIndex(scratchGPR, scratch2GPR, CCallHelpers::ScalePtr, 0), valueRegs.payloadGPR());</span>
<span class="line-added">1094         jit.boxCell(valueRegs.payloadGPR(), valueRegs);</span>
<span class="line-added">1095         allocator.restoreReusedRegistersByPopping(jit, preservedState);</span>
<span class="line-added">1096         state.succeed();</span>
<span class="line-added">1097 </span>
<span class="line-added">1098         if (allocator.didReuseRegisters()) {</span>
<span class="line-added">1099             failAndIgnore.link(&amp;jit);</span>
<span class="line-added">1100             allocator.restoreReusedRegistersByPopping(jit, preservedState);</span>
<span class="line-added">1101             state.failAndIgnore.append(jit.jump());</span>
<span class="line-added">1102         } else</span>
<span class="line-added">1103             state.failAndIgnore.append(failAndIgnore);</span>
<span class="line-added">1104 </span>
<span class="line-added">1105         return;</span>
<span class="line-added">1106     }</span>
<span class="line-added">1107 </span>
<span class="line-added">1108     case IndexedInt32Load:</span>
<span class="line-added">1109     case IndexedDoubleLoad:</span>
<span class="line-added">1110     case IndexedContiguousLoad:</span>
<span class="line-added">1111     case IndexedArrayStorageLoad: {</span>
<span class="line-added">1112         // This code is written such that the result could alias with the base or the property.</span>
<span class="line-added">1113         GPRReg propertyGPR = state.u.propertyGPR;</span>
<span class="line-added">1114 </span>
<span class="line-added">1115         // int32 check done in polymorphic access.</span>
<span class="line-added">1116         jit.load8(CCallHelpers::Address(baseGPR, JSCell::indexingTypeAndMiscOffset()), scratchGPR);</span>
<span class="line-added">1117         jit.and32(CCallHelpers::TrustedImm32(IndexingShapeMask), scratchGPR);</span>
<span class="line-added">1118 </span>
<span class="line-added">1119         CCallHelpers::Jump isOutOfBounds;</span>
<span class="line-added">1120         CCallHelpers::Jump isEmpty;</span>
<span class="line-added">1121 </span>
<span class="line-added">1122         ScratchRegisterAllocator allocator(stubInfo.usedRegisters);</span>
<span class="line-added">1123         allocator.lock(stubInfo.baseRegs());</span>
<span class="line-added">1124         allocator.lock(valueRegs);</span>
<span class="line-added">1125         allocator.lock(stubInfo.propertyRegs());</span>
<span class="line-added">1126         allocator.lock(scratchGPR);</span>
<span class="line-added">1127         GPRReg scratch2GPR = allocator.allocateScratchGPR();</span>
<span class="line-added">1128 #if USE(JSVALUE32_64)</span>
<span class="line-added">1129         GPRReg scratch3GPR = allocator.allocateScratchGPR();</span>
<span class="line-added">1130 #endif</span>
<span class="line-added">1131         ScratchRegisterAllocator::PreservedState preservedState;</span>
<span class="line-added">1132 </span>
<span class="line-added">1133         CCallHelpers::JumpList failAndIgnore;</span>
<span class="line-added">1134         auto preserveReusedRegisters = [&amp;] {</span>
<span class="line-added">1135             preservedState = allocator.preserveReusedRegistersByPushing(jit, ScratchRegisterAllocator::ExtraStackSpace::NoExtraSpace);</span>
<span class="line-added">1136         };</span>
<span class="line-added">1137 </span>
<span class="line-added">1138         if (m_type == IndexedArrayStorageLoad) {</span>
<span class="line-added">1139             jit.add32(CCallHelpers::TrustedImm32(-ArrayStorageShape), scratchGPR, scratchGPR);</span>
<span class="line-added">1140             fallThrough.append(jit.branch32(CCallHelpers::Above, scratchGPR, CCallHelpers::TrustedImm32(SlowPutArrayStorageShape - ArrayStorageShape)));</span>
<span class="line-added">1141 </span>
<span class="line-added">1142             preserveReusedRegisters();</span>
<span class="line-added">1143 </span>
<span class="line-added">1144             jit.loadPtr(CCallHelpers::Address(baseGPR, JSObject::butterflyOffset()), scratchGPR);</span>
<span class="line-added">1145             isOutOfBounds = jit.branch32(CCallHelpers::AboveOrEqual, propertyGPR, CCallHelpers::Address(scratchGPR, ArrayStorage::vectorLengthOffset()));</span>
<span class="line-added">1146 </span>
<span class="line-added">1147             jit.zeroExtend32ToPtr(propertyGPR, scratch2GPR);</span>
<span class="line-added">1148 #if USE(JSVALUE64)</span>
<span class="line-added">1149             jit.loadValue(CCallHelpers::BaseIndex(scratchGPR, scratch2GPR, CCallHelpers::TimesEight, ArrayStorage::vectorOffset()), JSValueRegs(scratchGPR));</span>
<span class="line-added">1150             isEmpty = jit.branchIfEmpty(scratchGPR);</span>
<span class="line-added">1151             jit.move(scratchGPR, valueRegs.payloadGPR());</span>
<span class="line-added">1152 #else</span>
<span class="line-added">1153             jit.loadValue(CCallHelpers::BaseIndex(scratchGPR, scratch2GPR, CCallHelpers::TimesEight, ArrayStorage::vectorOffset()), JSValueRegs(scratch3GPR, scratchGPR));</span>
<span class="line-added">1154             isEmpty = jit.branchIfEmpty(scratch3GPR);</span>
<span class="line-added">1155             jit.move(scratchGPR, valueRegs.payloadGPR());</span>
<span class="line-added">1156             jit.move(scratch3GPR, valueRegs.tagGPR());</span>
<span class="line-added">1157 #endif</span>
<span class="line-added">1158         } else {</span>
<span class="line-added">1159             IndexingType expectedShape;</span>
<span class="line-added">1160             switch (m_type) {</span>
<span class="line-added">1161             case IndexedInt32Load:</span>
<span class="line-added">1162                 expectedShape = Int32Shape;</span>
<span class="line-added">1163                 break;</span>
<span class="line-added">1164             case IndexedDoubleLoad:</span>
<span class="line-added">1165                 expectedShape = DoubleShape;</span>
<span class="line-added">1166                 break;</span>
<span class="line-added">1167             case IndexedContiguousLoad:</span>
<span class="line-added">1168                 expectedShape = ContiguousShape;</span>
<span class="line-added">1169                 break;</span>
<span class="line-added">1170             default:</span>
<span class="line-added">1171                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">1172                 break;</span>
<span class="line-added">1173             }</span>
<span class="line-added">1174 </span>
<span class="line-added">1175             fallThrough.append(jit.branch32(CCallHelpers::NotEqual, scratchGPR, CCallHelpers::TrustedImm32(expectedShape)));</span>
<span class="line-added">1176 </span>
<span class="line-added">1177             preserveReusedRegisters();</span>
<span class="line-added">1178 </span>
<span class="line-added">1179             jit.loadPtr(CCallHelpers::Address(baseGPR, JSObject::butterflyOffset()), scratchGPR);</span>
<span class="line-added">1180             isOutOfBounds = jit.branch32(CCallHelpers::AboveOrEqual, propertyGPR, CCallHelpers::Address(scratchGPR, Butterfly::offsetOfPublicLength()));</span>
<span class="line-added">1181             jit.zeroExtend32ToPtr(propertyGPR, scratch2GPR);</span>
<span class="line-added">1182             if (m_type == IndexedDoubleLoad) {</span>
<span class="line-added">1183                 RELEASE_ASSERT(state.scratchFPR != InvalidFPRReg);</span>
<span class="line-added">1184                 jit.loadDouble(CCallHelpers::BaseIndex(scratchGPR, scratch2GPR, CCallHelpers::TimesEight), state.scratchFPR);</span>
<span class="line-added">1185                 isEmpty = jit.branchIfNaN(state.scratchFPR);</span>
<span class="line-added">1186                 jit.boxDouble(state.scratchFPR, valueRegs);</span>
<span class="line-added">1187             } else {</span>
<span class="line-added">1188 #if USE(JSVALUE64)</span>
<span class="line-added">1189                 jit.loadValue(CCallHelpers::BaseIndex(scratchGPR, scratch2GPR, CCallHelpers::TimesEight), JSValueRegs(scratchGPR));</span>
<span class="line-added">1190                 isEmpty = jit.branchIfEmpty(scratchGPR);</span>
<span class="line-added">1191                 jit.move(scratchGPR, valueRegs.payloadGPR());</span>
<span class="line-added">1192 #else</span>
<span class="line-added">1193                 jit.loadValue(CCallHelpers::BaseIndex(scratchGPR, scratch2GPR, CCallHelpers::TimesEight), JSValueRegs(scratch3GPR, scratchGPR));</span>
<span class="line-added">1194                 isEmpty = jit.branchIfEmpty(scratch3GPR);</span>
<span class="line-added">1195                 jit.move(scratchGPR, valueRegs.payloadGPR());</span>
<span class="line-added">1196                 jit.move(scratch3GPR, valueRegs.tagGPR());</span>
<span class="line-added">1197 #endif</span>
<span class="line-added">1198             }</span>
<span class="line-added">1199         }</span>
<span class="line-added">1200 </span>
<span class="line-added">1201         allocator.restoreReusedRegistersByPopping(jit, preservedState);</span>
<span class="line-added">1202         state.succeed();</span>
<span class="line-added">1203 </span>
<span class="line-added">1204         if (allocator.didReuseRegisters()) {</span>
<span class="line-added">1205             isOutOfBounds.link(&amp;jit);</span>
<span class="line-added">1206             isEmpty.link(&amp;jit);</span>
<span class="line-added">1207             allocator.restoreReusedRegistersByPopping(jit, preservedState);</span>
<span class="line-added">1208             state.failAndIgnore.append(jit.jump());</span>
<span class="line-added">1209         } else {</span>
<span class="line-added">1210             state.failAndIgnore.append(isOutOfBounds);</span>
<span class="line-added">1211             state.failAndIgnore.append(isEmpty);</span>
<span class="line-added">1212         }</span>
<span class="line-added">1213 </span>
<span class="line-added">1214         return;</span>
<span class="line-added">1215     }</span>
<span class="line-added">1216 </span>
1217     case InstanceOfHit:
1218     case InstanceOfMiss:
1219         emitDefaultGuard();
1220 
1221         fallThrough.append(
1222             jit.branchPtr(
<span class="line-modified">1223                 CCallHelpers::NotEqual, state.u.prototypeGPR,</span>
1224                 CCallHelpers::TrustedImmPtr(as&lt;InstanceOfAccessCase&gt;().prototype())));
1225         break;
1226 
1227     case InstanceOfGeneric: {
<span class="line-modified">1228         GPRReg prototypeGPR = state.u.prototypeGPR;</span>
<span class="line-added">1229         // Legend: value = `base instanceof prototypeGPR`.</span>
1230 
1231         GPRReg valueGPR = valueRegs.payloadGPR();
1232 
<span class="line-modified">1233         ScratchRegisterAllocator allocator(stubInfo.usedRegisters);</span>
<span class="line-modified">1234         allocator.lock(stubInfo.baseRegs());</span>
<span class="line-modified">1235         allocator.lock(valueRegs);</span>
<span class="line-modified">1236         allocator.lock(stubInfo.propertyRegs());</span>
1237         allocator.lock(scratchGPR);
1238 
1239         GPRReg scratch2GPR = allocator.allocateScratchGPR();
1240 
1241         if (!state.stubInfo-&gt;prototypeIsKnownObject)
<span class="line-modified">1242             state.failAndIgnore.append(jit.branchIfNotObject(prototypeGPR));</span>
1243 
1244         ScratchRegisterAllocator::PreservedState preservedState =
1245             allocator.preserveReusedRegistersByPushing(
1246                 jit,
1247                 ScratchRegisterAllocator::ExtraStackSpace::NoExtraSpace);
1248         CCallHelpers::Jump failAndIgnore;
1249 
1250         jit.move(baseGPR, valueGPR);
1251 
1252         CCallHelpers::Label loop(&amp;jit);
1253         failAndIgnore = jit.branchIfType(valueGPR, ProxyObjectType);
1254 
1255         jit.emitLoadStructure(vm, valueGPR, scratch2GPR, scratchGPR);
1256 #if USE(JSVALUE64)
1257         jit.load64(CCallHelpers::Address(scratch2GPR, Structure::prototypeOffset()), scratch2GPR);
1258         CCallHelpers::Jump hasMonoProto = jit.branchTest64(CCallHelpers::NonZero, scratch2GPR);
1259         jit.load64(
1260             CCallHelpers::Address(valueGPR, offsetRelativeToBase(knownPolyProtoOffset)),
1261             scratch2GPR);
1262         hasMonoProto.link(&amp;jit);
1263 #else
1264         jit.load32(
1265             CCallHelpers::Address(scratch2GPR, Structure::prototypeOffset() + TagOffset),
1266             scratchGPR);
1267         jit.load32(
1268             CCallHelpers::Address(scratch2GPR, Structure::prototypeOffset() + PayloadOffset),
1269             scratch2GPR);
1270         CCallHelpers::Jump hasMonoProto = jit.branch32(
1271             CCallHelpers::NotEqual, scratchGPR, CCallHelpers::TrustedImm32(JSValue::EmptyValueTag));
1272         jit.load32(
1273             CCallHelpers::Address(
1274                 valueGPR, offsetRelativeToBase(knownPolyProtoOffset) + PayloadOffset),
1275             scratch2GPR);
1276         hasMonoProto.link(&amp;jit);
1277 #endif
1278         jit.move(scratch2GPR, valueGPR);
1279 
<span class="line-modified">1280         CCallHelpers::Jump isInstance = jit.branchPtr(CCallHelpers::Equal, valueGPR, prototypeGPR);</span>
1281 
1282 #if USE(JSVALUE64)
1283         jit.branchIfCell(JSValueRegs(valueGPR)).linkTo(loop, &amp;jit);
1284 #else
1285         jit.branchTestPtr(CCallHelpers::NonZero, valueGPR).linkTo(loop, &amp;jit);
1286 #endif
1287 
1288         jit.boxBooleanPayload(false, valueGPR);
1289         allocator.restoreReusedRegistersByPopping(jit, preservedState);
1290         state.succeed();
1291 
1292         isInstance.link(&amp;jit);
1293         jit.boxBooleanPayload(true, valueGPR);
1294         allocator.restoreReusedRegistersByPopping(jit, preservedState);
1295         state.succeed();
1296 
1297         if (allocator.didReuseRegisters()) {
1298             failAndIgnore.link(&amp;jit);
1299             allocator.restoreReusedRegistersByPopping(jit, preservedState);
1300             state.failAndIgnore.append(jit.jump());
1301         } else
1302             state.failAndIgnore.append(failAndIgnore);
1303         return;
1304     }
1305 
1306     default:
1307         emitDefaultGuard();
1308         break;
1309     }
1310 
1311     generateImpl(state);
1312 }
1313 
1314 void AccessCase::generate(AccessGenerationState&amp; state)
1315 {
1316     RELEASE_ASSERT(m_state == Committed);
<span class="line-added">1317     RELEASE_ASSERT(state.stubInfo-&gt;hasConstantIdentifier);</span>
1318     m_state = Generated;
1319 
<span class="line-added">1320     checkConsistency(*state.stubInfo);</span>
<span class="line-added">1321 </span>
1322     generateImpl(state);
1323 }
1324 
1325 void AccessCase::generateImpl(AccessGenerationState&amp; state)
1326 {
1327     SuperSamplerScope superSamplerScope(false);
1328     if (AccessCaseInternal::verbose)
1329         dataLog(&quot;\n\nGenerating code for: &quot;, *this, &quot;\n&quot;);
1330 
1331     ASSERT(m_state == Generated); // We rely on the callers setting this for us.
1332 
1333     CCallHelpers&amp; jit = *state.jit;
1334     VM&amp; vm = state.m_vm;
1335     CodeBlock* codeBlock = jit.codeBlock();
1336     StructureStubInfo&amp; stubInfo = *state.stubInfo;

1337     JSValueRegs valueRegs = state.valueRegs;
1338     GPRReg baseGPR = state.baseGPR;
<span class="line-modified">1339     GPRReg thisGPR = stubInfo.thisValueIsInThisGPR() ? state.u.thisGPR : baseGPR;</span>
1340     GPRReg scratchGPR = state.scratchGPR;
1341 


1342     for (const ObjectPropertyCondition&amp; condition : m_conditionSet) {
1343         RELEASE_ASSERT(!m_polyProtoAccessChain);
1344 
<span class="line-modified">1345         if (condition.isWatchableAssumingImpurePropertyWatchpoint(PropertyCondition::WatchabilityEffort::EnsureWatchability)) {</span>
<span class="line-modified">1346             state.installWatchpoint(condition);</span>


1347             continue;
1348         }
1349 
<span class="line-modified">1350         // For now, we only allow equivalence when it&#39;s watchable.</span>
<span class="line-added">1351         RELEASE_ASSERT(condition.condition().kind() != PropertyCondition::Equivalence);</span>
<span class="line-added">1352 </span>
<span class="line-added">1353         if (!condition.structureEnsuresValidityAssumingImpurePropertyWatchpoint()) {</span>
1354             // The reason why this cannot happen is that we require that PolymorphicAccess calls
1355             // AccessCase::generate() only after it has verified that
1356             // AccessCase::couldStillSucceed() returned true.
1357 
1358             dataLog(&quot;This condition is no longer met: &quot;, condition, &quot;\n&quot;);
1359             RELEASE_ASSERT_NOT_REACHED();
1360         }
1361 
1362         // We will emit code that has a weak reference that isn&#39;t otherwise listed anywhere.
<span class="line-added">1363         Structure* structure = condition.object()-&gt;structure(vm);</span>
1364         state.weakReferences.append(WriteBarrier&lt;JSCell&gt;(vm, codeBlock, structure));
1365 
1366         jit.move(CCallHelpers::TrustedImmPtr(condition.object()), scratchGPR);
1367         state.failAndRepatch.append(
1368             jit.branchStructure(
1369                 CCallHelpers::NotEqual,
1370                 CCallHelpers::Address(scratchGPR, JSCell::structureIDOffset()),
1371                 structure));
1372     }
1373 
1374     switch (m_type) {
1375     case InHit:
1376     case InMiss:
1377         jit.boxBoolean(m_type == InHit, valueRegs);
1378         state.succeed();
1379         return;
1380 
1381     case Miss:
1382         jit.moveTrustedValue(jsUndefined(), valueRegs);
1383         state.succeed();
</pre>
<hr />
<pre>
1503         CCallHelpers::DataLabelPtr addressOfLinkFunctionCheck;
1504         CCallHelpers::Call fastPathCall;
1505         CCallHelpers::Call slowPathCall;
1506 
1507         // This also does the necessary calculations of whether or not we&#39;re an
1508         // exception handling call site.
1509         AccessGenerationState::SpillState spillState = state.preserveLiveRegistersToStackForCall();
1510 
1511         auto restoreLiveRegistersFromStackForCall = [&amp;](AccessGenerationState::SpillState&amp; spillState, bool callHasReturnValue) {
1512             RegisterSet dontRestore;
1513             if (callHasReturnValue) {
1514                 // This is the result value. We don&#39;t want to overwrite the result with what we stored to the stack.
1515                 // We sometimes have to store it to the stack just in case we throw an exception and need the original value.
1516                 dontRestore.set(valueRegs);
1517             }
1518             state.restoreLiveRegistersFromStackForCall(spillState, dontRestore);
1519         };
1520 
1521         jit.store32(
1522             CCallHelpers::TrustedImm32(state.callSiteIndexForExceptionHandlingOrOriginal().bits()),
<span class="line-modified">1523             CCallHelpers::tagFor(CallFrameSlot::argumentCountIncludingThis));</span>
1524 
1525         if (m_type == Getter || m_type == Setter) {
1526             auto&amp; access = this-&gt;as&lt;GetterSetterAccessCase&gt;();
1527             ASSERT(baseGPR != loadedValueGPR);
1528             ASSERT(m_type != Setter || valueRegsPayloadGPR != loadedValueGPR);
1529 
1530             // Create a JS call using a JS call inline cache. Assume that:
1531             //
1532             // - SP is aligned and represents the extent of the calling compiler&#39;s stack usage.
1533             //
1534             // - FP is set correctly (i.e. it points to the caller&#39;s call frame header).
1535             //
1536             // - SP - FP is an aligned difference.
1537             //
1538             // - Any byte between FP (exclusive) and SP (inclusive) could be live in the calling
1539             //   code.
1540             //
1541             // Therefore, we temporarily grow the stack for the purpose of the call and then
1542             // shrink it after.
1543 
1544             state.setSpillStateForJSGetterSetter(spillState);
1545 
1546             RELEASE_ASSERT(!access.callLinkInfo());
<span class="line-modified">1547             CallLinkInfo* callLinkInfo = state.m_callLinkInfos.add();</span>
<span class="line-added">1548             access.m_callLinkInfo = callLinkInfo;</span>
1549 
1550             // FIXME: If we generated a polymorphic call stub that jumped back to the getter
1551             // stub, which then jumped back to the main code, then we&#39;d have a reachability
1552             // situation that the GC doesn&#39;t know about. The GC would ensure that the polymorphic
1553             // call stub stayed alive, and it would ensure that the main code stayed alive, but
1554             // it wouldn&#39;t know that the getter stub was alive. Ideally JIT stub routines would
1555             // be GC objects, and then we&#39;d be able to say that the polymorphic call stub has a
1556             // reference to the getter stub.
1557             // https://bugs.webkit.org/show_bug.cgi?id=148914
<span class="line-modified">1558             callLinkInfo-&gt;disallowStubs();</span>
1559 
<span class="line-modified">1560             callLinkInfo-&gt;setUpCall(CallLinkInfo::Call, stubInfo.codeOrigin, loadedValueGPR);</span>

1561 
1562             CCallHelpers::JumpList done;
1563 
1564             // There is a &quot;this&quot; argument.
1565             unsigned numberOfParameters = 1;
1566             // ... and a value argument if we&#39;re calling a setter.
1567             if (m_type == Setter)
1568                 numberOfParameters++;
1569 
1570             // Get the accessor; if there ain&#39;t one then the result is jsUndefined().
1571             if (m_type == Setter) {
1572                 jit.loadPtr(
1573                     CCallHelpers::Address(loadedValueGPR, GetterSetter::offsetOfSetter()),
1574                     loadedValueGPR);
1575             } else {
1576                 jit.loadPtr(
1577                     CCallHelpers::Address(loadedValueGPR, GetterSetter::offsetOfGetter()),
1578                     loadedValueGPR);
1579             }
1580 
1581             CCallHelpers::Jump returnUndefined = jit.branchTestPtr(
1582                 CCallHelpers::Zero, loadedValueGPR);
1583 
<span class="line-modified">1584             unsigned numberOfRegsForCall = CallFrame::headerSizeInRegisters + roundArgumentCountToAlignFrame(numberOfParameters);</span>
<span class="line-added">1585             ASSERT(!(numberOfRegsForCall % stackAlignmentRegisters()));</span>
1586             unsigned numberOfBytesForCall = numberOfRegsForCall * sizeof(Register) - sizeof(CallerFrameAndPC);
1587 
1588             unsigned alignedNumberOfBytesForCall =
1589             WTF::roundUpToMultipleOf(stackAlignmentBytes(), numberOfBytesForCall);
1590 
1591             jit.subPtr(
1592                 CCallHelpers::TrustedImm32(alignedNumberOfBytesForCall),
1593                 CCallHelpers::stackPointerRegister);
1594 
1595             CCallHelpers::Address calleeFrame = CCallHelpers::Address(
1596                 CCallHelpers::stackPointerRegister,
1597                 -static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC)));
1598 
1599             jit.store32(
1600                 CCallHelpers::TrustedImm32(numberOfParameters),
<span class="line-modified">1601                 calleeFrame.withOffset(CallFrameSlot::argumentCountIncludingThis * sizeof(Register) + PayloadOffset));</span>
1602 
1603             jit.storeCell(
1604                 loadedValueGPR, calleeFrame.withOffset(CallFrameSlot::callee * sizeof(Register)));
1605 
1606             jit.storeCell(
1607                 thisGPR,
<span class="line-modified">1608                 calleeFrame.withOffset(virtualRegisterForArgumentIncludingThis(0).offset() * sizeof(Register)));</span>
1609 
1610             if (m_type == Setter) {
1611                 jit.storeValue(
1612                     valueRegs,
1613                     calleeFrame.withOffset(
<span class="line-modified">1614                         virtualRegisterForArgumentIncludingThis(1).offset() * sizeof(Register)));</span>
1615             }
1616 
1617             CCallHelpers::Jump slowCase = jit.branchPtrWithPatch(
1618                 CCallHelpers::NotEqual, loadedValueGPR, addressOfLinkFunctionCheck,
1619                 CCallHelpers::TrustedImmPtr(nullptr));
1620 
1621             fastPathCall = jit.nearCall();
1622             if (m_type == Getter)
1623                 jit.setupResults(valueRegs);
1624             done.append(jit.jump());
1625 
<span class="line-added">1626             // FIXME: Revisit JSGlobalObject.</span>
<span class="line-added">1627             // https://bugs.webkit.org/show_bug.cgi?id=203204</span>
1628             slowCase.link(&amp;jit);
1629             jit.move(loadedValueGPR, GPRInfo::regT0);
1630 #if USE(JSVALUE32_64)
1631             // We *always* know that the getter/setter, if non-null, is a cell.
1632             jit.move(CCallHelpers::TrustedImm32(JSValue::CellTag), GPRInfo::regT1);
1633 #endif
1634             jit.move(CCallHelpers::TrustedImmPtr(access.callLinkInfo()), GPRInfo::regT2);
<span class="line-added">1635             jit.move(CCallHelpers::TrustedImmPtr(state.m_globalObject), GPRInfo::regT3);</span>
1636             slowPathCall = jit.nearCall();
1637             if (m_type == Getter)
1638                 jit.setupResults(valueRegs);
1639             done.append(jit.jump());
1640 
1641             returnUndefined.link(&amp;jit);
1642             if (m_type == Getter)
1643                 jit.moveTrustedValue(jsUndefined(), valueRegs);
1644 
1645             done.link(&amp;jit);
1646 
1647             jit.addPtr(CCallHelpers::TrustedImm32((codeBlock-&gt;stackPointerOffset() * sizeof(Register)) - state.preservedReusedRegisterState.numberOfBytesPreserved - spillState.numberOfStackBytesUsedForRegisterPreservation),
1648                 GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
1649             bool callHasReturnValue = isGetter();
1650             restoreLiveRegistersFromStackForCall(spillState, callHasReturnValue);
1651 
1652             jit.addLinkTask([=, &amp;vm] (LinkBuffer&amp; linkBuffer) {
1653                 this-&gt;as&lt;GetterSetterAccessCase&gt;().callLinkInfo()-&gt;setCallLocations(
1654                     CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(slowPathCall)),
1655                     CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(addressOfLinkFunctionCheck)),
1656                     linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(fastPathCall));
1657 
1658                 linkBuffer.link(
1659                     slowPathCall,
1660                     CodeLocationLabel&lt;JITThunkPtrTag&gt;(vm.getCTIStub(linkCallThunkGenerator).code()));
1661             });
1662         } else {
1663             ASSERT(m_type == CustomValueGetter || m_type == CustomAccessorGetter || m_type == CustomValueSetter || m_type == CustomAccessorSetter);
1664 
1665             // Need to make room for the C call so any of our stack spillage isn&#39;t overwritten. It&#39;s
1666             // hard to track if someone did spillage or not, so we just assume that we always need
1667             // to make some space here.
1668             jit.makeSpaceOnStackForCCall();
1669 
1670             // Check if it is a super access
1671             GPRReg baseForCustomGetGPR = baseGPR != thisGPR ? thisGPR : baseForGetGPR;
1672 
<span class="line-modified">1673             // getter: EncodedJSValue (*GetValueFunc)(JSGlobalObject*, EncodedJSValue thisValue, PropertyName);</span>
<span class="line-modified">1674             // setter: void (*PutValueFunc)(JSGlobalObject*, EncodedJSValue thisObject, EncodedJSValue value);</span>
1675             // Custom values are passed the slotBase (the property holder), custom accessors are passed the thisVaule (reciever).
1676             // FIXME: Remove this differences in custom values and custom accessors.
1677             // https://bugs.webkit.org/show_bug.cgi?id=158014
1678             GPRReg baseForCustom = m_type == CustomValueGetter || m_type == CustomValueSetter ? baseForAccessGPR : baseForCustomGetGPR;
<span class="line-added">1679             // FIXME: Revisit JSGlobalObject.</span>
<span class="line-added">1680             // https://bugs.webkit.org/show_bug.cgi?id=203204</span>
1681             if (m_type == CustomValueGetter || m_type == CustomAccessorGetter) {
<span class="line-added">1682                 RELEASE_ASSERT(m_identifier);</span>
1683                 jit.setupArguments&lt;PropertySlot::GetValueFunc&gt;(
<span class="line-added">1684                     CCallHelpers::TrustedImmPtr(codeBlock-&gt;globalObject()),</span>
1685                     CCallHelpers::CellValue(baseForCustom),
<span class="line-modified">1686                     CCallHelpers::TrustedImmPtr(uid()));</span>
1687             } else {
1688                 jit.setupArguments&lt;PutPropertySlot::PutValueFunc&gt;(
<span class="line-added">1689                     CCallHelpers::TrustedImmPtr(codeBlock-&gt;globalObject()),</span>
1690                     CCallHelpers::CellValue(baseForCustom),
1691                     valueRegs);
1692             }
1693             jit.storePtr(GPRInfo::callFrameRegister, &amp;vm.topCallFrame);
1694 
1695             operationCall = jit.call(OperationPtrTag);
1696             jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
1697                 linkBuffer.link(operationCall, this-&gt;as&lt;GetterSetterAccessCase&gt;().m_customAccessor);
1698             });
1699 
1700             if (m_type == CustomValueGetter || m_type == CustomAccessorGetter)
1701                 jit.setupResults(valueRegs);
1702             jit.reclaimSpaceOnStackForCCall();
1703 
1704             CCallHelpers::Jump noException =
1705             jit.emitExceptionCheck(vm, CCallHelpers::InvertedExceptionCheck);
1706 
1707             state.restoreLiveRegistersFromStackForCallWithThrownException(spillState);
1708             state.emitExplicitExceptionHandler();
1709 
</pre>
<hr />
<pre>
1727             jit.loadPtr(CCallHelpers::Address(baseGPR, JSObject::butterflyOffset()), scratchGPR);
1728             jit.storeValue(
1729                 valueRegs,
1730                 CCallHelpers::Address(
1731                     scratchGPR, offsetInButterfly(m_offset) * sizeof(JSValue)));
1732         }
1733         state.succeed();
1734         return;
1735     }
1736 
1737     case Transition: {
1738         // AccessCase::transition() should have returned null if this wasn&#39;t true.
1739         RELEASE_ASSERT(GPRInfo::numberOfRegisters &gt;= 6 || !structure()-&gt;outOfLineCapacity() || structure()-&gt;outOfLineCapacity() == newStructure()-&gt;outOfLineCapacity());
1740 
1741         // NOTE: This logic is duplicated in AccessCase::doesCalls(). It&#39;s important that doesCalls() knows
1742         // exactly when this would make calls.
1743         bool allocating = newStructure()-&gt;outOfLineCapacity() != structure()-&gt;outOfLineCapacity();
1744         bool reallocating = allocating &amp;&amp; structure()-&gt;outOfLineCapacity();
1745         bool allocatingInline = allocating &amp;&amp; !structure()-&gt;couldHaveIndexingHeader();
1746 
<span class="line-modified">1747         ScratchRegisterAllocator allocator(stubInfo.usedRegisters);</span>
<span class="line-modified">1748         allocator.lock(stubInfo.baseRegs());</span>



1749         allocator.lock(valueRegs);
1750         allocator.lock(scratchGPR);
1751 
1752         GPRReg scratchGPR2 = InvalidGPRReg;
1753         GPRReg scratchGPR3 = InvalidGPRReg;
1754         if (allocatingInline) {
1755             scratchGPR2 = allocator.allocateScratchGPR();
1756             scratchGPR3 = allocator.allocateScratchGPR();
1757         }
1758 
1759         ScratchRegisterAllocator::PreservedState preservedState =
1760             allocator.preserveReusedRegistersByPushing(jit, ScratchRegisterAllocator::ExtraStackSpace::SpaceForCCall);
1761 
1762         CCallHelpers::JumpList slowPath;
1763 
1764         ASSERT(structure()-&gt;transitionWatchpointSetHasBeenInvalidated());
1765 
1766         if (allocating) {
1767             size_t newSize = newStructure()-&gt;outOfLineCapacity() * sizeof(JSValue);
1768 
</pre>
<hr />
<pre>
1793                         jit.storePtr(
1794                             scratchGPR2,
1795                             CCallHelpers::Address(
1796                                 scratchGPR,
1797                                 -static_cast&lt;ptrdiff_t&gt;(offset + sizeof(JSValue) + sizeof(void*))));
1798                     }
1799                 }
1800 
1801                 for (size_t offset = oldSize; offset &lt; newSize; offset += sizeof(void*))
1802                     jit.storePtr(CCallHelpers::TrustedImmPtr(nullptr), CCallHelpers::Address(scratchGPR, -static_cast&lt;ptrdiff_t&gt;(offset + sizeof(JSValue) + sizeof(void*))));
1803             } else {
1804                 // Handle the case where we are allocating out-of-line using an operation.
1805                 RegisterSet extraRegistersToPreserve;
1806                 extraRegistersToPreserve.set(baseGPR);
1807                 extraRegistersToPreserve.set(valueRegs);
1808                 AccessGenerationState::SpillState spillState = state.preserveLiveRegistersToStackForCall(extraRegistersToPreserve);
1809 
1810                 jit.store32(
1811                     CCallHelpers::TrustedImm32(
1812                         state.callSiteIndexForExceptionHandlingOrOriginal().bits()),
<span class="line-modified">1813                     CCallHelpers::tagFor(CallFrameSlot::argumentCountIncludingThis));</span>
1814 
1815                 jit.makeSpaceOnStackForCCall();
1816 
1817                 if (!reallocating) {
<span class="line-modified">1818                     jit.setupArguments&lt;decltype(operationReallocateButterflyToHavePropertyStorageWithInitialCapacity)&gt;(CCallHelpers::TrustedImmPtr(&amp;vm), baseGPR);</span>
<span class="line-added">1819                     jit.prepareCallOperation(vm);</span>
1820 
1821                     CCallHelpers::Call operationCall = jit.call(OperationPtrTag);
1822                     jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
1823                         linkBuffer.link(
1824                             operationCall,
1825                             FunctionPtr&lt;OperationPtrTag&gt;(operationReallocateButterflyToHavePropertyStorageWithInitialCapacity));
1826                     });
1827                 } else {
1828                     // Handle the case where we are reallocating (i.e. the old structure/butterfly
1829                     // already had out-of-line property storage).
<span class="line-modified">1830                     jit.setupArguments&lt;decltype(operationReallocateButterflyToGrowPropertyStorage)&gt;(CCallHelpers::TrustedImmPtr(&amp;vm), baseGPR, CCallHelpers::TrustedImm32(newSize / sizeof(JSValue)));</span>
<span class="line-modified">1831                     jit.prepareCallOperation(vm);</span>
1832 
1833                     CCallHelpers::Call operationCall = jit.call(OperationPtrTag);
1834                     jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
1835                         linkBuffer.link(
1836                             operationCall,
1837                             FunctionPtr&lt;OperationPtrTag&gt;(operationReallocateButterflyToGrowPropertyStorage));
1838                     });
1839                 }
1840 
1841                 jit.reclaimSpaceOnStackForCCall();
1842                 jit.move(GPRInfo::returnValueGPR, scratchGPR);
1843 
1844                 CCallHelpers::Jump noException = jit.emitExceptionCheck(vm, CCallHelpers::InvertedExceptionCheck);
1845 
1846                 state.restoreLiveRegistersFromStackForCallWithThrownException(spillState);
1847                 state.emitExplicitExceptionHandler();
1848 
1849                 noException.link(&amp;jit);
1850                 RegisterSet resultRegisterToExclude;
1851                 resultRegisterToExclude.set(scratchGPR);
</pre>
<hr />
<pre>
1926     case IntrinsicGetter: {
1927         RELEASE_ASSERT(isValidOffset(offset()));
1928 
1929         // We need to ensure the getter value does not move from under us. Note that GetterSetters
1930         // are immutable so we just need to watch the property not any value inside it.
1931         Structure* currStructure;
1932         if (!hasAlternateBase())
1933             currStructure = structure();
1934         else
1935             currStructure = alternateBase()-&gt;structure(vm);
1936         currStructure-&gt;startWatchingPropertyForReplacements(vm, offset());
1937 
1938         this-&gt;as&lt;IntrinsicGetterAccessCase&gt;().emitIntrinsicGetter(state);
1939         return;
1940     }
1941 
1942     case DirectArgumentsLength:
1943     case ScopedArgumentsLength:
1944     case ModuleNamespaceLoad:
1945     case InstanceOfGeneric:
<span class="line-added">1946     case IndexedInt32Load:</span>
<span class="line-added">1947     case IndexedDoubleLoad:</span>
<span class="line-added">1948     case IndexedContiguousLoad:</span>
<span class="line-added">1949     case IndexedArrayStorageLoad:</span>
<span class="line-added">1950     case IndexedScopedArgumentsLoad:</span>
<span class="line-added">1951     case IndexedDirectArgumentsLoad:</span>
<span class="line-added">1952     case IndexedTypedArrayInt8Load:</span>
<span class="line-added">1953     case IndexedTypedArrayUint8Load:</span>
<span class="line-added">1954     case IndexedTypedArrayUint8ClampedLoad:</span>
<span class="line-added">1955     case IndexedTypedArrayInt16Load:</span>
<span class="line-added">1956     case IndexedTypedArrayUint16Load:</span>
<span class="line-added">1957     case IndexedTypedArrayInt32Load:</span>
<span class="line-added">1958     case IndexedTypedArrayUint32Load:</span>
<span class="line-added">1959     case IndexedTypedArrayFloat32Load:</span>
<span class="line-added">1960     case IndexedTypedArrayFloat64Load:</span>
<span class="line-added">1961     case IndexedStringLoad:</span>
1962         // These need to be handled by generateWithGuard(), since the guard is part of the
1963         // algorithm. We can be sure that nobody will call generate() directly for these since they
1964         // are not guarded by structure checks.
1965         RELEASE_ASSERT_NOT_REACHED();
1966     }
1967 
1968     RELEASE_ASSERT_NOT_REACHED();
1969 }
1970 
<span class="line-added">1971 TypedArrayType AccessCase::toTypedArrayType(AccessType accessType)</span>
<span class="line-added">1972 {</span>
<span class="line-added">1973     switch (accessType) {</span>
<span class="line-added">1974     case IndexedTypedArrayInt8Load:</span>
<span class="line-added">1975         return TypeInt8;</span>
<span class="line-added">1976     case IndexedTypedArrayUint8Load:</span>
<span class="line-added">1977         return TypeUint8;</span>
<span class="line-added">1978     case IndexedTypedArrayUint8ClampedLoad:</span>
<span class="line-added">1979         return TypeUint8Clamped;</span>
<span class="line-added">1980     case IndexedTypedArrayInt16Load:</span>
<span class="line-added">1981         return TypeInt16;</span>
<span class="line-added">1982     case IndexedTypedArrayUint16Load:</span>
<span class="line-added">1983         return TypeUint16;</span>
<span class="line-added">1984     case IndexedTypedArrayInt32Load:</span>
<span class="line-added">1985         return TypeInt32;</span>
<span class="line-added">1986     case IndexedTypedArrayUint32Load:</span>
<span class="line-added">1987         return TypeUint32;</span>
<span class="line-added">1988     case IndexedTypedArrayFloat32Load:</span>
<span class="line-added">1989         return TypeFloat32;</span>
<span class="line-added">1990     case IndexedTypedArrayFloat64Load:</span>
<span class="line-added">1991         return TypeFloat64;</span>
<span class="line-added">1992     default:</span>
<span class="line-added">1993         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">1994     }</span>
<span class="line-added">1995 }</span>
<span class="line-added">1996 </span>
<span class="line-added">1997 #if ASSERT_ENABLED</span>
<span class="line-added">1998 void AccessCase::checkConsistency(StructureStubInfo&amp; stubInfo)</span>
<span class="line-added">1999 {</span>
<span class="line-added">2000     RELEASE_ASSERT(!(requiresInt32PropertyCheck() &amp;&amp; requiresIdentifierNameMatch()));</span>
<span class="line-added">2001 </span>
<span class="line-added">2002     if (stubInfo.hasConstantIdentifier) {</span>
<span class="line-added">2003         RELEASE_ASSERT(!requiresInt32PropertyCheck());</span>
<span class="line-added">2004         RELEASE_ASSERT(requiresIdentifierNameMatch());</span>
<span class="line-added">2005     }</span>
<span class="line-added">2006 }</span>
<span class="line-added">2007 #endif // ASSERT_ENABLED</span>
<span class="line-added">2008 </span>
2009 } // namespace JSC
2010 
2011 #endif
</pre>
</td>
</tr>
</table>
<center><a href="../builtins/TypedArrayPrototype.js.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessCase.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
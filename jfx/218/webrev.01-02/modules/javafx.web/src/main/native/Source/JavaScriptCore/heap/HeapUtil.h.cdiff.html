<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/HeapUtil.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HeapSnapshotBuilder.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IncrementalSweeper.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/HeapUtil.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2016-2018 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 50,33 ***</span>
          void* passedPointer, const Func&amp; func)
      {
          const HashSet&lt;MarkedBlock*&gt;&amp; set = heap.objectSpace().blocks().set();
  
          ASSERT(heap.objectSpace().isMarking());
<span class="line-modified">!         static const bool isMarking = true;</span>
  
          char* pointer = static_cast&lt;char*&gt;(passedPointer);
  
          // It could point to a large allocation.
<span class="line-modified">!         if (heap.objectSpace().largeAllocationsForThisCollectionSize()) {</span>
<span class="line-modified">!             if (heap.objectSpace().largeAllocationsForThisCollectionBegin()[0]-&gt;aboveLowerBound(pointer)</span>
<span class="line-modified">!                 &amp;&amp; heap.objectSpace().largeAllocationsForThisCollectionEnd()[-1]-&gt;belowUpperBound(pointer)) {</span>
<span class="line-modified">!                 LargeAllocation** result = approximateBinarySearch&lt;LargeAllocation*&gt;(</span>
<span class="line-modified">!                     heap.objectSpace().largeAllocationsForThisCollectionBegin(),</span>
<span class="line-modified">!                     heap.objectSpace().largeAllocationsForThisCollectionSize(),</span>
<span class="line-modified">!                     LargeAllocation::fromCell(pointer),</span>
<span class="line-modified">!                     [] (LargeAllocation** ptr) -&gt; LargeAllocation* { return *ptr; });</span>
                  if (result) {
<span class="line-modified">!                     auto attemptLarge = [&amp;] (LargeAllocation* allocation) {</span>
<span class="line-modified">!                         if (allocation-&gt;contains(pointer))</span>
                              func(allocation-&gt;cell(), allocation-&gt;attributes().cellKind);
                      };
  
<span class="line-modified">!                     if (result &gt; heap.objectSpace().largeAllocationsForThisCollectionBegin())</span>
                          attemptLarge(result[-1]);
                      attemptLarge(result[0]);
<span class="line-modified">!                     if (result + 1 &lt; heap.objectSpace().largeAllocationsForThisCollectionEnd())</span>
                          attemptLarge(result[1]);
                  }
              }
          }
  
<span class="line-new-header">--- 50,33 ---</span>
          void* passedPointer, const Func&amp; func)
      {
          const HashSet&lt;MarkedBlock*&gt;&amp; set = heap.objectSpace().blocks().set();
  
          ASSERT(heap.objectSpace().isMarking());
<span class="line-modified">!         static constexpr bool isMarking = true;</span>
  
          char* pointer = static_cast&lt;char*&gt;(passedPointer);
  
          // It could point to a large allocation.
<span class="line-modified">!         if (heap.objectSpace().preciseAllocationsForThisCollectionSize()) {</span>
<span class="line-modified">!             if (heap.objectSpace().preciseAllocationsForThisCollectionBegin()[0]-&gt;aboveLowerBound(pointer)</span>
<span class="line-modified">!                 &amp;&amp; heap.objectSpace().preciseAllocationsForThisCollectionEnd()[-1]-&gt;belowUpperBound(pointer)) {</span>
<span class="line-modified">!                 PreciseAllocation** result = approximateBinarySearch&lt;PreciseAllocation*&gt;(</span>
<span class="line-modified">!                     heap.objectSpace().preciseAllocationsForThisCollectionBegin(),</span>
<span class="line-modified">!                     heap.objectSpace().preciseAllocationsForThisCollectionSize(),</span>
<span class="line-modified">!                     PreciseAllocation::fromCell(pointer),</span>
<span class="line-modified">!                     [] (PreciseAllocation** ptr) -&gt; PreciseAllocation* { return *ptr; });</span>
                  if (result) {
<span class="line-modified">!                     auto attemptLarge = [&amp;] (PreciseAllocation* allocation) {</span>
<span class="line-modified">!                         if (allocation-&gt;contains(pointer) &amp;&amp; allocation-&gt;hasValidCell())</span>
                              func(allocation-&gt;cell(), allocation-&gt;attributes().cellKind);
                      };
  
<span class="line-modified">!                     if (result &gt; heap.objectSpace().preciseAllocationsForThisCollectionBegin())</span>
                          attemptLarge(result[-1]);
                      attemptLarge(result[0]);
<span class="line-modified">!                     if (result + 1 &lt; heap.objectSpace().preciseAllocationsForThisCollectionEnd())</span>
                          attemptLarge(result[1]);
                  }
              }
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 121,41 ***</span>
          char* alignedPointer = static_cast&lt;char*&gt;(candidate-&gt;handle().cellAlign(pointer));
          tryPointer(alignedPointer);
  
          // Also, a butterfly could point at the end of an object plus sizeof(IndexingHeader). In that
          // case, this is pointing to the object to the right of the one we should be marking.
<span class="line-modified">!         if (candidate-&gt;atomNumber(alignedPointer) &gt; 0</span>
              &amp;&amp; pointer &lt;= alignedPointer + sizeof(IndexingHeader))
              tryPointer(alignedPointer - candidate-&gt;cellSize());
      }
  
<span class="line-modified">!     static bool isPointerGCObjectJSCell(</span>
<span class="line-removed">-         Heap&amp; heap, TinyBloomFilter filter, const void* pointer)</span>
      {
          // It could point to a large allocation.
<span class="line-modified">!         const Vector&lt;LargeAllocation*&gt;&amp; largeAllocations = heap.objectSpace().largeAllocations();</span>
<span class="line-modified">!         if (!largeAllocations.isEmpty()) {</span>
<span class="line-modified">!             if (largeAllocations[0]-&gt;aboveLowerBound(pointer)</span>
<span class="line-modified">!                 &amp;&amp; largeAllocations.last()-&gt;belowUpperBound(pointer)) {</span>
<span class="line-modified">!                 LargeAllocation*const* result = approximateBinarySearch&lt;LargeAllocation*const&gt;(</span>
<span class="line-modified">!                     largeAllocations.begin(), largeAllocations.size(),</span>
<span class="line-removed">-                     LargeAllocation::fromCell(pointer),</span>
<span class="line-removed">-                     [] (LargeAllocation*const* ptr) -&gt; LargeAllocation* { return *ptr; });</span>
<span class="line-removed">-                 if (result) {</span>
<span class="line-removed">-                     if (result &gt; largeAllocations.begin()</span>
<span class="line-removed">-                         &amp;&amp; result[-1]-&gt;cell() == pointer</span>
<span class="line-removed">-                         &amp;&amp; isJSCellKind(result[-1]-&gt;attributes().cellKind))</span>
<span class="line-removed">-                         return true;</span>
<span class="line-removed">-                     if (result[0]-&gt;cell() == pointer</span>
<span class="line-removed">-                         &amp;&amp; isJSCellKind(result[0]-&gt;attributes().cellKind))</span>
<span class="line-removed">-                         return true;</span>
<span class="line-removed">-                     if (result + 1 &lt; largeAllocations.end()</span>
<span class="line-removed">-                         &amp;&amp; result[1]-&gt;cell() == pointer</span>
<span class="line-removed">-                         &amp;&amp; isJSCellKind(result[1]-&gt;attributes().cellKind))</span>
<span class="line-removed">-                         return true;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
          }
  
          const HashSet&lt;MarkedBlock*&gt;&amp; set = heap.objectSpace().blocks().set();
  
          MarkedBlock* candidate = MarkedBlock::blockFor(pointer);
<span class="line-new-header">--- 121,24 ---</span>
          char* alignedPointer = static_cast&lt;char*&gt;(candidate-&gt;handle().cellAlign(pointer));
          tryPointer(alignedPointer);
  
          // Also, a butterfly could point at the end of an object plus sizeof(IndexingHeader). In that
          // case, this is pointing to the object to the right of the one we should be marking.
<span class="line-modified">!         if (candidate-&gt;candidateAtomNumber(alignedPointer) &gt; 0</span>
              &amp;&amp; pointer &lt;= alignedPointer + sizeof(IndexingHeader))
              tryPointer(alignedPointer - candidate-&gt;cellSize());
      }
  
<span class="line-modified">!     static bool isPointerGCObjectJSCell(Heap&amp; heap, TinyBloomFilter filter, JSCell* pointer)</span>
      {
          // It could point to a large allocation.
<span class="line-modified">!         if (pointer-&gt;isPreciseAllocation()) {</span>
<span class="line-modified">!             auto* set = heap.objectSpace().preciseAllocationSet();</span>
<span class="line-modified">!             ASSERT(set);</span>
<span class="line-modified">!             if (set-&gt;isEmpty())</span>
<span class="line-modified">!                 return false;</span>
<span class="line-modified">!             return set-&gt;contains(pointer);</span>
          }
  
          const HashSet&lt;MarkedBlock*&gt;&amp; set = heap.objectSpace().blocks().set();
  
          MarkedBlock* candidate = MarkedBlock::blockFor(pointer);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 177,16 ***</span>
              return false;
  
          return true;
      }
  
      static bool isValueGCObject(
          Heap&amp; heap, TinyBloomFilter filter, JSValue value)
      {
          if (!value.isCell())
              return false;
<span class="line-modified">!         return isPointerGCObjectJSCell(heap, filter, static_cast&lt;void*&gt;(value.asCell()));</span>
      }
  };
  
  } // namespace JSC
  
<span class="line-new-header">--- 160,18 ---</span>
              return false;
  
          return true;
      }
  
<span class="line-added">+     // This does not find the cell if the pointer is pointing at the middle of a JSCell.</span>
      static bool isValueGCObject(
          Heap&amp; heap, TinyBloomFilter filter, JSValue value)
      {
<span class="line-added">+         ASSERT(heap.objectSpace().preciseAllocationSet());</span>
          if (!value.isCell())
              return false;
<span class="line-modified">!         return isPointerGCObjectJSCell(heap, filter, value.asCell());</span>
      }
  };
  
  } // namespace JSC
  
</pre>
<center><a href="HeapSnapshotBuilder.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IncrementalSweeper.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
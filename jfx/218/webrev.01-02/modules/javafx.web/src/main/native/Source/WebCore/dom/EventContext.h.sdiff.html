<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/EventContext.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="EventContext.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EventListener.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/EventContext.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 35 
 36 class EventContext {
 37     WTF_MAKE_FAST_ALLOCATED;
 38 public:
 39     using EventInvokePhase = EventTarget::EventInvokePhase;
 40 
 41     EventContext(Node*, EventTarget* currentTarget, EventTarget*, int closedShadowDepth);
 42     virtual ~EventContext();
 43 
 44     Node* node() const { return m_node.get(); }
 45     EventTarget* currentTarget() const { return m_currentTarget.get(); }
 46     EventTarget* target() const { return m_target.get(); }
 47     int closedShadowDepth() const { return m_closedShadowDepth; }
 48 
 49     virtual void handleLocalEvents(Event&amp;, EventInvokePhase) const;
 50 
 51     virtual bool isMouseOrFocusEventContext() const;
 52     virtual bool isTouchEventContext() const;
 53 
 54 protected:
<span class="line-modified"> 55 #if !ASSERT_DISABLED</span>
 56     bool isUnreachableNode(EventTarget*) const;
 57 #endif
 58 
 59     RefPtr&lt;Node&gt; m_node;
 60     RefPtr&lt;EventTarget&gt; m_currentTarget;
 61     RefPtr&lt;EventTarget&gt; m_target;
 62     int m_closedShadowDepth { 0 };
 63 };
 64 
 65 class MouseOrFocusEventContext final : public EventContext {
 66 public:
 67     MouseOrFocusEventContext(Node&amp;, EventTarget* currentTarget, EventTarget*, int closedShadowDepth);
 68     virtual ~MouseOrFocusEventContext();
 69 
 70     Node* relatedTarget() const { return m_relatedTarget.get(); }
 71     void setRelatedTarget(Node*);
 72 
 73 private:
 74     void handleLocalEvents(Event&amp;, EventInvokePhase) const final;
 75     bool isMouseOrFocusEventContext() const final;
</pre>
<hr />
<pre>
 83 public:
 84     TouchEventContext(Node&amp;, EventTarget* currentTarget, EventTarget*, int closedShadowDepth);
 85     virtual ~TouchEventContext();
 86 
 87     enum TouchListType { Touches, TargetTouches, ChangedTouches };
 88     TouchList&amp; touchList(TouchListType);
 89 
 90 private:
 91     void handleLocalEvents(Event&amp;, EventInvokePhase) const final;
 92     bool isTouchEventContext() const final;
 93 
 94     void checkReachability(const Ref&lt;TouchList&gt;&amp;) const;
 95 
 96     Ref&lt;TouchList&gt; m_touches;
 97     Ref&lt;TouchList&gt; m_targetTouches;
 98     Ref&lt;TouchList&gt; m_changedTouches;
 99 };
100 
101 #endif // ENABLE(TOUCH_EVENTS)
102 
<span class="line-modified">103 #if !ASSERT_DISABLED</span>
104 
105 inline bool EventContext::isUnreachableNode(EventTarget* target) const
106 {
107     // FIXME: Checks also for SVG elements.
108     return is&lt;Node&gt;(target) &amp;&amp; !downcast&lt;Node&gt;(*target).isSVGElement() &amp;&amp; m_node-&gt;isClosedShadowHidden(downcast&lt;Node&gt;(*target));
109 }
110 
111 #endif
112 
113 inline void MouseOrFocusEventContext::setRelatedTarget(Node* relatedTarget)
114 {
115     ASSERT(!isUnreachableNode(relatedTarget));
116     m_relatedTarget = relatedTarget;
117 }
118 
119 #if ENABLE(TOUCH_EVENTS)
120 
121 inline TouchList&amp; TouchEventContext::touchList(TouchListType type)
122 {
123     switch (type) {
124     case Touches:
125         return m_touches.get();
126     case TargetTouches:
127         return m_targetTouches.get();
128     case ChangedTouches:
129         return m_changedTouches.get();
130     }
131     ASSERT_NOT_REACHED();
132     return m_touches.get();
133 }
134 
135 #endif
136 
<span class="line-modified">137 #if ENABLE(TOUCH_EVENTS) &amp;&amp; ASSERT_DISABLED</span>
138 
139 inline void TouchEventContext::checkReachability(const Ref&lt;TouchList&gt;&amp;) const
140 {
141 }
142 
143 #endif
144 
145 } // namespace WebCore
146 
147 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::MouseOrFocusEventContext)
148 static bool isType(const WebCore::EventContext&amp; context) { return context.isMouseOrFocusEventContext(); }
149 SPECIALIZE_TYPE_TRAITS_END()
150 
151 #if ENABLE(TOUCH_EVENTS)
152 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::TouchEventContext)
153 static bool isType(const WebCore::EventContext&amp; context) { return context.isTouchEventContext(); }
154 SPECIALIZE_TYPE_TRAITS_END()
155 #endif
</pre>
</td>
<td>
<hr />
<pre>
 35 
 36 class EventContext {
 37     WTF_MAKE_FAST_ALLOCATED;
 38 public:
 39     using EventInvokePhase = EventTarget::EventInvokePhase;
 40 
 41     EventContext(Node*, EventTarget* currentTarget, EventTarget*, int closedShadowDepth);
 42     virtual ~EventContext();
 43 
 44     Node* node() const { return m_node.get(); }
 45     EventTarget* currentTarget() const { return m_currentTarget.get(); }
 46     EventTarget* target() const { return m_target.get(); }
 47     int closedShadowDepth() const { return m_closedShadowDepth; }
 48 
 49     virtual void handleLocalEvents(Event&amp;, EventInvokePhase) const;
 50 
 51     virtual bool isMouseOrFocusEventContext() const;
 52     virtual bool isTouchEventContext() const;
 53 
 54 protected:
<span class="line-modified"> 55 #if ASSERT_ENABLED</span>
 56     bool isUnreachableNode(EventTarget*) const;
 57 #endif
 58 
 59     RefPtr&lt;Node&gt; m_node;
 60     RefPtr&lt;EventTarget&gt; m_currentTarget;
 61     RefPtr&lt;EventTarget&gt; m_target;
 62     int m_closedShadowDepth { 0 };
 63 };
 64 
 65 class MouseOrFocusEventContext final : public EventContext {
 66 public:
 67     MouseOrFocusEventContext(Node&amp;, EventTarget* currentTarget, EventTarget*, int closedShadowDepth);
 68     virtual ~MouseOrFocusEventContext();
 69 
 70     Node* relatedTarget() const { return m_relatedTarget.get(); }
 71     void setRelatedTarget(Node*);
 72 
 73 private:
 74     void handleLocalEvents(Event&amp;, EventInvokePhase) const final;
 75     bool isMouseOrFocusEventContext() const final;
</pre>
<hr />
<pre>
 83 public:
 84     TouchEventContext(Node&amp;, EventTarget* currentTarget, EventTarget*, int closedShadowDepth);
 85     virtual ~TouchEventContext();
 86 
 87     enum TouchListType { Touches, TargetTouches, ChangedTouches };
 88     TouchList&amp; touchList(TouchListType);
 89 
 90 private:
 91     void handleLocalEvents(Event&amp;, EventInvokePhase) const final;
 92     bool isTouchEventContext() const final;
 93 
 94     void checkReachability(const Ref&lt;TouchList&gt;&amp;) const;
 95 
 96     Ref&lt;TouchList&gt; m_touches;
 97     Ref&lt;TouchList&gt; m_targetTouches;
 98     Ref&lt;TouchList&gt; m_changedTouches;
 99 };
100 
101 #endif // ENABLE(TOUCH_EVENTS)
102 
<span class="line-modified">103 #if ASSERT_ENABLED</span>
104 
105 inline bool EventContext::isUnreachableNode(EventTarget* target) const
106 {
107     // FIXME: Checks also for SVG elements.
108     return is&lt;Node&gt;(target) &amp;&amp; !downcast&lt;Node&gt;(*target).isSVGElement() &amp;&amp; m_node-&gt;isClosedShadowHidden(downcast&lt;Node&gt;(*target));
109 }
110 
111 #endif
112 
113 inline void MouseOrFocusEventContext::setRelatedTarget(Node* relatedTarget)
114 {
115     ASSERT(!isUnreachableNode(relatedTarget));
116     m_relatedTarget = relatedTarget;
117 }
118 
119 #if ENABLE(TOUCH_EVENTS)
120 
121 inline TouchList&amp; TouchEventContext::touchList(TouchListType type)
122 {
123     switch (type) {
124     case Touches:
125         return m_touches.get();
126     case TargetTouches:
127         return m_targetTouches.get();
128     case ChangedTouches:
129         return m_changedTouches.get();
130     }
131     ASSERT_NOT_REACHED();
132     return m_touches.get();
133 }
134 
135 #endif
136 
<span class="line-modified">137 #if ENABLE(TOUCH_EVENTS) &amp;&amp; !ASSERT_ENABLED</span>
138 
139 inline void TouchEventContext::checkReachability(const Ref&lt;TouchList&gt;&amp;) const
140 {
141 }
142 
143 #endif
144 
145 } // namespace WebCore
146 
147 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::MouseOrFocusEventContext)
148 static bool isType(const WebCore::EventContext&amp; context) { return context.isMouseOrFocusEventContext(); }
149 SPECIALIZE_TYPE_TRAITS_END()
150 
151 #if ENABLE(TOUCH_EVENTS)
152 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::TouchEventContext)
153 static bool isType(const WebCore::EventContext&amp; context) { return context.isTouchEventContext(); }
154 SPECIALIZE_TYPE_TRAITS_END()
155 #endif
</pre>
</td>
</tr>
</table>
<center><a href="EventContext.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EventListener.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
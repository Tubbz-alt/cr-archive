<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGlobalObjectFunctions.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSGlobalObject.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSGlobalObjectFunctions.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGlobalObjectFunctions.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 37,11 ***</span>
  #include &quot;JSFunction.h&quot;
  #include &quot;JSGlobalObject.h&quot;
  #include &quot;JSInternalPromise.h&quot;
  #include &quot;JSModuleLoader.h&quot;
  #include &quot;JSPromise.h&quot;
<span class="line-removed">- #include &quot;JSPromiseDeferred.h&quot;</span>
  #include &quot;JSString.h&quot;
  #include &quot;Lexer.h&quot;
  #include &quot;LiteralParser.h&quot;
  #include &quot;Nodes.h&quot;
  #include &quot;ObjectConstructor.h&quot;
<span class="line-new-header">--- 37,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 72,20 ***</span>
          bitmap.set(characters[i]);
      return bitmap;
  }
  
  template&lt;typename CharacterType&gt;
<span class="line-modified">! static JSValue encode(ExecState* exec, const Bitmap&lt;256&gt;&amp; doNotEscape, const CharacterType* characters, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 18.2.6.1.1 Runtime Semantics: Encode ( string, unescapedSet )
      // https://tc39.github.io/ecma262/#sec-encode
  
<span class="line-modified">!     auto throwException = [&amp;scope, exec] {</span>
<span class="line-modified">!         return JSC::throwException(exec, scope, createURIError(exec, &quot;String contained an illegal UTF-16 sequence.&quot;_s));</span>
      };
  
      StringBuilder builder(StringBuilder::OverflowHandler::RecordOverflow);
      builder.reserveCapacity(length);
  
<span class="line-new-header">--- 71,20 ---</span>
          bitmap.set(characters[i]);
      return bitmap;
  }
  
  template&lt;typename CharacterType&gt;
<span class="line-modified">! static JSValue encode(JSGlobalObject* globalObject, const Bitmap&lt;256&gt;&amp; doNotEscape, const CharacterType* characters, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 18.2.6.1.1 Runtime Semantics: Encode ( string, unescapedSet )
      // https://tc39.github.io/ecma262/#sec-encode
  
<span class="line-modified">!     auto throwException = [&amp;scope, globalObject] {</span>
<span class="line-modified">!         return JSC::throwException(globalObject, scope, createURIError(globalObject, &quot;String contained an illegal UTF-16 sequence.&quot;_s));</span>
      };
  
      StringBuilder builder(StringBuilder::OverflowHandler::RecordOverflow);
      builder.reserveCapacity(length);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 144,33 ***</span>
          for (unsigned index = 0; index &lt; utf8Length; ++index) {
              // 4-d-vi-1. Let jOctet be the value at index j within Octets.
              // 4-d-vi-2. Let S be a String containing three code units &quot;%XY&quot; where XY are two uppercase hexadecimal digits encoding the value of jOctet.
              // 4-d-vi-3. Let R be a new String value computed by concatenating the previous value of R and S.
              builder.append(&#39;%&#39;);
<span class="line-modified">!             appendByteAsHex(utf8OctetsBuffer[index], builder);</span>
          }
      }
  
      if (UNLIKELY(builder.hasOverflowed()))
<span class="line-modified">!         return throwOutOfMemoryError(exec, scope);</span>
      return jsString(vm, builder.toString());
  }
  
<span class="line-modified">! static JSValue encode(ExecState* exec, const Bitmap&lt;256&gt;&amp; doNotEscape)</span>
  {
<span class="line-modified">!     return toStringView(exec, exec-&gt;argument(0), [&amp;] (StringView view) {</span>
          if (view.is8Bit())
<span class="line-modified">!             return encode(exec, doNotEscape, view.characters8(), view.length());</span>
<span class="line-modified">!         return encode(exec, doNotEscape, view.characters16(), view.length());</span>
      });
  }
  
  template &lt;typename CharType&gt;
  ALWAYS_INLINE
<span class="line-modified">! static JSValue decode(ExecState* exec, const CharType* characters, int length, const Bitmap&lt;256&gt;&amp; doNotUnescape, bool strict)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      StringBuilder builder(StringBuilder::OverflowHandler::RecordOverflow);
      int k = 0;
      UChar u = 0;
<span class="line-new-header">--- 143,33 ---</span>
          for (unsigned index = 0; index &lt; utf8Length; ++index) {
              // 4-d-vi-1. Let jOctet be the value at index j within Octets.
              // 4-d-vi-2. Let S be a String containing three code units &quot;%XY&quot; where XY are two uppercase hexadecimal digits encoding the value of jOctet.
              // 4-d-vi-3. Let R be a new String value computed by concatenating the previous value of R and S.
              builder.append(&#39;%&#39;);
<span class="line-modified">!             builder.append(hex(utf8OctetsBuffer[index], 2));</span>
          }
      }
  
      if (UNLIKELY(builder.hasOverflowed()))
<span class="line-modified">!         return throwOutOfMemoryError(globalObject, scope);</span>
      return jsString(vm, builder.toString());
  }
  
<span class="line-modified">! static JSValue encode(JSGlobalObject* globalObject, JSValue argument, const Bitmap&lt;256&gt;&amp; doNotEscape)</span>
  {
<span class="line-modified">!     return toStringView(globalObject, argument, [&amp;] (StringView view) {</span>
          if (view.is8Bit())
<span class="line-modified">!             return encode(globalObject, doNotEscape, view.characters8(), view.length());</span>
<span class="line-modified">!         return encode(globalObject, doNotEscape, view.characters16(), view.length());</span>
      });
  }
  
  template &lt;typename CharType&gt;
  ALWAYS_INLINE
<span class="line-modified">! static JSValue decode(JSGlobalObject* globalObject, const CharType* characters, int length, const Bitmap&lt;256&gt;&amp; doNotUnescape, bool strict)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      StringBuilder builder(StringBuilder::OverflowHandler::RecordOverflow);
      int k = 0;
      UChar u = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 218,11 ***</span>
                      }
                  }
              }
              if (charLen == 0) {
                  if (strict)
<span class="line-modified">!                     return throwException(exec, scope, createURIError(exec, &quot;URI error&quot;_s));</span>
                  // The only case where we don&#39;t use &quot;strict&quot; mode is the &quot;unescape&quot; function.
                  // For that, it&#39;s good to support the wonky &quot;%u&quot; syntax for compatibility with WinIE.
                  if (k &lt;= length - 6 &amp;&amp; p[1] == &#39;u&#39;
                          &amp;&amp; isASCIIHexDigit(p[2]) &amp;&amp; isASCIIHexDigit(p[3])
                          &amp;&amp; isASCIIHexDigit(p[4]) &amp;&amp; isASCIIHexDigit(p[5])) {
<span class="line-new-header">--- 217,11 ---</span>
                      }
                  }
              }
              if (charLen == 0) {
                  if (strict)
<span class="line-modified">!                     return throwException(globalObject, scope, createURIError(globalObject, &quot;URI error&quot;_s));</span>
                  // The only case where we don&#39;t use &quot;strict&quot; mode is the &quot;unescape&quot; function.
                  // For that, it&#39;s good to support the wonky &quot;%u&quot; syntax for compatibility with WinIE.
                  if (k &lt;= length - 6 &amp;&amp; p[1] == &#39;u&#39;
                          &amp;&amp; isASCIIHexDigit(p[2]) &amp;&amp; isASCIIHexDigit(p[3])
                          &amp;&amp; isASCIIHexDigit(p[4]) &amp;&amp; isASCIIHexDigit(p[5])) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 238,20 ***</span>
          }
          k++;
          builder.append(c);
      }
      if (UNLIKELY(builder.hasOverflowed()))
<span class="line-modified">!         return throwOutOfMemoryError(exec, scope);</span>
      RELEASE_AND_RETURN(scope, jsString(vm, builder.toString()));
  }
  
<span class="line-modified">! static JSValue decode(ExecState* exec, const Bitmap&lt;256&gt;&amp; doNotUnescape, bool strict)</span>
  {
<span class="line-modified">!     return toStringView(exec, exec-&gt;argument(0), [&amp;] (StringView view) {</span>
          if (view.is8Bit())
<span class="line-modified">!             return decode(exec, view.characters8(), view.length(), doNotUnescape, strict);</span>
<span class="line-modified">!         return decode(exec, view.characters16(), view.length(), doNotUnescape, strict);</span>
      });
  }
  
  static const int SizeOfInfinity = 8;
  
<span class="line-new-header">--- 237,20 ---</span>
          }
          k++;
          builder.append(c);
      }
      if (UNLIKELY(builder.hasOverflowed()))
<span class="line-modified">!         return throwOutOfMemoryError(globalObject, scope);</span>
      RELEASE_AND_RETURN(scope, jsString(vm, builder.toString()));
  }
  
<span class="line-modified">! static JSValue decode(JSGlobalObject* globalObject, JSValue argument, const Bitmap&lt;256&gt;&amp; doNotUnescape, bool strict)</span>
  {
<span class="line-modified">!     return toStringView(globalObject, argument, [&amp;] (StringView view) {</span>
          if (view.is8Bit())
<span class="line-modified">!             return decode(globalObject, view.characters8(), view.length(), doNotUnescape, strict);</span>
<span class="line-modified">!         return decode(globalObject, view.characters16(), view.length(), doNotUnescape, strict);</span>
      });
  }
  
  static const int SizeOfInfinity = 8;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 476,54 ***</span>
          return PNaN;
  
      return jsStrDecimalLiteral(data, end);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncEval(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue x = exec-&gt;argument(0);</span>
      if (!x.isString())
          return JSValue::encode(x);
  
<span class="line-removed">-     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
      if (!globalObject-&gt;evalEnabled()) {
<span class="line-modified">!         throwException(exec, scope, createEvalError(exec, globalObject-&gt;evalDisabledErrorMessage()));</span>
          return JSValue::encode(jsUndefined());
      }
  
<span class="line-modified">!     String s = asString(x)-&gt;value(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      JSValue parsedObject;
      if (s.is8Bit()) {
<span class="line-modified">!         LiteralParser&lt;LChar&gt; preparser(exec, s.characters8(), s.length(), NonStrictJSON);</span>
          parsedObject = preparser.tryLiteralParse();
      } else {
<span class="line-modified">!         LiteralParser&lt;UChar&gt; preparser(exec, s.characters16(), s.length(), NonStrictJSON);</span>
          parsedObject = preparser.tryLiteralParse();
      }
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      if (parsedObject)
          return JSValue::encode(parsedObject);
  
<span class="line-modified">!     SourceOrigin sourceOrigin = exec-&gt;callerSourceOrigin();</span>
<span class="line-modified">!     JSGlobalObject* calleeGlobalObject = exec-&gt;jsCallee()-&gt;globalObject(vm);</span>
<span class="line-removed">-     EvalExecutable* eval = IndirectEvalExecutable::create(exec, makeSource(s, sourceOrigin), false, DerivedContextType::None, false, EvalContextType::None);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !eval);
      if (!eval)
          return encodedJSValue();
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(vm.interpreter-&gt;execute(eval, exec, calleeGlobalObject-&gt;globalThis(), calleeGlobalObject-&gt;globalScope())));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncParseInt(ExecState* exec)</span>
  {
<span class="line-modified">!     JSValue value = exec-&gt;argument(0);</span>
<span class="line-modified">!     JSValue radixValue = exec-&gt;argument(1);</span>
  
      // Optimized handling for numbers:
      // If the argument is 0 or a number in range 10^-6 &lt;= n &lt; INT_MAX+1, then parseInt
      // results in a truncation to integer. In the case of -0, this is converted to 0.
      //
<span class="line-new-header">--- 475,52 ---</span>
          return PNaN;
  
      return jsStrDecimalLiteral(data, end);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncEval(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue x = callFrame-&gt;argument(0);</span>
      if (!x.isString())
          return JSValue::encode(x);
  
      if (!globalObject-&gt;evalEnabled()) {
<span class="line-modified">!         throwException(globalObject, scope, createEvalError(globalObject, globalObject-&gt;evalDisabledErrorMessage()));</span>
          return JSValue::encode(jsUndefined());
      }
  
<span class="line-modified">!     String s = asString(x)-&gt;value(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      JSValue parsedObject;
      if (s.is8Bit()) {
<span class="line-modified">!         LiteralParser&lt;LChar&gt; preparser(globalObject, s.characters8(), s.length(), NonStrictJSON, nullptr);</span>
          parsedObject = preparser.tryLiteralParse();
      } else {
<span class="line-modified">!         LiteralParser&lt;UChar&gt; preparser(globalObject, s.characters16(), s.length(), NonStrictJSON, nullptr);</span>
          parsedObject = preparser.tryLiteralParse();
      }
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      if (parsedObject)
          return JSValue::encode(parsedObject);
  
<span class="line-modified">!     SourceOrigin sourceOrigin = callFrame-&gt;callerSourceOrigin(vm);</span>
<span class="line-modified">!     EvalExecutable* eval = IndirectEvalExecutable::create(globalObject, makeSource(s, sourceOrigin), false, DerivedContextType::None, false, EvalContextType::None);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !eval);
      if (!eval)
          return encodedJSValue();
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(vm.interpreter-&gt;execute(eval, globalObject, globalObject-&gt;globalThis(), globalObject-&gt;globalScope())));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncParseInt(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     JSValue value = callFrame-&gt;argument(0);</span>
<span class="line-modified">!     JSValue radixValue = callFrame-&gt;argument(1);</span>
  
      // Optimized handling for numbers:
      // If the argument is 0 or a number in range 10^-6 &lt;= n &lt; INT_MAX+1, then parseInt
      // results in a truncation to integer. In the case of -0, this is converted to 0.
      //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 539,108 ***</span>
          if (((n &lt; intMaxPlusOne &amp;&amp; n &gt;= tenToTheMinus6) || !n) &amp;&amp; radixValue.isUndefinedOrNull())
              return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(n)));
      }
  
      // If ToString throws, we shouldn&#39;t call ToInt32.
<span class="line-modified">!     return toStringView(exec, value, [&amp;] (StringView view) {</span>
<span class="line-modified">!         return JSValue::encode(jsNumber(parseInt(view, radixValue.toInt32(exec))));</span>
      });
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncParseFloat(ExecState* exec)</span>
  {
<span class="line-modified">!     auto viewWithString = exec-&gt;argument(0).toString(exec)-&gt;viewWithUnderlyingString(exec);</span>
      return JSValue::encode(jsNumber(parseFloat(viewWithString.view)));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncDecodeURI(ExecState* exec)</span>
  {
      static Bitmap&lt;256&gt; doNotUnescapeWhenDecodingURI = makeCharacterBitmap(
          &quot;#$&amp;+,/:;=?@&quot;
      );
  
<span class="line-modified">!     return JSValue::encode(decode(exec, doNotUnescapeWhenDecodingURI, true));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncDecodeURIComponent(ExecState* exec)</span>
  {
      static Bitmap&lt;256&gt; emptyBitmap;
<span class="line-modified">!     return JSValue::encode(decode(exec, emptyBitmap, true));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncEncodeURI(ExecState* exec)</span>
  {
      static Bitmap&lt;256&gt; doNotEscapeWhenEncodingURI = makeCharacterBitmap(
          &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
          &quot;abcdefghijklmnopqrstuvwxyz&quot;
          &quot;0123456789&quot;
          &quot;!#$&amp;&#39;()*+,-./:;=?@_~&quot;
      );
  
<span class="line-modified">!     return JSValue::encode(encode(exec, doNotEscapeWhenEncodingURI));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncEncodeURIComponent(ExecState* exec)</span>
  {
      static Bitmap&lt;256&gt; doNotEscapeWhenEncodingURIComponent = makeCharacterBitmap(
          &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
          &quot;abcdefghijklmnopqrstuvwxyz&quot;
          &quot;0123456789&quot;
          &quot;!&#39;()*-._~&quot;
      );
  
<span class="line-modified">!     return JSValue::encode(encode(exec, doNotEscapeWhenEncodingURIComponent));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncEscape(ExecState* exec)</span>
  {
      static Bitmap&lt;256&gt; doNotEscape = makeCharacterBitmap(
          &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
          &quot;abcdefghijklmnopqrstuvwxyz&quot;
          &quot;0123456789&quot;
          &quot;*+-./@_&quot;
      );
  
<span class="line-modified">!     return JSValue::encode(toStringView(exec, exec-&gt;argument(0), [&amp;] (StringView view) {</span>
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
          StringBuilder builder;
          if (view.is8Bit()) {
              const LChar* c = view.characters8();
              for (unsigned k = 0; k &lt; view.length(); k++, c++) {
                  int u = c[0];
                  if (doNotEscape.get(static_cast&lt;LChar&gt;(u)))
                      builder.append(*c);
                  else {
                      builder.append(&#39;%&#39;);
<span class="line-modified">!                     appendByteAsHex(u, builder);</span>
                  }
              }
              return jsString(vm, builder.toString());
          }
  
          const UChar* c = view.characters16();
          for (unsigned k = 0; k &lt; view.length(); k++, c++) {
              UChar u = c[0];
              if (u &gt;= doNotEscape.size()) {
                  builder.appendLiteral(&quot;%u&quot;);
<span class="line-modified">!                 appendByteAsHex(u &gt;&gt; 8, builder);</span>
<span class="line-modified">!                 appendByteAsHex(u &amp; 0xFF, builder);</span>
              } else if (doNotEscape.get(static_cast&lt;LChar&gt;(u)))
                  builder.append(*c);
              else {
                  builder.append(&#39;%&#39;);
<span class="line-modified">!                 appendByteAsHex(u, builder);</span>
              }
          }
  
          return jsString(vm, builder.toString());
      }));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncUnescape(ExecState* exec)</span>
  {
<span class="line-modified">!     return JSValue::encode(toStringView(exec, exec-&gt;argument(0), [&amp;] (StringView view) {</span>
          // We use int for k and length intentionally since we would like to evaluate
          // the condition `k &lt;= length -6` even if length is less than 6.
          int k = 0;
          int length = view.length();
  
<span class="line-new-header">--- 536,108 ---</span>
          if (((n &lt; intMaxPlusOne &amp;&amp; n &gt;= tenToTheMinus6) || !n) &amp;&amp; radixValue.isUndefinedOrNull())
              return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(n)));
      }
  
      // If ToString throws, we shouldn&#39;t call ToInt32.
<span class="line-modified">!     return toStringView(globalObject, value, [&amp;] (StringView view) {</span>
<span class="line-modified">!         return JSValue::encode(jsNumber(parseInt(view, radixValue.toInt32(globalObject))));</span>
      });
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncParseFloat(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     auto viewWithString = callFrame-&gt;argument(0).toString(globalObject)-&gt;viewWithUnderlyingString(globalObject);</span>
      return JSValue::encode(jsNumber(parseFloat(viewWithString.view)));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncDecodeURI(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      static Bitmap&lt;256&gt; doNotUnescapeWhenDecodingURI = makeCharacterBitmap(
          &quot;#$&amp;+,/:;=?@&quot;
      );
  
<span class="line-modified">!     return JSValue::encode(decode(globalObject, callFrame-&gt;argument(0), doNotUnescapeWhenDecodingURI, true));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncDecodeURIComponent(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      static Bitmap&lt;256&gt; emptyBitmap;
<span class="line-modified">!     return JSValue::encode(decode(globalObject, callFrame-&gt;argument(0), emptyBitmap, true));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncEncodeURI(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      static Bitmap&lt;256&gt; doNotEscapeWhenEncodingURI = makeCharacterBitmap(
          &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
          &quot;abcdefghijklmnopqrstuvwxyz&quot;
          &quot;0123456789&quot;
          &quot;!#$&amp;&#39;()*+,-./:;=?@_~&quot;
      );
  
<span class="line-modified">!     return JSValue::encode(encode(globalObject, callFrame-&gt;argument(0), doNotEscapeWhenEncodingURI));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncEncodeURIComponent(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      static Bitmap&lt;256&gt; doNotEscapeWhenEncodingURIComponent = makeCharacterBitmap(
          &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
          &quot;abcdefghijklmnopqrstuvwxyz&quot;
          &quot;0123456789&quot;
          &quot;!&#39;()*-._~&quot;
      );
  
<span class="line-modified">!     return JSValue::encode(encode(globalObject, callFrame-&gt;argument(0), doNotEscapeWhenEncodingURIComponent));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncEscape(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      static Bitmap&lt;256&gt; doNotEscape = makeCharacterBitmap(
          &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
          &quot;abcdefghijklmnopqrstuvwxyz&quot;
          &quot;0123456789&quot;
          &quot;*+-./@_&quot;
      );
  
<span class="line-modified">!     return JSValue::encode(toStringView(globalObject, callFrame-&gt;argument(0), [&amp;] (StringView view) {</span>
<span class="line-modified">!         VM&amp; vm = globalObject-&gt;vm();</span>
          StringBuilder builder;
          if (view.is8Bit()) {
              const LChar* c = view.characters8();
              for (unsigned k = 0; k &lt; view.length(); k++, c++) {
                  int u = c[0];
                  if (doNotEscape.get(static_cast&lt;LChar&gt;(u)))
                      builder.append(*c);
                  else {
                      builder.append(&#39;%&#39;);
<span class="line-modified">!                     builder.append(hex(u, 2));</span>
                  }
              }
              return jsString(vm, builder.toString());
          }
  
          const UChar* c = view.characters16();
          for (unsigned k = 0; k &lt; view.length(); k++, c++) {
              UChar u = c[0];
              if (u &gt;= doNotEscape.size()) {
                  builder.appendLiteral(&quot;%u&quot;);
<span class="line-modified">!                 builder.append(hex(static_cast&lt;unsigned char&gt;(u &gt;&gt; 8), 2));</span>
<span class="line-modified">!                 builder.append(hex(static_cast&lt;unsigned char&gt;(u &amp; 0xFF), 2));</span>
              } else if (doNotEscape.get(static_cast&lt;LChar&gt;(u)))
                  builder.append(*c);
              else {
                  builder.append(&#39;%&#39;);
<span class="line-modified">!                 builder.append(hex(static_cast&lt;unsigned char&gt;(u), 2));</span>
              }
          }
  
          return jsString(vm, builder.toString());
      }));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncUnescape(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     return JSValue::encode(toStringView(globalObject, callFrame-&gt;argument(0), [&amp;] (StringView view) {</span>
          // We use int for k and length intentionally since we would like to evaluate
          // the condition `k &lt;= length -6` even if length is less than 6.
          int k = 0;
          int length = view.length();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 686,66 ***</span>
                  k++;
                  builder.append(*c);
              }
          }
  
<span class="line-modified">!         return jsString(exec-&gt;vm(), builder.toString());</span>
      }));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncThrowTypeError(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     return throwVMTypeError(exec, scope);</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncThrowTypeErrorArgumentsCalleeAndCaller(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     return throwVMTypeError(exec, scope, &quot;&#39;arguments&#39;, &#39;callee&#39;, and &#39;caller&#39; cannot be accessed in this context.&quot;);</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncMakeTypeError(ExecState* exec)</span>
  {
<span class="line-removed">-     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
      Structure* errorStructure = globalObject-&gt;errorStructure(ErrorType::TypeError);
<span class="line-modified">!     return JSValue::encode(ErrorInstance::create(exec, errorStructure, exec-&gt;argument(0), nullptr, TypeNothing, false));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncProtoGetter(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);</span>
      if (thisValue.isUndefinedOrNull())
<span class="line-modified">!         return throwVMError(exec, scope, createNotAnObjectError(exec, thisValue));</span>
  
      JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, thisValue);
      if (!thisObject) {
<span class="line-modified">!         JSObject* prototype = thisValue.synthesizePrototype(exec);</span>
          EXCEPTION_ASSERT(!!scope.exception() == !prototype);
          if (UNLIKELY(!prototype))
              return JSValue::encode(JSValue());
          return JSValue::encode(prototype);
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(thisObject-&gt;getPrototype(vm, exec)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncProtoSetter(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);</span>
      if (thisValue.isUndefinedOrNull())
<span class="line-modified">!         return throwVMTypeError(exec, scope, ObjectProtoCalledOnNullOrUndefinedError);</span>
  
<span class="line-modified">!     JSValue value = exec-&gt;argument(0);</span>
  
      JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, thisValue);
  
      // Setting __proto__ of a primitive should have no effect.
      if (!thisObject)
<span class="line-new-header">--- 683,65 ---</span>
                  k++;
                  builder.append(*c);
              }
          }
  
<span class="line-modified">!         return jsString(globalObject-&gt;vm(), builder.toString());</span>
      }));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncThrowTypeError(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     return throwVMTypeError(globalObject, scope);</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncThrowTypeErrorArgumentsCalleeAndCaller(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     return throwVMTypeError(globalObject, scope, &quot;&#39;arguments&#39;, &#39;callee&#39;, and &#39;caller&#39; cannot be accessed in this context.&quot;);</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncMakeTypeError(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      Structure* errorStructure = globalObject-&gt;errorStructure(ErrorType::TypeError);
<span class="line-modified">!     return JSValue::encode(ErrorInstance::create(globalObject, errorStructure, callFrame-&gt;argument(0), nullptr, TypeNothing, false));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncProtoGetter(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue().toThis(globalObject, StrictMode);</span>
      if (thisValue.isUndefinedOrNull())
<span class="line-modified">!         return throwVMError(globalObject, scope, createNotAnObjectError(globalObject, thisValue));</span>
  
      JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, thisValue);
      if (!thisObject) {
<span class="line-modified">!         JSObject* prototype = thisValue.synthesizePrototype(globalObject);</span>
          EXCEPTION_ASSERT(!!scope.exception() == !prototype);
          if (UNLIKELY(!prototype))
              return JSValue::encode(JSValue());
          return JSValue::encode(prototype);
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(thisObject-&gt;getPrototype(vm, globalObject)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncProtoSetter(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue().toThis(globalObject, StrictMode);</span>
      if (thisValue.isUndefinedOrNull())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, ObjectProtoCalledOnNullOrUndefinedError);</span>
  
<span class="line-modified">!     JSValue value = callFrame-&gt;argument(0);</span>
  
      JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, thisValue);
  
      // Setting __proto__ of a primitive should have no effect.
      if (!thisObject)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 755,35 ***</span>
      if (!value.isObject() &amp;&amp; !value.isNull())
          return JSValue::encode(jsUndefined());
  
      scope.release();
      bool shouldThrowIfCantSet = true;
<span class="line-modified">!     thisObject-&gt;setPrototype(vm, exec, value, shouldThrowIfCantSet);</span>
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncHostPromiseRejectionTracker(ExecState* exec)</span>
  {
<span class="line-removed">-     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
      VM&amp; vm = globalObject-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSPromise* promise = jsCast&lt;JSPromise*&gt;(exec-&gt;argument(0));</span>
  
      // InternalPromises should not be exposed to user scripts.
      if (jsDynamicCast&lt;JSInternalPromise*&gt;(vm, promise))
          return JSValue::encode(jsUndefined());
  
<span class="line-modified">!     JSValue operationValue = exec-&gt;argument(1);</span>
  
      ASSERT(operationValue.isNumber());
<span class="line-modified">!     auto operation = static_cast&lt;JSPromiseRejectionOperation&gt;(operationValue.toUInt32(exec));</span>
      ASSERT(operation == JSPromiseRejectionOperation::Reject || operation == JSPromiseRejectionOperation::Handle);
      scope.assertNoException();
  
      if (globalObject-&gt;globalObjectMethodTable()-&gt;promiseRejectionTracker)
<span class="line-modified">!         globalObject-&gt;globalObjectMethodTable()-&gt;promiseRejectionTracker(globalObject, exec, promise, operation);</span>
      else {
          switch (operation) {
          case JSPromiseRejectionOperation::Reject:
              vm.promiseRejected(promise);
              break;
<span class="line-new-header">--- 751,34 ---</span>
      if (!value.isObject() &amp;&amp; !value.isNull())
          return JSValue::encode(jsUndefined());
  
      scope.release();
      bool shouldThrowIfCantSet = true;
<span class="line-modified">!     thisObject-&gt;setPrototype(vm, globalObject, value, shouldThrowIfCantSet);</span>
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncHostPromiseRejectionTracker(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      VM&amp; vm = globalObject-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSPromise* promise = jsCast&lt;JSPromise*&gt;(callFrame-&gt;argument(0));</span>
  
      // InternalPromises should not be exposed to user scripts.
      if (jsDynamicCast&lt;JSInternalPromise*&gt;(vm, promise))
          return JSValue::encode(jsUndefined());
  
<span class="line-modified">!     JSValue operationValue = callFrame-&gt;argument(1);</span>
  
      ASSERT(operationValue.isNumber());
<span class="line-modified">!     auto operation = static_cast&lt;JSPromiseRejectionOperation&gt;(operationValue.toUInt32(globalObject));</span>
      ASSERT(operation == JSPromiseRejectionOperation::Reject || operation == JSPromiseRejectionOperation::Handle);
      scope.assertNoException();
  
      if (globalObject-&gt;globalObjectMethodTable()-&gt;promiseRejectionTracker)
<span class="line-modified">!         globalObject-&gt;globalObjectMethodTable()-&gt;promiseRejectionTracker(globalObject, promise, operation);</span>
      else {
          switch (operation) {
          case JSPromiseRejectionOperation::Reject:
              vm.promiseRejected(promise);
              break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 795,94 ***</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncBuiltinLog(ExecState* exec)</span>
  {
<span class="line-modified">!     dataLog(exec-&gt;argument(0).toWTFString(exec), &quot;\n&quot;);</span>
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncBuiltinDescribe(ExecState* exec)</span>
  {
<span class="line-modified">!     return JSValue::encode(jsString(exec-&gt;vm(), toString(exec-&gt;argument(0))));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncImportModule(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">-     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto* globalObject = exec-&gt;lexicalGlobalObject();</span>
  
<span class="line-modified">!     auto* promise = JSPromiseDeferred::tryCreate(exec, globalObject);</span>
<span class="line-removed">-     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());</span>
  
      auto catchScope = DECLARE_CATCH_SCOPE(vm);
      auto reject = [&amp;] (JSValue rejectionReason) {
          catchScope.clearException();
<span class="line-modified">!         promise-&gt;reject(exec, rejectionReason);</span>
          catchScope.clearException();
<span class="line-modified">!         return JSValue::encode(promise-&gt;promise());</span>
      };
  
<span class="line-modified">!     auto sourceOrigin = exec-&gt;callerSourceOrigin();</span>
<span class="line-modified">!     RELEASE_ASSERT(exec-&gt;argumentCount() == 1);</span>
<span class="line-modified">!     auto* specifier = exec-&gt;uncheckedArgument(0).toString(exec);</span>
      if (Exception* exception = catchScope.exception())
          return reject(exception-&gt;value());
  
      // We always specify parameters as undefined. Once dynamic import() starts accepting fetching parameters,
      // we should retrieve this from the arguments.
      JSValue parameters = jsUndefined();
<span class="line-modified">!     auto* internalPromise = globalObject-&gt;moduleLoader()-&gt;importModule(exec, specifier, parameters, sourceOrigin);</span>
      if (Exception* exception = catchScope.exception())
          return reject(exception-&gt;value());
<span class="line-modified">!     promise-&gt;resolve(exec, internalPromise);</span>
  
      catchScope.clearException();
<span class="line-modified">!     return JSValue::encode(promise-&gt;promise());</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncPropertyIsEnumerable(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     RELEASE_ASSERT(exec-&gt;argumentCount() == 2);</span>
<span class="line-modified">!     JSObject* object = jsCast&lt;JSObject*&gt;(exec-&gt;uncheckedArgument(0));</span>
<span class="line-modified">!     auto propertyName = exec-&gt;uncheckedArgument(1).toPropertyKey(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      scope.release();
      PropertyDescriptor descriptor;
<span class="line-modified">!     bool enumerable = object-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor) &amp;&amp; descriptor.enumerable();</span>
      return JSValue::encode(jsBoolean(enumerable));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncOwnKeys(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSObject* object = exec-&gt;argument(0).toObject(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(ownPropertyKeys(exec, object, PropertyNameMode::StringsAndSymbols, DontEnumPropertiesMode::Include)));</span>
  }
  
  #if ENABLE(INTL)
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncDateTimeFormat(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-removed">-     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
      IntlDateTimeFormat* dateTimeFormat = IntlDateTimeFormat::create(vm, globalObject-&gt;dateTimeFormatStructure());
<span class="line-modified">!     dateTimeFormat-&gt;initializeDateTimeFormat(*exec, exec-&gt;argument(0), exec-&gt;argument(1));</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     double value = exec-&gt;argument(2).toNumber(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(dateTimeFormat-&gt;format(*exec, value)));</span>
  }
  #endif
  
  } // namespace JSC
<span class="line-new-header">--- 790,89 ---</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncBuiltinLog(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     dataLog(callFrame-&gt;argument(0).toWTFString(globalObject), &quot;\n&quot;);</span>
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncBuiltinDescribe(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     return JSValue::encode(jsString(globalObject-&gt;vm(), toString(callFrame-&gt;argument(0))));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncImportModule(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
  
<span class="line-modified">!     auto* promise = JSPromise::create(vm, globalObject-&gt;promiseStructure());</span>
  
      auto catchScope = DECLARE_CATCH_SCOPE(vm);
      auto reject = [&amp;] (JSValue rejectionReason) {
          catchScope.clearException();
<span class="line-modified">!         promise-&gt;reject(globalObject, rejectionReason);</span>
          catchScope.clearException();
<span class="line-modified">!         return JSValue::encode(promise);</span>
      };
  
<span class="line-modified">!     auto sourceOrigin = callFrame-&gt;callerSourceOrigin(vm);</span>
<span class="line-modified">!     RELEASE_ASSERT(callFrame-&gt;argumentCount() == 1);</span>
<span class="line-modified">!     auto* specifier = callFrame-&gt;uncheckedArgument(0).toString(globalObject);</span>
      if (Exception* exception = catchScope.exception())
          return reject(exception-&gt;value());
  
      // We always specify parameters as undefined. Once dynamic import() starts accepting fetching parameters,
      // we should retrieve this from the arguments.
      JSValue parameters = jsUndefined();
<span class="line-modified">!     auto* internalPromise = globalObject-&gt;moduleLoader()-&gt;importModule(globalObject, specifier, parameters, sourceOrigin);</span>
      if (Exception* exception = catchScope.exception())
          return reject(exception-&gt;value());
<span class="line-modified">!     promise-&gt;resolve(globalObject, internalPromise);</span>
  
      catchScope.clearException();
<span class="line-modified">!     return JSValue::encode(promise);</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncPropertyIsEnumerable(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     RELEASE_ASSERT(callFrame-&gt;argumentCount() == 2);</span>
<span class="line-modified">!     JSObject* object = jsCast&lt;JSObject*&gt;(callFrame-&gt;uncheckedArgument(0));</span>
<span class="line-modified">!     auto propertyName = callFrame-&gt;uncheckedArgument(1).toPropertyKey(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      scope.release();
      PropertyDescriptor descriptor;
<span class="line-modified">!     bool enumerable = object-&gt;getOwnPropertyDescriptor(globalObject, propertyName, descriptor) &amp;&amp; descriptor.enumerable();</span>
      return JSValue::encode(jsBoolean(enumerable));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncOwnKeys(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSObject* object = callFrame-&gt;argument(0).toObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(ownPropertyKeys(globalObject, object, PropertyNameMode::StringsAndSymbols, DontEnumPropertiesMode::Include)));</span>
  }
  
  #if ENABLE(INTL)
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL globalFuncDateTimeFormat(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      IntlDateTimeFormat* dateTimeFormat = IntlDateTimeFormat::create(vm, globalObject-&gt;dateTimeFormatStructure());
<span class="line-modified">!     dateTimeFormat-&gt;initializeDateTimeFormat(globalObject, callFrame-&gt;argument(0), callFrame-&gt;argument(1));</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     double value = callFrame-&gt;argument(2).toNumber(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(dateTimeFormat-&gt;format(globalObject, value)));</span>
  }
  #endif
  
  } // namespace JSC
</pre>
<center><a href="JSGlobalObject.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSGlobalObjectFunctions.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Lookup.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Lookup.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Lookup.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Lookup.h
@@ -42,11 +42,11 @@
     const int16_t value;
     const int16_t next;
 };
 
 // FIXME: There is no reason this get function can't be simpler.
-// ie. typedef JSValue (*GetFunction)(ExecState*, JSObject* baseObject)
+// ie. typedef JSValue (*GetFunction)(JSGlobalObject*, JSObject* baseObject)
 typedef PropertySlot::GetValueFunc GetFunction;
 typedef PutPropertySlot::PutValueFunc PutFunction;
 typedef FunctionExecutable* (*BuiltinGenerator)(VM&);
 typedef JSValue (*LazyPropertyCallback)(VM&, JSObject*);
 
@@ -264,28 +264,28 @@
 }
 
 // 'base' means the object holding the property (possibly in the prototype chain of the object put was called on).
 // 'thisValue' is the object that put is being applied to (in the case of a proxy, the proxy target).
 // 'slot.thisValue()' is the object the put was originally performed on (in the case of a proxy, the proxy itself).
-inline bool putEntry(ExecState* exec, const ClassInfo*, const HashTableValue* entry, JSObject* base, JSObject* thisValue, PropertyName propertyName, JSValue value, PutPropertySlot& slot)
+inline bool putEntry(JSGlobalObject* globalObject, const ClassInfo*, const HashTableValue* entry, JSObject* base, JSObject* thisValue, PropertyName propertyName, JSValue value, PutPropertySlot& slot)
 {
-    VM& vm = exec->vm();
+    VM& vm = getVM(globalObject);
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (entry->attributes() & PropertyAttribute::BuiltinOrFunctionOrLazyProperty) {
         if (!(entry->attributes() & PropertyAttribute::ReadOnly)) {
             // If this is a function or lazy property put then we just do the put because
             // logically the object already had the property, so this is just a replace.
             if (JSObject* thisObject = jsDynamicCast<JSObject*>(vm, thisValue))
                 thisObject->putDirect(vm, propertyName, value);
             return true;
         }
-        return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);
+        return typeError(globalObject, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);
     }
 
     if (entry->attributes() & PropertyAttribute::Accessor)
-        return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);
+        return typeError(globalObject, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);
 
     if (!(entry->attributes() & PropertyAttribute::ReadOnly)) {
         ASSERT_WITH_MESSAGE(!(entry->attributes() & PropertyAttribute::DOMJITAttribute), "DOMJITAttribute supports readonly attributes currently.");
         bool isAccessor = entry->attributes() & PropertyAttribute::CustomAccessor;
         JSValue updateThisValue = entry->attributes() & PropertyAttribute::CustomAccessor ? slot.thisValue() : JSValue(base);
@@ -293,31 +293,31 @@
         if (isAccessor)
             slot.setCustomAccessor(base, entry->propertyPutter());
         else
             slot.setCustomValue(base, entry->propertyPutter());
 
-        bool result = callCustomSetter(exec, entry->propertyPutter(), isAccessor, updateThisValue, value);
+        bool result = callCustomSetter(globalObject, entry->propertyPutter(), isAccessor, updateThisValue, value);
         RETURN_IF_EXCEPTION(scope, false);
         return result;
     }
 
-    return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);
+    return typeError(globalObject, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);
 }
 
 /**
  * This one is for "put".
  * It looks up a hash entry for the property to be set.  If an entry
  * is found it sets the value and returns true, else it returns false.
  */
-inline bool lookupPut(ExecState* exec, PropertyName propertyName, JSObject* base, JSValue value, const HashTable& table, PutPropertySlot& slot, bool& putResult)
+inline bool lookupPut(JSGlobalObject* globalObject, PropertyName propertyName, JSObject* base, JSValue value, const HashTable& table, PutPropertySlot& slot, bool& putResult)
 {
     const HashTableValue* entry = table.entry(propertyName);
 
     if (!entry)
         return false;
 
-    putResult = putEntry(exec, table.classForThis, entry, base, base, propertyName, value, slot);
+    putResult = putEntry(globalObject, table.classForThis, entry, base, base, propertyName, value, slot);
     return true;
 }
 
 inline void reifyStaticProperty(VM& vm, const ClassInfo* classInfo, const PropertyName& propertyName, const HashTableValue& value, JSObject& thisObj)
 {
@@ -359,13 +359,14 @@
         thisObj.putDirect(vm, propertyName, result, attributesForStructure(value.attributes()));
         return;
     }
 
     if (value.attributes() & PropertyAttribute::ClassStructure) {
-        LazyClassStructure* structure = bitwise_cast<LazyClassStructure*>(
+        LazyClassStructure* lazyStructure = bitwise_cast<LazyClassStructure*>(
             bitwise_cast<char*>(&thisObj) + value.lazyClassStructureOffset());
-        structure->get(jsCast<JSGlobalObject*>(&thisObj));
+        JSObject* constructor = lazyStructure->constructor(jsCast<JSGlobalObject*>(&thisObj));
+        thisObj.putDirect(vm, propertyName, constructor, attributesForStructure(value.attributes()));
         return;
     }
 
     if (value.attributes() & PropertyAttribute::PropertyCallback) {
         JSValue result = value.lazyPropertyCallback()(vm, &thisObj);
@@ -402,11 +403,11 @@
         auto key = Identifier::fromString(vm, reinterpret_cast<const LChar*>(value.m_key), strlen(value.m_key));
         reifyStaticProperty(vm, classInfo, key, value, thisObj);
     }
 }
 
-template<RawNativeFunction nativeFunction, int length> EncodedJSValue nonCachingStaticFunctionGetter(ExecState* state, EncodedJSValue, PropertyName propertyName)
+template<RawNativeFunction nativeFunction, int length> EncodedJSValue nonCachingStaticFunctionGetter(JSGlobalObject* globalObject, EncodedJSValue, PropertyName propertyName)
 {
-    return JSValue::encode(JSFunction::create(state->vm(), state->lexicalGlobalObject(), length, propertyName.publicName(), nativeFunction));
+    return JSValue::encode(JSFunction::create(globalObject->vm(), globalObject, length, propertyName.publicName(), nativeFunction));
 }
 
 } // namespace JSC

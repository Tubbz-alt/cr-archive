<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGlobalObjectFunctions.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSGlobalObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSGlobalObjectFunctions.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGlobalObjectFunctions.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 22  *
 23  */
 24 
 25 #include &quot;config.h&quot;
 26 #include &quot;JSGlobalObjectFunctions.h&quot;
 27 
 28 #include &quot;CallFrame.h&quot;
 29 #include &quot;CatchScope.h&quot;
 30 #include &quot;EvalExecutable.h&quot;
 31 #include &quot;Exception.h&quot;
 32 #include &quot;IndirectEvalExecutable.h&quot;
 33 #include &quot;Interpreter.h&quot;
 34 #include &quot;IntlDateTimeFormat.h&quot;
 35 #include &quot;IntlObject.h&quot;
 36 #include &quot;JSCInlines.h&quot;
 37 #include &quot;JSFunction.h&quot;
 38 #include &quot;JSGlobalObject.h&quot;
 39 #include &quot;JSInternalPromise.h&quot;
 40 #include &quot;JSModuleLoader.h&quot;
 41 #include &quot;JSPromise.h&quot;
<span class="line-removed"> 42 #include &quot;JSPromiseDeferred.h&quot;</span>
 43 #include &quot;JSString.h&quot;
 44 #include &quot;Lexer.h&quot;
 45 #include &quot;LiteralParser.h&quot;
 46 #include &quot;Nodes.h&quot;
 47 #include &quot;ObjectConstructor.h&quot;
 48 #include &quot;JSCInlines.h&quot;
 49 #include &quot;ParseInt.h&quot;
 50 #include &quot;Parser.h&quot;
 51 #include &quot;StackVisitor.h&quot;
 52 #include &lt;stdio.h&gt;
 53 #include &lt;stdlib.h&gt;
 54 #include &lt;unicode/utf8.h&gt;
 55 #include &lt;wtf/ASCIICType.h&gt;
 56 #include &lt;wtf/Assertions.h&gt;
 57 #include &lt;wtf/HexNumber.h&gt;
 58 #include &lt;wtf/MathExtras.h&gt;
 59 #include &lt;wtf/dtoa.h&gt;
 60 #include &lt;wtf/text/StringBuilder.h&gt;
 61 
 62 namespace JSC {
 63 
 64 const ASCIILiteral ObjectProtoCalledOnNullOrUndefinedError { &quot;Object.prototype.__proto__ called on null or undefined&quot;_s };
 65 
 66 template&lt;unsigned charactersCount&gt;
 67 static Bitmap&lt;256&gt; makeCharacterBitmap(const char (&amp;characters)[charactersCount])
 68 {
 69     static_assert(charactersCount &gt; 0, &quot;Since string literal is null terminated, characterCount is always larger than 0&quot;);
 70     Bitmap&lt;256&gt; bitmap;
 71     for (unsigned i = 0; i &lt; charactersCount - 1; ++i)
 72         bitmap.set(characters[i]);
 73     return bitmap;
 74 }
 75 
 76 template&lt;typename CharacterType&gt;
<span class="line-modified"> 77 static JSValue encode(ExecState* exec, const Bitmap&lt;256&gt;&amp; doNotEscape, const CharacterType* characters, unsigned length)</span>
 78 {
<span class="line-modified"> 79     VM&amp; vm = exec-&gt;vm();</span>
 80     auto scope = DECLARE_THROW_SCOPE(vm);
 81 
 82     // 18.2.6.1.1 Runtime Semantics: Encode ( string, unescapedSet )
 83     // https://tc39.github.io/ecma262/#sec-encode
 84 
<span class="line-modified"> 85     auto throwException = [&amp;scope, exec] {</span>
<span class="line-modified"> 86         return JSC::throwException(exec, scope, createURIError(exec, &quot;String contained an illegal UTF-16 sequence.&quot;_s));</span>
 87     };
 88 
 89     StringBuilder builder(StringBuilder::OverflowHandler::RecordOverflow);
 90     builder.reserveCapacity(length);
 91 
 92     // 4. Repeat
 93     auto* end = characters + length;
 94     for (auto* cursor = characters; cursor != end; ++cursor) {
 95         auto character = *cursor;
 96 
 97         // 4-c. If C is in unescapedSet, then
 98         if (character &lt; doNotEscape.size() &amp;&amp; doNotEscape.get(character)) {
 99             // 4-c-i. Let S be a String containing only the code unit C.
100             // 4-c-ii. Let R be a new String value computed by concatenating the previous value of R and S.
101             builder.append(static_cast&lt;LChar&gt;(character));
102             continue;
103         }
104 
105         // 4-d-i. If the code unit value of C is not less than 0xDC00 and not greater than 0xDFFF, throw a URIError exception.
106         if (U16_IS_TRAIL(character))
</pre>
<hr />
<pre>
129 
130             // 4-d-iii-5. Let V be UTF16Decode(C, kChar).
131             codePoint = U16_GET_SUPPLEMENTARY(character, trail);
132         }
133 
134         // 4-d-iv. Let Octets be the array of octets resulting by applying the UTF-8 transformation to V, and let L be the array size.
135         LChar utf8OctetsBuffer[U8_MAX_LENGTH];
136         unsigned utf8Length = 0;
137         // We can use U8_APPEND_UNSAFE here since codePoint is either
138         // 1. non surrogate one, correct code point.
139         // 2. correct code point generated from validated lead and trail surrogates.
140         U8_APPEND_UNSAFE(utf8OctetsBuffer, utf8Length, codePoint);
141 
142         // 4-d-v. Let j be 0.
143         // 4-d-vi. Repeat, while j &lt; L
144         for (unsigned index = 0; index &lt; utf8Length; ++index) {
145             // 4-d-vi-1. Let jOctet be the value at index j within Octets.
146             // 4-d-vi-2. Let S be a String containing three code units &quot;%XY&quot; where XY are two uppercase hexadecimal digits encoding the value of jOctet.
147             // 4-d-vi-3. Let R be a new String value computed by concatenating the previous value of R and S.
148             builder.append(&#39;%&#39;);
<span class="line-modified">149             appendByteAsHex(utf8OctetsBuffer[index], builder);</span>
150         }
151     }
152 
153     if (UNLIKELY(builder.hasOverflowed()))
<span class="line-modified">154         return throwOutOfMemoryError(exec, scope);</span>
155     return jsString(vm, builder.toString());
156 }
157 
<span class="line-modified">158 static JSValue encode(ExecState* exec, const Bitmap&lt;256&gt;&amp; doNotEscape)</span>
159 {
<span class="line-modified">160     return toStringView(exec, exec-&gt;argument(0), [&amp;] (StringView view) {</span>
161         if (view.is8Bit())
<span class="line-modified">162             return encode(exec, doNotEscape, view.characters8(), view.length());</span>
<span class="line-modified">163         return encode(exec, doNotEscape, view.characters16(), view.length());</span>
164     });
165 }
166 
167 template &lt;typename CharType&gt;
168 ALWAYS_INLINE
<span class="line-modified">169 static JSValue decode(ExecState* exec, const CharType* characters, int length, const Bitmap&lt;256&gt;&amp; doNotUnescape, bool strict)</span>
170 {
<span class="line-modified">171     VM&amp; vm = exec-&gt;vm();</span>
172     auto scope = DECLARE_THROW_SCOPE(vm);
173 
174     StringBuilder builder(StringBuilder::OverflowHandler::RecordOverflow);
175     int k = 0;
176     UChar u = 0;
177     while (k &lt; length) {
178         const CharType* p = characters + k;
179         CharType c = *p;
180         if (c == &#39;%&#39;) {
181             int charLen = 0;
182             if (k &lt;= length - 3 &amp;&amp; isASCIIHexDigit(p[1]) &amp;&amp; isASCIIHexDigit(p[2])) {
183                 const char b0 = Lexer&lt;CharType&gt;::convertHex(p[1], p[2]);
184                 const int sequenceLen = 1 + U8_COUNT_TRAIL_BYTES(b0);
185                 if (k &lt;= length - sequenceLen * 3) {
186                     charLen = sequenceLen * 3;
187 #if U_ICU_VERSION_MAJOR_NUM &gt;= 60
188                     uint8_t sequence[U8_MAX_LENGTH];
189 #else
190                     // In pre-60 ICU, U8_COUNT_TRAIL_BYTES returns 0..5
191                     uint8_t sequence[6];
</pre>
<hr />
<pre>
203                     if (charLen != 0) {
204                         UChar32 character;
205                         int32_t offset = 0;
206                         U8_NEXT(sequence, offset, sequenceLen, character);
207                         if (character &lt; 0)
208                             charLen = 0;
209                         else if (!U_IS_BMP(character)) {
210                             // Convert to surrogate pair.
211                             ASSERT(U_IS_SUPPLEMENTARY(character));
212                             builder.append(U16_LEAD(character));
213                             u = U16_TRAIL(character);
214                         } else {
215                             ASSERT(!U_IS_SURROGATE(character));
216                             u = static_cast&lt;UChar&gt;(character);
217                         }
218                     }
219                 }
220             }
221             if (charLen == 0) {
222                 if (strict)
<span class="line-modified">223                     return throwException(exec, scope, createURIError(exec, &quot;URI error&quot;_s));</span>
224                 // The only case where we don&#39;t use &quot;strict&quot; mode is the &quot;unescape&quot; function.
225                 // For that, it&#39;s good to support the wonky &quot;%u&quot; syntax for compatibility with WinIE.
226                 if (k &lt;= length - 6 &amp;&amp; p[1] == &#39;u&#39;
227                         &amp;&amp; isASCIIHexDigit(p[2]) &amp;&amp; isASCIIHexDigit(p[3])
228                         &amp;&amp; isASCIIHexDigit(p[4]) &amp;&amp; isASCIIHexDigit(p[5])) {
229                     charLen = 6;
230                     u = Lexer&lt;UChar&gt;::convertUnicode(p[2], p[3], p[4], p[5]);
231                 }
232             }
233             if (charLen &amp;&amp; (u &gt;= 128 || !doNotUnescape.get(static_cast&lt;LChar&gt;(u)))) {
234                 builder.append(u);
235                 k += charLen;
236                 continue;
237             }
238         }
239         k++;
240         builder.append(c);
241     }
242     if (UNLIKELY(builder.hasOverflowed()))
<span class="line-modified">243         return throwOutOfMemoryError(exec, scope);</span>
244     RELEASE_AND_RETURN(scope, jsString(vm, builder.toString()));
245 }
246 
<span class="line-modified">247 static JSValue decode(ExecState* exec, const Bitmap&lt;256&gt;&amp; doNotUnescape, bool strict)</span>
248 {
<span class="line-modified">249     return toStringView(exec, exec-&gt;argument(0), [&amp;] (StringView view) {</span>
250         if (view.is8Bit())
<span class="line-modified">251             return decode(exec, view.characters8(), view.length(), doNotUnescape, strict);</span>
<span class="line-modified">252         return decode(exec, view.characters16(), view.length(), doNotUnescape, strict);</span>
253     });
254 }
255 
256 static const int SizeOfInfinity = 8;
257 
258 template &lt;typename CharType&gt;
259 static bool isInfinity(const CharType* data, const CharType* end)
260 {
261     return (end - data) &gt;= SizeOfInfinity
262         &amp;&amp; data[0] == &#39;I&#39;
263         &amp;&amp; data[1] == &#39;n&#39;
264         &amp;&amp; data[2] == &#39;f&#39;
265         &amp;&amp; data[3] == &#39;i&#39;
266         &amp;&amp; data[4] == &#39;n&#39;
267         &amp;&amp; data[5] == &#39;i&#39;
268         &amp;&amp; data[6] == &#39;t&#39;
269         &amp;&amp; data[7] == &#39;y&#39;;
270 }
271 
272 // See ecma-262 6th 11.8.3
</pre>
<hr />
<pre>
461 
462         return jsStrDecimalLiteral(data, end);
463     }
464 
465     const UChar* data = s.characters16();
466     const UChar* end = data + size;
467 
468     // Skip leading white space.
469     for (; data &lt; end; ++data) {
470         if (!isStrWhiteSpace(*data))
471             break;
472     }
473 
474     // Empty string.
475     if (data == end)
476         return PNaN;
477 
478     return jsStrDecimalLiteral(data, end);
479 }
480 
<span class="line-modified">481 EncodedJSValue JSC_HOST_CALL globalFuncEval(ExecState* exec)</span>
482 {
<span class="line-modified">483     VM&amp; vm = exec-&gt;vm();</span>
484     auto scope = DECLARE_THROW_SCOPE(vm);
485 
<span class="line-modified">486     JSValue x = exec-&gt;argument(0);</span>
487     if (!x.isString())
488         return JSValue::encode(x);
489 
<span class="line-removed">490     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
491     if (!globalObject-&gt;evalEnabled()) {
<span class="line-modified">492         throwException(exec, scope, createEvalError(exec, globalObject-&gt;evalDisabledErrorMessage()));</span>
493         return JSValue::encode(jsUndefined());
494     }
495 
<span class="line-modified">496     String s = asString(x)-&gt;value(exec);</span>
497     RETURN_IF_EXCEPTION(scope, encodedJSValue());
498 
499     JSValue parsedObject;
500     if (s.is8Bit()) {
<span class="line-modified">501         LiteralParser&lt;LChar&gt; preparser(exec, s.characters8(), s.length(), NonStrictJSON);</span>
502         parsedObject = preparser.tryLiteralParse();
503     } else {
<span class="line-modified">504         LiteralParser&lt;UChar&gt; preparser(exec, s.characters16(), s.length(), NonStrictJSON);</span>
505         parsedObject = preparser.tryLiteralParse();
506     }
507     RETURN_IF_EXCEPTION(scope, encodedJSValue());
508     if (parsedObject)
509         return JSValue::encode(parsedObject);
510 
<span class="line-modified">511     SourceOrigin sourceOrigin = exec-&gt;callerSourceOrigin();</span>
<span class="line-modified">512     JSGlobalObject* calleeGlobalObject = exec-&gt;jsCallee()-&gt;globalObject(vm);</span>
<span class="line-removed">513     EvalExecutable* eval = IndirectEvalExecutable::create(exec, makeSource(s, sourceOrigin), false, DerivedContextType::None, false, EvalContextType::None);</span>
514     EXCEPTION_ASSERT(!!scope.exception() == !eval);
515     if (!eval)
516         return encodedJSValue();
517 
<span class="line-modified">518     RELEASE_AND_RETURN(scope, JSValue::encode(vm.interpreter-&gt;execute(eval, exec, calleeGlobalObject-&gt;globalThis(), calleeGlobalObject-&gt;globalScope())));</span>
519 }
520 
<span class="line-modified">521 EncodedJSValue JSC_HOST_CALL globalFuncParseInt(ExecState* exec)</span>
522 {
<span class="line-modified">523     JSValue value = exec-&gt;argument(0);</span>
<span class="line-modified">524     JSValue radixValue = exec-&gt;argument(1);</span>
525 
526     // Optimized handling for numbers:
527     // If the argument is 0 or a number in range 10^-6 &lt;= n &lt; INT_MAX+1, then parseInt
528     // results in a truncation to integer. In the case of -0, this is converted to 0.
529     //
530     // This is also a truncation for values in the range INT_MAX+1 &lt;= n &lt; 10^21,
531     // however these values cannot be trivially truncated to int since 10^21 exceeds
532     // even the int64_t range. Negative numbers are a little trickier, the case for
533     // values in the range -10^21 &lt; n &lt;= -1 are similar to those for integer, but
534     // values in the range -1 &lt; n &lt;= -10^-6 need to truncate to -0, not 0.
535     static const double tenToTheMinus6 = 0.000001;
536     static const double intMaxPlusOne = 2147483648.0;
537     if (value.isNumber()) {
538         double n = value.asNumber();
539         if (((n &lt; intMaxPlusOne &amp;&amp; n &gt;= tenToTheMinus6) || !n) &amp;&amp; radixValue.isUndefinedOrNull())
540             return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(n)));
541     }
542 
543     // If ToString throws, we shouldn&#39;t call ToInt32.
<span class="line-modified">544     return toStringView(exec, value, [&amp;] (StringView view) {</span>
<span class="line-modified">545         return JSValue::encode(jsNumber(parseInt(view, radixValue.toInt32(exec))));</span>
546     });
547 }
548 
<span class="line-modified">549 EncodedJSValue JSC_HOST_CALL globalFuncParseFloat(ExecState* exec)</span>
550 {
<span class="line-modified">551     auto viewWithString = exec-&gt;argument(0).toString(exec)-&gt;viewWithUnderlyingString(exec);</span>
552     return JSValue::encode(jsNumber(parseFloat(viewWithString.view)));
553 }
554 
<span class="line-modified">555 EncodedJSValue JSC_HOST_CALL globalFuncDecodeURI(ExecState* exec)</span>
556 {
557     static Bitmap&lt;256&gt; doNotUnescapeWhenDecodingURI = makeCharacterBitmap(
558         &quot;#$&amp;+,/:;=?@&quot;
559     );
560 
<span class="line-modified">561     return JSValue::encode(decode(exec, doNotUnescapeWhenDecodingURI, true));</span>
562 }
563 
<span class="line-modified">564 EncodedJSValue JSC_HOST_CALL globalFuncDecodeURIComponent(ExecState* exec)</span>
565 {
566     static Bitmap&lt;256&gt; emptyBitmap;
<span class="line-modified">567     return JSValue::encode(decode(exec, emptyBitmap, true));</span>
568 }
569 
<span class="line-modified">570 EncodedJSValue JSC_HOST_CALL globalFuncEncodeURI(ExecState* exec)</span>
571 {
572     static Bitmap&lt;256&gt; doNotEscapeWhenEncodingURI = makeCharacterBitmap(
573         &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
574         &quot;abcdefghijklmnopqrstuvwxyz&quot;
575         &quot;0123456789&quot;
576         &quot;!#$&amp;&#39;()*+,-./:;=?@_~&quot;
577     );
578 
<span class="line-modified">579     return JSValue::encode(encode(exec, doNotEscapeWhenEncodingURI));</span>
580 }
581 
<span class="line-modified">582 EncodedJSValue JSC_HOST_CALL globalFuncEncodeURIComponent(ExecState* exec)</span>
583 {
584     static Bitmap&lt;256&gt; doNotEscapeWhenEncodingURIComponent = makeCharacterBitmap(
585         &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
586         &quot;abcdefghijklmnopqrstuvwxyz&quot;
587         &quot;0123456789&quot;
588         &quot;!&#39;()*-._~&quot;
589     );
590 
<span class="line-modified">591     return JSValue::encode(encode(exec, doNotEscapeWhenEncodingURIComponent));</span>
592 }
593 
<span class="line-modified">594 EncodedJSValue JSC_HOST_CALL globalFuncEscape(ExecState* exec)</span>
595 {
596     static Bitmap&lt;256&gt; doNotEscape = makeCharacterBitmap(
597         &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
598         &quot;abcdefghijklmnopqrstuvwxyz&quot;
599         &quot;0123456789&quot;
600         &quot;*+-./@_&quot;
601     );
602 
<span class="line-modified">603     return JSValue::encode(toStringView(exec, exec-&gt;argument(0), [&amp;] (StringView view) {</span>
<span class="line-modified">604         VM&amp; vm = exec-&gt;vm();</span>
605         StringBuilder builder;
606         if (view.is8Bit()) {
607             const LChar* c = view.characters8();
608             for (unsigned k = 0; k &lt; view.length(); k++, c++) {
609                 int u = c[0];
610                 if (doNotEscape.get(static_cast&lt;LChar&gt;(u)))
611                     builder.append(*c);
612                 else {
613                     builder.append(&#39;%&#39;);
<span class="line-modified">614                     appendByteAsHex(u, builder);</span>
615                 }
616             }
617             return jsString(vm, builder.toString());
618         }
619 
620         const UChar* c = view.characters16();
621         for (unsigned k = 0; k &lt; view.length(); k++, c++) {
622             UChar u = c[0];
623             if (u &gt;= doNotEscape.size()) {
624                 builder.appendLiteral(&quot;%u&quot;);
<span class="line-modified">625                 appendByteAsHex(u &gt;&gt; 8, builder);</span>
<span class="line-modified">626                 appendByteAsHex(u &amp; 0xFF, builder);</span>
627             } else if (doNotEscape.get(static_cast&lt;LChar&gt;(u)))
628                 builder.append(*c);
629             else {
630                 builder.append(&#39;%&#39;);
<span class="line-modified">631                 appendByteAsHex(u, builder);</span>
632             }
633         }
634 
635         return jsString(vm, builder.toString());
636     }));
637 }
638 
<span class="line-modified">639 EncodedJSValue JSC_HOST_CALL globalFuncUnescape(ExecState* exec)</span>
640 {
<span class="line-modified">641     return JSValue::encode(toStringView(exec, exec-&gt;argument(0), [&amp;] (StringView view) {</span>
642         // We use int for k and length intentionally since we would like to evaluate
643         // the condition `k &lt;= length -6` even if length is less than 6.
644         int k = 0;
645         int length = view.length();
646 
647         StringBuilder builder;
648         builder.reserveCapacity(length);
649 
650         if (view.is8Bit()) {
651             const LChar* characters = view.characters8();
652             LChar convertedLChar;
653             while (k &lt; length) {
654                 const LChar* c = characters + k;
655                 if (c[0] == &#39;%&#39; &amp;&amp; k &lt;= length - 6 &amp;&amp; c[1] == &#39;u&#39;) {
656                     if (isASCIIHexDigit(c[2]) &amp;&amp; isASCIIHexDigit(c[3]) &amp;&amp; isASCIIHexDigit(c[4]) &amp;&amp; isASCIIHexDigit(c[5])) {
657                         builder.append(Lexer&lt;UChar&gt;::convertUnicode(c[2], c[3], c[4], c[5]));
658                         k += 6;
659                         continue;
660                     }
661                 } else if (c[0] == &#39;%&#39; &amp;&amp; k &lt;= length - 3 &amp;&amp; isASCIIHexDigit(c[1]) &amp;&amp; isASCIIHexDigit(c[2])) {
</pre>
<hr />
<pre>
671 
672             while (k &lt; length) {
673                 const UChar* c = characters + k;
674                 UChar convertedUChar;
675                 if (c[0] == &#39;%&#39; &amp;&amp; k &lt;= length - 6 &amp;&amp; c[1] == &#39;u&#39;) {
676                     if (isASCIIHexDigit(c[2]) &amp;&amp; isASCIIHexDigit(c[3]) &amp;&amp; isASCIIHexDigit(c[4]) &amp;&amp; isASCIIHexDigit(c[5])) {
677                         convertedUChar = Lexer&lt;UChar&gt;::convertUnicode(c[2], c[3], c[4], c[5]);
678                         c = &amp;convertedUChar;
679                         k += 5;
680                     }
681                 } else if (c[0] == &#39;%&#39; &amp;&amp; k &lt;= length - 3 &amp;&amp; isASCIIHexDigit(c[1]) &amp;&amp; isASCIIHexDigit(c[2])) {
682                     convertedUChar = UChar(Lexer&lt;UChar&gt;::convertHex(c[1], c[2]));
683                     c = &amp;convertedUChar;
684                     k += 2;
685                 }
686                 k++;
687                 builder.append(*c);
688             }
689         }
690 
<span class="line-modified">691         return jsString(exec-&gt;vm(), builder.toString());</span>
692     }));
693 }
694 
<span class="line-modified">695 EncodedJSValue JSC_HOST_CALL globalFuncThrowTypeError(ExecState* exec)</span>
696 {
<span class="line-modified">697     VM&amp; vm = exec-&gt;vm();</span>
698     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">699     return throwVMTypeError(exec, scope);</span>
700 }
701 
<span class="line-modified">702 EncodedJSValue JSC_HOST_CALL globalFuncThrowTypeErrorArgumentsCalleeAndCaller(ExecState* exec)</span>
703 {
<span class="line-modified">704     VM&amp; vm = exec-&gt;vm();</span>
705     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">706     return throwVMTypeError(exec, scope, &quot;&#39;arguments&#39;, &#39;callee&#39;, and &#39;caller&#39; cannot be accessed in this context.&quot;);</span>
707 }
708 
<span class="line-modified">709 EncodedJSValue JSC_HOST_CALL globalFuncMakeTypeError(ExecState* exec)</span>
710 {
<span class="line-removed">711     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
712     Structure* errorStructure = globalObject-&gt;errorStructure(ErrorType::TypeError);
<span class="line-modified">713     return JSValue::encode(ErrorInstance::create(exec, errorStructure, exec-&gt;argument(0), nullptr, TypeNothing, false));</span>
714 }
715 
<span class="line-modified">716 EncodedJSValue JSC_HOST_CALL globalFuncProtoGetter(ExecState* exec)</span>
717 {
<span class="line-modified">718     VM&amp; vm = exec-&gt;vm();</span>
719     auto scope = DECLARE_THROW_SCOPE(vm);
720 
<span class="line-modified">721     JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);</span>
722     if (thisValue.isUndefinedOrNull())
<span class="line-modified">723         return throwVMError(exec, scope, createNotAnObjectError(exec, thisValue));</span>
724 
725     JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, thisValue);
726     if (!thisObject) {
<span class="line-modified">727         JSObject* prototype = thisValue.synthesizePrototype(exec);</span>
728         EXCEPTION_ASSERT(!!scope.exception() == !prototype);
729         if (UNLIKELY(!prototype))
730             return JSValue::encode(JSValue());
731         return JSValue::encode(prototype);
732     }
733 
<span class="line-modified">734     RELEASE_AND_RETURN(scope, JSValue::encode(thisObject-&gt;getPrototype(vm, exec)));</span>
735 }
736 
<span class="line-modified">737 EncodedJSValue JSC_HOST_CALL globalFuncProtoSetter(ExecState* exec)</span>
738 {
<span class="line-modified">739     VM&amp; vm = exec-&gt;vm();</span>
740     auto scope = DECLARE_THROW_SCOPE(vm);
741 
<span class="line-modified">742     JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);</span>
743     if (thisValue.isUndefinedOrNull())
<span class="line-modified">744         return throwVMTypeError(exec, scope, ObjectProtoCalledOnNullOrUndefinedError);</span>
745 
<span class="line-modified">746     JSValue value = exec-&gt;argument(0);</span>
747 
748     JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, thisValue);
749 
750     // Setting __proto__ of a primitive should have no effect.
751     if (!thisObject)
752         return JSValue::encode(jsUndefined());
753 
754     // Setting __proto__ to a non-object, non-null value is silently ignored to match Mozilla.
755     if (!value.isObject() &amp;&amp; !value.isNull())
756         return JSValue::encode(jsUndefined());
757 
758     scope.release();
759     bool shouldThrowIfCantSet = true;
<span class="line-modified">760     thisObject-&gt;setPrototype(vm, exec, value, shouldThrowIfCantSet);</span>
761     return JSValue::encode(jsUndefined());
762 }
763 
<span class="line-modified">764 EncodedJSValue JSC_HOST_CALL globalFuncHostPromiseRejectionTracker(ExecState* exec)</span>
765 {
<span class="line-removed">766     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
767     VM&amp; vm = globalObject-&gt;vm();
768     auto scope = DECLARE_THROW_SCOPE(vm);
769 
<span class="line-modified">770     JSPromise* promise = jsCast&lt;JSPromise*&gt;(exec-&gt;argument(0));</span>
771 
772     // InternalPromises should not be exposed to user scripts.
773     if (jsDynamicCast&lt;JSInternalPromise*&gt;(vm, promise))
774         return JSValue::encode(jsUndefined());
775 
<span class="line-modified">776     JSValue operationValue = exec-&gt;argument(1);</span>
777 
778     ASSERT(operationValue.isNumber());
<span class="line-modified">779     auto operation = static_cast&lt;JSPromiseRejectionOperation&gt;(operationValue.toUInt32(exec));</span>
780     ASSERT(operation == JSPromiseRejectionOperation::Reject || operation == JSPromiseRejectionOperation::Handle);
781     scope.assertNoException();
782 
783     if (globalObject-&gt;globalObjectMethodTable()-&gt;promiseRejectionTracker)
<span class="line-modified">784         globalObject-&gt;globalObjectMethodTable()-&gt;promiseRejectionTracker(globalObject, exec, promise, operation);</span>
785     else {
786         switch (operation) {
787         case JSPromiseRejectionOperation::Reject:
788             vm.promiseRejected(promise);
789             break;
790         case JSPromiseRejectionOperation::Handle:
791             // do nothing
792             break;
793         }
794     }
795     RETURN_IF_EXCEPTION(scope, { });
796 
797     return JSValue::encode(jsUndefined());
798 }
799 
<span class="line-modified">800 EncodedJSValue JSC_HOST_CALL globalFuncBuiltinLog(ExecState* exec)</span>
801 {
<span class="line-modified">802     dataLog(exec-&gt;argument(0).toWTFString(exec), &quot;\n&quot;);</span>
803     return JSValue::encode(jsUndefined());
804 }
805 
<span class="line-modified">806 EncodedJSValue JSC_HOST_CALL globalFuncBuiltinDescribe(ExecState* exec)</span>
807 {
<span class="line-modified">808     return JSValue::encode(jsString(exec-&gt;vm(), toString(exec-&gt;argument(0))));</span>
809 }
810 
<span class="line-modified">811 EncodedJSValue JSC_HOST_CALL globalFuncImportModule(ExecState* exec)</span>
812 {
<span class="line-modified">813     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">814     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-removed">815 </span>
<span class="line-removed">816     auto* globalObject = exec-&gt;lexicalGlobalObject();</span>
817 
<span class="line-modified">818     auto* promise = JSPromiseDeferred::tryCreate(exec, globalObject);</span>
<span class="line-removed">819     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());</span>
820 
821     auto catchScope = DECLARE_CATCH_SCOPE(vm);
822     auto reject = [&amp;] (JSValue rejectionReason) {
823         catchScope.clearException();
<span class="line-modified">824         promise-&gt;reject(exec, rejectionReason);</span>
825         catchScope.clearException();
<span class="line-modified">826         return JSValue::encode(promise-&gt;promise());</span>
827     };
828 
<span class="line-modified">829     auto sourceOrigin = exec-&gt;callerSourceOrigin();</span>
<span class="line-modified">830     RELEASE_ASSERT(exec-&gt;argumentCount() == 1);</span>
<span class="line-modified">831     auto* specifier = exec-&gt;uncheckedArgument(0).toString(exec);</span>
832     if (Exception* exception = catchScope.exception())
833         return reject(exception-&gt;value());
834 
835     // We always specify parameters as undefined. Once dynamic import() starts accepting fetching parameters,
836     // we should retrieve this from the arguments.
837     JSValue parameters = jsUndefined();
<span class="line-modified">838     auto* internalPromise = globalObject-&gt;moduleLoader()-&gt;importModule(exec, specifier, parameters, sourceOrigin);</span>
839     if (Exception* exception = catchScope.exception())
840         return reject(exception-&gt;value());
<span class="line-modified">841     promise-&gt;resolve(exec, internalPromise);</span>
842 
843     catchScope.clearException();
<span class="line-modified">844     return JSValue::encode(promise-&gt;promise());</span>
845 }
846 
<span class="line-modified">847 EncodedJSValue JSC_HOST_CALL globalFuncPropertyIsEnumerable(ExecState* exec)</span>
848 {
<span class="line-modified">849     VM&amp; vm = exec-&gt;vm();</span>
850     auto scope = DECLARE_THROW_SCOPE(vm);
851 
<span class="line-modified">852     RELEASE_ASSERT(exec-&gt;argumentCount() == 2);</span>
<span class="line-modified">853     JSObject* object = jsCast&lt;JSObject*&gt;(exec-&gt;uncheckedArgument(0));</span>
<span class="line-modified">854     auto propertyName = exec-&gt;uncheckedArgument(1).toPropertyKey(exec);</span>
855     RETURN_IF_EXCEPTION(scope, encodedJSValue());
856 
857     scope.release();
858     PropertyDescriptor descriptor;
<span class="line-modified">859     bool enumerable = object-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor) &amp;&amp; descriptor.enumerable();</span>
860     return JSValue::encode(jsBoolean(enumerable));
861 }
862 
<span class="line-modified">863 EncodedJSValue JSC_HOST_CALL globalFuncOwnKeys(ExecState* exec)</span>
864 {
<span class="line-modified">865     VM&amp; vm = exec-&gt;vm();</span>
866     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">867     JSObject* object = exec-&gt;argument(0).toObject(exec);</span>
868     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">869     RELEASE_AND_RETURN(scope, JSValue::encode(ownPropertyKeys(exec, object, PropertyNameMode::StringsAndSymbols, DontEnumPropertiesMode::Include)));</span>
870 }
871 
872 #if ENABLE(INTL)
<span class="line-modified">873 EncodedJSValue JSC_HOST_CALL globalFuncDateTimeFormat(ExecState* exec)</span>
874 {
<span class="line-modified">875     VM&amp; vm = exec-&gt;vm();</span>
876     auto scope = DECLARE_THROW_SCOPE(vm);
877 
<span class="line-removed">878     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
879     IntlDateTimeFormat* dateTimeFormat = IntlDateTimeFormat::create(vm, globalObject-&gt;dateTimeFormatStructure());
<span class="line-modified">880     dateTimeFormat-&gt;initializeDateTimeFormat(*exec, exec-&gt;argument(0), exec-&gt;argument(1));</span>
881     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">882     double value = exec-&gt;argument(2).toNumber(exec);</span>
883     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">884     RELEASE_AND_RETURN(scope, JSValue::encode(dateTimeFormat-&gt;format(*exec, value)));</span>
885 }
886 #endif
887 
888 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 22  *
 23  */
 24 
 25 #include &quot;config.h&quot;
 26 #include &quot;JSGlobalObjectFunctions.h&quot;
 27 
 28 #include &quot;CallFrame.h&quot;
 29 #include &quot;CatchScope.h&quot;
 30 #include &quot;EvalExecutable.h&quot;
 31 #include &quot;Exception.h&quot;
 32 #include &quot;IndirectEvalExecutable.h&quot;
 33 #include &quot;Interpreter.h&quot;
 34 #include &quot;IntlDateTimeFormat.h&quot;
 35 #include &quot;IntlObject.h&quot;
 36 #include &quot;JSCInlines.h&quot;
 37 #include &quot;JSFunction.h&quot;
 38 #include &quot;JSGlobalObject.h&quot;
 39 #include &quot;JSInternalPromise.h&quot;
 40 #include &quot;JSModuleLoader.h&quot;
 41 #include &quot;JSPromise.h&quot;

 42 #include &quot;JSString.h&quot;
 43 #include &quot;Lexer.h&quot;
 44 #include &quot;LiteralParser.h&quot;
 45 #include &quot;Nodes.h&quot;
 46 #include &quot;ObjectConstructor.h&quot;
 47 #include &quot;JSCInlines.h&quot;
 48 #include &quot;ParseInt.h&quot;
 49 #include &quot;Parser.h&quot;
 50 #include &quot;StackVisitor.h&quot;
 51 #include &lt;stdio.h&gt;
 52 #include &lt;stdlib.h&gt;
 53 #include &lt;unicode/utf8.h&gt;
 54 #include &lt;wtf/ASCIICType.h&gt;
 55 #include &lt;wtf/Assertions.h&gt;
 56 #include &lt;wtf/HexNumber.h&gt;
 57 #include &lt;wtf/MathExtras.h&gt;
 58 #include &lt;wtf/dtoa.h&gt;
 59 #include &lt;wtf/text/StringBuilder.h&gt;
 60 
 61 namespace JSC {
 62 
 63 const ASCIILiteral ObjectProtoCalledOnNullOrUndefinedError { &quot;Object.prototype.__proto__ called on null or undefined&quot;_s };
 64 
 65 template&lt;unsigned charactersCount&gt;
 66 static Bitmap&lt;256&gt; makeCharacterBitmap(const char (&amp;characters)[charactersCount])
 67 {
 68     static_assert(charactersCount &gt; 0, &quot;Since string literal is null terminated, characterCount is always larger than 0&quot;);
 69     Bitmap&lt;256&gt; bitmap;
 70     for (unsigned i = 0; i &lt; charactersCount - 1; ++i)
 71         bitmap.set(characters[i]);
 72     return bitmap;
 73 }
 74 
 75 template&lt;typename CharacterType&gt;
<span class="line-modified"> 76 static JSValue encode(JSGlobalObject* globalObject, const Bitmap&lt;256&gt;&amp; doNotEscape, const CharacterType* characters, unsigned length)</span>
 77 {
<span class="line-modified"> 78     VM&amp; vm = globalObject-&gt;vm();</span>
 79     auto scope = DECLARE_THROW_SCOPE(vm);
 80 
 81     // 18.2.6.1.1 Runtime Semantics: Encode ( string, unescapedSet )
 82     // https://tc39.github.io/ecma262/#sec-encode
 83 
<span class="line-modified"> 84     auto throwException = [&amp;scope, globalObject] {</span>
<span class="line-modified"> 85         return JSC::throwException(globalObject, scope, createURIError(globalObject, &quot;String contained an illegal UTF-16 sequence.&quot;_s));</span>
 86     };
 87 
 88     StringBuilder builder(StringBuilder::OverflowHandler::RecordOverflow);
 89     builder.reserveCapacity(length);
 90 
 91     // 4. Repeat
 92     auto* end = characters + length;
 93     for (auto* cursor = characters; cursor != end; ++cursor) {
 94         auto character = *cursor;
 95 
 96         // 4-c. If C is in unescapedSet, then
 97         if (character &lt; doNotEscape.size() &amp;&amp; doNotEscape.get(character)) {
 98             // 4-c-i. Let S be a String containing only the code unit C.
 99             // 4-c-ii. Let R be a new String value computed by concatenating the previous value of R and S.
100             builder.append(static_cast&lt;LChar&gt;(character));
101             continue;
102         }
103 
104         // 4-d-i. If the code unit value of C is not less than 0xDC00 and not greater than 0xDFFF, throw a URIError exception.
105         if (U16_IS_TRAIL(character))
</pre>
<hr />
<pre>
128 
129             // 4-d-iii-5. Let V be UTF16Decode(C, kChar).
130             codePoint = U16_GET_SUPPLEMENTARY(character, trail);
131         }
132 
133         // 4-d-iv. Let Octets be the array of octets resulting by applying the UTF-8 transformation to V, and let L be the array size.
134         LChar utf8OctetsBuffer[U8_MAX_LENGTH];
135         unsigned utf8Length = 0;
136         // We can use U8_APPEND_UNSAFE here since codePoint is either
137         // 1. non surrogate one, correct code point.
138         // 2. correct code point generated from validated lead and trail surrogates.
139         U8_APPEND_UNSAFE(utf8OctetsBuffer, utf8Length, codePoint);
140 
141         // 4-d-v. Let j be 0.
142         // 4-d-vi. Repeat, while j &lt; L
143         for (unsigned index = 0; index &lt; utf8Length; ++index) {
144             // 4-d-vi-1. Let jOctet be the value at index j within Octets.
145             // 4-d-vi-2. Let S be a String containing three code units &quot;%XY&quot; where XY are two uppercase hexadecimal digits encoding the value of jOctet.
146             // 4-d-vi-3. Let R be a new String value computed by concatenating the previous value of R and S.
147             builder.append(&#39;%&#39;);
<span class="line-modified">148             builder.append(hex(utf8OctetsBuffer[index], 2));</span>
149         }
150     }
151 
152     if (UNLIKELY(builder.hasOverflowed()))
<span class="line-modified">153         return throwOutOfMemoryError(globalObject, scope);</span>
154     return jsString(vm, builder.toString());
155 }
156 
<span class="line-modified">157 static JSValue encode(JSGlobalObject* globalObject, JSValue argument, const Bitmap&lt;256&gt;&amp; doNotEscape)</span>
158 {
<span class="line-modified">159     return toStringView(globalObject, argument, [&amp;] (StringView view) {</span>
160         if (view.is8Bit())
<span class="line-modified">161             return encode(globalObject, doNotEscape, view.characters8(), view.length());</span>
<span class="line-modified">162         return encode(globalObject, doNotEscape, view.characters16(), view.length());</span>
163     });
164 }
165 
166 template &lt;typename CharType&gt;
167 ALWAYS_INLINE
<span class="line-modified">168 static JSValue decode(JSGlobalObject* globalObject, const CharType* characters, int length, const Bitmap&lt;256&gt;&amp; doNotUnescape, bool strict)</span>
169 {
<span class="line-modified">170     VM&amp; vm = globalObject-&gt;vm();</span>
171     auto scope = DECLARE_THROW_SCOPE(vm);
172 
173     StringBuilder builder(StringBuilder::OverflowHandler::RecordOverflow);
174     int k = 0;
175     UChar u = 0;
176     while (k &lt; length) {
177         const CharType* p = characters + k;
178         CharType c = *p;
179         if (c == &#39;%&#39;) {
180             int charLen = 0;
181             if (k &lt;= length - 3 &amp;&amp; isASCIIHexDigit(p[1]) &amp;&amp; isASCIIHexDigit(p[2])) {
182                 const char b0 = Lexer&lt;CharType&gt;::convertHex(p[1], p[2]);
183                 const int sequenceLen = 1 + U8_COUNT_TRAIL_BYTES(b0);
184                 if (k &lt;= length - sequenceLen * 3) {
185                     charLen = sequenceLen * 3;
186 #if U_ICU_VERSION_MAJOR_NUM &gt;= 60
187                     uint8_t sequence[U8_MAX_LENGTH];
188 #else
189                     // In pre-60 ICU, U8_COUNT_TRAIL_BYTES returns 0..5
190                     uint8_t sequence[6];
</pre>
<hr />
<pre>
202                     if (charLen != 0) {
203                         UChar32 character;
204                         int32_t offset = 0;
205                         U8_NEXT(sequence, offset, sequenceLen, character);
206                         if (character &lt; 0)
207                             charLen = 0;
208                         else if (!U_IS_BMP(character)) {
209                             // Convert to surrogate pair.
210                             ASSERT(U_IS_SUPPLEMENTARY(character));
211                             builder.append(U16_LEAD(character));
212                             u = U16_TRAIL(character);
213                         } else {
214                             ASSERT(!U_IS_SURROGATE(character));
215                             u = static_cast&lt;UChar&gt;(character);
216                         }
217                     }
218                 }
219             }
220             if (charLen == 0) {
221                 if (strict)
<span class="line-modified">222                     return throwException(globalObject, scope, createURIError(globalObject, &quot;URI error&quot;_s));</span>
223                 // The only case where we don&#39;t use &quot;strict&quot; mode is the &quot;unescape&quot; function.
224                 // For that, it&#39;s good to support the wonky &quot;%u&quot; syntax for compatibility with WinIE.
225                 if (k &lt;= length - 6 &amp;&amp; p[1] == &#39;u&#39;
226                         &amp;&amp; isASCIIHexDigit(p[2]) &amp;&amp; isASCIIHexDigit(p[3])
227                         &amp;&amp; isASCIIHexDigit(p[4]) &amp;&amp; isASCIIHexDigit(p[5])) {
228                     charLen = 6;
229                     u = Lexer&lt;UChar&gt;::convertUnicode(p[2], p[3], p[4], p[5]);
230                 }
231             }
232             if (charLen &amp;&amp; (u &gt;= 128 || !doNotUnescape.get(static_cast&lt;LChar&gt;(u)))) {
233                 builder.append(u);
234                 k += charLen;
235                 continue;
236             }
237         }
238         k++;
239         builder.append(c);
240     }
241     if (UNLIKELY(builder.hasOverflowed()))
<span class="line-modified">242         return throwOutOfMemoryError(globalObject, scope);</span>
243     RELEASE_AND_RETURN(scope, jsString(vm, builder.toString()));
244 }
245 
<span class="line-modified">246 static JSValue decode(JSGlobalObject* globalObject, JSValue argument, const Bitmap&lt;256&gt;&amp; doNotUnescape, bool strict)</span>
247 {
<span class="line-modified">248     return toStringView(globalObject, argument, [&amp;] (StringView view) {</span>
249         if (view.is8Bit())
<span class="line-modified">250             return decode(globalObject, view.characters8(), view.length(), doNotUnescape, strict);</span>
<span class="line-modified">251         return decode(globalObject, view.characters16(), view.length(), doNotUnescape, strict);</span>
252     });
253 }
254 
255 static const int SizeOfInfinity = 8;
256 
257 template &lt;typename CharType&gt;
258 static bool isInfinity(const CharType* data, const CharType* end)
259 {
260     return (end - data) &gt;= SizeOfInfinity
261         &amp;&amp; data[0] == &#39;I&#39;
262         &amp;&amp; data[1] == &#39;n&#39;
263         &amp;&amp; data[2] == &#39;f&#39;
264         &amp;&amp; data[3] == &#39;i&#39;
265         &amp;&amp; data[4] == &#39;n&#39;
266         &amp;&amp; data[5] == &#39;i&#39;
267         &amp;&amp; data[6] == &#39;t&#39;
268         &amp;&amp; data[7] == &#39;y&#39;;
269 }
270 
271 // See ecma-262 6th 11.8.3
</pre>
<hr />
<pre>
460 
461         return jsStrDecimalLiteral(data, end);
462     }
463 
464     const UChar* data = s.characters16();
465     const UChar* end = data + size;
466 
467     // Skip leading white space.
468     for (; data &lt; end; ++data) {
469         if (!isStrWhiteSpace(*data))
470             break;
471     }
472 
473     // Empty string.
474     if (data == end)
475         return PNaN;
476 
477     return jsStrDecimalLiteral(data, end);
478 }
479 
<span class="line-modified">480 EncodedJSValue JSC_HOST_CALL globalFuncEval(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
481 {
<span class="line-modified">482     VM&amp; vm = globalObject-&gt;vm();</span>
483     auto scope = DECLARE_THROW_SCOPE(vm);
484 
<span class="line-modified">485     JSValue x = callFrame-&gt;argument(0);</span>
486     if (!x.isString())
487         return JSValue::encode(x);
488 

489     if (!globalObject-&gt;evalEnabled()) {
<span class="line-modified">490         throwException(globalObject, scope, createEvalError(globalObject, globalObject-&gt;evalDisabledErrorMessage()));</span>
491         return JSValue::encode(jsUndefined());
492     }
493 
<span class="line-modified">494     String s = asString(x)-&gt;value(globalObject);</span>
495     RETURN_IF_EXCEPTION(scope, encodedJSValue());
496 
497     JSValue parsedObject;
498     if (s.is8Bit()) {
<span class="line-modified">499         LiteralParser&lt;LChar&gt; preparser(globalObject, s.characters8(), s.length(), NonStrictJSON, nullptr);</span>
500         parsedObject = preparser.tryLiteralParse();
501     } else {
<span class="line-modified">502         LiteralParser&lt;UChar&gt; preparser(globalObject, s.characters16(), s.length(), NonStrictJSON, nullptr);</span>
503         parsedObject = preparser.tryLiteralParse();
504     }
505     RETURN_IF_EXCEPTION(scope, encodedJSValue());
506     if (parsedObject)
507         return JSValue::encode(parsedObject);
508 
<span class="line-modified">509     SourceOrigin sourceOrigin = callFrame-&gt;callerSourceOrigin(vm);</span>
<span class="line-modified">510     EvalExecutable* eval = IndirectEvalExecutable::create(globalObject, makeSource(s, sourceOrigin), false, DerivedContextType::None, false, EvalContextType::None);</span>

511     EXCEPTION_ASSERT(!!scope.exception() == !eval);
512     if (!eval)
513         return encodedJSValue();
514 
<span class="line-modified">515     RELEASE_AND_RETURN(scope, JSValue::encode(vm.interpreter-&gt;execute(eval, globalObject, globalObject-&gt;globalThis(), globalObject-&gt;globalScope())));</span>
516 }
517 
<span class="line-modified">518 EncodedJSValue JSC_HOST_CALL globalFuncParseInt(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
519 {
<span class="line-modified">520     JSValue value = callFrame-&gt;argument(0);</span>
<span class="line-modified">521     JSValue radixValue = callFrame-&gt;argument(1);</span>
522 
523     // Optimized handling for numbers:
524     // If the argument is 0 or a number in range 10^-6 &lt;= n &lt; INT_MAX+1, then parseInt
525     // results in a truncation to integer. In the case of -0, this is converted to 0.
526     //
527     // This is also a truncation for values in the range INT_MAX+1 &lt;= n &lt; 10^21,
528     // however these values cannot be trivially truncated to int since 10^21 exceeds
529     // even the int64_t range. Negative numbers are a little trickier, the case for
530     // values in the range -10^21 &lt; n &lt;= -1 are similar to those for integer, but
531     // values in the range -1 &lt; n &lt;= -10^-6 need to truncate to -0, not 0.
532     static const double tenToTheMinus6 = 0.000001;
533     static const double intMaxPlusOne = 2147483648.0;
534     if (value.isNumber()) {
535         double n = value.asNumber();
536         if (((n &lt; intMaxPlusOne &amp;&amp; n &gt;= tenToTheMinus6) || !n) &amp;&amp; radixValue.isUndefinedOrNull())
537             return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(n)));
538     }
539 
540     // If ToString throws, we shouldn&#39;t call ToInt32.
<span class="line-modified">541     return toStringView(globalObject, value, [&amp;] (StringView view) {</span>
<span class="line-modified">542         return JSValue::encode(jsNumber(parseInt(view, radixValue.toInt32(globalObject))));</span>
543     });
544 }
545 
<span class="line-modified">546 EncodedJSValue JSC_HOST_CALL globalFuncParseFloat(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
547 {
<span class="line-modified">548     auto viewWithString = callFrame-&gt;argument(0).toString(globalObject)-&gt;viewWithUnderlyingString(globalObject);</span>
549     return JSValue::encode(jsNumber(parseFloat(viewWithString.view)));
550 }
551 
<span class="line-modified">552 EncodedJSValue JSC_HOST_CALL globalFuncDecodeURI(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
553 {
554     static Bitmap&lt;256&gt; doNotUnescapeWhenDecodingURI = makeCharacterBitmap(
555         &quot;#$&amp;+,/:;=?@&quot;
556     );
557 
<span class="line-modified">558     return JSValue::encode(decode(globalObject, callFrame-&gt;argument(0), doNotUnescapeWhenDecodingURI, true));</span>
559 }
560 
<span class="line-modified">561 EncodedJSValue JSC_HOST_CALL globalFuncDecodeURIComponent(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
562 {
563     static Bitmap&lt;256&gt; emptyBitmap;
<span class="line-modified">564     return JSValue::encode(decode(globalObject, callFrame-&gt;argument(0), emptyBitmap, true));</span>
565 }
566 
<span class="line-modified">567 EncodedJSValue JSC_HOST_CALL globalFuncEncodeURI(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
568 {
569     static Bitmap&lt;256&gt; doNotEscapeWhenEncodingURI = makeCharacterBitmap(
570         &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
571         &quot;abcdefghijklmnopqrstuvwxyz&quot;
572         &quot;0123456789&quot;
573         &quot;!#$&amp;&#39;()*+,-./:;=?@_~&quot;
574     );
575 
<span class="line-modified">576     return JSValue::encode(encode(globalObject, callFrame-&gt;argument(0), doNotEscapeWhenEncodingURI));</span>
577 }
578 
<span class="line-modified">579 EncodedJSValue JSC_HOST_CALL globalFuncEncodeURIComponent(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
580 {
581     static Bitmap&lt;256&gt; doNotEscapeWhenEncodingURIComponent = makeCharacterBitmap(
582         &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
583         &quot;abcdefghijklmnopqrstuvwxyz&quot;
584         &quot;0123456789&quot;
585         &quot;!&#39;()*-._~&quot;
586     );
587 
<span class="line-modified">588     return JSValue::encode(encode(globalObject, callFrame-&gt;argument(0), doNotEscapeWhenEncodingURIComponent));</span>
589 }
590 
<span class="line-modified">591 EncodedJSValue JSC_HOST_CALL globalFuncEscape(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
592 {
593     static Bitmap&lt;256&gt; doNotEscape = makeCharacterBitmap(
594         &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
595         &quot;abcdefghijklmnopqrstuvwxyz&quot;
596         &quot;0123456789&quot;
597         &quot;*+-./@_&quot;
598     );
599 
<span class="line-modified">600     return JSValue::encode(toStringView(globalObject, callFrame-&gt;argument(0), [&amp;] (StringView view) {</span>
<span class="line-modified">601         VM&amp; vm = globalObject-&gt;vm();</span>
602         StringBuilder builder;
603         if (view.is8Bit()) {
604             const LChar* c = view.characters8();
605             for (unsigned k = 0; k &lt; view.length(); k++, c++) {
606                 int u = c[0];
607                 if (doNotEscape.get(static_cast&lt;LChar&gt;(u)))
608                     builder.append(*c);
609                 else {
610                     builder.append(&#39;%&#39;);
<span class="line-modified">611                     builder.append(hex(u, 2));</span>
612                 }
613             }
614             return jsString(vm, builder.toString());
615         }
616 
617         const UChar* c = view.characters16();
618         for (unsigned k = 0; k &lt; view.length(); k++, c++) {
619             UChar u = c[0];
620             if (u &gt;= doNotEscape.size()) {
621                 builder.appendLiteral(&quot;%u&quot;);
<span class="line-modified">622                 builder.append(hex(static_cast&lt;unsigned char&gt;(u &gt;&gt; 8), 2));</span>
<span class="line-modified">623                 builder.append(hex(static_cast&lt;unsigned char&gt;(u &amp; 0xFF), 2));</span>
624             } else if (doNotEscape.get(static_cast&lt;LChar&gt;(u)))
625                 builder.append(*c);
626             else {
627                 builder.append(&#39;%&#39;);
<span class="line-modified">628                 builder.append(hex(static_cast&lt;unsigned char&gt;(u), 2));</span>
629             }
630         }
631 
632         return jsString(vm, builder.toString());
633     }));
634 }
635 
<span class="line-modified">636 EncodedJSValue JSC_HOST_CALL globalFuncUnescape(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
637 {
<span class="line-modified">638     return JSValue::encode(toStringView(globalObject, callFrame-&gt;argument(0), [&amp;] (StringView view) {</span>
639         // We use int for k and length intentionally since we would like to evaluate
640         // the condition `k &lt;= length -6` even if length is less than 6.
641         int k = 0;
642         int length = view.length();
643 
644         StringBuilder builder;
645         builder.reserveCapacity(length);
646 
647         if (view.is8Bit()) {
648             const LChar* characters = view.characters8();
649             LChar convertedLChar;
650             while (k &lt; length) {
651                 const LChar* c = characters + k;
652                 if (c[0] == &#39;%&#39; &amp;&amp; k &lt;= length - 6 &amp;&amp; c[1] == &#39;u&#39;) {
653                     if (isASCIIHexDigit(c[2]) &amp;&amp; isASCIIHexDigit(c[3]) &amp;&amp; isASCIIHexDigit(c[4]) &amp;&amp; isASCIIHexDigit(c[5])) {
654                         builder.append(Lexer&lt;UChar&gt;::convertUnicode(c[2], c[3], c[4], c[5]));
655                         k += 6;
656                         continue;
657                     }
658                 } else if (c[0] == &#39;%&#39; &amp;&amp; k &lt;= length - 3 &amp;&amp; isASCIIHexDigit(c[1]) &amp;&amp; isASCIIHexDigit(c[2])) {
</pre>
<hr />
<pre>
668 
669             while (k &lt; length) {
670                 const UChar* c = characters + k;
671                 UChar convertedUChar;
672                 if (c[0] == &#39;%&#39; &amp;&amp; k &lt;= length - 6 &amp;&amp; c[1] == &#39;u&#39;) {
673                     if (isASCIIHexDigit(c[2]) &amp;&amp; isASCIIHexDigit(c[3]) &amp;&amp; isASCIIHexDigit(c[4]) &amp;&amp; isASCIIHexDigit(c[5])) {
674                         convertedUChar = Lexer&lt;UChar&gt;::convertUnicode(c[2], c[3], c[4], c[5]);
675                         c = &amp;convertedUChar;
676                         k += 5;
677                     }
678                 } else if (c[0] == &#39;%&#39; &amp;&amp; k &lt;= length - 3 &amp;&amp; isASCIIHexDigit(c[1]) &amp;&amp; isASCIIHexDigit(c[2])) {
679                     convertedUChar = UChar(Lexer&lt;UChar&gt;::convertHex(c[1], c[2]));
680                     c = &amp;convertedUChar;
681                     k += 2;
682                 }
683                 k++;
684                 builder.append(*c);
685             }
686         }
687 
<span class="line-modified">688         return jsString(globalObject-&gt;vm(), builder.toString());</span>
689     }));
690 }
691 
<span class="line-modified">692 EncodedJSValue JSC_HOST_CALL globalFuncThrowTypeError(JSGlobalObject* globalObject, CallFrame*)</span>
693 {
<span class="line-modified">694     VM&amp; vm = globalObject-&gt;vm();</span>
695     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">696     return throwVMTypeError(globalObject, scope);</span>
697 }
698 
<span class="line-modified">699 EncodedJSValue JSC_HOST_CALL globalFuncThrowTypeErrorArgumentsCalleeAndCaller(JSGlobalObject* globalObject, CallFrame*)</span>
700 {
<span class="line-modified">701     VM&amp; vm = globalObject-&gt;vm();</span>
702     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">703     return throwVMTypeError(globalObject, scope, &quot;&#39;arguments&#39;, &#39;callee&#39;, and &#39;caller&#39; cannot be accessed in this context.&quot;);</span>
704 }
705 
<span class="line-modified">706 EncodedJSValue JSC_HOST_CALL globalFuncMakeTypeError(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
707 {

708     Structure* errorStructure = globalObject-&gt;errorStructure(ErrorType::TypeError);
<span class="line-modified">709     return JSValue::encode(ErrorInstance::create(globalObject, errorStructure, callFrame-&gt;argument(0), nullptr, TypeNothing, false));</span>
710 }
711 
<span class="line-modified">712 EncodedJSValue JSC_HOST_CALL globalFuncProtoGetter(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
713 {
<span class="line-modified">714     VM&amp; vm = globalObject-&gt;vm();</span>
715     auto scope = DECLARE_THROW_SCOPE(vm);
716 
<span class="line-modified">717     JSValue thisValue = callFrame-&gt;thisValue().toThis(globalObject, StrictMode);</span>
718     if (thisValue.isUndefinedOrNull())
<span class="line-modified">719         return throwVMError(globalObject, scope, createNotAnObjectError(globalObject, thisValue));</span>
720 
721     JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, thisValue);
722     if (!thisObject) {
<span class="line-modified">723         JSObject* prototype = thisValue.synthesizePrototype(globalObject);</span>
724         EXCEPTION_ASSERT(!!scope.exception() == !prototype);
725         if (UNLIKELY(!prototype))
726             return JSValue::encode(JSValue());
727         return JSValue::encode(prototype);
728     }
729 
<span class="line-modified">730     RELEASE_AND_RETURN(scope, JSValue::encode(thisObject-&gt;getPrototype(vm, globalObject)));</span>
731 }
732 
<span class="line-modified">733 EncodedJSValue JSC_HOST_CALL globalFuncProtoSetter(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
734 {
<span class="line-modified">735     VM&amp; vm = globalObject-&gt;vm();</span>
736     auto scope = DECLARE_THROW_SCOPE(vm);
737 
<span class="line-modified">738     JSValue thisValue = callFrame-&gt;thisValue().toThis(globalObject, StrictMode);</span>
739     if (thisValue.isUndefinedOrNull())
<span class="line-modified">740         return throwVMTypeError(globalObject, scope, ObjectProtoCalledOnNullOrUndefinedError);</span>
741 
<span class="line-modified">742     JSValue value = callFrame-&gt;argument(0);</span>
743 
744     JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, thisValue);
745 
746     // Setting __proto__ of a primitive should have no effect.
747     if (!thisObject)
748         return JSValue::encode(jsUndefined());
749 
750     // Setting __proto__ to a non-object, non-null value is silently ignored to match Mozilla.
751     if (!value.isObject() &amp;&amp; !value.isNull())
752         return JSValue::encode(jsUndefined());
753 
754     scope.release();
755     bool shouldThrowIfCantSet = true;
<span class="line-modified">756     thisObject-&gt;setPrototype(vm, globalObject, value, shouldThrowIfCantSet);</span>
757     return JSValue::encode(jsUndefined());
758 }
759 
<span class="line-modified">760 EncodedJSValue JSC_HOST_CALL globalFuncHostPromiseRejectionTracker(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
761 {

762     VM&amp; vm = globalObject-&gt;vm();
763     auto scope = DECLARE_THROW_SCOPE(vm);
764 
<span class="line-modified">765     JSPromise* promise = jsCast&lt;JSPromise*&gt;(callFrame-&gt;argument(0));</span>
766 
767     // InternalPromises should not be exposed to user scripts.
768     if (jsDynamicCast&lt;JSInternalPromise*&gt;(vm, promise))
769         return JSValue::encode(jsUndefined());
770 
<span class="line-modified">771     JSValue operationValue = callFrame-&gt;argument(1);</span>
772 
773     ASSERT(operationValue.isNumber());
<span class="line-modified">774     auto operation = static_cast&lt;JSPromiseRejectionOperation&gt;(operationValue.toUInt32(globalObject));</span>
775     ASSERT(operation == JSPromiseRejectionOperation::Reject || operation == JSPromiseRejectionOperation::Handle);
776     scope.assertNoException();
777 
778     if (globalObject-&gt;globalObjectMethodTable()-&gt;promiseRejectionTracker)
<span class="line-modified">779         globalObject-&gt;globalObjectMethodTable()-&gt;promiseRejectionTracker(globalObject, promise, operation);</span>
780     else {
781         switch (operation) {
782         case JSPromiseRejectionOperation::Reject:
783             vm.promiseRejected(promise);
784             break;
785         case JSPromiseRejectionOperation::Handle:
786             // do nothing
787             break;
788         }
789     }
790     RETURN_IF_EXCEPTION(scope, { });
791 
792     return JSValue::encode(jsUndefined());
793 }
794 
<span class="line-modified">795 EncodedJSValue JSC_HOST_CALL globalFuncBuiltinLog(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
796 {
<span class="line-modified">797     dataLog(callFrame-&gt;argument(0).toWTFString(globalObject), &quot;\n&quot;);</span>
798     return JSValue::encode(jsUndefined());
799 }
800 
<span class="line-modified">801 EncodedJSValue JSC_HOST_CALL globalFuncBuiltinDescribe(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
802 {
<span class="line-modified">803     return JSValue::encode(jsString(globalObject-&gt;vm(), toString(callFrame-&gt;argument(0))));</span>
804 }
805 
<span class="line-modified">806 EncodedJSValue JSC_HOST_CALL globalFuncImportModule(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
807 {
<span class="line-modified">808     VM&amp; vm = globalObject-&gt;vm();</span>



809 
<span class="line-modified">810     auto* promise = JSPromise::create(vm, globalObject-&gt;promiseStructure());</span>

811 
812     auto catchScope = DECLARE_CATCH_SCOPE(vm);
813     auto reject = [&amp;] (JSValue rejectionReason) {
814         catchScope.clearException();
<span class="line-modified">815         promise-&gt;reject(globalObject, rejectionReason);</span>
816         catchScope.clearException();
<span class="line-modified">817         return JSValue::encode(promise);</span>
818     };
819 
<span class="line-modified">820     auto sourceOrigin = callFrame-&gt;callerSourceOrigin(vm);</span>
<span class="line-modified">821     RELEASE_ASSERT(callFrame-&gt;argumentCount() == 1);</span>
<span class="line-modified">822     auto* specifier = callFrame-&gt;uncheckedArgument(0).toString(globalObject);</span>
823     if (Exception* exception = catchScope.exception())
824         return reject(exception-&gt;value());
825 
826     // We always specify parameters as undefined. Once dynamic import() starts accepting fetching parameters,
827     // we should retrieve this from the arguments.
828     JSValue parameters = jsUndefined();
<span class="line-modified">829     auto* internalPromise = globalObject-&gt;moduleLoader()-&gt;importModule(globalObject, specifier, parameters, sourceOrigin);</span>
830     if (Exception* exception = catchScope.exception())
831         return reject(exception-&gt;value());
<span class="line-modified">832     promise-&gt;resolve(globalObject, internalPromise);</span>
833 
834     catchScope.clearException();
<span class="line-modified">835     return JSValue::encode(promise);</span>
836 }
837 
<span class="line-modified">838 EncodedJSValue JSC_HOST_CALL globalFuncPropertyIsEnumerable(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
839 {
<span class="line-modified">840     VM&amp; vm = globalObject-&gt;vm();</span>
841     auto scope = DECLARE_THROW_SCOPE(vm);
842 
<span class="line-modified">843     RELEASE_ASSERT(callFrame-&gt;argumentCount() == 2);</span>
<span class="line-modified">844     JSObject* object = jsCast&lt;JSObject*&gt;(callFrame-&gt;uncheckedArgument(0));</span>
<span class="line-modified">845     auto propertyName = callFrame-&gt;uncheckedArgument(1).toPropertyKey(globalObject);</span>
846     RETURN_IF_EXCEPTION(scope, encodedJSValue());
847 
848     scope.release();
849     PropertyDescriptor descriptor;
<span class="line-modified">850     bool enumerable = object-&gt;getOwnPropertyDescriptor(globalObject, propertyName, descriptor) &amp;&amp; descriptor.enumerable();</span>
851     return JSValue::encode(jsBoolean(enumerable));
852 }
853 
<span class="line-modified">854 EncodedJSValue JSC_HOST_CALL globalFuncOwnKeys(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
855 {
<span class="line-modified">856     VM&amp; vm = globalObject-&gt;vm();</span>
857     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">858     JSObject* object = callFrame-&gt;argument(0).toObject(globalObject);</span>
859     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">860     RELEASE_AND_RETURN(scope, JSValue::encode(ownPropertyKeys(globalObject, object, PropertyNameMode::StringsAndSymbols, DontEnumPropertiesMode::Include)));</span>
861 }
862 
863 #if ENABLE(INTL)
<span class="line-modified">864 EncodedJSValue JSC_HOST_CALL globalFuncDateTimeFormat(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
865 {
<span class="line-modified">866     VM&amp; vm = globalObject-&gt;vm();</span>
867     auto scope = DECLARE_THROW_SCOPE(vm);
868 

869     IntlDateTimeFormat* dateTimeFormat = IntlDateTimeFormat::create(vm, globalObject-&gt;dateTimeFormatStructure());
<span class="line-modified">870     dateTimeFormat-&gt;initializeDateTimeFormat(globalObject, callFrame-&gt;argument(0), callFrame-&gt;argument(1));</span>
871     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">872     double value = callFrame-&gt;argument(2).toNumber(globalObject);</span>
873     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">874     RELEASE_AND_RETURN(scope, JSValue::encode(dateTimeFormat-&gt;format(globalObject, value)));</span>
875 }
876 #endif
877 
878 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="JSGlobalObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSGlobalObjectFunctions.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
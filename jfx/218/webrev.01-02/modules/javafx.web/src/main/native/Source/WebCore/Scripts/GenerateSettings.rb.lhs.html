<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Scripts/GenerateSettings.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 #!/usr/bin/env ruby
  2 #
  3 # Copyright (c) 2017 Apple Inc. All rights reserved.
  4 #
  5 # Redistribution and use in source and binary forms, with or without
  6 # modification, are permitted provided that the following conditions
  7 # are met:
  8 # 1. Redistributions of source code must retain the above copyright
  9 #    notice, this list of conditions and the following disclaimer.
 10 # 2. Redistributions in binary form must reproduce the above copyright
 11 #    notice, this list of conditions and the following disclaimer in the
 12 #    documentation and/or other materials provided with the distribution.
 13 #
 14 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 15 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 16 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 18 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 19 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 20 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 21 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 22 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 23 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 24 # THE POSSIBILITY OF SUCH DAMAGE.
 25 
 26 require &quot;fileutils&quot;
 27 require &#39;erb&#39;
 28 require &#39;optparse&#39;
 29 require &#39;yaml&#39;
 30 
 31 options = { 
 32   :input =&gt; nil,
 33   :outputDirectory =&gt; nil
 34 }
 35 optparse = OptionParser.new do |opts|
 36     opts.banner = &quot;Usage: #{File.basename($0)} --input file&quot;
 37 
 38     opts.separator &quot;&quot;
 39 
 40     opts.on(&quot;--input input&quot;, &quot;file to generate settings from&quot;) { |input| options[:input] = input }
 41     opts.on(&quot;--outputDir output&quot;, &quot;directory to generate file in&quot;) { |output| options[:outputDirectory] = output }
 42 end
 43 
 44 optparse.parse!
 45 
 46 if !options[:input]
 47   puts optparse
 48   exit -1
 49 end
 50 
 51 if !options[:outputDirectory]
 52   options[:outputDirectory] = Dir.getwd
 53 end
 54 
 55 FileUtils.mkdir_p(options[:outputDirectory])
 56 
 57 parsedSettings = begin
 58   YAML.load_file(options[:input])
 59 rescue ArgumentError =&gt; e
 60   puts &quot;Could not parse input file: #{e.message}&quot;
 61   exit(-1)
 62 end
 63 
 64 class Setting
 65   attr_accessor :name
 66   attr_accessor :type
 67   attr_accessor :initial
 68   attr_accessor :conditional
 69   attr_accessor :onChange
 70   attr_accessor :getter
 71   attr_accessor :inspectorOverride
 72   
 73   def initialize(name, opts)
 74     @name = name
 75     @type = opts[&quot;type&quot;] || &quot;bool&quot;
 76     @initial = opts[&quot;initial&quot;]
 77     @conditional = opts[&quot;conditional&quot;]
 78     @onChange = opts[&quot;onChange&quot;]
 79     @getter = opts[&quot;getter&quot;]
 80     @inspectorOverride = opts[&quot;inspectorOverride&quot;]
 81   end
 82 
 83   def valueType?
 84     @type != &quot;String&quot; &amp;&amp; @type != &quot;URL&quot;
 85   end
 86 
 87   def idlType
 88     # FIXME: Add support for more types including enumerate types.
 89     if @type == &quot;int&quot;
 90       &quot;long&quot;
 91     elsif @type == &quot;unsigned&quot;
 92       &quot;unsigned long&quot;
 93     elsif @type == &quot;double&quot;
 94       &quot;double&quot;
 95     elsif @type == &quot;float&quot;
 96       &quot;float&quot;
 97     elsif @type == &quot;String&quot;
 98       &quot;DOMString&quot;
 99     elsif @type == &quot;bool&quot;
100       &quot;boolean&quot;
101     else
102       nil
103     end
104   end
105 
106   def parameterType
107     if valueType?
108       @type
109     else
110       &quot;const #{@type}&amp;&quot;
111     end
112   end
113 
114   def hasComplexSetter?
115     @onChange != nil
116   end
117 
118   def hasComplexGetter?
119     hasInspectorOverride?
120   end
121 
122   def setterFunctionName
<a name="1" id="anc1"></a><span class="line-modified">123     if @name.start_with?(&quot;css&quot;, &quot;xss&quot;, &quot;ftp&quot;, &quot;dom&quot;, &quot;dns&quot;, &quot;ice&quot;)</span>
124       &quot;set&quot; + @name[0..2].upcase + @name[3..@name.length]
125     else
126       &quot;set&quot; + @name[0].upcase + @name[1..@name.length]
127     end
128   end
129 
130   def getterFunctionName
131     @getter || @name
132   end
133 
134   def hasInspectorOverride?
135     @inspectorOverride == true
136   end
137 end
138 
139 class Conditional
140   attr_accessor :condition
141   attr_accessor :settings
142   attr_accessor :boolSettings
143   attr_accessor :nonBoolSettings
144   attr_accessor :settingsWithComplexGetters
145   attr_accessor :settingsWithComplexSetters
146 
147   def initialize(condition, settings)
148     @condition = condition
149     @settings = settings
150     
151     @boolSettings = @settings.select { |setting| setting.type == &quot;bool&quot; }
152     @nonBoolSettings = @settings.reject { |setting| setting.type == &quot;bool&quot; }
153     @settingsWithComplexGetters = @settings.select { |setting| setting.hasComplexGetter? }
154     @settingsWithComplexSetters = @settings.select { |setting| setting.hasComplexSetter? }
155   end
156 end
157 
158 class Settings
159   attr_accessor :settings
160   attr_accessor :unconditionalSetting
161   attr_accessor :unconditionalBoolSetting
162   attr_accessor :unconditionalNonBoolSetting
163   attr_accessor :unconditionalSettingWithComplexGetters
164   attr_accessor :unconditionalSettingWithComplexSetters
165   attr_accessor :conditionals
166   
167   def initialize(hash)
168     @settings = []
169     hash.each do |name, options|
170       @settings &lt;&lt; Setting.new(name, options)
171     end
172     @settings.sort! { |x, y| x.name &lt;=&gt; y.name }
173     
174     @unconditionalSetting = @settings.reject { |setting| setting.conditional }
175     @unconditionalBoolSetting = @unconditionalSetting.select { |setting| setting.type == &quot;bool&quot; }
176     @unconditionalNonBoolSetting = @unconditionalSetting.reject { |setting| setting.type == &quot;bool&quot; }
177     @unconditionalSettingWithComplexGetters = @unconditionalSetting.select { |setting| setting.hasComplexGetter? }
178     @unconditionalSettingWithComplexSetters = @unconditionalSetting.select { |setting| setting.hasComplexSetter? }
179     @inspectorOverrideSettings = @settings.select { |setting| setting.hasInspectorOverride? }
180 
181     @conditionals = []
182     conditionalsMap = {}
183     @settings.select { |setting| setting.conditional }.each do |setting|
184       if !conditionalsMap[setting.conditional]
185         conditionalsMap[setting.conditional] = []
186       end
187 
188       conditionalsMap[setting.conditional] &lt;&lt; setting
189     end
190     conditionalsMap.each do |key, value|
191       @conditionals &lt;&lt; Conditional.new(key, value)
192     end
193     @conditionals.sort! { |x, y| x.condition &lt;=&gt; y.condition }
194   end
195 
196   def renderToFile(template, file)
197     template = File.join(File.dirname(__FILE__), template)
198 
199     output = ERB.new(File.read(template), 0, &quot;-&quot;).result(binding)
200     File.open(file, &quot;w+&quot;) do |f|
201       f.write(output)
202     end
203   end
204 end
205 
206 settings = Settings.new(parsedSettings)
207 settings.renderToFile(&quot;SettingsTemplates/Settings.h.erb&quot;, File.join(options[:outputDirectory], &quot;Settings.h&quot;))
208 settings.renderToFile(&quot;SettingsTemplates/Settings.cpp.erb&quot;, File.join(options[:outputDirectory], &quot;Settings.cpp&quot;))
209 settings.renderToFile(&quot;SettingsTemplates/InternalSettingsGenerated.idl.erb&quot;, File.join(options[:outputDirectory], &quot;InternalSettingsGenerated.idl&quot;))
210 settings.renderToFile(&quot;SettingsTemplates/InternalSettingsGenerated.h.erb&quot;, File.join(options[:outputDirectory], &quot;InternalSettingsGenerated.h&quot;))
211 settings.renderToFile(&quot;SettingsTemplates/InternalSettingsGenerated.cpp.erb&quot;, File.join(options[:outputDirectory], &quot;InternalSettingsGenerated.cpp&quot;))
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
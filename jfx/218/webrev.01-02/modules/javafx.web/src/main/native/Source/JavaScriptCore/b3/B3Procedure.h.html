<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3Procedure.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(B3_JIT)
 29 
 30 #include &quot;B3OpaqueByproducts.h&quot;
 31 #include &quot;B3Origin.h&quot;
 32 #include &quot;B3PCToOriginMap.h&quot;
 33 #include &quot;B3SparseCollection.h&quot;
 34 #include &quot;B3Type.h&quot;
 35 #include &quot;B3ValueKey.h&quot;
 36 #include &quot;PureNaN.h&quot;
 37 #include &quot;RegisterAtOffsetList.h&quot;
 38 #include &lt;wtf/Bag.h&gt;
 39 #include &lt;wtf/FastMalloc.h&gt;
 40 #include &lt;wtf/HashSet.h&gt;
 41 #include &lt;wtf/IndexedContainerIterator.h&gt;
 42 #include &lt;wtf/Noncopyable.h&gt;
 43 #include &lt;wtf/PrintStream.h&gt;
 44 #include &lt;wtf/SharedTask.h&gt;
 45 #include &lt;wtf/TriState.h&gt;
 46 #include &lt;wtf/Vector.h&gt;
 47 
 48 namespace JSC {
 49 
 50 class CCallHelpers;
 51 
 52 namespace B3 {
 53 
 54 class BackwardsCFG;
 55 class BackwardsDominators;
 56 class BasicBlock;
 57 class BlockInsertionSet;
 58 class CFG;
 59 class Dominators;
 60 class NaturalLoops;
 61 class StackSlot;
 62 class Value;
 63 class Variable;
 64 
 65 namespace Air { class Code; }
 66 
 67 typedef void WasmBoundsCheckGeneratorFunction(CCallHelpers&amp;, GPRReg);
 68 typedef SharedTask&lt;WasmBoundsCheckGeneratorFunction&gt; WasmBoundsCheckGenerator;
 69 
 70 // This represents B3&#39;s view of a piece of code. Note that this object must exist in a 1:1
 71 // relationship with Air::Code. B3::Procedure and Air::Code are just different facades of the B3
 72 // compiler&#39;s knowledge about a piece of code. Some kinds of state aren&#39;t perfect fits for either
 73 // Procedure or Code, and are placed in one or the other based on convenience. Procedure always
 74 // allocates a Code, and a Code cannot be allocated without an owning Procedure and they always
 75 // have references to each other.
 76 
 77 class Procedure {
 78     WTF_MAKE_NONCOPYABLE(Procedure);
 79     WTF_MAKE_FAST_ALLOCATED;
 80 public:
 81 
 82     JS_EXPORT_PRIVATE Procedure();
 83     JS_EXPORT_PRIVATE ~Procedure();
 84 
 85     template&lt;typename Callback&gt;
 86     void setOriginPrinter(Callback&amp;&amp; callback)
 87     {
 88         m_originPrinter = createSharedTask&lt;void(PrintStream&amp;, Origin)&gt;(
 89             std::forward&lt;Callback&gt;(callback));
 90     }
 91 
 92     // Usually you use this via OriginDump, though it&#39;s cool to use it directly.
 93     void printOrigin(PrintStream&amp; out, Origin origin) const;
 94 
 95     // This is a debugging hack. Sometimes while debugging B3 you need to break the abstraction
 96     // and get at the DFG Graph, or whatever data structure the frontend used to describe the
 97     // program. The FTL passes the DFG Graph.
 98     void setFrontendData(const void* value) { m_frontendData = value; }
 99     const void* frontendData() const { return m_frontendData; }
100 
101     JS_EXPORT_PRIVATE BasicBlock* addBlock(double frequency = 1);
102 
103     // Changes the order of basic blocks to be as in the supplied vector. The vector does not
104     // need to mention every block in the procedure. Blocks not mentioned will be placed after
105     // these blocks in the same order as they were in originally.
106     template&lt;typename BlockIterable&gt;
107     void setBlockOrder(const BlockIterable&amp; iterable)
108     {
109         Vector&lt;BasicBlock*&gt; blocks;
110         for (BasicBlock* block : iterable)
111             blocks.append(block);
112         setBlockOrderImpl(blocks);
113     }
114 
115     JS_EXPORT_PRIVATE StackSlot* addStackSlot(unsigned byteSize);
116     JS_EXPORT_PRIVATE Variable* addVariable(Type);
117 
118     JS_EXPORT_PRIVATE Type addTuple(Vector&lt;Type&gt;&amp;&amp; types);
119     const Vector&lt;Vector&lt;Type&gt;&gt;&amp; tuples() const { return m_tuples; };
120     bool isValidTuple(Type tuple) const;
121     Type extractFromTuple(Type tuple, unsigned index) const;
122     const Vector&lt;Type&gt;&amp; tupleForType(Type tuple) const;
123 
124     unsigned resultCount(Type type) const { return type.isTuple() ? tupleForType(type).size() : type.isNumeric(); }
125     Type typeAtOffset(Type type, unsigned index) const { ASSERT(index &lt; resultCount(type)); return type.isTuple() ? extractFromTuple(type, index) : type; }
126 
127     template&lt;typename ValueType, typename... Arguments&gt;
128     ValueType* add(Arguments...);
129 
130     Value* clone(Value*);
131 
132     Value* addIntConstant(Origin, Type, int64_t value);
133     Value* addIntConstant(Value*, int64_t value);
134 
135     // bits is a bitwise_cast of the constant you want.
136     Value* addConstant(Origin, Type, uint64_t bits);
137 
138     // You&#39;re guaranteed that bottom is zero.
139     Value* addBottom(Origin, Type);
140     Value* addBottom(Value*);
141 
142     // Returns null for MixedTriState.
143     Value* addBoolConstant(Origin, TriState);
144 
145     void resetValueOwners();
146     JS_EXPORT_PRIVATE void resetReachability();
147 
148     // This destroys CFG analyses. If we ask for them again, we will recompute them. Usually you
149     // should call this anytime you call resetReachability().
150     void invalidateCFG();
151 
152     JS_EXPORT_PRIVATE void dump(PrintStream&amp;) const;
153 
154     unsigned size() const { return m_blocks.size(); }
155     BasicBlock* at(unsigned index) const { return m_blocks[index].get(); }
156     BasicBlock* operator[](unsigned index) const { return at(index); }
157 
158     typedef WTF::IndexedContainerIterator&lt;Procedure&gt; iterator;
159 
160     iterator begin() const { return iterator(*this, 0); }
161     iterator end() const { return iterator(*this, size()); }
162 
163     Vector&lt;BasicBlock*&gt; blocksInPreOrder();
164     Vector&lt;BasicBlock*&gt; blocksInPostOrder();
165 
166     SparseCollection&lt;StackSlot&gt;&amp; stackSlots() { return m_stackSlots; }
167     const SparseCollection&lt;StackSlot&gt;&amp; stackSlots() const { return m_stackSlots; }
168 
169     // Short for stackSlots().remove(). It&#39;s better to call this method since it&#39;s out of line.
170     void deleteStackSlot(StackSlot*);
171 
172     SparseCollection&lt;Variable&gt;&amp; variables() { return m_variables; }
173     const SparseCollection&lt;Variable&gt;&amp; variables() const { return m_variables; }
174 
175     // Short for variables().remove(). It&#39;s better to call this method since it&#39;s out of line.
176     void deleteVariable(Variable*);
177 
178     SparseCollection&lt;Value&gt;&amp; values() { return m_values; }
179     const SparseCollection&lt;Value&gt;&amp; values() const { return m_values; }
180 
181     // Short for values().remove(). It&#39;s better to call this method since it&#39;s out of line.
182     void deleteValue(Value*);
183 
184     // A valid procedure cannot contain any orphan values. An orphan is a value that is not in
185     // any basic block. It is possible to create an orphan value during code generation or during
186     // transformation. If you know that you may have created some, you can call this method to
187     // delete them, making the procedure valid again.
188     void deleteOrphans();
189 
190     CFG&amp; cfg() const { return *m_cfg; }
191 
192     Dominators&amp; dominators();
193     NaturalLoops&amp; naturalLoops();
194     BackwardsCFG&amp; backwardsCFG();
195     BackwardsDominators&amp; backwardsDominators();
196 
197     void addFastConstant(const ValueKey&amp;);
198     bool isFastConstant(const ValueKey&amp;);
199 
200     unsigned numEntrypoints() const { return m_numEntrypoints; }
201     JS_EXPORT_PRIVATE void setNumEntrypoints(unsigned);
202 
203     // The name has to be a string literal, since we don&#39;t do any memory management for the string.
204     void setLastPhaseName(const char* name)
205     {
206         m_lastPhaseName = name;
207     }
208 
209     const char* lastPhaseName() const { return m_lastPhaseName; }
210 
211     // Allocates a slab of memory that will be kept alive by anyone who keeps the resulting code
212     // alive. Great for compiler-generated data sections, like switch jump tables and constant pools.
213     // This returns memory that has been zero-initialized.
214     JS_EXPORT_PRIVATE void* addDataSection(size_t);
215 
216     // Some operations are specified in B3 IR to behave one way but on this given CPU they behave a
217     // different way. When true, those B3 IR ops switch to behaving the CPU way, and the optimizer may
218     // start taking advantage of it.
219     //
220     // One way to think of it is like this. Imagine that you find that the cleanest way of lowering
221     // something in lowerMacros is to unconditionally replace one opcode with another. This is a shortcut
222     // where you instead keep the same opcode, but rely on the opcode&#39;s meaning changes once lowerMacros
223     // sets hasQuirks.
224     bool hasQuirks() const { return m_hasQuirks; }
225     void setHasQuirks(bool value) { m_hasQuirks = value; }
226 
227     OpaqueByproducts&amp; byproducts() { return *m_byproducts; }
228 
229     // Below are methods that make sense to call after you have generated code for the procedure.
230 
231     // You have to call this method after calling generate(). The code generated by B3::generate()
232     // will require you to keep this object alive for as long as that code is runnable. Usually, this
233     // just keeps alive things like the double constant pool and switch lookup tables. If this sounds
234     // confusing, you should probably be using the B3::Compilation API to compile code. If you use
235     // that API, then you don&#39;t have to worry about this.
236     std::unique_ptr&lt;OpaqueByproducts&gt; releaseByproducts() { return WTFMove(m_byproducts); }
237 
238     // This gives you direct access to Code. However, the idea is that clients of B3 shouldn&#39;t have to
239     // call this. So, Procedure has some methods (below) that expose some Air::Code functionality.
240     const Air::Code&amp; code() const { return *m_code; }
241     Air::Code&amp; code() { return *m_code; }
242 
243     unsigned callArgAreaSizeInBytes() const;
244     void requestCallArgAreaSizeInBytes(unsigned size);
245 
246     // This tells the register allocators to stay away from this register.
247     JS_EXPORT_PRIVATE void pinRegister(Reg);
248 
249     JS_EXPORT_PRIVATE void setOptLevel(unsigned value);
250     unsigned optLevel() const { return m_optLevel; }
251 
252     // You can turn off used registers calculation. This may speed up compilation a bit. But if
253     // you turn it off then you cannot use StackmapGenerationParams::usedRegisters() or
254     // StackmapGenerationParams::unavailableRegisters().
255     void setNeedsUsedRegisters(bool value) { m_needsUsedRegisters = value; }
256     bool needsUsedRegisters() const { return m_needsUsedRegisters; }
257 
258     JS_EXPORT_PRIVATE unsigned frameSize() const;
259     JS_EXPORT_PRIVATE RegisterAtOffsetList calleeSaveRegisterAtOffsetList() const;
260 
261     PCToOriginMap&amp; pcToOriginMap() { return m_pcToOriginMap; }
262     PCToOriginMap releasePCToOriginMap() { return WTFMove(m_pcToOriginMap); }
263 
264     JS_EXPORT_PRIVATE void setWasmBoundsCheckGenerator(RefPtr&lt;WasmBoundsCheckGenerator&gt;);
265 
266     template&lt;typename Functor&gt;
267     void setWasmBoundsCheckGenerator(const Functor&amp; functor)
268     {
269         setWasmBoundsCheckGenerator(RefPtr&lt;WasmBoundsCheckGenerator&gt;(createSharedTask&lt;WasmBoundsCheckGeneratorFunction&gt;(functor)));
270     }
271 
272     JS_EXPORT_PRIVATE RegisterSet mutableGPRs();
273     JS_EXPORT_PRIVATE RegisterSet mutableFPRs();
274 
275 private:
276     friend class BlockInsertionSet;
277 
278     JS_EXPORT_PRIVATE Value* addValueImpl(Value*);
279     void setBlockOrderImpl(Vector&lt;BasicBlock*&gt;&amp;);
280 
281     SparseCollection&lt;StackSlot&gt; m_stackSlots;
282     SparseCollection&lt;Variable&gt; m_variables;
283     Vector&lt;Vector&lt;Type&gt;&gt; m_tuples;
284     Vector&lt;std::unique_ptr&lt;BasicBlock&gt;&gt; m_blocks;
285     SparseCollection&lt;Value&gt; m_values;
286     std::unique_ptr&lt;CFG&gt; m_cfg;
287     std::unique_ptr&lt;Dominators&gt; m_dominators;
288     std::unique_ptr&lt;NaturalLoops&gt; m_naturalLoops;
289     std::unique_ptr&lt;BackwardsCFG&gt; m_backwardsCFG;
290     std::unique_ptr&lt;BackwardsDominators&gt; m_backwardsDominators;
291     HashSet&lt;ValueKey&gt; m_fastConstants;
292     unsigned m_numEntrypoints { 1 };
293     const char* m_lastPhaseName;
294     std::unique_ptr&lt;OpaqueByproducts&gt; m_byproducts;
295     std::unique_ptr&lt;Air::Code&gt; m_code;
296     RefPtr&lt;SharedTask&lt;void(PrintStream&amp;, Origin)&gt;&gt; m_originPrinter;
297     const void* m_frontendData;
298     PCToOriginMap m_pcToOriginMap;
299     unsigned m_optLevel { defaultOptLevel() };
300     bool m_needsUsedRegisters { true };
301     bool m_hasQuirks { false };
302 };
303 
304 } } // namespace JSC::B3
305 
306 #endif // ENABLE(B3_JIT)
    </pre>
  </body>
</html>
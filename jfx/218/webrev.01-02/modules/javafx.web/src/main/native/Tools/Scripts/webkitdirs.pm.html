<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Tools/Scripts/webkitdirs.pm</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 # Copyright (C) 2005-2019 Apple Inc. All rights reserved.
   2 # Copyright (C) 2009 Google Inc. All rights reserved.
   3 # Copyright (C) 2011 Research In Motion Limited. All rights reserved.
   4 # Copyright (C) 2013 Nokia Corporation and/or its subsidiary(-ies).
   5 #
   6 # Redistribution and use in source and binary forms, with or without
   7 # modification, are permitted provided that the following conditions
   8 # are met:
   9 #
  10 # 1.  Redistributions of source code must retain the above copyright
  11 #     notice, this list of conditions and the following disclaimer. 
  12 # 2.  Redistributions in binary form must reproduce the above copyright
  13 #     notice, this list of conditions and the following disclaimer in the
  14 #     documentation and/or other materials provided with the distribution. 
  15 # 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  16 #     its contributors may be used to endorse or promote products derived
  17 #     from this software without specific prior written permission. 
  18 #
  19 # THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  20 # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  21 # WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  22 # DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  23 # DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  24 # (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  25 # LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  26 # ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  28 # THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29 
  30 # Module to share code to get to WebKit directories.
  31 
  32 use strict;
  33 #use version; #the module is not used by the Java port
  34 use warnings;
  35 use Config;
  36 use Cwd qw(realpath);
  37 use Digest::MD5 qw(md5_hex);
  38 use FindBin;
  39 use File::Basename;
  40 use File::Find;
  41 use File::Path qw(make_path mkpath rmtree);
  42 use File::Spec;
  43 use File::Temp qw(tempdir);
  44 use File::stat;
  45 use List::Util;
  46 use POSIX;
  47 use Time::HiRes qw(usleep);
  48 use VCSUtils;
  49 
  50 BEGIN {
  51    use Exporter   ();
  52    our ($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);
  53    $VERSION     = 1.00;
  54    @ISA         = qw(Exporter);
  55    @EXPORT      = qw(
  56        &amp;XcodeCoverageSupportOptions
  57        &amp;XcodeOptionString
  58        &amp;XcodeOptionStringNoConfig
  59        &amp;XcodeOptions
  60        &amp;XcodeStaticAnalyzerOption
  61        &amp;appDisplayNameFromBundle
  62        &amp;appendToEnvironmentVariableList
  63        &amp;archCommandLineArgumentsForRestrictedEnvironmentVariables
  64        &amp;availableXcodeSDKs
  65        &amp;baseProductDir
  66        &amp;chdirWebKit
  67        &amp;checkFrameworks
  68        &amp;cmakeArgsFromFeatures
  69        &amp;currentSVNRevision
  70        &amp;debugSafari
  71        &amp;executableProductDir
  72        &amp;extractNonHostConfiguration
  73        &amp;findOrCreateSimulatorForIOSDevice
  74        &amp;iosSimulatorDeviceByName
  75        &amp;iosVersion
  76        &amp;nmPath
  77        &amp;passedConfiguration
  78        &amp;prependToEnvironmentVariableList
  79        &amp;printHelpAndExitForRunAndDebugWebKitAppIfNeeded
  80        &amp;productDir
  81        &amp;quitIOSSimulator
  82        &amp;relaunchIOSSimulator
  83        &amp;restartIOSSimulatorDevice
  84        &amp;runIOSWebKitApp
  85        &amp;runMacWebKitApp
  86        &amp;safariPath
  87        &amp;sdkDirectory
  88        &amp;sdkPlatformDirectory
  89        &amp;setConfiguration
  90        &amp;setupMacWebKitEnvironment
  91        &amp;setupUnixWebKitEnvironment
  92        &amp;sharedCommandLineOptions
  93        &amp;sharedCommandLineOptionsUsage
  94        &amp;shutDownIOSSimulatorDevice
  95        &amp;willUseIOSDeviceSDK
  96        &amp;willUseIOSSimulatorSDK
  97        DO_NOT_USE_OPEN_COMMAND
  98        SIMULATOR_DEVICE_SUFFIX_FOR_WEBKIT_DEVELOPMENT
  99        USE_OPEN_COMMAND
 100    );
 101    %EXPORT_TAGS = ( );
 102    @EXPORT_OK   = ();
 103 }
 104 
 105 # Ports
 106 use constant {
 107     AppleWin    =&gt; &quot;AppleWin&quot;,
 108     FTW         =&gt; &quot;FTW&quot;,
 109     GTK         =&gt; &quot;GTK&quot;,
 110     iOS         =&gt; &quot;iOS&quot;,
 111     tvOS        =&gt; &quot;tvOS&quot;,
 112     watchOS     =&gt; &quot;watchOS&quot;,
 113     Mac         =&gt; &quot;Mac&quot;,
 114     MacCatalyst =&gt; &quot;MacCatalyst&quot;,
 115     JSCOnly     =&gt; &quot;JSCOnly&quot;,
 116     PlayStation =&gt; &quot;PlayStation&quot;,
 117     WinCairo    =&gt; &quot;WinCairo&quot;,
 118     Java     =&gt; &quot;Java&quot;,
 119     WPE         =&gt; &quot;WPE&quot;,
 120     Unknown     =&gt; &quot;Unknown&quot;
 121 };
 122 
 123 use constant USE_OPEN_COMMAND =&gt; 1; # Used in runMacWebKitApp().
 124 use constant DO_NOT_USE_OPEN_COMMAND =&gt; 2;
 125 use constant SIMULATOR_DEVICE_STATE_SHUTDOWN =&gt; &quot;1&quot;;
 126 use constant SIMULATOR_DEVICE_STATE_BOOTED =&gt; &quot;3&quot;;
 127 use constant SIMULATOR_DEVICE_SUFFIX_FOR_WEBKIT_DEVELOPMENT  =&gt; &quot;For WebKit Development&quot;;
 128 
 129 # See table &quot;Certificate types and names&quot; on &lt;https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/MaintainingCertificates/MaintainingCertificates.html#//apple_ref/doc/uid/TP40012582-CH31-SW41&gt;.
 130 use constant IOS_DEVELOPMENT_CERTIFICATE_NAME_PREFIX =&gt; &quot;iPhone Developer: &quot;;
 131 
 132 our @EXPORT_OK;
 133 
 134 my $architecture;
 135 my $asanIsEnabled;
 136 my $forceOptimizationLevel;
 137 my $coverageIsEnabled;
 138 my $ltoMode;
 139 my $numberOfCPUs;
 140 my $maxCPULoad;
 141 my $baseProductDir;
 142 my @baseProductDirOption;
 143 my $configuration;
 144 my $xcodeSDK;
 145 my $configurationForVisualStudio;
 146 my $configurationProductDir;
 147 my $sourceDir;
 148 my $currentSVNRevision;
 149 my $didLoadIPhoneSimulatorNotification;
 150 my $nmPath;
 151 my $osXVersion;
 152 my $iosVersion;
 153 my $generateDsym;
 154 my $isCMakeBuild;
 155 my $isGenerateProjectOnly;
 156 my $shouldBuild32Bit;
 157 my $isWin64;
 158 my $isInspectorFrontend;
 159 my $portName;
 160 my $shouldUseGuardMalloc;
 161 my $shouldNotUseNinja;
 162 my $xcodeVersion;
 163 my $isJava;
 164 my $is32bit;
 165 
 166 my $unknownPortProhibited = 0;
 167 
 168 # Variables for Win32 support
 169 my $programFilesPath;
 170 my $msBuildPath;
 171 my $vsInstallDir;
 172 my $vsVersion;
 173 my $windowsSourceDir;
 174 my $winVersion;
 175 
 176 # Defined in VCSUtils.
 177 sub exitStatus($);
 178 
 179 sub findMatchingArguments($$);
 180 sub hasArgument($$);
 181 
 182 sub sdkDirectory($)
 183 {
 184     my ($sdkName) = @_;
 185     chomp(my $sdkDirectory = `xcrun --sdk &#39;$sdkName&#39; --show-sdk-path`);
 186     die &quot;Failed to get SDK path from xcrun: $!&quot; if exitStatus($?);
 187     return $sdkDirectory;
 188 }
 189 
 190 sub sdkPlatformDirectory($)
 191 {
 192     my ($sdkName) = @_;
 193     chomp(my $sdkPlatformDirectory = `xcrun --sdk &#39;$sdkName&#39; --show-sdk-platform-path`);
 194     die &quot;Failed to get SDK platform path from xcrun: $!&quot; if exitStatus($?);
 195     return $sdkPlatformDirectory;
 196 }
 197 
 198 sub determineSourceDir
 199 {
 200     return if $sourceDir;
 201     $sourceDir = $FindBin::Bin;
 202     $sourceDir =~ s|/+$||; # Remove trailing &#39;/&#39; as we would die later
 203 
 204     # walks up path checking each directory to see if it is the main WebKit project dir, 
 205     # defined by containing Sources, WebCore, and JavaScriptCore.
 206     until ((-d File::Spec-&gt;catdir($sourceDir, &quot;Source&quot;) &amp;&amp; -d File::Spec-&gt;catdir($sourceDir, &quot;Source&quot;, &quot;WebCore&quot;) &amp;&amp; -d File::Spec-&gt;catdir($sourceDir, &quot;Source&quot;, &quot;JavaScriptCore&quot;)) || (-d File::Spec-&gt;catdir($sourceDir, &quot;Internal&quot;) &amp;&amp; -d File::Spec-&gt;catdir($sourceDir, &quot;OpenSource&quot;)))
 207     {
 208         if ($sourceDir !~ s|/[^/]+$||) {
 209             die &quot;Could not find top level webkit directory above source directory using FindBin.\n&quot;;
 210         }
 211     }
 212 
 213     $sourceDir = File::Spec-&gt;catdir($sourceDir, &quot;OpenSource&quot;) if -d File::Spec-&gt;catdir($sourceDir, &quot;OpenSource&quot;);
 214 }
 215 
 216 sub currentPerlPath()
 217 {
 218     my $thisPerl = $^X;
 219     if ($^O ne &#39;VMS&#39;) {
 220         $thisPerl .= $Config{_exe} unless $thisPerl =~ m/$Config{_exe}$/i;
 221     }
 222     return $thisPerl;
 223 }
 224 
 225 # used for scripts which are stored in a non-standard location
 226 sub setSourceDir($)
 227 {
 228     ($sourceDir) = @_;
 229 }
 230 
 231 sub determineNinjaVersion
 232 {
 233     chomp(my $ninjaVersion = `ninja --version`);
 234     return $ninjaVersion;
 235 }
 236 
 237 sub determineXcodeVersion
 238 {
 239     return if defined $xcodeVersion;
 240     my $xcodebuildVersionOutput = `xcodebuild -version`;
 241     $xcodeVersion = ($xcodebuildVersionOutput =~ /Xcode ([0-9]+(\.[0-9]+)*)/) ? $1 : &quot;3.0&quot;;
 242 }
 243 
 244 sub readXcodeUserDefault($)
 245 {
 246     my ($key) = @_;
 247 
 248     my $devnull = File::Spec-&gt;devnull();
 249 
 250     my $value = `defaults read com.apple.dt.Xcode ${key} 2&gt; ${devnull}`;
 251     return if $?;
 252 
 253     chomp $value;
 254     return $value;
 255 }
 256 
 257 sub determineBaseProductDir
 258 {
 259     return if defined $baseProductDir;
 260     determineSourceDir();
 261 
 262     my $setSharedPrecompsDir;
 263     my $indexDataStoreDir;
 264     $baseProductDir = $ENV{&quot;WEBKIT_OUTPUTDIR&quot;};
 265 
 266     if (!defined($baseProductDir) and isAppleCocoaWebKit()) {
 267         # Silently remove ~/Library/Preferences/xcodebuild.plist which can
 268         # cause build failure. The presence of
 269         # ~/Library/Preferences/xcodebuild.plist can prevent xcodebuild from
 270         # respecting global settings such as a custom build products directory
 271         # (&lt;rdar://problem/5585899&gt;).
 272         my $personalPlistFile = $ENV{HOME} . &quot;/Library/Preferences/xcodebuild.plist&quot;;
 273         if (-e $personalPlistFile) {
 274             unlink($personalPlistFile) || die &quot;Could not delete $personalPlistFile: $!&quot;;
 275         }
 276 
 277         my $buildLocationStyle = join &#39;&#39;, readXcodeUserDefault(&quot;IDEBuildLocationStyle&quot;);
 278         if ($buildLocationStyle eq &quot;Custom&quot;) {
 279             my $buildLocationType = join &#39;&#39;, readXcodeUserDefault(&quot;IDECustomBuildLocationType&quot;);
 280             # FIXME: Read CustomBuildIntermediatesPath and set OBJROOT accordingly.
 281             if ($buildLocationType eq &quot;Absolute&quot;) {
 282                 $baseProductDir = readXcodeUserDefault(&quot;IDECustomBuildProductsPath&quot;);
 283                 $indexDataStoreDir = readXcodeUserDefault(&quot;IDECustomIndexStorePath&quot;);
 284             }
 285         }
 286 
 287         # DeterminedByTargets corresponds to a setting of &quot;Legacy&quot; in Xcode.
 288         # It is the only build location style for which SHARED_PRECOMPS_DIR is not
 289         # overridden when building from within Xcode.
 290         $setSharedPrecompsDir = 1 if $buildLocationStyle ne &quot;DeterminedByTargets&quot;;
 291 
 292         if (!defined($baseProductDir)) {
 293             $baseProductDir = join &#39;&#39;, readXcodeUserDefault(&quot;IDEApplicationwideBuildSettings&quot;);
 294             $baseProductDir = $1 if $baseProductDir =~ /SYMROOT\s*=\s*\&quot;(.*?)\&quot;;/s;
 295         }
 296 
 297         undef $baseProductDir unless $baseProductDir =~ /^\//;
 298     }
 299 
 300     if (!defined($baseProductDir)) { # Port-specific checks failed, use default
 301         $baseProductDir = File::Spec-&gt;catdir($sourceDir, &quot;WebKitBuild&quot;);
 302     }
 303 
 304     if (isGit() &amp;&amp; isGitBranchBuild()) {
 305         my $branch = gitBranch();
 306         $baseProductDir = &quot;$baseProductDir/$branch&quot;;
 307     }
 308 
 309     if (isAppleCocoaWebKit()) {
 310         $baseProductDir =~ s|^\Q$(SRCROOT)/..\E$|$sourceDir|;
 311         $baseProductDir =~ s|^\Q$(SRCROOT)/../|$sourceDir/|;
 312         $baseProductDir =~ s|^~/|$ENV{HOME}/|;
 313         die &quot;Can&#39;t handle Xcode product directory with a ~ in it.\n&quot; if $baseProductDir =~ /~/;
 314         die &quot;Can&#39;t handle Xcode product directory with a variable in it.\n&quot; if $baseProductDir =~ /\$/;
 315         @baseProductDirOption = (&quot;SYMROOT=$baseProductDir&quot;, &quot;OBJROOT=$baseProductDir&quot;);
 316         push(@baseProductDirOption, &quot;SHARED_PRECOMPS_DIR=${baseProductDir}/PrecompiledHeaders&quot;) if $setSharedPrecompsDir;
 317         push(@baseProductDirOption, &quot;INDEX_ENABLE_DATA_STORE=YES&quot;, &quot;INDEX_DATA_STORE_DIR=${indexDataStoreDir}&quot;) if $indexDataStoreDir;
 318     }
 319 
 320     if (isCygwin()) {
 321         my $dosBuildPath = `cygpath --windows \&quot;$baseProductDir\&quot;`;
 322         chomp $dosBuildPath;
 323         $ENV{&quot;WEBKIT_OUTPUTDIR&quot;} = $dosBuildPath;
 324         my $unixBuildPath = `cygpath --unix \&quot;$baseProductDir\&quot;`;
 325         chomp $unixBuildPath;
 326         $baseProductDir = $dosBuildPath;
 327     }
 328 }
 329 
 330 sub systemVerbose {
 331     print &quot;+ @_\n&quot;;
 332     return system(@_);
 333 }
 334 
 335 sub setBaseProductDir($)
 336 {
 337     ($baseProductDir) = @_;
 338 }
 339 
 340 sub determineConfiguration
 341 {
 342     return if defined $configuration;
 343     determineBaseProductDir();
 344     if (open CONFIGURATION, &quot;$baseProductDir/Configuration&quot;) {
 345         $configuration = &lt;CONFIGURATION&gt;;
 346         close CONFIGURATION;
 347     }
 348     if ($configuration) {
 349         chomp $configuration;
 350         # compatibility for people who have old Configuration files
 351         $configuration = &quot;Release&quot; if $configuration eq &quot;Deployment&quot;;
 352         $configuration = &quot;Debug&quot; if $configuration eq &quot;Development&quot;;
 353     } else {
 354         $configuration = &quot;Release&quot;;
 355     }
 356 }
 357 
 358 sub determineArchitecture
 359 {
 360     return if defined $architecture;
 361     # make sure $architecture is defined in all cases
 362     $architecture = &quot;&quot;;
 363 
 364     determineBaseProductDir();
 365     determineXcodeSDK();
 366 
 367     if (isAppleCocoaWebKit()) {
 368         if (open ARCHITECTURE, &quot;$baseProductDir/Architecture&quot;) {
 369             $architecture = &lt;ARCHITECTURE&gt;;
 370             close ARCHITECTURE;
 371         }
 372         if ($architecture) {
 373             chomp $architecture;
 374         } else {
 375             if (not defined $xcodeSDK or $xcodeSDK =~ /^(\/$|macosx)/) {
 376                 my $supports64Bit = `sysctl -n hw.optional.x86_64`;
 377                 chomp $supports64Bit;
 378                 $architecture = &#39;x86_64&#39; if $supports64Bit;
 379             } elsif ($xcodeSDK =~ /^iphonesimulator/) {
 380                 $architecture = &#39;x86_64&#39;;
 381             } elsif ($xcodeSDK =~ /^iphoneos/) {
 382                 $architecture = &#39;arm64&#39;;
 383             }
 384         }
 385     } elsif (isCMakeBuild()) {
 386         if (isCrossCompilation()) {
 387             my $compiler = &quot;gcc&quot;;
 388             $compiler = $ENV{&#39;CC&#39;} if (defined($ENV{&#39;CC&#39;}));
 389             my @compiler_machine = split(&#39;-&#39;, `$compiler -dumpmachine`);
 390             $architecture = $compiler_machine[0];
 391         } elsif (open my $cmake_sysinfo, &quot;cmake --system-information |&quot;) {
 392             while (&lt;$cmake_sysinfo&gt;) {
 393                 next unless index($_, &#39;CMAKE_SYSTEM_PROCESSOR&#39;) == 0;
 394                 if (/^CMAKE_SYSTEM_PROCESSOR \&quot;([^&quot;]+)\&quot;/) {
 395                     $architecture = $1;
 396                     last;
 397                 }
 398             }
 399             close $cmake_sysinfo;
 400         }
 401     }
 402 
 403     if (!isAnyWindows()) {
 404         if (!$architecture) {
 405             # Fall back to output of `uname -m&#39;, if it is present.
 406             $architecture = `uname -m`;
 407             chomp $architecture;
 408         }
 409     }
 410 
 411     $architecture = &#39;x86_64&#39; if $architecture =~ /amd64/i;
 412     $architecture = &#39;arm64&#39; if $architecture =~ /aarch64/i;
 413 }
 414 
 415 sub determineASanIsEnabled
 416 {
 417     return if defined $asanIsEnabled;
 418     determineBaseProductDir();
 419 
 420     $asanIsEnabled = 0;
 421     my $asanConfigurationValue;
 422 
 423     if (open ASAN, &quot;$baseProductDir/ASan&quot;) {
 424         $asanConfigurationValue = &lt;ASAN&gt;;
 425         close ASAN;
 426         chomp $asanConfigurationValue;
 427         $asanIsEnabled = 1 if $asanConfigurationValue eq &quot;YES&quot;;
 428     }
 429 }
 430 
 431 sub determineForceOptimizationLevel
 432 {
 433     return if defined $forceOptimizationLevel;
 434     determineBaseProductDir();
 435 
 436     if (open ForceOptimizationLevel, &quot;$baseProductDir/ForceOptimizationLevel&quot;) {
 437         $forceOptimizationLevel = &lt;ForceOptimizationLevel&gt;;
 438         close ForceOptimizationLevel;
 439         chomp $forceOptimizationLevel;
 440     }
 441 }
 442 
 443 sub determineCoverageIsEnabled
 444 {
 445     return if defined $coverageIsEnabled;
 446     determineBaseProductDir();
 447 
 448     if (open Coverage, &quot;$baseProductDir/Coverage&quot;) {
 449         $coverageIsEnabled = &lt;Coverage&gt;;
 450         close Coverage;
 451         chomp $coverageIsEnabled;
 452     }
 453 }
 454 
 455 sub determineLTOMode
 456 {
 457     return if defined $ltoMode;
 458     determineBaseProductDir();
 459 
 460     if (open LTO, &quot;$baseProductDir/LTO&quot;) {
 461         $ltoMode = &lt;LTO&gt;;
 462         close LTO;
 463         chomp $ltoMode;
 464     }
 465 }
 466 
 467 sub determineNumberOfCPUs
 468 {
 469     return if defined $numberOfCPUs;
 470     if (defined($ENV{NUMBER_OF_PROCESSORS})) {
 471         $numberOfCPUs = $ENV{NUMBER_OF_PROCESSORS};
 472     } elsif (isLinux()) {
 473         # First try the nproc utility, if it exists. If we get no
 474         # results fall back to just interpretting /proc directly.
 475         chomp($numberOfCPUs = `nproc --all 2&gt; /dev/null`);
 476         if ($numberOfCPUs eq &quot;&quot;) {
 477             $numberOfCPUs = (grep /processor/, `cat /proc/cpuinfo`);
 478         }
 479     } elsif (isAnyWindows()) {
 480         # Assumes cygwin
 481         $numberOfCPUs = `ls /proc/registry/HKEY_LOCAL_MACHINE/HARDWARE/DESCRIPTION/System/CentralProcessor | wc -w`;
 482     } elsif (isDarwin() || isBSD()) {
 483         chomp($numberOfCPUs = `sysctl -n hw.ncpu`);
 484     } else {
 485         $numberOfCPUs = 1;
 486     }
 487 }
 488 
 489 sub determineMaxCPULoad
 490 {
 491     return if defined $maxCPULoad;
 492     if (defined($ENV{MAX_CPU_LOAD})) {
 493         $maxCPULoad = $ENV{MAX_CPU_LOAD};
 494     }
 495 }
 496 
 497 sub jscPath($)
 498 {
 499     my ($productDir) = @_;
 500     my $jscName = &quot;jsc&quot;;
 501     $jscName .= &quot;_debug&quot;  if configuration() eq &quot;Debug_All&quot;;
 502     if (isPlayStation()) {
 503         $jscName .= &quot;.elf&quot;;
 504     } elsif (isAnyWindows()) {
 505         $jscName .= &quot;.exe&quot;;
 506     }
 507     return &quot;$productDir/$jscName&quot; if -e &quot;$productDir/$jscName&quot;;
 508     return &quot;$productDir/JavaScriptCore.framework/Helpers/$jscName&quot;;
 509 }
 510 
 511 sub argumentsForConfiguration()
 512 {
 513     determineConfiguration();
 514     determineArchitecture();
 515     determineXcodeSDK();
 516 
 517     my @args = ();
 518     # FIXME: Is it necessary to pass --debug, --release, --32-bit or --64-bit?
 519     # These are determined automatically from stored configuration.
 520     push(@args, &#39;--debug&#39;) if ($configuration =~ &quot;^Debug&quot;);
 521     push(@args, &#39;--release&#39;) if ($configuration =~ &quot;^Release&quot;);
 522     push(@args, &#39;--ios-device&#39;) if (defined $xcodeSDK &amp;&amp; $xcodeSDK =~ /^iphoneos/);
 523     push(@args, &#39;--ios-simulator&#39;) if (defined $xcodeSDK &amp;&amp; $xcodeSDK =~ /^iphonesimulator/);
 524     push(@args, &#39;--maccatalyst&#39;) if (defined $xcodeSDK &amp;&amp; $xcodeSDK =~ /^maccatalyst/);
 525     push(@args, &#39;--32-bit&#39;) if ($architecture eq &quot;x86&quot; and !isWin64());
 526     push(@args, &#39;--64-bit&#39;) if (isWin64());
 527     push(@args, &#39;--ftw&#39;) if isFTW();
 528     push(@args, &#39;--gtk&#39;) if isGtk();
 529     push(@args, &#39;--java&#39;) if isJava();
 530     push(@args, &#39;--wpe&#39;) if isWPE();
 531     push(@args, &#39;--jsc-only&#39;) if isJSCOnly();
 532     push(@args, &#39;--wincairo&#39;) if isWinCairo();
 533     push(@args, &#39;--playstation&#39;) if isPlayStation();
 534     return @args;
 535 }
 536 
 537 sub extractNonMacOSHostConfiguration
 538 {
 539     my @args = ();
 540     my @extract = (&#39;--device&#39;, &#39;--gtk&#39;, &#39;--ios&#39;, &#39;--platform&#39;, &#39;--sdk&#39;, &#39;--simulator&#39;, &#39;--wincairo&#39;, &#39;--ftw&#39;, &#39;SDKROOT&#39;, &#39;ARCHS&#39;);
 541     foreach (@{$_[0]}) {
 542         my $line = $_;
 543         my $flag = 0;
 544         foreach (@extract) {
 545             if (length($line) &gt;= length($_) &amp;&amp; substr($line, 0, length($_)) eq $_
 546                 &amp;&amp; index($line, &#39;i386&#39;) == -1 &amp;&amp; index($line, &#39;x86_64&#39;) == -1) {
 547                 $flag = 1;
 548             }
 549         }
 550         if (!$flag) {
 551             push @args, $_;
 552         }
 553     }
 554     return @args;
 555 }
 556 
 557 # FIXME: Convert to json &lt;rdar://problem/21594308&gt;
 558 sub parseAvailableXcodeSDKs($)
 559 {
 560     my @outputToParse = @{$_[0]};
 561     my @result = ();
 562     foreach my $line (@outputToParse) {
 563         # Examples:
 564         #    iOS 12.0 -sdk iphoneos12.0
 565         #    Simulator - iOS 12.0 -sdk iphonesimulator12.0
 566         #    macOS 10.14 -sdk macosx10.14
 567         if ($line =~ /-sdk (\D+)([\d\.]+)(\D*)\n/) {
 568             if ($3) {
 569                 push @result, &quot;$1.$3&quot;;
 570             } else {
 571                 push @result, &quot;$1&quot;;
 572             }
 573         }
 574     }
 575     return @result;
 576 }
 577 
 578 sub availableXcodeSDKs
 579 {
 580     my @output = `xcodebuild -showsdks`;
 581     return parseAvailableXcodeSDKs(\@output);
 582 }
 583 
 584 sub determineXcodeSDK
 585 {
 586     return if defined $xcodeSDK;
 587     my $sdk;
 588     
 589     # The user explicitly specified the sdk, don&#39;t assume anything
 590     if (checkForArgumentAndRemoveFromARGVGettingValue(&quot;--sdk&quot;, \$sdk)) {
 591         $xcodeSDK = $sdk;
 592         return;
 593     }
 594     if (checkForArgumentAndRemoveFromARGV(&quot;--device&quot;) || checkForArgumentAndRemoveFromARGV(&quot;--ios-device&quot;)) {
 595         $xcodeSDK ||= &quot;iphoneos&quot;;
 596     }
 597     if (checkForArgumentAndRemoveFromARGV(&quot;--simulator&quot;) || checkForArgumentAndRemoveFromARGV(&quot;--ios-simulator&quot;)) {
 598         $xcodeSDK ||= &#39;iphonesimulator&#39;;
 599     }
 600     if (checkForArgumentAndRemoveFromARGV(&quot;--tvos-device&quot;)) {
 601         $xcodeSDK ||=  &quot;appletvos&quot;;
 602     }
 603     if (checkForArgumentAndRemoveFromARGV(&quot;--tvos-simulator&quot;)) {
 604         $xcodeSDK ||= &quot;appletvsimulator&quot;;
 605     }
 606     if (checkForArgumentAndRemoveFromARGV(&quot;--watchos-device&quot;)) {
 607         $xcodeSDK ||=  &quot;watchos&quot;;
 608     }
 609     if (checkForArgumentAndRemoveFromARGV(&quot;--watchos-simulator&quot;)) {
 610         $xcodeSDK ||= &quot;watchsimulator&quot;;
 611     }
 612     if (checkForArgumentAndRemoveFromARGV(&quot;--maccatalyst&quot;)) {
 613         $xcodeSDK ||= &quot;maccatalyst&quot;;
 614     }
 615     return if !defined $xcodeSDK;
 616     
 617     # Prefer the internal version of an sdk, if it exists.
 618     my @availableSDKs = availableXcodeSDKs();
 619 
 620     foreach my $sdk (@availableSDKs) {
 621         next if $sdk ne &quot;$xcodeSDK.internal&quot;;
 622         $xcodeSDK = $sdk;
 623         last;
 624     }
 625 }
 626 
 627 sub xcodeSDK
 628 {
 629     determineXcodeSDK();
 630     return $xcodeSDK;
 631 }
 632 
 633 sub setXcodeSDK($)
 634 {
 635     ($xcodeSDK) = @_;
 636 }
 637 
 638 
 639 sub xcodeSDKPlatformName()
 640 {
 641     determineXcodeSDK();
 642     return &quot;&quot; if !defined $xcodeSDK;
 643     return &quot;appletvos&quot; if $xcodeSDK =~ /appletvos/i;
 644     return &quot;appletvsimulator&quot; if $xcodeSDK =~ /appletvsimulator/i;
 645     return &quot;iphoneos&quot; if $xcodeSDK =~ /iphoneos/i;
 646     return &quot;iphonesimulator&quot; if $xcodeSDK =~ /iphonesimulator/i;
 647     return &quot;macosx&quot; if $xcodeSDK =~ /macosx/i;
 648     return &quot;watchos&quot; if $xcodeSDK =~ /watchos/i;
 649     return &quot;watchsimulator&quot; if $xcodeSDK =~ /watchsimulator/i;
 650     return &quot;maccatalyst&quot; if $xcodeSDK =~ /maccatalyst/i;
 651     die &quot;Couldn&#39;t determine platform name from Xcode SDK&quot;;
 652 }
 653 
 654 sub XcodeSDKPath
 655 {
 656     determineXcodeSDK();
 657 
 658     die &quot;Can&#39;t find the SDK path because no Xcode SDK was specified&quot; if not $xcodeSDK;
 659     return sdkDirectory($xcodeSDK);
 660 }
 661 
 662 sub xcodeSDKVersion
 663 {
 664     determineXcodeSDK();
 665 
 666     die &quot;Can&#39;t find the SDK version because no Xcode SDK was specified&quot; if !$xcodeSDK;
 667 
 668     chomp(my $sdkVersion = `xcrun --sdk $xcodeSDK --show-sdk-version`);
 669     die &quot;Failed to get SDK version from xcrun&quot; if exitStatus($?);
 670 
 671     return $sdkVersion;
 672 }
 673 
 674 sub programFilesPath
 675 {
 676     return $programFilesPath if defined $programFilesPath;
 677 
 678     $programFilesPath = $ENV{&#39;PROGRAMFILES(X86)&#39;} || $ENV{&#39;PROGRAMFILES&#39;} || &quot;C:\\Program Files&quot;;
 679 
 680     return $programFilesPath;
 681 }
 682 
 683 sub programFilesPathX86
 684 {
 685     my $programFilesPathX86 = $ENV{&#39;PROGRAMFILES(X86)&#39;} || &quot;C:\\Program Files (x86)&quot;;
 686 
 687     return $programFilesPathX86;
 688 }
 689 
 690 sub visualStudioInstallDirVSWhere
 691 {
 692     my $vswhere = File::Spec-&gt;catdir(programFilesPathX86(), &quot;Microsoft Visual Studio&quot;, &quot;Installer&quot;, &quot;vswhere.exe&quot;);
 693     return unless -e $vswhere;
 694     open(my $handle, &quot;-|&quot;, $vswhere, qw(-nologo -latest -requires Microsoft.Component.MSBuild -property installationPath)) || return;
 695     my $vsWhereOut = &lt;$handle&gt;;
 696     $vsWhereOut =~ s/\r?\n//;
 697     return $vsWhereOut;
 698 }
 699 
 700 sub visualStudioInstallDir
 701 {
 702     return $vsInstallDir if defined $vsInstallDir;
 703 
 704     if ($ENV{&#39;VSINSTALLDIR&#39;}) {
 705         $vsInstallDir = $ENV{&#39;VSINSTALLDIR&#39;};
 706         $vsInstallDir =~ s|[\\/]$||;
 707     } else {
 708         $vsInstallDir = visualStudioInstallDirVSWhere();
 709         return unless defined $vsInstallDir;
 710     }
 711     chomp($vsInstallDir = `cygpath &quot;$vsInstallDir&quot;`) if isCygwin();
 712 
 713     print &quot;Using Visual Studio: $vsInstallDir\n&quot;;
 714     return $vsInstallDir;
 715 }
 716 
 717 sub msBuildPath
 718 {
 719     my $installDir = visualStudioInstallDir();
 720 
 721     # FIXME: vswhere.exe should be used to find msbuild.exe after AppleWin will get vswhere with -find switch.
 722     # &lt;https://github.com/Microsoft/vswhere/wiki/Find-MSBuild&gt;
 723     # &lt;https://github.com/Microsoft/vswhere/releases/tag/2.6.6%2Bd9dbe79db3&gt;
 724     my $path = File::Spec-&gt;catdir($installDir, &quot;MSBuild&quot;, &quot;Current&quot;, &quot;bin&quot;, &quot;MSBuild.exe&quot;);
 725     $path = File::Spec-&gt;catdir($installDir, &quot;MSBuild&quot;, &quot;15.0&quot;, &quot;bin&quot;, &quot;MSBuild.exe&quot;) unless -e $path;
 726 
 727     chomp($path = `cygpath &quot;$path&quot;`) if isCygwin();
 728 
 729     print &quot;Using MSBuild: $path\n&quot;;
 730     return $path;
 731 }
 732 
 733 sub determineConfigurationForVisualStudio
 734 {
 735     return if defined $configurationForVisualStudio;
 736     determineConfiguration();
 737     # FIXME: We should detect when Debug_All or Production has been chosen.
 738     $configurationForVisualStudio = &quot;/p:Configuration=&quot; . $configuration;
 739 }
 740 
 741 sub usesPerConfigurationBuildDirectory
 742 {
 743     # [Gtk] We don&#39;t have Release/Debug configurations in straight
 744     # autotool builds (non build-webkit). In this case and if
 745     # WEBKIT_OUTPUTDIR exist, use that as our configuration dir. This will
 746     # allows us to run run-webkit-tests without using build-webkit.
 747     return ($ENV{&quot;WEBKIT_OUTPUTDIR&quot;} &amp;&amp; isGtk()) || isAppleWinWebKit() || isFTW() || isJava();
 748 }
 749 
 750 sub determineConfigurationProductDir
 751 {
 752     return if defined $configurationProductDir;
 753     determineBaseProductDir();
 754     determineConfiguration();
 755     if (isAppleWinWebKit() || isWinCairo() || isPlayStation() || isFTW()) {
 756         $configurationProductDir = File::Spec-&gt;catdir($baseProductDir, $configuration);
 757     } else {
 758         if (usesPerConfigurationBuildDirectory()) {
 759             $configurationProductDir = &quot;$baseProductDir&quot;;
 760         } else {
 761             $configurationProductDir = &quot;$baseProductDir/$configuration&quot;;
 762             $configurationProductDir .= &quot;-&quot; . xcodeSDKPlatformName() if isEmbeddedWebKit() || isMacCatalystWebKit();
 763         }
 764     }
 765 }
 766 
 767 sub setConfigurationProductDir($)
 768 {
 769     ($configurationProductDir) = @_;
 770 }
 771 
 772 sub determineCurrentSVNRevision
 773 {
 774     # We always update the current SVN revision here, and leave the caching
 775     # to currentSVNRevision(), so that changes to the SVN revision while the
 776     # script is running can be picked up by calling this function again.
 777     determineSourceDir();
 778     $currentSVNRevision = svnRevisionForDirectory($sourceDir);
 779     return $currentSVNRevision;
 780 }
 781 
 782 
 783 sub chdirWebKit
 784 {
 785     determineSourceDir();
 786     chdir $sourceDir or die;
 787 }
 788 
 789 sub baseProductDir
 790 {
 791     determineBaseProductDir();
 792     return $baseProductDir;
 793 }
 794 
 795 sub sourceDir
 796 {
 797     determineSourceDir();
 798     return $sourceDir;
 799 }
 800 
 801 sub productDir
 802 {
 803     determineConfigurationProductDir();
 804     return $configurationProductDir;
 805 }
 806 
 807 sub executableProductDir
 808 {
 809     my $productDirectory = productDir();
 810 
 811     my $binaryDirectory;
 812     if (isAnyWindows() &amp;&amp; !isPlayStation()) {
 813         $binaryDirectory = isWin64() ? &quot;bin64&quot; : &quot;bin32&quot;;
 814     } elsif (isGtk() || isJSCOnly() || isWPE() || isPlayStation()) {
 815         $binaryDirectory = &quot;bin&quot;;
 816     } else {
 817         return $productDirectory;
 818     }
 819 
 820     return File::Spec-&gt;catdir($productDirectory, $binaryDirectory);
 821 }
 822 
 823 sub jscProductDir
 824 {
 825     return executableProductDir();
 826 }
 827 
 828 sub configuration()
 829 {
 830     determineConfiguration();
 831     return $configuration;
 832 }
 833 
 834 sub asanIsEnabled()
 835 {
 836     determineASanIsEnabled();
 837     return $asanIsEnabled;
 838 }
 839 
 840 sub forceOptimizationLevel()
 841 {
 842     determineForceOptimizationLevel();
 843     return $forceOptimizationLevel;
 844 }
 845 
 846 sub ltoMode()
 847 {
 848     determineLTOMode();
 849     return $ltoMode;
 850 }
 851 
 852 sub configurationForVisualStudio()
 853 {
 854     determineConfigurationForVisualStudio();
 855     return $configurationForVisualStudio;
 856 }
 857 
 858 sub currentSVNRevision
 859 {
 860     determineCurrentSVNRevision() if not defined $currentSVNRevision;
 861     return $currentSVNRevision;
 862 }
 863 
 864 sub generateDsym()
 865 {
 866     determineGenerateDsym();
 867     return $generateDsym;
 868 }
 869 
 870 sub determineGenerateDsym()
 871 {
 872     return if defined($generateDsym);
 873     $generateDsym = checkForArgumentAndRemoveFromARGV(&quot;--dsym&quot;);
 874 }
 875 
 876 sub hasIOSDevelopmentCertificate()
 877 {
 878     return !exitStatus(system(&quot;security find-identity -p codesigning | grep &#39;&quot; . IOS_DEVELOPMENT_CERTIFICATE_NAME_PREFIX . &quot;&#39; &gt; /dev/null 2&gt;&amp;1&quot;));
 879 }
 880 
 881 sub argumentsForXcode()
 882 {
 883     my @args = ();
 884     push @args, &quot;DEBUG_INFORMATION_FORMAT=dwarf-with-dsym&quot; if generateDsym();
 885     return @args;
 886 }
 887 
 888 sub XcodeOptions
 889 {
 890     determineBaseProductDir();
 891     determineConfiguration();
 892     determineArchitecture();
 893     determineASanIsEnabled();
 894     determineForceOptimizationLevel();
 895     determineCoverageIsEnabled();
 896     determineLTOMode();
 897     determineXcodeSDK();
 898 
 899     my @options;
 900     push @options, &quot;-UseSanitizedBuildSystemEnvironment=YES&quot;;
 901     push @options, &quot;-ShowBuildOperationDuration=YES&quot;;
 902     push @options, (&quot;-configuration&quot;, $configuration);
 903     push @options, (&quot;-xcconfig&quot;, sourceDir() . &quot;/Tools/asan/asan.xcconfig&quot;, &quot;ASAN_IGNORE=&quot; . sourceDir() . &quot;/Tools/asan/webkit-asan-ignore.txt&quot;) if $asanIsEnabled;
 904     push @options, (&quot;-xcconfig&quot;, sourceDir() . &quot;/Tools/coverage/coverage.xcconfig&quot;) if $coverageIsEnabled;
 905     push @options, (&quot;GCC_OPTIMIZATION_LEVEL=$forceOptimizationLevel&quot;) if $forceOptimizationLevel;
 906     push @options, &quot;WK_LTO_MODE=$ltoMode&quot; if $ltoMode;
 907     push @options, @baseProductDirOption;
 908     push @options, &quot;ARCHS=$architecture&quot; if $architecture;
 909     push @options, &quot;SDKROOT=$xcodeSDK&quot; if $xcodeSDK;
 910 
 911     # When this environment variable is set Tools/Scripts/check-for-weak-vtables-and-externals
 912     # treats errors as non-fatal when it encounters missing symbols related to coverage.
 913     appendToEnvironmentVariableList(&quot;WEBKIT_COVERAGE_BUILD&quot;, &quot;1&quot;) if $coverageIsEnabled;
 914 
 915     die &quot;cannot enable both ASAN and Coverage at this time\n&quot; if $coverageIsEnabled &amp;&amp; $asanIsEnabled;
 916 
 917     if (willUseIOSDeviceSDK() || willUseWatchDeviceSDK() || willUseAppleTVDeviceSDK()) {
 918         push @options, &quot;-IDEProvisioningProfileSupportRelaxed=YES&quot;;
 919         push @options, &quot;ENABLE_BITCODE=NO&quot;;
 920         if (hasIOSDevelopmentCertificate()) {
 921             # FIXME: May match more than one installed development certificate.
 922             push @options, &quot;CODE_SIGN_IDENTITY=&quot; . IOS_DEVELOPMENT_CERTIFICATE_NAME_PREFIX;
 923         } else {
 924             push @options, &quot;CODE_SIGN_IDENTITY=&quot;; # No identity
 925             push @options, &quot;CODE_SIGNING_REQUIRED=NO&quot;;
 926         }
 927     }
 928     push @options, argumentsForXcode();
 929     return @options;
 930 }
 931 
 932 sub XcodeOptionString
 933 {
 934     return join &quot; &quot;, XcodeOptions();
 935 }
 936 
 937 sub XcodeOptionStringNoConfig
 938 {
 939     return join &quot; &quot;, @baseProductDirOption;
 940 }
 941 
 942 sub XcodeCoverageSupportOptions()
 943 {
 944     my @coverageSupportOptions = ();
 945     push @coverageSupportOptions, &quot;GCC_GENERATE_TEST_COVERAGE_FILES=YES&quot;;
 946     push @coverageSupportOptions, &quot;GCC_INSTRUMENT_PROGRAM_FLOW_ARCS=YES&quot;;
 947     return @coverageSupportOptions;
 948 }
 949 
 950 sub XcodeStaticAnalyzerOption()
 951 {
 952     return &quot;RUN_CLANG_STATIC_ANALYZER=YES&quot;;
 953 }
 954 
 955 sub canUseXCBuild()
 956 {
 957     # if (`xcodebuild -version | grep &quot;Build version&quot;` =~ /Build version (\d+)([a-zA-Z])(\d+)([a-zA-Z]?)/) {
 958     #     return $1 &gt;= 11;
 959     # }
 960 
 961     return 0;
 962 }
 963 
 964 my $passedConfiguration;
 965 my $searchedForPassedConfiguration;
 966 sub determinePassedConfiguration
 967 {
 968     return if $searchedForPassedConfiguration;
 969     $searchedForPassedConfiguration = 1;
 970     $passedConfiguration = undef;
 971 
 972     if (checkForArgumentAndRemoveFromARGV(&quot;--debug&quot;)) {
 973         $passedConfiguration = &quot;Debug&quot;;
 974     } elsif(checkForArgumentAndRemoveFromARGV(&quot;--release&quot;)) {
 975         $passedConfiguration = &quot;Release&quot;;
 976     } elsif (checkForArgumentAndRemoveFromARGV(&quot;--profile&quot;) || checkForArgumentAndRemoveFromARGV(&quot;--profiling&quot;)) {
 977         $passedConfiguration = &quot;Profiling&quot;;
 978     } elsif(checkForArgumentAndRemoveFromARGV(&quot;--testing&quot;)) {
 979         $passedConfiguration = &quot;Testing&quot;;
 980     } elsif(checkForArgumentAndRemoveFromARGV(&quot;--release-and-assert&quot;) || checkForArgumentAndRemoveFromARGV(&quot;--ra&quot;)) {
 981         $passedConfiguration = &quot;Release+Assert&quot;;
 982     }
 983 }
 984 
 985 sub passedConfiguration
 986 {
 987     determinePassedConfiguration();
 988     return $passedConfiguration;
 989 }
 990 
 991 sub setConfiguration
 992 {
 993     setArchitecture();
 994 
 995     if (my $config = shift @_) {
 996         $configuration = $config;
 997         return;
 998     }
 999 
1000     determinePassedConfiguration();
1001     $configuration = $passedConfiguration if $passedConfiguration;
1002 }
1003 
1004 
1005 my $passedArchitecture;
1006 my $searchedForPassedArchitecture;
1007 sub determinePassedArchitecture
1008 {
1009     return if $searchedForPassedArchitecture;
1010     $searchedForPassedArchitecture = 1;
1011 
1012     $passedArchitecture = undef;
1013     if (shouldBuild32Bit()) {
1014         if (isAppleCocoaWebKit()) {
1015             # PLATFORM_IOS: Don&#39;t run `arch` command inside Simulator environment
1016             local %ENV = %ENV;
1017             delete $ENV{DYLD_ROOT_PATH};
1018             delete $ENV{DYLD_FRAMEWORK_PATH};
1019 
1020             $passedArchitecture = `arch`;
1021             chomp $passedArchitecture;
1022         }
1023     }
1024 }
1025 
1026 sub passedArchitecture
1027 {
1028     determinePassedArchitecture();
1029     return $passedArchitecture;
1030 }
1031 
1032 sub architecture()
1033 {
1034     determineArchitecture();
1035     return $architecture;
1036 }
1037 
1038 sub numberOfCPUs()
1039 {
1040     determineNumberOfCPUs();
1041     return $numberOfCPUs;
1042 }
1043 
1044 sub maxCPULoad()
1045 {
1046     determineMaxCPULoad();
1047     return $maxCPULoad;
1048 }
1049 
1050 sub setArchitecture
1051 {
1052     if (my $arch = shift @_) {
1053         $architecture = $arch;
1054         return;
1055     }
1056 
1057     determinePassedArchitecture();
1058     $architecture = $passedArchitecture if $passedArchitecture;
1059 }
1060 
1061 # Locate Safari.
1062 sub safariPath
1063 {
1064     die &quot;Safari path is only relevant on Apple Mac platform\n&quot; unless isAppleMacWebKit();
1065 
1066     my $safariPath;
1067 
1068     # Use WEBKIT_SAFARI environment variable if present.
1069     my $safariBundle = $ENV{WEBKIT_SAFARI};
1070     if (!$safariBundle) {
1071         determineConfigurationProductDir();
1072         # Use Safari.app in product directory if present (good for Safari development team).
1073         if (-d &quot;$configurationProductDir/Safari.app&quot;) {
1074             $safariBundle = &quot;$configurationProductDir/Safari.app&quot;;
1075         }
1076     }
1077 
1078     if ($safariBundle) {
1079         $safariPath = &quot;$safariBundle/Contents/MacOS/Safari&quot;;
1080     } else {
1081         $safariPath = &quot;/Applications/Safari.app/Contents/MacOS/SafariForWebKitDevelopment&quot;;
1082     }
1083 
1084     die &quot;Can&#39;t find executable at $safariPath.\n&quot; if !-x $safariPath;
1085     return $safariPath;
1086 }
1087 
1088 sub builtDylibPathForName
1089 {
1090     my $libraryName = shift;
1091     determineConfigurationProductDir();
1092 
1093     if (isGtk()) {
1094         my $extension = isDarwin() ? &quot;.dylib&quot; : &quot;.so&quot;;
1095         return &quot;$configurationProductDir/lib/libwebkit2gtk-4.0&quot; . $extension;
1096     }
1097     if (isIOSWebKit()) {
1098         return &quot;$configurationProductDir/$libraryName.framework/$libraryName&quot;;
1099     }
1100     if (isAppleCocoaWebKit()) {
1101         return &quot;$configurationProductDir/$libraryName.framework/Versions/A/$libraryName&quot;;
1102     }
1103     if (isAppleWinWebKit() || isFTW()) {
1104         if ($libraryName eq &quot;JavaScriptCore&quot;) {
1105             return &quot;$baseProductDir/lib/$libraryName.lib&quot;;
1106         } else {
1107             return &quot;$baseProductDir/$libraryName.intermediate/$configuration/$libraryName.intermediate/$libraryName.lib&quot;;
1108         }
1109     }
1110     if (isJava()) {
1111         my $extension = isDarwin() ? &quot;.dylib&quot; : &quot;.so&quot;;
1112         return &quot;$configurationProductDir/lib/libjfxwebkit&quot; . $extension;
1113     }
1114     if (isWPE()) {
1115         return &quot;$configurationProductDir/lib/libWPEWebKit-1.0.so&quot;;
1116     }
1117 
1118     die &quot;Unsupported platform, can&#39;t determine built library locations.\nTry `build-webkit --help` for more information.\n&quot;;
1119 }
1120 
1121 # Check to see that all the frameworks are built.
1122 sub checkFrameworks # FIXME: This is a poor name since only the Mac calls built WebCore a Framework.
1123 {
1124     return if isAnyWindows() || isJava();
1125     my @frameworks = (&quot;JavaScriptCore&quot;, &quot;WebCore&quot;);
1126     push(@frameworks, &quot;WebKit&quot;) if isAppleCocoaWebKit(); # FIXME: This seems wrong, all ports should have a WebKit these days.
1127     for my $framework (@frameworks) {
1128         my $path = builtDylibPathForName($framework);
1129         die &quot;Can&#39;t find built framework at \&quot;$path\&quot;.\n&quot; unless -e $path;
1130     }
1131 }
1132 
1133 sub isInspectorFrontend()
1134 {
1135     determineIsInspectorFrontend();
1136     return $isInspectorFrontend;
1137 }
1138 
1139 sub determineIsInspectorFrontend()
1140 {
1141     return if defined($isInspectorFrontend);
1142     $isInspectorFrontend = checkForArgumentAndRemoveFromARGV(&quot;--inspector-frontend&quot;);
1143 }
1144 
1145 sub commandExists($)
1146 {
1147     my $command = shift;
1148     my $devnull = File::Spec-&gt;devnull();
1149 
1150     if (isAnyWindows()) {
1151         return exitStatus(system(&quot;where /q $command &gt;$devnull 2&gt;&amp;1&quot;)) == 0;
1152     }
1153     return exitStatus(system(&quot;which $command &gt;$devnull 2&gt;&amp;1&quot;)) == 0;
1154 }
1155 
1156 sub checkForArgumentAndRemoveFromARGV($)
1157 {
1158     my $argToCheck = shift;
1159     return checkForArgumentAndRemoveFromArrayRef($argToCheck, \@ARGV);
1160 }
1161 
1162 sub checkForArgumentAndRemoveFromArrayRefGettingValue($$$)
1163 {
1164     my ($argToCheck, $valueRef, $arrayRef) = @_;
1165     my $argumentStartRegEx = qr#^$argToCheck(?:=\S|$)#;
1166     my $i = 0;
1167     for (; $i &lt; @$arrayRef; ++$i) {
1168         last if $arrayRef-&gt;[$i] =~ $argumentStartRegEx;
1169     }
1170     if ($i &gt;= @$arrayRef) {
1171         return $$valueRef = undef;
1172     }
1173     my ($key, $value) = split(&quot;=&quot;, $arrayRef-&gt;[$i]);
1174     splice(@$arrayRef, $i, 1);
1175     if (defined($value)) {
1176         # e.g. --sdk=iphonesimulator
1177         return $$valueRef = $value;
1178     }
1179     return $$valueRef = splice(@$arrayRef, $i, 1); # e.g. --sdk iphonesimulator
1180 }
1181 
1182 sub checkForArgumentAndRemoveFromARGVGettingValue($$)
1183 {
1184     my ($argToCheck, $valueRef) = @_;
1185     return checkForArgumentAndRemoveFromArrayRefGettingValue($argToCheck, $valueRef, \@ARGV);
1186 }
1187 
1188 sub findMatchingArguments($$)
1189 {
1190     my ($argToCheck, $arrayRef) = @_;
1191     my @matchingIndices;
1192     foreach my $index (0 .. $#$arrayRef) {
1193         my $opt = $$arrayRef[$index];
1194         if ($opt =~ /^$argToCheck$/i ) {
1195             push(@matchingIndices, $index);
1196         }
1197     }
1198     return @matchingIndices; 
1199 }
1200 
1201 sub hasArgument($$)
1202 {
1203     my ($argToCheck, $arrayRef) = @_;
1204     my @matchingIndices = findMatchingArguments($argToCheck, $arrayRef);
1205     return scalar @matchingIndices &gt; 0;
1206 }
1207 
1208 sub checkForArgumentAndRemoveFromArrayRef
1209 {
1210     my ($argToCheck, $arrayRef) = @_;
1211     my @indicesToRemove = findMatchingArguments($argToCheck, $arrayRef);
1212     my $removeOffset = 0;
1213     foreach my $index (@indicesToRemove) {
1214         splice(@$arrayRef, $index - $removeOffset++, 1);
1215     }
1216     return scalar @indicesToRemove &gt; 0;
1217 }
1218 
1219 sub prohibitUnknownPort()
1220 {
1221     $unknownPortProhibited = 1;
1222 }
1223 
1224 sub determinePortName()
1225 {
1226     return if defined $portName;
1227 
1228     my %argToPortName = (
1229         ftw =&gt; FTW,
1230         gtk =&gt; GTK,
1231         &#39;jsc-only&#39; =&gt; JSCOnly,
1232         playstation =&gt; PlayStation,
1233         wincairo =&gt; WinCairo,
1234         java =&gt; Java,
1235         wpe =&gt; WPE
1236     );
1237 
1238     for my $arg (sort keys %argToPortName) {
1239         if (checkForArgumentAndRemoveFromARGV(&quot;--$arg&quot;)) {
1240             die &quot;Argument &#39;--$arg&#39; conflicts with selected port &#39;$portName&#39;\n&quot;
1241                 if defined $portName;
1242 
1243             $portName = $argToPortName{$arg};
1244         }
1245     }
1246 
1247     return if defined $portName;
1248 
1249     # Port was not selected via command line, use appropriate default value
1250 
1251     if (isAnyWindows()) {
1252         $portName = AppleWin;
1253     } elsif (isDarwin()) {
1254         determineXcodeSDK();
1255         if (willUseIOSDeviceSDK() || willUseIOSSimulatorSDK()) {
1256             $portName = iOS;
1257         } elsif (willUseAppleTVDeviceSDK() || willUseAppleTVSimulatorSDK()) {
1258             $portName = tvOS;
1259         } elsif (willUseWatchDeviceSDK() || willUseWatchSimulatorSDK()) {
1260             $portName = watchOS;
1261         } elsif (willUseMacCatalystSDK()) {
1262             $portName = MacCatalyst;
1263         } else {
1264             $portName = Mac;
1265         }
1266     } else {
1267         if ($unknownPortProhibited) {
1268             my $portsChoice = join &quot;\n\t&quot;, qw(
1269                 --gtk
1270                 --jsc-only
1271                 --wpe
1272             );
1273             die &quot;Please specify which WebKit port to build using one of the following options:&quot;
1274                 . &quot;\n\t$portsChoice\n&quot;;
1275         }
1276 
1277         # If script is run without arguments we cannot determine port
1278         # TODO: This state should be outlawed
1279         $portName = Unknown;
1280     }
1281 }
1282 
1283 sub portName()
1284 {
1285     determinePortName();
1286     return $portName;
1287 }
1288 
1289 sub isGtk()
1290 {
1291     return portName() eq GTK;
1292 }
1293 
1294 sub determineIsJava()
1295 {
1296     return if defined($isJava);
1297     $isJava = checkForArgumentAndRemoveFromARGV(&quot;--java&quot;);
1298 }
1299 
1300 sub isJava()
1301 {
1302     return portName() eq Java;
1303 }
1304 
1305 sub isJSCOnly()
1306 {
1307     return portName() eq JSCOnly;
1308 }
1309 
1310 sub isWPE()
1311 {
1312     return portName() eq WPE;
1313 }
1314 
1315 sub isPlayStation()
1316 {
1317     return portName() eq PlayStation;
1318 }
1319 
1320 # Determine if this is debian, ubuntu, linspire, or something similar.
1321 sub isDebianBased()
1322 {
1323     return -e &quot;/etc/debian_version&quot;;
1324 }
1325 
1326 sub isFedoraBased()
1327 {
1328     return -e &quot;/etc/fedora-release&quot;;
1329 }
1330 
1331 sub isFTW()
1332 {
1333     return portName() eq FTW;
1334 }
1335 
1336 sub isWinCairo()
1337 {
1338     return portName() eq WinCairo;
1339 }
1340 
1341 sub shouldBuild32Bit()
1342 {
1343     determineShouldBuild32Bit();
1344     return $shouldBuild32Bit;
1345 }
1346 
1347 sub determineShouldBuild32Bit()
1348 {
1349     return if defined($shouldBuild32Bit);
1350     $shouldBuild32Bit = checkForArgumentAndRemoveFromARGV(&quot;--32-bit&quot;);
1351 }
1352 
1353 sub isWin64()
1354 {
1355     determineIsWin64();
1356     return $isWin64;
1357 }
1358 
1359 sub determineIsWin64()
1360 {
1361     return if defined($isWin64);
1362     $isWin64 = checkForArgumentAndRemoveFromARGV(&quot;--64-bit&quot;) || ((isAnyWindows() || isJSCOnly()) &amp;&amp; !shouldBuild32Bit());
1363 }
1364 
1365 sub determineIsWin64FromArchitecture($)
1366 {
1367     my $arch = shift;
1368     $isWin64 = ($arch eq &quot;x86_64&quot;);
1369     return $isWin64;
1370 }
1371 
1372 sub isCygwin()
1373 {
1374     return ($^O eq &quot;cygwin&quot;) || 0;
1375 }
1376 
1377 sub isAnyWindows()
1378 {
1379     return isWindows() || isCygwin();
1380 }
1381 
1382 sub determineWinVersion()
1383 {
1384     return if $winVersion;
1385 
1386     if (!isAnyWindows()) {
1387         $winVersion = -1;
1388         return;
1389     }
1390 
1391     my $versionString = `cmd /c ver`;
1392     $versionString =~ /(\d)\.(\d)\.(\d+)/;
1393 
1394     $winVersion = {
1395         major =&gt; $1,
1396         minor =&gt; $2,
1397         build =&gt; $3,
1398     };
1399 }
1400 
1401 sub winVersion()
1402 {
1403     determineWinVersion();
1404     return $winVersion;
1405 }
1406 
1407 sub isWindows7SP0()
1408 {
1409     return isAnyWindows() &amp;&amp; winVersion()-&gt;{major} == 6 &amp;&amp; winVersion()-&gt;{minor} == 1 &amp;&amp; winVersion()-&gt;{build} == 7600;
1410 }
1411 
1412 sub isWindowsVista()
1413 {
1414     return isAnyWindows() &amp;&amp; winVersion()-&gt;{major} == 6 &amp;&amp; winVersion()-&gt;{minor} == 0;
1415 }
1416 
1417 sub isWindowsXP()
1418 {
1419     return isAnyWindows() &amp;&amp; winVersion()-&gt;{major} == 5 &amp;&amp; winVersion()-&gt;{minor} == 1;
1420 }
1421 
1422 sub isDarwin()
1423 {
1424     return ($^O eq &quot;darwin&quot;) || 0;
1425 }
1426 
1427 sub isWindows()
1428 {
1429     return ($^O eq &quot;MSWin32&quot;) || 0;
1430 }
1431 
1432 sub isLinux()
1433 {
1434     return ($^O eq &quot;linux&quot;) || 0;
1435 }
1436 
1437 sub isBSD()
1438 {
1439     return ($^O eq &quot;freebsd&quot;) || ($^O eq &quot;openbsd&quot;) || ($^O eq &quot;netbsd&quot;) || 0;
1440 }
1441 
1442 sub isX86_64()
1443 {
1444     return (architecture() eq &quot;x86_64&quot;) || 0;
1445 }
1446 
1447 sub isARM64()
1448 {
1449     return (architecture() eq &quot;arm64&quot;) || 0;
1450 }
1451 
1452 sub isCrossCompilation()
1453 {
1454     my $compiler = &quot;&quot;;
1455     $compiler = $ENV{&#39;CC&#39;} if (defined($ENV{&#39;CC&#39;}));
1456     if ($compiler =~ /gcc/) {
1457         my $compilerOptions = `$compiler -v 2&gt;&amp;1`;
1458         my @host = $compilerOptions =~ m/--host=(.*?)\s/;
1459         my @target = $compilerOptions =~ m/--target=(.*?)\s/;
1460         if (!@target || !@host) {
1461             # Sometimes a compiler does not report the host of target it was compiled for,
1462             # in which case, lacking better information we assume we are not cross-compiling.
1463             return 0;
1464         }
1465         elsif ($target[0] ne &quot;&quot; &amp;&amp; $host[0] ne &quot;&quot;) {
1466                 return ($host[0] ne $target[0]);
1467         } else {
1468                 # $tempDir gets automatically deleted when goes out of scope
1469                 my $tempDir = File::Temp-&gt;newdir();
1470                 my $testProgramSourcePath = File::Spec-&gt;catfile($tempDir, &quot;testcross.c&quot;);
1471                 my $testProgramBinaryPath = File::Spec-&gt;catfile($tempDir, &quot;testcross&quot;);
1472                 open(my $testProgramSourceHandler, &quot;&gt;&quot;, $testProgramSourcePath);
1473                 print $testProgramSourceHandler &quot;int main() { return 0; }\n&quot;;
1474                 system(&quot;$compiler $testProgramSourcePath -o $testProgramBinaryPath &gt; /dev/null 2&gt;&amp;1&quot;) == 0 or return 0;
1475                 # Crosscompiling if the program fails to run (because it was built for other arch)
1476                 system(&quot;$testProgramBinaryPath &gt; /dev/null 2&gt;&amp;1&quot;) == 0 or return 1;
1477                 return 0;
1478         }
1479     }
1480     return 0;
1481 }
1482 
1483 sub isIOSWebKit()
1484 {
1485     return portName() eq iOS;
1486 }
1487 
1488 sub isTVOSWebKit()
1489 {
1490     return portName() eq tvOS;
1491 }
1492 
1493 sub isWatchOSWebKit()
1494 {
1495     return portName() eq watchOS;
1496 }
1497 
1498 sub isEmbeddedWebKit()
1499 {
1500     return isIOSWebKit() || isTVOSWebKit() || isWatchOSWebKit();
1501 }
1502 
1503 sub isAppleWebKit()
1504 {
1505     return !isJava() &amp;&amp; (isAppleCocoaWebKit() || isAppleWinWebKit());
1506 }
1507 
1508 sub isAppleMacWebKit()
1509 {
1510     return portName() eq Mac;
1511 }
1512 
1513 sub isMacCatalystWebKit()
1514 {
1515     return portName() eq MacCatalyst;
1516 }
1517 
1518 sub isAppleCocoaWebKit()
1519 {
1520     return isAppleMacWebKit() || isEmbeddedWebKit() || isMacCatalystWebKit();
1521 }
1522 
1523 sub isAppleWinWebKit()
1524 {
1525     return portName() eq AppleWin;
1526 }
1527 
1528 sub iOSSimulatorDevicesPath
1529 {
1530     return &quot;$ENV{HOME}/Library/Developer/CoreSimulator/Devices&quot;;
1531 }
1532 
1533 sub iOSSimulatorDevices
1534 {
1535     eval &quot;require Foundation&quot;;
1536     my $devicesPath = iOSSimulatorDevicesPath();
1537     opendir(DEVICES, $devicesPath);
1538     my @udids = grep {
1539         $_ =~ m/^[0-9A-F]{8}-([0-9A-F]{4}-){3}[0-9A-F]{12}$/;
1540     } readdir(DEVICES);
1541     close(DEVICES);
1542 
1543     # FIXME: We should parse the device.plist file ourself and map the dictionary keys in it to known
1544     #        dictionary keys so as to decouple our representation of the plist from the actual structure
1545     #        of the plist, which may change.
1546     my @devices = map {
1547         Foundation::perlRefFromObjectRef(NSDictionary-&gt;dictionaryWithContentsOfFile_(&quot;$devicesPath/$_/device.plist&quot;));
1548     } @udids;
1549 
1550     return @devices;
1551 }
1552 
1553 sub createiOSSimulatorDevice
1554 {
1555     my $name = shift;
1556     my $deviceTypeId = shift;
1557     my $runtimeId = shift;
1558 
1559     my $created = system(&quot;xcrun&quot;, &quot;--sdk&quot;, &quot;iphonesimulator&quot;, &quot;simctl&quot;, &quot;create&quot;, $name, $deviceTypeId, $runtimeId) == 0;
1560     die &quot;Couldn&#39;t create simulator device: $name $deviceTypeId $runtimeId&quot; if not $created;
1561 
1562     system(&quot;xcrun&quot;, &quot;--sdk&quot;, &quot;iphonesimulator&quot;, &quot;simctl&quot;, &quot;list&quot;);
1563 
1564     print &quot;Waiting for device to be created ...\n&quot;;
1565     sleep 5;
1566     for (my $tries = 0; $tries &lt; 5; $tries++){
1567         my @devices = iOSSimulatorDevices();
1568         foreach my $device (@devices) {
1569             return $device if $device-&gt;{name} eq $name and $device-&gt;{deviceType} eq $deviceTypeId and $device-&gt;{runtime} eq $runtimeId;
1570         }
1571         sleep 5;
1572     }
1573     die &quot;Device $name $deviceTypeId $runtimeId wasn&#39;t found in &quot; . iOSSimulatorDevicesPath();
1574 }
1575 
1576 sub willUseIOSDeviceSDK()
1577 {
1578     return xcodeSDKPlatformName() eq &quot;iphoneos&quot;;
1579 }
1580 
1581 sub willUseIOSSimulatorSDK()
1582 {
1583     return xcodeSDKPlatformName() eq &quot;iphonesimulator&quot;;
1584 }
1585 
1586 sub willUseAppleTVDeviceSDK()
1587 {
1588     return xcodeSDKPlatformName() eq &quot;appletvos&quot;;
1589 }
1590 
1591 sub willUseAppleTVSimulatorSDK()
1592 {
1593     return xcodeSDKPlatformName() eq &quot;appletvsimulator&quot;;
1594 }
1595 
1596 sub willUseWatchDeviceSDK()
1597 {
1598     return xcodeSDKPlatformName() eq &quot;watchos&quot;;
1599 }
1600 
1601 sub willUseWatchSimulatorSDK()
1602 {
1603     return xcodeSDKPlatformName() eq &quot;watchsimulator&quot;;
1604 }
1605 
1606 sub willUseMacCatalystSDK()
1607 {
1608     return xcodeSDKPlatformName() eq &quot;maccatalyst&quot;;
1609 }
1610 
1611 sub determineNmPath()
1612 {
1613     return if $nmPath;
1614 
1615     if (isAppleCocoaWebKit()) {
1616         $nmPath = `xcrun -find nm`;
1617         chomp $nmPath;
1618     }
1619     $nmPath = &quot;nm&quot; if !$nmPath;
1620 }
1621 
1622 sub nmPath()
1623 {
1624     determineNmPath();
1625     return $nmPath;
1626 }
1627 
1628 sub splitVersionString
1629 {
1630     my $versionString = shift;
1631     my @splitVersion = split(/\./, $versionString);
1632     @splitVersion &gt;= 2 or die &quot;Invalid version $versionString&quot;;
1633     return {
1634         &quot;major&quot; =&gt; $splitVersion[0],
1635         &quot;minor&quot; =&gt; $splitVersion[1],
1636         &quot;subminor&quot; =&gt; (defined($splitVersion[2]) ? $splitVersion[2] : 0),
1637     };
1638 }
1639 
1640 sub determineOSXVersion()
1641 {
1642     return if $osXVersion;
1643 
1644     if (!isDarwin()) {
1645         $osXVersion = -1;
1646         return;
1647     }
1648 
1649     chomp(my $versionString = `sw_vers -productVersion`);
1650     $osXVersion = splitVersionString($versionString);
1651 }
1652 
1653 sub osXVersion()
1654 {
1655     determineOSXVersion();
1656     return $osXVersion;
1657 }
1658 
1659 sub determineIOSVersion()
1660 {
1661     return if $iosVersion;
1662 
1663     if (!isIOSWebKit()) {
1664         $iosVersion = -1;
1665         return;
1666     }
1667 
1668     my $versionString = xcodeSDKVersion();
1669     $iosVersion = splitVersionString($versionString);
1670 }
1671 
1672 sub iosVersion()
1673 {
1674     determineIOSVersion();
1675     return $iosVersion;
1676 }
1677 
1678 sub isWindowsNT()
1679 {
1680     return $ENV{&#39;OS&#39;} eq &#39;Windows_NT&#39;;
1681 }
1682 
1683 sub appendToEnvironmentVariableList($$)
1684 {
1685     my ($name, $value) = @_;
1686 
1687     if (defined($ENV{$name})) {
1688         $ENV{$name} .= $Config{path_sep} . $value;
1689     } else {
1690         $ENV{$name} = $value;
1691     }
1692 }
1693 
1694 sub prependToEnvironmentVariableList($$)
1695 {
1696     my ($name, $value) = @_;
1697 
1698     if (defined($ENV{$name})) {
1699         $ENV{$name} = $value . $Config{path_sep} . $ENV{$name};
1700     } else {
1701         $ENV{$name} = $value;
1702     }
1703 }
1704 
1705 sub sharedCommandLineOptions()
1706 {
1707     return (
1708         &quot;g|guard-malloc&quot; =&gt; \$shouldUseGuardMalloc,
1709     );
1710 }
1711 
1712 sub sharedCommandLineOptionsUsage
1713 {
1714     my %opts = @_;
1715 
1716     my %switches = (
1717         &#39;-g|--guard-malloc&#39; =&gt; &#39;Use guardmalloc when running executable&#39;,
1718     );
1719 
1720     my $indent = &quot; &quot; x ($opts{indent} || 2);
1721     my $switchWidth = List::Util::max(int($opts{switchWidth}), List::Util::max(map { length($_) } keys %switches) + ($opts{brackets} ? 2 : 0));
1722 
1723     my $result = &quot;Common switches:\n&quot;;
1724 
1725     for my $switch (keys %switches) {
1726         my $switchName = $opts{brackets} ? &quot;[&quot; . $switch . &quot;]&quot; : $switch;
1727         $result .= sprintf(&quot;%s%-&quot; . $switchWidth . &quot;s %s\n&quot;, $indent, $switchName, $switches{$switch});
1728     }
1729 
1730     return $result;
1731 }
1732 
1733 sub setUpGuardMallocIfNeeded
1734 {
1735     if (!isDarwin()) {
1736         return;
1737     }
1738 
1739     if (!defined($shouldUseGuardMalloc)) {
1740         $shouldUseGuardMalloc = checkForArgumentAndRemoveFromARGV(&quot;-g&quot;) || checkForArgumentAndRemoveFromARGV(&quot;--guard-malloc&quot;);
1741     }
1742 
1743     if ($shouldUseGuardMalloc) {
1744         appendToEnvironmentVariableList(&quot;DYLD_INSERT_LIBRARIES&quot;, &quot;/usr/lib/libgmalloc.dylib&quot;);
1745         appendToEnvironmentVariableList(&quot;__XPC_DYLD_INSERT_LIBRARIES&quot;, &quot;/usr/lib/libgmalloc.dylib&quot;);
1746     }
1747 }
1748 
1749 sub relativeScriptsDir()
1750 {
1751     my $scriptDir = File::Spec-&gt;catpath(&quot;&quot;, File::Spec-&gt;abs2rel($FindBin::Bin, getcwd()), &quot;&quot;);
1752     if ($scriptDir eq &quot;&quot;) {
1753         $scriptDir = &quot;.&quot;;
1754     }
1755     return $scriptDir;
1756 }
1757 
1758 sub launcherPath()
1759 {
1760     my $relativeScriptsPath = relativeScriptsDir();
1761     if (isGtk() || isWPE()) {
1762         if (inFlatpakSandbox()) {
1763             return &quot;Tools/Scripts/run-minibrowser&quot;;
1764         }
1765         return &quot;$relativeScriptsPath/run-minibrowser&quot;;
1766     } elsif (isAppleWebKit()) {
1767         return &quot;$relativeScriptsPath/run-safari&quot;;
1768     }
1769 }
1770 
1771 sub launcherName()
1772 {
1773     if (isGtk() || isWPE()) {
1774         return &quot;MiniBrowser&quot;;
1775     } elsif (isAppleMacWebKit()) {
1776         return &quot;Safari&quot;;
1777     } elsif (isAppleWinWebKit() || isFTW()) {
1778         return &quot;MiniBrowser&quot;;
1779     }
1780 }
1781 
1782 sub checkRequiredSystemConfig
1783 {
1784     if (isDarwin()) {
1785         chomp(my $productVersion = `sw_vers -productVersion`);
1786         if (eval &quot;v$productVersion&quot; lt v10.10.5) {
1787             print &quot;*************************************************************\n&quot;;
1788             print &quot;OS X Yosemite v10.10.5 or later is required to build WebKit.\n&quot;;
1789             print &quot;You have &quot; . $productVersion . &quot;, thus the build will most likely fail.\n&quot;;
1790             print &quot;*************************************************************\n&quot;;
1791         }
1792         determineXcodeVersion();
1793         if (eval &quot;v$xcodeVersion&quot; lt v7.0) {
1794             print &quot;*************************************************************\n&quot;;
1795             print &quot;Xcode 7.0 or later is required to build WebKit.\n&quot;;
1796             print &quot;You have an earlier version of Xcode, thus the build will\n&quot;;
1797             print &quot;most likely fail. The latest Xcode is available from the App Store.\n&quot;;
1798             print &quot;*************************************************************\n&quot;;
1799         }
1800     }
1801 }
1802 
1803 sub determineWindowsSourceDir()
1804 {
1805     return if $windowsSourceDir;
1806     $windowsSourceDir = sourceDir();
1807     chomp($windowsSourceDir = `cygpath -w &#39;$windowsSourceDir&#39;`) if isCygwin();
1808 }
1809 
1810 sub windowsSourceDir()
1811 {
1812     determineWindowsSourceDir();
1813     return $windowsSourceDir;
1814 }
1815 
1816 sub windowsSourceSourceDir()
1817 {
1818     return File::Spec-&gt;catdir(windowsSourceDir(), &quot;Source&quot;);
1819 }
1820 
1821 sub windowsLibrariesDir()
1822 {
1823     return File::Spec-&gt;catdir(windowsSourceDir(), &quot;WebKitLibraries&quot;, &quot;win&quot;);
1824 }
1825 
1826 sub windowsOutputDir()
1827 {
1828     return File::Spec-&gt;catdir(windowsSourceDir(), &quot;WebKitBuild&quot;);
1829 }
1830 
1831 sub fontExists($)
1832 {
1833     my $font = shift;
1834     my $cmd = &quot;reg query \&quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts\&quot; /v \&quot;$font\&quot; 2&gt;&amp;1&quot;;
1835     my $val = `$cmd`;
1836     return $? == 0;
1837 }
1838 
1839 sub checkInstalledTools()
1840 {
1841     # environment variables. Avoid until this is corrected.
1842     my $pythonVer = `python --version 2&gt;&amp;1`;
1843     die &quot;You must have Python installed to build WebKit.\n&quot; if ($?);
1844 
1845     # cURL 7.34.0 has a bug that prevents authentication with opensource.apple.com (and other things using SSL3).
1846     my $curlVer = `curl --version 2&gt; NUL`;
1847     if (!$? and $curlVer =~ &quot;(.*curl.*)&quot;) {
1848         $curlVer = $1;
1849         if ($curlVer =~ /libcurl\/7\.34\.0/) {
1850             print &quot;cURL version 7.34.0 has a bug that prevents authentication with SSL v2 or v3.\n&quot;;
1851             print &quot;cURL 7.33.0 is known to work. The cURL projects is preparing an update to\n&quot;;
1852             print &quot;correct this problem.\n\n&quot;;
1853             die &quot;Please install a working cURL and try again.\n&quot;;
1854         }
1855     }
1856 
1857     # MathML requires fonts that may not ship with Windows.
1858     # Warn the user if they are missing.
1859     my @fonts = (&#39;Cambria &amp; Cambria Math (TrueType)&#39;, &#39;LatinModernMath-Regular (TrueType)&#39;, &#39;STIXMath-Regular (TrueType)&#39;);
1860     my @missing = ();
1861     foreach my $font (@fonts) {
1862         push @missing, $font if not fontExists($font);
1863     }
1864 
1865     if (scalar @missing &gt; 0) {
1866         print &quot;*************************************************************\n&quot;;
1867         print &quot;Mathematical fonts, such as Latin Modern Math are needed to\n&quot;;
1868         print &quot;use the MathML feature.  You do not appear to have these fonts\n&quot;;
1869         print &quot;on your system.\n\n&quot;;
1870         print &quot;You can download a suitable set of fonts from the following URL:\n&quot;;
1871         print &quot;https://trac.webkit.org/wiki/MathML/Fonts\n&quot;;
1872         print &quot;*************************************************************\n&quot;;
1873     }
1874 
1875     print &quot;Installed tools are correct for the WebKit build.\n&quot;;
1876 }
1877 
1878 sub setupAppleWinEnv()
1879 {
1880     return unless isAppleWinWebKit() || isFTW();
1881 
1882     checkInstalledTools();
1883 
1884     if (isWindowsNT()) {
1885         my $restartNeeded = 0;
1886         my %variablesToSet = ();
1887 
1888         # FIXME: We should remove this explicit version check for cygwin once we stop supporting Cygwin 1.7.9 or older versions. 
1889         # https://bugs.webkit.org/show_bug.cgi?id=85791
1890         my $uname_version = (POSIX::uname())[2];
1891         $uname_version =~ s/\(.*\)//;  # Remove the trailing cygwin version, if any.
1892         $uname_version =~ s/\-.*$//; # Remove trailing dash-version content, if any
1893         if (version-&gt;parse($uname_version) &lt; version-&gt;parse(&quot;1.7.10&quot;)) {
1894             # Setting the environment variable &#39;CYGWIN&#39; to &#39;tty&#39; makes cygwin enable extra support (i.e., termios)
1895             # for UNIX-like ttys in the Windows console
1896             $variablesToSet{CYGWIN} = &quot;tty&quot; unless $ENV{CYGWIN};
1897         }
1898         
1899         # Those environment variables must be set to be able to build inside Visual Studio.
1900         $variablesToSet{WEBKIT_LIBRARIES} = windowsLibrariesDir() unless $ENV{WEBKIT_LIBRARIES};
1901         $variablesToSet{WEBKIT_OUTPUTDIR} = windowsOutputDir() unless $ENV{WEBKIT_OUTPUTDIR};
1902         $variablesToSet{MSBUILDDISABLENODEREUSE} = &quot;1&quot; unless $ENV{MSBUILDDISABLENODEREUSE};
1903         $variablesToSet{_IsNativeEnvironment} = &quot;true&quot; unless $ENV{_IsNativeEnvironment};
1904         $variablesToSet{PreferredToolArchitecture} = &quot;x64&quot; unless $ENV{PreferredToolArchitecture};
1905 
1906         foreach my $variable (keys %variablesToSet) {
1907             print &quot;Setting the Environment Variable &#39;&quot; . $variable . &quot;&#39; to &#39;&quot; . $variablesToSet{$variable} . &quot;&#39;\n\n&quot;;
1908             my $ret = system &quot;setx&quot;, $variable, $variablesToSet{$variable};
1909             if ($ret != 0) {
1910                 system qw(regtool -s set), &#39;\\HKEY_CURRENT_USER\\Environment\\&#39; . $variable, $variablesToSet{$variable};
1911             }
1912             $restartNeeded ||=  $variable eq &quot;WEBKIT_LIBRARIES&quot; || $variable eq &quot;WEBKIT_OUTPUTDIR&quot;;
1913         }
1914 
1915         if ($restartNeeded) {
1916             print &quot;Please restart your computer before attempting to build inside Visual Studio.\n\n&quot;;
1917         }
1918     } else {
1919         if (!defined $ENV{&#39;WEBKIT_LIBRARIES&#39;} || !$ENV{&#39;WEBKIT_LIBRARIES&#39;}) {
1920             print &quot;Warning: You must set the &#39;WebKit_Libraries&#39; environment variable\n&quot;;
1921             print &quot;         to be able build WebKit from within Visual Studio 2017 and newer.\n&quot;;
1922             print &quot;         Make sure that &#39;WebKit_Libraries&#39; points to the\n&quot;;
1923             print &quot;         &#39;WebKitLibraries/win&#39; directory, not the &#39;WebKitLibraries/&#39; directory.\n\n&quot;;
1924         }
1925         if (!defined $ENV{&#39;WEBKIT_OUTPUTDIR&#39;} || !$ENV{&#39;WEBKIT_OUTPUTDIR&#39;}) {
1926             print &quot;Warning: You must set the &#39;WebKit_OutputDir&#39; environment variable\n&quot;;
1927             print &quot;         to be able build WebKit from within Visual Studio 2017 and newer.\n\n&quot;;
1928         }
1929         if (!defined $ENV{&#39;MSBUILDDISABLENODEREUSE&#39;} || !$ENV{&#39;MSBUILDDISABLENODEREUSE&#39;}) {
1930             print &quot;Warning: You should set the &#39;MSBUILDDISABLENODEREUSE&#39; environment variable to &#39;1&#39;\n&quot;;
1931             print &quot;         to avoid periodic locked log files when building.\n\n&quot;;
1932         }
1933     }
1934     # FIXME (125180): Remove the following temporary 64-bit support once official support is available.
1935     if (isWin64() and !$ENV{&#39;WEBKIT_64_SUPPORT&#39;}) {
1936         print &quot;Warning: You must set the &#39;WEBKIT_64_SUPPORT&#39; environment variable\n&quot;;
1937         print &quot;         to be able run WebKit or JavaScriptCore tests.\n\n&quot;;
1938     }
1939 }
1940 
1941 sub setupCygwinEnv()
1942 {
1943     return if !isAnyWindows();
1944     return if $msBuildPath;
1945 
1946     my $programFilesPath = programFilesPath();
1947 
1948     print &quot;Building results into: &quot;, baseProductDir(), &quot;\n&quot;;
1949     print &quot;WEBKIT_OUTPUTDIR is set to: &quot;, $ENV{&quot;WEBKIT_OUTPUTDIR&quot;}, &quot;\n&quot;;
1950     print &quot;WEBKIT_LIBRARIES is set to: &quot;, $ENV{&quot;WEBKIT_LIBRARIES&quot;}, &quot;\n&quot;;
1951     # FIXME (125180): Remove the following temporary 64-bit support once official support is available.
1952     print &quot;WEBKIT_64_SUPPORT is set to: &quot;, $ENV{&quot;WEBKIT_64_SUPPORT&quot;}, &quot;\n&quot; if isWin64();
1953 
1954     # We will actually use MSBuild to build WebKit, but we need to find the Visual Studio install (above) to make
1955     # sure we use the right options.
1956     $msBuildPath = msBuildPath();
1957     if (! -e $msBuildPath) {
1958         print &quot;*************************************************************\n&quot;;
1959         print &quot;Cannot find &#39;$msBuildPath&#39;\n&quot;;
1960         print &quot;Please make sure execute that the Microsoft .NET Framework SDK\n&quot;;
1961         print &quot;is installed on this machine.\n&quot;;
1962         print &quot;*************************************************************\n&quot;;
1963         die;
1964     }
1965 }
1966 
1967 sub buildXCodeProject($$@)
1968 {
1969     my ($project, $clean, @extraOptions) = @_;
1970 
1971     if ($clean) {
1972         push(@extraOptions, &quot;-alltargets&quot;);
1973         push(@extraOptions, &quot;clean&quot;);
1974     }
1975 
1976     chomp($ENV{DSYMUTIL_NUM_THREADS} = `sysctl -n hw.activecpu`);
1977 
1978     # lldbWebKitTester won&#39;t work with the wrong CLANG_DEBUG_INFORMATION_LEVEL, so always use the default for that project
1979     if ($project eq &quot;lldbWebKitTester&quot;) {
1980         my $index = 0;
1981         while ($index &lt; scalar(@extraOptions)) {
1982             if ($extraOptions[$index] =~ /CLANG_DEBUG_INFORMATION_LEVEL=/) {
1983                 splice @extraOptions, $index, 1;
1984             } else {
1985                 $index += 1;
1986             }
1987         }
1988     }
1989     return system &quot;xcodebuild&quot;, &quot;-project&quot;, &quot;$project.xcodeproj&quot;, @extraOptions;
1990 }
1991 
1992 sub getVisualStudioToolset()
1993 {
1994     if (isPlayStation()) {
1995         return &quot;&quot;;
1996     } elsif (isWin64()) {
1997         return &quot;x64&quot;;
1998     } else {
1999         return &quot;Win32&quot;;
2000     }
2001 }
2002 
2003 sub getMSBuildPlatformArgument()
2004 {
2005     my $toolset = getVisualStudioToolset();
2006     if (defined($toolset) &amp;&amp; length($toolset)) {
2007         return &quot;/p:Platform=$toolset&quot;;
2008     }
2009     return &quot;&quot;;
2010 }
2011 
2012 sub getCMakeWindowsToolsetArgument()
2013 {
2014     my $toolset = getVisualStudioToolset();
2015     if (defined($toolset) &amp;&amp; length($toolset)) {
2016         return &quot;-A $toolset&quot;;
2017     }
2018     return &quot;&quot;;
2019 }
2020 
2021 sub buildVisualStudioProject
2022 {
2023     my ($project, $clean) = @_;
2024     setupCygwinEnv();
2025 
2026     my $config = configurationForVisualStudio();
2027 
2028     chomp($project = `cygpath -w &quot;$project&quot;`) if isCygwin();
2029 
2030     my $action = &quot;/t:build&quot;;
2031     if ($clean) {
2032         $action = &quot;/t:clean&quot;;
2033     }
2034 
2035     my $platform = getMSBuildPlatformArgument();
2036     my $logPath = File::Spec-&gt;catdir($baseProductDir, $configuration);
2037     make_path($logPath) unless -d $logPath or $logPath eq &quot;.&quot;;
2038 
2039     my $errorLogFile = File::Spec-&gt;catfile($logPath, &quot;webkit_errors.log&quot;);
2040     chomp($errorLogFile = `cygpath -w &quot;$errorLogFile&quot;`) if isCygwin();
2041     my $errorLogging = &quot;/flp:LogFile=&quot; . $errorLogFile . &quot;;ErrorsOnly&quot;;
2042 
2043     my $warningLogFile = File::Spec-&gt;catfile($logPath, &quot;webkit_warnings.log&quot;);
2044     chomp($warningLogFile = `cygpath -w &quot;$warningLogFile&quot;`) if isCygwin();
2045     my $warningLogging = &quot;/flp1:LogFile=&quot; . $warningLogFile . &quot;;WarningsOnly&quot;;
2046 
2047     my $maxCPUCount = &#39;/maxcpucount:&#39; . numberOfCPUs();
2048 
2049     my @command = ($msBuildPath, &quot;/verbosity:minimal&quot;, $project, $action, $config, $platform, &quot;/fl&quot;, $errorLogging, &quot;/fl1&quot;, $warningLogging, $maxCPUCount);
2050     print join(&quot; &quot;, @command), &quot;\n&quot;;
2051     return system @command;
2052 }
2053 
2054 sub getJhbuildPath()
2055 {
2056     my @jhbuildPath = File::Spec-&gt;splitdir(baseProductDir());
2057     if (isGit() &amp;&amp; isGitBranchBuild() &amp;&amp; gitBranch()) {
2058         pop(@jhbuildPath);
2059     }
2060     if (isGtk()) {
2061         push(@jhbuildPath, &quot;DependenciesGTK&quot;);
2062     } elsif (isJava()) {
2063         push(@jhbuildPath, &quot;DependenciesJava&quot;);
2064     } elsif (isWPE()) {
2065         push(@jhbuildPath, &quot;DependenciesWPE&quot;);
2066     } else {
2067         die &quot;Cannot get JHBuild path for platform that isn&#39;t GTK+ or WPE.\n&quot;;
2068     }
2069     return File::Spec-&gt;catdir(@jhbuildPath);
2070 }
2071 
2072 sub getFlatpakPath()
2073 {
2074     my @flatpakBuildPath = File::Spec-&gt;splitdir(baseProductDir());
2075     if (isGtk()) {
2076         push(@flatpakBuildPath, &quot;GTK&quot;);
2077     } elsif (isWPE()) {
2078         push(@flatpakBuildPath, &quot;WPE&quot;);
2079     } else {
2080         die &quot;Cannot get Flatpak path for platform that isn&#39;t GTK+ or WPE.\n&quot;;
2081     }
2082     my @configuration = configuration();
2083     push(@flatpakBuildPath, &quot;FlatpakTree$configuration&quot;);
2084 
2085     return File::Spec-&gt;catdir(@flatpakBuildPath);
2086 }
2087 
2088 sub isCachedArgumentfileOutOfDate($@)
2089 {
2090     my ($filename, $currentContents) = @_;
2091 
2092     if (! -e $filename) {
2093         return 1;
2094     }
2095 
2096     open(CONTENTS_FILE, $filename);
2097     chomp(my $previousContents = &lt;CONTENTS_FILE&gt; || &quot;&quot;);
2098     close(CONTENTS_FILE);
2099 
2100     if ($previousContents ne $currentContents) {
2101         print &quot;Contents for file $filename have changed.\n&quot;;
2102         print &quot;Previous contents were: $previousContents\n\n&quot;;
2103         print &quot;New contents are: $currentContents\n&quot;;
2104         return 1;
2105     }
2106 
2107     return 0;
2108 }
2109 
2110 sub inFlatpakSandbox()
2111 {
2112     if (-f &quot;/.flatpak-info&quot;) {
2113         return 1;
2114     }
2115 
2116     return 0;
2117 }
2118 
2119 sub runInFlatpak(@)
2120 {
2121     my @arg = @_;
2122     my @command = (File::Spec-&gt;catfile(sourceDir(), &quot;Tools&quot;, &quot;Scripts&quot;, &quot;webkit-flatpak&quot;));
2123     exec @command, argumentsForConfiguration(), &quot;--command&quot;, @_, argumentsForConfiguration(), @ARGV or die;
2124 }
2125 
2126 sub runInFlatpakIfAvailable(@)
2127 {
2128     if (inFlatpakSandbox()) {
2129         return 0;
2130     }
2131 
2132     my @command = (File::Spec-&gt;catfile(sourceDir(), &quot;Tools&quot;, &quot;Scripts&quot;, &quot;webkit-flatpak&quot;));
2133     if (system(@command, &quot;--available&quot;) != 0) {
2134         return 0;
2135     }
2136 
2137     if (! -e getFlatpakPath()) {
2138         return 0;
2139     }
2140 
2141     runInFlatpak(@_)
2142 }
2143 
2144 sub wrapperPrefixIfNeeded()
2145 {
2146     if (isJava()) {
2147         return ();
2148     }
2149 
2150     if (isAnyWindows() || isJSCOnly() || isPlayStation()) {
2151         return ();
2152     }
2153     if (isAppleCocoaWebKit()) {
2154         return (&quot;xcrun&quot;);
2155     }
2156     if (shouldUseJhbuild() and ! shouldUseFlatpak()) {
2157         my @prefix = (File::Spec-&gt;catfile(sourceDir(), &quot;Tools&quot;, &quot;jhbuild&quot;, &quot;jhbuild-wrapper&quot;));
2158         if (isGtk()) {
2159             push(@prefix, &quot;--gtk&quot;);
2160         } elsif (isWPE()) {
2161             push(@prefix, &quot;--wpe&quot;);
2162         }
2163         push(@prefix, &quot;run&quot;);
2164 
2165         return @prefix;
2166     }
2167 
2168     return ();
2169 }
2170 
2171 sub shouldUseJhbuild()
2172 {
2173     return ((isGtk() or isWPE()) and -e getJhbuildPath());
2174 }
2175 
2176 sub shouldUseFlatpak()
2177 {
2178     return ((isGtk() or isWPE()) and ! inFlatpakSandbox() and -e getFlatpakPath());
2179 }
2180 
2181 sub cmakeCachePath()
2182 {
2183     return File::Spec-&gt;catdir(baseProductDir(), configuration(), &quot;CMakeCache.txt&quot;);
2184 }
2185 
2186 sub cmakeFilesPath()
2187 {
2188     return File::Spec-&gt;catdir(baseProductDir(), configuration(), &quot;CMakeFiles&quot;);
2189 }
2190 
2191 sub shouldRemoveCMakeCache(@)
2192 {
2193     my ($cacheFilePath, @buildArgs) = @_;
2194 
2195     # We check this first, because we always want to create this file for a fresh build.
2196     my $productDir = File::Spec-&gt;catdir(baseProductDir(), configuration());
2197     my $optionsCache = File::Spec-&gt;catdir($productDir, &quot;build-webkit-options.txt&quot;);
2198     my $joinedBuildArgs = join(&quot; &quot;, @buildArgs);
2199     if (isCachedArgumentfileOutOfDate($optionsCache, $joinedBuildArgs)) {
2200         File::Path::mkpath($productDir) unless -d $productDir;
2201         open(CACHED_ARGUMENTS, &quot;&gt;&quot;, $optionsCache);
2202         print CACHED_ARGUMENTS $joinedBuildArgs;
2203         close(CACHED_ARGUMENTS);
2204 
2205         return 1;
2206     }
2207 
2208     my $cmakeCache = cmakeCachePath();
2209     unless (-e $cmakeCache) {
2210         return 0;
2211     }
2212 
2213     my $cacheFileModifiedTime = stat($cmakeCache)-&gt;mtime;
2214     my $platformConfiguration = File::Spec-&gt;catdir(sourceDir(), &quot;Source&quot;, &quot;cmake&quot;, &quot;Options&quot; . cmakeBasedPortName() . &quot;.cmake&quot;);
2215     if ($cacheFileModifiedTime &lt; stat($platformConfiguration)-&gt;mtime) {
2216         return 1;
2217     }
2218 
2219     my $globalConfiguration = File::Spec-&gt;catdir(sourceDir(), &quot;Source&quot;, &quot;cmake&quot;, &quot;OptionsCommon.cmake&quot;);
2220     if ($cacheFileModifiedTime &lt; stat($globalConfiguration)-&gt;mtime) {
2221         return 1;
2222     }
2223 
2224     unless (isJava()) {
2225     # FIXME: This probably does not work as expected, or the next block to
2226     # delete the images subdirectory would not be here. Directory mtime does not
2227     # percolate upwards when files are added or removed from subdirectories.
2228     my $inspectorUserInterfaceDirectory = File::Spec-&gt;catdir(sourceDir(), &quot;Source&quot;, &quot;WebInspectorUI&quot;, &quot;UserInterface&quot;);
2229     if ($cacheFileModifiedTime &lt; stat($inspectorUserInterfaceDirectory)-&gt;mtime) {
2230         return 1;
2231     }
2232 
2233     my $inspectorImageDirectory = File::Spec-&gt;catdir(sourceDir(), &quot;Source&quot;, &quot;WebInspectorUI&quot;, &quot;UserInterface&quot;, &quot;Images&quot;);
2234     if ($cacheFileModifiedTime &lt; stat($inspectorImageDirectory)-&gt;mtime) {
2235         return 1;
2236     }
2237     }
2238 
2239     if(isAnyWindows()) {
2240         my $winConfiguration = File::Spec-&gt;catdir(sourceDir(), &quot;Source&quot;, &quot;cmake&quot;, &quot;OptionsWin.cmake&quot;);
2241         if ($cacheFileModifiedTime &lt; stat($winConfiguration)-&gt;mtime) {
2242             return 1;
2243         }
2244     }
2245 
2246     # If a change on the JHBuild moduleset has been done, we need to clean the cache as well.
2247     if (isGtk() || isWPE()) {
2248         my $jhbuildRootDirectory = File::Spec-&gt;catdir(getJhbuildPath(), &quot;Root&quot;);
2249         # The script update-webkit-libs-jhbuild shall re-generate $jhbuildRootDirectory if the moduleset changed.
2250         if (-d $jhbuildRootDirectory &amp;&amp; $cacheFileModifiedTime &lt; stat($jhbuildRootDirectory)-&gt;mtime) {
2251             return 1;
2252         }
2253     }
2254 
2255     return 0;
2256 }
2257 
2258 sub removeCMakeCache(@)
2259 {
2260     my (@buildArgs) = @_;
2261     if (shouldRemoveCMakeCache(@buildArgs)) {
2262         my $cmakeCache = cmakeCachePath();
2263         my $cmakeFiles = cmakeFilesPath();
2264         unlink($cmakeCache) if -e $cmakeCache;
2265         rmtree($cmakeFiles) if -d $cmakeFiles;
2266     }
2267 }
2268 
2269 sub canUseNinja(@)
2270 {
2271     if (!defined($shouldNotUseNinja)) {
2272         $shouldNotUseNinja = checkForArgumentAndRemoveFromARGV(&quot;--no-ninja&quot;);
2273     }
2274 
2275     if ($shouldNotUseNinja) {
2276         return 0;
2277     }
2278 
2279     if (isAppleCocoaWebKit()) {
2280         my $devnull = File::Spec-&gt;devnull();
2281         if (exitStatus(system(&quot;xcrun -find ninja &gt;$devnull 2&gt;&amp;1&quot;)) == 0) {
2282             return 1;
2283         }
2284     }
2285 
2286     # Test both ninja and ninja-build. Fedora uses ninja-build and has patched CMake to also call ninja-build.
2287     return commandExists(&quot;ninja&quot;) || commandExists(&quot;ninja-build&quot;);
2288 }
2289 
2290 sub canUseEclipseNinjaGenerator(@)
2291 {
2292     # Check that eclipse and eclipse Ninja generator is installed
2293     my $devnull = File::Spec-&gt;devnull();
2294     return commandExists(&quot;eclipse&quot;) &amp;&amp; exitStatus(system(&quot;cmake -N -G &#39;Eclipse CDT4 - Ninja&#39; &gt;$devnull 2&gt;&amp;1&quot;)) == 0;
2295 }
2296 
2297 sub cmakeGeneratedBuildfile(@)
2298 {
2299     my ($willUseNinja) = @_;
2300     if ($willUseNinja) {
2301         return File::Spec-&gt;catfile(baseProductDir(), configuration(), &quot;build.ninja&quot;)
2302     } elsif (isAnyWindows()) {
2303         return File::Spec-&gt;catfile(baseProductDir(), configuration(), &quot;WebKit.sln&quot;)
2304     } else {
2305         return File::Spec-&gt;catfile(baseProductDir(), configuration(), &quot;Makefile&quot;)
2306     }
2307     return 0;
2308 }
2309 
2310 sub generateBuildSystemFromCMakeProject
2311 {
2312     my ($prefixPath, @cmakeArgs) = @_;
2313     my $config = configuration();
2314     my $port = cmakeBasedPortName();
2315     my $buildPath = File::Spec-&gt;catdir(baseProductDir(), $config);
2316     File::Path::mkpath($buildPath) unless -d $buildPath;
2317     my $originalWorkingDirectory = getcwd();
2318     chdir($buildPath) or die;
2319 
2320     # We try to be smart about when to rerun cmake, so that we can have faster incremental builds.
2321     my $willUseNinja = canUseNinja();
2322     if (-e cmakeCachePath() &amp;&amp; -e cmakeGeneratedBuildfile($willUseNinja)) {
2323         return 0;
2324     }
2325 
2326     my @args;
2327     push @args, &quot;-DPORT=\&quot;$port\&quot;&quot;;
2328     push @args, &quot;-DCMAKE_INSTALL_PREFIX=\&quot;$prefixPath\&quot;&quot; if $prefixPath;
2329     push @args, &quot;-DCMAKE_EXPORT_COMPILE_COMMANDS=ON&quot;;
2330     if ($config =~ /release/i) {
2331         push @args, &quot;-DCMAKE_BUILD_TYPE=Release&quot;;
2332     } elsif ($config =~ /debug/i) {
2333         push @args, &quot;-DCMAKE_BUILD_TYPE=Debug&quot;;
2334     }
2335 
2336     push @args, &quot;-DENABLE_SANITIZERS=address&quot; if asanIsEnabled();
2337 
2338     push @args, &quot;-DLTO_MODE=$ltoMode&quot; if ltoMode();
2339 
2340     push @args, &#39;-DCMAKE_TOOLCHAIN_FILE=Platform/PlayStation&#39; if isPlayStation();
2341 
2342     if ($willUseNinja) {
2343         push @args, &quot;-G&quot;;
2344         if (canUseEclipseNinjaGenerator()) {
2345             push @args, &quot;&#39;Eclipse CDT4 - Ninja&#39;&quot;;
2346         } else {
2347             push @args, &quot;Ninja&quot;;
2348         }
2349         push @args, &quot;-DUSE_THIN_ARCHIVES=OFF&quot; if isPlayStation();
2350     } elsif (isJava() &amp;&amp; isAnyWindows()) {
2351         push @args, &quot;-G&quot;;
2352         if (isWin64()) {
2353             push @args, &#39;&quot;Visual Studio 15 2017 Win64&quot;&#39;;
2354             push @args, &#39;-DCMAKE_GENERATOR_TOOLSET=&quot;host=x64&quot;&#39;;
2355         } else {
2356             push @args, &#39;&quot;Visual Studio 15 2017&quot;&#39;;
2357         }
2358     } else {
2359         if (isAnyWindows()) {
2360             push @args, getCMakeWindowsToolsetArgument();
2361         }
2362         if ((isAnyWindows() || isPlayStation()) &amp;&amp; defined $ENV{VisualStudioVersion}) {
2363             my $var = int($ENV{VisualStudioVersion});
2364             push @args, qq(-G &quot;Visual Studio $var&quot;);
2365         }
2366     }
2367 
2368     # Do not show progress of generating bindings in interactive Ninja build not to leave noisy lines on tty
2369     push @args, &#39;-DSHOW_BINDINGS_GENERATION_PROGRESS=1&#39; unless ($willUseNinja &amp;&amp; -t STDOUT);
2370 
2371     # Some ports have production mode, but build-webkit should always use developer mode.
2372     push @args, &quot;-DDEVELOPER_MODE=ON&quot; if isGtk() || isJSCOnly() || isWPE() || isWin64();
2373 
2374     if (architecture() eq &quot;x86_64&quot; &amp;&amp; shouldBuild32Bit() &amp;&amp; !(isJava() &amp;&amp; isCygwin())) {
2375         # CMAKE_LIBRARY_ARCHITECTURE is needed to get the right .pc
2376         # files in Debian-based systems, for the others
2377         # CMAKE_PREFIX_PATH will get us /usr/lib, which should be the
2378         # right path for 32bit. See FindPkgConfig.cmake.
2379         push @cmakeArgs, &#39;-DFORCE_32BIT=ON -DCMAKE_PREFIX_PATH=&quot;/usr&quot; -DCMAKE_LIBRARY_ARCHITECTURE=x86&#39;;
2380         $ENV{&quot;CFLAGS&quot;} =  &quot;-m32&quot; . ($ENV{&quot;CFLAGS&quot;} || &quot;&quot;);
2381         $ENV{&quot;CXXFLAGS&quot;} = &quot;-m32&quot; . ($ENV{&quot;CXXFLAGS&quot;} || &quot;&quot;);
2382         $ENV{&quot;LDFLAGS&quot;} = &quot;-m32&quot; . ($ENV{&quot;LDFLAGS&quot;} || &quot;&quot;);
2383     }
2384     push @args, @cmakeArgs if @cmakeArgs;
2385 
2386     my $cmakeSourceDir = isCygwin() ? windowsSourceDir() : sourceDir();
2387     push @args, &#39;&quot;&#39; . $cmakeSourceDir . &#39;&quot;&#39;;
2388 
2389     # We call system(&quot;cmake @args&quot;) instead of system(&quot;cmake&quot;, @args) so that @args is
2390     # parsed for shell metacharacters.
2391     my $wrapper = join(&quot; &quot;, wrapperPrefixIfNeeded()) . &quot; &quot;;
2392     my $returnCode = systemVerbose($wrapper . &quot;cmake @args&quot;);
2393 
2394     chdir($originalWorkingDirectory);
2395     return $returnCode;
2396 }
2397 
2398 sub buildCMakeGeneratedProject($)
2399 {
2400     my (@makeArgs) = @_;
2401     my $config = configuration();
2402     my $buildPath = File::Spec-&gt;catdir(baseProductDir(), $config);
2403     if (! -d $buildPath) {
2404         die &quot;Must call generateBuildSystemFromCMakeProject() before building CMake project.&quot;;
2405     }
2406 
2407     if ($ENV{VERBOSE} &amp;&amp; canUseNinja()) {
2408         push @makeArgs, &quot;-v&quot;;
2409         push @makeArgs, &quot;-d keeprsp&quot; if (version-&gt;parse(determineNinjaVersion()) &gt;= version-&gt;parse(&quot;1.4.0&quot;));
2410     }
2411 
2412     chomp($buildPath = `cygpath -m &#39;$buildPath&#39;`) if isCygwin();
2413 
2414     my $command = &quot;cmake&quot;;
2415     my @args = (&quot;--build&quot;, $buildPath, &quot;--config&quot;, $config);
2416     push @args, (&quot;--&quot;, @makeArgs) if @makeArgs;
2417 
2418     # GTK and JSCOnly can use a build script to preserve colors and pretty-printing.
2419     if ((isGtk() || isJSCOnly()) &amp;&amp; -e &quot;$buildPath/build.sh&quot;) {
2420         chdir &quot;$buildPath&quot; or die;
2421         $command = &quot;$buildPath/build.sh&quot;;
2422         @args = (@makeArgs);
2423     }
2424 
2425     # We call system(&quot;cmake @args&quot;) instead of system(&quot;cmake&quot;, @args) so that @args is
2426     # parsed for shell metacharacters. In particular, @makeArgs may contain such metacharacters.
2427     my $wrapper = join(&quot; &quot;, wrapperPrefixIfNeeded()) . &quot; &quot;;
2428     return systemVerbose($wrapper . &quot;$command @args&quot;);
2429 }
2430 
2431 sub cleanCMakeGeneratedProject()
2432 {
2433     my $config = configuration();
2434     my $buildPath = File::Spec-&gt;catdir(baseProductDir(), $config);
2435     if (-d $buildPath) {
2436         return systemVerbose(&quot;cmake&quot;, &quot;--build&quot;, $buildPath, &quot;--config&quot;, $config, &quot;--target&quot;, &quot;clean&quot;);
2437     }
2438     return 0;
2439 }
2440 
2441 sub buildCMakeProjectOrExit($$$@)
2442 {
2443     my ($clean, $prefixPath, $makeArgs, @cmakeArgs) = @_;
2444     my $returnCode;
2445 
2446     exit(exitStatus(cleanCMakeGeneratedProject())) if $clean;
2447 
2448     if (isGtk() &amp;&amp; checkForArgumentAndRemoveFromARGV(&quot;--update-gtk&quot;)) {
2449         system(&quot;perl&quot;, &quot;$sourceDir/Tools/Scripts/update-webkitgtk-libs&quot;) == 0 or die $!;
2450     }
2451 
2452     if (isWPE() &amp;&amp; checkForArgumentAndRemoveFromARGV(&quot;--update-wpe&quot;)) {
2453         system(&quot;perl&quot;, &quot;$sourceDir/Tools/Scripts/update-webkitwpe-libs&quot;) == 0 or die $!;
2454     }
2455 
2456     $returnCode = exitStatus(generateBuildSystemFromCMakeProject($prefixPath, @cmakeArgs));
2457     exit($returnCode) if $returnCode;
2458     exit 0 if isGenerateProjectOnly();
2459 
2460     $returnCode = exitStatus(buildCMakeGeneratedProject($makeArgs));
2461     exit($returnCode) if $returnCode;
2462     return 0;
2463 }
2464 
2465 sub cmakeArgsFromFeatures(\@;$)
2466 {
2467     my ($featuresArrayRef, $enableExperimentalFeatures) = @_;
2468 
2469     my @args;
2470     push @args, &quot;-DENABLE_EXPERIMENTAL_FEATURES=ON&quot; if $enableExperimentalFeatures;
2471     foreach (@$featuresArrayRef) {
2472         my $featureName = $_-&gt;{define};
2473         if ($featureName) {
2474             my $featureValue = ${$_-&gt;{value}}; # Undef to let the build system use its default.
2475             if (defined($featureValue)) {
2476                 my $featureEnabled = $featureValue ? &quot;ON&quot; : &quot;OFF&quot;;
2477                 push @args, &quot;-D$featureName=$featureEnabled&quot;;
2478             }
2479         }
2480     }
2481     return @args;
2482 }
2483 
2484 sub cmakeBasedPortName()
2485 {
2486     return ucfirst portName();
2487 }
2488 
2489 sub determineIsCMakeBuild()
2490 {
2491     return if defined($isCMakeBuild);
2492     $isCMakeBuild = checkForArgumentAndRemoveFromARGV(&quot;--cmake&quot;);
2493 }
2494 
2495 sub isCMakeBuild()
2496 {
2497     return 1 unless isAppleCocoaWebKit();
2498     determineIsCMakeBuild();
2499     return $isCMakeBuild;
2500 }
2501 
2502 sub determineIsGenerateProjectOnly()
2503 {
2504     return if defined($isGenerateProjectOnly);
2505     $isGenerateProjectOnly = checkForArgumentAndRemoveFromARGV(&quot;--generate-project-only&quot;);
2506 }
2507 
2508 sub isGenerateProjectOnly()
2509 {
2510     determineIsGenerateProjectOnly();
2511     return $isGenerateProjectOnly;
2512 }
2513 
2514 sub promptUser
2515 {
2516     my ($prompt, $default) = @_;
2517     my $defaultValue = $default ? &quot;[$default]&quot; : &quot;&quot;;
2518     print &quot;$prompt $defaultValue: &quot;;
2519     chomp(my $input = &lt;STDIN&gt;);
2520     return $input ? $input : $default;
2521 }
2522 
2523 sub appleApplicationSupportPath
2524 {
2525     open INSTALL_DIR, &quot;&lt;/proc/registry/HKEY_LOCAL_MACHINE/SOFTWARE/Apple\ Inc./Apple\ Application\ Support/InstallDir&quot;;
2526     my $path = &lt;INSTALL_DIR&gt;;
2527     $path =~ s/[\r\n\x00].*//;
2528     close INSTALL_DIR;
2529 
2530     my $unixPath = `cygpath -u &#39;$path&#39;`;
2531     chomp $unixPath;
2532     return $unixPath;
2533 }
2534 
2535 sub setPathForRunningWebKitApp
2536 {
2537     my ($env) = @_;
2538 
2539     if (isAnyWindows()) {
2540         my $productBinaryDir = executableProductDir();
2541         if (isAppleWinWebKit() || isFTW()) {
2542             $env-&gt;{PATH} = join(&#39;:&#39;, $productBinaryDir, appleApplicationSupportPath(), $env-&gt;{PATH} || &quot;&quot;);
2543         } elsif (isWinCairo()) {
2544             my $winCairoBin = sourceDir() . &quot;/WebKitLibraries/win/&quot; . (isWin64() ? &quot;bin64/&quot; : &quot;bin32/&quot;);
2545             my $gstreamerBin = isWin64() ? $ENV{&quot;GSTREAMER_1_0_ROOT_X86_64&quot;} . &quot;bin&quot; : $ENV{&quot;GSTREAMER_1_0_ROOT_X86&quot;} . &quot;bin&quot;;
2546             $env-&gt;{PATH} = join(&#39;:&#39;, $productBinaryDir, $winCairoBin, $gstreamerBin, $env-&gt;{PATH} || &quot;&quot;);
2547         }
2548     }
2549 }
2550 
2551 sub printHelpAndExitForRunAndDebugWebKitAppIfNeeded
2552 {
2553     return unless checkForArgumentAndRemoveFromARGV(&quot;--help&quot;);
2554 
2555     print STDERR &lt;&lt;EOF;
2556 Usage: @{[basename($0)]} [options] [args ...]
2557   --help                            Show this help message
2558   --no-saved-state                  Launch the application without state restoration
2559 
2560 Options specific to macOS:
2561   -g|--guard-malloc                 Enable Guard Malloc
2562   --lang=LANGUAGE                   Use a specific language instead of system language.
2563                                     This accepts a language name (German) or a language code (de, ar, pt_BR, etc).
2564   --locale=LOCALE                   Use a specific locale instead of the system region.
2565 EOF
2566 
2567     exit(1);
2568 }
2569 
2570 sub argumentsForRunAndDebugMacWebKitApp()
2571 {
2572     my @args = ();
2573     if (checkForArgumentAndRemoveFromARGV(&quot;--no-saved-state&quot;)) {
2574         push @args, (&quot;-ApplePersistenceIgnoreStateQuietly&quot;, &quot;YES&quot;);
2575     }
2576 
2577     my $lang;
2578     if (checkForArgumentAndRemoveFromARGVGettingValue(&quot;--lang&quot;, \$lang)) {
2579         push @args, (&quot;-AppleLanguages&quot;, &quot;(&quot; . $lang . &quot;)&quot;);
2580     }
2581 
2582     my $locale;
2583     if (checkForArgumentAndRemoveFromARGVGettingValue(&quot;--locale&quot;, \$locale)) {
2584         push @args, (&quot;-AppleLocale&quot;, $locale);
2585     }
2586 
2587     unshift @args, @ARGV;
2588 
2589     return @args;
2590 }
2591 
2592 sub setupMacWebKitEnvironment($)
2593 {
2594     my ($dyldFrameworkPath) = @_;
2595 
2596     $dyldFrameworkPath = File::Spec-&gt;rel2abs($dyldFrameworkPath);
2597 
2598     prependToEnvironmentVariableList(&quot;DYLD_FRAMEWORK_PATH&quot;, $dyldFrameworkPath);
2599     prependToEnvironmentVariableList(&quot;__XPC_DYLD_FRAMEWORK_PATH&quot;, $dyldFrameworkPath);
2600     prependToEnvironmentVariableList(&quot;DYLD_LIBRARY_PATH&quot;, $dyldFrameworkPath);
2601     prependToEnvironmentVariableList(&quot;__XPC_DYLD_LIBRARY_PATH&quot;, $dyldFrameworkPath);
2602     $ENV{WEBKIT_UNSET_DYLD_FRAMEWORK_PATH} = &quot;YES&quot;;
2603 
2604     setUpGuardMallocIfNeeded();
2605 }
2606 
2607 sub setupUnixWebKitEnvironment($)
2608 {
2609     my ($productDir) = @_;
2610 
2611     $ENV{TEST_RUNNER_INJECTED_BUNDLE_FILENAME} = File::Spec-&gt;catfile($productDir, &quot;lib&quot;, &quot;libTestRunnerInjectedBundle.so&quot;);
2612     $ENV{TEST_RUNNER_TEST_PLUGIN_PATH} = File::Spec-&gt;catdir($productDir, &quot;lib&quot;, &quot;plugins&quot;);
2613 }
2614 
2615 sub setupIOSWebKitEnvironment($)
2616 {
2617     my ($dyldFrameworkPath) = @_;
2618     $dyldFrameworkPath = File::Spec-&gt;rel2abs($dyldFrameworkPath);
2619 
2620     prependToEnvironmentVariableList(&quot;DYLD_FRAMEWORK_PATH&quot;, $dyldFrameworkPath);
2621     prependToEnvironmentVariableList(&quot;DYLD_LIBRARY_PATH&quot;, $dyldFrameworkPath);
2622 
2623     setUpGuardMallocIfNeeded();
2624 }
2625 
2626 sub iosSimulatorApplicationsPath()
2627 {
2628     # FIXME: We should ask simctl for this information, instead of guessing from available runtimes.
2629     my $runtimePath = File::Spec-&gt;catdir(sdkPlatformDirectory(&quot;iphoneos&quot;), &quot;Library&quot;, &quot;Developer&quot;, &quot;CoreSimulator&quot;, &quot;Profiles&quot;, &quot;Runtimes&quot;);
2630     opendir(RUNTIMES, $runtimePath);
2631     my @runtimes = grep {/.*\.simruntime/} readdir(RUNTIMES);
2632     close(RUNTIMES);
2633     my $sult = File::Spec-&gt;catdir($runtimePath, @runtimes ? $runtimes[0] : &quot;iOS.simruntime&quot;, &quot;Contents&quot;, &quot;Resources&quot;, &quot;RuntimeRoot&quot;, &quot;Applications&quot;);
2634     return $sult;
2635 }
2636 
2637 sub installedMobileSafariBundle()
2638 {
2639     return File::Spec-&gt;catfile(iosSimulatorApplicationsPath(), &quot;MobileSafari.app&quot;);
2640 }
2641 
2642 sub mobileSafariBundle()
2643 {
2644     determineConfigurationProductDir();
2645 
2646     # Use MobileSafari.app in product directory if present.
2647     if (isIOSWebKit() &amp;&amp; -d &quot;$configurationProductDir/MobileSafari.app&quot;) {
2648         return &quot;$configurationProductDir/MobileSafari.app&quot;;
2649     }
2650     return installedMobileSafariBundle();
2651 }
2652 
2653 sub plistPathFromBundle($)
2654 {
2655     my ($appBundle) = @_;
2656     return &quot;$appBundle/Info.plist&quot; if -f &quot;$appBundle/Info.plist&quot;; # iOS app bundle
2657     return &quot;$appBundle/Contents/Info.plist&quot; if -f &quot;$appBundle/Contents/Info.plist&quot;; # Mac app bundle
2658     return &quot;&quot;;
2659 }
2660 
2661 sub appIdentifierFromBundle($)
2662 {
2663     my ($appBundle) = @_;
2664     my $plistPath = File::Spec-&gt;rel2abs(plistPathFromBundle($appBundle)); # defaults(1) will complain if the specified path is not absolute.
2665     chomp(my $bundleIdentifier = `defaults read &#39;$plistPath&#39; CFBundleIdentifier 2&gt; /dev/null`);
2666     return $bundleIdentifier;
2667 }
2668 
2669 sub appDisplayNameFromBundle($)
2670 {
2671     my ($appBundle) = @_;
2672     my $plistPath = File::Spec-&gt;rel2abs(plistPathFromBundle($appBundle)); # defaults(1) will complain if the specified path is not absolute.
2673     chomp(my $bundleDisplayName = `defaults read &#39;$plistPath&#39; CFBundleDisplayName 2&gt; /dev/null`);
2674     return $bundleDisplayName;
2675 }
2676 
2677 sub waitUntilIOSSimulatorDeviceIsInState($$)
2678 {
2679     my ($deviceUDID, $waitUntilState) = @_;
2680     my $device = iosSimulatorDeviceByUDID($deviceUDID);
2681     # FIXME: We should add a maximum time limit to wait here.
2682     while ($device-&gt;{state} ne $waitUntilState) {
2683         usleep(500 * 1000); # Waiting 500ms between file system polls does not make script run-safari feel sluggish.
2684         $device = iosSimulatorDeviceByUDID($deviceUDID);
2685     }
2686 }
2687 
2688 sub waitUntilProcessNotRunning($)
2689 {
2690     my ($process) = @_;
2691     while (system(&quot;/bin/ps -eo pid,comm | /usr/bin/grep &#39;$process\$&#39;&quot;) == 0) {
2692         usleep(500 * 1000);
2693     }
2694 }
2695 
2696 sub shutDownIOSSimulatorDevice($)
2697 {
2698     my ($simulatorDevice) = @_;
2699     system(&quot;xcrun --sdk iphonesimulator simctl shutdown $simulatorDevice-&gt;{UDID} &gt; /dev/null 2&gt;&amp;1&quot;);
2700 }
2701 
2702 sub restartIOSSimulatorDevice($)
2703 {
2704     my ($simulatorDevice) = @_;
2705     shutDownIOSSimulatorDevice($simulatorDevice);
2706 
2707     exitStatus(system(&quot;xcrun&quot;, &quot;--sdk&quot;, &quot;iphonesimulator&quot;, &quot;simctl&quot;, &quot;boot&quot;, $simulatorDevice-&gt;{UDID})) == 0 or die &quot;Failed to boot simulator device $simulatorDevice-&gt;{UDID}&quot;;
2708 }
2709 
2710 sub relaunchIOSSimulator($)
2711 {
2712     my ($simulatedDevice) = @_;
2713     quitIOSSimulator($simulatedDevice-&gt;{UDID});
2714 
2715     # FIXME: &lt;rdar://problem/20916140&gt; Switch to using CoreSimulator.framework for launching and quitting iOS Simulator
2716     chomp(my $developerDirectory = $ENV{DEVELOPER_DIR} || `xcode-select --print-path`); 
2717     my $iosSimulatorPath = File::Spec-&gt;catfile($developerDirectory, &quot;Applications&quot;, &quot;Simulator.app&quot;); 
2718     system(&quot;open&quot;, &quot;-a&quot;, $iosSimulatorPath, &quot;--args&quot;, &quot;-CurrentDeviceUDID&quot;, $simulatedDevice-&gt;{UDID}) == 0 or die &quot;Failed to open $iosSimulatorPath: $!&quot;; 
2719 
2720     waitUntilIOSSimulatorDeviceIsInState($simulatedDevice-&gt;{UDID}, SIMULATOR_DEVICE_STATE_BOOTED);
2721     waitUntilProcessNotRunning(&quot;com.apple.datamigrator&quot;);
2722 }
2723 
2724 sub quitIOSSimulator(;$)
2725 {
2726     my ($waitForShutdownOfSimulatedDeviceUDID) = @_;
2727     # FIXME: &lt;rdar://problem/20916140&gt; Switch to using CoreSimulator.framework for launching and quitting iOS Simulator
2728     if (exitStatus(system {&quot;osascript&quot;} &quot;osascript&quot;, &quot;-e&quot;, &#39;tell application id &quot;com.apple.iphonesimulator&quot; to quit&#39;)) {
2729         # osascript returns a non-zero exit status if Simulator.app is not registered in LaunchServices.
2730         return;
2731     }
2732 
2733     if (!defined($waitForShutdownOfSimulatedDeviceUDID)) {
2734         return;
2735     }
2736     # FIXME: We assume that $waitForShutdownOfSimulatedDeviceUDID was not booted using the simctl command line tool.
2737     #        Otherwise we will spin indefinitely since quiting the iOS Simulator will not shutdown this device. We
2738     #        should add a maximum time limit to wait for a device to shutdown and either return an error or die()
2739     #        on expiration of the time limit.
2740     waitUntilIOSSimulatorDeviceIsInState($waitForShutdownOfSimulatedDeviceUDID, SIMULATOR_DEVICE_STATE_SHUTDOWN);
2741 }
2742 
2743 sub iosSimulatorDeviceByName($)
2744 {
2745     my ($simulatorName) = @_;
2746     my $simulatorRuntime = iosSimulatorRuntime();
2747     my @devices = iOSSimulatorDevices();
2748     for my $device (@devices) {
2749         if ($device-&gt;{name} eq $simulatorName &amp;&amp; $device-&gt;{runtime} eq $simulatorRuntime) {
2750             return $device;
2751         }
2752     }
2753     return undef;
2754 }
2755 
2756 sub iosSimulatorDeviceByUDID($)
2757 {
2758     my ($simulatedDeviceUDID) = @_;
2759     my $devicePlistPath = File::Spec-&gt;catfile(iOSSimulatorDevicesPath(), $simulatedDeviceUDID, &quot;device.plist&quot;);
2760     if (!-f $devicePlistPath) {
2761         return;
2762     }
2763     # FIXME: We should parse the device.plist file ourself and map the dictionary keys in it to known
2764     #        dictionary keys so as to decouple our representation of the plist from the actual structure
2765     #        of the plist, which may change.
2766     eval &quot;require Foundation&quot;;
2767     return Foundation::perlRefFromObjectRef(NSDictionary-&gt;dictionaryWithContentsOfFile_($devicePlistPath));
2768 }
2769 
2770 sub iosSimulatorRuntime()
2771 {
2772     my $xcodeSDKVersion = xcodeSDKVersion();
2773     $xcodeSDKVersion =~ s/\./-/;
2774     return &quot;com.apple.CoreSimulator.SimRuntime.iOS-$xcodeSDKVersion&quot;;
2775 }
2776 
2777 sub findOrCreateSimulatorForIOSDevice($)
2778 {
2779     my ($simulatorNameSuffix) = @_;
2780     my $simulatorName;
2781     my $simulatorDeviceType;
2782     if (architecture() eq &quot;x86_64&quot;) {
2783         $simulatorName = &quot;iPhone SE &quot; . $simulatorNameSuffix;
2784         $simulatorDeviceType = &quot;com.apple.CoreSimulator.SimDeviceType.iPhone-SE&quot;;
2785     } else {
2786         $simulatorName = &quot;iPhone 5 &quot; . $simulatorNameSuffix;
2787         $simulatorDeviceType = &quot;com.apple.CoreSimulator.SimDeviceType.iPhone-5&quot;;
2788     }
2789     my $simulatedDevice = iosSimulatorDeviceByName($simulatorName);
2790     return $simulatedDevice if $simulatedDevice;
2791     return createiOSSimulatorDevice($simulatorName, $simulatorDeviceType, iosSimulatorRuntime());
2792 }
2793 
2794 sub isIOSSimulatorSystemInstalledApp($)
2795 {
2796     my ($appBundle) = @_;
2797     my $simulatorApplicationsPath = realpath(iosSimulatorApplicationsPath());
2798     return substr(realpath($appBundle), 0, length($simulatorApplicationsPath)) eq $simulatorApplicationsPath;
2799 }
2800 
2801 sub hasUserInstalledAppInSimulatorDevice($$)
2802 {
2803     my ($appIdentifier, $simulatedDeviceUDID) = @_;
2804     my $userInstalledAppPath = File::Spec-&gt;catfile($ENV{HOME}, &quot;Library&quot;, &quot;Developer&quot;, &quot;CoreSimulator&quot;, &quot;Devices&quot;, $simulatedDeviceUDID, &quot;data&quot;, &quot;Containers&quot;, &quot;Bundle&quot;, &quot;Application&quot;);
2805     if (!-d $userInstalledAppPath) {
2806         return 0; # No user installed apps.
2807     }
2808     local @::userInstalledAppBundles;
2809     my $wantedFunction = sub {
2810         my $file = $_;
2811 
2812         # Ignore hidden files and directories.
2813         if ($file =~ /^\../) {
2814             $File::Find::prune = 1;
2815             return;
2816         }
2817 
2818         return if !-d $file || $file !~ /\.app$/;
2819         push @::userInstalledAppBundles, $File::Find::name;
2820         $File::Find::prune = 1; # Do not traverse contents of app bundle.
2821     };
2822     find($wantedFunction, $userInstalledAppPath);
2823     for my $userInstalledAppBundle (@::userInstalledAppBundles) {
2824         if (appIdentifierFromBundle($userInstalledAppBundle) eq $appIdentifier) {
2825             return 1; # Has user installed app.
2826         }
2827     }
2828     return 0; # Does not have user installed app.
2829 }
2830 
2831 sub isSimulatorDeviceBooted($)
2832 {
2833     my ($simulatedDeviceUDID) = @_;
2834     my $device = iosSimulatorDeviceByUDID($simulatedDeviceUDID);
2835     return $device &amp;&amp; $device-&gt;{state} eq SIMULATOR_DEVICE_STATE_BOOTED;
2836 }
2837 
2838 sub runIOSWebKitAppInSimulator($;$)
2839 {
2840     my ($appBundle, $simulatorOptions) = @_;
2841     my $productDir = productDir();
2842     my $appDisplayName = appDisplayNameFromBundle($appBundle);
2843     my $appIdentifier = appIdentifierFromBundle($appBundle);
2844     my $simulatedDevice = findOrCreateSimulatorForIOSDevice(SIMULATOR_DEVICE_SUFFIX_FOR_WEBKIT_DEVELOPMENT);
2845     my $simulatedDeviceUDID = $simulatedDevice-&gt;{UDID};
2846 
2847     my $willUseSystemInstalledApp = isIOSSimulatorSystemInstalledApp($appBundle);
2848     if ($willUseSystemInstalledApp) {
2849         if (hasUserInstalledAppInSimulatorDevice($appIdentifier, $simulatedDeviceUDID)) {
2850             # Restore the system-installed app in the simulator device corresponding to $appBundle as it
2851             # was previously overwritten with a custom built version of the app.
2852             # FIXME: Only restore the system-installed version of the app instead of erasing all contents and settings.
2853             print &quot;Quitting iOS Simulator...\n&quot;;
2854             quitIOSSimulator($simulatedDeviceUDID);
2855             print &quot;Erasing contents and settings for simulator device \&quot;$simulatedDevice-&gt;{name}\&quot;.\n&quot;;
2856             exitStatus(system(&quot;xcrun&quot;, &quot;--sdk&quot;, &quot;iphonesimulator&quot;, &quot;simctl&quot;, &quot;erase&quot;, $simulatedDeviceUDID)) == 0 or die;
2857         }
2858         # FIXME: We assume that if $simulatedDeviceUDID is not booted then iOS Simulator is not open. However
2859         #        $simulatedDeviceUDID may have been booted using the simctl command line tool. If $simulatedDeviceUDID
2860         #        was booted using simctl then we should shutdown the device and launch iOS Simulator to boot it again.
2861         if (!isSimulatorDeviceBooted($simulatedDeviceUDID)) {
2862             print &quot;Launching iOS Simulator...\n&quot;;
2863             relaunchIOSSimulator($simulatedDevice);
2864         }
2865     } else {
2866         # FIXME: We should killall(1) any running instances of $appBundle before installing it to ensure
2867         #        that simctl launch opens the latest installed version of the app. For now we quit and
2868         #        launch the iOS Simulator again to ensure there are no running instances of $appBundle.
2869         print &quot;Quitting and launching iOS Simulator...\n&quot;;
2870         relaunchIOSSimulator($simulatedDevice);
2871 
2872         print &quot;Installing $appBundle.\n&quot;;
2873         # Install custom built app, overwriting an app with the same app identifier if one exists.
2874         exitStatus(system(&quot;xcrun&quot;, &quot;--sdk&quot;, &quot;iphonesimulator&quot;, &quot;simctl&quot;, &quot;install&quot;, $simulatedDeviceUDID, $appBundle)) == 0 or die;
2875 
2876     }
2877 
2878     $simulatorOptions = {} unless $simulatorOptions;
2879 
2880     my %simulatorENV;
2881     %simulatorENV = %{$simulatorOptions-&gt;{applicationEnvironment}} if $simulatorOptions-&gt;{applicationEnvironment};
2882     {
2883         local %ENV; # Shadow global-scope %ENV so that changes to it will not be seen outside of this scope.
2884         setupIOSWebKitEnvironment($productDir);
2885         %simulatorENV = %ENV;
2886     }
2887     my $applicationArguments = \@ARGV;
2888     $applicationArguments = $simulatorOptions-&gt;{applicationArguments} if $simulatorOptions &amp;&amp; $simulatorOptions-&gt;{applicationArguments};
2889 
2890     # Prefix the environment variables with SIMCTL_CHILD_ per `xcrun simctl help launch`.
2891     foreach my $key (keys %simulatorENV) {
2892         $ENV{&quot;SIMCTL_CHILD_$key&quot;} = $simulatorENV{$key};
2893     }
2894 
2895     print &quot;Starting $appDisplayName with DYLD_FRAMEWORK_PATH set to point to built WebKit in $productDir.\n&quot;;
2896     return exitStatus(system(&quot;xcrun&quot;, &quot;--sdk&quot;, &quot;iphonesimulator&quot;, &quot;simctl&quot;, &quot;launch&quot;, $simulatedDeviceUDID, $appIdentifier, @$applicationArguments));
2897 }
2898 
2899 sub runIOSWebKitApp($)
2900 {
2901     my ($appBundle) = @_;
2902     if (willUseIOSDeviceSDK()) {
2903         die &quot;Only running Safari in iOS Simulator is supported now.&quot;;
2904     }
2905     if (willUseIOSSimulatorSDK()) {
2906         return runIOSWebKitAppInSimulator($appBundle);
2907     }
2908     die &quot;Not using an iOS SDK.&quot;
2909 }
2910 
2911 sub archCommandLineArgumentsForRestrictedEnvironmentVariables()
2912 {
2913     my @arguments = ();
2914     foreach my $key (keys(%ENV)) {
2915         if ($key =~ /^DYLD_/) {
2916             push @arguments, &quot;-e&quot;, &quot;$key=$ENV{$key}&quot;;
2917         }
2918     }
2919     return @arguments;
2920 }
2921 
2922 sub runMacWebKitApp($;$)
2923 {
2924     my ($appPath, $useOpenCommand) = @_;
2925     my $productDir = productDir();
2926     print &quot;Starting @{[basename($appPath)]} with DYLD_FRAMEWORK_PATH set to point to built WebKit in $productDir.\n&quot;;
2927 
2928     local %ENV = %ENV;
2929     setupMacWebKitEnvironment($productDir);
2930 
2931     if (defined($useOpenCommand) &amp;&amp; $useOpenCommand == USE_OPEN_COMMAND) {
2932         return system(&quot;open&quot;, &quot;-W&quot;, &quot;-a&quot;, $appPath, &quot;--args&quot;, argumentsForRunAndDebugMacWebKitApp());
2933     }
2934     if (architecture()) {
2935         return system &quot;arch&quot;, &quot;-&quot; . architecture(), archCommandLineArgumentsForRestrictedEnvironmentVariables(), $appPath, argumentsForRunAndDebugMacWebKitApp();
2936     }
2937     return system { $appPath } $appPath, argumentsForRunAndDebugMacWebKitApp();
2938 }
2939 
2940 sub execMacWebKitAppForDebugging($)
2941 {
2942     my ($appPath) = @_;
2943     my $architectureSwitch = &quot;--arch&quot;;
2944     my $argumentsSeparator = &quot;--&quot;;
2945 
2946     my $debuggerPath = `xcrun -find lldb`;
2947     chomp $debuggerPath;
2948     die &quot;Can&#39;t find the lldb executable.\n&quot; unless -x $debuggerPath;
2949 
2950     my $productDir = productDir();
2951     setupMacWebKitEnvironment($productDir);
2952 
2953     my @architectureFlags = ($architectureSwitch, architecture());
2954     print &quot;Starting @{[basename($appPath)]} under lldb with DYLD_FRAMEWORK_PATH set to point to built WebKit in $productDir.\n&quot;;
2955     exec { $debuggerPath } $debuggerPath, @architectureFlags, $argumentsSeparator, $appPath, argumentsForRunAndDebugMacWebKitApp() or die;
2956 }
2957 
2958 sub execUnixAppForDebugging($)
2959 {
2960     my ($appPath) = @_;
2961 
2962     my $debuggerPath = `which gdb | head -1`;
2963     chomp $debuggerPath;
2964     die &quot;Can&#39;t find the gdb executable.\n&quot; unless -x $debuggerPath;
2965 
2966     my $productDir = productDir();
2967     setupUnixWebKitEnvironment($productDir);
2968 
2969     my @cmdline = wrapperPrefixIfNeeded();
2970     push @cmdline, $debuggerPath, &quot;--args&quot;, $appPath;
2971 
2972     print &quot;Starting @{[basename($appPath)]} under gdb with build WebKit in $productDir.\n&quot;;
2973     exec @cmdline, @ARGV or die;
2974 }
2975 
2976 sub debugSafari
2977 {
2978     if (isAppleMacWebKit()) {
2979         checkFrameworks();
2980         execMacWebKitAppForDebugging(safariPath());
2981     }
2982 
2983     return 1; # Unsupported platform; can&#39;t debug Safari on this platform.
2984 }
2985 
2986 sub runSafari
2987 {
2988     if (isIOSWebKit()) {
2989         return runIOSWebKitApp(mobileSafariBundle());
2990     }
2991 
2992     if (isAppleMacWebKit()) {
2993         return runMacWebKitApp(safariPath());
2994     }
2995 
2996     if (isAppleWinWebKit() || isFTW()) {
2997         my $result;
2998         my $webKitLauncherPath = File::Spec-&gt;catfile(executableProductDir(), &quot;MiniBrowser.exe&quot;);
2999         return system { $webKitLauncherPath } $webKitLauncherPath, @ARGV;
3000     }
3001 
3002     return 1; # Unsupported platform; can&#39;t run Safari on this platform.
3003 }
3004 
3005 sub runMiniBrowser
3006 {
3007     if (isAppleMacWebKit()) {
3008         return runMacWebKitApp(File::Spec-&gt;catfile(productDir(), &quot;MiniBrowser.app&quot;, &quot;Contents&quot;, &quot;MacOS&quot;, &quot;MiniBrowser&quot;));
3009     }
3010     if (isAppleWinWebKit() || isFTW()) {
3011         my $webKitLauncherPath = File::Spec-&gt;catfile(executableProductDir(), &quot;MiniBrowser.exe&quot;);
3012         return system { $webKitLauncherPath } $webKitLauncherPath, @ARGV;
3013     }
3014     return 1;
3015 }
3016 
3017 sub debugMiniBrowser
3018 {
3019     if (isAppleMacWebKit()) {
3020         execMacWebKitAppForDebugging(File::Spec-&gt;catfile(productDir(), &quot;MiniBrowser.app&quot;, &quot;Contents&quot;, &quot;MacOS&quot;, &quot;MiniBrowser&quot;));
3021     }
3022     
3023     return 1;
3024 }
3025 
3026 sub runWebKitTestRunner
3027 {
3028     if (isAppleMacWebKit()) {
3029         return runMacWebKitApp(File::Spec-&gt;catfile(productDir(), &quot;WebKitTestRunner&quot;));
3030     }
3031 
3032     return 1;
3033 }
3034 
3035 sub debugWebKitTestRunner
3036 {
3037     if (isAppleMacWebKit()) {
3038         execMacWebKitAppForDebugging(File::Spec-&gt;catfile(productDir(), &quot;WebKitTestRunner&quot;));
3039     } elsif (isGtk() or isWPE()) {
3040         execUnixAppForDebugging(File::Spec-&gt;catfile(productDir(), &quot;bin&quot;, &quot;WebKitTestRunner&quot;));
3041     }
3042 
3043     return 1;
3044 }
3045 
3046 sub readRegistryString
3047 {
3048     my ($valueName) = @_;
3049     chomp(my $string = `regtool --wow32 get &quot;$valueName&quot;`);
3050     return $string;
3051 }
3052 
3053 sub writeRegistryString
3054 {
3055     my ($valueName, $string) = @_;
3056 
3057     my $error = system &quot;regtool&quot;, &quot;--wow32&quot;, &quot;set&quot;, &quot;-s&quot;, $valueName, $string;
3058 
3059     # On Windows Vista/7 with UAC enabled, regtool will fail to modify the registry, but will still
3060     # return a successful exit code. So we double-check here that the value we tried to write to the
3061     # registry was really written.
3062     return !$error &amp;&amp; readRegistryString($valueName) eq $string;
3063 }
3064 
3065 sub formatBuildTime($)
3066 {
3067     my ($buildTime) = @_;
3068 
3069     my $buildHours = int($buildTime / 3600);
3070     my $buildMins = int(($buildTime - $buildHours * 3600) / 60);
3071     my $buildSecs = $buildTime - $buildHours * 3600 - $buildMins * 60;
3072 
3073     if ($buildHours) {
3074         return sprintf(&quot;%dh:%02dm:%02ds&quot;, $buildHours, $buildMins, $buildSecs);
3075     }
3076     return sprintf(&quot;%02dm:%02ds&quot;, $buildMins, $buildSecs);
3077 }
3078 
3079 sub runSvnUpdateAndResolveChangeLogs(@)
3080 {
3081     my @svnOptions = @_;
3082     my $openCommand = &quot;svn update &quot; . join(&quot; &quot;, @svnOptions);
3083     open my $update, &quot;$openCommand |&quot; or die &quot;cannot execute command $openCommand&quot;;
3084     my @conflictedChangeLogs;
3085     while (my $line = &lt;$update&gt;) {
3086         print $line;
3087         $line =~ m/^C\s+(.+?)[\r\n]*$/;
3088         if ($1) {
3089           my $filename = normalizePath($1);
3090           push @conflictedChangeLogs, $filename if basename($filename) eq &quot;ChangeLog&quot;;
3091         }
3092     }
3093     close $update or die;
3094 
3095     if (@conflictedChangeLogs) {
3096         print &quot;Attempting to merge conflicted ChangeLogs.\n&quot;;
3097         my $resolveChangeLogsPath = File::Spec-&gt;catfile(sourceDir(), &quot;Tools&quot;, &quot;Scripts&quot;, &quot;resolve-ChangeLogs&quot;);
3098         (system($resolveChangeLogsPath, &quot;--no-warnings&quot;, @conflictedChangeLogs) == 0)
3099             or die &quot;Could not open resolve-ChangeLogs script: $!.\n&quot;;
3100     }
3101 }
3102 
3103 sub runGitUpdate()
3104 {
3105     # Doing a git fetch first allows setups with svn-remote.svn.fetch = trunk:refs/remotes/origin/master
3106     # to perform the rebase much much faster.
3107     system(&quot;git&quot;, &quot;fetch&quot;);
3108     if (isGitSVNDirectory(&quot;.&quot;)) {
3109         system(&quot;git&quot;, &quot;svn&quot;, &quot;rebase&quot;) == 0 or die;
3110     } else {
3111         # This will die if branch.$BRANCHNAME.merge isn&#39;t set, which is
3112         # almost certainly what we want.
3113         system(&quot;git&quot;, &quot;pull&quot;) == 0 or die;
3114     }
3115 }
3116 
3117 1;
    </pre>
  </body>
</html>
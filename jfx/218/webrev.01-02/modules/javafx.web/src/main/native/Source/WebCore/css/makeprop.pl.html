<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/css/makeprop.pl</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 #! /usr/bin/env perl
   2 #
   3 #   This file is part of the WebKit project
   4 #
   5 #   Copyright (C) 1999 Waldo Bastian (bastian@kde.org)
   6 #   Copyright (C) 2007-2018 Apple Inc. All rights reserved.
   7 #   Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
   8 #   Copyright (C) 2010 Andras Becsi (abecsi@inf.u-szeged.hu), University of Szeged
   9 #   Copyright (C) 2013 Google Inc. All rights reserved.
  10 #
  11 #   This library is free software; you can redistribute it and/or
  12 #   modify it under the terms of the GNU Library General Public
  13 #   License as published by the Free Software Foundation; either
  14 #   version 2 of the License, or (at your option) any later version.
  15 #
  16 #   This library is distributed in the hope that it will be useful,
  17 #   but WITHOUT ANY WARRANTY; without even the implied warranty of
  18 #   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  19 #   Library General Public License for more details.
  20 #
  21 #   You should have received a copy of the GNU Library General Public License
  22 #   along with this library; see the file COPYING.LIB.  If not, write to
  23 #   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  24 #   Boston, MA 02110-1301, USA.
  25 
  26 use strict;
  27 use warnings;
  28 
  29 use English;
  30 use File::Spec;
  31 use Getopt::Long;
  32 use JSON::PP;
  33 
  34 sub addProperty($$);
  35 sub isPropertyEnabled($$);
  36 sub removeInactiveCodegenProperties($$);
  37 
  38 my $inputFile = &quot;CSSProperties.json&quot;;
  39 
  40 my $defines = &quot;&quot;;
  41 my $gperf;
  42 GetOptions(&#39;defines=s&#39; =&gt; \$defines,
  43            &#39;gperf-executable=s&#39; =&gt; \$gperf);
  44 
  45 my $input;
  46 {
  47     local $INPUT_RECORD_SEPARATOR; # No separator; read through until end-of-file.
  48     open(JSON, &quot;&lt;&quot;, $inputFile) or die &quot;Cannot open $inputFile.\n&quot;;
  49     $input = &lt;JSON&gt;;
  50     close(JSON);
  51 }
  52 
  53 my $jsonDecoder = JSON::PP-&gt;new-&gt;utf8;
  54 my $jsonHashRef = $jsonDecoder-&gt;decode($input);
  55 my $propertiesHashRef = $jsonHashRef-&gt;{properties};
  56 my @allNames = keys(%$propertiesHashRef);
  57 die &quot;We&#39;ve reached more than 1024 CSS properties, please make sure to update CSSProperty/StylePropertyMetadata accordingly&quot; if @allNames &gt; 1024;
  58 
  59 my %defines = map { $_ =&gt; 1 } split(/ /, $defines);
  60 
  61 my @names;
  62 my @internalProprerties;
  63 my %runtimeFlags;
  64 my $numPredefinedProperties = 2;
  65 my %nameIsInherited;
  66 my %nameIsHighPriority;
  67 my %propertiesWithStyleBuilderOptions;
  68 my %styleBuilderOptions = (
  69     &quot;animatable&quot; =&gt; 1, # Defined in Source/WebCore/style/StyleBuilderConverter.h
  70     &quot;auto-functions&quot; =&gt; 1,
  71     &quot;conditional-converter&quot; =&gt; 1,
  72     &quot;converter&quot; =&gt; 1,
  73     &quot;custom&quot; =&gt; 1,
  74     &quot;fill-layer-property&quot; =&gt; 1,
  75     &quot;font-property&quot; =&gt; 1,
  76     &quot;getter&quot; =&gt; 1,
  77     &quot;initial&quot; =&gt; 1,
  78     &quot;longhands&quot; =&gt; 1,
  79     &quot;name-for-methods&quot; =&gt; 1,
  80     &quot;no-default-color&quot; =&gt; 1,
  81     &quot;svg&quot; =&gt; 1,
  82     &quot;skip-builder&quot; =&gt; 1,
  83     &quot;setter&quot; =&gt; 1,
  84     &quot;visited-link-color-support&quot; =&gt; 1,
  85 );
  86 my %nameToId;
  87 my %nameToAliases;
  88 
  89 for my $name (@allNames) {
  90     my $value = $propertiesHashRef-&gt;{$name};
  91     my $valueType = ref($value);
  92     
  93     if ($valueType eq &quot;HASH&quot;) {
  94         removeInactiveCodegenProperties($name, \%$value);
  95         if (isPropertyEnabled($name, $value)) {
  96             addProperty($name, $value);
  97         }
  98     } else {
  99         die &quot;$name does not have a supported value type. Only dictionary types are supported.&quot;;
 100     }
 101 }
 102 
 103 sub matchEnableFlags($)
 104 {
 105     my ($enable_flag) = @_;
 106     
 107     if (exists($defines{$enable_flag})) {
 108         return 1;
 109     }
 110 
 111     if (substr($enable_flag, 0, 1) eq &quot;!&quot; &amp;&amp; !exists($defines{substr($enable_flag, 1)})) {
 112         return 1;
 113     }
 114     
 115     return 0;
 116 }
 117 
 118 sub removeInactiveCodegenProperties($$)
 119 {
 120     my ($name, $propertyValue) = @_;
 121 
 122     if (!exists($propertyValue-&gt;{&quot;codegen-properties&quot;})) {
 123         return;
 124     }
 125     
 126     my $codegen_properties = $propertyValue-&gt;{&quot;codegen-properties&quot;};
 127     my $valueType = ref($codegen_properties);
 128 
 129     if ($valueType ne &quot;ARRAY&quot;) {
 130         return;
 131     }
 132 
 133     # Pick one based on &quot;enable-if&quot;
 134     my $matching_codegen_options;
 135     foreach my $entry (@{$codegen_properties}) {
 136         if (!exists($entry-&gt;{&quot;enable-if&quot;})) {
 137             print &quot;Found &#39;codegen-properties&#39; array with an unconditional entry under &#39;$name&#39;. This is probably unintentional.\n&quot;;
 138             $matching_codegen_options = $entry;
 139             last;
 140         }
 141 
 142         my $enable_flags = $entry-&gt;{&quot;enable-if&quot;};
 143         if (matchEnableFlags($enable_flags)) {
 144             $matching_codegen_options = $entry;
 145             last;
 146         }
 147 
 148         $matching_codegen_options = $entry;
 149     }
 150     
 151     $propertyValue-&gt;{&quot;codegen-properties&quot;} = $matching_codegen_options;
 152 }
 153 
 154 sub isPropertyEnabled($$)
 155 {
 156     my ($name, $propertyValue) = @_;
 157 
 158     if (!exists($propertyValue-&gt;{&quot;codegen-properties&quot;})) {
 159         return 1;
 160     }
 161     
 162     my $codegen_properties = $propertyValue-&gt;{&quot;codegen-properties&quot;};
 163     if ($codegen_properties-&gt;{&quot;skip-codegen&quot;}) {
 164         return 0;
 165     }
 166 
 167     if (!exists($codegen_properties-&gt;{&quot;enable-if&quot;})) {
 168         return 1;
 169     }
 170 
 171     return matchEnableFlags($codegen_properties-&gt;{&quot;enable-if&quot;});
 172 }
 173 
 174 sub addProperty($$)
 175 {
 176     my ($name, $optionsHashRef) = @_;
 177 
 178     push @names, $name;
 179 
 180     my $id = $name;
 181     $id =~ s/(^[^-])|-(.)/uc($1||$2)/ge;
 182     $nameToId{$name} = $id;
 183 
 184     for my $optionName (keys %{$optionsHashRef}) {
 185         if ($optionName eq &quot;codegen-properties&quot;) {
 186             my $codegenProperties = $optionsHashRef-&gt;{&quot;codegen-properties&quot;};
 187             for my $codegenOptionName (keys %$codegenProperties) {
 188                 if ($codegenOptionName eq &quot;enable-if&quot;) {
 189                     next;
 190                 } elsif ($codegenOptionName eq &quot;skip-codegen&quot;) {
 191                     next;
 192                 } elsif ($codegenOptionName eq &quot;comment&quot;) {
 193                     next;
 194                 } elsif ($codegenOptionName eq &quot;high-priority&quot;) {
 195                     $nameIsHighPriority{$name} = 1;
 196                 } elsif ($codegenOptionName eq &quot;aliases&quot;) {
 197                     $nameToAliases{$name} = $codegenProperties-&gt;{&quot;aliases&quot;};
 198                 } elsif ($styleBuilderOptions{$codegenOptionName}) {
 199                     $propertiesWithStyleBuilderOptions{$name}{$codegenOptionName} = $codegenProperties-&gt;{$codegenOptionName};
 200                 } elsif ($codegenOptionName eq &quot;internal-only&quot;) {
 201                     # internal-only properties exist to make it easier to parse compound properties (e.g. background-repeat) as if they were shorthands.
 202                     push @internalProprerties, $name
 203                 } elsif ($codegenOptionName eq &quot;runtime-flag&quot;) {
 204                     $runtimeFlags{$name} = $codegenProperties-&gt;{&quot;runtime-flag&quot;};
 205                 } else {
 206                     die &quot;Unrecognized codegen property \&quot;$codegenOptionName\&quot; for $name property.&quot;;
 207                 }
 208             }
 209         } elsif ($optionName eq &quot;animatable&quot;) {
 210              $propertiesWithStyleBuilderOptions{$name}{&quot;animatable&quot;} = $optionsHashRef-&gt;{&quot;animatable&quot;};
 211         } elsif ($optionName eq &quot;inherited&quot;) {
 212             $nameIsInherited{$name} = 1;
 213         } elsif ($optionName eq &quot;values&quot;) {
 214             # FIXME: Implement.
 215         }
 216         # We allow unrecognized options to pass through without error to support annotation.
 217     }
 218 }
 219 
 220 sub sortByDescendingPriorityAndName
 221 {
 222     # Sort names with high priority to the front
 223     if (!!$nameIsHighPriority{$a} &lt; !!$nameIsHighPriority{$b}) {
 224         return 1;
 225     }
 226     if (!!$nameIsHighPriority{$a} &gt; !!$nameIsHighPriority{$b}) {
 227         return -1;
 228     }
 229     # Sort names without leading &#39;-&#39; to the front
 230     if (substr($a, 0, 1) eq &quot;-&quot; &amp;&amp; substr($b, 0, 1) ne &quot;-&quot;) {
 231         return 1;
 232     }
 233     if (substr($a, 0, 1) ne &quot;-&quot; &amp;&amp; substr($b, 0, 1) eq &quot;-&quot;) {
 234         return -1;
 235     }
 236     return $a cmp $b;
 237 }
 238 
 239 @names = sort sortByDescendingPriorityAndName @names;
 240 
 241 open GPERF, &quot;&gt;CSSPropertyNames.gperf&quot; || die &quot;Could not open CSSPropertyNames.gperf for writing&quot;;
 242 print GPERF &lt;&lt; &quot;EOF&quot;;
 243 %{
 244 /* This file is automatically generated from $inputFile by makeprop, do not edit */
 245 #include &quot;config.h&quot;
 246 #include \&quot;CSSProperty.h\&quot;
 247 #include \&quot;CSSPropertyNames.h\&quot;
 248 #include \&quot;HashTools.h\&quot;
 249 #include &quot;RuntimeEnabledFeatures.h&quot;
 250 #include &lt;wtf/ASCIICType.h&gt;
 251 #include &lt;wtf/text/AtomString.h&gt;
 252 #include &lt;wtf/text/WTFString.h&gt;
 253 #include &lt;string.h&gt;
 254 
 255 IGNORE_WARNINGS_BEGIN(\&quot;implicit-fallthrough\&quot;)
 256 
 257 // Older versions of gperf like to use the `register` keyword.
 258 #define register
 259 
 260 namespace WebCore {
 261 
 262 // Using std::numeric_limits&lt;uint16_t&gt;::max() here would be cleaner,
 263 // but is not possible due to missing constexpr support in MSVC 2013.
 264 static_assert(numCSSProperties + 1 &lt;= 65535, &quot;CSSPropertyID should fit into uint16_t.&quot;);
 265 
 266 EOF
 267 
 268 print GPERF &quot;const char* const propertyNameStrings[numCSSProperties] = {\n&quot;;
 269 foreach my $name (@names) {
 270   print GPERF &quot;    \&quot;$name\&quot;,\n&quot;;
 271 }
 272 print GPERF &quot;};\n\n&quot;;
 273 
 274 print GPERF &lt;&lt; &quot;EOF&quot;;
 275 %}
 276 %struct-type
 277 struct Property;
 278 %omit-struct-type
 279 %language=C++
 280 %readonly-tables
 281 %global-table
 282 %compare-strncmp
 283 %define class-name CSSPropertyNamesHash
 284 %define lookup-function-name findPropertyImpl
 285 %define hash-function-name propery_hash_function
 286 %define word-array-name property_wordlist
 287 %enum
 288 %%
 289 EOF
 290 
 291 foreach my $name (@names) {
 292   print GPERF $name . &quot;, CSSProperty&quot; . $nameToId{$name} . &quot;\n&quot;;
 293 }
 294 
 295 for my $name (@names) {
 296     if (!$nameToAliases{$name}) {
 297         next;
 298     }
 299     for my $alias (@{$nameToAliases{$name}}) {
 300         print GPERF $alias . &quot;, CSSProperty&quot; . $nameToId{$name} . &quot;\n&quot;;
 301     }
 302 }
 303 
 304 print GPERF &lt;&lt; &quot;EOF&quot;;
 305 %%
 306 const Property* findProperty(const char* str, unsigned int len)
 307 {
 308     return CSSPropertyNamesHash::findPropertyImpl(str, len);
 309 }
 310 
 311 bool isInternalCSSProperty(const CSSPropertyID id)
 312 {
 313     switch (id) {
 314 EOF
 315 
 316 foreach my $name (sort @internalProprerties) {
 317   print GPERF &quot;    case CSSPropertyID::CSSProperty&quot; . $nameToId{$name} . &quot;:\n&quot;;
 318 }
 319 
 320 print GPERF &lt;&lt; &quot;EOF&quot;;
 321         return true;
 322     default:
 323         return false;
 324     }
 325 }
 326 
 327 bool isEnabledCSSProperty(const CSSPropertyID id)
 328 {
 329     switch (id) {
 330 EOF
 331 
 332 foreach my $name (keys %runtimeFlags) {
 333   print GPERF &quot;    case CSSPropertyID::CSSProperty&quot; . $nameToId{$name} . &quot;:\n&quot;;
 334   print GPERF &quot;        return RuntimeEnabledFeatures::sharedFeatures().&quot; . $runtimeFlags{$name} . &quot;Enabled();\n&quot;;
 335 }
 336 
 337 print GPERF &lt;&lt; &quot;EOF&quot;;
 338     default:
 339         return true;
 340     }
 341 }
 342 
 343 const char* getPropertyName(CSSPropertyID id)
 344 {
 345     if (id &lt; firstCSSProperty)
 346         return 0;
 347     int index = id - firstCSSProperty;
 348     if (index &gt;= numCSSProperties)
 349         return 0;
 350     return propertyNameStrings[index];
 351 }
 352 
 353 const AtomString&amp; getPropertyNameAtomString(CSSPropertyID id)
 354 {
 355     if (id &lt; firstCSSProperty)
 356         return nullAtom();
 357     int index = id - firstCSSProperty;
 358     if (index &gt;= numCSSProperties)
 359         return nullAtom();
 360 
 361     static AtomString* propertyStrings = new AtomString[numCSSProperties]; // Intentionally never destroyed.
 362     AtomString&amp; propertyString = propertyStrings[index];
 363     if (propertyString.isNull()) {
 364         const char* propertyName = propertyNameStrings[index];
 365         propertyString = AtomString(propertyName, strlen(propertyName), AtomString::ConstructFromLiteral);
 366     }
 367     return propertyString;
 368 }
 369 
 370 String getPropertyNameString(CSSPropertyID id)
 371 {
 372     // We share the StringImpl with the AtomStrings.
 373     return getPropertyNameAtomString(id).string();
 374 }
 375 
 376 String getJSPropertyName(CSSPropertyID id)
 377 {
 378     char result[maxCSSPropertyNameLength + 1];
 379     const char* cssPropertyName = getPropertyName(id);
 380     const char* propertyNamePointer = cssPropertyName;
 381     if (!propertyNamePointer)
 382         return emptyString();
 383 
 384     char* resultPointer = result;
 385     while (char character = *propertyNamePointer++) {
 386         if (character == &#39;-&#39;) {
 387             char nextCharacter = *propertyNamePointer++;
 388             if (!nextCharacter)
 389                 break;
 390             character = (propertyNamePointer - 2 != cssPropertyName) ? toASCIIUpper(nextCharacter) : nextCharacter;
 391         }
 392         *resultPointer++ = character;
 393     }
 394     *resultPointer = &#39;\\0&#39;;
 395     return WTF::String(result);
 396 }
 397 
 398 static const bool isInheritedPropertyTable[numCSSProperties + $numPredefinedProperties] = {
 399     false, // CSSPropertyInvalid
 400     true, // CSSPropertyCustom
 401 EOF
 402 
 403 foreach my $name (@names) {
 404   my $id = $nameToId{$name};
 405   my $value = $nameIsInherited{$name} ? &quot;true &quot; : &quot;false&quot;;
 406   print GPERF &quot;    $value, // CSSProperty$id\n&quot;;
 407 }
 408 
 409 print GPERF&lt;&lt; &quot;EOF&quot;;
 410 };
 411 
 412 bool CSSProperty::isInheritedProperty(CSSPropertyID id)
 413 {
 414     ASSERT(id &lt;= lastCSSProperty);
 415     ASSERT(id != CSSPropertyInvalid);
 416     return isInheritedPropertyTable[id];
 417 }
 418 
 419 Vector&lt;String&gt; CSSProperty::aliasesForProperty(CSSPropertyID id)
 420 {
 421     switch (id) {
 422 EOF
 423 
 424 for my $name (@names) {
 425     if (!$nameToAliases{$name}) {
 426         next;
 427     }
 428     print GPERF &quot;    case CSSPropertyID::CSSProperty&quot; . $nameToId{$name} . &quot;:\n&quot;;
 429     print GPERF &quot;        return { \&quot;&quot; . join(&quot;\&quot;_s, \&quot;&quot;, @{$nameToAliases{$name}}) . &quot;\&quot;_s };\n&quot;;
 430 }
 431 
 432 print GPERF &lt;&lt; &quot;EOF&quot;;
 433     default:
 434         return { };
 435     }
 436 }
 437 
 438 } // namespace WebCore
 439 
 440 IGNORE_WARNINGS_END
 441 EOF
 442 
 443 close GPERF;
 444 
 445 open HEADER, &quot;&gt;CSSPropertyNames.h&quot; || die &quot;Could not open CSSPropertyNames.h for writing&quot;;
 446 print HEADER &lt;&lt; &quot;EOF&quot;;
 447 /* This file is automatically generated from $inputFile by makeprop, do not edit */
 448 
 449 #pragma once
 450 
 451 #include &lt;string.h&gt;
 452 #include &lt;wtf/Forward.h&gt;
 453 #include &lt;wtf/HashFunctions.h&gt;
 454 #include &lt;wtf/HashTraits.h&gt;
 455 
 456 namespace WebCore {
 457 
 458 enum CSSPropertyID : uint16_t {
 459     CSSPropertyInvalid = 0,
 460     CSSPropertyCustom = 1,
 461 EOF
 462 
 463 my $first = $numPredefinedProperties;
 464 my $i = $numPredefinedProperties;
 465 my $maxLen = 0;
 466 my $lastHighPriorityPropertyName;
 467 foreach my $name (@names) {
 468   $lastHighPriorityPropertyName = $name if $nameIsHighPriority{$name}; # Assumes that @names is sorted by descending priorities.
 469   print HEADER &quot;    CSSProperty&quot; . $nameToId{$name} . &quot; = &quot; . $i . &quot;,\n&quot;;
 470   $i = $i + 1;
 471   if (length($name) &gt; $maxLen) {
 472     $maxLen = length($name);
 473   }
 474 }
 475 my $num = $i - $first;
 476 my $last = $i - 1;
 477 
 478 print HEADER &quot;};\n\n&quot;;
 479 print HEADER &quot;const int firstCSSProperty = $first;\n&quot;;
 480 print HEADER &quot;const int numCSSProperties = $num;\n&quot;;
 481 print HEADER &quot;const int lastCSSProperty = $last;\n&quot;;
 482 print HEADER &quot;const size_t maxCSSPropertyNameLength = $maxLen;\n&quot;;
 483 print HEADER &quot;const CSSPropertyID lastHighPriorityProperty = CSSProperty&quot; . $nameToId{$lastHighPriorityPropertyName} . &quot;;\n\n&quot;;
 484 
 485 print HEADER &quot;static const CSSPropertyID computedPropertyIDs[] = {\n&quot;;
 486 my $numComputedPropertyIDs = 0;
 487 sub sortWithPrefixedPropertiesLast
 488 {
 489     my $aStartsWithPrefix = substr($a, 0, 1) eq &quot;-&quot;;
 490     my $bStartsWithPrefix = substr($b, 0, 1) eq &quot;-&quot;;
 491     if ($aStartsWithPrefix &amp;&amp; !$bStartsWithPrefix) {
 492         return 1;
 493     }
 494     if (!$aStartsWithPrefix &amp;&amp; $bStartsWithPrefix) {
 495         return -1;
 496     }
 497     return $a cmp $b;
 498 }
 499 foreach my $name (sort sortWithPrefixedPropertiesLast @names) {
 500   next if (exists($propertiesWithStyleBuilderOptions{$name}{&quot;skip-builder&quot;}));
 501   next if (grep { $_ eq $name } @internalProprerties);
 502 
 503   # Skip properties if they have a non-internal longhand property.
 504   if (exists($propertiesWithStyleBuilderOptions{$name}{&quot;longhands&quot;})) {
 505     my @longhands = @{$propertiesWithStyleBuilderOptions{$name}{&quot;longhands&quot;}};
 506     if (scalar @longhands != 1) {
 507       my $hasNonInternalLonghand = 0;
 508       foreach my $longhand (@longhands) {
 509         if (!exists($propertiesWithStyleBuilderOptions{$longhand}{&quot;skip-builder&quot;}) &amp;&amp; !grep { $_ eq $longhand } @internalProprerties) {
 510           $hasNonInternalLonghand = 1;
 511           last;
 512         }
 513       }
 514       if ($hasNonInternalLonghand) {
 515         next;
 516       }
 517     }
 518   }
 519 
 520   print HEADER &quot;    CSSProperty&quot; . $nameToId{$name} . &quot;,\n&quot;;
 521   $numComputedPropertyIDs += 1;
 522 }
 523 print HEADER &quot;};\n&quot;;
 524 print HEADER &quot;const size_t numComputedPropertyIDs = $numComputedPropertyIDs;\n&quot;;
 525 
 526 print HEADER &lt;&lt; &quot;EOF&quot;;
 527 
 528 bool isInternalCSSProperty(const CSSPropertyID);
 529 bool isEnabledCSSProperty(const CSSPropertyID);
 530 const char* getPropertyName(CSSPropertyID);
 531 const WTF::AtomString&amp; getPropertyNameAtomString(CSSPropertyID id);
 532 WTF::String getPropertyNameString(CSSPropertyID id);
 533 WTF::String getJSPropertyName(CSSPropertyID);
 534 
 535 inline CSSPropertyID convertToCSSPropertyID(int value)
 536 {
 537     ASSERT((value &gt;= firstCSSProperty &amp;&amp; value &lt;= lastCSSProperty) || value == CSSPropertyInvalid || value == CSSPropertyCustom);
 538     return static_cast&lt;CSSPropertyID&gt;(value);
 539 }
 540 
 541 } // namespace WebCore
 542 
 543 namespace WTF {
 544 template&lt;&gt; struct DefaultHash&lt;WebCore::CSSPropertyID&gt; { typedef IntHash&lt;unsigned&gt; Hash; };
 545 template&lt;&gt; struct HashTraits&lt;WebCore::CSSPropertyID&gt; : GenericHashTraits&lt;WebCore::CSSPropertyID&gt; {
 546     static const bool emptyValueIsZero = true;
 547     static void constructDeletedValue(WebCore::CSSPropertyID&amp; slot) { slot = static_cast&lt;WebCore::CSSPropertyID&gt;(WebCore::lastCSSProperty + 1); }
 548     static bool isDeletedValue(WebCore::CSSPropertyID value) { return value == (WebCore::lastCSSProperty + 1); }
 549 };
 550 } // namespace WTF
 551 
 552 EOF
 553 
 554 close HEADER;
 555 
 556 #
 557 # StyleBuilderGenerated.cpp generator.
 558 #
 559 
 560 sub getScopeForFunction {
 561   my $name = shift;
 562   my $builderFunction = shift;
 563 
 564   return $propertiesWithStyleBuilderOptions{$name}{&quot;custom&quot;}{$builderFunction} ? &quot;BuilderCustom&quot; : &quot;BuilderFunctions&quot;;
 565 }
 566 
 567 sub getNameForMethods {
 568   my $name = shift;
 569 
 570   my $nameForMethods = $nameToId{$name};
 571   $nameForMethods =~ s/Webkit//g;
 572   if (exists($propertiesWithStyleBuilderOptions{$name}{&quot;name-for-methods&quot;})) {
 573     $nameForMethods = $propertiesWithStyleBuilderOptions{$name}{&quot;name-for-methods&quot;};
 574   }
 575   return $nameForMethods;
 576 }
 577 
 578 sub getAutoGetter {
 579   my $name = shift;
 580   my $renderStyle = shift;
 581 
 582   return $renderStyle . &quot;.hasAuto&quot; . getNameForMethods($name) . &quot;()&quot;;
 583 }
 584 
 585 sub getAutoSetter {
 586   my $name = shift;
 587   my $renderStyle = shift;
 588 
 589   return $renderStyle . &quot;.setHasAuto&quot; . getNameForMethods($name) . &quot;()&quot;;
 590 }
 591 
 592 sub getVisitedLinkSetter {
 593   my $name = shift;
 594   my $renderStyle = shift;
 595 
 596   return $renderStyle . &quot;.setVisitedLink&quot; . getNameForMethods($name);
 597 }
 598 
 599 sub getClearFunction {
 600   my $name = shift;
 601 
 602   return &quot;clear&quot; . getNameForMethods($name);
 603 }
 604 
 605 sub getEnsureAnimationsOrTransitionsMethod {
 606   my $name = shift;
 607 
 608   return &quot;ensureAnimations&quot; if $name =~ /animation-/;
 609   return &quot;ensureTransitions&quot; if $name =~ /transition-/;
 610   die &quot;Unrecognized animation property name.&quot;;
 611 }
 612 
 613 sub getAnimationsOrTransitionsMethod {
 614   my $name = shift;
 615 
 616   return &quot;animations&quot; if $name =~ /animation-/;
 617   return &quot;transitions&quot; if $name =~ /transition-/;
 618   die &quot;Unrecognized animation property name.&quot;;
 619 }
 620 
 621 sub getTestFunction {
 622   my $name = shift;
 623 
 624   return &quot;is&quot; . getNameForMethods($name) . &quot;Set&quot;;
 625 }
 626 
 627 sub getAnimationMapfunction {
 628   my $name = shift;
 629 
 630   return &quot;mapAnimation&quot; . getNameForMethods($name);
 631 }
 632 
 633 sub getLayersFunction {
 634   my $name = shift;
 635 
 636   return &quot;backgroundLayers&quot; if $name =~ /background-/;
 637   return &quot;maskLayers&quot; if $name =~ /mask-/;
 638   die &quot;Unrecognized FillLayer property name.&quot;;
 639 }
 640 
 641 sub getLayersAccessorFunction {
 642   my $name = shift;
 643 
 644   return &quot;ensureBackgroundLayers&quot; if $name =~ /background-/;
 645   return &quot;ensureMaskLayers&quot; if $name =~ /mask-/;
 646   die &quot;Unrecognized FillLayer property name.&quot;;
 647 }
 648 
 649 sub getFillLayerType {
 650 my $name = shift;
 651 
 652   return &quot;FillLayerType::Background&quot; if $name =~ /background-/;
 653   return &quot;FillLayerType::Mask&quot; if $name =~ /mask-/;
 654 }
 655 
 656 sub getFillLayerMapfunction {
 657   my $name = shift;
 658 
 659   return &quot;mapFill&quot; . getNameForMethods($name);
 660 }
 661 
 662 
 663 foreach my $name (@names) {
 664   my $nameForMethods = getNameForMethods($name);
 665   $nameForMethods =~ s/Webkit//g;
 666   if (exists($propertiesWithStyleBuilderOptions{$name}{&quot;name-for-methods&quot;})) {
 667     $nameForMethods = $propertiesWithStyleBuilderOptions{$name}{&quot;name-for-methods&quot;};
 668   }
 669 
 670   if (!exists($propertiesWithStyleBuilderOptions{$name}{&quot;getter&quot;})) {
 671     $propertiesWithStyleBuilderOptions{$name}{&quot;getter&quot;} = lcfirst($nameForMethods);
 672   }
 673   if (!exists($propertiesWithStyleBuilderOptions{$name}{&quot;setter&quot;})) {
 674     $propertiesWithStyleBuilderOptions{$name}{&quot;setter&quot;} = &quot;set&quot; . $nameForMethods;
 675   }
 676   if (!exists($propertiesWithStyleBuilderOptions{$name}{&quot;initial&quot;})) {
 677     if (exists($propertiesWithStyleBuilderOptions{$name}{&quot;fill-layer-property&quot;})) {
 678       $propertiesWithStyleBuilderOptions{$name}{&quot;initial&quot;} = &quot;initialFill&quot; . $nameForMethods;
 679     } else {
 680       $propertiesWithStyleBuilderOptions{$name}{&quot;initial&quot;} = &quot;initial&quot; . $nameForMethods;
 681     }
 682   }
 683   # FIXME: Convert option custom from a string to an array.
 684   if (!exists($propertiesWithStyleBuilderOptions{$name}{&quot;custom&quot;})) {
 685     $propertiesWithStyleBuilderOptions{$name}{&quot;custom&quot;} = &quot;&quot;;
 686   } elsif ($propertiesWithStyleBuilderOptions{$name}{&quot;custom&quot;} eq &quot;All&quot;) {
 687     $propertiesWithStyleBuilderOptions{$name}{&quot;custom&quot;} = &quot;Initial|Inherit|Value&quot;;
 688   }
 689   my %customValues = map { $_ =&gt; 1 } split(/\|/, $propertiesWithStyleBuilderOptions{$name}{&quot;custom&quot;});
 690   $propertiesWithStyleBuilderOptions{$name}{&quot;custom&quot;} = \%customValues;
 691 }
 692 
 693 use constant {
 694   NOT_FOR_VISITED_LINK =&gt; 0,
 695   FOR_VISITED_LINK =&gt; 1,
 696 };
 697 
 698 sub colorFromPrimitiveValue {
 699   my $primitiveValue = shift;
 700   my $forVisitedLink = @_ ? shift : NOT_FOR_VISITED_LINK;
 701 
 702   return &quot;builderState.colorFromPrimitiveValue(&quot; . $primitiveValue . &quot;, /* forVisitedLink */ &quot; . ($forVisitedLink ? &quot;true&quot; : &quot;false&quot;) . &quot;)&quot;;
 703 }
 704 
 705 use constant {
 706   VALUE_IS_COLOR =&gt; 0,
 707   VALUE_IS_PRIMITIVE =&gt; 1,
 708 };
 709 
 710 sub generateColorValueSetter {
 711   my $name = shift;
 712   my $value = shift;
 713   my $indent = shift;
 714   my $valueIsPrimitive = @_ ? shift : VALUE_IS_COLOR;
 715 
 716   my $style = &quot;builderState.style()&quot;;
 717   my $setterContent .= $indent . &quot;if (builderState.applyPropertyToRegularStyle())\n&quot;;
 718   my $setValue = $style . &quot;.&quot; . $propertiesWithStyleBuilderOptions{$name}{&quot;setter&quot;};
 719   my $color = $valueIsPrimitive ? colorFromPrimitiveValue($value) : $value;
 720   $setterContent .= $indent . &quot;    &quot; . $setValue . &quot;(&quot; . $color . &quot;);\n&quot;;
 721   $setterContent .= $indent . &quot;if (builderState.applyPropertyToVisitedLinkStyle())\n&quot;;
 722   $color = $valueIsPrimitive ? colorFromPrimitiveValue($value, FOR_VISITED_LINK) : $value;
 723   $setterContent .= $indent . &quot;    &quot; . getVisitedLinkSetter($name, $style) . &quot;(&quot; . $color . &quot;);\n&quot;;
 724 
 725   return $setterContent;
 726 }
 727 
 728 sub handleCurrentColorValue {
 729   my $name = shift;
 730   my $primitiveValue = shift;
 731   my $indent = shift;
 732 
 733   my $code = $indent . &quot;if (&quot; . $primitiveValue . &quot;.valueID() == CSSValueCurrentcolor) {\n&quot;;
 734   $code .= $indent . &quot;    applyInherit&quot; . $nameToId{$name} . &quot;(builderState);\n&quot;;
 735   $code .= $indent . &quot;    return;\n&quot;;
 736   $code .= $indent . &quot;}\n&quot;;
 737   return $code;
 738 }
 739 
 740 sub generateAnimationPropertyInitialValueSetter {
 741   my $name = shift;
 742   my $indent = shift;
 743 
 744   my $setterContent = &quot;&quot;;
 745   $setterContent .= $indent . &quot;AnimationList&amp; list = builderState.style().&quot; . getEnsureAnimationsOrTransitionsMethod($name) . &quot;();\n&quot;;
 746   $setterContent .= $indent . &quot;if (list.isEmpty())\n&quot;;
 747   $setterContent .= $indent . &quot;    list.append(Animation::create());\n&quot;;
 748   my $setter = $propertiesWithStyleBuilderOptions{$name}{&quot;setter&quot;};
 749   my $initial = $propertiesWithStyleBuilderOptions{$name}{&quot;initial&quot;};
 750   $setterContent .= $indent . &quot;list.animation(0).&quot; . $setter . &quot;(Animation::&quot; . $initial . &quot;());\n&quot;;
 751   if ($name eq &quot;-webkit-transition-property&quot;) {
 752     $setterContent .= $indent . &quot;list.animation(0).setAnimationMode(Animation::AnimateAll);\n&quot;;
 753   }
 754   $setterContent .= $indent . &quot;for (size_t i = 1; i &lt; list.size(); ++i)\n&quot;;
 755   $setterContent .= $indent . &quot;    list.animation(i).&quot; . getClearFunction($name) . &quot;();\n&quot;;
 756 
 757   return $setterContent;
 758 }
 759 
 760 sub generateAnimationPropertyInheritValueSetter {
 761   my $name = shift;
 762   my $indent = shift;
 763 
 764   my $setterContent = &quot;&quot;;
 765   $setterContent .= $indent . &quot;auto&amp; list = builderState.style().&quot; . getEnsureAnimationsOrTransitionsMethod($name) . &quot;();\n&quot;;
 766   $setterContent .= $indent . &quot;auto* parentList = builderState.parentStyle().&quot; . getAnimationsOrTransitionsMethod($name) . &quot;();\n&quot;;
 767   $setterContent .= $indent . &quot;size_t i = 0, parentSize = parentList ? parentList-&gt;size() : 0;\n&quot;;
 768   $setterContent .= $indent . &quot;for ( ; i &lt; parentSize &amp;&amp; parentList-&gt;animation(i).&quot; . getTestFunction($name) . &quot;(); ++i) {\n&quot;;
 769   $setterContent .= $indent . &quot;    if (list.size() &lt;= i)\n&quot;;
 770   $setterContent .= $indent . &quot;        list.append(Animation::create());\n&quot;;
 771   my $getter = $propertiesWithStyleBuilderOptions{$name}{&quot;getter&quot;};
 772   my $setter = $propertiesWithStyleBuilderOptions{$name}{&quot;setter&quot;};
 773   $setterContent .= $indent . &quot;    list.animation(i).&quot; . $setter . &quot;(parentList-&gt;animation(i).&quot; . $getter . &quot;());\n&quot;;
 774   $setterContent .= $indent . &quot;    list.animation(i).setAnimationMode(parentList-&gt;animation(i).animationMode());\n&quot;;
 775   $setterContent .= $indent . &quot;}\n&quot;;
 776   $setterContent .= &quot;\n&quot;;
 777   $setterContent .= $indent . &quot;// Reset any remaining animations to not have the property set.\n&quot;;
 778   $setterContent .= $indent . &quot;for ( ; i &lt; list.size(); ++i)\n&quot;;
 779   $setterContent .= $indent . &quot;    list.animation(i).&quot; . getClearFunction($name) . &quot;();\n&quot;;
 780 
 781   return $setterContent;
 782 }
 783 
 784 sub generateAnimationPropertyValueSetter {
 785   my $name = shift;
 786   my $indent = shift;
 787 
 788   my $setterContent = &quot;&quot;;
 789   $setterContent .= $indent . &quot;AnimationList&amp; list = builderState.style().&quot; . getEnsureAnimationsOrTransitionsMethod($name) . &quot;();\n&quot;;
 790   $setterContent .= $indent . &quot;size_t childIndex = 0;\n&quot;;
 791   $setterContent .= $indent . &quot;if (is&lt;CSSValueList&gt;(value)) {\n&quot;;
 792   $setterContent .= $indent . &quot;    /* Walk each value and put it into an animation, creating new animations as needed. */\n&quot;;
 793   $setterContent .= $indent . &quot;    for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value)) {\n&quot;;
 794   $setterContent .= $indent . &quot;        if (childIndex &lt;= list.size())\n&quot;;
 795   $setterContent .= $indent . &quot;            list.append(Animation::create());\n&quot;;
 796   $setterContent .= $indent . &quot;        builderState.styleMap().&quot; . getAnimationMapfunction($name) . &quot;(list.animation(childIndex), currentValue);\n&quot;;
 797   $setterContent .= $indent . &quot;        ++childIndex;\n&quot;;
 798   $setterContent .= $indent . &quot;    }\n&quot;;
 799   $setterContent .= $indent . &quot;} else {\n&quot;;
 800   $setterContent .= $indent . &quot;    if (list.isEmpty())\n&quot;;
 801   $setterContent .= $indent . &quot;        list.append(Animation::create());\n&quot;;
 802   $setterContent .= $indent . &quot;    builderState.styleMap().&quot; . getAnimationMapfunction($name) . &quot;(list.animation(childIndex), value);\n&quot;;
 803   $setterContent .= $indent . &quot;    childIndex = 1;\n&quot;;
 804   $setterContent .= $indent . &quot;}\n&quot;;
 805   $setterContent .= $indent . &quot;for ( ; childIndex &lt; list.size(); ++childIndex) {\n&quot;;
 806   $setterContent .= $indent . &quot;    /* Reset all remaining animations to not have the property set. */\n&quot;;
 807   $setterContent .= $indent . &quot;    list.animation(childIndex).&quot; . getClearFunction($name) . &quot;();\n&quot;;
 808   $setterContent .= $indent . &quot;}\n&quot;;
 809 
 810   return $setterContent;
 811 }
 812 
 813 sub generateFillLayerPropertyInitialValueSetter {
 814   my $name = shift;
 815   my $indent = shift;
 816 
 817   my $getter = $propertiesWithStyleBuilderOptions{$name}{&quot;getter&quot;};
 818   my $setter = $propertiesWithStyleBuilderOptions{$name}{&quot;setter&quot;};
 819   my $clearFunction = getClearFunction($name);
 820   my $testFunction = getTestFunction($name);
 821   my $initial = &quot;FillLayer::&quot; . $propertiesWithStyleBuilderOptions{$name}{&quot;initial&quot;} . &quot;(&quot; . getFillLayerType($name) . &quot;)&quot;;
 822 
 823   my $setterContent = &quot;&quot;;
 824   $setterContent .= $indent . &quot;// Check for (single-layer) no-op before clearing anything.\n&quot;;
 825   $setterContent .= $indent . &quot;auto&amp; layers = builderState.style().&quot; . getLayersFunction($name) . &quot;();\n&quot;;
 826   $setterContent .= $indent . &quot;if (!layers.next() &amp;&amp; (!layers.&quot; . $testFunction . &quot;() || layers.&quot; . $getter . &quot;() == $initial))\n&quot;;
 827   $setterContent .= $indent . &quot;    return;\n&quot;;
 828   $setterContent .= &quot;\n&quot;;
 829   $setterContent .= $indent . &quot;auto* child = &amp;builderState.style().&quot; . getLayersAccessorFunction($name) . &quot;();\n&quot;;
 830   $setterContent .= $indent . &quot;child-&gt;&quot; . $setter . &quot;(&quot; . $initial . &quot;);\n&quot;;
 831   $setterContent .= $indent . &quot;for (child = child-&gt;next(); child; child = child-&gt;next())\n&quot;;
 832   $setterContent .= $indent . &quot;    child-&gt;&quot; . $clearFunction . &quot;();\n&quot;;
 833 
 834   return $setterContent;
 835 }
 836 
 837 sub generateFillLayerPropertyInheritValueSetter {
 838   my $name = shift;
 839   my $indent = shift;
 840 
 841   my $getter = $propertiesWithStyleBuilderOptions{$name}{&quot;getter&quot;};
 842   my $setter = $propertiesWithStyleBuilderOptions{$name}{&quot;setter&quot;};
 843   my $clearFunction = getClearFunction($name);
 844   my $testFunction = getTestFunction($name);
 845 
 846   my $setterContent = &quot;&quot;;
 847   $setterContent .= $indent . &quot;// Check for no-op before copying anything.\n&quot;;
 848   $setterContent .= $indent . &quot;if (builderState.parentStyle().&quot; . getLayersFunction($name) .&quot;() == builderState.style().&quot; . getLayersFunction($name) . &quot;())\n&quot;;
 849   $setterContent .= $indent . &quot;    return;\n&quot;;
 850   $setterContent .= &quot;\n&quot;;
 851   $setterContent .= $indent . &quot;auto* child = &amp;builderState.style().&quot; . getLayersAccessorFunction($name) . &quot;();\n&quot;;
 852   $setterContent .= $indent . &quot;FillLayer* previousChild = nullptr;\n&quot;;
 853   $setterContent .= $indent . &quot;for (auto* parent = &amp;builderState.parentStyle().&quot; . getLayersFunction($name) . &quot;(); parent &amp;&amp; parent-&gt;&quot; . $testFunction . &quot;(); parent = parent-&gt;next()) {\n&quot;;
 854   $setterContent .= $indent . &quot;    if (!child) {\n&quot;;
 855   $setterContent .= $indent . &quot;        previousChild-&gt;setNext(makeUnique&lt;FillLayer&gt;(&quot; . getFillLayerType($name) . &quot;));\n&quot;;
 856   $setterContent .= $indent . &quot;        child = previousChild-&gt;next();\n&quot;;
 857   $setterContent .= $indent . &quot;    }\n&quot;;
 858   $setterContent .= $indent . &quot;    child-&gt;&quot; . $setter . &quot;(parent-&gt;&quot; . $getter . &quot;());\n&quot;;
 859   $setterContent .= $indent . &quot;    previousChild = child;\n&quot;;
 860   $setterContent .= $indent . &quot;    child = previousChild-&gt;next();\n&quot;;
 861   $setterContent .= $indent . &quot;}\n&quot;;
 862   $setterContent .= $indent . &quot;for (; child; child = child-&gt;next())\n&quot;;
 863   $setterContent .= $indent . &quot;    child-&gt;&quot; . $clearFunction . &quot;();\n&quot;;
 864 
 865   return $setterContent;
 866 }
 867 
 868 sub generateFillLayerPropertyValueSetter {
 869   my $name = shift;
 870   my $indent = shift;
 871 
 872   my $CSSPropertyId = &quot;CSSProperty&quot; . $nameToId{$name};
 873 
 874   my $setterContent = &quot;&quot;;
 875   $setterContent .= $indent . &quot;auto* child = &amp;builderState.style().&quot; . getLayersAccessorFunction($name) . &quot;();\n&quot;;
 876   $setterContent .= $indent . &quot;FillLayer* previousChild = nullptr;\n&quot;;
 877   $setterContent .= $indent . &quot;if (is&lt;CSSValueList&gt;(value) &amp;&amp; !is&lt;CSSImageSetValue&gt;(value)) {\n&quot;;
 878   $setterContent .= $indent . &quot;    // Walk each value and put it into a layer, creating new layers as needed.\n&quot;;
 879   $setterContent .= $indent . &quot;    for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {\n&quot;;
 880   $setterContent .= $indent . &quot;        if (!child) {\n&quot;;
 881   $setterContent .= $indent . &quot;            previousChild-&gt;setNext(makeUnique&lt;FillLayer&gt;(&quot; . getFillLayerType($name) . &quot;));\n&quot;;
 882   $setterContent .= $indent . &quot;            child = previousChild-&gt;next();\n&quot;;
 883   $setterContent .= $indent . &quot;        }\n&quot;;
 884   $setterContent .= $indent . &quot;        builderState.styleMap().&quot; . getFillLayerMapfunction($name) . &quot;(&quot; . $CSSPropertyId . &quot;, *child, item);\n&quot;;
 885   $setterContent .= $indent . &quot;        previousChild = child;\n&quot;;
 886   $setterContent .= $indent . &quot;        child = child-&gt;next();\n&quot;;
 887   $setterContent .= $indent . &quot;    }\n&quot;;
 888   $setterContent .= $indent . &quot;} else {\n&quot;;
 889   $setterContent .= $indent . &quot;    builderState.styleMap().&quot; . getFillLayerMapfunction($name) . &quot;(&quot; . $CSSPropertyId . &quot;, *child, value);\n&quot;;
 890   $setterContent .= $indent . &quot;    child = child-&gt;next();\n&quot;;
 891   $setterContent .= $indent . &quot;}\n&quot;;
 892   $setterContent .= $indent . &quot;for (; child; child = child-&gt;next())\n&quot;;
 893   $setterContent .= $indent . &quot;    child-&gt;&quot; . getClearFunction($name) . &quot;();\n&quot;;
 894 
 895   return $setterContent;
 896 }
 897 
 898 sub generateSetValueStatement
 899 {
 900   my $name = shift;
 901   my $value = shift;
 902 
 903   my $isSVG = exists $propertiesWithStyleBuilderOptions{$name}{&quot;svg&quot;};
 904   my $setter = $propertiesWithStyleBuilderOptions{$name}{&quot;setter&quot;};
 905   return &quot;builderState.style().&quot; .  ($isSVG ? &quot;accessSVGStyle().&quot; : &quot;&quot;) . $setter . &quot;(&quot; . $value . &quot;)&quot;;
 906 }
 907 
 908 sub generateInitialValueSetter {
 909   my $name = shift;
 910   my $indent = shift;
 911 
 912   my $setter = $propertiesWithStyleBuilderOptions{$name}{&quot;setter&quot;};
 913   my $initial = $propertiesWithStyleBuilderOptions{$name}{&quot;initial&quot;};
 914   my $isSVG = exists $propertiesWithStyleBuilderOptions{$name}{&quot;svg&quot;};
 915   my $setterContent = &quot;&quot;;
 916   $setterContent .= $indent . &quot;static void applyInitial&quot; . $nameToId{$name} . &quot;(BuilderState&amp; builderState)\n&quot;;
 917   $setterContent .= $indent . &quot;{\n&quot;;
 918   my $style = &quot;builderState.style()&quot;;
 919   if (exists $propertiesWithStyleBuilderOptions{$name}{&quot;auto-functions&quot;}) {
 920     $setterContent .= $indent . &quot;    &quot; . getAutoSetter($name, $style) . &quot;;\n&quot;;
 921   } elsif (exists $propertiesWithStyleBuilderOptions{$name}{&quot;visited-link-color-support&quot;}) {
 922       my $initialColor = &quot;RenderStyle::&quot; . $initial . &quot;()&quot;;
 923       $setterContent .= generateColorValueSetter($name, $initialColor, $indent . &quot;    &quot;);
 924   } elsif (exists $propertiesWithStyleBuilderOptions{$name}{&quot;animatable&quot;}) {
 925     $setterContent .= generateAnimationPropertyInitialValueSetter($name, $indent . &quot;    &quot;);
 926   } elsif (exists $propertiesWithStyleBuilderOptions{$name}{&quot;font-property&quot;}) {
 927     $setterContent .= $indent . &quot;    auto fontDescription = builderState.fontDescription();\n&quot;;
 928     $setterContent .= $indent . &quot;    fontDescription.&quot; . $setter . &quot;(FontCascadeDescription::&quot; . $initial . &quot;());\n&quot;;
 929     $setterContent .= $indent . &quot;    builderState.setFontDescription(WTFMove(fontDescription));\n&quot;;
 930   } elsif (exists $propertiesWithStyleBuilderOptions{$name}{&quot;fill-layer-property&quot;}) {
 931     $setterContent .= generateFillLayerPropertyInitialValueSetter($name, $indent . &quot;    &quot;);
 932   } else {
 933     my $initialValue = ($isSVG ? &quot;SVGRenderStyle&quot; : &quot;RenderStyle&quot;) . &quot;::&quot; . $initial . &quot;()&quot;;
 934     $setterContent .= $indent . &quot;    &quot; . generateSetValueStatement($name, $initialValue) . &quot;;\n&quot;;
 935   }
 936   $setterContent .= $indent . &quot;}\n&quot;;
 937 
 938   return $setterContent;
 939 }
 940 
 941 sub generateInheritValueSetter {
 942   my $name = shift;
 943   my $indent = shift;
 944 
 945   my $setterContent = &quot;&quot;;
 946   $setterContent .= $indent . &quot;static void applyInherit&quot; . $nameToId{$name} . &quot;(BuilderState&amp; builderState)\n&quot;;
 947   $setterContent .= $indent . &quot;{\n&quot;;
 948   my $isSVG = exists $propertiesWithStyleBuilderOptions{$name}{&quot;svg&quot;};
 949   my $parentStyle = &quot;builderState.parentStyle()&quot;;
 950   my $style = &quot;builderState.style()&quot;;
 951   my $getter = $propertiesWithStyleBuilderOptions{$name}{&quot;getter&quot;};
 952   my $setter = $propertiesWithStyleBuilderOptions{$name}{&quot;setter&quot;};
 953   my $didCallSetValue = 0;
 954   if (exists $propertiesWithStyleBuilderOptions{$name}{&quot;auto-functions&quot;}) {
 955     $setterContent .= $indent . &quot;    if (&quot; . getAutoGetter($name, $parentStyle) . &quot;) {\n&quot;;
 956     $setterContent .= $indent . &quot;        &quot; . getAutoSetter($name, $style) . &quot;;\n&quot;;
 957     $setterContent .= $indent . &quot;        return;\n&quot;;
 958     $setterContent .= $indent . &quot;    }\n&quot;;
 959   } elsif (exists $propertiesWithStyleBuilderOptions{$name}{&quot;visited-link-color-support&quot;}) {
 960     $setterContent .= $indent . &quot;    Color color = &quot; . $parentStyle . &quot;.&quot; . $getter . &quot;();\n&quot;;
 961     if (!exists($propertiesWithStyleBuilderOptions{$name}{&quot;no-default-color&quot;})) {
 962       $setterContent .= $indent . &quot;    if (!color.isValid())\n&quot;;
 963       $setterContent .= $indent . &quot;        color = &quot; . $parentStyle . &quot;.color();\n&quot;;
 964     }
 965     $setterContent .= generateColorValueSetter($name, &quot;color&quot;, $indent . &quot;    &quot;);
 966     $didCallSetValue = 1;
 967   } elsif (exists $propertiesWithStyleBuilderOptions{$name}{&quot;animatable&quot;}) {
 968     $setterContent .= generateAnimationPropertyInheritValueSetter($name, $indent . &quot;    &quot;);
 969     $didCallSetValue = 1;
 970   } elsif (exists $propertiesWithStyleBuilderOptions{$name}{&quot;font-property&quot;}) {
 971     $setterContent .= $indent . &quot;    auto fontDescription = builderState.fontDescription();\n&quot;;
 972     $setterContent .= $indent . &quot;    fontDescription.&quot; . $setter . &quot;(builderState.parentFontDescription().&quot; . $getter . &quot;());\n&quot;;
 973     $setterContent .= $indent . &quot;    builderState.setFontDescription(WTFMove(fontDescription));\n&quot;;
 974     $didCallSetValue = 1;
 975   } elsif (exists $propertiesWithStyleBuilderOptions{$name}{&quot;fill-layer-property&quot;}) {
 976     $setterContent .= generateFillLayerPropertyInheritValueSetter($name, $indent . &quot;    &quot;);
 977     $didCallSetValue = 1;
 978   }
 979   if (!$didCallSetValue) {
 980     my $inheritedValue = $parentStyle . &quot;.&quot; . ($isSVG ? &quot;svgStyle().&quot; : &quot;&quot;) .  $getter . &quot;()&quot;;
 981     $setterContent .= $indent . &quot;    &quot; . generateSetValueStatement($name, &quot;forwardInheritedValue(&quot; . $inheritedValue . &quot;)&quot;) . &quot;;\n&quot;;
 982   }
 983   $setterContent .= $indent . &quot;}\n&quot;;
 984 
 985   return $setterContent;
 986 }
 987 
 988 sub generateValueSetter {
 989   my $name = shift;
 990   my $indent = shift;
 991 
 992   my $setterContent = &quot;&quot;;
 993   $setterContent .= $indent . &quot;static void applyValue&quot; . $nameToId{$name} . &quot;(BuilderState&amp; builderState, CSSValue&amp; value)\n&quot;;
 994   $setterContent .= $indent . &quot;{\n&quot;;
 995   my $convertedValue;
 996   if (exists($propertiesWithStyleBuilderOptions{$name}{&quot;converter&quot;})) {
 997     $convertedValue = &quot;BuilderConverter::convert&quot; . $propertiesWithStyleBuilderOptions{$name}{&quot;converter&quot;} . &quot;(builderState, value)&quot;;
 998   } elsif (exists($propertiesWithStyleBuilderOptions{$name}{&quot;conditional-converter&quot;})) {
 999     $setterContent .= $indent . &quot;    auto convertedValue = BuilderConverter::convert&quot; . $propertiesWithStyleBuilderOptions{$name}{&quot;conditional-converter&quot;} . &quot;(builderState, value);\n&quot;;
1000     $convertedValue = &quot;WTFMove(convertedValue.value())&quot;;
1001   } else {
1002     $convertedValue = &quot;downcast&lt;CSSPrimitiveValue&gt;(value)&quot;;
1003   }
1004 
1005   my $setter = $propertiesWithStyleBuilderOptions{$name}{&quot;setter&quot;};
1006   my $style = &quot;builderState.style()&quot;;
1007   my $didCallSetValue = 0;
1008   if (exists $propertiesWithStyleBuilderOptions{$name}{&quot;auto-functions&quot;}) {
1009     $setterContent .= $indent . &quot;    if (downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueAuto) {\n&quot;;
1010     $setterContent .= $indent . &quot;        &quot;. getAutoSetter($name, $style) . &quot;;\n&quot;;
1011     $setterContent .= $indent . &quot;        return;\n&quot;;
1012     $setterContent .= $indent . &quot;    }\n&quot;;
1013   } elsif (exists $propertiesWithStyleBuilderOptions{$name}{&quot;visited-link-color-support&quot;}) {
1014     $setterContent .= $indent . &quot;    auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);\n&quot;;
1015     if ($name eq &quot;color&quot;) {
1016       # The &quot;color&quot; property supports &quot;currentColor&quot; value. We should add a parameter.
1017       $setterContent .= handleCurrentColorValue($name, &quot;primitiveValue&quot;, $indent . &quot;    &quot;);
1018     }
1019     $setterContent .= generateColorValueSetter($name, &quot;primitiveValue&quot;, $indent . &quot;    &quot;, VALUE_IS_PRIMITIVE);
1020     $didCallSetValue = 1;
1021   } elsif (exists $propertiesWithStyleBuilderOptions{$name}{&quot;animatable&quot;}) {
1022     $setterContent .= generateAnimationPropertyValueSetter($name, $indent . &quot;    &quot;);
1023     $didCallSetValue = 1;
1024   } elsif (exists $propertiesWithStyleBuilderOptions{$name}{&quot;font-property&quot;}) {
1025     $setterContent .= $indent . &quot;    auto fontDescription = builderState.fontDescription();\n&quot;;
1026     $setterContent .= $indent . &quot;    fontDescription.&quot; . $setter . &quot;(&quot; . $convertedValue . &quot;);\n&quot;;
1027     $setterContent .= $indent . &quot;    builderState.setFontDescription(WTFMove(fontDescription));\n&quot;;
1028     $didCallSetValue = 1;
1029   } elsif (exists $propertiesWithStyleBuilderOptions{$name}{&quot;fill-layer-property&quot;}) {
1030     $setterContent .= generateFillLayerPropertyValueSetter($name, $indent . &quot;    &quot;);
1031     $didCallSetValue = 1;
1032   }
1033   if (!$didCallSetValue) {
1034     if (exists($propertiesWithStyleBuilderOptions{$name}{&quot;conditional-converter&quot;})) {
1035       $setterContent .= $indent . &quot;    if (convertedValue)\n&quot;;
1036       $setterContent .= &quot;    &quot;;
1037     }
1038     $setterContent .= $indent . &quot;    &quot; . generateSetValueStatement($name, $convertedValue) . &quot;;\n&quot;;
1039   }
1040   $setterContent .= $indent . &quot;}\n&quot;;
1041 
1042   return $setterContent;
1043 }
1044 
1045 open STYLEBUILDER, &quot;&gt;StyleBuilderGenerated.cpp&quot; || die &quot;Could not open StyleBuilderGenerated.cpp for writing&quot;;
1046 print STYLEBUILDER &lt;&lt; &quot;EOF&quot;;
1047 /* This file is automatically generated from $inputFile by makeprop, do not edit */
1048 
1049 #include &quot;config.h&quot;
1050 #include &quot;StyleBuilderGenerated.h&quot;
1051 
1052 #include &quot;CSSPrimitiveValueMappings.h&quot;
1053 #include &quot;CSSProperty.h&quot;
1054 #include &quot;RenderStyle.h&quot;
1055 #include &quot;StyleBuilderState.h&quot;
1056 #include &quot;StyleBuilderConverter.h&quot;
1057 #include &quot;StyleBuilderCustom.h&quot;
1058 #include &quot;StylePropertyShorthand.h&quot;
1059 
1060 namespace WebCore {
1061 namespace Style {
1062 
1063 class BuilderFunctions {
1064 public:
1065 EOF
1066 
1067 foreach my $name (@names) {
1068   # Skip Shorthand properties and properties that do not use the StyleBuilder.
1069   next if (exists $propertiesWithStyleBuilderOptions{$name}{&quot;longhands&quot;});
1070   next if (exists $propertiesWithStyleBuilderOptions{$name}{&quot;skip-builder&quot;});
1071 
1072   my $indent = &quot;    &quot;;
1073   if (!$propertiesWithStyleBuilderOptions{$name}{&quot;custom&quot;}{&quot;Initial&quot;}) {
1074     print STYLEBUILDER generateInitialValueSetter($name, $indent);
1075   }
1076   if (!$propertiesWithStyleBuilderOptions{$name}{&quot;custom&quot;}{&quot;Inherit&quot;}) {
1077     print STYLEBUILDER generateInheritValueSetter($name, $indent);
1078   }
1079   if (!$propertiesWithStyleBuilderOptions{$name}{&quot;custom&quot;}{&quot;Value&quot;}) {
1080     print STYLEBUILDER generateValueSetter($name, $indent);
1081   }
1082 }
1083 
1084 print STYLEBUILDER &lt;&lt; &quot;EOF&quot;;
1085 };
1086 
1087 void BuilderGenerated::applyProperty(CSSPropertyID property, BuilderState&amp; builderState, CSSValue&amp; value, bool isInitial, bool isInherit, const CSSRegisteredCustomProperty* registered)
1088 {
1089     switch (property) {
1090     case CSSPropertyInvalid:
1091         break;
1092     case CSSPropertyCustom: {
1093         auto&amp; customProperty = downcast&lt;CSSCustomPropertyValue&gt;(value);
1094         if (isInitial)
1095             BuilderCustom::applyInitialCustomProperty(builderState, registered, customProperty.name());
1096         else if (isInherit)
1097             BuilderCustom::applyInheritCustomProperty(builderState, registered, customProperty.name());
1098         else
1099             BuilderCustom::applyValueCustomProperty(builderState, registered, customProperty);
1100         break;
1101     }
1102 EOF
1103 
1104 foreach my $name (@names) {
1105   print STYLEBUILDER &quot;    case CSSProperty&quot; . $nameToId{$name} . &quot;:\n&quot;;
1106   if (exists $propertiesWithStyleBuilderOptions{$name}{&quot;longhands&quot;}) {
1107     print STYLEBUILDER &quot;        ASSERT(isShorthandCSSProperty(property));\n&quot;;
1108     print STYLEBUILDER &quot;        ASSERT_NOT_REACHED();\n&quot;;
1109   } elsif (!exists $propertiesWithStyleBuilderOptions{$name}{&quot;skip-builder&quot;}) {
1110     print STYLEBUILDER &quot;        if (isInitial)\n&quot;;
1111     print STYLEBUILDER &quot;            &quot; . getScopeForFunction($name, &quot;Initial&quot;) . &quot;::applyInitial&quot; . $nameToId{$name} . &quot;(builderState);\n&quot;;
1112     print STYLEBUILDER &quot;        else if (isInherit)\n&quot;;
1113     print STYLEBUILDER &quot;            &quot; . getScopeForFunction($name, &quot;Inherit&quot;) . &quot;::applyInherit&quot; . $nameToId{$name} . &quot;(builderState);\n&quot;;
1114     print STYLEBUILDER &quot;        else\n&quot;;
1115     print STYLEBUILDER &quot;            &quot; . getScopeForFunction($name, &quot;Value&quot;) . &quot;::applyValue&quot; . $nameToId{$name} . &quot;(builderState, value);\n&quot;;
1116   }
1117   print STYLEBUILDER &quot;        break;\n&quot;;
1118 }
1119 
1120 print STYLEBUILDER &lt;&lt; &quot;EOF&quot;;
1121     };
1122 }
1123 
1124 } // namespace Style
1125 } // namespace WebCore
1126 EOF
1127 
1128 close STYLEBUILDER;
1129 
1130 # Generate StylePropertyShorthandsFunctions.
1131 open SHORTHANDS_H, &quot;&gt;&quot;, &quot;StylePropertyShorthandFunctions.h&quot; or die &quot;Could not open StylePropertyShorthandFunctions.h for writing\n&quot;;
1132 print SHORTHANDS_H &lt;&lt; &quot;EOF&quot;;
1133 // This file is automatically generated from $inputFile by the makeprop.pl script. Do not edit it.
1134 
1135 #pragma once
1136 
1137 namespace WebCore {
1138 
1139 class StylePropertyShorthand;
1140 
1141 EOF
1142 
1143 foreach my $name (@names) {
1144   # Skip non-Shorthand properties.
1145   next if (!exists $propertiesWithStyleBuilderOptions{$name}{&quot;longhands&quot;});
1146 
1147   print SHORTHANDS_H &quot;StylePropertyShorthand &quot; . lcfirst($nameToId{$name}) . &quot;Shorthand();\n&quot;;
1148 }
1149 
1150 print SHORTHANDS_H &lt;&lt; &quot;EOF&quot;;
1151 
1152 } // namespace WebCore
1153 EOF
1154 
1155 close SHORTHANDS_H;
1156 
1157 open SHORTHANDS_CPP, &quot;&gt;&quot;, &quot;StylePropertyShorthandFunctions.cpp&quot; or die &quot;Could not open StylePropertyShorthandFunctions.cpp for writing\n&quot;;
1158 print SHORTHANDS_CPP &lt;&lt; &quot;EOF&quot;;
1159 // This file is automatically generated from $inputFile by the makeprop.pl script. Do not edit it.
1160 
1161 #include &quot;config.h&quot;
1162 #include &quot;StylePropertyShorthandFunctions.h&quot;
1163 
1164 #include &quot;StylePropertyShorthand.h&quot;
1165 
1166 namespace WebCore {
1167 
1168 EOF
1169 
1170 my %longhandToShorthands = ();
1171 
1172 foreach my $name (@names) {
1173   # Skip non-Shorthand properties.
1174   next if (!exists $propertiesWithStyleBuilderOptions{$name}{&quot;longhands&quot;});
1175 
1176   my $lowercaseId = lcfirst($nameToId{$name});
1177   my @longhands = @{$propertiesWithStyleBuilderOptions{$name}{&quot;longhands&quot;}};
1178 
1179   print SHORTHANDS_CPP &quot;StylePropertyShorthand &quot; . $lowercaseId . &quot;Shorthand()\n&quot;;
1180   print SHORTHANDS_CPP &quot;{\n&quot;;
1181   print SHORTHANDS_CPP &quot;    static const CSSPropertyID &quot; . $lowercaseId . &quot;Properties[] = {\n&quot;;
1182   foreach (@longhands) {
1183     if ($_ eq &quot;all&quot;) {
1184         foreach my $propname (@names) {
1185             next if (exists $propertiesWithStyleBuilderOptions{$propname}{&quot;longhands&quot;});
1186             next if ($propname eq &quot;direction&quot; || $propname eq &quot;unicode-bidi&quot;);
1187             die &quot;Unknown CSS property used in all shorthand: $propname&quot; if !exists($nameToId{$propname});
1188             push(@{$longhandToShorthands{$propname}}, $name);
1189             print SHORTHANDS_CPP &quot;        CSSProperty&quot; . $nameToId{$propname} . &quot;,\n&quot;;
1190         }
1191     } else {
1192         die &quot;Unknown CSS property used in longhands: $_&quot; if !exists($nameToId{$_});
1193         push(@{$longhandToShorthands{$_}}, $name);
1194         print SHORTHANDS_CPP &quot;        CSSProperty&quot; . $nameToId{$_} . &quot;,\n&quot;;
1195     }
1196   }
1197   print SHORTHANDS_CPP &quot;    };\n&quot;;
1198   print SHORTHANDS_CPP &quot;    return StylePropertyShorthand(CSSProperty&quot; . $nameToId{$name} . &quot;, &quot; . $lowercaseId . &quot;Properties);\n&quot;;
1199   print SHORTHANDS_CPP &quot;}\n\n&quot;;
1200 }
1201 
1202 print SHORTHANDS_CPP &lt;&lt; &quot;EOF&quot;;
1203 StylePropertyShorthand shorthandForProperty(CSSPropertyID propertyID)
1204 {
1205     switch (propertyID) {
1206 EOF
1207 
1208 foreach my $name (@names) {
1209   # Skip non-Shorthand properties.
1210   next if (!exists $propertiesWithStyleBuilderOptions{$name}{&quot;longhands&quot;});
1211 
1212   print SHORTHANDS_CPP &quot;    case CSSProperty&quot; . $nameToId{$name} . &quot;:\n&quot;;
1213   print SHORTHANDS_CPP &quot;        return &quot; . lcfirst($nameToId{$name}) . &quot;Shorthand();\n&quot;;
1214 }
1215 
1216 print SHORTHANDS_CPP &lt;&lt; &quot;EOF&quot;;
1217     default:
1218         return { };
1219     }
1220 }
1221 EOF
1222 
1223 print SHORTHANDS_CPP &lt;&lt; &quot;EOF&quot;;
1224 StylePropertyShorthandVector matchingShorthandsForLonghand(CSSPropertyID propertyID)
1225 {
1226     switch (propertyID) {
1227 EOF
1228 
1229 sub constructShorthandsVector {
1230   my $shorthands = shift;
1231 
1232   my $vector = &quot;StylePropertyShorthandVector{&quot;;
1233   foreach my $i (0 .. $#$shorthands) {
1234     $vector .= &quot;, &quot; unless $i == 0;
1235     $vector .= lcfirst($nameToId{$shorthands-&gt;[$i]}) . &quot;Shorthand()&quot;;
1236   }
1237   $vector .= &quot;}&quot;;
1238   return $vector;
1239 }
1240 
1241 my %vectorToLonghands = ();
1242 for my $longhand (sort keys %longhandToShorthands) {
1243   my @shorthands = sort(@{$longhandToShorthands{$longhand}});
1244   push(@{$vectorToLonghands{constructShorthandsVector(\@shorthands)}}, $longhand);
1245 }
1246 
1247 for my $vector (sort keys %vectorToLonghands) {
1248   foreach (@{$vectorToLonghands{$vector}}) {
1249     print SHORTHANDS_CPP &quot;    case CSSProperty&quot; . $nameToId{$_} . &quot;:\n&quot;;
1250   }
1251   print SHORTHANDS_CPP &quot;        return &quot; . $vector . &quot;;\n&quot;;
1252 }
1253 
1254 print SHORTHANDS_CPP &lt;&lt; &quot;EOF&quot;;
1255     default:
1256         return { };
1257     }
1258 }
1259 EOF
1260 
1261 print SHORTHANDS_CPP &lt;&lt; &quot;EOF&quot;;
1262 } // namespace WebCore
1263 EOF
1264 
1265 close SHORTHANDS_CPP;
1266 
1267 if (not $gperf) {
1268     $gperf = $ENV{GPERF} ? $ENV{GPERF} : &quot;gperf&quot;;
1269 }
1270 system(&quot;\&quot;$gperf\&quot; --key-positions=\&quot;*\&quot; -D -n -s 2 CSSPropertyNames.gperf --output-file=CSSPropertyNames.cpp&quot;) == 0 || die &quot;calling gperf failed: $?&quot;;
    </pre>
  </body>
</html>
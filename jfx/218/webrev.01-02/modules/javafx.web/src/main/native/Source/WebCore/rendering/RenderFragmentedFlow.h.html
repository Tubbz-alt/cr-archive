<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderFragmentedFlow.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011 Adobe Systems Incorporated. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1. Redistributions of source code must retain the above
  9  *    copyright notice, this list of conditions and the following
 10  *    disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above
 12  *    copyright notice, this list of conditions and the following
 13  *    disclaimer in the documentation and/or other materials
 14  *    provided with the distribution.
 15  *
 16  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER &quot;AS IS&quot; AND ANY
 17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 18  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 19  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
 20  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 21  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 22  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 23  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 25  * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 26  * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 27  * SUCH DAMAGE.
 28  */
 29 
 30 #pragma once
 31 
 32 #include &quot;LayerFragment.h&quot;
 33 #include &quot;PODIntervalTree.h&quot;
 34 #include &quot;RenderBlockFlow.h&quot;
 35 #include &quot;RenderFragmentContainer.h&quot;
 36 #include &lt;wtf/ListHashSet.h&gt;
 37 
 38 namespace WebCore {
 39 
 40 class CurrentRenderFragmentContainerMaintainer;
 41 class RenderFragmentedFlow;
 42 class RenderStyle;
 43 class RenderFragmentContainer;
 44 class RootInlineBox;
 45 
 46 typedef ListHashSet&lt;RenderFragmentContainer*&gt; RenderFragmentContainerList;
 47 typedef Vector&lt;RenderLayer*&gt; RenderLayerList;
 48 typedef HashMap&lt;const RootInlineBox*, RenderFragmentContainer*&gt; ContainingFragmentMap;
 49 
 50 // RenderFragmentedFlow is used to collect all the render objects that participate in a
 51 // flow thread. It will also help in doing the layout. However, it will not render
 52 // directly to screen. Instead, RenderFragmentContainer objects will redirect their paint
 53 // and nodeAtPoint methods to this object. Each RenderFragmentContainer will actually be a viewPort
 54 // of the RenderFragmentedFlow.
 55 
 56 class RenderFragmentedFlow: public RenderBlockFlow {
 57     WTF_MAKE_ISO_ALLOCATED(RenderFragmentedFlow);
 58 public:
 59     virtual ~RenderFragmentedFlow() = default;
 60 
 61     virtual void removeFlowChildInfo(RenderElement&amp;);
 62 #ifndef NDEBUG
 63     bool hasChildInfo(RenderObject* child) const { return is&lt;RenderBox&gt;(child) &amp;&amp; m_fragmentRangeMap.contains(downcast&lt;RenderBox&gt;(child)); }
 64 #endif
 65 
 66 #if !ASSERT_WITH_SECURITY_IMPLICATION_DISABLED
 67     bool checkLinesConsistency(const RenderBlockFlow&amp;) const;
 68 #endif
 69 
 70     void deleteLines() override;
 71 
 72     virtual void addFragmentToThread(RenderFragmentContainer*) = 0;
 73     virtual void removeFragmentFromThread(RenderFragmentContainer*);
 74     const RenderFragmentContainerList&amp; renderFragmentContainerList() const { return m_fragmentList; }
 75 
 76     void updateLogicalWidth() final;
 77     LogicalExtentComputedValues computeLogicalHeight(LayoutUnit logicalHeight, LayoutUnit logicalTop) const override;
 78 
 79     bool nodeAtPoint(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction) override;
 80 
 81     bool hasFragments() const { return m_fragmentList.size(); }
 82     virtual void fragmentChangedWritingMode(RenderFragmentContainer*) { }
 83 
 84     void validateFragments();
 85     void invalidateFragments(MarkingBehavior = MarkContainingBlockChain);
 86     bool hasValidFragmentInfo() const { return !m_fragmentsInvalidated &amp;&amp; !m_fragmentList.isEmpty(); }
 87 
 88     // Called when a descendant box&#39;s layout is finished and it has been positioned within its container.
 89     virtual void fragmentedFlowDescendantBoxLaidOut(RenderBox*) { }
 90 
 91     void styleDidChange(StyleDifference, const RenderStyle* oldStyle) override;
 92 
 93     void repaintRectangleInFragments(const LayoutRect&amp;) const;
 94 
 95     LayoutPoint adjustedPositionRelativeToOffsetParent(const RenderBoxModelObject&amp;, const LayoutPoint&amp;) const;
 96 
 97     LayoutUnit pageLogicalTopForOffset(LayoutUnit) const;
 98     LayoutUnit pageLogicalWidthForOffset(LayoutUnit) const;
 99     LayoutUnit pageLogicalHeightForOffset(LayoutUnit) const;
100     LayoutUnit pageRemainingLogicalHeightForOffset(LayoutUnit, PageBoundaryRule = IncludePageBoundary) const;
101 
102     virtual void setPageBreak(const RenderBlock*, LayoutUnit /*offset*/, LayoutUnit /*spaceShortage*/) { }
103     virtual void updateMinimumPageHeight(const RenderBlock*, LayoutUnit /*offset*/, LayoutUnit /*minHeight*/) { }
104 
105     virtual RenderFragmentContainer* fragmentAtBlockOffset(const RenderBox*, LayoutUnit, bool extendLastFragment = false) const;
106 
107     bool fragmentsHaveUniformLogicalWidth() const { return m_fragmentsHaveUniformLogicalWidth; }
108     bool fragmentsHaveUniformLogicalHeight() const { return m_fragmentsHaveUniformLogicalHeight; }
109 
110     virtual RenderFragmentContainer* mapFromFlowToFragment(TransformState&amp;) const;
111 
112     void logicalWidthChangedInFragmentsForBlock(const RenderBlock*, bool&amp;);
113 
114     LayoutUnit contentLogicalWidthOfFirstFragment() const;
115     LayoutUnit contentLogicalHeightOfFirstFragment() const;
116     LayoutUnit contentLogicalLeftOfFirstFragment() const;
117 
118     RenderFragmentContainer* firstFragment() const;
119     RenderFragmentContainer* lastFragment() const;
120 
121     virtual void setFragmentRangeForBox(const RenderBox&amp;, RenderFragmentContainer*, RenderFragmentContainer*);
122     bool getFragmentRangeForBox(const RenderBox*, RenderFragmentContainer*&amp; startFragment, RenderFragmentContainer*&amp; endFragment) const;
123     bool computedFragmentRangeForBox(const RenderBox*, RenderFragmentContainer*&amp; startFragment, RenderFragmentContainer*&amp; endFragment) const;
124     bool hasCachedFragmentRangeForBox(const RenderBox&amp;) const;
125 
126     // Check if the object is in fragment and the fragment is part of this flow thread.
127     bool objectInFlowFragment(const RenderObject*, const RenderFragmentContainer*) const;
128 
129     // Check if the object should be painted in this fragment and if the fragment is part of this flow thread.
130     bool objectShouldFragmentInFlowFragment(const RenderObject*, const RenderFragmentContainer*) const;
131 
132     void markFragmentsForOverflowLayoutIfNeeded();
133 
134     virtual bool addForcedFragmentBreak(const RenderBlock*, LayoutUnit, RenderBox* breakChild, bool isBefore, LayoutUnit* offsetBreakAdjustment = 0);
135     virtual void applyBreakAfterContent(LayoutUnit) { }
136 
137     virtual bool isPageLogicalHeightKnown() const { return true; }
138     bool pageLogicalSizeChanged() const { return m_pageLogicalSizeChanged; }
139 
140     void collectLayerFragments(LayerFragments&amp;, const LayoutRect&amp; layerBoundingBox, const LayoutRect&amp; dirtyRect);
141     LayoutRect fragmentsBoundingBox(const LayoutRect&amp; layerBoundingBox);
142 
143     LayoutUnit offsetFromLogicalTopOfFirstFragment(const RenderBlock*) const;
144     void clearRenderBoxFragmentInfoAndCustomStyle(const RenderBox&amp;, const RenderFragmentContainer*, const RenderFragmentContainer*, const RenderFragmentContainer*, const RenderFragmentContainer*);
145 
146     void addFragmentsVisualEffectOverflow(const RenderBox*);
147     void addFragmentsVisualOverflowFromTheme(const RenderBlock*);
148     void addFragmentsOverflowFromChild(const RenderBox*, const RenderBox*, const LayoutSize&amp;);
149     void addFragmentsLayoutOverflow(const RenderBox*, const LayoutRect&amp;);
150     void addFragmentsVisualOverflow(const RenderBox*, const LayoutRect&amp;);
151     void clearFragmentsOverflow(const RenderBox*);
152 
153     LayoutRect mapFromFragmentedFlowToLocal(const RenderBox*, const LayoutRect&amp;) const;
154     LayoutRect mapFromLocalToFragmentedFlow(const RenderBox*, const LayoutRect&amp;) const;
155 
156     void flipForWritingModeLocalCoordinates(LayoutRect&amp;) const;
157 
158     // Used to estimate the maximum height of the flow thread.
159     static LayoutUnit maxLogicalHeight() { return LayoutUnit::max() / 2; }
160 
161     bool fragmentInRange(const RenderFragmentContainer* targetFragment, const RenderFragmentContainer* startFragment, const RenderFragmentContainer* endFragment) const;
162 
163     virtual bool absoluteQuadsForBox(Vector&lt;FloatQuad&gt;&amp;, bool*, const RenderBox*, float, float) const { return false; }
164 
165     void layout() override;
166 
167     void setCurrentFragmentMaintainer(CurrentRenderFragmentContainerMaintainer* currentFragmentMaintainer) { m_currentFragmentMaintainer = currentFragmentMaintainer; }
168     RenderFragmentContainer* currentFragment() const;
169 
170     ContainingFragmentMap&amp; containingFragmentMap();
171 
172     bool cachedEnclosingFragmentedFlowNeedsUpdate() const override { return false; }
173 
174     // FIXME: Eventually as column and fragment flow threads start nesting, this may end up changing.
175     virtual bool shouldCheckColumnBreaks() const { return false; }
176 
177 private:
178     // Always create a RenderLayer for the RenderFragmentedFlow so that we
179     // can easily avoid drawing the children directly.
180     bool requiresLayer() const final { return true; }
181 
182 protected:
183     RenderFragmentedFlow(Document&amp;, RenderStyle&amp;&amp;);
184 
185     RenderFragmentedFlow* locateEnclosingFragmentedFlow() const override { return const_cast&lt;RenderFragmentedFlow*&gt;(this); }
186 
187     const char* renderName() const override = 0;
188 
189     // Overridden by columns/pages to set up an initial logical width of the page width even when
190     // no fragments have been generated yet.
191     virtual LayoutUnit initialLogicalWidth() const { return 0; };
192 
193     void clearLinesToFragmentMap();
194     void willBeDestroyed() override;
195 
196     void mapLocalToContainer(const RenderLayerModelObject* repaintContainer, TransformState&amp;, MapCoordinatesFlags, bool* wasFixed) const override;
197 
198     void updateFragmentsFragmentedFlowPortionRect();
199     bool shouldRepaint(const LayoutRect&amp;) const;
200 
201     bool getFragmentRangeForBoxFromCachedInfo(const RenderBox*, RenderFragmentContainer*&amp; startFragment, RenderFragmentContainer*&amp; endFragment) const;
202 
203     void removeRenderBoxFragmentInfo(RenderBox&amp;);
204     void removeLineFragmentInfo(const RenderBlockFlow&amp;);
205 
206     class RenderFragmentContainerRange {
207     public:
208         RenderFragmentContainerRange() = default;
209         RenderFragmentContainerRange(RenderFragmentContainer* start, RenderFragmentContainer* end)
210         {
211             setRange(start, end);
212         }
213 
214         void setRange(RenderFragmentContainer* start, RenderFragmentContainer* end)
215         {
216             m_startFragment = makeWeakPtr(start);
217             m_endFragment = makeWeakPtr(end);
218             m_rangeInvalidated = true;
219         }
220 
221         RenderFragmentContainer* startFragment() const { return m_startFragment.get(); }
222         RenderFragmentContainer* endFragment() const { return m_endFragment.get(); }
223         bool rangeInvalidated() const { return m_rangeInvalidated; }
224         void clearRangeInvalidated() { m_rangeInvalidated = false; }
225 
226     private:
227         WeakPtr&lt;RenderFragmentContainer&gt; m_startFragment;
228         WeakPtr&lt;RenderFragmentContainer&gt; m_endFragment;
229         bool m_rangeInvalidated;
230     };
231 
232     class FragmentSearchAdapter;
233 
234     RenderFragmentContainerList m_fragmentList;
235 
236     // Map a line to its containing fragment.
237     std::unique_ptr&lt;ContainingFragmentMap&gt; m_lineToFragmentMap;
238 
239     // Map a box to the list of fragments in which the box is rendered.
240     using RenderFragmentContainerRangeMap = HashMap&lt;const RenderBox*, RenderFragmentContainerRange&gt;;
241     RenderFragmentContainerRangeMap m_fragmentRangeMap;
242 
243     // Map a box with a fragment break to the auto height fragment affected by that break.
244     using RenderBoxToFragmentMap = HashMap&lt;RenderBox*, RenderFragmentContainer*&gt;;
245     RenderBoxToFragmentMap m_breakBeforeToFragmentMap;
246     RenderBoxToFragmentMap m_breakAfterToFragmentMap;
247 
248     using FragmentIntervalTree = PODIntervalTree&lt;LayoutUnit, WeakPtr&lt;RenderFragmentContainer&gt;&gt;;
249     FragmentIntervalTree m_fragmentIntervalTree;
250 
251     CurrentRenderFragmentContainerMaintainer* m_currentFragmentMaintainer;
252 
253     bool m_fragmentsInvalidated : 1;
254     bool m_fragmentsHaveUniformLogicalWidth : 1;
255     bool m_fragmentsHaveUniformLogicalHeight : 1;
256     bool m_pageLogicalSizeChanged : 1;
257 };
258 
259 } // namespace WebCore
260 
261 SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(RenderFragmentedFlow, isRenderFragmentedFlow())
    </pre>
  </body>
</html>
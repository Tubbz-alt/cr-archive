<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PolymorphicAccess.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PolyProtoAccessChain.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PolymorphicAccess.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PolymorphicAccess.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2014-2018 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2014-2020 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 28,10 ***</span>
<span class="line-new-header">--- 28,11 ---</span>
  
  #if ENABLE(JIT)
  
  #include &quot;BinarySwitch.h&quot;
  #include &quot;CCallHelpers.h&quot;
<span class="line-added">+ #include &quot;CacheableIdentifierInlines.h&quot;</span>
  #include &quot;CodeBlock.h&quot;
  #include &quot;FullCodeOrigin.h&quot;
  #include &quot;Heap.h&quot;
  #include &quot;JITOperations.h&quot;
  #include &quot;JSCInlines.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 43,23 ***</span>
  #include &lt;wtf/ListDump.h&gt;
  
  namespace JSC {
  
  namespace PolymorphicAccessInternal {
<span class="line-modified">! static const bool verbose = false;</span>
  }
  
  void AccessGenerationResult::dump(PrintStream&amp; out) const
  {
      out.print(m_kind);
      if (m_code)
          out.print(&quot;:&quot;, m_code);
  }
  
<span class="line-modified">! Watchpoint* AccessGenerationState::addWatchpoint(const ObjectPropertyCondition&amp; condition)</span>
  {
<span class="line-modified">!     return WatchpointsOnStructureStubInfo::ensureReferenceAndAddWatchpoint(</span>
          watchpoints, jit-&gt;codeBlock(), stubInfo, condition);
  }
  
  void AccessGenerationState::restoreScratch()
  {
<span class="line-new-header">--- 44,25 ---</span>
  #include &lt;wtf/ListDump.h&gt;
  
  namespace JSC {
  
  namespace PolymorphicAccessInternal {
<span class="line-modified">! static constexpr bool verbose = false;</span>
  }
  
<span class="line-added">+ DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(PolymorphicAccess);</span>
<span class="line-added">+ </span>
  void AccessGenerationResult::dump(PrintStream&amp; out) const
  {
      out.print(m_kind);
      if (m_code)
          out.print(&quot;:&quot;, m_code);
  }
  
<span class="line-modified">! void AccessGenerationState::installWatchpoint(const ObjectPropertyCondition&amp; condition)</span>
  {
<span class="line-modified">!     WatchpointsOnStructureStubInfo::ensureReferenceAndInstallWatchpoint(</span>
          watchpoints, jit-&gt;codeBlock(), stubInfo, condition);
  }
  
  void AccessGenerationState::restoreScratch()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 208,27 ***</span>
          jit-&gt;addLinkTask(
              [=] (LinkBuffer&amp; linkBuffer) {
                  linkBuffer.link(jumpToOSRExitExceptionHandler, originalHandler.nativeCode);
              });
      } else {
<span class="line-modified">!         jit-&gt;setupArguments&lt;decltype(lookupExceptionHandler)&gt;(CCallHelpers::TrustedImmPtr(&amp;m_vm), GPRInfo::callFrameRegister);</span>
          CCallHelpers::Call lookupExceptionHandlerCall = jit-&gt;call(OperationPtrTag);
          jit-&gt;addLinkTask(
              [=] (LinkBuffer&amp; linkBuffer) {
<span class="line-modified">!                 linkBuffer.link(lookupExceptionHandlerCall, FunctionPtr&lt;OperationPtrTag&gt;(lookupExceptionHandler));</span>
              });
          jit-&gt;jumpToExceptionHandler(m_vm);
      }
  }
  
<span class="line-removed">- </span>
  PolymorphicAccess::PolymorphicAccess() { }
  PolymorphicAccess::~PolymorphicAccess() { }
  
  AccessGenerationResult PolymorphicAccess::addCases(
      const GCSafeConcurrentJSLocker&amp; locker, VM&amp; vm, CodeBlock* codeBlock, StructureStubInfo&amp; stubInfo,
<span class="line-modified">!     const Identifier&amp; ident, Vector&lt;std::unique_ptr&lt;AccessCase&gt;, 2&gt; originalCasesToAdd)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
      // This method will add the originalCasesToAdd to the list one at a time while preserving the
      // invariants:
<span class="line-new-header">--- 211,27 ---</span>
          jit-&gt;addLinkTask(
              [=] (LinkBuffer&amp; linkBuffer) {
                  linkBuffer.link(jumpToOSRExitExceptionHandler, originalHandler.nativeCode);
              });
      } else {
<span class="line-modified">!         jit-&gt;setupArguments&lt;decltype(operationLookupExceptionHandler)&gt;(CCallHelpers::TrustedImmPtr(&amp;m_vm));</span>
<span class="line-added">+         jit-&gt;prepareCallOperation(m_vm);</span>
          CCallHelpers::Call lookupExceptionHandlerCall = jit-&gt;call(OperationPtrTag);
          jit-&gt;addLinkTask(
              [=] (LinkBuffer&amp; linkBuffer) {
<span class="line-modified">!                 linkBuffer.link(lookupExceptionHandlerCall, FunctionPtr&lt;OperationPtrTag&gt;(operationLookupExceptionHandler));</span>
              });
          jit-&gt;jumpToExceptionHandler(m_vm);
      }
  }
  
  PolymorphicAccess::PolymorphicAccess() { }
  PolymorphicAccess::~PolymorphicAccess() { }
  
  AccessGenerationResult PolymorphicAccess::addCases(
      const GCSafeConcurrentJSLocker&amp; locker, VM&amp; vm, CodeBlock* codeBlock, StructureStubInfo&amp; stubInfo,
<span class="line-modified">!     Vector&lt;std::unique_ptr&lt;AccessCase&gt;, 2&gt; originalCasesToAdd)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
      // This method will add the originalCasesToAdd to the list one at a time while preserving the
      // invariants:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 307,27 ***</span>
      }
  
      // Now add things to the new list. Note that at this point, we will still have old cases that
      // may be replaced by the new ones. That&#39;s fine. We will sort that out when we regenerate.
      for (auto&amp; caseToAdd : casesToAdd) {
<span class="line-modified">!         commit(locker, vm, m_watchpoints, codeBlock, stubInfo, ident, *caseToAdd);</span>
          m_list.append(WTFMove(caseToAdd));
      }
  
      if (PolymorphicAccessInternal::verbose)
          dataLog(&quot;After addCases: m_list: &quot;, listDump(m_list), &quot;\n&quot;);
  
      return AccessGenerationResult::Buffered;
  }
  
  AccessGenerationResult PolymorphicAccess::addCase(
<span class="line-modified">!     const GCSafeConcurrentJSLocker&amp; locker, VM&amp; vm, CodeBlock* codeBlock, StructureStubInfo&amp; stubInfo,</span>
<span class="line-removed">-     const Identifier&amp; ident, std::unique_ptr&lt;AccessCase&gt; newAccess)</span>
  {
      Vector&lt;std::unique_ptr&lt;AccessCase&gt;, 2&gt; newAccesses;
      newAccesses.append(WTFMove(newAccess));
<span class="line-modified">!     return addCases(locker, vm, codeBlock, stubInfo, ident, WTFMove(newAccesses));</span>
  }
  
  bool PolymorphicAccess::visitWeak(VM&amp; vm) const
  {
      for (unsigned i = 0; i &lt; size(); ++i) {
<span class="line-new-header">--- 310,26 ---</span>
      }
  
      // Now add things to the new list. Note that at this point, we will still have old cases that
      // may be replaced by the new ones. That&#39;s fine. We will sort that out when we regenerate.
      for (auto&amp; caseToAdd : casesToAdd) {
<span class="line-modified">!         commit(locker, vm, m_watchpoints, codeBlock, stubInfo, *caseToAdd);</span>
          m_list.append(WTFMove(caseToAdd));
      }
  
      if (PolymorphicAccessInternal::verbose)
          dataLog(&quot;After addCases: m_list: &quot;, listDump(m_list), &quot;\n&quot;);
  
      return AccessGenerationResult::Buffered;
  }
  
  AccessGenerationResult PolymorphicAccess::addCase(
<span class="line-modified">!     const GCSafeConcurrentJSLocker&amp; locker, VM&amp; vm, CodeBlock* codeBlock, StructureStubInfo&amp; stubInfo, std::unique_ptr&lt;AccessCase&gt; newAccess)</span>
  {
      Vector&lt;std::unique_ptr&lt;AccessCase&gt;, 2&gt; newAccesses;
      newAccesses.append(WTFMove(newAccess));
<span class="line-modified">!     return addCases(locker, vm, codeBlock, stubInfo, WTFMove(newAccesses));</span>
  }
  
  bool PolymorphicAccess::visitWeak(VM&amp; vm) const
  {
      for (unsigned i = 0; i &lt; size(); ++i) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 349,10 ***</span>
<span class="line-new-header">--- 351,16 ---</span>
      for (unsigned i = 0; i &lt; size(); ++i)
          result &amp;= at(i).propagateTransitions(visitor);
      return result;
  }
  
<span class="line-added">+ void PolymorphicAccess::visitAggregate(SlotVisitor&amp; visitor)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     for (unsigned i = 0; i &lt; size(); ++i)</span>
<span class="line-added">+         at(i).visitAggregate(visitor);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void PolymorphicAccess::dump(PrintStream&amp; out) const
  {
      out.print(RawPointer(this), &quot;:[&quot;);
      CommaPrinter comma;
      for (auto&amp; entry : m_list)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 360,63 ***</span>
      out.print(&quot;]&quot;);
  }
  
  void PolymorphicAccess::commit(
      const GCSafeConcurrentJSLocker&amp;, VM&amp; vm, std::unique_ptr&lt;WatchpointsOnStructureStubInfo&gt;&amp; watchpoints, CodeBlock* codeBlock,
<span class="line-modified">!     StructureStubInfo&amp; stubInfo, const Identifier&amp; ident, AccessCase&amp; accessCase)</span>
  {
      // NOTE: We currently assume that this is relatively rare. It mainly arises for accesses to
      // properties on DOM nodes. For sure we cache many DOM node accesses, but even in
      // Real Pages (TM), we appear to spend most of our time caching accesses to properties on
      // vanilla objects or exotic objects from within JSC (like Arguments, those are super popular).
      // Those common kinds of JSC object accesses don&#39;t hit this case.
  
<span class="line-modified">!     for (WatchpointSet* set : accessCase.commit(vm, ident)) {</span>
          Watchpoint* watchpoint =
              WatchpointsOnStructureStubInfo::ensureReferenceAndAddWatchpoint(
<span class="line-modified">!                 watchpoints, codeBlock, &amp;stubInfo, ObjectPropertyCondition());</span>
  
          set-&gt;add(watchpoint);
      }
  }
  
  AccessGenerationResult PolymorphicAccess::regenerate(
<span class="line-modified">!     const GCSafeConcurrentJSLocker&amp; locker, VM&amp; vm, CodeBlock* codeBlock, StructureStubInfo&amp; stubInfo, const Identifier&amp; ident)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
      if (PolymorphicAccessInternal::verbose)
          dataLog(&quot;Regenerate with m_list: &quot;, listDump(m_list), &quot;\n&quot;);
  
      AccessGenerationState state(vm, codeBlock-&gt;globalObject());
  
      state.access = this;
      state.stubInfo = &amp;stubInfo;
<span class="line-removed">-     state.ident = &amp;ident;</span>
  
<span class="line-modified">!     state.baseGPR = stubInfo.baseGPR();</span>
<span class="line-modified">!     state.thisGPR = stubInfo.patch.thisGPR;</span>
      state.valueRegs = stubInfo.valueRegs();
  
<span class="line-removed">-     ScratchRegisterAllocator allocator(stubInfo.patch.usedRegisters);</span>
<span class="line-removed">-     state.allocator = &amp;allocator;</span>
<span class="line-removed">-     allocator.lock(state.baseGPR);</span>
<span class="line-removed">-     if (state.thisGPR != InvalidGPRReg)</span>
<span class="line-removed">-         allocator.lock(state.thisGPR);</span>
<span class="line-removed">-     allocator.lock(state.valueRegs);</span>
<span class="line-removed">- #if USE(JSVALUE32_64)</span>
<span class="line-removed">-     allocator.lock(stubInfo.patch.baseTagGPR);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-     state.scratchGPR = allocator.allocateScratchGPR();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     CCallHelpers jit(codeBlock);</span>
<span class="line-removed">-     state.jit = &amp;jit;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     state.preservedReusedRegisterState =</span>
<span class="line-removed">-         allocator.preserveReusedRegistersByPushing(jit, ScratchRegisterAllocator::ExtraStackSpace::NoExtraSpace);</span>
<span class="line-removed">- </span>
      // Regenerating is our opportunity to figure out what our list of cases should look like. We
      // do this here. The newly produced &#39;cases&#39; list may be smaller than m_list. We don&#39;t edit
      // m_list in-place because we may still fail, in which case we want the PolymorphicAccess object
      // to be unmutated. For sure, we want it to hang onto any data structures that may be referenced
      // from the code of the current stub (aka previous).
<span class="line-new-header">--- 368,44 ---</span>
      out.print(&quot;]&quot;);
  }
  
  void PolymorphicAccess::commit(
      const GCSafeConcurrentJSLocker&amp;, VM&amp; vm, std::unique_ptr&lt;WatchpointsOnStructureStubInfo&gt;&amp; watchpoints, CodeBlock* codeBlock,
<span class="line-modified">!     StructureStubInfo&amp; stubInfo, AccessCase&amp; accessCase)</span>
  {
      // NOTE: We currently assume that this is relatively rare. It mainly arises for accesses to
      // properties on DOM nodes. For sure we cache many DOM node accesses, but even in
      // Real Pages (TM), we appear to spend most of our time caching accesses to properties on
      // vanilla objects or exotic objects from within JSC (like Arguments, those are super popular).
      // Those common kinds of JSC object accesses don&#39;t hit this case.
  
<span class="line-modified">!     for (WatchpointSet* set : accessCase.commit(vm)) {</span>
          Watchpoint* watchpoint =
              WatchpointsOnStructureStubInfo::ensureReferenceAndAddWatchpoint(
<span class="line-modified">!                 watchpoints, codeBlock, &amp;stubInfo);</span>
  
          set-&gt;add(watchpoint);
      }
  }
  
  AccessGenerationResult PolymorphicAccess::regenerate(
<span class="line-modified">!     const GCSafeConcurrentJSLocker&amp; locker, VM&amp; vm, CodeBlock* codeBlock, StructureStubInfo&amp; stubInfo)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
      if (PolymorphicAccessInternal::verbose)
          dataLog(&quot;Regenerate with m_list: &quot;, listDump(m_list), &quot;\n&quot;);
  
      AccessGenerationState state(vm, codeBlock-&gt;globalObject());
  
      state.access = this;
      state.stubInfo = &amp;stubInfo;
  
<span class="line-modified">!     state.baseGPR = stubInfo.baseGPR;</span>
<span class="line-modified">!     state.u.thisGPR = stubInfo.regs.thisGPR;</span>
      state.valueRegs = stubInfo.valueRegs();
  
      // Regenerating is our opportunity to figure out what our list of cases should look like. We
      // do this here. The newly produced &#39;cases&#39; list may be smaller than m_list. We don&#39;t edit
      // m_list in-place because we may still fail, in which case we want the PolymorphicAccess object
      // to be unmutated. For sure, we want it to hang onto any data structures that may be referenced
      // from the code of the current stub (aka previous).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 461,19 ***</span>
          if (isGenerated)
              m_list[dstIndex++] = WTFMove(someCase);
      }
      m_list.resize(dstIndex);
  
      bool generatedFinalCode = false;
  
      // If the resulting set of cases is so big that we would stop caching and this is InstanceOf,
      // then we want to generate the generic InstanceOf and then stop.
      if (cases.size() &gt;= Options::maxAccessVariantListSize()
          &amp;&amp; stubInfo.accessType == AccessType::InstanceOf) {
          while (!cases.isEmpty())
              m_list.append(cases.takeLast());
<span class="line-modified">!         cases.append(AccessCase::create(vm, codeBlock, AccessCase::InstanceOfGeneric));</span>
          generatedFinalCode = true;
      }
  
      if (PolymorphicAccessInternal::verbose)
          dataLog(&quot;Optimized cases: &quot;, listDump(cases), &quot;\n&quot;);
<span class="line-new-header">--- 450,46 ---</span>
          if (isGenerated)
              m_list[dstIndex++] = WTFMove(someCase);
      }
      m_list.resize(dstIndex);
  
<span class="line-added">+     ScratchRegisterAllocator allocator(stubInfo.usedRegisters);</span>
<span class="line-added">+     state.allocator = &amp;allocator;</span>
<span class="line-added">+     allocator.lock(state.baseGPR);</span>
<span class="line-added">+     if (state.u.thisGPR != InvalidGPRReg)</span>
<span class="line-added">+         allocator.lock(state.u.thisGPR);</span>
<span class="line-added">+     allocator.lock(state.valueRegs);</span>
<span class="line-added">+ #if USE(JSVALUE32_64)</span>
<span class="line-added">+     allocator.lock(stubInfo.baseTagGPR);</span>
<span class="line-added">+     if (stubInfo.v.thisTagGPR != InvalidGPRReg)</span>
<span class="line-added">+         allocator.lock(stubInfo.v.thisTagGPR);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+     state.scratchGPR = allocator.allocateScratchGPR();</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (auto&amp; accessCase : cases) {</span>
<span class="line-added">+         if (accessCase-&gt;needsScratchFPR()) {</span>
<span class="line-added">+             state.scratchFPR = allocator.allocateScratchFPR();</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     CCallHelpers jit(codeBlock);</span>
<span class="line-added">+     state.jit = &amp;jit;</span>
<span class="line-added">+ </span>
<span class="line-added">+     state.preservedReusedRegisterState =</span>
<span class="line-added">+         allocator.preserveReusedRegistersByPushing(jit, ScratchRegisterAllocator::ExtraStackSpace::NoExtraSpace);</span>
<span class="line-added">+ </span>
      bool generatedFinalCode = false;
  
      // If the resulting set of cases is so big that we would stop caching and this is InstanceOf,
      // then we want to generate the generic InstanceOf and then stop.
      if (cases.size() &gt;= Options::maxAccessVariantListSize()
          &amp;&amp; stubInfo.accessType == AccessType::InstanceOf) {
          while (!cases.isEmpty())
              m_list.append(cases.takeLast());
<span class="line-modified">!         cases.append(AccessCase::create(vm, codeBlock, AccessCase::InstanceOfGeneric, nullptr));</span>
          generatedFinalCode = true;
      }
  
      if (PolymorphicAccessInternal::verbose)
          dataLog(&quot;Optimized cases: &quot;, listDump(cases), &quot;\n&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 481,13 ***</span>
      // At this point we&#39;re convinced that &#39;cases&#39; contains the cases that we want to JIT now and we
      // won&#39;t change that set anymore.
  
      bool allGuardedByStructureCheck = true;
      bool hasJSGetterSetterCall = false;
      for (auto&amp; newCase : cases) {
<span class="line-modified">!         commit(locker, vm, state.watchpoints, codeBlock, stubInfo, ident, *newCase);</span>
<span class="line-modified">!         allGuardedByStructureCheck &amp;= newCase-&gt;guardedByStructureCheck();</span>
          if (newCase-&gt;type() == AccessCase::Getter || newCase-&gt;type() == AccessCase::Setter)
              hasJSGetterSetterCall = true;
      }
  
      if (cases.isEmpty()) {
<span class="line-new-header">--- 497,25 ---</span>
      // At this point we&#39;re convinced that &#39;cases&#39; contains the cases that we want to JIT now and we
      // won&#39;t change that set anymore.
  
      bool allGuardedByStructureCheck = true;
      bool hasJSGetterSetterCall = false;
<span class="line-added">+     bool needsInt32PropertyCheck = false;</span>
<span class="line-added">+     bool needsStringPropertyCheck = false;</span>
<span class="line-added">+     bool needsSymbolPropertyCheck = false;</span>
      for (auto&amp; newCase : cases) {
<span class="line-modified">!         if (!stubInfo.hasConstantIdentifier) {</span>
<span class="line-modified">!             if (newCase-&gt;requiresIdentifierNameMatch()) {</span>
<span class="line-added">+                 if (newCase-&gt;uid()-&gt;isSymbol())</span>
<span class="line-added">+                     needsSymbolPropertyCheck = true;</span>
<span class="line-added">+                 else</span>
<span class="line-added">+                     needsStringPropertyCheck = true;</span>
<span class="line-added">+             } else if (newCase-&gt;requiresInt32PropertyCheck())</span>
<span class="line-added">+                 needsInt32PropertyCheck = true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         commit(locker, vm, state.watchpoints, codeBlock, stubInfo, *newCase);</span>
<span class="line-added">+         allGuardedByStructureCheck &amp;= newCase-&gt;guardedByStructureCheck(stubInfo);</span>
          if (newCase-&gt;type() == AccessCase::Getter || newCase-&gt;type() == AccessCase::Setter)
              hasJSGetterSetterCall = true;
      }
  
      if (cases.isEmpty()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 496,18 ***</span>
      } else if (!allGuardedByStructureCheck || cases.size() == 1) {
          // If there are any proxies in the list, we cannot just use a binary switch over the structure.
          // We need to resort to a cascade. A cascade also happens to be optimal if we only have just
          // one case.
          CCallHelpers::JumpList fallThrough;
  
<span class="line-modified">!         // Cascade through the list, preferring newer entries.</span>
<span class="line-modified">!         for (unsigned i = cases.size(); i--;) {</span>
<span class="line-modified">!             fallThrough.link(&amp;jit);</span>
<span class="line-modified">!             fallThrough.clear();</span>
<span class="line-modified">!             cases[i]-&gt;generateWithGuard(state, fallThrough);</span>
          }
          state.failAndRepatch.append(fallThrough);
      } else {
          jit.load32(
              CCallHelpers::Address(state.baseGPR, JSCell::structureIDOffset()),
              state.scratchGPR);
  
<span class="line-new-header">--- 524,104 ---</span>
      } else if (!allGuardedByStructureCheck || cases.size() == 1) {
          // If there are any proxies in the list, we cannot just use a binary switch over the structure.
          // We need to resort to a cascade. A cascade also happens to be optimal if we only have just
          // one case.
          CCallHelpers::JumpList fallThrough;
<span class="line-added">+         if (needsInt32PropertyCheck || needsStringPropertyCheck || needsSymbolPropertyCheck) {</span>
<span class="line-added">+             if (needsInt32PropertyCheck) {</span>
<span class="line-added">+                 CCallHelpers::Jump notInt32;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 if (!stubInfo.propertyIsInt32) {</span>
<span class="line-added">+ #if USE(JSVALUE64)</span>
<span class="line-added">+                     notInt32 = jit.branchIfNotInt32(state.u.propertyGPR);</span>
<span class="line-added">+ #else</span>
<span class="line-added">+                     notInt32 = jit.branchIfNotInt32(state.stubInfo-&gt;v.propertyTagGPR);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 for (unsigned i = cases.size(); i--;) {</span>
<span class="line-added">+                     fallThrough.link(&amp;jit);</span>
<span class="line-added">+                     fallThrough.clear();</span>
<span class="line-added">+                     if (cases[i]-&gt;requiresInt32PropertyCheck())</span>
<span class="line-added">+                         cases[i]-&gt;generateWithGuard(state, fallThrough);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 if (needsStringPropertyCheck || needsSymbolPropertyCheck) {</span>
<span class="line-added">+                     if (notInt32.isSet())</span>
<span class="line-added">+                         notInt32.link(&amp;jit);</span>
<span class="line-added">+                     fallThrough.link(&amp;jit);</span>
<span class="line-added">+                     fallThrough.clear();</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     if (notInt32.isSet())</span>
<span class="line-added">+                         state.failAndRepatch.append(notInt32);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (needsStringPropertyCheck) {</span>
<span class="line-added">+                 CCallHelpers::JumpList notString;</span>
<span class="line-added">+                 GPRReg propertyGPR = state.u.propertyGPR;</span>
<span class="line-added">+                 if (!stubInfo.propertyIsString) {</span>
<span class="line-added">+ #if USE(JSVALUE32_64)</span>
<span class="line-added">+                     GPRReg propertyTagGPR = state.stubInfo-&gt;v.propertyTagGPR;</span>
<span class="line-added">+                     notString.append(jit.branchIfNotCell(propertyTagGPR));</span>
<span class="line-added">+ #else</span>
<span class="line-added">+                     notString.append(jit.branchIfNotCell(propertyGPR));</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+                     notString.append(jit.branchIfNotString(propertyGPR));</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 jit.loadPtr(MacroAssembler::Address(propertyGPR, JSString::offsetOfValue()), state.scratchGPR);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 state.failAndRepatch.append(jit.branchIfRopeStringImpl(state.scratchGPR));</span>
<span class="line-added">+ </span>
<span class="line-added">+                 for (unsigned i = cases.size(); i--;) {</span>
<span class="line-added">+                     fallThrough.link(&amp;jit);</span>
<span class="line-added">+                     fallThrough.clear();</span>
<span class="line-added">+                     if (cases[i]-&gt;requiresIdentifierNameMatch() &amp;&amp; !cases[i]-&gt;uid()-&gt;isSymbol())</span>
<span class="line-added">+                         cases[i]-&gt;generateWithGuard(state, fallThrough);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 if (needsSymbolPropertyCheck) {</span>
<span class="line-added">+                     notString.link(&amp;jit);</span>
<span class="line-added">+                     fallThrough.link(&amp;jit);</span>
<span class="line-added">+                     fallThrough.clear();</span>
<span class="line-added">+                 } else</span>
<span class="line-added">+                     state.failAndRepatch.append(notString);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (needsSymbolPropertyCheck) {</span>
<span class="line-added">+                 CCallHelpers::JumpList notSymbol;</span>
<span class="line-added">+                 if (!stubInfo.propertyIsSymbol) {</span>
<span class="line-added">+                     GPRReg propertyGPR = state.u.propertyGPR;</span>
<span class="line-added">+ #if USE(JSVALUE32_64)</span>
<span class="line-added">+                     GPRReg propertyTagGPR = state.stubInfo-&gt;v.propertyTagGPR;</span>
<span class="line-added">+                     notSymbol.append(jit.branchIfNotCell(propertyTagGPR));</span>
<span class="line-added">+ #else</span>
<span class="line-added">+                     notSymbol.append(jit.branchIfNotCell(propertyGPR));</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+                     notSymbol.append(jit.branchIfNotSymbol(propertyGPR));</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 for (unsigned i = cases.size(); i--;) {</span>
<span class="line-added">+                     fallThrough.link(&amp;jit);</span>
<span class="line-added">+                     fallThrough.clear();</span>
<span class="line-added">+                     if (cases[i]-&gt;requiresIdentifierNameMatch() &amp;&amp; cases[i]-&gt;uid()-&gt;isSymbol())</span>
<span class="line-added">+                         cases[i]-&gt;generateWithGuard(state, fallThrough);</span>
<span class="line-added">+                 }</span>
  
<span class="line-modified">!                 state.failAndRepatch.append(notSymbol);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             // Cascade through the list, preferring newer entries.</span>
<span class="line-modified">!             for (unsigned i = cases.size(); i--;) {</span>
<span class="line-added">+                 fallThrough.link(&amp;jit);</span>
<span class="line-added">+                 fallThrough.clear();</span>
<span class="line-added">+                 cases[i]-&gt;generateWithGuard(state, fallThrough);</span>
<span class="line-added">+             }</span>
          }
<span class="line-added">+ </span>
          state.failAndRepatch.append(fallThrough);
<span class="line-added">+ </span>
      } else {
          jit.load32(
              CCallHelpers::Address(state.baseGPR, JSCell::structureIDOffset()),
              state.scratchGPR);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 593,15 ***</span>
          if (PolymorphicAccessInternal::verbose)
              dataLog(&quot;Did fail to allocate.\n&quot;);
          return AccessGenerationResult::GaveUp;
      }
  
<span class="line-modified">!     CodeLocationLabel&lt;JSInternalPtrTag&gt; successLabel = stubInfo.doneLocation();</span>
  
      linkBuffer.link(state.success, successLabel);
  
<span class="line-modified">!     linkBuffer.link(failure, stubInfo.slowPathStartLocation());</span>
  
      if (PolymorphicAccessInternal::verbose)
          dataLog(FullCodeOrigin(codeBlock, stubInfo.codeOrigin), &quot;: Generating polymorphic access stub for &quot;, listDump(cases), &quot;\n&quot;);
  
      MacroAssemblerCodeRef&lt;JITStubRoutinePtrTag&gt; code = FINALIZE_CODE_FOR(
<span class="line-new-header">--- 707,15 ---</span>
          if (PolymorphicAccessInternal::verbose)
              dataLog(&quot;Did fail to allocate.\n&quot;);
          return AccessGenerationResult::GaveUp;
      }
  
<span class="line-modified">!     CodeLocationLabel&lt;JSInternalPtrTag&gt; successLabel = stubInfo.doneLocation;</span>
  
      linkBuffer.link(state.success, successLabel);
  
<span class="line-modified">!     linkBuffer.link(failure, stubInfo.slowPathStartLocation);</span>
  
      if (PolymorphicAccessInternal::verbose)
          dataLog(FullCodeOrigin(codeBlock, stubInfo.codeOrigin), &quot;: Generating polymorphic access stub for &quot;, listDump(cases), &quot;\n&quot;);
  
      MacroAssemblerCodeRef&lt;JITStubRoutinePtrTag&gt; code = FINALIZE_CODE_FOR(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 609,20 ***</span>
          &quot;%s&quot;, toCString(&quot;Access stub for &quot;, *codeBlock, &quot; &quot;, stubInfo.codeOrigin, &quot; with return point &quot;, successLabel, &quot;: &quot;, listDump(cases)).data());
  
      bool doesCalls = false;
      Vector&lt;JSCell*&gt; cellsToMark;
      for (auto&amp; entry : cases)
<span class="line-modified">!         doesCalls |= entry-&gt;doesCalls(&amp;cellsToMark);</span>
  
<span class="line-modified">!     m_stubRoutine = createJITStubRoutine(code, vm, codeBlock, doesCalls, cellsToMark, codeBlockThatOwnsExceptionHandlers, callSiteIndexForExceptionHandling);</span>
      m_watchpoints = WTFMove(state.watchpoints);
<span class="line-modified">!     if (!state.weakReferences.isEmpty())</span>
          m_weakReferences = makeUnique&lt;Vector&lt;WriteBarrier&lt;JSCell&gt;&gt;&gt;(WTFMove(state.weakReferences));
      if (PolymorphicAccessInternal::verbose)
          dataLog(&quot;Returning: &quot;, code.code(), &quot;\n&quot;);
  
      m_list = WTFMove(cases);
  
      AccessGenerationResult::Kind resultKind;
      if (m_list.size() &gt;= Options::maxAccessVariantListSize() || generatedFinalCode)
          resultKind = AccessGenerationResult::GeneratedFinalCode;
      else
<span class="line-new-header">--- 723,23 ---</span>
          &quot;%s&quot;, toCString(&quot;Access stub for &quot;, *codeBlock, &quot; &quot;, stubInfo.codeOrigin, &quot; with return point &quot;, successLabel, &quot;: &quot;, listDump(cases)).data());
  
      bool doesCalls = false;
      Vector&lt;JSCell*&gt; cellsToMark;
      for (auto&amp; entry : cases)
<span class="line-modified">!         doesCalls |= entry-&gt;doesCalls(vm, &amp;cellsToMark);</span>
  
<span class="line-modified">!     m_stubRoutine = createJITStubRoutine(code, vm, codeBlock, doesCalls, cellsToMark, WTFMove(state.m_callLinkInfos), codeBlockThatOwnsExceptionHandlers, callSiteIndexForExceptionHandling);</span>
      m_watchpoints = WTFMove(state.watchpoints);
<span class="line-modified">!     if (!state.weakReferences.isEmpty()) {</span>
<span class="line-added">+         state.weakReferences.shrinkToFit();</span>
          m_weakReferences = makeUnique&lt;Vector&lt;WriteBarrier&lt;JSCell&gt;&gt;&gt;(WTFMove(state.weakReferences));
<span class="line-added">+     }</span>
      if (PolymorphicAccessInternal::verbose)
          dataLog(&quot;Returning: &quot;, code.code(), &quot;\n&quot;);
  
      m_list = WTFMove(cases);
<span class="line-added">+     m_list.shrinkToFit();</span>
  
      AccessGenerationResult::Kind resultKind;
      if (m_list.size() &gt;= Options::maxAccessVariantListSize() || generatedFinalCode)
          resultKind = AccessGenerationResult::GeneratedFinalCode;
      else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 736,10 ***</span>
<span class="line-new-header">--- 853,58 ---</span>
          out.print(&quot;InstanceOfMiss&quot;);
          return;
      case AccessCase::InstanceOfGeneric:
          out.print(&quot;InstanceOfGeneric&quot;);
          return;
<span class="line-added">+     case AccessCase::IndexedInt32Load:</span>
<span class="line-added">+         out.print(&quot;IndexedInt32Load&quot;);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     case AccessCase::IndexedDoubleLoad:</span>
<span class="line-added">+         out.print(&quot;IndexedDoubleLoad&quot;);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     case AccessCase::IndexedContiguousLoad:</span>
<span class="line-added">+         out.print(&quot;IndexedContiguousLoad&quot;);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     case AccessCase::IndexedArrayStorageLoad:</span>
<span class="line-added">+         out.print(&quot;IndexedArrayStorageLoad&quot;);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     case AccessCase::IndexedScopedArgumentsLoad:</span>
<span class="line-added">+         out.print(&quot;IndexedScopedArgumentsLoad&quot;);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     case AccessCase::IndexedDirectArgumentsLoad:</span>
<span class="line-added">+         out.print(&quot;IndexedDirectArgumentsLoad&quot;);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     case AccessCase::IndexedTypedArrayInt8Load:</span>
<span class="line-added">+         out.print(&quot;IndexedTypedArrayInt8Load&quot;);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     case AccessCase::IndexedTypedArrayUint8Load:</span>
<span class="line-added">+         out.print(&quot;IndexedTypedArrayUint8Load&quot;);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     case AccessCase::IndexedTypedArrayUint8ClampedLoad:</span>
<span class="line-added">+         out.print(&quot;IndexedTypedArrayUint8ClampedLoad&quot;);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     case AccessCase::IndexedTypedArrayInt16Load:</span>
<span class="line-added">+         out.print(&quot;IndexedTypedArrayInt16Load&quot;);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     case AccessCase::IndexedTypedArrayUint16Load:</span>
<span class="line-added">+         out.print(&quot;IndexedTypedArrayUint16Load&quot;);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     case AccessCase::IndexedTypedArrayInt32Load:</span>
<span class="line-added">+         out.print(&quot;IndexedTypedArrayInt32Load&quot;);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     case AccessCase::IndexedTypedArrayUint32Load:</span>
<span class="line-added">+         out.print(&quot;IndexedTypedArrayUint32Load&quot;);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     case AccessCase::IndexedTypedArrayFloat32Load:</span>
<span class="line-added">+         out.print(&quot;IndexedTypedArrayFloat32Load&quot;);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     case AccessCase::IndexedTypedArrayFloat64Load:</span>
<span class="line-added">+         out.print(&quot;IndexedTypedArrayFloat64Load&quot;);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     case AccessCase::IndexedStringLoad:</span>
<span class="line-added">+         out.print(&quot;IndexedStringLoad&quot;);</span>
<span class="line-added">+         return;</span>
      }
  
      RELEASE_ASSERT_NOT_REACHED();
  }
  
</pre>
<center><a href="PolyProtoAccessChain.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PolymorphicAccess.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
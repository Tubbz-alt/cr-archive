<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/history/BackForwardCache.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2007, 2014, 2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;BackForwardCache.h&quot;
 28 
 29 #include &quot;ApplicationCacheHost.h&quot;
 30 #include &quot;BackForwardController.h&quot;
 31 #include &quot;CachedPage.h&quot;
 32 #include &quot;DOMWindow.h&quot;
 33 #include &quot;DeviceMotionController.h&quot;
 34 #include &quot;DeviceOrientationController.h&quot;
 35 #include &quot;DiagnosticLoggingClient.h&quot;
 36 #include &quot;DiagnosticLoggingKeys.h&quot;
 37 #include &quot;Document.h&quot;
 38 #include &quot;DocumentLoader.h&quot;
 39 #include &quot;FocusController.h&quot;
 40 #include &quot;Frame.h&quot;
 41 #include &quot;FrameLoader.h&quot;
 42 #include &quot;FrameLoaderClient.h&quot;
 43 #include &quot;FrameView.h&quot;
 44 #include &quot;HistoryController.h&quot;
 45 #include &quot;IgnoreOpensDuringUnloadCountIncrementer.h&quot;
 46 #include &quot;Logging.h&quot;
 47 #include &quot;Page.h&quot;
 48 #include &quot;Quirks.h&quot;
 49 #include &quot;ScriptDisallowedScope.h&quot;
 50 #include &quot;Settings.h&quot;
 51 #include &quot;SubframeLoader.h&quot;
 52 #include &lt;pal/Logging.h&gt;
 53 #include &lt;wtf/MemoryPressureHandler.h&gt;
 54 #include &lt;wtf/NeverDestroyed.h&gt;
 55 #include &lt;wtf/SetForScope.h&gt;
 56 #include &lt;wtf/text/CString.h&gt;
 57 #include &lt;wtf/text/StringConcatenate.h&gt;
 58 
 59 namespace WebCore {
 60 
 61 #define PCLOG(...) LOG(BackForwardCache, &quot;%*s%s&quot;, indentLevel*4, &quot;&quot;, makeString(__VA_ARGS__).utf8().data())
 62 
 63 static inline void logBackForwardCacheFailureDiagnosticMessage(DiagnosticLoggingClient&amp; client, const String&amp; reason)
 64 {
 65     client.logDiagnosticMessage(DiagnosticLoggingKeys::backForwardCacheFailureKey(), reason, ShouldSample::No);
 66 }
 67 
 68 static inline void logBackForwardCacheFailureDiagnosticMessage(Page* page, const String&amp; reason)
 69 {
 70     if (!page)
 71         return;
 72 
 73     logBackForwardCacheFailureDiagnosticMessage(page-&gt;diagnosticLoggingClient(), reason);
 74 }
 75 
 76 static bool canCacheFrame(Frame&amp; frame, DiagnosticLoggingClient&amp; diagnosticLoggingClient, unsigned indentLevel)
 77 {
 78     PCLOG(&quot;+---&quot;);
 79     FrameLoader&amp; frameLoader = frame.loader();
 80 
 81     // Prevent page caching if a subframe is still in provisional load stage.
 82     // We only do this check for subframes because the main frame is reused when navigating to a new page.
 83     if (!frame.isMainFrame() &amp;&amp; frameLoader.state() == FrameStateProvisional) {
 84         PCLOG(&quot;   -Frame is in provisional load stage&quot;);
 85         logBackForwardCacheFailureDiagnosticMessage(diagnosticLoggingClient, DiagnosticLoggingKeys::provisionalLoadKey());
 86         return false;
 87     }
 88 
 89     if (frame.isMainFrame() &amp;&amp; frameLoader.stateMachine().isDisplayingInitialEmptyDocument()) {
 90         PCLOG(&quot;   -MainFrame is displaying initial empty document&quot;);
 91         return false;
 92     }
 93 
 94     if (!frame.document()) {
 95         PCLOG(&quot;   -Frame has no document&quot;);
 96         return false;
 97     }
 98 
 99     if (frame.document()-&gt;shouldPreventEnteringBackForwardCacheForTesting()) {
100         PCLOG(&quot;   -Back/Forward caching is disabled for testing&quot;);
101         return false;
102     }
103 
104     if (!frame.document()-&gt;frame()) {
105         PCLOG(&quot;   -Document is detached from frame&quot;);
106         ASSERT_NOT_REACHED();
107         return false;
108     }
109 
110     DocumentLoader* documentLoader = frameLoader.documentLoader();
111     if (!documentLoader) {
112         PCLOG(&quot;   -There is no DocumentLoader object&quot;);
113         logBackForwardCacheFailureDiagnosticMessage(diagnosticLoggingClient, DiagnosticLoggingKeys::noDocumentLoaderKey());
114         return false;
115     }
116 
117     URL currentURL = documentLoader-&gt;url();
118     URL newURL = frameLoader.provisionalDocumentLoader() ? frameLoader.provisionalDocumentLoader()-&gt;url() : URL();
119     if (!newURL.isEmpty())
120         PCLOG(&quot; Determining if frame can be cached navigating from (&quot;, currentURL.string(), &quot;) to (&quot;, newURL.string(), &quot;):&quot;);
121     else
122         PCLOG(&quot; Determining if subframe with URL (&quot;, currentURL.string(), &quot;) can be cached:&quot;);
123 
124     bool isCacheable = true;
125 
126     if (frame.isMainFrame() &amp;&amp; frame.document()-&gt;quirks().shouldBypassBackForwardCache()) {
127         PCLOG(&quot;   -Disabled by site-specific quirk&quot;);
128         logBackForwardCacheFailureDiagnosticMessage(diagnosticLoggingClient, DiagnosticLoggingKeys::siteSpecificQuirkKey());
129         isCacheable = false;
130     }
131 
132     // Do not cache error pages (these can be recognized as pages with substitute data or unreachable URLs).
133     if (documentLoader-&gt;substituteData().isValid() &amp;&amp; !documentLoader-&gt;substituteData().failingURL().isEmpty()) {
134         PCLOG(&quot;   -Frame is an error page&quot;);
135         logBackForwardCacheFailureDiagnosticMessage(diagnosticLoggingClient, DiagnosticLoggingKeys::isErrorPageKey());
136         isCacheable = false;
137     }
138     if (frameLoader.subframeLoader().containsPlugins() &amp;&amp; !frame.page()-&gt;settings().backForwardCacheSupportsPlugins()) {
139         PCLOG(&quot;   -Frame contains plugins&quot;);
140         logBackForwardCacheFailureDiagnosticMessage(diagnosticLoggingClient, DiagnosticLoggingKeys::hasPluginsKey());
141         isCacheable = false;
142     }
143     if (frame.isMainFrame() &amp;&amp; !frameLoader.history().currentItem()) {
144         PCLOG(&quot;   -Main frame has no current history item&quot;);
145         logBackForwardCacheFailureDiagnosticMessage(diagnosticLoggingClient, DiagnosticLoggingKeys::noCurrentHistoryItemKey());
146         isCacheable = false;
147     }
148     if (frame.isMainFrame() &amp;&amp; frame.view() &amp;&amp; !frame.view()-&gt;isVisuallyNonEmpty()) {
149         PCLOG(&quot;   -Main frame is visually empty&quot;);
150         logBackForwardCacheFailureDiagnosticMessage(diagnosticLoggingClient, DiagnosticLoggingKeys::visuallyEmptyKey());
151         isCacheable = false;
152     }
153     if (frameLoader.quickRedirectComing()) {
154         PCLOG(&quot;   -Quick redirect is coming&quot;);
155         logBackForwardCacheFailureDiagnosticMessage(diagnosticLoggingClient, DiagnosticLoggingKeys::quirkRedirectComingKey());
156         isCacheable = false;
157     }
158     if (documentLoader-&gt;isLoading()) {
159         PCLOG(&quot;   -DocumentLoader is still loading&quot;);
160         logBackForwardCacheFailureDiagnosticMessage(diagnosticLoggingClient, DiagnosticLoggingKeys::isLoadingKey());
161         isCacheable = false;
162     }
163     if (documentLoader-&gt;isStopping()) {
164         PCLOG(&quot;   -DocumentLoader is in the middle of stopping&quot;);
165         logBackForwardCacheFailureDiagnosticMessage(diagnosticLoggingClient, DiagnosticLoggingKeys::documentLoaderStoppingKey());
166         isCacheable = false;
167     }
168 
169     // FIXME: We should investigating caching frames that have an associated
170     // application cache. &lt;rdar://problem/5917899&gt; tracks that work.
171     if (!documentLoader-&gt;applicationCacheHost().canCacheInBackForwardCache()) {
172         PCLOG(&quot;   -The DocumentLoader uses an application cache&quot;);
173         logBackForwardCacheFailureDiagnosticMessage(diagnosticLoggingClient, DiagnosticLoggingKeys::applicationCacheKey());
174         isCacheable = false;
175     }
176     if (!frameLoader.client().canCachePage()) {
177         PCLOG(&quot;   -The client says this frame cannot be cached&quot;);
178         logBackForwardCacheFailureDiagnosticMessage(diagnosticLoggingClient, DiagnosticLoggingKeys::deniedByClientKey());
179         isCacheable = false;
180     }
181 
182     for (Frame* child = frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling()) {
183         if (!canCacheFrame(*child, diagnosticLoggingClient, indentLevel + 1))
184             isCacheable = false;
185     }
186 
187     PCLOG(isCacheable ? &quot; Frame CAN be cached&quot; : &quot; Frame CANNOT be cached&quot;);
188     PCLOG(&quot;+---&quot;);
189 
190     return isCacheable;
191 }
192 
193 static bool canCachePage(Page&amp; page)
194 {
195     RELEASE_ASSERT(!page.isRestoringCachedPage());
196 
197     unsigned indentLevel = 0;
198     PCLOG(&quot;--------\n Determining if page can be cached:&quot;);
199 
200     DiagnosticLoggingClient&amp; diagnosticLoggingClient = page.diagnosticLoggingClient();
201     bool isCacheable = canCacheFrame(page.mainFrame(), diagnosticLoggingClient, indentLevel + 1);
202 
203     if (!page.settings().usesBackForwardCache() || page.isResourceCachingDisabledByWebInspector()) {
204         PCLOG(&quot;   -Page settings says b/f cache disabled&quot;);
205         logBackForwardCacheFailureDiagnosticMessage(diagnosticLoggingClient, DiagnosticLoggingKeys::isDisabledKey());
206         isCacheable = false;
207     }
208 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; !PLATFORM(IOS_FAMILY)
209     if (DeviceMotionController::isActiveAt(&amp;page)) {
210         PCLOG(&quot;   -Page is using DeviceMotion&quot;);
211         logBackForwardCacheFailureDiagnosticMessage(diagnosticLoggingClient, DiagnosticLoggingKeys::deviceMotionKey());
212         isCacheable = false;
213     }
214     if (DeviceOrientationController::isActiveAt(&amp;page)) {
215         PCLOG(&quot;   -Page is using DeviceOrientation&quot;);
216         logBackForwardCacheFailureDiagnosticMessage(diagnosticLoggingClient, DiagnosticLoggingKeys::deviceOrientationKey());
217         isCacheable = false;
218     }
219 #endif
220 
221     FrameLoadType loadType = page.mainFrame().loader().loadType();
222     switch (loadType) {
223     case FrameLoadType::Reload:
224         // No point writing to the cache on a reload, since we will just write over it again when we leave that page.
225         PCLOG(&quot;   -Load type is: Reload&quot;);
226         logBackForwardCacheFailureDiagnosticMessage(diagnosticLoggingClient, DiagnosticLoggingKeys::reloadKey());
227         isCacheable = false;
228         break;
229     case FrameLoadType::Same: // user loads same URL again (but not reload button)
230         // No point writing to the cache on a same load, since we will just write over it again when we leave that page.
231         PCLOG(&quot;   -Load type is: Same&quot;);
232         logBackForwardCacheFailureDiagnosticMessage(diagnosticLoggingClient, DiagnosticLoggingKeys::sameLoadKey());
233         isCacheable = false;
234         break;
235     case FrameLoadType::RedirectWithLockedBackForwardList:
236         // Don&#39;t write to the cache if in the middle of a redirect, since we will want to store the final page we end up on.
237         PCLOG(&quot;   -Load type is: RedirectWithLockedBackForwardList&quot;);
238         logBackForwardCacheFailureDiagnosticMessage(diagnosticLoggingClient, DiagnosticLoggingKeys::redirectKey());
239         isCacheable = false;
240         break;
241     case FrameLoadType::Replace:
242         // No point writing to the cache on a replace, since we will just write over it again when we leave that page.
243         PCLOG(&quot;   -Load type is: Replace&quot;);
244         logBackForwardCacheFailureDiagnosticMessage(diagnosticLoggingClient, DiagnosticLoggingKeys::replaceKey());
245         isCacheable = false;
246         break;
247     case FrameLoadType::ReloadFromOrigin: {
248         // No point writing to the cache on a reload, since we will just write over it again when we leave that page.
249         PCLOG(&quot;   -Load type is: ReloadFromOrigin&quot;);
250         logBackForwardCacheFailureDiagnosticMessage(diagnosticLoggingClient, DiagnosticLoggingKeys::reloadFromOriginKey());
251         isCacheable = false;
252         break;
253     }
254     case FrameLoadType::ReloadExpiredOnly: {
255         // No point writing to the cache on a reload, since we will just write over it again when we leave that page.
256         PCLOG(&quot;   -Load type is: ReloadRevalidatingExpired&quot;);
257         logBackForwardCacheFailureDiagnosticMessage(diagnosticLoggingClient, DiagnosticLoggingKeys::reloadRevalidatingExpiredKey());
258         isCacheable = false;
259         break;
260     }
261     case FrameLoadType::Standard:
262     case FrameLoadType::Back:
263     case FrameLoadType::Forward:
264     case FrameLoadType::IndexedBackForward: // a multi-item hop in the backforward list
265         // Cacheable.
266         break;
267     }
268 
269     if (isCacheable)
270         PCLOG(&quot; Page CAN be cached\n--------&quot;);
271     else
272         PCLOG(&quot; Page CANNOT be cached\n--------&quot;);
273 
274     diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::backForwardCacheKey(), DiagnosticLoggingKeys::canCacheKey(), isCacheable ? DiagnosticLoggingResultPass : DiagnosticLoggingResultFail, ShouldSample::No);
275     return isCacheable;
276 }
277 
278 BackForwardCache&amp; BackForwardCache::singleton()
279 {
280     static NeverDestroyed&lt;BackForwardCache&gt; globalBackForwardCache;
281     return globalBackForwardCache;
282 }
283 
284 BackForwardCache::BackForwardCache()
285 {
286     static std::once_flag onceFlag;
287     std::call_once(onceFlag, [] {
288         PAL::registerNotifyCallback(&quot;com.apple.WebKit.showBackForwardCache&quot;, [] {
289             BackForwardCache::singleton().dump();
290         });
291     });
292 }
293 
294 void BackForwardCache::dump() const
295 {
296     WTFLogAlways(&quot;Back/Forward Cache:&quot;);
297     for (auto&amp; item : m_items) {
298         CachedPage&amp; cachedPage = *item-&gt;m_cachedPage;
299         WTFLogAlways(&quot;  Page %p, document %p %s&quot;, &amp;cachedPage.page(), cachedPage.document(), cachedPage.document() ? cachedPage.document()-&gt;url().string().utf8().data() : &quot;&quot;);
300     }
301 }
302 
303 bool BackForwardCache::canCache(Page&amp; page) const
304 {
305     if (!m_maxSize) {
306         logBackForwardCacheFailureDiagnosticMessage(&amp;page, DiagnosticLoggingKeys::isDisabledKey());
307         return false;
308     }
309 
310     if (MemoryPressureHandler::singleton().isUnderMemoryPressure()) {
311         logBackForwardCacheFailureDiagnosticMessage(&amp;page, DiagnosticLoggingKeys::underMemoryPressureKey());
312         return false;
313     }
314 
315     return canCachePage(page);
316 }
317 
318 void BackForwardCache::pruneToSizeNow(unsigned size, PruningReason pruningReason)
319 {
320     SetForScope&lt;unsigned&gt; change(m_maxSize, size);
321     prune(pruningReason);
322 }
323 
324 void BackForwardCache::setMaxSize(unsigned maxSize)
325 {
326     m_maxSize = maxSize;
327     prune(PruningReason::None);
328 }
329 
330 unsigned BackForwardCache::frameCount() const
331 {
332     unsigned frameCount = m_items.size();
333     for (auto&amp; item : m_items) {
334         ASSERT(item-&gt;m_cachedPage);
335         frameCount += item-&gt;m_cachedPage-&gt;cachedMainFrame()-&gt;descendantFrameCount();
336     }
337 
338     return frameCount;
339 }
340 
341 void BackForwardCache::markPagesForDeviceOrPageScaleChanged(Page&amp; page)
342 {
343     for (auto&amp; item : m_items) {
344         CachedPage&amp; cachedPage = *item-&gt;m_cachedPage;
345         if (&amp;page.mainFrame() == &amp;cachedPage.cachedMainFrame()-&gt;view()-&gt;frame())
346             cachedPage.markForDeviceOrPageScaleChanged();
347     }
348 }
349 
350 void BackForwardCache::markPagesForContentsSizeChanged(Page&amp; page)
351 {
352     for (auto&amp; item : m_items) {
353         CachedPage&amp; cachedPage = *item-&gt;m_cachedPage;
354         if (&amp;page.mainFrame() == &amp;cachedPage.cachedMainFrame()-&gt;view()-&gt;frame())
355             cachedPage.markForContentsSizeChanged();
356     }
357 }
358 
359 #if ENABLE(VIDEO_TRACK)
360 void BackForwardCache::markPagesForCaptionPreferencesChanged()
361 {
362     for (auto&amp; item : m_items) {
363         ASSERT(item-&gt;m_cachedPage);
364         item-&gt;m_cachedPage-&gt;markForCaptionPreferencesChanged();
365     }
366 }
367 #endif
368 
369 static String pruningReasonToDiagnosticLoggingKey(PruningReason pruningReason)
370 {
371     switch (pruningReason) {
372     case PruningReason::MemoryPressure:
373         return DiagnosticLoggingKeys::prunedDueToMemoryPressureKey();
374     case PruningReason::ProcessSuspended:
375         return DiagnosticLoggingKeys::prunedDueToProcessSuspended();
376     case PruningReason::ReachedMaxSize:
377         return DiagnosticLoggingKeys::prunedDueToMaxSizeReached();
378     case PruningReason::None:
379         break;
380     }
381     ASSERT_NOT_REACHED();
382     return emptyString();
383 }
384 
385 static void setBackForwardCacheState(Page&amp; page, Document::BackForwardCacheState BackForwardCacheState)
386 {
387     for (Frame* frame = &amp;page.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
388         if (auto* document = frame-&gt;document())
389             document-&gt;setBackForwardCacheState(BackForwardCacheState);
390     }
391 }
392 
393 // When entering back/forward cache, tear down the render tree before setting the in-cache flag.
394 // This maintains the invariant that render trees are never present in the back/forward cache.
395 // Note that destruction happens bottom-up so that the main frame&#39;s tree dies last.
396 static void destroyRenderTree(Frame&amp; mainFrame)
397 {
398     for (Frame* frame = mainFrame.tree().traversePrevious(CanWrap::Yes); frame; frame = frame-&gt;tree().traversePrevious(CanWrap::No)) {
399         if (!frame-&gt;document())
400             continue;
401         auto&amp; document = *frame-&gt;document();
402         if (document.hasLivingRenderTree())
403             document.destroyRenderTree();
404     }
405 }
406 
407 static void firePageHideEventRecursively(Frame&amp; frame)
408 {
409     auto* document = frame.document();
410     if (!document)
411         return;
412 
413     // stopLoading() will fire the pagehide event in each subframe and the HTML specification states
414     // that the parent document&#39;s ignore-opens-during-unload counter should be incremented while the
415     // pagehide event is being fired in its subframes:
416     // https://html.spec.whatwg.org/multipage/browsers.html#unload-a-document
417     IgnoreOpensDuringUnloadCountIncrementer ignoreOpensDuringUnloadCountIncrementer(document);
418 
419     frame.loader().stopLoading(UnloadEventPolicyUnloadAndPageHide);
420 
421     for (RefPtr&lt;Frame&gt; child = frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling())
422         firePageHideEventRecursively(*child);
423 }
424 
425 bool BackForwardCache::addIfCacheable(HistoryItem&amp; item, Page* page)
426 {
427     if (item.isInBackForwardCache())
428         return false;
429 
430     if (!page)
431         return false;
432 
433     page-&gt;mainFrame().loader().stopForBackForwardCache();
434 
435     if (!canCache(*page))
436         return false;
437 
438     ASSERT_WITH_MESSAGE(!page-&gt;isUtilityPage(), &quot;Utility pages such as SVGImage pages should never go into BackForwardCache&quot;);
439 
440     setBackForwardCacheState(*page, Document::AboutToEnterBackForwardCache);
441 
442     // Focus the main frame, defocusing a focused subframe (if we have one). We do this here,
443     // before the page enters the back/forward cache, while we still can dispatch DOM blur/focus events.
444     if (page-&gt;focusController().focusedFrame())
445         page-&gt;focusController().setFocusedFrame(&amp;page-&gt;mainFrame());
446 
447     // Fire the pagehide event in all frames.
448     firePageHideEventRecursively(page-&gt;mainFrame());
449 
450     destroyRenderTree(page-&gt;mainFrame());
451 
452     // Stop all loads again before checking if we can still cache the page after firing the pagehide
453     // event, since the page may have started ping loads in its pagehide event handler.
454     page-&gt;mainFrame().loader().stopForBackForwardCache();
455 
456     // Check that the page is still page-cacheable after firing the pagehide event. The JS event handlers
457     // could have altered the page in a way that could prevent caching.
458     if (!canCache(*page)) {
459         setBackForwardCacheState(*page, Document::NotInBackForwardCache);
460         return false;
461     }
462 
463     setBackForwardCacheState(*page, Document::InBackForwardCache);
464 
465     {
466         // Make sure we don&#39;t fire any JS events in this scope.
467         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
468 
469         item.setCachedPage(makeUnique&lt;CachedPage&gt;(*page));
470         item.m_pruningReason = PruningReason::None;
471         m_items.add(&amp;item);
472     }
473     prune(PruningReason::ReachedMaxSize);
474 
475     RELEASE_LOG(BackForwardCache, &quot;BackForwardCache::addIfCacheable item: %s, size: %u / %u&quot;, item.identifier().string().utf8().data(), pageCount(), maxSize());
476 
477     return true;
478 }
479 
480 std::unique_ptr&lt;CachedPage&gt; BackForwardCache::take(HistoryItem&amp; item, Page* page)
481 {
482     if (!item.m_cachedPage) {
483         if (item.m_pruningReason != PruningReason::None)
484             logBackForwardCacheFailureDiagnosticMessage(page, pruningReasonToDiagnosticLoggingKey(item.m_pruningReason));
485         return nullptr;
486     }
487 
488     m_items.remove(&amp;item);
489     std::unique_ptr&lt;CachedPage&gt; cachedPage = item.takeCachedPage();
490 
491     RELEASE_LOG(BackForwardCache, &quot;BackForwardCache::take item: %s, size: %u / %u&quot;, item.identifier().string().utf8().data(), pageCount(), maxSize());
492 
493     if (cachedPage-&gt;hasExpired() || (page &amp;&amp; page-&gt;isResourceCachingDisabledByWebInspector())) {
494         LOG(BackForwardCache, &quot;Not restoring page for %s from back/forward cache because cache entry has expired&quot;, item.url().string().ascii().data());
495         logBackForwardCacheFailureDiagnosticMessage(page, DiagnosticLoggingKeys::expiredKey());
496         return nullptr;
497     }
498 
499     return cachedPage;
500 }
501 
502 void BackForwardCache::removeAllItemsForPage(Page&amp; page)
503 {
504 #if ASSERT_ENABLED
505     ASSERT_WITH_MESSAGE(!m_isInRemoveAllItemsForPage, &quot;We should not reenter this method&quot;);
506     SetForScope&lt;bool&gt; inRemoveAllItemsForPageScope { m_isInRemoveAllItemsForPage, true };
507 #endif
508 
509     for (auto it = m_items.begin(); it != m_items.end();) {
510         // Increment iterator first so it stays valid after the removal.
511         auto current = it;
512         ++it;
513         if (&amp;(*current)-&gt;m_cachedPage-&gt;page() == &amp;page) {
514             RELEASE_LOG(BackForwardCache, &quot;BackForwardCache::removeAllItemsForPage removing item: %s, size: %u / %u&quot;, (*current)-&gt;identifier().string().utf8().data(), pageCount() - 1, maxSize());
515             (*current)-&gt;setCachedPage(nullptr);
516             m_items.remove(current);
517         }
518     }
519 }
520 
521 CachedPage* BackForwardCache::get(HistoryItem&amp; item, Page* page)
522 {
523     CachedPage* cachedPage = item.m_cachedPage.get();
524     if (!cachedPage) {
525         if (item.m_pruningReason != PruningReason::None)
526             logBackForwardCacheFailureDiagnosticMessage(page, pruningReasonToDiagnosticLoggingKey(item.m_pruningReason));
527         return nullptr;
528     }
529 
530     if (cachedPage-&gt;hasExpired() || (page &amp;&amp; page-&gt;isResourceCachingDisabledByWebInspector())) {
531         LOG(BackForwardCache, &quot;Not restoring page for %s from back/forward cache because cache entry has expired&quot;, item.url().string().ascii().data());
532         logBackForwardCacheFailureDiagnosticMessage(page, DiagnosticLoggingKeys::expiredKey());
533         remove(item);
534         return nullptr;
535     }
536     return cachedPage;
537 }
538 
539 void BackForwardCache::remove(HistoryItem&amp; item)
540 {
541     // Safely ignore attempts to remove items not in the cache.
542     if (!item.m_cachedPage)
543         return;
544 
545     m_items.remove(&amp;item);
546     item.setCachedPage(nullptr);
547 
548     RELEASE_LOG(BackForwardCache, &quot;BackForwardCache::remove item: %s, size: %u / %u&quot;, item.identifier().string().utf8().data(), pageCount(), maxSize());
549 
550 }
551 
552 void BackForwardCache::prune(PruningReason pruningReason)
553 {
554     while (pageCount() &gt; maxSize()) {
555         auto oldestItem = m_items.takeFirst();
556         oldestItem-&gt;setCachedPage(nullptr);
557         oldestItem-&gt;m_pruningReason = pruningReason;
558         RELEASE_LOG(BackForwardCache, &quot;BackForwardCache::prune removing item: %s, size: %u / %u&quot;, oldestItem-&gt;identifier().string().utf8().data(), pageCount(), maxSize());
559     }
560 }
561 
562 } // namespace WebCore
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/AtomicsObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AsyncIteratorPrototype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AtomicsObject.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/AtomicsObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 35 
 36 namespace JSC {
 37 
 38 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(AtomicsObject);
 39 
 40 #define FOR_EACH_ATOMICS_FUNC(macro)                                    \
 41     macro(add, Add, 3)                                                  \
 42     macro(and, And, 3)                                                  \
 43     macro(compareExchange, CompareExchange, 4)                          \
 44     macro(exchange, Exchange, 3)                                        \
 45     macro(isLockFree, IsLockFree, 1)                                    \
 46     macro(load, Load, 2)                                                \
 47     macro(or, Or, 3)                                                    \
 48     macro(store, Store, 3)                                              \
 49     macro(sub, Sub, 3)                                                  \
 50     macro(wait, Wait, 4)                                                \
 51     macro(wake, Wake, 3)                                                \
 52     macro(xor, Xor, 3)
 53 
 54 #define DECLARE_FUNC_PROTO(lowerName, upperName, count)                 \
<span class="line-modified"> 55     EncodedJSValue JSC_HOST_CALL atomicsFunc ## upperName(ExecState*);</span>
 56 FOR_EACH_ATOMICS_FUNC(DECLARE_FUNC_PROTO)
 57 #undef DECLARE_FUNC_PROTO
 58 
 59 const ClassInfo AtomicsObject::s_info = { &quot;Atomics&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(AtomicsObject) };
 60 
 61 AtomicsObject::AtomicsObject(VM&amp; vm, Structure* structure)
 62     : JSNonFinalObject(vm, structure)
 63 {
 64 }
 65 
 66 AtomicsObject* AtomicsObject::create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 67 {
 68     AtomicsObject* object = new (NotNull, allocateCell&lt;AtomicsObject&gt;(vm.heap)) AtomicsObject(vm, structure);
 69     object-&gt;finishCreation(vm, globalObject);
 70     return object;
 71 }
 72 
 73 Structure* AtomicsObject::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 74 {
 75     return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 76 }
 77 
 78 void AtomicsObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 79 {
 80     Base::finishCreation(vm);
 81     ASSERT(inherits(vm, info()));
 82 
 83 #define PUT_DIRECT_NATIVE_FUNC(lowerName, upperName, count) \
 84     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, #lowerName), count, atomicsFunc ## upperName, Atomics ## upperName ## Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 85     FOR_EACH_ATOMICS_FUNC(PUT_DIRECT_NATIVE_FUNC)
 86 #undef PUT_DIRECT_NATIVE_FUNC
 87 }
 88 
 89 namespace {
 90 
 91 template&lt;typename Adaptor, typename Func&gt;
<span class="line-modified"> 92 EncodedJSValue atomicOperationWithArgsCase(ExecState* exec, const JSValue* args, ThrowScope&amp; scope, JSArrayBufferView* typedArrayView, unsigned accessIndex, const Func&amp; func)</span>
 93 {
 94     JSGenericTypedArrayView&lt;Adaptor&gt;* typedArray = jsCast&lt;JSGenericTypedArrayView&lt;Adaptor&gt;*&gt;(typedArrayView);
 95 
 96     double extraArgs[Func::numExtraArgs + 1]; // Add 1 to avoid 0 size array error in VS.
 97     for (unsigned i = 0; i &lt; Func::numExtraArgs; ++i) {
<span class="line-modified"> 98         double value = args[2 + i].toInteger(exec);</span>
 99         RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
100         extraArgs[i] = value;
101     }
102 
103     return JSValue::encode(func(typedArray-&gt;typedVector() + accessIndex, extraArgs));
104 }
105 
<span class="line-modified">106 unsigned validatedAccessIndex(VM&amp; vm, ExecState* exec, JSValue accessIndexValue, JSArrayBufferView* typedArrayView)</span>
107 {
108     auto scope = DECLARE_THROW_SCOPE(vm);
109     if (UNLIKELY(!accessIndexValue.isInt32())) {
<span class="line-modified">110         double accessIndexDouble = accessIndexValue.toNumber(exec);</span>
111         RETURN_IF_EXCEPTION(scope, 0);
112         if (accessIndexDouble == 0)
113             accessIndexValue = jsNumber(0);
114         else {
115             accessIndexValue = jsNumber(accessIndexDouble);
116             if (!accessIndexValue.isInt32()) {
<span class="line-modified">117                 throwRangeError(exec, scope, &quot;Access index is not an integer.&quot;_s);</span>
118                 return 0;
119             }
120         }
121     }
122     int32_t accessIndex = accessIndexValue.asInt32();
123 
124     ASSERT(typedArrayView-&gt;length() &lt;= static_cast&lt;unsigned&gt;(INT_MAX));
125     if (static_cast&lt;unsigned&gt;(accessIndex) &gt;= typedArrayView-&gt;length()) {
<span class="line-modified">126         throwRangeError(exec, scope, &quot;Access index out of bounds for atomic access.&quot;_s);</span>
127         return 0;
128     }
129 
130     return accessIndex;
131 }
132 
133 template&lt;typename Func&gt;
<span class="line-modified">134 EncodedJSValue atomicOperationWithArgs(VM&amp; vm, ExecState* exec, const JSValue* args, const Func&amp; func)</span>
135 {
136     auto scope = DECLARE_THROW_SCOPE(vm);
137 
138     JSValue typedArrayValue = args[0];
139     if (!typedArrayValue.isCell()) {
<span class="line-modified">140         throwTypeError(exec, scope, &quot;Typed array argument must be a cell.&quot;_s);</span>
141         return JSValue::encode(jsUndefined());
142     }
143 
144     JSCell* typedArrayCell = typedArrayValue.asCell();
145 
146     JSType type = typedArrayCell-&gt;type();
147     switch (type) {
148     case Int8ArrayType:
149     case Int16ArrayType:
150     case Int32ArrayType:
151     case Uint8ArrayType:
152     case Uint16ArrayType:
153     case Uint32ArrayType:
154         break;
155     default:
<span class="line-modified">156         throwTypeError(exec, scope, &quot;Typed array argument must be an Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, or Uint32Array.&quot;_s);</span>
157         return JSValue::encode(jsUndefined());
158     }
159 
160     JSArrayBufferView* typedArrayView = jsCast&lt;JSArrayBufferView*&gt;(typedArrayCell);
161     if (!typedArrayView-&gt;isShared()) {
<span class="line-modified">162         throwTypeError(exec, scope, &quot;Typed array argument must wrap a SharedArrayBuffer.&quot;_s);</span>
163         return JSValue::encode(jsUndefined());
164     }
165 
<span class="line-modified">166     unsigned accessIndex = validatedAccessIndex(vm, exec, args[1], typedArrayView);</span>
167     RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
168 
169     switch (type) {
170     case Int8ArrayType:
<span class="line-modified">171         return atomicOperationWithArgsCase&lt;Int8Adaptor&gt;(exec, args, scope, typedArrayView, accessIndex, func);</span>
172     case Int16ArrayType:
<span class="line-modified">173         return atomicOperationWithArgsCase&lt;Int16Adaptor&gt;(exec, args, scope, typedArrayView, accessIndex, func);</span>
174     case Int32ArrayType:
<span class="line-modified">175         return atomicOperationWithArgsCase&lt;Int32Adaptor&gt;(exec, args, scope, typedArrayView, accessIndex, func);</span>
176     case Uint8ArrayType:
<span class="line-modified">177         return atomicOperationWithArgsCase&lt;Uint8Adaptor&gt;(exec, args, scope, typedArrayView, accessIndex, func);</span>
178     case Uint16ArrayType:
<span class="line-modified">179         return atomicOperationWithArgsCase&lt;Uint16Adaptor&gt;(exec, args, scope, typedArrayView, accessIndex, func);</span>
180     case Uint32ArrayType:
<span class="line-modified">181         return atomicOperationWithArgsCase&lt;Uint32Adaptor&gt;(exec, args, scope, typedArrayView, accessIndex, func);</span>
182     default:
183         RELEASE_ASSERT_NOT_REACHED();
184         return JSValue::encode(jsUndefined());
185     }
186 }
187 
188 template&lt;typename Func&gt;
<span class="line-modified">189 EncodedJSValue atomicOperationWithArgs(ExecState* exec, const Func&amp; func)</span>
190 {
191     JSValue args[2 + Func::numExtraArgs];
192     for (unsigned i = 2 + Func::numExtraArgs; i--;)
<span class="line-modified">193         args[i] = exec-&gt;argument(i);</span>
<span class="line-modified">194     return atomicOperationWithArgs(exec-&gt;vm(), exec, args, func);</span>
195 }
196 
197 struct AddFunc {
<span class="line-modified">198     static const unsigned numExtraArgs = 1;</span>
199 
200     template&lt;typename T&gt;
201     JSValue operator()(T* ptr, const double* args) const
202     {
203         return jsNumber(WTF::atomicExchangeAdd(ptr, toInt32(args[0])));
204     }
205 };
206 
207 struct AndFunc {
<span class="line-modified">208     static const unsigned numExtraArgs = 1;</span>
209 
210     template&lt;typename T&gt;
211     JSValue operator()(T* ptr, const double* args) const
212     {
213         return jsNumber(WTF::atomicExchangeAnd(ptr, toInt32(args[0])));
214     }
215 };
216 
217 struct CompareExchangeFunc {
<span class="line-modified">218     static const unsigned numExtraArgs = 2;</span>
219 
220     template&lt;typename T&gt;
221     JSValue operator()(T* ptr, const double* args) const
222     {
223         T expected = static_cast&lt;T&gt;(toInt32(args[0]));
224         T newValue = static_cast&lt;T&gt;(toInt32(args[1]));
225         return jsNumber(WTF::atomicCompareExchangeStrong(ptr, expected, newValue));
226     }
227 };
228 
229 struct ExchangeFunc {
<span class="line-modified">230     static const unsigned numExtraArgs = 1;</span>
231 
232     template&lt;typename T&gt;
233     JSValue operator()(T* ptr, const double* args) const
234     {
235         return jsNumber(WTF::atomicExchange(ptr, static_cast&lt;T&gt;(toInt32(args[0]))));
236     }
237 };
238 
239 struct LoadFunc {
<span class="line-modified">240     static const unsigned numExtraArgs = 0;</span>
241 
242     template&lt;typename T&gt;
243     JSValue operator()(T* ptr, const double*) const
244     {
245         return jsNumber(WTF::atomicLoadFullyFenced(ptr));
246     }
247 };
248 
249 struct OrFunc {
<span class="line-modified">250     static const unsigned numExtraArgs = 1;</span>
251 
252     template&lt;typename T&gt;
253     JSValue operator()(T* ptr, const double* args) const
254     {
255         return jsNumber(WTF::atomicExchangeOr(ptr, toInt32(args[0])));
256     }
257 };
258 
259 struct StoreFunc {
<span class="line-modified">260     static const unsigned numExtraArgs = 1;</span>
261 
262     template&lt;typename T&gt;
263     JSValue operator()(T* ptr, const double* args) const
264     {
265         double valueAsInt = args[0];
266         T valueAsT = static_cast&lt;T&gt;(toInt32(valueAsInt));
267         WTF::atomicStoreFullyFenced(ptr, valueAsT);
268         return jsNumber(valueAsInt);
269     }
270 };
271 
272 struct SubFunc {
<span class="line-modified">273     static const unsigned numExtraArgs = 1;</span>
274 
275     template&lt;typename T&gt;
276     JSValue operator()(T* ptr, const double* args) const
277     {
278         return jsNumber(WTF::atomicExchangeSub(ptr, toInt32(args[0])));
279     }
280 };
281 
282 struct XorFunc {
<span class="line-modified">283     static const unsigned numExtraArgs = 1;</span>
284 
285     template&lt;typename T&gt;
286     JSValue operator()(T* ptr, const double* args) const
287     {
288         return jsNumber(WTF::atomicExchangeXor(ptr, toInt32(args[0])));
289     }
290 };
291 
<span class="line-modified">292 EncodedJSValue isLockFree(ExecState* exec, JSValue arg)</span>
293 {
<span class="line-modified">294     VM&amp; vm = exec-&gt;vm();</span>
295     auto scope = DECLARE_THROW_SCOPE(vm);
296 
<span class="line-modified">297     int32_t size = arg.toInt32(exec);</span>
298     RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
299 
300     bool result;
301     switch (size) {
302     case 1:
303     case 2:
304     case 4:
305         result = true;
306         break;
307     default:
308         result = false;
309         break;
310     }
311     return JSValue::encode(jsBoolean(result));
312 }
313 
314 } // anonymous namespace
315 
<span class="line-modified">316 EncodedJSValue JSC_HOST_CALL atomicsFuncAdd(ExecState* exec)</span>
317 {
<span class="line-modified">318     return atomicOperationWithArgs(exec, AddFunc());</span>
319 }
320 
<span class="line-modified">321 EncodedJSValue JSC_HOST_CALL atomicsFuncAnd(ExecState* exec)</span>
322 {
<span class="line-modified">323     return atomicOperationWithArgs(exec, AndFunc());</span>
324 }
325 
<span class="line-modified">326 EncodedJSValue JSC_HOST_CALL atomicsFuncCompareExchange(ExecState* exec)</span>
327 {
<span class="line-modified">328     return atomicOperationWithArgs(exec, CompareExchangeFunc());</span>
329 }
330 
<span class="line-modified">331 EncodedJSValue JSC_HOST_CALL atomicsFuncExchange(ExecState* exec)</span>
332 {
<span class="line-modified">333     return atomicOperationWithArgs(exec, ExchangeFunc());</span>
334 }
335 
<span class="line-modified">336 EncodedJSValue JSC_HOST_CALL atomicsFuncIsLockFree(ExecState* exec)</span>
337 {
<span class="line-modified">338     return isLockFree(exec, exec-&gt;argument(0));</span>
339 }
340 
<span class="line-modified">341 EncodedJSValue JSC_HOST_CALL atomicsFuncLoad(ExecState* exec)</span>
342 {
<span class="line-modified">343     return atomicOperationWithArgs(exec, LoadFunc());</span>
344 }
345 
<span class="line-modified">346 EncodedJSValue JSC_HOST_CALL atomicsFuncOr(ExecState* exec)</span>
347 {
<span class="line-modified">348     return atomicOperationWithArgs(exec, OrFunc());</span>
349 }
350 
<span class="line-modified">351 EncodedJSValue JSC_HOST_CALL atomicsFuncStore(ExecState* exec)</span>
352 {
<span class="line-modified">353     return atomicOperationWithArgs(exec, StoreFunc());</span>
354 }
355 
<span class="line-modified">356 EncodedJSValue JSC_HOST_CALL atomicsFuncSub(ExecState* exec)</span>
357 {
<span class="line-modified">358     return atomicOperationWithArgs(exec, SubFunc());</span>
359 }
360 
<span class="line-modified">361 EncodedJSValue JSC_HOST_CALL atomicsFuncWait(ExecState* exec)</span>
362 {
<span class="line-modified">363     VM&amp; vm = exec-&gt;vm();</span>
364     auto scope = DECLARE_THROW_SCOPE(vm);
365 
<span class="line-modified">366     JSInt32Array* typedArray = jsDynamicCast&lt;JSInt32Array*&gt;(vm, exec-&gt;argument(0));</span>
367     if (!typedArray) {
<span class="line-modified">368         throwTypeError(exec, scope, &quot;Typed array for wait/wake must be an Int32Array.&quot;_s);</span>
369         return JSValue::encode(jsUndefined());
370     }
371 
372     if (!typedArray-&gt;isShared()) {
<span class="line-modified">373         throwTypeError(exec, scope, &quot;Typed array for wait/wake must wrap a SharedArrayBuffer.&quot;_s);</span>
374         return JSValue::encode(jsUndefined());
375     }
376 
<span class="line-modified">377     unsigned accessIndex = validatedAccessIndex(vm, exec, exec-&gt;argument(1), typedArray);</span>
378     RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
379 
380     int32_t* ptr = typedArray-&gt;typedVector() + accessIndex;
381 
<span class="line-modified">382     int32_t expectedValue = exec-&gt;argument(2).toInt32(exec);</span>
383     RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
384 
<span class="line-modified">385     double timeoutInMilliseconds = exec-&gt;argument(3).toNumber(exec);</span>
386     RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
387 
388     if (!vm.m_typedArrayController-&gt;isAtomicsWaitAllowedOnCurrentThread()) {
<span class="line-modified">389         throwTypeError(exec, scope, &quot;Atomics.wait cannot be called from the current thread.&quot;_s);</span>
390         return JSValue::encode(jsUndefined());
391     }
392 
393     Seconds timeout = Seconds::fromMilliseconds(timeoutInMilliseconds);
394 
395     // This covers the proposed rule:
396     //
397     // 4. If timeout is not provided or is undefined then let t be +inf. Otherwise:
398     //     a. Let q be ? ToNumber(timeout).
399     //     b. If q is NaN then let t be +inf, otherwise let t be max(0, q).
400     //
<span class="line-modified">401     // exec-&gt;argument(3) returns undefined if it&#39;s not provided and ToNumber(undefined) returns NaN,</span>
402     // so NaN is the only special case.
403     if (!std::isnan(timeout))
404         timeout = std::max(0_s, timeout);
405     else
406         timeout = Seconds::infinity();
407 
408     bool didPassValidation = false;
409     ParkingLot::ParkResult result;
410     {
411         ReleaseHeapAccessScope releaseHeapAccessScope(vm.heap);
412         result = ParkingLot::parkConditionally(
413             ptr,
414             [&amp;] () -&gt; bool {
415                 didPassValidation = WTF::atomicLoad(ptr) == expectedValue;
416                 return didPassValidation;
417             },
418             [] () { },
419             MonotonicTime::now() + timeout);
420     }
421     const char* resultString;
422     if (!didPassValidation)
423         resultString = &quot;not-equal&quot;;
424     else if (!result.wasUnparked)
425         resultString = &quot;timed-out&quot;;
426     else
427         resultString = &quot;ok&quot;;
428     return JSValue::encode(jsString(vm, resultString));
429 }
430 
<span class="line-modified">431 EncodedJSValue JSC_HOST_CALL atomicsFuncWake(ExecState* exec)</span>
432 {
<span class="line-modified">433     VM&amp; vm = exec-&gt;vm();</span>
434     auto scope = DECLARE_THROW_SCOPE(vm);
435 
<span class="line-modified">436     JSInt32Array* typedArray = jsDynamicCast&lt;JSInt32Array*&gt;(vm, exec-&gt;argument(0));</span>
437     if (!typedArray) {
<span class="line-modified">438         throwTypeError(exec, scope, &quot;Typed array for wait/wake must be an Int32Array.&quot;_s);</span>
439         return JSValue::encode(jsUndefined());
440     }
441 
442     if (!typedArray-&gt;isShared()) {
<span class="line-modified">443         throwTypeError(exec, scope, &quot;Typed array for wait/wake must wrap a SharedArrayBuffer.&quot;_s);</span>
444         return JSValue::encode(jsUndefined());
445     }
446 
<span class="line-modified">447     unsigned accessIndex = validatedAccessIndex(vm, exec, exec-&gt;argument(1), typedArray);</span>
448     RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
449 
450     int32_t* ptr = typedArray-&gt;typedVector() + accessIndex;
451 
<span class="line-modified">452     JSValue countValue = exec-&gt;argument(2);</span>
453     unsigned count = UINT_MAX;
454     if (!countValue.isUndefined()) {
<span class="line-modified">455         int32_t countInt = countValue.toInt32(exec);</span>
456         RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
457         count = std::max(0, countInt);
458     }
459 
460     return JSValue::encode(jsNumber(ParkingLot::unparkCount(ptr, count)));
461 }
462 
<span class="line-modified">463 EncodedJSValue JSC_HOST_CALL atomicsFuncXor(ExecState* exec)</span>
464 {
<span class="line-modified">465     return atomicOperationWithArgs(exec, XorFunc());</span>
466 }
467 
<span class="line-modified">468 EncodedJSValue JIT_OPERATION operationAtomicsAdd(ExecState* exec, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>


469 {
<span class="line-modified">470     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">471     NativeCallFrameTracer tracer(vm, exec);</span>

472     JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">473     return atomicOperationWithArgs(vm, exec, args, AddFunc());</span>
474 }
475 
<span class="line-modified">476 EncodedJSValue JIT_OPERATION operationAtomicsAnd(ExecState* exec, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
477 {
<span class="line-modified">478     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">479     NativeCallFrameTracer tracer(vm, exec);</span>

480     JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">481     return atomicOperationWithArgs(vm, exec, args, AndFunc());</span>
482 }
483 
<span class="line-modified">484 EncodedJSValue JIT_OPERATION operationAtomicsCompareExchange(ExecState* exec, EncodedJSValue base, EncodedJSValue index, EncodedJSValue expected, EncodedJSValue newValue)</span>
485 {
<span class="line-modified">486     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">487     NativeCallFrameTracer tracer(vm, exec);</span>

488     JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(expected), JSValue::decode(newValue)};
<span class="line-modified">489     return atomicOperationWithArgs(vm, exec, args, CompareExchangeFunc());</span>
490 }
491 
<span class="line-modified">492 EncodedJSValue JIT_OPERATION operationAtomicsExchange(ExecState* exec, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
493 {
<span class="line-modified">494     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">495     NativeCallFrameTracer tracer(vm, exec);</span>

496     JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">497     return atomicOperationWithArgs(vm, exec, args, ExchangeFunc());</span>
498 }
499 
<span class="line-modified">500 EncodedJSValue JIT_OPERATION operationAtomicsIsLockFree(ExecState* exec, EncodedJSValue size)</span>
501 {
<span class="line-modified">502     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">503     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">504     return isLockFree(exec, JSValue::decode(size));</span>

505 }
506 
<span class="line-modified">507 EncodedJSValue JIT_OPERATION operationAtomicsLoad(ExecState* exec, EncodedJSValue base, EncodedJSValue index)</span>
508 {
<span class="line-modified">509     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">510     NativeCallFrameTracer tracer(vm, exec);</span>

511     JSValue args[] = {JSValue::decode(base), JSValue::decode(index)};
<span class="line-modified">512     return atomicOperationWithArgs(vm, exec, args, LoadFunc());</span>
513 }
514 
<span class="line-modified">515 EncodedJSValue JIT_OPERATION operationAtomicsOr(ExecState* exec, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
516 {
<span class="line-modified">517     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">518     NativeCallFrameTracer tracer(vm, exec);</span>

519     JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">520     return atomicOperationWithArgs(vm, exec, args, OrFunc());</span>
521 }
522 
<span class="line-modified">523 EncodedJSValue JIT_OPERATION operationAtomicsStore(ExecState* exec, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
524 {
<span class="line-modified">525     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">526     NativeCallFrameTracer tracer(vm, exec);</span>

527     JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">528     return atomicOperationWithArgs(vm, exec, args, StoreFunc());</span>
529 }
530 
<span class="line-modified">531 EncodedJSValue JIT_OPERATION operationAtomicsSub(ExecState* exec, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
532 {
<span class="line-modified">533     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">534     NativeCallFrameTracer tracer(vm, exec);</span>

535     JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">536     return atomicOperationWithArgs(vm, exec, args, SubFunc());</span>
537 }
538 
<span class="line-modified">539 EncodedJSValue JIT_OPERATION operationAtomicsXor(ExecState* exec, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
540 {
<span class="line-modified">541     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">542     NativeCallFrameTracer tracer(vm, exec);</span>

543     JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">544     return atomicOperationWithArgs(vm, exec, args, XorFunc());</span>
545 }
546 


547 } // namespace JSC
548 
</pre>
</td>
<td>
<hr />
<pre>
 35 
 36 namespace JSC {
 37 
 38 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(AtomicsObject);
 39 
 40 #define FOR_EACH_ATOMICS_FUNC(macro)                                    \
 41     macro(add, Add, 3)                                                  \
 42     macro(and, And, 3)                                                  \
 43     macro(compareExchange, CompareExchange, 4)                          \
 44     macro(exchange, Exchange, 3)                                        \
 45     macro(isLockFree, IsLockFree, 1)                                    \
 46     macro(load, Load, 2)                                                \
 47     macro(or, Or, 3)                                                    \
 48     macro(store, Store, 3)                                              \
 49     macro(sub, Sub, 3)                                                  \
 50     macro(wait, Wait, 4)                                                \
 51     macro(wake, Wake, 3)                                                \
 52     macro(xor, Xor, 3)
 53 
 54 #define DECLARE_FUNC_PROTO(lowerName, upperName, count)                 \
<span class="line-modified"> 55     EncodedJSValue JSC_HOST_CALL atomicsFunc ## upperName(JSGlobalObject*, CallFrame*);</span>
 56 FOR_EACH_ATOMICS_FUNC(DECLARE_FUNC_PROTO)
 57 #undef DECLARE_FUNC_PROTO
 58 
 59 const ClassInfo AtomicsObject::s_info = { &quot;Atomics&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(AtomicsObject) };
 60 
 61 AtomicsObject::AtomicsObject(VM&amp; vm, Structure* structure)
 62     : JSNonFinalObject(vm, structure)
 63 {
 64 }
 65 
 66 AtomicsObject* AtomicsObject::create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 67 {
 68     AtomicsObject* object = new (NotNull, allocateCell&lt;AtomicsObject&gt;(vm.heap)) AtomicsObject(vm, structure);
 69     object-&gt;finishCreation(vm, globalObject);
 70     return object;
 71 }
 72 
 73 Structure* AtomicsObject::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 74 {
 75     return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 76 }
 77 
 78 void AtomicsObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 79 {
 80     Base::finishCreation(vm);
 81     ASSERT(inherits(vm, info()));
 82 
 83 #define PUT_DIRECT_NATIVE_FUNC(lowerName, upperName, count) \
 84     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, #lowerName), count, atomicsFunc ## upperName, Atomics ## upperName ## Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 85     FOR_EACH_ATOMICS_FUNC(PUT_DIRECT_NATIVE_FUNC)
 86 #undef PUT_DIRECT_NATIVE_FUNC
 87 }
 88 
 89 namespace {
 90 
 91 template&lt;typename Adaptor, typename Func&gt;
<span class="line-modified"> 92 EncodedJSValue atomicOperationWithArgsCase(JSGlobalObject* globalObject, const JSValue* args, ThrowScope&amp; scope, JSArrayBufferView* typedArrayView, unsigned accessIndex, const Func&amp; func)</span>
 93 {
 94     JSGenericTypedArrayView&lt;Adaptor&gt;* typedArray = jsCast&lt;JSGenericTypedArrayView&lt;Adaptor&gt;*&gt;(typedArrayView);
 95 
 96     double extraArgs[Func::numExtraArgs + 1]; // Add 1 to avoid 0 size array error in VS.
 97     for (unsigned i = 0; i &lt; Func::numExtraArgs; ++i) {
<span class="line-modified"> 98         double value = args[2 + i].toInteger(globalObject);</span>
 99         RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
100         extraArgs[i] = value;
101     }
102 
103     return JSValue::encode(func(typedArray-&gt;typedVector() + accessIndex, extraArgs));
104 }
105 
<span class="line-modified">106 unsigned validatedAccessIndex(VM&amp; vm, JSGlobalObject* globalObject, JSValue accessIndexValue, JSArrayBufferView* typedArrayView)</span>
107 {
108     auto scope = DECLARE_THROW_SCOPE(vm);
109     if (UNLIKELY(!accessIndexValue.isInt32())) {
<span class="line-modified">110         double accessIndexDouble = accessIndexValue.toNumber(globalObject);</span>
111         RETURN_IF_EXCEPTION(scope, 0);
112         if (accessIndexDouble == 0)
113             accessIndexValue = jsNumber(0);
114         else {
115             accessIndexValue = jsNumber(accessIndexDouble);
116             if (!accessIndexValue.isInt32()) {
<span class="line-modified">117                 throwRangeError(globalObject, scope, &quot;Access index is not an integer.&quot;_s);</span>
118                 return 0;
119             }
120         }
121     }
122     int32_t accessIndex = accessIndexValue.asInt32();
123 
124     ASSERT(typedArrayView-&gt;length() &lt;= static_cast&lt;unsigned&gt;(INT_MAX));
125     if (static_cast&lt;unsigned&gt;(accessIndex) &gt;= typedArrayView-&gt;length()) {
<span class="line-modified">126         throwRangeError(globalObject, scope, &quot;Access index out of bounds for atomic access.&quot;_s);</span>
127         return 0;
128     }
129 
130     return accessIndex;
131 }
132 
133 template&lt;typename Func&gt;
<span class="line-modified">134 EncodedJSValue atomicOperationWithArgs(VM&amp; vm, JSGlobalObject* globalObject, const JSValue* args, const Func&amp; func)</span>
135 {
136     auto scope = DECLARE_THROW_SCOPE(vm);
137 
138     JSValue typedArrayValue = args[0];
139     if (!typedArrayValue.isCell()) {
<span class="line-modified">140         throwTypeError(globalObject, scope, &quot;Typed array argument must be a cell.&quot;_s);</span>
141         return JSValue::encode(jsUndefined());
142     }
143 
144     JSCell* typedArrayCell = typedArrayValue.asCell();
145 
146     JSType type = typedArrayCell-&gt;type();
147     switch (type) {
148     case Int8ArrayType:
149     case Int16ArrayType:
150     case Int32ArrayType:
151     case Uint8ArrayType:
152     case Uint16ArrayType:
153     case Uint32ArrayType:
154         break;
155     default:
<span class="line-modified">156         throwTypeError(globalObject, scope, &quot;Typed array argument must be an Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, or Uint32Array.&quot;_s);</span>
157         return JSValue::encode(jsUndefined());
158     }
159 
160     JSArrayBufferView* typedArrayView = jsCast&lt;JSArrayBufferView*&gt;(typedArrayCell);
161     if (!typedArrayView-&gt;isShared()) {
<span class="line-modified">162         throwTypeError(globalObject, scope, &quot;Typed array argument must wrap a SharedArrayBuffer.&quot;_s);</span>
163         return JSValue::encode(jsUndefined());
164     }
165 
<span class="line-modified">166     unsigned accessIndex = validatedAccessIndex(vm, globalObject, args[1], typedArrayView);</span>
167     RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
168 
169     switch (type) {
170     case Int8ArrayType:
<span class="line-modified">171         return atomicOperationWithArgsCase&lt;Int8Adaptor&gt;(globalObject, args, scope, typedArrayView, accessIndex, func);</span>
172     case Int16ArrayType:
<span class="line-modified">173         return atomicOperationWithArgsCase&lt;Int16Adaptor&gt;(globalObject, args, scope, typedArrayView, accessIndex, func);</span>
174     case Int32ArrayType:
<span class="line-modified">175         return atomicOperationWithArgsCase&lt;Int32Adaptor&gt;(globalObject, args, scope, typedArrayView, accessIndex, func);</span>
176     case Uint8ArrayType:
<span class="line-modified">177         return atomicOperationWithArgsCase&lt;Uint8Adaptor&gt;(globalObject, args, scope, typedArrayView, accessIndex, func);</span>
178     case Uint16ArrayType:
<span class="line-modified">179         return atomicOperationWithArgsCase&lt;Uint16Adaptor&gt;(globalObject, args, scope, typedArrayView, accessIndex, func);</span>
180     case Uint32ArrayType:
<span class="line-modified">181         return atomicOperationWithArgsCase&lt;Uint32Adaptor&gt;(globalObject, args, scope, typedArrayView, accessIndex, func);</span>
182     default:
183         RELEASE_ASSERT_NOT_REACHED();
184         return JSValue::encode(jsUndefined());
185     }
186 }
187 
188 template&lt;typename Func&gt;
<span class="line-modified">189 EncodedJSValue atomicOperationWithArgs(JSGlobalObject* globalObject, CallFrame* callFrame, const Func&amp; func)</span>
190 {
191     JSValue args[2 + Func::numExtraArgs];
192     for (unsigned i = 2 + Func::numExtraArgs; i--;)
<span class="line-modified">193         args[i] = callFrame-&gt;argument(i);</span>
<span class="line-modified">194     return atomicOperationWithArgs(globalObject-&gt;vm(), globalObject, args, func);</span>
195 }
196 
197 struct AddFunc {
<span class="line-modified">198     static constexpr unsigned numExtraArgs = 1;</span>
199 
200     template&lt;typename T&gt;
201     JSValue operator()(T* ptr, const double* args) const
202     {
203         return jsNumber(WTF::atomicExchangeAdd(ptr, toInt32(args[0])));
204     }
205 };
206 
207 struct AndFunc {
<span class="line-modified">208     static constexpr unsigned numExtraArgs = 1;</span>
209 
210     template&lt;typename T&gt;
211     JSValue operator()(T* ptr, const double* args) const
212     {
213         return jsNumber(WTF::atomicExchangeAnd(ptr, toInt32(args[0])));
214     }
215 };
216 
217 struct CompareExchangeFunc {
<span class="line-modified">218     static constexpr unsigned numExtraArgs = 2;</span>
219 
220     template&lt;typename T&gt;
221     JSValue operator()(T* ptr, const double* args) const
222     {
223         T expected = static_cast&lt;T&gt;(toInt32(args[0]));
224         T newValue = static_cast&lt;T&gt;(toInt32(args[1]));
225         return jsNumber(WTF::atomicCompareExchangeStrong(ptr, expected, newValue));
226     }
227 };
228 
229 struct ExchangeFunc {
<span class="line-modified">230     static constexpr unsigned numExtraArgs = 1;</span>
231 
232     template&lt;typename T&gt;
233     JSValue operator()(T* ptr, const double* args) const
234     {
235         return jsNumber(WTF::atomicExchange(ptr, static_cast&lt;T&gt;(toInt32(args[0]))));
236     }
237 };
238 
239 struct LoadFunc {
<span class="line-modified">240     static constexpr unsigned numExtraArgs = 0;</span>
241 
242     template&lt;typename T&gt;
243     JSValue operator()(T* ptr, const double*) const
244     {
245         return jsNumber(WTF::atomicLoadFullyFenced(ptr));
246     }
247 };
248 
249 struct OrFunc {
<span class="line-modified">250     static constexpr unsigned numExtraArgs = 1;</span>
251 
252     template&lt;typename T&gt;
253     JSValue operator()(T* ptr, const double* args) const
254     {
255         return jsNumber(WTF::atomicExchangeOr(ptr, toInt32(args[0])));
256     }
257 };
258 
259 struct StoreFunc {
<span class="line-modified">260     static constexpr unsigned numExtraArgs = 1;</span>
261 
262     template&lt;typename T&gt;
263     JSValue operator()(T* ptr, const double* args) const
264     {
265         double valueAsInt = args[0];
266         T valueAsT = static_cast&lt;T&gt;(toInt32(valueAsInt));
267         WTF::atomicStoreFullyFenced(ptr, valueAsT);
268         return jsNumber(valueAsInt);
269     }
270 };
271 
272 struct SubFunc {
<span class="line-modified">273     static constexpr unsigned numExtraArgs = 1;</span>
274 
275     template&lt;typename T&gt;
276     JSValue operator()(T* ptr, const double* args) const
277     {
278         return jsNumber(WTF::atomicExchangeSub(ptr, toInt32(args[0])));
279     }
280 };
281 
282 struct XorFunc {
<span class="line-modified">283     static constexpr unsigned numExtraArgs = 1;</span>
284 
285     template&lt;typename T&gt;
286     JSValue operator()(T* ptr, const double* args) const
287     {
288         return jsNumber(WTF::atomicExchangeXor(ptr, toInt32(args[0])));
289     }
290 };
291 
<span class="line-modified">292 EncodedJSValue isLockFree(JSGlobalObject* globalObject, JSValue arg)</span>
293 {
<span class="line-modified">294     VM&amp; vm = globalObject-&gt;vm();</span>
295     auto scope = DECLARE_THROW_SCOPE(vm);
296 
<span class="line-modified">297     int32_t size = arg.toInt32(globalObject);</span>
298     RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
299 
300     bool result;
301     switch (size) {
302     case 1:
303     case 2:
304     case 4:
305         result = true;
306         break;
307     default:
308         result = false;
309         break;
310     }
311     return JSValue::encode(jsBoolean(result));
312 }
313 
314 } // anonymous namespace
315 
<span class="line-modified">316 EncodedJSValue JSC_HOST_CALL atomicsFuncAdd(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
317 {
<span class="line-modified">318     return atomicOperationWithArgs(globalObject, callFrame, AddFunc());</span>
319 }
320 
<span class="line-modified">321 EncodedJSValue JSC_HOST_CALL atomicsFuncAnd(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
322 {
<span class="line-modified">323     return atomicOperationWithArgs(globalObject, callFrame, AndFunc());</span>
324 }
325 
<span class="line-modified">326 EncodedJSValue JSC_HOST_CALL atomicsFuncCompareExchange(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
327 {
<span class="line-modified">328     return atomicOperationWithArgs(globalObject, callFrame, CompareExchangeFunc());</span>
329 }
330 
<span class="line-modified">331 EncodedJSValue JSC_HOST_CALL atomicsFuncExchange(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
332 {
<span class="line-modified">333     return atomicOperationWithArgs(globalObject, callFrame, ExchangeFunc());</span>
334 }
335 
<span class="line-modified">336 EncodedJSValue JSC_HOST_CALL atomicsFuncIsLockFree(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
337 {
<span class="line-modified">338     return isLockFree(globalObject, callFrame-&gt;argument(0));</span>
339 }
340 
<span class="line-modified">341 EncodedJSValue JSC_HOST_CALL atomicsFuncLoad(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
342 {
<span class="line-modified">343     return atomicOperationWithArgs(globalObject, callFrame, LoadFunc());</span>
344 }
345 
<span class="line-modified">346 EncodedJSValue JSC_HOST_CALL atomicsFuncOr(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
347 {
<span class="line-modified">348     return atomicOperationWithArgs(globalObject, callFrame, OrFunc());</span>
349 }
350 
<span class="line-modified">351 EncodedJSValue JSC_HOST_CALL atomicsFuncStore(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
352 {
<span class="line-modified">353     return atomicOperationWithArgs(globalObject, callFrame, StoreFunc());</span>
354 }
355 
<span class="line-modified">356 EncodedJSValue JSC_HOST_CALL atomicsFuncSub(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
357 {
<span class="line-modified">358     return atomicOperationWithArgs(globalObject, callFrame, SubFunc());</span>
359 }
360 
<span class="line-modified">361 EncodedJSValue JSC_HOST_CALL atomicsFuncWait(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
362 {
<span class="line-modified">363     VM&amp; vm = globalObject-&gt;vm();</span>
364     auto scope = DECLARE_THROW_SCOPE(vm);
365 
<span class="line-modified">366     JSInt32Array* typedArray = jsDynamicCast&lt;JSInt32Array*&gt;(vm, callFrame-&gt;argument(0));</span>
367     if (!typedArray) {
<span class="line-modified">368         throwTypeError(globalObject, scope, &quot;Typed array for wait/wake must be an Int32Array.&quot;_s);</span>
369         return JSValue::encode(jsUndefined());
370     }
371 
372     if (!typedArray-&gt;isShared()) {
<span class="line-modified">373         throwTypeError(globalObject, scope, &quot;Typed array for wait/wake must wrap a SharedArrayBuffer.&quot;_s);</span>
374         return JSValue::encode(jsUndefined());
375     }
376 
<span class="line-modified">377     unsigned accessIndex = validatedAccessIndex(vm, globalObject, callFrame-&gt;argument(1), typedArray);</span>
378     RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
379 
380     int32_t* ptr = typedArray-&gt;typedVector() + accessIndex;
381 
<span class="line-modified">382     int32_t expectedValue = callFrame-&gt;argument(2).toInt32(globalObject);</span>
383     RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
384 
<span class="line-modified">385     double timeoutInMilliseconds = callFrame-&gt;argument(3).toNumber(globalObject);</span>
386     RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
387 
388     if (!vm.m_typedArrayController-&gt;isAtomicsWaitAllowedOnCurrentThread()) {
<span class="line-modified">389         throwTypeError(globalObject, scope, &quot;Atomics.wait cannot be called from the current thread.&quot;_s);</span>
390         return JSValue::encode(jsUndefined());
391     }
392 
393     Seconds timeout = Seconds::fromMilliseconds(timeoutInMilliseconds);
394 
395     // This covers the proposed rule:
396     //
397     // 4. If timeout is not provided or is undefined then let t be +inf. Otherwise:
398     //     a. Let q be ? ToNumber(timeout).
399     //     b. If q is NaN then let t be +inf, otherwise let t be max(0, q).
400     //
<span class="line-modified">401     // callFrame-&gt;argument(3) returns undefined if it&#39;s not provided and ToNumber(undefined) returns NaN,</span>
402     // so NaN is the only special case.
403     if (!std::isnan(timeout))
404         timeout = std::max(0_s, timeout);
405     else
406         timeout = Seconds::infinity();
407 
408     bool didPassValidation = false;
409     ParkingLot::ParkResult result;
410     {
411         ReleaseHeapAccessScope releaseHeapAccessScope(vm.heap);
412         result = ParkingLot::parkConditionally(
413             ptr,
414             [&amp;] () -&gt; bool {
415                 didPassValidation = WTF::atomicLoad(ptr) == expectedValue;
416                 return didPassValidation;
417             },
418             [] () { },
419             MonotonicTime::now() + timeout);
420     }
421     const char* resultString;
422     if (!didPassValidation)
423         resultString = &quot;not-equal&quot;;
424     else if (!result.wasUnparked)
425         resultString = &quot;timed-out&quot;;
426     else
427         resultString = &quot;ok&quot;;
428     return JSValue::encode(jsString(vm, resultString));
429 }
430 
<span class="line-modified">431 EncodedJSValue JSC_HOST_CALL atomicsFuncWake(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
432 {
<span class="line-modified">433     VM&amp; vm = globalObject-&gt;vm();</span>
434     auto scope = DECLARE_THROW_SCOPE(vm);
435 
<span class="line-modified">436     JSInt32Array* typedArray = jsDynamicCast&lt;JSInt32Array*&gt;(vm, callFrame-&gt;argument(0));</span>
437     if (!typedArray) {
<span class="line-modified">438         throwTypeError(globalObject, scope, &quot;Typed array for wait/wake must be an Int32Array.&quot;_s);</span>
439         return JSValue::encode(jsUndefined());
440     }
441 
442     if (!typedArray-&gt;isShared()) {
<span class="line-modified">443         throwTypeError(globalObject, scope, &quot;Typed array for wait/wake must wrap a SharedArrayBuffer.&quot;_s);</span>
444         return JSValue::encode(jsUndefined());
445     }
446 
<span class="line-modified">447     unsigned accessIndex = validatedAccessIndex(vm, globalObject, callFrame-&gt;argument(1), typedArray);</span>
448     RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
449 
450     int32_t* ptr = typedArray-&gt;typedVector() + accessIndex;
451 
<span class="line-modified">452     JSValue countValue = callFrame-&gt;argument(2);</span>
453     unsigned count = UINT_MAX;
454     if (!countValue.isUndefined()) {
<span class="line-modified">455         int32_t countInt = countValue.toInt32(globalObject);</span>
456         RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
457         count = std::max(0, countInt);
458     }
459 
460     return JSValue::encode(jsNumber(ParkingLot::unparkCount(ptr, count)));
461 }
462 
<span class="line-modified">463 EncodedJSValue JSC_HOST_CALL atomicsFuncXor(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
464 {
<span class="line-modified">465     return atomicOperationWithArgs(globalObject, callFrame, XorFunc());</span>
466 }
467 
<span class="line-modified">468 IGNORE_WARNINGS_BEGIN(&quot;frame-address&quot;)</span>
<span class="line-added">469 </span>
<span class="line-added">470 EncodedJSValue JIT_OPERATION operationAtomicsAdd(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
471 {
<span class="line-modified">472     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">473     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">474     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
475     JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">476     return atomicOperationWithArgs(vm, globalObject, args, AddFunc());</span>
477 }
478 
<span class="line-modified">479 EncodedJSValue JIT_OPERATION operationAtomicsAnd(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
480 {
<span class="line-modified">481     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">482     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">483     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
484     JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">485     return atomicOperationWithArgs(vm, globalObject, args, AndFunc());</span>
486 }
487 
<span class="line-modified">488 EncodedJSValue JIT_OPERATION operationAtomicsCompareExchange(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index, EncodedJSValue expected, EncodedJSValue newValue)</span>
489 {
<span class="line-modified">490     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">491     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">492     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
493     JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(expected), JSValue::decode(newValue)};
<span class="line-modified">494     return atomicOperationWithArgs(vm, globalObject, args, CompareExchangeFunc());</span>
495 }
496 
<span class="line-modified">497 EncodedJSValue JIT_OPERATION operationAtomicsExchange(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
498 {
<span class="line-modified">499     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">500     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">501     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
502     JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">503     return atomicOperationWithArgs(vm, globalObject, args, ExchangeFunc());</span>
504 }
505 
<span class="line-modified">506 EncodedJSValue JIT_OPERATION operationAtomicsIsLockFree(JSGlobalObject* globalObject, EncodedJSValue size)</span>
507 {
<span class="line-modified">508     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">509     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">510     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">511     return isLockFree(globalObject, JSValue::decode(size));</span>
512 }
513 
<span class="line-modified">514 EncodedJSValue JIT_OPERATION operationAtomicsLoad(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index)</span>
515 {
<span class="line-modified">516     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">517     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">518     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
519     JSValue args[] = {JSValue::decode(base), JSValue::decode(index)};
<span class="line-modified">520     return atomicOperationWithArgs(vm, globalObject, args, LoadFunc());</span>
521 }
522 
<span class="line-modified">523 EncodedJSValue JIT_OPERATION operationAtomicsOr(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
524 {
<span class="line-modified">525     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">526     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">527     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
528     JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">529     return atomicOperationWithArgs(vm, globalObject, args, OrFunc());</span>
530 }
531 
<span class="line-modified">532 EncodedJSValue JIT_OPERATION operationAtomicsStore(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
533 {
<span class="line-modified">534     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">535     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">536     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
537     JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">538     return atomicOperationWithArgs(vm, globalObject, args, StoreFunc());</span>
539 }
540 
<span class="line-modified">541 EncodedJSValue JIT_OPERATION operationAtomicsSub(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
542 {
<span class="line-modified">543     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">544     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">545     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
546     JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">547     return atomicOperationWithArgs(vm, globalObject, args, SubFunc());</span>
548 }
549 
<span class="line-modified">550 EncodedJSValue JIT_OPERATION operationAtomicsXor(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
551 {
<span class="line-modified">552     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">553     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">554     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
555     JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">556     return atomicOperationWithArgs(vm, globalObject, args, XorFunc());</span>
557 }
558 
<span class="line-added">559 IGNORE_WARNINGS_END</span>
<span class="line-added">560 </span>
561 } // namespace JSC
562 
</pre>
</td>
</tr>
</table>
<center><a href="AsyncIteratorPrototype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AtomicsObject.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/scripts/codegen/generate_objc_backend_dispatcher_implementation.py</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 #!/usr/bin/env python
  2 #
  3 # Copyright (c) 2014-2018 Apple Inc. All rights reserved.
  4 # Copyright (c) 2014 University of Washington. All rights reserved.
  5 #
  6 # Redistribution and use in source and binary forms, with or without
  7 # modification, are permitted provided that the following conditions
  8 # are met:
  9 # 1. Redistributions of source code must retain the above copyright
 10 #    notice, this list of conditions and the following disclaimer.
 11 # 2. Redistributions in binary form must reproduce the above copyright
 12 #    notice, this list of conditions and the following disclaimer in the
 13 #    documentation and/or other materials provided with the distribution.
 14 #
 15 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 16 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 17 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 19 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 20 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 21 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 22 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 23 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 24 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 25 # THE POSSIBILITY OF SUCH DAMAGE.
 26 
 27 
 28 import logging
 29 import string
 30 import re
 31 from string import Template
 32 
 33 try:
 34     from .cpp_generator import CppGenerator
 35     from .generator import Generator
 36     from .models import PrimitiveType, EnumType, AliasedType, Frameworks
 37     from .objc_generator import ObjCTypeCategory, ObjCGenerator, join_type_and_name
 38     from .objc_generator_templates import ObjCGeneratorTemplates as ObjCTemplates
 39 except ValueError:
 40     from cpp_generator import CppGenerator
 41     from generator import Generator
 42     from models import PrimitiveType, EnumType, AliasedType, Frameworks
 43     from objc_generator import ObjCTypeCategory, ObjCGenerator, join_type_and_name
 44     from objc_generator_templates import ObjCGeneratorTemplates as ObjCTemplates
 45 
 46 log = logging.getLogger(&#39;global&#39;)
 47 
 48 
 49 class ObjCBackendDispatcherImplementationGenerator(ObjCGenerator):
 50     def __init__(self, *args, **kwargs):
 51         ObjCGenerator.__init__(self, *args, **kwargs)
 52 
 53     def output_filename(self):
 54         return &#39;%sBackendDispatchers.mm&#39; % self.protocol_name()
 55 
 56     def domains_to_generate(self):
 57         return list(filter(self.should_generate_commands_for_domain, Generator.domains_to_generate(self)))
 58 
 59     def generate_output(self):
 60         secondary_headers = [
 61             &#39;&quot;%sInternal.h&quot;&#39; % self.protocol_name(),
 62             &#39;&quot;%sTypeConversions.h&quot;&#39; % self.protocol_name(),
 63             &#39;&lt;wtf/JSONValues.h&gt;&#39;,
 64         ]
 65 
 66         header_args = {
 67             &#39;primaryInclude&#39;: &#39;&quot;%sBackendDispatchers.h&quot;&#39; % self.protocol_name(),
 68             &#39;secondaryIncludes&#39;: &#39;\n&#39;.join([&#39;#include %s&#39; % header for header in secondary_headers]),
 69         }
 70 
 71         domains = self.domains_to_generate()
 72         sections = []
 73         sections.append(self.generate_license())
 74         sections.append(Template(ObjCTemplates.BackendDispatcherImplementationPrelude).substitute(None, **header_args))
 75         sections.extend(list(map(self._generate_handler_implementation_for_domain, domains)))
 76         sections.append(Template(ObjCTemplates.BackendDispatcherImplementationPostlude).substitute(None, **header_args))
 77         return &#39;\n\n&#39;.join(sections)
 78 
 79     def _generate_handler_implementation_for_domain(self, domain):
 80         commands = self.commands_for_domain(domain)
 81 
 82         if not commands:
 83             return &#39;&#39;
 84 
 85         command_declarations = []
 86         for command in commands:
 87             command_declarations.append(self._generate_handler_implementation_for_command(domain, command))
 88 
 89         return &#39;\n&#39;.join(command_declarations)
 90 
 91     def _generate_handler_implementation_for_command(self, domain, command):
 92         lines = []
 93         parameters = [&#39;long requestId&#39;]
 94         for parameter in command.call_parameters:
 95             parameters.append(&#39;%s in_%s&#39; % (CppGenerator.cpp_type_for_unchecked_formal_in_parameter(parameter), parameter.parameter_name))
 96 
 97         command_args = {
 98             &#39;domainName&#39;: domain.domain_name,
 99             &#39;commandName&#39;: command.command_name,
100             &#39;parameters&#39;: &#39;, &#39;.join(parameters),
101             &#39;respondsToSelector&#39;: self._generate_responds_to_selector_for_command(domain, command),
102             &#39;successCallback&#39;: self._generate_success_block_for_command(domain, command),
103             &#39;conversions&#39;: self._generate_conversions_for_command(domain, command),
104             &#39;invocation&#39;: self._generate_invocation_for_command(domain, command),
105         }
106 
107         return self.wrap_with_guard_for_domain(domain, Template(ObjCTemplates.BackendDispatcherHeaderDomainHandlerImplementation).substitute(None, **command_args))
108 
109     def _generate_responds_to_selector_for_command(self, domain, command):
110         return &#39;[m_delegate respondsToSelector:@selector(%sWithErrorCallback:successCallback:%s)]&#39; % (command.command_name, &#39;&#39;.join(map(lambda parameter: &#39;%s:&#39; % parameter.parameter_name, command.call_parameters)))
111 
112     def _generate_success_block_for_command(self, domain, command):
113         lines = []
114 
115         if command.return_parameters:
116             success_block_parameters = []
117             for parameter in command.return_parameters:
118                 objc_type = self.objc_type_for_param(domain, command.command_name, parameter)
119                 var_name = ObjCGenerator.identifier_to_objc_identifier(parameter.parameter_name)
120                 success_block_parameters.append(join_type_and_name(objc_type, var_name))
121             lines.append(&#39;    id successCallback = ^(%s) {&#39; % &#39;, &#39;.join(success_block_parameters))
122         else:
123             lines.append(&#39;    id successCallback = ^{&#39;)
124 
125         if command.return_parameters:
126             lines.append(&#39;        Ref&lt;JSON::Object&gt; resultObject = JSON::Object::create();&#39;)
127 
128             required_pointer_parameters = [parameter for parameter in command.return_parameters if not parameter.is_optional and ObjCGenerator.is_type_objc_pointer_type(parameter.type)]
129             for parameter in required_pointer_parameters:
130                 var_name = ObjCGenerator.identifier_to_objc_identifier(parameter.parameter_name)
131                 lines.append(&#39;        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(%s, @&quot;%s&quot;);&#39; % (var_name, var_name))
132                 objc_array_class = self.objc_class_for_array_type(parameter.type)
133                 if objc_array_class and objc_array_class.startswith(self.objc_prefix()):
134                     lines.append(&#39;        THROW_EXCEPTION_FOR_BAD_TYPE_IN_ARRAY(%s, [%s class]);&#39; % (var_name, objc_array_class))
135 
136             optional_pointer_parameters = [parameter for parameter in command.return_parameters if parameter.is_optional and ObjCGenerator.is_type_objc_pointer_type(parameter.type)]
137             for parameter in optional_pointer_parameters:
138                 var_name = ObjCGenerator.identifier_to_objc_identifier(parameter.parameter_name)
139                 lines.append(&#39;        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(%s, @&quot;%s&quot;);&#39; % (var_name, var_name))
140                 objc_array_class = self.objc_class_for_array_type(parameter.type)
141                 if objc_array_class and objc_array_class.startswith(self.objc_prefix()):
142                     lines.append(&#39;        THROW_EXCEPTION_FOR_BAD_TYPE_IN_OPTIONAL_ARRAY(%s, [%s class]);&#39; % (var_name, objc_array_class))
143 
144             for parameter in command.return_parameters:
145                 keyed_set_method = CppGenerator.cpp_setter_method_for_type(parameter.type)
146                 var_name = ObjCGenerator.identifier_to_objc_identifier(parameter.parameter_name)
147                 var_expression = &#39;*%s&#39; % var_name if parameter.is_optional else var_name
148                 export_expression = self.objc_protocol_export_expression_for_variable(parameter.type, var_expression)
149                 if not parameter.is_optional:
150                     lines.append(&#39;        resultObject-&gt;%s(&quot;%s&quot;_s, %s);&#39; % (keyed_set_method, parameter.parameter_name, export_expression))
151                 else:
152                     lines.append(&#39;        if (%s)&#39; % var_name)
153                     lines.append(&#39;            resultObject-&gt;%s(&quot;%s&quot;_s, %s);&#39; % (keyed_set_method, parameter.parameter_name, export_expression))
154             lines.append(&#39;        backendDispatcher()-&gt;sendResponse(requestId, WTFMove(resultObject), false);&#39;)
155         else:
156             lines.append(&#39;        backendDispatcher()-&gt;sendResponse(requestId, JSON::Object::create(), false);&#39;)
157 
158         lines.append(&#39;    };&#39;)
159         return &#39;\n&#39;.join(lines)
160 
161     def _generate_conversions_for_command(self, domain, command):
162         lines = []
163         if command.call_parameters:
164             lines.append(&#39;&#39;)
165 
166         def in_param_expression(param_name, parameter):
167             _type = parameter.type
168             if isinstance(_type, AliasedType):
169                 _type = _type.aliased_type  # Fall through to enum or primitive.
170             if isinstance(_type, EnumType):
171                 _type = _type.primitive_type  # Fall through to primitive.
172             if isinstance(_type, PrimitiveType):
173                 if _type.raw_name() in [&#39;array&#39;, &#39;any&#39;, &#39;object&#39;]:
174                     return &#39;&amp;%s&#39; % param_name if not parameter.is_optional else param_name
175                 return &#39;*%s&#39; % param_name if parameter.is_optional else param_name
176             return &#39;&amp;%s&#39; % param_name if not parameter.is_optional else param_name
177 
178         for parameter in command.call_parameters:
179             in_param_name = &#39;in_%s&#39; % parameter.parameter_name
180             objc_in_param_name = &#39;o_%s&#39; % in_param_name
181             objc_type = self.objc_type_for_param(domain, command.command_name, parameter, False)
182             if isinstance(parameter.type, EnumType):
183                 objc_type = &#39;Optional&lt;%s&gt;&#39; % objc_type
184             param_expression = in_param_expression(in_param_name, parameter)
185             import_expression = self.objc_protocol_import_expression_for_parameter(param_expression, domain, command.command_name, parameter)
186             if not parameter.is_optional:
187                 lines.append(&#39;    %s = %s;&#39; % (join_type_and_name(objc_type, objc_in_param_name), import_expression))
188 
189                 if isinstance(parameter.type, EnumType):
190                     lines.append(&#39;    if (!%s) {&#39; % objc_in_param_name)
191                     lines.append(&#39;        backendDispatcher()-&gt;reportProtocolError(BackendDispatcher::InvalidParams, &quot;Parameter \&#39;%s\&#39; of method \&#39;%s.%s\&#39; cannot be processed&quot;_s);&#39; % (parameter.parameter_name, domain.domain_name, command.command_name))
192                     lines.append(&#39;        return;&#39;)
193                     lines.append(&#39;    }&#39;)
194 
195             else:
196                 lines.append(&#39;    %s;&#39; % join_type_and_name(objc_type, objc_in_param_name))
197                 lines.append(&#39;    if (%s)&#39; % in_param_name)
198                 lines.append(&#39;        %s = %s;&#39; % (objc_in_param_name, import_expression))
199 
200         if lines:
201             lines.append(&#39;&#39;)
202         return &#39;\n&#39;.join(lines)
203 
204     def _generate_invocation_for_command(self, domain, command):
205         pairs = []
206         pairs.append(&#39;WithErrorCallback:errorCallback&#39;)
207         pairs.append(&#39;successCallback:successCallback&#39;)
208         for parameter in command.call_parameters:
209             in_param_name = &#39;in_%s&#39; % parameter.parameter_name
210             objc_in_param_expression = &#39;o_%s&#39; % in_param_name
211             if not parameter.is_optional:
212                 if isinstance(parameter.type, EnumType):
213                     objc_in_param_expression = &#39;%s.value()&#39; % objc_in_param_expression
214 
215                 pairs.append(&#39;%s:%s&#39; % (parameter.parameter_name, objc_in_param_expression))
216             else:
217                 if isinstance(parameter.type, EnumType):
218                     objc_in_param_expression = &#39;%s.value()&#39; % objc_in_param_expression
219 
220                 optional_expression = &#39;(%s ? &amp;%s : nil)&#39; % (in_param_name, objc_in_param_expression)
221                 pairs.append(&#39;%s:%s&#39; % (parameter.parameter_name, optional_expression))
222         return &#39;    [m_delegate %s%s];&#39; % (command.command_name, &#39; &#39;.join(pairs))
    </pre>
  </body>
</html>
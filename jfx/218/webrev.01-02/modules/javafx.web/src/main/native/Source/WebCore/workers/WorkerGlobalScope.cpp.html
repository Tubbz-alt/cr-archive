<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerGlobalScope.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2008-2017 Apple Inc. All Rights Reserved.
  3  * Copyright (C) 2009, 2011 Google Inc. All Rights Reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  *
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;WorkerGlobalScope.h&quot;
 30 
 31 #include &quot;CSSValueList.h&quot;
 32 #include &quot;CSSValuePool.h&quot;
 33 #include &quot;ContentSecurityPolicy.h&quot;
 34 #include &quot;Crypto.h&quot;
 35 #include &quot;IDBConnectionProxy.h&quot;
 36 #include &quot;ImageBitmapOptions.h&quot;
 37 #include &quot;InspectorInstrumentation.h&quot;
 38 #include &quot;Performance.h&quot;
 39 #include &quot;RuntimeEnabledFeatures.h&quot;
 40 #include &quot;ScheduledAction.h&quot;
 41 #include &quot;ScriptSourceCode.h&quot;
 42 #include &quot;SecurityOrigin.h&quot;
 43 #include &quot;SecurityOriginPolicy.h&quot;
 44 #include &quot;ServiceWorkerGlobalScope.h&quot;
 45 #include &quot;SocketProvider.h&quot;
 46 #include &quot;WorkerEventLoop.h&quot;
 47 #include &quot;WorkerInspectorController.h&quot;
 48 #include &quot;WorkerLoaderProxy.h&quot;
 49 #include &quot;WorkerLocation.h&quot;
 50 #include &quot;WorkerMessagingProxy.h&quot;
 51 #include &quot;WorkerNavigator.h&quot;
 52 #include &quot;WorkerReportingProxy.h&quot;
 53 #include &quot;WorkerSWClientConnection.h&quot;
 54 #include &quot;WorkerScriptLoader.h&quot;
 55 #include &quot;WorkerThread.h&quot;
 56 #include &lt;JavaScriptCore/ScriptArguments.h&gt;
 57 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 58 #include &lt;wtf/IsoMallocInlines.h&gt;
 59 
 60 namespace WebCore {
 61 using namespace Inspector;
 62 
 63 WTF_MAKE_ISO_ALLOCATED_IMPL(WorkerGlobalScope);
 64 
 65 WorkerGlobalScope::WorkerGlobalScope(const WorkerParameters&amp; params, Ref&lt;SecurityOrigin&gt;&amp;&amp; origin, WorkerThread&amp; thread, Ref&lt;SecurityOrigin&gt;&amp;&amp; topOrigin, IDBClient::IDBConnectionProxy* connectionProxy, SocketProvider* socketProvider)
 66     : m_url(params.scriptURL)
 67     , m_identifier(params.identifier)
 68     , m_userAgent(params.userAgent)
 69     , m_thread(thread)
 70     , m_script(makeUnique&lt;WorkerScriptController&gt;(this))
 71     , m_inspectorController(makeUnique&lt;WorkerInspectorController&gt;(*this))
 72     , m_isOnline(params.isOnline)
 73     , m_shouldBypassMainWorldContentSecurityPolicy(params.shouldBypassMainWorldContentSecurityPolicy)
 74     , m_topOrigin(WTFMove(topOrigin))
 75 #if ENABLE(INDEXED_DATABASE)
 76     , m_connectionProxy(connectionProxy)
 77 #endif
 78     , m_socketProvider(socketProvider)
 79     , m_performance(Performance::create(this, params.timeOrigin))
 80     , m_referrerPolicy(params.referrerPolicy)
 81 {
 82 #if !ENABLE(INDEXED_DATABASE)
 83     UNUSED_PARAM(connectionProxy);
 84 #endif
 85 
 86     if (m_topOrigin-&gt;hasUniversalAccess())
 87         origin-&gt;grantUniversalAccess();
 88     if (m_topOrigin-&gt;needsStorageAccessFromFileURLsQuirk())
 89         origin-&gt;grantStorageAccessFromFileURLsQuirk();
 90 
 91     setSecurityOriginPolicy(SecurityOriginPolicy::create(WTFMove(origin)));
 92     setContentSecurityPolicy(makeUnique&lt;ContentSecurityPolicy&gt;(URL { m_url }, *this));
 93 }
 94 
 95 WorkerGlobalScope::~WorkerGlobalScope()
 96 {
 97     ASSERT(thread().thread() == &amp;Thread::current());
 98     // We need to remove from the contexts map very early in the destructor so that calling postTask() on this WorkerGlobalScope from another thread is safe.
 99     removeFromContextsMap();
100 
101     m_performance = nullptr;
102     m_crypto = nullptr;
103 
104     // Notify proxy that we are going away. This can free the WorkerThread object, so do not access it after this.
105     thread().workerReportingProxy().workerGlobalScopeDestroyed();
106 }
107 
108 EventLoopTaskGroup&amp; WorkerGlobalScope::eventLoop()
109 {
110     ASSERT(isContextThread());
111     if (UNLIKELY(!m_defaultTaskGroup)) {
112         m_eventLoop = WorkerEventLoop::create(*this);
113         m_defaultTaskGroup = makeUnique&lt;EventLoopTaskGroup&gt;(*m_eventLoop);
114         if (activeDOMObjectsAreStopped())
115             m_defaultTaskGroup-&gt;stopAndDiscardAllTasks();
116     }
117     return *m_defaultTaskGroup;
118 }
119 
120 String WorkerGlobalScope::origin() const
121 {
122     auto* securityOrigin = this-&gt;securityOrigin();
123     return securityOrigin ? securityOrigin-&gt;toString() : emptyString();
124 }
125 
126 void WorkerGlobalScope::prepareForTermination()
127 {
128 #if ENABLE(INDEXED_DATABASE)
129     stopIndexedDatabase();
130 #endif
131 
132     if (m_defaultTaskGroup)
133         m_defaultTaskGroup-&gt;stopAndDiscardAllTasks();
134     stopActiveDOMObjects();
135 
136     if (m_cacheStorageConnection)
137         m_cacheStorageConnection-&gt;clearPendingRequests();
138 
139     m_inspectorController-&gt;workerTerminating();
140 
141     // Event listeners would keep DOMWrapperWorld objects alive for too long. Also, they have references to JS objects,
142     // which become dangling once Heap is destroyed.
143     removeAllEventListeners();
144 
145     // MicrotaskQueue and RejectedPromiseTracker reference Heap.
146     if (m_eventLoop)
147         m_eventLoop-&gt;clearMicrotaskQueue();
148     removeRejectedPromiseTracker();
149 }
150 
151 void WorkerGlobalScope::removeAllEventListeners()
152 {
153     EventTarget::removeAllEventListeners();
154     m_performance-&gt;removeAllEventListeners();
155     m_performance-&gt;removeAllObservers();
156 }
157 
158 bool WorkerGlobalScope::isSecureContext() const
159 {
160     if (!RuntimeEnabledFeatures::sharedFeatures().secureContextChecksEnabled())
161         return true;
162 
163     return securityOrigin() &amp;&amp; securityOrigin()-&gt;isPotentiallyTrustworthy();
164 }
165 
166 void WorkerGlobalScope::applyContentSecurityPolicyResponseHeaders(const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicyResponseHeaders)
167 {
168     contentSecurityPolicy()-&gt;didReceiveHeaders(contentSecurityPolicyResponseHeaders, String { });
169 }
170 
171 URL WorkerGlobalScope::completeURL(const String&amp; url, ForceUTF8) const
172 {
173     // Always return a null URL when passed a null string.
174     // FIXME: Should we change the URL constructor to have this behavior?
175     if (url.isNull())
176         return URL();
177     // Always use UTF-8 in Workers.
178     return URL(m_url, url);
179 }
180 
181 String WorkerGlobalScope::userAgent(const URL&amp;) const
182 {
183     return m_userAgent;
184 }
185 
186 void WorkerGlobalScope::disableEval(const String&amp; errorMessage)
187 {
188     m_script-&gt;disableEval(errorMessage);
189 }
190 
191 void WorkerGlobalScope::disableWebAssembly(const String&amp; errorMessage)
192 {
193     m_script-&gt;disableWebAssembly(errorMessage);
194 }
195 
196 SocketProvider* WorkerGlobalScope::socketProvider()
197 {
198     return m_socketProvider.get();
199 }
200 
201 #if ENABLE(INDEXED_DATABASE)
202 
203 IDBClient::IDBConnectionProxy* WorkerGlobalScope::idbConnectionProxy()
204 {
205 #if ENABLE(INDEXED_DATABASE_IN_WORKERS)
206     return m_connectionProxy.get();
207 #else
208     return nullptr;
209 #endif
210 }
211 
212 void WorkerGlobalScope::stopIndexedDatabase()
213 {
214 #if ENABLE(INDEXED_DATABASE_IN_WORKERS)
215     if (m_connectionProxy)
216         m_connectionProxy-&gt;forgetActivityForCurrentThread();
217 #endif
218 }
219 
220 void WorkerGlobalScope::suspend()
221 {
222 #if ENABLE(INDEXED_DATABASE_IN_WORKERS)
223     if (m_connectionProxy)
224         m_connectionProxy-&gt;setContextSuspended(*scriptExecutionContext(), true);
225 #endif
226 }
227 
228 void WorkerGlobalScope::resume()
229 {
230 #if ENABLE(INDEXED_DATABASE_IN_WORKERS)
231     if (m_connectionProxy)
232         m_connectionProxy-&gt;setContextSuspended(*scriptExecutionContext(), false);
233 #endif
234 }
235 
236 #endif // ENABLE(INDEXED_DATABASE)
237 
238 WorkerLocation&amp; WorkerGlobalScope::location() const
239 {
240     if (!m_location)
241         m_location = WorkerLocation::create(m_url);
242     return *m_location;
243 }
244 
245 void WorkerGlobalScope::close()
246 {
247     if (m_closing)
248         return;
249 
250     // Let current script run to completion but prevent future script evaluations.
251     // After m_closing is set, all the tasks in the queue continue to be fetched but only
252     // tasks with isCleanupTask()==true will be executed.
253     m_closing = true;
254     postTask({ ScriptExecutionContext::Task::CleanupTask, [] (ScriptExecutionContext&amp; context) {
255         ASSERT_WITH_SECURITY_IMPLICATION(is&lt;WorkerGlobalScope&gt;(context));
256         WorkerGlobalScope&amp; workerGlobalScope = downcast&lt;WorkerGlobalScope&gt;(context);
257         // Notify parent that this context is closed. Parent is responsible for calling WorkerThread::stop().
258         workerGlobalScope.thread().workerReportingProxy().workerGlobalScopeClosed();
259     } });
260 }
261 
262 WorkerNavigator&amp; WorkerGlobalScope::navigator()
263 {
264     if (!m_navigator)
265         m_navigator = WorkerNavigator::create(*this, m_userAgent, m_isOnline);
266     return *m_navigator;
267 }
268 
269 void WorkerGlobalScope::setIsOnline(bool isOnline)
270 {
271     m_isOnline = isOnline;
272     if (m_navigator)
273         m_navigator-&gt;setIsOnline(isOnline);
274 }
275 
276 void WorkerGlobalScope::postTask(Task&amp;&amp; task)
277 {
278     thread().runLoop().postTask(WTFMove(task));
279 }
280 
281 ExceptionOr&lt;int&gt; WorkerGlobalScope::setTimeout(JSC::JSGlobalObject&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)
282 {
283     // FIXME: Should this check really happen here? Or should it happen when code is about to eval?
284     if (action-&gt;type() == ScheduledAction::Type::Code) {
285         if (!contentSecurityPolicy()-&gt;allowEval(&amp;state))
286             return 0;
287     }
288 
289     action-&gt;addArguments(WTFMove(arguments));
290 
291     return DOMTimer::install(*this, WTFMove(action), Seconds::fromMilliseconds(timeout), true);
292 }
293 
294 void WorkerGlobalScope::clearTimeout(int timeoutId)
295 {
296     DOMTimer::removeById(*this, timeoutId);
297 }
298 
299 ExceptionOr&lt;int&gt; WorkerGlobalScope::setInterval(JSC::JSGlobalObject&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)
300 {
301     // FIXME: Should this check really happen here? Or should it happen when code is about to eval?
302     if (action-&gt;type() == ScheduledAction::Type::Code) {
303         if (!contentSecurityPolicy()-&gt;allowEval(&amp;state))
304             return 0;
305     }
306 
307     action-&gt;addArguments(WTFMove(arguments));
308 
309     return DOMTimer::install(*this, WTFMove(action), Seconds::fromMilliseconds(timeout), false);
310 }
311 
312 void WorkerGlobalScope::clearInterval(int timeoutId)
313 {
314     DOMTimer::removeById(*this, timeoutId);
315 }
316 
317 ExceptionOr&lt;void&gt; WorkerGlobalScope::importScripts(const Vector&lt;String&gt;&amp; urls)
318 {
319     ASSERT(contentSecurityPolicy());
320 
321     Vector&lt;URL&gt; completedURLs;
322     completedURLs.reserveInitialCapacity(urls.size());
323     for (auto&amp; entry : urls) {
324         URL url = completeURL(entry);
325         if (!url.isValid())
326             return Exception { SyntaxError };
327         completedURLs.uncheckedAppend(WTFMove(url));
328     }
329 
330     FetchOptions::Cache cachePolicy = FetchOptions::Cache::Default;
331 
332 #if ENABLE(SERVICE_WORKER)
333     bool isServiceWorkerGlobalScope = is&lt;ServiceWorkerGlobalScope&gt;(*this);
334     if (isServiceWorkerGlobalScope) {
335         // FIXME: We need to add support for the &#39;imported scripts updated&#39; flag as per:
336         // https://w3c.github.io/ServiceWorker/#importscripts
337         auto&amp; serviceWorkerGlobalScope = downcast&lt;ServiceWorkerGlobalScope&gt;(*this);
338         auto&amp; registration = serviceWorkerGlobalScope.registration();
339         if (registration.updateViaCache() == ServiceWorkerUpdateViaCache::None || registration.needsUpdate())
340             cachePolicy = FetchOptions::Cache::NoCache;
341     }
342 #endif
343 
344     for (auto&amp; url : completedURLs) {
345         // FIXME: Convert this to check the isolated world&#39;s Content Security Policy once webkit.org/b/104520 is solved.
346         bool shouldBypassMainWorldContentSecurityPolicy = this-&gt;shouldBypassMainWorldContentSecurityPolicy();
347         if (!shouldBypassMainWorldContentSecurityPolicy &amp;&amp; !contentSecurityPolicy()-&gt;allowScriptFromSource(url))
348             return Exception { NetworkError };
349 
350         auto scriptLoader = WorkerScriptLoader::create();
351         auto cspEnforcement = shouldBypassMainWorldContentSecurityPolicy ? ContentSecurityPolicyEnforcement::DoNotEnforce : ContentSecurityPolicyEnforcement::EnforceScriptSrcDirective;
352         if (auto exception = scriptLoader-&gt;loadSynchronously(this, url, FetchOptions::Mode::NoCors, cachePolicy, cspEnforcement, resourceRequestIdentifier()))
353             return WTFMove(*exception);
354 
355         InspectorInstrumentation::scriptImported(*this, scriptLoader-&gt;identifier(), scriptLoader-&gt;script());
356 
357         NakedPtr&lt;JSC::Exception&gt; exception;
358         m_script-&gt;evaluate(ScriptSourceCode(scriptLoader-&gt;script(), URL(scriptLoader-&gt;responseURL())), exception);
359         if (exception) {
360             m_script-&gt;setException(exception);
361             return { };
362         }
363     }
364 
365     return { };
366 }
367 
368 EventTarget* WorkerGlobalScope::errorEventTarget()
369 {
370     return this;
371 }
372 
373 void WorkerGlobalScope::logExceptionToConsole(const String&amp; errorMessage, const String&amp; sourceURL, int lineNumber, int columnNumber, RefPtr&lt;ScriptCallStack&gt;&amp;&amp;)
374 {
375     thread().workerReportingProxy().postExceptionToWorkerObject(errorMessage, lineNumber, columnNumber, sourceURL);
376 }
377 
378 void WorkerGlobalScope::addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp; message)
379 {
380     if (!isContextThread()) {
381         postTask(AddConsoleMessageTask(message-&gt;source(), message-&gt;level(), message-&gt;message()));
382         return;
383     }
384 
385     InspectorInstrumentation::addMessageToConsole(*this, WTFMove(message));
386 }
387 
388 void WorkerGlobalScope::addConsoleMessage(MessageSource source, MessageLevel level, const String&amp; message, unsigned long requestIdentifier)
389 {
390     addMessage(source, level, message, { }, 0, 0, nullptr, nullptr, requestIdentifier);
391 }
392 
393 void WorkerGlobalScope::addMessage(MessageSource source, MessageLevel level, const String&amp; messageText, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;ScriptCallStack&gt;&amp;&amp; callStack, JSC::JSGlobalObject* state, unsigned long requestIdentifier)
394 {
395     if (!isContextThread()) {
396         postTask(AddConsoleMessageTask(source, level, messageText));
397         return;
398     }
399 
400     std::unique_ptr&lt;Inspector::ConsoleMessage&gt; message;
401     if (callStack)
402         message = makeUnique&lt;Inspector::ConsoleMessage&gt;(source, MessageType::Log, level, messageText, callStack.releaseNonNull(), requestIdentifier);
403     else
404         message = makeUnique&lt;Inspector::ConsoleMessage&gt;(source, MessageType::Log, level, messageText, sourceURL, lineNumber, columnNumber, state, requestIdentifier);
405     InspectorInstrumentation::addMessageToConsole(*this, WTFMove(message));
406 }
407 
408 bool WorkerGlobalScope::isContextThread() const
409 {
410     return thread().thread() == &amp;Thread::current();
411 }
412 
413 bool WorkerGlobalScope::isJSExecutionForbidden() const
414 {
415     return m_script-&gt;isExecutionForbidden();
416 }
417 
418 #if ENABLE(WEB_CRYPTO)
419 
420 class CryptoBufferContainer : public ThreadSafeRefCounted&lt;CryptoBufferContainer&gt; {
421 public:
422     static Ref&lt;CryptoBufferContainer&gt; create() { return adoptRef(*new CryptoBufferContainer); }
423     Vector&lt;uint8_t&gt;&amp; buffer() { return m_buffer; }
424 
425 private:
426     Vector&lt;uint8_t&gt; m_buffer;
427 };
428 
429 class CryptoBooleanContainer : public ThreadSafeRefCounted&lt;CryptoBooleanContainer&gt; {
430 public:
431     static Ref&lt;CryptoBooleanContainer&gt; create() { return adoptRef(*new CryptoBooleanContainer); }
432     bool boolean() const { return m_boolean; }
433     void setBoolean(bool boolean) { m_boolean = boolean; }
434 
435 private:
436     std::atomic&lt;bool&gt; m_boolean { false };
437 };
438 
439 bool WorkerGlobalScope::wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey)
440 {
441     Ref&lt;WorkerGlobalScope&gt; protectedThis(*this);
442     auto resultContainer = CryptoBooleanContainer::create();
443     auto doneContainer = CryptoBooleanContainer::create();
444     auto wrappedKeyContainer = CryptoBufferContainer::create();
445     m_thread.workerLoaderProxy().postTaskToLoader([resultContainer = resultContainer.copyRef(), key, wrappedKeyContainer = wrappedKeyContainer.copyRef(), doneContainer = doneContainer.copyRef(), workerMessagingProxy = makeRef(downcast&lt;WorkerMessagingProxy&gt;(m_thread.workerLoaderProxy()))](ScriptExecutionContext&amp; context) {
446         resultContainer-&gt;setBoolean(context.wrapCryptoKey(key, wrappedKeyContainer-&gt;buffer()));
447         doneContainer-&gt;setBoolean(true);
448         workerMessagingProxy-&gt;postTaskForModeToWorkerGlobalScope([](ScriptExecutionContext&amp; context) {
449             ASSERT_UNUSED(context, context.isWorkerGlobalScope());
450         }, WorkerRunLoop::defaultMode());
451     });
452 
453     auto waitResult = MessageQueueMessageReceived;
454     while (!doneContainer-&gt;boolean() &amp;&amp; waitResult != MessageQueueTerminated)
455         waitResult = m_thread.runLoop().runInMode(this, WorkerRunLoop::defaultMode());
456 
457     if (doneContainer-&gt;boolean())
458         wrappedKey.swap(wrappedKeyContainer-&gt;buffer());
459     return resultContainer-&gt;boolean();
460 }
461 
462 bool WorkerGlobalScope::unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key)
463 {
464     Ref&lt;WorkerGlobalScope&gt; protectedThis(*this);
465     auto resultContainer = CryptoBooleanContainer::create();
466     auto doneContainer = CryptoBooleanContainer::create();
467     auto keyContainer = CryptoBufferContainer::create();
468     m_thread.workerLoaderProxy().postTaskToLoader([resultContainer = resultContainer.copyRef(), wrappedKey, keyContainer = keyContainer.copyRef(), doneContainer = doneContainer.copyRef(), workerMessagingProxy = makeRef(downcast&lt;WorkerMessagingProxy&gt;(m_thread.workerLoaderProxy()))](ScriptExecutionContext&amp; context) {
469         resultContainer-&gt;setBoolean(context.unwrapCryptoKey(wrappedKey, keyContainer-&gt;buffer()));
470         doneContainer-&gt;setBoolean(true);
471         workerMessagingProxy-&gt;postTaskForModeToWorkerGlobalScope([](ScriptExecutionContext&amp; context) {
472             ASSERT_UNUSED(context, context.isWorkerGlobalScope());
473         }, WorkerRunLoop::defaultMode());
474     });
475 
476     auto waitResult = MessageQueueMessageReceived;
477     while (!doneContainer-&gt;boolean() &amp;&amp; waitResult != MessageQueueTerminated)
478         waitResult = m_thread.runLoop().runInMode(this, WorkerRunLoop::defaultMode());
479 
480     if (doneContainer-&gt;boolean())
481         key.swap(keyContainer-&gt;buffer());
482     return resultContainer-&gt;boolean();
483 }
484 
485 #endif // ENABLE(WEB_CRYPTO)
486 
487 Crypto&amp; WorkerGlobalScope::crypto()
488 {
489     if (!m_crypto)
490         m_crypto = Crypto::create(this);
491     return *m_crypto;
492 }
493 
494 Performance&amp; WorkerGlobalScope::performance() const
495 {
496     return *m_performance;
497 }
498 
499 WorkerCacheStorageConnection&amp; WorkerGlobalScope::cacheStorageConnection()
500 {
501     if (!m_cacheStorageConnection)
502         m_cacheStorageConnection = WorkerCacheStorageConnection::create(*this);
503     return *m_cacheStorageConnection;
504 }
505 
506 MessagePortChannelProvider&amp; WorkerGlobalScope::messagePortChannelProvider()
507 {
508     if (!m_messagePortChannelProvider)
509         m_messagePortChannelProvider = makeUnique&lt;WorkerMessagePortChannelProvider&gt;(*this);
510     return *m_messagePortChannelProvider;
511 }
512 
513 #if ENABLE(SERVICE_WORKER)
514 WorkerSWClientConnection&amp; WorkerGlobalScope::swClientConnection()
515 {
516     if (!m_swClientConnection)
517         m_swClientConnection = WorkerSWClientConnection::create(*this);
518     return *m_swClientConnection;
519 }
520 #endif
521 
522 void WorkerGlobalScope::createImageBitmap(ImageBitmap::Source&amp;&amp; source, ImageBitmapOptions&amp;&amp; options, ImageBitmap::Promise&amp;&amp; promise)
523 {
524     ImageBitmap::createPromise(*this, WTFMove(source), WTFMove(options), WTFMove(promise));
525 }
526 
527 void WorkerGlobalScope::createImageBitmap(ImageBitmap::Source&amp;&amp; source, int sx, int sy, int sw, int sh, ImageBitmapOptions&amp;&amp; options, ImageBitmap::Promise&amp;&amp; promise)
528 {
529     ImageBitmap::createPromise(*this, WTFMove(source), WTFMove(options), sx, sy, sw, sh, WTFMove(promise));
530 }
531 
532 CSSValuePool&amp; WorkerGlobalScope::cssValuePool()
533 {
534     if (!m_cssValuePool)
535         m_cssValuePool = makeUnique&lt;CSSValuePool&gt;();
536     return *m_cssValuePool;
537 }
538 
539 ReferrerPolicy WorkerGlobalScope::referrerPolicy() const
540 {
541     return m_referrerPolicy;
542 }
543 
544 } // namespace WebCore
    </pre>
  </body>
</html>
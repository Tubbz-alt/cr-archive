<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/animation/WebAnimation.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="KeyframeEffect.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WebAnimation.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/animation/WebAnimation.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WebAnimation.h&quot;
  28 
  29 #include &quot;AnimationEffect.h&quot;
  30 #include &quot;AnimationPlaybackEvent.h&quot;
  31 #include &quot;AnimationTimeline.h&quot;



  32 #include &quot;Document.h&quot;
  33 #include &quot;DocumentTimeline.h&quot;

  34 #include &quot;EventNames.h&quot;

  35 #include &quot;JSWebAnimation.h&quot;
  36 #include &quot;KeyframeEffect.h&quot;
<span class="line-modified">  37 #include &quot;Microtasks.h&quot;</span>



  38 #include &quot;WebAnimationUtilities.h&quot;
  39 #include &lt;wtf/IsoMallocInlines.h&gt;


  40 #include &lt;wtf/Optional.h&gt;

  41 #include &lt;wtf/text/WTFString.h&gt;
  42 
  43 namespace WebCore {
  44 
  45 WTF_MAKE_ISO_ALLOCATED_IMPL(WebAnimation);
  46 
















  47 Ref&lt;WebAnimation&gt; WebAnimation::create(Document&amp; document, AnimationEffect* effect)
  48 {
  49     auto result = adoptRef(*new WebAnimation(document));
  50     result-&gt;setEffect(effect);
  51     result-&gt;setTimeline(&amp;document.timeline());



  52     return result;
  53 }
  54 
  55 Ref&lt;WebAnimation&gt; WebAnimation::create(Document&amp; document, AnimationEffect* effect, AnimationTimeline* timeline)
  56 {
  57     auto result = adoptRef(*new WebAnimation(document));
  58     result-&gt;setEffect(effect);
  59     if (timeline)
  60         result-&gt;setTimeline(timeline);



  61     return result;
  62 }
  63 
  64 WebAnimation::WebAnimation(Document&amp; document)
  65     : ActiveDOMObject(document)
  66     , m_readyPromise(makeUniqueRef&lt;ReadyPromise&gt;(*this, &amp;WebAnimation::readyPromiseResolve))
  67     , m_finishedPromise(makeUniqueRef&lt;FinishedPromise&gt;(*this, &amp;WebAnimation::finishedPromiseResolve))
  68 {
  69     m_readyPromise-&gt;resolve(*this);
  70     suspendIfNeeded();



  71 }
  72 
  73 WebAnimation::~WebAnimation()
  74 {


  75     if (m_timeline)
  76         m_timeline-&gt;forgetAnimation(this);











  77 }
  78 
  79 void WebAnimation::remove()
  80 {
  81     // This object could be deleted after either clearing the effect or timeline relationship.
  82     auto protectedThis = makeRef(*this);
  83     setEffectInternal(nullptr);
  84     setTimelineInternal(nullptr);
  85 }
  86 
  87 void WebAnimation::suspendEffectInvalidation()
  88 {
  89     ++m_suspendCount;
  90 }
  91 
  92 void WebAnimation::unsuspendEffectInvalidation()
  93 {
  94     ASSERT(m_suspendCount &gt; 0);
  95     --m_suspendCount;
  96 }
  97 
<span class="line-modified">  98 void WebAnimation::effectTimingDidChange()</span>
  99 {
 100     timingDidChange(DidSeek::No, SynchronouslyNotify::Yes);










 101 }
 102 
 103 void WebAnimation::setEffect(RefPtr&lt;AnimationEffect&gt;&amp;&amp; newEffect)
 104 {
 105     // 3.4.3. Setting the target effect of an animation
 106     // https://drafts.csswg.org/web-animations-1/#setting-the-target-effect
 107 
 108     // 1. Let old effect be the current target effect of animation, if any.
 109     auto oldEffect = m_effect;
 110 
 111     // 2. If new effect is the same object as old effect, abort this procedure.
 112     if (newEffect == oldEffect)
 113         return;
 114 
 115     // 3. If animation has a pending pause task, reschedule that task to run as soon as animation is ready.
 116     if (hasPendingPauseTask())
 117         m_timeToRunPendingPauseTask = TimeToRunPendingTask::WhenReady;
 118 
 119     // 4. If animation has a pending play task, reschedule that task to run as soon as animation is ready to play new effect.
 120     if (hasPendingPlayTask())
</pre>
<hr />
<pre>
 126         newEffect-&gt;animation()-&gt;setEffect(nullptr);
 127 
 128     // 6. Let the target effect of animation be new effect.
 129     // In the case of a declarative animation, we don&#39;t want to remove the animation from the relevant maps because
 130     // while the effect was set via the API, the element still has a transition or animation set up and we must
 131     // not break the timeline-to-animation relationship.
 132 
 133     invalidateEffect();
 134 
 135     // This object could be deleted after clearing the effect relationship.
 136     auto protectedThis = makeRef(*this);
 137     setEffectInternal(WTFMove(newEffect), isDeclarativeAnimation());
 138 
 139     // 7. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false,
 140     // and the synchronously notify flag set to false.
 141     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
 142 
 143     invalidateEffect();
 144 }
 145 





 146 void WebAnimation::setEffectInternal(RefPtr&lt;AnimationEffect&gt;&amp;&amp; newEffect, bool doNotRemoveFromTimeline)
 147 {
 148     if (m_effect == newEffect)
 149         return;
 150 
 151     auto oldEffect = std::exchange(m_effect, WTFMove(newEffect));
 152 
 153     Element* previousTarget = nullptr;
 154     if (is&lt;KeyframeEffect&gt;(oldEffect))
 155         previousTarget = downcast&lt;KeyframeEffect&gt;(oldEffect.get())-&gt;target();
 156 
 157     Element* newTarget = nullptr;
 158     if (is&lt;KeyframeEffect&gt;(m_effect))
 159         newTarget = downcast&lt;KeyframeEffect&gt;(m_effect.get())-&gt;target();
 160 
 161     // Update the effect-to-animation relationships and the timeline&#39;s animation map.
 162     if (oldEffect) {
 163         oldEffect-&gt;setAnimation(nullptr);
 164         if (!doNotRemoveFromTimeline &amp;&amp; m_timeline &amp;&amp; previousTarget &amp;&amp; previousTarget != newTarget)
 165             m_timeline-&gt;animationWasRemovedFromElement(*this, *previousTarget);
 166         updateRelevance();
 167     }
 168 
 169     if (m_effect) {
 170         m_effect-&gt;setAnimation(this);
 171         if (m_timeline &amp;&amp; newTarget &amp;&amp; previousTarget != newTarget)
 172             m_timeline-&gt;animationWasAddedToElement(*this, *newTarget);
 173     }


 174 }
 175 
 176 void WebAnimation::setTimeline(RefPtr&lt;AnimationTimeline&gt;&amp;&amp; timeline)
 177 {
 178     // 3.4.1. Setting the timeline of an animation
 179     // https://drafts.csswg.org/web-animations-1/#setting-the-timeline
 180 
 181     // 2. If new timeline is the same object as old timeline, abort this procedure.
<span class="line-modified"> 182     if (timeline == m_timeline)</span>
 183         return;
 184 
 185     // 4. If the animation start time of animation is resolved, make animation&#39;s hold time unresolved.
 186     if (m_startTime)
 187         m_holdTime = WTF::nullopt;
 188 
 189     if (is&lt;KeyframeEffect&gt;(m_effect)) {
 190         auto* keyframeEffect = downcast&lt;KeyframeEffect&gt;(m_effect.get());
 191         auto* target = keyframeEffect-&gt;target();
 192         if (target) {
 193             // In the case of a declarative animation, we don&#39;t want to remove the animation from the relevant maps because
 194             // while the timeline was set via the API, the element still has a transition or animation set up and we must
 195             // not break the relationship.
 196             if (m_timeline &amp;&amp; !isDeclarativeAnimation())
 197                 m_timeline-&gt;animationWasRemovedFromElement(*this, *target);
 198             if (timeline)
 199                 timeline-&gt;animationWasAddedToElement(*this, *target);
 200         }
 201     }
 202 
 203     // This object could be deleted after clearing the timeline relationship.
 204     auto protectedThis = makeRef(*this);
 205     setTimelineInternal(WTFMove(timeline));
 206 
<span class="line-modified"> 207     setSuspended(is&lt;DocumentTimeline&gt;(m_timeline) &amp;&amp; downcast&lt;DocumentTimeline&gt;(*m_timeline).animationsAreSuspended());</span>
 208 
 209     // 5. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false,
 210     // and the synchronously notify flag set to false.
 211     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
 212 
 213     invalidateEffect();
 214 }
 215 
 216 void WebAnimation::setTimelineInternal(RefPtr&lt;AnimationTimeline&gt;&amp;&amp; timeline)
 217 {
<span class="line-modified"> 218     if (m_timeline == timeline)</span>
 219         return;
 220 
 221     if (m_timeline)
 222         m_timeline-&gt;removeAnimation(*this);
 223 
<span class="line-modified"> 224     m_timeline = WTFMove(timeline);</span>



 225 }
 226 
 227 void WebAnimation::effectTargetDidChange(Element* previousTarget, Element* newTarget)
 228 {
<span class="line-modified"> 229     if (!m_timeline)</span>
<span class="line-modified"> 230         return;</span>




 231 
<span class="line-modified"> 232     if (previousTarget)</span>
<span class="line-modified"> 233         m_timeline-&gt;animationWasRemovedFromElement(*this, *previousTarget);</span>

 234 
<span class="line-modified"> 235     if (newTarget)</span>
<span class="line-removed"> 236         m_timeline-&gt;animationWasAddedToElement(*this, *newTarget);</span>
 237 }
 238 
 239 Optional&lt;double&gt; WebAnimation::startTime() const
 240 {
 241     if (!m_startTime)
 242         return WTF::nullopt;
 243     return secondsToWebAnimationsAPITime(m_startTime.value());
 244 }
 245 
 246 void WebAnimation::setStartTime(Optional&lt;double&gt; startTime)
 247 {
 248     // 3.4.6 The procedure to set the start time of animation, animation, to new start time, is as follows:
 249     // https://drafts.csswg.org/web-animations/#setting-the-start-time-of-an-animation
 250 
 251     Optional&lt;Seconds&gt; newStartTime;
 252     if (!startTime)
 253         newStartTime = WTF::nullopt;
 254     else
 255         newStartTime = Seconds::fromMilliseconds(startTime.value());
 256 
</pre>
<hr />
<pre>
 325     // The current time is calculated from the first matching condition from below:
 326 
 327     // If the animation&#39;s hold time is resolved, the current time is the animation&#39;s hold time.
 328     if (respectHoldTime == RespectHoldTime::Yes &amp;&amp; m_holdTime)
 329         return m_holdTime;
 330 
 331     // If any of the following are true:
 332     //     1. the animation has no associated timeline, or
 333     //     2. the associated timeline is inactive, or
 334     //     3. the animation&#39;s start time is unresolved.
 335     // The current time is an unresolved time value.
 336     if (!m_timeline || !m_timeline-&gt;currentTime() || !m_startTime)
 337         return WTF::nullopt;
 338 
 339     // Otherwise, current time = (timeline time - start time) * playback rate
 340     return (m_timeline-&gt;currentTime().value() - m_startTime.value()) * m_playbackRate;
 341 }
 342 
 343 ExceptionOr&lt;void&gt; WebAnimation::silentlySetCurrentTime(Optional&lt;Seconds&gt; seekTime)
 344 {


 345     // 3.4.5. Setting the current time of an animation
 346     // https://drafts.csswg.org/web-animations-1/#setting-the-current-time-of-an-animation
 347 
 348     // 1. If seek time is an unresolved time value, then perform the following steps.
 349     if (!seekTime) {
 350         // 1. If the current time is resolved, then throw a TypeError.
 351         if (currentTime())
 352             return Exception { TypeError };
 353         // 2. Abort these steps.
 354         return { };
 355     }
 356 
 357     // 2. Update either animation&#39;s hold time or start time as follows:
 358     // If any of the following conditions are true:
 359     //     - animation&#39;s hold time is resolved, or
 360     //     - animation&#39;s start time is unresolved, or
 361     //     - animation has no associated timeline or the associated timeline is inactive, or
 362     //     - animation&#39;s playback rate is 0,
 363     // Set animation&#39;s hold time to seek time.
 364     // Otherwise, set animation&#39;s start time to the result of evaluating timeline time - (seek time / playback rate)
 365     // where timeline time is the current time value of timeline associated with animation.
 366     if (m_holdTime || !m_startTime || !m_timeline || !m_timeline-&gt;currentTime() || !m_playbackRate)
 367         m_holdTime = seekTime;
 368     else
 369         m_startTime = m_timeline-&gt;currentTime().value() - (seekTime.value() / m_playbackRate);
 370 
 371     // 3. If animation has no associated timeline or the associated timeline is inactive, make animation&#39;s start time unresolved.
 372     if (!m_timeline || !m_timeline-&gt;currentTime())
 373         m_startTime = WTF::nullopt;
 374 
 375     // 4. Make animation&#39;s previous current time unresolved.
 376     m_previousCurrentTime = WTF::nullopt;
 377 
 378     return { };
 379 }
 380 
 381 ExceptionOr&lt;void&gt; WebAnimation::setCurrentTime(Optional&lt;Seconds&gt; seekTime)
 382 {


 383     // 3.4.5. Setting the current time of an animation
 384     // https://drafts.csswg.org/web-animations-1/#setting-the-current-time-of-an-animation
 385 
 386     // 1. Run the steps to silently set the current time of animation to seek time.
 387     auto silentResult = silentlySetCurrentTime(seekTime);
 388     if (silentResult.hasException())
 389         return silentResult.releaseException();
 390 
 391     // 2. If animation has a pending pause task, synchronously complete the pause operation by performing the following steps:
 392     if (hasPendingPauseTask()) {
 393         // 1. Set animation&#39;s hold time to seek time.
 394         m_holdTime = seekTime;
 395         // 2. Apply any pending playback rate to animation.
 396         applyPendingPlaybackRate();
 397         // 3. Make animation&#39;s start time unresolved.
 398         m_startTime = WTF::nullopt;
 399         // 4. Cancel the pending pause task.
 400         m_timeToRunPendingPauseTask = TimeToRunPendingTask::NotScheduled;
 401         // 5. Resolve animation&#39;s current ready promise with animation.
 402         m_readyPromise-&gt;resolve(*this);
</pre>
<hr />
<pre>
 525     // have a pending play task,
 526     // → paused
 527     if (hasPendingPauseTask() || (!m_startTime &amp;&amp; !hasPendingPlayTask()))
 528         return PlayState::Paused;
 529 
 530     // For animation, current time is resolved and either of the following conditions are true:
 531     // animation&#39;s effective playback rate &gt; 0 and current time ≥ target effect end; or
 532     // animation&#39;s effective playback rate &lt; 0 and current time ≤ 0,
 533     // → finished
 534     if (animationCurrentTime &amp;&amp; ((effectivePlaybackRate() &gt; 0 &amp;&amp; (*animationCurrentTime + timeEpsilon) &gt;= effectEndTime()) || (effectivePlaybackRate() &lt; 0 &amp;&amp; (*animationCurrentTime - timeEpsilon) &lt;= 0_s)))
 535         return PlayState::Finished;
 536 
 537     // Otherwise → running
 538     return PlayState::Running;
 539 }
 540 
 541 Seconds WebAnimation::effectEndTime() const
 542 {
 543     // The target effect end of an animation is equal to the end time of the animation&#39;s target effect.
 544     // If the animation has no target effect, the target effect end is zero.
<span class="line-modified"> 545     return m_effect ? m_effect-&gt;getBasicTiming().endTime : 0_s;</span>
 546 }
 547 
 548 void WebAnimation::cancel()
 549 {
 550     cancel(Silently::No);
 551     invalidateEffect();
 552 }
 553 
 554 void WebAnimation::cancel(Silently silently)
 555 {


 556     // 3.4.16. Canceling an animation
 557     // https://drafts.csswg.org/web-animations-1/#canceling-an-animation-section
 558     //
 559     // An animation can be canceled which causes the current time to become unresolved hence removing any effects caused by the target effect.
 560     //
 561     // The procedure to cancel an animation for animation is as follows:
 562     //
 563     // 1. If animation&#39;s play state is not idle, perform the following steps:
 564     if (playState() != PlayState::Idle) {
 565         // 1. Run the procedure to reset an animation&#39;s pending tasks on animation.
 566         resetPendingTasks(silently);
 567 
 568         // 2. Reject the current finished promise with a DOMException named &quot;AbortError&quot;.
 569         if (silently == Silently::No &amp;&amp; !m_finishedPromise-&gt;isFulfilled())
 570             m_finishedPromise-&gt;reject(Exception { AbortError });
 571 
 572         // 3. Let current finished promise be a new (pending) Promise object.
 573         m_finishedPromise = makeUniqueRef&lt;FinishedPromise&gt;(*this, &amp;WebAnimation::finishedPromiseResolve);
 574 
 575         // 4. Create an AnimationPlaybackEvent, cancelEvent.
</pre>
<hr />
<pre>
 579         //    active timeline, let timeline time be n unresolved time value.
 580         // 8. Set cancelEvent&#39;s timelineTime to timeline time. If timeline time is unresolved, set it to null.
 581         // 9. If animation has a document for timing, then append cancelEvent to its document for timing&#39;s pending animation event queue along
 582         //    with its target, animation. If animation is associated with an active timeline that defines a procedure to convert timeline times
 583         //    to origin-relative time, let the scheduled event time be the result of applying that procedure to timeline time. Otherwise, the
 584         //    scheduled event time is an unresolved time value.
 585         // Otherwise, queue a task to dispatch cancelEvent at animation. The task source for this task is the DOM manipulation task source.
 586         if (silently == Silently::No)
 587             enqueueAnimationPlaybackEvent(eventNames().cancelEvent, WTF::nullopt, m_timeline ? m_timeline-&gt;currentTime() : WTF::nullopt);
 588     }
 589 
 590     // 2. Make animation&#39;s hold time unresolved.
 591     m_holdTime = WTF::nullopt;
 592 
 593     // 3. Make animation&#39;s start time unresolved.
 594     m_startTime = WTF::nullopt;
 595 
 596     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
 597 
 598     invalidateEffect();









 599 }
 600 
 601 void WebAnimation::enqueueAnimationPlaybackEvent(const AtomString&amp; type, Optional&lt;Seconds&gt; currentTime, Optional&lt;Seconds&gt; timelineTime)
 602 {
<span class="line-modified"> 603     auto event = AnimationPlaybackEvent::create(type, currentTime, timelineTime);</span>
 604     event-&gt;setTarget(this);


 605 
<span class="line-modified"> 606     if (is&lt;DocumentTimeline&gt;(m_timeline)) {</span>


 607         // If animation has a document for timing, then append event to its document for timing&#39;s pending animation event queue along
 608         // with its target, animation. If animation is associated with an active timeline that defines a procedure to convert timeline times
 609         // to origin-relative time, let the scheduled event time be the result of applying that procedure to timeline time. Otherwise, the
 610         // scheduled event time is an unresolved time value.
<span class="line-modified"> 611         downcast&lt;DocumentTimeline&gt;(*m_timeline).enqueueAnimationPlaybackEvent(WTFMove(event));</span>

 612     } else {
 613         // Otherwise, queue a task to dispatch event at animation. The task source for this task is the DOM manipulation task source.
<span class="line-modified"> 614         callOnMainThread([this, pendingActivity = makePendingActivity(*this), event = WTFMove(event)]() {</span>
<span class="line-removed"> 615             if (!m_isStopped)</span>
<span class="line-removed"> 616                 this-&gt;dispatchEvent(event);</span>
<span class="line-removed"> 617         });</span>
 618     }
 619 }
 620 
 621 void WebAnimation::resetPendingTasks(Silently silently)
 622 {
 623     // The procedure to reset an animation&#39;s pending tasks for animation is as follows:
 624     // https://drafts.csswg.org/web-animations-1/#reset-an-animations-pending-tasks
 625     //
 626     // 1. If animation does not have a pending play task or a pending pause task, abort this procedure.
 627     if (!pending())
 628         return;
 629 
 630     // 2. If animation has a pending play task, cancel that task.
 631     if (hasPendingPlayTask())
 632         m_timeToRunPendingPlayTask = TimeToRunPendingTask::NotScheduled;
 633 
 634     // 3. If animation has a pending pause task, cancel that task.
 635     if (hasPendingPauseTask())
 636         m_timeToRunPendingPauseTask = TimeToRunPendingTask::NotScheduled;
 637 
 638     // 4. Apply any pending playback rate on animation.
 639     applyPendingPlaybackRate();
 640 
 641     // 5. Reject animation&#39;s current ready promise with a DOMException named &quot;AbortError&quot;.
 642     if (silently == Silently::No)
 643         m_readyPromise-&gt;reject(Exception { AbortError });
 644 
 645     // 6. Let animation&#39;s current ready promise be the result of creating a new resolved Promise object.
 646     m_readyPromise = makeUniqueRef&lt;ReadyPromise&gt;(*this, &amp;WebAnimation::readyPromiseResolve);
 647     m_readyPromise-&gt;resolve(*this);
 648 }
 649 
 650 ExceptionOr&lt;void&gt; WebAnimation::finish()
 651 {


 652     // 3.4.15. Finishing an animation
 653     // https://drafts.csswg.org/web-animations-1/#finishing-an-animation-section
 654 
 655     // An animation can be advanced to the natural end of its current playback direction by using the procedure to finish an animation for animation defined below:
 656     //
 657     // 1. If animation&#39;s effective playback rate is zero, or if animation&#39;s effective playback rate &gt; 0 and target effect end is infinity, throw an InvalidStateError and abort these steps.
 658     if (!effectivePlaybackRate() || (effectivePlaybackRate() &gt; 0 &amp;&amp; effectEndTime() == Seconds::infinity()))
 659         return Exception { InvalidStateError };
 660 
 661     // 2. Apply any pending playback rate to animation.
 662     applyPendingPlaybackRate();
 663 
 664     // 3. Set limit as follows:
 665     // If animation playback rate &gt; 0, let limit be target effect end.
 666     // Otherwise, let limit be zero.
 667     auto limit = m_playbackRate &gt; 0 ? effectEndTime() : 0_s;
 668 
 669     // 4. Silently set the current time to limit.
 670     silentlySetCurrentTime(limit);
 671 
</pre>
<hr />
<pre>
 681         // 2. Cancel the pending pause task.
 682         m_timeToRunPendingPauseTask = TimeToRunPendingTask::NotScheduled;
 683         // 3. Resolve the current ready promise of animation with animation.
 684         m_readyPromise-&gt;resolve(*this);
 685     }
 686 
 687     // 7. If there is a pending play task and start time is resolved, cancel that task and resolve the current ready promise of animation with animation.
 688     if (hasPendingPlayTask() &amp;&amp; m_startTime) {
 689         m_timeToRunPendingPlayTask = TimeToRunPendingTask::NotScheduled;
 690         m_readyPromise-&gt;resolve(*this);
 691     }
 692 
 693     // 8. Run the procedure to update an animation&#39;s finished state animation with the did seek flag set to true, and the synchronously notify flag set to true.
 694     timingDidChange(DidSeek::Yes, SynchronouslyNotify::Yes);
 695 
 696     invalidateEffect();
 697 
 698     return { };
 699 }
 700 
<span class="line-modified"> 701 void WebAnimation::timingDidChange(DidSeek didSeek, SynchronouslyNotify synchronouslyNotify)</span>
 702 {
 703     m_shouldSkipUpdatingFinishedStateWhenResolving = false;
 704     updateFinishedState(didSeek, synchronouslyNotify);
<span class="line-modified"> 705     if (m_timeline)</span>






 706         m_timeline-&gt;animationTimingDidChange(*this);
 707 };
 708 
 709 void WebAnimation::invalidateEffect()
 710 {
 711     if (!isEffectInvalidationSuspended() &amp;&amp; m_effect)
 712         m_effect-&gt;invalidate();
 713 }
 714 
 715 void WebAnimation::updateFinishedState(DidSeek didSeek, SynchronouslyNotify synchronouslyNotify)
 716 {
 717     // 3.4.14. Updating the finished state
 718     // https://drafts.csswg.org/web-animations-1/#updating-the-finished-state
 719 
 720     // 1. Let the unconstrained current time be the result of calculating the current time substituting an unresolved time value
 721     // for the hold time if did seek is false. If did seek is true, the unconstrained current time is equal to the current time.
 722     auto unconstrainedCurrentTime = currentTime(didSeek == DidSeek::Yes ? RespectHoldTime::Yes : RespectHoldTime::No);
 723     auto endTime = effectEndTime();
 724 
 725     // 2. If all three of the following conditions are true,
</pre>
<hr />
<pre>
 760         }
 761     }
 762 
 763     // 3. Set the previous current time of animation be the result of calculating its current time.
 764     m_previousCurrentTime = currentTime();
 765 
 766     // 4. Let current finished state be true if the play state of animation is finished. Otherwise, let it be false.
 767     auto currentFinishedState = playState() == PlayState::Finished;
 768 
 769     // 5. If current finished state is true and the current finished promise is not yet resolved, perform the following steps:
 770     if (currentFinishedState &amp;&amp; !m_finishedPromise-&gt;isFulfilled()) {
 771         if (synchronouslyNotify == SynchronouslyNotify::Yes) {
 772             // If synchronously notify is true, cancel any queued microtask to run the finish notification steps for this animation,
 773             // and run the finish notification steps immediately.
 774             m_finishNotificationStepsMicrotaskPending = false;
 775             finishNotificationSteps();
 776         } else if (!m_finishNotificationStepsMicrotaskPending) {
 777             // Otherwise, if synchronously notify is false, queue a microtask to run finish notification steps for animation unless there
 778             // is already a microtask queued to run those steps for animation.
 779             m_finishNotificationStepsMicrotaskPending = true;
<span class="line-modified"> 780             MicrotaskQueue::mainThreadQueue().append(makeUnique&lt;VoidMicrotask&gt;([this, protectedThis = makeRef(*this)] () {</span>
<span class="line-modified"> 781                 if (m_finishNotificationStepsMicrotaskPending) {</span>
<span class="line-modified"> 782                     m_finishNotificationStepsMicrotaskPending = false;</span>
<span class="line-modified"> 783                     finishNotificationSteps();</span>
<span class="line-modified"> 784                 }</span>
<span class="line-modified"> 785             }));</span>


 786         }
 787     }
 788 
 789     // 6. If current finished state is false and animation&#39;s current finished promise is already resolved, set animation&#39;s current
 790     // finished promise to a new (pending) Promise object.
 791     if (!currentFinishedState &amp;&amp; m_finishedPromise-&gt;isFulfilled())
 792         m_finishedPromise = makeUniqueRef&lt;FinishedPromise&gt;(*this, &amp;WebAnimation::finishedPromiseResolve);
 793 
 794     updateRelevance();
 795 }
 796 
 797 void WebAnimation::finishNotificationSteps()
 798 {
 799     // 3.4.14. Updating the finished state
 800     // https://drafts.csswg.org/web-animations-1/#finish-notification-steps
 801 
 802     // Let finish notification steps refer to the following procedure:
 803     // 1. If animation&#39;s play state is not equal to finished, abort these steps.
 804     if (playState() != PlayState::Finished)
 805         return;
</pre>
<hr />
<pre>
 809 
 810     // 3. Create an AnimationPlaybackEvent, finishEvent.
 811     // 4. Set finishEvent&#39;s type attribute to finish.
 812     // 5. Set finishEvent&#39;s currentTime attribute to the current time of animation.
 813     // 6. Set finishEvent&#39;s timelineTime attribute to the current time of the timeline with which animation is associated.
 814     //    If animation is not associated with a timeline, or the timeline is inactive, let timelineTime be null.
 815     // 7. If animation has a document for timing, then append finishEvent to its document for timing&#39;s pending animation event
 816     //    queue along with its target, animation. For the scheduled event time, use the result of converting animation&#39;s target
 817     //    effect end to an origin-relative time.
 818     //    Otherwise, queue a task to dispatch finishEvent at animation. The task source for this task is the DOM manipulation task source.
 819     enqueueAnimationPlaybackEvent(eventNames().finishEvent, currentTime(), m_timeline ? m_timeline-&gt;currentTime() : WTF::nullopt);
 820 }
 821 
 822 ExceptionOr&lt;void&gt; WebAnimation::play()
 823 {
 824     return play(AutoRewind::Yes);
 825 }
 826 
 827 ExceptionOr&lt;void&gt; WebAnimation::play(AutoRewind autoRewind)
 828 {


 829     // 3.4.10. Playing an animation
 830     // https://drafts.csswg.org/web-animations-1/#play-an-animation
 831 
 832     auto localTime = currentTime();
 833     auto endTime = effectEndTime();
 834 
 835     // 1. Let aborted pause be a boolean flag that is true if animation has a pending pause task, and false otherwise.
 836     bool abortedPause = hasPendingPauseTask();
 837 
 838     // 2. Let has pending ready promise be a boolean flag that is initially false.
 839     bool hasPendingReadyPromise = false;
 840 
 841     // 3. Perform the steps corresponding to the first matching condition from the following, if any:
 842     if (effectivePlaybackRate() &gt; 0 &amp;&amp; autoRewind == AutoRewind::Yes &amp;&amp; (!localTime || localTime.value() &lt; 0_s || localTime.value() &gt;= endTime)) {
 843         // If animation&#39;s effective playback rate &gt; 0, the auto-rewind flag is true and either animation&#39;s:
 844         //     - current time is unresolved, or
 845         //     - current time &lt; zero, or
 846         //     - current time ≥ target effect end,
 847         // Set animation&#39;s hold time to zero.
 848         m_holdTime = 0_s;
</pre>
<hr />
<pre>
 877     // abort this procedure.
 878     if (!m_holdTime &amp;&amp; !abortedPause &amp;&amp; !m_pendingPlaybackRate)
 879         return { };
 880 
 881     // 6. If animation&#39;s hold time is resolved, let its start time be unresolved.
 882     if (m_holdTime)
 883         m_startTime = WTF::nullopt;
 884 
 885     // 7. If has pending ready promise is false, let animation&#39;s current ready promise be a new (pending) Promise object.
 886     if (!hasPendingReadyPromise)
 887         m_readyPromise = makeUniqueRef&lt;ReadyPromise&gt;(*this, &amp;WebAnimation::readyPromiseResolve);
 888 
 889     // 8. Schedule a task to run as soon as animation is ready.
 890     m_timeToRunPendingPlayTask = TimeToRunPendingTask::WhenReady;
 891 
 892     // 9. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
 893     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
 894 
 895     invalidateEffect();
 896 



 897     return { };
 898 }
 899 
 900 void WebAnimation::runPendingPlayTask()
 901 {


 902     // 3.4.10. Playing an animation, step 8.
 903     // https://drafts.csswg.org/web-animations-1/#play-an-animation
 904 
 905     m_timeToRunPendingPlayTask = TimeToRunPendingTask::NotScheduled;
 906 
 907     // 1. Assert that at least one of animation&#39;s start time or hold time is resolved.
 908     ASSERT(m_startTime || m_holdTime);
 909 
 910     // 2. Let ready time be the time value of the timeline associated with animation at the moment when animation became ready.
 911     auto readyTime = m_timeline-&gt;currentTime();
 912 
 913     // 3. Perform the steps corresponding to the first matching condition below, if any:
 914     if (m_holdTime) {
 915         // If animation&#39;s hold time is resolved,
 916         // 1. Apply any pending playback rate on animation.
 917         applyPendingPlaybackRate();
 918         // 2. Let new start time be the result of evaluating ready time - hold time / animation playback rate for animation.
 919         // If the animation playback rate is zero, let new start time be simply ready time.
 920         // FIXME: Implementation cannot guarantee an active timeline at the point of this async dispatch.
 921         // Subsequently, the resulting readyTime value can be null. Unify behavior between C++17 and
</pre>
<hr />
<pre>
 935         auto currentTimeToMatch = (readyTime.valueOr(0_s) - m_startTime.value()) * m_playbackRate;
 936         // 2. Apply any pending playback rate on animation.
 937         applyPendingPlaybackRate();
 938         // 3. If animation&#39;s playback rate is zero, let animation&#39;s hold time be current time to match.
 939         if (m_playbackRate)
 940             m_holdTime = currentTimeToMatch;
 941         // 4. Let new start time be the result of evaluating ready time - current time to match / playback rate for animation.
 942         // If the playback rate is zero, let new start time be simply ready time.
 943         auto newStartTime = readyTime.valueOr(0_s);
 944         if (m_playbackRate)
 945             newStartTime -= currentTimeToMatch / m_playbackRate;
 946         // 5. Set the start time of animation to new start time.
 947         m_startTime = newStartTime;
 948     }
 949 
 950     // 4. Resolve animation&#39;s current ready promise with animation.
 951     if (!m_readyPromise-&gt;isFulfilled())
 952         m_readyPromise-&gt;resolve(*this);
 953 
 954     // 5. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
<span class="line-modified"> 955     timingDidChange(DidSeek::No, SynchronouslyNotify::No);</span>
 956 
 957     invalidateEffect();
 958 }
 959 
 960 ExceptionOr&lt;void&gt; WebAnimation::pause()
 961 {


 962     // 3.4.11. Pausing an animation
 963     // https://drafts.csswg.org/web-animations-1/#pause-an-animation
 964 
 965     // 1. If animation has a pending pause task, abort these steps.
 966     if (hasPendingPauseTask())
 967         return { };
 968 
 969     // 2. If the play state of animation is paused, abort these steps.
 970     if (playState() == PlayState::Paused)
 971         return { };
 972 
 973     auto localTime = currentTime();
 974 
 975     // 3. If the animation&#39;s current time is unresolved, perform the steps according to the first matching condition from below:
 976     if (!localTime) {
 977         if (m_playbackRate &gt;= 0) {
 978             // If animation&#39;s playback rate is ≥ 0, let animation&#39;s hold time be zero.
 979             m_holdTime = 0_s;
 980         } else if (effectEndTime() == Seconds::infinity()) {
 981             // Otherwise, if target effect end for animation is positive infinity, throw an InvalidStateError and abort these steps.
</pre>
<hr />
<pre>
 996     }
 997 
 998     // 6. If has pending ready promise is false, set animation&#39;s current ready promise to a new (pending) Promise object.
 999     if (!hasPendingReadyPromise)
1000         m_readyPromise = makeUniqueRef&lt;ReadyPromise&gt;(*this, &amp;WebAnimation::readyPromiseResolve);
1001 
1002     // 7. Schedule a task to be executed at the first possible moment after the user agent has performed any processing necessary
1003     //    to suspend the playback of animation&#39;s target effect, if any.
1004     m_timeToRunPendingPauseTask = TimeToRunPendingTask::ASAP;
1005 
1006     // 8. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
1007     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
1008 
1009     invalidateEffect();
1010 
1011     return { };
1012 }
1013 
1014 ExceptionOr&lt;void&gt; WebAnimation::reverse()
1015 {


1016     // 3.4.18. Reversing an animation
1017     // https://drafts.csswg.org/web-animations-1/#reverse-an-animation
1018 
1019     // The procedure to reverse an animation of animation animation is as follows:
1020 
1021     // 1. If there is no timeline associated with animation, or the associated timeline is inactive
1022     //    throw an InvalidStateError and abort these steps.
1023     if (!m_timeline || !m_timeline-&gt;currentTime())
1024         return Exception { InvalidStateError };
1025 
1026     // 2. Let original pending playback rate be animation&#39;s pending playback rate.
1027     auto originalPendingPlaybackRate = m_pendingPlaybackRate;
1028 
1029     // 3. Let animation&#39;s pending playback rate be the additive inverse of its effective playback rate (i.e. -effective playback rate).
1030     m_pendingPlaybackRate = -effectivePlaybackRate();
1031 
1032     // 4. Run the steps to play an animation for animation with the auto-rewind flag set to true.
1033     auto playResult = play(AutoRewind::Yes);
1034 
1035     // If the steps to play an animation throw an exception, set animation&#39;s pending playback rate to original
1036     // pending playback rate and propagate the exception.
1037     if (playResult.hasException()) {
1038         m_pendingPlaybackRate = originalPendingPlaybackRate;
1039         return playResult.releaseException();
1040     }
1041 
1042     return { };
1043 }
1044 
1045 void WebAnimation::runPendingPauseTask()
1046 {


1047     // 3.4.11. Pausing an animation, step 7.
1048     // https://drafts.csswg.org/web-animations-1/#pause-an-animation
1049 
1050     m_timeToRunPendingPauseTask = TimeToRunPendingTask::NotScheduled;
1051 
1052     // 1. Let ready time be the time value of the timeline associated with animation at the moment when the user agent
1053     //    completed processing necessary to suspend playback of animation&#39;s target effect.
1054     auto readyTime = m_timeline-&gt;currentTime();
1055     auto animationStartTime = m_startTime;
1056 
1057     // 2. If animation&#39;s start time is resolved and its hold time is not resolved, let animation&#39;s hold time be the result of
1058     //    evaluating (ready time - start time) × playback rate.
1059     //    Note: The hold time might be already set if the animation is finished, or if the animation is pending, waiting to begin
1060     //    playback. In either case we want to preserve the hold time as we enter the paused state.
1061     if (animationStartTime &amp;&amp; !m_holdTime) {
1062         // FIXME: Implementation cannot guarantee an active timeline at the point of this async dispatch.
1063         // Subsequently, the resulting readyTime value can be null. Unify behavior between C++17 and
1064         // C++14 builds (the latter using WTF&#39;s Optional) and avoid null Optional dereferencing
1065         // by defaulting to a Seconds(0) value. See https://bugs.webkit.org/show_bug.cgi?id=186189.
1066         m_holdTime = (readyTime.valueOr(0_s) - animationStartTime.value()) * m_playbackRate;
1067     }
1068 
1069     // 3. Apply any pending playback rate on animation.
1070     applyPendingPlaybackRate();
1071 
1072     // 4. Make animation&#39;s start time unresolved.
1073     m_startTime = WTF::nullopt;
1074 
1075     // 5. Resolve animation&#39;s current ready promise with animation.
1076     if (!m_readyPromise-&gt;isFulfilled())
1077         m_readyPromise-&gt;resolve(*this);
1078 
1079     // 6. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false, and the
1080     //    synchronously notify flag set to false.
<span class="line-modified">1081     timingDidChange(DidSeek::No, SynchronouslyNotify::No);</span>
1082 
1083     invalidateEffect();
1084 }
1085 
1086 bool WebAnimation::isRunningAccelerated() const
1087 {
1088     return is&lt;KeyframeEffect&gt;(m_effect) &amp;&amp; downcast&lt;KeyframeEffect&gt;(*m_effect).isRunningAccelerated();
1089 }
1090 





1091 bool WebAnimation::needsTick() const
1092 {
<span class="line-modified">1093     return pending() || playState() == PlayState::Running;</span>
1094 }
1095 
1096 void WebAnimation::tick()
1097 {

1098     updateFinishedState(DidSeek::No, SynchronouslyNotify::Yes);
1099     m_shouldSkipUpdatingFinishedStateWhenResolving = true;
1100 
1101     // Run pending tasks, if any.
1102     if (hasPendingPauseTask())
1103         runPendingPauseTask();
1104     if (hasPendingPlayTask())
1105         runPendingPlayTask();
1106 
<span class="line-modified">1107     invalidateEffect();</span>

1108 }
1109 
1110 void WebAnimation::resolve(RenderStyle&amp; targetStyle)
1111 {
1112     if (!m_shouldSkipUpdatingFinishedStateWhenResolving)
1113         updateFinishedState(DidSeek::No, SynchronouslyNotify::Yes);
1114     m_shouldSkipUpdatingFinishedStateWhenResolving = false;
1115 
1116     if (m_effect)
1117         m_effect-&gt;apply(targetStyle);
1118 }
1119 
1120 void WebAnimation::setSuspended(bool isSuspended)
1121 {
1122     if (m_isSuspended == isSuspended)
1123         return;
1124 
1125     m_isSuspended = isSuspended;
1126 
1127     if (m_effect &amp;&amp; playState() == PlayState::Running)
1128         m_effect-&gt;animationSuspensionStateDidChange(isSuspended);
1129 }
1130 
1131 void WebAnimation::acceleratedStateDidChange()
1132 {
<span class="line-modified">1133     if (is&lt;DocumentTimeline&gt;(m_timeline))</span>
1134         downcast&lt;DocumentTimeline&gt;(*m_timeline).animationAcceleratedRunningStateDidChange(*this);
1135 }
1136 
1137 void WebAnimation::applyPendingAcceleratedActions()
1138 {
1139     if (is&lt;KeyframeEffect&gt;(m_effect))
1140         downcast&lt;KeyframeEffect&gt;(*m_effect).applyPendingAcceleratedActions();
1141 }
1142 
1143 WebAnimation&amp; WebAnimation::readyPromiseResolve()
1144 {
1145     return *this;
1146 }
1147 
1148 WebAnimation&amp; WebAnimation::finishedPromiseResolve()
1149 {
1150     return *this;
1151 }
1152 
1153 const char* WebAnimation::activeDOMObjectName() const
1154 {
1155     return &quot;Animation&quot;;
1156 }
1157 
<span class="line-modified">1158 bool WebAnimation::canSuspendForDocumentSuspension() const</span>
1159 {
<span class="line-modified">1160     // Use the base class&#39;s implementation of hasPendingActivity() since we wouldn&#39;t want the custom implementation</span>
<span class="line-modified">1161     // in this class designed to keep JS wrappers alive to interfere with the ability for a page using animations</span>
<span class="line-modified">1162     // to enter the page cache.</span>
<span class="line-modified">1163     return !ActiveDOMObject::hasPendingActivity();</span>


1164 }
1165 
1166 void WebAnimation::stop()
1167 {
1168     ActiveDOMObject::stop();
<span class="line-removed">1169     m_isStopped = true;</span>
1170     removeAllEventListeners();
1171 }
1172 
1173 bool WebAnimation::hasPendingActivity() const
1174 {
1175     // Keep the JS wrapper alive if the animation is considered relevant or could become relevant again by virtue of having a timeline.
1176     return m_timeline || m_isRelevant || ActiveDOMObject::hasPendingActivity();
1177 }
1178 
1179 void WebAnimation::updateRelevance()
1180 {
1181     m_isRelevant = computeRelevance();
1182 }
1183 
1184 bool WebAnimation::computeRelevance()
1185 {
1186     // To be listed in getAnimations() an animation needs a target effect which is current or in effect.
1187     if (!m_effect)
1188         return false;
1189 



1190     auto timing = m_effect-&gt;getBasicTiming();
1191 
1192     // An animation effect is in effect if its active time is not unresolved.
1193     if (timing.activeTime)
1194         return true;
1195 
1196     // An animation effect is current if either of the following conditions is true:
1197     // - the animation effect is in the before phase, or
1198     // - the animation effect is in play.
1199 
1200     // An animation effect is in play if all of the following conditions are met:
1201     // - the animation effect is in the active phase, and
1202     // - the animation effect is associated with an animation that is not finished.
1203     return timing.phase == AnimationEffectPhase::Before || (timing.phase == AnimationEffectPhase::Active &amp;&amp; playState() != PlayState::Finished);
1204 }
1205 

























































































































1206 Seconds WebAnimation::timeToNextTick() const
1207 {
<span class="line-modified">1208     ASSERT(isRunningAccelerated());</span>
1209 
1210     if (pending())
1211         return 0_s;
1212 
<span class="line-modified">1213     // If we&#39;re not running, there&#39;s no telling when we&#39;ll end.</span>
<span class="line-modified">1214     if (playState() != PlayState::Running)</span>

1215         return Seconds::infinity();
1216 
<span class="line-modified">1217     // CSS Animations dispatch events for each iteration, so compute the time until</span>
<span class="line-modified">1218     // the end of this iteration. Any other animation only cares about remaning total time.</span>
<span class="line-modified">1219     if (isCSSAnimation()) {</span>
<span class="line-modified">1220         auto* animationEffect = effect();</span>
<span class="line-modified">1221         auto timing = animationEffect-&gt;getComputedTiming();</span>
<span class="line-modified">1222         // If we&#39;re actively running, we need the time until the next iteration.</span>
<span class="line-modified">1223         if (auto iterationProgress = timing.simpleIterationProgress)</span>
<span class="line-modified">1224             return animationEffect-&gt;iterationDuration() * (1 - *iterationProgress);</span>
<span class="line-modified">1225 </span>
<span class="line-modified">1226         // Otherwise we&#39;re probably in the before phase waiting to reach our start time.</span>
<span class="line-modified">1227         if (auto animationCurrentTime = currentTime()) {</span>
<span class="line-modified">1228             // If our current time is negative, we need to be scheduled to be resolved at the inverse</span>
<span class="line-modified">1229             // of our current time, unless we fill backwards, in which case we want to invalidate as</span>
<span class="line-modified">1230             // soon as possible.</span>
<span class="line-modified">1231             auto localTime = animationCurrentTime.value();</span>
<span class="line-removed">1232             if (localTime &lt; 0_s)</span>
<span class="line-removed">1233                 return -localTime;</span>
<span class="line-removed">1234             if (localTime &lt; animationEffect-&gt;delay())</span>
<span class="line-removed">1235                 return animationEffect-&gt;delay() - localTime;</span>
1236         }
<span class="line-modified">1237     } else if (auto animationCurrentTime = currentTime())</span>
<span class="line-modified">1238         return effect()-&gt;getBasicTiming().endTime - *animationCurrentTime;</span>







1239 
1240     ASSERT_NOT_REACHED();
1241     return Seconds::infinity();
1242 }
1243 
1244 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WebAnimation.h&quot;
  28 
  29 #include &quot;AnimationEffect.h&quot;
  30 #include &quot;AnimationPlaybackEvent.h&quot;
  31 #include &quot;AnimationTimeline.h&quot;
<span class="line-added">  32 #include &quot;CSSComputedStyleDeclaration.h&quot;</span>
<span class="line-added">  33 #include &quot;DOMPromiseProxy.h&quot;</span>
<span class="line-added">  34 #include &quot;DeclarativeAnimation.h&quot;</span>
  35 #include &quot;Document.h&quot;
  36 #include &quot;DocumentTimeline.h&quot;
<span class="line-added">  37 #include &quot;EventLoop.h&quot;</span>
  38 #include &quot;EventNames.h&quot;
<span class="line-added">  39 #include &quot;InspectorInstrumentation.h&quot;</span>
  40 #include &quot;JSWebAnimation.h&quot;
  41 #include &quot;KeyframeEffect.h&quot;
<span class="line-modified">  42 #include &quot;KeyframeEffectStack.h&quot;</span>
<span class="line-added">  43 #include &quot;Logging.h&quot;</span>
<span class="line-added">  44 #include &quot;RenderElement.h&quot;</span>
<span class="line-added">  45 #include &quot;StyledElement.h&quot;</span>
  46 #include &quot;WebAnimationUtilities.h&quot;
  47 #include &lt;wtf/IsoMallocInlines.h&gt;
<span class="line-added">  48 #include &lt;wtf/Lock.h&gt;</span>
<span class="line-added">  49 #include &lt;wtf/NeverDestroyed.h&gt;</span>
  50 #include &lt;wtf/Optional.h&gt;
<span class="line-added">  51 #include &lt;wtf/text/TextStream.h&gt;</span>
  52 #include &lt;wtf/text/WTFString.h&gt;
  53 
  54 namespace WebCore {
  55 
  56 WTF_MAKE_ISO_ALLOCATED_IMPL(WebAnimation);
  57 
<span class="line-added">  58 HashSet&lt;WebAnimation*&gt;&amp; WebAnimation::instances(const LockHolder&amp;)</span>
<span class="line-added">  59 {</span>
<span class="line-added">  60     static NeverDestroyed&lt;HashSet&lt;WebAnimation*&gt;&gt; instances;</span>
<span class="line-added">  61     return instances;</span>
<span class="line-added">  62 }</span>
<span class="line-added">  63 </span>
<span class="line-added">  64 Lock&amp; WebAnimation::instancesMutex()</span>
<span class="line-added">  65 {</span>
<span class="line-added">  66     static LazyNeverDestroyed&lt;Lock&gt; mutex;</span>
<span class="line-added">  67     static std::once_flag initializeMutex;</span>
<span class="line-added">  68     std::call_once(initializeMutex, [] {</span>
<span class="line-added">  69         mutex.construct();</span>
<span class="line-added">  70     });</span>
<span class="line-added">  71     return mutex.get();</span>
<span class="line-added">  72 }</span>
<span class="line-added">  73 </span>
  74 Ref&lt;WebAnimation&gt; WebAnimation::create(Document&amp; document, AnimationEffect* effect)
  75 {
  76     auto result = adoptRef(*new WebAnimation(document));
  77     result-&gt;setEffect(effect);
  78     result-&gt;setTimeline(&amp;document.timeline());
<span class="line-added">  79 </span>
<span class="line-added">  80     InspectorInstrumentation::didCreateWebAnimation(result.get());</span>
<span class="line-added">  81 </span>
  82     return result;
  83 }
  84 
  85 Ref&lt;WebAnimation&gt; WebAnimation::create(Document&amp; document, AnimationEffect* effect, AnimationTimeline* timeline)
  86 {
  87     auto result = adoptRef(*new WebAnimation(document));
  88     result-&gt;setEffect(effect);
  89     if (timeline)
  90         result-&gt;setTimeline(timeline);
<span class="line-added">  91 </span>
<span class="line-added">  92     InspectorInstrumentation::didCreateWebAnimation(result.get());</span>
<span class="line-added">  93 </span>
  94     return result;
  95 }
  96 
  97 WebAnimation::WebAnimation(Document&amp; document)
  98     : ActiveDOMObject(document)
  99     , m_readyPromise(makeUniqueRef&lt;ReadyPromise&gt;(*this, &amp;WebAnimation::readyPromiseResolve))
 100     , m_finishedPromise(makeUniqueRef&lt;FinishedPromise&gt;(*this, &amp;WebAnimation::finishedPromiseResolve))
 101 {
 102     m_readyPromise-&gt;resolve(*this);
 103     suspendIfNeeded();
<span class="line-added"> 104 </span>
<span class="line-added"> 105     LockHolder lock(instancesMutex());</span>
<span class="line-added"> 106     instances(lock).add(this);</span>
 107 }
 108 
 109 WebAnimation::~WebAnimation()
 110 {
<span class="line-added"> 111     InspectorInstrumentation::willDestroyWebAnimation(*this);</span>
<span class="line-added"> 112 </span>
 113     if (m_timeline)
 114         m_timeline-&gt;forgetAnimation(this);
<span class="line-added"> 115 </span>
<span class="line-added"> 116     LockHolder lock(instancesMutex());</span>
<span class="line-added"> 117     ASSERT(instances(lock).contains(this));</span>
<span class="line-added"> 118     instances(lock).remove(this);</span>
<span class="line-added"> 119 }</span>
<span class="line-added"> 120 </span>
<span class="line-added"> 121 void WebAnimation::contextDestroyed()</span>
<span class="line-added"> 122 {</span>
<span class="line-added"> 123     InspectorInstrumentation::willDestroyWebAnimation(*this);</span>
<span class="line-added"> 124 </span>
<span class="line-added"> 125     ActiveDOMObject::contextDestroyed();</span>
 126 }
 127 
 128 void WebAnimation::remove()
 129 {
 130     // This object could be deleted after either clearing the effect or timeline relationship.
 131     auto protectedThis = makeRef(*this);
 132     setEffectInternal(nullptr);
 133     setTimelineInternal(nullptr);
 134 }
 135 
 136 void WebAnimation::suspendEffectInvalidation()
 137 {
 138     ++m_suspendCount;
 139 }
 140 
 141 void WebAnimation::unsuspendEffectInvalidation()
 142 {
 143     ASSERT(m_suspendCount &gt; 0);
 144     --m_suspendCount;
 145 }
 146 
<span class="line-modified"> 147 void WebAnimation::effectTimingDidChange(Optional&lt;ComputedEffectTiming&gt; previousTiming)</span>
 148 {
 149     timingDidChange(DidSeek::No, SynchronouslyNotify::Yes);
<span class="line-added"> 150 </span>
<span class="line-added"> 151     InspectorInstrumentation::didChangeWebAnimationEffectTiming(*this);</span>
<span class="line-added"> 152 </span>
<span class="line-added"> 153     if (!previousTiming)</span>
<span class="line-added"> 154         return;</span>
<span class="line-added"> 155 </span>
<span class="line-added"> 156     auto* effect = this-&gt;effect();</span>
<span class="line-added"> 157     ASSERT(effect);</span>
<span class="line-added"> 158     if (previousTiming-&gt;progress != effect-&gt;getComputedTiming().progress)</span>
<span class="line-added"> 159         effect-&gt;animationDidSeek();</span>
 160 }
 161 
 162 void WebAnimation::setEffect(RefPtr&lt;AnimationEffect&gt;&amp;&amp; newEffect)
 163 {
 164     // 3.4.3. Setting the target effect of an animation
 165     // https://drafts.csswg.org/web-animations-1/#setting-the-target-effect
 166 
 167     // 1. Let old effect be the current target effect of animation, if any.
 168     auto oldEffect = m_effect;
 169 
 170     // 2. If new effect is the same object as old effect, abort this procedure.
 171     if (newEffect == oldEffect)
 172         return;
 173 
 174     // 3. If animation has a pending pause task, reschedule that task to run as soon as animation is ready.
 175     if (hasPendingPauseTask())
 176         m_timeToRunPendingPauseTask = TimeToRunPendingTask::WhenReady;
 177 
 178     // 4. If animation has a pending play task, reschedule that task to run as soon as animation is ready to play new effect.
 179     if (hasPendingPlayTask())
</pre>
<hr />
<pre>
 185         newEffect-&gt;animation()-&gt;setEffect(nullptr);
 186 
 187     // 6. Let the target effect of animation be new effect.
 188     // In the case of a declarative animation, we don&#39;t want to remove the animation from the relevant maps because
 189     // while the effect was set via the API, the element still has a transition or animation set up and we must
 190     // not break the timeline-to-animation relationship.
 191 
 192     invalidateEffect();
 193 
 194     // This object could be deleted after clearing the effect relationship.
 195     auto protectedThis = makeRef(*this);
 196     setEffectInternal(WTFMove(newEffect), isDeclarativeAnimation());
 197 
 198     // 7. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false,
 199     // and the synchronously notify flag set to false.
 200     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
 201 
 202     invalidateEffect();
 203 }
 204 
<span class="line-added"> 205 AnimationTimeline* WebAnimation::timeline() const</span>
<span class="line-added"> 206 {</span>
<span class="line-added"> 207     return m_timeline.get();</span>
<span class="line-added"> 208 }</span>
<span class="line-added"> 209 </span>
 210 void WebAnimation::setEffectInternal(RefPtr&lt;AnimationEffect&gt;&amp;&amp; newEffect, bool doNotRemoveFromTimeline)
 211 {
 212     if (m_effect == newEffect)
 213         return;
 214 
 215     auto oldEffect = std::exchange(m_effect, WTFMove(newEffect));
 216 
 217     Element* previousTarget = nullptr;
 218     if (is&lt;KeyframeEffect&gt;(oldEffect))
 219         previousTarget = downcast&lt;KeyframeEffect&gt;(oldEffect.get())-&gt;target();
 220 
 221     Element* newTarget = nullptr;
 222     if (is&lt;KeyframeEffect&gt;(m_effect))
 223         newTarget = downcast&lt;KeyframeEffect&gt;(m_effect.get())-&gt;target();
 224 
 225     // Update the effect-to-animation relationships and the timeline&#39;s animation map.
 226     if (oldEffect) {
 227         oldEffect-&gt;setAnimation(nullptr);
 228         if (!doNotRemoveFromTimeline &amp;&amp; m_timeline &amp;&amp; previousTarget &amp;&amp; previousTarget != newTarget)
 229             m_timeline-&gt;animationWasRemovedFromElement(*this, *previousTarget);
 230         updateRelevance();
 231     }
 232 
 233     if (m_effect) {
 234         m_effect-&gt;setAnimation(this);
 235         if (m_timeline &amp;&amp; newTarget &amp;&amp; previousTarget != newTarget)
 236             m_timeline-&gt;animationWasAddedToElement(*this, *newTarget);
 237     }
<span class="line-added"> 238 </span>
<span class="line-added"> 239     InspectorInstrumentation::didSetWebAnimationEffect(*this);</span>
 240 }
 241 
 242 void WebAnimation::setTimeline(RefPtr&lt;AnimationTimeline&gt;&amp;&amp; timeline)
 243 {
 244     // 3.4.1. Setting the timeline of an animation
 245     // https://drafts.csswg.org/web-animations-1/#setting-the-timeline
 246 
 247     // 2. If new timeline is the same object as old timeline, abort this procedure.
<span class="line-modified"> 248     if (timeline == m_timeline.get())</span>
 249         return;
 250 
 251     // 4. If the animation start time of animation is resolved, make animation&#39;s hold time unresolved.
 252     if (m_startTime)
 253         m_holdTime = WTF::nullopt;
 254 
 255     if (is&lt;KeyframeEffect&gt;(m_effect)) {
 256         auto* keyframeEffect = downcast&lt;KeyframeEffect&gt;(m_effect.get());
 257         auto* target = keyframeEffect-&gt;target();
 258         if (target) {
 259             // In the case of a declarative animation, we don&#39;t want to remove the animation from the relevant maps because
 260             // while the timeline was set via the API, the element still has a transition or animation set up and we must
 261             // not break the relationship.
 262             if (m_timeline &amp;&amp; !isDeclarativeAnimation())
 263                 m_timeline-&gt;animationWasRemovedFromElement(*this, *target);
 264             if (timeline)
 265                 timeline-&gt;animationWasAddedToElement(*this, *target);
 266         }
 267     }
 268 
 269     // This object could be deleted after clearing the timeline relationship.
 270     auto protectedThis = makeRef(*this);
 271     setTimelineInternal(WTFMove(timeline));
 272 
<span class="line-modified"> 273     setSuspended(is&lt;DocumentTimeline&gt;(m_timeline.get()) &amp;&amp; downcast&lt;DocumentTimeline&gt;(*m_timeline).animationsAreSuspended());</span>
 274 
 275     // 5. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false,
 276     // and the synchronously notify flag set to false.
 277     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
 278 
 279     invalidateEffect();
 280 }
 281 
 282 void WebAnimation::setTimelineInternal(RefPtr&lt;AnimationTimeline&gt;&amp;&amp; timeline)
 283 {
<span class="line-modified"> 284     if (m_timeline.get() == timeline)</span>
 285         return;
 286 
 287     if (m_timeline)
 288         m_timeline-&gt;removeAnimation(*this);
 289 
<span class="line-modified"> 290     m_timeline = makeWeakPtr(timeline.get());</span>
<span class="line-added"> 291 </span>
<span class="line-added"> 292     if (m_effect)</span>
<span class="line-added"> 293         m_effect-&gt;animationTimelineDidChange(m_timeline.get());</span>
 294 }
 295 
 296 void WebAnimation::effectTargetDidChange(Element* previousTarget, Element* newTarget)
 297 {
<span class="line-modified"> 298     if (m_timeline) {</span>
<span class="line-modified"> 299         if (previousTarget)</span>
<span class="line-added"> 300             m_timeline-&gt;animationWasRemovedFromElement(*this, *previousTarget);</span>
<span class="line-added"> 301 </span>
<span class="line-added"> 302         if (newTarget)</span>
<span class="line-added"> 303             m_timeline-&gt;animationWasAddedToElement(*this, *newTarget);</span>
 304 
<span class="line-modified"> 305         // This could have changed whether we have replaced animations, so we may need to schedule an update.</span>
<span class="line-modified"> 306         m_timeline-&gt;animationTimingDidChange(*this);</span>
<span class="line-added"> 307     }</span>
 308 
<span class="line-modified"> 309     InspectorInstrumentation::didChangeWebAnimationEffectTarget(*this);</span>

 310 }
 311 
 312 Optional&lt;double&gt; WebAnimation::startTime() const
 313 {
 314     if (!m_startTime)
 315         return WTF::nullopt;
 316     return secondsToWebAnimationsAPITime(m_startTime.value());
 317 }
 318 
 319 void WebAnimation::setStartTime(Optional&lt;double&gt; startTime)
 320 {
 321     // 3.4.6 The procedure to set the start time of animation, animation, to new start time, is as follows:
 322     // https://drafts.csswg.org/web-animations/#setting-the-start-time-of-an-animation
 323 
 324     Optional&lt;Seconds&gt; newStartTime;
 325     if (!startTime)
 326         newStartTime = WTF::nullopt;
 327     else
 328         newStartTime = Seconds::fromMilliseconds(startTime.value());
 329 
</pre>
<hr />
<pre>
 398     // The current time is calculated from the first matching condition from below:
 399 
 400     // If the animation&#39;s hold time is resolved, the current time is the animation&#39;s hold time.
 401     if (respectHoldTime == RespectHoldTime::Yes &amp;&amp; m_holdTime)
 402         return m_holdTime;
 403 
 404     // If any of the following are true:
 405     //     1. the animation has no associated timeline, or
 406     //     2. the associated timeline is inactive, or
 407     //     3. the animation&#39;s start time is unresolved.
 408     // The current time is an unresolved time value.
 409     if (!m_timeline || !m_timeline-&gt;currentTime() || !m_startTime)
 410         return WTF::nullopt;
 411 
 412     // Otherwise, current time = (timeline time - start time) * playback rate
 413     return (m_timeline-&gt;currentTime().value() - m_startTime.value()) * m_playbackRate;
 414 }
 415 
 416 ExceptionOr&lt;void&gt; WebAnimation::silentlySetCurrentTime(Optional&lt;Seconds&gt; seekTime)
 417 {
<span class="line-added"> 418     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; silentlySetCurrentTime &quot; &lt;&lt; seekTime);</span>
<span class="line-added"> 419 </span>
 420     // 3.4.5. Setting the current time of an animation
 421     // https://drafts.csswg.org/web-animations-1/#setting-the-current-time-of-an-animation
 422 
 423     // 1. If seek time is an unresolved time value, then perform the following steps.
 424     if (!seekTime) {
 425         // 1. If the current time is resolved, then throw a TypeError.
 426         if (currentTime())
 427             return Exception { TypeError };
 428         // 2. Abort these steps.
 429         return { };
 430     }
 431 
 432     // 2. Update either animation&#39;s hold time or start time as follows:
 433     // If any of the following conditions are true:
 434     //     - animation&#39;s hold time is resolved, or
 435     //     - animation&#39;s start time is unresolved, or
 436     //     - animation has no associated timeline or the associated timeline is inactive, or
 437     //     - animation&#39;s playback rate is 0,
 438     // Set animation&#39;s hold time to seek time.
 439     // Otherwise, set animation&#39;s start time to the result of evaluating timeline time - (seek time / playback rate)
 440     // where timeline time is the current time value of timeline associated with animation.
 441     if (m_holdTime || !m_startTime || !m_timeline || !m_timeline-&gt;currentTime() || !m_playbackRate)
 442         m_holdTime = seekTime;
 443     else
 444         m_startTime = m_timeline-&gt;currentTime().value() - (seekTime.value() / m_playbackRate);
 445 
 446     // 3. If animation has no associated timeline or the associated timeline is inactive, make animation&#39;s start time unresolved.
 447     if (!m_timeline || !m_timeline-&gt;currentTime())
 448         m_startTime = WTF::nullopt;
 449 
 450     // 4. Make animation&#39;s previous current time unresolved.
 451     m_previousCurrentTime = WTF::nullopt;
 452 
 453     return { };
 454 }
 455 
 456 ExceptionOr&lt;void&gt; WebAnimation::setCurrentTime(Optional&lt;Seconds&gt; seekTime)
 457 {
<span class="line-added"> 458     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; setCurrentTime &quot; &lt;&lt; seekTime);</span>
<span class="line-added"> 459 </span>
 460     // 3.4.5. Setting the current time of an animation
 461     // https://drafts.csswg.org/web-animations-1/#setting-the-current-time-of-an-animation
 462 
 463     // 1. Run the steps to silently set the current time of animation to seek time.
 464     auto silentResult = silentlySetCurrentTime(seekTime);
 465     if (silentResult.hasException())
 466         return silentResult.releaseException();
 467 
 468     // 2. If animation has a pending pause task, synchronously complete the pause operation by performing the following steps:
 469     if (hasPendingPauseTask()) {
 470         // 1. Set animation&#39;s hold time to seek time.
 471         m_holdTime = seekTime;
 472         // 2. Apply any pending playback rate to animation.
 473         applyPendingPlaybackRate();
 474         // 3. Make animation&#39;s start time unresolved.
 475         m_startTime = WTF::nullopt;
 476         // 4. Cancel the pending pause task.
 477         m_timeToRunPendingPauseTask = TimeToRunPendingTask::NotScheduled;
 478         // 5. Resolve animation&#39;s current ready promise with animation.
 479         m_readyPromise-&gt;resolve(*this);
</pre>
<hr />
<pre>
 602     // have a pending play task,
 603     // → paused
 604     if (hasPendingPauseTask() || (!m_startTime &amp;&amp; !hasPendingPlayTask()))
 605         return PlayState::Paused;
 606 
 607     // For animation, current time is resolved and either of the following conditions are true:
 608     // animation&#39;s effective playback rate &gt; 0 and current time ≥ target effect end; or
 609     // animation&#39;s effective playback rate &lt; 0 and current time ≤ 0,
 610     // → finished
 611     if (animationCurrentTime &amp;&amp; ((effectivePlaybackRate() &gt; 0 &amp;&amp; (*animationCurrentTime + timeEpsilon) &gt;= effectEndTime()) || (effectivePlaybackRate() &lt; 0 &amp;&amp; (*animationCurrentTime - timeEpsilon) &lt;= 0_s)))
 612         return PlayState::Finished;
 613 
 614     // Otherwise → running
 615     return PlayState::Running;
 616 }
 617 
 618 Seconds WebAnimation::effectEndTime() const
 619 {
 620     // The target effect end of an animation is equal to the end time of the animation&#39;s target effect.
 621     // If the animation has no target effect, the target effect end is zero.
<span class="line-modified"> 622     return m_effect ? m_effect-&gt;endTime() : 0_s;</span>
 623 }
 624 
 625 void WebAnimation::cancel()
 626 {
 627     cancel(Silently::No);
 628     invalidateEffect();
 629 }
 630 
 631 void WebAnimation::cancel(Silently silently)
 632 {
<span class="line-added"> 633     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; cancel(silently &quot; &lt;&lt; (silently == Silently::Yes) &lt;&lt; &quot;) (current time is &quot; &lt;&lt; currentTime() &lt;&lt; &quot;)&quot;);</span>
<span class="line-added"> 634 </span>
 635     // 3.4.16. Canceling an animation
 636     // https://drafts.csswg.org/web-animations-1/#canceling-an-animation-section
 637     //
 638     // An animation can be canceled which causes the current time to become unresolved hence removing any effects caused by the target effect.
 639     //
 640     // The procedure to cancel an animation for animation is as follows:
 641     //
 642     // 1. If animation&#39;s play state is not idle, perform the following steps:
 643     if (playState() != PlayState::Idle) {
 644         // 1. Run the procedure to reset an animation&#39;s pending tasks on animation.
 645         resetPendingTasks(silently);
 646 
 647         // 2. Reject the current finished promise with a DOMException named &quot;AbortError&quot;.
 648         if (silently == Silently::No &amp;&amp; !m_finishedPromise-&gt;isFulfilled())
 649             m_finishedPromise-&gt;reject(Exception { AbortError });
 650 
 651         // 3. Let current finished promise be a new (pending) Promise object.
 652         m_finishedPromise = makeUniqueRef&lt;FinishedPromise&gt;(*this, &amp;WebAnimation::finishedPromiseResolve);
 653 
 654         // 4. Create an AnimationPlaybackEvent, cancelEvent.
</pre>
<hr />
<pre>
 658         //    active timeline, let timeline time be n unresolved time value.
 659         // 8. Set cancelEvent&#39;s timelineTime to timeline time. If timeline time is unresolved, set it to null.
 660         // 9. If animation has a document for timing, then append cancelEvent to its document for timing&#39;s pending animation event queue along
 661         //    with its target, animation. If animation is associated with an active timeline that defines a procedure to convert timeline times
 662         //    to origin-relative time, let the scheduled event time be the result of applying that procedure to timeline time. Otherwise, the
 663         //    scheduled event time is an unresolved time value.
 664         // Otherwise, queue a task to dispatch cancelEvent at animation. The task source for this task is the DOM manipulation task source.
 665         if (silently == Silently::No)
 666             enqueueAnimationPlaybackEvent(eventNames().cancelEvent, WTF::nullopt, m_timeline ? m_timeline-&gt;currentTime() : WTF::nullopt);
 667     }
 668 
 669     // 2. Make animation&#39;s hold time unresolved.
 670     m_holdTime = WTF::nullopt;
 671 
 672     // 3. Make animation&#39;s start time unresolved.
 673     m_startTime = WTF::nullopt;
 674 
 675     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
 676 
 677     invalidateEffect();
<span class="line-added"> 678 </span>
<span class="line-added"> 679     if (m_effect)</span>
<span class="line-added"> 680         m_effect-&gt;animationWasCanceled();</span>
<span class="line-added"> 681 }</span>
<span class="line-added"> 682 </span>
<span class="line-added"> 683 void WebAnimation::willChangeRenderer()</span>
<span class="line-added"> 684 {</span>
<span class="line-added"> 685     if (is&lt;KeyframeEffect&gt;(m_effect))</span>
<span class="line-added"> 686         downcast&lt;KeyframeEffect&gt;(*m_effect).willChangeRenderer();</span>
 687 }
 688 
 689 void WebAnimation::enqueueAnimationPlaybackEvent(const AtomString&amp; type, Optional&lt;Seconds&gt; currentTime, Optional&lt;Seconds&gt; timelineTime)
 690 {
<span class="line-modified"> 691     auto event = AnimationPlaybackEvent::create(type, currentTime, timelineTime, this);</span>
 692     event-&gt;setTarget(this);
<span class="line-added"> 693     enqueueAnimationEvent(WTFMove(event));</span>
<span class="line-added"> 694 }</span>
 695 
<span class="line-modified"> 696 void WebAnimation::enqueueAnimationEvent(Ref&lt;AnimationEventBase&gt;&amp;&amp; event)</span>
<span class="line-added"> 697 {</span>
<span class="line-added"> 698     if (is&lt;DocumentTimeline&gt;(m_timeline.get())) {</span>
 699         // If animation has a document for timing, then append event to its document for timing&#39;s pending animation event queue along
 700         // with its target, animation. If animation is associated with an active timeline that defines a procedure to convert timeline times
 701         // to origin-relative time, let the scheduled event time be the result of applying that procedure to timeline time. Otherwise, the
 702         // scheduled event time is an unresolved time value.
<span class="line-modified"> 703         m_hasScheduledEventsDuringTick = true;</span>
<span class="line-added"> 704         downcast&lt;DocumentTimeline&gt;(*m_timeline).enqueueAnimationEvent(WTFMove(event));</span>
 705     } else {
 706         // Otherwise, queue a task to dispatch event at animation. The task source for this task is the DOM manipulation task source.
<span class="line-modified"> 707         queueTaskToDispatchEvent(*this, TaskSource::DOMManipulation, WTFMove(event));</span>



 708     }
 709 }
 710 
 711 void WebAnimation::resetPendingTasks(Silently silently)
 712 {
 713     // The procedure to reset an animation&#39;s pending tasks for animation is as follows:
 714     // https://drafts.csswg.org/web-animations-1/#reset-an-animations-pending-tasks
 715     //
 716     // 1. If animation does not have a pending play task or a pending pause task, abort this procedure.
 717     if (!pending())
 718         return;
 719 
 720     // 2. If animation has a pending play task, cancel that task.
 721     if (hasPendingPlayTask())
 722         m_timeToRunPendingPlayTask = TimeToRunPendingTask::NotScheduled;
 723 
 724     // 3. If animation has a pending pause task, cancel that task.
 725     if (hasPendingPauseTask())
 726         m_timeToRunPendingPauseTask = TimeToRunPendingTask::NotScheduled;
 727 
 728     // 4. Apply any pending playback rate on animation.
 729     applyPendingPlaybackRate();
 730 
 731     // 5. Reject animation&#39;s current ready promise with a DOMException named &quot;AbortError&quot;.
 732     if (silently == Silently::No)
 733         m_readyPromise-&gt;reject(Exception { AbortError });
 734 
 735     // 6. Let animation&#39;s current ready promise be the result of creating a new resolved Promise object.
 736     m_readyPromise = makeUniqueRef&lt;ReadyPromise&gt;(*this, &amp;WebAnimation::readyPromiseResolve);
 737     m_readyPromise-&gt;resolve(*this);
 738 }
 739 
 740 ExceptionOr&lt;void&gt; WebAnimation::finish()
 741 {
<span class="line-added"> 742     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; finish (current time is &quot; &lt;&lt; currentTime() &lt;&lt; &quot;)&quot;);</span>
<span class="line-added"> 743 </span>
 744     // 3.4.15. Finishing an animation
 745     // https://drafts.csswg.org/web-animations-1/#finishing-an-animation-section
 746 
 747     // An animation can be advanced to the natural end of its current playback direction by using the procedure to finish an animation for animation defined below:
 748     //
 749     // 1. If animation&#39;s effective playback rate is zero, or if animation&#39;s effective playback rate &gt; 0 and target effect end is infinity, throw an InvalidStateError and abort these steps.
 750     if (!effectivePlaybackRate() || (effectivePlaybackRate() &gt; 0 &amp;&amp; effectEndTime() == Seconds::infinity()))
 751         return Exception { InvalidStateError };
 752 
 753     // 2. Apply any pending playback rate to animation.
 754     applyPendingPlaybackRate();
 755 
 756     // 3. Set limit as follows:
 757     // If animation playback rate &gt; 0, let limit be target effect end.
 758     // Otherwise, let limit be zero.
 759     auto limit = m_playbackRate &gt; 0 ? effectEndTime() : 0_s;
 760 
 761     // 4. Silently set the current time to limit.
 762     silentlySetCurrentTime(limit);
 763 
</pre>
<hr />
<pre>
 773         // 2. Cancel the pending pause task.
 774         m_timeToRunPendingPauseTask = TimeToRunPendingTask::NotScheduled;
 775         // 3. Resolve the current ready promise of animation with animation.
 776         m_readyPromise-&gt;resolve(*this);
 777     }
 778 
 779     // 7. If there is a pending play task and start time is resolved, cancel that task and resolve the current ready promise of animation with animation.
 780     if (hasPendingPlayTask() &amp;&amp; m_startTime) {
 781         m_timeToRunPendingPlayTask = TimeToRunPendingTask::NotScheduled;
 782         m_readyPromise-&gt;resolve(*this);
 783     }
 784 
 785     // 8. Run the procedure to update an animation&#39;s finished state animation with the did seek flag set to true, and the synchronously notify flag set to true.
 786     timingDidChange(DidSeek::Yes, SynchronouslyNotify::Yes);
 787 
 788     invalidateEffect();
 789 
 790     return { };
 791 }
 792 
<span class="line-modified"> 793 void WebAnimation::timingDidChange(DidSeek didSeek, SynchronouslyNotify synchronouslyNotify, Silently silently)</span>
 794 {
 795     m_shouldSkipUpdatingFinishedStateWhenResolving = false;
 796     updateFinishedState(didSeek, synchronouslyNotify);
<span class="line-modified"> 797 </span>
<span class="line-added"> 798     if (is&lt;KeyframeEffect&gt;(m_effect)) {</span>
<span class="line-added"> 799         updateRelevance();</span>
<span class="line-added"> 800         downcast&lt;KeyframeEffect&gt;(*m_effect).animationTimingDidChange();</span>
<span class="line-added"> 801     }</span>
<span class="line-added"> 802 </span>
<span class="line-added"> 803     if (silently == Silently::No &amp;&amp; m_timeline)</span>
 804         m_timeline-&gt;animationTimingDidChange(*this);
 805 };
 806 
 807 void WebAnimation::invalidateEffect()
 808 {
 809     if (!isEffectInvalidationSuspended() &amp;&amp; m_effect)
 810         m_effect-&gt;invalidate();
 811 }
 812 
 813 void WebAnimation::updateFinishedState(DidSeek didSeek, SynchronouslyNotify synchronouslyNotify)
 814 {
 815     // 3.4.14. Updating the finished state
 816     // https://drafts.csswg.org/web-animations-1/#updating-the-finished-state
 817 
 818     // 1. Let the unconstrained current time be the result of calculating the current time substituting an unresolved time value
 819     // for the hold time if did seek is false. If did seek is true, the unconstrained current time is equal to the current time.
 820     auto unconstrainedCurrentTime = currentTime(didSeek == DidSeek::Yes ? RespectHoldTime::Yes : RespectHoldTime::No);
 821     auto endTime = effectEndTime();
 822 
 823     // 2. If all three of the following conditions are true,
</pre>
<hr />
<pre>
 858         }
 859     }
 860 
 861     // 3. Set the previous current time of animation be the result of calculating its current time.
 862     m_previousCurrentTime = currentTime();
 863 
 864     // 4. Let current finished state be true if the play state of animation is finished. Otherwise, let it be false.
 865     auto currentFinishedState = playState() == PlayState::Finished;
 866 
 867     // 5. If current finished state is true and the current finished promise is not yet resolved, perform the following steps:
 868     if (currentFinishedState &amp;&amp; !m_finishedPromise-&gt;isFulfilled()) {
 869         if (synchronouslyNotify == SynchronouslyNotify::Yes) {
 870             // If synchronously notify is true, cancel any queued microtask to run the finish notification steps for this animation,
 871             // and run the finish notification steps immediately.
 872             m_finishNotificationStepsMicrotaskPending = false;
 873             finishNotificationSteps();
 874         } else if (!m_finishNotificationStepsMicrotaskPending) {
 875             // Otherwise, if synchronously notify is false, queue a microtask to run finish notification steps for animation unless there
 876             // is already a microtask queued to run those steps for animation.
 877             m_finishNotificationStepsMicrotaskPending = true;
<span class="line-modified"> 878             if (auto* context = scriptExecutionContext()) {</span>
<span class="line-modified"> 879                 context-&gt;eventLoop().queueMicrotask([this, protectedThis = makeRef(*this)] {</span>
<span class="line-modified"> 880                     if (m_finishNotificationStepsMicrotaskPending) {</span>
<span class="line-modified"> 881                         m_finishNotificationStepsMicrotaskPending = false;</span>
<span class="line-modified"> 882                         finishNotificationSteps();</span>
<span class="line-modified"> 883                     }</span>
<span class="line-added"> 884                 });</span>
<span class="line-added"> 885             }</span>
 886         }
 887     }
 888 
 889     // 6. If current finished state is false and animation&#39;s current finished promise is already resolved, set animation&#39;s current
 890     // finished promise to a new (pending) Promise object.
 891     if (!currentFinishedState &amp;&amp; m_finishedPromise-&gt;isFulfilled())
 892         m_finishedPromise = makeUniqueRef&lt;FinishedPromise&gt;(*this, &amp;WebAnimation::finishedPromiseResolve);
 893 
 894     updateRelevance();
 895 }
 896 
 897 void WebAnimation::finishNotificationSteps()
 898 {
 899     // 3.4.14. Updating the finished state
 900     // https://drafts.csswg.org/web-animations-1/#finish-notification-steps
 901 
 902     // Let finish notification steps refer to the following procedure:
 903     // 1. If animation&#39;s play state is not equal to finished, abort these steps.
 904     if (playState() != PlayState::Finished)
 905         return;
</pre>
<hr />
<pre>
 909 
 910     // 3. Create an AnimationPlaybackEvent, finishEvent.
 911     // 4. Set finishEvent&#39;s type attribute to finish.
 912     // 5. Set finishEvent&#39;s currentTime attribute to the current time of animation.
 913     // 6. Set finishEvent&#39;s timelineTime attribute to the current time of the timeline with which animation is associated.
 914     //    If animation is not associated with a timeline, or the timeline is inactive, let timelineTime be null.
 915     // 7. If animation has a document for timing, then append finishEvent to its document for timing&#39;s pending animation event
 916     //    queue along with its target, animation. For the scheduled event time, use the result of converting animation&#39;s target
 917     //    effect end to an origin-relative time.
 918     //    Otherwise, queue a task to dispatch finishEvent at animation. The task source for this task is the DOM manipulation task source.
 919     enqueueAnimationPlaybackEvent(eventNames().finishEvent, currentTime(), m_timeline ? m_timeline-&gt;currentTime() : WTF::nullopt);
 920 }
 921 
 922 ExceptionOr&lt;void&gt; WebAnimation::play()
 923 {
 924     return play(AutoRewind::Yes);
 925 }
 926 
 927 ExceptionOr&lt;void&gt; WebAnimation::play(AutoRewind autoRewind)
 928 {
<span class="line-added"> 929     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; play(autoRewind &quot; &lt;&lt; (autoRewind == AutoRewind::Yes) &lt;&lt; &quot;) (current time is &quot; &lt;&lt; currentTime() &lt;&lt; &quot;)&quot;);</span>
<span class="line-added"> 930 </span>
 931     // 3.4.10. Playing an animation
 932     // https://drafts.csswg.org/web-animations-1/#play-an-animation
 933 
 934     auto localTime = currentTime();
 935     auto endTime = effectEndTime();
 936 
 937     // 1. Let aborted pause be a boolean flag that is true if animation has a pending pause task, and false otherwise.
 938     bool abortedPause = hasPendingPauseTask();
 939 
 940     // 2. Let has pending ready promise be a boolean flag that is initially false.
 941     bool hasPendingReadyPromise = false;
 942 
 943     // 3. Perform the steps corresponding to the first matching condition from the following, if any:
 944     if (effectivePlaybackRate() &gt; 0 &amp;&amp; autoRewind == AutoRewind::Yes &amp;&amp; (!localTime || localTime.value() &lt; 0_s || localTime.value() &gt;= endTime)) {
 945         // If animation&#39;s effective playback rate &gt; 0, the auto-rewind flag is true and either animation&#39;s:
 946         //     - current time is unresolved, or
 947         //     - current time &lt; zero, or
 948         //     - current time ≥ target effect end,
 949         // Set animation&#39;s hold time to zero.
 950         m_holdTime = 0_s;
</pre>
<hr />
<pre>
 979     // abort this procedure.
 980     if (!m_holdTime &amp;&amp; !abortedPause &amp;&amp; !m_pendingPlaybackRate)
 981         return { };
 982 
 983     // 6. If animation&#39;s hold time is resolved, let its start time be unresolved.
 984     if (m_holdTime)
 985         m_startTime = WTF::nullopt;
 986 
 987     // 7. If has pending ready promise is false, let animation&#39;s current ready promise be a new (pending) Promise object.
 988     if (!hasPendingReadyPromise)
 989         m_readyPromise = makeUniqueRef&lt;ReadyPromise&gt;(*this, &amp;WebAnimation::readyPromiseResolve);
 990 
 991     // 8. Schedule a task to run as soon as animation is ready.
 992     m_timeToRunPendingPlayTask = TimeToRunPendingTask::WhenReady;
 993 
 994     // 9. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
 995     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
 996 
 997     invalidateEffect();
 998 
<span class="line-added"> 999     if (m_effect)</span>
<span class="line-added">1000         m_effect-&gt;animationDidPlay();</span>
<span class="line-added">1001 </span>
1002     return { };
1003 }
1004 
1005 void WebAnimation::runPendingPlayTask()
1006 {
<span class="line-added">1007     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; runPendingPlayTask (current time is &quot; &lt;&lt; currentTime() &lt;&lt; &quot;)&quot;);</span>
<span class="line-added">1008 </span>
1009     // 3.4.10. Playing an animation, step 8.
1010     // https://drafts.csswg.org/web-animations-1/#play-an-animation
1011 
1012     m_timeToRunPendingPlayTask = TimeToRunPendingTask::NotScheduled;
1013 
1014     // 1. Assert that at least one of animation&#39;s start time or hold time is resolved.
1015     ASSERT(m_startTime || m_holdTime);
1016 
1017     // 2. Let ready time be the time value of the timeline associated with animation at the moment when animation became ready.
1018     auto readyTime = m_timeline-&gt;currentTime();
1019 
1020     // 3. Perform the steps corresponding to the first matching condition below, if any:
1021     if (m_holdTime) {
1022         // If animation&#39;s hold time is resolved,
1023         // 1. Apply any pending playback rate on animation.
1024         applyPendingPlaybackRate();
1025         // 2. Let new start time be the result of evaluating ready time - hold time / animation playback rate for animation.
1026         // If the animation playback rate is zero, let new start time be simply ready time.
1027         // FIXME: Implementation cannot guarantee an active timeline at the point of this async dispatch.
1028         // Subsequently, the resulting readyTime value can be null. Unify behavior between C++17 and
</pre>
<hr />
<pre>
1042         auto currentTimeToMatch = (readyTime.valueOr(0_s) - m_startTime.value()) * m_playbackRate;
1043         // 2. Apply any pending playback rate on animation.
1044         applyPendingPlaybackRate();
1045         // 3. If animation&#39;s playback rate is zero, let animation&#39;s hold time be current time to match.
1046         if (m_playbackRate)
1047             m_holdTime = currentTimeToMatch;
1048         // 4. Let new start time be the result of evaluating ready time - current time to match / playback rate for animation.
1049         // If the playback rate is zero, let new start time be simply ready time.
1050         auto newStartTime = readyTime.valueOr(0_s);
1051         if (m_playbackRate)
1052             newStartTime -= currentTimeToMatch / m_playbackRate;
1053         // 5. Set the start time of animation to new start time.
1054         m_startTime = newStartTime;
1055     }
1056 
1057     // 4. Resolve animation&#39;s current ready promise with animation.
1058     if (!m_readyPromise-&gt;isFulfilled())
1059         m_readyPromise-&gt;resolve(*this);
1060 
1061     // 5. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
<span class="line-modified">1062     timingDidChange(DidSeek::No, SynchronouslyNotify::No, Silently::Yes);</span>
1063 
1064     invalidateEffect();
1065 }
1066 
1067 ExceptionOr&lt;void&gt; WebAnimation::pause()
1068 {
<span class="line-added">1069     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; pause (current time is &quot; &lt;&lt; currentTime() &lt;&lt; &quot;)&quot;);</span>
<span class="line-added">1070 </span>
1071     // 3.4.11. Pausing an animation
1072     // https://drafts.csswg.org/web-animations-1/#pause-an-animation
1073 
1074     // 1. If animation has a pending pause task, abort these steps.
1075     if (hasPendingPauseTask())
1076         return { };
1077 
1078     // 2. If the play state of animation is paused, abort these steps.
1079     if (playState() == PlayState::Paused)
1080         return { };
1081 
1082     auto localTime = currentTime();
1083 
1084     // 3. If the animation&#39;s current time is unresolved, perform the steps according to the first matching condition from below:
1085     if (!localTime) {
1086         if (m_playbackRate &gt;= 0) {
1087             // If animation&#39;s playback rate is ≥ 0, let animation&#39;s hold time be zero.
1088             m_holdTime = 0_s;
1089         } else if (effectEndTime() == Seconds::infinity()) {
1090             // Otherwise, if target effect end for animation is positive infinity, throw an InvalidStateError and abort these steps.
</pre>
<hr />
<pre>
1105     }
1106 
1107     // 6. If has pending ready promise is false, set animation&#39;s current ready promise to a new (pending) Promise object.
1108     if (!hasPendingReadyPromise)
1109         m_readyPromise = makeUniqueRef&lt;ReadyPromise&gt;(*this, &amp;WebAnimation::readyPromiseResolve);
1110 
1111     // 7. Schedule a task to be executed at the first possible moment after the user agent has performed any processing necessary
1112     //    to suspend the playback of animation&#39;s target effect, if any.
1113     m_timeToRunPendingPauseTask = TimeToRunPendingTask::ASAP;
1114 
1115     // 8. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
1116     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
1117 
1118     invalidateEffect();
1119 
1120     return { };
1121 }
1122 
1123 ExceptionOr&lt;void&gt; WebAnimation::reverse()
1124 {
<span class="line-added">1125     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; reverse (current time is &quot; &lt;&lt; currentTime() &lt;&lt; &quot;)&quot;);</span>
<span class="line-added">1126 </span>
1127     // 3.4.18. Reversing an animation
1128     // https://drafts.csswg.org/web-animations-1/#reverse-an-animation
1129 
1130     // The procedure to reverse an animation of animation animation is as follows:
1131 
1132     // 1. If there is no timeline associated with animation, or the associated timeline is inactive
1133     //    throw an InvalidStateError and abort these steps.
1134     if (!m_timeline || !m_timeline-&gt;currentTime())
1135         return Exception { InvalidStateError };
1136 
1137     // 2. Let original pending playback rate be animation&#39;s pending playback rate.
1138     auto originalPendingPlaybackRate = m_pendingPlaybackRate;
1139 
1140     // 3. Let animation&#39;s pending playback rate be the additive inverse of its effective playback rate (i.e. -effective playback rate).
1141     m_pendingPlaybackRate = -effectivePlaybackRate();
1142 
1143     // 4. Run the steps to play an animation for animation with the auto-rewind flag set to true.
1144     auto playResult = play(AutoRewind::Yes);
1145 
1146     // If the steps to play an animation throw an exception, set animation&#39;s pending playback rate to original
1147     // pending playback rate and propagate the exception.
1148     if (playResult.hasException()) {
1149         m_pendingPlaybackRate = originalPendingPlaybackRate;
1150         return playResult.releaseException();
1151     }
1152 
1153     return { };
1154 }
1155 
1156 void WebAnimation::runPendingPauseTask()
1157 {
<span class="line-added">1158     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; runPendingPauseTask (current time is &quot; &lt;&lt; currentTime() &lt;&lt; &quot;)&quot;);</span>
<span class="line-added">1159 </span>
1160     // 3.4.11. Pausing an animation, step 7.
1161     // https://drafts.csswg.org/web-animations-1/#pause-an-animation
1162 
1163     m_timeToRunPendingPauseTask = TimeToRunPendingTask::NotScheduled;
1164 
1165     // 1. Let ready time be the time value of the timeline associated with animation at the moment when the user agent
1166     //    completed processing necessary to suspend playback of animation&#39;s target effect.
1167     auto readyTime = m_timeline-&gt;currentTime();
1168     auto animationStartTime = m_startTime;
1169 
1170     // 2. If animation&#39;s start time is resolved and its hold time is not resolved, let animation&#39;s hold time be the result of
1171     //    evaluating (ready time - start time) × playback rate.
1172     //    Note: The hold time might be already set if the animation is finished, or if the animation is pending, waiting to begin
1173     //    playback. In either case we want to preserve the hold time as we enter the paused state.
1174     if (animationStartTime &amp;&amp; !m_holdTime) {
1175         // FIXME: Implementation cannot guarantee an active timeline at the point of this async dispatch.
1176         // Subsequently, the resulting readyTime value can be null. Unify behavior between C++17 and
1177         // C++14 builds (the latter using WTF&#39;s Optional) and avoid null Optional dereferencing
1178         // by defaulting to a Seconds(0) value. See https://bugs.webkit.org/show_bug.cgi?id=186189.
1179         m_holdTime = (readyTime.valueOr(0_s) - animationStartTime.value()) * m_playbackRate;
1180     }
1181 
1182     // 3. Apply any pending playback rate on animation.
1183     applyPendingPlaybackRate();
1184 
1185     // 4. Make animation&#39;s start time unresolved.
1186     m_startTime = WTF::nullopt;
1187 
1188     // 5. Resolve animation&#39;s current ready promise with animation.
1189     if (!m_readyPromise-&gt;isFulfilled())
1190         m_readyPromise-&gt;resolve(*this);
1191 
1192     // 6. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false, and the
1193     //    synchronously notify flag set to false.
<span class="line-modified">1194     timingDidChange(DidSeek::No, SynchronouslyNotify::No, Silently::Yes);</span>
1195 
1196     invalidateEffect();
1197 }
1198 
1199 bool WebAnimation::isRunningAccelerated() const
1200 {
1201     return is&lt;KeyframeEffect&gt;(m_effect) &amp;&amp; downcast&lt;KeyframeEffect&gt;(*m_effect).isRunningAccelerated();
1202 }
1203 
<span class="line-added">1204 bool WebAnimation::isCompletelyAccelerated() const</span>
<span class="line-added">1205 {</span>
<span class="line-added">1206     return is&lt;KeyframeEffect&gt;(m_effect) &amp;&amp; downcast&lt;KeyframeEffect&gt;(*m_effect).isCompletelyAccelerated();</span>
<span class="line-added">1207 }</span>
<span class="line-added">1208 </span>
1209 bool WebAnimation::needsTick() const
1210 {
<span class="line-modified">1211     return pending() || playState() == PlayState::Running || m_hasScheduledEventsDuringTick;</span>
1212 }
1213 
1214 void WebAnimation::tick()
1215 {
<span class="line-added">1216     m_hasScheduledEventsDuringTick = false;</span>
1217     updateFinishedState(DidSeek::No, SynchronouslyNotify::Yes);
1218     m_shouldSkipUpdatingFinishedStateWhenResolving = true;
1219 
1220     // Run pending tasks, if any.
1221     if (hasPendingPauseTask())
1222         runPendingPauseTask();
1223     if (hasPendingPlayTask())
1224         runPendingPlayTask();
1225 
<span class="line-modified">1226     if (!isEffectInvalidationSuspended() &amp;&amp; m_effect)</span>
<span class="line-added">1227         m_effect-&gt;animationDidTick();</span>
1228 }
1229 
1230 void WebAnimation::resolve(RenderStyle&amp; targetStyle)
1231 {
1232     if (!m_shouldSkipUpdatingFinishedStateWhenResolving)
1233         updateFinishedState(DidSeek::No, SynchronouslyNotify::Yes);
1234     m_shouldSkipUpdatingFinishedStateWhenResolving = false;
1235 
1236     if (m_effect)
1237         m_effect-&gt;apply(targetStyle);
1238 }
1239 
1240 void WebAnimation::setSuspended(bool isSuspended)
1241 {
1242     if (m_isSuspended == isSuspended)
1243         return;
1244 
1245     m_isSuspended = isSuspended;
1246 
1247     if (m_effect &amp;&amp; playState() == PlayState::Running)
1248         m_effect-&gt;animationSuspensionStateDidChange(isSuspended);
1249 }
1250 
1251 void WebAnimation::acceleratedStateDidChange()
1252 {
<span class="line-modified">1253     if (is&lt;DocumentTimeline&gt;(m_timeline.get()))</span>
1254         downcast&lt;DocumentTimeline&gt;(*m_timeline).animationAcceleratedRunningStateDidChange(*this);
1255 }
1256 
1257 void WebAnimation::applyPendingAcceleratedActions()
1258 {
1259     if (is&lt;KeyframeEffect&gt;(m_effect))
1260         downcast&lt;KeyframeEffect&gt;(*m_effect).applyPendingAcceleratedActions();
1261 }
1262 
1263 WebAnimation&amp; WebAnimation::readyPromiseResolve()
1264 {
1265     return *this;
1266 }
1267 
1268 WebAnimation&amp; WebAnimation::finishedPromiseResolve()
1269 {
1270     return *this;
1271 }
1272 
1273 const char* WebAnimation::activeDOMObjectName() const
1274 {
1275     return &quot;Animation&quot;;
1276 }
1277 
<span class="line-modified">1278 void WebAnimation::suspend(ReasonForSuspension)</span>
1279 {
<span class="line-modified">1280     setSuspended(true);</span>
<span class="line-modified">1281 }</span>
<span class="line-modified">1282 </span>
<span class="line-modified">1283 void WebAnimation::resume()</span>
<span class="line-added">1284 {</span>
<span class="line-added">1285     setSuspended(false);</span>
1286 }
1287 
1288 void WebAnimation::stop()
1289 {
1290     ActiveDOMObject::stop();

1291     removeAllEventListeners();
1292 }
1293 
1294 bool WebAnimation::hasPendingActivity() const
1295 {
1296     // Keep the JS wrapper alive if the animation is considered relevant or could become relevant again by virtue of having a timeline.
1297     return m_timeline || m_isRelevant || ActiveDOMObject::hasPendingActivity();
1298 }
1299 
1300 void WebAnimation::updateRelevance()
1301 {
1302     m_isRelevant = computeRelevance();
1303 }
1304 
1305 bool WebAnimation::computeRelevance()
1306 {
1307     // To be listed in getAnimations() an animation needs a target effect which is current or in effect.
1308     if (!m_effect)
1309         return false;
1310 
<span class="line-added">1311     if (m_replaceState == ReplaceState::Removed)</span>
<span class="line-added">1312         return false;</span>
<span class="line-added">1313 </span>
1314     auto timing = m_effect-&gt;getBasicTiming();
1315 
1316     // An animation effect is in effect if its active time is not unresolved.
1317     if (timing.activeTime)
1318         return true;
1319 
1320     // An animation effect is current if either of the following conditions is true:
1321     // - the animation effect is in the before phase, or
1322     // - the animation effect is in play.
1323 
1324     // An animation effect is in play if all of the following conditions are met:
1325     // - the animation effect is in the active phase, and
1326     // - the animation effect is associated with an animation that is not finished.
1327     return timing.phase == AnimationEffectPhase::Before || (timing.phase == AnimationEffectPhase::Active &amp;&amp; playState() != PlayState::Finished);
1328 }
1329 
<span class="line-added">1330 bool WebAnimation::isReplaceable() const</span>
<span class="line-added">1331 {</span>
<span class="line-added">1332     // An animation is replaceable if all of the following conditions are true:</span>
<span class="line-added">1333     // https://drafts.csswg.org/web-animations/#removing-replaced-animations</span>
<span class="line-added">1334 </span>
<span class="line-added">1335     // The existence of the animation is not prescribed by markup. That is, it is not a CSS animation with an owning element,</span>
<span class="line-added">1336     // nor a CSS transition with an owning element.</span>
<span class="line-added">1337     if (isDeclarativeAnimation() &amp;&amp; downcast&lt;DeclarativeAnimation&gt;(this)-&gt;owningElement())</span>
<span class="line-added">1338         return false;</span>
<span class="line-added">1339 </span>
<span class="line-added">1340     // The animation&#39;s play state is finished.</span>
<span class="line-added">1341     if (playState() != PlayState::Finished)</span>
<span class="line-added">1342         return false;</span>
<span class="line-added">1343 </span>
<span class="line-added">1344     // The animation&#39;s replace state is not removed.</span>
<span class="line-added">1345     if (m_replaceState == ReplaceState::Removed)</span>
<span class="line-added">1346         return false;</span>
<span class="line-added">1347 </span>
<span class="line-added">1348     // The animation is associated with a monotonically increasing timeline.</span>
<span class="line-added">1349     if (!m_timeline)</span>
<span class="line-added">1350         return false;</span>
<span class="line-added">1351 </span>
<span class="line-added">1352     // The animation has an associated target effect.</span>
<span class="line-added">1353     if (!m_effect)</span>
<span class="line-added">1354         return false;</span>
<span class="line-added">1355 </span>
<span class="line-added">1356     // The target effect associated with the animation is in effect.</span>
<span class="line-added">1357     if (!m_effect-&gt;getBasicTiming().activeTime)</span>
<span class="line-added">1358         return false;</span>
<span class="line-added">1359 </span>
<span class="line-added">1360     // The target effect has an associated target element.</span>
<span class="line-added">1361     if (!is&lt;KeyframeEffect&gt;(m_effect) || !downcast&lt;KeyframeEffect&gt;(m_effect.get())-&gt;target())</span>
<span class="line-added">1362         return false;</span>
<span class="line-added">1363 </span>
<span class="line-added">1364     return true;</span>
<span class="line-added">1365 }</span>
<span class="line-added">1366 </span>
<span class="line-added">1367 void WebAnimation::persist()</span>
<span class="line-added">1368 {</span>
<span class="line-added">1369     auto previousReplaceState = std::exchange(m_replaceState, ReplaceState::Persisted);</span>
<span class="line-added">1370 </span>
<span class="line-added">1371     if (previousReplaceState == ReplaceState::Removed &amp;&amp; m_timeline) {</span>
<span class="line-added">1372         if (is&lt;KeyframeEffect&gt;(m_effect)) {</span>
<span class="line-added">1373             auto&amp; keyframeEffect = downcast&lt;KeyframeEffect&gt;(*m_effect);</span>
<span class="line-added">1374             auto&amp; target = *keyframeEffect.target();</span>
<span class="line-added">1375             m_timeline-&gt;animationWasAddedToElement(*this, target);</span>
<span class="line-added">1376             target.ensureKeyframeEffectStack().addEffect(keyframeEffect);</span>
<span class="line-added">1377         }</span>
<span class="line-added">1378     }</span>
<span class="line-added">1379 }</span>
<span class="line-added">1380 </span>
<span class="line-added">1381 ExceptionOr&lt;void&gt; WebAnimation::commitStyles()</span>
<span class="line-added">1382 {</span>
<span class="line-added">1383     // https://drafts.csswg.org/web-animations-1/#commit-computed-styles</span>
<span class="line-added">1384 </span>
<span class="line-added">1385     // 1. Let targets be the set of all effect targets for animation effects associated with animation.</span>
<span class="line-added">1386     auto* effect = is&lt;KeyframeEffect&gt;(m_effect) ? downcast&lt;KeyframeEffect&gt;(m_effect.get()) : nullptr;</span>
<span class="line-added">1387     auto* target = effect ? effect-&gt;target() : nullptr;</span>
<span class="line-added">1388 </span>
<span class="line-added">1389     // 2. For each target in targets:</span>
<span class="line-added">1390     //</span>
<span class="line-added">1391     // 2.1 If target is not an element capable of having a style attribute (for example, it is a pseudo-element or is an element in a</span>
<span class="line-added">1392     // document format for which style attributes are not defined) throw a &quot;NoModificationAllowedError&quot; DOMException and abort these steps.</span>
<span class="line-added">1393     if (!is&lt;StyledElement&gt;(target))</span>
<span class="line-added">1394         return Exception { NoModificationAllowedError };</span>
<span class="line-added">1395 </span>
<span class="line-added">1396     auto&amp; styledElement = downcast&lt;StyledElement&gt;(*target);</span>
<span class="line-added">1397 </span>
<span class="line-added">1398     // 2.2 If, after applying any pending style changes, target is not being rendered, throw an &quot;InvalidStateError&quot; DOMException and abort these steps.</span>
<span class="line-added">1399     styledElement.document().updateStyleIfNeeded();</span>
<span class="line-added">1400     auto* renderer = styledElement.renderer();</span>
<span class="line-added">1401     if (!renderer)</span>
<span class="line-added">1402         return Exception { InvalidStateError };</span>
<span class="line-added">1403 </span>
<span class="line-added">1404     // 2.3 Let inline style be the result of getting the CSS declaration block corresponding to target’s style attribute. If target does not have a style</span>
<span class="line-added">1405     // attribute, let inline style be a new empty CSS declaration block with the readonly flag unset and owner node set to target.</span>
<span class="line-added">1406 </span>
<span class="line-added">1407     // 2.4 Let targeted properties be the set of physical longhand properties that are a target property for at least one animation effect associated with</span>
<span class="line-added">1408     // animation whose effect target is target.</span>
<span class="line-added">1409 </span>
<span class="line-added">1410     auto&amp; style = renderer-&gt;style();</span>
<span class="line-added">1411     auto computedStyleExtractor = ComputedStyleExtractor(&amp;styledElement);</span>
<span class="line-added">1412     auto inlineStyle = styledElement.document().createCSSStyleDeclaration();</span>
<span class="line-added">1413     inlineStyle-&gt;setCssText(styledElement.getAttribute(&quot;style&quot;));</span>
<span class="line-added">1414 </span>
<span class="line-added">1415     auto&amp; keyframeStack = styledElement.ensureKeyframeEffectStack();</span>
<span class="line-added">1416     auto* cssAnimationList = keyframeStack.cssAnimationList();</span>
<span class="line-added">1417 </span>
<span class="line-added">1418     // 2.5 For each property, property, in targeted properties:</span>
<span class="line-added">1419     for (auto property : effect-&gt;animatedProperties()) {</span>
<span class="line-added">1420         // 1. Let partialEffectStack be a copy of the effect stack for property on target.</span>
<span class="line-added">1421         // 2. If animation&#39;s replace state is removed, add all animation effects associated with animation whose effect target is target and which include</span>
<span class="line-added">1422         // property as a target property to partialEffectStack.</span>
<span class="line-added">1423         // 3. Remove from partialEffectStack any animation effects whose associated animation has a higher composite order than animation.</span>
<span class="line-added">1424         // 4. Let effect value be the result of calculating the result of partialEffectStack for property using target&#39;s computed style (see § 5.4.3 Calculating</span>
<span class="line-added">1425         // the result of an effect stack).</span>
<span class="line-added">1426         // 5. Set a CSS declaration property for effect value in inline style.</span>
<span class="line-added">1427         // 6. Update style attribute for inline style.</span>
<span class="line-added">1428 </span>
<span class="line-added">1429         // We actually perform those steps in a different way: instead of building a copy of the effect stack and then removing stuff, we iterate through the</span>
<span class="line-added">1430         // effect stack and stop when we&#39;ve found this animation&#39;s effect or when we&#39;ve found an effect associated with an animation with a higher composite order.</span>
<span class="line-added">1431         auto animatedStyle = RenderStyle::clonePtr(style);</span>
<span class="line-added">1432         for (const auto&amp; effectInStack : keyframeStack.sortedEffects()) {</span>
<span class="line-added">1433             if (effectInStack-&gt;animation() != this &amp;&amp; !compareAnimationsByCompositeOrder(*effectInStack-&gt;animation(), *this, cssAnimationList))</span>
<span class="line-added">1434                 break;</span>
<span class="line-added">1435             if (effectInStack-&gt;animatedProperties().contains(property))</span>
<span class="line-added">1436                 effectInStack-&gt;animation()-&gt;resolve(*animatedStyle);</span>
<span class="line-added">1437             if (effectInStack-&gt;animation() == this)</span>
<span class="line-added">1438                 break;</span>
<span class="line-added">1439         }</span>
<span class="line-added">1440         if (m_replaceState == ReplaceState::Removed)</span>
<span class="line-added">1441             effect-&gt;animation()-&gt;resolve(*animatedStyle);</span>
<span class="line-added">1442         if (auto cssValue = computedStyleExtractor.valueForPropertyInStyle(*animatedStyle, property, renderer))</span>
<span class="line-added">1443             inlineStyle-&gt;setPropertyInternal(property, cssValue-&gt;cssText(), false);</span>
<span class="line-added">1444     }</span>
<span class="line-added">1445 </span>
<span class="line-added">1446     styledElement.setAttribute(&quot;style&quot;, inlineStyle-&gt;cssText());</span>
<span class="line-added">1447 </span>
<span class="line-added">1448     return { };</span>
<span class="line-added">1449 }</span>
<span class="line-added">1450 </span>
1451 Seconds WebAnimation::timeToNextTick() const
1452 {
<span class="line-modified">1453     ASSERT(effect());</span>
1454 
1455     if (pending())
1456         return 0_s;
1457 
<span class="line-modified">1458     // If we&#39;re not running, or time is not advancing for this animation, there&#39;s no telling when we&#39;ll end.</span>
<span class="line-modified">1459     auto playbackRate = effectivePlaybackRate();</span>
<span class="line-added">1460     if (playState() != PlayState::Running || !playbackRate)</span>
1461         return Seconds::infinity();
1462 
<span class="line-modified">1463     auto&amp; effect = *this-&gt;effect();</span>
<span class="line-modified">1464     auto timing = effect.getBasicTiming();</span>
<span class="line-modified">1465     switch (timing.phase) {</span>
<span class="line-modified">1466     case AnimationEffectPhase::Before:</span>
<span class="line-modified">1467         // The animation is in its &quot;before&quot; phase, in this case we can wait until it enters its &quot;active&quot; phase.</span>
<span class="line-modified">1468         return (effect.delay() - timing.localTime.value()) / playbackRate;</span>
<span class="line-modified">1469     case AnimationEffectPhase::Active:</span>
<span class="line-modified">1470         if (isCompletelyAccelerated() &amp;&amp; isRunningAccelerated()) {</span>
<span class="line-modified">1471             // Fully-accelerated running CSS Animations need to trigger &quot;animationiteration&quot; events, in this case we must wait until the next iteration.</span>
<span class="line-modified">1472             if (isCSSAnimation()) {</span>
<span class="line-modified">1473                 if (auto iterationProgress = effect.getComputedTiming().simpleIterationProgress)</span>
<span class="line-modified">1474                     return effect.iterationDuration() * (1 - *iterationProgress);</span>
<span class="line-modified">1475             }</span>
<span class="line-modified">1476             // Fully-accelerated running animations in the &quot;active&quot; phase can wait until they ended.</span>
<span class="line-modified">1477             return (effect.endTime() - timing.localTime.value()) / playbackRate;</span>




1478         }
<span class="line-modified">1479         // Other animations in the &quot;active&quot; phase will need to update their animated value at the immediate next opportunity.</span>
<span class="line-modified">1480         return 0_s;</span>
<span class="line-added">1481     case AnimationEffectPhase::After:</span>
<span class="line-added">1482         // The animation is in its after phase, which means it will no longer update its value, so it doens&#39;t need a tick.</span>
<span class="line-added">1483         return Seconds::infinity();</span>
<span class="line-added">1484     case AnimationEffectPhase::Idle:</span>
<span class="line-added">1485         ASSERT_NOT_REACHED();</span>
<span class="line-added">1486         return Seconds::infinity();</span>
<span class="line-added">1487     }</span>
1488 
1489     ASSERT_NOT_REACHED();
1490     return Seconds::infinity();
1491 }
1492 
1493 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="KeyframeEffect.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WebAnimation.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/ScriptCallStackFactory.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScriptCallStack.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScriptCallStackFactory.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/ScriptCallStackFactory.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 28  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 29  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 30  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 31  */
 32 
 33 #include &quot;config.h&quot;
 34 #include &quot;ScriptCallStackFactory.h&quot;
 35 
 36 #include &quot;CallFrame.h&quot;
 37 #include &quot;CatchScope.h&quot;
 38 #include &quot;CodeBlock.h&quot;
 39 #include &quot;Exception.h&quot;
 40 #include &quot;JSCJSValue.h&quot;
 41 #include &quot;JSCInlines.h&quot;
 42 #include &quot;ScriptArguments.h&quot;
 43 #include &quot;ScriptCallFrame.h&quot;
 44 #include &quot;StackVisitor.h&quot;
 45 #include &quot;StrongInlines.h&quot;
 46 #include &lt;wtf/text/WTFString.h&gt;
 47 
<span class="line-removed"> 48 using namespace JSC;</span>
<span class="line-removed"> 49 </span>
 50 namespace Inspector {
 51 


 52 class CreateScriptCallStackFunctor {
 53 public:
 54     CreateScriptCallStackFunctor(bool needToSkipAFrame, Vector&lt;ScriptCallFrame&gt;&amp; frames, size_t remainingCapacity)
 55         : m_needToSkipAFrame(needToSkipAFrame)
 56         , m_frames(frames)
 57         , m_remainingCapacityForFrameCapture(remainingCapacity)
 58     {
 59     }
 60 
 61     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
 62     {
 63         if (m_needToSkipAFrame) {
 64             m_needToSkipAFrame = false;
 65             return StackVisitor::Continue;
 66         }
 67 
 68         if (m_remainingCapacityForFrameCapture) {
 69             unsigned line;
 70             unsigned column;
 71             visitor-&gt;computeLineAndColumn(line, column);
 72             m_frames.append(ScriptCallFrame(visitor-&gt;functionName(), visitor-&gt;sourceURL(), static_cast&lt;SourceID&gt;(visitor-&gt;sourceID()), line, column));
 73 
 74             m_remainingCapacityForFrameCapture--;
 75             return StackVisitor::Continue;
 76         }
 77 
 78         return StackVisitor::Done;
 79     }
 80 
 81 private:
 82     mutable bool m_needToSkipAFrame;
 83     Vector&lt;ScriptCallFrame&gt;&amp; m_frames;
 84     mutable size_t m_remainingCapacityForFrameCapture;
 85 };
 86 
<span class="line-modified"> 87 Ref&lt;ScriptCallStack&gt; createScriptCallStack(JSC::ExecState* exec, size_t maxStackSize)</span>
 88 {
<span class="line-modified"> 89     if (!exec)</span>
 90         return ScriptCallStack::create();
 91 
<span class="line-modified"> 92     JSLockHolder locker(exec);</span>
 93     Vector&lt;ScriptCallFrame&gt; frames;
 94 
<span class="line-modified"> 95     CallFrame* frame = exec-&gt;vm().topCallFrame;</span>

 96     if (!frame)
 97         return ScriptCallStack::create();
 98     CreateScriptCallStackFunctor functor(false, frames, maxStackSize);
<span class="line-modified"> 99     frame-&gt;iterate(functor);</span>
100 
101     return ScriptCallStack::create(frames);
102 }
103 
<span class="line-modified">104 Ref&lt;ScriptCallStack&gt; createScriptCallStackForConsole(JSC::ExecState* exec, size_t maxStackSize)</span>
105 {
<span class="line-modified">106     if (!exec)</span>
107         return ScriptCallStack::create();
108 
<span class="line-modified">109     JSLockHolder locker(exec);</span>
110     Vector&lt;ScriptCallFrame&gt; frames;
111 
<span class="line-modified">112     CallFrame* frame = exec-&gt;vm().topCallFrame;</span>

113     if (!frame)
114         return ScriptCallStack::create();
115     CreateScriptCallStackFunctor functor(true, frames, maxStackSize);
<span class="line-modified">116     frame-&gt;iterate(functor);</span>
117 
118     if (frames.isEmpty()) {
119         CreateScriptCallStackFunctor functor(false, frames, maxStackSize);
<span class="line-modified">120         frame-&gt;iterate(functor);</span>
121     }
122 
123     return ScriptCallStack::create(frames);
124 }
125 
<span class="line-modified">126 static bool extractSourceInformationFromException(JSC::ExecState* exec, JSObject* exceptionObject, int* lineNumber, int* columnNumber, String* sourceURL)</span>
127 {
<span class="line-modified">128     VM&amp; vm = exec-&gt;vm();</span>
129     auto scope = DECLARE_CATCH_SCOPE(vm);
130 
131     // FIXME: &lt;http://webkit.org/b/115087&gt; Web Inspector: Should not need to evaluate JavaScript handling exceptions
132     JSValue lineValue = exceptionObject-&gt;getDirect(vm, Identifier::fromString(vm, &quot;line&quot;));
133     JSValue columnValue = exceptionObject-&gt;getDirect(vm, Identifier::fromString(vm, &quot;column&quot;));
134     JSValue sourceURLValue = exceptionObject-&gt;getDirect(vm, Identifier::fromString(vm, &quot;sourceURL&quot;));
135 
136     bool result = false;
137     if (lineValue &amp;&amp; lineValue.isNumber()
138         &amp;&amp; sourceURLValue &amp;&amp; sourceURLValue.isString()) {
<span class="line-modified">139         *lineNumber = int(lineValue.toNumber(exec));</span>
<span class="line-modified">140         *columnNumber = columnValue &amp;&amp; columnValue.isNumber() ? int(columnValue.toNumber(exec)) : 0;</span>
<span class="line-modified">141         *sourceURL = sourceURLValue.toWTFString(exec);</span>
142         result = true;
143     } else if (ErrorInstance* error = jsDynamicCast&lt;ErrorInstance*&gt;(vm, exceptionObject)) {
144         unsigned unsignedLine;
145         unsigned unsignedColumn;
146         result = getLineColumnAndSource(error-&gt;stackTrace(), unsignedLine, unsignedColumn, *sourceURL);
147         *lineNumber = static_cast&lt;int&gt;(unsignedLine);
148         *columnNumber = static_cast&lt;int&gt;(unsignedColumn);
149     }
150 
151     if (sourceURL-&gt;isEmpty())
152         *sourceURL = &quot;undefined&quot;_s;
153 
154     scope.clearException();
155     return result;
156 }
157 
<span class="line-modified">158 Ref&lt;ScriptCallStack&gt; createScriptCallStackFromException(JSC::ExecState* exec, JSC::Exception* exception, size_t maxStackSize)</span>
159 {
160     Vector&lt;ScriptCallFrame&gt; frames;
161     auto&amp; stackTrace = exception-&gt;stack();
<span class="line-modified">162     VM&amp; vm = exec-&gt;vm();</span>
163     for (size_t i = 0; i &lt; stackTrace.size() &amp;&amp; i &lt; maxStackSize; i++) {
164         unsigned line;
165         unsigned column;
166         stackTrace[i].computeLineAndColumn(line, column);
167         String functionName = stackTrace[i].functionName(vm);
168         frames.append(ScriptCallFrame(functionName, stackTrace[i].sourceURL(), static_cast&lt;SourceID&gt;(stackTrace[i].sourceID()), line, column));
169     }
170 
171     // Fallback to getting at least the line and sourceURL from the exception object if it has values and the exceptionStack doesn&#39;t.
172     if (exception-&gt;value().isObject()) {
<span class="line-modified">173         JSObject* exceptionObject = exception-&gt;value().toObject(exec);</span>
174         ASSERT(exceptionObject);
175         int lineNumber;
176         int columnNumber;
177         String exceptionSourceURL;
178         if (!frames.size()) {
<span class="line-modified">179             if (extractSourceInformationFromException(exec, exceptionObject, &amp;lineNumber, &amp;columnNumber, &amp;exceptionSourceURL))</span>
180                 frames.append(ScriptCallFrame(String(), exceptionSourceURL, noSourceID, lineNumber, columnNumber));
181         } else {
182             // FIXME: The typical stack trace will have a native frame at the top, and consumers of
183             // this code already know this (see JSDOMExceptionHandling.cpp&#39;s reportException, for
184             // example - it uses firstNonNativeCallFrame). This looks like it splats something else
185             // over it. That something else is probably already at stackTrace[1].
186             // https://bugs.webkit.org/show_bug.cgi?id=176663
187             if (!stackTrace[0].hasLineAndColumnInfo() || stackTrace[0].sourceURL().isEmpty()) {
188                 const ScriptCallFrame&amp; firstCallFrame = frames.first();
<span class="line-modified">189                 if (extractSourceInformationFromException(exec, exceptionObject, &amp;lineNumber, &amp;columnNumber, &amp;exceptionSourceURL))</span>
190                     frames[0] = ScriptCallFrame(firstCallFrame.functionName(), exceptionSourceURL, stackTrace[0].sourceID(), lineNumber, columnNumber);
191             }
192         }
193     }
194 
195     return ScriptCallStack::create(frames);
196 }
197 
<span class="line-modified">198 Ref&lt;ScriptArguments&gt; createScriptArguments(JSC::ExecState* state, unsigned skipArgumentCount)</span>
199 {
<span class="line-modified">200     VM&amp; vm = state-&gt;vm();</span>
201     Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt; arguments;
<span class="line-modified">202     size_t argumentCount = state-&gt;argumentCount();</span>
203     for (size_t i = skipArgumentCount; i &lt; argumentCount; ++i)
<span class="line-modified">204         arguments.append({ vm, state-&gt;uncheckedArgument(i) });</span>
<span class="line-modified">205     return ScriptArguments::create(*state, WTFMove(arguments));</span>
206 }
207 
208 } // namespace Inspector
</pre>
</td>
<td>
<hr />
<pre>
 28  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 29  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 30  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 31  */
 32 
 33 #include &quot;config.h&quot;
 34 #include &quot;ScriptCallStackFactory.h&quot;
 35 
 36 #include &quot;CallFrame.h&quot;
 37 #include &quot;CatchScope.h&quot;
 38 #include &quot;CodeBlock.h&quot;
 39 #include &quot;Exception.h&quot;
 40 #include &quot;JSCJSValue.h&quot;
 41 #include &quot;JSCInlines.h&quot;
 42 #include &quot;ScriptArguments.h&quot;
 43 #include &quot;ScriptCallFrame.h&quot;
 44 #include &quot;StackVisitor.h&quot;
 45 #include &quot;StrongInlines.h&quot;
 46 #include &lt;wtf/text/WTFString.h&gt;
 47 


 48 namespace Inspector {
 49 
<span class="line-added"> 50 using namespace JSC;</span>
<span class="line-added"> 51 </span>
 52 class CreateScriptCallStackFunctor {
 53 public:
 54     CreateScriptCallStackFunctor(bool needToSkipAFrame, Vector&lt;ScriptCallFrame&gt;&amp; frames, size_t remainingCapacity)
 55         : m_needToSkipAFrame(needToSkipAFrame)
 56         , m_frames(frames)
 57         , m_remainingCapacityForFrameCapture(remainingCapacity)
 58     {
 59     }
 60 
 61     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
 62     {
 63         if (m_needToSkipAFrame) {
 64             m_needToSkipAFrame = false;
 65             return StackVisitor::Continue;
 66         }
 67 
 68         if (m_remainingCapacityForFrameCapture) {
 69             unsigned line;
 70             unsigned column;
 71             visitor-&gt;computeLineAndColumn(line, column);
 72             m_frames.append(ScriptCallFrame(visitor-&gt;functionName(), visitor-&gt;sourceURL(), static_cast&lt;SourceID&gt;(visitor-&gt;sourceID()), line, column));
 73 
 74             m_remainingCapacityForFrameCapture--;
 75             return StackVisitor::Continue;
 76         }
 77 
 78         return StackVisitor::Done;
 79     }
 80 
 81 private:
 82     mutable bool m_needToSkipAFrame;
 83     Vector&lt;ScriptCallFrame&gt;&amp; m_frames;
 84     mutable size_t m_remainingCapacityForFrameCapture;
 85 };
 86 
<span class="line-modified"> 87 Ref&lt;ScriptCallStack&gt; createScriptCallStack(JSC::JSGlobalObject* globalObject, size_t maxStackSize)</span>
 88 {
<span class="line-modified"> 89     if (!globalObject)</span>
 90         return ScriptCallStack::create();
 91 
<span class="line-modified"> 92     JSLockHolder locker(globalObject);</span>
 93     Vector&lt;ScriptCallFrame&gt; frames;
 94 
<span class="line-modified"> 95     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added"> 96     CallFrame* frame = vm.topCallFrame;</span>
 97     if (!frame)
 98         return ScriptCallStack::create();
 99     CreateScriptCallStackFunctor functor(false, frames, maxStackSize);
<span class="line-modified">100     frame-&gt;iterate(vm, functor);</span>
101 
102     return ScriptCallStack::create(frames);
103 }
104 
<span class="line-modified">105 Ref&lt;ScriptCallStack&gt; createScriptCallStackForConsole(JSC::JSGlobalObject* globalObject, size_t maxStackSize)</span>
106 {
<span class="line-modified">107     if (!globalObject)</span>
108         return ScriptCallStack::create();
109 
<span class="line-modified">110     JSLockHolder locker(globalObject);</span>
111     Vector&lt;ScriptCallFrame&gt; frames;
112 
<span class="line-modified">113     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">114     CallFrame* frame = vm.topCallFrame;</span>
115     if (!frame)
116         return ScriptCallStack::create();
117     CreateScriptCallStackFunctor functor(true, frames, maxStackSize);
<span class="line-modified">118     frame-&gt;iterate(vm, functor);</span>
119 
120     if (frames.isEmpty()) {
121         CreateScriptCallStackFunctor functor(false, frames, maxStackSize);
<span class="line-modified">122         frame-&gt;iterate(vm, functor);</span>
123     }
124 
125     return ScriptCallStack::create(frames);
126 }
127 
<span class="line-modified">128 static bool extractSourceInformationFromException(JSC::JSGlobalObject* globalObject, JSObject* exceptionObject, int* lineNumber, int* columnNumber, String* sourceURL)</span>
129 {
<span class="line-modified">130     VM&amp; vm = globalObject-&gt;vm();</span>
131     auto scope = DECLARE_CATCH_SCOPE(vm);
132 
133     // FIXME: &lt;http://webkit.org/b/115087&gt; Web Inspector: Should not need to evaluate JavaScript handling exceptions
134     JSValue lineValue = exceptionObject-&gt;getDirect(vm, Identifier::fromString(vm, &quot;line&quot;));
135     JSValue columnValue = exceptionObject-&gt;getDirect(vm, Identifier::fromString(vm, &quot;column&quot;));
136     JSValue sourceURLValue = exceptionObject-&gt;getDirect(vm, Identifier::fromString(vm, &quot;sourceURL&quot;));
137 
138     bool result = false;
139     if (lineValue &amp;&amp; lineValue.isNumber()
140         &amp;&amp; sourceURLValue &amp;&amp; sourceURLValue.isString()) {
<span class="line-modified">141         *lineNumber = int(lineValue.toNumber(globalObject));</span>
<span class="line-modified">142         *columnNumber = columnValue &amp;&amp; columnValue.isNumber() ? int(columnValue.toNumber(globalObject)) : 0;</span>
<span class="line-modified">143         *sourceURL = sourceURLValue.toWTFString(globalObject);</span>
144         result = true;
145     } else if (ErrorInstance* error = jsDynamicCast&lt;ErrorInstance*&gt;(vm, exceptionObject)) {
146         unsigned unsignedLine;
147         unsigned unsignedColumn;
148         result = getLineColumnAndSource(error-&gt;stackTrace(), unsignedLine, unsignedColumn, *sourceURL);
149         *lineNumber = static_cast&lt;int&gt;(unsignedLine);
150         *columnNumber = static_cast&lt;int&gt;(unsignedColumn);
151     }
152 
153     if (sourceURL-&gt;isEmpty())
154         *sourceURL = &quot;undefined&quot;_s;
155 
156     scope.clearException();
157     return result;
158 }
159 
<span class="line-modified">160 Ref&lt;ScriptCallStack&gt; createScriptCallStackFromException(JSC::JSGlobalObject* globalObject, JSC::Exception* exception, size_t maxStackSize)</span>
161 {
162     Vector&lt;ScriptCallFrame&gt; frames;
163     auto&amp; stackTrace = exception-&gt;stack();
<span class="line-modified">164     VM&amp; vm = globalObject-&gt;vm();</span>
165     for (size_t i = 0; i &lt; stackTrace.size() &amp;&amp; i &lt; maxStackSize; i++) {
166         unsigned line;
167         unsigned column;
168         stackTrace[i].computeLineAndColumn(line, column);
169         String functionName = stackTrace[i].functionName(vm);
170         frames.append(ScriptCallFrame(functionName, stackTrace[i].sourceURL(), static_cast&lt;SourceID&gt;(stackTrace[i].sourceID()), line, column));
171     }
172 
173     // Fallback to getting at least the line and sourceURL from the exception object if it has values and the exceptionStack doesn&#39;t.
174     if (exception-&gt;value().isObject()) {
<span class="line-modified">175         JSObject* exceptionObject = exception-&gt;value().toObject(globalObject);</span>
176         ASSERT(exceptionObject);
177         int lineNumber;
178         int columnNumber;
179         String exceptionSourceURL;
180         if (!frames.size()) {
<span class="line-modified">181             if (extractSourceInformationFromException(globalObject, exceptionObject, &amp;lineNumber, &amp;columnNumber, &amp;exceptionSourceURL))</span>
182                 frames.append(ScriptCallFrame(String(), exceptionSourceURL, noSourceID, lineNumber, columnNumber));
183         } else {
184             // FIXME: The typical stack trace will have a native frame at the top, and consumers of
185             // this code already know this (see JSDOMExceptionHandling.cpp&#39;s reportException, for
186             // example - it uses firstNonNativeCallFrame). This looks like it splats something else
187             // over it. That something else is probably already at stackTrace[1].
188             // https://bugs.webkit.org/show_bug.cgi?id=176663
189             if (!stackTrace[0].hasLineAndColumnInfo() || stackTrace[0].sourceURL().isEmpty()) {
190                 const ScriptCallFrame&amp; firstCallFrame = frames.first();
<span class="line-modified">191                 if (extractSourceInformationFromException(globalObject, exceptionObject, &amp;lineNumber, &amp;columnNumber, &amp;exceptionSourceURL))</span>
192                     frames[0] = ScriptCallFrame(firstCallFrame.functionName(), exceptionSourceURL, stackTrace[0].sourceID(), lineNumber, columnNumber);
193             }
194         }
195     }
196 
197     return ScriptCallStack::create(frames);
198 }
199 
<span class="line-modified">200 Ref&lt;ScriptArguments&gt; createScriptArguments(JSC::JSGlobalObject* globalObject, JSC::CallFrame* callFrame, unsigned skipArgumentCount)</span>
201 {
<span class="line-modified">202     VM&amp; vm = globalObject-&gt;vm();</span>
203     Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt; arguments;
<span class="line-modified">204     size_t argumentCount = callFrame-&gt;argumentCount();</span>
205     for (size_t i = skipArgumentCount; i &lt; argumentCount; ++i)
<span class="line-modified">206         arguments.append({ vm, callFrame-&gt;uncheckedArgument(i) });</span>
<span class="line-modified">207     return ScriptArguments::create(globalObject, WTFMove(arguments));</span>
208 }
209 
210 } // namespace Inspector
</pre>
</td>
</tr>
</table>
<center><a href="ScriptCallStack.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScriptCallStackFactory.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
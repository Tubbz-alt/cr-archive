<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGOpInfo.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGOperations.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOperations.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 36,37 ***</span>
  #include &quot;DFGOSRExit.h&quot;
  #include &quot;DFGThunks.h&quot;
  #include &quot;DFGToFTLDeferredCompilationCallback.h&quot;
  #include &quot;DFGToFTLForOSREntryDeferredCompilationCallback.h&quot;
  #include &quot;DFGWorklist.h&quot;
  #include &quot;DefinePropertyAttributes.h&quot;
  #include &quot;DirectArguments.h&quot;
  #include &quot;FTLForOSREntryJITCode.h&quot;
  #include &quot;FTLOSREntry.h&quot;
  #include &quot;FrameTracers.h&quot;
  #include &quot;HasOwnPropertyCache.h&quot;
  #include &quot;HostCallReturnValue.h&quot;
  #include &quot;Interpreter.h&quot;
  #include &quot;JIT.h&quot;
  #include &quot;JITExceptions.h&quot;
  #include &quot;JSArrayInlines.h&quot;
  #include &quot;JSBigInt.h&quot;
  #include &quot;JSCInlines.h&quot;
<span class="line-removed">- #include &quot;JSFixedArray.h&quot;</span>
  #include &quot;JSGenericTypedArrayViewConstructorInlines.h&quot;
  #include &quot;JSGlobalObjectFunctions.h&quot;
  #include &quot;JSImmutableButterfly.h&quot;
  #include &quot;JSLexicalEnvironment.h&quot;
  #include &quot;JSMap.h&quot;
  #include &quot;JSPropertyNameEnumerator.h&quot;
  #include &quot;JSSet.h&quot;
  #include &quot;JSWeakMap.h&quot;
  #include &quot;JSWeakSet.h&quot;
  #include &quot;NumberConstructor.h&quot;
  #include &quot;ObjectConstructor.h&quot;
  #include &quot;Operations.h&quot;
  #include &quot;ParseInt.h&quot;
  #include &quot;RegExpGlobalDataInlines.h&quot;
  #include &quot;RegExpMatchesArray.h&quot;
  #include &quot;RegExpObjectInlines.h&quot;
  #include &quot;Repatch.h&quot;
  #include &quot;ScopedArguments.h&quot;
<span class="line-new-header">--- 36,45 ---</span>
  #include &quot;DFGOSRExit.h&quot;
  #include &quot;DFGThunks.h&quot;
  #include &quot;DFGToFTLDeferredCompilationCallback.h&quot;
  #include &quot;DFGToFTLForOSREntryDeferredCompilationCallback.h&quot;
  #include &quot;DFGWorklist.h&quot;
<span class="line-added">+ #include &quot;DateInstance.h&quot;</span>
  #include &quot;DefinePropertyAttributes.h&quot;
  #include &quot;DirectArguments.h&quot;
<span class="line-added">+ #include &quot;EvalCodeBlock.h&quot;</span>
  #include &quot;FTLForOSREntryJITCode.h&quot;
  #include &quot;FTLOSREntry.h&quot;
  #include &quot;FrameTracers.h&quot;
  #include &quot;HasOwnPropertyCache.h&quot;
  #include &quot;HostCallReturnValue.h&quot;
  #include &quot;Interpreter.h&quot;
  #include &quot;JIT.h&quot;
  #include &quot;JITExceptions.h&quot;
  #include &quot;JSArrayInlines.h&quot;
<span class="line-added">+ #include &quot;JSArrayIterator.h&quot;</span>
<span class="line-added">+ #include &quot;JSAsyncGenerator.h&quot;</span>
  #include &quot;JSBigInt.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSGenericTypedArrayViewConstructorInlines.h&quot;
  #include &quot;JSGlobalObjectFunctions.h&quot;
  #include &quot;JSImmutableButterfly.h&quot;
<span class="line-added">+ #include &quot;JSInternalPromise.h&quot;</span>
<span class="line-added">+ #include &quot;JSInternalPromiseConstructor.h&quot;</span>
  #include &quot;JSLexicalEnvironment.h&quot;
  #include &quot;JSMap.h&quot;
<span class="line-added">+ #include &quot;JSPromiseConstructor.h&quot;</span>
  #include &quot;JSPropertyNameEnumerator.h&quot;
  #include &quot;JSSet.h&quot;
  #include &quot;JSWeakMap.h&quot;
  #include &quot;JSWeakSet.h&quot;
<span class="line-added">+ #include &quot;ModuleProgramCodeBlock.h&quot;</span>
  #include &quot;NumberConstructor.h&quot;
  #include &quot;ObjectConstructor.h&quot;
  #include &quot;Operations.h&quot;
  #include &quot;ParseInt.h&quot;
<span class="line-added">+ #include &quot;ProgramCodeBlock.h&quot;</span>
  #include &quot;RegExpGlobalDataInlines.h&quot;
  #include &quot;RegExpMatchesArray.h&quot;
  #include &quot;RegExpObjectInlines.h&quot;
  #include &quot;Repatch.h&quot;
  #include &quot;ScopedArguments.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 81,37 ***</span>
  #include &lt;wtf/Variant.h&gt;
  
  #if ENABLE(JIT)
  #if ENABLE(DFG_JIT)
  
  namespace JSC { namespace DFG {
  
  template&lt;bool strict, bool direct&gt;
<span class="line-modified">! static inline void putByVal(ExecState* exec, VM&amp; vm, JSValue baseValue, uint32_t index, JSValue value)</span>
  {
      ASSERT(isIndex(index));
      if (direct) {
          RELEASE_ASSERT(baseValue.isObject());
<span class="line-modified">!         asObject(baseValue)-&gt;putDirectIndex(exec, index, value, 0, strict ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
          return;
      }
      if (baseValue.isObject()) {
          JSObject* object = asObject(baseValue);
          if (object-&gt;canSetIndexQuickly(index, value)) {
              object-&gt;setIndexQuickly(vm, index, value);
              return;
          }
  
<span class="line-modified">!         object-&gt;methodTable(vm)-&gt;putByIndex(object, exec, index, value, strict);</span>
          return;
      }
  
<span class="line-modified">!     baseValue.putByIndex(exec, index, value, strict);</span>
  }
  
  template&lt;bool strict, bool direct&gt;
<span class="line-modified">! ALWAYS_INLINE static void putByValInternal(ExecState* exec, VM&amp; vm, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue baseValue = JSValue::decode(encodedBase);
      JSValue property = JSValue::decode(encodedProperty);
<span class="line-new-header">--- 89,39 ---</span>
  #include &lt;wtf/Variant.h&gt;
  
  #if ENABLE(JIT)
  #if ENABLE(DFG_JIT)
  
<span class="line-added">+ IGNORE_WARNINGS_BEGIN(&quot;frame-address&quot;)</span>
<span class="line-added">+ </span>
  namespace JSC { namespace DFG {
  
  template&lt;bool strict, bool direct&gt;
<span class="line-modified">! static inline void putByVal(JSGlobalObject* globalObject, VM&amp; vm, JSValue baseValue, uint32_t index, JSValue value)</span>
  {
      ASSERT(isIndex(index));
      if (direct) {
          RELEASE_ASSERT(baseValue.isObject());
<span class="line-modified">!         asObject(baseValue)-&gt;putDirectIndex(globalObject, index, value, 0, strict ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
          return;
      }
      if (baseValue.isObject()) {
          JSObject* object = asObject(baseValue);
          if (object-&gt;canSetIndexQuickly(index, value)) {
              object-&gt;setIndexQuickly(vm, index, value);
              return;
          }
  
<span class="line-modified">!         object-&gt;methodTable(vm)-&gt;putByIndex(object, globalObject, index, value, strict);</span>
          return;
      }
  
<span class="line-modified">!     baseValue.putByIndex(globalObject, index, value, strict);</span>
  }
  
  template&lt;bool strict, bool direct&gt;
<span class="line-modified">! ALWAYS_INLINE static void putByValInternal(JSGlobalObject* globalObject, VM&amp; vm, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue baseValue = JSValue::decode(encodedBase);
      JSValue property = JSValue::decode(encodedProperty);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 119,149 ***</span>
  
      if (LIKELY(property.isUInt32())) {
          // Despite its name, JSValue::isUInt32 will return true only for positive boxed int32_t; all those values are valid array indices.
          ASSERT(isIndex(property.asUInt32()));
          scope.release();
<span class="line-modified">!         putByVal&lt;strict, direct&gt;(exec, vm, baseValue, property.asUInt32(), value);</span>
          return;
      }
  
      if (property.isDouble()) {
          double propertyAsDouble = property.asDouble();
          uint32_t propertyAsUInt32 = static_cast&lt;uint32_t&gt;(propertyAsDouble);
          if (propertyAsDouble == propertyAsUInt32 &amp;&amp; isIndex(propertyAsUInt32)) {
              scope.release();
<span class="line-modified">!             putByVal&lt;strict, direct&gt;(exec, vm, baseValue, propertyAsUInt32, value);</span>
              return;
          }
      }
  
      // Don&#39;t put to an object if toString throws an exception.
<span class="line-modified">!     auto propertyName = property.toPropertyKey(exec);</span>
      RETURN_IF_EXCEPTION(scope, void());
  
      PutPropertySlot slot(baseValue, strict);
      if (direct) {
          RELEASE_ASSERT(baseValue.isObject());
          JSObject* baseObject = asObject(baseValue);
          if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName)) {
              scope.release();
<span class="line-modified">!             baseObject-&gt;putDirectIndex(exec, index.value(), value, 0, strict ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
              return;
          }
          scope.release();
<span class="line-modified">!         CommonSlowPaths::putDirectWithReify(vm, exec, baseObject, propertyName, value, slot);</span>
          return;
      }
      scope.release();
<span class="line-modified">!     baseValue.put(exec, propertyName, value, slot);</span>
  }
  
  template&lt;bool strict, bool direct&gt;
<span class="line-modified">! ALWAYS_INLINE static void putByValCellInternal(ExecState* exec, VM&amp; vm, JSCell* base, PropertyName propertyName, JSValue value)</span>
  {
      PutPropertySlot slot(base, strict);
      if (direct) {
          RELEASE_ASSERT(base-&gt;isObject());
          JSObject* baseObject = asObject(base);
          if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName)) {
<span class="line-modified">!             baseObject-&gt;putDirectIndex(exec, index.value(), value, 0, strict ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
              return;
          }
<span class="line-modified">!         CommonSlowPaths::putDirectWithReify(vm, exec, baseObject, propertyName, value, slot);</span>
          return;
      }
<span class="line-modified">!     base-&gt;putInline(exec, propertyName, value, slot);</span>
  }
  
  template&lt;bool strict, bool direct&gt;
<span class="line-modified">! ALWAYS_INLINE static void putByValCellStringInternal(ExecState* exec, VM&amp; vm, JSCell* base, JSString* property, JSValue value)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     auto propertyName = property-&gt;toIdentifier(exec);</span>
      RETURN_IF_EXCEPTION(scope, void());
  
      scope.release();
<span class="line-modified">!     putByValCellInternal&lt;strict, direct&gt;(exec, vm, base, propertyName, value);</span>
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! char* newTypedArrayWithSize(ExecState* exec, Structure* structure, int32_t size, char* vector)</span>
  {
<span class="line-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">-     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (size &lt; 0) {
<span class="line-modified">!         throwException(exec, scope, createRangeError(exec, &quot;Requested length is negative&quot;_s));</span>
          return 0;
      }
  
      if (vector)
<span class="line-modified">!         return bitwise_cast&lt;char*&gt;(ViewClass::createWithFastVector(exec, structure, size, untagArrayPtr(vector, size)));</span>
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, bitwise_cast&lt;char*&gt;(ViewClass::create(exec, structure, size)));</span>
  }
  
  template &lt;bool strict&gt;
<span class="line-modified">! static ALWAYS_INLINE void putWithThis(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedValue, const Identifier&amp; ident)</span>
  {
      JSValue baseValue = JSValue::decode(encodedBase);
      JSValue thisVal = JSValue::decode(encodedThis);
      JSValue putValue = JSValue::decode(encodedValue);
      PutPropertySlot slot(thisVal, strict);
<span class="line-modified">!     baseValue.putInline(exec, ident, putValue, slot);</span>
  }
  
  template&lt;typename BigIntOperation, typename NumberOperation&gt;
<span class="line-modified">! static ALWAYS_INLINE EncodedJSValue binaryOp(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, BigIntOperation&amp;&amp; bigIntOp, NumberOperation&amp;&amp; numberOp, const char* errorMessage)</span>
  {
<span class="line-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">-     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue op1 = JSValue::decode(encodedOp1);
      JSValue op2 = JSValue::decode(encodedOp2);
  
<span class="line-modified">!     auto leftNumeric = op1.toNumeric(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     auto rightNumeric = op2.toNumeric(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric))
<span class="line-modified">!             RELEASE_AND_RETURN(scope, JSValue::encode(bigIntOp(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric))));</span>
  
<span class="line-modified">!         return throwVMTypeError(exec, scope, errorMessage);</span>
      }
  
      scope.release();
  
      return JSValue::encode(jsNumber(numberOp(WTF::get&lt;double&gt;(leftNumeric), WTF::get&lt;double&gt;(rightNumeric))));
  }
  
  template&lt;typename BigIntOperation, typename Int32Operation&gt;
<span class="line-modified">! static ALWAYS_INLINE EncodedJSValue bitwiseBinaryOp(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, BigIntOperation&amp;&amp; bigIntOp, Int32Operation&amp;&amp; int32Op, const char* errorMessage)</span>
  {
<span class="line-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">-     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue op1 = JSValue::decode(encodedOp1);
      JSValue op2 = JSValue::decode(encodedOp2);
  
<span class="line-modified">!     auto leftNumeric = op1.toBigIntOrInt32(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     auto rightNumeric = op2.toBigIntOrInt32(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric))
<span class="line-modified">!             RELEASE_AND_RETURN(scope, JSValue::encode(bigIntOp(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric))));</span>
  
<span class="line-modified">!         return throwVMTypeError(exec, scope, errorMessage);</span>
      }
  
      scope.release();
  
      return JSValue::encode(jsNumber(int32Op(WTF::get&lt;int32_t&gt;(leftNumeric), WTF::get&lt;int32_t&gt;(rightNumeric))));
<span class="line-new-header">--- 129,143 ---</span>
  
      if (LIKELY(property.isUInt32())) {
          // Despite its name, JSValue::isUInt32 will return true only for positive boxed int32_t; all those values are valid array indices.
          ASSERT(isIndex(property.asUInt32()));
          scope.release();
<span class="line-modified">!         putByVal&lt;strict, direct&gt;(globalObject, vm, baseValue, property.asUInt32(), value);</span>
          return;
      }
  
      if (property.isDouble()) {
          double propertyAsDouble = property.asDouble();
          uint32_t propertyAsUInt32 = static_cast&lt;uint32_t&gt;(propertyAsDouble);
          if (propertyAsDouble == propertyAsUInt32 &amp;&amp; isIndex(propertyAsUInt32)) {
              scope.release();
<span class="line-modified">!             putByVal&lt;strict, direct&gt;(globalObject, vm, baseValue, propertyAsUInt32, value);</span>
              return;
          }
      }
  
      // Don&#39;t put to an object if toString throws an exception.
<span class="line-modified">!     auto propertyName = property.toPropertyKey(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, void());
  
      PutPropertySlot slot(baseValue, strict);
      if (direct) {
          RELEASE_ASSERT(baseValue.isObject());
          JSObject* baseObject = asObject(baseValue);
          if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName)) {
              scope.release();
<span class="line-modified">!             baseObject-&gt;putDirectIndex(globalObject, index.value(), value, 0, strict ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
              return;
          }
          scope.release();
<span class="line-modified">!         CommonSlowPaths::putDirectWithReify(vm, globalObject, baseObject, propertyName, value, slot);</span>
          return;
      }
      scope.release();
<span class="line-modified">!     baseValue.put(globalObject, propertyName, value, slot);</span>
  }
  
  template&lt;bool strict, bool direct&gt;
<span class="line-modified">! ALWAYS_INLINE static void putByValCellInternal(JSGlobalObject* globalObject, VM&amp; vm, JSCell* base, PropertyName propertyName, JSValue value)</span>
  {
      PutPropertySlot slot(base, strict);
      if (direct) {
          RELEASE_ASSERT(base-&gt;isObject());
          JSObject* baseObject = asObject(base);
          if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName)) {
<span class="line-modified">!             baseObject-&gt;putDirectIndex(globalObject, index.value(), value, 0, strict ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
              return;
          }
<span class="line-modified">!         CommonSlowPaths::putDirectWithReify(vm, globalObject, baseObject, propertyName, value, slot);</span>
          return;
      }
<span class="line-modified">!     base-&gt;putInline(globalObject, propertyName, value, slot);</span>
  }
  
  template&lt;bool strict, bool direct&gt;
<span class="line-modified">! ALWAYS_INLINE static void putByValCellStringInternal(JSGlobalObject* globalObject, VM&amp; vm, JSCell* base, JSString* property, JSValue value)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     auto propertyName = property-&gt;toIdentifier(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, void());
  
      scope.release();
<span class="line-modified">!     putByValCellInternal&lt;strict, direct&gt;(globalObject, vm, base, propertyName, value);</span>
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! char* newTypedArrayWithSize(JSGlobalObject* globalObject, VM&amp; vm, Structure* structure, int32_t size, char* vector)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (size &lt; 0) {
<span class="line-modified">!         throwException(globalObject, scope, createRangeError(globalObject, &quot;Requested length is negative&quot;_s));</span>
          return 0;
      }
  
      if (vector)
<span class="line-modified">!         return bitwise_cast&lt;char*&gt;(ViewClass::createWithFastVector(globalObject, structure, size, untagArrayPtr(vector, size)));</span>
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, bitwise_cast&lt;char*&gt;(ViewClass::create(globalObject, structure, size)));</span>
  }
  
  template &lt;bool strict&gt;
<span class="line-modified">! static ALWAYS_INLINE void putWithThis(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedValue, const Identifier&amp; ident)</span>
  {
      JSValue baseValue = JSValue::decode(encodedBase);
      JSValue thisVal = JSValue::decode(encodedThis);
      JSValue putValue = JSValue::decode(encodedValue);
      PutPropertySlot slot(thisVal, strict);
<span class="line-modified">!     baseValue.putInline(globalObject, ident, putValue, slot);</span>
  }
  
  template&lt;typename BigIntOperation, typename NumberOperation&gt;
<span class="line-modified">! static ALWAYS_INLINE EncodedJSValue binaryOp(JSGlobalObject* globalObject, VM&amp; vm, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, BigIntOperation&amp;&amp; bigIntOp, NumberOperation&amp;&amp; numberOp, const char* errorMessage)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue op1 = JSValue::decode(encodedOp1);
      JSValue op2 = JSValue::decode(encodedOp2);
  
<span class="line-modified">!     auto leftNumeric = op1.toNumeric(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     auto rightNumeric = op2.toNumeric(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric))
<span class="line-modified">!             RELEASE_AND_RETURN(scope, JSValue::encode(bigIntOp(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric))));</span>
  
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, errorMessage);</span>
      }
  
      scope.release();
  
      return JSValue::encode(jsNumber(numberOp(WTF::get&lt;double&gt;(leftNumeric), WTF::get&lt;double&gt;(rightNumeric))));
  }
  
  template&lt;typename BigIntOperation, typename Int32Operation&gt;
<span class="line-modified">! static ALWAYS_INLINE EncodedJSValue bitwiseBinaryOp(JSGlobalObject* globalObject, VM&amp; vm, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, BigIntOperation&amp;&amp; bigIntOp, Int32Operation&amp;&amp; int32Op, const char* errorMessage)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue op1 = JSValue::decode(encodedOp1);
      JSValue op2 = JSValue::decode(encodedOp2);
  
<span class="line-modified">!     auto leftNumeric = op1.toBigIntOrInt32(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     auto rightNumeric = op2.toBigIntOrInt32(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric))
<span class="line-modified">!             RELEASE_AND_RETURN(scope, JSValue::encode(bigIntOp(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric))));</span>
  
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, errorMessage);</span>
      }
  
      scope.release();
  
      return JSValue::encode(jsNumber(int32Op(WTF::get&lt;int32_t&gt;(leftNumeric), WTF::get&lt;int32_t&gt;(rightNumeric))));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 273,818 ***</span>
      if (static_cast&lt;double&gt;(asInt) == input)
          return JSValue::encode(jsNumber(asInt));
      return JSValue::encode(jsNumber(input));
  }
  
<span class="line-modified">! ALWAYS_INLINE static JSValue getByValObject(ExecState* exec, VM&amp; vm, JSObject* base, PropertyName propertyName)</span>
  {
      Structure&amp; structure = *base-&gt;structure(vm);
      if (JSCell::canUseFastGetOwnProperty(structure)) {
          if (JSValue result = base-&gt;fastGetOwnProperty(vm, structure, propertyName))
              return result;
      }
<span class="line-modified">!     return base-&gt;get(exec, propertyName);</span>
  }
  
  extern &quot;C&quot; {
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationToThis(ExecState* exec, EncodedJSValue encodedOp)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return JSValue::encode(JSValue::decode(encodedOp).toThis(exec, NotStrictMode));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationToThisStrict(ExecState* exec, EncodedJSValue encodedOp)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return JSValue::encode(JSValue::decode(encodedOp).toThis(exec, StrictMode));</span>
  }
  
<span class="line-modified">! JSArray* JIT_OPERATION operationObjectKeys(ExecState* exec, EncodedJSValue encodedObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* object = JSValue::decode(encodedObject).toObject(exec);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      scope.release();
<span class="line-modified">!     return ownPropertyKeys(exec, object, PropertyNameMode::Strings, DontEnumPropertiesMode::Exclude);</span>
  }
  
<span class="line-modified">! JSArray* JIT_OPERATION operationObjectKeysObject(ExecState* exec, JSObject* object)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     return ownPropertyKeys(exec, object, PropertyNameMode::Strings, DontEnumPropertiesMode::Exclude);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationObjectCreate(ExecState* exec, EncodedJSValue encodedPrototype)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue prototype = JSValue::decode(encodedPrototype);
  
      if (!prototype.isObject() &amp;&amp; !prototype.isNull()) {
<span class="line-modified">!         throwVMTypeError(exec, scope, &quot;Object prototype may only be an Object or null.&quot;_s);</span>
          return nullptr;
      }
  
      if (prototype.isObject())
<span class="line-modified">!         RELEASE_AND_RETURN(scope, constructEmptyObject(exec, asObject(prototype)));</span>
<span class="line-modified">!     RELEASE_AND_RETURN(scope, constructEmptyObject(exec, exec-&gt;lexicalGlobalObject()-&gt;nullPrototypeObjectStructure()));</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationObjectCreateObject(ExecState* exec, JSObject* prototype)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     return constructEmptyObject(exec, prototype);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationCreateThis(ExecState* exec, JSObject* constructor, uint32_t inlineCapacity)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (constructor-&gt;type() == JSFunctionType &amp;&amp; jsCast&lt;JSFunction*&gt;(constructor)-&gt;canUseAllocationProfile()) {
<span class="line-modified">!         auto rareData = jsCast&lt;JSFunction*&gt;(constructor)-&gt;ensureRareDataAndAllocationProfile(exec, inlineCapacity);</span>
          scope.releaseAssertNoException();
          ObjectAllocationProfileWithPrototype* allocationProfile = rareData-&gt;objectAllocationProfile();
          Structure* structure = allocationProfile-&gt;structure();
<span class="line-modified">!         JSObject* result = constructEmptyObject(exec, structure);</span>
          if (structure-&gt;hasPolyProto()) {
              JSObject* prototype = allocationProfile-&gt;prototype();
<span class="line-modified">!             ASSERT(prototype == jsCast&lt;JSFunction*&gt;(constructor)-&gt;prototypeForConstruction(vm, exec));</span>
              result-&gt;putDirect(vm, knownPolyProtoOffset, prototype);
              prototype-&gt;didBecomePrototype();
              ASSERT_WITH_MESSAGE(!hasIndexedProperties(result-&gt;indexingType()), &quot;We rely on JSFinalObject not starting out with an indexing type otherwise we would potentially need to convert to slow put storage&quot;);
          }
          return result;
      }
  
<span class="line-modified">!     JSValue proto = constructor-&gt;get(exec, vm.propertyNames-&gt;prototype);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (proto.isObject())
<span class="line-modified">!         return constructEmptyObject(exec, asObject(proto));</span>
<span class="line-modified">!     return constructEmptyObject(exec);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationCallObjectConstructor(ExecState* exec, JSGlobalObject* globalObject, EncodedJSValue encodedTarget)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSValue value = JSValue::decode(encodedTarget);
      ASSERT(!value.isObject());
  
      if (value.isUndefinedOrNull())
<span class="line-modified">!         return constructEmptyObject(exec, globalObject-&gt;objectPrototype());</span>
<span class="line-modified">!     return value.toObject(exec, globalObject);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationToObject(ExecState* exec, JSGlobalObject* globalObject, EncodedJSValue encodedTarget, UniquedStringImpl* errorMessage)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue value = JSValue::decode(encodedTarget);
      ASSERT(!value.isObject());
  
      if (UNLIKELY(value.isUndefinedOrNull())) {
<span class="line-modified">!         if (errorMessage-&gt;length()) {</span>
<span class="line-modified">!             throwVMTypeError(exec, scope, errorMessage);</span>
              return nullptr;
          }
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, value.toObject(exec, globalObject));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueMod(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
  {
<span class="line-modified">!     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified">!         return JSBigInt::remainder(exec, left, right);</span>
      };
  
      auto numberOp = [] (double left, double right) -&gt; double {
          return jsMod(left, right);
      };
  
<span class="line-modified">!     return binaryOp(exec, encodedOp1, encodedOp2, bigIntOp, numberOp, &quot;Invalid mix of BigInt and other type in remainder operation.&quot;);</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueBitNot(ExecState* exec, EncodedJSValue encodedOp1)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue op1 = JSValue::decode(encodedOp1);
  
<span class="line-modified">!     auto operandNumeric = op1.toBigIntOrInt32(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(operandNumeric))
<span class="line-modified">!         RELEASE_AND_RETURN(scope, JSValue::encode(JSBigInt::bitwiseNot(exec, WTF::get&lt;JSBigInt*&gt;(operandNumeric))));</span>
  
      return JSValue::encode(jsNumber(~WTF::get&lt;int32_t&gt;(operandNumeric)));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueBitAnd(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
  {
<span class="line-modified">!     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified">!         return JSBigInt::bitwiseAnd(exec, left, right);</span>
      };
  
      auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {
          return left &amp; right;
      };
  
<span class="line-modified">!     return bitwiseBinaryOp(exec, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in bitwise &#39;and&#39; operation.&quot;_s);</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueBitOr(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
  {
<span class="line-modified">!     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified">!         return JSBigInt::bitwiseOr(exec, left, right);</span>
      };
  
      auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {
          return left | right;
      };
  
<span class="line-modified">!     return bitwiseBinaryOp(exec, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in bitwise &#39;or&#39; operation.&quot;_s);</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueBitXor(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
  {
<span class="line-modified">!     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified">!         return JSBigInt::bitwiseXor(exec, left, right);</span>
      };
  
      auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {
          return left ^ right;
      };
  
<span class="line-modified">!     return bitwiseBinaryOp(exec, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in bitwise &#39;xor&#39; operation.&quot;_s);</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueBitLShift(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
  {
<span class="line-modified">!     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified">!         return JSBigInt::leftShift(exec, left, right);</span>
      };
  
      auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {
          return left &lt;&lt; (right &amp; 0x1f);
      };
  
<span class="line-modified">!     return bitwiseBinaryOp(exec, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in left shift operation.&quot;_s);</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueBitRShift(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
<span class="line-modified">!     JSValue op1 = JSValue::decode(encodedOp1);</span>
<span class="line-modified">!     JSValue op2 = JSValue::decode(encodedOp2);</span>
  
<span class="line-modified">!     int32_t a = op1.toInt32(exec);</span>
<span class="line-modified">!     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-modified">!     scope.release();</span>
<span class="line-modified">!     uint32_t b = op2.toUInt32(exec);</span>
<span class="line-modified">!     return JSValue::encode(jsNumber(a &gt;&gt; (b &amp; 0x1f)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueBitURShift(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue op1 = JSValue::decode(encodedOp1);
      JSValue op2 = JSValue::decode(encodedOp2);
  
<span class="line-modified">!     uint32_t a = op1.toUInt32(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      scope.release();
<span class="line-modified">!     uint32_t b = op2.toUInt32(exec);</span>
      return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(a &gt;&gt; (b &amp; 0x1f))));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueAddNotNumber(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSValue op1 = JSValue::decode(encodedOp1);
      JSValue op2 = JSValue::decode(encodedOp2);
  
<span class="line-modified">!     return JSValue::encode(jsAddNonNumber(exec, op1, op2));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueDiv(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
  {
<span class="line-modified">!     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified">!         return JSBigInt::divide(exec, left, right);</span>
      };
  
      auto numberOp = [] (double left, double right) -&gt; double {
          return left / right;
      };
  
<span class="line-modified">!     return binaryOp(exec, encodedOp1, encodedOp2, bigIntOp, numberOp, &quot;Invalid mix of BigInt and other type in division operation.&quot;);</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValuePow(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
  {
<span class="line-modified">!     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified">!         return JSBigInt::exponentiate(exec, left, right);</span>
      };
  
      auto numberOp = [] (double left, double right) -&gt; double {
          return operationMathPow(left, right);
      };
  
<span class="line-modified">!     return binaryOp(exec, encodedOp1, encodedOp2, bigIntOp, numberOp, &quot;Invalid mix of BigInt and other type in exponentiation operation.&quot;_s);</span>
  }
  
<span class="line-modified">! double JIT_OPERATION operationArithAbs(ExecState* exec, EncodedJSValue encodedOp1)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue op1 = JSValue::decode(encodedOp1);
<span class="line-modified">!     double a = op1.toNumber(exec);</span>
      RETURN_IF_EXCEPTION(scope, PNaN);
      return fabs(a);
  }
  
<span class="line-modified">! uint32_t JIT_OPERATION operationArithClz32(ExecState* exec, EncodedJSValue encodedOp1)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue op1 = JSValue::decode(encodedOp1);
<span class="line-modified">!     uint32_t value = op1.toUInt32(exec);</span>
      RETURN_IF_EXCEPTION(scope, 0);
      return clz(value);
  }
  
<span class="line-modified">! double JIT_OPERATION operationArithFRound(ExecState* exec, EncodedJSValue encodedOp1)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue op1 = JSValue::decode(encodedOp1);
<span class="line-modified">!     double a = op1.toNumber(exec);</span>
      RETURN_IF_EXCEPTION(scope, PNaN);
      return static_cast&lt;float&gt;(a);
  }
  
  #define DFG_ARITH_UNARY(capitalizedName, lowerName) \
<span class="line-modified">! double JIT_OPERATION operationArith##capitalizedName(ExecState* exec, EncodedJSValue encodedOp1) \</span>
  { \
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm(); \</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec); \</span>
      auto scope = DECLARE_THROW_SCOPE(vm); \
      JSValue op1 = JSValue::decode(encodedOp1); \
<span class="line-modified">!     double result = op1.toNumber(exec); \</span>
      RETURN_IF_EXCEPTION(scope, PNaN); \
      return JSC::Math::lowerName(result); \
  }
      FOR_EACH_DFG_ARITH_UNARY_OP(DFG_ARITH_UNARY)
  #undef DFG_ARITH_UNARY
  
<span class="line-modified">! double JIT_OPERATION operationArithSqrt(ExecState* exec, EncodedJSValue encodedOp1)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue op1 = JSValue::decode(encodedOp1);
<span class="line-modified">!     double a = op1.toNumber(exec);</span>
      RETURN_IF_EXCEPTION(scope, PNaN);
      return sqrt(a);
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationArithRound(ExecState* exec, EncodedJSValue encodedArgument)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue argument = JSValue::decode(encodedArgument);
<span class="line-modified">!     double valueOfArgument = argument.toNumber(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(jsNumber(jsRound(valueOfArgument)));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationArithFloor(ExecState* exec, EncodedJSValue encodedArgument)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue argument = JSValue::decode(encodedArgument);
<span class="line-modified">!     double valueOfArgument = argument.toNumber(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(jsNumber(floor(valueOfArgument)));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationArithCeil(ExecState* exec, EncodedJSValue encodedArgument)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue argument = JSValue::decode(encodedArgument);
<span class="line-modified">!     double valueOfArgument = argument.toNumber(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(jsNumber(ceil(valueOfArgument)));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationArithTrunc(ExecState* exec, EncodedJSValue encodedArgument)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue argument = JSValue::decode(encodedArgument);
<span class="line-modified">!     double truncatedValueOfArgument = argument.toIntegerPreserveNaN(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(jsNumber(truncatedValueOfArgument));
  }
  
<span class="line-modified">! static ALWAYS_INLINE EncodedJSValue getByVal(ExecState* exec, JSCell* base, uint32_t index)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">-     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (base-&gt;isObject()) {</span>
<span class="line-removed">-         JSObject* object = asObject(base);</span>
<span class="line-removed">-         if (object-&gt;canGetIndexQuickly(index))</span>
<span class="line-removed">-             return JSValue::encode(object-&gt;getIndexQuickly(index));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (isJSString(base) &amp;&amp; asString(base)-&gt;canGetIndex(index))</span>
<span class="line-removed">-         return JSValue::encode(asString(base)-&gt;getIndex(exec, index));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return JSValue::encode(JSValue(base).get(exec, index));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- EncodedJSValue JIT_OPERATION operationGetByVal(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     JSValue baseValue = JSValue::decode(encodedBase);</span>
<span class="line-removed">-     JSValue property = JSValue::decode(encodedProperty);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (LIKELY(baseValue.isCell())) {</span>
<span class="line-removed">-         JSCell* base = baseValue.asCell();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (property.isUInt32())</span>
<span class="line-removed">-             RELEASE_AND_RETURN(scope, getByVal(exec, base, property.asUInt32()));</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (property.isDouble()) {</span>
<span class="line-removed">-             double propertyAsDouble = property.asDouble();</span>
<span class="line-removed">-             uint32_t propertyAsUInt32 = static_cast&lt;uint32_t&gt;(propertyAsDouble);</span>
<span class="line-removed">-             if (propertyAsUInt32 == propertyAsDouble &amp;&amp; isIndex(propertyAsUInt32))</span>
<span class="line-removed">-                 RELEASE_AND_RETURN(scope, getByVal(exec, base, propertyAsUInt32));</span>
<span class="line-removed">- </span>
<span class="line-removed">-         } else if (property.isString()) {</span>
<span class="line-removed">-             Structure&amp; structure = *base-&gt;structure(vm);</span>
<span class="line-removed">-             if (JSCell::canUseFastGetOwnProperty(structure)) {</span>
<span class="line-removed">-                 RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(property)-&gt;toExistingAtomString(exec);</span>
<span class="line-removed">-                 RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed">-                 if (existingAtomString) {</span>
<span class="line-removed">-                     if (JSValue result = base-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))</span>
<span class="line-removed">-                         return JSValue::encode(result);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     baseValue.requireObjectCoercible(exec);</span>
<span class="line-removed">-     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed">-     auto propertyName = property.toPropertyKey(exec);</span>
<span class="line-removed">-     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed">-     RELEASE_AND_RETURN(scope, JSValue::encode(baseValue.get(exec, propertyName)));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- EncodedJSValue JIT_OPERATION operationGetByValCell(ExecState* exec, JSCell* base, EncodedJSValue encodedProperty)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">-     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue property = JSValue::decode(encodedProperty);
  
      if (property.isUInt32())
<span class="line-modified">!         RELEASE_AND_RETURN(scope, getByVal(exec, base, property.asUInt32()));</span>
  
      if (property.isDouble()) {
          double propertyAsDouble = property.asDouble();
          uint32_t propertyAsUInt32 = static_cast&lt;uint32_t&gt;(propertyAsDouble);
          if (propertyAsUInt32 == propertyAsDouble)
<span class="line-modified">!             RELEASE_AND_RETURN(scope, getByVal(exec, base, propertyAsUInt32));</span>
  
      } else if (property.isString()) {
          Structure&amp; structure = *base-&gt;structure(vm);
          if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">!             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(property)-&gt;toExistingAtomString(exec);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
              if (existingAtomString) {
                  if (JSValue result = base-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))
                      return JSValue::encode(result);
              }
          }
      }
  
<span class="line-modified">!     auto propertyName = property.toPropertyKey(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(JSValue(base).get(exec, propertyName)));</span>
  }
  
<span class="line-modified">! ALWAYS_INLINE EncodedJSValue getByValCellInt(ExecState* exec, JSCell* base, int32_t index)</span>
  {
<span class="line-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">-     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-removed">- </span>
      if (index &lt; 0) {
          // Go the slowest way possible because negative indices don&#39;t use indexed storage.
<span class="line-modified">!         return JSValue::encode(JSValue(base).get(exec, Identifier::from(vm, index)));</span>
      }
  
      // Use this since we know that the value is out of bounds.
<span class="line-modified">!     return JSValue::encode(JSValue(base).get(exec, static_cast&lt;unsigned&gt;(index)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationGetByValObjectInt(ExecState* exec, JSObject* base, int32_t index)</span>
  {
<span class="line-modified">!     return getByValCellInt(exec, base, index);</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationGetByValStringInt(ExecState* exec, JSString* base, int32_t index)</span>
  {
<span class="line-modified">!     return getByValCellInt(exec, base, index);</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationGetByValObjectString(ExecState* exec, JSCell* base, JSCell* string)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     auto propertyName = asString(string)-&gt;toIdentifier(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(getByValObject(exec, vm, asObject(base), propertyName)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationGetByValObjectSymbol(ExecState* exec, JSCell* base, JSCell* symbol)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      auto propertyName = asSymbol(symbol)-&gt;privateName();
<span class="line-modified">!     return JSValue::encode(getByValObject(exec, vm, asObject(base), propertyName));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     putByValInternal&lt;true, false&gt;(exec, vm, encodedBase, encodedProperty, encodedValue);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValNonStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     putByValInternal&lt;false, false&gt;(exec, vm, encodedBase, encodedProperty, encodedValue);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValCellStrict(ExecState* exec, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     putByValInternal&lt;true, false&gt;(exec, vm, JSValue::encode(cell), encodedProperty, encodedValue);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValCellNonStrict(ExecState* exec, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     putByValInternal&lt;false, false&gt;(exec, vm, JSValue::encode(cell), encodedProperty, encodedValue);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValCellStringStrict(ExecState* exec, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     putByValCellStringInternal&lt;true, false&gt;(exec, vm, cell, asString(string), JSValue::decode(encodedValue));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValCellStringNonStrict(ExecState* exec, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     putByValCellStringInternal&lt;false, false&gt;(exec, vm, cell, asString(string), JSValue::decode(encodedValue));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValCellSymbolStrict(ExecState* exec, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      auto propertyName = asSymbol(symbol)-&gt;privateName();
<span class="line-modified">!     putByValCellInternal&lt;true, false&gt;(exec, vm, cell, propertyName, JSValue::decode(encodedValue));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValCellSymbolNonStrict(ExecState* exec, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      auto propertyName = asSymbol(symbol)-&gt;privateName();
<span class="line-modified">!     putByValCellInternal&lt;false, false&gt;(exec, vm, cell, propertyName, JSValue::decode(encodedValue));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValBeyondArrayBoundsStrict(ExecState* exec, JSObject* object, int32_t index, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      if (index &gt;= 0) {
<span class="line-modified">!         object-&gt;putByIndexInline(exec, index, JSValue::decode(encodedValue), true);</span>
          return;
      }
  
      PutPropertySlot slot(object, true);
      object-&gt;methodTable(vm)-&gt;put(
<span class="line-modified">!         object, exec, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValBeyondArrayBoundsNonStrict(ExecState* exec, JSObject* object, int32_t index, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      if (index &gt;= 0) {
<span class="line-modified">!         object-&gt;putByIndexInline(exec, index, JSValue::decode(encodedValue), false);</span>
          return;
      }
  
      PutPropertySlot slot(object, false);
      object-&gt;methodTable(vm)-&gt;put(
<span class="line-modified">!         object, exec, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutDoubleByValBeyondArrayBoundsStrict(ExecState* exec, JSObject* object, int32_t index, double value)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
  
      if (index &gt;= 0) {
<span class="line-modified">!         object-&gt;putByIndexInline(exec, index, jsValue, true);</span>
          return;
      }
  
      PutPropertySlot slot(object, true);
      object-&gt;methodTable(vm)-&gt;put(
<span class="line-modified">!         object, exec, Identifier::from(vm, index), jsValue, slot);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutDoubleByValBeyondArrayBoundsNonStrict(ExecState* exec, JSObject* object, int32_t index, double value)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
  
      if (index &gt;= 0) {
<span class="line-modified">!         object-&gt;putByIndexInline(exec, index, jsValue, false);</span>
          return;
      }
  
      PutPropertySlot slot(object, false);
      object-&gt;methodTable(vm)-&gt;put(
<span class="line-modified">!         object, exec, Identifier::from(vm, index), jsValue, slot);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutDoubleByValDirectBeyondArrayBoundsStrict(ExecState* exec, JSObject* object, int32_t index, double value)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
  
      if (index &gt;= 0) {
<span class="line-modified">!         object-&gt;putDirectIndex(exec, index, jsValue, 0, PutDirectIndexShouldThrow);</span>
          return;
      }
  
      PutPropertySlot slot(object, true);
<span class="line-modified">!     CommonSlowPaths::putDirectWithReify(vm, exec, object, Identifier::from(vm, index), jsValue, slot);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutDoubleByValDirectBeyondArrayBoundsNonStrict(ExecState* exec, JSObject* object, int32_t index, double value)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
  
      if (index &gt;= 0) {
<span class="line-modified">!         object-&gt;putDirectIndex(exec, index, jsValue);</span>
          return;
      }
  
      PutPropertySlot slot(object, false);
<span class="line-modified">!     CommonSlowPaths::putDirectWithReify(vm, exec, object, Identifier::from(vm, index), jsValue, slot);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValDirectStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     putByValInternal&lt;true, true&gt;(exec, vm, encodedBase, encodedProperty, encodedValue);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValDirectNonStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     putByValInternal&lt;false, true&gt;(exec, vm, encodedBase, encodedProperty, encodedValue);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValDirectCellStrict(ExecState* exec, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     putByValInternal&lt;true, true&gt;(exec, vm, JSValue::encode(cell), encodedProperty, encodedValue);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValDirectCellNonStrict(ExecState* exec, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     putByValInternal&lt;false, true&gt;(exec, vm, JSValue::encode(cell), encodedProperty, encodedValue);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValDirectCellStringStrict(ExecState* exec, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     putByValCellStringInternal&lt;true, true&gt;(exec, vm, cell, asString(string), JSValue::decode(encodedValue));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValDirectCellStringNonStrict(ExecState* exec, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     putByValCellStringInternal&lt;false, true&gt;(exec, vm, cell, asString(string), JSValue::decode(encodedValue));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValDirectCellSymbolStrict(ExecState* exec, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      auto propertyName = asSymbol(symbol)-&gt;privateName();
<span class="line-modified">!     putByValCellInternal&lt;true, true&gt;(exec, vm, cell, propertyName, JSValue::decode(encodedValue));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValDirectCellSymbolNonStrict(ExecState* exec, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      auto propertyName = asSymbol(symbol)-&gt;privateName();
<span class="line-modified">!     putByValCellInternal&lt;false, true&gt;(exec, vm, cell, propertyName, JSValue::decode(encodedValue));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValDirectBeyondArrayBoundsStrict(ExecState* exec, JSObject* object, int32_t index, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      if (index &gt;= 0) {
<span class="line-modified">!         object-&gt;putDirectIndex(exec, index, JSValue::decode(encodedValue), 0, PutDirectIndexShouldThrow);</span>
          return;
      }
  
      PutPropertySlot slot(object, true);
<span class="line-modified">!     CommonSlowPaths::putDirectWithReify(vm, exec, object, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValDirectBeyondArrayBoundsNonStrict(ExecState* exec, JSObject* object, int32_t index, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      if (index &gt;= 0) {
<span class="line-modified">!         object-&gt;putDirectIndex(exec, index, JSValue::decode(encodedValue));</span>
          return;
      }
  
      PutPropertySlot slot(object, false);
<span class="line-modified">!     CommonSlowPaths::putDirectWithReify(vm, exec, object, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationArrayPush(ExecState* exec, EncodedJSValue encodedValue, JSArray* array)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     array-&gt;pushInline(exec, JSValue::decode(encodedValue));</span>
      return JSValue::encode(jsNumber(array-&gt;length()));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationArrayPushDouble(ExecState* exec, double value, JSArray* array)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     array-&gt;pushInline(exec, JSValue(JSValue::EncodeAsDouble, value));</span>
      return JSValue::encode(jsNumber(array-&gt;length()));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationArrayPushMultiple(ExecState* exec, JSArray* array, void* buffer, int32_t elementCount)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // We assume that multiple JSArray::push calls with ArrayWithInt32/ArrayWithContiguous do not cause JS traps.
      // If it can cause any JS interactions, we can call the caller JS function of this function and overwrite the
      // content of ScratchBuffer. If the IndexingType is now ArrayWithInt32/ArrayWithContiguous, we can ensure
<span class="line-new-header">--- 277,927 ---</span>
      if (static_cast&lt;double&gt;(asInt) == input)
          return JSValue::encode(jsNumber(asInt));
      return JSValue::encode(jsNumber(input));
  }
  
<span class="line-modified">! ALWAYS_INLINE static JSValue getByValObject(JSGlobalObject* globalObject, VM&amp; vm, JSObject* base, PropertyName propertyName)</span>
  {
      Structure&amp; structure = *base-&gt;structure(vm);
      if (JSCell::canUseFastGetOwnProperty(structure)) {
          if (JSValue result = base-&gt;fastGetOwnProperty(vm, structure, propertyName))
              return result;
      }
<span class="line-modified">!     return base-&gt;get(globalObject, propertyName);</span>
  }
  
  extern &quot;C&quot; {
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationToThis(JSGlobalObject* globalObject, EncodedJSValue encodedOp)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     return JSValue::encode(JSValue::decode(encodedOp).toThis(globalObject, NotStrictMode));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationToThisStrict(JSGlobalObject* globalObject, EncodedJSValue encodedOp)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     return JSValue::encode(JSValue::decode(encodedOp).toThis(globalObject, StrictMode));</span>
  }
  
<span class="line-modified">! JSArray* JIT_OPERATION operationObjectKeys(JSGlobalObject* globalObject, EncodedJSValue encodedObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* object = JSValue::decode(encodedObject).toObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      scope.release();
<span class="line-modified">!     return ownPropertyKeys(globalObject, object, PropertyNameMode::Strings, DontEnumPropertiesMode::Exclude);</span>
  }
  
<span class="line-modified">! JSArray* JIT_OPERATION operationObjectKeysObject(JSGlobalObject* globalObject, JSObject* object)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     return ownPropertyKeys(globalObject, object, PropertyNameMode::Strings, DontEnumPropertiesMode::Exclude);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationObjectCreate(JSGlobalObject* globalObject, EncodedJSValue encodedPrototype)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue prototype = JSValue::decode(encodedPrototype);
  
      if (!prototype.isObject() &amp;&amp; !prototype.isNull()) {
<span class="line-modified">!         throwVMTypeError(globalObject, scope, &quot;Object prototype may only be an Object or null.&quot;_s);</span>
          return nullptr;
      }
  
      if (prototype.isObject())
<span class="line-modified">!         RELEASE_AND_RETURN(scope, constructEmptyObject(globalObject, asObject(prototype)));</span>
<span class="line-modified">!     RELEASE_AND_RETURN(scope, constructEmptyObject(vm, globalObject-&gt;nullPrototypeObjectStructure()));</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationObjectCreateObject(JSGlobalObject* globalObject, JSObject* prototype)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     return constructEmptyObject(globalObject, prototype);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationCreateThis(JSGlobalObject* globalObject, JSObject* constructor, uint32_t inlineCapacity)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (constructor-&gt;type() == JSFunctionType &amp;&amp; jsCast&lt;JSFunction*&gt;(constructor)-&gt;canUseAllocationProfile()) {
<span class="line-modified">!         auto rareData = jsCast&lt;JSFunction*&gt;(constructor)-&gt;ensureRareDataAndAllocationProfile(globalObject, inlineCapacity);</span>
          scope.releaseAssertNoException();
          ObjectAllocationProfileWithPrototype* allocationProfile = rareData-&gt;objectAllocationProfile();
          Structure* structure = allocationProfile-&gt;structure();
<span class="line-modified">!         JSObject* result = constructEmptyObject(vm, structure);</span>
          if (structure-&gt;hasPolyProto()) {
              JSObject* prototype = allocationProfile-&gt;prototype();
<span class="line-modified">!             ASSERT(prototype == jsCast&lt;JSFunction*&gt;(constructor)-&gt;prototypeForConstruction(vm, globalObject));</span>
              result-&gt;putDirect(vm, knownPolyProtoOffset, prototype);
              prototype-&gt;didBecomePrototype();
              ASSERT_WITH_MESSAGE(!hasIndexedProperties(result-&gt;indexingType()), &quot;We rely on JSFinalObject not starting out with an indexing type otherwise we would potentially need to convert to slow put storage&quot;);
          }
          return result;
      }
  
<span class="line-modified">!     JSValue proto = constructor-&gt;get(globalObject, vm.propertyNames-&gt;prototype);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (proto.isObject())
<span class="line-modified">!         return constructEmptyObject(globalObject, asObject(proto));</span>
<span class="line-modified">!     return constructEmptyObject(globalObject);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JSCell* JIT_OPERATION operationCreatePromise(JSGlobalObject* globalObject, JSObject* constructor)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+     Structure* structure = InternalFunction::createSubclassStructure(globalObject, globalObject-&gt;promiseConstructor(), constructor, globalObject-&gt;promiseStructure());</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added">+     RELEASE_AND_RETURN(scope, JSPromise::create(vm, structure));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JSCell* JIT_OPERATION operationCreateInternalPromise(JSGlobalObject* globalObject, JSObject* constructor)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+     Structure* structure = InternalFunction::createSubclassStructure(globalObject, globalObject-&gt;internalPromiseConstructor(), constructor, globalObject-&gt;internalPromiseStructure());</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added">+     RELEASE_AND_RETURN(scope, JSInternalPromise::create(vm, structure));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JSCell* JIT_OPERATION operationCreateGenerator(JSGlobalObject* globalObject, JSObject* constructor)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+     Structure* structure = InternalFunction::createSubclassStructure(globalObject, nullptr, constructor, globalObject-&gt;generatorStructure());</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added">+     RELEASE_AND_RETURN(scope, JSGenerator::create(vm, structure));</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationCreateAsyncGenerator(JSGlobalObject* globalObject, JSObject* constructor)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+     Structure* structure = InternalFunction::createSubclassStructure(globalObject, nullptr, constructor, globalObject-&gt;asyncGeneratorStructure());</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added">+     RELEASE_AND_RETURN(scope, JSAsyncGenerator::create(vm, structure));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JSCell* JIT_OPERATION operationCallObjectConstructor(JSGlobalObject* globalObject, EncodedJSValue encodedTarget)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      JSValue value = JSValue::decode(encodedTarget);
      ASSERT(!value.isObject());
  
      if (value.isUndefinedOrNull())
<span class="line-modified">!         return constructEmptyObject(globalObject, globalObject-&gt;objectPrototype());</span>
<span class="line-modified">!     return value.toObject(globalObject);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationToObject(JSGlobalObject* globalObject, EncodedJSValue encodedTarget, UniquedStringImpl* errorMessage)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue value = JSValue::decode(encodedTarget);
      ASSERT(!value.isObject());
  
      if (UNLIKELY(value.isUndefinedOrNull())) {
<span class="line-modified">!         if (errorMessage &amp;&amp; errorMessage-&gt;length()) {</span>
<span class="line-modified">!             throwVMTypeError(globalObject, scope, errorMessage);</span>
              return nullptr;
          }
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, value.toObject(globalObject));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueMod(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto bigIntOp = [] (JSGlobalObject* globalObject, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-added">+         return JSBigInt::remainder(globalObject, left, right);</span>
      };
  
      auto numberOp = [] (double left, double right) -&gt; double {
          return jsMod(left, right);
      };
  
<span class="line-modified">!     return binaryOp(globalObject, vm, encodedOp1, encodedOp2, bigIntOp, numberOp, &quot;Invalid mix of BigInt and other type in remainder operation.&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JIT_OPERATION operationInc(JSGlobalObject* globalObject, EncodedJSValue encodedOp1)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSValue op1 = JSValue::decode(encodedOp1);</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto operandNumeric = op1.toNumeric(globalObject);</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (WTF::holds_alternative&lt;JSBigInt*&gt;(operandNumeric))</span>
<span class="line-added">+         RELEASE_AND_RETURN(scope, JSValue::encode(JSBigInt::inc(globalObject, WTF::get&lt;JSBigInt*&gt;(operandNumeric))));</span>
<span class="line-added">+ </span>
<span class="line-added">+     double value = WTF::get&lt;double&gt;(operandNumeric);</span>
<span class="line-added">+     return JSValue::encode(jsNumber(value + 1));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JIT_OPERATION operationDec(JSGlobalObject* globalObject, EncodedJSValue encodedOp1)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSValue op1 = JSValue::decode(encodedOp1);</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto operandNumeric = op1.toNumeric(globalObject);</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (WTF::holds_alternative&lt;JSBigInt*&gt;(operandNumeric))</span>
<span class="line-added">+         RELEASE_AND_RETURN(scope, JSValue::encode(JSBigInt::dec(globalObject, WTF::get&lt;JSBigInt*&gt;(operandNumeric))));</span>
<span class="line-added">+ </span>
<span class="line-added">+     double value = WTF::get&lt;double&gt;(operandNumeric);</span>
<span class="line-added">+     return JSValue::encode(jsNumber(value - 1));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueBitNot(JSGlobalObject* globalObject, EncodedJSValue encodedOp1)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue op1 = JSValue::decode(encodedOp1);
  
<span class="line-modified">!     auto operandNumeric = op1.toBigIntOrInt32(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(operandNumeric))
<span class="line-modified">!         RELEASE_AND_RETURN(scope, JSValue::encode(JSBigInt::bitwiseNot(globalObject, WTF::get&lt;JSBigInt*&gt;(operandNumeric))));</span>
  
      return JSValue::encode(jsNumber(~WTF::get&lt;int32_t&gt;(operandNumeric)));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueBitAnd(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto bigIntOp = [] (JSGlobalObject* globalObject, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-added">+         return JSBigInt::bitwiseAnd(globalObject, left, right);</span>
      };
  
      auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {
          return left &amp; right;
      };
  
<span class="line-modified">!     return bitwiseBinaryOp(globalObject, vm, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in bitwise &#39;and&#39; operation.&quot;_s);</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueBitOr(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto bigIntOp = [] (JSGlobalObject* globalObject, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-added">+         return JSBigInt::bitwiseOr(globalObject, left, right);</span>
      };
  
      auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {
          return left | right;
      };
  
<span class="line-modified">!     return bitwiseBinaryOp(globalObject, vm, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in bitwise &#39;or&#39; operation.&quot;_s);</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueBitXor(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto bigIntOp = [] (JSGlobalObject* globalObject, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-added">+         return JSBigInt::bitwiseXor(globalObject, left, right);</span>
      };
  
      auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {
          return left ^ right;
      };
  
<span class="line-modified">!     return bitwiseBinaryOp(globalObject, vm, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in bitwise &#39;xor&#39; operation.&quot;_s);</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueBitLShift(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto bigIntOp = [] (JSGlobalObject* globalObject, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-added">+         return JSBigInt::leftShift(globalObject, left, right);</span>
      };
  
      auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {
          return left &lt;&lt; (right &amp; 0x1f);
      };
  
<span class="line-modified">!     return bitwiseBinaryOp(globalObject, vm, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in left shift operation.&quot;_s);</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueBitRShift(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     auto bigIntOp = [] (JSGlobalObject* globalObject, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified">!         return JSBigInt::signedRightShift(globalObject, left, right);</span>
<span class="line-added">+     };</span>
  
<span class="line-modified">!     auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {</span>
<span class="line-modified">!         return left &gt;&gt; (right &amp; 0x1f);</span>
<span class="line-modified">!     };</span>
<span class="line-modified">! </span>
<span class="line-modified">!     return bitwiseBinaryOp(globalObject, vm, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in signed right shift operation.&quot;_s);</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueBitURShift(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue op1 = JSValue::decode(encodedOp1);
      JSValue op2 = JSValue::decode(encodedOp2);
  
<span class="line-modified">!     uint32_t a = op1.toUInt32(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      scope.release();
<span class="line-modified">!     uint32_t b = op2.toUInt32(globalObject);</span>
      return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(a &gt;&gt; (b &amp; 0x1f))));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueAddNotNumber(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      JSValue op1 = JSValue::decode(encodedOp1);
      JSValue op2 = JSValue::decode(encodedOp2);
  
<span class="line-modified">!     return JSValue::encode(jsAddNonNumber(globalObject, op1, op2));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueDiv(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto bigIntOp = [] (JSGlobalObject* globalObject, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-added">+         return JSBigInt::divide(globalObject, left, right);</span>
      };
  
      auto numberOp = [] (double left, double right) -&gt; double {
          return left / right;
      };
  
<span class="line-modified">!     return binaryOp(globalObject, vm, encodedOp1, encodedOp2, bigIntOp, numberOp, &quot;Invalid mix of BigInt and other type in division operation.&quot;);</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValuePow(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto bigIntOp = [] (JSGlobalObject* globalObject, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-added">+         return JSBigInt::exponentiate(globalObject, left, right);</span>
      };
  
      auto numberOp = [] (double left, double right) -&gt; double {
          return operationMathPow(left, right);
      };
  
<span class="line-modified">!     return binaryOp(globalObject, vm, encodedOp1, encodedOp2, bigIntOp, numberOp, &quot;Invalid mix of BigInt and other type in exponentiation operation.&quot;_s);</span>
  }
  
<span class="line-modified">! double JIT_OPERATION operationArithAbs(JSGlobalObject* globalObject, EncodedJSValue encodedOp1)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue op1 = JSValue::decode(encodedOp1);
<span class="line-modified">!     double a = op1.toNumber(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, PNaN);
      return fabs(a);
  }
  
<span class="line-modified">! uint32_t JIT_OPERATION operationArithClz32(JSGlobalObject* globalObject, EncodedJSValue encodedOp1)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue op1 = JSValue::decode(encodedOp1);
<span class="line-modified">!     uint32_t value = op1.toUInt32(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, 0);
      return clz(value);
  }
  
<span class="line-modified">! double JIT_OPERATION operationArithFRound(JSGlobalObject* globalObject, EncodedJSValue encodedOp1)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue op1 = JSValue::decode(encodedOp1);
<span class="line-modified">!     double a = op1.toNumber(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, PNaN);
      return static_cast&lt;float&gt;(a);
  }
  
  #define DFG_ARITH_UNARY(capitalizedName, lowerName) \
<span class="line-modified">! double JIT_OPERATION operationArith##capitalizedName(JSGlobalObject* globalObject, EncodedJSValue encodedOp1) \</span>
  { \
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm(); \</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm); \</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame); \</span>
      auto scope = DECLARE_THROW_SCOPE(vm); \
      JSValue op1 = JSValue::decode(encodedOp1); \
<span class="line-modified">!     double result = op1.toNumber(globalObject); \</span>
      RETURN_IF_EXCEPTION(scope, PNaN); \
      return JSC::Math::lowerName(result); \
  }
      FOR_EACH_DFG_ARITH_UNARY_OP(DFG_ARITH_UNARY)
  #undef DFG_ARITH_UNARY
  
<span class="line-modified">! double JIT_OPERATION operationArithSqrt(JSGlobalObject* globalObject, EncodedJSValue encodedOp1)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue op1 = JSValue::decode(encodedOp1);
<span class="line-modified">!     double a = op1.toNumber(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, PNaN);
      return sqrt(a);
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationArithRound(JSGlobalObject* globalObject, EncodedJSValue encodedArgument)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue argument = JSValue::decode(encodedArgument);
<span class="line-modified">!     double valueOfArgument = argument.toNumber(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(jsNumber(jsRound(valueOfArgument)));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationArithFloor(JSGlobalObject* globalObject, EncodedJSValue encodedArgument)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue argument = JSValue::decode(encodedArgument);
<span class="line-modified">!     double valueOfArgument = argument.toNumber(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(jsNumber(floor(valueOfArgument)));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationArithCeil(JSGlobalObject* globalObject, EncodedJSValue encodedArgument)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue argument = JSValue::decode(encodedArgument);
<span class="line-modified">!     double valueOfArgument = argument.toNumber(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(jsNumber(ceil(valueOfArgument)));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationArithTrunc(JSGlobalObject* globalObject, EncodedJSValue encodedArgument)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue argument = JSValue::decode(encodedArgument);
<span class="line-modified">!     double truncatedValueOfArgument = argument.toIntegerPreserveNaN(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(jsNumber(truncatedValueOfArgument));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationGetByValCell(JSGlobalObject* globalObject, JSCell* base, EncodedJSValue encodedProperty)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue property = JSValue::decode(encodedProperty);
  
      if (property.isUInt32())
<span class="line-modified">!         RELEASE_AND_RETURN(scope, getByValWithIndex(globalObject, base, property.asUInt32()));</span>
  
      if (property.isDouble()) {
          double propertyAsDouble = property.asDouble();
          uint32_t propertyAsUInt32 = static_cast&lt;uint32_t&gt;(propertyAsDouble);
          if (propertyAsUInt32 == propertyAsDouble)
<span class="line-modified">!             RELEASE_AND_RETURN(scope, getByValWithIndex(globalObject, base, propertyAsUInt32));</span>
  
      } else if (property.isString()) {
          Structure&amp; structure = *base-&gt;structure(vm);
          if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">!             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(property)-&gt;toExistingAtomString(globalObject);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
              if (existingAtomString) {
                  if (JSValue result = base-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))
                      return JSValue::encode(result);
              }
          }
      }
  
<span class="line-modified">!     auto propertyName = property.toPropertyKey(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(JSValue(base).get(globalObject, propertyName)));</span>
  }
  
<span class="line-modified">! ALWAYS_INLINE EncodedJSValue getByValCellInt(JSGlobalObject* globalObject, VM&amp; vm, JSCell* base, int32_t index)</span>
  {
      if (index &lt; 0) {
          // Go the slowest way possible because negative indices don&#39;t use indexed storage.
<span class="line-modified">!         return JSValue::encode(JSValue(base).get(globalObject, Identifier::from(vm, index)));</span>
      }
  
      // Use this since we know that the value is out of bounds.
<span class="line-modified">!     return JSValue::encode(JSValue(base).get(globalObject, static_cast&lt;unsigned&gt;(index)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationGetByValObjectInt(JSGlobalObject* globalObject, JSObject* base, int32_t index)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return getByValCellInt(globalObject, vm, base, index);</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationGetByValStringInt(JSGlobalObject* globalObject, JSString* base, int32_t index)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return getByValCellInt(globalObject, vm, base, index);</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationGetByValObjectString(JSGlobalObject* globalObject, JSCell* base, JSCell* string)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     auto propertyName = asString(string)-&gt;toIdentifier(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(getByValObject(globalObject, vm, asObject(base), propertyName)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationGetByValObjectSymbol(JSGlobalObject* globalObject, JSCell* base, JSCell* symbol)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      auto propertyName = asSymbol(symbol)-&gt;privateName();
<span class="line-modified">!     return JSValue::encode(getByValObject(globalObject, vm, asObject(base), propertyName));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValStrict(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     putByValInternal&lt;true, false&gt;(globalObject, vm, encodedBase, encodedProperty, encodedValue);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValNonStrict(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     putByValInternal&lt;false, false&gt;(globalObject, vm, encodedBase, encodedProperty, encodedValue);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValCellStrict(JSGlobalObject* globalObject, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     putByValInternal&lt;true, false&gt;(globalObject, vm, JSValue::encode(cell), encodedProperty, encodedValue);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValCellNonStrict(JSGlobalObject* globalObject, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     putByValInternal&lt;false, false&gt;(globalObject, vm, JSValue::encode(cell), encodedProperty, encodedValue);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValCellStringStrict(JSGlobalObject* globalObject, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     putByValCellStringInternal&lt;true, false&gt;(globalObject, vm, cell, asString(string), JSValue::decode(encodedValue));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValCellStringNonStrict(JSGlobalObject* globalObject, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     putByValCellStringInternal&lt;false, false&gt;(globalObject, vm, cell, asString(string), JSValue::decode(encodedValue));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValCellSymbolStrict(JSGlobalObject* globalObject, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      auto propertyName = asSymbol(symbol)-&gt;privateName();
<span class="line-modified">!     putByValCellInternal&lt;true, false&gt;(globalObject, vm, cell, propertyName, JSValue::decode(encodedValue));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValCellSymbolNonStrict(JSGlobalObject* globalObject, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      auto propertyName = asSymbol(symbol)-&gt;privateName();
<span class="line-modified">!     putByValCellInternal&lt;false, false&gt;(globalObject, vm, cell, propertyName, JSValue::decode(encodedValue));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValBeyondArrayBoundsStrict(JSGlobalObject* globalObject, JSObject* object, int32_t index, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      if (index &gt;= 0) {
<span class="line-modified">!         object-&gt;putByIndexInline(globalObject, index, JSValue::decode(encodedValue), true);</span>
          return;
      }
  
      PutPropertySlot slot(object, true);
      object-&gt;methodTable(vm)-&gt;put(
<span class="line-modified">!         object, globalObject, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValBeyondArrayBoundsNonStrict(JSGlobalObject* globalObject, JSObject* object, int32_t index, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      if (index &gt;= 0) {
<span class="line-modified">!         object-&gt;putByIndexInline(globalObject, index, JSValue::decode(encodedValue), false);</span>
          return;
      }
  
      PutPropertySlot slot(object, false);
      object-&gt;methodTable(vm)-&gt;put(
<span class="line-modified">!         object, globalObject, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutDoubleByValBeyondArrayBoundsStrict(JSGlobalObject* globalObject, JSObject* object, int32_t index, double value)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
  
      if (index &gt;= 0) {
<span class="line-modified">!         object-&gt;putByIndexInline(globalObject, index, jsValue, true);</span>
          return;
      }
  
      PutPropertySlot slot(object, true);
      object-&gt;methodTable(vm)-&gt;put(
<span class="line-modified">!         object, globalObject, Identifier::from(vm, index), jsValue, slot);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutDoubleByValBeyondArrayBoundsNonStrict(JSGlobalObject* globalObject, JSObject* object, int32_t index, double value)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
  
      if (index &gt;= 0) {
<span class="line-modified">!         object-&gt;putByIndexInline(globalObject, index, jsValue, false);</span>
          return;
      }
  
      PutPropertySlot slot(object, false);
      object-&gt;methodTable(vm)-&gt;put(
<span class="line-modified">!         object, globalObject, Identifier::from(vm, index), jsValue, slot);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutDoubleByValDirectBeyondArrayBoundsStrict(JSGlobalObject* globalObject, JSObject* object, int32_t index, double value)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
  
      if (index &gt;= 0) {
<span class="line-modified">!         object-&gt;putDirectIndex(globalObject, index, jsValue, 0, PutDirectIndexShouldThrow);</span>
          return;
      }
  
      PutPropertySlot slot(object, true);
<span class="line-modified">!     CommonSlowPaths::putDirectWithReify(vm, globalObject, object, Identifier::from(vm, index), jsValue, slot);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutDoubleByValDirectBeyondArrayBoundsNonStrict(JSGlobalObject* globalObject, JSObject* object, int32_t index, double value)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
  
      if (index &gt;= 0) {
<span class="line-modified">!         object-&gt;putDirectIndex(globalObject, index, jsValue);</span>
          return;
      }
  
      PutPropertySlot slot(object, false);
<span class="line-modified">!     CommonSlowPaths::putDirectWithReify(vm, globalObject, object, Identifier::from(vm, index), jsValue, slot);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValDirectStrict(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     putByValInternal&lt;true, true&gt;(globalObject, vm, encodedBase, encodedProperty, encodedValue);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValDirectNonStrict(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     putByValInternal&lt;false, true&gt;(globalObject, vm, encodedBase, encodedProperty, encodedValue);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValDirectCellStrict(JSGlobalObject* globalObject, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     putByValInternal&lt;true, true&gt;(globalObject, vm, JSValue::encode(cell), encodedProperty, encodedValue);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValDirectCellNonStrict(JSGlobalObject* globalObject, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     putByValInternal&lt;false, true&gt;(globalObject, vm, JSValue::encode(cell), encodedProperty, encodedValue);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValDirectCellStringStrict(JSGlobalObject* globalObject, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     putByValCellStringInternal&lt;true, true&gt;(globalObject, vm, cell, asString(string), JSValue::decode(encodedValue));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValDirectCellStringNonStrict(JSGlobalObject* globalObject, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     putByValCellStringInternal&lt;false, true&gt;(globalObject, vm, cell, asString(string), JSValue::decode(encodedValue));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValDirectCellSymbolStrict(JSGlobalObject* globalObject, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      auto propertyName = asSymbol(symbol)-&gt;privateName();
<span class="line-modified">!     putByValCellInternal&lt;true, true&gt;(globalObject, vm, cell, propertyName, JSValue::decode(encodedValue));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValDirectCellSymbolNonStrict(JSGlobalObject* globalObject, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      auto propertyName = asSymbol(symbol)-&gt;privateName();
<span class="line-modified">!     putByValCellInternal&lt;false, true&gt;(globalObject, vm, cell, propertyName, JSValue::decode(encodedValue));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValDirectBeyondArrayBoundsStrict(JSGlobalObject* globalObject, JSObject* object, int32_t index, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      if (index &gt;= 0) {
<span class="line-modified">!         object-&gt;putDirectIndex(globalObject, index, JSValue::decode(encodedValue), 0, PutDirectIndexShouldThrow);</span>
          return;
      }
  
      PutPropertySlot slot(object, true);
<span class="line-modified">!     CommonSlowPaths::putDirectWithReify(vm, globalObject, object, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValDirectBeyondArrayBoundsNonStrict(JSGlobalObject* globalObject, JSObject* object, int32_t index, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      if (index &gt;= 0) {
<span class="line-modified">!         object-&gt;putDirectIndex(globalObject, index, JSValue::decode(encodedValue));</span>
          return;
      }
  
      PutPropertySlot slot(object, false);
<span class="line-modified">!     CommonSlowPaths::putDirectWithReify(vm, globalObject, object, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationArrayPush(JSGlobalObject* globalObject, EncodedJSValue encodedValue, JSArray* array)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     array-&gt;pushInline(globalObject, JSValue::decode(encodedValue));</span>
      return JSValue::encode(jsNumber(array-&gt;length()));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationArrayPushDouble(JSGlobalObject* globalObject, double value, JSArray* array)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     array-&gt;pushInline(globalObject, JSValue(JSValue::EncodeAsDouble, value));</span>
      return JSValue::encode(jsNumber(array-&gt;length()));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationArrayPushMultiple(JSGlobalObject* globalObject, JSArray* array, void* buffer, int32_t elementCount)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // We assume that multiple JSArray::push calls with ArrayWithInt32/ArrayWithContiguous do not cause JS traps.
      // If it can cause any JS interactions, we can call the caller JS function of this function and overwrite the
      // content of ScratchBuffer. If the IndexingType is now ArrayWithInt32/ArrayWithContiguous, we can ensure
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1095,431 ***</span>
      // the IndexingType is ArrayWithSlowPutArrayStorage which could have an indexed accessor in a prototype chain.
      RELEASE_ASSERT(!shouldUseSlowPut(array-&gt;indexingType()));
  
      EncodedJSValue* values = static_cast&lt;EncodedJSValue*&gt;(buffer);
      for (int32_t i = 0; i &lt; elementCount; ++i) {
<span class="line-modified">!         array-&gt;pushInline(exec, JSValue::decode(values[i]));</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
      return JSValue::encode(jsNumber(array-&gt;length()));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationArrayPushDoubleMultiple(ExecState* exec, JSArray* array, void* buffer, int32_t elementCount)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // We assume that multiple JSArray::push calls with ArrayWithDouble do not cause JS traps.
      // If it can cause any JS interactions, we can call the caller JS function of this function and overwrite the
      // content of ScratchBuffer. If the IndexingType is now ArrayWithDouble, we can ensure
      // that there is no indexed accessors in this object and its prototype chain.
      ASSERT(array-&gt;indexingMode() == ArrayWithDouble);
  
      double* values = static_cast&lt;double*&gt;(buffer);
      for (int32_t i = 0; i &lt; elementCount; ++i) {
<span class="line-modified">!         array-&gt;pushInline(exec, JSValue(JSValue::EncodeAsDouble, values[i]));</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
      return JSValue::encode(jsNumber(array-&gt;length()));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationArrayPop(ExecState* exec, JSArray* array)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return JSValue::encode(array-&gt;pop(exec));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationArrayPopAndRecoverLength(ExecState* exec, JSArray* array)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      array-&gt;butterfly()-&gt;setPublicLength(array-&gt;butterfly()-&gt;publicLength() + 1);
  
<span class="line-modified">!     return JSValue::encode(array-&gt;pop(exec));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationRegExpExecString(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* argument)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return JSValue::encode(regExpObject-&gt;execInline(exec, globalObject, argument));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationRegExpExec(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, EncodedJSValue encodedArgument)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue argument = JSValue::decode(encodedArgument);
  
<span class="line-modified">!     JSString* input = argument.toStringOrNull(exec);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !input);
      if (!input)
          return encodedJSValue();
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(regExpObject-&gt;execInline(exec, globalObject, input)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationRegExpExecGeneric(ExecState* exec, JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedArgument)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue base = JSValue::decode(encodedBase);
      JSValue argument = JSValue::decode(encodedArgument);
  
      auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, base);
      if (UNLIKELY(!regexp))
<span class="line-modified">!         return throwVMTypeError(exec, scope);</span>
  
<span class="line-modified">!     JSString* input = argument.toStringOrNull(exec);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !input);
      if (!input)
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(regexp-&gt;exec(exec, globalObject, input)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationRegExpExecNonGlobalOrSticky(ExecState* exec, JSGlobalObject* globalObject, RegExp* regExp, JSString* string)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String input = string-&gt;value(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      unsigned lastIndex = 0;
      MatchResult result;
      JSArray* array = createRegExpMatchesArray(vm, globalObject, string, input, regExp, lastIndex, result);
<span class="line-modified">!     if (!array) {</span>
<span class="line-modified">!         ASSERT(!scope.exception());</span>
          return JSValue::encode(jsNull());
<span class="line-removed">-     }</span>
  
<span class="line-removed">-     RETURN_IF_EXCEPTION(scope, { });</span>
      globalObject-&gt;regExpGlobalData().recordMatch(vm, globalObject, regExp, string, result);
      return JSValue::encode(array);
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationRegExpMatchFastString(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* argument)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      if (!regExpObject-&gt;regExp()-&gt;global())
<span class="line-modified">!         return JSValue::encode(regExpObject-&gt;execInline(exec, globalObject, argument));</span>
<span class="line-modified">!     return JSValue::encode(regExpObject-&gt;matchGlobal(exec, globalObject, argument));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationRegExpMatchFastGlobalString(ExecState* exec, JSGlobalObject* globalObject, RegExp* regExp, JSString* string)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      ASSERT(regExp-&gt;global());
  
<span class="line-modified">!     String s = string-&gt;value(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      if (regExp-&gt;unicode()) {
          unsigned stringLength = s.length();
          RELEASE_AND_RETURN(scope, JSValue::encode(collectMatches(
<span class="line-modified">!             vm, exec, string, s, globalObject, regExp,</span>
              [&amp;] (size_t end) -&gt; size_t {
                  return advanceStringUnicode(s, stringLength, end);
              })));
      }
  
      RELEASE_AND_RETURN(scope, JSValue::encode(collectMatches(
<span class="line-modified">!         vm, exec, string, s, globalObject, regExp,</span>
          [&amp;] (size_t end) -&gt; size_t {
              return end + 1;
          })));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationParseIntNoRadixGeneric(ExecState* exec, EncodedJSValue value)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return toStringView(exec, JSValue::decode(value), [&amp;] (StringView view) {</span>
          // This version is as if radix was undefined. Hence, undefined.toNumber() === 0.
          return parseIntResult(parseInt(view, 0));
      });
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationParseIntStringNoRadix(ExecState* exec, JSString* string)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     auto viewWithString = string-&gt;viewWithUnderlyingString(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      // This version is as if radix was undefined. Hence, undefined.toNumber() === 0.
      return parseIntResult(parseInt(viewWithString.view, 0));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationParseIntString(ExecState* exec, JSString* string, int32_t radix)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     auto viewWithString = string-&gt;viewWithUnderlyingString(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      return parseIntResult(parseInt(viewWithString.view, radix));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationParseIntGeneric(ExecState* exec, EncodedJSValue value, int32_t radix)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return toStringView(exec, JSValue::decode(value), [&amp;] (StringView view) {</span>
          return parseIntResult(parseInt(view, radix));
      });
  }
  
<span class="line-modified">! size_t JIT_OPERATION operationRegExpTestString(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* input)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return regExpObject-&gt;testInline(exec, globalObject, input);</span>
  }
  
<span class="line-modified">! size_t JIT_OPERATION operationRegExpTest(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, EncodedJSValue encodedArgument)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSValue argument = JSValue::decode(encodedArgument);
  
<span class="line-modified">!     JSString* input = argument.toStringOrNull(exec);</span>
      if (!input)
          return false;
<span class="line-modified">!     return regExpObject-&gt;testInline(exec, globalObject, input);</span>
  }
  
<span class="line-modified">! size_t JIT_OPERATION operationRegExpTestGeneric(ExecState* exec, JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedArgument)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue base = JSValue::decode(encodedBase);
      JSValue argument = JSValue::decode(encodedArgument);
  
      auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, base);
      if (UNLIKELY(!regexp)) {
<span class="line-modified">!         throwTypeError(exec, scope);</span>
          return false;
      }
  
<span class="line-modified">!     JSString* input = argument.toStringOrNull(exec);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !input);
      if (!input)
          return false;
<span class="line-modified">!     RELEASE_AND_RETURN(scope, regexp-&gt;test(exec, globalObject, input));</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationSubBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
<span class="line-modified">!     return JSBigInt::sub(exec, leftOperand, rightOperand);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationBitNotBigInt(ExecState* exec, JSCell* op1)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSBigInt* operand = jsCast&lt;JSBigInt*&gt;(op1);
  
<span class="line-modified">!     return JSBigInt::bitwiseNot(exec, operand);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationMulBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
<span class="line-modified">!     return JSBigInt::multiply(exec, leftOperand, rightOperand);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationModBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
<span class="line-modified">!     return JSBigInt::remainder(exec, leftOperand, rightOperand);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationDivBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
<span class="line-modified">!     return JSBigInt::divide(exec, leftOperand, rightOperand);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationPowBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
<span class="line-modified">!     return JSBigInt::exponentiate(exec, leftOperand, rightOperand);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationBitAndBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
<span class="line-modified">!     return JSBigInt::bitwiseAnd(exec, leftOperand, rightOperand);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationBitLShiftBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
<span class="line-modified">!     return JSBigInt::leftShift(exec, leftOperand, rightOperand);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationAddBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
<span class="line-modified">!     return JSBigInt::add(exec, leftOperand, rightOperand);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationBitOrBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
<span class="line-modified">!     return JSBigInt::bitwiseOr(exec, leftOperand, rightOperand);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationBitXorBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
<span class="line-modified">!     return JSBigInt::bitwiseXor(exec, leftOperand, rightOperand);</span>
  }
  
<span class="line-modified">! size_t JIT_OPERATION operationCompareStrictEqCell(ExecState* exec, JSCell* op1, JSCell* op2)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return JSValue::strictEqualSlowCaseInline(exec, op1, op2);</span>
  }
  
<span class="line-modified">! size_t JIT_OPERATION operationSameValue(ExecState* exec, EncodedJSValue arg1, EncodedJSValue arg2)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return sameValue(exec, JSValue::decode(arg1), JSValue::decode(arg2));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationToPrimitive(ExecState* exec, EncodedJSValue value)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return JSValue::encode(JSValue::decode(value).toPrimitive(exec));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationToNumber(ExecState* exec, EncodedJSValue value)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return JSValue::encode(jsNumber(JSValue::decode(value).toNumber(exec)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationGetByValWithThis(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue baseValue = JSValue::decode(encodedBase);
      JSValue thisVal = JSValue::decode(encodedThis);
      JSValue subscript = JSValue::decode(encodedSubscript);
  
      if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
          Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
          if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">!             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(subscript)-&gt;toExistingAtomString(exec);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
              if (existingAtomString) {
                  if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))
                      return JSValue::encode(result);
              }
<span class="line-new-header">--- 1208,494 ---</span>
      // the IndexingType is ArrayWithSlowPutArrayStorage which could have an indexed accessor in a prototype chain.
      RELEASE_ASSERT(!shouldUseSlowPut(array-&gt;indexingType()));
  
      EncodedJSValue* values = static_cast&lt;EncodedJSValue*&gt;(buffer);
      for (int32_t i = 0; i &lt; elementCount; ++i) {
<span class="line-modified">!         array-&gt;pushInline(globalObject, JSValue::decode(values[i]));</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
      return JSValue::encode(jsNumber(array-&gt;length()));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationArrayPushDoubleMultiple(JSGlobalObject* globalObject, JSArray* array, void* buffer, int32_t elementCount)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // We assume that multiple JSArray::push calls with ArrayWithDouble do not cause JS traps.
      // If it can cause any JS interactions, we can call the caller JS function of this function and overwrite the
      // content of ScratchBuffer. If the IndexingType is now ArrayWithDouble, we can ensure
      // that there is no indexed accessors in this object and its prototype chain.
      ASSERT(array-&gt;indexingMode() == ArrayWithDouble);
  
      double* values = static_cast&lt;double*&gt;(buffer);
      for (int32_t i = 0; i &lt; elementCount; ++i) {
<span class="line-modified">!         array-&gt;pushInline(globalObject, JSValue(JSValue::EncodeAsDouble, values[i]));</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
      return JSValue::encode(jsNumber(array-&gt;length()));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationArrayPop(JSGlobalObject* globalObject, JSArray* array)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     return JSValue::encode(array-&gt;pop(globalObject));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationArrayPopAndRecoverLength(JSGlobalObject* globalObject, JSArray* array)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      array-&gt;butterfly()-&gt;setPublicLength(array-&gt;butterfly()-&gt;publicLength() + 1);
  
<span class="line-modified">!     return JSValue::encode(array-&gt;pop(globalObject));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationRegExpExecString(JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* argument)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     return JSValue::encode(regExpObject-&gt;execInline(globalObject, argument));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationRegExpExec(JSGlobalObject* globalObject, RegExpObject* regExpObject, EncodedJSValue encodedArgument)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue argument = JSValue::decode(encodedArgument);
  
<span class="line-modified">!     JSString* input = argument.toStringOrNull(globalObject);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !input);
      if (!input)
          return encodedJSValue();
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(regExpObject-&gt;execInline(globalObject, input)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationRegExpExecGeneric(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedArgument)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue base = JSValue::decode(encodedBase);
      JSValue argument = JSValue::decode(encodedArgument);
  
      auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, base);
      if (UNLIKELY(!regexp))
<span class="line-modified">!         return throwVMTypeError(globalObject, scope);</span>
  
<span class="line-modified">!     JSString* input = argument.toStringOrNull(globalObject);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !input);
      if (!input)
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(regexp-&gt;exec(globalObject, input)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationRegExpExecNonGlobalOrSticky(JSGlobalObject* globalObject, RegExp* regExp, JSString* string)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String input = string-&gt;value(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      unsigned lastIndex = 0;
      MatchResult result;
      JSArray* array = createRegExpMatchesArray(vm, globalObject, string, input, regExp, lastIndex, result);
<span class="line-modified">!     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-modified">!     if (!array)</span>
          return JSValue::encode(jsNull());
  
      globalObject-&gt;regExpGlobalData().recordMatch(vm, globalObject, regExp, string, result);
      return JSValue::encode(array);
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationRegExpMatchFastString(JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* argument)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      if (!regExpObject-&gt;regExp()-&gt;global())
<span class="line-modified">!         return JSValue::encode(regExpObject-&gt;execInline(globalObject, argument));</span>
<span class="line-modified">!     return JSValue::encode(regExpObject-&gt;matchGlobal(globalObject, argument));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationRegExpMatchFastGlobalString(JSGlobalObject* globalObject, RegExp* regExp, JSString* string)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      ASSERT(regExp-&gt;global());
  
<span class="line-modified">!     String s = string-&gt;value(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      if (regExp-&gt;unicode()) {
          unsigned stringLength = s.length();
          RELEASE_AND_RETURN(scope, JSValue::encode(collectMatches(
<span class="line-modified">!             vm, globalObject, string, s, regExp,</span>
              [&amp;] (size_t end) -&gt; size_t {
                  return advanceStringUnicode(s, stringLength, end);
              })));
      }
  
      RELEASE_AND_RETURN(scope, JSValue::encode(collectMatches(
<span class="line-modified">!         vm, globalObject, string, s, regExp,</span>
          [&amp;] (size_t end) -&gt; size_t {
              return end + 1;
          })));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationParseIntNoRadixGeneric(JSGlobalObject* globalObject, EncodedJSValue value)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     return toStringView(globalObject, JSValue::decode(value), [&amp;] (StringView view) {</span>
          // This version is as if radix was undefined. Hence, undefined.toNumber() === 0.
          return parseIntResult(parseInt(view, 0));
      });
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationParseIntStringNoRadix(JSGlobalObject* globalObject, JSString* string)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     auto viewWithString = string-&gt;viewWithUnderlyingString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      // This version is as if radix was undefined. Hence, undefined.toNumber() === 0.
      return parseIntResult(parseInt(viewWithString.view, 0));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationParseIntString(JSGlobalObject* globalObject, JSString* string, int32_t radix)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     auto viewWithString = string-&gt;viewWithUnderlyingString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      return parseIntResult(parseInt(viewWithString.view, radix));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationParseIntGeneric(JSGlobalObject* globalObject, EncodedJSValue value, int32_t radix)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     return toStringView(globalObject, JSValue::decode(value), [&amp;] (StringView view) {</span>
          return parseIntResult(parseInt(view, radix));
      });
  }
  
<span class="line-modified">! size_t JIT_OPERATION operationRegExpTestString(JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* input)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     return regExpObject-&gt;testInline(globalObject, input);</span>
  }
  
<span class="line-modified">! size_t JIT_OPERATION operationRegExpTest(JSGlobalObject* globalObject, RegExpObject* regExpObject, EncodedJSValue encodedArgument)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      JSValue argument = JSValue::decode(encodedArgument);
  
<span class="line-modified">!     JSString* input = argument.toStringOrNull(globalObject);</span>
      if (!input)
          return false;
<span class="line-modified">!     return regExpObject-&gt;testInline(globalObject, input);</span>
  }
  
<span class="line-modified">! size_t JIT_OPERATION operationRegExpTestGeneric(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedArgument)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue base = JSValue::decode(encodedBase);
      JSValue argument = JSValue::decode(encodedArgument);
  
      auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, base);
      if (UNLIKELY(!regexp)) {
<span class="line-modified">!         throwTypeError(globalObject, scope);</span>
          return false;
      }
  
<span class="line-modified">!     JSString* input = argument.toStringOrNull(globalObject);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !input);
      if (!input)
          return false;
<span class="line-modified">!     RELEASE_AND_RETURN(scope, regexp-&gt;test(globalObject, input));</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationSubBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
<span class="line-modified">!     return JSBigInt::sub(globalObject, leftOperand, rightOperand);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationBitNotBigInt(JSGlobalObject* globalObject, JSCell* op1)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      JSBigInt* operand = jsCast&lt;JSBigInt*&gt;(op1);
  
<span class="line-modified">!     return JSBigInt::bitwiseNot(globalObject, operand);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationMulBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
<span class="line-modified">!     return JSBigInt::multiply(globalObject, leftOperand, rightOperand);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationModBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
<span class="line-modified">!     return JSBigInt::remainder(globalObject, leftOperand, rightOperand);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationDivBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
<span class="line-modified">!     return JSBigInt::divide(globalObject, leftOperand, rightOperand);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationPowBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
<span class="line-modified">!     return JSBigInt::exponentiate(globalObject, leftOperand, rightOperand);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationBitAndBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
<span class="line-modified">!     return JSBigInt::bitwiseAnd(globalObject, leftOperand, rightOperand);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationBitLShiftBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
<span class="line-modified">!     return JSBigInt::leftShift(globalObject, leftOperand, rightOperand);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationAddBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
<span class="line-modified">!     return JSBigInt::add(globalObject, leftOperand, rightOperand);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationBitRShiftBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
<span class="line-modified">!     return JSBigInt::signedRightShift(globalObject, leftOperand, rightOperand);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationBitOrBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
<span class="line-modified">!     return JSBigInt::bitwiseOr(globalObject, leftOperand, rightOperand);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationBitXorBigInt(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);</span>
<span class="line-added">+     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);</span>
  
<span class="line-modified">!     return JSBigInt::bitwiseXor(globalObject, leftOperand, rightOperand);</span>
  }
  
<span class="line-modified">! size_t JIT_OPERATION operationCompareStrictEqCell(JSGlobalObject* globalObject, JSCell* op1, JSCell* op2)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return JSValue::strictEqualSlowCaseInline(globalObject, op1, op2);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ size_t JIT_OPERATION operationSameValue(JSGlobalObject* globalObject, EncodedJSValue arg1, EncodedJSValue arg2)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return sameValue(globalObject, JSValue::decode(arg1), JSValue::decode(arg2));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JIT_OPERATION operationToPrimitive(JSGlobalObject* globalObject, EncodedJSValue value)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return JSValue::encode(JSValue::decode(value).toPrimitive(globalObject));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JIT_OPERATION operationToPropertyKey(JSGlobalObject* globalObject, EncodedJSValue value)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     return JSValue::encode(JSValue::decode(value).toPropertyKeyValue(globalObject));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationToNumber(JSGlobalObject* globalObject, EncodedJSValue value)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     return JSValue::encode(jsNumber(JSValue::decode(value).toNumber(globalObject)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationToNumeric(JSGlobalObject* globalObject, EncodedJSValue value)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     auto variant = JSValue::decode(value).toNumeric(globalObject);</span>
<span class="line-added">+     if (WTF::holds_alternative&lt;JSBigInt*&gt;(variant))</span>
<span class="line-added">+         return JSValue::encode(WTF::get&lt;JSBigInt*&gt;(variant));</span>
<span class="line-added">+     return JSValue::encode(jsNumber(WTF::get&lt;double&gt;(variant)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationGetByValWithThis(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue baseValue = JSValue::decode(encodedBase);
      JSValue thisVal = JSValue::decode(encodedThis);
      JSValue subscript = JSValue::decode(encodedSubscript);
  
      if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
          Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
          if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">!             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(subscript)-&gt;toExistingAtomString(globalObject);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
              if (existingAtomString) {
                  if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))
                      return JSValue::encode(result);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1528,198 ***</span>
  
      PropertySlot slot(thisVal, PropertySlot::PropertySlot::InternalMethodType::Get);
      if (subscript.isUInt32()) {
          uint32_t i = subscript.asUInt32();
          if (isJSString(baseValue) &amp;&amp; asString(baseValue)-&gt;canGetIndex(i))
<span class="line-modified">!             return JSValue::encode(asString(baseValue)-&gt;getIndex(exec, i));</span>
  
<span class="line-modified">!         RELEASE_AND_RETURN(scope, JSValue::encode(baseValue.get(exec, i, slot)));</span>
      }
  
<span class="line-modified">!     baseValue.requireObjectCoercible(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     auto property = subscript.toPropertyKey(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(baseValue.get(exec, property, slot)));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByIdWithThisStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedValue, UniquedStringImpl* impl)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     putWithThis&lt;true&gt;(exec, encodedBase, encodedThis, encodedValue, Identifier::fromUid(vm, impl));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByIdWithThis(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedValue, UniquedStringImpl* impl)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     putWithThis&lt;false&gt;(exec, encodedBase, encodedThis, encodedValue, Identifier::fromUid(vm, impl));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValWithThisStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     Identifier property = JSValue::decode(encodedSubscript).toPropertyKey(exec);</span>
      RETURN_IF_EXCEPTION(scope, void());
      scope.release();
<span class="line-modified">!     putWithThis&lt;true&gt;(exec, encodedBase, encodedThis, encodedValue, property);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValWithThis(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     Identifier property = JSValue::decode(encodedSubscript).toPropertyKey(exec);</span>
      RETURN_IF_EXCEPTION(scope, void());
      scope.release();
<span class="line-modified">!     putWithThis&lt;false&gt;(exec, encodedBase, encodedThis, encodedValue, property);</span>
  }
  
<span class="line-modified">! ALWAYS_INLINE static void defineDataProperty(ExecState* exec, VM&amp; vm, JSObject* base, const Identifier&amp; propertyName, JSValue value, int32_t attributes)</span>
  {
      PropertyDescriptor descriptor = toPropertyDescriptor(value, jsUndefined(), jsUndefined(), DefinePropertyAttributes(attributes));
      ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
      if (base-&gt;methodTable(vm)-&gt;defineOwnProperty == JSObject::defineOwnProperty)
<span class="line-modified">!         JSObject::defineOwnProperty(base, exec, propertyName, descriptor, true);</span>
      else
<span class="line-modified">!         base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, exec, propertyName, descriptor, true);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationDefineDataProperty(ExecState* exec, JSObject* base, EncodedJSValue encodedProperty, EncodedJSValue encodedValue, int32_t attributes)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     Identifier propertyName = JSValue::decode(encodedProperty).toPropertyKey(exec);</span>
      RETURN_IF_EXCEPTION(scope, void());
      scope.release();
<span class="line-modified">!     defineDataProperty(exec, vm, base, propertyName, JSValue::decode(encodedValue), attributes);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationDefineDataPropertyString(ExecState* exec, JSObject* base, JSString* property, EncodedJSValue encodedValue, int32_t attributes)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     Identifier propertyName = property-&gt;toIdentifier(exec);</span>
      RETURN_IF_EXCEPTION(scope, void());
      scope.release();
<span class="line-modified">!     defineDataProperty(exec, vm, base, propertyName, JSValue::decode(encodedValue), attributes);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationDefineDataPropertyStringIdent(ExecState* exec, JSObject* base, UniquedStringImpl* property, EncodedJSValue encodedValue, int32_t attributes)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     defineDataProperty(exec, vm, base, Identifier::fromUid(vm, property), JSValue::decode(encodedValue), attributes);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationDefineDataPropertySymbol(ExecState* exec, JSObject* base, Symbol* property, EncodedJSValue encodedValue, int32_t attributes)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     defineDataProperty(exec, vm, base, Identifier::fromUid(property-&gt;privateName()), JSValue::decode(encodedValue), attributes);</span>
  }
  
<span class="line-modified">! ALWAYS_INLINE static void defineAccessorProperty(ExecState* exec, VM&amp; vm, JSObject* base, const Identifier&amp; propertyName, JSObject* getter, JSObject* setter, int32_t attributes)</span>
  {
      PropertyDescriptor descriptor = toPropertyDescriptor(jsUndefined(), getter, setter, DefinePropertyAttributes(attributes));
      ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
      if (base-&gt;methodTable(vm)-&gt;defineOwnProperty == JSObject::defineOwnProperty)
<span class="line-modified">!         JSObject::defineOwnProperty(base, exec, propertyName, descriptor, true);</span>
      else
<span class="line-modified">!         base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, exec, propertyName, descriptor, true);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationDefineAccessorProperty(ExecState* exec, JSObject* base, EncodedJSValue encodedProperty, JSObject* getter, JSObject* setter, int32_t attributes)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     Identifier propertyName = JSValue::decode(encodedProperty).toPropertyKey(exec);</span>
      RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">!     defineAccessorProperty(exec, vm, base, propertyName, getter, setter, attributes);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationDefineAccessorPropertyString(ExecState* exec, JSObject* base, JSString* property, JSObject* getter, JSObject* setter, int32_t attributes)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     Identifier propertyName = property-&gt;toIdentifier(exec);</span>
      RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">!     defineAccessorProperty(exec, vm, base, propertyName, getter, setter, attributes);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationDefineAccessorPropertyStringIdent(ExecState* exec, JSObject* base, UniquedStringImpl* property, JSObject* getter, JSObject* setter, int32_t attributes)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     defineAccessorProperty(exec, vm, base, Identifier::fromUid(vm, property), getter, setter, attributes);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationDefineAccessorPropertySymbol(ExecState* exec, JSObject* base, Symbol* property, JSObject* getter, JSObject* setter, int32_t attributes)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     defineAccessorProperty(exec, vm, base, Identifier::fromUid(property-&gt;privateName()), getter, setter, attributes);</span>
  }
  
<span class="line-modified">! char* JIT_OPERATION operationNewArray(ExecState* exec, Structure* arrayStructure, void* buffer, size_t size)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return bitwise_cast&lt;char*&gt;(constructArray(exec, arrayStructure, static_cast&lt;JSValue*&gt;(buffer), size));</span>
  }
  
<span class="line-modified">! char* JIT_OPERATION operationNewEmptyArray(ExecState* exec, Structure* arrayStructure)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return bitwise_cast&lt;char*&gt;(JSArray::create(vm, arrayStructure));
  }
  
<span class="line-modified">! char* JIT_OPERATION operationNewArrayWithSize(ExecState* exec, Structure* arrayStructure, int32_t size, Butterfly* butterfly)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (UNLIKELY(size &lt; 0))
<span class="line-modified">!         return bitwise_cast&lt;char*&gt;(throwException(exec, scope, createRangeError(exec, &quot;Array size is not a small enough positive integer.&quot;_s)));</span>
  
      JSArray* result;
      if (butterfly)
          result = JSArray::createWithButterfly(vm, nullptr, arrayStructure, butterfly);
      else
          result = JSArray::create(vm, arrayStructure, size);
      return bitwise_cast&lt;char*&gt;(result);
  }
  
<span class="line-modified">! char* JIT_OPERATION operationNewArrayWithSizeAndHint(ExecState* exec, Structure* arrayStructure, int32_t size, int32_t vectorLengthHint, Butterfly* butterfly)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (UNLIKELY(size &lt; 0))
<span class="line-modified">!         return bitwise_cast&lt;char*&gt;(throwException(exec, scope, createRangeError(exec, &quot;Array size is not a small enough positive integer.&quot;_s)));</span>
  
      JSArray* result;
      if (butterfly)
          result = JSArray::createWithButterfly(vm, nullptr, arrayStructure, butterfly);
      else {
<span class="line-new-header">--- 1704,214 ---</span>
  
      PropertySlot slot(thisVal, PropertySlot::PropertySlot::InternalMethodType::Get);
      if (subscript.isUInt32()) {
          uint32_t i = subscript.asUInt32();
          if (isJSString(baseValue) &amp;&amp; asString(baseValue)-&gt;canGetIndex(i))
<span class="line-modified">!             return JSValue::encode(asString(baseValue)-&gt;getIndex(globalObject, i));</span>
  
<span class="line-modified">!         RELEASE_AND_RETURN(scope, JSValue::encode(baseValue.get(globalObject, i, slot)));</span>
      }
  
<span class="line-modified">!     baseValue.requireObjectCoercible(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     auto property = subscript.toPropertyKey(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(baseValue.get(globalObject, property, slot)));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByIdWithThisStrict(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedValue, UniquedStringImpl* impl)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     putWithThis&lt;true&gt;(globalObject, encodedBase, encodedThis, encodedValue, Identifier::fromUid(vm, impl));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByIdWithThis(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedValue, UniquedStringImpl* impl)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     putWithThis&lt;false&gt;(globalObject, encodedBase, encodedThis, encodedValue, Identifier::fromUid(vm, impl));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValWithThisStrict(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     Identifier property = JSValue::decode(encodedSubscript).toPropertyKey(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, void());
      scope.release();
<span class="line-modified">!     putWithThis&lt;true&gt;(globalObject, encodedBase, encodedThis, encodedValue, property);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutByValWithThis(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     Identifier property = JSValue::decode(encodedSubscript).toPropertyKey(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, void());
      scope.release();
<span class="line-modified">!     putWithThis&lt;false&gt;(globalObject, encodedBase, encodedThis, encodedValue, property);</span>
  }
  
<span class="line-modified">! ALWAYS_INLINE static void defineDataProperty(JSGlobalObject* globalObject, VM&amp; vm, JSObject* base, const Identifier&amp; propertyName, JSValue value, int32_t attributes)</span>
  {
      PropertyDescriptor descriptor = toPropertyDescriptor(value, jsUndefined(), jsUndefined(), DefinePropertyAttributes(attributes));
      ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
      if (base-&gt;methodTable(vm)-&gt;defineOwnProperty == JSObject::defineOwnProperty)
<span class="line-modified">!         JSObject::defineOwnProperty(base, globalObject, propertyName, descriptor, true);</span>
      else
<span class="line-modified">!         base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, globalObject, propertyName, descriptor, true);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationDefineDataProperty(JSGlobalObject* globalObject, JSObject* base, EncodedJSValue encodedProperty, EncodedJSValue encodedValue, int32_t attributes)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     Identifier propertyName = JSValue::decode(encodedProperty).toPropertyKey(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, void());
      scope.release();
<span class="line-modified">!     defineDataProperty(globalObject, vm, base, propertyName, JSValue::decode(encodedValue), attributes);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationDefineDataPropertyString(JSGlobalObject* globalObject, JSObject* base, JSString* property, EncodedJSValue encodedValue, int32_t attributes)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     Identifier propertyName = property-&gt;toIdentifier(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, void());
      scope.release();
<span class="line-modified">!     defineDataProperty(globalObject, vm, base, propertyName, JSValue::decode(encodedValue), attributes);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationDefineDataPropertyStringIdent(JSGlobalObject* globalObject, JSObject* base, UniquedStringImpl* property, EncodedJSValue encodedValue, int32_t attributes)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     defineDataProperty(globalObject, vm, base, Identifier::fromUid(vm, property), JSValue::decode(encodedValue), attributes);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationDefineDataPropertySymbol(JSGlobalObject* globalObject, JSObject* base, Symbol* property, EncodedJSValue encodedValue, int32_t attributes)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     defineDataProperty(globalObject, vm, base, Identifier::fromUid(property-&gt;privateName()), JSValue::decode(encodedValue), attributes);</span>
  }
  
<span class="line-modified">! ALWAYS_INLINE static void defineAccessorProperty(JSGlobalObject* globalObject, VM&amp; vm, JSObject* base, const Identifier&amp; propertyName, JSObject* getter, JSObject* setter, int32_t attributes)</span>
  {
      PropertyDescriptor descriptor = toPropertyDescriptor(jsUndefined(), getter, setter, DefinePropertyAttributes(attributes));
      ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
      if (base-&gt;methodTable(vm)-&gt;defineOwnProperty == JSObject::defineOwnProperty)
<span class="line-modified">!         JSObject::defineOwnProperty(base, globalObject, propertyName, descriptor, true);</span>
      else
<span class="line-modified">!         base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, globalObject, propertyName, descriptor, true);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationDefineAccessorProperty(JSGlobalObject* globalObject, JSObject* base, EncodedJSValue encodedProperty, JSObject* getter, JSObject* setter, int32_t attributes)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     Identifier propertyName = JSValue::decode(encodedProperty).toPropertyKey(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">!     defineAccessorProperty(globalObject, vm, base, propertyName, getter, setter, attributes);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationDefineAccessorPropertyString(JSGlobalObject* globalObject, JSObject* base, JSString* property, JSObject* getter, JSObject* setter, int32_t attributes)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     Identifier propertyName = property-&gt;toIdentifier(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">!     defineAccessorProperty(globalObject, vm, base, propertyName, getter, setter, attributes);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationDefineAccessorPropertyStringIdent(JSGlobalObject* globalObject, JSObject* base, UniquedStringImpl* property, JSObject* getter, JSObject* setter, int32_t attributes)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     defineAccessorProperty(globalObject, vm, base, Identifier::fromUid(vm, property), getter, setter, attributes);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationDefineAccessorPropertySymbol(JSGlobalObject* globalObject, JSObject* base, Symbol* property, JSObject* getter, JSObject* setter, int32_t attributes)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     defineAccessorProperty(globalObject, vm, base, Identifier::fromUid(property-&gt;privateName()), getter, setter, attributes);</span>
  }
  
<span class="line-modified">! char* JIT_OPERATION operationNewArray(JSGlobalObject* globalObject, Structure* arrayStructure, void* buffer, size_t size)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     return bitwise_cast&lt;char*&gt;(constructArray(globalObject, arrayStructure, static_cast&lt;JSValue*&gt;(buffer), size));</span>
  }
  
<span class="line-modified">! char* JIT_OPERATION operationNewEmptyArray(VM* vmPointer, Structure* arrayStructure)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      return bitwise_cast&lt;char*&gt;(JSArray::create(vm, arrayStructure));
  }
  
<span class="line-modified">! char* JIT_OPERATION operationNewArrayWithSize(JSGlobalObject* globalObject, Structure* arrayStructure, int32_t size, Butterfly* butterfly)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (UNLIKELY(size &lt; 0))
<span class="line-modified">!         return bitwise_cast&lt;char*&gt;(throwException(globalObject, scope, createRangeError(globalObject, &quot;Array size is not a small enough positive integer.&quot;_s)));</span>
  
      JSArray* result;
      if (butterfly)
          result = JSArray::createWithButterfly(vm, nullptr, arrayStructure, butterfly);
      else
          result = JSArray::create(vm, arrayStructure, size);
      return bitwise_cast&lt;char*&gt;(result);
  }
  
<span class="line-modified">! char* JIT_OPERATION operationNewArrayWithSizeAndHint(JSGlobalObject* globalObject, Structure* arrayStructure, int32_t size, int32_t vectorLengthHint, Butterfly* butterfly)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (UNLIKELY(size &lt; 0))
<span class="line-modified">!         return bitwise_cast&lt;char*&gt;(throwException(globalObject, scope, createRangeError(globalObject, &quot;Array size is not a small enough positive integer.&quot;_s)));</span>
  
      JSArray* result;
      if (butterfly)
          result = JSArray::createWithButterfly(vm, nullptr, arrayStructure, butterfly);
      else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1727,771 ***</span>
          RELEASE_ASSERT(result);
      }
      return bitwise_cast&lt;char*&gt;(result);
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationNewArrayBuffer(ExecState* exec, Structure* arrayStructure, JSCell* immutableButterflyCell)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      ASSERT(!arrayStructure-&gt;outOfLineCapacity());
      auto* immutableButterfly = jsCast&lt;JSImmutableButterfly*&gt;(immutableButterflyCell);
      ASSERT(arrayStructure-&gt;indexingMode() == immutableButterfly-&gt;indexingMode() || hasAnyArrayStorage(arrayStructure-&gt;indexingMode()));
      auto* result = CommonSlowPaths::allocateNewArrayBuffer(vm, arrayStructure, immutableButterfly);
      ASSERT(result-&gt;indexingMode() == result-&gt;structure(vm)-&gt;indexingMode());
      ASSERT(result-&gt;structure(vm) == arrayStructure);
      return result;
  }
  
  char* JIT_OPERATION operationNewInt8ArrayWithSize(
<span class="line-modified">!     ExecState* exec, Structure* structure, int32_t length, char* vector)</span>
  {
<span class="line-modified">!     return newTypedArrayWithSize&lt;JSInt8Array&gt;(exec, structure, length, vector);</span>
  }
  
  char* JIT_OPERATION operationNewInt8ArrayWithOneArgument(
<span class="line-modified">!     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt8Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));</span>
  }
  
  char* JIT_OPERATION operationNewInt16ArrayWithSize(
<span class="line-modified">!     ExecState* exec, Structure* structure, int32_t length, char* vector)</span>
  {
<span class="line-modified">!     return newTypedArrayWithSize&lt;JSInt16Array&gt;(exec, structure, length, vector);</span>
  }
  
  char* JIT_OPERATION operationNewInt16ArrayWithOneArgument(
<span class="line-modified">!     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt16Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));</span>
  }
  
  char* JIT_OPERATION operationNewInt32ArrayWithSize(
<span class="line-modified">!     ExecState* exec, Structure* structure, int32_t length, char* vector)</span>
  {
<span class="line-modified">!     return newTypedArrayWithSize&lt;JSInt32Array&gt;(exec, structure, length, vector);</span>
  }
  
  char* JIT_OPERATION operationNewInt32ArrayWithOneArgument(
<span class="line-modified">!     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt32Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));</span>
  }
  
  char* JIT_OPERATION operationNewUint8ArrayWithSize(
<span class="line-modified">!     ExecState* exec, Structure* structure, int32_t length, char* vector)</span>
  {
<span class="line-modified">!     return newTypedArrayWithSize&lt;JSUint8Array&gt;(exec, structure, length, vector);</span>
  }
  
  char* JIT_OPERATION operationNewUint8ArrayWithOneArgument(
<span class="line-modified">!     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint8Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));</span>
  }
  
  char* JIT_OPERATION operationNewUint8ClampedArrayWithSize(
<span class="line-modified">!     ExecState* exec, Structure* structure, int32_t length, char* vector)</span>
  {
<span class="line-modified">!     return newTypedArrayWithSize&lt;JSUint8ClampedArray&gt;(exec, structure, length, vector);</span>
  }
  
  char* JIT_OPERATION operationNewUint8ClampedArrayWithOneArgument(
<span class="line-modified">!     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint8ClampedArray&gt;(exec, structure, encodedValue, 0, WTF::nullopt));</span>
  }
  
  char* JIT_OPERATION operationNewUint16ArrayWithSize(
<span class="line-modified">!     ExecState* exec, Structure* structure, int32_t length, char* vector)</span>
  {
<span class="line-modified">!     return newTypedArrayWithSize&lt;JSUint16Array&gt;(exec, structure, length, vector);</span>
  }
  
  char* JIT_OPERATION operationNewUint16ArrayWithOneArgument(
<span class="line-modified">!     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint16Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));</span>
  }
  
  char* JIT_OPERATION operationNewUint32ArrayWithSize(
<span class="line-modified">!     ExecState* exec, Structure* structure, int32_t length, char* vector)</span>
  {
<span class="line-modified">!     return newTypedArrayWithSize&lt;JSUint32Array&gt;(exec, structure, length, vector);</span>
  }
  
  char* JIT_OPERATION operationNewUint32ArrayWithOneArgument(
<span class="line-modified">!     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint32Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));</span>
  }
  
  char* JIT_OPERATION operationNewFloat32ArrayWithSize(
<span class="line-modified">!     ExecState* exec, Structure* structure, int32_t length, char* vector)</span>
  {
<span class="line-modified">!     return newTypedArrayWithSize&lt;JSFloat32Array&gt;(exec, structure, length, vector);</span>
  }
  
  char* JIT_OPERATION operationNewFloat32ArrayWithOneArgument(
<span class="line-modified">!     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSFloat32Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));</span>
  }
  
  char* JIT_OPERATION operationNewFloat64ArrayWithSize(
<span class="line-modified">!     ExecState* exec, Structure* structure, int32_t length, char* vector)</span>
  {
<span class="line-modified">!     return newTypedArrayWithSize&lt;JSFloat64Array&gt;(exec, structure, length, vector);</span>
  }
  
  char* JIT_OPERATION operationNewFloat64ArrayWithOneArgument(
<span class="line-modified">!     ExecState* exec, Structure* structure, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSFloat64Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationCreateActivationDirect(ExecState* exec, Structure* structure, JSScope* scope, SymbolTable* table, EncodedJSValue initialValueEncoded)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue initialValue = JSValue::decode(initialValueEncoded);
      ASSERT(initialValue == jsUndefined() || initialValue == jsTDZValue());
      return JSLexicalEnvironment::create(vm, structure, scope, table, initialValue);
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationCreateDirectArguments(ExecState* exec, Structure* structure, uint32_t length, uint32_t minCapacity)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      DirectArguments* result = DirectArguments::create(
          vm, structure, length, std::max(length, minCapacity));
      // The caller will store to this object without barriers. Most likely, at this point, this is
      // still a young object and so no barriers are needed. But it&#39;s good to be careful anyway,
      // since the GC should be allowed to do crazy (like pretenuring, for example).
      vm.heap.writeBarrier(result);
      return result;
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationCreateScopedArguments(ExecState* exec, Structure* structure, Register* argumentStart, uint32_t length, JSFunction* callee, JSLexicalEnvironment* scope)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      // We could pass the ScopedArgumentsTable* as an argument. We currently don&#39;t because I
      // didn&#39;t feel like changing the max number of arguments for a slow path call from 6 to 7.
      ScopedArgumentsTable* table = scope-&gt;symbolTable()-&gt;arguments();
  
      return ScopedArguments::createByCopyingFrom(
          vm, structure, argumentStart, length, callee, table, scope);
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationCreateClonedArguments(ExecState* exec, Structure* structure, Register* argumentStart, uint32_t length, JSFunction* callee)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      return ClonedArguments::createByCopyingFrom(
<span class="line-modified">!         exec, structure, argumentStart, length, callee);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationCreateDirectArgumentsDuringExit(ExecState* exec, InlineCallFrame* inlineCallFrame, JSFunction* callee, uint32_t argumentCount)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      DeferGCForAWhile deferGC(vm.heap);
  
      CodeBlock* codeBlock;
      if (inlineCallFrame)
          codeBlock = baselineCodeBlockForInlineCallFrame(inlineCallFrame);
      else
<span class="line-modified">!         codeBlock = exec-&gt;codeBlock();</span>
  
      unsigned length = argumentCount - 1;
      unsigned capacity = std::max(length, static_cast&lt;unsigned&gt;(codeBlock-&gt;numParameters() - 1));
      DirectArguments* result = DirectArguments::create(
          vm, codeBlock-&gt;globalObject()-&gt;directArgumentsStructure(), length, capacity);
  
      result-&gt;setCallee(vm, callee);
  
      Register* arguments =
<span class="line-modified">!         exec-&gt;registers() + (inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0) +</span>
          CallFrame::argumentOffset(0);
      for (unsigned i = length; i--;)
          result-&gt;setIndexQuickly(vm, i, arguments[i].jsValue());
  
      return result;
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationCreateClonedArgumentsDuringExit(ExecState* exec, InlineCallFrame* inlineCallFrame, JSFunction* callee, uint32_t argumentCount)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      DeferGCForAWhile deferGC(vm.heap);
  
      CodeBlock* codeBlock;
      if (inlineCallFrame)
          codeBlock = baselineCodeBlockForInlineCallFrame(inlineCallFrame);
      else
<span class="line-modified">!         codeBlock = exec-&gt;codeBlock();</span>
  
      unsigned length = argumentCount - 1;
      ClonedArguments* result = ClonedArguments::createEmpty(
<span class="line-modified">!         vm, codeBlock-&gt;globalObject()-&gt;clonedArgumentsStructure(), callee, length);</span>
  
      Register* arguments =
<span class="line-modified">!         exec-&gt;registers() + (inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0) +</span>
          CallFrame::argumentOffset(0);
      for (unsigned i = length; i--;)
<span class="line-modified">!         result-&gt;putDirectIndex(exec, i, arguments[i].jsValue());</span>
  
  
      return result;
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationCreateRest(ExecState* exec, Register* argumentStart, unsigned numberOfParamsToSkip, unsigned arraySize)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-removed">-     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
      Structure* structure = globalObject-&gt;restParameterStructure();
      static_assert(sizeof(Register) == sizeof(JSValue), &quot;This is a strong assumption here.&quot;);
      JSValue* argumentsToCopyRegion = bitwise_cast&lt;JSValue*&gt;(argumentStart) + numberOfParamsToSkip;
<span class="line-modified">!     return constructArray(exec, structure, argumentsToCopyRegion, arraySize);</span>
  }
  
<span class="line-modified">! size_t JIT_OPERATION operationObjectIsObject(ExecState* exec, JSGlobalObject* globalObject, JSCell* object)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
  
      if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
          return false;
      if (object-&gt;isFunction(vm))
          return false;
      return true;
  }
  
<span class="line-modified">! size_t JIT_OPERATION operationObjectIsFunction(ExecState* exec, JSGlobalObject* globalObject, JSCell* object)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
  
      if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
          return false;
      if (object-&gt;isFunction(vm))
          return true;
      return false;
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationTypeOfObject(ExecState* exec, JSGlobalObject* globalObject, JSCell* object)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
  
      if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
          return vm.smallStrings.undefinedString();
      if (object-&gt;isFunction(vm))
          return vm.smallStrings.functionString();
      return vm.smallStrings.objectString();
  }
  
<span class="line-modified">! int32_t JIT_OPERATION operationTypeOfObjectAsTypeofType(ExecState* exec, JSGlobalObject* globalObject, JSCell* object)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
  
      if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
          return static_cast&lt;int32_t&gt;(TypeofType::Undefined);
      if (object-&gt;isFunction(vm))
          return static_cast&lt;int32_t&gt;(TypeofType::Function);
      return static_cast&lt;int32_t&gt;(TypeofType::Object);
  }
  
<span class="line-modified">! char* JIT_OPERATION operationAllocateSimplePropertyStorageWithInitialCapacity(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return reinterpret_cast&lt;char*&gt;(
          Butterfly::createUninitialized(vm, 0, 0, initialOutOfLineCapacity, false, 0));
  }
  
<span class="line-modified">! char* JIT_OPERATION operationAllocateSimplePropertyStorage(ExecState* exec, size_t newSize)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return reinterpret_cast&lt;char*&gt;(
          Butterfly::createUninitialized(vm, 0, 0, newSize, false, 0));
  }
  
<span class="line-modified">! char* JIT_OPERATION operationAllocateComplexPropertyStorageWithInitialCapacity(ExecState* exec, JSObject* object)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      ASSERT(!object-&gt;structure(vm)-&gt;outOfLineCapacity());
      return reinterpret_cast&lt;char*&gt;(
          object-&gt;allocateMoreOutOfLineStorage(vm, 0, initialOutOfLineCapacity));
  }
  
<span class="line-modified">! char* JIT_OPERATION operationAllocateComplexPropertyStorage(ExecState* exec, JSObject* object, size_t newSize)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return reinterpret_cast&lt;char*&gt;(
          object-&gt;allocateMoreOutOfLineStorage(vm, object-&gt;structure(vm)-&gt;outOfLineCapacity(), newSize));
  }
  
<span class="line-modified">! char* JIT_OPERATION operationEnsureInt32(ExecState* exec, JSCell* cell)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      if (!cell-&gt;isObject())
          return 0;
  
      auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableInt32(vm).data());
      ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasInt32(cell-&gt;indexingMode())) || !result);
      return result;
  }
  
<span class="line-modified">! char* JIT_OPERATION operationEnsureDouble(ExecState* exec, JSCell* cell)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      if (!cell-&gt;isObject())
          return 0;
  
      auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableDouble(vm).data());
      ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasDouble(cell-&gt;indexingMode())) || !result);
      return result;
  }
  
<span class="line-modified">! char* JIT_OPERATION operationEnsureContiguous(ExecState* exec, JSCell* cell)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      if (!cell-&gt;isObject())
          return 0;
  
      auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableContiguous(vm).data());
      ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasContiguous(cell-&gt;indexingMode())) || !result);
      return result;
  }
  
<span class="line-modified">! char* JIT_OPERATION operationEnsureArrayStorage(ExecState* exec, JSCell* cell)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      if (!cell-&gt;isObject())
          return 0;
  
      auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;ensureArrayStorage(vm));
      ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasAnyArrayStorage(cell-&gt;indexingMode())) || !result);
      return result;
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationHasGenericProperty(ExecState* exec, EncodedJSValue encodedBaseValue, JSCell* property)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue baseValue = JSValue::decode(encodedBaseValue);
      if (baseValue.isUndefinedOrNull())
          return JSValue::encode(jsBoolean(false));
  
<span class="line-modified">!     JSObject* base = baseValue.toObject(exec);</span>
<span class="line-modified">!     ASSERT(!scope.exception() || !base);</span>
      if (!base)
          return JSValue::encode(JSValue());
<span class="line-modified">!     auto propertyName = asString(property)-&gt;toIdentifier(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(jsBoolean(base-&gt;hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::GetOwnProperty))));</span>
  }
  
<span class="line-modified">! size_t JIT_OPERATION operationHasIndexedPropertyByInt(ExecState* exec, JSCell* baseCell, int32_t subscript, int32_t internalMethodType)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     JSObject* object = baseCell-&gt;toObject(exec, exec-&gt;lexicalGlobalObject());</span>
      if (UNLIKELY(subscript &lt; 0)) {
          // Go the slowest way possible because negative indices don&#39;t use indexed storage.
<span class="line-modified">!         return object-&gt;hasPropertyGeneric(exec, Identifier::from(vm, subscript), static_cast&lt;PropertySlot::InternalMethodType&gt;(internalMethodType));</span>
      }
<span class="line-modified">!     return object-&gt;hasPropertyGeneric(exec, subscript, static_cast&lt;PropertySlot::InternalMethodType&gt;(internalMethodType));</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationGetPropertyEnumerator(ExecState* exec, EncodedJSValue encodedBase)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue base = JSValue::decode(encodedBase);
      if (base.isUndefinedOrNull())
          return vm.emptyPropertyNameEnumerator();
  
<span class="line-modified">!     JSObject* baseObject = base.toObject(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, propertyNameEnumerator(exec, baseObject));</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationGetPropertyEnumeratorCell(ExecState* exec, JSCell* cell)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* base = cell-&gt;toObject(exec, exec-&gt;lexicalGlobalObject());</span>
      RETURN_IF_EXCEPTION(scope, { });
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, propertyNameEnumerator(exec, base));</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationToIndexString(ExecState* exec, int32_t index)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      return jsString(vm, Identifier::from(vm, index).string());
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationNewRegexpWithLastIndex(ExecState* exec, JSCell* regexpPtr, EncodedJSValue encodedLastIndex)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      RegExp* regexp = static_cast&lt;RegExp*&gt;(regexpPtr);
      ASSERT(regexp-&gt;isValid());
<span class="line-modified">!     return RegExpObject::create(vm, exec-&gt;lexicalGlobalObject()-&gt;regExpStructure(), regexp, JSValue::decode(encodedLastIndex));</span>
  }
  
<span class="line-modified">! StringImpl* JIT_OPERATION operationResolveRope(ExecState* exec, JSString* string)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return string-&gt;value(exec).impl();</span>
  }
  
<span class="line-modified">! JSString* JIT_OPERATION operationStringValueOf(ExecState* exec, EncodedJSValue encodedArgument)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue argument = JSValue::decode(encodedArgument);
  
      if (argument.isString())
          return asString(argument);
  
      if (auto* stringObject = jsDynamicCast&lt;StringObject*&gt;(vm, argument))
          return stringObject-&gt;internalValue();
  
<span class="line-modified">!     throwVMTypeError(exec, scope);</span>
      return nullptr;
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationStringSubstr(ExecState* exec, JSCell* cell, int32_t from, int32_t span)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return jsSubstring(vm, exec, jsCast&lt;JSString*&gt;(cell), from, span);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationStringSlice(ExecState* exec, JSCell* cell, int32_t start, int32_t end)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSString* string = asString(cell);
      static_assert(static_cast&lt;uint64_t&gt;(JSString::MaxLength) &lt;= static_cast&lt;uint64_t&gt;(std::numeric_limits&lt;int32_t&gt;::max()), &quot;&quot;);
<span class="line-modified">!     return stringSlice(exec, vm, string, string-&gt;length(), start, end);</span>
  }
  
<span class="line-modified">! JSString* JIT_OPERATION operationToLowerCase(ExecState* exec, JSString* string, uint32_t failingIndex)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     const String&amp; inputString = string-&gt;value(exec);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (!inputString.length())
          return vm.smallStrings.emptyString();
  
      String lowercasedString = inputString.is8Bit() ? inputString.convertToLowercaseWithoutLocaleStartingAtFailingIndex8Bit(failingIndex) : inputString.convertToLowercaseWithoutLocale();
      if (lowercasedString.impl() == inputString.impl())
          return string;
      RELEASE_AND_RETURN(scope, jsString(vm, lowercasedString));
  }
  
<span class="line-modified">! char* JIT_OPERATION operationInt32ToString(ExecState* exec, int32_t value, int32_t radix)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (radix &lt; 2 || radix &gt; 36) {
<span class="line-modified">!         throwVMError(exec, scope, createRangeError(exec, &quot;toString() radix argument must be between 2 and 36&quot;_s));</span>
          return nullptr;
      }
  
      return reinterpret_cast&lt;char*&gt;(int32ToString(vm, value, radix));
  }
  
<span class="line-modified">! char* JIT_OPERATION operationInt52ToString(ExecState* exec, int64_t value, int32_t radix)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (radix &lt; 2 || radix &gt; 36) {
<span class="line-modified">!         throwVMError(exec, scope, createRangeError(exec, &quot;toString() radix argument must be between 2 and 36&quot;_s));</span>
          return nullptr;
      }
  
      return reinterpret_cast&lt;char*&gt;(int52ToString(vm, value, radix));
  }
  
<span class="line-modified">! char* JIT_OPERATION operationDoubleToString(ExecState* exec, double value, int32_t radix)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (radix &lt; 2 || radix &gt; 36) {
<span class="line-modified">!         throwVMError(exec, scope, createRangeError(exec, &quot;toString() radix argument must be between 2 and 36&quot;_s));</span>
          return nullptr;
      }
  
      return reinterpret_cast&lt;char*&gt;(numberToString(vm, value, radix));
  }
  
<span class="line-modified">! char* JIT_OPERATION operationInt32ToStringWithValidRadix(ExecState* exec, int32_t value, int32_t radix)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return reinterpret_cast&lt;char*&gt;(int32ToString(vm, value, radix));
  }
  
<span class="line-modified">! char* JIT_OPERATION operationInt52ToStringWithValidRadix(ExecState* exec, int64_t value, int32_t radix)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return reinterpret_cast&lt;char*&gt;(int52ToString(vm, value, radix));
  }
  
<span class="line-modified">! char* JIT_OPERATION operationDoubleToStringWithValidRadix(ExecState* exec, double value, int32_t radix)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return reinterpret_cast&lt;char*&gt;(numberToString(vm, value, radix));
  }
  
<span class="line-modified">! JSString* JIT_OPERATION operationSingleCharacterString(ExecState* exec, int32_t character)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return jsSingleCharacterString(vm, static_cast&lt;UChar&gt;(character));
  }
  
<span class="line-modified">! Symbol* JIT_OPERATION operationNewSymbol(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return Symbol::create(vm);
  }
  
<span class="line-modified">! Symbol* JIT_OPERATION operationNewSymbolWithDescription(ExecState* exec, JSString* description)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String string = description-&gt;value(exec);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      return Symbol::createWithDescription(vm, string);
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationNewStringObject(ExecState* exec, JSString* string, Structure* structure)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return StringObject::create(vm, structure, string);
  }
  
<span class="line-modified">! JSString* JIT_OPERATION operationToStringOnCell(ExecState* exec, JSCell* cell)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return JSValue(cell).toString(exec);</span>
  }
  
<span class="line-modified">! JSString* JIT_OPERATION operationToString(ExecState* exec, EncodedJSValue value)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return JSValue::decode(value).toString(exec);</span>
  }
  
<span class="line-modified">! JSString* JIT_OPERATION operationCallStringConstructorOnCell(ExecState* exec, JSCell* cell)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return stringConstructor(exec, cell);</span>
  }
  
<span class="line-modified">! JSString* JIT_OPERATION operationCallStringConstructor(ExecState* exec, EncodedJSValue value)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return stringConstructor(exec, JSValue::decode(value));</span>
  }
  
<span class="line-modified">! JSString* JIT_OPERATION operationMakeRope2(ExecState* exec, JSString* left, JSString* right)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return jsString(exec, left, right);</span>
  }
  
<span class="line-modified">! JSString* JIT_OPERATION operationMakeRope3(ExecState* exec, JSString* a, JSString* b, JSString* c)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return jsString(exec, a, b, c);</span>
  }
  
<span class="line-modified">! JSString* JIT_OPERATION operationStrCat2(ExecState* exec, EncodedJSValue a, EncodedJSValue b)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      ASSERT(!JSValue::decode(a).isSymbol());
      ASSERT(!JSValue::decode(b).isSymbol());
<span class="line-modified">!     JSString* str1 = JSValue::decode(a).toString(exec);</span>
      scope.assertNoException(); // Impossible, since we must have been given non-Symbol primitives.
<span class="line-modified">!     JSString* str2 = JSValue::decode(b).toString(exec);</span>
      scope.assertNoException();
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, jsString(exec, str1, str2));</span>
  }
  
<span class="line-modified">! JSString* JIT_OPERATION operationStrCat3(ExecState* exec, EncodedJSValue a, EncodedJSValue b, EncodedJSValue c)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      ASSERT(!JSValue::decode(a).isSymbol());
      ASSERT(!JSValue::decode(b).isSymbol());
      ASSERT(!JSValue::decode(c).isSymbol());
<span class="line-modified">!     JSString* str1 = JSValue::decode(a).toString(exec);</span>
      scope.assertNoException(); // Impossible, since we must have been given non-Symbol primitives.
<span class="line-modified">!     JSString* str2 = JSValue::decode(b).toString(exec);</span>
      scope.assertNoException();
<span class="line-modified">!     JSString* str3 = JSValue::decode(c).toString(exec);</span>
      scope.assertNoException();
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, jsString(exec, str1, str2, str3));</span>
  }
  
<span class="line-modified">! char* JIT_OPERATION operationFindSwitchImmTargetForDouble(</span>
<span class="line-removed">-     ExecState* exec, EncodedJSValue encodedValue, size_t tableIndex)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
      SimpleJumpTable&amp; table = codeBlock-&gt;switchJumpTable(tableIndex);
      JSValue value = JSValue::decode(encodedValue);
      ASSERT(value.isDouble());
      double asDouble = value.asDouble();
      int32_t asInt32 = static_cast&lt;int32_t&gt;(asDouble);
      if (asDouble == asInt32)
          return table.ctiForValue(asInt32).executableAddress&lt;char*&gt;();
      return table.ctiDefault.executableAddress&lt;char*&gt;();
  }
  
<span class="line-modified">! char* JIT_OPERATION operationSwitchString(ExecState* exec, size_t tableIndex, JSString* string)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     StringImpl* strImpl = string-&gt;value(exec).impl();</span>
  
      RETURN_IF_EXCEPTION(throwScope, nullptr);
  
<span class="line-modified">!     return exec-&gt;codeBlock()-&gt;stringSwitchJumpTable(tableIndex).ctiForValue(strImpl).executableAddress&lt;char*&gt;();</span>
  }
  
<span class="line-modified">! int32_t JIT_OPERATION operationSwitchStringAndGetBranchOffset(ExecState* exec, size_t tableIndex, JSString* string)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     StringImpl* strImpl = string-&gt;value(exec).impl();</span>
  
      RETURN_IF_EXCEPTION(throwScope, 0);
  
<span class="line-modified">!     return exec-&gt;codeBlock()-&gt;stringSwitchJumpTable(tableIndex).offsetForValue(strImpl, std::numeric_limits&lt;int32_t&gt;::min());</span>
  }
  
  uintptr_t JIT_OPERATION operationCompareStringImplLess(StringImpl* a, StringImpl* b)
  {
      return codePointCompare(a, b) &lt; 0;
<span class="line-new-header">--- 1919,884 ---</span>
          RELEASE_ASSERT(result);
      }
      return bitwise_cast&lt;char*&gt;(result);
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationNewArrayBuffer(VM* vmPointer, Structure* arrayStructure, JSCell* immutableButterflyCell)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      ASSERT(!arrayStructure-&gt;outOfLineCapacity());
      auto* immutableButterfly = jsCast&lt;JSImmutableButterfly*&gt;(immutableButterflyCell);
      ASSERT(arrayStructure-&gt;indexingMode() == immutableButterfly-&gt;indexingMode() || hasAnyArrayStorage(arrayStructure-&gt;indexingMode()));
      auto* result = CommonSlowPaths::allocateNewArrayBuffer(vm, arrayStructure, immutableButterfly);
      ASSERT(result-&gt;indexingMode() == result-&gt;structure(vm)-&gt;indexingMode());
      ASSERT(result-&gt;structure(vm) == arrayStructure);
      return result;
  }
  
  char* JIT_OPERATION operationNewInt8ArrayWithSize(
<span class="line-modified">!     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     return newTypedArrayWithSize&lt;JSInt8Array&gt;(globalObject, vm, structure, length, vector);</span>
  }
  
  char* JIT_OPERATION operationNewInt8ArrayWithOneArgument(
<span class="line-modified">!     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt8Array&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));</span>
  }
  
  char* JIT_OPERATION operationNewInt16ArrayWithSize(
<span class="line-modified">!     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     return newTypedArrayWithSize&lt;JSInt16Array&gt;(globalObject, vm, structure, length, vector);</span>
  }
  
  char* JIT_OPERATION operationNewInt16ArrayWithOneArgument(
<span class="line-modified">!     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt16Array&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));</span>
  }
  
  char* JIT_OPERATION operationNewInt32ArrayWithSize(
<span class="line-modified">!     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     return newTypedArrayWithSize&lt;JSInt32Array&gt;(globalObject, vm, structure, length, vector);</span>
  }
  
  char* JIT_OPERATION operationNewInt32ArrayWithOneArgument(
<span class="line-modified">!     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt32Array&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));</span>
  }
  
  char* JIT_OPERATION operationNewUint8ArrayWithSize(
<span class="line-modified">!     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     return newTypedArrayWithSize&lt;JSUint8Array&gt;(globalObject, vm, structure, length, vector);</span>
  }
  
  char* JIT_OPERATION operationNewUint8ArrayWithOneArgument(
<span class="line-modified">!     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint8Array&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));</span>
  }
  
  char* JIT_OPERATION operationNewUint8ClampedArrayWithSize(
<span class="line-modified">!     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     return newTypedArrayWithSize&lt;JSUint8ClampedArray&gt;(globalObject, vm, structure, length, vector);</span>
  }
  
  char* JIT_OPERATION operationNewUint8ClampedArrayWithOneArgument(
<span class="line-modified">!     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint8ClampedArray&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));</span>
  }
  
  char* JIT_OPERATION operationNewUint16ArrayWithSize(
<span class="line-modified">!     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     return newTypedArrayWithSize&lt;JSUint16Array&gt;(globalObject, vm, structure, length, vector);</span>
  }
  
  char* JIT_OPERATION operationNewUint16ArrayWithOneArgument(
<span class="line-modified">!     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint16Array&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));</span>
  }
  
  char* JIT_OPERATION operationNewUint32ArrayWithSize(
<span class="line-modified">!     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     return newTypedArrayWithSize&lt;JSUint32Array&gt;(globalObject, vm, structure, length, vector);</span>
  }
  
  char* JIT_OPERATION operationNewUint32ArrayWithOneArgument(
<span class="line-modified">!     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint32Array&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));</span>
  }
  
  char* JIT_OPERATION operationNewFloat32ArrayWithSize(
<span class="line-modified">!     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     return newTypedArrayWithSize&lt;JSFloat32Array&gt;(globalObject, vm, structure, length, vector);</span>
  }
  
  char* JIT_OPERATION operationNewFloat32ArrayWithOneArgument(
<span class="line-modified">!     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSFloat32Array&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));</span>
  }
  
  char* JIT_OPERATION operationNewFloat64ArrayWithSize(
<span class="line-modified">!     JSGlobalObject* globalObject, Structure* structure, int32_t length, char* vector)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     return newTypedArrayWithSize&lt;JSFloat64Array&gt;(globalObject, vm, structure, length, vector);</span>
  }
  
  char* JIT_OPERATION operationNewFloat64ArrayWithOneArgument(
<span class="line-modified">!     JSGlobalObject* globalObject, Structure* structure, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSFloat64Array&gt;(globalObject, structure, encodedValue, 0, WTF::nullopt));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JSCell* JIT_OPERATION operationNewArrayIterator(VM* vmPointer, Structure* structure)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = *vmPointer;</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return JSArrayIterator::createWithInitialValues(vm, structure);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationCreateActivationDirect(VM* vmPointer, Structure* structure, JSScope* scope, SymbolTable* table, EncodedJSValue initialValueEncoded)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      JSValue initialValue = JSValue::decode(initialValueEncoded);
      ASSERT(initialValue == jsUndefined() || initialValue == jsTDZValue());
      return JSLexicalEnvironment::create(vm, structure, scope, table, initialValue);
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationCreateDirectArguments(VM* vmPointer, Structure* structure, uint32_t length, uint32_t minCapacity)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      DirectArguments* result = DirectArguments::create(
          vm, structure, length, std::max(length, minCapacity));
      // The caller will store to this object without barriers. Most likely, at this point, this is
      // still a young object and so no barriers are needed. But it&#39;s good to be careful anyway,
      // since the GC should be allowed to do crazy (like pretenuring, for example).
      vm.heap.writeBarrier(result);
      return result;
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationCreateScopedArguments(JSGlobalObject* globalObject, Structure* structure, Register* argumentStart, uint32_t length, JSFunction* callee, JSLexicalEnvironment* scope)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      // We could pass the ScopedArgumentsTable* as an argument. We currently don&#39;t because I
      // didn&#39;t feel like changing the max number of arguments for a slow path call from 6 to 7.
      ScopedArgumentsTable* table = scope-&gt;symbolTable()-&gt;arguments();
  
      return ScopedArguments::createByCopyingFrom(
          vm, structure, argumentStart, length, callee, table, scope);
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationCreateClonedArguments(JSGlobalObject* globalObject, Structure* structure, Register* argumentStart, uint32_t length, JSFunction* callee)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      return ClonedArguments::createByCopyingFrom(
<span class="line-modified">!         globalObject, structure, argumentStart, length, callee);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationCreateArgumentsButterfly(JSGlobalObject* globalObject, Register* argumentStart, uint32_t argumentCount)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSImmutableButterfly* butterfly = JSImmutableButterfly::tryCreate(vm, vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get(), argumentCount);</span>
<span class="line-added">+     if (!butterfly) {</span>
<span class="line-added">+         throwOutOfMemoryError(globalObject, scope);</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     for (unsigned index = 0; index &lt; argumentCount; ++index)</span>
<span class="line-added">+         butterfly-&gt;setIndex(vm, index, argumentStart[index].jsValue());</span>
<span class="line-added">+     return butterfly;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JSCell* JIT_OPERATION operationCreateDirectArgumentsDuringExit(VM* vmPointer, InlineCallFrame* inlineCallFrame, JSFunction* callee, uint32_t argumentCount)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = *vmPointer;</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      DeferGCForAWhile deferGC(vm.heap);
  
      CodeBlock* codeBlock;
      if (inlineCallFrame)
          codeBlock = baselineCodeBlockForInlineCallFrame(inlineCallFrame);
      else
<span class="line-modified">!         codeBlock = callFrame-&gt;codeBlock();</span>
  
      unsigned length = argumentCount - 1;
      unsigned capacity = std::max(length, static_cast&lt;unsigned&gt;(codeBlock-&gt;numParameters() - 1));
      DirectArguments* result = DirectArguments::create(
          vm, codeBlock-&gt;globalObject()-&gt;directArgumentsStructure(), length, capacity);
  
      result-&gt;setCallee(vm, callee);
  
      Register* arguments =
<span class="line-modified">!         callFrame-&gt;registers() + (inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0) +</span>
          CallFrame::argumentOffset(0);
      for (unsigned i = length; i--;)
          result-&gt;setIndexQuickly(vm, i, arguments[i].jsValue());
  
      return result;
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationCreateClonedArgumentsDuringExit(VM* vmPointer, InlineCallFrame* inlineCallFrame, JSFunction* callee, uint32_t argumentCount)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      DeferGCForAWhile deferGC(vm.heap);
  
      CodeBlock* codeBlock;
      if (inlineCallFrame)
          codeBlock = baselineCodeBlockForInlineCallFrame(inlineCallFrame);
      else
<span class="line-modified">!         codeBlock = callFrame-&gt;codeBlock();</span>
  
      unsigned length = argumentCount - 1;
<span class="line-added">+     JSGlobalObject* globalObject = codeBlock-&gt;globalObject();</span>
      ClonedArguments* result = ClonedArguments::createEmpty(
<span class="line-modified">!         vm, globalObject-&gt;clonedArgumentsStructure(), callee, length);</span>
  
      Register* arguments =
<span class="line-modified">!         callFrame-&gt;registers() + (inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0) +</span>
          CallFrame::argumentOffset(0);
      for (unsigned i = length; i--;)
<span class="line-modified">!         result-&gt;putDirectIndex(globalObject, i, arguments[i].jsValue());</span>
  
  
      return result;
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationCreateRest(JSGlobalObject* globalObject, Register* argumentStart, unsigned numberOfParamsToSkip, unsigned arraySize)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      Structure* structure = globalObject-&gt;restParameterStructure();
      static_assert(sizeof(Register) == sizeof(JSValue), &quot;This is a strong assumption here.&quot;);
      JSValue* argumentsToCopyRegion = bitwise_cast&lt;JSValue*&gt;(argumentStart) + numberOfParamsToSkip;
<span class="line-modified">!     return constructArray(globalObject, structure, argumentsToCopyRegion, arraySize);</span>
  }
  
<span class="line-modified">! size_t JIT_OPERATION operationObjectIsObject(JSGlobalObject* globalObject, JSCell* object)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
  
      if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
          return false;
      if (object-&gt;isFunction(vm))
          return false;
      return true;
  }
  
<span class="line-modified">! size_t JIT_OPERATION operationObjectIsFunction(JSGlobalObject* globalObject, JSCell* object)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
  
      if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
          return false;
      if (object-&gt;isFunction(vm))
          return true;
      return false;
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationTypeOfObject(JSGlobalObject* globalObject, JSCell* object)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
  
      if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
          return vm.smallStrings.undefinedString();
      if (object-&gt;isFunction(vm))
          return vm.smallStrings.functionString();
      return vm.smallStrings.objectString();
  }
  
<span class="line-modified">! int32_t JIT_OPERATION operationTypeOfObjectAsTypeofType(JSGlobalObject* globalObject, JSCell* object)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
  
      if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
          return static_cast&lt;int32_t&gt;(TypeofType::Undefined);
      if (object-&gt;isFunction(vm))
          return static_cast&lt;int32_t&gt;(TypeofType::Function);
      return static_cast&lt;int32_t&gt;(TypeofType::Object);
  }
  
<span class="line-modified">! char* JIT_OPERATION operationAllocateSimplePropertyStorageWithInitialCapacity(VM* vmPointer)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      return reinterpret_cast&lt;char*&gt;(
          Butterfly::createUninitialized(vm, 0, 0, initialOutOfLineCapacity, false, 0));
  }
  
<span class="line-modified">! char* JIT_OPERATION operationAllocateSimplePropertyStorage(VM* vmPointer, size_t newSize)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      return reinterpret_cast&lt;char*&gt;(
          Butterfly::createUninitialized(vm, 0, 0, newSize, false, 0));
  }
  
<span class="line-modified">! char* JIT_OPERATION operationAllocateComplexPropertyStorageWithInitialCapacity(VM* vmPointer, JSObject* object)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      ASSERT(!object-&gt;structure(vm)-&gt;outOfLineCapacity());
      return reinterpret_cast&lt;char*&gt;(
          object-&gt;allocateMoreOutOfLineStorage(vm, 0, initialOutOfLineCapacity));
  }
  
<span class="line-modified">! char* JIT_OPERATION operationAllocateComplexPropertyStorage(VM* vmPointer, JSObject* object, size_t newSize)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      return reinterpret_cast&lt;char*&gt;(
          object-&gt;allocateMoreOutOfLineStorage(vm, object-&gt;structure(vm)-&gt;outOfLineCapacity(), newSize));
  }
  
<span class="line-modified">! char* JIT_OPERATION operationEnsureInt32(VM* vmPointer, JSCell* cell)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      if (!cell-&gt;isObject())
          return 0;
  
      auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableInt32(vm).data());
      ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasInt32(cell-&gt;indexingMode())) || !result);
      return result;
  }
  
<span class="line-modified">! char* JIT_OPERATION operationEnsureDouble(VM* vmPointer, JSCell* cell)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      if (!cell-&gt;isObject())
          return 0;
  
      auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableDouble(vm).data());
      ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasDouble(cell-&gt;indexingMode())) || !result);
      return result;
  }
  
<span class="line-modified">! char* JIT_OPERATION operationEnsureContiguous(VM* vmPointer, JSCell* cell)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      if (!cell-&gt;isObject())
          return 0;
  
      auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableContiguous(vm).data());
      ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasContiguous(cell-&gt;indexingMode())) || !result);
      return result;
  }
  
<span class="line-modified">! char* JIT_OPERATION operationEnsureArrayStorage(VM* vmPointer, JSCell* cell)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      if (!cell-&gt;isObject())
          return 0;
  
      auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;ensureArrayStorage(vm));
      ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasAnyArrayStorage(cell-&gt;indexingMode())) || !result);
      return result;
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationHasGenericProperty(JSGlobalObject* globalObject, EncodedJSValue encodedBaseValue, JSCell* property)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue baseValue = JSValue::decode(encodedBaseValue);
      if (baseValue.isUndefinedOrNull())
          return JSValue::encode(jsBoolean(false));
  
<span class="line-modified">!     JSObject* base = baseValue.toObject(globalObject);</span>
<span class="line-modified">!     EXCEPTION_ASSERT(!scope.exception() || !base);</span>
      if (!base)
          return JSValue::encode(JSValue());
<span class="line-modified">!     auto propertyName = asString(property)-&gt;toIdentifier(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(jsBoolean(base-&gt;hasPropertyGeneric(globalObject, propertyName, PropertySlot::InternalMethodType::GetOwnProperty))));</span>
  }
  
<span class="line-modified">! size_t JIT_OPERATION operationHasIndexedPropertyByInt(JSGlobalObject* globalObject, JSCell* baseCell, int32_t subscript, int32_t internalMethodType)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     JSObject* object = baseCell-&gt;toObject(globalObject);</span>
      if (UNLIKELY(subscript &lt; 0)) {
          // Go the slowest way possible because negative indices don&#39;t use indexed storage.
<span class="line-modified">!         return object-&gt;hasPropertyGeneric(globalObject, Identifier::from(vm, subscript), static_cast&lt;PropertySlot::InternalMethodType&gt;(internalMethodType));</span>
      }
<span class="line-modified">!     return object-&gt;hasPropertyGeneric(globalObject, subscript, static_cast&lt;PropertySlot::InternalMethodType&gt;(internalMethodType));</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationGetPropertyEnumerator(JSGlobalObject* globalObject, EncodedJSValue encodedBase)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue base = JSValue::decode(encodedBase);
      if (base.isUndefinedOrNull())
          return vm.emptyPropertyNameEnumerator();
  
<span class="line-modified">!     JSObject* baseObject = base.toObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, propertyNameEnumerator(globalObject, baseObject));</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationGetPropertyEnumeratorCell(JSGlobalObject* globalObject, JSCell* cell)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* base = cell-&gt;toObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, propertyNameEnumerator(globalObject, base));</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationToIndexString(JSGlobalObject* globalObject, int32_t index)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      return jsString(vm, Identifier::from(vm, index).string());
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationNewRegexpWithLastIndex(JSGlobalObject* globalObject, JSCell* regexpPtr, EncodedJSValue encodedLastIndex)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      RegExp* regexp = static_cast&lt;RegExp*&gt;(regexpPtr);
      ASSERT(regexp-&gt;isValid());
<span class="line-modified">!     return RegExpObject::create(vm, globalObject-&gt;regExpStructure(), regexp, JSValue::decode(encodedLastIndex));</span>
  }
  
<span class="line-modified">! StringImpl* JIT_OPERATION operationResolveRope(JSGlobalObject* globalObject, JSString* string)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     return string-&gt;value(globalObject).impl();</span>
  }
  
<span class="line-modified">! JSString* JIT_OPERATION operationStringValueOf(JSGlobalObject* globalObject, EncodedJSValue encodedArgument)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue argument = JSValue::decode(encodedArgument);
  
      if (argument.isString())
          return asString(argument);
  
      if (auto* stringObject = jsDynamicCast&lt;StringObject*&gt;(vm, argument))
          return stringObject-&gt;internalValue();
  
<span class="line-modified">!     throwVMTypeError(globalObject, scope);</span>
      return nullptr;
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationStringSubstr(JSGlobalObject* globalObject, JSCell* cell, int32_t from, int32_t span)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     return jsSubstring(vm, globalObject, jsCast&lt;JSString*&gt;(cell), from, span);</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationStringSlice(JSGlobalObject* globalObject, JSCell* cell, int32_t start, int32_t end)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      JSString* string = asString(cell);
      static_assert(static_cast&lt;uint64_t&gt;(JSString::MaxLength) &lt;= static_cast&lt;uint64_t&gt;(std::numeric_limits&lt;int32_t&gt;::max()), &quot;&quot;);
<span class="line-modified">!     return stringSlice(globalObject, vm, string, string-&gt;length(), start, end);</span>
  }
  
<span class="line-modified">! JSString* JIT_OPERATION operationToLowerCase(JSGlobalObject* globalObject, JSString* string, uint32_t failingIndex)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String inputString = string-&gt;value(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (!inputString.length())
          return vm.smallStrings.emptyString();
  
      String lowercasedString = inputString.is8Bit() ? inputString.convertToLowercaseWithoutLocaleStartingAtFailingIndex8Bit(failingIndex) : inputString.convertToLowercaseWithoutLocale();
      if (lowercasedString.impl() == inputString.impl())
          return string;
      RELEASE_AND_RETURN(scope, jsString(vm, lowercasedString));
  }
  
<span class="line-modified">! char* JIT_OPERATION operationInt32ToString(JSGlobalObject* globalObject, int32_t value, int32_t radix)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (radix &lt; 2 || radix &gt; 36) {
<span class="line-modified">!         throwVMError(globalObject, scope, createRangeError(globalObject, &quot;toString() radix argument must be between 2 and 36&quot;_s));</span>
          return nullptr;
      }
  
      return reinterpret_cast&lt;char*&gt;(int32ToString(vm, value, radix));
  }
  
<span class="line-modified">! char* JIT_OPERATION operationInt52ToString(JSGlobalObject* globalObject, int64_t value, int32_t radix)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (radix &lt; 2 || radix &gt; 36) {
<span class="line-modified">!         throwVMError(globalObject, scope, createRangeError(globalObject, &quot;toString() radix argument must be between 2 and 36&quot;_s));</span>
          return nullptr;
      }
  
      return reinterpret_cast&lt;char*&gt;(int52ToString(vm, value, radix));
  }
  
<span class="line-modified">! char* JIT_OPERATION operationDoubleToString(JSGlobalObject* globalObject, double value, int32_t radix)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (radix &lt; 2 || radix &gt; 36) {
<span class="line-modified">!         throwVMError(globalObject, scope, createRangeError(globalObject, &quot;toString() radix argument must be between 2 and 36&quot;_s));</span>
          return nullptr;
      }
  
      return reinterpret_cast&lt;char*&gt;(numberToString(vm, value, radix));
  }
  
<span class="line-modified">! char* JIT_OPERATION operationInt32ToStringWithValidRadix(JSGlobalObject* globalObject, int32_t value, int32_t radix)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      return reinterpret_cast&lt;char*&gt;(int32ToString(vm, value, radix));
  }
  
<span class="line-modified">! char* JIT_OPERATION operationInt52ToStringWithValidRadix(JSGlobalObject* globalObject, int64_t value, int32_t radix)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      return reinterpret_cast&lt;char*&gt;(int52ToString(vm, value, radix));
  }
  
<span class="line-modified">! char* JIT_OPERATION operationDoubleToStringWithValidRadix(JSGlobalObject* globalObject, double value, int32_t radix)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      return reinterpret_cast&lt;char*&gt;(numberToString(vm, value, radix));
  }
  
<span class="line-modified">! JSString* JIT_OPERATION operationSingleCharacterString(VM* vmPointer, int32_t character)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      return jsSingleCharacterString(vm, static_cast&lt;UChar&gt;(character));
  }
  
<span class="line-modified">! Symbol* JIT_OPERATION operationNewSymbol(VM* vmPointer)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      return Symbol::create(vm);
  }
  
<span class="line-modified">! Symbol* JIT_OPERATION operationNewSymbolWithDescription(JSGlobalObject* globalObject, JSString* description)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     String string = description-&gt;value(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      return Symbol::createWithDescription(vm, string);
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationNewStringObject(VM* vmPointer, JSString* string, Structure* structure)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      return StringObject::create(vm, structure, string);
  }
  
<span class="line-modified">! JSString* JIT_OPERATION operationToStringOnCell(JSGlobalObject* globalObject, JSCell* cell)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     return JSValue(cell).toString(globalObject);</span>
  }
  
<span class="line-modified">! JSString* JIT_OPERATION operationToString(JSGlobalObject* globalObject, EncodedJSValue value)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     return JSValue::decode(value).toString(globalObject);</span>
  }
  
<span class="line-modified">! JSString* JIT_OPERATION operationCallStringConstructorOnCell(JSGlobalObject* globalObject, JSCell* cell)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     return stringConstructor(globalObject, cell);</span>
  }
  
<span class="line-modified">! JSString* JIT_OPERATION operationCallStringConstructor(JSGlobalObject* globalObject, EncodedJSValue value)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     return stringConstructor(globalObject, JSValue::decode(value));</span>
  }
  
<span class="line-modified">! JSString* JIT_OPERATION operationMakeRope2(JSGlobalObject* globalObject, JSString* left, JSString* right)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     return jsString(globalObject, left, right);</span>
  }
  
<span class="line-modified">! JSString* JIT_OPERATION operationMakeRope3(JSGlobalObject* globalObject, JSString* a, JSString* b, JSString* c)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     return jsString(globalObject, a, b, c);</span>
  }
  
<span class="line-modified">! JSString* JIT_OPERATION operationStrCat2(JSGlobalObject* globalObject, EncodedJSValue a, EncodedJSValue b)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      ASSERT(!JSValue::decode(a).isSymbol());
      ASSERT(!JSValue::decode(b).isSymbol());
<span class="line-modified">!     JSString* str1 = JSValue::decode(a).toString(globalObject);</span>
      scope.assertNoException(); // Impossible, since we must have been given non-Symbol primitives.
<span class="line-modified">!     JSString* str2 = JSValue::decode(b).toString(globalObject);</span>
      scope.assertNoException();
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, jsString(globalObject, str1, str2));</span>
  }
  
<span class="line-modified">! JSString* JIT_OPERATION operationStrCat3(JSGlobalObject* globalObject, EncodedJSValue a, EncodedJSValue b, EncodedJSValue c)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      ASSERT(!JSValue::decode(a).isSymbol());
      ASSERT(!JSValue::decode(b).isSymbol());
      ASSERT(!JSValue::decode(c).isSymbol());
<span class="line-modified">!     JSString* str1 = JSValue::decode(a).toString(globalObject);</span>
      scope.assertNoException(); // Impossible, since we must have been given non-Symbol primitives.
<span class="line-modified">!     JSString* str2 = JSValue::decode(b).toString(globalObject);</span>
      scope.assertNoException();
<span class="line-modified">!     JSString* str3 = JSValue::decode(c).toString(globalObject);</span>
      scope.assertNoException();
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, jsString(globalObject, str1, str2, str3));</span>
  }
  
<span class="line-modified">! char* JIT_OPERATION operationFindSwitchImmTargetForDouble(VM* vmPointer, EncodedJSValue encodedValue, size_t tableIndex)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
      SimpleJumpTable&amp; table = codeBlock-&gt;switchJumpTable(tableIndex);
      JSValue value = JSValue::decode(encodedValue);
      ASSERT(value.isDouble());
      double asDouble = value.asDouble();
      int32_t asInt32 = static_cast&lt;int32_t&gt;(asDouble);
      if (asDouble == asInt32)
          return table.ctiForValue(asInt32).executableAddress&lt;char*&gt;();
      return table.ctiDefault.executableAddress&lt;char*&gt;();
  }
  
<span class="line-modified">! char* JIT_OPERATION operationSwitchString(JSGlobalObject* globalObject, size_t tableIndex, JSString* string)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     StringImpl* strImpl = string-&gt;value(globalObject).impl();</span>
  
      RETURN_IF_EXCEPTION(throwScope, nullptr);
  
<span class="line-modified">!     return callFrame-&gt;codeBlock()-&gt;stringSwitchJumpTable(tableIndex).ctiForValue(strImpl).executableAddress&lt;char*&gt;();</span>
  }
  
<span class="line-modified">! int32_t JIT_OPERATION operationSwitchStringAndGetBranchOffset(JSGlobalObject* globalObject, size_t tableIndex, JSString* string)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     StringImpl* strImpl = string-&gt;value(globalObject).impl();</span>
  
      RETURN_IF_EXCEPTION(throwScope, 0);
  
<span class="line-modified">!     return callFrame-&gt;codeBlock()-&gt;stringSwitchJumpTable(tableIndex).offsetForValue(strImpl, std::numeric_limits&lt;int32_t&gt;::min());</span>
  }
  
  uintptr_t JIT_OPERATION operationCompareStringImplLess(StringImpl* a, StringImpl* b)
  {
      return codePointCompare(a, b) &lt; 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2510,98 ***</span>
  uintptr_t JIT_OPERATION operationCompareStringImplGreaterEq(StringImpl* a, StringImpl* b)
  {
      return codePointCompare(a, b) &gt;= 0;
  }
  
<span class="line-modified">! uintptr_t JIT_OPERATION operationCompareStringLess(ExecState* exec, JSString* a, JSString* b)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return codePointCompareLessThan(asString(a)-&gt;value(exec), asString(b)-&gt;value(exec));</span>
  }
  
<span class="line-modified">! uintptr_t JIT_OPERATION operationCompareStringLessEq(ExecState* exec, JSString* a, JSString* b)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return !codePointCompareLessThan(asString(b)-&gt;value(exec), asString(a)-&gt;value(exec));</span>
  }
  
<span class="line-modified">! uintptr_t JIT_OPERATION operationCompareStringGreater(ExecState* exec, JSString* a, JSString* b)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return codePointCompareLessThan(asString(b)-&gt;value(exec), asString(a)-&gt;value(exec));</span>
  }
  
<span class="line-modified">! uintptr_t JIT_OPERATION operationCompareStringGreaterEq(ExecState* exec, JSString* a, JSString* b)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return !codePointCompareLessThan(asString(a)-&gt;value(exec), asString(b)-&gt;value(exec));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationNotifyWrite(ExecState* exec, WatchpointSet* set)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      set-&gt;touch(vm, &quot;Executed NotifyWrite&quot;);
  }
  
<span class="line-modified">! void JIT_OPERATION operationThrowStackOverflowForVarargs(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     throwStackOverflowError(exec, scope);</span>
  }
  
<span class="line-modified">! int32_t JIT_OPERATION operationSizeOfVarargs(ExecState* exec, EncodedJSValue encodedArguments, uint32_t firstVarArgOffset)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue arguments = JSValue::decode(encodedArguments);
  
<span class="line-modified">!     return sizeOfVarargs(exec, arguments, firstVarArgOffset);</span>
  }
  
<span class="line-modified">! int32_t JIT_OPERATION operationHasOwnProperty(ExecState* exec, JSObject* thisObject, EncodedJSValue encodedKey)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue key = JSValue::decode(encodedKey);
<span class="line-modified">!     Identifier propertyName = key.toPropertyKey(exec);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      PropertySlot slot(thisObject, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">!     bool result = thisObject-&gt;hasOwnProperty(exec, propertyName.impl(), slot);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      HasOwnPropertyCache* hasOwnPropertyCache = vm.hasOwnPropertyCache();
      ASSERT(hasOwnPropertyCache);
      hasOwnPropertyCache-&gt;tryAdd(vm, slot, thisObject, propertyName.impl(), result);
      return result;
  }
  
<span class="line-modified">! int32_t JIT_OPERATION operationNumberIsInteger(ExecState* exec, EncodedJSValue value)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      return NumberConstructor::isIntegerImpl(JSValue::decode(value));
  }
  
<span class="line-modified">! int32_t JIT_OPERATION operationArrayIndexOfString(ExecState* exec, Butterfly* butterfly, JSString* searchElement, int32_t index)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      int32_t length = butterfly-&gt;publicLength();
      auto data = butterfly-&gt;contiguous().data();
      for (; index &lt; length; ++index) {
<span class="line-new-header">--- 2815,108 ---</span>
  uintptr_t JIT_OPERATION operationCompareStringImplGreaterEq(StringImpl* a, StringImpl* b)
  {
      return codePointCompare(a, b) &gt;= 0;
  }
  
<span class="line-modified">! uintptr_t JIT_OPERATION operationCompareStringLess(JSGlobalObject* globalObject, JSString* a, JSString* b)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     return codePointCompareLessThan(asString(a)-&gt;value(globalObject), asString(b)-&gt;value(globalObject));</span>
  }
  
<span class="line-modified">! uintptr_t JIT_OPERATION operationCompareStringLessEq(JSGlobalObject* globalObject, JSString* a, JSString* b)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     return !codePointCompareLessThan(asString(b)-&gt;value(globalObject), asString(a)-&gt;value(globalObject));</span>
  }
  
<span class="line-modified">! uintptr_t JIT_OPERATION operationCompareStringGreater(JSGlobalObject* globalObject, JSString* a, JSString* b)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     return codePointCompareLessThan(asString(b)-&gt;value(globalObject), asString(a)-&gt;value(globalObject));</span>
  }
  
<span class="line-modified">! uintptr_t JIT_OPERATION operationCompareStringGreaterEq(JSGlobalObject* globalObject, JSString* a, JSString* b)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     return !codePointCompareLessThan(asString(a)-&gt;value(globalObject), asString(b)-&gt;value(globalObject));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationNotifyWrite(VM* vmPointer, WatchpointSet* set)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      set-&gt;touch(vm, &quot;Executed NotifyWrite&quot;);
  }
  
<span class="line-modified">! void JIT_OPERATION operationThrowStackOverflowForVarargs(JSGlobalObject* globalObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     throwStackOverflowError(globalObject, scope);</span>
  }
  
<span class="line-modified">! int32_t JIT_OPERATION operationSizeOfVarargs(JSGlobalObject* globalObject, EncodedJSValue encodedArguments, uint32_t firstVarArgOffset)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      JSValue arguments = JSValue::decode(encodedArguments);
  
<span class="line-modified">!     return sizeOfVarargs(globalObject, arguments, firstVarArgOffset);</span>
  }
  
<span class="line-modified">! int32_t JIT_OPERATION operationHasOwnProperty(JSGlobalObject* globalObject, JSObject* thisObject, EncodedJSValue encodedKey)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue key = JSValue::decode(encodedKey);
<span class="line-modified">!     Identifier propertyName = key.toPropertyKey(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      PropertySlot slot(thisObject, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">!     bool result = thisObject-&gt;hasOwnProperty(globalObject, propertyName.impl(), slot);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      HasOwnPropertyCache* hasOwnPropertyCache = vm.hasOwnPropertyCache();
      ASSERT(hasOwnPropertyCache);
      hasOwnPropertyCache-&gt;tryAdd(vm, slot, thisObject, propertyName.impl(), result);
      return result;
  }
  
<span class="line-modified">! int32_t JIT_OPERATION operationNumberIsInteger(JSGlobalObject* globalObject, EncodedJSValue value)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      return NumberConstructor::isIntegerImpl(JSValue::decode(value));
  }
  
<span class="line-modified">! int32_t JIT_OPERATION operationArrayIndexOfString(JSGlobalObject* globalObject, Butterfly* butterfly, JSString* searchElement, int32_t index)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      int32_t length = butterfly-&gt;publicLength();
      auto data = butterfly-&gt;contiguous().data();
      for (; index &lt; length; ++index) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2609,45 ***</span>
          if (!value || !value.isString())
              continue;
          auto* string = asString(value);
          if (string == searchElement)
              return index;
<span class="line-modified">!         if (string-&gt;equal(exec, searchElement)) {</span>
              scope.assertNoException();
              return index;
          }
          RETURN_IF_EXCEPTION(scope, { });
      }
      return -1;
  }
  
<span class="line-modified">! int32_t JIT_OPERATION operationArrayIndexOfValueInt32OrContiguous(ExecState* exec, Butterfly* butterfly, EncodedJSValue encodedValue, int32_t index)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue searchElement = JSValue::decode(encodedValue);
  
      int32_t length = butterfly-&gt;publicLength();
      auto data = butterfly-&gt;contiguous().data();
      for (; index &lt; length; ++index) {
          JSValue value = data[index].get();
          if (!value)
              continue;
<span class="line-modified">!         bool isEqual = JSValue::strictEqual(exec, searchElement, value);</span>
          RETURN_IF_EXCEPTION(scope, { });
          if (isEqual)
              return index;
      }
      return -1;
  }
  
<span class="line-modified">! int32_t JIT_OPERATION operationArrayIndexOfValueDouble(ExecState* exec, Butterfly* butterfly, EncodedJSValue encodedValue, int32_t index)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSValue searchElement = JSValue::decode(encodedValue);
  
      if (!searchElement.isNumber())
          return -1;
<span class="line-new-header">--- 2924,47 ---</span>
          if (!value || !value.isString())
              continue;
          auto* string = asString(value);
          if (string == searchElement)
              return index;
<span class="line-modified">!         if (string-&gt;equal(globalObject, searchElement)) {</span>
              scope.assertNoException();
              return index;
          }
          RETURN_IF_EXCEPTION(scope, { });
      }
      return -1;
  }
  
<span class="line-modified">! int32_t JIT_OPERATION operationArrayIndexOfValueInt32OrContiguous(JSGlobalObject* globalObject, Butterfly* butterfly, EncodedJSValue encodedValue, int32_t index)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue searchElement = JSValue::decode(encodedValue);
  
      int32_t length = butterfly-&gt;publicLength();
      auto data = butterfly-&gt;contiguous().data();
      for (; index &lt; length; ++index) {
          JSValue value = data[index].get();
          if (!value)
              continue;
<span class="line-modified">!         bool isEqual = JSValue::strictEqual(globalObject, searchElement, value);</span>
          RETURN_IF_EXCEPTION(scope, { });
          if (isEqual)
              return index;
      }
      return -1;
  }
  
<span class="line-modified">! int32_t JIT_OPERATION operationArrayIndexOfValueDouble(JSGlobalObject* globalObject, Butterfly* butterfly, EncodedJSValue encodedValue, int32_t index)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      JSValue searchElement = JSValue::decode(encodedValue);
  
      if (!searchElement.isNumber())
          return -1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2661,20 ***</span>
              return index;
      }
      return -1;
  }
  
<span class="line-modified">! void JIT_OPERATION operationLoadVarargs(ExecState* exec, int32_t firstElementDest, EncodedJSValue encodedArguments, uint32_t offset, uint32_t length, uint32_t mandatoryMinimum)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue arguments = JSValue::decode(encodedArguments);
  
<span class="line-modified">!     loadVarargs(exec, VirtualRegister(firstElementDest), arguments, offset, length);</span>
  
<span class="line-modified">!     for (uint32_t i = length; i &lt; mandatoryMinimum; ++i)</span>
<span class="line-modified">!         exec-&gt;r(firstElementDest + i) = jsUndefined();</span>
  }
  
  double JIT_OPERATION operationFModOnInts(int32_t a, int32_t b)
  {
      return fmod(a, b);
<span class="line-new-header">--- 2978,22 ---</span>
              return index;
      }
      return -1;
  }
  
<span class="line-modified">! void JIT_OPERATION operationLoadVarargs(JSGlobalObject* globalObject, int32_t firstElementDest, EncodedJSValue encodedArguments, uint32_t offset, uint32_t lengthIncludingThis, uint32_t mandatoryMinimum)</span>
  {
<span class="line-modified">!     VirtualRegister firstElement { firstElementDest };</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      JSValue arguments = JSValue::decode(encodedArguments);
  
<span class="line-modified">!     loadVarargs(globalObject, bitwise_cast&lt;JSValue*&gt;(&amp;callFrame-&gt;r(firstElement)), arguments, offset, lengthIncludingThis - 1);</span>
  
<span class="line-modified">!     for (uint32_t i = lengthIncludingThis - 1; i &lt; mandatoryMinimum; ++i)</span>
<span class="line-modified">!         callFrame-&gt;r(firstElement + i) = jsUndefined();</span>
  }
  
  double JIT_OPERATION operationFModOnInts(int32_t a, int32_t b)
  {
      return fmod(a, b);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2685,24 ***</span>
  {
      return globalObject-&gt;weakRandomNumber();
  }
  #endif
  
<span class="line-modified">! JSCell* JIT_OPERATION operationStringFromCharCode(ExecState* exec, int32_t op1)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     return JSC::stringFromCharCode(exec, op1);</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationStringFromCharCodeUntyped(ExecState* exec, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue charValue = JSValue::decode(encodedValue);
<span class="line-modified">!     int32_t chInt = charValue.toUInt32(exec);</span>
<span class="line-modified">!     return JSValue::encode(JSC::stringFromCharCode(exec, chInt));</span>
  }
  
  int64_t JIT_OPERATION operationConvertBoxedDoubleToInt52(EncodedJSValue encodedValue)
  {
      JSValue value = JSValue::decode(encodedValue);
<span class="line-new-header">--- 3004,26 ---</span>
  {
      return globalObject-&gt;weakRandomNumber();
  }
  #endif
  
<span class="line-modified">! JSCell* JIT_OPERATION operationStringFromCharCode(JSGlobalObject* globalObject, int32_t op1)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     return JSC::stringFromCharCode(globalObject, op1);</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationStringFromCharCodeUntyped(JSGlobalObject* globalObject, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      JSValue charValue = JSValue::decode(encodedValue);
<span class="line-modified">!     int32_t chInt = charValue.toUInt32(globalObject);</span>
<span class="line-modified">!     return JSValue::encode(JSC::stringFromCharCode(globalObject, chInt));</span>
  }
  
  int64_t JIT_OPERATION operationConvertBoxedDoubleToInt52(EncodedJSValue encodedValue)
  {
      JSValue value = JSValue::decode(encodedValue);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2714,14 ***</span>
  int64_t JIT_OPERATION operationConvertDoubleToInt52(double value)
  {
      return tryConvertToInt52(value);
  }
  
<span class="line-modified">! char* JIT_OPERATION operationNewRawObject(ExecState* exec, Structure* structure, int32_t length, Butterfly* butterfly)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      if (!butterfly
          &amp;&amp; (structure-&gt;outOfLineCapacity() || hasIndexedProperties(structure-&gt;indexingType()))) {
          IndexingHeader header;
          header.setVectorLength(length);
<span class="line-new-header">--- 3035,15 ---</span>
  int64_t JIT_OPERATION operationConvertDoubleToInt52(double value)
  {
      return tryConvertToInt52(value);
  }
  
<span class="line-modified">! char* JIT_OPERATION operationNewRawObject(VM* vmPointer, Structure* structure, int32_t length, Butterfly* butterfly)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      if (!butterfly
          &amp;&amp; (structure-&gt;outOfLineCapacity() || hasIndexedProperties(structure-&gt;indexingType()))) {
          IndexingHeader header;
          header.setVectorLength(length);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2731,34 ***</span>
              vm, nullptr, 0, structure-&gt;outOfLineCapacity(),
              hasIndexedProperties(structure-&gt;indexingType()), header,
              length * sizeof(EncodedJSValue));
      }
  
<span class="line-modified">!     JSObject* result = JSObject::createRawObject(exec, structure, butterfly);</span>
<span class="line-removed">-     result-&gt;butterfly(); // Ensure that the butterfly is in to-space.</span>
      return bitwise_cast&lt;char*&gt;(result);
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationNewObjectWithButterfly(ExecState* exec, Structure* structure, Butterfly* butterfly)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      if (!butterfly) {
          butterfly = Butterfly::create(
              vm, nullptr, 0, structure-&gt;outOfLineCapacity(), false, IndexingHeader(), 0);
      }
  
<span class="line-modified">!     JSObject* result = JSObject::createRawObject(exec, structure, butterfly);</span>
<span class="line-removed">-     result-&gt;butterfly(); // Ensure that the butterfly is in to-space.</span>
      return result;
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationNewObjectWithButterflyWithIndexingHeaderAndVectorLength(ExecState* exec, Structure* structure, unsigned length, Butterfly* butterfly)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      IndexingHeader header;
      header.setVectorLength(length);
      header.setPublicLength(0);
      if (butterfly)
<span class="line-new-header">--- 3053,34 ---</span>
              vm, nullptr, 0, structure-&gt;outOfLineCapacity(),
              hasIndexedProperties(structure-&gt;indexingType()), header,
              length * sizeof(EncodedJSValue));
      }
  
<span class="line-modified">!     JSObject* result = JSObject::createRawObject(vm, structure, butterfly);</span>
      return bitwise_cast&lt;char*&gt;(result);
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationNewObjectWithButterfly(VM* vmPointer, Structure* structure, Butterfly* butterfly)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      if (!butterfly) {
          butterfly = Butterfly::create(
              vm, nullptr, 0, structure-&gt;outOfLineCapacity(), false, IndexingHeader(), 0);
      }
  
<span class="line-modified">!     JSObject* result = JSObject::createRawObject(vm, structure, butterfly);</span>
      return result;
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationNewObjectWithButterflyWithIndexingHeaderAndVectorLength(VM* vmPointer, Structure* structure, unsigned length, Butterfly* butterfly)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      IndexingHeader header;
      header.setVectorLength(length);
      header.setPublicLength(0);
      if (butterfly)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2768,364 ***</span>
              vm, nullptr, 0, structure-&gt;outOfLineCapacity(), true, header,
              sizeof(EncodedJSValue) * length);
      }
  
      // Paradoxically this may allocate a JSArray. That&#39;s totally cool.
<span class="line-modified">!     JSObject* result = JSObject::createRawObject(exec, structure, butterfly);</span>
<span class="line-removed">-     result-&gt;butterfly(); // Ensure that the butterfly is in to-space.</span>
      return result;
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationNewArrayWithSpreadSlow(ExecState* exec, void* buffer, uint32_t numItems)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      EncodedJSValue* values = static_cast&lt;EncodedJSValue*&gt;(buffer);
      Checked&lt;unsigned, RecordOverflow&gt; checkedLength = 0;
      for (unsigned i = 0; i &lt; numItems; i++) {
          JSValue value = JSValue::decode(values[i]);
<span class="line-modified">!         if (JSFixedArray* array = jsDynamicCast&lt;JSFixedArray*&gt;(vm, value))</span>
<span class="line-modified">!             checkedLength += array-&gt;size();</span>
          else
              ++checkedLength;
      }
  
      if (UNLIKELY(checkedLength.hasOverflowed())) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return nullptr;
      }
  
      unsigned length = checkedLength.unsafeGet();
      if (UNLIKELY(length &gt;= MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return nullptr;
      }
  
<span class="line-removed">-     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
      Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous);
  
      JSArray* result = JSArray::tryCreate(vm, structure, length);
      if (UNLIKELY(!result)) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return nullptr;
      }
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      unsigned index = 0;
      for (unsigned i = 0; i &lt; numItems; i++) {
          JSValue value = JSValue::decode(values[i]);
<span class="line-modified">!         if (JSFixedArray* array = jsDynamicCast&lt;JSFixedArray*&gt;(vm, value)) {</span>
              // We are spreading.
<span class="line-modified">!             for (unsigned i = 0; i &lt; array-&gt;size(); i++) {</span>
<span class="line-modified">!                 result-&gt;putDirectIndex(exec, index, array-&gt;get(i));</span>
                  RETURN_IF_EXCEPTION(scope, nullptr);
                  ++index;
              }
          } else {
              // We are not spreading.
<span class="line-modified">!             result-&gt;putDirectIndex(exec, index, value);</span>
              RETURN_IF_EXCEPTION(scope, nullptr);
              ++index;
          }
      }
  
      return result;
  }
  
<span class="line-modified">! JSCell* operationCreateFixedArray(ExecState* exec, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (JSFixedArray* result = JSFixedArray::tryCreate(vm, vm.fixedArrayStructure.get(), length))</span>
          return result;
  
<span class="line-modified">!     throwOutOfMemoryError(exec, scope);</span>
      return nullptr;
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationSpreadGeneric(ExecState* exec, JSCell* iterable)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      if (isJSArray(iterable)) {
          JSArray* array = jsCast&lt;JSArray*&gt;(iterable);
          if (array-&gt;isIteratorProtocolFastAndNonObservable())
<span class="line-modified">!             RELEASE_AND_RETURN(throwScope, JSFixedArray::createFromArray(exec, vm, array));</span>
      }
  
      // FIXME: we can probably make this path faster by having our caller JS code call directly into
      // the iteration protocol builtin: https://bugs.webkit.org/show_bug.cgi?id=164520
  
<span class="line-removed">-     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
      JSArray* array;
      {
          JSFunction* iterationFunction = globalObject-&gt;iteratorProtocolFunction();
          CallData callData;
          CallType callType = JSC::getCallData(vm, iterationFunction, callData);
          ASSERT(callType != CallType::None);
  
          MarkedArgumentBuffer arguments;
          arguments.append(iterable);
          ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!         JSValue arrayResult = call(exec, iterationFunction, callType, callData, jsNull(), arguments);</span>
          RETURN_IF_EXCEPTION(throwScope, nullptr);
          array = jsCast&lt;JSArray*&gt;(arrayResult);
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(throwScope, JSFixedArray::createFromArray(exec, vm, array));</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationSpreadFastArray(ExecState* exec, JSCell* cell)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      ASSERT(isJSArray(cell));
      JSArray* array = jsCast&lt;JSArray*&gt;(cell);
      ASSERT(array-&gt;isIteratorProtocolFastAndNonObservable());
  
<span class="line-modified">!     return JSFixedArray::createFromArray(exec, vm, array);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationProcessTypeProfilerLogDFG(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;Log Full, called from inside DFG.&quot;_s);
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationResolveScopeForHoistingFuncDeclInEval(ExecState* exec, JSScope* scope, UniquedStringImpl* impl)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(exec, scope, Identifier::fromUid(vm, impl));</span>
      return JSValue::encode(resolvedScope);
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationResolveScope(ExecState* exec, JSScope* scope, UniquedStringImpl* impl)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     JSObject* resolvedScope = JSScope::resolve(exec, scope, Identifier::fromUid(vm, impl));</span>
      return resolvedScope;
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationGetDynamicVar(ExecState* exec, JSObject* scope, UniquedStringImpl* impl, unsigned getPutInfoBits)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      Identifier ident = Identifier::fromUid(vm, impl);
<span class="line-modified">!     RELEASE_AND_RETURN(throwScope, JSValue::encode(scope-&gt;getPropertySlot(exec, ident, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {</span>
          if (!found) {
              GetPutInfo getPutInfo(getPutInfoBits);
              if (getPutInfo.resolveMode() == ThrowIfNotFound)
<span class="line-modified">!                 throwException(exec, throwScope, createUndefinedVariableError(exec, ident));</span>
              return jsUndefined();
          }
  
          if (scope-&gt;isGlobalLexicalEnvironment()) {
              // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
<span class="line-modified">!             JSValue result = slot.getValue(exec, ident);</span>
              if (result == jsTDZValue()) {
<span class="line-modified">!                 throwException(exec, throwScope, createTDZError(exec));</span>
                  return jsUndefined();
              }
              return result;
          }
  
<span class="line-modified">!         return slot.getValue(exec, ident);</span>
      })));
  }
  
<span class="line-modified">! ALWAYS_INLINE static void putDynamicVar(ExecState* exec, VM&amp; vm, JSObject* scope, EncodedJSValue value, UniquedStringImpl* impl, unsigned getPutInfoBits, bool isStrictMode)</span>
  {
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      const Identifier&amp; ident = Identifier::fromUid(vm, impl);
      GetPutInfo getPutInfo(getPutInfoBits);
<span class="line-modified">!     bool hasProperty = scope-&gt;hasProperty(exec, ident);</span>
      RETURN_IF_EXCEPTION(throwScope, void());
      if (hasProperty
          &amp;&amp; scope-&gt;isGlobalLexicalEnvironment()
          &amp;&amp; !isInitialization(getPutInfo.initializationMode())) {
          // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
          PropertySlot slot(scope, PropertySlot::InternalMethodType::Get);
<span class="line-modified">!         JSGlobalLexicalEnvironment::getOwnPropertySlot(scope, exec, ident, slot);</span>
<span class="line-modified">!         if (slot.getValue(exec, ident) == jsTDZValue()) {</span>
<span class="line-modified">!             throwException(exec, throwScope, createTDZError(exec));</span>
              return;
          }
      }
  
      if (getPutInfo.resolveMode() == ThrowIfNotFound &amp;&amp; !hasProperty) {
<span class="line-modified">!         throwException(exec, throwScope, createUndefinedVariableError(exec, ident));</span>
          return;
      }
  
      PutPropertySlot slot(scope, isStrictMode, PutPropertySlot::UnknownContext, isInitialization(getPutInfo.initializationMode()));
      throwScope.release();
<span class="line-modified">!     scope-&gt;methodTable(vm)-&gt;put(scope, exec, ident, JSValue::decode(value), slot);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutDynamicVarStrict(ExecState* exec, JSObject* scope, EncodedJSValue value, UniquedStringImpl* impl, unsigned getPutInfoBits)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      constexpr bool isStrictMode = true;
<span class="line-modified">!     return putDynamicVar(exec, vm, scope, value, impl, getPutInfoBits, isStrictMode);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutDynamicVarNonStrict(ExecState* exec, JSObject* scope, EncodedJSValue value, UniquedStringImpl* impl, unsigned getPutInfoBits)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      constexpr bool isStrictMode = false;
<span class="line-modified">!     return putDynamicVar(exec, vm, scope, value, impl, getPutInfoBits, isStrictMode);</span>
  }
  
<span class="line-modified">! int32_t JIT_OPERATION operationMapHash(ExecState* exec, EncodedJSValue input)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return jsMapHash(exec, vm, JSValue::decode(input));</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationJSMapFindBucket(ExecState* exec, JSCell* map, EncodedJSValue key, int32_t hash)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     JSMap::BucketType** bucket = jsCast&lt;JSMap*&gt;(map)-&gt;findBucket(exec, JSValue::decode(key), hash);</span>
      if (!bucket)
          return vm.sentinelMapBucket();
      return *bucket;
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationJSSetFindBucket(ExecState* exec, JSCell* map, EncodedJSValue key, int32_t hash)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     JSSet::BucketType** bucket = jsCast&lt;JSSet*&gt;(map)-&gt;findBucket(exec, JSValue::decode(key), hash);</span>
      if (!bucket)
          return vm.sentinelSetBucket();
      return *bucket;
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationSetAdd(ExecState* exec, JSCell* set, EncodedJSValue key, int32_t hash)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     auto* bucket = jsCast&lt;JSSet*&gt;(set)-&gt;addNormalized(exec, JSValue::decode(key), JSValue(), hash);</span>
      if (!bucket)
          return vm.sentinelSetBucket();
      return bucket;
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationMapSet(ExecState* exec, JSCell* map, EncodedJSValue key, EncodedJSValue value, int32_t hash)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     auto* bucket = jsCast&lt;JSMap*&gt;(map)-&gt;addNormalized(exec, JSValue::decode(key), JSValue::decode(value), hash);</span>
      if (!bucket)
          return vm.sentinelMapBucket();
      return bucket;
  }
  
<span class="line-modified">! void JIT_OPERATION operationWeakSetAdd(ExecState* exec, JSCell* set, JSCell* key, int32_t hash)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      jsCast&lt;JSWeakSet*&gt;(set)-&gt;add(vm, asObject(key), JSValue(), hash);
  }
  
<span class="line-modified">! void JIT_OPERATION operationWeakMapSet(ExecState* exec, JSCell* map, JSCell* key, EncodedJSValue value, int32_t hash)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      jsCast&lt;JSWeakMap*&gt;(map)-&gt;add(vm, asObject(key), JSValue::decode(value), hash);
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationGetPrototypeOfObject(ExecState* exec, JSObject* thisObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     return JSValue::encode(thisObject-&gt;getPrototype(vm, exec));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationGetPrototypeOf(ExecState* exec, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = JSValue::decode(encodedValue).toThis(exec, StrictMode);</span>
      if (thisValue.isUndefinedOrNull())
<span class="line-modified">!         return throwVMError(exec, scope, createNotAnObjectError(exec, thisValue));</span>
  
      JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, thisValue);
      if (!thisObject) {
<span class="line-modified">!         JSObject* prototype = thisValue.synthesizePrototype(exec);</span>
          EXCEPTION_ASSERT(!!scope.exception() == !prototype);
          if (UNLIKELY(!prototype))
              return JSValue::encode(JSValue());
          return JSValue::encode(prototype);
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(thisObject-&gt;getPrototype(vm, exec)));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationThrowDFG(ExecState* exec, EncodedJSValue valueToThrow)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     scope.throwException(exec, JSValue::decode(valueToThrow));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationThrowStaticError(ExecState* exec, JSString* message, uint32_t errorType)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     String errorMessage = message-&gt;value(exec);</span>
<span class="line-modified">!     scope.throwException(exec, createError(exec, static_cast&lt;ErrorType&gt;(errorType), errorMessage));</span>
  }
  
<span class="line-modified">! extern &quot;C&quot; void JIT_OPERATION triggerReoptimizationNow(CodeBlock* codeBlock, CodeBlock* optimizedCodeBlock, OSRExitBase* exit)</span>
  {
      // It&#39;s sort of preferable that we don&#39;t GC while in here. Anyways, doing so wouldn&#39;t
      // really be profitable.
      DeferGCForAWhile deferGC(codeBlock-&gt;vm().heap);
  
      sanitizeStackForVM(codeBlock-&gt;vm());
  
<span class="line-modified">!     if (Options::verboseOSR())</span>
<span class="line-removed">-         dataLog(*codeBlock, &quot;: Entered reoptimize\n&quot;);</span>
      // We must be called with the baseline code block.
      ASSERT(JITCode::isBaselineCode(codeBlock-&gt;jitType()));
  
      // If I am my own replacement, then reoptimization has already been triggered.
      // This can happen in recursive functions.
      //
      // Note that even if optimizedCodeBlock is an FTLForOSREntry style CodeBlock, this condition is a
      // sure bet that we don&#39;t have anything else left to do.
      CodeBlock* replacement = codeBlock-&gt;replacement();
      if (!replacement || replacement == codeBlock) {
<span class="line-modified">!         if (Options::verboseOSR())</span>
<span class="line-removed">-             dataLog(*codeBlock, &quot;: Not reoptimizing because we&#39;ve already been jettisoned.\n&quot;);</span>
          return;
      }
  
      // Otherwise, the replacement must be optimized code. Use this as an opportunity
      // to check our logic.
<span class="line-new-header">--- 3090,624 ---</span>
              vm, nullptr, 0, structure-&gt;outOfLineCapacity(), true, header,
              sizeof(EncodedJSValue) * length);
      }
  
      // Paradoxically this may allocate a JSArray. That&#39;s totally cool.
<span class="line-modified">!     JSObject* result = JSObject::createRawObject(vm, structure, butterfly);</span>
      return result;
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationNewArrayWithSpreadSlow(JSGlobalObject* globalObject, void* buffer, uint32_t numItems)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      EncodedJSValue* values = static_cast&lt;EncodedJSValue*&gt;(buffer);
      Checked&lt;unsigned, RecordOverflow&gt; checkedLength = 0;
      for (unsigned i = 0; i &lt; numItems; i++) {
          JSValue value = JSValue::decode(values[i]);
<span class="line-modified">!         if (JSImmutableButterfly* array = jsDynamicCast&lt;JSImmutableButterfly*&gt;(vm, value))</span>
<span class="line-modified">!             checkedLength += array-&gt;publicLength();</span>
          else
              ++checkedLength;
      }
  
      if (UNLIKELY(checkedLength.hasOverflowed())) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return nullptr;
      }
  
      unsigned length = checkedLength.unsafeGet();
      if (UNLIKELY(length &gt;= MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return nullptr;
      }
  
      Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous);
  
      JSArray* result = JSArray::tryCreate(vm, structure, length);
      if (UNLIKELY(!result)) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return nullptr;
      }
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      unsigned index = 0;
      for (unsigned i = 0; i &lt; numItems; i++) {
          JSValue value = JSValue::decode(values[i]);
<span class="line-modified">!         if (JSImmutableButterfly* array = jsDynamicCast&lt;JSImmutableButterfly*&gt;(vm, value)) {</span>
              // We are spreading.
<span class="line-modified">!             for (unsigned i = 0; i &lt; array-&gt;publicLength(); i++) {</span>
<span class="line-modified">!                 result-&gt;putDirectIndex(globalObject, index, array-&gt;get(i));</span>
                  RETURN_IF_EXCEPTION(scope, nullptr);
                  ++index;
              }
          } else {
              // We are not spreading.
<span class="line-modified">!             result-&gt;putDirectIndex(globalObject, index, value);</span>
              RETURN_IF_EXCEPTION(scope, nullptr);
              ++index;
          }
      }
  
      return result;
  }
  
<span class="line-modified">! JSCell* operationCreateImmutableButterfly(JSGlobalObject* globalObject, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (JSImmutableButterfly* result = JSImmutableButterfly::tryCreate(vm, vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get(), length))</span>
          return result;
  
<span class="line-modified">!     throwOutOfMemoryError(globalObject, scope);</span>
      return nullptr;
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationSpreadGeneric(JSGlobalObject* globalObject, JSCell* iterable)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      if (isJSArray(iterable)) {
          JSArray* array = jsCast&lt;JSArray*&gt;(iterable);
          if (array-&gt;isIteratorProtocolFastAndNonObservable())
<span class="line-modified">!             RELEASE_AND_RETURN(throwScope, JSImmutableButterfly::createFromArray(globalObject, vm, array));</span>
      }
  
      // FIXME: we can probably make this path faster by having our caller JS code call directly into
      // the iteration protocol builtin: https://bugs.webkit.org/show_bug.cgi?id=164520
  
      JSArray* array;
      {
          JSFunction* iterationFunction = globalObject-&gt;iteratorProtocolFunction();
          CallData callData;
          CallType callType = JSC::getCallData(vm, iterationFunction, callData);
          ASSERT(callType != CallType::None);
  
          MarkedArgumentBuffer arguments;
          arguments.append(iterable);
          ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!         JSValue arrayResult = call(globalObject, iterationFunction, callType, callData, jsNull(), arguments);</span>
          RETURN_IF_EXCEPTION(throwScope, nullptr);
          array = jsCast&lt;JSArray*&gt;(arrayResult);
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(throwScope, JSImmutableButterfly::createFromArray(globalObject, vm, array));</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationSpreadFastArray(JSGlobalObject* globalObject, JSCell* cell)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      ASSERT(isJSArray(cell));
      JSArray* array = jsCast&lt;JSArray*&gt;(cell);
      ASSERT(array-&gt;isIteratorProtocolFastAndNonObservable());
  
<span class="line-modified">!     return JSImmutableButterfly::createFromArray(globalObject, vm, array);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationProcessTypeProfilerLogDFG(VM* vmPointer)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;Log Full, called from inside DFG.&quot;_s);
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationResolveScopeForHoistingFuncDeclInEval(JSGlobalObject* globalObject, JSScope* scope, UniquedStringImpl* impl)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(globalObject, scope, Identifier::fromUid(vm, impl));</span>
      return JSValue::encode(resolvedScope);
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationResolveScope(JSGlobalObject* globalObject, JSScope* scope, UniquedStringImpl* impl)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     JSObject* resolvedScope = JSScope::resolve(globalObject, scope, Identifier::fromUid(vm, impl));</span>
      return resolvedScope;
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationGetDynamicVar(JSGlobalObject* globalObject, JSObject* scope, UniquedStringImpl* impl, unsigned getPutInfoBits)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      Identifier ident = Identifier::fromUid(vm, impl);
<span class="line-modified">!     RELEASE_AND_RETURN(throwScope, JSValue::encode(scope-&gt;getPropertySlot(globalObject, ident, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {</span>
          if (!found) {
              GetPutInfo getPutInfo(getPutInfoBits);
              if (getPutInfo.resolveMode() == ThrowIfNotFound)
<span class="line-modified">!                 throwException(globalObject, throwScope, createUndefinedVariableError(globalObject, ident));</span>
              return jsUndefined();
          }
  
          if (scope-&gt;isGlobalLexicalEnvironment()) {
              // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
<span class="line-modified">!             JSValue result = slot.getValue(globalObject, ident);</span>
              if (result == jsTDZValue()) {
<span class="line-modified">!                 throwException(globalObject, throwScope, createTDZError(globalObject));</span>
                  return jsUndefined();
              }
              return result;
          }
  
<span class="line-modified">!         return slot.getValue(globalObject, ident);</span>
      })));
  }
  
<span class="line-modified">! ALWAYS_INLINE static void putDynamicVar(JSGlobalObject* globalObject, VM&amp; vm, JSObject* scope, EncodedJSValue value, UniquedStringImpl* impl, unsigned getPutInfoBits, bool isStrictMode)</span>
  {
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      const Identifier&amp; ident = Identifier::fromUid(vm, impl);
      GetPutInfo getPutInfo(getPutInfoBits);
<span class="line-modified">!     bool hasProperty = scope-&gt;hasProperty(globalObject, ident);</span>
      RETURN_IF_EXCEPTION(throwScope, void());
      if (hasProperty
          &amp;&amp; scope-&gt;isGlobalLexicalEnvironment()
          &amp;&amp; !isInitialization(getPutInfo.initializationMode())) {
          // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
          PropertySlot slot(scope, PropertySlot::InternalMethodType::Get);
<span class="line-modified">!         JSGlobalLexicalEnvironment::getOwnPropertySlot(scope, globalObject, ident, slot);</span>
<span class="line-modified">!         if (slot.getValue(globalObject, ident) == jsTDZValue()) {</span>
<span class="line-modified">!             throwException(globalObject, throwScope, createTDZError(globalObject));</span>
              return;
          }
      }
  
      if (getPutInfo.resolveMode() == ThrowIfNotFound &amp;&amp; !hasProperty) {
<span class="line-modified">!         throwException(globalObject, throwScope, createUndefinedVariableError(globalObject, ident));</span>
          return;
      }
  
      PutPropertySlot slot(scope, isStrictMode, PutPropertySlot::UnknownContext, isInitialization(getPutInfo.initializationMode()));
      throwScope.release();
<span class="line-modified">!     scope-&gt;methodTable(vm)-&gt;put(scope, globalObject, ident, JSValue::decode(value), slot);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutDynamicVarStrict(JSGlobalObject* globalObject, JSObject* scope, EncodedJSValue value, UniquedStringImpl* impl, unsigned getPutInfoBits)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      constexpr bool isStrictMode = true;
<span class="line-modified">!     return putDynamicVar(globalObject, vm, scope, value, impl, getPutInfoBits, isStrictMode);</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutDynamicVarNonStrict(JSGlobalObject* globalObject, JSObject* scope, EncodedJSValue value, UniquedStringImpl* impl, unsigned getPutInfoBits)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      constexpr bool isStrictMode = false;
<span class="line-modified">!     return putDynamicVar(globalObject, vm, scope, value, impl, getPutInfoBits, isStrictMode);</span>
  }
  
<span class="line-modified">! int32_t JIT_OPERATION operationMapHash(JSGlobalObject* globalObject, EncodedJSValue input)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
<span class="line-modified">!     return jsMapHash(globalObject, vm, JSValue::decode(input));</span>
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationJSMapFindBucket(JSGlobalObject* globalObject, JSCell* map, EncodedJSValue key, int32_t hash)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     JSMap::BucketType** bucket = jsCast&lt;JSMap*&gt;(map)-&gt;findBucket(globalObject, JSValue::decode(key), hash);</span>
      if (!bucket)
          return vm.sentinelMapBucket();
      return *bucket;
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationJSSetFindBucket(JSGlobalObject* globalObject, JSCell* map, EncodedJSValue key, int32_t hash)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     JSSet::BucketType** bucket = jsCast&lt;JSSet*&gt;(map)-&gt;findBucket(globalObject, JSValue::decode(key), hash);</span>
      if (!bucket)
          return vm.sentinelSetBucket();
      return *bucket;
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationSetAdd(JSGlobalObject* globalObject, JSCell* set, EncodedJSValue key, int32_t hash)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     auto* bucket = jsCast&lt;JSSet*&gt;(set)-&gt;addNormalized(globalObject, JSValue::decode(key), JSValue(), hash);</span>
      if (!bucket)
          return vm.sentinelSetBucket();
      return bucket;
  }
  
<span class="line-modified">! JSCell* JIT_OPERATION operationMapSet(JSGlobalObject* globalObject, JSCell* map, EncodedJSValue key, EncodedJSValue value, int32_t hash)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     auto* bucket = jsCast&lt;JSMap*&gt;(map)-&gt;addNormalized(globalObject, JSValue::decode(key), JSValue::decode(value), hash);</span>
      if (!bucket)
          return vm.sentinelMapBucket();
      return bucket;
  }
  
<span class="line-modified">! void JIT_OPERATION operationWeakSetAdd(VM* vmPointer, JSCell* set, JSCell* key, int32_t hash)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      jsCast&lt;JSWeakSet*&gt;(set)-&gt;add(vm, asObject(key), JSValue(), hash);
  }
  
<span class="line-modified">! void JIT_OPERATION operationWeakMapSet(VM* vmPointer, JSCell* map, JSCell* key, EncodedJSValue value, int32_t hash)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      jsCast&lt;JSWeakMap*&gt;(map)-&gt;add(vm, asObject(key), JSValue::decode(value), hash);
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationGetPrototypeOfObject(JSGlobalObject* globalObject, JSObject* thisObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     return JSValue::encode(thisObject-&gt;getPrototype(vm, globalObject));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationGetPrototypeOf(JSGlobalObject* globalObject, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = JSValue::decode(encodedValue).toThis(globalObject, StrictMode);</span>
      if (thisValue.isUndefinedOrNull())
<span class="line-modified">!         return throwVMError(globalObject, scope, createNotAnObjectError(globalObject, thisValue));</span>
  
      JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, thisValue);
      if (!thisObject) {
<span class="line-modified">!         JSObject* prototype = thisValue.synthesizePrototype(globalObject);</span>
          EXCEPTION_ASSERT(!!scope.exception() == !prototype);
          if (UNLIKELY(!prototype))
              return JSValue::encode(JSValue());
          return JSValue::encode(prototype);
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(thisObject-&gt;getPrototype(vm, globalObject)));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JIT_OPERATION operationDateGetFullYear(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = *vmPointer;</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);</span>
<span class="line-added">+     if (!gregorianDateTime)</span>
<span class="line-added">+         return JSValue::encode(jsNaN());</span>
<span class="line-added">+     return JSValue::encode(jsNumber(gregorianDateTime-&gt;year()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JIT_OPERATION operationDateGetUTCFullYear(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = *vmPointer;</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTimeUTC(vm);</span>
<span class="line-added">+     if (!gregorianDateTime)</span>
<span class="line-added">+         return JSValue::encode(jsNaN());</span>
<span class="line-added">+     return JSValue::encode(jsNumber(gregorianDateTime-&gt;year()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JIT_OPERATION operationDateGetMonth(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = *vmPointer;</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);</span>
<span class="line-added">+     if (!gregorianDateTime)</span>
<span class="line-added">+         return JSValue::encode(jsNaN());</span>
<span class="line-added">+     return JSValue::encode(jsNumber(gregorianDateTime-&gt;month()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JIT_OPERATION operationDateGetUTCMonth(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = *vmPointer;</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTimeUTC(vm);</span>
<span class="line-added">+     if (!gregorianDateTime)</span>
<span class="line-added">+         return JSValue::encode(jsNaN());</span>
<span class="line-added">+     return JSValue::encode(jsNumber(gregorianDateTime-&gt;month()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JIT_OPERATION operationDateGetDate(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = *vmPointer;</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);</span>
<span class="line-added">+     if (!gregorianDateTime)</span>
<span class="line-added">+         return JSValue::encode(jsNaN());</span>
<span class="line-added">+     return JSValue::encode(jsNumber(gregorianDateTime-&gt;monthDay()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JIT_OPERATION operationDateGetUTCDate(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = *vmPointer;</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTimeUTC(vm);</span>
<span class="line-added">+     if (!gregorianDateTime)</span>
<span class="line-added">+         return JSValue::encode(jsNaN());</span>
<span class="line-added">+     return JSValue::encode(jsNumber(gregorianDateTime-&gt;monthDay()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JIT_OPERATION operationDateGetDay(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = *vmPointer;</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);</span>
<span class="line-added">+     if (!gregorianDateTime)</span>
<span class="line-added">+         return JSValue::encode(jsNaN());</span>
<span class="line-added">+     return JSValue::encode(jsNumber(gregorianDateTime-&gt;weekDay()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JIT_OPERATION operationDateGetUTCDay(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = *vmPointer;</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTimeUTC(vm);</span>
<span class="line-added">+     if (!gregorianDateTime)</span>
<span class="line-added">+         return JSValue::encode(jsNaN());</span>
<span class="line-added">+     return JSValue::encode(jsNumber(gregorianDateTime-&gt;weekDay()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JIT_OPERATION operationDateGetHours(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = *vmPointer;</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);</span>
<span class="line-added">+     if (!gregorianDateTime)</span>
<span class="line-added">+         return JSValue::encode(jsNaN());</span>
<span class="line-added">+     return JSValue::encode(jsNumber(gregorianDateTime-&gt;hour()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JIT_OPERATION operationDateGetUTCHours(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = *vmPointer;</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTimeUTC(vm);</span>
<span class="line-added">+     if (!gregorianDateTime)</span>
<span class="line-added">+         return JSValue::encode(jsNaN());</span>
<span class="line-added">+     return JSValue::encode(jsNumber(gregorianDateTime-&gt;hour()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JIT_OPERATION operationDateGetMinutes(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = *vmPointer;</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);</span>
<span class="line-added">+     if (!gregorianDateTime)</span>
<span class="line-added">+         return JSValue::encode(jsNaN());</span>
<span class="line-added">+     return JSValue::encode(jsNumber(gregorianDateTime-&gt;minute()));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationDateGetUTCMinutes(VM* vmPointer, DateInstance* date)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTimeUTC(vm);</span>
<span class="line-added">+     if (!gregorianDateTime)</span>
<span class="line-added">+         return JSValue::encode(jsNaN());</span>
<span class="line-added">+     return JSValue::encode(jsNumber(gregorianDateTime-&gt;minute()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JIT_OPERATION operationDateGetSeconds(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = *vmPointer;</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);</span>
<span class="line-added">+     if (!gregorianDateTime)</span>
<span class="line-added">+         return JSValue::encode(jsNaN());</span>
<span class="line-added">+     return JSValue::encode(jsNumber(gregorianDateTime-&gt;second()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JIT_OPERATION operationDateGetUTCSeconds(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = *vmPointer;</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTimeUTC(vm);</span>
<span class="line-added">+     if (!gregorianDateTime)</span>
<span class="line-added">+         return JSValue::encode(jsNaN());</span>
<span class="line-added">+     return JSValue::encode(jsNumber(gregorianDateTime-&gt;second()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JIT_OPERATION operationDateGetTimezoneOffset(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = *vmPointer;</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);</span>
<span class="line-added">+     if (!gregorianDateTime)</span>
<span class="line-added">+         return JSValue::encode(jsNaN());</span>
<span class="line-added">+     return JSValue::encode(jsNumber(-gregorianDateTime-&gt;utcOffsetInMinute()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JIT_OPERATION operationDateGetYear(VM* vmPointer, DateInstance* date)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = *vmPointer;</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     const GregorianDateTime* gregorianDateTime = date-&gt;gregorianDateTime(vm);</span>
<span class="line-added">+     if (!gregorianDateTime)</span>
<span class="line-added">+         return JSValue::encode(jsNaN());</span>
<span class="line-added">+     return JSValue::encode(jsNumber(gregorianDateTime-&gt;year() - 1900));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JIT_OPERATION operationThrowDFG(JSGlobalObject* globalObject, EncodedJSValue valueToThrow)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     scope.throwException(globalObject, JSValue::decode(valueToThrow));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationThrowStaticError(JSGlobalObject* globalObject, JSString* message, uint32_t errorType)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     String errorMessage = message-&gt;value(globalObject);</span>
<span class="line-modified">!     scope.throwException(globalObject, createError(globalObject, static_cast&lt;ErrorType&gt;(errorType), errorMessage));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationLinkDirectCall(CallLinkInfo* callLinkInfo, JSFunction* callee)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     JSGlobalObject* globalObject = callee-&gt;globalObject();</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+     CodeSpecializationKind kind = callLinkInfo-&gt;specializationKind();</span>
<span class="line-added">+ </span>
<span class="line-added">+     RELEASE_ASSERT(callLinkInfo-&gt;isDirect());</span>
<span class="line-added">+ </span>
<span class="line-added">+     // This would happen if the executable died during GC but the CodeBlock did not die. That should</span>
<span class="line-added">+     // not happen because the CodeBlock should have a weak reference to any executable it uses for</span>
<span class="line-added">+     // this purpose.</span>
<span class="line-added">+     RELEASE_ASSERT(callLinkInfo-&gt;executable());</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Having a CodeBlock indicates that this is linked. We shouldn&#39;t be taking this path if it&#39;s</span>
<span class="line-added">+     // linked.</span>
<span class="line-added">+     RELEASE_ASSERT(!callLinkInfo-&gt;codeBlock());</span>
<span class="line-added">+ </span>
<span class="line-added">+     // We just don&#39;t support this yet.</span>
<span class="line-added">+     RELEASE_ASSERT(!callLinkInfo-&gt;isVarargs());</span>
<span class="line-added">+ </span>
<span class="line-added">+     ExecutableBase* executable = callLinkInfo-&gt;executable();</span>
<span class="line-added">+     RELEASE_ASSERT(callee-&gt;executable() == callLinkInfo-&gt;executable());</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSScope* scope = callee-&gt;scopeUnchecked();</span>
<span class="line-added">+ </span>
<span class="line-added">+     MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr;</span>
<span class="line-added">+     CodeBlock* codeBlock = nullptr;</span>
<span class="line-added">+     if (executable-&gt;isHostFunction())</span>
<span class="line-added">+         codePtr = executable-&gt;entrypointFor(kind, MustCheckArity);</span>
<span class="line-added">+     else {</span>
<span class="line-added">+         FunctionExecutable* functionExecutable = static_cast&lt;FunctionExecutable*&gt;(executable);</span>
<span class="line-added">+ </span>
<span class="line-added">+         RELEASE_ASSERT(isCall(kind) || functionExecutable-&gt;constructAbility() != ConstructAbility::CannotConstruct);</span>
<span class="line-added">+ </span>
<span class="line-added">+         Exception* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, callee, scope, kind, codeBlock);</span>
<span class="line-added">+         EXCEPTION_ASSERT_UNUSED(throwScope, throwScope.exception() == error);</span>
<span class="line-added">+         if (UNLIKELY(error))</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         unsigned argumentStackSlots = callLinkInfo-&gt;maxArgumentCountIncludingThis();</span>
<span class="line-added">+         if (argumentStackSlots &lt; static_cast&lt;size_t&gt;(codeBlock-&gt;numParameters()))</span>
<span class="line-added">+             codePtr = functionExecutable-&gt;entrypointFor(kind, MustCheckArity);</span>
<span class="line-added">+         else</span>
<span class="line-added">+             codePtr = functionExecutable-&gt;entrypointFor(kind, ArityCheckNotRequired);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     linkDirectFor(callFrame, *callLinkInfo, codeBlock, codePtr);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void triggerReoptimizationNow(CodeBlock* codeBlock, CodeBlock* optimizedCodeBlock, OSRExitBase* exit)</span>
  {
      // It&#39;s sort of preferable that we don&#39;t GC while in here. Anyways, doing so wouldn&#39;t
      // really be profitable.
      DeferGCForAWhile deferGC(codeBlock-&gt;vm().heap);
  
      sanitizeStackForVM(codeBlock-&gt;vm());
  
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(), *codeBlock, &quot;: Entered reoptimize&quot;);</span>
      // We must be called with the baseline code block.
      ASSERT(JITCode::isBaselineCode(codeBlock-&gt;jitType()));
  
      // If I am my own replacement, then reoptimization has already been triggered.
      // This can happen in recursive functions.
      //
      // Note that even if optimizedCodeBlock is an FTLForOSREntry style CodeBlock, this condition is a
      // sure bet that we don&#39;t have anything else left to do.
      CodeBlock* replacement = codeBlock-&gt;replacement();
      if (!replacement || replacement == codeBlock) {
<span class="line-modified">!         dataLogLnIf(Options::verboseOSR(), *codeBlock, &quot;: Not reoptimizing because we&#39;ve already been jettisoned.&quot;);</span>
          return;
      }
  
      // Otherwise, the replacement must be optimized code. Use this as an opportunity
      // to check our logic.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3147,35 ***</span>
      bool didGetStuckInLoop =
          (codeBlock-&gt;checkIfOptimizationThresholdReached() || didTryToEnterIntoInlinedLoops)
          &amp;&amp; optimizedCodeBlock-&gt;shouldReoptimizeFromLoopNow();
  
      if (!didExitABunch &amp;&amp; !didGetStuckInLoop) {
<span class="line-modified">!         if (Options::verboseOSR())</span>
<span class="line-removed">-             dataLog(*codeBlock, &quot;: Not reoptimizing &quot;, *optimizedCodeBlock, &quot; because it either didn&#39;t exit enough or didn&#39;t loop enough after exit.\n&quot;);</span>
          codeBlock-&gt;optimizeAfterLongWarmUp();
          return;
      }
  
      optimizedCodeBlock-&gt;jettison(Profiler::JettisonDueToOSRExit, CountReoptimization);
  }
  
  #if ENABLE(FTL_JIT)
  static bool shouldTriggerFTLCompile(CodeBlock* codeBlock, JITCode* jitCode)
  {
      if (codeBlock-&gt;baselineVersion()-&gt;m_didFailFTLCompilation) {
          CODEBLOCK_LOG_EVENT(codeBlock, &quot;abortFTLCompile&quot;, ());
<span class="line-modified">!         if (Options::verboseOSR())</span>
<span class="line-removed">-             dataLog(&quot;Deferring FTL-optimization of &quot;, *codeBlock, &quot; indefinitely because there was an FTL failure.\n&quot;);</span>
          jitCode-&gt;dontOptimizeAnytimeSoon(codeBlock);
          return false;
      }
  
      if (!codeBlock-&gt;hasOptimizedReplacement()
          &amp;&amp; !jitCode-&gt;checkIfOptimizationThresholdReached(codeBlock)) {
          CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;counter = &quot;, jitCode-&gt;tierUpCounter));
<span class="line-modified">!         if (Options::verboseOSR())</span>
<span class="line-removed">-             dataLog(&quot;Choosing not to FTL-optimize &quot;, *codeBlock, &quot; yet.\n&quot;);</span>
          return false;
      }
      return true;
  }
  
<span class="line-new-header">--- 3729,37 ---</span>
      bool didGetStuckInLoop =
          (codeBlock-&gt;checkIfOptimizationThresholdReached() || didTryToEnterIntoInlinedLoops)
          &amp;&amp; optimizedCodeBlock-&gt;shouldReoptimizeFromLoopNow();
  
      if (!didExitABunch &amp;&amp; !didGetStuckInLoop) {
<span class="line-modified">!         dataLogLnIf(Options::verboseOSR(), *codeBlock, &quot;: Not reoptimizing &quot;, *optimizedCodeBlock, &quot; because it either didn&#39;t exit enough or didn&#39;t loop enough after exit.&quot;);</span>
          codeBlock-&gt;optimizeAfterLongWarmUp();
          return;
      }
  
      optimizedCodeBlock-&gt;jettison(Profiler::JettisonDueToOSRExit, CountReoptimization);
  }
  
<span class="line-added">+ void JIT_OPERATION operationTriggerReoptimizationNow(CodeBlock* codeBlock, CodeBlock* optimizedCodeBlock, OSRExitBase* exit)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     triggerReoptimizationNow(codeBlock, optimizedCodeBlock, exit);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #if ENABLE(FTL_JIT)
  static bool shouldTriggerFTLCompile(CodeBlock* codeBlock, JITCode* jitCode)
  {
      if (codeBlock-&gt;baselineVersion()-&gt;m_didFailFTLCompilation) {
          CODEBLOCK_LOG_EVENT(codeBlock, &quot;abortFTLCompile&quot;, ());
<span class="line-modified">!         dataLogLnIf(Options::verboseOSR(), &quot;Deferring FTL-optimization of &quot;, *codeBlock, &quot; indefinitely because there was an FTL failure.&quot;);</span>
          jitCode-&gt;dontOptimizeAnytimeSoon(codeBlock);
          return false;
      }
  
      if (!codeBlock-&gt;hasOptimizedReplacement()
          &amp;&amp; !jitCode-&gt;checkIfOptimizationThresholdReached(codeBlock)) {
          CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;counter = &quot;, jitCode-&gt;tierUpCounter));
<span class="line-modified">!         dataLogLnIf(Options::verboseOSR(), &quot;Choosing not to FTL-optimize &quot;, *codeBlock, &quot; yet.&quot;);</span>
          return false;
      }
      return true;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3213,47 ***</span>
  
      if (worklistState == Worklist::Compiled) {
          CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;compiled and failed&quot;));
          // This means that we finished compiling, but failed somehow; in that case the
          // thresholds will be set appropriately.
<span class="line-modified">!         if (Options::verboseOSR())</span>
<span class="line-removed">-             dataLog(&quot;Code block &quot;, *codeBlock, &quot; was compiled but it doesn&#39;t have an optimized replacement.\n&quot;);</span>
          return;
      }
  
      CODEBLOCK_LOG_EVENT(codeBlock, &quot;triggerFTLReplacement&quot;, ());
      // We need to compile the code.
      compile(
<span class="line-modified">!         vm, codeBlock-&gt;newReplacement(), codeBlock, FTLMode, UINT_MAX,</span>
          Operands&lt;Optional&lt;JSValue&gt;&gt;(), ToFTLDeferredCompilationCallback::create());
  
      // If we reached here, the counter has not be reset. Do that now.
      jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
          codeBlock, CompilationDeferred);
  }
  
<span class="line-modified">! void JIT_OPERATION triggerTierUpNow(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      DeferGCForAWhile deferGC(vm.heap);
<span class="line-modified">!     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
  
      sanitizeStackForVM(vm);
  
      if (codeBlock-&gt;jitType() != JITType::DFGJIT) {
          dataLog(&quot;Unexpected code block in DFG-&gt;FTL tier-up: &quot;, *codeBlock, &quot;\n&quot;);
          RELEASE_ASSERT_NOT_REACHED();
      }
  
      JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
  
<span class="line-modified">!     if (Options::verboseOSR()) {</span>
<span class="line-modified">!         dataLog(</span>
<span class="line-removed">-             *codeBlock, &quot;: Entered triggerTierUpNow with executeCounter = &quot;,</span>
<span class="line-removed">-             jitCode-&gt;tierUpCounter, &quot;\n&quot;);</span>
<span class="line-removed">-     }</span>
  
      if (shouldTriggerFTLCompile(codeBlock, jitCode))
          triggerFTLReplacementCompile(vm, codeBlock, jitCode);
  
      if (codeBlock-&gt;hasOptimizedReplacement()) {
<span class="line-new-header">--- 3797,44 ---</span>
  
      if (worklistState == Worklist::Compiled) {
          CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;compiled and failed&quot;));
          // This means that we finished compiling, but failed somehow; in that case the
          // thresholds will be set appropriately.
<span class="line-modified">!         dataLogLnIf(Options::verboseOSR(), &quot;Code block &quot;, *codeBlock, &quot; was compiled but it doesn&#39;t have an optimized replacement.&quot;);</span>
          return;
      }
  
      CODEBLOCK_LOG_EVENT(codeBlock, &quot;triggerFTLReplacement&quot;, ());
      // We need to compile the code.
      compile(
<span class="line-modified">!         vm, codeBlock-&gt;newReplacement(), codeBlock, FTLMode, BytecodeIndex(),</span>
          Operands&lt;Optional&lt;JSValue&gt;&gt;(), ToFTLDeferredCompilationCallback::create());
  
      // If we reached here, the counter has not be reset. Do that now.
      jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
          codeBlock, CompilationDeferred);
  }
  
<span class="line-modified">! void JIT_OPERATION operationTriggerTierUpNow(VM* vmPointer)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      DeferGCForAWhile deferGC(vm.heap);
<span class="line-modified">!     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
  
      sanitizeStackForVM(vm);
  
      if (codeBlock-&gt;jitType() != JITType::DFGJIT) {
          dataLog(&quot;Unexpected code block in DFG-&gt;FTL tier-up: &quot;, *codeBlock, &quot;\n&quot;);
          RELEASE_ASSERT_NOT_REACHED();
      }
  
      JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
  
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(),</span>
<span class="line-modified">!         *codeBlock, &quot;: Entered triggerTierUpNow with executeCounter = &quot;, jitCode-&gt;tierUpCounter);</span>
  
      if (shouldTriggerFTLCompile(codeBlock, jitCode))
          triggerFTLReplacementCompile(vm, codeBlock, jitCode);
  
      if (codeBlock-&gt;hasOptimizedReplacement()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3274,14 ***</span>
              return;
          }
      }
  }
  
<span class="line-modified">! static char* tierUpCommon(ExecState* exec, unsigned originBytecodeIndex, bool canOSREnterHere)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">-     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
  
      // Resolve any pending plan for OSR Enter on this function.
      Worklist::State worklistState;
      if (Worklist* worklist = existingGlobalFTLWorklistOrNull()) {
          worklistState = worklist-&gt;completeAllReadyPlansForVM(
<span class="line-new-header">--- 3855,13 ---</span>
              return;
          }
      }
  }
  
<span class="line-modified">! static char* tierUpCommon(VM&amp; vm, CallFrame* callFrame, BytecodeIndex originBytecodeIndex, bool canOSREnterHere)</span>
  {
<span class="line-modified">!     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
  
      // Resolve any pending plan for OSR Enter on this function.
      Worklist::State worklistState;
      if (Worklist* worklist = existingGlobalFTLWorklistOrNull()) {
          worklistState = worklist-&gt;completeAllReadyPlansForVM(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3325,25 ***</span>
      if (canOSREnterHere) {
          auto iter = jitCode-&gt;bytecodeIndexToStreamIndex.find(originBytecodeIndex);
          if (iter != jitCode-&gt;bytecodeIndexToStreamIndex.end()) {
              unsigned streamIndex = iter-&gt;value;
              if (CodeBlock* entryBlock = jitCode-&gt;osrEntryBlock()) {
<span class="line-modified">!                 if (Options::verboseOSR())</span>
<span class="line-modified">!                     dataLog(&quot;OSR entry: From &quot;, RawPointer(jitCode), &quot; got entry block &quot;, RawPointer(entryBlock), &quot;\n&quot;);</span>
<span class="line-modified">!                 if (void* address = FTL::prepareOSREntry(exec, codeBlock, entryBlock, originBytecodeIndex, streamIndex)) {</span>
<span class="line-modified">!                     CODEBLOCK_LOG_EVENT(entryBlock, &quot;osrEntry&quot;, (&quot;at bc#&quot;, originBytecodeIndex));</span>
<span class="line-removed">-                     return retagCodePtr&lt;char*&gt;(address, JSEntryPtrTag, bitwise_cast&lt;PtrTag&gt;(exec));</span>
                  }
              }
          }
      }
  
      if (worklistState == Worklist::Compiled) {
          CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;compiled and failed&quot;));
          // This means that compilation failed and we already set the thresholds.
<span class="line-modified">!         if (Options::verboseOSR())</span>
<span class="line-removed">-             dataLog(&quot;Code block &quot;, *codeBlock, &quot; was compiled but it doesn&#39;t have an optimized replacement.\n&quot;);</span>
          return nullptr;
      }
  
      // - If we don&#39;t have an FTL code block, then try to compile one.
      // - If we do have an FTL code block, then try to enter for a while.
<span class="line-new-header">--- 3905,23 ---</span>
      if (canOSREnterHere) {
          auto iter = jitCode-&gt;bytecodeIndexToStreamIndex.find(originBytecodeIndex);
          if (iter != jitCode-&gt;bytecodeIndexToStreamIndex.end()) {
              unsigned streamIndex = iter-&gt;value;
              if (CodeBlock* entryBlock = jitCode-&gt;osrEntryBlock()) {
<span class="line-modified">!                 dataLogLnIf(Options::verboseOSR(), &quot;OSR entry: From &quot;, RawPointer(jitCode), &quot; got entry block &quot;, RawPointer(entryBlock));</span>
<span class="line-modified">!                 if (void* address = FTL::prepareOSREntry(vm, callFrame, codeBlock, entryBlock, originBytecodeIndex, streamIndex)) {</span>
<span class="line-modified">!                     CODEBLOCK_LOG_EVENT(entryBlock, &quot;osrEntry&quot;, (&quot;at &quot;, originBytecodeIndex));</span>
<span class="line-modified">!                     return retagCodePtr&lt;char*&gt;(address, JSEntryPtrTag, bitwise_cast&lt;PtrTag&gt;(callFrame));</span>
                  }
              }
          }
      }
  
      if (worklistState == Worklist::Compiled) {
          CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;compiled and failed&quot;));
          // This means that compilation failed and we already set the thresholds.
<span class="line-modified">!         dataLogLnIf(Options::verboseOSR(), &quot;Code block &quot;, *codeBlock, &quot; was compiled but it doesn&#39;t have an optimized replacement.&quot;);</span>
          return nullptr;
      }
  
      // - If we don&#39;t have an FTL code block, then try to compile one.
      // - If we do have an FTL code block, then try to enter for a while.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3413,23 ***</span>
              // immediately when program control reaches it. If program control is taking too long to reach that
              // outer loop, we progressively move inwards, meaning, we&#39;ll eventually trigger some loop that is
              // executing to compile. We start with trying to compile outer loops since we believe outer loop
              // compilations reveal the best opportunities for optimizing code.
              for (auto iter = tierUpHierarchyEntry-&gt;value.rbegin(), end = tierUpHierarchyEntry-&gt;value.rend(); iter != end; ++iter) {
<span class="line-modified">!                 unsigned osrEntryCandidate = *iter;</span>
  
                  if (jitCode-&gt;tierUpEntryTriggers.get(osrEntryCandidate) == JITCode::TriggerReason::StartCompilation) {
                      // This means that we already asked this loop to compile. If we&#39;ve reached here, it
                      // means program control has not yet reached that loop. So it&#39;s taking too long to compile.
                      // So we move on to asking the inner loop of this loop to compile itself.
                      continue;
                  }
  
                  // This is where we ask the outer to loop to immediately compile itself if program
                  // control reaches it.
<span class="line-modified">!                 if (Options::verboseOSR())</span>
<span class="line-removed">-                     dataLog(&quot;Inner-loop bc#&quot;, originBytecodeIndex, &quot; in &quot;, *codeBlock, &quot; setting parent loop bc#&quot;, osrEntryCandidate, &quot;&#39;s trigger and backing off.\n&quot;);</span>
                  jitCode-&gt;tierUpEntryTriggers.set(osrEntryCandidate, JITCode::TriggerReason::StartCompilation);
                  return true;
              }
  
              return false;
<span class="line-new-header">--- 3991,22 ---</span>
              // immediately when program control reaches it. If program control is taking too long to reach that
              // outer loop, we progressively move inwards, meaning, we&#39;ll eventually trigger some loop that is
              // executing to compile. We start with trying to compile outer loops since we believe outer loop
              // compilations reveal the best opportunities for optimizing code.
              for (auto iter = tierUpHierarchyEntry-&gt;value.rbegin(), end = tierUpHierarchyEntry-&gt;value.rend(); iter != end; ++iter) {
<span class="line-modified">!                 BytecodeIndex osrEntryCandidate = *iter;</span>
  
                  if (jitCode-&gt;tierUpEntryTriggers.get(osrEntryCandidate) == JITCode::TriggerReason::StartCompilation) {
                      // This means that we already asked this loop to compile. If we&#39;ve reached here, it
                      // means program control has not yet reached that loop. So it&#39;s taking too long to compile.
                      // So we move on to asking the inner loop of this loop to compile itself.
                      continue;
                  }
  
                  // This is where we ask the outer to loop to immediately compile itself if program
                  // control reaches it.
<span class="line-modified">!                 dataLogLnIf(Options::verboseOSR(), &quot;Inner-loop &quot;, originBytecodeIndex, &quot; in &quot;, *codeBlock, &quot; setting parent loop &quot;, osrEntryCandidate, &quot;&#39;s trigger and backing off.&quot;);</span>
                  jitCode-&gt;tierUpEntryTriggers.set(osrEntryCandidate, JITCode::TriggerReason::StartCompilation);
                  return true;
              }
  
              return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3457,12 ***</span>
  
      JITCode::TriggerReason* triggerAddress = &amp;(triggerIterator-&gt;value);
  
      Operands&lt;Optional&lt;JSValue&gt;&gt; mustHandleValues;
      unsigned streamIndex = jitCode-&gt;bytecodeIndexToStreamIndex.get(originBytecodeIndex);
<span class="line-modified">!     jitCode-&gt;reconstruct(</span>
<span class="line-removed">-         exec, codeBlock, CodeOrigin(originBytecodeIndex), streamIndex, mustHandleValues);</span>
      CodeBlock* replacementCodeBlock = codeBlock-&gt;newReplacement();
  
      CODEBLOCK_LOG_EVENT(codeBlock, &quot;triggerFTLOSR&quot;, ());
      CompilationResult forEntryResult = compile(
          vm, replacementCodeBlock, codeBlock, FTLForOSREntryMode, originBytecodeIndex,
<span class="line-new-header">--- 4034,11 ---</span>
  
      JITCode::TriggerReason* triggerAddress = &amp;(triggerIterator-&gt;value);
  
      Operands&lt;Optional&lt;JSValue&gt;&gt; mustHandleValues;
      unsigned streamIndex = jitCode-&gt;bytecodeIndexToStreamIndex.get(originBytecodeIndex);
<span class="line-modified">!     jitCode-&gt;reconstruct(callFrame, codeBlock, CodeOrigin(originBytecodeIndex), streamIndex, mustHandleValues);</span>
      CodeBlock* replacementCodeBlock = codeBlock-&gt;newReplacement();
  
      CODEBLOCK_LOG_EVENT(codeBlock, &quot;triggerFTLOSR&quot;, ());
      CompilationResult forEntryResult = compile(
          vm, replacementCodeBlock, codeBlock, FTLForOSREntryMode, originBytecodeIndex,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3476,86 ***</span>
          jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
              codeBlock, CompilationDeferred);
          return nullptr;
      }
  
<span class="line-modified">!     CODEBLOCK_LOG_EVENT(jitCode-&gt;osrEntryBlock(), &quot;osrEntry&quot;, (&quot;at bc#&quot;, originBytecodeIndex));</span>
      // It&#39;s possible that the for-entry compile already succeeded. In that case OSR
      // entry will succeed unless we ran out of stack. It&#39;s not clear what we should do.
      // We signal to try again after a while if that happens.
<span class="line-modified">!     if (Options::verboseOSR())</span>
<span class="line-removed">-         dataLog(&quot;Immediate OSR entry: From &quot;, RawPointer(jitCode), &quot; got entry block &quot;, RawPointer(jitCode-&gt;osrEntryBlock()), &quot;\n&quot;);</span>
  
<span class="line-modified">!     void* address = FTL::prepareOSREntry(</span>
<span class="line-removed">-         exec, codeBlock, jitCode-&gt;osrEntryBlock(), originBytecodeIndex, streamIndex);</span>
      if (!address)
          return nullptr;
<span class="line-modified">!     return retagCodePtr&lt;char*&gt;(address, JSEntryPtrTag, bitwise_cast&lt;PtrTag&gt;(exec));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION triggerTierUpNowInLoop(ExecState* exec, unsigned bytecodeIndex)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      DeferGCForAWhile deferGC(vm.heap);
<span class="line-modified">!     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
  
      sanitizeStackForVM(vm);
  
      if (codeBlock-&gt;jitType() != JITType::DFGJIT) {
<span class="line-modified">!         dataLog(&quot;Unexpected code block in DFG-&gt;FTL trigger tier up now in loop: &quot;, *codeBlock, &quot;\n&quot;);</span>
          RELEASE_ASSERT_NOT_REACHED();
      }
  
      JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
  
<span class="line-modified">!     if (Options::verboseOSR()) {</span>
<span class="line-removed">-         dataLog(</span>
<span class="line-removed">-             *codeBlock, &quot;: Entered triggerTierUpNowInLoop with executeCounter = &quot;,</span>
<span class="line-removed">-             jitCode-&gt;tierUpCounter, &quot;\n&quot;);</span>
<span class="line-removed">-     }</span>
  
      if (jitCode-&gt;tierUpInLoopHierarchy.contains(bytecodeIndex))
<span class="line-modified">!         tierUpCommon(exec, bytecodeIndex, false);</span>
      else if (shouldTriggerFTLCompile(codeBlock, jitCode))
          triggerFTLReplacementCompile(vm, codeBlock, jitCode);
  
      // Since we cannot OSR Enter here, the default &quot;optimizeSoon()&quot; is not useful.
      if (codeBlock-&gt;hasOptimizedReplacement()) {
          CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;OSR in loop failed, deferring&quot;));
          jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(codeBlock, CompilationDeferred);
      }
  }
  
<span class="line-modified">! char* JIT_OPERATION triggerOSREntryNow(ExecState* exec, unsigned bytecodeIndex)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      DeferGCForAWhile deferGC(vm.heap);
<span class="line-modified">!     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
  
      sanitizeStackForVM(vm);
  
      if (codeBlock-&gt;jitType() != JITType::DFGJIT) {
          dataLog(&quot;Unexpected code block in DFG-&gt;FTL tier-up: &quot;, *codeBlock, &quot;\n&quot;);
          RELEASE_ASSERT_NOT_REACHED();
      }
  
      JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
  
<span class="line-modified">!     if (Options::verboseOSR()) {</span>
<span class="line-removed">-         dataLog(</span>
<span class="line-removed">-             *codeBlock, &quot;: Entered triggerOSREntryNow with executeCounter = &quot;,</span>
<span class="line-removed">-             jitCode-&gt;tierUpCounter, &quot;\n&quot;);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     return tierUpCommon(exec, bytecodeIndex, true);</span>
  }
  
  #endif // ENABLE(FTL_JIT)
  
  } // extern &quot;C&quot;
  } } // namespace JSC::DFG
  
  #endif // ENABLE(DFG_JIT)
  
  #endif // ENABLE(JIT)
<span class="line-new-header">--- 4052,82 ---</span>
          jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
              codeBlock, CompilationDeferred);
          return nullptr;
      }
  
<span class="line-modified">!     CODEBLOCK_LOG_EVENT(jitCode-&gt;osrEntryBlock(), &quot;osrEntry&quot;, (&quot;at &quot;, originBytecodeIndex));</span>
      // It&#39;s possible that the for-entry compile already succeeded. In that case OSR
      // entry will succeed unless we ran out of stack. It&#39;s not clear what we should do.
      // We signal to try again after a while if that happens.
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(), &quot;Immediate OSR entry: From &quot;, RawPointer(jitCode), &quot; got entry block &quot;, RawPointer(jitCode-&gt;osrEntryBlock()));</span>
  
<span class="line-modified">!     void* address = FTL::prepareOSREntry(vm, callFrame, codeBlock, jitCode-&gt;osrEntryBlock(), originBytecodeIndex, streamIndex);</span>
      if (!address)
          return nullptr;
<span class="line-modified">!     return retagCodePtr&lt;char*&gt;(address, JSEntryPtrTag, bitwise_cast&lt;PtrTag&gt;(callFrame));</span>
  }
  
<span class="line-modified">! void JIT_OPERATION operationTriggerTierUpNowInLoop(VM* vmPointer, unsigned bytecodeIndexBits)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      DeferGCForAWhile deferGC(vm.heap);
<span class="line-modified">!     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
<span class="line-added">+     BytecodeIndex bytecodeIndex = BytecodeIndex::fromBits(bytecodeIndexBits);</span>
  
      sanitizeStackForVM(vm);
  
      if (codeBlock-&gt;jitType() != JITType::DFGJIT) {
<span class="line-modified">!         dataLogLn(&quot;Unexpected code block in DFG-&gt;FTL trigger tier up now in loop: &quot;, *codeBlock);</span>
          RELEASE_ASSERT_NOT_REACHED();
      }
  
      JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
  
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(), *codeBlock, &quot;: Entered triggerTierUpNowInLoop with executeCounter = &quot;, jitCode-&gt;tierUpCounter);</span>
  
      if (jitCode-&gt;tierUpInLoopHierarchy.contains(bytecodeIndex))
<span class="line-modified">!         tierUpCommon(vm, callFrame, bytecodeIndex, false);</span>
      else if (shouldTriggerFTLCompile(codeBlock, jitCode))
          triggerFTLReplacementCompile(vm, codeBlock, jitCode);
  
      // Since we cannot OSR Enter here, the default &quot;optimizeSoon()&quot; is not useful.
      if (codeBlock-&gt;hasOptimizedReplacement()) {
          CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;OSR in loop failed, deferring&quot;));
          jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(codeBlock, CompilationDeferred);
      }
  }
  
<span class="line-modified">! char* JIT_OPERATION operationTriggerOSREntryNow(VM* vmPointer, unsigned bytecodeIndexBits)</span>
  {
<span class="line-modified">!     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      DeferGCForAWhile deferGC(vm.heap);
<span class="line-modified">!     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
<span class="line-added">+     BytecodeIndex bytecodeIndex = BytecodeIndex::fromBits(bytecodeIndexBits);</span>
  
      sanitizeStackForVM(vm);
  
      if (codeBlock-&gt;jitType() != JITType::DFGJIT) {
          dataLog(&quot;Unexpected code block in DFG-&gt;FTL tier-up: &quot;, *codeBlock, &quot;\n&quot;);
          RELEASE_ASSERT_NOT_REACHED();
      }
  
      JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
  
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(), *codeBlock, &quot;: Entered triggerOSREntryNow with executeCounter = &quot;, jitCode-&gt;tierUpCounter);</span>
  
<span class="line-modified">!     return tierUpCommon(vm, callFrame, bytecodeIndex, true);</span>
  }
  
  #endif // ENABLE(FTL_JIT)
  
  } // extern &quot;C&quot;
  } } // namespace JSC::DFG
  
<span class="line-added">+ IGNORE_WARNINGS_END</span>
<span class="line-added">+ </span>
  #endif // ENABLE(DFG_JIT)
  
  #endif // ENABLE(JIT)
</pre>
<center><a href="DFGOpInfo.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGOperations.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/StdLibExtras.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StackTrace.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SystemTracing.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/StdLibExtras.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2008-2017 Apple Inc. All Rights Reserved.</span>
  3  * Copyright (C) 2013 Patrick Gansterer &lt;paroga@paroga.com&gt;
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</pre>
<hr />
<pre>
 96 
 97 template&lt;typename TypePtr&gt;
 98 inline TypePtr reinterpret_cast_ptr(const void* ptr)
 99 {
100     ASSERT(isPointerTypeAlignmentOkay(reinterpret_cast&lt;TypePtr&gt;(ptr)));
101     return reinterpret_cast&lt;TypePtr&gt;(ptr);
102 }
103 #else
104 template&lt;typename Type&gt;
105 inline bool isPointerTypeAlignmentOkay(Type*)
106 {
107     return true;
108 }
109 #define reinterpret_cast_ptr reinterpret_cast
110 #endif
111 
112 namespace WTF {
113 
114 enum CheckMoveParameterTag { CheckMoveParameter };
115 
<span class="line-modified">116 static const size_t KB = 1024;</span>
<span class="line-modified">117 static const size_t MB = 1024 * 1024;</span>
<span class="line-modified">118 static const size_t GB = 1024 * 1024 * 1024;</span>
119 
120 inline bool isPointerAligned(void* p)
121 {
122     return !((intptr_t)(p) &amp; (sizeof(char*) - 1));
123 }
124 
125 inline bool is8ByteAligned(void* p)
126 {
127     return !((uintptr_t)(p) &amp; (sizeof(double) - 1));
128 }
129 
130 /*
131  * C++&#39;s idea of a reinterpret_cast lacks sufficient cojones.
132  */
133 template&lt;typename ToType, typename FromType&gt;
134 inline ToType bitwise_cast(FromType from)
135 {
136     static_assert(sizeof(FromType) == sizeof(ToType), &quot;bitwise_cast size of FromType and ToType must be equal!&quot;);
137 #if COMPILER_SUPPORTS(BUILTIN_IS_TRIVIALLY_COPYABLE)
138     // Not all recent STL implementations support the std::is_trivially_copyable type trait. Work around this by only checking on toolchains which have the equivalent compiler intrinsic.
</pre>
<hr />
<pre>
442 
443 // libstdc++5 does not have constexpr std::tie. Since we cannot redefine std::tie with constexpr, we define WTF::tie instead.
444 // This workaround can be removed after 2019-04 and all users of WTF::tie can be converted to std::tie
445 // For more info see: https://bugs.webkit.org/show_bug.cgi?id=180692 and https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65978
446 template &lt;class ...Args&gt;
447 constexpr std::tuple&lt;Args&amp;...&gt; tie(Args&amp;... values)
448 {
449     return std::tuple&lt;Args&amp;...&gt;(values...);
450 }
451 
452 } // namespace WTF
453 
454 // This version of placement new omits a 0 check.
455 enum NotNullTag { NotNull };
456 inline void* operator new(size_t, NotNullTag, void* location)
457 {
458     ASSERT(location);
459     return location;
460 }
461 
<span class="line-removed">462 // This adds various C++14 features for versions of the STL that may not yet have them.</span>
463 namespace std {
<span class="line-removed">464 #if COMPILER(CLANG) &amp;&amp; __cplusplus &lt; 201400L</span>
<span class="line-removed">465 template&lt;class T&gt; struct _Unique_if {</span>
<span class="line-removed">466     typedef unique_ptr&lt;T&gt; _Single_object;</span>
<span class="line-removed">467 };</span>
<span class="line-removed">468 </span>
<span class="line-removed">469 template&lt;class T&gt; struct _Unique_if&lt;T[]&gt; {</span>
<span class="line-removed">470     typedef unique_ptr&lt;T[]&gt; _Unknown_bound;</span>
<span class="line-removed">471 };</span>
<span class="line-removed">472 </span>
<span class="line-removed">473 template&lt;class T, size_t N&gt; struct _Unique_if&lt;T[N]&gt; {</span>
<span class="line-removed">474     typedef void _Known_bound;</span>
<span class="line-removed">475 };</span>
<span class="line-removed">476 </span>
<span class="line-removed">477 template&lt;class T, class... Args&gt; inline typename _Unique_if&lt;T&gt;::_Single_object</span>
<span class="line-removed">478 make_unique(Args&amp;&amp;... args)</span>
<span class="line-removed">479 {</span>
<span class="line-removed">480     return unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...));</span>
<span class="line-removed">481 }</span>
<span class="line-removed">482 </span>
<span class="line-removed">483 template&lt;class T&gt; inline typename _Unique_if&lt;T&gt;::_Unknown_bound</span>
<span class="line-removed">484 make_unique(size_t n)</span>
<span class="line-removed">485 {</span>
<span class="line-removed">486     typedef typename remove_extent&lt;T&gt;::type U;</span>
<span class="line-removed">487     return unique_ptr&lt;T&gt;(new U[n]());</span>
<span class="line-removed">488 }</span>
<span class="line-removed">489 </span>
<span class="line-removed">490 template&lt;class T, class... Args&gt; typename _Unique_if&lt;T&gt;::_Known_bound</span>
<span class="line-removed">491 make_unique(Args&amp;&amp;...) = delete;</span>
<span class="line-removed">492 </span>
<span class="line-removed">493 // std::exchange</span>
<span class="line-removed">494 template&lt;class T, class U = T&gt;</span>
<span class="line-removed">495 T exchange(T&amp; t, U&amp;&amp; newValue)</span>
<span class="line-removed">496 {</span>
<span class="line-removed">497     T oldValue = std::move(t);</span>
<span class="line-removed">498     t = std::forward&lt;U&gt;(newValue);</span>
<span class="line-removed">499 </span>
<span class="line-removed">500     return oldValue;</span>
<span class="line-removed">501 }</span>
<span class="line-removed">502 #endif</span>
503 
504 template&lt;WTF::CheckMoveParameterTag, typename T&gt;
505 ALWAYS_INLINE constexpr typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; value)
506 {
507     static_assert(is_lvalue_reference&lt;T&gt;::value, &quot;T is not an lvalue reference; move() is unnecessary.&quot;);
508 
509     using NonRefQualifiedType = typename remove_reference&lt;T&gt;::type;
510     static_assert(!is_const&lt;NonRefQualifiedType&gt;::value, &quot;T is const qualified.&quot;);
511 
512     return move(forward&lt;T&gt;(value));
513 }
514 
<span class="line-removed">515 #if __cplusplus &lt; 201703L &amp;&amp; (!defined(_MSC_FULL_VER) || _MSC_FULL_VER &lt; 190023918) &amp;&amp; !defined(__cpp_lib_logical_traits)</span>
<span class="line-removed">516 template&lt;class...&gt; struct wtf_conjunction_impl;</span>
<span class="line-removed">517 template&lt;&gt; struct wtf_conjunction_impl&lt;&gt; : true_type { };</span>
<span class="line-removed">518 template&lt;class B0&gt; struct wtf_conjunction_impl&lt;B0&gt; : B0 { };</span>
<span class="line-removed">519 template&lt;class B0, class B1&gt; struct wtf_conjunction_impl&lt;B0, B1&gt; : conditional&lt;B0::value, B1, B0&gt;::type { };</span>
<span class="line-removed">520 template&lt;class B0, class B1, class B2, class... Bn&gt; struct wtf_conjunction_impl&lt;B0, B1, B2, Bn...&gt; : conditional&lt;B0::value, wtf_conjunction_impl&lt;B1, B2, Bn...&gt;, B0&gt;::type { };</span>
<span class="line-removed">521 template&lt;class... _Args&gt; struct conjunction : wtf_conjunction_impl&lt;_Args...&gt; { };</span>
<span class="line-removed">522 #endif</span>
<span class="line-removed">523 </span>
<span class="line-removed">524 // Provide in_place_t when not building with -std=c++17, or when building with libstdc++ 6</span>
<span class="line-removed">525 // (which doesn&#39;t define the _GLIBCXX_RELEASE macro that&#39;s been introduced in libstdc++ 7).</span>
<span class="line-removed">526 #if ((defined(__GLIBCXX__) &amp;&amp; !defined(_GLIBCXX_RELEASE))) &amp;&amp; (!defined(_MSVC_LANG) || _MSVC_LANG &lt; 201703L)</span>
<span class="line-removed">527 </span>
<span class="line-removed">528 // These are inline variable for C++17 and later.</span>
<span class="line-removed">529 #define __IN_PLACE_INLINE_VARIABLE static const</span>
<span class="line-removed">530 </span>
<span class="line-removed">531 struct in_place_t {</span>
<span class="line-removed">532     explicit in_place_t() = default;</span>
<span class="line-removed">533 };</span>
<span class="line-removed">534 __IN_PLACE_INLINE_VARIABLE constexpr in_place_t in_place { };</span>
<span class="line-removed">535 </span>
<span class="line-removed">536 template &lt;class T&gt; struct in_place_type_t {</span>
<span class="line-removed">537     explicit in_place_type_t() = default;</span>
<span class="line-removed">538 };</span>
<span class="line-removed">539 template &lt;class T&gt;</span>
<span class="line-removed">540 __IN_PLACE_INLINE_VARIABLE constexpr in_place_type_t&lt;T&gt; in_place_type { };</span>
<span class="line-removed">541 </span>
<span class="line-removed">542 template &lt;size_t I&gt; struct in_place_index_t {</span>
<span class="line-removed">543     explicit in_place_index_t() = default;</span>
<span class="line-removed">544 };</span>
<span class="line-removed">545 template &lt;size_t I&gt;</span>
<span class="line-removed">546 __IN_PLACE_INLINE_VARIABLE constexpr in_place_index_t&lt;I&gt; in_place_index { };</span>
<span class="line-removed">547 #endif // __cplusplus &lt; 201703L</span>
<span class="line-removed">548 </span>
<span class="line-removed">549 enum class ZeroStatus {</span>
<span class="line-removed">550     MayBeZero,</span>
<span class="line-removed">551     NonZero</span>
<span class="line-removed">552 };</span>
<span class="line-removed">553 </span>
<span class="line-removed">554 constexpr size_t clz(uint32_t value, ZeroStatus mightBeZero = ZeroStatus::MayBeZero)</span>
<span class="line-removed">555 {</span>
<span class="line-removed">556     if (mightBeZero == ZeroStatus::MayBeZero &amp;&amp; value) {</span>
<span class="line-removed">557 #if COMPILER(MSVC)</span>
<span class="line-removed">558         return __lzcnt(value);</span>
<span class="line-removed">559 #else</span>
<span class="line-removed">560         return __builtin_clz(value);</span>
<span class="line-removed">561 #endif</span>
<span class="line-removed">562     }</span>
<span class="line-removed">563     return 32;</span>
<span class="line-removed">564 }</span>
<span class="line-removed">565 </span>
566 } // namespace std
567 
568 namespace WTF {
569 
570 template&lt;class T, class... Args&gt;
571 ALWAYS_INLINE decltype(auto) makeUnique(Args&amp;&amp;... args)
572 {
573     static_assert(std::is_same&lt;typename T::webkitFastMalloced, int&gt;::value, &quot;T is FastMalloced&quot;);
574     return std::make_unique&lt;T&gt;(std::forward&lt;Args&gt;(args)...);
575 }
576 
577 template&lt;class T, class... Args&gt;
578 ALWAYS_INLINE decltype(auto) makeUniqueWithoutFastMallocCheck(Args&amp;&amp;... args)
579 {
580     return std::make_unique&lt;T&gt;(std::forward&lt;Args&gt;(args)...);
581 }
582 
583 
584 } // namespace WTF
585 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2008-2019 Apple Inc. All Rights Reserved.</span>
  3  * Copyright (C) 2013 Patrick Gansterer &lt;paroga@paroga.com&gt;
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</pre>
<hr />
<pre>
 96 
 97 template&lt;typename TypePtr&gt;
 98 inline TypePtr reinterpret_cast_ptr(const void* ptr)
 99 {
100     ASSERT(isPointerTypeAlignmentOkay(reinterpret_cast&lt;TypePtr&gt;(ptr)));
101     return reinterpret_cast&lt;TypePtr&gt;(ptr);
102 }
103 #else
104 template&lt;typename Type&gt;
105 inline bool isPointerTypeAlignmentOkay(Type*)
106 {
107     return true;
108 }
109 #define reinterpret_cast_ptr reinterpret_cast
110 #endif
111 
112 namespace WTF {
113 
114 enum CheckMoveParameterTag { CheckMoveParameter };
115 
<span class="line-modified">116 static constexpr size_t KB = 1024;</span>
<span class="line-modified">117 static constexpr size_t MB = 1024 * 1024;</span>
<span class="line-modified">118 static constexpr size_t GB = 1024 * 1024 * 1024;</span>
119 
120 inline bool isPointerAligned(void* p)
121 {
122     return !((intptr_t)(p) &amp; (sizeof(char*) - 1));
123 }
124 
125 inline bool is8ByteAligned(void* p)
126 {
127     return !((uintptr_t)(p) &amp; (sizeof(double) - 1));
128 }
129 
130 /*
131  * C++&#39;s idea of a reinterpret_cast lacks sufficient cojones.
132  */
133 template&lt;typename ToType, typename FromType&gt;
134 inline ToType bitwise_cast(FromType from)
135 {
136     static_assert(sizeof(FromType) == sizeof(ToType), &quot;bitwise_cast size of FromType and ToType must be equal!&quot;);
137 #if COMPILER_SUPPORTS(BUILTIN_IS_TRIVIALLY_COPYABLE)
138     // Not all recent STL implementations support the std::is_trivially_copyable type trait. Work around this by only checking on toolchains which have the equivalent compiler intrinsic.
</pre>
<hr />
<pre>
442 
443 // libstdc++5 does not have constexpr std::tie. Since we cannot redefine std::tie with constexpr, we define WTF::tie instead.
444 // This workaround can be removed after 2019-04 and all users of WTF::tie can be converted to std::tie
445 // For more info see: https://bugs.webkit.org/show_bug.cgi?id=180692 and https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65978
446 template &lt;class ...Args&gt;
447 constexpr std::tuple&lt;Args&amp;...&gt; tie(Args&amp;... values)
448 {
449     return std::tuple&lt;Args&amp;...&gt;(values...);
450 }
451 
452 } // namespace WTF
453 
454 // This version of placement new omits a 0 check.
455 enum NotNullTag { NotNull };
456 inline void* operator new(size_t, NotNullTag, void* location)
457 {
458     ASSERT(location);
459     return location;
460 }
461 

462 namespace std {







































463 
464 template&lt;WTF::CheckMoveParameterTag, typename T&gt;
465 ALWAYS_INLINE constexpr typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; value)
466 {
467     static_assert(is_lvalue_reference&lt;T&gt;::value, &quot;T is not an lvalue reference; move() is unnecessary.&quot;);
468 
469     using NonRefQualifiedType = typename remove_reference&lt;T&gt;::type;
470     static_assert(!is_const&lt;NonRefQualifiedType&gt;::value, &quot;T is const qualified.&quot;);
471 
472     return move(forward&lt;T&gt;(value));
473 }
474 



















































475 } // namespace std
476 
477 namespace WTF {
478 
479 template&lt;class T, class... Args&gt;
480 ALWAYS_INLINE decltype(auto) makeUnique(Args&amp;&amp;... args)
481 {
482     static_assert(std::is_same&lt;typename T::webkitFastMalloced, int&gt;::value, &quot;T is FastMalloced&quot;);
483     return std::make_unique&lt;T&gt;(std::forward&lt;Args&gt;(args)...);
484 }
485 
486 template&lt;class T, class... Args&gt;
487 ALWAYS_INLINE decltype(auto) makeUniqueWithoutFastMallocCheck(Args&amp;&amp;... args)
488 {
489     return std::make_unique&lt;T&gt;(std::forward&lt;Args&gt;(args)...);
490 }
491 
492 
493 } // namespace WTF
494 
</pre>
</td>
</tr>
</table>
<center><a href="StackTrace.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SystemTracing.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
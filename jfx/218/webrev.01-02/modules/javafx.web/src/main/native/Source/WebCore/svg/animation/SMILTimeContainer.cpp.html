<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/svg/animation/SMILTimeContainer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SMILTimeContainer.h&quot;
 28 
 29 #include &quot;Document.h&quot;
 30 #include &quot;ElementIterator.h&quot;
 31 #include &quot;Page.h&quot;
 32 #include &quot;SVGSMILElement.h&quot;
 33 #include &quot;SVGSVGElement.h&quot;
 34 #include &quot;ScopedEventQueue.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 static const Seconds SMILAnimationFrameDelay { 1_s / 60. };
 39 static const Seconds SMILAnimationFrameThrottledDelay { 1_s / 30. };
 40 
 41 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(SMILTimeContainer);
 42 
 43 SMILTimeContainer::SMILTimeContainer(SVGSVGElement&amp; owner)
 44     : m_timer(*this, &amp;SMILTimeContainer::timerFired)
 45     , m_ownerSVGElement(owner)
 46 {
 47 }
 48 
 49 void SMILTimeContainer::schedule(SVGSMILElement* animation, SVGElement* target, const QualifiedName&amp; attributeName)
 50 {
 51     ASSERT(animation-&gt;timeContainer() == this);
 52     ASSERT(target);
 53     ASSERT(animation-&gt;hasValidAttributeName());
 54 
 55     ElementAttributePair key(target, attributeName);
 56     std::unique_ptr&lt;AnimationsVector&gt;&amp; scheduled = m_scheduledAnimations.add(key, nullptr).iterator-&gt;value;
 57     if (!scheduled)
 58         scheduled = makeUnique&lt;AnimationsVector&gt;();
 59     ASSERT(!scheduled-&gt;contains(animation));
 60     scheduled-&gt;append(animation);
 61 
 62     SMILTime nextFireTime = animation-&gt;nextProgressTime();
 63     if (nextFireTime.isFinite())
 64         notifyIntervalsChanged();
 65 }
 66 
 67 void SMILTimeContainer::unschedule(SVGSMILElement* animation, SVGElement* target, const QualifiedName&amp; attributeName)
 68 {
 69     ASSERT(animation-&gt;timeContainer() == this);
 70 
 71     ElementAttributePair key(target, attributeName);
 72     AnimationsVector* scheduled = m_scheduledAnimations.get(key);
 73     ASSERT(scheduled);
 74     bool removed = scheduled-&gt;removeFirst(animation);
 75     ASSERT_UNUSED(removed, removed);
 76 }
 77 
 78 void SMILTimeContainer::notifyIntervalsChanged()
 79 {
 80     // Schedule updateAnimations() to be called asynchronously so multiple intervals
 81     // can change with updateAnimations() only called once at the end.
 82     startTimer(elapsed(), 0);
 83 }
 84 
 85 Seconds SMILTimeContainer::animationFrameDelay() const
 86 {
 87     auto* page = m_ownerSVGElement.document().page();
 88     if (!page)
 89         return SMILAnimationFrameDelay;
 90     return page-&gt;isLowPowerModeEnabled() ? SMILAnimationFrameThrottledDelay : SMILAnimationFrameDelay;
 91 }
 92 
 93 SMILTime SMILTimeContainer::elapsed() const
 94 {
 95     if (!m_beginTime)
 96         return 0_s;
 97     if (isPaused())
 98         return m_accumulatedActiveTime;
 99     return MonotonicTime::now() + m_accumulatedActiveTime - m_resumeTime;
100 }
101 
102 bool SMILTimeContainer::isActive() const
103 {
104     return !!m_beginTime &amp;&amp; !isPaused();
105 }
106 
107 bool SMILTimeContainer::isPaused() const
108 {
109     return !!m_pauseTime;
110 }
111 
112 bool SMILTimeContainer::isStarted() const
113 {
114     return !!m_beginTime;
115 }
116 
117 void SMILTimeContainer::begin()
118 {
119     ASSERT(!m_beginTime);
120     MonotonicTime now = MonotonicTime::now();
121 
122     // If &#39;m_presetStartTime&#39; is set, the timeline was modified via setElapsed() before the document began.
123     // In this case pass on &#39;seekToTime=true&#39; to updateAnimations().
124     m_beginTime = m_resumeTime = now - m_presetStartTime;
125     updateAnimations(SMILTime(m_presetStartTime), m_presetStartTime ? true : false);
126     m_presetStartTime = 0_s;
127 
128     if (m_pauseTime) {
129         m_pauseTime = now;
130         m_timer.stop();
131     }
132 }
133 
134 void SMILTimeContainer::pause()
135 {
136     ASSERT(!isPaused());
137 
138     m_pauseTime = MonotonicTime::now();
139     if (m_beginTime) {
140         m_accumulatedActiveTime += m_pauseTime - m_resumeTime;
141         m_timer.stop();
142     }
143 }
144 
145 void SMILTimeContainer::resume()
146 {
147     ASSERT(isPaused());
148 
149     m_resumeTime = MonotonicTime::now();
150     m_pauseTime = MonotonicTime();
151     startTimer(elapsed(), 0);
152 }
153 
154 void SMILTimeContainer::setElapsed(SMILTime time)
155 {
156     // If the documment didn&#39;t begin yet, record a new start time, we&#39;ll seek to once its possible.
157     if (!m_beginTime) {
158         m_presetStartTime = Seconds(time.value());
159         return;
160     }
161 
162     if (m_beginTime)
163         m_timer.stop();
164 
165     MonotonicTime now = MonotonicTime::now();
166     m_beginTime = now - Seconds { time.value() };
167 
168     if (m_pauseTime) {
169         m_resumeTime = m_pauseTime = now;
170         m_accumulatedActiveTime = Seconds(time.value());
171     } else
172         m_resumeTime = m_beginTime;
173 
174     processScheduledAnimations([](auto* animation) {
175         animation-&gt;reset();
176     });
177 
178     updateAnimations(time, true);
179 }
180 
181 void SMILTimeContainer::startTimer(SMILTime elapsed, SMILTime fireTime, SMILTime minimumDelay)
182 {
183     if (!m_beginTime || isPaused())
184         return;
185 
186     if (!fireTime.isFinite())
187         return;
188 
189     SMILTime delay = std::max(fireTime - elapsed, minimumDelay);
190     m_timer.startOneShot(1_s * delay.value());
191 }
192 
193 void SMILTimeContainer::timerFired()
194 {
195     ASSERT(!!m_beginTime);
196     ASSERT(!m_pauseTime);
197     updateAnimations(elapsed());
198 }
199 
200 void SMILTimeContainer::updateDocumentOrderIndexes()
201 {
202     unsigned timingElementCount = 0;
203 
204     for (auto&amp; smilElement : descendantsOfType&lt;SVGSMILElement&gt;(m_ownerSVGElement))
205         smilElement.setDocumentOrderIndex(timingElementCount++);
206 
207     m_documentOrderIndexesDirty = false;
208 }
209 
210 struct PriorityCompare {
211     PriorityCompare(SMILTime elapsed) : m_elapsed(elapsed) {}
212     bool operator()(SVGSMILElement* a, SVGSMILElement* b)
213     {
214         // FIXME: This should also consider possible timing relations between the elements.
215         SMILTime aBegin = a-&gt;intervalBegin();
216         SMILTime bBegin = b-&gt;intervalBegin();
217         // Frozen elements need to be prioritized based on their previous interval.
218         aBegin = a-&gt;isFrozen() &amp;&amp; m_elapsed &lt; aBegin ? a-&gt;previousIntervalBegin() : aBegin;
219         bBegin = b-&gt;isFrozen() &amp;&amp; m_elapsed &lt; bBegin ? b-&gt;previousIntervalBegin() : bBegin;
220         if (aBegin == bBegin)
221             return a-&gt;documentOrderIndex() &lt; b-&gt;documentOrderIndex();
222         return aBegin &lt; bBegin;
223     }
224     SMILTime m_elapsed;
225 };
226 
227 void SMILTimeContainer::sortByPriority(AnimationsVector&amp; animations, SMILTime elapsed)
228 {
229     if (m_documentOrderIndexesDirty)
230         updateDocumentOrderIndexes();
231     std::sort(animations.begin(), animations.end(), PriorityCompare(elapsed));
232 }
233 
234 void SMILTimeContainer::processAnimations(const AnimationsVector&amp; animations, Function&lt;void(SVGSMILElement*)&gt;&amp;&amp; callback)
235 {
236     // &#39;animations&#39; may change if &#39;callback&#39; causes an animation to end which will end up calling
237     // unschedule(). Copy &#39;animations&#39; so none of the items gets deleted out from underneath us.
238     auto animationsCopy = animations;
239     for (auto* animation : animations)
240         callback(animation);
241 }
242 
243 void SMILTimeContainer::processScheduledAnimations(Function&lt;void(SVGSMILElement*)&gt;&amp;&amp; callback)
244 {
245     for (auto&amp; it : m_scheduledAnimations)
246         processAnimations(*it.value, WTFMove(callback));
247 }
248 
249 void SMILTimeContainer::updateAnimations(SMILTime elapsed, bool seekToTime)
250 {
251     // Don&#39;t mutate the DOM while updating the animations.
252     EventQueueScope scope;
253 
254     processScheduledAnimations([](auto* animation) {
255         if (!animation-&gt;hasConditionsConnected())
256             animation-&gt;connectConditions();
257     });
258 
259     AnimationsVector animationsToApply;
260     SMILTime earliestFireTime = SMILTime::unresolved();
261 
262     for (auto&amp; it : m_scheduledAnimations) {
263         // Sort according to priority. Elements with later begin time have higher priority.
264         // In case of a tie, document order decides.
265         // FIXME: This should also consider timing relationships between the elements. Dependents
266         // have higher priority.
267         sortByPriority(*it.value, elapsed);
268 
269         RefPtr&lt;SVGSMILElement&gt; firstAnimation;
270         processAnimations(*it.value, [&amp;](auto* animation) {
271             ASSERT(animation-&gt;timeContainer() == this);
272             ASSERT(animation-&gt;targetElement());
273             ASSERT(animation-&gt;hasValidAttributeName());
274 
275             // Results are accumulated to the first animation that animates and contributes to a particular element/attribute pair.
276             if (!firstAnimation) {
277                 if (!animation-&gt;hasValidAttributeType())
278                     return;
279                 firstAnimation = animation;
280             }
281 
282             // This will calculate the contribution from the animation and add it to the resultsElement.
283             if (!animation-&gt;progress(elapsed, *firstAnimation, seekToTime) &amp;&amp; firstAnimation == animation)
284                 firstAnimation = nullptr;
285 
286             SMILTime nextFireTime = animation-&gt;nextProgressTime();
287             if (nextFireTime.isFinite())
288                 earliestFireTime = std::min(nextFireTime, earliestFireTime);
289         });
290 
291         if (firstAnimation)
292             animationsToApply.append(firstAnimation.get());
293     }
294 
295     // Apply results to target elements.
296     for (auto&amp; animation : animationsToApply)
297         animation-&gt;applyResultsToTarget();
298 
299     startTimer(elapsed, earliestFireTime, animationFrameDelay());
300 }
301 
302 }
    </pre>
  </body>
</html>
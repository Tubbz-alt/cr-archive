<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WTF/wtf/win/ThreadingWin.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RunLoopWin.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../WebCore/CMakeLists.txt.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/win/ThreadingWin.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -157,11 +157,10 @@</span>
  {
      size_t stackSize = 0;
  #if PLATFORM(JAVA) &amp;&amp; USE(JSVALUE32_64)
      stackSize = 1024 * 1024;
  #endif
<span class="udiff-line-removed">- </span>
      unsigned threadIdentifier = 0;
      unsigned initFlag = stackSize ? STACK_SIZE_PARAM_IS_A_RESERVATION : 0;
  
      HANDLE threadHandle = reinterpret_cast&lt;HANDLE&gt;(_beginthreadex(0, stackSize, wtfThreadEntryPoint, data, initFlag, &amp;threadIdentifier));
      if (!threadHandle) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -268,101 +267,70 @@</span>
      auto locker = holdLock(m_mutex);
      m_handle = handle;
      m_id = threadID;
  }
  
<span class="udiff-line-modified-removed">- #define InvalidThread reinterpret_cast&lt;Thread*&gt;(static_cast&lt;uintptr_t&gt;(0xbbadbeef))</span>
<span class="udiff-line-modified-added">+ struct Thread::ThreadHolder {</span>
<span class="udiff-line-added">+     ~ThreadHolder()</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         if (thread) {</span>
<span class="udiff-line-added">+             thread-&gt;specificStorage().destroySlots();</span>
<span class="udiff-line-added">+             thread-&gt;didExit();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     RefPtr&lt;Thread&gt; thread;</span>
<span class="udiff-line-added">+ };</span>
  
<span class="udiff-line-modified-removed">- static WordLock threadMapMutex;</span>
<span class="udiff-line-modified-added">+ thread_local static Thread::ThreadHolder s_threadHolder;</span>
  
<span class="udiff-line-modified-removed">- static HashMap&lt;ThreadIdentifier, Thread*&gt;&amp; threadMap()</span>
<span class="udiff-line-modified-added">+ Thread* Thread::currentMayBeNull()</span>
  {
<span class="udiff-line-modified-removed">-     static NeverDestroyed&lt;HashMap&lt;ThreadIdentifier, Thread*&gt;&gt; map;</span>
<span class="udiff-line-removed">-     return map.get();</span>
<span class="udiff-line-modified-added">+     return s_threadHolder.thread.get();</span>
  }
  
<span class="udiff-line-modified-removed">- void Thread::initializeTLSKey()</span>
<span class="udiff-line-modified-added">+ Thread&amp; Thread::initializeTLS(Ref&lt;Thread&gt;&amp;&amp; thread)</span>
  {
<span class="udiff-line-modified-removed">-     threadMap();</span>
<span class="udiff-line-modified-removed">-     threadSpecificKeyCreate(&amp;s_key, destructTLS);</span>
<span class="udiff-line-modified-added">+     s_threadHolder.thread = WTFMove(thread);</span>
<span class="udiff-line-modified-added">+     return *s_threadHolder.thread;</span>
  }
  
<span class="udiff-line-modified-removed">- Thread* Thread::currentDying()</span>
<span class="udiff-line-modified-added">+ Atomic&lt;int&gt; Thread::SpecificStorage::s_numberOfKeys;</span>
<span class="udiff-line-added">+ std::array&lt;Atomic&lt;Thread::SpecificStorage::DestroyFunction&gt;, Thread::SpecificStorage::s_maxKeys&gt; Thread::SpecificStorage::s_destroyFunctions;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool Thread::SpecificStorage::allocateKey(int&amp; key, DestroyFunction destroy)</span>
  {
<span class="udiff-line-modified-removed">-     ASSERT(s_key != InvalidThreadSpecificKey);</span>
<span class="udiff-line-modified-removed">-     // After FLS is destroyed, this map offers the value until the second thread exit callback is called.</span>
<span class="udiff-line-modified-removed">-     auto locker = holdLock(threadMapMutex);</span>
<span class="udiff-line-modified-removed">-     return threadMap().get(currentID());</span>
<span class="udiff-line-modified-added">+     int k = s_numberOfKeys.exchangeAdd(1);</span>
<span class="udiff-line-modified-added">+     if (k &gt;= s_maxKeys) {</span>
<span class="udiff-line-modified-added">+         s_numberOfKeys.exchangeSub(1);</span>
<span class="udiff-line-modified-added">+         return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     key = k;</span>
<span class="udiff-line-added">+     s_destroyFunctions[key].store(destroy);</span>
<span class="udiff-line-added">+     return true;</span>
  }
  
<span class="udiff-line-modified-removed">- RefPtr&lt;Thread&gt; Thread::get(ThreadIdentifier id)</span>
<span class="udiff-line-modified-added">+ void* Thread::SpecificStorage::get(int key)</span>
  {
<span class="udiff-line-modified-removed">-     auto locker = holdLock(threadMapMutex);</span>
<span class="udiff-line-removed">-     Thread* thread = threadMap().get(id);</span>
<span class="udiff-line-removed">-     if (thread)</span>
<span class="udiff-line-removed">-         return thread;</span>
<span class="udiff-line-removed">-     return nullptr;</span>
<span class="udiff-line-modified-added">+     return m_slots[key];</span>
  }
  
<span class="udiff-line-modified-removed">- Thread&amp; Thread::initializeTLS(Ref&lt;Thread&gt;&amp;&amp; thread)</span>
<span class="udiff-line-modified-added">+ void Thread::SpecificStorage::set(int key, void* value)</span>
  {
<span class="udiff-line-modified-removed">-     ASSERT(s_key != InvalidThreadSpecificKey);</span>
<span class="udiff-line-removed">-     // FIXME: Remove this workaround code once &lt;rdar://problem/31793213&gt; is fixed.</span>
<span class="udiff-line-removed">-     auto id = thread-&gt;id();</span>
<span class="udiff-line-removed">-     // We leak the ref to keep the Thread alive while it is held in TLS. destructTLS will deref it later at thread destruction time.</span>
<span class="udiff-line-removed">-     auto&amp; threadInTLS = thread.leakRef();</span>
<span class="udiff-line-removed">-     threadSpecificSet(s_key, &amp;threadInTLS);</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         auto locker = holdLock(threadMapMutex);</span>
<span class="udiff-line-removed">-         threadMap().add(id, &amp;threadInTLS);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     return threadInTLS;</span>
<span class="udiff-line-modified-added">+     m_slots[key] = value;</span>
  }
  
<span class="udiff-line-modified-removed">- void Thread::destructTLS(void* data)</span>
<span class="udiff-line-modified-added">+ void Thread::SpecificStorage::destroySlots()</span>
  {
<span class="udiff-line-modified-removed">-     if (data == InvalidThread)</span>
<span class="udiff-line-modified-removed">-         return;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     Thread* thread = static_cast&lt;Thread*&gt;(data);</span>
<span class="udiff-line-modified-removed">-     ASSERT(thread);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-     // Delay the deallocation of Thread more.</span>
<span class="udiff-line-removed">-     // It defers Thread deallocation after the other ThreadSpecific values are deallocated.</span>
<span class="udiff-line-removed">-     static thread_local class ThreadExitCallback {</span>
<span class="udiff-line-removed">-     public:</span>
<span class="udiff-line-removed">-         ThreadExitCallback(Thread* thread)</span>
<span class="udiff-line-removed">-             : m_thread(thread)</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         ~ThreadExitCallback()</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-             Thread::destructTLS(m_thread);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     private:</span>
<span class="udiff-line-removed">-         Thread* m_thread;</span>
<span class="udiff-line-removed">-     } callback(thread);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (thread-&gt;m_isDestroyedOnce) {</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-             auto locker = holdLock(threadMapMutex);</span>
<span class="udiff-line-removed">-             ASSERT(threadMap().contains(thread-&gt;id()));</span>
<span class="udiff-line-removed">-             threadMap().remove(thread-&gt;id());</span>
<span class="udiff-line-modified-added">+     auto numberOfKeys = s_numberOfKeys.load();</span>
<span class="udiff-line-modified-added">+     for (size_t i = 0; i &lt; numberOfKeys; i++) {</span>
<span class="udiff-line-modified-added">+         auto destroy = s_destroyFunctions[i].load();</span>
<span class="udiff-line-modified-added">+         if (destroy &amp;&amp; m_slots[i]) {</span>
<span class="udiff-line-modified-added">+             destroy(m_slots[i]);</span>
<span class="udiff-line-modified-added">+             m_slots[i] = nullptr;</span>
          }
<span class="udiff-line-removed">-         thread-&gt;didExit();</span>
<span class="udiff-line-removed">-         thread-&gt;deref();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Fill the FLS with the non-nullptr value. While FLS destructor won&#39;t be called for that,</span>
<span class="udiff-line-removed">-         // non-nullptr value tells us that we already destructed Thread. This allows us to</span>
<span class="udiff-line-removed">-         // detect incorrect use of Thread::current() after this point because it will crash.</span>
<span class="udiff-line-removed">-         threadSpecificSet(s_key, InvalidThread);</span>
<span class="udiff-line-removed">-         return;</span>
      }
<span class="udiff-line-removed">-     threadSpecificSet(s_key, InvalidThread);</span>
<span class="udiff-line-removed">-     thread-&gt;m_isDestroyedOnce = true;</span>
  }
  
  Mutex::~Mutex()
  {
  }
</pre>
<center><a href="RunLoopWin.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../WebCore/CMakeLists.txt.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
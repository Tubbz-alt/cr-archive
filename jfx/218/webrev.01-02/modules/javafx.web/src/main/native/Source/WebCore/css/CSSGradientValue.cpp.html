<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/css/CSSGradientValue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2008 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;CSSGradientValue.h&quot;
  28 
  29 #include &quot;CSSCalculationValue.h&quot;
  30 #include &quot;CSSToLengthConversionData.h&quot;
  31 #include &quot;CSSValueKeywords.h&quot;
  32 #include &quot;FloatSize.h&quot;
  33 #include &quot;Gradient.h&quot;
  34 #include &quot;GradientImage.h&quot;
  35 #include &quot;NodeRenderStyle.h&quot;
  36 #include &quot;Pair.h&quot;
  37 #include &quot;RenderElement.h&quot;
  38 #include &quot;RenderView.h&quot;
  39 #include &quot;StyleBuilderState.h&quot;
  40 #include &lt;wtf/text/StringBuilder.h&gt;
  41 
  42 namespace WebCore {
  43 
  44 static inline Ref&lt;Gradient&gt; createGradient(CSSGradientValue&amp; value, RenderElement&amp; renderer, FloatSize size)
  45 {
  46     if (is&lt;CSSLinearGradientValue&gt;(value))
  47         return downcast&lt;CSSLinearGradientValue&gt;(value).createGradient(renderer, size);
  48     if (is&lt;CSSRadialGradientValue&gt;(value))
  49         return downcast&lt;CSSRadialGradientValue&gt;(value).createGradient(renderer, size);
  50     return downcast&lt;CSSConicGradientValue&gt;(value).createGradient(renderer, size);
  51 }
  52 
  53 RefPtr&lt;Image&gt; CSSGradientValue::image(RenderElement&amp; renderer, const FloatSize&amp; size)
  54 {
  55     if (size.isEmpty())
  56         return nullptr;
  57     bool cacheable = isCacheable() &amp;&amp; !renderer.style().hasAppleColorFilter();
  58     if (cacheable) {
  59         if (!clients().contains(&amp;renderer))
  60             return nullptr;
  61         if (auto* result = cachedImageForSize(size))
  62             return result;
  63     }
  64     auto newImage = GradientImage::create(createGradient(*this, renderer, size), size);
  65     if (cacheable)
  66         saveCachedImageForSize(size, newImage.get());
  67     return newImage;
  68 }
  69 
  70 // Should only ever be called for deprecated gradients.
  71 static inline bool compareStops(const CSSGradientColorStop&amp; a, const CSSGradientColorStop&amp; b)
  72 {
  73     double aVal = a.m_position-&gt;doubleValue(CSSUnitType::CSS_NUMBER);
  74     double bVal = b.m_position-&gt;doubleValue(CSSUnitType::CSS_NUMBER);
  75 
  76     return aVal &lt; bVal;
  77 }
  78 
  79 void CSSGradientValue::sortStopsIfNeeded()
  80 {
  81     ASSERT(m_gradientType == CSSDeprecatedLinearGradient || m_gradientType == CSSDeprecatedRadialGradient);
  82     if (!m_stopsSorted) {
  83         if (m_stops.size())
  84             std::stable_sort(m_stops.begin(), m_stops.end(), compareStops);
  85         m_stopsSorted = true;
  86     }
  87 }
  88 
  89 struct GradientStop {
  90     Color color;
  91     float offset { 0 };
  92     bool specified { false };
  93     bool isMidpoint { false };
  94 };
  95 
  96 static inline Ref&lt;CSSGradientValue&gt; clone(CSSGradientValue&amp; value)
  97 {
  98     if (is&lt;CSSLinearGradientValue&gt;(value))
  99         return downcast&lt;CSSLinearGradientValue&gt;(value).clone();
 100     if (is&lt;CSSRadialGradientValue&gt;(value))
 101         return downcast&lt;CSSRadialGradientValue&gt;(value).clone();
 102     ASSERT(is&lt;CSSConicGradientValue&gt;(value));
 103     return downcast&lt;CSSConicGradientValue&gt;(value).clone();
 104 }
 105 
 106 template&lt;typename Function&gt;
 107 void resolveStopColors(Vector&lt;CSSGradientColorStop, 2&gt;&amp; stops, Function&amp;&amp; colorResolveFunction)
 108 {
 109     for (size_t i = 0; i &lt; stops.size(); ++i) {
 110         auto&amp; stop = stops[i];
 111         if (stop.isMidpoint)
 112             continue;
 113         if (stop.m_color)
 114             stop.m_resolvedColor = colorResolveFunction(*stop.m_color);
 115         else if (i) {
 116             auto&amp; previousStop = stops[i - 1];
 117             ASSERT(previousStop.m_color);
 118             stop.m_color = previousStop.m_color;
 119             stop.m_resolvedColor = previousStop.m_resolvedColor;
 120         }
 121     }
 122 }
 123 
 124 Ref&lt;CSSGradientValue&gt; CSSGradientValue::gradientWithStylesResolved(Style::BuilderState&amp; builderState)
 125 {
 126     bool colorIsDerivedFromElement = false;
 127     for (auto&amp; stop : m_stops) {
 128         if (!stop.isMidpoint &amp;&amp; stop.m_color &amp;&amp; Style::BuilderState::isColorFromPrimitiveValueDerivedFromElement(*stop.m_color)) {
 129             stop.m_colorIsDerivedFromElement = true;
 130             colorIsDerivedFromElement = true;
 131             break;
 132         }
 133     }
 134     auto result = colorIsDerivedFromElement ? clone(*this) : makeRef(*this);
 135     resolveStopColors(result-&gt;m_stops, [&amp;](const CSSPrimitiveValue&amp; colorValue) {
 136         return builderState.colorFromPrimitiveValue(colorValue);
 137     });
 138     return result;
 139 }
 140 
 141 void CSSGradientValue::resolveRGBColors()
 142 {
 143     resolveStopColors(m_stops, [&amp;](const CSSPrimitiveValue&amp; colorValue) {
 144         ASSERT(colorValue.isRGBColor());
 145         return colorValue.color();
 146     });
 147 }
 148 
 149 class LinearGradientAdapter {
 150 public:
 151     explicit LinearGradientAdapter(Gradient::LinearData&amp; data)
 152         : m_data(data)
 153     {
 154     }
 155 
 156     float gradientLength() const
 157     {
 158         auto gradientSize = m_data.point0 - m_data.point1;
 159         return gradientSize.diagonalLength();
 160     }
 161     float maxExtent(float, float) const { return 1; }
 162 
 163     void normalizeStopsAndEndpointsOutsideRange(Vector&lt;GradientStop&gt;&amp; stops)
 164     {
 165         float firstOffset = stops.first().offset;
 166         float lastOffset = stops.last().offset;
 167         if (firstOffset != lastOffset) {
 168             float scale = lastOffset - firstOffset;
 169 
 170             for (auto&amp; stop : stops)
 171                 stop.offset = (stop.offset - firstOffset) / scale;
 172 
 173             auto p0 = m_data.point0;
 174             auto p1 = m_data.point1;
 175             m_data.point0 = { p0.x() + firstOffset * (p1.x() - p0.x()), p0.y() + firstOffset * (p1.y() - p0.y()) };
 176             m_data.point1 = { p1.x() + (lastOffset - 1) * (p1.x() - p0.x()), p1.y() + (lastOffset - 1) * (p1.y() - p0.y()) };
 177         } else {
 178             // There&#39;s a single position that is outside the scale, clamp the positions to 1.
 179             for (auto&amp; stop : stops)
 180                 stop.offset = 1;
 181         }
 182     }
 183 
 184 private:
 185     Gradient::LinearData&amp; m_data;
 186 };
 187 
 188 class RadialGradientAdapter {
 189 public:
 190     explicit RadialGradientAdapter(Gradient::RadialData&amp; data)
 191         : m_data(data)
 192     {
 193     }
 194 
 195     float gradientLength() const { return m_data.endRadius; }
 196 
 197     // Radial gradients may need to extend further than the endpoints, because they have
 198     // to repeat out to the corners of the box.
 199     float maxExtent(float maxLengthForRepeat, float gradientLength) const
 200     {
 201         if (maxLengthForRepeat &gt; gradientLength)
 202             return gradientLength &gt; 0 ? maxLengthForRepeat / gradientLength : 0;
 203         return 1;
 204     }
 205 
 206     void normalizeStopsAndEndpointsOutsideRange(Vector&lt;GradientStop&gt;&amp; stops)
 207     {
 208         auto numStops = stops.size();
 209 
 210         // Rather than scaling the points &lt; 0, we truncate them, so only scale according to the largest point.
 211         float firstOffset = 0;
 212         float lastOffset = stops.last().offset;
 213         float scale = lastOffset - firstOffset;
 214 
 215         // Reset points below 0 to the first visible color.
 216         size_t firstZeroOrGreaterIndex = numStops;
 217         for (size_t i = 0; i &lt; numStops; ++i) {
 218             if (stops[i].offset &gt;= 0) {
 219                 firstZeroOrGreaterIndex = i;
 220                 break;
 221             }
 222         }
 223 
 224         if (firstZeroOrGreaterIndex &gt; 0) {
 225             if (firstZeroOrGreaterIndex &lt; numStops &amp;&amp; stops[firstZeroOrGreaterIndex].offset &gt; 0) {
 226                 float prevOffset = stops[firstZeroOrGreaterIndex - 1].offset;
 227                 float nextOffset = stops[firstZeroOrGreaterIndex].offset;
 228 
 229                 float interStopProportion = -prevOffset / (nextOffset - prevOffset);
 230                 // FIXME: when we interpolate gradients using premultiplied colors, this should do premultiplication.
 231                 Color blendedColor = blend(stops[firstZeroOrGreaterIndex - 1].color, stops[firstZeroOrGreaterIndex].color, interStopProportion);
 232 
 233                 // Clamp the positions to 0 and set the color.
 234                 for (size_t i = 0; i &lt; firstZeroOrGreaterIndex; ++i) {
 235                     stops[i].offset = 0;
 236                     stops[i].color = blendedColor;
 237                 }
 238             } else {
 239                 // All stops are below 0; just clamp them.
 240                 for (size_t i = 0; i &lt; firstZeroOrGreaterIndex; ++i)
 241                     stops[i].offset = 0;
 242             }
 243         }
 244 
 245         for (auto&amp; stop : stops)
 246             stop.offset /= scale;
 247 
 248         m_data.startRadius *= scale;
 249         m_data.endRadius *= scale;
 250     }
 251 
 252 private:
 253     Gradient::RadialData&amp; m_data;
 254 };
 255 
 256 class ConicGradientAdapter {
 257 public:
 258     float gradientLength() const { return 1; }
 259     float maxExtent(float, float) const { return 1; }
 260 
 261     void normalizeStopsAndEndpointsOutsideRange(Vector&lt;GradientStop&gt;&amp; stops)
 262     {
 263         auto numStops = stops.size();
 264 
 265         size_t firstZeroOrGreaterIndex = numStops;
 266         for (size_t i = 0; i &lt; numStops; ++i) {
 267             if (stops[i].offset &gt;= 0) {
 268                 firstZeroOrGreaterIndex = i;
 269                 break;
 270             }
 271         }
 272 
 273         if (firstZeroOrGreaterIndex &gt; 0) {
 274             if (firstZeroOrGreaterIndex &lt; numStops &amp;&amp; stops[firstZeroOrGreaterIndex].offset &gt; 0) {
 275                 float prevOffset = stops[firstZeroOrGreaterIndex - 1].offset;
 276                 float nextOffset = stops[firstZeroOrGreaterIndex].offset;
 277 
 278                 float interStopProportion = -prevOffset / (nextOffset - prevOffset);
 279                 // FIXME: when we interpolate gradients using premultiplied colors, this should do premultiplication.
 280                 Color blendedColor = blend(stops[firstZeroOrGreaterIndex - 1].color, stops[firstZeroOrGreaterIndex].color, interStopProportion);
 281 
 282                 // Clamp the positions to 0 and set the color.
 283                 for (size_t i = 0; i &lt; firstZeroOrGreaterIndex; ++i) {
 284                     stops[i].offset = 0;
 285                     stops[i].color = blendedColor;
 286                 }
 287             } else {
 288                 // All stops are below 0; just clamp them.
 289                 for (size_t i = 0; i &lt; firstZeroOrGreaterIndex; ++i)
 290                     stops[i].offset = 0;
 291             }
 292         }
 293 
 294         size_t lastOneOrLessIndex = numStops;
 295         for (int i = numStops - 1; i &gt;= 0; --i) {
 296             if (stops[i].offset &lt;= 1) {
 297                 lastOneOrLessIndex = i;
 298                 break;
 299             }
 300         }
 301 
 302         if (lastOneOrLessIndex &lt; numStops - 1) {
 303             if (lastOneOrLessIndex &lt; numStops &amp;&amp; stops[lastOneOrLessIndex].offset &lt; 1) {
 304                 float prevOffset = stops[lastOneOrLessIndex].offset;
 305                 float nextOffset = stops[lastOneOrLessIndex + 1].offset;
 306 
 307                 float interStopProportion = (1 - prevOffset) / (nextOffset - prevOffset);
 308                 // FIXME: when we interpolate gradients using premultiplied colors, this should do premultiplication.
 309                 Color blendedColor = blend(stops[lastOneOrLessIndex].color, stops[lastOneOrLessIndex + 1].color, interStopProportion);
 310 
 311                 // Clamp the positions to 1 and set the color.
 312                 for (size_t i = lastOneOrLessIndex + 1; i &lt; numStops; ++i) {
 313                     stops[i].offset = 1;
 314                     stops[i].color = blendedColor;
 315                 }
 316             } else {
 317                 // All stops are above 1; just clamp them.
 318                 for (size_t i = lastOneOrLessIndex; i &lt; numStops; ++i)
 319                     stops[i].offset = 1;
 320             }
 321         }
 322     }
 323 };
 324 
 325 template&lt;typename GradientAdapter&gt;
 326 Gradient::ColorStopVector CSSGradientValue::computeStops(GradientAdapter&amp; gradientAdapter, const CSSToLengthConversionData&amp; conversionData, const RenderStyle&amp; style, float maxLengthForRepeat)
 327 {
 328     if (m_gradientType == CSSDeprecatedLinearGradient || m_gradientType == CSSDeprecatedRadialGradient) {
 329         sortStopsIfNeeded();
 330 
 331         Gradient::ColorStopVector result;
 332         result.reserveInitialCapacity(m_stops.size());
 333 
 334         for (auto&amp; stop : m_stops) {
 335             float offset;
 336             if (stop.m_position-&gt;isPercentage())
 337                 offset = stop.m_position-&gt;floatValue(CSSUnitType::CSS_PERCENTAGE) / 100;
 338             else
 339                 offset = stop.m_position-&gt;floatValue(CSSUnitType::CSS_NUMBER);
 340 
 341             Color color = stop.m_resolvedColor;
 342             if (style.hasAppleColorFilter())
 343                 style.appleColorFilter().transformColor(color);
 344             result.uncheckedAppend({ offset, color });
 345         }
 346 
 347         return result;
 348     }
 349 
 350     size_t numStops = m_stops.size();
 351     Vector&lt;GradientStop&gt; stops(numStops);
 352 
 353     float gradientLength = gradientAdapter.gradientLength();
 354 
 355     for (size_t i = 0; i &lt; numStops; ++i) {
 356         auto&amp; stop = m_stops[i];
 357 
 358         stops[i].isMidpoint = stop.isMidpoint;
 359 
 360         Color color = stop.m_resolvedColor;
 361         if (style.hasAppleColorFilter())
 362             style.appleColorFilter().transformColor(color);
 363 
 364         stops[i].color = color;
 365 
 366         if (stop.m_position) {
 367             auto&amp; positionValue = *stop.m_position;
 368             if (positionValue.isPercentage())
 369                 stops[i].offset = positionValue.floatValue(CSSUnitType::CSS_PERCENTAGE) / 100;
 370             else if (positionValue.isLength() || positionValue.isViewportPercentageLength() || positionValue.isCalculatedPercentageWithLength()) {
 371                 float length;
 372                 if (positionValue.isLength())
 373                     length = positionValue.computeLength&lt;float&gt;(conversionData);
 374                 else {
 375                     Ref&lt;CalculationValue&gt; calculationValue { positionValue.cssCalcValue()-&gt;createCalculationValue(conversionData) };
 376                     length = calculationValue-&gt;evaluate(gradientLength);
 377                 }
 378                 stops[i].offset = (gradientLength &gt; 0) ? length / gradientLength : 0;
 379             } else if (positionValue.isAngle())
 380                 stops[i].offset = positionValue.floatValue(CSSUnitType::CSS_DEG) / 360;
 381             else {
 382                 ASSERT_NOT_REACHED();
 383                 stops[i].offset = 0;
 384             }
 385             stops[i].specified = true;
 386         } else {
 387             // If the first color-stop does not have a position, its position defaults to 0%.
 388             // If the last color-stop does not have a position, its position defaults to 100%.
 389             if (!i) {
 390                 stops[i].offset = 0;
 391                 stops[i].specified = true;
 392             } else if (numStops &gt; 1 &amp;&amp; i == numStops - 1) {
 393                 stops[i].offset = 1;
 394                 stops[i].specified = true;
 395             }
 396         }
 397 
 398         // If a color-stop has a position that is less than the specified position of any
 399         // color-stop before it in the list, its position is changed to be equal to the
 400         // largest specified position of any color-stop before it.
 401         if (stops[i].specified &amp;&amp; i &gt; 0) {
 402             size_t prevSpecifiedIndex;
 403             for (prevSpecifiedIndex = i - 1; prevSpecifiedIndex; --prevSpecifiedIndex) {
 404                 if (stops[prevSpecifiedIndex].specified)
 405                     break;
 406             }
 407 
 408             if (stops[i].offset &lt; stops[prevSpecifiedIndex].offset)
 409                 stops[i].offset = stops[prevSpecifiedIndex].offset;
 410         }
 411     }
 412 
 413     ASSERT(stops[0].specified &amp;&amp; stops[numStops - 1].specified);
 414 
 415     // If any color-stop still does not have a position, then, for each run of adjacent
 416     // color-stops without positions, set their positions so that they are evenly spaced
 417     // between the preceding and following color-stops with positions.
 418     if (numStops &gt; 2) {
 419         size_t unspecifiedRunStart = 0;
 420         bool inUnspecifiedRun = false;
 421 
 422         for (size_t i = 0; i &lt; numStops; ++i) {
 423             if (!stops[i].specified &amp;&amp; !inUnspecifiedRun) {
 424                 unspecifiedRunStart = i;
 425                 inUnspecifiedRun = true;
 426             } else if (stops[i].specified &amp;&amp; inUnspecifiedRun) {
 427                 size_t unspecifiedRunEnd = i;
 428 
 429                 if (unspecifiedRunStart &lt; unspecifiedRunEnd) {
 430                     float lastSpecifiedOffset = stops[unspecifiedRunStart - 1].offset;
 431                     float nextSpecifiedOffset = stops[unspecifiedRunEnd].offset;
 432                     float delta = (nextSpecifiedOffset - lastSpecifiedOffset) / (unspecifiedRunEnd - unspecifiedRunStart + 1);
 433 
 434                     for (size_t j = unspecifiedRunStart; j &lt; unspecifiedRunEnd; ++j)
 435                         stops[j].offset = lastSpecifiedOffset + (j - unspecifiedRunStart + 1) * delta;
 436                 }
 437 
 438                 inUnspecifiedRun = false;
 439             }
 440         }
 441     }
 442 
 443     // Walk over the color stops, look for midpoints and add stops as needed.
 444     // If mid &lt; 50%, add 2 stops to the left and 6 to the right
 445     // else add 6 stops to the left and 2 to the right.
 446     // Stops on the side with the most stops start midway because the curve approximates
 447     // a line in that region. We then add 5 more color stops on that side to minimize the change
 448     // how the luminance changes at each of the color stops. We don&#39;t have to add as many on the other side
 449     // since it becomes small which increases the differentation of luminance which hides the color stops.
 450     // Even with 4 extra color stops, it *is* possible to discern the steps when the gradient is large and has
 451     // large luminance differences between midpoint and color stop. If this becomes an issue, we can consider
 452     // making this algorithm a bit smarter.
 453 
 454     // Midpoints that coincide with color stops are treated specially since they don&#39;t require
 455     // extra stops and generate hard lines.
 456     for (size_t x = 1; x &lt; stops.size() - 1;) {
 457         if (!stops[x].isMidpoint) {
 458             ++x;
 459             continue;
 460         }
 461 
 462         // Find previous and next color so we know what to interpolate between.
 463         // We already know they have a color since we checked for that earlier.
 464         Color color1 = stops[x - 1].color;
 465         Color color2 = stops[x + 1].color;
 466         // Likewise find the position of previous and next color stop.
 467         float offset1 = stops[x - 1].offset;
 468         float offset2 = stops[x + 1].offset;
 469         float offset = stops[x].offset;
 470 
 471         // Check if everything coincides or the midpoint is exactly in the middle.
 472         // If so, ignore the midpoint.
 473         if (offset - offset1 == offset2 - offset) {
 474             stops.remove(x);
 475             continue;
 476         }
 477 
 478         // Check if we coincide with the left color stop.
 479         if (offset1 == offset) {
 480             // Morph the midpoint to a regular stop with the color of the next color stop.
 481             stops[x].color = color2;
 482             stops[x].isMidpoint = false;
 483             continue;
 484         }
 485 
 486         // Check if we coincide with the right color stop.
 487         if (offset2 == offset) {
 488             // Morph the midpoint to a regular stop with the color of the previous color stop.
 489             stops[x].color = color1;
 490             stops[x].isMidpoint = false;
 491             continue;
 492         }
 493 
 494         float midpoint = (offset - offset1) / (offset2 - offset1);
 495         GradientStop newStops[9];
 496         if (midpoint &gt; .5f) {
 497             for (size_t y = 0; y &lt; 7; ++y)
 498                 newStops[y].offset = offset1 + (offset - offset1) * (7 + y) / 13;
 499 
 500             newStops[7].offset = offset + (offset2 - offset) / 3;
 501             newStops[8].offset = offset + (offset2 - offset) * 2 / 3;
 502         } else {
 503             newStops[0].offset = offset1 + (offset - offset1) / 3;
 504             newStops[1].offset = offset1 + (offset - offset1) * 2 / 3;
 505 
 506             for (size_t y = 0; y &lt; 7; ++y)
 507                 newStops[y + 2].offset = offset + (offset2 - offset) * y / 13;
 508         }
 509         // calculate colors
 510         for (size_t y = 0; y &lt; 9; ++y) {
 511             float relativeOffset = (newStops[y].offset - offset1) / (offset2 - offset1);
 512             float multiplier = std::pow(relativeOffset, std::log(.5f) / std::log(midpoint));
 513             // FIXME: Why not premultiply here?
 514             newStops[y].color = blend(color1, color2, multiplier, false /* do not premultiply */);
 515         }
 516 
 517         stops.remove(x);
 518         stops.insert(x, newStops, 9);
 519         x += 9;
 520     }
 521 
 522     numStops = stops.size();
 523 
 524     // If the gradient is repeating, repeat the color stops.
 525     // We can&#39;t just push this logic down into the platform-specific Gradient code,
 526     // because we have to know the extent of the gradient, and possible move the end points.
 527     if (m_repeating &amp;&amp; numStops &gt; 1) {
 528         // If the difference in the positions of the first and last color-stops is 0,
 529         // the gradient defines a solid-color image with the color of the last color-stop in the rule.
 530         float gradientRange = stops.last().offset - stops.first().offset;
 531         if (!gradientRange) {
 532             stops.first().offset = 0;
 533             stops.first().color = stops.last().color;
 534             stops.shrink(1);
 535             numStops = 1;
 536         } else {
 537             float maxExtent = gradientAdapter.maxExtent(maxLengthForRepeat, gradientLength);
 538 
 539             size_t originalNumStops = numStops;
 540             size_t originalFirstStopIndex = 0;
 541 
 542             // Work backwards from the first, adding stops until we get one before 0.
 543             float firstOffset = stops[0].offset;
 544             if (firstOffset &gt; 0) {
 545                 float currOffset = firstOffset;
 546                 size_t srcStopOrdinal = originalNumStops - 1;
 547 
 548                 while (true) {
 549                     GradientStop newStop = stops[originalFirstStopIndex + srcStopOrdinal];
 550                     newStop.offset = currOffset;
 551                     stops.insert(0, newStop);
 552                     ++originalFirstStopIndex;
 553                     if (currOffset &lt; 0)
 554                         break;
 555 
 556                     if (srcStopOrdinal)
 557                         currOffset -= stops[originalFirstStopIndex + srcStopOrdinal].offset - stops[originalFirstStopIndex + srcStopOrdinal - 1].offset;
 558                     srcStopOrdinal = (srcStopOrdinal + originalNumStops - 1) % originalNumStops;
 559                 }
 560             }
 561 
 562             // Work forwards from the end, adding stops until we get one after 1.
 563             float lastOffset = stops[stops.size() - 1].offset;
 564             if (lastOffset &lt; maxExtent) {
 565                 float currOffset = lastOffset;
 566                 size_t srcStopOrdinal = 0;
 567 
 568                 while (true) {
 569                     size_t srcStopIndex = originalFirstStopIndex + srcStopOrdinal;
 570                     GradientStop newStop = stops[srcStopIndex];
 571                     newStop.offset = currOffset;
 572                     stops.append(newStop);
 573                     if (currOffset &gt; maxExtent)
 574                         break;
 575                     if (srcStopOrdinal &lt; originalNumStops - 1)
 576                         currOffset += stops[srcStopIndex + 1].offset - stops[srcStopIndex].offset;
 577                     srcStopOrdinal = (srcStopOrdinal + 1) % originalNumStops;
 578                 }
 579             }
 580         }
 581     }
 582 
 583     // If the gradient goes outside the 0-1 range, normalize it by moving the endpoints, and adjusting the stops.
 584     if (stops.size() &gt; 1 &amp;&amp; (stops.first().offset &lt; 0 || stops.last().offset &gt; 1))
 585         gradientAdapter.normalizeStopsAndEndpointsOutsideRange(stops);
 586 
 587     Gradient::ColorStopVector result;
 588     result.reserveInitialCapacity(stops.size());
 589     for (auto&amp; stop : stops)
 590         result.uncheckedAppend({ stop.offset, stop.color });
 591 
 592     return result;
 593 }
 594 
 595 static float positionFromValue(const CSSPrimitiveValue* value, const CSSToLengthConversionData&amp; conversionData, const FloatSize&amp; size, bool isHorizontal)
 596 {
 597     int origin = 0;
 598     int sign = 1;
 599     int edgeDistance = isHorizontal ? size.width() : size.height();
 600 
 601     // In this case the center of the gradient is given relative to an edge in the
 602     // form of: [ top | bottom | right | left ] [ &lt;percentage&gt; | &lt;length&gt; ].
 603     if (value-&gt;isPair()) {
 604         CSSValueID originID = value-&gt;pairValue()-&gt;first()-&gt;valueID();
 605         value = value-&gt;pairValue()-&gt;second();
 606 
 607         if (originID == CSSValueRight || originID == CSSValueBottom) {
 608             // For right/bottom, the offset is relative to the far edge.
 609             origin = edgeDistance;
 610             sign = -1;
 611         }
 612     }
 613 
 614     if (value-&gt;isNumber())
 615         return origin + sign * value-&gt;floatValue() * conversionData.zoom();
 616 
 617     if (value-&gt;isPercentage())
 618         return origin + sign * value-&gt;floatValue() / 100.f * edgeDistance;
 619 
 620     if (value-&gt;isCalculatedPercentageWithLength()) {
 621         Ref&lt;CalculationValue&gt; calculationValue { value-&gt;cssCalcValue()-&gt;createCalculationValue(conversionData) };
 622         return origin + sign * calculationValue-&gt;evaluate(edgeDistance);
 623     }
 624 
 625     switch (value-&gt;valueID()) {
 626     case CSSValueTop:
 627         ASSERT(!isHorizontal);
 628         return 0;
 629     case CSSValueLeft:
 630         ASSERT(isHorizontal);
 631         return 0;
 632     case CSSValueBottom:
 633         ASSERT(!isHorizontal);
 634         return size.height();
 635     case CSSValueRight:
 636         ASSERT(isHorizontal);
 637         return size.width();
 638     case CSSValueCenter:
 639         return origin + sign * .5f * edgeDistance;
 640     default:
 641         break;
 642     }
 643 
 644     return origin + sign * value-&gt;computeLength&lt;float&gt;(conversionData);
 645 }
 646 
 647 FloatPoint CSSGradientValue::computeEndPoint(CSSPrimitiveValue* horizontal, CSSPrimitiveValue* vertical, const CSSToLengthConversionData&amp; conversionData, const FloatSize&amp; size)
 648 {
 649     FloatPoint result;
 650 
 651     if (horizontal)
 652         result.setX(positionFromValue(horizontal, conversionData, size, true));
 653 
 654     if (vertical)
 655         result.setY(positionFromValue(vertical, conversionData, size, false));
 656 
 657     return result;
 658 }
 659 
 660 bool CSSGradientValue::isCacheable() const
 661 {
 662     for (auto&amp; stop : m_stops) {
 663         if (stop.m_colorIsDerivedFromElement)
 664             return false;
 665 
 666         if (!stop.m_position)
 667             continue;
 668 
 669         if (stop.m_position-&gt;isFontRelativeLength())
 670             return false;
 671     }
 672 
 673     return true;
 674 }
 675 
 676 bool CSSGradientValue::knownToBeOpaque(const RenderElement&amp; renderer) const
 677 {
 678     bool hasColorFilter = renderer.style().hasAppleColorFilter();
 679 
 680     for (auto&amp; stop : m_stops) {
 681         if (hasColorFilter) {
 682             Color stopColor = stop.m_resolvedColor;
 683             renderer.style().appleColorFilter().transformColor(stopColor);
 684             if (!stopColor.isOpaque())
 685                 return false;
 686         }
 687 
 688         if (!stop.m_resolvedColor.isOpaque())
 689             return false;
 690     }
 691     return true;
 692 }
 693 
 694 static void appendGradientStops(StringBuilder&amp; builder, const Vector&lt;CSSGradientColorStop, 2&gt;&amp; stops)
 695 {
 696     for (auto&amp; stop : stops) {
 697         double position = stop.m_position-&gt;doubleValue(CSSUnitType::CSS_NUMBER);
 698         if (!position)
 699             builder.append(&quot;, from(&quot;, stop.m_color-&gt;cssText(), &#39;)&#39;);
 700         else if (position == 1)
 701             builder.append(&quot;, to(&quot;, stop.m_color-&gt;cssText(), &#39;)&#39;);
 702         else
 703             builder.append(&quot;, color-stop(&quot;, position, &quot;, &quot;, stop.m_color-&gt;cssText(), &#39;)&#39;);
 704     }
 705 }
 706 
 707 void CSSGradientValue::writeColorStop(StringBuilder&amp; builder, const CSSGradientColorStop&amp; stop) const
 708 {
 709     if (!stop.isMidpoint &amp;&amp; stop.m_color)
 710         builder.append(stop.m_color-&gt;cssText());
 711 
 712     if (stop.m_position) {
 713         if (!stop.isMidpoint)
 714             builder.append(&#39; &#39;);
 715         builder.append(stop.m_position-&gt;cssText());
 716     }
 717 }
 718 
 719 String CSSLinearGradientValue::customCSSText() const
 720 {
 721     StringBuilder result;
 722     if (m_gradientType == CSSDeprecatedLinearGradient) {
 723         result.append(&quot;-webkit-gradient(linear, &quot;, m_firstX-&gt;cssText(), &#39; &#39;, m_firstY-&gt;cssText(), &quot;, &quot;, m_secondX-&gt;cssText(), &#39; &#39;, m_secondY-&gt;cssText());
 724         appendGradientStops(result, m_stops);
 725     } else if (m_gradientType == CSSPrefixedLinearGradient) {
 726         if (m_repeating)
 727             result.appendLiteral(&quot;-webkit-repeating-linear-gradient(&quot;);
 728         else
 729             result.appendLiteral(&quot;-webkit-linear-gradient(&quot;);
 730 
 731         if (m_angle)
 732             result.append(m_angle-&gt;cssText());
 733         else {
 734             if (m_firstX &amp;&amp; m_firstY)
 735                 result.append(m_firstX-&gt;cssText(), &#39; &#39;, m_firstY-&gt;cssText());
 736             else if (m_firstX)
 737                 result.append(m_firstX-&gt;cssText());
 738             else if (m_firstY)
 739                 result.append(m_firstY-&gt;cssText());
 740         }
 741 
 742         for (auto&amp; stop : m_stops) {
 743             result.appendLiteral(&quot;, &quot;);
 744             writeColorStop(result, stop);
 745         }
 746     } else {
 747         if (m_repeating)
 748             result.appendLiteral(&quot;repeating-linear-gradient(&quot;);
 749         else
 750             result.appendLiteral(&quot;linear-gradient(&quot;);
 751 
 752         bool wroteSomething = false;
 753 
 754         if (m_angle &amp;&amp; m_angle-&gt;computeDegrees() != 180) {
 755             result.append(m_angle-&gt;cssText());
 756             wroteSomething = true;
 757         } else if ((m_firstX || m_firstY) &amp;&amp; !(!m_firstX &amp;&amp; m_firstY &amp;&amp; m_firstY-&gt;valueID() == CSSValueBottom)) {
 758             result.appendLiteral(&quot;to &quot;);
 759             if (m_firstX &amp;&amp; m_firstY)
 760                 result.append(m_firstX-&gt;cssText(), &#39; &#39;, m_firstY-&gt;cssText());
 761             else if (m_firstX)
 762                 result.append(m_firstX-&gt;cssText());
 763             else
 764                 result.append(m_firstY-&gt;cssText());
 765             wroteSomething = true;
 766         }
 767 
 768         if (wroteSomething)
 769             result.appendLiteral(&quot;, &quot;);
 770 
 771         bool wroteFirstStop = false;
 772         for (auto&amp; stop : m_stops) {
 773             if (wroteFirstStop)
 774                 result.appendLiteral(&quot;, &quot;);
 775             wroteFirstStop = true;
 776             writeColorStop(result, stop);
 777         }
 778     }
 779 
 780     result.append(&#39;)&#39;);
 781     return result.toString();
 782 }
 783 
 784 // Compute the endpoints so that a gradient of the given angle covers a box of the given size.
 785 static void endPointsFromAngle(float angleDeg, const FloatSize&amp; size, FloatPoint&amp; firstPoint, FloatPoint&amp; secondPoint, CSSGradientType type)
 786 {
 787     // Prefixed gradients use &quot;polar coordinate&quot; angles, rather than &quot;bearing&quot; angles.
 788     if (type == CSSPrefixedLinearGradient)
 789         angleDeg = 90 - angleDeg;
 790 
 791     angleDeg = fmodf(angleDeg, 360);
 792     if (angleDeg &lt; 0)
 793         angleDeg += 360;
 794 
 795     if (!angleDeg) {
 796         firstPoint.set(0, size.height());
 797         secondPoint.set(0, 0);
 798         return;
 799     }
 800 
 801     if (angleDeg == 90) {
 802         firstPoint.set(0, 0);
 803         secondPoint.set(size.width(), 0);
 804         return;
 805     }
 806 
 807     if (angleDeg == 180) {
 808         firstPoint.set(0, 0);
 809         secondPoint.set(0, size.height());
 810         return;
 811     }
 812 
 813     if (angleDeg == 270) {
 814         firstPoint.set(size.width(), 0);
 815         secondPoint.set(0, 0);
 816         return;
 817     }
 818 
 819     // angleDeg is a &quot;bearing angle&quot; (0deg = N, 90deg = E),
 820     // but tan expects 0deg = E, 90deg = N.
 821     float slope = tan(deg2rad(90 - angleDeg));
 822 
 823     // We find the endpoint by computing the intersection of the line formed by the slope,
 824     // and a line perpendicular to it that intersects the corner.
 825     float perpendicularSlope = -1 / slope;
 826 
 827     // Compute start corner relative to center, in Cartesian space (+y = up).
 828     float halfHeight = size.height() / 2;
 829     float halfWidth = size.width() / 2;
 830     FloatPoint endCorner;
 831     if (angleDeg &lt; 90)
 832         endCorner.set(halfWidth, halfHeight);
 833     else if (angleDeg &lt; 180)
 834         endCorner.set(halfWidth, -halfHeight);
 835     else if (angleDeg &lt; 270)
 836         endCorner.set(-halfWidth, -halfHeight);
 837     else
 838         endCorner.set(-halfWidth, halfHeight);
 839 
 840     // Compute c (of y = mx + c) using the corner point.
 841     float c = endCorner.y() - perpendicularSlope * endCorner.x();
 842     float endX = c / (slope - perpendicularSlope);
 843     float endY = perpendicularSlope * endX + c;
 844 
 845     // We computed the end point, so set the second point,
 846     // taking into account the moved origin and the fact that we&#39;re in drawing space (+y = down).
 847     secondPoint.set(halfWidth + endX, halfHeight - endY);
 848     // Reflect around the center for the start point.
 849     firstPoint.set(halfWidth - endX, halfHeight + endY);
 850 }
 851 
 852 Ref&lt;Gradient&gt; CSSLinearGradientValue::createGradient(RenderElement&amp; renderer, const FloatSize&amp; size)
 853 {
 854     ASSERT(!size.isEmpty());
 855 
 856     CSSToLengthConversionData conversionData(&amp;renderer.style(), renderer.document().documentElement()-&gt;renderStyle(), &amp;renderer.view());
 857 
 858     FloatPoint firstPoint;
 859     FloatPoint secondPoint;
 860     if (m_angle) {
 861         float angle = m_angle-&gt;floatValue(CSSUnitType::CSS_DEG);
 862         endPointsFromAngle(angle, size, firstPoint, secondPoint, m_gradientType);
 863     } else {
 864         switch (m_gradientType) {
 865         case CSSDeprecatedLinearGradient:
 866             firstPoint = computeEndPoint(m_firstX.get(), m_firstY.get(), conversionData, size);
 867             if (m_secondX || m_secondY)
 868                 secondPoint = computeEndPoint(m_secondX.get(), m_secondY.get(), conversionData, size);
 869             else {
 870                 if (m_firstX)
 871                     secondPoint.setX(size.width() - firstPoint.x());
 872                 if (m_firstY)
 873                     secondPoint.setY(size.height() - firstPoint.y());
 874             }
 875             break;
 876         case CSSPrefixedLinearGradient:
 877             firstPoint = computeEndPoint(m_firstX.get(), m_firstY.get(), conversionData, size);
 878             if (m_firstX)
 879                 secondPoint.setX(size.width() - firstPoint.x());
 880             if (m_firstY)
 881                 secondPoint.setY(size.height() - firstPoint.y());
 882             break;
 883         case CSSLinearGradient:
 884             if (m_firstX &amp;&amp; m_firstY) {
 885                 // &quot;Magic&quot; corners, so the 50% line touches two corners.
 886                 float rise = size.width();
 887                 float run = size.height();
 888                 if (m_firstX &amp;&amp; m_firstX-&gt;valueID() == CSSValueLeft)
 889                     run *= -1;
 890                 if (m_firstY &amp;&amp; m_firstY-&gt;valueID() == CSSValueBottom)
 891                     rise *= -1;
 892                 // Compute angle, and flip it back to &quot;bearing angle&quot; degrees.
 893                 float angle = 90 - rad2deg(atan2(rise, run));
 894                 endPointsFromAngle(angle, size, firstPoint, secondPoint, m_gradientType);
 895             } else if (m_firstX || m_firstY) {
 896                 secondPoint = computeEndPoint(m_firstX.get(), m_firstY.get(), conversionData, size);
 897                 if (m_firstX)
 898                     firstPoint.setX(size.width() - secondPoint.x());
 899                 if (m_firstY)
 900                     firstPoint.setY(size.height() - secondPoint.y());
 901             } else
 902                 secondPoint.setY(size.height());
 903             break;
 904         default:
 905             ASSERT_NOT_REACHED();
 906         }
 907     }
 908 
 909     Gradient::LinearData data { firstPoint, secondPoint };
 910     LinearGradientAdapter adapter { data };
 911     auto stops = computeStops(adapter, conversionData, renderer.style(), 1);
 912 
 913     auto gradient = Gradient::create(WTFMove(data));
 914     gradient-&gt;setSortedColorStops(WTFMove(stops));
 915     return gradient;
 916 }
 917 
 918 bool CSSLinearGradientValue::equals(const CSSLinearGradientValue&amp; other) const
 919 {
 920     if (m_gradientType == CSSDeprecatedLinearGradient)
 921         return other.m_gradientType == m_gradientType
 922             &amp;&amp; compareCSSValuePtr(m_firstX, other.m_firstX)
 923             &amp;&amp; compareCSSValuePtr(m_firstY, other.m_firstY)
 924             &amp;&amp; compareCSSValuePtr(m_secondX, other.m_secondX)
 925             &amp;&amp; compareCSSValuePtr(m_secondY, other.m_secondY)
 926             &amp;&amp; m_stops == other.m_stops;
 927 
 928     if (m_gradientType != other.m_gradientType)
 929         return false;
 930 
 931     if (m_repeating != other.m_repeating)
 932         return false;
 933 
 934     if (m_angle)
 935         return compareCSSValuePtr(m_angle, other.m_angle) &amp;&amp; m_stops == other.m_stops;
 936 
 937     if (other.m_angle)
 938         return false;
 939 
 940     bool equalXandY = false;
 941     if (m_firstX &amp;&amp; m_firstY)
 942         equalXandY = compareCSSValuePtr(m_firstX, other.m_firstX) &amp;&amp; compareCSSValuePtr(m_firstY, other.m_firstY);
 943     else if (m_firstX)
 944         equalXandY = compareCSSValuePtr(m_firstX, other.m_firstX) &amp;&amp; !other.m_firstY;
 945     else if (m_firstY)
 946         equalXandY = compareCSSValuePtr(m_firstY, other.m_firstY) &amp;&amp; !other.m_firstX;
 947     else
 948         equalXandY = !other.m_firstX &amp;&amp; !other.m_firstY;
 949 
 950     return equalXandY &amp;&amp; m_stops == other.m_stops;
 951 }
 952 
 953 String CSSRadialGradientValue::customCSSText() const
 954 {
 955     StringBuilder result;
 956 
 957     if (m_gradientType == CSSDeprecatedRadialGradient) {
 958         result.append(&quot;-webkit-gradient(radial, &quot;, m_firstX-&gt;cssText(), &#39; &#39;, m_firstY-&gt;cssText(), &quot;, &quot;, m_firstRadius-&gt;cssText(),
 959             &quot;, &quot;, m_secondX-&gt;cssText(), &#39; &#39;, m_secondY-&gt;cssText(), &quot;, &quot;, m_secondRadius-&gt;cssText());
 960         appendGradientStops(result, m_stops);
 961     } else if (m_gradientType == CSSPrefixedRadialGradient) {
 962         if (m_repeating)
 963             result.appendLiteral(&quot;-webkit-repeating-radial-gradient(&quot;);
 964         else
 965             result.appendLiteral(&quot;-webkit-radial-gradient(&quot;);
 966 
 967         if (m_firstX &amp;&amp; m_firstY)
 968             result.append(m_firstX-&gt;cssText(), &#39; &#39;, m_firstY-&gt;cssText());
 969         else if (m_firstX)
 970             result.append(m_firstX-&gt;cssText());
 971         else if (m_firstY)
 972             result.append(m_firstY-&gt;cssText());
 973         else
 974             result.appendLiteral(&quot;center&quot;);
 975 
 976         if (m_shape || m_sizingBehavior) {
 977             result.appendLiteral(&quot;, &quot;);
 978             if (m_shape)
 979                 result.append(m_shape-&gt;cssText(), &#39; &#39;);
 980             else
 981                 result.appendLiteral(&quot;ellipse &quot;);
 982             if (m_sizingBehavior)
 983                 result.append(m_sizingBehavior-&gt;cssText());
 984             else
 985                 result.appendLiteral(&quot;cover&quot;);
 986         } else if (m_endHorizontalSize &amp;&amp; m_endVerticalSize)
 987             result.append(&quot;, &quot;, m_endHorizontalSize-&gt;cssText(), &#39; &#39;, m_endVerticalSize-&gt;cssText());
 988 
 989         for (auto&amp; stop : m_stops) {
 990             result.appendLiteral(&quot;, &quot;);
 991             writeColorStop(result, stop);
 992         }
 993     } else {
 994         if (m_repeating)
 995             result.appendLiteral(&quot;repeating-radial-gradient(&quot;);
 996         else
 997             result.appendLiteral(&quot;radial-gradient(&quot;);
 998 
 999         bool wroteSomething = false;
1000 
1001         // The only ambiguous case that needs an explicit shape to be provided
1002         // is when a sizing keyword is used (or all sizing is omitted).
1003         if (m_shape &amp;&amp; m_shape-&gt;valueID() != CSSValueEllipse &amp;&amp; (m_sizingBehavior || (!m_sizingBehavior &amp;&amp; !m_endHorizontalSize))) {
1004             result.appendLiteral(&quot;circle&quot;);
1005             wroteSomething = true;
1006         }
1007 
1008         if (m_sizingBehavior &amp;&amp; m_sizingBehavior-&gt;valueID() != CSSValueFarthestCorner) {
1009             if (wroteSomething)
1010                 result.append(&#39; &#39;);
1011             result.append(m_sizingBehavior-&gt;cssText());
1012             wroteSomething = true;
1013         } else if (m_endHorizontalSize) {
1014             if (wroteSomething)
1015                 result.append(&#39; &#39;);
1016             result.append(m_endHorizontalSize-&gt;cssText());
1017             if (m_endVerticalSize)
1018                 result.append(&#39; &#39;, m_endVerticalSize-&gt;cssText());
1019             wroteSomething = true;
1020         }
1021 
1022         if (m_firstX || m_firstY) {
1023             if (wroteSomething)
1024                 result.append(&#39; &#39;);
1025             result.appendLiteral(&quot;at &quot;);
1026             if (m_firstX &amp;&amp; m_firstY)
1027                 result.append(m_firstX-&gt;cssText(), &#39; &#39;, m_firstY-&gt;cssText());
1028             else if (m_firstX)
1029                 result.append(m_firstX-&gt;cssText());
1030             else
1031                 result.append(m_firstY-&gt;cssText());
1032             wroteSomething = true;
1033         }
1034 
1035         if (wroteSomething)
1036             result.appendLiteral(&quot;, &quot;);
1037 
1038         bool wroteFirstStop = false;
1039         for (auto&amp; stop : m_stops) {
1040             if (wroteFirstStop)
1041                 result.appendLiteral(&quot;, &quot;);
1042             wroteFirstStop = true;
1043             writeColorStop(result, stop);
1044         }
1045     }
1046 
1047     result.append(&#39;)&#39;);
1048     return result.toString();
1049 }
1050 
1051 float CSSRadialGradientValue::resolveRadius(CSSPrimitiveValue&amp; radius, const CSSToLengthConversionData&amp; conversionData, float* widthOrHeight)
1052 {
1053     float result = 0;
1054     if (radius.isNumber())
1055         result = radius.floatValue() * conversionData.zoom();
1056     else if (widthOrHeight &amp;&amp; radius.isPercentage())
1057         result = *widthOrHeight * radius.floatValue() / 100;
1058     else
1059         result = radius.computeLength&lt;float&gt;(conversionData);
1060     return result;
1061 }
1062 
1063 static float distanceToClosestCorner(const FloatPoint&amp; p, const FloatSize&amp; size, FloatPoint&amp; corner)
1064 {
1065     FloatPoint topLeft;
1066     float topLeftDistance = FloatSize(p - topLeft).diagonalLength();
1067 
1068     FloatPoint topRight(size.width(), 0);
1069     float topRightDistance = FloatSize(p - topRight).diagonalLength();
1070 
1071     FloatPoint bottomLeft(0, size.height());
1072     float bottomLeftDistance = FloatSize(p - bottomLeft).diagonalLength();
1073 
1074     FloatPoint bottomRight(size.width(), size.height());
1075     float bottomRightDistance = FloatSize(p - bottomRight).diagonalLength();
1076 
1077     corner = topLeft;
1078     float minDistance = topLeftDistance;
1079     if (topRightDistance &lt; minDistance) {
1080         minDistance = topRightDistance;
1081         corner = topRight;
1082     }
1083 
1084     if (bottomLeftDistance &lt; minDistance) {
1085         minDistance = bottomLeftDistance;
1086         corner = bottomLeft;
1087     }
1088 
1089     if (bottomRightDistance &lt; minDistance) {
1090         minDistance = bottomRightDistance;
1091         corner = bottomRight;
1092     }
1093     return minDistance;
1094 }
1095 
1096 static float distanceToFarthestCorner(const FloatPoint&amp; p, const FloatSize&amp; size, FloatPoint&amp; corner)
1097 {
1098     FloatPoint topLeft;
1099     float topLeftDistance = FloatSize(p - topLeft).diagonalLength();
1100 
1101     FloatPoint topRight(size.width(), 0);
1102     float topRightDistance = FloatSize(p - topRight).diagonalLength();
1103 
1104     FloatPoint bottomLeft(0, size.height());
1105     float bottomLeftDistance = FloatSize(p - bottomLeft).diagonalLength();
1106 
1107     FloatPoint bottomRight(size.width(), size.height());
1108     float bottomRightDistance = FloatSize(p - bottomRight).diagonalLength();
1109 
1110     corner = topLeft;
1111     float maxDistance = topLeftDistance;
1112     if (topRightDistance &gt; maxDistance) {
1113         maxDistance = topRightDistance;
1114         corner = topRight;
1115     }
1116 
1117     if (bottomLeftDistance &gt; maxDistance) {
1118         maxDistance = bottomLeftDistance;
1119         corner = bottomLeft;
1120     }
1121 
1122     if (bottomRightDistance &gt; maxDistance) {
1123         maxDistance = bottomRightDistance;
1124         corner = bottomRight;
1125     }
1126     return maxDistance;
1127 }
1128 
1129 // Compute horizontal radius of ellipse with center at 0,0 which passes through p, and has
1130 // width/height given by aspectRatio.
1131 static inline float horizontalEllipseRadius(const FloatSize&amp; p, float aspectRatio)
1132 {
1133     // x^2/a^2 + y^2/b^2 = 1
1134     // a/b = aspectRatio, b = a/aspectRatio
1135     // a = sqrt(x^2 + y^2/(1/r^2))
1136     return std::hypot(p.width(), p.height() * aspectRatio);
1137 }
1138 
1139 // FIXME: share code with the linear version
1140 Ref&lt;Gradient&gt; CSSRadialGradientValue::createGradient(RenderElement&amp; renderer, const FloatSize&amp; size)
1141 {
1142     ASSERT(!size.isEmpty());
1143 
1144     CSSToLengthConversionData conversionData(&amp;renderer.style(), renderer.document().documentElement()-&gt;renderStyle(), &amp;renderer.view());
1145 
1146     FloatPoint firstPoint = computeEndPoint(m_firstX.get(), m_firstY.get(), conversionData, size);
1147     if (!m_firstX)
1148         firstPoint.setX(size.width() / 2);
1149     if (!m_firstY)
1150         firstPoint.setY(size.height() / 2);
1151 
1152     FloatPoint secondPoint = computeEndPoint(m_secondX.get(), m_secondY.get(), conversionData, size);
1153     if (!m_secondX)
1154         secondPoint.setX(size.width() / 2);
1155     if (!m_secondY)
1156         secondPoint.setY(size.height() / 2);
1157 
1158     float firstRadius = 0;
1159     if (m_firstRadius)
1160         firstRadius = resolveRadius(*m_firstRadius, conversionData);
1161 
1162     float secondRadius = 0;
1163     float aspectRatio = 1; // width / height.
1164     if (m_secondRadius)
1165         secondRadius = resolveRadius(*m_secondRadius, conversionData);
1166     else if (m_endHorizontalSize) {
1167         float width = size.width();
1168         float height = size.height();
1169         secondRadius = resolveRadius(*m_endHorizontalSize, conversionData, &amp;width);
1170         if (m_endVerticalSize)
1171             aspectRatio = secondRadius / resolveRadius(*m_endVerticalSize, conversionData, &amp;height);
1172         else
1173             aspectRatio = 1;
1174     } else {
1175         enum GradientShape { Circle, Ellipse };
1176         GradientShape shape = Ellipse;
1177         if ((m_shape &amp;&amp; m_shape-&gt;valueID() == CSSValueCircle)
1178             || (!m_shape &amp;&amp; !m_sizingBehavior &amp;&amp; m_endHorizontalSize &amp;&amp; !m_endVerticalSize))
1179             shape = Circle;
1180 
1181         enum GradientFill { ClosestSide, ClosestCorner, FarthestSide, FarthestCorner };
1182         GradientFill fill = FarthestCorner;
1183 
1184         switch (m_sizingBehavior ? m_sizingBehavior-&gt;valueID() : 0) {
1185         case CSSValueContain:
1186         case CSSValueClosestSide:
1187             fill = ClosestSide;
1188             break;
1189         case CSSValueClosestCorner:
1190             fill = ClosestCorner;
1191             break;
1192         case CSSValueFarthestSide:
1193             fill = FarthestSide;
1194             break;
1195         case CSSValueCover:
1196         case CSSValueFarthestCorner:
1197             fill = FarthestCorner;
1198             break;
1199         default:
1200             break;
1201         }
1202 
1203         // Now compute the end radii based on the second point, shape and fill.
1204 
1205         // Horizontal
1206         switch (fill) {
1207         case ClosestSide: {
1208             float xDist = std::min(secondPoint.x(), size.width() - secondPoint.x());
1209             float yDist = std::min(secondPoint.y(), size.height() - secondPoint.y());
1210             if (shape == Circle) {
1211                 float smaller = std::min(xDist, yDist);
1212                 xDist = smaller;
1213                 yDist = smaller;
1214             }
1215             secondRadius = xDist;
1216             aspectRatio = xDist / yDist;
1217             break;
1218         }
1219         case FarthestSide: {
1220             float xDist = std::max(secondPoint.x(), size.width() - secondPoint.x());
1221             float yDist = std::max(secondPoint.y(), size.height() - secondPoint.y());
1222             if (shape == Circle) {
1223                 float larger = std::max(xDist, yDist);
1224                 xDist = larger;
1225                 yDist = larger;
1226             }
1227             secondRadius = xDist;
1228             aspectRatio = xDist / yDist;
1229             break;
1230         }
1231         case ClosestCorner: {
1232             FloatPoint corner;
1233             float distance = distanceToClosestCorner(secondPoint, size, corner);
1234             if (shape == Circle)
1235                 secondRadius = distance;
1236             else {
1237                 // If &lt;shape&gt; is ellipse, the gradient-shape has the same ratio of width to height
1238                 // that it would if closest-side or farthest-side were specified, as appropriate.
1239                 float xDist = std::min(secondPoint.x(), size.width() - secondPoint.x());
1240                 float yDist = std::min(secondPoint.y(), size.height() - secondPoint.y());
1241 
1242                 secondRadius = horizontalEllipseRadius(corner - secondPoint, xDist / yDist);
1243                 aspectRatio = xDist / yDist;
1244             }
1245             break;
1246         }
1247 
1248         case FarthestCorner: {
1249             FloatPoint corner;
1250             float distance = distanceToFarthestCorner(secondPoint, size, corner);
1251             if (shape == Circle)
1252                 secondRadius = distance;
1253             else {
1254                 // If &lt;shape&gt; is ellipse, the gradient-shape has the same ratio of width to height
1255                 // that it would if closest-side or farthest-side were specified, as appropriate.
1256                 float xDist = std::max(secondPoint.x(), size.width() - secondPoint.x());
1257                 float yDist = std::max(secondPoint.y(), size.height() - secondPoint.y());
1258 
1259                 secondRadius = horizontalEllipseRadius(corner - secondPoint, xDist / yDist);
1260                 aspectRatio = xDist / yDist;
1261             }
1262             break;
1263         }
1264         }
1265     }
1266 
1267     // computeStops() only uses maxExtent for repeating gradients.
1268     float maxExtent = 0;
1269     if (m_repeating) {
1270         FloatPoint corner;
1271         maxExtent = distanceToFarthestCorner(secondPoint, size, corner);
1272     }
1273 
1274     Gradient::RadialData data { firstPoint, secondPoint, firstRadius, secondRadius, aspectRatio };
1275     RadialGradientAdapter adapter { data };
1276     auto stops = computeStops(adapter, conversionData, renderer.style(), maxExtent);
1277 
1278     auto gradient = Gradient::create(WTFMove(data));
1279     gradient-&gt;setSortedColorStops(WTFMove(stops));
1280     return gradient;
1281 }
1282 
1283 bool CSSRadialGradientValue::equals(const CSSRadialGradientValue&amp; other) const
1284 {
1285     if (m_gradientType == CSSDeprecatedRadialGradient)
1286         return other.m_gradientType == m_gradientType
1287             &amp;&amp; compareCSSValuePtr(m_firstX, other.m_firstX)
1288             &amp;&amp; compareCSSValuePtr(m_firstY, other.m_firstY)
1289             &amp;&amp; compareCSSValuePtr(m_secondX, other.m_secondX)
1290             &amp;&amp; compareCSSValuePtr(m_secondY, other.m_secondY)
1291             &amp;&amp; compareCSSValuePtr(m_firstRadius, other.m_firstRadius)
1292             &amp;&amp; compareCSSValuePtr(m_secondRadius, other.m_secondRadius)
1293             &amp;&amp; m_stops == other.m_stops;
1294 
1295     if (m_gradientType != other.m_gradientType)
1296         return false;
1297 
1298     if (m_repeating != other.m_repeating)
1299         return false;
1300 
1301     bool equalXandY = false;
1302     if (m_firstX &amp;&amp; m_firstY)
1303         equalXandY = compareCSSValuePtr(m_firstX, other.m_firstX) &amp;&amp; compareCSSValuePtr(m_firstY, other.m_firstY);
1304     else if (m_firstX)
1305         equalXandY = compareCSSValuePtr(m_firstX, other.m_firstX) &amp;&amp; !other.m_firstY;
1306     else if (m_firstY)
1307         equalXandY = compareCSSValuePtr(m_firstY, other.m_firstY) &amp;&amp; !other.m_firstX;
1308     else
1309         equalXandY = !other.m_firstX &amp;&amp; !other.m_firstY;
1310 
1311     if (!equalXandY)
1312         return false;
1313 
1314     bool equalShape = true;
1315     bool equalSizingBehavior = true;
1316     bool equalHorizontalAndVerticalSize = true;
1317 
1318     if (m_shape)
1319         equalShape = compareCSSValuePtr(m_shape, other.m_shape);
1320     else if (m_sizingBehavior)
1321         equalSizingBehavior = compareCSSValuePtr(m_sizingBehavior, other.m_sizingBehavior);
1322     else if (m_endHorizontalSize &amp;&amp; m_endVerticalSize)
1323         equalHorizontalAndVerticalSize = compareCSSValuePtr(m_endHorizontalSize, other.m_endHorizontalSize) &amp;&amp; compareCSSValuePtr(m_endVerticalSize, other.m_endVerticalSize);
1324     else {
1325         equalShape = !other.m_shape;
1326         equalSizingBehavior = !other.m_sizingBehavior;
1327         equalHorizontalAndVerticalSize = !other.m_endHorizontalSize &amp;&amp; !other.m_endVerticalSize;
1328     }
1329     return equalShape &amp;&amp; equalSizingBehavior &amp;&amp; equalHorizontalAndVerticalSize &amp;&amp; m_stops == other.m_stops;
1330 }
1331 
1332 
1333 String CSSConicGradientValue::customCSSText() const
1334 {
1335     StringBuilder result;
1336 
1337     if (m_repeating)
1338         result.appendLiteral(&quot;repeating-conic-gradient(&quot;);
1339     else
1340         result.appendLiteral(&quot;conic-gradient(&quot;);
1341 
1342     bool wroteSomething = false;
1343 
1344     if (m_angle) {
1345         result.append(&quot;from &quot;, m_angle-&gt;cssText());
1346         wroteSomething = true;
1347     }
1348 
1349     if (m_firstX &amp;&amp; m_firstY) {
1350         if (wroteSomething)
1351             result.append(&#39; &#39;);
1352         result.append(&quot;at &quot;, m_firstX-&gt;cssText(), &#39; &#39;, m_firstY-&gt;cssText());
1353         wroteSomething = true;
1354     }
1355 
1356     if (wroteSomething)
1357         result.appendLiteral(&quot;, &quot;);
1358 
1359     bool wroteFirstStop = false;
1360     for (auto&amp; stop : m_stops) {
1361         if (wroteFirstStop)
1362             result.appendLiteral(&quot;, &quot;);
1363         wroteFirstStop = true;
1364         writeColorStop(result, stop);
1365     }
1366 
1367     result.append(&#39;)&#39;);
1368     return result.toString();
1369 }
1370 
1371 Ref&lt;Gradient&gt; CSSConicGradientValue::createGradient(RenderElement&amp; renderer, const FloatSize&amp; size)
1372 {
1373     ASSERT(!size.isEmpty());
1374 
1375     CSSToLengthConversionData conversionData(&amp;renderer.style(), renderer.document().documentElement()-&gt;renderStyle(), &amp;renderer.view());
1376 
1377     FloatPoint centerPoint = computeEndPoint(m_firstX.get(), m_firstY.get(), conversionData, size);
1378     if (!m_firstX)
1379         centerPoint.setX(size.width() / 2);
1380     if (!m_firstY)
1381         centerPoint.setY(size.height() / 2);
1382 
1383     float angleRadians = 0;
1384     if (m_angle)
1385         angleRadians = m_angle-&gt;floatValue(CSSUnitType::CSS_RAD);
1386 
1387     Gradient::ConicData data { centerPoint, angleRadians };
1388     ConicGradientAdapter adapter;
1389     auto stops = computeStops(adapter, conversionData, renderer.style(), 1);
1390 
1391     auto gradient = Gradient::create(WTFMove(data));
1392     gradient-&gt;setSortedColorStops(WTFMove(stops));
1393     return gradient;
1394 }
1395 
1396 bool CSSConicGradientValue::equals(const CSSConicGradientValue&amp; other) const
1397 {
1398     if (m_repeating != other.m_repeating)
1399         return false;
1400 
1401     if (!compareCSSValuePtr(m_angle, other.m_angle))
1402         return false;
1403 
1404     bool equalXandY = false;
1405     if (m_firstX &amp;&amp; m_firstY)
1406         equalXandY = compareCSSValuePtr(m_firstX, other.m_firstX) &amp;&amp; compareCSSValuePtr(m_firstY, other.m_firstY);
1407     else if (m_firstX)
1408         equalXandY = compareCSSValuePtr(m_firstX, other.m_firstX) &amp;&amp; !other.m_firstY;
1409     else if (m_firstY)
1410         equalXandY = compareCSSValuePtr(m_firstY, other.m_firstY) &amp;&amp; !other.m_firstX;
1411     else
1412         equalXandY = !other.m_firstX &amp;&amp; !other.m_firstY;
1413 
1414     return equalXandY &amp;&amp; m_stops == other.m_stops;
1415 }
1416 
1417 } // namespace WebCore
    </pre>
  </body>
</html>
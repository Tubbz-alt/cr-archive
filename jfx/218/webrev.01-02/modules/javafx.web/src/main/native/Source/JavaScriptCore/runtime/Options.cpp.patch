diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Options.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Options.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Options.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Options.cpp
@@ -39,10 +39,11 @@
 #include <string.h>
 #include <wtf/ASCIICType.h>
 #include <wtf/Compiler.h>
 #include <wtf/DataLog.h>
 #include <wtf/NumberOfCores.h>
+#include <wtf/Optional.h>
 #include <wtf/PointerPreparations.h>
 #include <wtf/StdLibExtras.h>
 #include <wtf/text/StringBuilder.h>
 #include <wtf/threads/Signals.h>
 
@@ -54,103 +55,102 @@
 #include "MacroAssembler.h"
 #endif
 
 namespace JSC {
 
-namespace {
-#ifdef NDEBUG
-bool restrictedOptionsEnabled = false;
-#else
-bool restrictedOptionsEnabled = true;
-#endif
-}
-
-void Options::enableRestrictedOptions(bool enableOrNot)
-{
-    restrictedOptionsEnabled = enableOrNot;
-}
+template<typename T>
+Optional<T> parse(const char* string);
 
-static bool parse(const char* string, bool& value)
+template<>
+Optional<OptionsStorage::Bool> parse(const char* string)
 {
-    if (equalLettersIgnoringASCIICase(string, "true") || equalLettersIgnoringASCIICase(string, "yes") || !strcmp(string, "1")) {
-        value = true;
+    if (equalLettersIgnoringASCIICase(string, "true") || equalLettersIgnoringASCIICase(string, "yes") || !strcmp(string, "1"))
         return true;
-    }
-    if (equalLettersIgnoringASCIICase(string, "false") || equalLettersIgnoringASCIICase(string, "no") || !strcmp(string, "0")) {
-        value = false;
-        return true;
-    }
-    return false;
-}
-
-static bool parse(const char* string, int32_t& value)
-{
-    return sscanf(string, "%d", &value) == 1;
+    if (equalLettersIgnoringASCIICase(string, "false") || equalLettersIgnoringASCIICase(string, "no") || !strcmp(string, "0"))
+        return false;
+    return WTF::nullopt;
 }
 
-static bool parse(const char* string, unsigned& value)
+template<>
+Optional<OptionsStorage::Int32> parse(const char* string)
 {
-    return sscanf(string, "%u", &value) == 1;
+    int32_t value;
+    if (sscanf(string, "%d", &value) == 1)
+        return value;
+    return WTF::nullopt;
 }
 
-static bool UNUSED_FUNCTION parse(const char* string, unsigned long& value)
+template<>
+Optional<OptionsStorage::Unsigned> parse(const char* string)
 {
-    return sscanf(string, "%lu", &value);
+    unsigned value;
+    if (sscanf(string, "%u", &value) == 1)
+        return value;
+    return WTF::nullopt;
 }
 
-static bool UNUSED_FUNCTION parse(const char* string, unsigned long long& value)
+#if CPU(ADDRESS64) || OS(DARWIN)
+template<>
+Optional<OptionsStorage::Size> parse(const char* string)
 {
-    return sscanf(string, "%llu", &value);
+    size_t value;
+    if (sscanf(string, "%zu", &value) == 1)
+        return value;
+    return WTF::nullopt;
 }
+#endif // CPU(ADDRESS64) || OS(DARWIN)
 
-static bool parse(const char* string, double& value)
+template<>
+Optional<OptionsStorage::Double> parse(const char* string)
 {
-    return sscanf(string, "%lf", &value) == 1;
+    double value;
+    if (sscanf(string, "%lf", &value) == 1)
+        return value;
+    return WTF::nullopt;
 }
 
-static bool parse(const char* string, OptionRange& value)
+template<>
+Optional<OptionsStorage::OptionRange> parse(const char* string)
 {
-    return value.init(string);
+    OptionRange range;
+    if (range.init(string))
+        return range;
+    return WTF::nullopt;
 }
 
-static bool parse(const char* string, const char*& value)
+template<>
+Optional<OptionsStorage::OptionString> parse(const char* string)
 {
-    if (!strlen(string)) {
-        value = nullptr;
-        return true;
-    }
+    const char* value = nullptr;
+    if (!strlen(string))
+        return value;
 
     // FIXME <https://webkit.org/b/169057>: This could leak if this option is set more than once.
     // Given that Options are typically used for testing, this isn't considered to be a problem.
     value = WTF::fastStrDup(string);
-    return true;
+    return value;
 }
 
-static bool parse(const char* string, GCLogging::Level& value)
+template<>
+Optional<OptionsStorage::GCLogLevel> parse(const char* string)
 {
-    if (equalLettersIgnoringASCIICase(string, "none") || equalLettersIgnoringASCIICase(string, "no") || equalLettersIgnoringASCIICase(string, "false") || !strcmp(string, "0")) {
-        value = GCLogging::None;
-        return true;
-    }
+    if (equalLettersIgnoringASCIICase(string, "none") || equalLettersIgnoringASCIICase(string, "no") || equalLettersIgnoringASCIICase(string, "false") || !strcmp(string, "0"))
+        return GCLogging::None;
 
-    if (equalLettersIgnoringASCIICase(string, "basic") || equalLettersIgnoringASCIICase(string, "yes") || equalLettersIgnoringASCIICase(string, "true") || !strcmp(string, "1")) {
-        value = GCLogging::Basic;
-        return true;
-    }
+    if (equalLettersIgnoringASCIICase(string, "basic") || equalLettersIgnoringASCIICase(string, "yes") || equalLettersIgnoringASCIICase(string, "true") || !strcmp(string, "1"))
+        return GCLogging::Basic;
 
-    if (equalLettersIgnoringASCIICase(string, "verbose") || !strcmp(string, "2")) {
-        value = GCLogging::Verbose;
-        return true;
-    }
+    if (equalLettersIgnoringASCIICase(string, "verbose") || !strcmp(string, "2"))
+        return GCLogging::Verbose;
 
-    return false;
+    return WTF::nullopt;
 }
 
 bool Options::isAvailable(Options::ID id, Options::Availability availability)
 {
     if (availability == Availability::Restricted)
-        return restrictedOptionsEnabled;
+        return g_jscConfig.restrictedOptionsEnabled;
     ASSERT(availability == Availability::Configurable);
 
     UNUSED_PARAM(id);
 #if !defined(NDEBUG)
     if (id == maxSingleAllocationSizeID)
@@ -179,12 +179,17 @@
 
     const char* stringValue = getenv(name);
     if (!stringValue)
         return false;
 
-    if (available && parse(stringValue, variable))
-        return true;
+    if (available) {
+        Optional<T> value = parse<T>(stringValue);
+        if (value) {
+            variable = value.value();
+            return true;
+        }
+    }
 
     fprintf(stderr, "WARNING: failed to parse %s=%s\n", name, stringValue);
     return false;
 }
 
@@ -293,51 +298,38 @@
 void OptionRange::dump(PrintStream& out) const
 {
     out.print(m_rangeString);
 }
 
-Options::Entry Options::s_options[Options::numberOfOptions];
-Options::Entry Options::s_defaultOptions[Options::numberOfOptions];
-
 // Realize the names for each of the options:
-const Options::EntryInfo Options::s_optionsInfo[Options::numberOfOptions] = {
-#define FOR_EACH_OPTION(type_, name_, defaultValue_, availability_, description_) \
-    { #name_, description_, Options::Type::type_##Type, Availability::availability_ },
-    JSC_OPTIONS(FOR_EACH_OPTION)
-#undef FOR_EACH_OPTION
+const Options::ConstMetaData Options::s_constMetaData[NumberOfOptions] = {
+#define FILL_OPTION_INFO(type_, name_, defaultValue_, availability_, description_) \
+    { #name_, description_, Options::Type::type_, Availability::availability_, offsetof(OptionsStorage, name_), offsetof(OptionsStorage, name_##Default) },
+    FOR_EACH_JSC_OPTION(FILL_OPTION_INFO)
+#undef FILL_OPTION_INFO
 };
 
 static void scaleJITPolicy()
 {
     auto& scaleFactor = Options::jitPolicyScale();
     if (scaleFactor > 1.0)
         scaleFactor = 1.0;
     else if (scaleFactor < 0.0)
         scaleFactor = 0.0;
 
-    struct OptionToScale {
-        Options::ID id;
-        int32_t minVal;
+    auto scaleOption = [&] (int32_t& optionValue, int32_t minValue) {
+        optionValue *= scaleFactor;
+        optionValue = std::max(optionValue, minValue);
     };
 
-    static const OptionToScale optionsToScale[] = {
-        { Options::thresholdForJITAfterWarmUpID, 0 },
-        { Options::thresholdForJITSoonID, 0 },
-        { Options::thresholdForOptimizeAfterWarmUpID, 1 },
-        { Options::thresholdForOptimizeAfterLongWarmUpID, 1 },
-        { Options::thresholdForOptimizeSoonID, 1 },
-        { Options::thresholdForFTLOptimizeSoonID, 2 },
-        { Options::thresholdForFTLOptimizeAfterWarmUpID, 2 }
-    };
-
-    const int numberOfOptionsToScale = sizeof(optionsToScale) / sizeof(OptionToScale);
-    for (int i = 0; i < numberOfOptionsToScale; i++) {
-        Option option(optionsToScale[i].id);
-        ASSERT(option.type() == Options::Type::int32Type);
-        option.int32Val() *= scaleFactor;
-        option.int32Val() = std::max(option.int32Val(), optionsToScale[i].minVal);
-    }
+    scaleOption(Options::thresholdForJITAfterWarmUp(), 0);
+    scaleOption(Options::thresholdForJITSoon(), 0);
+    scaleOption(Options::thresholdForOptimizeAfterWarmUp(), 1);
+    scaleOption(Options::thresholdForOptimizeAfterLongWarmUp(), 1);
+    scaleOption(Options::thresholdForOptimizeSoon(), 1);
+    scaleOption(Options::thresholdForFTLOptimizeSoon(), 2);
+    scaleOption(Options::thresholdForFTLOptimizeAfterWarmUp(), 2);
 }
 
 static void overrideDefaults()
 {
 #if !PLATFORM(IOS_FAMILY)
@@ -352,19 +344,19 @@
             Options::gcIncrementScale() = 1;
         else
             Options::gcIncrementScale() = 0;
     }
 
-#if PLATFORM(IOS_FAMILY)
-    // On iOS, we control heap growth using process memory footprint. Therefore these values can be agressive.
+#if USE(BMALLOC_MEMORY_FOOTPRINT_API)
+    // On iOS and conditionally Linux, we control heap growth using process memory footprint. Therefore these values can be agressive.
     Options::smallHeapRAMFraction() = 0.8;
     Options::mediumHeapRAMFraction() = 0.9;
+#endif
 
-#if !PLATFORM(WATCHOS) && defined(__LP64__)
+#if PLATFORM(IOS_FAMILY) && !PLATFORM(WATCHOS) && defined(__LP64__)
     Options::useSigillCrashAnalyzer() = true;
 #endif
-#endif
 
 #if !ENABLE(SIGNAL_BASED_VM_TRAPS)
     Options::usePollingTraps() = true;
 #endif
 
@@ -373,10 +365,15 @@
 #endif
 
 #if !HAVE(MACH_EXCEPTIONS)
     Options::useMachForExceptions() = false;
 #endif
+
+    if (Options::useWasmLLInt() && !Options::wasmLLIntTiersUpToBBQ()) {
+        Options::thresholdForOMGOptimizeAfterWarmUp() = 1500;
+        Options::thresholdForOMGOptimizeSoon() = 100;
+    }
 }
 
 static void correctOptions()
 {
     unsigned thresholdForGlobalLexicalBindingEpoch = Options::thresholdForGlobalLexicalBindingEpoch();
@@ -449,17 +446,17 @@
         || Options::reportFTLCompileTimes()
         || Options::logPhaseTimes()
         || Options::verboseCFA()
         || Options::verboseDFGFailure()
         || Options::verboseFTLFailure()
-        || Options::dumpRandomizingFuzzerAgentPredictions())
+        || Options::dumpFuzzerAgentPredictions())
         Options::alwaysComputeHash() = true;
 
     if (!Options::useConcurrentGC())
         Options::collectContinuously() = false;
 
-    if (Option(Options::jitPolicyScaleID).isOverridden())
+    if (Options::jitPolicyScale() != Options::jitPolicyScaleDefault())
         scaleJITPolicy();
 
     if (Options::forceEagerCompilation()) {
         Options::thresholdForJITAfterWarmUp() = 10;
         Options::thresholdForJITSoon() = 10;
@@ -510,33 +507,61 @@
     if (Options::reservedZoneSize() < minimumReservedZoneSize)
         Options::reservedZoneSize() = minimumReservedZoneSize;
     if (Options::softReservedZoneSize() < Options::reservedZoneSize() + minimumReservedZoneSize)
         Options::softReservedZoneSize() = Options::reservedZoneSize() + minimumReservedZoneSize;
 
-#if USE(JSVALUE32_64)
     // FIXME: Make probe OSR exit work on 32-bit:
     // https://bugs.webkit.org/show_bug.cgi?id=177956
     Options::useProbeOSRExit() = false;
-#endif
 
     if (!Options::useCodeCache())
         Options::diskCachePath() = nullptr;
+
+    if (Options::randomIntegrityAuditRate() < 0)
+        Options::randomIntegrityAuditRate() = 0;
+    else if (Options::randomIntegrityAuditRate() > 1.0)
+        Options::randomIntegrityAuditRate() = 1.0;
+}
+
+inline void* Options::addressOfOption(Options::ID id)
+{
+    auto offset = Options::s_constMetaData[id].offsetOfOption;
+    return reinterpret_cast<uint8_t*>(&g_jscConfig.options) + offset;
+}
+
+inline void* Options::addressOfOptionDefault(Options::ID id)
+{
+    auto offset = Options::s_constMetaData[id].offsetOfOptionDefault;
+    return reinterpret_cast<uint8_t*>(&g_jscConfig.options) + offset;
 }
 
 void Options::initialize()
 {
     static std::once_flag initializeOptionsOnceFlag;
 
     std::call_once(
         initializeOptionsOnceFlag,
         [] {
+            // Sanity check that options address computation is working.
+            RELEASE_ASSERT(Options::addressOfOption(useKernTCSMID) ==  &Options::useKernTCSM());
+            RELEASE_ASSERT(Options::addressOfOptionDefault(useKernTCSMID) ==  &Options::useKernTCSMDefault());
+            RELEASE_ASSERT(Options::addressOfOption(gcMaxHeapSizeID) ==  &Options::gcMaxHeapSize());
+            RELEASE_ASSERT(Options::addressOfOptionDefault(gcMaxHeapSizeID) ==  &Options::gcMaxHeapSizeDefault());
+            RELEASE_ASSERT(Options::addressOfOption(forceOSRExitToLLIntID) ==  &Options::forceOSRExitToLLInt());
+            RELEASE_ASSERT(Options::addressOfOptionDefault(forceOSRExitToLLIntID) ==  &Options::forceOSRExitToLLIntDefault());
+
+#ifndef NDEBUG
+            Config::enableRestrictedOptions();
+#endif
             // Initialize each of the options with their default values:
-#define FOR_EACH_OPTION(type_, name_, defaultValue_, availability_, description_) \
-            name_() = defaultValue_;                                    \
-            name_##Default() = defaultValue_;
-            JSC_OPTIONS(FOR_EACH_OPTION)
-#undef FOR_EACH_OPTION
+#define INIT_OPTION(type_, name_, defaultValue_, availability_, description_) { \
+                auto value = defaultValue_; \
+                name_() = value; \
+                name_##Default() = value; \
+            }
+            FOR_EACH_JSC_OPTION(INIT_OPTION)
+#undef INIT_OPTION
 
             overrideDefaults();
 
             // Allow environment vars to override options if applicable.
             // The evn var should be the name of the option prefixed with
@@ -553,20 +578,20 @@
                 }
             }
             if (hasBadOptions && Options::validateOptions())
                 CRASH();
 #else // PLATFORM(COCOA)
-#define FOR_EACH_OPTION(type_, name_, defaultValue_, availability_, description_) \
+#define OVERRIDE_OPTION_WITH_HEURISTICS(type_, name_, defaultValue_, availability_, description_) \
             overrideOptionWithHeuristic(name_(), name_##ID, "JSC_" #name_, Availability::availability_);
-            JSC_OPTIONS(FOR_EACH_OPTION)
-#undef FOR_EACH_OPTION
+            FOR_EACH_JSC_OPTION(OVERRIDE_OPTION_WITH_HEURISTICS)
+#undef OVERRIDE_OPTION_WITH_HEURISTICS
 #endif // PLATFORM(COCOA)
 
-#define FOR_EACH_OPTION(aliasedName_, unaliasedName_, equivalence_) \
+#define OVERRIDE_ALIASED_OPTION_WITH_HEURISTICS(aliasedName_, unaliasedName_, equivalence_) \
             overrideAliasedOptionWithHeuristic("JSC_" #aliasedName_);
-            JSC_ALIASED_OPTIONS(FOR_EACH_OPTION)
-#undef FOR_EACH_OPTION
+            FOR_EACH_JSC_ALIASED_OPTION(OVERRIDE_ALIASED_OPTION_WITH_HEURISTICS)
+#undef OVERRIDE_ALIASED_OPTION_WITH_HEURISTICS
 
 #if 0
                 ; // Deconfuse editors that do auto indentation
 #endif
 
@@ -640,10 +665,11 @@
     return isASCIISpace(c) || (c == ',');
 }
 
 bool Options::setOptions(const char* optionsStr)
 {
+    RELEASE_ASSERT(!g_jscConfig.isPermanentlyFrozen);
     Vector<char*> options;
 
     size_t length = strlen(optionsStr);
     char* optionsStrCopy = WTF::fastStrDup(optionsStr);
     char* end = optionsStrCopy + length;
@@ -732,43 +758,41 @@
     if (!equalStr)
         return false;
 
     const char* valueStr = equalStr + 1;
 
-    // For each option, check if the specify arg is a match. If so, set the arg
+    // For each option, check if the specified arg is a match. If so, set the arg
     // if the value makes sense. Otherwise, move on to checking the next option.
-#define FOR_EACH_OPTION(type_, name_, defaultValue_, availability_, description_) \
+#define SET_OPTION_IF_MATCH(type_, name_, defaultValue_, availability_, description_) \
     if (strlen(#name_) == static_cast<size_t>(equalStr - arg)      \
         && !strncmp(arg, #name_, equalStr - arg)) {                \
         if (Availability::availability_ != Availability::Normal     \
             && !isAvailable(name_##ID, Availability::availability_)) \
             return false;                                          \
-        type_ value;                                               \
-        value = (defaultValue_);                                   \
-        bool success = parse(valueStr, value);                     \
-        if (success) {                                             \
-            name_() = value;                                       \
+        Optional<OptionsStorage::type_> value;                     \
+        value = parse<OptionsStorage::type_>(valueStr);            \
+        if (value) {                                               \
+            name_() = value.value();                               \
             correctOptions();                                      \
             recomputeDependentOptions();                           \
             return true;                                           \
         }                                                          \
         return false;                                              \
     }
 
-    JSC_OPTIONS(FOR_EACH_OPTION)
-#undef FOR_EACH_OPTION
+    FOR_EACH_JSC_OPTION(SET_OPTION_IF_MATCH)
+#undef SET_OPTION_IF_MATCH
 
     return false; // No option matched.
 }
 
-static bool invertBoolOptionValue(const char* valueStr, const char*& invertedValueStr)
+static const char* invertBoolOptionValue(const char* valueStr)
 {
-    bool boolValue;
-    if (!parse(valueStr, boolValue))
-        return false;
-    invertedValueStr = boolValue ? "false" : "true";
-    return true;
+    Optional<OptionsStorage::Bool> value = parse<OptionsStorage::Bool>(valueStr);
+    if (!value)
+        return nullptr;
+    return value.value() ? "false" : "true";
 }
 
 
 bool Options::setAliasedOption(const char* arg)
 {
@@ -788,19 +812,19 @@
         String unaliasedOption(#unaliasedName_);                        \
         if (equivalence == SameOption)                                  \
             unaliasedOption = unaliasedOption + equalStr;               \
         else {                                                          \
             ASSERT(equivalence == InvertedOption);                      \
-            const char* invertedValueStr = nullptr;                     \
-            if (!invertBoolOptionValue(equalStr + 1, invertedValueStr)) \
+            auto* invertedValueStr = invertBoolOptionValue(equalStr + 1); \
+            if (!invertedValueStr)                                      \
                 return false;                                           \
             unaliasedOption = unaliasedOption + "=" + invertedValueStr; \
         }                                                               \
         return setOptionWithoutAlias(unaliasedOption.utf8().data());   \
     }
 
-    JSC_ALIASED_OPTIONS(FOR_EACH_OPTION)
+    FOR_EACH_JSC_ALIASED_OPTION(FOR_EACH_OPTION)
 #undef FOR_EACH_OPTION
 
     IGNORE_WARNINGS_END
 
     return false; // No option matched.
@@ -821,11 +845,11 @@
     if (title) {
         builder.append(title);
         builder.append('\n');
     }
 
-    for (int id = 0; id < numberOfOptions; id++) {
+    for (size_t id = 0; id < NumberOfOptions; id++) {
         if (separator && id)
             builder.append(separator);
         dumpOption(builder, level, static_cast<ID>(id), optionHeader, optionFooter, dumpDefaultsOption);
     }
 }
@@ -840,17 +864,58 @@
     StringBuilder builder;
     dumpAllOptions(builder, level, title, nullptr, "   ", "\n", DumpDefaults);
     fprintf(stream, "%s", builder.toString().utf8().data());
 }
 
+struct OptionReader {
+    class Option {
+    public:
+        void dump(StringBuilder&) const;
+
+        bool operator==(const Option& other) const;
+        bool operator!=(const Option& other) const { return !(*this == other); }
+
+        const char* name() const { return Options::s_constMetaData[m_id].name; }
+        const char* description() const { return Options::s_constMetaData[m_id].description; }
+        Options::Type type() const { return Options::s_constMetaData[m_id].type; }
+        Options::Availability availability() const { return Options::s_constMetaData[m_id].availability; }
+        bool isOverridden() const { return *this != OptionReader::defaultFor(m_id); }
+
+    private:
+        Option(Options::ID id, void* addressOfValue)
+            : m_id(id)
+        {
+            initValue(addressOfValue);
+        }
+
+        void initValue(void* addressOfValue);
+
+        Options::ID m_id;
+        union {
+            bool m_bool;
+            unsigned m_unsigned;
+            double m_double;
+            int32_t m_int32;
+            size_t m_size;
+            OptionRange m_optionRange;
+            const char* m_optionString;
+            GCLogging::Level m_gcLogLevel;
+        };
+
+        friend struct OptionReader;
+    };
+
+    static const Option optionFor(Options::ID);
+    static const Option defaultFor(Options::ID);
+};
+
 void Options::dumpOption(StringBuilder& builder, DumpLevel level, Options::ID id,
     const char* header, const char* footer, DumpDefaultsOption dumpDefaultsOption)
 {
-    if (id >= numberOfOptions)
-        return; // Illegal option.
+    RELEASE_ASSERT(static_cast<size_t>(id) < NumberOfOptions);
 
-    Option option(id);
+    auto option = OptionReader::optionFor(id);
     Availability availability = option.availability();
     if (availability != Availability::Normal && !isAvailable(id, availability))
         return;
 
     bool wasOverridden = option.isOverridden();
@@ -863,12 +928,13 @@
         builder.append(header);
     builder.append(option.name(), '=');
     option.dump(builder);
 
     if (wasOverridden && (dumpDefaultsOption == DumpDefaults)) {
+        auto defaultOption = OptionReader::defaultFor(id);
         builder.appendLiteral(" (default: ");
-        option.defaultOption().dump(builder);
+        defaultOption.dump(builder);
         builder.appendLiteral(")");
     }
 
     if (needsDescription)
         builder.append("   ... ", option.description());
@@ -885,68 +951,109 @@
     }
     if (!coherent)
         CRASH();
 }
 
-void Option::dump(StringBuilder& builder) const
+const OptionReader::Option OptionReader::optionFor(Options::ID id)
+{
+    return Option(id, Options::addressOfOption(id));
+}
+
+const OptionReader::Option OptionReader::defaultFor(Options::ID id)
+{
+    return Option(id, Options::addressOfOptionDefault(id));
+}
+
+void OptionReader::Option::initValue(void* addressOfValue)
+{
+    Options::Type type = Options::s_constMetaData[m_id].type;
+    switch (type) {
+    case Options::Type::Bool:
+        memcpy(&m_bool, addressOfValue, sizeof(OptionsStorage::Bool));
+        break;
+    case Options::Type::Unsigned:
+        memcpy(&m_unsigned, addressOfValue, sizeof(OptionsStorage::Unsigned));
+        break;
+    case Options::Type::Double:
+        memcpy(&m_double, addressOfValue, sizeof(OptionsStorage::Double));
+        break;
+    case Options::Type::Int32:
+        memcpy(&m_int32, addressOfValue, sizeof(OptionsStorage::Int32));
+        break;
+    case Options::Type::Size:
+        memcpy(&m_size, addressOfValue, sizeof(OptionsStorage::Size));
+        break;
+    case Options::Type::OptionRange:
+        memcpy(&m_optionRange, addressOfValue, sizeof(OptionsStorage::OptionRange));
+        break;
+    case Options::Type::OptionString:
+        memcpy(&m_optionString, addressOfValue, sizeof(OptionsStorage::OptionString));
+        break;
+    case Options::Type::GCLogLevel:
+        memcpy(&m_gcLogLevel, addressOfValue, sizeof(OptionsStorage::GCLogLevel));
+        break;
+    }
+}
+
+void OptionReader::Option::dump(StringBuilder& builder) const
 {
     switch (type()) {
-    case Options::Type::boolType:
-        builder.append(m_entry.boolVal ? "true" : "false");
+    case Options::Type::Bool:
+        builder.append(m_bool ? "true" : "false");
         break;
-    case Options::Type::unsignedType:
-        builder.appendNumber(m_entry.unsignedVal);
+    case Options::Type::Unsigned:
+        builder.appendNumber(m_unsigned);
         break;
-    case Options::Type::sizeType:
-        builder.appendNumber(m_entry.sizeVal);
+    case Options::Type::Size:
+        builder.appendNumber(m_size);
         break;
-    case Options::Type::doubleType:
-        builder.appendFixedPrecisionNumber(m_entry.doubleVal);
+    case Options::Type::Double:
+        builder.append(m_double);
         break;
-    case Options::Type::int32Type:
-        builder.appendNumber(m_entry.int32Val);
+    case Options::Type::Int32:
+        builder.appendNumber(m_int32);
         break;
-    case Options::Type::optionRangeType:
-        builder.append(m_entry.optionRangeVal.rangeString());
+    case Options::Type::OptionRange:
+        builder.append(m_optionRange.rangeString());
         break;
-    case Options::Type::optionStringType: {
-        const char* option = m_entry.optionStringVal;
+    case Options::Type::OptionString: {
+        const char* option = m_optionString;
         if (!option)
             option = "";
         builder.append('"');
         builder.append(option);
         builder.append('"');
         break;
     }
-    case Options::Type::gcLogLevelType: {
-        builder.append(GCLogging::levelAsString(m_entry.gcLogLevelVal));
+    case Options::Type::GCLogLevel: {
+        builder.append(GCLogging::levelAsString(m_gcLogLevel));
         break;
     }
     }
 }
 
-bool Option::operator==(const Option& other) const
+bool OptionReader::Option::operator==(const Option& other) const
 {
+    ASSERT(type() == other.type());
     switch (type()) {
-    case Options::Type::boolType:
-        return m_entry.boolVal == other.m_entry.boolVal;
-    case Options::Type::unsignedType:
-        return m_entry.unsignedVal == other.m_entry.unsignedVal;
-    case Options::Type::sizeType:
-        return m_entry.sizeVal == other.m_entry.sizeVal;
-    case Options::Type::doubleType:
-        return (m_entry.doubleVal == other.m_entry.doubleVal) || (std::isnan(m_entry.doubleVal) && std::isnan(other.m_entry.doubleVal));
-    case Options::Type::int32Type:
-        return m_entry.int32Val == other.m_entry.int32Val;
-    case Options::Type::optionRangeType:
-        return m_entry.optionRangeVal.rangeString() == other.m_entry.optionRangeVal.rangeString();
-    case Options::Type::optionStringType:
-        return (m_entry.optionStringVal == other.m_entry.optionStringVal)
-            || (m_entry.optionStringVal && other.m_entry.optionStringVal && !strcmp(m_entry.optionStringVal, other.m_entry.optionStringVal));
-    case Options::Type::gcLogLevelType:
-        return m_entry.gcLogLevelVal == other.m_entry.gcLogLevelVal;
+    case Options::Type::Bool:
+        return m_bool == other.m_bool;
+    case Options::Type::Unsigned:
+        return m_unsigned == other.m_unsigned;
+    case Options::Type::Size:
+        return m_size == other.m_size;
+    case Options::Type::Double:
+        return (m_double == other.m_double) || (std::isnan(m_double) && std::isnan(other.m_double));
+    case Options::Type::Int32:
+        return m_int32 == other.m_int32;
+    case Options::Type::OptionRange:
+        return m_optionRange.rangeString() == other.m_optionRange.rangeString();
+    case Options::Type::OptionString:
+        return (m_optionString == other.m_optionString)
+            || (m_optionString && other.m_optionString && !strcmp(m_optionString, other.m_optionString));
+    case Options::Type::GCLogLevel:
+        return m_gcLogLevel == other.m_gcLogLevel;
     }
     return false;
 }
 
 } // namespace JSC
-

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLFunctionWriter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLFunctionWriter.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
 31 #include &quot;NotImplemented.h&quot;
 32 #include &quot;WHLSLAST.h&quot;
 33 #include &quot;WHLSLEntryPointScaffolding.h&quot;
 34 #include &quot;WHLSLInferTypes.h&quot;
 35 #include &quot;WHLSLNativeFunctionWriter.h&quot;
 36 #include &quot;WHLSLProgram.h&quot;
 37 #include &quot;WHLSLTypeNamer.h&quot;
 38 #include &quot;WHLSLVisitor.h&quot;
 39 #include &lt;wtf/HashMap.h&gt;
 40 #include &lt;wtf/HashSet.h&gt;
 41 #include &lt;wtf/SetForScope.h&gt;
 42 #include &lt;wtf/text/StringBuilder.h&gt;
 43 
 44 namespace WebCore {
 45 
 46 namespace WHLSL {
 47 
 48 namespace Metal {
 49 
 50 static void declareFunction(StringBuilder&amp; stringBuilder, AST::FunctionDeclaration&amp; functionDeclaration, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping)
 51 {
 52     if (functionDeclaration.entryPointType())
 53         return;
 54 
 55     auto iterator = functionMapping.find(&amp;functionDeclaration);
 56     ASSERT(iterator != functionMapping.end());
 57     stringBuilder.append(typeNamer.mangledNameForType(functionDeclaration.type()), &#39; &#39;, iterator-&gt;value, &#39;(&#39;);
 58     for (size_t i = 0; i &lt; functionDeclaration.parameters().size(); ++i) {
 59         if (i)
 60             stringBuilder.append(&quot;, &quot;);
 61         stringBuilder.append(typeNamer.mangledNameForType(*functionDeclaration.parameters()[i]-&gt;type()));
 62     }
 63     stringBuilder.append(&quot;);\n&quot;);
 64 }
 65 
<a name="1" id="anc1"></a><span class="line-added"> 66 struct Variable {</span>
<span class="line-added"> 67     MangledVariableName name;</span>
<span class="line-added"> 68     MangledTypeName type;</span>
<span class="line-added"> 69 };</span>
<span class="line-added"> 70 </span>
 71 class FunctionDefinitionWriter : public Visitor {
<a name="2" id="anc2"></a><span class="line-added"> 72     class HoistedVariableCollector : public Visitor {</span>
<span class="line-added"> 73         public:</span>
<span class="line-added"> 74         HoistedVariableCollector(FunctionDefinitionWriter&amp; functionDefinitionWriter)</span>
<span class="line-added"> 75             : functionDefinitionWriter(functionDefinitionWriter)</span>
<span class="line-added"> 76         {</span>
<span class="line-added"> 77         }</span>
<span class="line-added"> 78 </span>
<span class="line-added"> 79         void visit(AST::CallExpression&amp; callExpression) override</span>
<span class="line-added"> 80         {</span>
<span class="line-added"> 81             Vector&lt;Variable&gt; variables;</span>
<span class="line-added"> 82             size_t size = callExpression.arguments().size();</span>
<span class="line-added"> 83             bool isVoid = matches(callExpression.resolvedType(), functionDefinitionWriter.m_intrinsics.voidType());</span>
<span class="line-added"> 84             if (!isVoid)</span>
<span class="line-added"> 85                 ++size;</span>
<span class="line-added"> 86             variables.reserveInitialCapacity(size);</span>
<span class="line-added"> 87 </span>
<span class="line-added"> 88             for (auto&amp; argument : callExpression.arguments()) {</span>
<span class="line-added"> 89                 auto type = functionDefinitionWriter.m_typeNamer.mangledNameForType(argument-&gt;resolvedType());</span>
<span class="line-added"> 90                 auto name = functionDefinitionWriter.generateNextVariableName();</span>
<span class="line-added"> 91                 variables.uncheckedAppend(Variable { name, type });</span>
<span class="line-added"> 92             }</span>
<span class="line-added"> 93 </span>
<span class="line-added"> 94             if (!isVoid)</span>
<span class="line-added"> 95                 variables.uncheckedAppend(Variable { functionDefinitionWriter.generateNextVariableName(), functionDefinitionWriter.m_typeNamer.mangledNameForType(callExpression.resolvedType()) });</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97             toHoist.add(&amp;callExpression, WTFMove(variables));</span>
<span class="line-added"> 98 </span>
<span class="line-added"> 99             Visitor::visit(callExpression);</span>
<span class="line-added">100         }</span>
<span class="line-added">101 </span>
<span class="line-added">102         void visit(AST::ReadModifyWriteExpression&amp; readModifyWrite) override</span>
<span class="line-added">103         {</span>
<span class="line-added">104             Vector&lt;Variable&gt; variables;</span>
<span class="line-added">105             variables.append(Variable { functionDefinitionWriter.generateNextVariableName(), functionDefinitionWriter.m_typeNamer.mangledNameForType(*readModifyWrite.oldValue().type()) });</span>
<span class="line-added">106             variables.append(Variable { functionDefinitionWriter.generateNextVariableName(), functionDefinitionWriter.m_typeNamer.mangledNameForType(*readModifyWrite.newValue().type()) });</span>
<span class="line-added">107 </span>
<span class="line-added">108             toHoist.add(&amp;readModifyWrite, WTFMove(variables));</span>
<span class="line-added">109 </span>
<span class="line-added">110             Visitor::visit(readModifyWrite);</span>
<span class="line-added">111         }</span>
<span class="line-added">112 </span>
<span class="line-added">113         FunctionDefinitionWriter&amp; functionDefinitionWriter;</span>
<span class="line-added">114         HashMap&lt;AST::Expression*, Vector&lt;Variable&gt;&gt; toHoist;</span>
<span class="line-added">115     };</span>
<span class="line-added">116 </span>
117 public:
118     FunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, Layout&amp; layout)
119         : m_stringBuilder(stringBuilder)
120         , m_intrinsics(intrinsics)
121         , m_typeNamer(typeNamer)
122         , m_functionMapping(functionMapping)
123         , m_layout(layout)
124     {
125     }
126 
127     virtual ~FunctionDefinitionWriter() = default;
128 
129     void visit(AST::NativeFunctionDeclaration&amp;) override;
130     void visit(AST::FunctionDefinition&amp;) override;
131 
132 protected:
133     virtual std::unique_ptr&lt;EntryPointScaffolding&gt; createEntryPointScaffolding(AST::FunctionDefinition&amp;) = 0;
134 
135     void visit(AST::FunctionDeclaration&amp;) override;
136     void visit(AST::Statement&amp;) override;
137     void visit(AST::Block&amp;) override;
138     void visit(AST::Break&amp;) override;
139     void visit(AST::Continue&amp;) override;
140     void visit(AST::DoWhileLoop&amp;) override;
141     void visit(AST::EffectfulExpressionStatement&amp;) override;
142     void visit(AST::Fallthrough&amp;) override;
143     void visit(AST::ForLoop&amp;) override;
144     void visit(AST::IfStatement&amp;) override;
145     void visit(AST::Return&amp;) override;
146     void visit(AST::SwitchStatement&amp;) override;
147     void visit(AST::SwitchCase&amp;) override;
148     void visit(AST::VariableDeclarationsStatement&amp;) override;
149     void visit(AST::WhileLoop&amp;) override;
150     void visit(AST::IntegerLiteral&amp;) override;
151     void visit(AST::UnsignedIntegerLiteral&amp;) override;
152     void visit(AST::FloatLiteral&amp;) override;
<a name="3" id="anc3"></a>
153     void visit(AST::BooleanLiteral&amp;) override;
154     void visit(AST::EnumerationMemberLiteral&amp;) override;
155     void visit(AST::Expression&amp;) override;
<a name="4" id="anc4"></a>
156     void visit(AST::GlobalVariableReference&amp;) override;
<a name="5" id="anc5"></a><span class="line-added">157     void visit(AST::DotExpression&amp;) override;</span>
158     void visit(AST::IndexExpression&amp;) override;
<a name="6" id="anc6"></a>
159     void visit(AST::VariableDeclaration&amp;) override;
160     void visit(AST::AssignmentExpression&amp;) override;
161     void visit(AST::CallExpression&amp;) override;
162     void visit(AST::CommaExpression&amp;) override;
163     void visit(AST::DereferenceExpression&amp;) override;
164     void visit(AST::LogicalExpression&amp;) override;
165     void visit(AST::LogicalNotExpression&amp;) override;
166     void visit(AST::MakeArrayReferenceExpression&amp;) override;
167     void visit(AST::MakePointerExpression&amp;) override;
168     void visit(AST::ReadModifyWriteExpression&amp;) override;
169     void visit(AST::TernaryExpression&amp;) override;
170     void visit(AST::VariableReference&amp;) override;
171 
172     enum class LoopConditionLocation {
173         BeforeBody,
174         AfterBody
175     };
176     void emitLoop(LoopConditionLocation, AST::Expression* conditionExpression, AST::Expression* increment, AST::Statement&amp; body);
177 
178     void emitConstantExpressionString(AST::ConstantExpression&amp;);
179 
180     MangledVariableName generateNextVariableName() { return { m_variableCount++ }; }
181 
<a name="7" id="anc7"></a>


























































182     enum class BreakContext {
183         Loop,
184         Switch
185     };
186 
187     Optional&lt;BreakContext&gt; m_currentBreakContext;
188 
189     StringBuilder&amp; m_stringBuilder;
190     Intrinsics&amp; m_intrinsics;
191     TypeNamer&amp; m_typeNamer;
192     HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; m_functionMapping;
193     HashMap&lt;AST::VariableDeclaration*, MangledVariableName&gt; m_variableMapping;
194 
<a name="8" id="anc8"></a>
195     std::unique_ptr&lt;EntryPointScaffolding&gt; m_entryPointScaffolding;
196     Layout&amp; m_layout;
197     unsigned m_variableCount { 0 };
198     Optional&lt;MangledVariableName&gt; m_breakOutOfCurrentLoopEarlyVariable;
199     Indentation&lt;4&gt; m_indent { 0 };
<a name="9" id="anc9"></a><span class="line-added">200     HashMap&lt;AST::Expression*, Vector&lt;Variable&gt;&gt; m_hoistedVariables;</span>
201 };
202 
203 void FunctionDefinitionWriter::visit(AST::NativeFunctionDeclaration&amp;)
204 {
205     // We inline native function calls.
206 }
207 
208 void FunctionDefinitionWriter::visit(AST::FunctionDefinition&amp; functionDefinition)
209 {
<a name="10" id="anc10"></a><span class="line-added">210 </span>
<span class="line-added">211     {</span>
<span class="line-added">212         HoistedVariableCollector collector(*this);</span>
<span class="line-added">213         collector.Visitor::visit(functionDefinition);</span>
<span class="line-added">214         m_hoistedVariables = WTFMove(collector.toHoist);</span>
<span class="line-added">215     }</span>
<span class="line-added">216 </span>
<span class="line-added">217     auto defineHoistedVariables = [&amp;] {</span>
<span class="line-added">218         for (const auto&amp; vector : m_hoistedVariables.values()) {</span>
<span class="line-added">219             for (auto variable : vector)</span>
<span class="line-added">220                 m_stringBuilder.append(m_indent, variable.type, &#39; &#39;, variable.name, &quot;;\n&quot;);</span>
<span class="line-added">221         }</span>
<span class="line-added">222     };</span>
<span class="line-added">223 </span>
224     auto iterator = m_functionMapping.find(&amp;functionDefinition);
225     ASSERT(iterator != m_functionMapping.end());
226     if (functionDefinition.entryPointType()) {
227         auto entryPointScaffolding = createEntryPointScaffolding(functionDefinition);
228         if (!entryPointScaffolding)
229             return;
230         m_entryPointScaffolding = WTFMove(entryPointScaffolding);
231 
232         m_entryPointScaffolding-&gt;emitHelperTypes(m_stringBuilder, m_indent);
233         m_entryPointScaffolding-&gt;emitSignature(m_stringBuilder, iterator-&gt;value, m_indent);
234         m_stringBuilder.append(m_indent, &quot;{\n&quot;);
235         {
236             IndentationScope scope(m_indent);
237 
238             m_entryPointScaffolding-&gt;emitUnpack(m_stringBuilder, m_indent);
239 
240             for (size_t i = 0; i &lt; functionDefinition.parameters().size(); ++i) {
241                 auto addResult = m_variableMapping.add(&amp;functionDefinition.parameters()[i], m_entryPointScaffolding-&gt;parameterVariables()[i]);
242                 ASSERT_UNUSED(addResult, addResult.isNewEntry);
243             }
<a name="11" id="anc11"></a><span class="line-added">244 </span>
<span class="line-added">245             defineHoistedVariables();</span>
<span class="line-added">246 </span>
247             checkErrorAndVisit(functionDefinition.block());
<a name="12" id="anc12"></a>
248         }
249         m_stringBuilder.append(&quot;}\n\n&quot;);
250 
251         m_entryPointScaffolding = nullptr;
252     } else {
253         ASSERT(m_entryPointScaffolding == nullptr);
254         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(functionDefinition.type()), &#39; &#39;, iterator-&gt;value, &#39;(&#39;);
255         for (size_t i = 0; i &lt; functionDefinition.parameters().size(); ++i) {
<a name="13" id="anc13"></a>
256             if (i)
257                 m_stringBuilder.append(&quot;, &quot;);
<a name="14" id="anc14"></a><span class="line-added">258             auto&amp; parameter = functionDefinition.parameters()[i];</span>
259             auto parameterName = generateNextVariableName();
260             auto addResult = m_variableMapping.add(&amp;parameter, parameterName);
261             ASSERT_UNUSED(addResult, addResult.isNewEntry);
262             m_stringBuilder.append(m_typeNamer.mangledNameForType(*parameter-&gt;type()), &#39; &#39;, parameterName);
263         }
264         m_stringBuilder.append(&quot;)\n&quot;);
<a name="15" id="anc15"></a><span class="line-added">265 </span>
<span class="line-added">266         m_stringBuilder.append(&quot;{\n&quot;);</span>
<span class="line-added">267 </span>
<span class="line-added">268         defineHoistedVariables();</span>
<span class="line-added">269 </span>
270         checkErrorAndVisit(functionDefinition.block());
<a name="16" id="anc16"></a><span class="line-modified">271         m_stringBuilder.append(&quot;}\n&quot;);</span>
272         m_stringBuilder.append(&#39;\n&#39;);
273     }
274 }
275 
276 void FunctionDefinitionWriter::visit(AST::FunctionDeclaration&amp;)
277 {
278     ASSERT_NOT_REACHED();
279 }
280 
281 void FunctionDefinitionWriter::visit(AST::Statement&amp; statement)
282 {
283     Visitor::visit(statement);
284 }
285 
286 void FunctionDefinitionWriter::visit(AST::Block&amp; block)
287 {
288     m_stringBuilder.append(m_indent, &quot;{\n&quot;);
289     {
290         IndentationScope scope(m_indent);
291         for (auto&amp; statement : block.statements())
292             checkErrorAndVisit(statement);
293     }
294     m_stringBuilder.append(m_indent, &quot;}\n&quot;);
295 }
296 
297 void FunctionDefinitionWriter::visit(AST::Break&amp;)
298 {
299     ASSERT(m_currentBreakContext);
300     switch (*m_currentBreakContext) {
301     case BreakContext::Switch:
302         m_stringBuilder.append(m_indent, &quot;break;\n&quot;);
303         break;
304     case BreakContext::Loop:
305         ASSERT(m_breakOutOfCurrentLoopEarlyVariable);
306         m_stringBuilder.append(
307             m_indent, *m_breakOutOfCurrentLoopEarlyVariable, &quot; = true;\n&quot;,
308             m_indent, &quot;break;\n&quot;
309         );
310         break;
311     }
312 }
313 
314 void FunctionDefinitionWriter::visit(AST::Continue&amp;)
315 {
316     ASSERT(m_breakOutOfCurrentLoopEarlyVariable);
317     m_stringBuilder.append(m_indent, &quot;break;\n&quot;);
318 }
319 
320 void FunctionDefinitionWriter::visit(AST::EffectfulExpressionStatement&amp; effectfulExpressionStatement)
321 {
<a name="17" id="anc17"></a><span class="line-added">322     m_stringBuilder.append(m_indent);</span>
323     checkErrorAndVisit(effectfulExpressionStatement.effectfulExpression());
<a name="18" id="anc18"></a><span class="line-modified">324     m_stringBuilder.append(&quot;;\n&quot;);</span>
325 }
326 
327 void FunctionDefinitionWriter::visit(AST::Fallthrough&amp;)
328 {
329     m_stringBuilder.append(m_indent, &quot;[[clang::fallthrough]];\n&quot;); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195808 Make sure this is okay. Alternatively, we could do nothing and just return here instead.
330 }
331 
332 void FunctionDefinitionWriter::emitLoop(LoopConditionLocation loopConditionLocation, AST::Expression* conditionExpression, AST::Expression* increment, AST::Statement&amp; body)
333 {
334     SetForScope&lt;Optional&lt;MangledVariableName&gt;&gt; loopVariableScope(m_breakOutOfCurrentLoopEarlyVariable, generateNextVariableName());
335 
336     m_stringBuilder.append(
337         m_indent, &quot;bool &quot;, *m_breakOutOfCurrentLoopEarlyVariable, &quot; = false;\n&quot;,
338         m_indent, &quot;while (true) {\n&quot;
339     );
340     {
341         IndentationScope whileScope(m_indent);
342 
343         if (loopConditionLocation == LoopConditionLocation::BeforeBody &amp;&amp; conditionExpression) {
<a name="19" id="anc19"></a><span class="line-added">344             m_stringBuilder.append(</span>
<span class="line-added">345                 m_indent, &quot;if (!(&quot;);</span>
346             checkErrorAndVisit(*conditionExpression);
347             m_stringBuilder.append(
<a name="20" id="anc20"></a><span class="line-modified">348                 &quot;))\n&quot;,</span>
<span class="line-modified">349                 &quot;    break;\n&quot;);</span>
350         }
351 
352         m_stringBuilder.append(m_indent, &quot;do {\n&quot;);
353         SetForScope&lt;Optional&lt;BreakContext&gt;&gt; breakContext(m_currentBreakContext, BreakContext::Loop);
354 
355         {
356             IndentationScope doScope(m_indent);
357             checkErrorAndVisit(body);
358         }
359         m_stringBuilder.append(m_indent, &quot;} while(false); \n&quot;);
360 
361         m_stringBuilder.append(
362             m_indent, &quot;if (&quot;, *m_breakOutOfCurrentLoopEarlyVariable, &quot;)\n&quot;,
363             m_indent, &quot;    break;\n&quot;);
364 
365         if (increment) {
<a name="21" id="anc21"></a><span class="line-added">366             m_stringBuilder.append(&quot;(&quot;);</span>
367             checkErrorAndVisit(*increment);
<a name="22" id="anc22"></a><span class="line-modified">368             m_stringBuilder.append(&quot;);\n&quot;);</span>


369         }
370 
371         if (loopConditionLocation == LoopConditionLocation::AfterBody &amp;&amp; conditionExpression) {
<a name="23" id="anc23"></a><span class="line-added">372             m_stringBuilder.append(</span>
<span class="line-added">373                 m_indent, &quot;if (!(&quot;);</span>
374             checkErrorAndVisit(*conditionExpression);
375             m_stringBuilder.append(
<a name="24" id="anc24"></a><span class="line-modified">376                 &quot;))\n&quot;,</span>
<span class="line-modified">377                 &quot;    break;\n&quot;);</span>
378         }
379     }
380 
381     m_stringBuilder.append(m_indent, &quot;} \n&quot;);
382 }
383 
384 void FunctionDefinitionWriter::visit(AST::DoWhileLoop&amp; doWhileLoop)
385 {
386     emitLoop(LoopConditionLocation::AfterBody, &amp;doWhileLoop.conditional(), nullptr, doWhileLoop.body());
387 }
388 
389 void FunctionDefinitionWriter::visit(AST::WhileLoop&amp; whileLoop)
390 {
391     emitLoop(LoopConditionLocation::BeforeBody, &amp;whileLoop.conditional(), nullptr, whileLoop.body());
392 }
393 
394 void FunctionDefinitionWriter::visit(AST::ForLoop&amp; forLoop)
395 {
396     m_stringBuilder.append(m_indent, &quot;{\n&quot;);
397     {
398         IndentationScope scope(m_indent);
399         checkErrorAndVisit(forLoop.initialization());
400         emitLoop(LoopConditionLocation::BeforeBody, forLoop.condition(), forLoop.increment(), forLoop.body());
401     }
402     m_stringBuilder.append(m_indent, &quot;}\n&quot;);
403 }
404 
405 void FunctionDefinitionWriter::visit(AST::IfStatement&amp; ifStatement)
406 {
<a name="25" id="anc25"></a><span class="line-added">407     m_stringBuilder.append(m_indent, &quot;if (&quot;);</span>
408     checkErrorAndVisit(ifStatement.conditional());
<a name="26" id="anc26"></a><span class="line-modified">409     m_stringBuilder.append(&quot;) {\n&quot;);</span>
<span class="line-added">410 </span>
411     {
412         IndentationScope ifScope(m_indent);
413         checkErrorAndVisit(ifStatement.body());
414     }
<a name="27" id="anc27"></a><span class="line-added">415 </span>
416     if (ifStatement.elseBody()) {
417         m_stringBuilder.append(m_indent, &quot;} else {\n&quot;);
418         {
419             IndentationScope elseScope(m_indent);
420             checkErrorAndVisit(*ifStatement.elseBody());
421         }
422     }
<a name="28" id="anc28"></a><span class="line-added">423 </span>
424     m_stringBuilder.append(m_indent, &quot;}\n&quot;);
425 }
426 
427 void FunctionDefinitionWriter::visit(AST::Return&amp; returnStatement)
428 {
429     if (returnStatement.value()) {
<a name="29" id="anc29"></a><span class="line-added">430         auto tempReturnName = generateNextVariableName();</span>
<span class="line-added">431         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(returnStatement.value()-&gt;resolvedType()), &#39; &#39;, tempReturnName, &quot; = &quot;);</span>
432         checkErrorAndVisit(*returnStatement.value());
<a name="30" id="anc30"></a><span class="line-added">433         m_stringBuilder.append(&quot;;\n&quot;);</span>
434 
435         if (m_entryPointScaffolding) {
436             auto variableName = generateNextVariableName();
<a name="31" id="anc31"></a><span class="line-modified">437             m_entryPointScaffolding-&gt;emitPack(m_stringBuilder, tempReturnName, variableName, m_indent);</span>
438             m_stringBuilder.append(m_indent, &quot;return &quot;, variableName, &quot;;\n&quot;);
439         } else
<a name="32" id="anc32"></a><span class="line-modified">440             m_stringBuilder.append(m_indent, &quot;return &quot;, tempReturnName, &quot;;\n&quot;);</span>
441     } else
442         m_stringBuilder.append(m_indent, &quot;return;\n&quot;);
443 }
444 
445 void FunctionDefinitionWriter::visit(AST::SwitchStatement&amp; switchStatement)
446 {
<a name="33" id="anc33"></a><span class="line-added">447     m_stringBuilder.append(m_indent, &quot;switch (&quot;);</span>
448     checkErrorAndVisit(switchStatement.value());
<a name="34" id="anc34"></a><span class="line-added">449     m_stringBuilder.append(&quot;) {&quot;);</span>
450 
<a name="35" id="anc35"></a>
451     {
452         IndentationScope switchScope(m_indent);
453         for (auto&amp; switchCase : switchStatement.switchCases())
454             checkErrorAndVisit(switchCase);
455     }
456     m_stringBuilder.append(m_indent, &quot;}\n&quot;);
457 }
458 
459 void FunctionDefinitionWriter::visit(AST::SwitchCase&amp; switchCase)
460 {
461     if (switchCase.value()) {
462         m_stringBuilder.append(m_indent, &quot;case &quot;);
463         emitConstantExpressionString(*switchCase.value());
464         m_stringBuilder.append(&quot;:\n&quot;);
465     } else
466         m_stringBuilder.append(m_indent, &quot;default:\n&quot;);
467     SetForScope&lt;Optional&lt;BreakContext&gt;&gt; breakContext(m_currentBreakContext, BreakContext::Switch);
468     checkErrorAndVisit(switchCase.block());
469     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195812 Figure out whether we need to break or fallthrough.
470 }
471 
472 void FunctionDefinitionWriter::visit(AST::VariableDeclarationsStatement&amp; variableDeclarationsStatement)
473 {
474     Visitor::visit(variableDeclarationsStatement);
475 }
476 
477 void FunctionDefinitionWriter::visit(AST::IntegerLiteral&amp; integerLiteral)
478 {
<a name="36" id="anc36"></a>
479     auto mangledTypeName = m_typeNamer.mangledNameForType(integerLiteral.resolvedType());
<a name="37" id="anc37"></a><span class="line-modified">480     m_stringBuilder.append(&quot;static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, integerLiteral.value(), &quot;)&quot;);</span>

481 }
482 
483 void FunctionDefinitionWriter::visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral)
484 {
<a name="38" id="anc38"></a>
485     auto mangledTypeName = m_typeNamer.mangledNameForType(unsignedIntegerLiteral.resolvedType());
<a name="39" id="anc39"></a><span class="line-modified">486     m_stringBuilder.append(&quot;static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, unsignedIntegerLiteral.value(), &quot;)&quot;);</span>

487 }
488 
489 void FunctionDefinitionWriter::visit(AST::FloatLiteral&amp; floatLiteral)
490 {
<a name="40" id="anc40"></a>
491     auto mangledTypeName = m_typeNamer.mangledNameForType(floatLiteral.resolvedType());
<a name="41" id="anc41"></a><span class="line-modified">492     m_stringBuilder.append(&quot;static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, floatLiteral.value(), &quot;)&quot;);</span>
















493 }
494 
495 void FunctionDefinitionWriter::visit(AST::BooleanLiteral&amp; booleanLiteral)
496 {
<a name="42" id="anc42"></a>
497     auto mangledTypeName = m_typeNamer.mangledNameForType(booleanLiteral.resolvedType());
<a name="43" id="anc43"></a><span class="line-modified">498     m_stringBuilder.append(&quot;static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, booleanLiteral.value() ? &quot;true&quot; : &quot;false&quot;, &quot;)&quot;);</span>

499 }
500 
501 void FunctionDefinitionWriter::visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral)
502 {
503     ASSERT(enumerationMemberLiteral.enumerationDefinition());
504     ASSERT(enumerationMemberLiteral.enumerationDefinition());
<a name="44" id="anc44"></a>
505     auto mangledTypeName = m_typeNamer.mangledNameForType(enumerationMemberLiteral.resolvedType());
<a name="45" id="anc45"></a><span class="line-modified">506     m_stringBuilder.append(mangledTypeName, &quot;::&quot;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()));</span>

507 }
508 
509 void FunctionDefinitionWriter::visit(AST::Expression&amp; expression)
510 {
511     Visitor::visit(expression);
512 }
513 
<a name="46" id="anc46"></a>







514 void FunctionDefinitionWriter::visit(AST::GlobalVariableReference&amp; globalVariableReference)
515 {
<a name="47" id="anc47"></a><span class="line-modified">516     MangledStructureElementName mangledFieldName = m_typeNamer.mangledNameForStructureElement(globalVariableReference.structField());</span>
<span class="line-modified">517     m_stringBuilder.append(&#39;(&#39;);</span>

518     checkErrorAndVisit(globalVariableReference.base());
<a name="48" id="anc48"></a><span class="line-modified">519     m_stringBuilder.append(&quot;)-&gt;&quot;, mangledFieldName);</span>
<span class="line-added">520 }</span>
521 
<a name="49" id="anc49"></a><span class="line-modified">522 void FunctionDefinitionWriter::visit(AST::DotExpression&amp; dotExpression)</span>
<span class="line-added">523 {</span>
<span class="line-added">524     auto&amp; type = dotExpression.base().resolvedType().unifyNode();</span>
525 
<a name="50" id="anc50"></a><span class="line-modified">526     if (is&lt;AST::StructureDefinition&gt;(type)) {</span>
<span class="line-modified">527         auto&amp; structureDefinition = downcast&lt;AST::StructureDefinition&gt;(type);</span>
<span class="line-added">528         auto* structureElement = structureDefinition.find(dotExpression.fieldName());</span>
<span class="line-added">529         ASSERT(structureElement);</span>
<span class="line-added">530         auto elementName = m_typeNamer.mangledNameForStructureElement(*structureElement);</span>
531 
<a name="51" id="anc51"></a><span class="line-modified">532         m_stringBuilder.append(&#39;(&#39;);</span>
<span class="line-modified">533         checkErrorAndVisit(dotExpression.base());</span>
<span class="line-modified">534         m_stringBuilder.append(&quot;).&quot;, elementName);</span>
<span class="line-modified">535     } else {</span>
<span class="line-modified">536         String elementName = dotExpression.fieldName();</span>
<span class="line-modified">537         if (elementName == &quot;length&quot; &amp;&amp; (is&lt;AST::ArrayReferenceType&gt;(type) || is&lt;AST::ArrayType&gt;(type) || (is&lt;AST::NativeTypeDeclaration&gt;(type) &amp;&amp; downcast&lt;AST::NativeTypeDeclaration&gt;(type).isVector()))) {</span>
<span class="line-modified">538             if (is&lt;AST::ArrayReferenceType&gt;(type)) {</span>
<span class="line-added">539                 m_stringBuilder.append(&#39;(&#39;);</span>
<span class="line-added">540                 checkErrorAndVisit(dotExpression.base());</span>
<span class="line-added">541                 m_stringBuilder.append(&quot;).length&quot;);</span>
<span class="line-added">542             } else if (is&lt;AST::ArrayType&gt;(type)) {</span>
<span class="line-added">543                 m_stringBuilder.append(&#39;(&#39;);</span>
<span class="line-added">544                 checkErrorAndVisit(dotExpression.base());</span>
<span class="line-added">545                 m_stringBuilder.append(&quot;, &quot;, downcast&lt;AST::ArrayType&gt;(type).numElements(), &quot;)&quot;);</span>
<span class="line-added">546             } else {</span>
<span class="line-added">547                 m_stringBuilder.append(&#39;(&#39;);</span>
<span class="line-added">548                 checkErrorAndVisit(dotExpression.base());</span>
<span class="line-added">549                 m_stringBuilder.append(&quot;, &quot;, downcast&lt;AST::NativeTypeDeclaration&gt;(type).vectorSize(), &quot;)&quot;);</span>
<span class="line-added">550             }</span>
<span class="line-added">551         } else {</span>
<span class="line-added">552             m_stringBuilder.append(&#39;(&#39;);</span>
<span class="line-added">553             checkErrorAndVisit(dotExpression.base());</span>
<span class="line-added">554             m_stringBuilder.append(&quot;).&quot;, elementName);</span>
<span class="line-added">555         }</span>
<span class="line-added">556     }</span>
557 }
558 
559 void FunctionDefinitionWriter::visit(AST::IndexExpression&amp; indexExpression)
560 {
<a name="52" id="anc52"></a><span class="line-modified">561     auto&amp; type = indexExpression.base().resolvedType().unifyNode();</span>
<span class="line-modified">562     if (is&lt;AST::ArrayReferenceType&gt;(type)) {</span>
<span class="line-modified">563         m_stringBuilder.append(&#39;(&#39;);</span>
<span class="line-modified">564         checkErrorAndVisit(indexExpression.base());</span>
<span class="line-modified">565         m_stringBuilder.append(&quot;).pointer[(&quot;);</span>
<span class="line-modified">566         checkErrorAndVisit(indexExpression.indexExpression());</span>
<span class="line-modified">567         m_stringBuilder.append(&quot;) &lt; (&quot;);</span>
<span class="line-modified">568         checkErrorAndVisit(indexExpression.base());</span>
<span class="line-modified">569         m_stringBuilder.append(&quot;).length ? &quot;);</span>
<span class="line-modified">570         checkErrorAndVisit(indexExpression.indexExpression());</span>
<span class="line-modified">571         m_stringBuilder.append(&quot; : 0]&quot;);</span>
<span class="line-modified">572     } else if (is&lt;AST::ArrayType&gt;(type)) {</span>
<span class="line-added">573         m_stringBuilder.append(&#39;(&#39;);</span>
<span class="line-added">574         checkErrorAndVisit(indexExpression.base());</span>
<span class="line-added">575         m_stringBuilder.append(&quot;).data()[(&quot;);</span>
<span class="line-added">576         checkErrorAndVisit(indexExpression.indexExpression());</span>
<span class="line-added">577         m_stringBuilder.append(&quot;) &lt; &quot;, downcast&lt;AST::ArrayType&gt;(type).numElements(), &quot; ? &quot;);</span>
<span class="line-added">578         checkErrorAndVisit(indexExpression.indexExpression());</span>
<span class="line-added">579         m_stringBuilder.append(&quot; : 0]&quot;);</span>
<span class="line-added">580     } else if (is&lt;AST::NativeTypeDeclaration&gt;(type)) {</span>
<span class="line-added">581         auto&amp; nativeType = downcast&lt;AST::NativeTypeDeclaration&gt;(type);</span>
<span class="line-added">582         unsigned size;</span>
<span class="line-added">583         if (nativeType.isMatrix())</span>
<span class="line-added">584             size = nativeType.numberOfMatrixColumns();</span>
<span class="line-added">585         else if (nativeType.isVector())</span>
<span class="line-added">586             size = nativeType.vectorSize();</span>
<span class="line-added">587         else</span>
<span class="line-added">588             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">589 </span>
<span class="line-added">590         m_stringBuilder.append(&#39;(&#39;);</span>
<span class="line-added">591         checkErrorAndVisit(indexExpression.base());</span>
<span class="line-added">592         m_stringBuilder.append(&quot;)[(&quot;);</span>
<span class="line-added">593         checkErrorAndVisit(indexExpression.indexExpression());</span>
<span class="line-added">594         m_stringBuilder.append(&quot; &lt; &quot;, size, &quot;) ? (&quot;);</span>
<span class="line-added">595         checkErrorAndVisit(indexExpression.indexExpression());</span>
<span class="line-added">596         m_stringBuilder.append(&quot;) : 0]&quot;);</span>
<span class="line-added">597     } else</span>
<span class="line-added">598         RELEASE_ASSERT_NOT_REACHED();</span>
599 }
600 
601 void FunctionDefinitionWriter::visit(AST::VariableDeclaration&amp; variableDeclaration)
602 {
603     ASSERT(variableDeclaration.type());
604     auto variableName = generateNextVariableName();
605     auto addResult = m_variableMapping.add(&amp;variableDeclaration, variableName);
606     ASSERT_UNUSED(addResult, addResult.isNewEntry);
607     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198160 Implement qualifiers.
608     if (variableDeclaration.initializer()) {
<a name="53" id="anc53"></a><span class="line-added">609         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(*variableDeclaration.type()), &#39; &#39;, variableName, &quot; = &quot;);</span>
610         checkErrorAndVisit(*variableDeclaration.initializer());
<a name="54" id="anc54"></a><span class="line-modified">611         m_stringBuilder.append(&quot;;\n&quot;);</span>
612     } else
613         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(*variableDeclaration.type()), &#39; &#39;, variableName, &quot; = { };\n&quot;);
614 }
615 
616 void FunctionDefinitionWriter::visit(AST::AssignmentExpression&amp; assignmentExpression)
617 {
<a name="55" id="anc55"></a><span class="line-added">618     m_stringBuilder.append(&#39;(&#39;);</span>
619     checkErrorAndVisit(assignmentExpression.left());
<a name="56" id="anc56"></a><span class="line-modified">620     m_stringBuilder.append(&#39;)&#39;);</span>
<span class="line-added">621     m_stringBuilder.append(&quot; = (&quot;);</span>
622     checkErrorAndVisit(assignmentExpression.right());
<a name="57" id="anc57"></a><span class="line-modified">623     m_stringBuilder.append(&#39;)&#39;);</span>








624 }
625 
626 void FunctionDefinitionWriter::visit(AST::CallExpression&amp; callExpression)
627 {
<a name="58" id="anc58"></a><span class="line-added">628     auto iter = m_hoistedVariables.find(&amp;callExpression);</span>
<span class="line-added">629     RELEASE_ASSERT(iter != m_hoistedVariables.end());</span>
<span class="line-added">630     auto&amp; variables = iter-&gt;value;</span>
<span class="line-added">631     RELEASE_ASSERT(callExpression.arguments().size() &lt;= variables.size());</span>
632     Vector&lt;MangledVariableName&gt; argumentNames;
<a name="59" id="anc59"></a>



633 
<a name="60" id="anc60"></a><span class="line-modified">634     MangledVariableName resultName;</span>
<span class="line-modified">635     if (!matches(callExpression.resolvedType(), m_intrinsics.voidType()))</span>
<span class="line-modified">636         resultName = variables.last().name;</span>
<span class="line-modified">637 </span>
<span class="line-modified">638     m_stringBuilder.append(&#39;(&#39;);</span>
<span class="line-added">639     for (size_t i = 0; i &lt; callExpression.arguments().size(); ++i) {</span>
<span class="line-added">640         argumentNames.append(variables[i].name);</span>
<span class="line-added">641         m_stringBuilder.append(variables[i].name, &quot; = (&quot;);</span>
<span class="line-added">642         checkErrorAndVisit(callExpression.arguments()[i]);</span>
<span class="line-added">643         m_stringBuilder.append(&quot;), &quot;);</span>
644     }
645 
646     if (is&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function())) {
<a name="61" id="anc61"></a><span class="line-modified">647         inlineNativeFunction(m_stringBuilder, downcast&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function()), argumentNames, resultName, m_typeNamer);</span>






648     } else {
<a name="62" id="anc62"></a>

649         auto iterator = m_functionMapping.find(&amp;callExpression.function());
650         ASSERT(iterator != m_functionMapping.end());
<a name="63" id="anc63"></a>

651         m_stringBuilder.append(iterator-&gt;value, &#39;(&#39;);
<a name="64" id="anc64"></a><span class="line-modified">652         for (size_t i = 0; i &lt; callExpression.arguments().size(); ++i) {</span>
653             if (i)
654                 m_stringBuilder.append(&quot;, &quot;);
<a name="65" id="anc65"></a><span class="line-modified">655             m_stringBuilder.append(variables[i].name);</span>
656         }
<a name="66" id="anc66"></a><span class="line-modified">657         m_stringBuilder.append(&#39;)&#39;);</span>
658     }
659 
<a name="67" id="anc67"></a><span class="line-modified">660     m_stringBuilder.append(&#39;)&#39;);</span>
661 }
662 
663 void FunctionDefinitionWriter::visit(AST::CommaExpression&amp; commaExpression)
664 {
<a name="68" id="anc68"></a><span class="line-modified">665     m_stringBuilder.append(&#39;(&#39;);</span>
<span class="line-added">666     bool ranOnce = false;</span>
667     for (auto&amp; expression : commaExpression.list()) {
<a name="69" id="anc69"></a><span class="line-added">668         if (ranOnce)</span>
<span class="line-added">669             m_stringBuilder.append(&quot;, &quot;);</span>
<span class="line-added">670         ranOnce = true;</span>
671         checkErrorAndVisit(expression);
<a name="70" id="anc70"></a>
672     }
<a name="71" id="anc71"></a><span class="line-modified">673     m_stringBuilder.append(&#39;)&#39;);</span>

674 }
675 
676 void FunctionDefinitionWriter::visit(AST::DereferenceExpression&amp; dereferenceExpression)
677 {
<a name="72" id="anc72"></a><span class="line-added">678     m_stringBuilder.append(&quot;*(&quot;);</span>
679     checkErrorAndVisit(dereferenceExpression.pointer());
<a name="73" id="anc73"></a><span class="line-modified">680     m_stringBuilder.append(&#39;)&#39;);</span>










681 }
682 
683 void FunctionDefinitionWriter::visit(AST::LogicalExpression&amp; logicalExpression)
684 {
<a name="74" id="anc74"></a><span class="line-added">685     m_stringBuilder.append(&quot;((&quot;);</span>
686     checkErrorAndVisit(logicalExpression.left());
<a name="75" id="anc75"></a><span class="line-modified">687     m_stringBuilder.append(&#39;)&#39;);</span>



688 
<a name="76" id="anc76"></a>

689     switch (logicalExpression.type()) {
690     case AST::LogicalExpression::Type::And:
691         m_stringBuilder.append(&quot; &amp;&amp; &quot;);
692         break;
<a name="77" id="anc77"></a><span class="line-modified">693     case AST::LogicalExpression::Type::Or:</span>

694         m_stringBuilder.append(&quot; || &quot;);
695         break;
696     }
<a name="78" id="anc78"></a><span class="line-modified">697 </span>
<span class="line-modified">698     m_stringBuilder.append(&#39;(&#39;);</span>
<span class="line-added">699     checkErrorAndVisit(logicalExpression.right());</span>
<span class="line-added">700     m_stringBuilder.append(&quot;))&quot;);</span>
701 }
702 
703 void FunctionDefinitionWriter::visit(AST::LogicalNotExpression&amp; logicalNotExpression)
704 {
<a name="79" id="anc79"></a><span class="line-added">705     m_stringBuilder.append(&quot;!(&quot;);</span>
706     checkErrorAndVisit(logicalNotExpression.operand());
<a name="80" id="anc80"></a><span class="line-modified">707     m_stringBuilder.append(&#39;)&#39;);</span>





708 }
709 
710 void FunctionDefinitionWriter::visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression)
711 {
<a name="81" id="anc81"></a>
712     // FIXME: This needs to be made to work. It probably should be using the last leftValue too.
713     // https://bugs.webkit.org/show_bug.cgi?id=198838
<a name="82" id="anc82"></a>

714     auto mangledTypeName = m_typeNamer.mangledNameForType(makeArrayReferenceExpression.resolvedType());
715     if (is&lt;AST::PointerType&gt;(makeArrayReferenceExpression.leftValue().resolvedType())) {
<a name="83" id="anc83"></a><span class="line-modified">716         m_stringBuilder.append(mangledTypeName, &quot;{ &quot;);</span>
<span class="line-modified">717         checkErrorAndVisit(makeArrayReferenceExpression.leftValue());</span>
<span class="line-modified">718         m_stringBuilder.append(&quot;, 1 }&quot;);</span>
719     } else if (is&lt;AST::ArrayType&gt;(makeArrayReferenceExpression.leftValue().resolvedType())) {
<a name="84" id="anc84"></a>
720         auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(makeArrayReferenceExpression.leftValue().resolvedType());
<a name="85" id="anc85"></a><span class="line-modified">721         m_stringBuilder.append(mangledTypeName, &quot; { &quot;);</span>
<span class="line-added">722         checkErrorAndVisit(makeArrayReferenceExpression.leftValue());</span>
<span class="line-added">723         m_stringBuilder.append(&quot;.data(), &quot;, arrayType.numElements(), &quot; }&quot;);</span>
724     } else {
<a name="86" id="anc86"></a><span class="line-modified">725         m_stringBuilder.append(mangledTypeName, &quot; { &amp;&quot;);</span>
<span class="line-modified">726         checkErrorAndVisit(makeArrayReferenceExpression.leftValue());</span>
<span class="line-added">727         m_stringBuilder.append(&quot;, 1 }&quot;);</span>
728     }
<a name="87" id="anc87"></a>
729 }
730 
731 void FunctionDefinitionWriter::visit(AST::MakePointerExpression&amp; makePointerExpression)
732 {
<a name="88" id="anc88"></a><span class="line-added">733     m_stringBuilder.append(&quot;&amp;(&quot;);</span>
734     checkErrorAndVisit(makePointerExpression.leftValue());
<a name="89" id="anc89"></a><span class="line-modified">735     m_stringBuilder.append(&#39;)&#39;);</span>



736 }
737 
<a name="90" id="anc90"></a><span class="line-modified">738 void FunctionDefinitionWriter::visit(AST::ReadModifyWriteExpression&amp; readModifyWrite)</span>
739 {
<a name="91" id="anc91"></a><span class="line-modified">740     /*</span>
<span class="line-modified">741      *  1. Evaluate m_leftValue</span>
<span class="line-added">742      *  2. Assign the result to m_oldValue</span>
<span class="line-added">743      *  3. Evaluate m_newValueExpression</span>
<span class="line-added">744      *  4. Assign the result to m_newValue</span>
<span class="line-added">745      *  5. Assign the result to m_leftValue</span>
<span class="line-added">746      *  6. Evaluate m_resultExpression</span>
<span class="line-added">747      *  7. Return the result</span>
<span class="line-added">748      */</span>
<span class="line-added">749 </span>
<span class="line-added">750     auto iter = m_hoistedVariables.find(&amp;readModifyWrite);</span>
<span class="line-added">751     RELEASE_ASSERT(iter != m_hoistedVariables.end());</span>
<span class="line-added">752     auto&amp; variables = iter-&gt;value;</span>
<span class="line-added">753     RELEASE_ASSERT(variables.size() == 2);</span>
<span class="line-added">754 </span>
<span class="line-added">755     MangledVariableName oldValueVariable = variables[0].name;</span>
<span class="line-added">756     MangledVariableName newValueVariable = variables[1].name;</span>
<span class="line-added">757 </span>
<span class="line-added">758     m_variableMapping.add(&amp;readModifyWrite.oldValue(), oldValueVariable);</span>
<span class="line-added">759     m_variableMapping.add(&amp;readModifyWrite.newValue(), newValueVariable);</span>
<span class="line-added">760 </span>
<span class="line-added">761     m_stringBuilder.append(&#39;(&#39;);</span>
<span class="line-added">762 </span>
<span class="line-added">763     m_stringBuilder.append(oldValueVariable, &quot; = &quot;);</span>
<span class="line-added">764     checkErrorAndVisit(readModifyWrite.leftValue());</span>
<span class="line-added">765 </span>
<span class="line-added">766     m_stringBuilder.append(&quot;, &quot;, newValueVariable, &quot; = &quot;);</span>
<span class="line-added">767     checkErrorAndVisit(readModifyWrite.newValueExpression());</span>
<span class="line-added">768 </span>
<span class="line-added">769     m_stringBuilder.append(&quot;, &quot;);</span>
<span class="line-added">770     checkErrorAndVisit(readModifyWrite.leftValue());</span>
<span class="line-added">771     m_stringBuilder.append(&quot; = &quot;, newValueVariable, &quot;, &quot;);</span>
<span class="line-added">772 </span>
<span class="line-added">773     checkErrorAndVisit(readModifyWrite.resultExpression());</span>
<span class="line-added">774     m_stringBuilder.append(&#39;)&#39;);</span>
775 }
776 
777 void FunctionDefinitionWriter::visit(AST::TernaryExpression&amp; ternaryExpression)
778 {
<a name="92" id="anc92"></a><span class="line-added">779     m_stringBuilder.append(&#39;(&#39;);</span>
780     checkErrorAndVisit(ternaryExpression.predicate());
<a name="93" id="anc93"></a><span class="line-modified">781     m_stringBuilder.append(&quot;) ? (&quot;);</span>
782     checkErrorAndVisit(ternaryExpression.bodyExpression());
<a name="94" id="anc94"></a><span class="line-modified">783     m_stringBuilder.append(&quot;) : (&quot;);</span>
784     checkErrorAndVisit(ternaryExpression.elseExpression());
<a name="95" id="anc95"></a><span class="line-modified">785     m_stringBuilder.append(&#39;)&#39;);</span>




786 }
787 
788 void FunctionDefinitionWriter::visit(AST::VariableReference&amp; variableReference)
789 {
790     ASSERT(variableReference.variable());
791     auto iterator = m_variableMapping.find(variableReference.variable());
792     ASSERT(iterator != m_variableMapping.end());
793 
794     MangledVariableName variableName = iterator-&gt;value;
<a name="96" id="anc96"></a><span class="line-modified">795     m_stringBuilder.append(variableName);</span>






796 }
797 
798 void FunctionDefinitionWriter::emitConstantExpressionString(AST::ConstantExpression&amp; constantExpression)
799 {
800     constantExpression.visit(WTF::makeVisitor(
801         [&amp;](AST::IntegerLiteral&amp; integerLiteral) {
802             m_stringBuilder.append(integerLiteral.value());
803         },
804         [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {
805             m_stringBuilder.append(unsignedIntegerLiteral.value());
806         },
807         [&amp;](AST::FloatLiteral&amp; floatLiteral) {
808             m_stringBuilder.append(floatLiteral.value());
809         },
<a name="97" id="anc97"></a>


810         [&amp;](AST::BooleanLiteral&amp; booleanLiteral) {
811             if (booleanLiteral.value())
812                 m_stringBuilder.append(&quot;true&quot;);
813             else
814                 m_stringBuilder.append(&quot;false&quot;);
815         },
816         [&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {
817             ASSERT(enumerationMemberLiteral.enumerationDefinition());
818             ASSERT(enumerationMemberLiteral.enumerationDefinition());
819             m_stringBuilder.append(m_typeNamer.mangledNameForType(*enumerationMemberLiteral.enumerationDefinition()), &quot;::&quot;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()));
820         }
821     ));
822 }
823 
824 class RenderFunctionDefinitionWriter final : public FunctionDefinitionWriter {
825 public:
826     RenderFunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, MatchedRenderSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)
827         : FunctionDefinitionWriter(stringBuilder, intrinsics, typeNamer, functionMapping, layout)
828         , m_matchedSemantics(WTFMove(matchedSemantics))
829     {
830     }
831 
832 private:
833     std::unique_ptr&lt;EntryPointScaffolding&gt; createEntryPointScaffolding(AST::FunctionDefinition&amp;) override;
834 
835     MatchedRenderSemantics m_matchedSemantics;
836 };
837 
838 std::unique_ptr&lt;EntryPointScaffolding&gt; RenderFunctionDefinitionWriter::createEntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition)
839 {
840     auto generateNextVariableName = [this]() -&gt; MangledVariableName {
841         return this-&gt;generateNextVariableName();
842     };
843     if (&amp;functionDefinition == m_matchedSemantics.vertexShader)
844         return makeUnique&lt;VertexEntryPointScaffolding&gt;(functionDefinition, m_intrinsics, m_typeNamer, m_matchedSemantics.vertexShaderEntryPointItems, m_matchedSemantics.vertexShaderResourceMap, m_layout, WTFMove(generateNextVariableName), m_matchedSemantics.matchedVertexAttributes);
845     if (&amp;functionDefinition == m_matchedSemantics.fragmentShader)
846         return makeUnique&lt;FragmentEntryPointScaffolding&gt;(functionDefinition, m_intrinsics, m_typeNamer, m_matchedSemantics.fragmentShaderEntryPointItems, m_matchedSemantics.fragmentShaderResourceMap, m_layout, WTFMove(generateNextVariableName), m_matchedSemantics.matchedColorAttachments);
847     return nullptr;
848 }
849 
850 class ComputeFunctionDefinitionWriter final : public FunctionDefinitionWriter {
851 public:
852     ComputeFunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, MatchedComputeSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)
853         : FunctionDefinitionWriter(stringBuilder, intrinsics, typeNamer, functionMapping, layout)
854         , m_matchedSemantics(WTFMove(matchedSemantics))
855     {
856     }
857 
858 private:
859     std::unique_ptr&lt;EntryPointScaffolding&gt; createEntryPointScaffolding(AST::FunctionDefinition&amp;) override;
860 
861     MatchedComputeSemantics m_matchedSemantics;
862 };
863 
864 std::unique_ptr&lt;EntryPointScaffolding&gt; ComputeFunctionDefinitionWriter::createEntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition)
865 {
866     auto generateNextVariableName = [this]() -&gt; MangledVariableName {
867         return this-&gt;generateNextVariableName();
868     };
869     if (&amp;functionDefinition == m_matchedSemantics.shader)
870         return makeUnique&lt;ComputeEntryPointScaffolding&gt;(functionDefinition, m_intrinsics, m_typeNamer, m_matchedSemantics.entryPointItems, m_matchedSemantics.resourceMap, m_layout, WTFMove(generateNextVariableName));
871     return nullptr;
872 }
873 
874 static HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt; generateMetalFunctionsMapping(Program&amp; program)
875 {
876     unsigned numFunctions = 0;
877     HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt; functionMapping;
878     for (auto&amp; functionDefinition : program.functionDefinitions()) {
879         auto addResult = functionMapping.add(&amp;functionDefinition, MangledFunctionName { numFunctions++ });
880         ASSERT_UNUSED(addResult, addResult.isNewEntry);
881     }
882 
883     return functionMapping;
884 }
885 
886 static void emitSharedMetalFunctions(StringBuilder&amp; stringBuilder, Program&amp; program, TypeNamer&amp; typeNamer, const HashSet&lt;AST::FunctionDeclaration*&gt;&amp; reachableFunctions, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping)
887 {
888     for (auto&amp; functionDefinition : program.functionDefinitions()) {
889         if (!functionDefinition-&gt;entryPointType() &amp;&amp; reachableFunctions.contains(&amp;functionDefinition))
890             declareFunction(stringBuilder, functionDefinition, typeNamer, functionMapping);
891     }
892 
893     stringBuilder.append(&#39;\n&#39;);
894 }
895 
896 class ReachableFunctionsGatherer final : public Visitor {
897 public:
898     void visit(AST::FunctionDeclaration&amp; functionDeclaration) override
899     {
900         auto result = m_reachableFunctions.add(&amp;functionDeclaration);
901         if (result.isNewEntry)
902             Visitor::visit(functionDeclaration);
903     }
904 
905     void visit(AST::CallExpression&amp; callExpression) override
906     {
907         Visitor::visit(callExpression);
908         if (is&lt;AST::FunctionDefinition&gt;(callExpression.function()))
909             checkErrorAndVisit(downcast&lt;AST::FunctionDefinition&gt;(callExpression.function()));
910         else
911             checkErrorAndVisit(downcast&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function()));
912     }
913 
914     HashSet&lt;AST::FunctionDeclaration*&gt; takeReachableFunctions() { return WTFMove(m_reachableFunctions); }
915 
916 private:
917     HashSet&lt;AST::FunctionDeclaration*&gt; m_reachableFunctions;
918 };
919 
920 RenderMetalFunctionEntryPoints emitMetalFunctions(StringBuilder&amp; stringBuilder, Program&amp; program, TypeNamer&amp; typeNamer, MatchedRenderSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)
921 {
922     auto&amp; vertexShaderEntryPoint = *matchedSemantics.vertexShader;
923     auto* fragmentShaderEntryPoint = matchedSemantics.fragmentShader;
924 
925     ReachableFunctionsGatherer reachableFunctionsGatherer;
926     reachableFunctionsGatherer.Visitor::visit(vertexShaderEntryPoint);
927     if (fragmentShaderEntryPoint)
928         reachableFunctionsGatherer.Visitor::visit(*fragmentShaderEntryPoint);
929     auto reachableFunctions = reachableFunctionsGatherer.takeReachableFunctions();
930 
931     auto functionMapping = generateMetalFunctionsMapping(program);
932 
933     emitSharedMetalFunctions(stringBuilder, program, typeNamer, reachableFunctions, functionMapping);
934 
935     RenderFunctionDefinitionWriter functionDefinitionWriter(stringBuilder, program.intrinsics(), typeNamer, functionMapping, WTFMove(matchedSemantics), layout);
936     for (auto&amp; functionDefinition : program.functionDefinitions()) {
937         if (reachableFunctions.contains(&amp;functionDefinition))
938             functionDefinitionWriter.visit(functionDefinition);
939     }
940 
941     return { functionMapping.get(&amp;vertexShaderEntryPoint), fragmentShaderEntryPoint ? functionMapping.get(fragmentShaderEntryPoint) : MangledFunctionName { 0 } };
942 }
943 
944 ComputeMetalFunctionEntryPoints emitMetalFunctions(StringBuilder&amp; stringBuilder, Program&amp; program, TypeNamer&amp; typeNamer, MatchedComputeSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)
945 {
946     auto&amp; entryPoint = *matchedSemantics.shader;
947 
948     ReachableFunctionsGatherer reachableFunctionsGatherer;
949     reachableFunctionsGatherer.Visitor::visit(entryPoint);
950     auto reachableFunctions = reachableFunctionsGatherer.takeReachableFunctions();
951 
952     auto functionMapping = generateMetalFunctionsMapping(program);
953     emitSharedMetalFunctions(stringBuilder, program, typeNamer, reachableFunctions, functionMapping);
954 
955     ComputeFunctionDefinitionWriter functionDefinitionWriter(stringBuilder, program.intrinsics(), typeNamer, functionMapping, WTFMove(matchedSemantics), layout);
956     for (auto&amp; functionDefinition : program.functionDefinitions()) {
957         if (reachableFunctions.contains(&amp;functionDefinition))
958             functionDefinitionWriter.visit(functionDefinition);
959     }
960 
961     return { functionMapping.get(&amp;entryPoint) };
962 }
963 
964 } // namespace Metal
965 
966 } // namespace WHLSL
967 
968 } // namespace WebCore
969 
970 #endif
<a name="98" id="anc98"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="98" type="hidden" />
</body>
</html>
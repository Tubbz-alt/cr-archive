<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ComplexTextController.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2007, 2008, 2009, 2011 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 15  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 16  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 17  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 18  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 19  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 20  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 21  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 22  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 23  */
 24 
 25 #pragma once
 26 
 27 #include &quot;FloatPoint.h&quot;
 28 #include &quot;GlyphBuffer.h&quot;
 29 #include &lt;wtf/HashSet.h&gt;
 30 #include &lt;wtf/RefCounted.h&gt;
 31 #include &lt;wtf/RetainPtr.h&gt;
 32 #include &lt;wtf/Vector.h&gt;
 33 #include &lt;wtf/text/WTFString.h&gt;
 34 
 35 #if PLATFORM(JAVA)
 36 #include &lt;wtf/java/JavaRef.h&gt;
 37 typedef jint CGGlyph;
 38 #else
 39 typedef unsigned short CGGlyph;
 40 #endif
 41 
 42 typedef const struct __CTRun * CTRunRef;
 43 typedef const struct __CTLine * CTLineRef;
 44 
 45 typedef struct hb_buffer_t hb_buffer_t;
 46 
 47 namespace WebCore {
 48 
 49 class FontCascade;
 50 class Font;
 51 class TextRun;
 52 
 53 enum GlyphIterationStyle { IncludePartialGlyphs, ByWholeGlyphs };
 54 
 55 // See https://trac.webkit.org/wiki/ComplexTextController for more information about ComplexTextController.
 56 class ComplexTextController {
 57     WTF_MAKE_FAST_ALLOCATED;
 58 public:
 59     ComplexTextController(const FontCascade&amp;, const TextRun&amp;, bool mayUseNaturalWritingDirection = false, HashSet&lt;const Font*&gt;* fallbackFonts = 0, bool forTextEmphasis = false);
 60 
 61     class ComplexTextRun;
 62     WEBCORE_EXPORT ComplexTextController(const FontCascade&amp;, const TextRun&amp;, Vector&lt;Ref&lt;ComplexTextRun&gt;&gt;&amp;);
 63 
 64     // Advance and emit glyphs up to the specified character.
 65     WEBCORE_EXPORT void advance(unsigned to, GlyphBuffer* = nullptr, GlyphIterationStyle = IncludePartialGlyphs, HashSet&lt;const Font*&gt;* fallbackFonts = nullptr);
 66 
 67     // Compute the character offset for a given x coordinate.
 68     unsigned offsetForPosition(float x, bool includePartialGlyphs);
 69 
 70     // Returns the width of everything we&#39;ve consumed so far.
 71     float runWidthSoFar() const { return m_runWidthSoFar; }
 72 
<a name="1" id="anc1"></a><span class="line-modified"> 73     float totalWidth() const { return m_totalWidth; }</span>
 74 
 75     float minGlyphBoundingBoxX() const { return m_minGlyphBoundingBoxX; }
 76     float maxGlyphBoundingBoxX() const { return m_maxGlyphBoundingBoxX; }
 77     float minGlyphBoundingBoxY() const { return m_minGlyphBoundingBoxY; }
 78     float maxGlyphBoundingBoxY() const { return m_maxGlyphBoundingBoxY; }
 79 
 80     class ComplexTextRun : public RefCounted&lt;ComplexTextRun&gt; {
 81     public:
 82         static Ref&lt;ComplexTextRun&gt; create(CTRunRef ctRun, const Font&amp; font, const UChar* characters, unsigned stringLocation, unsigned stringLength, unsigned indexBegin, unsigned indexEnd)
 83         {
 84             return adoptRef(*new ComplexTextRun(ctRun, font, characters, stringLocation, stringLength, indexBegin, indexEnd));
 85         }
 86 
 87         static Ref&lt;ComplexTextRun&gt; create(hb_buffer_t* buffer, const Font&amp; font, const UChar* characters, unsigned stringLocation, unsigned stringLength, unsigned indexBegin, unsigned indexEnd)
 88         {
 89             return adoptRef(*new ComplexTextRun(buffer, font, characters, stringLocation, stringLength, indexBegin, indexEnd));
 90         }
 91 
 92 #if PLATFORM(JAVA)
 93         static Ref&lt;ComplexTextRun&gt; create(JLObject jRun, const Font&amp; font, const UChar* characters, unsigned stringLocation, unsigned stringLength)
 94         {
 95             return adoptRef(*new ComplexTextRun(jRun, font, characters, stringLocation, stringLength));
 96         }
 97 #endif
 98 
 99         static Ref&lt;ComplexTextRun&gt; create(const Font&amp; font, const UChar* characters, unsigned stringLocation, unsigned stringLength, unsigned indexBegin, unsigned indexEnd, bool ltr)
100         {
101             return adoptRef(*new ComplexTextRun(font, characters, stringLocation, stringLength, indexBegin, indexEnd, ltr));
102         }
103 
104         static Ref&lt;ComplexTextRun&gt; create(const Vector&lt;FloatSize&gt;&amp; advances, const Vector&lt;FloatPoint&gt;&amp; origins, const Vector&lt;Glyph&gt;&amp; glyphs, const Vector&lt;unsigned&gt;&amp; stringIndices, FloatSize initialAdvance, const Font&amp; font, const UChar* characters, unsigned stringLocation, unsigned stringLength, unsigned indexBegin, unsigned indexEnd, bool ltr)
105         {
106             return adoptRef(*new ComplexTextRun(advances, origins, glyphs, stringIndices, initialAdvance, font, characters, stringLocation, stringLength, indexBegin, indexEnd, ltr));
107         }
108 
109         unsigned glyphCount() const { return m_glyphCount; }
110         const Font&amp; font() const { return m_font; }
111         const UChar* characters() const { return m_characters; }
112         unsigned stringLocation() const { return m_stringLocation; }
113         unsigned stringLength() const { return m_stringLength; }
114         ALWAYS_INLINE unsigned indexAt(unsigned) const;
115         unsigned indexBegin() const { return m_indexBegin; }
116         unsigned indexEnd() const { return m_indexEnd; }
117         unsigned endOffsetAt(unsigned i) const { ASSERT(!m_isMonotonic); return m_glyphEndOffsets[i]; }
118         const CGGlyph* glyphs() const { return m_glyphs.data(); }
119 
120         /*
121          * This is the format of the information CoreText gives us about each run:
122          *
123          *                                        -----&gt;X (Paint glyph position)   X (Paint glyph position)   X (Paint glyph position)
124          *                                       /     7                          7                          7
125          *                                      /     /                          /                          /
126          *                   (Initial advance) /     / (Glyph origin)           / (Glyph origin)           / (Glyph origin)
127          *                  -------------------     /                          /                          /
128          *                 /                       /                          /                          /
129          *                X                       X--------------------------X--------------------------X--------------------------X
130          * (text position ^)                             (base advance)             (base advance)             (base advance)
131          *
132          *
133          *
134          *
135          *
136          * And here is the output we transform this into (for each run):
137          *
138          *                                        -----&gt;X-------------------------&gt;X-------------------------&gt;X
139          *                                       /            (Paint advance)            (Paint advance)       \
140          *                                      /                                                               \
141          *                   (Initial advance) /                                                                 \ (Paint advance)
142          *                  -------------------                                                                   ----------------
143          *                 /                                                                                                      \
144          *                X--------------------------------------------------X--------------------------X--------------------------X
145          * (text position ^)                (layout advance)                       (layout advance)           (layout advance)
146          */
147         void growInitialAdvanceHorizontally(float delta) { m_initialAdvance.expand(delta, 0); }
148         FloatSize initialAdvance() const { return m_initialAdvance; }
149         const FloatSize* baseAdvances() const { return m_baseAdvances.data(); }
150         const FloatPoint* glyphOrigins() const { return m_glyphOrigins.size() == glyphCount() ? m_glyphOrigins.data() : nullptr; }
151         bool isLTR() const { return m_isLTR; }
152         bool isMonotonic() const { return m_isMonotonic; }
153         void setIsNonMonotonic();
154 
155     private:
156         ComplexTextRun(CTRunRef, const Font&amp;, const UChar* characters, unsigned stringLocation, unsigned stringLength, unsigned indexBegin, unsigned indexEnd);
157         ComplexTextRun(hb_buffer_t*, const Font&amp;, const UChar* characters, unsigned stringLocation, unsigned stringLength, unsigned indexBegin, unsigned indexEnd);
158 #if PLATFORM(JAVA)
159         ComplexTextRun(JLObject, const Font&amp;, const UChar* characters, unsigned stringLocation, unsigned stringLength);
160 #endif
161         ComplexTextRun(const Font&amp;, const UChar* characters, unsigned stringLocation, unsigned stringLength, unsigned indexBegin, unsigned indexEnd, bool ltr);
162         WEBCORE_EXPORT ComplexTextRun(const Vector&lt;FloatSize&gt;&amp; advances, const Vector&lt;FloatPoint&gt;&amp; origins, const Vector&lt;Glyph&gt;&amp; glyphs, const Vector&lt;unsigned&gt;&amp; stringIndices, FloatSize initialAdvance, const Font&amp;, const UChar* characters, unsigned stringLocation, unsigned stringLength, unsigned indexBegin, unsigned indexEnd, bool ltr);
163 
164         Vector&lt;FloatSize, 64&gt; m_baseAdvances;
165         Vector&lt;FloatPoint, 64&gt; m_glyphOrigins;
166         Vector&lt;CGGlyph, 64&gt; m_glyphs;
167         Vector&lt;unsigned, 64&gt; m_glyphEndOffsets;
168         Vector&lt;unsigned, 64&gt; m_coreTextIndices;
169         FloatSize m_initialAdvance;
170         const Font&amp; m_font;
171         const UChar* m_characters;
172         unsigned m_stringLength;
173         unsigned m_indexBegin;
174         unsigned m_indexEnd;
175         unsigned m_glyphCount;
176         unsigned m_stringLocation;
177         bool m_isLTR;
178         bool m_isMonotonic { true };
179     };
180 private:
181     void computeExpansionOpportunity();
182     void finishConstruction();
183 
184     static unsigned stringBegin(const ComplexTextRun&amp; run) { return run.stringLocation() + run.indexBegin(); }
185     static unsigned stringEnd(const ComplexTextRun&amp; run) { return run.stringLocation() + run.indexEnd(); }
186 
187     void collectComplexTextRuns();
188 
189     void collectComplexTextRunsForCharacters(const UChar*, unsigned length, unsigned stringLocation, const Font*);
190     void adjustGlyphsAndAdvances();
191 
192     unsigned indexOfCurrentRun(unsigned&amp; leftmostGlyph);
193     unsigned incrementCurrentRun(unsigned&amp; leftmostGlyph);
194 
195     float runWidthSoFarFraction(unsigned glyphStartOffset, unsigned glyphEndOffset, unsigned oldCharacterInCurrentGlyph, GlyphIterationStyle) const;
196 
197     FloatPoint glyphOrigin(unsigned index) const { return index &lt; m_glyphOrigins.size() ? m_glyphOrigins[index] : FloatPoint(); }
198 
199     Vector&lt;FloatSize, 256&gt; m_adjustedBaseAdvances;
200     Vector&lt;FloatPoint, 256&gt; m_glyphOrigins;
201     Vector&lt;CGGlyph, 256&gt; m_adjustedGlyphs;
202 
203     Vector&lt;UChar, 256&gt; m_smallCapsBuffer;
204 
205     // There is a 3-level hierarchy here. At the top, we are interested in m_run.string(). We partition that string
206     // into Lines, each of which is a sequence of characters which should use the same Font. Core Text then partitions
207     // the Line into ComplexTextRuns.
208     // ComplexTextRun::stringLocation() and ComplexTextRun::stringLength() refer to the offset and length of the Line
209     // relative to m_run.string(). ComplexTextRun::indexAt() returns to the offset of a codepoint relative to
210     // its Line. ComplexTextRun::glyphs() and ComplexTextRun::advances() refer to glyphs relative to the ComplexTextRun.
211     // The length of the entire TextRun is m_run.length()
212     Vector&lt;RefPtr&lt;ComplexTextRun&gt;, 16&gt; m_complexTextRuns;
213 
214     // The initial capacity of these vectors was selected as being the smallest power of two greater than
215     // the average (3.5) plus one standard deviation (7.5) of nonzero sizes used on Arabic Wikipedia.
216     Vector&lt;unsigned, 16&gt; m_runIndices;
217     Vector&lt;unsigned, 16&gt; m_glyphCountFromStartToIndex;
218 
219 #if PLATFORM(COCOA)
220     Vector&lt;RetainPtr&lt;CTLineRef&gt;&gt; m_coreTextLines;
221 #endif
222 
223     Vector&lt;String&gt; m_stringsFor8BitRuns;
224 
225     HashSet&lt;const Font*&gt;* m_fallbackFonts { nullptr };
226 
227     const FontCascade&amp; m_font;
228     const TextRun&amp; m_run;
229 
230     unsigned m_currentCharacter { 0 };
231     unsigned m_end { 0 };
232 
<a name="2" id="anc2"></a><span class="line-modified">233     float m_totalWidth { 0 };</span>
234     float m_runWidthSoFar { 0 };
235     unsigned m_numGlyphsSoFar { 0 };
236     unsigned m_currentRun { 0 };
237     unsigned m_glyphInCurrentRun { 0 };
238     unsigned m_characterInCurrentGlyph { 0 };
239     float m_expansion { 0 };
240     float m_expansionPerOpportunity { 0 };
241 
242     float m_minGlyphBoundingBoxX { std::numeric_limits&lt;float&gt;::max() };
243     float m_maxGlyphBoundingBoxX { std::numeric_limits&lt;float&gt;::min() };
244     float m_minGlyphBoundingBoxY { std::numeric_limits&lt;float&gt;::max() };
245     float m_maxGlyphBoundingBoxY { std::numeric_limits&lt;float&gt;::min() };
246 
247     bool m_isLTROnly { true };
248     bool m_mayUseNaturalWritingDirection { false };
249     bool m_forTextEmphasis { false };
250 };
251 
252 } // namespace WebCore
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGVariableAccessData.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGVarargsForwardingPhase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGVariableAccessData.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGVariableAccessData.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGVariableAccessData.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 namespace JSC { namespace DFG {
 32 
 33 VariableAccessData::VariableAccessData()
<span class="line-modified"> 34     : m_local(static_cast&lt;VirtualRegister&gt;(std::numeric_limits&lt;int&gt;::min()))</span>
<span class="line-removed"> 35     , m_prediction(SpecNone)</span>
 36     , m_argumentAwarePrediction(SpecNone)
 37     , m_flags(0)
 38     , m_shouldNeverUnbox(false)
 39     , m_structureCheckHoistingFailed(false)
 40     , m_checkArrayHoistingFailed(false)
 41     , m_isProfitableToUnbox(false)
 42     , m_isLoadedFrom(false)
 43     , m_doubleFormatState(EmptyDoubleFormatState)
 44 {
 45     clearVotes();
 46 }
 47 
<span class="line-modified"> 48 VariableAccessData::VariableAccessData(VirtualRegister local)</span>
<span class="line-modified"> 49     : m_local(local)</span>
<span class="line-removed"> 50     , m_prediction(SpecNone)</span>
 51     , m_argumentAwarePrediction(SpecNone)

 52     , m_flags(0)
 53     , m_shouldNeverUnbox(false)
 54     , m_structureCheckHoistingFailed(false)
 55     , m_checkArrayHoistingFailed(false)
 56     , m_isProfitableToUnbox(false)
 57     , m_isLoadedFrom(false)
 58     , m_doubleFormatState(EmptyDoubleFormatState)
 59 {
 60     clearVotes();
 61 }
 62 
 63 bool VariableAccessData::mergeShouldNeverUnbox(bool shouldNeverUnbox)
 64 {
 65     bool newShouldNeverUnbox = m_shouldNeverUnbox | shouldNeverUnbox;
 66     if (newShouldNeverUnbox == m_shouldNeverUnbox)
 67         return false;
 68     m_shouldNeverUnbox = newShouldNeverUnbox;
 69     return true;
 70 }
 71 
 72 bool VariableAccessData::predict(SpeculatedType prediction)
 73 {
 74     VariableAccessData* self = find();
 75     bool result = mergeSpeculation(self-&gt;m_prediction, prediction);
 76     if (result)
 77         mergeSpeculation(m_argumentAwarePrediction, m_prediction);
 78     return result;
 79 }
 80 
 81 bool VariableAccessData::mergeArgumentAwarePrediction(SpeculatedType prediction)
 82 {
 83     return mergeSpeculation(find()-&gt;m_argumentAwarePrediction, prediction);
 84 }
 85 
 86 bool VariableAccessData::shouldUseDoubleFormatAccordingToVote()
 87 {
 88     // We don&#39;t support this facility for arguments, yet.
 89     // FIXME: make this work for arguments.
<span class="line-modified"> 90     if (local().isArgument())</span>
 91         return false;
 92 
 93     // If the variable is not a number prediction, then this doesn&#39;t
 94     // make any sense.
 95     if (!isFullNumberSpeculation(prediction())) {
 96         // FIXME: we may end up forcing a local in inlined argument position to be a double even
 97         // if it is sometimes not even numeric, since this never signals the fact that it doesn&#39;t
 98         // want doubles. https://bugs.webkit.org/show_bug.cgi?id=109511
 99         return false;
100     }
101 
102     // If the variable is predicted to hold only doubles, then it&#39;s a
103     // no-brainer: it should be formatted as a double.
104     if (isDoubleSpeculation(prediction()))
105         return true;
106 
107     // If the variable is known to be used as an integer, then be safe -
108     // don&#39;t force it to be a double.
109     if (flags() &amp; NodeBytecodeUsesAsInt)
110         return false;
111 
112     // If the variable has been voted to become a double, then make it a
113     // double.
114     if (voteRatio() &gt;= Options::doubleVoteRatioForDoubleFormat())
115         return true;
116 
117     return false;
118 }
119 
120 bool VariableAccessData::tallyVotesForShouldUseDoubleFormat()
121 {
122     ASSERT(isRoot());
123 
<span class="line-modified">124     if (local().isArgument() || shouldNeverUnbox()</span>
125         || (flags() &amp; NodeBytecodeUsesAsArrayIndex))
126         return DFG::mergeDoubleFormatState(m_doubleFormatState, NotUsingDoubleFormat);
127 
128     if (m_doubleFormatState == CantUseDoubleFormat)
129         return false;
130 
131     bool newValueOfShouldUseDoubleFormat = shouldUseDoubleFormatAccordingToVote();
132     if (!newValueOfShouldUseDoubleFormat) {
133         // We monotonically convert to double. Hence, if the fixpoint leads us to conclude that we should
134         // switch back to int, we instead ignore this and stick with double.
135         return false;
136     }
137 
138     if (m_doubleFormatState == UsingDoubleFormat)
139         return false;
140 
141     return DFG::mergeDoubleFormatState(m_doubleFormatState, UsingDoubleFormat);
142 }
143 
144 bool VariableAccessData::mergeDoubleFormatState(DoubleFormatState doubleFormatState)
</pre>
<hr />
<pre>
159     if (type &amp; (SpecInt32Only | SpecInt52Any))
160         type |= SpecAnyIntAsDouble;
161     return checkAndSet(m_prediction, type);
162 }
163 
164 bool VariableAccessData::couldRepresentInt52()
165 {
166     if (shouldNeverUnbox())
167         return false;
168 
169     return couldRepresentInt52Impl();
170 }
171 
172 bool VariableAccessData::couldRepresentInt52Impl()
173 {
174     // The hardware has to support it.
175     if (!enableInt52())
176         return false;
177 
178     // We punt for machine arguments.
<span class="line-modified">179     if (m_local.isArgument())</span>
180         return false;
181 
182     // The argument-aware prediction -- which merges all of an (inlined or machine)
183     // argument&#39;s variable access datas&#39; predictions -- must possibly be Int52Any.
184     return isInt32OrInt52Speculation(argumentAwarePrediction());
185 }
186 
187 FlushFormat VariableAccessData::flushFormat()
188 {
189     ASSERT(find() == this);
190 
191     if (!shouldUnboxIfPossible())
192         return FlushedJSValue;
193 
194     if (shouldUseDoubleFormat())
195         return FlushedDouble;
196 
197     SpeculatedType prediction = argumentAwarePrediction();
198 
199     // This guard is here to protect the call to couldRepresentInt52(), which will return
</pre>
</td>
<td>
<hr />
<pre>
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGVariableAccessData.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 namespace JSC { namespace DFG {
 32 
 33 VariableAccessData::VariableAccessData()
<span class="line-modified"> 34     : m_prediction(SpecNone)</span>

 35     , m_argumentAwarePrediction(SpecNone)
 36     , m_flags(0)
 37     , m_shouldNeverUnbox(false)
 38     , m_structureCheckHoistingFailed(false)
 39     , m_checkArrayHoistingFailed(false)
 40     , m_isProfitableToUnbox(false)
 41     , m_isLoadedFrom(false)
 42     , m_doubleFormatState(EmptyDoubleFormatState)
 43 {
 44     clearVotes();
 45 }
 46 
<span class="line-modified"> 47 VariableAccessData::VariableAccessData(Operand operand)</span>
<span class="line-modified"> 48     : m_prediction(SpecNone)</span>

 49     , m_argumentAwarePrediction(SpecNone)
<span class="line-added"> 50     , m_operand(operand)</span>
 51     , m_flags(0)
 52     , m_shouldNeverUnbox(false)
 53     , m_structureCheckHoistingFailed(false)
 54     , m_checkArrayHoistingFailed(false)
 55     , m_isProfitableToUnbox(false)
 56     , m_isLoadedFrom(false)
 57     , m_doubleFormatState(EmptyDoubleFormatState)
 58 {
 59     clearVotes();
 60 }
 61 
 62 bool VariableAccessData::mergeShouldNeverUnbox(bool shouldNeverUnbox)
 63 {
 64     bool newShouldNeverUnbox = m_shouldNeverUnbox | shouldNeverUnbox;
 65     if (newShouldNeverUnbox == m_shouldNeverUnbox)
 66         return false;
 67     m_shouldNeverUnbox = newShouldNeverUnbox;
 68     return true;
 69 }
 70 
 71 bool VariableAccessData::predict(SpeculatedType prediction)
 72 {
 73     VariableAccessData* self = find();
 74     bool result = mergeSpeculation(self-&gt;m_prediction, prediction);
 75     if (result)
 76         mergeSpeculation(m_argumentAwarePrediction, m_prediction);
 77     return result;
 78 }
 79 
 80 bool VariableAccessData::mergeArgumentAwarePrediction(SpeculatedType prediction)
 81 {
 82     return mergeSpeculation(find()-&gt;m_argumentAwarePrediction, prediction);
 83 }
 84 
 85 bool VariableAccessData::shouldUseDoubleFormatAccordingToVote()
 86 {
 87     // We don&#39;t support this facility for arguments, yet.
 88     // FIXME: make this work for arguments.
<span class="line-modified"> 89     if (operand().isArgument())</span>
 90         return false;
 91 
 92     // If the variable is not a number prediction, then this doesn&#39;t
 93     // make any sense.
 94     if (!isFullNumberSpeculation(prediction())) {
 95         // FIXME: we may end up forcing a local in inlined argument position to be a double even
 96         // if it is sometimes not even numeric, since this never signals the fact that it doesn&#39;t
 97         // want doubles. https://bugs.webkit.org/show_bug.cgi?id=109511
 98         return false;
 99     }
100 
101     // If the variable is predicted to hold only doubles, then it&#39;s a
102     // no-brainer: it should be formatted as a double.
103     if (isDoubleSpeculation(prediction()))
104         return true;
105 
106     // If the variable is known to be used as an integer, then be safe -
107     // don&#39;t force it to be a double.
108     if (flags() &amp; NodeBytecodeUsesAsInt)
109         return false;
110 
111     // If the variable has been voted to become a double, then make it a
112     // double.
113     if (voteRatio() &gt;= Options::doubleVoteRatioForDoubleFormat())
114         return true;
115 
116     return false;
117 }
118 
119 bool VariableAccessData::tallyVotesForShouldUseDoubleFormat()
120 {
121     ASSERT(isRoot());
122 
<span class="line-modified">123     if (operand().isArgument() || shouldNeverUnbox()</span>
124         || (flags() &amp; NodeBytecodeUsesAsArrayIndex))
125         return DFG::mergeDoubleFormatState(m_doubleFormatState, NotUsingDoubleFormat);
126 
127     if (m_doubleFormatState == CantUseDoubleFormat)
128         return false;
129 
130     bool newValueOfShouldUseDoubleFormat = shouldUseDoubleFormatAccordingToVote();
131     if (!newValueOfShouldUseDoubleFormat) {
132         // We monotonically convert to double. Hence, if the fixpoint leads us to conclude that we should
133         // switch back to int, we instead ignore this and stick with double.
134         return false;
135     }
136 
137     if (m_doubleFormatState == UsingDoubleFormat)
138         return false;
139 
140     return DFG::mergeDoubleFormatState(m_doubleFormatState, UsingDoubleFormat);
141 }
142 
143 bool VariableAccessData::mergeDoubleFormatState(DoubleFormatState doubleFormatState)
</pre>
<hr />
<pre>
158     if (type &amp; (SpecInt32Only | SpecInt52Any))
159         type |= SpecAnyIntAsDouble;
160     return checkAndSet(m_prediction, type);
161 }
162 
163 bool VariableAccessData::couldRepresentInt52()
164 {
165     if (shouldNeverUnbox())
166         return false;
167 
168     return couldRepresentInt52Impl();
169 }
170 
171 bool VariableAccessData::couldRepresentInt52Impl()
172 {
173     // The hardware has to support it.
174     if (!enableInt52())
175         return false;
176 
177     // We punt for machine arguments.
<span class="line-modified">178     if (operand().isArgument())</span>
179         return false;
180 
181     // The argument-aware prediction -- which merges all of an (inlined or machine)
182     // argument&#39;s variable access datas&#39; predictions -- must possibly be Int52Any.
183     return isInt32OrInt52Speculation(argumentAwarePrediction());
184 }
185 
186 FlushFormat VariableAccessData::flushFormat()
187 {
188     ASSERT(find() == this);
189 
190     if (!shouldUnboxIfPossible())
191         return FlushedJSValue;
192 
193     if (shouldUseDoubleFormat())
194         return FlushedDouble;
195 
196     SpeculatedType prediction = argumentAwarePrediction();
197 
198     // This guard is here to protect the call to couldRepresentInt52(), which will return
</pre>
</td>
</tr>
</table>
<center><a href="DFGVarargsForwardingPhase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGVariableAccessData.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/editing/FrameSelection.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2004, 2008, 2009, 2010, 2014-2015 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;FrameSelection.h&quot;
  28 
  29 #include &quot;AXObjectCache.h&quot;
  30 #include &quot;CharacterData.h&quot;
  31 #include &quot;DeleteSelectionCommand.h&quot;
  32 #include &quot;Document.h&quot;
  33 #include &quot;Editing.h&quot;
  34 #include &quot;Editor.h&quot;
  35 #include &quot;EditorClient.h&quot;
  36 #include &quot;Element.h&quot;
  37 #include &quot;ElementIterator.h&quot;
  38 #include &quot;Event.h&quot;
  39 #include &quot;EventNames.h&quot;
  40 #include &quot;FloatQuad.h&quot;
  41 #include &quot;FocusController.h&quot;
  42 #include &quot;Frame.h&quot;
  43 #include &quot;FrameTree.h&quot;
  44 #include &quot;FrameView.h&quot;
  45 #include &quot;GraphicsContext.h&quot;
  46 #include &quot;HTMLBodyElement.h&quot;
  47 #include &quot;HTMLFormElement.h&quot;
  48 #include &quot;HTMLFrameElement.h&quot;
  49 #include &quot;HTMLIFrameElement.h&quot;
  50 #include &quot;HTMLNames.h&quot;
  51 #include &quot;HTMLSelectElement.h&quot;
  52 #include &quot;HitTestRequest.h&quot;
  53 #include &quot;HitTestResult.h&quot;
  54 #include &quot;InlineTextBox.h&quot;
  55 #include &quot;Page.h&quot;
  56 #include &quot;RenderLayer.h&quot;
  57 #include &quot;RenderText.h&quot;
  58 #include &quot;RenderTextControl.h&quot;
  59 #include &quot;RenderTheme.h&quot;
  60 #include &quot;RenderView.h&quot;
  61 #include &quot;RenderWidget.h&quot;
  62 #include &quot;RenderedPosition.h&quot;
  63 #include &quot;Settings.h&quot;
  64 #include &quot;SpatialNavigation.h&quot;
  65 #include &quot;StyleProperties.h&quot;
  66 #include &quot;TypingCommand.h&quot;
  67 #include &quot;VisibleUnits.h&quot;
  68 #include &lt;stdio.h&gt;
  69 #include &lt;wtf/text/CString.h&gt;
  70 
  71 #if PLATFORM(IOS_FAMILY)
  72 #include &quot;Chrome.h&quot;
  73 #include &quot;ChromeClient.h&quot;
  74 #include &quot;Color.h&quot;
  75 #include &quot;RenderObject.h&quot;
  76 #include &quot;RenderStyle.h&quot;
  77 #endif
  78 
  79 namespace WebCore {
  80 
  81 using namespace HTMLNames;
  82 
  83 static inline LayoutUnit NoXPosForVerticalArrowNavigation()
  84 {
  85     return LayoutUnit::min();
  86 }
  87 
  88 CaretBase::CaretBase(CaretVisibility visibility)
  89     : m_caretRectNeedsUpdate(true)
  90     , m_caretVisibility(visibility)
  91 {
  92 }
  93 
  94 DragCaretController::DragCaretController()
  95     : CaretBase(Visible)
  96 {
  97 }
  98 
  99 bool DragCaretController::isContentRichlyEditable() const
 100 {
 101     return isRichlyEditablePosition(m_position.deepEquivalent());
 102 }
 103 
 104 IntRect DragCaretController::caretRectInRootViewCoordinates() const
 105 {
 106     if (!hasCaret())
 107         return { };
 108 
 109     if (auto* document = m_position.deepEquivalent().document()) {
 110         if (auto* documentView = document-&gt;view())
 111             return documentView-&gt;contentsToRootView(m_position.absoluteCaretBounds());
 112     }
 113 
 114     return { };
 115 }
 116 
 117 IntRect DragCaretController::editableElementRectInRootViewCoordinates() const
 118 {
 119     if (!hasCaret())
 120         return { };
 121 
 122     RefPtr&lt;ContainerNode&gt; editableContainer;
 123     if (auto* formControl = enclosingTextFormControl(m_position.deepEquivalent()))
 124         editableContainer = formControl;
 125     else
 126         editableContainer = highestEditableRoot(m_position.deepEquivalent());
 127 
 128     if (!editableContainer)
 129         return { };
 130 
 131     auto* renderer = editableContainer-&gt;renderer();
 132     if (!renderer)
 133         return { };
 134 
 135     if (auto* view = editableContainer-&gt;document().view())
 136         return view-&gt;contentsToRootView(renderer-&gt;absoluteBoundingBoxRect()); // FIXME: Wrong for elements with visible layout overflow.
 137 
 138     return { };
 139 }
 140 
 141 static inline bool shouldAlwaysUseDirectionalSelection(Frame* frame)
 142 {
 143     return !frame || frame-&gt;editor().behavior().shouldConsiderSelectionAsDirectional();
 144 }
 145 
 146 FrameSelection::FrameSelection(Frame* frame)
 147     : m_frame(frame)
 148     , m_xPosForVerticalArrowNavigation(NoXPosForVerticalArrowNavigation())
 149     , m_granularity(CharacterGranularity)
 150 #if ENABLE(TEXT_CARET)
 151     , m_caretBlinkTimer(*this, &amp;FrameSelection::caretBlinkTimerFired)
 152 #endif
 153     , m_appearanceUpdateTimer(*this, &amp;FrameSelection::appearanceUpdateTimerFired)
 154     , m_caretInsidePositionFixed(false)
 155     , m_absCaretBoundsDirty(true)
 156     , m_caretPaint(true)
 157     , m_isCaretBlinkingSuspended(false)
 158     , m_focused(frame &amp;&amp; frame-&gt;page() &amp;&amp; frame-&gt;page()-&gt;focusController().focusedFrame() == frame)
 159     , m_shouldShowBlockCursor(false)
 160     , m_pendingSelectionUpdate(false)
 161     , m_alwaysAlignCursorOnScrollWhenRevealingSelection(false)
 162 #if PLATFORM(IOS_FAMILY)
 163     , m_updateAppearanceEnabled(false)
 164     , m_caretBlinks(true)
 165 #endif
 166 {
 167     if (shouldAlwaysUseDirectionalSelection(m_frame))
 168         m_selection.setIsDirectional(true);
 169 }
 170 
 171 Element* FrameSelection::rootEditableElementOrDocumentElement() const
 172 {
 173     Element* selectionRoot = m_selection.rootEditableElement();
 174     return selectionRoot ? selectionRoot : m_frame-&gt;document()-&gt;documentElement();
 175 }
 176 
 177 void FrameSelection::moveTo(const VisiblePosition &amp;pos, EUserTriggered userTriggered, CursorAlignOnScroll align)
 178 {
 179     setSelection(VisibleSelection(pos.deepEquivalent(), pos.deepEquivalent(), pos.affinity(), m_selection.isDirectional()),
 180         defaultSetSelectionOptions(userTriggered), AXTextStateChangeIntent(), align);
 181 }
 182 
 183 void FrameSelection::moveTo(const VisiblePosition &amp;base, const VisiblePosition &amp;extent, EUserTriggered userTriggered)
 184 {
 185     const bool selectionHasDirection = true;
 186     setSelection(VisibleSelection(base.deepEquivalent(), extent.deepEquivalent(), base.affinity(), selectionHasDirection), defaultSetSelectionOptions(userTriggered));
 187 }
 188 
 189 void FrameSelection::moveTo(const Position &amp;pos, EAffinity affinity, EUserTriggered userTriggered)
 190 {
 191     setSelection(VisibleSelection(pos, affinity, m_selection.isDirectional()), defaultSetSelectionOptions(userTriggered));
 192 }
 193 
 194 void FrameSelection::moveTo(const Range* range)
 195 {
 196     VisibleSelection selection = range ? VisibleSelection(range-&gt;startPosition(), range-&gt;endPosition()) : VisibleSelection();
 197     setSelection(selection);
 198 }
 199 
 200 void FrameSelection::moveTo(const Position &amp;base, const Position &amp;extent, EAffinity affinity, EUserTriggered userTriggered)
 201 {
 202     const bool selectionHasDirection = true;
 203     setSelection(VisibleSelection(base, extent, affinity, selectionHasDirection), defaultSetSelectionOptions(userTriggered));
 204 }
 205 
 206 void FrameSelection::moveWithoutValidationTo(const Position&amp; base, const Position&amp; extent, bool selectionHasDirection, bool shouldSetFocus, SelectionRevealMode revealMode, const AXTextStateChangeIntent&amp; intent)
 207 {
 208     VisibleSelection newSelection;
 209     newSelection.setWithoutValidation(base, extent);
 210     newSelection.setIsDirectional(selectionHasDirection);
 211     AXTextStateChangeIntent newIntent = intent.type == AXTextStateChangeTypeUnknown ? AXTextStateChangeIntent(AXTextStateChangeTypeSelectionMove, AXTextSelection { AXTextSelectionDirectionDiscontiguous, AXTextSelectionGranularityUnknown, false }) : intent;
 212     auto options = defaultSetSelectionOptions();
 213     if (!shouldSetFocus)
 214         options.add(DoNotSetFocus);
 215     switch (revealMode) {
 216     case SelectionRevealMode::DoNotReveal:
 217         break;
 218     case SelectionRevealMode::Reveal:
 219         options.add(RevealSelection);
 220         break;
 221     case SelectionRevealMode::RevealUpToMainFrame:
 222         options.add(RevealSelectionUpToMainFrame);
 223         break;
 224     }
 225     setSelection(newSelection, options, newIntent);
 226 }
 227 
 228 void DragCaretController::setCaretPosition(const VisiblePosition&amp; position)
 229 {
 230     if (Node* node = m_position.deepEquivalent().deprecatedNode())
 231         invalidateCaretRect(node);
 232     m_position = position;
 233     setCaretRectNeedsUpdate();
 234     Document* document = nullptr;
 235     if (Node* node = m_position.deepEquivalent().deprecatedNode()) {
 236         invalidateCaretRect(node);
 237         document = &amp;node-&gt;document();
 238     }
 239     if (m_position.isNull() || m_position.isOrphan())
 240         clearCaretRect();
 241     else
 242         updateCaretRect(document, m_position);
 243 }
 244 
 245 static void adjustEndpointsAtBidiBoundary(VisiblePosition&amp; visibleBase, VisiblePosition&amp; visibleExtent)
 246 {
 247     RenderedPosition base(visibleBase);
 248     RenderedPosition extent(visibleExtent);
 249 
 250     if (base.isNull() || extent.isNull() || base.isEquivalent(extent))
 251         return;
 252 
 253     if (base.atLeftBoundaryOfBidiRun()) {
 254         if (!extent.atRightBoundaryOfBidiRun(base.bidiLevelOnRight())
 255             &amp;&amp; base.isEquivalent(extent.leftBoundaryOfBidiRun(base.bidiLevelOnRight()))) {
 256             visibleBase = base.positionAtLeftBoundaryOfBiDiRun();
 257             return;
 258         }
 259         return;
 260     }
 261 
 262     if (base.atRightBoundaryOfBidiRun()) {
 263         if (!extent.atLeftBoundaryOfBidiRun(base.bidiLevelOnLeft())
 264             &amp;&amp; base.isEquivalent(extent.rightBoundaryOfBidiRun(base.bidiLevelOnLeft()))) {
 265             visibleBase = base.positionAtRightBoundaryOfBiDiRun();
 266             return;
 267         }
 268         return;
 269     }
 270 
 271     if (extent.atLeftBoundaryOfBidiRun() &amp;&amp; extent.isEquivalent(base.leftBoundaryOfBidiRun(extent.bidiLevelOnRight()))) {
 272         visibleExtent = extent.positionAtLeftBoundaryOfBiDiRun();
 273         return;
 274     }
 275 
 276     if (extent.atRightBoundaryOfBidiRun() &amp;&amp; extent.isEquivalent(base.rightBoundaryOfBidiRun(extent.bidiLevelOnLeft()))) {
 277         visibleExtent = extent.positionAtRightBoundaryOfBiDiRun();
 278         return;
 279     }
 280 }
 281 
 282 void FrameSelection::setSelectionByMouseIfDifferent(const VisibleSelection&amp; passedNewSelection, TextGranularity granularity,
 283     EndPointsAdjustmentMode endpointsAdjustmentMode)
 284 {
 285     VisibleSelection newSelection = passedNewSelection;
 286     bool isDirectional = shouldAlwaysUseDirectionalSelection(m_frame) || newSelection.isDirectional();
 287 
 288     VisiblePosition base = m_originalBase.isNotNull() ? m_originalBase : newSelection.visibleBase();
 289     VisiblePosition newBase = base;
 290     VisiblePosition extent = newSelection.visibleExtent();
 291     VisiblePosition newExtent = extent;
 292     if (endpointsAdjustmentMode == AdjustEndpointsAtBidiBoundary)
 293         adjustEndpointsAtBidiBoundary(newBase, newExtent);
 294 
 295     if (newBase != base || newExtent != extent) {
 296         m_originalBase = base;
 297         newSelection.setBase(newBase);
 298         newSelection.setExtent(newExtent);
 299     } else if (m_originalBase.isNotNull()) {
 300         if (m_selection.base() == newSelection.base())
 301             newSelection.setBase(m_originalBase);
 302         m_originalBase.clear();
 303     }
 304 
 305     newSelection.setIsDirectional(isDirectional); // Adjusting base and extent will make newSelection always directional
 306     if (m_selection == newSelection || !shouldChangeSelection(newSelection))
 307         return;
 308 
 309 
 310     AXTextStateChangeIntent intent;
 311     if (AXObjectCache::accessibilityEnabled() &amp;&amp; newSelection.isCaret())
 312         intent = AXTextStateChangeIntent(AXTextStateChangeTypeSelectionMove, AXTextSelection { AXTextSelectionDirectionDiscontiguous, AXTextSelectionGranularityUnknown, false });
 313     else
 314         intent = AXTextStateChangeIntent();
 315     setSelection(newSelection, defaultSetSelectionOptions() | FireSelectEvent, intent, AlignCursorOnScrollIfNeeded, granularity);
 316 }
 317 
 318 bool FrameSelection::setSelectionWithoutUpdatingAppearance(const VisibleSelection&amp; newSelectionPossiblyWithoutDirection, OptionSet&lt;SetSelectionOption&gt; options, CursorAlignOnScroll align, TextGranularity granularity)
 319 {
 320     bool closeTyping = options.contains(CloseTyping);
 321     bool shouldClearTypingStyle = options.contains(ClearTypingStyle);
 322 
 323     VisibleSelection newSelection = newSelectionPossiblyWithoutDirection;
 324     if (shouldAlwaysUseDirectionalSelection(m_frame))
 325         newSelection.setIsDirectional(true);
 326 
 327     if (!m_frame) {
 328         m_selection = newSelection;
 329         return false;
 330     }
 331 
 332     // &lt;http://bugs.webkit.org/show_bug.cgi?id=23464&gt;: Infinite recursion at FrameSelection::setSelection
 333     // if document-&gt;frame() == m_frame we can get into an infinite loop
 334     if (Document* newSelectionDocument = newSelection.base().document()) {
 335         if (RefPtr&lt;Frame&gt; newSelectionFrame = newSelectionDocument-&gt;frame()) {
 336             if (newSelectionFrame != m_frame &amp;&amp; newSelectionDocument != m_frame-&gt;document()) {
 337                 newSelectionFrame-&gt;selection().setSelection(newSelection, options, AXTextStateChangeIntent(), align, granularity);
 338                 // It&#39;s possible that during the above set selection, this FrameSelection has been modified by
 339                 // selectFrameElementInParentIfFullySelected, but that the selection is no longer valid since
 340                 // the frame is about to be destroyed. If this is the case, clear our selection.
 341                 if (newSelectionFrame-&gt;hasOneRef() &amp;&amp; m_selection.isNoneOrOrphaned())
 342                     clear();
 343                 return false;
 344             }
 345         }
 346     }
 347 
 348     m_granularity = granularity;
 349 
 350     if (closeTyping)
 351         TypingCommand::closeTyping(m_frame);
 352 
 353     if (shouldClearTypingStyle)
 354         clearTypingStyle();
 355 
 356     VisibleSelection oldSelection = m_selection;
 357     bool didMutateSelection = oldSelection != newSelection;
 358     if (didMutateSelection)
 359         m_frame-&gt;editor().selectionWillChange();
 360 
 361     m_selection = newSelection;
 362 
 363     // Selection offsets should increase when LF is inserted before the caret in InsertLineBreakCommand. See &lt;https://webkit.org/b/56061&gt;.
 364     if (HTMLTextFormControlElement* textControl = enclosingTextFormControl(newSelection.start()))
 365         textControl-&gt;selectionChanged(options.contains(FireSelectEvent));
 366 
 367     if (!didMutateSelection)
 368         return false;
 369 
 370     setCaretRectNeedsUpdate();
 371 
 372     if (!newSelection.isNone() &amp;&amp; !(options &amp; DoNotSetFocus))
 373         setFocusedElementIfNeeded();
 374 
 375     // Always clear the x position used for vertical arrow navigation.
 376     // It will be restored by the vertical arrow navigation code if necessary.
 377     m_xPosForVerticalArrowNavigation = NoXPosForVerticalArrowNavigation();
 378     selectFrameElementInParentIfFullySelected();
 379     m_frame-&gt;editor().respondToChangedSelection(oldSelection, options);
 380     // https://www.w3.org/TR/selection-api/#selectionchange-event
 381     // FIXME: Spec doesn&#39;t specify which task source to use.
 382     m_frame-&gt;document()-&gt;queueTaskToDispatchEvent(TaskSource::UserInteraction, Event::create(eventNames().selectionchangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
 383 
 384     return true;
 385 }
 386 
 387 void FrameSelection::setSelection(const VisibleSelection&amp; selection, OptionSet&lt;SetSelectionOption&gt; options, AXTextStateChangeIntent intent, CursorAlignOnScroll align, TextGranularity granularity)
 388 {
 389     RefPtr&lt;Frame&gt; protectedFrame(m_frame);
 390     if (!setSelectionWithoutUpdatingAppearance(selection, options, align, granularity))
 391         return;
 392 
 393     Document* document = m_frame-&gt;document();
 394     if (!document)
 395         return;
 396 
 397     if (options &amp; RevealSelectionUpToMainFrame)
 398         m_selectionRevealMode = SelectionRevealMode::RevealUpToMainFrame;
 399     else if (options &amp; RevealSelection)
 400         m_selectionRevealMode = SelectionRevealMode::Reveal;
 401     else
 402         m_selectionRevealMode = SelectionRevealMode::DoNotReveal;
 403     m_alwaysAlignCursorOnScrollWhenRevealingSelection = align == AlignCursorOnScrollAlways;
 404 
 405     m_selectionRevealIntent = intent;
 406     m_pendingSelectionUpdate = true;
 407 
 408     if (document-&gt;hasPendingStyleRecalc())
 409         return;
 410 
 411     FrameView* frameView = document-&gt;view();
 412     if (frameView &amp;&amp; frameView-&gt;layoutContext().isLayoutPending())
 413         return;
 414 
 415     updateAndRevealSelection(intent);
 416 
 417     if (options &amp; IsUserTriggered) {
 418         if (auto* client = m_frame-&gt;editor().client())
 419             client-&gt;didEndUserTriggeredSelectionChanges();
 420     }
 421 }
 422 
 423 static void updateSelectionByUpdatingLayoutOrStyle(Frame&amp; frame)
 424 {
 425 #if ENABLE(TEXT_CARET)
 426     frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
 427 #else
 428     frame.document()-&gt;updateStyleIfNeeded();
 429 #endif
 430 }
 431 
 432 void FrameSelection::setNeedsSelectionUpdate(RevealSelectionAfterUpdate revealMode)
 433 {
 434     m_selectionRevealIntent = AXTextStateChangeIntent();
 435     if (revealMode == RevealSelectionAfterUpdate::Forced)
 436         m_selectionRevealMode = SelectionRevealMode::Reveal;
 437     m_pendingSelectionUpdate = true;
 438     if (RenderView* view = m_frame-&gt;contentRenderer())
 439         view-&gt;selection().clear();
 440 }
 441 
 442 void FrameSelection::updateAndRevealSelection(const AXTextStateChangeIntent&amp; intent)
 443 {
 444     if (!m_pendingSelectionUpdate)
 445         return;
 446 
 447     m_pendingSelectionUpdate = false;
 448 
 449     updateAppearance();
 450 
 451     if (m_selectionRevealMode != SelectionRevealMode::DoNotReveal) {
 452         ScrollAlignment alignment;
 453 
 454         if (m_frame-&gt;editor().behavior().shouldCenterAlignWhenSelectionIsRevealed())
 455             alignment = m_alwaysAlignCursorOnScrollWhenRevealingSelection ? ScrollAlignment::alignCenterAlways : ScrollAlignment::alignCenterIfNeeded;
 456         else
 457             alignment = m_alwaysAlignCursorOnScrollWhenRevealingSelection ? ScrollAlignment::alignTopAlways : ScrollAlignment::alignToEdgeIfNeeded;
 458 
 459         revealSelection(m_selectionRevealMode, alignment, RevealExtent);
 460     }
 461 
 462     notifyAccessibilityForSelectionChange(intent);
 463 }
 464 
 465 void FrameSelection::updateDataDetectorsForSelection()
 466 {
 467 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
 468     m_frame-&gt;editor().scanSelectionForTelephoneNumbers();
 469 #endif
 470 }
 471 
 472 static bool removingNodeRemovesPosition(Node&amp; node, const Position&amp; position)
 473 {
 474     if (!position.anchorNode())
 475         return false;
 476 
 477     if (position.anchorNode() == &amp;node)
 478         return true;
 479 
 480     if (!is&lt;Element&gt;(node))
 481         return false;
 482 
 483     return downcast&lt;Element&gt;(node).containsIncludingShadowDOM(position.anchorNode());
 484 }
 485 
 486 void DragCaretController::nodeWillBeRemoved(Node&amp; node)
 487 {
 488     if (!hasCaret() || !node.isConnected())
 489         return;
 490 
 491     if (!removingNodeRemovesPosition(node, m_position.deepEquivalent()))
 492         return;
 493 
 494     if (RenderView* view = node.document().renderView())
 495         view-&gt;selection().clear();
 496 
 497     clear();
 498 }
 499 
 500 void FrameSelection::nodeWillBeRemoved(Node&amp; node)
 501 {
 502     // There can&#39;t be a selection inside a fragment, so if a fragment&#39;s node is being removed,
 503     // the selection in the document that created the fragment needs no adjustment.
 504     if (isNone() || !node.isConnected())
 505         return;
 506 
 507     respondToNodeModification(node, removingNodeRemovesPosition(node, m_selection.base()), removingNodeRemovesPosition(node, m_selection.extent()),
 508         removingNodeRemovesPosition(node, m_selection.start()), removingNodeRemovesPosition(node, m_selection.end()));
 509 }
 510 
 511 void FrameSelection::respondToNodeModification(Node&amp; node, bool baseRemoved, bool extentRemoved, bool startRemoved, bool endRemoved)
 512 {
 513     bool clearRenderTreeSelection = false;
 514     bool clearDOMTreeSelection = false;
 515 
 516     if (startRemoved || endRemoved) {
 517         Position start = m_selection.start();
 518         Position end = m_selection.end();
 519         if (startRemoved)
 520             updatePositionForNodeRemoval(start, node);
 521         if (endRemoved)
 522             updatePositionForNodeRemoval(end, node);
 523 
 524         if (start.isNotNull() &amp;&amp; end.isNotNull()) {
 525             if (m_selection.isBaseFirst())
 526                 m_selection.setWithoutValidation(start, end);
 527             else
 528                 m_selection.setWithoutValidation(end, start);
 529         } else
 530             clearDOMTreeSelection = true;
 531 
 532         clearRenderTreeSelection = true;
 533     } else if (baseRemoved || extentRemoved) {
 534         // The base and/or extent are about to be removed, but the start and end aren&#39;t.
 535         // Change the base and extent to the start and end, but don&#39;t re-validate the
 536         // selection, since doing so could move the start and end into the node
 537         // that is about to be removed.
 538         if (m_selection.isBaseFirst())
 539             m_selection.setWithoutValidation(m_selection.start(), m_selection.end());
 540         else
 541             m_selection.setWithoutValidation(m_selection.end(), m_selection.start());
 542     } else if (isRange()) {
 543         if (RefPtr&lt;Range&gt; range = m_selection.firstRange()) {
 544             auto compareNodeResult = range-&gt;compareNode(node);
 545             if (!compareNodeResult.hasException()) {
 546                 auto compareResult = compareNodeResult.releaseReturnValue();
 547                 if (compareResult == Range::NODE_BEFORE_AND_AFTER || compareResult == Range::NODE_INSIDE) {
 548                     // If we did nothing here, when this node&#39;s renderer was destroyed, the rect that it
 549                     // occupied would be invalidated, but, selection gaps that change as a result of
 550                     // the removal wouldn&#39;t be invalidated.
 551                     // FIXME: Don&#39;t do so much unnecessary invalidation.
 552                     clearRenderTreeSelection = true;
 553                 }
 554             }
 555         }
 556     }
 557 
 558     if (clearRenderTreeSelection) {
 559         if (auto* renderView = node.document().renderView()) {
 560             renderView-&gt;selection().clear();
 561 
 562             // Trigger a selection update so the selection will be set again.
 563             m_selectionRevealIntent = AXTextStateChangeIntent();
 564             m_pendingSelectionUpdate = true;
 565             renderView-&gt;frameView().scheduleSelectionUpdate();
 566         }
 567     }
 568 
 569     if (clearDOMTreeSelection)
 570         setSelection(VisibleSelection(), DoNotSetFocus);
 571 }
 572 
 573 static void updatePositionAfterAdoptingTextReplacement(Position&amp; position, CharacterData* node, unsigned offset, unsigned oldLength, unsigned newLength)
 574 {
 575     if (!position.anchorNode() || position.anchorNode() != node || position.anchorType() != Position::PositionIsOffsetInAnchor)
 576         return;
 577 
 578     // See: http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Mutation
 579     ASSERT(position.offsetInContainerNode() &gt;= 0);
 580     unsigned positionOffset = static_cast&lt;unsigned&gt;(position.offsetInContainerNode());
 581     // Replacing text can be viewed as a deletion followed by insertion.
 582     if (positionOffset &gt;= offset &amp;&amp; positionOffset &lt;= offset + oldLength)
 583         position.moveToOffset(offset);
 584 
 585     // Adjust the offset if the position is after the end of the deleted contents
 586     // (positionOffset &gt; offset + oldLength) to avoid having a stale offset.
 587     if (positionOffset &gt; offset + oldLength)
 588         position.moveToOffset(positionOffset - oldLength + newLength);
 589 
 590     ASSERT(static_cast&lt;unsigned&gt;(position.offsetInContainerNode()) &lt;= node-&gt;length());
 591 }
 592 
 593 void FrameSelection::textWasReplaced(CharacterData* node, unsigned offset, unsigned oldLength, unsigned newLength)
 594 {
 595     // The fragment check is a performance optimization. See http://trac.webkit.org/changeset/30062.
 596     if (isNone() || !node || !node-&gt;isConnected())
 597         return;
 598 
 599     Position base = m_selection.base();
 600     Position extent = m_selection.extent();
 601     Position start = m_selection.start();
 602     Position end = m_selection.end();
 603     updatePositionAfterAdoptingTextReplacement(base, node, offset, oldLength, newLength);
 604     updatePositionAfterAdoptingTextReplacement(extent, node, offset, oldLength, newLength);
 605     updatePositionAfterAdoptingTextReplacement(start, node, offset, oldLength, newLength);
 606     updatePositionAfterAdoptingTextReplacement(end, node, offset, oldLength, newLength);
 607 
 608     if (base != m_selection.base() || extent != m_selection.extent() || start != m_selection.start() || end != m_selection.end()) {
 609         VisibleSelection newSelection;
 610         if (base != extent)
 611             newSelection.setWithoutValidation(base, extent);
 612         else if (m_selection.isDirectional() &amp;&amp; !m_selection.isBaseFirst())
 613             newSelection.setWithoutValidation(end, start);
 614         else
 615             newSelection.setWithoutValidation(start, end);
 616 
 617         setSelection(newSelection, DoNotSetFocus);
 618     }
 619 }
 620 
 621 TextDirection FrameSelection::directionOfEnclosingBlock()
 622 {
 623     return WebCore::directionOfEnclosingBlock(m_selection.extent());
 624 }
 625 
 626 TextDirection FrameSelection::directionOfSelection()
 627 {
 628     InlineBox* startBox = nullptr;
 629     InlineBox* endBox = nullptr;
 630     int unusedOffset;
 631     // Cache the VisiblePositions because visibleStart() and visibleEnd()
 632     // can cause layout, which has the potential to invalidate lineboxes.
 633     VisiblePosition startPosition = m_selection.visibleStart();
 634     VisiblePosition endPosition = m_selection.visibleEnd();
 635     if (startPosition.isNotNull())
 636         startPosition.getInlineBoxAndOffset(startBox, unusedOffset);
 637     if (endPosition.isNotNull())
 638         endPosition.getInlineBoxAndOffset(endBox, unusedOffset);
 639     if (startBox &amp;&amp; endBox &amp;&amp; startBox-&gt;direction() == endBox-&gt;direction())
 640         return startBox-&gt;direction();
 641 
 642     return directionOfEnclosingBlock();
 643 }
 644 
 645 void FrameSelection::willBeModified(EAlteration alter, SelectionDirection direction)
 646 {
 647     if (alter != AlterationExtend)
 648         return;
 649 
 650     Position start = m_selection.start();
 651     Position end = m_selection.end();
 652 
 653     bool baseIsStart = true;
 654 
 655     if (m_selection.isDirectional()) {
 656         // Make base and extent match start and end so we extend the user-visible selection.
 657         // This only matters for cases where base and extend point to different positions than
 658         // start and end (e.g. after a double-click to select a word).
 659         if (m_selection.isBaseFirst())
 660             baseIsStart = true;
 661         else
 662             baseIsStart = false;
 663     } else {
 664         switch (direction) {
 665         case DirectionRight:
 666             if (directionOfSelection() == TextDirection::LTR)
 667                 baseIsStart = true;
 668             else
 669                 baseIsStart = false;
 670             break;
 671         case DirectionForward:
 672             baseIsStart = true;
 673             break;
 674         case DirectionLeft:
 675             if (directionOfSelection() == TextDirection::LTR)
 676                 baseIsStart = false;
 677             else
 678                 baseIsStart = true;
 679             break;
 680         case DirectionBackward:
 681             baseIsStart = false;
 682             break;
 683         }
 684     }
 685     if (baseIsStart) {
 686         m_selection.setBase(start);
 687         m_selection.setExtent(end);
 688     } else {
 689         m_selection.setBase(end);
 690         m_selection.setExtent(start);
 691     }
 692 }
 693 
 694 VisiblePosition FrameSelection::positionForPlatform(bool isGetStart) const
 695 {
 696     // FIXME: VisibleSelection should be fixed to ensure as an invariant that
 697     // base/extent always point to the same nodes as start/end, but which points
 698     // to which depends on the value of isBaseFirst. Then this can be changed
 699     // to just return m_sel.extent().
 700     if (m_frame &amp;&amp; m_frame-&gt;editor().behavior().shouldAlwaysExtendSelectionFromExtentEndpoint())
 701         return m_selection.isBaseFirst() ? m_selection.visibleEnd() : m_selection.visibleStart();
 702 
 703     return isGetStart ? m_selection.visibleStart() : m_selection.visibleEnd();
 704 }
 705 
 706 VisiblePosition FrameSelection::startForPlatform() const
 707 {
 708     return positionForPlatform(true);
 709 }
 710 
 711 VisiblePosition FrameSelection::endForPlatform() const
 712 {
 713     return positionForPlatform(false);
 714 }
 715 
 716 VisiblePosition FrameSelection::nextWordPositionForPlatform(const VisiblePosition &amp;originalPosition)
 717 {
 718     VisiblePosition positionAfterCurrentWord = nextWordPosition(originalPosition);
 719 
 720     if (m_frame &amp;&amp; m_frame-&gt;editor().behavior().shouldSkipSpaceWhenMovingRight()) {
 721         // In order to skip spaces when moving right, we advance one
 722         // word further and then move one word back. Given the
 723         // semantics of previousWordPosition() this will put us at the
 724         // beginning of the word following.
 725         VisiblePosition positionAfterSpacingAndFollowingWord = nextWordPosition(positionAfterCurrentWord);
 726         if (positionAfterSpacingAndFollowingWord != positionAfterCurrentWord)
 727             positionAfterCurrentWord = previousWordPosition(positionAfterSpacingAndFollowingWord);
 728 
 729         bool movingBackwardsMovedPositionToStartOfCurrentWord = positionAfterCurrentWord == previousWordPosition(nextWordPosition(originalPosition));
 730         if (movingBackwardsMovedPositionToStartOfCurrentWord)
 731             positionAfterCurrentWord = positionAfterSpacingAndFollowingWord;
 732     }
 733     return positionAfterCurrentWord;
 734 }
 735 
 736 #if ENABLE(USERSELECT_ALL)
 737 static void adjustPositionForUserSelectAll(VisiblePosition&amp; pos, bool isForward)
 738 {
 739     if (Node* rootUserSelectAll = Position::rootUserSelectAllForNode(pos.deepEquivalent().anchorNode()))
 740         pos = isForward ? positionAfterNode(rootUserSelectAll).downstream(CanCrossEditingBoundary) : positionBeforeNode(rootUserSelectAll).upstream(CanCrossEditingBoundary);
 741 }
 742 #endif
 743 
 744 VisiblePosition FrameSelection::modifyExtendingRight(TextGranularity granularity)
 745 {
 746     VisiblePosition pos(m_selection.extent(), m_selection.affinity());
 747 
 748     // The difference between modifyExtendingRight and modifyExtendingForward is:
 749     // modifyExtendingForward always extends forward logically.
 750     // modifyExtendingRight behaves the same as modifyExtendingForward except for extending character or word,
 751     // it extends forward logically if the enclosing block is TextDirection::LTR,
 752     // but it extends backward logically if the enclosing block is TextDirection::RTL.
 753     switch (granularity) {
 754     case CharacterGranularity:
 755         if (directionOfEnclosingBlock() == TextDirection::LTR)
 756             pos = pos.next(CannotCrossEditingBoundary);
 757         else
 758             pos = pos.previous(CannotCrossEditingBoundary);
 759         break;
 760     case WordGranularity:
 761         if (directionOfEnclosingBlock() == TextDirection::LTR)
 762             pos = nextWordPositionForPlatform(pos);
 763         else
 764             pos = previousWordPosition(pos);
 765         break;
 766     case LineBoundary:
 767         if (directionOfEnclosingBlock() == TextDirection::LTR)
 768             pos = modifyExtendingForward(granularity);
 769         else
 770             pos = modifyExtendingBackward(granularity);
 771         break;
 772     case SentenceGranularity:
 773     case LineGranularity:
 774     case ParagraphGranularity:
 775     case SentenceBoundary:
 776     case ParagraphBoundary:
 777     case DocumentBoundary:
 778         // FIXME: implement all of the above?
 779         pos = modifyExtendingForward(granularity);
 780         break;
 781     case DocumentGranularity:
 782         ASSERT_NOT_REACHED();
 783         break;
 784     }
 785 #if ENABLE(USERSELECT_ALL)
 786     adjustPositionForUserSelectAll(pos, directionOfEnclosingBlock() == TextDirection::LTR);
 787 #endif
 788     return pos;
 789 }
 790 
 791 VisiblePosition FrameSelection::modifyExtendingForward(TextGranularity granularity)
 792 {
 793     VisiblePosition pos(m_selection.extent(), m_selection.affinity());
 794     switch (granularity) {
 795     case CharacterGranularity:
 796         pos = pos.next(CannotCrossEditingBoundary);
 797         break;
 798     case WordGranularity:
 799         pos = nextWordPositionForPlatform(pos);
 800         break;
 801     case SentenceGranularity:
 802         pos = nextSentencePosition(pos);
 803         break;
 804     case LineGranularity:
 805         pos = nextLinePosition(pos, lineDirectionPointForBlockDirectionNavigation(EXTENT));
 806         break;
 807     case ParagraphGranularity:
 808         pos = nextParagraphPosition(pos, lineDirectionPointForBlockDirectionNavigation(EXTENT));
 809         break;
 810     case DocumentGranularity:
 811         ASSERT_NOT_REACHED();
 812         break;
 813     case SentenceBoundary:
 814         pos = endOfSentence(endForPlatform());
 815         break;
 816     case LineBoundary:
 817         pos = logicalEndOfLine(endForPlatform());
 818         break;
 819     case ParagraphBoundary:
 820         pos = endOfParagraph(endForPlatform());
 821         break;
 822     case DocumentBoundary:
 823         pos = endForPlatform();
 824         if (isEditablePosition(pos.deepEquivalent()))
 825             pos = endOfEditableContent(pos);
 826         else
 827             pos = endOfDocument(pos);
 828         break;
 829     }
 830 #if ENABLE(USERSELECT_ALL)
 831     adjustPositionForUserSelectAll(pos, directionOfEnclosingBlock() == TextDirection::LTR);
 832 #endif
 833     return pos;
 834 }
 835 
 836 VisiblePosition FrameSelection::modifyMovingRight(TextGranularity granularity, bool* reachedBoundary)
 837 {
 838     if (reachedBoundary)
 839         *reachedBoundary = false;
 840     VisiblePosition pos;
 841     switch (granularity) {
 842     case CharacterGranularity:
 843         if (isRange()) {
 844             if (directionOfSelection() == TextDirection::LTR)
 845                 pos = VisiblePosition(m_selection.end(), m_selection.affinity());
 846             else
 847                 pos = VisiblePosition(m_selection.start(), m_selection.affinity());
 848         } else
 849             pos = VisiblePosition(m_selection.extent(), m_selection.affinity()).right(true, reachedBoundary);
 850         break;
 851     case WordGranularity: {
 852         bool skipsSpaceWhenMovingRight = m_frame &amp;&amp; m_frame-&gt;editor().behavior().shouldSkipSpaceWhenMovingRight();
 853         VisiblePosition currentPosition(m_selection.extent(), m_selection.affinity());
 854         pos = rightWordPosition(currentPosition, skipsSpaceWhenMovingRight);
 855         if (reachedBoundary)
 856             *reachedBoundary = pos == currentPosition;
 857         break;
 858     }
 859     case SentenceGranularity:
 860     case LineGranularity:
 861     case ParagraphGranularity:
 862     case SentenceBoundary:
 863     case ParagraphBoundary:
 864     case DocumentBoundary:
 865         // FIXME: Implement all of the above.
 866         pos = modifyMovingForward(granularity, reachedBoundary);
 867         break;
 868     case LineBoundary:
 869         pos = rightBoundaryOfLine(startForPlatform(), directionOfEnclosingBlock(), reachedBoundary);
 870         break;
 871     case DocumentGranularity:
 872         ASSERT_NOT_REACHED();
 873         break;
 874     }
 875     return pos;
 876 }
 877 
 878 VisiblePosition FrameSelection::modifyMovingForward(TextGranularity granularity, bool* reachedBoundary)
 879 {
 880     if (reachedBoundary)
 881         *reachedBoundary = false;
 882     VisiblePosition currentPosition;
 883     switch (granularity) {
 884     case WordGranularity:
 885     case SentenceGranularity:
 886         currentPosition = VisiblePosition(m_selection.extent(), m_selection.affinity());
 887         break;
 888     case LineGranularity:
 889     case ParagraphGranularity:
 890     case SentenceBoundary:
 891     case ParagraphBoundary:
 892     case DocumentBoundary:
 893         currentPosition = endForPlatform();
 894         break;
 895     default:
 896         break;
 897     }
 898     VisiblePosition pos;
 899     // FIXME: Stay in editable content for the less common granularities.
 900     switch (granularity) {
 901     case CharacterGranularity:
 902         if (isRange())
 903             pos = VisiblePosition(m_selection.end(), m_selection.affinity());
 904         else
 905             pos = VisiblePosition(m_selection.extent(), m_selection.affinity()).next(CannotCrossEditingBoundary, reachedBoundary);
 906         break;
 907     case WordGranularity:
 908         pos = nextWordPositionForPlatform(currentPosition);
 909         break;
 910     case SentenceGranularity:
 911         pos = nextSentencePosition(currentPosition);
 912         break;
 913     case LineGranularity: {
 914         // down-arrowing from a range selection that ends at the start of a line needs
 915         // to leave the selection at that line start (no need to call nextLinePosition!)
 916         pos = currentPosition;
 917         if (!isRange() || !isStartOfLine(pos))
 918             pos = nextLinePosition(pos, lineDirectionPointForBlockDirectionNavigation(START));
 919         break;
 920     }
 921     case ParagraphGranularity:
 922         pos = nextParagraphPosition(currentPosition, lineDirectionPointForBlockDirectionNavigation(START));
 923         break;
 924     case DocumentGranularity:
 925         ASSERT_NOT_REACHED();
 926         break;
 927     case SentenceBoundary:
 928         pos = endOfSentence(currentPosition);
 929         break;
 930     case LineBoundary:
 931         pos = logicalEndOfLine(endForPlatform(), reachedBoundary);
 932         break;
 933     case ParagraphBoundary:
 934         pos = endOfParagraph(currentPosition);
 935         break;
 936     case DocumentBoundary:
 937         pos = currentPosition;
 938         if (isEditablePosition(pos.deepEquivalent()))
 939             pos = endOfEditableContent(pos);
 940         else
 941             pos = endOfDocument(pos);
 942         break;
 943     }
 944     switch (granularity) {
 945     case WordGranularity:
 946     case SentenceGranularity:
 947     case LineGranularity:
 948     case ParagraphGranularity:
 949     case SentenceBoundary:
 950     case ParagraphBoundary:
 951     case DocumentBoundary:
 952         if (reachedBoundary)
 953             *reachedBoundary = pos == currentPosition;
 954         break;
 955     default:
 956         break;
 957     }
 958     return pos;
 959 }
 960 
 961 VisiblePosition FrameSelection::modifyExtendingLeft(TextGranularity granularity)
 962 {
 963     VisiblePosition pos(m_selection.extent(), m_selection.affinity());
 964 
 965     // The difference between modifyExtendingLeft and modifyExtendingBackward is:
 966     // modifyExtendingBackward always extends backward logically.
 967     // modifyExtendingLeft behaves the same as modifyExtendingBackward except for extending character or word,
 968     // it extends backward logically if the enclosing block is TextDirection::LTR,
 969     // but it extends forward logically if the enclosing block is TextDirection::RTL.
 970     switch (granularity) {
 971     case CharacterGranularity:
 972         if (directionOfEnclosingBlock() == TextDirection::LTR)
 973             pos = pos.previous(CannotCrossEditingBoundary);
 974         else
 975             pos = pos.next(CannotCrossEditingBoundary);
 976         break;
 977     case WordGranularity:
 978         if (directionOfEnclosingBlock() == TextDirection::LTR)
 979             pos = previousWordPosition(pos);
 980         else
 981             pos = nextWordPositionForPlatform(pos);
 982         break;
 983     case LineBoundary:
 984         if (directionOfEnclosingBlock() == TextDirection::LTR)
 985             pos = modifyExtendingBackward(granularity);
 986         else
 987             pos = modifyExtendingForward(granularity);
 988         break;
 989     case SentenceGranularity:
 990     case LineGranularity:
 991     case ParagraphGranularity:
 992     case SentenceBoundary:
 993     case ParagraphBoundary:
 994     case DocumentBoundary:
 995         pos = modifyExtendingBackward(granularity);
 996         break;
 997     case DocumentGranularity:
 998         ASSERT_NOT_REACHED();
 999         break;
1000     }
1001 #if ENABLE(USERSELECT_ALL)
1002     adjustPositionForUserSelectAll(pos, !(directionOfEnclosingBlock() == TextDirection::LTR));
1003 #endif
1004     return pos;
1005 }
1006 
1007 VisiblePosition FrameSelection::modifyExtendingBackward(TextGranularity granularity)
1008 {
1009     VisiblePosition pos(m_selection.extent(), m_selection.affinity());
1010 
1011     // Extending a selection backward by word or character from just after a table selects
1012     // the table.  This &quot;makes sense&quot; from the user perspective, esp. when deleting.
1013     // It was done here instead of in VisiblePosition because we want VPs to iterate
1014     // over everything.
1015     switch (granularity) {
1016     case CharacterGranularity:
1017         pos = pos.previous(CannotCrossEditingBoundary);
1018         break;
1019     case WordGranularity:
1020         pos = previousWordPosition(pos);
1021         break;
1022     case SentenceGranularity:
1023         pos = previousSentencePosition(pos);
1024         break;
1025     case LineGranularity:
1026         pos = previousLinePosition(pos, lineDirectionPointForBlockDirectionNavigation(EXTENT));
1027         break;
1028     case ParagraphGranularity:
1029         pos = previousParagraphPosition(pos, lineDirectionPointForBlockDirectionNavigation(EXTENT));
1030         break;
1031     case SentenceBoundary:
1032         pos = startOfSentence(startForPlatform());
1033         break;
1034     case LineBoundary:
1035         pos = logicalStartOfLine(startForPlatform());
1036         break;
1037     case ParagraphBoundary:
1038         pos = startOfParagraph(startForPlatform());
1039         break;
1040     case DocumentBoundary:
1041         pos = startForPlatform();
1042         if (isEditablePosition(pos.deepEquivalent()))
1043             pos = startOfEditableContent(pos);
1044         else
1045             pos = startOfDocument(pos);
1046         break;
1047     case DocumentGranularity:
1048         ASSERT_NOT_REACHED();
1049         break;
1050     }
1051 #if ENABLE(USERSELECT_ALL)
1052     adjustPositionForUserSelectAll(pos, !(directionOfEnclosingBlock() == TextDirection::LTR));
1053 #endif
1054     return pos;
1055 }
1056 
1057 VisiblePosition FrameSelection::modifyMovingLeft(TextGranularity granularity, bool* reachedBoundary)
1058 {
1059     if (reachedBoundary)
1060         *reachedBoundary = false;
1061     VisiblePosition pos;
1062     switch (granularity) {
1063     case CharacterGranularity:
1064         if (isRange())
1065             if (directionOfSelection() == TextDirection::LTR)
1066                 pos = VisiblePosition(m_selection.start(), m_selection.affinity());
1067             else
1068                 pos = VisiblePosition(m_selection.end(), m_selection.affinity());
1069         else
1070             pos = VisiblePosition(m_selection.extent(), m_selection.affinity()).left(true, reachedBoundary);
1071         break;
1072     case WordGranularity: {
1073         bool skipsSpaceWhenMovingRight = m_frame &amp;&amp; m_frame-&gt;editor().behavior().shouldSkipSpaceWhenMovingRight();
1074         VisiblePosition currentPosition(m_selection.extent(), m_selection.affinity());
1075         pos = leftWordPosition(currentPosition, skipsSpaceWhenMovingRight);
1076         if (reachedBoundary)
1077             *reachedBoundary = pos == currentPosition;
1078         break;
1079     }
1080     case SentenceGranularity:
1081     case LineGranularity:
1082     case ParagraphGranularity:
1083     case SentenceBoundary:
1084     case ParagraphBoundary:
1085     case DocumentBoundary:
1086         // FIXME: Implement all of the above.
1087         pos = modifyMovingBackward(granularity, reachedBoundary);
1088         break;
1089     case LineBoundary:
1090         pos = leftBoundaryOfLine(startForPlatform(), directionOfEnclosingBlock(), reachedBoundary);
1091         break;
1092     case DocumentGranularity:
1093         ASSERT_NOT_REACHED();
1094         break;
1095     }
1096     return pos;
1097 }
1098 
1099 VisiblePosition FrameSelection::modifyMovingBackward(TextGranularity granularity, bool* reachedBoundary)
1100 {
1101     if (reachedBoundary)
1102         *reachedBoundary = false;
1103     VisiblePosition currentPosition;
1104     switch (granularity) {
1105     case WordGranularity:
1106     case SentenceGranularity:
1107         currentPosition = VisiblePosition(m_selection.extent(), m_selection.affinity());
1108         break;
1109     case LineGranularity:
1110     case ParagraphGranularity:
1111     case SentenceBoundary:
1112     case ParagraphBoundary:
1113     case DocumentBoundary:
1114         currentPosition = startForPlatform();
1115         break;
1116     default:
1117         break;
1118     }
1119     VisiblePosition pos;
1120     switch (granularity) {
1121     case CharacterGranularity:
1122         if (isRange())
1123             pos = VisiblePosition(m_selection.start(), m_selection.affinity());
1124         else
1125             pos = VisiblePosition(m_selection.extent(), m_selection.affinity()).previous(CannotCrossEditingBoundary, reachedBoundary);
1126         break;
1127     case WordGranularity:
1128         pos = previousWordPosition(currentPosition);
1129         break;
1130     case SentenceGranularity:
1131         pos = previousSentencePosition(currentPosition);
1132         break;
1133     case LineGranularity:
1134         pos = previousLinePosition(currentPosition, lineDirectionPointForBlockDirectionNavigation(START));
1135         break;
1136     case ParagraphGranularity:
1137         pos = previousParagraphPosition(currentPosition, lineDirectionPointForBlockDirectionNavigation(START));
1138         break;
1139     case SentenceBoundary:
1140         pos = startOfSentence(currentPosition);
1141         break;
1142     case LineBoundary:
1143         pos = logicalStartOfLine(startForPlatform(), reachedBoundary);
1144         break;
1145     case ParagraphBoundary:
1146         pos = startOfParagraph(currentPosition);
1147         break;
1148     case DocumentBoundary:
1149         pos = currentPosition;
1150         if (isEditablePosition(pos.deepEquivalent()))
1151             pos = startOfEditableContent(pos);
1152         else
1153             pos = startOfDocument(pos);
1154         break;
1155     case DocumentGranularity:
1156         ASSERT_NOT_REACHED();
1157         break;
1158     }
1159     switch (granularity) {
1160     case WordGranularity:
1161     case SentenceGranularity:
1162     case LineGranularity:
1163     case ParagraphGranularity:
1164     case SentenceBoundary:
1165     case ParagraphBoundary:
1166     case DocumentBoundary:
1167         if (reachedBoundary)
1168             *reachedBoundary = pos == currentPosition;
1169         break;
1170     default:
1171         break;
1172     }
1173     return pos;
1174 }
1175 
1176 static bool isBoundary(TextGranularity granularity)
1177 {
1178     return granularity == LineBoundary || granularity == ParagraphBoundary || granularity == DocumentBoundary;
1179 }
1180 
1181 AXTextStateChangeIntent FrameSelection::textSelectionIntent(EAlteration alter, SelectionDirection direction, TextGranularity granularity)
1182 {
1183     AXTextStateChangeIntent intent = AXTextStateChangeIntent();
1184     bool flip = false;
1185     if (alter == FrameSelection::AlterationMove) {
1186         intent.type = AXTextStateChangeTypeSelectionMove;
1187         flip = isRange() &amp;&amp; directionOfSelection() == TextDirection::RTL;
1188     } else
1189         intent.type = AXTextStateChangeTypeSelectionExtend;
1190     switch (granularity) {
1191     case CharacterGranularity:
1192         intent.selection.granularity = AXTextSelectionGranularityCharacter;
1193         break;
1194     case WordGranularity:
1195         intent.selection.granularity = AXTextSelectionGranularityWord;
1196         break;
1197     case SentenceGranularity:
1198     case SentenceBoundary:
1199         intent.selection.granularity = AXTextSelectionGranularitySentence;
1200         break;
1201     case LineGranularity:
1202     case LineBoundary:
1203         intent.selection.granularity = AXTextSelectionGranularityLine;
1204         break;
1205     case ParagraphGranularity:
1206     case ParagraphBoundary:
1207         intent.selection.granularity = AXTextSelectionGranularityParagraph;
1208         break;
1209     case DocumentGranularity:
1210     case DocumentBoundary:
1211         intent.selection.granularity = AXTextSelectionGranularityDocument;
1212         break;
1213     }
1214     bool boundary = false;
1215     switch (granularity) {
1216     case CharacterGranularity:
1217     case WordGranularity:
1218     case SentenceGranularity:
1219     case LineGranularity:
1220     case ParagraphGranularity:
1221     case DocumentGranularity:
1222         break;
1223     case SentenceBoundary:
1224     case LineBoundary:
1225     case ParagraphBoundary:
1226     case DocumentBoundary:
1227         boundary = true;
1228         break;
1229     }
1230     switch (direction) {
1231     case DirectionRight:
1232     case DirectionForward:
1233         if (boundary)
1234             intent.selection.direction = flip ? AXTextSelectionDirectionBeginning : AXTextSelectionDirectionEnd;
1235         else
1236             intent.selection.direction = flip ? AXTextSelectionDirectionPrevious : AXTextSelectionDirectionNext;
1237         break;
1238     case DirectionLeft:
1239     case DirectionBackward:
1240         if (boundary)
1241             intent.selection.direction = flip ? AXTextSelectionDirectionEnd : AXTextSelectionDirectionBeginning;
1242         else
1243             intent.selection.direction = flip ? AXTextSelectionDirectionNext : AXTextSelectionDirectionPrevious;
1244         break;
1245     }
1246     return intent;
1247 }
1248 
1249 static AXTextSelection textSelectionWithDirectionAndGranularity(SelectionDirection direction, TextGranularity granularity)
1250 {
1251     // FIXME: Account for BIDI in DirectionRight &amp; DirectionLeft. (In a RTL block, Right would map to Previous/Beginning and Left to Next/End.)
1252     AXTextSelectionDirection intentDirection = AXTextSelectionDirectionUnknown;
1253     switch (direction) {
1254     case DirectionForward:
1255         intentDirection = AXTextSelectionDirectionNext;
1256         break;
1257     case DirectionRight:
1258         intentDirection = AXTextSelectionDirectionNext;
1259         break;
1260     case DirectionBackward:
1261         intentDirection = AXTextSelectionDirectionPrevious;
1262         break;
1263     case DirectionLeft:
1264         intentDirection = AXTextSelectionDirectionPrevious;
1265         break;
1266     }
1267     AXTextSelectionGranularity intentGranularity = AXTextSelectionGranularityUnknown;
1268     switch (granularity) {
1269     case CharacterGranularity:
1270         intentGranularity = AXTextSelectionGranularityCharacter;
1271         break;
1272     case WordGranularity:
1273         intentGranularity = AXTextSelectionGranularityWord;
1274         break;
1275     case SentenceGranularity:
1276     case SentenceBoundary: // FIXME: Boundary should affect direction.
1277         intentGranularity = AXTextSelectionGranularitySentence;
1278         break;
1279     case LineGranularity:
1280         intentGranularity = AXTextSelectionGranularityLine;
1281         break;
1282     case ParagraphGranularity:
1283     case ParagraphBoundary: // FIXME: Boundary should affect direction.
1284         intentGranularity = AXTextSelectionGranularityParagraph;
1285         break;
1286     case DocumentGranularity:
1287     case DocumentBoundary: // FIXME: Boundary should affect direction.
1288         intentGranularity = AXTextSelectionGranularityDocument;
1289         break;
1290     case LineBoundary:
1291         intentGranularity = AXTextSelectionGranularityLine;
1292         switch (direction) {
1293         case DirectionForward:
1294             intentDirection = AXTextSelectionDirectionEnd;
1295             break;
1296         case DirectionRight:
1297             intentDirection = AXTextSelectionDirectionEnd;
1298             break;
1299         case DirectionBackward:
1300             intentDirection = AXTextSelectionDirectionBeginning;
1301             break;
1302         case DirectionLeft:
1303             intentDirection = AXTextSelectionDirectionBeginning;
1304             break;
1305         }
1306         break;
1307     }
1308     return { intentDirection, intentGranularity, false };
1309 }
1310 
1311 bool FrameSelection::modify(EAlteration alter, SelectionDirection direction, TextGranularity granularity, EUserTriggered userTriggered)
1312 {
1313     if (userTriggered == UserTriggered) {
1314         FrameSelection trialFrameSelection;
1315         trialFrameSelection.setSelection(m_selection);
1316         trialFrameSelection.modify(alter, direction, granularity, NotUserTriggered);
1317 
1318         bool change = shouldChangeSelection(trialFrameSelection.selection());
1319         if (!change)
1320             return false;
1321 
1322         if (trialFrameSelection.selection().isRange() &amp;&amp; m_selection.isCaret() &amp;&amp; !dispatchSelectStart())
1323             return false;
1324     }
1325 
1326     willBeModified(alter, direction);
1327 
1328     bool reachedBoundary = false;
1329     bool wasRange = m_selection.isRange();
1330     Position originalStartPosition = m_selection.start();
1331     VisiblePosition position;
1332     switch (direction) {
1333     case DirectionRight:
1334         if (alter == AlterationMove)
1335             position = modifyMovingRight(granularity, &amp;reachedBoundary);
1336         else
1337             position = modifyExtendingRight(granularity);
1338         break;
1339     case DirectionForward:
1340         if (alter == AlterationExtend)
1341             position = modifyExtendingForward(granularity);
1342         else
1343             position = modifyMovingForward(granularity, &amp;reachedBoundary);
1344         break;
1345     case DirectionLeft:
1346         if (alter == AlterationMove)
1347             position = modifyMovingLeft(granularity, &amp;reachedBoundary);
1348         else
1349             position = modifyExtendingLeft(granularity);
1350         break;
1351     case DirectionBackward:
1352         if (alter == AlterationExtend)
1353             position = modifyExtendingBackward(granularity);
1354         else
1355             position = modifyMovingBackward(granularity, &amp;reachedBoundary);
1356         break;
1357     }
1358 
1359     if (reachedBoundary &amp;&amp; !isRange() &amp;&amp; userTriggered == UserTriggered &amp;&amp; m_frame &amp;&amp; AXObjectCache::accessibilityEnabled()) {
1360         notifyAccessibilityForSelectionChange({ AXTextStateChangeTypeSelectionBoundary, textSelectionWithDirectionAndGranularity(direction, granularity) });
1361         return true;
1362     }
1363 
1364     if (position.isNull())
1365         return false;
1366 
1367     if (isSpatialNavigationEnabled(m_frame))
1368         if (!wasRange &amp;&amp; alter == AlterationMove &amp;&amp; position == originalStartPosition)
1369             return false;
1370 
1371     if (m_frame &amp;&amp; AXObjectCache::accessibilityEnabled()) {
1372         if (AXObjectCache* cache = m_frame-&gt;document()-&gt;existingAXObjectCache())
1373             cache-&gt;setTextSelectionIntent(textSelectionIntent(alter, direction, granularity));
1374     }
1375 
1376     // Some of the above operations set an xPosForVerticalArrowNavigation.
1377     // Setting a selection will clear it, so save it to possibly restore later.
1378     // Note: the START position type is arbitrary because it is unused, it would be
1379     // the requested position type if there were no xPosForVerticalArrowNavigation set.
1380     LayoutUnit x = lineDirectionPointForBlockDirectionNavigation(START);
1381     m_selection.setIsDirectional(shouldAlwaysUseDirectionalSelection(m_frame) || alter == AlterationExtend);
1382 
1383     switch (alter) {
1384     case AlterationMove:
1385         moveTo(position, userTriggered);
1386         break;
1387     case AlterationExtend:
1388 
1389         if (!m_selection.isCaret()
1390             &amp;&amp; (granularity == WordGranularity || granularity == ParagraphGranularity || granularity == LineGranularity)
1391             &amp;&amp; m_frame &amp;&amp; !m_frame-&gt;editor().behavior().shouldExtendSelectionByWordOrLineAcrossCaret()) {
1392             // Don&#39;t let the selection go across the base position directly. Needed to match mac
1393             // behavior when, for instance, word-selecting backwards starting with the caret in
1394             // the middle of a word and then word-selecting forward, leaving the caret in the
1395             // same place where it was, instead of directly selecting to the end of the word.
1396             VisibleSelection newSelection = m_selection;
1397             newSelection.setExtent(position);
1398             if (m_selection.isBaseFirst() != newSelection.isBaseFirst())
1399                 position = m_selection.base();
1400         }
1401 
1402         // Standard Mac behavior when extending to a boundary is grow the selection rather than leaving the
1403         // base in place and moving the extent. Matches NSTextView.
1404         if (!m_frame || !m_frame-&gt;editor().behavior().shouldAlwaysGrowSelectionWhenExtendingToBoundary() || m_selection.isCaret() || !isBoundary(granularity))
1405             setExtent(position, userTriggered);
1406         else {
1407             TextDirection textDirection = directionOfEnclosingBlock();
1408             if (direction == DirectionForward || (textDirection == TextDirection::LTR &amp;&amp; direction == DirectionRight) || (textDirection == TextDirection::RTL &amp;&amp; direction == DirectionLeft))
1409                 setEnd(position, userTriggered);
1410             else
1411                 setStart(position, userTriggered);
1412         }
1413         break;
1414     }
1415 
1416     if (granularity == LineGranularity || granularity == ParagraphGranularity)
1417         m_xPosForVerticalArrowNavigation = x;
1418 
1419     if (userTriggered == UserTriggered)
1420         m_granularity = CharacterGranularity;
1421 
1422     setCaretRectNeedsUpdate();
1423 
1424     return true;
1425 }
1426 
1427 // FIXME: Maybe baseline would be better?
1428 static bool absoluteCaretY(const VisiblePosition &amp;c, int &amp;y)
1429 {
1430     IntRect rect = c.absoluteCaretBounds();
1431     if (rect.isEmpty())
1432         return false;
1433     y = rect.y() + rect.height() / 2;
1434     return true;
1435 }
1436 
1437 bool FrameSelection::modify(EAlteration alter, unsigned verticalDistance, VerticalDirection direction, EUserTriggered userTriggered, CursorAlignOnScroll align)
1438 {
1439     if (!verticalDistance)
1440         return false;
1441 
1442     if (userTriggered == UserTriggered) {
1443         FrameSelection trialFrameSelection;
1444         trialFrameSelection.setSelection(m_selection);
1445         trialFrameSelection.modify(alter, verticalDistance, direction, NotUserTriggered);
1446 
1447         bool change = shouldChangeSelection(trialFrameSelection.selection());
1448         if (!change)
1449             return false;
1450     }
1451 
1452     willBeModified(alter, direction == DirectionUp ? DirectionBackward : DirectionForward);
1453 
1454     VisiblePosition pos;
1455     LayoutUnit xPos;
1456     switch (alter) {
1457     case AlterationMove:
1458         pos = VisiblePosition(direction == DirectionUp ? m_selection.start() : m_selection.end(), m_selection.affinity());
1459         xPos = lineDirectionPointForBlockDirectionNavigation(direction == DirectionUp ? START : END);
1460         m_selection.setAffinity(direction == DirectionUp ? UPSTREAM : DOWNSTREAM);
1461         break;
1462     case AlterationExtend:
1463         pos = VisiblePosition(m_selection.extent(), m_selection.affinity());
1464         xPos = lineDirectionPointForBlockDirectionNavigation(EXTENT);
1465         m_selection.setAffinity(DOWNSTREAM);
1466         break;
1467     }
1468 
1469     int startY;
1470     if (!absoluteCaretY(pos, startY))
1471         return false;
1472     if (direction == DirectionUp)
1473         startY = -startY;
1474     int lastY = startY;
1475 
1476     VisiblePosition result;
1477     VisiblePosition next;
1478     for (VisiblePosition p = pos; ; p = next) {
1479         if (direction == DirectionUp)
1480             next = previousLinePosition(p, xPos);
1481         else
1482             next = nextLinePosition(p, xPos);
1483 
1484         if (next.isNull() || next == p)
1485             break;
1486         int nextY;
1487         if (!absoluteCaretY(next, nextY))
1488             break;
1489         if (direction == DirectionUp)
1490             nextY = -nextY;
1491         if (nextY - startY &gt; static_cast&lt;int&gt;(verticalDistance))
1492             break;
1493         if (nextY &gt;= lastY) {
1494             lastY = nextY;
1495             result = next;
1496         }
1497     }
1498 
1499     if (result.isNull())
1500         return false;
1501 
1502     switch (alter) {
1503     case AlterationMove:
1504         moveTo(result, userTriggered, align);
1505         break;
1506     case AlterationExtend:
1507         setExtent(result, userTriggered);
1508         break;
1509     }
1510 
1511     if (userTriggered == UserTriggered)
1512         m_granularity = CharacterGranularity;
1513 
1514     m_selection.setIsDirectional(shouldAlwaysUseDirectionalSelection(m_frame) || alter == AlterationExtend);
1515 
1516     return true;
1517 }
1518 
1519 LayoutUnit FrameSelection::lineDirectionPointForBlockDirectionNavigation(EPositionType type)
1520 {
1521     LayoutUnit x;
1522 
1523     if (isNone())
1524         return x;
1525 
1526     Position pos;
1527     switch (type) {
1528     case START:
1529         pos = m_selection.start();
1530         break;
1531     case END:
1532         pos = m_selection.end();
1533         break;
1534     case BASE:
1535         pos = m_selection.base();
1536         break;
1537     case EXTENT:
1538         pos = m_selection.extent();
1539         break;
1540     }
1541 
1542     Frame* frame = pos.anchorNode()-&gt;document().frame();
1543     if (!frame)
1544         return x;
1545 
1546     if (m_xPosForVerticalArrowNavigation == NoXPosForVerticalArrowNavigation()) {
1547         VisiblePosition visiblePosition(pos, m_selection.affinity());
1548         // VisiblePosition creation can fail here if a node containing the selection becomes visibility:hidden
1549         // after the selection is created and before this function is called.
1550         x = visiblePosition.isNotNull() ? visiblePosition.lineDirectionPointForBlockDirectionNavigation() : 0;
1551         m_xPosForVerticalArrowNavigation = x;
1552     } else
1553         x = m_xPosForVerticalArrowNavigation;
1554 
1555     return x;
1556 }
1557 
1558 void FrameSelection::clear()
1559 {
1560     m_granularity = CharacterGranularity;
1561     setSelection(VisibleSelection());
1562 }
1563 
1564 void FrameSelection::prepareForDestruction()
1565 {
1566     m_granularity = CharacterGranularity;
1567 
1568 #if ENABLE(TEXT_CARET)
1569     m_caretBlinkTimer.stop();
1570 #endif
1571 
1572     if (auto* view = m_frame-&gt;contentRenderer())
1573         view-&gt;selection().clear();
1574 
1575     setSelectionWithoutUpdatingAppearance(VisibleSelection(), defaultSetSelectionOptions(), AlignCursorOnScrollIfNeeded, CharacterGranularity);
1576     m_previousCaretNode = nullptr;
1577     m_typingStyle = nullptr;
1578     m_appearanceUpdateTimer.stop();
1579 }
1580 
1581 void FrameSelection::setStart(const VisiblePosition &amp;pos, EUserTriggered trigger)
1582 {
1583     if (m_selection.isBaseFirst())
1584         setBase(pos, trigger);
1585     else
1586         setExtent(pos, trigger);
1587 }
1588 
1589 void FrameSelection::setEnd(const VisiblePosition &amp;pos, EUserTriggered trigger)
1590 {
1591     if (m_selection.isBaseFirst())
1592         setExtent(pos, trigger);
1593     else
1594         setBase(pos, trigger);
1595 }
1596 
1597 void FrameSelection::setBase(const VisiblePosition &amp;pos, EUserTriggered userTriggered)
1598 {
1599     const bool selectionHasDirection = true;
1600     setSelection(VisibleSelection(pos.deepEquivalent(), m_selection.extent(), pos.affinity(), selectionHasDirection), defaultSetSelectionOptions(userTriggered));
1601 }
1602 
1603 void FrameSelection::setExtent(const VisiblePosition &amp;pos, EUserTriggered userTriggered)
1604 {
1605     const bool selectionHasDirection = true;
1606     setSelection(VisibleSelection(m_selection.base(), pos.deepEquivalent(), pos.affinity(), selectionHasDirection), defaultSetSelectionOptions(userTriggered));
1607 }
1608 
1609 void FrameSelection::setBase(const Position &amp;pos, EAffinity affinity, EUserTriggered userTriggered)
1610 {
1611     const bool selectionHasDirection = true;
1612     setSelection(VisibleSelection(pos, m_selection.extent(), affinity, selectionHasDirection), defaultSetSelectionOptions(userTriggered));
1613 }
1614 
1615 void FrameSelection::setExtent(const Position &amp;pos, EAffinity affinity, EUserTriggered userTriggered)
1616 {
1617     const bool selectionHasDirection = true;
1618     setSelection(VisibleSelection(m_selection.base(), pos, affinity, selectionHasDirection), defaultSetSelectionOptions(userTriggered));
1619 }
1620 
1621 void CaretBase::clearCaretRect()
1622 {
1623     m_caretLocalRect = LayoutRect();
1624 }
1625 
1626 bool CaretBase::updateCaretRect(Document* document, const VisiblePosition&amp; caretPosition)
1627 {
1628     document-&gt;updateLayoutIgnorePendingStylesheets();
1629     m_caretRectNeedsUpdate = false;
1630     RenderBlock* renderer;
1631     m_caretLocalRect = localCaretRectInRendererForCaretPainting(caretPosition, renderer);
1632     return !m_caretLocalRect.isEmpty();
1633 }
1634 
1635 RenderBlock* FrameSelection::caretRendererWithoutUpdatingLayout() const
1636 {
1637     return rendererForCaretPainting(m_selection.start().deprecatedNode());
1638 }
1639 
1640 RenderBlock* DragCaretController::caretRenderer() const
1641 {
1642     return rendererForCaretPainting(m_position.deepEquivalent().deprecatedNode());
1643 }
1644 
1645 static bool isNonOrphanedCaret(const VisibleSelection&amp; selection)
1646 {
1647     return selection.isCaret() &amp;&amp; !selection.start().isOrphan() &amp;&amp; !selection.end().isOrphan();
1648 }
1649 
1650 IntRect FrameSelection::absoluteCaretBounds(bool* insideFixed)
1651 {
1652     if (!m_frame)
1653         return IntRect();
1654     updateSelectionByUpdatingLayoutOrStyle(*m_frame);
1655     recomputeCaretRect();
1656     if (insideFixed)
1657         *insideFixed = m_caretInsidePositionFixed;
1658     return m_absCaretBounds;
1659 }
1660 
1661 static void repaintCaretForLocalRect(Node* node, const LayoutRect&amp; rect)
1662 {
1663     if (auto* caretPainter = rendererForCaretPainting(node))
1664         caretPainter-&gt;repaintRectangle(rect);
1665 }
1666 
1667 bool FrameSelection::recomputeCaretRect()
1668 {
1669     if (!shouldUpdateCaretRect())
1670         return false;
1671 
1672     if (!m_frame)
1673         return false;
1674 
1675     FrameView* v = m_frame-&gt;document()-&gt;view();
1676     if (!v)
1677         return false;
1678 
1679     LayoutRect oldRect = localCaretRectWithoutUpdate();
1680 
1681     RefPtr&lt;Node&gt; caretNode = m_previousCaretNode;
1682     if (shouldUpdateCaretRect()) {
1683         if (!isNonOrphanedCaret(m_selection))
1684             clearCaretRect();
1685         else {
1686             VisiblePosition visibleStart = m_selection.visibleStart();
1687             if (updateCaretRect(m_frame-&gt;document(), visibleStart)) {
1688                 caretNode = visibleStart.deepEquivalent().deprecatedNode();
1689                 m_absCaretBoundsDirty = true;
1690             }
1691         }
1692     }
1693     LayoutRect newRect = localCaretRectWithoutUpdate();
1694 
1695     if (caretNode == m_previousCaretNode &amp;&amp; oldRect == newRect &amp;&amp; !m_absCaretBoundsDirty)
1696         return false;
1697 
1698     IntRect oldAbsCaretBounds = m_absCaretBounds;
1699     bool isInsideFixed;
1700     m_absCaretBounds = absoluteBoundsForLocalCaretRect(rendererForCaretPainting(caretNode.get()), newRect, &amp;isInsideFixed);
1701     m_caretInsidePositionFixed = isInsideFixed;
1702 
1703     if (m_absCaretBoundsDirty &amp;&amp; m_selection.isCaret()) // We should be able to always assert this condition.
1704         ASSERT(m_absCaretBounds == m_selection.visibleStart().absoluteCaretBounds());
1705 
1706     m_absCaretBoundsDirty = false;
1707 
1708     if (caretNode == m_previousCaretNode &amp;&amp; oldAbsCaretBounds == m_absCaretBounds)
1709         return false;
1710 
1711 #if ENABLE(TEXT_CARET)
1712     if (RenderView* view = m_frame-&gt;document()-&gt;renderView()) {
1713         bool previousOrNewCaretNodeIsContentEditable = m_selection.isContentEditable() || (m_previousCaretNode &amp;&amp; m_previousCaretNode-&gt;isContentEditable());
1714         if (shouldRepaintCaret(view, previousOrNewCaretNodeIsContentEditable)) {
1715             if (m_previousCaretNode)
1716                 repaintCaretForLocalRect(m_previousCaretNode.get(), oldRect);
1717             m_previousCaretNode = caretNode;
1718             repaintCaretForLocalRect(caretNode.get(), newRect);
1719         }
1720     }
1721 #endif
1722     return true;
1723 }
1724 
1725 bool CaretBase::shouldRepaintCaret(const RenderView* view, bool isContentEditable) const
1726 {
1727     ASSERT(view);
1728     Frame* frame = &amp;view-&gt;frameView().frame(); // The frame where the selection started.
1729     bool caretBrowsing = frame &amp;&amp; frame-&gt;settings().caretBrowsingEnabled();
1730     return (caretBrowsing || isContentEditable);
1731 }
1732 
1733 void FrameSelection::invalidateCaretRect()
1734 {
1735     if (!isCaret())
1736         return;
1737 
1738     CaretBase::invalidateCaretRect(m_selection.start().deprecatedNode(), recomputeCaretRect());
1739 }
1740 
1741 void CaretBase::invalidateCaretRect(Node* node, bool caretRectChanged)
1742 {
1743     // EDIT FIXME: This is an unfortunate hack.
1744     // Basically, we can&#39;t trust this layout position since we
1745     // can&#39;t guarantee that the check to see if we are in unrendered
1746     // content will work at this point. We may have to wait for
1747     // a layout and re-render of the document to happen. So, resetting this
1748     // flag will cause another caret layout to happen the first time
1749     // that we try to paint the caret after this call. That one will work since
1750     // it happens after the document has accounted for any editing
1751     // changes which may have been done.
1752     // And, we need to leave this layout here so the caret moves right
1753     // away after clicking.
1754     m_caretRectNeedsUpdate = true;
1755 
1756     if (caretRectChanged)
1757         return;
1758 
1759     if (RenderView* view = node-&gt;document().renderView()) {
1760         if (shouldRepaintCaret(view, isEditableNode(*node)))
1761             repaintCaretForLocalRect(node, localCaretRectWithoutUpdate());
1762     }
1763 }
1764 
1765 void FrameSelection::paintCaret(GraphicsContext&amp; context, const LayoutPoint&amp; paintOffset, const LayoutRect&amp; clipRect)
1766 {
1767     if (m_selection.isCaret() &amp;&amp; m_caretPaint)
1768         CaretBase::paintCaret(m_selection.start().deprecatedNode(), context, paintOffset, clipRect);
1769 }
1770 
1771 void CaretBase::paintCaret(Node* node, GraphicsContext&amp; context, const LayoutPoint&amp; paintOffset, const LayoutRect&amp; clipRect) const
1772 {
1773 #if ENABLE(TEXT_CARET)
1774     if (m_caretVisibility == Hidden)
1775         return;
1776 
1777     LayoutRect drawingRect = localCaretRectWithoutUpdate();
1778     if (auto* renderer = rendererForCaretPainting(node))
1779         renderer-&gt;flipForWritingMode(drawingRect);
1780     drawingRect.moveBy(roundedIntPoint(paintOffset));
1781     LayoutRect caret = intersection(drawingRect, clipRect);
1782     if (caret.isEmpty())
1783         return;
1784 
1785     Color caretColor = Color::black;
1786     Element* element = is&lt;Element&gt;(*node) ? downcast&lt;Element&gt;(node) : node-&gt;parentElement();
1787     if (element &amp;&amp; element-&gt;renderer()) {
1788         auto computeCaretColor = [] (const RenderStyle&amp; elementStyle, const RenderStyle* rootEditableStyle) {
1789             // CSS value &quot;auto&quot; is treated as an invalid color.
1790             if (!elementStyle.caretColor().isValid() &amp;&amp; rootEditableStyle) {
1791                 auto rootEditableBackgroundColor = rootEditableStyle-&gt;visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
1792                 auto elementBackgroundColor = elementStyle.visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
1793                 auto disappearsIntoBackground = rootEditableBackgroundColor.blend(elementBackgroundColor) == rootEditableBackgroundColor;
1794                 if (disappearsIntoBackground)
1795                     return rootEditableStyle-&gt;visitedDependentColorWithColorFilter(CSSPropertyCaretColor);
1796             }
1797             return elementStyle.visitedDependentColorWithColorFilter(CSSPropertyCaretColor);
1798         };
1799         auto* rootEditableElement = node-&gt;rootEditableElement();
1800         auto* rootEditableStyle = rootEditableElement &amp;&amp; rootEditableElement-&gt;renderer() ? &amp;rootEditableElement-&gt;renderer()-&gt;style() : nullptr;
1801         caretColor = computeCaretColor(element-&gt;renderer()-&gt;style(), rootEditableStyle);
1802     }
1803 
1804     context.fillRect(caret, caretColor);
1805 #else
1806     UNUSED_PARAM(node);
1807     UNUSED_PARAM(context);
1808     UNUSED_PARAM(paintOffset);
1809     UNUSED_PARAM(clipRect);
1810 #endif
1811 }
1812 
1813 void FrameSelection::debugRenderer(RenderObject* renderer, bool selected) const
1814 {
1815     if (is&lt;Element&gt;(*renderer-&gt;node())) {
1816         Element&amp; element = downcast&lt;Element&gt;(*renderer-&gt;node());
1817         fprintf(stderr, &quot;%s%s\n&quot;, selected ? &quot;==&gt; &quot; : &quot;    &quot;, element.localName().string().utf8().data());
1818     } else if (is&lt;RenderText&gt;(*renderer)) {
1819         RenderText&amp; textRenderer = downcast&lt;RenderText&gt;(*renderer);
1820         if (textRenderer.text().isEmpty() || !textRenderer.firstTextBox()) {
1821             fprintf(stderr, &quot;%s#text (empty)\n&quot;, selected ? &quot;==&gt; &quot; : &quot;    &quot;);
1822             return;
1823         }
1824 
1825         static const int max = 36;
1826         String text = textRenderer.text();
1827         int textLength = text.length();
1828         if (selected) {
1829             int offset = 0;
1830             if (renderer-&gt;node() == m_selection.start().containerNode())
1831                 offset = m_selection.start().computeOffsetInContainerNode();
1832             else if (renderer-&gt;node() == m_selection.end().containerNode())
1833                 offset = m_selection.end().computeOffsetInContainerNode();
1834 
1835             int pos;
1836             InlineTextBox* box = textRenderer.findNextInlineTextBox(offset, pos);
1837             text = text.substring(box-&gt;start(), box-&gt;len());
1838 
1839             String show;
1840             int mid = max / 2;
1841             int caret = 0;
1842 
1843             // text is shorter than max
1844             if (textLength &lt; max) {
1845                 show = text;
1846                 caret = pos;
1847             } else if (pos - mid &lt; 0) {
1848                 // too few characters to left
1849                 show = text.left(max - 3) + &quot;...&quot;;
1850                 caret = pos;
1851             } else if (pos - mid &gt;= 0 &amp;&amp; pos + mid &lt;= textLength) {
1852                 // enough characters on each side
1853                 show = &quot;...&quot; + text.substring(pos - mid + 3, max - 6) + &quot;...&quot;;
1854                 caret = mid;
1855             } else {
1856                 // too few characters on right
1857                 show = &quot;...&quot; + text.right(max - 3);
1858                 caret = pos - (textLength - show.length());
1859             }
1860 
1861             show.replace(&#39;\n&#39;, &#39; &#39;);
1862             show.replace(&#39;\r&#39;, &#39; &#39;);
1863             fprintf(stderr, &quot;==&gt; #text : \&quot;%s\&quot; at offset %d\n&quot;, show.utf8().data(), pos);
1864             fprintf(stderr, &quot;           &quot;);
1865             for (int i = 0; i &lt; caret; i++)
1866                 fprintf(stderr, &quot; &quot;);
1867             fprintf(stderr, &quot;^\n&quot;);
1868         } else {
1869             if ((int)text.length() &gt; max)
1870                 text = text.left(max - 3) + &quot;...&quot;;
1871             else
1872                 text = text.left(max);
1873             fprintf(stderr, &quot;    #text : \&quot;%s\&quot;\n&quot;, text.utf8().data());
1874         }
1875     }
1876 }
1877 
1878 bool FrameSelection::contains(const LayoutPoint&amp; point) const
1879 {
1880     // Treat a collapsed selection like no selection.
1881     if (!isRange())
1882         return false;
1883 
1884     auto* document = m_frame-&gt;document();
1885     if (!document)
1886         return false;
1887 
1888     HitTestResult result(point);
1889     document-&gt;hitTest(HitTestRequest(), result);
1890     Node* innerNode = result.innerNode();
1891     if (!innerNode || !innerNode-&gt;renderer())
1892         return false;
1893 
1894     VisiblePosition visiblePos(innerNode-&gt;renderer()-&gt;positionForPoint(result.localPoint(), nullptr));
1895     if (visiblePos.isNull())
1896         return false;
1897 
1898     if (m_selection.visibleStart().isNull() || m_selection.visibleEnd().isNull())
1899         return false;
1900 
1901     Position start(m_selection.visibleStart().deepEquivalent());
1902     Position end(m_selection.visibleEnd().deepEquivalent());
1903     Position p(visiblePos.deepEquivalent());
1904 
1905     return comparePositions(start, p) &lt;= 0 &amp;&amp; comparePositions(p, end) &lt;= 0;
1906 }
1907 
1908 // Workaround for the fact that it&#39;s hard to delete a frame.
1909 // Call this after doing user-triggered selections to make it easy to delete the frame you entirely selected.
1910 // Can&#39;t do this implicitly as part of every setSelection call because in some contexts it might not be good
1911 // for the focus to move to another frame. So instead we call it from places where we are selecting with the
1912 // mouse or the keyboard after setting the selection.
1913 void FrameSelection::selectFrameElementInParentIfFullySelected()
1914 {
1915     // Find the parent frame; if there is none, then we have nothing to do.
1916     Frame* parent = m_frame-&gt;tree().parent();
1917     if (!parent)
1918         return;
1919     Page* page = m_frame-&gt;page();
1920     if (!page)
1921         return;
1922 
1923     // Check if the selection contains the entire frame contents; if not, then there is nothing to do.
1924     if (!isRange())
1925         return;
1926     if (!isStartOfDocument(selection().visibleStart()))
1927         return;
1928     if (!isEndOfDocument(selection().visibleEnd()))
1929         return;
1930 
1931     // Get to the &lt;iframe&gt; or &lt;frame&gt; (or even &lt;object&gt;) element in the parent frame.
1932     Element* ownerElement = m_frame-&gt;ownerElement();
1933     if (!ownerElement)
1934         return;
1935     ContainerNode* ownerElementParent = ownerElement-&gt;parentNode();
1936     if (!ownerElementParent)
1937         return;
1938 
1939     // This method&#39;s purpose is it to make it easier to select iframes (in order to delete them).  Don&#39;t do anything if the iframe isn&#39;t deletable.
1940     if (!ownerElementParent-&gt;hasEditableStyle())
1941         return;
1942 
1943     // Create compute positions before and after the element.
1944     unsigned ownerElementNodeIndex = ownerElement-&gt;computeNodeIndex();
1945     VisiblePosition beforeOwnerElement(VisiblePosition(Position(ownerElementParent, ownerElementNodeIndex, Position::PositionIsOffsetInAnchor)));
1946     VisiblePosition afterOwnerElement(VisiblePosition(Position(ownerElementParent, ownerElementNodeIndex + 1, Position::PositionIsOffsetInAnchor), VP_UPSTREAM_IF_POSSIBLE));
1947 
1948     // Focus on the parent frame, and then select from before this element to after.
1949     VisibleSelection newSelection(beforeOwnerElement, afterOwnerElement);
1950     if (parent-&gt;selection().shouldChangeSelection(newSelection)) {
1951         page-&gt;focusController().setFocusedFrame(parent);
1952         parent-&gt;selection().setSelection(newSelection);
1953     }
1954 }
1955 
1956 void FrameSelection::selectAll()
1957 {
1958     Document* document = m_frame-&gt;document();
1959 
1960     Element* focusedElement = document-&gt;focusedElement();
1961     if (is&lt;HTMLSelectElement&gt;(focusedElement)) {
1962         HTMLSelectElement&amp; selectElement = downcast&lt;HTMLSelectElement&gt;(*focusedElement);
1963         if (selectElement.canSelectAll()) {
1964             selectElement.selectAll();
1965             return;
1966         }
1967     }
1968 
1969     RefPtr&lt;Node&gt; root;
1970     Node* selectStartTarget = nullptr;
1971     if (m_selection.isContentEditable()) {
1972         root = highestEditableRoot(m_selection.start());
1973         if (Node* shadowRoot = m_selection.nonBoundaryShadowTreeRootNode())
1974             selectStartTarget = shadowRoot-&gt;shadowHost();
1975         else
1976             selectStartTarget = root.get();
1977     } else {
1978         if (m_selection.isNone() &amp;&amp; focusedElement) {
1979             if (focusedElement-&gt;isTextField()) {
1980                 downcast&lt;HTMLTextFormControlElement&gt;(*focusedElement).select();
1981                 return;
1982             }
1983             root = focusedElement-&gt;nonBoundaryShadowTreeRootNode();
1984         } else
1985             root = m_selection.nonBoundaryShadowTreeRootNode();
1986 
1987         if (root)
1988             selectStartTarget = root-&gt;shadowHost();
1989         else {
1990             root = document-&gt;documentElement();
1991             selectStartTarget = document-&gt;bodyOrFrameset();
1992         }
1993     }
1994     if (!root)
1995         return;
1996 
1997     if (selectStartTarget) {
1998         auto event = Event::create(eventNames().selectstartEvent, Event::CanBubble::Yes, Event::IsCancelable::Yes);
1999         selectStartTarget-&gt;dispatchEvent(event);
2000         if (event-&gt;defaultPrevented())
2001             return;
2002     }
2003 
2004     VisibleSelection newSelection(VisibleSelection::selectionFromContentsOfNode(root.get()));
2005 
2006     if (shouldChangeSelection(newSelection)) {
2007         AXTextStateChangeIntent intent(AXTextStateChangeTypeSelectionExtend, AXTextSelection { AXTextSelectionDirectionDiscontiguous, AXTextSelectionGranularityAll, false });
2008         setSelection(newSelection, defaultSetSelectionOptions() | FireSelectEvent, intent);
2009     }
2010 }
2011 
2012 bool FrameSelection::setSelectedRange(Range* range, EAffinity affinity, ShouldCloseTyping closeTyping, EUserTriggered userTriggered)
2013 {
2014     if (!range)
2015         return false;
2016     ASSERT(&amp;range-&gt;startContainer().document() == &amp;range-&gt;endContainer().document());
2017 
2018     VisibleSelection newSelection(*range, affinity);
2019 
2020 #if PLATFORM(IOS_FAMILY)
2021     // FIXME: Why do we need this check only in iOS?
2022     if (newSelection.isNone())
2023         return false;
2024 #endif
2025 
2026     OptionSet&lt;SetSelectionOption&gt; selectionOptions {  ClearTypingStyle };
2027     if (closeTyping == ShouldCloseTyping::Yes)
2028         selectionOptions.add(CloseTyping);
2029 
2030     if (userTriggered == UserTriggered) {
2031         FrameSelection trialFrameSelection;
2032 
2033         trialFrameSelection.setSelection(newSelection, selectionOptions);
2034 
2035         if (!shouldChangeSelection(trialFrameSelection.selection()))
2036             return false;
2037 
2038         selectionOptions.add(IsUserTriggered);
2039     }
2040 
2041     setSelection(newSelection, selectionOptions);
2042     return true;
2043 }
2044 
2045 void FrameSelection::focusedOrActiveStateChanged()
2046 {
2047     bool activeAndFocused = isFocusedAndActive();
2048     Ref&lt;Document&gt; document(*m_frame-&gt;document());
2049 
2050     document-&gt;updateStyleIfNeeded();
2051 
2052 #if USE(UIKIT_EDITING)
2053     // Caret blinking (blinks | does not blink)
2054     if (activeAndFocused)
2055         setSelectionFromNone();
2056     setCaretVisible(activeAndFocused);
2057 #else
2058     // Because RenderObject::selectionBackgroundColor() and
2059     // RenderObject::selectionForegroundColor() check if the frame is active,
2060     // we have to update places those colors were painted.
2061     if (RenderView* view = document-&gt;renderView())
2062         view-&gt;selection().repaint();
2063 
2064     // Caret appears in the active frame.
2065     if (activeAndFocused)
2066         setSelectionFromNone();
2067     setCaretVisibility(activeAndFocused ? Visible : Hidden);
2068 
2069     // Because Style::Resolver::checkOneSelector() and
2070     // RenderTheme::isFocused() check if the frame is active, we have to
2071     // update style and theme state that depended on those.
2072     if (Element* element = document-&gt;focusedElement()) {
2073         element-&gt;invalidateStyleForSubtree();
2074         if (RenderObject* renderer = element-&gt;renderer())
2075             if (renderer &amp;&amp; renderer-&gt;style().hasAppearance())
2076                 renderer-&gt;theme().stateChanged(*renderer, ControlStates::FocusState);
2077     }
2078 #endif
2079 }
2080 
2081 void FrameSelection::pageActivationChanged()
2082 {
2083     focusedOrActiveStateChanged();
2084 }
2085 
2086 void FrameSelection::setFocused(bool flag)
2087 {
2088     if (m_focused == flag)
2089         return;
2090     m_focused = flag;
2091 
2092     focusedOrActiveStateChanged();
2093 }
2094 
2095 bool FrameSelection::isFocusedAndActive() const
2096 {
2097     return m_focused &amp;&amp; m_frame-&gt;page() &amp;&amp; m_frame-&gt;page()-&gt;focusController().isActive();
2098 }
2099 
2100 #if ENABLE(TEXT_CARET)
2101 inline static bool shouldStopBlinkingDueToTypingCommand(Frame* frame)
2102 {
2103     return frame-&gt;editor().lastEditCommand() &amp;&amp; frame-&gt;editor().lastEditCommand()-&gt;shouldStopCaretBlinking();
2104 }
2105 #endif
2106 
2107 void FrameSelection::updateAppearance()
2108 {
2109 #if PLATFORM(IOS_FAMILY)
2110     if (!m_updateAppearanceEnabled)
2111         return;
2112 #endif
2113 
2114     // Paint a block cursor instead of a caret in overtype mode unless the caret is at the end of a line (in this case
2115     // the FrameSelection will paint a blinking caret as usual).
2116     VisibleSelection oldSelection = selection();
2117 
2118 #if ENABLE(TEXT_CARET)
2119     bool paintBlockCursor = m_shouldShowBlockCursor &amp;&amp; m_selection.isCaret() &amp;&amp; !isLogicalEndOfLine(m_selection.visibleEnd());
2120     bool caretRectChangedOrCleared = recomputeCaretRect();
2121 
2122     bool caretBrowsing = m_frame-&gt;settings().caretBrowsingEnabled();
2123     bool shouldBlink = !paintBlockCursor &amp;&amp; caretIsVisible() &amp;&amp; isCaret() &amp;&amp; (oldSelection.isContentEditable() || caretBrowsing);
2124 
2125     // If the caret moved, stop the blink timer so we can restart with a
2126     // black caret in the new location.
2127     if (caretRectChangedOrCleared || !shouldBlink || shouldStopBlinkingDueToTypingCommand(m_frame))
2128         m_caretBlinkTimer.stop();
2129 
2130     // Start blinking with a black caret. Be sure not to restart if we&#39;re
2131     // already blinking in the right location.
2132     if (shouldBlink &amp;&amp; !m_caretBlinkTimer.isActive()) {
2133         if (Seconds blinkInterval = RenderTheme::singleton().caretBlinkInterval())
2134             m_caretBlinkTimer.startRepeating(blinkInterval);
2135 
2136         if (!m_caretPaint) {
2137             m_caretPaint = true;
2138             invalidateCaretRect();
2139         }
2140     }
2141 #endif
2142 
2143     RenderView* view = m_frame-&gt;contentRenderer();
2144     if (!view)
2145         return;
2146 
2147     // Construct a new VisibleSolution, since m_selection is not necessarily valid, and the following steps
2148     // assume a valid selection. See &lt;https://bugs.webkit.org/show_bug.cgi?id=69563&gt; and &lt;rdar://problem/10232866&gt;.
2149 #if ENABLE(TEXT_CARET)
2150     VisiblePosition endVisiblePosition = paintBlockCursor ? modifyExtendingForward(CharacterGranularity) : oldSelection.visibleEnd();
2151     VisibleSelection selection(oldSelection.visibleStart(), endVisiblePosition);
2152 #else
2153     VisibleSelection selection(oldSelection.visibleStart(), oldSelection.visibleEnd());
2154 #endif
2155 
2156     if (!selection.isRange()) {
2157         view-&gt;selection().clear();
2158         return;
2159     }
2160 
2161     // Use the rightmost candidate for the start of the selection, and the leftmost candidate for the end of the selection.
2162     // Example: foo &lt;a&gt;bar&lt;/a&gt;.  Imagine that a line wrap occurs after &#39;foo&#39;, and that &#39;bar&#39; is selected.   If we pass [foo, 3]
2163     // as the start of the selection, the selection painting code will think that content on the line containing &#39;foo&#39; is selected
2164     // and will fill the gap before &#39;bar&#39;.
2165     Position startPos = selection.start();
2166     Position candidate = startPos.downstream();
2167     if (candidate.isCandidate())
2168         startPos = candidate;
2169     Position endPos = selection.end();
2170     candidate = endPos.upstream();
2171     if (candidate.isCandidate())
2172         endPos = candidate;
2173 
2174     // We can get into a state where the selection endpoints map to the same VisiblePosition when a selection is deleted
2175     // because we don&#39;t yet notify the FrameSelection of text removal.
2176     if (startPos.isNotNull() &amp;&amp; endPos.isNotNull() &amp;&amp; selection.visibleStart() != selection.visibleEnd()) {
2177         RenderObject* startRenderer = startPos.deprecatedNode()-&gt;renderer();
2178         int startOffset = startPos.deprecatedEditingOffset();
2179         RenderObject* endRenderer = endPos.deprecatedNode()-&gt;renderer();
2180         int endOffset = endPos.deprecatedEditingOffset();
2181         ASSERT(startOffset &gt;= 0 &amp;&amp; endOffset &gt;= 0);
2182         view-&gt;selection().set({ startRenderer, endRenderer, static_cast&lt;unsigned&gt;(startOffset), static_cast&lt;unsigned&gt;(endOffset) });
2183     }
2184 }
2185 
2186 void FrameSelection::setCaretVisibility(CaretVisibility visibility)
2187 {
2188     if (caretVisibility() == visibility)
2189         return;
2190 
2191     // FIXME: We shouldn&#39;t trigger a synchronous layout here.
2192     if (m_frame)
2193         updateSelectionByUpdatingLayoutOrStyle(*m_frame);
2194 
2195 #if ENABLE(TEXT_CARET)
2196     if (m_caretPaint) {
2197         m_caretPaint = false;
2198         invalidateCaretRect();
2199     }
2200     CaretBase::setCaretVisibility(visibility);
2201 #endif
2202 
2203     updateAppearance();
2204 }
2205 
2206 void FrameSelection::caretBlinkTimerFired()
2207 {
2208 #if ENABLE(TEXT_CARET)
2209     ASSERT(caretIsVisible());
2210     ASSERT(isCaret());
2211     bool caretPaint = m_caretPaint;
2212     if (isCaretBlinkingSuspended() &amp;&amp; caretPaint)
2213         return;
2214     m_caretPaint = !caretPaint;
2215     invalidateCaretRect();
2216 #endif
2217 }
2218 
2219 // Helper function that tells whether a particular node is an element that has an entire
2220 // Frame and FrameView, a &lt;frame&gt;, &lt;iframe&gt;, or &lt;object&gt;.
2221 static bool isFrameElement(const Node* n)
2222 {
2223     if (!n)
2224         return false;
2225     RenderObject* renderer = n-&gt;renderer();
2226     if (!is&lt;RenderWidget&gt;(renderer))
2227         return false;
2228     Widget* widget = downcast&lt;RenderWidget&gt;(*renderer).widget();
2229     return widget &amp;&amp; widget-&gt;isFrameView();
2230 }
2231 
2232 void FrameSelection::setFocusedElementIfNeeded()
2233 {
2234     if (isNone() || !isFocused())
2235         return;
2236 
2237     bool caretBrowsing = m_frame-&gt;settings().caretBrowsingEnabled();
2238     if (caretBrowsing) {
2239         if (Element* anchor = enclosingAnchorElement(m_selection.base())) {
2240             m_frame-&gt;page()-&gt;focusController().setFocusedElement(anchor, *m_frame);
2241             return;
2242         }
2243     }
2244 
2245     if (Element* target = m_selection.rootEditableElement()) {
2246         // Walk up the DOM tree to search for an element to focus.
2247         while (target) {
2248             // We don&#39;t want to set focus on a subframe when selecting in a parent frame,
2249             // so add the !isFrameElement check here. There&#39;s probably a better way to make this
2250             // work in the long term, but this is the safest fix at this time.
2251             if (target-&gt;isMouseFocusable() &amp;&amp; !isFrameElement(target)) {
2252                 m_frame-&gt;page()-&gt;focusController().setFocusedElement(target, *m_frame);
2253                 return;
2254             }
2255             target = target-&gt;parentOrShadowHostElement();
2256         }
2257         m_frame-&gt;document()-&gt;setFocusedElement(nullptr);
2258     }
2259 
2260     if (caretBrowsing)
2261         m_frame-&gt;page()-&gt;focusController().setFocusedElement(nullptr, *m_frame);
2262 }
2263 
2264 void DragCaretController::paintDragCaret(Frame* frame, GraphicsContext&amp; p, const LayoutPoint&amp; paintOffset, const LayoutRect&amp; clipRect) const
2265 {
2266 #if ENABLE(TEXT_CARET)
2267     if (m_position.deepEquivalent().deprecatedNode()-&gt;document().frame() == frame)
2268         paintCaret(m_position.deepEquivalent().deprecatedNode(), p, paintOffset, clipRect);
2269 #else
2270     UNUSED_PARAM(frame);
2271     UNUSED_PARAM(p);
2272     UNUSED_PARAM(paintOffset);
2273     UNUSED_PARAM(clipRect);
2274 #endif
2275 }
2276 
2277 RefPtr&lt;MutableStyleProperties&gt; FrameSelection::copyTypingStyle() const
2278 {
2279     if (!m_typingStyle || !m_typingStyle-&gt;style())
2280         return nullptr;
2281     return m_typingStyle-&gt;style()-&gt;mutableCopy();
2282 }
2283 
2284 bool FrameSelection::shouldDeleteSelection(const VisibleSelection&amp; selection) const
2285 {
2286 #if PLATFORM(IOS_FAMILY)
2287     if (m_frame-&gt;selectionChangeCallbacksDisabled())
2288         return true;
2289 #endif
2290     return m_frame-&gt;editor().client()-&gt;shouldDeleteRange(selection.toNormalizedRange().get());
2291 }
2292 
2293 FloatRect FrameSelection::selectionBounds(ClipToVisibleContent clipToVisibleContent) const
2294 {
2295     if (!m_frame-&gt;document())
2296         return LayoutRect();
2297 
2298     updateSelectionByUpdatingLayoutOrStyle(*m_frame);
2299     auto* renderView = m_frame-&gt;contentRenderer();
2300     if (!renderView)
2301         return LayoutRect();
2302 
2303     auto&amp; selection = renderView-&gt;selection();
2304 
2305     if (clipToVisibleContent == ClipToVisibleContent::Yes) {
2306         auto selectionRect = selection.boundsClippedToVisibleContent();
2307         return intersection(selectionRect, renderView-&gt;frameView().visibleContentRect(ScrollableArea::LegacyIOSDocumentVisibleRect));
2308     }
2309 
2310     return selection.bounds();
2311 }
2312 
2313 void FrameSelection::getClippedVisibleTextRectangles(Vector&lt;FloatRect&gt;&amp; rectangles, TextRectangleHeight textRectHeight) const
2314 {
2315     RenderView* root = m_frame-&gt;contentRenderer();
2316     if (!root)
2317         return;
2318 
2319     Vector&lt;FloatRect&gt; textRects;
2320     getTextRectangles(textRects, textRectHeight);
2321 
2322     FloatRect visibleContentRect = m_frame-&gt;view()-&gt;visibleContentRect(ScrollableArea::LegacyIOSDocumentVisibleRect);
2323 
2324     for (const auto&amp; rect : textRects) {
2325         FloatRect intersectionRect = intersection(rect, visibleContentRect);
2326         if (!intersectionRect.isEmpty())
2327             rectangles.append(intersectionRect);
2328     }
2329 }
2330 
2331 void FrameSelection::getTextRectangles(Vector&lt;FloatRect&gt;&amp; rectangles, TextRectangleHeight textRectHeight) const
2332 {
2333     RefPtr&lt;Range&gt; range = toNormalizedRange();
2334     if (!range)
2335         return;
2336 
2337     Vector&lt;FloatQuad&gt; quads;
2338     range-&gt;absoluteTextQuads(quads, textRectHeight == TextRectangleHeight::SelectionHeight);
2339 
2340     for (const auto&amp; quad : quads)
2341         rectangles.append(quad.boundingBox());
2342 }
2343 
2344 // Scans logically forward from &quot;start&quot;, including any child frames.
2345 static HTMLFormElement* scanForForm(Element* start)
2346 {
2347     if (!start)
2348         return nullptr;
2349 
2350     auto descendants = descendantsOfType&lt;HTMLElement&gt;(start-&gt;document());
2351     for (auto it = descendants.from(*start), end = descendants.end(); it != end; ++it) {
2352         HTMLElement&amp; element = *it;
2353         if (is&lt;HTMLFormElement&gt;(element))
2354             return &amp;downcast&lt;HTMLFormElement&gt;(element);
2355         if (is&lt;HTMLFormControlElement&gt;(element))
2356             return downcast&lt;HTMLFormControlElement&gt;(element).form();
2357         if (is&lt;HTMLFrameElementBase&gt;(element)) {
2358             Document* contentDocument = downcast&lt;HTMLFrameElementBase&gt;(element).contentDocument();
2359             if (!contentDocument)
2360                 continue;
2361             if (HTMLFormElement* frameResult = scanForForm(contentDocument-&gt;documentElement()))
2362                 return frameResult;
2363         }
2364     }
2365     return nullptr;
2366 }
2367 
2368 // We look for either the form containing the current focus, or for one immediately after it
2369 HTMLFormElement* FrameSelection::currentForm() const
2370 {
2371     // Start looking either at the active (first responder) node, or where the selection is.
2372     Element* start = m_frame-&gt;document()-&gt;focusedElement();
2373     if (!start)
2374         start = m_selection.start().element();
2375     if (!start)
2376         return nullptr;
2377 
2378     if (auto form = lineageOfType&lt;HTMLFormElement&gt;(*start).first())
2379         return form;
2380     if (auto formControl = lineageOfType&lt;HTMLFormControlElement&gt;(*start).first())
2381         return formControl-&gt;form();
2382 
2383     // Try walking forward in the node tree to find a form element.
2384     return scanForForm(start);
2385 }
2386 
2387 void FrameSelection::revealSelection(SelectionRevealMode revealMode, const ScrollAlignment&amp; alignment, RevealExtentOption revealExtentOption)
2388 {
2389     if (revealMode == SelectionRevealMode::DoNotReveal)
2390         return;
2391 
2392     LayoutRect rect;
2393     bool insideFixed = false;
2394     switch (m_selection.selectionType()) {
2395     case VisibleSelection::NoSelection:
2396         return;
2397     case VisibleSelection::CaretSelection:
2398         rect = absoluteCaretBounds(&amp;insideFixed);
2399         break;
2400     case VisibleSelection::RangeSelection:
2401         rect = revealExtentOption == RevealExtent ? VisiblePosition(m_selection.extent()).absoluteCaretBounds() : enclosingIntRect(selectionBounds(ClipToVisibleContent::No));
2402         break;
2403     }
2404 
2405     Position start = m_selection.start();
2406     ASSERT(start.deprecatedNode());
2407     if (start.deprecatedNode() &amp;&amp; start.deprecatedNode()-&gt;renderer()) {
2408 #if PLATFORM(IOS_FAMILY)
2409         if (RenderLayer* layer = start.deprecatedNode()-&gt;renderer()-&gt;enclosingLayer()) {
2410             if (!m_scrollingSuppressCount) {
2411                 layer-&gt;setAdjustForIOSCaretWhenScrolling(true);
2412                 layer-&gt;scrollRectToVisible(rect, insideFixed, { revealMode, alignment, alignment, ShouldAllowCrossOriginScrolling::Yes });
2413                 layer-&gt;setAdjustForIOSCaretWhenScrolling(false);
2414                 updateAppearance();
2415                 if (m_frame-&gt;page())
2416                     m_frame-&gt;page()-&gt;chrome().client().notifyRevealedSelectionByScrollingFrame(*m_frame);
2417             }
2418         }
2419 #else
2420         // FIXME: This code only handles scrolling the startContainer&#39;s layer, but
2421         // the selection rect could intersect more than just that.
2422         // See &lt;rdar://problem/4799899&gt;.
2423         if (start.deprecatedNode()-&gt;renderer()-&gt;scrollRectToVisible(rect, insideFixed, { revealMode, alignment, alignment, ShouldAllowCrossOriginScrolling::Yes }))
2424             updateAppearance();
2425 #endif
2426     }
2427 }
2428 
2429 void FrameSelection::setSelectionFromNone()
2430 {
2431     // Put a caret inside the body if the entire frame is editable (either the
2432     // entire WebView is editable or designMode is on for this document).
2433 
2434     Document* document = m_frame-&gt;document();
2435 #if !PLATFORM(IOS_FAMILY)
2436     bool caretBrowsing = m_frame-&gt;settings().caretBrowsingEnabled();
2437     if (!isNone() || !(document-&gt;hasEditableStyle() || caretBrowsing))
2438         return;
2439 #else
2440     if (!document || !(isNone() || isStartOfDocument(VisiblePosition(m_selection.start(), m_selection.affinity()))) || !document-&gt;hasEditableStyle())
2441         return;
2442 #endif
2443 
2444     if (auto* body = document-&gt;body())
2445         setSelection(VisibleSelection(firstPositionInOrBeforeNode(body), DOWNSTREAM));
2446 }
2447 
2448 bool FrameSelection::shouldChangeSelection(const VisibleSelection&amp; newSelection) const
2449 {
2450 #if PLATFORM(IOS_FAMILY)
2451     if (m_frame-&gt;selectionChangeCallbacksDisabled())
2452         return true;
2453 #endif
2454     return m_frame-&gt;editor().shouldChangeSelection(selection(), newSelection, newSelection.affinity(), false);
2455 }
2456 
2457 bool FrameSelection::dispatchSelectStart()
2458 {
2459     Node* selectStartTarget = m_selection.extent().containerNode();
2460     if (!selectStartTarget)
2461         return true;
2462 
2463     auto event = Event::create(eventNames().selectstartEvent, Event::CanBubble::Yes, Event::IsCancelable::Yes);
2464     selectStartTarget-&gt;dispatchEvent(event);
2465     return !event-&gt;defaultPrevented();
2466 }
2467 
2468 void FrameSelection::setShouldShowBlockCursor(bool shouldShowBlockCursor)
2469 {
2470     m_shouldShowBlockCursor = shouldShowBlockCursor;
2471 
2472     m_frame-&gt;document()-&gt;updateLayoutIgnorePendingStylesheets();
2473 
2474     updateAppearance();
2475 }
2476 
2477 void FrameSelection::updateAppearanceAfterLayout()
2478 {
2479     m_appearanceUpdateTimer.stop();
2480     updateAppearanceAfterLayoutOrStyleChange();
2481 }
2482 
2483 void FrameSelection::scheduleAppearanceUpdateAfterStyleChange()
2484 {
2485     m_appearanceUpdateTimer.startOneShot(0_s);
2486 }
2487 
2488 void FrameSelection::appearanceUpdateTimerFired()
2489 {
2490     Ref&lt;Frame&gt; protectedFrame(*m_frame);
2491     updateAppearanceAfterLayoutOrStyleChange();
2492 }
2493 
2494 void FrameSelection::updateAppearanceAfterLayoutOrStyleChange()
2495 {
2496     if (auto* client = m_frame-&gt;editor().client())
2497         client-&gt;updateEditorStateAfterLayoutIfEditabilityChanged();
2498 
2499     setCaretRectNeedsUpdate();
2500     updateAndRevealSelection(m_selectionRevealIntent);
2501     updateDataDetectorsForSelection();
2502 }
2503 
2504 #if ENABLE(TREE_DEBUGGING)
2505 
2506 void FrameSelection::formatForDebugger(char* buffer, unsigned length) const
2507 {
2508     m_selection.formatForDebugger(buffer, length);
2509 }
2510 
2511 void FrameSelection::showTreeForThis() const
2512 {
2513     m_selection.showTreeForThis();
2514 }
2515 
2516 #endif
2517 
2518 #if PLATFORM(IOS_FAMILY)
2519 void FrameSelection::expandSelectionToElementContainingCaretSelection()
2520 {
2521     RefPtr&lt;Range&gt; range = elementRangeContainingCaretSelection();
2522     if (!range)
2523         return;
2524     VisibleSelection selection(*range, DOWNSTREAM);
2525     setSelection(selection);
2526 }
2527 
2528 RefPtr&lt;Range&gt; FrameSelection::elementRangeContainingCaretSelection() const
2529 {
2530     if (m_selection.isNone())
2531         return nullptr;
2532 
2533     VisibleSelection selection = m_selection;
2534     if (selection.isNone())
2535         return nullptr;
2536 
2537     VisiblePosition visiblePos(selection.start(), VP_DEFAULT_AFFINITY);
2538     if (visiblePos.isNull())
2539         return nullptr;
2540 
2541     Node* node = visiblePos.deepEquivalent().deprecatedNode();
2542     Element* element = deprecatedEnclosingBlockFlowElement(node);
2543     if (!element)
2544         return nullptr;
2545 
2546     Position startPos = createLegacyEditingPosition(element, 0);
2547     Position endPos = createLegacyEditingPosition(element, element-&gt;countChildNodes());
2548 
2549     VisiblePosition startVisiblePos(startPos, VP_DEFAULT_AFFINITY);
2550     VisiblePosition endVisiblePos(endPos, VP_DEFAULT_AFFINITY);
2551     if (startVisiblePos.isNull() || endVisiblePos.isNull())
2552         return nullptr;
2553 
2554     selection.setBase(startVisiblePos);
2555     selection.setExtent(endVisiblePos);
2556 
2557     return selection.toNormalizedRange();
2558 }
2559 
2560 void FrameSelection::expandSelectionToWordContainingCaretSelection()
2561 {
2562     VisibleSelection selection(wordSelectionContainingCaretSelection(m_selection));
2563     if (selection.isCaretOrRange())
2564         setSelection(selection);
2565 }
2566 
2567 RefPtr&lt;Range&gt; FrameSelection::wordRangeContainingCaretSelection()
2568 {
2569     return wordSelectionContainingCaretSelection(m_selection).toNormalizedRange();
2570 }
2571 
2572 void FrameSelection::expandSelectionToStartOfWordContainingCaretSelection()
2573 {
2574     if (m_selection.isNone() || isStartOfDocument(m_selection.start()))
2575         return;
2576 
2577     VisiblePosition s1(m_selection.start());
2578     VisiblePosition e1(m_selection.end());
2579 
2580     VisibleSelection expanded(wordSelectionContainingCaretSelection(m_selection));
2581     VisiblePosition s2(expanded.start());
2582 
2583     // Don&#39;t allow the start to become greater after the expansion.
2584     if (s2.isNull() || s2 &gt; s1)
2585         s2 = s1;
2586 
2587     moveTo(s2, e1);
2588 }
2589 
2590 UChar FrameSelection::characterInRelationToCaretSelection(int amount) const
2591 {
2592     if (m_selection.isNone())
2593         return 0;
2594 
2595     VisibleSelection selection = m_selection;
2596     ASSERT(selection.isCaretOrRange());
2597 
2598     VisiblePosition visiblePosition(selection.start(), VP_DEFAULT_AFFINITY);
2599 
2600     if (amount &lt; 0) {
2601         int count = abs(amount);
2602         for (int i = 0; i &lt; count; i++)
2603             visiblePosition = visiblePosition.previous();
2604         return visiblePosition.characterBefore();
2605     }
2606     for (int i = 0; i &lt; amount; i++)
2607         visiblePosition = visiblePosition.next();
2608     return visiblePosition.characterAfter();
2609 }
2610 
2611 UChar FrameSelection::characterBeforeCaretSelection() const
2612 {
2613     if (m_selection.isNone())
2614         return 0;
2615 
2616     VisibleSelection selection = m_selection;
2617     ASSERT(selection.isCaretOrRange());
2618 
2619     VisiblePosition visiblePosition(selection.start(), VP_DEFAULT_AFFINITY);
2620     return visiblePosition.characterBefore();
2621 }
2622 
2623 UChar FrameSelection::characterAfterCaretSelection() const
2624 {
2625     if (m_selection.isNone())
2626         return 0;
2627 
2628     VisibleSelection selection = m_selection;
2629     ASSERT(selection.isCaretOrRange());
2630 
2631     VisiblePosition visiblePosition(selection.end(), VP_DEFAULT_AFFINITY);
2632     return visiblePosition.characterAfter();
2633 }
2634 
2635 int FrameSelection::wordOffsetInRange(const Range *range) const
2636 {
2637     if (!range)
2638         return -1;
2639 
2640     VisibleSelection selection = m_selection;
2641     if (!selection.isCaret())
2642         return -1;
2643 
2644     // FIXME: This will only work in cases where the selection remains in
2645     // the same node after it is expanded. Improve to handle more complicated
2646     // cases.
2647     int result = selection.start().deprecatedEditingOffset() - range-&gt;startOffset();
2648     if (result &lt; 0)
2649         result = 0;
2650     return result;
2651 }
2652 
2653 bool FrameSelection::spaceFollowsWordInRange(const Range *range) const
2654 {
2655     if (!range)
2656         return false;
2657     Node&amp; node = range-&gt;endContainer();
2658     int endOffset = range-&gt;endOffset();
2659     VisiblePosition pos(createLegacyEditingPosition(&amp;node, endOffset), VP_DEFAULT_AFFINITY);
2660     return isSpaceOrNewline(pos.characterAfter());
2661 }
2662 
2663 bool FrameSelection::selectionAtDocumentStart() const
2664 {
2665     VisibleSelection selection = m_selection;
2666     if (selection.isNone())
2667         return false;
2668 
2669     Position startPos(selection.start());
2670     VisiblePosition pos(createLegacyEditingPosition(startPos.deprecatedNode(), startPos.deprecatedEditingOffset()), VP_DEFAULT_AFFINITY);
2671     if (pos.isNull())
2672         return false;
2673 
2674     return isStartOfDocument(pos);
2675 }
2676 
2677 bool FrameSelection::selectionAtSentenceStart() const
2678 {
2679     VisibleSelection selection = m_selection;
2680     if (selection.isNone())
2681         return false;
2682 
2683     return actualSelectionAtSentenceStart(selection);
2684 }
2685 
2686 bool FrameSelection::selectionAtWordStart() const
2687 {
2688     VisibleSelection selection = m_selection;
2689     if (selection.isNone())
2690         return false;
2691 
2692     Position startPos(selection.start());
2693     VisiblePosition pos(createLegacyEditingPosition(startPos.deprecatedNode(), startPos.deprecatedEditingOffset()), VP_DEFAULT_AFFINITY);
2694     if (pos.isNull())
2695         return false;
2696 
2697     if (isStartOfParagraph(pos))
2698         return true;
2699 
2700     bool result = true;
2701     unsigned previousCount = 0;
2702     for (pos = pos.previous(); !pos.isNull(); pos = pos.previous()) {
2703         previousCount++;
2704         if (isStartOfParagraph(pos)) {
2705             if (previousCount == 1)
2706                 result = false;
2707             break;
2708         }
2709         UChar c(pos.characterAfter());
2710         if (c) {
2711             result = isSpaceOrNewline(c) || c == noBreakSpace || (u_ispunct(c) &amp;&amp; c != &#39;,&#39; &amp;&amp; c != &#39;-&#39; &amp;&amp; c != &#39;\&#39;&#39;);
2712             break;
2713         }
2714     }
2715 
2716     return result;
2717 }
2718 
2719 RefPtr&lt;Range&gt; FrameSelection::rangeByMovingCurrentSelection(int amount) const
2720 {
2721     return rangeByAlteringCurrentSelection(AlterationMove, amount);
2722 }
2723 
2724 RefPtr&lt;Range&gt; FrameSelection::rangeByExtendingCurrentSelection(int amount) const
2725 {
2726     return rangeByAlteringCurrentSelection(AlterationExtend, amount);
2727 }
2728 
2729 void FrameSelection::selectRangeOnElement(unsigned location, unsigned length, Node&amp; node)
2730 {
2731     RefPtr&lt;Range&gt; resultRange = m_frame-&gt;document()-&gt;createRange();
2732     resultRange-&gt;setStart(node, location);
2733     resultRange-&gt;setEnd(node, location + length);
2734     VisibleSelection selection = VisibleSelection(*resultRange, SEL_DEFAULT_AFFINITY);
2735     // FIXME: The second argument was &quot;true&quot; which implicitly converted to option &quot;FireSelectEvent&quot;. Is this correct?
2736     setSelection(selection, { FireSelectEvent });
2737 }
2738 
2739 VisibleSelection FrameSelection::wordSelectionContainingCaretSelection(const VisibleSelection&amp; selection)
2740 {
2741     if (selection.isNone())
2742         return VisibleSelection();
2743 
2744     ASSERT(selection.isCaretOrRange());
2745     FrameSelection frameSelection;
2746     frameSelection.setSelection(selection);
2747 
2748     Position startPosBeforeExpansion(selection.start());
2749     Position endPosBeforeExpansion(selection.end());
2750     VisiblePosition startVisiblePosBeforeExpansion(startPosBeforeExpansion, VP_DEFAULT_AFFINITY);
2751     VisiblePosition endVisiblePosBeforeExpansion(endPosBeforeExpansion, VP_DEFAULT_AFFINITY);
2752     if (endVisiblePosBeforeExpansion.isNull())
2753         return VisibleSelection();
2754 
2755     if (isEndOfParagraph(endVisiblePosBeforeExpansion)) {
2756         UChar c(endVisiblePosBeforeExpansion.characterBefore());
2757         if (isSpaceOrNewline(c) || c == noBreakSpace) {
2758             // End of paragraph with space.
2759             return VisibleSelection();
2760         }
2761     }
2762 
2763     // If at end of paragraph, move backwards one character.
2764     // This has the effect of selecting the word on the line (which is
2765     // what we want, rather than selecting past the end of the line).
2766     if (isEndOfParagraph(endVisiblePosBeforeExpansion) &amp;&amp; !isStartOfParagraph(endVisiblePosBeforeExpansion))
2767         frameSelection.modify(FrameSelection::AlterationMove, DirectionBackward, CharacterGranularity);
2768 
2769     VisibleSelection newSelection = frameSelection.selection();
2770     newSelection.expandUsingGranularity(WordGranularity);
2771     frameSelection.setSelection(newSelection, defaultSetSelectionOptions(), AXTextStateChangeIntent(), AlignCursorOnScrollIfNeeded, frameSelection.granularity());
2772 
2773     Position startPos(frameSelection.selection().start());
2774     Position endPos(frameSelection.selection().end());
2775 
2776     // Expansion cannot be allowed to change selection so that it is no longer
2777     // touches (or contains) the original, unexpanded selection.
2778     // Enforce this on the way into these additional calculations to give them
2779     // the best chance to yield a suitable answer.
2780     if (startPos &gt; startPosBeforeExpansion)
2781         startPos = startPosBeforeExpansion;
2782     if (endPos &lt; endPosBeforeExpansion)
2783         endPos = endPosBeforeExpansion;
2784 
2785     VisiblePosition startVisiblePos(startPos, VP_DEFAULT_AFFINITY);
2786     VisiblePosition endVisiblePos(endPos, VP_DEFAULT_AFFINITY);
2787 
2788     if (startVisiblePos.isNull() || endVisiblePos.isNull()) {
2789         // Start or end is nil
2790         return VisibleSelection();
2791     }
2792 
2793     if (isEndOfLine(endVisiblePosBeforeExpansion)) {
2794         VisiblePosition previous(endVisiblePos.previous());
2795         if (previous == endVisiblePos) {
2796             // Empty document
2797             return VisibleSelection();
2798         }
2799         UChar c(previous.characterAfter());
2800         if (isSpaceOrNewline(c) || c == noBreakSpace) {
2801             // Space at end of line
2802             return VisibleSelection();
2803         }
2804     }
2805 
2806     // Expansion has selected past end of line.
2807     // Try repositioning backwards.
2808     if (isEndOfLine(startVisiblePos) &amp;&amp; isStartOfLine(endVisiblePos)) {
2809         VisiblePosition previous(startVisiblePos.previous());
2810         if (isEndOfLine(previous)) {
2811             // On empty line
2812             return VisibleSelection();
2813         }
2814         UChar c(previous.characterAfter());
2815         if (isSpaceOrNewline(c) || c == noBreakSpace) {
2816             // Space at end of line
2817             return VisibleSelection();
2818         }
2819         frameSelection.moveTo(startVisiblePos);
2820         frameSelection.modify(FrameSelection::AlterationExtend, DirectionBackward, WordGranularity);
2821         startPos = frameSelection.selection().start();
2822         endPos = frameSelection.selection().end();
2823         startVisiblePos = VisiblePosition(startPos, VP_DEFAULT_AFFINITY);
2824         endVisiblePos = VisiblePosition(endPos, VP_DEFAULT_AFFINITY);
2825         if (startVisiblePos.isNull() || endVisiblePos.isNull()) {
2826             // Start or end is nil
2827             return VisibleSelection();
2828         }
2829     }
2830 
2831     // Now loop backwards until we find a non-space.
2832     while (endVisiblePos != startVisiblePos) {
2833         VisiblePosition previous(endVisiblePos.previous());
2834         UChar c(previous.characterAfter());
2835         if (!isSpaceOrNewline(c) &amp;&amp; c != noBreakSpace)
2836             break;
2837         endVisiblePos = previous;
2838     }
2839 
2840     // Expansion cannot be allowed to change selection so that it is no longer
2841     // touches (or contains) the original, unexpanded selection.
2842     // Enforce this on the way out of the function to preserve the invariant.
2843     if (startVisiblePos &gt; startVisiblePosBeforeExpansion)
2844         startVisiblePos = startVisiblePosBeforeExpansion;
2845     if (endVisiblePos &lt; endVisiblePosBeforeExpansion)
2846         endVisiblePos = endVisiblePosBeforeExpansion;
2847 
2848     return VisibleSelection(startVisiblePos, endVisiblePos);
2849 }
2850 
2851 bool FrameSelection::actualSelectionAtSentenceStart(const VisibleSelection&amp; sel) const
2852 {
2853     Position startPos(sel.start());
2854     VisiblePosition pos(createLegacyEditingPosition(startPos.deprecatedNode(), startPos.deprecatedEditingOffset()), VP_DEFAULT_AFFINITY);
2855     if (pos.isNull())
2856         return false;
2857 
2858     if (isStartOfParagraph(pos))
2859         return true;
2860 
2861     bool result = true;
2862     bool sawSpace = false;
2863     unsigned previousCount = 0;
2864     for (pos = pos.previous(); !pos.isNull(); pos = pos.previous()) {
2865         previousCount++;
2866         if (isStartOfParagraph(pos)) {
2867             if (previousCount == 1 || (previousCount == 2 &amp;&amp; sawSpace))
2868                 result = false;
2869             break;
2870         }
2871         UChar c(pos.characterAfter());
2872         if (c) {
2873             if (isSpaceOrNewline(c) || c == noBreakSpace) {
2874                 sawSpace = true;
2875             }
2876             else {
2877                 result = (c == &#39;.&#39; || c == &#39;!&#39; || c == &#39;?&#39;);
2878                 break;
2879             }
2880         }
2881     }
2882 
2883     return result;
2884 }
2885 
2886 RefPtr&lt;Range&gt; FrameSelection::rangeByAlteringCurrentSelection(EAlteration alteration, int amount) const
2887 {
2888     if (m_selection.isNone())
2889         return nullptr;
2890 
2891     if (!amount)
2892         return toNormalizedRange();
2893 
2894     FrameSelection frameSelection;
2895     frameSelection.setSelection(m_selection);
2896     SelectionDirection direction = amount &gt; 0 ? DirectionForward : DirectionBackward;
2897     for (int i = 0; i &lt; abs(amount); i++)
2898         frameSelection.modify(alteration, direction, CharacterGranularity);
2899     return frameSelection.toNormalizedRange();
2900 }
2901 
2902 void FrameSelection::clearCurrentSelection()
2903 {
2904     setSelection(VisibleSelection());
2905 }
2906 
2907 void FrameSelection::setCaretBlinks(bool caretBlinks)
2908 {
2909     if (m_caretBlinks == caretBlinks)
2910         return;
2911 #if ENABLE(TEXT_CARET)
2912     m_frame-&gt;document()-&gt;updateLayoutIgnorePendingStylesheets();
2913     if (m_caretPaint) {
2914         m_caretPaint = false;
2915         invalidateCaretRect();
2916     }
2917 #endif
2918     if (caretBlinks)
2919         setFocusedElementIfNeeded();
2920     m_caretBlinks = caretBlinks;
2921     updateAppearance();
2922 }
2923 
2924 void FrameSelection::setCaretColor(const Color&amp; caretColor)
2925 {
2926     if (m_caretColor != caretColor) {
2927         m_caretColor = caretColor;
2928         if (caretIsVisible() &amp;&amp; m_caretBlinks &amp;&amp; isCaret())
2929             invalidateCaretRect();
2930     }
2931 }
2932 #endif // PLATFORM(IOS_FAMILY)
2933 
2934 }
2935 
2936 #if ENABLE(TREE_DEBUGGING)
2937 
2938 void showTree(const WebCore::FrameSelection&amp; sel)
2939 {
2940     sel.showTreeForThis();
2941 }
2942 
2943 void showTree(const WebCore::FrameSelection* sel)
2944 {
2945     if (sel)
2946         sel-&gt;showTreeForThis();
2947 }
2948 
2949 #endif
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLDrawBuffers.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2013 Google Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 16  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 17  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 18  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 19  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 20  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 21  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 23  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #if ENABLE(WEBGL)
 29 #include &quot;WebGLDrawBuffers.h&quot;
 30 
<a name="1" id="anc1"></a><span class="line-modified"> 31 #include &quot;Extensions3D.h&quot;</span>
 32 
 33 namespace WebCore {
 34 
 35 WebGLDrawBuffers::WebGLDrawBuffers(WebGLRenderingContextBase&amp; context)
 36     : WebGLExtension(context)
 37 {
<a name="2" id="anc2"></a>
 38 }
 39 
 40 WebGLDrawBuffers::~WebGLDrawBuffers() = default;
 41 
 42 WebGLExtension::ExtensionName WebGLDrawBuffers::getName() const
 43 {
 44     return WebGLExtension::WebGLDrawBuffersName;
 45 }
 46 
 47 bool WebGLDrawBuffers::supported(WebGLRenderingContextBase&amp; context)
 48 {
<a name="3" id="anc3"></a><span class="line-modified"> 49     return context.graphicsContext3D()-&gt;getExtensions().supports(&quot;GL_EXT_draw_buffers&quot;)</span>



 50         &amp;&amp; satisfiesWebGLRequirements(context);
<a name="4" id="anc4"></a>
 51 }
 52 
<a name="5" id="anc5"></a><span class="line-modified"> 53 void WebGLDrawBuffers::drawBuffersWEBGL(const Vector&lt;GC3Denum&gt;&amp; buffers)</span>
 54 {
 55     if (m_context.isContextLost())
 56         return;
<a name="6" id="anc6"></a><span class="line-modified"> 57     GC3Dsizei n = buffers.size();</span>
<span class="line-modified"> 58     const GC3Denum* bufs = buffers.data();</span>
 59     if (!m_context.m_framebufferBinding) {
 60         if (n != 1) {
<a name="7" id="anc7"></a><span class="line-modified"> 61             m_context.synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;drawBuffersWEBGL&quot;, &quot;more than one buffer&quot;);</span>
 62             return;
 63         }
<a name="8" id="anc8"></a><span class="line-modified"> 64         if (bufs[0] != GraphicsContext3D::BACK &amp;&amp; bufs[0] != GraphicsContext3D::NONE) {</span>
<span class="line-modified"> 65             m_context.synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawBuffersWEBGL&quot;, &quot;BACK or NONE&quot;);</span>
 66             return;
 67         }
 68         // Because the backbuffer is simulated on all current WebKit ports, we need to change BACK to COLOR_ATTACHMENT0.
<a name="9" id="anc9"></a><span class="line-modified"> 69         GC3Denum value = (bufs[0] == GraphicsContext3D::BACK) ? GraphicsContext3D::COLOR_ATTACHMENT0 : GraphicsContext3D::NONE;</span>
<span class="line-modified"> 70         m_context.graphicsContext3D()-&gt;getExtensions().drawBuffersEXT(1, &amp;value);</span>
 71         m_context.setBackDrawBuffer(bufs[0]);
 72     } else {
 73         if (n &gt; m_context.getMaxDrawBuffers()) {
<a name="10" id="anc10"></a><span class="line-modified"> 74             m_context.synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;drawBuffersWEBGL&quot;, &quot;more than max draw buffers&quot;);</span>
 75             return;
 76         }
<a name="11" id="anc11"></a><span class="line-modified"> 77         for (GC3Dsizei i = 0; i &lt; n; ++i) {</span>
<span class="line-modified"> 78             if (bufs[i] != GraphicsContext3D::NONE &amp;&amp; bufs[i] != static_cast&lt;GC3Denum&gt;(Extensions3D::COLOR_ATTACHMENT0_EXT + i)) {</span>
<span class="line-modified"> 79                 m_context.synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawBuffersWEBGL&quot;, &quot;COLOR_ATTACHMENTi_EXT or NONE&quot;);</span>
 80                 return;
 81             }
 82         }
 83         m_context.m_framebufferBinding-&gt;drawBuffers(buffers);
 84     }
 85 }
 86 
 87 // static
 88 bool WebGLDrawBuffers::satisfiesWebGLRequirements(WebGLRenderingContextBase&amp; webglContext)
 89 {
<a name="12" id="anc12"></a><span class="line-modified"> 90     GraphicsContext3D* context = webglContext.graphicsContext3D();</span>
 91 
 92     // This is called after we make sure GL_EXT_draw_buffers is supported.
<a name="13" id="anc13"></a><span class="line-modified"> 93     GC3Dint maxDrawBuffers = 0;</span>
<span class="line-modified"> 94     GC3Dint maxColorAttachments = 0;</span>
<span class="line-modified"> 95     context-&gt;getIntegerv(Extensions3D::MAX_DRAW_BUFFERS_EXT, &amp;maxDrawBuffers);</span>
<span class="line-modified"> 96     context-&gt;getIntegerv(Extensions3D::MAX_COLOR_ATTACHMENTS_EXT, &amp;maxColorAttachments);</span>
 97     if (maxDrawBuffers &lt; 4 || maxColorAttachments &lt; 4)
 98         return false;
 99 
<a name="14" id="anc14"></a><span class="line-modified">100     Platform3DObject fbo = context-&gt;createFramebuffer();</span>
<span class="line-modified">101     context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, fbo);</span>
102 
103     const unsigned char buffer[4] = { 0, 0, 0, 0 }; // textures are required to be initialized for other ports.
104     bool supportsDepth = context-&gt;getExtensions().supports(&quot;GL_OES_depth_texture&quot;)
105         || context-&gt;getExtensions().supports(&quot;GL_ARB_depth_texture&quot;);
106     bool supportsDepthStencil = (context-&gt;getExtensions().supports(&quot;GL_EXT_packed_depth_stencil&quot;)
107         || context-&gt;getExtensions().supports(&quot;GL_OES_packed_depth_stencil&quot;));
<a name="15" id="anc15"></a><span class="line-modified">108     Platform3DObject depthStencil = 0;</span>
109     if (supportsDepthStencil) {
110         depthStencil = context-&gt;createTexture();
<a name="16" id="anc16"></a><span class="line-modified">111         context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, depthStencil);</span>
<span class="line-modified">112         context-&gt;texImage2D(GraphicsContext3D::TEXTURE_2D, 0, GraphicsContext3D::DEPTH_STENCIL, 1, 1, 0, GraphicsContext3D::DEPTH_STENCIL, GraphicsContext3D::UNSIGNED_INT_24_8, buffer);</span>
113     }
<a name="17" id="anc17"></a><span class="line-modified">114     Platform3DObject depth = 0;</span>
115     if (supportsDepth) {
116         depth = context-&gt;createTexture();
<a name="18" id="anc18"></a><span class="line-modified">117         context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, depth);</span>
<span class="line-modified">118         context-&gt;texImage2D(GraphicsContext3D::TEXTURE_2D, 0, GraphicsContext3D::DEPTH_COMPONENT, 1, 1, 0, GraphicsContext3D::DEPTH_COMPONENT, GraphicsContext3D::UNSIGNED_INT, buffer);</span>
119     }
120 
<a name="19" id="anc19"></a><span class="line-modified">121     Vector&lt;Platform3DObject&gt; colors;</span>
122     bool ok = true;
<a name="20" id="anc20"></a><span class="line-modified">123     GC3Dint maxAllowedBuffers = std::min(maxDrawBuffers, maxColorAttachments);</span>
<span class="line-modified">124     for (GC3Dint i = 0; i &lt; maxAllowedBuffers; ++i) {</span>
<span class="line-modified">125         Platform3DObject color = context-&gt;createTexture();</span>
126         colors.append(color);
<a name="21" id="anc21"></a><span class="line-modified">127         context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, color);</span>
<span class="line-modified">128         context-&gt;texImage2D(GraphicsContext3D::TEXTURE_2D, 0, GraphicsContext3D::RGBA, 1, 1, 0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, buffer);</span>
<span class="line-modified">129         context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::COLOR_ATTACHMENT0 + i, GraphicsContext3D::TEXTURE_2D, color, 0);</span>
<span class="line-modified">130         if (context-&gt;checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER) != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {</span>
131             ok = false;
132             break;
133         }
134         if (supportsDepth) {
<a name="22" id="anc22"></a><span class="line-modified">135             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::DEPTH_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, depth, 0);</span>
<span class="line-modified">136             if (context-&gt;checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER) != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {</span>
137                 ok = false;
138                 break;
139             }
<a name="23" id="anc23"></a><span class="line-modified">140             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::DEPTH_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, 0, 0);</span>
141         }
142         if (supportsDepthStencil) {
<a name="24" id="anc24"></a><span class="line-modified">143             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::DEPTH_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, depthStencil, 0);</span>
<span class="line-modified">144             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::STENCIL_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, depthStencil, 0);</span>
<span class="line-modified">145             if (context-&gt;checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER) != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {</span>
146                 ok = false;
147                 break;
148             }
<a name="25" id="anc25"></a><span class="line-modified">149             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::DEPTH_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, 0, 0);</span>
<span class="line-modified">150             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::STENCIL_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, 0, 0);</span>
151         }
152     }
153 
154     webglContext.restoreCurrentFramebuffer();
155     context-&gt;deleteFramebuffer(fbo);
156     webglContext.restoreCurrentTexture2D();
157     if (supportsDepth)
158         context-&gt;deleteTexture(depth);
159     if (supportsDepthStencil)
160         context-&gt;deleteTexture(depthStencil);
161     for (auto&amp; color : colors)
162         context-&gt;deleteTexture(color);
163     return ok;
164 }
165 
166 } // namespace WebCore
167 
168 #endif // ENABLE(WEBGL)
<a name="26" id="anc26"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="26" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/SpeculatedType.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #pragma once
 30 
 31 #include &quot;CPU.h&quot;
 32 #include &quot;JSCJSValue.h&quot;
 33 #include &quot;TypedArrayType.h&quot;
 34 #include &lt;wtf/PrintStream.h&gt;
 35 
 36 namespace JSC {
 37 
 38 class Structure;
 39 
 40 typedef uint64_t SpeculatedType;
 41 static constexpr SpeculatedType SpecNone                              = 0; // We don&#39;t know anything yet.
 42 static constexpr SpeculatedType SpecFinalObject                       = 1ull &lt;&lt; 0; // It&#39;s definitely a JSFinalObject.
 43 static constexpr SpeculatedType SpecArray                             = 1ull &lt;&lt; 1; // It&#39;s definitely a JSArray.
 44 static constexpr SpeculatedType SpecFunctionWithDefaultHasInstance    = 1ull &lt;&lt; 2; // It&#39;s definitely a JSFunction that has its ImplementsDefaultHasInstance type info flags bit set.
 45 static constexpr SpeculatedType SpecFunctionWithNonDefaultHasInstance = 1ull &lt;&lt; 3; // It&#39;s definitely a JSFunction that does not have its ImplementsDefaultHasInstance type info flags bit set.
 46 static constexpr SpeculatedType SpecFunction                          = SpecFunctionWithDefaultHasInstance | SpecFunctionWithNonDefaultHasInstance; // It&#39;s definitely a JSFunction.
 47 static constexpr SpeculatedType SpecInt8Array                         = 1ull &lt;&lt; 4; // It&#39;s definitely an Int8Array or one of its subclasses.
 48 static constexpr SpeculatedType SpecInt16Array                        = 1ull &lt;&lt; 5; // It&#39;s definitely an Int16Array or one of its subclasses.
 49 static constexpr SpeculatedType SpecInt32Array                        = 1ull &lt;&lt; 6; // It&#39;s definitely an Int32Array or one of its subclasses.
 50 static constexpr SpeculatedType SpecUint8Array                        = 1ull &lt;&lt; 7; // It&#39;s definitely an Uint8Array or one of its subclasses.
 51 static constexpr SpeculatedType SpecUint8ClampedArray                 = 1ull &lt;&lt; 8; // It&#39;s definitely an Uint8ClampedArray or one of its subclasses.
 52 static constexpr SpeculatedType SpecUint16Array                       = 1ull &lt;&lt; 9; // It&#39;s definitely an Uint16Array or one of its subclasses.
 53 static constexpr SpeculatedType SpecUint32Array                       = 1ull &lt;&lt; 10; // It&#39;s definitely an Uint32Array or one of its subclasses.
 54 static constexpr SpeculatedType SpecFloat32Array                      = 1ull &lt;&lt; 11; // It&#39;s definitely an Uint16Array or one of its subclasses.
 55 static constexpr SpeculatedType SpecFloat64Array                      = 1ull &lt;&lt; 12; // It&#39;s definitely an Uint16Array or one of its subclasses.
 56 static constexpr SpeculatedType SpecTypedArrayView                    = SpecInt8Array | SpecInt16Array | SpecInt32Array | SpecUint8Array | SpecUint8ClampedArray | SpecUint16Array | SpecUint32Array | SpecFloat32Array | SpecFloat64Array;
 57 static constexpr SpeculatedType SpecDirectArguments                   = 1ull &lt;&lt; 13; // It&#39;s definitely a DirectArguments object.
 58 static constexpr SpeculatedType SpecScopedArguments                   = 1ull &lt;&lt; 14; // It&#39;s definitely a ScopedArguments object.
 59 static constexpr SpeculatedType SpecStringObject                      = 1ull &lt;&lt; 15; // It&#39;s definitely a StringObject.
 60 static constexpr SpeculatedType SpecRegExpObject                      = 1ull &lt;&lt; 16; // It&#39;s definitely a RegExpObject (and not any subclass of RegExpObject).
 61 static constexpr SpeculatedType SpecDateObject                        = 1ull &lt;&lt; 17; // It&#39;s definitely a Date object or one of its subclasses.
 62 static constexpr SpeculatedType SpecPromiseObject                     = 1ull &lt;&lt; 18; // It&#39;s definitely a Promise object or one of its subclasses.
 63 static constexpr SpeculatedType SpecMapObject                         = 1ull &lt;&lt; 19; // It&#39;s definitely a Map object or one of its subclasses.
 64 static constexpr SpeculatedType SpecSetObject                         = 1ull &lt;&lt; 20; // It&#39;s definitely a Set object or one of its subclasses.
 65 static constexpr SpeculatedType SpecWeakMapObject                     = 1ull &lt;&lt; 21; // It&#39;s definitely a WeakMap object or one of its subclasses.
 66 static constexpr SpeculatedType SpecWeakSetObject                     = 1ull &lt;&lt; 22; // It&#39;s definitely a WeakSet object or one of its subclasses.
 67 static constexpr SpeculatedType SpecProxyObject                       = 1ull &lt;&lt; 23; // It&#39;s definitely a Proxy object or one of its subclasses.
 68 static constexpr SpeculatedType SpecDerivedArray                      = 1ull &lt;&lt; 24; // It&#39;s definitely a DerivedArray object.
 69 static constexpr SpeculatedType SpecObjectOther                       = 1ull &lt;&lt; 25; // It&#39;s definitely an object but not JSFinalObject, JSArray, or JSFunction.
 70 static constexpr SpeculatedType SpecStringIdent                       = 1ull &lt;&lt; 26; // It&#39;s definitely a JSString, and it&#39;s an identifier.
 71 static constexpr SpeculatedType SpecStringVar                         = 1ull &lt;&lt; 27; // It&#39;s definitely a JSString, and it&#39;s not an identifier.
 72 static constexpr SpeculatedType SpecString                            = SpecStringIdent | SpecStringVar; // It&#39;s definitely a JSString.
 73 static constexpr SpeculatedType SpecSymbol                            = 1ull &lt;&lt; 28; // It&#39;s definitely a Symbol.
 74 static constexpr SpeculatedType SpecCellOther                         = 1ull &lt;&lt; 29; // It&#39;s definitely a JSCell but not a subclass of JSObject and definitely not a JSString, BigInt, or Symbol.
 75 static constexpr SpeculatedType SpecBoolInt32                         = 1ull &lt;&lt; 30; // It&#39;s definitely an Int32 with value 0 or 1.
 76 static constexpr SpeculatedType SpecNonBoolInt32                      = 1ull &lt;&lt; 31; // It&#39;s definitely an Int32 with value other than 0 or 1.
 77 static constexpr SpeculatedType SpecInt32Only                         = SpecBoolInt32 | SpecNonBoolInt32; // It&#39;s definitely an Int32.
 78 
 79 static constexpr SpeculatedType SpecInt32AsInt52                      = 1ull &lt;&lt; 32; // It&#39;s an Int52 and it can fit in an int32.
 80 static constexpr SpeculatedType SpecNonInt32AsInt52                   = 1ull &lt;&lt; 33; // It&#39;s an Int52 and it can&#39;t fit in an int32.
 81 static constexpr SpeculatedType SpecInt52Any                          = SpecInt32AsInt52 | SpecNonInt32AsInt52; // It&#39;s any kind of Int52.
 82 
 83 static constexpr SpeculatedType SpecAnyIntAsDouble                    = 1ull &lt;&lt; 34; // It&#39;s definitely an Int52 and it&#39;s inside a double.
 84 static constexpr SpeculatedType SpecNonIntAsDouble                    = 1ull &lt;&lt; 35; // It&#39;s definitely not an Int52 but it&#39;s a real number and it&#39;s a double.
 85 static constexpr SpeculatedType SpecDoubleReal                        = SpecNonIntAsDouble | SpecAnyIntAsDouble; // It&#39;s definitely a non-NaN double.
 86 static constexpr SpeculatedType SpecDoublePureNaN                     = 1ull &lt;&lt; 36; // It&#39;s definitely a NaN that is safe to tag (i.e. pure).
 87 static constexpr SpeculatedType SpecDoubleImpureNaN                   = 1ull &lt;&lt; 37; // It&#39;s definitely a NaN that is unsafe to tag (i.e. impure).
 88 static constexpr SpeculatedType SpecDoubleNaN                         = SpecDoublePureNaN | SpecDoubleImpureNaN; // It&#39;s definitely some kind of NaN.
 89 static constexpr SpeculatedType SpecBytecodeDouble                    = SpecDoubleReal | SpecDoublePureNaN; // It&#39;s either a non-NaN or a NaN double, but it&#39;s definitely not impure NaN.
 90 static constexpr SpeculatedType SpecFullDouble                        = SpecDoubleReal | SpecDoubleNaN; // It&#39;s either a non-NaN or a NaN double.
 91 static constexpr SpeculatedType SpecBytecodeRealNumber                = SpecInt32Only | SpecDoubleReal; // It&#39;s either an Int32 or a DoubleReal.
 92 static constexpr SpeculatedType SpecFullRealNumber                    = SpecInt32Only | SpecInt52Any | SpecDoubleReal; // It&#39;s either an Int32 or a DoubleReal, or an Int52.
 93 static constexpr SpeculatedType SpecBytecodeNumber                    = SpecInt32Only | SpecBytecodeDouble; // It&#39;s either an Int32 or a Double, and the Double cannot be an impure NaN.
 94 static constexpr SpeculatedType SpecIntAnyFormat                      = SpecInt52Any | SpecInt32Only | SpecAnyIntAsDouble;
 95 
 96 static constexpr SpeculatedType SpecFullNumber                        = SpecIntAnyFormat | SpecFullDouble; // It&#39;s either an Int32, Int52, or a Double, and the Double can be impure NaN.
 97 static constexpr SpeculatedType SpecBoolean                           = 1ull &lt;&lt; 38; // It&#39;s definitely a Boolean.
 98 static constexpr SpeculatedType SpecOther                             = 1ull &lt;&lt; 39; // It&#39;s definitely either Null or Undefined.
 99 static constexpr SpeculatedType SpecMisc                              = SpecBoolean | SpecOther; // It&#39;s definitely either a boolean, Null, or Undefined.
100 static constexpr SpeculatedType SpecEmpty                             = 1ull &lt;&lt; 40; // It&#39;s definitely an empty value marker.
101 static constexpr SpeculatedType SpecBigInt                            = 1ull &lt;&lt; 41; // It&#39;s definitely a BigInt.
102 static constexpr SpeculatedType SpecDataViewObject                    = 1ull &lt;&lt; 42; // It&#39;s definitely a JSDataView.
103 static constexpr SpeculatedType SpecPrimitive                         = SpecString | SpecSymbol | SpecBytecodeNumber | SpecMisc | SpecBigInt; // It&#39;s any non-Object JSValue.
104 static constexpr SpeculatedType SpecObject                            = SpecFinalObject | SpecArray | SpecFunction | SpecTypedArrayView | SpecDirectArguments | SpecScopedArguments | SpecStringObject | SpecRegExpObject | SpecDateObject | SpecPromiseObject | SpecMapObject | SpecSetObject | SpecWeakMapObject | SpecWeakSetObject | SpecProxyObject | SpecDerivedArray | SpecObjectOther | SpecDataViewObject; // Bitmask used for testing for any kind of object prediction.
105 static constexpr SpeculatedType SpecCell                              = SpecObject | SpecString | SpecSymbol | SpecCellOther | SpecBigInt; // It&#39;s definitely a JSCell.
106 static constexpr SpeculatedType SpecHeapTop                           = SpecCell | SpecBytecodeNumber | SpecMisc; // It can be any of the above, except for SpecInt52Only and SpecDoubleImpureNaN.
107 static constexpr SpeculatedType SpecBytecodeTop                       = SpecHeapTop | SpecEmpty; // It can be any of the above, except for SpecInt52Only and SpecDoubleImpureNaN. Corresponds to what could be found in a bytecode local.
108 static constexpr SpeculatedType SpecFullTop                           = SpecBytecodeTop | SpecFullNumber; // It can be anything that bytecode could see plus exotic encodings of numbers.
109 
110 // SpecCellCheck is the type set representing the values that can flow through a cell check.
111 // On 64-bit platforms, the empty value passes a cell check. Also, ~SpecCellCheck is the type
112 // set that representing the values that flow through when testing that something is not a cell.
113 static constexpr SpeculatedType SpecCellCheck          = is64Bit() ? (SpecCell | SpecEmpty) : SpecCell;
114 
115 typedef bool (*SpeculatedTypeChecker)(SpeculatedType);
116 
117 // Dummy prediction checker, only useful if someone insists on requiring a prediction checker.
118 inline bool isAnySpeculation(SpeculatedType)
119 {
120     return true;
121 }
122 
123 inline bool isCellSpeculation(SpeculatedType value)
124 {
125     return !!(value &amp; SpecCell) &amp;&amp; !(value &amp; ~SpecCell);
126 }
127 
128 inline bool isCellOrOtherSpeculation(SpeculatedType value)
129 {
130     return !!value &amp;&amp; !(value &amp; ~(SpecCell | SpecOther));
131 }
132 
133 inline bool isNotCellSpeculation(SpeculatedType value)
134 {
135     return !(value &amp; SpecCellCheck) &amp;&amp; value;
136 }
137 
138 inline bool isObjectSpeculation(SpeculatedType value)
139 {
140     return !!(value &amp; SpecObject) &amp;&amp; !(value &amp; ~SpecObject);
141 }
142 
143 inline bool isObjectOrOtherSpeculation(SpeculatedType value)
144 {
145     return !!(value &amp; (SpecObject | SpecOther)) &amp;&amp; !(value &amp; ~(SpecObject | SpecOther));
146 }
147 
148 inline bool isFinalObjectSpeculation(SpeculatedType value)
149 {
150     return value == SpecFinalObject;
151 }
152 
153 inline bool isFinalObjectOrOtherSpeculation(SpeculatedType value)
154 {
155     return !!(value &amp; (SpecFinalObject | SpecOther)) &amp;&amp; !(value &amp; ~(SpecFinalObject | SpecOther));
156 }
157 
158 inline bool isStringIdentSpeculation(SpeculatedType value)
159 {
160     return value == SpecStringIdent;
161 }
162 
163 inline bool isNotStringVarSpeculation(SpeculatedType value)
164 {
165     return !(value &amp; SpecStringVar);
166 }
167 
168 inline bool isStringSpeculation(SpeculatedType value)
169 {
170     return !!value &amp;&amp; (value &amp; SpecString) == value;
171 }
172 
173 inline bool isNotStringSpeculation(SpeculatedType value)
174 {
175     return value &amp;&amp; !(value &amp; SpecString);
176 }
177 
178 inline bool isStringOrOtherSpeculation(SpeculatedType value)
179 {
180     return !!value &amp;&amp; (value &amp; (SpecString | SpecOther)) == value;
181 }
182 
183 inline bool isSymbolSpeculation(SpeculatedType value)
184 {
185     return value == SpecSymbol;
186 }
187 
188 inline bool isBigIntSpeculation(SpeculatedType value)
189 {
190     return value == SpecBigInt;
191 }
192 
193 inline bool isArraySpeculation(SpeculatedType value)
194 {
195     return value == SpecArray;
196 }
197 
198 inline bool isFunctionSpeculation(SpeculatedType value)
199 {
200     return value == SpecFunction;
201 }
202 
203 inline bool isProxyObjectSpeculation(SpeculatedType value)
204 {
205     return value == SpecProxyObject;
206 }
207 
208 inline bool isDerivedArraySpeculation(SpeculatedType value)
209 {
210     return value == SpecDerivedArray;
211 }
212 
213 inline bool isInt8ArraySpeculation(SpeculatedType value)
214 {
215     return value == SpecInt8Array;
216 }
217 
218 inline bool isInt16ArraySpeculation(SpeculatedType value)
219 {
220     return value == SpecInt16Array;
221 }
222 
223 inline bool isInt32ArraySpeculation(SpeculatedType value)
224 {
225     return value == SpecInt32Array;
226 }
227 
228 inline bool isUint8ArraySpeculation(SpeculatedType value)
229 {
230     return value == SpecUint8Array;
231 }
232 
233 inline bool isUint8ClampedArraySpeculation(SpeculatedType value)
234 {
235     return value == SpecUint8ClampedArray;
236 }
237 
238 inline bool isUint16ArraySpeculation(SpeculatedType value)
239 {
240     return value == SpecUint16Array;
241 }
242 
243 inline bool isUint32ArraySpeculation(SpeculatedType value)
244 {
245     return value == SpecUint32Array;
246 }
247 
248 inline bool isFloat32ArraySpeculation(SpeculatedType value)
249 {
250     return value == SpecFloat32Array;
251 }
252 
253 inline bool isFloat64ArraySpeculation(SpeculatedType value)
254 {
255     return value == SpecFloat64Array;
256 }
257 
258 inline bool isDirectArgumentsSpeculation(SpeculatedType value)
259 {
260     return value == SpecDirectArguments;
261 }
262 
263 inline bool isScopedArgumentsSpeculation(SpeculatedType value)
264 {
265     return value == SpecScopedArguments;
266 }
267 
268 inline bool isActionableIntMutableArraySpeculation(SpeculatedType value)
269 {
270     return isInt8ArraySpeculation(value)
271         || isInt16ArraySpeculation(value)
272         || isInt32ArraySpeculation(value)
273         || isUint8ArraySpeculation(value)
274         || isUint8ClampedArraySpeculation(value)
275         || isUint16ArraySpeculation(value)
276         || isUint32ArraySpeculation(value);
277 }
278 
279 inline bool isActionableFloatMutableArraySpeculation(SpeculatedType value)
280 {
281     return isFloat32ArraySpeculation(value)
282         || isFloat64ArraySpeculation(value);
283 }
284 
285 inline bool isActionableTypedMutableArraySpeculation(SpeculatedType value)
286 {
287     return isActionableIntMutableArraySpeculation(value)
288         || isActionableFloatMutableArraySpeculation(value);
289 }
290 
291 inline bool isActionableMutableArraySpeculation(SpeculatedType value)
292 {
293     return isArraySpeculation(value)
294         || isActionableTypedMutableArraySpeculation(value);
295 }
296 
297 inline bool isActionableArraySpeculation(SpeculatedType value)
298 {
299     return isStringSpeculation(value)
300         || isDirectArgumentsSpeculation(value)
301         || isScopedArgumentsSpeculation(value)
302         || isActionableMutableArraySpeculation(value);
303 }
304 
305 inline bool isArrayOrOtherSpeculation(SpeculatedType value)
306 {
307     return !!(value &amp; (SpecArray | SpecOther)) &amp;&amp; !(value &amp; ~(SpecArray | SpecOther));
308 }
309 
310 inline bool isStringObjectSpeculation(SpeculatedType value)
311 {
312     return value == SpecStringObject;
313 }
314 
315 inline bool isStringOrStringObjectSpeculation(SpeculatedType value)
316 {
317     return !!value &amp;&amp; !(value &amp; ~(SpecString | SpecStringObject));
318 }
319 
320 inline bool isRegExpObjectSpeculation(SpeculatedType value)
321 {
322     return value == SpecRegExpObject;
323 }
324 
325 inline bool isBoolInt32Speculation(SpeculatedType value)
326 {
327     return value == SpecBoolInt32;
328 }
329 
330 inline bool isInt32Speculation(SpeculatedType value)
331 {
332     return value &amp;&amp; !(value &amp; ~SpecInt32Only);
333 }
334 
335 inline bool isNotInt32Speculation(SpeculatedType value)
336 {
337     return value &amp;&amp; !(value &amp; SpecInt32Only);
338 }
339 
340 inline bool isInt32OrBooleanSpeculation(SpeculatedType value)
341 {
342     return value &amp;&amp; !(value &amp; ~(SpecBoolean | SpecInt32Only));
343 }
344 
345 inline bool isInt32SpeculationForArithmetic(SpeculatedType value)
346 {
347     return !(value &amp; (SpecFullDouble | SpecNonInt32AsInt52 | SpecBigInt));
348 }
349 
350 inline bool isInt32OrBooleanSpeculationForArithmetic(SpeculatedType value)
351 {
352     return !(value &amp; (SpecFullDouble | SpecNonInt32AsInt52 | SpecBigInt));
353 }
354 
355 inline bool isInt32OrBooleanSpeculationExpectingDefined(SpeculatedType value)
356 {
357     return isInt32OrBooleanSpeculation(value &amp; ~SpecOther);
358 }
359 
360 inline bool isAnyInt52Speculation(SpeculatedType value)
361 {
362     return !!value &amp;&amp; (value &amp; SpecInt52Any) == value;
363 }
364 
365 inline bool isInt32OrInt52Speculation(SpeculatedType value)
366 {
367     return !!value &amp;&amp; (value &amp; (SpecInt32Only | SpecInt52Any)) == value;
368 }
369 
370 inline bool isIntAnyFormat(SpeculatedType value)
371 {
372     return !!value &amp;&amp; (value &amp; SpecIntAnyFormat) == value;
373 }
374 
375 inline bool isAnyIntAsDoubleSpeculation(SpeculatedType value)
376 {
377     return value == SpecAnyIntAsDouble;
378 }
379 
380 inline bool isDoubleRealSpeculation(SpeculatedType value)
381 {
382     return !!value &amp;&amp; (value &amp; SpecDoubleReal) == value;
383 }
384 
385 inline bool isDoubleSpeculation(SpeculatedType value)
386 {
387     return !!value &amp;&amp; (value &amp; SpecFullDouble) == value;
388 }
389 
390 inline bool isDoubleSpeculationForArithmetic(SpeculatedType value)
391 {
392     return !!(value &amp; SpecFullDouble);
393 }
394 
395 inline bool isBytecodeRealNumberSpeculation(SpeculatedType value)
396 {
397     return !!(value &amp; SpecBytecodeRealNumber) &amp;&amp; !(value &amp; ~SpecBytecodeRealNumber);
398 }
399 
400 inline bool isFullRealNumberSpeculation(SpeculatedType value)
401 {
402     return !!(value &amp; SpecFullRealNumber) &amp;&amp; !(value &amp; ~SpecFullRealNumber);
403 }
404 
405 inline bool isBytecodeNumberSpeculation(SpeculatedType value)
406 {
407     return !!(value &amp; SpecBytecodeNumber) &amp;&amp; !(value &amp; ~SpecBytecodeNumber);
408 }
409 
410 inline bool isFullNumberSpeculation(SpeculatedType value)
411 {
412     return !!(value &amp; SpecFullNumber) &amp;&amp; !(value &amp; ~SpecFullNumber);
413 }
414 
415 inline bool isFullNumberOrBooleanSpeculation(SpeculatedType value)
416 {
417     return value &amp;&amp; !(value &amp; ~(SpecFullNumber | SpecBoolean));
418 }
419 
420 inline bool isFullNumberOrBooleanSpeculationExpectingDefined(SpeculatedType value)
421 {
422     return isFullNumberOrBooleanSpeculation(value &amp; ~SpecOther);
423 }
424 
425 inline bool isBooleanSpeculation(SpeculatedType value)
426 {
427     return value == SpecBoolean;
428 }
429 
430 inline bool isNotBooleanSpeculation(SpeculatedType value)
431 {
432     return value &amp;&amp; !(value &amp; SpecBoolean);
433 }
434 
435 inline bool isOtherSpeculation(SpeculatedType value)
436 {
437     return value == SpecOther;
438 }
439 
440 inline bool isMiscSpeculation(SpeculatedType value)
441 {
442     return !!value &amp;&amp; !(value &amp; ~SpecMisc);
443 }
444 
445 inline bool isOtherOrEmptySpeculation(SpeculatedType value)
446 {
447     return !value || value == SpecOther;
448 }
449 
450 inline bool isEmptySpeculation(SpeculatedType value)
451 {
452     return value == SpecEmpty;
453 }
454 
455 inline bool isUntypedSpeculationForArithmetic(SpeculatedType value)
456 {
457     return !!(value &amp; ~(SpecFullNumber | SpecBoolean));
458 }
459 
460 inline bool isUntypedSpeculationForBitOps(SpeculatedType value)
461 {
462     return !!(value &amp; ~(SpecFullNumber | SpecBoolean | SpecOther));
463 }
464 
465 void dumpSpeculation(PrintStream&amp;, SpeculatedType);
466 void dumpSpeculationAbbreviated(PrintStream&amp;, SpeculatedType);
467 
468 MAKE_PRINT_ADAPTOR(SpeculationDump, SpeculatedType, dumpSpeculation);
469 MAKE_PRINT_ADAPTOR(AbbreviatedSpeculationDump, SpeculatedType, dumpSpeculationAbbreviated);
470 
471 // Merge two predictions. Note that currently this just does left | right. It may
472 // seem tempting to do so directly, but you would be doing so at your own peril,
473 // since the merging protocol SpeculatedType may change at any time (and has already
474 // changed several times in its history).
475 inline SpeculatedType mergeSpeculations(SpeculatedType left, SpeculatedType right)
476 {
477     return left | right;
478 }
479 
480 template&lt;typename T&gt;
481 inline bool mergeSpeculation(T&amp; left, SpeculatedType right)
482 {
483     SpeculatedType newSpeculation = static_cast&lt;T&gt;(mergeSpeculations(static_cast&lt;SpeculatedType&gt;(left), right));
484     bool result = newSpeculation != static_cast&lt;SpeculatedType&gt;(left);
485     left = newSpeculation;
486     return result;
487 }
488 
489 inline bool speculationChecked(SpeculatedType actual, SpeculatedType desired)
490 {
491     return (actual | desired) == desired;
492 }
493 
494 SpeculatedType speculationFromClassInfo(const ClassInfo*);
495 SpeculatedType speculationFromStructure(Structure*);
496 SpeculatedType speculationFromCell(JSCell*);
497 JS_EXPORT_PRIVATE SpeculatedType speculationFromValue(JSValue);
498 // If it&#39;s an anyInt(), it&#39;ll return speculated types from the Int52 lattice.
499 // Otherwise, it&#39;ll return types from the JSValue lattice.
500 JS_EXPORT_PRIVATE SpeculatedType int52AwareSpeculationFromValue(JSValue);
501 Optional&lt;SpeculatedType&gt; speculationFromJSType(JSType);
502 
503 SpeculatedType speculationFromTypedArrayType(TypedArrayType); // only valid for typed views.
504 TypedArrayType typedArrayTypeFromSpeculation(SpeculatedType);
505 
506 SpeculatedType leastUpperBoundOfStrictlyEquivalentSpeculations(SpeculatedType);
507 
508 bool valuesCouldBeEqual(SpeculatedType, SpeculatedType);
509 
510 // Precise computation of the type of the result of a double computation after we
511 // already know that the inputs are doubles and that the result must be a double. Use
512 // the closest one of these that applies.
513 SpeculatedType typeOfDoubleSum(SpeculatedType, SpeculatedType);
514 SpeculatedType typeOfDoubleDifference(SpeculatedType, SpeculatedType);
515 SpeculatedType typeOfDoubleIncOrDec(SpeculatedType);
516 SpeculatedType typeOfDoubleProduct(SpeculatedType, SpeculatedType);
517 SpeculatedType typeOfDoubleQuotient(SpeculatedType, SpeculatedType);
518 SpeculatedType typeOfDoubleMinMax(SpeculatedType, SpeculatedType);
519 SpeculatedType typeOfDoubleNegation(SpeculatedType);
520 SpeculatedType typeOfDoubleAbs(SpeculatedType);
521 SpeculatedType typeOfDoubleRounding(SpeculatedType);
522 SpeculatedType typeOfDoublePow(SpeculatedType, SpeculatedType);
523 
524 // This conservatively models the behavior of arbitrary double operations.
525 SpeculatedType typeOfDoubleBinaryOp(SpeculatedType, SpeculatedType);
526 SpeculatedType typeOfDoubleUnaryOp(SpeculatedType);
527 
528 // This is mostly for debugging so we can fill profiles from strings.
529 SpeculatedType speculationFromString(const char*);
530 
531 } // namespace JSC
    </pre>
  </body>
</html>
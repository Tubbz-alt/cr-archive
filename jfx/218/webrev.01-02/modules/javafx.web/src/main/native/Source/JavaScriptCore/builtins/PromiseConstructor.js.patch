diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/PromiseConstructor.js b/modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/PromiseConstructor.js
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/PromiseConstructor.js
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/PromiseConstructor.js
@@ -37,11 +37,11 @@
     var remainingElementsCount = 1;
 
     function newResolveElement(index)
     {
         var alreadyCalled = false;
-        return function @resolve(argument)
+        return function (argument)
         {
             if (alreadyCalled)
                 return @undefined;
             alreadyCalled = true;
 
@@ -94,51 +94,49 @@
 
     function newResolveRejectElements(index)
     {
         var alreadyCalled = false;
 
-        var resolveElement = function @resolve(x)
-        {
-            if (alreadyCalled)
-                return @undefined;
-            alreadyCalled = true;
-
-            var obj = {
-                status: "fulfilled",
-                value: x
-            };
+        return [
+            function (value) {
+                if (alreadyCalled)
+                    return @undefined;
+                alreadyCalled = true;
 
-            @putByValDirect(values, index, obj);
+                var obj = {
+                    status: "fulfilled",
+                    value
+                };
 
-            --remainingElementsCount;
-            if (remainingElementsCount === 0)
-                return promiseCapability.@resolve.@call(@undefined, values);
+                @putByValDirect(values, index, obj);
 
-            return @undefined;
-        };
+                --remainingElementsCount;
+                if (remainingElementsCount === 0)
+                    return promiseCapability.@resolve.@call(@undefined, values);
 
-        var rejectElement = function @reject(x)
-        {
-            if (alreadyCalled)
                 return @undefined;
-            alreadyCalled = true;
+            },
 
-            var obj = {
-                status: "rejected",
-                reason: x
-            };
+            function (reason) {
+                if (alreadyCalled)
+                    return @undefined;
+                alreadyCalled = true;
 
-            @putByValDirect(values, index, obj);
+                var obj = {
+                    status: "rejected",
+                    reason
+                };
 
-            --remainingElementsCount;
-            if (remainingElementsCount === 0)
-                return promiseCapability.@resolve.@call(@undefined, values);
+                @putByValDirect(values, index, obj);
 
-            return @undefined;
-        };
+                --remainingElementsCount;
+                if (remainingElementsCount === 0)
+                    return promiseCapability.@resolve.@call(@undefined, values);
 
-        return [resolveElement, rejectElement];
+                return @undefined;
+            }
+        ];
     }
 
     try {
         var promiseResolve = this.resolve;
         if (typeof promiseResolve !== "function")
@@ -193,15 +191,17 @@
     "use strict";
 
     if (!@isObject(this))
         @throwTypeError("|this| is not an object");
 
-    var promiseCapability = @newPromiseCapability(this);
-
-    promiseCapability.@reject.@call(@undefined, reason);
+    if (this === @Promise) {
+        var promise = @newPromise();
+        @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, reason);
+        return promise;
+    }
 
-    return promiseCapability.@promise;
+    return @promiseRejectSlow(this, reason);
 }
 
 function resolve(value)
 {
     "use strict";
@@ -213,11 +213,65 @@
         var valueConstructor = value.constructor;
         if (valueConstructor === this)
             return value;
     }
 
-    var promiseCapability = @newPromiseCapability(this);
+    if (this === @Promise) {
+        var promise = @newPromise();
+        @resolvePromiseWithFirstResolvingFunctionCallCheck(promise, value);
+        return promise;
+    }
 
-    promiseCapability.@resolve.@call(@undefined, value);
+    return @promiseResolveSlow(this, value);
+}
 
-    return promiseCapability.@promise;
+@nakedConstructor
+function Promise(executor)
+{
+    "use strict";
+
+    if (typeof executor !== "function")
+        @throwTypeError("Promise constructor takes a function argument");
+
+    var promise = @createPromise(this, /* isInternalPromise */ false);
+    var capturedPromise = promise;
+
+    try {
+        executor(
+            function (resolution) {
+                return @resolvePromiseWithFirstResolvingFunctionCallCheck(capturedPromise, resolution);
+            },
+            function (reason) {
+                return @rejectPromiseWithFirstResolvingFunctionCallCheck(capturedPromise, reason);
+            });
+    } catch (error) {
+        @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, error);
+    }
+
+    return promise;
+}
+
+@nakedConstructor
+function InternalPromise(executor)
+{
+    "use strict";
+
+    if (typeof executor !== "function")
+        @throwTypeError("InternalPromise constructor takes a function argument");
+
+    var promise = @createPromise(this, /* isInternalPromise */ true);
+    var capturedPromise = promise;
+
+    try {
+        executor(
+            function (resolution) {
+                return @resolvePromiseWithFirstResolvingFunctionCallCheck(capturedPromise, resolution);
+            },
+            function (reason) {
+                return @rejectPromiseWithFirstResolvingFunctionCallCheck(capturedPromise, reason);
+            });
+    } catch (error) {
+        @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, error);
+    }
+
+    return promise;
 }

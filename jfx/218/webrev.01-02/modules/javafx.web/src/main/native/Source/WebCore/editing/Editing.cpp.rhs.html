<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/editing/Editing.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2004-2007, 2016 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;Editing.h&quot;
  28 
  29 #include &quot;AXObjectCache.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  30 #include &quot;CachedImage.h&quot;</span>
  31 #include &quot;Document.h&quot;
  32 #include &quot;Editor.h&quot;
  33 #include &quot;Frame.h&quot;
  34 #include &quot;HTMLBodyElement.h&quot;
  35 #include &quot;HTMLDListElement.h&quot;
  36 #include &quot;HTMLDivElement.h&quot;
  37 #include &quot;HTMLElementFactory.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  38 #include &quot;HTMLImageElement.h&quot;</span>
  39 #include &quot;HTMLInterchange.h&quot;
  40 #include &quot;HTMLLIElement.h&quot;
  41 #include &quot;HTMLNames.h&quot;
  42 #include &quot;HTMLOListElement.h&quot;
  43 #include &quot;HTMLParagraphElement.h&quot;
  44 #include &quot;HTMLSpanElement.h&quot;
  45 #include &quot;HTMLTableElement.h&quot;
  46 #include &quot;HTMLTextFormControlElement.h&quot;
  47 #include &quot;HTMLUListElement.h&quot;
  48 #include &quot;NodeTraversal.h&quot;
  49 #include &quot;PositionIterator.h&quot;
  50 #include &quot;RenderBlock.h&quot;
  51 #include &quot;RenderElement.h&quot;
  52 #include &quot;RenderTableCell.h&quot;
  53 #include &quot;ShadowRoot.h&quot;
  54 #include &quot;Text.h&quot;
  55 #include &quot;TextIterator.h&quot;
  56 #include &quot;VisibleUnits.h&quot;
  57 #include &lt;wtf/Assertions.h&gt;
  58 #include &lt;wtf/StdLibExtras.h&gt;
  59 #include &lt;wtf/text/StringBuilder.h&gt;
  60 #include &lt;wtf/unicode/CharacterNames.h&gt;
  61 
  62 namespace WebCore {
  63 
  64 using namespace HTMLNames;
  65 
  66 static bool isVisiblyAdjacent(const Position&amp;, const Position&amp;);
  67 
  68 bool canHaveChildrenForEditing(const Node&amp; node)
  69 {
  70     return !is&lt;Text&gt;(node) &amp;&amp; node.canContainRangeEndPoint();
  71 }
  72 
  73 // Atomic means that the node has no children, or has children which are ignored for the purposes of editing.
  74 bool isAtomicNode(const Node* node)
  75 {
  76     return node &amp;&amp; (!node-&gt;hasChildNodes() || editingIgnoresContent(*node));
  77 }
  78 
  79 // Compare two positions, taking into account the possibility that one or both
  80 // could be inside a shadow tree. Only works for non-null values.
  81 int comparePositions(const Position&amp; a, const Position&amp; b)
  82 {
  83     TreeScope* commonScope = commonTreeScope(a.containerNode(), b.containerNode());
  84 
  85     if (!commonScope)
  86         return 0;
  87 
  88     Node* nodeA = commonScope-&gt;ancestorNodeInThisScope(a.containerNode());
  89     ASSERT(nodeA);
  90     bool hasDescendentA = nodeA != a.containerNode();
  91     int offsetA = hasDescendentA ? 0 : a.computeOffsetInContainerNode();
  92 
  93     Node* nodeB = commonScope-&gt;ancestorNodeInThisScope(b.containerNode());
  94     ASSERT(nodeB);
  95     bool hasDescendentB = nodeB != b.containerNode();
  96     int offsetB = hasDescendentB ? 0 : b.computeOffsetInContainerNode();
  97 
  98     int bias = 0;
  99     if (nodeA == nodeB) {
 100         if (hasDescendentA)
 101             bias = -1;
 102         else if (hasDescendentB)
 103             bias = 1;
 104     }
 105 
 106     auto comparisonResult = Range::compareBoundaryPoints(nodeA, offsetA, nodeB, offsetB);
 107     if (comparisonResult.hasException())
 108         return bias;
 109     auto result = comparisonResult.releaseReturnValue();
 110     return result ? result : bias;
 111 }
 112 
 113 int comparePositions(const VisiblePosition&amp; a, const VisiblePosition&amp; b)
 114 {
 115     return comparePositions(a.deepEquivalent(), b.deepEquivalent());
 116 }
 117 
 118 ContainerNode* highestEditableRoot(const Position&amp; position, EditableType editableType)
 119 {
 120     ContainerNode* highestEditableRoot = editableRootForPosition(position, editableType);
 121     if (!highestEditableRoot)
 122         return nullptr;
 123 
 124     for (ContainerNode* node = highestEditableRoot; !is&lt;HTMLBodyElement&gt;(*node); ) {
 125         node = node-&gt;parentNode();
 126         if (!node)
 127             break;
 128         // FIXME: Can this ever be a Document or DocumentFragment? If not, this should return Element* instead.
 129         if (hasEditableStyle(*node, editableType))
 130             highestEditableRoot = node;
 131     }
 132 
 133     return highestEditableRoot;
 134 }
 135 
 136 Element* lowestEditableAncestor(Node* node)
 137 {
 138     for (; node; node = node-&gt;parentNode()) {
 139         if (node-&gt;hasEditableStyle())
 140             return node-&gt;rootEditableElement();
 141         if (is&lt;HTMLBodyElement&gt;(*node))
 142             break;
 143     }
 144     return nullptr;
 145 }
 146 
 147 static bool isEditableToAccessibility(const Node&amp; node)
 148 {
 149     ASSERT(AXObjectCache::accessibilityEnabled());
 150     ASSERT(node.document().existingAXObjectCache());
 151 
 152     if (auto* cache = node.document().existingAXObjectCache())
 153         return cache-&gt;rootAXEditableElement(&amp;node);
 154 
 155     return false;
 156 }
 157 
 158 static bool computeEditability(const Node&amp; node, EditableType editableType, Node::ShouldUpdateStyle shouldUpdateStyle)
 159 {
 160     if (node.computeEditability(Node::UserSelectAllIsAlwaysNonEditable, shouldUpdateStyle) != Node::Editability::ReadOnly)
 161         return true;
 162 
 163     switch (editableType) {
 164     case ContentIsEditable:
 165         return false;
 166     case HasEditableAXRole:
 167         return isEditableToAccessibility(node);
 168     }
 169     ASSERT_NOT_REACHED();
 170     return false;
 171 }
 172 
 173 bool hasEditableStyle(const Node&amp; node, EditableType editableType)
 174 {
 175     return computeEditability(node, editableType, Node::ShouldUpdateStyle::DoNotUpdate);
 176 }
 177 
 178 bool isEditableNode(const Node&amp; node)
 179 {
 180     return computeEditability(node, ContentIsEditable, Node::ShouldUpdateStyle::Update);
 181 }
 182 
 183 bool isEditablePosition(const Position&amp; position, EditableType editableType)
 184 {
 185     Node* node = position.containerNode();
 186     return node &amp;&amp; computeEditability(*node, editableType, Node::ShouldUpdateStyle::Update);
 187 }
 188 
 189 bool isAtUnsplittableElement(const Position&amp; position)
 190 {
 191     Node* node = position.containerNode();
 192     return node == editableRootForPosition(position) || node == enclosingNodeOfType(position, isTableCell);
 193 }
 194 
 195 bool isRichlyEditablePosition(const Position&amp; position)
 196 {
 197     auto* node = position.containerNode();
 198     return node &amp;&amp; node-&gt;hasRichlyEditableStyle();
 199 }
 200 
 201 Element* editableRootForPosition(const Position&amp; position, EditableType editableType)
 202 {
 203     Node* node = position.containerNode();
 204     if (!node)
 205         return nullptr;
 206 
 207     switch (editableType) {
 208     case HasEditableAXRole:
 209         if (auto* cache = node-&gt;document().existingAXObjectCache())
 210             return const_cast&lt;Element*&gt;(cache-&gt;rootAXEditableElement(node));
 211         FALLTHROUGH;
 212     case ContentIsEditable:
 213         return node-&gt;rootEditableElement();
 214     }
 215     return nullptr;
 216 }
 217 
 218 // Finds the enclosing element until which the tree can be split.
 219 // When a user hits ENTER, he/she won&#39;t expect this element to be split into two.
 220 // You may pass it as the second argument of splitTreeToNode.
 221 Element* unsplittableElementForPosition(const Position&amp; position)
 222 {
 223     // Since enclosingNodeOfType won&#39;t search beyond the highest root editable node,
 224     // this code works even if the closest table cell was outside of the root editable node.
 225     if (auto* enclosingCell = downcast&lt;Element&gt;(enclosingNodeOfType(position, &amp;isTableCell)))
 226         return enclosingCell;
 227     return editableRootForPosition(position);
 228 }
 229 
 230 Position nextCandidate(const Position&amp; position)
 231 {
 232     for (PositionIterator nextPosition = position; !nextPosition.atEnd(); ) {
 233         nextPosition.increment();
 234         if (nextPosition.isCandidate())
 235             return nextPosition;
 236     }
 237     return { };
 238 }
 239 
 240 Position nextVisuallyDistinctCandidate(const Position&amp; position)
 241 {
 242     // FIXME: Use PositionIterator instead.
 243     Position nextPosition = position;
 244     Position downstreamStart = nextPosition.downstream();
 245     while (!nextPosition.atEndOfTree()) {
 246         nextPosition = nextPosition.next(Character);
 247         if (nextPosition.isCandidate() &amp;&amp; nextPosition.downstream() != downstreamStart)
 248             return nextPosition;
 249         if (auto* node = nextPosition.containerNode()) {
 250             if (!node-&gt;renderer())
 251                 nextPosition = lastPositionInOrAfterNode(node);
 252         }
 253     }
 254     return { };
 255 }
 256 
 257 Position previousCandidate(const Position&amp; position)
 258 {
 259     PositionIterator previousPosition = position;
 260     while (!previousPosition.atStart()) {
 261         previousPosition.decrement();
 262         if (previousPosition.isCandidate())
 263             return previousPosition;
 264     }
 265     return { };
 266 }
 267 
 268 Position previousVisuallyDistinctCandidate(const Position&amp; position)
 269 {
 270     // FIXME: Use PositionIterator instead.
 271     Position previousPosition = position;
 272     Position downstreamStart = previousPosition.downstream();
 273     while (!previousPosition.atStartOfTree()) {
 274         previousPosition = previousPosition.previous(Character);
 275         if (previousPosition.isCandidate() &amp;&amp; previousPosition.downstream() != downstreamStart)
 276             return previousPosition;
 277         if (auto* node = previousPosition.containerNode()) {
 278             if (!node-&gt;renderer())
 279                 previousPosition = firstPositionInOrBeforeNode(node);
 280         }
 281     }
 282     return { };
 283 }
 284 
 285 Position firstEditablePositionAfterPositionInRoot(const Position&amp; position, ContainerNode* highestRoot)
 286 {
 287     if (!highestRoot)
 288         return { };
 289 
 290     // position falls before highestRoot.
 291     if (comparePositions(position, firstPositionInNode(highestRoot)) == -1 &amp;&amp; highestRoot-&gt;hasEditableStyle())
 292         return firstPositionInNode(highestRoot);
 293 
 294     Position candidate = position;
 295 
 296     if (&amp;position.deprecatedNode()-&gt;treeScope() != &amp;highestRoot-&gt;treeScope()) {
 297         auto* shadowAncestor = highestRoot-&gt;treeScope().ancestorNodeInThisScope(position.deprecatedNode());
 298         if (!shadowAncestor)
 299             return { };
 300 
 301         candidate = positionAfterNode(shadowAncestor);
 302     }
 303 
 304     while (candidate.deprecatedNode() &amp;&amp; !isEditablePosition(candidate) &amp;&amp; candidate.deprecatedNode()-&gt;isDescendantOf(*highestRoot))
 305         candidate = isAtomicNode(candidate.deprecatedNode()) ? positionInParentAfterNode(candidate.deprecatedNode()) : nextVisuallyDistinctCandidate(candidate);
 306 
 307     if (candidate.deprecatedNode() &amp;&amp; candidate.deprecatedNode() != highestRoot &amp;&amp; !candidate.deprecatedNode()-&gt;isDescendantOf(*highestRoot))
 308         return { };
 309 
 310     return candidate;
 311 }
 312 
 313 Position lastEditablePositionBeforePositionInRoot(const Position&amp; position, ContainerNode* highestRoot)
 314 {
 315     if (!highestRoot)
 316         return { };
 317 
 318     // When position falls after highestRoot, the result is easy to compute.
 319     if (comparePositions(position, lastPositionInNode(highestRoot)) == 1)
 320         return lastPositionInNode(highestRoot);
 321 
 322     Position candidate = position;
 323 
 324     if (&amp;position.deprecatedNode()-&gt;treeScope() != &amp;highestRoot-&gt;treeScope()) {
 325         auto* shadowAncestor = highestRoot-&gt;treeScope().ancestorNodeInThisScope(position.deprecatedNode());
 326         if (!shadowAncestor)
 327             return { };
 328 
 329         candidate = firstPositionInOrBeforeNode(shadowAncestor);
 330     }
 331 
 332     while (candidate.deprecatedNode() &amp;&amp; !isEditablePosition(candidate) &amp;&amp; candidate.deprecatedNode()-&gt;isDescendantOf(*highestRoot))
 333         candidate = isAtomicNode(candidate.deprecatedNode()) ? positionInParentBeforeNode(candidate.deprecatedNode()) : previousVisuallyDistinctCandidate(candidate);
 334 
 335     if (candidate.deprecatedNode() &amp;&amp; candidate.deprecatedNode() != highestRoot &amp;&amp; !candidate.deprecatedNode()-&gt;isDescendantOf(*highestRoot))
 336         return { };
 337 
 338     return candidate;
 339 }
 340 
 341 // FIXME: The function name, comment, and code say three different things here!
 342 // Whether or not content before and after this node will collapse onto the same line as it.
 343 bool isBlock(const Node* node)
 344 {
 345     return node &amp;&amp; node-&gt;renderer() &amp;&amp; !node-&gt;renderer()-&gt;isInline() &amp;&amp; !node-&gt;renderer()-&gt;isRubyText();
 346 }
 347 
 348 bool isInline(const Node* node)
 349 {
 350     return node &amp;&amp; node-&gt;renderer() &amp;&amp; node-&gt;renderer()-&gt;isInline();
 351 }
 352 
 353 // FIXME: Deploy this in all of the places where enclosingBlockFlow/enclosingBlockFlowOrTableElement are used.
 354 // FIXME: Pass a position to this function. The enclosing block of [table, x] for example, should be the
 355 // block that contains the table and not the table, and this function should be the only one responsible for
 356 // knowing about these kinds of special cases.
 357 Element* enclosingBlock(Node* node, EditingBoundaryCrossingRule rule)
 358 {
 359     Node* enclosingNode = enclosingNodeOfType(firstPositionInOrBeforeNode(node), isBlock, rule);
 360     return is&lt;Element&gt;(enclosingNode) ? downcast&lt;Element&gt;(enclosingNode) : nullptr;
 361 }
 362 
 363 TextDirection directionOfEnclosingBlock(const Position&amp; position)
 364 {
 365     auto block = enclosingBlock(position.containerNode());
 366     if (!block)
 367         return TextDirection::LTR;
 368     auto renderer = block-&gt;renderer();
 369     if (!renderer)
 370         return TextDirection::LTR;
 371     return renderer-&gt;style().direction();
 372 }
 373 
 374 // This method is used to create positions in the DOM. It returns the maximum valid offset
 375 // in a node. It returns 1 for some elements even though they do not have children, which
 376 // creates technically invalid DOM Positions. Be sure to call parentAnchoredEquivalent
 377 // on a Position before using it to create a DOM Range, or an exception will be thrown.
 378 int lastOffsetForEditing(const Node&amp; node)
 379 {
 380     if (node.isCharacterDataNode())
 381         return node.maxCharacterOffset();
 382 
 383     if (node.hasChildNodes())
 384         return node.countChildNodes();
 385 
 386     // NOTE: This should preempt the countChildNodes() for, e.g., select nodes.
 387     // FIXME: What does the comment above mean?
 388     if (editingIgnoresContent(node))
 389         return 1;
 390 
 391     return 0;
 392 }
 393 
 394 bool isAmbiguousBoundaryCharacter(UChar character)
 395 {
 396     // These are characters that can behave as word boundaries, but can appear within words.
 397     // If they are just typed, i.e. if they are immediately followed by a caret, we want to delay text checking until the next character has been typed.
 398     // FIXME: this is required until &lt;rdar://problem/6853027&gt; is fixed and text checking can do this for us.
 399     return character == &#39;\&#39;&#39; || character == &#39;@&#39; || character == rightSingleQuotationMark || character == hebrewPunctuationGershayim;
 400 }
 401 
 402 String stringWithRebalancedWhitespace(const String&amp; string, bool startIsStartOfParagraph, bool endIsEndOfParagraph)
 403 {
 404     StringBuilder rebalancedString;
 405 
 406     bool previousCharacterWasSpace = false;
 407     unsigned length = string.length();
 408     for (unsigned i = 0; i &lt; length; ++i) {
 409         auto character = string[i];
 410         if (!deprecatedIsEditingWhitespace(character)) {
 411             previousCharacterWasSpace = false;
 412             continue;
 413         }
 414         LChar selectedWhitespaceCharacter;
 415         if (previousCharacterWasSpace || (!i &amp;&amp; startIsStartOfParagraph) || (i == length - 1 &amp;&amp; endIsEndOfParagraph)) {
 416             selectedWhitespaceCharacter = noBreakSpace;
 417             previousCharacterWasSpace = false;
 418         } else {
 419             selectedWhitespaceCharacter = &#39; &#39;;
 420             previousCharacterWasSpace = true;
 421         }
 422         if (character == selectedWhitespaceCharacter)
 423             continue;
 424         rebalancedString.reserveCapacity(length);
 425         rebalancedString.appendSubstring(string, rebalancedString.length(), i - rebalancedString.length());
 426         rebalancedString.append(selectedWhitespaceCharacter);
 427     }
 428 
 429     if (rebalancedString.isEmpty())
 430         return string;
 431 
 432     rebalancedString.reserveCapacity(length);
 433     rebalancedString.appendSubstring(string, rebalancedString.length(), length - rebalancedString.length());
 434     return rebalancedString.toString();
 435 }
 436 
 437 bool isTableStructureNode(const Node* node)
 438 {
 439     auto* renderer = node-&gt;renderer();
 440     return renderer &amp;&amp; (renderer-&gt;isTableCell() || renderer-&gt;isTableRow() || renderer-&gt;isTableSection() || renderer-&gt;isRenderTableCol());
 441 }
 442 
 443 const String&amp; nonBreakingSpaceString()
 444 {
 445     static NeverDestroyed&lt;String&gt; nonBreakingSpaceString(&amp;noBreakSpace, 1);
 446     return nonBreakingSpaceString;
 447 }
 448 
 449 static bool isSpecialHTMLElement(const Node* node)
 450 {
 451     if (!is&lt;HTMLElement&gt;(node))
 452         return false;
 453 
 454     if (downcast&lt;HTMLElement&gt;(*node).isLink())
 455         return true;
 456 
 457     auto* renderer = downcast&lt;HTMLElement&gt;(*node).renderer();
 458     if (!renderer)
 459         return false;
 460 
 461     if (renderer-&gt;style().display() == DisplayType::Table || renderer-&gt;style().display() == DisplayType::InlineTable)
 462         return true;
 463 
 464     if (renderer-&gt;style().isFloating())
 465         return true;
 466 
 467     if (renderer-&gt;style().position() != PositionType::Static)
 468         return true;
 469 
 470     return false;
 471 }
 472 
 473 static HTMLElement* firstInSpecialElement(const Position&amp; position)
 474 {
 475     auto* rootEditableElement = position.containerNode()-&gt;rootEditableElement();
 476     for (Node* node = position.deprecatedNode(); node &amp;&amp; node-&gt;rootEditableElement() == rootEditableElement; node = node-&gt;parentNode()) {
 477         if (!isSpecialHTMLElement(node))
 478             continue;
 479         VisiblePosition vPos(position, DOWNSTREAM);
 480         VisiblePosition firstInElement(firstPositionInOrBeforeNode(node), DOWNSTREAM);
 481         if ((isRenderedTable(node) &amp;&amp; vPos == firstInElement.next()) || vPos == firstInElement)
 482             return &amp;downcast&lt;HTMLElement&gt;(*node);
 483     }
 484     return nullptr;
 485 }
 486 
 487 static HTMLElement* lastInSpecialElement(const Position&amp; position)
 488 {
 489     auto* rootEditableElement = position.containerNode()-&gt;rootEditableElement();
 490     for (Node* node = position.deprecatedNode(); node &amp;&amp; node-&gt;rootEditableElement() == rootEditableElement; node = node-&gt;parentNode()) {
 491         if (!isSpecialHTMLElement(node))
 492             continue;
 493         VisiblePosition vPos(position, DOWNSTREAM);
 494         VisiblePosition lastInElement(lastPositionInOrAfterNode(node), DOWNSTREAM);
 495         if ((isRenderedTable(node) &amp;&amp; vPos == lastInElement.previous()) || vPos == lastInElement)
 496             return &amp;downcast&lt;HTMLElement&gt;(*node);
 497     }
 498     return nullptr;
 499 }
 500 
 501 Position positionBeforeContainingSpecialElement(const Position&amp; position, HTMLElement** containingSpecialElement)
 502 {
 503     auto* element = firstInSpecialElement(position);
 504     if (!element)
 505         return position;
 506     Position result = positionInParentBeforeNode(element);
 507     if (result.isNull() || result.deprecatedNode()-&gt;rootEditableElement() != position.deprecatedNode()-&gt;rootEditableElement())
 508         return position;
 509     if (containingSpecialElement)
 510         *containingSpecialElement = element;
 511     return result;
 512 }
 513 
 514 Position positionAfterContainingSpecialElement(const Position&amp; position, HTMLElement** containingSpecialElement)
 515 {
 516     auto* element = lastInSpecialElement(position);
 517     if (!element)
 518         return position;
 519     Position result = positionInParentAfterNode(element);
 520     if (result.isNull() || result.deprecatedNode()-&gt;rootEditableElement() != position.deprecatedNode()-&gt;rootEditableElement())
 521         return position;
 522     if (containingSpecialElement)
 523         *containingSpecialElement = element;
 524     return result;
 525 }
 526 
 527 Element* isFirstPositionAfterTable(const VisiblePosition&amp; position)
 528 {
 529     Position upstream(position.deepEquivalent().upstream());
 530     auto* node = upstream.deprecatedNode();
 531     if (!node)
 532         return nullptr;
 533     auto* renderer = node-&gt;renderer();
 534     if (!renderer || !renderer-&gt;isTable() || !upstream.atLastEditingPositionForNode())
 535         return nullptr;
 536     return &amp;downcast&lt;Element&gt;(*node);
 537 }
 538 
 539 Element* isLastPositionBeforeTable(const VisiblePosition&amp; position)
 540 {
 541     Position downstream(position.deepEquivalent().downstream());
 542     auto* node = downstream.deprecatedNode();
 543     if (!node)
 544         return nullptr;
 545     auto* renderer = node-&gt;renderer();
 546     if (!renderer || !renderer-&gt;isTable() || !downstream.atFirstEditingPositionForNode())
 547         return nullptr;
 548     return &amp;downcast&lt;Element&gt;(*node);
 549 }
 550 
 551 // Returns the visible position at the beginning of a node
 552 VisiblePosition visiblePositionBeforeNode(Node&amp; node)
 553 {
 554     if (node.hasChildNodes())
 555         return VisiblePosition(firstPositionInOrBeforeNode(&amp;node), DOWNSTREAM);
 556     ASSERT(node.parentNode());
 557     ASSERT(!node.parentNode()-&gt;isShadowRoot());
 558     return positionInParentBeforeNode(&amp;node);
 559 }
 560 
 561 // Returns the visible position at the ending of a node
 562 VisiblePosition visiblePositionAfterNode(Node&amp; node)
 563 {
 564     if (node.hasChildNodes())
 565         return VisiblePosition(lastPositionInOrAfterNode(&amp;node), DOWNSTREAM);
 566     ASSERT(node.parentNode());
 567     ASSERT(!node.parentNode()-&gt;isShadowRoot());
 568     return positionInParentAfterNode(&amp;node);
 569 }
 570 
 571 bool isListHTMLElement(Node* node)
 572 {
 573     return node &amp;&amp; (is&lt;HTMLUListElement&gt;(*node) || is&lt;HTMLOListElement&gt;(*node) || is&lt;HTMLDListElement&gt;(*node));
 574 }
 575 
 576 bool isListItem(const Node* node)
 577 {
 578     return node &amp;&amp; (isListHTMLElement(node-&gt;parentNode()) || (node-&gt;renderer() &amp;&amp; node-&gt;renderer()-&gt;isListItem()));
 579 }
 580 
 581 Element* enclosingElementWithTag(const Position&amp; position, const QualifiedName&amp; tagName)
 582 {
 583     auto* root = highestEditableRoot(position);
 584     for (Node* node = position.deprecatedNode(); node; node = node-&gt;parentNode()) {
 585         if (root &amp;&amp; !node-&gt;hasEditableStyle())
 586             continue;
 587         if (!is&lt;Element&gt;(*node))
 588             continue;
 589         if (downcast&lt;Element&gt;(*node).hasTagName(tagName))
 590             return &amp;downcast&lt;Element&gt;(*node);
 591         if (node == root)
 592             return nullptr;
 593     }
 594     return nullptr;
 595 }
 596 
 597 Node* enclosingNodeOfType(const Position&amp; position, bool (*nodeIsOfType)(const Node*), EditingBoundaryCrossingRule rule)
 598 {
 599     // FIXME: support CanSkipCrossEditingBoundary
 600     ASSERT(rule == CanCrossEditingBoundary || rule == CannotCrossEditingBoundary);
 601     auto* root = rule == CannotCrossEditingBoundary ? highestEditableRoot(position) : nullptr;
 602     for (Node* n = position.deprecatedNode(); n; n = n-&gt;parentNode()) {
 603         // Don&#39;t return a non-editable node if the input position was editable, since
 604         // the callers from editing will no doubt want to perform editing inside the returned node.
 605         if (root &amp;&amp; !n-&gt;hasEditableStyle())
 606             continue;
 607         if (nodeIsOfType(n))
 608             return n;
 609         if (n == root)
 610             return nullptr;
 611     }
 612     return nullptr;
 613 }
 614 
 615 Node* highestEnclosingNodeOfType(const Position&amp; position, bool (*nodeIsOfType)(const Node*), EditingBoundaryCrossingRule rule, Node* stayWithin)
 616 {
 617     Node* highest = nullptr;
 618     auto* root = rule == CannotCrossEditingBoundary ? highestEditableRoot(position) : nullptr;
 619     for (Node* n = position.containerNode(); n &amp;&amp; n != stayWithin; n = n-&gt;parentNode()) {
 620         if (root &amp;&amp; !n-&gt;hasEditableStyle())
 621             continue;
 622         if (nodeIsOfType(n))
 623             highest = n;
 624         if (n == root)
 625             break;
 626     }
 627     return highest;
 628 }
 629 
 630 static bool hasARenderedDescendant(Node* node, Node* excludedNode)
 631 {
 632     for (Node* n = node-&gt;firstChild(); n;) {
 633         if (n == excludedNode) {
 634             n = NodeTraversal::nextSkippingChildren(*n, node);
 635             continue;
 636         }
 637         if (n-&gt;renderer())
 638             return true;
 639         n = NodeTraversal::next(*n, node);
 640     }
 641     return false;
 642 }
 643 
 644 Node* highestNodeToRemoveInPruning(Node* node)
 645 {
 646     Node* previousNode = nullptr;
 647     auto* rootEditableElement = node ? node-&gt;rootEditableElement() : nullptr;
 648     for (; node; node = node-&gt;parentNode()) {
 649         if (auto* renderer = node-&gt;renderer()) {
 650             if (!renderer-&gt;canHaveChildren() || hasARenderedDescendant(node, previousNode) || rootEditableElement == node)
 651                 return previousNode;
 652         }
 653         previousNode = node;
 654     }
 655     return nullptr;
 656 }
 657 
 658 Element* enclosingTableCell(const Position&amp; position)
 659 {
 660     return downcast&lt;Element&gt;(enclosingNodeOfType(position, isTableCell));
 661 }
 662 
 663 Element* enclosingAnchorElement(const Position&amp; p)
 664 {
 665     for (Node* node = p.deprecatedNode(); node; node = node-&gt;parentNode()) {
 666         if (is&lt;Element&gt;(*node) &amp;&amp; node-&gt;isLink())
 667             return downcast&lt;Element&gt;(node);
 668     }
 669     return nullptr;
 670 }
 671 
 672 HTMLElement* enclosingList(Node* node)
 673 {
 674     if (!node)
 675         return nullptr;
 676 
 677     auto* root = highestEditableRoot(firstPositionInOrBeforeNode(node));
 678 
 679     for (ContainerNode* ancestor = node-&gt;parentNode(); ancestor; ancestor = ancestor-&gt;parentNode()) {
 680         if (is&lt;HTMLUListElement&gt;(*ancestor) || is&lt;HTMLOListElement&gt;(*ancestor))
 681             return downcast&lt;HTMLElement&gt;(ancestor);
 682         if (ancestor == root)
 683             return nullptr;
 684     }
 685 
 686     return nullptr;
 687 }
 688 
 689 Node* enclosingListChild(Node *node)
 690 {
 691     if (!node)
 692         return nullptr;
 693 
 694     // Check for a list item element, or for a node whose parent is a list element. Such a node
 695     // will appear visually as a list item (but without a list marker)
 696     auto* root = highestEditableRoot(firstPositionInOrBeforeNode(node));
 697 
 698     // FIXME: This function is inappropriately named since it starts with node instead of node-&gt;parentNode()
 699     for (Node* n = node; n &amp;&amp; n-&gt;parentNode(); n = n-&gt;parentNode()) {
 700         if (is&lt;HTMLLIElement&gt;(*n) || (isListHTMLElement(n-&gt;parentNode()) &amp;&amp; n != root))
 701             return n;
 702         if (n == root || isTableCell(n))
 703             return nullptr;
 704     }
 705 
 706     return nullptr;
 707 }
 708 
 709 static HTMLElement* embeddedSublist(Node* listItem)
 710 {
 711     // Check the DOM so that we&#39;ll find collapsed sublists without renderers.
 712     for (Node* n = listItem-&gt;firstChild(); n; n = n-&gt;nextSibling()) {
 713         if (isListHTMLElement(n))
 714             return downcast&lt;HTMLElement&gt;(n);
 715     }
 716     return nullptr;
 717 }
 718 
 719 static Node* appendedSublist(Node* listItem)
 720 {
 721     // Check the DOM so that we&#39;ll find collapsed sublists without renderers.
 722     for (Node* n = listItem-&gt;nextSibling(); n; n = n-&gt;nextSibling()) {
 723         if (isListHTMLElement(n))
 724             return downcast&lt;HTMLElement&gt;(n);
 725         if (isListItem(listItem))
 726             return nullptr;
 727     }
 728 
 729     return nullptr;
 730 }
 731 
 732 // FIXME: This function should not need to call isStartOfParagraph/isEndOfParagraph.
 733 Node* enclosingEmptyListItem(const VisiblePosition&amp; position)
 734 {
 735     // Check that position is on a line by itself inside a list item
 736     auto* listChildNode = enclosingListChild(position.deepEquivalent().deprecatedNode());
 737     if (!listChildNode || !isStartOfParagraph(position) || !isEndOfParagraph(position))
 738         return nullptr;
 739 
 740     VisiblePosition firstInListChild(firstPositionInOrBeforeNode(listChildNode));
 741     VisiblePosition lastInListChild(lastPositionInOrAfterNode(listChildNode));
 742 
 743     if (firstInListChild != position || lastInListChild != position)
 744         return nullptr;
 745 
 746     if (embeddedSublist(listChildNode) || appendedSublist(listChildNode))
 747         return nullptr;
 748 
 749     return listChildNode;
 750 }
 751 
 752 HTMLElement* outermostEnclosingList(Node* node, Node* rootList)
 753 {
 754     auto* list = enclosingList(node);
 755     if (!list)
 756         return nullptr;
 757 
 758     while (auto* nextList = enclosingList(list)) {
 759         if (nextList == rootList)
 760             break;
 761         list = nextList;
 762     }
 763 
 764     return list;
 765 }
 766 
 767 bool canMergeLists(Element* firstList, Element* secondList)
 768 {
 769     if (!is&lt;HTMLElement&gt;(firstList) || !is&lt;HTMLElement&gt;(secondList))
 770         return false;
 771 
 772     auto&amp; first = downcast&lt;HTMLElement&gt;(*firstList);
 773     auto&amp; second = downcast&lt;HTMLElement&gt;(*secondList);
 774 
 775     return first.localName() == second.localName() // make sure the list types match (ol vs. ul)
 776         &amp;&amp; first.hasEditableStyle() &amp;&amp; second.hasEditableStyle() // both lists are editable
 777         &amp;&amp; first.rootEditableElement() == second.rootEditableElement() // don&#39;t cross editing boundaries
 778         // Make sure there is no visible content between this li and the previous list.
 779         &amp;&amp; isVisiblyAdjacent(positionInParentAfterNode(&amp;first), positionInParentBeforeNode(&amp;second));
 780 }
 781 
 782 static Node* previousNodeConsideringAtomicNodes(const Node* node)
 783 {
 784     if (node-&gt;previousSibling()) {
 785         Node* n = node-&gt;previousSibling();
 786         while (!isAtomicNode(n) &amp;&amp; n-&gt;lastChild())
 787             n = n-&gt;lastChild();
 788         return n;
 789     }
 790     if (node-&gt;parentNode())
 791         return node-&gt;parentNode();
 792     return nullptr;
 793 }
 794 
 795 static Node* nextNodeConsideringAtomicNodes(const Node* node)
 796 {
 797     if (!isAtomicNode(node) &amp;&amp; node-&gt;firstChild())
 798         return node-&gt;firstChild();
 799     if (node-&gt;nextSibling())
 800         return node-&gt;nextSibling();
 801     const Node* n = node;
 802     while (n &amp;&amp; !n-&gt;nextSibling())
 803         n = n-&gt;parentNode();
 804     if (n)
 805         return n-&gt;nextSibling();
 806     return nullptr;
 807 }
 808 
 809 Node* previousLeafNode(const Node* node)
 810 {
 811     while ((node = previousNodeConsideringAtomicNodes(node))) {
 812         if (isAtomicNode(node))
 813             return const_cast&lt;Node*&gt;(node);
 814     }
 815     return nullptr;
 816 }
 817 
 818 Node* nextLeafNode(const Node* node)
 819 {
 820     while ((node = nextNodeConsideringAtomicNodes(node))) {
 821         if (isAtomicNode(node))
 822             return const_cast&lt;Node*&gt;(node);
 823     }
 824     return nullptr;
 825 }
 826 
 827 // FIXME: Do not require renderer, so that this can be used within fragments.
 828 bool isRenderedTable(const Node* node)
 829 {
 830     if (!is&lt;Element&gt;(node))
 831         return false;
 832     auto* renderer = downcast&lt;Element&gt;(*node).renderer();
 833     return renderer &amp;&amp; renderer-&gt;isTable();
 834 }
 835 
 836 bool isTableCell(const Node* node)
 837 {
 838     auto* renderer = node-&gt;renderer();
 839     if (!renderer)
 840         return node-&gt;hasTagName(tdTag) || node-&gt;hasTagName(thTag);
 841     return renderer-&gt;isTableCell();
 842 }
 843 
 844 bool isEmptyTableCell(const Node* node)
 845 {
 846     // Returns true IFF the passed in node is one of:
 847     //   .) a table cell with no children,
 848     //   .) a table cell with a single BR child, and which has no other child renderers, including :before and :after renderers
 849     //   .) the BR child of such a table cell
 850 
 851     // Find rendered node
 852     while (node &amp;&amp; !node-&gt;renderer())
 853         node = node-&gt;parentNode();
 854     if (!node)
 855         return false;
 856 
 857     // Make sure the rendered node is a table cell or &lt;br&gt;.
 858     // If it&#39;s a &lt;br&gt;, then the parent node has to be a table cell.
 859     auto* renderer = node-&gt;renderer();
 860     if (renderer-&gt;isBR()) {
 861         renderer = renderer-&gt;parent();
 862         if (!renderer)
 863             return false;
 864     }
 865     if (!is&lt;RenderTableCell&gt;(*renderer))
 866         return false;
 867 
 868     // Check that the table cell contains no child renderers except for perhaps a single &lt;br&gt;.
 869     auto* childRenderer = downcast&lt;RenderTableCell&gt;(*renderer).firstChild();
 870     if (!childRenderer)
 871         return true;
 872     if (!childRenderer-&gt;isBR())
 873         return false;
 874     return !childRenderer-&gt;nextSibling();
 875 }
 876 
 877 Ref&lt;HTMLElement&gt; createDefaultParagraphElement(Document&amp; document)
 878 {
 879     switch (document.frame()-&gt;editor().defaultParagraphSeparator()) {
 880     case EditorParagraphSeparatorIsDiv:
 881         return HTMLDivElement::create(document);
 882     case EditorParagraphSeparatorIsP:
 883         break;
 884     }
 885     return HTMLParagraphElement::create(document);
 886 }
 887 
 888 Ref&lt;HTMLElement&gt; createHTMLElement(Document&amp; document, const QualifiedName&amp; name)
 889 {
 890     return HTMLElementFactory::createElement(name, document);
 891 }
 892 
 893 Ref&lt;HTMLElement&gt; createHTMLElement(Document&amp; document, const AtomString&amp; tagName)
 894 {
 895     return createHTMLElement(document, QualifiedName(nullAtom(), tagName, xhtmlNamespaceURI));
 896 }
 897 
 898 bool isTabSpanNode(const Node* node)
 899 {
 900     return is&lt;HTMLSpanElement&gt;(node) &amp;&amp; downcast&lt;HTMLSpanElement&gt;(*node).attributeWithoutSynchronization(classAttr) == AppleTabSpanClass;
 901 }
 902 
 903 bool isTabSpanTextNode(const Node* node)
 904 {
 905     return is&lt;Text&gt;(node) &amp;&amp; isTabSpanNode(node-&gt;parentNode());
 906 }
 907 
 908 HTMLSpanElement* tabSpanNode(const Node* node)
 909 {
 910     return isTabSpanTextNode(node) ? downcast&lt;HTMLSpanElement&gt;(node-&gt;parentNode()) : nullptr;
 911 }
 912 
 913 static Ref&lt;Element&gt; createTabSpanElement(Document&amp; document, Text&amp; tabTextNode)
 914 {
 915     auto spanElement = HTMLSpanElement::create(document);
 916 
 917     spanElement-&gt;setAttributeWithoutSynchronization(classAttr, AppleTabSpanClass);
 918     spanElement-&gt;setAttribute(styleAttr, &quot;white-space:pre&quot;);
 919 
 920     spanElement-&gt;appendChild(tabTextNode);
 921 
 922     return spanElement;
 923 }
 924 
 925 Ref&lt;Element&gt; createTabSpanElement(Document&amp; document, const String&amp; tabText)
 926 {
 927     return createTabSpanElement(document, document.createTextNode(tabText));
 928 }
 929 
 930 Ref&lt;Element&gt; createTabSpanElement(Document&amp; document)
 931 {
 932     return createTabSpanElement(document, document.createEditingTextNode(&quot;\t&quot;_s));
 933 }
 934 
 935 bool isNodeRendered(const Node&amp; node)
 936 {
 937     auto* renderer = node.renderer();
 938     return renderer &amp;&amp; renderer-&gt;style().visibility() == Visibility::Visible;
 939 }
 940 
 941 unsigned numEnclosingMailBlockquotes(const Position&amp; position)
 942 {
 943     unsigned count = 0;
 944     for (Node* node = position.deprecatedNode(); node; node = node-&gt;parentNode()) {
 945         if (isMailBlockquote(node))
 946             ++count;
 947     }
 948     return count;
 949 }
 950 
 951 void updatePositionForNodeRemoval(Position&amp; position, Node&amp; node)
 952 {
 953     if (position.isNull())
 954         return;
 955     switch (position.anchorType()) {
 956     case Position::PositionIsBeforeChildren:
 957         if (node.containsIncludingShadowDOM(position.containerNode()))
 958             position = positionInParentBeforeNode(&amp;node);
 959         break;
 960     case Position::PositionIsAfterChildren:
 961         if (node.containsIncludingShadowDOM(position.containerNode()))
 962             position = positionInParentBeforeNode(&amp;node);
 963         break;
 964     case Position::PositionIsOffsetInAnchor:
 965         if (position.containerNode() == node.parentNode() &amp;&amp; static_cast&lt;unsigned&gt;(position.offsetInContainerNode()) &gt; node.computeNodeIndex())
 966             position.moveToOffset(position.offsetInContainerNode() - 1);
 967         else if (node.containsIncludingShadowDOM(position.containerNode()))
 968             position = positionInParentBeforeNode(&amp;node);
 969         break;
 970     case Position::PositionIsAfterAnchor:
 971         if (node.containsIncludingShadowDOM(position.anchorNode()))
 972             position = positionInParentAfterNode(&amp;node);
 973         break;
 974     case Position::PositionIsBeforeAnchor:
 975         if (node.containsIncludingShadowDOM(position.anchorNode()))
 976             position = positionInParentBeforeNode(&amp;node);
 977         break;
 978     }
 979 }
 980 
 981 bool isMailBlockquote(const Node* node)
 982 {
 983     ASSERT(node);
 984     if (!node-&gt;hasTagName(blockquoteTag))
 985         return false;
 986     return downcast&lt;HTMLElement&gt;(*node).attributeWithoutSynchronization(typeAttr) == &quot;cite&quot;;
 987 }
 988 
 989 int caretMinOffset(const Node&amp; node)
 990 {
 991     auto* renderer = node.renderer();
 992     ASSERT(!node.isCharacterDataNode() || !renderer || renderer-&gt;isText());
 993     return renderer ? renderer-&gt;caretMinOffset() : 0;
 994 }
 995 
 996 // If a node can contain candidates for VisiblePositions, return the offset of the last candidate, otherwise
 997 // return the number of children for container nodes and the length for unrendered text nodes.
 998 int caretMaxOffset(const Node&amp; node)
 999 {
1000     // For rendered text nodes, return the last position that a caret could occupy.
1001     if (is&lt;Text&gt;(node)) {
1002         if (auto* renderer = downcast&lt;Text&gt;(node).renderer())
1003             return renderer-&gt;caretMaxOffset();
1004     }
1005     return lastOffsetForEditing(node);
1006 }
1007 
1008 bool lineBreakExistsAtVisiblePosition(const VisiblePosition&amp; position)
1009 {
1010     return lineBreakExistsAtPosition(position.deepEquivalent().downstream());
1011 }
1012 
1013 bool lineBreakExistsAtPosition(const Position&amp; position)
1014 {
1015     if (position.isNull())
1016         return false;
1017 
1018     if (position.anchorNode()-&gt;hasTagName(brTag) &amp;&amp; position.atFirstEditingPositionForNode())
1019         return true;
1020 
1021     if (!position.anchorNode()-&gt;renderer())
1022         return false;
1023 
1024     if (!is&lt;Text&gt;(*position.anchorNode()) || !position.anchorNode()-&gt;renderer()-&gt;style().preserveNewline())
1025         return false;
1026 
1027     Text&amp; textNode = downcast&lt;Text&gt;(*position.anchorNode());
1028     unsigned offset = position.offsetInContainerNode();
1029     return offset &lt; textNode.length() &amp;&amp; textNode.data()[offset] == &#39;\n&#39;;
1030 }
1031 
1032 // Modifies selections that have an end point at the edge of a table
1033 // that contains the other endpoint so that they don&#39;t confuse
1034 // code that iterates over selected paragraphs.
1035 VisibleSelection selectionForParagraphIteration(const VisibleSelection&amp; original)
1036 {
1037     VisibleSelection newSelection(original);
1038     VisiblePosition startOfSelection(newSelection.visibleStart());
1039     VisiblePosition endOfSelection(newSelection.visibleEnd());
1040 
1041     // If the end of the selection to modify is just after a table, and
1042     // if the start of the selection is inside that table, then the last paragraph
1043     // that we&#39;ll want modify is the last one inside the table, not the table itself
1044     // (a table is itself a paragraph).
1045     if (auto* table = isFirstPositionAfterTable(endOfSelection)) {
1046         if (startOfSelection.deepEquivalent().deprecatedNode()-&gt;isDescendantOf(*table))
1047             newSelection = VisibleSelection(startOfSelection, endOfSelection.previous(CannotCrossEditingBoundary));
1048     }
1049 
1050     // If the start of the selection to modify is just before a table,
1051     // and if the end of the selection is inside that table, then the first paragraph
1052     // we&#39;ll want to modify is the first one inside the table, not the paragraph
1053     // containing the table itself.
1054     if (auto* table = isLastPositionBeforeTable(startOfSelection)) {
1055         if (endOfSelection.deepEquivalent().deprecatedNode()-&gt;isDescendantOf(*table))
1056             newSelection = VisibleSelection(startOfSelection.next(CannotCrossEditingBoundary), endOfSelection);
1057     }
1058 
1059     return newSelection;
1060 }
1061 
1062 // FIXME: indexForVisiblePosition and visiblePositionForIndex use TextIterators to convert between
1063 // VisiblePositions and indices. But TextIterator iteration using TextIteratorEmitsCharactersBetweenAllVisiblePositions
1064 // does not exactly match VisiblePosition iteration, so using them to preserve a selection during an editing
1065 // opertion is unreliable. TextIterator&#39;s TextIteratorEmitsCharactersBetweenAllVisiblePositions mode needs to be fixed,
1066 // or these functions need to be changed to iterate using actual VisiblePositions.
1067 // FIXME: Deploy these functions everywhere that TextIterators are used to convert between VisiblePositions and indices.
1068 int indexForVisiblePosition(const VisiblePosition&amp; visiblePosition, RefPtr&lt;ContainerNode&gt;&amp; scope)
1069 {
1070     if (visiblePosition.isNull())
1071         return 0;
1072 
1073     auto position = visiblePosition.deepEquivalent();
1074     auto&amp; document = *position.document();
1075 
1076     auto* editableRoot = highestEditableRoot(position, AXObjectCache::accessibilityEnabled() ? HasEditableAXRole : ContentIsEditable);
1077     if (editableRoot &amp;&amp; !document.inDesignMode())
1078         scope = editableRoot;
1079     else {
1080         if (position.containerNode()-&gt;isInShadowTree())
1081             scope = position.containerNode()-&gt;containingShadowRoot();
1082         else
1083             scope = &amp;document;
1084     }
1085 
1086     auto range = Range::create(document, firstPositionInNode(scope.get()), position.parentAnchoredEquivalent());
1087     return TextIterator::rangeLength(range.ptr(), true);
1088 }
1089 
1090 // FIXME: Merge this function with the one above.
1091 int indexForVisiblePosition(Node&amp; node, const VisiblePosition&amp; visiblePosition, bool forSelectionPreservation)
1092 {
1093     auto range = Range::create(node.document(), firstPositionInNode(&amp;node), visiblePosition.deepEquivalent().parentAnchoredEquivalent());
1094     return TextIterator::rangeLength(range.ptr(), forSelectionPreservation);
1095 }
1096 
1097 VisiblePosition visiblePositionForPositionWithOffset(const VisiblePosition&amp; position, int offset)
1098 {
1099     RefPtr&lt;ContainerNode&gt; root;
1100     unsigned startIndex = indexForVisiblePosition(position, root);
1101     if (!root)
1102         return { };
1103 
1104     return visiblePositionForIndex(startIndex + offset, root.get());
1105 }
1106 
1107 VisiblePosition visiblePositionForIndex(int index, ContainerNode* scope)
1108 {
1109     auto range = TextIterator::rangeFromLocationAndLength(scope, index, 0, true);
1110     // Check for an invalid index. Certain editing operations invalidate indices because
1111     // of problems with TextIteratorEmitsCharactersBetweenAllVisiblePositions.
1112     if (!range)
1113         return { };
1114     return { range-&gt;startPosition() };
1115 }
1116 
1117 VisiblePosition visiblePositionForIndexUsingCharacterIterator(Node&amp; node, int index)
1118 {
1119     if (index &lt;= 0)
1120         return { firstPositionInOrBeforeNode(&amp;node), DOWNSTREAM };
1121 
1122     auto range = Range::create(node.document());
1123     range-&gt;selectNodeContents(node);
1124     CharacterIterator it(range.get());
1125     it.advance(index - 1);
1126 
<a name="3" id="anc3"></a><span class="line-modified">1127     if (!it.atEnd() &amp;&amp; it.text().length() == 1 &amp;&amp; it.text()[0] == &#39;\n&#39;) {</span>
1128         // FIXME: workaround for collapsed range (where only start position is correct) emitted for some emitted newlines.
<a name="4" id="anc4"></a><span class="line-modified">1129         it.advance(1);</span>
<span class="line-modified">1130         if (!it.atEnd())</span>
<span class="line-modified">1131             return VisiblePosition(it.range()-&gt;startPosition());</span>



1132     }
1133 
1134     return { it.atEnd() ? range-&gt;endPosition() : it.range()-&gt;endPosition(), UPSTREAM };
1135 }
1136 
1137 // Determines whether two positions are visibly next to each other (first then second)
1138 // while ignoring whitespaces and unrendered nodes
1139 static bool isVisiblyAdjacent(const Position&amp; first, const Position&amp; second)
1140 {
1141     return VisiblePosition(first) == VisiblePosition(second.upstream());
1142 }
1143 
1144 // Determines whether a node is inside a range or visibly starts and ends at the boundaries of the range.
1145 // Call this function to determine whether a node is visibly fit inside selectedRange
1146 bool isNodeVisiblyContainedWithin(Node&amp; node, const Range&amp; range)
1147 {
1148     // If the node is inside the range, then it surely is contained within.
1149     auto comparisonResult = range.compareNode(node);
1150     if (!comparisonResult.hasException() &amp;&amp; comparisonResult.releaseReturnValue() == Range::NODE_INSIDE)
1151         return true;
1152 
1153     bool startIsVisuallySame = visiblePositionBeforeNode(node) == range.startPosition();
1154     if (startIsVisuallySame &amp;&amp; comparePositions(positionInParentAfterNode(&amp;node), range.endPosition()) &lt; 0)
1155         return true;
1156 
1157     bool endIsVisuallySame = visiblePositionAfterNode(node) == range.endPosition();
1158     if (endIsVisuallySame &amp;&amp; comparePositions(range.startPosition(), positionInParentBeforeNode(&amp;node)) &lt; 0)
1159         return true;
1160 
1161     return startIsVisuallySame &amp;&amp; endIsVisuallySame;
1162 }
1163 
1164 bool isRenderedAsNonInlineTableImageOrHR(const Node* node)
1165 {
1166     if (!node)
1167         return false;
1168     RenderObject* renderer = node-&gt;renderer();
1169     return renderer &amp;&amp; ((renderer-&gt;isTable() &amp;&amp; !renderer-&gt;isInline()) || (renderer-&gt;isImage() &amp;&amp; !renderer-&gt;isInline()) || renderer-&gt;isHR());
1170 }
1171 
1172 bool areIdenticalElements(const Node&amp; first, const Node&amp; second)
1173 {
1174     if (!is&lt;Element&gt;(first) || !is&lt;Element&gt;(second))
1175         return false;
1176     auto&amp; firstElement = downcast&lt;Element&gt;(first);
1177     auto&amp; secondElement = downcast&lt;Element&gt;(second);
1178     return firstElement.hasTagName(secondElement.tagQName()) &amp;&amp; firstElement.hasEquivalentAttributes(secondElement);
1179 }
1180 
1181 bool isNonTableCellHTMLBlockElement(const Node* node)
1182 {
1183     return node-&gt;hasTagName(listingTag)
1184         || node-&gt;hasTagName(olTag)
1185         || node-&gt;hasTagName(preTag)
1186         || is&lt;HTMLTableElement&gt;(*node)
1187         || node-&gt;hasTagName(ulTag)
1188         || node-&gt;hasTagName(xmpTag)
1189         || node-&gt;hasTagName(h1Tag)
1190         || node-&gt;hasTagName(h2Tag)
1191         || node-&gt;hasTagName(h3Tag)
1192         || node-&gt;hasTagName(h4Tag)
1193         || node-&gt;hasTagName(h5Tag);
1194 }
1195 
1196 Position adjustedSelectionStartForStyleComputation(const VisibleSelection&amp; selection)
1197 {
1198     // This function is used by range style computations to avoid bugs like:
1199     // &lt;rdar://problem/4017641&gt; REGRESSION (Mail): you can only bold/unbold a selection starting from end of line once
1200     // It is important to skip certain irrelevant content at the start of the selection, so we do not wind up
1201     // with a spurious &quot;mixed&quot; style.
1202 
1203     auto visiblePosition = selection.visibleStart();
1204     if (visiblePosition.isNull())
1205         return { };
1206 
1207     // if the selection is a caret, just return the position, since the style
1208     // behind us is relevant
1209     if (selection.isCaret())
1210         return visiblePosition.deepEquivalent();
1211 
1212     // if the selection starts just before a paragraph break, skip over it
1213     if (isEndOfParagraph(visiblePosition))
1214         return visiblePosition.next().deepEquivalent().downstream();
1215 
1216     // otherwise, make sure to be at the start of the first selected node,
1217     // instead of possibly at the end of the last node before the selection
1218     return visiblePosition.deepEquivalent().downstream();
1219 }
1220 
1221 // FIXME: Should this be deprecated like deprecatedEnclosingBlockFlowElement is?
1222 bool isBlockFlowElement(const Node&amp; node)
1223 {
1224     if (!node.isElementNode())
1225         return false;
1226     auto* renderer = downcast&lt;Element&gt;(node).renderer();
1227     return renderer &amp;&amp; renderer-&gt;isRenderBlockFlow();
1228 }
1229 
1230 Element* deprecatedEnclosingBlockFlowElement(Node* node)
1231 {
1232     if (!node)
1233         return nullptr;
1234     if (isBlockFlowElement(*node))
1235         return downcast&lt;Element&gt;(node);
1236     while ((node = node-&gt;parentNode())) {
1237         if (isBlockFlowElement(*node) || is&lt;HTMLBodyElement&gt;(*node))
1238             return downcast&lt;Element&gt;(node);
1239     }
1240     return nullptr;
1241 }
1242 
1243 static inline bool caretRendersInsideNode(Node&amp; node)
1244 {
1245     return !isRenderedTable(&amp;node) &amp;&amp; !editingIgnoresContent(node);
1246 }
1247 
1248 RenderBlock* rendererForCaretPainting(Node* node)
1249 {
1250     if (!node)
1251         return nullptr;
1252 
1253     auto* renderer = node-&gt;renderer();
1254     if (!renderer)
1255         return nullptr;
1256 
1257     // If caretNode is a block and caret is inside it, then caret should be painted by that block.
1258     bool paintedByBlock = is&lt;RenderBlockFlow&gt;(*renderer) &amp;&amp; caretRendersInsideNode(*node);
1259     return paintedByBlock ? downcast&lt;RenderBlock&gt;(renderer) : renderer-&gt;containingBlock();
1260 }
1261 
1262 LayoutRect localCaretRectInRendererForCaretPainting(const VisiblePosition&amp; caretPosition, RenderBlock*&amp; caretPainter)
1263 {
1264     if (caretPosition.isNull())
1265         return LayoutRect();
1266 
1267     ASSERT(caretPosition.deepEquivalent().deprecatedNode()-&gt;renderer());
1268 
1269     // First compute a rect local to the renderer at the selection start.
1270     RenderObject* renderer;
1271     LayoutRect localRect = caretPosition.localCaretRect(renderer);
1272 
1273     return localCaretRectInRendererForRect(localRect, caretPosition.deepEquivalent().deprecatedNode(), renderer, caretPainter);
1274 }
1275 
1276 LayoutRect localCaretRectInRendererForRect(LayoutRect&amp; localRect, Node* node, RenderObject* renderer, RenderBlock*&amp; caretPainter)
1277 {
1278     // Get the renderer that will be responsible for painting the caret
1279     // (which is either the renderer we just found, or one of its containers).
1280     caretPainter = rendererForCaretPainting(node);
1281 
1282     // Compute an offset between the renderer and the caretPainter.
1283     while (renderer != caretPainter) {
1284         RenderElement* containerObject = renderer-&gt;container();
1285         if (!containerObject)
1286             return LayoutRect();
1287         localRect.move(renderer-&gt;offsetFromContainer(*containerObject, localRect.location()));
1288         renderer = containerObject;
1289     }
1290 
1291     return localRect;
1292 }
1293 
1294 IntRect absoluteBoundsForLocalCaretRect(RenderBlock* rendererForCaretPainting, const LayoutRect&amp; rect, bool* insideFixed)
1295 {
1296     if (insideFixed)
1297         *insideFixed = false;
1298 
1299     if (!rendererForCaretPainting || rect.isEmpty())
1300         return IntRect();
1301 
1302     LayoutRect localRect(rect);
1303     rendererForCaretPainting-&gt;flipForWritingMode(localRect);
1304     return rendererForCaretPainting-&gt;localToAbsoluteQuad(FloatRect(localRect), UseTransforms, insideFixed).enclosingBoundingBox();
1305 }
1306 
<a name="5" id="anc5"></a><span class="line-added">1307 HashSet&lt;RefPtr&lt;HTMLImageElement&gt;&gt; visibleImageElementsInRangeWithNonLoadedImages(const Range&amp; range)</span>
<span class="line-added">1308 {</span>
<span class="line-added">1309     HashSet&lt;RefPtr&lt;HTMLImageElement&gt;&gt; result;</span>
<span class="line-added">1310     for (TextIterator iterator(&amp;range); !iterator.atEnd(); iterator.advance()) {</span>
<span class="line-added">1311         if (!is&lt;HTMLImageElement&gt;(iterator.node()))</span>
<span class="line-added">1312             continue;</span>
<span class="line-added">1313 </span>
<span class="line-added">1314         auto&amp; imageElement = downcast&lt;HTMLImageElement&gt;(*iterator.node());</span>
<span class="line-added">1315         auto* cachedImage = imageElement.cachedImage();</span>
<span class="line-added">1316         if (cachedImage &amp;&amp; cachedImage-&gt;isLoading())</span>
<span class="line-added">1317             result.add(&amp;imageElement);</span>
<span class="line-added">1318     }</span>
<span class="line-added">1319     return result;</span>
<span class="line-added">1320 }</span>
<span class="line-added">1321 </span>
1322 } // namespace WebCore
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
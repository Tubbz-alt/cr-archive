<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLFormElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLFormControlElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLFormElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLFormElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
341     bool needButtonActivation = activateSubmitButton; // do we need to activate a submit button?
342 
343     for (auto&amp; associatedElement : m_associatedElements) {
344         if (!is&lt;HTMLFormControlElement&gt;(*associatedElement))
345             continue;
346         if (needButtonActivation) {
347             HTMLFormControlElement&amp; control = downcast&lt;HTMLFormControlElement&gt;(*associatedElement);
348             if (control.isActivatedSubmit())
349                 needButtonActivation = false;
350             else if (!firstSuccessfulSubmitButton &amp;&amp; control.isSuccessfulSubmitButton())
351                 firstSuccessfulSubmitButton = &amp;control;
352         }
353     }
354 
355     if (needButtonActivation &amp;&amp; firstSuccessfulSubmitButton)
356         firstSuccessfulSubmitButton-&gt;setActivatedSubmit(true);
357 
358     auto protectedThis = makeRef(*this); // Form submission can execute arbitary JavaScript.
359 
360     auto shouldLockHistory = processingUserGesture ? LockHistory::No : LockHistory::Yes;
<span class="line-modified">361     frame-&gt;loader().submitForm(FormSubmission::create(*this, m_attributes, event, shouldLockHistory, formSubmissionTrigger));</span>




362 
363     if (needButtonActivation &amp;&amp; firstSuccessfulSubmitButton)
364         firstSuccessfulSubmitButton-&gt;setActivatedSubmit(false);
365 
366     m_shouldSubmit = false;
367     m_isSubmittingOrPreparingForSubmission = false;
368 }
369 
370 void HTMLFormElement::reset()
371 {
372     if (m_isInResetFunction)
373         return;
374 
375     RefPtr&lt;Frame&gt; protectedFrame = document().frame();
376     if (!protectedFrame)
377         return;
378 
379     Ref&lt;HTMLFormElement&gt; protectedThis(*this);
380 
381     SetForScope&lt;bool&gt; isInResetFunctionRestorer(m_isInResetFunction, true);
</pre>
<hr />
<pre>
385     if (!event-&gt;defaultPrevented())
386         resetAssociatedFormControlElements();
387 }
388 
389 void HTMLFormElement::resetAssociatedFormControlElements()
390 {
391     // Event handling can cause associated elements to be added or deleted while iterating
392     // over this collection. Protect these elements until we are done notifying them of
393     // the reset operation.
394     Vector&lt;Ref&lt;HTMLFormControlElement&gt;&gt; associatedFormControlElements;
395     associatedFormControlElements.reserveInitialCapacity(m_associatedElements.size());
396     for (auto* element : m_associatedElements) {
397         if (is&lt;HTMLFormControlElement&gt;(element))
398             associatedFormControlElements.uncheckedAppend(*downcast&lt;HTMLFormControlElement&gt;(element));
399     }
400 
401     for (auto&amp; associatedFormControlElement : associatedFormControlElements)
402         associatedFormControlElement-&gt;reset();
403 }
404 
<span class="line-modified">405 #if ENABLE(IOS_AUTOCORRECT_AND_AUTOCAPITALIZE)</span>
406 
407 // FIXME: We should look to share this code with class HTMLFormControlElement instead of duplicating the logic.
408 
409 bool HTMLFormElement::shouldAutocorrect() const
410 {
411     const AtomString&amp; autocorrectValue = attributeWithoutSynchronization(autocorrectAttr);
412     if (!autocorrectValue.isEmpty())
413         return !equalLettersIgnoringASCIICase(autocorrectValue, &quot;off&quot;);
414     if (RefPtr&lt;HTMLFormElement&gt; form = this-&gt;form())
415         return form-&gt;shouldAutocorrect();
416     return true;
417 }
418 
419 #endif
420 
421 void HTMLFormElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
422 {
423     if (name == actionAttr) {
424         m_attributes.parseAction(value);
425 
</pre>
</td>
<td>
<hr />
<pre>
341     bool needButtonActivation = activateSubmitButton; // do we need to activate a submit button?
342 
343     for (auto&amp; associatedElement : m_associatedElements) {
344         if (!is&lt;HTMLFormControlElement&gt;(*associatedElement))
345             continue;
346         if (needButtonActivation) {
347             HTMLFormControlElement&amp; control = downcast&lt;HTMLFormControlElement&gt;(*associatedElement);
348             if (control.isActivatedSubmit())
349                 needButtonActivation = false;
350             else if (!firstSuccessfulSubmitButton &amp;&amp; control.isSuccessfulSubmitButton())
351                 firstSuccessfulSubmitButton = &amp;control;
352         }
353     }
354 
355     if (needButtonActivation &amp;&amp; firstSuccessfulSubmitButton)
356         firstSuccessfulSubmitButton-&gt;setActivatedSubmit(true);
357 
358     auto protectedThis = makeRef(*this); // Form submission can execute arbitary JavaScript.
359 
360     auto shouldLockHistory = processingUserGesture ? LockHistory::No : LockHistory::Yes;
<span class="line-modified">361     auto formSubmission = FormSubmission::create(*this, m_attributes, event, shouldLockHistory, formSubmissionTrigger);</span>
<span class="line-added">362     if (m_plannedFormSubmission)</span>
<span class="line-added">363         m_plannedFormSubmission-&gt;cancel();</span>
<span class="line-added">364     m_plannedFormSubmission = makeWeakPtr(formSubmission.get());</span>
<span class="line-added">365     frame-&gt;loader().submitForm(WTFMove(formSubmission));</span>
366 
367     if (needButtonActivation &amp;&amp; firstSuccessfulSubmitButton)
368         firstSuccessfulSubmitButton-&gt;setActivatedSubmit(false);
369 
370     m_shouldSubmit = false;
371     m_isSubmittingOrPreparingForSubmission = false;
372 }
373 
374 void HTMLFormElement::reset()
375 {
376     if (m_isInResetFunction)
377         return;
378 
379     RefPtr&lt;Frame&gt; protectedFrame = document().frame();
380     if (!protectedFrame)
381         return;
382 
383     Ref&lt;HTMLFormElement&gt; protectedThis(*this);
384 
385     SetForScope&lt;bool&gt; isInResetFunctionRestorer(m_isInResetFunction, true);
</pre>
<hr />
<pre>
389     if (!event-&gt;defaultPrevented())
390         resetAssociatedFormControlElements();
391 }
392 
393 void HTMLFormElement::resetAssociatedFormControlElements()
394 {
395     // Event handling can cause associated elements to be added or deleted while iterating
396     // over this collection. Protect these elements until we are done notifying them of
397     // the reset operation.
398     Vector&lt;Ref&lt;HTMLFormControlElement&gt;&gt; associatedFormControlElements;
399     associatedFormControlElements.reserveInitialCapacity(m_associatedElements.size());
400     for (auto* element : m_associatedElements) {
401         if (is&lt;HTMLFormControlElement&gt;(element))
402             associatedFormControlElements.uncheckedAppend(*downcast&lt;HTMLFormControlElement&gt;(element));
403     }
404 
405     for (auto&amp; associatedFormControlElement : associatedFormControlElements)
406         associatedFormControlElement-&gt;reset();
407 }
408 
<span class="line-modified">409 #if ENABLE(AUTOCORRECT)</span>
410 
411 // FIXME: We should look to share this code with class HTMLFormControlElement instead of duplicating the logic.
412 
413 bool HTMLFormElement::shouldAutocorrect() const
414 {
415     const AtomString&amp; autocorrectValue = attributeWithoutSynchronization(autocorrectAttr);
416     if (!autocorrectValue.isEmpty())
417         return !equalLettersIgnoringASCIICase(autocorrectValue, &quot;off&quot;);
418     if (RefPtr&lt;HTMLFormElement&gt; form = this-&gt;form())
419         return form-&gt;shouldAutocorrect();
420     return true;
421 }
422 
423 #endif
424 
425 void HTMLFormElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
426 {
427     if (name == actionAttr) {
428         m_attributes.parseAction(value);
429 
</pre>
</td>
</tr>
</table>
<center><a href="HTMLFormControlElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLFormElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
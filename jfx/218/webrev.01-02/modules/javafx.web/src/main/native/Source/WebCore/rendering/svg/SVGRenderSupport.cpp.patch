diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGRenderSupport.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGRenderSupport.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGRenderSupport.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGRenderSupport.cpp
@@ -39,10 +39,11 @@
 #include "RenderSVGResourceMasker.h"
 #include "RenderSVGRoot.h"
 #include "RenderSVGText.h"
 #include "RenderSVGTransformableContainer.h"
 #include "RenderSVGViewportContainer.h"
+#include "SVGGeometryElement.h"
 #include "SVGResources.h"
 #include "SVGResourcesCache.h"
 #include "TransformState.h"
 
 namespace WebCore {
@@ -62,19 +63,26 @@
     return enclosingLayoutRect(renderer.computeFloatRectForRepaint(repaintRect, repaintContainer));
 }
 
 Optional<FloatRect> SVGRenderSupport::computeFloatVisibleRectInContainer(const RenderElement& renderer, const FloatRect& rect, const RenderLayerModelObject* container, RenderObject::VisibleRectContext context)
 {
+    // Ensure our parent is an SVG object.
+    ASSERT(renderer.parent());
+    auto& parent = *renderer.parent();
+    if (!is<SVGElement>(parent.element()))
+        return FloatRect();
+
     FloatRect adjustedRect = rect;
     const SVGRenderStyle& svgStyle = renderer.style().svgStyle();
     if (const ShadowData* shadow = svgStyle.shadow())
         shadow->adjustRectForShadow(adjustedRect);
     adjustedRect.inflate(renderer.style().outlineWidth());
 
     // Translate to coords in our parent renderer, and then call computeFloatVisibleRectInContainer() on our parent.
     adjustedRect = renderer.localToParentTransform().mapRect(adjustedRect);
-    return renderer.parent()->computeFloatVisibleRectInContainer(adjustedRect, container, context);
+
+    return parent.computeFloatVisibleRectInContainer(adjustedRect, container, context);
 }
 
 const RenderElement& SVGRenderSupport::localToParentTransform(const RenderElement& renderer, AffineTransform &transform)
 {
     ASSERT(renderer.parent());
@@ -414,12 +422,16 @@
 }
 
 void SVGRenderSupport::applyStrokeStyleToContext(GraphicsContext* context, const RenderStyle& style, const RenderElement& renderer)
 {
     ASSERT(context);
-    ASSERT(renderer.element());
-    ASSERT(renderer.element()->isSVGElement());
+
+    Element* element = renderer.element();
+    if (!is<SVGElement>(element)) {
+        ASSERT_NOT_REACHED();
+        return;
+    }
 
     const SVGRenderStyle& svgStyle = style.svgStyle();
 
     SVGLengthContext lengthContext(downcast<SVGElement>(renderer.element()));
     context->setStrokeThickness(lengthContext.valueForLength(style.strokeWidth()));
@@ -433,19 +445,27 @@
         context->setStrokeStyle(SolidStroke);
     else {
         DashArray dashArray;
         dashArray.reserveInitialCapacity(dashes.size());
         bool canSetLineDash = false;
+        float scaleFactor = 1;
+
+        if (is<SVGGeometryElement>(element)) {
+            ASSERT(renderer.isSVGShape());
+            // FIXME: A value of zero is valid. Need to differentiate this case from being unspecified.
+            if (float pathLength = downcast<SVGGeometryElement>(element)->pathLength())
+                scaleFactor = downcast<RenderSVGShape>(renderer).getTotalLength() / pathLength;
+        }
 
         for (auto& dash : dashes) {
-            dashArray.uncheckedAppend(dash.value(lengthContext));
+            dashArray.uncheckedAppend(dash.value(lengthContext) * scaleFactor);
             if (dashArray.last() > 0)
                 canSetLineDash = true;
         }
 
         if (canSetLineDash)
-            context->setLineDash(dashArray, lengthContext.valueForLength(svgStyle.strokeDashOffset()));
+            context->setLineDash(dashArray, lengthContext.valueForLength(svgStyle.strokeDashOffset()) * scaleFactor);
         else
             context->setStrokeStyle(SolidStroke);
     }
 }
 

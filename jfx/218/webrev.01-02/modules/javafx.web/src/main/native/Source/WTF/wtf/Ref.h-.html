<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WTF/wtf/Ref.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;wtf/Assertions.h&gt;
 29 #include &lt;wtf/DumbPtrTraits.h&gt;
 30 #include &lt;wtf/Forward.h&gt;
 31 #include &lt;wtf/GetPtr.h&gt;
 32 #include &lt;wtf/StdLibExtras.h&gt;
 33 #include &lt;wtf/TypeCasts.h&gt;
 34 
 35 #if ASAN_ENABLED
 36 extern &quot;C&quot; void __asan_poison_memory_region(void const volatile *addr, size_t size);
 37 extern &quot;C&quot; void __asan_unpoison_memory_region(void const volatile *addr, size_t size);
 38 extern &quot;C&quot; int __asan_address_is_poisoned(void const volatile *addr);
 39 #endif
 40 
 41 namespace WTF {
 42 
 43 inline void adopted(const void*) { }
 44 
 45 template&lt;typename T, typename PtrTraits&gt; class Ref;
 46 template&lt;typename T, typename PtrTraits = DumbPtrTraits&lt;T&gt;&gt; Ref&lt;T, PtrTraits&gt; adoptRef(T&amp;);
 47 
 48 template&lt;typename T, typename PtrTraits&gt;
 49 class Ref {
 50 public:
 51     static constexpr bool isRef = true;
 52 
 53     ~Ref()
 54     {
 55 #if ASAN_ENABLED
 56         if (__asan_address_is_poisoned(this))
 57             __asan_unpoison_memory_region(this, sizeof(*this));
 58 #endif
 59         if (m_ptr)
 60             PtrTraits::unwrap(m_ptr)-&gt;deref();
 61     }
 62 
 63     Ref(T&amp; object)
 64         : m_ptr(&amp;object)
 65     {
 66         object.ref();
 67     }
 68 
 69     // Use copyRef() instead.
 70     Ref(const Ref&amp; other) = delete;
 71     template&lt;typename X, typename Y&gt; Ref(const Ref&lt;X, Y&gt;&amp; other) = delete;
 72 
 73     Ref(Ref&amp;&amp; other)
 74         : m_ptr(&amp;other.leakRef())
 75     {
 76         ASSERT(m_ptr);
 77     }
 78 
 79     template&lt;typename X, typename Y&gt;
 80     Ref(Ref&lt;X, Y&gt;&amp;&amp; other)
 81         : m_ptr(&amp;other.leakRef())
 82     {
 83         ASSERT(m_ptr);
 84     }
 85 
 86     Ref&amp; operator=(T&amp;);
 87     Ref&amp; operator=(Ref&amp;&amp;);
 88     template&lt;typename X, typename Y&gt; Ref&amp; operator=(Ref&lt;X, Y&gt;&amp;&amp;);
 89 
 90     // Use copyRef() and the move assignment operators instead.
 91     Ref&amp; operator=(const Ref&amp;) = delete;
 92     template&lt;typename X, typename Y&gt; Ref&amp; operator=(const Ref&lt;X, Y&gt;&amp;) = delete;
 93 
 94     template&lt;typename X, typename Y&gt; void swap(Ref&lt;X, Y&gt;&amp;);
 95 
 96     // Hash table deleted values, which are only constructed and never copied or destroyed.
 97     Ref(HashTableDeletedValueType) : m_ptr(hashTableDeletedValue()) { }
 98     bool isHashTableDeletedValue() const { return m_ptr == hashTableDeletedValue(); }
 99     static T* hashTableDeletedValue() { return reinterpret_cast&lt;T*&gt;(-1); }
100 
101     Ref(HashTableEmptyValueType) : m_ptr(hashTableEmptyValue()) { }
102     bool isHashTableEmptyValue() const { return m_ptr == hashTableEmptyValue(); }
103     static T* hashTableEmptyValue() { return nullptr; }
104 
105     const T* ptrAllowingHashTableEmptyValue() const { ASSERT(m_ptr || isHashTableEmptyValue()); return PtrTraits::unwrap(m_ptr); }
106     T* ptrAllowingHashTableEmptyValue() { ASSERT(m_ptr || isHashTableEmptyValue()); return PtrTraits::unwrap(m_ptr); }
107 
108     void assignToHashTableEmptyValue(Ref&amp;&amp; reference)
109     {
110 #if ASAN_ENABLED
111         if (__asan_address_is_poisoned(this))
112             __asan_unpoison_memory_region(this, sizeof(*this));
113 #endif
114         ASSERT(m_ptr == hashTableEmptyValue());
115         m_ptr = &amp;reference.leakRef();
116         ASSERT(m_ptr);
117     }
118 
119     T* operator-&gt;() const { ASSERT(m_ptr); return PtrTraits::unwrap(m_ptr); }
120     T* ptr() const RETURNS_NONNULL { ASSERT(m_ptr); return PtrTraits::unwrap(m_ptr); }
121     T&amp; get() const { ASSERT(m_ptr); return *PtrTraits::unwrap(m_ptr); }
122     operator T&amp;() const { ASSERT(m_ptr); return *PtrTraits::unwrap(m_ptr); }
123     bool operator!() const { ASSERT(m_ptr); return !*m_ptr; }
124 
125     template&lt;typename X, typename Y&gt; Ref&lt;T, PtrTraits&gt; replace(Ref&lt;X, Y&gt;&amp;&amp;) WARN_UNUSED_RETURN;
126 
127     Ref copyRef() &amp;&amp; = delete;
128     Ref copyRef() const &amp; WARN_UNUSED_RETURN { return Ref(*m_ptr); }
129 
130     T&amp; leakRef() WARN_UNUSED_RETURN
131     {
132         ASSERT(m_ptr);
133 
134         T&amp; result = *PtrTraits::exchange(m_ptr, nullptr);
135 #if ASAN_ENABLED
136         __asan_poison_memory_region(this, sizeof(*this));
137 #endif
138         return result;
139     }
140 
141 private:
142     friend Ref adoptRef&lt;T&gt;(T&amp;);
143     template&lt;typename X, typename Y&gt; friend class Ref;
144 
145     enum AdoptTag { Adopt };
146     Ref(T&amp; object, AdoptTag)
147         : m_ptr(&amp;object)
148     {
149     }
150 
151     typename PtrTraits::StorageType m_ptr;
152 };
153 
154 template&lt;typename T, typename U&gt; Ref&lt;T, U&gt; adoptRef(T&amp;);
155 template&lt;typename T&gt; Ref&lt;T&gt; makeRef(T&amp;);
156 
157 template&lt;typename T, typename U&gt;
158 inline Ref&lt;T, U&gt;&amp; Ref&lt;T, U&gt;::operator=(T&amp; reference)
159 {
160     Ref copiedReference = reference;
161     swap(copiedReference);
162     return *this;
163 }
164 
165 template&lt;typename T, typename U&gt;
166 inline Ref&lt;T, U&gt;&amp; Ref&lt;T, U&gt;::operator=(Ref&amp;&amp; reference)
167 {
168 #if ASAN_ENABLED
169     if (__asan_address_is_poisoned(this))
170         __asan_unpoison_memory_region(this, sizeof(*this));
171 #endif
172     Ref movedReference = WTFMove(reference);
173     swap(movedReference);
174     return *this;
175 }
176 
177 template&lt;typename T, typename U&gt;
178 template&lt;typename X, typename Y&gt;
179 inline Ref&lt;T, U&gt;&amp; Ref&lt;T, U&gt;::operator=(Ref&lt;X, Y&gt;&amp;&amp; reference)
180 {
181 #if ASAN_ENABLED
182     if (__asan_address_is_poisoned(this))
183         __asan_unpoison_memory_region(this, sizeof(*this));
184 #endif
185     Ref movedReference = WTFMove(reference);
186     swap(movedReference);
187     return *this;
188 }
189 
190 template&lt;typename T, typename U&gt;
191 template&lt;typename X, typename Y&gt;
192 inline void Ref&lt;T, U&gt;::swap(Ref&lt;X, Y&gt;&amp; other)
193 {
194     U::swap(m_ptr, other.m_ptr);
195 }
196 
197 template&lt;typename T, typename U, typename X, typename Y, typename = std::enable_if_t&lt;!std::is_same&lt;U, DumbPtrTraits&lt;T&gt;&gt;::value || !std::is_same&lt;Y, DumbPtrTraits&lt;X&gt;&gt;::value&gt;&gt;
198 inline void swap(Ref&lt;T, U&gt;&amp; a, Ref&lt;X, Y&gt;&amp; b)
199 {
200     a.swap(b);
201 }
202 
203 template&lt;typename T, typename U&gt;
204 template&lt;typename X, typename Y&gt;
205 inline Ref&lt;T, U&gt; Ref&lt;T, U&gt;::replace(Ref&lt;X, Y&gt;&amp;&amp; reference)
206 {
207 #if ASAN_ENABLED
208     if (__asan_address_is_poisoned(this))
209         __asan_unpoison_memory_region(this, sizeof(*this));
210 #endif
211     auto oldReference = adoptRef(*m_ptr);
212     m_ptr = &amp;reference.leakRef();
213     return oldReference;
214 }
215 
216 template&lt;typename T, typename U = DumbPtrTraits&lt;T&gt;, typename X, typename Y&gt;
217 inline Ref&lt;T, U&gt; static_reference_cast(Ref&lt;X, Y&gt;&amp; reference)
218 {
219     return Ref&lt;T, U&gt;(static_cast&lt;T&amp;&gt;(reference.get()));
220 }
221 
222 template&lt;typename T, typename U = DumbPtrTraits&lt;T&gt;, typename X, typename Y&gt;
223 inline Ref&lt;T, U&gt; static_reference_cast(Ref&lt;X, Y&gt;&amp;&amp; reference)
224 {
225     return adoptRef(static_cast&lt;T&amp;&gt;(reference.leakRef()));
226 }
227 
228 template&lt;typename T, typename U = DumbPtrTraits&lt;T&gt;, typename X, typename Y&gt;
229 inline Ref&lt;T, U&gt; static_reference_cast(const Ref&lt;X, Y&gt;&amp; reference)
230 {
231     return Ref&lt;T, U&gt;(static_cast&lt;T&amp;&gt;(reference.copyRef().get()));
232 }
233 
234 template &lt;typename T, typename U&gt;
235 struct GetPtrHelper&lt;Ref&lt;T, U&gt;&gt; {
236     typedef T* PtrType;
237     static T* getPtr(const Ref&lt;T, U&gt;&amp; p) { return const_cast&lt;T*&gt;(p.ptr()); }
238 };
239 
240 template &lt;typename T, typename U&gt;
241 struct IsSmartPtr&lt;Ref&lt;T, U&gt;&gt; {
242     static const bool value = true;
243 };
244 
245 template&lt;typename T, typename U&gt;
246 inline Ref&lt;T, U&gt; adoptRef(T&amp; reference)
247 {
248     adopted(&amp;reference);
249     return Ref&lt;T, U&gt;(reference, Ref&lt;T, U&gt;::Adopt);
250 }
251 
252 template&lt;typename T&gt;
253 inline Ref&lt;T&gt; makeRef(T&amp; reference)
254 {
255     return Ref&lt;T&gt;(reference);
256 }
257 
258 template&lt;typename ExpectedType, typename ArgType, typename PtrTraits&gt;
259 inline bool is(Ref&lt;ArgType, PtrTraits&gt;&amp; source)
260 {
261     return is&lt;ExpectedType&gt;(source.get());
262 }
263 
264 template&lt;typename ExpectedType, typename ArgType, typename PtrTraits&gt;
265 inline bool is(const Ref&lt;ArgType, PtrTraits&gt;&amp; source)
266 {
267     return is&lt;ExpectedType&gt;(source.get());
268 }
269 
270 } // namespace WTF
271 
272 using WTF::Ref;
273 using WTF::adoptRef;
274 using WTF::makeRef;
275 using WTF::static_reference_cast;
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/Repatch.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RegisterSet.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Repatch.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/Repatch.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2011-2020 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 28,10 ***</span>
<span class="line-new-header">--- 28,11 ---</span>
  
  #if ENABLE(JIT)
  
  #include &quot;BinarySwitch.h&quot;
  #include &quot;CCallHelpers.h&quot;
<span class="line-added">+ #include &quot;CacheableIdentifierInlines.h&quot;</span>
  #include &quot;CallFrameShuffler.h&quot;
  #include &quot;DFGOperations.h&quot;
  #include &quot;DFGSpeculativeJIT.h&quot;
  #include &quot;DOMJITGetterSetter.h&quot;
  #include &quot;DirectArguments.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 62,11 ***</span>
  #include &quot;StructureStubClearingWatchpoint.h&quot;
  #include &quot;StructureStubInfo.h&quot;
  #include &quot;SuperSampler.h&quot;
  #include &quot;ThunkGenerators.h&quot;
  #include &quot;WebAssemblyFunction.h&quot;
<span class="line-removed">- #include &quot;WebAssemblyToJSCallee.h&quot;</span>
  #include &lt;wtf/CommaPrinter.h&gt;
  #include &lt;wtf/ListDump.h&gt;
  #include &lt;wtf/StringPrintStream.h&gt;
  
  namespace JSC {
<span class="line-new-header">--- 63,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 93,11 ***</span>
          FTL::Thunks&amp; thunks = *vm.ftlThunks;
          FunctionPtr&lt;OperationPtrTag&gt; target = MacroAssembler::readCallTarget&lt;OperationPtrTag&gt;(call);
          auto slowPathThunk = MacroAssemblerCodePtr&lt;JITThunkPtrTag&gt;::createFromExecutableAddress(target.retaggedExecutableAddress&lt;JITThunkPtrTag&gt;());
          FTL::SlowPathCallKey key = thunks.keyForSlowPathCallThunk(slowPathThunk);
          key = key.withCallTarget(newCalleeFunction);
<span class="line-modified">!         MacroAssembler::repatchCall(call, FunctionPtr&lt;OperationPtrTag&gt;(thunks.getSlowPathCallThunk(key).retaggedCode&lt;OperationPtrTag&gt;()));</span>
          return;
      }
  #else // ENABLE(FTL_JIT)
      UNUSED_PARAM(codeBlock);
  #endif // ENABLE(FTL_JIT)
<span class="line-new-header">--- 93,11 ---</span>
          FTL::Thunks&amp; thunks = *vm.ftlThunks;
          FunctionPtr&lt;OperationPtrTag&gt; target = MacroAssembler::readCallTarget&lt;OperationPtrTag&gt;(call);
          auto slowPathThunk = MacroAssemblerCodePtr&lt;JITThunkPtrTag&gt;::createFromExecutableAddress(target.retaggedExecutableAddress&lt;JITThunkPtrTag&gt;());
          FTL::SlowPathCallKey key = thunks.keyForSlowPathCallThunk(slowPathThunk);
          key = key.withCallTarget(newCalleeFunction);
<span class="line-modified">!         MacroAssembler::repatchCall(call, FunctionPtr&lt;OperationPtrTag&gt;(thunks.getSlowPathCallThunk(vm, key).retaggedCode&lt;OperationPtrTag&gt;()));</span>
          return;
      }
  #else // ENABLE(FTL_JIT)
      UNUSED_PARAM(codeBlock);
  #endif // ENABLE(FTL_JIT)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 130,11 ***</span>
          return GiveUpOnCache;
  
      return AttemptToCache;
  }
  
<span class="line-modified">! static bool forceICFailure(ExecState*)</span>
  {
      return Options::forceICFailure();
  }
  
  ALWAYS_INLINE static void fireWatchpointsAndClearStubIfNeeded(VM&amp; vm, StructureStubInfo&amp; stubInfo, CodeBlock* codeBlock, AccessGenerationResult&amp; result)
<span class="line-new-header">--- 130,11 ---</span>
          return GiveUpOnCache;
  
      return AttemptToCache;
  }
  
<span class="line-modified">! static bool forceICFailure(JSGlobalObject*)</span>
  {
      return Options::forceICFailure();
  }
  
  ALWAYS_INLINE static void fireWatchpointsAndClearStubIfNeeded(VM&amp; vm, StructureStubInfo&amp; stubInfo, CodeBlock* codeBlock, AccessGenerationResult&amp; result)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 143,104 ***</span>
          result.fireWatchpoints(vm);
          stubInfo.reset(codeBlock);
      }
  }
  
<span class="line-modified">! inline FunctionPtr&lt;CFunctionPtrTag&gt; appropriateOptimizingGetByIdFunction(GetByIDKind kind)</span>
  {
      switch (kind) {
<span class="line-modified">!     case GetByIDKind::Normal:</span>
          return operationGetByIdOptimize;
<span class="line-modified">!     case GetByIDKind::WithThis:</span>
          return operationGetByIdWithThisOptimize;
<span class="line-modified">!     case GetByIDKind::Try:</span>
          return operationTryGetByIdOptimize;
<span class="line-modified">!     case GetByIDKind::Direct:</span>
          return operationGetByIdDirectOptimize;
      }
<span class="line-modified">!     ASSERT_NOT_REACHED();</span>
<span class="line-removed">-     return operationGetById;</span>
  }
  
<span class="line-modified">! inline FunctionPtr&lt;CFunctionPtrTag&gt; appropriateGetByIdFunction(GetByIDKind kind)</span>
  {
      switch (kind) {
<span class="line-modified">!     case GetByIDKind::Normal:</span>
          return operationGetById;
<span class="line-modified">!     case GetByIDKind::WithThis:</span>
          return operationGetByIdWithThis;
<span class="line-modified">!     case GetByIDKind::Try:</span>
          return operationTryGetById;
<span class="line-modified">!     case GetByIDKind::Direct:</span>
          return operationGetByIdDirect;
      }
<span class="line-modified">!     ASSERT_NOT_REACHED();</span>
<span class="line-removed">-     return operationGetById;</span>
  }
  
<span class="line-modified">! static InlineCacheAction tryCacheGetByID(ExecState* exec, JSValue baseValue, const Identifier&amp; propertyName, const PropertySlot&amp; slot, StructureStubInfo&amp; stubInfo, GetByIDKind kind)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      AccessGenerationResult result;
  
      {
<span class="line-modified">!         GCSafeConcurrentJSLocker locker(exec-&gt;codeBlock()-&gt;m_lock, exec-&gt;vm().heap);</span>
  
<span class="line-modified">!         if (forceICFailure(exec))</span>
              return GiveUpOnCache;
  
          // FIXME: Cache property access for immediates.
          if (!baseValue.isCell())
              return GiveUpOnCache;
          JSCell* baseCell = baseValue.asCell();
  
<span class="line-removed">-         CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">- </span>
          std::unique_ptr&lt;AccessCase&gt; newCase;
  
          if (propertyName == vm.propertyNames-&gt;length) {
              if (isJSArray(baseCell)) {
<span class="line-modified">!                 if (stubInfo.cacheType == CacheType::Unset</span>
                      &amp;&amp; slot.slotBase() == baseCell
                      &amp;&amp; InlineAccess::isCacheableArrayLength(stubInfo, jsCast&lt;JSArray*&gt;(baseCell))) {
  
                      bool generatedCodeInline = InlineAccess::generateArrayLength(stubInfo, jsCast&lt;JSArray*&gt;(baseCell));
                      if (generatedCodeInline) {
<span class="line-modified">!                         ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation(), appropriateOptimizingGetByIdFunction(kind));</span>
                          stubInfo.initArrayLength();
                          return RetryCacheLater;
                      }
                  }
  
<span class="line-modified">!                 newCase = AccessCase::create(vm, codeBlock, AccessCase::ArrayLength);</span>
              } else if (isJSString(baseCell)) {
<span class="line-modified">!                 if (stubInfo.cacheType == CacheType::Unset &amp;&amp; InlineAccess::isCacheableStringLength(stubInfo)) {</span>
                      bool generatedCodeInline = InlineAccess::generateStringLength(stubInfo);
                      if (generatedCodeInline) {
<span class="line-modified">!                         ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation(), appropriateOptimizingGetByIdFunction(kind));</span>
                          stubInfo.initStringLength();
                          return RetryCacheLater;
                      }
                  }
  
<span class="line-modified">!                 newCase = AccessCase::create(vm, codeBlock, AccessCase::StringLength);</span>
<span class="line-modified">!             }</span>
<span class="line-removed">-             else if (DirectArguments* arguments = jsDynamicCast&lt;DirectArguments*&gt;(vm, baseCell)) {</span>
                  // If there were overrides, then we can handle this as a normal property load! Guarding
                  // this with such a check enables us to add an IC case for that load if needed.
                  if (!arguments-&gt;overrodeThings())
<span class="line-modified">!                     newCase = AccessCase::create(vm, codeBlock, AccessCase::DirectArgumentsLength);</span>
              } else if (ScopedArguments* arguments = jsDynamicCast&lt;ScopedArguments*&gt;(vm, baseCell)) {
                  // Ditto.
                  if (!arguments-&gt;overrodeThings())
<span class="line-modified">!                     newCase = AccessCase::create(vm, codeBlock, AccessCase::ScopedArgumentsLength);</span>
              }
          }
  
          if (!propertyName.isSymbol() &amp;&amp; baseCell-&gt;inherits&lt;JSModuleNamespaceObject&gt;(vm) &amp;&amp; !slot.isUnset()) {
              if (auto moduleNamespaceSlot = slot.moduleNamespaceSlot())
<span class="line-modified">!                 newCase = ModuleNamespaceAccessCase::create(vm, codeBlock, jsCast&lt;JSModuleNamespaceObject*&gt;(baseCell), moduleNamespaceSlot-&gt;environment, ScopeOffset(moduleNamespaceSlot-&gt;scopeOffset));</span>
          }
  
          if (!newCase) {
              if (!slot.isCacheable() &amp;&amp; !slot.isUnset())
                  return GiveUpOnCache;
<span class="line-new-header">--- 143,103 ---</span>
          result.fireWatchpoints(vm);
          stubInfo.reset(codeBlock);
      }
  }
  
<span class="line-modified">! inline FunctionPtr&lt;CFunctionPtrTag&gt; appropriateOptimizingGetByFunction(GetByKind kind)</span>
  {
      switch (kind) {
<span class="line-modified">!     case GetByKind::Normal:</span>
          return operationGetByIdOptimize;
<span class="line-modified">!     case GetByKind::WithThis:</span>
          return operationGetByIdWithThisOptimize;
<span class="line-modified">!     case GetByKind::Try:</span>
          return operationTryGetByIdOptimize;
<span class="line-modified">!     case GetByKind::Direct:</span>
          return operationGetByIdDirectOptimize;
<span class="line-added">+     case GetByKind::NormalByVal:</span>
<span class="line-added">+         return operationGetByValOptimize;</span>
      }
<span class="line-modified">!     RELEASE_ASSERT_NOT_REACHED();</span>
  }
  
<span class="line-modified">! inline FunctionPtr&lt;CFunctionPtrTag&gt; appropriateGetByFunction(GetByKind kind)</span>
  {
      switch (kind) {
<span class="line-modified">!     case GetByKind::Normal:</span>
          return operationGetById;
<span class="line-modified">!     case GetByKind::WithThis:</span>
          return operationGetByIdWithThis;
<span class="line-modified">!     case GetByKind::Try:</span>
          return operationTryGetById;
<span class="line-modified">!     case GetByKind::Direct:</span>
          return operationGetByIdDirect;
<span class="line-added">+     case GetByKind::NormalByVal:</span>
<span class="line-added">+         return operationGetByValGeneric;</span>
      }
<span class="line-modified">!     RELEASE_ASSERT_NOT_REACHED();</span>
  }
  
<span class="line-modified">! static InlineCacheAction tryCacheGetBy(JSGlobalObject* globalObject, CodeBlock* codeBlock, JSValue baseValue, CacheableIdentifier propertyName, const PropertySlot&amp; slot, StructureStubInfo&amp; stubInfo, GetByKind kind)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      AccessGenerationResult result;
  
      {
<span class="line-modified">!         GCSafeConcurrentJSLocker locker(codeBlock-&gt;m_lock, globalObject-&gt;vm().heap);</span>
  
<span class="line-modified">!         if (forceICFailure(globalObject))</span>
              return GiveUpOnCache;
  
          // FIXME: Cache property access for immediates.
          if (!baseValue.isCell())
              return GiveUpOnCache;
          JSCell* baseCell = baseValue.asCell();
  
          std::unique_ptr&lt;AccessCase&gt; newCase;
  
          if (propertyName == vm.propertyNames-&gt;length) {
              if (isJSArray(baseCell)) {
<span class="line-modified">!                 if (stubInfo.cacheType() == CacheType::Unset</span>
                      &amp;&amp; slot.slotBase() == baseCell
                      &amp;&amp; InlineAccess::isCacheableArrayLength(stubInfo, jsCast&lt;JSArray*&gt;(baseCell))) {
  
                      bool generatedCodeInline = InlineAccess::generateArrayLength(stubInfo, jsCast&lt;JSArray*&gt;(baseCell));
                      if (generatedCodeInline) {
<span class="line-modified">!                         ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation, appropriateOptimizingGetByFunction(kind));</span>
                          stubInfo.initArrayLength();
                          return RetryCacheLater;
                      }
                  }
  
<span class="line-modified">!                 newCase = AccessCase::create(vm, codeBlock, AccessCase::ArrayLength, propertyName);</span>
              } else if (isJSString(baseCell)) {
<span class="line-modified">!                 if (stubInfo.cacheType() == CacheType::Unset &amp;&amp; InlineAccess::isCacheableStringLength(stubInfo)) {</span>
                      bool generatedCodeInline = InlineAccess::generateStringLength(stubInfo);
                      if (generatedCodeInline) {
<span class="line-modified">!                         ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation, appropriateOptimizingGetByFunction(kind));</span>
                          stubInfo.initStringLength();
                          return RetryCacheLater;
                      }
                  }
  
<span class="line-modified">!                 newCase = AccessCase::create(vm, codeBlock, AccessCase::StringLength, propertyName);</span>
<span class="line-modified">!             } else if (DirectArguments* arguments = jsDynamicCast&lt;DirectArguments*&gt;(vm, baseCell)) {</span>
                  // If there were overrides, then we can handle this as a normal property load! Guarding
                  // this with such a check enables us to add an IC case for that load if needed.
                  if (!arguments-&gt;overrodeThings())
<span class="line-modified">!                     newCase = AccessCase::create(vm, codeBlock, AccessCase::DirectArgumentsLength, propertyName);</span>
              } else if (ScopedArguments* arguments = jsDynamicCast&lt;ScopedArguments*&gt;(vm, baseCell)) {
                  // Ditto.
                  if (!arguments-&gt;overrodeThings())
<span class="line-modified">!                     newCase = AccessCase::create(vm, codeBlock, AccessCase::ScopedArgumentsLength, propertyName);</span>
              }
          }
  
          if (!propertyName.isSymbol() &amp;&amp; baseCell-&gt;inherits&lt;JSModuleNamespaceObject&gt;(vm) &amp;&amp; !slot.isUnset()) {
              if (auto moduleNamespaceSlot = slot.moduleNamespaceSlot())
<span class="line-modified">!                 newCase = ModuleNamespaceAccessCase::create(vm, codeBlock, propertyName, jsCast&lt;JSModuleNamespaceObject*&gt;(baseCell), moduleNamespaceSlot-&gt;environment, ScopeOffset(moduleNamespaceSlot-&gt;scopeOffset));</span>
          }
  
          if (!newCase) {
              if (!slot.isCacheable() &amp;&amp; !slot.isUnset())
                  return GiveUpOnCache;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 259,156 ***</span>
              InlineCacheAction action = actionForCell(vm, baseCell);
              if (action != AttemptToCache)
                  return action;
  
              // Optimize self access.
<span class="line-modified">!             if (stubInfo.cacheType == CacheType::Unset</span>
                  &amp;&amp; slot.isCacheableValue()
                  &amp;&amp; slot.slotBase() == baseValue
                  &amp;&amp; !slot.watchpointSet()
                  &amp;&amp; !structure-&gt;needImpurePropertyWatchpoint()
                  &amp;&amp; !loadTargetFromProxy) {
  
                  bool generatedCodeInline = InlineAccess::generateSelfPropertyAccess(stubInfo, structure, slot.cachedOffset());
                  if (generatedCodeInline) {
<span class="line-modified">!                     LOG_IC((ICEvent::GetByIdSelfPatch, structure-&gt;classInfo(), propertyName, slot.slotBase() == baseValue));</span>
                      structure-&gt;startWatchingPropertyForReplacements(vm, slot.cachedOffset());
<span class="line-modified">!                     ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation(), appropriateOptimizingGetByIdFunction(kind));</span>
<span class="line-modified">!                     stubInfo.initGetByIdSelf(codeBlock, structure, slot.cachedOffset());</span>
                      return RetryCacheLater;
                  }
              }
  
              std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain;
  
              PropertyOffset offset = slot.isUnset() ? invalidOffset : slot.cachedOffset();
  
              if (slot.isUnset() || slot.slotBase() != baseValue) {
                  if (structure-&gt;typeInfo().prohibitsPropertyCaching())
                      return GiveUpOnCache;
  
                  if (structure-&gt;isDictionary()) {
                      if (structure-&gt;hasBeenFlattenedBefore())
                          return GiveUpOnCache;
                      structure-&gt;flattenDictionaryStructure(vm, jsCast&lt;JSObject*&gt;(baseCell));
                  }
  
                  if (slot.isUnset() &amp;&amp; structure-&gt;typeInfo().getOwnPropertySlotIsImpureForPropertyAbsence())
                      return GiveUpOnCache;
  
<span class="line-modified">!                 // If a kind is GetByIDKind::Direct, we do not need to investigate prototype chains further.</span>
                  // Cacheability just depends on the head structure.
<span class="line-modified">!                 if (kind != GetByIDKind::Direct) {</span>
<span class="line-modified">!                     bool usesPolyProto;</span>
<span class="line-modified">!                     prototypeAccessChain = PolyProtoAccessChain::create(exec-&gt;lexicalGlobalObject(), baseCell, slot, usesPolyProto);</span>
<span class="line-removed">-                     if (!prototypeAccessChain) {</span>
<span class="line-removed">-                         // It&#39;s invalid to access this prototype property.</span>
                          return GiveUpOnCache;
                      }
  
<span class="line-modified">!                     if (!usesPolyProto) {</span>
                          // We use ObjectPropertyConditionSet instead for faster accesses.
                          prototypeAccessChain = nullptr;
  
                          // FIXME: Maybe this `if` should be inside generateConditionsForPropertyBlah.
                          // https://bugs.webkit.org/show_bug.cgi?id=185215
                          if (slot.isUnset()) {
                              conditionSet = generateConditionsForPropertyMiss(
<span class="line-modified">!                                 vm, codeBlock, exec, structure, propertyName.impl());</span>
                          } else if (!slot.isCacheableCustom()) {
                              conditionSet = generateConditionsForPrototypePropertyHit(
<span class="line-modified">!                                 vm, codeBlock, exec, structure, slot.slotBase(),</span>
<span class="line-modified">!                                 propertyName.impl());</span>
                          } else {
                              conditionSet = generateConditionsForPrototypePropertyHitCustom(
<span class="line-modified">!                                 vm, codeBlock, exec, structure, slot.slotBase(),</span>
<span class="line-modified">!                                 propertyName.impl());</span>
                          }
  
                          if (!conditionSet.isValid())
                              return GiveUpOnCache;
                      }
                  }
<span class="line-removed">- </span>
<span class="line-removed">-                 offset = slot.isUnset() ? invalidOffset : slot.cachedOffset();</span>
              }
  
              JSFunction* getter = nullptr;
              if (slot.isCacheableGetter())
                  getter = jsDynamicCast&lt;JSFunction*&gt;(vm, slot.getterSetter()-&gt;getter());
  
              Optional&lt;DOMAttributeAnnotation&gt; domAttribute;
              if (slot.isCacheableCustom() &amp;&amp; slot.domAttribute())
                  domAttribute = slot.domAttribute();
  
<span class="line-modified">!             if (kind == GetByIDKind::Try) {</span>
                  AccessCase::AccessType type;
                  if (slot.isCacheableValue())
                      type = AccessCase::Load;
                  else if (slot.isUnset())
                      type = AccessCase::Miss;
                  else if (slot.isCacheableGetter())
                      type = AccessCase::GetGetter;
                  else
                      RELEASE_ASSERT_NOT_REACHED();
  
<span class="line-modified">!                 newCase = ProxyableAccessCase::create(vm, codeBlock, type, offset, structure, conditionSet, loadTargetFromProxy, slot.watchpointSet(), WTFMove(prototypeAccessChain));</span>
              } else if (!loadTargetFromProxy &amp;&amp; getter &amp;&amp; IntrinsicGetterAccessCase::canEmitIntrinsicGetter(getter, structure))
<span class="line-modified">!                 newCase = IntrinsicGetterAccessCase::create(vm, codeBlock, slot.cachedOffset(), structure, conditionSet, getter, WTFMove(prototypeAccessChain));</span>
              else {
                  if (slot.isCacheableValue() || slot.isUnset()) {
                      newCase = ProxyableAccessCase::create(vm, codeBlock, slot.isUnset() ? AccessCase::Miss : AccessCase::Load,
<span class="line-modified">!                         offset, structure, conditionSet, loadTargetFromProxy, slot.watchpointSet(), WTFMove(prototypeAccessChain));</span>
                  } else {
                      AccessCase::AccessType type;
                      if (slot.isCacheableGetter())
                          type = AccessCase::Getter;
                      else if (slot.attributes() &amp; PropertyAttribute::CustomAccessor)
                          type = AccessCase::CustomAccessorGetter;
                      else
                          type = AccessCase::CustomValueGetter;
  
<span class="line-modified">!                     if (kind == GetByIDKind::WithThis &amp;&amp; type == AccessCase::CustomAccessorGetter &amp;&amp; domAttribute)</span>
                          return GiveUpOnCache;
  
                      newCase = GetterSetterAccessCase::create(
<span class="line-modified">!                         vm, codeBlock, type, offset, structure, conditionSet, loadTargetFromProxy,</span>
                          slot.watchpointSet(), slot.isCacheableCustom() ? slot.customGetter() : nullptr,
                          slot.isCacheableCustom() &amp;&amp; slot.slotBase() != baseValue ? slot.slotBase() : nullptr,
                          domAttribute, WTFMove(prototypeAccessChain));
                  }
              }
          }
  
<span class="line-modified">!         LOG_IC((ICEvent::GetByIdAddAccessCase, baseValue.classInfoOrNull(vm), propertyName, slot.slotBase() == baseValue));</span>
  
          result = stubInfo.addAccessCase(locker, codeBlock, propertyName, WTFMove(newCase));
  
          if (result.generatedSomeCode()) {
<span class="line-modified">!             LOG_IC((ICEvent::GetByIdReplaceWithJump, baseValue.classInfoOrNull(vm), propertyName, slot.slotBase() == baseValue));</span>
  
              RELEASE_ASSERT(result.code());
              InlineAccess::rewireStubAsJump(stubInfo, CodeLocationLabel&lt;JITStubRoutinePtrTag&gt;(result.code()));
          }
      }
  
<span class="line-modified">!     fireWatchpointsAndClearStubIfNeeded(vm, stubInfo, exec-&gt;codeBlock(), result);</span>
  
      return result.shouldGiveUpNow() ? GiveUpOnCache : RetryCacheLater;
  }
  
<span class="line-modified">! void repatchGetByID(ExecState* exec, JSValue baseValue, const Identifier&amp; propertyName, const PropertySlot&amp; slot, StructureStubInfo&amp; stubInfo, GetByIDKind kind)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
<span class="line-modified">!     if (tryCacheGetByID(exec, baseValue, propertyName, slot, stubInfo, kind) == GiveUpOnCache) {</span>
<span class="line-modified">!         CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-modified">!         ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation(), appropriateGetByIdFunction(kind));</span>
      }
  }
  
<span class="line-modified">! static V_JITOperation_ESsiJJI appropriateGenericPutByIdFunction(const PutPropertySlot &amp;slot, PutKind putKind)</span>
  {
      if (slot.isStrictMode()) {
          if (putKind == Direct)
              return operationPutByIdDirectStrict;
          return operationPutByIdStrict;
<span class="line-new-header">--- 258,266 ---</span>
              InlineCacheAction action = actionForCell(vm, baseCell);
              if (action != AttemptToCache)
                  return action;
  
              // Optimize self access.
<span class="line-modified">!             if (stubInfo.cacheType() == CacheType::Unset</span>
                  &amp;&amp; slot.isCacheableValue()
                  &amp;&amp; slot.slotBase() == baseValue
                  &amp;&amp; !slot.watchpointSet()
                  &amp;&amp; !structure-&gt;needImpurePropertyWatchpoint()
                  &amp;&amp; !loadTargetFromProxy) {
  
                  bool generatedCodeInline = InlineAccess::generateSelfPropertyAccess(stubInfo, structure, slot.cachedOffset());
                  if (generatedCodeInline) {
<span class="line-modified">!                     LOG_IC((ICEvent::GetBySelfPatch, structure-&gt;classInfo(), Identifier::fromUid(vm, propertyName.uid()), slot.slotBase() == baseValue));</span>
                      structure-&gt;startWatchingPropertyForReplacements(vm, slot.cachedOffset());
<span class="line-modified">!                     ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation, appropriateOptimizingGetByFunction(kind));</span>
<span class="line-modified">!                     stubInfo.initGetByIdSelf(codeBlock, structure, slot.cachedOffset(), propertyName);</span>
                      return RetryCacheLater;
                  }
              }
  
              std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain;
  
              PropertyOffset offset = slot.isUnset() ? invalidOffset : slot.cachedOffset();
  
<span class="line-added">+             if (slot.isCustom() &amp;&amp; slot.slotBase() == baseValue) {</span>
<span class="line-added">+                 // To cache self customs, we must disallow dictionaries because we</span>
<span class="line-added">+                 // need to be informed if the custom goes away since we cache the</span>
<span class="line-added">+                 // constant function pointer.</span>
<span class="line-added">+ </span>
<span class="line-added">+                 if (!prepareChainForCaching(globalObject, slot.slotBase(), slot.slotBase()))</span>
<span class="line-added">+                     return GiveUpOnCache;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
              if (slot.isUnset() || slot.slotBase() != baseValue) {
                  if (structure-&gt;typeInfo().prohibitsPropertyCaching())
                      return GiveUpOnCache;
  
                  if (structure-&gt;isDictionary()) {
                      if (structure-&gt;hasBeenFlattenedBefore())
                          return GiveUpOnCache;
                      structure-&gt;flattenDictionaryStructure(vm, jsCast&lt;JSObject*&gt;(baseCell));
<span class="line-added">+                     return RetryCacheLater; // We may have changed property offsets.</span>
                  }
  
                  if (slot.isUnset() &amp;&amp; structure-&gt;typeInfo().getOwnPropertySlotIsImpureForPropertyAbsence())
                      return GiveUpOnCache;
  
<span class="line-modified">!                 // If a kind is GetByKind::Direct, we do not need to investigate prototype chains further.</span>
                  // Cacheability just depends on the head structure.
<span class="line-modified">!                 if (kind != GetByKind::Direct) {</span>
<span class="line-modified">!                     auto cacheStatus = prepareChainForCaching(globalObject, baseCell, slot);</span>
<span class="line-modified">!                     if (!cacheStatus)</span>
                          return GiveUpOnCache;
<span class="line-added">+ </span>
<span class="line-added">+                     if (cacheStatus-&gt;flattenedDictionary) {</span>
<span class="line-added">+                         // Property offsets may have changed due to flattening. We&#39;ll cache later.</span>
<span class="line-added">+                         return RetryCacheLater;</span>
                      }
  
<span class="line-modified">!                     if (cacheStatus-&gt;usesPolyProto) {</span>
<span class="line-added">+                         prototypeAccessChain = PolyProtoAccessChain::create(globalObject, baseCell, slot);</span>
<span class="line-added">+                         if (!prototypeAccessChain)</span>
<span class="line-added">+                             return GiveUpOnCache;</span>
<span class="line-added">+                         RELEASE_ASSERT(slot.isCacheableCustom() || prototypeAccessChain-&gt;slotBaseStructure(vm, structure)-&gt;get(vm, propertyName.uid()) == offset);</span>
<span class="line-added">+                     } else {</span>
                          // We use ObjectPropertyConditionSet instead for faster accesses.
                          prototypeAccessChain = nullptr;
  
                          // FIXME: Maybe this `if` should be inside generateConditionsForPropertyBlah.
                          // https://bugs.webkit.org/show_bug.cgi?id=185215
                          if (slot.isUnset()) {
                              conditionSet = generateConditionsForPropertyMiss(
<span class="line-modified">!                                 vm, codeBlock, globalObject, structure, propertyName.uid());</span>
                          } else if (!slot.isCacheableCustom()) {
                              conditionSet = generateConditionsForPrototypePropertyHit(
<span class="line-modified">!                                 vm, codeBlock, globalObject, structure, slot.slotBase(),</span>
<span class="line-modified">!                                 propertyName.uid());</span>
<span class="line-added">+                             RELEASE_ASSERT(!conditionSet.isValid() || conditionSet.slotBaseCondition().offset() == offset);</span>
                          } else {
                              conditionSet = generateConditionsForPrototypePropertyHitCustom(
<span class="line-modified">!                                 vm, codeBlock, globalObject, structure, slot.slotBase(),</span>
<span class="line-modified">!                                 propertyName.uid(), slot.attributes());</span>
                          }
  
                          if (!conditionSet.isValid())
                              return GiveUpOnCache;
                      }
                  }
              }
  
              JSFunction* getter = nullptr;
              if (slot.isCacheableGetter())
                  getter = jsDynamicCast&lt;JSFunction*&gt;(vm, slot.getterSetter()-&gt;getter());
  
              Optional&lt;DOMAttributeAnnotation&gt; domAttribute;
              if (slot.isCacheableCustom() &amp;&amp; slot.domAttribute())
                  domAttribute = slot.domAttribute();
  
<span class="line-modified">!             if (kind == GetByKind::Try) {</span>
                  AccessCase::AccessType type;
                  if (slot.isCacheableValue())
                      type = AccessCase::Load;
                  else if (slot.isUnset())
                      type = AccessCase::Miss;
                  else if (slot.isCacheableGetter())
                      type = AccessCase::GetGetter;
                  else
                      RELEASE_ASSERT_NOT_REACHED();
  
<span class="line-modified">!                 newCase = ProxyableAccessCase::create(vm, codeBlock, type, propertyName, offset, structure, conditionSet, loadTargetFromProxy, slot.watchpointSet(), WTFMove(prototypeAccessChain));</span>
              } else if (!loadTargetFromProxy &amp;&amp; getter &amp;&amp; IntrinsicGetterAccessCase::canEmitIntrinsicGetter(getter, structure))
<span class="line-modified">!                 newCase = IntrinsicGetterAccessCase::create(vm, codeBlock, propertyName, slot.cachedOffset(), structure, conditionSet, getter, WTFMove(prototypeAccessChain));</span>
              else {
                  if (slot.isCacheableValue() || slot.isUnset()) {
                      newCase = ProxyableAccessCase::create(vm, codeBlock, slot.isUnset() ? AccessCase::Miss : AccessCase::Load,
<span class="line-modified">!                         propertyName, offset, structure, conditionSet, loadTargetFromProxy, slot.watchpointSet(), WTFMove(prototypeAccessChain));</span>
                  } else {
                      AccessCase::AccessType type;
                      if (slot.isCacheableGetter())
                          type = AccessCase::Getter;
                      else if (slot.attributes() &amp; PropertyAttribute::CustomAccessor)
                          type = AccessCase::CustomAccessorGetter;
                      else
                          type = AccessCase::CustomValueGetter;
  
<span class="line-modified">!                     if (kind == GetByKind::WithThis &amp;&amp; type == AccessCase::CustomAccessorGetter &amp;&amp; domAttribute)</span>
                          return GiveUpOnCache;
  
                      newCase = GetterSetterAccessCase::create(
<span class="line-modified">!                         vm, codeBlock, type, propertyName, offset, structure, conditionSet, loadTargetFromProxy,</span>
                          slot.watchpointSet(), slot.isCacheableCustom() ? slot.customGetter() : nullptr,
                          slot.isCacheableCustom() &amp;&amp; slot.slotBase() != baseValue ? slot.slotBase() : nullptr,
                          domAttribute, WTFMove(prototypeAccessChain));
                  }
              }
          }
  
<span class="line-modified">!         LOG_IC((ICEvent::GetByAddAccessCase, baseValue.classInfoOrNull(vm), Identifier::fromUid(vm, propertyName.uid()), slot.slotBase() == baseValue));</span>
  
          result = stubInfo.addAccessCase(locker, codeBlock, propertyName, WTFMove(newCase));
  
          if (result.generatedSomeCode()) {
<span class="line-modified">!             LOG_IC((ICEvent::GetByReplaceWithJump, baseValue.classInfoOrNull(vm), Identifier::fromUid(vm, propertyName.uid()), slot.slotBase() == baseValue));</span>
  
              RELEASE_ASSERT(result.code());
              InlineAccess::rewireStubAsJump(stubInfo, CodeLocationLabel&lt;JITStubRoutinePtrTag&gt;(result.code()));
          }
      }
  
<span class="line-modified">!     fireWatchpointsAndClearStubIfNeeded(vm, stubInfo, codeBlock, result);</span>
  
      return result.shouldGiveUpNow() ? GiveUpOnCache : RetryCacheLater;
  }
  
<span class="line-modified">! void repatchGetBy(JSGlobalObject* globalObject, CodeBlock* codeBlock, JSValue baseValue, CacheableIdentifier propertyName, const PropertySlot&amp; slot, StructureStubInfo&amp; stubInfo, GetByKind kind)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
<span class="line-modified">!     if (tryCacheGetBy(globalObject, codeBlock, baseValue, propertyName, slot, stubInfo, kind) == GiveUpOnCache)</span>
<span class="line-modified">!         ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation, appropriateGetByFunction(kind));</span>
<span class="line-modified">! }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ static InlineCacheAction tryCacheArrayGetByVal(JSGlobalObject* globalObject, CodeBlock* codeBlock, JSValue baseValue, JSValue index, StructureStubInfo&amp; stubInfo)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!baseValue.isCell())</span>
<span class="line-added">+         return GiveUpOnCache;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!index.isInt32())</span>
<span class="line-added">+         return RetryCacheLater;</span>
<span class="line-added">+ </span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     AccessGenerationResult result;</span>
<span class="line-added">+ </span>
<span class="line-added">+     {</span>
<span class="line-added">+         GCSafeConcurrentJSLocker locker(codeBlock-&gt;m_lock, globalObject-&gt;vm().heap);</span>
<span class="line-added">+ </span>
<span class="line-added">+         JSCell* base = baseValue.asCell();</span>
<span class="line-added">+ </span>
<span class="line-added">+         AccessCase::AccessType accessType;</span>
<span class="line-added">+         if (base-&gt;type() == DirectArgumentsType)</span>
<span class="line-added">+             accessType = AccessCase::IndexedDirectArgumentsLoad;</span>
<span class="line-added">+         else if (base-&gt;type() == ScopedArgumentsType)</span>
<span class="line-added">+             accessType = AccessCase::IndexedScopedArgumentsLoad;</span>
<span class="line-added">+         else if (base-&gt;type() == StringType)</span>
<span class="line-added">+             accessType = AccessCase::IndexedStringLoad;</span>
<span class="line-added">+         else if (isTypedView(base-&gt;classInfo(vm)-&gt;typedArrayStorageType)) {</span>
<span class="line-added">+             switch (base-&gt;classInfo(vm)-&gt;typedArrayStorageType) {</span>
<span class="line-added">+             case TypeInt8:</span>
<span class="line-added">+                 accessType = AccessCase::IndexedTypedArrayInt8Load;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case TypeUint8:</span>
<span class="line-added">+                 accessType = AccessCase::IndexedTypedArrayUint8Load;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case TypeUint8Clamped:</span>
<span class="line-added">+                 accessType = AccessCase::IndexedTypedArrayUint8ClampedLoad;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case TypeInt16:</span>
<span class="line-added">+                 accessType = AccessCase::IndexedTypedArrayInt16Load;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case TypeUint16:</span>
<span class="line-added">+                 accessType = AccessCase::IndexedTypedArrayUint16Load;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case TypeInt32:</span>
<span class="line-added">+                 accessType = AccessCase::IndexedTypedArrayInt32Load;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case TypeUint32:</span>
<span class="line-added">+                 accessType = AccessCase::IndexedTypedArrayUint32Load;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case TypeFloat32:</span>
<span class="line-added">+                 accessType = AccessCase::IndexedTypedArrayFloat32Load;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case TypeFloat64:</span>
<span class="line-added">+                 accessType = AccessCase::IndexedTypedArrayFloat64Load;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             IndexingType indexingShape = base-&gt;indexingType() &amp; IndexingShapeMask;</span>
<span class="line-added">+             switch (indexingShape) {</span>
<span class="line-added">+             case Int32Shape:</span>
<span class="line-added">+                 accessType = AccessCase::IndexedInt32Load;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case DoubleShape:</span>
<span class="line-added">+                 accessType = AccessCase::IndexedDoubleLoad;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case ContiguousShape:</span>
<span class="line-added">+                 accessType = AccessCase::IndexedContiguousLoad;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case ArrayStorageShape:</span>
<span class="line-added">+                 accessType = AccessCase::IndexedArrayStorageLoad;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 return GiveUpOnCache;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         result = stubInfo.addAccessCase(locker, codeBlock, nullptr, AccessCase::create(vm, codeBlock, accessType, nullptr));</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (result.generatedSomeCode()) {</span>
<span class="line-added">+             LOG_IC((ICEvent::GetByReplaceWithJump, baseValue.classInfoOrNull(vm), Identifier()));</span>
<span class="line-added">+ </span>
<span class="line-added">+             RELEASE_ASSERT(result.code());</span>
<span class="line-added">+             InlineAccess::rewireStubAsJump(stubInfo, CodeLocationLabel&lt;JITStubRoutinePtrTag&gt;(result.code()));</span>
<span class="line-added">+         }</span>
      }
<span class="line-added">+ </span>
<span class="line-added">+     fireWatchpointsAndClearStubIfNeeded(vm, stubInfo, codeBlock, result);</span>
<span class="line-added">+     return result.shouldGiveUpNow() ? GiveUpOnCache : RetryCacheLater;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void repatchArrayGetByVal(JSGlobalObject* globalObject, CodeBlock* codeBlock, JSValue base, JSValue index, StructureStubInfo&amp; stubInfo)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (tryCacheArrayGetByVal(globalObject, codeBlock, base, index, stubInfo) == GiveUpOnCache)</span>
<span class="line-added">+         ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation, operationGetByValGeneric);</span>
  }
  
<span class="line-modified">! static V_JITOperation_GSsiJJI appropriateGenericPutByIdFunction(const PutPropertySlot &amp;slot, PutKind putKind)</span>
  {
      if (slot.isStrictMode()) {
          if (putKind == Direct)
              return operationPutByIdDirectStrict;
          return operationPutByIdStrict;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 416,11 ***</span>
      if (putKind == Direct)
          return operationPutByIdDirectNonStrict;
      return operationPutByIdNonStrict;
  }
  
<span class="line-modified">! static V_JITOperation_ESsiJJI appropriateOptimizingPutByIdFunction(const PutPropertySlot &amp;slot, PutKind putKind)</span>
  {
      if (slot.isStrictMode()) {
          if (putKind == Direct)
              return operationPutByIdDirectStrictOptimize;
          return operationPutByIdStrictOptimize;
<span class="line-new-header">--- 525,11 ---</span>
      if (putKind == Direct)
          return operationPutByIdDirectNonStrict;
      return operationPutByIdNonStrict;
  }
  
<span class="line-modified">! static V_JITOperation_GSsiJJI appropriateOptimizingPutByIdFunction(const PutPropertySlot &amp;slot, PutKind putKind)</span>
  {
      if (slot.isStrictMode()) {
          if (putKind == Direct)
              return operationPutByIdDirectStrictOptimize;
          return operationPutByIdStrictOptimize;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 428,35 ***</span>
      if (putKind == Direct)
          return operationPutByIdDirectNonStrictOptimize;
      return operationPutByIdNonStrictOptimize;
  }
  
<span class="line-modified">! static InlineCacheAction tryCachePutByID(ExecState* exec, JSValue baseValue, Structure* structure, const Identifier&amp; ident, const PutPropertySlot&amp; slot, StructureStubInfo&amp; stubInfo, PutKind putKind)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      AccessGenerationResult result;
      {
<span class="line-modified">!         GCSafeConcurrentJSLocker locker(exec-&gt;codeBlock()-&gt;m_lock, exec-&gt;vm().heap);</span>
  
<span class="line-modified">!         if (forceICFailure(exec))</span>
              return GiveUpOnCache;
  
<span class="line-removed">-         CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">- </span>
          if (!baseValue.isCell())
              return GiveUpOnCache;
  
          if (!slot.isCacheablePut() &amp;&amp; !slot.isCacheableCustom() &amp;&amp; !slot.isCacheableSetter())
              return GiveUpOnCache;
  
          // FIXME: We should try to do something smarter here...
<span class="line-modified">!         if (isCopyOnWrite(structure-&gt;indexingMode()))</span>
              return GiveUpOnCache;
          // We can&#39;t end up storing to a CoW on the prototype since it shouldn&#39;t own properties.
          ASSERT(!isCopyOnWrite(slot.base()-&gt;indexingMode()));
  
<span class="line-modified">!         if (!structure-&gt;propertyAccessesAreCacheable())</span>
              return GiveUpOnCache;
  
          std::unique_ptr&lt;AccessCase&gt; newCase;
          JSCell* baseCell = baseValue.asCell();
  
<span class="line-new-header">--- 537,33 ---</span>
      if (putKind == Direct)
          return operationPutByIdDirectNonStrictOptimize;
      return operationPutByIdNonStrictOptimize;
  }
  
<span class="line-modified">! static InlineCacheAction tryCachePutByID(JSGlobalObject* globalObject, CodeBlock* codeBlock, JSValue baseValue, Structure* oldStructure, const Identifier&amp; ident, const PutPropertySlot&amp; slot, StructureStubInfo&amp; stubInfo, PutKind putKind)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      AccessGenerationResult result;
      {
<span class="line-modified">!         GCSafeConcurrentJSLocker locker(codeBlock-&gt;m_lock, globalObject-&gt;vm().heap);</span>
  
<span class="line-modified">!         if (forceICFailure(globalObject))</span>
              return GiveUpOnCache;
  
          if (!baseValue.isCell())
              return GiveUpOnCache;
  
          if (!slot.isCacheablePut() &amp;&amp; !slot.isCacheableCustom() &amp;&amp; !slot.isCacheableSetter())
              return GiveUpOnCache;
  
          // FIXME: We should try to do something smarter here...
<span class="line-modified">!         if (isCopyOnWrite(oldStructure-&gt;indexingMode()))</span>
              return GiveUpOnCache;
          // We can&#39;t end up storing to a CoW on the prototype since it shouldn&#39;t own properties.
          ASSERT(!isCopyOnWrite(slot.base()-&gt;indexingMode()));
  
<span class="line-modified">!         if (!oldStructure-&gt;propertyAccessesAreCacheable())</span>
              return GiveUpOnCache;
  
          std::unique_ptr&lt;AccessCase&gt; newCase;
          JSCell* baseCell = baseValue.asCell();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 466,242 ***</span>
                  // when we transition then store to an existing property. This is common among
                  // paths that reify lazy properties. If we reify a lazy property and forget
                  // to disable caching, we may come down this path. The Replace IC does not
                  // know how to model these types of structure transitions (or any structure
                  // transition for that matter).
<span class="line-modified">!                 RELEASE_ASSERT(baseValue.asCell()-&gt;structure(vm) == structure);</span>
  
<span class="line-modified">!                 structure-&gt;didCachePropertyReplacement(vm, slot.cachedOffset());</span>
  
<span class="line-modified">!                 if (stubInfo.cacheType == CacheType::Unset</span>
                      &amp;&amp; InlineAccess::canGenerateSelfPropertyReplace(stubInfo, slot.cachedOffset())
<span class="line-modified">!                     &amp;&amp; !structure-&gt;needImpurePropertyWatchpoint()) {</span>
  
<span class="line-modified">!                     bool generatedCodeInline = InlineAccess::generateSelfPropertyReplace(stubInfo, structure, slot.cachedOffset());</span>
                      if (generatedCodeInline) {
<span class="line-modified">!                         LOG_IC((ICEvent::PutByIdSelfPatch, structure-&gt;classInfo(), ident, slot.base() == baseValue));</span>
<span class="line-modified">!                         ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation(), appropriateOptimizingPutByIdFunction(slot, putKind));</span>
<span class="line-modified">!                         stubInfo.initPutByIdReplace(codeBlock, structure, slot.cachedOffset());</span>
                          return RetryCacheLater;
                      }
                  }
  
<span class="line-modified">!                 newCase = AccessCase::create(vm, codeBlock, AccessCase::Replace, slot.cachedOffset(), structure);</span>
              } else {
                  ASSERT(slot.type() == PutPropertySlot::NewProperty);
  
<span class="line-modified">!                 if (!structure-&gt;isObject())</span>
                      return GiveUpOnCache;
  
<span class="line-modified">!                 if (structure-&gt;isDictionary()) {</span>
<span class="line-modified">!                     if (structure-&gt;hasBeenFlattenedBefore())</span>
<span class="line-modified">!                         return GiveUpOnCache;</span>
<span class="line-modified">!                     structure-&gt;flattenDictionaryStructure(vm, jsCast&lt;JSObject*&gt;(baseValue));</span>
<span class="line-removed">-                 }</span>
  
                  PropertyOffset offset;
<span class="line-modified">!                 Structure* newStructure =</span>
<span class="line-removed">-                     Structure::addPropertyTransitionToExistingStructureConcurrently(</span>
<span class="line-removed">-                         structure, ident.impl(), 0, offset);</span>
                  if (!newStructure || !newStructure-&gt;propertyAccessesAreCacheable())
                      return GiveUpOnCache;
  
<span class="line-modified">!                 ASSERT(newStructure-&gt;previousID() == structure);</span>
                  ASSERT(!newStructure-&gt;isDictionary());
                  ASSERT(newStructure-&gt;isObject());
  
                  std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain;
                  ObjectPropertyConditionSet conditionSet;
                  if (putKind == NotDirect) {
<span class="line-modified">!                     bool usesPolyProto;</span>
<span class="line-modified">!                     prototypeAccessChain = PolyProtoAccessChain::create(exec-&gt;lexicalGlobalObject(), baseCell, nullptr, usesPolyProto);</span>
<span class="line-removed">-                     if (!prototypeAccessChain) {</span>
<span class="line-removed">-                         // It&#39;s invalid to access this prototype property.</span>
                          return GiveUpOnCache;
<span class="line-removed">-                     }</span>
  
<span class="line-modified">!                     if (!usesPolyProto) {</span>
                          prototypeAccessChain = nullptr;
<span class="line-modified">!                         conditionSet =</span>
<span class="line-modified">!                             generateConditionsForPropertySetterMiss(</span>
<span class="line-removed">-                                 vm, codeBlock, exec, newStructure, ident.impl());</span>
                          if (!conditionSet.isValid())
                              return GiveUpOnCache;
                      }
<span class="line-removed">- </span>
                  }
  
<span class="line-modified">!                 newCase = AccessCase::create(vm, codeBlock, offset, structure, newStructure, conditionSet, WTFMove(prototypeAccessChain));</span>
              }
          } else if (slot.isCacheableCustom() || slot.isCacheableSetter()) {
              if (slot.isCacheableCustom()) {
                  ObjectPropertyConditionSet conditionSet;
                  std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain;
  
<span class="line-modified">!                 if (slot.base() != baseValue) {</span>
<span class="line-modified">!                     bool usesPolyProto;</span>
<span class="line-modified">!                     prototypeAccessChain = PolyProtoAccessChain::create(exec-&gt;lexicalGlobalObject(), baseCell, slot.base(), usesPolyProto);</span>
<span class="line-modified">!                     if (!prototypeAccessChain) {</span>
<span class="line-modified">!                         // It&#39;s invalid to access this prototype property.</span>
<span class="line-modified">!                         return GiveUpOnCache;</span>
<span class="line-removed">-                     }</span>
  
<span class="line-modified">!                     if (!usesPolyProto) {</span>
                          prototypeAccessChain = nullptr;
<span class="line-modified">!                         conditionSet =</span>
<span class="line-modified">!                             generateConditionsForPrototypePropertyHitCustom(</span>
<span class="line-removed">-                                 vm, codeBlock, exec, structure, slot.base(), ident.impl());</span>
                          if (!conditionSet.isValid())
                              return GiveUpOnCache;
                      }
                  }
  
                  newCase = GetterSetterAccessCase::create(
<span class="line-modified">!                     vm, codeBlock, slot.isCustomAccessor() ? AccessCase::CustomAccessorSetter : AccessCase::CustomValueSetter, structure, invalidOffset,</span>
<span class="line-modified">!                     conditionSet, WTFMove(prototypeAccessChain), slot.customSetter(), slot.base() != baseValue ? slot.base() : nullptr);</span>
              } else {
                  ObjectPropertyConditionSet conditionSet;
                  std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain;
                  PropertyOffset offset = slot.cachedOffset();
  
                  if (slot.base() != baseValue) {
<span class="line-modified">!                     bool usesPolyProto;</span>
<span class="line-modified">!                     prototypeAccessChain = PolyProtoAccessChain::create(exec-&gt;lexicalGlobalObject(), baseCell, slot.base(), usesPolyProto);</span>
<span class="line-removed">-                     if (!prototypeAccessChain) {</span>
<span class="line-removed">-                         // It&#39;s invalid to access this prototype property.</span>
                          return GiveUpOnCache;
<span class="line-modified">!                     }</span>
  
<span class="line-modified">!                     if (!usesPolyProto) {</span>
                          prototypeAccessChain = nullptr;
<span class="line-modified">!                         conditionSet =</span>
<span class="line-modified">!                             generateConditionsForPrototypePropertyHit(</span>
<span class="line-removed">-                                 vm, codeBlock, exec, structure, slot.base(), ident.impl());</span>
                          if (!conditionSet.isValid())
                              return GiveUpOnCache;
  
                          if (!(conditionSet.slotBaseCondition().attributes() &amp; PropertyAttribute::Accessor))
                              return GiveUpOnCache;
  
                          offset = conditionSet.slotBaseCondition().offset();
                      }
<span class="line-removed">- </span>
                  }
  
                  newCase = GetterSetterAccessCase::create(
<span class="line-modified">!                     vm, codeBlock, AccessCase::Setter, structure, offset, conditionSet, WTFMove(prototypeAccessChain));</span>
              }
          }
  
<span class="line-modified">!         LOG_IC((ICEvent::PutByIdAddAccessCase, structure-&gt;classInfo(), ident, slot.base() == baseValue));</span>
  
          result = stubInfo.addAccessCase(locker, codeBlock, ident, WTFMove(newCase));
  
          if (result.generatedSomeCode()) {
<span class="line-modified">!             LOG_IC((ICEvent::PutByIdReplaceWithJump, structure-&gt;classInfo(), ident, slot.base() == baseValue));</span>
  
              RELEASE_ASSERT(result.code());
  
              InlineAccess::rewireStubAsJump(stubInfo, CodeLocationLabel&lt;JITStubRoutinePtrTag&gt;(result.code()));
          }
      }
  
<span class="line-modified">!     fireWatchpointsAndClearStubIfNeeded(vm, stubInfo, exec-&gt;codeBlock(), result);</span>
  
      return result.shouldGiveUpNow() ? GiveUpOnCache : RetryCacheLater;
  }
  
<span class="line-modified">! void repatchPutByID(ExecState* exec, JSValue baseValue, Structure* structure, const Identifier&amp; propertyName, const PutPropertySlot&amp; slot, StructureStubInfo&amp; stubInfo, PutKind putKind)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
<span class="line-modified">!     if (tryCachePutByID(exec, baseValue, structure, propertyName, slot, stubInfo, putKind) == GiveUpOnCache) {</span>
<span class="line-modified">!         CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">-         ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation(), appropriateGenericPutByIdFunction(slot, putKind));</span>
<span class="line-removed">-     }</span>
  }
  
  static InlineCacheAction tryCacheInByID(
<span class="line-modified">!     ExecState* exec, JSObject* base, const Identifier&amp; ident,</span>
      bool wasFound, const PropertySlot&amp; slot, StructureStubInfo&amp; stubInfo)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      AccessGenerationResult result;
  
      {
<span class="line-modified">!         GCSafeConcurrentJSLocker locker(exec-&gt;codeBlock()-&gt;m_lock, vm.heap);</span>
<span class="line-modified">!         if (forceICFailure(exec))</span>
              return GiveUpOnCache;
  
          if (!base-&gt;structure(vm)-&gt;propertyAccessesAreCacheable() || (!wasFound &amp;&amp; !base-&gt;structure(vm)-&gt;propertyAccessesAreCacheableForAbsence()))
              return GiveUpOnCache;
  
          if (wasFound) {
              if (!slot.isCacheable())
                  return GiveUpOnCache;
          }
  
<span class="line-removed">-         CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
          Structure* structure = base-&gt;structure(vm);
  
          std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain;
          ObjectPropertyConditionSet conditionSet;
          if (wasFound) {
              InlineCacheAction action = actionForCell(vm, base);
              if (action != AttemptToCache)
                  return action;
  
              // Optimize self access.
<span class="line-modified">!             if (stubInfo.cacheType == CacheType::Unset</span>
                  &amp;&amp; slot.isCacheableValue()
                  &amp;&amp; slot.slotBase() == base
                  &amp;&amp; !slot.watchpointSet()
                  &amp;&amp; !structure-&gt;needImpurePropertyWatchpoint()) {
                  bool generatedCodeInline = InlineAccess::generateSelfInAccess(stubInfo, structure);
                  if (generatedCodeInline) {
                      LOG_IC((ICEvent::InByIdSelfPatch, structure-&gt;classInfo(), ident, slot.slotBase() == base));
                      structure-&gt;startWatchingPropertyForReplacements(vm, slot.cachedOffset());
<span class="line-modified">!                     ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation(), operationInByIdOptimize);</span>
                      stubInfo.initInByIdSelf(codeBlock, structure, slot.cachedOffset());
                      return RetryCacheLater;
                  }
              }
  
              if (slot.slotBase() != base) {
<span class="line-modified">!                 bool usesPolyProto;</span>
<span class="line-modified">!                 prototypeAccessChain = PolyProtoAccessChain::create(exec-&gt;lexicalGlobalObject(), base, slot, usesPolyProto);</span>
<span class="line-removed">-                 if (!prototypeAccessChain) {</span>
<span class="line-removed">-                     // It&#39;s invalid to access this prototype property.</span>
                      return GiveUpOnCache;
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 if (!usesPolyProto) {</span>
                      prototypeAccessChain = nullptr;
                      conditionSet = generateConditionsForPrototypePropertyHit(
<span class="line-modified">!                         vm, codeBlock, exec, structure, slot.slotBase(), ident.impl());</span>
                  }
              }
          } else {
<span class="line-modified">!             bool usesPolyProto;</span>
<span class="line-modified">!             prototypeAccessChain = PolyProtoAccessChain::create(exec-&gt;lexicalGlobalObject(), base, slot, usesPolyProto);</span>
<span class="line-removed">-             if (!prototypeAccessChain) {</span>
<span class="line-removed">-                 // It&#39;s invalid to access this prototype property.</span>
                  return GiveUpOnCache;
<span class="line-removed">-             }</span>
  
<span class="line-modified">!             if (!usesPolyProto) {</span>
                  prototypeAccessChain = nullptr;
                  conditionSet = generateConditionsForPropertyMiss(
<span class="line-modified">!                     vm, codeBlock, exec, structure, ident.impl());</span>
              }
          }
<span class="line-removed">-         if (!conditionSet.isValid())</span>
<span class="line-removed">-             return GiveUpOnCache;</span>
  
          LOG_IC((ICEvent::InAddAccessCase, structure-&gt;classInfo(), ident, slot.slotBase() == base));
  
          std::unique_ptr&lt;AccessCase&gt; newCase = AccessCase::create(
<span class="line-modified">!             vm, codeBlock, wasFound ? AccessCase::InHit : AccessCase::InMiss, wasFound ? slot.cachedOffset() : invalidOffset, structure, conditionSet, WTFMove(prototypeAccessChain));</span>
  
          result = stubInfo.addAccessCase(locker, codeBlock, ident, WTFMove(newCase));
  
          if (result.generatedSomeCode()) {
              LOG_IC((ICEvent::InReplaceWithJump, structure-&gt;classInfo(), ident, slot.slotBase() == base));
<span class="line-new-header">--- 573,257 ---</span>
                  // when we transition then store to an existing property. This is common among
                  // paths that reify lazy properties. If we reify a lazy property and forget
                  // to disable caching, we may come down this path. The Replace IC does not
                  // know how to model these types of structure transitions (or any structure
                  // transition for that matter).
<span class="line-modified">!                 RELEASE_ASSERT(baseValue.asCell()-&gt;structure(vm) == oldStructure);</span>
  
<span class="line-modified">!                 oldStructure-&gt;didCachePropertyReplacement(vm, slot.cachedOffset());</span>
  
<span class="line-modified">!                 if (stubInfo.cacheType() == CacheType::Unset</span>
                      &amp;&amp; InlineAccess::canGenerateSelfPropertyReplace(stubInfo, slot.cachedOffset())
<span class="line-modified">!                     &amp;&amp; !oldStructure-&gt;needImpurePropertyWatchpoint()) {</span>
  
<span class="line-modified">!                     bool generatedCodeInline = InlineAccess::generateSelfPropertyReplace(stubInfo, oldStructure, slot.cachedOffset());</span>
                      if (generatedCodeInline) {
<span class="line-modified">!                         LOG_IC((ICEvent::PutByIdSelfPatch, oldStructure-&gt;classInfo(), ident, slot.base() == baseValue));</span>
<span class="line-modified">!                         ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation, appropriateOptimizingPutByIdFunction(slot, putKind));</span>
<span class="line-modified">!                         stubInfo.initPutByIdReplace(codeBlock, oldStructure, slot.cachedOffset());</span>
                          return RetryCacheLater;
                      }
                  }
  
<span class="line-modified">!                 newCase = AccessCase::create(vm, codeBlock, AccessCase::Replace, ident, slot.cachedOffset(), oldStructure);</span>
              } else {
                  ASSERT(slot.type() == PutPropertySlot::NewProperty);
  
<span class="line-modified">!                 if (!oldStructure-&gt;isObject())</span>
                      return GiveUpOnCache;
  
<span class="line-modified">!                 // If the old structure is dictionary, it means that this is one-on-one between an object and a structure.</span>
<span class="line-modified">!                 // If this is NewProperty operation, generating IC for this does not offer any benefit because this transition never happens again.</span>
<span class="line-modified">!                 if (oldStructure-&gt;isDictionary())</span>
<span class="line-modified">!                     return RetryCacheLater;</span>
  
                  PropertyOffset offset;
<span class="line-modified">!                 Structure* newStructure = Structure::addPropertyTransitionToExistingStructureConcurrently(oldStructure, ident.impl(), static_cast&lt;unsigned&gt;(PropertyAttribute::None), offset);</span>
                  if (!newStructure || !newStructure-&gt;propertyAccessesAreCacheable())
                      return GiveUpOnCache;
  
<span class="line-modified">!                 // If JSObject::put is overridden by UserObject, UserObject::put performs side-effect on JSObject::put, and it neglects to mark the PutPropertySlot as non-cachaeble,</span>
<span class="line-added">+                 // then arbitrary structure transitions can happen during the put operation, and this generates wrong transition information here as if oldStructure -&gt; newStructure.</span>
<span class="line-added">+                 // In reality, the transition is oldStructure -&gt; something unknown structures -&gt; baseValue&#39;s structure.</span>
<span class="line-added">+                 // To guard against the embedder&#39;s potentially incorrect UserObject::put implementation, we should check for this condition and if found, and give up on caching the put.</span>
<span class="line-added">+                 ASSERT(baseValue.asCell()-&gt;structure(vm) == newStructure);</span>
<span class="line-added">+                 if (baseValue.asCell()-&gt;structure(vm) != newStructure)</span>
<span class="line-added">+                     return GiveUpOnCache;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 ASSERT(newStructure-&gt;previousID() == oldStructure);</span>
                  ASSERT(!newStructure-&gt;isDictionary());
                  ASSERT(newStructure-&gt;isObject());
  
                  std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain;
                  ObjectPropertyConditionSet conditionSet;
                  if (putKind == NotDirect) {
<span class="line-modified">!                     auto cacheStatus = prepareChainForCaching(globalObject, baseCell, nullptr);</span>
<span class="line-modified">!                     if (!cacheStatus)</span>
                          return GiveUpOnCache;
  
<span class="line-modified">!                     if (cacheStatus-&gt;usesPolyProto) {</span>
<span class="line-added">+                         prototypeAccessChain = PolyProtoAccessChain::create(globalObject, baseCell, nullptr);</span>
<span class="line-added">+                         if (!prototypeAccessChain)</span>
<span class="line-added">+                             return GiveUpOnCache;</span>
<span class="line-added">+                     } else {</span>
                          prototypeAccessChain = nullptr;
<span class="line-modified">!                         conditionSet = generateConditionsForPropertySetterMiss(</span>
<span class="line-modified">!                             vm, codeBlock, globalObject, newStructure, ident.impl());</span>
                          if (!conditionSet.isValid())
                              return GiveUpOnCache;
                      }
                  }
  
<span class="line-modified">!                 newCase = AccessCase::create(vm, codeBlock, ident, offset, oldStructure, newStructure, conditionSet, WTFMove(prototypeAccessChain));</span>
              }
          } else if (slot.isCacheableCustom() || slot.isCacheableSetter()) {
              if (slot.isCacheableCustom()) {
                  ObjectPropertyConditionSet conditionSet;
                  std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain;
  
<span class="line-modified">!                 // We need to do this even if we&#39;re a self custom, since we must disallow dictionaries</span>
<span class="line-modified">!                 // because we need to be informed if the custom goes away since we cache the constant</span>
<span class="line-modified">!                 // function pointer.</span>
<span class="line-modified">!                 auto cacheStatus = prepareChainForCaching(globalObject, baseCell, slot.base());</span>
<span class="line-modified">!                 if (!cacheStatus)</span>
<span class="line-modified">!                     return GiveUpOnCache;</span>
  
<span class="line-modified">!                 if (slot.base() != baseValue) {</span>
<span class="line-added">+                     if (cacheStatus-&gt;usesPolyProto) {</span>
<span class="line-added">+                         prototypeAccessChain = PolyProtoAccessChain::create(globalObject, baseCell, slot.base());</span>
<span class="line-added">+                         if (!prototypeAccessChain)</span>
<span class="line-added">+                             return GiveUpOnCache;</span>
<span class="line-added">+                     } else {</span>
                          prototypeAccessChain = nullptr;
<span class="line-modified">!                         conditionSet = generateConditionsForPrototypePropertyHitCustom(</span>
<span class="line-modified">!                             vm, codeBlock, globalObject, oldStructure, slot.base(), ident.impl(), static_cast&lt;unsigned&gt;(PropertyAttribute::None));</span>
                          if (!conditionSet.isValid())
                              return GiveUpOnCache;
                      }
                  }
  
                  newCase = GetterSetterAccessCase::create(
<span class="line-modified">!                     vm, codeBlock, slot.isCustomAccessor() ? AccessCase::CustomAccessorSetter : AccessCase::CustomValueSetter, oldStructure, ident,</span>
<span class="line-modified">!                     invalidOffset, conditionSet, WTFMove(prototypeAccessChain), slot.customSetter(), slot.base() != baseValue ? slot.base() : nullptr);</span>
              } else {
                  ObjectPropertyConditionSet conditionSet;
                  std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain;
                  PropertyOffset offset = slot.cachedOffset();
  
                  if (slot.base() != baseValue) {
<span class="line-modified">!                     auto cacheStatus = prepareChainForCaching(globalObject, baseCell, slot.base());</span>
<span class="line-modified">!                     if (!cacheStatus)</span>
                          return GiveUpOnCache;
<span class="line-modified">!                     if (cacheStatus-&gt;flattenedDictionary)</span>
<span class="line-added">+                         return RetryCacheLater;</span>
  
<span class="line-modified">!                     if (cacheStatus-&gt;usesPolyProto) {</span>
<span class="line-added">+                         prototypeAccessChain = PolyProtoAccessChain::create(globalObject, baseCell, slot.base());</span>
<span class="line-added">+                         if (!prototypeAccessChain)</span>
<span class="line-added">+                             return GiveUpOnCache;</span>
<span class="line-added">+                         offset = prototypeAccessChain-&gt;slotBaseStructure(vm, baseCell-&gt;structure(vm))-&gt;get(vm, ident.impl());</span>
<span class="line-added">+                     } else {</span>
                          prototypeAccessChain = nullptr;
<span class="line-modified">!                         conditionSet = generateConditionsForPrototypePropertyHit(</span>
<span class="line-modified">!                             vm, codeBlock, globalObject, oldStructure, slot.base(), ident.impl());</span>
                          if (!conditionSet.isValid())
                              return GiveUpOnCache;
  
                          if (!(conditionSet.slotBaseCondition().attributes() &amp; PropertyAttribute::Accessor))
                              return GiveUpOnCache;
  
                          offset = conditionSet.slotBaseCondition().offset();
                      }
                  }
  
                  newCase = GetterSetterAccessCase::create(
<span class="line-modified">!                     vm, codeBlock, AccessCase::Setter, oldStructure, ident, offset, conditionSet, WTFMove(prototypeAccessChain));</span>
              }
          }
  
<span class="line-modified">!         LOG_IC((ICEvent::PutByIdAddAccessCase, oldStructure-&gt;classInfo(), ident, slot.base() == baseValue));</span>
  
          result = stubInfo.addAccessCase(locker, codeBlock, ident, WTFMove(newCase));
  
          if (result.generatedSomeCode()) {
<span class="line-modified">!             LOG_IC((ICEvent::PutByIdReplaceWithJump, oldStructure-&gt;classInfo(), ident, slot.base() == baseValue));</span>
  
              RELEASE_ASSERT(result.code());
  
              InlineAccess::rewireStubAsJump(stubInfo, CodeLocationLabel&lt;JITStubRoutinePtrTag&gt;(result.code()));
          }
      }
  
<span class="line-modified">!     fireWatchpointsAndClearStubIfNeeded(vm, stubInfo, codeBlock, result);</span>
  
      return result.shouldGiveUpNow() ? GiveUpOnCache : RetryCacheLater;
  }
  
<span class="line-modified">! void repatchPutByID(JSGlobalObject* globalObject, CodeBlock* codeBlock, JSValue baseValue, Structure* oldStructure, const Identifier&amp; propertyName, const PutPropertySlot&amp; slot, StructureStubInfo&amp; stubInfo, PutKind putKind)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
<span class="line-modified">!     if (tryCachePutByID(globalObject, codeBlock, baseValue, oldStructure, propertyName, slot, stubInfo, putKind) == GiveUpOnCache)</span>
<span class="line-modified">!         ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation, appropriateGenericPutByIdFunction(slot, putKind));</span>
  }
  
  static InlineCacheAction tryCacheInByID(
<span class="line-modified">!     JSGlobalObject* globalObject, CodeBlock* codeBlock, JSObject* base, const Identifier&amp; ident,</span>
      bool wasFound, const PropertySlot&amp; slot, StructureStubInfo&amp; stubInfo)
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      AccessGenerationResult result;
  
      {
<span class="line-modified">!         GCSafeConcurrentJSLocker locker(codeBlock-&gt;m_lock, vm.heap);</span>
<span class="line-modified">!         if (forceICFailure(globalObject))</span>
              return GiveUpOnCache;
  
          if (!base-&gt;structure(vm)-&gt;propertyAccessesAreCacheable() || (!wasFound &amp;&amp; !base-&gt;structure(vm)-&gt;propertyAccessesAreCacheableForAbsence()))
              return GiveUpOnCache;
  
          if (wasFound) {
              if (!slot.isCacheable())
                  return GiveUpOnCache;
          }
  
          Structure* structure = base-&gt;structure(vm);
  
          std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain;
          ObjectPropertyConditionSet conditionSet;
          if (wasFound) {
              InlineCacheAction action = actionForCell(vm, base);
              if (action != AttemptToCache)
                  return action;
  
              // Optimize self access.
<span class="line-modified">!             if (stubInfo.cacheType() == CacheType::Unset</span>
                  &amp;&amp; slot.isCacheableValue()
                  &amp;&amp; slot.slotBase() == base
                  &amp;&amp; !slot.watchpointSet()
                  &amp;&amp; !structure-&gt;needImpurePropertyWatchpoint()) {
                  bool generatedCodeInline = InlineAccess::generateSelfInAccess(stubInfo, structure);
                  if (generatedCodeInline) {
                      LOG_IC((ICEvent::InByIdSelfPatch, structure-&gt;classInfo(), ident, slot.slotBase() == base));
                      structure-&gt;startWatchingPropertyForReplacements(vm, slot.cachedOffset());
<span class="line-modified">!                     ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation, operationInByIdOptimize);</span>
                      stubInfo.initInByIdSelf(codeBlock, structure, slot.cachedOffset());
                      return RetryCacheLater;
                  }
              }
  
              if (slot.slotBase() != base) {
<span class="line-modified">!                 auto cacheStatus = prepareChainForCaching(globalObject, base, slot);</span>
<span class="line-modified">!                 if (!cacheStatus)</span>
                      return GiveUpOnCache;
<span class="line-modified">!                 if (cacheStatus-&gt;flattenedDictionary)</span>
<span class="line-modified">!                     return RetryCacheLater;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 if (cacheStatus-&gt;usesPolyProto) {</span>
<span class="line-added">+                     prototypeAccessChain = PolyProtoAccessChain::create(globalObject, base, slot);</span>
<span class="line-added">+                     if (!prototypeAccessChain)</span>
<span class="line-added">+                         return GiveUpOnCache;</span>
<span class="line-added">+                     RELEASE_ASSERT(slot.isCacheableCustom() || prototypeAccessChain-&gt;slotBaseStructure(vm, structure)-&gt;get(vm, ident.impl()) == slot.cachedOffset());</span>
<span class="line-added">+                 } else {</span>
                      prototypeAccessChain = nullptr;
                      conditionSet = generateConditionsForPrototypePropertyHit(
<span class="line-modified">!                         vm, codeBlock, globalObject, structure, slot.slotBase(), ident.impl());</span>
<span class="line-added">+                     if (!conditionSet.isValid())</span>
<span class="line-added">+                         return GiveUpOnCache;</span>
<span class="line-added">+                     RELEASE_ASSERT(slot.isCacheableCustom() || conditionSet.slotBaseCondition().offset() == slot.cachedOffset());</span>
                  }
              }
          } else {
<span class="line-modified">!             auto cacheStatus = prepareChainForCaching(globalObject, base, nullptr);</span>
<span class="line-modified">!             if (!cacheStatus)</span>
                  return GiveUpOnCache;
  
<span class="line-modified">!             if (cacheStatus-&gt;usesPolyProto) {</span>
<span class="line-added">+                 prototypeAccessChain = PolyProtoAccessChain::create(globalObject, base, slot);</span>
<span class="line-added">+                 if (!prototypeAccessChain)</span>
<span class="line-added">+                     return GiveUpOnCache;</span>
<span class="line-added">+             } else {</span>
                  prototypeAccessChain = nullptr;
                  conditionSet = generateConditionsForPropertyMiss(
<span class="line-modified">!                     vm, codeBlock, globalObject, structure, ident.impl());</span>
<span class="line-added">+                 if (!conditionSet.isValid())</span>
<span class="line-added">+                     return GiveUpOnCache;</span>
              }
          }
  
          LOG_IC((ICEvent::InAddAccessCase, structure-&gt;classInfo(), ident, slot.slotBase() == base));
  
          std::unique_ptr&lt;AccessCase&gt; newCase = AccessCase::create(
<span class="line-modified">!             vm, codeBlock, wasFound ? AccessCase::InHit : AccessCase::InMiss, ident, wasFound ? slot.cachedOffset() : invalidOffset, structure, conditionSet, WTFMove(prototypeAccessChain));</span>
  
          result = stubInfo.addAccessCase(locker, codeBlock, ident, WTFMove(newCase));
  
          if (result.generatedSomeCode()) {
              LOG_IC((ICEvent::InReplaceWithJump, structure-&gt;classInfo(), ident, slot.slotBase() == base));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 709,36 ***</span>
              RELEASE_ASSERT(result.code());
              InlineAccess::rewireStubAsJump(stubInfo, CodeLocationLabel&lt;JITStubRoutinePtrTag&gt;(result.code()));
          }
      }
  
<span class="line-modified">!     fireWatchpointsAndClearStubIfNeeded(vm, stubInfo, exec-&gt;codeBlock(), result);</span>
  
      return result.shouldGiveUpNow() ? GiveUpOnCache : RetryCacheLater;
  }
  
<span class="line-modified">! void repatchInByID(ExecState* exec, JSObject* baseObject, const Identifier&amp; propertyName, bool wasFound, const PropertySlot&amp; slot, StructureStubInfo&amp; stubInfo)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
<span class="line-modified">!     if (tryCacheInByID(exec, baseObject, propertyName, wasFound, slot, stubInfo) == GiveUpOnCache) {</span>
<span class="line-modified">!         CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">-         ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation(), operationInById);</span>
<span class="line-removed">-     }</span>
  }
  
  static InlineCacheAction tryCacheInstanceOf(
<span class="line-modified">!     ExecState* exec, JSValue valueValue, JSValue prototypeValue, StructureStubInfo&amp; stubInfo,</span>
      bool wasFound)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">-     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
      AccessGenerationResult result;
  
      RELEASE_ASSERT(valueValue.isCell()); // shouldConsiderCaching rejects non-cells.
  
<span class="line-modified">!     if (forceICFailure(exec))</span>
          return GiveUpOnCache;
  
      {
          GCSafeConcurrentJSLocker locker(codeBlock-&gt;m_lock, vm.heap);
  
<span class="line-new-header">--- 831,33 ---</span>
              RELEASE_ASSERT(result.code());
              InlineAccess::rewireStubAsJump(stubInfo, CodeLocationLabel&lt;JITStubRoutinePtrTag&gt;(result.code()));
          }
      }
  
<span class="line-modified">!     fireWatchpointsAndClearStubIfNeeded(vm, stubInfo, codeBlock, result);</span>
  
      return result.shouldGiveUpNow() ? GiveUpOnCache : RetryCacheLater;
  }
  
<span class="line-modified">! void repatchInByID(JSGlobalObject* globalObject, CodeBlock* codeBlock, JSObject* baseObject, const Identifier&amp; propertyName, bool wasFound, const PropertySlot&amp; slot, StructureStubInfo&amp; stubInfo)</span>
  {
      SuperSamplerScope superSamplerScope(false);
  
<span class="line-modified">!     if (tryCacheInByID(globalObject, codeBlock, baseObject, propertyName, wasFound, slot, stubInfo) == GiveUpOnCache)</span>
<span class="line-modified">!         ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation, operationInById);</span>
  }
  
  static InlineCacheAction tryCacheInstanceOf(
<span class="line-modified">!     JSGlobalObject* globalObject, CodeBlock* codeBlock, JSValue valueValue, JSValue prototypeValue, StructureStubInfo&amp; stubInfo,</span>
      bool wasFound)
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      AccessGenerationResult result;
  
      RELEASE_ASSERT(valueValue.isCell()); // shouldConsiderCaching rejects non-cells.
  
<span class="line-modified">!     if (forceICFailure(globalObject))</span>
          return GiveUpOnCache;
  
      {
          GCSafeConcurrentJSLocker locker(codeBlock-&gt;m_lock, vm.heap);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 752,13 ***</span>
                      vm, codeBlock, AccessCase::InstanceOfMiss, structure, ObjectPropertyConditionSet(),
                      prototype);
              } else if (structure-&gt;prototypeQueriesAreCacheable()) {
                  // FIXME: Teach this to do poly proto.
                  // https://bugs.webkit.org/show_bug.cgi?id=185663
<span class="line-modified">! </span>
                  ObjectPropertyConditionSet conditionSet = generateConditionsForInstanceOf(
<span class="line-modified">!                     vm, codeBlock, exec, structure, prototype, wasFound);</span>
  
                  if (conditionSet.isValid()) {
                      newCase = InstanceOfAccessCase::create(
                          vm, codeBlock,
                          wasFound ? AccessCase::InstanceOfHit : AccessCase::InstanceOfMiss,
<span class="line-new-header">--- 871,13 ---</span>
                      vm, codeBlock, AccessCase::InstanceOfMiss, structure, ObjectPropertyConditionSet(),
                      prototype);
              } else if (structure-&gt;prototypeQueriesAreCacheable()) {
                  // FIXME: Teach this to do poly proto.
                  // https://bugs.webkit.org/show_bug.cgi?id=185663
<span class="line-modified">!                 prepareChainForCaching(globalObject, value, wasFound ? prototype : nullptr);</span>
                  ObjectPropertyConditionSet conditionSet = generateConditionsForInstanceOf(
<span class="line-modified">!                     vm, codeBlock, globalObject, structure, prototype, wasFound);</span>
  
                  if (conditionSet.isValid()) {
                      newCase = InstanceOfAccessCase::create(
                          vm, codeBlock,
                          wasFound ? AccessCase::InstanceOfHit : AccessCase::InstanceOfMiss,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 766,15 ***</span>
                  }
              }
          }
  
          if (!newCase)
<span class="line-modified">!             newCase = AccessCase::create(vm, codeBlock, AccessCase::InstanceOfGeneric);</span>
  
          LOG_IC((ICEvent::InstanceOfAddAccessCase, structure-&gt;classInfo(), Identifier()));
  
<span class="line-modified">!         result = stubInfo.addAccessCase(locker, codeBlock, Identifier(), WTFMove(newCase));</span>
  
          if (result.generatedSomeCode()) {
              LOG_IC((ICEvent::InstanceOfReplaceWithJump, structure-&gt;classInfo(), Identifier()));
  
              RELEASE_ASSERT(result.code());
<span class="line-new-header">--- 885,15 ---</span>
                  }
              }
          }
  
          if (!newCase)
<span class="line-modified">!             newCase = AccessCase::create(vm, codeBlock, AccessCase::InstanceOfGeneric, Identifier());</span>
  
          LOG_IC((ICEvent::InstanceOfAddAccessCase, structure-&gt;classInfo(), Identifier()));
  
<span class="line-modified">!         result = stubInfo.addAccessCase(locker, codeBlock, nullptr, WTFMove(newCase));</span>
  
          if (result.generatedSomeCode()) {
              LOG_IC((ICEvent::InstanceOfReplaceWithJump, structure-&gt;classInfo(), Identifier()));
  
              RELEASE_ASSERT(result.code());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 789,16 ***</span>
  
      return result.shouldGiveUpNow() ? GiveUpOnCache : RetryCacheLater;
  }
  
  void repatchInstanceOf(
<span class="line-modified">!     ExecState* exec, JSValue valueValue, JSValue prototypeValue, StructureStubInfo&amp; stubInfo,</span>
      bool wasFound)
  {
      SuperSamplerScope superSamplerScope(false);
<span class="line-modified">!     if (tryCacheInstanceOf(exec, valueValue, prototypeValue, stubInfo, wasFound) == GiveUpOnCache)</span>
<span class="line-modified">!         ftlThunkAwareRepatchCall(exec-&gt;codeBlock(), stubInfo.slowPathCallLocation(), operationInstanceOfGeneric);</span>
  }
  
  static void linkSlowFor(VM&amp;, CallLinkInfo&amp; callLinkInfo, MacroAssemblerCodeRef&lt;JITStubRoutinePtrTag&gt; codeRef)
  {
      MacroAssembler::repatchNearCall(callLinkInfo.callReturnLocation(), CodeLocationLabel&lt;JITStubRoutinePtrTag&gt;(codeRef.code()));
<span class="line-new-header">--- 908,16 ---</span>
  
      return result.shouldGiveUpNow() ? GiveUpOnCache : RetryCacheLater;
  }
  
  void repatchInstanceOf(
<span class="line-modified">!     JSGlobalObject* globalObject, CodeBlock* codeBlock, JSValue valueValue, JSValue prototypeValue, StructureStubInfo&amp; stubInfo,</span>
      bool wasFound)
  {
      SuperSamplerScope superSamplerScope(false);
<span class="line-modified">!     if (tryCacheInstanceOf(globalObject, codeBlock, valueValue, prototypeValue, stubInfo, wasFound) == GiveUpOnCache)</span>
<span class="line-modified">!         ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation, operationInstanceOfGeneric);</span>
  }
  
  static void linkSlowFor(VM&amp;, CallLinkInfo&amp; callLinkInfo, MacroAssemblerCodeRef&lt;JITStubRoutinePtrTag&gt; codeRef)
  {
      MacroAssembler::repatchNearCall(callLinkInfo.callReturnLocation(), CodeLocationLabel&lt;JITStubRoutinePtrTag&gt;(codeRef.code()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 811,41 ***</span>
  
  static void linkSlowFor(VM&amp; vm, CallLinkInfo&amp; callLinkInfo)
  {
      MacroAssemblerCodeRef&lt;JITStubRoutinePtrTag&gt; virtualThunk = virtualThunkFor(vm, callLinkInfo);
      linkSlowFor(vm, callLinkInfo, virtualThunk);
<span class="line-modified">!     callLinkInfo.setSlowStub(createJITStubRoutine(virtualThunk, vm, nullptr, true));</span>
  }
  
  static JSCell* webAssemblyOwner(JSCell* callee)
  {
  #if ENABLE(WEBASSEMBLY)
      // Each WebAssembly.Instance shares the stubs from their WebAssembly.Module, which are therefore the appropriate owner.
<span class="line-modified">!     return jsCast&lt;WebAssemblyToJSCallee*&gt;(callee)-&gt;module();</span>
  #else
      UNUSED_PARAM(callee);
      RELEASE_ASSERT_NOT_REACHED();
      return nullptr;
  #endif // ENABLE(WEBASSEMBLY)
  }
  
  void linkFor(
<span class="line-modified">!     ExecState* exec, CallLinkInfo&amp; callLinkInfo, CodeBlock* calleeCodeBlock,</span>
      JSObject* callee, MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr)
  {
      ASSERT(!callLinkInfo.stub());
  
<span class="line-modified">!     CallFrame* callerFrame = exec-&gt;callerFrame();</span>
      // Our caller must have a cell for a callee. When calling
      // this from Wasm, we ensure the callee is a cell.
      ASSERT(callerFrame-&gt;callee().isCell());
  
<span class="line-removed">-     VM&amp; vm = callerFrame-&gt;vm();</span>
      CodeBlock* callerCodeBlock = callerFrame-&gt;codeBlock();
  
      // WebAssembly -&gt; JS stubs don&#39;t have a valid CodeBlock.
<span class="line-modified">!     JSCell* owner = isWebAssemblyToJSCallee(callerFrame-&gt;callee().asCell()) ? webAssemblyOwner(callerFrame-&gt;callee().asCell()) : callerCodeBlock;</span>
      ASSERT(owner);
  
      ASSERT(!callLinkInfo.isLinked());
      callLinkInfo.setCallee(vm, owner, callee);
      MacroAssembler::repatchPointer(callLinkInfo.hotPathBegin(), callee);
<span class="line-new-header">--- 930,40 ---</span>
  
  static void linkSlowFor(VM&amp; vm, CallLinkInfo&amp; callLinkInfo)
  {
      MacroAssemblerCodeRef&lt;JITStubRoutinePtrTag&gt; virtualThunk = virtualThunkFor(vm, callLinkInfo);
      linkSlowFor(vm, callLinkInfo, virtualThunk);
<span class="line-modified">!     callLinkInfo.setSlowStub(GCAwareJITStubRoutine::create(virtualThunk, vm));</span>
  }
  
  static JSCell* webAssemblyOwner(JSCell* callee)
  {
  #if ENABLE(WEBASSEMBLY)
      // Each WebAssembly.Instance shares the stubs from their WebAssembly.Module, which are therefore the appropriate owner.
<span class="line-modified">!     return jsCast&lt;JSWebAssemblyModule*&gt;(callee);</span>
  #else
      UNUSED_PARAM(callee);
      RELEASE_ASSERT_NOT_REACHED();
      return nullptr;
  #endif // ENABLE(WEBASSEMBLY)
  }
  
  void linkFor(
<span class="line-modified">!     VM&amp; vm, CallFrame* callFrame, CallLinkInfo&amp; callLinkInfo, CodeBlock* calleeCodeBlock,</span>
      JSObject* callee, MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr)
  {
      ASSERT(!callLinkInfo.stub());
  
<span class="line-modified">!     CallFrame* callerFrame = callFrame-&gt;callerFrame();</span>
      // Our caller must have a cell for a callee. When calling
      // this from Wasm, we ensure the callee is a cell.
      ASSERT(callerFrame-&gt;callee().isCell());
  
      CodeBlock* callerCodeBlock = callerFrame-&gt;codeBlock();
  
      // WebAssembly -&gt; JS stubs don&#39;t have a valid CodeBlock.
<span class="line-modified">!     JSCell* owner = isWebAssemblyModule(callerFrame-&gt;callee().asCell()) ? webAssemblyOwner(callerFrame-&gt;callee().asCell()) : callerCodeBlock;</span>
      ASSERT(owner);
  
      ASSERT(!callLinkInfo.isLinked());
      callLinkInfo.setCallee(vm, owner, callee);
      MacroAssembler::repatchPointer(callLinkInfo.hotPathBegin(), callee);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 865,16 ***</span>
  
      linkSlowFor(vm, callLinkInfo);
  }
  
  void linkDirectFor(
<span class="line-modified">!     ExecState* exec, CallLinkInfo&amp; callLinkInfo, CodeBlock* calleeCodeBlock,</span>
      MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr)
  {
      ASSERT(!callLinkInfo.stub());
  
<span class="line-modified">!     CodeBlock* callerCodeBlock = exec-&gt;codeBlock();</span>
  
      VM&amp; vm = callerCodeBlock-&gt;vm();
  
      ASSERT(!callLinkInfo.isLinked());
      callLinkInfo.setCodeBlock(vm, callerCodeBlock, jsCast&lt;FunctionCodeBlock*&gt;(calleeCodeBlock));
<span class="line-new-header">--- 983,16 ---</span>
  
      linkSlowFor(vm, callLinkInfo);
  }
  
  void linkDirectFor(
<span class="line-modified">!     CallFrame* callFrame, CallLinkInfo&amp; callLinkInfo, CodeBlock* calleeCodeBlock,</span>
      MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr)
  {
      ASSERT(!callLinkInfo.stub());
  
<span class="line-modified">!     CodeBlock* callerCodeBlock = callFrame-&gt;codeBlock();</span>
  
      VM&amp; vm = callerCodeBlock-&gt;vm();
  
      ASSERT(!callLinkInfo.isLinked());
      callLinkInfo.setCodeBlock(vm, callerCodeBlock, jsCast&lt;FunctionCodeBlock*&gt;(calleeCodeBlock));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 884,17 ***</span>
      if (callLinkInfo.callType() == CallLinkInfo::DirectTailCall)
          MacroAssembler::repatchJumpToNop(callLinkInfo.patchableJump());
      MacroAssembler::repatchNearCall(callLinkInfo.hotPathOther(), CodeLocationLabel&lt;JSEntryPtrTag&gt;(codePtr));
  
      if (calleeCodeBlock)
<span class="line-modified">!         calleeCodeBlock-&gt;linkIncomingCall(exec, &amp;callLinkInfo);</span>
  }
  
<span class="line-modified">! void linkSlowFor(</span>
<span class="line-removed">-     ExecState* exec, CallLinkInfo&amp; callLinkInfo)</span>
  {
<span class="line-modified">!     CodeBlock* callerCodeBlock = exec-&gt;callerFrame()-&gt;codeBlock();</span>
      VM&amp; vm = callerCodeBlock-&gt;vm();
  
      linkSlowFor(vm, callLinkInfo);
  }
  
<span class="line-new-header">--- 1002,16 ---</span>
      if (callLinkInfo.callType() == CallLinkInfo::DirectTailCall)
          MacroAssembler::repatchJumpToNop(callLinkInfo.patchableJump());
      MacroAssembler::repatchNearCall(callLinkInfo.hotPathOther(), CodeLocationLabel&lt;JSEntryPtrTag&gt;(codePtr));
  
      if (calleeCodeBlock)
<span class="line-modified">!         calleeCodeBlock-&gt;linkIncomingCall(callFrame, &amp;callLinkInfo);</span>
  }
  
<span class="line-modified">! void linkSlowFor(CallFrame* callFrame, CallLinkInfo&amp; callLinkInfo)</span>
  {
<span class="line-modified">!     CodeBlock* callerCodeBlock = callFrame-&gt;callerFrame()-&gt;codeBlock();</span>
      VM&amp; vm = callerCodeBlock-&gt;vm();
  
      linkSlowFor(vm, callLinkInfo);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 925,61 ***</span>
          callLinkInfo.remove();
  }
  
  void unlinkFor(VM&amp; vm, CallLinkInfo&amp; callLinkInfo)
  {
<span class="line-modified">!     if (Options::dumpDisassembly())</span>
<span class="line-removed">-         dataLog(&quot;Unlinking call at &quot;, callLinkInfo.hotPathOther(), &quot;\n&quot;);</span>
  
      revertCall(vm, callLinkInfo, vm.getCTIStub(linkCallThunkGenerator).retagged&lt;JITStubRoutinePtrTag&gt;());
  }
  
<span class="line-modified">! static void linkVirtualFor(ExecState* exec, CallLinkInfo&amp; callLinkInfo)</span>
  {
<span class="line-modified">!     CallFrame* callerFrame = exec-&gt;callerFrame();</span>
<span class="line-removed">-     VM&amp; vm = callerFrame-&gt;vm();</span>
      CodeBlock* callerCodeBlock = callerFrame-&gt;codeBlock();
  
<span class="line-modified">!     if (shouldDumpDisassemblyFor(callerCodeBlock))</span>
<span class="line-modified">!         dataLog(&quot;Linking virtual call at &quot;, FullCodeOrigin(callerCodeBlock, callerFrame-&gt;codeOrigin()), &quot;\n&quot;);</span>
  
      MacroAssemblerCodeRef&lt;JITStubRoutinePtrTag&gt; virtualThunk = virtualThunkFor(vm, callLinkInfo);
      revertCall(vm, callLinkInfo, virtualThunk);
<span class="line-modified">!     callLinkInfo.setSlowStub(createJITStubRoutine(virtualThunk, vm, nullptr, true));</span>
      callLinkInfo.setClearedByVirtual();
  }
  
  namespace {
  struct CallToCodePtr {
      CCallHelpers::Call call;
      MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr;
  };
  } // annonymous namespace
  
<span class="line-modified">! void linkPolymorphicCall(</span>
<span class="line-removed">-     ExecState* exec, CallLinkInfo&amp; callLinkInfo, CallVariant newVariant)</span>
  {
      RELEASE_ASSERT(callLinkInfo.allowStubs());
  
<span class="line-modified">!     CallFrame* callerFrame = exec-&gt;callerFrame();</span>
<span class="line-modified">!     VM&amp; vm = callerFrame-&gt;vm();</span>
  
      // During execution of linkPolymorphicCall, we strongly assume that we never do GC.
      // GC jettisons CodeBlocks, changes CallLinkInfo etc. and breaks assumption done before and after this call.
      DeferGCForAWhile deferGCForAWhile(vm.heap);
  
      if (!newVariant) {
<span class="line-modified">!         linkVirtualFor(exec, callLinkInfo);</span>
          return;
      }
  
      // Our caller must be have a cell for a callee. When calling
      // this from Wasm, we ensure the callee is a cell.
      ASSERT(callerFrame-&gt;callee().isCell());
  
      CodeBlock* callerCodeBlock = callerFrame-&gt;codeBlock();
<span class="line-modified">!     bool isWebAssembly = isWebAssemblyToJSCallee(callerFrame-&gt;callee().asCell());</span>
  
      // WebAssembly -&gt; JS stubs don&#39;t have a valid CodeBlock.
      JSCell* owner = isWebAssembly ? webAssemblyOwner(callerFrame-&gt;callee().asCell()) : callerCodeBlock;
      ASSERT(owner);
  
<span class="line-new-header">--- 1042,58 ---</span>
          callLinkInfo.remove();
  }
  
  void unlinkFor(VM&amp; vm, CallLinkInfo&amp; callLinkInfo)
  {
<span class="line-modified">!     dataLogLnIf(Options::dumpDisassembly(), &quot;Unlinking call at &quot;, callLinkInfo.hotPathOther());</span>
  
      revertCall(vm, callLinkInfo, vm.getCTIStub(linkCallThunkGenerator).retagged&lt;JITStubRoutinePtrTag&gt;());
  }
  
<span class="line-modified">! static void linkVirtualFor(VM&amp; vm, CallFrame* callFrame, CallLinkInfo&amp; callLinkInfo)</span>
  {
<span class="line-modified">!     CallFrame* callerFrame = callFrame-&gt;callerFrame();</span>
      CodeBlock* callerCodeBlock = callerFrame-&gt;codeBlock();
  
<span class="line-modified">!     dataLogLnIf(shouldDumpDisassemblyFor(callerCodeBlock),</span>
<span class="line-modified">!         &quot;Linking virtual call at &quot;, FullCodeOrigin(callerCodeBlock, callerFrame-&gt;codeOrigin()));</span>
  
      MacroAssemblerCodeRef&lt;JITStubRoutinePtrTag&gt; virtualThunk = virtualThunkFor(vm, callLinkInfo);
      revertCall(vm, callLinkInfo, virtualThunk);
<span class="line-modified">!     callLinkInfo.setSlowStub(GCAwareJITStubRoutine::create(virtualThunk, vm));</span>
      callLinkInfo.setClearedByVirtual();
  }
  
  namespace {
  struct CallToCodePtr {
      CCallHelpers::Call call;
      MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr;
  };
  } // annonymous namespace
  
<span class="line-modified">! void linkPolymorphicCall(JSGlobalObject* globalObject, CallFrame* callFrame, CallLinkInfo&amp; callLinkInfo, CallVariant newVariant)</span>
  {
      RELEASE_ASSERT(callLinkInfo.allowStubs());
  
<span class="line-modified">!     CallFrame* callerFrame = callFrame-&gt;callerFrame();</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
  
      // During execution of linkPolymorphicCall, we strongly assume that we never do GC.
      // GC jettisons CodeBlocks, changes CallLinkInfo etc. and breaks assumption done before and after this call.
      DeferGCForAWhile deferGCForAWhile(vm.heap);
  
      if (!newVariant) {
<span class="line-modified">!         linkVirtualFor(vm, callFrame, callLinkInfo);</span>
          return;
      }
  
      // Our caller must be have a cell for a callee. When calling
      // this from Wasm, we ensure the callee is a cell.
      ASSERT(callerFrame-&gt;callee().isCell());
  
      CodeBlock* callerCodeBlock = callerFrame-&gt;codeBlock();
<span class="line-modified">!     bool isWebAssembly = isWebAssemblyModule(callerFrame-&gt;callee().asCell());</span>
  
      // WebAssembly -&gt; JS stubs don&#39;t have a valid CodeBlock.
      JSCell* owner = isWebAssembly ? webAssemblyOwner(callerFrame-&gt;callee().asCell()) : callerCodeBlock;
      ASSERT(owner);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1015,12 ***</span>
          if (variant.executable() &amp;&amp; !variant.executable()-&gt;isHostFunction()) {
              ExecutableBase* executable = variant.executable();
              codeBlock = jsCast&lt;FunctionExecutable*&gt;(executable)-&gt;codeBlockForCall();
              // If we cannot handle a callee, either because we don&#39;t have a CodeBlock or because arity mismatch,
              // assume that it&#39;s better for this whole thing to be a virtual call.
<span class="line-modified">!             if (!codeBlock || exec-&gt;argumentCountIncludingThis() &lt; static_cast&lt;size_t&gt;(codeBlock-&gt;numParameters()) || callLinkInfo.isVarargs()) {</span>
<span class="line-modified">!                 linkVirtualFor(exec, callLinkInfo);</span>
                  return;
              }
          }
  
          int64_t newCaseValue = 0;
<span class="line-new-header">--- 1129,12 ---</span>
          if (variant.executable() &amp;&amp; !variant.executable()-&gt;isHostFunction()) {
              ExecutableBase* executable = variant.executable();
              codeBlock = jsCast&lt;FunctionExecutable*&gt;(executable)-&gt;codeBlockForCall();
              // If we cannot handle a callee, either because we don&#39;t have a CodeBlock or because arity mismatch,
              // assume that it&#39;s better for this whole thing to be a virtual call.
<span class="line-modified">!             if (!codeBlock || callFrame-&gt;argumentCountIncludingThis() &lt; static_cast&lt;size_t&gt;(codeBlock-&gt;numParameters()) || callLinkInfo.isVarargs()) {</span>
<span class="line-modified">!                 linkVirtualFor(vm, callFrame, callLinkInfo);</span>
                  return;
              }
          }
  
          int64_t newCaseValue = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1035,11 ***</span>
                  newCaseValue = bitwise_cast&lt;intptr_t&gt;(function);
              else
                  newCaseValue = bitwise_cast&lt;intptr_t&gt;(variant.internalFunction());
          }
  
<span class="line-modified">!         if (!ASSERT_DISABLED) {</span>
              if (caseValues.contains(newCaseValue)) {
                  dataLog(&quot;ERROR: Attempt to add duplicate case value.\n&quot;);
                  dataLog(&quot;Existing case values: &quot;);
                  CommaPrinter comma;
                  for (auto&amp; value : caseValues)
<span class="line-new-header">--- 1149,11 ---</span>
                  newCaseValue = bitwise_cast&lt;intptr_t&gt;(function);
              else
                  newCaseValue = bitwise_cast&lt;intptr_t&gt;(variant.internalFunction());
          }
  
<span class="line-modified">!         if (ASSERT_ENABLED) {</span>
              if (caseValues.contains(newCaseValue)) {
                  dataLog(&quot;ERROR: Attempt to add duplicate case value.\n&quot;);
                  dataLog(&quot;Existing case values: &quot;);
                  CommaPrinter comma;
                  for (auto&amp; value : caseValues)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1065,11 ***</span>
      else
          maxPolymorphicCallVariantListSize = Options::maxPolymorphicCallVariantListSize();
  
      // We use list.size() instead of callCases.size() because we respect CallVariant size for now.
      if (list.size() &gt; maxPolymorphicCallVariantListSize) {
<span class="line-modified">!         linkVirtualFor(exec, callLinkInfo);</span>
          return;
      }
  
      Vector&lt;CallToCodePtr&gt; calls(callCases.size());
      UniqueArray&lt;uint32_t&gt; fastCounts;
<span class="line-new-header">--- 1179,11 ---</span>
      else
          maxPolymorphicCallVariantListSize = Options::maxPolymorphicCallVariantListSize();
  
      // We use list.size() instead of callCases.size() because we respect CallVariant size for now.
      if (list.size() &gt; maxPolymorphicCallVariantListSize) {
<span class="line-modified">!         linkVirtualFor(vm, callFrame, callLinkInfo);</span>
          return;
      }
  
      Vector&lt;CallToCodePtr&gt; calls(callCases.size());
      UniqueArray&lt;uint32_t&gt; fastCounts;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1131,13 ***</span>
          // We would have already checked that the callee is a cell.
  #endif
          // FIXME: We could add a fast path for InternalFunction with closure call.
          slowPath.append(stubJit.branchIfNotFunction(calleeGPR));
  
<span class="line-modified">!         stubJit.loadPtr(</span>
<span class="line-modified">!             CCallHelpers::Address(calleeGPR, JSFunction::offsetOfExecutable()),</span>
<span class="line-modified">!             comparisonValueGPR);</span>
      }
  
      BinarySwitch binarySwitch(comparisonValueGPR, caseValues, BinarySwitch::IntPtr);
      CCallHelpers::JumpList done;
      while (binarySwitch.advance(stubJit)) {
<span class="line-new-header">--- 1245,14 ---</span>
          // We would have already checked that the callee is a cell.
  #endif
          // FIXME: We could add a fast path for InternalFunction with closure call.
          slowPath.append(stubJit.branchIfNotFunction(calleeGPR));
  
<span class="line-modified">!         stubJit.loadPtr(CCallHelpers::Address(calleeGPR, JSFunction::offsetOfExecutableOrRareData()), comparisonValueGPR);</span>
<span class="line-modified">!         auto hasExecutable = stubJit.branchTestPtr(CCallHelpers::Zero, comparisonValueGPR, CCallHelpers::TrustedImm32(JSFunction::rareDataTag));</span>
<span class="line-modified">!         stubJit.loadPtr(CCallHelpers::Address(comparisonValueGPR, FunctionRareData::offsetOfExecutable() - JSFunction::rareDataTag), comparisonValueGPR);</span>
<span class="line-added">+         hasExecutable.link(&amp;stubJit);</span>
      }
  
      BinarySwitch binarySwitch(comparisonValueGPR, caseValues, BinarySwitch::IntPtr);
      CCallHelpers::JumpList done;
      while (binarySwitch.advance(stubJit)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1191,19 ***</span>
          stubJit.move(calleeGPR, GPRInfo::regT0);
  #if USE(JSVALUE32_64)
          stubJit.move(CCallHelpers::TrustedImm32(JSValue::CellTag), GPRInfo::regT1);
  #endif
      }
      stubJit.move(CCallHelpers::TrustedImmPtr(&amp;callLinkInfo), GPRInfo::regT2);
      stubJit.move(CCallHelpers::TrustedImmPtr(callLinkInfo.callReturnLocation().untaggedExecutableAddress()), GPRInfo::regT4);
  
      stubJit.restoreReturnAddressBeforeReturn(GPRInfo::regT4);
      AssemblyHelpers::Jump slow = stubJit.jump();
  
      LinkBuffer patchBuffer(stubJit, owner, JITCompilationCanFail);
      if (patchBuffer.didFailToAllocate()) {
<span class="line-modified">!         linkVirtualFor(exec, callLinkInfo);</span>
          return;
      }
  
      RELEASE_ASSERT(callCases.size() == calls.size());
      for (CallToCodePtr callToCodePtr : calls) {
<span class="line-new-header">--- 1306,20 ---</span>
          stubJit.move(calleeGPR, GPRInfo::regT0);
  #if USE(JSVALUE32_64)
          stubJit.move(CCallHelpers::TrustedImm32(JSValue::CellTag), GPRInfo::regT1);
  #endif
      }
<span class="line-added">+     stubJit.move(CCallHelpers::TrustedImmPtr(globalObject), GPRInfo::regT3);</span>
      stubJit.move(CCallHelpers::TrustedImmPtr(&amp;callLinkInfo), GPRInfo::regT2);
      stubJit.move(CCallHelpers::TrustedImmPtr(callLinkInfo.callReturnLocation().untaggedExecutableAddress()), GPRInfo::regT4);
  
      stubJit.restoreReturnAddressBeforeReturn(GPRInfo::regT4);
      AssemblyHelpers::Jump slow = stubJit.jump();
  
      LinkBuffer patchBuffer(stubJit, owner, JITCompilationCanFail);
      if (patchBuffer.didFailToAllocate()) {
<span class="line-modified">!         linkVirtualFor(vm, callFrame, callLinkInfo);</span>
          return;
      }
  
      RELEASE_ASSERT(callCases.size() == calls.size());
      for (CallToCodePtr callToCodePtr : calls) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1227,11 ***</span>
          FINALIZE_CODE_FOR(
              callerCodeBlock, patchBuffer, JITStubRoutinePtrTag,
              &quot;Polymorphic call stub for %s, return point %p, targets %s&quot;,
                  isWebAssembly ? &quot;WebAssembly&quot; : toCString(*callerCodeBlock).data(), callLinkInfo.callReturnLocation().labelAtOffset(0).executableAddress(),
                  toCString(listDump(callCases)).data()),
<span class="line-modified">!         vm, owner, exec-&gt;callerFrame(), callLinkInfo, callCases,</span>
          WTFMove(fastCounts)));
  
      MacroAssembler::replaceWithJump(
          MacroAssembler::startOfBranchPtrWithPatchOnRegister(callLinkInfo.hotPathBegin()),
          CodeLocationLabel&lt;JITStubRoutinePtrTag&gt;(stubRoutine-&gt;code().code()));
<span class="line-new-header">--- 1343,11 ---</span>
          FINALIZE_CODE_FOR(
              callerCodeBlock, patchBuffer, JITStubRoutinePtrTag,
              &quot;Polymorphic call stub for %s, return point %p, targets %s&quot;,
                  isWebAssembly ? &quot;WebAssembly&quot; : toCString(*callerCodeBlock).data(), callLinkInfo.callReturnLocation().labelAtOffset(0).executableAddress(),
                  toCString(listDump(callCases)).data()),
<span class="line-modified">!         vm, owner, callFrame-&gt;callerFrame(), callLinkInfo, callCases,</span>
          WTFMove(fastCounts)));
  
      MacroAssembler::replaceWithJump(
          MacroAssembler::startOfBranchPtrWithPatchOnRegister(callLinkInfo.hotPathBegin()),
          CodeLocationLabel&lt;JITStubRoutinePtrTag&gt;(stubRoutine-&gt;code().code()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1248,20 ***</span>
      // stub.
      if (callLinkInfo.isOnList())
          callLinkInfo.remove();
  }
  
<span class="line-modified">! void resetGetByID(CodeBlock* codeBlock, StructureStubInfo&amp; stubInfo, GetByIDKind kind)</span>
  {
<span class="line-modified">!     ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation(), appropriateOptimizingGetByIdFunction(kind));</span>
<span class="line-modified">!     InlineAccess::rewireStubAsJump(stubInfo, stubInfo.slowPathStartLocation());</span>
  }
  
  void resetPutByID(CodeBlock* codeBlock, StructureStubInfo&amp; stubInfo)
  {
<span class="line-modified">!     V_JITOperation_ESsiJJI unoptimizedFunction = reinterpret_cast&lt;V_JITOperation_ESsiJJI&gt;(readPutICCallTarget(codeBlock, stubInfo.slowPathCallLocation()).executableAddress());</span>
<span class="line-modified">!     V_JITOperation_ESsiJJI optimizedFunction;</span>
      if (unoptimizedFunction == operationPutByIdStrict || unoptimizedFunction == operationPutByIdStrictOptimize)
          optimizedFunction = operationPutByIdStrictOptimize;
      else if (unoptimizedFunction == operationPutByIdNonStrict || unoptimizedFunction == operationPutByIdNonStrictOptimize)
          optimizedFunction = operationPutByIdNonStrictOptimize;
      else if (unoptimizedFunction == operationPutByIdDirectStrict || unoptimizedFunction == operationPutByIdDirectStrictOptimize)
<span class="line-new-header">--- 1364,20 ---</span>
      // stub.
      if (callLinkInfo.isOnList())
          callLinkInfo.remove();
  }
  
<span class="line-modified">! void resetGetBy(CodeBlock* codeBlock, StructureStubInfo&amp; stubInfo, GetByKind kind)</span>
  {
<span class="line-modified">!     ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation, appropriateOptimizingGetByFunction(kind));</span>
<span class="line-modified">!     InlineAccess::rewireStubAsJump(stubInfo, stubInfo.slowPathStartLocation);</span>
  }
  
  void resetPutByID(CodeBlock* codeBlock, StructureStubInfo&amp; stubInfo)
  {
<span class="line-modified">!     V_JITOperation_GSsiJJI unoptimizedFunction = reinterpret_cast&lt;V_JITOperation_GSsiJJI&gt;(readPutICCallTarget(codeBlock, stubInfo.slowPathCallLocation).executableAddress());</span>
<span class="line-modified">!     V_JITOperation_GSsiJJI optimizedFunction;</span>
      if (unoptimizedFunction == operationPutByIdStrict || unoptimizedFunction == operationPutByIdStrictOptimize)
          optimizedFunction = operationPutByIdStrictOptimize;
      else if (unoptimizedFunction == operationPutByIdNonStrict || unoptimizedFunction == operationPutByIdNonStrictOptimize)
          optimizedFunction = operationPutByIdNonStrictOptimize;
      else if (unoptimizedFunction == operationPutByIdDirectStrict || unoptimizedFunction == operationPutByIdDirectStrictOptimize)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1269,23 ***</span>
      else {
          ASSERT(unoptimizedFunction == operationPutByIdDirectNonStrict || unoptimizedFunction == operationPutByIdDirectNonStrictOptimize);
          optimizedFunction = operationPutByIdDirectNonStrictOptimize;
      }
  
<span class="line-modified">!     ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation(), optimizedFunction);</span>
<span class="line-modified">!     InlineAccess::rewireStubAsJump(stubInfo, stubInfo.slowPathStartLocation());</span>
  }
  
  static void resetPatchableJump(StructureStubInfo&amp; stubInfo)
  {
<span class="line-modified">!     MacroAssembler::repatchJump(stubInfo.patchableJump(), stubInfo.slowPathStartLocation());</span>
  }
  
  void resetInByID(CodeBlock* codeBlock, StructureStubInfo&amp; stubInfo)
  {
<span class="line-modified">!     ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation(), operationInByIdOptimize);</span>
<span class="line-modified">!     InlineAccess::rewireStubAsJump(stubInfo, stubInfo.slowPathStartLocation());</span>
  }
  
  void resetInstanceOf(StructureStubInfo&amp; stubInfo)
  {
      resetPatchableJump(stubInfo);
<span class="line-new-header">--- 1385,23 ---</span>
      else {
          ASSERT(unoptimizedFunction == operationPutByIdDirectNonStrict || unoptimizedFunction == operationPutByIdDirectNonStrictOptimize);
          optimizedFunction = operationPutByIdDirectNonStrictOptimize;
      }
  
<span class="line-modified">!     ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation, optimizedFunction);</span>
<span class="line-modified">!     InlineAccess::rewireStubAsJump(stubInfo, stubInfo.slowPathStartLocation);</span>
  }
  
  static void resetPatchableJump(StructureStubInfo&amp; stubInfo)
  {
<span class="line-modified">!     MacroAssembler::repatchJump(stubInfo.patchableJump(), stubInfo.slowPathStartLocation);</span>
  }
  
  void resetInByID(CodeBlock* codeBlock, StructureStubInfo&amp; stubInfo)
  {
<span class="line-modified">!     ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation, operationInByIdOptimize);</span>
<span class="line-modified">!     InlineAccess::rewireStubAsJump(stubInfo, stubInfo.slowPathStartLocation);</span>
  }
  
  void resetInstanceOf(StructureStubInfo&amp; stubInfo)
  {
      resetPatchableJump(stubInfo);
</pre>
<center><a href="RegisterSet.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Repatch.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
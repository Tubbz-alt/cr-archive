<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/CallFrame.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2008-2018 Apple Inc. All Rights Reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;CallFrame.h&quot;
 28 
 29 #include &quot;CodeBlock.h&quot;
 30 #include &quot;ExecutableAllocator.h&quot;
 31 #include &quot;InlineCallFrame.h&quot;
 32 #include &quot;Interpreter.h&quot;
 33 #include &quot;JSCInlines.h&quot;
 34 #include &quot;JSWebAssemblyInstance.h&quot;
 35 #include &quot;LLIntPCRanges.h&quot;
 36 #include &quot;VMEntryScope.h&quot;
 37 #include &quot;WasmContextInlines.h&quot;
 38 #include &quot;WasmInstance.h&quot;
 39 #include &lt;wtf/StringPrintStream.h&gt;
 40 
 41 namespace JSC {
 42 
 43 void CallFrame::initDeprecatedCallFrameForDebugger(CallFrame* globalExec, JSCallee* globalCallee)
 44 {
 45     globalExec-&gt;setCodeBlock(nullptr);
 46     globalExec-&gt;setCallerFrame(noCaller());
 47     globalExec-&gt;setReturnPC(0);
 48     globalExec-&gt;setArgumentCountIncludingThis(0);
 49     globalExec-&gt;setCallee(globalCallee);
 50     ASSERT(globalExec-&gt;isDeprecatedCallFrameForDebugger());
 51 }
 52 
 53 bool CallFrame::callSiteBitsAreBytecodeOffset() const
 54 {
 55     ASSERT(codeBlock());
 56     switch (codeBlock()-&gt;jitType()) {
 57     case JITType::InterpreterThunk:
 58     case JITType::BaselineJIT:
 59         return true;
 60     case JITType::None:
 61     case JITType::HostCallThunk:
 62         RELEASE_ASSERT_NOT_REACHED();
 63         return false;
 64     default:
 65         return false;
 66     }
 67 
 68     RELEASE_ASSERT_NOT_REACHED();
 69     return false;
 70 }
 71 
 72 bool CallFrame::callSiteBitsAreCodeOriginIndex() const
 73 {
 74     ASSERT(codeBlock());
 75     switch (codeBlock()-&gt;jitType()) {
 76     case JITType::DFGJIT:
 77     case JITType::FTLJIT:
 78         return true;
 79     case JITType::None:
 80     case JITType::HostCallThunk:
 81         RELEASE_ASSERT_NOT_REACHED();
 82         return false;
 83     default:
 84         return false;
 85     }
 86 
 87     RELEASE_ASSERT_NOT_REACHED();
 88     return false;
 89 }
 90 
 91 unsigned CallFrame::callSiteAsRawBits() const
 92 {
 93     return this[static_cast&lt;int&gt;(CallFrameSlot::argumentCountIncludingThis)].tag();
 94 }
 95 
 96 SUPPRESS_ASAN unsigned CallFrame::unsafeCallSiteAsRawBits() const
 97 {
 98     return this[static_cast&lt;int&gt;(CallFrameSlot::argumentCountIncludingThis)].unsafeTag();
 99 }
100 
101 CallSiteIndex CallFrame::callSiteIndex() const
102 {
103     return CallSiteIndex::fromBits(callSiteAsRawBits());
104 }
105 
106 SUPPRESS_ASAN CallSiteIndex CallFrame::unsafeCallSiteIndex() const
107 {
108     return CallSiteIndex::fromBits(unsafeCallSiteAsRawBits());
109 }
110 
111 const Instruction* CallFrame::currentVPC() const
112 {
113     ASSERT(callSiteBitsAreBytecodeOffset());
114     return codeBlock()-&gt;instructions().at(callSiteBitsAsBytecodeOffset()).ptr();
115 }
116 
117 void CallFrame::setCurrentVPC(const Instruction* vpc)
118 {
119     CallSiteIndex callSite(codeBlock()-&gt;bytecodeIndex(vpc));
120     this[static_cast&lt;int&gt;(CallFrameSlot::argumentCountIncludingThis)].tag() = callSite.bits();
121     ASSERT(currentVPC() == vpc);
122 }
123 
124 unsigned CallFrame::callSiteBitsAsBytecodeOffset() const
125 {
126     ASSERT(codeBlock());
127     ASSERT(callSiteBitsAreBytecodeOffset());
128     return callSiteIndex().bits();
129 }
130 
131 BytecodeIndex CallFrame::bytecodeIndex()
132 {
133     ASSERT(!callee().isWasm());
134     if (!codeBlock())
135         return BytecodeIndex(0);
136 #if ENABLE(DFG_JIT)
137     if (callSiteBitsAreCodeOriginIndex()) {
138         ASSERT(codeBlock());
139         CodeOrigin codeOrigin = this-&gt;codeOrigin();
140         for (InlineCallFrame* inlineCallFrame = codeOrigin.inlineCallFrame(); inlineCallFrame;) {
141             codeOrigin = inlineCallFrame-&gt;directCaller;
142             inlineCallFrame = codeOrigin.inlineCallFrame();
143         }
144         return codeOrigin.bytecodeIndex();
145     }
146 #endif
147     ASSERT(callSiteBitsAreBytecodeOffset());
148     return callSiteIndex().bytecodeIndex();
149 }
150 
151 CodeOrigin CallFrame::codeOrigin()
152 {
153     if (!codeBlock())
154         return CodeOrigin(BytecodeIndex(0));
155 #if ENABLE(DFG_JIT)
156     if (callSiteBitsAreCodeOriginIndex()) {
157         CallSiteIndex index = callSiteIndex();
158         ASSERT(codeBlock()-&gt;canGetCodeOrigin(index));
159         return codeBlock()-&gt;codeOrigin(index);
160     }
161 #endif
162     return CodeOrigin(callSiteIndex().bytecodeIndex());
163 }
164 
165 Register* CallFrame::topOfFrameInternal()
166 {
167     CodeBlock* codeBlock = this-&gt;codeBlock();
168     ASSERT(codeBlock);
169     return registers() + codeBlock-&gt;stackPointerOffset();
170 }
171 
172 bool CallFrame::isAnyWasmCallee()
173 {
174     CalleeBits callee = this-&gt;callee();
175     if (callee.isWasm())
176         return true;
177 
178     ASSERT(callee.isCell());
179     if (!!callee.rawPtr() &amp;&amp; isWebAssemblyModule(callee.asCell()))
180         return true;
181 
182     return false;
183 }
184 
185 CallFrame* CallFrame::callerFrame(EntryFrame*&amp; currEntryFrame) const
186 {
187     if (callerFrameOrEntryFrame() == currEntryFrame) {
188         VMEntryRecord* currVMEntryRecord = vmEntryRecord(currEntryFrame);
189         currEntryFrame = currVMEntryRecord-&gt;prevTopEntryFrame();
190         return currVMEntryRecord-&gt;prevTopCallFrame();
191     }
192     return static_cast&lt;CallFrame*&gt;(callerFrameOrEntryFrame());
193 }
194 
195 SUPPRESS_ASAN CallFrame* CallFrame::unsafeCallerFrame(EntryFrame*&amp; currEntryFrame) const
196 {
197     if (unsafeCallerFrameOrEntryFrame() == currEntryFrame) {
198         VMEntryRecord* currVMEntryRecord = vmEntryRecord(currEntryFrame);
199         currEntryFrame = currVMEntryRecord-&gt;unsafePrevTopEntryFrame();
200         return currVMEntryRecord-&gt;unsafePrevTopCallFrame();
201     }
202     return static_cast&lt;CallFrame*&gt;(unsafeCallerFrameOrEntryFrame());
203 }
204 
205 SourceOrigin CallFrame::callerSourceOrigin(VM&amp; vm)
206 {
207     RELEASE_ASSERT(callee().isCell());
208     SourceOrigin sourceOrigin;
209     bool haveSkippedFirstFrame = false;
210     StackVisitor::visit(this, vm, [&amp;](StackVisitor&amp; visitor) {
211         if (!std::exchange(haveSkippedFirstFrame, true))
212             return StackVisitor::Status::Continue;
213 
214         switch (visitor-&gt;codeType()) {
215         case StackVisitor::Frame::CodeType::Function:
216             // Skip the builtin functions since they should not pass the source origin to the dynamic code generation calls.
217             // Consider the following code.
218             //
219             // [ &quot;42 + 44&quot; ].forEach(eval);
220             //
221             // In the above case, the eval function will be interpreted as the indirect call to eval inside forEach function.
222             // At that time, the generated eval code should have the source origin to the original caller of the forEach function
223             // instead of the source origin of the forEach function.
224             if (static_cast&lt;FunctionExecutable*&gt;(visitor-&gt;codeBlock()-&gt;ownerExecutable())-&gt;isBuiltinFunction())
225                 return StackVisitor::Status::Continue;
226             FALLTHROUGH;
227 
228         case StackVisitor::Frame::CodeType::Eval:
229         case StackVisitor::Frame::CodeType::Module:
230         case StackVisitor::Frame::CodeType::Global:
231             sourceOrigin = visitor-&gt;codeBlock()-&gt;ownerExecutable()-&gt;sourceOrigin();
232             return StackVisitor::Status::Done;
233 
234         case StackVisitor::Frame::CodeType::Native:
235             return StackVisitor::Status::Continue;
236 
237         case StackVisitor::Frame::CodeType::Wasm:
238             // FIXME: Should return the source origin for WASM.
239             return StackVisitor::Status::Done;
240         }
241 
242         RELEASE_ASSERT_NOT_REACHED();
243         return StackVisitor::Status::Done;
244     });
245     return sourceOrigin;
246 }
247 
248 String CallFrame::friendlyFunctionName()
249 {
250     CodeBlock* codeBlock = this-&gt;codeBlock();
251     if (!codeBlock)
252         return emptyString();
253 
254     switch (codeBlock-&gt;codeType()) {
255     case EvalCode:
256         return &quot;eval code&quot;_s;
257     case ModuleCode:
258         return &quot;module code&quot;_s;
259     case GlobalCode:
260         return &quot;global code&quot;_s;
261     case FunctionCode:
262         if (jsCallee())
263             return getCalculatedDisplayName(codeBlock-&gt;vm(), jsCallee());
264         return emptyString();
265     }
266 
267     ASSERT_NOT_REACHED();
268     return emptyString();
269 }
270 
271 void CallFrame::dump(PrintStream&amp; out)
272 {
273     if (CodeBlock* codeBlock = this-&gt;codeBlock()) {
274         out.print(codeBlock-&gt;inferredName(), &quot;#&quot;, codeBlock-&gt;hashAsStringIfPossible(), &quot; [&quot;, codeBlock-&gt;jitType(), &quot; &quot;, bytecodeIndex(), &quot;]&quot;);
275 
276         out.print(&quot;(&quot;);
277         thisValue().dumpForBacktrace(out);
278 
279         for (size_t i = 0; i &lt; argumentCount(); ++i) {
280             out.print(&quot;, &quot;);
281             JSValue value = argument(i);
282             value.dumpForBacktrace(out);
283         }
284 
285         out.print(&quot;)&quot;);
286 
287         return;
288     }
289 
290     out.print(returnPC());
291 }
292 
293 const char* CallFrame::describeFrame()
294 {
295     const size_t bufferSize = 200;
296     static char buffer[bufferSize + 1];
297 
298     WTF::StringPrintStream stringStream;
299 
300     dump(stringStream);
301 
302     strncpy(buffer, stringStream.toCString().data(), bufferSize);
303     buffer[bufferSize] = &#39;\0&#39;;
304 
305     return buffer;
306 }
307 
308 void CallFrame::convertToStackOverflowFrame(VM&amp; vm, CodeBlock* codeBlockToKeepAliveUntilFrameIsUnwound)
309 {
310     ASSERT(!isDeprecatedCallFrameForDebugger());
311     ASSERT(codeBlockToKeepAliveUntilFrameIsUnwound-&gt;inherits&lt;CodeBlock&gt;(vm));
312 
313     EntryFrame* entryFrame = vm.topEntryFrame;
314     CallFrame* throwOriginFrame = this;
315     do {
316         throwOriginFrame = throwOriginFrame-&gt;callerFrame(entryFrame);
317     } while (throwOriginFrame &amp;&amp; throwOriginFrame-&gt;callee().isWasm());
318 
319     JSObject* originCallee = throwOriginFrame ? throwOriginFrame-&gt;jsCallee() : vmEntryRecord(vm.topEntryFrame)-&gt;callee();
320     JSObject* stackOverflowCallee = originCallee-&gt;globalObject()-&gt;stackOverflowFrameCallee();
321 
322     setCodeBlock(codeBlockToKeepAliveUntilFrameIsUnwound);
323     setCallee(stackOverflowCallee);
324     setArgumentCountIncludingThis(0);
325 }
326 
327 #if ENABLE(WEBASSEMBLY)
328 JSGlobalObject* CallFrame::lexicalGlobalObjectFromWasmCallee(VM&amp; vm) const
329 {
330     return vm.wasmContext.load()-&gt;owner&lt;JSWebAssemblyInstance&gt;()-&gt;globalObject();
331 }
332 #endif
333 
334 bool isFromJSCode(void* returnAddress)
335 {
336     UNUSED_PARAM(returnAddress);
337 #if ENABLE(JIT)
338     if (isJITPC(returnAddress))
339         return true;
340 #endif
341 #if ENABLE(C_LOOP)
342     return true;
343 #else
344     return LLInt::isLLIntPC(returnAddress);
345 #endif
346 }
347 
348 } // namespace JSC
    </pre>
  </body>
</html>
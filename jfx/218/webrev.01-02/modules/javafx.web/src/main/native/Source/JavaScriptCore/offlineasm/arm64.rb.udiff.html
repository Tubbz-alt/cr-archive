<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/arm64.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="arm.rb.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="asm.rb.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/arm64.rb</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -45,12 +45,12 @@</span>
  #  x5  =&gt; t5
  # x13  =&gt;                  (scratch)
  # x16  =&gt;                  (scratch)
  # x17  =&gt;                  (scratch)
  # x26  =&gt;             csr0 (PB)
<span class="udiff-line-modified-removed">- # x27  =&gt;             csr1 (tagTypeNumber)</span>
<span class="udiff-line-modified-removed">- # x28  =&gt;             csr2 (tagMask)</span>
<span class="udiff-line-modified-added">+ # x27  =&gt;             csr1 (numberTag)</span>
<span class="udiff-line-modified-added">+ # x28  =&gt;             csr2 (notCellMask)</span>
  # x29  =&gt; cfr
  #  sp  =&gt; sp
  #  lr  =&gt; lr
  #
  # FPR conventions, to match the baseline JIT:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -86,13 +86,21 @@</span>
          raise &quot;Wrong kind: #{kind}&quot;
      end
  end
  
  def arm64FPRName(name, kind)
<span class="udiff-line-removed">-     raise &quot;bad FPR kind #{kind}&quot; unless kind == :double</span>
      raise &quot;bad FPR name #{name}&quot; unless name =~ /^q/
<span class="udiff-line-modified-removed">-     &quot;d&quot; + name[1..-1]</span>
<span class="udiff-line-modified-added">+     case kind</span>
<span class="udiff-line-added">+     when :double</span>
<span class="udiff-line-added">+         &quot;d&quot; + name[1..-1]</span>
<span class="udiff-line-added">+     when :float</span>
<span class="udiff-line-added">+         &quot;s&quot; + name[1..-1]</span>
<span class="udiff-line-added">+     when :vector</span>
<span class="udiff-line-added">+         &quot;v&quot; + name[1..-1]</span>
<span class="udiff-line-added">+     else</span>
<span class="udiff-line-added">+         raise &quot;bad FPR kind #{kind}&quot;</span>
<span class="udiff-line-added">+     end</span>
  end
  
  class SpecialRegister
      def arm64Operand(kind)
          case @name
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -110,26 +118,30 @@</span>
  ARM64_EXTRA_FPRS = [SpecialRegister.new(&quot;q31&quot;)]
  
  class RegisterID
      def arm64Operand(kind)
          case @name
<span class="udiff-line-modified-removed">-         when &#39;t0&#39;, &#39;a0&#39;, &#39;r0&#39;</span>
<span class="udiff-line-modified-added">+         when &#39;t0&#39;, &#39;a0&#39;, &#39;r0&#39;, &#39;wa0&#39;</span>
              arm64GPRName(&#39;x0&#39;, kind)
<span class="udiff-line-modified-removed">-         when &#39;t1&#39;, &#39;a1&#39;, &#39;r1&#39;</span>
<span class="udiff-line-modified-added">+         when &#39;t1&#39;, &#39;a1&#39;, &#39;r1&#39;, &#39;wa1&#39;</span>
              arm64GPRName(&#39;x1&#39;, kind)
<span class="udiff-line-modified-removed">-         when &#39;t2&#39;, &#39;a2&#39;</span>
<span class="udiff-line-modified-added">+         when &#39;t2&#39;, &#39;a2&#39;, &#39;wa2&#39;</span>
              arm64GPRName(&#39;x2&#39;, kind)
<span class="udiff-line-modified-removed">-         when &#39;t3&#39;, &#39;a3&#39;</span>
<span class="udiff-line-modified-added">+         when &#39;t3&#39;, &#39;a3&#39;, &#39;wa3&#39;</span>
              arm64GPRName(&#39;x3&#39;, kind)
<span class="udiff-line-modified-removed">-         when &#39;t4&#39;</span>
<span class="udiff-line-modified-added">+         when &#39;t4&#39;, &#39;wa4&#39;</span>
              arm64GPRName(&#39;x4&#39;, kind)
<span class="udiff-line-modified-removed">-         when &#39;t5&#39;</span>
<span class="udiff-line-modified-added">+         when &#39;t5&#39;, &#39;wa5&#39;</span>
            arm64GPRName(&#39;x5&#39;, kind)
<span class="udiff-line-modified-removed">-         when &#39;t6&#39;</span>
<span class="udiff-line-modified-added">+         when &#39;t6&#39;, &#39;wa6&#39;</span>
            arm64GPRName(&#39;x6&#39;, kind)
<span class="udiff-line-modified-removed">-         when &#39;t7&#39;</span>
<span class="udiff-line-modified-added">+         when &#39;t7&#39;, &#39;wa7&#39;</span>
            arm64GPRName(&#39;x7&#39;, kind)
<span class="udiff-line-added">+         when &#39;ws0&#39;</span>
<span class="udiff-line-added">+           arm64GPRName(&#39;x9&#39;, kind)</span>
<span class="udiff-line-added">+         when &#39;ws1&#39;</span>
<span class="udiff-line-added">+           arm64GPRName(&#39;x10&#39;, kind)</span>
          when &#39;cfr&#39;
              arm64GPRName(&#39;x29&#39;, kind)
          when &#39;csr0&#39;
              arm64GPRName(&#39;x19&#39;, kind)
          when &#39;csr1&#39;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -161,22 +173,26 @@</span>
  end
  
  class FPRegisterID
      def arm64Operand(kind)
          case @name
<span class="udiff-line-modified-removed">-         when &#39;ft0&#39;, &#39;fr&#39;, &#39;fa0&#39;</span>
<span class="udiff-line-modified-added">+         when &#39;ft0&#39;, &#39;fr&#39;, &#39;fa0&#39;, &#39;wfa0&#39;</span>
              arm64FPRName(&#39;q0&#39;, kind)
<span class="udiff-line-modified-removed">-         when &#39;ft1&#39;, &#39;fa1&#39;</span>
<span class="udiff-line-modified-added">+         when &#39;ft1&#39;, &#39;fa1&#39;, &#39;wfa1&#39;</span>
              arm64FPRName(&#39;q1&#39;, kind)
<span class="udiff-line-modified-removed">-         when &#39;ft2&#39;, &#39;fa2&#39;</span>
<span class="udiff-line-modified-added">+         when &#39;ft2&#39;, &#39;fa2&#39;, &#39;wfa2&#39;</span>
              arm64FPRName(&#39;q2&#39;, kind)
<span class="udiff-line-modified-removed">-         when &#39;ft3&#39;, &#39;fa3&#39;</span>
<span class="udiff-line-modified-added">+         when &#39;ft3&#39;, &#39;fa3&#39;, &#39;wfa3&#39;</span>
              arm64FPRName(&#39;q3&#39;, kind)
<span class="udiff-line-modified-removed">-         when &#39;ft4&#39;</span>
<span class="udiff-line-modified-added">+         when &#39;ft4&#39;, &#39;wfa4&#39;</span>
              arm64FPRName(&#39;q4&#39;, kind)
<span class="udiff-line-modified-removed">-         when &#39;ft5&#39;</span>
<span class="udiff-line-modified-added">+         when &#39;ft5&#39;, &#39;wfa5&#39;</span>
              arm64FPRName(&#39;q5&#39;, kind)
<span class="udiff-line-added">+         when &#39;wfa6&#39;</span>
<span class="udiff-line-added">+             arm64FPRName(&#39;q6&#39;, kind)</span>
<span class="udiff-line-added">+         when &#39;wfa7&#39;</span>
<span class="udiff-line-added">+             arm64FPRName(&#39;q7&#39;, kind)</span>
          when &#39;csfr0&#39;
              arm64FPRName(&#39;q8&#39;, kind)
          when &#39;csfr1&#39;
              arm64FPRName(&#39;q9&#39;, kind)
          when &#39;csfr2&#39;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -196,11 +212,10 @@</span>
      end
  end
  
  class Immediate
      def arm64Operand(kind)
<span class="udiff-line-removed">-         raise &quot;Invalid immediate #{value} at #{codeOriginString}&quot; if value &lt; 0 or value &gt; 4095</span>
          &quot;\##{value}&quot;
      end
  end
  
  class Address
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -376,15 +391,15 @@</span>
          result = riscLowerMalformedAddresses(result) {
              | node, address |
              case node.opcode
              when &quot;loadb&quot;, &quot;loadbsi&quot;, &quot;loadbsq&quot;, &quot;storeb&quot;, /^bb/, /^btb/, /^cb/, /^tb/
                  size = 1
<span class="udiff-line-modified-removed">-             when &quot;loadh&quot;, &quot;loadhsi&quot;, &quot;loadhsq&quot;</span>
<span class="udiff-line-modified-added">+             when &quot;loadh&quot;, &quot;loadhsi&quot;, &quot;loadhsq&quot;, &quot;orh&quot;, &quot;storeh&quot;</span>
                  size = 2
              when &quot;loadi&quot;, &quot;loadis&quot;, &quot;storei&quot;, &quot;addi&quot;, &quot;andi&quot;, &quot;lshifti&quot;, &quot;muli&quot;, &quot;negi&quot;,
                  &quot;noti&quot;, &quot;ori&quot;, &quot;rshifti&quot;, &quot;urshifti&quot;, &quot;subi&quot;, &quot;xori&quot;, /^bi/, /^bti/,
<span class="udiff-line-modified-removed">-                 /^ci/, /^ti/, &quot;addis&quot;, &quot;subis&quot;, &quot;mulis&quot;, &quot;smulli&quot;, &quot;leai&quot;</span>
<span class="udiff-line-modified-added">+                 /^ci/, /^ti/, &quot;addis&quot;, &quot;subis&quot;, &quot;mulis&quot;, &quot;smulli&quot;, &quot;leai&quot;, &quot;loadf&quot;, &quot;storef&quot;</span>
                  size = 4
              when &quot;loadp&quot;, &quot;storep&quot;, &quot;loadq&quot;, &quot;storeq&quot;, &quot;loadd&quot;, &quot;stored&quot;, &quot;lshiftp&quot;, &quot;lshiftq&quot;, &quot;negp&quot;, &quot;negq&quot;, &quot;rshiftp&quot;, &quot;rshiftq&quot;,
                  &quot;urshiftp&quot;, &quot;urshiftq&quot;, &quot;addp&quot;, &quot;addq&quot;, &quot;mulp&quot;, &quot;mulq&quot;, &quot;andp&quot;, &quot;andq&quot;, &quot;orp&quot;, &quot;orq&quot;, &quot;subp&quot;, &quot;subq&quot;, &quot;xorp&quot;, &quot;xorq&quot;, &quot;addd&quot;,
                  &quot;divd&quot;, &quot;subd&quot;, &quot;muld&quot;, &quot;sqrtd&quot;, /^bp/, /^bq/, /^btp/, /^btq/, /^cp/, /^cq/, /^tp/, /^tq/, /^bd/,
                  &quot;jmp&quot;, &quot;call&quot;, &quot;leap&quot;, &quot;leaq&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -400,12 +415,45 @@</span>
                  (-255..4095).include? address.offset.value
              else
                  false
              end
          }
<span class="udiff-line-modified-removed">-         result = riscLowerMisplacedImmediates(result, [&quot;storeb&quot;, &quot;storei&quot;, &quot;storep&quot;, &quot;storeq&quot;])</span>
<span class="udiff-line-modified-removed">-         result = riscLowerMalformedImmediates(result, 0..4095)</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         result = riscLowerMisplacedImmediates(result, [&quot;storeb&quot;, &quot;storeh&quot;, &quot;storei&quot;, &quot;storep&quot;, &quot;storeq&quot;])</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         # The rules for which immediates are valid for and/or/xor instructions are fairly involved, see https://dinfuehr.github.io/blog/encoding-of-immediate-values-on-aarch64/</span>
<span class="udiff-line-added">+         validLogicalImmediates = []</span>
<span class="udiff-line-added">+         def rotate(value, n, size)</span>
<span class="udiff-line-added">+             mask = (1 &lt;&lt; size) - 1</span>
<span class="udiff-line-added">+             shiftedValue = value &lt;&lt; n</span>
<span class="udiff-line-added">+             result = (shiftedValue &amp; mask) | ((shiftedValue &amp; ~mask) &gt;&gt; size)</span>
<span class="udiff-line-added">+             return result</span>
<span class="udiff-line-added">+         end</span>
<span class="udiff-line-added">+         def replicate(value, size)</span>
<span class="udiff-line-added">+             until size == 64 do</span>
<span class="udiff-line-added">+                 value = value | (value &lt;&lt; size)</span>
<span class="udiff-line-added">+                 size *= 2</span>
<span class="udiff-line-added">+             end</span>
<span class="udiff-line-added">+             return value</span>
<span class="udiff-line-added">+         end</span>
<span class="udiff-line-added">+         size = 2</span>
<span class="udiff-line-added">+         until size &gt; 64 do</span>
<span class="udiff-line-added">+             for numberOfOnes in 1..(size-1) do</span>
<span class="udiff-line-added">+                 for rotation in 0..(size-1) do</span>
<span class="udiff-line-added">+                     immediate = 0;</span>
<span class="udiff-line-added">+                     for i in 0..(numberOfOnes-1) do</span>
<span class="udiff-line-added">+                         immediate = immediate*2 + 1</span>
<span class="udiff-line-added">+                     end</span>
<span class="udiff-line-added">+                     immediate = rotate(immediate, rotation, size)</span>
<span class="udiff-line-added">+                     immediate = replicate(immediate, size)</span>
<span class="udiff-line-added">+                     validLogicalImmediates &lt;&lt; immediate</span>
<span class="udiff-line-added">+                 end</span>
<span class="udiff-line-added">+             end</span>
<span class="udiff-line-added">+             size *= 2</span>
<span class="udiff-line-added">+         end</span>
<span class="udiff-line-added">+         result = riscLowerMalformedImmediates(result, 0..4095, validLogicalImmediates)</span>
<span class="udiff-line-added">+ </span>
          result = riscLowerMisplacedAddresses(result)
          result = riscLowerMalformedAddresses(result) {
              | node, address |
              case node.opcode
              when /^load/
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -529,10 +577,37 @@</span>
  
  def emitARM64TAC(opcode, operands, kind)
      $asm.puts &quot;#{opcode} #{arm64TACOperands(operands, kind)}&quot;
  end
  
<span class="udiff-line-added">+ def emitARM64Div(opcode, operands, kind)</span>
<span class="udiff-line-added">+     if operands.size == 2</span>
<span class="udiff-line-added">+         operands = [operands[1], operands[1], operands[0]]</span>
<span class="udiff-line-added">+     elsif operands.size == 3</span>
<span class="udiff-line-added">+         operands = [operands[2], operands[1], operands[0]]</span>
<span class="udiff-line-added">+     else</span>
<span class="udiff-line-added">+         raise</span>
<span class="udiff-line-added">+     end</span>
<span class="udiff-line-added">+     $asm.puts &quot;#{opcode} #{arm64Operands(operands, kind)}&quot;</span>
<span class="udiff-line-added">+ end</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ def emitARM64TACWithOperandSuffix(opcode, operands, kind)</span>
<span class="udiff-line-added">+     raise unless [:float, :double].include? kind</span>
<span class="udiff-line-added">+     size = kind == :float ? 8 : 16</span>
<span class="udiff-line-added">+     operands = operands.map { |operand|</span>
<span class="udiff-line-added">+         raise unless operand.is_a? FPRegisterID</span>
<span class="udiff-line-added">+         &quot;#{operand.arm64Operand(:vector)}.#{size}b&quot;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if operands.length == 2</span>
<span class="udiff-line-added">+       operands = [operands[1], operands[1], operands[0]]</span>
<span class="udiff-line-added">+     else</span>
<span class="udiff-line-added">+       raise unless operands.length == 3</span>
<span class="udiff-line-added">+       operands = [operands[2], operands[0], operands[1]]</span>
<span class="udiff-line-added">+     end</span>
<span class="udiff-line-added">+     $asm.puts &quot;#{opcode} #{operands.join(&quot;, &quot;)}&quot;</span>
<span class="udiff-line-added">+ end</span>
<span class="udiff-line-added">+ </span>
  def emitARM64(opcode, operands, kind)
      $asm.puts &quot;#{opcode} #{arm64FlippedOperands(operands, kind)}&quot;
  end
  
  def emitARM64Access(opcode, opcodeNegativeOffset, register, memory, kind)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -579,10 +654,15 @@</span>
  def emitARM64Branch(opcode, operands, kind, branchOpcode)
      emitARM64Unflipped(opcode, operands[0..-2], kind)
      $asm.puts &quot;#{branchOpcode} #{operands[-1].asmLabel}&quot;
  end
  
<span class="udiff-line-added">+ def emitARM64CompareFP(operands, kind, compareCode)</span>
<span class="udiff-line-added">+     emitARM64Unflipped(&quot;fcmp&quot;, operands[0..-2], kind)</span>
<span class="udiff-line-added">+     $asm.puts &quot;cset #{operands[-1].arm64Operand(:word)}, #{compareCode}&quot;</span>
<span class="udiff-line-added">+ end</span>
<span class="udiff-line-added">+ </span>
  def emitARM64Compare(operands, kind, compareCode)
      emitARM64Unflipped(&quot;subs #{arm64GPRName(&#39;xzr&#39;, kind)}, &quot;, operands[0..-2], kind)
      $asm.puts &quot;csinc #{operands[-1].arm64Operand(:word)}, wzr, wzr, #{compareCode}&quot;
  end
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -629,16 +709,26 @@</span>
              emitARM64TAC(&quot;orr&quot;, operands, :word)
          when &quot;orp&quot;
              emitARM64TAC(&quot;orr&quot;, operands, :ptr)
          when &quot;orq&quot;
              emitARM64TAC(&quot;orr&quot;, operands, :quad)
<span class="udiff-line-added">+         when &quot;orh&quot;</span>
<span class="udiff-line-added">+             emitARM64TAC(&quot;orr&quot;, operands, :word) # not :half because 16-bit registers don&#39;t exist on ARM.</span>
          when &quot;xori&quot;
              emitARM64TAC(&quot;eor&quot;, operands, :word)
          when &quot;xorp&quot;
              emitARM64TAC(&quot;eor&quot;, operands, :ptr)
          when &quot;xorq&quot;
              emitARM64TAC(&quot;eor&quot;, operands, :quad)
<span class="udiff-line-added">+         when &#39;divi&#39;</span>
<span class="udiff-line-added">+             emitARM64Div(&quot;udiv&quot;, operands, :word)</span>
<span class="udiff-line-added">+         when &#39;divis&#39;</span>
<span class="udiff-line-added">+             emitARM64Div(&quot;sdiv&quot;, operands, :word)</span>
<span class="udiff-line-added">+         when &#39;divq&#39;</span>
<span class="udiff-line-added">+             emitARM64Div(&quot;udiv&quot;, operands, :quad)</span>
<span class="udiff-line-added">+         when &#39;divqs&#39;</span>
<span class="udiff-line-added">+             emitARM64Div(&quot;sdiv&quot;, operands, :quad)</span>
          when &quot;lshifti&quot;
              emitARM64LShift(operands, :word)
          when &quot;lshiftp&quot;
              emitARM64LShift(operands, :ptr)
          when &quot;lshiftq&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -737,20 +827,18 @@</span>
              emitARM64TAC(&quot;fsub&quot;, operands, :double)
          when &quot;muld&quot;
              emitARM64TAC(&quot;fmul&quot;, operands, :double)
          when &quot;sqrtd&quot;
              emitARM64(&quot;fsqrt&quot;, operands, :double)
<span class="udiff-line-removed">-         when &quot;ci2d&quot;</span>
<span class="udiff-line-removed">-             emitARM64(&quot;scvtf&quot;, operands, [:word, :double])</span>
          when &quot;bdeq&quot;
              emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.eq&quot;)
          when &quot;bdneq&quot;
              emitARM64Unflipped(&quot;fcmp&quot;, operands[0..1], :double)
              isUnordered = LocalLabel.unique(&quot;bdneq&quot;)
              $asm.puts &quot;b.vs #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;
              $asm.puts &quot;b.ne #{operands[2].asmLabel}&quot;
<span class="udiff-line-modified-removed">-             isUnordered.lower(&quot;ARM64&quot;)</span>
<span class="udiff-line-modified-added">+             isUnordered.lower($activeBackend)</span>
          when &quot;bdgt&quot;
              emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.gt&quot;)
          when &quot;bdgteq&quot;
              emitARM64Branch(&quot;fcmp&quot;, operands, :double, &quot;b.ge&quot;)
          when &quot;bdlt&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -807,10 +895,12 @@</span>
              if operands[0].immediate?
                  emitARM64MoveImmediate(operands[0].value, operands[1])
              else
                  emitARM64(&quot;mov&quot;, operands, :quad)
              end
<span class="udiff-line-added">+         when &quot;moved&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;fmov&quot;, operands, :double)</span>
          when &quot;sxi2p&quot;
              emitARM64(&quot;sxtw&quot;, operands, [:word, :ptr])
          when &quot;sxi2q&quot;
              emitARM64(&quot;sxtw&quot;, operands, [:word, :quad])
          when &quot;zxi2p&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1054,10 +1144,193 @@</span>
                  # On Darwin, also include the .loh directive using the generated labels.
                  $asm.putStr(&quot;#if OS(DARWIN)&quot;)
                  $asm.puts &quot;.loh AdrpLdrGot L_offlineasm_loh_adrp_#{uid}, L_offlineasm_loh_ldr_#{uid}&quot;
                  $asm.putStr(&quot;#endif&quot;)
              }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         when &quot;andf&quot;, &quot;andd&quot;</span>
<span class="udiff-line-added">+             emitARM64TACWithOperandSuffix(&quot;and&quot;, operands, :double)</span>
<span class="udiff-line-added">+         when &quot;orf&quot;, &quot;ord&quot;</span>
<span class="udiff-line-added">+             emitARM64TACWithOperandSuffix(&quot;orr&quot;, operands, :double)</span>
<span class="udiff-line-added">+         when &quot;lrotatei&quot;</span>
<span class="udiff-line-added">+             tmp = Tmp.new(codeOrigin, :gpr)</span>
<span class="udiff-line-added">+             Sequence.new(codeOrigin, [</span>
<span class="udiff-line-added">+                 Instruction.new(codeOrigin, &quot;move&quot;, [operands[0], tmp]),</span>
<span class="udiff-line-added">+                 Instruction.new(codeOrigin, &quot;negq&quot;, [tmp]),</span>
<span class="udiff-line-added">+                 Instruction.new(codeOrigin, &quot;rrotatei&quot;, [tmp, operands[1]]),</span>
<span class="udiff-line-added">+             ]).lower($activeBackend)</span>
<span class="udiff-line-added">+         when &quot;lrotateq&quot;</span>
<span class="udiff-line-added">+             tmp = Tmp.new(codeOrigin, :gpr)</span>
<span class="udiff-line-added">+             Sequence.new(codeOrigin, [</span>
<span class="udiff-line-added">+                 Instruction.new(codeOrigin, &quot;move&quot;, [operands[0], tmp]),</span>
<span class="udiff-line-added">+                 Instruction.new(codeOrigin, &quot;negq&quot;, [tmp]),</span>
<span class="udiff-line-added">+                 Instruction.new(codeOrigin, &quot;rrotateq&quot;, [tmp, operands[1]]),</span>
<span class="udiff-line-added">+             ]).lower($activeBackend)</span>
<span class="udiff-line-added">+         when &quot;rrotatei&quot;</span>
<span class="udiff-line-added">+             emitARM64TAC(&quot;ror&quot;, operands, :word)</span>
<span class="udiff-line-added">+         when &quot;rrotateq&quot;</span>
<span class="udiff-line-added">+             emitARM64TAC(&quot;ror&quot;, operands, :quad)</span>
<span class="udiff-line-added">+         when &quot;loadf&quot;</span>
<span class="udiff-line-added">+             emitARM64Access(&quot;ldr&quot;, &quot;ldur&quot;, operands[1], operands[0], :float)</span>
<span class="udiff-line-added">+         when &quot;storef&quot;</span>
<span class="udiff-line-added">+             emitARM64Unflipped(&quot;str&quot;, operands, :float)</span>
<span class="udiff-line-added">+         when &quot;addf&quot;</span>
<span class="udiff-line-added">+             emitARM64TAC(&quot;fadd&quot;, operands, :float)</span>
<span class="udiff-line-added">+         when &quot;divf&quot;</span>
<span class="udiff-line-added">+             emitARM64TAC(&quot;fdiv&quot;, operands, :float)</span>
<span class="udiff-line-added">+         when &quot;subf&quot;</span>
<span class="udiff-line-added">+             emitARM64TAC(&quot;fsub&quot;, operands, :float)</span>
<span class="udiff-line-added">+         when &quot;mulf&quot;</span>
<span class="udiff-line-added">+             emitARM64TAC(&quot;fmul&quot;, operands, :float)</span>
<span class="udiff-line-added">+         when &quot;sqrtf&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;fsqrt&quot;, operands, :float)</span>
<span class="udiff-line-added">+         when &quot;floorf&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;frintm&quot;, operands, :float)</span>
<span class="udiff-line-added">+         when &quot;floord&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;frintm&quot;, operands, :double)</span>
<span class="udiff-line-added">+         when &quot;roundf&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;frintn&quot;, operands, :float)</span>
<span class="udiff-line-added">+         when &quot;roundd&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;frintn&quot;, operands, :double)</span>
<span class="udiff-line-added">+         when &quot;truncatef&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;frintz&quot;, operands, :float)</span>
<span class="udiff-line-added">+         when &quot;truncated&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;frintz&quot;, operands, :double)</span>
<span class="udiff-line-added">+         when &quot;truncatef2i&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;fcvtzu&quot;, operands, [:float, :word])</span>
<span class="udiff-line-added">+         when &quot;truncatef2q&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;fcvtzu&quot;, operands, [:float, :quad])</span>
<span class="udiff-line-added">+         when &quot;truncated2q&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;fcvtzu&quot;, operands, [:double, :quad])</span>
<span class="udiff-line-added">+         when &quot;truncated2i&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;fcvtzu&quot;, operands, [:double, :word])</span>
<span class="udiff-line-added">+         when &quot;truncatef2is&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;fcvtzs&quot;, operands, [:float, :word])</span>
<span class="udiff-line-added">+         when &quot;truncated2is&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;fcvtzs&quot;, operands, [:double, :word])</span>
<span class="udiff-line-added">+         when &quot;truncatef2qs&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;fcvtzs&quot;, operands, [:float, :quad])</span>
<span class="udiff-line-added">+         when &quot;truncated2qs&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;fcvtzs&quot;, operands, [:double, :quad])</span>
<span class="udiff-line-added">+         when &quot;ci2d&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;ucvtf&quot;, operands, [:word, :double])</span>
<span class="udiff-line-added">+         when &quot;ci2ds&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;scvtf&quot;, operands, [:word, :double])</span>
<span class="udiff-line-added">+         when &quot;ci2f&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;ucvtf&quot;, operands, [:word, :float])</span>
<span class="udiff-line-added">+         when &quot;ci2fs&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;scvtf&quot;, operands, [:word, :float])</span>
<span class="udiff-line-added">+         when &quot;cq2f&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;ucvtf&quot;, operands, [:quad, :float])</span>
<span class="udiff-line-added">+         when &quot;cq2fs&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;scvtf&quot;, operands, [:quad, :float])</span>
<span class="udiff-line-added">+         when &quot;cq2d&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;ucvtf&quot;, operands, [:quad, :double])</span>
<span class="udiff-line-added">+         when &quot;cq2ds&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;scvtf&quot;, operands, [:quad, :double])</span>
<span class="udiff-line-added">+         when &quot;cd2f&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;fcvt&quot;, operands, [:double, :float])</span>
<span class="udiff-line-added">+         when &quot;cf2d&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;fcvt&quot;, operands, [:float, :double])</span>
<span class="udiff-line-added">+         when &quot;bfeq&quot;</span>
<span class="udiff-line-added">+             emitARM64Branch(&quot;fcmp&quot;, operands, :float, &quot;b.eq&quot;)</span>
<span class="udiff-line-added">+         when &quot;bfgt&quot;</span>
<span class="udiff-line-added">+             emitARM64Branch(&quot;fcmp&quot;, operands, :float, &quot;b.gt&quot;)</span>
<span class="udiff-line-added">+         when &quot;bflt&quot;</span>
<span class="udiff-line-added">+             emitARM64Branch(&quot;fcmp&quot;, operands, :float, &quot;b.mi&quot;)</span>
<span class="udiff-line-added">+         when &quot;bfgtun&quot;</span>
<span class="udiff-line-added">+             emitARM64Branch(&quot;fcmp&quot;, operands, :float, &quot;b.hi&quot;)</span>
<span class="udiff-line-added">+         when &quot;bfgtequn&quot;</span>
<span class="udiff-line-added">+             emitARM64Branch(&quot;fcmp&quot;, operands, :float, &quot;b.pl&quot;)</span>
<span class="udiff-line-added">+         when &quot;bfltun&quot;</span>
<span class="udiff-line-added">+             emitARM64Branch(&quot;fcmp&quot;, operands, :float, &quot;b.lt&quot;)</span>
<span class="udiff-line-added">+         when &quot;bfltequn&quot;</span>
<span class="udiff-line-added">+             emitARM64Branch(&quot;fcmp&quot;, operands, :float, &quot;b.le&quot;)</span>
<span class="udiff-line-added">+         when &quot;tzcnti&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;rbit&quot;, operands, :word)</span>
<span class="udiff-line-added">+             emitARM64(&quot;clz&quot;, [operands[1], operands[1]], :word)</span>
<span class="udiff-line-added">+         when &quot;tzcntq&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;rbit&quot;, operands, :quad)</span>
<span class="udiff-line-added">+             emitARM64(&quot;clz&quot;, [operands[1], operands[1]], :quad)</span>
<span class="udiff-line-added">+         when &quot;lzcnti&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;clz&quot;, operands, :word)</span>
<span class="udiff-line-added">+         when &quot;lzcntq&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;clz&quot;, operands, :quad)</span>
<span class="udiff-line-added">+         when &quot;absf&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;fabs&quot;, operands, :float)</span>
<span class="udiff-line-added">+         when &quot;absd&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;fabs&quot;, operands, :double)</span>
<span class="udiff-line-added">+         when &quot;negf&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;fneg&quot;, operands, :float)</span>
<span class="udiff-line-added">+         when &quot;negd&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;fneg&quot;, operands, :double)</span>
<span class="udiff-line-added">+         when &quot;ceilf&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;frintp&quot;, operands, :float)</span>
<span class="udiff-line-added">+         when &quot;ceild&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;frintp&quot;, operands, :double)</span>
<span class="udiff-line-added">+         when &quot;cfeq&quot;</span>
<span class="udiff-line-added">+             emitARM64CompareFP(operands, :float, &quot;eq&quot;)</span>
<span class="udiff-line-added">+         when &quot;cdeq&quot;</span>
<span class="udiff-line-added">+             emitARM64CompareFP(operands, :double, &quot;eq&quot;)</span>
<span class="udiff-line-added">+         when &quot;cfneq&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;move $0, #{operands[2].arm64Operand(:word)}&quot;</span>
<span class="udiff-line-added">+             emitARM64Unflipped(&quot;fcmp&quot;, operands[0..1], :float)</span>
<span class="udiff-line-added">+             isUnordered = LocalLabel.unique(&quot;cdneq&quot;)</span>
<span class="udiff-line-added">+             $asm.puts &quot;b.vs #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;cset #{operands[2].arm64Operand(:word)}, ne&quot;</span>
<span class="udiff-line-added">+             isUnordered.lower($activeBackend)</span>
<span class="udiff-line-added">+         when &quot;cdneq&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;move $0, #{operands[2].arm64Operand(:word)}&quot;</span>
<span class="udiff-line-added">+             emitARM64Unflipped(&quot;fcmp&quot;, operands[0..1], :double)</span>
<span class="udiff-line-added">+             isUnordered = LocalLabel.unique(&quot;cdneq&quot;)</span>
<span class="udiff-line-added">+             $asm.puts &quot;b.vs #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;cset #{operands[2].arm64Operand(:word)}, ne&quot;</span>
<span class="udiff-line-added">+             isUnordered.lower($activeBackend)</span>
<span class="udiff-line-added">+         when &quot;cfnequn&quot;</span>
<span class="udiff-line-added">+             emitARM64CompareFP(operands, :float, &quot;ne&quot;)</span>
<span class="udiff-line-added">+         when &quot;cdnequn&quot;</span>
<span class="udiff-line-added">+             emitARM64CompareFP(operands, :double, &quot;ne&quot;)</span>
<span class="udiff-line-added">+         when &quot;cflt&quot;</span>
<span class="udiff-line-added">+             emitARM64CompareFP(operands, :float, &quot;mi&quot;)</span>
<span class="udiff-line-added">+         when &quot;cdlt&quot;</span>
<span class="udiff-line-added">+             emitARM64CompareFP(operands, :double, &quot;mi&quot;)</span>
<span class="udiff-line-added">+         when &quot;cflteq&quot;</span>
<span class="udiff-line-added">+             emitARM64CompareFP(operands, :float, &quot;ls&quot;)</span>
<span class="udiff-line-added">+         when &quot;cdlteq&quot;</span>
<span class="udiff-line-added">+             emitARM64CompareFP(operands, :double, &quot;ls&quot;)</span>
<span class="udiff-line-added">+         when &quot;cfgt&quot;</span>
<span class="udiff-line-added">+             emitARM64CompareFP(operands, :float, &quot;gt&quot;)</span>
<span class="udiff-line-added">+         when &quot;cdgt&quot;</span>
<span class="udiff-line-added">+             emitARM64CompareFP(operands, :double, &quot;gt&quot;)</span>
<span class="udiff-line-added">+         when &quot;cfgteq&quot;</span>
<span class="udiff-line-added">+             emitARM64CompareFP(operands, :float, &quot;ge&quot;)</span>
<span class="udiff-line-added">+         when &quot;cdgteq&quot;</span>
<span class="udiff-line-added">+             emitARM64CompareFP(operands, :double, &quot;ge&quot;)</span>
<span class="udiff-line-added">+         when &quot;fi2f&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;fmov&quot;, operands, [:word, :float])</span>
<span class="udiff-line-added">+         when &quot;ff2i&quot;</span>
<span class="udiff-line-added">+             emitARM64(&quot;fmov&quot;, operands, [:float, :word])</span>
<span class="udiff-line-added">+         when &quot;tls_loadp&quot;</span>
<span class="udiff-line-added">+             tmp = ARM64_EXTRA_GPRS[0].arm64Operand(:ptr)</span>
<span class="udiff-line-added">+             if operands[0].immediate?</span>
<span class="udiff-line-added">+               offset = &quot;\##{operands[0].value * 8}&quot;</span>
<span class="udiff-line-added">+             else</span>
<span class="udiff-line-added">+               offset = operands[0].arm64Operand(:word)</span>
<span class="udiff-line-added">+             end</span>
<span class="udiff-line-added">+             $asm.puts &quot;mrs #{tmp}, tpidrro_el0&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;bic #{tmp}, #{tmp}, #7&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;ldr #{operands[1].arm64Operand(:ptr)}, [#{tmp}, #{offset}]&quot;</span>
<span class="udiff-line-added">+         when &quot;tls_storep&quot;</span>
<span class="udiff-line-added">+             tmp = ARM64_EXTRA_GPRS[0].arm64Operand(:ptr)</span>
<span class="udiff-line-added">+             if operands[1].immediate?</span>
<span class="udiff-line-added">+               offset = &quot;\##{operands[1].value * 8}&quot;</span>
<span class="udiff-line-added">+             else</span>
<span class="udiff-line-added">+               offset = operands[1].arm64Operand(:word)</span>
<span class="udiff-line-added">+             end</span>
<span class="udiff-line-added">+             $asm.puts &quot;mrs #{tmp}, tpidrro_el0&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;bic #{tmp}, #{tmp}, #7&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;str #{operands[0].arm64Operand(:ptr)}, [#{tmp}, #{offset}]&quot;</span>
          else
              lowerDefault
          end
      end
  end
</pre>
<center><a href="arm.rb.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="asm.rb.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
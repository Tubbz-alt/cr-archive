<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/CallFrame.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<a name="1" id="anc1"></a><span class="line-modified">  4  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.</span>
  5  *
  6  *  This library is free software; you can redistribute it and/or
  7  *  modify it under the terms of the GNU Library General Public
  8  *  License as published by the Free Software Foundation; either
  9  *  version 2 of the License, or (at your option) any later version.
 10  *
 11  *  This library is distributed in the hope that it will be useful,
 12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  *  Library General Public License for more details.
 15  *
 16  *  You should have received a copy of the GNU Library General Public License
 17  *  along with this library; see the file COPYING.LIB.  If not, write to
 18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  *  Boston, MA 02110-1301, USA.
 20  *
 21  */
 22 
 23 #pragma once
 24 
 25 #include &quot;AbstractPC.h&quot;
 26 #include &quot;CalleeBits.h&quot;
 27 #include &quot;MacroAssemblerCodeRef.h&quot;
 28 #include &quot;Register.h&quot;
 29 #include &quot;StackVisitor.h&quot;
 30 #include &quot;VM.h&quot;
 31 #include &quot;VMEntryRecord.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 32 #include &lt;wtf/EnumClassOperatorOverloads.h&gt;</span>
 33 
 34 namespace JSC  {
 35 
 36     class Arguments;
<a name="3" id="anc3"></a><span class="line-modified"> 37     class CallFrame;</span>
 38     class Interpreter;
 39     class JSCallee;
 40     class JSScope;
 41     class SourceOrigin;
 42 
 43     struct Instruction;
 44 
<a name="4" id="anc4"></a>

 45     class CallSiteIndex {
 46     public:
 47         CallSiteIndex() = default;
 48 
<a name="5" id="anc5"></a><span class="line-added"> 49         explicit CallSiteIndex(BytecodeIndex bytecodeIndex)</span>
<span class="line-added"> 50             : m_bits(bytecodeIndex.offset())</span>
<span class="line-added"> 51         {</span>
<span class="line-added"> 52             ASSERT(!bytecodeIndex.checkpoint());</span>
<span class="line-added"> 53         }</span>
 54         explicit CallSiteIndex(uint32_t bits)
 55             : m_bits(bits)
 56         { }
<a name="6" id="anc6"></a>




 57 
<a name="7" id="anc7"></a><span class="line-modified"> 58         explicit operator bool() const { return !!m_bits; }</span>
 59         bool operator==(const CallSiteIndex&amp; other) const { return m_bits == other.m_bits; }
 60 
<a name="8" id="anc8"></a><span class="line-modified"> 61         uint32_t bits() const { return m_bits; }</span>
<span class="line-added"> 62         static CallSiteIndex fromBits(uint32_t bits) { return CallSiteIndex(bits); }</span>
<span class="line-added"> 63 </span>
<span class="line-added"> 64         BytecodeIndex bytecodeIndex() const { return BytecodeIndex(bits()); }</span>
 65 
 66     private:
<a name="9" id="anc9"></a><span class="line-modified"> 67         uint32_t m_bits { BytecodeIndex().offset() };</span>
 68     };
 69 
 70     class DisposableCallSiteIndex : public CallSiteIndex {
 71     public:
 72         DisposableCallSiteIndex() = default;
 73 
 74         explicit DisposableCallSiteIndex(uint32_t bits)
 75             : CallSiteIndex(bits)
 76         {
 77         }
 78 
 79         static DisposableCallSiteIndex fromCallSiteIndex(CallSiteIndex callSiteIndex)
 80         {
 81             return DisposableCallSiteIndex(callSiteIndex.bits());
 82         }
 83     };
 84 
 85     // arm64_32 expects caller frame and return pc to use 8 bytes
 86     struct CallerFrameAndPC {
 87         alignas(CPURegister) CallFrame* callerFrame;
<a name="10" id="anc10"></a><span class="line-modified"> 88         alignas(CPURegister) void* returnPC;</span>
<span class="line-modified"> 89         static constexpr int sizeInRegisters = 2 * sizeof(CPURegister) / sizeof(Register);</span>
 90     };
 91     static_assert(CallerFrameAndPC::sizeInRegisters == sizeof(CallerFrameAndPC) / sizeof(Register), &quot;CallerFrameAndPC::sizeInRegisters is incorrect.&quot;);
 92 
<a name="11" id="anc11"></a><span class="line-modified"> 93     enum class CallFrameSlot : int {</span>
<span class="line-modified"> 94         codeBlock = CallerFrameAndPC::sizeInRegisters,</span>
<span class="line-modified"> 95         callee = codeBlock + 1,</span>
<span class="line-modified"> 96         argumentCountIncludingThis = callee + 1,</span>
<span class="line-modified"> 97         thisArgument = argumentCountIncludingThis + 1,</span>
<span class="line-modified"> 98         firstArgument = thisArgument + 1,</span>
 99     };
100 
<a name="12" id="anc12"></a><span class="line-added">101     OVERLOAD_MATH_OPERATORS_FOR_ENUM_CLASS_WITH_INTEGRALS(CallFrameSlot)</span>
<span class="line-added">102     OVERLOAD_RELATIONAL_OPERATORS_FOR_ENUM_CLASS_WITH_INTEGRALS(CallFrameSlot)</span>
<span class="line-added">103 </span>
104     // Represents the current state of script execution.
105     // Passed as the first argument to most functions.
<a name="13" id="anc13"></a><span class="line-modified">106     class CallFrame : private Register {</span>
107     public:
<a name="14" id="anc14"></a><span class="line-modified">108         static constexpr int headerSizeInRegisters = static_cast&lt;int&gt;(CallFrameSlot::argumentCountIncludingThis) + 1;</span>
109 
110         // This function should only be called in very specific circumstances
111         // when you&#39;ve guaranteed the callee can&#39;t be a Wasm callee, and can
112         // be an arbitrary JSValue. This function should basically never be used.
113         // Its only use right now is when we are making a call, and we&#39;re not
114         // yet sure if the callee is a cell. In general, a JS callee is guaranteed
115         // to be a cell, however, there is a brief window where we need to check
116         // to see if it&#39;s a cell, and if it&#39;s not, we throw an exception.
<a name="15" id="anc15"></a><span class="line-modified">117         inline JSValue guaranteedJSValueCallee() const;</span>
<span class="line-modified">118         inline JSObject* jsCallee() const;</span>
<span class="line-modified">119         CalleeBits callee() const { return CalleeBits(this[static_cast&lt;int&gt;(CallFrameSlot::callee)].pointer()); }</span>
<span class="line-modified">120         SUPPRESS_ASAN CalleeBits unsafeCallee() const { return CalleeBits(this[static_cast&lt;int&gt;(CallFrameSlot::callee)].asanUnsafePointer()); }</span>
<span class="line-modified">121         CodeBlock* codeBlock() const;</span>
<span class="line-modified">122         CodeBlock** addressOfCodeBlock() const { return bitwise_cast&lt;CodeBlock**&gt;(this + static_cast&lt;int&gt;(CallFrameSlot::codeBlock)); }</span>
<span class="line-modified">123         inline SUPPRESS_ASAN CodeBlock* unsafeCodeBlock() const;</span>
<span class="line-modified">124         inline JSScope* scope(int scopeRegisterOffset) const;</span>














125 
<a name="16" id="anc16"></a><span class="line-modified">126         JS_EXPORT_PRIVATE bool isAnyWasmCallee();</span>
127 
128         // Global object in which the currently executing code was defined.
<a name="17" id="anc17"></a><span class="line-modified">129         // Differs from VM::deprecatedVMEntryGlobalObject() during function calls across web browser frames.</span>
<span class="line-modified">130         JSGlobalObject* lexicalGlobalObject(VM&amp;) const;</span>
131 
<a name="18" id="anc18"></a><span class="line-modified">132         // FIXME: Remove this function</span>
<span class="line-modified">133         // https://bugs.webkit.org/show_bug.cgi?id=203272</span>
<span class="line-modified">134         VM&amp; deprecatedVM() const;</span>


135 
136         static CallFrame* create(Register* callFrameBase) { return static_cast&lt;CallFrame*&gt;(callFrameBase); }
137         Register* registers() { return this; }
138         const Register* registers() const { return this; }
139 
140         CallFrame&amp; operator=(const Register&amp; r) { *static_cast&lt;Register*&gt;(this) = r; return *this; }
141 
142         CallFrame* callerFrame() const { return static_cast&lt;CallFrame*&gt;(callerFrameOrEntryFrame()); }
143         void* callerFrameOrEntryFrame() const { return callerFrameAndPC().callerFrame; }
144         SUPPRESS_ASAN void* unsafeCallerFrameOrEntryFrame() const { return unsafeCallerFrameAndPC().callerFrame; }
145 
146         CallFrame* unsafeCallerFrame(EntryFrame*&amp;) const;
147         JS_EXPORT_PRIVATE CallFrame* callerFrame(EntryFrame*&amp;) const;
148 
<a name="19" id="anc19"></a><span class="line-modified">149         JS_EXPORT_PRIVATE SourceOrigin callerSourceOrigin(VM&amp;);</span>
150 
151         static ptrdiff_t callerFrameOffset() { return OBJECT_OFFSETOF(CallerFrameAndPC, callerFrame); }
152 
153         ReturnAddressPtr returnPC() const { return ReturnAddressPtr(callerFrameAndPC().returnPC); }
154         bool hasReturnPC() const { return !!callerFrameAndPC().returnPC; }
155         void clearReturnPC() { callerFrameAndPC().returnPC = 0; }
156         static ptrdiff_t returnPCOffset() { return OBJECT_OFFSETOF(CallerFrameAndPC, returnPC); }
157         AbstractPC abstractReturnPC(VM&amp; vm) { return AbstractPC(vm, this); }
158 
159         bool callSiteBitsAreBytecodeOffset() const;
160         bool callSiteBitsAreCodeOriginIndex() const;
161 
162         unsigned callSiteAsRawBits() const;
163         unsigned unsafeCallSiteAsRawBits() const;
164         CallSiteIndex callSiteIndex() const;
165         CallSiteIndex unsafeCallSiteIndex() const;
166     private:
167         unsigned callSiteBitsAsBytecodeOffset() const;
<a name="20" id="anc20"></a><span class="line-added">168 #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added">169         JS_EXPORT_PRIVATE JSGlobalObject* lexicalGlobalObjectFromWasmCallee(VM&amp;) const;</span>
<span class="line-added">170 #endif</span>
171     public:
172 
173         // This will try to get you the bytecode offset, but you should be aware that
174         // this bytecode offset may be bogus in the presence of inlining. This will
175         // also return 0 if the call frame has no notion of bytecode offsets (for
176         // example if it&#39;s native code).
177         // https://bugs.webkit.org/show_bug.cgi?id=121754
<a name="21" id="anc21"></a><span class="line-modified">178         BytecodeIndex bytecodeIndex();</span>
179 
180         // This will get you a CodeOrigin. It will always succeed. May return
<a name="22" id="anc22"></a><span class="line-modified">181         // CodeOrigin(BytecodeIndex(0)) if we&#39;re in native code.</span>
182         JS_EXPORT_PRIVATE CodeOrigin codeOrigin();
183 
<a name="23" id="anc23"></a><span class="line-modified">184         inline Register* topOfFrame();</span>





185 
186         const Instruction* currentVPC() const; // This only makes sense in the LLInt and baseline.
187         void setCurrentVPC(const Instruction*);
188 
189         void setCallerFrame(CallFrame* frame) { callerFrameAndPC().callerFrame = frame; }
<a name="24" id="anc24"></a><span class="line-modified">190         inline void setScope(int scopeRegisterOffset, JSScope*);</span>
191 
<a name="25" id="anc25"></a><span class="line-modified">192         static void initDeprecatedCallFrameForDebugger(CallFrame* globalExec, JSCallee* globalCallee);</span>
193 
194         // Read a register from the codeframe (or constant from the CodeBlock).
<a name="26" id="anc26"></a>
195         Register&amp; r(VirtualRegister);
<a name="27" id="anc27"></a><span class="line-modified">196         // Read a register for a known non-constant</span>

197         Register&amp; uncheckedR(VirtualRegister);
198 
199         // Access to arguments as passed. (After capture, arguments may move to a different location.)
200         size_t argumentCount() const { return argumentCountIncludingThis() - 1; }
<a name="28" id="anc28"></a><span class="line-modified">201         size_t argumentCountIncludingThis() const { return this[static_cast&lt;int&gt;(CallFrameSlot::argumentCountIncludingThis)].payload(); }</span>
202         static int argumentOffset(int argument) { return (CallFrameSlot::firstArgument + argument); }
203         static int argumentOffsetIncludingThis(int argument) { return (CallFrameSlot::thisArgument + argument); }
204 
205         // In the following (argument() and setArgument()), the &#39;argument&#39;
206         // parameter is the index of the arguments of the target function of
207         // this frame. The index starts at 0 for the first arg, 1 for the
208         // second, etc.
209         //
210         // The arguments (in this case) do not include the &#39;this&#39; value.
211         // arguments(0) will not fetch the &#39;this&#39; value. To get/set &#39;this&#39;,
212         // use thisValue() and setThisValue() below.
213 
214         JSValue* addressOfArgumentsStart() const { return bitwise_cast&lt;JSValue*&gt;(this + argumentOffset(0)); }
215         JSValue argument(size_t argument)
216         {
217             if (argument &gt;= argumentCount())
218                  return jsUndefined();
219             return getArgumentUnsafe(argument);
220         }
221         JSValue uncheckedArgument(size_t argument)
222         {
223             ASSERT(argument &lt; argumentCount());
224             return getArgumentUnsafe(argument);
225         }
226         void setArgument(size_t argument, JSValue value)
227         {
228             this[argumentOffset(argument)] = value;
229         }
230 
231         JSValue getArgumentUnsafe(size_t argIndex)
232         {
233             // User beware! This method does not verify that there is a valid
234             // argument at the specified argIndex. This is used for debugging
235             // and verification code only. The caller is expected to know what
236             // he/she is doing when calling this method.
237             return this[argumentOffset(argIndex)].jsValue();
238         }
239 
240         static int thisArgumentOffset() { return argumentOffsetIncludingThis(0); }
241         JSValue thisValue() { return this[thisArgumentOffset()].jsValue(); }
242         void setThisValue(JSValue value) { this[thisArgumentOffset()] = value; }
243 
244         // Under the constructor implemented in C++, thisValue holds the newTarget instead of the automatically constructed value.
245         // The result of this function is only effective under the &quot;construct&quot; context.
246         JSValue newTarget() { return thisValue(); }
247 
248         JSValue argumentAfterCapture(size_t argument);
249 
<a name="29" id="anc29"></a><span class="line-modified">250         static int offsetFor(size_t argumentCountIncludingThis) { return CallFrameSlot::thisArgument + argumentCountIncludingThis - 1; }</span>
251 
252         static CallFrame* noCaller() { return nullptr; }
<a name="30" id="anc30"></a><span class="line-modified">253         bool isDeprecatedCallFrameForDebugger() const</span>
254         {
255             return callerFrameAndPC().callerFrame == noCaller() &amp;&amp; callerFrameAndPC().returnPC == nullptr;
256         }
257 
258         void convertToStackOverflowFrame(VM&amp;, CodeBlock* codeBlockToKeepAliveUntilFrameIsUnwound);
259         bool isStackOverflowFrame() const;
260         bool isWasmFrame() const;
261 
<a name="31" id="anc31"></a><span class="line-modified">262         void setArgumentCountIncludingThis(int count) { static_cast&lt;Register*&gt;(this)[static_cast&lt;int&gt;(CallFrameSlot::argumentCountIncludingThis)].payload() = count; }</span>
<span class="line-modified">263         inline void setCallee(JSObject*);</span>
<span class="line-modified">264         inline void setCodeBlock(CodeBlock*);</span>
<span class="line-modified">265         void setReturnPC(void* value) { callerFrameAndPC().returnPC = value; }</span>
266 
267         String friendlyFunctionName();
268 
269         // CallFrame::iterate() expects a Functor that implements the following method:
270         //     StackVisitor::Status operator()(StackVisitor&amp;) const;
271         // FIXME: This method is improper. We rely on the fact that we can call it with a null
272         // receiver. We should always be using StackVisitor directly.
273         // It&#39;s only valid to call this from a non-wasm top frame.
<a name="32" id="anc32"></a><span class="line-modified">274         template &lt;StackVisitor::EmptyEntryFrameAction action = StackVisitor::ContinueIfTopEntryFrameIsEmpty, typename Functor&gt; void iterate(VM&amp; vm, const Functor&amp; functor)</span>
275         {
<a name="33" id="anc33"></a>
276             void* rawThis = this;
<a name="34" id="anc34"></a><span class="line-modified">277             if (!!rawThis)</span>
278                 RELEASE_ASSERT(callee().isCell());
<a name="35" id="anc35"></a>


279             StackVisitor::visit&lt;action, Functor&gt;(this, vm, functor);
280         }
281 
282         void dump(PrintStream&amp;);
283         JS_EXPORT_PRIVATE const char* describeFrame();
284 
285     private:
286 
<a name="36" id="anc36"></a><span class="line-modified">287         CallFrame();</span>
<span class="line-modified">288         ~CallFrame();</span>
289 
290         Register* topOfFrameInternal();
291 
292         // The following are for internal use in debugging and verification
293         // code only and not meant as an API for general usage:
294 
295         size_t argIndexForRegister(Register* reg)
296         {
297             // The register at &#39;offset&#39; number of slots from the frame pointer
298             // i.e.
299             //       reg = frame[offset];
300             //   ==&gt; reg = frame + offset;
301             //   ==&gt; offset = reg - frame;
302             int offset = reg - this-&gt;registers();
303 
304             // The offset is defined (based on argumentOffset()) to be:
305             //       offset = CallFrameSlot::firstArgument - argIndex;
306             // Hence:
307             //       argIndex = CallFrameSlot::firstArgument - offset;
308             size_t argIndex = offset - CallFrameSlot::firstArgument;
309             return argIndex;
310         }
311 
312         CallerFrameAndPC&amp; callerFrameAndPC() { return *reinterpret_cast&lt;CallerFrameAndPC*&gt;(this); }
313         const CallerFrameAndPC&amp; callerFrameAndPC() const { return *reinterpret_cast&lt;const CallerFrameAndPC*&gt;(this); }
314         SUPPRESS_ASAN const CallerFrameAndPC&amp; unsafeCallerFrameAndPC() const { return *reinterpret_cast&lt;const CallerFrameAndPC*&gt;(this); }
315     };
316 
<a name="37" id="anc37"></a><span class="line-added">317 JS_EXPORT_PRIVATE bool isFromJSCode(void* returnAddress);</span>
<span class="line-added">318 </span>
<span class="line-added">319 #if USE(BUILTIN_FRAME_ADDRESS)</span>
<span class="line-added">320 #define DECLARE_CALL_FRAME(vm) \</span>
<span class="line-added">321     ({ \</span>
<span class="line-added">322         ASSERT(JSC::isFromJSCode(removeCodePtrTag&lt;void*&gt;(__builtin_return_address(0)))); \</span>
<span class="line-added">323         bitwise_cast&lt;JSC::CallFrame*&gt;(__builtin_frame_address(1)); \</span>
<span class="line-added">324     })</span>
<span class="line-added">325 #else</span>
<span class="line-added">326 #define DECLARE_CALL_FRAME(vm) ((vm).topCallFrame)</span>
<span class="line-added">327 #endif</span>
<span class="line-added">328 </span>
<span class="line-added">329 </span>
330 } // namespace JSC
<a name="38" id="anc38"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="38" type="hidden" />
</body>
</html>
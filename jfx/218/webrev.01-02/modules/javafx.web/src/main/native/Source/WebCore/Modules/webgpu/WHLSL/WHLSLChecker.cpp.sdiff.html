<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLChecker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WHLSLCheckTextureReferences.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLHighZombieFinder.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLChecker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 182         static bool equal(const FunctionKey&amp; a, const FunctionKey&amp; b)
 183         {
 184             return a == b;
 185         }
 186 
 187         static const bool safeToCompareToEmptyOrDeleted = false;
 188         static const bool emptyValueIsZero = false;
 189     };
 190 
 191     struct Traits : public WTF::SimpleClassHashTraits&lt;FunctionKey&gt; {
 192         static const bool hasIsEmptyValueFunction = true;
 193         static bool isEmptyValue(const FunctionKey&amp; key) { return key.isEmptyValue(); }
 194     };
 195 
 196 private:
 197     String m_name;
 198     Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; m_types;
 199     AST::NamedType* m_castReturnType;
 200 };
 201 
<span class="line-removed"> 202 class AndOverloadTypeKey {</span>
<span class="line-removed"> 203 public:</span>
<span class="line-removed"> 204     AndOverloadTypeKey() = default;</span>
<span class="line-removed"> 205     AndOverloadTypeKey(WTF::HashTableDeletedValueType)</span>
<span class="line-removed"> 206     {</span>
<span class="line-removed"> 207         m_type = bitwise_cast&lt;AST::UnnamedType*&gt;(static_cast&lt;uintptr_t&gt;(1));</span>
<span class="line-removed"> 208     }</span>
<span class="line-removed"> 209 </span>
<span class="line-removed"> 210     AndOverloadTypeKey(AST::UnnamedType&amp; type, AST::AddressSpace addressSpace)</span>
<span class="line-removed"> 211         : m_type(&amp;type)</span>
<span class="line-removed"> 212         , m_addressSpace(addressSpace)</span>
<span class="line-removed"> 213     { }</span>
<span class="line-removed"> 214 </span>
<span class="line-removed"> 215     bool isEmptyValue() const { return !m_type; }</span>
<span class="line-removed"> 216     bool isHashTableDeletedValue() const { return m_type == bitwise_cast&lt;AST::UnnamedType*&gt;(static_cast&lt;uintptr_t&gt;(1)); }</span>
<span class="line-removed"> 217 </span>
<span class="line-removed"> 218     unsigned hash() const</span>
<span class="line-removed"> 219     {</span>
<span class="line-removed"> 220         return IntHash&lt;uint8_t&gt;::hash(static_cast&lt;uint8_t&gt;(m_addressSpace)) ^ m_type-&gt;hash();</span>
<span class="line-removed"> 221     }</span>
<span class="line-removed"> 222 </span>
<span class="line-removed"> 223     bool operator==(const AndOverloadTypeKey&amp; other) const</span>
<span class="line-removed"> 224     {</span>
<span class="line-removed"> 225         return m_addressSpace == other.m_addressSpace</span>
<span class="line-removed"> 226             &amp;&amp; *m_type == *other.m_type;</span>
<span class="line-removed"> 227     }</span>
<span class="line-removed"> 228 </span>
<span class="line-removed"> 229     struct Hash {</span>
<span class="line-removed"> 230         static unsigned hash(const AndOverloadTypeKey&amp; key)</span>
<span class="line-removed"> 231         {</span>
<span class="line-removed"> 232             return key.hash();</span>
<span class="line-removed"> 233         }</span>
<span class="line-removed"> 234 </span>
<span class="line-removed"> 235         static bool equal(const AndOverloadTypeKey&amp; a, const AndOverloadTypeKey&amp; b)</span>
<span class="line-removed"> 236         {</span>
<span class="line-removed"> 237             return a == b;</span>
<span class="line-removed"> 238         }</span>
<span class="line-removed"> 239 </span>
<span class="line-removed"> 240         static const bool safeToCompareToEmptyOrDeleted = false;</span>
<span class="line-removed"> 241     };</span>
<span class="line-removed"> 242 </span>
<span class="line-removed"> 243     struct Traits : public WTF::SimpleClassHashTraits&lt;AndOverloadTypeKey&gt; {</span>
<span class="line-removed"> 244         static const bool hasIsEmptyValueFunction = true;</span>
<span class="line-removed"> 245         static bool isEmptyValue(const AndOverloadTypeKey&amp; key) { return key.isEmptyValue(); }</span>
<span class="line-removed"> 246     };</span>
<span class="line-removed"> 247 </span>
<span class="line-removed"> 248 private:</span>
<span class="line-removed"> 249     AST::UnnamedType* m_type { nullptr };</span>
<span class="line-removed"> 250     AST::AddressSpace m_addressSpace;</span>
<span class="line-removed"> 251 };</span>
<span class="line-removed"> 252 </span>
<span class="line-removed"> 253 static AST::NativeFunctionDeclaration resolveWithOperatorAnderIndexer(CodeLocation location, AST::ArrayReferenceType&amp; firstArgument, const Intrinsics&amp; intrinsics)</span>
<span class="line-removed"> 254 {</span>
<span class="line-removed"> 255     const bool isOperator = true;</span>
<span class="line-removed"> 256     auto returnType = AST::PointerType::create(location, firstArgument.addressSpace(), firstArgument.elementType());</span>
<span class="line-removed"> 257     AST::VariableDeclarations parameters;</span>
<span class="line-removed"> 258     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), &amp;firstArgument, String(), nullptr, nullptr));</span>
<span class="line-removed"> 259     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), AST::TypeReference::wrap(location, intrinsics.uintType()), String(), nullptr, nullptr));</span>
<span class="line-removed"> 260     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(location, AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator&amp;[]&quot;, String::ConstructFromLiteral), WTFMove(parameters), nullptr, isOperator, ParsingMode::StandardLibrary));</span>
<span class="line-removed"> 261 }</span>
<span class="line-removed"> 262 </span>
<span class="line-removed"> 263 static AST::NativeFunctionDeclaration resolveWithOperatorLength(CodeLocation location, AST::UnnamedType&amp; firstArgument, const Intrinsics&amp; intrinsics)</span>
<span class="line-removed"> 264 {</span>
<span class="line-removed"> 265     const bool isOperator = true;</span>
<span class="line-removed"> 266     auto returnType = AST::TypeReference::wrap(location, intrinsics.uintType());</span>
<span class="line-removed"> 267     AST::VariableDeclarations parameters;</span>
<span class="line-removed"> 268     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), &amp;firstArgument, String(), nullptr, nullptr));</span>
<span class="line-removed"> 269     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(location, AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator.length&quot;, String::ConstructFromLiteral), WTFMove(parameters), nullptr, isOperator, ParsingMode::StandardLibrary));</span>
<span class="line-removed"> 270 }</span>
<span class="line-removed"> 271 </span>
 272 static AST::NativeFunctionDeclaration resolveWithReferenceComparator(CodeLocation location, ResolvingType&amp; firstArgument, ResolvingType&amp; secondArgument, const Intrinsics&amp; intrinsics)
 273 {
 274     const bool isOperator = true;
 275     auto returnType = AST::TypeReference::wrap(location, intrinsics.boolType());
 276     auto argumentType = firstArgument.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; Ref&lt;AST::UnnamedType&gt; {
 277         return unnamedType.copyRef();
 278     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; Ref&lt;AST::UnnamedType&gt; {
 279         return secondArgument.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; Ref&lt;AST::UnnamedType&gt; {
 280             return unnamedType.copyRef();
 281         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; Ref&lt;AST::UnnamedType&gt; {
 282             // We encountered &quot;null == null&quot;.
 283             // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198162 This can probably be generalized, using the &quot;preferred type&quot; infrastructure used by generic literals
 284             ASSERT_NOT_REACHED();
 285             return AST::TypeReference::wrap(location, intrinsics.intType());
 286         }));
 287     }));
 288     AST::VariableDeclarations parameters;
 289     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), argumentType.copyRef(), String(), nullptr, nullptr));
 290     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), WTFMove(argumentType), String(), nullptr, nullptr));
 291     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(location, AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator==&quot;, String::ConstructFromLiteral), WTFMove(parameters), nullptr, isOperator, ParsingMode::StandardLibrary));
 292 }
 293 
 294 enum class Acceptability {
 295     Yes,
<span class="line-removed"> 296     Maybe,</span>
 297     No
 298 };
 299 
 300 static Optional&lt;AST::NativeFunctionDeclaration&gt; resolveByInstantiation(const String&amp; name, CodeLocation location, const Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const Intrinsics&amp; intrinsics)
 301 {
<span class="line-modified"> 302     if (name == &quot;operator&amp;[]&quot; &amp;&amp; types.size() == 2) {</span>
<span class="line-removed"> 303         auto* firstArgumentArrayRef = types[0].get().visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::ArrayReferenceType* {</span>
<span class="line-removed"> 304             if (is&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)))</span>
<span class="line-removed"> 305                 return &amp;downcast&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType));</span>
<span class="line-removed"> 306             return nullptr;</span>
<span class="line-removed"> 307         }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; AST::ArrayReferenceType* {</span>
<span class="line-removed"> 308             return nullptr;</span>
<span class="line-removed"> 309         }));</span>
<span class="line-removed"> 310         bool secondArgumentIsUint = types[1].get().visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; bool {</span>
<span class="line-removed"> 311             return matches(unnamedType, intrinsics.uintType());</span>
<span class="line-removed"> 312         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; bool {</span>
<span class="line-removed"> 313             return resolvableTypeReference-&gt;resolvableType().canResolve(intrinsics.uintType());</span>
<span class="line-removed"> 314         }));</span>
<span class="line-removed"> 315         if (firstArgumentArrayRef &amp;&amp; secondArgumentIsUint)</span>
<span class="line-removed"> 316             return resolveWithOperatorAnderIndexer(location, *firstArgumentArrayRef, intrinsics);</span>
<span class="line-removed"> 317     } else if (name == &quot;operator.length&quot; &amp;&amp; types.size() == 1) {</span>
<span class="line-removed"> 318         auto* firstArgumentReference = types[0].get().visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::UnnamedType* {</span>
<span class="line-removed"> 319             if (is&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)) || is&lt;AST::ArrayType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)))</span>
<span class="line-removed"> 320                 return unnamedType.ptr();</span>
<span class="line-removed"> 321             return nullptr;</span>
<span class="line-removed"> 322         }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; AST::UnnamedType* {</span>
<span class="line-removed"> 323             return nullptr;</span>
<span class="line-removed"> 324         }));</span>
<span class="line-removed"> 325         if (firstArgumentReference)</span>
<span class="line-removed"> 326             return resolveWithOperatorLength(location, *firstArgumentReference, intrinsics);</span>
<span class="line-removed"> 327     } else if (name == &quot;operator==&quot; &amp;&amp; types.size() == 2) {</span>
 328         auto acceptability = [](ResolvingType&amp; resolvingType) -&gt; Acceptability {
 329             return resolvingType.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; Acceptability {
 330                 auto&amp; unifyNode = unnamedType-&gt;unifyNode();
 331                 return is&lt;AST::UnnamedType&gt;(unifyNode) &amp;&amp; is&lt;AST::ReferenceType&gt;(downcast&lt;AST::UnnamedType&gt;(unifyNode)) ? Acceptability::Yes : Acceptability::No;
<span class="line-modified"> 332             }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; Acceptability {</span>
<span class="line-modified"> 333                 return is&lt;AST::NullLiteralType&gt;(resolvableTypeReference-&gt;resolvableType()) ? Acceptability::Maybe : Acceptability::No;</span>
 334             }));
 335         };
 336         auto leftAcceptability = acceptability(types[0].get());
 337         auto rightAcceptability = acceptability(types[1].get());
 338         bool success = false;
 339         if (leftAcceptability == Acceptability::Yes &amp;&amp; rightAcceptability == Acceptability::Yes) {
 340             auto&amp; unnamedType1 = *types[0].get().getUnnamedType();
 341             auto&amp; unnamedType2 = *types[1].get().getUnnamedType();
 342             success = matches(unnamedType1, unnamedType2);
<span class="line-modified"> 343         } else if ((leftAcceptability == Acceptability::Maybe &amp;&amp; rightAcceptability == Acceptability::Yes)</span>
<span class="line-removed"> 344             || (leftAcceptability == Acceptability::Yes &amp;&amp; rightAcceptability == Acceptability::Maybe))</span>
<span class="line-removed"> 345             success = true;</span>
 346         if (success)
 347             return resolveWithReferenceComparator(location, types[0].get(), types[1].get(), intrinsics);
 348     }
 349     return WTF::nullopt;
 350 }
 351 
 352 static bool checkSemantics(Vector&lt;EntryPointItem&gt;&amp; inputItems, Vector&lt;EntryPointItem&gt;&amp; outputItems, const Optional&lt;AST::EntryPointType&gt;&amp; entryPointType, const Intrinsics&amp; intrinsics)
 353 {
 354     {
 355         auto checkDuplicateSemantics = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items) -&gt; bool {
 356             for (size_t i = 0; i &lt; items.size(); ++i) {
 357                 for (size_t j = i + 1; j &lt; items.size(); ++j) {
 358                     if (items[i].semantic == items[j].semantic)
 359                         return false;
 360                 }
 361             }
 362             return true;
 363         };
 364         if (!checkDuplicateSemantics(inputItems))
 365             return false;
</pre>
<hr />
<pre>
 410                 else if (is&lt;AST::ArrayReferenceType&gt;(item.unnamedType))
 411                     podChecker.checkErrorAndVisit(downcast&lt;AST::ArrayReferenceType&gt;(*item.unnamedType).elementType());
 412                 else if (is&lt;AST::ArrayType&gt;(item.unnamedType))
 413                     podChecker.checkErrorAndVisit(downcast&lt;AST::ArrayType&gt;(*item.unnamedType).type());
 414                 else
 415                     continue;
 416                 if (podChecker.hasError())
 417                     return false;
 418             }
 419             return true;
 420         };
 421         if (!checkPODData(inputItems))
 422             return false;
 423         if (!checkPODData(outputItems))
 424             return false;
 425     }
 426 
 427     return true;
 428 }
 429 
<span class="line-modified"> 430 static bool checkOperatorOverload(const AST::FunctionDefinition&amp; functionDefinition, NameContext&amp; nameContext, AST::NameSpace currentNameSpace)</span>
 431 {
 432     enum class CheckKind {
 433         Index,
 434         Dot
 435     };
 436 
<span class="line-removed"> 437     auto checkGetter = [&amp;](CheckKind kind) -&gt; bool {</span>
<span class="line-removed"> 438         size_t numExpectedParameters = kind == CheckKind::Index ? 2 : 1;</span>
<span class="line-removed"> 439         if (functionDefinition.parameters().size() != numExpectedParameters)</span>
<span class="line-removed"> 440             return false;</span>
<span class="line-removed"> 441         auto&amp; firstParameterUnifyNode = functionDefinition.parameters()[0]-&gt;type()-&gt;unifyNode();</span>
<span class="line-removed"> 442         if (is&lt;AST::UnnamedType&gt;(firstParameterUnifyNode)) {</span>
<span class="line-removed"> 443             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(firstParameterUnifyNode);</span>
<span class="line-removed"> 444             if (is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType) || is&lt;AST::ArrayType&gt;(unnamedType))</span>
<span class="line-removed"> 445                 return false;</span>
<span class="line-removed"> 446         }</span>
<span class="line-removed"> 447         if (kind == CheckKind::Index) {</span>
<span class="line-removed"> 448             auto&amp; secondParameterUnifyNode = functionDefinition.parameters()[1]-&gt;type()-&gt;unifyNode();</span>
<span class="line-removed"> 449             if (!is&lt;AST::NamedType&gt;(secondParameterUnifyNode))</span>
<span class="line-removed"> 450                 return false;</span>
<span class="line-removed"> 451             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(secondParameterUnifyNode);</span>
<span class="line-removed"> 452             if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))</span>
<span class="line-removed"> 453                 return false;</span>
<span class="line-removed"> 454             auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);</span>
<span class="line-removed"> 455             if (!nativeTypeDeclaration.isInt())</span>
<span class="line-removed"> 456                 return false;</span>
<span class="line-removed"> 457         }</span>
<span class="line-removed"> 458         return true;</span>
<span class="line-removed"> 459     };</span>
<span class="line-removed"> 460 </span>
<span class="line-removed"> 461     auto checkSetter = [&amp;](CheckKind kind) -&gt; bool {</span>
<span class="line-removed"> 462         size_t numExpectedParameters = kind == CheckKind::Index ? 3 : 2;</span>
<span class="line-removed"> 463         if (functionDefinition.parameters().size() != numExpectedParameters)</span>
<span class="line-removed"> 464             return false;</span>
<span class="line-removed"> 465         auto&amp; firstArgumentUnifyNode = functionDefinition.parameters()[0]-&gt;type()-&gt;unifyNode();</span>
<span class="line-removed"> 466         if (is&lt;AST::UnnamedType&gt;(firstArgumentUnifyNode)) {</span>
<span class="line-removed"> 467             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(firstArgumentUnifyNode);</span>
<span class="line-removed"> 468             if (is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType) || is&lt;AST::ArrayType&gt;(unnamedType))</span>
<span class="line-removed"> 469                 return false;</span>
<span class="line-removed"> 470         }</span>
<span class="line-removed"> 471         if (kind == CheckKind::Index) {</span>
<span class="line-removed"> 472             auto&amp; secondParameterUnifyNode = functionDefinition.parameters()[1]-&gt;type()-&gt;unifyNode();</span>
<span class="line-removed"> 473             if (!is&lt;AST::NamedType&gt;(secondParameterUnifyNode))</span>
<span class="line-removed"> 474                 return false;</span>
<span class="line-removed"> 475             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(secondParameterUnifyNode);</span>
<span class="line-removed"> 476             if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))</span>
<span class="line-removed"> 477                 return false;</span>
<span class="line-removed"> 478             auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);</span>
<span class="line-removed"> 479             if (!nativeTypeDeclaration.isInt())</span>
<span class="line-removed"> 480                 return false;</span>
<span class="line-removed"> 481         }</span>
<span class="line-removed"> 482         if (!matches(functionDefinition.type(), *functionDefinition.parameters()[0]-&gt;type()))</span>
<span class="line-removed"> 483             return false;</span>
<span class="line-removed"> 484         auto&amp; valueType = *functionDefinition.parameters()[numExpectedParameters - 1]-&gt;type();</span>
<span class="line-removed"> 485         auto getterName = functionDefinition.name().substring(0, functionDefinition.name().length() - 1);</span>
<span class="line-removed"> 486         auto getterFuncs = nameContext.getFunctions(getterName, currentNameSpace);</span>
<span class="line-removed"> 487         Vector&lt;ResolvingType&gt; argumentTypes;</span>
<span class="line-removed"> 488         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; argumentTypeReferences;</span>
<span class="line-removed"> 489         for (size_t i = 0; i &lt; numExpectedParameters - 1; ++i)</span>
<span class="line-removed"> 490             argumentTypes.append(*functionDefinition.parameters()[i]-&gt;type());</span>
<span class="line-removed"> 491         for (auto&amp; argumentType : argumentTypes)</span>
<span class="line-removed"> 492             argumentTypeReferences.append(argumentType);</span>
<span class="line-removed"> 493         auto* overload = resolveFunctionOverload(getterFuncs, argumentTypeReferences, currentNameSpace);</span>
<span class="line-removed"> 494         if (!overload)</span>
<span class="line-removed"> 495             return false;</span>
<span class="line-removed"> 496         auto&amp; resultType = overload-&gt;type();</span>
<span class="line-removed"> 497         return matches(resultType, valueType);</span>
<span class="line-removed"> 498     };</span>
<span class="line-removed"> 499 </span>
<span class="line-removed"> 500     auto checkAnder = [&amp;](CheckKind kind) -&gt; bool {</span>
<span class="line-removed"> 501         size_t numExpectedParameters = kind == CheckKind::Index ? 2 : 1;</span>
<span class="line-removed"> 502         if (functionDefinition.parameters().size() != numExpectedParameters)</span>
<span class="line-removed"> 503             return false;</span>
<span class="line-removed"> 504         {</span>
<span class="line-removed"> 505             auto&amp; unifyNode = functionDefinition.type().unifyNode();</span>
<span class="line-removed"> 506             if (!is&lt;AST::UnnamedType&gt;(unifyNode))</span>
<span class="line-removed"> 507                 return false;</span>
<span class="line-removed"> 508             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);</span>
<span class="line-removed"> 509             if (!is&lt;AST::PointerType&gt;(unnamedType))</span>
<span class="line-removed"> 510                 return false;</span>
<span class="line-removed"> 511         }</span>
<span class="line-removed"> 512         {</span>
<span class="line-removed"> 513             auto&amp; unifyNode = functionDefinition.parameters()[0]-&gt;type()-&gt;unifyNode();</span>
<span class="line-removed"> 514             if (!is&lt;AST::UnnamedType&gt;(unifyNode))</span>
<span class="line-removed"> 515                 return false;</span>
<span class="line-removed"> 516             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);</span>
<span class="line-removed"> 517             return is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType);</span>
<span class="line-removed"> 518         }</span>
<span class="line-removed"> 519     };</span>
<span class="line-removed"> 520 </span>
 521     if (!functionDefinition.isOperator())
 522         return true;
 523     if (functionDefinition.isCast())
 524         return true;
 525     if (functionDefinition.name() == &quot;operator++&quot; || functionDefinition.name() == &quot;operator--&quot;) {
 526         return functionDefinition.parameters().size() == 1
 527             &amp;&amp; matches(*functionDefinition.parameters()[0]-&gt;type(), functionDefinition.type());
 528     }
 529     if (functionDefinition.name() == &quot;operator+&quot; || functionDefinition.name() == &quot;operator-&quot;)
 530         return functionDefinition.parameters().size() == 1 || functionDefinition.parameters().size() == 2;
 531     if (functionDefinition.name() == &quot;operator*&quot;
 532         || functionDefinition.name() == &quot;operator/&quot;
 533         || functionDefinition.name() == &quot;operator%&quot;
 534         || functionDefinition.name() == &quot;operator&amp;&quot;
 535         || functionDefinition.name() == &quot;operator|&quot;
 536         || functionDefinition.name() == &quot;operator^&quot;
 537         || functionDefinition.name() == &quot;operator&lt;&lt;&quot;
 538         || functionDefinition.name() == &quot;operator&gt;&gt;&quot;)
 539         return functionDefinition.parameters().size() == 2;
 540     if (functionDefinition.name() == &quot;operator~&quot;)
 541         return functionDefinition.parameters().size() == 1;
<span class="line-removed"> 542     if (functionDefinition.name() == &quot;operator[]&quot;)</span>
<span class="line-removed"> 543         return checkGetter(CheckKind::Index);</span>
<span class="line-removed"> 544     if (functionDefinition.name() == &quot;operator[]=&quot;)</span>
<span class="line-removed"> 545         return checkSetter(CheckKind::Index);</span>
<span class="line-removed"> 546     if (functionDefinition.name() == &quot;operator&amp;[]&quot;)</span>
<span class="line-removed"> 547         return checkAnder(CheckKind::Index);</span>
<span class="line-removed"> 548     if (functionDefinition.name().startsWith(&quot;operator.&quot;)) {</span>
<span class="line-removed"> 549         if (functionDefinition.name().endsWith(&quot;=&quot;))</span>
<span class="line-removed"> 550             return checkSetter(CheckKind::Dot);</span>
<span class="line-removed"> 551         return checkGetter(CheckKind::Dot);</span>
<span class="line-removed"> 552     }</span>
<span class="line-removed"> 553     if (functionDefinition.name().startsWith(&quot;operator&amp;.&quot;))</span>
<span class="line-removed"> 554         return checkAnder(CheckKind::Dot);</span>
 555     return false;
 556 }
 557 
 558 class Checker : public Visitor {
 559 public:
 560     Checker(const Intrinsics&amp; intrinsics, Program&amp; program)
 561         : m_intrinsics(intrinsics)
 562         , m_program(program)
 563     {
 564         auto addFunction = [&amp;] (AST::FunctionDeclaration&amp; function) {
 565             AST::NamedType* castReturnType = nullptr;
 566             if (function.isCast() &amp;&amp; is&lt;AST::NamedType&gt;(function.type().unifyNode()))
 567                 castReturnType = &amp;downcast&lt;AST::NamedType&gt;(function.type().unifyNode());
 568 
 569             Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; types;
 570             types.reserveInitialCapacity(function.parameters().size());
 571 
 572             for (auto&amp; param : function.parameters())
 573                 types.uncheckedAppend(normalizedTypeForFunctionKey(*param-&gt;type()));
 574 
</pre>
<hr />
<pre>
 583     }
 584 
 585     virtual ~Checker() = default;
 586 
 587     void visit(Program&amp;) override;
 588 
 589     Expected&lt;void, Error&gt; assignTypes();
 590 
 591 private:
 592     bool checkShaderType(const AST::FunctionDefinition&amp;);
 593     bool isBoolType(ResolvingType&amp;);
 594     struct RecurseInfo {
 595         ResolvingType&amp; resolvingType;
 596         const AST::TypeAnnotation typeAnnotation;
 597     };
 598     Optional&lt;RecurseInfo&gt; recurseAndGetInfo(AST::Expression&amp;, bool requiresLeftValue = false);
 599     Optional&lt;RecurseInfo&gt; getInfo(AST::Expression&amp;, bool requiresLeftValue = false);
 600     RefPtr&lt;AST::UnnamedType&gt; recurseAndWrapBaseType(AST::PropertyAccessExpression&amp;);
 601     bool recurseAndRequireBoolType(AST::Expression&amp;);
 602     void assignConcreteType(AST::Expression&amp;, Ref&lt;AST::UnnamedType&gt;, AST::TypeAnnotation);

 603     void assignType(AST::Expression&amp;, RefPtr&lt;ResolvableTypeReference&gt;, AST::TypeAnnotation);
 604     void forwardType(AST::Expression&amp;, ResolvingType&amp;, AST::TypeAnnotation);
 605 
 606     void visit(AST::FunctionDefinition&amp;) override;

 607     void visit(AST::EnumerationDefinition&amp;) override;
 608     void visit(AST::TypeReference&amp;) override;
 609     void visit(AST::VariableDeclaration&amp;) override;
 610     void visit(AST::AssignmentExpression&amp;) override;
 611     void visit(AST::ReadModifyWriteExpression&amp;) override;
 612     void visit(AST::DereferenceExpression&amp;) override;
 613     void visit(AST::MakePointerExpression&amp;) override;
 614     void visit(AST::MakeArrayReferenceExpression&amp;) override;
 615     void visit(AST::DotExpression&amp;) override;
 616     void visit(AST::IndexExpression&amp;) override;
 617     void visit(AST::VariableReference&amp;) override;
 618     void visit(AST::Return&amp;) override;
 619     void visit(AST::PointerType&amp;) override;
 620     void visit(AST::ArrayReferenceType&amp;) override;
 621     void visit(AST::IntegerLiteral&amp;) override;
 622     void visit(AST::UnsignedIntegerLiteral&amp;) override;
 623     void visit(AST::FloatLiteral&amp;) override;
<span class="line-removed"> 624     void visit(AST::NullLiteral&amp;) override;</span>
 625     void visit(AST::BooleanLiteral&amp;) override;
 626     void visit(AST::EnumerationMemberLiteral&amp;) override;
 627     void visit(AST::LogicalNotExpression&amp;) override;
 628     void visit(AST::LogicalExpression&amp;) override;
 629     void visit(AST::IfStatement&amp;) override;
 630     void visit(AST::WhileLoop&amp;) override;
 631     void visit(AST::DoWhileLoop&amp;) override;
 632     void visit(AST::ForLoop&amp;) override;
 633     void visit(AST::SwitchStatement&amp;) override;
 634     void visit(AST::CommaExpression&amp;) override;
 635     void visit(AST::TernaryExpression&amp;) override;
 636     void visit(AST::CallExpression&amp;) override;
 637 
<span class="line-removed"> 638     void finishVisiting(AST::PropertyAccessExpression&amp;, ResolvingType* additionalArgumentType = nullptr);</span>
<span class="line-removed"> 639 </span>
 640     AST::FunctionDeclaration* resolveFunction(Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const String&amp; name, CodeLocation, AST::NamedType* castReturnType = nullptr);
 641 
<span class="line-removed"> 642     RefPtr&lt;AST::UnnamedType&gt; argumentTypeForAndOverload(AST::UnnamedType&amp; baseType, AST::AddressSpace);</span>
<span class="line-removed"> 643 </span>
 644     AST::UnnamedType&amp; wrappedFloatType()
 645     {
 646         if (!m_wrappedFloatType)
 647             m_wrappedFloatType = AST::TypeReference::wrap({ }, m_intrinsics.floatType());
 648         return *m_wrappedFloatType;
 649     }
 650 
<span class="line-modified"> 651     AST::UnnamedType&amp; genericPointerType()</span>
 652     {
<span class="line-modified"> 653         if (!m_genericPointerType)</span>
<span class="line-modified"> 654             m_genericPointerType = AST::PointerType::create({ }, AST::AddressSpace::Thread, AST::TypeReference::wrap({ }, m_intrinsics.floatType()));</span>
<span class="line-modified"> 655         return *m_genericPointerType;</span>
 656     }
 657 
 658     AST::UnnamedType&amp; normalizedTypeForFunctionKey(AST::UnnamedType&amp; type)
 659     {
 660         auto* unifyNode = &amp;type.unifyNode();
 661         if (unifyNode == &amp;m_intrinsics.uintType() || unifyNode == &amp;m_intrinsics.intType())
 662             return wrappedFloatType();
 663 
<span class="line-removed"> 664         if (is&lt;AST::ReferenceType&gt;(type))</span>
<span class="line-removed"> 665             return genericPointerType();</span>
<span class="line-removed"> 666 </span>
 667         return type;
 668     }
 669 
 670     RefPtr&lt;AST::TypeReference&gt; m_wrappedFloatType;
<span class="line-modified"> 671     RefPtr&lt;AST::UnnamedType&gt; m_genericPointerType;</span>
 672     HashMap&lt;AST::Expression*, std::unique_ptr&lt;ResolvingType&gt;&gt; m_typeMap;
 673     HashSet&lt;String&gt; m_vertexEntryPoints[AST::nameSpaceCount];
 674     HashSet&lt;String&gt; m_fragmentEntryPoints[AST::nameSpaceCount];
 675     HashSet&lt;String&gt; m_computeEntryPoints[AST::nameSpaceCount];
 676     const Intrinsics&amp; m_intrinsics;
 677     Program&amp; m_program;
 678     AST::FunctionDefinition* m_currentFunction { nullptr };
 679     HashMap&lt;FunctionKey, Vector&lt;std::reference_wrapper&lt;AST::FunctionDeclaration&gt;, 1&gt;, FunctionKey::Hash, FunctionKey::Traits&gt; m_functions;
<span class="line-removed"> 680     HashMap&lt;AndOverloadTypeKey, RefPtr&lt;AST::UnnamedType&gt;, AndOverloadTypeKey::Hash, AndOverloadTypeKey::Traits&gt; m_andOverloadTypeMap;</span>
 681     AST::NameSpace m_currentNameSpace { AST::NameSpace::StandardLibrary };

 682 };
 683 
 684 void Checker::visit(Program&amp; program)
 685 {
 686     // These visiting functions might add new global statements, so don&#39;t use foreach syntax.
 687     for (size_t i = 0; i &lt; program.typeDefinitions().size(); ++i)
 688         checkErrorAndVisit(program.typeDefinitions()[i]);
 689     for (size_t i = 0; i &lt; program.structureDefinitions().size(); ++i)
 690         checkErrorAndVisit(program.structureDefinitions()[i]);
 691     for (size_t i = 0; i &lt; program.enumerationDefinitions().size(); ++i)
 692         checkErrorAndVisit(program.enumerationDefinitions()[i]);
 693     for (size_t i = 0; i &lt; program.nativeTypeDeclarations().size(); ++i)
 694         checkErrorAndVisit(program.nativeTypeDeclarations()[i]);
 695 
 696     for (size_t i = 0; i &lt; program.functionDefinitions().size(); ++i)
 697         checkErrorAndVisit(program.functionDefinitions()[i]);
 698     for (size_t i = 0; i &lt; program.nativeFunctionDeclarations().size(); ++i)
 699         checkErrorAndVisit(program.nativeFunctionDeclarations()[i]);
 700 }
 701 
</pre>
<hr />
<pre>
 716         if (!success)
 717             return makeUnexpected(Error(&quot;Could not resolve the type of a constant.&quot;));
 718     }
 719 
 720     return { };
 721 }
 722 
 723 bool Checker::checkShaderType(const AST::FunctionDefinition&amp; functionDefinition)
 724 {
 725     auto index = static_cast&lt;unsigned&gt;(m_currentNameSpace);
 726     switch (*functionDefinition.entryPointType()) {
 727     case AST::EntryPointType::Vertex:
 728         return static_cast&lt;bool&gt;(m_vertexEntryPoints[index].add(functionDefinition.name()));
 729     case AST::EntryPointType::Fragment:
 730         return static_cast&lt;bool&gt;(m_fragmentEntryPoints[index].add(functionDefinition.name()));
 731     case AST::EntryPointType::Compute:
 732         return static_cast&lt;bool&gt;(m_computeEntryPoints[index].add(functionDefinition.name()));
 733     }
 734 }
 735 







 736 void Checker::visit(AST::FunctionDefinition&amp; functionDefinition)
 737 {
 738     m_currentNameSpace = functionDefinition.nameSpace();
 739     m_currentFunction = &amp;functionDefinition;
 740     if (functionDefinition.entryPointType()) {
 741         if (!checkShaderType(functionDefinition)) {
 742             setError(Error(&quot;Duplicate entrypoint function.&quot;, functionDefinition.codeLocation()));
 743             return;
 744         }
 745         auto entryPointItems = gatherEntryPointItems(m_intrinsics, functionDefinition);
 746         if (!entryPointItems) {
 747             setError(entryPointItems.error());
 748             return;
 749         }
 750         if (!checkSemantics(entryPointItems-&gt;inputs, entryPointItems-&gt;outputs, functionDefinition.entryPointType(), m_intrinsics)) {
 751             setError(Error(&quot;Bad semantics for entrypoint.&quot;, functionDefinition.codeLocation()));
 752             return;
 753         }
 754     }
<span class="line-modified"> 755     if (!checkOperatorOverload(functionDefinition, m_program.nameContext(), m_currentNameSpace)) {</span>
 756         setError(Error(&quot;Operator does not match expected signature.&quot;, functionDefinition.codeLocation()));
 757         return;
 758     }
 759 
 760     Visitor::visit(functionDefinition);
 761 }
 762 
 763 static RefPtr&lt;AST::UnnamedType&gt; matchAndCommit(ResolvingType&amp; left, ResolvingType&amp; right)
 764 {
 765     return left.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; left) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 766         return right.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 767             if (matches(left, right))
 768                 return left.copyRef();
 769             return nullptr;
 770         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 771             return matchAndCommit(left, right-&gt;resolvableType());
 772         }));
 773     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; left) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 774         return right.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 775             return matchAndCommit(right, left-&gt;resolvableType());
 776         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 777             return matchAndCommit(left-&gt;resolvableType(), right-&gt;resolvableType());
 778         }));
 779     }));
 780 }
 781 
 782 static RefPtr&lt;AST::UnnamedType&gt; matchAndCommit(ResolvingType&amp; resolvingType, AST::UnnamedType&amp; unnamedType)
 783 {
 784     return resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; resolvingType) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 785         if (matches(unnamedType, resolvingType))
 786             return &amp;unnamedType;
 787         return nullptr;
 788     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvingType) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 789         return matchAndCommit(unnamedType, resolvingType-&gt;resolvableType());
 790     }));
 791 }
 792 











 793 static RefPtr&lt;AST::UnnamedType&gt; commit(ResolvingType&amp; resolvingType)
 794 {
 795     return resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 796         return unnamedType.copyRef();
 797     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 798         if (!resolvableTypeReference-&gt;resolvableType().maybeResolvedType())
 799             return commit(resolvableTypeReference-&gt;resolvableType());
 800         return &amp;resolvableTypeReference-&gt;resolvableType().resolvedType();
 801     }));
 802 }
 803 
 804 AST::FunctionDeclaration* Checker::resolveFunction(Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const String&amp; name, CodeLocation location, AST::NamedType* castReturnType)
 805 {
 806     Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; unnamedTypes;
 807     unnamedTypes.reserveInitialCapacity(types.size());
 808 
 809     for (auto resolvingType : types) {
 810         AST::UnnamedType* type = resolvingType.get().visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::UnnamedType* {
 811             return unnamedType.ptr();
 812         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; AST::UnnamedType* {
 813             if (resolvableTypeReference-&gt;resolvableType().maybeResolvedType())
 814                 return &amp;resolvableTypeReference-&gt;resolvableType().resolvedType();
 815 
 816             if (resolvableTypeReference-&gt;resolvableType().isFloatLiteralType()
 817                 || resolvableTypeReference-&gt;resolvableType().isIntegerLiteralType()
 818                 || resolvableTypeReference-&gt;resolvableType().isUnsignedIntegerLiteralType())
 819                 return &amp;wrappedFloatType();
 820 
<span class="line-removed"> 821             if (resolvableTypeReference-&gt;resolvableType().isNullLiteralType())</span>
<span class="line-removed"> 822                 return &amp;genericPointerType();</span>
<span class="line-removed"> 823 </span>
 824             return commit(resolvableTypeReference-&gt;resolvableType()).get();
 825         }));
 826 
 827         if (!type) {
 828             setError(Error(&quot;Could not resolve the type of a constant.&quot;));
 829             return nullptr;
 830         }
 831 
 832         unnamedTypes.uncheckedAppend(normalizedTypeForFunctionKey(*type));
 833     }
 834 
 835     {
 836         auto iter = m_functions.find(FunctionKey { name, WTFMove(unnamedTypes), castReturnType });
 837         if (iter != m_functions.end()) {
 838             if (AST::FunctionDeclaration* function = resolveFunctionOverload(iter-&gt;value, types, castReturnType, m_currentNameSpace))
 839                 return function;
 840         }
 841     }
 842 
 843     if (auto newFunction = resolveByInstantiation(name, location, types, m_intrinsics)) {
</pre>
<hr />
<pre>
 941 }
 942 
 943 void Checker::visit(AST::VariableDeclaration&amp; variableDeclaration)
 944 {
 945     // ReadModifyWriteExpressions are the only place where anonymous variables exist,
 946     // and that doesn&#39;t recurse on the anonymous variables, so we can assume the variable has a type.
 947     checkErrorAndVisit(*variableDeclaration.type());
 948     if (matches(*variableDeclaration.type(), m_intrinsics.voidType())) {
 949         setError(Error(&quot;Variables can&#39;t have void type.&quot;, variableDeclaration.codeLocation()));
 950         return;
 951     }
 952     if (variableDeclaration.initializer()) {
 953         auto&amp; lhsType = *variableDeclaration.type();
 954         auto initializerInfo = recurseAndGetInfo(*variableDeclaration.initializer());
 955         if (!initializerInfo)
 956             return;
 957         if (!matchAndCommit(initializerInfo-&gt;resolvingType, lhsType)) {
 958             setError(Error(&quot;Declared variable type does not match its initializer&#39;s type.&quot;, variableDeclaration.codeLocation()));
 959             return;
 960         }








 961     }
 962 }
 963 
 964 void Checker::assignConcreteType(AST::Expression&amp; expression, Ref&lt;AST::UnnamedType&gt; unnamedType, AST::TypeAnnotation typeAnnotation = AST::RightValue())
 965 {
 966     auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(WTFMove(unnamedType)));
 967     ASSERT_UNUSED(addResult, addResult.isNewEntry);
 968     expression.setTypeAnnotation(WTFMove(typeAnnotation));
 969 }
 970 







 971 void Checker::assignType(AST::Expression&amp; expression, RefPtr&lt;ResolvableTypeReference&gt; resolvableTypeReference, AST::TypeAnnotation typeAnnotation = AST::RightValue())
 972 {
 973     auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(WTFMove(resolvableTypeReference)));
 974     ASSERT_UNUSED(addResult, addResult.isNewEntry);
 975     expression.setTypeAnnotation(WTFMove(typeAnnotation));
 976 }
 977 
 978 void Checker::forwardType(AST::Expression&amp; expression, ResolvingType&amp; resolvingType, AST::TypeAnnotation typeAnnotation = AST::RightValue())
 979 {
 980     resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; result) {
 981         auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(result.copyRef()));
 982         ASSERT_UNUSED(addResult, addResult.isNewEntry);
 983     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; result) {
 984         auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(result.copyRef()));
 985         ASSERT_UNUSED(addResult, addResult.isNewEntry);
 986     }));
 987     expression.setTypeAnnotation(WTFMove(typeAnnotation));
 988 }
 989 
 990 void Checker::visit(AST::AssignmentExpression&amp; assignmentExpression)
</pre>
<hr />
<pre>
1012     if (!leftValueInfo)
1013         return;
1014 
1015     readModifyWriteExpression.oldValue().setType(*leftValueInfo-&gt;resolvingType.getUnnamedType());
1016 
1017     auto newValueInfo = recurseAndGetInfo(readModifyWriteExpression.newValueExpression());
1018     if (!newValueInfo)
1019         return;
1020 
1021     if (RefPtr&lt;AST::UnnamedType&gt; matchedType = matchAndCommit(leftValueInfo-&gt;resolvingType, newValueInfo-&gt;resolvingType))
1022         readModifyWriteExpression.newValue().setType(*matchedType);
1023     else {
1024         setError(Error(&quot;Base of the read-modify-write expression does not match the type of the new value.&quot;, readModifyWriteExpression.codeLocation()));
1025         return;
1026     }
1027 
1028     auto resultInfo = recurseAndGetInfo(readModifyWriteExpression.resultExpression());
1029     if (!resultInfo)
1030         return;
1031 
<span class="line-modified">1032     forwardType(readModifyWriteExpression, resultInfo-&gt;resolvingType);</span>
1033 }
1034 
1035 static AST::UnnamedType* getUnnamedType(ResolvingType&amp; resolvingType)
1036 {
1037     return resolvingType.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; type) -&gt; AST::UnnamedType* {
1038         return type.ptr();
1039     }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp; type) -&gt; AST::UnnamedType* {
1040         // FIXME: If the type isn&#39;t committed, should we just commit() it now?
1041         return type-&gt;resolvableType().maybeResolvedType();
1042     }));
1043 }
1044 
1045 void Checker::visit(AST::DereferenceExpression&amp; dereferenceExpression)
1046 {
1047     auto pointerInfo = recurseAndGetInfo(dereferenceExpression.pointer());
1048     if (!pointerInfo)
1049         return;
1050 
1051     auto* unnamedType = getUnnamedType(pointerInfo-&gt;resolvingType);
1052 
</pre>
<hr />
<pre>
1090     assignConcreteType(makePointerExpression, AST::PointerType::create(makePointerExpression.codeLocation(), *leftAddressSpace, *leftValueType));
1091 }
1092 
1093 void Checker::visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression)
1094 {
1095     auto leftValueInfo = recurseAndGetInfo(makeArrayReferenceExpression.leftValue());
1096     if (!leftValueInfo)
1097         return;
1098 
1099     auto* leftValueType = getUnnamedType(leftValueInfo-&gt;resolvingType);
1100     if (!leftValueType) {
1101         setError(Error(&quot;Cannot make an array reference of a value without a type.&quot;, makeArrayReferenceExpression.codeLocation()));
1102         return;
1103     }
1104 
1105     auto&amp; unifyNode = leftValueType-&gt;unifyNode();
1106     if (is&lt;AST::UnnamedType&gt;(unifyNode)) {
1107         auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
1108         if (is&lt;AST::PointerType&gt;(unnamedType)) {
1109             auto&amp; pointerType = downcast&lt;AST::PointerType&gt;(unnamedType);
<span class="line-removed">1110             // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198163 Save the fact that we&#39;re not targetting the item; we&#39;re targetting the item&#39;s inner element.</span>
1111             assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), pointerType.addressSpace(), pointerType.elementType()));
1112             return;
1113         }
1114 
1115         auto leftAddressSpace = leftValueInfo-&gt;typeAnnotation.leftAddressSpace();
1116         if (!leftAddressSpace) {
1117             setError(Error(&quot;Cannot make an array reference from a non-left-value.&quot;, makeArrayReferenceExpression.codeLocation()));
1118             return;
1119         }
1120 
1121         if (is&lt;AST::ArrayType&gt;(unnamedType)) {
1122             auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(unnamedType);
1123             // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198163 Save the number of elements.
1124             assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), *leftAddressSpace, arrayType.type()));
1125             return;
1126         }
1127     }
1128 
1129     auto leftAddressSpace = leftValueInfo-&gt;typeAnnotation.leftAddressSpace();
1130     if (!leftAddressSpace) {
1131         setError(Error(&quot;Cannot make an array reference from a non-left-value.&quot;, makeArrayReferenceExpression.codeLocation()));
1132         return;
1133     }
1134 
1135     assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), *leftAddressSpace, *leftValueType));
1136 }
1137 
<span class="line-modified">1138 RefPtr&lt;AST::UnnamedType&gt; Checker::argumentTypeForAndOverload(AST::UnnamedType&amp; baseType, AST::AddressSpace addressSpace)</span>
<span class="line-removed">1139 {</span>
<span class="line-removed">1140     AndOverloadTypeKey key { baseType, addressSpace };</span>
<span class="line-removed">1141     {</span>
<span class="line-removed">1142         auto iter = m_andOverloadTypeMap.find(key);</span>
<span class="line-removed">1143         if (iter != m_andOverloadTypeMap.end())</span>
<span class="line-removed">1144             return iter-&gt;value;</span>
<span class="line-removed">1145     }</span>
<span class="line-removed">1146 </span>
<span class="line-removed">1147     auto createArgumentType = [&amp;] () -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
<span class="line-removed">1148         auto&amp; unifyNode = baseType.unifyNode();</span>
<span class="line-removed">1149         if (is&lt;AST::NamedType&gt;(unifyNode)) {</span>
<span class="line-removed">1150             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(unifyNode);</span>
<span class="line-removed">1151             return { AST::PointerType::create(namedType.codeLocation(), addressSpace, AST::TypeReference::wrap(namedType.codeLocation(), namedType)) };</span>
<span class="line-removed">1152         }</span>
<span class="line-removed">1153 </span>
<span class="line-removed">1154         auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);</span>
<span class="line-removed">1155 </span>
<span class="line-removed">1156         if (is&lt;AST::ArrayReferenceType&gt;(unnamedType))</span>
<span class="line-removed">1157             return &amp;unnamedType;</span>
<span class="line-removed">1158 </span>
<span class="line-removed">1159         if (is&lt;AST::ArrayType&gt;(unnamedType))</span>
<span class="line-removed">1160             return { AST::ArrayReferenceType::create(unnamedType.codeLocation(), addressSpace, downcast&lt;AST::ArrayType&gt;(unnamedType).type()) };</span>
<span class="line-removed">1161 </span>
<span class="line-removed">1162         if (is&lt;AST::PointerType&gt;(unnamedType))</span>
<span class="line-removed">1163             return nullptr;</span>
<span class="line-removed">1164 </span>
<span class="line-removed">1165         return { AST::PointerType::create(unnamedType.codeLocation(), addressSpace, unnamedType) };</span>
<span class="line-removed">1166     };</span>
<span class="line-removed">1167 </span>
<span class="line-removed">1168     auto result = createArgumentType();</span>
<span class="line-removed">1169     m_andOverloadTypeMap.add(key, result);</span>
<span class="line-removed">1170     return result;</span>
<span class="line-removed">1171 }</span>
<span class="line-removed">1172 </span>
<span class="line-removed">1173 void Checker::finishVisiting(AST::PropertyAccessExpression&amp; propertyAccessExpression, ResolvingType* additionalArgumentType)</span>
1174 {
<span class="line-modified">1175     auto baseInfo = recurseAndGetInfo(propertyAccessExpression.base());</span>
1176     if (!baseInfo)
1177         return;

1178     auto baseUnnamedType = commit(baseInfo-&gt;resolvingType);
1179     if (!baseUnnamedType) {
<span class="line-modified">1180         setError(Error(&quot;Cannot resolve the type of the base of a property access expression.&quot;, propertyAccessExpression.codeLocation()));</span>
1181         return;
1182     }
1183 
<span class="line-modified">1184     AST::FunctionDeclaration* getterFunction = nullptr;</span>
<span class="line-modified">1185     RefPtr&lt;AST::UnnamedType&gt; getterReturnType = nullptr;</span>
<span class="line-modified">1186     {</span>
<span class="line-modified">1187         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; getterArgumentTypes { baseInfo-&gt;resolvingType };</span>
<span class="line-modified">1188         if (additionalArgumentType)</span>
<span class="line-modified">1189             getterArgumentTypes.append(*additionalArgumentType);</span>
<span class="line-modified">1190         auto getterName = propertyAccessExpression.getterFunctionName();</span>
<span class="line-removed">1191         getterFunction = resolveFunction(getterArgumentTypes, getterName, propertyAccessExpression.codeLocation());</span>
<span class="line-removed">1192         if (hasError())</span>
1193             return;
<span class="line-removed">1194         if (getterFunction)</span>
<span class="line-removed">1195             getterReturnType = &amp;getterFunction-&gt;type();</span>
<span class="line-removed">1196     }</span>
<span class="line-removed">1197 </span>
<span class="line-removed">1198     AST::FunctionDeclaration* anderFunction = nullptr;</span>
<span class="line-removed">1199     RefPtr&lt;AST::UnnamedType&gt; anderReturnType = nullptr;</span>
<span class="line-removed">1200     auto leftAddressSpace = baseInfo-&gt;typeAnnotation.leftAddressSpace();</span>
<span class="line-removed">1201     if (leftAddressSpace) {</span>
<span class="line-removed">1202         if (auto argumentTypeForAndOverload = this-&gt;argumentTypeForAndOverload(*baseUnnamedType, *leftAddressSpace)) {</span>
<span class="line-removed">1203             ResolvingType argumentType = { Ref&lt;AST::UnnamedType&gt;(*argumentTypeForAndOverload) };</span>
<span class="line-removed">1204             Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; anderArgumentTypes { argumentType };</span>
<span class="line-removed">1205             if (additionalArgumentType)</span>
<span class="line-removed">1206                 anderArgumentTypes.append(*additionalArgumentType);</span>
<span class="line-removed">1207             auto anderName = propertyAccessExpression.anderFunctionName();</span>
<span class="line-removed">1208             anderFunction = resolveFunction(anderArgumentTypes, anderName, propertyAccessExpression.codeLocation());</span>
<span class="line-removed">1209             if (hasError())</span>
<span class="line-removed">1210                 return;</span>
<span class="line-removed">1211             if (anderFunction)</span>
<span class="line-removed">1212                 anderReturnType = &amp;downcast&lt;AST::PointerType&gt;(anderFunction-&gt;type()).elementType(); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198164 Enforce the return of anders will always be a pointer</span>
1213         }
<span class="line-modified">1214     }</span>
<span class="line-modified">1215 </span>
<span class="line-modified">1216     AST::FunctionDeclaration* threadAnderFunction = nullptr;</span>
<span class="line-modified">1217     RefPtr&lt;AST::UnnamedType&gt; threadAnderReturnType = nullptr;</span>
<span class="line-modified">1218     if (auto argumentTypeForAndOverload = this-&gt;argumentTypeForAndOverload(*baseUnnamedType, AST::AddressSpace::Thread)) {</span>
<span class="line-modified">1219         ResolvingType argumentType = { Ref&lt;AST::UnnamedType&gt;(AST::PointerType::create(propertyAccessExpression.codeLocation(), AST::AddressSpace::Thread, *baseUnnamedType)) };</span>
<span class="line-modified">1220         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; threadAnderArgumentTypes { argumentType };</span>
<span class="line-removed">1221         if (additionalArgumentType)</span>
<span class="line-removed">1222             threadAnderArgumentTypes.append(*additionalArgumentType);</span>
<span class="line-removed">1223         auto anderName = propertyAccessExpression.anderFunctionName();</span>
<span class="line-removed">1224         threadAnderFunction = resolveFunction(threadAnderArgumentTypes, anderName, propertyAccessExpression.codeLocation());</span>
<span class="line-removed">1225         if (hasError())</span>
1226             return;
<span class="line-modified">1227         if (threadAnderFunction)</span>
<span class="line-modified">1228             threadAnderReturnType = &amp;downcast&lt;AST::PointerType&gt;(threadAnderFunction-&gt;type()).elementType(); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198164 Enforce the return of anders will always be a pointer</span>
<span class="line-modified">1229     }</span>
<span class="line-modified">1230 </span>
<span class="line-modified">1231     if (leftAddressSpace &amp;&amp; !anderFunction &amp;&amp; !getterFunction) {</span>
<span class="line-modified">1232         setError(Error(&quot;Property access instruction must either have an ander or a getter.&quot;, propertyAccessExpression.codeLocation()));</span>
<span class="line-removed">1233         return;</span>
<span class="line-removed">1234     }</span>
1235 
<span class="line-modified">1236     if (!leftAddressSpace &amp;&amp; !threadAnderFunction &amp;&amp; !getterFunction) {</span>
<span class="line-modified">1237         setError(Error(&quot;Property access instruction must either have a thread ander or a getter.&quot;, propertyAccessExpression.codeLocation()));</span>
<span class="line-modified">1238         return;</span>
<span class="line-modified">1239     }</span>

















1240 
<span class="line-modified">1241     if (threadAnderFunction &amp;&amp; getterFunction) {</span>
<span class="line-modified">1242         setError(Error(&quot;Cannot have both a thread ander and a getter.&quot;, propertyAccessExpression.codeLocation()));</span>
<span class="line-modified">1243         return;</span>
<span class="line-modified">1244     }</span>


1245 
<span class="line-modified">1246     if (anderFunction &amp;&amp; threadAnderFunction &amp;&amp; !matches(*anderReturnType, *threadAnderReturnType)) {</span>
<span class="line-modified">1247         setError(Error(&quot;Return type of ander must match the return type of the thread ander.&quot;, propertyAccessExpression.codeLocation()));</span>
<span class="line-modified">1248         return;</span>

1249     }
1250 
<span class="line-modified">1251     if (getterFunction &amp;&amp; anderFunction &amp;&amp; !matches(*getterReturnType, *anderReturnType)) {</span>
<span class="line-modified">1252         setError(Error(&quot;Return type of ander must match the return type of the getter.&quot;, propertyAccessExpression.codeLocation()));</span>
1253         return;
<span class="line-removed">1254     }</span>
1255 
<span class="line-modified">1256     if (getterFunction &amp;&amp; threadAnderFunction &amp;&amp; !matches(*getterReturnType, *threadAnderReturnType)) {</span>
<span class="line-modified">1257         setError(Error(&quot;Return type of the thread ander must match the return type of the getter.&quot;, propertyAccessExpression.codeLocation()));</span>

1258         return;
1259     }
1260 
<span class="line-modified">1261     Ref&lt;AST::UnnamedType&gt; fieldType = getterReturnType ? *getterReturnType : anderReturnType ? *anderReturnType : *threadAnderReturnType;</span>
<span class="line-modified">1262 </span>
<span class="line-modified">1263     AST::FunctionDeclaration* setterFunction = nullptr;</span>
<span class="line-modified">1264     AST::UnnamedType* setterReturnType = nullptr;</span>
<span class="line-modified">1265     {</span>
<span class="line-modified">1266         ResolvingType fieldResolvingType(fieldType.copyRef());</span>
<span class="line-modified">1267         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; setterArgumentTypes { baseInfo-&gt;resolvingType };</span>
<span class="line-modified">1268         if (additionalArgumentType)</span>
<span class="line-modified">1269             setterArgumentTypes.append(*additionalArgumentType);</span>
<span class="line-modified">1270         setterArgumentTypes.append(fieldResolvingType);</span>
<span class="line-modified">1271         auto setterName = propertyAccessExpression.setterFunctionName();</span>
<span class="line-modified">1272         setterFunction = resolveFunction(setterArgumentTypes, setterName, propertyAccessExpression.codeLocation());</span>
<span class="line-modified">1273         if (hasError())</span>









1274             return;
<span class="line-modified">1275         if (setterFunction)</span>
<span class="line-modified">1276             setterReturnType = &amp;setterFunction-&gt;type();</span>
<span class="line-modified">1277     }</span>
<span class="line-removed">1278 </span>
<span class="line-removed">1279     if (setterFunction &amp;&amp; !getterFunction) {</span>
<span class="line-removed">1280         setError(Error(&quot;Cannot define a setter function without a corresponding getter.&quot;, propertyAccessExpression.codeLocation()));</span>
1281         return;
1282     }
<span class="line-removed">1283 </span>
<span class="line-removed">1284     propertyAccessExpression.setGetterFunction(getterFunction);</span>
<span class="line-removed">1285     propertyAccessExpression.setAnderFunction(anderFunction);</span>
<span class="line-removed">1286     propertyAccessExpression.setThreadAnderFunction(threadAnderFunction);</span>
<span class="line-removed">1287     propertyAccessExpression.setSetterFunction(setterFunction);</span>
<span class="line-removed">1288 </span>
<span class="line-removed">1289     AST::TypeAnnotation typeAnnotation = AST::RightValue();</span>
<span class="line-removed">1290     if (auto leftAddressSpace = baseInfo-&gt;typeAnnotation.leftAddressSpace()) {</span>
<span class="line-removed">1291         if (anderFunction)</span>
<span class="line-removed">1292             typeAnnotation = AST::LeftValue { downcast&lt;AST::ReferenceType&gt;(anderFunction-&gt;type()).addressSpace() };</span>
<span class="line-removed">1293         else if (setterFunction)</span>
<span class="line-removed">1294             typeAnnotation = AST::AbstractLeftValue();</span>
<span class="line-removed">1295     } else if (!baseInfo-&gt;typeAnnotation.isRightValue() &amp;&amp; (setterFunction || threadAnderFunction))</span>
<span class="line-removed">1296         typeAnnotation = AST::AbstractLeftValue();</span>
<span class="line-removed">1297     assignConcreteType(propertyAccessExpression, WTFMove(fieldType), WTFMove(typeAnnotation));</span>
<span class="line-removed">1298 }</span>
<span class="line-removed">1299 </span>
<span class="line-removed">1300 void Checker::visit(AST::DotExpression&amp; dotExpression)</span>
<span class="line-removed">1301 {</span>
<span class="line-removed">1302     finishVisiting(dotExpression);</span>
<span class="line-removed">1303 }</span>
<span class="line-removed">1304 </span>
<span class="line-removed">1305 void Checker::visit(AST::IndexExpression&amp; indexExpression)</span>
<span class="line-removed">1306 {</span>
<span class="line-removed">1307     auto baseInfo = recurseAndGetInfo(indexExpression.indexExpression());</span>
<span class="line-removed">1308     if (!baseInfo)</span>
<span class="line-removed">1309         return;</span>
<span class="line-removed">1310     finishVisiting(indexExpression, &amp;baseInfo-&gt;resolvingType);</span>
1311 }
1312 
1313 void Checker::visit(AST::VariableReference&amp; variableReference)
1314 {
1315     ASSERT(variableReference.variable());
1316     ASSERT(variableReference.variable()-&gt;type());
1317 
1318     assignConcreteType(variableReference, *variableReference.variable()-&gt;type(), AST::LeftValue { AST::AddressSpace::Thread });
1319 }
1320 
1321 void Checker::visit(AST::Return&amp; returnStatement)
1322 {
1323     if (returnStatement.value()) {
1324         auto valueInfo = recurseAndGetInfo(*returnStatement.value());
1325         if (!valueInfo)
1326             return;
1327         if (!matchAndCommit(valueInfo-&gt;resolvingType, m_currentFunction-&gt;type()))
1328             setError(Error(&quot;Type of the return value must match the return type of the function.&quot;, returnStatement.codeLocation()));
1329         return;
1330     }
</pre>
<hr />
<pre>
1345     // Following array reference types can cause infinite loops because of data
1346     // structures like linked lists.
1347     // FIXME: Make sure this function should be empty
1348 }
1349 
1350 void Checker::visit(AST::IntegerLiteral&amp; integerLiteral)
1351 {
1352     assignType(integerLiteral, adoptRef(*new ResolvableTypeReference(integerLiteral.type())));
1353 }
1354 
1355 void Checker::visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral)
1356 {
1357     assignType(unsignedIntegerLiteral, adoptRef(*new ResolvableTypeReference(unsignedIntegerLiteral.type())));
1358 }
1359 
1360 void Checker::visit(AST::FloatLiteral&amp; floatLiteral)
1361 {
1362     assignType(floatLiteral, adoptRef(*new ResolvableTypeReference(floatLiteral.type())));
1363 }
1364 
<span class="line-removed">1365 void Checker::visit(AST::NullLiteral&amp; nullLiteral)</span>
<span class="line-removed">1366 {</span>
<span class="line-removed">1367     assignType(nullLiteral, adoptRef(*new ResolvableTypeReference(nullLiteral.type())));</span>
<span class="line-removed">1368 }</span>
<span class="line-removed">1369 </span>
1370 void Checker::visit(AST::BooleanLiteral&amp; booleanLiteral)
1371 {
1372     assignConcreteType(booleanLiteral, AST::TypeReference::wrap(booleanLiteral.codeLocation(), m_intrinsics.boolType()));
1373 }
1374 
1375 void Checker::visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral)
1376 {
1377     ASSERT(enumerationMemberLiteral.enumerationDefinition());
1378     auto&amp; enumerationDefinition = *enumerationMemberLiteral.enumerationDefinition();
1379     assignConcreteType(enumerationMemberLiteral, AST::TypeReference::wrap(enumerationMemberLiteral.codeLocation(), enumerationDefinition));
1380 }
1381 
1382 bool Checker::isBoolType(ResolvingType&amp; resolvingType)
1383 {
1384     return resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; left) -&gt; bool {
1385         return matches(left, m_intrinsics.boolType());
1386     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; left) -&gt; bool {
1387         return static_cast&lt;bool&gt;(matchAndCommit(m_intrinsics.boolType(), left-&gt;resolvableType()));
1388     }));
1389 }
</pre>
<hr />
<pre>
1471         return &amp;valueNamedUnifyNode;
1472     })();
1473     if (!valueType) {
1474         setError(Error(&quot;Invalid type for the expression condition of the switch statement.&quot;, switchStatement.codeLocation()));
1475         return;
1476     }
1477 
1478     bool hasDefault = false;
1479     for (auto&amp; switchCase : switchStatement.switchCases()) {
1480         checkErrorAndVisit(switchCase.block());
1481         if (!switchCase.value()) {
1482             hasDefault = true;
1483             continue;
1484         }
1485         auto success = switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) -&gt; bool {
1486             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, integerLiteral.type()));
1487         }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) -&gt; bool {
1488             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, unsignedIntegerLiteral.type()));
1489         }, [&amp;](AST::FloatLiteral&amp; floatLiteral) -&gt; bool {
1490             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, floatLiteral.type()));
<span class="line-removed">1491         }, [&amp;](AST::NullLiteral&amp; nullLiteral) -&gt; bool {</span>
<span class="line-removed">1492             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, nullLiteral.type()));</span>
1493         }, [&amp;](AST::BooleanLiteral&amp;) -&gt; bool {
1494             return matches(*valueType, m_intrinsics.boolType());
1495         }, [&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) -&gt; bool {
1496             ASSERT(enumerationMemberLiteral.enumerationDefinition());
1497             return matches(*valueType, *enumerationMemberLiteral.enumerationDefinition());
1498         }));
1499         if (!success) {
1500             setError(Error(&quot;Invalid type for switch case.&quot;, switchCase.codeLocation()));
1501             return;
1502         }
1503     }
1504 
1505     for (size_t i = 0; i &lt; switchStatement.switchCases().size(); ++i) {
1506         auto&amp; firstCase = switchStatement.switchCases()[i];
1507         for (size_t j = i + 1; j &lt; switchStatement.switchCases().size(); ++j) {
1508             auto&amp; secondCase = switchStatement.switchCases()[j];
1509 
1510             if (static_cast&lt;bool&gt;(firstCase.value()) != static_cast&lt;bool&gt;(secondCase.value()))
1511                 continue;
1512 
</pre>
</td>
<td>
<hr />
<pre>
 182         static bool equal(const FunctionKey&amp; a, const FunctionKey&amp; b)
 183         {
 184             return a == b;
 185         }
 186 
 187         static const bool safeToCompareToEmptyOrDeleted = false;
 188         static const bool emptyValueIsZero = false;
 189     };
 190 
 191     struct Traits : public WTF::SimpleClassHashTraits&lt;FunctionKey&gt; {
 192         static const bool hasIsEmptyValueFunction = true;
 193         static bool isEmptyValue(const FunctionKey&amp; key) { return key.isEmptyValue(); }
 194     };
 195 
 196 private:
 197     String m_name;
 198     Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; m_types;
 199     AST::NamedType* m_castReturnType;
 200 };
 201 






































































 202 static AST::NativeFunctionDeclaration resolveWithReferenceComparator(CodeLocation location, ResolvingType&amp; firstArgument, ResolvingType&amp; secondArgument, const Intrinsics&amp; intrinsics)
 203 {
 204     const bool isOperator = true;
 205     auto returnType = AST::TypeReference::wrap(location, intrinsics.boolType());
 206     auto argumentType = firstArgument.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; Ref&lt;AST::UnnamedType&gt; {
 207         return unnamedType.copyRef();
 208     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; Ref&lt;AST::UnnamedType&gt; {
 209         return secondArgument.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; Ref&lt;AST::UnnamedType&gt; {
 210             return unnamedType.copyRef();
 211         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; Ref&lt;AST::UnnamedType&gt; {
 212             // We encountered &quot;null == null&quot;.
 213             // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198162 This can probably be generalized, using the &quot;preferred type&quot; infrastructure used by generic literals
 214             ASSERT_NOT_REACHED();
 215             return AST::TypeReference::wrap(location, intrinsics.intType());
 216         }));
 217     }));
 218     AST::VariableDeclarations parameters;
 219     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), argumentType.copyRef(), String(), nullptr, nullptr));
 220     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), WTFMove(argumentType), String(), nullptr, nullptr));
 221     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(location, AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator==&quot;, String::ConstructFromLiteral), WTFMove(parameters), nullptr, isOperator, ParsingMode::StandardLibrary));
 222 }
 223 
 224 enum class Acceptability {
 225     Yes,

 226     No
 227 };
 228 
 229 static Optional&lt;AST::NativeFunctionDeclaration&gt; resolveByInstantiation(const String&amp; name, CodeLocation location, const Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const Intrinsics&amp; intrinsics)
 230 {
<span class="line-modified"> 231     if (name == &quot;operator==&quot; &amp;&amp; types.size() == 2) {</span>

























 232         auto acceptability = [](ResolvingType&amp; resolvingType) -&gt; Acceptability {
 233             return resolvingType.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; Acceptability {
 234                 auto&amp; unifyNode = unnamedType-&gt;unifyNode();
 235                 return is&lt;AST::UnnamedType&gt;(unifyNode) &amp;&amp; is&lt;AST::ReferenceType&gt;(downcast&lt;AST::UnnamedType&gt;(unifyNode)) ? Acceptability::Yes : Acceptability::No;
<span class="line-modified"> 236             }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; Acceptability {</span>
<span class="line-modified"> 237                 return Acceptability::No;</span>
 238             }));
 239         };
 240         auto leftAcceptability = acceptability(types[0].get());
 241         auto rightAcceptability = acceptability(types[1].get());
 242         bool success = false;
 243         if (leftAcceptability == Acceptability::Yes &amp;&amp; rightAcceptability == Acceptability::Yes) {
 244             auto&amp; unnamedType1 = *types[0].get().getUnnamedType();
 245             auto&amp; unnamedType2 = *types[1].get().getUnnamedType();
 246             success = matches(unnamedType1, unnamedType2);
<span class="line-modified"> 247         }</span>


 248         if (success)
 249             return resolveWithReferenceComparator(location, types[0].get(), types[1].get(), intrinsics);
 250     }
 251     return WTF::nullopt;
 252 }
 253 
 254 static bool checkSemantics(Vector&lt;EntryPointItem&gt;&amp; inputItems, Vector&lt;EntryPointItem&gt;&amp; outputItems, const Optional&lt;AST::EntryPointType&gt;&amp; entryPointType, const Intrinsics&amp; intrinsics)
 255 {
 256     {
 257         auto checkDuplicateSemantics = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items) -&gt; bool {
 258             for (size_t i = 0; i &lt; items.size(); ++i) {
 259                 for (size_t j = i + 1; j &lt; items.size(); ++j) {
 260                     if (items[i].semantic == items[j].semantic)
 261                         return false;
 262                 }
 263             }
 264             return true;
 265         };
 266         if (!checkDuplicateSemantics(inputItems))
 267             return false;
</pre>
<hr />
<pre>
 312                 else if (is&lt;AST::ArrayReferenceType&gt;(item.unnamedType))
 313                     podChecker.checkErrorAndVisit(downcast&lt;AST::ArrayReferenceType&gt;(*item.unnamedType).elementType());
 314                 else if (is&lt;AST::ArrayType&gt;(item.unnamedType))
 315                     podChecker.checkErrorAndVisit(downcast&lt;AST::ArrayType&gt;(*item.unnamedType).type());
 316                 else
 317                     continue;
 318                 if (podChecker.hasError())
 319                     return false;
 320             }
 321             return true;
 322         };
 323         if (!checkPODData(inputItems))
 324             return false;
 325         if (!checkPODData(outputItems))
 326             return false;
 327     }
 328 
 329     return true;
 330 }
 331 
<span class="line-modified"> 332 static bool checkOperatorOverload(const AST::FunctionDefinition&amp; functionDefinition)</span>
 333 {
 334     enum class CheckKind {
 335         Index,
 336         Dot
 337     };
 338 




















































































 339     if (!functionDefinition.isOperator())
 340         return true;
 341     if (functionDefinition.isCast())
 342         return true;
 343     if (functionDefinition.name() == &quot;operator++&quot; || functionDefinition.name() == &quot;operator--&quot;) {
 344         return functionDefinition.parameters().size() == 1
 345             &amp;&amp; matches(*functionDefinition.parameters()[0]-&gt;type(), functionDefinition.type());
 346     }
 347     if (functionDefinition.name() == &quot;operator+&quot; || functionDefinition.name() == &quot;operator-&quot;)
 348         return functionDefinition.parameters().size() == 1 || functionDefinition.parameters().size() == 2;
 349     if (functionDefinition.name() == &quot;operator*&quot;
 350         || functionDefinition.name() == &quot;operator/&quot;
 351         || functionDefinition.name() == &quot;operator%&quot;
 352         || functionDefinition.name() == &quot;operator&amp;&quot;
 353         || functionDefinition.name() == &quot;operator|&quot;
 354         || functionDefinition.name() == &quot;operator^&quot;
 355         || functionDefinition.name() == &quot;operator&lt;&lt;&quot;
 356         || functionDefinition.name() == &quot;operator&gt;&gt;&quot;)
 357         return functionDefinition.parameters().size() == 2;
 358     if (functionDefinition.name() == &quot;operator~&quot;)
 359         return functionDefinition.parameters().size() == 1;













 360     return false;
 361 }
 362 
 363 class Checker : public Visitor {
 364 public:
 365     Checker(const Intrinsics&amp; intrinsics, Program&amp; program)
 366         : m_intrinsics(intrinsics)
 367         , m_program(program)
 368     {
 369         auto addFunction = [&amp;] (AST::FunctionDeclaration&amp; function) {
 370             AST::NamedType* castReturnType = nullptr;
 371             if (function.isCast() &amp;&amp; is&lt;AST::NamedType&gt;(function.type().unifyNode()))
 372                 castReturnType = &amp;downcast&lt;AST::NamedType&gt;(function.type().unifyNode());
 373 
 374             Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; types;
 375             types.reserveInitialCapacity(function.parameters().size());
 376 
 377             for (auto&amp; param : function.parameters())
 378                 types.uncheckedAppend(normalizedTypeForFunctionKey(*param-&gt;type()));
 379 
</pre>
<hr />
<pre>
 388     }
 389 
 390     virtual ~Checker() = default;
 391 
 392     void visit(Program&amp;) override;
 393 
 394     Expected&lt;void, Error&gt; assignTypes();
 395 
 396 private:
 397     bool checkShaderType(const AST::FunctionDefinition&amp;);
 398     bool isBoolType(ResolvingType&amp;);
 399     struct RecurseInfo {
 400         ResolvingType&amp; resolvingType;
 401         const AST::TypeAnnotation typeAnnotation;
 402     };
 403     Optional&lt;RecurseInfo&gt; recurseAndGetInfo(AST::Expression&amp;, bool requiresLeftValue = false);
 404     Optional&lt;RecurseInfo&gt; getInfo(AST::Expression&amp;, bool requiresLeftValue = false);
 405     RefPtr&lt;AST::UnnamedType&gt; recurseAndWrapBaseType(AST::PropertyAccessExpression&amp;);
 406     bool recurseAndRequireBoolType(AST::Expression&amp;);
 407     void assignConcreteType(AST::Expression&amp;, Ref&lt;AST::UnnamedType&gt;, AST::TypeAnnotation);
<span class="line-added"> 408     void assignConcreteType(AST::Expression&amp;, AST::NamedType&amp;, AST::TypeAnnotation);</span>
 409     void assignType(AST::Expression&amp;, RefPtr&lt;ResolvableTypeReference&gt;, AST::TypeAnnotation);
 410     void forwardType(AST::Expression&amp;, ResolvingType&amp;, AST::TypeAnnotation);
 411 
 412     void visit(AST::FunctionDefinition&amp;) override;
<span class="line-added"> 413     void visit(AST::FunctionDeclaration&amp;) override;</span>
 414     void visit(AST::EnumerationDefinition&amp;) override;
 415     void visit(AST::TypeReference&amp;) override;
 416     void visit(AST::VariableDeclaration&amp;) override;
 417     void visit(AST::AssignmentExpression&amp;) override;
 418     void visit(AST::ReadModifyWriteExpression&amp;) override;
 419     void visit(AST::DereferenceExpression&amp;) override;
 420     void visit(AST::MakePointerExpression&amp;) override;
 421     void visit(AST::MakeArrayReferenceExpression&amp;) override;
 422     void visit(AST::DotExpression&amp;) override;
 423     void visit(AST::IndexExpression&amp;) override;
 424     void visit(AST::VariableReference&amp;) override;
 425     void visit(AST::Return&amp;) override;
 426     void visit(AST::PointerType&amp;) override;
 427     void visit(AST::ArrayReferenceType&amp;) override;
 428     void visit(AST::IntegerLiteral&amp;) override;
 429     void visit(AST::UnsignedIntegerLiteral&amp;) override;
 430     void visit(AST::FloatLiteral&amp;) override;

 431     void visit(AST::BooleanLiteral&amp;) override;
 432     void visit(AST::EnumerationMemberLiteral&amp;) override;
 433     void visit(AST::LogicalNotExpression&amp;) override;
 434     void visit(AST::LogicalExpression&amp;) override;
 435     void visit(AST::IfStatement&amp;) override;
 436     void visit(AST::WhileLoop&amp;) override;
 437     void visit(AST::DoWhileLoop&amp;) override;
 438     void visit(AST::ForLoop&amp;) override;
 439     void visit(AST::SwitchStatement&amp;) override;
 440     void visit(AST::CommaExpression&amp;) override;
 441     void visit(AST::TernaryExpression&amp;) override;
 442     void visit(AST::CallExpression&amp;) override;
 443 


 444     AST::FunctionDeclaration* resolveFunction(Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const String&amp; name, CodeLocation, AST::NamedType* castReturnType = nullptr);
 445 


 446     AST::UnnamedType&amp; wrappedFloatType()
 447     {
 448         if (!m_wrappedFloatType)
 449             m_wrappedFloatType = AST::TypeReference::wrap({ }, m_intrinsics.floatType());
 450         return *m_wrappedFloatType;
 451     }
 452 
<span class="line-modified"> 453     AST::UnnamedType&amp; wrappedUintType()</span>
 454     {
<span class="line-modified"> 455         if (!m_wrappedUintType)</span>
<span class="line-modified"> 456             m_wrappedUintType = AST::TypeReference::wrap({ }, m_intrinsics.uintType());</span>
<span class="line-modified"> 457         return *m_wrappedUintType;</span>
 458     }
 459 
 460     AST::UnnamedType&amp; normalizedTypeForFunctionKey(AST::UnnamedType&amp; type)
 461     {
 462         auto* unifyNode = &amp;type.unifyNode();
 463         if (unifyNode == &amp;m_intrinsics.uintType() || unifyNode == &amp;m_intrinsics.intType())
 464             return wrappedFloatType();
 465 



 466         return type;
 467     }
 468 
 469     RefPtr&lt;AST::TypeReference&gt; m_wrappedFloatType;
<span class="line-modified"> 470     RefPtr&lt;AST::TypeReference&gt; m_wrappedUintType;</span>
 471     HashMap&lt;AST::Expression*, std::unique_ptr&lt;ResolvingType&gt;&gt; m_typeMap;
 472     HashSet&lt;String&gt; m_vertexEntryPoints[AST::nameSpaceCount];
 473     HashSet&lt;String&gt; m_fragmentEntryPoints[AST::nameSpaceCount];
 474     HashSet&lt;String&gt; m_computeEntryPoints[AST::nameSpaceCount];
 475     const Intrinsics&amp; m_intrinsics;
 476     Program&amp; m_program;
 477     AST::FunctionDefinition* m_currentFunction { nullptr };
 478     HashMap&lt;FunctionKey, Vector&lt;std::reference_wrapper&lt;AST::FunctionDeclaration&gt;, 1&gt;, FunctionKey::Hash, FunctionKey::Traits&gt; m_functions;

 479     AST::NameSpace m_currentNameSpace { AST::NameSpace::StandardLibrary };
<span class="line-added"> 480     bool m_isVisitingParameters { false };</span>
 481 };
 482 
 483 void Checker::visit(Program&amp; program)
 484 {
 485     // These visiting functions might add new global statements, so don&#39;t use foreach syntax.
 486     for (size_t i = 0; i &lt; program.typeDefinitions().size(); ++i)
 487         checkErrorAndVisit(program.typeDefinitions()[i]);
 488     for (size_t i = 0; i &lt; program.structureDefinitions().size(); ++i)
 489         checkErrorAndVisit(program.structureDefinitions()[i]);
 490     for (size_t i = 0; i &lt; program.enumerationDefinitions().size(); ++i)
 491         checkErrorAndVisit(program.enumerationDefinitions()[i]);
 492     for (size_t i = 0; i &lt; program.nativeTypeDeclarations().size(); ++i)
 493         checkErrorAndVisit(program.nativeTypeDeclarations()[i]);
 494 
 495     for (size_t i = 0; i &lt; program.functionDefinitions().size(); ++i)
 496         checkErrorAndVisit(program.functionDefinitions()[i]);
 497     for (size_t i = 0; i &lt; program.nativeFunctionDeclarations().size(); ++i)
 498         checkErrorAndVisit(program.nativeFunctionDeclarations()[i]);
 499 }
 500 
</pre>
<hr />
<pre>
 515         if (!success)
 516             return makeUnexpected(Error(&quot;Could not resolve the type of a constant.&quot;));
 517     }
 518 
 519     return { };
 520 }
 521 
 522 bool Checker::checkShaderType(const AST::FunctionDefinition&amp; functionDefinition)
 523 {
 524     auto index = static_cast&lt;unsigned&gt;(m_currentNameSpace);
 525     switch (*functionDefinition.entryPointType()) {
 526     case AST::EntryPointType::Vertex:
 527         return static_cast&lt;bool&gt;(m_vertexEntryPoints[index].add(functionDefinition.name()));
 528     case AST::EntryPointType::Fragment:
 529         return static_cast&lt;bool&gt;(m_fragmentEntryPoints[index].add(functionDefinition.name()));
 530     case AST::EntryPointType::Compute:
 531         return static_cast&lt;bool&gt;(m_computeEntryPoints[index].add(functionDefinition.name()));
 532     }
 533 }
 534 
<span class="line-added"> 535 void Checker::visit(AST::FunctionDeclaration&amp; functionDeclaration)</span>
<span class="line-added"> 536 {</span>
<span class="line-added"> 537     m_isVisitingParameters = true;</span>
<span class="line-added"> 538     Visitor::visit(functionDeclaration);</span>
<span class="line-added"> 539     m_isVisitingParameters = false;</span>
<span class="line-added"> 540 }</span>
<span class="line-added"> 541 </span>
 542 void Checker::visit(AST::FunctionDefinition&amp; functionDefinition)
 543 {
 544     m_currentNameSpace = functionDefinition.nameSpace();
 545     m_currentFunction = &amp;functionDefinition;
 546     if (functionDefinition.entryPointType()) {
 547         if (!checkShaderType(functionDefinition)) {
 548             setError(Error(&quot;Duplicate entrypoint function.&quot;, functionDefinition.codeLocation()));
 549             return;
 550         }
 551         auto entryPointItems = gatherEntryPointItems(m_intrinsics, functionDefinition);
 552         if (!entryPointItems) {
 553             setError(entryPointItems.error());
 554             return;
 555         }
 556         if (!checkSemantics(entryPointItems-&gt;inputs, entryPointItems-&gt;outputs, functionDefinition.entryPointType(), m_intrinsics)) {
 557             setError(Error(&quot;Bad semantics for entrypoint.&quot;, functionDefinition.codeLocation()));
 558             return;
 559         }
 560     }
<span class="line-modified"> 561     if (!checkOperatorOverload(functionDefinition)) {</span>
 562         setError(Error(&quot;Operator does not match expected signature.&quot;, functionDefinition.codeLocation()));
 563         return;
 564     }
 565 
 566     Visitor::visit(functionDefinition);
 567 }
 568 
 569 static RefPtr&lt;AST::UnnamedType&gt; matchAndCommit(ResolvingType&amp; left, ResolvingType&amp; right)
 570 {
 571     return left.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; left) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 572         return right.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 573             if (matches(left, right))
 574                 return left.copyRef();
 575             return nullptr;
 576         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 577             return matchAndCommit(left, right-&gt;resolvableType());
 578         }));
 579     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; left) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 580         return right.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 581             return matchAndCommit(right, left-&gt;resolvableType());
 582         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 583             return matchAndCommit(left-&gt;resolvableType(), right-&gt;resolvableType());
 584         }));
 585     }));
 586 }
 587 
 588 static RefPtr&lt;AST::UnnamedType&gt; matchAndCommit(ResolvingType&amp; resolvingType, AST::UnnamedType&amp; unnamedType)
 589 {
 590     return resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; resolvingType) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 591         if (matches(unnamedType, resolvingType))
 592             return &amp;unnamedType;
 593         return nullptr;
 594     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvingType) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 595         return matchAndCommit(unnamedType, resolvingType-&gt;resolvableType());
 596     }));
 597 }
 598 
<span class="line-added"> 599 static bool matchAndCommit(ResolvingType&amp; resolvingType, AST::NamedType&amp; namedType)</span>
<span class="line-added"> 600 {</span>
<span class="line-added"> 601     return resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; resolvingType) {</span>
<span class="line-added"> 602         if (matches(resolvingType, namedType))</span>
<span class="line-added"> 603             return true;</span>
<span class="line-added"> 604         return false;</span>
<span class="line-added"> 605     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvingType) -&gt; bool {</span>
<span class="line-added"> 606         return matchAndCommit(namedType, resolvingType-&gt;resolvableType());</span>
<span class="line-added"> 607     }));</span>
<span class="line-added"> 608 }</span>
<span class="line-added"> 609 </span>
 610 static RefPtr&lt;AST::UnnamedType&gt; commit(ResolvingType&amp; resolvingType)
 611 {
 612     return resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 613         return unnamedType.copyRef();
 614     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 615         if (!resolvableTypeReference-&gt;resolvableType().maybeResolvedType())
 616             return commit(resolvableTypeReference-&gt;resolvableType());
 617         return &amp;resolvableTypeReference-&gt;resolvableType().resolvedType();
 618     }));
 619 }
 620 
 621 AST::FunctionDeclaration* Checker::resolveFunction(Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const String&amp; name, CodeLocation location, AST::NamedType* castReturnType)
 622 {
 623     Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; unnamedTypes;
 624     unnamedTypes.reserveInitialCapacity(types.size());
 625 
 626     for (auto resolvingType : types) {
 627         AST::UnnamedType* type = resolvingType.get().visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::UnnamedType* {
 628             return unnamedType.ptr();
 629         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; AST::UnnamedType* {
 630             if (resolvableTypeReference-&gt;resolvableType().maybeResolvedType())
 631                 return &amp;resolvableTypeReference-&gt;resolvableType().resolvedType();
 632 
 633             if (resolvableTypeReference-&gt;resolvableType().isFloatLiteralType()
 634                 || resolvableTypeReference-&gt;resolvableType().isIntegerLiteralType()
 635                 || resolvableTypeReference-&gt;resolvableType().isUnsignedIntegerLiteralType())
 636                 return &amp;wrappedFloatType();
 637 



 638             return commit(resolvableTypeReference-&gt;resolvableType()).get();
 639         }));
 640 
 641         if (!type) {
 642             setError(Error(&quot;Could not resolve the type of a constant.&quot;));
 643             return nullptr;
 644         }
 645 
 646         unnamedTypes.uncheckedAppend(normalizedTypeForFunctionKey(*type));
 647     }
 648 
 649     {
 650         auto iter = m_functions.find(FunctionKey { name, WTFMove(unnamedTypes), castReturnType });
 651         if (iter != m_functions.end()) {
 652             if (AST::FunctionDeclaration* function = resolveFunctionOverload(iter-&gt;value, types, castReturnType, m_currentNameSpace))
 653                 return function;
 654         }
 655     }
 656 
 657     if (auto newFunction = resolveByInstantiation(name, location, types, m_intrinsics)) {
</pre>
<hr />
<pre>
 755 }
 756 
 757 void Checker::visit(AST::VariableDeclaration&amp; variableDeclaration)
 758 {
 759     // ReadModifyWriteExpressions are the only place where anonymous variables exist,
 760     // and that doesn&#39;t recurse on the anonymous variables, so we can assume the variable has a type.
 761     checkErrorAndVisit(*variableDeclaration.type());
 762     if (matches(*variableDeclaration.type(), m_intrinsics.voidType())) {
 763         setError(Error(&quot;Variables can&#39;t have void type.&quot;, variableDeclaration.codeLocation()));
 764         return;
 765     }
 766     if (variableDeclaration.initializer()) {
 767         auto&amp; lhsType = *variableDeclaration.type();
 768         auto initializerInfo = recurseAndGetInfo(*variableDeclaration.initializer());
 769         if (!initializerInfo)
 770             return;
 771         if (!matchAndCommit(initializerInfo-&gt;resolvingType, lhsType)) {
 772             setError(Error(&quot;Declared variable type does not match its initializer&#39;s type.&quot;, variableDeclaration.codeLocation()));
 773             return;
 774         }
<span class="line-added"> 775     } else if (!m_isVisitingParameters &amp;&amp; is&lt;AST::ReferenceType&gt;(variableDeclaration.type()-&gt;unifyNode())) {</span>
<span class="line-added"> 776         if (is&lt;AST::PointerType&gt;(variableDeclaration.type()-&gt;unifyNode()))</span>
<span class="line-added"> 777             setError(Error(&quot;Must assign to a pointer variable declaration in its initializer.&quot;, variableDeclaration.codeLocation()));</span>
<span class="line-added"> 778         else {</span>
<span class="line-added"> 779             ASSERT(is&lt;AST::ArrayReferenceType&gt;(variableDeclaration.type()-&gt;unifyNode()));</span>
<span class="line-added"> 780             setError(Error(&quot;Must assign to an array reference variable declaration in its initializer.&quot;, variableDeclaration.codeLocation()));</span>
<span class="line-added"> 781         }</span>
<span class="line-added"> 782         return;</span>
 783     }
 784 }
 785 
 786 void Checker::assignConcreteType(AST::Expression&amp; expression, Ref&lt;AST::UnnamedType&gt; unnamedType, AST::TypeAnnotation typeAnnotation = AST::RightValue())
 787 {
 788     auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(WTFMove(unnamedType)));
 789     ASSERT_UNUSED(addResult, addResult.isNewEntry);
 790     expression.setTypeAnnotation(WTFMove(typeAnnotation));
 791 }
 792 
<span class="line-added"> 793 void Checker::assignConcreteType(AST::Expression&amp; expression, AST::NamedType&amp; type, AST::TypeAnnotation annotation)</span>
<span class="line-added"> 794 {</span>
<span class="line-added"> 795     auto unnamedType = AST::TypeReference::wrap(type.codeLocation(), type);</span>
<span class="line-added"> 796     Visitor::visit(unnamedType);</span>
<span class="line-added"> 797     assignConcreteType(expression, WTFMove(unnamedType), annotation);</span>
<span class="line-added"> 798 }</span>
<span class="line-added"> 799 </span>
 800 void Checker::assignType(AST::Expression&amp; expression, RefPtr&lt;ResolvableTypeReference&gt; resolvableTypeReference, AST::TypeAnnotation typeAnnotation = AST::RightValue())
 801 {
 802     auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(WTFMove(resolvableTypeReference)));
 803     ASSERT_UNUSED(addResult, addResult.isNewEntry);
 804     expression.setTypeAnnotation(WTFMove(typeAnnotation));
 805 }
 806 
 807 void Checker::forwardType(AST::Expression&amp; expression, ResolvingType&amp; resolvingType, AST::TypeAnnotation typeAnnotation = AST::RightValue())
 808 {
 809     resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; result) {
 810         auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(result.copyRef()));
 811         ASSERT_UNUSED(addResult, addResult.isNewEntry);
 812     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; result) {
 813         auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(result.copyRef()));
 814         ASSERT_UNUSED(addResult, addResult.isNewEntry);
 815     }));
 816     expression.setTypeAnnotation(WTFMove(typeAnnotation));
 817 }
 818 
 819 void Checker::visit(AST::AssignmentExpression&amp; assignmentExpression)
</pre>
<hr />
<pre>
 841     if (!leftValueInfo)
 842         return;
 843 
 844     readModifyWriteExpression.oldValue().setType(*leftValueInfo-&gt;resolvingType.getUnnamedType());
 845 
 846     auto newValueInfo = recurseAndGetInfo(readModifyWriteExpression.newValueExpression());
 847     if (!newValueInfo)
 848         return;
 849 
 850     if (RefPtr&lt;AST::UnnamedType&gt; matchedType = matchAndCommit(leftValueInfo-&gt;resolvingType, newValueInfo-&gt;resolvingType))
 851         readModifyWriteExpression.newValue().setType(*matchedType);
 852     else {
 853         setError(Error(&quot;Base of the read-modify-write expression does not match the type of the new value.&quot;, readModifyWriteExpression.codeLocation()));
 854         return;
 855     }
 856 
 857     auto resultInfo = recurseAndGetInfo(readModifyWriteExpression.resultExpression());
 858     if (!resultInfo)
 859         return;
 860 
<span class="line-modified"> 861     forwardType(readModifyWriteExpression, resultInfo-&gt;resolvingType, AST::RightValue());</span>
 862 }
 863 
 864 static AST::UnnamedType* getUnnamedType(ResolvingType&amp; resolvingType)
 865 {
 866     return resolvingType.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; type) -&gt; AST::UnnamedType* {
 867         return type.ptr();
 868     }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp; type) -&gt; AST::UnnamedType* {
 869         // FIXME: If the type isn&#39;t committed, should we just commit() it now?
 870         return type-&gt;resolvableType().maybeResolvedType();
 871     }));
 872 }
 873 
 874 void Checker::visit(AST::DereferenceExpression&amp; dereferenceExpression)
 875 {
 876     auto pointerInfo = recurseAndGetInfo(dereferenceExpression.pointer());
 877     if (!pointerInfo)
 878         return;
 879 
 880     auto* unnamedType = getUnnamedType(pointerInfo-&gt;resolvingType);
 881 
</pre>
<hr />
<pre>
 919     assignConcreteType(makePointerExpression, AST::PointerType::create(makePointerExpression.codeLocation(), *leftAddressSpace, *leftValueType));
 920 }
 921 
 922 void Checker::visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression)
 923 {
 924     auto leftValueInfo = recurseAndGetInfo(makeArrayReferenceExpression.leftValue());
 925     if (!leftValueInfo)
 926         return;
 927 
 928     auto* leftValueType = getUnnamedType(leftValueInfo-&gt;resolvingType);
 929     if (!leftValueType) {
 930         setError(Error(&quot;Cannot make an array reference of a value without a type.&quot;, makeArrayReferenceExpression.codeLocation()));
 931         return;
 932     }
 933 
 934     auto&amp; unifyNode = leftValueType-&gt;unifyNode();
 935     if (is&lt;AST::UnnamedType&gt;(unifyNode)) {
 936         auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
 937         if (is&lt;AST::PointerType&gt;(unnamedType)) {
 938             auto&amp; pointerType = downcast&lt;AST::PointerType&gt;(unnamedType);

 939             assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), pointerType.addressSpace(), pointerType.elementType()));
 940             return;
 941         }
 942 
 943         auto leftAddressSpace = leftValueInfo-&gt;typeAnnotation.leftAddressSpace();
 944         if (!leftAddressSpace) {
 945             setError(Error(&quot;Cannot make an array reference from a non-left-value.&quot;, makeArrayReferenceExpression.codeLocation()));
 946             return;
 947         }
 948 
 949         if (is&lt;AST::ArrayType&gt;(unnamedType)) {
 950             auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(unnamedType);
 951             // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198163 Save the number of elements.
 952             assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), *leftAddressSpace, arrayType.type()));
 953             return;
 954         }
 955     }
 956 
 957     auto leftAddressSpace = leftValueInfo-&gt;typeAnnotation.leftAddressSpace();
 958     if (!leftAddressSpace) {
 959         setError(Error(&quot;Cannot make an array reference from a non-left-value.&quot;, makeArrayReferenceExpression.codeLocation()));
 960         return;
 961     }
 962 
 963     assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), *leftAddressSpace, *leftValueType));
 964 }
 965 
<span class="line-modified"> 966 void Checker::visit(AST::DotExpression&amp; dotExpression)</span>



































 967 {
<span class="line-modified"> 968     auto baseInfo = recurseAndGetInfo(dotExpression.base());</span>
 969     if (!baseInfo)
 970         return;
<span class="line-added"> 971 </span>
 972     auto baseUnnamedType = commit(baseInfo-&gt;resolvingType);
 973     if (!baseUnnamedType) {
<span class="line-modified"> 974         setError(Error(&quot;Cannot resolve the type of the base of a dot expression.&quot;, dotExpression.codeLocation()));</span>
 975         return;
 976     }
 977 
<span class="line-modified"> 978     auto&amp; type = baseUnnamedType-&gt;unifyNode();</span>
<span class="line-modified"> 979     if (is&lt;AST::StructureDefinition&gt;(type)) {</span>
<span class="line-modified"> 980         auto&amp; structure = downcast&lt;AST::StructureDefinition&gt;(type);</span>
<span class="line-modified"> 981         if (AST::StructureElement* element = structure.find(dotExpression.fieldName()))</span>
<span class="line-modified"> 982             assignConcreteType(dotExpression, element-&gt;type(), baseInfo-&gt;typeAnnotation);</span>
<span class="line-modified"> 983         else {</span>
<span class="line-modified"> 984             setError(Error(makeString(&quot;Field name: &#39;&quot;, dotExpression.fieldName(), &quot;&#39; does not exist on structure: &quot;, structure.name()), dotExpression.codeLocation()));</span>


 985             return;



















 986         }
<span class="line-modified"> 987     } else if (dotExpression.fieldName() == &quot;length&quot;) {</span>
<span class="line-modified"> 988         if (is&lt;AST::ArrayReferenceType&gt;(type)</span>
<span class="line-modified"> 989             || is&lt;AST::ArrayType&gt;(type)</span>
<span class="line-modified"> 990             || (is&lt;AST::NativeTypeDeclaration&gt;(type) &amp;&amp; downcast&lt;AST::NativeTypeDeclaration&gt;(type).isVector())) {</span>
<span class="line-modified"> 991             assignConcreteType(dotExpression, wrappedUintType(), AST::RightValue());</span>
<span class="line-modified"> 992         } else {</span>
<span class="line-modified"> 993             setError(Error(&quot;.length field is only available on arrays, array references, or vectors.&quot;, dotExpression.codeLocation()));</span>





 994             return;
<span class="line-modified"> 995         }</span>
<span class="line-modified"> 996     } else if (is&lt;AST::NativeTypeDeclaration&gt;(type) &amp;&amp; downcast&lt;AST::NativeTypeDeclaration&gt;(type).isVector()) {</span>
<span class="line-modified"> 997         if (!m_program.isValidVectorProperty(dotExpression.fieldName())) {</span>
<span class="line-modified"> 998             setError(Error(makeString(&quot;&#39;.&quot;, dotExpression.fieldName(), &quot;&#39; is not a valid property on a vector.&quot;), dotExpression.codeLocation()));</span>
<span class="line-modified"> 999             return;</span>
<span class="line-modified">1000         }</span>


1001 
<span class="line-modified">1002         auto typeAnnotation = baseInfo-&gt;typeAnnotation.isRightValue() ? AST::TypeAnnotation { AST::RightValue() } : AST::TypeAnnotation { AST::AbstractLeftValue() };</span>
<span class="line-modified">1003 </span>
<span class="line-modified">1004         size_t fieldLength = dotExpression.fieldName().length();</span>
<span class="line-modified">1005         auto&amp; innerType = downcast&lt;AST::NativeTypeDeclaration&gt;(type).vectorTypeArgument();</span>
<span class="line-added">1006         if (fieldLength == 1)</span>
<span class="line-added">1007             assignConcreteType(dotExpression, innerType, typeAnnotation);</span>
<span class="line-added">1008         else {</span>
<span class="line-added">1009             if (matches(innerType, m_intrinsics.boolType()))</span>
<span class="line-added">1010                 assignConcreteType(dotExpression, m_intrinsics.boolVectorTypeForSize(fieldLength), typeAnnotation);</span>
<span class="line-added">1011             else if (matches(innerType, m_intrinsics.intType()))</span>
<span class="line-added">1012                 assignConcreteType(dotExpression, m_intrinsics.intVectorTypeForSize(fieldLength), typeAnnotation);</span>
<span class="line-added">1013             else if (matches(innerType, m_intrinsics.uintType()))</span>
<span class="line-added">1014                 assignConcreteType(dotExpression, m_intrinsics.uintVectorTypeForSize(fieldLength), typeAnnotation);</span>
<span class="line-added">1015             else if (matches(innerType, m_intrinsics.floatType()))</span>
<span class="line-added">1016                 assignConcreteType(dotExpression, m_intrinsics.floatVectorTypeForSize(fieldLength), typeAnnotation);</span>
<span class="line-added">1017             else</span>
<span class="line-added">1018                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">1019         }</span>
<span class="line-added">1020     } else</span>
<span class="line-added">1021         setError(Error(&quot;Base value of dot expression must be a structure, array, or vector.&quot;, dotExpression.codeLocation()));</span>
<span class="line-added">1022 }</span>
1023 
<span class="line-modified">1024 void Checker::visit(AST::IndexExpression&amp; indexExpression)</span>
<span class="line-modified">1025 {</span>
<span class="line-modified">1026     {</span>
<span class="line-modified">1027         auto indexInfo = recurseAndGetInfo(indexExpression.indexExpression());</span>
<span class="line-added">1028         if (!indexInfo)</span>
<span class="line-added">1029             return;</span>
1030 
<span class="line-modified">1031         if (!matchAndCommit(indexInfo-&gt;resolvingType, m_intrinsics.uintType())) {</span>
<span class="line-modified">1032             setError(Error(&quot;Index in an index expression must be a uint.&quot;, indexExpression.codeLocation()));</span>
<span class="line-modified">1033             return;</span>
<span class="line-added">1034         }</span>
1035     }
1036 
<span class="line-modified">1037     auto baseInfo = recurseAndGetInfo(indexExpression.base());</span>
<span class="line-modified">1038     if (!baseInfo)</span>
1039         return;

1040 
<span class="line-modified">1041     auto baseUnnamedType = commit(baseInfo-&gt;resolvingType);</span>
<span class="line-modified">1042     if (!baseUnnamedType) {</span>
<span class="line-added">1043         setError(Error(&quot;Cannot resolve the type of the base of an index expression.&quot;, indexExpression.codeLocation()));</span>
1044         return;
1045     }
1046 
<span class="line-modified">1047     auto&amp; type = baseUnnamedType-&gt;unifyNode();</span>
<span class="line-modified">1048     if (is&lt;AST::ArrayReferenceType&gt;(type)) {</span>
<span class="line-modified">1049         auto&amp; arrayReferenceType = downcast&lt;AST::ArrayReferenceType&gt;(type);</span>
<span class="line-modified">1050         assignConcreteType(indexExpression, arrayReferenceType.elementType(), AST::LeftValue { arrayReferenceType.addressSpace() });</span>
<span class="line-modified">1051     } else if (is&lt;AST::ArrayType&gt;(type))</span>
<span class="line-modified">1052         assignConcreteType(indexExpression, downcast&lt;AST::ArrayType&gt;(type).type(), baseInfo-&gt;typeAnnotation);</span>
<span class="line-modified">1053     else if (is&lt;AST::NativeTypeDeclaration&gt;(type)) {</span>
<span class="line-modified">1054         auto&amp; nativeType = downcast&lt;AST::NativeTypeDeclaration&gt;(type);</span>
<span class="line-modified">1055         auto typeAnnotation = baseInfo-&gt;typeAnnotation.isRightValue() ? AST::TypeAnnotation { AST::RightValue() } : AST::TypeAnnotation { AST::AbstractLeftValue() };</span>
<span class="line-modified">1056         if (nativeType.isVector())</span>
<span class="line-modified">1057             assignConcreteType(indexExpression, nativeType.vectorTypeArgument(), typeAnnotation);</span>
<span class="line-modified">1058         else if (nativeType.isMatrix()) {</span>
<span class="line-modified">1059             auto&amp; innerType = nativeType.matrixTypeArgument();</span>
<span class="line-added">1060             unsigned numRows = nativeType.numberOfMatrixRows();</span>
<span class="line-added">1061             if (matches(innerType, m_intrinsics.boolType()))</span>
<span class="line-added">1062                 assignConcreteType(indexExpression, m_intrinsics.boolVectorTypeForSize(numRows), typeAnnotation);</span>
<span class="line-added">1063             else if (matches(innerType, m_intrinsics.floatType()))</span>
<span class="line-added">1064                 assignConcreteType(indexExpression, m_intrinsics.floatVectorTypeForSize(numRows), typeAnnotation);</span>
<span class="line-added">1065             else</span>
<span class="line-added">1066                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">1067         } else {</span>
<span class="line-added">1068             setError(Error(&quot;Index expression on unknown type.&quot;, indexExpression.codeLocation()));</span>
1069             return;
<span class="line-modified">1070         }</span>
<span class="line-modified">1071     } else {</span>
<span class="line-modified">1072         setError(Error(&quot;Index expression on an unknown base type. Base type must be an array, array reference, vector, or matrix.&quot;, indexExpression.codeLocation()));</span>



1073         return;
1074     }




























1075 }
1076 
1077 void Checker::visit(AST::VariableReference&amp; variableReference)
1078 {
1079     ASSERT(variableReference.variable());
1080     ASSERT(variableReference.variable()-&gt;type());
1081 
1082     assignConcreteType(variableReference, *variableReference.variable()-&gt;type(), AST::LeftValue { AST::AddressSpace::Thread });
1083 }
1084 
1085 void Checker::visit(AST::Return&amp; returnStatement)
1086 {
1087     if (returnStatement.value()) {
1088         auto valueInfo = recurseAndGetInfo(*returnStatement.value());
1089         if (!valueInfo)
1090             return;
1091         if (!matchAndCommit(valueInfo-&gt;resolvingType, m_currentFunction-&gt;type()))
1092             setError(Error(&quot;Type of the return value must match the return type of the function.&quot;, returnStatement.codeLocation()));
1093         return;
1094     }
</pre>
<hr />
<pre>
1109     // Following array reference types can cause infinite loops because of data
1110     // structures like linked lists.
1111     // FIXME: Make sure this function should be empty
1112 }
1113 
1114 void Checker::visit(AST::IntegerLiteral&amp; integerLiteral)
1115 {
1116     assignType(integerLiteral, adoptRef(*new ResolvableTypeReference(integerLiteral.type())));
1117 }
1118 
1119 void Checker::visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral)
1120 {
1121     assignType(unsignedIntegerLiteral, adoptRef(*new ResolvableTypeReference(unsignedIntegerLiteral.type())));
1122 }
1123 
1124 void Checker::visit(AST::FloatLiteral&amp; floatLiteral)
1125 {
1126     assignType(floatLiteral, adoptRef(*new ResolvableTypeReference(floatLiteral.type())));
1127 }
1128 





1129 void Checker::visit(AST::BooleanLiteral&amp; booleanLiteral)
1130 {
1131     assignConcreteType(booleanLiteral, AST::TypeReference::wrap(booleanLiteral.codeLocation(), m_intrinsics.boolType()));
1132 }
1133 
1134 void Checker::visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral)
1135 {
1136     ASSERT(enumerationMemberLiteral.enumerationDefinition());
1137     auto&amp; enumerationDefinition = *enumerationMemberLiteral.enumerationDefinition();
1138     assignConcreteType(enumerationMemberLiteral, AST::TypeReference::wrap(enumerationMemberLiteral.codeLocation(), enumerationDefinition));
1139 }
1140 
1141 bool Checker::isBoolType(ResolvingType&amp; resolvingType)
1142 {
1143     return resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; left) -&gt; bool {
1144         return matches(left, m_intrinsics.boolType());
1145     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; left) -&gt; bool {
1146         return static_cast&lt;bool&gt;(matchAndCommit(m_intrinsics.boolType(), left-&gt;resolvableType()));
1147     }));
1148 }
</pre>
<hr />
<pre>
1230         return &amp;valueNamedUnifyNode;
1231     })();
1232     if (!valueType) {
1233         setError(Error(&quot;Invalid type for the expression condition of the switch statement.&quot;, switchStatement.codeLocation()));
1234         return;
1235     }
1236 
1237     bool hasDefault = false;
1238     for (auto&amp; switchCase : switchStatement.switchCases()) {
1239         checkErrorAndVisit(switchCase.block());
1240         if (!switchCase.value()) {
1241             hasDefault = true;
1242             continue;
1243         }
1244         auto success = switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) -&gt; bool {
1245             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, integerLiteral.type()));
1246         }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) -&gt; bool {
1247             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, unsignedIntegerLiteral.type()));
1248         }, [&amp;](AST::FloatLiteral&amp; floatLiteral) -&gt; bool {
1249             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, floatLiteral.type()));


1250         }, [&amp;](AST::BooleanLiteral&amp;) -&gt; bool {
1251             return matches(*valueType, m_intrinsics.boolType());
1252         }, [&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) -&gt; bool {
1253             ASSERT(enumerationMemberLiteral.enumerationDefinition());
1254             return matches(*valueType, *enumerationMemberLiteral.enumerationDefinition());
1255         }));
1256         if (!success) {
1257             setError(Error(&quot;Invalid type for switch case.&quot;, switchCase.codeLocation()));
1258             return;
1259         }
1260     }
1261 
1262     for (size_t i = 0; i &lt; switchStatement.switchCases().size(); ++i) {
1263         auto&amp; firstCase = switchStatement.switchCases()[i];
1264         for (size_t j = i + 1; j &lt; switchStatement.switchCases().size(); ++j) {
1265             auto&amp; secondCase = switchStatement.switchCases()[j];
1266 
1267             if (static_cast&lt;bool&gt;(firstCase.value()) != static_cast&lt;bool&gt;(secondCase.value()))
1268                 continue;
1269 
</pre>
</td>
</tr>
</table>
<center><a href="WHLSLCheckTextureReferences.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLHighZombieFinder.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
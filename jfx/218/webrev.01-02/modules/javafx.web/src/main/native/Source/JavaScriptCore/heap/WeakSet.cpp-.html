<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/WeakSet.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2012, 2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WeakSet.h&quot;
 28 
 29 #include &quot;Heap.h&quot;
 30 #include &quot;JSCInlines.h&quot;
 31 #include &quot;VM.h&quot;
 32 
 33 namespace JSC {
 34 
 35 WeakSet::~WeakSet()
 36 {
 37     if (isOnList())
 38         remove();
 39 
 40     Heap&amp; heap = *this-&gt;heap();
 41     WeakBlock* next = 0;
 42     for (WeakBlock* block = m_blocks.head(); block; block = next) {
 43         next = block-&gt;next();
 44         WeakBlock::destroy(heap, block);
 45     }
 46     m_blocks.clear();
 47 }
 48 
 49 void WeakSet::sweep()
 50 {
 51     for (WeakBlock* block = m_blocks.head(); block;) {
 52         heap()-&gt;sweepNextLogicallyEmptyWeakBlock();
 53 
 54         WeakBlock* nextBlock = block-&gt;next();
 55         block-&gt;sweep();
 56         if (block-&gt;isLogicallyEmptyButNotFree()) {
 57             // If this WeakBlock is logically empty, but still has Weaks pointing into it,
 58             // we can&#39;t destroy it just yet. Detach it from the WeakSet and hand ownership
 59             // to the Heap so we don&#39;t pin down the entire MarkedBlock or LargeAllocation.
 60             m_blocks.remove(block);
 61             heap()-&gt;addLogicallyEmptyWeakBlock(block);
 62             block-&gt;disconnectContainer();
 63         }
 64         block = nextBlock;
 65     }
 66 
 67     resetAllocator();
 68 }
 69 
 70 void WeakSet::shrink()
 71 {
 72     WeakBlock* next;
 73     for (WeakBlock* block = m_blocks.head(); block; block = next) {
 74         next = block-&gt;next();
 75 
 76         if (block-&gt;isEmpty())
 77             removeAllocator(block);
 78     }
 79 
 80     resetAllocator();
 81 
 82     if (m_blocks.isEmpty() &amp;&amp; isOnList())
 83         remove();
 84 }
 85 
 86 WeakBlock::FreeCell* WeakSet::findAllocator()
 87 {
 88     if (WeakBlock::FreeCell* allocator = tryFindAllocator())
 89         return allocator;
 90 
 91     return addAllocator();
 92 }
 93 
 94 WeakBlock::FreeCell* WeakSet::tryFindAllocator()
 95 {
 96     while (m_nextAllocator) {
 97         WeakBlock* block = m_nextAllocator;
 98         m_nextAllocator = m_nextAllocator-&gt;next();
 99 
100         WeakBlock::SweepResult sweepResult = block-&gt;takeSweepResult();
101         if (sweepResult.freeList)
102             return sweepResult.freeList;
103     }
104 
105     return 0;
106 }
107 
108 WeakBlock::FreeCell* WeakSet::addAllocator()
109 {
110     if (!isOnList())
111         heap()-&gt;objectSpace().addActiveWeakSet(this);
112 
113     WeakBlock* block = WeakBlock::create(*heap(), m_container);
114     heap()-&gt;didAllocate(WeakBlock::blockSize);
115     m_blocks.append(block);
116     WeakBlock::SweepResult sweepResult = block-&gt;takeSweepResult();
117     ASSERT(!sweepResult.isNull() &amp;&amp; sweepResult.freeList);
118     return sweepResult.freeList;
119 }
120 
121 void WeakSet::removeAllocator(WeakBlock* block)
122 {
123     m_blocks.remove(block);
124     WeakBlock::destroy(*heap(), block);
125 }
126 
127 } // namespace JSC
    </pre>
  </body>
</html>
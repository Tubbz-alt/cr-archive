<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/SharedBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SerializedPlatformRepresentation.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SharedBuffer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/SharedBuffer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  *    notice, this list of conditions and the following disclaimer in the
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;SharedBuffer.h&quot;
 30 
 31 #include &lt;algorithm&gt;



 32 #include &lt;wtf/unicode/UTF8Conversion.h&gt;
 33 
 34 namespace WebCore {
 35 
 36 SharedBuffer::SharedBuffer(const char* data, size_t size)
 37 {
 38     append(data, size);
 39 }
 40 
 41 SharedBuffer::SharedBuffer(const unsigned char* data, size_t size)
 42 {
 43     append(reinterpret_cast&lt;const char*&gt;(data), size);
 44 }
 45 
 46 SharedBuffer::SharedBuffer(FileSystem::MappedFileData&amp;&amp; fileData)
 47     : m_size(fileData.size())
 48 {
 49     m_segments.append({0, DataSegment::create(WTFMove(fileData))});
 50 }
 51 
</pre>
<hr />
<pre>
 75 
 76     if (!mappingSuccess)
 77         return SharedBuffer::createFromReadingFile(filePath);
 78 
 79     return adoptRef(new SharedBuffer(WTFMove(mappedFileData)));
 80 }
 81 
 82 Ref&lt;SharedBuffer&gt; SharedBuffer::create(Vector&lt;char&gt;&amp;&amp; vector)
 83 {
 84     return adoptRef(*new SharedBuffer(WTFMove(vector)));
 85 }
 86 
 87 // FIXME: Move the whole class from Vector&lt;char&gt; to Vector&lt;uint8_t&gt; and make this efficient, replacing the Vector&lt;char&gt; version above.
 88 Ref&lt;SharedBuffer&gt; SharedBuffer::create(Vector&lt;uint8_t&gt;&amp;&amp; vector)
 89 {
 90     return adoptRef(*new SharedBuffer { vector.data(), vector.size() });
 91 }
 92 
 93 void SharedBuffer::combineIntoOneSegment() const
 94 {
<span class="line-modified"> 95 #if !ASSERT_DISABLED</span>
 96     // FIXME: We ought to be able to set this to true and have no assertions fire.
 97     // Remove all instances of appending after calling this, because they are all O(n^2) algorithms since r215686.
 98     // m_hasBeenCombinedIntoOneSegment = true;
 99 #endif
100     if (m_segments.size() &lt;= 1)
101         return;
102 
103     Vector&lt;char&gt; combinedData;
104     combinedData.reserveInitialCapacity(m_size);
105     for (const auto&amp; segment : m_segments)
106         combinedData.append(segment.segment-&gt;data(), segment.segment-&gt;size());
107     ASSERT(combinedData.size() == m_size);
108     m_segments.clear();
109     m_segments.append({0, DataSegment::create(WTFMove(combinedData))});
110     ASSERT(m_segments.size() == 1);
111     ASSERT(internallyConsistent());
112 }
113 
114 const char* SharedBuffer::data() const
115 {
116     if (!m_segments.size())
117         return nullptr;
118     combineIntoOneSegment();
119     ASSERT(internallyConsistent());
120     return m_segments[0].segment-&gt;data();
121 }
122 
123 SharedBufferDataView SharedBuffer::getSomeData(size_t position) const
124 {
125     RELEASE_ASSERT(position &lt; m_size);
126     auto comparator = [](const size_t&amp; position, const DataSegmentVectorEntry&amp; entry) {
127         return position &lt; entry.beginPosition;
128     };
129     const DataSegmentVectorEntry* element = std::upper_bound(m_segments.begin(), m_segments.end(), position, comparator);
130     element--; // std::upper_bound gives a pointer to the element that is greater than position. We want the element just before that.
131     return { element-&gt;segment.copyRef(), position - element-&gt;beginPosition };
132 }
133 










134 RefPtr&lt;ArrayBuffer&gt; SharedBuffer::tryCreateArrayBuffer() const
135 {
136     auto arrayBuffer = ArrayBuffer::tryCreateUninitialized(static_cast&lt;unsigned&gt;(size()), sizeof(char));
137     if (!arrayBuffer) {
138         WTFLogAlways(&quot;SharedBuffer::tryCreateArrayBuffer Unable to create buffer. Requested size was %zu\n&quot;, size());
139         return nullptr;
140     }
141 
142     size_t position = 0;
143     for (const auto&amp; segment : m_segments) {
144         memcpy(static_cast&lt;char*&gt;(arrayBuffer-&gt;data()) + position, segment.segment-&gt;data(), segment.segment-&gt;size());
145         position += segment.segment-&gt;size();
146     }
147 
148     ASSERT(position == m_size);
149     ASSERT(internallyConsistent());
150     return arrayBuffer;
151 }
152 
153 void SharedBuffer::append(const SharedBuffer&amp; data)
</pre>
<hr />
<pre>
182 
183 void SharedBuffer::clear()
184 {
185     m_size = 0;
186     m_segments.clear();
187     ASSERT(internallyConsistent());
188 }
189 
190 Ref&lt;SharedBuffer&gt; SharedBuffer::copy() const
191 {
192     Ref&lt;SharedBuffer&gt; clone = adoptRef(*new SharedBuffer);
193     clone-&gt;m_size = m_size;
194     clone-&gt;m_segments.reserveInitialCapacity(m_segments.size());
195     for (const auto&amp; element : m_segments)
196         clone-&gt;m_segments.uncheckedAppend({element.beginPosition, element.segment.copyRef()});
197     ASSERT(clone-&gt;internallyConsistent());
198     ASSERT(internallyConsistent());
199     return clone;
200 }
201 
<span class="line-modified">202 #if !ASSERT_DISABLED</span>
203 bool SharedBuffer::internallyConsistent() const
204 {
205     size_t position = 0;
206     for (const auto&amp; element : m_segments) {
207         if (element.beginPosition != position)
208             return false;
209         position += element.segment-&gt;size();
210     }
211     return position == m_size;
212 }
<span class="line-modified">213 #endif</span>
214 
215 const char* SharedBuffer::DataSegment::data() const
216 {
217     auto visitor = WTF::makeVisitor(
218         [](const Vector&lt;char&gt;&amp; data) { return data.data(); },
219 #if USE(CF)
220         [](const RetainPtr&lt;CFDataRef&gt;&amp; data) { return reinterpret_cast&lt;const char*&gt;(CFDataGetBytePtr(data.get())); },
221 #endif
222 #if USE(SOUP)
223         [](const GUniquePtr&lt;SoupBuffer&gt;&amp; data) { return data-&gt;data; },
224 #endif
225 #if USE(GLIB)
226         [](const GRefPtr&lt;GBytes&gt;&amp; data) { return reinterpret_cast&lt;const char*&gt;(g_bytes_get_data(data.get(), nullptr)); },
227 #endif
228 #if USE(GSTREAMER)
229         [](const RefPtr&lt;GstMappedBuffer&gt;&amp; data) { return reinterpret_cast&lt;const char*&gt;(data-&gt;data()); },
230 #endif
231         [](const FileSystem::MappedFileData&amp; data) { return reinterpret_cast&lt;const char*&gt;(data.data()); }
232     );
233     return WTF::visit(visitor, m_immutableData);
234 }
235 
236 #if !USE(CF)
237 void SharedBuffer::hintMemoryNotNeededSoon() const
238 {
239 }
240 #endif
241 





242 bool SharedBuffer::operator==(const SharedBuffer&amp; other) const
243 {
244     if (this == &amp;other)
245         return true;
246 
247     if (m_size != other.m_size)
248         return false;
249 
250     auto thisIterator = begin();
251     size_t thisOffset = 0;
252     auto otherIterator = other.begin();
253     size_t otherOffset = 0;
254 
255     while (thisIterator != end() &amp;&amp; otherIterator != other.end()) {
256         auto&amp; thisSegment = thisIterator-&gt;segment.get();
257         auto&amp; otherSegment = otherIterator-&gt;segment.get();
258 
259         if (&amp;thisSegment == &amp;otherSegment &amp;&amp; !thisOffset &amp;&amp; !otherOffset) {
260             ++thisIterator;
261             ++otherIterator;
</pre>
</td>
<td>
<hr />
<pre>
 12  *    notice, this list of conditions and the following disclaimer in the
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;SharedBuffer.h&quot;
 30 
 31 #include &lt;algorithm&gt;
<span class="line-added"> 32 #include &lt;wtf/HexNumber.h&gt;</span>
<span class="line-added"> 33 #include &lt;wtf/persistence/PersistentCoders.h&gt;</span>
<span class="line-added"> 34 #include &lt;wtf/text/StringBuilder.h&gt;</span>
 35 #include &lt;wtf/unicode/UTF8Conversion.h&gt;
 36 
 37 namespace WebCore {
 38 
 39 SharedBuffer::SharedBuffer(const char* data, size_t size)
 40 {
 41     append(data, size);
 42 }
 43 
 44 SharedBuffer::SharedBuffer(const unsigned char* data, size_t size)
 45 {
 46     append(reinterpret_cast&lt;const char*&gt;(data), size);
 47 }
 48 
 49 SharedBuffer::SharedBuffer(FileSystem::MappedFileData&amp;&amp; fileData)
 50     : m_size(fileData.size())
 51 {
 52     m_segments.append({0, DataSegment::create(WTFMove(fileData))});
 53 }
 54 
</pre>
<hr />
<pre>
 78 
 79     if (!mappingSuccess)
 80         return SharedBuffer::createFromReadingFile(filePath);
 81 
 82     return adoptRef(new SharedBuffer(WTFMove(mappedFileData)));
 83 }
 84 
 85 Ref&lt;SharedBuffer&gt; SharedBuffer::create(Vector&lt;char&gt;&amp;&amp; vector)
 86 {
 87     return adoptRef(*new SharedBuffer(WTFMove(vector)));
 88 }
 89 
 90 // FIXME: Move the whole class from Vector&lt;char&gt; to Vector&lt;uint8_t&gt; and make this efficient, replacing the Vector&lt;char&gt; version above.
 91 Ref&lt;SharedBuffer&gt; SharedBuffer::create(Vector&lt;uint8_t&gt;&amp;&amp; vector)
 92 {
 93     return adoptRef(*new SharedBuffer { vector.data(), vector.size() });
 94 }
 95 
 96 void SharedBuffer::combineIntoOneSegment() const
 97 {
<span class="line-modified"> 98 #if ASSERT_ENABLED</span>
 99     // FIXME: We ought to be able to set this to true and have no assertions fire.
100     // Remove all instances of appending after calling this, because they are all O(n^2) algorithms since r215686.
101     // m_hasBeenCombinedIntoOneSegment = true;
102 #endif
103     if (m_segments.size() &lt;= 1)
104         return;
105 
106     Vector&lt;char&gt; combinedData;
107     combinedData.reserveInitialCapacity(m_size);
108     for (const auto&amp; segment : m_segments)
109         combinedData.append(segment.segment-&gt;data(), segment.segment-&gt;size());
110     ASSERT(combinedData.size() == m_size);
111     m_segments.clear();
112     m_segments.append({0, DataSegment::create(WTFMove(combinedData))});
113     ASSERT(m_segments.size() == 1);
114     ASSERT(internallyConsistent());
115 }
116 
117 const char* SharedBuffer::data() const
118 {
119     if (!m_segments.size())
120         return nullptr;
121     combineIntoOneSegment();
122     ASSERT(internallyConsistent());
123     return m_segments[0].segment-&gt;data();
124 }
125 
126 SharedBufferDataView SharedBuffer::getSomeData(size_t position) const
127 {
128     RELEASE_ASSERT(position &lt; m_size);
129     auto comparator = [](const size_t&amp; position, const DataSegmentVectorEntry&amp; entry) {
130         return position &lt; entry.beginPosition;
131     };
132     const DataSegmentVectorEntry* element = std::upper_bound(m_segments.begin(), m_segments.end(), position, comparator);
133     element--; // std::upper_bound gives a pointer to the element that is greater than position. We want the element just before that.
134     return { element-&gt;segment.copyRef(), position - element-&gt;beginPosition };
135 }
136 
<span class="line-added">137 String SharedBuffer::toHexString() const</span>
<span class="line-added">138 {</span>
<span class="line-added">139     StringBuilder stringBuilder;</span>
<span class="line-added">140     for (unsigned byteOffset = 0; byteOffset &lt; size(); byteOffset++) {</span>
<span class="line-added">141         const uint8_t byte = data()[byteOffset];</span>
<span class="line-added">142         stringBuilder.append(pad(&#39;0&#39;, 2, hex(byte)));</span>
<span class="line-added">143     }</span>
<span class="line-added">144     return stringBuilder.toString();</span>
<span class="line-added">145 }</span>
<span class="line-added">146 </span>
147 RefPtr&lt;ArrayBuffer&gt; SharedBuffer::tryCreateArrayBuffer() const
148 {
149     auto arrayBuffer = ArrayBuffer::tryCreateUninitialized(static_cast&lt;unsigned&gt;(size()), sizeof(char));
150     if (!arrayBuffer) {
151         WTFLogAlways(&quot;SharedBuffer::tryCreateArrayBuffer Unable to create buffer. Requested size was %zu\n&quot;, size());
152         return nullptr;
153     }
154 
155     size_t position = 0;
156     for (const auto&amp; segment : m_segments) {
157         memcpy(static_cast&lt;char*&gt;(arrayBuffer-&gt;data()) + position, segment.segment-&gt;data(), segment.segment-&gt;size());
158         position += segment.segment-&gt;size();
159     }
160 
161     ASSERT(position == m_size);
162     ASSERT(internallyConsistent());
163     return arrayBuffer;
164 }
165 
166 void SharedBuffer::append(const SharedBuffer&amp; data)
</pre>
<hr />
<pre>
195 
196 void SharedBuffer::clear()
197 {
198     m_size = 0;
199     m_segments.clear();
200     ASSERT(internallyConsistent());
201 }
202 
203 Ref&lt;SharedBuffer&gt; SharedBuffer::copy() const
204 {
205     Ref&lt;SharedBuffer&gt; clone = adoptRef(*new SharedBuffer);
206     clone-&gt;m_size = m_size;
207     clone-&gt;m_segments.reserveInitialCapacity(m_segments.size());
208     for (const auto&amp; element : m_segments)
209         clone-&gt;m_segments.uncheckedAppend({element.beginPosition, element.segment.copyRef()});
210     ASSERT(clone-&gt;internallyConsistent());
211     ASSERT(internallyConsistent());
212     return clone;
213 }
214 
<span class="line-modified">215 #if ASSERT_ENABLED</span>
216 bool SharedBuffer::internallyConsistent() const
217 {
218     size_t position = 0;
219     for (const auto&amp; element : m_segments) {
220         if (element.beginPosition != position)
221             return false;
222         position += element.segment-&gt;size();
223     }
224     return position == m_size;
225 }
<span class="line-modified">226 #endif // ASSERT_ENABLED</span>
227 
228 const char* SharedBuffer::DataSegment::data() const
229 {
230     auto visitor = WTF::makeVisitor(
231         [](const Vector&lt;char&gt;&amp; data) { return data.data(); },
232 #if USE(CF)
233         [](const RetainPtr&lt;CFDataRef&gt;&amp; data) { return reinterpret_cast&lt;const char*&gt;(CFDataGetBytePtr(data.get())); },
234 #endif
235 #if USE(SOUP)
236         [](const GUniquePtr&lt;SoupBuffer&gt;&amp; data) { return data-&gt;data; },
237 #endif
238 #if USE(GLIB)
239         [](const GRefPtr&lt;GBytes&gt;&amp; data) { return reinterpret_cast&lt;const char*&gt;(g_bytes_get_data(data.get(), nullptr)); },
240 #endif
241 #if USE(GSTREAMER)
242         [](const RefPtr&lt;GstMappedBuffer&gt;&amp; data) { return reinterpret_cast&lt;const char*&gt;(data-&gt;data()); },
243 #endif
244         [](const FileSystem::MappedFileData&amp; data) { return reinterpret_cast&lt;const char*&gt;(data.data()); }
245     );
246     return WTF::visit(visitor, m_immutableData);
247 }
248 
249 #if !USE(CF)
250 void SharedBuffer::hintMemoryNotNeededSoon() const
251 {
252 }
253 #endif
254 
<span class="line-added">255 WTF::Persistence::Decoder SharedBuffer::decoder() const</span>
<span class="line-added">256 {</span>
<span class="line-added">257     return { reinterpret_cast&lt;const uint8_t*&gt;(data()), size() };</span>
<span class="line-added">258 }</span>
<span class="line-added">259 </span>
260 bool SharedBuffer::operator==(const SharedBuffer&amp; other) const
261 {
262     if (this == &amp;other)
263         return true;
264 
265     if (m_size != other.m_size)
266         return false;
267 
268     auto thisIterator = begin();
269     size_t thisOffset = 0;
270     auto otherIterator = other.begin();
271     size_t otherOffset = 0;
272 
273     while (thisIterator != end() &amp;&amp; otherIterator != other.end()) {
274         auto&amp; thisSegment = thisIterator-&gt;segment.get();
275         auto&amp; otherSegment = otherIterator-&gt;segment.get();
276 
277         if (&amp;thisSegment == &amp;otherSegment &amp;&amp; !thisOffset &amp;&amp; !otherOffset) {
278             ++thisIterator;
279             ++otherIterator;
</pre>
</td>
</tr>
</table>
<center><a href="SerializedPlatformRepresentation.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SharedBuffer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmFunctionParser.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmFormat.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmInstance.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmFunctionParser.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2016-2017 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(WEBASSEMBLY)
  29 
  30 #include &quot;WasmParser.h&quot;
  31 #include &quot;WasmSignatureInlines.h&quot;
  32 #include &lt;wtf/DataLog.h&gt;
  33 
  34 namespace JSC { namespace Wasm {
  35 
  36 enum class BlockType {
  37     If,
  38     Block,
  39     Loop,
  40     TopLevel
  41 };
  42 











  43 template&lt;typename Context&gt;
  44 class FunctionParser : public Parser&lt;void&gt; {
  45 public:
<span class="line-modified">  46     using ExpressionType = typename Context::ExpressionType;</span>

  47     using ControlType = typename Context::ControlType;
<span class="line-modified">  48     using ExpressionList = typename Context::ExpressionList;</span>
<span class="line-removed">  49     using Stack = typename Context::Stack;</span>
  50 
<span class="line-modified">  51     FunctionParser(Context&amp;, const uint8_t* functionStart, size_t functionLength, const Signature&amp;, const ModuleInformation&amp;);</span>


  52 
<span class="line-modified">  53     Result WARN_UNUSED_RETURN parse();</span>




















  54 
  55     struct ControlEntry {
  56         Stack enclosedExpressionStack;

  57         ControlType controlData;
  58     };
  59 




  60     OpType currentOpcode() const { return m_currentOpcode; }
  61     size_t currentOpcodeStartingOffset() const { return m_currentOpcodeStartingOffset; }




  62 
  63 private:
<span class="line-modified">  64     static const bool verbose = false;</span>
  65 
  66     PartialResult WARN_UNUSED_RETURN parseBody();
  67     PartialResult WARN_UNUSED_RETURN parseExpression();
  68     PartialResult WARN_UNUSED_RETURN parseUnreachableExpression();
  69     PartialResult WARN_UNUSED_RETURN unifyControl(Vector&lt;ExpressionType&gt;&amp;, unsigned level);


  70 
  71 #define WASM_TRY_POP_EXPRESSION_STACK_INTO(result, what) do {                               \
  72         WASM_PARSER_FAIL_IF(m_expressionStack.isEmpty(), &quot;can&#39;t pop empty stack in &quot; what); \
  73         result = m_expressionStack.takeLast();                                              \
<span class="line-modified">  74         m_toKillAfterExpression.append(result);                                             \</span>
  75     } while (0)
  76 
  77     template&lt;OpType&gt;
<span class="line-modified">  78     PartialResult WARN_UNUSED_RETURN unaryCase();</span>
  79 
  80     template&lt;OpType&gt;
<span class="line-modified">  81     PartialResult WARN_UNUSED_RETURN binaryCase();</span>



  82 
  83 #define WASM_TRY_ADD_TO_CONTEXT(add_expression) WASM_FAIL_IF_HELPER_FAILS(m_context.add_expression)
  84 

















  85     // FIXME add a macro as above for WASM_TRY_APPEND_TO_CONTROL_STACK https://bugs.webkit.org/show_bug.cgi?id=165862
  86 
  87     Context&amp; m_context;
  88     Stack m_expressionStack;
<span class="line-modified">  89     Vector&lt;ControlEntry&gt; m_controlStack;</span>

  90     const Signature&amp; m_signature;
  91     const ModuleInformation&amp; m_info;
  92 
  93     OpType m_currentOpcode;
  94     size_t m_currentOpcodeStartingOffset { 0 };
  95 
<span class="line-removed">  96     Vector&lt;ExpressionType, 8&gt; m_toKillAfterExpression;</span>
<span class="line-removed">  97 </span>
  98     unsigned m_unreachableBlocks { 0 };
  99     unsigned m_loopIndex { 0 };
 100 };
 101 
 102 template&lt;typename Context&gt;
 103 FunctionParser&lt;Context&gt;::FunctionParser(Context&amp; context, const uint8_t* functionStart, size_t functionLength, const Signature&amp; signature, const ModuleInformation&amp; info)
 104     : Parser(functionStart, functionLength)
 105     , m_context(context)
<span class="line-removed"> 106     , m_expressionStack(context.createStack())</span>
 107     , m_signature(signature)
 108     , m_info(info)
 109 {
 110     if (verbose)
 111         dataLogLn(&quot;Parsing function starting at: &quot;, (uintptr_t)functionStart, &quot; of length: &quot;, functionLength, &quot; with signature: &quot;, signature);
 112     m_context.setParser(this);
 113 }
 114 
 115 template&lt;typename Context&gt;
 116 auto FunctionParser&lt;Context&gt;::parse() -&gt; Result
 117 {
 118     uint32_t localGroupsCount;
 119 
 120     WASM_PARSER_FAIL_IF(!m_context.addArguments(m_signature), &quot;can&#39;t add &quot;, m_signature.argumentCount(), &quot; arguments to Function&quot;);
 121     WASM_PARSER_FAIL_IF(!parseVarUInt32(localGroupsCount), &quot;can&#39;t get local groups count&quot;);
 122 




 123     uint64_t totalNumberOfLocals = m_signature.argumentCount();
 124     for (uint32_t i = 0; i &lt; localGroupsCount; ++i) {
 125         uint32_t numberOfLocals;
 126         Type typeOfLocal;
 127 
 128         WASM_PARSER_FAIL_IF(!parseVarUInt32(numberOfLocals), &quot;can&#39;t get Function&#39;s number of locals in group &quot;, i);
 129         totalNumberOfLocals += numberOfLocals;
 130         WASM_PARSER_FAIL_IF(totalNumberOfLocals &gt; maxFunctionLocals, &quot;Function&#39;s number of locals is too big &quot;, totalNumberOfLocals, &quot; maximum &quot;, maxFunctionLocals);
 131         WASM_PARSER_FAIL_IF(!parseValueType(typeOfLocal), &quot;can&#39;t get Function local&#39;s type in group &quot;, i);





 132         WASM_TRY_ADD_TO_CONTEXT(addLocal(typeOfLocal, numberOfLocals));
 133     }
 134 


 135     WASM_FAIL_IF_HELPER_FAILS(parseBody());
 136 
 137     return { };
 138 }
 139 
 140 template&lt;typename Context&gt;
 141 auto FunctionParser&lt;Context&gt;::parseBody() -&gt; PartialResult
 142 {
<span class="line-modified"> 143     m_controlStack.append({ m_context.createStack(), m_context.addTopLevel(m_signature.returnType()) });</span>
<span class="line-modified"> 144     uint8_t op;</span>
 145     while (m_controlStack.size()) {
<span class="line-removed"> 146         ASSERT(m_toKillAfterExpression.isEmpty());</span>
<span class="line-removed"> 147 </span>
 148         m_currentOpcodeStartingOffset = m_offset;
 149         WASM_PARSER_FAIL_IF(!parseUInt8(op), &quot;can&#39;t decode opcode&quot;);
 150         WASM_PARSER_FAIL_IF(!isValidOpType(op), &quot;invalid opcode &quot;, op);
 151 
 152         m_currentOpcode = static_cast&lt;OpType&gt;(op);
 153 
 154         if (verbose) {
 155             dataLogLn(&quot;processing op (&quot;, m_unreachableBlocks, &quot;): &quot;,  RawPointer(reinterpret_cast&lt;void*&gt;(op)), &quot;, &quot;, makeString(static_cast&lt;OpType&gt;(op)), &quot; at offset: &quot;, RawPointer(reinterpret_cast&lt;void*&gt;(m_offset)));
 156             m_context.dump(m_controlStack, &amp;m_expressionStack);
 157         }
 158 
 159         if (m_unreachableBlocks)
 160             WASM_FAIL_IF_HELPER_FAILS(parseUnreachableExpression());
 161         else {
 162             WASM_FAIL_IF_HELPER_FAILS(parseExpression());
<span class="line-removed"> 163             while (m_toKillAfterExpression.size())</span>
<span class="line-removed"> 164                 m_context.didKill(m_toKillAfterExpression.takeLast());</span>
 165         }
 166     }

 167 
 168     ASSERT(op == OpType::End);
 169     return { };
 170 }
 171 
 172 template&lt;typename Context&gt;
 173 template&lt;OpType op&gt;
<span class="line-modified"> 174 auto FunctionParser&lt;Context&gt;::binaryCase() -&gt; PartialResult</span>
 175 {
<span class="line-modified"> 176     ExpressionType right;</span>
<span class="line-modified"> 177     ExpressionType left;</span>
<span class="line-removed"> 178     ExpressionType result;</span>
 179 
 180     WASM_TRY_POP_EXPRESSION_STACK_INTO(right, &quot;binary right&quot;);
 181     WASM_TRY_POP_EXPRESSION_STACK_INTO(left, &quot;binary left&quot;);
<span class="line-removed"> 182     WASM_TRY_ADD_TO_CONTEXT(template addOp&lt;op&gt;(left, right, result));</span>
 183 
<span class="line-modified"> 184     m_expressionStack.append(result);</span>





 185     return { };
 186 }
 187 
 188 template&lt;typename Context&gt;
 189 template&lt;OpType op&gt;
<span class="line-modified"> 190 auto FunctionParser&lt;Context&gt;::unaryCase() -&gt; PartialResult</span>
 191 {
<span class="line-modified"> 192     ExpressionType value;</span>
<span class="line-removed"> 193     ExpressionType result;</span>
<span class="line-removed"> 194 </span>
 195     WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;unary&quot;);




 196     WASM_TRY_ADD_TO_CONTEXT(template addOp&lt;op&gt;(value, result));





































































 197 
<span class="line-removed"> 198     m_expressionStack.append(result);</span>
 199     return { };
 200 }
 201 
 202 template&lt;typename Context&gt;
 203 auto FunctionParser&lt;Context&gt;::parseExpression() -&gt; PartialResult
 204 {
 205     switch (m_currentOpcode) {
<span class="line-modified"> 206 #define CREATE_CASE(name, id, b3op, inc) case OpType::name: return binaryCase&lt;OpType::name&gt;();</span>
 207     FOR_EACH_WASM_BINARY_OP(CREATE_CASE)
 208 #undef CREATE_CASE
 209 
<span class="line-modified"> 210 #define CREATE_CASE(name, id, b3op, inc) case OpType::name: return unaryCase&lt;OpType::name&gt;();</span>
 211     FOR_EACH_WASM_UNARY_OP(CREATE_CASE)
 212 #undef CREATE_CASE
 213 
 214     case Select: {
<span class="line-modified"> 215         ExpressionType condition;</span>
<span class="line-modified"> 216         ExpressionType zero;</span>
<span class="line-modified"> 217         ExpressionType nonZero;</span>
 218 
 219         WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;select condition&quot;);
 220         WASM_TRY_POP_EXPRESSION_STACK_INTO(zero, &quot;select zero&quot;);
 221         WASM_TRY_POP_EXPRESSION_STACK_INTO(nonZero, &quot;select non-zero&quot;);
 222 



 223         ExpressionType result;
 224         WASM_TRY_ADD_TO_CONTEXT(addSelect(condition, nonZero, zero, result));
 225 
<span class="line-modified"> 226         m_expressionStack.append(result);</span>
 227         return { };
 228     }
 229 
<span class="line-modified"> 230 #define CREATE_CASE(name, id, b3op, inc) case OpType::name:</span>
<span class="line-modified"> 231     FOR_EACH_WASM_MEMORY_LOAD_OP(CREATE_CASE) {</span>
<span class="line-modified"> 232         uint32_t alignment;</span>
<span class="line-removed"> 233         uint32_t offset;</span>
<span class="line-removed"> 234         ExpressionType pointer;</span>
<span class="line-removed"> 235         ExpressionType result;</span>
<span class="line-removed"> 236         WASM_PARSER_FAIL_IF(!parseVarUInt32(alignment), &quot;can&#39;t get load alignment&quot;);</span>
<span class="line-removed"> 237         WASM_PARSER_FAIL_IF(alignment &gt; memoryLog2Alignment(m_currentOpcode), &quot;byte alignment &quot;, 1ull &lt;&lt; alignment, &quot; exceeds load&#39;s natural alignment &quot;, 1ull &lt;&lt; memoryLog2Alignment(m_currentOpcode));</span>
<span class="line-removed"> 238         WASM_PARSER_FAIL_IF(!parseVarUInt32(offset), &quot;can&#39;t get load offset&quot;);</span>
<span class="line-removed"> 239         WASM_TRY_POP_EXPRESSION_STACK_INTO(pointer, &quot;load pointer&quot;);</span>
<span class="line-removed"> 240         WASM_TRY_ADD_TO_CONTEXT(load(static_cast&lt;LoadOpType&gt;(m_currentOpcode), pointer, result, offset));</span>
<span class="line-removed"> 241         m_expressionStack.append(result);</span>
<span class="line-removed"> 242         return { };</span>
<span class="line-removed"> 243     }</span>
 244 
<span class="line-modified"> 245     FOR_EACH_WASM_MEMORY_STORE_OP(CREATE_CASE) {</span>
<span class="line-modified"> 246         uint32_t alignment;</span>
<span class="line-removed"> 247         uint32_t offset;</span>
<span class="line-removed"> 248         ExpressionType value;</span>
<span class="line-removed"> 249         ExpressionType pointer;</span>
<span class="line-removed"> 250         WASM_PARSER_FAIL_IF(!parseVarUInt32(alignment), &quot;can&#39;t get store alignment&quot;);</span>
<span class="line-removed"> 251         WASM_PARSER_FAIL_IF(alignment &gt; memoryLog2Alignment(m_currentOpcode), &quot;byte alignment &quot;, 1ull &lt;&lt; alignment, &quot; exceeds store&#39;s natural alignment &quot;, 1ull &lt;&lt; memoryLog2Alignment(m_currentOpcode));</span>
<span class="line-removed"> 252         WASM_PARSER_FAIL_IF(!parseVarUInt32(offset), &quot;can&#39;t get store offset&quot;);</span>
<span class="line-removed"> 253         WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;store value&quot;);</span>
<span class="line-removed"> 254         WASM_TRY_POP_EXPRESSION_STACK_INTO(pointer, &quot;store pointer&quot;);</span>
<span class="line-removed"> 255         WASM_TRY_ADD_TO_CONTEXT(store(static_cast&lt;StoreOpType&gt;(m_currentOpcode), pointer, value, offset));</span>
<span class="line-removed"> 256         return { };</span>
<span class="line-removed"> 257     }</span>
 258 #undef CREATE_CASE
 259 
 260     case F32Const: {
 261         uint32_t constant;
 262         WASM_PARSER_FAIL_IF(!parseUInt32(constant), &quot;can&#39;t parse 32-bit floating-point constant&quot;);
<span class="line-modified"> 263         m_expressionStack.append(m_context.addConstant(F32, constant));</span>
 264         return { };
 265     }
 266 
 267     case I32Const: {
 268         int32_t constant;
 269         WASM_PARSER_FAIL_IF(!parseVarInt32(constant), &quot;can&#39;t parse 32-bit constant&quot;);
<span class="line-modified"> 270         m_expressionStack.append(m_context.addConstant(I32, constant));</span>
 271         return { };
 272     }
 273 
 274     case F64Const: {
 275         uint64_t constant;
 276         WASM_PARSER_FAIL_IF(!parseUInt64(constant), &quot;can&#39;t parse 64-bit floating-point constant&quot;);
<span class="line-modified"> 277         m_expressionStack.append(m_context.addConstant(F64, constant));</span>
 278         return { };
 279     }
 280 
 281     case I64Const: {
 282         int64_t constant;
 283         WASM_PARSER_FAIL_IF(!parseVarInt64(constant), &quot;can&#39;t parse 64-bit constant&quot;);
<span class="line-modified"> 284         m_expressionStack.append(m_context.addConstant(I64, constant));</span>
 285         return { };
 286     }
 287 
 288     case TableGet: {
 289         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
 290         unsigned tableIndex;
 291         WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t parse table index&quot;);
<span class="line-modified"> 292         ExpressionType result, index;</span>


 293         WASM_TRY_POP_EXPRESSION_STACK_INTO(index, &quot;table.get&quot;);



 294         WASM_TRY_ADD_TO_CONTEXT(addTableGet(tableIndex, index, result));
<span class="line-modified"> 295         m_expressionStack.append(result);</span>

 296         return { };
 297     }
 298 
 299     case TableSet: {
 300         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
 301         unsigned tableIndex;
 302         WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t parse table index&quot;);
<span class="line-modified"> 303         ExpressionType val, index;</span>
<span class="line-modified"> 304         WASM_TRY_POP_EXPRESSION_STACK_INTO(val, &quot;table.set&quot;);</span>

 305         WASM_TRY_POP_EXPRESSION_STACK_INTO(index, &quot;table.set&quot;);
<span class="line-modified"> 306         WASM_TRY_ADD_TO_CONTEXT(addTableSet(tableIndex, index, val));</span>




 307         return { };
 308     }
 309 
 310     case ExtTable: {
 311         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
 312         uint8_t extOp;
 313         WASM_PARSER_FAIL_IF(!parseUInt8(extOp), &quot;can&#39;t parse table extended opcode&quot;);
 314         unsigned tableIndex;
 315         WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t parse table index&quot;);

 316 
 317         switch (static_cast&lt;ExtTableOpType&gt;(extOp)) {
 318         case ExtTableOpType::TableSize: {
 319             ExpressionType result;
 320             WASM_TRY_ADD_TO_CONTEXT(addTableSize(tableIndex, result));
<span class="line-modified"> 321             m_expressionStack.append(result);</span>
 322             break;
 323         }
 324         case ExtTableOpType::TableGrow: {
<span class="line-modified"> 325             ExpressionType fill, delta, result;</span>

 326             WASM_TRY_POP_EXPRESSION_STACK_INTO(delta, &quot;table.grow&quot;);
 327             WASM_TRY_POP_EXPRESSION_STACK_INTO(fill, &quot;table.grow&quot;);





 328             WASM_TRY_ADD_TO_CONTEXT(addTableGrow(tableIndex, fill, delta, result));
<span class="line-modified"> 329             m_expressionStack.append(result);</span>
 330             break;
 331         }
 332         case ExtTableOpType::TableFill: {
<span class="line-modified"> 333             ExpressionType offset, fill, count;</span>
 334             WASM_TRY_POP_EXPRESSION_STACK_INTO(count, &quot;table.fill&quot;);
 335             WASM_TRY_POP_EXPRESSION_STACK_INTO(fill, &quot;table.fill&quot;);
 336             WASM_TRY_POP_EXPRESSION_STACK_INTO(offset, &quot;table.fill&quot;);





 337             WASM_TRY_ADD_TO_CONTEXT(addTableFill(tableIndex, offset, fill, count));
 338             break;
 339         }
 340         default:
 341             WASM_PARSER_FAIL_IF(true, &quot;invalid extended table op &quot;, extOp);
 342             break;
 343         }
 344         return { };
 345     }
 346 
 347     case RefNull: {
 348         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
<span class="line-modified"> 349         m_expressionStack.append(m_context.addConstant(Funcref, JSValue::encode(jsNull())));</span>
 350         return { };
 351     }
 352 
 353     case RefIsNull: {
 354         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
<span class="line-modified"> 355         ExpressionType result, value;</span>
 356         WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;ref.is_null&quot;);


 357         WASM_TRY_ADD_TO_CONTEXT(addRefIsNull(value, result));
<span class="line-modified"> 358         m_expressionStack.append(result);</span>
 359         return { };
 360     }
 361 
 362     case RefFunc: {
 363         uint32_t index;
 364         ExpressionType result;
 365         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
 366         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for ref.func&quot;);
 367 


 368         WASM_TRY_ADD_TO_CONTEXT(addRefFunc(index, result));
<span class="line-modified"> 369         m_expressionStack.append(result);</span>
 370         return { };
 371     }
 372 
 373     case GetLocal: {
 374         uint32_t index;
 375         ExpressionType result;
 376         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for get_local&quot;);

 377         WASM_TRY_ADD_TO_CONTEXT(getLocal(index, result));
<span class="line-modified"> 378         m_expressionStack.append(result);</span>
 379         return { };
 380     }
 381 
 382     case SetLocal: {
 383         uint32_t index;
<span class="line-modified"> 384         ExpressionType value;</span>
 385         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for set_local&quot;);
 386         WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;set_local&quot;);


 387         WASM_TRY_ADD_TO_CONTEXT(setLocal(index, value));
 388         return { };
 389     }
 390 
 391     case TeeLocal: {
 392         uint32_t index;
 393         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for tee_local&quot;);
 394         WASM_PARSER_FAIL_IF(m_expressionStack.isEmpty(), &quot;can&#39;t tee_local on empty expression stack&quot;);
<span class="line-modified"> 395         WASM_TRY_ADD_TO_CONTEXT(setLocal(index, m_expressionStack.last()));</span>



 396         return { };
 397     }
 398 
 399     case GetGlobal: {
 400         uint32_t index;
 401         ExpressionType result;
 402         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get get_global&#39;s index&quot;);



 403         WASM_TRY_ADD_TO_CONTEXT(getGlobal(index, result));
<span class="line-modified"> 404         m_expressionStack.append(result);</span>
 405         return { };
 406     }
 407 
 408     case SetGlobal: {
 409         uint32_t index;
<span class="line-modified"> 410         ExpressionType value;</span>
 411         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get set_global&#39;s index&quot;);
 412         WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;set_global value&quot;);








 413         WASM_TRY_ADD_TO_CONTEXT(setGlobal(index, value));
 414         return { };
 415     }
 416 
 417     case Call: {
 418         uint32_t functionIndex;
 419         WASM_PARSER_FAIL_IF(!parseVarUInt32(functionIndex), &quot;can&#39;t parse call&#39;s function index&quot;);
 420         WASM_PARSER_FAIL_IF(functionIndex &gt;= m_info.functionIndexSpaceSize(), &quot;call function index &quot;, functionIndex, &quot; exceeds function index space &quot;, m_info.functionIndexSpaceSize());
 421 
 422         SignatureIndex calleeSignatureIndex = m_info.signatureIndexFromFunctionIndexSpace(functionIndex);
 423         const Signature&amp; calleeSignature = SignatureInformation::get(calleeSignatureIndex);
 424         WASM_PARSER_FAIL_IF(calleeSignature.argumentCount() &gt; m_expressionStack.size(), &quot;call function index &quot;, functionIndex, &quot; has &quot;, calleeSignature.argumentCount(), &quot; arguments, but the expression stack currently holds &quot;, m_expressionStack.size(), &quot; values&quot;);
 425 
 426         size_t firstArgumentIndex = m_expressionStack.size() - calleeSignature.argumentCount();
 427         Vector&lt;ExpressionType&gt; args;
 428         WASM_PARSER_FAIL_IF(!args.tryReserveCapacity(calleeSignature.argumentCount()), &quot;can&#39;t allocate enough memory for call&#39;s &quot;, calleeSignature.argumentCount(), &quot; arguments&quot;);
<span class="line-modified"> 429         for (size_t i = firstArgumentIndex; i &lt; m_expressionStack.size(); ++i)</span>
<span class="line-modified"> 430             args.uncheckedAppend(m_expressionStack.at(i));</span>




 431         m_expressionStack.shrink(firstArgumentIndex);
 432 
<span class="line-modified"> 433         ExpressionType result = Context::emptyExpression();</span>
<span class="line-modified"> 434         WASM_TRY_ADD_TO_CONTEXT(addCall(functionIndex, calleeSignature, args, result));</span>


 435 
<span class="line-modified"> 436         if (result != Context::emptyExpression())</span>
<span class="line-modified"> 437             m_expressionStack.append(result);</span>


 438 
 439         return { };
 440     }
 441 
 442     case CallIndirect: {
 443         uint32_t signatureIndex;
 444         uint32_t tableIndex;
 445         WASM_PARSER_FAIL_IF(!m_info.tableCount(), &quot;call_indirect is only valid when a table is defined or imported&quot;);
 446         WASM_PARSER_FAIL_IF(!parseVarUInt32(signatureIndex), &quot;can&#39;t get call_indirect&#39;s signature index&quot;);
 447         WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t get call_indirect&#39;s table index&quot;);
 448         WASM_PARSER_FAIL_IF(tableIndex &gt;= m_info.tableCount(), &quot;call_indirect&#39;s table index &quot;, tableIndex, &quot; invalid, limit is &quot;, m_info.tableCount());
 449         WASM_PARSER_FAIL_IF(m_info.usedSignatures.size() &lt;= signatureIndex, &quot;call_indirect&#39;s signature index &quot;, signatureIndex, &quot; exceeds known signatures &quot;, m_info.usedSignatures.size());
 450         WASM_PARSER_FAIL_IF(m_info.tables[tableIndex].type() != TableElementType::Funcref, &quot;call_indirect is only valid when a table has type funcref&quot;);
 451 
 452         const Signature&amp; calleeSignature = m_info.usedSignatures[signatureIndex].get();
 453         size_t argumentCount = calleeSignature.argumentCount() + 1; // Add the callee&#39;s index.
 454         WASM_PARSER_FAIL_IF(argumentCount &gt; m_expressionStack.size(), &quot;call_indirect expects &quot;, argumentCount, &quot; arguments, but the expression stack currently holds &quot;, m_expressionStack.size(), &quot; values&quot;);
 455 


 456         Vector&lt;ExpressionType&gt; args;
 457         WASM_PARSER_FAIL_IF(!args.tryReserveCapacity(argumentCount), &quot;can&#39;t allocate enough memory for &quot;, argumentCount, &quot; call_indirect arguments&quot;);
 458         size_t firstArgumentIndex = m_expressionStack.size() - argumentCount;
<span class="line-modified"> 459         for (size_t i = firstArgumentIndex; i &lt; m_expressionStack.size(); ++i)</span>
<span class="line-modified"> 460             args.uncheckedAppend(m_expressionStack.at(i));</span>





 461         m_expressionStack.shrink(firstArgumentIndex);
 462 
<span class="line-removed"> 463         ExpressionType result = Context::emptyExpression();</span>
<span class="line-removed"> 464         WASM_TRY_ADD_TO_CONTEXT(addCallIndirect(tableIndex, calleeSignature, args, result));</span>
 465 
<span class="line-modified"> 466         if (result != Context::emptyExpression())</span>
<span class="line-modified"> 467             m_expressionStack.append(result);</span>




 468 
 469         return { };
 470     }
 471 
 472     case Block: {
<span class="line-modified"> 473         Type inlineSignature;</span>
<span class="line-modified"> 474         WASM_PARSER_FAIL_IF(!parseResultType(inlineSignature), &quot;can&#39;t get block&#39;s inline signature&quot;);</span>
<span class="line-modified"> 475         m_controlStack.append({ WTFMove(m_expressionStack), m_context.addBlock(inlineSignature) });</span>
<span class="line-modified"> 476         m_expressionStack = m_context.createStack();</span>















 477         return { };
 478     }
 479 
 480     case Loop: {
<span class="line-modified"> 481         Type inlineSignature;</span>
<span class="line-modified"> 482         WASM_PARSER_FAIL_IF(!parseResultType(inlineSignature), &quot;can&#39;t get loop&#39;s inline signature&quot;);</span>
<span class="line-modified"> 483         auto expressionStack = WTFMove(m_expressionStack);</span>
<span class="line-modified"> 484         auto loop = m_context.addLoop(inlineSignature, expressionStack, m_loopIndex++);</span>
<span class="line-modified"> 485         m_controlStack.append({ expressionStack, loop });</span>
<span class="line-modified"> 486         m_expressionStack = m_context.createStack();</span>













 487         return { };
 488     }
 489 
 490     case If: {
<span class="line-modified"> 491         Type inlineSignature;</span>
<span class="line-modified"> 492         ExpressionType condition;</span>
<span class="line-modified"> 493         ControlType control;</span>
<span class="line-removed"> 494         WASM_PARSER_FAIL_IF(!parseResultType(inlineSignature), &quot;can&#39;t get if&#39;s inline signature&quot;);</span>
 495         WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;if condition&quot;);
<span class="line-modified"> 496         WASM_TRY_ADD_TO_CONTEXT(addIf(condition, inlineSignature, control));</span>
<span class="line-modified"> 497         m_controlStack.append({ WTFMove(m_expressionStack), control });</span>
<span class="line-modified"> 498         m_expressionStack = m_context.createStack();</span>













 499         return { };
 500     }
 501 
 502     case Else: {
 503         WASM_PARSER_FAIL_IF(m_controlStack.size() == 1, &quot;can&#39;t use else block at the top-level of a function&quot;);
<span class="line-modified"> 504         WASM_TRY_ADD_TO_CONTEXT(addElse(m_controlStack.last().controlData, m_expressionStack));</span>
<span class="line-modified"> 505         m_expressionStack.shrink(0);</span>





 506         return { };
 507     }
 508 
 509     case Br:
 510     case BrIf: {
 511         uint32_t target;
<span class="line-modified"> 512         ExpressionType condition = Context::emptyExpression();</span>
 513         WASM_PARSER_FAIL_IF(!parseVarUInt32(target), &quot;can&#39;t get br / br_if&#39;s target&quot;);
 514         WASM_PARSER_FAIL_IF(target &gt;= m_controlStack.size(), &quot;br / br_if&#39;s target &quot;, target, &quot; exceeds control stack size &quot;, m_controlStack.size());
<span class="line-modified"> 515         if (m_currentOpcode == BrIf)</span>
 516             WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;br / br_if condition&quot;);
<span class="line-modified"> 517         else</span>

 518             m_unreachableBlocks = 1;


 519 
 520         ControlType&amp; data = m_controlStack[m_controlStack.size() - 1 - target].controlData;
<span class="line-modified"> 521 </span>
 522         WASM_TRY_ADD_TO_CONTEXT(addBranch(data, condition, m_expressionStack));
 523         return { };
 524     }
 525 
 526     case BrTable: {
 527         uint32_t numberOfTargets;
<span class="line-modified"> 528         uint32_t defaultTarget;</span>
<span class="line-modified"> 529         ExpressionType condition;</span>
 530         Vector&lt;ControlType*&gt; targets;
 531 
 532         WASM_PARSER_FAIL_IF(!parseVarUInt32(numberOfTargets), &quot;can&#39;t get the number of targets for br_table&quot;);
 533         WASM_PARSER_FAIL_IF(numberOfTargets == std::numeric_limits&lt;uint32_t&gt;::max(), &quot;br_table&#39;s number of targets is too big &quot;, numberOfTargets);
 534 
 535         WASM_PARSER_FAIL_IF(!targets.tryReserveCapacity(numberOfTargets), &quot;can&#39;t allocate memory for &quot;, numberOfTargets, &quot; br_table targets&quot;);
 536         for (uint32_t i = 0; i &lt; numberOfTargets; ++i) {
 537             uint32_t target;
 538             WASM_PARSER_FAIL_IF(!parseVarUInt32(target), &quot;can&#39;t get &quot;, i, &quot;th target for br_table&quot;);
 539             WASM_PARSER_FAIL_IF(target &gt;= m_controlStack.size(), &quot;br_table&#39;s &quot;, i, &quot;th target &quot;, target, &quot; exceeds control stack size &quot;, m_controlStack.size());
 540             targets.uncheckedAppend(&amp;m_controlStack[m_controlStack.size() - 1 - target].controlData);
 541         }
 542 
<span class="line-modified"> 543         WASM_PARSER_FAIL_IF(!parseVarUInt32(defaultTarget), &quot;can&#39;t get default target for br_table&quot;);</span>
<span class="line-modified"> 544         WASM_PARSER_FAIL_IF(defaultTarget &gt;= m_controlStack.size(), &quot;br_table&#39;s default target &quot;, defaultTarget, &quot; exceeds control stack size &quot;, m_controlStack.size());</span>

 545 
 546         WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;br_table condition&quot;);
<span class="line-modified"> 547         WASM_TRY_ADD_TO_CONTEXT(addSwitch(condition, targets, m_controlStack[m_controlStack.size() - 1 - defaultTarget].controlData, m_expressionStack));</span>










 548 
 549         m_unreachableBlocks = 1;
 550         return { };
 551     }
 552 
 553     case Return: {
<span class="line-modified"> 554         ExpressionList returnValues;</span>
<span class="line-modified"> 555         if (m_signature.returnType() != Void) {</span>
<span class="line-removed"> 556             ExpressionType returnValue;</span>
<span class="line-removed"> 557             WASM_TRY_POP_EXPRESSION_STACK_INTO(returnValue, &quot;return&quot;);</span>
<span class="line-removed"> 558             returnValues.append(returnValue);</span>
<span class="line-removed"> 559         }</span>
<span class="line-removed"> 560 </span>
<span class="line-removed"> 561         WASM_TRY_ADD_TO_CONTEXT(addReturn(m_controlStack[0].controlData, returnValues));</span>
 562         m_unreachableBlocks = 1;
 563         return { };
 564     }
 565 
 566     case End: {
 567         ControlEntry data = m_controlStack.takeLast();





 568         // FIXME: This is a little weird in that it will modify the expressionStack for the result of the block.
 569         // That&#39;s a little too effectful for me but I don&#39;t have a better API right now.
 570         // see: https://bugs.webkit.org/show_bug.cgi?id=164353

 571         WASM_TRY_ADD_TO_CONTEXT(endBlock(data, m_expressionStack));
 572         m_expressionStack.swap(data.enclosedExpressionStack);
 573         return { };
 574     }
 575 
 576     case Unreachable: {
 577         WASM_TRY_ADD_TO_CONTEXT(addUnreachable());
 578         m_unreachableBlocks = 1;
 579         return { };
 580     }
 581 
 582     case Drop: {
 583         WASM_PARSER_FAIL_IF(!m_expressionStack.size(), &quot;can&#39;t drop on empty stack&quot;);
<span class="line-modified"> 584         auto expression = m_expressionStack.takeLast();</span>
<span class="line-modified"> 585         m_toKillAfterExpression.append(expression);</span>
 586         return { };
 587     }
 588 
 589     case Nop: {
 590         return { };
 591     }
 592 
 593     case GrowMemory: {
 594         WASM_PARSER_FAIL_IF(!m_info.memory, &quot;grow_memory is only valid if a memory is defined or imported&quot;);
 595 
 596         uint8_t reserved;
 597         WASM_PARSER_FAIL_IF(!parseVarUInt1(reserved), &quot;can&#39;t parse reserved varUint1 for grow_memory&quot;);
 598         WASM_PARSER_FAIL_IF(reserved != 0, &quot;reserved varUint1 for grow_memory must be zero&quot;);
 599 
<span class="line-modified"> 600         ExpressionType delta;</span>
 601         WASM_TRY_POP_EXPRESSION_STACK_INTO(delta, &quot;expect an i32 argument to grow_memory on the stack&quot;);

 602 
 603         ExpressionType result;
 604         WASM_TRY_ADD_TO_CONTEXT(addGrowMemory(delta, result));
<span class="line-modified"> 605         m_expressionStack.append(result);</span>
 606 
 607         return { };
 608     }
 609 
 610     case CurrentMemory: {
 611         WASM_PARSER_FAIL_IF(!m_info.memory, &quot;current_memory is only valid if a memory is defined or imported&quot;);
 612 
 613         uint8_t reserved;
 614         WASM_PARSER_FAIL_IF(!parseVarUInt1(reserved), &quot;can&#39;t parse reserved varUint1 for current_memory&quot;);
 615         WASM_PARSER_FAIL_IF(reserved != 0, &quot;reserved varUint1 for current_memory must be zero&quot;);
 616 
 617         ExpressionType result;
 618         WASM_TRY_ADD_TO_CONTEXT(addCurrentMemory(result));
<span class="line-modified"> 619         m_expressionStack.append(result);</span>
 620 
 621         return { };
 622     }
 623     }
 624 
 625     ASSERT_NOT_REACHED();
 626     return { };
 627 }
 628 
 629 // FIXME: We should try to use the same decoder function for both unreachable and reachable code. https://bugs.webkit.org/show_bug.cgi?id=165965
 630 template&lt;typename Context&gt;
 631 auto FunctionParser&lt;Context&gt;::parseUnreachableExpression() -&gt; PartialResult
 632 {
 633     ASSERT(m_unreachableBlocks);
<span class="line-modified"> 634 #define CREATE_CASE(name, id, b3op, inc) case OpType::name:</span>
 635     switch (m_currentOpcode) {
 636     case Else: {
 637         if (m_unreachableBlocks &gt; 1)
 638             return { };
 639 
 640         ControlEntry&amp; data = m_controlStack.last();
 641         m_unreachableBlocks = 0;

 642         WASM_TRY_ADD_TO_CONTEXT(addElseToUnreachable(data.controlData));
<span class="line-modified"> 643         m_expressionStack.shrink(0);</span>
 644         return { };
 645     }
 646 
 647     case End: {
 648         if (m_unreachableBlocks == 1) {
 649             ControlEntry data = m_controlStack.takeLast();
<span class="line-modified"> 650             WASM_TRY_ADD_TO_CONTEXT(addEndToUnreachable(data));</span>







 651             m_expressionStack.swap(data.enclosedExpressionStack);
 652         }
 653         m_unreachableBlocks--;
 654         return { };
 655     }
 656 
 657     case Loop:
 658     case If:
 659     case Block: {
 660         m_unreachableBlocks++;
<span class="line-modified"> 661         Type unused;</span>
<span class="line-modified"> 662         WASM_PARSER_FAIL_IF(!parseResultType(unused), &quot;can&#39;t get inline type for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);</span>
 663         return { };
 664     }
 665 
 666     case BrTable: {
 667         uint32_t numberOfTargets;
 668         uint32_t unused;
 669         WASM_PARSER_FAIL_IF(!parseVarUInt32(numberOfTargets), &quot;can&#39;t get the number of targets for br_table in unreachable context&quot;);
 670         WASM_PARSER_FAIL_IF(numberOfTargets == std::numeric_limits&lt;uint32_t&gt;::max(), &quot;br_table&#39;s number of targets is too big &quot;, numberOfTargets);
 671 
 672         for (uint32_t i = 0; i &lt; numberOfTargets; ++i)
 673             WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get &quot;, i, &quot;th target for br_table in unreachable context&quot;);
 674 
 675         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get default target for br_table in unreachable context&quot;);
 676         return { };
 677     }
 678 
 679     case CallIndirect: {
 680         uint32_t unused;
 681         uint32_t unused2;
 682         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get call_indirect&#39;s signature index in unreachable context&quot;);
</pre>
<hr />
<pre>
 758         return { };
 759     }
 760 
 761     // no immediate cases
 762     FOR_EACH_WASM_BINARY_OP(CREATE_CASE)
 763     FOR_EACH_WASM_UNARY_OP(CREATE_CASE)
 764     case Unreachable:
 765     case Nop:
 766     case Return:
 767     case Select:
 768     case Drop: {
 769         return { };
 770     }
 771     }
 772 #undef CREATE_CASE
 773     RELEASE_ASSERT_NOT_REACHED();
 774 }
 775 
 776 } } // namespace JSC::Wasm
 777 




 778 #endif // ENABLE(WEBASSEMBLY)
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(WEBASSEMBLY)
  29 
  30 #include &quot;WasmParser.h&quot;
  31 #include &quot;WasmSignatureInlines.h&quot;
  32 #include &lt;wtf/DataLog.h&gt;
  33 
  34 namespace JSC { namespace Wasm {
  35 
  36 enum class BlockType {
  37     If,
  38     Block,
  39     Loop,
  40     TopLevel
  41 };
  42 
<span class="line-added">  43 template&lt;typename EnclosingStack, typename NewStack&gt;</span>
<span class="line-added">  44 void splitStack(BlockSignature signature, EnclosingStack&amp; enclosingStack, NewStack&amp; newStack)</span>
<span class="line-added">  45 {</span>
<span class="line-added">  46     newStack.reserveInitialCapacity(signature-&gt;argumentCount());</span>
<span class="line-added">  47     ASSERT(enclosingStack.size() &gt;= signature-&gt;argumentCount());</span>
<span class="line-added">  48     unsigned offset = enclosingStack.size() - signature-&gt;argumentCount();</span>
<span class="line-added">  49     for (unsigned i = 0; i &lt; signature-&gt;argumentCount(); ++i)</span>
<span class="line-added">  50         newStack.uncheckedAppend(enclosingStack.at(i + offset));</span>
<span class="line-added">  51     enclosingStack.shrink(offset);</span>
<span class="line-added">  52 }</span>
<span class="line-added">  53 </span>
  54 template&lt;typename Context&gt;
  55 class FunctionParser : public Parser&lt;void&gt; {
  56 public:
<span class="line-modified">  57     struct ControlEntry;</span>
<span class="line-added">  58 </span>
  59     using ControlType = typename Context::ControlType;
<span class="line-modified">  60     using ExpressionType = typename Context::ExpressionType;</span>

  61 
<span class="line-modified">  62     class TypedExpression {</span>
<span class="line-added">  63     public:</span>
<span class="line-added">  64         TypedExpression() = default;</span>
  65 
<span class="line-modified">  66         TypedExpression(Type type, ExpressionType value)</span>
<span class="line-added">  67             : m_type(type)</span>
<span class="line-added">  68             , m_value(value)</span>
<span class="line-added">  69         {</span>
<span class="line-added">  70         }</span>
<span class="line-added">  71 </span>
<span class="line-added">  72         Type type() const { return m_type; }</span>
<span class="line-added">  73 </span>
<span class="line-added">  74         ExpressionType value() const { return m_value; }</span>
<span class="line-added">  75         operator ExpressionType() const { return m_value; }</span>
<span class="line-added">  76 </span>
<span class="line-added">  77         ExpressionType operator-&gt;() const { return m_value; }</span>
<span class="line-added">  78 </span>
<span class="line-added">  79     private:</span>
<span class="line-added">  80         Type m_type;</span>
<span class="line-added">  81         ExpressionType m_value;</span>
<span class="line-added">  82     };</span>
<span class="line-added">  83 </span>
<span class="line-added">  84     using ControlStack = Vector&lt;ControlEntry, 16&gt;;</span>
<span class="line-added">  85     using ResultList = Vector&lt;ExpressionType, 8&gt;;</span>
<span class="line-added">  86     using Stack = Vector&lt;TypedExpression, 16, UnsafeVectorOverflow&gt;;</span>
  87 
  88     struct ControlEntry {
  89         Stack enclosedExpressionStack;
<span class="line-added">  90         Stack elseBlockStack;</span>
  91         ControlType controlData;
  92     };
  93 
<span class="line-added">  94     FunctionParser(Context&amp;, const uint8_t* functionStart, size_t functionLength, const Signature&amp;, const ModuleInformation&amp;);</span>
<span class="line-added">  95 </span>
<span class="line-added">  96     Result WARN_UNUSED_RETURN parse();</span>
<span class="line-added">  97 </span>
  98     OpType currentOpcode() const { return m_currentOpcode; }
  99     size_t currentOpcodeStartingOffset() const { return m_currentOpcodeStartingOffset; }
<span class="line-added"> 100     const Signature&amp; signature() const { return m_signature; }</span>
<span class="line-added"> 101 </span>
<span class="line-added"> 102     ControlStack&amp; controlStack() { return m_controlStack; }</span>
<span class="line-added"> 103     Stack&amp; expressionStack() { return m_expressionStack; }</span>
 104 
 105 private:
<span class="line-modified"> 106     static constexpr bool verbose = false;</span>
 107 
 108     PartialResult WARN_UNUSED_RETURN parseBody();
 109     PartialResult WARN_UNUSED_RETURN parseExpression();
 110     PartialResult WARN_UNUSED_RETURN parseUnreachableExpression();
 111     PartialResult WARN_UNUSED_RETURN unifyControl(Vector&lt;ExpressionType&gt;&amp;, unsigned level);
<span class="line-added"> 112     PartialResult WARN_UNUSED_RETURN checkBranchTarget(const ControlType&amp;);</span>
<span class="line-added"> 113     PartialResult WARN_UNUSED_RETURN unify(const ControlType&amp;);</span>
 114 
 115 #define WASM_TRY_POP_EXPRESSION_STACK_INTO(result, what) do {                               \
 116         WASM_PARSER_FAIL_IF(m_expressionStack.isEmpty(), &quot;can&#39;t pop empty stack in &quot; what); \
 117         result = m_expressionStack.takeLast();                                              \
<span class="line-modified"> 118         m_context.didPopValueFromStack();                                                   \</span>
 119     } while (0)
 120 
 121     template&lt;OpType&gt;
<span class="line-modified"> 122     PartialResult WARN_UNUSED_RETURN unaryCase(Type returnType, Type operandType);</span>
 123 
 124     template&lt;OpType&gt;
<span class="line-modified"> 125     PartialResult WARN_UNUSED_RETURN binaryCase(Type returnType, Type lhsType, Type rhsType);</span>
<span class="line-added"> 126 </span>
<span class="line-added"> 127     PartialResult WARN_UNUSED_RETURN store(Type memoryType);</span>
<span class="line-added"> 128     PartialResult WARN_UNUSED_RETURN load(Type memoryType);</span>
 129 
 130 #define WASM_TRY_ADD_TO_CONTEXT(add_expression) WASM_FAIL_IF_HELPER_FAILS(m_context.add_expression)
 131 
<span class="line-added"> 132     template &lt;typename ...Args&gt;</span>
<span class="line-added"> 133     NEVER_INLINE UnexpectedResult WARN_UNUSED_RETURN validationFail(const Args&amp;... args) const</span>
<span class="line-added"> 134     {</span>
<span class="line-added"> 135         using namespace FailureHelper; // See ADL comment in WasmParser.h.</span>
<span class="line-added"> 136         if (UNLIKELY(ASSERT_ENABLED &amp;&amp; Options::crashOnFailedWebAssemblyValidate()))</span>
<span class="line-added"> 137             WTFBreakpointTrap();</span>
<span class="line-added"> 138 </span>
<span class="line-added"> 139         StringPrintStream out;</span>
<span class="line-added"> 140         out.print(&quot;WebAssembly.Module doesn&#39;t validate: &quot;_s, args...);</span>
<span class="line-added"> 141         return UnexpectedResult(out.toString());</span>
<span class="line-added"> 142     }</span>
<span class="line-added"> 143 </span>
<span class="line-added"> 144 #define WASM_VALIDATOR_FAIL_IF(condition, ...) do { \</span>
<span class="line-added"> 145         if (UNLIKELY(condition)) \</span>
<span class="line-added"> 146             return validationFail(__VA_ARGS__); \</span>
<span class="line-added"> 147     } while (0) \</span>
<span class="line-added"> 148 </span>
 149     // FIXME add a macro as above for WASM_TRY_APPEND_TO_CONTROL_STACK https://bugs.webkit.org/show_bug.cgi?id=165862
 150 
 151     Context&amp; m_context;
 152     Stack m_expressionStack;
<span class="line-modified"> 153     ControlStack m_controlStack;</span>
<span class="line-added"> 154     Vector&lt;Type, 16&gt; m_locals;</span>
 155     const Signature&amp; m_signature;
 156     const ModuleInformation&amp; m_info;
 157 
 158     OpType m_currentOpcode;
 159     size_t m_currentOpcodeStartingOffset { 0 };
 160 


 161     unsigned m_unreachableBlocks { 0 };
 162     unsigned m_loopIndex { 0 };
 163 };
 164 
 165 template&lt;typename Context&gt;
 166 FunctionParser&lt;Context&gt;::FunctionParser(Context&amp; context, const uint8_t* functionStart, size_t functionLength, const Signature&amp; signature, const ModuleInformation&amp; info)
 167     : Parser(functionStart, functionLength)
 168     , m_context(context)

 169     , m_signature(signature)
 170     , m_info(info)
 171 {
 172     if (verbose)
 173         dataLogLn(&quot;Parsing function starting at: &quot;, (uintptr_t)functionStart, &quot; of length: &quot;, functionLength, &quot; with signature: &quot;, signature);
 174     m_context.setParser(this);
 175 }
 176 
 177 template&lt;typename Context&gt;
 178 auto FunctionParser&lt;Context&gt;::parse() -&gt; Result
 179 {
 180     uint32_t localGroupsCount;
 181 
 182     WASM_PARSER_FAIL_IF(!m_context.addArguments(m_signature), &quot;can&#39;t add &quot;, m_signature.argumentCount(), &quot; arguments to Function&quot;);
 183     WASM_PARSER_FAIL_IF(!parseVarUInt32(localGroupsCount), &quot;can&#39;t get local groups count&quot;);
 184 
<span class="line-added"> 185     WASM_PARSER_FAIL_IF(!m_locals.tryReserveCapacity(m_signature.argumentCount()), &quot;can&#39;t allocate enough memory for function&#39;s &quot;, m_signature.argumentCount(), &quot; arguments&quot;);</span>
<span class="line-added"> 186     for (uint32_t i = 0; i &lt; m_signature.argumentCount(); ++i)</span>
<span class="line-added"> 187         m_locals.uncheckedAppend(m_signature.argument(i));</span>
<span class="line-added"> 188 </span>
 189     uint64_t totalNumberOfLocals = m_signature.argumentCount();
 190     for (uint32_t i = 0; i &lt; localGroupsCount; ++i) {
 191         uint32_t numberOfLocals;
 192         Type typeOfLocal;
 193 
 194         WASM_PARSER_FAIL_IF(!parseVarUInt32(numberOfLocals), &quot;can&#39;t get Function&#39;s number of locals in group &quot;, i);
 195         totalNumberOfLocals += numberOfLocals;
 196         WASM_PARSER_FAIL_IF(totalNumberOfLocals &gt; maxFunctionLocals, &quot;Function&#39;s number of locals is too big &quot;, totalNumberOfLocals, &quot; maximum &quot;, maxFunctionLocals);
 197         WASM_PARSER_FAIL_IF(!parseValueType(typeOfLocal), &quot;can&#39;t get Function local&#39;s type in group &quot;, i);
<span class="line-added"> 198 </span>
<span class="line-added"> 199         WASM_PARSER_FAIL_IF(!m_locals.tryReserveCapacity(totalNumberOfLocals), &quot;can&#39;t allocate enough memory for function&#39;s &quot;, totalNumberOfLocals, &quot; locals&quot;);</span>
<span class="line-added"> 200         for (uint32_t i = 0; i &lt; numberOfLocals; ++i)</span>
<span class="line-added"> 201             m_locals.uncheckedAppend(typeOfLocal);</span>
<span class="line-added"> 202 </span>
 203         WASM_TRY_ADD_TO_CONTEXT(addLocal(typeOfLocal, numberOfLocals));
 204     }
 205 
<span class="line-added"> 206     m_context.didFinishParsingLocals();</span>
<span class="line-added"> 207 </span>
 208     WASM_FAIL_IF_HELPER_FAILS(parseBody());
 209 
 210     return { };
 211 }
 212 
 213 template&lt;typename Context&gt;
 214 auto FunctionParser&lt;Context&gt;::parseBody() -&gt; PartialResult
 215 {
<span class="line-modified"> 216     m_controlStack.append({ { }, { }, m_context.addTopLevel(&amp;m_signature) });</span>
<span class="line-modified"> 217     uint8_t op = 0;</span>
 218     while (m_controlStack.size()) {


 219         m_currentOpcodeStartingOffset = m_offset;
 220         WASM_PARSER_FAIL_IF(!parseUInt8(op), &quot;can&#39;t decode opcode&quot;);
 221         WASM_PARSER_FAIL_IF(!isValidOpType(op), &quot;invalid opcode &quot;, op);
 222 
 223         m_currentOpcode = static_cast&lt;OpType&gt;(op);
 224 
 225         if (verbose) {
 226             dataLogLn(&quot;processing op (&quot;, m_unreachableBlocks, &quot;): &quot;,  RawPointer(reinterpret_cast&lt;void*&gt;(op)), &quot;, &quot;, makeString(static_cast&lt;OpType&gt;(op)), &quot; at offset: &quot;, RawPointer(reinterpret_cast&lt;void*&gt;(m_offset)));
 227             m_context.dump(m_controlStack, &amp;m_expressionStack);
 228         }
 229 
 230         if (m_unreachableBlocks)
 231             WASM_FAIL_IF_HELPER_FAILS(parseUnreachableExpression());
 232         else {
 233             WASM_FAIL_IF_HELPER_FAILS(parseExpression());


 234         }
 235     }
<span class="line-added"> 236     WASM_FAIL_IF_HELPER_FAILS(m_context.endTopLevel(&amp;m_signature, m_expressionStack));</span>
 237 
 238     ASSERT(op == OpType::End);
 239     return { };
 240 }
 241 
 242 template&lt;typename Context&gt;
 243 template&lt;OpType op&gt;
<span class="line-modified"> 244 auto FunctionParser&lt;Context&gt;::binaryCase(Type returnType, Type lhsType, Type rhsType) -&gt; PartialResult</span>
 245 {
<span class="line-modified"> 246     TypedExpression right;</span>
<span class="line-modified"> 247     TypedExpression left;</span>

 248 
 249     WASM_TRY_POP_EXPRESSION_STACK_INTO(right, &quot;binary right&quot;);
 250     WASM_TRY_POP_EXPRESSION_STACK_INTO(left, &quot;binary left&quot;);

 251 
<span class="line-modified"> 252     WASM_VALIDATOR_FAIL_IF(left.type() != lhsType, op, &quot; left value type mismatch&quot;);</span>
<span class="line-added"> 253     WASM_VALIDATOR_FAIL_IF(right.type() != rhsType, op, &quot; right value type mismatch&quot;);</span>
<span class="line-added"> 254 </span>
<span class="line-added"> 255     ExpressionType result;</span>
<span class="line-added"> 256     WASM_TRY_ADD_TO_CONTEXT(template addOp&lt;op&gt;(left, right, result));</span>
<span class="line-added"> 257     m_expressionStack.constructAndAppend(returnType, result);</span>
 258     return { };
 259 }
 260 
 261 template&lt;typename Context&gt;
 262 template&lt;OpType op&gt;
<span class="line-modified"> 263 auto FunctionParser&lt;Context&gt;::unaryCase(Type returnType, Type operandType) -&gt; PartialResult</span>
 264 {
<span class="line-modified"> 265     TypedExpression value;</span>


 266     WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;unary&quot;);
<span class="line-added"> 267 </span>
<span class="line-added"> 268     WASM_VALIDATOR_FAIL_IF(value.type() != operandType, op, &quot; value type mismatch&quot;);</span>
<span class="line-added"> 269 </span>
<span class="line-added"> 270     ExpressionType result;</span>
 271     WASM_TRY_ADD_TO_CONTEXT(template addOp&lt;op&gt;(value, result));
<span class="line-added"> 272     m_expressionStack.constructAndAppend(returnType, result);</span>
<span class="line-added"> 273     return { };</span>
<span class="line-added"> 274 }</span>
<span class="line-added"> 275 </span>
<span class="line-added"> 276 template&lt;typename Context&gt;</span>
<span class="line-added"> 277 auto FunctionParser&lt;Context&gt;::load(Type memoryType) -&gt; PartialResult</span>
<span class="line-added"> 278 {</span>
<span class="line-added"> 279     WASM_VALIDATOR_FAIL_IF(!m_info.memory, &quot;load instruction without memory&quot;);</span>
<span class="line-added"> 280 </span>
<span class="line-added"> 281     uint32_t alignment;</span>
<span class="line-added"> 282     uint32_t offset;</span>
<span class="line-added"> 283     TypedExpression pointer;</span>
<span class="line-added"> 284     WASM_PARSER_FAIL_IF(!parseVarUInt32(alignment), &quot;can&#39;t get load alignment&quot;);</span>
<span class="line-added"> 285     WASM_PARSER_FAIL_IF(alignment &gt; memoryLog2Alignment(m_currentOpcode), &quot;byte alignment &quot;, 1ull &lt;&lt; alignment, &quot; exceeds load&#39;s natural alignment &quot;, 1ull &lt;&lt; memoryLog2Alignment(m_currentOpcode));</span>
<span class="line-added"> 286     WASM_PARSER_FAIL_IF(!parseVarUInt32(offset), &quot;can&#39;t get load offset&quot;);</span>
<span class="line-added"> 287     WASM_TRY_POP_EXPRESSION_STACK_INTO(pointer, &quot;load pointer&quot;);</span>
<span class="line-added"> 288 </span>
<span class="line-added"> 289     WASM_VALIDATOR_FAIL_IF(pointer.type() != I32, m_currentOpcode, &quot; pointer type mismatch&quot;);</span>
<span class="line-added"> 290 </span>
<span class="line-added"> 291     ExpressionType result;</span>
<span class="line-added"> 292     WASM_TRY_ADD_TO_CONTEXT(load(static_cast&lt;LoadOpType&gt;(m_currentOpcode), pointer, result, offset));</span>
<span class="line-added"> 293     m_expressionStack.constructAndAppend(memoryType, result);</span>
<span class="line-added"> 294     return { };</span>
<span class="line-added"> 295 }</span>
<span class="line-added"> 296 </span>
<span class="line-added"> 297 template&lt;typename Context&gt;</span>
<span class="line-added"> 298 auto FunctionParser&lt;Context&gt;::store(Type memoryType) -&gt; PartialResult</span>
<span class="line-added"> 299 {</span>
<span class="line-added"> 300     WASM_VALIDATOR_FAIL_IF(!m_info.memory, &quot;store instruction without memory&quot;);</span>
<span class="line-added"> 301 </span>
<span class="line-added"> 302     uint32_t alignment;</span>
<span class="line-added"> 303     uint32_t offset;</span>
<span class="line-added"> 304     TypedExpression value;</span>
<span class="line-added"> 305     TypedExpression pointer;</span>
<span class="line-added"> 306     WASM_PARSER_FAIL_IF(!parseVarUInt32(alignment), &quot;can&#39;t get store alignment&quot;);</span>
<span class="line-added"> 307     WASM_PARSER_FAIL_IF(alignment &gt; memoryLog2Alignment(m_currentOpcode), &quot;byte alignment &quot;, 1ull &lt;&lt; alignment, &quot; exceeds store&#39;s natural alignment &quot;, 1ull &lt;&lt; memoryLog2Alignment(m_currentOpcode));</span>
<span class="line-added"> 308     WASM_PARSER_FAIL_IF(!parseVarUInt32(offset), &quot;can&#39;t get store offset&quot;);</span>
<span class="line-added"> 309     WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;store value&quot;);</span>
<span class="line-added"> 310     WASM_TRY_POP_EXPRESSION_STACK_INTO(pointer, &quot;store pointer&quot;);</span>
<span class="line-added"> 311 </span>
<span class="line-added"> 312     WASM_VALIDATOR_FAIL_IF(pointer.type() != I32, m_currentOpcode, &quot; pointer type mismatch&quot;);</span>
<span class="line-added"> 313     WASM_VALIDATOR_FAIL_IF(value.type() != memoryType, m_currentOpcode, &quot; value type mismatch&quot;);</span>
<span class="line-added"> 314 </span>
<span class="line-added"> 315     WASM_TRY_ADD_TO_CONTEXT(store(static_cast&lt;StoreOpType&gt;(m_currentOpcode), pointer, value, offset));</span>
<span class="line-added"> 316     return { };</span>
<span class="line-added"> 317 }</span>
<span class="line-added"> 318 </span>
<span class="line-added"> 319 template&lt;typename Context&gt;</span>
<span class="line-added"> 320 auto FunctionParser&lt;Context&gt;::checkBranchTarget(const ControlType&amp; target) -&gt; PartialResult</span>
<span class="line-added"> 321 {</span>
<span class="line-added"> 322     if (!target.branchTargetArity())</span>
<span class="line-added"> 323         return { };</span>
<span class="line-added"> 324 </span>
<span class="line-added"> 325     WASM_VALIDATOR_FAIL_IF(m_expressionStack.size() &lt; target.branchTargetArity(), ControlType::isTopLevel(target) ? &quot;branch out of function&quot; : &quot;branch to block&quot;, &quot; on expression stack of size &quot;, m_expressionStack.size(), &quot;, but block, &quot;, target.signature()-&gt;toString() , &quot; expects &quot;, target.branchTargetArity(), &quot; values&quot;);</span>
<span class="line-added"> 326 </span>
<span class="line-added"> 327 </span>
<span class="line-added"> 328     unsigned offset = m_expressionStack.size() - target.branchTargetArity();</span>
<span class="line-added"> 329     for (unsigned i = 0; i &lt; target.branchTargetArity(); ++i)</span>
<span class="line-added"> 330         WASM_VALIDATOR_FAIL_IF(!isSubtype(target.branchTargetType(i), m_expressionStack[offset + i].type()), &quot;branch&#39;s stack type is not a subtype of block&#39;s type branch target type. Stack value has type&quot;, m_expressionStack[offset + i].type(), &quot; but branch target expects a value with subtype of &quot;, target.branchTargetType(i), &quot; at index &quot;, i);</span>
<span class="line-added"> 331 </span>
<span class="line-added"> 332     return { };</span>
<span class="line-added"> 333 }</span>
<span class="line-added"> 334 </span>
<span class="line-added"> 335 template&lt;typename Context&gt;</span>
<span class="line-added"> 336 auto FunctionParser&lt;Context&gt;::unify(const ControlType&amp; controlData) -&gt; PartialResult</span>
<span class="line-added"> 337 {</span>
<span class="line-added"> 338     WASM_VALIDATOR_FAIL_IF(controlData.signature()-&gt;returnCount() != m_expressionStack.size(), &quot; block with type: &quot;, controlData.signature()-&gt;toString(), &quot; returns: &quot;, controlData.signature()-&gt;returnCount(), &quot; but stack has: &quot;, m_expressionStack.size(), &quot; values&quot;);</span>
<span class="line-added"> 339     for (unsigned i = 0; i &lt; controlData.signature()-&gt;returnCount(); ++i)</span>
<span class="line-added"> 340         WASM_VALIDATOR_FAIL_IF(!isSubtype(m_expressionStack[i].type(), controlData.signature()-&gt;returnType(i)), &quot;control flow returns with unexpected type. &quot;, m_expressionStack[i].type(), &quot; is not a subtype of &quot;, controlData.signature()-&gt;returnType(i));</span>
 341 

 342     return { };
 343 }
 344 
 345 template&lt;typename Context&gt;
 346 auto FunctionParser&lt;Context&gt;::parseExpression() -&gt; PartialResult
 347 {
 348     switch (m_currentOpcode) {
<span class="line-modified"> 349 #define CREATE_CASE(name, id, b3op, inc, lhsType, rhsType, returnType) case OpType::name: return binaryCase&lt;OpType::name&gt;(returnType, lhsType, rhsType);</span>
 350     FOR_EACH_WASM_BINARY_OP(CREATE_CASE)
 351 #undef CREATE_CASE
 352 
<span class="line-modified"> 353 #define CREATE_CASE(name, id, b3op, inc, operandType, returnType) case OpType::name: return unaryCase&lt;OpType::name&gt;(returnType, operandType);</span>
 354     FOR_EACH_WASM_UNARY_OP(CREATE_CASE)
 355 #undef CREATE_CASE
 356 
 357     case Select: {
<span class="line-modified"> 358         TypedExpression condition;</span>
<span class="line-modified"> 359         TypedExpression zero;</span>
<span class="line-modified"> 360         TypedExpression nonZero;</span>
 361 
 362         WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;select condition&quot;);
 363         WASM_TRY_POP_EXPRESSION_STACK_INTO(zero, &quot;select zero&quot;);
 364         WASM_TRY_POP_EXPRESSION_STACK_INTO(nonZero, &quot;select non-zero&quot;);
 365 
<span class="line-added"> 366         WASM_VALIDATOR_FAIL_IF(condition.type() != I32, &quot;select condition must be i32, got &quot;, condition.type());</span>
<span class="line-added"> 367         WASM_VALIDATOR_FAIL_IF(nonZero.type() != zero.type(), &quot;select result types must match, got &quot;, nonZero.type(), &quot; and &quot;, zero.type());</span>
<span class="line-added"> 368 </span>
 369         ExpressionType result;
 370         WASM_TRY_ADD_TO_CONTEXT(addSelect(condition, nonZero, zero, result));
 371 
<span class="line-modified"> 372         m_expressionStack.constructAndAppend(zero.type(), result);</span>
 373         return { };
 374     }
 375 
<span class="line-modified"> 376 #define CREATE_CASE(name, id, b3op, inc, memoryType) case OpType::name: return load(memoryType);</span>
<span class="line-modified"> 377 FOR_EACH_WASM_MEMORY_LOAD_OP(CREATE_CASE)</span>
<span class="line-modified"> 378 #undef CREATE_CASE</span>











 379 
<span class="line-modified"> 380 #define CREATE_CASE(name, id, b3op, inc, memoryType) case OpType::name: return store(memoryType);</span>
<span class="line-modified"> 381 FOR_EACH_WASM_MEMORY_STORE_OP(CREATE_CASE)</span>











 382 #undef CREATE_CASE
 383 
 384     case F32Const: {
 385         uint32_t constant;
 386         WASM_PARSER_FAIL_IF(!parseUInt32(constant), &quot;can&#39;t parse 32-bit floating-point constant&quot;);
<span class="line-modified"> 387         m_expressionStack.constructAndAppend(F32, m_context.addConstant(F32, constant));</span>
 388         return { };
 389     }
 390 
 391     case I32Const: {
 392         int32_t constant;
 393         WASM_PARSER_FAIL_IF(!parseVarInt32(constant), &quot;can&#39;t parse 32-bit constant&quot;);
<span class="line-modified"> 394         m_expressionStack.constructAndAppend(I32, m_context.addConstant(I32, constant));</span>
 395         return { };
 396     }
 397 
 398     case F64Const: {
 399         uint64_t constant;
 400         WASM_PARSER_FAIL_IF(!parseUInt64(constant), &quot;can&#39;t parse 64-bit floating-point constant&quot;);
<span class="line-modified"> 401         m_expressionStack.constructAndAppend(F64, m_context.addConstant(F64, constant));</span>
 402         return { };
 403     }
 404 
 405     case I64Const: {
 406         int64_t constant;
 407         WASM_PARSER_FAIL_IF(!parseVarInt64(constant), &quot;can&#39;t parse 64-bit constant&quot;);
<span class="line-modified"> 408         m_expressionStack.constructAndAppend(I64, m_context.addConstant(I64, constant));</span>
 409         return { };
 410     }
 411 
 412     case TableGet: {
 413         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
 414         unsigned tableIndex;
 415         WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t parse table index&quot;);
<span class="line-modified"> 416         WASM_VALIDATOR_FAIL_IF(tableIndex &gt;= m_info.tableCount(), &quot;table index &quot;, tableIndex, &quot; is invalid, limit is &quot;, m_info.tableCount());</span>
<span class="line-added"> 417 </span>
<span class="line-added"> 418         TypedExpression index;</span>
 419         WASM_TRY_POP_EXPRESSION_STACK_INTO(index, &quot;table.get&quot;);
<span class="line-added"> 420         WASM_VALIDATOR_FAIL_IF(I32 != index.type(), &quot;table.get index to type &quot;, index.type(), &quot; expected &quot;, I32);</span>
<span class="line-added"> 421 </span>
<span class="line-added"> 422         ExpressionType result;</span>
 423         WASM_TRY_ADD_TO_CONTEXT(addTableGet(tableIndex, index, result));
<span class="line-modified"> 424         Type resultType = m_info.tables[tableIndex].wasmType();</span>
<span class="line-added"> 425         m_expressionStack.constructAndAppend(resultType, result);</span>
 426         return { };
 427     }
 428 
 429     case TableSet: {
 430         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
 431         unsigned tableIndex;
 432         WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t parse table index&quot;);
<span class="line-modified"> 433         WASM_VALIDATOR_FAIL_IF(tableIndex &gt;= m_info.tableCount(), &quot;table index &quot;, tableIndex, &quot; is invalid, limit is &quot;, m_info.tableCount());</span>
<span class="line-modified"> 434         TypedExpression value, index;</span>
<span class="line-added"> 435         WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;table.set&quot;);</span>
 436         WASM_TRY_POP_EXPRESSION_STACK_INTO(index, &quot;table.set&quot;);
<span class="line-modified"> 437         WASM_VALIDATOR_FAIL_IF(I32 != index.type(), &quot;table.set index to type &quot;, index.type(), &quot; expected &quot;, I32);</span>
<span class="line-added"> 438         Type type = m_info.tables[tableIndex].wasmType();</span>
<span class="line-added"> 439         WASM_VALIDATOR_FAIL_IF(!isSubtype(value.type(), type), &quot;table.set value to type &quot;, value.type(), &quot; expected &quot;, type);</span>
<span class="line-added"> 440         RELEASE_ASSERT(m_info.tables[tableIndex].type() == TableElementType::Anyref || m_info.tables[tableIndex].type() == TableElementType::Funcref);</span>
<span class="line-added"> 441         WASM_TRY_ADD_TO_CONTEXT(addTableSet(tableIndex, index, value));</span>
 442         return { };
 443     }
 444 
 445     case ExtTable: {
 446         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
 447         uint8_t extOp;
 448         WASM_PARSER_FAIL_IF(!parseUInt8(extOp), &quot;can&#39;t parse table extended opcode&quot;);
 449         unsigned tableIndex;
 450         WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t parse table index&quot;);
<span class="line-added"> 451         WASM_VALIDATOR_FAIL_IF(tableIndex &gt;= m_info.tableCount(), &quot;table index &quot;, tableIndex, &quot; is invalid, limit is &quot;, m_info.tableCount());</span>
 452 
 453         switch (static_cast&lt;ExtTableOpType&gt;(extOp)) {
 454         case ExtTableOpType::TableSize: {
 455             ExpressionType result;
 456             WASM_TRY_ADD_TO_CONTEXT(addTableSize(tableIndex, result));
<span class="line-modified"> 457             m_expressionStack.constructAndAppend(I32, result);</span>
 458             break;
 459         }
 460         case ExtTableOpType::TableGrow: {
<span class="line-modified"> 461             TypedExpression fill;</span>
<span class="line-added"> 462             TypedExpression delta;</span>
 463             WASM_TRY_POP_EXPRESSION_STACK_INTO(delta, &quot;table.grow&quot;);
 464             WASM_TRY_POP_EXPRESSION_STACK_INTO(fill, &quot;table.grow&quot;);
<span class="line-added"> 465 </span>
<span class="line-added"> 466             WASM_VALIDATOR_FAIL_IF(!isSubtype(fill.type(), m_info.tables[tableIndex].wasmType()), &quot;table.grow expects fill value of type &quot;, m_info.tables[tableIndex].wasmType(), &quot; got &quot;, fill.type());</span>
<span class="line-added"> 467             WASM_VALIDATOR_FAIL_IF(I32 != delta.type(), &quot;table.grow expects an i32 delta value, got &quot;, delta.type());</span>
<span class="line-added"> 468 </span>
<span class="line-added"> 469             ExpressionType result;</span>
 470             WASM_TRY_ADD_TO_CONTEXT(addTableGrow(tableIndex, fill, delta, result));
<span class="line-modified"> 471             m_expressionStack.constructAndAppend(I32, result);</span>
 472             break;
 473         }
 474         case ExtTableOpType::TableFill: {
<span class="line-modified"> 475             TypedExpression offset, fill, count;</span>
 476             WASM_TRY_POP_EXPRESSION_STACK_INTO(count, &quot;table.fill&quot;);
 477             WASM_TRY_POP_EXPRESSION_STACK_INTO(fill, &quot;table.fill&quot;);
 478             WASM_TRY_POP_EXPRESSION_STACK_INTO(offset, &quot;table.fill&quot;);
<span class="line-added"> 479 </span>
<span class="line-added"> 480             WASM_VALIDATOR_FAIL_IF(!isSubtype(fill.type(), m_info.tables[tableIndex].wasmType()), &quot;table.fill expects fill value of type &quot;, m_info.tables[tableIndex].wasmType(), &quot; got &quot;, fill.type());</span>
<span class="line-added"> 481             WASM_VALIDATOR_FAIL_IF(I32 != offset.type(), &quot;table.fill expects an i32 offset value, got &quot;, offset.type());</span>
<span class="line-added"> 482             WASM_VALIDATOR_FAIL_IF(I32 != count.type(), &quot;table.fill expects an i32 count value, got &quot;, count.type());</span>
<span class="line-added"> 483 </span>
 484             WASM_TRY_ADD_TO_CONTEXT(addTableFill(tableIndex, offset, fill, count));
 485             break;
 486         }
 487         default:
 488             WASM_PARSER_FAIL_IF(true, &quot;invalid extended table op &quot;, extOp);
 489             break;
 490         }
 491         return { };
 492     }
 493 
 494     case RefNull: {
 495         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
<span class="line-modified"> 496         m_expressionStack.constructAndAppend(Funcref, m_context.addConstant(Funcref, JSValue::encode(jsNull())));</span>
 497         return { };
 498     }
 499 
 500     case RefIsNull: {
 501         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
<span class="line-modified"> 502         TypedExpression value;</span>
 503         WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;ref.is_null&quot;);
<span class="line-added"> 504         WASM_VALIDATOR_FAIL_IF(!isSubtype(value.type(), Anyref), &quot;ref.is_null to type &quot;, value.type(), &quot; expected &quot;, Anyref);</span>
<span class="line-added"> 505         ExpressionType result;</span>
 506         WASM_TRY_ADD_TO_CONTEXT(addRefIsNull(value, result));
<span class="line-modified"> 507         m_expressionStack.constructAndAppend(I32, result);</span>
 508         return { };
 509     }
 510 
 511     case RefFunc: {
 512         uint32_t index;
 513         ExpressionType result;
 514         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
 515         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for ref.func&quot;);
 516 
<span class="line-added"> 517         WASM_VALIDATOR_FAIL_IF(index &gt;= m_info.functionIndexSpaceSize(), &quot;ref.func index &quot;, index, &quot; is too large, max is &quot;, m_info.functionIndexSpaceSize());</span>
<span class="line-added"> 518         m_info.addReferencedFunction(index);</span>
 519         WASM_TRY_ADD_TO_CONTEXT(addRefFunc(index, result));
<span class="line-modified"> 520         m_expressionStack.constructAndAppend(Funcref, result);</span>
 521         return { };
 522     }
 523 
 524     case GetLocal: {
 525         uint32_t index;
 526         ExpressionType result;
 527         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for get_local&quot;);
<span class="line-added"> 528         WASM_VALIDATOR_FAIL_IF(index &gt;= m_locals.size(), &quot;attempt to use unknown local &quot;, index, &quot; last one is &quot;, m_locals.size());</span>
 529         WASM_TRY_ADD_TO_CONTEXT(getLocal(index, result));
<span class="line-modified"> 530         m_expressionStack.constructAndAppend(m_locals[index], result);</span>
 531         return { };
 532     }
 533 
 534     case SetLocal: {
 535         uint32_t index;
<span class="line-modified"> 536         TypedExpression value;</span>
 537         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for set_local&quot;);
 538         WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;set_local&quot;);
<span class="line-added"> 539         WASM_VALIDATOR_FAIL_IF(index &gt;= m_locals.size(), &quot;attempt to set unknown local &quot;, index, &quot; last one is &quot;, m_locals.size());</span>
<span class="line-added"> 540         WASM_VALIDATOR_FAIL_IF(!isSubtype(value.type(), m_locals[index]), &quot;set_local to type &quot;, value.type(), &quot; expected &quot;, m_locals[index]);</span>
 541         WASM_TRY_ADD_TO_CONTEXT(setLocal(index, value));
 542         return { };
 543     }
 544 
 545     case TeeLocal: {
 546         uint32_t index;
 547         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for tee_local&quot;);
 548         WASM_PARSER_FAIL_IF(m_expressionStack.isEmpty(), &quot;can&#39;t tee_local on empty expression stack&quot;);
<span class="line-modified"> 549         TypedExpression value = m_expressionStack.last();</span>
<span class="line-added"> 550         WASM_VALIDATOR_FAIL_IF(index &gt;= m_locals.size(), &quot;attempt to tee unknown local &quot;, index, &quot; last one is &quot;, m_locals.size());</span>
<span class="line-added"> 551         WASM_VALIDATOR_FAIL_IF(!isSubtype(value.type(), m_locals[index]), &quot;set_local to type &quot;, value.type(), &quot; expected &quot;, m_locals[index]);</span>
<span class="line-added"> 552         WASM_TRY_ADD_TO_CONTEXT(setLocal(index, value));</span>
 553         return { };
 554     }
 555 
 556     case GetGlobal: {
 557         uint32_t index;
 558         ExpressionType result;
 559         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get get_global&#39;s index&quot;);
<span class="line-added"> 560         WASM_VALIDATOR_FAIL_IF(index &gt;= m_info.globals.size(), &quot;get_global &quot;, index, &quot; of unknown global, limit is &quot;, m_info.globals.size());</span>
<span class="line-added"> 561         Type resultType = m_info.globals[index].type;</span>
<span class="line-added"> 562         ASSERT(isValueType(resultType));</span>
 563         WASM_TRY_ADD_TO_CONTEXT(getGlobal(index, result));
<span class="line-modified"> 564         m_expressionStack.constructAndAppend(resultType, result);</span>
 565         return { };
 566     }
 567 
 568     case SetGlobal: {
 569         uint32_t index;
<span class="line-modified"> 570         TypedExpression value;</span>
 571         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get set_global&#39;s index&quot;);
 572         WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;set_global value&quot;);
<span class="line-added"> 573 </span>
<span class="line-added"> 574         WASM_VALIDATOR_FAIL_IF(index &gt;= m_info.globals.size(), &quot;set_global &quot;, index, &quot; of unknown global, limit is &quot;, m_info.globals.size());</span>
<span class="line-added"> 575         WASM_VALIDATOR_FAIL_IF(m_info.globals[index].mutability == GlobalInformation::Immutable, &quot;set_global &quot;, index, &quot; is immutable&quot;);</span>
<span class="line-added"> 576 </span>
<span class="line-added"> 577         Type globalType = m_info.globals[index].type;</span>
<span class="line-added"> 578         ASSERT(isValueType(globalType));</span>
<span class="line-added"> 579         WASM_VALIDATOR_FAIL_IF(globalType != value.type(), &quot;set_global &quot;, index, &quot; with type &quot;, globalType, &quot; with a variable of type &quot;, value.type());</span>
<span class="line-added"> 580 </span>
 581         WASM_TRY_ADD_TO_CONTEXT(setGlobal(index, value));
 582         return { };
 583     }
 584 
 585     case Call: {
 586         uint32_t functionIndex;
 587         WASM_PARSER_FAIL_IF(!parseVarUInt32(functionIndex), &quot;can&#39;t parse call&#39;s function index&quot;);
 588         WASM_PARSER_FAIL_IF(functionIndex &gt;= m_info.functionIndexSpaceSize(), &quot;call function index &quot;, functionIndex, &quot; exceeds function index space &quot;, m_info.functionIndexSpaceSize());
 589 
 590         SignatureIndex calleeSignatureIndex = m_info.signatureIndexFromFunctionIndexSpace(functionIndex);
 591         const Signature&amp; calleeSignature = SignatureInformation::get(calleeSignatureIndex);
 592         WASM_PARSER_FAIL_IF(calleeSignature.argumentCount() &gt; m_expressionStack.size(), &quot;call function index &quot;, functionIndex, &quot; has &quot;, calleeSignature.argumentCount(), &quot; arguments, but the expression stack currently holds &quot;, m_expressionStack.size(), &quot; values&quot;);
 593 
 594         size_t firstArgumentIndex = m_expressionStack.size() - calleeSignature.argumentCount();
 595         Vector&lt;ExpressionType&gt; args;
 596         WASM_PARSER_FAIL_IF(!args.tryReserveCapacity(calleeSignature.argumentCount()), &quot;can&#39;t allocate enough memory for call&#39;s &quot;, calleeSignature.argumentCount(), &quot; arguments&quot;);
<span class="line-modified"> 597         for (size_t i = firstArgumentIndex; i &lt; m_expressionStack.size(); ++i) {</span>
<span class="line-modified"> 598             TypedExpression arg = m_expressionStack.at(i);</span>
<span class="line-added"> 599             WASM_VALIDATOR_FAIL_IF(!isSubtype(arg.type(), calleeSignature.argument(i - firstArgumentIndex)), &quot;argument type mismatch in call, got &quot;, arg.type(), &quot;, expected &quot;, calleeSignature.argument(i - firstArgumentIndex));</span>
<span class="line-added"> 600             args.uncheckedAppend(arg);</span>
<span class="line-added"> 601             m_context.didPopValueFromStack();</span>
<span class="line-added"> 602         }</span>
 603         m_expressionStack.shrink(firstArgumentIndex);
 604 
<span class="line-modified"> 605         RELEASE_ASSERT(calleeSignature.argumentCount() == args.size());</span>
<span class="line-modified"> 606 </span>
<span class="line-added"> 607         ResultList results;</span>
<span class="line-added"> 608         WASM_TRY_ADD_TO_CONTEXT(addCall(functionIndex, calleeSignature, args, results));</span>
 609 
<span class="line-modified"> 610         RELEASE_ASSERT(calleeSignature.returnCount() == results.size());</span>
<span class="line-modified"> 611 </span>
<span class="line-added"> 612         for (unsigned i = 0; i &lt; calleeSignature.returnCount(); ++i)</span>
<span class="line-added"> 613             m_expressionStack.constructAndAppend(calleeSignature.returnType(i), results[i]);</span>
 614 
 615         return { };
 616     }
 617 
 618     case CallIndirect: {
 619         uint32_t signatureIndex;
 620         uint32_t tableIndex;
 621         WASM_PARSER_FAIL_IF(!m_info.tableCount(), &quot;call_indirect is only valid when a table is defined or imported&quot;);
 622         WASM_PARSER_FAIL_IF(!parseVarUInt32(signatureIndex), &quot;can&#39;t get call_indirect&#39;s signature index&quot;);
 623         WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t get call_indirect&#39;s table index&quot;);
 624         WASM_PARSER_FAIL_IF(tableIndex &gt;= m_info.tableCount(), &quot;call_indirect&#39;s table index &quot;, tableIndex, &quot; invalid, limit is &quot;, m_info.tableCount());
 625         WASM_PARSER_FAIL_IF(m_info.usedSignatures.size() &lt;= signatureIndex, &quot;call_indirect&#39;s signature index &quot;, signatureIndex, &quot; exceeds known signatures &quot;, m_info.usedSignatures.size());
 626         WASM_PARSER_FAIL_IF(m_info.tables[tableIndex].type() != TableElementType::Funcref, &quot;call_indirect is only valid when a table has type funcref&quot;);
 627 
 628         const Signature&amp; calleeSignature = m_info.usedSignatures[signatureIndex].get();
 629         size_t argumentCount = calleeSignature.argumentCount() + 1; // Add the callee&#39;s index.
 630         WASM_PARSER_FAIL_IF(argumentCount &gt; m_expressionStack.size(), &quot;call_indirect expects &quot;, argumentCount, &quot; arguments, but the expression stack currently holds &quot;, m_expressionStack.size(), &quot; values&quot;);
 631 
<span class="line-added"> 632         WASM_VALIDATOR_FAIL_IF(m_expressionStack.last().type() != I32, &quot;non-i32 call_indirect index &quot;, m_expressionStack.last().type());</span>
<span class="line-added"> 633 </span>
 634         Vector&lt;ExpressionType&gt; args;
 635         WASM_PARSER_FAIL_IF(!args.tryReserveCapacity(argumentCount), &quot;can&#39;t allocate enough memory for &quot;, argumentCount, &quot; call_indirect arguments&quot;);
 636         size_t firstArgumentIndex = m_expressionStack.size() - argumentCount;
<span class="line-modified"> 637         for (size_t i = firstArgumentIndex; i &lt; m_expressionStack.size(); ++i) {</span>
<span class="line-modified"> 638             TypedExpression arg = m_expressionStack.at(i);</span>
<span class="line-added"> 639             if (i &lt; calleeSignature.argumentCount())</span>
<span class="line-added"> 640                 WASM_VALIDATOR_FAIL_IF(!isSubtype(arg.type(), calleeSignature.argument(i - firstArgumentIndex)), &quot;argument type mismatch in call_indirect, got &quot;, arg.type(), &quot;, expected &quot;, calleeSignature.argument(i - firstArgumentIndex));</span>
<span class="line-added"> 641             args.uncheckedAppend(arg);</span>
<span class="line-added"> 642             m_context.didPopValueFromStack();</span>
<span class="line-added"> 643         }</span>
 644         m_expressionStack.shrink(firstArgumentIndex);
 645 


 646 
<span class="line-modified"> 647 </span>
<span class="line-modified"> 648         ResultList results;</span>
<span class="line-added"> 649         WASM_TRY_ADD_TO_CONTEXT(addCallIndirect(tableIndex, calleeSignature, args, results));</span>
<span class="line-added"> 650 </span>
<span class="line-added"> 651         for (unsigned i = 0; i &lt; calleeSignature.returnCount(); ++i)</span>
<span class="line-added"> 652             m_expressionStack.constructAndAppend(calleeSignature.returnType(i), results[i]);</span>
 653 
 654         return { };
 655     }
 656 
 657     case Block: {
<span class="line-modified"> 658         BlockSignature inlineSignature;</span>
<span class="line-modified"> 659         WASM_PARSER_FAIL_IF(!parseBlockSignature(m_info, inlineSignature), &quot;can&#39;t get block&#39;s signature&quot;);</span>
<span class="line-modified"> 660 </span>
<span class="line-modified"> 661         WASM_VALIDATOR_FAIL_IF(m_expressionStack.size() &lt; inlineSignature-&gt;argumentCount(), &quot;Too few values on stack for block. Block expects &quot;, inlineSignature-&gt;argumentCount(), &quot;, but only &quot;, m_expressionStack.size(), &quot; were present. Block has inlineSignature: &quot;, inlineSignature-&gt;toString());</span>
<span class="line-added"> 662         unsigned offset = m_expressionStack.size() - inlineSignature-&gt;argumentCount();</span>
<span class="line-added"> 663         for (unsigned i = 0; i &lt; inlineSignature-&gt;argumentCount(); ++i) {</span>
<span class="line-added"> 664             Type type = m_expressionStack.at(offset + i).type();</span>
<span class="line-added"> 665             WASM_VALIDATOR_FAIL_IF(!isSubtype(type, inlineSignature-&gt;argument(i)), &quot;Block expects the argument at index&quot;, i, &quot; to be a subtype of &quot;, inlineSignature-&gt;argument(i), &quot; but argument has type &quot;, type);</span>
<span class="line-added"> 666         }</span>
<span class="line-added"> 667 </span>
<span class="line-added"> 668         int64_t oldSize = m_expressionStack.size();</span>
<span class="line-added"> 669         Stack newStack;</span>
<span class="line-added"> 670         ControlType block;</span>
<span class="line-added"> 671         WASM_TRY_ADD_TO_CONTEXT(addBlock(inlineSignature, m_expressionStack, block, newStack));</span>
<span class="line-added"> 672         ASSERT_UNUSED(oldSize, oldSize - m_expressionStack.size() == inlineSignature-&gt;argumentCount());</span>
<span class="line-added"> 673         ASSERT(newStack.size() == inlineSignature-&gt;argumentCount());</span>
<span class="line-added"> 674 </span>
<span class="line-added"> 675         m_controlStack.append({ WTFMove(m_expressionStack), { },  WTFMove(block) });</span>
<span class="line-added"> 676         m_expressionStack = WTFMove(newStack);</span>
 677         return { };
 678     }
 679 
 680     case Loop: {
<span class="line-modified"> 681         BlockSignature inlineSignature;</span>
<span class="line-modified"> 682         WASM_PARSER_FAIL_IF(!parseBlockSignature(m_info, inlineSignature), &quot;can&#39;t get loop&#39;s signature&quot;);</span>
<span class="line-modified"> 683 </span>
<span class="line-modified"> 684         WASM_VALIDATOR_FAIL_IF(m_expressionStack.size() &lt; inlineSignature-&gt;argumentCount(), &quot;Too few values on stack for loop block. Loop expects &quot;, inlineSignature-&gt;argumentCount(), &quot;, but only &quot;, m_expressionStack.size(), &quot; were present. Loop has inlineSignature: &quot;, inlineSignature-&gt;toString());</span>
<span class="line-modified"> 685         unsigned offset = m_expressionStack.size() - inlineSignature-&gt;argumentCount();</span>
<span class="line-modified"> 686         for (unsigned i = 0; i &lt; inlineSignature-&gt;argumentCount(); ++i) {</span>
<span class="line-added"> 687             Type type = m_expressionStack.at(offset + i).type();</span>
<span class="line-added"> 688             WASM_VALIDATOR_FAIL_IF(!isSubtype(type, inlineSignature-&gt;argument(i)), &quot;Loop expects the argument at index&quot;, i, &quot; to be a subtype of &quot;, inlineSignature-&gt;argument(i), &quot; but argument has type &quot;, type);</span>
<span class="line-added"> 689         }</span>
<span class="line-added"> 690 </span>
<span class="line-added"> 691         int64_t oldSize = m_expressionStack.size();</span>
<span class="line-added"> 692         Stack newStack;</span>
<span class="line-added"> 693         ControlType loop;</span>
<span class="line-added"> 694         WASM_TRY_ADD_TO_CONTEXT(addLoop(inlineSignature, m_expressionStack, loop, newStack, m_loopIndex++));</span>
<span class="line-added"> 695         ASSERT_UNUSED(oldSize, oldSize - m_expressionStack.size() == inlineSignature-&gt;argumentCount());</span>
<span class="line-added"> 696         ASSERT(newStack.size() == inlineSignature-&gt;argumentCount());</span>
<span class="line-added"> 697 </span>
<span class="line-added"> 698         m_controlStack.append({ WTFMove(m_expressionStack), { }, WTFMove(loop) });</span>
<span class="line-added"> 699         m_expressionStack = WTFMove(newStack);</span>
 700         return { };
 701     }
 702 
 703     case If: {
<span class="line-modified"> 704         BlockSignature inlineSignature;</span>
<span class="line-modified"> 705         TypedExpression condition;</span>
<span class="line-modified"> 706         WASM_PARSER_FAIL_IF(!parseBlockSignature(m_info, inlineSignature), &quot;can&#39;t get if&#39;s signature&quot;);</span>

 707         WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;if condition&quot;);
<span class="line-modified"> 708 </span>
<span class="line-modified"> 709         WASM_VALIDATOR_FAIL_IF(condition.type() != I32, &quot;if condition must be i32, got &quot;, condition.type());</span>
<span class="line-modified"> 710         WASM_VALIDATOR_FAIL_IF(m_expressionStack.size() &lt; inlineSignature-&gt;argumentCount(), &quot;Too few arguments on stack for if block. If expects &quot;, inlineSignature-&gt;argumentCount(), &quot;, but only &quot;, m_expressionStack.size(), &quot; were present. If block has signature: &quot;, inlineSignature-&gt;toString());</span>
<span class="line-added"> 711         unsigned offset = m_expressionStack.size() - inlineSignature-&gt;argumentCount();</span>
<span class="line-added"> 712         for (unsigned i = 0; i &lt; inlineSignature-&gt;argumentCount(); ++i)</span>
<span class="line-added"> 713             WASM_VALIDATOR_FAIL_IF(!isSubtype(m_expressionStack[offset + i].type(), inlineSignature-&gt;argument(i)), &quot;Loop expects the argument at index&quot;, i, &quot; to be a subtype of &quot;, inlineSignature-&gt;argument(i), &quot; but argument has type &quot;, m_expressionStack[i].type());</span>
<span class="line-added"> 714 </span>
<span class="line-added"> 715         int64_t oldSize = m_expressionStack.size();</span>
<span class="line-added"> 716         Stack newStack;</span>
<span class="line-added"> 717         ControlType control;</span>
<span class="line-added"> 718         WASM_TRY_ADD_TO_CONTEXT(addIf(condition, inlineSignature, m_expressionStack, control, newStack));</span>
<span class="line-added"> 719         ASSERT_UNUSED(oldSize, oldSize - m_expressionStack.size() == inlineSignature-&gt;argumentCount());</span>
<span class="line-added"> 720         ASSERT(newStack.size() == inlineSignature-&gt;argumentCount());</span>
<span class="line-added"> 721 </span>
<span class="line-added"> 722         m_controlStack.append({ WTFMove(m_expressionStack), newStack, WTFMove(control) });</span>
<span class="line-added"> 723         m_expressionStack = WTFMove(newStack);</span>
 724         return { };
 725     }
 726 
 727     case Else: {
 728         WASM_PARSER_FAIL_IF(m_controlStack.size() == 1, &quot;can&#39;t use else block at the top-level of a function&quot;);
<span class="line-modified"> 729 </span>
<span class="line-modified"> 730         ControlEntry&amp; controlEntry = m_controlStack.last();</span>
<span class="line-added"> 731 </span>
<span class="line-added"> 732         WASM_VALIDATOR_FAIL_IF(!ControlType::isIf(controlEntry.controlData), &quot;else block isn&#39;t associated to an if&quot;);</span>
<span class="line-added"> 733         WASM_FAIL_IF_HELPER_FAILS(unify(controlEntry.controlData));</span>
<span class="line-added"> 734         WASM_TRY_ADD_TO_CONTEXT(addElse(controlEntry.controlData, m_expressionStack));</span>
<span class="line-added"> 735         m_expressionStack = WTFMove(controlEntry.elseBlockStack);</span>
 736         return { };
 737     }
 738 
 739     case Br:
 740     case BrIf: {
 741         uint32_t target;
<span class="line-modified"> 742         TypedExpression condition;</span>
 743         WASM_PARSER_FAIL_IF(!parseVarUInt32(target), &quot;can&#39;t get br / br_if&#39;s target&quot;);
 744         WASM_PARSER_FAIL_IF(target &gt;= m_controlStack.size(), &quot;br / br_if&#39;s target &quot;, target, &quot; exceeds control stack size &quot;, m_controlStack.size());
<span class="line-modified"> 745         if (m_currentOpcode == BrIf) {</span>
 746             WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;br / br_if condition&quot;);
<span class="line-modified"> 747             WASM_VALIDATOR_FAIL_IF(condition.type() != I32, &quot;conditional branch with non-i32 condition &quot;, condition.type());</span>
<span class="line-added"> 748         } else {</span>
 749             m_unreachableBlocks = 1;
<span class="line-added"> 750             condition = TypedExpression { Void, Context::emptyExpression() };</span>
<span class="line-added"> 751         }</span>
 752 
 753         ControlType&amp; data = m_controlStack[m_controlStack.size() - 1 - target].controlData;
<span class="line-modified"> 754         WASM_FAIL_IF_HELPER_FAILS(checkBranchTarget(data));</span>
 755         WASM_TRY_ADD_TO_CONTEXT(addBranch(data, condition, m_expressionStack));
 756         return { };
 757     }
 758 
 759     case BrTable: {
 760         uint32_t numberOfTargets;
<span class="line-modified"> 761         uint32_t defaultTargetIndex;</span>
<span class="line-modified"> 762         TypedExpression condition;</span>
 763         Vector&lt;ControlType*&gt; targets;
 764 
 765         WASM_PARSER_FAIL_IF(!parseVarUInt32(numberOfTargets), &quot;can&#39;t get the number of targets for br_table&quot;);
 766         WASM_PARSER_FAIL_IF(numberOfTargets == std::numeric_limits&lt;uint32_t&gt;::max(), &quot;br_table&#39;s number of targets is too big &quot;, numberOfTargets);
 767 
 768         WASM_PARSER_FAIL_IF(!targets.tryReserveCapacity(numberOfTargets), &quot;can&#39;t allocate memory for &quot;, numberOfTargets, &quot; br_table targets&quot;);
 769         for (uint32_t i = 0; i &lt; numberOfTargets; ++i) {
 770             uint32_t target;
 771             WASM_PARSER_FAIL_IF(!parseVarUInt32(target), &quot;can&#39;t get &quot;, i, &quot;th target for br_table&quot;);
 772             WASM_PARSER_FAIL_IF(target &gt;= m_controlStack.size(), &quot;br_table&#39;s &quot;, i, &quot;th target &quot;, target, &quot; exceeds control stack size &quot;, m_controlStack.size());
 773             targets.uncheckedAppend(&amp;m_controlStack[m_controlStack.size() - 1 - target].controlData);
 774         }
 775 
<span class="line-modified"> 776         WASM_PARSER_FAIL_IF(!parseVarUInt32(defaultTargetIndex), &quot;can&#39;t get default target for br_table&quot;);</span>
<span class="line-modified"> 777         WASM_PARSER_FAIL_IF(defaultTargetIndex &gt;= m_controlStack.size(), &quot;br_table&#39;s default target &quot;, defaultTargetIndex, &quot; exceeds control stack size &quot;, m_controlStack.size());</span>
<span class="line-added"> 778         ControlType&amp; defaultTarget = m_controlStack[m_controlStack.size() - 1 - defaultTargetIndex].controlData;</span>
 779 
 780         WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;br_table condition&quot;);
<span class="line-modified"> 781         WASM_VALIDATOR_FAIL_IF(condition.type() != I32, &quot;br_table with non-i32 condition &quot;, condition.type());</span>
<span class="line-added"> 782 </span>
<span class="line-added"> 783         for (unsigned i = 0; i &lt; targets.size(); ++i) {</span>
<span class="line-added"> 784             ControlType* target = targets[i];</span>
<span class="line-added"> 785             WASM_VALIDATOR_FAIL_IF(defaultTarget.branchTargetArity() != target-&gt;branchTargetArity(), &quot;br_table target type size mismatch. Default has size: &quot;, defaultTarget.branchTargetArity(), &quot;but target: &quot;, i, &quot; has size: &quot;, target-&gt;branchTargetArity());</span>
<span class="line-added"> 786             for (unsigned type = 0; type &lt; defaultTarget.branchTargetArity(); ++type)</span>
<span class="line-added"> 787                 WASM_VALIDATOR_FAIL_IF(!isSubtype(defaultTarget.branchTargetType(type), target-&gt;branchTargetType(type)), &quot;br_table target type mismatch at offset &quot;, type, &quot; expected: &quot;, defaultTarget.branchTargetType(type), &quot; but saw: &quot;, target-&gt;branchTargetType(type), &quot; when targeting block: &quot;, target-&gt;signature()-&gt;toString());</span>
<span class="line-added"> 788         }</span>
<span class="line-added"> 789 </span>
<span class="line-added"> 790         WASM_FAIL_IF_HELPER_FAILS(checkBranchTarget(defaultTarget));</span>
<span class="line-added"> 791         WASM_TRY_ADD_TO_CONTEXT(addSwitch(condition, targets, defaultTarget, m_expressionStack));</span>
 792 
 793         m_unreachableBlocks = 1;
 794         return { };
 795     }
 796 
 797     case Return: {
<span class="line-modified"> 798         WASM_FAIL_IF_HELPER_FAILS(checkBranchTarget(m_controlStack[0].controlData));</span>
<span class="line-modified"> 799         WASM_TRY_ADD_TO_CONTEXT(addReturn(m_controlStack[0].controlData, m_expressionStack));</span>






 800         m_unreachableBlocks = 1;
 801         return { };
 802     }
 803 
 804     case End: {
 805         ControlEntry data = m_controlStack.takeLast();
<span class="line-added"> 806         if (ControlType::isIf(data.controlData)) {</span>
<span class="line-added"> 807             WASM_FAIL_IF_HELPER_FAILS(unify(data.controlData));</span>
<span class="line-added"> 808             WASM_TRY_ADD_TO_CONTEXT(addElse(data.controlData, m_expressionStack));</span>
<span class="line-added"> 809             m_expressionStack = WTFMove(data.elseBlockStack);</span>
<span class="line-added"> 810         }</span>
 811         // FIXME: This is a little weird in that it will modify the expressionStack for the result of the block.
 812         // That&#39;s a little too effectful for me but I don&#39;t have a better API right now.
 813         // see: https://bugs.webkit.org/show_bug.cgi?id=164353
<span class="line-added"> 814         WASM_FAIL_IF_HELPER_FAILS(unify(data.controlData));</span>
 815         WASM_TRY_ADD_TO_CONTEXT(endBlock(data, m_expressionStack));
 816         m_expressionStack.swap(data.enclosedExpressionStack);
 817         return { };
 818     }
 819 
 820     case Unreachable: {
 821         WASM_TRY_ADD_TO_CONTEXT(addUnreachable());
 822         m_unreachableBlocks = 1;
 823         return { };
 824     }
 825 
 826     case Drop: {
 827         WASM_PARSER_FAIL_IF(!m_expressionStack.size(), &quot;can&#39;t drop on empty stack&quot;);
<span class="line-modified"> 828         m_expressionStack.takeLast();</span>
<span class="line-modified"> 829         m_context.didPopValueFromStack();</span>
 830         return { };
 831     }
 832 
 833     case Nop: {
 834         return { };
 835     }
 836 
 837     case GrowMemory: {
 838         WASM_PARSER_FAIL_IF(!m_info.memory, &quot;grow_memory is only valid if a memory is defined or imported&quot;);
 839 
 840         uint8_t reserved;
 841         WASM_PARSER_FAIL_IF(!parseVarUInt1(reserved), &quot;can&#39;t parse reserved varUint1 for grow_memory&quot;);
 842         WASM_PARSER_FAIL_IF(reserved != 0, &quot;reserved varUint1 for grow_memory must be zero&quot;);
 843 
<span class="line-modified"> 844         TypedExpression delta;</span>
 845         WASM_TRY_POP_EXPRESSION_STACK_INTO(delta, &quot;expect an i32 argument to grow_memory on the stack&quot;);
<span class="line-added"> 846         WASM_VALIDATOR_FAIL_IF(delta.type() != I32, &quot;grow_memory with non-i32 delta argument has type: &quot;, delta.type());</span>
 847 
 848         ExpressionType result;
 849         WASM_TRY_ADD_TO_CONTEXT(addGrowMemory(delta, result));
<span class="line-modified"> 850         m_expressionStack.constructAndAppend(I32, result);</span>
 851 
 852         return { };
 853     }
 854 
 855     case CurrentMemory: {
 856         WASM_PARSER_FAIL_IF(!m_info.memory, &quot;current_memory is only valid if a memory is defined or imported&quot;);
 857 
 858         uint8_t reserved;
 859         WASM_PARSER_FAIL_IF(!parseVarUInt1(reserved), &quot;can&#39;t parse reserved varUint1 for current_memory&quot;);
 860         WASM_PARSER_FAIL_IF(reserved != 0, &quot;reserved varUint1 for current_memory must be zero&quot;);
 861 
 862         ExpressionType result;
 863         WASM_TRY_ADD_TO_CONTEXT(addCurrentMemory(result));
<span class="line-modified"> 864         m_expressionStack.constructAndAppend(I32, result);</span>
 865 
 866         return { };
 867     }
 868     }
 869 
 870     ASSERT_NOT_REACHED();
 871     return { };
 872 }
 873 
 874 // FIXME: We should try to use the same decoder function for both unreachable and reachable code. https://bugs.webkit.org/show_bug.cgi?id=165965
 875 template&lt;typename Context&gt;
 876 auto FunctionParser&lt;Context&gt;::parseUnreachableExpression() -&gt; PartialResult
 877 {
 878     ASSERT(m_unreachableBlocks);
<span class="line-modified"> 879 #define CREATE_CASE(name, ...) case OpType::name:</span>
 880     switch (m_currentOpcode) {
 881     case Else: {
 882         if (m_unreachableBlocks &gt; 1)
 883             return { };
 884 
 885         ControlEntry&amp; data = m_controlStack.last();
 886         m_unreachableBlocks = 0;
<span class="line-added"> 887         WASM_VALIDATOR_FAIL_IF(!ControlType::isIf(data.controlData), &quot;else block isn&#39;t associated to an if&quot;);</span>
 888         WASM_TRY_ADD_TO_CONTEXT(addElseToUnreachable(data.controlData));
<span class="line-modified"> 889         m_expressionStack = WTFMove(data.elseBlockStack);</span>
 890         return { };
 891     }
 892 
 893     case End: {
 894         if (m_unreachableBlocks == 1) {
 895             ControlEntry data = m_controlStack.takeLast();
<span class="line-modified"> 896             if (ControlType::isIf(data.controlData)) {</span>
<span class="line-added"> 897                 WASM_TRY_ADD_TO_CONTEXT(addElseToUnreachable(data.controlData));</span>
<span class="line-added"> 898                 m_expressionStack = WTFMove(data.elseBlockStack);</span>
<span class="line-added"> 899                 WASM_FAIL_IF_HELPER_FAILS(unify(data.controlData));</span>
<span class="line-added"> 900                 WASM_TRY_ADD_TO_CONTEXT(endBlock(data, m_expressionStack));</span>
<span class="line-added"> 901             } else</span>
<span class="line-added"> 902                 WASM_TRY_ADD_TO_CONTEXT(addEndToUnreachable(data));</span>
<span class="line-added"> 903 </span>
 904             m_expressionStack.swap(data.enclosedExpressionStack);
 905         }
 906         m_unreachableBlocks--;
 907         return { };
 908     }
 909 
 910     case Loop:
 911     case If:
 912     case Block: {
 913         m_unreachableBlocks++;
<span class="line-modified"> 914         BlockSignature unused;</span>
<span class="line-modified"> 915         WASM_PARSER_FAIL_IF(!parseBlockSignature(m_info, unused), &quot;can&#39;t get inline type for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);</span>
 916         return { };
 917     }
 918 
 919     case BrTable: {
 920         uint32_t numberOfTargets;
 921         uint32_t unused;
 922         WASM_PARSER_FAIL_IF(!parseVarUInt32(numberOfTargets), &quot;can&#39;t get the number of targets for br_table in unreachable context&quot;);
 923         WASM_PARSER_FAIL_IF(numberOfTargets == std::numeric_limits&lt;uint32_t&gt;::max(), &quot;br_table&#39;s number of targets is too big &quot;, numberOfTargets);
 924 
 925         for (uint32_t i = 0; i &lt; numberOfTargets; ++i)
 926             WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get &quot;, i, &quot;th target for br_table in unreachable context&quot;);
 927 
 928         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get default target for br_table in unreachable context&quot;);
 929         return { };
 930     }
 931 
 932     case CallIndirect: {
 933         uint32_t unused;
 934         uint32_t unused2;
 935         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get call_indirect&#39;s signature index in unreachable context&quot;);
</pre>
<hr />
<pre>
1011         return { };
1012     }
1013 
1014     // no immediate cases
1015     FOR_EACH_WASM_BINARY_OP(CREATE_CASE)
1016     FOR_EACH_WASM_UNARY_OP(CREATE_CASE)
1017     case Unreachable:
1018     case Nop:
1019     case Return:
1020     case Select:
1021     case Drop: {
1022         return { };
1023     }
1024     }
1025 #undef CREATE_CASE
1026     RELEASE_ASSERT_NOT_REACHED();
1027 }
1028 
1029 } } // namespace JSC::Wasm
1030 
<span class="line-added">1031 #undef WASM_TRY_POP_EXPRESSION_STACK_INTO</span>
<span class="line-added">1032 #undef WASM_TRY_ADD_TO_CONTEXT</span>
<span class="line-added">1033 #undef WASM_VALIDATOR_FAIL_IF</span>
<span class="line-added">1034 </span>
1035 #endif // ENABLE(WEBASSEMBLY)
</pre>
</td>
</tr>
</table>
<center><a href="WasmFormat.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmInstance.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
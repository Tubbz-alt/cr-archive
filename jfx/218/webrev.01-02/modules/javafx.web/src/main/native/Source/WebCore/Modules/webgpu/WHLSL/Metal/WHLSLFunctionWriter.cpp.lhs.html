<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLFunctionWriter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLFunctionWriter.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
 31 #include &quot;NotImplemented.h&quot;
 32 #include &quot;WHLSLAST.h&quot;
 33 #include &quot;WHLSLEntryPointScaffolding.h&quot;
 34 #include &quot;WHLSLInferTypes.h&quot;
 35 #include &quot;WHLSLNativeFunctionWriter.h&quot;
 36 #include &quot;WHLSLProgram.h&quot;
 37 #include &quot;WHLSLTypeNamer.h&quot;
 38 #include &quot;WHLSLVisitor.h&quot;
 39 #include &lt;wtf/HashMap.h&gt;
 40 #include &lt;wtf/HashSet.h&gt;
 41 #include &lt;wtf/SetForScope.h&gt;
 42 #include &lt;wtf/text/StringBuilder.h&gt;
 43 
 44 namespace WebCore {
 45 
 46 namespace WHLSL {
 47 
 48 namespace Metal {
 49 
 50 static void declareFunction(StringBuilder&amp; stringBuilder, AST::FunctionDeclaration&amp; functionDeclaration, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping)
 51 {
 52     if (functionDeclaration.entryPointType())
 53         return;
 54 
 55     auto iterator = functionMapping.find(&amp;functionDeclaration);
 56     ASSERT(iterator != functionMapping.end());
 57     stringBuilder.append(typeNamer.mangledNameForType(functionDeclaration.type()), &#39; &#39;, iterator-&gt;value, &#39;(&#39;);
 58     for (size_t i = 0; i &lt; functionDeclaration.parameters().size(); ++i) {
 59         if (i)
 60             stringBuilder.append(&quot;, &quot;);
 61         stringBuilder.append(typeNamer.mangledNameForType(*functionDeclaration.parameters()[i]-&gt;type()));
 62     }
 63     stringBuilder.append(&quot;);\n&quot;);
 64 }
 65 
<a name="1" id="anc1"></a>




 66 class FunctionDefinitionWriter : public Visitor {
<a name="2" id="anc2"></a>












































 67 public:
 68     FunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, Layout&amp; layout)
 69         : m_stringBuilder(stringBuilder)
 70         , m_intrinsics(intrinsics)
 71         , m_typeNamer(typeNamer)
 72         , m_functionMapping(functionMapping)
 73         , m_layout(layout)
 74     {
 75     }
 76 
 77     virtual ~FunctionDefinitionWriter() = default;
 78 
 79     void visit(AST::NativeFunctionDeclaration&amp;) override;
 80     void visit(AST::FunctionDefinition&amp;) override;
 81 
 82 protected:
 83     virtual std::unique_ptr&lt;EntryPointScaffolding&gt; createEntryPointScaffolding(AST::FunctionDefinition&amp;) = 0;
 84 
 85     void visit(AST::FunctionDeclaration&amp;) override;
 86     void visit(AST::Statement&amp;) override;
 87     void visit(AST::Block&amp;) override;
 88     void visit(AST::Break&amp;) override;
 89     void visit(AST::Continue&amp;) override;
 90     void visit(AST::DoWhileLoop&amp;) override;
 91     void visit(AST::EffectfulExpressionStatement&amp;) override;
 92     void visit(AST::Fallthrough&amp;) override;
 93     void visit(AST::ForLoop&amp;) override;
 94     void visit(AST::IfStatement&amp;) override;
 95     void visit(AST::Return&amp;) override;
 96     void visit(AST::SwitchStatement&amp;) override;
 97     void visit(AST::SwitchCase&amp;) override;
 98     void visit(AST::VariableDeclarationsStatement&amp;) override;
 99     void visit(AST::WhileLoop&amp;) override;
100     void visit(AST::IntegerLiteral&amp;) override;
101     void visit(AST::UnsignedIntegerLiteral&amp;) override;
102     void visit(AST::FloatLiteral&amp;) override;
<a name="3" id="anc3"></a><span class="line-removed">103     void visit(AST::NullLiteral&amp;) override;</span>
104     void visit(AST::BooleanLiteral&amp;) override;
105     void visit(AST::EnumerationMemberLiteral&amp;) override;
106     void visit(AST::Expression&amp;) override;
<a name="4" id="anc4"></a><span class="line-removed">107     void visit(AST::DotExpression&amp;) override;</span>
108     void visit(AST::GlobalVariableReference&amp;) override;
<a name="5" id="anc5"></a>
109     void visit(AST::IndexExpression&amp;) override;
<a name="6" id="anc6"></a><span class="line-removed">110     void visit(AST::PropertyAccessExpression&amp;) override;</span>
111     void visit(AST::VariableDeclaration&amp;) override;
112     void visit(AST::AssignmentExpression&amp;) override;
113     void visit(AST::CallExpression&amp;) override;
114     void visit(AST::CommaExpression&amp;) override;
115     void visit(AST::DereferenceExpression&amp;) override;
116     void visit(AST::LogicalExpression&amp;) override;
117     void visit(AST::LogicalNotExpression&amp;) override;
118     void visit(AST::MakeArrayReferenceExpression&amp;) override;
119     void visit(AST::MakePointerExpression&amp;) override;
120     void visit(AST::ReadModifyWriteExpression&amp;) override;
121     void visit(AST::TernaryExpression&amp;) override;
122     void visit(AST::VariableReference&amp;) override;
123 
124     enum class LoopConditionLocation {
125         BeforeBody,
126         AfterBody
127     };
128     void emitLoop(LoopConditionLocation, AST::Expression* conditionExpression, AST::Expression* increment, AST::Statement&amp; body);
129 
130     void emitConstantExpressionString(AST::ConstantExpression&amp;);
131 
132     MangledVariableName generateNextVariableName() { return { m_variableCount++ }; }
133 
<a name="7" id="anc7"></a><span class="line-removed">134     enum class Nullability : uint8_t {</span>
<span class="line-removed">135         NotNull,</span>
<span class="line-removed">136         CanBeNull</span>
<span class="line-removed">137     };</span>
<span class="line-removed">138 </span>
<span class="line-removed">139     struct StackItem {</span>
<span class="line-removed">140         MangledVariableName value;</span>
<span class="line-removed">141         MangledVariableName leftValue;</span>
<span class="line-removed">142         Nullability valueNullability;</span>
<span class="line-removed">143         Nullability leftValueNullability;</span>
<span class="line-removed">144         std::function&lt;MangledVariableName()&gt; generateLeftValue;</span>
<span class="line-removed">145     };</span>
<span class="line-removed">146 </span>
<span class="line-removed">147     struct StackValue {</span>
<span class="line-removed">148         MangledVariableName value;</span>
<span class="line-removed">149         Nullability nullability;</span>
<span class="line-removed">150     };</span>
<span class="line-removed">151 </span>
<span class="line-removed">152     // This is the important data flow step where we can take the nullability of an lvalue</span>
<span class="line-removed">153     // and transfer it into the nullability of an rvalue. This is conveyed in MakePointerExpression</span>
<span class="line-removed">154     // and DereferenceExpression. MakePointerExpression will try to produce rvalues which are</span>
<span class="line-removed">155     // non-null, and DereferenceExpression will take a non-null rvalue and try to produce</span>
<span class="line-removed">156     // a non-null lvalue.</span>
<span class="line-removed">157     void appendRightValueWithNullability(AST::Expression&amp;, MangledVariableName value, Nullability nullability)</span>
<span class="line-removed">158     {</span>
<span class="line-removed">159         m_stack.append({ WTFMove(value), { }, nullability, Nullability::CanBeNull, { } });</span>
<span class="line-removed">160     }</span>
<span class="line-removed">161 </span>
<span class="line-removed">162     void appendRightValue(AST::Expression&amp; expression, MangledVariableName value)</span>
<span class="line-removed">163     {</span>
<span class="line-removed">164         appendRightValueWithNullability(expression, WTFMove(value), Nullability::CanBeNull);</span>
<span class="line-removed">165     }</span>
<span class="line-removed">166 </span>
<span class="line-removed">167     void appendLeftValue(AST::Expression&amp; expression, MangledVariableName value, MangledVariableName leftValue, Nullability nullability, std::function&lt;MangledVariableName()&gt; generateLeftValue = { })</span>
<span class="line-removed">168     {</span>
<span class="line-removed">169         ASSERT_UNUSED(expression, expression.typeAnnotation().leftAddressSpace());</span>
<span class="line-removed">170         ASSERT(leftValue || generateLeftValue);</span>
<span class="line-removed">171         m_stack.append({ WTFMove(value), WTFMove(leftValue), Nullability::CanBeNull, nullability, WTFMove(generateLeftValue) });</span>
<span class="line-removed">172     }</span>
<span class="line-removed">173 </span>
<span class="line-removed">174     MangledVariableName takeLastValue()</span>
<span class="line-removed">175     {</span>
<span class="line-removed">176         return m_stack.takeLast().value;</span>
<span class="line-removed">177     }</span>
<span class="line-removed">178 </span>
<span class="line-removed">179     StackValue takeLastValueAndNullability()</span>
<span class="line-removed">180     {</span>
<span class="line-removed">181         auto last = m_stack.takeLast();</span>
<span class="line-removed">182         return { last.value, last.valueNullability };</span>
<span class="line-removed">183     }</span>
<span class="line-removed">184 </span>
<span class="line-removed">185     StackValue takeLastLeftValue()</span>
<span class="line-removed">186     {</span>
<span class="line-removed">187         auto last = m_stack.takeLast();</span>
<span class="line-removed">188         if (!last.leftValue)</span>
<span class="line-removed">189             last.leftValue = last.generateLeftValue();</span>
<span class="line-removed">190         return { last.leftValue, last.leftValueNullability };</span>
<span class="line-removed">191     }</span>
<span class="line-removed">192 </span>
193     enum class BreakContext {
194         Loop,
195         Switch
196     };
197 
198     Optional&lt;BreakContext&gt; m_currentBreakContext;
199 
200     StringBuilder&amp; m_stringBuilder;
201     Intrinsics&amp; m_intrinsics;
202     TypeNamer&amp; m_typeNamer;
203     HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; m_functionMapping;
204     HashMap&lt;AST::VariableDeclaration*, MangledVariableName&gt; m_variableMapping;
205 
<a name="8" id="anc8"></a><span class="line-removed">206     Vector&lt;StackItem&gt; m_stack;</span>
207     std::unique_ptr&lt;EntryPointScaffolding&gt; m_entryPointScaffolding;
208     Layout&amp; m_layout;
209     unsigned m_variableCount { 0 };
210     Optional&lt;MangledVariableName&gt; m_breakOutOfCurrentLoopEarlyVariable;
211     Indentation&lt;4&gt; m_indent { 0 };
<a name="9" id="anc9"></a>
212 };
213 
214 void FunctionDefinitionWriter::visit(AST::NativeFunctionDeclaration&amp;)
215 {
216     // We inline native function calls.
217 }
218 
219 void FunctionDefinitionWriter::visit(AST::FunctionDefinition&amp; functionDefinition)
220 {
<a name="10" id="anc10"></a>













221     auto iterator = m_functionMapping.find(&amp;functionDefinition);
222     ASSERT(iterator != m_functionMapping.end());
223     if (functionDefinition.entryPointType()) {
224         auto entryPointScaffolding = createEntryPointScaffolding(functionDefinition);
225         if (!entryPointScaffolding)
226             return;
227         m_entryPointScaffolding = WTFMove(entryPointScaffolding);
228 
229         m_entryPointScaffolding-&gt;emitHelperTypes(m_stringBuilder, m_indent);
230         m_entryPointScaffolding-&gt;emitSignature(m_stringBuilder, iterator-&gt;value, m_indent);
231         m_stringBuilder.append(m_indent, &quot;{\n&quot;);
232         {
233             IndentationScope scope(m_indent);
234 
235             m_entryPointScaffolding-&gt;emitUnpack(m_stringBuilder, m_indent);
236 
237             for (size_t i = 0; i &lt; functionDefinition.parameters().size(); ++i) {
238                 auto addResult = m_variableMapping.add(&amp;functionDefinition.parameters()[i], m_entryPointScaffolding-&gt;parameterVariables()[i]);
239                 ASSERT_UNUSED(addResult, addResult.isNewEntry);
240             }
<a name="11" id="anc11"></a>


241             checkErrorAndVisit(functionDefinition.block());
<a name="12" id="anc12"></a><span class="line-removed">242             ASSERT(m_stack.isEmpty());</span>
243         }
244         m_stringBuilder.append(&quot;}\n\n&quot;);
245 
246         m_entryPointScaffolding = nullptr;
247     } else {
248         ASSERT(m_entryPointScaffolding == nullptr);
249         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(functionDefinition.type()), &#39; &#39;, iterator-&gt;value, &#39;(&#39;);
250         for (size_t i = 0; i &lt; functionDefinition.parameters().size(); ++i) {
<a name="13" id="anc13"></a><span class="line-removed">251             auto&amp; parameter = functionDefinition.parameters()[i];</span>
252             if (i)
253                 m_stringBuilder.append(&quot;, &quot;);
<a name="14" id="anc14"></a>
254             auto parameterName = generateNextVariableName();
255             auto addResult = m_variableMapping.add(&amp;parameter, parameterName);
256             ASSERT_UNUSED(addResult, addResult.isNewEntry);
257             m_stringBuilder.append(m_typeNamer.mangledNameForType(*parameter-&gt;type()), &#39; &#39;, parameterName);
258         }
259         m_stringBuilder.append(&quot;)\n&quot;);
<a name="15" id="anc15"></a>




260         checkErrorAndVisit(functionDefinition.block());
<a name="16" id="anc16"></a><span class="line-modified">261         ASSERT(m_stack.isEmpty());</span>
262         m_stringBuilder.append(&#39;\n&#39;);
263     }
264 }
265 
266 void FunctionDefinitionWriter::visit(AST::FunctionDeclaration&amp;)
267 {
268     ASSERT_NOT_REACHED();
269 }
270 
271 void FunctionDefinitionWriter::visit(AST::Statement&amp; statement)
272 {
273     Visitor::visit(statement);
274 }
275 
276 void FunctionDefinitionWriter::visit(AST::Block&amp; block)
277 {
278     m_stringBuilder.append(m_indent, &quot;{\n&quot;);
279     {
280         IndentationScope scope(m_indent);
281         for (auto&amp; statement : block.statements())
282             checkErrorAndVisit(statement);
283     }
284     m_stringBuilder.append(m_indent, &quot;}\n&quot;);
285 }
286 
287 void FunctionDefinitionWriter::visit(AST::Break&amp;)
288 {
289     ASSERT(m_currentBreakContext);
290     switch (*m_currentBreakContext) {
291     case BreakContext::Switch:
292         m_stringBuilder.append(m_indent, &quot;break;\n&quot;);
293         break;
294     case BreakContext::Loop:
295         ASSERT(m_breakOutOfCurrentLoopEarlyVariable);
296         m_stringBuilder.append(
297             m_indent, *m_breakOutOfCurrentLoopEarlyVariable, &quot; = true;\n&quot;,
298             m_indent, &quot;break;\n&quot;
299         );
300         break;
301     }
302 }
303 
304 void FunctionDefinitionWriter::visit(AST::Continue&amp;)
305 {
306     ASSERT(m_breakOutOfCurrentLoopEarlyVariable);
307     m_stringBuilder.append(m_indent, &quot;break;\n&quot;);
308 }
309 
310 void FunctionDefinitionWriter::visit(AST::EffectfulExpressionStatement&amp; effectfulExpressionStatement)
311 {
<a name="17" id="anc17"></a>
312     checkErrorAndVisit(effectfulExpressionStatement.effectfulExpression());
<a name="18" id="anc18"></a><span class="line-modified">313     takeLastValue(); // The statement is already effectful, so we don&#39;t need to do anything with the result.</span>
314 }
315 
316 void FunctionDefinitionWriter::visit(AST::Fallthrough&amp;)
317 {
318     m_stringBuilder.append(m_indent, &quot;[[clang::fallthrough]];\n&quot;); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195808 Make sure this is okay. Alternatively, we could do nothing and just return here instead.
319 }
320 
321 void FunctionDefinitionWriter::emitLoop(LoopConditionLocation loopConditionLocation, AST::Expression* conditionExpression, AST::Expression* increment, AST::Statement&amp; body)
322 {
323     SetForScope&lt;Optional&lt;MangledVariableName&gt;&gt; loopVariableScope(m_breakOutOfCurrentLoopEarlyVariable, generateNextVariableName());
324 
325     m_stringBuilder.append(
326         m_indent, &quot;bool &quot;, *m_breakOutOfCurrentLoopEarlyVariable, &quot; = false;\n&quot;,
327         m_indent, &quot;while (true) {\n&quot;
328     );
329     {
330         IndentationScope whileScope(m_indent);
331 
332         if (loopConditionLocation == LoopConditionLocation::BeforeBody &amp;&amp; conditionExpression) {
<a name="19" id="anc19"></a>

333             checkErrorAndVisit(*conditionExpression);
334             m_stringBuilder.append(
<a name="20" id="anc20"></a><span class="line-modified">335                 m_indent, &quot;if (!&quot;, takeLastValue(), &quot;)\n&quot;,</span>
<span class="line-modified">336                 m_indent, &quot;    break;\n&quot;);</span>
337         }
338 
339         m_stringBuilder.append(m_indent, &quot;do {\n&quot;);
340         SetForScope&lt;Optional&lt;BreakContext&gt;&gt; breakContext(m_currentBreakContext, BreakContext::Loop);
341 
342         {
343             IndentationScope doScope(m_indent);
344             checkErrorAndVisit(body);
345         }
346         m_stringBuilder.append(m_indent, &quot;} while(false); \n&quot;);
347 
348         m_stringBuilder.append(
349             m_indent, &quot;if (&quot;, *m_breakOutOfCurrentLoopEarlyVariable, &quot;)\n&quot;,
350             m_indent, &quot;    break;\n&quot;);
351 
352         if (increment) {
<a name="21" id="anc21"></a>
353             checkErrorAndVisit(*increment);
<a name="22" id="anc22"></a><span class="line-modified">354             // Expression results get pushed to m_stack. We don&#39;t use the result</span>
<span class="line-removed">355             // of increment, so we dispense of that now.</span>
<span class="line-removed">356             takeLastValue();</span>
357         }
358 
359         if (loopConditionLocation == LoopConditionLocation::AfterBody &amp;&amp; conditionExpression) {
<a name="23" id="anc23"></a>

360             checkErrorAndVisit(*conditionExpression);
361             m_stringBuilder.append(
<a name="24" id="anc24"></a><span class="line-modified">362                 m_indent, &quot;if (!&quot;, takeLastValue(), &quot;)\n&quot;,</span>
<span class="line-modified">363                 m_indent, &quot;    break;\n&quot;);</span>
364         }
365     }
366 
367     m_stringBuilder.append(m_indent, &quot;} \n&quot;);
368 }
369 
370 void FunctionDefinitionWriter::visit(AST::DoWhileLoop&amp; doWhileLoop)
371 {
372     emitLoop(LoopConditionLocation::AfterBody, &amp;doWhileLoop.conditional(), nullptr, doWhileLoop.body());
373 }
374 
375 void FunctionDefinitionWriter::visit(AST::WhileLoop&amp; whileLoop)
376 {
377     emitLoop(LoopConditionLocation::BeforeBody, &amp;whileLoop.conditional(), nullptr, whileLoop.body());
378 }
379 
380 void FunctionDefinitionWriter::visit(AST::ForLoop&amp; forLoop)
381 {
382     m_stringBuilder.append(m_indent, &quot;{\n&quot;);
383     {
384         IndentationScope scope(m_indent);
385         checkErrorAndVisit(forLoop.initialization());
386         emitLoop(LoopConditionLocation::BeforeBody, forLoop.condition(), forLoop.increment(), forLoop.body());
387     }
388     m_stringBuilder.append(m_indent, &quot;}\n&quot;);
389 }
390 
391 void FunctionDefinitionWriter::visit(AST::IfStatement&amp; ifStatement)
392 {
<a name="25" id="anc25"></a>
393     checkErrorAndVisit(ifStatement.conditional());
<a name="26" id="anc26"></a><span class="line-modified">394     m_stringBuilder.append(m_indent, &quot;if (&quot;, takeLastValue(), &quot;) {\n&quot;);</span>

395     {
396         IndentationScope ifScope(m_indent);
397         checkErrorAndVisit(ifStatement.body());
398     }
<a name="27" id="anc27"></a>
399     if (ifStatement.elseBody()) {
400         m_stringBuilder.append(m_indent, &quot;} else {\n&quot;);
401         {
402             IndentationScope elseScope(m_indent);
403             checkErrorAndVisit(*ifStatement.elseBody());
404         }
405     }
<a name="28" id="anc28"></a>
406     m_stringBuilder.append(m_indent, &quot;}\n&quot;);
407 }
408 
409 void FunctionDefinitionWriter::visit(AST::Return&amp; returnStatement)
410 {
411     if (returnStatement.value()) {
<a name="29" id="anc29"></a>

412         checkErrorAndVisit(*returnStatement.value());
<a name="30" id="anc30"></a>
413 
414         if (m_entryPointScaffolding) {
415             auto variableName = generateNextVariableName();
<a name="31" id="anc31"></a><span class="line-modified">416             m_entryPointScaffolding-&gt;emitPack(m_stringBuilder, takeLastValue(), variableName, m_indent);</span>
417             m_stringBuilder.append(m_indent, &quot;return &quot;, variableName, &quot;;\n&quot;);
418         } else
<a name="32" id="anc32"></a><span class="line-modified">419             m_stringBuilder.append(m_indent, &quot;return &quot;, takeLastValue(), &quot;;\n&quot;);</span>
420     } else
421         m_stringBuilder.append(m_indent, &quot;return;\n&quot;);
422 }
423 
424 void FunctionDefinitionWriter::visit(AST::SwitchStatement&amp; switchStatement)
425 {
<a name="33" id="anc33"></a>
426     checkErrorAndVisit(switchStatement.value());
<a name="34" id="anc34"></a>
427 
<a name="35" id="anc35"></a><span class="line-removed">428     m_stringBuilder.append(m_indent, &quot;switch (&quot;, takeLastValue(), &quot;) {&quot;);</span>
429     {
430         IndentationScope switchScope(m_indent);
431         for (auto&amp; switchCase : switchStatement.switchCases())
432             checkErrorAndVisit(switchCase);
433     }
434     m_stringBuilder.append(m_indent, &quot;}\n&quot;);
435 }
436 
437 void FunctionDefinitionWriter::visit(AST::SwitchCase&amp; switchCase)
438 {
439     if (switchCase.value()) {
440         m_stringBuilder.append(m_indent, &quot;case &quot;);
441         emitConstantExpressionString(*switchCase.value());
442         m_stringBuilder.append(&quot;:\n&quot;);
443     } else
444         m_stringBuilder.append(m_indent, &quot;default:\n&quot;);
445     SetForScope&lt;Optional&lt;BreakContext&gt;&gt; breakContext(m_currentBreakContext, BreakContext::Switch);
446     checkErrorAndVisit(switchCase.block());
447     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195812 Figure out whether we need to break or fallthrough.
448 }
449 
450 void FunctionDefinitionWriter::visit(AST::VariableDeclarationsStatement&amp; variableDeclarationsStatement)
451 {
452     Visitor::visit(variableDeclarationsStatement);
453 }
454 
455 void FunctionDefinitionWriter::visit(AST::IntegerLiteral&amp; integerLiteral)
456 {
<a name="36" id="anc36"></a><span class="line-removed">457     auto variableName = generateNextVariableName();</span>
458     auto mangledTypeName = m_typeNamer.mangledNameForType(integerLiteral.resolvedType());
<a name="37" id="anc37"></a><span class="line-modified">459     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, integerLiteral.value(), &quot;);\n&quot;);</span>
<span class="line-removed">460     appendRightValue(integerLiteral, variableName);</span>
461 }
462 
463 void FunctionDefinitionWriter::visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral)
464 {
<a name="38" id="anc38"></a><span class="line-removed">465     auto variableName = generateNextVariableName();</span>
466     auto mangledTypeName = m_typeNamer.mangledNameForType(unsignedIntegerLiteral.resolvedType());
<a name="39" id="anc39"></a><span class="line-modified">467     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, unsignedIntegerLiteral.value(), &quot;);\n&quot;);</span>
<span class="line-removed">468     appendRightValue(unsignedIntegerLiteral, variableName);</span>
469 }
470 
471 void FunctionDefinitionWriter::visit(AST::FloatLiteral&amp; floatLiteral)
472 {
<a name="40" id="anc40"></a><span class="line-removed">473     auto variableName = generateNextVariableName();</span>
474     auto mangledTypeName = m_typeNamer.mangledNameForType(floatLiteral.resolvedType());
<a name="41" id="anc41"></a><span class="line-modified">475     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, floatLiteral.value(), &quot;);\n&quot;);</span>
<span class="line-removed">476     appendRightValue(floatLiteral, variableName);</span>
<span class="line-removed">477 }</span>
<span class="line-removed">478 </span>
<span class="line-removed">479 void FunctionDefinitionWriter::visit(AST::NullLiteral&amp; nullLiteral)</span>
<span class="line-removed">480 {</span>
<span class="line-removed">481     auto&amp; unifyNode = nullLiteral.resolvedType().unifyNode();</span>
<span class="line-removed">482     auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);</span>
<span class="line-removed">483     bool isArrayReferenceType = is&lt;AST::ArrayReferenceType&gt;(unnamedType);</span>
<span class="line-removed">484 </span>
<span class="line-removed">485     auto variableName = generateNextVariableName();</span>
<span class="line-removed">486     m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(nullLiteral.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;);</span>
<span class="line-removed">487     if (isArrayReferenceType)</span>
<span class="line-removed">488         m_stringBuilder.append(&quot;{ nullptr, 0 };\n&quot;);</span>
<span class="line-removed">489     else</span>
<span class="line-removed">490         m_stringBuilder.append(&quot;nullptr;\n&quot;);</span>
<span class="line-removed">491     appendRightValue(nullLiteral, variableName);</span>
492 }
493 
494 void FunctionDefinitionWriter::visit(AST::BooleanLiteral&amp; booleanLiteral)
495 {
<a name="42" id="anc42"></a><span class="line-removed">496     auto variableName = generateNextVariableName();</span>
497     auto mangledTypeName = m_typeNamer.mangledNameForType(booleanLiteral.resolvedType());
<a name="43" id="anc43"></a><span class="line-modified">498     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, booleanLiteral.value() ? &quot;true&quot; : &quot;false&quot;, &quot;);\n&quot;);</span>
<span class="line-removed">499     appendRightValue(booleanLiteral, variableName);</span>
500 }
501 
502 void FunctionDefinitionWriter::visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral)
503 {
504     ASSERT(enumerationMemberLiteral.enumerationDefinition());
505     ASSERT(enumerationMemberLiteral.enumerationDefinition());
<a name="44" id="anc44"></a><span class="line-removed">506     auto variableName = generateNextVariableName();</span>
507     auto mangledTypeName = m_typeNamer.mangledNameForType(enumerationMemberLiteral.resolvedType());
<a name="45" id="anc45"></a><span class="line-modified">508     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = &quot;, mangledTypeName, &quot;::&quot;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()), &quot;;\n&quot;);</span>
<span class="line-removed">509     appendRightValue(enumerationMemberLiteral, variableName);</span>
510 }
511 
512 void FunctionDefinitionWriter::visit(AST::Expression&amp; expression)
513 {
514     Visitor::visit(expression);
515 }
516 
<a name="46" id="anc46"></a><span class="line-removed">517 void FunctionDefinitionWriter::visit(AST::DotExpression&amp; dotExpression)</span>
<span class="line-removed">518 {</span>
<span class="line-removed">519     // This should be lowered already.</span>
<span class="line-removed">520     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195788 Replace this with ASSERT_NOT_REACHED().</span>
<span class="line-removed">521     notImplemented();</span>
<span class="line-removed">522     appendRightValue(dotExpression, generateNextVariableName());</span>
<span class="line-removed">523 }</span>
<span class="line-removed">524 </span>
525 void FunctionDefinitionWriter::visit(AST::GlobalVariableReference&amp; globalVariableReference)
526 {
<a name="47" id="anc47"></a><span class="line-modified">527     auto valueName = generateNextVariableName();</span>
<span class="line-modified">528     MangledTypeName mangledTypeName = m_typeNamer.mangledNameForType(globalVariableReference.resolvedType());</span>
<span class="line-removed">529 </span>
530     checkErrorAndVisit(globalVariableReference.base());
<a name="48" id="anc48"></a><span class="line-modified">531     MangledVariableName structVariable = takeLastValue();</span>

532 
<a name="49" id="anc49"></a><span class="line-modified">533     MangledStructureElementName mangledFieldName = m_typeNamer.mangledNameForStructureElement(globalVariableReference.structField());</span>


534 
<a name="50" id="anc50"></a><span class="line-modified">535     m_stringBuilder.append(</span>
<span class="line-modified">536         m_indent, mangledTypeName, &#39; &#39;, valueName, &quot; = &quot;, structVariable, &quot;-&gt;&quot;, mangledFieldName, &quot;;\n&quot;);</span>



537 
<a name="51" id="anc51"></a><span class="line-modified">538     appendLeftValue(globalVariableReference, valueName, { }, Nullability::NotNull,</span>
<span class="line-modified">539         [this, mangledTypeName, structVariable, mangledFieldName] {</span>
<span class="line-modified">540             auto pointerName = generateNextVariableName();</span>
<span class="line-modified">541             m_stringBuilder.append(</span>
<span class="line-modified">542                 m_indent, &quot;thread &quot;, mangledTypeName, &quot;* &quot;, pointerName, &quot; = &amp;&quot;, structVariable, &quot;-&gt;&quot;, mangledFieldName, &quot;;\n&quot;);</span>
<span class="line-modified">543             return pointerName;</span>
<span class="line-modified">544         });</span>


















545 }
546 
547 void FunctionDefinitionWriter::visit(AST::IndexExpression&amp; indexExpression)
548 {
<a name="52" id="anc52"></a><span class="line-modified">549     // This should be lowered already.</span>
<span class="line-modified">550     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195788 Replace this with ASSERT_NOT_REACHED().</span>
<span class="line-modified">551     notImplemented();</span>
<span class="line-modified">552     appendRightValue(indexExpression, generateNextVariableName());</span>
<span class="line-modified">553 }</span>
<span class="line-modified">554 </span>
<span class="line-modified">555 void FunctionDefinitionWriter::visit(AST::PropertyAccessExpression&amp; propertyAccessExpression)</span>
<span class="line-modified">556 {</span>
<span class="line-modified">557     // This should be lowered already.</span>
<span class="line-modified">558     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195788 Replace this with ASSERT_NOT_REACHED().</span>
<span class="line-modified">559     notImplemented();</span>
<span class="line-modified">560     appendRightValue(propertyAccessExpression, generateNextVariableName());</span>


























561 }
562 
563 void FunctionDefinitionWriter::visit(AST::VariableDeclaration&amp; variableDeclaration)
564 {
565     ASSERT(variableDeclaration.type());
566     auto variableName = generateNextVariableName();
567     auto addResult = m_variableMapping.add(&amp;variableDeclaration, variableName);
568     ASSERT_UNUSED(addResult, addResult.isNewEntry);
569     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198160 Implement qualifiers.
570     if (variableDeclaration.initializer()) {
<a name="53" id="anc53"></a>
571         checkErrorAndVisit(*variableDeclaration.initializer());
<a name="54" id="anc54"></a><span class="line-modified">572         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(*variableDeclaration.type()), &#39; &#39;, variableName, &quot; = &quot;, takeLastValue(), &quot;;\n&quot;);</span>
573     } else
574         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(*variableDeclaration.type()), &#39; &#39;, variableName, &quot; = { };\n&quot;);
575 }
576 
577 void FunctionDefinitionWriter::visit(AST::AssignmentExpression&amp; assignmentExpression)
578 {
<a name="55" id="anc55"></a>
579     checkErrorAndVisit(assignmentExpression.left());
<a name="56" id="anc56"></a><span class="line-modified">580     auto [pointerName, nullability] = takeLastLeftValue();</span>

581     checkErrorAndVisit(assignmentExpression.right());
<a name="57" id="anc57"></a><span class="line-modified">582     auto [rightName, rightNullability] = takeLastValueAndNullability();</span>
<span class="line-removed">583 </span>
<span class="line-removed">584     if (nullability == Nullability::CanBeNull)</span>
<span class="line-removed">585         m_stringBuilder.append(</span>
<span class="line-removed">586             m_indent, &quot;if (&quot;, pointerName, &quot;)\n&quot;,</span>
<span class="line-removed">587             m_indent, &quot;    *&quot;, pointerName, &quot; = &quot;, rightName, &quot;;\n&quot;);</span>
<span class="line-removed">588     else</span>
<span class="line-removed">589         m_stringBuilder.append(m_indent, &quot;*&quot;, pointerName, &quot; = &quot;, rightName, &quot;;\n&quot;);</span>
<span class="line-removed">590     appendRightValueWithNullability(assignmentExpression, rightName, rightNullability);</span>
591 }
592 
593 void FunctionDefinitionWriter::visit(AST::CallExpression&amp; callExpression)
594 {
<a name="58" id="anc58"></a>



595     Vector&lt;MangledVariableName&gt; argumentNames;
<a name="59" id="anc59"></a><span class="line-removed">596     for (auto&amp; argument : callExpression.arguments()) {</span>
<span class="line-removed">597         checkErrorAndVisit(argument);</span>
<span class="line-removed">598         argumentNames.append(takeLastValue());</span>
<span class="line-removed">599     }</span>
600 
<a name="60" id="anc60"></a><span class="line-modified">601     bool isVoid = matches(callExpression.resolvedType(), m_intrinsics.voidType());</span>
<span class="line-modified">602     MangledVariableName returnName;</span>
<span class="line-modified">603     if (!isVoid) {</span>
<span class="line-modified">604         returnName = generateNextVariableName();</span>
<span class="line-modified">605         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(callExpression.resolvedType()), &#39; &#39;, returnName, &quot;;\n&quot;);</span>





606     }
607 
608     if (is&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function())) {
<a name="61" id="anc61"></a><span class="line-modified">609         auto generateNextVariableName = [this]() -&gt; MangledVariableName {</span>
<span class="line-removed">610             return this-&gt;generateNextVariableName();</span>
<span class="line-removed">611         };</span>
<span class="line-removed">612 </span>
<span class="line-removed">613         m_stringBuilder.append(&#39;\n&#39;);</span>
<span class="line-removed">614         inlineNativeFunction(m_stringBuilder, downcast&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function()), returnName, argumentNames, m_intrinsics, m_typeNamer, WTFMove(generateNextVariableName), m_indent);</span>
<span class="line-removed">615         m_stringBuilder.append(&#39;\n&#39;);</span>
616     } else {
<a name="62" id="anc62"></a><span class="line-removed">617         m_stringBuilder.append(m_indent);</span>
<span class="line-removed">618 </span>
619         auto iterator = m_functionMapping.find(&amp;callExpression.function());
620         ASSERT(iterator != m_functionMapping.end());
<a name="63" id="anc63"></a><span class="line-removed">621         if (!isVoid)</span>
<span class="line-removed">622             m_stringBuilder.append(returnName, &quot; = &quot;);</span>
623         m_stringBuilder.append(iterator-&gt;value, &#39;(&#39;);
<a name="64" id="anc64"></a><span class="line-modified">624         for (size_t i = 0; i &lt; argumentNames.size(); ++i) {</span>
625             if (i)
626                 m_stringBuilder.append(&quot;, &quot;);
<a name="65" id="anc65"></a><span class="line-modified">627             m_stringBuilder.append(argumentNames[i]);</span>
628         }
<a name="66" id="anc66"></a><span class="line-modified">629         m_stringBuilder.append(&quot;);\n&quot;);</span>
630     }
631 
<a name="67" id="anc67"></a><span class="line-modified">632     appendRightValue(callExpression, returnName);</span>
633 }
634 
635 void FunctionDefinitionWriter::visit(AST::CommaExpression&amp; commaExpression)
636 {
<a name="68" id="anc68"></a><span class="line-modified">637     Optional&lt;MangledVariableName&gt; result;</span>

638     for (auto&amp; expression : commaExpression.list()) {
<a name="69" id="anc69"></a>


639         checkErrorAndVisit(expression);
<a name="70" id="anc70"></a><span class="line-removed">640         result = takeLastValue();</span>
641     }
<a name="71" id="anc71"></a><span class="line-modified">642     ASSERT(result);</span>
<span class="line-removed">643     appendRightValue(commaExpression, *result);</span>
644 }
645 
646 void FunctionDefinitionWriter::visit(AST::DereferenceExpression&amp; dereferenceExpression)
647 {
<a name="72" id="anc72"></a>
648     checkErrorAndVisit(dereferenceExpression.pointer());
<a name="73" id="anc73"></a><span class="line-modified">649     auto [inputPointer, nullability] = takeLastValueAndNullability();</span>
<span class="line-removed">650     auto resultValue = generateNextVariableName();</span>
<span class="line-removed">651     auto resultType = m_typeNamer.mangledNameForType(dereferenceExpression.resolvedType());</span>
<span class="line-removed">652 </span>
<span class="line-removed">653     if (nullability == Nullability::CanBeNull) {</span>
<span class="line-removed">654         m_stringBuilder.append(</span>
<span class="line-removed">655             m_indent, resultType , &#39; &#39;, resultValue, &quot; = &quot;, inputPointer, &quot; ? &quot;, &#39;*&#39;, inputPointer, &quot; : &quot;, resultType, &quot;{ };\n&quot;);</span>
<span class="line-removed">656     } else</span>
<span class="line-removed">657         m_stringBuilder.append(m_indent, resultValue, &quot; = *&quot;, inputPointer, &quot;;\n&quot;);</span>
<span class="line-removed">658 </span>
<span class="line-removed">659     appendLeftValue(dereferenceExpression, resultValue, inputPointer, nullability);</span>
660 }
661 
662 void FunctionDefinitionWriter::visit(AST::LogicalExpression&amp; logicalExpression)
663 {
<a name="74" id="anc74"></a>
664     checkErrorAndVisit(logicalExpression.left());
<a name="75" id="anc75"></a><span class="line-modified">665     auto left = takeLastValue();</span>
<span class="line-removed">666     checkErrorAndVisit(logicalExpression.right());</span>
<span class="line-removed">667     auto right = takeLastValue();</span>
<span class="line-removed">668     auto variableName = generateNextVariableName();</span>
669 
<a name="76" id="anc76"></a><span class="line-removed">670     m_stringBuilder.append(</span>
<span class="line-removed">671         m_indent, m_typeNamer.mangledNameForType(logicalExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, left);</span>
672     switch (logicalExpression.type()) {
673     case AST::LogicalExpression::Type::And:
674         m_stringBuilder.append(&quot; &amp;&amp; &quot;);
675         break;
<a name="77" id="anc77"></a><span class="line-modified">676     default:</span>
<span class="line-removed">677         ASSERT(logicalExpression.type() == AST::LogicalExpression::Type::Or);</span>
678         m_stringBuilder.append(&quot; || &quot;);
679         break;
680     }
<a name="78" id="anc78"></a><span class="line-modified">681     m_stringBuilder.append(right, &quot;;\n&quot;);</span>
<span class="line-modified">682     appendRightValue(logicalExpression, variableName);</span>


683 }
684 
685 void FunctionDefinitionWriter::visit(AST::LogicalNotExpression&amp; logicalNotExpression)
686 {
<a name="79" id="anc79"></a>
687     checkErrorAndVisit(logicalNotExpression.operand());
<a name="80" id="anc80"></a><span class="line-modified">688     auto operand = takeLastValue();</span>
<span class="line-removed">689     auto variableName = generateNextVariableName();</span>
<span class="line-removed">690 </span>
<span class="line-removed">691     m_stringBuilder.append(</span>
<span class="line-removed">692         m_indent, m_typeNamer.mangledNameForType(logicalNotExpression.resolvedType()), &#39; &#39;, variableName, &quot; = !&quot;, operand, &quot;;\n&quot;);</span>
<span class="line-removed">693     appendRightValue(logicalNotExpression, variableName);</span>
694 }
695 
696 void FunctionDefinitionWriter::visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression)
697 {
<a name="81" id="anc81"></a><span class="line-removed">698     checkErrorAndVisit(makeArrayReferenceExpression.leftValue());</span>
699     // FIXME: This needs to be made to work. It probably should be using the last leftValue too.
700     // https://bugs.webkit.org/show_bug.cgi?id=198838
<a name="82" id="anc82"></a><span class="line-removed">701     auto variableName = generateNextVariableName();</span>
<span class="line-removed">702 </span>
703     auto mangledTypeName = m_typeNamer.mangledNameForType(makeArrayReferenceExpression.resolvedType());
704     if (is&lt;AST::PointerType&gt;(makeArrayReferenceExpression.leftValue().resolvedType())) {
<a name="83" id="anc83"></a><span class="line-modified">705         auto ptrValue = takeLastValue();</span>
<span class="line-modified">706         m_stringBuilder.append(</span>
<span class="line-modified">707             m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = &quot;, ptrValue, &quot; ? &quot;, mangledTypeName, &quot;{ &quot;, ptrValue, &quot;, 1 } : &quot;, mangledTypeName, &quot;{ nullptr, 0 };\n&quot;);</span>
708     } else if (is&lt;AST::ArrayType&gt;(makeArrayReferenceExpression.leftValue().resolvedType())) {
<a name="84" id="anc84"></a><span class="line-removed">709         auto lValue = takeLastLeftValue().value;</span>
710         auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(makeArrayReferenceExpression.leftValue().resolvedType());
<a name="85" id="anc85"></a><span class="line-modified">711         m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = { &quot;, lValue, &quot;-&gt;data(), &quot;, arrayType.numElements(), &quot; };\n&quot;);</span>


712     } else {
<a name="86" id="anc86"></a><span class="line-modified">713         auto lValue = takeLastLeftValue().value;</span>
<span class="line-modified">714         m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = { &quot;, lValue, &quot;, 1 };\n&quot;);</span>

715     }
<a name="87" id="anc87"></a><span class="line-removed">716     appendRightValue(makeArrayReferenceExpression, variableName);</span>
717 }
718 
719 void FunctionDefinitionWriter::visit(AST::MakePointerExpression&amp; makePointerExpression)
720 {
<a name="88" id="anc88"></a>
721     checkErrorAndVisit(makePointerExpression.leftValue());
<a name="89" id="anc89"></a><span class="line-modified">722     auto [pointer, nullability] = takeLastLeftValue();</span>
<span class="line-removed">723     auto variableName = generateNextVariableName();</span>
<span class="line-removed">724     m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(makePointerExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, pointer, &quot;;\n&quot;);</span>
<span class="line-removed">725     appendRightValueWithNullability(makePointerExpression, variableName, nullability);</span>
726 }
727 
<a name="90" id="anc90"></a><span class="line-modified">728 void FunctionDefinitionWriter::visit(AST::ReadModifyWriteExpression&amp;)</span>
729 {
<a name="91" id="anc91"></a><span class="line-modified">730     // This should be lowered already.</span>
<span class="line-modified">731     ASSERT_NOT_REACHED();</span>

































732 }
733 
734 void FunctionDefinitionWriter::visit(AST::TernaryExpression&amp; ternaryExpression)
735 {
<a name="92" id="anc92"></a>
736     checkErrorAndVisit(ternaryExpression.predicate());
<a name="93" id="anc93"></a><span class="line-modified">737     auto check = takeLastValue();</span>
738     checkErrorAndVisit(ternaryExpression.bodyExpression());
<a name="94" id="anc94"></a><span class="line-modified">739     auto body = takeLastValue();</span>
740     checkErrorAndVisit(ternaryExpression.elseExpression());
<a name="95" id="anc95"></a><span class="line-modified">741     auto elseBody = takeLastValue();</span>
<span class="line-removed">742 </span>
<span class="line-removed">743     auto variableName = generateNextVariableName();</span>
<span class="line-removed">744     m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(ternaryExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, check, &quot; ? &quot;, body, &quot; : &quot;, elseBody, &quot;;\n&quot;);</span>
<span class="line-removed">745     appendRightValue(ternaryExpression, variableName);</span>
746 }
747 
748 void FunctionDefinitionWriter::visit(AST::VariableReference&amp; variableReference)
749 {
750     ASSERT(variableReference.variable());
751     auto iterator = m_variableMapping.find(variableReference.variable());
752     ASSERT(iterator != m_variableMapping.end());
753 
754     MangledVariableName variableName = iterator-&gt;value;
<a name="96" id="anc96"></a><span class="line-modified">755 </span>
<span class="line-removed">756     appendLeftValue(variableReference, variableName, { }, Nullability::NotNull,</span>
<span class="line-removed">757         [this, &amp;variableReference, variableName] {</span>
<span class="line-removed">758             auto pointerName = generateNextVariableName();</span>
<span class="line-removed">759             m_stringBuilder.append(m_indent, &quot;thread &quot;, m_typeNamer.mangledNameForType(variableReference.resolvedType()), &quot;* &quot;, pointerName, &quot; = &amp;&quot;, variableName, &quot;;\n&quot;);</span>
<span class="line-removed">760             return pointerName;</span>
<span class="line-removed">761         });</span>
762 }
763 
764 void FunctionDefinitionWriter::emitConstantExpressionString(AST::ConstantExpression&amp; constantExpression)
765 {
766     constantExpression.visit(WTF::makeVisitor(
767         [&amp;](AST::IntegerLiteral&amp; integerLiteral) {
768             m_stringBuilder.append(integerLiteral.value());
769         },
770         [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {
771             m_stringBuilder.append(unsignedIntegerLiteral.value());
772         },
773         [&amp;](AST::FloatLiteral&amp; floatLiteral) {
774             m_stringBuilder.append(floatLiteral.value());
775         },
<a name="97" id="anc97"></a><span class="line-removed">776         [&amp;](AST::NullLiteral&amp;) {</span>
<span class="line-removed">777             m_stringBuilder.append(&quot;nullptr&quot;);</span>
<span class="line-removed">778         },</span>
779         [&amp;](AST::BooleanLiteral&amp; booleanLiteral) {
780             if (booleanLiteral.value())
781                 m_stringBuilder.append(&quot;true&quot;);
782             else
783                 m_stringBuilder.append(&quot;false&quot;);
784         },
785         [&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {
786             ASSERT(enumerationMemberLiteral.enumerationDefinition());
787             ASSERT(enumerationMemberLiteral.enumerationDefinition());
788             m_stringBuilder.append(m_typeNamer.mangledNameForType(*enumerationMemberLiteral.enumerationDefinition()), &quot;::&quot;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()));
789         }
790     ));
791 }
792 
793 class RenderFunctionDefinitionWriter final : public FunctionDefinitionWriter {
794 public:
795     RenderFunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, MatchedRenderSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)
796         : FunctionDefinitionWriter(stringBuilder, intrinsics, typeNamer, functionMapping, layout)
797         , m_matchedSemantics(WTFMove(matchedSemantics))
798     {
799     }
800 
801 private:
802     std::unique_ptr&lt;EntryPointScaffolding&gt; createEntryPointScaffolding(AST::FunctionDefinition&amp;) override;
803 
804     MatchedRenderSemantics m_matchedSemantics;
805 };
806 
807 std::unique_ptr&lt;EntryPointScaffolding&gt; RenderFunctionDefinitionWriter::createEntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition)
808 {
809     auto generateNextVariableName = [this]() -&gt; MangledVariableName {
810         return this-&gt;generateNextVariableName();
811     };
812     if (&amp;functionDefinition == m_matchedSemantics.vertexShader)
813         return makeUnique&lt;VertexEntryPointScaffolding&gt;(functionDefinition, m_intrinsics, m_typeNamer, m_matchedSemantics.vertexShaderEntryPointItems, m_matchedSemantics.vertexShaderResourceMap, m_layout, WTFMove(generateNextVariableName), m_matchedSemantics.matchedVertexAttributes);
814     if (&amp;functionDefinition == m_matchedSemantics.fragmentShader)
815         return makeUnique&lt;FragmentEntryPointScaffolding&gt;(functionDefinition, m_intrinsics, m_typeNamer, m_matchedSemantics.fragmentShaderEntryPointItems, m_matchedSemantics.fragmentShaderResourceMap, m_layout, WTFMove(generateNextVariableName), m_matchedSemantics.matchedColorAttachments);
816     return nullptr;
817 }
818 
819 class ComputeFunctionDefinitionWriter final : public FunctionDefinitionWriter {
820 public:
821     ComputeFunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, MatchedComputeSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)
822         : FunctionDefinitionWriter(stringBuilder, intrinsics, typeNamer, functionMapping, layout)
823         , m_matchedSemantics(WTFMove(matchedSemantics))
824     {
825     }
826 
827 private:
828     std::unique_ptr&lt;EntryPointScaffolding&gt; createEntryPointScaffolding(AST::FunctionDefinition&amp;) override;
829 
830     MatchedComputeSemantics m_matchedSemantics;
831 };
832 
833 std::unique_ptr&lt;EntryPointScaffolding&gt; ComputeFunctionDefinitionWriter::createEntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition)
834 {
835     auto generateNextVariableName = [this]() -&gt; MangledVariableName {
836         return this-&gt;generateNextVariableName();
837     };
838     if (&amp;functionDefinition == m_matchedSemantics.shader)
839         return makeUnique&lt;ComputeEntryPointScaffolding&gt;(functionDefinition, m_intrinsics, m_typeNamer, m_matchedSemantics.entryPointItems, m_matchedSemantics.resourceMap, m_layout, WTFMove(generateNextVariableName));
840     return nullptr;
841 }
842 
843 static HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt; generateMetalFunctionsMapping(Program&amp; program)
844 {
845     unsigned numFunctions = 0;
846     HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt; functionMapping;
847     for (auto&amp; functionDefinition : program.functionDefinitions()) {
848         auto addResult = functionMapping.add(&amp;functionDefinition, MangledFunctionName { numFunctions++ });
849         ASSERT_UNUSED(addResult, addResult.isNewEntry);
850     }
851 
852     return functionMapping;
853 }
854 
855 static void emitSharedMetalFunctions(StringBuilder&amp; stringBuilder, Program&amp; program, TypeNamer&amp; typeNamer, const HashSet&lt;AST::FunctionDeclaration*&gt;&amp; reachableFunctions, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping)
856 {
857     for (auto&amp; functionDefinition : program.functionDefinitions()) {
858         if (!functionDefinition-&gt;entryPointType() &amp;&amp; reachableFunctions.contains(&amp;functionDefinition))
859             declareFunction(stringBuilder, functionDefinition, typeNamer, functionMapping);
860     }
861 
862     stringBuilder.append(&#39;\n&#39;);
863 }
864 
865 class ReachableFunctionsGatherer final : public Visitor {
866 public:
867     void visit(AST::FunctionDeclaration&amp; functionDeclaration) override
868     {
869         auto result = m_reachableFunctions.add(&amp;functionDeclaration);
870         if (result.isNewEntry)
871             Visitor::visit(functionDeclaration);
872     }
873 
874     void visit(AST::CallExpression&amp; callExpression) override
875     {
876         Visitor::visit(callExpression);
877         if (is&lt;AST::FunctionDefinition&gt;(callExpression.function()))
878             checkErrorAndVisit(downcast&lt;AST::FunctionDefinition&gt;(callExpression.function()));
879         else
880             checkErrorAndVisit(downcast&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function()));
881     }
882 
883     HashSet&lt;AST::FunctionDeclaration*&gt; takeReachableFunctions() { return WTFMove(m_reachableFunctions); }
884 
885 private:
886     HashSet&lt;AST::FunctionDeclaration*&gt; m_reachableFunctions;
887 };
888 
889 RenderMetalFunctionEntryPoints emitMetalFunctions(StringBuilder&amp; stringBuilder, Program&amp; program, TypeNamer&amp; typeNamer, MatchedRenderSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)
890 {
891     auto&amp; vertexShaderEntryPoint = *matchedSemantics.vertexShader;
892     auto* fragmentShaderEntryPoint = matchedSemantics.fragmentShader;
893 
894     ReachableFunctionsGatherer reachableFunctionsGatherer;
895     reachableFunctionsGatherer.Visitor::visit(vertexShaderEntryPoint);
896     if (fragmentShaderEntryPoint)
897         reachableFunctionsGatherer.Visitor::visit(*fragmentShaderEntryPoint);
898     auto reachableFunctions = reachableFunctionsGatherer.takeReachableFunctions();
899 
900     auto functionMapping = generateMetalFunctionsMapping(program);
901 
902     emitSharedMetalFunctions(stringBuilder, program, typeNamer, reachableFunctions, functionMapping);
903 
904     RenderFunctionDefinitionWriter functionDefinitionWriter(stringBuilder, program.intrinsics(), typeNamer, functionMapping, WTFMove(matchedSemantics), layout);
905     for (auto&amp; functionDefinition : program.functionDefinitions()) {
906         if (reachableFunctions.contains(&amp;functionDefinition))
907             functionDefinitionWriter.visit(functionDefinition);
908     }
909 
910     return { functionMapping.get(&amp;vertexShaderEntryPoint), fragmentShaderEntryPoint ? functionMapping.get(fragmentShaderEntryPoint) : MangledFunctionName { 0 } };
911 }
912 
913 ComputeMetalFunctionEntryPoints emitMetalFunctions(StringBuilder&amp; stringBuilder, Program&amp; program, TypeNamer&amp; typeNamer, MatchedComputeSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)
914 {
915     auto&amp; entryPoint = *matchedSemantics.shader;
916 
917     ReachableFunctionsGatherer reachableFunctionsGatherer;
918     reachableFunctionsGatherer.Visitor::visit(entryPoint);
919     auto reachableFunctions = reachableFunctionsGatherer.takeReachableFunctions();
920 
921     auto functionMapping = generateMetalFunctionsMapping(program);
922     emitSharedMetalFunctions(stringBuilder, program, typeNamer, reachableFunctions, functionMapping);
923 
924     ComputeFunctionDefinitionWriter functionDefinitionWriter(stringBuilder, program.intrinsics(), typeNamer, functionMapping, WTFMove(matchedSemantics), layout);
925     for (auto&amp; functionDefinition : program.functionDefinitions()) {
926         if (reachableFunctions.contains(&amp;functionDefinition))
927             functionDefinitionWriter.visit(functionDefinition);
928     }
929 
930     return { functionMapping.get(&amp;entryPoint) };
931 }
932 
933 } // namespace Metal
934 
935 } // namespace WHLSL
936 
937 } // namespace WebCore
938 
939 #endif
<a name="98" id="anc98"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="98" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webaudio/AudioScheduledSourceNode.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AudioScheduledSourceNode.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaStreamAudioSourceNode.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webaudio/AudioScheduledSourceNode.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,15 ***</span>
   * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  #pragma once
  
  #include &quot;AudioNode.h&quot;
  
  namespace WebCore {
  
<span class="line-modified">! class AudioScheduledSourceNode : public AudioNode {</span>
      WTF_MAKE_ISO_ALLOCATED(AudioScheduledSourceNode);
  public:
      // These are the possible states an AudioScheduledSourceNode can be in:
      //
      // UNSCHEDULED_STATE - Initial playback state. Created, but not yet scheduled.
<span class="line-new-header">--- 26,16 ---</span>
   * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  #pragma once
  
<span class="line-added">+ #include &quot;ActiveDOMObject.h&quot;</span>
  #include &quot;AudioNode.h&quot;
  
  namespace WebCore {
  
<span class="line-modified">! class AudioScheduledSourceNode : public AudioNode, public ActiveDOMObject {</span>
      WTF_MAKE_ISO_ALLOCATED(AudioScheduledSourceNode);
  public:
      // These are the possible states an AudioScheduledSourceNode can be in:
      //
      // UNSCHEDULED_STATE - Initial playback state. Created, but not yet scheduled.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 52,12 ***</span>
          FINISHED_STATE = 3
      };
  
      AudioScheduledSourceNode(AudioContext&amp;, float sampleRate);
  
<span class="line-modified">!     ExceptionOr&lt;void&gt; start(double when);</span>
<span class="line-modified">!     ExceptionOr&lt;void&gt; stop(double when);</span>
  
      unsigned short playbackState() const { return static_cast&lt;unsigned short&gt;(m_playbackState); }
      bool isPlayingOrScheduled() const { return m_playbackState == PLAYING_STATE || m_playbackState == SCHEDULED_STATE; }
      bool hasFinished() const { return m_playbackState == FINISHED_STATE; }
  
<span class="line-new-header">--- 53,14 ---</span>
          FINISHED_STATE = 3
      };
  
      AudioScheduledSourceNode(AudioContext&amp;, float sampleRate);
  
<span class="line-modified">!     ExceptionOr&lt;void&gt; startLater(double when);</span>
<span class="line-modified">!     ExceptionOr&lt;void&gt; stopLater(double when);</span>
<span class="line-added">+ </span>
<span class="line-added">+     void didBecomeMarkedForDeletion() override;</span>
  
      unsigned short playbackState() const { return static_cast&lt;unsigned short&gt;(m_playbackState); }
      bool isPlayingOrScheduled() const { return m_playbackState == PLAYING_STATE || m_playbackState == SCHEDULED_STATE; }
      bool hasFinished() const { return m_playbackState == FINISHED_STATE; }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 73,24 ***</span>
      // Called when we have no more sound to play or the noteOff() time has been reached.
      virtual void finish();
  
      PlaybackState m_playbackState { UNSCHEDULED_STATE };
  
      // m_startTime is the time to start playing based on the context&#39;s timeline (0 or a time less than the context&#39;s current time means &quot;now&quot;).
      double m_startTime { 0 }; // in seconds
  
      // m_endTime is the time to stop playing based on the context&#39;s timeline (0 or a time less than the context&#39;s current time means &quot;now&quot;).
      // If it hasn&#39;t been set explicitly, then the sound will not stop playing (if looping) or will stop when the end of the AudioBuffer
      // has been reached.
      double m_endTime; // in seconds
  
<span class="line-removed">-     bool m_hasEndedListener { false };</span>
<span class="line-removed">- </span>
      static const double UnknownTime;
<span class="line-removed">- </span>
<span class="line-removed">- private:</span>
<span class="line-removed">-     bool addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp;, const AddEventListenerOptions&amp;) override;</span>
<span class="line-removed">-     bool removeEventListener(const AtomString&amp; eventType, EventListener&amp;, const ListenerOptions&amp;) override;</span>
<span class="line-removed">-     void removeAllEventListeners() override;</span>
  };
  
  } // namespace WebCore
<span class="line-new-header">--- 76,18 ---</span>
      // Called when we have no more sound to play or the noteOff() time has been reached.
      virtual void finish();
  
      PlaybackState m_playbackState { UNSCHEDULED_STATE };
  
<span class="line-added">+     RefPtr&lt;PendingActivity&lt;AudioScheduledSourceNode&gt;&gt; m_pendingActivity;</span>
      // m_startTime is the time to start playing based on the context&#39;s timeline (0 or a time less than the context&#39;s current time means &quot;now&quot;).
      double m_startTime { 0 }; // in seconds
  
      // m_endTime is the time to stop playing based on the context&#39;s timeline (0 or a time less than the context&#39;s current time means &quot;now&quot;).
      // If it hasn&#39;t been set explicitly, then the sound will not stop playing (if looping) or will stop when the end of the AudioBuffer
      // has been reached.
      double m_endTime; // in seconds
  
      static const double UnknownTime;
  };
  
  } // namespace WebCore
</pre>
<center><a href="AudioScheduledSourceNode.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaStreamAudioSourceNode.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
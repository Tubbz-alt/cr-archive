<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/CallFrame.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
  4  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.
  5  *
  6  *  This library is free software; you can redistribute it and/or
  7  *  modify it under the terms of the GNU Library General Public
  8  *  License as published by the Free Software Foundation; either
  9  *  version 2 of the License, or (at your option) any later version.
 10  *
 11  *  This library is distributed in the hope that it will be useful,
 12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  *  Library General Public License for more details.
 15  *
 16  *  You should have received a copy of the GNU Library General Public License
 17  *  along with this library; see the file COPYING.LIB.  If not, write to
 18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  *  Boston, MA 02110-1301, USA.
 20  *
 21  */
 22 
 23 #pragma once
 24 
 25 #include &quot;AbstractPC.h&quot;
 26 #include &quot;CalleeBits.h&quot;
 27 #include &quot;MacroAssemblerCodeRef.h&quot;
 28 #include &quot;Register.h&quot;
 29 #include &quot;StackVisitor.h&quot;
 30 #include &quot;VM.h&quot;
 31 #include &quot;VMEntryRecord.h&quot;
 32 #include &lt;wtf/EnumClassOperatorOverloads.h&gt;
 33 
 34 namespace JSC  {
 35 
 36     class Arguments;
 37     class CallFrame;
 38     class Interpreter;
 39     class JSCallee;
 40     class JSScope;
 41     class SourceOrigin;
 42 
 43     struct Instruction;
 44 
 45     class CallSiteIndex {
 46     public:
 47         CallSiteIndex() = default;
 48 
 49         explicit CallSiteIndex(BytecodeIndex bytecodeIndex)
 50             : m_bits(bytecodeIndex.offset())
 51         {
 52             ASSERT(!bytecodeIndex.checkpoint());
 53         }
 54         explicit CallSiteIndex(uint32_t bits)
 55             : m_bits(bits)
 56         { }
 57 
 58         explicit operator bool() const { return !!m_bits; }
 59         bool operator==(const CallSiteIndex&amp; other) const { return m_bits == other.m_bits; }
 60 
 61         uint32_t bits() const { return m_bits; }
 62         static CallSiteIndex fromBits(uint32_t bits) { return CallSiteIndex(bits); }
 63 
 64         BytecodeIndex bytecodeIndex() const { return BytecodeIndex(bits()); }
 65 
 66     private:
 67         uint32_t m_bits { BytecodeIndex().offset() };
 68     };
 69 
 70     class DisposableCallSiteIndex : public CallSiteIndex {
 71     public:
 72         DisposableCallSiteIndex() = default;
 73 
 74         explicit DisposableCallSiteIndex(uint32_t bits)
 75             : CallSiteIndex(bits)
 76         {
 77         }
 78 
 79         static DisposableCallSiteIndex fromCallSiteIndex(CallSiteIndex callSiteIndex)
 80         {
 81             return DisposableCallSiteIndex(callSiteIndex.bits());
 82         }
 83     };
 84 
 85     // arm64_32 expects caller frame and return pc to use 8 bytes
 86     struct CallerFrameAndPC {
 87         alignas(CPURegister) CallFrame* callerFrame;
 88         alignas(CPURegister) void* returnPC;
 89         static constexpr int sizeInRegisters = 2 * sizeof(CPURegister) / sizeof(Register);
 90     };
 91     static_assert(CallerFrameAndPC::sizeInRegisters == sizeof(CallerFrameAndPC) / sizeof(Register), &quot;CallerFrameAndPC::sizeInRegisters is incorrect.&quot;);
 92 
 93     enum class CallFrameSlot : int {
 94         codeBlock = CallerFrameAndPC::sizeInRegisters,
 95         callee = codeBlock + 1,
 96         argumentCountIncludingThis = callee + 1,
 97         thisArgument = argumentCountIncludingThis + 1,
 98         firstArgument = thisArgument + 1,
 99     };
100 
101     OVERLOAD_MATH_OPERATORS_FOR_ENUM_CLASS_WITH_INTEGRALS(CallFrameSlot)
102     OVERLOAD_RELATIONAL_OPERATORS_FOR_ENUM_CLASS_WITH_INTEGRALS(CallFrameSlot)
103 
104     // Represents the current state of script execution.
105     // Passed as the first argument to most functions.
106     class CallFrame : private Register {
107     public:
108         static constexpr int headerSizeInRegisters = static_cast&lt;int&gt;(CallFrameSlot::argumentCountIncludingThis) + 1;
109 
110         // This function should only be called in very specific circumstances
111         // when you&#39;ve guaranteed the callee can&#39;t be a Wasm callee, and can
112         // be an arbitrary JSValue. This function should basically never be used.
113         // Its only use right now is when we are making a call, and we&#39;re not
114         // yet sure if the callee is a cell. In general, a JS callee is guaranteed
115         // to be a cell, however, there is a brief window where we need to check
116         // to see if it&#39;s a cell, and if it&#39;s not, we throw an exception.
117         inline JSValue guaranteedJSValueCallee() const;
118         inline JSObject* jsCallee() const;
119         CalleeBits callee() const { return CalleeBits(this[static_cast&lt;int&gt;(CallFrameSlot::callee)].pointer()); }
120         SUPPRESS_ASAN CalleeBits unsafeCallee() const { return CalleeBits(this[static_cast&lt;int&gt;(CallFrameSlot::callee)].asanUnsafePointer()); }
121         CodeBlock* codeBlock() const;
122         CodeBlock** addressOfCodeBlock() const { return bitwise_cast&lt;CodeBlock**&gt;(this + static_cast&lt;int&gt;(CallFrameSlot::codeBlock)); }
123         inline SUPPRESS_ASAN CodeBlock* unsafeCodeBlock() const;
124         inline JSScope* scope(int scopeRegisterOffset) const;
125 
126         JS_EXPORT_PRIVATE bool isAnyWasmCallee();
127 
128         // Global object in which the currently executing code was defined.
129         // Differs from VM::deprecatedVMEntryGlobalObject() during function calls across web browser frames.
130         JSGlobalObject* lexicalGlobalObject(VM&amp;) const;
131 
132         // FIXME: Remove this function
133         // https://bugs.webkit.org/show_bug.cgi?id=203272
134         VM&amp; deprecatedVM() const;
135 
136         static CallFrame* create(Register* callFrameBase) { return static_cast&lt;CallFrame*&gt;(callFrameBase); }
137         Register* registers() { return this; }
138         const Register* registers() const { return this; }
139 
140         CallFrame&amp; operator=(const Register&amp; r) { *static_cast&lt;Register*&gt;(this) = r; return *this; }
141 
142         CallFrame* callerFrame() const { return static_cast&lt;CallFrame*&gt;(callerFrameOrEntryFrame()); }
143         void* callerFrameOrEntryFrame() const { return callerFrameAndPC().callerFrame; }
144         SUPPRESS_ASAN void* unsafeCallerFrameOrEntryFrame() const { return unsafeCallerFrameAndPC().callerFrame; }
145 
146         CallFrame* unsafeCallerFrame(EntryFrame*&amp;) const;
147         JS_EXPORT_PRIVATE CallFrame* callerFrame(EntryFrame*&amp;) const;
148 
149         JS_EXPORT_PRIVATE SourceOrigin callerSourceOrigin(VM&amp;);
150 
151         static ptrdiff_t callerFrameOffset() { return OBJECT_OFFSETOF(CallerFrameAndPC, callerFrame); }
152 
153         ReturnAddressPtr returnPC() const { return ReturnAddressPtr(callerFrameAndPC().returnPC); }
154         bool hasReturnPC() const { return !!callerFrameAndPC().returnPC; }
155         void clearReturnPC() { callerFrameAndPC().returnPC = 0; }
156         static ptrdiff_t returnPCOffset() { return OBJECT_OFFSETOF(CallerFrameAndPC, returnPC); }
157         AbstractPC abstractReturnPC(VM&amp; vm) { return AbstractPC(vm, this); }
158 
159         bool callSiteBitsAreBytecodeOffset() const;
160         bool callSiteBitsAreCodeOriginIndex() const;
161 
162         unsigned callSiteAsRawBits() const;
163         unsigned unsafeCallSiteAsRawBits() const;
164         CallSiteIndex callSiteIndex() const;
165         CallSiteIndex unsafeCallSiteIndex() const;
166     private:
167         unsigned callSiteBitsAsBytecodeOffset() const;
168 #if ENABLE(WEBASSEMBLY)
169         JS_EXPORT_PRIVATE JSGlobalObject* lexicalGlobalObjectFromWasmCallee(VM&amp;) const;
170 #endif
171     public:
172 
173         // This will try to get you the bytecode offset, but you should be aware that
174         // this bytecode offset may be bogus in the presence of inlining. This will
175         // also return 0 if the call frame has no notion of bytecode offsets (for
176         // example if it&#39;s native code).
177         // https://bugs.webkit.org/show_bug.cgi?id=121754
178         BytecodeIndex bytecodeIndex();
179 
180         // This will get you a CodeOrigin. It will always succeed. May return
181         // CodeOrigin(BytecodeIndex(0)) if we&#39;re in native code.
182         JS_EXPORT_PRIVATE CodeOrigin codeOrigin();
183 
184         inline Register* topOfFrame();
185 
186         const Instruction* currentVPC() const; // This only makes sense in the LLInt and baseline.
187         void setCurrentVPC(const Instruction*);
188 
189         void setCallerFrame(CallFrame* frame) { callerFrameAndPC().callerFrame = frame; }
190         inline void setScope(int scopeRegisterOffset, JSScope*);
191 
192         static void initDeprecatedCallFrameForDebugger(CallFrame* globalExec, JSCallee* globalCallee);
193 
194         // Read a register from the codeframe (or constant from the CodeBlock).
195         Register&amp; r(VirtualRegister);
196         // Read a register for a known non-constant
197         Register&amp; uncheckedR(VirtualRegister);
198 
199         // Access to arguments as passed. (After capture, arguments may move to a different location.)
200         size_t argumentCount() const { return argumentCountIncludingThis() - 1; }
201         size_t argumentCountIncludingThis() const { return this[static_cast&lt;int&gt;(CallFrameSlot::argumentCountIncludingThis)].payload(); }
202         static int argumentOffset(int argument) { return (CallFrameSlot::firstArgument + argument); }
203         static int argumentOffsetIncludingThis(int argument) { return (CallFrameSlot::thisArgument + argument); }
204 
205         // In the following (argument() and setArgument()), the &#39;argument&#39;
206         // parameter is the index of the arguments of the target function of
207         // this frame. The index starts at 0 for the first arg, 1 for the
208         // second, etc.
209         //
210         // The arguments (in this case) do not include the &#39;this&#39; value.
211         // arguments(0) will not fetch the &#39;this&#39; value. To get/set &#39;this&#39;,
212         // use thisValue() and setThisValue() below.
213 
214         JSValue* addressOfArgumentsStart() const { return bitwise_cast&lt;JSValue*&gt;(this + argumentOffset(0)); }
215         JSValue argument(size_t argument)
216         {
217             if (argument &gt;= argumentCount())
218                  return jsUndefined();
219             return getArgumentUnsafe(argument);
220         }
221         JSValue uncheckedArgument(size_t argument)
222         {
223             ASSERT(argument &lt; argumentCount());
224             return getArgumentUnsafe(argument);
225         }
226         void setArgument(size_t argument, JSValue value)
227         {
228             this[argumentOffset(argument)] = value;
229         }
230 
231         JSValue getArgumentUnsafe(size_t argIndex)
232         {
233             // User beware! This method does not verify that there is a valid
234             // argument at the specified argIndex. This is used for debugging
235             // and verification code only. The caller is expected to know what
236             // he/she is doing when calling this method.
237             return this[argumentOffset(argIndex)].jsValue();
238         }
239 
240         static int thisArgumentOffset() { return argumentOffsetIncludingThis(0); }
241         JSValue thisValue() { return this[thisArgumentOffset()].jsValue(); }
242         void setThisValue(JSValue value) { this[thisArgumentOffset()] = value; }
243 
244         // Under the constructor implemented in C++, thisValue holds the newTarget instead of the automatically constructed value.
245         // The result of this function is only effective under the &quot;construct&quot; context.
246         JSValue newTarget() { return thisValue(); }
247 
248         JSValue argumentAfterCapture(size_t argument);
249 
250         static int offsetFor(size_t argumentCountIncludingThis) { return CallFrameSlot::thisArgument + argumentCountIncludingThis - 1; }
251 
252         static CallFrame* noCaller() { return nullptr; }
253         bool isDeprecatedCallFrameForDebugger() const
254         {
255             return callerFrameAndPC().callerFrame == noCaller() &amp;&amp; callerFrameAndPC().returnPC == nullptr;
256         }
257 
258         void convertToStackOverflowFrame(VM&amp;, CodeBlock* codeBlockToKeepAliveUntilFrameIsUnwound);
259         bool isStackOverflowFrame() const;
260         bool isWasmFrame() const;
261 
262         void setArgumentCountIncludingThis(int count) { static_cast&lt;Register*&gt;(this)[static_cast&lt;int&gt;(CallFrameSlot::argumentCountIncludingThis)].payload() = count; }
263         inline void setCallee(JSObject*);
264         inline void setCodeBlock(CodeBlock*);
265         void setReturnPC(void* value) { callerFrameAndPC().returnPC = value; }
266 
267         String friendlyFunctionName();
268 
269         // CallFrame::iterate() expects a Functor that implements the following method:
270         //     StackVisitor::Status operator()(StackVisitor&amp;) const;
271         // FIXME: This method is improper. We rely on the fact that we can call it with a null
272         // receiver. We should always be using StackVisitor directly.
273         // It&#39;s only valid to call this from a non-wasm top frame.
274         template &lt;StackVisitor::EmptyEntryFrameAction action = StackVisitor::ContinueIfTopEntryFrameIsEmpty, typename Functor&gt; void iterate(VM&amp; vm, const Functor&amp; functor)
275         {
276             void* rawThis = this;
277             if (!!rawThis)
278                 RELEASE_ASSERT(callee().isCell());
279             StackVisitor::visit&lt;action, Functor&gt;(this, vm, functor);
280         }
281 
282         void dump(PrintStream&amp;);
283         JS_EXPORT_PRIVATE const char* describeFrame();
284 
285     private:
286 
287         CallFrame();
288         ~CallFrame();
289 
290         Register* topOfFrameInternal();
291 
292         // The following are for internal use in debugging and verification
293         // code only and not meant as an API for general usage:
294 
295         size_t argIndexForRegister(Register* reg)
296         {
297             // The register at &#39;offset&#39; number of slots from the frame pointer
298             // i.e.
299             //       reg = frame[offset];
300             //   ==&gt; reg = frame + offset;
301             //   ==&gt; offset = reg - frame;
302             int offset = reg - this-&gt;registers();
303 
304             // The offset is defined (based on argumentOffset()) to be:
305             //       offset = CallFrameSlot::firstArgument - argIndex;
306             // Hence:
307             //       argIndex = CallFrameSlot::firstArgument - offset;
308             size_t argIndex = offset - CallFrameSlot::firstArgument;
309             return argIndex;
310         }
311 
312         CallerFrameAndPC&amp; callerFrameAndPC() { return *reinterpret_cast&lt;CallerFrameAndPC*&gt;(this); }
313         const CallerFrameAndPC&amp; callerFrameAndPC() const { return *reinterpret_cast&lt;const CallerFrameAndPC*&gt;(this); }
314         SUPPRESS_ASAN const CallerFrameAndPC&amp; unsafeCallerFrameAndPC() const { return *reinterpret_cast&lt;const CallerFrameAndPC*&gt;(this); }
315     };
316 
317 JS_EXPORT_PRIVATE bool isFromJSCode(void* returnAddress);
318 
319 #if USE(BUILTIN_FRAME_ADDRESS)
320 #define DECLARE_CALL_FRAME(vm) \
321     ({ \
322         ASSERT(JSC::isFromJSCode(removeCodePtrTag&lt;void*&gt;(__builtin_return_address(0)))); \
323         bitwise_cast&lt;JSC::CallFrame*&gt;(__builtin_frame_address(1)); \
324     })
325 #else
326 #define DECLARE_CALL_FRAME(vm) ((vm).topCallFrame)
327 #endif
328 
329 
330 } // namespace JSC
    </pre>
  </body>
</html>
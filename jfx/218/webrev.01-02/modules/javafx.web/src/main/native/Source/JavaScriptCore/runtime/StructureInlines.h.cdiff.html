<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StructureInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StructureIDTable.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StructureRareData.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StructureInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 30,10 ***</span>
<span class="line-new-header">--- 30,11 ---</span>
  #include &quot;JSGlobalObject.h&quot;
  #include &quot;PropertyMapHashTable.h&quot;
  #include &quot;Structure.h&quot;
  #include &quot;StructureChain.h&quot;
  #include &quot;StructureRareDataInlines.h&quot;
<span class="line-added">+ #include &lt;wtf/Threading.h&gt;</span>
  
  namespace JSC {
  
  inline Structure* Structure::create(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype, const TypeInfo&amp; typeInfo, const ClassInfo* classInfo, IndexingType indexingType, unsigned inlineCapacity)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 106,19 ***</span>
      return object-&gt;structure();
  }
  
  ALWAYS_INLINE JSValue Structure::storedPrototype(const JSObject* object) const
  {
<span class="line-modified">!     ASSERT(!isMainThread() || object-&gt;structure() == this);</span>
      if (hasMonoProto())
          return storedPrototype();
      return object-&gt;getDirect(knownPolyProtoOffset);
  }
  
  ALWAYS_INLINE JSObject* Structure::storedPrototypeObject(const JSObject* object) const
  {
<span class="line-modified">!     ASSERT(!isMainThread() || object-&gt;structure() == this);</span>
      if (hasMonoProto())
          return storedPrototypeObject();
      JSValue proto = object-&gt;getDirect(knownPolyProtoOffset);
      if (proto.isNull())
          return nullptr;
<span class="line-new-header">--- 107,19 ---</span>
      return object-&gt;structure();
  }
  
  ALWAYS_INLINE JSValue Structure::storedPrototype(const JSObject* object) const
  {
<span class="line-modified">!     ASSERT(isCompilationThread() || Thread::mayBeGCThread() || object-&gt;structure() == this);</span>
      if (hasMonoProto())
          return storedPrototype();
      return object-&gt;getDirect(knownPolyProtoOffset);
  }
  
  ALWAYS_INLINE JSObject* Structure::storedPrototypeObject(const JSObject* object) const
  {
<span class="line-modified">!     ASSERT(isCompilationThread() || Thread::mayBeGCThread() || object-&gt;structure() == this);</span>
      if (hasMonoProto())
          return storedPrototypeObject();
      JSValue proto = object-&gt;getDirect(knownPolyProtoOffset);
      if (proto.isNull())
          return nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 141,10 ***</span>
<span class="line-new-header">--- 142,13 ---</span>
  ALWAYS_INLINE PropertyOffset Structure::get(VM&amp; vm, PropertyName propertyName, unsigned&amp; attributes)
  {
      ASSERT(!isCompilationThread());
      ASSERT(structure(vm)-&gt;classInfo() == info());
  
<span class="line-added">+     if (m_seenProperties.ruleOut(bitwise_cast&lt;uintptr_t&gt;(propertyName.uid())))</span>
<span class="line-added">+         return invalidOffset;</span>
<span class="line-added">+ </span>
      PropertyTable* propertyTable = ensurePropertyTableIfNotEmpty(vm);
      if (!propertyTable)
          return invalidOffset;
  
      PropertyMapEntry* entry = propertyTable-&gt;get(propertyName.uid());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 157,32 ***</span>
  
  template&lt;typename Functor&gt;
  void Structure::forEachPropertyConcurrently(const Functor&amp; functor)
  {
      Vector&lt;Structure*, 8&gt; structures;
<span class="line-modified">!     Structure* structure;</span>
      PropertyTable* table;
  
<span class="line-modified">!     findStructuresAndMapForMaterialization(structures, structure, table);</span>
  
      if (table) {
          for (auto&amp; entry : *table) {
              if (!functor(entry)) {
<span class="line-modified">!                 structure-&gt;m_lock.unlock();</span>
                  return;
              }
          }
<span class="line-modified">!         structure-&gt;m_lock.unlock();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     for (unsigned i = structures.size(); i--;) {</span>
<span class="line-removed">-         structure = structures[i];</span>
<span class="line-removed">-         if (!structure-&gt;m_nameInPrevious)</span>
<span class="line-removed">-             continue;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (!functor(PropertyMapEntry(structure-&gt;m_nameInPrevious.get(), structure-&gt;m_offset, structure-&gt;attributesInPrevious())))</span>
<span class="line-removed">-             return;</span>
      }
  }
  
  template&lt;typename Functor&gt;
  void Structure::forEachProperty(VM&amp; vm, const Functor&amp; functor)
<span class="line-new-header">--- 161,44 ---</span>
  
  template&lt;typename Functor&gt;
  void Structure::forEachPropertyConcurrently(const Functor&amp; functor)
  {
      Vector&lt;Structure*, 8&gt; structures;
<span class="line-modified">!     Structure* tableStructure;</span>
      PropertyTable* table;
  
<span class="line-modified">!     findStructuresAndMapForMaterialization(structures, tableStructure, table);</span>
<span class="line-added">+ </span>
<span class="line-added">+     HashSet&lt;UniquedStringImpl*&gt; seenProperties;</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (auto* structure : structures) {</span>
<span class="line-added">+         if (!structure-&gt;m_transitionPropertyName || seenProperties.contains(structure-&gt;m_transitionPropertyName.get()))</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+         seenProperties.add(structure-&gt;m_transitionPropertyName.get());</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (structure-&gt;isPropertyDeletionTransition())</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (!functor(PropertyMapEntry(structure-&gt;m_transitionPropertyName.get(), structure-&gt;transitionOffset(), structure-&gt;transitionPropertyAttributes()))) {</span>
<span class="line-added">+             if (table)</span>
<span class="line-added">+                 tableStructure-&gt;m_lock.unlock();</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
      if (table) {
          for (auto&amp; entry : *table) {
<span class="line-added">+             if (seenProperties.contains(entry.key))</span>
<span class="line-added">+                 continue;</span>
<span class="line-added">+ </span>
              if (!functor(entry)) {
<span class="line-modified">!                 tableStructure-&gt;m_lock.unlock();</span>
                  return;
              }
          }
<span class="line-modified">!         tableStructure-&gt;m_lock.unlock();</span>
      }
  }
  
  template&lt;typename Functor&gt;
  void Structure::forEachProperty(VM&amp; vm, const Functor&amp; functor)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 295,25 ***</span>
          m_cachedPrototypeChain.set(vm, this, StructureChain::create(vm, prototype.isNull() ? nullptr : asObject(prototype)));
      }
      return m_cachedPrototypeChain.get();
  }
  
<span class="line-modified">! inline StructureChain* Structure::prototypeChain(ExecState* exec, JSObject* base) const</span>
  {
<span class="line-modified">!     return prototypeChain(exec-&gt;vm(), exec-&gt;lexicalGlobalObject(), base);</span>
  }
  
  inline bool Structure::isValid(JSGlobalObject* globalObject, StructureChain* cachedPrototypeChain, JSObject* base) const
  {
      if (!cachedPrototypeChain)
          return false;
  
      VM&amp; vm = globalObject-&gt;vm();
      JSValue prototype = prototypeForLookup(globalObject, base);
<span class="line-modified">!     WriteBarrier&lt;Structure&gt;* cachedStructure = cachedPrototypeChain-&gt;head();</span>
      while (*cachedStructure &amp;&amp; !prototype.isNull()) {
<span class="line-modified">!         if (asObject(prototype)-&gt;structure(vm) != cachedStructure-&gt;get())</span>
              return false;
          ++cachedStructure;
          prototype = asObject(prototype)-&gt;getPrototypeDirect(vm);
      }
      return prototype.isNull() &amp;&amp; !*cachedStructure;
<span class="line-new-header">--- 311,25 ---</span>
          m_cachedPrototypeChain.set(vm, this, StructureChain::create(vm, prototype.isNull() ? nullptr : asObject(prototype)));
      }
      return m_cachedPrototypeChain.get();
  }
  
<span class="line-modified">! inline StructureChain* Structure::prototypeChain(JSGlobalObject* globalObject, JSObject* base) const</span>
  {
<span class="line-modified">!     return prototypeChain(globalObject-&gt;vm(), globalObject, base);</span>
  }
  
  inline bool Structure::isValid(JSGlobalObject* globalObject, StructureChain* cachedPrototypeChain, JSObject* base) const
  {
      if (!cachedPrototypeChain)
          return false;
  
      VM&amp; vm = globalObject-&gt;vm();
      JSValue prototype = prototypeForLookup(globalObject, base);
<span class="line-modified">!     StructureID* cachedStructure = cachedPrototypeChain-&gt;head();</span>
      while (*cachedStructure &amp;&amp; !prototype.isNull()) {
<span class="line-modified">!         if (asObject(prototype)-&gt;structureID() != *cachedStructure)</span>
              return false;
          ++cachedStructure;
          prototype = asObject(prototype)-&gt;getPrototypeDirect(vm);
      }
      return prototype.isNull() &amp;&amp; !*cachedStructure;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 358,25 ***</span>
      unsigned inlineOverflowAccordingToTotalSize = totalSize &lt; m_inlineCapacity ? 0 : totalSize - m_inlineCapacity;
  
      auto fail = [&amp;] (const char* description) {
          dataLog(&quot;Detected offset inconsistency: &quot;, description, &quot;!\n&quot;);
          dataLog(&quot;this = &quot;, RawPointer(this), &quot;\n&quot;);
<span class="line-modified">!         dataLog(&quot;m_offset = &quot;, m_offset, &quot;\n&quot;);</span>
          dataLog(&quot;m_inlineCapacity = &quot;, m_inlineCapacity, &quot;\n&quot;);
          dataLog(&quot;propertyTable = &quot;, RawPointer(propertyTable), &quot;\n&quot;);
<span class="line-modified">!         dataLog(&quot;numberOfSlotsForLastOffset = &quot;, numberOfSlotsForLastOffset(m_offset, m_inlineCapacity), &quot;\n&quot;);</span>
          dataLog(&quot;totalSize = &quot;, totalSize, &quot;\n&quot;);
          dataLog(&quot;inlineOverflowAccordingToTotalSize = &quot;, inlineOverflowAccordingToTotalSize, &quot;\n&quot;);
<span class="line-modified">!         dataLog(&quot;numberOfOutOfLineSlotsForLastOffset = &quot;, numberOfOutOfLineSlotsForLastOffset(m_offset), &quot;\n&quot;);</span>
          detailsFunc();
          UNREACHABLE_FOR_PLATFORM();
      };
  
<span class="line-modified">!     if (numberOfSlotsForLastOffset(m_offset, m_inlineCapacity) != totalSize)</span>
<span class="line-modified">!         fail(&quot;numberOfSlotsForLastOffset doesn&#39;t match totalSize&quot;);</span>
<span class="line-modified">!     if (inlineOverflowAccordingToTotalSize != numberOfOutOfLineSlotsForLastOffset(m_offset))</span>
<span class="line-modified">!         fail(&quot;inlineOverflowAccordingToTotalSize doesn&#39;t match numberOfOutOfLineSlotsForLastOffset&quot;);</span>
  
      return true;
  }
  
  ALWAYS_INLINE bool Structure::checkOffsetConsistency() const
<span class="line-new-header">--- 374,26 ---</span>
      unsigned inlineOverflowAccordingToTotalSize = totalSize &lt; m_inlineCapacity ? 0 : totalSize - m_inlineCapacity;
  
      auto fail = [&amp;] (const char* description) {
          dataLog(&quot;Detected offset inconsistency: &quot;, description, &quot;!\n&quot;);
          dataLog(&quot;this = &quot;, RawPointer(this), &quot;\n&quot;);
<span class="line-modified">!         dataLog(&quot;transitionOffset = &quot;, transitionOffset(), &quot;\n&quot;);</span>
<span class="line-added">+         dataLog(&quot;maxOffset = &quot;, maxOffset(), &quot;\n&quot;);</span>
          dataLog(&quot;m_inlineCapacity = &quot;, m_inlineCapacity, &quot;\n&quot;);
          dataLog(&quot;propertyTable = &quot;, RawPointer(propertyTable), &quot;\n&quot;);
<span class="line-modified">!         dataLog(&quot;numberOfSlotsForMaxOffset = &quot;, numberOfSlotsForMaxOffset(maxOffset(), m_inlineCapacity), &quot;\n&quot;);</span>
          dataLog(&quot;totalSize = &quot;, totalSize, &quot;\n&quot;);
          dataLog(&quot;inlineOverflowAccordingToTotalSize = &quot;, inlineOverflowAccordingToTotalSize, &quot;\n&quot;);
<span class="line-modified">!         dataLog(&quot;numberOfOutOfLineSlotsForMaxOffset = &quot;, numberOfOutOfLineSlotsForMaxOffset(maxOffset()), &quot;\n&quot;);</span>
          detailsFunc();
          UNREACHABLE_FOR_PLATFORM();
      };
  
<span class="line-modified">!     if (numberOfSlotsForMaxOffset(maxOffset(), m_inlineCapacity) != totalSize)</span>
<span class="line-modified">!         fail(&quot;numberOfSlotsForMaxOffset doesn&#39;t match totalSize&quot;);</span>
<span class="line-modified">!     if (inlineOverflowAccordingToTotalSize != numberOfOutOfLineSlotsForMaxOffset(maxOffset()))</span>
<span class="line-modified">!         fail(&quot;inlineOverflowAccordingToTotalSize doesn&#39;t match numberOfOutOfLineSlotsForMaxOffset&quot;);</span>
  
      return true;
  }
  
  ALWAYS_INLINE bool Structure::checkOffsetConsistency() const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 408,15 ***</span>
      if (!currentCapacity)
          return initialOutOfLineCapacity;
      return currentCapacity * outOfLineGrowthFactor;
  }
  
<span class="line-modified">! inline void Structure::setObjectToStringValue(ExecState* exec, VM&amp; vm, JSString* value, PropertySlot toStringTagSymbolSlot)</span>
  {
      if (!hasRareData())
          allocateRareData(vm);
<span class="line-modified">!     rareData()-&gt;setObjectToStringValue(exec, vm, this, value, toStringTagSymbolSlot);</span>
  }
  
  template&lt;Structure::ShouldPin shouldPin, typename Func&gt;
  inline PropertyOffset Structure::add(VM&amp; vm, PropertyName propertyName, unsigned attributes, const Func&amp; func)
  {
<span class="line-new-header">--- 425,15 ---</span>
      if (!currentCapacity)
          return initialOutOfLineCapacity;
      return currentCapacity * outOfLineGrowthFactor;
  }
  
<span class="line-modified">! inline void Structure::setObjectToStringValue(JSGlobalObject* globalObject, VM&amp; vm, JSString* value, PropertySlot toStringTagSymbolSlot)</span>
  {
      if (!hasRareData())
          allocateRareData(vm);
<span class="line-modified">!     rareData()-&gt;setObjectToStringValue(globalObject, vm, this, value, toStringTagSymbolSlot);</span>
  }
  
  template&lt;Structure::ShouldPin shouldPin, typename Func&gt;
  inline PropertyOffset Structure::add(VM&amp; vm, PropertyName propertyName, unsigned attributes, const Func&amp; func)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 444,67 ***</span>
      auto rep = propertyName.uid();
  
      PropertyOffset newOffset = table-&gt;nextOffset(m_inlineCapacity);
  
      m_propertyHash = m_propertyHash ^ rep-&gt;existingSymbolAwareHash();
  
<span class="line-modified">!     PropertyOffset newLastOffset = m_offset;</span>
<span class="line-modified">!     table-&gt;add(PropertyMapEntry(rep, newOffset, attributes), newLastOffset, PropertyTable::PropertyOffsetMayChange);</span>
  
<span class="line-modified">!     func(locker, newOffset, newLastOffset);</span>
  
<span class="line-modified">!     ASSERT(m_offset == newLastOffset);</span>
  
      checkConsistency();
      return newOffset;
  }
  
<span class="line-modified">! template&lt;typename Func&gt;</span>
<span class="line-modified">! inline PropertyOffset Structure::remove(PropertyName propertyName, const Func&amp; func)</span>
  {
<span class="line-modified">!     ConcurrentJSLocker locker(m_lock);</span>
  
<span class="line-modified">!     checkConsistency();</span>
  
<span class="line-modified">!     auto rep = propertyName.uid();</span>
  
<span class="line-modified">!     // We ONLY remove from uncacheable dictionaries, which will have a pinned property table.</span>
<span class="line-removed">-     // The only way for them not to have a table is if they are empty.</span>
<span class="line-removed">-     PropertyTable* table = propertyTableOrNull();</span>
  
<span class="line-modified">!     if (!table)</span>
<span class="line-removed">-         return invalidOffset;</span>
  
      PropertyTable::find_iterator position = table-&gt;find(rep);
      if (!position.first)
          return invalidOffset;
  
      PropertyOffset offset = position.first-&gt;offset;
  
      table-&gt;remove(position);
      table-&gt;addDeletedOffset(offset);
  
<span class="line-modified">!     checkConsistency();</span>
  
<span class="line-modified">!     func(locker, offset);</span>
      return offset;
  }
  
  template&lt;typename Func&gt;
  inline PropertyOffset Structure::addPropertyWithoutTransition(VM&amp; vm, PropertyName propertyName, unsigned attributes, const Func&amp; func)
  {
      return add&lt;ShouldPin::Yes&gt;(vm, propertyName, attributes, func);
  }
  
  template&lt;typename Func&gt;
<span class="line-modified">! inline PropertyOffset Structure::removePropertyWithoutTransition(VM&amp;, PropertyName propertyName, const Func&amp; func)</span>
  {
      ASSERT(isUncacheableDictionary());
      ASSERT(isPinnedPropertyTable());
      ASSERT(propertyTableOrNull());
  
<span class="line-modified">!     return remove(propertyName, func);</span>
  }
  
  ALWAYS_INLINE void Structure::setPrototypeWithoutTransition(VM&amp; vm, JSValue prototype)
  {
      ASSERT(isValidPrototype(prototype));
<span class="line-new-header">--- 461,82 ---</span>
      auto rep = propertyName.uid();
  
      PropertyOffset newOffset = table-&gt;nextOffset(m_inlineCapacity);
  
      m_propertyHash = m_propertyHash ^ rep-&gt;existingSymbolAwareHash();
<span class="line-added">+     m_seenProperties.add(bitwise_cast&lt;uintptr_t&gt;(rep));</span>
  
<span class="line-modified">!     auto result = table-&gt;add(PropertyMapEntry(rep, newOffset, attributes));</span>
<span class="line-modified">!     ASSERT_UNUSED(result, result.second);</span>
<span class="line-added">+     ASSERT_UNUSED(result, result.first.first-&gt;offset == newOffset);</span>
<span class="line-added">+     auto newMaxOffset = std::max(newOffset, maxOffset());</span>
  
<span class="line-modified">!     func(locker, newOffset, newMaxOffset);</span>
  
<span class="line-modified">!     ASSERT(maxOffset() == newMaxOffset);</span>
  
      checkConsistency();
      return newOffset;
  }
  
<span class="line-modified">! template&lt;Structure::ShouldPin shouldPin, typename Func&gt;</span>
<span class="line-modified">! inline PropertyOffset Structure::remove(VM&amp; vm, PropertyName propertyName, const Func&amp; func)</span>
  {
<span class="line-modified">!     PropertyTable* table = ensurePropertyTable(vm);</span>
<span class="line-added">+     GCSafeConcurrentJSLocker locker(m_lock, vm.heap);</span>
  
<span class="line-modified">!     switch (shouldPin) {</span>
<span class="line-added">+     case ShouldPin::Yes:</span>
<span class="line-added">+         pin(locker, vm, table);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ShouldPin::No:</span>
<span class="line-added">+         setPropertyTable(vm, table);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     ASSERT(JSC::isValidOffset(get(vm, propertyName)));</span>
  
<span class="line-modified">!     checkConsistency();</span>
  
<span class="line-modified">!     auto rep = propertyName.uid();</span>
  
      PropertyTable::find_iterator position = table-&gt;find(rep);
      if (!position.first)
          return invalidOffset;
  
<span class="line-added">+     setIsQuickPropertyAccessAllowedForEnumeration(false);</span>
<span class="line-added">+ </span>
      PropertyOffset offset = position.first-&gt;offset;
  
      table-&gt;remove(position);
      table-&gt;addDeletedOffset(offset);
  
<span class="line-modified">!     PropertyOffset newMaxOffset = maxOffset();</span>
<span class="line-added">+ </span>
<span class="line-added">+     func(locker, offset, newMaxOffset);</span>
  
<span class="line-modified">!     ASSERT(maxOffset() == newMaxOffset);</span>
<span class="line-added">+     ASSERT(!JSC::isValidOffset(get(vm, propertyName)));</span>
<span class="line-added">+ </span>
<span class="line-added">+     checkConsistency();</span>
      return offset;
  }
  
  template&lt;typename Func&gt;
  inline PropertyOffset Structure::addPropertyWithoutTransition(VM&amp; vm, PropertyName propertyName, unsigned attributes, const Func&amp; func)
  {
      return add&lt;ShouldPin::Yes&gt;(vm, propertyName, attributes, func);
  }
  
  template&lt;typename Func&gt;
<span class="line-modified">! inline PropertyOffset Structure::removePropertyWithoutTransition(VM&amp; vm, PropertyName propertyName, const Func&amp; func)</span>
  {
      ASSERT(isUncacheableDictionary());
      ASSERT(isPinnedPropertyTable());
      ASSERT(propertyTableOrNull());
  
<span class="line-modified">!     return remove&lt;ShouldPin::Yes&gt;(vm, propertyName, func);</span>
  }
  
  ALWAYS_INLINE void Structure::setPrototypeWithoutTransition(VM&amp; vm, JSValue prototype)
  {
      ASSERT(isValidPrototype(prototype));
</pre>
<center><a href="StructureIDTable.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StructureRareData.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
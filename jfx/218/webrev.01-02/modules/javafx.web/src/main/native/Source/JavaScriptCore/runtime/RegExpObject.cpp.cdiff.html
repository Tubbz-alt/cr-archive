<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/RegExpObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RegExpMatchesArray.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RegExpObject.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/RegExpObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,8 ***</span>
  /*
   *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">!  *  Copyright (C) 2003-2018 Apple Inc. All Rights Reserved.</span>
   *
   *  This library is free software; you can redistribute it and/or
   *  modify it under the terms of the GNU Lesser General Public
   *  License as published by the Free Software Foundation; either
   *  version 2 of the License, or (at your option) any later version.
<span class="line-new-header">--- 1,8 ---</span>
  /*
   *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">!  *  Copyright (C) 2003-2019 Apple Inc. All Rights Reserved.</span>
   *
   *  This library is free software; you can redistribute it and/or
   *  modify it under the terms of the GNU Lesser General Public
   *  License as published by the Free Software Foundation; either
   *  version 2 of the License, or (at your option) any later version.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 57,151 ***</span>
      Base::visitChildren(thisObject, visitor);
      visitor.appendUnbarriered(thisObject-&gt;regExp());
      visitor.append(thisObject-&gt;m_lastIndex);
  }
  
<span class="line-modified">! bool RegExpObject::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      if (propertyName == vm.propertyNames-&gt;lastIndex) {
          RegExpObject* regExp = jsCast&lt;RegExpObject*&gt;(object);
          unsigned attributes = regExp-&gt;lastIndexIsWritable() ? PropertyAttribute::DontDelete | PropertyAttribute::DontEnum : PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly;
          slot.setValue(regExp, attributes, regExp-&gt;getLastIndex());
          return true;
      }
<span class="line-modified">!     return Base::getOwnPropertySlot(object, exec, propertyName, slot);</span>
  }
  
<span class="line-modified">! bool RegExpObject::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      if (propertyName == vm.propertyNames-&gt;lastIndex)
          return false;
<span class="line-modified">!     return Base::deleteProperty(cell, exec, propertyName);</span>
  }
  
<span class="line-modified">! void RegExpObject::getOwnNonIndexPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      if (mode.includeDontEnumProperties())
          propertyNames.add(vm.propertyNames-&gt;lastIndex);
<span class="line-modified">!     Base::getOwnNonIndexPropertyNames(object, exec, propertyNames, mode);</span>
  }
  
<span class="line-modified">! void RegExpObject::getPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      if (mode.includeDontEnumProperties())
          propertyNames.add(vm.propertyNames-&gt;lastIndex);
<span class="line-modified">!     Base::getPropertyNames(object, exec, propertyNames, mode);</span>
  }
  
<span class="line-modified">! void RegExpObject::getGenericPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      if (mode.includeDontEnumProperties())
          propertyNames.add(vm.propertyNames-&gt;lastIndex);
<span class="line-modified">!     Base::getGenericPropertyNames(object, exec, propertyNames, mode);</span>
  }
  
<span class="line-modified">! bool RegExpObject::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (propertyName == vm.propertyNames-&gt;lastIndex) {
          RegExpObject* regExp = jsCast&lt;RegExpObject*&gt;(object);
          if (descriptor.configurablePresent() &amp;&amp; descriptor.configurable())
<span class="line-modified">!             return typeError(exec, scope, shouldThrow, UnconfigurablePropertyChangeConfigurabilityError);</span>
          if (descriptor.enumerablePresent() &amp;&amp; descriptor.enumerable())
<span class="line-modified">!             return typeError(exec, scope, shouldThrow, UnconfigurablePropertyChangeEnumerabilityError);</span>
          if (descriptor.isAccessorDescriptor())
<span class="line-modified">!             return typeError(exec, scope, shouldThrow, UnconfigurablePropertyChangeAccessMechanismError);</span>
          if (!regExp-&gt;lastIndexIsWritable()) {
              if (descriptor.writablePresent() &amp;&amp; descriptor.writable())
<span class="line-modified">!                 return typeError(exec, scope, shouldThrow, UnconfigurablePropertyChangeWritabilityError);</span>
<span class="line-modified">!             if (descriptor.value() &amp;&amp; !sameValue(exec, regExp-&gt;getLastIndex(), descriptor.value()))</span>
<span class="line-modified">!                 return typeError(exec, scope, shouldThrow, ReadonlyPropertyChangeError);</span>
              return true;
          }
          if (descriptor.value()) {
<span class="line-modified">!             regExp-&gt;setLastIndex(exec, descriptor.value(), false);</span>
              RETURN_IF_EXCEPTION(scope, false);
          }
          if (descriptor.writablePresent() &amp;&amp; !descriptor.writable())
              regExp-&gt;setLastIndexIsNotWritable();
          return true;
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, Base::defineOwnProperty(object, exec, propertyName, descriptor, shouldThrow));</span>
  }
  
<span class="line-modified">! static bool regExpObjectSetLastIndexStrict(ExecState* exec, EncodedJSValue thisValue, EncodedJSValue value)</span>
  {
<span class="line-modified">!     return jsCast&lt;RegExpObject*&gt;(JSValue::decode(thisValue))-&gt;setLastIndex(exec, JSValue::decode(value), true);</span>
  }
  
<span class="line-modified">! static bool regExpObjectSetLastIndexNonStrict(ExecState* exec, EncodedJSValue thisValue, EncodedJSValue value)</span>
  {
<span class="line-modified">!     return jsCast&lt;RegExpObject*&gt;(JSValue::decode(thisValue))-&gt;setLastIndex(exec, JSValue::decode(value), false);</span>
  }
  
<span class="line-modified">! bool RegExpObject::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      RegExpObject* thisObject = jsCast&lt;RegExpObject*&gt;(cell);
  
      if (UNLIKELY(isThisValueAltered(slot, thisObject)))
<span class="line-modified">!         return ordinarySetSlow(exec, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode());</span>
  
      if (propertyName == vm.propertyNames-&gt;lastIndex) {
<span class="line-modified">!         bool result = thisObject-&gt;setLastIndex(exec, value, slot.isStrictMode());</span>
          slot.setCustomValue(thisObject, slot.isStrictMode()
              ? regExpObjectSetLastIndexStrict
              : regExpObjectSetLastIndexNonStrict);
          return result;
      }
<span class="line-modified">!     return Base::put(cell, exec, propertyName, value, slot);</span>
  }
  
<span class="line-modified">! JSValue RegExpObject::exec(ExecState* exec, JSGlobalObject* globalObject, JSString* string)</span>
  {
<span class="line-modified">!     return execInline(exec, globalObject, string);</span>
  }
  
  // Shared implementation used by test and exec.
<span class="line-modified">! MatchResult RegExpObject::match(ExecState* exec, JSGlobalObject* globalObject, JSString* string)</span>
  {
<span class="line-modified">!     return matchInline(exec, globalObject, string);</span>
  }
  
<span class="line-modified">! JSValue RegExpObject::matchGlobal(ExecState* exec, JSGlobalObject* globalObject, JSString* string)</span>
  {
      VM&amp; vm = globalObject-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
      RegExp* regExp = this-&gt;regExp();
  
      ASSERT(regExp-&gt;global());
  
<span class="line-modified">!     setLastIndex(exec, 0);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
<span class="line-modified">!     String s = string-&gt;value(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      ASSERT(!s.isNull());
      if (regExp-&gt;unicode()) {
          unsigned stringLength = s.length();
          RELEASE_AND_RETURN(scope, collectMatches(
<span class="line-modified">!             vm, exec, string, s, globalObject, regExp,</span>
              [&amp;] (size_t end) -&gt; size_t {
                  return advanceStringUnicode(s, stringLength, end);
              }));
      }
  
      RELEASE_AND_RETURN(scope, collectMatches(
<span class="line-modified">!         vm, exec, string, s, globalObject, regExp,</span>
          [&amp;] (size_t end) -&gt; size_t {
              return end + 1;
          }));
  }
  
<span class="line-new-header">--- 57,155 ---</span>
      Base::visitChildren(thisObject, visitor);
      visitor.appendUnbarriered(thisObject-&gt;regExp());
      visitor.append(thisObject-&gt;m_lastIndex);
  }
  
<span class="line-modified">! bool RegExpObject::getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      if (propertyName == vm.propertyNames-&gt;lastIndex) {
          RegExpObject* regExp = jsCast&lt;RegExpObject*&gt;(object);
          unsigned attributes = regExp-&gt;lastIndexIsWritable() ? PropertyAttribute::DontDelete | PropertyAttribute::DontEnum : PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly;
          slot.setValue(regExp, attributes, regExp-&gt;getLastIndex());
          return true;
      }
<span class="line-modified">!     return Base::getOwnPropertySlot(object, globalObject, propertyName, slot);</span>
  }
  
<span class="line-modified">! bool RegExpObject::deleteProperty(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      if (propertyName == vm.propertyNames-&gt;lastIndex)
          return false;
<span class="line-modified">!     return Base::deleteProperty(cell, globalObject, propertyName);</span>
  }
  
<span class="line-modified">! void RegExpObject::getOwnNonIndexPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      if (mode.includeDontEnumProperties())
          propertyNames.add(vm.propertyNames-&gt;lastIndex);
<span class="line-modified">!     Base::getOwnNonIndexPropertyNames(object, globalObject, propertyNames, mode);</span>
  }
  
<span class="line-modified">! void RegExpObject::getPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      if (mode.includeDontEnumProperties())
          propertyNames.add(vm.propertyNames-&gt;lastIndex);
<span class="line-modified">!     Base::getPropertyNames(object, globalObject, propertyNames, mode);</span>
  }
  
<span class="line-modified">! void RegExpObject::getGenericPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      if (mode.includeDontEnumProperties())
          propertyNames.add(vm.propertyNames-&gt;lastIndex);
<span class="line-modified">!     Base::getGenericPropertyNames(object, globalObject, propertyNames, mode);</span>
  }
  
<span class="line-modified">! bool RegExpObject::defineOwnProperty(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (propertyName == vm.propertyNames-&gt;lastIndex) {
          RegExpObject* regExp = jsCast&lt;RegExpObject*&gt;(object);
          if (descriptor.configurablePresent() &amp;&amp; descriptor.configurable())
<span class="line-modified">!             return typeError(globalObject, scope, shouldThrow, UnconfigurablePropertyChangeConfigurabilityError);</span>
          if (descriptor.enumerablePresent() &amp;&amp; descriptor.enumerable())
<span class="line-modified">!             return typeError(globalObject, scope, shouldThrow, UnconfigurablePropertyChangeEnumerabilityError);</span>
          if (descriptor.isAccessorDescriptor())
<span class="line-modified">!             return typeError(globalObject, scope, shouldThrow, UnconfigurablePropertyChangeAccessMechanismError);</span>
          if (!regExp-&gt;lastIndexIsWritable()) {
              if (descriptor.writablePresent() &amp;&amp; descriptor.writable())
<span class="line-modified">!                 return typeError(globalObject, scope, shouldThrow, UnconfigurablePropertyChangeWritabilityError);</span>
<span class="line-modified">!             if (descriptor.value()) {</span>
<span class="line-modified">!                 bool isSame = sameValue(globalObject, regExp-&gt;getLastIndex(), descriptor.value());</span>
<span class="line-added">+                 RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">+                 if (!isSame)</span>
<span class="line-added">+                     return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyChangeError);</span>
<span class="line-added">+             }</span>
              return true;
          }
          if (descriptor.value()) {
<span class="line-modified">!             regExp-&gt;setLastIndex(globalObject, descriptor.value(), false);</span>
              RETURN_IF_EXCEPTION(scope, false);
          }
          if (descriptor.writablePresent() &amp;&amp; !descriptor.writable())
              regExp-&gt;setLastIndexIsNotWritable();
          return true;
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, Base::defineOwnProperty(object, globalObject, propertyName, descriptor, shouldThrow));</span>
  }
  
<span class="line-modified">! static bool regExpObjectSetLastIndexStrict(JSGlobalObject* globalObject, EncodedJSValue thisValue, EncodedJSValue value)</span>
  {
<span class="line-modified">!     return jsCast&lt;RegExpObject*&gt;(JSValue::decode(thisValue))-&gt;setLastIndex(globalObject, JSValue::decode(value), true);</span>
  }
  
<span class="line-modified">! static bool regExpObjectSetLastIndexNonStrict(JSGlobalObject* globalObject, EncodedJSValue thisValue, EncodedJSValue value)</span>
  {
<span class="line-modified">!     return jsCast&lt;RegExpObject*&gt;(JSValue::decode(thisValue))-&gt;setLastIndex(globalObject, JSValue::decode(value), false);</span>
  }
  
<span class="line-modified">! bool RegExpObject::put(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      RegExpObject* thisObject = jsCast&lt;RegExpObject*&gt;(cell);
  
      if (UNLIKELY(isThisValueAltered(slot, thisObject)))
<span class="line-modified">!         return ordinarySetSlow(globalObject, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode());</span>
  
      if (propertyName == vm.propertyNames-&gt;lastIndex) {
<span class="line-modified">!         bool result = thisObject-&gt;setLastIndex(globalObject, value, slot.isStrictMode());</span>
          slot.setCustomValue(thisObject, slot.isStrictMode()
              ? regExpObjectSetLastIndexStrict
              : regExpObjectSetLastIndexNonStrict);
          return result;
      }
<span class="line-modified">!     return Base::put(cell, globalObject, propertyName, value, slot);</span>
  }
  
<span class="line-modified">! JSValue RegExpObject::exec(JSGlobalObject* globalObject, JSString* string)</span>
  {
<span class="line-modified">!     return execInline(globalObject, string);</span>
  }
  
  // Shared implementation used by test and exec.
<span class="line-modified">! MatchResult RegExpObject::match(JSGlobalObject* globalObject, JSString* string)</span>
  {
<span class="line-modified">!     return matchInline(globalObject, string);</span>
  }
  
<span class="line-modified">! JSValue RegExpObject::matchGlobal(JSGlobalObject* globalObject, JSString* string)</span>
  {
      VM&amp; vm = globalObject-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
      RegExp* regExp = this-&gt;regExp();
  
      ASSERT(regExp-&gt;global());
  
<span class="line-modified">!     setLastIndex(globalObject, 0);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
<span class="line-modified">!     String s = string-&gt;value(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      ASSERT(!s.isNull());
      if (regExp-&gt;unicode()) {
          unsigned stringLength = s.length();
          RELEASE_AND_RETURN(scope, collectMatches(
<span class="line-modified">!             vm, globalObject, string, s, regExp,</span>
              [&amp;] (size_t end) -&gt; size_t {
                  return advanceStringUnicode(s, stringLength, end);
              }));
      }
  
      RELEASE_AND_RETURN(scope, collectMatches(
<span class="line-modified">!         vm, globalObject, string, s, regExp,</span>
          [&amp;] (size_t end) -&gt; size_t {
              return end + 1;
          }));
  }
  
</pre>
<center><a href="RegExpMatchesArray.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RegExpObject.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
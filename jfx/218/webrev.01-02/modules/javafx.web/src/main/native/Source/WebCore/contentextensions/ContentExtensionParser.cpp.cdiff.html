<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/contentextensions/ContentExtensionParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ContentExtensionCompiler.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ContentExtensionsBackend.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/contentextensions/ContentExtensionParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 54,170 ***</span>
              return false;
      }
      return true;
  }
  
<span class="line-modified">! static Expected&lt;Vector&lt;String&gt;, std::error_code&gt; getStringList(ExecState&amp; exec, const JSObject* arrayObject)</span>
  {
      static const ContentExtensionError error = ContentExtensionError::JSONInvalidConditionList;
<span class="line-modified">!     VM&amp; vm = exec.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!arrayObject || !isJSArray(arrayObject))
          return makeUnexpected(error);
      const JSArray* array = jsCast&lt;const JSArray*&gt;(arrayObject);
  
      Vector&lt;String&gt; strings;
      unsigned length = array-&gt;length();
      for (unsigned i = 0; i &lt; length; ++i) {
<span class="line-modified">!         const JSValue value = array-&gt;getIndex(&amp;exec, i);</span>
          if (scope.exception() || !value.isString())
              return makeUnexpected(error);
  
<span class="line-modified">!         const String&amp; string = asString(value)-&gt;value(&amp;exec);</span>
          if (string.isEmpty())
              return makeUnexpected(error);
          strings.append(string);
      }
      return strings;
  }
  
<span class="line-modified">! static Expected&lt;Vector&lt;String&gt;, std::error_code&gt; getDomainList(ExecState&amp; exec, const JSObject* arrayObject)</span>
  {
<span class="line-modified">!     auto strings = getStringList(exec, arrayObject);</span>
      if (!strings.has_value())
          return strings;
      for (auto&amp; domain : strings.value()) {
          // Domains should be punycode encoded lower case.
          if (!containsOnlyASCIIWithNoUppercase(domain))
              return makeUnexpected(ContentExtensionError::JSONDomainNotLowerCaseASCII);
      }
      return strings;
  }
  
<span class="line-modified">! static std::error_code getTypeFlags(ExecState&amp; exec, const JSValue&amp; typeValue, ResourceFlags&amp; flags, uint16_t (*stringToType)(const String&amp;))</span>
  {
<span class="line-modified">!     VM&amp; vm = exec.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!typeValue.isObject())
          return { };
  
<span class="line-modified">!     const JSObject* object = typeValue.toObject(&amp;exec);</span>
      scope.assertNoException();
      if (!isJSArray(object))
          return ContentExtensionError::JSONInvalidTriggerFlagsArray;
  
      const JSArray* array = jsCast&lt;const JSArray*&gt;(object);
  
      unsigned length = array-&gt;length();
      for (unsigned i = 0; i &lt; length; ++i) {
<span class="line-modified">!         const JSValue value = array-&gt;getIndex(&amp;exec, i);</span>
          if (scope.exception() || !value)
              return ContentExtensionError::JSONInvalidObjectInTriggerFlagsArray;
  
<span class="line-modified">!         String name = value.toWTFString(&amp;exec);</span>
          uint16_t type = stringToType(name);
          if (!type)
              return ContentExtensionError::JSONInvalidStringInTriggerFlagsArray;
  
          flags |= type;
      }
  
      return { };
  }
  
<span class="line-modified">! static Expected&lt;Trigger, std::error_code&gt; loadTrigger(ExecState&amp; exec, const JSObject&amp; ruleObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     const JSValue triggerObject = ruleObject.get(&amp;exec, Identifier::fromString(vm, &quot;trigger&quot;));</span>
      if (!triggerObject || scope.exception() || !triggerObject.isObject())
          return makeUnexpected(ContentExtensionError::JSONInvalidTrigger);
  
<span class="line-modified">!     const JSValue urlFilterObject = triggerObject.get(&amp;exec, Identifier::fromString(vm, &quot;url-filter&quot;));</span>
      if (!urlFilterObject || scope.exception() || !urlFilterObject.isString())
          return makeUnexpected(ContentExtensionError::JSONInvalidURLFilterInTrigger);
  
<span class="line-modified">!     String urlFilter = asString(urlFilterObject)-&gt;value(&amp;exec);</span>
      if (urlFilter.isEmpty())
          return makeUnexpected(ContentExtensionError::JSONInvalidURLFilterInTrigger);
  
      Trigger trigger;
      trigger.urlFilter = urlFilter;
  
<span class="line-modified">!     const JSValue urlFilterCaseValue = triggerObject.get(&amp;exec, Identifier::fromString(vm, &quot;url-filter-is-case-sensitive&quot;));</span>
      if (urlFilterCaseValue &amp;&amp; !scope.exception() &amp;&amp; urlFilterCaseValue.isBoolean())
<span class="line-modified">!         trigger.urlFilterIsCaseSensitive = urlFilterCaseValue.toBoolean(&amp;exec);</span>
  
<span class="line-modified">!     const JSValue topURLFilterCaseValue = triggerObject.get(&amp;exec, Identifier::fromString(vm, &quot;top-url-filter-is-case-sensitive&quot;));</span>
      if (topURLFilterCaseValue &amp;&amp; !scope.exception() &amp;&amp; topURLFilterCaseValue.isBoolean())
<span class="line-modified">!         trigger.topURLConditionIsCaseSensitive = topURLFilterCaseValue.toBoolean(&amp;exec);</span>
  
<span class="line-modified">!     const JSValue resourceTypeValue = triggerObject.get(&amp;exec, Identifier::fromString(vm, &quot;resource-type&quot;));</span>
      if (!scope.exception() &amp;&amp; resourceTypeValue.isObject()) {
<span class="line-modified">!         auto typeFlagsError = getTypeFlags(exec, resourceTypeValue, trigger.flags, readResourceType);</span>
          if (typeFlagsError)
              return makeUnexpected(typeFlagsError);
      } else if (!resourceTypeValue.isUndefined())
          return makeUnexpected(ContentExtensionError::JSONInvalidTriggerFlagsArray);
  
<span class="line-modified">!     const JSValue loadTypeValue = triggerObject.get(&amp;exec, Identifier::fromString(vm, &quot;load-type&quot;));</span>
      if (!scope.exception() &amp;&amp; loadTypeValue.isObject()) {
<span class="line-modified">!         auto typeFlagsError = getTypeFlags(exec, loadTypeValue, trigger.flags, readLoadType);</span>
          if (typeFlagsError)
              return makeUnexpected(typeFlagsError);
      } else if (!loadTypeValue.isUndefined())
          return makeUnexpected(ContentExtensionError::JSONInvalidTriggerFlagsArray);
  
<span class="line-modified">!     const JSValue ifDomainValue = triggerObject.get(&amp;exec, Identifier::fromString(vm, &quot;if-domain&quot;));</span>
      if (!scope.exception() &amp;&amp; ifDomainValue.isObject()) {
<span class="line-modified">!         auto ifDomain = getDomainList(exec, asObject(ifDomainValue));</span>
          if (!ifDomain.has_value())
              return makeUnexpected(ifDomain.error());
          trigger.conditions = WTFMove(ifDomain.value());
          if (trigger.conditions.isEmpty())
              return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
          ASSERT(trigger.conditionType == Trigger::ConditionType::None);
          trigger.conditionType = Trigger::ConditionType::IfDomain;
      } else if (!ifDomainValue.isUndefined())
          return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
  
<span class="line-modified">!     const JSValue unlessDomainValue = triggerObject.get(&amp;exec, Identifier::fromString(vm, &quot;unless-domain&quot;));</span>
      if (!scope.exception() &amp;&amp; unlessDomainValue.isObject()) {
          if (trigger.conditionType != Trigger::ConditionType::None)
              return makeUnexpected(ContentExtensionError::JSONMultipleConditions);
<span class="line-modified">!         auto unlessDomain = getDomainList(exec, asObject(unlessDomainValue));</span>
          if (!unlessDomain.has_value())
              return makeUnexpected(unlessDomain.error());
          trigger.conditions = WTFMove(unlessDomain.value());
          if (trigger.conditions.isEmpty())
              return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
          trigger.conditionType = Trigger::ConditionType::UnlessDomain;
      } else if (!unlessDomainValue.isUndefined())
          return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
  
<span class="line-modified">!     const JSValue ifTopURLValue = triggerObject.get(&amp;exec, Identifier::fromString(vm, &quot;if-top-url&quot;));</span>
      if (!scope.exception() &amp;&amp; ifTopURLValue.isObject()) {
          if (trigger.conditionType != Trigger::ConditionType::None)
              return makeUnexpected(ContentExtensionError::JSONMultipleConditions);
<span class="line-modified">!         auto ifTopURL = getStringList(exec, asObject(ifTopURLValue));</span>
          if (!ifTopURL.has_value())
              return makeUnexpected(ifTopURL.error());
          trigger.conditions = WTFMove(ifTopURL.value());
          if (trigger.conditions.isEmpty())
              return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
          trigger.conditionType = Trigger::ConditionType::IfTopURL;
      } else if (!ifTopURLValue.isUndefined())
          return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
  
<span class="line-modified">!     const JSValue unlessTopURLValue = triggerObject.get(&amp;exec, Identifier::fromString(vm, &quot;unless-top-url&quot;));</span>
      if (!scope.exception() &amp;&amp; unlessTopURLValue.isObject()) {
          if (trigger.conditionType != Trigger::ConditionType::None)
              return makeUnexpected(ContentExtensionError::JSONMultipleConditions);
<span class="line-modified">!         auto unlessTopURL = getStringList(exec, asObject(unlessTopURLValue));</span>
          if (!unlessTopURL.has_value())
              return makeUnexpected(unlessTopURL.error());
          trigger.conditions = WTFMove(unlessTopURL.value());
          if (trigger.conditions.isEmpty())
              return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
<span class="line-new-header">--- 54,170 ---</span>
              return false;
      }
      return true;
  }
  
<span class="line-modified">! static Expected&lt;Vector&lt;String&gt;, std::error_code&gt; getStringList(JSGlobalObject&amp; lexicalGlobalObject, const JSObject* arrayObject)</span>
  {
      static const ContentExtensionError error = ContentExtensionError::JSONInvalidConditionList;
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!arrayObject || !isJSArray(arrayObject))
          return makeUnexpected(error);
      const JSArray* array = jsCast&lt;const JSArray*&gt;(arrayObject);
  
      Vector&lt;String&gt; strings;
      unsigned length = array-&gt;length();
      for (unsigned i = 0; i &lt; length; ++i) {
<span class="line-modified">!         const JSValue value = array-&gt;getIndex(&amp;lexicalGlobalObject, i);</span>
          if (scope.exception() || !value.isString())
              return makeUnexpected(error);
  
<span class="line-modified">!         const String&amp; string = asString(value)-&gt;value(&amp;lexicalGlobalObject);</span>
          if (string.isEmpty())
              return makeUnexpected(error);
          strings.append(string);
      }
      return strings;
  }
  
<span class="line-modified">! static Expected&lt;Vector&lt;String&gt;, std::error_code&gt; getDomainList(JSGlobalObject&amp; lexicalGlobalObject, const JSObject* arrayObject)</span>
  {
<span class="line-modified">!     auto strings = getStringList(lexicalGlobalObject, arrayObject);</span>
      if (!strings.has_value())
          return strings;
      for (auto&amp; domain : strings.value()) {
          // Domains should be punycode encoded lower case.
          if (!containsOnlyASCIIWithNoUppercase(domain))
              return makeUnexpected(ContentExtensionError::JSONDomainNotLowerCaseASCII);
      }
      return strings;
  }
  
<span class="line-modified">! static std::error_code getTypeFlags(JSGlobalObject&amp; lexicalGlobalObject, const JSValue&amp; typeValue, ResourceFlags&amp; flags, uint16_t (*stringToType)(const String&amp;))</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!typeValue.isObject())
          return { };
  
<span class="line-modified">!     const JSObject* object = typeValue.toObject(&amp;lexicalGlobalObject);</span>
      scope.assertNoException();
      if (!isJSArray(object))
          return ContentExtensionError::JSONInvalidTriggerFlagsArray;
  
      const JSArray* array = jsCast&lt;const JSArray*&gt;(object);
  
      unsigned length = array-&gt;length();
      for (unsigned i = 0; i &lt; length; ++i) {
<span class="line-modified">!         const JSValue value = array-&gt;getIndex(&amp;lexicalGlobalObject, i);</span>
          if (scope.exception() || !value)
              return ContentExtensionError::JSONInvalidObjectInTriggerFlagsArray;
  
<span class="line-modified">!         String name = value.toWTFString(&amp;lexicalGlobalObject);</span>
          uint16_t type = stringToType(name);
          if (!type)
              return ContentExtensionError::JSONInvalidStringInTriggerFlagsArray;
  
          flags |= type;
      }
  
      return { };
  }
  
<span class="line-modified">! static Expected&lt;Trigger, std::error_code&gt; loadTrigger(JSGlobalObject&amp; lexicalGlobalObject, const JSObject&amp; ruleObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     const JSValue triggerObject = ruleObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;trigger&quot;));</span>
      if (!triggerObject || scope.exception() || !triggerObject.isObject())
          return makeUnexpected(ContentExtensionError::JSONInvalidTrigger);
  
<span class="line-modified">!     const JSValue urlFilterObject = triggerObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;url-filter&quot;));</span>
      if (!urlFilterObject || scope.exception() || !urlFilterObject.isString())
          return makeUnexpected(ContentExtensionError::JSONInvalidURLFilterInTrigger);
  
<span class="line-modified">!     String urlFilter = asString(urlFilterObject)-&gt;value(&amp;lexicalGlobalObject);</span>
      if (urlFilter.isEmpty())
          return makeUnexpected(ContentExtensionError::JSONInvalidURLFilterInTrigger);
  
      Trigger trigger;
      trigger.urlFilter = urlFilter;
  
<span class="line-modified">!     const JSValue urlFilterCaseValue = triggerObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;url-filter-is-case-sensitive&quot;));</span>
      if (urlFilterCaseValue &amp;&amp; !scope.exception() &amp;&amp; urlFilterCaseValue.isBoolean())
<span class="line-modified">!         trigger.urlFilterIsCaseSensitive = urlFilterCaseValue.toBoolean(&amp;lexicalGlobalObject);</span>
  
<span class="line-modified">!     const JSValue topURLFilterCaseValue = triggerObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;top-url-filter-is-case-sensitive&quot;));</span>
      if (topURLFilterCaseValue &amp;&amp; !scope.exception() &amp;&amp; topURLFilterCaseValue.isBoolean())
<span class="line-modified">!         trigger.topURLConditionIsCaseSensitive = topURLFilterCaseValue.toBoolean(&amp;lexicalGlobalObject);</span>
  
<span class="line-modified">!     const JSValue resourceTypeValue = triggerObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;resource-type&quot;));</span>
      if (!scope.exception() &amp;&amp; resourceTypeValue.isObject()) {
<span class="line-modified">!         auto typeFlagsError = getTypeFlags(lexicalGlobalObject, resourceTypeValue, trigger.flags, readResourceType);</span>
          if (typeFlagsError)
              return makeUnexpected(typeFlagsError);
      } else if (!resourceTypeValue.isUndefined())
          return makeUnexpected(ContentExtensionError::JSONInvalidTriggerFlagsArray);
  
<span class="line-modified">!     const JSValue loadTypeValue = triggerObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;load-type&quot;));</span>
      if (!scope.exception() &amp;&amp; loadTypeValue.isObject()) {
<span class="line-modified">!         auto typeFlagsError = getTypeFlags(lexicalGlobalObject, loadTypeValue, trigger.flags, readLoadType);</span>
          if (typeFlagsError)
              return makeUnexpected(typeFlagsError);
      } else if (!loadTypeValue.isUndefined())
          return makeUnexpected(ContentExtensionError::JSONInvalidTriggerFlagsArray);
  
<span class="line-modified">!     const JSValue ifDomainValue = triggerObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;if-domain&quot;));</span>
      if (!scope.exception() &amp;&amp; ifDomainValue.isObject()) {
<span class="line-modified">!         auto ifDomain = getDomainList(lexicalGlobalObject, asObject(ifDomainValue));</span>
          if (!ifDomain.has_value())
              return makeUnexpected(ifDomain.error());
          trigger.conditions = WTFMove(ifDomain.value());
          if (trigger.conditions.isEmpty())
              return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
          ASSERT(trigger.conditionType == Trigger::ConditionType::None);
          trigger.conditionType = Trigger::ConditionType::IfDomain;
      } else if (!ifDomainValue.isUndefined())
          return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
  
<span class="line-modified">!     const JSValue unlessDomainValue = triggerObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;unless-domain&quot;));</span>
      if (!scope.exception() &amp;&amp; unlessDomainValue.isObject()) {
          if (trigger.conditionType != Trigger::ConditionType::None)
              return makeUnexpected(ContentExtensionError::JSONMultipleConditions);
<span class="line-modified">!         auto unlessDomain = getDomainList(lexicalGlobalObject, asObject(unlessDomainValue));</span>
          if (!unlessDomain.has_value())
              return makeUnexpected(unlessDomain.error());
          trigger.conditions = WTFMove(unlessDomain.value());
          if (trigger.conditions.isEmpty())
              return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
          trigger.conditionType = Trigger::ConditionType::UnlessDomain;
      } else if (!unlessDomainValue.isUndefined())
          return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
  
<span class="line-modified">!     const JSValue ifTopURLValue = triggerObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;if-top-url&quot;));</span>
      if (!scope.exception() &amp;&amp; ifTopURLValue.isObject()) {
          if (trigger.conditionType != Trigger::ConditionType::None)
              return makeUnexpected(ContentExtensionError::JSONMultipleConditions);
<span class="line-modified">!         auto ifTopURL = getStringList(lexicalGlobalObject, asObject(ifTopURLValue));</span>
          if (!ifTopURL.has_value())
              return makeUnexpected(ifTopURL.error());
          trigger.conditions = WTFMove(ifTopURL.value());
          if (trigger.conditions.isEmpty())
              return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
          trigger.conditionType = Trigger::ConditionType::IfTopURL;
      } else if (!ifTopURLValue.isUndefined())
          return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
  
<span class="line-modified">!     const JSValue unlessTopURLValue = triggerObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;unless-top-url&quot;));</span>
      if (!scope.exception() &amp;&amp; unlessTopURLValue.isObject()) {
          if (trigger.conditionType != Trigger::ConditionType::None)
              return makeUnexpected(ContentExtensionError::JSONMultipleConditions);
<span class="line-modified">!         auto unlessTopURL = getStringList(lexicalGlobalObject, asObject(unlessTopURLValue));</span>
          if (!unlessTopURL.has_value())
              return makeUnexpected(unlessTopURL.error());
          trigger.conditions = WTFMove(unlessTopURL.value());
          if (trigger.conditions.isEmpty())
              return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 238,85 ***</span>
      CSSSelectorList selectorList;
      parser.parseSelector(selector, selectorList);
      return selectorList.isValid();
  }
  
<span class="line-modified">! static Expected&lt;Optional&lt;Action&gt;, std::error_code&gt; loadAction(ExecState&amp; exec, const JSObject&amp; ruleObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     const JSValue actionObject = ruleObject.get(&amp;exec, Identifier::fromString(vm, &quot;action&quot;));</span>
      if (scope.exception() || !actionObject.isObject())
          return makeUnexpected(ContentExtensionError::JSONInvalidAction);
  
<span class="line-modified">!     const JSValue typeObject = actionObject.get(&amp;exec, Identifier::fromString(vm, &quot;type&quot;));</span>
      if (scope.exception() || !typeObject.isString())
          return makeUnexpected(ContentExtensionError::JSONInvalidActionType);
  
<span class="line-modified">!     String actionType = asString(typeObject)-&gt;value(&amp;exec);</span>
  
      if (actionType == &quot;block&quot;)
          return { Action(ActionType::BlockLoad) };
      if (actionType == &quot;ignore-previous-rules&quot;)
          return { Action(ActionType::IgnorePreviousRules) };
      if (actionType == &quot;block-cookies&quot;)
          return { Action(ActionType::BlockCookies) };
      if (actionType == &quot;css-display-none&quot;) {
<span class="line-modified">!         JSValue selector = actionObject.get(&amp;exec, Identifier::fromString(vm, &quot;selector&quot;));</span>
          if (scope.exception() || !selector.isString())
              return makeUnexpected(ContentExtensionError::JSONInvalidCSSDisplayNoneActionType);
  
<span class="line-modified">!         String selectorString = asString(selector)-&gt;value(&amp;exec);</span>
          if (!isValidCSSSelector(selectorString)) {
              // Skip rules with invalid selectors to be backwards-compatible.
              return { WTF::nullopt };
          }
          return { Action(ActionType::CSSDisplayNoneSelector, selectorString) };
      }
      if (actionType == &quot;make-https&quot;)
          return { Action(ActionType::MakeHTTPS) };
      if (actionType == &quot;notify&quot;) {
<span class="line-modified">!         JSValue notification = actionObject.get(&amp;exec, Identifier::fromString(vm, &quot;notification&quot;));</span>
          if (scope.exception() || !notification.isString())
              return makeUnexpected(ContentExtensionError::JSONInvalidNotification);
<span class="line-modified">!         return { Action(ActionType::Notify, asString(notification)-&gt;value(&amp;exec)) };</span>
      }
      return makeUnexpected(ContentExtensionError::JSONInvalidActionType);
  }
  
<span class="line-modified">! static Expected&lt;Optional&lt;ContentExtensionRule&gt;, std::error_code&gt; loadRule(ExecState&amp; exec, const JSObject&amp; ruleObject)</span>
  {
<span class="line-modified">!     auto trigger = loadTrigger(exec, ruleObject);</span>
      if (!trigger.has_value())
          return makeUnexpected(trigger.error());
  
<span class="line-modified">!     auto action = loadAction(exec, ruleObject);</span>
      if (!action.has_value())
          return makeUnexpected(action.error());
  
      if (action.value())
          return {{{ WTFMove(trigger.value()), WTFMove(action.value().value()) }}};
  
      return { WTF::nullopt };
  }
  
<span class="line-modified">! static Expected&lt;Vector&lt;ContentExtensionRule&gt;, std::error_code&gt; loadEncodedRules(ExecState&amp; exec, const String&amp; ruleJSON)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // FIXME: JSONParse should require callbacks instead of an ExecState.
<span class="line-modified">!     const JSValue decodedRules = JSONParse(&amp;exec, ruleJSON);</span>
  
      if (scope.exception() || !decodedRules)
          return makeUnexpected(ContentExtensionError::JSONInvalid);
  
      if (!decodedRules.isObject())
          return makeUnexpected(ContentExtensionError::JSONTopLevelStructureNotAnObject);
  
<span class="line-modified">!     const JSObject* topLevelObject = decodedRules.toObject(&amp;exec);</span>
      if (!topLevelObject || scope.exception())
          return makeUnexpected(ContentExtensionError::JSONTopLevelStructureNotAnObject);
  
      if (!isJSArray(topLevelObject))
          return makeUnexpected(ContentExtensionError::JSONTopLevelStructureNotAnArray);
<span class="line-new-header">--- 238,85 ---</span>
      CSSSelectorList selectorList;
      parser.parseSelector(selector, selectorList);
      return selectorList.isValid();
  }
  
<span class="line-modified">! static Expected&lt;Optional&lt;Action&gt;, std::error_code&gt; loadAction(JSGlobalObject&amp; lexicalGlobalObject, const JSObject&amp; ruleObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     const JSValue actionObject = ruleObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;action&quot;));</span>
      if (scope.exception() || !actionObject.isObject())
          return makeUnexpected(ContentExtensionError::JSONInvalidAction);
  
<span class="line-modified">!     const JSValue typeObject = actionObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;type&quot;));</span>
      if (scope.exception() || !typeObject.isString())
          return makeUnexpected(ContentExtensionError::JSONInvalidActionType);
  
<span class="line-modified">!     String actionType = asString(typeObject)-&gt;value(&amp;lexicalGlobalObject);</span>
  
      if (actionType == &quot;block&quot;)
          return { Action(ActionType::BlockLoad) };
      if (actionType == &quot;ignore-previous-rules&quot;)
          return { Action(ActionType::IgnorePreviousRules) };
      if (actionType == &quot;block-cookies&quot;)
          return { Action(ActionType::BlockCookies) };
      if (actionType == &quot;css-display-none&quot;) {
<span class="line-modified">!         JSValue selector = actionObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;selector&quot;));</span>
          if (scope.exception() || !selector.isString())
              return makeUnexpected(ContentExtensionError::JSONInvalidCSSDisplayNoneActionType);
  
<span class="line-modified">!         String selectorString = asString(selector)-&gt;value(&amp;lexicalGlobalObject);</span>
          if (!isValidCSSSelector(selectorString)) {
              // Skip rules with invalid selectors to be backwards-compatible.
              return { WTF::nullopt };
          }
          return { Action(ActionType::CSSDisplayNoneSelector, selectorString) };
      }
      if (actionType == &quot;make-https&quot;)
          return { Action(ActionType::MakeHTTPS) };
      if (actionType == &quot;notify&quot;) {
<span class="line-modified">!         JSValue notification = actionObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;notification&quot;));</span>
          if (scope.exception() || !notification.isString())
              return makeUnexpected(ContentExtensionError::JSONInvalidNotification);
<span class="line-modified">!         return { Action(ActionType::Notify, asString(notification)-&gt;value(&amp;lexicalGlobalObject)) };</span>
      }
      return makeUnexpected(ContentExtensionError::JSONInvalidActionType);
  }
  
<span class="line-modified">! static Expected&lt;Optional&lt;ContentExtensionRule&gt;, std::error_code&gt; loadRule(JSGlobalObject&amp; lexicalGlobalObject, const JSObject&amp; ruleObject)</span>
  {
<span class="line-modified">!     auto trigger = loadTrigger(lexicalGlobalObject, ruleObject);</span>
      if (!trigger.has_value())
          return makeUnexpected(trigger.error());
  
<span class="line-modified">!     auto action = loadAction(lexicalGlobalObject, ruleObject);</span>
      if (!action.has_value())
          return makeUnexpected(action.error());
  
      if (action.value())
          return {{{ WTFMove(trigger.value()), WTFMove(action.value().value()) }}};
  
      return { WTF::nullopt };
  }
  
<span class="line-modified">! static Expected&lt;Vector&lt;ContentExtensionRule&gt;, std::error_code&gt; loadEncodedRules(JSGlobalObject&amp; lexicalGlobalObject, const String&amp; ruleJSON)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // FIXME: JSONParse should require callbacks instead of an ExecState.
<span class="line-modified">!     const JSValue decodedRules = JSONParse(&amp;lexicalGlobalObject, ruleJSON);</span>
  
      if (scope.exception() || !decodedRules)
          return makeUnexpected(ContentExtensionError::JSONInvalid);
  
      if (!decodedRules.isObject())
          return makeUnexpected(ContentExtensionError::JSONTopLevelStructureNotAnObject);
  
<span class="line-modified">!     const JSObject* topLevelObject = decodedRules.toObject(&amp;lexicalGlobalObject);</span>
      if (!topLevelObject || scope.exception())
          return makeUnexpected(ContentExtensionError::JSONTopLevelStructureNotAnObject);
  
      if (!isJSArray(topLevelObject))
          return makeUnexpected(ContentExtensionError::JSONTopLevelStructureNotAnArray);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 328,19 ***</span>
      unsigned length = topLevelArray-&gt;length();
      const unsigned maxRuleCount = 50000;
      if (length &gt; maxRuleCount)
          return makeUnexpected(ContentExtensionError::JSONTooManyRules);
      for (unsigned i = 0; i &lt; length; ++i) {
<span class="line-modified">!         const JSValue value = topLevelArray-&gt;getIndex(&amp;exec, i);</span>
          if (scope.exception() || !value)
              return makeUnexpected(ContentExtensionError::JSONInvalidObjectInTopLevelArray);
  
<span class="line-modified">!         const JSObject* ruleObject = value.toObject(&amp;exec);</span>
          if (!ruleObject || scope.exception())
              return makeUnexpected(ContentExtensionError::JSONInvalidRule);
  
<span class="line-modified">!         auto rule = loadRule(exec, *ruleObject);</span>
          if (!rule.has_value())
              return makeUnexpected(rule.error());
          if (rule.value())
              ruleList.append(WTFMove(*rule.value()));
      }
<span class="line-new-header">--- 328,19 ---</span>
      unsigned length = topLevelArray-&gt;length();
      const unsigned maxRuleCount = 50000;
      if (length &gt; maxRuleCount)
          return makeUnexpected(ContentExtensionError::JSONTooManyRules);
      for (unsigned i = 0; i &lt; length; ++i) {
<span class="line-modified">!         const JSValue value = topLevelArray-&gt;getIndex(&amp;lexicalGlobalObject, i);</span>
          if (scope.exception() || !value)
              return makeUnexpected(ContentExtensionError::JSONInvalidObjectInTopLevelArray);
  
<span class="line-modified">!         const JSObject* ruleObject = value.toObject(&amp;lexicalGlobalObject);</span>
          if (!ruleObject || scope.exception())
              return makeUnexpected(ContentExtensionError::JSONInvalidRule);
  
<span class="line-modified">!         auto rule = loadRule(lexicalGlobalObject, *ruleObject);</span>
          if (!rule.has_value())
              return makeUnexpected(rule.error());
          if (rule.value())
              ruleList.append(WTFMove(*rule.value()));
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 356,12 ***</span>
      RefPtr&lt;VM&gt; vm = VM::create();
  
      JSLockHolder locker(vm.get());
      JSGlobalObject* globalObject = JSGlobalObject::create(*vm, JSGlobalObject::createStructure(*vm, jsNull()));
  
<span class="line-modified">!     ExecState* exec = globalObject-&gt;globalExec();</span>
<span class="line-modified">!     auto ruleList = loadEncodedRules(*exec, ruleJSON);</span>
  
      vm = nullptr;
  
      if (!ruleList.has_value())
          return makeUnexpected(ruleList.error());
<span class="line-new-header">--- 356,12 ---</span>
      RefPtr&lt;VM&gt; vm = VM::create();
  
      JSLockHolder locker(vm.get());
      JSGlobalObject* globalObject = JSGlobalObject::create(*vm, JSGlobalObject::createStructure(*vm, jsNull()));
  
<span class="line-modified">!     JSGlobalObject* lexicalGlobalObject = globalObject;</span>
<span class="line-modified">!     auto ruleList = loadEncodedRules(*lexicalGlobalObject, ruleJSON);</span>
  
      vm = nullptr;
  
      if (!ruleList.has_value())
          return makeUnexpected(ruleList.error());
</pre>
<center><a href="ContentExtensionCompiler.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ContentExtensionsBackend.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSTypedArray.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015 Dominic Szablewski (dominic@phoboslab.org)
  3  * Copyright (C) 2016 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;JSTypedArray.h&quot;
 29 
 30 #include &quot;APICast.h&quot;
 31 #include &quot;APIUtils.h&quot;
 32 #include &quot;ClassInfo.h&quot;
 33 #include &quot;Error.h&quot;
 34 #include &quot;JSArrayBufferViewInlines.h&quot;
 35 #include &quot;JSCInlines.h&quot;
 36 #include &quot;JSDataView.h&quot;
 37 #include &quot;JSGenericTypedArrayViewInlines.h&quot;
 38 #include &quot;JSTypedArrays.h&quot;
 39 #include &quot;TypedArrayController.h&quot;
 40 #include &lt;wtf/RefPtr.h&gt;
 41 
 42 using namespace JSC;
 43 
 44 // Helper functions.
 45 
 46 inline JSTypedArrayType toJSTypedArrayType(TypedArrayType type)
 47 {
 48     switch (type) {
 49     case JSC::TypeDataView:
 50     case NotTypedArray:
 51         return kJSTypedArrayTypeNone;
 52     case TypeInt8:
 53         return kJSTypedArrayTypeInt8Array;
 54     case TypeUint8:
 55         return kJSTypedArrayTypeUint8Array;
 56     case TypeUint8Clamped:
 57         return kJSTypedArrayTypeUint8ClampedArray;
 58     case TypeInt16:
 59         return kJSTypedArrayTypeInt16Array;
 60     case TypeUint16:
 61         return kJSTypedArrayTypeUint16Array;
 62     case TypeInt32:
 63         return kJSTypedArrayTypeInt32Array;
 64     case TypeUint32:
 65         return kJSTypedArrayTypeUint32Array;
 66     case TypeFloat32:
 67         return kJSTypedArrayTypeFloat32Array;
 68     case TypeFloat64:
 69         return kJSTypedArrayTypeFloat64Array;
 70     }
 71     RELEASE_ASSERT_NOT_REACHED();
 72 }
 73 
 74 inline TypedArrayType toTypedArrayType(JSTypedArrayType type)
 75 {
 76     switch (type) {
 77     case kJSTypedArrayTypeArrayBuffer:
 78     case kJSTypedArrayTypeNone:
 79         return NotTypedArray;
 80     case kJSTypedArrayTypeInt8Array:
 81         return TypeInt8;
 82     case kJSTypedArrayTypeUint8Array:
 83         return TypeUint8;
 84     case kJSTypedArrayTypeUint8ClampedArray:
 85         return TypeUint8Clamped;
 86     case kJSTypedArrayTypeInt16Array:
 87         return TypeInt16;
 88     case kJSTypedArrayTypeUint16Array:
 89         return TypeUint16;
 90     case kJSTypedArrayTypeInt32Array:
 91         return TypeInt32;
 92     case kJSTypedArrayTypeUint32Array:
 93         return TypeUint32;
 94     case kJSTypedArrayTypeFloat32Array:
 95         return TypeFloat32;
 96     case kJSTypedArrayTypeFloat64Array:
 97         return TypeFloat64;
 98     }
 99     RELEASE_ASSERT_NOT_REACHED();
100 }
101 
102 static JSObject* createTypedArray(JSGlobalObject* globalObject, JSTypedArrayType type, RefPtr&lt;ArrayBuffer&gt;&amp;&amp; buffer, size_t offset, size_t length)
103 {
104     VM&amp; vm = globalObject-&gt;vm();
105     auto scope = DECLARE_THROW_SCOPE(vm);
106     if (!buffer) {
107         throwOutOfMemoryError(globalObject, scope);
108         return nullptr;
109     }
110     switch (type) {
111     case kJSTypedArrayTypeInt8Array:
112         return JSInt8Array::create(globalObject, globalObject-&gt;typedArrayStructure(TypeInt8), WTFMove(buffer), offset, length);
113     case kJSTypedArrayTypeInt16Array:
114         return JSInt16Array::create(globalObject, globalObject-&gt;typedArrayStructure(TypeInt16), WTFMove(buffer), offset, length);
115     case kJSTypedArrayTypeInt32Array:
116         return JSInt32Array::create(globalObject, globalObject-&gt;typedArrayStructure(TypeInt32), WTFMove(buffer), offset, length);
117     case kJSTypedArrayTypeUint8Array:
118         return JSUint8Array::create(globalObject, globalObject-&gt;typedArrayStructure(TypeUint8), WTFMove(buffer), offset, length);
119     case kJSTypedArrayTypeUint8ClampedArray:
120         return JSUint8ClampedArray::create(globalObject, globalObject-&gt;typedArrayStructure(TypeUint8Clamped), WTFMove(buffer), offset, length);
121     case kJSTypedArrayTypeUint16Array:
122         return JSUint16Array::create(globalObject, globalObject-&gt;typedArrayStructure(TypeUint16), WTFMove(buffer), offset, length);
123     case kJSTypedArrayTypeUint32Array:
124         return JSUint32Array::create(globalObject, globalObject-&gt;typedArrayStructure(TypeUint32), WTFMove(buffer), offset, length);
125     case kJSTypedArrayTypeFloat32Array:
126         return JSFloat32Array::create(globalObject, globalObject-&gt;typedArrayStructure(TypeFloat32), WTFMove(buffer), offset, length);
127     case kJSTypedArrayTypeFloat64Array:
128         return JSFloat64Array::create(globalObject, globalObject-&gt;typedArrayStructure(TypeFloat64), WTFMove(buffer), offset, length);
129     case kJSTypedArrayTypeArrayBuffer:
130     case kJSTypedArrayTypeNone:
131         RELEASE_ASSERT_NOT_REACHED();
132     }
133     return nullptr;
134 }
135 
136 // Implementations of the API functions.
137 
138 JSTypedArrayType JSValueGetTypedArrayType(JSContextRef ctx, JSValueRef valueRef, JSValueRef*)
139 {
140 
141     JSGlobalObject* globalObject = toJS(ctx);
142     VM&amp; vm = globalObject-&gt;vm();
143     JSLockHolder locker(vm);
144 
145     JSValue value = toJS(globalObject, valueRef);
146     if (!value.isObject())
147         return kJSTypedArrayTypeNone;
148     JSObject* object = value.getObject();
149 
150     if (jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, object))
151         return kJSTypedArrayTypeArrayBuffer;
152 
153     return toJSTypedArrayType(object-&gt;classInfo(vm)-&gt;typedArrayStorageType);
154 }
155 
156 JSObjectRef JSObjectMakeTypedArray(JSContextRef ctx, JSTypedArrayType arrayType, size_t length, JSValueRef* exception)
157 {
158     JSGlobalObject* globalObject = toJS(ctx);
159     VM&amp; vm = globalObject-&gt;vm();
160     JSLockHolder locker(vm);
161     auto scope = DECLARE_CATCH_SCOPE(vm);
162 
163     if (arrayType == kJSTypedArrayTypeNone || arrayType == kJSTypedArrayTypeArrayBuffer)
164         return nullptr;
165 
166     unsigned elementByteSize = elementSize(toTypedArrayType(arrayType));
167 
168     auto buffer = ArrayBuffer::tryCreate(length, elementByteSize);
169     JSObject* result = createTypedArray(globalObject, arrayType, WTFMove(buffer), 0, length);
170     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)
171         return nullptr;
172     return toRef(result);
173 }
174 
175 JSObjectRef JSObjectMakeTypedArrayWithBytesNoCopy(JSContextRef ctx, JSTypedArrayType arrayType, void* bytes, size_t length, JSTypedArrayBytesDeallocator destructor, void* destructorContext, JSValueRef* exception)
176 {
177     JSGlobalObject* globalObject = toJS(ctx);
178     VM&amp; vm = globalObject-&gt;vm();
179     JSLockHolder locker(vm);
180     auto scope = DECLARE_CATCH_SCOPE(vm);
181 
182     if (arrayType == kJSTypedArrayTypeNone || arrayType == kJSTypedArrayTypeArrayBuffer)
183         return nullptr;
184 
185     unsigned elementByteSize = elementSize(toTypedArrayType(arrayType));
186 
187     auto buffer = ArrayBuffer::createFromBytes(bytes, length, createSharedTask&lt;void(void*)&gt;([=](void* p) {
188         if (destructor)
189             destructor(p, destructorContext);
190     }));
191     JSObject* result = createTypedArray(globalObject, arrayType, WTFMove(buffer), 0, length / elementByteSize);
192     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)
193         return nullptr;
194     return toRef(result);
195 }
196 
197 JSObjectRef JSObjectMakeTypedArrayWithArrayBuffer(JSContextRef ctx, JSTypedArrayType arrayType, JSObjectRef jsBufferRef, JSValueRef* exception)
198 {
199     JSGlobalObject* globalObject = toJS(ctx);
200     VM&amp; vm = globalObject-&gt;vm();
201     JSLockHolder locker(vm);
202     auto scope = DECLARE_CATCH_SCOPE(vm);
203 
204     if (arrayType == kJSTypedArrayTypeNone || arrayType == kJSTypedArrayTypeArrayBuffer)
205         return nullptr;
206 
207     JSArrayBuffer* jsBuffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, toJS(jsBufferRef));
208     if (!jsBuffer) {
209         setException(ctx, exception, createTypeError(globalObject, &quot;JSObjectMakeTypedArrayWithArrayBuffer expects buffer to be an Array Buffer object&quot;));
210         return nullptr;
211     }
212 
213     RefPtr&lt;ArrayBuffer&gt; buffer = jsBuffer-&gt;impl();
214     unsigned elementByteSize = elementSize(toTypedArrayType(arrayType));
215 
216     JSObject* result = createTypedArray(globalObject, arrayType, WTFMove(buffer), 0, buffer-&gt;byteLength() / elementByteSize);
217     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)
218         return nullptr;
219     return toRef(result);
220 }
221 
222 JSObjectRef JSObjectMakeTypedArrayWithArrayBufferAndOffset(JSContextRef ctx, JSTypedArrayType arrayType, JSObjectRef jsBufferRef, size_t offset, size_t length, JSValueRef* exception)
223 {
224     JSGlobalObject* globalObject = toJS(ctx);
225     VM&amp; vm = globalObject-&gt;vm();
226     JSLockHolder locker(vm);
227     auto scope = DECLARE_CATCH_SCOPE(vm);
228 
229     if (arrayType == kJSTypedArrayTypeNone || arrayType == kJSTypedArrayTypeArrayBuffer)
230         return nullptr;
231 
232     JSArrayBuffer* jsBuffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, toJS(jsBufferRef));
233     if (!jsBuffer) {
234         setException(ctx, exception, createTypeError(globalObject, &quot;JSObjectMakeTypedArrayWithArrayBuffer expects buffer to be an Array Buffer object&quot;));
235         return nullptr;
236     }
237 
238     JSObject* result = createTypedArray(globalObject, arrayType, jsBuffer-&gt;impl(), offset, length);
239     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)
240         return nullptr;
241     return toRef(result);
242 }
243 
244 void* JSObjectGetTypedArrayBytesPtr(JSContextRef ctx, JSObjectRef objectRef, JSValueRef*)
245 {
246     JSGlobalObject* globalObject = toJS(ctx);
247     VM&amp; vm = globalObject-&gt;vm();
248     JSLockHolder locker(vm);
249     JSObject* object = toJS(objectRef);
250 
251     if (JSArrayBufferView* typedArray = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, object)) {
252         ArrayBuffer* buffer = typedArray-&gt;possiblySharedBuffer();
253         buffer-&gt;pinAndLock();
254         return buffer-&gt;data();
255     }
256     return nullptr;
257 }
258 
259 size_t JSObjectGetTypedArrayLength(JSContextRef ctx, JSObjectRef objectRef, JSValueRef*)
260 {
261     JSGlobalObject* globalObject = toJS(ctx);
262     VM&amp; vm = globalObject-&gt;vm();
263     JSObject* object = toJS(objectRef);
264 
265     if (JSArrayBufferView* typedArray = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, object))
266         return typedArray-&gt;length();
267 
268     return 0;
269 }
270 
271 size_t JSObjectGetTypedArrayByteLength(JSContextRef ctx, JSObjectRef objectRef, JSValueRef*)
272 {
273     JSGlobalObject* globalObject = toJS(ctx);
274     VM&amp; vm = globalObject-&gt;vm();
275     JSObject* object = toJS(objectRef);
276 
277     if (JSArrayBufferView* typedArray = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, object))
278         return typedArray-&gt;length() * elementSize(typedArray-&gt;classInfo(vm)-&gt;typedArrayStorageType);
279 
280     return 0;
281 }
282 
283 size_t JSObjectGetTypedArrayByteOffset(JSContextRef ctx, JSObjectRef objectRef, JSValueRef*)
284 {
285     JSGlobalObject* globalObject = toJS(ctx);
286     VM&amp; vm = globalObject-&gt;vm();
287     JSObject* object = toJS(objectRef);
288 
289     if (JSArrayBufferView* typedArray = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, object))
290         return typedArray-&gt;byteOffset();
291 
292     return 0;
293 }
294 
295 JSObjectRef JSObjectGetTypedArrayBuffer(JSContextRef ctx, JSObjectRef objectRef, JSValueRef*)
296 {
297     JSGlobalObject* globalObject = toJS(ctx);
298     VM&amp; vm = globalObject-&gt;vm();
299     JSLockHolder locker(vm);
300     JSObject* object = toJS(objectRef);
301 
302     if (JSArrayBufferView* typedArray = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, object))
303         return toRef(vm.m_typedArrayController-&gt;toJS(globalObject, typedArray-&gt;globalObject(vm), typedArray-&gt;possiblySharedBuffer()));
304 
305     return nullptr;
306 }
307 
308 JSObjectRef JSObjectMakeArrayBufferWithBytesNoCopy(JSContextRef ctx, void* bytes, size_t byteLength, JSTypedArrayBytesDeallocator bytesDeallocator, void* deallocatorContext, JSValueRef* exception)
309 {
310     JSGlobalObject* globalObject = toJS(ctx);
311     VM&amp; vm = globalObject-&gt;vm();
312     JSLockHolder locker(vm);
313     auto scope = DECLARE_CATCH_SCOPE(vm);
314 
315     auto buffer = ArrayBuffer::createFromBytes(bytes, byteLength, createSharedTask&lt;void(void*)&gt;([=](void* p) {
316         if (bytesDeallocator)
317             bytesDeallocator(p, deallocatorContext);
318     }));
319 
320     JSArrayBuffer* jsBuffer = JSArrayBuffer::create(vm, globalObject-&gt;arrayBufferStructure(ArrayBufferSharingMode::Default), WTFMove(buffer));
321     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)
322         return nullptr;
323 
324     return toRef(jsBuffer);
325 }
326 
327 void* JSObjectGetArrayBufferBytesPtr(JSContextRef ctx, JSObjectRef objectRef, JSValueRef* exception)
328 {
329     JSGlobalObject* globalObject = toJS(ctx);
330     VM&amp; vm = globalObject-&gt;vm();
331     JSLockHolder locker(vm);
332     JSObject* object = toJS(objectRef);
333 
334     if (JSArrayBuffer* jsBuffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, object)) {
335         ArrayBuffer* buffer = jsBuffer-&gt;impl();
336         if (buffer-&gt;isWasmMemory()) {
337             setException(ctx, exception, createTypeError(globalObject, &quot;Cannot get the backing buffer for a WebAssembly.Memory&quot;_s));
338             return nullptr;
339         }
340 
341         buffer-&gt;pinAndLock();
342         return buffer-&gt;data();
343     }
344     return nullptr;
345 }
346 
347 size_t JSObjectGetArrayBufferByteLength(JSContextRef ctx, JSObjectRef objectRef, JSValueRef*)
348 {
349     JSGlobalObject* globalObject = toJS(ctx);
350     VM&amp; vm = globalObject-&gt;vm();
351     JSObject* object = toJS(objectRef);
352 
353     if (JSArrayBuffer* jsBuffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, object))
354         return jsBuffer-&gt;impl()-&gt;byteLength();
355 
356     return 0;
357 }
    </pre>
  </body>
</html>
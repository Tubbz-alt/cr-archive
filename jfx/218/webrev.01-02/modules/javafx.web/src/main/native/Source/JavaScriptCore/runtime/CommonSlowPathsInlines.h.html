<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CommonSlowPathsInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2020 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;BytecodeStructs.h&quot;
 29 #include &quot;CommonSlowPaths.h&quot;
 30 
 31 namespace JSC {
 32 
 33 namespace CommonSlowPaths {
 34 
 35 inline void tryCachePutToScopeGlobal(
 36     JSGlobalObject* globalObject, CodeBlock* codeBlock, OpPutToScope&amp; bytecode, JSObject* scope,
 37     PutPropertySlot&amp; slot, const Identifier&amp; ident)
 38 {
 39     // Covers implicit globals. Since they don&#39;t exist until they first execute, we didn&#39;t know how to cache them at compile time.
 40     auto&amp; metadata = bytecode.metadata(codeBlock);
 41     ResolveType resolveType = metadata.m_getPutInfo.resolveType();
 42 
 43     switch (resolveType) {
 44     case UnresolvedProperty:
 45     case UnresolvedPropertyWithVarInjectionChecks: {
 46         if (scope-&gt;isGlobalObject()) {
 47             ResolveType newResolveType = needsVarInjectionChecks(resolveType) ? GlobalPropertyWithVarInjectionChecks : GlobalProperty;
 48             resolveType = newResolveType; // Allow below caching mechanism to kick in.
 49             ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 50             metadata.m_getPutInfo = GetPutInfo(metadata.m_getPutInfo.resolveMode(), newResolveType, metadata.m_getPutInfo.initializationMode());
 51             break;
 52         }
 53         FALLTHROUGH;
 54     }
 55     case GlobalProperty:
 56     case GlobalPropertyWithVarInjectionChecks: {
 57         // Global Lexical Binding Epoch is changed. Update op_get_from_scope from GlobalProperty to GlobalLexicalVar.
 58         if (scope-&gt;isGlobalLexicalEnvironment()) {
 59             JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalLexicalEnvironment*&gt;(scope);
 60             ResolveType newResolveType = needsVarInjectionChecks(resolveType) ? GlobalLexicalVarWithVarInjectionChecks : GlobalLexicalVar;
 61             SymbolTableEntry entry = globalLexicalEnvironment-&gt;symbolTable()-&gt;get(ident.impl());
 62             ASSERT(!entry.isNull());
 63             ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 64             metadata.m_getPutInfo = GetPutInfo(metadata.m_getPutInfo.resolveMode(), newResolveType, metadata.m_getPutInfo.initializationMode());
 65             metadata.m_watchpointSet = entry.watchpointSet();
 66             metadata.m_operand = reinterpret_cast&lt;uintptr_t&gt;(globalLexicalEnvironment-&gt;variableAt(entry.scopeOffset()).slot());
 67             return;
 68         }
 69         break;
 70     }
 71     default:
 72         return;
 73     }
 74 
 75     if (resolveType == GlobalProperty || resolveType == GlobalPropertyWithVarInjectionChecks) {
 76         VM&amp; vm = getVM(globalObject);
 77         JSGlobalObject* globalObject = codeBlock-&gt;globalObject();
 78         ASSERT(globalObject == scope || globalObject-&gt;varInjectionWatchpoint()-&gt;hasBeenInvalidated());
 79         if (!slot.isCacheablePut()
 80             || slot.base() != scope
 81             || scope != globalObject
 82             || !scope-&gt;structure(vm)-&gt;propertyAccessesAreCacheable())
 83             return;
 84 
 85         if (slot.type() == PutPropertySlot::NewProperty) {
 86             // Don&#39;t cache if we&#39;ve done a transition. We want to detect the first replace so that we
 87             // can invalidate the watchpoint.
 88             return;
 89         }
 90 
 91         scope-&gt;structure(vm)-&gt;didCachePropertyReplacement(vm, slot.cachedOffset());
 92 
 93         ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 94         metadata.m_structure.set(vm, codeBlock, scope-&gt;structure(vm));
 95         metadata.m_operand = slot.cachedOffset();
 96     }
 97 }
 98 
 99 inline void tryCacheGetFromScopeGlobal(
100     JSGlobalObject* globalObject, CodeBlock* codeBlock, VM&amp; vm, OpGetFromScope&amp; bytecode, JSObject* scope, PropertySlot&amp; slot, const Identifier&amp; ident)
101 {
102     auto&amp; metadata = bytecode.metadata(codeBlock);
103     ResolveType resolveType = metadata.m_getPutInfo.resolveType();
104 
105     switch (resolveType) {
106     case UnresolvedProperty:
107     case UnresolvedPropertyWithVarInjectionChecks: {
108         if (scope-&gt;isGlobalObject()) {
109             ResolveType newResolveType = needsVarInjectionChecks(resolveType) ? GlobalPropertyWithVarInjectionChecks : GlobalProperty;
110             resolveType = newResolveType; // Allow below caching mechanism to kick in.
111             ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
112             metadata.m_getPutInfo = GetPutInfo(metadata.m_getPutInfo.resolveMode(), newResolveType, metadata.m_getPutInfo.initializationMode());
113             break;
114         }
115         FALLTHROUGH;
116     }
117     case GlobalProperty:
118     case GlobalPropertyWithVarInjectionChecks: {
119         // Global Lexical Binding Epoch is changed. Update op_get_from_scope from GlobalProperty to GlobalLexicalVar.
120         if (scope-&gt;isGlobalLexicalEnvironment()) {
121             JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalLexicalEnvironment*&gt;(scope);
122             ResolveType newResolveType = needsVarInjectionChecks(resolveType) ? GlobalLexicalVarWithVarInjectionChecks : GlobalLexicalVar;
123             SymbolTableEntry entry = globalLexicalEnvironment-&gt;symbolTable()-&gt;get(ident.impl());
124             ASSERT(!entry.isNull());
125             ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
126             metadata.m_getPutInfo = GetPutInfo(metadata.m_getPutInfo.resolveMode(), newResolveType, metadata.m_getPutInfo.initializationMode());
127             metadata.m_watchpointSet = entry.watchpointSet();
128             metadata.m_operand = reinterpret_cast&lt;uintptr_t&gt;(globalLexicalEnvironment-&gt;variableAt(entry.scopeOffset()).slot());
129             return;
130         }
131         break;
132     }
133     default:
134         return;
135     }
136 
137     // Covers implicit globals. Since they don&#39;t exist until they first execute, we didn&#39;t know how to cache them at compile time.
138     if (resolveType == GlobalProperty || resolveType == GlobalPropertyWithVarInjectionChecks) {
139         ASSERT(scope == globalObject || globalObject-&gt;varInjectionWatchpoint()-&gt;hasBeenInvalidated());
140         if (slot.isCacheableValue() &amp;&amp; slot.slotBase() == scope &amp;&amp; scope == globalObject &amp;&amp; scope-&gt;structure(vm)-&gt;propertyAccessesAreCacheable()) {
141             Structure* structure = scope-&gt;structure(vm);
142             {
143                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
144                 metadata.m_structure.set(vm, codeBlock, structure);
145                 metadata.m_operand = slot.cachedOffset();
146             }
147             structure-&gt;startWatchingPropertyForReplacements(vm, slot.cachedOffset());
148         }
149     }
150 }
151 
152 }} // namespace JSC::CommonSlowPaths
    </pre>
  </body>
</html>
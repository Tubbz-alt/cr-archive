<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlockFlow.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderBlockFlow.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBox.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlockFlow.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 35,10 ***</span>
<span class="line-new-header">--- 35,16 ---</span>
  
  class LineBreaker;
  class RenderMultiColumnFlow;
  class RenderRubyRun;
  
<span class="line-added">+ #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">+ namespace LayoutIntegration {</span>
<span class="line-added">+ class LineLayout;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  #if ENABLE(TEXT_AUTOSIZING)
  enum LineCount {
      NOT_SET = 0, NO_LINE = 1, ONE_LINE = 2, MULTI_LINE = 3
  };
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 70,12 ***</span>
      LayoutUnit collapsedMarginBefore() const final { return maxPositiveMarginBefore() - maxNegativeMarginBefore(); }
      LayoutUnit collapsedMarginAfter() const final { return maxPositiveMarginAfter() - maxNegativeMarginAfter(); }
  
      void dirtyLinesFromChangedChild(RenderObject&amp; child) final
      {
<span class="line-modified">!         if (m_complexLineLayout)</span>
<span class="line-modified">!             m_complexLineLayout-&gt;lineBoxes().dirtyLinesFromChangedChild(*this, child);</span>
      }
  
      void paintColumnRules(PaintInfo&amp;, const LayoutPoint&amp;) override;
  
  public:
<span class="line-new-header">--- 76,12 ---</span>
      LayoutUnit collapsedMarginBefore() const final { return maxPositiveMarginBefore() - maxNegativeMarginBefore(); }
      LayoutUnit collapsedMarginAfter() const final { return maxPositiveMarginAfter() - maxNegativeMarginAfter(); }
  
      void dirtyLinesFromChangedChild(RenderObject&amp; child) final
      {
<span class="line-modified">!         if (complexLineLayout())</span>
<span class="line-modified">!             complexLineLayout()-&gt;lineBoxes().dirtyLinesFromChangedChild(*this, child);</span>
      }
  
      void paintColumnRules(PaintInfo&amp;, const LayoutPoint&amp;) override;
  
  public:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 330,33 ***</span>
              floatingObject.setMarginOffset(LayoutSize(logicalBeforeMargin, logicalLeftMargin));
      }
  
      LayoutPoint flipFloatForWritingModeForChild(const FloatingObject&amp;, const LayoutPoint&amp;) const;
  
<span class="line-modified">!     RootInlineBox* firstRootBox() const { return m_complexLineLayout ? m_complexLineLayout-&gt;firstRootBox() : nullptr; }</span>
<span class="line-modified">!     RootInlineBox* lastRootBox() const { return m_complexLineLayout ? m_complexLineLayout-&gt;lastRootBox() : nullptr; }</span>
  
      bool hasLines() const;
      void invalidateLineLayoutPath() final;
  
<span class="line-modified">!     enum LineLayoutPath { UndeterminedPath = 0, SimpleLinesPath, LineBoxesPath, ForceLineBoxesPath };</span>
      LineLayoutPath lineLayoutPath() const { return static_cast&lt;LineLayoutPath&gt;(renderBlockFlowLineLayoutPath()); }
      void setLineLayoutPath(LineLayoutPath path) { setRenderBlockFlowLineLayoutPath(path); }
  
      // Helper methods for computing line counts and heights for line counts.
      RootInlineBox* lineAtIndex(int) const;
<span class="line-modified">!     int lineCount(const RootInlineBox* = nullptr, bool* = nullptr) const;</span>
      int heightForLineCount(int);
      void clearTruncation();
  
      void setHasMarkupTruncation(bool b) { setRenderBlockFlowHasMarkupTruncation(b); }
      bool hasMarkupTruncation() const { return renderBlockFlowHasMarkupTruncation(); }
  
      bool containsNonZeroBidiLevel() const;
  
      const SimpleLineLayout::Layout* simpleLineLayout() const;
<span class="line-modified">!     void deleteLineBoxesBeforeSimpleLineLayout();</span>
      void ensureLineBoxes();
      void generateLineBoxTree();
  
  #if ENABLE(TREE_DEBUGGING)
      void outputLineTreeAndMark(WTF::TextStream&amp;, const InlineBox* markedBox, int depth) const;
<span class="line-new-header">--- 336,40 ---</span>
              floatingObject.setMarginOffset(LayoutSize(logicalBeforeMargin, logicalLeftMargin));
      }
  
      LayoutPoint flipFloatForWritingModeForChild(const FloatingObject&amp;, const LayoutPoint&amp;) const;
  
<span class="line-modified">!     RootInlineBox* firstRootBox() const { return complexLineLayout() ? complexLineLayout()-&gt;firstRootBox() : nullptr; }</span>
<span class="line-modified">!     RootInlineBox* lastRootBox() const { return complexLineLayout() ? complexLineLayout()-&gt;lastRootBox() : nullptr; }</span>
  
      bool hasLines() const;
      void invalidateLineLayoutPath() final;
  
<span class="line-modified">!     enum LineLayoutPath { UndeterminedPath = 0, SimpleLinesPath, LineBoxesPath, LayoutFormattingContextPath, ForceLineBoxesPath };</span>
      LineLayoutPath lineLayoutPath() const { return static_cast&lt;LineLayoutPath&gt;(renderBlockFlowLineLayoutPath()); }
      void setLineLayoutPath(LineLayoutPath path) { setRenderBlockFlowLineLayoutPath(path); }
  
      // Helper methods for computing line counts and heights for line counts.
      RootInlineBox* lineAtIndex(int) const;
<span class="line-modified">!     int lineCount() const;</span>
      int heightForLineCount(int);
      void clearTruncation();
  
      void setHasMarkupTruncation(bool b) { setRenderBlockFlowHasMarkupTruncation(b); }
      bool hasMarkupTruncation() const { return renderBlockFlowHasMarkupTruncation(); }
  
      bool containsNonZeroBidiLevel() const;
  
      const SimpleLineLayout::Layout* simpleLineLayout() const;
<span class="line-modified">!     SimpleLineLayout::Layout* simpleLineLayout();</span>
<span class="line-added">+     const ComplexLineLayout* complexLineLayout() const;</span>
<span class="line-added">+     ComplexLineLayout* complexLineLayout();</span>
<span class="line-added">+ #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">+     const LayoutIntegration::LineLayout* layoutFormattingContextLineLayout() const;</span>
<span class="line-added">+     LayoutIntegration::LineLayout* layoutFormattingContextLineLayout();</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      void ensureLineBoxes();
      void generateLineBoxTree();
  
  #if ENABLE(TREE_DEBUGGING)
      void outputLineTreeAndMark(WTF::TextStream&amp;, const InlineBox* markedBox, int depth) const;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 389,10 ***</span>
<span class="line-new-header">--- 402,12 ---</span>
      void updateMinimumPageHeight(LayoutUnit offset, LayoutUnit minHeight);
  
      void addFloatsToNewParent(RenderBlockFlow&amp; toBlockFlow) const;
  
  protected:
<span class="line-added">+     bool shouldResetLogicalHeightBeforeLayout() const override { return true; }</span>
<span class="line-added">+ </span>
      void computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const override;
  
      bool pushToNextPageWithMinimumLogicalHeight(LayoutUnit&amp; adjustment, LayoutUnit logicalOffset, LayoutUnit minimumLogicalHeight) const;
  
      // If the child is unsplittable and can&#39;t fit on the current page, return the top of the next page/column.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 519,18 ***</span>
      Position positionForBox(InlineBox*, bool start = true) const;
      VisiblePosition positionForPointWithInlineChildren(const LayoutPoint&amp; pointInLogicalContents, const RenderFragmentContainer*) override;
      void addFocusRingRectsForInlineChildren(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject*) override;
  
  public:
<span class="line-removed">-     ComplexLineLayout* complexLineLayout() { return m_complexLineLayout.get(); }</span>
<span class="line-removed">- </span>
      virtual Optional&lt;TextAlignMode&gt; overrideTextAlignmentForLine(bool /* endsWithSoftBreak */) const { return { }; }
      virtual void adjustInlineDirectionLineBounds(int /* expansionOpportunityCount */, float&amp; /* logicalLeft */, float&amp; /* logicalWidth */) const { }
  
  private:
      void layoutSimpleLines(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom);
  
      void adjustIntrinsicLogicalWidthsForColumns(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const;
      void computeInlinePreferredLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const;
      void adjustInitialLetterPosition(RenderBox&amp; childBox, LayoutUnit&amp; logicalTopOffset, LayoutUnit&amp; marginBeforeOffset);
  
  #if ENABLE(TEXT_AUTOSIZING)
<span class="line-new-header">--- 534,25 ---</span>
      Position positionForBox(InlineBox*, bool start = true) const;
      VisiblePosition positionForPointWithInlineChildren(const LayoutPoint&amp; pointInLogicalContents, const RenderFragmentContainer*) override;
      void addFocusRingRectsForInlineChildren(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject*) override;
  
  public:
      virtual Optional&lt;TextAlignMode&gt; overrideTextAlignmentForLine(bool /* endsWithSoftBreak */) const { return { }; }
      virtual void adjustInlineDirectionLineBounds(int /* expansionOpportunityCount */, float&amp; /* logicalLeft */, float&amp; /* logicalWidth */) const { }
  
  private:
<span class="line-added">+     bool hasLineLayout() const;</span>
<span class="line-added">+     bool hasSimpleLineLayout() const;</span>
<span class="line-added">+     bool hasComplexLineLayout() const;</span>
<span class="line-added">+ </span>
      void layoutSimpleLines(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom);
  
<span class="line-added">+ #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">+     bool hasLayoutFormattingContextLineLayout() const;</span>
<span class="line-added">+     void layoutLFCLines(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      void adjustIntrinsicLogicalWidthsForColumns(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const;
      void computeInlinePreferredLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const;
      void adjustInitialLetterPosition(RenderBox&amp; childBox, LayoutUnit&amp; logicalTopOffset, LayoutUnit&amp; marginBeforeOffset);
  
  #if ENABLE(TEXT_AUTOSIZING)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 563,23 ***</span>
  
  protected:
      std::unique_ptr&lt;FloatingObjects&gt; m_floatingObjects;
      std::unique_ptr&lt;RenderBlockFlowRareData&gt; m_rareBlockFlowData;
  
<span class="line-modified">!     // FIXME: Only one of these should be needed at any given time.</span>
<span class="line-modified">!     std::unique_ptr&lt;ComplexLineLayout&gt; m_complexLineLayout;</span>
<span class="line-modified">!     std::unique_ptr&lt;SimpleLineLayout::Layout&gt; m_simpleLineLayout;</span>
  
      friend class LineBreaker;
      friend class LineWidth; // Needs to know FloatingObject
      friend class ComplexLineLayout;
  };
  
  inline const SimpleLineLayout::Layout* RenderBlockFlow::simpleLineLayout() const
  {
<span class="line-modified">!     ASSERT(lineLayoutPath() == SimpleLinesPath || !m_simpleLineLayout);</span>
<span class="line-modified">!     return m_simpleLineLayout.get();</span>
  }
  
  } // namespace WebCore
  
  SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(RenderBlockFlow, isRenderBlockFlow())
<span class="line-new-header">--- 585,75 ---</span>
  
  protected:
      std::unique_ptr&lt;FloatingObjects&gt; m_floatingObjects;
      std::unique_ptr&lt;RenderBlockFlowRareData&gt; m_rareBlockFlowData;
  
<span class="line-modified">! private:</span>
<span class="line-modified">!     Variant&lt;</span>
<span class="line-modified">!         WTF::Monostate,</span>
<span class="line-added">+         Ref&lt;SimpleLineLayout::Layout&gt;,</span>
<span class="line-added">+ #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">+         std::unique_ptr&lt;LayoutIntegration::LineLayout&gt;,</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+         std::unique_ptr&lt;ComplexLineLayout&gt;</span>
<span class="line-added">+     &gt; m_lineLayout;</span>
  
      friend class LineBreaker;
      friend class LineWidth; // Needs to know FloatingObject
      friend class ComplexLineLayout;
  };
  
<span class="line-added">+ inline bool RenderBlockFlow::hasLineLayout() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return !WTF::holds_alternative&lt;WTF::Monostate&gt;(m_lineLayout);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline bool RenderBlockFlow::hasComplexLineLayout() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return WTF::holds_alternative&lt;std::unique_ptr&lt;ComplexLineLayout&gt;&gt;(m_lineLayout);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline const ComplexLineLayout* RenderBlockFlow::complexLineLayout() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return hasComplexLineLayout() ? WTF::get&lt;std::unique_ptr&lt;ComplexLineLayout&gt;&gt;(m_lineLayout).get() : nullptr;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline ComplexLineLayout* RenderBlockFlow::complexLineLayout()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return hasComplexLineLayout() ? WTF::get&lt;std::unique_ptr&lt;ComplexLineLayout&gt;&gt;(m_lineLayout).get() : nullptr;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline bool RenderBlockFlow::hasSimpleLineLayout() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return WTF::holds_alternative&lt;Ref&lt;SimpleLineLayout::Layout&gt;&gt;(m_lineLayout);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  inline const SimpleLineLayout::Layout* RenderBlockFlow::simpleLineLayout() const
  {
<span class="line-modified">!     return hasSimpleLineLayout() ? WTF::get&lt;Ref&lt;SimpleLineLayout::Layout&gt;&gt;(m_lineLayout).ptr() : nullptr;</span>
<span class="line-modified">! }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline SimpleLineLayout::Layout* RenderBlockFlow::simpleLineLayout()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return hasSimpleLineLayout() ? WTF::get&lt;Ref&lt;SimpleLineLayout::Layout&gt;&gt;(m_lineLayout).ptr() : nullptr;</span>
  }
  
<span class="line-added">+ #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">+ inline bool RenderBlockFlow::hasLayoutFormattingContextLineLayout() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return WTF::holds_alternative&lt;std::unique_ptr&lt;LayoutIntegration::LineLayout&gt;&gt;(m_lineLayout);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline const LayoutIntegration::LineLayout* RenderBlockFlow::layoutFormattingContextLineLayout() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return hasLayoutFormattingContextLineLayout() ? WTF::get&lt;std::unique_ptr&lt;LayoutIntegration::LineLayout&gt;&gt;(m_lineLayout).get() : nullptr;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline LayoutIntegration::LineLayout* RenderBlockFlow::layoutFormattingContextLineLayout()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return hasLayoutFormattingContextLineLayout() ? WTF::get&lt;std::unique_ptr&lt;LayoutIntegration::LineLayout&gt;&gt;(m_lineLayout).get() : nullptr;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  } // namespace WebCore
  
  SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(RenderBlockFlow, isRenderBlockFlow())
</pre>
<center><a href="RenderBlockFlow.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBox.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
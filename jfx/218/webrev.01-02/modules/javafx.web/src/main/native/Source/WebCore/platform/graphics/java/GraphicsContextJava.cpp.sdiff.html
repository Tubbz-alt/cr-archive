<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/java/GraphicsContextJava.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FontCustomPlatformData.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ImageBufferJava.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/java/GraphicsContextJava.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 93 
 94     context-&gt;rq().freeSpace(4 * 11 + 8 * nStops)
 95     &lt;&lt; id
 96     &lt;&lt; (jfloat)p0.x()
 97     &lt;&lt; (jfloat)p0.y()
 98     &lt;&lt; (jfloat)p1.x()
 99     &lt;&lt; (jfloat)p1.y()
100     &lt;&lt; (jint)(gradient.type() == Gradient::Type::Radial);
101 
102     if (gradient.type() == Gradient::Type::Radial) {
103         context-&gt;rq()
104         &lt;&lt; (jfloat)(gt.xScale() * startRadius)
105         &lt;&lt; (jfloat)(gt.xScale() * endRadius);
106     }
107     context-&gt;rq()
108     &lt;&lt; (jint)0 //is not proportional
109     &lt;&lt; (jint)gradient.spreadMethod()
110     &lt;&lt; (jint)nStops;
111 
112     for (const auto&amp; cs : stops) {
<span class="line-modified">113         int rgba = (int)cs.color.rgb();</span>
114         context-&gt;rq()
115         &lt;&lt; (jint)rgba &lt;&lt; (jfloat)cs.offset;
116     }
117 }
118 
119 class GraphicsContextPlatformPrivate : public PlatformGraphicsContext {
120 };
121 
122 void GraphicsContext::platformInit(PlatformGraphicsContext* context) // TODO-java: , bool shouldUseContextColors) // todo tav new param
123 {
124     m_data = static_cast&lt;GraphicsContextPlatformPrivate *&gt;(context);
125 }
126 
127 PlatformGraphicsContext* GraphicsContext::platformContext() const
128 {
129     return m_data;
130 }
131 
132 void GraphicsContext::platformDestroy()
133 {
</pre>
<hr />
<pre>
189 //void GraphicsContext::strokeArc(const IntRect&amp; rect, int startAngle, int angleSpan)
190 //{
191 //    if (paintingDisabled() || strokeStyle() == NoStroke)
192 //        return;
193 //
194 //    platformContext()-&gt;rq().freeSpace(28)
195 //    &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_STROKEARC
196 //    &lt;&lt; (jint)rect.x() &lt;&lt; (jint)rect.y() &lt;&lt; (jint)rect.width() &lt;&lt; (jint)rect.height()
197 //    &lt;&lt; (jint)startAngle &lt;&lt; (jint)angleSpan;
198 //}
199 
200 void GraphicsContext::fillRect(const FloatRect&amp; rect, const Color&amp; color)
201 {
202     if (paintingDisabled())
203         return;
204 
205     platformContext()-&gt;rq().freeSpace(24)
206     &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_FILLRECT_FFFFI
207     &lt;&lt; rect.x() &lt;&lt; rect.y()
208     &lt;&lt; rect.width() &lt;&lt; rect.height()
<span class="line-modified">209     &lt;&lt; (jint)color.rgb();</span>
210 }
211 
212 void GraphicsContext::fillRect(const FloatRect&amp; rect)
213 {
214     if (paintingDisabled())
215         return;
216 
217     if (m_state.fillPattern) {
218         Image&amp; img = m_state.fillPattern-&gt;tileImage();
219         FloatRect destRect(
220             rect.x(),
221             rect.y(),
222             m_state.fillPattern-&gt;repeatX() ? rect.width() : img.width(),
223             m_state.fillPattern-&gt;repeatY() ? rect.height() : img.height());
224         img.drawPattern(
225             *this,
226             destRect,
227             FloatRect(0., 0., img.width(), img.height()),
228             m_state.fillPattern-&gt;getPatternSpaceTransform(),
229             FloatPoint(),
230             FloatSize(),
<span class="line-modified">231             CompositeCopy);</span>
232     } else {
233         if (m_state.fillGradient) {
234             setGradient(
235                 *m_state.fillGradient,
236                 platformContext(),
237                 com_sun_webkit_graphics_GraphicsDecoder_SET_FILL_GRADIENT);
238         }
239 
240         platformContext()-&gt;rq().freeSpace(20)
241         &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_FILLRECT_FFFF
242         &lt;&lt; rect.x() &lt;&lt; rect.y()
243         &lt;&lt; rect.width() &lt;&lt; rect.height();
244     }
245 }
246 
247 void GraphicsContext::clip(const FloatRect&amp; rect)
248 {
249     if (paintingDisabled())
250         return;
251 
</pre>
<hr />
<pre>
299                 needAdd = false;
300                 break;
301             } else if (focusRect.contains(rect)) {
302                 toDraw.remove(j);
303             } else if (rect.intersects(focusRect)) {
304                 focusRect.unite(rect);
305                 toDraw.remove(j);
306             }
307         }
308         if (needAdd) {
309             toDraw.append(focusRect);
310         }
311     }
312 
313     platformContext()-&gt;rq().freeSpace(24 * toDraw.size());
314     for (size_t i = 0; i &lt; toDraw.size(); i++) {
315         IntRect focusRect = toDraw[i];
316         platformContext()-&gt;rq() &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_DRAWFOCUSRING
317         &lt;&lt; (jint)focusRect.x() &lt;&lt; (jint)focusRect.y()
318         &lt;&lt; (jint)focusRect.width() &lt;&lt; (jint)focusRect.height()
<span class="line-modified">319         &lt;&lt; (jint)color.rgb();</span>
320     }
321 }
322 
323 void GraphicsContext::drawLinesForText(const FloatPoint&amp; origin, float thickness, const DashArray&amp; widths, bool, bool, StrokeStyle stroke) {
324 
325     if (paintingDisabled())
326         return;
327 
328     for (const auto&amp; width : widths) {
329         // This is a workaround for http://bugs.webkit.org/show_bug.cgi?id=15659
330         StrokeStyle savedStrokeStyle = strokeStyle();
331         setStrokeStyle(stroke);
332 
333         FloatPoint endPoint = origin + FloatPoint(width, thickness);
334         drawLine(
335             IntPoint(origin.x(), origin.y()),
336             IntPoint(endPoint.x(), endPoint.y()));
337 
338         setStrokeStyle(savedStrokeStyle);
339     }
</pre>
<hr />
<pre>
457 }
458 
459 void GraphicsContext::translate(float x, float y)
460 {
461     if (paintingDisabled())
462         return;
463 
464     m_state.transform.translate(x, y);
465     platformContext()-&gt;rq().freeSpace(12)
466     &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_TRANSLATE
467     &lt;&lt; x &lt;&lt; y;
468 }
469 
470 void GraphicsContext::setPlatformFillColor(const Color&amp; col)
471 {
472     if (paintingDisabled())
473         return;
474 
475     platformContext()-&gt;rq().freeSpace(8)
476     &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_SETFILLCOLOR
<span class="line-modified">477     &lt;&lt; (jint)col.rgb();</span>
478 }
479 
480 void GraphicsContext::setPlatformTextDrawingMode(TextDrawingModeFlags mode)
481 {
482     if (paintingDisabled())
483         return;
484 
485     platformContext()-&gt;rq().freeSpace(16)
486     &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_SET_TEXT_MODE
487     &lt;&lt; (jint)(mode &amp; TextModeFill)
488     &lt;&lt; (jint)(mode &amp; TextModeStroke)
489     &lt;&lt; (jint)0;
490     //utatodo:
491     //&lt;&lt; (jint)(mode &amp; TextModeClip);
492 }
493 
494 void GraphicsContext::setPlatformStrokeStyle(StrokeStyle style)
495 {
496     if (paintingDisabled())
497         return;
498 
499     platformContext()-&gt;rq().freeSpace(8)
500     &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_SETSTROKESTYLE
501     &lt;&lt; (jint)style;
502 }
503 
504 void GraphicsContext::setPlatformStrokeColor(const Color&amp; col)
505 {
506     if (paintingDisabled())
507         return;
508 
509     platformContext()-&gt;rq().freeSpace(8)
510     &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_SETSTROKECOLOR
<span class="line-modified">511     &lt;&lt; (jint)col.rgb();</span>
512 }
513 
514 void GraphicsContext::setPlatformStrokeThickness(float strokeThickness)
515 {
516     if (paintingDisabled())
517         return;
518 
519     platformContext()-&gt;rq().freeSpace(8)
520     &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_SETSTROKEWIDTH
521     &lt;&lt; strokeThickness;
522 }
523 
524 void GraphicsContext::setPlatformImageInterpolationQuality(InterpolationQuality)
525 {
526     notImplemented();
527 }
528 
529 void GraphicsContext::setPlatformShouldAntialias(bool)
530 {
531     notImplemented();
</pre>
<hr />
<pre>
558 //    rect.inflate(-thickness);
559 //    path.addEllipse(rect);
560 //    clipPath(path, WindRule::EvenOdd);
561 //}
562 
563 void GraphicsContext::setPlatformShadow(const FloatSize&amp; s, float blur, const Color&amp; color)
564 {
565     if (paintingDisabled())
566         return;
567 
568     float width = s.width();
569     float height = s.height();
570     if (shadowsIgnoreTransforms()) {
571         // Meaning that this graphics context is associated with a CanvasRenderingContext
572         // We flip the height since JavaFX Prism and HTML5 Canvas have opposite Y axis
573         height = -height;
574     }
575 
576     platformContext()-&gt;rq().freeSpace(20)
577     &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_SETSHADOW
<span class="line-modified">578     &lt;&lt; width &lt;&lt; height &lt;&lt; blur &lt;&lt; (jint)color.rgb();</span>
579 }
580 
581 void GraphicsContext::clearPlatformShadow()
582 {
583     setPlatformShadow(FloatSize(0, 0), 0, Color());
584 }
585 
586 bool GraphicsContext::supportsTransparencyLayers()
587 {
588     return true;
589 }
590 
591 void GraphicsContext::beginPlatformTransparencyLayer(float opacity)
592 {
593     if (paintingDisabled())
594       return;
595 
596     platformContext()-&gt;rq().freeSpace(8)
597     &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_BEGINTRANSPARENCYLAYER
598     &lt;&lt; opacity;
</pre>
<hr />
<pre>
816         return;
817 
818     if (m_state.fillPattern) {
819         savePlatformState(); //fake clip isolation
820         clipPath(path, m_state.fillRule);
821         FloatRect rect(path.boundingRect());
822 
823         Image&amp; img = m_state.fillPattern-&gt;tileImage();
824         FloatRect destRect(
825             rect.x(),
826             rect.y(),
827             m_state.fillPattern-&gt;repeatX() ? rect.width() : img.width(),
828             m_state.fillPattern-&gt;repeatY() ? rect.height() : img.height());
829         img.drawPattern(
830             *this,
831             destRect,
832             FloatRect(0., 0., img.width(), img.height()),
833             m_state.fillPattern-&gt;getPatternSpaceTransform(),
834             FloatPoint(),
835             FloatSize(),
<span class="line-modified">836             CompositeCopy);</span>
837         restorePlatformState();
838     } else {
839         if (m_state.fillGradient) {
840             setGradient(
841                 *m_state.fillGradient,
842                 platformContext(),
843                 com_sun_webkit_graphics_GraphicsDecoder_SET_FILL_GRADIENT);
844         }
845 
846         platformContext()-&gt;rq().freeSpace(12)
847         &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_FILL_PATH
848         &lt;&lt; copyPath(path.platformPath())
849         &lt;&lt; (jint)fillRule();
850     }
851 }
852 
853 void GraphicsContext::rotate(float radians)
854 {
855     if (paintingDisabled())
856         return;
</pre>
<hr />
<pre>
875 
876 void GraphicsContext::fillRoundedRect(const FloatRoundedRect&amp; rect, const Color&amp; color, BlendMode) // todo tav Int to Float
877 {
878     if (paintingDisabled())
879         return;
880 
881     if (rect.radii().topLeft().width() == rect.radii().topRight().width() &amp;&amp;
882         rect.radii().topRight().width() == rect.radii().bottomRight().width() &amp;&amp;
883         rect.radii().bottomRight().width() == rect.radii().bottomLeft().width() &amp;&amp;
884         rect.radii().topLeft().height() == rect.radii().topRight().height() &amp;&amp;
885         rect.radii().topRight().height() == rect.radii().bottomRight().height() &amp;&amp;
886         rect.radii().bottomRight().height() == rect.radii().bottomLeft().height()) {
887         platformContext()-&gt;rq().freeSpace(56)
888         &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_FILL_ROUNDED_RECT
889         &lt;&lt; (jfloat)rect.rect().x() &lt;&lt; (jfloat)rect.rect().y()
890         &lt;&lt; (jfloat)rect.rect().width() &lt;&lt; (jfloat)rect.rect().height()
891         &lt;&lt; (jfloat)rect.radii().topLeft().width() &lt;&lt; (jfloat)rect.radii().topLeft().height()
892         &lt;&lt; (jfloat)rect.radii().topRight().width() &lt;&lt; (jfloat)rect.radii().topRight().height()
893         &lt;&lt; (jfloat)rect.radii().bottomLeft().width() &lt;&lt; (jfloat)rect.radii().bottomLeft().height()
894         &lt;&lt; (jfloat)rect.radii().bottomRight().width() &lt;&lt; (jfloat)rect.radii().bottomRight().height()
<span class="line-modified">895         &lt;&lt; (jint)color.rgb();</span>
896     }
897     else {
898         WindRule oldFillRule = fillRule();
899         Color oldFillColor = fillColor();
900 
901         setFillRule(WindRule::EvenOdd);
902         setFillColor(color);
903 
904         Path roundedRectPath;
905         roundedRectPath.addRoundedRect(rect);
906         fillPath(roundedRectPath);
907 
908         setFillRule(oldFillRule);
909         setFillColor(oldFillColor);
910     }
911 }
912 
913 void GraphicsContext::fillRectWithRoundedHole(const FloatRect&amp; frect, const FloatRoundedRect&amp; roundedHoleRect, const Color&amp; color)
914 {
915     if (paintingDisabled())
</pre>
</td>
<td>
<hr />
<pre>
 93 
 94     context-&gt;rq().freeSpace(4 * 11 + 8 * nStops)
 95     &lt;&lt; id
 96     &lt;&lt; (jfloat)p0.x()
 97     &lt;&lt; (jfloat)p0.y()
 98     &lt;&lt; (jfloat)p1.x()
 99     &lt;&lt; (jfloat)p1.y()
100     &lt;&lt; (jint)(gradient.type() == Gradient::Type::Radial);
101 
102     if (gradient.type() == Gradient::Type::Radial) {
103         context-&gt;rq()
104         &lt;&lt; (jfloat)(gt.xScale() * startRadius)
105         &lt;&lt; (jfloat)(gt.xScale() * endRadius);
106     }
107     context-&gt;rq()
108     &lt;&lt; (jint)0 //is not proportional
109     &lt;&lt; (jint)gradient.spreadMethod()
110     &lt;&lt; (jint)nStops;
111 
112     for (const auto&amp; cs : stops) {
<span class="line-modified">113         int rgba = (int)cs.color.rgb().value();</span>
114         context-&gt;rq()
115         &lt;&lt; (jint)rgba &lt;&lt; (jfloat)cs.offset;
116     }
117 }
118 
119 class GraphicsContextPlatformPrivate : public PlatformGraphicsContext {
120 };
121 
122 void GraphicsContext::platformInit(PlatformGraphicsContext* context) // TODO-java: , bool shouldUseContextColors) // todo tav new param
123 {
124     m_data = static_cast&lt;GraphicsContextPlatformPrivate *&gt;(context);
125 }
126 
127 PlatformGraphicsContext* GraphicsContext::platformContext() const
128 {
129     return m_data;
130 }
131 
132 void GraphicsContext::platformDestroy()
133 {
</pre>
<hr />
<pre>
189 //void GraphicsContext::strokeArc(const IntRect&amp; rect, int startAngle, int angleSpan)
190 //{
191 //    if (paintingDisabled() || strokeStyle() == NoStroke)
192 //        return;
193 //
194 //    platformContext()-&gt;rq().freeSpace(28)
195 //    &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_STROKEARC
196 //    &lt;&lt; (jint)rect.x() &lt;&lt; (jint)rect.y() &lt;&lt; (jint)rect.width() &lt;&lt; (jint)rect.height()
197 //    &lt;&lt; (jint)startAngle &lt;&lt; (jint)angleSpan;
198 //}
199 
200 void GraphicsContext::fillRect(const FloatRect&amp; rect, const Color&amp; color)
201 {
202     if (paintingDisabled())
203         return;
204 
205     platformContext()-&gt;rq().freeSpace(24)
206     &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_FILLRECT_FFFFI
207     &lt;&lt; rect.x() &lt;&lt; rect.y()
208     &lt;&lt; rect.width() &lt;&lt; rect.height()
<span class="line-modified">209     &lt;&lt; (jint)color.rgb().value();</span>
210 }
211 
212 void GraphicsContext::fillRect(const FloatRect&amp; rect)
213 {
214     if (paintingDisabled())
215         return;
216 
217     if (m_state.fillPattern) {
218         Image&amp; img = m_state.fillPattern-&gt;tileImage();
219         FloatRect destRect(
220             rect.x(),
221             rect.y(),
222             m_state.fillPattern-&gt;repeatX() ? rect.width() : img.width(),
223             m_state.fillPattern-&gt;repeatY() ? rect.height() : img.height());
224         img.drawPattern(
225             *this,
226             destRect,
227             FloatRect(0., 0., img.width(), img.height()),
228             m_state.fillPattern-&gt;getPatternSpaceTransform(),
229             FloatPoint(),
230             FloatSize(),
<span class="line-modified">231             CompositeOperator::Copy);</span>
232     } else {
233         if (m_state.fillGradient) {
234             setGradient(
235                 *m_state.fillGradient,
236                 platformContext(),
237                 com_sun_webkit_graphics_GraphicsDecoder_SET_FILL_GRADIENT);
238         }
239 
240         platformContext()-&gt;rq().freeSpace(20)
241         &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_FILLRECT_FFFF
242         &lt;&lt; rect.x() &lt;&lt; rect.y()
243         &lt;&lt; rect.width() &lt;&lt; rect.height();
244     }
245 }
246 
247 void GraphicsContext::clip(const FloatRect&amp; rect)
248 {
249     if (paintingDisabled())
250         return;
251 
</pre>
<hr />
<pre>
299                 needAdd = false;
300                 break;
301             } else if (focusRect.contains(rect)) {
302                 toDraw.remove(j);
303             } else if (rect.intersects(focusRect)) {
304                 focusRect.unite(rect);
305                 toDraw.remove(j);
306             }
307         }
308         if (needAdd) {
309             toDraw.append(focusRect);
310         }
311     }
312 
313     platformContext()-&gt;rq().freeSpace(24 * toDraw.size());
314     for (size_t i = 0; i &lt; toDraw.size(); i++) {
315         IntRect focusRect = toDraw[i];
316         platformContext()-&gt;rq() &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_DRAWFOCUSRING
317         &lt;&lt; (jint)focusRect.x() &lt;&lt; (jint)focusRect.y()
318         &lt;&lt; (jint)focusRect.width() &lt;&lt; (jint)focusRect.height()
<span class="line-modified">319         &lt;&lt; (jint)color.rgb().value();</span>
320     }
321 }
322 
323 void GraphicsContext::drawLinesForText(const FloatPoint&amp; origin, float thickness, const DashArray&amp; widths, bool, bool, StrokeStyle stroke) {
324 
325     if (paintingDisabled())
326         return;
327 
328     for (const auto&amp; width : widths) {
329         // This is a workaround for http://bugs.webkit.org/show_bug.cgi?id=15659
330         StrokeStyle savedStrokeStyle = strokeStyle();
331         setStrokeStyle(stroke);
332 
333         FloatPoint endPoint = origin + FloatPoint(width, thickness);
334         drawLine(
335             IntPoint(origin.x(), origin.y()),
336             IntPoint(endPoint.x(), endPoint.y()));
337 
338         setStrokeStyle(savedStrokeStyle);
339     }
</pre>
<hr />
<pre>
457 }
458 
459 void GraphicsContext::translate(float x, float y)
460 {
461     if (paintingDisabled())
462         return;
463 
464     m_state.transform.translate(x, y);
465     platformContext()-&gt;rq().freeSpace(12)
466     &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_TRANSLATE
467     &lt;&lt; x &lt;&lt; y;
468 }
469 
470 void GraphicsContext::setPlatformFillColor(const Color&amp; col)
471 {
472     if (paintingDisabled())
473         return;
474 
475     platformContext()-&gt;rq().freeSpace(8)
476     &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_SETFILLCOLOR
<span class="line-modified">477     &lt;&lt; (jint)col.rgb().value();</span>
478 }
479 
480 void GraphicsContext::setPlatformTextDrawingMode(TextDrawingModeFlags mode)
481 {
482     if (paintingDisabled())
483         return;
484 
485     platformContext()-&gt;rq().freeSpace(16)
486     &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_SET_TEXT_MODE
487     &lt;&lt; (jint)(mode &amp; TextModeFill)
488     &lt;&lt; (jint)(mode &amp; TextModeStroke)
489     &lt;&lt; (jint)0;
490     //utatodo:
491     //&lt;&lt; (jint)(mode &amp; TextModeClip);
492 }
493 
494 void GraphicsContext::setPlatformStrokeStyle(StrokeStyle style)
495 {
496     if (paintingDisabled())
497         return;
498 
499     platformContext()-&gt;rq().freeSpace(8)
500     &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_SETSTROKESTYLE
501     &lt;&lt; (jint)style;
502 }
503 
504 void GraphicsContext::setPlatformStrokeColor(const Color&amp; col)
505 {
506     if (paintingDisabled())
507         return;
508 
509     platformContext()-&gt;rq().freeSpace(8)
510     &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_SETSTROKECOLOR
<span class="line-modified">511     &lt;&lt; (jint)col.rgb().value();</span>
512 }
513 
514 void GraphicsContext::setPlatformStrokeThickness(float strokeThickness)
515 {
516     if (paintingDisabled())
517         return;
518 
519     platformContext()-&gt;rq().freeSpace(8)
520     &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_SETSTROKEWIDTH
521     &lt;&lt; strokeThickness;
522 }
523 
524 void GraphicsContext::setPlatformImageInterpolationQuality(InterpolationQuality)
525 {
526     notImplemented();
527 }
528 
529 void GraphicsContext::setPlatformShouldAntialias(bool)
530 {
531     notImplemented();
</pre>
<hr />
<pre>
558 //    rect.inflate(-thickness);
559 //    path.addEllipse(rect);
560 //    clipPath(path, WindRule::EvenOdd);
561 //}
562 
563 void GraphicsContext::setPlatformShadow(const FloatSize&amp; s, float blur, const Color&amp; color)
564 {
565     if (paintingDisabled())
566         return;
567 
568     float width = s.width();
569     float height = s.height();
570     if (shadowsIgnoreTransforms()) {
571         // Meaning that this graphics context is associated with a CanvasRenderingContext
572         // We flip the height since JavaFX Prism and HTML5 Canvas have opposite Y axis
573         height = -height;
574     }
575 
576     platformContext()-&gt;rq().freeSpace(20)
577     &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_SETSHADOW
<span class="line-modified">578     &lt;&lt; width &lt;&lt; height &lt;&lt; blur &lt;&lt; (jint)color.rgb().value();</span>
579 }
580 
581 void GraphicsContext::clearPlatformShadow()
582 {
583     setPlatformShadow(FloatSize(0, 0), 0, Color());
584 }
585 
586 bool GraphicsContext::supportsTransparencyLayers()
587 {
588     return true;
589 }
590 
591 void GraphicsContext::beginPlatformTransparencyLayer(float opacity)
592 {
593     if (paintingDisabled())
594       return;
595 
596     platformContext()-&gt;rq().freeSpace(8)
597     &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_BEGINTRANSPARENCYLAYER
598     &lt;&lt; opacity;
</pre>
<hr />
<pre>
816         return;
817 
818     if (m_state.fillPattern) {
819         savePlatformState(); //fake clip isolation
820         clipPath(path, m_state.fillRule);
821         FloatRect rect(path.boundingRect());
822 
823         Image&amp; img = m_state.fillPattern-&gt;tileImage();
824         FloatRect destRect(
825             rect.x(),
826             rect.y(),
827             m_state.fillPattern-&gt;repeatX() ? rect.width() : img.width(),
828             m_state.fillPattern-&gt;repeatY() ? rect.height() : img.height());
829         img.drawPattern(
830             *this,
831             destRect,
832             FloatRect(0., 0., img.width(), img.height()),
833             m_state.fillPattern-&gt;getPatternSpaceTransform(),
834             FloatPoint(),
835             FloatSize(),
<span class="line-modified">836             CompositeOperator::Copy);</span>
837         restorePlatformState();
838     } else {
839         if (m_state.fillGradient) {
840             setGradient(
841                 *m_state.fillGradient,
842                 platformContext(),
843                 com_sun_webkit_graphics_GraphicsDecoder_SET_FILL_GRADIENT);
844         }
845 
846         platformContext()-&gt;rq().freeSpace(12)
847         &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_FILL_PATH
848         &lt;&lt; copyPath(path.platformPath())
849         &lt;&lt; (jint)fillRule();
850     }
851 }
852 
853 void GraphicsContext::rotate(float radians)
854 {
855     if (paintingDisabled())
856         return;
</pre>
<hr />
<pre>
875 
876 void GraphicsContext::fillRoundedRect(const FloatRoundedRect&amp; rect, const Color&amp; color, BlendMode) // todo tav Int to Float
877 {
878     if (paintingDisabled())
879         return;
880 
881     if (rect.radii().topLeft().width() == rect.radii().topRight().width() &amp;&amp;
882         rect.radii().topRight().width() == rect.radii().bottomRight().width() &amp;&amp;
883         rect.radii().bottomRight().width() == rect.radii().bottomLeft().width() &amp;&amp;
884         rect.radii().topLeft().height() == rect.radii().topRight().height() &amp;&amp;
885         rect.radii().topRight().height() == rect.radii().bottomRight().height() &amp;&amp;
886         rect.radii().bottomRight().height() == rect.radii().bottomLeft().height()) {
887         platformContext()-&gt;rq().freeSpace(56)
888         &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_FILL_ROUNDED_RECT
889         &lt;&lt; (jfloat)rect.rect().x() &lt;&lt; (jfloat)rect.rect().y()
890         &lt;&lt; (jfloat)rect.rect().width() &lt;&lt; (jfloat)rect.rect().height()
891         &lt;&lt; (jfloat)rect.radii().topLeft().width() &lt;&lt; (jfloat)rect.radii().topLeft().height()
892         &lt;&lt; (jfloat)rect.radii().topRight().width() &lt;&lt; (jfloat)rect.radii().topRight().height()
893         &lt;&lt; (jfloat)rect.radii().bottomLeft().width() &lt;&lt; (jfloat)rect.radii().bottomLeft().height()
894         &lt;&lt; (jfloat)rect.radii().bottomRight().width() &lt;&lt; (jfloat)rect.radii().bottomRight().height()
<span class="line-modified">895         &lt;&lt; (jint)color.rgb().value();</span>
896     }
897     else {
898         WindRule oldFillRule = fillRule();
899         Color oldFillColor = fillColor();
900 
901         setFillRule(WindRule::EvenOdd);
902         setFillColor(color);
903 
904         Path roundedRectPath;
905         roundedRectPath.addRoundedRect(rect);
906         fillPath(roundedRectPath);
907 
908         setFillRule(oldFillRule);
909         setFillColor(oldFillColor);
910     }
911 }
912 
913 void GraphicsContext::fillRectWithRoundedHole(const FloatRect&amp; frect, const FloatRoundedRect&amp; roundedHoleRect, const Color&amp; color)
914 {
915     if (paintingDisabled())
</pre>
</td>
</tr>
</table>
<center><a href="FontCustomPlatformData.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ImageBufferJava.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
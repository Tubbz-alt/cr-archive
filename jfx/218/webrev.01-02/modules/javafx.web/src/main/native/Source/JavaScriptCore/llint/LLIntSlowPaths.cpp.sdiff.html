<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/llint/LLIntSlowPaths.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LLIntPCRanges.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LLIntSlowPaths.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/llint/LLIntSlowPaths.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;LLIntSlowPaths.h&quot;
  28 
  29 #include &quot;ArrayConstructor.h&quot;

  30 #include &quot;CallFrame.h&quot;
<span class="line-modified">  31 #include &quot;CommonSlowPaths.h&quot;</span>

  32 #include &quot;Error.h&quot;
  33 #include &quot;ErrorHandlingScope.h&quot;
  34 #include &quot;EvalCodeBlock.h&quot;
  35 #include &quot;Exception.h&quot;
  36 #include &quot;ExceptionFuzz.h&quot;
  37 #include &quot;ExecutableBaseInlines.h&quot;
  38 #include &quot;FrameTracers.h&quot;
  39 #include &quot;FunctionCodeBlock.h&quot;
  40 #include &quot;FunctionWhitelist.h&quot;
  41 #include &quot;GetterSetter.h&quot;
  42 #include &quot;HostCallReturnValue.h&quot;
  43 #include &quot;InterpreterInlines.h&quot;
  44 #include &quot;IteratorOperations.h&quot;
  45 #include &quot;JIT.h&quot;
  46 #include &quot;JITExceptions.h&quot;
  47 #include &quot;JITWorklist.h&quot;
  48 #include &quot;JSAsyncFunction.h&quot;
  49 #include &quot;JSAsyncGeneratorFunction.h&quot;
  50 #include &quot;JSCInlines.h&quot;
  51 #include &quot;JSCJSValue.h&quot;
  52 #include &quot;JSGeneratorFunction.h&quot;
  53 #include &quot;JSGlobalObjectFunctions.h&quot;
  54 #include &quot;JSLexicalEnvironment.h&quot;
  55 #include &quot;JSString.h&quot;
  56 #include &quot;JSWithScope.h&quot;
  57 #include &quot;LLIntCommon.h&quot;
  58 #include &quot;LLIntData.h&quot;
  59 #include &quot;LLIntExceptions.h&quot;
  60 #include &quot;LLIntPrototypeLoadAdaptiveStructureWatchpoint.h&quot;
  61 #include &quot;LowLevelInterpreter.h&quot;
  62 #include &quot;ModuleProgramCodeBlock.h&quot;
  63 #include &quot;ObjectConstructor.h&quot;
  64 #include &quot;ObjectPropertyConditionSet.h&quot;
  65 #include &quot;OpcodeInlines.h&quot;
  66 #include &quot;ProgramCodeBlock.h&quot;
<span class="line-modified">  67 #include &quot;ProtoCallFrame.h&quot;</span>
  68 #include &quot;RegExpObject.h&quot;
  69 #include &quot;ShadowChicken.h&quot;
  70 #include &quot;StructureRareDataInlines.h&quot;
  71 #include &quot;SuperSampler.h&quot;
  72 #include &quot;VMInlines.h&quot;
  73 #include &lt;wtf/NeverDestroyed.h&gt;
  74 #include &lt;wtf/StringPrintStream.h&gt;
  75 
  76 namespace JSC { namespace LLInt {
  77 
  78 #define LLINT_BEGIN_NO_SET_PC() \
<span class="line-modified">  79     VM&amp; vm = exec-&gt;vm();      \</span>
<span class="line-modified">  80     NativeCallFrameTracer tracer(vm, exec); \</span>


  81     auto throwScope = DECLARE_THROW_SCOPE(vm)
  82 
  83 #ifndef NDEBUG
  84 #define LLINT_SET_PC_FOR_STUBS() do { \
<span class="line-modified">  85         exec-&gt;codeBlock()-&gt;bytecodeOffset(pc); \</span>
<span class="line-modified">  86         exec-&gt;setCurrentVPC(pc); \</span>
  87     } while (false)
  88 #else
  89 #define LLINT_SET_PC_FOR_STUBS() do { \
<span class="line-modified">  90         exec-&gt;setCurrentVPC(pc); \</span>
  91     } while (false)
  92 #endif
  93 
  94 #define LLINT_BEGIN()                           \
  95     LLINT_BEGIN_NO_SET_PC();                    \
  96     LLINT_SET_PC_FOR_STUBS()
  97 
<span class="line-modified">  98 inline JSValue getNonConstantOperand(ExecState* exec, const VirtualRegister&amp; operand) { return exec-&gt;uncheckedR(operand.offset()).jsValue(); }</span>
<span class="line-modified">  99 inline JSValue getOperand(ExecState* exec, const VirtualRegister&amp; operand) { return exec-&gt;r(operand.offset()).jsValue(); }</span>
 100 
 101 #define LLINT_RETURN_TWO(first, second) do {       \
 102         return encodeResult(first, second);        \
 103     } while (false)
 104 
<span class="line-modified"> 105 #define LLINT_END_IMPL() LLINT_RETURN_TWO(pc, 0)</span>
 106 
 107 #define LLINT_THROW(exceptionToThrow) do {                        \
<span class="line-modified"> 108         throwException(exec, throwScope, exceptionToThrow);       \</span>
<span class="line-modified"> 109         pc = returnToThrow(exec);                                 \</span>
 110         LLINT_END_IMPL();                                         \
 111     } while (false)
 112 
 113 #define LLINT_CHECK_EXCEPTION() do {                    \
<span class="line-modified"> 114         doExceptionFuzzingIfEnabled(exec, throwScope, &quot;LLIntSlowPaths&quot;, pc);    \</span>
 115         if (UNLIKELY(throwScope.exception())) {         \
<span class="line-modified"> 116             pc = returnToThrow(exec);                   \</span>
 117             LLINT_END_IMPL();                           \
 118         }                                               \
 119     } while (false)
 120 
 121 #define LLINT_END() do {                        \
 122         LLINT_CHECK_EXCEPTION();                \
 123         LLINT_END_IMPL();                       \
 124     } while (false)
 125 
 126 #define JUMP_OFFSET(targetOffset) \
<span class="line-modified"> 127     ((targetOffset) ? (targetOffset) : exec-&gt;codeBlock()-&gt;outOfLineJumpOffset(pc))</span>
 128 
 129 #define JUMP_TO(target) do { \
 130         pc = reinterpret_cast&lt;const Instruction*&gt;(reinterpret_cast&lt;const uint8_t*&gt;(pc) + (target)); \
 131     } while (false)
 132 
 133 #define LLINT_BRANCH(condition) do {                  \
 134         bool __b_condition = (condition);                         \
 135         LLINT_CHECK_EXCEPTION();                                  \
 136         if (__b_condition)                                        \
 137             JUMP_TO(JUMP_OFFSET(bytecode.m_targetLabel));         \
 138         else                                                      \
 139             JUMP_TO(pc-&gt;size()); \
 140         LLINT_END_IMPL();                                         \
 141     } while (false)
 142 
 143 #define LLINT_RETURN(value) do {                \
 144         JSValue __r_returnValue = (value);      \
 145         LLINT_CHECK_EXCEPTION();                \
<span class="line-modified"> 146         exec-&gt;uncheckedR(bytecode.m_dst) = __r_returnValue;          \</span>
 147         LLINT_END_IMPL();                       \
 148     } while (false)
 149 
 150 #define LLINT_RETURN_PROFILED(value) do {               \
 151         JSValue __rp_returnValue = (value);                     \
 152         LLINT_CHECK_EXCEPTION();                                \
<span class="line-modified"> 153         exec-&gt;uncheckedR(bytecode.m_dst) = __rp_returnValue;                         \</span>
 154         LLINT_PROFILE_VALUE(__rp_returnValue);          \
 155         LLINT_END_IMPL();                                       \
 156     } while (false)
 157 
 158 #define LLINT_PROFILE_VALUE(value) do { \
<span class="line-modified"> 159         bytecode.metadata(exec).m_profile.m_buckets[0] = JSValue::encode(value); \</span>
 160     } while (false)
 161 
<span class="line-modified"> 162 #define LLINT_CALL_END_IMPL(exec, callTarget, callTargetTag) \</span>
<span class="line-modified"> 163     LLINT_RETURN_TWO(retagCodePtr((callTarget), callTargetTag, SlowPathPtrTag), (exec))</span>
 164 
<span class="line-modified"> 165 #define LLINT_CALL_THROW(exec, exceptionToThrow) do {                   \</span>
<span class="line-modified"> 166         ExecState* __ct_exec = (exec);                                  \</span>
<span class="line-modified"> 167         throwException(__ct_exec, throwScope, exceptionToThrow);        \</span>
<span class="line-modified"> 168         LLINT_CALL_END_IMPL(0, callToThrow(__ct_exec), ExceptionHandlerPtrTag);                 \</span>
 169     } while (false)
 170 
<span class="line-modified"> 171 #define LLINT_CALL_CHECK_EXCEPTION(exec, execCallee) do {               \</span>
<span class="line-modified"> 172         ExecState* __cce_exec = (exec);                                 \</span>
<span class="line-modified"> 173         ExecState* __cce_execCallee = (execCallee);                     \</span>
<span class="line-removed"> 174         doExceptionFuzzingIfEnabled(__cce_exec, throwScope, &quot;LLIntSlowPaths/call&quot;, nullptr); \</span>
 175         if (UNLIKELY(throwScope.exception()))                           \
<span class="line-modified"> 176             LLINT_CALL_END_IMPL(0, callToThrow(__cce_execCallee), ExceptionHandlerPtrTag); \</span>
 177     } while (false)
 178 
<span class="line-modified"> 179 #define LLINT_CALL_RETURN(exec, execCallee, callTarget, callTargetTag) do { \</span>
<span class="line-modified"> 180         ExecState* __cr_exec = (exec);                                  \</span>
<span class="line-modified"> 181         ExecState* __cr_execCallee = (execCallee);                      \</span>
<span class="line-modified"> 182         void* __cr_callTarget = (callTarget);                           \</span>
<span class="line-modified"> 183         LLINT_CALL_CHECK_EXCEPTION(__cr_exec, __cr_execCallee);         \</span>
<span class="line-modified"> 184         LLINT_CALL_END_IMPL(__cr_execCallee, __cr_callTarget, callTargetTag); \</span>
 185     } while (false)
 186 
<span class="line-modified"> 187 #define LLINT_RETURN_CALLEE_FRAME(execCallee) do {                      \</span>
<span class="line-modified"> 188         ExecState* __rcf_exec = (execCallee);                           \</span>
<span class="line-modified"> 189         LLINT_RETURN_TWO(pc, __rcf_exec);                               \</span>
 190     } while (false)
 191 
 192 #if LLINT_TRACING
 193 
 194 template&lt;typename... Types&gt;
 195 void slowPathLog(const Types&amp;... values)
 196 {
 197     dataLogIf(Options::traceLLIntSlowPath(), values...);
 198 }
 199 
 200 template&lt;typename... Types&gt;
 201 void slowPathLn(const Types&amp;... values)
 202 {
 203     dataLogLnIf(Options::traceLLIntSlowPath(), values...);
 204 }
 205 
 206 template&lt;typename... Types&gt;
 207 void slowPathLogF(const char* format, const Types&amp;... values)
 208 {
 209     ALLOW_NONLITERAL_FORMAT_BEGIN
 210     IGNORE_WARNINGS_BEGIN(&quot;format-security&quot;)
 211     if (Options::traceLLIntSlowPath())
 212         dataLogF(format, values...);
 213     IGNORE_WARNINGS_END
 214     ALLOW_NONLITERAL_FORMAT_END
 215 }
 216 
 217 #else // not LLINT_TRACING
 218 
 219 template&lt;typename... Types&gt; void slowPathLog(const Types&amp;...) { }
 220 template&lt;typename... Types&gt; void slowPathLogLn(const Types&amp;...) { }
 221 template&lt;typename... Types&gt; void slowPathLogF(const char*, const Types&amp;...) { }
 222 
 223 #endif // LLINT_TRACING
 224 
<span class="line-modified"> 225 extern &quot;C&quot; SlowPathReturnType llint_trace_operand(ExecState* exec, const Instruction* pc, int fromWhere, int operand)</span>
 226 {
 227     if (!Options::traceLLIntExecution())
 228         LLINT_END_IMPL();
 229 
 230     LLINT_BEGIN();
 231     dataLogF(
 232         &quot;&lt;%p&gt; %p / %p: executing bc#%zu, op#%u: Trace(%d): %d\n&quot;,
 233         &amp;Thread::current(),
<span class="line-modified"> 234         exec-&gt;codeBlock(),</span>
<span class="line-modified"> 235         exec,</span>
<span class="line-modified"> 236         static_cast&lt;intptr_t&gt;(exec-&gt;codeBlock()-&gt;bytecodeOffset(pc)),</span>
 237         pc-&gt;opcodeID(),
 238         fromWhere,
 239         operand);
 240     LLINT_END();
 241 }
 242 
<span class="line-modified"> 243 extern &quot;C&quot; SlowPathReturnType llint_trace_value(ExecState* exec, const Instruction* pc, int fromWhere, VirtualRegister operand)</span>
 244 {
 245     if (!Options::traceLLIntExecution())
 246         LLINT_END_IMPL();
 247 
<span class="line-modified"> 248     JSValue value = getOperand(exec, operand);</span>
 249     union {
 250         struct {
 251             uint32_t tag;
 252             uint32_t payload;
 253         } bits;
 254         EncodedJSValue asValue;
 255     } u;
 256     u.asValue = JSValue::encode(value);
 257     dataLogF(
 258         &quot;&lt;%p&gt; %p / %p: executing bc#%zu, op#%u: Trace(%d): %d: %08x:%08x: %s\n&quot;,
 259         &amp;Thread::current(),
<span class="line-modified"> 260         exec-&gt;codeBlock(),</span>
<span class="line-modified"> 261         exec,</span>
<span class="line-modified"> 262         static_cast&lt;intptr_t&gt;(exec-&gt;codeBlock()-&gt;bytecodeOffset(pc)),</span>
 263         pc-&gt;opcodeID(),
 264         fromWhere,
 265         operand.offset(),
 266         u.bits.tag,
 267         u.bits.payload,
 268         toCString(value).data());
 269     LLINT_END_IMPL();
 270 }
 271 
 272 LLINT_SLOW_PATH_DECL(trace_prologue)
 273 {
 274     if (!Options::traceLLIntExecution())
 275         LLINT_END_IMPL();
 276 
<span class="line-modified"> 277     dataLogF(&quot;&lt;%p&gt; %p / %p: in prologue of &quot;, &amp;Thread::current(), exec-&gt;codeBlock(), exec);</span>
<span class="line-modified"> 278     dataLog(exec-&gt;codeBlock(), &quot;\n&quot;);</span>

 279     LLINT_END_IMPL();
 280 }
 281 
<span class="line-modified"> 282 static void traceFunctionPrologue(ExecState* exec, const char* comment, CodeSpecializationKind kind)</span>
 283 {
 284     if (!Options::traceLLIntExecution())
 285         return;
 286 
<span class="line-modified"> 287     JSFunction* callee = jsCast&lt;JSFunction*&gt;(exec-&gt;jsCallee());</span>
 288     FunctionExecutable* executable = callee-&gt;jsExecutable();
 289     CodeBlock* codeBlock = executable-&gt;codeBlockFor(kind);
<span class="line-modified"> 290     dataLogF(&quot;&lt;%p&gt; %p / %p: in %s of &quot;, &amp;Thread::current(), codeBlock, exec, comment);</span>
 291     dataLog(codeBlock);
 292     dataLogF(&quot; function %p, executable %p; numVars = %u, numParameters = %u, numCalleeLocals = %u, caller = %p.\n&quot;,
<span class="line-modified"> 293         callee, executable, codeBlock-&gt;numVars(), codeBlock-&gt;numParameters(), codeBlock-&gt;numCalleeLocals(), exec-&gt;callerFrame());</span>
 294 }
 295 
 296 LLINT_SLOW_PATH_DECL(trace_prologue_function_for_call)
 297 {
<span class="line-modified"> 298     traceFunctionPrologue(exec, &quot;call prologue&quot;, CodeForCall);</span>
 299     LLINT_END_IMPL();
 300 }
 301 
 302 LLINT_SLOW_PATH_DECL(trace_prologue_function_for_construct)
 303 {
<span class="line-modified"> 304     traceFunctionPrologue(exec, &quot;construct prologue&quot;, CodeForConstruct);</span>
 305     LLINT_END_IMPL();
 306 }
 307 
 308 LLINT_SLOW_PATH_DECL(trace_arityCheck_for_call)
 309 {
<span class="line-modified"> 310     traceFunctionPrologue(exec, &quot;call arity check&quot;, CodeForCall);</span>
 311     LLINT_END_IMPL();
 312 }
 313 
 314 LLINT_SLOW_PATH_DECL(trace_arityCheck_for_construct)
 315 {
<span class="line-modified"> 316     traceFunctionPrologue(exec, &quot;construct arity check&quot;, CodeForConstruct);</span>
 317     LLINT_END_IMPL();
 318 }
 319 
 320 LLINT_SLOW_PATH_DECL(trace)
 321 {
 322     if (!Options::traceLLIntExecution())
 323         LLINT_END_IMPL();
 324 

 325     OpcodeID opcodeID = pc-&gt;opcodeID();
 326     dataLogF(&quot;&lt;%p&gt; %p / %p: executing bc#%zu, %s, pc = %p\n&quot;,
 327             &amp;Thread::current(),
<span class="line-modified"> 328             exec-&gt;codeBlock(),</span>
<span class="line-modified"> 329             exec,</span>
<span class="line-modified"> 330             static_cast&lt;intptr_t&gt;(exec-&gt;codeBlock()-&gt;bytecodeOffset(pc)),</span>
 331             pc-&gt;name(),
 332             pc);
 333     if (opcodeID == op_enter) {
<span class="line-modified"> 334         dataLogF(&quot;Frame will eventually return to %p\n&quot;, exec-&gt;returnPC().value());</span>
<span class="line-modified"> 335         *removeCodePtrTag&lt;volatile char*&gt;(exec-&gt;returnPC().value());</span>
 336     }
 337     if (opcodeID == op_ret) {
<span class="line-modified"> 338         dataLogF(&quot;Will be returning to %p\n&quot;, exec-&gt;returnPC().value());</span>
<span class="line-modified"> 339         dataLogF(&quot;The new cfr will be %p\n&quot;, exec-&gt;callerFrame());</span>
 340     }
 341     LLINT_END_IMPL();
 342 }
 343 
 344 enum EntryKind { Prologue, ArityCheck };
 345 
 346 #if ENABLE(JIT)
 347 static FunctionWhitelist&amp; ensureGlobalJITWhitelist()
 348 {
 349     static LazyNeverDestroyed&lt;FunctionWhitelist&gt; baselineWhitelist;
 350     static std::once_flag initializeWhitelistFlag;
 351     std::call_once(initializeWhitelistFlag, [] {
 352         const char* functionWhitelistFile = Options::jitWhitelist();
 353         baselineWhitelist.construct(functionWhitelistFile);
 354     });
 355     return baselineWhitelist;
 356 }
 357 
 358 inline bool shouldJIT(CodeBlock* codeBlock)
 359 {
 360     if (!Options::bytecodeRangeToJITCompile().isInRange(codeBlock-&gt;instructionsSize())
 361         || !ensureGlobalJITWhitelist().contains(codeBlock))
 362         return false;
 363 
 364     return VM::canUseJIT() &amp;&amp; Options::useBaselineJIT();
 365 }
 366 
 367 // Returns true if we should try to OSR.
<span class="line-modified"> 368 inline bool jitCompileAndSetHeuristics(CodeBlock* codeBlock, ExecState* exec, unsigned loopOSREntryBytecodeOffset = 0)</span>
 369 {
<span class="line-removed"> 370     VM&amp; vm = exec-&gt;vm();</span>
 371     DeferGCForAWhile deferGC(vm.heap); // My callers don&#39;t set top callframe, so we don&#39;t want to GC here at all.
 372     ASSERT(VM::canUseJIT());
 373 
 374     codeBlock-&gt;updateAllValueProfilePredictions();
 375 
 376     if (!codeBlock-&gt;checkIfJITThresholdReached()) {
 377         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayJITCompile&quot;, (&quot;threshold not reached, counter = &quot;, codeBlock-&gt;llintExecuteCounter()));
<span class="line-modified"> 378         if (Options::verboseOSR())</span>
<span class="line-removed"> 379             dataLogF(&quot;    JIT threshold should be lifted.\n&quot;);</span>
 380         return false;
 381     }
 382 
 383     JITWorklist::ensureGlobalWorklist().poll(vm);
 384 
 385     switch (codeBlock-&gt;jitType()) {
 386     case JITType::BaselineJIT: {
<span class="line-modified"> 387         if (Options::verboseOSR())</span>
<span class="line-removed"> 388             dataLogF(&quot;    Code was already compiled.\n&quot;);</span>
 389         codeBlock-&gt;jitSoon();
 390         return true;
 391     }
 392     case JITType::InterpreterThunk: {
<span class="line-modified"> 393         JITWorklist::ensureGlobalWorklist().compileLater(codeBlock, loopOSREntryBytecodeOffset);</span>
 394         return codeBlock-&gt;jitType() == JITType::BaselineJIT;
 395     }
 396     default:
 397         dataLog(&quot;Unexpected code block in LLInt: &quot;, *codeBlock, &quot;\n&quot;);
 398         RELEASE_ASSERT_NOT_REACHED();
 399         return false;
 400     }
 401 }
 402 
<span class="line-modified"> 403 static SlowPathReturnType entryOSR(ExecState* exec, const Instruction*, CodeBlock* codeBlock, const char *name, EntryKind kind)</span>
 404 {
<span class="line-modified"> 405     if (Options::verboseOSR()) {</span>
<span class="line-modified"> 406         dataLog(</span>
<span class="line-modified"> 407             *codeBlock, &quot;: Entered &quot;, name, &quot; with executeCounter = &quot;,</span>
<span class="line-removed"> 408             codeBlock-&gt;llintExecuteCounter(), &quot;\n&quot;);</span>
<span class="line-removed"> 409     }</span>
 410 
 411     if (!shouldJIT(codeBlock)) {
 412         codeBlock-&gt;dontJITAnytimeSoon();
<span class="line-modified"> 413         LLINT_RETURN_TWO(0, 0);</span>
 414     }
<span class="line-modified"> 415     if (!jitCompileAndSetHeuristics(codeBlock, exec))</span>
<span class="line-modified"> 416         LLINT_RETURN_TWO(0, 0);</span>

 417 
 418     CODEBLOCK_LOG_EVENT(codeBlock, &quot;OSR entry&quot;, (&quot;in prologue&quot;));
 419 
 420     if (kind == Prologue)
<span class="line-modified"> 421         LLINT_RETURN_TWO(codeBlock-&gt;jitCode()-&gt;executableAddress(), 0);</span>
 422     ASSERT(kind == ArityCheck);
<span class="line-modified"> 423     LLINT_RETURN_TWO(codeBlock-&gt;jitCode()-&gt;addressForCall(MustCheckArity).executableAddress(), 0);</span>
 424 }
 425 #else // ENABLE(JIT)
<span class="line-modified"> 426 static SlowPathReturnType entryOSR(ExecState* exec, const Instruction*, CodeBlock* codeBlock, const char*, EntryKind)</span>
 427 {
 428     codeBlock-&gt;dontJITAnytimeSoon();
<span class="line-modified"> 429     LLINT_RETURN_TWO(0, exec);</span>
 430 }
 431 #endif // ENABLE(JIT)
 432 
 433 LLINT_SLOW_PATH_DECL(entry_osr)
 434 {
<span class="line-modified"> 435     return entryOSR(exec, pc, exec-&gt;codeBlock(), &quot;entry_osr&quot;, Prologue);</span>

 436 }
 437 
 438 LLINT_SLOW_PATH_DECL(entry_osr_function_for_call)
 439 {
<span class="line-modified"> 440     return entryOSR(exec, pc, jsCast&lt;JSFunction*&gt;(exec-&gt;jsCallee())-&gt;jsExecutable()-&gt;codeBlockForCall(), &quot;entry_osr_function_for_call&quot;, Prologue);</span>

 441 }
 442 
 443 LLINT_SLOW_PATH_DECL(entry_osr_function_for_construct)
 444 {
<span class="line-modified"> 445     return entryOSR(exec, pc, jsCast&lt;JSFunction*&gt;(exec-&gt;jsCallee())-&gt;jsExecutable()-&gt;codeBlockForConstruct(), &quot;entry_osr_function_for_construct&quot;, Prologue);</span>

 446 }
 447 
 448 LLINT_SLOW_PATH_DECL(entry_osr_function_for_call_arityCheck)
 449 {
<span class="line-modified"> 450     return entryOSR(exec, pc, jsCast&lt;JSFunction*&gt;(exec-&gt;jsCallee())-&gt;jsExecutable()-&gt;codeBlockForCall(), &quot;entry_osr_function_for_call_arityCheck&quot;, ArityCheck);</span>

 451 }
 452 
 453 LLINT_SLOW_PATH_DECL(entry_osr_function_for_construct_arityCheck)
 454 {
<span class="line-modified"> 455     return entryOSR(exec, pc, jsCast&lt;JSFunction*&gt;(exec-&gt;jsCallee())-&gt;jsExecutable()-&gt;codeBlockForConstruct(), &quot;entry_osr_function_for_construct_arityCheck&quot;, ArityCheck);</span>

 456 }
 457 
 458 LLINT_SLOW_PATH_DECL(loop_osr)
 459 {
 460     LLINT_BEGIN_NO_SET_PC();
 461     UNUSED_PARAM(throwScope);
<span class="line-modified"> 462     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
 463 
 464 #if ENABLE(JIT)
<span class="line-modified"> 465     if (Options::verboseOSR()) {</span>
<span class="line-removed"> 466         dataLog(</span>
 467             *codeBlock, &quot;: Entered loop_osr with executeCounter = &quot;,
<span class="line-modified"> 468             codeBlock-&gt;llintExecuteCounter(), &quot;\n&quot;);</span>
<span class="line-removed"> 469     }</span>
 470 
<span class="line-modified"> 471     unsigned loopOSREntryBytecodeOffset = codeBlock-&gt;bytecodeOffset(pc);</span>
 472 
 473     if (!shouldJIT(codeBlock)) {
 474         codeBlock-&gt;dontJITAnytimeSoon();
 475         LLINT_RETURN_TWO(0, 0);
 476     }
 477 
<span class="line-modified"> 478     if (!jitCompileAndSetHeuristics(codeBlock, exec, loopOSREntryBytecodeOffset))</span>
 479         LLINT_RETURN_TWO(0, 0);
 480 
<span class="line-modified"> 481     CODEBLOCK_LOG_EVENT(codeBlock, &quot;osrEntry&quot;, (&quot;at bc#&quot;, loopOSREntryBytecodeOffset));</span>
 482 
 483     ASSERT(codeBlock-&gt;jitType() == JITType::BaselineJIT);
 484 
 485     const JITCodeMap&amp; codeMap = codeBlock-&gt;jitCodeMap();
<span class="line-modified"> 486     CodeLocationLabel&lt;JSEntryPtrTag&gt; codeLocation = codeMap.find(loopOSREntryBytecodeOffset);</span>
 487     ASSERT(codeLocation);
 488 
 489     void* jumpTarget = codeLocation.executableAddress();
 490     ASSERT(jumpTarget);
 491 
<span class="line-modified"> 492     LLINT_RETURN_TWO(jumpTarget, exec-&gt;topOfFrame());</span>
 493 #else // ENABLE(JIT)
 494     UNUSED_PARAM(pc);
 495     codeBlock-&gt;dontJITAnytimeSoon();
 496     LLINT_RETURN_TWO(0, 0);
 497 #endif // ENABLE(JIT)
 498 }
 499 
 500 LLINT_SLOW_PATH_DECL(replace)
 501 {
 502     LLINT_BEGIN_NO_SET_PC();
 503     UNUSED_PARAM(throwScope);
<span class="line-modified"> 504     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
 505 
 506 #if ENABLE(JIT)
<span class="line-modified"> 507     if (Options::verboseOSR()) {</span>
<span class="line-modified"> 508         dataLog(</span>
<span class="line-modified"> 509             *codeBlock, &quot;: Entered replace with executeCounter = &quot;,</span>
<span class="line-removed"> 510             codeBlock-&gt;llintExecuteCounter(), &quot;\n&quot;);</span>
<span class="line-removed"> 511     }</span>
 512 
 513     if (shouldJIT(codeBlock))
<span class="line-modified"> 514         jitCompileAndSetHeuristics(codeBlock, exec);</span>
 515     else
 516         codeBlock-&gt;dontJITAnytimeSoon();
 517     LLINT_END_IMPL();
 518 #else // ENABLE(JIT)
 519     codeBlock-&gt;dontJITAnytimeSoon();
 520     LLINT_END_IMPL();
 521 #endif // ENABLE(JIT)
 522 }
 523 
 524 LLINT_SLOW_PATH_DECL(stack_check)
 525 {
<span class="line-modified"> 526     VM&amp; vm = exec-&gt;vm();</span>


 527     auto throwScope = DECLARE_THROW_SCOPE(vm);
 528 
<span class="line-modified"> 529     // It&#39;s ok to create the NativeCallFrameTracer here before we</span>
 530     // convertToStackOverflowFrame() because this function is always called
 531     // after the frame has been propulated with a proper CodeBlock and callee.
<span class="line-modified"> 532     NativeCallFrameTracer tracer(vm, exec);</span>
 533 
 534     LLINT_SET_PC_FOR_STUBS();
 535 
<span class="line-modified"> 536     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed"> 537     slowPathLogF(&quot;Checking stack height with exec = %p.\n&quot;, exec);</span>
 538     slowPathLog(&quot;CodeBlock = &quot;, codeBlock, &quot;\n&quot;);
 539     if (codeBlock) {
 540         slowPathLogF(&quot;Num callee registers = %u.\n&quot;, codeBlock-&gt;numCalleeLocals());
 541         slowPathLogF(&quot;Num vars = %u.\n&quot;, codeBlock-&gt;numVars());
 542     }
 543     slowPathLogF(&quot;Current OS stack end is at %p.\n&quot;, vm.softStackLimit());
 544 #if ENABLE(C_LOOP)
 545     slowPathLogF(&quot;Current C Loop stack end is at %p.\n&quot;, vm.cloopStackLimit());
 546 #endif
 547 
 548     // If the stack check succeeds and we don&#39;t need to throw the error, then
 549     // we&#39;ll return 0 instead. The prologue will check for a non-zero value
 550     // when determining whether to set the callFrame or not.
 551 
 552     // For JIT enabled builds which uses the C stack, the stack is not growable.
 553     // Hence, if we get here, then we know a stack overflow is imminent. So, just
 554     // throw the StackOverflowError unconditionally.
 555 #if ENABLE(C_LOOP)
<span class="line-modified"> 556     Register* topOfFrame = exec-&gt;topOfFrame();</span>
<span class="line-modified"> 557     if (LIKELY(topOfFrame &lt; reinterpret_cast&lt;Register*&gt;(exec))) {</span>
 558         ASSERT(!vm.interpreter-&gt;cloopStack().containsAddress(topOfFrame));
 559         if (LIKELY(vm.ensureStackCapacityFor(topOfFrame)))
 560             LLINT_RETURN_TWO(pc, 0);
 561     }
 562 #endif
 563 
<span class="line-modified"> 564     exec-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
 565     ErrorHandlingScope errorScope(vm);
<span class="line-modified"> 566     throwStackOverflowError(exec, throwScope);</span>
<span class="line-modified"> 567     pc = returnToThrow(exec);</span>
<span class="line-modified"> 568     LLINT_RETURN_TWO(pc, exec);</span>
 569 }
 570 
 571 LLINT_SLOW_PATH_DECL(slow_path_new_object)
 572 {
 573     LLINT_BEGIN();
 574     auto bytecode = pc-&gt;as&lt;OpNewObject&gt;();
<span class="line-modified"> 575     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-modified"> 576     LLINT_RETURN(constructEmptyObject(exec, metadata.m_objectAllocationProfile.structure()));</span>
 577 }
 578 
 579 LLINT_SLOW_PATH_DECL(slow_path_new_array)
 580 {
 581     LLINT_BEGIN();
 582     auto bytecode = pc-&gt;as&lt;OpNewArray&gt;();
<span class="line-modified"> 583     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-modified"> 584     LLINT_RETURN(constructArrayNegativeIndexed(exec, &amp;metadata.m_arrayAllocationProfile, bitwise_cast&lt;JSValue*&gt;(&amp;exec-&gt;uncheckedR(bytecode.m_argv)), bytecode.m_argc));</span>
 585 }
 586 
 587 LLINT_SLOW_PATH_DECL(slow_path_new_array_with_size)
 588 {
 589     LLINT_BEGIN();
 590     auto bytecode = pc-&gt;as&lt;OpNewArrayWithSize&gt;();
<span class="line-modified"> 591     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-modified"> 592     LLINT_RETURN(constructArrayWithSizeQuirk(exec, &amp;metadata.m_arrayAllocationProfile, exec-&gt;lexicalGlobalObject(), getOperand(exec, bytecode.m_length)));</span>
 593 }
 594 
 595 LLINT_SLOW_PATH_DECL(slow_path_new_regexp)
 596 {
 597     LLINT_BEGIN();
 598     auto bytecode = pc-&gt;as&lt;OpNewRegexp&gt;();
<span class="line-modified"> 599     RegExp* regExp = jsCast&lt;RegExp*&gt;(getOperand(exec, bytecode.m_regexp));</span>
 600     ASSERT(regExp-&gt;isValid());
<span class="line-modified"> 601     LLINT_RETURN(RegExpObject::create(vm, exec-&gt;lexicalGlobalObject()-&gt;regExpStructure(), regExp));</span>
 602 }
 603 
 604 LLINT_SLOW_PATH_DECL(slow_path_instanceof)
 605 {
 606     LLINT_BEGIN();
 607     auto bytecode = pc-&gt;as&lt;OpInstanceof&gt;();
<span class="line-modified"> 608     JSValue value = getOperand(exec, bytecode.m_value);</span>
<span class="line-modified"> 609     JSValue proto = getOperand(exec, bytecode.m_prototype);</span>
<span class="line-modified"> 610     LLINT_RETURN(jsBoolean(JSObject::defaultHasInstance(exec, value, proto)));</span>
 611 }
 612 
 613 LLINT_SLOW_PATH_DECL(slow_path_instanceof_custom)
 614 {
 615     LLINT_BEGIN();
 616 
 617     auto bytecode = pc-&gt;as&lt;OpInstanceofCustom&gt;();
<span class="line-modified"> 618     JSValue value = getOperand(exec, bytecode.m_value);</span>
<span class="line-modified"> 619     JSValue constructor = getOperand(exec, bytecode.m_constructor);</span>
<span class="line-modified"> 620     JSValue hasInstanceValue = getOperand(exec, bytecode.m_hasInstanceValue);</span>
 621 
 622     ASSERT(constructor.isObject());
<span class="line-modified"> 623     ASSERT(hasInstanceValue != exec-&gt;lexicalGlobalObject()-&gt;functionProtoHasInstanceSymbolFunction() || !constructor.getObject()-&gt;structure(vm)-&gt;typeInfo().implementsDefaultHasInstance());</span>
 624 
<span class="line-modified"> 625     JSValue result = jsBoolean(constructor.getObject()-&gt;hasInstance(exec, value, hasInstanceValue));</span>
 626     LLINT_RETURN(result);
 627 }
 628 
 629 LLINT_SLOW_PATH_DECL(slow_path_try_get_by_id)
 630 {
 631     LLINT_BEGIN();
 632     auto bytecode = pc-&gt;as&lt;OpTryGetById&gt;();
<span class="line-removed"> 633     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
 634     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
<span class="line-modified"> 635     JSValue baseValue = getOperand(exec, bytecode.m_base);</span>
 636     PropertySlot slot(baseValue, PropertySlot::PropertySlot::InternalMethodType::VMInquiry);
 637 
<span class="line-modified"> 638     baseValue.getPropertySlot(exec, ident, slot);</span>
 639     JSValue result = slot.getPureResult();
 640 
 641     LLINT_RETURN_PROFILED(result);
 642 }
 643 
 644 LLINT_SLOW_PATH_DECL(slow_path_get_by_id_direct)
 645 {
 646     LLINT_BEGIN();
 647     auto bytecode = pc-&gt;as&lt;OpGetByIdDirect&gt;();
<span class="line-removed"> 648     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
 649     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
<span class="line-modified"> 650     JSValue baseValue = getOperand(exec, bytecode.m_base);</span>
 651     PropertySlot slot(baseValue, PropertySlot::PropertySlot::InternalMethodType::GetOwnProperty);
 652 
<span class="line-modified"> 653     bool found = baseValue.getOwnPropertySlot(exec, ident, slot);</span>
 654     LLINT_CHECK_EXCEPTION();
<span class="line-modified"> 655     JSValue result = found ? slot.getValue(exec, ident) : jsUndefined();</span>
 656     LLINT_CHECK_EXCEPTION();
 657 
<span class="line-modified"> 658     if (!LLINT_ALWAYS_ACCESS_SLOW &amp;&amp; slot.isCacheable()) {</span>
<span class="line-modified"> 659         auto&amp; metadata = bytecode.metadata(exec);</span>
 660         {
 661             StructureID oldStructureID = metadata.m_structureID;
 662             if (oldStructureID) {
 663                 Structure* a = vm.heap.structureIDTable().get(oldStructureID);
 664                 Structure* b = baseValue.asCell()-&gt;structure(vm);
 665 
 666                 if (Structure::shouldConvertToPolyProto(a, b)) {
 667                     ASSERT(a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint().get() == b-&gt;rareData()-&gt;sharedPolyProtoWatchpoint().get());
 668                     a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint()-&gt;invalidate(vm, StringFireDetail(&quot;Detected poly proto opportunity.&quot;));
 669                 }
 670             }
 671         }
 672 
 673         JSCell* baseCell = baseValue.asCell();
 674         Structure* structure = baseCell-&gt;structure(vm);
 675         if (slot.isValue()) {
 676             // Start out by clearing out the old cache.
 677             metadata.m_structureID = 0;
 678             metadata.m_offset = 0;
 679 
 680             if (structure-&gt;propertyAccessesAreCacheable() &amp;&amp; !structure-&gt;needImpurePropertyWatchpoint()) {
 681                 {
 682                     ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 683                     metadata.m_structureID = structure-&gt;id();
 684                     metadata.m_offset = slot.cachedOffset();
 685                 }
 686                 vm.heap.writeBarrier(codeBlock);
 687             }
 688         }
 689     }
 690 
 691     LLINT_RETURN_PROFILED(result);
 692 }
 693 
 694 
<span class="line-modified"> 695 static void setupGetByIdPrototypeCache(ExecState* exec, VM&amp; vm, const Instruction* pc, OpGetById::Metadata&amp; metadata, JSCell* baseCell, PropertySlot&amp; slot, const Identifier&amp; ident)</span>
 696 {
<span class="line-removed"> 697     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
 698     Structure* structure = baseCell-&gt;structure(vm);
 699 
 700     if (structure-&gt;typeInfo().prohibitsPropertyCaching())
 701         return;
 702 
 703     if (structure-&gt;needImpurePropertyWatchpoint())
 704         return;
 705 
 706     if (structure-&gt;isDictionary()) {
 707         if (structure-&gt;hasBeenFlattenedBefore())
 708             return;
 709         structure-&gt;flattenDictionaryStructure(vm, jsCast&lt;JSObject*&gt;(baseCell));
 710     }
 711 


 712     ObjectPropertyConditionSet conditions;
 713     if (slot.isUnset())
<span class="line-modified"> 714         conditions = generateConditionsForPropertyMiss(vm, codeBlock, exec, structure, ident.impl());</span>
 715     else
<span class="line-modified"> 716         conditions = generateConditionsForPrototypePropertyHit(vm, codeBlock, exec, structure, slot.slotBase(), ident.impl());</span>
 717 
 718     if (!conditions.isValid())
 719         return;
 720 
 721     unsigned bytecodeOffset = codeBlock-&gt;bytecodeOffset(pc);
 722     PropertyOffset offset = invalidOffset;
 723     CodeBlock::StructureWatchpointMap&amp; watchpointMap = codeBlock-&gt;llintGetByIdWatchpointMap();
 724     Vector&lt;LLIntPrototypeLoadAdaptiveStructureWatchpoint&gt; watchpoints;
 725     watchpoints.reserveInitialCapacity(conditions.size());
 726     for (ObjectPropertyCondition condition : conditions) {
 727         if (!condition.isWatchable())
 728             return;
 729         if (condition.condition().kind() == PropertyCondition::Presence)
 730             offset = condition.condition().offset();
 731         watchpoints.uncheckedConstructAndAppend(codeBlock, condition, bytecodeOffset);
 732         watchpoints.last().install(vm);
 733     }
 734 
 735     ASSERT((offset == invalidOffset) == slot.isUnset());
 736     auto result = watchpointMap.add(std::make_tuple(structure-&gt;id(), bytecodeOffset), WTFMove(watchpoints));
 737     ASSERT_UNUSED(result, result.isNewEntry);
 738 
 739     {
 740         ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 741         if (slot.isUnset())
 742             metadata.m_modeMetadata.setUnsetMode(structure);
 743         else {
 744             ASSERT(slot.isValue());
 745             metadata.m_modeMetadata.setProtoLoadMode(structure, offset, slot.slotBase());
 746         }
 747     }
 748     vm.heap.writeBarrier(codeBlock);
 749 }
 750 
 751 
 752 LLINT_SLOW_PATH_DECL(slow_path_get_by_id)
 753 {
 754     LLINT_BEGIN();
 755     auto bytecode = pc-&gt;as&lt;OpGetById&gt;();
<span class="line-modified"> 756     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-removed"> 757     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
 758     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
<span class="line-modified"> 759     JSValue baseValue = getOperand(exec, bytecode.m_base);</span>
 760     PropertySlot slot(baseValue, PropertySlot::PropertySlot::InternalMethodType::Get);
 761 
<span class="line-modified"> 762     JSValue result = baseValue.get(exec, ident, slot);</span>
 763     LLINT_CHECK_EXCEPTION();
<span class="line-modified"> 764     exec-&gt;uncheckedR(bytecode.m_dst) = result;</span>
 765 
 766     if (!LLINT_ALWAYS_ACCESS_SLOW
 767         &amp;&amp; baseValue.isCell()
<span class="line-modified"> 768         &amp;&amp; slot.isCacheable()) {</span>

 769         {
 770             StructureID oldStructureID;
 771             switch (metadata.m_modeMetadata.mode) {
 772             case GetByIdMode::Default:
 773                 oldStructureID = metadata.m_modeMetadata.defaultMode.structureID;
 774                 break;
 775             case GetByIdMode::Unset:
 776                 oldStructureID = metadata.m_modeMetadata.unsetMode.structureID;
 777                 break;
 778             case GetByIdMode::ProtoLoad:
 779                 oldStructureID = metadata.m_modeMetadata.protoLoadMode.structureID;
 780                 break;
 781             default:
 782                 oldStructureID = 0;
 783             }
 784             if (oldStructureID) {
 785                 Structure* a = vm.heap.structureIDTable().get(oldStructureID);
 786                 Structure* b = baseValue.asCell()-&gt;structure(vm);
 787 
 788                 if (Structure::shouldConvertToPolyProto(a, b)) {
</pre>
<hr />
<pre>
 790                     a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint()-&gt;invalidate(vm, StringFireDetail(&quot;Detected poly proto opportunity.&quot;));
 791                 }
 792             }
 793         }
 794 
 795         JSCell* baseCell = baseValue.asCell();
 796         Structure* structure = baseCell-&gt;structure(vm);
 797         if (slot.isValue() &amp;&amp; slot.slotBase() == baseValue) {
 798             ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 799             // Start out by clearing out the old cache.
 800             metadata.m_modeMetadata.clearToDefaultModeWithoutCache();
 801 
 802             // Prevent the prototype cache from ever happening.
 803             metadata.m_modeMetadata.hitCountForLLIntCaching = 0;
 804 
 805             if (structure-&gt;propertyAccessesAreCacheable() &amp;&amp; !structure-&gt;needImpurePropertyWatchpoint()) {
 806                 metadata.m_modeMetadata.defaultMode.structureID = structure-&gt;id();
 807                 metadata.m_modeMetadata.defaultMode.cachedOffset = slot.cachedOffset();
 808                 vm.heap.writeBarrier(codeBlock);
 809             }
<span class="line-modified"> 810         } else if (UNLIKELY(metadata.m_modeMetadata.hitCountForLLIntCaching &amp;&amp; (slot.isValue() || slot.isUnset()))) {</span>
 811             ASSERT(slot.slotBase() != baseValue);
 812 
 813             if (!(--metadata.m_modeMetadata.hitCountForLLIntCaching))
<span class="line-modified"> 814                 setupGetByIdPrototypeCache(exec, vm, pc, metadata, baseCell, slot, ident);</span>
 815         }
 816     } else if (!LLINT_ALWAYS_ACCESS_SLOW &amp;&amp; isJSArray(baseValue) &amp;&amp; ident == vm.propertyNames-&gt;length) {
 817         {
 818             ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 819             metadata.m_modeMetadata.setArrayLengthMode();
 820             metadata.m_modeMetadata.arrayLengthMode.arrayProfile.observeStructure(baseValue.asCell()-&gt;structure(vm));
 821         }
 822         vm.heap.writeBarrier(codeBlock);
 823     }
 824 
 825     LLINT_PROFILE_VALUE(result);
 826     LLINT_END();
 827 }
 828 
 829 LLINT_SLOW_PATH_DECL(slow_path_put_by_id)
 830 {
 831     LLINT_BEGIN();
 832     auto bytecode = pc-&gt;as&lt;OpPutById&gt;();
<span class="line-modified"> 833     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-removed"> 834     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
 835     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
 836 
<span class="line-modified"> 837     JSValue baseValue = getOperand(exec, bytecode.m_base);</span>
 838     PutPropertySlot slot(baseValue, codeBlock-&gt;isStrictMode(), codeBlock-&gt;putByIdContext());


 839     if (bytecode.m_flags &amp; PutByIdIsDirect)
<span class="line-modified"> 840         CommonSlowPaths::putDirectWithReify(vm, exec, asObject(baseValue), ident, getOperand(exec, bytecode.m_value), slot);</span>
 841     else
<span class="line-modified"> 842         baseValue.putInline(exec, ident, getOperand(exec, bytecode.m_value), slot);</span>
 843     LLINT_CHECK_EXCEPTION();
 844 
 845     if (!LLINT_ALWAYS_ACCESS_SLOW
 846         &amp;&amp; baseValue.isCell()
<span class="line-modified"> 847         &amp;&amp; slot.isCacheablePut()) {</span>
<span class="line-modified"> 848 </span>
 849         {
 850             StructureID oldStructureID = metadata.m_oldStructureID;
 851             if (oldStructureID) {
 852                 Structure* a = vm.heap.structureIDTable().get(oldStructureID);
 853                 Structure* b = baseValue.asCell()-&gt;structure(vm);
 854                 if (slot.type() == PutPropertySlot::NewProperty)
 855                     b = b-&gt;previousID();
 856 
 857                 if (Structure::shouldConvertToPolyProto(a, b)) {
 858                     a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint()-&gt;invalidate(vm, StringFireDetail(&quot;Detected poly proto opportunity.&quot;));
 859                     b-&gt;rareData()-&gt;sharedPolyProtoWatchpoint()-&gt;invalidate(vm, StringFireDetail(&quot;Detected poly proto opportunity.&quot;));
 860                 }
 861             }
 862         }
 863 
 864         // Start out by clearing out the old cache.
 865         metadata.m_oldStructureID = 0;
 866         metadata.m_offset = 0;
 867         metadata.m_newStructureID = 0;
 868         metadata.m_structureChain.clear();
 869 
 870         JSCell* baseCell = baseValue.asCell();
<span class="line-modified"> 871         Structure* structure = baseCell-&gt;structure(vm);</span>
 872 
<span class="line-modified"> 873         if (!structure-&gt;isUncacheableDictionary() &amp;&amp; !structure-&gt;typeInfo().prohibitsPropertyCaching() &amp;&amp; baseCell == slot.base()) {</span>
 874             if (slot.type() == PutPropertySlot::NewProperty) {
 875                 GCSafeConcurrentJSLocker locker(codeBlock-&gt;m_lock, vm.heap);
<span class="line-modified"> 876                 if (!structure-&gt;isDictionary() &amp;&amp; structure-&gt;previousID()-&gt;outOfLineCapacity() == structure-&gt;outOfLineCapacity()) {</span>
<span class="line-modified"> 877                     ASSERT(structure-&gt;previousID()-&gt;transitionWatchpointSetHasBeenInvalidated());</span>
<span class="line-modified"> 878 </span>
<span class="line-modified"> 879                     bool sawPolyProto = false;</span>
<span class="line-modified"> 880                     auto result = normalizePrototypeChain(exec, baseCell, sawPolyProto);</span>
<span class="line-modified"> 881                     if (result != InvalidPrototypeChain &amp;&amp; !sawPolyProto) {</span>
<span class="line-modified"> 882                         ASSERT(structure-&gt;previousID()-&gt;isObject());</span>
<span class="line-modified"> 883                         metadata.m_oldStructureID = structure-&gt;previousID()-&gt;id();</span>
<span class="line-modified"> 884                         metadata.m_offset = slot.cachedOffset();</span>
<span class="line-modified"> 885                         metadata.m_newStructureID = structure-&gt;id();</span>
<span class="line-modified"> 886                         if (!(bytecode.m_flags &amp; PutByIdIsDirect)) {</span>
<span class="line-modified"> 887                             StructureChain* chain = structure-&gt;prototypeChain(exec, asObject(baseCell));</span>
<span class="line-modified"> 888                             ASSERT(chain);</span>
<span class="line-modified"> 889                             metadata.m_structureChain.set(vm, codeBlock, chain);</span>




 890                         }
<span class="line-removed"> 891                         vm.heap.writeBarrier(codeBlock);</span>
 892                     }
 893                 }
 894             } else {
<span class="line-modified"> 895                 structure-&gt;didCachePropertyReplacement(vm, slot.cachedOffset());</span>







 896                 {
 897                     ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
<span class="line-modified"> 898                     metadata.m_oldStructureID = structure-&gt;id();</span>
 899                     metadata.m_offset = slot.cachedOffset();
 900                 }
 901                 vm.heap.writeBarrier(codeBlock);
 902             }
 903         }
 904     }
 905 
 906     LLINT_END();
 907 }
 908 
 909 LLINT_SLOW_PATH_DECL(slow_path_del_by_id)
 910 {
 911     LLINT_BEGIN();
 912     auto bytecode = pc-&gt;as&lt;OpDelById&gt;();
<span class="line-modified"> 913     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed"> 914     JSObject* baseObject = getOperand(exec, bytecode.m_base).toObject(exec);</span>
 915     LLINT_CHECK_EXCEPTION();
<span class="line-modified"> 916     bool couldDelete = baseObject-&gt;methodTable(vm)-&gt;deleteProperty(baseObject, exec, codeBlock-&gt;identifier(bytecode.m_property));</span>
 917     LLINT_CHECK_EXCEPTION();
 918     if (!couldDelete &amp;&amp; codeBlock-&gt;isStrictMode())
<span class="line-modified"> 919         LLINT_THROW(createTypeError(exec, UnableToDeletePropertyError));</span>
 920     LLINT_RETURN(jsBoolean(couldDelete));
 921 }
 922 
<span class="line-modified"> 923 static ALWAYS_INLINE JSValue getByVal(VM&amp; vm, ExecState* exec, OpGetByVal bytecode)</span>
 924 {
<span class="line-removed"> 925     JSValue baseValue = getOperand(exec, bytecode.m_base);</span>
<span class="line-removed"> 926     JSValue subscript = getOperand(exec, bytecode.m_property);</span>
 927     auto scope = DECLARE_THROW_SCOPE(vm);
 928 
 929     if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
 930         Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
 931         if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified"> 932             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(subscript)-&gt;toExistingAtomString(exec);</span>
 933             RETURN_IF_EXCEPTION(scope, JSValue());
 934             if (existingAtomString) {
 935                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))
 936                     return result;
 937             }
 938         }
 939     }
 940 
 941     if (subscript.isUInt32()) {
 942         uint32_t i = subscript.asUInt32();
<span class="line-modified"> 943         auto&amp; metadata = bytecode.metadata(exec);</span>
 944         ArrayProfile* arrayProfile = &amp;metadata.m_arrayProfile;
 945 
 946         if (isJSString(baseValue)) {
 947             if (asString(baseValue)-&gt;canGetIndex(i)) {
 948                 scope.release();
<span class="line-modified"> 949                 return asString(baseValue)-&gt;getIndex(exec, i);</span>
 950             }
 951             arrayProfile-&gt;setOutOfBounds();
 952         } else if (baseValue.isObject()) {
 953             JSObject* object = asObject(baseValue);
 954             if (object-&gt;canGetIndexQuickly(i))
 955                 return object-&gt;getIndexQuickly(i);
 956 
 957             bool skipMarkingOutOfBounds = false;
 958 
 959             if (object-&gt;indexingType() == ArrayWithContiguous &amp;&amp; i &lt; object-&gt;butterfly()-&gt;publicLength()) {
 960                 // FIXME: expand this to ArrayStorage, Int32, and maybe Double:
 961                 // https://bugs.webkit.org/show_bug.cgi?id=182940
 962                 auto* globalObject = object-&gt;globalObject(vm);
 963                 skipMarkingOutOfBounds = globalObject-&gt;isOriginalArrayStructure(object-&gt;structure(vm)) &amp;&amp; globalObject-&gt;arrayPrototypeChainIsSane();
 964             }
 965 
 966             if (!skipMarkingOutOfBounds &amp;&amp; !CommonSlowPaths::canAccessArgumentIndexQuickly(*object, i))
 967                 arrayProfile-&gt;setOutOfBounds();
 968         }
 969 
 970         scope.release();
<span class="line-modified"> 971         return baseValue.get(exec, i);</span>
 972     }
 973 
<span class="line-modified"> 974     baseValue.requireObjectCoercible(exec);</span>
 975     RETURN_IF_EXCEPTION(scope, JSValue());
<span class="line-modified"> 976     auto property = subscript.toPropertyKey(exec);</span>
 977     RETURN_IF_EXCEPTION(scope, JSValue());
 978     scope.release();
<span class="line-modified"> 979     return baseValue.get(exec, property);</span>
 980 }
 981 
 982 LLINT_SLOW_PATH_DECL(slow_path_get_by_val)
 983 {
 984     LLINT_BEGIN();
 985     auto bytecode = pc-&gt;as&lt;OpGetByVal&gt;();
<span class="line-modified"> 986     LLINT_RETURN_PROFILED(getByVal(vm, exec, bytecode));</span>





















 987 }
 988 
 989 LLINT_SLOW_PATH_DECL(slow_path_put_by_val)
 990 {
 991     LLINT_BEGIN();
 992 
 993     auto bytecode = pc-&gt;as&lt;OpPutByVal&gt;();
<span class="line-modified"> 994     JSValue baseValue = getOperand(exec, bytecode.m_base);</span>
<span class="line-modified"> 995     JSValue subscript = getOperand(exec, bytecode.m_property);</span>
<span class="line-modified"> 996     JSValue value = getOperand(exec, bytecode.m_value);</span>
<span class="line-modified"> 997     bool isStrictMode = exec-&gt;codeBlock()-&gt;isStrictMode();</span>
 998 
 999     if (LIKELY(subscript.isUInt32())) {
1000         uint32_t i = subscript.asUInt32();
1001         if (baseValue.isObject()) {
1002             JSObject* object = asObject(baseValue);
1003             if (object-&gt;canSetIndexQuickly(i, value))
1004                 object-&gt;setIndexQuickly(vm, i, value);
1005             else
<span class="line-modified">1006                 object-&gt;methodTable(vm)-&gt;putByIndex(object, exec, i, value, isStrictMode);</span>
1007             LLINT_END();
1008         }
<span class="line-modified">1009         baseValue.putByIndex(exec, i, value, isStrictMode);</span>
1010         LLINT_END();
1011     }
1012 
<span class="line-modified">1013     auto property = subscript.toPropertyKey(exec);</span>
1014     LLINT_CHECK_EXCEPTION();
1015     PutPropertySlot slot(baseValue, isStrictMode);
<span class="line-modified">1016     baseValue.put(exec, property, value, slot);</span>
1017     LLINT_END();
1018 }
1019 
1020 LLINT_SLOW_PATH_DECL(slow_path_put_by_val_direct)
1021 {
1022     LLINT_BEGIN();
1023 
1024     auto bytecode = pc-&gt;as&lt;OpPutByValDirect&gt;();
<span class="line-modified">1025     JSValue baseValue = getOperand(exec, bytecode.m_base);</span>
<span class="line-modified">1026     JSValue subscript = getOperand(exec, bytecode.m_property);</span>
<span class="line-modified">1027     JSValue value = getOperand(exec, bytecode.m_value);</span>
1028     RELEASE_ASSERT(baseValue.isObject());
1029     JSObject* baseObject = asObject(baseValue);
<span class="line-modified">1030     bool isStrictMode = exec-&gt;codeBlock()-&gt;isStrictMode();</span>
1031     if (LIKELY(subscript.isUInt32())) {
1032         // Despite its name, JSValue::isUInt32 will return true only for positive boxed int32_t; all those values are valid array indices.
1033         ASSERT(isIndex(subscript.asUInt32()));
<span class="line-modified">1034         baseObject-&gt;putDirectIndex(exec, subscript.asUInt32(), value, 0, isStrictMode ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
1035         LLINT_END();
1036     }
1037 
1038     if (subscript.isDouble()) {
1039         double subscriptAsDouble = subscript.asDouble();
1040         uint32_t subscriptAsUInt32 = static_cast&lt;uint32_t&gt;(subscriptAsDouble);
1041         if (subscriptAsDouble == subscriptAsUInt32 &amp;&amp; isIndex(subscriptAsUInt32)) {
<span class="line-modified">1042             baseObject-&gt;putDirectIndex(exec, subscriptAsUInt32, value, 0, isStrictMode ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
1043             LLINT_END();
1044         }
1045     }
1046 
1047     // Don&#39;t put to an object if toString threw an exception.
<span class="line-modified">1048     auto property = subscript.toPropertyKey(exec);</span>
1049     if (UNLIKELY(throwScope.exception()))
1050         LLINT_END();
1051 
1052     if (Optional&lt;uint32_t&gt; index = parseIndex(property))
<span class="line-modified">1053         baseObject-&gt;putDirectIndex(exec, index.value(), value, 0, isStrictMode ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
1054     else {
1055         PutPropertySlot slot(baseObject, isStrictMode);
<span class="line-modified">1056         CommonSlowPaths::putDirectWithReify(vm, exec, baseObject, property, value, slot);</span>
1057     }
1058     LLINT_END();
1059 }
1060 
1061 LLINT_SLOW_PATH_DECL(slow_path_del_by_val)
1062 {
1063     LLINT_BEGIN();
1064     auto bytecode = pc-&gt;as&lt;OpDelByVal&gt;();
<span class="line-modified">1065     JSValue baseValue = getOperand(exec, bytecode.m_base);</span>
<span class="line-modified">1066     JSObject* baseObject = baseValue.toObject(exec);</span>
1067     LLINT_CHECK_EXCEPTION();
1068 
<span class="line-modified">1069     JSValue subscript = getOperand(exec, bytecode.m_property);</span>
1070 
1071     bool couldDelete;
1072 
1073     uint32_t i;
1074     if (subscript.getUInt32(i))
<span class="line-modified">1075         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(baseObject, exec, i);</span>
1076     else {
1077         LLINT_CHECK_EXCEPTION();
<span class="line-modified">1078         auto property = subscript.toPropertyKey(exec);</span>
1079         LLINT_CHECK_EXCEPTION();
<span class="line-modified">1080         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deleteProperty(baseObject, exec, property);</span>
1081     }
1082     LLINT_CHECK_EXCEPTION();
1083 
<span class="line-modified">1084     if (!couldDelete &amp;&amp; exec-&gt;codeBlock()-&gt;isStrictMode())</span>
<span class="line-modified">1085         LLINT_THROW(createTypeError(exec, UnableToDeletePropertyError));</span>
1086 
1087     LLINT_RETURN(jsBoolean(couldDelete));
1088 }
1089 
1090 LLINT_SLOW_PATH_DECL(slow_path_put_getter_by_id)
1091 {
1092     LLINT_BEGIN();
1093     auto bytecode = pc-&gt;as&lt;OpPutGetterById&gt;();
<span class="line-modified">1094     ASSERT(getNonConstantOperand(exec, bytecode.m_base).isObject());</span>
<span class="line-modified">1095     JSObject* baseObj = asObject(getNonConstantOperand(exec, bytecode.m_base));</span>
1096 
1097     unsigned options = bytecode.m_attributes;
1098 
<span class="line-modified">1099     JSValue getter = getNonConstantOperand(exec, bytecode.m_accessor);</span>
1100     ASSERT(getter.isObject());
1101 
<span class="line-modified">1102     baseObj-&gt;putGetter(exec, exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property), asObject(getter), options);</span>
1103     LLINT_END();
1104 }
1105 
1106 LLINT_SLOW_PATH_DECL(slow_path_put_setter_by_id)
1107 {
1108     LLINT_BEGIN();
1109     auto bytecode = pc-&gt;as&lt;OpPutSetterById&gt;();
<span class="line-modified">1110     ASSERT(getNonConstantOperand(exec, bytecode.m_base).isObject());</span>
<span class="line-modified">1111     JSObject* baseObj = asObject(getNonConstantOperand(exec, bytecode.m_base));</span>
1112 
1113     unsigned options = bytecode.m_attributes;
1114 
<span class="line-modified">1115     JSValue setter = getNonConstantOperand(exec, bytecode.m_accessor);</span>
1116     ASSERT(setter.isObject());
1117 
<span class="line-modified">1118     baseObj-&gt;putSetter(exec, exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property), asObject(setter), options);</span>
1119     LLINT_END();
1120 }
1121 
1122 LLINT_SLOW_PATH_DECL(slow_path_put_getter_setter_by_id)
1123 {
1124     LLINT_BEGIN();
1125     auto bytecode = pc-&gt;as&lt;OpPutGetterSetterById&gt;();
<span class="line-modified">1126     ASSERT(getNonConstantOperand(exec, bytecode.m_base).isObject());</span>
<span class="line-modified">1127     JSObject* baseObject = asObject(getNonConstantOperand(exec, bytecode.m_base));</span>
1128 
<span class="line-modified">1129     JSValue getter = getNonConstantOperand(exec, bytecode.m_getter);</span>
<span class="line-modified">1130     JSValue setter = getNonConstantOperand(exec, bytecode.m_setter);</span>
1131     ASSERT(getter.isObject() || setter.isObject());
<span class="line-modified">1132     GetterSetter* accessor = GetterSetter::create(vm, exec-&gt;lexicalGlobalObject(), getter, setter);</span>
1133 
<span class="line-modified">1134     CommonSlowPaths::putDirectAccessorWithReify(vm, exec, baseObject, exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property), accessor, bytecode.m_attributes);</span>
1135     LLINT_END();
1136 }
1137 
1138 LLINT_SLOW_PATH_DECL(slow_path_put_getter_by_val)
1139 {
1140     LLINT_BEGIN();
1141     auto bytecode = pc-&gt;as&lt;OpPutGetterByVal&gt;();
<span class="line-modified">1142     ASSERT(getNonConstantOperand(exec, bytecode.m_base).isObject());</span>
<span class="line-modified">1143     JSObject* baseObj = asObject(getNonConstantOperand(exec, bytecode.m_base));</span>
<span class="line-modified">1144     JSValue subscript = getOperand(exec, bytecode.m_property);</span>
1145 
1146     unsigned options = bytecode.m_attributes;
1147 
<span class="line-modified">1148     JSValue getter = getNonConstantOperand(exec, bytecode.m_accessor);</span>
1149     ASSERT(getter.isObject());
1150 
<span class="line-modified">1151     auto property = subscript.toPropertyKey(exec);</span>
1152     LLINT_CHECK_EXCEPTION();
1153 
<span class="line-modified">1154     baseObj-&gt;putGetter(exec, property, asObject(getter), options);</span>
1155     LLINT_END();
1156 }
1157 
1158 LLINT_SLOW_PATH_DECL(slow_path_put_setter_by_val)
1159 {
1160     LLINT_BEGIN();
1161     auto bytecode = pc-&gt;as&lt;OpPutSetterByVal&gt;();
<span class="line-modified">1162     ASSERT(getNonConstantOperand(exec, bytecode.m_base).isObject());</span>
<span class="line-modified">1163     JSObject* baseObj = asObject(getNonConstantOperand(exec, bytecode.m_base));</span>
<span class="line-modified">1164     JSValue subscript = getOperand(exec, bytecode.m_property);</span>
1165 
1166     unsigned options = bytecode.m_attributes;
1167 
<span class="line-modified">1168     JSValue setter = getNonConstantOperand(exec, bytecode.m_accessor);</span>
1169     ASSERT(setter.isObject());
1170 
<span class="line-modified">1171     auto property = subscript.toPropertyKey(exec);</span>
1172     LLINT_CHECK_EXCEPTION();
1173 
<span class="line-modified">1174     baseObj-&gt;putSetter(exec, property, asObject(setter), options);</span>
1175     LLINT_END();
1176 }
1177 
1178 LLINT_SLOW_PATH_DECL(slow_path_jtrue)
1179 {
1180     LLINT_BEGIN();
1181     auto bytecode = pc-&gt;as&lt;OpJtrue&gt;();
<span class="line-modified">1182     LLINT_BRANCH(getOperand(exec, bytecode.m_condition).toBoolean(exec));</span>
1183 }
1184 
1185 LLINT_SLOW_PATH_DECL(slow_path_jfalse)
1186 {
1187     LLINT_BEGIN();
1188     auto bytecode = pc-&gt;as&lt;OpJfalse&gt;();
<span class="line-modified">1189     LLINT_BRANCH(!getOperand(exec, bytecode.m_condition).toBoolean(exec));</span>
1190 }
1191 
1192 LLINT_SLOW_PATH_DECL(slow_path_jless)
1193 {
1194     LLINT_BEGIN();
1195     auto bytecode = pc-&gt;as&lt;OpJless&gt;();
<span class="line-modified">1196     LLINT_BRANCH(jsLess&lt;true&gt;(exec, getOperand(exec, bytecode.m_lhs), getOperand(exec, bytecode.m_rhs)));</span>
1197 }
1198 
1199 LLINT_SLOW_PATH_DECL(slow_path_jnless)
1200 {
1201     LLINT_BEGIN();
1202     auto bytecode = pc-&gt;as&lt;OpJnless&gt;();
<span class="line-modified">1203     LLINT_BRANCH(!jsLess&lt;true&gt;(exec, getOperand(exec, bytecode.m_lhs), getOperand(exec, bytecode.m_rhs)));</span>
1204 }
1205 
1206 LLINT_SLOW_PATH_DECL(slow_path_jgreater)
1207 {
1208     LLINT_BEGIN();
1209     auto bytecode = pc-&gt;as&lt;OpJgreater&gt;();
<span class="line-modified">1210     LLINT_BRANCH(jsLess&lt;false&gt;(exec, getOperand(exec, bytecode.m_rhs), getOperand(exec, bytecode.m_lhs)));</span>
1211 }
1212 
1213 LLINT_SLOW_PATH_DECL(slow_path_jngreater)
1214 {
1215     LLINT_BEGIN();
1216     auto bytecode = pc-&gt;as&lt;OpJngreater&gt;();
<span class="line-modified">1217     LLINT_BRANCH(!jsLess&lt;false&gt;(exec, getOperand(exec, bytecode.m_rhs), getOperand(exec, bytecode.m_lhs)));</span>
1218 }
1219 
1220 LLINT_SLOW_PATH_DECL(slow_path_jlesseq)
1221 {
1222     LLINT_BEGIN();
1223     auto bytecode = pc-&gt;as&lt;OpJlesseq&gt;();
<span class="line-modified">1224     LLINT_BRANCH(jsLessEq&lt;true&gt;(exec, getOperand(exec, bytecode.m_lhs), getOperand(exec, bytecode.m_rhs)));</span>
1225 }
1226 
1227 LLINT_SLOW_PATH_DECL(slow_path_jnlesseq)
1228 {
1229     LLINT_BEGIN();
1230     auto bytecode = pc-&gt;as&lt;OpJnlesseq&gt;();
<span class="line-modified">1231     LLINT_BRANCH(!jsLessEq&lt;true&gt;(exec, getOperand(exec, bytecode.m_lhs), getOperand(exec, bytecode.m_rhs)));</span>
1232 }
1233 
1234 LLINT_SLOW_PATH_DECL(slow_path_jgreatereq)
1235 {
1236     LLINT_BEGIN();
1237     auto bytecode = pc-&gt;as&lt;OpJgreatereq&gt;();
<span class="line-modified">1238     LLINT_BRANCH(jsLessEq&lt;false&gt;(exec, getOperand(exec, bytecode.m_rhs), getOperand(exec, bytecode.m_lhs)));</span>
1239 }
1240 
1241 LLINT_SLOW_PATH_DECL(slow_path_jngreatereq)
1242 {
1243     LLINT_BEGIN();
1244     auto bytecode = pc-&gt;as&lt;OpJngreatereq&gt;();
<span class="line-modified">1245     LLINT_BRANCH(!jsLessEq&lt;false&gt;(exec, getOperand(exec, bytecode.m_rhs), getOperand(exec, bytecode.m_lhs)));</span>
1246 }
1247 
1248 LLINT_SLOW_PATH_DECL(slow_path_jeq)
1249 {
1250     LLINT_BEGIN();
1251     auto bytecode = pc-&gt;as&lt;OpJeq&gt;();
<span class="line-modified">1252     LLINT_BRANCH(JSValue::equal(exec, getOperand(exec, bytecode.m_lhs), getOperand(exec, bytecode.m_rhs)));</span>
1253 }
1254 
1255 LLINT_SLOW_PATH_DECL(slow_path_jneq)
1256 {
1257     LLINT_BEGIN();
1258     auto bytecode = pc-&gt;as&lt;OpJneq&gt;();
<span class="line-modified">1259     LLINT_BRANCH(!JSValue::equal(exec, getOperand(exec, bytecode.m_lhs), getOperand(exec, bytecode.m_rhs)));</span>
1260 }
1261 
1262 LLINT_SLOW_PATH_DECL(slow_path_jstricteq)
1263 {
1264     LLINT_BEGIN();
1265     auto bytecode = pc-&gt;as&lt;OpJstricteq&gt;();
<span class="line-modified">1266     LLINT_BRANCH(JSValue::strictEqual(exec, getOperand(exec, bytecode.m_lhs), getOperand(exec, bytecode.m_rhs)));</span>
1267 }
1268 
1269 LLINT_SLOW_PATH_DECL(slow_path_jnstricteq)
1270 {
1271     LLINT_BEGIN();
1272     auto bytecode = pc-&gt;as&lt;OpJnstricteq&gt;();
<span class="line-modified">1273     LLINT_BRANCH(!JSValue::strictEqual(exec, getOperand(exec, bytecode.m_lhs), getOperand(exec, bytecode.m_rhs)));</span>
1274 }
1275 
1276 LLINT_SLOW_PATH_DECL(slow_path_switch_imm)
1277 {
1278     LLINT_BEGIN();
1279     auto bytecode = pc-&gt;as&lt;OpSwitchImm&gt;();
<span class="line-modified">1280     JSValue scrutinee = getOperand(exec, bytecode.m_scrutinee);</span>
1281     ASSERT(scrutinee.isDouble());
1282     double value = scrutinee.asDouble();
1283     int32_t intValue = static_cast&lt;int32_t&gt;(value);
1284     int defaultOffset = JUMP_OFFSET(bytecode.m_defaultOffset);
<span class="line-modified">1285     if (value == intValue) {</span>
<span class="line-removed">1286         CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
1287         JUMP_TO(codeBlock-&gt;switchJumpTable(bytecode.m_tableIndex).offsetForValue(intValue, defaultOffset));
<span class="line-modified">1288     } else</span>
1289         JUMP_TO(defaultOffset);
1290     LLINT_END();
1291 }
1292 
1293 LLINT_SLOW_PATH_DECL(slow_path_switch_char)
1294 {
1295     LLINT_BEGIN();
1296     auto bytecode = pc-&gt;as&lt;OpSwitchChar&gt;();
<span class="line-modified">1297     JSValue scrutinee = getOperand(exec, bytecode.m_scrutinee);</span>
1298     ASSERT(scrutinee.isString());
1299     JSString* string = asString(scrutinee);
1300     ASSERT(string-&gt;length() == 1);
1301     int defaultOffset = JUMP_OFFSET(bytecode.m_defaultOffset);
<span class="line-modified">1302     StringImpl* impl = string-&gt;value(exec).impl();</span>
<span class="line-removed">1303     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
1304     JUMP_TO(codeBlock-&gt;switchJumpTable(bytecode.m_tableIndex).offsetForValue((*impl)[0], defaultOffset));
1305     LLINT_END();
1306 }
1307 
1308 LLINT_SLOW_PATH_DECL(slow_path_switch_string)
1309 {
1310     LLINT_BEGIN();
1311     auto bytecode = pc-&gt;as&lt;OpSwitchString&gt;();
<span class="line-modified">1312     JSValue scrutinee = getOperand(exec, bytecode.m_scrutinee);</span>
1313     int defaultOffset = JUMP_OFFSET(bytecode.m_defaultOffset);
1314     if (!scrutinee.isString())
1315         JUMP_TO(defaultOffset);
1316     else {
<span class="line-modified">1317         StringImpl* scrutineeStringImpl = asString(scrutinee)-&gt;value(exec).impl();</span>
1318 
1319         LLINT_CHECK_EXCEPTION();
1320 
<span class="line-removed">1321         CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">1322 </span>
1323         JUMP_TO(codeBlock-&gt;stringSwitchJumpTable(bytecode.m_tableIndex).offsetForValue(scrutineeStringImpl, defaultOffset));
1324     }
1325     LLINT_END();
1326 }
1327 
1328 LLINT_SLOW_PATH_DECL(slow_path_new_func)
1329 {
1330     LLINT_BEGIN();
1331     auto bytecode = pc-&gt;as&lt;OpNewFunc&gt;();
<span class="line-modified">1332     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">1333     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
1334     slowPathLogF(&quot;Creating function!\n&quot;);
1335     LLINT_RETURN(JSFunction::create(vm, codeBlock-&gt;functionDecl(bytecode.m_functionDecl), scope));
1336 }
1337 
1338 LLINT_SLOW_PATH_DECL(slow_path_new_generator_func)
1339 {
1340     LLINT_BEGIN();
1341     auto bytecode = pc-&gt;as&lt;OpNewGeneratorFunc&gt;();
<span class="line-modified">1342     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">1343     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
1344     slowPathLogF(&quot;Creating function!\n&quot;);
1345     LLINT_RETURN(JSGeneratorFunction::create(vm, codeBlock-&gt;functionDecl(bytecode.m_functionDecl), scope));
1346 }
1347 
1348 LLINT_SLOW_PATH_DECL(slow_path_new_async_func)
1349 {
1350     LLINT_BEGIN();
1351     auto bytecode = pc-&gt;as&lt;OpNewAsyncFunc&gt;();
<span class="line-modified">1352     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">1353     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
1354     slowPathLogF(&quot;Creating async function!\n&quot;);
1355     LLINT_RETURN(JSAsyncFunction::create(vm, codeBlock-&gt;functionDecl(bytecode.m_functionDecl), scope));
1356 }
1357 
1358 LLINT_SLOW_PATH_DECL(slow_path_new_async_generator_func)
1359 {
1360     LLINT_BEGIN();
1361     auto bytecode = pc-&gt;as&lt;OpNewAsyncGeneratorFunc&gt;();
<span class="line-modified">1362     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">1363     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
1364     slowPathLogF(&quot;Creating async generator function!\n&quot;);
1365     LLINT_RETURN(JSAsyncGeneratorFunction::create(vm, codeBlock-&gt;functionDecl(bytecode.m_functionDecl), scope));
1366 }
1367 
1368 LLINT_SLOW_PATH_DECL(slow_path_new_func_exp)
1369 {
1370     LLINT_BEGIN();
1371 
1372     auto bytecode = pc-&gt;as&lt;OpNewFuncExp&gt;();
<span class="line-modified">1373     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">1374     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
1375     FunctionExecutable* executable = codeBlock-&gt;functionExpr(bytecode.m_functionDecl);
1376 
1377     LLINT_RETURN(JSFunction::create(vm, executable, scope));
1378 }
1379 
1380 LLINT_SLOW_PATH_DECL(slow_path_new_generator_func_exp)
1381 {
1382     LLINT_BEGIN();
1383 
1384     auto bytecode = pc-&gt;as&lt;OpNewGeneratorFuncExp&gt;();
<span class="line-modified">1385     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">1386     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
1387     FunctionExecutable* executable = codeBlock-&gt;functionExpr(bytecode.m_functionDecl);
1388 
1389     LLINT_RETURN(JSGeneratorFunction::create(vm, executable, scope));
1390 }
1391 
1392 LLINT_SLOW_PATH_DECL(slow_path_new_async_func_exp)
1393 {
1394     LLINT_BEGIN();
1395 
1396     auto bytecode = pc-&gt;as&lt;OpNewAsyncFuncExp&gt;();
<span class="line-modified">1397     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">1398     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
1399     FunctionExecutable* executable = codeBlock-&gt;functionExpr(bytecode.m_functionDecl);
1400 
1401     LLINT_RETURN(JSAsyncFunction::create(vm, executable, scope));
1402 }
1403 
1404 LLINT_SLOW_PATH_DECL(slow_path_new_async_generator_func_exp)
1405 {
1406     LLINT_BEGIN();
1407 
1408     auto bytecode = pc-&gt;as&lt;OpNewAsyncGeneratorFuncExp&gt;();
<span class="line-modified">1409     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">1410     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
1411     FunctionExecutable* executable = codeBlock-&gt;functionExpr(bytecode.m_functionDecl);
1412 
1413     LLINT_RETURN(JSAsyncGeneratorFunction::create(vm, executable, scope));
1414 }
1415 
1416 LLINT_SLOW_PATH_DECL(slow_path_set_function_name)
1417 {
1418     LLINT_BEGIN();
1419     auto bytecode = pc-&gt;as&lt;OpSetFunctionName&gt;();
<span class="line-modified">1420     JSFunction* func = jsCast&lt;JSFunction*&gt;(getNonConstantOperand(exec, bytecode.m_function));</span>
<span class="line-modified">1421     JSValue name = getOperand(exec, bytecode.m_name);</span>
<span class="line-modified">1422     func-&gt;setFunctionName(exec, name);</span>
1423     LLINT_END();
1424 }
1425 
<span class="line-modified">1426 static SlowPathReturnType handleHostCall(ExecState* execCallee, JSValue callee, CodeSpecializationKind kind)</span>
1427 {
1428     slowPathLog(&quot;Performing host call.\n&quot;);
1429 
<span class="line-modified">1430     ExecState* exec = execCallee-&gt;callerFrame();</span>
<span class="line-modified">1431     VM&amp; vm = exec-&gt;vm();</span>


1432     auto throwScope = DECLARE_THROW_SCOPE(vm);
1433 
<span class="line-modified">1434     execCallee-&gt;setCodeBlock(0);</span>
<span class="line-modified">1435     execCallee-&gt;clearReturnPC();</span>
1436 
1437     if (kind == CodeForCall) {
1438         CallData callData;
1439         CallType callType = getCallData(vm, callee, callData);
1440 
1441         ASSERT(callType != CallType::JS);
1442 
1443         if (callType == CallType::Host) {
<span class="line-modified">1444             NativeCallFrameTracer tracer(vm, execCallee);</span>
<span class="line-modified">1445             execCallee-&gt;setCallee(asObject(callee));</span>
<span class="line-modified">1446             vm.hostCallReturnValue = JSValue::decode(callData.native.function(execCallee));</span>
<span class="line-modified">1447             LLINT_CALL_RETURN(execCallee, execCallee, LLInt::getCodePtr(getHostCallReturnValue), CFunctionPtrTag);</span>
1448         }
1449 
1450         slowPathLog(&quot;Call callee is not a function: &quot;, callee, &quot;\n&quot;);
1451 
1452         ASSERT(callType == CallType::None);
<span class="line-modified">1453         LLINT_CALL_THROW(exec, createNotAFunctionError(exec, callee));</span>
1454     }
1455 
1456     ASSERT(kind == CodeForConstruct);
1457 
1458     ConstructData constructData;
1459     ConstructType constructType = getConstructData(vm, callee, constructData);
1460 
1461     ASSERT(constructType != ConstructType::JS);
1462 
1463     if (constructType == ConstructType::Host) {
<span class="line-modified">1464         NativeCallFrameTracer tracer(vm, execCallee);</span>
<span class="line-modified">1465         execCallee-&gt;setCallee(asObject(callee));</span>
<span class="line-modified">1466         vm.hostCallReturnValue = JSValue::decode(constructData.native.function(execCallee));</span>
<span class="line-modified">1467         LLINT_CALL_RETURN(execCallee, execCallee, LLInt::getCodePtr(getHostCallReturnValue), CFunctionPtrTag);</span>
1468     }
1469 
1470     slowPathLog(&quot;Constructor callee is not a function: &quot;, callee, &quot;\n&quot;);
1471 
1472     ASSERT(constructType == ConstructType::None);
<span class="line-modified">1473     LLINT_CALL_THROW(exec, createNotAConstructorError(exec, callee));</span>
1474 }
1475 
<span class="line-modified">1476 inline SlowPathReturnType setUpCall(ExecState* execCallee, CodeSpecializationKind kind, JSValue calleeAsValue, LLIntCallLinkInfo* callLinkInfo = nullptr)</span>
1477 {
<span class="line-modified">1478     ExecState* exec = execCallee-&gt;callerFrame();</span>
<span class="line-modified">1479     VM&amp; vm = exec-&gt;vm();</span>


1480     auto throwScope = DECLARE_THROW_SCOPE(vm);
1481 
<span class="line-modified">1482     slowPathLogF(&quot;Performing call with recorded PC = %p\n&quot;, exec-&gt;currentVPC());</span>
1483 
1484     JSCell* calleeAsFunctionCell = getJSFunction(calleeAsValue);
1485     if (!calleeAsFunctionCell) {
1486         if (auto* internalFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, calleeAsValue)) {
1487             MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr = vm.getCTIInternalFunctionTrampolineFor(kind);
1488             ASSERT(!!codePtr);
1489 
1490             if (!LLINT_ALWAYS_ACCESS_SLOW &amp;&amp; callLinkInfo) {
<span class="line-removed">1491                 CodeBlock* callerCodeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">1492 </span>
1493                 ConcurrentJSLocker locker(callerCodeBlock-&gt;m_lock);
1494                 callLinkInfo-&gt;link(vm, callerCodeBlock, internalFunction, codePtr);
1495             }
1496 
1497             assertIsTaggedWith(codePtr.executableAddress(), JSEntryPtrTag);
<span class="line-modified">1498             LLINT_CALL_RETURN(exec, execCallee, codePtr.executableAddress(), JSEntryPtrTag);</span>
1499         }
<span class="line-modified">1500         RELEASE_AND_RETURN(throwScope, handleHostCall(execCallee, calleeAsValue, kind));</span>
1501     }
1502     JSFunction* callee = jsCast&lt;JSFunction*&gt;(calleeAsFunctionCell);
1503     JSScope* scope = callee-&gt;scopeUnchecked();
1504     ExecutableBase* executable = callee-&gt;executable();
1505 
1506     MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr;
<span class="line-modified">1507     CodeBlock* codeBlock = 0;</span>
1508     if (executable-&gt;isHostFunction())
1509         codePtr = executable-&gt;entrypointFor(kind, MustCheckArity);
1510     else {
1511         FunctionExecutable* functionExecutable = static_cast&lt;FunctionExecutable*&gt;(executable);
1512 
1513         if (!isCall(kind) &amp;&amp; functionExecutable-&gt;constructAbility() == ConstructAbility::CannotConstruct)
<span class="line-modified">1514             LLINT_CALL_THROW(exec, createNotAConstructorError(exec, callee));</span>
1515 
<span class="line-modified">1516         CodeBlock** codeBlockSlot = execCallee-&gt;addressOfCodeBlock();</span>
1517         Exception* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, callee, scope, kind, *codeBlockSlot);
1518         EXCEPTION_ASSERT(throwScope.exception() == error);
1519         if (UNLIKELY(error))
<span class="line-modified">1520             LLINT_CALL_THROW(exec, error);</span>
1521         codeBlock = *codeBlockSlot;
1522         ASSERT(codeBlock);
1523         ArityCheckMode arity;
<span class="line-modified">1524         if (execCallee-&gt;argumentCountIncludingThis() &lt; static_cast&lt;size_t&gt;(codeBlock-&gt;numParameters()))</span>
1525             arity = MustCheckArity;
1526         else
1527             arity = ArityCheckNotRequired;
1528         codePtr = functionExecutable-&gt;entrypointFor(kind, arity);
1529     }
1530 
1531     ASSERT(!!codePtr);
1532 
1533     if (!LLINT_ALWAYS_ACCESS_SLOW &amp;&amp; callLinkInfo) {
<span class="line-removed">1534         CodeBlock* callerCodeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">1535 </span>
1536         ConcurrentJSLocker locker(callerCodeBlock-&gt;m_lock);
1537         callLinkInfo-&gt;link(vm, callerCodeBlock, callee, codePtr);
1538         if (codeBlock)
<span class="line-modified">1539             codeBlock-&gt;linkIncomingCall(exec, callLinkInfo);</span>
1540     }
1541 
1542     assertIsTaggedWith(codePtr.executableAddress(), JSEntryPtrTag);
<span class="line-modified">1543     LLINT_CALL_RETURN(exec, execCallee, codePtr.executableAddress(), JSEntryPtrTag);</span>
1544 }
1545 
1546 template&lt;typename Op&gt;
<span class="line-modified">1547 inline SlowPathReturnType genericCall(ExecState* exec, Op&amp;&amp; bytecode, CodeSpecializationKind kind)</span>
1548 {
1549     // This needs to:
1550     // - Set up a call frame.
1551     // - Figure out what to call and compile it if necessary.
1552     // - If possible, link the call&#39;s inline cache.
1553     // - Return a tuple of machine code address to call and the new call frame.
1554 
<span class="line-modified">1555     JSValue calleeAsValue = getOperand(exec, bytecode.m_callee);</span>
1556 
<span class="line-modified">1557     ExecState* execCallee = exec - bytecode.m_argv;</span>
1558 
<span class="line-modified">1559     execCallee-&gt;setArgumentCountIncludingThis(bytecode.m_argc);</span>
<span class="line-modified">1560     execCallee-&gt;uncheckedR(CallFrameSlot::callee) = calleeAsValue;</span>
<span class="line-modified">1561     execCallee-&gt;setCallerFrame(exec);</span>
1562 
<span class="line-modified">1563     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-modified">1564     return setUpCall(execCallee, kind, calleeAsValue, &amp;metadata.m_callLinkInfo);</span>
1565 }
1566 
1567 LLINT_SLOW_PATH_DECL(slow_path_call)
1568 {
1569     LLINT_BEGIN_NO_SET_PC();
<span class="line-modified">1570     RELEASE_AND_RETURN(throwScope, genericCall(exec, pc-&gt;as&lt;OpCall&gt;(), CodeForCall));</span>

1571 }
1572 
1573 LLINT_SLOW_PATH_DECL(slow_path_tail_call)
1574 {
1575     LLINT_BEGIN_NO_SET_PC();
<span class="line-modified">1576     RELEASE_AND_RETURN(throwScope, genericCall(exec, pc-&gt;as&lt;OpTailCall&gt;(), CodeForCall));</span>

1577 }
1578 
1579 LLINT_SLOW_PATH_DECL(slow_path_construct)
1580 {
1581     LLINT_BEGIN_NO_SET_PC();
<span class="line-modified">1582     RELEASE_AND_RETURN(throwScope, genericCall(exec, pc-&gt;as&lt;OpConstruct&gt;(), CodeForConstruct));</span>

1583 }
1584 
1585 LLINT_SLOW_PATH_DECL(slow_path_size_frame_for_varargs)
1586 {
1587     LLINT_BEGIN();
1588     // This needs to:
1589     // - Set up a call frame while respecting the variable arguments.
1590 
1591     unsigned numUsedStackSlots;
1592     JSValue arguments;
1593     int firstVarArg;
1594     switch (pc-&gt;opcodeID()) {
1595     case op_call_varargs: {
1596         auto bytecode = pc-&gt;as&lt;OpCallVarargs&gt;();
1597         numUsedStackSlots = -bytecode.m_firstFree.offset();
<span class="line-modified">1598         arguments = getOperand(exec, bytecode.m_arguments);</span>
1599         firstVarArg = bytecode.m_firstVarArg;
1600         break;
1601     }
1602     case op_tail_call_varargs: {
1603         auto bytecode = pc-&gt;as&lt;OpTailCallVarargs&gt;();
1604         numUsedStackSlots = -bytecode.m_firstFree.offset();
<span class="line-modified">1605         arguments = getOperand(exec, bytecode.m_arguments);</span>
1606         firstVarArg = bytecode.m_firstVarArg;
1607         break;
1608     }
1609     case op_construct_varargs: {
1610         auto bytecode = pc-&gt;as&lt;OpConstructVarargs&gt;();
1611         numUsedStackSlots = -bytecode.m_firstFree.offset();
<span class="line-modified">1612         arguments = getOperand(exec, bytecode.m_arguments);</span>
1613         firstVarArg = bytecode.m_firstVarArg;
1614         break;
1615     }
1616     default:
1617         RELEASE_ASSERT_NOT_REACHED();
1618     }
<span class="line-modified">1619     unsigned length = sizeFrameForVarargs(exec, vm, arguments, numUsedStackSlots, firstVarArg);</span>
<span class="line-modified">1620     LLINT_CALL_CHECK_EXCEPTION(exec, exec);</span>
1621 
<span class="line-modified">1622     ExecState* execCallee = calleeFrameForVarargs(exec, numUsedStackSlots, length + 1);</span>
1623     vm.varargsLength = length;
<span class="line-modified">1624     vm.newCallFrameReturnValue = execCallee;</span>
1625 
<span class="line-modified">1626     LLINT_RETURN_CALLEE_FRAME(execCallee);</span>
1627 }
1628 
1629 LLINT_SLOW_PATH_DECL(slow_path_size_frame_for_forward_arguments)
1630 {
1631     LLINT_BEGIN();
1632     // This needs to:
1633     // - Set up a call frame with the same arguments as the current frame.
1634 
1635     auto bytecode = pc-&gt;as&lt;OpTailCallForwardArguments&gt;();
1636     unsigned numUsedStackSlots = -bytecode.m_firstFree.offset();
1637 
<span class="line-modified">1638     unsigned arguments = sizeFrameForForwardArguments(exec, vm, numUsedStackSlots);</span>
<span class="line-modified">1639     LLINT_CALL_CHECK_EXCEPTION(exec, exec);</span>
1640 
<span class="line-modified">1641     ExecState* execCallee = calleeFrameForVarargs(exec, numUsedStackSlots, arguments + 1);</span>
1642 
1643     vm.varargsLength = arguments;
<span class="line-modified">1644     vm.newCallFrameReturnValue = execCallee;</span>
1645 
<span class="line-modified">1646     LLINT_RETURN_CALLEE_FRAME(execCallee);</span>
1647 }
1648 
1649 enum class SetArgumentsWith {
1650     Object,
1651     CurrentArguments
1652 };
1653 
1654 template&lt;typename Op&gt;
<span class="line-modified">1655 inline SlowPathReturnType varargsSetup(ExecState* exec, const Instruction* pc, CodeSpecializationKind kind, SetArgumentsWith set)</span>
1656 {
1657     LLINT_BEGIN_NO_SET_PC();

1658     // This needs to:
1659     // - Figure out what to call and compile it if necessary.
1660     // - Return a tuple of machine code address to call and the new call frame.
1661 
1662     auto bytecode = pc-&gt;as&lt;Op&gt;();
<span class="line-modified">1663     JSValue calleeAsValue = getOperand(exec, bytecode.m_callee);</span>
1664 
<span class="line-modified">1665     ExecState* execCallee = vm.newCallFrameReturnValue;</span>
1666 
1667     if (set == SetArgumentsWith::Object) {
<span class="line-modified">1668         setupVarargsFrameAndSetThis(exec, execCallee, getOperand(exec, bytecode.m_thisValue), getOperand(exec, bytecode.m_arguments), bytecode.m_firstVarArg, vm.varargsLength);</span>
<span class="line-modified">1669         LLINT_CALL_CHECK_EXCEPTION(exec, exec);</span>
1670     } else
<span class="line-modified">1671         setupForwardArgumentsFrameAndSetThis(exec, execCallee, getOperand(exec, bytecode.m_thisValue), vm.varargsLength);</span>
1672 
<span class="line-modified">1673     execCallee-&gt;setCallerFrame(exec);</span>
<span class="line-modified">1674     execCallee-&gt;uncheckedR(CallFrameSlot::callee) = calleeAsValue;</span>
<span class="line-modified">1675     exec-&gt;setCurrentVPC(pc);</span>
1676 
<span class="line-modified">1677     RELEASE_AND_RETURN(throwScope, setUpCall(execCallee, kind, calleeAsValue));</span>
1678 }
1679 
1680 LLINT_SLOW_PATH_DECL(slow_path_call_varargs)
1681 {
<span class="line-modified">1682     return varargsSetup&lt;OpCallVarargs&gt;(exec, pc, CodeForCall, SetArgumentsWith::Object);</span>
1683 }
1684 
1685 LLINT_SLOW_PATH_DECL(slow_path_tail_call_varargs)
1686 {
<span class="line-modified">1687     return varargsSetup&lt;OpTailCallVarargs&gt;(exec, pc, CodeForCall, SetArgumentsWith::Object);</span>
1688 }
1689 
1690 LLINT_SLOW_PATH_DECL(slow_path_tail_call_forward_arguments)
1691 {
<span class="line-modified">1692     return varargsSetup&lt;OpTailCallForwardArguments&gt;(exec, pc, CodeForCall, SetArgumentsWith::CurrentArguments);</span>
1693 }
1694 
1695 LLINT_SLOW_PATH_DECL(slow_path_construct_varargs)
1696 {
<span class="line-modified">1697     return varargsSetup&lt;OpConstructVarargs&gt;(exec, pc, CodeForConstruct, SetArgumentsWith::Object);</span>
1698 }
1699 
<span class="line-modified">1700 inline SlowPathReturnType commonCallEval(ExecState* exec, const Instruction* pc, MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; returnPoint)</span>
1701 {
1702     LLINT_BEGIN_NO_SET_PC();
1703     auto bytecode = pc-&gt;as&lt;OpCallEval&gt;();
<span class="line-modified">1704     JSValue calleeAsValue = getNonConstantOperand(exec, bytecode.m_callee);</span>
1705 
<span class="line-modified">1706     ExecState* execCallee = exec - bytecode.m_argv;</span>
1707 
<span class="line-modified">1708     execCallee-&gt;setArgumentCountIncludingThis(bytecode.m_argc);</span>
<span class="line-modified">1709     execCallee-&gt;setCallerFrame(exec);</span>
<span class="line-modified">1710     execCallee-&gt;uncheckedR(CallFrameSlot::callee) = calleeAsValue;</span>
<span class="line-modified">1711     execCallee-&gt;setReturnPC(returnPoint.executableAddress());</span>
<span class="line-modified">1712     execCallee-&gt;setCodeBlock(0);</span>
<span class="line-modified">1713     exec-&gt;setCurrentVPC(pc);</span>
1714 
1715     if (!isHostFunction(calleeAsValue, globalFuncEval))
<span class="line-modified">1716         RELEASE_AND_RETURN(throwScope, setUpCall(execCallee, CodeForCall, calleeAsValue));</span>
1717 
<span class="line-modified">1718     vm.hostCallReturnValue = eval(execCallee);</span>
<span class="line-modified">1719     LLINT_CALL_RETURN(exec, execCallee, LLInt::getCodePtr(getHostCallReturnValue), CFunctionPtrTag);</span>
1720 }
1721 
1722 LLINT_SLOW_PATH_DECL(slow_path_call_eval)
1723 {
<span class="line-modified">1724     return commonCallEval(exec, pc, LLInt::getCodePtr&lt;JSEntryPtrTag&gt;(llint_generic_return_point));</span>
1725 }
1726 
1727 LLINT_SLOW_PATH_DECL(slow_path_call_eval_wide16)
1728 {
<span class="line-modified">1729     return commonCallEval(exec, pc, LLInt::getWide16CodePtr&lt;JSEntryPtrTag&gt;(llint_generic_return_point));</span>
1730 }
1731 
1732 LLINT_SLOW_PATH_DECL(slow_path_call_eval_wide32)
1733 {
<span class="line-modified">1734     return commonCallEval(exec, pc, LLInt::getWide32CodePtr&lt;JSEntryPtrTag&gt;(llint_generic_return_point));</span>
1735 }
1736 
1737 LLINT_SLOW_PATH_DECL(slow_path_strcat)
1738 {
1739     LLINT_BEGIN();
1740     auto bytecode = pc-&gt;as&lt;OpStrcat&gt;();
<span class="line-modified">1741     LLINT_RETURN(jsStringFromRegisterArray(exec, &amp;exec-&gt;uncheckedR(bytecode.m_src), bytecode.m_count));</span>
1742 }
1743 
1744 LLINT_SLOW_PATH_DECL(slow_path_to_primitive)
1745 {
1746     LLINT_BEGIN();
1747     auto bytecode = pc-&gt;as&lt;OpToPrimitive&gt;();
<span class="line-modified">1748     LLINT_RETURN(getOperand(exec, bytecode.m_src).toPrimitive(exec));</span>
1749 }
1750 
1751 LLINT_SLOW_PATH_DECL(slow_path_throw)
1752 {
1753     LLINT_BEGIN();
1754     auto bytecode = pc-&gt;as&lt;OpThrow&gt;();
<span class="line-modified">1755     LLINT_THROW(getOperand(exec, bytecode.m_value));</span>
1756 }
1757 
1758 LLINT_SLOW_PATH_DECL(slow_path_handle_traps)
1759 {
1760     LLINT_BEGIN_NO_SET_PC();
1761     ASSERT(vm.needTrapHandling());
<span class="line-modified">1762     vm.handleTraps(exec);</span>
1763     UNUSED_PARAM(pc);
<span class="line-modified">1764     LLINT_RETURN_TWO(throwScope.exception(), exec);</span>
1765 }
1766 
1767 LLINT_SLOW_PATH_DECL(slow_path_debug)
1768 {
1769     LLINT_BEGIN();
1770     auto bytecode = pc-&gt;as&lt;OpDebug&gt;();
<span class="line-modified">1771     vm.interpreter-&gt;debug(exec, bytecode.m_debugHookType);</span>
1772 
1773     LLINT_END();
1774 }
1775 
1776 LLINT_SLOW_PATH_DECL(slow_path_handle_exception)
1777 {
<span class="line-modified">1778     LLINT_BEGIN_NO_SET_PC();</span>
<span class="line-modified">1779     UNUSED_PARAM(throwScope);</span>
<span class="line-modified">1780     genericUnwind(vm, exec);</span>
1781     LLINT_END_IMPL();
1782 }
1783 
1784 LLINT_SLOW_PATH_DECL(slow_path_get_from_scope)
1785 {
1786     LLINT_BEGIN();
1787     auto bytecode = pc-&gt;as&lt;OpGetFromScope&gt;();
<span class="line-modified">1788     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-modified">1789     const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_var);</span>
<span class="line-modified">1790     JSObject* scope = jsCast&lt;JSObject*&gt;(getNonConstantOperand(exec, bytecode.m_scope));</span>
1791 
1792     // ModuleVar is always converted to ClosureVar for get_from_scope.
1793     ASSERT(metadata.m_getPutInfo.resolveType() != ModuleVar);
1794 
<span class="line-modified">1795     LLINT_RETURN(scope-&gt;getPropertySlot(exec, ident, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {</span>
1796         if (!found) {
1797             if (metadata.m_getPutInfo.resolveMode() == ThrowIfNotFound)
<span class="line-modified">1798                 return throwException(exec, throwScope, createUndefinedVariableError(exec, ident));</span>
1799             return jsUndefined();
1800         }
1801 
1802         JSValue result = JSValue();
1803         if (scope-&gt;isGlobalLexicalEnvironment()) {
1804             // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
<span class="line-modified">1805             result = slot.getValue(exec, ident);</span>
1806             if (result == jsTDZValue())
<span class="line-modified">1807                 return throwException(exec, throwScope, createTDZError(exec));</span>
1808         }
1809 
<span class="line-modified">1810         CommonSlowPaths::tryCacheGetFromScopeGlobal(exec, vm, bytecode, scope, slot, ident);</span>
1811 
1812         if (!result)
<span class="line-modified">1813             return slot.getValue(exec, ident);</span>
1814         return result;
1815     }));
1816 }
1817 
1818 LLINT_SLOW_PATH_DECL(slow_path_put_to_scope)
1819 {
1820     LLINT_BEGIN();
1821 
1822     auto bytecode = pc-&gt;as&lt;OpPutToScope&gt;();
<span class="line-modified">1823     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-removed">1824     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
1825     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_var);
<span class="line-modified">1826     JSObject* scope = jsCast&lt;JSObject*&gt;(getNonConstantOperand(exec, bytecode.m_scope));</span>
<span class="line-modified">1827     JSValue value = getOperand(exec, bytecode.m_value);</span>
1828     if (metadata.m_getPutInfo.resolveType() == LocalClosureVar) {
1829         JSLexicalEnvironment* environment = jsCast&lt;JSLexicalEnvironment*&gt;(scope);
1830         environment-&gt;variableAt(ScopeOffset(metadata.m_operand)).set(vm, environment, value);
1831 
1832         // Have to do this *after* the write, because if this puts the set into IsWatched, then we need
1833         // to have already changed the value of the variable. Otherwise we might watch and constant-fold
1834         // to the Undefined value from before the assignment.
1835         if (metadata.m_watchpointSet)
1836             metadata.m_watchpointSet-&gt;touch(vm, &quot;Executed op_put_scope&lt;LocalClosureVar&gt;&quot;);
1837         LLINT_END();
1838     }
1839 
<span class="line-modified">1840     bool hasProperty = scope-&gt;hasProperty(exec, ident);</span>
1841     LLINT_CHECK_EXCEPTION();
1842     if (hasProperty
1843         &amp;&amp; scope-&gt;isGlobalLexicalEnvironment()
1844         &amp;&amp; !isInitialization(metadata.m_getPutInfo.initializationMode())) {
1845         // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
1846         PropertySlot slot(scope, PropertySlot::InternalMethodType::Get);
<span class="line-modified">1847         JSGlobalLexicalEnvironment::getOwnPropertySlot(scope, exec, ident, slot);</span>
<span class="line-modified">1848         if (slot.getValue(exec, ident) == jsTDZValue())</span>
<span class="line-modified">1849             LLINT_THROW(createTDZError(exec));</span>
1850     }
1851 
1852     if (metadata.m_getPutInfo.resolveMode() == ThrowIfNotFound &amp;&amp; !hasProperty)
<span class="line-modified">1853         LLINT_THROW(createUndefinedVariableError(exec, ident));</span>
1854 
1855     PutPropertySlot slot(scope, codeBlock-&gt;isStrictMode(), PutPropertySlot::UnknownContext, isInitialization(metadata.m_getPutInfo.initializationMode()));
<span class="line-modified">1856     scope-&gt;methodTable(vm)-&gt;put(scope, exec, ident, value, slot);</span>
1857 
<span class="line-modified">1858     CommonSlowPaths::tryCachePutToScopeGlobal(exec, codeBlock, bytecode, scope, slot, ident);</span>
1859 
1860     LLINT_END();
1861 }
1862 
1863 LLINT_SLOW_PATH_DECL(slow_path_check_if_exception_is_uncatchable_and_notify_profiler)
1864 {
1865     LLINT_BEGIN();

1866     RELEASE_ASSERT(!!throwScope.exception());
1867 
1868     if (isTerminatedExecutionException(vm, throwScope.exception()))
1869         LLINT_RETURN_TWO(pc, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)));
<span class="line-modified">1870     LLINT_RETURN_TWO(pc, 0);</span>
1871 }
1872 
1873 LLINT_SLOW_PATH_DECL(slow_path_log_shadow_chicken_prologue)
1874 {
1875     LLINT_BEGIN();
1876 
1877     auto bytecode = pc-&gt;as&lt;OpLogShadowChickenPrologue&gt;();
<span class="line-modified">1878     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
1879     ShadowChicken* shadowChicken = vm.shadowChicken();
1880     RELEASE_ASSERT(shadowChicken);
<span class="line-modified">1881     shadowChicken-&gt;log(vm, exec, ShadowChicken::Packet::prologue(exec-&gt;jsCallee(), exec, exec-&gt;callerFrame(), scope));</span>
1882 
1883     LLINT_END();
1884 }
1885 
1886 LLINT_SLOW_PATH_DECL(slow_path_log_shadow_chicken_tail)
1887 {
1888     LLINT_BEGIN();
1889 
1890     auto bytecode = pc-&gt;as&lt;OpLogShadowChickenTail&gt;();
<span class="line-modified">1891     JSValue thisValue = getNonConstantOperand(exec, bytecode.m_thisValue);</span>
<span class="line-modified">1892     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>


1893 
<span class="line-removed">1894 #if USE(JSVALUE64)</span>
<span class="line-removed">1895     CallSiteIndex callSiteIndex(exec-&gt;codeBlock()-&gt;bytecodeOffset(pc));</span>
<span class="line-removed">1896 #else</span>
<span class="line-removed">1897     CallSiteIndex callSiteIndex(pc);</span>
<span class="line-removed">1898 #endif</span>
1899     ShadowChicken* shadowChicken = vm.shadowChicken();
1900     RELEASE_ASSERT(shadowChicken);
<span class="line-modified">1901     shadowChicken-&gt;log(vm, exec, ShadowChicken::Packet::tail(exec, thisValue, scope, exec-&gt;codeBlock(), callSiteIndex));</span>
1902 
1903     LLINT_END();
1904 }
1905 
1906 LLINT_SLOW_PATH_DECL(slow_path_profile_catch)
1907 {
1908     LLINT_BEGIN();
1909 
<span class="line-modified">1910     exec-&gt;codeBlock()-&gt;ensureCatchLivenessIsComputedForBytecodeOffset(exec-&gt;bytecodeOffset());</span>
1911 
1912     auto bytecode = pc-&gt;as&lt;OpCatch&gt;();
<span class="line-modified">1913     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-modified">1914     metadata.m_buffer-&gt;forEach([&amp;] (ValueProfileAndOperand&amp; profile) {</span>
<span class="line-modified">1915         profile.m_buckets[0] = JSValue::encode(exec-&gt;uncheckedR(profile.m_operand).jsValue());</span>
1916     });
1917 
1918     LLINT_END();
1919 }
1920 
1921 LLINT_SLOW_PATH_DECL(slow_path_super_sampler_begin)
1922 {
1923     // FIXME: It seems like we should be able to do this in asm but llint doesn&#39;t seem to like global variables.
1924     // See: https://bugs.webkit.org/show_bug.cgi?id=179438
<span class="line-modified">1925     UNUSED_PARAM(exec);</span>
1926     g_superSamplerCount++;
1927     LLINT_END_IMPL();
1928 }
1929 
1930 LLINT_SLOW_PATH_DECL(slow_path_super_sampler_end)
1931 {
1932     // FIXME: It seems like we should be able to do this in asm but llint doesn&#39;t seem to like global variables.
1933     // See: https://bugs.webkit.org/show_bug.cgi?id=179438
<span class="line-modified">1934     UNUSED_PARAM(exec);</span>
1935     g_superSamplerCount--;
1936     LLINT_END_IMPL();
1937 }
1938 
1939 LLINT_SLOW_PATH_DECL(slow_path_out_of_line_jump_target)
1940 {
<span class="line-modified">1941     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">1942     pc = codeBlock-&gt;outOfLineJumpTarget(pc);</span>
1943     LLINT_END_IMPL();
1944 }
1945 


















































































































1946 extern &quot;C&quot; SlowPathReturnType llint_throw_stack_overflow_error(VM* vm, ProtoCallFrame* protoFrame)
1947 {
<span class="line-modified">1948     ExecState* exec = vm-&gt;topCallFrame;</span>
1949     auto scope = DECLARE_THROW_SCOPE(*vm);
<span class="line-modified">1950 </span>
<span class="line-modified">1951     if (!exec)</span>
<span class="line-modified">1952         exec = protoFrame-&gt;callee()-&gt;globalObject(*vm)-&gt;globalExec();</span>
<span class="line-modified">1953     throwStackOverflowError(exec, scope);</span>


1954     return encodeResult(0, 0);
1955 }
1956 
1957 #if ENABLE(C_LOOP)
1958 extern &quot;C&quot; SlowPathReturnType llint_stack_check_at_vm_entry(VM* vm, Register* newTopOfStack)
1959 {
1960     bool success = vm-&gt;ensureStackCapacityFor(newTopOfStack);
1961     return encodeResult(reinterpret_cast&lt;void*&gt;(success), 0);
1962 }
1963 #endif
1964 
<span class="line-modified">1965 extern &quot;C&quot; void llint_write_barrier_slow(ExecState* exec, JSCell* cell)</span>
1966 {
<span class="line-modified">1967     VM&amp; vm = exec-&gt;vm();</span>
1968     vm.heap.writeBarrier(cell);
1969 }
1970 
1971 extern &quot;C&quot; NO_RETURN_DUE_TO_CRASH void llint_crash()
1972 {
1973     CRASH();
1974 }
1975 
1976 } } // namespace JSC::LLInt
</pre>
</td>
<td>
<hr />
<pre>
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;LLIntSlowPaths.h&quot;
  28 
  29 #include &quot;ArrayConstructor.h&quot;
<span class="line-added">  30 #include &quot;BytecodeGenerator.h&quot;</span>
  31 #include &quot;CallFrame.h&quot;
<span class="line-modified">  32 #include &quot;CheckpointOSRExitSideState.h&quot;</span>
<span class="line-added">  33 #include &quot;CommonSlowPathsInlines.h&quot;</span>
  34 #include &quot;Error.h&quot;
  35 #include &quot;ErrorHandlingScope.h&quot;
  36 #include &quot;EvalCodeBlock.h&quot;
  37 #include &quot;Exception.h&quot;
  38 #include &quot;ExceptionFuzz.h&quot;
  39 #include &quot;ExecutableBaseInlines.h&quot;
  40 #include &quot;FrameTracers.h&quot;
  41 #include &quot;FunctionCodeBlock.h&quot;
  42 #include &quot;FunctionWhitelist.h&quot;
  43 #include &quot;GetterSetter.h&quot;
  44 #include &quot;HostCallReturnValue.h&quot;
  45 #include &quot;InterpreterInlines.h&quot;
  46 #include &quot;IteratorOperations.h&quot;
  47 #include &quot;JIT.h&quot;
  48 #include &quot;JITExceptions.h&quot;
  49 #include &quot;JITWorklist.h&quot;
  50 #include &quot;JSAsyncFunction.h&quot;
  51 #include &quot;JSAsyncGeneratorFunction.h&quot;
  52 #include &quot;JSCInlines.h&quot;
  53 #include &quot;JSCJSValue.h&quot;
  54 #include &quot;JSGeneratorFunction.h&quot;
  55 #include &quot;JSGlobalObjectFunctions.h&quot;
  56 #include &quot;JSLexicalEnvironment.h&quot;
  57 #include &quot;JSString.h&quot;
  58 #include &quot;JSWithScope.h&quot;
  59 #include &quot;LLIntCommon.h&quot;
  60 #include &quot;LLIntData.h&quot;
  61 #include &quot;LLIntExceptions.h&quot;
  62 #include &quot;LLIntPrototypeLoadAdaptiveStructureWatchpoint.h&quot;
  63 #include &quot;LowLevelInterpreter.h&quot;
  64 #include &quot;ModuleProgramCodeBlock.h&quot;
  65 #include &quot;ObjectConstructor.h&quot;
  66 #include &quot;ObjectPropertyConditionSet.h&quot;
  67 #include &quot;OpcodeInlines.h&quot;
  68 #include &quot;ProgramCodeBlock.h&quot;
<span class="line-modified">  69 #include &quot;ProtoCallFrameInlines.h&quot;</span>
  70 #include &quot;RegExpObject.h&quot;
  71 #include &quot;ShadowChicken.h&quot;
  72 #include &quot;StructureRareDataInlines.h&quot;
  73 #include &quot;SuperSampler.h&quot;
  74 #include &quot;VMInlines.h&quot;
  75 #include &lt;wtf/NeverDestroyed.h&gt;
  76 #include &lt;wtf/StringPrintStream.h&gt;
  77 
  78 namespace JSC { namespace LLInt {
  79 
  80 #define LLINT_BEGIN_NO_SET_PC() \
<span class="line-modified">  81     CodeBlock* codeBlock = callFrame-&gt;codeBlock(); \</span>
<span class="line-modified">  82     JSGlobalObject* globalObject = codeBlock-&gt;globalObject(); \</span>
<span class="line-added">  83     VM&amp; vm = codeBlock-&gt;vm(); \</span>
<span class="line-added">  84     SlowPathFrameTracer tracer(vm, callFrame); \</span>
  85     auto throwScope = DECLARE_THROW_SCOPE(vm)
  86 
  87 #ifndef NDEBUG
  88 #define LLINT_SET_PC_FOR_STUBS() do { \
<span class="line-modified">  89         codeBlock-&gt;bytecodeOffset(pc); \</span>
<span class="line-modified">  90         callFrame-&gt;setCurrentVPC(pc); \</span>
  91     } while (false)
  92 #else
  93 #define LLINT_SET_PC_FOR_STUBS() do { \
<span class="line-modified">  94         callFrame-&gt;setCurrentVPC(pc); \</span>
  95     } while (false)
  96 #endif
  97 
  98 #define LLINT_BEGIN()                           \
  99     LLINT_BEGIN_NO_SET_PC();                    \
 100     LLINT_SET_PC_FOR_STUBS()
 101 
<span class="line-modified"> 102 inline JSValue getNonConstantOperand(CallFrame* callFrame, VirtualRegister operand) { return callFrame-&gt;uncheckedR(operand).jsValue(); }</span>
<span class="line-modified"> 103 inline JSValue getOperand(CallFrame* callFrame, VirtualRegister operand) { return callFrame-&gt;r(operand).jsValue(); }</span>
 104 
 105 #define LLINT_RETURN_TWO(first, second) do {       \
 106         return encodeResult(first, second);        \
 107     } while (false)
 108 
<span class="line-modified"> 109 #define LLINT_END_IMPL() LLINT_RETURN_TWO(pc, nullptr)</span>
 110 
 111 #define LLINT_THROW(exceptionToThrow) do {                        \
<span class="line-modified"> 112         throwException(globalObject, throwScope, exceptionToThrow);       \</span>
<span class="line-modified"> 113         pc = returnToThrow(vm);                                 \</span>
 114         LLINT_END_IMPL();                                         \
 115     } while (false)
 116 
 117 #define LLINT_CHECK_EXCEPTION() do {                    \
<span class="line-modified"> 118         doExceptionFuzzingIfEnabled(globalObject, throwScope, &quot;LLIntSlowPaths&quot;, pc);    \</span>
 119         if (UNLIKELY(throwScope.exception())) {         \
<span class="line-modified"> 120             pc = returnToThrow(vm);                   \</span>
 121             LLINT_END_IMPL();                           \
 122         }                                               \
 123     } while (false)
 124 
 125 #define LLINT_END() do {                        \
 126         LLINT_CHECK_EXCEPTION();                \
 127         LLINT_END_IMPL();                       \
 128     } while (false)
 129 
 130 #define JUMP_OFFSET(targetOffset) \
<span class="line-modified"> 131     ((targetOffset) ? (targetOffset) : codeBlock-&gt;outOfLineJumpOffset(pc))</span>
 132 
 133 #define JUMP_TO(target) do { \
 134         pc = reinterpret_cast&lt;const Instruction*&gt;(reinterpret_cast&lt;const uint8_t*&gt;(pc) + (target)); \
 135     } while (false)
 136 
 137 #define LLINT_BRANCH(condition) do {                  \
 138         bool __b_condition = (condition);                         \
 139         LLINT_CHECK_EXCEPTION();                                  \
 140         if (__b_condition)                                        \
 141             JUMP_TO(JUMP_OFFSET(bytecode.m_targetLabel));         \
 142         else                                                      \
 143             JUMP_TO(pc-&gt;size()); \
 144         LLINT_END_IMPL();                                         \
 145     } while (false)
 146 
 147 #define LLINT_RETURN(value) do {                \
 148         JSValue __r_returnValue = (value);      \
 149         LLINT_CHECK_EXCEPTION();                \
<span class="line-modified"> 150         callFrame-&gt;uncheckedR(bytecode.m_dst) = __r_returnValue;          \</span>
 151         LLINT_END_IMPL();                       \
 152     } while (false)
 153 
 154 #define LLINT_RETURN_PROFILED(value) do {               \
 155         JSValue __rp_returnValue = (value);                     \
 156         LLINT_CHECK_EXCEPTION();                                \
<span class="line-modified"> 157         callFrame-&gt;uncheckedR(bytecode.m_dst) = __rp_returnValue;                         \</span>
 158         LLINT_PROFILE_VALUE(__rp_returnValue);          \
 159         LLINT_END_IMPL();                                       \
 160     } while (false)
 161 
 162 #define LLINT_PROFILE_VALUE(value) do { \
<span class="line-modified"> 163         bytecode.metadata(codeBlock).m_profile.m_buckets[0] = JSValue::encode(value); \</span>
 164     } while (false)
 165 
<span class="line-modified"> 166 #define LLINT_CALL_END_IMPL(callFrame, callTarget, callTargetTag) \</span>
<span class="line-modified"> 167     LLINT_RETURN_TWO(retagCodePtr((callTarget), callTargetTag, SlowPathPtrTag), (callFrame))</span>
 168 
<span class="line-modified"> 169 #define LLINT_CALL_THROW(globalObject, exceptionToThrow) do {                   \</span>
<span class="line-modified"> 170         JSGlobalObject* __ct_globalObject = (globalObject);                                  \</span>
<span class="line-modified"> 171         throwException(__ct_globalObject, throwScope, exceptionToThrow);        \</span>
<span class="line-modified"> 172         LLINT_CALL_END_IMPL(nullptr, callToThrow(vm), ExceptionHandlerPtrTag);                 \</span>
 173     } while (false)
 174 
<span class="line-modified"> 175 #define LLINT_CALL_CHECK_EXCEPTION(globalObject) do {               \</span>
<span class="line-modified"> 176         JSGlobalObject* __cce_globalObject = (globalObject);                                 \</span>
<span class="line-modified"> 177         doExceptionFuzzingIfEnabled(__cce_globalObject, throwScope, &quot;LLIntSlowPaths/call&quot;, nullptr); \</span>

 178         if (UNLIKELY(throwScope.exception()))                           \
<span class="line-modified"> 179             LLINT_CALL_END_IMPL(nullptr, callToThrow(vm), ExceptionHandlerPtrTag); \</span>
 180     } while (false)
 181 
<span class="line-modified"> 182 #define LLINT_CALL_RETURN(globalObject, calleeFrame, callTarget, callTargetTag) do { \</span>
<span class="line-modified"> 183         JSGlobalObject* __cr_globalObject = (globalObject); \</span>
<span class="line-modified"> 184         CallFrame* __cr_calleeFrame = (calleeFrame); \</span>
<span class="line-modified"> 185         void* __cr_callTarget = (callTarget); \</span>
<span class="line-modified"> 186         LLINT_CALL_CHECK_EXCEPTION(__cr_globalObject);         \</span>
<span class="line-modified"> 187         LLINT_CALL_END_IMPL(__cr_calleeFrame, __cr_callTarget, callTargetTag); \</span>
 188     } while (false)
 189 
<span class="line-modified"> 190 #define LLINT_RETURN_CALLEE_FRAME(calleeFrame) do { \</span>
<span class="line-modified"> 191         CallFrame* __rcf_calleeFrame = (calleeFrame); \</span>
<span class="line-modified"> 192         LLINT_RETURN_TWO(pc, __rcf_calleeFrame); \</span>
 193     } while (false)
 194 
 195 #if LLINT_TRACING
 196 
 197 template&lt;typename... Types&gt;
 198 void slowPathLog(const Types&amp;... values)
 199 {
 200     dataLogIf(Options::traceLLIntSlowPath(), values...);
 201 }
 202 
 203 template&lt;typename... Types&gt;
 204 void slowPathLn(const Types&amp;... values)
 205 {
 206     dataLogLnIf(Options::traceLLIntSlowPath(), values...);
 207 }
 208 
 209 template&lt;typename... Types&gt;
 210 void slowPathLogF(const char* format, const Types&amp;... values)
 211 {
 212     ALLOW_NONLITERAL_FORMAT_BEGIN
 213     IGNORE_WARNINGS_BEGIN(&quot;format-security&quot;)
 214     if (Options::traceLLIntSlowPath())
 215         dataLogF(format, values...);
 216     IGNORE_WARNINGS_END
 217     ALLOW_NONLITERAL_FORMAT_END
 218 }
 219 
 220 #else // not LLINT_TRACING
 221 
 222 template&lt;typename... Types&gt; void slowPathLog(const Types&amp;...) { }
 223 template&lt;typename... Types&gt; void slowPathLogLn(const Types&amp;...) { }
 224 template&lt;typename... Types&gt; void slowPathLogF(const char*, const Types&amp;...) { }
 225 
 226 #endif // LLINT_TRACING
 227 
<span class="line-modified"> 228 extern &quot;C&quot; SlowPathReturnType llint_trace_operand(CallFrame* callFrame, const Instruction* pc, int fromWhere, int operand)</span>
 229 {
 230     if (!Options::traceLLIntExecution())
 231         LLINT_END_IMPL();
 232 
 233     LLINT_BEGIN();
 234     dataLogF(
 235         &quot;&lt;%p&gt; %p / %p: executing bc#%zu, op#%u: Trace(%d): %d\n&quot;,
 236         &amp;Thread::current(),
<span class="line-modified"> 237         callFrame-&gt;codeBlock(),</span>
<span class="line-modified"> 238         globalObject,</span>
<span class="line-modified"> 239         static_cast&lt;intptr_t&gt;(callFrame-&gt;codeBlock()-&gt;bytecodeOffset(pc)),</span>
 240         pc-&gt;opcodeID(),
 241         fromWhere,
 242         operand);
 243     LLINT_END();
 244 }
 245 
<span class="line-modified"> 246 extern &quot;C&quot; SlowPathReturnType llint_trace_value(CallFrame* callFrame, const Instruction* pc, int fromWhere, VirtualRegister operand)</span>
 247 {
 248     if (!Options::traceLLIntExecution())
 249         LLINT_END_IMPL();
 250 
<span class="line-modified"> 251     JSValue value = getOperand(callFrame, operand);</span>
 252     union {
 253         struct {
 254             uint32_t tag;
 255             uint32_t payload;
 256         } bits;
 257         EncodedJSValue asValue;
 258     } u;
 259     u.asValue = JSValue::encode(value);
 260     dataLogF(
 261         &quot;&lt;%p&gt; %p / %p: executing bc#%zu, op#%u: Trace(%d): %d: %08x:%08x: %s\n&quot;,
 262         &amp;Thread::current(),
<span class="line-modified"> 263         callFrame-&gt;codeBlock(),</span>
<span class="line-modified"> 264         callFrame,</span>
<span class="line-modified"> 265         static_cast&lt;intptr_t&gt;(callFrame-&gt;codeBlock()-&gt;bytecodeOffset(pc)),</span>
 266         pc-&gt;opcodeID(),
 267         fromWhere,
 268         operand.offset(),
 269         u.bits.tag,
 270         u.bits.payload,
 271         toCString(value).data());
 272     LLINT_END_IMPL();
 273 }
 274 
 275 LLINT_SLOW_PATH_DECL(trace_prologue)
 276 {
 277     if (!Options::traceLLIntExecution())
 278         LLINT_END_IMPL();
 279 
<span class="line-modified"> 280     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
<span class="line-modified"> 281     dataLogF(&quot;&lt;%p&gt; %p / %p: in prologue of &quot;, &amp;Thread::current(), codeBlock, callFrame);</span>
<span class="line-added"> 282     dataLog(codeBlock, &quot;\n&quot;);</span>
 283     LLINT_END_IMPL();
 284 }
 285 
<span class="line-modified"> 286 static void traceFunctionPrologue(CallFrame* callFrame, const char* comment, CodeSpecializationKind kind)</span>
 287 {
 288     if (!Options::traceLLIntExecution())
 289         return;
 290 
<span class="line-modified"> 291     JSFunction* callee = jsCast&lt;JSFunction*&gt;(callFrame-&gt;jsCallee());</span>
 292     FunctionExecutable* executable = callee-&gt;jsExecutable();
 293     CodeBlock* codeBlock = executable-&gt;codeBlockFor(kind);
<span class="line-modified"> 294     dataLogF(&quot;&lt;%p&gt; %p / %p: in %s of &quot;, &amp;Thread::current(), codeBlock, callFrame, comment);</span>
 295     dataLog(codeBlock);
 296     dataLogF(&quot; function %p, executable %p; numVars = %u, numParameters = %u, numCalleeLocals = %u, caller = %p.\n&quot;,
<span class="line-modified"> 297         callee, executable, codeBlock-&gt;numVars(), codeBlock-&gt;numParameters(), codeBlock-&gt;numCalleeLocals(), callFrame-&gt;callerFrame());</span>
 298 }
 299 
 300 LLINT_SLOW_PATH_DECL(trace_prologue_function_for_call)
 301 {
<span class="line-modified"> 302     traceFunctionPrologue(callFrame, &quot;call prologue&quot;, CodeForCall);</span>
 303     LLINT_END_IMPL();
 304 }
 305 
 306 LLINT_SLOW_PATH_DECL(trace_prologue_function_for_construct)
 307 {
<span class="line-modified"> 308     traceFunctionPrologue(callFrame, &quot;construct prologue&quot;, CodeForConstruct);</span>
 309     LLINT_END_IMPL();
 310 }
 311 
 312 LLINT_SLOW_PATH_DECL(trace_arityCheck_for_call)
 313 {
<span class="line-modified"> 314     traceFunctionPrologue(callFrame, &quot;call arity check&quot;, CodeForCall);</span>
 315     LLINT_END_IMPL();
 316 }
 317 
 318 LLINT_SLOW_PATH_DECL(trace_arityCheck_for_construct)
 319 {
<span class="line-modified"> 320     traceFunctionPrologue(callFrame, &quot;construct arity check&quot;, CodeForConstruct);</span>
 321     LLINT_END_IMPL();
 322 }
 323 
 324 LLINT_SLOW_PATH_DECL(trace)
 325 {
 326     if (!Options::traceLLIntExecution())
 327         LLINT_END_IMPL();
 328 
<span class="line-added"> 329     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
 330     OpcodeID opcodeID = pc-&gt;opcodeID();
 331     dataLogF(&quot;&lt;%p&gt; %p / %p: executing bc#%zu, %s, pc = %p\n&quot;,
 332             &amp;Thread::current(),
<span class="line-modified"> 333             codeBlock,</span>
<span class="line-modified"> 334             callFrame,</span>
<span class="line-modified"> 335             static_cast&lt;intptr_t&gt;(codeBlock-&gt;bytecodeOffset(pc)),</span>
 336             pc-&gt;name(),
 337             pc);
 338     if (opcodeID == op_enter) {
<span class="line-modified"> 339         dataLogF(&quot;Frame will eventually return to %p\n&quot;, callFrame-&gt;returnPC().value());</span>
<span class="line-modified"> 340         *removeCodePtrTag&lt;volatile char*&gt;(callFrame-&gt;returnPC().value());</span>
 341     }
 342     if (opcodeID == op_ret) {
<span class="line-modified"> 343         dataLogF(&quot;Will be returning to %p\n&quot;, callFrame-&gt;returnPC().value());</span>
<span class="line-modified"> 344         dataLogF(&quot;The new cfr will be %p\n&quot;, callFrame-&gt;callerFrame());</span>
 345     }
 346     LLINT_END_IMPL();
 347 }
 348 
 349 enum EntryKind { Prologue, ArityCheck };
 350 
 351 #if ENABLE(JIT)
 352 static FunctionWhitelist&amp; ensureGlobalJITWhitelist()
 353 {
 354     static LazyNeverDestroyed&lt;FunctionWhitelist&gt; baselineWhitelist;
 355     static std::once_flag initializeWhitelistFlag;
 356     std::call_once(initializeWhitelistFlag, [] {
 357         const char* functionWhitelistFile = Options::jitWhitelist();
 358         baselineWhitelist.construct(functionWhitelistFile);
 359     });
 360     return baselineWhitelist;
 361 }
 362 
 363 inline bool shouldJIT(CodeBlock* codeBlock)
 364 {
 365     if (!Options::bytecodeRangeToJITCompile().isInRange(codeBlock-&gt;instructionsSize())
 366         || !ensureGlobalJITWhitelist().contains(codeBlock))
 367         return false;
 368 
 369     return VM::canUseJIT() &amp;&amp; Options::useBaselineJIT();
 370 }
 371 
 372 // Returns true if we should try to OSR.
<span class="line-modified"> 373 inline bool jitCompileAndSetHeuristics(VM&amp; vm, CodeBlock* codeBlock, BytecodeIndex loopOSREntryBytecodeIndex = BytecodeIndex(0))</span>
 374 {

 375     DeferGCForAWhile deferGC(vm.heap); // My callers don&#39;t set top callframe, so we don&#39;t want to GC here at all.
 376     ASSERT(VM::canUseJIT());
 377 
 378     codeBlock-&gt;updateAllValueProfilePredictions();
 379 
 380     if (!codeBlock-&gt;checkIfJITThresholdReached()) {
 381         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayJITCompile&quot;, (&quot;threshold not reached, counter = &quot;, codeBlock-&gt;llintExecuteCounter()));
<span class="line-modified"> 382         dataLogLnIf(Options::verboseOSR(), &quot;    JIT threshold should be lifted.&quot;);</span>

 383         return false;
 384     }
 385 
 386     JITWorklist::ensureGlobalWorklist().poll(vm);
 387 
 388     switch (codeBlock-&gt;jitType()) {
 389     case JITType::BaselineJIT: {
<span class="line-modified"> 390         dataLogLnIf(Options::verboseOSR(), &quot;    Code was already compiled.&quot;);</span>

 391         codeBlock-&gt;jitSoon();
 392         return true;
 393     }
 394     case JITType::InterpreterThunk: {
<span class="line-modified"> 395         JITWorklist::ensureGlobalWorklist().compileLater(codeBlock, loopOSREntryBytecodeIndex);</span>
 396         return codeBlock-&gt;jitType() == JITType::BaselineJIT;
 397     }
 398     default:
 399         dataLog(&quot;Unexpected code block in LLInt: &quot;, *codeBlock, &quot;\n&quot;);
 400         RELEASE_ASSERT_NOT_REACHED();
 401         return false;
 402     }
 403 }
 404 
<span class="line-modified"> 405 static SlowPathReturnType entryOSR(CodeBlock* codeBlock, const char *name, EntryKind kind)</span>
 406 {
<span class="line-modified"> 407     dataLogLnIf(Options::verboseOSR(),</span>
<span class="line-modified"> 408         *codeBlock, &quot;: Entered &quot;, name, &quot; with executeCounter = &quot;,</span>
<span class="line-modified"> 409         codeBlock-&gt;llintExecuteCounter());</span>


 410 
 411     if (!shouldJIT(codeBlock)) {
 412         codeBlock-&gt;dontJITAnytimeSoon();
<span class="line-modified"> 413         LLINT_RETURN_TWO(nullptr, nullptr);</span>
 414     }
<span class="line-modified"> 415     VM&amp; vm = codeBlock-&gt;vm();</span>
<span class="line-modified"> 416     if (!jitCompileAndSetHeuristics(vm, codeBlock))</span>
<span class="line-added"> 417         LLINT_RETURN_TWO(nullptr, nullptr);</span>
 418 
 419     CODEBLOCK_LOG_EVENT(codeBlock, &quot;OSR entry&quot;, (&quot;in prologue&quot;));
 420 
 421     if (kind == Prologue)
<span class="line-modified"> 422         LLINT_RETURN_TWO(codeBlock-&gt;jitCode()-&gt;executableAddress(), nullptr);</span>
 423     ASSERT(kind == ArityCheck);
<span class="line-modified"> 424     LLINT_RETURN_TWO(codeBlock-&gt;jitCode()-&gt;addressForCall(MustCheckArity).executableAddress(), nullptr);</span>
 425 }
 426 #else // ENABLE(JIT)
<span class="line-modified"> 427 static SlowPathReturnType entryOSR(CodeBlock* codeBlock, const char*, EntryKind)</span>
 428 {
 429     codeBlock-&gt;dontJITAnytimeSoon();
<span class="line-modified"> 430     LLINT_RETURN_TWO(nullptr, nullptr);</span>
 431 }
 432 #endif // ENABLE(JIT)
 433 
 434 LLINT_SLOW_PATH_DECL(entry_osr)
 435 {
<span class="line-modified"> 436     UNUSED_PARAM(pc);</span>
<span class="line-added"> 437     return entryOSR(callFrame-&gt;codeBlock(), &quot;entry_osr&quot;, Prologue);</span>
 438 }
 439 
 440 LLINT_SLOW_PATH_DECL(entry_osr_function_for_call)
 441 {
<span class="line-modified"> 442     UNUSED_PARAM(pc);</span>
<span class="line-added"> 443     return entryOSR(jsCast&lt;JSFunction*&gt;(callFrame-&gt;jsCallee())-&gt;jsExecutable()-&gt;codeBlockForCall(), &quot;entry_osr_function_for_call&quot;, Prologue);</span>
 444 }
 445 
 446 LLINT_SLOW_PATH_DECL(entry_osr_function_for_construct)
 447 {
<span class="line-modified"> 448     UNUSED_PARAM(pc);</span>
<span class="line-added"> 449     return entryOSR(jsCast&lt;JSFunction*&gt;(callFrame-&gt;jsCallee())-&gt;jsExecutable()-&gt;codeBlockForConstruct(), &quot;entry_osr_function_for_construct&quot;, Prologue);</span>
 450 }
 451 
 452 LLINT_SLOW_PATH_DECL(entry_osr_function_for_call_arityCheck)
 453 {
<span class="line-modified"> 454     UNUSED_PARAM(pc);</span>
<span class="line-added"> 455     return entryOSR(jsCast&lt;JSFunction*&gt;(callFrame-&gt;jsCallee())-&gt;jsExecutable()-&gt;codeBlockForCall(), &quot;entry_osr_function_for_call_arityCheck&quot;, ArityCheck);</span>
 456 }
 457 
 458 LLINT_SLOW_PATH_DECL(entry_osr_function_for_construct_arityCheck)
 459 {
<span class="line-modified"> 460     UNUSED_PARAM(pc);</span>
<span class="line-added"> 461     return entryOSR(jsCast&lt;JSFunction*&gt;(callFrame-&gt;jsCallee())-&gt;jsExecutable()-&gt;codeBlockForConstruct(), &quot;entry_osr_function_for_construct_arityCheck&quot;, ArityCheck);</span>
 462 }
 463 
 464 LLINT_SLOW_PATH_DECL(loop_osr)
 465 {
 466     LLINT_BEGIN_NO_SET_PC();
 467     UNUSED_PARAM(throwScope);
<span class="line-modified"> 468     UNUSED_PARAM(globalObject);</span>
 469 
 470 #if ENABLE(JIT)
<span class="line-modified"> 471     dataLogLnIf(Options::verboseOSR(),</span>

 472             *codeBlock, &quot;: Entered loop_osr with executeCounter = &quot;,
<span class="line-modified"> 473             codeBlock-&gt;llintExecuteCounter());</span>

 474 
<span class="line-modified"> 475     auto loopOSREntryBytecodeIndex = BytecodeIndex(codeBlock-&gt;bytecodeOffset(pc));</span>
 476 
 477     if (!shouldJIT(codeBlock)) {
 478         codeBlock-&gt;dontJITAnytimeSoon();
 479         LLINT_RETURN_TWO(0, 0);
 480     }
 481 
<span class="line-modified"> 482     if (!jitCompileAndSetHeuristics(vm, codeBlock, loopOSREntryBytecodeIndex))</span>
 483         LLINT_RETURN_TWO(0, 0);
 484 
<span class="line-modified"> 485     CODEBLOCK_LOG_EVENT(codeBlock, &quot;osrEntry&quot;, (&quot;at &quot;, loopOSREntryBytecodeIndex));</span>
 486 
 487     ASSERT(codeBlock-&gt;jitType() == JITType::BaselineJIT);
 488 
 489     const JITCodeMap&amp; codeMap = codeBlock-&gt;jitCodeMap();
<span class="line-modified"> 490     CodeLocationLabel&lt;JSEntryPtrTag&gt; codeLocation = codeMap.find(loopOSREntryBytecodeIndex);</span>
 491     ASSERT(codeLocation);
 492 
 493     void* jumpTarget = codeLocation.executableAddress();
 494     ASSERT(jumpTarget);
 495 
<span class="line-modified"> 496     LLINT_RETURN_TWO(jumpTarget, callFrame-&gt;topOfFrame());</span>
 497 #else // ENABLE(JIT)
 498     UNUSED_PARAM(pc);
 499     codeBlock-&gt;dontJITAnytimeSoon();
 500     LLINT_RETURN_TWO(0, 0);
 501 #endif // ENABLE(JIT)
 502 }
 503 
 504 LLINT_SLOW_PATH_DECL(replace)
 505 {
 506     LLINT_BEGIN_NO_SET_PC();
 507     UNUSED_PARAM(throwScope);
<span class="line-modified"> 508     UNUSED_PARAM(globalObject);</span>
 509 
 510 #if ENABLE(JIT)
<span class="line-modified"> 511     dataLogLnIf(Options::verboseOSR(),</span>
<span class="line-modified"> 512         *codeBlock, &quot;: Entered replace with executeCounter = &quot;,</span>
<span class="line-modified"> 513         codeBlock-&gt;llintExecuteCounter());</span>


 514 
 515     if (shouldJIT(codeBlock))
<span class="line-modified"> 516         jitCompileAndSetHeuristics(vm, codeBlock);</span>
 517     else
 518         codeBlock-&gt;dontJITAnytimeSoon();
 519     LLINT_END_IMPL();
 520 #else // ENABLE(JIT)
 521     codeBlock-&gt;dontJITAnytimeSoon();
 522     LLINT_END_IMPL();
 523 #endif // ENABLE(JIT)
 524 }
 525 
 526 LLINT_SLOW_PATH_DECL(stack_check)
 527 {
<span class="line-modified"> 528     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
<span class="line-added"> 529     JSGlobalObject* globalObject = codeBlock-&gt;globalObject();</span>
<span class="line-added"> 530     VM&amp; vm = codeBlock-&gt;vm();</span>
 531     auto throwScope = DECLARE_THROW_SCOPE(vm);
 532 
<span class="line-modified"> 533     // It&#39;s ok to create the SlowPathFrameTracer here before we</span>
 534     // convertToStackOverflowFrame() because this function is always called
 535     // after the frame has been propulated with a proper CodeBlock and callee.
<span class="line-modified"> 536     SlowPathFrameTracer tracer(vm, callFrame);</span>
 537 
 538     LLINT_SET_PC_FOR_STUBS();
 539 
<span class="line-modified"> 540     slowPathLogF(&quot;Checking stack height with callFrame = %p.\n&quot;, callFrame);</span>

 541     slowPathLog(&quot;CodeBlock = &quot;, codeBlock, &quot;\n&quot;);
 542     if (codeBlock) {
 543         slowPathLogF(&quot;Num callee registers = %u.\n&quot;, codeBlock-&gt;numCalleeLocals());
 544         slowPathLogF(&quot;Num vars = %u.\n&quot;, codeBlock-&gt;numVars());
 545     }
 546     slowPathLogF(&quot;Current OS stack end is at %p.\n&quot;, vm.softStackLimit());
 547 #if ENABLE(C_LOOP)
 548     slowPathLogF(&quot;Current C Loop stack end is at %p.\n&quot;, vm.cloopStackLimit());
 549 #endif
 550 
 551     // If the stack check succeeds and we don&#39;t need to throw the error, then
 552     // we&#39;ll return 0 instead. The prologue will check for a non-zero value
 553     // when determining whether to set the callFrame or not.
 554 
 555     // For JIT enabled builds which uses the C stack, the stack is not growable.
 556     // Hence, if we get here, then we know a stack overflow is imminent. So, just
 557     // throw the StackOverflowError unconditionally.
 558 #if ENABLE(C_LOOP)
<span class="line-modified"> 559     Register* topOfFrame = callFrame-&gt;topOfFrame();</span>
<span class="line-modified"> 560     if (LIKELY(topOfFrame &lt; reinterpret_cast&lt;Register*&gt;(callFrame))) {</span>
 561         ASSERT(!vm.interpreter-&gt;cloopStack().containsAddress(topOfFrame));
 562         if (LIKELY(vm.ensureStackCapacityFor(topOfFrame)))
 563             LLINT_RETURN_TWO(pc, 0);
 564     }
 565 #endif
 566 
<span class="line-modified"> 567     callFrame-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
 568     ErrorHandlingScope errorScope(vm);
<span class="line-modified"> 569     throwStackOverflowError(globalObject, throwScope);</span>
<span class="line-modified"> 570     pc = returnToThrow(vm);</span>
<span class="line-modified"> 571     LLINT_RETURN_TWO(pc, callFrame);</span>
 572 }
 573 
 574 LLINT_SLOW_PATH_DECL(slow_path_new_object)
 575 {
 576     LLINT_BEGIN();
 577     auto bytecode = pc-&gt;as&lt;OpNewObject&gt;();
<span class="line-modified"> 578     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
<span class="line-modified"> 579     LLINT_RETURN(constructEmptyObject(vm, metadata.m_objectAllocationProfile.structure()));</span>
 580 }
 581 
 582 LLINT_SLOW_PATH_DECL(slow_path_new_array)
 583 {
 584     LLINT_BEGIN();
 585     auto bytecode = pc-&gt;as&lt;OpNewArray&gt;();
<span class="line-modified"> 586     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
<span class="line-modified"> 587     LLINT_RETURN(constructArrayNegativeIndexed(globalObject, &amp;metadata.m_arrayAllocationProfile, bitwise_cast&lt;JSValue*&gt;(&amp;callFrame-&gt;uncheckedR(bytecode.m_argv)), bytecode.m_argc));</span>
 588 }
 589 
 590 LLINT_SLOW_PATH_DECL(slow_path_new_array_with_size)
 591 {
 592     LLINT_BEGIN();
 593     auto bytecode = pc-&gt;as&lt;OpNewArrayWithSize&gt;();
<span class="line-modified"> 594     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
<span class="line-modified"> 595     LLINT_RETURN(constructArrayWithSizeQuirk(globalObject, &amp;metadata.m_arrayAllocationProfile, getOperand(callFrame, bytecode.m_length)));</span>
 596 }
 597 
 598 LLINT_SLOW_PATH_DECL(slow_path_new_regexp)
 599 {
 600     LLINT_BEGIN();
 601     auto bytecode = pc-&gt;as&lt;OpNewRegexp&gt;();
<span class="line-modified"> 602     RegExp* regExp = jsCast&lt;RegExp*&gt;(getOperand(callFrame, bytecode.m_regexp));</span>
 603     ASSERT(regExp-&gt;isValid());
<span class="line-modified"> 604     LLINT_RETURN(RegExpObject::create(vm, globalObject-&gt;regExpStructure(), regExp));</span>
 605 }
 606 
 607 LLINT_SLOW_PATH_DECL(slow_path_instanceof)
 608 {
 609     LLINT_BEGIN();
 610     auto bytecode = pc-&gt;as&lt;OpInstanceof&gt;();
<span class="line-modified"> 611     JSValue value = getOperand(callFrame, bytecode.m_value);</span>
<span class="line-modified"> 612     JSValue proto = getOperand(callFrame, bytecode.m_prototype);</span>
<span class="line-modified"> 613     LLINT_RETURN(jsBoolean(JSObject::defaultHasInstance(globalObject, value, proto)));</span>
 614 }
 615 
 616 LLINT_SLOW_PATH_DECL(slow_path_instanceof_custom)
 617 {
 618     LLINT_BEGIN();
 619 
 620     auto bytecode = pc-&gt;as&lt;OpInstanceofCustom&gt;();
<span class="line-modified"> 621     JSValue value = getOperand(callFrame, bytecode.m_value);</span>
<span class="line-modified"> 622     JSValue constructor = getOperand(callFrame, bytecode.m_constructor);</span>
<span class="line-modified"> 623     JSValue hasInstanceValue = getOperand(callFrame, bytecode.m_hasInstanceValue);</span>
 624 
 625     ASSERT(constructor.isObject());
<span class="line-modified"> 626     ASSERT(hasInstanceValue != globalObject-&gt;functionProtoHasInstanceSymbolFunction() || !constructor.getObject()-&gt;structure(vm)-&gt;typeInfo().implementsDefaultHasInstance());</span>
 627 
<span class="line-modified"> 628     JSValue result = jsBoolean(constructor.getObject()-&gt;hasInstance(globalObject, value, hasInstanceValue));</span>
 629     LLINT_RETURN(result);
 630 }
 631 
 632 LLINT_SLOW_PATH_DECL(slow_path_try_get_by_id)
 633 {
 634     LLINT_BEGIN();
 635     auto bytecode = pc-&gt;as&lt;OpTryGetById&gt;();

 636     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
<span class="line-modified"> 637     JSValue baseValue = getOperand(callFrame, bytecode.m_base);</span>
 638     PropertySlot slot(baseValue, PropertySlot::PropertySlot::InternalMethodType::VMInquiry);
 639 
<span class="line-modified"> 640     baseValue.getPropertySlot(globalObject, ident, slot);</span>
 641     JSValue result = slot.getPureResult();
 642 
 643     LLINT_RETURN_PROFILED(result);
 644 }
 645 
 646 LLINT_SLOW_PATH_DECL(slow_path_get_by_id_direct)
 647 {
 648     LLINT_BEGIN();
 649     auto bytecode = pc-&gt;as&lt;OpGetByIdDirect&gt;();

 650     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
<span class="line-modified"> 651     JSValue baseValue = getOperand(callFrame, bytecode.m_base);</span>
 652     PropertySlot slot(baseValue, PropertySlot::PropertySlot::InternalMethodType::GetOwnProperty);
 653 
<span class="line-modified"> 654     bool found = baseValue.getOwnPropertySlot(globalObject, ident, slot);</span>
 655     LLINT_CHECK_EXCEPTION();
<span class="line-modified"> 656     JSValue result = found ? slot.getValue(globalObject, ident) : jsUndefined();</span>
 657     LLINT_CHECK_EXCEPTION();
 658 
<span class="line-modified"> 659     if (!LLINT_ALWAYS_ACCESS_SLOW &amp;&amp; slot.isCacheable() &amp;&amp; !slot.isUnset()) {</span>
<span class="line-modified"> 660         auto&amp; metadata = bytecode.metadata(codeBlock);</span>
 661         {
 662             StructureID oldStructureID = metadata.m_structureID;
 663             if (oldStructureID) {
 664                 Structure* a = vm.heap.structureIDTable().get(oldStructureID);
 665                 Structure* b = baseValue.asCell()-&gt;structure(vm);
 666 
 667                 if (Structure::shouldConvertToPolyProto(a, b)) {
 668                     ASSERT(a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint().get() == b-&gt;rareData()-&gt;sharedPolyProtoWatchpoint().get());
 669                     a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint()-&gt;invalidate(vm, StringFireDetail(&quot;Detected poly proto opportunity.&quot;));
 670                 }
 671             }
 672         }
 673 
 674         JSCell* baseCell = baseValue.asCell();
 675         Structure* structure = baseCell-&gt;structure(vm);
 676         if (slot.isValue()) {
 677             // Start out by clearing out the old cache.
 678             metadata.m_structureID = 0;
 679             metadata.m_offset = 0;
 680 
 681             if (structure-&gt;propertyAccessesAreCacheable() &amp;&amp; !structure-&gt;needImpurePropertyWatchpoint()) {
 682                 {
 683                     ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 684                     metadata.m_structureID = structure-&gt;id();
 685                     metadata.m_offset = slot.cachedOffset();
 686                 }
 687                 vm.heap.writeBarrier(codeBlock);
 688             }
 689         }
 690     }
 691 
 692     LLINT_RETURN_PROFILED(result);
 693 }
 694 
 695 
<span class="line-modified"> 696 static void setupGetByIdPrototypeCache(JSGlobalObject* globalObject, VM&amp; vm, CodeBlock* codeBlock, const Instruction* pc, OpGetById::Metadata&amp; metadata, JSCell* baseCell, PropertySlot&amp; slot, const Identifier&amp; ident)</span>
 697 {

 698     Structure* structure = baseCell-&gt;structure(vm);
 699 
 700     if (structure-&gt;typeInfo().prohibitsPropertyCaching())
 701         return;
 702 
 703     if (structure-&gt;needImpurePropertyWatchpoint())
 704         return;
 705 
 706     if (structure-&gt;isDictionary()) {
 707         if (structure-&gt;hasBeenFlattenedBefore())
 708             return;
 709         structure-&gt;flattenDictionaryStructure(vm, jsCast&lt;JSObject*&gt;(baseCell));
 710     }
 711 
<span class="line-added"> 712     prepareChainForCaching(globalObject, baseCell, slot);</span>
<span class="line-added"> 713 </span>
 714     ObjectPropertyConditionSet conditions;
 715     if (slot.isUnset())
<span class="line-modified"> 716         conditions = generateConditionsForPropertyMiss(vm, codeBlock, globalObject, structure, ident.impl());</span>
 717     else
<span class="line-modified"> 718         conditions = generateConditionsForPrototypePropertyHit(vm, codeBlock, globalObject, structure, slot.slotBase(), ident.impl());</span>
 719 
 720     if (!conditions.isValid())
 721         return;
 722 
 723     unsigned bytecodeOffset = codeBlock-&gt;bytecodeOffset(pc);
 724     PropertyOffset offset = invalidOffset;
 725     CodeBlock::StructureWatchpointMap&amp; watchpointMap = codeBlock-&gt;llintGetByIdWatchpointMap();
 726     Vector&lt;LLIntPrototypeLoadAdaptiveStructureWatchpoint&gt; watchpoints;
 727     watchpoints.reserveInitialCapacity(conditions.size());
 728     for (ObjectPropertyCondition condition : conditions) {
 729         if (!condition.isWatchable())
 730             return;
 731         if (condition.condition().kind() == PropertyCondition::Presence)
 732             offset = condition.condition().offset();
 733         watchpoints.uncheckedConstructAndAppend(codeBlock, condition, bytecodeOffset);
 734         watchpoints.last().install(vm);
 735     }
 736 
 737     ASSERT((offset == invalidOffset) == slot.isUnset());
 738     auto result = watchpointMap.add(std::make_tuple(structure-&gt;id(), bytecodeOffset), WTFMove(watchpoints));
 739     ASSERT_UNUSED(result, result.isNewEntry);
 740 
 741     {
 742         ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 743         if (slot.isUnset())
 744             metadata.m_modeMetadata.setUnsetMode(structure);
 745         else {
 746             ASSERT(slot.isValue());
 747             metadata.m_modeMetadata.setProtoLoadMode(structure, offset, slot.slotBase());
 748         }
 749     }
 750     vm.heap.writeBarrier(codeBlock);
 751 }
 752 
 753 
 754 LLINT_SLOW_PATH_DECL(slow_path_get_by_id)
 755 {
 756     LLINT_BEGIN();
 757     auto bytecode = pc-&gt;as&lt;OpGetById&gt;();
<span class="line-modified"> 758     auto&amp; metadata = bytecode.metadata(codeBlock);</span>

 759     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
<span class="line-modified"> 760     JSValue baseValue = getOperand(callFrame, bytecode.m_base);</span>
 761     PropertySlot slot(baseValue, PropertySlot::PropertySlot::InternalMethodType::Get);
 762 
<span class="line-modified"> 763     JSValue result = baseValue.get(globalObject, ident, slot);</span>
 764     LLINT_CHECK_EXCEPTION();
<span class="line-modified"> 765     callFrame-&gt;uncheckedR(bytecode.m_dst) = result;</span>
 766 
 767     if (!LLINT_ALWAYS_ACCESS_SLOW
 768         &amp;&amp; baseValue.isCell()
<span class="line-modified"> 769         &amp;&amp; slot.isCacheable()</span>
<span class="line-added"> 770         &amp;&amp; !slot.isUnset()) {</span>
 771         {
 772             StructureID oldStructureID;
 773             switch (metadata.m_modeMetadata.mode) {
 774             case GetByIdMode::Default:
 775                 oldStructureID = metadata.m_modeMetadata.defaultMode.structureID;
 776                 break;
 777             case GetByIdMode::Unset:
 778                 oldStructureID = metadata.m_modeMetadata.unsetMode.structureID;
 779                 break;
 780             case GetByIdMode::ProtoLoad:
 781                 oldStructureID = metadata.m_modeMetadata.protoLoadMode.structureID;
 782                 break;
 783             default:
 784                 oldStructureID = 0;
 785             }
 786             if (oldStructureID) {
 787                 Structure* a = vm.heap.structureIDTable().get(oldStructureID);
 788                 Structure* b = baseValue.asCell()-&gt;structure(vm);
 789 
 790                 if (Structure::shouldConvertToPolyProto(a, b)) {
</pre>
<hr />
<pre>
 792                     a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint()-&gt;invalidate(vm, StringFireDetail(&quot;Detected poly proto opportunity.&quot;));
 793                 }
 794             }
 795         }
 796 
 797         JSCell* baseCell = baseValue.asCell();
 798         Structure* structure = baseCell-&gt;structure(vm);
 799         if (slot.isValue() &amp;&amp; slot.slotBase() == baseValue) {
 800             ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 801             // Start out by clearing out the old cache.
 802             metadata.m_modeMetadata.clearToDefaultModeWithoutCache();
 803 
 804             // Prevent the prototype cache from ever happening.
 805             metadata.m_modeMetadata.hitCountForLLIntCaching = 0;
 806 
 807             if (structure-&gt;propertyAccessesAreCacheable() &amp;&amp; !structure-&gt;needImpurePropertyWatchpoint()) {
 808                 metadata.m_modeMetadata.defaultMode.structureID = structure-&gt;id();
 809                 metadata.m_modeMetadata.defaultMode.cachedOffset = slot.cachedOffset();
 810                 vm.heap.writeBarrier(codeBlock);
 811             }
<span class="line-modified"> 812         } else if (UNLIKELY(metadata.m_modeMetadata.hitCountForLLIntCaching &amp;&amp; slot.isValue())) {</span>
 813             ASSERT(slot.slotBase() != baseValue);
 814 
 815             if (!(--metadata.m_modeMetadata.hitCountForLLIntCaching))
<span class="line-modified"> 816                 setupGetByIdPrototypeCache(globalObject, vm, codeBlock, pc, metadata, baseCell, slot, ident);</span>
 817         }
 818     } else if (!LLINT_ALWAYS_ACCESS_SLOW &amp;&amp; isJSArray(baseValue) &amp;&amp; ident == vm.propertyNames-&gt;length) {
 819         {
 820             ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 821             metadata.m_modeMetadata.setArrayLengthMode();
 822             metadata.m_modeMetadata.arrayLengthMode.arrayProfile.observeStructure(baseValue.asCell()-&gt;structure(vm));
 823         }
 824         vm.heap.writeBarrier(codeBlock);
 825     }
 826 
 827     LLINT_PROFILE_VALUE(result);
 828     LLINT_END();
 829 }
 830 
 831 LLINT_SLOW_PATH_DECL(slow_path_put_by_id)
 832 {
 833     LLINT_BEGIN();
 834     auto bytecode = pc-&gt;as&lt;OpPutById&gt;();
<span class="line-modified"> 835     auto&amp; metadata = bytecode.metadata(codeBlock);</span>

 836     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
 837 
<span class="line-modified"> 838     JSValue baseValue = getOperand(callFrame, bytecode.m_base);</span>
 839     PutPropertySlot slot(baseValue, codeBlock-&gt;isStrictMode(), codeBlock-&gt;putByIdContext());
<span class="line-added"> 840 </span>
<span class="line-added"> 841     Structure* oldStructure = baseValue.isCell() ? baseValue.asCell()-&gt;structure(vm) : nullptr;</span>
 842     if (bytecode.m_flags &amp; PutByIdIsDirect)
<span class="line-modified"> 843         CommonSlowPaths::putDirectWithReify(vm, globalObject, asObject(baseValue), ident, getOperand(callFrame, bytecode.m_value), slot);</span>
 844     else
<span class="line-modified"> 845         baseValue.putInline(globalObject, ident, getOperand(callFrame, bytecode.m_value), slot);</span>
 846     LLINT_CHECK_EXCEPTION();
 847 
 848     if (!LLINT_ALWAYS_ACCESS_SLOW
 849         &amp;&amp; baseValue.isCell()
<span class="line-modified"> 850         &amp;&amp; slot.isCacheablePut()</span>
<span class="line-modified"> 851         &amp;&amp; oldStructure-&gt;propertyAccessesAreCacheable()) {</span>
 852         {
 853             StructureID oldStructureID = metadata.m_oldStructureID;
 854             if (oldStructureID) {
 855                 Structure* a = vm.heap.structureIDTable().get(oldStructureID);
 856                 Structure* b = baseValue.asCell()-&gt;structure(vm);
 857                 if (slot.type() == PutPropertySlot::NewProperty)
 858                     b = b-&gt;previousID();
 859 
 860                 if (Structure::shouldConvertToPolyProto(a, b)) {
 861                     a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint()-&gt;invalidate(vm, StringFireDetail(&quot;Detected poly proto opportunity.&quot;));
 862                     b-&gt;rareData()-&gt;sharedPolyProtoWatchpoint()-&gt;invalidate(vm, StringFireDetail(&quot;Detected poly proto opportunity.&quot;));
 863                 }
 864             }
 865         }
 866 
 867         // Start out by clearing out the old cache.
 868         metadata.m_oldStructureID = 0;
 869         metadata.m_offset = 0;
 870         metadata.m_newStructureID = 0;
 871         metadata.m_structureChain.clear();
 872 
 873         JSCell* baseCell = baseValue.asCell();
<span class="line-modified"> 874         Structure* newStructure = baseCell-&gt;structure(vm);</span>
 875 
<span class="line-modified"> 876         if (newStructure-&gt;propertyAccessesAreCacheable() &amp;&amp; baseCell == slot.base()) {</span>
 877             if (slot.type() == PutPropertySlot::NewProperty) {
 878                 GCSafeConcurrentJSLocker locker(codeBlock-&gt;m_lock, vm.heap);
<span class="line-modified"> 879                 if (!newStructure-&gt;isDictionary() &amp;&amp; newStructure-&gt;previousID()-&gt;outOfLineCapacity() == newStructure-&gt;outOfLineCapacity()) {</span>
<span class="line-modified"> 880                     ASSERT(oldStructure == newStructure-&gt;previousID());</span>
<span class="line-modified"> 881                     if (oldStructure == newStructure-&gt;previousID()) {</span>
<span class="line-modified"> 882                         ASSERT(oldStructure-&gt;transitionWatchpointSetHasBeenInvalidated());</span>
<span class="line-modified"> 883 </span>
<span class="line-modified"> 884                         bool sawPolyProto = false;</span>
<span class="line-modified"> 885                         auto result = normalizePrototypeChain(globalObject, baseCell, sawPolyProto);</span>
<span class="line-modified"> 886                         if (result != InvalidPrototypeChain &amp;&amp; !sawPolyProto) {</span>
<span class="line-modified"> 887                             ASSERT(oldStructure-&gt;isObject());</span>
<span class="line-modified"> 888                             metadata.m_oldStructureID = oldStructure-&gt;id();</span>
<span class="line-modified"> 889                             metadata.m_offset = slot.cachedOffset();</span>
<span class="line-modified"> 890                             metadata.m_newStructureID = newStructure-&gt;id();</span>
<span class="line-modified"> 891                             if (!(bytecode.m_flags &amp; PutByIdIsDirect)) {</span>
<span class="line-modified"> 892                                 StructureChain* chain = newStructure-&gt;prototypeChain(globalObject, asObject(baseCell));</span>
<span class="line-added"> 893                                 ASSERT(chain);</span>
<span class="line-added"> 894                                 metadata.m_structureChain.set(vm, codeBlock, chain);</span>
<span class="line-added"> 895                             }</span>
<span class="line-added"> 896                             vm.heap.writeBarrier(codeBlock);</span>
 897                         }

 898                     }
 899                 }
 900             } else {
<span class="line-modified"> 901                 // This assert helps catch bugs if we accidentally forget to disable caching</span>
<span class="line-added"> 902                 // when we transition then store to an existing property. This is common among</span>
<span class="line-added"> 903                 // paths that reify lazy properties. If we reify a lazy property and forget</span>
<span class="line-added"> 904                 // to disable caching, we may come down this path. The Replace IC does not</span>
<span class="line-added"> 905                 // know how to model these types of structure transitions (or any structure</span>
<span class="line-added"> 906                 // transition for that matter).</span>
<span class="line-added"> 907                 RELEASE_ASSERT(newStructure == oldStructure);</span>
<span class="line-added"> 908                 newStructure-&gt;didCachePropertyReplacement(vm, slot.cachedOffset());</span>
 909                 {
 910                     ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
<span class="line-modified"> 911                     metadata.m_oldStructureID = newStructure-&gt;id();</span>
 912                     metadata.m_offset = slot.cachedOffset();
 913                 }
 914                 vm.heap.writeBarrier(codeBlock);
 915             }
 916         }
 917     }
 918 
 919     LLINT_END();
 920 }
 921 
 922 LLINT_SLOW_PATH_DECL(slow_path_del_by_id)
 923 {
 924     LLINT_BEGIN();
 925     auto bytecode = pc-&gt;as&lt;OpDelById&gt;();
<span class="line-modified"> 926     JSObject* baseObject = getOperand(callFrame, bytecode.m_base).toObject(globalObject);</span>

 927     LLINT_CHECK_EXCEPTION();
<span class="line-modified"> 928     bool couldDelete = baseObject-&gt;methodTable(vm)-&gt;deleteProperty(baseObject, globalObject, codeBlock-&gt;identifier(bytecode.m_property));</span>
 929     LLINT_CHECK_EXCEPTION();
 930     if (!couldDelete &amp;&amp; codeBlock-&gt;isStrictMode())
<span class="line-modified"> 931         LLINT_THROW(createTypeError(globalObject, UnableToDeletePropertyError));</span>
 932     LLINT_RETURN(jsBoolean(couldDelete));
 933 }
 934 
<span class="line-modified"> 935 static ALWAYS_INLINE JSValue getByVal(VM&amp; vm, JSGlobalObject* globalObject, CodeBlock* codeBlock, JSValue baseValue, JSValue subscript, OpGetByVal bytecode)</span>
 936 {


 937     auto scope = DECLARE_THROW_SCOPE(vm);
 938 
 939     if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
 940         Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
 941         if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified"> 942             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(subscript)-&gt;toExistingAtomString(globalObject);</span>
 943             RETURN_IF_EXCEPTION(scope, JSValue());
 944             if (existingAtomString) {
 945                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))
 946                     return result;
 947             }
 948         }
 949     }
 950 
 951     if (subscript.isUInt32()) {
 952         uint32_t i = subscript.asUInt32();
<span class="line-modified"> 953         auto&amp; metadata = bytecode.metadata(codeBlock);</span>
 954         ArrayProfile* arrayProfile = &amp;metadata.m_arrayProfile;
 955 
 956         if (isJSString(baseValue)) {
 957             if (asString(baseValue)-&gt;canGetIndex(i)) {
 958                 scope.release();
<span class="line-modified"> 959                 return asString(baseValue)-&gt;getIndex(globalObject, i);</span>
 960             }
 961             arrayProfile-&gt;setOutOfBounds();
 962         } else if (baseValue.isObject()) {
 963             JSObject* object = asObject(baseValue);
 964             if (object-&gt;canGetIndexQuickly(i))
 965                 return object-&gt;getIndexQuickly(i);
 966 
 967             bool skipMarkingOutOfBounds = false;
 968 
 969             if (object-&gt;indexingType() == ArrayWithContiguous &amp;&amp; i &lt; object-&gt;butterfly()-&gt;publicLength()) {
 970                 // FIXME: expand this to ArrayStorage, Int32, and maybe Double:
 971                 // https://bugs.webkit.org/show_bug.cgi?id=182940
 972                 auto* globalObject = object-&gt;globalObject(vm);
 973                 skipMarkingOutOfBounds = globalObject-&gt;isOriginalArrayStructure(object-&gt;structure(vm)) &amp;&amp; globalObject-&gt;arrayPrototypeChainIsSane();
 974             }
 975 
 976             if (!skipMarkingOutOfBounds &amp;&amp; !CommonSlowPaths::canAccessArgumentIndexQuickly(*object, i))
 977                 arrayProfile-&gt;setOutOfBounds();
 978         }
 979 
 980         scope.release();
<span class="line-modified"> 981         return baseValue.get(globalObject, i);</span>
 982     }
 983 
<span class="line-modified"> 984     baseValue.requireObjectCoercible(globalObject);</span>
 985     RETURN_IF_EXCEPTION(scope, JSValue());
<span class="line-modified"> 986     auto property = subscript.toPropertyKey(globalObject);</span>
 987     RETURN_IF_EXCEPTION(scope, JSValue());
 988     scope.release();
<span class="line-modified"> 989     return baseValue.get(globalObject, property);</span>
 990 }
 991 
 992 LLINT_SLOW_PATH_DECL(slow_path_get_by_val)
 993 {
 994     LLINT_BEGIN();
 995     auto bytecode = pc-&gt;as&lt;OpGetByVal&gt;();
<span class="line-modified"> 996     JSValue baseValue = getOperand(callFrame, bytecode.m_base);</span>
<span class="line-added"> 997     JSValue subscript = getOperand(callFrame, bytecode.m_property);</span>
<span class="line-added"> 998 </span>
<span class="line-added"> 999     if (subscript.isString() || subscript.isSymbol()) {</span>
<span class="line-added">1000         auto&amp; metadata = bytecode.metadata(codeBlock);</span>
<span class="line-added">1001         if (metadata.m_seenIdentifiers.count() &lt;= Options::getByValICMaxNumberOfIdentifiers()) {</span>
<span class="line-added">1002             const UniquedStringImpl* impl = nullptr;</span>
<span class="line-added">1003             if (subscript.isSymbol())</span>
<span class="line-added">1004                 impl = &amp;jsCast&lt;Symbol*&gt;(subscript)-&gt;privateName().uid();</span>
<span class="line-added">1005             else {</span>
<span class="line-added">1006                 JSString* string = asString(subscript);</span>
<span class="line-added">1007                 if (auto* maybeUID = string-&gt;tryGetValueImpl()) {</span>
<span class="line-added">1008                     if (maybeUID-&gt;isAtom())</span>
<span class="line-added">1009                         impl = static_cast&lt;const UniquedStringImpl*&gt;(maybeUID);</span>
<span class="line-added">1010                 }</span>
<span class="line-added">1011             }</span>
<span class="line-added">1012 </span>
<span class="line-added">1013             metadata.m_seenIdentifiers.observe(impl);</span>
<span class="line-added">1014         }</span>
<span class="line-added">1015     }</span>
<span class="line-added">1016 </span>
<span class="line-added">1017     LLINT_RETURN_PROFILED(getByVal(vm, globalObject, codeBlock, baseValue, subscript, bytecode));</span>
1018 }
1019 
1020 LLINT_SLOW_PATH_DECL(slow_path_put_by_val)
1021 {
1022     LLINT_BEGIN();
1023 
1024     auto bytecode = pc-&gt;as&lt;OpPutByVal&gt;();
<span class="line-modified">1025     JSValue baseValue = getOperand(callFrame, bytecode.m_base);</span>
<span class="line-modified">1026     JSValue subscript = getOperand(callFrame, bytecode.m_property);</span>
<span class="line-modified">1027     JSValue value = getOperand(callFrame, bytecode.m_value);</span>
<span class="line-modified">1028     bool isStrictMode = codeBlock-&gt;isStrictMode();</span>
1029 
1030     if (LIKELY(subscript.isUInt32())) {
1031         uint32_t i = subscript.asUInt32();
1032         if (baseValue.isObject()) {
1033             JSObject* object = asObject(baseValue);
1034             if (object-&gt;canSetIndexQuickly(i, value))
1035                 object-&gt;setIndexQuickly(vm, i, value);
1036             else
<span class="line-modified">1037                 object-&gt;methodTable(vm)-&gt;putByIndex(object, globalObject, i, value, isStrictMode);</span>
1038             LLINT_END();
1039         }
<span class="line-modified">1040         baseValue.putByIndex(globalObject, i, value, isStrictMode);</span>
1041         LLINT_END();
1042     }
1043 
<span class="line-modified">1044     auto property = subscript.toPropertyKey(globalObject);</span>
1045     LLINT_CHECK_EXCEPTION();
1046     PutPropertySlot slot(baseValue, isStrictMode);
<span class="line-modified">1047     baseValue.put(globalObject, property, value, slot);</span>
1048     LLINT_END();
1049 }
1050 
1051 LLINT_SLOW_PATH_DECL(slow_path_put_by_val_direct)
1052 {
1053     LLINT_BEGIN();
1054 
1055     auto bytecode = pc-&gt;as&lt;OpPutByValDirect&gt;();
<span class="line-modified">1056     JSValue baseValue = getOperand(callFrame, bytecode.m_base);</span>
<span class="line-modified">1057     JSValue subscript = getOperand(callFrame, bytecode.m_property);</span>
<span class="line-modified">1058     JSValue value = getOperand(callFrame, bytecode.m_value);</span>
1059     RELEASE_ASSERT(baseValue.isObject());
1060     JSObject* baseObject = asObject(baseValue);
<span class="line-modified">1061     bool isStrictMode = codeBlock-&gt;isStrictMode();</span>
1062     if (LIKELY(subscript.isUInt32())) {
1063         // Despite its name, JSValue::isUInt32 will return true only for positive boxed int32_t; all those values are valid array indices.
1064         ASSERT(isIndex(subscript.asUInt32()));
<span class="line-modified">1065         baseObject-&gt;putDirectIndex(globalObject, subscript.asUInt32(), value, 0, isStrictMode ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
1066         LLINT_END();
1067     }
1068 
1069     if (subscript.isDouble()) {
1070         double subscriptAsDouble = subscript.asDouble();
1071         uint32_t subscriptAsUInt32 = static_cast&lt;uint32_t&gt;(subscriptAsDouble);
1072         if (subscriptAsDouble == subscriptAsUInt32 &amp;&amp; isIndex(subscriptAsUInt32)) {
<span class="line-modified">1073             baseObject-&gt;putDirectIndex(globalObject, subscriptAsUInt32, value, 0, isStrictMode ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
1074             LLINT_END();
1075         }
1076     }
1077 
1078     // Don&#39;t put to an object if toString threw an exception.
<span class="line-modified">1079     auto property = subscript.toPropertyKey(globalObject);</span>
1080     if (UNLIKELY(throwScope.exception()))
1081         LLINT_END();
1082 
1083     if (Optional&lt;uint32_t&gt; index = parseIndex(property))
<span class="line-modified">1084         baseObject-&gt;putDirectIndex(globalObject, index.value(), value, 0, isStrictMode ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
1085     else {
1086         PutPropertySlot slot(baseObject, isStrictMode);
<span class="line-modified">1087         CommonSlowPaths::putDirectWithReify(vm, globalObject, baseObject, property, value, slot);</span>
1088     }
1089     LLINT_END();
1090 }
1091 
1092 LLINT_SLOW_PATH_DECL(slow_path_del_by_val)
1093 {
1094     LLINT_BEGIN();
1095     auto bytecode = pc-&gt;as&lt;OpDelByVal&gt;();
<span class="line-modified">1096     JSValue baseValue = getOperand(callFrame, bytecode.m_base);</span>
<span class="line-modified">1097     JSObject* baseObject = baseValue.toObject(globalObject);</span>
1098     LLINT_CHECK_EXCEPTION();
1099 
<span class="line-modified">1100     JSValue subscript = getOperand(callFrame, bytecode.m_property);</span>
1101 
1102     bool couldDelete;
1103 
1104     uint32_t i;
1105     if (subscript.getUInt32(i))
<span class="line-modified">1106         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(baseObject, globalObject, i);</span>
1107     else {
1108         LLINT_CHECK_EXCEPTION();
<span class="line-modified">1109         auto property = subscript.toPropertyKey(globalObject);</span>
1110         LLINT_CHECK_EXCEPTION();
<span class="line-modified">1111         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deleteProperty(baseObject, globalObject, property);</span>
1112     }
1113     LLINT_CHECK_EXCEPTION();
1114 
<span class="line-modified">1115     if (!couldDelete &amp;&amp; codeBlock-&gt;isStrictMode())</span>
<span class="line-modified">1116         LLINT_THROW(createTypeError(globalObject, UnableToDeletePropertyError));</span>
1117 
1118     LLINT_RETURN(jsBoolean(couldDelete));
1119 }
1120 
1121 LLINT_SLOW_PATH_DECL(slow_path_put_getter_by_id)
1122 {
1123     LLINT_BEGIN();
1124     auto bytecode = pc-&gt;as&lt;OpPutGetterById&gt;();
<span class="line-modified">1125     ASSERT(getNonConstantOperand(callFrame, bytecode.m_base).isObject());</span>
<span class="line-modified">1126     JSObject* baseObj = asObject(getNonConstantOperand(callFrame, bytecode.m_base));</span>
1127 
1128     unsigned options = bytecode.m_attributes;
1129 
<span class="line-modified">1130     JSValue getter = getNonConstantOperand(callFrame, bytecode.m_accessor);</span>
1131     ASSERT(getter.isObject());
1132 
<span class="line-modified">1133     baseObj-&gt;putGetter(globalObject, codeBlock-&gt;identifier(bytecode.m_property), asObject(getter), options);</span>
1134     LLINT_END();
1135 }
1136 
1137 LLINT_SLOW_PATH_DECL(slow_path_put_setter_by_id)
1138 {
1139     LLINT_BEGIN();
1140     auto bytecode = pc-&gt;as&lt;OpPutSetterById&gt;();
<span class="line-modified">1141     ASSERT(getNonConstantOperand(callFrame, bytecode.m_base).isObject());</span>
<span class="line-modified">1142     JSObject* baseObj = asObject(getNonConstantOperand(callFrame, bytecode.m_base));</span>
1143 
1144     unsigned options = bytecode.m_attributes;
1145 
<span class="line-modified">1146     JSValue setter = getNonConstantOperand(callFrame, bytecode.m_accessor);</span>
1147     ASSERT(setter.isObject());
1148 
<span class="line-modified">1149     baseObj-&gt;putSetter(globalObject, codeBlock-&gt;identifier(bytecode.m_property), asObject(setter), options);</span>
1150     LLINT_END();
1151 }
1152 
1153 LLINT_SLOW_PATH_DECL(slow_path_put_getter_setter_by_id)
1154 {
1155     LLINT_BEGIN();
1156     auto bytecode = pc-&gt;as&lt;OpPutGetterSetterById&gt;();
<span class="line-modified">1157     ASSERT(getNonConstantOperand(callFrame, bytecode.m_base).isObject());</span>
<span class="line-modified">1158     JSObject* baseObject = asObject(getNonConstantOperand(callFrame, bytecode.m_base));</span>
1159 
<span class="line-modified">1160     JSValue getter = getNonConstantOperand(callFrame, bytecode.m_getter);</span>
<span class="line-modified">1161     JSValue setter = getNonConstantOperand(callFrame, bytecode.m_setter);</span>
1162     ASSERT(getter.isObject() || setter.isObject());
<span class="line-modified">1163     GetterSetter* accessor = GetterSetter::create(vm, globalObject, getter, setter);</span>
1164 
<span class="line-modified">1165     CommonSlowPaths::putDirectAccessorWithReify(vm, globalObject, baseObject, codeBlock-&gt;identifier(bytecode.m_property), accessor, bytecode.m_attributes);</span>
1166     LLINT_END();
1167 }
1168 
1169 LLINT_SLOW_PATH_DECL(slow_path_put_getter_by_val)
1170 {
1171     LLINT_BEGIN();
1172     auto bytecode = pc-&gt;as&lt;OpPutGetterByVal&gt;();
<span class="line-modified">1173     ASSERT(getNonConstantOperand(callFrame, bytecode.m_base).isObject());</span>
<span class="line-modified">1174     JSObject* baseObj = asObject(getNonConstantOperand(callFrame, bytecode.m_base));</span>
<span class="line-modified">1175     JSValue subscript = getOperand(callFrame, bytecode.m_property);</span>
1176 
1177     unsigned options = bytecode.m_attributes;
1178 
<span class="line-modified">1179     JSValue getter = getNonConstantOperand(callFrame, bytecode.m_accessor);</span>
1180     ASSERT(getter.isObject());
1181 
<span class="line-modified">1182     auto property = subscript.toPropertyKey(globalObject);</span>
1183     LLINT_CHECK_EXCEPTION();
1184 
<span class="line-modified">1185     baseObj-&gt;putGetter(globalObject, property, asObject(getter), options);</span>
1186     LLINT_END();
1187 }
1188 
1189 LLINT_SLOW_PATH_DECL(slow_path_put_setter_by_val)
1190 {
1191     LLINT_BEGIN();
1192     auto bytecode = pc-&gt;as&lt;OpPutSetterByVal&gt;();
<span class="line-modified">1193     ASSERT(getNonConstantOperand(callFrame, bytecode.m_base).isObject());</span>
<span class="line-modified">1194     JSObject* baseObj = asObject(getNonConstantOperand(callFrame, bytecode.m_base));</span>
<span class="line-modified">1195     JSValue subscript = getOperand(callFrame, bytecode.m_property);</span>
1196 
1197     unsigned options = bytecode.m_attributes;
1198 
<span class="line-modified">1199     JSValue setter = getNonConstantOperand(callFrame, bytecode.m_accessor);</span>
1200     ASSERT(setter.isObject());
1201 
<span class="line-modified">1202     auto property = subscript.toPropertyKey(globalObject);</span>
1203     LLINT_CHECK_EXCEPTION();
1204 
<span class="line-modified">1205     baseObj-&gt;putSetter(globalObject, property, asObject(setter), options);</span>
1206     LLINT_END();
1207 }
1208 
1209 LLINT_SLOW_PATH_DECL(slow_path_jtrue)
1210 {
1211     LLINT_BEGIN();
1212     auto bytecode = pc-&gt;as&lt;OpJtrue&gt;();
<span class="line-modified">1213     LLINT_BRANCH(getOperand(callFrame, bytecode.m_condition).toBoolean(globalObject));</span>
1214 }
1215 
1216 LLINT_SLOW_PATH_DECL(slow_path_jfalse)
1217 {
1218     LLINT_BEGIN();
1219     auto bytecode = pc-&gt;as&lt;OpJfalse&gt;();
<span class="line-modified">1220     LLINT_BRANCH(!getOperand(callFrame, bytecode.m_condition).toBoolean(globalObject));</span>
1221 }
1222 
1223 LLINT_SLOW_PATH_DECL(slow_path_jless)
1224 {
1225     LLINT_BEGIN();
1226     auto bytecode = pc-&gt;as&lt;OpJless&gt;();
<span class="line-modified">1227     LLINT_BRANCH(jsLess&lt;true&gt;(globalObject, getOperand(callFrame, bytecode.m_lhs), getOperand(callFrame, bytecode.m_rhs)));</span>
1228 }
1229 
1230 LLINT_SLOW_PATH_DECL(slow_path_jnless)
1231 {
1232     LLINT_BEGIN();
1233     auto bytecode = pc-&gt;as&lt;OpJnless&gt;();
<span class="line-modified">1234     LLINT_BRANCH(!jsLess&lt;true&gt;(globalObject, getOperand(callFrame, bytecode.m_lhs), getOperand(callFrame, bytecode.m_rhs)));</span>
1235 }
1236 
1237 LLINT_SLOW_PATH_DECL(slow_path_jgreater)
1238 {
1239     LLINT_BEGIN();
1240     auto bytecode = pc-&gt;as&lt;OpJgreater&gt;();
<span class="line-modified">1241     LLINT_BRANCH(jsLess&lt;false&gt;(globalObject, getOperand(callFrame, bytecode.m_rhs), getOperand(callFrame, bytecode.m_lhs)));</span>
1242 }
1243 
1244 LLINT_SLOW_PATH_DECL(slow_path_jngreater)
1245 {
1246     LLINT_BEGIN();
1247     auto bytecode = pc-&gt;as&lt;OpJngreater&gt;();
<span class="line-modified">1248     LLINT_BRANCH(!jsLess&lt;false&gt;(globalObject, getOperand(callFrame, bytecode.m_rhs), getOperand(callFrame, bytecode.m_lhs)));</span>
1249 }
1250 
1251 LLINT_SLOW_PATH_DECL(slow_path_jlesseq)
1252 {
1253     LLINT_BEGIN();
1254     auto bytecode = pc-&gt;as&lt;OpJlesseq&gt;();
<span class="line-modified">1255     LLINT_BRANCH(jsLessEq&lt;true&gt;(globalObject, getOperand(callFrame, bytecode.m_lhs), getOperand(callFrame, bytecode.m_rhs)));</span>
1256 }
1257 
1258 LLINT_SLOW_PATH_DECL(slow_path_jnlesseq)
1259 {
1260     LLINT_BEGIN();
1261     auto bytecode = pc-&gt;as&lt;OpJnlesseq&gt;();
<span class="line-modified">1262     LLINT_BRANCH(!jsLessEq&lt;true&gt;(globalObject, getOperand(callFrame, bytecode.m_lhs), getOperand(callFrame, bytecode.m_rhs)));</span>
1263 }
1264 
1265 LLINT_SLOW_PATH_DECL(slow_path_jgreatereq)
1266 {
1267     LLINT_BEGIN();
1268     auto bytecode = pc-&gt;as&lt;OpJgreatereq&gt;();
<span class="line-modified">1269     LLINT_BRANCH(jsLessEq&lt;false&gt;(globalObject, getOperand(callFrame, bytecode.m_rhs), getOperand(callFrame, bytecode.m_lhs)));</span>
1270 }
1271 
1272 LLINT_SLOW_PATH_DECL(slow_path_jngreatereq)
1273 {
1274     LLINT_BEGIN();
1275     auto bytecode = pc-&gt;as&lt;OpJngreatereq&gt;();
<span class="line-modified">1276     LLINT_BRANCH(!jsLessEq&lt;false&gt;(globalObject, getOperand(callFrame, bytecode.m_rhs), getOperand(callFrame, bytecode.m_lhs)));</span>
1277 }
1278 
1279 LLINT_SLOW_PATH_DECL(slow_path_jeq)
1280 {
1281     LLINT_BEGIN();
1282     auto bytecode = pc-&gt;as&lt;OpJeq&gt;();
<span class="line-modified">1283     LLINT_BRANCH(JSValue::equal(globalObject, getOperand(callFrame, bytecode.m_lhs), getOperand(callFrame, bytecode.m_rhs)));</span>
1284 }
1285 
1286 LLINT_SLOW_PATH_DECL(slow_path_jneq)
1287 {
1288     LLINT_BEGIN();
1289     auto bytecode = pc-&gt;as&lt;OpJneq&gt;();
<span class="line-modified">1290     LLINT_BRANCH(!JSValue::equal(globalObject, getOperand(callFrame, bytecode.m_lhs), getOperand(callFrame, bytecode.m_rhs)));</span>
1291 }
1292 
1293 LLINT_SLOW_PATH_DECL(slow_path_jstricteq)
1294 {
1295     LLINT_BEGIN();
1296     auto bytecode = pc-&gt;as&lt;OpJstricteq&gt;();
<span class="line-modified">1297     LLINT_BRANCH(JSValue::strictEqual(globalObject, getOperand(callFrame, bytecode.m_lhs), getOperand(callFrame, bytecode.m_rhs)));</span>
1298 }
1299 
1300 LLINT_SLOW_PATH_DECL(slow_path_jnstricteq)
1301 {
1302     LLINT_BEGIN();
1303     auto bytecode = pc-&gt;as&lt;OpJnstricteq&gt;();
<span class="line-modified">1304     LLINT_BRANCH(!JSValue::strictEqual(globalObject, getOperand(callFrame, bytecode.m_lhs), getOperand(callFrame, bytecode.m_rhs)));</span>
1305 }
1306 
1307 LLINT_SLOW_PATH_DECL(slow_path_switch_imm)
1308 {
1309     LLINT_BEGIN();
1310     auto bytecode = pc-&gt;as&lt;OpSwitchImm&gt;();
<span class="line-modified">1311     JSValue scrutinee = getOperand(callFrame, bytecode.m_scrutinee);</span>
1312     ASSERT(scrutinee.isDouble());
1313     double value = scrutinee.asDouble();
1314     int32_t intValue = static_cast&lt;int32_t&gt;(value);
1315     int defaultOffset = JUMP_OFFSET(bytecode.m_defaultOffset);
<span class="line-modified">1316     if (value == intValue)</span>

1317         JUMP_TO(codeBlock-&gt;switchJumpTable(bytecode.m_tableIndex).offsetForValue(intValue, defaultOffset));
<span class="line-modified">1318     else</span>
1319         JUMP_TO(defaultOffset);
1320     LLINT_END();
1321 }
1322 
1323 LLINT_SLOW_PATH_DECL(slow_path_switch_char)
1324 {
1325     LLINT_BEGIN();
1326     auto bytecode = pc-&gt;as&lt;OpSwitchChar&gt;();
<span class="line-modified">1327     JSValue scrutinee = getOperand(callFrame, bytecode.m_scrutinee);</span>
1328     ASSERT(scrutinee.isString());
1329     JSString* string = asString(scrutinee);
1330     ASSERT(string-&gt;length() == 1);
1331     int defaultOffset = JUMP_OFFSET(bytecode.m_defaultOffset);
<span class="line-modified">1332     StringImpl* impl = string-&gt;value(globalObject).impl();</span>

1333     JUMP_TO(codeBlock-&gt;switchJumpTable(bytecode.m_tableIndex).offsetForValue((*impl)[0], defaultOffset));
1334     LLINT_END();
1335 }
1336 
1337 LLINT_SLOW_PATH_DECL(slow_path_switch_string)
1338 {
1339     LLINT_BEGIN();
1340     auto bytecode = pc-&gt;as&lt;OpSwitchString&gt;();
<span class="line-modified">1341     JSValue scrutinee = getOperand(callFrame, bytecode.m_scrutinee);</span>
1342     int defaultOffset = JUMP_OFFSET(bytecode.m_defaultOffset);
1343     if (!scrutinee.isString())
1344         JUMP_TO(defaultOffset);
1345     else {
<span class="line-modified">1346         StringImpl* scrutineeStringImpl = asString(scrutinee)-&gt;value(globalObject).impl();</span>
1347 
1348         LLINT_CHECK_EXCEPTION();
1349 


1350         JUMP_TO(codeBlock-&gt;stringSwitchJumpTable(bytecode.m_tableIndex).offsetForValue(scrutineeStringImpl, defaultOffset));
1351     }
1352     LLINT_END();
1353 }
1354 
1355 LLINT_SLOW_PATH_DECL(slow_path_new_func)
1356 {
1357     LLINT_BEGIN();
1358     auto bytecode = pc-&gt;as&lt;OpNewFunc&gt;();
<span class="line-modified">1359     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>

1360     slowPathLogF(&quot;Creating function!\n&quot;);
1361     LLINT_RETURN(JSFunction::create(vm, codeBlock-&gt;functionDecl(bytecode.m_functionDecl), scope));
1362 }
1363 
1364 LLINT_SLOW_PATH_DECL(slow_path_new_generator_func)
1365 {
1366     LLINT_BEGIN();
1367     auto bytecode = pc-&gt;as&lt;OpNewGeneratorFunc&gt;();
<span class="line-modified">1368     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>

1369     slowPathLogF(&quot;Creating function!\n&quot;);
1370     LLINT_RETURN(JSGeneratorFunction::create(vm, codeBlock-&gt;functionDecl(bytecode.m_functionDecl), scope));
1371 }
1372 
1373 LLINT_SLOW_PATH_DECL(slow_path_new_async_func)
1374 {
1375     LLINT_BEGIN();
1376     auto bytecode = pc-&gt;as&lt;OpNewAsyncFunc&gt;();
<span class="line-modified">1377     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>

1378     slowPathLogF(&quot;Creating async function!\n&quot;);
1379     LLINT_RETURN(JSAsyncFunction::create(vm, codeBlock-&gt;functionDecl(bytecode.m_functionDecl), scope));
1380 }
1381 
1382 LLINT_SLOW_PATH_DECL(slow_path_new_async_generator_func)
1383 {
1384     LLINT_BEGIN();
1385     auto bytecode = pc-&gt;as&lt;OpNewAsyncGeneratorFunc&gt;();
<span class="line-modified">1386     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>

1387     slowPathLogF(&quot;Creating async generator function!\n&quot;);
1388     LLINT_RETURN(JSAsyncGeneratorFunction::create(vm, codeBlock-&gt;functionDecl(bytecode.m_functionDecl), scope));
1389 }
1390 
1391 LLINT_SLOW_PATH_DECL(slow_path_new_func_exp)
1392 {
1393     LLINT_BEGIN();
1394 
1395     auto bytecode = pc-&gt;as&lt;OpNewFuncExp&gt;();
<span class="line-modified">1396     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>

1397     FunctionExecutable* executable = codeBlock-&gt;functionExpr(bytecode.m_functionDecl);
1398 
1399     LLINT_RETURN(JSFunction::create(vm, executable, scope));
1400 }
1401 
1402 LLINT_SLOW_PATH_DECL(slow_path_new_generator_func_exp)
1403 {
1404     LLINT_BEGIN();
1405 
1406     auto bytecode = pc-&gt;as&lt;OpNewGeneratorFuncExp&gt;();
<span class="line-modified">1407     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>

1408     FunctionExecutable* executable = codeBlock-&gt;functionExpr(bytecode.m_functionDecl);
1409 
1410     LLINT_RETURN(JSGeneratorFunction::create(vm, executable, scope));
1411 }
1412 
1413 LLINT_SLOW_PATH_DECL(slow_path_new_async_func_exp)
1414 {
1415     LLINT_BEGIN();
1416 
1417     auto bytecode = pc-&gt;as&lt;OpNewAsyncFuncExp&gt;();
<span class="line-modified">1418     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>

1419     FunctionExecutable* executable = codeBlock-&gt;functionExpr(bytecode.m_functionDecl);
1420 
1421     LLINT_RETURN(JSAsyncFunction::create(vm, executable, scope));
1422 }
1423 
1424 LLINT_SLOW_PATH_DECL(slow_path_new_async_generator_func_exp)
1425 {
1426     LLINT_BEGIN();
1427 
1428     auto bytecode = pc-&gt;as&lt;OpNewAsyncGeneratorFuncExp&gt;();
<span class="line-modified">1429     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>

1430     FunctionExecutable* executable = codeBlock-&gt;functionExpr(bytecode.m_functionDecl);
1431 
1432     LLINT_RETURN(JSAsyncGeneratorFunction::create(vm, executable, scope));
1433 }
1434 
1435 LLINT_SLOW_PATH_DECL(slow_path_set_function_name)
1436 {
1437     LLINT_BEGIN();
1438     auto bytecode = pc-&gt;as&lt;OpSetFunctionName&gt;();
<span class="line-modified">1439     JSFunction* func = jsCast&lt;JSFunction*&gt;(getNonConstantOperand(callFrame, bytecode.m_function));</span>
<span class="line-modified">1440     JSValue name = getOperand(callFrame, bytecode.m_name);</span>
<span class="line-modified">1441     func-&gt;setFunctionName(globalObject, name);</span>
1442     LLINT_END();
1443 }
1444 
<span class="line-modified">1445 static SlowPathReturnType handleHostCall(CallFrame* calleeFrame, JSValue callee, CodeSpecializationKind kind)</span>
1446 {
1447     slowPathLog(&quot;Performing host call.\n&quot;);
1448 
<span class="line-modified">1449     CallFrame* callFrame = calleeFrame-&gt;callerFrame();</span>
<span class="line-modified">1450     CodeBlock* callerCodeBlock = callFrame-&gt;codeBlock();</span>
<span class="line-added">1451     JSGlobalObject* globalObject = callerCodeBlock-&gt;globalObject();</span>
<span class="line-added">1452     VM&amp; vm = callerCodeBlock-&gt;vm();</span>
1453     auto throwScope = DECLARE_THROW_SCOPE(vm);
1454 
<span class="line-modified">1455     calleeFrame-&gt;setCodeBlock(nullptr);</span>
<span class="line-modified">1456     calleeFrame-&gt;clearReturnPC();</span>
1457 
1458     if (kind == CodeForCall) {
1459         CallData callData;
1460         CallType callType = getCallData(vm, callee, callData);
1461 
1462         ASSERT(callType != CallType::JS);
1463 
1464         if (callType == CallType::Host) {
<span class="line-modified">1465             SlowPathFrameTracer tracer(vm, calleeFrame);</span>
<span class="line-modified">1466             calleeFrame-&gt;setCallee(asObject(callee));</span>
<span class="line-modified">1467             vm.hostCallReturnValue = JSValue::decode(callData.native.function(asObject(callee)-&gt;globalObject(vm), calleeFrame));</span>
<span class="line-modified">1468             LLINT_CALL_RETURN(globalObject, calleeFrame, LLInt::getCodePtr(getHostCallReturnValue), CFunctionPtrTag);</span>
1469         }
1470 
1471         slowPathLog(&quot;Call callee is not a function: &quot;, callee, &quot;\n&quot;);
1472 
1473         ASSERT(callType == CallType::None);
<span class="line-modified">1474         LLINT_CALL_THROW(globalObject, createNotAFunctionError(globalObject, callee));</span>
1475     }
1476 
1477     ASSERT(kind == CodeForConstruct);
1478 
1479     ConstructData constructData;
1480     ConstructType constructType = getConstructData(vm, callee, constructData);
1481 
1482     ASSERT(constructType != ConstructType::JS);
1483 
1484     if (constructType == ConstructType::Host) {
<span class="line-modified">1485         SlowPathFrameTracer tracer(vm, calleeFrame);</span>
<span class="line-modified">1486         calleeFrame-&gt;setCallee(asObject(callee));</span>
<span class="line-modified">1487         vm.hostCallReturnValue = JSValue::decode(constructData.native.function(asObject(callee)-&gt;globalObject(vm), calleeFrame));</span>
<span class="line-modified">1488         LLINT_CALL_RETURN(globalObject, calleeFrame, LLInt::getCodePtr(getHostCallReturnValue), CFunctionPtrTag);</span>
1489     }
1490 
1491     slowPathLog(&quot;Constructor callee is not a function: &quot;, callee, &quot;\n&quot;);
1492 
1493     ASSERT(constructType == ConstructType::None);
<span class="line-modified">1494     LLINT_CALL_THROW(globalObject, createNotAConstructorError(globalObject, callee));</span>
1495 }
1496 
<span class="line-modified">1497 inline SlowPathReturnType setUpCall(CallFrame* calleeFrame, CodeSpecializationKind kind, JSValue calleeAsValue, LLIntCallLinkInfo* callLinkInfo = nullptr)</span>
1498 {
<span class="line-modified">1499     CallFrame* callFrame = calleeFrame-&gt;callerFrame();</span>
<span class="line-modified">1500     CodeBlock* callerCodeBlock = callFrame-&gt;codeBlock();</span>
<span class="line-added">1501     JSGlobalObject* globalObject = callerCodeBlock-&gt;globalObject();</span>
<span class="line-added">1502     VM&amp; vm = callerCodeBlock-&gt;vm();</span>
1503     auto throwScope = DECLARE_THROW_SCOPE(vm);
1504 
<span class="line-modified">1505     slowPathLogF(&quot;Performing call with recorded PC = %p\n&quot;, callFrame-&gt;currentVPC());</span>
1506 
1507     JSCell* calleeAsFunctionCell = getJSFunction(calleeAsValue);
1508     if (!calleeAsFunctionCell) {
1509         if (auto* internalFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, calleeAsValue)) {
1510             MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr = vm.getCTIInternalFunctionTrampolineFor(kind);
1511             ASSERT(!!codePtr);
1512 
1513             if (!LLINT_ALWAYS_ACCESS_SLOW &amp;&amp; callLinkInfo) {


1514                 ConcurrentJSLocker locker(callerCodeBlock-&gt;m_lock);
1515                 callLinkInfo-&gt;link(vm, callerCodeBlock, internalFunction, codePtr);
1516             }
1517 
1518             assertIsTaggedWith(codePtr.executableAddress(), JSEntryPtrTag);
<span class="line-modified">1519             LLINT_CALL_RETURN(globalObject, calleeFrame, codePtr.executableAddress(), JSEntryPtrTag);</span>
1520         }
<span class="line-modified">1521         RELEASE_AND_RETURN(throwScope, handleHostCall(calleeFrame, calleeAsValue, kind));</span>
1522     }
1523     JSFunction* callee = jsCast&lt;JSFunction*&gt;(calleeAsFunctionCell);
1524     JSScope* scope = callee-&gt;scopeUnchecked();
1525     ExecutableBase* executable = callee-&gt;executable();
1526 
1527     MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr;
<span class="line-modified">1528     CodeBlock* codeBlock = nullptr;</span>
1529     if (executable-&gt;isHostFunction())
1530         codePtr = executable-&gt;entrypointFor(kind, MustCheckArity);
1531     else {
1532         FunctionExecutable* functionExecutable = static_cast&lt;FunctionExecutable*&gt;(executable);
1533 
1534         if (!isCall(kind) &amp;&amp; functionExecutable-&gt;constructAbility() == ConstructAbility::CannotConstruct)
<span class="line-modified">1535             LLINT_CALL_THROW(globalObject, createNotAConstructorError(globalObject, callee));</span>
1536 
<span class="line-modified">1537         CodeBlock** codeBlockSlot = calleeFrame-&gt;addressOfCodeBlock();</span>
1538         Exception* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, callee, scope, kind, *codeBlockSlot);
1539         EXCEPTION_ASSERT(throwScope.exception() == error);
1540         if (UNLIKELY(error))
<span class="line-modified">1541             LLINT_CALL_THROW(globalObject, error);</span>
1542         codeBlock = *codeBlockSlot;
1543         ASSERT(codeBlock);
1544         ArityCheckMode arity;
<span class="line-modified">1545         if (calleeFrame-&gt;argumentCountIncludingThis() &lt; static_cast&lt;size_t&gt;(codeBlock-&gt;numParameters()))</span>
1546             arity = MustCheckArity;
1547         else
1548             arity = ArityCheckNotRequired;
1549         codePtr = functionExecutable-&gt;entrypointFor(kind, arity);
1550     }
1551 
1552     ASSERT(!!codePtr);
1553 
1554     if (!LLINT_ALWAYS_ACCESS_SLOW &amp;&amp; callLinkInfo) {


1555         ConcurrentJSLocker locker(callerCodeBlock-&gt;m_lock);
1556         callLinkInfo-&gt;link(vm, callerCodeBlock, callee, codePtr);
1557         if (codeBlock)
<span class="line-modified">1558             codeBlock-&gt;linkIncomingCall(callFrame, callLinkInfo);</span>
1559     }
1560 
1561     assertIsTaggedWith(codePtr.executableAddress(), JSEntryPtrTag);
<span class="line-modified">1562     LLINT_CALL_RETURN(globalObject, calleeFrame, codePtr.executableAddress(), JSEntryPtrTag);</span>
1563 }
1564 
1565 template&lt;typename Op&gt;
<span class="line-modified">1566 inline SlowPathReturnType genericCall(CodeBlock* codeBlock, CallFrame* callFrame, Op&amp;&amp; bytecode, CodeSpecializationKind kind)</span>
1567 {
1568     // This needs to:
1569     // - Set up a call frame.
1570     // - Figure out what to call and compile it if necessary.
1571     // - If possible, link the call&#39;s inline cache.
1572     // - Return a tuple of machine code address to call and the new call frame.
1573 
<span class="line-modified">1574     JSValue calleeAsValue = getOperand(callFrame, bytecode.m_callee);</span>
1575 
<span class="line-modified">1576     CallFrame* calleeFrame = callFrame - bytecode.m_argv;</span>
1577 
<span class="line-modified">1578     calleeFrame-&gt;setArgumentCountIncludingThis(bytecode.m_argc);</span>
<span class="line-modified">1579     calleeFrame-&gt;uncheckedR(VirtualRegister(CallFrameSlot::callee)) = calleeAsValue;</span>
<span class="line-modified">1580     calleeFrame-&gt;setCallerFrame(callFrame);</span>
1581 
<span class="line-modified">1582     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
<span class="line-modified">1583     return setUpCall(calleeFrame, kind, calleeAsValue, &amp;metadata.m_callLinkInfo);</span>
1584 }
1585 
1586 LLINT_SLOW_PATH_DECL(slow_path_call)
1587 {
1588     LLINT_BEGIN_NO_SET_PC();
<span class="line-modified">1589     UNUSED_PARAM(globalObject);</span>
<span class="line-added">1590     RELEASE_AND_RETURN(throwScope, genericCall(codeBlock, callFrame, pc-&gt;as&lt;OpCall&gt;(), CodeForCall));</span>
1591 }
1592 
1593 LLINT_SLOW_PATH_DECL(slow_path_tail_call)
1594 {
1595     LLINT_BEGIN_NO_SET_PC();
<span class="line-modified">1596     UNUSED_PARAM(globalObject);</span>
<span class="line-added">1597     RELEASE_AND_RETURN(throwScope, genericCall(codeBlock, callFrame, pc-&gt;as&lt;OpTailCall&gt;(), CodeForCall));</span>
1598 }
1599 
1600 LLINT_SLOW_PATH_DECL(slow_path_construct)
1601 {
1602     LLINT_BEGIN_NO_SET_PC();
<span class="line-modified">1603     UNUSED_PARAM(globalObject);</span>
<span class="line-added">1604     RELEASE_AND_RETURN(throwScope, genericCall(codeBlock, callFrame, pc-&gt;as&lt;OpConstruct&gt;(), CodeForConstruct));</span>
1605 }
1606 
1607 LLINT_SLOW_PATH_DECL(slow_path_size_frame_for_varargs)
1608 {
1609     LLINT_BEGIN();
1610     // This needs to:
1611     // - Set up a call frame while respecting the variable arguments.
1612 
1613     unsigned numUsedStackSlots;
1614     JSValue arguments;
1615     int firstVarArg;
1616     switch (pc-&gt;opcodeID()) {
1617     case op_call_varargs: {
1618         auto bytecode = pc-&gt;as&lt;OpCallVarargs&gt;();
1619         numUsedStackSlots = -bytecode.m_firstFree.offset();
<span class="line-modified">1620         arguments = getOperand(callFrame, bytecode.m_arguments);</span>
1621         firstVarArg = bytecode.m_firstVarArg;
1622         break;
1623     }
1624     case op_tail_call_varargs: {
1625         auto bytecode = pc-&gt;as&lt;OpTailCallVarargs&gt;();
1626         numUsedStackSlots = -bytecode.m_firstFree.offset();
<span class="line-modified">1627         arguments = getOperand(callFrame, bytecode.m_arguments);</span>
1628         firstVarArg = bytecode.m_firstVarArg;
1629         break;
1630     }
1631     case op_construct_varargs: {
1632         auto bytecode = pc-&gt;as&lt;OpConstructVarargs&gt;();
1633         numUsedStackSlots = -bytecode.m_firstFree.offset();
<span class="line-modified">1634         arguments = getOperand(callFrame, bytecode.m_arguments);</span>
1635         firstVarArg = bytecode.m_firstVarArg;
1636         break;
1637     }
1638     default:
1639         RELEASE_ASSERT_NOT_REACHED();
1640     }
<span class="line-modified">1641     unsigned length = sizeFrameForVarargs(globalObject, callFrame, vm, arguments, numUsedStackSlots, firstVarArg);</span>
<span class="line-modified">1642     LLINT_CALL_CHECK_EXCEPTION(globalObject);</span>
1643 
<span class="line-modified">1644     CallFrame* calleeFrame = calleeFrameForVarargs(callFrame, numUsedStackSlots, length + 1);</span>
1645     vm.varargsLength = length;
<span class="line-modified">1646     vm.newCallFrameReturnValue = calleeFrame;</span>
1647 
<span class="line-modified">1648     LLINT_RETURN_CALLEE_FRAME(calleeFrame);</span>
1649 }
1650 
1651 LLINT_SLOW_PATH_DECL(slow_path_size_frame_for_forward_arguments)
1652 {
1653     LLINT_BEGIN();
1654     // This needs to:
1655     // - Set up a call frame with the same arguments as the current frame.
1656 
1657     auto bytecode = pc-&gt;as&lt;OpTailCallForwardArguments&gt;();
1658     unsigned numUsedStackSlots = -bytecode.m_firstFree.offset();
1659 
<span class="line-modified">1660     unsigned arguments = sizeFrameForForwardArguments(globalObject, callFrame, vm, numUsedStackSlots);</span>
<span class="line-modified">1661     LLINT_CALL_CHECK_EXCEPTION(globalObject);</span>
1662 
<span class="line-modified">1663     CallFrame* calleeFrame = calleeFrameForVarargs(callFrame, numUsedStackSlots, arguments + 1);</span>
1664 
1665     vm.varargsLength = arguments;
<span class="line-modified">1666     vm.newCallFrameReturnValue = calleeFrame;</span>
1667 
<span class="line-modified">1668     LLINT_RETURN_CALLEE_FRAME(calleeFrame);</span>
1669 }
1670 
1671 enum class SetArgumentsWith {
1672     Object,
1673     CurrentArguments
1674 };
1675 
1676 template&lt;typename Op&gt;
<span class="line-modified">1677 inline SlowPathReturnType varargsSetup(CallFrame* callFrame, const Instruction* pc, CodeSpecializationKind kind, SetArgumentsWith set)</span>
1678 {
1679     LLINT_BEGIN_NO_SET_PC();
<span class="line-added">1680 </span>
1681     // This needs to:
1682     // - Figure out what to call and compile it if necessary.
1683     // - Return a tuple of machine code address to call and the new call frame.
1684 
1685     auto bytecode = pc-&gt;as&lt;Op&gt;();
<span class="line-modified">1686     JSValue calleeAsValue = getOperand(callFrame, bytecode.m_callee);</span>
1687 
<span class="line-modified">1688     CallFrame* calleeFrame = vm.newCallFrameReturnValue;</span>
1689 
1690     if (set == SetArgumentsWith::Object) {
<span class="line-modified">1691         setupVarargsFrameAndSetThis(globalObject, callFrame, calleeFrame, getOperand(callFrame, bytecode.m_thisValue), getOperand(callFrame, bytecode.m_arguments), bytecode.m_firstVarArg, vm.varargsLength);</span>
<span class="line-modified">1692         LLINT_CALL_CHECK_EXCEPTION(globalObject);</span>
1693     } else
<span class="line-modified">1694         setupForwardArgumentsFrameAndSetThis(globalObject, callFrame, calleeFrame, getOperand(callFrame, bytecode.m_thisValue), vm.varargsLength);</span>
1695 
<span class="line-modified">1696     calleeFrame-&gt;setCallerFrame(callFrame);</span>
<span class="line-modified">1697     calleeFrame-&gt;uncheckedR(VirtualRegister(CallFrameSlot::callee)) = calleeAsValue;</span>
<span class="line-modified">1698     callFrame-&gt;setCurrentVPC(pc);</span>
1699 
<span class="line-modified">1700     RELEASE_AND_RETURN(throwScope, setUpCall(calleeFrame, kind, calleeAsValue));</span>
1701 }
1702 
1703 LLINT_SLOW_PATH_DECL(slow_path_call_varargs)
1704 {
<span class="line-modified">1705     return varargsSetup&lt;OpCallVarargs&gt;(callFrame, pc, CodeForCall, SetArgumentsWith::Object);</span>
1706 }
1707 
1708 LLINT_SLOW_PATH_DECL(slow_path_tail_call_varargs)
1709 {
<span class="line-modified">1710     return varargsSetup&lt;OpTailCallVarargs&gt;(callFrame, pc, CodeForCall, SetArgumentsWith::Object);</span>
1711 }
1712 
1713 LLINT_SLOW_PATH_DECL(slow_path_tail_call_forward_arguments)
1714 {
<span class="line-modified">1715     return varargsSetup&lt;OpTailCallForwardArguments&gt;(callFrame, pc, CodeForCall, SetArgumentsWith::CurrentArguments);</span>
1716 }
1717 
1718 LLINT_SLOW_PATH_DECL(slow_path_construct_varargs)
1719 {
<span class="line-modified">1720     return varargsSetup&lt;OpConstructVarargs&gt;(callFrame, pc, CodeForConstruct, SetArgumentsWith::Object);</span>
1721 }
1722 
<span class="line-modified">1723 inline SlowPathReturnType commonCallEval(CallFrame* callFrame, const Instruction* pc, MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; returnPoint)</span>
1724 {
1725     LLINT_BEGIN_NO_SET_PC();
1726     auto bytecode = pc-&gt;as&lt;OpCallEval&gt;();
<span class="line-modified">1727     JSValue calleeAsValue = getNonConstantOperand(callFrame, bytecode.m_callee);</span>
1728 
<span class="line-modified">1729     CallFrame* calleeFrame = callFrame - bytecode.m_argv;</span>
1730 
<span class="line-modified">1731     calleeFrame-&gt;setArgumentCountIncludingThis(bytecode.m_argc);</span>
<span class="line-modified">1732     calleeFrame-&gt;setCallerFrame(callFrame);</span>
<span class="line-modified">1733     calleeFrame-&gt;uncheckedR(VirtualRegister(CallFrameSlot::callee)) = calleeAsValue;</span>
<span class="line-modified">1734     calleeFrame-&gt;setReturnPC(returnPoint.executableAddress());</span>
<span class="line-modified">1735     calleeFrame-&gt;setCodeBlock(nullptr);</span>
<span class="line-modified">1736     callFrame-&gt;setCurrentVPC(pc);</span>
1737 
1738     if (!isHostFunction(calleeAsValue, globalFuncEval))
<span class="line-modified">1739         RELEASE_AND_RETURN(throwScope, setUpCall(calleeFrame, CodeForCall, calleeAsValue));</span>
1740 
<span class="line-modified">1741     vm.hostCallReturnValue = eval(globalObject, calleeFrame);</span>
<span class="line-modified">1742     LLINT_CALL_RETURN(globalObject, calleeFrame, LLInt::getCodePtr(getHostCallReturnValue), CFunctionPtrTag);</span>
1743 }
1744 
1745 LLINT_SLOW_PATH_DECL(slow_path_call_eval)
1746 {
<span class="line-modified">1747     return commonCallEval(callFrame, pc, LLInt::getCodePtr&lt;JSEntryPtrTag&gt;(llint_generic_return_point));</span>
1748 }
1749 
1750 LLINT_SLOW_PATH_DECL(slow_path_call_eval_wide16)
1751 {
<span class="line-modified">1752     return commonCallEval(callFrame, pc, LLInt::getWide16CodePtr&lt;JSEntryPtrTag&gt;(llint_generic_return_point));</span>
1753 }
1754 
1755 LLINT_SLOW_PATH_DECL(slow_path_call_eval_wide32)
1756 {
<span class="line-modified">1757     return commonCallEval(callFrame, pc, LLInt::getWide32CodePtr&lt;JSEntryPtrTag&gt;(llint_generic_return_point));</span>
1758 }
1759 
1760 LLINT_SLOW_PATH_DECL(slow_path_strcat)
1761 {
1762     LLINT_BEGIN();
1763     auto bytecode = pc-&gt;as&lt;OpStrcat&gt;();
<span class="line-modified">1764     LLINT_RETURN(jsStringFromRegisterArray(globalObject, &amp;callFrame-&gt;uncheckedR(bytecode.m_src), bytecode.m_count));</span>
1765 }
1766 
1767 LLINT_SLOW_PATH_DECL(slow_path_to_primitive)
1768 {
1769     LLINT_BEGIN();
1770     auto bytecode = pc-&gt;as&lt;OpToPrimitive&gt;();
<span class="line-modified">1771     LLINT_RETURN(getOperand(callFrame, bytecode.m_src).toPrimitive(globalObject));</span>
1772 }
1773 
1774 LLINT_SLOW_PATH_DECL(slow_path_throw)
1775 {
1776     LLINT_BEGIN();
1777     auto bytecode = pc-&gt;as&lt;OpThrow&gt;();
<span class="line-modified">1778     LLINT_THROW(getOperand(callFrame, bytecode.m_value));</span>
1779 }
1780 
1781 LLINT_SLOW_PATH_DECL(slow_path_handle_traps)
1782 {
1783     LLINT_BEGIN_NO_SET_PC();
1784     ASSERT(vm.needTrapHandling());
<span class="line-modified">1785     vm.handleTraps(globalObject, callFrame);</span>
1786     UNUSED_PARAM(pc);
<span class="line-modified">1787     LLINT_RETURN_TWO(throwScope.exception(), globalObject);</span>
1788 }
1789 
1790 LLINT_SLOW_PATH_DECL(slow_path_debug)
1791 {
1792     LLINT_BEGIN();
1793     auto bytecode = pc-&gt;as&lt;OpDebug&gt;();
<span class="line-modified">1794     vm.interpreter-&gt;debug(callFrame, bytecode.m_debugHookType);</span>
1795 
1796     LLINT_END();
1797 }
1798 
1799 LLINT_SLOW_PATH_DECL(slow_path_handle_exception)
1800 {
<span class="line-modified">1801     VM&amp; vm = callFrame-&gt;deprecatedVM();</span>
<span class="line-modified">1802     SlowPathFrameTracer tracer(vm, callFrame);</span>
<span class="line-modified">1803     genericUnwind(vm, callFrame);</span>
1804     LLINT_END_IMPL();
1805 }
1806 
1807 LLINT_SLOW_PATH_DECL(slow_path_get_from_scope)
1808 {
1809     LLINT_BEGIN();
1810     auto bytecode = pc-&gt;as&lt;OpGetFromScope&gt;();
<span class="line-modified">1811     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
<span class="line-modified">1812     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_var);</span>
<span class="line-modified">1813     JSObject* scope = jsCast&lt;JSObject*&gt;(getNonConstantOperand(callFrame, bytecode.m_scope));</span>
1814 
1815     // ModuleVar is always converted to ClosureVar for get_from_scope.
1816     ASSERT(metadata.m_getPutInfo.resolveType() != ModuleVar);
1817 
<span class="line-modified">1818     LLINT_RETURN(scope-&gt;getPropertySlot(globalObject, ident, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {</span>
1819         if (!found) {
1820             if (metadata.m_getPutInfo.resolveMode() == ThrowIfNotFound)
<span class="line-modified">1821                 return throwException(globalObject, throwScope, createUndefinedVariableError(globalObject, ident));</span>
1822             return jsUndefined();
1823         }
1824 
1825         JSValue result = JSValue();
1826         if (scope-&gt;isGlobalLexicalEnvironment()) {
1827             // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
<span class="line-modified">1828             result = slot.getValue(globalObject, ident);</span>
1829             if (result == jsTDZValue())
<span class="line-modified">1830                 return throwException(globalObject, throwScope, createTDZError(globalObject));</span>
1831         }
1832 
<span class="line-modified">1833         CommonSlowPaths::tryCacheGetFromScopeGlobal(globalObject, codeBlock, vm, bytecode, scope, slot, ident);</span>
1834 
1835         if (!result)
<span class="line-modified">1836             return slot.getValue(globalObject, ident);</span>
1837         return result;
1838     }));
1839 }
1840 
1841 LLINT_SLOW_PATH_DECL(slow_path_put_to_scope)
1842 {
1843     LLINT_BEGIN();
1844 
1845     auto bytecode = pc-&gt;as&lt;OpPutToScope&gt;();
<span class="line-modified">1846     auto&amp; metadata = bytecode.metadata(codeBlock);</span>

1847     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_var);
<span class="line-modified">1848     JSObject* scope = jsCast&lt;JSObject*&gt;(getNonConstantOperand(callFrame, bytecode.m_scope));</span>
<span class="line-modified">1849     JSValue value = getOperand(callFrame, bytecode.m_value);</span>
1850     if (metadata.m_getPutInfo.resolveType() == LocalClosureVar) {
1851         JSLexicalEnvironment* environment = jsCast&lt;JSLexicalEnvironment*&gt;(scope);
1852         environment-&gt;variableAt(ScopeOffset(metadata.m_operand)).set(vm, environment, value);
1853 
1854         // Have to do this *after* the write, because if this puts the set into IsWatched, then we need
1855         // to have already changed the value of the variable. Otherwise we might watch and constant-fold
1856         // to the Undefined value from before the assignment.
1857         if (metadata.m_watchpointSet)
1858             metadata.m_watchpointSet-&gt;touch(vm, &quot;Executed op_put_scope&lt;LocalClosureVar&gt;&quot;);
1859         LLINT_END();
1860     }
1861 
<span class="line-modified">1862     bool hasProperty = scope-&gt;hasProperty(globalObject, ident);</span>
1863     LLINT_CHECK_EXCEPTION();
1864     if (hasProperty
1865         &amp;&amp; scope-&gt;isGlobalLexicalEnvironment()
1866         &amp;&amp; !isInitialization(metadata.m_getPutInfo.initializationMode())) {
1867         // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
1868         PropertySlot slot(scope, PropertySlot::InternalMethodType::Get);
<span class="line-modified">1869         JSGlobalLexicalEnvironment::getOwnPropertySlot(scope, globalObject, ident, slot);</span>
<span class="line-modified">1870         if (slot.getValue(globalObject, ident) == jsTDZValue())</span>
<span class="line-modified">1871             LLINT_THROW(createTDZError(globalObject));</span>
1872     }
1873 
1874     if (metadata.m_getPutInfo.resolveMode() == ThrowIfNotFound &amp;&amp; !hasProperty)
<span class="line-modified">1875         LLINT_THROW(createUndefinedVariableError(globalObject, ident));</span>
1876 
1877     PutPropertySlot slot(scope, codeBlock-&gt;isStrictMode(), PutPropertySlot::UnknownContext, isInitialization(metadata.m_getPutInfo.initializationMode()));
<span class="line-modified">1878     scope-&gt;methodTable(vm)-&gt;put(scope, globalObject, ident, value, slot);</span>
1879 
<span class="line-modified">1880     CommonSlowPaths::tryCachePutToScopeGlobal(globalObject, codeBlock, bytecode, scope, slot, ident);</span>
1881 
1882     LLINT_END();
1883 }
1884 
1885 LLINT_SLOW_PATH_DECL(slow_path_check_if_exception_is_uncatchable_and_notify_profiler)
1886 {
1887     LLINT_BEGIN();
<span class="line-added">1888     UNUSED_PARAM(globalObject);</span>
1889     RELEASE_ASSERT(!!throwScope.exception());
1890 
1891     if (isTerminatedExecutionException(vm, throwScope.exception()))
1892         LLINT_RETURN_TWO(pc, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)));
<span class="line-modified">1893     LLINT_RETURN_TWO(pc, nullptr);</span>
1894 }
1895 
1896 LLINT_SLOW_PATH_DECL(slow_path_log_shadow_chicken_prologue)
1897 {
1898     LLINT_BEGIN();
1899 
1900     auto bytecode = pc-&gt;as&lt;OpLogShadowChickenPrologue&gt;();
<span class="line-modified">1901     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
1902     ShadowChicken* shadowChicken = vm.shadowChicken();
1903     RELEASE_ASSERT(shadowChicken);
<span class="line-modified">1904     shadowChicken-&gt;log(vm, callFrame, ShadowChicken::Packet::prologue(callFrame-&gt;jsCallee(), callFrame, callFrame-&gt;callerFrame(), scope));</span>
1905 
1906     LLINT_END();
1907 }
1908 
1909 LLINT_SLOW_PATH_DECL(slow_path_log_shadow_chicken_tail)
1910 {
1911     LLINT_BEGIN();
1912 
1913     auto bytecode = pc-&gt;as&lt;OpLogShadowChickenTail&gt;();
<span class="line-modified">1914     JSValue thisValue = getNonConstantOperand(callFrame, bytecode.m_thisValue);</span>
<span class="line-modified">1915     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
<span class="line-added">1916 </span>
<span class="line-added">1917     CallSiteIndex callSiteIndex(BytecodeIndex(codeBlock-&gt;bytecodeOffset(pc)));</span>
1918 





1919     ShadowChicken* shadowChicken = vm.shadowChicken();
1920     RELEASE_ASSERT(shadowChicken);
<span class="line-modified">1921     shadowChicken-&gt;log(vm, callFrame, ShadowChicken::Packet::tail(callFrame, thisValue, scope, codeBlock, callSiteIndex));</span>
1922 
1923     LLINT_END();
1924 }
1925 
1926 LLINT_SLOW_PATH_DECL(slow_path_profile_catch)
1927 {
1928     LLINT_BEGIN();
1929 
<span class="line-modified">1930     codeBlock-&gt;ensureCatchLivenessIsComputedForBytecodeIndex(callFrame-&gt;bytecodeIndex());</span>
1931 
1932     auto bytecode = pc-&gt;as&lt;OpCatch&gt;();
<span class="line-modified">1933     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
<span class="line-modified">1934     metadata.m_buffer-&gt;forEach([&amp;] (ValueProfileAndVirtualRegister&amp; profile) {</span>
<span class="line-modified">1935         profile.m_buckets[0] = JSValue::encode(callFrame-&gt;uncheckedR(profile.m_operand).jsValue());</span>
1936     });
1937 
1938     LLINT_END();
1939 }
1940 
1941 LLINT_SLOW_PATH_DECL(slow_path_super_sampler_begin)
1942 {
1943     // FIXME: It seems like we should be able to do this in asm but llint doesn&#39;t seem to like global variables.
1944     // See: https://bugs.webkit.org/show_bug.cgi?id=179438
<span class="line-modified">1945     UNUSED_PARAM(callFrame);</span>
1946     g_superSamplerCount++;
1947     LLINT_END_IMPL();
1948 }
1949 
1950 LLINT_SLOW_PATH_DECL(slow_path_super_sampler_end)
1951 {
1952     // FIXME: It seems like we should be able to do this in asm but llint doesn&#39;t seem to like global variables.
1953     // See: https://bugs.webkit.org/show_bug.cgi?id=179438
<span class="line-modified">1954     UNUSED_PARAM(callFrame);</span>
1955     g_superSamplerCount--;
1956     LLINT_END_IMPL();
1957 }
1958 
1959 LLINT_SLOW_PATH_DECL(slow_path_out_of_line_jump_target)
1960 {
<span class="line-modified">1961     pc = callFrame-&gt;codeBlock()-&gt;outOfLineJumpTarget(pc);</span>

1962     LLINT_END_IMPL();
1963 }
1964 
<span class="line-added">1965 template&lt;typename Opcode&gt;</span>
<span class="line-added">1966 static void handleVarargsCheckpoint(VM&amp; vm, CallFrame* callFrame, JSGlobalObject* globalObject, const Opcode&amp; bytecode, CheckpointOSRExitSideState&amp; sideState)</span>
<span class="line-added">1967 {</span>
<span class="line-added">1968     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">1969     unsigned argumentCountIncludingThis = sideState.tmps[Opcode::argCountIncludingThis].asUInt32();</span>
<span class="line-added">1970     unsigned firstVarArg = bytecode.m_firstVarArg;</span>
<span class="line-added">1971 </span>
<span class="line-added">1972     MarkedArgumentBuffer args;</span>
<span class="line-added">1973     args.fill(argumentCountIncludingThis - 1, [&amp;] (JSValue* buffer) {</span>
<span class="line-added">1974         loadVarargs(globalObject, buffer, callFrame-&gt;r(bytecode.m_arguments).jsValue(), firstVarArg, argumentCountIncludingThis - 1);</span>
<span class="line-added">1975     });</span>
<span class="line-added">1976     if (args.hasOverflowed()) {</span>
<span class="line-added">1977         throwStackOverflowError(globalObject, scope);</span>
<span class="line-added">1978         return;</span>
<span class="line-added">1979     }</span>
<span class="line-added">1980 </span>
<span class="line-added">1981     RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-added">1982 </span>
<span class="line-added">1983     JSValue result;</span>
<span class="line-added">1984     if (Opcode::opcodeID != op_construct_varargs)</span>
<span class="line-added">1985         result = call(globalObject, getOperand(callFrame, bytecode.m_callee), getOperand(callFrame, bytecode.m_thisValue), args, &quot;&quot;);</span>
<span class="line-added">1986     else</span>
<span class="line-added">1987         result = construct(globalObject, getOperand(callFrame, bytecode.m_callee), getOperand(callFrame, bytecode.m_thisValue), args, &quot;&quot;);</span>
<span class="line-added">1988 </span>
<span class="line-added">1989     RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-added">1990     callFrame-&gt;uncheckedR(bytecode.m_dst) = result;</span>
<span class="line-added">1991 }</span>
<span class="line-added">1992 </span>
<span class="line-added">1993 inline SlowPathReturnType dispatchToNextInstruction(CodeBlock* codeBlock, InstructionStream::Ref pc)</span>
<span class="line-added">1994 {</span>
<span class="line-added">1995     RELEASE_ASSERT(!codeBlock-&gt;vm().exceptionForInspection());</span>
<span class="line-added">1996     if (Options::forceOSRExitToLLInt() || codeBlock-&gt;jitType() == JITType::InterpreterThunk) {</span>
<span class="line-added">1997         const Instruction* nextPC = pc.next().ptr();</span>
<span class="line-added">1998         auto nextBytecode = LLInt::getCodePtr&lt;JSEntryPtrTag&gt;(*pc.next().ptr());</span>
<span class="line-added">1999         return encodeResult(nextPC, nextBytecode.executableAddress());</span>
<span class="line-added">2000     }</span>
<span class="line-added">2001 </span>
<span class="line-added">2002 #if ENABLE(JIT)</span>
<span class="line-added">2003     ASSERT(codeBlock-&gt;jitType() == JITType::BaselineJIT);</span>
<span class="line-added">2004     BytecodeIndex nextBytecodeIndex = pc.next().index();</span>
<span class="line-added">2005     auto nextBytecode = codeBlock-&gt;jitCodeMap().find(nextBytecodeIndex);</span>
<span class="line-added">2006     return encodeResult(nullptr, nextBytecode.executableAddress());</span>
<span class="line-added">2007 #endif</span>
<span class="line-added">2008     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">2009 }</span>
<span class="line-added">2010 </span>
<span class="line-added">2011 extern &quot;C&quot; SlowPathReturnType slow_path_checkpoint_osr_exit_from_inlined_call(CallFrame* callFrame, EncodedJSValue result)</span>
<span class="line-added">2012 {</span>
<span class="line-added">2013     // Since all our calling checkpoints do right now is move result into our dest we can just do that here and return.</span>
<span class="line-added">2014     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
<span class="line-added">2015     VM&amp; vm = codeBlock-&gt;vm();</span>
<span class="line-added">2016     SlowPathFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2017 </span>
<span class="line-added">2018     std::unique_ptr&lt;CheckpointOSRExitSideState&gt; sideState = vm.findCheckpointOSRSideState(callFrame);</span>
<span class="line-added">2019     BytecodeIndex bytecodeIndex = sideState-&gt;bytecodeIndex;</span>
<span class="line-added">2020     auto pc = codeBlock-&gt;instructions().at(bytecodeIndex);</span>
<span class="line-added">2021 </span>
<span class="line-added">2022     auto opcode = pc-&gt;opcodeID();</span>
<span class="line-added">2023     switch (opcode) {</span>
<span class="line-added">2024     case op_call_varargs: {</span>
<span class="line-added">2025         callFrame-&gt;uncheckedR(pc-&gt;as&lt;OpCallVarargs&gt;().m_dst) = JSValue::decode(result);</span>
<span class="line-added">2026         break;</span>
<span class="line-added">2027     }</span>
<span class="line-added">2028     case op_construct_varargs: {</span>
<span class="line-added">2029         callFrame-&gt;uncheckedR(pc-&gt;as&lt;OpConstructVarargs&gt;().m_dst) = JSValue::decode(result);</span>
<span class="line-added">2030         break;</span>
<span class="line-added">2031     }</span>
<span class="line-added">2032     // op_tail_call_varargs should never return if the thing it was calling was inlined.</span>
<span class="line-added">2033     default:</span>
<span class="line-added">2034         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">2035         break;</span>
<span class="line-added">2036     }</span>
<span class="line-added">2037 </span>
<span class="line-added">2038     return dispatchToNextInstruction(codeBlock, pc);</span>
<span class="line-added">2039 }</span>
<span class="line-added">2040 </span>
<span class="line-added">2041 extern &quot;C&quot; SlowPathReturnType slow_path_checkpoint_osr_exit(CallFrame* callFrame, EncodedJSValue /* needed for cCall2 in CLoop */)</span>
<span class="line-added">2042 {</span>
<span class="line-added">2043     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
<span class="line-added">2044     VM&amp; vm = codeBlock-&gt;vm();</span>
<span class="line-added">2045     SlowPathFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2046     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">2047 </span>
<span class="line-added">2048     JSGlobalObject* globalObject = codeBlock-&gt;globalObject();</span>
<span class="line-added">2049 </span>
<span class="line-added">2050     std::unique_ptr&lt;CheckpointOSRExitSideState&gt; sideState = vm.findCheckpointOSRSideState(callFrame);</span>
<span class="line-added">2051     BytecodeIndex bytecodeIndex = sideState-&gt;bytecodeIndex;</span>
<span class="line-added">2052     ASSERT(bytecodeIndex.checkpoint());</span>
<span class="line-added">2053 </span>
<span class="line-added">2054     auto pc = codeBlock-&gt;instructions().at(bytecodeIndex);</span>
<span class="line-added">2055 </span>
<span class="line-added">2056     auto opcode = pc-&gt;opcodeID();</span>
<span class="line-added">2057     switch (opcode) {</span>
<span class="line-added">2058     case op_call_varargs:</span>
<span class="line-added">2059         handleVarargsCheckpoint(vm, callFrame, globalObject, pc-&gt;as&lt;OpCallVarargs&gt;(), *sideState.get());</span>
<span class="line-added">2060         break;</span>
<span class="line-added">2061     case op_construct_varargs:</span>
<span class="line-added">2062         handleVarargsCheckpoint(vm, callFrame, globalObject, pc-&gt;as&lt;OpConstructVarargs&gt;(), *sideState.get());</span>
<span class="line-added">2063         break;</span>
<span class="line-added">2064     case op_tail_call_varargs:</span>
<span class="line-added">2065         ASSERT_WITH_MESSAGE(pc.next()-&gt;opcodeID() == op_ret || pc.next()-&gt;opcodeID() == op_jmp, &quot;We strongly assume all tail calls are followed by an op_ret (or sometimes a jmp to a ret).&quot;);</span>
<span class="line-added">2066         handleVarargsCheckpoint(vm, callFrame, globalObject, pc-&gt;as&lt;OpTailCallVarargs&gt;(), *sideState.get());</span>
<span class="line-added">2067         break;</span>
<span class="line-added">2068 </span>
<span class="line-added">2069     default:</span>
<span class="line-added">2070         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">2071         break;</span>
<span class="line-added">2072     }</span>
<span class="line-added">2073     if (UNLIKELY(scope.exception()))</span>
<span class="line-added">2074         return encodeResult(returnToThrow(vm), 0);</span>
<span class="line-added">2075 </span>
<span class="line-added">2076     return dispatchToNextInstruction(codeBlock, pc);</span>
<span class="line-added">2077 }</span>
<span class="line-added">2078 </span>
2079 extern &quot;C&quot; SlowPathReturnType llint_throw_stack_overflow_error(VM* vm, ProtoCallFrame* protoFrame)
2080 {
<span class="line-modified">2081     CallFrame* callFrame = vm-&gt;topCallFrame;</span>
2082     auto scope = DECLARE_THROW_SCOPE(*vm);
<span class="line-modified">2083     JSGlobalObject* globalObject = nullptr;</span>
<span class="line-modified">2084     if (callFrame)</span>
<span class="line-modified">2085         globalObject = callFrame-&gt;lexicalGlobalObject(*vm);</span>
<span class="line-modified">2086     else</span>
<span class="line-added">2087         globalObject = protoFrame-&gt;callee()-&gt;globalObject(*vm);</span>
<span class="line-added">2088     throwStackOverflowError(globalObject, scope);</span>
2089     return encodeResult(0, 0);
2090 }
2091 
2092 #if ENABLE(C_LOOP)
2093 extern &quot;C&quot; SlowPathReturnType llint_stack_check_at_vm_entry(VM* vm, Register* newTopOfStack)
2094 {
2095     bool success = vm-&gt;ensureStackCapacityFor(newTopOfStack);
2096     return encodeResult(reinterpret_cast&lt;void*&gt;(success), 0);
2097 }
2098 #endif
2099 
<span class="line-modified">2100 extern &quot;C&quot; void llint_write_barrier_slow(CallFrame* callFrame, JSCell* cell)</span>
2101 {
<span class="line-modified">2102     VM&amp; vm = callFrame-&gt;codeBlock()-&gt;vm();</span>
2103     vm.heap.writeBarrier(cell);
2104 }
2105 
2106 extern &quot;C&quot; NO_RETURN_DUE_TO_CRASH void llint_crash()
2107 {
2108     CRASH();
2109 }
2110 
2111 } } // namespace JSC::LLInt
</pre>
</td>
</tr>
</table>
<center><a href="LLIntPCRanges.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LLIntSlowPaths.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/arm.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../llint/LowLevelInterpreter64.asm.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="arm64.rb.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/arm.rb</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23 # THE POSSIBILITY OF SUCH DAMAGE.
 24 
 25 require &quot;config&quot;
 26 require &quot;ast&quot;
 27 require &quot;opt&quot;
 28 require &quot;risc&quot;
 29 
 30 # GPR conventions, to match the baseline JIT
 31 #
 32 #  x0 =&gt; t0, a0, r0
 33 #  x1 =&gt; t1, a1, r1
 34 #  x2 =&gt; t2, a2, r2
 35 #  x3 =&gt; t3, a3, r3
 36 #  x6 =&gt;            (callee-save scratch)
 37 #  x7 =&gt; cfr
 38 #  x8 =&gt; t4         (callee-save)
 39 #  x9 =&gt; t5         (callee-save)
<span class="line-modified"> 40 # x10 =&gt;            (callee-save scratch)</span>
 41 # x11 =&gt; cfr, csr0  (callee-save, metadataTable)
 42 # x12 =&gt;            (callee-save scratch)
 43 #  lr =&gt; lr
 44 #  sp =&gt; sp
 45 #  pc =&gt; pc
 46 #
 47 # FPR conventions, to match the baseline JIT
 48 #
 49 # d0 =&gt; ft0, fa0, fr
 50 # d1 =&gt; ft1, fa1
 51 # d2 =&gt; ft2
 52 # d3 =&gt; ft3
 53 # d4 =&gt; ft4
 54 # d5 =&gt; ft5
 55 # d6 =&gt;              (scratch)
 56 # d7 =&gt;              (scratch)
 57 
 58 class Node
 59     def armSingle
 60         doubleOperand = armOperand
 61         raise &quot;Bogus register name #{doubleOperand}&quot; unless doubleOperand =~ /^d/
 62         &quot;s&quot; + ($~.post_match.to_i * 2).to_s
 63     end
 64 end
 65 
 66 class SpecialRegister
 67     def armOperand
 68         @name
 69     end
 70 end
 71 
<span class="line-modified"> 72 ARM_EXTRA_GPRS = [SpecialRegister.new(&quot;r6&quot;), SpecialRegister.new(&quot;r10&quot;), SpecialRegister.new(&quot;r12&quot;)]</span>
 73 ARM_EXTRA_FPRS = [SpecialRegister.new(&quot;d7&quot;)]
 74 ARM_SCRATCH_FPR = SpecialRegister.new(&quot;d6&quot;)
 75 OS_DARWIN = ((RUBY_PLATFORM =~ /darwin/i) != nil)
 76 
 77 def armMoveImmediate(value, register)
 78     # Currently we only handle the simple cases, and fall back to mov/movt for the complex ones.
 79     if value.is_a? String
 80       $asm.puts &quot;mov #{register.armOperand}, (#{value})&quot;
 81     elsif value &gt;= 0 &amp;&amp; value &lt; 256
 82         $asm.puts &quot;mov #{register.armOperand}, \##{value}&quot;
 83     elsif (~value) &gt;= 0 &amp;&amp; (~value) &lt; 256
 84         $asm.puts &quot;mvn #{register.armOperand}, \##{~value}&quot;
 85     else
 86         $asm.puts &quot;movw #{register.armOperand}, \##{value &amp; 0xffff}&quot;
 87         if (value &amp; 0xffff0000) != 0
 88             $asm.puts &quot;movt #{register.armOperand}, \##{(value &gt;&gt; 16) &amp; 0xffff}&quot;
 89         end
 90     end
 91 end
 92 
 93 class RegisterID
 94     def armOperand
 95         case name
 96         when &quot;t0&quot;, &quot;a0&quot;, &quot;r0&quot;
 97             &quot;r0&quot;
 98         when &quot;t1&quot;, &quot;a1&quot;, &quot;r1&quot;
 99             &quot;r1&quot;
100         when &quot;t2&quot;, &quot;a2&quot;
101             &quot;r2&quot;
102         when &quot;a3&quot;
103             &quot;r3&quot;
104         when &quot;t3&quot;
<span class="line-modified">105             &quot;r4&quot;</span>
106         when &quot;t4&quot;
107             &quot;r8&quot;
108         when &quot;t5&quot;
109             &quot;r9&quot;
110         when &quot;cfr&quot;
111             &quot;r7&quot;
112         when &quot;csr0&quot;
113             &quot;r11&quot;


114         when &quot;lr&quot;
115             &quot;lr&quot;
116         when &quot;sp&quot;
117             &quot;sp&quot;
118         when &quot;pc&quot;
119             &quot;pc&quot;
120         else
121             raise &quot;Bad register #{name} for ARM at #{codeOriginString}&quot;
122         end
123     end
124 end
125 
126 class FPRegisterID
127     def armOperand
128         case name
129         when &quot;ft0&quot;, &quot;fr&quot;, &quot;fa0&quot;
130             &quot;d0&quot;
131         when &quot;ft1&quot;, &quot;fa1&quot;
132             &quot;d1&quot;
133         when &quot;ft2&quot;
</pre>
<hr />
<pre>
282         getModifiedListARMCommon
283     end
284 
285     def getModifiedListARMCommon
286         result = @list
287         result = riscLowerSimpleBranchOps(result)
288         result = riscLowerHardBranchOps(result)
289         result = riscLowerShiftOps(result)
290         result = armLowerLabelReferences(result)
291         result = riscLowerMalformedAddresses(result) {
292             | node, address |
293             if address.is_a? BaseIndex
294                 address.offset.value == 0
295             elsif address.is_a? Address
296                 (-0xff..0xfff).include? address.offset.value
297             else
298                 false
299             end
300         }
301         result = riscLowerMalformedAddressesDouble(result)
<span class="line-modified">302         result = riscLowerMisplacedImmediates(result, [&quot;storeb&quot;, &quot;storei&quot;, &quot;storep&quot;, &quot;storeq&quot;])</span>
<span class="line-modified">303         result = riscLowerMalformedImmediates(result, 0..0xff)</span>
304         result = riscLowerMisplacedAddresses(result)
305         result = riscLowerRegisterReuse(result)
306         result = assignRegistersToTemporaries(result, :gpr, ARM_EXTRA_GPRS)
307         result = assignRegistersToTemporaries(result, :fpr, ARM_EXTRA_FPRS)
308         result = armLowerStackPointerInComparison(result)
309         return result
310     end
311 end
312 
313 def armOperands(operands)
314     operands.map{|v| v.armOperand}.join(&quot;, &quot;)
315 end
316 
317 def armFlippedOperands(operands)
318     armOperands([operands[-1]] + operands[0..-2])
319 end
320 
321 def emitArmCompact(opcode2, opcode3, operands)
322     if operands.size == 3
323         $asm.puts &quot;#{opcode3} #{armFlippedOperands(operands)}&quot;
</pre>
<hr />
<pre>
401                         $asm.puts &quot;mov #{operands[2].armOperand}, #{operands[1].armOperand}&quot;
402                     end
403                 else
404                     $asm.puts &quot;adds #{operands[2].armOperand}, #{operands[1].armOperand}, #{operands[0].armOperand}&quot;
405                 end
406             elsif operands.size == 3 and operands[0].register?
407                 raise unless operands[1].register?
408                 raise unless operands[2].register?
409                 $asm.puts &quot;adds #{armFlippedOperands(operands)}&quot;
410             else
411                 if operands[0].immediate?
412                     unless Immediate.new(nil, 0) == operands[0]
413                         $asm.puts &quot;adds #{armFlippedOperands(operands)}&quot;
414                     end
415                 else
416                     $asm.puts &quot;add#{suffix} #{armFlippedOperands(operands)}&quot;
417                 end
418             end
419         when &quot;andi&quot;, &quot;andp&quot;
420             emitArmCompact(&quot;ands&quot;, &quot;and&quot;, operands)
<span class="line-modified">421         when &quot;ori&quot;, &quot;orp&quot;</span>
422             emitArmCompact(&quot;orrs&quot;, &quot;orr&quot;, operands)
423         when &quot;oris&quot;
424             emitArmCompact(&quot;orrs&quot;, &quot;orrs&quot;, operands)
425         when &quot;xori&quot;, &quot;xorp&quot;
426             emitArmCompact(&quot;eors&quot;, &quot;eor&quot;, operands)
427         when &quot;lshifti&quot;, &quot;lshiftp&quot;
428             emitArmCompact(&quot;lsls&quot;, &quot;lsls&quot;, operands)
429         when &quot;rshifti&quot;, &quot;rshiftp&quot;
430             emitArmCompact(&quot;asrs&quot;, &quot;asrs&quot;, operands)
431         when &quot;urshifti&quot;, &quot;urshiftp&quot;
432             emitArmCompact(&quot;lsrs&quot;, &quot;lsrs&quot;, operands)
433         when &quot;muli&quot;, &quot;mulp&quot;
434             emitArm(&quot;mul&quot;, operands)
435         when &quot;subi&quot;, &quot;subp&quot;, &quot;subis&quot;
436             emitArmCompact(&quot;subs&quot;, &quot;subs&quot;, operands)
437         when &quot;negi&quot;, &quot;negp&quot;
438             $asm.puts &quot;rsbs #{operands[0].armOperand}, #{operands[0].armOperand}, \#0&quot;
439         when &quot;noti&quot;
440             $asm.puts &quot;mvns #{operands[0].armOperand}, #{operands[0].armOperand}&quot;
441         when &quot;loadi&quot;, &quot;loadis&quot;, &quot;loadp&quot;
</pre>
<hr />
<pre>
451         when &quot;loadh&quot;
452             $asm.puts &quot;ldrh #{armFlippedOperands(operands)}&quot;
453         when &quot;loadhsi&quot;
454             $asm.puts &quot;ldrsh.w #{armFlippedOperands(operands)}&quot;
455         when &quot;storeh&quot;
456             $asm.puts &quot;strh #{armOperands(operands)}&quot;
457         when &quot;loadd&quot;
458             $asm.puts &quot;vldr.64 #{armFlippedOperands(operands)}&quot;
459         when &quot;stored&quot;
460             $asm.puts &quot;vstr.64 #{armOperands(operands)}&quot;
461         when &quot;addd&quot;
462             emitArm(&quot;vadd.f64&quot;, operands)
463         when &quot;divd&quot;
464             emitArm(&quot;vdiv.f64&quot;, operands)
465         when &quot;subd&quot;
466             emitArm(&quot;vsub.f64&quot;, operands)
467         when &quot;muld&quot;
468             emitArm(&quot;vmul.f64&quot;, operands)
469         when &quot;sqrtd&quot;
470             $asm.puts &quot;vsqrt.f64 #{armFlippedOperands(operands)}&quot;
<span class="line-modified">471         when &quot;ci2d&quot;</span>
472             $asm.puts &quot;vmov #{operands[1].armSingle}, #{operands[0].armOperand}&quot;
473             $asm.puts &quot;vcvt.f64.s32 #{operands[1].armOperand}, #{operands[1].armSingle}&quot;
474         when &quot;bdeq&quot;
475             emitArmDoubleBranch(&quot;beq&quot;, operands)
476         when &quot;bdneq&quot;
477             $asm.puts &quot;vcmpe.f64 #{armOperands(operands[0..1])}&quot;
478             $asm.puts &quot;vmrs apsr_nzcv, fpscr&quot;
479             isUnordered = LocalLabel.unique(&quot;bdneq&quot;)
480             $asm.puts &quot;bvs #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;
481             $asm.puts &quot;bne #{operands[2].asmLabel}&quot;
482             isUnordered.lower(&quot;ARM&quot;)
483         when &quot;bdgt&quot;
484             emitArmDoubleBranch(&quot;bgt&quot;, operands)
485         when &quot;bdgteq&quot;
486             emitArmDoubleBranch(&quot;bge&quot;, operands)
487         when &quot;bdlt&quot;
488             emitArmDoubleBranch(&quot;bmi&quot;, operands)
489         when &quot;bdlteq&quot;
490             emitArmDoubleBranch(&quot;bls&quot;, operands)
491         when &quot;bdequn&quot;
</pre>
</td>
<td>
<hr />
<pre>
 20 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23 # THE POSSIBILITY OF SUCH DAMAGE.
 24 
 25 require &quot;config&quot;
 26 require &quot;ast&quot;
 27 require &quot;opt&quot;
 28 require &quot;risc&quot;
 29 
 30 # GPR conventions, to match the baseline JIT
 31 #
 32 #  x0 =&gt; t0, a0, r0
 33 #  x1 =&gt; t1, a1, r1
 34 #  x2 =&gt; t2, a2, r2
 35 #  x3 =&gt; t3, a3, r3
 36 #  x6 =&gt;            (callee-save scratch)
 37 #  x7 =&gt; cfr
 38 #  x8 =&gt; t4         (callee-save)
 39 #  x9 =&gt; t5         (callee-save)
<span class="line-modified"> 40 # x10 =&gt; csr1       (callee-save, PB)</span>
 41 # x11 =&gt; cfr, csr0  (callee-save, metadataTable)
 42 # x12 =&gt;            (callee-save scratch)
 43 #  lr =&gt; lr
 44 #  sp =&gt; sp
 45 #  pc =&gt; pc
 46 #
 47 # FPR conventions, to match the baseline JIT
 48 #
 49 # d0 =&gt; ft0, fa0, fr
 50 # d1 =&gt; ft1, fa1
 51 # d2 =&gt; ft2
 52 # d3 =&gt; ft3
 53 # d4 =&gt; ft4
 54 # d5 =&gt; ft5
 55 # d6 =&gt;              (scratch)
 56 # d7 =&gt;              (scratch)
 57 
 58 class Node
 59     def armSingle
 60         doubleOperand = armOperand
 61         raise &quot;Bogus register name #{doubleOperand}&quot; unless doubleOperand =~ /^d/
 62         &quot;s&quot; + ($~.post_match.to_i * 2).to_s
 63     end
 64 end
 65 
 66 class SpecialRegister
 67     def armOperand
 68         @name
 69     end
 70 end
 71 
<span class="line-modified"> 72 ARM_EXTRA_GPRS = [SpecialRegister.new(&quot;r6&quot;), SpecialRegister.new(&quot;r4&quot;), SpecialRegister.new(&quot;r12&quot;)]</span>
 73 ARM_EXTRA_FPRS = [SpecialRegister.new(&quot;d7&quot;)]
 74 ARM_SCRATCH_FPR = SpecialRegister.new(&quot;d6&quot;)
 75 OS_DARWIN = ((RUBY_PLATFORM =~ /darwin/i) != nil)
 76 
 77 def armMoveImmediate(value, register)
 78     # Currently we only handle the simple cases, and fall back to mov/movt for the complex ones.
 79     if value.is_a? String
 80       $asm.puts &quot;mov #{register.armOperand}, (#{value})&quot;
 81     elsif value &gt;= 0 &amp;&amp; value &lt; 256
 82         $asm.puts &quot;mov #{register.armOperand}, \##{value}&quot;
 83     elsif (~value) &gt;= 0 &amp;&amp; (~value) &lt; 256
 84         $asm.puts &quot;mvn #{register.armOperand}, \##{~value}&quot;
 85     else
 86         $asm.puts &quot;movw #{register.armOperand}, \##{value &amp; 0xffff}&quot;
 87         if (value &amp; 0xffff0000) != 0
 88             $asm.puts &quot;movt #{register.armOperand}, \##{(value &gt;&gt; 16) &amp; 0xffff}&quot;
 89         end
 90     end
 91 end
 92 
 93 class RegisterID
 94     def armOperand
 95         case name
 96         when &quot;t0&quot;, &quot;a0&quot;, &quot;r0&quot;
 97             &quot;r0&quot;
 98         when &quot;t1&quot;, &quot;a1&quot;, &quot;r1&quot;
 99             &quot;r1&quot;
100         when &quot;t2&quot;, &quot;a2&quot;
101             &quot;r2&quot;
102         when &quot;a3&quot;
103             &quot;r3&quot;
104         when &quot;t3&quot;
<span class="line-modified">105             &quot;r3&quot;</span>
106         when &quot;t4&quot;
107             &quot;r8&quot;
108         when &quot;t5&quot;
109             &quot;r9&quot;
110         when &quot;cfr&quot;
111             &quot;r7&quot;
112         when &quot;csr0&quot;
113             &quot;r11&quot;
<span class="line-added">114         when &quot;csr1&quot;</span>
<span class="line-added">115             &quot;r10&quot;</span>
116         when &quot;lr&quot;
117             &quot;lr&quot;
118         when &quot;sp&quot;
119             &quot;sp&quot;
120         when &quot;pc&quot;
121             &quot;pc&quot;
122         else
123             raise &quot;Bad register #{name} for ARM at #{codeOriginString}&quot;
124         end
125     end
126 end
127 
128 class FPRegisterID
129     def armOperand
130         case name
131         when &quot;ft0&quot;, &quot;fr&quot;, &quot;fa0&quot;
132             &quot;d0&quot;
133         when &quot;ft1&quot;, &quot;fa1&quot;
134             &quot;d1&quot;
135         when &quot;ft2&quot;
</pre>
<hr />
<pre>
284         getModifiedListARMCommon
285     end
286 
287     def getModifiedListARMCommon
288         result = @list
289         result = riscLowerSimpleBranchOps(result)
290         result = riscLowerHardBranchOps(result)
291         result = riscLowerShiftOps(result)
292         result = armLowerLabelReferences(result)
293         result = riscLowerMalformedAddresses(result) {
294             | node, address |
295             if address.is_a? BaseIndex
296                 address.offset.value == 0
297             elsif address.is_a? Address
298                 (-0xff..0xfff).include? address.offset.value
299             else
300                 false
301             end
302         }
303         result = riscLowerMalformedAddressesDouble(result)
<span class="line-modified">304         result = riscLowerMisplacedImmediates(result, [&quot;storeb&quot;, &quot;storeh&quot;, &quot;storei&quot;, &quot;storep&quot;, &quot;storeq&quot;])</span>
<span class="line-modified">305         result = riscLowerMalformedImmediates(result, 0..0xff, 0..0x0ff)</span>
306         result = riscLowerMisplacedAddresses(result)
307         result = riscLowerRegisterReuse(result)
308         result = assignRegistersToTemporaries(result, :gpr, ARM_EXTRA_GPRS)
309         result = assignRegistersToTemporaries(result, :fpr, ARM_EXTRA_FPRS)
310         result = armLowerStackPointerInComparison(result)
311         return result
312     end
313 end
314 
315 def armOperands(operands)
316     operands.map{|v| v.armOperand}.join(&quot;, &quot;)
317 end
318 
319 def armFlippedOperands(operands)
320     armOperands([operands[-1]] + operands[0..-2])
321 end
322 
323 def emitArmCompact(opcode2, opcode3, operands)
324     if operands.size == 3
325         $asm.puts &quot;#{opcode3} #{armFlippedOperands(operands)}&quot;
</pre>
<hr />
<pre>
403                         $asm.puts &quot;mov #{operands[2].armOperand}, #{operands[1].armOperand}&quot;
404                     end
405                 else
406                     $asm.puts &quot;adds #{operands[2].armOperand}, #{operands[1].armOperand}, #{operands[0].armOperand}&quot;
407                 end
408             elsif operands.size == 3 and operands[0].register?
409                 raise unless operands[1].register?
410                 raise unless operands[2].register?
411                 $asm.puts &quot;adds #{armFlippedOperands(operands)}&quot;
412             else
413                 if operands[0].immediate?
414                     unless Immediate.new(nil, 0) == operands[0]
415                         $asm.puts &quot;adds #{armFlippedOperands(operands)}&quot;
416                     end
417                 else
418                     $asm.puts &quot;add#{suffix} #{armFlippedOperands(operands)}&quot;
419                 end
420             end
421         when &quot;andi&quot;, &quot;andp&quot;
422             emitArmCompact(&quot;ands&quot;, &quot;and&quot;, operands)
<span class="line-modified">423         when &quot;ori&quot;, &quot;orp&quot;, &quot;orh&quot;</span>
424             emitArmCompact(&quot;orrs&quot;, &quot;orr&quot;, operands)
425         when &quot;oris&quot;
426             emitArmCompact(&quot;orrs&quot;, &quot;orrs&quot;, operands)
427         when &quot;xori&quot;, &quot;xorp&quot;
428             emitArmCompact(&quot;eors&quot;, &quot;eor&quot;, operands)
429         when &quot;lshifti&quot;, &quot;lshiftp&quot;
430             emitArmCompact(&quot;lsls&quot;, &quot;lsls&quot;, operands)
431         when &quot;rshifti&quot;, &quot;rshiftp&quot;
432             emitArmCompact(&quot;asrs&quot;, &quot;asrs&quot;, operands)
433         when &quot;urshifti&quot;, &quot;urshiftp&quot;
434             emitArmCompact(&quot;lsrs&quot;, &quot;lsrs&quot;, operands)
435         when &quot;muli&quot;, &quot;mulp&quot;
436             emitArm(&quot;mul&quot;, operands)
437         when &quot;subi&quot;, &quot;subp&quot;, &quot;subis&quot;
438             emitArmCompact(&quot;subs&quot;, &quot;subs&quot;, operands)
439         when &quot;negi&quot;, &quot;negp&quot;
440             $asm.puts &quot;rsbs #{operands[0].armOperand}, #{operands[0].armOperand}, \#0&quot;
441         when &quot;noti&quot;
442             $asm.puts &quot;mvns #{operands[0].armOperand}, #{operands[0].armOperand}&quot;
443         when &quot;loadi&quot;, &quot;loadis&quot;, &quot;loadp&quot;
</pre>
<hr />
<pre>
453         when &quot;loadh&quot;
454             $asm.puts &quot;ldrh #{armFlippedOperands(operands)}&quot;
455         when &quot;loadhsi&quot;
456             $asm.puts &quot;ldrsh.w #{armFlippedOperands(operands)}&quot;
457         when &quot;storeh&quot;
458             $asm.puts &quot;strh #{armOperands(operands)}&quot;
459         when &quot;loadd&quot;
460             $asm.puts &quot;vldr.64 #{armFlippedOperands(operands)}&quot;
461         when &quot;stored&quot;
462             $asm.puts &quot;vstr.64 #{armOperands(operands)}&quot;
463         when &quot;addd&quot;
464             emitArm(&quot;vadd.f64&quot;, operands)
465         when &quot;divd&quot;
466             emitArm(&quot;vdiv.f64&quot;, operands)
467         when &quot;subd&quot;
468             emitArm(&quot;vsub.f64&quot;, operands)
469         when &quot;muld&quot;
470             emitArm(&quot;vmul.f64&quot;, operands)
471         when &quot;sqrtd&quot;
472             $asm.puts &quot;vsqrt.f64 #{armFlippedOperands(operands)}&quot;
<span class="line-modified">473         when &quot;ci2ds&quot;</span>
474             $asm.puts &quot;vmov #{operands[1].armSingle}, #{operands[0].armOperand}&quot;
475             $asm.puts &quot;vcvt.f64.s32 #{operands[1].armOperand}, #{operands[1].armSingle}&quot;
476         when &quot;bdeq&quot;
477             emitArmDoubleBranch(&quot;beq&quot;, operands)
478         when &quot;bdneq&quot;
479             $asm.puts &quot;vcmpe.f64 #{armOperands(operands[0..1])}&quot;
480             $asm.puts &quot;vmrs apsr_nzcv, fpscr&quot;
481             isUnordered = LocalLabel.unique(&quot;bdneq&quot;)
482             $asm.puts &quot;bvs #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;
483             $asm.puts &quot;bne #{operands[2].asmLabel}&quot;
484             isUnordered.lower(&quot;ARM&quot;)
485         when &quot;bdgt&quot;
486             emitArmDoubleBranch(&quot;bgt&quot;, operands)
487         when &quot;bdgteq&quot;
488             emitArmDoubleBranch(&quot;bge&quot;, operands)
489         when &quot;bdlt&quot;
490             emitArmDoubleBranch(&quot;bmi&quot;, operands)
491         when &quot;bdlteq&quot;
492             emitArmDoubleBranch(&quot;bls&quot;, operands)
493         when &quot;bdequn&quot;
</pre>
</td>
</tr>
</table>
<center><a href="../llint/LowLevelInterpreter64.asm.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="arm64.rb.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
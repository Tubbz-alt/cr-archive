<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGenericTypedArrayView.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSGeneratorFunction.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSGenericTypedArrayViewConstructorInlines.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGenericTypedArrayView.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2013, 2016 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 91,25 ***</span>
  static const ASCIILiteral typedArrayBufferHasBeenDetachedErrorMessage { &quot;Underlying ArrayBuffer has been detached from the view&quot;_s };
  
  template&lt;typename Adaptor&gt;
  class JSGenericTypedArrayView final : public JSArrayBufferView {
  public:
<span class="line-modified">!     typedef JSArrayBufferView Base;</span>
      typedef typename Adaptor::Type ElementType;
  
<span class="line-modified">!     static const unsigned StructureFlags = Base::StructureFlags | OverridesGetPropertyNames | OverridesGetOwnPropertySlot | InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero;</span>
  
<span class="line-modified">!     static const unsigned elementSize = sizeof(typename Adaptor::Type);</span>
  
  protected:
      JSGenericTypedArrayView(VM&amp;, ConstructionContext&amp;);
  
  public:
<span class="line-modified">!     static JSGenericTypedArrayView* create(ExecState*, Structure*, unsigned length);</span>
<span class="line-modified">!     static JSGenericTypedArrayView* createWithFastVector(ExecState*, Structure*, unsigned length, void* vector);</span>
<span class="line-modified">!     static JSGenericTypedArrayView* createUninitialized(ExecState*, Structure*, unsigned length);</span>
<span class="line-modified">!     static JSGenericTypedArrayView* create(ExecState*, Structure*, RefPtr&lt;ArrayBuffer&gt;&amp;&amp;, unsigned byteOffset, unsigned length);</span>
      static JSGenericTypedArrayView* create(VM&amp;, Structure*, RefPtr&lt;typename Adaptor::ViewType&gt;&amp;&amp; impl);
      static JSGenericTypedArrayView* create(Structure*, JSGlobalObject*, RefPtr&lt;typename Adaptor::ViewType&gt;&amp;&amp; impl);
  
      unsigned byteLength() const { return m_length * sizeof(typename Adaptor::Type); }
      size_t byteSize() const { return sizeOf(m_length, sizeof(typename Adaptor::Type)); }
<span class="line-new-header">--- 91,25 ---</span>
  static const ASCIILiteral typedArrayBufferHasBeenDetachedErrorMessage { &quot;Underlying ArrayBuffer has been detached from the view&quot;_s };
  
  template&lt;typename Adaptor&gt;
  class JSGenericTypedArrayView final : public JSArrayBufferView {
  public:
<span class="line-modified">!     using Base = JSArrayBufferView;</span>
      typedef typename Adaptor::Type ElementType;
  
<span class="line-modified">!     static constexpr unsigned StructureFlags = Base::StructureFlags | OverridesGetPropertyNames | OverridesGetOwnPropertySlot | InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero;</span>
  
<span class="line-modified">!     static constexpr unsigned elementSize = sizeof(typename Adaptor::Type);</span>
  
  protected:
      JSGenericTypedArrayView(VM&amp;, ConstructionContext&amp;);
  
  public:
<span class="line-modified">!     static JSGenericTypedArrayView* create(JSGlobalObject*, Structure*, unsigned length);</span>
<span class="line-modified">!     static JSGenericTypedArrayView* createWithFastVector(JSGlobalObject*, Structure*, unsigned length, void* vector);</span>
<span class="line-modified">!     static JSGenericTypedArrayView* createUninitialized(JSGlobalObject*, Structure*, unsigned length);</span>
<span class="line-modified">!     static JSGenericTypedArrayView* create(JSGlobalObject*, Structure*, RefPtr&lt;ArrayBuffer&gt;&amp;&amp;, unsigned byteOffset, unsigned length);</span>
      static JSGenericTypedArrayView* create(VM&amp;, Structure*, RefPtr&lt;typename Adaptor::ViewType&gt;&amp;&amp; impl);
      static JSGenericTypedArrayView* create(Structure*, JSGlobalObject*, RefPtr&lt;typename Adaptor::ViewType&gt;&amp;&amp; impl);
  
      unsigned byteLength() const { return m_length * sizeof(typename Adaptor::Type); }
      size_t byteSize() const { return sizeOf(m_length, sizeof(typename Adaptor::Type)); }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 165,31 ***</span>
      {
          ASSERT(!value.isObject());
          setIndexQuicklyToNativeValue(i, toNativeFromValue&lt;Adaptor&gt;(value));
      }
  
<span class="line-modified">!     bool setIndex(ExecState* exec, unsigned i, JSValue jsValue)</span>
      {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!         typename Adaptor::Type value = toNativeFromValue&lt;Adaptor&gt;(exec, jsValue);</span>
          RETURN_IF_EXCEPTION(scope, false);
  
          if (isNeutered()) {
<span class="line-modified">!             throwTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
              return false;
          }
  
          if (i &gt;= m_length)
              return false;
  
          setIndexQuicklyToNativeValue(i, value);
          return true;
      }
  
<span class="line-modified">!     static ElementType toAdaptorNativeFromValue(ExecState* exec, JSValue jsValue) { return toNativeFromValue&lt;Adaptor&gt;(exec, jsValue); }</span>
  
      static Optional&lt;ElementType&gt; toAdaptorNativeFromValueWithoutCoercion(JSValue jsValue) { return toNativeFromValueWithoutCoercion&lt;Adaptor&gt;(jsValue); }
  
      void sort()
      {
<span class="line-new-header">--- 165,31 ---</span>
      {
          ASSERT(!value.isObject());
          setIndexQuicklyToNativeValue(i, toNativeFromValue&lt;Adaptor&gt;(value));
      }
  
<span class="line-modified">!     bool setIndex(JSGlobalObject* globalObject, unsigned i, JSValue jsValue)</span>
      {
<span class="line-modified">!         VM&amp; vm = getVM(globalObject);</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!         typename Adaptor::Type value = toNativeFromValue&lt;Adaptor&gt;(globalObject, jsValue);</span>
          RETURN_IF_EXCEPTION(scope, false);
  
          if (isNeutered()) {
<span class="line-modified">!             throwTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
              return false;
          }
  
          if (i &gt;= m_length)
              return false;
  
          setIndexQuicklyToNativeValue(i, value);
          return true;
      }
  
<span class="line-modified">!     static ElementType toAdaptorNativeFromValue(JSGlobalObject* globalObject, JSValue jsValue) { return toNativeFromValue&lt;Adaptor&gt;(globalObject, jsValue); }</span>
  
      static Optional&lt;ElementType&gt; toAdaptorNativeFromValueWithoutCoercion(JSValue jsValue) { return toNativeFromValueWithoutCoercion&lt;Adaptor&gt;(jsValue); }
  
      void sort()
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 217,15 ***</span>
              &amp;&amp; offset + length &gt;= offset;
      }
  
      // Like canSetQuickly, except: if it returns false, it will throw the
      // appropriate exception.
<span class="line-modified">!     bool validateRange(ExecState*, unsigned offset, unsigned length);</span>
  
      // Returns true if successful, and false on error; if it returns false
      // then it will have thrown an exception.
<span class="line-modified">!     bool set(ExecState*, unsigned offset, JSObject*, unsigned objectOffset, unsigned length, CopyType type = CopyType::Unobservable);</span>
  
      RefPtr&lt;typename Adaptor::ViewType&gt; possiblySharedTypedImpl();
      RefPtr&lt;typename Adaptor::ViewType&gt; unsharedTypedImpl();
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
<span class="line-new-header">--- 217,15 ---</span>
              &amp;&amp; offset + length &gt;= offset;
      }
  
      // Like canSetQuickly, except: if it returns false, it will throw the
      // appropriate exception.
<span class="line-modified">!     bool validateRange(JSGlobalObject*, unsigned offset, unsigned length);</span>
  
      // Returns true if successful, and false on error; if it returns false
      // then it will have thrown an exception.
<span class="line-modified">!     bool set(JSGlobalObject*, unsigned offset, JSObject*, unsigned objectOffset, unsigned length, CopyType type = CopyType::Unobservable);</span>
  
      RefPtr&lt;typename Adaptor::ViewType&gt; possiblySharedTypedImpl();
      RefPtr&lt;typename Adaptor::ViewType&gt; unsharedTypedImpl();
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 256,11 ***</span>
              return getFloat32ArrayClassInfo();
          case TypeFloat64:
              return getFloat64ArrayClassInfo();
          default:
              RELEASE_ASSERT_NOT_REACHED();
<span class="line-modified">!             return 0;</span>
          }
      }
  
      ArrayBuffer* existingBuffer();
  
<span class="line-new-header">--- 256,39 ---</span>
              return getFloat32ArrayClassInfo();
          case TypeFloat64:
              return getFloat64ArrayClassInfo();
          default:
              RELEASE_ASSERT_NOT_REACHED();
<span class="line-modified">!             return nullptr;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     template&lt;typename CellType, SubspaceAccess mode&gt;</span>
<span class="line-added">+     static IsoSubspace* subspaceFor(VM&amp; vm)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         switch (Adaptor::typeValue) {</span>
<span class="line-added">+         case TypeInt8:</span>
<span class="line-added">+             return vm.int8ArraySpace&lt;mode&gt;();</span>
<span class="line-added">+         case TypeInt16:</span>
<span class="line-added">+             return vm.int16ArraySpace&lt;mode&gt;();</span>
<span class="line-added">+         case TypeInt32:</span>
<span class="line-added">+             return vm.int32ArraySpace&lt;mode&gt;();</span>
<span class="line-added">+         case TypeUint8:</span>
<span class="line-added">+             return vm.uint8ArraySpace&lt;mode&gt;();</span>
<span class="line-added">+         case TypeUint8Clamped:</span>
<span class="line-added">+             return vm.uint8ClampedArraySpace&lt;mode&gt;();</span>
<span class="line-added">+         case TypeUint16:</span>
<span class="line-added">+             return vm.uint16ArraySpace&lt;mode&gt;();</span>
<span class="line-added">+         case TypeUint32:</span>
<span class="line-added">+             return vm.uint32ArraySpace&lt;mode&gt;();</span>
<span class="line-added">+         case TypeFloat32:</span>
<span class="line-added">+             return vm.float32ArraySpace&lt;mode&gt;();</span>
<span class="line-added">+         case TypeFloat64:</span>
<span class="line-added">+             return vm.float64ArraySpace&lt;mode&gt;();</span>
<span class="line-added">+         default:</span>
<span class="line-added">+             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+             return nullptr;</span>
          }
      }
  
      ArrayBuffer* existingBuffer();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 270,31 ***</span>
      static RefPtr&lt;typename Adaptor::ViewType&gt; toWrapped(VM&amp;, JSValue);
  
  protected:
      friend struct TypedArrayClassInfos;
  
<span class="line-modified">!     static EncodedJSValue throwNeuteredTypedArrayTypeError(ExecState*, EncodedJSValue, PropertyName);</span>
  
<span class="line-modified">!     static bool getOwnPropertySlot(JSObject*, ExecState*, PropertyName, PropertySlot&amp;);</span>
<span class="line-modified">!     static bool put(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="line-modified">!     static bool defineOwnProperty(JSObject*, ExecState*, PropertyName, const PropertyDescriptor&amp;, bool shouldThrow);</span>
<span class="line-modified">!     static bool deleteProperty(JSCell*, ExecState*, PropertyName);</span>
  
<span class="line-modified">!     static bool getOwnPropertySlotByIndex(JSObject*, ExecState*, unsigned propertyName, PropertySlot&amp;);</span>
<span class="line-modified">!     static bool putByIndex(JSCell*, ExecState*, unsigned propertyName, JSValue, bool shouldThrow);</span>
<span class="line-modified">!     static bool deletePropertyByIndex(JSCell*, ExecState*, unsigned propertyName);</span>
  
<span class="line-modified">!     static void getOwnPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);</span>
  
      static size_t estimatedSize(JSCell*, VM&amp;);
      static void visitChildren(JSCell*, SlotVisitor&amp;);
  
  private:
      // Returns true if successful, and false on error; it will throw on error.
      template&lt;typename OtherAdaptor&gt;
      bool setWithSpecificType(
<span class="line-modified">!         ExecState*, unsigned offset, JSGenericTypedArrayView&lt;OtherAdaptor&gt;*,</span>
          unsigned objectOffset, unsigned length, CopyType);
  
      // The ECMA 6 spec states that floating point Typed Arrays should have the following ordering:
      //
      // -Inifinity &lt; negative finite numbers &lt; -0.0 &lt; 0.0 &lt; positive finite numbers &lt; Infinity &lt; NaN
<span class="line-new-header">--- 298,31 ---</span>
      static RefPtr&lt;typename Adaptor::ViewType&gt; toWrapped(VM&amp;, JSValue);
  
  protected:
      friend struct TypedArrayClassInfos;
  
<span class="line-modified">!     static EncodedJSValue throwNeuteredTypedArrayTypeError(JSGlobalObject*, EncodedJSValue, PropertyName);</span>
  
<span class="line-modified">!     static bool getOwnPropertySlot(JSObject*, JSGlobalObject*, PropertyName, PropertySlot&amp;);</span>
<span class="line-modified">!     static bool put(JSCell*, JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="line-modified">!     static bool defineOwnProperty(JSObject*, JSGlobalObject*, PropertyName, const PropertyDescriptor&amp;, bool shouldThrow);</span>
<span class="line-modified">!     static bool deleteProperty(JSCell*, JSGlobalObject*, PropertyName);</span>
  
<span class="line-modified">!     static bool getOwnPropertySlotByIndex(JSObject*, JSGlobalObject*, unsigned propertyName, PropertySlot&amp;);</span>
<span class="line-modified">!     static bool putByIndex(JSCell*, JSGlobalObject*, unsigned propertyName, JSValue, bool shouldThrow);</span>
<span class="line-modified">!     static bool deletePropertyByIndex(JSCell*, JSGlobalObject*, unsigned propertyName);</span>
  
<span class="line-modified">!     static void getOwnPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);</span>
  
      static size_t estimatedSize(JSCell*, VM&amp;);
      static void visitChildren(JSCell*, SlotVisitor&amp;);
  
  private:
      // Returns true if successful, and false on error; it will throw on error.
      template&lt;typename OtherAdaptor&gt;
      bool setWithSpecificType(
<span class="line-modified">!         JSGlobalObject*, unsigned offset, JSGenericTypedArrayView&lt;OtherAdaptor&gt;*,</span>
          unsigned objectOffset, unsigned length, CopyType);
  
      // The ECMA 6 spec states that floating point Typed Arrays should have the following ordering:
      //
      // -Inifinity &lt; negative finite numbers &lt; -0.0 &lt; 0.0 &lt; positive finite numbers &lt; Infinity &lt; NaN
</pre>
<center><a href="JSGeneratorFunction.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSGenericTypedArrayViewConstructorInlines.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
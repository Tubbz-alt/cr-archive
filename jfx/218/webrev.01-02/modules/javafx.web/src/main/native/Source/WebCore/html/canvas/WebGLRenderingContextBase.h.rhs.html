<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContextBase.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(WEBGL)
 29 
 30 #include &quot;ActivityStateChangeObserver.h&quot;
 31 #include &quot;ExceptionOr.h&quot;
 32 #include &quot;GPUBasedCanvasRenderingContext.h&quot;
<a name="1" id="anc1"></a><span class="line-modified"> 33 #include &quot;GraphicsContextGLOpenGL.h&quot;</span>
 34 #include &quot;ImageBuffer.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 35 #include &quot;SuspendableTimer.h&quot;</span>
 36 #include &quot;Timer.h&quot;
 37 #include &quot;WebGLAny.h&quot;
 38 #include &quot;WebGLBuffer.h&quot;
 39 #include &quot;WebGLContextAttributes.h&quot;
 40 #include &quot;WebGLFramebuffer.h&quot;
 41 #include &quot;WebGLProgram.h&quot;
 42 #include &quot;WebGLRenderbuffer.h&quot;
 43 #include &quot;WebGLStateTracker.h&quot;
 44 #include &quot;WebGLTexture.h&quot;
 45 #include &quot;WebGLVertexArrayObjectOES.h&quot;
 46 #include &lt;JavaScriptCore/ConsoleTypes.h&gt;
 47 #include &lt;limits&gt;
 48 #include &lt;memory&gt;
 49 
 50 #if ENABLE(WEBGL2)
 51 #include &quot;WebGLVertexArrayObject.h&quot;
 52 #endif
 53 
 54 namespace WebCore {
 55 
 56 class ANGLEInstancedArrays;
 57 class EXTBlendMinMax;
 58 class EXTTextureFilterAnisotropic;
 59 class EXTShaderTextureLOD;
 60 class EXTsRGB;
 61 class EXTFragDepth;
 62 class HTMLImageElement;
 63 class ImageData;
 64 class IntSize;
 65 class OESStandardDerivatives;
 66 class OESTextureFloat;
 67 class OESTextureFloatLinear;
 68 class OESTextureHalfFloat;
 69 class OESTextureHalfFloatLinear;
 70 class OESVertexArrayObject;
 71 class OESElementIndexUint;
<a name="3" id="anc3"></a><span class="line-added"> 72 #if ENABLE(OFFSCREEN_CANVAS)</span>
 73 class OffscreenCanvas;
<a name="4" id="anc4"></a><span class="line-added"> 74 #endif</span>
 75 class WebGLActiveInfo;
 76 class WebGLContextGroup;
 77 class WebGLContextObject;
 78 class WebGLCompressedTextureASTC;
 79 class WebGLCompressedTextureATC;
<a name="5" id="anc5"></a><span class="line-added"> 80 class WebGLCompressedTextureETC;</span>
<span class="line-added"> 81 class WebGLCompressedTextureETC1;</span>
 82 class WebGLCompressedTexturePVRTC;
 83 class WebGLCompressedTextureS3TC;
 84 class WebGLDebugRendererInfo;
 85 class WebGLDebugShaders;
 86 class WebGLDepthTexture;
 87 class WebGLDrawBuffers;
 88 class WebGLExtension;
 89 class WebGLLoseContext;
 90 class WebGLObject;
 91 class WebGLShader;
 92 class WebGLSharedObject;
 93 class WebGLShaderPrecisionFormat;
 94 class WebGLUniformLocation;
 95 
 96 #if ENABLE(VIDEO)
 97 class HTMLVideoElement;
 98 #endif
 99 
<a name="6" id="anc6"></a><span class="line-added">100 #if ENABLE(OFFSCREEN_CANVAS)</span>
101 using WebGLCanvas = WTF::Variant&lt;RefPtr&lt;HTMLCanvasElement&gt;, RefPtr&lt;OffscreenCanvas&gt;&gt;;
<a name="7" id="anc7"></a><span class="line-added">102 #else</span>
<span class="line-added">103 using WebGLCanvas = WTF::Variant&lt;RefPtr&lt;HTMLCanvasElement&gt;&gt;;</span>
<span class="line-added">104 #endif</span>
105 
<a name="8" id="anc8"></a><span class="line-modified">106 class WebGLRenderingContextBase : public GraphicsContextGLOpenGL::Client, public GPUBasedCanvasRenderingContext, private ActivityStateChangeObserver {</span>
107     WTF_MAKE_ISO_ALLOCATED(WebGLRenderingContextBase);
108 public:
109     static std::unique_ptr&lt;WebGLRenderingContextBase&gt; create(CanvasBase&amp;, WebGLContextAttributes&amp;, const String&amp;);
110     virtual ~WebGLRenderingContextBase();
111 
112     WebGLCanvas canvas();
113 
114     int drawingBufferWidth() const;
115     int drawingBufferHeight() const;
116 
<a name="9" id="anc9"></a><span class="line-modified">117     void activeTexture(GCGLenum texture);</span>
118     void attachShader(WebGLProgram*, WebGLShader*);
<a name="10" id="anc10"></a><span class="line-modified">119     void bindAttribLocation(WebGLProgram*, GCGLuint index, const String&amp; name);</span>
<span class="line-modified">120     void bindBuffer(GCGLenum target, WebGLBuffer*);</span>
<span class="line-modified">121     void bindFramebuffer(GCGLenum target, WebGLFramebuffer*);</span>
<span class="line-modified">122     void bindRenderbuffer(GCGLenum target, WebGLRenderbuffer*);</span>
<span class="line-modified">123     void bindTexture(GCGLenum target, WebGLTexture*);</span>
<span class="line-modified">124     void blendColor(GCGLfloat red, GCGLfloat green, GCGLfloat blue, GCGLfloat alpha);</span>
<span class="line-modified">125     void blendEquation(GCGLenum mode);</span>
<span class="line-modified">126     void blendEquationSeparate(GCGLenum modeRGB, GCGLenum modeAlpha);</span>
<span class="line-modified">127     void blendFunc(GCGLenum sfactor, GCGLenum dfactor);</span>
<span class="line-modified">128     void blendFuncSeparate(GCGLenum srcRGB, GCGLenum dstRGB, GCGLenum srcAlpha, GCGLenum dstAlpha);</span>
129 
130     using BufferDataSource = WTF::Variant&lt;RefPtr&lt;ArrayBuffer&gt;, RefPtr&lt;ArrayBufferView&gt;&gt;;
<a name="11" id="anc11"></a><span class="line-modified">131     void bufferData(GCGLenum target, long long size, GCGLenum usage);</span>
<span class="line-modified">132     void bufferData(GCGLenum target, Optional&lt;BufferDataSource&gt;&amp;&amp;, GCGLenum usage);</span>
<span class="line-modified">133     void bufferSubData(GCGLenum target, long long offset, Optional&lt;BufferDataSource&gt;&amp;&amp;);</span>
<span class="line-modified">134 </span>
<span class="line-modified">135     GCGLenum checkFramebufferStatus(GCGLenum target);</span>
<span class="line-modified">136     virtual void clear(GCGLbitfield mask) = 0;</span>
<span class="line-modified">137     void clearColor(GCGLfloat red, GCGLfloat green, GCGLfloat blue, GCGLfloat alpha);</span>
<span class="line-modified">138     void clearDepth(GCGLfloat);</span>
<span class="line-modified">139     void clearStencil(GCGLint);</span>
<span class="line-modified">140     void colorMask(GCGLboolean red, GCGLboolean green, GCGLboolean blue, GCGLboolean alpha);</span>
141     void compileShader(WebGLShader*);
142 
<a name="12" id="anc12"></a><span class="line-modified">143     void compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, ArrayBufferView&amp; data);</span>
<span class="line-modified">144     void compressedTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, ArrayBufferView&amp; data);</span>
145 
<a name="13" id="anc13"></a><span class="line-modified">146     void copyTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLint border);</span>
<span class="line-modified">147     void copyTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height);</span>
148 
149     RefPtr&lt;WebGLBuffer&gt; createBuffer();
150     RefPtr&lt;WebGLFramebuffer&gt; createFramebuffer();
151     RefPtr&lt;WebGLProgram&gt; createProgram();
152     RefPtr&lt;WebGLRenderbuffer&gt; createRenderbuffer();
<a name="14" id="anc14"></a><span class="line-modified">153     RefPtr&lt;WebGLShader&gt; createShader(GCGLenum type);</span>
154     RefPtr&lt;WebGLTexture&gt; createTexture();
155 
<a name="15" id="anc15"></a><span class="line-modified">156     void cullFace(GCGLenum mode);</span>
157 
158     void deleteBuffer(WebGLBuffer*);
159     void deleteFramebuffer(WebGLFramebuffer*);
160     void deleteProgram(WebGLProgram*);
161     void deleteRenderbuffer(WebGLRenderbuffer*);
162     void deleteShader(WebGLShader*);
163     void deleteTexture(WebGLTexture*);
164 
<a name="16" id="anc16"></a><span class="line-modified">165     void depthFunc(GCGLenum);</span>
<span class="line-modified">166     void depthMask(GCGLboolean);</span>
<span class="line-modified">167     void depthRange(GCGLfloat zNear, GCGLfloat zFar);</span>
168     void detachShader(WebGLProgram*, WebGLShader*);
<a name="17" id="anc17"></a><span class="line-modified">169     void disable(GCGLenum cap);</span>
<span class="line-modified">170     void disableVertexAttribArray(GCGLuint index);</span>
<span class="line-modified">171     void drawArrays(GCGLenum mode, GCGLint first, GCGLsizei count);</span>
<span class="line-modified">172     void drawElements(GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset);</span>
173 
<a name="18" id="anc18"></a><span class="line-modified">174     void enable(GCGLenum cap);</span>
<span class="line-modified">175     void enableVertexAttribArray(GCGLuint index);</span>
176     void finish();
177     void flush();
<a name="19" id="anc19"></a><span class="line-modified">178     void framebufferRenderbuffer(GCGLenum target, GCGLenum attachment, GCGLenum renderbuffertarget, WebGLRenderbuffer*);</span>
<span class="line-modified">179     void framebufferTexture2D(GCGLenum target, GCGLenum attachment, GCGLenum textarget, WebGLTexture*, GCGLint level);</span>
<span class="line-modified">180     void frontFace(GCGLenum mode);</span>
<span class="line-modified">181     void generateMipmap(GCGLenum target);</span>
182 
<a name="20" id="anc20"></a><span class="line-modified">183     RefPtr&lt;WebGLActiveInfo&gt; getActiveAttrib(WebGLProgram*, GCGLuint index);</span>
<span class="line-modified">184     RefPtr&lt;WebGLActiveInfo&gt; getActiveUniform(WebGLProgram*, GCGLuint index);</span>
185     Optional&lt;Vector&lt;RefPtr&lt;WebGLShader&gt;&gt;&gt; getAttachedShaders(WebGLProgram*);
<a name="21" id="anc21"></a><span class="line-modified">186     GCGLint getAttribLocation(WebGLProgram*, const String&amp; name);</span>
<span class="line-modified">187     WebGLAny getBufferParameter(GCGLenum target, GCGLenum pname);</span>
188     Optional&lt;WebGLContextAttributes&gt; getContextAttributes();
<a name="22" id="anc22"></a><span class="line-modified">189     GCGLenum getError();</span>
190     virtual WebGLExtension* getExtension(const String&amp; name) = 0;
<a name="23" id="anc23"></a><span class="line-modified">191     virtual WebGLAny getFramebufferAttachmentParameter(GCGLenum target, GCGLenum attachment, GCGLenum pname) = 0;</span>
<span class="line-modified">192     virtual WebGLAny getParameter(GCGLenum pname) = 0;</span>
<span class="line-modified">193     WebGLAny getProgramParameter(WebGLProgram*, GCGLenum pname);</span>
194     String getProgramInfoLog(WebGLProgram*);
<a name="24" id="anc24"></a><span class="line-modified">195     WebGLAny getRenderbufferParameter(GCGLenum target, GCGLenum pname);</span>
<span class="line-modified">196     WebGLAny getShaderParameter(WebGLShader*, GCGLenum pname);</span>
197     String getShaderInfoLog(WebGLShader*);
<a name="25" id="anc25"></a><span class="line-modified">198     RefPtr&lt;WebGLShaderPrecisionFormat&gt; getShaderPrecisionFormat(GCGLenum shaderType, GCGLenum precisionType);</span>
199     String getShaderSource(WebGLShader*);
200     virtual Optional&lt;Vector&lt;String&gt;&gt; getSupportedExtensions() = 0;
<a name="26" id="anc26"></a><span class="line-modified">201     WebGLAny getTexParameter(GCGLenum target, GCGLenum pname);</span>
202     WebGLAny getUniform(WebGLProgram*, const WebGLUniformLocation*);
203     RefPtr&lt;WebGLUniformLocation&gt; getUniformLocation(WebGLProgram*, const String&amp;);
<a name="27" id="anc27"></a><span class="line-modified">204     WebGLAny getVertexAttrib(GCGLuint index, GCGLenum pname);</span>
<span class="line-modified">205     long long getVertexAttribOffset(GCGLuint index, GCGLenum pname);</span>
206 
207     bool extensionIsEnabled(const String&amp;);
208 
209     bool isPreservingDrawingBuffer() const { return m_attributes.preserveDrawingBuffer; }
210     void setPreserveDrawingBuffer(bool value) { m_attributes.preserveDrawingBuffer = value; }
211 
212     bool preventBufferClearForInspector() const { return m_preventBufferClearForInspector; }
213     void setPreventBufferClearForInspector(bool value) { m_preventBufferClearForInspector = value; }
214 
<a name="28" id="anc28"></a><span class="line-modified">215     virtual void hint(GCGLenum target, GCGLenum mode) = 0;</span>
<span class="line-modified">216     GCGLboolean isBuffer(WebGLBuffer*);</span>
217     bool isContextLost() const;
<a name="29" id="anc29"></a><span class="line-modified">218     GCGLboolean isEnabled(GCGLenum cap);</span>
<span class="line-modified">219     GCGLboolean isFramebuffer(WebGLFramebuffer*);</span>
<span class="line-modified">220     GCGLboolean isProgram(WebGLProgram*);</span>
<span class="line-modified">221     GCGLboolean isRenderbuffer(WebGLRenderbuffer*);</span>
<span class="line-modified">222     GCGLboolean isShader(WebGLShader*);</span>
<span class="line-modified">223     GCGLboolean isTexture(WebGLTexture*);</span>
<span class="line-modified">224 </span>
<span class="line-modified">225     void lineWidth(GCGLfloat);</span>
226     void linkProgram(WebGLProgram*);
227     bool linkProgramWithoutInvalidatingAttribLocations(WebGLProgram*);
<a name="30" id="anc30"></a><span class="line-modified">228     void pixelStorei(GCGLenum pname, GCGLint param);</span>
<span class="line-modified">229     void polygonOffset(GCGLfloat factor, GCGLfloat units);</span>
<span class="line-modified">230     void readPixels(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, ArrayBufferView&amp; pixels);</span>
231     void releaseShaderCompiler();
<a name="31" id="anc31"></a><span class="line-modified">232     virtual void renderbufferStorage(GCGLenum target, GCGLenum internalformat, GCGLsizei width, GCGLsizei height) = 0;</span>
<span class="line-modified">233     void sampleCoverage(GCGLfloat value, GCGLboolean invert);</span>
<span class="line-modified">234     void scissor(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height);</span>
235     void shaderSource(WebGLShader*, const String&amp;);
<a name="32" id="anc32"></a><span class="line-modified">236     void stencilFunc(GCGLenum func, GCGLint ref, GCGLuint mask);</span>
<span class="line-modified">237     void stencilFuncSeparate(GCGLenum face, GCGLenum func, GCGLint ref, GCGLuint mask);</span>
<span class="line-modified">238     void stencilMask(GCGLuint);</span>
<span class="line-modified">239     void stencilMaskSeparate(GCGLenum face, GCGLuint mask);</span>
<span class="line-modified">240     void stencilOp(GCGLenum fail, GCGLenum zfail, GCGLenum zpass);</span>
<span class="line-modified">241     void stencilOpSeparate(GCGLenum face, GCGLenum fail, GCGLenum zfail, GCGLenum zpass);</span>
242 
<a name="33" id="anc33"></a><span class="line-modified">243     void texImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp;);</span>
244 
245 #if ENABLE(VIDEO)
246     using TexImageSource = WTF::Variant&lt;RefPtr&lt;ImageBitmap&gt;, RefPtr&lt;ImageData&gt;, RefPtr&lt;HTMLImageElement&gt;, RefPtr&lt;HTMLCanvasElement&gt;, RefPtr&lt;HTMLVideoElement&gt;&gt;;
247 #else
248     using TexImageSource = WTF::Variant&lt;RefPtr&lt;ImageBitmap&gt;, RefPtr&lt;ImageData&gt;, RefPtr&lt;HTMLImageElement&gt;, RefPtr&lt;HTMLCanvasElement&gt;&gt;;
249 #endif
250 
<a name="34" id="anc34"></a><span class="line-modified">251     ExceptionOr&lt;void&gt; texImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLenum format, GCGLenum type, Optional&lt;TexImageSource&gt;);</span>
252 
<a name="35" id="anc35"></a><span class="line-modified">253     void texParameterf(GCGLenum target, GCGLenum pname, GCGLfloat param);</span>
<span class="line-modified">254     void texParameteri(GCGLenum target, GCGLenum pname, GCGLint param);</span>
255 
<a name="36" id="anc36"></a><span class="line-modified">256     void texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp;);</span>
<span class="line-modified">257     ExceptionOr&lt;void&gt; texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLenum format, GCGLenum type, Optional&lt;TexImageSource&gt;&amp;&amp;);</span>
258 
259     template &lt;class TypedArray, class DataType&gt;
260     class TypedList {
261     public:
262         using VariantType = Variant&lt;RefPtr&lt;TypedArray&gt;, Vector&lt;DataType&gt;&gt;;
263 
264         TypedList(VariantType&amp;&amp; variant)
265             : m_variant(WTFMove(variant))
266         {
267         }
268 
269         const DataType* data() const
270         {
271             return WTF::switchOn(m_variant,
272                 [] (const RefPtr&lt;TypedArray&gt;&amp; typedArray) -&gt; const DataType* { return typedArray-&gt;data(); },
273                 [] (const Vector&lt;DataType&gt;&amp; vector) -&gt; const DataType* { return vector.data(); }
274             );
275         }
276 
<a name="37" id="anc37"></a><span class="line-modified">277         GCGLsizei length() const</span>
278         {
279             return WTF::switchOn(m_variant,
<a name="38" id="anc38"></a><span class="line-modified">280                 [] (const RefPtr&lt;TypedArray&gt;&amp; typedArray) -&gt; GCGLsizei { return typedArray-&gt;length(); },</span>
<span class="line-modified">281                 [] (const Vector&lt;DataType&gt;&amp; vector) -&gt; GCGLsizei { return vector.size(); }</span>
282             );
283         }
284 
285     private:
286         VariantType m_variant;
287     };
288 
289     using Float32List = TypedList&lt;Float32Array, float&gt;;
290     using Int32List = TypedList&lt;Int32Array, int&gt;;
291 
<a name="39" id="anc39"></a><span class="line-modified">292     void uniform1f(const WebGLUniformLocation*, GCGLfloat x);</span>
<span class="line-modified">293     void uniform2f(const WebGLUniformLocation*, GCGLfloat x, GCGLfloat y);</span>
<span class="line-modified">294     void uniform3f(const WebGLUniformLocation*, GCGLfloat x, GCGLfloat y, GCGLfloat z);</span>
<span class="line-modified">295     void uniform4f(const WebGLUniformLocation*, GCGLfloat x, GCGLfloat y, GCGLfloat z, GCGLfloat w);</span>
296 
<a name="40" id="anc40"></a><span class="line-modified">297     void uniform1i(const WebGLUniformLocation*, GCGLint x);</span>
<span class="line-modified">298     void uniform2i(const WebGLUniformLocation*, GCGLint x, GCGLint y);</span>
<span class="line-modified">299     void uniform3i(const WebGLUniformLocation*, GCGLint x, GCGLint y, GCGLint z);</span>
<span class="line-modified">300     void uniform4i(const WebGLUniformLocation*, GCGLint x, GCGLint y, GCGLint z, GCGLint w);</span>
301 
302     void uniform1fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
303     void uniform2fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
304     void uniform3fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
305     void uniform4fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
306 
307     void uniform1iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
308     void uniform2iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
309     void uniform3iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
310     void uniform4iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
311 
<a name="41" id="anc41"></a><span class="line-modified">312     void uniformMatrix2fv(const WebGLUniformLocation*, GCGLboolean transpose, Float32List&amp;&amp;);</span>
<span class="line-modified">313     void uniformMatrix3fv(const WebGLUniformLocation*, GCGLboolean transpose, Float32List&amp;&amp;);</span>
<span class="line-modified">314     void uniformMatrix4fv(const WebGLUniformLocation*, GCGLboolean transpose, Float32List&amp;&amp;);</span>
315 
316     void useProgram(WebGLProgram*);
317     void validateProgram(WebGLProgram*);
318 
<a name="42" id="anc42"></a><span class="line-modified">319     void vertexAttrib1f(GCGLuint index, GCGLfloat x);</span>
<span class="line-modified">320     void vertexAttrib2f(GCGLuint index, GCGLfloat x, GCGLfloat y);</span>
<span class="line-modified">321     void vertexAttrib3f(GCGLuint index, GCGLfloat x, GCGLfloat y, GCGLfloat z);</span>
<span class="line-modified">322     void vertexAttrib4f(GCGLuint index, GCGLfloat x, GCGLfloat y, GCGLfloat z, GCGLfloat w);</span>
323 
<a name="43" id="anc43"></a><span class="line-modified">324     void vertexAttrib1fv(GCGLuint index, Float32List&amp;&amp;);</span>
<span class="line-modified">325     void vertexAttrib2fv(GCGLuint index, Float32List&amp;&amp;);</span>
<span class="line-modified">326     void vertexAttrib3fv(GCGLuint index, Float32List&amp;&amp;);</span>
<span class="line-modified">327     void vertexAttrib4fv(GCGLuint index, Float32List&amp;&amp;);</span>
328 
<a name="44" id="anc44"></a><span class="line-modified">329     void vertexAttribPointer(GCGLuint index, GCGLint size, GCGLenum type, GCGLboolean normalized,</span>
<span class="line-modified">330         GCGLsizei stride, long long offset);</span>
331 
<a name="45" id="anc45"></a><span class="line-modified">332     void viewport(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height);</span>
333 
334     // WEBKIT_lose_context support
335     enum LostContextMode {
336         // Lost context occurred at the graphics system level.
337         RealLostContext,
338 
339         // Lost context provoked by WEBKIT_lose_context.
340         SyntheticLostContext
341     };
342     void forceLostContext(LostContextMode);
343     void forceRestoreContext();
344     void loseContextImpl(LostContextMode);
345     WEBCORE_EXPORT void simulateContextChanged();
346 
<a name="46" id="anc46"></a><span class="line-modified">347     GraphicsContextGLOpenGL* graphicsContextGL() const { return m_context.get(); }</span>
348     WebGLContextGroup* contextGroup() const { return m_contextGroup.get(); }
349     PlatformLayer* platformLayer() const override;
350 
351     void reshape(int width, int height) override;
352 
353     void markLayerComposited() final;
354     void paintRenderingResultsToCanvas() override;
355     RefPtr&lt;ImageData&gt; paintRenderingResultsToImageData();
356 
357     void removeSharedObject(WebGLSharedObject&amp;);
358     void removeContextObject(WebGLContextObject&amp;);
359 
360     unsigned getMaxVertexAttribs() const { return m_maxVertexAttribs; }
361 
362     // Instanced Array helper functions.
<a name="47" id="anc47"></a><span class="line-modified">363     void drawArraysInstanced(GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei primcount);</span>
<span class="line-modified">364     void drawElementsInstanced(GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset, GCGLsizei primcount);</span>
<span class="line-modified">365     void vertexAttribDivisor(GCGLuint index, GCGLuint divisor);</span>
366 
367     // Used for testing only, from Internals.
368     WEBCORE_EXPORT void setFailNextGPUStatusCheck();
369 
<a name="48" id="anc48"></a><span class="line-modified">370     // GraphicsContextGL::Client</span>
371     void didComposite() override;
372     void forceContextLost() override;
373     void recycleContext() override;
374     void dispatchContextChangedNotification() override;
375 
<a name="49" id="anc49"></a><span class="line-added">376     // ActiveDOMObject</span>
<span class="line-added">377     bool hasPendingActivity() const final;</span>
<span class="line-added">378 </span>
379 protected:
380     WebGLRenderingContextBase(CanvasBase&amp;, WebGLContextAttributes);
<a name="50" id="anc50"></a><span class="line-modified">381     WebGLRenderingContextBase(CanvasBase&amp;, Ref&lt;GraphicsContextGLOpenGL&gt;&amp;&amp;, WebGLContextAttributes);</span>
382 
383     friend class WebGLDrawBuffers;
384     friend class WebGLFramebuffer;
385     friend class WebGLObject;
386     friend class OESVertexArrayObject;
387     friend class WebGLDebugShaders;
388     friend class WebGLCompressedTextureASTC;
389     friend class WebGLCompressedTextureATC;
<a name="51" id="anc51"></a><span class="line-added">390     friend class WebGLCompressedTextureETC;</span>
<span class="line-added">391     friend class WebGLCompressedTextureETC1;</span>
392     friend class WebGLCompressedTexturePVRTC;
393     friend class WebGLCompressedTextureS3TC;
394     friend class WebGLRenderingContextErrorMessageCallback;
395     friend class WebGLVertexArrayObjectOES;
396     friend class WebGLVertexArrayObject;
397     friend class WebGLVertexArrayObjectBase;
398 
399     virtual void initializeNewContext();
400     virtual void initializeVertexArrayObjects() = 0;
401     void setupFlags();
402 
403     // ActiveDOMObject
<a name="52" id="anc52"></a>
404     void stop() override;
405     const char* activeDOMObjectName() const override;
<a name="53" id="anc53"></a><span class="line-modified">406     void suspend(ReasonForSuspension) override;</span>
<span class="line-added">407     void resume() override;</span>
408 
409     void addSharedObject(WebGLSharedObject&amp;);
410     void addContextObject(WebGLContextObject&amp;);
411     void detachAndRemoveAllObjects();
412 
<a name="54" id="anc54"></a><span class="line-modified">413     void destroyGraphicsContextGL();</span>
414     void markContextChanged();
415     void markContextChangedAndNotifyCanvasObserver();
416 
417     void addActivityStateChangeObserverIfNecessary();
418     void removeActivityStateChangeObserver();
419 
420     // Query whether it is built on top of compliant GLES2 implementation.
421     bool isGLES2Compliant() { return m_isGLES2Compliant; }
422     // Query if the GL implementation is NPOT strict.
423     bool isGLES2NPOTStrict() { return m_isGLES2NPOTStrict; }
424     // Query if depth_stencil buffer is supported.
425     bool isDepthStencilSupported() { return m_isDepthStencilSupported; }
426 
427     // Helper to return the size in bytes of OpenGL data types
428     // like GL_FLOAT, GL_INT, etc.
<a name="55" id="anc55"></a><span class="line-modified">429     unsigned sizeInBytes(GCGLenum type);</span>
430 
431     // Basic validation of count and offset against number of elements in element array buffer
<a name="56" id="anc56"></a><span class="line-modified">432     bool validateElementArraySize(GCGLsizei count, GCGLenum type, GCGLintptr offset);</span>
433 
434     // Conservative but quick index validation
<a name="57" id="anc57"></a><span class="line-modified">435     virtual bool validateIndexArrayConservative(GCGLenum type, unsigned&amp; numElementsRequired) = 0;</span>
436 
437     // Precise but slow index validation -- only done if conservative checks fail
<a name="58" id="anc58"></a><span class="line-modified">438     bool validateIndexArrayPrecise(GCGLsizei count, GCGLenum type, GCGLintptr offset, unsigned&amp; numElementsRequired);</span>
439     bool validateVertexAttributes(unsigned elementCount, unsigned primitiveCount = 0);
440 
441     bool validateWebGLObject(const char*, WebGLObject*);
442 
<a name="59" id="anc59"></a><span class="line-modified">443     bool validateDrawArrays(const char* functionName, GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei primcount);</span>
<span class="line-modified">444     bool validateDrawElements(const char* functionName, GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset, unsigned&amp; numElements, GCGLsizei primcount);</span>
<span class="line-modified">445     bool validateNPOTTextureLevel(GCGLsizei width, GCGLsizei height, GCGLint level, const char* functionName);</span>
446 
447     // Adds a compressed texture format.
<a name="60" id="anc60"></a><span class="line-modified">448     void addCompressedTextureFormat(GCGLenum);</span>
449 
450     RefPtr&lt;Image&gt; drawImageIntoBuffer(Image&amp;, int width, int height, int deviceScaleFactor);
451 
452 #if ENABLE(VIDEO)
453     RefPtr&lt;Image&gt; videoFrameToImage(HTMLVideoElement*, BackingStoreCopy);
454 #endif
455 
456     WebGLTexture::TextureExtensionFlag textureExtensionFlags() const;
457 
458     bool enableSupportedExtension(ASCIILiteral extensionNameLiteral);
459 
<a name="61" id="anc61"></a><span class="line-modified">460     virtual void uncacheDeletedBuffer(WebGLBuffer*);</span>
<span class="line-added">461 </span>
<span class="line-added">462     RefPtr&lt;GraphicsContextGLOpenGL&gt; m_context;</span>
463     RefPtr&lt;WebGLContextGroup&gt; m_contextGroup;
464 
465     // Dispatches a context lost event once it is determined that one is needed.
466     // This is used both for synthetic and real context losses. For real ones, it&#39;s
467     // likely that there&#39;s no JavaScript on the stack, but that might be dependent
468     // on how exactly the platform discovers that the context was lost. For better
469     // portability we always defer the dispatch of the event.
<a name="62" id="anc62"></a><span class="line-modified">470     SuspendableTimer m_dispatchContextLostEventTimer;</span>
<span class="line-added">471     SuspendableTimer m_dispatchContextChangedEventTimer;</span>
472     bool m_restoreAllowed { false };
<a name="63" id="anc63"></a><span class="line-modified">473     SuspendableTimer m_restoreTimer;</span>
474 
475     bool m_needsUpdate;
476     bool m_markedCanvasDirty;
477     HashSet&lt;WebGLContextObject*&gt; m_contextObjects;
478 
479     // List of bound VBO&#39;s. Used to maintain info about sizes for ARRAY_BUFFER and stored values for ELEMENT_ARRAY_BUFFER
480     RefPtr&lt;WebGLBuffer&gt; m_boundArrayBuffer;
481     RefPtr&lt;WebGLBuffer&gt; m_boundCopyReadBuffer;
482     RefPtr&lt;WebGLBuffer&gt; m_boundCopyWriteBuffer;
483     RefPtr&lt;WebGLBuffer&gt; m_boundPixelPackBuffer;
484     RefPtr&lt;WebGLBuffer&gt; m_boundPixelUnpackBuffer;
485     RefPtr&lt;WebGLBuffer&gt; m_boundTransformFeedbackBuffer;
486     RefPtr&lt;WebGLBuffer&gt; m_boundUniformBuffer;
487 
488     RefPtr&lt;WebGLVertexArrayObjectBase&gt; m_defaultVertexArrayObject;
489     RefPtr&lt;WebGLVertexArrayObjectBase&gt; m_boundVertexArrayObject;
490 
491     void setBoundVertexArrayObject(WebGLVertexArrayObjectBase* arrayObject)
492     {
493         m_boundVertexArrayObject = arrayObject ? arrayObject : m_defaultVertexArrayObject;
494     }
495 
496     class VertexAttribValue {
497     public:
498         VertexAttribValue()
499         {
500             initValue();
501         }
502 
503         void initValue()
504         {
505             value[0] = 0.0f;
506             value[1] = 0.0f;
507             value[2] = 0.0f;
508             value[3] = 1.0f;
509         }
510 
<a name="64" id="anc64"></a><span class="line-modified">511         GCGLfloat value[4];</span>
512     };
513     Vector&lt;VertexAttribValue&gt; m_vertexAttribValue;
514     unsigned m_maxVertexAttribs;
515     RefPtr&lt;WebGLBuffer&gt; m_vertexAttrib0Buffer;
516     long m_vertexAttrib0BufferSize { 0 };
<a name="65" id="anc65"></a><span class="line-modified">517     GCGLfloat m_vertexAttrib0BufferValue[4];</span>
518     bool m_forceAttrib0BufferRefill { true };
519     bool m_vertexAttrib0UsedBefore { false };
520 
521     RefPtr&lt;WebGLProgram&gt; m_currentProgram;
522     RefPtr&lt;WebGLFramebuffer&gt; m_framebufferBinding;
523     RefPtr&lt;WebGLFramebuffer&gt; m_readFramebufferBinding;
524     RefPtr&lt;WebGLRenderbuffer&gt; m_renderbufferBinding;
525     struct TextureUnitState {
526         RefPtr&lt;WebGLTexture&gt; texture2DBinding;
527         RefPtr&lt;WebGLTexture&gt; textureCubeMapBinding;
528     };
529     Vector&lt;TextureUnitState&gt; m_textureUnits;
530     HashSet&lt;unsigned, DefaultHash&lt;unsigned&gt;::Hash, WTF::UnsignedWithZeroKeyHashTraits&lt;unsigned&gt;&gt; m_unrenderableTextureUnits;
531 
532     unsigned long m_activeTextureUnit;
533 
534     RefPtr&lt;WebGLTexture&gt; m_blackTexture2D;
535     RefPtr&lt;WebGLTexture&gt; m_blackTextureCubeMap;
536 
<a name="66" id="anc66"></a><span class="line-modified">537     Vector&lt;GCGLenum&gt; m_compressedTextureFormats;</span>
538 
539     // Fixed-size cache of reusable image buffers for video texImage2D calls.
540     class LRUImageBufferCache {
541     public:
542         LRUImageBufferCache(int capacity);
543         // The pointer returned is owned by the image buffer map.
544         ImageBuffer* imageBuffer(const IntSize&amp; size);
545     private:
546         void bubbleToFront(size_t idx);
547         Vector&lt;std::unique_ptr&lt;ImageBuffer&gt;&gt; m_buffers;
548     };
549     LRUImageBufferCache m_generatedImageCache { 0 };
550 
<a name="67" id="anc67"></a><span class="line-modified">551     GCGLint m_maxTextureSize;</span>
<span class="line-modified">552     GCGLint m_maxCubeMapTextureSize;</span>
<span class="line-modified">553     GCGLint m_maxRenderbufferSize;</span>
<span class="line-modified">554     GCGLint m_maxViewportDims[2] { 0, 0 };</span>
<span class="line-modified">555     GCGLint m_maxTextureLevel;</span>
<span class="line-modified">556     GCGLint m_maxCubeMapTextureLevel;</span>
557 
<a name="68" id="anc68"></a><span class="line-modified">558     GCGLint m_maxDrawBuffers;</span>
<span class="line-modified">559     GCGLint m_maxColorAttachments;</span>
<span class="line-modified">560     GCGLenum m_backDrawBuffer;</span>
561     bool m_drawBuffersWebGLRequirementsChecked;
562     bool m_drawBuffersSupported;
563 
<a name="69" id="anc69"></a><span class="line-modified">564     GCGLint m_packAlignment;</span>
<span class="line-modified">565     GCGLint m_unpackAlignment;</span>
566     bool m_unpackFlipY;
567     bool m_unpackPremultiplyAlpha;
<a name="70" id="anc70"></a><span class="line-modified">568     GCGLenum m_unpackColorspaceConversion;</span>
569     bool m_contextLost { false };
570     LostContextMode m_contextLostMode { SyntheticLostContext };
571     WebGLContextAttributes m_attributes;
572 
573     bool m_layerCleared;
<a name="71" id="anc71"></a><span class="line-modified">574     GCGLfloat m_clearColor[4];</span>
575     bool m_scissorEnabled;
<a name="72" id="anc72"></a><span class="line-modified">576     GCGLfloat m_clearDepth;</span>
<span class="line-modified">577     GCGLint m_clearStencil;</span>
<span class="line-modified">578     GCGLboolean m_colorMask[4];</span>
<span class="line-modified">579     GCGLboolean m_depthMask;</span>
580 
581     bool m_stencilEnabled;
<a name="73" id="anc73"></a><span class="line-modified">582     GCGLuint m_stencilMask, m_stencilMaskBack;</span>
<span class="line-modified">583     GCGLint m_stencilFuncRef, m_stencilFuncRefBack; // Note that these are the user specified values, not the internal clamped value.</span>
<span class="line-modified">584     GCGLuint m_stencilFuncMask, m_stencilFuncMaskBack;</span>
585 
586     bool m_isGLES2Compliant;
587     bool m_isGLES2NPOTStrict;
588     bool m_isDepthStencilSupported;
589     bool m_isRobustnessEXTSupported;
590 
591     bool m_synthesizedErrorsToConsole { true };
592     int m_numGLErrorsToConsoleAllowed;
593 
594     bool m_preventBufferClearForInspector { false };
595 
596     // A WebGLRenderingContext can be created in a state where it appears as
597     // a valid and active context, but will not execute any important operations
598     // until its load policy is completely resolved.
599     bool m_isPendingPolicyResolution { false };
600     bool m_hasRequestedPolicyResolution { false };
601     bool isContextLostOrPending();
602 
603     // Enabled extension objects.
604     // FIXME: Move some of these to WebGLRenderingContext, the ones not needed for WebGL2
605     std::unique_ptr&lt;EXTFragDepth&gt; m_extFragDepth;
606     std::unique_ptr&lt;EXTBlendMinMax&gt; m_extBlendMinMax;
607     std::unique_ptr&lt;EXTsRGB&gt; m_extsRGB;
608     std::unique_ptr&lt;EXTTextureFilterAnisotropic&gt; m_extTextureFilterAnisotropic;
609     std::unique_ptr&lt;EXTShaderTextureLOD&gt; m_extShaderTextureLOD;
610     std::unique_ptr&lt;OESTextureFloat&gt; m_oesTextureFloat;
611     std::unique_ptr&lt;OESTextureFloatLinear&gt; m_oesTextureFloatLinear;
612     std::unique_ptr&lt;OESTextureHalfFloat&gt; m_oesTextureHalfFloat;
613     std::unique_ptr&lt;OESTextureHalfFloatLinear&gt; m_oesTextureHalfFloatLinear;
614     std::unique_ptr&lt;OESStandardDerivatives&gt; m_oesStandardDerivatives;
615     std::unique_ptr&lt;OESVertexArrayObject&gt; m_oesVertexArrayObject;
616     std::unique_ptr&lt;OESElementIndexUint&gt; m_oesElementIndexUint;
617     std::unique_ptr&lt;WebGLLoseContext&gt; m_webglLoseContext;
618     std::unique_ptr&lt;WebGLDebugRendererInfo&gt; m_webglDebugRendererInfo;
619     std::unique_ptr&lt;WebGLDebugShaders&gt; m_webglDebugShaders;
620     std::unique_ptr&lt;WebGLCompressedTextureASTC&gt; m_webglCompressedTextureASTC;
621     std::unique_ptr&lt;WebGLCompressedTextureATC&gt; m_webglCompressedTextureATC;
<a name="74" id="anc74"></a><span class="line-added">622     std::unique_ptr&lt;WebGLCompressedTextureETC&gt; m_webglCompressedTextureETC;</span>
<span class="line-added">623     std::unique_ptr&lt;WebGLCompressedTextureETC1&gt; m_webglCompressedTextureETC1;</span>
624     std::unique_ptr&lt;WebGLCompressedTexturePVRTC&gt; m_webglCompressedTexturePVRTC;
625     std::unique_ptr&lt;WebGLCompressedTextureS3TC&gt; m_webglCompressedTextureS3TC;
626     std::unique_ptr&lt;WebGLDepthTexture&gt; m_webglDepthTexture;
627     std::unique_ptr&lt;WebGLDrawBuffers&gt; m_webglDrawBuffers;
628     std::unique_ptr&lt;ANGLEInstancedArrays&gt; m_angleInstancedArrays;
629 
630     // Helpers for getParameter and other similar functions.
<a name="75" id="anc75"></a><span class="line-modified">631     bool getBooleanParameter(GCGLenum);</span>
<span class="line-modified">632     Vector&lt;bool&gt; getBooleanArrayParameter(GCGLenum);</span>
<span class="line-modified">633     float getFloatParameter(GCGLenum);</span>
<span class="line-modified">634     int getIntParameter(GCGLenum);</span>
<span class="line-modified">635     unsigned getUnsignedIntParameter(GCGLenum);</span>
<span class="line-modified">636     long long getInt64Parameter(GCGLenum);</span>
<span class="line-modified">637     RefPtr&lt;Float32Array&gt; getWebGLFloatArrayParameter(GCGLenum);</span>
<span class="line-modified">638     RefPtr&lt;Int32Array&gt; getWebGLIntArrayParameter(GCGLenum);</span>
639 
640     // Clear the backbuffer if it was composited since the last operation.
641     // clearMask is set to the bitfield of any clear that would happen anyway at this time
642     // and the function returns true if that clear is now unnecessary.
<a name="76" id="anc76"></a><span class="line-modified">643     bool clearIfComposited(GCGLbitfield clearMask = 0);</span>
644 
645     // Helper to restore state that clearing the framebuffer may destroy.
646     void restoreStateAfterClear();
647 
<a name="77" id="anc77"></a><span class="line-modified">648     void texImage2DBase(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, const void* pixels);</span>
<span class="line-modified">649     void texImage2DImpl(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLenum format, GCGLenum type, Image*, GraphicsContextGL::DOMSource, bool flipY, bool premultiplyAlpha);</span>
<span class="line-modified">650     void texSubImage2DBase(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum internalformat, GCGLenum format, GCGLenum type, const void* pixels);</span>
<span class="line-modified">651     void texSubImage2DImpl(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLenum format, GCGLenum type, Image*, GraphicsContextGL::DOMSource, bool flipY, bool premultiplyAlpha);</span>
652 
653     bool checkTextureCompleteness(const char*, bool);
654 
655     void createFallbackBlackTextures1x1();
656 
657     // Helper function for copyTex{Sub}Image, check whether the internalformat
658     // and the color buffer format of the current bound framebuffer combination
659     // is valid.
<a name="78" id="anc78"></a><span class="line-modified">660     bool isTexInternalFormatColorBufferCombinationValid(GCGLenum texInternalFormat, GCGLenum colorBufferFormat);</span>

661 
662     // Helper function to get the bound framebuffer&#39;s color buffer format.
<a name="79" id="anc79"></a><span class="line-modified">663     GCGLenum getBoundFramebufferColorFormat();</span>
664 
665     // Helper function to get the bound framebuffer&#39;s width.
666     int getBoundFramebufferWidth();
667 
668     // Helper function to get the bound framebuffer&#39;s height.
669     int getBoundFramebufferHeight();
670 
671     // Helper function to verify limits on the length of uniform and attribute locations.
672     bool validateLocationLength(const char* functionName, const String&amp;);
673 
674     // Helper function to check if size is non-negative.
675     // Generate GL error and return false for negative inputs; otherwise, return true.
<a name="80" id="anc80"></a><span class="line-modified">676     bool validateSize(const char* functionName, GCGLint x, GCGLint y);</span>
677 
678     // Helper function to check if all characters in the string belong to the
679     // ASCII subset as defined in GLSL ES 1.0 spec section 3.1.
680     bool validateString(const char* functionName, const String&amp;);
681 
682     // Helper function to check target and texture bound to the target.
683     // Generate GL errors and return 0 if target is invalid or texture bound is
684     // null.  Otherwise, return the texture bound to the target.
<a name="81" id="anc81"></a><span class="line-modified">685     RefPtr&lt;WebGLTexture&gt; validateTextureBinding(const char* functionName, GCGLenum target, bool useSixEnumsForCubeMap);</span>
686 
687     // Helper function to check input format/type for functions {copy}Tex{Sub}Image.
688     // Generates GL error and returns false if parameters are invalid.
<a name="82" id="anc82"></a><span class="line-modified">689     bool validateTexFuncFormatAndType(const char* functionName, GCGLenum internalformat, GCGLenum format, GCGLenum type, GCGLint level);</span>
690 
691     // Helper function to check input level for functions {copy}Tex{Sub}Image.
692     // Generates GL error and returns false if level is invalid.
<a name="83" id="anc83"></a><span class="line-modified">693     bool validateTexFuncLevel(const char* functionName, GCGLenum target, GCGLint level);</span>
694 
695     enum TexFuncValidationFunctionType {
696         TexImage,
697         TexSubImage,
698         CopyTexImage
699     };
700 
701     enum TexFuncValidationSourceType {
702         SourceArrayBufferView,
703         SourceImageBitmap,
704         SourceImageData,
705         SourceHTMLImageElement,
706         SourceHTMLCanvasElement,
707 #if ENABLE(VIDEO)
708         SourceHTMLVideoElement,
709 #endif
710     };
711 
712     // Helper function for tex{Sub}Image2D to check if the input format/type/level/target/width/height/border/xoffset/yoffset are valid.
713     // Otherwise, it would return quickly without doing other work.
<a name="84" id="anc84"></a><span class="line-modified">714     bool validateTexFunc(const char* functionName, TexFuncValidationFunctionType, TexFuncValidationSourceType, GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width,</span>
<span class="line-modified">715         GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, GCGLint xoffset, GCGLint yoffset);</span>
716 
717     // Helper function to check input parameters for functions {copy}Tex{Sub}Image.
718     // Generates GL error and returns false if parameters are invalid.
719     bool validateTexFuncParameters(const char* functionName,
720         TexFuncValidationFunctionType,
<a name="85" id="anc85"></a><span class="line-modified">721         GCGLenum target, GCGLint level,</span>
<span class="line-modified">722         GCGLenum internalformat,</span>
<span class="line-modified">723         GCGLsizei width, GCGLsizei height, GCGLint border,</span>
<span class="line-modified">724         GCGLenum format, GCGLenum type);</span>
725 
726     enum NullDisposition {
727         NullAllowed,
728         NullNotAllowed
729     };
730 
731     // Helper function to validate that the given ArrayBufferView
732     // is of the correct type and contains enough data for the texImage call.
733     // Generates GL error and returns false if parameters are invalid.
<a name="86" id="anc86"></a><span class="line-modified">734     bool validateTexFuncData(const char* functionName, GCGLint level,</span>
<span class="line-modified">735         GCGLsizei width, GCGLsizei height,</span>
<span class="line-modified">736         GCGLenum internalformat, GCGLenum format, GCGLenum type,</span>
737         ArrayBufferView* pixels,
738         NullDisposition);
739 
740     // Helper function to validate a given texture format is settable as in
741     // you can supply data to texImage2D, or call texImage2D, copyTexImage2D and
742     // copyTexSubImage2D.
743     // Generates GL error and returns false if the format is not settable.
<a name="87" id="anc87"></a><span class="line-modified">744     bool validateSettableTexInternalFormat(const char* functionName, GCGLenum format);</span>
745 
746     // Helper function to validate compressed texture data is correct size
747     // for the given format and dimensions.
<a name="88" id="anc88"></a><span class="line-modified">748     bool validateCompressedTexFuncData(const char* functionName, GCGLsizei width, GCGLsizei height, GCGLenum format, ArrayBufferView&amp; pixels);</span>
749 
750     // Helper function for validating compressed texture formats.
<a name="89" id="anc89"></a><span class="line-modified">751     bool validateCompressedTexFormat(GCGLenum format);</span>
752 
753     // Helper function to validate compressed texture dimensions are valid for
754     // the given format.
<a name="90" id="anc90"></a><span class="line-modified">755     bool validateCompressedTexDimensions(const char* functionName, GCGLenum target, GCGLint level, GCGLsizei width, GCGLsizei height, GCGLenum format);</span>
756 
757     // Helper function to validate compressed texture dimensions are valid for
758     // the given format.
<a name="91" id="anc91"></a><span class="line-modified">759     bool validateCompressedTexSubDimensions(const char* functionName, GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset,</span>
<span class="line-modified">760         GCGLsizei width, GCGLsizei height, GCGLenum format, WebGLTexture*);</span>
761 
762     // Helper function to validate mode for draw{Arrays/Elements}.
<a name="92" id="anc92"></a><span class="line-modified">763     bool validateDrawMode(const char* functionName, GCGLenum);</span>
764 
765     // Helper function to validate if front/back stencilMask and stencilFunc settings are the same.
766     bool validateStencilSettings(const char* functionName);
767 
768     // Helper function to validate stencil func.
<a name="93" id="anc93"></a><span class="line-modified">769     bool validateStencilFunc(const char* functionName, GCGLenum);</span>
770 
771     // Helper function for texParameterf and texParameteri.
<a name="94" id="anc94"></a><span class="line-modified">772     void texParameter(GCGLenum target, GCGLenum pname, GCGLfloat parami, GCGLint paramf, bool isFloat);</span>
773 
774     // Helper function to print errors and warnings to console.
775     void printToConsole(MessageLevel, const String&amp;);
776 
777     // Helper function to validate input parameters for framebuffer functions.
778     // Generate GL error if parameters are illegal.
<a name="95" id="anc95"></a><span class="line-modified">779     virtual bool validateFramebufferFuncParameters(const char* functionName, GCGLenum target, GCGLenum attachment) = 0;</span>
780 
781     // Helper function to validate blend equation mode.
<a name="96" id="anc96"></a><span class="line-modified">782     virtual bool validateBlendEquation(const char* functionName, GCGLenum) = 0;</span>
783 
784     // Helper function to validate blend func factors.
<a name="97" id="anc97"></a><span class="line-modified">785     bool validateBlendFuncFactors(const char* functionName, GCGLenum src, GCGLenum dst);</span>
786 
787     // Helper function to validate a GL capability.
<a name="98" id="anc98"></a><span class="line-modified">788     virtual bool validateCapability(const char* functionName, GCGLenum) = 0;</span>
789 
790     // Helper function to validate input parameters for uniform functions.
<a name="99" id="anc99"></a><span class="line-modified">791     bool validateUniformParameters(const char* functionName, const WebGLUniformLocation*, const Float32List&amp;, GCGLsizei mod);</span>
<span class="line-modified">792     bool validateUniformParameters(const char* functionName, const WebGLUniformLocation*, const Int32List&amp;, GCGLsizei mod);</span>
<span class="line-modified">793     bool validateUniformParameters(const char* functionName, const WebGLUniformLocation*, void*, GCGLsizei, GCGLsizei mod);</span>
<span class="line-modified">794     bool validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation*, GCGLboolean transpose, const Float32List&amp;, GCGLsizei mod);</span>
<span class="line-modified">795     bool validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation*, GCGLboolean transpose, const void*, GCGLsizei, GCGLsizei mod);</span>
796 
797     // Helper function to validate parameters for bufferData.
798     // Return the current bound buffer to target, or 0 if parameters are invalid.
<a name="100" id="anc100"></a><span class="line-modified">799     WebGLBuffer* validateBufferDataParameters(const char* functionName, GCGLenum target, GCGLenum usage);</span>
800 
801     // Helper function for tex{Sub}Image2D to make sure image is ready.
802     ExceptionOr&lt;bool&gt; validateHTMLImageElement(const char* functionName, HTMLImageElement*);
803     ExceptionOr&lt;bool&gt; validateHTMLCanvasElement(const char* functionName, HTMLCanvasElement*);
804 #if ENABLE(VIDEO)
805     ExceptionOr&lt;bool&gt; validateHTMLVideoElement(const char* functionName, HTMLVideoElement*);
806 #endif
807 
808     // Helper functions for vertexAttribNf{v}.
<a name="101" id="anc101"></a><span class="line-modified">809     void vertexAttribfImpl(const char* functionName, GCGLuint index, GCGLsizei expectedSize, GCGLfloat, GCGLfloat, GCGLfloat, GCGLfloat);</span>
<span class="line-modified">810     void vertexAttribfvImpl(const char* functionName, GCGLuint index, Float32List&amp;&amp;, GCGLsizei expectedSize);</span>
811 
812     // Helper function for delete* (deleteBuffer, deleteProgram, etc) functions.
813     // Return false if caller should return without further processing.
814     bool deleteObject(WebGLObject*);
815 
816     // Helper function for bind* (bindBuffer, bindTexture, etc) and useProgram.
817     // If the object has already been deleted, set deleted to true upon return.
818     // Return false if caller should return without further processing.
819     bool checkObjectToBeBound(const char* functionName, WebGLObject*, bool&amp; deleted);
820 
<a name="102" id="anc102"></a><span class="line-added">821     bool validateAndCacheBufferBinding(const char* functionName, GCGLenum target, WebGLBuffer*);</span>
<span class="line-added">822 </span>
823     // Helpers for simulating vertexAttrib0.
824     void initVertexAttrib0();
<a name="103" id="anc103"></a><span class="line-modified">825     Optional&lt;bool&gt; simulateVertexAttrib0(GCGLuint numVertex);</span>
<span class="line-modified">826     bool validateSimulatedVertexAttrib0(GCGLuint numVertex);</span>
827     void restoreStatesAfterVertexAttrib0Simulation();
828 
<a name="104" id="anc104"></a><span class="line-modified">829     // Wrapper for GraphicsContextGLOpenGL::synthesizeGLError that sends a message to the JavaScript console.</span>




830     enum ConsoleDisplayPreference { DisplayInConsole, DontDisplayInConsole };
<a name="105" id="anc105"></a><span class="line-modified">831     void synthesizeGLError(GCGLenum, const char* functionName, const char* description, ConsoleDisplayPreference = DisplayInConsole);</span>
832 
833     String ensureNotNull(const String&amp;) const;
834 
835     // Enable or disable stencil test based on user setting and whether the current FBO has a stencil buffer.
836     void applyStencilTest();
837 
838     // Helper for enabling or disabling a capability.
<a name="106" id="anc106"></a><span class="line-modified">839     void enableOrDisable(GCGLenum capability, bool enable);</span>
840 
841     // Clamp the width and height to GL_MAX_VIEWPORT_DIMS.
842     IntSize clampedCanvasSize();
843 
<a name="107" id="anc107"></a><span class="line-modified">844     virtual GCGLint getMaxDrawBuffers() = 0;</span>
<span class="line-modified">845     virtual GCGLint getMaxColorAttachments() = 0;</span>
846 
<a name="108" id="anc108"></a><span class="line-modified">847     void setBackDrawBuffer(GCGLenum);</span>
848 
849     void restoreCurrentFramebuffer();
850     void restoreCurrentTexture2D();
851 
852     // Check if EXT_draw_buffers extension is supported and if it satisfies the WebGL requirements.
853     bool supportsDrawBuffers();
854 
<a name="109" id="anc109"></a><span class="line-added">855 #if ENABLE(OFFSCREEN_CANVAS)</span>
856     OffscreenCanvas* offscreenCanvas();
<a name="110" id="anc110"></a><span class="line-added">857 #endif</span>
858 
859     template &lt;typename T&gt; inline Optional&lt;T&gt; checkedAddAndMultiply(T value, T add, T multiply);
<a name="111" id="anc111"></a><span class="line-modified">860     template &lt;typename T&gt; unsigned getMaxIndex(const RefPtr&lt;JSC::ArrayBuffer&gt; elementArrayBuffer, GCGLintptr uoffset, GCGLsizei n);</span>
861 
862 private:
<a name="112" id="anc112"></a><span class="line-modified">863     void dispatchContextLostEvent();</span>
<span class="line-added">864     void dispatchContextChangedEvent();</span>
<span class="line-added">865     // Helper for restoration after context lost.</span>
<span class="line-added">866     void maybeRestoreContext();</span>
<span class="line-added">867 </span>
<span class="line-added">868     bool validateArrayBufferType(const char* functionName, GCGLenum type, Optional&lt;JSC::TypedArrayType&gt;);</span>
869     void registerWithWebGLStateTracker();
870     void checkForContextLossHandling();
871 
872     void activityStateDidChange(OptionSet&lt;ActivityState::Flag&gt; oldActivityState, OptionSet&lt;ActivityState::Flag&gt; newActivityState) override;
873 
874     WebGLStateTracker::Token m_trackerToken;
875     Timer m_checkForContextLossHandlingTimer;
<a name="113" id="anc113"></a><span class="line-added">876     bool m_isSuspended { false };</span>
877 };
878 
879 template &lt;typename T&gt;
880 inline Optional&lt;T&gt; WebGLRenderingContextBase::checkedAddAndMultiply(T value, T add, T multiply)
881 {
882     Checked&lt;T, RecordOverflow&gt; checkedResult = Checked&lt;T&gt;(value);
883     checkedResult += Checked&lt;T&gt;(add);
884     checkedResult *= Checked&lt;T&gt;(multiply);
885     if (checkedResult.hasOverflowed())
886         return WTF::nullopt;
887 
888     return checkedResult.unsafeGet();
889 }
890 
891 template&lt;typename T&gt;
<a name="114" id="anc114"></a><span class="line-modified">892 inline unsigned WebGLRenderingContextBase::getMaxIndex(const RefPtr&lt;JSC::ArrayBuffer&gt; elementArrayBuffer, GCGLintptr uoffset, GCGLsizei n)</span>
893 {
894     unsigned maxIndex = 0;
895     T restartIndex = 0;
896 
897 #if ENABLE(WEBGL2)
898     // WebGL 2 spec enforces that GL_PRIMITIVE_RESTART_FIXED_INDEX is always enabled, so ignore the restart index.
899     if (isWebGL2())
900         restartIndex = std::numeric_limits&lt;T&gt;::max();
901 #endif
902 
903     // Make uoffset an element offset.
904     uoffset /= sizeof(T);
905     const T* p = static_cast&lt;const T*&gt;(elementArrayBuffer-&gt;data()) + uoffset;
906     while (n-- &gt; 0) {
907         if (*p != restartIndex &amp;&amp; *p &gt; maxIndex)
908             maxIndex = *p;
909         ++p;
910     }
911 
912     return maxIndex;
913 }
914 
915 } // namespace WebCore
916 
917 SPECIALIZE_TYPE_TRAITS_CANVASRENDERINGCONTEXT(WebCore::WebGLRenderingContextBase, isWebGL())
918 
919 #endif
<a name="115" id="anc115"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="115" type="hidden" />
</body>
</html>
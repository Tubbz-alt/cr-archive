<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBBackingStore.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2016-2017 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;SQLiteIDBBackingStore.h&quot;
  28 
  29 #if ENABLE(INDEXED_DATABASE)
  30 
  31 #include &quot;IDBBindingUtilities.h&quot;
  32 #include &quot;IDBCursorInfo.h&quot;
  33 #include &quot;IDBGetAllRecordsData.h&quot;
  34 #include &quot;IDBGetAllResult.h&quot;
  35 #include &quot;IDBGetRecordData.h&quot;
  36 #include &quot;IDBGetResult.h&quot;
  37 #include &quot;IDBIterateCursorData.h&quot;
  38 #include &quot;IDBKeyData.h&quot;
  39 #include &quot;IDBObjectStoreInfo.h&quot;
  40 #include &quot;IDBSerialization.h&quot;
  41 #include &quot;IDBSerializationContext.h&quot;
  42 #include &quot;IDBTransactionInfo.h&quot;
  43 #include &quot;IDBValue.h&quot;
  44 #include &quot;IndexKey.h&quot;
  45 #include &quot;Logging.h&quot;
  46 #include &quot;SQLiteDatabase.h&quot;
  47 #include &quot;SQLiteFileSystem.h&quot;
  48 #include &quot;SQLiteIDBCursor.h&quot;
  49 #include &quot;SQLiteStatement.h&quot;
  50 #include &quot;SQLiteTransaction.h&quot;
  51 #include &quot;ThreadSafeDataBuffer.h&quot;
  52 #include &lt;JavaScriptCore/AuxiliaryBarrierInlines.h&gt;
  53 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  54 #include &lt;JavaScriptCore/StrongInlines.h&gt;
  55 #include &lt;wtf/FileSystem.h&gt;
  56 #include &lt;wtf/NeverDestroyed.h&gt;
  57 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  58 
  59 namespace WebCore {
  60 using namespace JSC;
  61 namespace IDBServer {
  62 
  63 constexpr auto objectStoreInfoTableName = &quot;ObjectStoreInfo&quot;_s;
  64 constexpr auto objectStoreInfoTableNameAlternate = &quot;\&quot;ObjectStoreInfo\&quot;&quot;_s;
  65 constexpr auto v2ObjectStoreInfoSchema = &quot;CREATE TABLE ObjectStoreInfo (id INTEGER PRIMARY KEY NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, name TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, keyPath BLOB NOT NULL ON CONFLICT FAIL, autoInc INTEGER NOT NULL ON CONFLICT FAIL)&quot;_s;
  66 constexpr auto v1IndexRecordsRecordIndexSchema = &quot;CREATE INDEX IndexRecordsRecordIndex ON IndexRecords (objectStoreID, objectStoreRecordID)&quot;_s;
  67 constexpr auto IndexRecordsIndexSchema = &quot;CREATE INDEX IndexRecordsIndex ON IndexRecords (indexID, key, value)&quot;_s;
  68 
  69 // Current version of the metadata schema being used in the metadata database.
  70 static const int currentMetadataVersion = 1;
  71 
  72 // The IndexedDatabase spec defines the max key generator value as 2^53.
  73 static const uint64_t maxGeneratorValue = 0x20000000000000;
  74 
  75 static int idbKeyCollate(int aLength, const void* aBuffer, int bLength, const void* bBuffer)
  76 {
  77     IDBKeyData a, b;
  78     if (!deserializeIDBKeyData(static_cast&lt;const uint8_t*&gt;(aBuffer), aLength, a)) {
  79         LOG_ERROR(&quot;Unable to deserialize key A in collation function.&quot;);
  80 
  81         // There&#39;s no way to indicate an error to SQLite - we have to return a sorting decision.
  82         // We arbitrarily choose &quot;A &gt; B&quot;
  83         return 1;
  84     }
  85     if (!deserializeIDBKeyData(static_cast&lt;const uint8_t*&gt;(bBuffer), bLength, b)) {
  86         LOG_ERROR(&quot;Unable to deserialize key B in collation function.&quot;);
  87 
  88         // There&#39;s no way to indicate an error to SQLite - we have to return a sorting decision.
  89         // We arbitrarily choose &quot;A &gt; B&quot;
  90         return 1;
  91     }
  92 
  93     return a.compare(b);
  94 }
  95 
  96 static const String v1RecordsTableSchema(const String&amp; tableName)
  97 {
  98     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (objectStoreID INTEGER NOT NULL ON CONFLICT FAIL, key TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT REPLACE, value NOT NULL ON CONFLICT FAIL)&quot;);
  99 }
 100 
 101 static const String&amp; v1RecordsTableSchema()
 102 {
 103     static NeverDestroyed&lt;WTF::String&gt; v1RecordsTableSchemaString(v1RecordsTableSchema(&quot;Records&quot;));
 104     return v1RecordsTableSchemaString;
 105 }
 106 
 107 static const String&amp; v1RecordsTableSchemaAlternate()
 108 {
 109     static NeverDestroyed&lt;WTF::String&gt; v1RecordsTableSchemaString(v1RecordsTableSchema(&quot;\&quot;Records\&quot;&quot;));
 110     return v1RecordsTableSchemaString;
 111 }
 112 
 113 static const String v2RecordsTableSchema(const String&amp; tableName)
 114 {
 115     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (objectStoreID INTEGER NOT NULL ON CONFLICT FAIL, key TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL, value NOT NULL ON CONFLICT FAIL)&quot;);
 116 }
 117 
 118 static const String&amp; v2RecordsTableSchema()
 119 {
 120     static NeverDestroyed&lt;WTF::String&gt; v2RecordsTableSchemaString(v2RecordsTableSchema(&quot;Records&quot;));
 121     return v2RecordsTableSchemaString;
 122 }
 123 
 124 static const String&amp; v2RecordsTableSchemaAlternate()
 125 {
 126     static NeverDestroyed&lt;WTF::String&gt; v2RecordsTableSchemaString(v2RecordsTableSchema(&quot;\&quot;Records\&quot;&quot;));
 127     return v2RecordsTableSchemaString;
 128 }
 129 
 130 static const String v3RecordsTableSchema(const String&amp; tableName)
 131 {
 132     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (objectStoreID INTEGER NOT NULL ON CONFLICT FAIL, key TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL, value NOT NULL ON CONFLICT FAIL, recordID INTEGER PRIMARY KEY)&quot;);
 133 }
 134 
 135 static const String&amp; v3RecordsTableSchema()
 136 {
 137     static NeverDestroyed&lt;WTF::String&gt; v3RecordsTableSchemaString(v3RecordsTableSchema(&quot;Records&quot;));
 138     return v3RecordsTableSchemaString;
 139 }
 140 
 141 static const String&amp; v3RecordsTableSchemaAlternate()
 142 {
 143     static NeverDestroyed&lt;WTF::String&gt; v3RecordsTableSchemaString(v3RecordsTableSchema(&quot;\&quot;Records\&quot;&quot;));
 144     return v3RecordsTableSchemaString;
 145 }
 146 
 147 static const String v1IndexRecordsTableSchema(const String&amp; tableName)
 148 {
 149     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (indexID INTEGER NOT NULL ON CONFLICT FAIL, objectStoreID INTEGER NOT NULL ON CONFLICT FAIL, key TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL, value NOT NULL ON CONFLICT FAIL)&quot;);
 150 }
 151 
 152 static const String&amp; v1IndexRecordsTableSchema()
 153 {
 154     static NeverDestroyed&lt;WTF::String&gt; v1IndexRecordsTableSchemaString(v1IndexRecordsTableSchema(&quot;IndexRecords&quot;));
 155     return v1IndexRecordsTableSchemaString;
 156 }
 157 
 158 static const String&amp; v1IndexRecordsTableSchemaAlternate()
 159 {
 160     static NeverDestroyed&lt;WTF::String&gt; v1IndexRecordsTableSchemaString(v1IndexRecordsTableSchema(&quot;\&quot;IndexRecords\&quot;&quot;));
 161     return v1IndexRecordsTableSchemaString;
 162 }
 163 
 164 static const String v2IndexRecordsTableSchema(const String&amp; tableName)
 165 {
 166     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (indexID INTEGER NOT NULL ON CONFLICT FAIL, objectStoreID INTEGER NOT NULL ON CONFLICT FAIL, key TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL, value TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL)&quot;);
 167 }
 168 
 169 static const String&amp; v2IndexRecordsTableSchema()
 170 {
 171     static NeverDestroyed&lt;WTF::String&gt; v2IndexRecordsTableSchemaString(v2IndexRecordsTableSchema(&quot;IndexRecords&quot;));
 172     return v2IndexRecordsTableSchemaString;
 173 }
 174 
 175 static const String&amp; v2IndexRecordsTableSchemaAlternate()
 176 {
 177     static NeverDestroyed&lt;WTF::String&gt; v2IndexRecordsTableSchemaString(v2IndexRecordsTableSchema(&quot;\&quot;IndexRecords\&quot;&quot;));
 178     return v2IndexRecordsTableSchemaString;
 179 }
 180 
 181 static const String v3IndexRecordsTableSchema(const String&amp; tableName)
 182 {
 183     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (indexID INTEGER NOT NULL ON CONFLICT FAIL, objectStoreID INTEGER NOT NULL ON CONFLICT FAIL, key TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL, value TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL, objectStoreRecordID INTEGER NOT NULL ON CONFLICT FAIL)&quot;);
 184 }
 185 
 186 static const String v3IndexRecordsTableSchema()
 187 {
 188     static NeverDestroyed&lt;WTF::String&gt; indexRecordsTableSchemaString = v3IndexRecordsTableSchema(&quot;IndexRecords&quot;);
 189     return indexRecordsTableSchemaString;
 190 }
 191 
 192 static const String v3IndexRecordsTableSchemaAlternate()
 193 {
 194     static NeverDestroyed&lt;WTF::String&gt; indexRecordsTableSchemaString = v3IndexRecordsTableSchema(&quot;\&quot;IndexRecords\&quot;&quot;);
 195     return indexRecordsTableSchemaString;
 196 }
 197 
 198 static const String blobRecordsTableSchema(const String&amp; tableName)
 199 {
 200     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (objectStoreRow INTEGER NOT NULL ON CONFLICT FAIL, blobURL TEXT NOT NULL ON CONFLICT FAIL)&quot;);
 201 }
 202 
 203 static const String&amp; blobRecordsTableSchema()
 204 {
 205     static NeverDestroyed&lt;String&gt; blobRecordsTableSchemaString(blobRecordsTableSchema(&quot;BlobRecords&quot;));
 206     return blobRecordsTableSchemaString;
 207 }
 208 
 209 static const String&amp; blobRecordsTableSchemaAlternate()
 210 {
 211     static NeverDestroyed&lt;String&gt; blobRecordsTableSchemaString(blobRecordsTableSchema(&quot;\&quot;BlobRecords\&quot;&quot;));
 212     return blobRecordsTableSchemaString;
 213 }
 214 
 215 static const String blobFilesTableSchema(const String&amp; tableName)
 216 {
 217     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (blobURL TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, fileName TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL)&quot;);
 218 }
 219 
 220 static const String&amp; blobFilesTableSchema()
 221 {
 222     static NeverDestroyed&lt;String&gt; blobFilesTableSchemaString(blobFilesTableSchema(&quot;BlobFiles&quot;));
 223     return blobFilesTableSchemaString;
 224 }
 225 
 226 static const String&amp; blobFilesTableSchemaAlternate()
 227 {
 228     static NeverDestroyed&lt;String&gt; blobFilesTableSchemaString(blobFilesTableSchema(&quot;\&quot;BlobFiles\&quot;&quot;));
 229     return blobFilesTableSchemaString;
 230 }
 231 
 232 static String createV1ObjectStoreInfoSchema(ASCIILiteral tableName)
 233 {
 234     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (id INTEGER PRIMARY KEY NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, name TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, keyPath BLOB NOT NULL ON CONFLICT FAIL, autoInc INTEGER NOT NULL ON CONFLICT FAIL, maxIndexID INTEGER NOT NULL ON CONFLICT FAIL)&quot;);
 235 }
 236 
 237 static String createV2ObjectStoreInfoSchema(ASCIILiteral tableName)
 238 {
 239     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (id INTEGER PRIMARY KEY NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, name TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, keyPath BLOB NOT NULL ON CONFLICT FAIL, autoInc INTEGER NOT NULL ON CONFLICT FAIL)&quot;);
 240 }
 241 
 242 SQLiteIDBBackingStore::SQLiteIDBBackingStore(PAL::SessionID sessionID, const IDBDatabaseIdentifier&amp; identifier, const String&amp; databaseRootDirectory)
 243     : m_sessionID(sessionID)
 244     , m_identifier(identifier)
 245     , m_databaseRootDirectory(databaseRootDirectory)
 246     , m_serializationContext(IDBSerializationContext::getOrCreateIDBSerializationContext(sessionID))
 247 {
 248     m_databaseDirectory = fullDatabaseDirectoryWithUpgrade();
 249 }
 250 
 251 SQLiteIDBBackingStore::~SQLiteIDBBackingStore()
 252 {
 253     if (m_sqliteDB)
 254         closeSQLiteDB();
 255 }
 256 
 257 static bool createOrMigrateRecordsTableIfNecessary(SQLiteDatabase&amp; database)
 258 {
 259     String currentSchema;
 260     {
 261         // Fetch the schema for an existing records table.
 262         SQLiteStatement statement(database, &quot;SELECT type, sql FROM sqlite_master WHERE tbl_name=&#39;Records&#39;&quot;);
 263         if (statement.prepare() != SQLITE_OK) {
 264             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the Records table.&quot;);
 265             return false;
 266         }
 267 
 268         int sqliteResult = statement.step();
 269 
 270         // If there is no Records table at all, create it and then bail.
 271         if (sqliteResult == SQLITE_DONE) {
 272             if (!database.executeCommand(v3RecordsTableSchema())) {
 273                 LOG_ERROR(&quot;Could not create Records table in database (%i) - %s&quot;, database.lastError(), database.lastErrorMsg());
 274                 return false;
 275             }
 276 
 277             return true;
 278         }
 279 
 280         if (sqliteResult != SQLITE_ROW) {
 281             LOG_ERROR(&quot;Error executing statement to fetch schema for the Records table.&quot;);
 282             return false;
 283         }
 284 
 285         currentSchema = statement.getColumnText(1);
 286     }
 287 
 288     ASSERT(!currentSchema.isEmpty());
 289 
 290     // If the schema in the backing store is the current schema, we&#39;re done.
 291     if (currentSchema == v3RecordsTableSchema() || currentSchema == v3RecordsTableSchemaAlternate())
 292         return true;
 293 
 294     // If the record table is not the current schema then it must be one of the previous schemas.
 295     // If it is not then the database is in an unrecoverable state and this should be considered a fatal error.
 296     if (currentSchema != v1RecordsTableSchema() &amp;&amp; currentSchema != v1RecordsTableSchemaAlternate()
 297         &amp;&amp; currentSchema != v2RecordsTableSchema() &amp;&amp; currentSchema != v2RecordsTableSchemaAlternate())
 298         RELEASE_ASSERT_NOT_REACHED();
 299 
 300     SQLiteTransaction transaction(database);
 301     transaction.begin();
 302 
 303     // Create a temporary table with the correct schema and migrate all existing content over.
 304     if (!database.executeCommand(v3RecordsTableSchema(&quot;_Temp_Records&quot;))) {
 305         LOG_ERROR(&quot;Could not create temporary records table in database (%i) - %s&quot;, database.lastError(), database.lastErrorMsg());
 306         return false;
 307     }
 308 
 309     if (!database.executeCommand(&quot;INSERT INTO _Temp_Records (objectStoreID, key, value) SELECT objectStoreID, CAST(key AS TEXT), value FROM Records&quot;)) {
 310         LOG_ERROR(&quot;Could not migrate existing Records content (%i) - %s&quot;, database.lastError(), database.lastErrorMsg());
 311         return false;
 312     }
 313 
 314     if (!database.executeCommand(&quot;DROP TABLE Records&quot;)) {
 315         LOG_ERROR(&quot;Could not drop existing Records table (%i) - %s&quot;, database.lastError(), database.lastErrorMsg());
 316         return false;
 317     }
 318 
 319     if (!database.executeCommand(&quot;ALTER TABLE _Temp_Records RENAME TO Records&quot;)) {
 320         LOG_ERROR(&quot;Could not rename temporary Records table (%i) - %s&quot;, database.lastError(), database.lastErrorMsg());
 321         return false;
 322     }
 323 
 324     transaction.commit();
 325 
 326     return true;
 327 }
 328 
 329 bool SQLiteIDBBackingStore::ensureValidBlobTables()
 330 {
 331     ASSERT(m_sqliteDB);
 332     ASSERT(m_sqliteDB-&gt;isOpen());
 333 
 334     String currentSchema;
 335     {
 336         // Fetch the schema for an existing blob record table.
 337         SQLiteStatement statement(*m_sqliteDB, &quot;SELECT type, sql FROM sqlite_master WHERE tbl_name=&#39;BlobRecords&#39;&quot;);
 338         if (statement.prepare() != SQLITE_OK) {
 339             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the BlobRecords table.&quot;);
 340             return false;
 341         }
 342 
 343         int sqliteResult = statement.step();
 344 
 345         // If there is no BlobRecords table at all, create it..
 346         if (sqliteResult == SQLITE_DONE) {
 347             if (!m_sqliteDB-&gt;executeCommand(blobRecordsTableSchema())) {
 348                 LOG_ERROR(&quot;Could not create BlobRecords table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 349                 return false;
 350             }
 351 
 352             currentSchema = blobRecordsTableSchema();
 353         } else if (sqliteResult != SQLITE_ROW) {
 354             LOG_ERROR(&quot;Error executing statement to fetch schema for the BlobRecords table.&quot;);
 355             return false;
 356         } else
 357             currentSchema = statement.getColumnText(1);
 358     }
 359 
 360     if (currentSchema != blobRecordsTableSchema() &amp;&amp; currentSchema != blobRecordsTableSchemaAlternate()) {
 361         LOG_ERROR(&quot;Invalid BlobRecords table schema found&quot;);
 362         return false;
 363     }
 364 
 365     {
 366         // Fetch the schema for an existing blob file table.
 367         SQLiteStatement statement(*m_sqliteDB, &quot;SELECT type, sql FROM sqlite_master WHERE tbl_name=&#39;BlobFiles&#39;&quot;);
 368         if (statement.prepare() != SQLITE_OK) {
 369             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the BlobFiles table.&quot;);
 370             return false;
 371         }
 372 
 373         int sqliteResult = statement.step();
 374 
 375         // If there is no BlobFiles table at all, create it and then bail.
 376         if (sqliteResult == SQLITE_DONE) {
 377             if (!m_sqliteDB-&gt;executeCommand(blobFilesTableSchema())) {
 378                 LOG_ERROR(&quot;Could not create BlobFiles table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 379                 return false;
 380             }
 381 
 382             return true;
 383         }
 384 
 385         if (sqliteResult != SQLITE_ROW) {
 386             LOG_ERROR(&quot;Error executing statement to fetch schema for the BlobFiles table.&quot;);
 387             return false;
 388         }
 389 
 390         currentSchema = statement.getColumnText(1);
 391     }
 392 
 393     if (currentSchema != blobFilesTableSchema() &amp;&amp; currentSchema != blobFilesTableSchemaAlternate()) {
 394         LOG_ERROR(&quot;Invalid BlobFiles table schema found&quot;);
 395         return false;
 396     }
 397 
 398     return true;
 399 }
 400 
 401 bool SQLiteIDBBackingStore::ensureValidRecordsTable()
 402 {
 403     ASSERT(m_sqliteDB);
 404     ASSERT(m_sqliteDB-&gt;isOpen());
 405 
 406     if (!createOrMigrateRecordsTableIfNecessary(*m_sqliteDB))
 407         return false;
 408 
 409     // Whether the updated records table already existed or if it was just created and the data migrated over,
 410     // make sure the uniqueness index exists.
 411     if (!m_sqliteDB-&gt;executeCommand(&quot;CREATE UNIQUE INDEX IF NOT EXISTS RecordsIndex ON Records (objectStoreID, key);&quot;)) {
 412         LOG_ERROR(&quot;Could not create RecordsIndex on Records table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 413         return false;
 414     }
 415 
 416     return true;
 417 }
 418 
 419 bool SQLiteIDBBackingStore::ensureValidIndexRecordsTable()
 420 {
 421     ASSERT(m_sqliteDB);
 422     ASSERT(m_sqliteDB-&gt;isOpen());
 423 
 424     String currentSchema;
 425     {
 426         // Fetch the schema for an existing index record table.
 427         SQLiteStatement statement(*m_sqliteDB, &quot;SELECT type, sql FROM sqlite_master WHERE tbl_name=&#39;IndexRecords&#39;&quot;);
 428         if (statement.prepare() != SQLITE_OK) {
 429             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the IndexRecords table.&quot;);
 430             return false;
 431         }
 432 
 433         int sqliteResult = statement.step();
 434 
 435         // If there is no IndexRecords table at all, create it and then bail.
 436         if (sqliteResult == SQLITE_DONE) {
 437             if (!m_sqliteDB-&gt;executeCommand(v3IndexRecordsTableSchema())) {
 438                 LOG_ERROR(&quot;Could not create IndexRecords table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 439                 return false;
 440             }
 441 
 442             return true;
 443         }
 444 
 445         if (sqliteResult != SQLITE_ROW) {
 446             LOG_ERROR(&quot;Error executing statement to fetch schema for the IndexRecords table.&quot;);
 447             return false;
 448         }
 449 
 450         currentSchema = statement.getColumnText(1);
 451     }
 452 
 453     ASSERT(!currentSchema.isEmpty());
 454 
 455     // If the schema in the backing store is the current schema, we&#39;re done.
 456     if (currentSchema == v3IndexRecordsTableSchema() || currentSchema == v3IndexRecordsTableSchemaAlternate())
 457         return true;
 458 
 459     // If the record table is not the current schema then it must be one of the previous schemas.
 460     // If it is not then the database is in an unrecoverable state and this should be considered a fatal error.
 461     if (currentSchema != v1IndexRecordsTableSchema() &amp;&amp; currentSchema != v1IndexRecordsTableSchemaAlternate()
 462         &amp;&amp; currentSchema != v2IndexRecordsTableSchema() &amp;&amp; currentSchema != v2IndexRecordsTableSchemaAlternate())
 463         RELEASE_ASSERT_NOT_REACHED();
 464 
 465     SQLiteTransaction transaction(*m_sqliteDB);
 466     transaction.begin();
 467 
 468     // Create a temporary table with the correct schema and migrate all existing content over.
 469     if (!m_sqliteDB-&gt;executeCommand(v3IndexRecordsTableSchema(&quot;_Temp_IndexRecords&quot;))) {
 470         LOG_ERROR(&quot;Could not create temporary index records table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 471         return false;
 472     }
 473 
 474     if (!m_sqliteDB-&gt;executeCommand(&quot;INSERT INTO _Temp_IndexRecords SELECT IndexRecords.indexID, IndexRecords.objectStoreID, IndexRecords.key, IndexRecords.value, Records.rowid FROM IndexRecords INNER JOIN Records ON Records.key = IndexRecords.value AND Records.objectStoreID = IndexRecords.objectStoreID&quot;)) {
 475         LOG_ERROR(&quot;Could not migrate existing IndexRecords content (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 476         return false;
 477     }
 478 
 479     if (!m_sqliteDB-&gt;executeCommand(&quot;DROP TABLE IndexRecords&quot;)) {
 480         LOG_ERROR(&quot;Could not drop existing IndexRecords table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 481         return false;
 482     }
 483 
 484     if (!m_sqliteDB-&gt;executeCommand(&quot;ALTER TABLE _Temp_IndexRecords RENAME TO IndexRecords&quot;)) {
 485         LOG_ERROR(&quot;Could not rename temporary IndexRecords table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 486         return false;
 487     }
 488 
 489     transaction.commit();
 490 
 491     return true;
 492 }
 493 
 494 bool SQLiteIDBBackingStore::ensureValidIndexRecordsIndex()
 495 {
 496     ASSERT(m_sqliteDB);
 497     ASSERT(m_sqliteDB-&gt;isOpen());
 498 
 499     String currentSchema;
 500     {
 501         // Fetch the schema for an existing index record index.
 502         SQLiteStatement statement(*m_sqliteDB, &quot;SELECT sql FROM sqlite_master WHERE name=&#39;IndexRecordsIndex&#39;&quot;);
 503         if (statement.prepare() != SQLITE_OK) {
 504             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the IndexRecordsIndex index.&quot;);
 505             return false;
 506         }
 507 
 508         int sqliteResult = statement.step();
 509 
 510         // If there is no IndexRecordsIndex index at all, create it and then bail.
 511         if (sqliteResult == SQLITE_DONE) {
 512             if (!m_sqliteDB-&gt;executeCommand(IndexRecordsIndexSchema)) {
 513                 LOG_ERROR(&quot;Could not create IndexRecordsIndex index in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 514                 return false;
 515             }
 516 
 517             return true;
 518         }
 519 
 520         if (sqliteResult != SQLITE_ROW) {
 521             LOG_ERROR(&quot;Error executing statement to fetch schema for the IndexRecordsIndex index.&quot;);
 522             return false;
 523         }
 524 
 525         currentSchema = statement.getColumnText(0);
 526     }
 527 
 528     ASSERT(!currentSchema.isEmpty());
 529 
 530     // If the schema in the backing store is the current schema, we&#39;re done.
 531     if (currentSchema == IndexRecordsIndexSchema)
 532         return true;
 533 
 534     // Otherwise, update the schema.
 535     SQLiteTransaction transaction(*m_sqliteDB);
 536     transaction.begin();
 537 
 538     if (!m_sqliteDB-&gt;executeCommand(&quot;DROP INDEX IndexRecordsIndex&quot;)) {
 539         LOG_ERROR(&quot;Could not drop index IndexRecordsIndex in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 540         return false;
 541     }
 542 
 543     if (!m_sqliteDB-&gt;executeCommand(IndexRecordsIndexSchema)) {
 544         LOG_ERROR(&quot;Could not create IndexRecordsIndex index in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 545         return false;
 546     }
 547 
 548     transaction.commit();
 549 
 550     return true;
 551 }
 552 
 553 bool SQLiteIDBBackingStore::ensureValidIndexRecordsRecordIndex()
 554 {
 555     ASSERT(m_sqliteDB);
 556     ASSERT(m_sqliteDB-&gt;isOpen());
 557 
 558     String currentSchema;
 559     {
 560         SQLiteStatement statement(*m_sqliteDB, &quot;SELECT sql FROM sqlite_master WHERE name=&#39;IndexRecordsRecordIndex&#39;&quot;);
 561         if (statement.prepare() != SQLITE_OK) {
 562             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the IndexRecordsRecordIndex index.&quot;);
 563             return false;
 564         }
 565 
 566         int sqliteResult = statement.step();
 567 
 568         if (sqliteResult == SQLITE_DONE) {
 569             if (!m_sqliteDB-&gt;executeCommand(v1IndexRecordsRecordIndexSchema)) {
 570                 LOG_ERROR(&quot;Could not create IndexRecordsRecordIndex index in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 571                 return false;
 572             }
 573 
 574             return true;
 575         }
 576 
 577         if (sqliteResult != SQLITE_ROW) {
 578             LOG_ERROR(&quot;Error executing statement to fetch schema for the IndexRecordsRecordIndex index.&quot;);
 579             return false;
 580         }
 581 
 582         currentSchema = statement.getColumnText(0);
 583     }
 584 
 585     ASSERT(!currentSchema.isEmpty());
 586 
 587     if (currentSchema == v1IndexRecordsRecordIndexSchema)
 588         return true;
 589 
 590     return false;
 591 }
 592 
 593 std::unique_ptr&lt;IDBDatabaseInfo&gt; SQLiteIDBBackingStore::createAndPopulateInitialDatabaseInfo()
 594 {
 595     ASSERT(m_sqliteDB);
 596     ASSERT(m_sqliteDB-&gt;isOpen());
 597 
 598     if (!m_sqliteDB-&gt;executeCommand(&quot;CREATE TABLE IDBDatabaseInfo (key TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT REPLACE, value TEXT NOT NULL ON CONFLICT FAIL);&quot;)) {
 599         LOG_ERROR(&quot;Could not create IDBDatabaseInfo table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 600         closeSQLiteDB();
 601         return nullptr;
 602     }
 603 
 604     if (!m_sqliteDB-&gt;executeCommand(v2ObjectStoreInfoSchema)) {
 605         LOG_ERROR(&quot;Could not create ObjectStoreInfo table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 606         closeSQLiteDB();
 607         return nullptr;
 608     }
 609 
 610     if (!m_sqliteDB-&gt;executeCommand(&quot;CREATE TABLE IndexInfo (id INTEGER NOT NULL ON CONFLICT FAIL, name TEXT NOT NULL ON CONFLICT FAIL, objectStoreID INTEGER NOT NULL ON CONFLICT FAIL, keyPath BLOB NOT NULL ON CONFLICT FAIL, isUnique INTEGER NOT NULL ON CONFLICT FAIL, multiEntry INTEGER NOT NULL ON CONFLICT FAIL);&quot;)) {
 611         LOG_ERROR(&quot;Could not create IndexInfo table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 612         closeSQLiteDB();
 613         return nullptr;
 614     }
 615 
 616     if (!m_sqliteDB-&gt;executeCommand(&quot;CREATE TABLE KeyGenerators (objectStoreID INTEGER NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT REPLACE, currentKey INTEGER NOT NULL ON CONFLICT FAIL);&quot;)) {
 617         LOG_ERROR(&quot;Could not create KeyGenerators table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 618         closeSQLiteDB();
 619         return nullptr;
 620     }
 621 
 622     {
 623         SQLiteStatement sql(*m_sqliteDB, &quot;INSERT INTO IDBDatabaseInfo VALUES (&#39;MetadataVersion&#39;, ?);&quot;_s);
 624         if (sql.prepare() != SQLITE_OK
 625             || sql.bindInt(1, currentMetadataVersion) != SQLITE_OK
 626             || sql.step() != SQLITE_DONE) {
 627             LOG_ERROR(&quot;Could not insert database metadata version into IDBDatabaseInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 628             closeSQLiteDB();
 629             return nullptr;
 630         }
 631     }
 632     {
 633         SQLiteStatement sql(*m_sqliteDB, &quot;INSERT INTO IDBDatabaseInfo VALUES (&#39;DatabaseName&#39;, ?);&quot;_s);
 634         if (sql.prepare() != SQLITE_OK
 635             || sql.bindText(1, m_identifier.databaseName()) != SQLITE_OK
 636             || sql.step() != SQLITE_DONE) {
 637             LOG_ERROR(&quot;Could not insert database name into IDBDatabaseInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 638             closeSQLiteDB();
 639             return nullptr;
 640         }
 641     }
 642     {
 643         // Database versions are defined to be a uin64_t in the spec but sqlite3 doesn&#39;t support native binding of unsigned integers.
 644         // Therefore we&#39;ll store the version as a String.
 645         SQLiteStatement sql(*m_sqliteDB, &quot;INSERT INTO IDBDatabaseInfo VALUES (&#39;DatabaseVersion&#39;, ?);&quot;_s);
 646         if (sql.prepare() != SQLITE_OK
 647             || sql.bindText(1, String::number(0)) != SQLITE_OK
 648             || sql.step() != SQLITE_DONE) {
 649             LOG_ERROR(&quot;Could not insert default version into IDBDatabaseInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 650             closeSQLiteDB();
 651             return nullptr;
 652         }
 653     }
 654 
 655     if (!m_sqliteDB-&gt;executeCommand(&quot;INSERT INTO IDBDatabaseInfo VALUES (&#39;MaxObjectStoreID&#39;, 1);&quot;_s)) {
 656         LOG_ERROR(&quot;Could not insert default version into IDBDatabaseInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 657         closeSQLiteDB();
 658         return nullptr;
 659     }
 660 
 661     // This initial database info matches the default values we just put into the metadata database.
 662     return makeUnique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), 0, 0);
 663 }
 664 
 665 Optional&lt;IsSchemaUpgraded&gt; SQLiteIDBBackingStore::ensureValidObjectStoreInfoTable()
 666 {
 667     ASSERT(m_sqliteDB);
 668     ASSERT(m_sqliteDB-&gt;isOpen());
 669 
 670     String currentSchema;
 671     {
 672         // Fetch the schema for ObjectStoreInfo table.
 673         SQLiteStatement statement(*m_sqliteDB, &quot;SELECT sql FROM sqlite_master WHERE tbl_name=&#39;ObjectStoreInfo&#39;&quot;);
 674         if (statement.prepare() != SQLITE_OK) {
 675             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the ObjectStoreInfo table.&quot;);
 676             return WTF::nullopt;
 677         }
 678 
 679         int sqliteResult = statement.step();
 680         if (sqliteResult != SQLITE_ROW) {
 681             LOG_ERROR(&quot;Error executing statement to fetch schema for the ObjectStoreInfo table.&quot;);
 682             return WTF::nullopt;
 683         }
 684 
 685         currentSchema = statement.getColumnText(0);
 686     }
 687 
 688     ASSERT(!currentSchema.isEmpty());
 689     if (currentSchema == v2ObjectStoreInfoSchema || currentSchema == createV2ObjectStoreInfoSchema(objectStoreInfoTableNameAlternate))
 690         return { IsSchemaUpgraded::No };
 691 
 692     if (currentSchema != createV1ObjectStoreInfoSchema(objectStoreInfoTableName) &amp;&amp; currentSchema != createV1ObjectStoreInfoSchema(objectStoreInfoTableNameAlternate)) {
 693         RELEASE_LOG_ERROR(IndexedDB, &quot;%p - SQLiteIDBBackingStore::ensureValidObjectStoreInfoTable: schema is invalid - %s&quot;, this, currentSchema.utf8().data());
 694         return WTF::nullopt;
 695     }
 696 
 697     // Drop column maxIndexID from table.
 698     SQLiteTransaction transaction(*m_sqliteDB);
 699     transaction.begin();
 700 
 701     if (!m_sqliteDB-&gt;executeCommand(createV2ObjectStoreInfoSchema(&quot;_Temp_ObjectStoreInfo&quot;_s))) {
 702         LOG_ERROR(&quot;Could not create temporary ObjectStoreInfo table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 703         return WTF::nullopt;
 704     }
 705 
 706     if (!m_sqliteDB-&gt;executeCommand(&quot;INSERT INTO _Temp_ObjectStoreInfo (id, name, keyPath, autoInc) SELECT id, name, keyPath, autoInc FROM ObjectStoreInfo&quot;)) {
 707         LOG_ERROR(&quot;Could not migrate existing ObjectStoreInfo content (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 708         return WTF::nullopt;
 709     }
 710 
 711     if (!m_sqliteDB-&gt;executeCommand(&quot;DROP TABLE ObjectStoreInfo&quot;)) {
 712         LOG_ERROR(&quot;Could not drop existing ObjectStoreInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 713         return WTF::nullopt;
 714     }
 715 
 716     if (!m_sqliteDB-&gt;executeCommand(&quot;ALTER TABLE _Temp_ObjectStoreInfo RENAME TO ObjectStoreInfo&quot;)) {
 717         LOG_ERROR(&quot;Could not rename temporary ObjectStoreInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 718         return WTF::nullopt;
 719     }
 720 
 721     transaction.commit();
 722 
 723     return { IsSchemaUpgraded::Yes };
 724 }
 725 
 726 std::unique_ptr&lt;IDBDatabaseInfo&gt; SQLiteIDBBackingStore::extractExistingDatabaseInfo()
 727 {
 728     ASSERT(m_sqliteDB);
 729 
 730     if (!m_sqliteDB-&gt;tableExists(&quot;IDBDatabaseInfo&quot;_s))
 731         return nullptr;
 732 
 733     String databaseName;
 734     {
 735         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT value FROM IDBDatabaseInfo WHERE key = &#39;DatabaseName&#39;;&quot;);
 736         if (sql.isColumnNull(0))
 737             return nullptr;
 738         databaseName = sql.getColumnText(0);
 739         if (databaseName != m_identifier.databaseName()) {
 740             LOG_ERROR(&quot;Database name in the info database (&#39;%s&#39;) does not match the expected name (&#39;%s&#39;)&quot;, databaseName.utf8().data(), m_identifier.databaseName().utf8().data());
 741             return nullptr;
 742         }
 743     }
 744     uint64_t databaseVersion;
 745     {
 746         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT value FROM IDBDatabaseInfo WHERE key = &#39;DatabaseVersion&#39;;&quot;_s);
 747         if (sql.isColumnNull(0))
 748             return nullptr;
 749         String stringVersion = sql.getColumnText(0);
 750         bool ok;
 751         databaseVersion = stringVersion.toUInt64Strict(&amp;ok);
 752         if (!ok) {
 753             LOG_ERROR(&quot;Database version on disk (&#39;%s&#39;) does not cleanly convert to an unsigned 64-bit integer version&quot;, stringVersion.utf8().data());
 754             return nullptr;
 755         }
 756     }
 757 
 758     auto databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(databaseName, databaseVersion, 0);
 759 
 760     auto result = ensureValidObjectStoreInfoTable();
 761     if (!result)
 762         return nullptr;
 763 
 764     bool shouldUpdateIndexID = (result.value() == IsSchemaUpgraded::Yes);
 765 
 766     {
 767         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT id, name, keyPath, autoInc FROM ObjectStoreInfo;&quot;_s);
 768         if (sql.prepare() != SQLITE_OK)
 769             return nullptr;
 770 
 771         int result = sql.step();
 772         while (result == SQLITE_ROW) {
 773             uint64_t objectStoreID = sql.getColumnInt64(0);
 774             String objectStoreName = sql.getColumnText(1);
 775 
 776             Vector&lt;char&gt; keyPathBuffer;
 777             sql.getColumnBlobAsVector(2, keyPathBuffer);
 778 
 779             Optional&lt;IDBKeyPath&gt; objectStoreKeyPath;
 780             if (!deserializeIDBKeyPath(reinterpret_cast&lt;const uint8_t*&gt;(keyPathBuffer.data()), keyPathBuffer.size(), objectStoreKeyPath)) {
 781                 LOG_ERROR(&quot;Unable to extract key path from database&quot;);
 782                 return nullptr;
 783             }
 784 
 785             bool autoIncrement = sql.getColumnInt(3);
 786 
 787             databaseInfo-&gt;addExistingObjectStore({ objectStoreID, objectStoreName, WTFMove(objectStoreKeyPath), autoIncrement });
 788 
 789             result = sql.step();
 790         }
 791 
 792         if (result != SQLITE_DONE) {
 793             LOG_ERROR(&quot;Error fetching object store info from database on disk&quot;);
 794             return nullptr;
 795         }
 796     }
 797 
 798     uint64_t maxIndexID = 0;
 799     HashMap&lt;std::pair&lt;uint64_t, uint64_t&gt;, uint64_t&gt; indexIDMap;
 800     {
 801         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT id, name, objectStoreID, keyPath, isUnique, multiEntry FROM IndexInfo;&quot;_s);
 802         if (sql.prepare() != SQLITE_OK) {
 803             LOG_ERROR(&quot;Unable to prepare statement to fetch records from the IndexInfo table.&quot;);
 804             return nullptr;
 805         }
 806 
 807         int result = sql.step();
 808         while (result == SQLITE_ROW) {
 809             uint64_t indexID = sql.getColumnInt64(0);
 810             String indexName = sql.getColumnText(1);
 811             uint64_t objectStoreID = sql.getColumnInt64(2);
 812 
 813             Vector&lt;char&gt; keyPathBuffer;
 814             sql.getColumnBlobAsVector(3, keyPathBuffer);
 815 
 816             Optional&lt;IDBKeyPath&gt; indexKeyPath;
 817             if (!deserializeIDBKeyPath(reinterpret_cast&lt;const uint8_t*&gt;(keyPathBuffer.data()), keyPathBuffer.size(), indexKeyPath)) {
 818                 LOG_ERROR(&quot;Unable to extract key path from database&quot;);
 819                 return nullptr;
 820             }
 821             if (!indexKeyPath) {
 822                 LOG_ERROR(&quot;Unable to extract key path from database&quot;);
 823                 return nullptr;
 824             }
 825 
 826             bool unique = sql.getColumnInt(4);
 827             bool multiEntry = sql.getColumnInt(5);
 828 
 829             auto objectStore = databaseInfo-&gt;infoForExistingObjectStore(objectStoreID);
 830             if (!objectStore) {
 831                 LOG_ERROR(&quot;Found index referring to a non-existant object store&quot;);
 832                 return nullptr;
 833             }
 834 
 835             if (shouldUpdateIndexID) {
 836                 indexIDMap.set({ objectStoreID, indexID }, ++maxIndexID);
 837                 indexID = maxIndexID;
 838             }
 839 
 840             objectStore-&gt;addExistingIndex({ indexID, objectStoreID, indexName, WTFMove(indexKeyPath.value()), unique, multiEntry });
 841             maxIndexID = maxIndexID &lt; indexID ? indexID : maxIndexID;
 842 
 843             result = sql.step();
 844         }
 845 
 846         if (result != SQLITE_DONE) {
 847             LOG_ERROR(&quot;Error fetching index info from database on disk&quot;);
 848             return nullptr;
 849         }
 850         databaseInfo-&gt;setMaxIndexID(maxIndexID);
 851 
 852         if (!shouldUpdateIndexID)
 853             return databaseInfo;
 854 
 855         for (auto&amp; entry : indexIDMap) {
 856             SQLiteStatement sql(*m_sqliteDB, &quot;UPDATE IndexInfo SET id = ? WHERE id = ? AND objectStoreID = ?;&quot;_s);
 857             if (sql.prepare() != SQLITE_OK
 858                 || sql.bindInt64(1, entry.value) != SQLITE_OK
 859                 || sql.bindInt64(2, entry.key.second) != SQLITE_OK
 860                 || sql.bindInt64(3, entry.key.first) != SQLITE_OK
 861                 || sql.step() != SQLITE_DONE) {
 862                 LOG_ERROR(&quot;Unable to update id of IndexInfo table&quot;);
 863                 return nullptr;
 864             }
 865 
 866             SQLiteStatement recordSql(*m_sqliteDB, &quot;UPDATE IndexRecords SET indexID = ? WHERE indexID = ? AND objectStoreID = ?;&quot;_s);
 867             if (recordSql.prepare() != SQLITE_OK
 868                 || recordSql.bindInt64(1, entry.value) != SQLITE_OK
 869                 || recordSql.bindInt64(2, entry.key.second) != SQLITE_OK
 870                 || recordSql.bindInt64(3, entry.key.first) != SQLITE_OK
 871                 || recordSql.step() != SQLITE_DONE) {
 872                 LOG_ERROR(&quot;Unable to update indexID of IndexRecords table&quot;);
 873                 return nullptr;
 874             }
 875         }
 876     }
 877 
 878     return databaseInfo;
 879 }
 880 
 881 String SQLiteIDBBackingStore::databaseNameFromEncodedFilename(const String&amp; encodedName)
 882 {
 883     if (encodedName == &quot;%00&quot;_s)
 884         return { };
 885 
 886     String partiallyDecoded = encodedName;
 887     partiallyDecoded.replace(&quot;%2E&quot;_s, &quot;.&quot;_s);
 888 
 889     return FileSystem::decodeFromFilename(partiallyDecoded);
 890 }
 891 
 892 String SQLiteIDBBackingStore::filenameForDatabaseName() const
 893 {
 894     ASSERT(!m_identifier.databaseName().isNull());
 895 
 896     if (m_identifier.databaseName().isEmpty())
 897         return &quot;%00&quot;;
 898 
 899     String filename = FileSystem::encodeForFileName(m_identifier.databaseName());
 900     filename.replace(&#39;.&#39;, &quot;%2E&quot;);
 901 
 902     return filename;
 903 }
 904 
 905 String SQLiteIDBBackingStore::fullDatabasePathForDirectory(const String&amp; fullDatabaseDirectory)
 906 {
 907     return FileSystem::pathByAppendingComponent(fullDatabaseDirectory, &quot;IndexedDB.sqlite3&quot;);
 908 }
 909 
 910 String SQLiteIDBBackingStore::fullDatabasePath() const
 911 {
 912     return fullDatabasePathForDirectory(m_databaseDirectory);
 913 }
 914 
 915 String SQLiteIDBBackingStore::databaseNameFromFile(const String&amp; databasePath)
 916 {
 917     SQLiteDatabase database;
 918     if (!database.open(databasePath)) {
 919         LOG_ERROR(&quot;Failed to open SQLite database at path &#39;%s&#39; when getting database name&quot;, databasePath.utf8().data());
 920         return { };
 921     }
 922     if (!database.tableExists(&quot;IDBDatabaseInfo&quot;_s)) {
 923         LOG_ERROR(&quot;Could not find IDBDatabaseInfo table and get database name(%i) - %s&quot;, database.lastError(), database.lastErrorMsg());
 924         database.close();
 925         return { };
 926     }
 927     SQLiteStatement sql(database, &quot;SELECT value FROM IDBDatabaseInfo WHERE key = &#39;DatabaseName&#39;;&quot;);
 928     auto databaseName = sql.getColumnText(0);
 929     database.close();
 930     return databaseName;
 931 }
 932 
 933 String SQLiteIDBBackingStore::fullDatabaseDirectoryWithUpgrade()
 934 {
 935     auto databaseRootDirectory = this-&gt;databaseRootDirectoryIsolatedCopy();
 936     String oldOriginDirectory = m_identifier.databaseDirectoryRelativeToRoot(databaseRootDirectory, &quot;v0&quot;);
 937     String oldDatabaseDirectory = FileSystem::pathByAppendingComponent(oldOriginDirectory, filenameForDatabaseName());
 938     String newOriginDirectory = m_identifier.databaseDirectoryRelativeToRoot(databaseRootDirectory, &quot;v1&quot;);
 939     String fileNameHash = SQLiteFileSystem::computeHashForFileName(m_identifier.databaseName());
 940     Vector&lt;String&gt; directoriesWithSameHash = FileSystem::listDirectory(newOriginDirectory, fileNameHash + &quot;*&quot;);
 941     String newDatabaseDirectory = FileSystem::pathByAppendingComponent(newOriginDirectory, fileNameHash);
 942     FileSystem::makeAllDirectories(newDatabaseDirectory);
 943 
 944     if (FileSystem::fileExists(oldDatabaseDirectory)) {
 945         FileSystem::moveFile(oldDatabaseDirectory, newDatabaseDirectory);
 946         FileSystem::deleteEmptyDirectory(oldOriginDirectory);
 947     }
 948 
 949     return newDatabaseDirectory;
 950 }
 951 
 952 IDBError SQLiteIDBBackingStore::getOrEstablishDatabaseInfo(IDBDatabaseInfo&amp; info)
 953 {
 954     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getOrEstablishDatabaseInfo - database %s&quot;, m_identifier.databaseName().utf8().data());
 955 
 956     if (m_databaseInfo) {
 957         info = *m_databaseInfo;
 958         return IDBError { };
 959     }
 960 
 961     String dbFilename = fullDatabasePath();
 962 
 963     m_sqliteDB = makeUnique&lt;SQLiteDatabase&gt;();
 964     if (!m_sqliteDB-&gt;open(dbFilename)) {
 965         LOG_ERROR(&quot;Failed to open SQLite database at path &#39;%s&#39;&quot;, dbFilename.utf8().data());
 966         closeSQLiteDB();
 967     }
 968 
 969     if (!m_sqliteDB)
 970         return IDBError { UnknownError, &quot;Unable to open database file on disk&quot;_s };
 971 
 972     m_sqliteDB-&gt;setCollationFunction(&quot;IDBKEY&quot;, [](int aLength, const void* a, int bLength, const void* b) {
 973         return idbKeyCollate(aLength, a, bLength, b);
 974     });
 975 
 976     if (!ensureValidRecordsTable()) {
 977         LOG_ERROR(&quot;Error creating or migrating Records table in database&quot;);
 978         closeSQLiteDB();
 979         return IDBError { UnknownError, &quot;Error creating or migrating Records table in database&quot;_s };
 980     }
 981 
 982     if (!ensureValidIndexRecordsTable()) {
 983         LOG_ERROR(&quot;Error creating or migrating Index Records table in database&quot;);
 984         closeSQLiteDB();
 985         return IDBError { UnknownError, &quot;Error creating or migrating Index Records table in database&quot;_s };
 986     }
 987 
 988     if (!ensureValidIndexRecordsIndex()) {
 989         LOG_ERROR(&quot;Error creating or migrating Index Records index in database&quot;);
 990         closeSQLiteDB();
 991         return IDBError { UnknownError, &quot;Error creating or migrating Index Records index in database&quot;_s };
 992     }
 993 
 994     if (!ensureValidIndexRecordsRecordIndex()) {
 995         LOG_ERROR(&quot;Error creating or migrating Index Records second index for in database&quot;);
 996         closeSQLiteDB();
 997         return IDBError { UnknownError, &quot;Error creating or migrating Index Records second index in database&quot;_s };
 998     }
 999 
1000     if (!ensureValidBlobTables()) {
1001         LOG_ERROR(&quot;Error creating or confirming Blob Records tables in database&quot;);
1002         closeSQLiteDB();
1003         return IDBError { UnknownError, &quot;Error creating or confirming Blob Records tables in database&quot;_s };
1004     }
1005 
1006     auto databaseInfo = extractExistingDatabaseInfo();
1007     if (!databaseInfo)
1008         databaseInfo = createAndPopulateInitialDatabaseInfo();
1009 
1010     if (!databaseInfo) {
1011         LOG_ERROR(&quot;Unable to establish IDB database at path &#39;%s&#39;&quot;, dbFilename.utf8().data());
1012         closeSQLiteDB();
1013         return IDBError { UnknownError, &quot;Unable to establish IDB database file&quot;_s };
1014     }
1015 
1016     m_databaseInfo = WTFMove(databaseInfo);
1017     info = *m_databaseInfo;
1018     return IDBError { };
1019 }
1020 
1021 uint64_t SQLiteIDBBackingStore::databasesSizeForDirectory(const String&amp; directory)
1022 {
1023     uint64_t diskUsage = 0;
1024     for (auto&amp; dbDirectory : FileSystem::listDirectory(directory, &quot;*&quot;)) {
1025         for (auto&amp; file : FileSystem::listDirectory(dbDirectory, &quot;*.sqlite3&quot;_s))
1026             diskUsage += SQLiteFileSystem::getDatabaseFileSize(file);
1027     }
1028     return diskUsage;
1029 }
1030 
1031 IDBError SQLiteIDBBackingStore::beginTransaction(const IDBTransactionInfo&amp; info)
1032 {
1033     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::beginTransaction - %s&quot;, info.identifier().loggingString().utf8().data());
1034 
1035     ASSERT(m_sqliteDB);
1036     ASSERT(m_sqliteDB-&gt;isOpen());
1037     ASSERT(m_databaseInfo);
1038 
1039     auto addResult = m_transactions.add(info.identifier(), nullptr);
1040     if (!addResult.isNewEntry) {
1041         LOG_ERROR(&quot;Attempt to establish transaction identifier that already exists&quot;);
1042         return IDBError { UnknownError, &quot;Attempt to establish transaction identifier that already exists&quot;_s };
1043     }
1044 
1045     addResult.iterator-&gt;value = makeUnique&lt;SQLiteIDBTransaction&gt;(*this, info);
1046 
1047     auto error = addResult.iterator-&gt;value-&gt;begin(*m_sqliteDB);
1048     if (error.isNull() &amp;&amp; info.mode() == IDBTransactionMode::Versionchange) {
1049         m_originalDatabaseInfoBeforeVersionChange = makeUnique&lt;IDBDatabaseInfo&gt;(*m_databaseInfo);
1050 
1051         SQLiteStatement sql(*m_sqliteDB, &quot;UPDATE IDBDatabaseInfo SET value = ? where key = &#39;DatabaseVersion&#39;;&quot;_s);
1052         if (sql.prepare() != SQLITE_OK
1053             || sql.bindText(1, String::number(info.newVersion())) != SQLITE_OK
1054             || sql.step() != SQLITE_DONE) {
1055             error = IDBError { UnknownError, &quot;Failed to store new database version in database&quot;_s };
1056         }
1057     }
1058 
1059     return error;
1060 }
1061 
1062 IDBError SQLiteIDBBackingStore::abortTransaction(const IDBResourceIdentifier&amp; identifier)
1063 {
1064     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::abortTransaction - %s&quot;, identifier.loggingString().utf8().data());
1065 
1066     ASSERT(m_sqliteDB);
1067     ASSERT(m_sqliteDB-&gt;isOpen());
1068 
1069     auto transaction = m_transactions.take(identifier);
1070     if (!transaction) {
1071         LOG_ERROR(&quot;Attempt to commit a transaction that hasn&#39;t been established&quot;);
1072         return IDBError { UnknownError, &quot;Attempt to abort a transaction that hasn&#39;t been established&quot;_s };
1073     }
1074 
1075     if (transaction-&gt;mode() == IDBTransactionMode::Versionchange &amp;&amp; m_originalDatabaseInfoBeforeVersionChange)
1076         m_databaseInfo = WTFMove(m_originalDatabaseInfoBeforeVersionChange);
1077 
1078     return transaction-&gt;abort();
1079 }
1080 
1081 IDBError SQLiteIDBBackingStore::commitTransaction(const IDBResourceIdentifier&amp; identifier)
1082 {
1083     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::commitTransaction - %s&quot;, identifier.loggingString().utf8().data());
1084 
1085     ASSERT(m_sqliteDB);
1086     ASSERT(m_sqliteDB-&gt;isOpen());
1087 
1088     auto transaction = m_transactions.take(identifier);
1089     if (!transaction) {
1090         LOG_ERROR(&quot;Attempt to commit a transaction that hasn&#39;t been established&quot;);
1091         return IDBError { UnknownError, &quot;Attempt to commit a transaction that hasn&#39;t been established&quot;_s };
1092     }
1093 
1094     auto error = transaction-&gt;commit();
1095     if (!error.isNull()) {
1096         if (transaction-&gt;mode() == IDBTransactionMode::Versionchange) {
1097             ASSERT(m_originalDatabaseInfoBeforeVersionChange);
1098             m_databaseInfo = WTFMove(m_originalDatabaseInfoBeforeVersionChange);
1099         }
1100     } else
1101         m_originalDatabaseInfoBeforeVersionChange = nullptr;
1102 
1103     return error;
1104 }
1105 
1106 IDBError SQLiteIDBBackingStore::createObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBObjectStoreInfo&amp; info)
1107 {
1108     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::createObjectStore - adding OS %s with ID %&quot; PRIu64, info.name().utf8().data(), info.identifier());
1109 
1110     ASSERT(m_sqliteDB);
1111     ASSERT(m_sqliteDB-&gt;isOpen());
1112 
1113     auto* transaction = m_transactions.get(transactionIdentifier);
1114     if (!transaction || !transaction-&gt;inProgress())
1115         return IDBError { UnknownError, &quot;Attempt to create an object store without an in-progress transaction&quot;_s };
1116 
1117     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1118         LOG_ERROR(&quot;Attempt to create an object store in a non-version-change transaction&quot;);
1119         return IDBError { UnknownError, &quot;Attempt to create an object store in a non-version-change transaction&quot;_s };
1120     }
1121 
1122     RefPtr&lt;SharedBuffer&gt; keyPathBlob = serializeIDBKeyPath(info.keyPath());
1123     if (!keyPathBlob) {
1124         LOG_ERROR(&quot;Unable to serialize IDBKeyPath to save in database for new object store&quot;);
1125         return IDBError { UnknownError, &quot;Unable to serialize IDBKeyPath to save in database for new object store&quot;_s };
1126     }
1127 
1128     {
1129         auto* sql = cachedStatement(SQL::CreateObjectStoreInfo, &quot;INSERT INTO ObjectStoreInfo VALUES (?, ?, ?, ?);&quot;_s);
1130         if (!sql
1131             || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
1132             || sql-&gt;bindText(2, info.name()) != SQLITE_OK
1133             || sql-&gt;bindBlob(3, keyPathBlob-&gt;data(), keyPathBlob-&gt;size()) != SQLITE_OK
1134             || sql-&gt;bindInt(4, info.autoIncrement()) != SQLITE_OK
1135             || sql-&gt;step() != SQLITE_DONE) {
1136             LOG_ERROR(&quot;Could not add object store &#39;%s&#39; to ObjectStoreInfo table (%i) - %s&quot;, info.name().utf8().data(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1137             return IDBError { UnknownError, &quot;Could not create object store&quot;_s };
1138         }
1139     }
1140 
1141     {
1142         auto* sql = cachedStatement(SQL::CreateObjectStoreKeyGenerator, &quot;INSERT INTO KeyGenerators VALUES (?, 0);&quot;_s);
1143         if (!sql
1144             || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
1145             || sql-&gt;step() != SQLITE_DONE) {
1146             LOG_ERROR(&quot;Could not seed initial key generator value for ObjectStoreInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1147             return IDBError { UnknownError, &quot;Could not seed initial key generator value for object store&quot;_s };
1148         }
1149     }
1150 
1151     m_databaseInfo-&gt;addExistingObjectStore(info);
1152 
1153     return IDBError { };
1154 }
1155 
1156 IDBError SQLiteIDBBackingStore::deleteObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier)
1157 {
1158     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteObjectStore - object store %&quot; PRIu64, objectStoreIdentifier);
1159 
1160     ASSERT(m_sqliteDB);
1161     ASSERT(m_sqliteDB-&gt;isOpen());
1162 
1163     auto* transaction = m_transactions.get(transactionIdentifier);
1164     if (!transaction || !transaction-&gt;inProgress())
1165         return IDBError { UnknownError, &quot;Attempt to delete an object store without an in-progress transaction&quot;_s };
1166 
1167     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1168         LOG_ERROR(&quot;Attempt to delete an object store in a non-version-change transaction&quot;);
1169         return IDBError { UnknownError, &quot;Attempt to delete an object store in a non-version-change transaction&quot;_s };
1170     }
1171 
1172     // Delete the ObjectStore record
1173     {
1174         auto* sql = cachedStatement(SQL::DeleteObjectStoreInfo, &quot;DELETE FROM ObjectStoreInfo WHERE id = ?;&quot;_s);
1175         if (!sql
1176             || sql-&gt;bindInt64(1, objectStoreIdentifier) != SQLITE_OK
1177             || sql-&gt;step() != SQLITE_DONE) {
1178             LOG_ERROR(&quot;Could not delete object store id %&quot; PRIi64 &quot; from ObjectStoreInfo table (%i) - %s&quot;, objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1179             return IDBError { UnknownError, &quot;Could not delete object store&quot;_s };
1180         }
1181     }
1182 
1183     // Delete the ObjectStore&#39;s key generator record if there is one.
1184     {
1185         auto* sql = cachedStatement(SQL::DeleteObjectStoreKeyGenerator, &quot;DELETE FROM KeyGenerators WHERE objectStoreID = ?;&quot;_s);
1186         if (!sql
1187             || sql-&gt;bindInt64(1, objectStoreIdentifier) != SQLITE_OK
1188             || sql-&gt;step() != SQLITE_DONE) {
1189             LOG_ERROR(&quot;Could not delete object store from KeyGenerators table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1190             return IDBError { UnknownError, &quot;Could not delete key generator for deleted object store&quot;_s };
1191         }
1192     }
1193 
1194     // Delete all associated records
1195     {
1196         auto* sql = cachedStatement(SQL::DeleteObjectStoreRecords, &quot;DELETE FROM Records WHERE objectStoreID = ?;&quot;_s);
1197         if (!sql
1198             || sql-&gt;bindInt64(1, objectStoreIdentifier) != SQLITE_OK
1199             || sql-&gt;step() != SQLITE_DONE) {
1200             LOG_ERROR(&quot;Could not delete records for object store %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1201             return IDBError { UnknownError, &quot;Could not delete records for deleted object store&quot;_s };
1202         }
1203     }
1204 
1205     // Delete all associated Indexes
1206     {
1207         auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexInfo, &quot;DELETE FROM IndexInfo WHERE objectStoreID = ?;&quot;_s);
1208         if (!sql
1209             || sql-&gt;bindInt64(1, objectStoreIdentifier) != SQLITE_OK
1210             || sql-&gt;step() != SQLITE_DONE) {
1211             LOG_ERROR(&quot;Could not delete index from IndexInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1212             return IDBError { UnknownError, &quot;Could not delete IDBIndex for deleted object store&quot;_s };
1213         }
1214     }
1215 
1216     // Delete all associated Index records
1217     {
1218         auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexRecords, &quot;DELETE FROM IndexRecords WHERE objectStoreID = ?;&quot;_s);
1219         if (!sql
1220             || sql-&gt;bindInt64(1, objectStoreIdentifier) != SQLITE_OK
1221             || sql-&gt;step() != SQLITE_DONE) {
1222             LOG_ERROR(&quot;Could not delete index records(%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1223             return IDBError { UnknownError, &quot;Could not delete IDBIndex records for deleted object store&quot;_s };
1224         }
1225     }
1226 
1227     // Delete all unused Blob URL records.
1228     {
1229         auto* sql = cachedStatement(SQL::DeleteObjectStoreBlobRecords, &quot;DELETE FROM BlobRecords WHERE objectStoreRow NOT IN (SELECT recordID FROM Records)&quot;_s);
1230         if (!sql
1231             || sql-&gt;step() != SQLITE_DONE) {
1232             LOG_ERROR(&quot;Could not delete Blob URL records(%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1233             return IDBError { UnknownError, &quot;Could not delete stored blob records for deleted object store&quot;_s };
1234         }
1235     }
1236 
1237     // Delete all unused Blob File records.
1238     auto error = deleteUnusedBlobFileRecords(*transaction);
1239     if (!error.isNull())
1240         return error;
1241 
1242     m_databaseInfo-&gt;deleteObjectStore(objectStoreIdentifier);
1243 
1244     return IDBError { };
1245 }
1246 
1247 IDBError SQLiteIDBBackingStore::renameObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const String&amp; newName)
1248 {
1249     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::renameObjectStore - object store %&quot; PRIu64, objectStoreIdentifier);
1250 
1251     ASSERT(m_sqliteDB);
1252     ASSERT(m_sqliteDB-&gt;isOpen());
1253 
1254     auto* transaction = m_transactions.get(transactionIdentifier);
1255     if (!transaction || !transaction-&gt;inProgress())
1256         return IDBError { UnknownError, &quot;Attempt to rename an object store without an in-progress transaction&quot;_s };
1257 
1258     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1259         LOG_ERROR(&quot;Attempt to rename an object store in a non-version-change transaction&quot;);
1260         return IDBError { UnknownError, &quot;Attempt to rename an object store in a non-version-change transaction&quot;_s };
1261     }
1262 
1263     {
1264         auto* sql = cachedStatement(SQL::RenameObjectStore, &quot;UPDATE ObjectStoreInfo SET name = ? WHERE id = ?;&quot;_s);
1265         if (!sql
1266             || sql-&gt;bindText(1, newName) != SQLITE_OK
1267             || sql-&gt;bindInt64(2, objectStoreIdentifier) != SQLITE_OK
1268             || sql-&gt;step() != SQLITE_DONE) {
1269             LOG_ERROR(&quot;Could not update name for object store id %&quot; PRIi64 &quot; in ObjectStoreInfo table (%i) - %s&quot;, objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1270             return IDBError { UnknownError, &quot;Could not rename object store&quot;_s };
1271         }
1272     }
1273 
1274     m_databaseInfo-&gt;renameObjectStore(objectStoreIdentifier, newName);
1275 
1276     return IDBError { };
1277 }
1278 
1279 IDBError SQLiteIDBBackingStore::clearObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID)
1280 {
1281     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::clearObjectStore - object store %&quot; PRIu64, objectStoreID);
1282 
1283     ASSERT(m_sqliteDB);
1284     ASSERT(m_sqliteDB-&gt;isOpen());
1285 
1286     auto* transaction = m_transactions.get(transactionIdentifier);
1287     if (!transaction || !transaction-&gt;inProgress())
1288         return IDBError { UnknownError, &quot;Attempt to clear an object store without an in-progress transaction&quot;_s };
1289 
1290     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
1291         LOG_ERROR(&quot;Attempt to clear an object store in a read-only transaction&quot;);
1292         return IDBError { UnknownError, &quot;Attempt to clear an object store in a read-only transaction&quot;_s };
1293     }
1294 
1295     {
1296         auto* sql = cachedStatement(SQL::ClearObjectStoreRecords, &quot;DELETE FROM Records WHERE objectStoreID = ?;&quot;_s);
1297         if (!sql
1298             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1299             || sql-&gt;step() != SQLITE_DONE) {
1300             LOG_ERROR(&quot;Could not clear records from object store id %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1301             return IDBError { UnknownError, &quot;Unable to clear object store&quot;_s };
1302         }
1303     }
1304 
1305     {
1306         auto* sql = cachedStatement(SQL::ClearObjectStoreIndexRecords, &quot;DELETE FROM IndexRecords WHERE objectStoreID = ?;&quot;_s);
1307         if (!sql
1308             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1309             || sql-&gt;step() != SQLITE_DONE) {
1310             LOG_ERROR(&quot;Could not delete records from index record store id %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1311             return IDBError { UnknownError, &quot;Unable to delete index records while clearing object store&quot;_s };
1312         }
1313     }
1314 
1315     transaction-&gt;notifyCursorsOfChanges(objectStoreID);
1316 
1317     return IDBError { };
1318 }
1319 
1320 IDBError SQLiteIDBBackingStore::createIndex(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBIndexInfo&amp; info)
1321 {
1322     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::createIndex - ObjectStore %&quot; PRIu64 &quot;, Index %&quot; PRIu64, info.objectStoreIdentifier(), info.identifier());
1323     ASSERT(m_sqliteDB);
1324     ASSERT(m_sqliteDB-&gt;isOpen());
1325 
1326     auto* transaction = m_transactions.get(transactionIdentifier);
1327     if (!transaction || !transaction-&gt;inProgress())
1328         return IDBError { UnknownError, &quot;Attempt to create an index without an in-progress transaction&quot;_s };
1329 
1330     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1331         LOG_ERROR(&quot;Attempt to create an index in a non-version-change transaction&quot;);
1332         return IDBError { UnknownError, &quot;Attempt to create an index in a non-version-change transaction&quot;_s };
1333     }
1334 
1335     RefPtr&lt;SharedBuffer&gt; keyPathBlob = serializeIDBKeyPath(info.keyPath());
1336     if (!keyPathBlob) {
1337         LOG_ERROR(&quot;Unable to serialize IDBKeyPath to save in database&quot;);
1338         return IDBError { UnknownError, &quot;Unable to serialize IDBKeyPath to create index in database&quot;_s };
1339     }
1340 
1341     auto* sql = cachedStatement(SQL::CreateIndexInfo, &quot;INSERT INTO IndexInfo VALUES (?, ?, ?, ?, ?, ?);&quot;_s);
1342     if (!sql
1343         || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
1344         || sql-&gt;bindText(2, info.name()) != SQLITE_OK
1345         || sql-&gt;bindInt64(3, info.objectStoreIdentifier()) != SQLITE_OK
1346         || sql-&gt;bindBlob(4, keyPathBlob-&gt;data(), keyPathBlob-&gt;size()) != SQLITE_OK
1347         || sql-&gt;bindInt(5, info.unique()) != SQLITE_OK
1348         || sql-&gt;bindInt(6, info.multiEntry()) != SQLITE_OK
1349         || sql-&gt;step() != SQLITE_DONE) {
1350         LOG_ERROR(&quot;Could not add index &#39;%s&#39; to IndexInfo table (%i) - %s&quot;, info.name().utf8().data(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1351         return IDBError { UnknownError, &quot;Unable to create index in database&quot;_s };
1352     }
1353 
1354     // Write index records for any records that already exist in this object store.
1355 
1356     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(info.objectStoreIdentifier(), 0, IDBKeyRangeData::allKeys());
1357 
1358     if (!cursor) {
1359         LOG_ERROR(&quot;Cannot open cursor to populate indexes in database&quot;);
1360         return IDBError { UnknownError, &quot;Unable to populate indexes in database&quot;_s };
1361     }
1362 
1363     while (!cursor-&gt;currentKey().isNull()) {
1364         auto&amp; key = cursor-&gt;currentKey();
1365         auto value = cursor-&gt;currentValue();
1366         ThreadSafeDataBuffer valueBuffer = value.data();
1367 
1368         ASSERT(cursor-&gt;currentRecordRowID());
1369 
1370         IDBError error = updateOneIndexForAddRecord(info, key, valueBuffer, cursor-&gt;currentRecordRowID());
1371         if (!error.isNull()) {
1372             auto* sql = cachedStatement(SQL::DeleteIndexInfo, &quot;DELETE FROM IndexInfo WHERE id = ? AND objectStoreID = ?;&quot;_s);
1373             if (!sql
1374                 || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
1375                 || sql-&gt;bindInt64(2, info.objectStoreIdentifier()) != SQLITE_OK
1376                 || sql-&gt;step() != SQLITE_DONE) {
1377                 LOG_ERROR(&quot;Index creation failed due to uniqueness constraint failure, but there was an error deleting the Index record from the database&quot;);
1378                 return IDBError { UnknownError, &quot;Index creation failed due to uniqueness constraint failure, but there was an error deleting the Index record from the database&quot;_s };
1379             }
1380 
1381             return error;
1382         }
1383 
1384         if (!cursor-&gt;advance(1)) {
1385             LOG_ERROR(&quot;Error advancing cursor while indexing existing records for new index.&quot;);
1386             return IDBError { UnknownError, &quot;Error advancing cursor while indexing existing records for new index&quot;_s };
1387         }
1388     }
1389 
1390     ASSERT(m_databaseInfo);
1391     if (!m_databaseInfo) {
1392         RELEASE_LOG_ERROR(IndexedDB, &quot;%p - SQLiteIDBBackingStore::clearObjectStore: m_databaseInfo is null&quot;, this);
1393         return IDBError { UnknownError, &quot;Database info is invalid&quot;_s };
1394     }
1395 
1396     auto* objectStore = m_databaseInfo-&gt;infoForExistingObjectStore(info.objectStoreIdentifier());
1397     ASSERT(objectStore);
1398     objectStore-&gt;addExistingIndex(info);
1399     m_databaseInfo-&gt;setMaxIndexID(info.identifier());
1400 
1401     return IDBError { };
1402 }
1403 
1404 IDBError SQLiteIDBBackingStore::uncheckedHasIndexRecord(const IDBIndexInfo&amp; info, const IDBKeyData&amp; indexKey, bool&amp; hasRecord)
1405 {
1406     hasRecord = false;
1407 
1408     RefPtr&lt;SharedBuffer&gt; indexKeyBuffer = serializeIDBKeyData(indexKey);
1409     if (!indexKeyBuffer) {
1410         LOG_ERROR(&quot;Unable to serialize index key to be stored in the database&quot;);
1411         return IDBError { UnknownError, &quot;Unable to serialize IDBKey to check for index record in database&quot;_s };
1412     }
1413 
1414     auto* sql = cachedStatement(SQL::HasIndexRecord, &quot;SELECT rowid FROM IndexRecords WHERE indexID = ? AND key = CAST(? AS TEXT);&quot;_s);
1415     if (!sql
1416         || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
1417         || sql-&gt;bindBlob(2, indexKeyBuffer-&gt;data(), indexKeyBuffer-&gt;size()) != SQLITE_OK) {
1418         LOG_ERROR(&quot;Error checking for index record in database&quot;);
1419         return IDBError { UnknownError, &quot;Error checking for index record in database&quot;_s };
1420     }
1421 
1422     int sqlResult = sql-&gt;step();
1423     if (sqlResult == SQLITE_OK || sqlResult == SQLITE_DONE)
1424         return IDBError { };
1425 
1426     if (sqlResult != SQLITE_ROW) {
1427         // There was an error fetching the record from the database.
1428         LOG_ERROR(&quot;Could not check if key exists in index (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1429         return IDBError { UnknownError, &quot;Error checking for existence of IDBKey in index&quot;_s };
1430     }
1431 
1432     hasRecord = true;
1433     return IDBError { };
1434 }
1435 
1436 IDBError SQLiteIDBBackingStore::uncheckedPutIndexKey(const IDBIndexInfo&amp; info, const IDBKeyData&amp; key, const IndexKey&amp; indexKey, int64_t recordID)
1437 {
1438     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::uncheckedPutIndexKey - (%&quot; PRIu64 &quot;) %s, %s&quot;, info.identifier(), key.loggingString().utf8().data(), indexKey.asOneKey().loggingString().utf8().data());
1439 
1440     Vector&lt;IDBKeyData&gt; indexKeys;
1441     if (info.multiEntry())
1442         indexKeys = indexKey.multiEntry();
1443     else
1444         indexKeys.append(indexKey.asOneKey());
1445 
1446     if (info.unique()) {
1447         bool hasRecord;
1448         IDBError error;
1449         for (auto&amp; indexKey : indexKeys) {
1450             if (!indexKey.isValid())
1451                 continue;
1452             error = uncheckedHasIndexRecord(info, indexKey, hasRecord);
1453             if (!error.isNull())
1454                 return error;
1455             if (hasRecord)
1456                 return IDBError(ConstraintError);
1457         }
1458     }
1459 
1460     for (auto&amp; indexKey : indexKeys) {
1461         if (!indexKey.isValid())
1462             continue;
1463         auto error = uncheckedPutIndexRecord(info.objectStoreIdentifier(), info.identifier(), key, indexKey, recordID);
1464         if (!error.isNull()) {
1465             LOG_ERROR(&quot;Unable to put index record for newly created index&quot;);
1466             return error;
1467         }
1468     }
1469 
1470     return IDBError { };
1471 }
1472 
1473 IDBError SQLiteIDBBackingStore::uncheckedPutIndexRecord(int64_t objectStoreID, int64_t indexID, const WebCore::IDBKeyData&amp; keyValue, const WebCore::IDBKeyData&amp; indexKey, int64_t recordID)
1474 {
1475     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::uncheckedPutIndexRecord - %s, %s&quot;, keyValue.loggingString().utf8().data(), indexKey.loggingString().utf8().data());
1476 
1477     RefPtr&lt;SharedBuffer&gt; indexKeyBuffer = serializeIDBKeyData(indexKey);
1478     if (!indexKeyBuffer) {
1479         LOG_ERROR(&quot;Unable to serialize index key to be stored in the database&quot;);
1480         return IDBError { UnknownError, &quot;Unable to serialize index key to be stored in the database&quot;_s };
1481     }
1482 
1483     RefPtr&lt;SharedBuffer&gt; valueBuffer = serializeIDBKeyData(keyValue);
1484     if (!valueBuffer) {
1485         LOG_ERROR(&quot;Unable to serialize the value to be stored in the database&quot;);
1486         return IDBError { UnknownError, &quot;Unable to serialize value to be stored in the database&quot;_s };
1487     }
1488 
1489     {
1490         auto* sql = cachedStatement(SQL::PutIndexRecord, &quot;INSERT INTO IndexRecords VALUES (?, ?, CAST(? AS TEXT), CAST(? AS TEXT), ?);&quot;_s);
1491         if (!sql
1492             || sql-&gt;bindInt64(1, indexID) != SQLITE_OK
1493             || sql-&gt;bindInt64(2, objectStoreID) != SQLITE_OK
1494             || sql-&gt;bindBlob(3, indexKeyBuffer-&gt;data(), indexKeyBuffer-&gt;size()) != SQLITE_OK
1495             || sql-&gt;bindBlob(4, valueBuffer-&gt;data(), valueBuffer-&gt;size()) != SQLITE_OK
1496             || sql-&gt;bindInt64(5, recordID) != SQLITE_OK
1497             || sql-&gt;step() != SQLITE_DONE) {
1498             LOG_ERROR(&quot;Could not put index record for index %&quot; PRIi64 &quot; in object store %&quot; PRIi64 &quot; in Records table (%i) - %s&quot;, indexID, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1499             return IDBError { UnknownError, &quot;Error putting index record into database&quot;_s };
1500         }
1501     }
1502 
1503     return IDBError { };
1504 }
1505 
1506 
1507 IDBError SQLiteIDBBackingStore::deleteIndex(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier)
1508 {
1509     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteIndex - object store %&quot; PRIu64, objectStoreIdentifier);
1510 
1511     ASSERT(m_sqliteDB);
1512     ASSERT(m_sqliteDB-&gt;isOpen());
1513 
1514     auto* transaction = m_transactions.get(transactionIdentifier);
1515     if (!transaction || !transaction-&gt;inProgress())
1516         return IDBError { UnknownError, &quot;Attempt to delete index without an in-progress transaction&quot;_s };
1517 
1518     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1519         LOG_ERROR(&quot;Attempt to delete index during a non-version-change transaction&quot;);
1520         return IDBError { UnknownError, &quot;Attempt to delete index during a non-version-change transaction&quot;_s };
1521     }
1522 
1523     {
1524         auto* sql = cachedStatement(SQL::DeleteIndexInfo, &quot;DELETE FROM IndexInfo WHERE id = ? AND objectStoreID = ?;&quot;_s);
1525         if (!sql
1526             || sql-&gt;bindInt64(1, indexIdentifier) != SQLITE_OK
1527             || sql-&gt;bindInt64(2, objectStoreIdentifier) != SQLITE_OK
1528             || sql-&gt;step() != SQLITE_DONE) {
1529             LOG_ERROR(&quot;Could not delete index id %&quot; PRIi64 &quot; from IndexInfo table (%i) - %s&quot;, objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1530             return IDBError { UnknownError, &quot;Error deleting index from database&quot;_s };
1531         }
1532     }
1533 
1534     {
1535         auto* sql = cachedStatement(SQL::DeleteIndexRecords, &quot;DELETE FROM IndexRecords WHERE indexID = ?;&quot;_s);
1536         if (!sql
1537             || sql-&gt;bindInt64(1, indexIdentifier) != SQLITE_OK
1538             || sql-&gt;step() != SQLITE_DONE) {
1539             LOG_ERROR(&quot;Could not delete index records for index id %&quot; PRIi64 &quot; from IndexRecords table (%i) - %s&quot;, indexIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1540             return IDBError { UnknownError, &quot;Error deleting index records from database&quot;_s };
1541         }
1542     }
1543 
1544     auto* objectStore = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
1545     ASSERT(objectStore);
1546     objectStore-&gt;deleteIndex(indexIdentifier);
1547 
1548     return IDBError { };
1549 }
1550 
1551 IDBError SQLiteIDBBackingStore::renameIndex(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
1552 {
1553     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::renameIndex - object store %&quot; PRIu64 &quot;, index %&quot; PRIu64, objectStoreIdentifier, indexIdentifier);
1554 
1555     ASSERT(m_sqliteDB);
1556     ASSERT(m_sqliteDB-&gt;isOpen());
1557 
1558     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
1559     if (!objectStoreInfo)
1560         return IDBError { UnknownError, &quot;Could not rename index&quot;_s };
1561 
1562     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);
1563     if (!indexInfo)
1564         return IDBError { UnknownError, &quot;Could not rename index&quot;_s };
1565 
1566     auto* transaction = m_transactions.get(transactionIdentifier);
1567     if (!transaction || !transaction-&gt;inProgress())
1568         return IDBError { UnknownError, &quot;Attempt to rename an index without an in-progress transaction&quot;_s };
1569 
1570     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1571         LOG_ERROR(&quot;Attempt to rename an index in a non-version-change transaction&quot;);
1572         return IDBError { UnknownError, &quot;Attempt to rename an index in a non-version-change transaction&quot;_s };
1573     }
1574 
1575     {
1576         auto* sql = cachedStatement(SQL::RenameIndex, &quot;UPDATE IndexInfo SET name = ? WHERE objectStoreID = ? AND id = ?;&quot;_s);
1577         if (!sql
1578             || sql-&gt;bindText(1, newName) != SQLITE_OK
1579             || sql-&gt;bindInt64(2, objectStoreIdentifier) != SQLITE_OK
1580             || sql-&gt;bindInt64(3, indexIdentifier) != SQLITE_OK
1581             || sql-&gt;step() != SQLITE_DONE) {
1582             LOG_ERROR(&quot;Could not update name for index id (%&quot; PRIi64 &quot;, %&quot; PRIi64 &quot;) in IndexInfo table (%i) - %s&quot;, objectStoreIdentifier, indexIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1583             return IDBError { UnknownError, &quot;Could not rename index&quot;_s };
1584         }
1585     }
1586 
1587     indexInfo-&gt;rename(newName);
1588 
1589     return IDBError { };
1590 }
1591 
1592 IDBError SQLiteIDBBackingStore::keyExistsInObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, const IDBKeyData&amp; keyData, bool&amp; keyExists)
1593 {
1594     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::keyExistsInObjectStore - key %s, object store %&quot; PRIu64, keyData.loggingString().utf8().data(), objectStoreID);
1595 
1596     ASSERT(m_sqliteDB);
1597     ASSERT(m_sqliteDB-&gt;isOpen());
1598 
1599     keyExists = false;
1600 
1601     auto* transaction = m_transactions.get(transactionIdentifier);
1602     if (!transaction || !transaction-&gt;inProgress())
1603         return IDBError { UnknownError, &quot;Attempt to see if key exists in objectstore without an in-progress transaction&quot;_s };
1604 
1605     RefPtr&lt;SharedBuffer&gt; keyBuffer = serializeIDBKeyData(keyData);
1606     if (!keyBuffer) {
1607         LOG_ERROR(&quot;Unable to serialize IDBKey to check for existence in object store&quot;);
1608         return IDBError { UnknownError, &quot;Unable to serialize IDBKey to check for existence in object store&quot;_s };
1609     }
1610     auto* sql = cachedStatement(SQL::KeyExistsInObjectStore, &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key = CAST(? AS TEXT) LIMIT 1;&quot;_s);
1611     if (!sql
1612         || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1613         || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK) {
1614         LOG_ERROR(&quot;Could not get record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1615         return IDBError { UnknownError, &quot;Unable to check for existence of IDBKey in object store&quot;_s };
1616     }
1617 
1618     int sqlResult = sql-&gt;step();
1619     if (sqlResult == SQLITE_OK || sqlResult == SQLITE_DONE)
1620         return IDBError { };
1621 
1622     if (sqlResult != SQLITE_ROW) {
1623         // There was an error fetching the record from the database.
1624         LOG_ERROR(&quot;Could not check if key exists in object store (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1625         return IDBError { UnknownError, &quot;Error checking for existence of IDBKey in object store&quot;_s };
1626     }
1627 
1628     keyExists = true;
1629     return IDBError { };
1630 }
1631 
1632 IDBError SQLiteIDBBackingStore::deleteUnusedBlobFileRecords(SQLiteIDBTransaction&amp; transaction)
1633 {
1634     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteUnusedBlobFileRecords&quot;);
1635 
1636     // Gather the set of blob URLs and filenames that are no longer in use.
1637     HashSet&lt;String&gt; removedBlobFilenames;
1638     {
1639         auto* sql = cachedStatement(SQL::GetUnusedBlobFilenames, &quot;SELECT fileName FROM BlobFiles WHERE blobURL NOT IN (SELECT blobURL FROM BlobRecords)&quot;_s);
1640 
1641         if (!sql) {
1642             LOG_ERROR(&quot;Error deleting stored blobs (%i) (Could not gather unused blobURLs) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1643             return IDBError { UnknownError, &quot;Error deleting stored blobs&quot;_s };
1644         }
1645 
1646         int result = sql-&gt;step();
1647         while (result == SQLITE_ROW) {
1648             removedBlobFilenames.add(sql-&gt;getColumnText(0));
1649             result = sql-&gt;step();
1650         }
1651 
1652         if (result != SQLITE_DONE) {
1653             LOG_ERROR(&quot;Error deleting stored blobs (%i) (Could not gather unused blobURLs) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1654             return IDBError { UnknownError, &quot;Error deleting stored blobs&quot;_s };
1655         }
1656     }
1657 
1658     // Remove the blob records that are no longer in use.
1659     if (!removedBlobFilenames.isEmpty()) {
1660         auto* sql = cachedStatement(SQL::DeleteUnusedBlobs, &quot;DELETE FROM BlobFiles WHERE blobURL NOT IN (SELECT blobURL FROM BlobRecords)&quot;_s);
1661 
1662         if (!sql
1663             || sql-&gt;step() != SQLITE_DONE) {
1664             LOG_ERROR(&quot;Error deleting stored blobs (%i) (Could not delete blobFile records) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1665             return IDBError { UnknownError, &quot;Error deleting stored blobs&quot;_s };
1666         }
1667     }
1668 
1669     for (auto&amp; file : removedBlobFilenames)
1670         transaction.addRemovedBlobFile(file);
1671 
1672     return IDBError { };
1673 }
1674 
1675 IDBError SQLiteIDBBackingStore::deleteRecord(SQLiteIDBTransaction&amp; transaction, int64_t objectStoreID, const IDBKeyData&amp; keyData)
1676 {
1677     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteRecord - key %s, object store %&quot; PRIu64, keyData.loggingString().utf8().data(), objectStoreID);
1678 
1679     ASSERT(m_sqliteDB);
1680     ASSERT(m_sqliteDB-&gt;isOpen());
1681     ASSERT(transaction.inProgress());
1682     ASSERT(transaction.mode() != IDBTransactionMode::Readonly);
1683     UNUSED_PARAM(transaction);
1684 
1685     RefPtr&lt;SharedBuffer&gt; keyBuffer = serializeIDBKeyData(keyData);
1686     if (!keyBuffer) {
1687         LOG_ERROR(&quot;Unable to serialize IDBKeyData to be removed from the database&quot;);
1688         return IDBError { UnknownError, &quot;Unable to serialize IDBKeyData to be removed from the database&quot;_s };
1689     }
1690 
1691     // Get the record ID and value.
1692     int64_t recordID;
1693     ThreadSafeDataBuffer value;
1694     {
1695         auto* sql = cachedStatement(SQL::GetObjectStoreRecord, &quot;SELECT recordID, value FROM Records WHERE objectStoreID = ? AND key = CAST(? AS TEXT);&quot;_s);
1696 
1697         if (!sql
1698             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1699             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK) {
1700             LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1701             return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
1702         }
1703 
1704         int result = sql-&gt;step();
1705 
1706         // If there&#39;s no record ID, there&#39;s no record to delete.
1707         if (result == SQLITE_DONE)
1708             return IDBError { };
1709 
1710         if (result != SQLITE_ROW) {
1711             LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) (unable to fetch record ID) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1712             return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
1713         }
1714 
1715         recordID = sql-&gt;getColumnInt64(0);
1716 
1717         Vector&lt;uint8_t&gt; valueBuffer;
1718         sql-&gt;getColumnBlobAsVector(1, valueBuffer);
1719         value = ThreadSafeDataBuffer::create(WTFMove(valueBuffer));
1720     }
1721 
1722     if (recordID &lt; 1) {
1723         LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) (record ID is invalid) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1724         return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
1725     }
1726 
1727     // Delete the blob records for this object store record.
1728     {
1729         auto* sql = cachedStatement(SQL::DeleteBlobRecord, &quot;DELETE FROM BlobRecords WHERE objectStoreRow = ?;&quot;_s);
1730 
1731         if (!sql
1732             || sql-&gt;bindInt64(1, recordID) != SQLITE_OK
1733             || sql-&gt;step() != SQLITE_DONE) {
1734             LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) (Could not delete BlobRecords records) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1735             return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
1736         }
1737     }
1738 
1739     auto error = deleteUnusedBlobFileRecords(transaction);
1740     if (!error.isNull())
1741         return error;
1742 
1743     // Delete record from object store
1744     {
1745         auto* sql = cachedStatement(SQL::DeleteObjectStoreRecord, &quot;DELETE FROM Records WHERE objectStoreID = ? AND key = CAST(? AS TEXT);&quot;_s);
1746 
1747         if (!sql
1748             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1749             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK
1750             || sql-&gt;step() != SQLITE_DONE) {
1751             LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1752             return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
1753         }
1754     }
1755 
1756     // Delete record from indexes store
1757     {
1758         auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexRecord, &quot;DELETE FROM IndexRecords WHERE objectStoreID = ? AND objectStoreRecordID = ?;&quot;_s);
1759 
1760         if (!sql
1761             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1762             || sql-&gt;bindInt64(2, recordID) != SQLITE_OK
1763             || sql-&gt;step() != SQLITE_DONE) {
1764             LOG_ERROR(&quot;Could not delete record from indexes for object store %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1765             return IDBError { UnknownError, &quot;Failed to delete index entries for object store record&quot;_s };
1766         }
1767     }
1768 
1769     return IDBError { };
1770 }
1771 
1772 IDBError SQLiteIDBBackingStore::deleteRange(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, const IDBKeyRangeData&amp; keyRange)
1773 {
1774     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteRange - range %s, object store %&quot; PRIu64, keyRange.loggingString().utf8().data(), objectStoreID);
1775 
1776     ASSERT(m_sqliteDB);
1777     ASSERT(m_sqliteDB-&gt;isOpen());
1778 
1779     auto* transaction = m_transactions.get(transactionIdentifier);
1780     if (!transaction || !transaction-&gt;inProgress())
1781         return IDBError { UnknownError, &quot;Attempt to delete range from database without an in-progress transaction&quot;_s };
1782 
1783     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
1784         LOG_ERROR(&quot;Attempt to delete records from an object store in a read-only transaction&quot;);
1785         return IDBError { UnknownError, &quot;Attempt to delete records from an object store in a read-only transaction&quot;_s };
1786     }
1787 
1788     // If the range to delete is exactly one key we can delete it right now.
1789     if (keyRange.isExactlyOneKey()) {
1790         auto error = deleteRecord(*transaction, objectStoreID, keyRange.lowerKey);
1791         if (!error.isNull()) {
1792             LOG_ERROR(&quot;Failed to delete record for key &#39;%s&#39;&quot;, keyRange.lowerKey.loggingString().utf8().data());
1793             return error;
1794         }
1795 
1796         transaction-&gt;notifyCursorsOfChanges(objectStoreID);
1797 
1798         return IDBError { };
1799     }
1800 
1801     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(objectStoreID, 0, keyRange);
1802     if (!cursor) {
1803         LOG_ERROR(&quot;Cannot open cursor to delete range of records from the database&quot;);
1804         return IDBError { UnknownError, &quot;Cannot open cursor to delete range of records from the database&quot;_s };
1805     }
1806 
1807     Vector&lt;IDBKeyData&gt; keys;
1808     while (!cursor-&gt;didComplete() &amp;&amp; !cursor-&gt;didError()) {
1809         keys.append(cursor-&gt;currentKey());
1810         cursor-&gt;advance(1);
1811     }
1812 
1813     if (cursor-&gt;didError()) {
1814         LOG_ERROR(&quot;Cursor failed while accumulating range of records from the database&quot;);
1815         return IDBError { UnknownError, &quot;Cursor failed while accumulating range of records from the database&quot;_s };
1816     }
1817 
1818     IDBError error;
1819     for (auto&amp; key : keys) {
1820         error = deleteRecord(*transaction, objectStoreID, key);
1821         if (!error.isNull()) {
1822             LOG_ERROR(&quot;deleteRange: Error deleting keys in range&quot;);
1823             break;
1824         }
1825     }
1826 
1827     transaction-&gt;notifyCursorsOfChanges(objectStoreID);
1828 
1829     return error;
1830 }
1831 
1832 IDBError SQLiteIDBBackingStore::updateOneIndexForAddRecord(const IDBIndexInfo&amp; info, const IDBKeyData&amp; key, const ThreadSafeDataBuffer&amp; value, int64_t recordID)
1833 {
1834     JSLockHolder locker(m_serializationContext-&gt;vm());
1835 
1836     auto jsValue = deserializeIDBValueToJSValue(m_serializationContext-&gt;execState(), value);
1837     if (jsValue.isUndefinedOrNull())
1838         return IDBError { };
1839 
1840     IndexKey indexKey;
1841     auto* objectStoreInfo = infoForObjectStore(info.objectStoreIdentifier());
1842     ASSERT(objectStoreInfo);
1843     generateIndexKeyForValue(m_serializationContext-&gt;execState(), info, jsValue, indexKey, objectStoreInfo-&gt;keyPath(), key);
1844 
1845     if (indexKey.isNull())
1846         return IDBError { };
1847 
1848     return uncheckedPutIndexKey(info, key, indexKey, recordID);
1849 }
1850 
1851 IDBError SQLiteIDBBackingStore::updateAllIndexesForAddRecord(const IDBObjectStoreInfo&amp; info, const IDBKeyData&amp; key, const ThreadSafeDataBuffer&amp; value, int64_t recordID)
1852 {
1853     JSLockHolder locker(m_serializationContext-&gt;vm());
1854 
1855     auto jsValue = deserializeIDBValueToJSValue(m_serializationContext-&gt;execState(), value);
1856     if (jsValue.isUndefinedOrNull())
1857         return IDBError { };
1858 
1859     IDBError error;
1860     bool anyRecordsSucceeded = false;
1861     for (auto&amp; index : info.indexMap().values()) {
1862         IndexKey indexKey;
1863         generateIndexKeyForValue(m_serializationContext-&gt;execState(), index, jsValue, indexKey, info.keyPath(), key);
1864 
1865         if (indexKey.isNull())
1866             continue;
1867 
1868         error = uncheckedPutIndexKey(index, key, indexKey, recordID);
1869         if (!error.isNull())
1870             break;
1871 
1872         anyRecordsSucceeded = true;
1873     }
1874 
1875     if (!error.isNull() &amp;&amp; anyRecordsSucceeded) {
1876         auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexRecord, &quot;DELETE FROM IndexRecords WHERE objectStoreID = ? AND objectStoreRecordID = ?;&quot;_s);
1877 
1878         if (!sql
1879             || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
1880             || sql-&gt;bindInt64(2, recordID) != SQLITE_OK
1881             || sql-&gt;step() != SQLITE_DONE) {
1882             LOG_ERROR(&quot;Adding one Index record failed, but failed to remove all others that previously succeeded&quot;);
1883             return IDBError { UnknownError, &quot;Adding one Index record failed, but failed to remove all others that previously succeeded&quot;_s };
1884         }
1885     }
1886 
1887     return error;
1888 }
1889 
1890 IDBError SQLiteIDBBackingStore::addRecord(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBObjectStoreInfo&amp; objectStoreInfo, const IDBKeyData&amp; keyData, const IDBValue&amp; value)
1891 {
1892     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::addRecord - key %s, object store %&quot; PRIu64, keyData.loggingString().utf8().data(), objectStoreInfo.identifier());
1893 
1894     ASSERT(m_sqliteDB);
1895     ASSERT(m_sqliteDB-&gt;isOpen());
1896     ASSERT(value.data().data());
1897     ASSERT(value.blobURLs().size() == value.blobFilePaths().size());
1898 
1899     auto* transaction = m_transactions.get(transactionIdentifier);
1900     if (!transaction || !transaction-&gt;inProgress())
1901         return IDBError { UnknownError, &quot;Attempt to store a record in an object store without an in-progress transaction&quot;_s };
1902 
1903     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
1904         LOG_ERROR(&quot;Attempt to store a record in an object store in a read-only transaction&quot;);
1905         return IDBError { UnknownError, &quot;Attempt to store a record in an object store in a read-only transaction&quot;_s };
1906     }
1907 
1908     RefPtr&lt;SharedBuffer&gt; keyBuffer = serializeIDBKeyData(keyData);
1909     if (!keyBuffer) {
1910         LOG_ERROR(&quot;Unable to serialize IDBKey to be stored in an object store&quot;);
1911         return IDBError { UnknownError, &quot;Unable to serialize IDBKey to be stored in an object store&quot;_s };
1912     }
1913 
1914     int64_t recordID = 0;
1915     {
1916         auto* sql = cachedStatement(SQL::AddObjectStoreRecord, &quot;INSERT INTO Records VALUES (?, CAST(? AS TEXT), ?, NULL);&quot;_s);
1917         if (!sql
1918             || sql-&gt;bindInt64(1, objectStoreInfo.identifier()) != SQLITE_OK
1919             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK
1920             || sql-&gt;bindBlob(3, value.data().data()-&gt;data(), value.data().data()-&gt;size()) != SQLITE_OK
1921             || sql-&gt;step() != SQLITE_DONE) {
1922             LOG_ERROR(&quot;Could not put record for object store %&quot; PRIi64 &quot; in Records table (%i) - %s&quot;, objectStoreInfo.identifier(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1923             return IDBError { UnknownError, &quot;Unable to store record in object store&quot;_s };
1924         }
1925 
1926         recordID = m_sqliteDB-&gt;lastInsertRowID();
1927     }
1928 
1929     auto error = updateAllIndexesForAddRecord(objectStoreInfo, keyData, value.data(), recordID);
1930 
1931     if (!error.isNull()) {
1932         auto* sql = cachedStatement(SQL::DeleteObjectStoreRecord, &quot;DELETE FROM Records WHERE objectStoreID = ? AND key = CAST(? AS TEXT);&quot;_s);
1933         if (!sql
1934             || sql-&gt;bindInt64(1, objectStoreInfo.identifier()) != SQLITE_OK
1935             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK
1936             || sql-&gt;step() != SQLITE_DONE) {
1937             LOG_ERROR(&quot;Indexing new object store record failed, but unable to remove the object store record itself&quot;);
1938             return IDBError { UnknownError, &quot;Indexing new object store record failed, but unable to remove the object store record itself&quot;_s };
1939         }
1940 
1941         return error;
1942     }
1943 
1944     const Vector&lt;String&gt;&amp; blobURLs = value.blobURLs();
1945     const Vector&lt;String&gt;&amp; blobFiles = value.blobFilePaths();
1946     for (size_t i = 0; i &lt; blobURLs.size(); ++i) {
1947         auto&amp; url = blobURLs[i];
1948         {
1949             auto* sql = cachedStatement(SQL::AddBlobRecord, &quot;INSERT INTO BlobRecords VALUES (?, ?);&quot;_s);
1950             if (!sql
1951                 || sql-&gt;bindInt64(1, recordID) != SQLITE_OK
1952                 || sql-&gt;bindText(2, url) != SQLITE_OK
1953                 || sql-&gt;step() != SQLITE_DONE) {
1954                 LOG_ERROR(&quot;Unable to record Blob record in database&quot;);
1955                 return IDBError { UnknownError, &quot;Unable to record Blob record in database&quot;_s };
1956             }
1957         }
1958         int64_t potentialFileNameInteger = m_sqliteDB-&gt;lastInsertRowID();
1959 
1960         // If we already have a file for this blobURL, nothing left to do.
1961         {
1962             auto* sql = cachedStatement(SQL::BlobFilenameForBlobURL, &quot;SELECT fileName FROM BlobFiles WHERE blobURL = ?;&quot;_s);
1963             if (!sql
1964                 || sql-&gt;bindText(1, url) != SQLITE_OK) {
1965                 LOG_ERROR(&quot;Unable to examine Blob filenames in database&quot;);
1966                 return IDBError { UnknownError, &quot;Unable to examine Blob filenames in database&quot;_s };
1967             }
1968 
1969             int result = sql-&gt;step();
1970             if (result != SQLITE_ROW &amp;&amp; result != SQLITE_DONE) {
1971                 LOG_ERROR(&quot;Unable to examine Blob filenames in database&quot;);
1972                 return IDBError { UnknownError, &quot;Unable to examine Blob filenames in database&quot;_s };
1973             }
1974 
1975             if (result == SQLITE_ROW)
1976                 continue;
1977         }
1978 
1979         // We don&#39;t already have a file for this blobURL, so commit our file as a unique filename
1980         String storedFilename = makeString(potentialFileNameInteger, &quot;.blob&quot;);
1981         {
1982             auto* sql = cachedStatement(SQL::AddBlobFilename, &quot;INSERT INTO BlobFiles VALUES (?, ?);&quot;_s);
1983             if (!sql
1984                 || sql-&gt;bindText(1, url) != SQLITE_OK
1985                 || sql-&gt;bindText(2, storedFilename) != SQLITE_OK
1986                 || sql-&gt;step() != SQLITE_DONE) {
1987                 LOG_ERROR(&quot;Unable to record Blob file record in database&quot;);
1988                 return IDBError { UnknownError, &quot;Unable to record Blob file record in database&quot;_s };
1989             }
1990         }
1991 
1992         transaction-&gt;addBlobFile(blobFiles[i], storedFilename);
1993     }
1994 
1995     transaction-&gt;notifyCursorsOfChanges(objectStoreInfo.identifier());
1996 
1997     return error;
1998 }
1999 
2000 IDBError SQLiteIDBBackingStore::getBlobRecordsForObjectStoreRecord(int64_t objectStoreRecord, Vector&lt;String&gt;&amp; blobURLs, Vector&lt;String&gt;&amp; blobFilePaths)
2001 {
2002     ASSERT(objectStoreRecord);
2003 
2004     HashSet&lt;String&gt; blobURLSet;
2005     {
2006         auto* sql = cachedStatement(SQL::GetBlobURL, &quot;SELECT blobURL FROM BlobRecords WHERE objectStoreRow = ?&quot;_s);
2007         if (!sql
2008             || sql-&gt;bindInt64(1, objectStoreRecord) != SQLITE_OK) {
2009             LOG_ERROR(&quot;Could not prepare statement to fetch blob URLs for object store record (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2010             return IDBError { UnknownError, &quot;Failed to look up blobURL records in object store by key range&quot;_s };
2011         }
2012 
2013         int sqlResult = sql-&gt;step();
2014         if (sqlResult == SQLITE_OK || sqlResult == SQLITE_DONE) {
2015             // There are no blobURLs in the database for this object store record.
2016             return IDBError { };
2017         }
2018 
2019         while (sqlResult == SQLITE_ROW) {
2020             blobURLSet.add(sql-&gt;getColumnText(0));
2021             sqlResult = sql-&gt;step();
2022         }
2023 
2024         if (sqlResult != SQLITE_DONE) {
2025             LOG_ERROR(&quot;Could not fetch blob URLs for object store record (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2026             return IDBError { UnknownError, &quot;Failed to look up blobURL records in object store by key range&quot;_s };
2027         }
2028     }
2029 
2030     ASSERT(!blobURLSet.isEmpty());
2031     for (auto&amp; blobURL : blobURLSet) {
2032         auto* sql = cachedStatement(SQL::BlobFilenameForBlobURL, &quot;SELECT fileName FROM BlobFiles WHERE blobURL = ?;&quot;_s);
2033         if (!sql
2034             || sql-&gt;bindText(1, blobURL) != SQLITE_OK) {
2035             LOG_ERROR(&quot;Could not prepare statement to fetch blob filename for object store record (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2036             return IDBError { UnknownError, &quot;Failed to look up blobURL records in object store by key range&quot;_s };
2037         }
2038 
2039         if (sql-&gt;step() != SQLITE_ROW) {
2040             LOG_ERROR(&quot;Entry for blob filename for blob url %s does not exist (%i) - %s&quot;, blobURL.utf8().data(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2041             return IDBError { UnknownError, &quot;Failed to look up blobURL records in object store by key range&quot;_s };
2042         }
2043 
2044         blobURLs.append(blobURL);
2045 
2046         String fileName = sql-&gt;getColumnText(0);
2047         blobFilePaths.append(FileSystem::pathByAppendingComponent(m_databaseDirectory, fileName));
2048     }
2049     return IDBError { };
2050 }
2051 
2052 IDBError SQLiteIDBBackingStore::getRecord(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, const IDBKeyRangeData&amp; keyRange, IDBGetRecordDataType type, IDBGetResult&amp; resultValue)
2053 {
2054     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getRecord - key range %s, object store %&quot; PRIu64, keyRange.loggingString().utf8().data(), objectStoreID);
2055 
2056     ASSERT(m_sqliteDB);
2057     ASSERT(m_sqliteDB-&gt;isOpen());
2058 
2059     auto* transaction = m_transactions.get(transactionIdentifier);
2060     if (!transaction || !transaction-&gt;inProgress())
2061         return IDBError { UnknownError, &quot;Attempt to get a record from database without an in-progress transaction&quot;_s };
2062 
2063     auto key = keyRange.lowerKey;
2064     if (key.isNull())
2065         key = IDBKeyData::minimum();
2066     RefPtr&lt;SharedBuffer&gt; lowerBuffer = serializeIDBKeyData(key);
2067     if (!lowerBuffer) {
2068         LOG_ERROR(&quot;Unable to serialize lower IDBKey in lookup range&quot;);
2069         return IDBError { UnknownError, &quot;Unable to serialize lower IDBKey in lookup range&quot;_s };
2070     }
2071 
2072     key = keyRange.upperKey;
2073     if (key.isNull())
2074         key = IDBKeyData::maximum();
2075     RefPtr&lt;SharedBuffer&gt; upperBuffer = serializeIDBKeyData(key);
2076     if (!upperBuffer) {
2077         LOG_ERROR(&quot;Unable to serialize upper IDBKey in lookup range&quot;);
2078         return IDBError { UnknownError, &quot;Unable to serialize upper IDBKey in lookup range&quot;_s };
2079     }
2080 
2081     int64_t recordID = 0;
2082     ThreadSafeDataBuffer keyResultBuffer, valueResultBuffer;
2083     {
2084         static const char* const lowerOpenUpperOpen = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
2085         static const char* const lowerOpenUpperClosed = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
2086         static const char* const lowerClosedUpperOpen = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
2087         static const char* const lowerClosedUpperClosed = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
2088 
2089         static const char* const lowerOpenUpperOpenKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
2090         static const char* const lowerOpenUpperClosedKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
2091         static const char* const lowerClosedUpperOpenKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
2092         static const char* const lowerClosedUpperClosedKeyOnly = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
2093 
2094         SQLiteStatement* sql = nullptr;
2095 
2096         switch (type) {
2097         case IDBGetRecordDataType::KeyAndValue:
2098             if (keyRange.lowerOpen) {
2099                 if (keyRange.upperOpen)
2100                     sql = cachedStatement(SQL::GetValueRecordsLowerOpenUpperOpen, lowerOpenUpperOpen);
2101                 else
2102                     sql = cachedStatement(SQL::GetValueRecordsLowerOpenUpperClosed, lowerOpenUpperClosed);
2103             } else {
2104                 if (keyRange.upperOpen)
2105                     sql = cachedStatement(SQL::GetValueRecordsLowerClosedUpperOpen, lowerClosedUpperOpen);
2106                 else
2107                     sql = cachedStatement(SQL::GetValueRecordsLowerClosedUpperClosed, lowerClosedUpperClosed);
2108             }
2109             break;
2110         case IDBGetRecordDataType::KeyOnly:
2111             if (keyRange.lowerOpen) {
2112                 if (keyRange.upperOpen)
2113                     sql = cachedStatement(SQL::GetKeyRecordsLowerOpenUpperOpen, lowerOpenUpperOpenKeyOnly);
2114                 else
2115                     sql = cachedStatement(SQL::GetKeyRecordsLowerOpenUpperClosed, lowerOpenUpperClosedKeyOnly);
2116             } else {
2117                 if (keyRange.upperOpen)
2118                     sql = cachedStatement(SQL::GetKeyRecordsLowerClosedUpperOpen, lowerClosedUpperOpenKeyOnly);
2119                 else
2120                     sql = cachedStatement(SQL::GetKeyRecordsLowerClosedUpperClosed, lowerClosedUpperClosedKeyOnly);
2121             }
2122         }
2123 
2124         if (!sql
2125             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
2126             || sql-&gt;bindBlob(2, lowerBuffer-&gt;data(), lowerBuffer-&gt;size()) != SQLITE_OK
2127             || sql-&gt;bindBlob(3, upperBuffer-&gt;data(), upperBuffer-&gt;size()) != SQLITE_OK) {
2128             LOG_ERROR(&quot;Could not get key range record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2129             return IDBError { UnknownError, &quot;Failed to look up record in object store by key range&quot;_s };
2130         }
2131 
2132         int sqlResult = sql-&gt;step();
2133 
2134         if (sqlResult == SQLITE_OK || sqlResult == SQLITE_DONE) {
2135             // There was no record for the key in the database.
2136             return IDBError { };
2137         }
2138         if (sqlResult != SQLITE_ROW) {
2139             // There was an error fetching the record from the database.
2140             LOG_ERROR(&quot;Could not get record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2141             return IDBError { UnknownError, &quot;Error looking up record in object store by key range&quot;_s };
2142         }
2143 
2144         Vector&lt;uint8_t&gt; keyBuffer;
2145         sql-&gt;getColumnBlobAsVector(0, keyBuffer);
2146         keyResultBuffer = ThreadSafeDataBuffer::create(WTFMove(keyBuffer));
2147 
2148         if (type == IDBGetRecordDataType::KeyAndValue) {
2149             Vector&lt;uint8_t&gt; valueBuffer;
2150             sql-&gt;getColumnBlobAsVector(1, valueBuffer);
2151             valueResultBuffer = ThreadSafeDataBuffer::create(WTFMove(valueBuffer));
2152             recordID = sql-&gt;getColumnInt64(2);
2153         }
2154     }
2155 
2156     auto* keyVector = keyResultBuffer.data();
2157     if (!keyVector) {
2158         LOG_ERROR(&quot;Unable to deserialize key data from database for IDBObjectStore&quot;);
2159         return IDBError { UnknownError, &quot;Error extracting key data from database executing IDBObjectStore get&quot;_s };
2160     }
2161 
2162     IDBKeyData keyData;
2163     if (!deserializeIDBKeyData(keyVector-&gt;data(), keyVector-&gt;size(), keyData)) {
2164         LOG_ERROR(&quot;Unable to deserialize key data from database for IDBObjectStore&quot;);
2165         return IDBError { UnknownError, &quot;Error extracting key data from database executing IDBObjectStore get&quot;_s };
2166     }
2167 
2168     if (type == IDBGetRecordDataType::KeyOnly) {
2169         resultValue = { keyData };
2170         return IDBError { };
2171     }
2172 
2173     ASSERT(recordID);
2174     Vector&lt;String&gt; blobURLs, blobFilePaths;
2175     auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, blobFilePaths);
2176     ASSERT(blobURLs.size() == blobFilePaths.size());
2177 
2178     if (!error.isNull())
2179         return error;
2180 
2181     auto* objectStoreInfo = infoForObjectStore(objectStoreID);
2182     ASSERT(objectStoreInfo);
2183     resultValue = { keyData, { valueResultBuffer, WTFMove(blobURLs), WTFMove(blobFilePaths) }, objectStoreInfo-&gt;keyPath()};
2184     return IDBError { };
2185 }
2186 
2187 IDBError SQLiteIDBBackingStore::getAllRecords(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBGetAllRecordsData&amp; getAllRecordsData, IDBGetAllResult&amp; result)
2188 {
2189     return getAllRecordsData.indexIdentifier ? getAllIndexRecords(transactionIdentifier, getAllRecordsData, result) : getAllObjectStoreRecords(transactionIdentifier, getAllRecordsData, result);
2190 }
2191 
2192 SQLiteStatement* SQLiteIDBBackingStore::cachedStatementForGetAllObjectStoreRecords(const IDBGetAllRecordsData&amp; getAllRecordsData)
2193 {
2194     static const char* const lowerOpenUpperOpenKey =&quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
2195     static const char* const lowerOpenUpperClosedKey = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
2196     static const char* const lowerClosedUpperOpenKey = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
2197     static const char* const lowerClosedUpperClosedKey = &quot;SELECT key FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
2198     static const char* const lowerOpenUpperOpenValue = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
2199     static const char* const lowerOpenUpperClosedValue = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
2200     static const char* const lowerClosedUpperOpenValue = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT) ORDER BY key;&quot;;
2201     static const char* const lowerClosedUpperClosedValue = &quot;SELECT key, value, ROWID FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT) ORDER BY key;&quot;;
2202 
2203     if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Keys) {
2204         if (getAllRecordsData.keyRangeData.lowerOpen) {
2205             if (getAllRecordsData.keyRangeData.upperOpen)
2206                 return cachedStatement(SQL::GetAllKeyRecordsLowerOpenUpperOpen, lowerOpenUpperOpenKey);
2207             return cachedStatement(SQL::GetAllKeyRecordsLowerOpenUpperClosed, lowerOpenUpperClosedKey);
2208         }
2209 
2210         if (getAllRecordsData.keyRangeData.upperOpen)
2211             return cachedStatement(SQL::GetAllKeyRecordsLowerClosedUpperOpen, lowerClosedUpperOpenKey);
2212         return cachedStatement(SQL::GetAllKeyRecordsLowerClosedUpperClosed, lowerClosedUpperClosedKey);
2213     }
2214 
2215     if (getAllRecordsData.keyRangeData.lowerOpen) {
2216         if (getAllRecordsData.keyRangeData.upperOpen)
2217             return cachedStatement(SQL::GetValueRecordsLowerOpenUpperOpen, lowerOpenUpperOpenValue);
2218         return cachedStatement(SQL::GetValueRecordsLowerOpenUpperClosed, lowerOpenUpperClosedValue);
2219     }
2220 
2221     if (getAllRecordsData.keyRangeData.upperOpen)
2222         return cachedStatement(SQL::GetValueRecordsLowerClosedUpperOpen, lowerClosedUpperOpenValue);
2223     return cachedStatement(SQL::GetValueRecordsLowerClosedUpperClosed, lowerClosedUpperClosedValue);
2224 }
2225 
2226 IDBError SQLiteIDBBackingStore::getAllObjectStoreRecords(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBGetAllRecordsData&amp; getAllRecordsData, IDBGetAllResult&amp; result)
2227 {
2228     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getAllObjectStoreRecords&quot;);
2229 
2230     ASSERT(m_sqliteDB);
2231     ASSERT(m_sqliteDB-&gt;isOpen());
2232 
2233     auto* transaction = m_transactions.get(transactionIdentifier);
2234     if (!transaction || !transaction-&gt;inProgress())
2235         return IDBError { UnknownError, &quot;Attempt to get records from database without an in-progress transaction&quot;_s };
2236 
2237     auto key = getAllRecordsData.keyRangeData.lowerKey;
2238     if (key.isNull())
2239         key = IDBKeyData::minimum();
2240     auto lowerBuffer = serializeIDBKeyData(key);
2241     if (!lowerBuffer) {
2242         LOG_ERROR(&quot;Unable to serialize lower IDBKey in lookup range&quot;);
2243         return IDBError { UnknownError, &quot;Unable to serialize lower IDBKey in lookup range&quot;_s };
2244     }
2245 
2246     key = getAllRecordsData.keyRangeData.upperKey;
2247     if (key.isNull())
2248         key = IDBKeyData::maximum();
2249     auto upperBuffer = serializeIDBKeyData(key);
2250     if (!upperBuffer) {
2251         LOG_ERROR(&quot;Unable to serialize upper IDBKey in lookup range&quot;);
2252         return IDBError { UnknownError, &quot;Unable to serialize upper IDBKey in lookup range&quot;_s };
2253     }
2254 
2255     auto* sql = cachedStatementForGetAllObjectStoreRecords(getAllRecordsData);
2256     if (!sql
2257         || sql-&gt;bindInt64(1, getAllRecordsData.objectStoreIdentifier) != SQLITE_OK
2258         || sql-&gt;bindBlob(2, lowerBuffer-&gt;data(), lowerBuffer-&gt;size()) != SQLITE_OK
2259         || sql-&gt;bindBlob(3, upperBuffer-&gt;data(), upperBuffer-&gt;size()) != SQLITE_OK) {
2260         LOG_ERROR(&quot;Could not get key range record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, getAllRecordsData.objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2261         return IDBError { UnknownError, &quot;Failed to look up record in object store by key range&quot;_s };
2262     }
2263 
2264     auto* objectStoreInfo = infoForObjectStore(getAllRecordsData.objectStoreIdentifier);
2265     ASSERT(objectStoreInfo);
2266     result = { getAllRecordsData.getAllType, objectStoreInfo-&gt;keyPath() };
2267 
2268     uint32_t targetResults;
2269     if (getAllRecordsData.count &amp;&amp; getAllRecordsData.count.value())
2270         targetResults = getAllRecordsData.count.value();
2271     else
2272         targetResults = std::numeric_limits&lt;uint32_t&gt;::max();
2273 
2274     int sqlResult = sql-&gt;step();
2275     uint32_t returnedResults = 0;
2276 
2277     while (sqlResult == SQLITE_ROW &amp;&amp; returnedResults &lt; targetResults) {
2278         Vector&lt;uint8_t&gt; keyBuffer;
2279         IDBKeyData keyData;
2280         sql-&gt;getColumnBlobAsVector(0, keyBuffer);
2281         if (!deserializeIDBKeyData(keyBuffer.data(), keyBuffer.size(), keyData)) {
2282             LOG_ERROR(&quot;Unable to deserialize key data from database while getting all records&quot;);
2283             return IDBError { UnknownError, &quot;Unable to deserialize key data while getting all records&quot;_s };
2284         }
2285         result.addKey(WTFMove(keyData));
2286 
2287         if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Values) {
2288             Vector&lt;uint8_t&gt; valueBuffer;
2289             sql-&gt;getColumnBlobAsVector(1, valueBuffer);
2290             ThreadSafeDataBuffer valueResultBuffer = ThreadSafeDataBuffer::create(WTFMove(valueBuffer));
2291 
2292             auto recordID = sql-&gt;getColumnInt64(2);
2293 
2294             ASSERT(recordID);
2295             Vector&lt;String&gt; blobURLs, blobFilePaths;
2296             auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, blobFilePaths);
2297             ASSERT(blobURLs.size() == blobFilePaths.size());
2298 
2299             if (!error.isNull())
2300                 return error;
2301 
2302             result.addValue({ valueResultBuffer, WTFMove(blobURLs), WTFMove(blobFilePaths) });
2303         }
2304 
2305         ++returnedResults;
2306         sqlResult = sql-&gt;step();
2307     }
2308 
2309     if (sqlResult == SQLITE_OK || sqlResult == SQLITE_DONE || sqlResult == SQLITE_ROW) {
2310         // Finished getting results
2311         return IDBError { };
2312     }
2313 
2314     // There was an error fetching records from the database.
2315     LOG_ERROR(&quot;Could not get record from object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, getAllRecordsData.objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2316     return IDBError { UnknownError, &quot;Error looking up record in object store by key range&quot;_s };
2317 }
2318 
2319 IDBError SQLiteIDBBackingStore::getAllIndexRecords(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBGetAllRecordsData&amp; getAllRecordsData, IDBGetAllResult&amp; result)
2320 {
2321     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getAllIndexRecords - %s&quot;, getAllRecordsData.keyRangeData.loggingString().utf8().data());
2322 
2323     ASSERT(m_sqliteDB);
2324     ASSERT(m_sqliteDB-&gt;isOpen());
2325 
2326     auto* transaction = m_transactions.get(transactionIdentifier);
2327     if (!transaction || !transaction-&gt;inProgress())
2328         return IDBError { UnknownError, &quot;Attempt to get all index records from database without an in-progress transaction&quot;_s };
2329 
2330     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(getAllRecordsData.objectStoreIdentifier, getAllRecordsData.indexIdentifier, getAllRecordsData.keyRangeData);
2331     if (!cursor) {
2332         LOG_ERROR(&quot;Cannot open cursor to perform index gets in database&quot;);
2333         return IDBError { UnknownError, &quot;Cannot open cursor to perform index gets in database&quot;_s };
2334     }
2335 
2336     if (cursor-&gt;didError()) {
2337         LOG_ERROR(&quot;Cursor failed while looking up index records in database&quot;);
2338         return IDBError { UnknownError, &quot;Cursor failed while looking up index records in database&quot;_s };
2339     }
2340 
2341     auto* objectStoreInfo = infoForObjectStore(getAllRecordsData.objectStoreIdentifier);
2342     ASSERT(objectStoreInfo);
2343     result = { getAllRecordsData.getAllType, objectStoreInfo-&gt;keyPath() };
2344 
2345     uint32_t currentCount = 0;
2346     uint32_t targetCount = getAllRecordsData.count ? getAllRecordsData.count.value() : 0;
2347     if (!targetCount)
2348         targetCount = std::numeric_limits&lt;uint32_t&gt;::max();
2349     while (!cursor-&gt;didComplete() &amp;&amp; !cursor-&gt;didError() &amp;&amp; currentCount &lt; targetCount) {
2350         IDBKeyData keyCopy = cursor-&gt;currentPrimaryKey();
2351         result.addKey(WTFMove(keyCopy));
2352         if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Values)
2353             result.addValue(IDBValue(cursor-&gt;currentValue()));
2354 
2355         ++currentCount;
2356         cursor-&gt;advance(1);
2357     }
2358 
2359     if (cursor-&gt;didError()) {
2360         LOG_ERROR(&quot;Cursor failed while looking up index records in database&quot;);
2361         return IDBError { UnknownError, &quot;Cursor failed while looking up index records in database&quot;_s };
2362     }
2363 
2364     return IDBError { };
2365 }
2366 
2367 IDBError SQLiteIDBBackingStore::getIndexRecord(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, uint64_t indexID, IndexedDB::IndexRecordType type, const IDBKeyRangeData&amp; range, IDBGetResult&amp; getResult)
2368 {
2369     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getIndexRecord - %s&quot;, range.loggingString().utf8().data());
2370 
2371     ASSERT(m_sqliteDB);
2372     ASSERT(m_sqliteDB-&gt;isOpen());
2373 
2374     auto* transaction = m_transactions.get(transactionIdentifier);
2375     if (!transaction || !transaction-&gt;inProgress())
2376         return IDBError { UnknownError, &quot;Attempt to get an index record from database without an in-progress transaction&quot;_s };
2377 
2378     if (range.isExactlyOneKey())
2379         return uncheckedGetIndexRecordForOneKey(indexID, objectStoreID, type, range.lowerKey, getResult);
2380 
2381     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(objectStoreID, indexID, range);
2382     if (!cursor) {
2383         LOG_ERROR(&quot;Cannot open cursor to perform index get in database&quot;);
2384         return IDBError { UnknownError, &quot;Cannot open cursor to perform index get in database&quot;_s };
2385     }
2386 
2387     if (cursor-&gt;didError()) {
2388         LOG_ERROR(&quot;Cursor failed while looking up index record in database&quot;);
2389         return IDBError { UnknownError, &quot;Cursor failed while looking up index record in database&quot;_s };
2390     }
2391 
2392     if (cursor-&gt;didComplete())
2393         getResult = { };
2394     else {
2395         if (type == IndexedDB::IndexRecordType::Key)
2396             getResult = { cursor-&gt;currentPrimaryKey() };
2397         else {
2398             auto* objectStoreInfo = infoForObjectStore(objectStoreID);
2399             ASSERT(objectStoreInfo);
2400             getResult = { cursor-&gt;currentPrimaryKey(), cursor-&gt;currentPrimaryKey(), IDBValue(cursor-&gt;currentValue()), objectStoreInfo-&gt;keyPath() };
2401         }
2402     }
2403 
2404     return IDBError { };
2405 }
2406 
2407 IDBError SQLiteIDBBackingStore::uncheckedGetIndexRecordForOneKey(int64_t indexID, int64_t objectStoreID, IndexedDB::IndexRecordType type, const IDBKeyData&amp; key, IDBGetResult&amp; getResult)
2408 {
2409     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::uncheckedGetIndexRecordForOneKey&quot;);
2410 
2411     ASSERT(key.isValid() &amp;&amp; key.type() != IndexedDB::KeyType::Max &amp;&amp; key.type() != IndexedDB::KeyType::Min);
2412 
2413     RefPtr&lt;SharedBuffer&gt; buffer = serializeIDBKeyData(key);
2414     if (!buffer) {
2415         LOG_ERROR(&quot;Unable to serialize IDBKey to look up one index record&quot;);
2416         return IDBError { UnknownError, &quot;Unable to serialize IDBKey to look up one index record&quot;_s };
2417     }
2418 
2419     auto* sql = cachedStatement(SQL::GetIndexRecordForOneKey, &quot;SELECT IndexRecords.value, Records.value, Records.recordID FROM Records INNER JOIN IndexRecords ON Records.objectStoreID = IndexRecords.objectStoreID AND Records.recordID = IndexRecords.objectStoreRecordID WHERE IndexRecords.indexID = ? AND IndexRecords.key = CAST(? AS TEXT) ORDER BY IndexRecords.key, IndexRecords.value&quot;_s);
2420 
2421     if (!sql
2422         || sql-&gt;bindInt64(1, indexID) != SQLITE_OK
2423         || sql-&gt;bindBlob(2, buffer-&gt;data(), buffer-&gt;size()) != SQLITE_OK) {
2424         LOG_ERROR(&quot;Unable to lookup index record in database&quot;);
2425         return IDBError { UnknownError, &quot;Unable to lookup index record in database&quot;_s };
2426     }
2427 
2428     int result = sql-&gt;step();
2429     if (result != SQLITE_ROW &amp;&amp; result != SQLITE_DONE) {
2430         LOG_ERROR(&quot;Unable to lookup index record in database&quot;);
2431         return IDBError { UnknownError, &quot;Unable to lookup index record in database&quot;_s };
2432     }
2433 
2434     if (result == SQLITE_DONE)
2435         return IDBError { };
2436 
2437     IDBKeyData objectStoreKey;
2438     Vector&lt;uint8_t&gt; keyVector;
2439     sql-&gt;getColumnBlobAsVector(0, keyVector);
2440 
2441     if (!deserializeIDBKeyData(keyVector.data(), keyVector.size(), objectStoreKey)) {
2442         LOG_ERROR(&quot;Unable to deserialize key looking up index record in database&quot;);
2443         return IDBError { UnknownError, &quot;Unable to deserialize key looking up index record in database&quot;_s };
2444     }
2445 
2446     if (type == IndexedDB::IndexRecordType::Key) {
2447         getResult = { objectStoreKey };
2448         return IDBError { };
2449     }
2450 
2451     Vector&lt;uint8_t&gt; valueVector;
2452     sql-&gt;getColumnBlobAsVector(1, valueVector);
2453 
2454     int64_t recordID = sql-&gt;getColumnInt64(2);
2455     Vector&lt;String&gt; blobURLs, blobFilePaths;
2456     auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, blobFilePaths);
2457     ASSERT(blobURLs.size() == blobFilePaths.size());
2458 
2459     if (!error.isNull())
2460         return error;
2461 
2462     auto* objectStoreInfo = infoForObjectStore(objectStoreID);
2463     ASSERT(objectStoreInfo);
2464     getResult = { objectStoreKey, objectStoreKey, { ThreadSafeDataBuffer::create(WTFMove(valueVector)), WTFMove(blobURLs), WTFMove(blobFilePaths) }, objectStoreInfo-&gt;keyPath() };
2465     return IDBError { };
2466 }
2467 
2468 IDBError SQLiteIDBBackingStore::getCount(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const IDBKeyRangeData&amp; range, uint64_t&amp; outCount)
2469 {
2470     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getCount - object store %&quot; PRIu64, objectStoreIdentifier);
2471     ASSERT(m_sqliteDB);
2472     ASSERT(m_sqliteDB-&gt;isOpen());
2473 
2474     auto* transaction = m_transactions.get(transactionIdentifier);
2475     if (!transaction || !transaction-&gt;inProgress())
2476         return IDBError { UnknownError, &quot;Attempt to get count from database without an in-progress transaction&quot;_s };
2477 
2478     outCount = 0;
2479 
2480     auto lowerKey = range.lowerKey.isNull() ? IDBKeyData::minimum() : range.lowerKey;
2481     RefPtr&lt;SharedBuffer&gt; lowerBuffer = serializeIDBKeyData(lowerKey);
2482     if (!lowerBuffer) {
2483         LOG_ERROR(&quot;Unable to serialize lower IDBKey in lookup range&quot;);
2484         return IDBError { UnknownError, &quot;Unable to serialize lower IDBKey in lookup range for count operation&quot;_s };
2485     }
2486 
2487     auto upperKey = range.upperKey.isNull() ? IDBKeyData::maximum() : range.upperKey;
2488     RefPtr&lt;SharedBuffer&gt; upperBuffer = serializeIDBKeyData(upperKey);
2489     if (!upperBuffer) {
2490         LOG_ERROR(&quot;Unable to serialize upper IDBKey in lookup range&quot;);
2491         return IDBError { UnknownError, &quot;Unable to serialize upper IDBKey in lookup range for count operation&quot;_s };
2492     }
2493 
2494     SQLiteStatement* statement = nullptr;
2495 
2496     if (!indexIdentifier) {
2497         static const char* const countLowerOpenUpperOpenRecords = &quot;SELECT COUNT(*) FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT);&quot;;
2498         static const char* const countLowerOpenUpperClosedRecords = &quot;SELECT COUNT(*) FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT);&quot;;
2499         static const char* const countLowerClosedUpperOpenRecords = &quot;SELECT COUNT(*) FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT);&quot;;
2500         static const char* const countLowerClosedUpperClosedRecords = &quot;SELECT COUNT(*) FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT);&quot;;
2501 
2502         if (range.lowerOpen &amp;&amp; range.upperOpen)
2503             statement = cachedStatement(SQL::CountRecordsLowerOpenUpperOpen, countLowerOpenUpperOpenRecords);
2504         else if (range.lowerOpen &amp;&amp; !range.upperOpen)
2505             statement = cachedStatement(SQL::CountRecordsLowerOpenUpperClosed, countLowerOpenUpperClosedRecords);
2506         else if (!range.lowerOpen &amp;&amp; range.upperOpen)
2507             statement = cachedStatement(SQL::CountRecordsLowerClosedUpperOpen, countLowerClosedUpperOpenRecords);
2508         else
2509             statement = cachedStatement(SQL::CountRecordsLowerClosedUpperClosed, countLowerClosedUpperClosedRecords);
2510 
2511         if (!statement
2512             || statement-&gt;bindInt64(1, objectStoreIdentifier) != SQLITE_OK
2513             || statement-&gt;bindBlob(2, lowerBuffer-&gt;data(), lowerBuffer-&gt;size()) != SQLITE_OK
2514             || statement-&gt;bindBlob(3, upperBuffer-&gt;data(), upperBuffer-&gt;size()) != SQLITE_OK) {
2515             LOG_ERROR(&quot;Could not count records in object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2516             return IDBError { UnknownError, &quot;Unable to count records in object store due to binding failure&quot;_s };
2517         }
2518     } else {
2519         static const char* const countLowerOpenUpperOpenIndexRecords = &quot;SELECT COUNT(*) FROM IndexRecords WHERE indexID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT);&quot;;
2520         static const char* const countLowerOpenUpperClosedIndexRecords = &quot;SELECT COUNT(*) FROM IndexRecords WHERE indexID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT);&quot;;
2521         static const char* const countLowerClosedUpperOpenIndexRecords = &quot;SELECT COUNT(*) FROM IndexRecords WHERE indexID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT);&quot;;
2522         static const char* const countLowerClosedUpperClosedIndexRecords = &quot;SELECT COUNT(*) FROM IndexRecords WHERE indexID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT);&quot;;
2523 
2524         if (range.lowerOpen &amp;&amp; range.upperOpen)
2525             statement = cachedStatement(SQL::CountIndexRecordsLowerOpenUpperOpen, countLowerOpenUpperOpenIndexRecords);
2526         else if (range.lowerOpen &amp;&amp; !range.upperOpen)
2527             statement = cachedStatement(SQL::CountIndexRecordsLowerOpenUpperClosed, countLowerOpenUpperClosedIndexRecords);
2528         else if (!range.lowerOpen &amp;&amp; range.upperOpen)
2529             statement = cachedStatement(SQL::CountIndexRecordsLowerClosedUpperOpen, countLowerClosedUpperOpenIndexRecords);
2530         else
2531             statement = cachedStatement(SQL::CountIndexRecordsLowerClosedUpperClosed, countLowerClosedUpperClosedIndexRecords);
2532 
2533         if (!statement
2534             || statement-&gt;bindInt64(1, indexIdentifier) != SQLITE_OK
2535             || statement-&gt;bindBlob(2, lowerBuffer-&gt;data(), lowerBuffer-&gt;size()) != SQLITE_OK
2536             || statement-&gt;bindBlob(3, upperBuffer-&gt;data(), upperBuffer-&gt;size()) != SQLITE_OK) {
2537             LOG_ERROR(&quot;Could not count records with index %&quot; PRIi64 &quot; from IndexRecords table (%i) - %s&quot;, indexIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2538             return IDBError { UnknownError, &quot;Unable to count records for index due to binding failure&quot;_s };
2539         }
2540     }
2541 
2542     if (statement-&gt;step() != SQLITE_ROW)
2543         return IDBError { UnknownError, &quot;Unable to count records&quot;_s };
2544 
2545     outCount = statement-&gt;getColumnInt(0);
2546     return IDBError { };
2547 }
2548 
2549 IDBError SQLiteIDBBackingStore::uncheckedGetKeyGeneratorValue(int64_t objectStoreID, uint64_t&amp; outValue)
2550 {
2551     auto* sql = cachedStatement(SQL::GetKeyGeneratorValue, &quot;SELECT currentKey FROM KeyGenerators WHERE objectStoreID = ?;&quot;_s);
2552     if (!sql
2553         || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK) {
2554         LOG_ERROR(&quot;Could not retrieve currentKey from KeyGenerators table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2555         return IDBError { UnknownError, &quot;Error getting current key generator value from database&quot;_s };
2556     }
2557     int result = sql-&gt;step();
2558     if (result != SQLITE_ROW) {
2559         LOG_ERROR(&quot;Could not retreive key generator value for object store, but it should be there.&quot;);
2560         return IDBError { UnknownError, &quot;Error finding current key generator value in database&quot;_s };
2561     }
2562 
2563     int64_t value = sql-&gt;getColumnInt64(0);
2564     if (value &lt; 0)
2565         return IDBError { ConstraintError, &quot;Current key generator value from database is invalid&quot; };
2566 
2567     outValue = value;
2568     return IDBError { };
2569 }
2570 
2571 IDBError SQLiteIDBBackingStore::uncheckedSetKeyGeneratorValue(int64_t objectStoreID, uint64_t value)
2572 {
2573     auto* sql = cachedStatement(SQL::SetKeyGeneratorValue, &quot;INSERT INTO KeyGenerators VALUES (?, ?);&quot;_s);
2574     if (!sql
2575         || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
2576         || sql-&gt;bindInt64(2, value) != SQLITE_OK
2577         || sql-&gt;step() != SQLITE_DONE) {
2578         LOG_ERROR(&quot;Could not update key generator value (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2579         return IDBError { ConstraintError, &quot;Error storing new key generator value in database&quot; };
2580     }
2581 
2582     return IDBError { };
2583 }
2584 
2585 IDBError SQLiteIDBBackingStore::generateKeyNumber(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, uint64_t&amp; generatedKey)
2586 {
2587     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::generateKeyNumber&quot;);
2588 
2589     ASSERT(m_sqliteDB);
2590     ASSERT(m_sqliteDB-&gt;isOpen());
2591 
2592     auto* transaction = m_transactions.get(transactionIdentifier);
2593     if (!transaction || !transaction-&gt;inProgress())
2594         return IDBError { UnknownError, &quot;Attempt to generate key in database without an in-progress transaction&quot;_s };
2595 
2596     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
2597         LOG_ERROR(&quot;Attempt to generate key in a read-only transaction&quot;);
2598         return IDBError { UnknownError, &quot;Attempt to generate key in a read-only transaction&quot;_s };
2599     }
2600 
2601     uint64_t currentValue;
2602     auto error = uncheckedGetKeyGeneratorValue(objectStoreID, currentValue);
2603     if (!error.isNull())
2604         return error;
2605 
2606     if (currentValue + 1 &gt; maxGeneratorValue)
2607         return IDBError { ConstraintError, &quot;Cannot generate new key value over 2^53 for object store operation&quot; };
2608 
2609     generatedKey = currentValue + 1;
2610     return uncheckedSetKeyGeneratorValue(objectStoreID, generatedKey);
2611 }
2612 
2613 IDBError SQLiteIDBBackingStore::revertGeneratedKeyNumber(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, uint64_t newKeyNumber)
2614 {
2615     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::revertGeneratedKeyNumber - object store %&quot; PRIu64 &quot;, reverted number %&quot; PRIu64, objectStoreID, newKeyNumber);
2616 
2617     ASSERT(m_sqliteDB);
2618     ASSERT(m_sqliteDB-&gt;isOpen());
2619 
2620     auto* transaction = m_transactions.get(transactionIdentifier);
2621     if (!transaction || !transaction-&gt;inProgress())
2622         return IDBError { UnknownError, &quot;Attempt to revert key generator value in database without an in-progress transaction&quot;_s };
2623 
2624     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
2625         LOG_ERROR(&quot;Attempt to revert key generator value in a read-only transaction&quot;);
2626         return IDBError { UnknownError, &quot;Attempt to revert key generator value in a read-only transaction&quot;_s };
2627     }
2628 
2629     ASSERT(newKeyNumber);
2630     return uncheckedSetKeyGeneratorValue(objectStoreID, newKeyNumber - 1);
2631 }
2632 
2633 IDBError SQLiteIDBBackingStore::maybeUpdateKeyGeneratorNumber(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, double newKeyNumber)
2634 {
2635     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::maybeUpdateKeyGeneratorNumber&quot;);
2636 
2637     ASSERT(m_sqliteDB);
2638     ASSERT(m_sqliteDB-&gt;isOpen());
2639 
2640     auto* transaction = m_transactions.get(transactionIdentifier);
2641     if (!transaction || !transaction-&gt;inProgress())
2642         return IDBError { UnknownError, &quot;Attempt to update key generator value in database without an in-progress transaction&quot;_s };
2643 
2644     if (transaction-&gt;mode() == IDBTransactionMode::Readonly) {
2645         LOG_ERROR(&quot;Attempt to update key generator value in a read-only transaction&quot;);
2646         return IDBError { UnknownError, &quot;Attempt to update key generator value in a read-only transaction&quot;_s };
2647     }
2648 
2649     uint64_t currentValue;
2650     auto error = uncheckedGetKeyGeneratorValue(objectStoreID, currentValue);
2651     if (!error.isNull())
2652         return error;
2653 
2654     if (newKeyNumber &lt;= currentValue)
2655         return IDBError { };
2656 
2657     return uncheckedSetKeyGeneratorValue(objectStoreID, std::min(newKeyNumber, (double)maxGeneratorValue));
2658 }
2659 
2660 IDBError SQLiteIDBBackingStore::openCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBCursorInfo&amp; info, IDBGetResult&amp; result)
2661 {
2662     ASSERT(m_sqliteDB);
2663     ASSERT(m_sqliteDB-&gt;isOpen());
2664 
2665     auto* transaction = m_transactions.get(transactionIdentifier);
2666     if (!transaction || !transaction-&gt;inProgress())
2667         return IDBError { UnknownError, &quot;Attempt to open a cursor in database without an in-progress transaction&quot;_s };
2668 
2669     auto* cursor = transaction-&gt;maybeOpenCursor(info);
2670     if (!cursor) {
2671         LOG_ERROR(&quot;Unable to open cursor&quot;);
2672         return IDBError { UnknownError, &quot;Unable to open cursor&quot;_s };
2673     }
2674 
2675     m_cursors.set(cursor-&gt;identifier(), cursor);
2676 
2677     auto* objectStoreInfo = infoForObjectStore(info.objectStoreIdentifier());
2678     ASSERT(objectStoreInfo);
2679     cursor-&gt;currentData(result, objectStoreInfo-&gt;keyPath());
2680     return IDBError { };
2681 }
2682 
2683 IDBError SQLiteIDBBackingStore::iterateCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier, const IDBIterateCursorData&amp; data, IDBGetResult&amp; result)
2684 {
2685     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::iterateCursor&quot;);
2686 
2687     ASSERT(m_sqliteDB);
2688     ASSERT(m_sqliteDB-&gt;isOpen());
2689 
2690     auto* cursor = m_cursors.get(cursorIdentifier);
2691     if (!cursor) {
2692         LOG_ERROR(&quot;Attempt to iterate a cursor that doesn&#39;t exist&quot;);
2693         return IDBError { UnknownError, &quot;Attempt to iterate a cursor that doesn&#39;t exist&quot;_s };
2694     }
2695 
2696     ASSERT_UNUSED(transactionIdentifier, cursor-&gt;transaction()-&gt;transactionIdentifier() == transactionIdentifier);
2697 
2698     if (!cursor-&gt;transaction() || !cursor-&gt;transaction()-&gt;inProgress())
2699         return IDBError { UnknownError, &quot;Attempt to iterate a cursor without an in-progress transaction&quot;_s };
2700 
2701     auto key = data.keyData;
2702     auto primaryKey = data.primaryKeyData;
2703     auto count = data.count;
2704 
2705     if (key.isValid()) {
2706         if (!cursor-&gt;iterate(key, primaryKey)) {
2707             LOG_ERROR(&quot;Attempt to iterate cursor failed&quot;);
2708             return IDBError { UnknownError, &quot;Attempt to iterate cursor failed&quot;_s };
2709         }
2710     } else {
2711         ASSERT(!primaryKey.isValid());
2712         if (!count)
2713             count = 1;
2714         if (!cursor-&gt;advance(count)) {
2715             LOG_ERROR(&quot;Attempt to advance cursor failed&quot;);
2716             return IDBError { UnknownError, &quot;Attempt to advance cursor failed&quot;_s };
2717         }
2718     }
2719 
2720     if (data.option == IndexedDB::CursorIterateOption::Reply) {
2721         auto* objectStoreInfo = infoForObjectStore(cursor-&gt;objectStoreID());
2722         ASSERT(objectStoreInfo);
2723 
2724         bool shouldPrefetch = key.isNull() &amp;&amp; primaryKey.isNull();
2725         if (shouldPrefetch)
2726             cursor-&gt;prefetch();
2727 
2728         cursor-&gt;currentData(result, objectStoreInfo-&gt;keyPath(), shouldPrefetch ? SQLiteIDBCursor::ShouldIncludePrefetchedRecords::Yes : SQLiteIDBCursor::ShouldIncludePrefetchedRecords::No);
2729     }
2730 
2731     return IDBError { };
2732 }
2733 
2734 IDBObjectStoreInfo* SQLiteIDBBackingStore::infoForObjectStore(uint64_t objectStoreIdentifier)
2735 {
2736     ASSERT(m_databaseInfo);
2737     return m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
2738 }
2739 
2740 void SQLiteIDBBackingStore::deleteBackingStore()
2741 {
2742     String dbFilename = fullDatabasePath();
2743 
2744     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteBackingStore deleting file &#39;%s&#39; on disk&quot;, dbFilename.utf8().data());
2745 
2746     Vector&lt;String&gt; blobFiles;
2747     {
2748         bool errored = true;
2749 
2750         if (m_sqliteDB) {
2751             SQLiteStatement sql(*m_sqliteDB, &quot;SELECT fileName FROM BlobFiles;&quot;_s);
2752             if (sql.prepare() == SQLITE_OK) {
2753                 int result = sql.step();
2754                 while (result == SQLITE_ROW) {
2755                     blobFiles.append(sql.getColumnText(0));
2756                     result = sql.step();
2757                 }
2758 
2759                 if (result == SQLITE_DONE)
2760                     errored = false;
2761             }
2762         }
2763 
2764         if (errored)
2765             LOG_ERROR(&quot;Error getting all blob filenames to be deleted&quot;);
2766     }
2767 
2768     for (auto&amp; file : blobFiles) {
2769         String fullPath = FileSystem::pathByAppendingComponent(m_databaseDirectory, file);
2770         if (!FileSystem::deleteFile(fullPath))
2771             LOG_ERROR(&quot;Error deleting blob file %s&quot;, fullPath.utf8().data());
2772     }
2773 
2774     if (m_sqliteDB)
2775         closeSQLiteDB();
2776 
2777     SQLiteFileSystem::deleteDatabaseFile(dbFilename);
2778     SQLiteFileSystem::deleteEmptyDatabaseDirectory(m_databaseDirectory);
2779     SQLiteFileSystem::deleteEmptyDatabaseDirectory(m_identifier.databaseDirectoryRelativeToRoot(databaseRootDirectoryIsolatedCopy()));
2780 }
2781 
2782 void SQLiteIDBBackingStore::unregisterCursor(SQLiteIDBCursor&amp; cursor)
2783 {
2784     ASSERT(m_cursors.contains(cursor.identifier()));
2785     m_cursors.remove(cursor.identifier());
2786 }
2787 
2788 SQLiteStatement* SQLiteIDBBackingStore::cachedStatement(SQLiteIDBBackingStore::SQL sql, const char* statement)
2789 {
2790     if (sql &gt;= SQL::Invalid) {
2791         LOG_ERROR(&quot;Invalid SQL statement ID passed to cachedStatement()&quot;);
2792         return nullptr;
2793     }
2794 
2795     if (m_cachedStatements[static_cast&lt;size_t&gt;(sql)]) {
2796         if (m_cachedStatements[static_cast&lt;size_t&gt;(sql)]-&gt;reset() == SQLITE_OK)
2797             return m_cachedStatements[static_cast&lt;size_t&gt;(sql)].get();
2798         m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = nullptr;
2799     }
2800 
2801     if (m_sqliteDB) {
2802         m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = makeUnique&lt;SQLiteStatement&gt;(*m_sqliteDB, statement);
2803         if (m_cachedStatements[static_cast&lt;size_t&gt;(sql)]-&gt;prepare() != SQLITE_OK)
2804             m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = nullptr;
2805     }
2806 
2807     return m_cachedStatements[static_cast&lt;size_t&gt;(sql)].get();
2808 }
2809 
2810 void SQLiteIDBBackingStore::close()
2811 {
2812     closeSQLiteDB();
2813 }
2814 
2815 void SQLiteIDBBackingStore::closeSQLiteDB()
2816 {
2817     for (size_t i = 0; i &lt; static_cast&lt;int&gt;(SQL::Invalid); ++i)
2818         m_cachedStatements[i] = nullptr;
2819 
2820     if (m_sqliteDB)
2821         m_sqliteDB-&gt;close();
2822 
2823     m_sqliteDB = nullptr;
2824 }
2825 
2826 bool SQLiteIDBBackingStore::hasTransaction(const IDBResourceIdentifier&amp; transactionIdentifier) const
2827 {
2828     ASSERT(isMainThread());
2829     return m_transactions.contains(transactionIdentifier);
2830 }
2831 
2832 } // namespace IDBServer
2833 } // namespace WebCore
2834 
2835 #endif // ENABLE(INDEXED_DATABASE)
    </pre>
  </body>
</html>
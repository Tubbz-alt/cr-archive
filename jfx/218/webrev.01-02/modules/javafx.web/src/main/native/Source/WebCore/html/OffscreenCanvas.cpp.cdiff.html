<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/html/OffscreenCanvas.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MediaEncryptedEvent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="OffscreenCanvas.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/OffscreenCanvas.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,123 ***</span>
   */
  
  #include &quot;config.h&quot;
  #include &quot;OffscreenCanvas.h&quot;
  
  #include &quot;CanvasRenderingContext.h&quot;
  #include &quot;ImageBitmap.h&quot;
  #include &quot;WebGLRenderingContext.h&quot;
  #include &lt;wtf/IsoMallocInlines.h&gt;
  
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(OffscreenCanvas);
  
  Ref&lt;OffscreenCanvas&gt; OffscreenCanvas::create(ScriptExecutionContext&amp; context, unsigned width, unsigned height)
  {
      return adoptRef(*new OffscreenCanvas(context, width, height));
  }
  
  OffscreenCanvas::OffscreenCanvas(ScriptExecutionContext&amp; context, unsigned width, unsigned height)
<span class="line-modified">!     : ContextDestructionObserver(&amp;context)</span>
<span class="line-modified">!     , m_size(width, height)</span>
  {
  }
  
  OffscreenCanvas::~OffscreenCanvas()
  {
      notifyObserversCanvasDestroyed();
  
<span class="line-modified">!     m_context = nullptr;</span>
  }
  
  unsigned OffscreenCanvas::width() const
  {
<span class="line-modified">!     return m_size.width();</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-removed">- void OffscreenCanvas::setWidth(unsigned newWidth)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return m_size.setWidth(newWidth);</span>
  }
  
  unsigned OffscreenCanvas::height() const
  {
<span class="line-modified">!     return m_size.height();</span>
  }
  
<span class="line-modified">! void OffscreenCanvas::setHeight(unsigned newHeight)</span>
  {
<span class="line-modified">!     return m_size.setHeight(newHeight);</span>
  }
  
<span class="line-modified">! const IntSize&amp; OffscreenCanvas::size() const</span>
  {
<span class="line-modified">!     return m_size;</span>
  }
  
  void OffscreenCanvas::setSize(const IntSize&amp; newSize)
  {
<span class="line-modified">!     m_size = newSize;</span>
  }
  
<span class="line-modified">! #if ENABLE(WEBGL)</span>
<span class="line-removed">- ExceptionOr&lt;OffscreenRenderingContext&gt; OffscreenCanvas::getContext(JSC::ExecState&amp; state, RenderingContextType contextType, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)</span>
  {
<span class="line-modified">!     if (m_context &amp;&amp; contextType == RenderingContextType::Webgl)</span>
<span class="line-modified">!         return { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*m_context) } };</span>
  
      if (contextType == RenderingContextType::Webgl) {
          auto scope = DECLARE_THROW_SCOPE(state.vm());
          auto attributes = convert&lt;IDLDictionary&lt;WebGLContextAttributes&gt;&gt;(state, !arguments.isEmpty() ? arguments[0].get() : JSC::jsUndefined());
          RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
  
          m_context = WebGLRenderingContextBase::create(*this, attributes, &quot;webgl&quot;);
          if (!m_context)
<span class="line-modified">!             return { nullptr };</span>
  
          return { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*m_context) } };
      }
  
<span class="line-modified">!     return { nullptr };</span>
  }
<span class="line-removed">- #endif</span>
  
<span class="line-modified">! RefPtr&lt;ImageBitmap&gt; OffscreenCanvas::transferToImageBitmap()</span>
  {
<span class="line-modified">!     if (!m_context)</span>
<span class="line-modified">!         return nullptr;</span>
  
  #if ENABLE(WEBGL)
<span class="line-modified">!     if (!is&lt;WebGLRenderingContext&gt;(*m_context))</span>
          return nullptr;
  
<span class="line-modified">!     auto webGLContext = &amp;downcast&lt;WebGLRenderingContext&gt;(*m_context);</span>
  
<span class="line-modified">!     // FIXME: We&#39;re supposed to create an ImageBitmap using the backing</span>
<span class="line-modified">!     // store from this canvas (or its context), but for now we&#39;ll just</span>
<span class="line-modified">!     // create a new bitmap and paint into it.</span>
  
<span class="line-modified">!     auto imageBitmap = ImageBitmap::create(m_size);</span>
<span class="line-modified">!     if (!imageBitmap-&gt;buffer())</span>
          return nullptr;
  
<span class="line-modified">!     auto* gc3d = webGLContext-&gt;graphicsContext3D();</span>
<span class="line-modified">!     gc3d-&gt;paintRenderingResultsToCanvas(imageBitmap-&gt;buffer());</span>
  
<span class="line-modified">!     // FIXME: The transfer algorithm requires that the canvas effectively</span>
<span class="line-modified">!     // creates a new backing store. Since we&#39;re not doing that yet, we</span>
<span class="line-modified">!     // need to erase what&#39;s there.</span>
  
<span class="line-modified">!     GC3Dfloat clearColor[4];</span>
<span class="line-modified">!     gc3d-&gt;getFloatv(GraphicsContext3D::COLOR_CLEAR_VALUE, clearColor);</span>
<span class="line-removed">-     gc3d-&gt;clearColor(0, 0, 0, 0);</span>
<span class="line-removed">-     gc3d-&gt;clear(GraphicsContext3D::COLOR_BUFFER_BIT | GraphicsContext3D::DEPTH_BUFFER_BIT | GraphicsContext3D::STENCIL_BUFFER_BIT);</span>
<span class="line-removed">-     gc3d-&gt;clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);</span>
  
<span class="line-modified">!     return imageBitmap;</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     return nullptr;</span>
<span class="line-removed">- #endif</span>
  }
  
  }
<span class="line-new-header">--- 24,313 ---</span>
   */
  
  #include &quot;config.h&quot;
  #include &quot;OffscreenCanvas.h&quot;
  
<span class="line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">+ </span>
<span class="line-added">+ #include &quot;CSSValuePool.h&quot;</span>
  #include &quot;CanvasRenderingContext.h&quot;
  #include &quot;ImageBitmap.h&quot;
<span class="line-added">+ #include &quot;JSBlob.h&quot;</span>
<span class="line-added">+ #include &quot;JSDOMPromiseDeferred.h&quot;</span>
<span class="line-added">+ #include &quot;MIMETypeRegistry.h&quot;</span>
<span class="line-added">+ #include &quot;OffscreenCanvasRenderingContext2D.h&quot;</span>
  #include &quot;WebGLRenderingContext.h&quot;
<span class="line-added">+ #include &quot;WorkerGlobalScope.h&quot;</span>
  #include &lt;wtf/IsoMallocInlines.h&gt;
  
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(OffscreenCanvas);
  
<span class="line-added">+ DetachedOffscreenCanvas::DetachedOffscreenCanvas(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp; buffer, const IntSize&amp; size, bool originClean)</span>
<span class="line-added">+     : m_buffer(WTFMove(buffer))</span>
<span class="line-added">+     , m_size(size)</span>
<span class="line-added">+     , m_originClean(originClean)</span>
<span class="line-added">+ {</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ std::unique_ptr&lt;ImageBuffer&gt; DetachedOffscreenCanvas::takeImageBuffer()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return WTFMove(m_buffer);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  Ref&lt;OffscreenCanvas&gt; OffscreenCanvas::create(ScriptExecutionContext&amp; context, unsigned width, unsigned height)
  {
      return adoptRef(*new OffscreenCanvas(context, width, height));
  }
  
<span class="line-added">+ Ref&lt;OffscreenCanvas&gt; OffscreenCanvas::create(ScriptExecutionContext&amp; context, std::unique_ptr&lt;DetachedOffscreenCanvas&gt;&amp;&amp; detachedCanvas)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Ref&lt;OffscreenCanvas&gt; clone = adoptRef(*new OffscreenCanvas(context, detachedCanvas-&gt;size().width(), detachedCanvas-&gt;size().height()));</span>
<span class="line-added">+     clone-&gt;setImageBuffer(detachedCanvas-&gt;takeImageBuffer());</span>
<span class="line-added">+     if (!detachedCanvas-&gt;originClean())</span>
<span class="line-added">+         clone-&gt;setOriginTainted();</span>
<span class="line-added">+ </span>
<span class="line-added">+     return clone;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  OffscreenCanvas::OffscreenCanvas(ScriptExecutionContext&amp; context, unsigned width, unsigned height)
<span class="line-modified">!     : CanvasBase(IntSize(width, height))</span>
<span class="line-modified">!     , ContextDestructionObserver(&amp;context)</span>
  {
  }
  
  OffscreenCanvas::~OffscreenCanvas()
  {
      notifyObserversCanvasDestroyed();
  
<span class="line-modified">!     m_context = nullptr; // Ensure this goes away before the ImageBuffer.</span>
<span class="line-added">+     setImageBuffer(nullptr);</span>
  }
  
  unsigned OffscreenCanvas::width() const
  {
<span class="line-modified">!     if (m_detached)</span>
<span class="line-modified">!         return 0;</span>
<span class="line-modified">!     return CanvasBase::width();</span>
  }
  
  unsigned OffscreenCanvas::height() const
  {
<span class="line-modified">!     if (m_detached)</span>
<span class="line-added">+         return 0;</span>
<span class="line-added">+     return CanvasBase::height();</span>
  }
  
<span class="line-modified">! void OffscreenCanvas::setWidth(unsigned newWidth)</span>
  {
<span class="line-modified">!     if (m_detached)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     setSize(IntSize(newWidth, height()));</span>
  }
  
<span class="line-modified">! void OffscreenCanvas::setHeight(unsigned newHeight)</span>
  {
<span class="line-modified">!     if (m_detached)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     setSize(IntSize(width(), newHeight));</span>
  }
  
  void OffscreenCanvas::setSize(const IntSize&amp; newSize)
  {
<span class="line-modified">!     CanvasBase::setSize(newSize);</span>
<span class="line-added">+     reset();</span>
  }
  
<span class="line-modified">! ExceptionOr&lt;OffscreenRenderingContext&gt; OffscreenCanvas::getContext(JSC::JSGlobalObject&amp; state, RenderingContextType contextType, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)</span>
  {
<span class="line-modified">!     if (m_detached)</span>
<span class="line-modified">!         return Exception { InvalidStateError };</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (contextType == RenderingContextType::_2d) {</span>
<span class="line-added">+         if (m_context) {</span>
<span class="line-added">+             if (!is&lt;OffscreenCanvasRenderingContext2D&gt;(*m_context))</span>
<span class="line-added">+                 return Exception { InvalidStateError };</span>
<span class="line-added">+             return { RefPtr&lt;OffscreenCanvasRenderingContext2D&gt; { &amp;downcast&lt;OffscreenCanvasRenderingContext2D&gt;(*m_context) } };</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_context = makeUnique&lt;OffscreenCanvasRenderingContext2D&gt;(*this);</span>
<span class="line-added">+         if (!m_context)</span>
<span class="line-added">+             return { RefPtr&lt;OffscreenCanvasRenderingContext2D&gt; { nullptr } };</span>
  
<span class="line-added">+         return { RefPtr&lt;OffscreenCanvasRenderingContext2D&gt; { &amp;downcast&lt;OffscreenCanvasRenderingContext2D&gt;(*m_context) } };</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #if ENABLE(WEBGL)</span>
      if (contextType == RenderingContextType::Webgl) {
<span class="line-added">+         if (m_context) {</span>
<span class="line-added">+             if (!is&lt;WebGLRenderingContext&gt;(*m_context))</span>
<span class="line-added">+                 return Exception { InvalidStateError };</span>
<span class="line-added">+             return { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*m_context) } };</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          auto scope = DECLARE_THROW_SCOPE(state.vm());
          auto attributes = convert&lt;IDLDictionary&lt;WebGLContextAttributes&gt;&gt;(state, !arguments.isEmpty() ? arguments[0].get() : JSC::jsUndefined());
          RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
  
          m_context = WebGLRenderingContextBase::create(*this, attributes, &quot;webgl&quot;);
          if (!m_context)
<span class="line-modified">!             return { RefPtr&lt;WebGLRenderingContext&gt; { nullptr } };</span>
  
          return { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*m_context) } };
      }
<span class="line-added">+ #endif</span>
  
<span class="line-modified">!     return Exception { NotSupportedError };</span>
  }
  
<span class="line-modified">! ExceptionOr&lt;RefPtr&lt;ImageBitmap&gt;&gt; OffscreenCanvas::transferToImageBitmap()</span>
  {
<span class="line-modified">!     if (m_detached || !m_context)</span>
<span class="line-modified">!         return Exception { InvalidStateError };</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (is&lt;OffscreenCanvasRenderingContext2D&gt;(*m_context)) {</span>
<span class="line-added">+         if (!width() || !height())</span>
<span class="line-added">+             return { RefPtr&lt;ImageBitmap&gt; { nullptr } };</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (!m_hasCreatedImageBuffer)</span>
<span class="line-added">+             return { ImageBitmap::create({ ImageBuffer::create(size(), RenderingMode::Unaccelerated), true }) };</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto buffer = takeImageBuffer();</span>
<span class="line-added">+         if (!buffer)</span>
<span class="line-added">+             return { RefPtr&lt;ImageBitmap&gt; { nullptr } };</span>
<span class="line-added">+ </span>
<span class="line-added">+         return { ImageBitmap::create({ WTFMove(buffer), originClean() }) };</span>
<span class="line-added">+     }</span>
  
  #if ENABLE(WEBGL)
<span class="line-modified">!     if (is&lt;WebGLRenderingContext&gt;(*m_context)) {</span>
<span class="line-added">+         auto webGLContext = &amp;downcast&lt;WebGLRenderingContext&gt;(*m_context);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // FIXME: We&#39;re supposed to create an ImageBitmap using the backing</span>
<span class="line-added">+         // store from this canvas (or its context), but for now we&#39;ll just</span>
<span class="line-added">+         // create a new bitmap and paint into it.</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto imageBitmap = ImageBitmap::create(size());</span>
<span class="line-added">+         if (!imageBitmap-&gt;buffer())</span>
<span class="line-added">+             return { RefPtr&lt;ImageBitmap&gt; { nullptr } };</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto* gc3d = webGLContext-&gt;graphicsContextGL();</span>
<span class="line-added">+         gc3d-&gt;paintRenderingResultsToCanvas(imageBitmap-&gt;buffer());</span>
<span class="line-added">+ </span>
<span class="line-added">+         // FIXME: The transfer algorithm requires that the canvas effectively</span>
<span class="line-added">+         // creates a new backing store. Since we&#39;re not doing that yet, we</span>
<span class="line-added">+         // need to erase what&#39;s there.</span>
<span class="line-added">+ </span>
<span class="line-added">+         GCGLfloat clearColor[4];</span>
<span class="line-added">+         gc3d-&gt;getFloatv(GraphicsContextGL::COLOR_CLEAR_VALUE, clearColor);</span>
<span class="line-added">+         gc3d-&gt;clearColor(0, 0, 0, 0);</span>
<span class="line-added">+         gc3d-&gt;clear(GraphicsContextGL::COLOR_BUFFER_BIT | GraphicsContextGL::DEPTH_BUFFER_BIT | GraphicsContextGL::STENCIL_BUFFER_BIT);</span>
<span class="line-added">+         gc3d-&gt;clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);</span>
<span class="line-added">+ </span>
<span class="line-added">+         return { WTFMove(imageBitmap) };</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+     return Exception { NotSupportedError };</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static String toEncodingMimeType(const String&amp; mimeType)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!MIMETypeRegistry::isSupportedImageMIMETypeForEncoding(mimeType))</span>
<span class="line-added">+         return &quot;image/png&quot;_s;</span>
<span class="line-added">+     return mimeType.convertToASCIILowercase();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static Optional&lt;double&gt; qualityFromDouble(double qualityNumber)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!(qualityNumber &gt;= 0 &amp;&amp; qualityNumber &lt;= 1))</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return qualityNumber;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void OffscreenCanvas::convertToBlob(ImageEncodeOptions&amp;&amp; options, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!originClean()) {</span>
<span class="line-added">+         promise-&gt;reject(SecurityError);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (size().isEmpty()) {</span>
<span class="line-added">+         promise-&gt;reject(IndexSizeError);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (m_detached || !buffer()) {</span>
<span class="line-added">+         promise-&gt;reject(InvalidStateError);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     makeRenderingResultsAvailable();</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto encodingMIMEType = toEncodingMimeType(options.type);</span>
<span class="line-added">+     auto quality = qualityFromDouble(options.quality);</span>
<span class="line-added">+ </span>
<span class="line-added">+     Vector&lt;uint8_t&gt; blobData = buffer()-&gt;toData(encodingMIMEType, quality);</span>
<span class="line-added">+     if (blobData.isEmpty()) {</span>
<span class="line-added">+         promise-&gt;reject(EncodingError);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     Ref&lt;Blob&gt; blob = Blob::create(WTFMove(blobData), encodingMIMEType);</span>
<span class="line-added">+     promise-&gt;resolveWithNewlyCreated&lt;IDLInterface&lt;Blob&gt;&gt;(WTFMove(blob));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void OffscreenCanvas::didDraw(const FloatRect&amp; rect)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     notifyObserversCanvasChanged(rect);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ SecurityOrigin* OffscreenCanvas::securityOrigin() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto&amp; context = *canvasBaseScriptExecutionContext();</span>
<span class="line-added">+     if (is&lt;WorkerGlobalScope&gt;(context))</span>
<span class="line-added">+         return &amp;downcast&lt;WorkerGlobalScope&gt;(context).topOrigin();</span>
<span class="line-added">+ </span>
<span class="line-added">+     return &amp;downcast&lt;Document&gt;(context).securityOrigin();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool OffscreenCanvas::canDetach() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return !m_detached &amp;&amp; !m_context;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ std::unique_ptr&lt;DetachedOffscreenCanvas&gt; OffscreenCanvas::detach()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!canDetach())</span>
          return nullptr;
  
<span class="line-modified">!     m_detached = true;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return makeUnique&lt;DetachedOffscreenCanvas&gt;(takeImageBuffer(), size(), originClean());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ CSSValuePool&amp; OffscreenCanvas::cssValuePool()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto* context = canvasBaseScriptExecutionContext();</span>
<span class="line-added">+     if (context-&gt;isWorkerGlobalScope())</span>
<span class="line-added">+         return downcast&lt;WorkerGlobalScope&gt;(*context).cssValuePool();</span>
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT(context-&gt;isDocument());</span>
<span class="line-added">+     return CSSValuePool::singleton();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void OffscreenCanvas::createImageBuffer() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_hasCreatedImageBuffer = true;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!width() || !height())</span>
<span class="line-added">+         return;</span>
  
<span class="line-modified">!     setImageBuffer(ImageBuffer::create(size(), RenderingMode::Unaccelerated));</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-added">+ std::unique_ptr&lt;ImageBuffer&gt; OffscreenCanvas::takeImageBuffer() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!m_detached)</span>
<span class="line-added">+         m_hasCreatedImageBuffer = true;</span>
  
<span class="line-modified">!     // This function is primarily for use with transferToImageBitmap, which</span>
<span class="line-modified">!     // requires that the canvas bitmap refer to a new, blank bitmap of the same</span>
<span class="line-added">+     // size after the existing bitmap is taken. In the case of a zero-size</span>
<span class="line-added">+     // bitmap, our buffer is null, so returning early here is valid.</span>
<span class="line-added">+     if (size().isEmpty())</span>
          return nullptr;
  
<span class="line-modified">!     return setImageBuffer(m_detached ? nullptr : ImageBuffer::create(size(), RenderingMode::Unaccelerated));</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void OffscreenCanvas::reset()</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     resetGraphicsContextState();</span>
<span class="line-added">+     if (is&lt;OffscreenCanvasRenderingContext2D&gt;(m_context.get()))</span>
<span class="line-added">+         downcast&lt;OffscreenCanvasRenderingContext2D&gt;(*m_context).reset();</span>
  
<span class="line-modified">!     m_hasCreatedImageBuffer = false;</span>
<span class="line-modified">!     setImageBuffer(nullptr);</span>
  
<span class="line-modified">!     notifyObserversCanvasResized();</span>
  }
  
  }
<span class="line-added">+ </span>
<span class="line-added">+ #endif</span>
</pre>
<center><a href="MediaEncryptedEvent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="OffscreenCanvas.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
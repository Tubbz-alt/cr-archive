<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/RTCDataChannel.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2012 Google Inc. All rights reserved.
  3  * Copyright (C) 2017 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 16  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 17  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 18  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 19  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 20  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 21  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 23  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RTCDataChannel.h&quot;
 28 
 29 #if ENABLE(WEB_RTC)
 30 
 31 #include &quot;Blob.h&quot;
<a name="1" id="anc1"></a><span class="line-removed"> 32 #include &quot;Event.h&quot;</span>
 33 #include &quot;EventNames.h&quot;
 34 #include &quot;MessageEvent.h&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 35 #include &quot;RTCDataChannelHandler.h&quot;</span>
 36 #include &quot;ScriptExecutionContext.h&quot;
 37 #include &quot;SharedBuffer.h&quot;
<a name="3" id="anc3"></a><span class="line-removed"> 38 #include &lt;JavaScriptCore/ArrayBuffer.h&gt;</span>
 39 #include &lt;JavaScriptCore/ArrayBufferView.h&gt;
 40 #include &lt;wtf/IsoMallocInlines.h&gt;
 41 #include &lt;wtf/NeverDestroyed.h&gt;
 42 
 43 namespace WebCore {
 44 
 45 WTF_MAKE_ISO_ALLOCATED_IMPL(RTCDataChannel);
 46 
 47 static const AtomString&amp; blobKeyword()
 48 {
 49     static NeverDestroyed&lt;AtomString&gt; blob(&quot;blob&quot;, AtomString::ConstructFromLiteral);
 50     return blob;
 51 }
 52 
 53 static const AtomString&amp; arraybufferKeyword()
 54 {
 55     static NeverDestroyed&lt;AtomString&gt; arraybuffer(&quot;arraybuffer&quot;, AtomString::ConstructFromLiteral);
 56     return arraybuffer;
 57 }
 58 
<a name="4" id="anc4"></a><span class="line-modified"> 59 Ref&lt;RTCDataChannel&gt; RTCDataChannel::create(ScriptExecutionContext&amp; context, std::unique_ptr&lt;RTCDataChannelHandler&gt;&amp;&amp; handler, String&amp;&amp; label, RTCDataChannelInit&amp;&amp; options)</span>
 60 {
 61     ASSERT(handler);
<a name="5" id="anc5"></a><span class="line-modified"> 62     auto channel = adoptRef(*new RTCDataChannel(context, WTFMove(handler), WTFMove(label), WTFMove(options)));</span>
 63     channel-&gt;suspendIfNeeded();
 64     channel-&gt;m_handler-&gt;setClient(channel.get());
 65     channel-&gt;setPendingActivity(channel.get());
 66     return channel;
 67 }
 68 
<a name="6" id="anc6"></a><span class="line-modified"> 69 RTCDataChannel::RTCDataChannel(ScriptExecutionContext&amp; context, std::unique_ptr&lt;RTCDataChannelHandler&gt;&amp;&amp; handler, String&amp;&amp; label, RTCDataChannelInit&amp;&amp; options)</span>
<span class="line-modified"> 70     : ActiveDOMObject(&amp;context)</span>















 71     , m_handler(WTFMove(handler))
<a name="7" id="anc7"></a><span class="line-removed"> 72     , m_scheduledEventTimer(*this, &amp;RTCDataChannel::scheduledEventTimerFired)</span>
 73     , m_label(WTFMove(label))
 74     , m_options(WTFMove(options))
<a name="8" id="anc8"></a>
 75 {
 76 }
 77 
 78 size_t RTCDataChannel::bufferedAmount() const
 79 {
 80     // FIXME: We should compute our own bufferedAmount and not count on m_handler which is made null at closing time.
 81     if (m_stopped)
 82         return 0;
 83     return m_handler-&gt;bufferedAmount();
 84 }
 85 
 86 const AtomString&amp; RTCDataChannel::binaryType() const
 87 {
 88     switch (m_binaryType) {
 89     case BinaryType::Blob:
 90         return blobKeyword();
 91     case BinaryType::ArrayBuffer:
 92         return arraybufferKeyword();
 93     }
 94 
 95     ASSERT_NOT_REACHED();
 96     return emptyAtom();
 97 }
 98 
 99 ExceptionOr&lt;void&gt; RTCDataChannel::setBinaryType(const AtomString&amp; binaryType)
100 {
101     if (binaryType == blobKeyword()) {
102         m_binaryType = BinaryType::Blob;
103         return { };
104     }
105     if (binaryType == arraybufferKeyword()) {
106         m_binaryType = BinaryType::ArrayBuffer;
107         return { };
108     }
109     return Exception { TypeMismatchError };
110 }
111 
112 ExceptionOr&lt;void&gt; RTCDataChannel::send(const String&amp; data)
113 {
114     if (m_readyState != RTCDataChannelState::Open)
115         return Exception { InvalidStateError };
116 
<a name="9" id="anc9"></a><span class="line-modified">117     if (!m_handler-&gt;sendStringData(data)) {</span>
<span class="line-removed">118         // FIXME: Decide what the right exception here is.</span>
<span class="line-removed">119         return Exception { SyntaxError };</span>
<span class="line-removed">120     }</span>
<span class="line-removed">121 </span>
122     return { };
123 }
124 
<a name="10" id="anc10"></a><span class="line-modified">125 ExceptionOr&lt;void&gt; RTCDataChannel::sendRawData(const char* data, size_t length)</span>
126 {
127     if (m_readyState != RTCDataChannelState::Open)
128         return Exception { InvalidStateError };
129 
<a name="11" id="anc11"></a><span class="line-modified">130     if (!length)</span>
<span class="line-removed">131         return { };</span>
<span class="line-removed">132 </span>
<span class="line-removed">133     if (!m_handler-&gt;sendRawData(data, length)) {</span>
<span class="line-removed">134         // FIXME: Decide what the right exception here is.</span>
<span class="line-removed">135         return Exception { SyntaxError };</span>
<span class="line-removed">136     }</span>
<span class="line-removed">137 </span>
138     return { };
139 }
140 
<a name="12" id="anc12"></a><span class="line-removed">141 </span>
<span class="line-removed">142 ExceptionOr&lt;void&gt; RTCDataChannel::send(ArrayBuffer&amp; data)</span>
<span class="line-removed">143 {</span>
<span class="line-removed">144     return sendRawData(static_cast&lt;const char*&gt;(data.data()), data.byteLength());</span>
<span class="line-removed">145 }</span>
<span class="line-removed">146 </span>
147 ExceptionOr&lt;void&gt; RTCDataChannel::send(ArrayBufferView&amp; data)
148 {
<a name="13" id="anc13"></a><span class="line-modified">149     return sendRawData(static_cast&lt;const char*&gt;(data.baseAddress()), data.byteLength());</span>




150 }
151 
<a name="14" id="anc14"></a><span class="line-modified">152 ExceptionOr&lt;void&gt; RTCDataChannel::send(Blob&amp;)</span>
153 {
<a name="15" id="anc15"></a><span class="line-modified">154     // FIXME: Implement.</span>
<span class="line-modified">155     return Exception { NotSupportedError };</span>



156 }
157 
158 void RTCDataChannel::close()
159 {
160     if (m_stopped)
161         return;
162 
163     m_stopped = true;
164     m_readyState = RTCDataChannelState::Closed;
165 
<a name="16" id="anc16"></a>

166     m_handler-&gt;close();
167     m_handler = nullptr;
168     unsetPendingActivity(*this);
169 }
170 
171 void RTCDataChannel::didChangeReadyState(RTCDataChannelState newState)
172 {
173     if (m_stopped || m_readyState == RTCDataChannelState::Closed || m_readyState == newState)
174         return;
175 
176     m_readyState = newState;
177 
178     switch (m_readyState) {
179     case RTCDataChannelState::Open:
180         scheduleDispatchEvent(Event::create(eventNames().openEvent, Event::CanBubble::No, Event::IsCancelable::No));
181         break;
182     case RTCDataChannelState::Closed:
183         scheduleDispatchEvent(Event::create(eventNames().closeEvent, Event::CanBubble::No, Event::IsCancelable::No));
184         break;
185     default:
186         break;
187     }
188 }
189 
190 void RTCDataChannel::didReceiveStringData(const String&amp; text)
191 {
<a name="17" id="anc17"></a><span class="line-removed">192     if (m_stopped)</span>
<span class="line-removed">193         return;</span>
<span class="line-removed">194 </span>
195     scheduleDispatchEvent(MessageEvent::create(text));
196 }
197 
198 void RTCDataChannel::didReceiveRawData(const char* data, size_t dataLength)
199 {
<a name="18" id="anc18"></a><span class="line-removed">200     if (m_stopped)</span>
<span class="line-removed">201         return;</span>
<span class="line-removed">202 </span>
203     switch (m_binaryType) {
204     case BinaryType::Blob:
<a name="19" id="anc19"></a><span class="line-modified">205         scheduleDispatchEvent(MessageEvent::create(Blob::create(scriptExecutionContext()-&gt;sessionID(), SharedBuffer::create(data, dataLength), emptyString()), { }));</span>
206         return;
207     case BinaryType::ArrayBuffer:
208         scheduleDispatchEvent(MessageEvent::create(ArrayBuffer::create(data, dataLength)));
209         return;
210     }
211     ASSERT_NOT_REACHED();
212 }
213 
214 void RTCDataChannel::didDetectError()
215 {
<a name="20" id="anc20"></a><span class="line-removed">216     if (m_stopped)</span>
<span class="line-removed">217         return;</span>
<span class="line-removed">218 </span>
219     scheduleDispatchEvent(Event::create(eventNames().errorEvent, Event::CanBubble::No, Event::IsCancelable::No));
220 }
221 
222 void RTCDataChannel::bufferedAmountIsDecreasing(size_t amount)
223 {
<a name="21" id="anc21"></a><span class="line-removed">224     if (m_stopped)</span>
<span class="line-removed">225         return;</span>
<span class="line-removed">226 </span>
227     if (amount &lt;= m_bufferedAmountLowThreshold)
228         scheduleDispatchEvent(Event::create(eventNames().bufferedamountlowEvent, Event::CanBubble::No, Event::IsCancelable::No));
229 }
230 
231 void RTCDataChannel::stop()
232 {
233     close();
234 }
235 
236 void RTCDataChannel::scheduleDispatchEvent(Ref&lt;Event&gt;&amp;&amp; event)
<a name="22" id="anc22"></a><span class="line-removed">237 {</span>
<span class="line-removed">238     m_scheduledEvents.append(WTFMove(event));</span>
<span class="line-removed">239 </span>
<span class="line-removed">240     if (!m_scheduledEventTimer.isActive())</span>
<span class="line-removed">241         m_scheduledEventTimer.startOneShot(0_s);</span>
<span class="line-removed">242 }</span>
<span class="line-removed">243 </span>
<span class="line-removed">244 void RTCDataChannel::scheduledEventTimerFired()</span>
245 {
246     if (m_stopped)
247         return;
248 
<a name="23" id="anc23"></a><span class="line-modified">249     Vector&lt;Ref&lt;Event&gt;&gt; events;</span>
<span class="line-modified">250     events.swap(m_scheduledEvents);</span>
<span class="line-removed">251 </span>
<span class="line-removed">252     for (auto&amp; event : events)</span>
<span class="line-removed">253         dispatchEvent(event);</span>
254 }
255 
256 } // namespace WebCore
257 
258 #endif // ENABLE(WEB_RTC)
<a name="24" id="anc24"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="24" type="hidden" />
</body>
</html>
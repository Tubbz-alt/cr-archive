<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmCodeBlock.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmCallingConvention.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmCodeBlock.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmCodeBlock.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WasmCodeBlock.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
<span class="line-modified"> 31 #include &quot;WasmBBQPlanInlines.h&quot;</span>
 32 #include &quot;WasmCallee.h&quot;
 33 #include &quot;WasmFormat.h&quot;

 34 #include &quot;WasmWorklist.h&quot;
 35 
 36 namespace JSC { namespace Wasm {
 37 
<span class="line-modified"> 38 Ref&lt;CodeBlock&gt; CodeBlock::create(Context* context, MemoryMode mode, ModuleInformation&amp; moduleInformation, CreateEmbedderWrapper&amp;&amp; createEmbedderWrapper, ThrowWasmException throwWasmException)</span>
 39 {
<span class="line-modified"> 40     auto* result = new (NotNull, fastMalloc(sizeof(CodeBlock))) CodeBlock(context, mode, moduleInformation, WTFMove(createEmbedderWrapper), throwWasmException);</span>
 41     return adoptRef(*result);
 42 }
 43 
<span class="line-modified"> 44 CodeBlock::CodeBlock(Context* context, MemoryMode mode, ModuleInformation&amp; moduleInformation, CreateEmbedderWrapper&amp;&amp; createEmbedderWrapper, ThrowWasmException throwWasmException)</span>
 45     : m_calleeCount(moduleInformation.internalFunctionCount())
 46     , m_mode(mode)

 47 {
 48     RefPtr&lt;CodeBlock&gt; protectedThis = this;
 49 
<span class="line-modified"> 50     m_plan = adoptRef(*new BBQPlan(context, makeRef(moduleInformation), BBQPlan::FullCompile, createSharedTask&lt;Plan::CallbackType&gt;([this, protectedThis = WTFMove(protectedThis)] (Plan&amp;) {</span>
<span class="line-modified"> 51         auto locker = holdLock(m_lock);</span>
<span class="line-modified"> 52         if (m_plan-&gt;failed()) {</span>
<span class="line-modified"> 53             m_errorMessage = m_plan-&gt;errorMessage();</span>

















 54             setCompilationFinished();
<span class="line-modified"> 55             return;</span>
<span class="line-modified"> 56         }</span>
<span class="line-modified"> 57 </span>
<span class="line-modified"> 58         // FIXME: we should eventually collect the BBQ code.</span>
<span class="line-modified"> 59         m_callees.resize(m_calleeCount);</span>
<span class="line-modified"> 60         m_optimizedCallees.resize(m_calleeCount);</span>
<span class="line-modified"> 61         m_wasmIndirectCallEntryPoints.resize(m_calleeCount);</span>
<span class="line-modified"> 62 </span>
<span class="line-removed"> 63         m_plan-&gt;initializeCallees([&amp;] (unsigned calleeIndex, RefPtr&lt;Wasm::Callee&gt;&amp;&amp; embedderEntrypointCallee, Ref&lt;Wasm::Callee&gt;&amp;&amp; wasmEntrypointCallee) {</span>
<span class="line-removed"> 64             if (embedderEntrypointCallee) {</span>
<span class="line-removed"> 65                 auto result = m_embedderCallees.set(calleeIndex, WTFMove(embedderEntrypointCallee));</span>
<span class="line-removed"> 66                 ASSERT_UNUSED(result, result.isNewEntry);</span>
 67             }
<span class="line-removed"> 68             m_callees[calleeIndex] = WTFMove(wasmEntrypointCallee);</span>
<span class="line-removed"> 69             m_wasmIndirectCallEntryPoints[calleeIndex] = m_callees[calleeIndex]-&gt;entrypoint();</span>
<span class="line-removed"> 70         });</span>
 71 
<span class="line-modified"> 72         m_wasmToWasmExitStubs = m_plan-&gt;takeWasmToWasmExitStubs();</span>
<span class="line-modified"> 73         m_wasmToWasmCallsites = m_plan-&gt;takeWasmToWasmCallsites();</span>















 74 
<span class="line-modified"> 75         setCompilationFinished();</span>
<span class="line-modified"> 76     }), WTFMove(createEmbedderWrapper), throwWasmException));</span>

 77     m_plan-&gt;setMode(mode);
 78 
 79     auto&amp; worklist = Wasm::ensureWorklist();
 80     // Note, immediately after we enqueue the plan, there is a chance the above callback will be called.
 81     worklist.enqueue(makeRef(*m_plan.get()));
 82 }
 83 
 84 CodeBlock::~CodeBlock() { }
 85 
 86 void CodeBlock::waitUntilFinished()
 87 {
 88     RefPtr&lt;Plan&gt; plan;
 89     {
 90         auto locker = holdLock(m_lock);
 91         plan = m_plan;
 92     }
 93 
 94     if (plan) {
 95         auto&amp; worklist = Wasm::ensureWorklist();
 96         worklist.completePlanSynchronously(*plan.get());
</pre>
</td>
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WasmCodeBlock.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
<span class="line-modified"> 31 #include &quot;WasmBBQPlan.h&quot;</span>
 32 #include &quot;WasmCallee.h&quot;
 33 #include &quot;WasmFormat.h&quot;
<span class="line-added"> 34 #include &quot;WasmLLIntPlan.h&quot;</span>
 35 #include &quot;WasmWorklist.h&quot;
 36 
 37 namespace JSC { namespace Wasm {
 38 
<span class="line-modified"> 39 Ref&lt;CodeBlock&gt; CodeBlock::create(Context* context, MemoryMode mode, ModuleInformation&amp; moduleInformation, RefPtr&lt;LLIntCallees&gt; llintCallees)</span>
 40 {
<span class="line-modified"> 41     auto* result = new (NotNull, fastMalloc(sizeof(CodeBlock))) CodeBlock(context, mode, moduleInformation, llintCallees);</span>
 42     return adoptRef(*result);
 43 }
 44 
<span class="line-modified"> 45 CodeBlock::CodeBlock(Context* context, MemoryMode mode, ModuleInformation&amp; moduleInformation, RefPtr&lt;LLIntCallees&gt; llintCallees)</span>
 46     : m_calleeCount(moduleInformation.internalFunctionCount())
 47     , m_mode(mode)
<span class="line-added"> 48     , m_llintCallees(llintCallees)</span>
 49 {
 50     RefPtr&lt;CodeBlock&gt; protectedThis = this;
 51 
<span class="line-modified"> 52     if (Options::useWasmLLInt()) {</span>
<span class="line-modified"> 53         m_plan = adoptRef(*new LLIntPlan(context, makeRef(moduleInformation), m_llintCallees-&gt;data(), createSharedTask&lt;Plan::CallbackType&gt;([this, protectedThis = WTFMove(protectedThis)] (Plan&amp;) {</span>
<span class="line-modified"> 54             auto locker = holdLock(m_lock);</span>
<span class="line-modified"> 55             if (m_plan-&gt;failed()) {</span>
<span class="line-added"> 56                 m_errorMessage = m_plan-&gt;errorMessage();</span>
<span class="line-added"> 57                 setCompilationFinished();</span>
<span class="line-added"> 58                 return;</span>
<span class="line-added"> 59             }</span>
<span class="line-added"> 60 </span>
<span class="line-added"> 61             // FIXME: we should eventually collect the BBQ code.</span>
<span class="line-added"> 62             m_bbqCallees.resize(m_calleeCount);</span>
<span class="line-added"> 63             m_omgCallees.resize(m_calleeCount);</span>
<span class="line-added"> 64             m_wasmIndirectCallEntryPoints.resize(m_calleeCount);</span>
<span class="line-added"> 65 </span>
<span class="line-added"> 66             for (unsigned i = 0; i &lt; m_calleeCount; ++i)</span>
<span class="line-added"> 67                 m_wasmIndirectCallEntryPoints[i] = m_llintCallees-&gt;at(i)-&gt;entrypoint();</span>
<span class="line-added"> 68 </span>
<span class="line-added"> 69             m_wasmToWasmExitStubs = m_plan-&gt;takeWasmToWasmExitStubs();</span>
<span class="line-added"> 70             m_wasmToWasmCallsites = m_plan-&gt;takeWasmToWasmCallsites();</span>
<span class="line-added"> 71             m_embedderCallees = static_cast&lt;LLIntPlan*&gt;(m_plan.get())-&gt;takeEmbedderCallees();</span>
<span class="line-added"> 72 </span>
 73             setCompilationFinished();
<span class="line-modified"> 74         })));</span>
<span class="line-modified"> 75     } else {</span>
<span class="line-modified"> 76         m_plan = adoptRef(*new BBQPlan(context, makeRef(moduleInformation), EntryPlan::FullCompile, createSharedTask&lt;Plan::CallbackType&gt;([this, protectedThis = WTFMove(protectedThis)] (Plan&amp;) {</span>
<span class="line-modified"> 77             auto locker = holdLock(m_lock);</span>
<span class="line-modified"> 78             if (m_plan-&gt;failed()) {</span>
<span class="line-modified"> 79                 m_errorMessage = m_plan-&gt;errorMessage();</span>
<span class="line-modified"> 80                 setCompilationFinished();</span>
<span class="line-modified"> 81                 return;</span>




 82             }



 83 
<span class="line-modified"> 84             // FIXME: we should eventually collect the BBQ code.</span>
<span class="line-modified"> 85             m_bbqCallees.resize(m_calleeCount);</span>
<span class="line-added"> 86             m_omgCallees.resize(m_calleeCount);</span>
<span class="line-added"> 87             m_wasmIndirectCallEntryPoints.resize(m_calleeCount);</span>
<span class="line-added"> 88 </span>
<span class="line-added"> 89             BBQPlan* bbqPlan = static_cast&lt;BBQPlan*&gt;(m_plan.get());</span>
<span class="line-added"> 90             bbqPlan-&gt;initializeCallees([&amp;] (unsigned calleeIndex, RefPtr&lt;EmbedderEntrypointCallee&gt;&amp;&amp; embedderEntrypointCallee, RefPtr&lt;BBQCallee&gt;&amp;&amp; wasmEntrypoint) {</span>
<span class="line-added"> 91                 if (embedderEntrypointCallee) {</span>
<span class="line-added"> 92                     auto result = m_embedderCallees.set(calleeIndex, WTFMove(embedderEntrypointCallee));</span>
<span class="line-added"> 93                     ASSERT_UNUSED(result, result.isNewEntry);</span>
<span class="line-added"> 94                 }</span>
<span class="line-added"> 95                 m_wasmIndirectCallEntryPoints[calleeIndex] = wasmEntrypoint-&gt;entrypoint();</span>
<span class="line-added"> 96                 m_bbqCallees[calleeIndex] = adoptRef(static_cast&lt;BBQCallee*&gt;(wasmEntrypoint.leakRef()));</span>
<span class="line-added"> 97             });</span>
<span class="line-added"> 98 </span>
<span class="line-added"> 99             m_wasmToWasmExitStubs = m_plan-&gt;takeWasmToWasmExitStubs();</span>
<span class="line-added">100             m_wasmToWasmCallsites = m_plan-&gt;takeWasmToWasmCallsites();</span>
101 
<span class="line-modified">102             setCompilationFinished();</span>
<span class="line-modified">103         })));</span>
<span class="line-added">104     }</span>
105     m_plan-&gt;setMode(mode);
106 
107     auto&amp; worklist = Wasm::ensureWorklist();
108     // Note, immediately after we enqueue the plan, there is a chance the above callback will be called.
109     worklist.enqueue(makeRef(*m_plan.get()));
110 }
111 
112 CodeBlock::~CodeBlock() { }
113 
114 void CodeBlock::waitUntilFinished()
115 {
116     RefPtr&lt;Plan&gt; plan;
117     {
118         auto locker = holdLock(m_lock);
119         plan = m_plan;
120     }
121 
122     if (plan) {
123         auto&amp; worklist = Wasm::ensureWorklist();
124         worklist.completePlanSynchronously(*plan.get());
</pre>
</td>
</tr>
</table>
<center><a href="WasmCallingConvention.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmCodeBlock.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/CalculationValue.h b/modules/javafx.web/src/main/native/Source/WebCore/platform/CalculationValue.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/CalculationValue.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/CalculationValue.h
@@ -47,18 +47,21 @@
     Add = '+',
     Subtract = '-',
     Multiply = '*',
     Divide = '/',
     Min = 0,
-    Max = 1,
+    Max,
+    Clamp,
 };
 
 enum class CalcExpressionNodeType : uint8_t {
     Undefined,
     Number,
     Length,
     Operation,
+    Negation,
+    Inversion,
     BlendLength,
 };
 
 class CalcExpressionNode {
     WTF_MAKE_FAST_ALLOCATED;
@@ -102,10 +105,52 @@
     void dump(WTF::TextStream&) const override;
 
     Length m_length;
 };
 
+class CalcExpressionNegation final : public CalcExpressionNode {
+public:
+    CalcExpressionNegation(std::unique_ptr<CalcExpressionNode>&& node)
+        : CalcExpressionNode(CalcExpressionNodeType::Negation)
+        , m_child(WTFMove(node))
+    {
+        ASSERT(m_child);
+    }
+
+    float evaluate(float maxValue) const final;
+    bool operator==(const CalcExpressionNode&) const final;
+    void dump(WTF::TextStream&) const final;
+
+    const CalcExpressionNode* child() const { return m_child.get(); }
+
+private:
+    std::unique_ptr<CalcExpressionNode> m_child;
+};
+
+bool operator==(const CalcExpressionNegation&, const CalcExpressionNegation&);
+
+class CalcExpressionInversion final : public CalcExpressionNode {
+public:
+    CalcExpressionInversion(std::unique_ptr<CalcExpressionNode>&& node)
+        : CalcExpressionNode(CalcExpressionNodeType::Inversion)
+        , m_child(WTFMove(node))
+    {
+        ASSERT(m_child);
+    }
+
+    float evaluate(float maxValue) const final;
+    bool operator==(const CalcExpressionNode&) const final;
+    void dump(WTF::TextStream&) const final;
+
+    const CalcExpressionNode* child() const { return m_child.get(); }
+
+private:
+    std::unique_ptr<CalcExpressionNode> m_child;
+};
+
+bool operator==(const CalcExpressionInversion&, const CalcExpressionInversion&);
+
 class CalcExpressionOperation final : public CalcExpressionNode {
 public:
     CalcExpressionOperation(Vector<std::unique_ptr<CalcExpressionNode>>&& children, CalcOperator);
 
     CalcOperator getOperator() const { return m_operator; }
@@ -179,16 +224,10 @@
 inline bool operator==(const CalcExpressionNumber& a, const CalcExpressionNumber& b)
 {
     return a.value() == b.value();
 }
 
-inline const CalcExpressionNumber& toCalcExpressionNumber(const CalcExpressionNode& value)
-{
-    ASSERT_WITH_SECURITY_IMPLICATION(value.type() == CalcExpressionNodeType::Number);
-    return static_cast<const CalcExpressionNumber&>(value);
-}
-
 inline CalcExpressionLength::CalcExpressionLength(Length length)
     : CalcExpressionNode(CalcExpressionNodeType::Length)
     , m_length(length)
 {
 }
@@ -196,42 +235,36 @@
 inline bool operator==(const CalcExpressionLength& a, const CalcExpressionLength& b)
 {
     return a.length() == b.length();
 }
 
-inline const CalcExpressionLength& toCalcExpressionLength(const CalcExpressionNode& value)
-{
-    ASSERT_WITH_SECURITY_IMPLICATION(value.type() == CalcExpressionNodeType::Length);
-    return static_cast<const CalcExpressionLength&>(value);
-}
-
 inline CalcExpressionOperation::CalcExpressionOperation(Vector<std::unique_ptr<CalcExpressionNode>>&& children, CalcOperator op)
     : CalcExpressionNode(CalcExpressionNodeType::Operation)
     , m_children(WTFMove(children))
     , m_operator(op)
 {
 }
 
 bool operator==(const CalcExpressionOperation&, const CalcExpressionOperation&);
 
-inline const CalcExpressionOperation& toCalcExpressionOperation(const CalcExpressionNode& value)
-{
-    ASSERT_WITH_SECURITY_IMPLICATION(value.type() == CalcExpressionNodeType::Operation);
-    return static_cast<const CalcExpressionOperation&>(value);
-}
-
 inline bool operator==(const CalcExpressionBlendLength& a, const CalcExpressionBlendLength& b)
 {
     return a.progress() == b.progress() && a.from() == b.from() && a.to() == b.to();
 }
 
-inline const CalcExpressionBlendLength& toCalcExpressionBlendLength(const CalcExpressionNode& value)
-{
-    ASSERT_WITH_SECURITY_IMPLICATION(value.type() == CalcExpressionNodeType::BlendLength);
-    return static_cast<const CalcExpressionBlendLength&>(value);
-}
-
 WTF::TextStream& operator<<(WTF::TextStream&, const CalculationValue&);
 WTF::TextStream& operator<<(WTF::TextStream&, const CalcExpressionNode&);
 WTF::TextStream& operator<<(WTF::TextStream&, CalcOperator);
 
 } // namespace WebCore
+
+#define SPECIALIZE_TYPE_TRAITS_CALCEXPRESSION_NODE(ToValueTypeName, predicate) \
+SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::ToValueTypeName) \
+    static bool isType(const WebCore::CalcExpressionNode& node) { return node.predicate; } \
+SPECIALIZE_TYPE_TRAITS_END()
+
+SPECIALIZE_TYPE_TRAITS_CALCEXPRESSION_NODE(CalcExpressionNumber, type() == WebCore::CalcExpressionNodeType::Number)
+SPECIALIZE_TYPE_TRAITS_CALCEXPRESSION_NODE(CalcExpressionLength, type() == WebCore::CalcExpressionNodeType::Length)
+SPECIALIZE_TYPE_TRAITS_CALCEXPRESSION_NODE(CalcExpressionOperation, type() == WebCore::CalcExpressionNodeType::Operation)
+SPECIALIZE_TYPE_TRAITS_CALCEXPRESSION_NODE(CalcExpressionNegation, type() == WebCore::CalcExpressionNodeType::Negation)
+SPECIALIZE_TYPE_TRAITS_CALCEXPRESSION_NODE(CalcExpressionInversion, type() == WebCore::CalcExpressionNodeType::Inversion)
+SPECIALIZE_TYPE_TRAITS_CALCEXPRESSION_NODE(CalcExpressionBlendLength, type() == WebCore::CalcExpressionNodeType::BlendLength)

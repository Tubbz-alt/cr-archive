<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/generator/Wasm.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
 1 require &#39;json&#39;
 2 
 3 module Wasm
 4     def self.normalize(name)
 5         name.gsub(/(\.|\/)/, &quot;_&quot;)
 6     end
 7 
 8     def self.autogenerate_opcodes(context, wasm_json)
 9         JSON.parse(wasm_json)[&quot;opcode&quot;].each do |name, value|
10             category = value[&quot;category&quot;]
11 
12             next unless [&quot;arithmetic&quot;, &quot;comparison&quot;, &quot;conversion&quot;].include? category
13 
14             returnCount = value[&quot;return&quot;].size
15             parameterCount = value[&quot;parameter&quot;].size
16 
17             assert(&quot;should return 0 or 1 values&quot;) { [0, 1].include? returnCount }
18             assert(&quot;should only have 1 or 2 parameters&quot;) { [1, 2].include? parameterCount }
19 
20             name = normalize(name)
21             arguments = {}
22 
23             virtualRegister = context.eval(&quot;VirtualRegister&quot;)
24 
25             if returnCount &gt; 0
26                 arguments[:dst] = virtualRegister
27             end
28 
29             case parameterCount
30             when 1
31                 arguments[:operand] = virtualRegister
32             when 2
33                 arguments[:lhs] = virtualRegister
34                 arguments[:rhs] = virtualRegister
35             end
36 
37             context.eval(&quot;Proc.new { |arguments, extras | op(&#39;#{name}&#39;, { extras: extras, args: arguments }) }&quot;).call(arguments, value)
38         end
39     end
40 
41     def self.generate_llint_generator(section)
42         opcodes = section.opcodes.select { |op| [&quot;arithmetic&quot;, &quot;comparison&quot;, &quot;conversion&quot;].include? op.extras[&quot;category&quot;] }
43         methods = opcodes.map do |op|
44             case op.args.size
45             when 2
46                 generate_unary_op(op)
47             when 3
48                 generate_binary_op(op)
49             else
50                 assert(&quot;Invalid argument count #{op.args.size} for op #{op.name}&quot;) { false }
51             end
52         end
53         methods.join(&quot;\n&quot;)
54     end
55 
56     def self.generate_binary_op(op)
57         &lt;&lt;-EOF
58 template&lt;&gt;
59 auto LLIntGenerator::addOp&lt;#{op_type(op)}&gt;(ExpressionType lhs, ExpressionType rhs, ExpressionType&amp; result) -&gt; PartialResult
60 {
61     result = push();
62     #{op.capitalized_name}::emit(this, result, lhs, rhs);
63     return { };
64 }
65         EOF
66     end
67 
68     def self.generate_unary_op(op)
69         &lt;&lt;-EOF
70 template&lt;&gt;
71 auto LLIntGenerator::addOp&lt;#{op_type(op)}&gt;(ExpressionType operand, ExpressionType&amp; result) -&gt; PartialResult
72 {
73     result = push();
74     #{op.capitalized_name}::emit(this, result, operand);
75     return { };
76 }
77         EOF
78     end
79 
80     def self.op_type(op)
81         &quot;OpType::#{op.unprefixed_name.gsub(/^.|[^a-z0-9]./) { |c| c[-1].upcase }}&quot;
82     end
83 end
    </pre>
  </body>
</html>
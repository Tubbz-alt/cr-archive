<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Path.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="OpenGLShims.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Path.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Path.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 36 #include &quot;RoundedRect.h&quot;
 37 #include &lt;math.h&gt;
 38 #include &lt;wtf/MathExtras.h&gt;
 39 #include &lt;wtf/text/TextStream.h&gt;
 40 
 41 namespace WebCore {
 42 
 43 #if !USE(DIRECT2D)
 44 float Path::length() const
 45 {
 46     PathTraversalState traversalState(PathTraversalState::Action::TotalLength);
 47 
 48     apply([&amp;traversalState](const PathElement&amp; element) {
 49         traversalState.processPathElement(element);
 50     });
 51 
 52     return traversalState.totalLength();
 53 }
 54 #endif
 55 
<span class="line-modified"> 56 PathTraversalState Path::traversalStateAtLength(float length, bool&amp; success) const</span>
 57 {
 58     PathTraversalState traversalState(PathTraversalState::Action::VectorAtLength, length);
 59 
 60     apply([&amp;traversalState](const PathElement&amp; element) {
 61         traversalState.processPathElement(element);
 62     });
 63 
<span class="line-removed"> 64     success = traversalState.success();</span>
 65     return traversalState;
 66 }
 67 
<span class="line-modified"> 68 FloatPoint Path::pointAtLength(float length, bool&amp; success) const</span>
 69 {
<span class="line-modified"> 70     return traversalStateAtLength(length, success).current();</span>
<span class="line-removed"> 71 }</span>
<span class="line-removed"> 72 </span>
<span class="line-removed"> 73 float Path::normalAngleAtLength(float length, bool&amp; success) const</span>
<span class="line-removed"> 74 {</span>
<span class="line-removed"> 75     return traversalStateAtLength(length, success).normalAngle();</span>
 76 }
 77 
 78 void Path::addRoundedRect(const FloatRect&amp; rect, const FloatSize&amp; roundingRadii, RoundedRectStrategy strategy)
 79 {
 80     if (rect.isEmpty())
 81         return;
 82 
 83     FloatSize radius(roundingRadii);
 84     FloatSize halfSize = rect.size() / 2;
 85 
 86     // Apply the SVG corner radius constraints, per the rect section of the SVG shapes spec: if
 87     // one of rx,ry is negative, then the other corner radius value is used. If both values are
 88     // negative then rx = ry = 0. If rx is greater than half of the width of the rectangle
 89     // then set rx to half of the width; ry is handled similarly.
 90 
 91     if (radius.width() &lt; 0)
 92         radius.setWidth((radius.height() &lt; 0) ? 0 : radius.height());
 93 
 94     if (radius.height() &lt; 0)
 95         radius.setHeight(radius.width());
</pre>
<hr />
<pre>
100     if (radius.height() &gt; halfSize.height())
101         radius.setHeight(halfSize.height());
102 
103     addRoundedRect(FloatRoundedRect(rect, radius, radius, radius, radius), strategy);
104 }
105 
106 void Path::addRoundedRect(const FloatRoundedRect&amp; r, RoundedRectStrategy strategy)
107 {
108     if (r.isEmpty())
109         return;
110 
111     const FloatRoundedRect::Radii&amp; radii = r.radii();
112     const FloatRect&amp; rect = r.rect();
113 
114     if (!r.isRenderable()) {
115         // If all the radii cannot be accommodated, return a rect.
116         addRect(rect);
117         return;
118     }
119 
<span class="line-modified">120     if (strategy == PreferNativeRoundedRect) {</span>
121 #if USE(CG) || USE(DIRECT2D)
122         platformAddPathForRoundedRect(rect, radii.topLeft(), radii.topRight(), radii.bottomLeft(), radii.bottomRight());
123         return;
124 #endif
125     }
126 
127     addBeziersForRoundedRect(rect, radii.topLeft(), radii.topRight(), radii.bottomLeft(), radii.bottomRight());
128 }
129 
130 void Path::addRoundedRect(const RoundedRect&amp; r)
131 {
132     addRoundedRect(FloatRoundedRect(r));
133 }
134 
135 void Path::addBeziersForRoundedRect(const FloatRect&amp; rect, const FloatSize&amp; topLeftRadius, const FloatSize&amp; topRightRadius, const FloatSize&amp; bottomLeftRadius, const FloatSize&amp; bottomRightRadius)
136 {
137     moveTo(FloatPoint(rect.x() + topLeftRadius.width(), rect.y()));
138 
139     addLineTo(FloatPoint(rect.maxX() - topRightRadius.width(), rect.y()));
140     if (topRightRadius.width() &gt; 0 || topRightRadius.height() &gt; 0)
</pre>
<hr />
<pre>
181 }
182 #endif
183 
184 #ifndef NDEBUG
185 void Path::dump() const
186 {
187     TextStream stream;
188     stream &lt;&lt; *this;
189     WTFLogAlways(&quot;%s&quot;, stream.release().utf8().data());
190 }
191 #endif
192 
193 TextStream&amp; operator&lt;&lt;(TextStream&amp; stream, const Path&amp; path)
194 {
195     bool isFirst = true;
196     path.apply([&amp;stream, &amp;isFirst](const PathElement&amp; element) {
197         if (!isFirst)
198             stream &lt;&lt; &quot;, &quot;;
199         isFirst = false;
200         switch (element.type) {
<span class="line-modified">201         case PathElementMoveToPoint: // The points member will contain 1 value.</span>
202             stream &lt;&lt; &quot;move to &quot; &lt;&lt; element.points[0];
203             break;
<span class="line-modified">204         case PathElementAddLineToPoint: // The points member will contain 1 value.</span>
205             stream &lt;&lt; &quot;add line to &quot; &lt;&lt; element.points[0];
206             break;
<span class="line-modified">207         case PathElementAddQuadCurveToPoint: // The points member will contain 2 values.</span>
208             stream &lt;&lt; &quot;add quad curve to &quot; &lt;&lt; element.points[0] &lt;&lt; &quot; &quot; &lt;&lt; element.points[1];
209             break;
<span class="line-modified">210         case PathElementAddCurveToPoint: // The points member will contain 3 values.</span>
211             stream &lt;&lt; &quot;add curve to &quot; &lt;&lt; element.points[0] &lt;&lt; &quot; &quot; &lt;&lt; element.points[1] &lt;&lt; &quot; &quot; &lt;&lt; element.points[2];
212             break;
<span class="line-modified">213         case PathElementCloseSubpath: // The points member will contain no values.</span>
214             stream &lt;&lt; &quot;close subpath&quot;;
215             break;
216         }
217     });
218 
219     return stream;
220 }
221 
222 }
</pre>
</td>
<td>
<hr />
<pre>
 36 #include &quot;RoundedRect.h&quot;
 37 #include &lt;math.h&gt;
 38 #include &lt;wtf/MathExtras.h&gt;
 39 #include &lt;wtf/text/TextStream.h&gt;
 40 
 41 namespace WebCore {
 42 
 43 #if !USE(DIRECT2D)
 44 float Path::length() const
 45 {
 46     PathTraversalState traversalState(PathTraversalState::Action::TotalLength);
 47 
 48     apply([&amp;traversalState](const PathElement&amp; element) {
 49         traversalState.processPathElement(element);
 50     });
 51 
 52     return traversalState.totalLength();
 53 }
 54 #endif
 55 
<span class="line-modified"> 56 PathTraversalState Path::traversalStateAtLength(float length) const</span>
 57 {
 58     PathTraversalState traversalState(PathTraversalState::Action::VectorAtLength, length);
 59 
 60     apply([&amp;traversalState](const PathElement&amp; element) {
 61         traversalState.processPathElement(element);
 62     });
 63 

 64     return traversalState;
 65 }
 66 
<span class="line-modified"> 67 FloatPoint Path::pointAtLength(float length) const</span>
 68 {
<span class="line-modified"> 69     return traversalStateAtLength(length).current();</span>





 70 }
 71 
 72 void Path::addRoundedRect(const FloatRect&amp; rect, const FloatSize&amp; roundingRadii, RoundedRectStrategy strategy)
 73 {
 74     if (rect.isEmpty())
 75         return;
 76 
 77     FloatSize radius(roundingRadii);
 78     FloatSize halfSize = rect.size() / 2;
 79 
 80     // Apply the SVG corner radius constraints, per the rect section of the SVG shapes spec: if
 81     // one of rx,ry is negative, then the other corner radius value is used. If both values are
 82     // negative then rx = ry = 0. If rx is greater than half of the width of the rectangle
 83     // then set rx to half of the width; ry is handled similarly.
 84 
 85     if (radius.width() &lt; 0)
 86         radius.setWidth((radius.height() &lt; 0) ? 0 : radius.height());
 87 
 88     if (radius.height() &lt; 0)
 89         radius.setHeight(radius.width());
</pre>
<hr />
<pre>
 94     if (radius.height() &gt; halfSize.height())
 95         radius.setHeight(halfSize.height());
 96 
 97     addRoundedRect(FloatRoundedRect(rect, radius, radius, radius, radius), strategy);
 98 }
 99 
100 void Path::addRoundedRect(const FloatRoundedRect&amp; r, RoundedRectStrategy strategy)
101 {
102     if (r.isEmpty())
103         return;
104 
105     const FloatRoundedRect::Radii&amp; radii = r.radii();
106     const FloatRect&amp; rect = r.rect();
107 
108     if (!r.isRenderable()) {
109         // If all the radii cannot be accommodated, return a rect.
110         addRect(rect);
111         return;
112     }
113 
<span class="line-modified">114     if (strategy == RoundedRectStrategy::PreferNative) {</span>
115 #if USE(CG) || USE(DIRECT2D)
116         platformAddPathForRoundedRect(rect, radii.topLeft(), radii.topRight(), radii.bottomLeft(), radii.bottomRight());
117         return;
118 #endif
119     }
120 
121     addBeziersForRoundedRect(rect, radii.topLeft(), radii.topRight(), radii.bottomLeft(), radii.bottomRight());
122 }
123 
124 void Path::addRoundedRect(const RoundedRect&amp; r)
125 {
126     addRoundedRect(FloatRoundedRect(r));
127 }
128 
129 void Path::addBeziersForRoundedRect(const FloatRect&amp; rect, const FloatSize&amp; topLeftRadius, const FloatSize&amp; topRightRadius, const FloatSize&amp; bottomLeftRadius, const FloatSize&amp; bottomRightRadius)
130 {
131     moveTo(FloatPoint(rect.x() + topLeftRadius.width(), rect.y()));
132 
133     addLineTo(FloatPoint(rect.maxX() - topRightRadius.width(), rect.y()));
134     if (topRightRadius.width() &gt; 0 || topRightRadius.height() &gt; 0)
</pre>
<hr />
<pre>
175 }
176 #endif
177 
178 #ifndef NDEBUG
179 void Path::dump() const
180 {
181     TextStream stream;
182     stream &lt;&lt; *this;
183     WTFLogAlways(&quot;%s&quot;, stream.release().utf8().data());
184 }
185 #endif
186 
187 TextStream&amp; operator&lt;&lt;(TextStream&amp; stream, const Path&amp; path)
188 {
189     bool isFirst = true;
190     path.apply([&amp;stream, &amp;isFirst](const PathElement&amp; element) {
191         if (!isFirst)
192             stream &lt;&lt; &quot;, &quot;;
193         isFirst = false;
194         switch (element.type) {
<span class="line-modified">195         case PathElement::Type::MoveToPoint: // The points member will contain 1 value.</span>
196             stream &lt;&lt; &quot;move to &quot; &lt;&lt; element.points[0];
197             break;
<span class="line-modified">198         case PathElement::Type::AddLineToPoint: // The points member will contain 1 value.</span>
199             stream &lt;&lt; &quot;add line to &quot; &lt;&lt; element.points[0];
200             break;
<span class="line-modified">201         case PathElement::Type::AddQuadCurveToPoint: // The points member will contain 2 values.</span>
202             stream &lt;&lt; &quot;add quad curve to &quot; &lt;&lt; element.points[0] &lt;&lt; &quot; &quot; &lt;&lt; element.points[1];
203             break;
<span class="line-modified">204         case PathElement::Type::AddCurveToPoint: // The points member will contain 3 values.</span>
205             stream &lt;&lt; &quot;add curve to &quot; &lt;&lt; element.points[0] &lt;&lt; &quot; &quot; &lt;&lt; element.points[1] &lt;&lt; &quot; &quot; &lt;&lt; element.points[2];
206             break;
<span class="line-modified">207         case PathElement::Type::CloseSubpath: // The points member will contain no values.</span>
208             stream &lt;&lt; &quot;close subpath&quot;;
209             break;
210         }
211     });
212 
213     return stream;
214 }
215 
216 }
</pre>
</td>
</tr>
</table>
<center><a href="OpenGLShims.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Path.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
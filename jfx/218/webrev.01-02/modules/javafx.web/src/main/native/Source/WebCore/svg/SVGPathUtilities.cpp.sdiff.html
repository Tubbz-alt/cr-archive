<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/svg/SVGPathUtilities.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGPathTraversalStateBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGPathUtilities.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/svg/SVGPathUtilities.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 41 
 42 Path buildPathFromString(const String&amp; d)
 43 {
 44     if (d.isEmpty())
 45         return { };
 46 
 47     Path path;
 48     SVGPathBuilder builder(path);
 49     SVGPathStringSource source(d);
 50     SVGPathParser::parse(source, builder);
 51     return path;
 52 }
 53 
 54 String buildStringFromPath(const Path&amp; path)
 55 {
 56     StringBuilder builder;
 57 
 58     if (!path.isNull() &amp;&amp; !path.isEmpty()) {
 59         path.apply([&amp;builder] (const PathElement&amp; element) {
 60             switch (element.type) {
<span class="line-modified"> 61             case PathElementMoveToPoint:</span>
 62                 builder.append(&#39;M&#39;);
 63                 builder.appendNumber(element.points[0].x());
 64                 builder.append(&#39; &#39;);
 65                 builder.appendNumber(element.points[0].y());
 66                 break;
<span class="line-modified"> 67             case PathElementAddLineToPoint:</span>
 68                 builder.append(&#39;L&#39;);
 69                 builder.appendNumber(element.points[0].x());
 70                 builder.append(&#39; &#39;);
 71                 builder.appendNumber(element.points[0].y());
 72                 break;
<span class="line-modified"> 73             case PathElementAddQuadCurveToPoint:</span>
 74                 builder.append(&#39;Q&#39;);
 75                 builder.appendNumber(element.points[0].x());
 76                 builder.append(&#39; &#39;);
 77                 builder.appendNumber(element.points[0].y());
 78                 builder.append(&#39;,&#39;);
 79                 builder.appendNumber(element.points[1].x());
 80                 builder.append(&#39; &#39;);
 81                 builder.appendNumber(element.points[1].y());
 82                 break;
<span class="line-modified"> 83             case PathElementAddCurveToPoint:</span>
 84                 builder.append(&#39;C&#39;);
 85                 builder.appendNumber(element.points[0].x());
 86                 builder.append(&#39; &#39;);
 87                 builder.appendNumber(element.points[0].y());
 88                 builder.append(&#39;,&#39;);
 89                 builder.appendNumber(element.points[1].x());
 90                 builder.append(&#39; &#39;);
 91                 builder.appendNumber(element.points[1].y());
 92                 builder.append(&#39;,&#39;);
 93                 builder.appendNumber(element.points[2].x());
 94                 builder.append(&#39; &#39;);
 95                 builder.appendNumber(element.points[2].y());
 96                 break;
<span class="line-modified"> 97             case PathElementCloseSubpath:</span>
 98                 builder.append(&#39;Z&#39;);
 99                 break;
100             }
101         });
102     }
103 
104     return builder.toString();
105 }
106 
107 bool buildSVGPathByteStreamFromSVGPathSegList(const SVGPathSegList&amp; list, SVGPathByteStream&amp; stream, PathParsingMode parsingMode, bool checkForInitialMoveTo)
108 {
109     stream.clear();
110     if (list.isEmpty())
111         return true;
112 
113     SVGPathSegListSource source(list);
114     return SVGPathParser::parseToByteStream(source, stream, parsingMode, checkForInitialMoveTo);
115 }
116 
117 Path buildPathFromByteStream(const SVGPathByteStream&amp; stream)
</pre>
<hr />
<pre>
176     return SVGPathBlender::blendAnimatedPath(fromSource, toSource, builder, progress);
177 }
178 
179 bool addToSVGPathByteStream(SVGPathByteStream&amp; streamToAppendTo, const SVGPathByteStream&amp; byStream, unsigned repeatCount)
180 {
181     // The byStream will be blended with streamToAppendTo. So streamToAppendTo has to have elements.
182     if (streamToAppendTo.isEmpty() || byStream.isEmpty())
183         return true;
184 
185     // builder is the destination of blending fromSource and bySource. The stream of builder
186     // (i.e. streamToAppendTo) has to be cleared before calling addAnimatedPath.
187     SVGPathByteStreamBuilder builder(streamToAppendTo);
188 
189     SVGPathByteStream fromStreamCopy = WTFMove(streamToAppendTo);
190 
191     SVGPathByteStreamSource fromSource(fromStreamCopy);
192     SVGPathByteStreamSource bySource(byStream);
193     return SVGPathBlender::addAnimatedPath(fromSource, bySource, builder, repeatCount);
194 }
195 
<span class="line-modified">196 bool getSVGPathSegAtLengthFromSVGPathByteStream(const SVGPathByteStream&amp; stream, float length, unsigned&amp; pathSeg)</span>
197 {
198     if (stream.isEmpty())
<span class="line-modified">199         return false;</span>
200 
201     PathTraversalState traversalState(PathTraversalState::Action::SegmentAtLength);
202     SVGPathTraversalStateBuilder builder(traversalState, length);
203 
204     SVGPathByteStreamSource source(stream);
<span class="line-modified">205     bool ok = SVGPathParser::parse(source, builder);</span>
<span class="line-modified">206     pathSeg = builder.pathSegmentIndex();</span>
<span class="line-removed">207     return ok;</span>
208 }
209 
<span class="line-modified">210 bool getTotalLengthOfSVGPathByteStream(const SVGPathByteStream&amp; stream, float&amp; totalLength)</span>
211 {
212     if (stream.isEmpty())
<span class="line-modified">213         return false;</span>
214 
215     PathTraversalState traversalState(PathTraversalState::Action::TotalLength);
216 
217     SVGPathTraversalStateBuilder builder(traversalState);
218 
219     SVGPathByteStreamSource source(stream);
<span class="line-modified">220     bool ok = SVGPathParser::parse(source, builder);</span>
<span class="line-modified">221     totalLength = builder.totalLength();</span>
<span class="line-removed">222     return ok;</span>
223 }
224 
<span class="line-modified">225 bool getPointAtLengthOfSVGPathByteStream(const SVGPathByteStream&amp; stream, float length, FloatPoint&amp; point)</span>
226 {
227     if (stream.isEmpty())
<span class="line-modified">228         return false;</span>
229 
230     PathTraversalState traversalState(PathTraversalState::Action::VectorAtLength);
231 
232     SVGPathTraversalStateBuilder builder(traversalState, length);
233 
234     SVGPathByteStreamSource source(stream);
<span class="line-modified">235     bool ok = SVGPathParser::parse(source, builder);</span>
<span class="line-modified">236     point = builder.currentPoint();</span>
<span class="line-removed">237     return ok;</span>
238 }
239 
240 }
</pre>
</td>
<td>
<hr />
<pre>
 41 
 42 Path buildPathFromString(const String&amp; d)
 43 {
 44     if (d.isEmpty())
 45         return { };
 46 
 47     Path path;
 48     SVGPathBuilder builder(path);
 49     SVGPathStringSource source(d);
 50     SVGPathParser::parse(source, builder);
 51     return path;
 52 }
 53 
 54 String buildStringFromPath(const Path&amp; path)
 55 {
 56     StringBuilder builder;
 57 
 58     if (!path.isNull() &amp;&amp; !path.isEmpty()) {
 59         path.apply([&amp;builder] (const PathElement&amp; element) {
 60             switch (element.type) {
<span class="line-modified"> 61             case PathElement::Type::MoveToPoint:</span>
 62                 builder.append(&#39;M&#39;);
 63                 builder.appendNumber(element.points[0].x());
 64                 builder.append(&#39; &#39;);
 65                 builder.appendNumber(element.points[0].y());
 66                 break;
<span class="line-modified"> 67             case PathElement::Type::AddLineToPoint:</span>
 68                 builder.append(&#39;L&#39;);
 69                 builder.appendNumber(element.points[0].x());
 70                 builder.append(&#39; &#39;);
 71                 builder.appendNumber(element.points[0].y());
 72                 break;
<span class="line-modified"> 73             case PathElement::Type::AddQuadCurveToPoint:</span>
 74                 builder.append(&#39;Q&#39;);
 75                 builder.appendNumber(element.points[0].x());
 76                 builder.append(&#39; &#39;);
 77                 builder.appendNumber(element.points[0].y());
 78                 builder.append(&#39;,&#39;);
 79                 builder.appendNumber(element.points[1].x());
 80                 builder.append(&#39; &#39;);
 81                 builder.appendNumber(element.points[1].y());
 82                 break;
<span class="line-modified"> 83             case PathElement::Type::AddCurveToPoint:</span>
 84                 builder.append(&#39;C&#39;);
 85                 builder.appendNumber(element.points[0].x());
 86                 builder.append(&#39; &#39;);
 87                 builder.appendNumber(element.points[0].y());
 88                 builder.append(&#39;,&#39;);
 89                 builder.appendNumber(element.points[1].x());
 90                 builder.append(&#39; &#39;);
 91                 builder.appendNumber(element.points[1].y());
 92                 builder.append(&#39;,&#39;);
 93                 builder.appendNumber(element.points[2].x());
 94                 builder.append(&#39; &#39;);
 95                 builder.appendNumber(element.points[2].y());
 96                 break;
<span class="line-modified"> 97             case PathElement::Type::CloseSubpath:</span>
 98                 builder.append(&#39;Z&#39;);
 99                 break;
100             }
101         });
102     }
103 
104     return builder.toString();
105 }
106 
107 bool buildSVGPathByteStreamFromSVGPathSegList(const SVGPathSegList&amp; list, SVGPathByteStream&amp; stream, PathParsingMode parsingMode, bool checkForInitialMoveTo)
108 {
109     stream.clear();
110     if (list.isEmpty())
111         return true;
112 
113     SVGPathSegListSource source(list);
114     return SVGPathParser::parseToByteStream(source, stream, parsingMode, checkForInitialMoveTo);
115 }
116 
117 Path buildPathFromByteStream(const SVGPathByteStream&amp; stream)
</pre>
<hr />
<pre>
176     return SVGPathBlender::blendAnimatedPath(fromSource, toSource, builder, progress);
177 }
178 
179 bool addToSVGPathByteStream(SVGPathByteStream&amp; streamToAppendTo, const SVGPathByteStream&amp; byStream, unsigned repeatCount)
180 {
181     // The byStream will be blended with streamToAppendTo. So streamToAppendTo has to have elements.
182     if (streamToAppendTo.isEmpty() || byStream.isEmpty())
183         return true;
184 
185     // builder is the destination of blending fromSource and bySource. The stream of builder
186     // (i.e. streamToAppendTo) has to be cleared before calling addAnimatedPath.
187     SVGPathByteStreamBuilder builder(streamToAppendTo);
188 
189     SVGPathByteStream fromStreamCopy = WTFMove(streamToAppendTo);
190 
191     SVGPathByteStreamSource fromSource(fromStreamCopy);
192     SVGPathByteStreamSource bySource(byStream);
193     return SVGPathBlender::addAnimatedPath(fromSource, bySource, builder, repeatCount);
194 }
195 
<span class="line-modified">196 unsigned getSVGPathSegAtLengthFromSVGPathByteStream(const SVGPathByteStream&amp; stream, float length)</span>
197 {
198     if (stream.isEmpty())
<span class="line-modified">199         return 0;</span>
200 
201     PathTraversalState traversalState(PathTraversalState::Action::SegmentAtLength);
202     SVGPathTraversalStateBuilder builder(traversalState, length);
203 
204     SVGPathByteStreamSource source(stream);
<span class="line-modified">205     SVGPathParser::parse(source, builder);</span>
<span class="line-modified">206     return builder.pathSegmentIndex();</span>

207 }
208 
<span class="line-modified">209 float getTotalLengthOfSVGPathByteStream(const SVGPathByteStream&amp; stream)</span>
210 {
211     if (stream.isEmpty())
<span class="line-modified">212         return 0;</span>
213 
214     PathTraversalState traversalState(PathTraversalState::Action::TotalLength);
215 
216     SVGPathTraversalStateBuilder builder(traversalState);
217 
218     SVGPathByteStreamSource source(stream);
<span class="line-modified">219     SVGPathParser::parse(source, builder);</span>
<span class="line-modified">220     return builder.totalLength();</span>

221 }
222 
<span class="line-modified">223 FloatPoint getPointAtLengthOfSVGPathByteStream(const SVGPathByteStream&amp; stream, float length)</span>
224 {
225     if (stream.isEmpty())
<span class="line-modified">226         return { };</span>
227 
228     PathTraversalState traversalState(PathTraversalState::Action::VectorAtLength);
229 
230     SVGPathTraversalStateBuilder builder(traversalState, length);
231 
232     SVGPathByteStreamSource source(stream);
<span class="line-modified">233     SVGPathParser::parse(source, builder);</span>
<span class="line-modified">234     return builder.currentPoint();</span>

235 }
236 
237 }
</pre>
</td>
</tr>
</table>
<center><a href="SVGPathTraversalStateBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGPathUtilities.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
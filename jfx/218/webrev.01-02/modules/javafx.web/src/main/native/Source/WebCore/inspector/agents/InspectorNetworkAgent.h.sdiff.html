<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorNetworkAgent.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorNetworkAgent.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorPageAgent.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorNetworkAgent.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #pragma once
 33 
 34 #include &quot;InspectorInstrumentation.h&quot;
 35 #include &quot;InspectorPageAgent.h&quot;
 36 #include &quot;InspectorWebAgentBase.h&quot;
 37 #include &lt;JavaScriptCore/InspectorBackendDispatchers.h&gt;
 38 #include &lt;JavaScriptCore/InspectorFrontendDispatchers.h&gt;
 39 #include &lt;JavaScriptCore/RegularExpression.h&gt;
<span class="line-modified"> 40 #include &lt;wtf/HashSet.h&gt;</span>
 41 #include &lt;wtf/JSONValues.h&gt;
<span class="line-removed"> 42 #include &lt;wtf/text/WTFString.h&gt;</span>
 43 
 44 namespace Inspector {
 45 class InjectedScriptManager;
 46 }
 47 
 48 namespace WebCore {
 49 
 50 class CachedResource;
 51 class Document;
 52 class DocumentLoader;
 53 class DocumentThreadableLoader;
 54 class NetworkLoadMetrics;
 55 class NetworkResourcesData;
 56 class ResourceError;
 57 class ResourceLoader;
 58 class ResourceRequest;
 59 class ResourceResponse;
 60 class TextResourceDecoder;
 61 class WebSocket;
 62 
 63 struct WebSocketFrame;
 64 
 65 typedef String ErrorString;
 66 
 67 class InspectorNetworkAgent : public InspectorAgentBase, public Inspector::NetworkBackendDispatcherHandler {
 68     WTF_MAKE_NONCOPYABLE(InspectorNetworkAgent);
 69     WTF_MAKE_FAST_ALLOCATED;
 70 public:
<span class="line-modified"> 71     virtual ~InspectorNetworkAgent();</span>
 72 
 73     static bool shouldTreatAsText(const String&amp; mimeType);
 74     static Ref&lt;TextResourceDecoder&gt; createTextDecoder(const String&amp; mimeType, const String&amp; textEncodingName);
 75     static Optional&lt;String&gt; textContentForCachedResource(CachedResource&amp;);
 76     static bool cachedResourceContent(CachedResource&amp;, String* result, bool* base64Encoded);
 77 
 78     // InspectorAgentBase
 79     void didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*) final;
 80     void willDestroyFrontendAndBackend(Inspector::DisconnectReason) final;
 81 
 82     // NetworkBackendDispatcherHandler
 83     void enable(ErrorString&amp;) final;
 84     void disable(ErrorString&amp;) final;
 85     void setExtraHTTPHeaders(ErrorString&amp;, const JSON::Object&amp; headers) final;
 86     void getResponseBody(ErrorString&amp;, const String&amp; requestId, String* content, bool* base64Encoded) final;
 87     void setResourceCachingDisabled(ErrorString&amp;, bool disabled) final;
 88     void loadResource(const String&amp; frameId, const String&amp; url, Ref&lt;LoadResourceCallback&gt;&amp;&amp;) final;
 89     void getSerializedCertificate(ErrorString&amp;, const String&amp; requestId, String* serializedCertificate) final;
 90     void resolveWebSocket(ErrorString&amp;, const String&amp; requestId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp;) final;





 91 
 92     // InspectorInstrumentation
 93     void willRecalculateStyle();
 94     void didRecalculateStyle();
 95     void willSendRequest(unsigned long identifier, DocumentLoader*, ResourceRequest&amp;, const ResourceResponse&amp; redirectResponse);
 96     void willSendRequestOfType(unsigned long identifier, DocumentLoader*, ResourceRequest&amp;, InspectorInstrumentation::LoadType);
 97     void didReceiveResponse(unsigned long identifier, DocumentLoader*, const ResourceResponse&amp;, ResourceLoader*);
 98     void didReceiveData(unsigned long identifier, const char* data, int dataLength, int encodedDataLength);
 99     void didFinishLoading(unsigned long identifier, DocumentLoader*, const NetworkLoadMetrics&amp;, ResourceLoader*);
100     void didFailLoading(unsigned long identifier, DocumentLoader*, const ResourceError&amp;);
101     void didLoadResourceFromMemoryCache(DocumentLoader*, CachedResource&amp;);
102     void didReceiveThreadableLoaderResponse(unsigned long identifier, DocumentThreadableLoader&amp;);
103     void willLoadXHRSynchronously();
104     void didLoadXHRSynchronously();
105     void didReceiveScriptResponse(unsigned long identifier);
106     void willDestroyCachedResource(CachedResource&amp;);
107     void didCreateWebSocket(unsigned long identifier, const URL&amp; requestURL);
108     void willSendWebSocketHandshakeRequest(unsigned long identifier, const ResourceRequest&amp;);
109     void didReceiveWebSocketHandshakeResponse(unsigned long identifier, const ResourceResponse&amp;);
110     void didCloseWebSocket(unsigned long identifier);
111     void didReceiveWebSocketFrame(unsigned long identifier, const WebSocketFrame&amp;);
112     void didSendWebSocketFrame(unsigned long identifier, const WebSocketFrame&amp;);
113     void didReceiveWebSocketFrameError(unsigned long identifier, const String&amp;);
114     void mainFrameNavigated(DocumentLoader&amp;);
115     void setInitialScriptContent(unsigned long identifier, const String&amp; sourceString);
116     void didScheduleStyleRecalculation(Document&amp;);



117 
118     void searchOtherRequests(const JSC::Yarr::RegularExpression&amp;, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::SearchResult&gt;&gt;&amp;);
119     void searchInRequest(ErrorString&amp;, const String&amp; requestId, const String&amp; query, bool caseSensitive, bool isRegex, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::GenericTypes::SearchMatch&gt;&gt;&amp;);
120 
121 protected:
122     InspectorNetworkAgent(WebAgentContext&amp;);
123 
124     virtual String loaderIdentifier(DocumentLoader*) = 0;
125     virtual String frameIdentifier(DocumentLoader*) = 0;
126     virtual Vector&lt;WebSocket*&gt; activeWebSockets(const LockHolder&amp;) = 0;
127     virtual void setResourceCachingDisabled(bool) = 0;
128     virtual ScriptExecutionContext* scriptExecutionContext(ErrorString&amp;, const String&amp; frameId) = 0;
129     virtual bool shouldForceBufferingNetworkResourceData() const = 0;
130 
131 private:
132     void enable();
133 
134     void willSendRequest(unsigned long identifier, DocumentLoader*, ResourceRequest&amp;, const ResourceResponse&amp; redirectResponse, InspectorPageAgent::ResourceType);
135 



136     WebSocket* webSocketForRequestId(const String&amp; requestId);
137 
138     RefPtr&lt;Inspector::Protocol::Network::Initiator&gt; buildInitiatorObject(Document*, Optional&lt;const ResourceRequest&amp;&gt; = WTF::nullopt);
139     Ref&lt;Inspector::Protocol::Network::ResourceTiming&gt; buildObjectForTiming(const NetworkLoadMetrics&amp;, ResourceLoader&amp;);
140     Ref&lt;Inspector::Protocol::Network::Metrics&gt; buildObjectForMetrics(const NetworkLoadMetrics&amp;);
141     RefPtr&lt;Inspector::Protocol::Network::Response&gt; buildObjectForResourceResponse(const ResourceResponse&amp;, ResourceLoader*);
142     Ref&lt;Inspector::Protocol::Network::CachedResource&gt; buildObjectForCachedResource(CachedResource*);
143 
144     double timestamp();
145 






































146     std::unique_ptr&lt;Inspector::NetworkFrontendDispatcher&gt; m_frontendDispatcher;
147     RefPtr&lt;Inspector::NetworkBackendDispatcher&gt; m_backendDispatcher;
148     Inspector::InjectedScriptManager&amp; m_injectedScriptManager;
149 




















150     // FIXME: InspectorNetworkAgent should not be aware of style recalculation.
151     RefPtr&lt;Inspector::Protocol::Network::Initiator&gt; m_styleRecalculationInitiator;
152     bool m_isRecalculatingStyle { false };
153 
<span class="line-removed">154     std::unique_ptr&lt;NetworkResourcesData&gt; m_resourcesData;</span>
155     bool m_enabled { false };
156     bool m_loadingXHRSynchronously { false };
<span class="line-modified">157     HashMap&lt;String, String&gt; m_extraRequestHeaders;</span>
<span class="line-removed">158     HashSet&lt;unsigned long&gt; m_hiddenRequestIdentifiers;</span>
159 };
160 
161 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #pragma once
 33 
 34 #include &quot;InspectorInstrumentation.h&quot;
 35 #include &quot;InspectorPageAgent.h&quot;
 36 #include &quot;InspectorWebAgentBase.h&quot;
 37 #include &lt;JavaScriptCore/InspectorBackendDispatchers.h&gt;
 38 #include &lt;JavaScriptCore/InspectorFrontendDispatchers.h&gt;
 39 #include &lt;JavaScriptCore/RegularExpression.h&gt;
<span class="line-modified"> 40 #include &lt;wtf/Forward.h&gt;</span>
 41 #include &lt;wtf/JSONValues.h&gt;

 42 
 43 namespace Inspector {
 44 class InjectedScriptManager;
 45 }
 46 
 47 namespace WebCore {
 48 
 49 class CachedResource;
 50 class Document;
 51 class DocumentLoader;
 52 class DocumentThreadableLoader;
 53 class NetworkLoadMetrics;
 54 class NetworkResourcesData;
 55 class ResourceError;
 56 class ResourceLoader;
 57 class ResourceRequest;
 58 class ResourceResponse;
 59 class TextResourceDecoder;
 60 class WebSocket;
 61 
 62 struct WebSocketFrame;
 63 
 64 typedef String ErrorString;
 65 
 66 class InspectorNetworkAgent : public InspectorAgentBase, public Inspector::NetworkBackendDispatcherHandler {
 67     WTF_MAKE_NONCOPYABLE(InspectorNetworkAgent);
 68     WTF_MAKE_FAST_ALLOCATED;
 69 public:
<span class="line-modified"> 70     ~InspectorNetworkAgent() override;</span>
 71 
 72     static bool shouldTreatAsText(const String&amp; mimeType);
 73     static Ref&lt;TextResourceDecoder&gt; createTextDecoder(const String&amp; mimeType, const String&amp; textEncodingName);
 74     static Optional&lt;String&gt; textContentForCachedResource(CachedResource&amp;);
 75     static bool cachedResourceContent(CachedResource&amp;, String* result, bool* base64Encoded);
 76 
 77     // InspectorAgentBase
 78     void didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*) final;
 79     void willDestroyFrontendAndBackend(Inspector::DisconnectReason) final;
 80 
 81     // NetworkBackendDispatcherHandler
 82     void enable(ErrorString&amp;) final;
 83     void disable(ErrorString&amp;) final;
 84     void setExtraHTTPHeaders(ErrorString&amp;, const JSON::Object&amp; headers) final;
 85     void getResponseBody(ErrorString&amp;, const String&amp; requestId, String* content, bool* base64Encoded) final;
 86     void setResourceCachingDisabled(ErrorString&amp;, bool disabled) final;
 87     void loadResource(const String&amp; frameId, const String&amp; url, Ref&lt;LoadResourceCallback&gt;&amp;&amp;) final;
 88     void getSerializedCertificate(ErrorString&amp;, const String&amp; requestId, String* serializedCertificate) final;
 89     void resolveWebSocket(ErrorString&amp;, const String&amp; requestId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp;) final;
<span class="line-added"> 90     void setInterceptionEnabled(ErrorString&amp;, bool enabled) final;</span>
<span class="line-added"> 91     void addInterception(ErrorString&amp;, const String&amp; url, const bool* caseSensitive, const bool* isRegex, const String* networkStageString) final;</span>
<span class="line-added"> 92     void removeInterception(ErrorString&amp;, const String&amp; url, const bool* caseSensitive, const bool* isRegex, const String* networkStageString) final;</span>
<span class="line-added"> 93     void interceptContinue(ErrorString&amp;, const String&amp; requestId) final;</span>
<span class="line-added"> 94     void interceptWithResponse(ErrorString&amp;, const String&amp; requestId, const String&amp; content, bool base64Encoded, const String* mimeType, const int* status, const String* statusText, const JSON::Object* headers) final;</span>
 95 
 96     // InspectorInstrumentation
 97     void willRecalculateStyle();
 98     void didRecalculateStyle();
 99     void willSendRequest(unsigned long identifier, DocumentLoader*, ResourceRequest&amp;, const ResourceResponse&amp; redirectResponse);
100     void willSendRequestOfType(unsigned long identifier, DocumentLoader*, ResourceRequest&amp;, InspectorInstrumentation::LoadType);
101     void didReceiveResponse(unsigned long identifier, DocumentLoader*, const ResourceResponse&amp;, ResourceLoader*);
102     void didReceiveData(unsigned long identifier, const char* data, int dataLength, int encodedDataLength);
103     void didFinishLoading(unsigned long identifier, DocumentLoader*, const NetworkLoadMetrics&amp;, ResourceLoader*);
104     void didFailLoading(unsigned long identifier, DocumentLoader*, const ResourceError&amp;);
105     void didLoadResourceFromMemoryCache(DocumentLoader*, CachedResource&amp;);
106     void didReceiveThreadableLoaderResponse(unsigned long identifier, DocumentThreadableLoader&amp;);
107     void willLoadXHRSynchronously();
108     void didLoadXHRSynchronously();
109     void didReceiveScriptResponse(unsigned long identifier);
110     void willDestroyCachedResource(CachedResource&amp;);
111     void didCreateWebSocket(unsigned long identifier, const URL&amp; requestURL);
112     void willSendWebSocketHandshakeRequest(unsigned long identifier, const ResourceRequest&amp;);
113     void didReceiveWebSocketHandshakeResponse(unsigned long identifier, const ResourceResponse&amp;);
114     void didCloseWebSocket(unsigned long identifier);
115     void didReceiveWebSocketFrame(unsigned long identifier, const WebSocketFrame&amp;);
116     void didSendWebSocketFrame(unsigned long identifier, const WebSocketFrame&amp;);
117     void didReceiveWebSocketFrameError(unsigned long identifier, const String&amp;);
118     void mainFrameNavigated(DocumentLoader&amp;);
119     void setInitialScriptContent(unsigned long identifier, const String&amp; sourceString);
120     void didScheduleStyleRecalculation(Document&amp;);
<span class="line-added">121     bool willInterceptRequest(const ResourceRequest&amp;);</span>
<span class="line-added">122     bool shouldInterceptResponse(const ResourceResponse&amp;);</span>
<span class="line-added">123     void interceptResponse(const ResourceResponse&amp;, unsigned long identifier, CompletionHandler&lt;void(const ResourceResponse&amp;, RefPtr&lt;SharedBuffer&gt;)&gt;&amp;&amp;);</span>
124 
125     void searchOtherRequests(const JSC::Yarr::RegularExpression&amp;, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::SearchResult&gt;&gt;&amp;);
126     void searchInRequest(ErrorString&amp;, const String&amp; requestId, const String&amp; query, bool caseSensitive, bool isRegex, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::GenericTypes::SearchMatch&gt;&gt;&amp;);
127 
128 protected:
129     InspectorNetworkAgent(WebAgentContext&amp;);
130 
131     virtual String loaderIdentifier(DocumentLoader*) = 0;
132     virtual String frameIdentifier(DocumentLoader*) = 0;
133     virtual Vector&lt;WebSocket*&gt; activeWebSockets(const LockHolder&amp;) = 0;
134     virtual void setResourceCachingDisabled(bool) = 0;
135     virtual ScriptExecutionContext* scriptExecutionContext(ErrorString&amp;, const String&amp; frameId) = 0;
136     virtual bool shouldForceBufferingNetworkResourceData() const = 0;
137 
138 private:
139     void enable();
140 
141     void willSendRequest(unsigned long identifier, DocumentLoader*, ResourceRequest&amp;, const ResourceResponse&amp; redirectResponse, InspectorPageAgent::ResourceType);
142 
<span class="line-added">143     bool shouldIntercept(URL);</span>
<span class="line-added">144     void continuePendingResponses();</span>
<span class="line-added">145 </span>
146     WebSocket* webSocketForRequestId(const String&amp; requestId);
147 
148     RefPtr&lt;Inspector::Protocol::Network::Initiator&gt; buildInitiatorObject(Document*, Optional&lt;const ResourceRequest&amp;&gt; = WTF::nullopt);
149     Ref&lt;Inspector::Protocol::Network::ResourceTiming&gt; buildObjectForTiming(const NetworkLoadMetrics&amp;, ResourceLoader&amp;);
150     Ref&lt;Inspector::Protocol::Network::Metrics&gt; buildObjectForMetrics(const NetworkLoadMetrics&amp;);
151     RefPtr&lt;Inspector::Protocol::Network::Response&gt; buildObjectForResourceResponse(const ResourceResponse&amp;, ResourceLoader*);
152     Ref&lt;Inspector::Protocol::Network::CachedResource&gt; buildObjectForCachedResource(CachedResource*);
153 
154     double timestamp();
155 
<span class="line-added">156     class PendingInterceptResponse {</span>
<span class="line-added">157         WTF_MAKE_NONCOPYABLE(PendingInterceptResponse);</span>
<span class="line-added">158         WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-added">159     public:</span>
<span class="line-added">160         PendingInterceptResponse(const ResourceResponse&amp; originalResponse, CompletionHandler&lt;void(const ResourceResponse&amp;, RefPtr&lt;SharedBuffer&gt;)&gt;&amp;&amp; completionHandler)</span>
<span class="line-added">161             : m_originalResponse(originalResponse)</span>
<span class="line-added">162             , m_completionHandler(WTFMove(completionHandler))</span>
<span class="line-added">163         { }</span>
<span class="line-added">164 </span>
<span class="line-added">165         ~PendingInterceptResponse()</span>
<span class="line-added">166         {</span>
<span class="line-added">167             ASSERT(m_responded);</span>
<span class="line-added">168         }</span>
<span class="line-added">169 </span>
<span class="line-added">170         ResourceResponse originalResponse() { return m_originalResponse; }</span>
<span class="line-added">171 </span>
<span class="line-added">172         void respondWithOriginalResponse()</span>
<span class="line-added">173         {</span>
<span class="line-added">174             respond(m_originalResponse, nullptr);</span>
<span class="line-added">175         }</span>
<span class="line-added">176 </span>
<span class="line-added">177         void respond(const ResourceResponse&amp; response, RefPtr&lt;SharedBuffer&gt; data)</span>
<span class="line-added">178         {</span>
<span class="line-added">179             ASSERT(!m_responded);</span>
<span class="line-added">180             if (m_responded)</span>
<span class="line-added">181                 return;</span>
<span class="line-added">182 </span>
<span class="line-added">183             m_responded = true;</span>
<span class="line-added">184 </span>
<span class="line-added">185             m_completionHandler(response, data);</span>
<span class="line-added">186         }</span>
<span class="line-added">187 </span>
<span class="line-added">188     private:</span>
<span class="line-added">189         ResourceResponse m_originalResponse;</span>
<span class="line-added">190         CompletionHandler&lt;void(const ResourceResponse&amp;, RefPtr&lt;SharedBuffer&gt;)&gt; m_completionHandler;</span>
<span class="line-added">191         bool m_responded { false };</span>
<span class="line-added">192     };</span>
<span class="line-added">193 </span>
194     std::unique_ptr&lt;Inspector::NetworkFrontendDispatcher&gt; m_frontendDispatcher;
195     RefPtr&lt;Inspector::NetworkBackendDispatcher&gt; m_backendDispatcher;
196     Inspector::InjectedScriptManager&amp; m_injectedScriptManager;
197 
<span class="line-added">198     std::unique_ptr&lt;NetworkResourcesData&gt; m_resourcesData;</span>
<span class="line-added">199 </span>
<span class="line-added">200     HashMap&lt;String, String&gt; m_extraRequestHeaders;</span>
<span class="line-added">201     HashSet&lt;unsigned long&gt; m_hiddenRequestIdentifiers;</span>
<span class="line-added">202 </span>
<span class="line-added">203     struct Intercept {</span>
<span class="line-added">204         String url;</span>
<span class="line-added">205         bool caseSensitive { true };</span>
<span class="line-added">206         bool isRegex { false };</span>
<span class="line-added">207 </span>
<span class="line-added">208         inline bool operator==(const Intercept&amp; other) const</span>
<span class="line-added">209         {</span>
<span class="line-added">210             return url == other.url</span>
<span class="line-added">211                 &amp;&amp; caseSensitive == other.caseSensitive</span>
<span class="line-added">212                 &amp;&amp; isRegex == other.isRegex;</span>
<span class="line-added">213         }</span>
<span class="line-added">214     };</span>
<span class="line-added">215     Vector&lt;Intercept&gt; m_intercepts;</span>
<span class="line-added">216     HashMap&lt;String, std::unique_ptr&lt;PendingInterceptResponse&gt;&gt; m_pendingInterceptResponses;</span>
<span class="line-added">217 </span>
218     // FIXME: InspectorNetworkAgent should not be aware of style recalculation.
219     RefPtr&lt;Inspector::Protocol::Network::Initiator&gt; m_styleRecalculationInitiator;
220     bool m_isRecalculatingStyle { false };
221 

222     bool m_enabled { false };
223     bool m_loadingXHRSynchronously { false };
<span class="line-modified">224     bool m_interceptionEnabled { false };</span>

225 };
226 
227 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="InspectorNetworkAgent.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorPageAgent.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
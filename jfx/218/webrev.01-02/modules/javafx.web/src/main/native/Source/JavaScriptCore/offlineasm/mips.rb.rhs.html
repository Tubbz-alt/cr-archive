<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/mips.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 # Copyright (C) 2012-2018 Apple Inc. All rights reserved.
   2 # Copyright (C) 2012 MIPS Technologies, Inc. All rights reserved.
   3 #
   4 # Redistribution and use in source and binary forms, with or without
   5 # modification, are permitted provided that the following conditions
   6 # are met:
   7 # 1. Redistributions of source code must retain the above copyright
   8 #    notice, this list of conditions and the following disclaimer.
   9 # 2. Redistributions in binary form must reproduce the above copyright
  10 #    notice, this list of conditions and the following disclaimer in the
  11 #    documentation and/or other materials provided with the distribution.
  12 #
  13 # THIS SOFTWARE IS PROVIDED BY MIPS TECHNOLOGIES, INC. ``AS IS&#39;&#39; AND ANY
  14 # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15 # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16 # PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL MIPS TECHNOLOGIES, INC. OR
  17 # CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18 # EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19 # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20 # PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21 # OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24 
  25 require &#39;risc&#39;
  26 
  27 # GPR conventions, to match the baseline JIT
  28 #
  29 # $a0 =&gt; a0, t7
  30 # $a1 =&gt; a1, t8
  31 # $a2 =&gt; a2, t9
  32 # $a3 =&gt; a3, t10
  33 # $v0 =&gt; t0, r0
  34 # $v1 =&gt; t1, r1
  35 # $t0 =&gt;            (scratch)
  36 # $t1 =&gt;            (scratch)
  37 # $t2 =&gt;         t2
  38 # $t3 =&gt;         t3
  39 # $t4 =&gt;         t4
  40 # $t5 =&gt;         t5
  41 # $t6 =&gt;         t6
  42 # $t7 =&gt;            (scratch)
  43 # $t8 =&gt;            (scratch)
  44 # $t9 =&gt;            (stores the callee of a call opcode)
  45 # $gp =&gt;            (globals)
<a name="1" id="anc1"></a><span class="line-added">  46 # $s0 =&gt; csr0       (callee-save, metadataTable)</span>
<span class="line-added">  47 # $s1 =&gt; csr1       (callee-save, PB)</span>
  48 # $s4 =&gt;            (callee-save used to preserve $gp across calls)
  49 # $ra =&gt; lr
  50 # $sp =&gt; sp
  51 # $fp =&gt; cfr
  52 #
  53 # FPR conventions, to match the baseline JIT
  54 # We don&#39;t have fa2 or fa3!
  55 #  $f0 =&gt; ft0, fr
  56 #  $f2 =&gt; ft1
  57 #  $f4 =&gt; ft2
  58 #  $f6 =&gt; ft3
  59 #  $f8 =&gt; ft4
  60 # $f10 =&gt; ft5
  61 # $f12 =&gt;        fa0
  62 # $f14 =&gt;        fa1
  63 # $f16 =&gt;            (scratch)
  64 # $f18 =&gt;            (scratch)
  65 
  66 class Assembler
  67     def putStr(str)
  68         @outp.puts str
  69     end
  70 end
  71 
  72 class Node
  73     def mipsSingleHi
  74         doubleOperand = mipsOperand
  75         raise &quot;Bogus register name #{doubleOperand}&quot; unless doubleOperand =~ /^\$f/
  76         &quot;$f&quot; + ($~.post_match.to_i + 1).to_s
  77     end
  78     def mipsSingleLo
  79         doubleOperand = mipsOperand
  80         raise &quot;Bogus register name #{doubleOperand}&quot; unless doubleOperand =~ /^\$f/
  81         doubleOperand
  82     end
  83 end
  84 
  85 class SpecialRegister &lt; NoChildren
  86     def mipsOperand
  87         @name
  88     end
  89 
  90     def dump
  91         @name
  92     end
  93 
  94     def register?
  95         true
  96     end
  97 end
  98 
  99 MIPS_TEMP_GPRS = [SpecialRegister.new(&quot;$t0&quot;), SpecialRegister.new(&quot;$t1&quot;), SpecialRegister.new(&quot;$t7&quot;), SpecialRegister.new(&quot;$t8&quot;)]
 100 MIPS_ZERO_REG = SpecialRegister.new(&quot;$zero&quot;)
 101 MIPS_GP_REG = SpecialRegister.new(&quot;$gp&quot;)
 102 MIPS_GPSAVE_REG = SpecialRegister.new(&quot;$s4&quot;)
 103 MIPS_CALL_REG = SpecialRegister.new(&quot;$t9&quot;)
<a name="2" id="anc2"></a><span class="line-added"> 104 MIPS_RETURN_ADDRESS_REG = SpecialRegister.new(&quot;$ra&quot;)</span>
 105 MIPS_TEMP_FPRS = [SpecialRegister.new(&quot;$f16&quot;)]
 106 MIPS_SCRATCH_FPR = SpecialRegister.new(&quot;$f18&quot;)
 107 
 108 def mipsMoveImmediate(value, register)
 109     if value == 0
 110         $asm.puts &quot;add #{register.mipsOperand}, $zero, $zero&quot;
 111     else
 112         $asm.puts &quot;li #{register.mipsOperand}, #{value}&quot;
 113     end
 114 end
 115 
 116 class RegisterID
 117     def mipsOperand
 118         case name
 119         when &quot;a0&quot;, &quot;t7&quot;
 120             &quot;$a0&quot;
 121         when &quot;a1&quot;, &quot;t8&quot;
 122             &quot;$a1&quot;
 123         when &quot;a2&quot;, &quot;t9&quot;
 124             &quot;$a2&quot;
 125         when &quot;a3&quot;, &quot;t10&quot;
 126             &quot;$a3&quot;
 127         when &quot;t0&quot;, &quot;r0&quot;
 128             &quot;$v0&quot;
 129         when &quot;t1&quot;, &quot;r1&quot;
 130             &quot;$v1&quot;
 131         when &quot;t2&quot;
 132             &quot;$t2&quot;
 133         when &quot;t3&quot;
 134             &quot;$t3&quot;
 135         when &quot;t4&quot;
 136             &quot;$t4&quot;
 137         when &quot;t5&quot;
 138             &quot;$t5&quot;
 139         when &quot;cfr&quot;
 140             &quot;$fp&quot;
 141         when &quot;csr0&quot;
 142             &quot;$s0&quot;
<a name="3" id="anc3"></a><span class="line-added"> 143         when &quot;csr1&quot;</span>
<span class="line-added"> 144             &quot;$s1&quot;</span>
 145         when &quot;lr&quot;
 146             &quot;$ra&quot;
 147         when &quot;sp&quot;
 148             &quot;$sp&quot;
 149         else
 150             raise &quot;Bad register #{name} for MIPS at #{codeOriginString}&quot;
 151         end
 152     end
 153 end
 154 
 155 class FPRegisterID
 156     def mipsOperand
 157         case name
 158         when &quot;ft0&quot;, &quot;fr&quot;
 159             &quot;$f0&quot;
 160         when &quot;ft1&quot;
 161             &quot;$f2&quot;
 162         when &quot;ft2&quot;
 163             &quot;$f4&quot;
 164         when &quot;ft3&quot;
 165             &quot;$f6&quot;
 166         when &quot;ft4&quot;
 167             &quot;$f8&quot;
 168         when &quot;ft5&quot;
 169             &quot;$f10&quot;
 170         when &quot;fa0&quot;
 171             &quot;$f12&quot;
 172         when &quot;fa1&quot;
 173             &quot;$f14&quot;
 174         else
 175             raise &quot;Bad register #{name} for MIPS at #{codeOriginString}&quot;
 176         end
 177     end
 178 end
 179 
 180 class Immediate
 181     def mipsOperand
 182         raise &quot;Invalid immediate #{value} at #{codeOriginString}&quot; if value &lt; -0x7fff or value &gt; 0xffff
 183         &quot;#{value}&quot;
 184     end
 185 end
 186 
 187 class Address
 188     def mipsOperand
 189         raise &quot;Bad offset at #{codeOriginString}&quot; if offset.value &lt; -0x7fff or offset.value &gt; 0x7fff
 190         &quot;#{offset.value}(#{base.mipsOperand})&quot;
 191     end
 192 end
 193 
 194 class AbsoluteAddress
 195     def mipsOperand
 196         raise &quot;Unconverted absolute address at #{codeOriginString}&quot;
 197     end
 198 end
 199 
 200 #
 201 # Negate condition of branches to labels.
 202 #
 203 
 204 class Instruction
 205     def mipsNegateCondition(list)
 206         /^(b(add|sub|or|mul|t)?)([ipb])/.match(opcode)
 207         case $~.post_match
 208         when &quot;eq&quot;
 209             op = &quot;neq&quot;
 210         when &quot;neq&quot;
 211             op = &quot;eq&quot;
 212         when &quot;z&quot;
 213             op = &quot;nz&quot;
 214         when &quot;nz&quot;
 215             op = &quot;z&quot;
 216         when &quot;gt&quot;
 217             op = &quot;lteq&quot;
 218         when &quot;gteq&quot;
 219             op = &quot;lt&quot;
 220         when &quot;lt&quot;
 221             op = &quot;gteq&quot;
 222         when &quot;lteq&quot;
 223             op = &quot;gt&quot;
 224         when &quot;a&quot;
 225             op = &quot;beq&quot;
 226         when &quot;b&quot;
 227             op = &quot;aeq&quot;
 228         when &quot;aeq&quot;
 229             op = &quot;b&quot;
 230         when &quot;beq&quot;
 231             op = &quot;a&quot;
 232         else
 233             raise &quot;Can&#39;t negate #{opcode} branch.&quot;
 234         end
 235         noBranch = LocalLabel.unique(&quot;nobranch&quot;)
 236         noBranchRef = LocalLabelReference.new(codeOrigin, noBranch)
 237         toRef = operands[-1]
 238         list &lt;&lt; Instruction.new(codeOrigin, &quot;#{$1}#{$3}#{op}&quot;, operands[0..-2].push(noBranchRef), annotation)
 239         list &lt;&lt; Instruction.new(codeOrigin, &quot;la&quot;, [toRef, MIPS_CALL_REG])
 240         list &lt;&lt; Instruction.new(codeOrigin, &quot;jmp&quot;, [MIPS_CALL_REG])
 241         list &lt;&lt; noBranch
 242     end
 243 end
 244 
 245 def mipsLowerFarBranchOps(list)
 246     newList = []
 247     list.each {
 248         | node |
 249         if node.is_a? Instruction
 250             annotation = node.annotation
 251             case node.opcode
 252             when /^b(add|sub|or|mul|t)?([ipb])/
 253                 if node.operands[-1].is_a? LabelReference
 254                     node.mipsNegateCondition(newList)
 255                     next
 256                 end
 257             end
 258         end
 259         newList &lt;&lt; node
 260     }
 261     newList
 262 end
 263 
 264 #
 265 # Lower &#39;and&#39; masked branches
 266 #
 267 
 268 def lowerMIPSCondBranch(list, condOp, node)
 269     if node.operands.size == 2
 270         list &lt;&lt; Instruction.new(node.codeOrigin,
 271                                 condOp,
 272                                 [node.operands[0], MIPS_ZERO_REG, node.operands[-1]],
 273                                 node.annotation)
 274     elsif node.operands.size == 3
 275         tl = condOp[-1, 1]
 276         tmp = Tmp.new(node.codeOrigin, :gpr)
 277         list &lt;&lt; Instruction.new(node.codeOrigin,
 278                                 &quot;and&quot; + tl,
 279                                 [node.operands[0], node.operands[1], tmp],
 280                                 node.annotation)
 281         list &lt;&lt; Instruction.new(node.codeOrigin,
 282                                 condOp,
 283                                 [tmp, MIPS_ZERO_REG, node.operands[-1]])
 284     else
 285         raise &quot;Expected 2 or 3 operands but got #{node.operands.size} at #{node.codeOriginString}&quot;
 286     end
 287 end
 288 
 289 #
 290 # Lowering of branch ops. For example:
 291 #
 292 # baddiz foo, bar, baz
 293 #
 294 # will become:
 295 #
 296 # addi foo, bar
 297 # bz baz
 298 #
 299 
 300 def mipsLowerSimpleBranchOps(list)
 301     newList = []
 302     list.each {
 303         | node |
 304         if node.is_a? Instruction
 305             annotation = node.annotation
 306             case node.opcode
 307             when /^b(addi|subi|ori|addp)/
 308                 op = $1
 309                 bc = $~.post_match
 310                 branch = &quot;b&quot; + bc
 311 
 312                 case op
 313                 when &quot;addi&quot;, &quot;addp&quot;
 314                     op = &quot;addi&quot;
 315                 when &quot;subi&quot;
 316                     op = &quot;subi&quot;
 317                 when &quot;ori&quot;
 318                     op = &quot;ori&quot;
 319                 end
 320 
 321                 if bc == &quot;o&quot;
 322                     case op
 323                     when &quot;addi&quot;
 324                         #  addu $s0, $s1, $s2
 325                         #  xor $t0, $s1, $s2
 326                         #  blt $t0, $zero, no overflow
 327                         #  xor $t0, $s0, $s1
 328                         #  blt $t0, $zero, overflow
 329                         # no overflow:
 330                         #
 331                         tr = Tmp.new(node.codeOrigin, :gpr)
 332                         tmp = Tmp.new(node.codeOrigin, :gpr)
 333                         noFlow = LocalLabel.unique(&quot;noflow&quot;)
 334                         noFlowRef = LocalLabelReference.new(node.codeOrigin, noFlow)
 335                         newList &lt;&lt; Instruction.new(node.codeOrigin, op, [node.operands[0], node.operands[1], tr], annotation)
 336                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;xori&quot;, [node.operands[0], node.operands[1], tmp])
 337                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;bilt&quot;, [tmp, MIPS_ZERO_REG, noFlowRef])
 338                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;xori&quot;, [tr, node.operands[0], tmp])
 339                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;bilt&quot;, [tmp, MIPS_ZERO_REG, node.operands[2]])
 340                         newList &lt;&lt; noFlow
 341                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;move&quot;, [tr, node.operands[1]])
 342                     when &quot;subi&quot;
 343                         #  subu $s0, $s1, $s2
 344                         #  xor $t0, $s1, $s2
 345                         #  bge $t0, $zero, no overflow
 346                         #  xor $t0, $s0, $s1
 347                         #  blt $t0, $zero, overflow
 348                         # no overflow:
 349                         #
 350                         tr = Tmp.new(node.codeOrigin, :gpr)
 351                         tmp = Tmp.new(node.codeOrigin, :gpr)
 352                         noFlow = LocalLabel.unique(&quot;noflow&quot;)
 353                         noFlowRef = LocalLabelReference.new(node.codeOrigin, noFlow)
 354                         newList &lt;&lt; Instruction.new(node.codeOrigin, op, [node.operands[1], node.operands[0], tr], annotation)
 355                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;xori&quot;, [node.operands[1], node.operands[0], tmp])
 356                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;bigteq&quot;, [tmp, MIPS_ZERO_REG, noFlowRef])
 357                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;xori&quot;, [tr, node.operands[1], tmp])
 358                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;bilt&quot;, [tmp, MIPS_ZERO_REG, node.operands[2]])
 359                         newList &lt;&lt; noFlow
 360                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;move&quot;, [tr, node.operands[1]])
 361                     when &quot;ori&quot;
 362                         # no ovwerflow at ori
 363                         newList &lt;&lt; Instruction.new(node.codeOrigin, op, node.operands[0..1], annotation)
 364                     end
 365                 else
 366                     if node.operands[1].is_a? Address
 367                         addr = node.operands[1]
 368                         tr = Tmp.new(node.codeOrigin, :gpr)
 369                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;loadp&quot;, [addr, tr], annotation)
 370                         newList &lt;&lt; Instruction.new(node.codeOrigin, op, [node.operands[0], tr])
 371                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;storep&quot;, [tr, addr])
 372                     else
 373                         tr = node.operands[1]
 374                         newList &lt;&lt; Instruction.new(node.codeOrigin, op, node.operands[0..-2], annotation)
 375                     end
 376                     newList &lt;&lt; Instruction.new(node.codeOrigin, branch, [tr, MIPS_ZERO_REG, node.operands[-1]])
 377                 end
 378             when &quot;bia&quot;, &quot;bpa&quot;, &quot;bba&quot;
 379                 tmp = Tmp.new(node.codeOrigin, :gpr)
 380                 comp = node.opcode[1] == ?b ? &quot;sltub&quot; : &quot;sltu&quot;
 381                 newList &lt;&lt; Instruction.new(node.codeOrigin, comp, [tmp, node.operands[1], node.operands[0]], annotation)
 382                 newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;bnz&quot;, [tmp, MIPS_ZERO_REG, node.operands[2]])
 383             when &quot;biaeq&quot;, &quot;bpaeq&quot;, &quot;bbaeq&quot;
 384                 tmp = Tmp.new(node.codeOrigin, :gpr)
 385                 comp = node.opcode[1] == ?b ? &quot;sltub&quot; : &quot;sltu&quot;
 386                 newList &lt;&lt; Instruction.new(node.codeOrigin, comp, [tmp, node.operands[0], node.operands[1]], annotation)
 387                 newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;bz&quot;, [tmp, MIPS_ZERO_REG, node.operands[2]])
 388             when &quot;bib&quot;, &quot;bpb&quot;, &quot;bbb&quot;
 389                 tmp = Tmp.new(node.codeOrigin, :gpr)
 390                 comp = node.opcode[1] == ?b ? &quot;sltub&quot; : &quot;sltu&quot;
 391                 newList &lt;&lt; Instruction.new(node.codeOrigin, comp, [tmp, node.operands[0], node.operands[1]], annotation)
 392                 newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;bnz&quot;, [tmp, MIPS_ZERO_REG, node.operands[2]])
 393             when &quot;bibeq&quot;, &quot;bpbeq&quot;, &quot;bbbeq&quot;
 394                 tmp = Tmp.new(node.codeOrigin, :gpr)
 395                 comp = node.opcode[1] == ?b ? &quot;sltub&quot; : &quot;sltu&quot;
 396                 newList &lt;&lt; Instruction.new(node.codeOrigin, comp, [tmp, node.operands[1], node.operands[0]], annotation)
 397                 newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;bz&quot;, [tmp, MIPS_ZERO_REG, node.operands[2]])
 398             when /^bt(i|p|b)/
 399                 lowerMIPSCondBranch(newList, &quot;b&quot; + $~.post_match + $1, node)
 400             else
 401                 newList &lt;&lt; node
 402             end
 403         else
 404             newList &lt;&lt; node
 405         end
 406     }
 407     newList
 408 end
 409 
 410 #
 411 # Specialization of lowering of malformed BaseIndex addresses.
 412 #
 413 
 414 class Node
 415     def mipsLowerMalformedAddressesRecurse(list)
 416         mapChildren {
 417             | subNode |
 418             subNode.mipsLowerMalformedAddressesRecurse(list)
 419         }
 420     end
 421 
 422     def mipsLowerShiftedAddressesRecurse(list, isFirst, tmp)
 423         mapChildren {
 424             | subNode |
 425             subNode.mipsLowerShiftedAddressesRecurse(list, isFirst, tmp)
 426         }
 427     end
 428 end
 429 
 430 class BaseIndex
 431     def mipsLowerMalformedAddressesRecurse(list)
 432         tmp = Tmp.new(codeOrigin, :gpr)
 433         if scaleShift == 0
 434             list &lt;&lt; Instruction.new(codeOrigin, &quot;addp&quot;, [base, index, tmp])
 435             Address.new(codeOrigin, tmp, Immediate.new(codeOrigin, offset.value));
 436         end
 437     end
 438 
 439     def mipsLowerShiftedAddressesRecurse(list, isFirst, tmp)
 440         if isFirst
 441             list &lt;&lt; Instruction.new(codeOrigin, &quot;lshifti&quot;, [index, Immediate.new(codeOrigin, scaleShift), tmp]);
 442             list &lt;&lt; Instruction.new(codeOrigin, &quot;addp&quot;, [base, tmp])
 443         end
 444         Address.new(codeOrigin, tmp, Immediate.new(codeOrigin, offset.value));
 445     end
 446 end
 447 
 448 #
 449 # Lowering of BaseIndex addresses with optimization for MIPS.
 450 #
 451 # offline asm instruction pair:
 452 #   loadi 4[cfr, t0, 8], t2
 453 #   loadi 0[cfr, t0, 8], t0
 454 #
 455 # lowered instructions: 
 456 #   lshifti t0, 3, tmp
 457 #   addp    cfr, tmp
 458 #   loadi   4[tmp], t2
 459 #   loadi   0[tmp], t0
 460 #
 461 
 462 def mipsHasShiftedBaseIndexAddress(instruction)
 463     instruction.operands.each_with_index {
 464         | operand, index |
 465         if operand.is_a? BaseIndex and operand.scaleShift != 0
 466             return index
 467         end
 468     }
 469     -1
 470 end
 471 
 472 def mipsScaleOfBaseIndexMatches(baseIndex0, baseIndex1)
 473     baseIndex0.base == baseIndex1.base and
 474     baseIndex0.index == baseIndex1.index and
 475     baseIndex0.scale == baseIndex1.scale
 476 end
 477 
 478 def mipsLowerBaseIndexAddresses(list)
 479     newList = [ list[0] ]
 480     tmp = nil
 481     list.each_cons(2) {
 482         | nodes |
 483         if nodes[1].is_a? Instruction
 484             ind = mipsHasShiftedBaseIndexAddress(nodes[1])
 485             if ind != -1
 486                 if nodes[0].is_a? Instruction and
 487                     nodes[0].opcode == nodes[1].opcode and
 488                     ind == mipsHasShiftedBaseIndexAddress(nodes[0]) and
 489                     mipsScaleOfBaseIndexMatches(nodes[0].operands[ind], nodes[1].operands[ind])
 490 
 491                     newList &lt;&lt; nodes[1].mipsLowerShiftedAddressesRecurse(newList, false, tmp)
 492                 else
 493                     tmp = Tmp.new(codeOrigin, :gpr)
 494                     newList &lt;&lt; nodes[1].mipsLowerShiftedAddressesRecurse(newList, true, tmp)
 495                 end
 496             else
 497                 newList &lt;&lt; nodes[1].mipsLowerMalformedAddressesRecurse(newList)
 498             end
 499         else
 500             newList &lt;&lt; nodes[1]
 501         end
 502     }
 503     newList
 504 end
 505 
 506 #
 507 # Lowering of misplaced immediates of MIPS specific instructions. For example:
 508 #
 509 # sltu reg, 4, 2
 510 #
 511 # will become:
 512 #
 513 # move 4, tmp
 514 # sltu reg, tmp, 2
 515 #
 516 
 517 def mipsLowerMisplacedImmediates(list)
 518     newList = []
 519     list.each {
 520         | node |
 521         if node.is_a? Instruction
 522             case node.opcode
 523             when &quot;slt&quot;, &quot;sltu&quot;, &quot;sltb&quot;, &quot;sltub&quot;
 524                 if node.operands[1].is_a? Immediate
 525                     tmp = Tmp.new(node.codeOrigin, :gpr)
 526                     newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;move&quot;, [node.operands[1], tmp], node.annotation)
 527                     newList &lt;&lt; Instruction.new(node.codeOrigin, node.opcode,
 528                                                [node.operands[0], tmp, node.operands[2]],
 529                                                node.annotation)
 530                 else
 531                     newList &lt;&lt; node
 532                 end
 533             when /^(addi|subi)/
 534                 newList &lt;&lt; node.riscLowerMalformedImmediatesRecurse(newList, -0x7fff..0x7fff)
<a name="4" id="anc4"></a><span class="line-modified"> 535             when &quot;andi&quot;, &quot;andp&quot;, &quot;ori&quot;, &quot;orp&quot;, &quot;orh&quot;, &quot;xori&quot;, &quot;xorp&quot;</span>
 536                 newList &lt;&lt; node.riscLowerMalformedImmediatesRecurse(newList, 0..0xffff)
 537             else
 538                 newList &lt;&lt; node
 539             end
 540         else
 541             newList &lt;&lt; node
 542         end
 543     }
 544     newList
 545 end
 546 
 547 #
 548 # Specialization of lowering of misplaced addresses.
 549 #
 550 
 551 class LocalLabelReference
 552     def register?
 553         false
 554     end
 555 end
 556 
 557 def mipsAsRegister(preList, postList, operand, needRestore)
 558     tmp = MIPS_CALL_REG
 559     if operand.address?
 560         preList &lt;&lt; Instruction.new(operand.codeOrigin, &quot;loadp&quot;, [operand, MIPS_CALL_REG])
 561     elsif operand.is_a? LabelReference
 562         preList &lt;&lt; Instruction.new(operand.codeOrigin, &quot;la&quot;, [operand, MIPS_CALL_REG])
 563     elsif operand.register? and operand != MIPS_CALL_REG
 564         preList &lt;&lt; Instruction.new(operand.codeOrigin, &quot;move&quot;, [operand, MIPS_CALL_REG])
 565     else
 566         needRestore = false
 567         tmp = operand
 568     end
 569     if needRestore
 570         postList &lt;&lt; Instruction.new(operand.codeOrigin, &quot;move&quot;, [MIPS_GPSAVE_REG, MIPS_GP_REG])
 571     end
 572     tmp
 573 end
 574 
 575 def mipsLowerMisplacedAddresses(list)
 576     newList = []
 577     list.each {
 578         | node |
 579         if node.is_a? Instruction
 580             postInstructions = []
 581             annotation = node.annotation
 582             case node.opcode
 583             when &quot;jmp&quot;
 584                 newList &lt;&lt; Instruction.new(node.codeOrigin,
 585                                            node.opcode,
 586                                            [mipsAsRegister(newList, [], node.operands[0], false)])
 587             when &quot;call&quot;
 588                 newList &lt;&lt; Instruction.new(node.codeOrigin,
 589                                            node.opcode,
 590                                            [mipsAsRegister(newList, postInstructions, node.operands[0], true)])
 591             when &quot;slt&quot;, &quot;sltu&quot;
 592                 newList &lt;&lt; Instruction.new(node.codeOrigin,
 593                                            node.opcode,
 594                                            riscAsRegisters(newList, [], node.operands, &quot;i&quot;))
 595             when &quot;sltub&quot;, &quot;sltb&quot;
 596                 newList &lt;&lt; Instruction.new(node.codeOrigin,
 597                                            node.opcode,
 598                                            riscAsRegisters(newList, [], node.operands, &quot;b&quot;))
 599             when &quot;andb&quot;
 600                 newList &lt;&lt; Instruction.new(node.codeOrigin,
 601                                            &quot;andi&quot;,
 602                                            riscAsRegisters(newList, [], node.operands, &quot;b&quot;))
 603             when /^(bz|bnz|bs|bo)/
 604                 tl = $~.post_match == &quot;&quot; ? &quot;i&quot; : $~.post_match
 605                 newList &lt;&lt; Instruction.new(node.codeOrigin,
 606                                            node.opcode,
 607                                            riscAsRegisters(newList, [], node.operands, tl))
 608             else
 609                 newList &lt;&lt; node
 610             end
 611             newList += postInstructions
 612         else
 613             newList &lt;&lt; node
 614         end
 615     }
 616     newList
 617 end
 618 
 619 #
 620 # Lowering compares and tests.
 621 #
 622 
 623 def mipsLowerCompareTemplate(list, node, opCmp, opMov)
 624     tmp0 = Tmp.new(node.codeOrigin, :gpr)
 625     tmp1 = Tmp.new(node.codeOrigin, :gpr)
 626     list &lt;&lt; Instruction.new(node.codeOrigin, &quot;move&quot;, [Immediate.new(nil, 0), node.operands[2]])
 627     list &lt;&lt; Instruction.new(node.codeOrigin, opCmp, [node.operands[1], node.operands[0], tmp0])
 628     list &lt;&lt; Instruction.new(node.codeOrigin, &quot;move&quot;, [Immediate.new(nil, 1), tmp1])
 629     list &lt;&lt; Instruction.new(node.codeOrigin, opMov, [node.operands[2], tmp1, tmp0])
 630 end
 631 
 632 def mipsLowerCompares(list)
 633     newList = []
 634     list.each {
 635         | node |
 636         if node.is_a? Instruction
 637             case node.opcode
 638             when &quot;cieq&quot;, &quot;cpeq&quot;, &quot;cbeq&quot;
 639                 mipsLowerCompareTemplate(newList, node, &quot;subp&quot;, &quot;movz&quot;)
 640             when &quot;cineq&quot;, &quot;cpneq&quot;, &quot;cbneq&quot;
 641                 mipsLowerCompareTemplate(newList, node, &quot;subp&quot;, &quot;movn&quot;)
 642             when &quot;tiz&quot;, &quot;tbz&quot;, &quot;tpz&quot;
 643                 mipsLowerCompareTemplate(newList, node, &quot;andp&quot;, &quot;movz&quot;)
 644             when &quot;tinz&quot;, &quot;tbnz&quot;, &quot;tpnz&quot;
 645                 mipsLowerCompareTemplate(newList, node, &quot;andp&quot;, &quot;movn&quot;)
 646             when &quot;tio&quot;, &quot;tbo&quot;, &quot;tpo&quot;
 647                 tmp = Tmp.new(node.codeOrigin, :gpr)
 648                 list &lt;&lt; Instruction.new(node.codeOrigin, &quot;andp&quot;, [node.operands[1], node.operands[0], tmp])
 649                 list &lt;&lt; Instruction.new(node.codeOrigin, &quot;slt&quot;, [node.operands[2], MIPS_ZERO_REG, tmp])
 650             when &quot;tis&quot;, &quot;tbs&quot;, &quot;tps&quot;
 651                 tmp = Tmp.new(node.codeOrigin, :gpr)
 652                 list &lt;&lt; Instruction.new(node.codeOrigin, &quot;andp&quot;, [node.operands[1], node.operands[0], tmp])
 653                 list &lt;&lt; Instruction.new(node.codeOrigin, &quot;slt&quot;, [node.operands[2], tmp, MIPS_ZERO_REG])
 654             else
 655                 newList &lt;&lt; node
 656             end
 657         else
 658             newList &lt;&lt; node
 659         end
 660     }
 661     newList
 662 end
 663 
 664 #
 665 # Lea support.
 666 #
 667 
 668 class Address
 669     def mipsEmitLea(destination)
 670         if destination == base
 671             $asm.puts &quot;addiu #{destination.mipsOperand}, #{offset.value}&quot;
 672         else
 673             $asm.puts &quot;addiu #{destination.mipsOperand}, #{base.mipsOperand}, #{offset.value}&quot;
 674         end
 675     end
 676 end
 677 
 678 #
 679 # Add PIC compatible header code to all the LLInt rutins.
 680 #
 681 
 682 def mipsAddPICCode(list)
 683     myList = []
 684     list.each {
 685         | node |
 686         myList &lt;&lt; node
 687         if node.is_a? Label
<a name="5" id="anc5"></a><span class="line-modified"> 688             # FIXME: [JSC] checkpoint_osr_exit_from_inlined_call_trampoline is a return location</span>
<span class="line-added"> 689             # and we should name it properly.</span>
<span class="line-added"> 690             # https://bugs.webkit.org/show_bug.cgi?id=208236</span>
<span class="line-added"> 691             if node.name =~ /^.*_return_location(?:_(?:wide16|wide32))?$/ or node.name.start_with?(&quot;_checkpoint_osr_exit_from_inlined_call_trampoline&quot;)</span>
<span class="line-added"> 692                 # We need to have a special case for return location labels because they are always</span>
<span class="line-added"> 693                 # reached from a `ret` instruction. In this case, we need to proper reconfigure `$gp`</span>
<span class="line-added"> 694                 # using `$ra` instead of using `$t9`.</span>
<span class="line-added"> 695                 myList &lt;&lt; Instruction.new(node.codeOrigin, &quot;pichdr&quot;, [MIPS_RETURN_ADDRESS_REG])</span>
<span class="line-added"> 696             else</span>
<span class="line-added"> 697                 myList &lt;&lt; Instruction.new(node.codeOrigin, &quot;pichdr&quot;, [MIPS_CALL_REG])</span>
<span class="line-added"> 698             end</span>
 699         end
 700     }
 701     myList
 702 end
 703 
 704 #
 705 # Actual lowering code follows.
 706 #
 707 
 708 class Sequence
 709     def getModifiedListMIPS
 710         result = @list
 711 
 712         # Verify that we will only see instructions and labels.
 713         result.each {
 714             | node |
 715             unless node.is_a? Instruction or
 716                     node.is_a? Label or
 717                     node.is_a? LocalLabel or
 718                     node.is_a? Skip
 719                 raise &quot;Unexpected #{node.inspect} at #{node.codeOrigin}&quot;
 720             end
 721         }
 722 
 723         result = mipsAddPICCode(result)
 724         result = mipsLowerFarBranchOps(result)
 725         result = mipsLowerSimpleBranchOps(result)
 726         result = riscLowerSimpleBranchOps(result)
 727         result = riscLowerHardBranchOps(result)
 728         result = riscLowerShiftOps(result)
 729         result = mipsLowerBaseIndexAddresses(result)
 730         result = riscLowerMalformedAddresses(result) {
 731             | node, address |
 732             if address.is_a? Address
 733                 (-0x7fff..0x7fff).include? address.offset.value
 734             else
 735                 false
 736             end
 737         }
 738         result = riscLowerMalformedAddressesDouble(result)
 739         result = riscLowerMisplacedImmediates(result, [&quot;storeb&quot;, &quot;storei&quot;, &quot;storep&quot;])
 740         result = mipsLowerMisplacedImmediates(result)
<a name="6" id="anc6"></a><span class="line-modified"> 741         result = riscLowerMalformedImmediates(result, -0x7fff..0x7fff, -0x7fff..0x7fff)</span>
 742         result = mipsLowerMisplacedAddresses(result)
 743         result = riscLowerMisplacedAddresses(result)
 744         result = riscLowerRegisterReuse(result)
 745         result = mipsLowerCompares(result)
 746         result = assignRegistersToTemporaries(result, :gpr, MIPS_TEMP_GPRS)
 747         result = assignRegistersToTemporaries(result, :fpr, MIPS_TEMP_FPRS)
 748 
 749         return result
 750     end
 751 end
 752 
 753 def mipsOperands(operands)
 754     operands.map{|v| v.mipsOperand}.join(&quot;, &quot;)
 755 end
 756 
 757 def mipsFlippedOperands(operands)
 758     mipsOperands([operands[-1]] + operands[0..-2])
 759 end
 760 
 761 def getMIPSOpcode(opcode, suffix)
 762 
 763 end
 764 
 765 def emitMIPSCompact(opcode, opcodei, operands)
 766     postfix = &quot;&quot;
 767     if opcode == &quot;sub&quot;
 768         if operands[0].is_a? Immediate
 769             opcode = &quot;add&quot;
 770             operands[0] = Immediate.new(operands[0].codeOrigin, -1 * operands[0].value)
 771         elsif operands[1].is_a? Immediate
 772             opcode = &quot;add&quot;
 773             operands[1] = Immediate.new(operands[1].codeOrigin, -1 * operands[1].value)
 774         end
 775         postfix = &quot;u&quot;
 776     elsif opcode == &quot;add&quot;
 777         postfix = &quot;u&quot;
 778     end
 779     if operands.size == 3
 780         if operands[0].is_a? Immediate
 781             $asm.puts &quot;#{opcode}i#{postfix} #{operands[2].mipsOperand}, #{operands[1].mipsOperand}, #{operands[0].value}&quot;
 782         elsif operands[1].is_a? Immediate
 783             $asm.puts &quot;#{opcode}i#{postfix} #{operands[2].mipsOperand}, #{operands[0].mipsOperand}, #{operands[1].value}&quot;
 784         else
 785             $asm.puts &quot;#{opcode}#{postfix} #{mipsFlippedOperands(operands)}&quot;
 786         end
 787     else
 788         raise unless operands.size == 2
 789         raise unless operands[1].register?
 790         if operands[0].is_a? Immediate
 791             $asm.puts &quot;#{opcode}i#{postfix} #{operands[1].mipsOperand}, #{operands[1].mipsOperand}, #{operands[0].mipsOperand}&quot;
 792         else
 793             $asm.puts &quot;#{opcode}#{postfix} #{operands[1].mipsOperand}, #{operands[1].mipsOperand}, #{operands[0].mipsOperand}&quot;
 794         end
 795     end
 796 end
 797 
 798 def emitMIPSShiftCompact(opcode, operands)
 799     if operands.size == 3
 800         if (operands[1].is_a? Immediate)
 801             $asm.puts &quot;#{opcode} #{operands[2].mipsOperand}, #{operands[0].mipsOperand}, #{operands[1].value}&quot;
 802         else
 803             $asm.puts &quot;#{opcode}v #{mipsFlippedOperands(operands)}&quot;
 804         end
 805     else
 806         raise unless operands.size == 2
 807         if operands[0].register?
 808             $asm.puts &quot;#{opcode}v #{operands[1].mipsOperand}, #{operands[1].mipsOperand}, #{operands[0].mipsOperand}&quot;
 809         else
 810             $asm.puts &quot;#{opcode} #{operands[1].mipsOperand}, #{operands[1].mipsOperand}, #{operands[0].value}&quot;
 811         end
 812     end
 813 end
 814 
 815 def emitMIPS(opcode, operands)
 816     if operands.size == 3
 817         $asm.puts &quot;#{opcode} #{mipsFlippedOperands(operands)}&quot;
 818     else
 819         raise unless operands.size == 2
 820         $asm.puts &quot;#{opcode} #{operands[1].mipsOperand}, #{operands[1].mipsOperand}, #{operands[0].mipsOperand}&quot;
 821     end
 822 end
 823 
 824 def emitMIPSDoubleBranch(branchOpcode, neg, operands)
 825     $asm.puts &quot;c.#{branchOpcode}.d #{mipsOperands(operands[0..1])}&quot;
 826     if (!neg)
 827         $asm.puts &quot;bc1t #{operands[2].asmLabel}&quot;
 828     else
 829         $asm.puts &quot;bc1f #{operands[2].asmLabel}&quot;
 830     end
 831 end
 832 
 833 def emitMIPSJumpOrCall(opcode, operand)
 834     if operand.label?
 835         raise &quot;Direct call/jump to a not local label.&quot; unless operand.is_a? LocalLabelReference
 836         $asm.puts &quot;#{opcode} #{operand.asmLabel}&quot;
 837     else
 838         raise &quot;Invalid call/jump register.&quot; unless operand == MIPS_CALL_REG
 839         $asm.puts &quot;#{opcode}r #{MIPS_CALL_REG.mipsOperand}&quot;
 840     end
 841 end
 842 
 843 class Instruction
 844     def lowerMIPS
 845         case opcode
 846         when &quot;addi&quot;, &quot;addp&quot;, &quot;addis&quot;
 847             if operands.size == 3 and operands[0].is_a? Immediate
 848                 raise unless operands[1].register?
 849                 raise unless operands[2].register?
 850                 if operands[0].value == 0 #and suffix.empty?
 851                     unless operands[1] == operands[2]
 852                         $asm.puts &quot;move #{operands[2].mipsOperand}, #{operands[1].mipsOperand}&quot;
 853                     end
 854                 else
 855                     $asm.puts &quot;addiu #{operands[2].mipsOperand}, #{operands[1].mipsOperand}, #{operands[0].mipsOperand}&quot;
 856                 end
 857             elsif operands.size == 3 and operands[0].register?
 858                 raise unless operands[1].register?
 859                 raise unless operands[2].register?
 860                 $asm.puts &quot;addu #{mipsFlippedOperands(operands)}&quot;
 861             else
 862                 if operands[0].is_a? Immediate
 863                     unless Immediate.new(nil, 0) == operands[0]
 864                         $asm.puts &quot;addiu #{operands[1].mipsOperand}, #{mipsFlippedOperands(operands)}&quot;
 865                     end
 866                 else
 867                     $asm.puts &quot;addu #{operands[1].mipsOperand}, #{operands[1].mipsOperand}, #{operands[0].mipsOperand}&quot;
 868                 end
 869             end
 870         when &quot;andi&quot;, &quot;andp&quot;
 871             emitMIPSCompact(&quot;and&quot;, &quot;and&quot;, operands)
<a name="7" id="anc7"></a><span class="line-modified"> 872         when &quot;ori&quot;, &quot;orp&quot;, &quot;orh&quot;</span>
 873             emitMIPSCompact(&quot;or&quot;, &quot;orr&quot;, operands)
 874         when &quot;oris&quot;
 875             emitMIPSCompact(&quot;or&quot;, &quot;orrs&quot;, operands)
 876         when &quot;xori&quot;, &quot;xorp&quot;
 877             emitMIPSCompact(&quot;xor&quot;, &quot;eor&quot;, operands)
 878         when &quot;lshifti&quot;, &quot;lshiftp&quot;
 879             emitMIPSShiftCompact(&quot;sll&quot;, operands)
 880         when &quot;rshifti&quot;, &quot;rshiftp&quot;
 881             emitMIPSShiftCompact(&quot;sra&quot;, operands)
 882         when &quot;urshifti&quot;, &quot;urshiftp&quot;
 883             emitMIPSShiftCompact(&quot;srl&quot;, operands)
 884         when &quot;muli&quot;, &quot;mulp&quot;
 885             emitMIPS(&quot;mul&quot;, operands)
 886         when &quot;subi&quot;, &quot;subp&quot;, &quot;subis&quot;
 887             emitMIPSCompact(&quot;sub&quot;, &quot;subs&quot;, operands)
 888         when &quot;negi&quot;, &quot;negp&quot;
 889             $asm.puts &quot;negu #{operands[0].mipsOperand}, #{operands[0].mipsOperand}&quot;
 890         when &quot;noti&quot;
 891             $asm.puts &quot;nor #{operands[0].mipsOperand}, #{operands[0].mipsOperand}, $zero&quot;
 892         when &quot;loadi&quot;, &quot;loadis&quot;, &quot;loadp&quot;
 893             $asm.puts &quot;lw #{mipsFlippedOperands(operands)}&quot;
 894         when &quot;storei&quot;, &quot;storep&quot;
 895             $asm.puts &quot;sw #{mipsOperands(operands)}&quot;
 896         when &quot;loadb&quot;
 897             $asm.puts &quot;lbu #{mipsFlippedOperands(operands)}&quot;
 898         when &quot;loadbsi&quot;
 899             $asm.puts &quot;lb #{mipsFlippedOperands(operands)}&quot;
 900         when &quot;storeb&quot;
 901             $asm.puts &quot;sb #{mipsOperands(operands)}&quot;
 902         when &quot;loadh&quot;
 903             $asm.puts &quot;lhu #{mipsFlippedOperands(operands)}&quot;
 904         when &quot;loadhsi&quot;
 905             $asm.puts &quot;lh #{mipsFlippedOperands(operands)}&quot;
 906         when &quot;storeh&quot;
 907             $asm.puts &quot;shv #{mipsOperands(operands)}&quot;
 908         when &quot;loadd&quot;
 909             $asm.puts &quot;ldc1 #{mipsFlippedOperands(operands)}&quot;
 910         when &quot;stored&quot;
 911             $asm.puts &quot;sdc1 #{mipsOperands(operands)}&quot;
 912         when &quot;la&quot;
 913             $asm.puts &quot;la #{operands[1].mipsOperand}, #{operands[0].asmLabel}&quot;
 914         when &quot;addd&quot;
 915             emitMIPS(&quot;add.d&quot;, operands)
 916         when &quot;divd&quot;
 917             emitMIPS(&quot;div.d&quot;, operands)
 918         when &quot;subd&quot;
 919             emitMIPS(&quot;sub.d&quot;, operands)
 920         when &quot;muld&quot;
 921             emitMIPS(&quot;mul.d&quot;, operands)
 922         when &quot;sqrtd&quot;
 923             $asm.puts &quot;sqrt.d #{mipsFlippedOperands(operands)}&quot;
<a name="8" id="anc8"></a><span class="line-modified"> 924         when &quot;ci2ds&quot;</span>
 925             raise &quot;invalid ops of #{self.inspect} at #{codeOriginString}&quot; unless operands[1].is_a? FPRegisterID and operands[0].register?
 926             $asm.puts &quot;mtc1 #{operands[0].mipsOperand}, #{operands[1].mipsOperand}&quot;
 927             $asm.puts &quot;cvt.d.w #{operands[1].mipsOperand}, #{operands[1].mipsOperand}&quot;
 928         when &quot;bdeq&quot;
 929             emitMIPSDoubleBranch(&quot;eq&quot;, false, operands)
 930         when &quot;bdneq&quot;
 931             emitMIPSDoubleBranch(&quot;ueq&quot;, true, operands)
 932         when &quot;bdgt&quot;
 933             emitMIPSDoubleBranch(&quot;ule&quot;, true, operands)
 934         when &quot;bdgteq&quot;
 935             emitMIPSDoubleBranch(&quot;ult&quot;, true, operands)
 936         when &quot;bdlt&quot;
 937             emitMIPSDoubleBranch(&quot;olt&quot;, false, operands)
 938         when &quot;bdlteq&quot;
 939             emitMIPSDoubleBranch(&quot;ole&quot;, false, operands)
 940         when &quot;bdequn&quot;
 941             emitMIPSDoubleBranch(&quot;ueq&quot;, false, operands)
 942         when &quot;bdnequn&quot;
 943             emitMIPSDoubleBranch(&quot;eq&quot;, true, operands)
 944         when &quot;bdgtun&quot;
 945             emitMIPSDoubleBranch(&quot;ole&quot;, true, operands)
 946         when &quot;bdgtequn&quot;
 947             emitMIPSDoubleBranch(&quot;olt&quot;, true, operands)
 948         when &quot;bdltun&quot;
 949             emitMIPSDoubleBranch(&quot;ult&quot;, false, operands)
 950         when &quot;bdltequn&quot;
 951             emitMIPSDoubleBranch(&quot;ule&quot;, false, operands)
 952         when &quot;btd2i&quot;
 953             # FIXME: may be a good idea to just get rid of this instruction, since the interpreter
 954             # currently does not use it.
 955             raise &quot;MIPS does not support this opcode yet, #{codeOrigin}&quot;
 956         when &quot;td2i&quot;
 957             $asm.puts &quot;cvt.w.d #{MIPS_SCRATCH_FPR.mipsSingleLo}, #{operands[0].mipsOperand}&quot;
 958             $asm.puts &quot;mfc1 #{operands[1].mipsOperand}, #{MIPS_SCRATCH_FPR.mipsSingleLo}&quot;
 959         when &quot;bcd2i&quot;
 960             $asm.puts &quot;cvt.w.d #{MIPS_SCRATCH_FPR.mipsSingleLo}, #{operands[0].mipsOperand}&quot;
 961             $asm.puts &quot;mfc1 #{operands[1].mipsOperand}, #{MIPS_SCRATCH_FPR.mipsSingleLo}&quot;
 962             $asm.puts &quot;cvt.d.w #{MIPS_SCRATCH_FPR.mipsOperand}, #{MIPS_SCRATCH_FPR.mipsSingleLo}&quot;
 963             emitMIPSDoubleBranch(&quot;eq&quot;, true, [MIPS_SCRATCH_FPR, operands[0], operands[2]])
 964             $asm.puts &quot;beq #{operands[1].mipsOperand}, $zero, #{operands[2].asmLabel}&quot;
 965         when &quot;movdz&quot;
 966             # FIXME: either support this or remove it.
 967             raise &quot;MIPS does not support this opcode yet, #{codeOrigin}&quot;
 968         when &quot;pop&quot;
 969             operands.each {
 970                 | op |
 971                 $asm.puts &quot;lw #{op.mipsOperand}, 0($sp)&quot;
 972                 $asm.puts &quot;addiu $sp, $sp, 4&quot;
 973             }
 974         when &quot;push&quot;
 975             operands.each {
 976                 | op |
 977                 $asm.puts &quot;addiu $sp, $sp, -4&quot;
 978                 $asm.puts &quot;sw #{op.mipsOperand}, 0($sp)&quot;
 979             }
 980         when &quot;move&quot;, &quot;sxi2p&quot;, &quot;zxi2p&quot;
 981             if operands[0].is_a? Immediate
 982                 mipsMoveImmediate(operands[0].value, operands[1])
 983             else
 984                 $asm.puts &quot;move #{mipsFlippedOperands(operands)}&quot;
 985             end
 986         when &quot;nop&quot;
 987             $asm.puts &quot;nop&quot;
 988         when &quot;bieq&quot;, &quot;bpeq&quot;, &quot;bbeq&quot;
 989             $asm.puts &quot;beq #{mipsOperands(operands[0..1])}, #{operands[2].asmLabel}&quot;
 990         when &quot;bineq&quot;, &quot;bpneq&quot;, &quot;bbneq&quot;
 991             $asm.puts &quot;bne #{mipsOperands(operands[0..1])}, #{operands[2].asmLabel}&quot;
 992         when &quot;bigt&quot;, &quot;bpgt&quot;, &quot;bbgt&quot;
 993             $asm.puts &quot;bgt #{mipsOperands(operands[0..1])}, #{operands[2].asmLabel}&quot;
 994         when &quot;bigteq&quot;, &quot;bpgteq&quot;, &quot;bbgteq&quot;
 995             $asm.puts &quot;bge #{mipsOperands(operands[0..1])}, #{operands[2].asmLabel}&quot;
 996         when &quot;bilt&quot;, &quot;bplt&quot;, &quot;bblt&quot;
 997             $asm.puts &quot;blt #{mipsOperands(operands[0..1])}, #{operands[2].asmLabel}&quot;
 998         when &quot;bilteq&quot;, &quot;bplteq&quot;, &quot;bblteq&quot;
 999             $asm.puts &quot;ble #{mipsOperands(operands[0..1])}, #{operands[2].asmLabel}&quot;
1000         when &quot;jmp&quot;
1001             emitMIPSJumpOrCall(&quot;j&quot;, operands[0])
1002         when &quot;call&quot;
1003             emitMIPSJumpOrCall(&quot;jal&quot;, operands[0])
1004         when &quot;break&quot;
1005             $asm.puts &quot;break&quot;
1006         when &quot;ret&quot;
1007             $asm.puts &quot;jr $ra&quot;
1008         when &quot;cia&quot;, &quot;cpa&quot;, &quot;cba&quot;
1009             $asm.puts &quot;sltu #{operands[2].mipsOperand}, #{operands[1].mipsOperand}, #{operands[0].mipsOperand}&quot;
1010         when &quot;ciaeq&quot;, &quot;cpaeq&quot;, &quot;cbaeq&quot;
1011             $asm.puts &quot;sltu #{operands[2].mipsOperand}, #{operands[0].mipsOperand}, #{operands[1].mipsOperand}&quot;
1012             $asm.puts &quot;xori #{operands[2].mipsOperand}, 1&quot;
1013         when &quot;cib&quot;, &quot;cpb&quot;, &quot;cbb&quot;
1014             $asm.puts &quot;sltu #{operands[2].mipsOperand}, #{operands[0].mipsOperand}, #{operands[1].mipsOperand}&quot;
1015         when &quot;cibeq&quot;, &quot;cpbeq&quot;, &quot;cbbeq&quot;
1016             $asm.puts &quot;sltu #{operands[2].mipsOperand}, #{operands[1].mipsOperand}, #{operands[0].mipsOperand}&quot;
1017             $asm.puts &quot;xori #{operands[2].mipsOperand}, 1&quot;
1018         when &quot;cigt&quot;, &quot;cpgt&quot;, &quot;cbgt&quot;
1019             $asm.puts &quot;slt #{operands[2].mipsOperand}, #{operands[1].mipsOperand}, #{operands[0].mipsOperand}&quot;
1020         when &quot;cigteq&quot;, &quot;cpgteq&quot;, &quot;cbgteq&quot;
1021             $asm.puts &quot;slt #{operands[2].mipsOperand}, #{operands[0].mipsOperand}, #{operands[1].mipsOperand}&quot;
1022             $asm.puts &quot;xori #{operands[2].mipsOperand}, 1&quot;
1023         when &quot;cilt&quot;, &quot;cplt&quot;, &quot;cblt&quot;
1024             $asm.puts &quot;slt #{operands[2].mipsOperand}, #{operands[0].mipsOperand}, #{operands[1].mipsOperand}&quot;
1025         when &quot;cilteq&quot;, &quot;cplteq&quot;, &quot;cblteq&quot;
1026             $asm.puts &quot;slt #{operands[2].mipsOperand}, #{operands[1].mipsOperand}, #{operands[0].mipsOperand}&quot;
1027             $asm.puts &quot;xori #{operands[2].mipsOperand}, 1&quot;
1028         when &quot;peek&quot;
1029             $asm.puts &quot;lw #{operands[1].mipsOperand}, #{operands[0].value * 4}($sp)&quot;
1030         when &quot;poke&quot;
1031             $asm.puts &quot;sw #{operands[1].mipsOperand}, #{operands[0].value * 4}($sp)&quot;
1032         when &quot;fii2d&quot;
1033             $asm.puts &quot;mtc1 #{operands[0].mipsOperand}, #{operands[2].mipsSingleLo}&quot;
1034             $asm.putStr(&quot;#if WTF_MIPS_ISA_REV_AT_LEAST(2)&quot;)
1035             $asm.puts &quot;mthc1 #{operands[1].mipsOperand}, #{operands[2].mipsSingleLo}&quot;
1036             $asm.putStr(&quot;#else&quot;)
1037             $asm.puts &quot;mtc1 #{operands[1].mipsOperand}, #{operands[2].mipsSingleHi}&quot;
1038             $asm.putStr(&quot;#endif&quot;)
1039         when &quot;fd2ii&quot;
1040             $asm.puts &quot;mfc1 #{operands[1].mipsOperand}, #{operands[0].mipsSingleLo}&quot;
1041             $asm.putStr(&quot;#if WTF_MIPS_ISA_REV_AT_LEAST(2)&quot;)
1042             $asm.puts &quot;mfhc1 #{operands[2].mipsOperand}, #{operands[0].mipsSingleLo}&quot;
1043             $asm.putStr(&quot;#else&quot;)
1044             $asm.puts &quot;mfc1 #{operands[2].mipsOperand}, #{operands[0].mipsSingleHi}&quot;
1045             $asm.putStr(&quot;#endif&quot;)
1046         when /^bo/
1047             $asm.puts &quot;bgt #{operands[0].mipsOperand}, #{operands[1].mipsOperand}, #{operands[2].asmLabel}&quot;
1048         when /^bs/
1049             $asm.puts &quot;blt #{operands[0].mipsOperand}, #{operands[1].mipsOperand}, #{operands[2].asmLabel}&quot;
1050         when /^bz/
1051             $asm.puts &quot;beq #{operands[0].mipsOperand}, #{operands[1].mipsOperand}, #{operands[2].asmLabel}&quot;
1052         when /^bnz/
1053             $asm.puts &quot;bne #{operands[0].mipsOperand}, #{operands[1].mipsOperand}, #{operands[2].asmLabel}&quot;
1054         when &quot;leai&quot;, &quot;leap&quot;
1055             if operands[0].is_a? LabelReference
1056                 labelRef = operands[0]
1057                 raise unless labelRef.offset == 0
1058                 $asm.puts &quot;lw #{operands[1].mipsOperand}, %got(#{labelRef.asmLabel})($gp)&quot;
1059             else
1060                 operands[0].mipsEmitLea(operands[1])
1061             end
1062 
1063         when &quot;smulli&quot;
1064             raise &quot;Wrong number of arguments to smull in #{self.inspect} at #{codeOriginString}&quot; unless operands.length == 4
1065             $asm.puts &quot;mult #{operands[0].mipsOperand}, #{operands[1].mipsOperand}&quot;
1066             $asm.puts &quot;mflo #{operands[2].mipsOperand}&quot;
1067             $asm.puts &quot;mfhi #{operands[3].mipsOperand}&quot;
1068         when &quot;movz&quot;
1069             $asm.puts &quot;movz #{operands[0].mipsOperand}, #{operands[1].mipsOperand}, #{operands[2].mipsOperand}&quot;
1070         when &quot;movn&quot;
1071             $asm.puts &quot;movn #{operands[0].mipsOperand}, #{operands[1].mipsOperand}, #{operands[2].mipsOperand}&quot;
1072         when &quot;setcallreg&quot;
1073             $asm.puts &quot;move #{MIPS_CALL_REG.mipsOperand}, #{operands[0].mipsOperand}&quot;
1074         when &quot;slt&quot;, &quot;sltb&quot;
1075             $asm.puts &quot;slt #{operands[0].mipsOperand}, #{operands[1].mipsOperand}, #{operands[2].mipsOperand}&quot;
1076         when &quot;sltu&quot;, &quot;sltub&quot;
1077             $asm.puts &quot;sltu #{operands[0].mipsOperand}, #{operands[1].mipsOperand}, #{operands[2].mipsOperand}&quot;
1078         when &quot;pichdr&quot;
<a name="9" id="anc9"></a><span class="line-modified">1079             $asm.putStr(&quot;OFFLINE_ASM_CPLOAD(#{operands[0].mipsOperand})&quot;)</span>
1080         when &quot;memfence&quot;
1081             $asm.puts &quot;sync&quot;
1082         else
1083             lowerDefault
1084         end
1085     end
1086 end
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
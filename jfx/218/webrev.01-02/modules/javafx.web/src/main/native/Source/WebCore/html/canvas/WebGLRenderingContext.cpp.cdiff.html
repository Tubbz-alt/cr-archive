<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebGLRenderbuffer.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLRenderingContext.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContext.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 33,11 ***</span>
  #include &quot;EXTBlendMinMax.h&quot;
  #include &quot;EXTFragDepth.h&quot;
  #include &quot;EXTShaderTextureLOD.h&quot;
  #include &quot;EXTTextureFilterAnisotropic.h&quot;
  #include &quot;EXTsRGB.h&quot;
<span class="line-modified">! #include &quot;Extensions3D.h&quot;</span>
  #include &quot;HTMLCanvasElement.h&quot;
  #include &quot;HTMLImageElement.h&quot;
  #include &quot;HTMLVideoElement.h&quot;
  #include &quot;ImageData.h&quot;
  #include &quot;InspectorInstrumentation.h&quot;
<span class="line-new-header">--- 33,11 ---</span>
  #include &quot;EXTBlendMinMax.h&quot;
  #include &quot;EXTFragDepth.h&quot;
  #include &quot;EXTShaderTextureLOD.h&quot;
  #include &quot;EXTTextureFilterAnisotropic.h&quot;
  #include &quot;EXTsRGB.h&quot;
<span class="line-modified">! #include &quot;ExtensionsGL.h&quot;</span>
  #include &quot;HTMLCanvasElement.h&quot;
  #include &quot;HTMLImageElement.h&quot;
  #include &quot;HTMLVideoElement.h&quot;
  #include &quot;ImageData.h&quot;
  #include &quot;InspectorInstrumentation.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 49,10 ***</span>
<span class="line-new-header">--- 49,12 ---</span>
  #include &quot;OESTextureHalfFloatLinear.h&quot;
  #include &quot;OESVertexArrayObject.h&quot;
  #include &quot;RenderBox.h&quot;
  #include &quot;WebGLCompressedTextureASTC.h&quot;
  #include &quot;WebGLCompressedTextureATC.h&quot;
<span class="line-added">+ #include &quot;WebGLCompressedTextureETC.h&quot;</span>
<span class="line-added">+ #include &quot;WebGLCompressedTextureETC1.h&quot;</span>
  #include &quot;WebGLCompressedTexturePVRTC.h&quot;
  #include &quot;WebGLCompressedTextureS3TC.h&quot;
  #include &quot;WebGLDebugRendererInfo.h&quot;
  #include &quot;WebGLDebugShaders.h&quot;
  #include &quot;WebGLDepthTexture.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 68,34 ***</span>
  
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(WebGLRenderingContext);
  
<span class="line-modified">! std::unique_ptr&lt;WebGLRenderingContext&gt; WebGLRenderingContext::create(CanvasBase&amp; canvas, GraphicsContext3DAttributes attributes)</span>
  {
      auto renderingContext = std::unique_ptr&lt;WebGLRenderingContext&gt;(new WebGLRenderingContext(canvas, attributes));
  
      InspectorInstrumentation::didCreateCanvasRenderingContext(*renderingContext);
  
      return renderingContext;
  }
  
<span class="line-modified">! std::unique_ptr&lt;WebGLRenderingContext&gt; WebGLRenderingContext::create(CanvasBase&amp; canvas, Ref&lt;GraphicsContext3D&gt;&amp;&amp; context, GraphicsContext3DAttributes attributes)</span>
  {
      auto renderingContext = std::unique_ptr&lt;WebGLRenderingContext&gt;(new WebGLRenderingContext(canvas, WTFMove(context), attributes));
  
      InspectorInstrumentation::didCreateCanvasRenderingContext(*renderingContext);
  
      return renderingContext;
  }
  
<span class="line-modified">! WebGLRenderingContext::WebGLRenderingContext(CanvasBase&amp; canvas, GraphicsContext3DAttributes attributes)</span>
      : WebGLRenderingContextBase(canvas, attributes)
  {
  }
  
<span class="line-modified">! WebGLRenderingContext::WebGLRenderingContext(CanvasBase&amp; canvas, Ref&lt;GraphicsContext3D&gt;&amp;&amp; context, GraphicsContext3DAttributes attributes)</span>
      : WebGLRenderingContextBase(canvas, WTFMove(context), attributes)
  {
      initializeVertexArrayObjects();
  }
  
<span class="line-new-header">--- 70,34 ---</span>
  
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(WebGLRenderingContext);
  
<span class="line-modified">! std::unique_ptr&lt;WebGLRenderingContext&gt; WebGLRenderingContext::create(CanvasBase&amp; canvas, GraphicsContextGLAttributes attributes)</span>
  {
      auto renderingContext = std::unique_ptr&lt;WebGLRenderingContext&gt;(new WebGLRenderingContext(canvas, attributes));
  
      InspectorInstrumentation::didCreateCanvasRenderingContext(*renderingContext);
  
      return renderingContext;
  }
  
<span class="line-modified">! std::unique_ptr&lt;WebGLRenderingContext&gt; WebGLRenderingContext::create(CanvasBase&amp; canvas, Ref&lt;GraphicsContextGLOpenGL&gt;&amp;&amp; context, GraphicsContextGLAttributes attributes)</span>
  {
      auto renderingContext = std::unique_ptr&lt;WebGLRenderingContext&gt;(new WebGLRenderingContext(canvas, WTFMove(context), attributes));
  
      InspectorInstrumentation::didCreateCanvasRenderingContext(*renderingContext);
  
      return renderingContext;
  }
  
<span class="line-modified">! WebGLRenderingContext::WebGLRenderingContext(CanvasBase&amp; canvas, GraphicsContextGLAttributes attributes)</span>
      : WebGLRenderingContextBase(canvas, attributes)
  {
  }
  
<span class="line-modified">! WebGLRenderingContext::WebGLRenderingContext(CanvasBase&amp; canvas, Ref&lt;GraphicsContextGLOpenGL&gt;&amp;&amp; context, GraphicsContextGLAttributes attributes)</span>
      : WebGLRenderingContextBase(canvas, WTFMove(context), attributes)
  {
      initializeVertexArrayObjects();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 137,23 ***</span>
              }
          }
          return m_extShaderTextureLOD.get();
      }
      ENABLE_IF_REQUESTED(EXTTextureFilterAnisotropic, m_extTextureFilterAnisotropic, &quot;EXT_texture_filter_anisotropic&quot;, enableSupportedExtension(&quot;GL_EXT_texture_filter_anisotropic&quot;_s));
<span class="line-removed">-     ENABLE_IF_REQUESTED(EXTTextureFilterAnisotropic, m_extTextureFilterAnisotropic, &quot;WEBKIT_EXT_texture_filter_anisotropic&quot;, enableSupportedExtension(&quot;GL_EXT_texture_filter_anisotropic&quot;_s));</span>
      ENABLE_IF_REQUESTED(OESStandardDerivatives, m_oesStandardDerivatives, &quot;OES_standard_derivatives&quot;, enableSupportedExtension(&quot;GL_OES_standard_derivatives&quot;_s));
      ENABLE_IF_REQUESTED(OESTextureFloat, m_oesTextureFloat, &quot;OES_texture_float&quot;, enableSupportedExtension(&quot;GL_OES_texture_float&quot;_s));
      ENABLE_IF_REQUESTED(OESTextureFloatLinear, m_oesTextureFloatLinear, &quot;OES_texture_float_linear&quot;, enableSupportedExtension(&quot;GL_OES_texture_float_linear&quot;_s));
      ENABLE_IF_REQUESTED(OESTextureHalfFloat, m_oesTextureHalfFloat, &quot;OES_texture_half_float&quot;, enableSupportedExtension(&quot;GL_OES_texture_half_float&quot;_s));
      ENABLE_IF_REQUESTED(OESTextureHalfFloatLinear, m_oesTextureHalfFloatLinear, &quot;OES_texture_half_float_linear&quot;, enableSupportedExtension(&quot;GL_OES_texture_half_float_linear&quot;_s));
      ENABLE_IF_REQUESTED(OESVertexArrayObject, m_oesVertexArrayObject, &quot;OES_vertex_array_object&quot;, enableSupportedExtension(&quot;GL_OES_vertex_array_object&quot;_s));
      ENABLE_IF_REQUESTED(OESElementIndexUint, m_oesElementIndexUint, &quot;OES_element_index_uint&quot;, enableSupportedExtension(&quot;GL_OES_element_index_uint&quot;_s));
      ENABLE_IF_REQUESTED(WebGLLoseContext, m_webglLoseContext, &quot;WEBGL_lose_context&quot;, true);
      ENABLE_IF_REQUESTED(WebGLCompressedTextureATC, m_webglCompressedTextureATC, &quot;WEBKIT_WEBGL_compressed_texture_atc&quot;, WebGLCompressedTextureATC::supported(*this));
      ENABLE_IF_REQUESTED(WebGLCompressedTexturePVRTC, m_webglCompressedTexturePVRTC, &quot;WEBKIT_WEBGL_compressed_texture_pvrtc&quot;, WebGLCompressedTexturePVRTC::supported(*this));
      ENABLE_IF_REQUESTED(WebGLCompressedTextureS3TC, m_webglCompressedTextureS3TC, &quot;WEBGL_compressed_texture_s3tc&quot;, WebGLCompressedTextureS3TC::supported(*this));
<span class="line-removed">-     ENABLE_IF_REQUESTED(WebGLCompressedTextureASTC, m_webglCompressedTextureASTC, &quot;WEBGL_compressed_texture_astc&quot;, WebGLCompressedTextureASTC::supported(*this));</span>
      ENABLE_IF_REQUESTED(WebGLDepthTexture, m_webglDepthTexture, &quot;WEBGL_depth_texture&quot;, WebGLDepthTexture::supported(*m_context));
      if (equalIgnoringASCIICase(name, &quot;WEBGL_draw_buffers&quot;)) {
          if (!m_webglDrawBuffers) {
              if (!supportsDrawBuffers())
                  m_webglDrawBuffers = nullptr;
<span class="line-new-header">--- 139,24 ---</span>
              }
          }
          return m_extShaderTextureLOD.get();
      }
      ENABLE_IF_REQUESTED(EXTTextureFilterAnisotropic, m_extTextureFilterAnisotropic, &quot;EXT_texture_filter_anisotropic&quot;, enableSupportedExtension(&quot;GL_EXT_texture_filter_anisotropic&quot;_s));
      ENABLE_IF_REQUESTED(OESStandardDerivatives, m_oesStandardDerivatives, &quot;OES_standard_derivatives&quot;, enableSupportedExtension(&quot;GL_OES_standard_derivatives&quot;_s));
      ENABLE_IF_REQUESTED(OESTextureFloat, m_oesTextureFloat, &quot;OES_texture_float&quot;, enableSupportedExtension(&quot;GL_OES_texture_float&quot;_s));
      ENABLE_IF_REQUESTED(OESTextureFloatLinear, m_oesTextureFloatLinear, &quot;OES_texture_float_linear&quot;, enableSupportedExtension(&quot;GL_OES_texture_float_linear&quot;_s));
      ENABLE_IF_REQUESTED(OESTextureHalfFloat, m_oesTextureHalfFloat, &quot;OES_texture_half_float&quot;, enableSupportedExtension(&quot;GL_OES_texture_half_float&quot;_s));
      ENABLE_IF_REQUESTED(OESTextureHalfFloatLinear, m_oesTextureHalfFloatLinear, &quot;OES_texture_half_float_linear&quot;, enableSupportedExtension(&quot;GL_OES_texture_half_float_linear&quot;_s));
      ENABLE_IF_REQUESTED(OESVertexArrayObject, m_oesVertexArrayObject, &quot;OES_vertex_array_object&quot;, enableSupportedExtension(&quot;GL_OES_vertex_array_object&quot;_s));
      ENABLE_IF_REQUESTED(OESElementIndexUint, m_oesElementIndexUint, &quot;OES_element_index_uint&quot;, enableSupportedExtension(&quot;GL_OES_element_index_uint&quot;_s));
      ENABLE_IF_REQUESTED(WebGLLoseContext, m_webglLoseContext, &quot;WEBGL_lose_context&quot;, true);
<span class="line-added">+     ENABLE_IF_REQUESTED(WebGLCompressedTextureASTC, m_webglCompressedTextureASTC, &quot;WEBGL_compressed_texture_astc&quot;, WebGLCompressedTextureASTC::supported(*this));</span>
      ENABLE_IF_REQUESTED(WebGLCompressedTextureATC, m_webglCompressedTextureATC, &quot;WEBKIT_WEBGL_compressed_texture_atc&quot;, WebGLCompressedTextureATC::supported(*this));
<span class="line-added">+     ENABLE_IF_REQUESTED(WebGLCompressedTextureETC, m_webglCompressedTextureETC, &quot;WEBGL_compressed_texture_etc&quot;, WebGLCompressedTextureETC::supported(*this));</span>
<span class="line-added">+     ENABLE_IF_REQUESTED(WebGLCompressedTextureETC1, m_webglCompressedTextureETC1, &quot;WEBGL_compressed_texture_etc1&quot;, WebGLCompressedTextureETC1::supported(*this));</span>
      ENABLE_IF_REQUESTED(WebGLCompressedTexturePVRTC, m_webglCompressedTexturePVRTC, &quot;WEBKIT_WEBGL_compressed_texture_pvrtc&quot;, WebGLCompressedTexturePVRTC::supported(*this));
      ENABLE_IF_REQUESTED(WebGLCompressedTextureS3TC, m_webglCompressedTextureS3TC, &quot;WEBGL_compressed_texture_s3tc&quot;, WebGLCompressedTextureS3TC::supported(*this));
      ENABLE_IF_REQUESTED(WebGLDepthTexture, m_webglDepthTexture, &quot;WEBGL_depth_texture&quot;, WebGLDepthTexture::supported(*m_context));
      if (equalIgnoringASCIICase(name, &quot;WEBGL_draw_buffers&quot;)) {
          if (!m_webglDrawBuffers) {
              if (!supportsDrawBuffers())
                  m_webglDrawBuffers = nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 215,18 ***</span>
      if (m_context-&gt;getExtensions().supports(&quot;GL_OES_vertex_array_object&quot;_s))
          result.append(&quot;OES_vertex_array_object&quot;_s);
      if (m_context-&gt;getExtensions().supports(&quot;GL_OES_element_index_uint&quot;_s))
          result.append(&quot;OES_element_index_uint&quot;_s);
      result.append(&quot;WEBGL_lose_context&quot;_s);
      if (WebGLCompressedTextureATC::supported(*this))
          result.append(&quot;WEBKIT_WEBGL_compressed_texture_atc&quot;_s);
      if (WebGLCompressedTexturePVRTC::supported(*this))
          result.append(&quot;WEBKIT_WEBGL_compressed_texture_pvrtc&quot;_s);
      if (WebGLCompressedTextureS3TC::supported(*this))
          result.append(&quot;WEBGL_compressed_texture_s3tc&quot;_s);
<span class="line-removed">-     if (WebGLCompressedTextureASTC::supported(*this))</span>
<span class="line-removed">-         result.append(&quot;WEBGL_compressed_texture_astc&quot;_s);</span>
      if (WebGLDepthTexture::supported(*m_context))
          result.append(&quot;WEBGL_depth_texture&quot;_s);
      if (supportsDrawBuffers())
          result.append(&quot;WEBGL_draw_buffers&quot;_s);
      if (ANGLEInstancedArrays::supported(*this))
<span class="line-new-header">--- 218,22 ---</span>
      if (m_context-&gt;getExtensions().supports(&quot;GL_OES_vertex_array_object&quot;_s))
          result.append(&quot;OES_vertex_array_object&quot;_s);
      if (m_context-&gt;getExtensions().supports(&quot;GL_OES_element_index_uint&quot;_s))
          result.append(&quot;OES_element_index_uint&quot;_s);
      result.append(&quot;WEBGL_lose_context&quot;_s);
<span class="line-added">+     if (WebGLCompressedTextureASTC::supported(*this))</span>
<span class="line-added">+         result.append(&quot;WEBGL_compressed_texture_astc&quot;_s);</span>
      if (WebGLCompressedTextureATC::supported(*this))
          result.append(&quot;WEBKIT_WEBGL_compressed_texture_atc&quot;_s);
<span class="line-added">+     if (WebGLCompressedTextureETC::supported(*this))</span>
<span class="line-added">+         result.append(&quot;WEBGL_compressed_texture_etc&quot;_s);</span>
<span class="line-added">+     if (WebGLCompressedTextureETC1::supported(*this))</span>
<span class="line-added">+         result.append(&quot;WEBGL_compressed_texture_etc1&quot;_s);</span>
      if (WebGLCompressedTexturePVRTC::supported(*this))
          result.append(&quot;WEBKIT_WEBGL_compressed_texture_pvrtc&quot;_s);
      if (WebGLCompressedTextureS3TC::supported(*this))
          result.append(&quot;WEBGL_compressed_texture_s3tc&quot;_s);
      if (WebGLDepthTexture::supported(*m_context))
          result.append(&quot;WEBGL_depth_texture&quot;_s);
      if (supportsDrawBuffers())
          result.append(&quot;WEBGL_draw_buffers&quot;_s);
      if (ANGLEInstancedArrays::supported(*this))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 236,449 ***</span>
      result.append(&quot;WEBGL_debug_renderer_info&quot;_s);
  
      return result;
  }
  
<span class="line-modified">! WebGLAny WebGLRenderingContext::getFramebufferAttachmentParameter(GC3Denum target, GC3Denum attachment, GC3Denum pname)</span>
  {
      if (isContextLostOrPending() || !validateFramebufferFuncParameters(&quot;getFramebufferAttachmentParameter&quot;, target, attachment))
          return nullptr;
  
      if (!m_framebufferBinding || !m_framebufferBinding-&gt;object()) {
<span class="line-modified">!         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getFramebufferAttachmentParameter&quot;, &quot;no framebuffer bound&quot;);</span>
          return nullptr;
      }
  
      auto object = makeRefPtr(m_framebufferBinding-&gt;getAttachmentObject(attachment));
      if (!object) {
<span class="line-modified">!         if (pname == GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE)</span>
<span class="line-modified">!             return static_cast&lt;unsigned&gt;(GraphicsContext3D::NONE);</span>
          // OpenGL ES 2.0 specifies INVALID_ENUM in this case, while desktop GL
          // specifies INVALID_OPERATION.
<span class="line-modified">!         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getFramebufferAttachmentParameter&quot;, &quot;invalid parameter name&quot;);</span>
          return nullptr;
      }
  
      if (object-&gt;isTexture()) {
          switch (pname) {
<span class="line-modified">!         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:</span>
<span class="line-modified">!             return static_cast&lt;unsigned&gt;(GraphicsContext3D::TEXTURE);</span>
<span class="line-modified">!         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:</span>
              return makeRefPtr(reinterpret_cast&lt;WebGLTexture&amp;&gt;(*object));
<span class="line-modified">!         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:</span>
<span class="line-modified">!         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:</span>
<span class="line-modified">!         case Extensions3D::FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: {</span>
<span class="line-modified">!             GC3Dint value = 0;</span>
              m_context-&gt;getFramebufferAttachmentParameteriv(target, attachment, pname, &amp;value);
              return value;
          }
          default:
<span class="line-modified">!             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getFramebufferAttachmentParameter&quot;, &quot;invalid parameter name for texture attachment&quot;);</span>
              return nullptr;
          }
      } else {
          ASSERT(object-&gt;isRenderbuffer());
          switch (pname) {
<span class="line-modified">!         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:</span>
<span class="line-modified">!             return static_cast&lt;unsigned&gt;(GraphicsContext3D::RENDERBUFFER);</span>
<span class="line-modified">!         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:</span>
              return makeRefPtr(reinterpret_cast&lt;WebGLRenderbuffer&amp;&gt;(*object));
<span class="line-modified">!         case Extensions3D::FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: {</span>
              if (!m_extsRGB) {
<span class="line-modified">!                 synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getFramebufferAttachmentParameter&quot;, &quot;invalid parameter name for renderbuffer attachment&quot;);</span>
                  return nullptr;
              }
              RefPtr&lt;WebGLRenderbuffer&gt; renderBuffer = reinterpret_cast&lt;WebGLRenderbuffer*&gt;(object.get());
<span class="line-modified">!             GC3Denum renderBufferFormat = renderBuffer-&gt;getInternalFormat();</span>
<span class="line-modified">!             ASSERT(renderBufferFormat != Extensions3D::SRGB_EXT &amp;&amp; renderBufferFormat != Extensions3D::SRGB_ALPHA_EXT);</span>
<span class="line-modified">!             if (renderBufferFormat == Extensions3D::SRGB8_ALPHA8_EXT)</span>
<span class="line-modified">!                 return static_cast&lt;unsigned&gt;(Extensions3D::SRGB_EXT);</span>
<span class="line-modified">!             return static_cast&lt;unsigned&gt;(GraphicsContext3D::LINEAR);</span>
          }
          default:
<span class="line-modified">!             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getFramebufferAttachmentParameter&quot;, &quot;invalid parameter name for renderbuffer attachment&quot;);</span>
              return nullptr;
          }
      }
  }
  
<span class="line-modified">! bool WebGLRenderingContext::validateFramebufferFuncParameters(const char* functionName, GC3Denum target, GC3Denum attachment)</span>
  {
<span class="line-modified">!     if (target != GraphicsContext3D::FRAMEBUFFER) {</span>
<span class="line-modified">!         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid target&quot;);</span>
          return false;
      }
      // FIXME: Why does this return true unconditionally for COLOR_ATTACHMENT0,
      // but false for other COLOR_ATTACHMENT values if m_webglDrawBuffers is false?
      switch (attachment) {
<span class="line-modified">!     case GraphicsContext3D::COLOR_ATTACHMENT0:</span>
<span class="line-modified">!     case GraphicsContext3D::DEPTH_ATTACHMENT:</span>
<span class="line-modified">!     case GraphicsContext3D::STENCIL_ATTACHMENT:</span>
<span class="line-modified">!     case GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT:</span>
          return true;
      default:
          if (m_webglDrawBuffers
<span class="line-modified">!             &amp;&amp; attachment &gt;= GraphicsContext3D::COLOR_ATTACHMENT0</span>
<span class="line-modified">!             &amp;&amp; attachment &lt; static_cast&lt;GC3Denum&gt;(GraphicsContext3D::COLOR_ATTACHMENT0 + getMaxColorAttachments()))</span>
              return true;
<span class="line-modified">!         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid attachment&quot;);</span>
          return false;
      }
  }
  
<span class="line-modified">! void WebGLRenderingContext::renderbufferStorage(GC3Denum target, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height)</span>
  {
      if (isContextLostOrPending())
          return;
<span class="line-modified">!     if (target != GraphicsContext3D::RENDERBUFFER) {</span>
<span class="line-modified">!         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid target&quot;);</span>
          return;
      }
      if (!m_renderbufferBinding || !m_renderbufferBinding-&gt;object()) {
<span class="line-modified">!         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;renderbufferStorage&quot;, &quot;no bound renderbuffer&quot;);</span>
          return;
      }
      if (!validateSize(&quot;renderbufferStorage&quot;, width, height))
          return;
      switch (internalformat) {
<span class="line-modified">!     case GraphicsContext3D::DEPTH_COMPONENT16:</span>
<span class="line-modified">!     case GraphicsContext3D::RGBA4:</span>
<span class="line-modified">!     case GraphicsContext3D::RGB5_A1:</span>
<span class="line-modified">!     case GraphicsContext3D::RGB565:</span>
<span class="line-modified">!     case GraphicsContext3D::STENCIL_INDEX8:</span>
<span class="line-modified">!     case Extensions3D::SRGB8_ALPHA8_EXT:</span>
<span class="line-modified">!         if (internalformat == Extensions3D::SRGB8_ALPHA8_EXT &amp;&amp; !m_extsRGB) {</span>
<span class="line-modified">!             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid internalformat&quot;);</span>
              return;
          }
          m_context-&gt;renderbufferStorage(target, internalformat, width, height);
          m_renderbufferBinding-&gt;setInternalFormat(internalformat);
          m_renderbufferBinding-&gt;setIsValid(true);
          m_renderbufferBinding-&gt;setSize(width, height);
          break;
<span class="line-modified">!     case GraphicsContext3D::DEPTH_STENCIL:</span>
          if (isDepthStencilSupported())
<span class="line-modified">!             m_context-&gt;renderbufferStorage(target, Extensions3D::DEPTH24_STENCIL8, width, height);</span>
          m_renderbufferBinding-&gt;setSize(width, height);
          m_renderbufferBinding-&gt;setIsValid(isDepthStencilSupported());
          m_renderbufferBinding-&gt;setInternalFormat(internalformat);
          break;
      default:
<span class="line-modified">!         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid internalformat&quot;);</span>
          return;
      }
      applyStencilTest();
  }
  
<span class="line-modified">! void WebGLRenderingContext::hint(GC3Denum target, GC3Denum mode)</span>
  {
      if (isContextLostOrPending())
          return;
      bool isValid = false;
      switch (target) {
<span class="line-modified">!     case GraphicsContext3D::GENERATE_MIPMAP_HINT:</span>
          isValid = true;
          break;
<span class="line-modified">!     case Extensions3D::FRAGMENT_SHADER_DERIVATIVE_HINT_OES: // OES_standard_derivatives</span>
          if (m_oesStandardDerivatives)
              isValid = true;
          break;
      }
      if (!isValid) {
<span class="line-modified">!         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;hint&quot;, &quot;invalid target&quot;);</span>
          return;
      }
      m_context-&gt;hint(target, mode);
  }
  
<span class="line-modified">! void WebGLRenderingContext::clear(GC3Dbitfield mask)</span>
  {
      if (isContextLostOrPending())
          return;
<span class="line-modified">!     if (mask &amp; ~(GraphicsContext3D::COLOR_BUFFER_BIT | GraphicsContext3D::DEPTH_BUFFER_BIT | GraphicsContext3D::STENCIL_BUFFER_BIT)) {</span>
<span class="line-modified">!         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;clear&quot;, &quot;invalid mask&quot;);</span>
          return;
      }
      const char* reason = &quot;framebuffer incomplete&quot;;
      if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(m_context.get(), &amp;reason)) {
<span class="line-modified">!         synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, &quot;clear&quot;, reason);</span>
          return;
      }
      if (!clearIfComposited(mask))
          m_context-&gt;clear(mask);
      markContextChangedAndNotifyCanvasObserver();
  }
  
<span class="line-modified">! WebGLAny WebGLRenderingContext::getParameter(GC3Denum pname)</span>
  {
      if (isContextLostOrPending())
          return nullptr;
  
      switch (pname) {
<span class="line-modified">!     case GraphicsContext3D::ACTIVE_TEXTURE:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::ALIASED_LINE_WIDTH_RANGE:</span>
          return getWebGLFloatArrayParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::ALIASED_POINT_SIZE_RANGE:</span>
          return getWebGLFloatArrayParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::ALPHA_BITS:</span>
          if (!m_framebufferBinding &amp;&amp; !m_attributes.alpha)
              return 0;
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::ARRAY_BUFFER_BINDING:</span>
          return m_boundArrayBuffer;
<span class="line-modified">!     case GraphicsContext3D::BLEND:</span>
          return getBooleanParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::BLEND_COLOR:</span>
          return getWebGLFloatArrayParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::BLEND_DST_ALPHA:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::BLEND_DST_RGB:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::BLEND_EQUATION_ALPHA:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::BLEND_EQUATION_RGB:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::BLEND_SRC_ALPHA:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::BLEND_SRC_RGB:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::BLUE_BITS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::COLOR_CLEAR_VALUE:</span>
          return getWebGLFloatArrayParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::COLOR_WRITEMASK:</span>
          return getBooleanArrayParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::COMPRESSED_TEXTURE_FORMATS:</span>
          return Uint32Array::tryCreate(m_compressedTextureFormats.data(), m_compressedTextureFormats.size());
<span class="line-modified">!     case GraphicsContext3D::CULL_FACE:</span>
          return getBooleanParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::CULL_FACE_MODE:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::CURRENT_PROGRAM:</span>
          return m_currentProgram;
<span class="line-modified">!     case GraphicsContext3D::DEPTH_BITS:</span>
          if (!m_framebufferBinding &amp;&amp; !m_attributes.depth)
              return 0;
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::DEPTH_CLEAR_VALUE:</span>
          return getFloatParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::DEPTH_FUNC:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::DEPTH_RANGE:</span>
          return getWebGLFloatArrayParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::DEPTH_TEST:</span>
          return getBooleanParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::DEPTH_WRITEMASK:</span>
          return getBooleanParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::DITHER:</span>
          return getBooleanParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::ELEMENT_ARRAY_BUFFER_BINDING:</span>
          return makeRefPtr(m_boundVertexArrayObject-&gt;getElementArrayBuffer());
<span class="line-modified">!     case GraphicsContext3D::FRAMEBUFFER_BINDING:</span>
          return m_framebufferBinding;
<span class="line-modified">!     case GraphicsContext3D::FRONT_FACE:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::GENERATE_MIPMAP_HINT:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::GREEN_BITS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::IMPLEMENTATION_COLOR_READ_FORMAT:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::IMPLEMENTATION_COLOR_READ_TYPE:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::LINE_WIDTH:</span>
          return getFloatParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::MAX_COMBINED_TEXTURE_IMAGE_UNITS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::MAX_CUBE_MAP_TEXTURE_SIZE:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::MAX_FRAGMENT_UNIFORM_VECTORS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::MAX_RENDERBUFFER_SIZE:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::MAX_TEXTURE_IMAGE_UNITS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::MAX_TEXTURE_SIZE:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::MAX_VARYING_VECTORS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::MAX_VERTEX_ATTRIBS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::MAX_VERTEX_TEXTURE_IMAGE_UNITS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::MAX_VERTEX_UNIFORM_VECTORS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::MAX_VIEWPORT_DIMS:</span>
          return getWebGLIntArrayParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::NUM_SHADER_BINARY_FORMATS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::PACK_ALIGNMENT:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::POLYGON_OFFSET_FACTOR:</span>
          return getFloatParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::POLYGON_OFFSET_FILL:</span>
          return getBooleanParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::POLYGON_OFFSET_UNITS:</span>
          return getFloatParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::RED_BITS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::RENDERBUFFER_BINDING:</span>
          return m_renderbufferBinding;
<span class="line-modified">!     case GraphicsContext3D::RENDERER:</span>
          return &quot;WebKit WebGL&quot;_str;
<span class="line-modified">!     case GraphicsContext3D::SAMPLE_BUFFERS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::SAMPLE_COVERAGE_INVERT:</span>
          return getBooleanParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::SAMPLE_COVERAGE_VALUE:</span>
          return getFloatParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::SAMPLES:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::SCISSOR_BOX:</span>
          return getWebGLIntArrayParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::SCISSOR_TEST:</span>
          return getBooleanParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::SHADING_LANGUAGE_VERSION:</span>
<span class="line-modified">!         return &quot;WebGL GLSL ES 1.0 (&quot; + m_context-&gt;getString(GraphicsContext3D::SHADING_LANGUAGE_VERSION) + &quot;)&quot;;</span>
<span class="line-modified">!     case GraphicsContext3D::STENCIL_BACK_FAIL:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::STENCIL_BACK_FUNC:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::STENCIL_BACK_PASS_DEPTH_FAIL:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::STENCIL_BACK_PASS_DEPTH_PASS:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::STENCIL_BACK_REF:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::STENCIL_BACK_VALUE_MASK:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::STENCIL_BACK_WRITEMASK:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::STENCIL_BITS:</span>
          if (!m_framebufferBinding &amp;&amp; !m_attributes.stencil)
              return 0;
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::STENCIL_CLEAR_VALUE:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::STENCIL_FAIL:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::STENCIL_FUNC:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::STENCIL_PASS_DEPTH_FAIL:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::STENCIL_PASS_DEPTH_PASS:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::STENCIL_REF:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::STENCIL_TEST:</span>
          return getBooleanParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::STENCIL_VALUE_MASK:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::STENCIL_WRITEMASK:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::SUBPIXEL_BITS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::TEXTURE_BINDING_2D:</span>
          return m_textureUnits[m_activeTextureUnit].texture2DBinding;
<span class="line-modified">!     case GraphicsContext3D::TEXTURE_BINDING_CUBE_MAP:</span>
          return m_textureUnits[m_activeTextureUnit].textureCubeMapBinding;
<span class="line-modified">!     case GraphicsContext3D::UNPACK_ALIGNMENT:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContext3D::UNPACK_FLIP_Y_WEBGL:</span>
          return m_unpackFlipY;
<span class="line-modified">!     case GraphicsContext3D::UNPACK_PREMULTIPLY_ALPHA_WEBGL:</span>
          return m_unpackPremultiplyAlpha;
<span class="line-modified">!     case GraphicsContext3D::UNPACK_COLORSPACE_CONVERSION_WEBGL:</span>
          return m_unpackColorspaceConversion;
<span class="line-modified">!     case GraphicsContext3D::VENDOR:</span>
          return &quot;WebKit&quot;_str;
<span class="line-modified">!     case GraphicsContext3D::VERSION:</span>
          return &quot;WebGL 1.0&quot;_str;
<span class="line-modified">!     case GraphicsContext3D::VIEWPORT:</span>
          return getWebGLIntArrayParameter(pname);
<span class="line-modified">!     case Extensions3D::FRAGMENT_SHADER_DERIVATIVE_HINT_OES: // OES_standard_derivatives</span>
          if (m_oesStandardDerivatives)
<span class="line-modified">!             return getUnsignedIntParameter(Extensions3D::FRAGMENT_SHADER_DERIVATIVE_HINT_OES);</span>
<span class="line-modified">!         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, OES_standard_derivatives not enabled&quot;);</span>
          return nullptr;
      case WebGLDebugRendererInfo::UNMASKED_RENDERER_WEBGL:
          if (m_webglDebugRendererInfo) {
  #if PLATFORM(IOS_FAMILY)
              return &quot;Apple GPU&quot;_str;
  #else
<span class="line-modified">!             return m_context-&gt;getString(GraphicsContext3D::RENDERER);</span>
  #endif
          }
<span class="line-modified">!         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_debug_renderer_info not enabled&quot;);</span>
          return nullptr;
      case WebGLDebugRendererInfo::UNMASKED_VENDOR_WEBGL:
          if (m_webglDebugRendererInfo)
<span class="line-modified">!             return m_context-&gt;getString(GraphicsContext3D::VENDOR);</span>
<span class="line-modified">!         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_debug_renderer_info not enabled&quot;);</span>
          return nullptr;
<span class="line-modified">!     case Extensions3D::VERTEX_ARRAY_BINDING_OES: // OES_vertex_array_object</span>
          if (m_oesVertexArrayObject) {
              if (m_boundVertexArrayObject-&gt;isDefaultObject())
                  return nullptr;
              return makeRefPtr(static_cast&lt;WebGLVertexArrayObjectOES&amp;&gt;(*m_boundVertexArrayObject));
          }
<span class="line-modified">!         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, OES_vertex_array_object not enabled&quot;);</span>
          return nullptr;
<span class="line-modified">!     case Extensions3D::MAX_TEXTURE_MAX_ANISOTROPY_EXT: // EXT_texture_filter_anisotropic</span>
          if (m_extTextureFilterAnisotropic)
<span class="line-modified">!             return getUnsignedIntParameter(Extensions3D::MAX_TEXTURE_MAX_ANISOTROPY_EXT);</span>
<span class="line-modified">!         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, EXT_texture_filter_anisotropic not enabled&quot;);</span>
          return nullptr;
<span class="line-modified">!     case Extensions3D::MAX_COLOR_ATTACHMENTS_EXT: // EXT_draw_buffers BEGIN</span>
          if (m_webglDrawBuffers)
              return getMaxColorAttachments();
<span class="line-modified">!         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_draw_buffers not enabled&quot;);</span>
          return nullptr;
<span class="line-modified">!     case Extensions3D::MAX_DRAW_BUFFERS_EXT:</span>
          if (m_webglDrawBuffers)
              return getMaxDrawBuffers();
<span class="line-modified">!         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_draw_buffers not enabled&quot;);</span>
          return nullptr;
      default:
          if (m_webglDrawBuffers
<span class="line-modified">!             &amp;&amp; pname &gt;= Extensions3D::DRAW_BUFFER0_EXT</span>
<span class="line-modified">!             &amp;&amp; pname &lt; static_cast&lt;GC3Denum&gt;(Extensions3D::DRAW_BUFFER0_EXT + getMaxDrawBuffers())) {</span>
<span class="line-modified">!             GC3Dint value = GraphicsContext3D::NONE;</span>
              if (m_framebufferBinding)
                  value = m_framebufferBinding-&gt;getDrawBuffer(pname);
              else // emulated backbuffer
                  value = m_backDrawBuffer;
              return value;
          }
<span class="line-modified">!         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name&quot;);</span>
          return nullptr;
      }
  }
  
<span class="line-modified">! GC3Dint WebGLRenderingContext::getMaxDrawBuffers()</span>
  {
      if (!supportsDrawBuffers())
          return 0;
      if (!m_maxDrawBuffers)
<span class="line-modified">!         m_context-&gt;getIntegerv(Extensions3D::MAX_DRAW_BUFFERS_EXT, &amp;m_maxDrawBuffers);</span>
      if (!m_maxColorAttachments)
<span class="line-modified">!         m_context-&gt;getIntegerv(Extensions3D::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);</span>
      // WEBGL_draw_buffers requires MAX_COLOR_ATTACHMENTS &gt;= MAX_DRAW_BUFFERS.
      return std::min(m_maxDrawBuffers, m_maxColorAttachments);
  }
  
<span class="line-modified">! GC3Dint WebGLRenderingContext::getMaxColorAttachments()</span>
  {
      if (!supportsDrawBuffers())
          return 0;
      if (!m_maxColorAttachments)
<span class="line-modified">!         m_context-&gt;getIntegerv(Extensions3D::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);</span>
      return m_maxColorAttachments;
  }
  
<span class="line-modified">! bool WebGLRenderingContext::validateIndexArrayConservative(GC3Denum type, unsigned&amp; numElementsRequired)</span>
  {
      // Performs conservative validation by caching a maximum index of
      // the given type per element array buffer. If all of the bound
      // array buffers have enough elements to satisfy that maximum
      // index, skips the expensive per-draw-call iteration in
<span class="line-new-header">--- 243,449 ---</span>
      result.append(&quot;WEBGL_debug_renderer_info&quot;_s);
  
      return result;
  }
  
<span class="line-modified">! WebGLAny WebGLRenderingContext::getFramebufferAttachmentParameter(GCGLenum target, GCGLenum attachment, GCGLenum pname)</span>
  {
      if (isContextLostOrPending() || !validateFramebufferFuncParameters(&quot;getFramebufferAttachmentParameter&quot;, target, attachment))
          return nullptr;
  
      if (!m_framebufferBinding || !m_framebufferBinding-&gt;object()) {
<span class="line-modified">!         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getFramebufferAttachmentParameter&quot;, &quot;no framebuffer bound&quot;);</span>
          return nullptr;
      }
  
      auto object = makeRefPtr(m_framebufferBinding-&gt;getAttachmentObject(attachment));
      if (!object) {
<span class="line-modified">!         if (pname == GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE)</span>
<span class="line-modified">!             return static_cast&lt;unsigned&gt;(GraphicsContextGL::NONE);</span>
          // OpenGL ES 2.0 specifies INVALID_ENUM in this case, while desktop GL
          // specifies INVALID_OPERATION.
<span class="line-modified">!         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getFramebufferAttachmentParameter&quot;, &quot;invalid parameter name&quot;);</span>
          return nullptr;
      }
  
      if (object-&gt;isTexture()) {
          switch (pname) {
<span class="line-modified">!         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:</span>
<span class="line-modified">!             return static_cast&lt;unsigned&gt;(GraphicsContextGL::TEXTURE);</span>
<span class="line-modified">!         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:</span>
              return makeRefPtr(reinterpret_cast&lt;WebGLTexture&amp;&gt;(*object));
<span class="line-modified">!         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:</span>
<span class="line-modified">!         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:</span>
<span class="line-modified">!         case ExtensionsGL::FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: {</span>
<span class="line-modified">!             GCGLint value = 0;</span>
              m_context-&gt;getFramebufferAttachmentParameteriv(target, attachment, pname, &amp;value);
              return value;
          }
          default:
<span class="line-modified">!             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getFramebufferAttachmentParameter&quot;, &quot;invalid parameter name for texture attachment&quot;);</span>
              return nullptr;
          }
      } else {
          ASSERT(object-&gt;isRenderbuffer());
          switch (pname) {
<span class="line-modified">!         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:</span>
<span class="line-modified">!             return static_cast&lt;unsigned&gt;(GraphicsContextGL::RENDERBUFFER);</span>
<span class="line-modified">!         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:</span>
              return makeRefPtr(reinterpret_cast&lt;WebGLRenderbuffer&amp;&gt;(*object));
<span class="line-modified">!         case ExtensionsGL::FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: {</span>
              if (!m_extsRGB) {
<span class="line-modified">!                 synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getFramebufferAttachmentParameter&quot;, &quot;invalid parameter name for renderbuffer attachment&quot;);</span>
                  return nullptr;
              }
              RefPtr&lt;WebGLRenderbuffer&gt; renderBuffer = reinterpret_cast&lt;WebGLRenderbuffer*&gt;(object.get());
<span class="line-modified">!             GCGLenum renderBufferFormat = renderBuffer-&gt;getInternalFormat();</span>
<span class="line-modified">!             ASSERT(renderBufferFormat != ExtensionsGL::SRGB_EXT &amp;&amp; renderBufferFormat != ExtensionsGL::SRGB_ALPHA_EXT);</span>
<span class="line-modified">!             if (renderBufferFormat == ExtensionsGL::SRGB8_ALPHA8_EXT)</span>
<span class="line-modified">!                 return static_cast&lt;unsigned&gt;(ExtensionsGL::SRGB_EXT);</span>
<span class="line-modified">!             return static_cast&lt;unsigned&gt;(GraphicsContextGL::LINEAR);</span>
          }
          default:
<span class="line-modified">!             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getFramebufferAttachmentParameter&quot;, &quot;invalid parameter name for renderbuffer attachment&quot;);</span>
              return nullptr;
          }
      }
  }
  
<span class="line-modified">! bool WebGLRenderingContext::validateFramebufferFuncParameters(const char* functionName, GCGLenum target, GCGLenum attachment)</span>
  {
<span class="line-modified">!     if (target != GraphicsContextGL::FRAMEBUFFER) {</span>
<span class="line-modified">!         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid target&quot;);</span>
          return false;
      }
      // FIXME: Why does this return true unconditionally for COLOR_ATTACHMENT0,
      // but false for other COLOR_ATTACHMENT values if m_webglDrawBuffers is false?
      switch (attachment) {
<span class="line-modified">!     case GraphicsContextGL::COLOR_ATTACHMENT0:</span>
<span class="line-modified">!     case GraphicsContextGL::DEPTH_ATTACHMENT:</span>
<span class="line-modified">!     case GraphicsContextGL::STENCIL_ATTACHMENT:</span>
<span class="line-modified">!     case GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT:</span>
          return true;
      default:
          if (m_webglDrawBuffers
<span class="line-modified">!             &amp;&amp; attachment &gt;= GraphicsContextGL::COLOR_ATTACHMENT0</span>
<span class="line-modified">!             &amp;&amp; attachment &lt; static_cast&lt;GCGLenum&gt;(GraphicsContextGL::COLOR_ATTACHMENT0 + getMaxColorAttachments()))</span>
              return true;
<span class="line-modified">!         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid attachment&quot;);</span>
          return false;
      }
  }
  
<span class="line-modified">! void WebGLRenderingContext::renderbufferStorage(GCGLenum target, GCGLenum internalformat, GCGLsizei width, GCGLsizei height)</span>
  {
      if (isContextLostOrPending())
          return;
<span class="line-modified">!     if (target != GraphicsContextGL::RENDERBUFFER) {</span>
<span class="line-modified">!         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid target&quot;);</span>
          return;
      }
      if (!m_renderbufferBinding || !m_renderbufferBinding-&gt;object()) {
<span class="line-modified">!         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;renderbufferStorage&quot;, &quot;no bound renderbuffer&quot;);</span>
          return;
      }
      if (!validateSize(&quot;renderbufferStorage&quot;, width, height))
          return;
      switch (internalformat) {
<span class="line-modified">!     case GraphicsContextGL::DEPTH_COMPONENT16:</span>
<span class="line-modified">!     case GraphicsContextGL::RGBA4:</span>
<span class="line-modified">!     case GraphicsContextGL::RGB5_A1:</span>
<span class="line-modified">!     case GraphicsContextGL::RGB565:</span>
<span class="line-modified">!     case GraphicsContextGL::STENCIL_INDEX8:</span>
<span class="line-modified">!     case ExtensionsGL::SRGB8_ALPHA8_EXT:</span>
<span class="line-modified">!         if (internalformat == ExtensionsGL::SRGB8_ALPHA8_EXT &amp;&amp; !m_extsRGB) {</span>
<span class="line-modified">!             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid internalformat&quot;);</span>
              return;
          }
          m_context-&gt;renderbufferStorage(target, internalformat, width, height);
          m_renderbufferBinding-&gt;setInternalFormat(internalformat);
          m_renderbufferBinding-&gt;setIsValid(true);
          m_renderbufferBinding-&gt;setSize(width, height);
          break;
<span class="line-modified">!     case GraphicsContextGL::DEPTH_STENCIL:</span>
          if (isDepthStencilSupported())
<span class="line-modified">!             m_context-&gt;renderbufferStorage(target, ExtensionsGL::DEPTH24_STENCIL8, width, height);</span>
          m_renderbufferBinding-&gt;setSize(width, height);
          m_renderbufferBinding-&gt;setIsValid(isDepthStencilSupported());
          m_renderbufferBinding-&gt;setInternalFormat(internalformat);
          break;
      default:
<span class="line-modified">!         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid internalformat&quot;);</span>
          return;
      }
      applyStencilTest();
  }
  
<span class="line-modified">! void WebGLRenderingContext::hint(GCGLenum target, GCGLenum mode)</span>
  {
      if (isContextLostOrPending())
          return;
      bool isValid = false;
      switch (target) {
<span class="line-modified">!     case GraphicsContextGL::GENERATE_MIPMAP_HINT:</span>
          isValid = true;
          break;
<span class="line-modified">!     case ExtensionsGL::FRAGMENT_SHADER_DERIVATIVE_HINT_OES: // OES_standard_derivatives</span>
          if (m_oesStandardDerivatives)
              isValid = true;
          break;
      }
      if (!isValid) {
<span class="line-modified">!         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;hint&quot;, &quot;invalid target&quot;);</span>
          return;
      }
      m_context-&gt;hint(target, mode);
  }
  
<span class="line-modified">! void WebGLRenderingContext::clear(GCGLbitfield mask)</span>
  {
      if (isContextLostOrPending())
          return;
<span class="line-modified">!     if (mask &amp; ~(GraphicsContextGL::COLOR_BUFFER_BIT | GraphicsContextGL::DEPTH_BUFFER_BIT | GraphicsContextGL::STENCIL_BUFFER_BIT)) {</span>
<span class="line-modified">!         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;clear&quot;, &quot;invalid mask&quot;);</span>
          return;
      }
      const char* reason = &quot;framebuffer incomplete&quot;;
      if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(m_context.get(), &amp;reason)) {
<span class="line-modified">!         synthesizeGLError(GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION, &quot;clear&quot;, reason);</span>
          return;
      }
      if (!clearIfComposited(mask))
          m_context-&gt;clear(mask);
      markContextChangedAndNotifyCanvasObserver();
  }
  
<span class="line-modified">! WebGLAny WebGLRenderingContext::getParameter(GCGLenum pname)</span>
  {
      if (isContextLostOrPending())
          return nullptr;
  
      switch (pname) {
<span class="line-modified">!     case GraphicsContextGL::ACTIVE_TEXTURE:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::ALIASED_LINE_WIDTH_RANGE:</span>
          return getWebGLFloatArrayParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::ALIASED_POINT_SIZE_RANGE:</span>
          return getWebGLFloatArrayParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::ALPHA_BITS:</span>
          if (!m_framebufferBinding &amp;&amp; !m_attributes.alpha)
              return 0;
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::ARRAY_BUFFER_BINDING:</span>
          return m_boundArrayBuffer;
<span class="line-modified">!     case GraphicsContextGL::BLEND:</span>
          return getBooleanParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::BLEND_COLOR:</span>
          return getWebGLFloatArrayParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::BLEND_DST_ALPHA:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::BLEND_DST_RGB:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::BLEND_EQUATION_ALPHA:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::BLEND_EQUATION_RGB:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::BLEND_SRC_ALPHA:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::BLEND_SRC_RGB:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::BLUE_BITS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::COLOR_CLEAR_VALUE:</span>
          return getWebGLFloatArrayParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::COLOR_WRITEMASK:</span>
          return getBooleanArrayParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::COMPRESSED_TEXTURE_FORMATS:</span>
          return Uint32Array::tryCreate(m_compressedTextureFormats.data(), m_compressedTextureFormats.size());
<span class="line-modified">!     case GraphicsContextGL::CULL_FACE:</span>
          return getBooleanParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::CULL_FACE_MODE:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::CURRENT_PROGRAM:</span>
          return m_currentProgram;
<span class="line-modified">!     case GraphicsContextGL::DEPTH_BITS:</span>
          if (!m_framebufferBinding &amp;&amp; !m_attributes.depth)
              return 0;
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::DEPTH_CLEAR_VALUE:</span>
          return getFloatParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::DEPTH_FUNC:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::DEPTH_RANGE:</span>
          return getWebGLFloatArrayParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::DEPTH_TEST:</span>
          return getBooleanParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::DEPTH_WRITEMASK:</span>
          return getBooleanParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::DITHER:</span>
          return getBooleanParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::ELEMENT_ARRAY_BUFFER_BINDING:</span>
          return makeRefPtr(m_boundVertexArrayObject-&gt;getElementArrayBuffer());
<span class="line-modified">!     case GraphicsContextGL::FRAMEBUFFER_BINDING:</span>
          return m_framebufferBinding;
<span class="line-modified">!     case GraphicsContextGL::FRONT_FACE:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::GENERATE_MIPMAP_HINT:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::GREEN_BITS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::IMPLEMENTATION_COLOR_READ_FORMAT:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::IMPLEMENTATION_COLOR_READ_TYPE:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::LINE_WIDTH:</span>
          return getFloatParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::MAX_COMBINED_TEXTURE_IMAGE_UNITS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::MAX_CUBE_MAP_TEXTURE_SIZE:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::MAX_FRAGMENT_UNIFORM_VECTORS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::MAX_RENDERBUFFER_SIZE:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::MAX_TEXTURE_IMAGE_UNITS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::MAX_TEXTURE_SIZE:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::MAX_VARYING_VECTORS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::MAX_VERTEX_ATTRIBS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::MAX_VERTEX_TEXTURE_IMAGE_UNITS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::MAX_VERTEX_UNIFORM_VECTORS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::MAX_VIEWPORT_DIMS:</span>
          return getWebGLIntArrayParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::NUM_SHADER_BINARY_FORMATS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::PACK_ALIGNMENT:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::POLYGON_OFFSET_FACTOR:</span>
          return getFloatParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::POLYGON_OFFSET_FILL:</span>
          return getBooleanParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::POLYGON_OFFSET_UNITS:</span>
          return getFloatParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::RED_BITS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::RENDERBUFFER_BINDING:</span>
          return m_renderbufferBinding;
<span class="line-modified">!     case GraphicsContextGL::RENDERER:</span>
          return &quot;WebKit WebGL&quot;_str;
<span class="line-modified">!     case GraphicsContextGL::SAMPLE_BUFFERS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::SAMPLE_COVERAGE_INVERT:</span>
          return getBooleanParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::SAMPLE_COVERAGE_VALUE:</span>
          return getFloatParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::SAMPLES:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::SCISSOR_BOX:</span>
          return getWebGLIntArrayParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::SCISSOR_TEST:</span>
          return getBooleanParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::SHADING_LANGUAGE_VERSION:</span>
<span class="line-modified">!         return &quot;WebGL GLSL ES 1.0 (&quot; + m_context-&gt;getString(GraphicsContextGL::SHADING_LANGUAGE_VERSION) + &quot;)&quot;;</span>
<span class="line-modified">!     case GraphicsContextGL::STENCIL_BACK_FAIL:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::STENCIL_BACK_FUNC:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::STENCIL_BACK_PASS_DEPTH_FAIL:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::STENCIL_BACK_PASS_DEPTH_PASS:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::STENCIL_BACK_REF:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::STENCIL_BACK_VALUE_MASK:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::STENCIL_BACK_WRITEMASK:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::STENCIL_BITS:</span>
          if (!m_framebufferBinding &amp;&amp; !m_attributes.stencil)
              return 0;
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::STENCIL_CLEAR_VALUE:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::STENCIL_FAIL:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::STENCIL_FUNC:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::STENCIL_PASS_DEPTH_FAIL:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::STENCIL_PASS_DEPTH_PASS:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::STENCIL_REF:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::STENCIL_TEST:</span>
          return getBooleanParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::STENCIL_VALUE_MASK:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::STENCIL_WRITEMASK:</span>
          return getUnsignedIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::SUBPIXEL_BITS:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::TEXTURE_BINDING_2D:</span>
          return m_textureUnits[m_activeTextureUnit].texture2DBinding;
<span class="line-modified">!     case GraphicsContextGL::TEXTURE_BINDING_CUBE_MAP:</span>
          return m_textureUnits[m_activeTextureUnit].textureCubeMapBinding;
<span class="line-modified">!     case GraphicsContextGL::UNPACK_ALIGNMENT:</span>
          return getIntParameter(pname);
<span class="line-modified">!     case GraphicsContextGL::UNPACK_FLIP_Y_WEBGL:</span>
          return m_unpackFlipY;
<span class="line-modified">!     case GraphicsContextGL::UNPACK_PREMULTIPLY_ALPHA_WEBGL:</span>
          return m_unpackPremultiplyAlpha;
<span class="line-modified">!     case GraphicsContextGL::UNPACK_COLORSPACE_CONVERSION_WEBGL:</span>
          return m_unpackColorspaceConversion;
<span class="line-modified">!     case GraphicsContextGL::VENDOR:</span>
          return &quot;WebKit&quot;_str;
<span class="line-modified">!     case GraphicsContextGL::VERSION:</span>
          return &quot;WebGL 1.0&quot;_str;
<span class="line-modified">!     case GraphicsContextGL::VIEWPORT:</span>
          return getWebGLIntArrayParameter(pname);
<span class="line-modified">!     case ExtensionsGL::FRAGMENT_SHADER_DERIVATIVE_HINT_OES: // OES_standard_derivatives</span>
          if (m_oesStandardDerivatives)
<span class="line-modified">!             return getUnsignedIntParameter(ExtensionsGL::FRAGMENT_SHADER_DERIVATIVE_HINT_OES);</span>
<span class="line-modified">!         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, OES_standard_derivatives not enabled&quot;);</span>
          return nullptr;
      case WebGLDebugRendererInfo::UNMASKED_RENDERER_WEBGL:
          if (m_webglDebugRendererInfo) {
  #if PLATFORM(IOS_FAMILY)
              return &quot;Apple GPU&quot;_str;
  #else
<span class="line-modified">!             return m_context-&gt;getString(GraphicsContextGL::RENDERER);</span>
  #endif
          }
<span class="line-modified">!         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_debug_renderer_info not enabled&quot;);</span>
          return nullptr;
      case WebGLDebugRendererInfo::UNMASKED_VENDOR_WEBGL:
          if (m_webglDebugRendererInfo)
<span class="line-modified">!             return m_context-&gt;getString(GraphicsContextGL::VENDOR);</span>
<span class="line-modified">!         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_debug_renderer_info not enabled&quot;);</span>
          return nullptr;
<span class="line-modified">!     case ExtensionsGL::VERTEX_ARRAY_BINDING_OES: // OES_vertex_array_object</span>
          if (m_oesVertexArrayObject) {
              if (m_boundVertexArrayObject-&gt;isDefaultObject())
                  return nullptr;
              return makeRefPtr(static_cast&lt;WebGLVertexArrayObjectOES&amp;&gt;(*m_boundVertexArrayObject));
          }
<span class="line-modified">!         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, OES_vertex_array_object not enabled&quot;);</span>
          return nullptr;
<span class="line-modified">!     case ExtensionsGL::MAX_TEXTURE_MAX_ANISOTROPY_EXT: // EXT_texture_filter_anisotropic</span>
          if (m_extTextureFilterAnisotropic)
<span class="line-modified">!             return getUnsignedIntParameter(ExtensionsGL::MAX_TEXTURE_MAX_ANISOTROPY_EXT);</span>
<span class="line-modified">!         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, EXT_texture_filter_anisotropic not enabled&quot;);</span>
          return nullptr;
<span class="line-modified">!     case ExtensionsGL::MAX_COLOR_ATTACHMENTS_EXT: // EXT_draw_buffers BEGIN</span>
          if (m_webglDrawBuffers)
              return getMaxColorAttachments();
<span class="line-modified">!         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_draw_buffers not enabled&quot;);</span>
          return nullptr;
<span class="line-modified">!     case ExtensionsGL::MAX_DRAW_BUFFERS_EXT:</span>
          if (m_webglDrawBuffers)
              return getMaxDrawBuffers();
<span class="line-modified">!         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_draw_buffers not enabled&quot;);</span>
          return nullptr;
      default:
          if (m_webglDrawBuffers
<span class="line-modified">!             &amp;&amp; pname &gt;= ExtensionsGL::DRAW_BUFFER0_EXT</span>
<span class="line-modified">!             &amp;&amp; pname &lt; static_cast&lt;GCGLenum&gt;(ExtensionsGL::DRAW_BUFFER0_EXT + getMaxDrawBuffers())) {</span>
<span class="line-modified">!             GCGLint value = GraphicsContextGL::NONE;</span>
              if (m_framebufferBinding)
                  value = m_framebufferBinding-&gt;getDrawBuffer(pname);
              else // emulated backbuffer
                  value = m_backDrawBuffer;
              return value;
          }
<span class="line-modified">!         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name&quot;);</span>
          return nullptr;
      }
  }
  
<span class="line-modified">! GCGLint WebGLRenderingContext::getMaxDrawBuffers()</span>
  {
      if (!supportsDrawBuffers())
          return 0;
      if (!m_maxDrawBuffers)
<span class="line-modified">!         m_context-&gt;getIntegerv(ExtensionsGL::MAX_DRAW_BUFFERS_EXT, &amp;m_maxDrawBuffers);</span>
      if (!m_maxColorAttachments)
<span class="line-modified">!         m_context-&gt;getIntegerv(ExtensionsGL::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);</span>
      // WEBGL_draw_buffers requires MAX_COLOR_ATTACHMENTS &gt;= MAX_DRAW_BUFFERS.
      return std::min(m_maxDrawBuffers, m_maxColorAttachments);
  }
  
<span class="line-modified">! GCGLint WebGLRenderingContext::getMaxColorAttachments()</span>
  {
      if (!supportsDrawBuffers())
          return 0;
      if (!m_maxColorAttachments)
<span class="line-modified">!         m_context-&gt;getIntegerv(ExtensionsGL::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);</span>
      return m_maxColorAttachments;
  }
  
<span class="line-modified">! bool WebGLRenderingContext::validateIndexArrayConservative(GCGLenum type, unsigned&amp; numElementsRequired)</span>
  {
      // Performs conservative validation by caching a maximum index of
      // the given type per element array buffer. If all of the bound
      // array buffers have enough elements to satisfy that maximum
      // index, skips the expensive per-draw-call iteration in
</pre>
<hr />
<pre>
<span class="line-old-header">*** 687,40 ***</span>
      RefPtr&lt;WebGLBuffer&gt; elementArrayBuffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
  
      if (!elementArrayBuffer)
          return false;
  
<span class="line-modified">!     GC3Dsizeiptr numElements = elementArrayBuffer-&gt;byteLength();</span>
      // The case count==0 is already dealt with in drawElements before validateIndexArrayConservative.
      if (!numElements)
          return false;
      auto buffer = elementArrayBuffer-&gt;elementArrayBuffer();
      ASSERT(buffer);
  
      Optional&lt;unsigned&gt; maxIndex = elementArrayBuffer-&gt;getCachedMaxIndex(type);
      if (!maxIndex) {
          // Compute the maximum index in the entire buffer for the given type of index.
          switch (type) {
<span class="line-modified">!         case GraphicsContext3D::UNSIGNED_BYTE: {</span>
<span class="line-modified">!             const GC3Dubyte* p = static_cast&lt;const GC3Dubyte*&gt;(buffer-&gt;data());</span>
<span class="line-modified">!             for (GC3Dsizeiptr i = 0; i &lt; numElements; i++)</span>
                  maxIndex = maxIndex ? std::max(maxIndex.value(), static_cast&lt;unsigned&gt;(p[i])) : static_cast&lt;unsigned&gt;(p[i]);
              break;
          }
<span class="line-modified">!         case GraphicsContext3D::UNSIGNED_SHORT: {</span>
<span class="line-modified">!             numElements /= sizeof(GC3Dushort);</span>
<span class="line-modified">!             const GC3Dushort* p = static_cast&lt;const GC3Dushort*&gt;(buffer-&gt;data());</span>
<span class="line-modified">!             for (GC3Dsizeiptr i = 0; i &lt; numElements; i++)</span>
                  maxIndex = maxIndex ? std::max(maxIndex.value(), static_cast&lt;unsigned&gt;(p[i])) : static_cast&lt;unsigned&gt;(p[i]);
              break;
          }
<span class="line-modified">!         case GraphicsContext3D::UNSIGNED_INT: {</span>
              if (!m_oesElementIndexUint)
                  return false;
<span class="line-modified">!             numElements /= sizeof(GC3Duint);</span>
<span class="line-modified">!             const GC3Duint* p = static_cast&lt;const GC3Duint*&gt;(buffer-&gt;data());</span>
<span class="line-modified">!             for (GC3Dsizeiptr i = 0; i &lt; numElements; i++)</span>
                  maxIndex = maxIndex ? std::max(maxIndex.value(), static_cast&lt;unsigned&gt;(p[i])) : static_cast&lt;unsigned&gt;(p[i]);
              break;
          }
          default:
              return false;
<span class="line-new-header">--- 694,40 ---</span>
      RefPtr&lt;WebGLBuffer&gt; elementArrayBuffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
  
      if (!elementArrayBuffer)
          return false;
  
<span class="line-modified">!     GCGLsizeiptr numElements = elementArrayBuffer-&gt;byteLength();</span>
      // The case count==0 is already dealt with in drawElements before validateIndexArrayConservative.
      if (!numElements)
          return false;
      auto buffer = elementArrayBuffer-&gt;elementArrayBuffer();
      ASSERT(buffer);
  
      Optional&lt;unsigned&gt; maxIndex = elementArrayBuffer-&gt;getCachedMaxIndex(type);
      if (!maxIndex) {
          // Compute the maximum index in the entire buffer for the given type of index.
          switch (type) {
<span class="line-modified">!         case GraphicsContextGL::UNSIGNED_BYTE: {</span>
<span class="line-modified">!             const GCGLubyte* p = static_cast&lt;const GCGLubyte*&gt;(buffer-&gt;data());</span>
<span class="line-modified">!             for (GCGLsizeiptr i = 0; i &lt; numElements; i++)</span>
                  maxIndex = maxIndex ? std::max(maxIndex.value(), static_cast&lt;unsigned&gt;(p[i])) : static_cast&lt;unsigned&gt;(p[i]);
              break;
          }
<span class="line-modified">!         case GraphicsContextGL::UNSIGNED_SHORT: {</span>
<span class="line-modified">!             numElements /= sizeof(GCGLushort);</span>
<span class="line-modified">!             const GCGLushort* p = static_cast&lt;const GCGLushort*&gt;(buffer-&gt;data());</span>
<span class="line-modified">!             for (GCGLsizeiptr i = 0; i &lt; numElements; i++)</span>
                  maxIndex = maxIndex ? std::max(maxIndex.value(), static_cast&lt;unsigned&gt;(p[i])) : static_cast&lt;unsigned&gt;(p[i]);
              break;
          }
<span class="line-modified">!         case GraphicsContextGL::UNSIGNED_INT: {</span>
              if (!m_oesElementIndexUint)
                  return false;
<span class="line-modified">!             numElements /= sizeof(GCGLuint);</span>
<span class="line-modified">!             const GCGLuint* p = static_cast&lt;const GCGLuint*&gt;(buffer-&gt;data());</span>
<span class="line-modified">!             for (GCGLsizeiptr i = 0; i &lt; numElements; i++)</span>
                  maxIndex = maxIndex ? std::max(maxIndex.value(), static_cast&lt;unsigned&gt;(p[i])) : static_cast&lt;unsigned&gt;(p[i]);
              break;
          }
          default:
              return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 739,45 ***</span>
      numElementsRequired = checkedNumElementsRequired.value();
  
      return true;
  }
  
<span class="line-modified">! bool WebGLRenderingContext::validateBlendEquation(const char* functionName, GC3Denum mode)</span>
  {
      switch (mode) {
<span class="line-modified">!     case GraphicsContext3D::FUNC_ADD:</span>
<span class="line-modified">!     case GraphicsContext3D::FUNC_SUBTRACT:</span>
<span class="line-modified">!     case GraphicsContext3D::FUNC_REVERSE_SUBTRACT:</span>
<span class="line-modified">!     case Extensions3D::MIN_EXT:</span>
<span class="line-modified">!     case Extensions3D::MAX_EXT:</span>
<span class="line-modified">!         if ((mode == Extensions3D::MIN_EXT || mode == Extensions3D::MAX_EXT) &amp;&amp; !m_extBlendMinMax) {</span>
<span class="line-modified">!             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid mode&quot;);</span>
              return false;
          }
          return true;
          break;
      default:
<span class="line-modified">!         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid mode&quot;);</span>
          return false;
      }
  }
  
<span class="line-modified">! bool WebGLRenderingContext::validateCapability(const char* functionName, GC3Denum cap)</span>
  {
      switch (cap) {
<span class="line-modified">!     case GraphicsContext3D::BLEND:</span>
<span class="line-modified">!     case GraphicsContext3D::CULL_FACE:</span>
<span class="line-modified">!     case GraphicsContext3D::DEPTH_TEST:</span>
<span class="line-modified">!     case GraphicsContext3D::DITHER:</span>
<span class="line-modified">!     case GraphicsContext3D::POLYGON_OFFSET_FILL:</span>
<span class="line-modified">!     case GraphicsContext3D::SAMPLE_ALPHA_TO_COVERAGE:</span>
<span class="line-modified">!     case GraphicsContext3D::SAMPLE_COVERAGE:</span>
<span class="line-modified">!     case GraphicsContext3D::SCISSOR_TEST:</span>
<span class="line-modified">!     case GraphicsContext3D::STENCIL_TEST:</span>
          return true;
      default:
<span class="line-modified">!         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid capability&quot;);</span>
          return false;
      }
  }
  
  } // namespace WebCore
<span class="line-new-header">--- 746,45 ---</span>
      numElementsRequired = checkedNumElementsRequired.value();
  
      return true;
  }
  
<span class="line-modified">! bool WebGLRenderingContext::validateBlendEquation(const char* functionName, GCGLenum mode)</span>
  {
      switch (mode) {
<span class="line-modified">!     case GraphicsContextGL::FUNC_ADD:</span>
<span class="line-modified">!     case GraphicsContextGL::FUNC_SUBTRACT:</span>
<span class="line-modified">!     case GraphicsContextGL::FUNC_REVERSE_SUBTRACT:</span>
<span class="line-modified">!     case ExtensionsGL::MIN_EXT:</span>
<span class="line-modified">!     case ExtensionsGL::MAX_EXT:</span>
<span class="line-modified">!         if ((mode == ExtensionsGL::MIN_EXT || mode == ExtensionsGL::MAX_EXT) &amp;&amp; !m_extBlendMinMax) {</span>
<span class="line-modified">!             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid mode&quot;);</span>
              return false;
          }
          return true;
          break;
      default:
<span class="line-modified">!         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid mode&quot;);</span>
          return false;
      }
  }
  
<span class="line-modified">! bool WebGLRenderingContext::validateCapability(const char* functionName, GCGLenum cap)</span>
  {
      switch (cap) {
<span class="line-modified">!     case GraphicsContextGL::BLEND:</span>
<span class="line-modified">!     case GraphicsContextGL::CULL_FACE:</span>
<span class="line-modified">!     case GraphicsContextGL::DEPTH_TEST:</span>
<span class="line-modified">!     case GraphicsContextGL::DITHER:</span>
<span class="line-modified">!     case GraphicsContextGL::POLYGON_OFFSET_FILL:</span>
<span class="line-modified">!     case GraphicsContextGL::SAMPLE_ALPHA_TO_COVERAGE:</span>
<span class="line-modified">!     case GraphicsContextGL::SAMPLE_COVERAGE:</span>
<span class="line-modified">!     case GraphicsContextGL::SCISSOR_TEST:</span>
<span class="line-modified">!     case GraphicsContextGL::STENCIL_TEST:</span>
          return true;
      default:
<span class="line-modified">!         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid capability&quot;);</span>
          return false;
      }
  }
  
  } // namespace WebCore
</pre>
<center><a href="WebGLRenderbuffer.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLRenderingContext.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
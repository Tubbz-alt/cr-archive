<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/platform/network/ParsedContentType.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NetworkStorageSession.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ResourceHandle.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/network/ParsedContentType.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 54,27 ***</span>
      return isASCII(c) &amp;&amp; c &gt; &#39; &#39; &amp;&amp; c != &#39;&quot;&#39; &amp;&amp; c != &#39;(&#39; &amp;&amp; c != &#39;)&#39; &amp;&amp; c != &#39;,&#39; &amp;&amp; c != &#39;/&#39; &amp;&amp; (c &lt; &#39;:&#39; || c &gt; &#39;@&#39;) &amp;&amp; (c &lt; &#39;[&#39; || c &gt; &#39;]&#39;);
  }
  
  using CharacterMeetsCondition = bool (*)(UChar);
  
<span class="line-modified">! static Optional&lt;StringView&gt; parseToken(StringView input, unsigned&amp; startIndex, CharacterMeetsCondition characterMeetsCondition, Mode mode, bool skipTrailingWhitespace = false)</span>
  {
      unsigned inputLength = input.length();
      unsigned tokenStart = startIndex;
      unsigned&amp; tokenEnd = startIndex;
  
      if (tokenEnd &gt;= inputLength)
<span class="line-modified">!         return WTF::nullopt;</span>
  
      while (tokenEnd &lt; inputLength &amp;&amp; characterMeetsCondition(input[tokenEnd])) {
          if (mode == Mode::Rfc2045 &amp;&amp; !isTokenCharacter(input[tokenEnd]))
              break;
          ++tokenEnd;
      }
  
      if (tokenEnd == tokenStart)
<span class="line-modified">!         return WTF::nullopt;</span>
      if (skipTrailingWhitespace) {
          while (input[tokenEnd - 1] == &#39; &#39;)
              --tokenEnd;
      }
      return input.substring(tokenStart, tokenEnd - tokenStart);
<span class="line-new-header">--- 54,27 ---</span>
      return isASCII(c) &amp;&amp; c &gt; &#39; &#39; &amp;&amp; c != &#39;&quot;&#39; &amp;&amp; c != &#39;(&#39; &amp;&amp; c != &#39;)&#39; &amp;&amp; c != &#39;,&#39; &amp;&amp; c != &#39;/&#39; &amp;&amp; (c &lt; &#39;:&#39; || c &gt; &#39;@&#39;) &amp;&amp; (c &lt; &#39;[&#39; || c &gt; &#39;]&#39;);
  }
  
  using CharacterMeetsCondition = bool (*)(UChar);
  
<span class="line-modified">! static StringView parseToken(StringView input, unsigned&amp; startIndex, CharacterMeetsCondition characterMeetsCondition, Mode mode, bool skipTrailingWhitespace = false)</span>
  {
      unsigned inputLength = input.length();
      unsigned tokenStart = startIndex;
      unsigned&amp; tokenEnd = startIndex;
  
      if (tokenEnd &gt;= inputLength)
<span class="line-modified">!         return StringView();</span>
  
      while (tokenEnd &lt; inputLength &amp;&amp; characterMeetsCondition(input[tokenEnd])) {
          if (mode == Mode::Rfc2045 &amp;&amp; !isTokenCharacter(input[tokenEnd]))
              break;
          ++tokenEnd;
      }
  
      if (tokenEnd == tokenStart)
<span class="line-modified">!         return StringView();</span>
      if (skipTrailingWhitespace) {
          while (input[tokenEnd - 1] == &#39; &#39;)
              --tokenEnd;
      }
      return input.substring(tokenStart, tokenEnd - tokenStart);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 123,27 ***</span>
              return true;
      }
      return false;
  }
  
<span class="line-modified">! static Optional&lt;StringView&gt; parseQuotedString(StringView input, unsigned&amp; startIndex)</span>
  {
      unsigned inputLength = input.length();
      unsigned quotedStringStart = startIndex + 1;
      unsigned&amp; quotedStringEnd = startIndex;
  
      if (quotedStringEnd &gt;= inputLength)
<span class="line-modified">!         return WTF::nullopt;</span>
  
      if (input[quotedStringEnd++] != &#39;&quot;&#39; || quotedStringEnd &gt;= inputLength)
<span class="line-modified">!         return WTF::nullopt;</span>
  
      bool lastCharacterWasBackslash = false;
      char currentCharacter;
      while ((currentCharacter = input[quotedStringEnd++]) != &#39;&quot;&#39; || lastCharacterWasBackslash) {
          if (quotedStringEnd &gt;= inputLength)
<span class="line-modified">!             return WTF::nullopt;</span>
          if (currentCharacter == &#39;\\&#39; &amp;&amp; !lastCharacterWasBackslash) {
              lastCharacterWasBackslash = true;
              continue;
          }
          if (lastCharacterWasBackslash)
<span class="line-new-header">--- 123,27 ---</span>
              return true;
      }
      return false;
  }
  
<span class="line-modified">! static StringView parseQuotedString(StringView input, unsigned&amp; startIndex)</span>
  {
      unsigned inputLength = input.length();
      unsigned quotedStringStart = startIndex + 1;
      unsigned&amp; quotedStringEnd = startIndex;
  
      if (quotedStringEnd &gt;= inputLength)
<span class="line-modified">!         return StringView();</span>
  
      if (input[quotedStringEnd++] != &#39;&quot;&#39; || quotedStringEnd &gt;= inputLength)
<span class="line-modified">!         return StringView();</span>
  
      bool lastCharacterWasBackslash = false;
      char currentCharacter;
      while ((currentCharacter = input[quotedStringEnd++]) != &#39;&quot;&#39; || lastCharacterWasBackslash) {
          if (quotedStringEnd &gt;= inputLength)
<span class="line-modified">!             return StringView();</span>
          if (currentCharacter == &#39;\\&#39; &amp;&amp; !lastCharacterWasBackslash) {
              lastCharacterWasBackslash = true;
              continue;
          }
          if (lastCharacterWasBackslash)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 232,22 ***</span>
          return false;
      }
  
      unsigned contentTypeStart = index;
      auto typeRange = parseToken(m_contentType, index, isNotForwardSlash, mode);
<span class="line-modified">!     if (!typeRange || containsNonTokenCharacters(*typeRange, mode)) {</span>
          LOG_ERROR(&quot;Invalid Content-Type, invalid type value.&quot;);
          return false;
      }
  
      if (index &gt;= contentTypeLength || m_contentType[index++] != &#39;/&#39;) {
          LOG_ERROR(&quot;Invalid Content-Type, missing &#39;/&#39;.&quot;);
          return false;
      }
  
      auto subTypeRange = parseToken(m_contentType, index, isNotSemicolon, mode, mode == Mode::MimeSniff);
<span class="line-modified">!     if (!subTypeRange || containsNonTokenCharacters(*subTypeRange, mode)) {</span>
          LOG_ERROR(&quot;Invalid Content-Type, invalid subtype value.&quot;);
          return false;
      }
  
      // There should not be any quoted strings until we reach the parameters.
<span class="line-new-header">--- 232,22 ---</span>
          return false;
      }
  
      unsigned contentTypeStart = index;
      auto typeRange = parseToken(m_contentType, index, isNotForwardSlash, mode);
<span class="line-modified">!     if (typeRange.isNull() || containsNonTokenCharacters(typeRange, mode)) {</span>
          LOG_ERROR(&quot;Invalid Content-Type, invalid type value.&quot;);
          return false;
      }
  
      if (index &gt;= contentTypeLength || m_contentType[index++] != &#39;/&#39;) {
          LOG_ERROR(&quot;Invalid Content-Type, missing &#39;/&#39;.&quot;);
          return false;
      }
  
      auto subTypeRange = parseToken(m_contentType, index, isNotSemicolon, mode, mode == Mode::MimeSniff);
<span class="line-modified">!     if (subTypeRange.isNull() || containsNonTokenCharacters(subTypeRange, mode)) {</span>
          LOG_ERROR(&quot;Invalid Content-Type, invalid subtype value.&quot;);
          return false;
      }
  
      // There should not be any quoted strings until we reach the parameters.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 260,11 ***</span>
      setContentType(m_contentType.substring(contentTypeStart, semiColonIndex - contentTypeStart), mode);
      index = semiColonIndex + 1;
      while (true) {
          skipSpaces(m_contentType, index);
          auto keyRange = parseToken(m_contentType, index, isNotSemicolonOrEqualSign, mode);
<span class="line-modified">!         if (mode == Mode::Rfc2045 &amp;&amp; (!keyRange || index &gt;= contentTypeLength)) {</span>
              LOG_ERROR(&quot;Invalid Content-Type parameter name.&quot;);
              return false;
          }
  
          // Should we tolerate spaces here?
<span class="line-new-header">--- 260,11 ---</span>
      setContentType(m_contentType.substring(contentTypeStart, semiColonIndex - contentTypeStart), mode);
      index = semiColonIndex + 1;
      while (true) {
          skipSpaces(m_contentType, index);
          auto keyRange = parseToken(m_contentType, index, isNotSemicolonOrEqualSign, mode);
<span class="line-modified">!         if (mode == Mode::Rfc2045 &amp;&amp; (keyRange.isNull() || index &gt;= contentTypeLength)) {</span>
              LOG_ERROR(&quot;Invalid Content-Type parameter name.&quot;);
              return false;
          }
  
          // Should we tolerate spaces here?
</pre>
<hr />
<pre>
<span class="line-old-header">*** 281,42 ***</span>
                  return false;
              }
              if (m_contentType[index++] == &#39;;&#39;)
                  continue;
          }
<span class="line-removed">-         String parameterName = keyRange-&gt;toString();</span>
  
          // Should we tolerate spaces here?
          String parameterValue;
<span class="line-modified">!         Optional&lt;StringView&gt; valueRange;</span>
          if (index &lt; contentTypeLength &amp;&amp; m_contentType[index] == &#39;&quot;&#39;) {
              if (mode == Mode::MimeSniff) {
                  parameterValue = collectHTTPQuotedString(m_contentType, index);
                  parseToken(m_contentType, index, isNotSemicolon, mode);
              } else
                  valueRange = parseQuotedString(m_contentType, index);
          } else
              valueRange = parseToken(m_contentType, index, isNotSemicolon, mode, mode == Mode::MimeSniff);
  
<span class="line-removed">- </span>
          if (parameterValue.isNull()) {
<span class="line-modified">!             if (!valueRange) {</span>
                  if (mode == Mode::MimeSniff)
                      continue;
                  LOG_ERROR(&quot;Invalid Content-Type, invalid parameter value.&quot;);
                  return false;
              }
<span class="line-modified">!             parameterValue = valueRange-&gt;toString();</span>
          }
  
          // Should we tolerate spaces here?
          if (mode == Mode::Rfc2045 &amp;&amp; index &lt; contentTypeLength &amp;&amp; m_contentType[index++] != &#39;;&#39;) {
              LOG_ERROR(&quot;Invalid Content-Type, invalid character at the end of key/value parameter.&quot;);
              return false;
          }
  
<span class="line-modified">!         setContentTypeParameter(parameterName, parameterValue, mode);</span>
  
          if (index &gt;= contentTypeLength)
              return true;
      }
  
<span class="line-new-header">--- 281,41 ---</span>
                  return false;
              }
              if (m_contentType[index++] == &#39;;&#39;)
                  continue;
          }
  
          // Should we tolerate spaces here?
          String parameterValue;
<span class="line-modified">!         StringView valueRange;</span>
          if (index &lt; contentTypeLength &amp;&amp; m_contentType[index] == &#39;&quot;&#39;) {
              if (mode == Mode::MimeSniff) {
                  parameterValue = collectHTTPQuotedString(m_contentType, index);
                  parseToken(m_contentType, index, isNotSemicolon, mode);
              } else
                  valueRange = parseQuotedString(m_contentType, index);
          } else
              valueRange = parseToken(m_contentType, index, isNotSemicolon, mode, mode == Mode::MimeSniff);
  
          if (parameterValue.isNull()) {
<span class="line-modified">!             if (valueRange.isNull()) {</span>
                  if (mode == Mode::MimeSniff)
                      continue;
                  LOG_ERROR(&quot;Invalid Content-Type, invalid parameter value.&quot;);
                  return false;
              }
<span class="line-modified">!             parameterValue = valueRange.toString();</span>
          }
  
          // Should we tolerate spaces here?
          if (mode == Mode::Rfc2045 &amp;&amp; index &lt; contentTypeLength &amp;&amp; m_contentType[index++] != &#39;;&#39;) {
              LOG_ERROR(&quot;Invalid Content-Type, invalid character at the end of key/value parameter.&quot;);
              return false;
          }
  
<span class="line-modified">!         if (!keyRange.isNull())</span>
<span class="line-added">+             setContentTypeParameter(keyRange.toString(), parameterValue, mode);</span>
  
          if (index &gt;= contentTypeLength)
              return true;
      }
  
</pre>
<center><a href="NetworkStorageSession.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ResourceHandle.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
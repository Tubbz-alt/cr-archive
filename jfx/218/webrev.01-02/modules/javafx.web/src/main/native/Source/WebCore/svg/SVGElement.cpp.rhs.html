<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/svg/SVGElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2004, 2005, 2006, 2007, 2008 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  3  * Copyright (C) 2004, 2005, 2006, 2008 Rob Buis &lt;buis@kde.org&gt;
  4  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
  5  * Copyright (C) 2008 Alp Toker &lt;alp@atoker.com&gt;
  6  * Copyright (C) 2009 Cameron McCormack &lt;cam@mcc.id.au&gt;
  7  * Copyright (C) 2013 Samsung Electronics. All rights reserved.
  8  * Copyright (C) 2014 Adobe Systems Incorporated. All rights reserved.
  9  *
 10  * This library is free software; you can redistribute it and/or
 11  * modify it under the terms of the GNU Library General Public
 12  * License as published by the Free Software Foundation; either
 13  * version 2 of the License, or (at your option) any later version.
 14  *
 15  * This library is distributed in the hope that it will be useful,
 16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 18  * Library General Public License for more details.
 19  *
 20  * You should have received a copy of the GNU Library General Public License
 21  * along with this library; see the file COPYING.LIB.  If not, write to
 22  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 23  * Boston, MA 02110-1301, USA.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SVGElement.h&quot;
 28 
 29 #include &quot;CSSPropertyParser.h&quot;
 30 #include &quot;DeprecatedCSSOMValue.h&quot;
 31 #include &quot;Document.h&quot;
 32 #include &quot;ElementIterator.h&quot;
 33 #include &quot;Event.h&quot;
 34 #include &quot;EventNames.h&quot;
 35 #include &quot;HTMLElement.h&quot;
 36 #include &quot;HTMLNames.h&quot;
 37 #include &quot;HTMLParserIdioms.h&quot;
 38 #include &quot;RenderObject.h&quot;
 39 #include &quot;RenderSVGResource.h&quot;
 40 #include &quot;RenderSVGResourceFilter.h&quot;
 41 #include &quot;RenderSVGResourceMasker.h&quot;
 42 #include &quot;SVGDocumentExtensions.h&quot;
 43 #include &quot;SVGElementRareData.h&quot;
 44 #include &quot;SVGGraphicsElement.h&quot;
 45 #include &quot;SVGImageElement.h&quot;
 46 #include &quot;SVGNames.h&quot;
 47 #include &quot;SVGPropertyAnimatorFactory.h&quot;
 48 #include &quot;SVGRenderStyle.h&quot;
 49 #include &quot;SVGRenderSupport.h&quot;
 50 #include &quot;SVGSVGElement.h&quot;
 51 #include &quot;SVGTitleElement.h&quot;
 52 #include &quot;SVGUseElement.h&quot;
 53 #include &quot;ShadowRoot.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 54 #include &quot;StyleAdjuster.h&quot;</span>
 55 #include &quot;XMLNames.h&quot;
 56 #include &lt;wtf/Assertions.h&gt;
 57 #include &lt;wtf/HashMap.h&gt;
 58 #include &lt;wtf/IsoMallocInlines.h&gt;
 59 #include &lt;wtf/NeverDestroyed.h&gt;
 60 #include &lt;wtf/StdLibExtras.h&gt;
 61 #include &lt;wtf/text/WTFString.h&gt;
 62 
 63 
 64 namespace WebCore {
 65 
 66 WTF_MAKE_ISO_ALLOCATED_IMPL(SVGElement);
 67 
 68 static NEVER_INLINE HashMap&lt;AtomStringImpl*, CSSPropertyID&gt; createAttributeNameToCSSPropertyIDMap()
 69 {
 70     using namespace HTMLNames;
 71     using namespace SVGNames;
 72 
 73     // This list should include all base CSS and SVG CSS properties which are exposed as SVG XML attributes.
 74     static const QualifiedName* const attributeNames[] = {
 75         &amp;alignment_baselineAttr.get(),
 76         &amp;baseline_shiftAttr.get(),
 77         &amp;buffered_renderingAttr.get(),
 78         &amp;clipAttr.get(),
 79         &amp;clip_pathAttr.get(),
 80         &amp;clip_ruleAttr.get(),
 81         &amp;SVGNames::colorAttr.get(),
 82         &amp;color_interpolationAttr.get(),
 83         &amp;color_interpolation_filtersAttr.get(),
 84         &amp;color_profileAttr.get(),
 85         &amp;color_renderingAttr.get(),
 86         &amp;cursorAttr.get(),
 87         &amp;cxAttr.get(),
 88         &amp;cyAttr.get(),
 89         &amp;SVGNames::directionAttr.get(),
 90         &amp;displayAttr.get(),
 91         &amp;dominant_baselineAttr.get(),
 92         &amp;enable_backgroundAttr.get(),
 93         &amp;fillAttr.get(),
 94         &amp;fill_opacityAttr.get(),
 95         &amp;fill_ruleAttr.get(),
 96         &amp;filterAttr.get(),
 97         &amp;flood_colorAttr.get(),
 98         &amp;flood_opacityAttr.get(),
 99         &amp;font_familyAttr.get(),
100         &amp;font_sizeAttr.get(),
101         &amp;font_stretchAttr.get(),
102         &amp;font_styleAttr.get(),
103         &amp;font_variantAttr.get(),
104         &amp;font_weightAttr.get(),
105         &amp;glyph_orientation_horizontalAttr.get(),
106         &amp;glyph_orientation_verticalAttr.get(),
107         &amp;image_renderingAttr.get(),
108         &amp;SVGNames::heightAttr.get(),
109         &amp;kerningAttr.get(),
110         &amp;letter_spacingAttr.get(),
111         &amp;lighting_colorAttr.get(),
112         &amp;marker_endAttr.get(),
113         &amp;marker_midAttr.get(),
114         &amp;marker_startAttr.get(),
115         &amp;maskAttr.get(),
116         &amp;mask_typeAttr.get(),
117         &amp;opacityAttr.get(),
118         &amp;overflowAttr.get(),
119         &amp;paint_orderAttr.get(),
120         &amp;pointer_eventsAttr.get(),
121         &amp;rAttr.get(),
122         &amp;rxAttr.get(),
123         &amp;ryAttr.get(),
124         &amp;shape_renderingAttr.get(),
125         &amp;stop_colorAttr.get(),
126         &amp;stop_opacityAttr.get(),
127         &amp;strokeAttr.get(),
128         &amp;stroke_dasharrayAttr.get(),
129         &amp;stroke_dashoffsetAttr.get(),
130         &amp;stroke_linecapAttr.get(),
131         &amp;stroke_linejoinAttr.get(),
132         &amp;stroke_miterlimitAttr.get(),
133         &amp;stroke_opacityAttr.get(),
134         &amp;stroke_widthAttr.get(),
135         &amp;text_anchorAttr.get(),
136         &amp;text_decorationAttr.get(),
137         &amp;text_renderingAttr.get(),
138         &amp;unicode_bidiAttr.get(),
139         &amp;vector_effectAttr.get(),
140         &amp;visibilityAttr.get(),
141         &amp;SVGNames::widthAttr.get(),
142         &amp;word_spacingAttr.get(),
143         &amp;writing_modeAttr.get(),
144         &amp;xAttr.get(),
145         &amp;yAttr.get(),
146     };
147 
148     HashMap&lt;AtomStringImpl*, CSSPropertyID&gt; map;
149 
150     for (auto&amp; name : attributeNames) {
151         const AtomString&amp; localName = name-&gt;localName();
152         map.add(localName.impl(), cssPropertyID(localName));
153     }
154 
155     // FIXME: When CSS supports &quot;transform-origin&quot; this special case can be removed,
156     // and we can add transform_originAttr to the table above instead.
157     map.add(transform_originAttr-&gt;localName().impl(), CSSPropertyTransformOrigin);
158 
159     return map;
160 }
161 
162 SVGElement::SVGElement(const QualifiedName&amp; tagName, Document&amp; document)
163     : StyledElement(tagName, document, CreateSVGElement)
<a name="2" id="anc2"></a>
164     , m_propertyAnimatorFactory(makeUnique&lt;SVGPropertyAnimatorFactory&gt;())
165 {
166     static std::once_flag onceFlag;
167     std::call_once(onceFlag, [] {
168         PropertyRegistry::registerProperty&lt;HTMLNames::classAttr, &amp;SVGElement::m_className&gt;();
169     });
170 }
171 
172 SVGElement::~SVGElement()
173 {
174     if (m_svgRareData) {
175         for (SVGElement* instance : m_svgRareData-&gt;instances())
176             instance-&gt;m_svgRareData-&gt;setCorrespondingElement(nullptr);
177         if (auto correspondingElement = makeRefPtr(m_svgRareData-&gt;correspondingElement()))
178             correspondingElement-&gt;m_svgRareData-&gt;instances().remove(this);
179 
180         m_svgRareData = nullptr;
181     }
182     document().accessSVGExtensions().rebuildAllElementReferencesForTarget(*this);
183     document().accessSVGExtensions().removeAllElementReferencesForTarget(*this);
184 }
185 
186 void SVGElement::willRecalcStyle(Style::Change change)
187 {
188     if (!m_svgRareData || styleResolutionShouldRecompositeLayer())
189         return;
190     // If the style changes because of a regular property change (not induced by SMIL animations themselves)
191     // reset the &quot;computed style without SMIL style properties&quot;, so the base value change gets reflected.
192     if (change &gt; Style::NoChange || needsStyleRecalc())
193         m_svgRareData-&gt;setNeedsOverrideComputedStyleUpdate();
194 }
195 
196 SVGElementRareData&amp; SVGElement::ensureSVGRareData()
197 {
198     if (!m_svgRareData)
199         m_svgRareData = makeUnique&lt;SVGElementRareData&gt;();
200     return *m_svgRareData;
201 }
202 
203 bool SVGElement::isOutermostSVGSVGElement() const
204 {
205     if (!is&lt;SVGSVGElement&gt;(*this))
206         return false;
207 
208     // If we&#39;re living in a shadow tree, we&#39;re a &lt;svg&gt; element that got created as replacement
209     // for a &lt;symbol&gt; element or a cloned &lt;svg&gt; element in the referenced tree. In that case
210     // we&#39;re always an inner &lt;svg&gt; element.
211     if (isInShadowTree() &amp;&amp; parentOrShadowHostElement() &amp;&amp; parentOrShadowHostElement()-&gt;isSVGElement())
212         return false;
213 
214     // Element may not be in the document, pretend we&#39;re outermost for viewport(), getCTM(), etc.
215     if (!parentNode())
216         return true;
217 
218     // We act like an outermost SVG element, if we&#39;re a direct child of a &lt;foreignObject&gt; element.
219     if (parentNode()-&gt;hasTagName(SVGNames::foreignObjectTag))
220         return true;
221 
222     // This is true whenever this is the outermost SVG, even if there are HTML elements outside it
223     return !parentNode()-&gt;isSVGElement();
224 }
225 
226 void SVGElement::reportAttributeParsingError(SVGParsingError error, const QualifiedName&amp; name, const AtomString&amp; value)
227 {
228     if (error == NoError)
229         return;
230 
231     String errorString = &quot;&lt;&quot; + tagName() + &quot;&gt; attribute &quot; + name.toString() + &quot;=\&quot;&quot; + value + &quot;\&quot;&quot;;
232     SVGDocumentExtensions&amp; extensions = document().accessSVGExtensions();
233 
234     if (error == NegativeValueForbiddenError) {
235         extensions.reportError(&quot;Invalid negative value for &quot; + errorString);
236         return;
237     }
238 
239     if (error == ParsingAttributeFailedError) {
240         extensions.reportError(&quot;Invalid value for &quot; + errorString);
241         return;
242     }
243 
244     ASSERT_NOT_REACHED();
245 }
246 
247 void SVGElement::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
248 {
249     if (removalType.disconnectedFromDocument)
250         updateRelativeLengthsInformation(false, this);
251 
252     StyledElement::removedFromAncestor(removalType, oldParentOfRemovedTree);
253 
254     if (removalType.disconnectedFromDocument) {
255         document().accessSVGExtensions().clearTargetDependencies(*this);
256         document().accessSVGExtensions().removeAllElementReferencesForTarget(*this);
257     }
258     invalidateInstances();
259 }
260 
261 SVGSVGElement* SVGElement::ownerSVGElement() const
262 {
263     ContainerNode* node = parentOrShadowHostNode();
264     while (node) {
265         if (is&lt;SVGSVGElement&gt;(*node))
266             return downcast&lt;SVGSVGElement&gt;(node);
267 
268         node = node-&gt;parentOrShadowHostNode();
269     }
270 
271     return nullptr;
272 }
273 
274 SVGElement* SVGElement::viewportElement() const
275 {
276     // This function needs shadow tree support - as RenderSVGContainer uses this function
277     // to determine the &quot;overflow&quot; property. &lt;use&gt; on &lt;symbol&gt; wouldn&#39;t work otherwhise.
278     ContainerNode* node = parentOrShadowHostNode();
279     while (node) {
280         if (is&lt;SVGSVGElement&gt;(*node) || is&lt;SVGImageElement&gt;(*node) || node-&gt;hasTagName(SVGNames::symbolTag))
281             return downcast&lt;SVGElement&gt;(node);
282 
283         node = node-&gt;parentOrShadowHostNode();
284     }
285 
286     return nullptr;
287 }
288 
289 const HashSet&lt;SVGElement*&gt;&amp; SVGElement::instances() const
290 {
291     if (!m_svgRareData) {
292         static NeverDestroyed&lt;HashSet&lt;SVGElement*&gt;&gt; emptyInstances;
293         return emptyInstances;
294     }
295     return m_svgRareData-&gt;instances();
296 }
297 
298 bool SVGElement::getBoundingBox(FloatRect&amp; rect, SVGLocatable::StyleUpdateStrategy styleUpdateStrategy)
299 {
300     if (is&lt;SVGGraphicsElement&gt;(*this)) {
301         rect = downcast&lt;SVGGraphicsElement&gt;(*this).getBBox(styleUpdateStrategy);
302         return true;
303     }
304     return false;
305 }
306 
307 SVGElement* SVGElement::correspondingElement() const
308 {
309     return m_svgRareData ? m_svgRareData-&gt;correspondingElement() : nullptr;
310 }
311 
312 RefPtr&lt;SVGUseElement&gt; SVGElement::correspondingUseElement() const
313 {
314     auto* root = containingShadowRoot();
315     if (!root)
316         return nullptr;
317     if (root-&gt;mode() != ShadowRootMode::UserAgent)
318         return nullptr;
319     auto* host = root-&gt;host();
320     if (!is&lt;SVGUseElement&gt;(host))
321         return nullptr;
322     return &amp;downcast&lt;SVGUseElement&gt;(*host);
323 }
324 
325 void SVGElement::setCorrespondingElement(SVGElement* correspondingElement)
326 {
327     if (m_svgRareData) {
328         if (auto oldCorrespondingElement = makeRefPtr(m_svgRareData-&gt;correspondingElement()))
329             oldCorrespondingElement-&gt;m_svgRareData-&gt;instances().remove(this);
330     }
331     if (m_svgRareData || correspondingElement)
332         ensureSVGRareData().setCorrespondingElement(correspondingElement);
333     if (correspondingElement)
334         correspondingElement-&gt;ensureSVGRareData().instances().add(this);
335 }
336 
337 void SVGElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
338 {
339     if (name == HTMLNames::classAttr) {
340         m_className-&gt;setBaseValInternal(value);
341         return;
342     }
343 
344     if (name == HTMLNames::tabindexAttr) {
345         if (value.isEmpty())
346             clearTabIndexExplicitlyIfNeeded();
347         else if (auto optionalTabIndex = parseHTMLInteger(value))
348             setTabIndexExplicitly(optionalTabIndex.value());
349         return;
350     }
351 
352     auto&amp; eventName = HTMLElement::eventNameForEventHandlerAttribute(name);
353     if (!eventName.isNull()) {
354         setAttributeEventListener(eventName, name, value);
355         return;
356     }
<a name="3" id="anc3"></a>

357 }
358 
359 bool SVGElement::haveLoadedRequiredResources()
360 {
361     for (auto&amp; child : childrenOfType&lt;SVGElement&gt;(*this)) {
362         if (!child.haveLoadedRequiredResources())
363             return false;
364     }
365     return true;
366 }
367 
368 bool SVGElement::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)
369 {
370     // Add event listener to regular DOM element
371     if (!Node::addEventListener(eventType, listener.copyRef(), options))
372         return false;
373 
374     if (containingShadowRoot())
375         return true;
376 
377     // Add event listener to all shadow tree DOM element instances
378     ASSERT(!instanceUpdatesBlocked());
379     for (auto* instance : instances()) {
380         ASSERT(instance-&gt;correspondingElement() == this);
381         bool result = instance-&gt;Node::addEventListener(eventType, listener.copyRef(), options);
382         ASSERT_UNUSED(result, result);
383     }
384 
385     return true;
386 }
387 
388 bool SVGElement::removeEventListener(const AtomString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)
389 {
390     if (containingShadowRoot())
391         return Node::removeEventListener(eventType, listener, options);
392 
393     // EventTarget::removeEventListener creates a Ref around the given EventListener
394     // object when creating a temporary RegisteredEventListener object used to look up the
395     // event listener in a cache. If we want to be able to call removeEventListener() multiple
396     // times on different nodes, we have to delay its immediate destruction, which would happen
397     // after the first call below.
398     Ref&lt;EventListener&gt; protector(listener);
399 
400     // Remove event listener from regular DOM element
401     if (!Node::removeEventListener(eventType, listener, options))
402         return false;
403 
404     // Remove event listener from all shadow tree DOM element instances
405     ASSERT(!instanceUpdatesBlocked());
406     for (auto&amp; instance : instances()) {
407         ASSERT(instance-&gt;correspondingElement() == this);
408 
409         if (instance-&gt;Node::removeEventListener(eventType, listener, options))
410             continue;
411 
412         // This case can only be hit for event listeners created from markup
413         ASSERT(listener.wasCreatedFromMarkup());
414 
415         // If the event listener &#39;listener&#39; has been created from markup and has been fired before
416         // then JSLazyEventListener::parseCode() has been called and m_jsFunction of that listener
417         // has been created (read: it&#39;s not 0 anymore). During shadow tree creation, the event
418         // listener DOM attribute has been cloned, and another event listener has been setup in
419         // the shadow tree. If that event listener has not been used yet, m_jsFunction is still 0,
420         // and tryRemoveEventListener() above will fail. Work around that very rare problem.
421         ASSERT(instance-&gt;eventTargetData());
422         instance-&gt;eventTargetData()-&gt;eventListenerMap.removeFirstEventListenerCreatedFromMarkup(eventType);
423     }
424 
425     return true;
426 }
427 
428 static bool hasLoadListener(Element* element)
429 {
430     if (element-&gt;hasEventListeners(eventNames().loadEvent))
431         return true;
432 
433     for (element = element-&gt;parentOrShadowHostElement(); element; element = element-&gt;parentOrShadowHostElement()) {
434         if (element-&gt;hasCapturingEventListeners(eventNames().loadEvent))
435             return true;
436     }
437 
438     return false;
439 }
440 
<a name="4" id="anc4"></a><span class="line-modified">441 void SVGElement::sendLoadEventIfPossible()</span>
442 {
443     if (!isConnected() || !document().frame())
444         return;
445 
<a name="5" id="anc5"></a><span class="line-modified">446     if (!haveLoadedRequiredResources() || !hasLoadListener(this))</span>
<span class="line-modified">447         return;</span>






















448 
<a name="6" id="anc6"></a><span class="line-modified">449     dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>


450 }
451 
<a name="7" id="anc7"></a><span class="line-modified">452 void SVGElement::loadEventTimerFired()</span>
453 {
<a name="8" id="anc8"></a><span class="line-modified">454     sendLoadEventIfPossible();</span>
455 }
456 
<a name="9" id="anc9"></a><span class="line-modified">457 Timer* SVGElement::loadEventTimer()</span>
458 {
459     ASSERT_NOT_REACHED();
460     return nullptr;
461 }
462 
463 void SVGElement::finishParsingChildren()
464 {
465     StyledElement::finishParsingChildren();
466 
<a name="10" id="anc10"></a>
467     if (isOutermostSVGSVGElement())
468         return;
469 
<a name="11" id="anc11"></a>



470     // Notify all the elements which have references to this element to rebuild their shadow and render
471     // trees, e.g. a &lt;use&gt; element references a target element before this target element is defined.
472     invalidateInstances();
473 }
474 
475 bool SVGElement::childShouldCreateRenderer(const Node&amp; child) const
476 {
477     if (!child.isSVGElement())
478         return false;
479     auto&amp; svgChild = downcast&lt;SVGElement&gt;(child);
480 
481     static const QualifiedName* const invalidTextContent[] {
482 #if ENABLE(SVG_FONTS)
483         &amp;SVGNames::altGlyphTag.get(),
484 #endif
485         &amp;SVGNames::textPathTag.get(),
486         &amp;SVGNames::trefTag.get(),
487         &amp;SVGNames::tspanTag.get(),
488     };
489     auto&amp; name = svgChild.localName();
490     for (auto* tag : invalidTextContent) {
491         if (name == tag-&gt;localName())
492             return false;
493     }
494 
495     return svgChild.isValid();
496 }
497 
498 void SVGElement::attributeChanged(const QualifiedName&amp; name, const AtomString&amp; oldValue, const AtomString&amp; newValue, AttributeModificationReason)
499 {
500     StyledElement::attributeChanged(name, oldValue, newValue);
501 
502     if (name == HTMLNames::idAttr)
503         document().accessSVGExtensions().rebuildAllElementReferencesForTarget(*this);
504 
505     // Changes to the style attribute are processed lazily (see Element::getAttribute() and related methods),
506     // so we don&#39;t want changes to the style attribute to result in extra work here except invalidateInstances().
507     if (name == HTMLNames::styleAttr)
508         invalidateInstances();
509     else
510         svgAttributeChanged(name);
511 }
512 
513 void SVGElement::synchronizeAttribute(const QualifiedName&amp; name)
514 {
515     // If the value of the property has changed, serialize the new value to the attribute.
516     if (auto value = propertyRegistry().synchronize(name))
517         setSynchronizedLazyAttribute(name, *value);
518 }
519 
520 void SVGElement::synchronizeAllAttributes()
521 {
522     // SVGPropertyRegistry::synchronizeAllAttributes() returns the new values of
523     // the properties which have changed but not committed yet.
524     auto map = propertyRegistry().synchronizeAllAttributes();
525     for (const auto&amp; entry : map)
526         setSynchronizedLazyAttribute(entry.key, entry.value);
527 }
528 
529 void SVGElement::synchronizeAllAnimatedSVGAttribute(SVGElement&amp; svgElement)
530 {
531     svgElement.synchronizeAllAttributes();
532 }
533 
534 void SVGElement::commitPropertyChange(SVGProperty* property)
535 {
536     // We want to dirty the top-level property when a descendant changes. For example
537     // a change in an SVGLength item in SVGLengthList should set the dirty flag on
538     // SVGLengthList and not the SVGLength.
539     property-&gt;setDirty();
540 
541     invalidateSVGAttributes();
542     svgAttributeChanged(propertyRegistry().propertyAttributeName(*property));
543 }
544 
545 void SVGElement::commitPropertyChange(SVGAnimatedProperty&amp; animatedProperty)
546 {
547     QualifiedName attributeName = propertyRegistry().animatedPropertyAttributeName(animatedProperty);
548     ASSERT(attributeName != nullQName());
549 
550     // A change in a style property, e.g SVGRectElement::x should be serialized to
551     // the attribute immediately. Otherwise it is okay to be lazy in this regard.
552     if (!propertyRegistry().isAnimatedStylePropertyAttribute(attributeName))
<a name="12" id="anc12"></a><span class="line-modified">553         propertyRegistry().setAnimatedPropertDirty(attributeName, animatedProperty);</span>
554     else
555         setSynchronizedLazyAttribute(attributeName, animatedProperty.baseValAsString());
556 
557     invalidateSVGAttributes();
558     svgAttributeChanged(attributeName);
559 }
560 
561 bool SVGElement::isAnimatedPropertyAttribute(const QualifiedName&amp; attributeName) const
562 {
563     return propertyRegistry().isAnimatedPropertyAttribute(attributeName);
564 }
565 
566 bool SVGElement::isAnimatedAttribute(const QualifiedName&amp; attributeName) const
567 {
568     return SVGPropertyAnimatorFactory::isKnownAttribute(attributeName) || isAnimatedPropertyAttribute(attributeName);
569 }
570 
571 bool SVGElement::isAnimatedStyleAttribute(const QualifiedName&amp; attributeName) const
572 {
573     return SVGPropertyAnimatorFactory::isKnownAttribute(attributeName) || propertyRegistry().isAnimatedStylePropertyAttribute(attributeName);
574 }
575 
576 RefPtr&lt;SVGAttributeAnimator&gt; SVGElement::createAnimator(const QualifiedName&amp; attributeName, AnimationMode animationMode, CalcMode calcMode, bool isAccumulated, bool isAdditive)
577 {
578     // Property animator, e.g. &quot;fill&quot; or &quot;fill-opacity&quot;.
579     if (auto animator = propertyAnimatorFactory().createAnimator(attributeName, animationMode, calcMode, isAccumulated, isAdditive))
580         return animator;
581 
582     // Animated property animator.
583     auto animator = propertyRegistry().createAnimator(attributeName, animationMode, calcMode, isAccumulated, isAdditive);
584     if (!animator)
585         return animator;
586     for (auto* instance : instances())
587         instance-&gt;propertyRegistry().appendAnimatedInstance(attributeName, *animator);
588     return animator;
589 }
590 
591 void SVGElement::animatorWillBeDeleted(const QualifiedName&amp; attributeName)
592 {
593     propertyAnimatorFactory().animatorWillBeDeleted(attributeName);
594 }
595 
<a name="13" id="anc13"></a><span class="line-modified">596 Optional&lt;Style::ElementStyle&gt; SVGElement::resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle*)</span>
597 {
598     // If the element is in a &lt;use&gt; tree we get the style from the definition tree.
599     if (auto styleElement = makeRefPtr(this-&gt;correspondingElement())) {
<a name="14" id="anc14"></a><span class="line-modified">600         auto style = styleElement-&gt;resolveStyle(&amp;parentStyle);</span>
<span class="line-modified">601         Style::Adjuster::adjustSVGElementStyle(*style.renderStyle, *this);</span>
602         return style;
603     }
604 
605     return resolveStyle(&amp;parentStyle);
606 }
607 
608 MutableStyleProperties* SVGElement::animatedSMILStyleProperties() const
609 {
610     if (m_svgRareData)
611         return m_svgRareData-&gt;animatedSMILStyleProperties();
612     return 0;
613 }
614 
615 MutableStyleProperties&amp; SVGElement::ensureAnimatedSMILStyleProperties()
616 {
617     return ensureSVGRareData().ensureAnimatedSMILStyleProperties();
618 }
619 
620 void SVGElement::setUseOverrideComputedStyle(bool value)
621 {
622     if (m_svgRareData)
623         m_svgRareData-&gt;setUseOverrideComputedStyle(value);
624 }
625 
626 const RenderStyle* SVGElement::computedStyle(PseudoId pseudoElementSpecifier)
627 {
628     if (!m_svgRareData || !m_svgRareData-&gt;useOverrideComputedStyle())
629         return Element::computedStyle(pseudoElementSpecifier);
630 
631     const RenderStyle* parentStyle = nullptr;
632     if (auto parent = makeRefPtr(parentOrShadowHostElement())) {
633         if (auto renderer = parent-&gt;renderer())
634             parentStyle = &amp;renderer-&gt;style();
635     }
636 
637     return m_svgRareData-&gt;overrideComputedStyle(*this, parentStyle);
638 }
639 
640 QualifiedName SVGElement::animatableAttributeForName(const AtomString&amp; localName)
641 {
642     static const auto animatableAttributes = makeNeverDestroyed([] {
643         static const QualifiedName* const names[] = {
644             &amp;HTMLNames::classAttr.get(),
645             &amp;SVGNames::amplitudeAttr.get(),
646             &amp;SVGNames::azimuthAttr.get(),
647             &amp;SVGNames::baseFrequencyAttr.get(),
648             &amp;SVGNames::biasAttr.get(),
649             &amp;SVGNames::clipPathUnitsAttr.get(),
650             &amp;SVGNames::cxAttr.get(),
651             &amp;SVGNames::cyAttr.get(),
652             &amp;SVGNames::diffuseConstantAttr.get(),
653             &amp;SVGNames::divisorAttr.get(),
654             &amp;SVGNames::dxAttr.get(),
655             &amp;SVGNames::dyAttr.get(),
656             &amp;SVGNames::edgeModeAttr.get(),
657             &amp;SVGNames::elevationAttr.get(),
658             &amp;SVGNames::exponentAttr.get(),
659             &amp;SVGNames::externalResourcesRequiredAttr.get(),
660             &amp;SVGNames::filterUnitsAttr.get(),
661             &amp;SVGNames::fxAttr.get(),
662             &amp;SVGNames::fyAttr.get(),
663             &amp;SVGNames::gradientTransformAttr.get(),
664             &amp;SVGNames::gradientUnitsAttr.get(),
665             &amp;SVGNames::heightAttr.get(),
666             &amp;SVGNames::in2Attr.get(),
667             &amp;SVGNames::inAttr.get(),
668             &amp;SVGNames::interceptAttr.get(),
669             &amp;SVGNames::k1Attr.get(),
670             &amp;SVGNames::k2Attr.get(),
671             &amp;SVGNames::k3Attr.get(),
672             &amp;SVGNames::k4Attr.get(),
673             &amp;SVGNames::kernelMatrixAttr.get(),
674             &amp;SVGNames::kernelUnitLengthAttr.get(),
675             &amp;SVGNames::lengthAdjustAttr.get(),
676             &amp;SVGNames::limitingConeAngleAttr.get(),
677             &amp;SVGNames::markerHeightAttr.get(),
678             &amp;SVGNames::markerUnitsAttr.get(),
679             &amp;SVGNames::markerWidthAttr.get(),
680             &amp;SVGNames::maskContentUnitsAttr.get(),
681             &amp;SVGNames::maskUnitsAttr.get(),
682             &amp;SVGNames::methodAttr.get(),
683             &amp;SVGNames::modeAttr.get(),
684             &amp;SVGNames::numOctavesAttr.get(),
685             &amp;SVGNames::offsetAttr.get(),
686             &amp;SVGNames::operatorAttr.get(),
687             &amp;SVGNames::orderAttr.get(),
688             &amp;SVGNames::orientAttr.get(),
689             &amp;SVGNames::pathLengthAttr.get(),
690             &amp;SVGNames::patternContentUnitsAttr.get(),
691             &amp;SVGNames::patternTransformAttr.get(),
692             &amp;SVGNames::patternUnitsAttr.get(),
693             &amp;SVGNames::pointsAtXAttr.get(),
694             &amp;SVGNames::pointsAtYAttr.get(),
695             &amp;SVGNames::pointsAtZAttr.get(),
696             &amp;SVGNames::preserveAlphaAttr.get(),
697             &amp;SVGNames::preserveAspectRatioAttr.get(),
698             &amp;SVGNames::primitiveUnitsAttr.get(),
699             &amp;SVGNames::radiusAttr.get(),
700             &amp;SVGNames::rAttr.get(),
701             &amp;SVGNames::refXAttr.get(),
702             &amp;SVGNames::refYAttr.get(),
703             &amp;SVGNames::resultAttr.get(),
704             &amp;SVGNames::rotateAttr.get(),
705             &amp;SVGNames::rxAttr.get(),
706             &amp;SVGNames::ryAttr.get(),
707             &amp;SVGNames::scaleAttr.get(),
708             &amp;SVGNames::seedAttr.get(),
709             &amp;SVGNames::slopeAttr.get(),
710             &amp;SVGNames::spacingAttr.get(),
711             &amp;SVGNames::specularConstantAttr.get(),
712             &amp;SVGNames::specularExponentAttr.get(),
713             &amp;SVGNames::spreadMethodAttr.get(),
714             &amp;SVGNames::startOffsetAttr.get(),
715             &amp;SVGNames::stdDeviationAttr.get(),
716             &amp;SVGNames::stitchTilesAttr.get(),
717             &amp;SVGNames::surfaceScaleAttr.get(),
718             &amp;SVGNames::tableValuesAttr.get(),
719             &amp;SVGNames::targetAttr.get(),
720             &amp;SVGNames::targetXAttr.get(),
721             &amp;SVGNames::targetYAttr.get(),
722             &amp;SVGNames::transformAttr.get(),
723             &amp;SVGNames::typeAttr.get(),
724             &amp;SVGNames::valuesAttr.get(),
725             &amp;SVGNames::viewBoxAttr.get(),
726             &amp;SVGNames::widthAttr.get(),
727             &amp;SVGNames::x1Attr.get(),
728             &amp;SVGNames::x2Attr.get(),
729             &amp;SVGNames::xAttr.get(),
730             &amp;SVGNames::xChannelSelectorAttr.get(),
731             &amp;SVGNames::y1Attr.get(),
732             &amp;SVGNames::y2Attr.get(),
733             &amp;SVGNames::yAttr.get(),
734             &amp;SVGNames::yChannelSelectorAttr.get(),
735             &amp;SVGNames::zAttr.get(),
736             &amp;SVGNames::hrefAttr.get(),
737         };
738         HashMap&lt;AtomString, QualifiedName&gt; map;
739         for (auto&amp; name : names) {
740             auto addResult = map.add(name-&gt;localName(), *name);
741             ASSERT_UNUSED(addResult, addResult.isNewEntry);
742         }
743         return map;
744     }());
745     return animatableAttributes.get().get(localName);
746 }
747 
748 #ifndef NDEBUG
749 
750 bool SVGElement::isAnimatableAttribute(const QualifiedName&amp; name) const
751 {
752     if (animatableAttributeForName(name.localName()) == name)
753         return !filterOutAnimatableAttribute(name);
754     return false;
755 }
756 
757 bool SVGElement::filterOutAnimatableAttribute(const QualifiedName&amp;) const
758 {
759     return false;
760 }
761 
762 #endif
763 
764 String SVGElement::title() const
765 {
766     // According to spec, for stand-alone SVG documents we should not return a title when
767     // hovering over the rootmost SVG element (the first &lt;title&gt; element is the title of
768     // the document, not a tooltip) so we instantly return.
769     if (isOutermostSVGSVGElement() &amp;&amp; document().topDocument().isSVGDocument())
770         return String();
771     auto firstTitle = childrenOfType&lt;SVGTitleElement&gt;(*this).first();
772     return firstTitle ? const_cast&lt;SVGTitleElement*&gt;(firstTitle)-&gt;innerText() : String();
773 }
774 
775 bool SVGElement::rendererIsNeeded(const RenderStyle&amp; style)
776 {
777     // http://www.w3.org/TR/SVG/extend.html#PrivateData
778     // Prevent anything other than SVG renderers from appearing in our render tree
779     // Spec: SVG allows inclusion of elements from foreign namespaces anywhere
780     // with the SVG content. In general, the SVG user agent will include the unknown
781     // elements in the DOM but will otherwise ignore unknown elements.
782     if (!parentOrShadowHostElement() || parentOrShadowHostElement()-&gt;isSVGElement())
783         return StyledElement::rendererIsNeeded(style);
784 
785     return false;
786 }
787 
788 CSSPropertyID SVGElement::cssPropertyIdForSVGAttributeName(const QualifiedName&amp; attrName)
789 {
790     if (!attrName.namespaceURI().isNull())
791         return CSSPropertyInvalid;
792 
793     static const auto properties = makeNeverDestroyed(createAttributeNameToCSSPropertyIDMap());
794     return properties.get().get(attrName.localName().impl());
795 }
796 
797 bool SVGElement::isPresentationAttribute(const QualifiedName&amp; name) const
798 {
799     if (cssPropertyIdForSVGAttributeName(name) &gt; 0)
800         return true;
801     return StyledElement::isPresentationAttribute(name);
802 }
803 
804 void SVGElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomString&amp; value, MutableStyleProperties&amp; style)
805 {
806     CSSPropertyID propertyID = cssPropertyIdForSVGAttributeName(name);
807     if (propertyID &gt; 0)
808         addPropertyToPresentationAttributeStyle(style, propertyID, value);
809 }
810 
811 void SVGElement::svgAttributeChanged(const QualifiedName&amp; attrName)
812 {
813     CSSPropertyID propId = cssPropertyIdForSVGAttributeName(attrName);
814     if (propId &gt; 0) {
815         invalidateInstances();
816         return;
817     }
818 
819     if (attrName == HTMLNames::classAttr) {
820         classAttributeChanged(className());
821         invalidateInstances();
822         return;
823     }
824 
825     if (attrName == HTMLNames::idAttr) {
826         auto renderer = this-&gt;renderer();
827         // Notify resources about id changes, this is important as we cache resources by id in SVGDocumentExtensions
828         if (is&lt;RenderSVGResourceContainer&gt;(renderer))
829             downcast&lt;RenderSVGResourceContainer&gt;(*renderer).idChanged();
830         if (isConnected())
831             buildPendingResourcesIfNeeded();
832         invalidateInstances();
833         return;
834     }
<a name="15" id="anc15"></a>

835 }
836 
837 Node::InsertedIntoAncestorResult SVGElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
838 {
839     StyledElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
840     updateRelativeLengthsInformation();
841     buildPendingResourcesIfNeeded();
842     return InsertedIntoAncestorResult::Done;
843 }
844 
845 void SVGElement::buildPendingResourcesIfNeeded()
846 {
847     if (!needsPendingResourceHandling() || !isConnected() || isInShadowTree())
848         return;
849 
850     SVGDocumentExtensions&amp; extensions = document().accessSVGExtensions();
851     String resourceId = getIdAttribute();
852     if (!extensions.isIdOfPendingResource(resourceId))
853         return;
854 
855     // Mark pending resources as pending for removal.
856     extensions.markPendingResourcesForRemoval(resourceId);
857 
858     // Rebuild pending resources for each client of a pending resource that is being removed.
859     while (auto clientElement = extensions.removeElementFromPendingResourcesForRemovalMap(resourceId)) {
860         ASSERT(clientElement-&gt;hasPendingResources());
861         if (clientElement-&gt;hasPendingResources()) {
862             clientElement-&gt;buildPendingResource();
863             extensions.clearHasPendingResourcesIfPossible(*clientElement);
864         }
865     }
866 }
867 
868 void SVGElement::childrenChanged(const ChildChange&amp; change)
869 {
870     StyledElement::childrenChanged(change);
871 
872     if (change.source == ChildChangeSource::Parser)
873         return;
874     invalidateInstances();
875 }
876 
<a name="16" id="anc16"></a>


















877 bool SVGElement::instanceUpdatesBlocked() const
878 {
879     return m_svgRareData &amp;&amp; m_svgRareData-&gt;instanceUpdatesBlocked();
880 }
881 
882 void SVGElement::setInstanceUpdatesBlocked(bool value)
883 {
884     // Catch any callers that calls setInstanceUpdatesBlocked(true) twice in a row.
885     // That probably indicates nested use of InstanceUpdateBlocker and a bug.
886     ASSERT(!value || !instanceUpdatesBlocked());
887 
888     if (m_svgRareData)
889         m_svgRareData-&gt;setInstanceUpdatesBlocked(value);
890 }
891 
892 AffineTransform SVGElement::localCoordinateSpaceTransform(SVGLocatable::CTMScope) const
893 {
894     // To be overridden by SVGGraphicsElement (or as special case SVGTextElement and SVGPatternElement)
895     return AffineTransform();
896 }
897 
898 void SVGElement::updateRelativeLengthsInformation(bool hasRelativeLengths, SVGElement* element)
899 {
900     // If we&#39;re not yet in a document, this function will be called again from insertedIntoAncestor(). Do nothing now.
901     if (!isConnected())
902         return;
903 
904     // An element wants to notify us that its own relative lengths state changed.
905     // Register it in the relative length map, and register us in the parent relative length map.
906     // Register the parent in the grandparents map, etc. Repeat procedure until the root of the SVG tree.
907 
908     if (hasRelativeLengths)
909         m_elementsWithRelativeLengths.add(element);
910     else {
911         if (!m_elementsWithRelativeLengths.contains(element)) {
912             // We were never registered. Do nothing.
913             return;
914         }
915 
916         m_elementsWithRelativeLengths.remove(element);
917     }
918 
919     if (!element-&gt;isSVGGraphicsElement())
920         return;
921 
922     // Find first styled parent node, and notify it that we&#39;ve changed our relative length state.
923     auto node = makeRefPtr(parentNode());
924     while (node) {
925         if (!node-&gt;isSVGElement())
926             break;
927 
928         // Register us in the parent element map.
929         downcast&lt;SVGElement&gt;(*node).updateRelativeLengthsInformation(hasRelativeLengths, this);
930         break;
931     }
932 }
933 
934 void SVGElement::accessKeyAction(bool sendMouseEvents)
935 {
936     dispatchSimulatedClick(0, sendMouseEvents ? SendMouseUpDownEvents : SendNoEvents);
937 }
938 
939 void SVGElement::invalidateInstances()
940 {
941     if (instanceUpdatesBlocked())
942         return;
943 
944     auto&amp; instances = this-&gt;instances();
945     while (!instances.isEmpty()) {
946         auto instance = makeRefPtr(*instances.begin());
947         if (auto useElement = instance-&gt;correspondingUseElement())
948             useElement-&gt;invalidateShadowTree();
949         instance-&gt;setCorrespondingElement(nullptr);
950     } while (!instances.isEmpty());
951 }
952 
953 }
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/websockets/WebSocket.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ThreadableWebSocketChannel.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebSocket.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/websockets/WebSocket.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 86         &amp;&amp; character != &#39;{&#39; &amp;&amp; character != &#39;}&#39;;
 87 }
 88 
 89 static bool isValidProtocolString(StringView protocol)
 90 {
 91     if (protocol.isEmpty())
 92         return false;
 93     for (auto codeUnit : protocol.codeUnits()) {
 94         if (!isValidProtocolCharacter(codeUnit))
 95             return false;
 96     }
 97     return true;
 98 }
 99 
100 static String encodeProtocolString(const String&amp; protocol)
101 {
102     StringBuilder builder;
103     for (size_t i = 0; i &lt; protocol.length(); i++) {
104         if (protocol[i] &lt; 0x20 || protocol[i] &gt; 0x7E) {
105             builder.appendLiteral(&quot;\\u&quot;);
<span class="line-modified">106             appendUnsignedAsHexFixedSize(protocol[i], builder, 4);</span>
107         } else if (protocol[i] == 0x5c)
108             builder.appendLiteral(&quot;\\\\&quot;);
109         else
110             builder.append(protocol[i]);
111     }
112     return builder.toString();
113 }
114 
115 static String joinStrings(const Vector&lt;String&gt;&amp; strings, const char* separator)
116 {
117     StringBuilder builder;
118     for (size_t i = 0; i &lt; strings.size(); ++i) {
119         if (i)
120             builder.append(separator);
121         builder.append(strings[i]);
122     }
123     return builder.toString();
124 }
125 
126 static unsigned saturateAdd(unsigned a, unsigned b)
</pre>
<hr />
<pre>
281     // and MUST all be unique strings.&quot;
282     //
283     // Here, we throw SyntaxError if the given protocols do not meet the latter criteria. This behavior does not
284     // comply with WebSocket API specification, but it seems to be the only reasonable way to handle this conflict.
285     for (auto&amp; protocol : protocols) {
286         if (!isValidProtocolString(protocol)) {
287             context.addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Wrong protocol for WebSocket &#39;&quot; + encodeProtocolString(protocol) + &quot;&#39;&quot;);
288             m_state = CLOSED;
289             return Exception { SyntaxError };
290         }
291     }
292     HashSet&lt;String&gt; visited;
293     for (auto&amp; protocol : protocols) {
294         if (!visited.add(protocol).isNewEntry) {
295             context.addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;WebSocket protocols contain duplicates: &#39;&quot; + encodeProtocolString(protocol) + &quot;&#39;&quot;);
296             m_state = CLOSED;
297             return Exception { SyntaxError };
298         }
299     }
300 
<span class="line-modified">301     RunLoop::main().dispatch([targetURL = m_url.isolatedCopy(), mainFrameURL = context.url().isolatedCopy(), sessionID = context.sessionID()]() {</span>
<span class="line-modified">302         ResourceLoadObserver::shared().logWebSocketLoading(targetURL, mainFrameURL, sessionID);</span>
303     });
304 
305     if (is&lt;Document&gt;(context)) {
306         Document&amp; document = downcast&lt;Document&gt;(context);
307         RefPtr&lt;Frame&gt; frame = document.frame();

308         if (!frame || !frame-&gt;loader().mixedContentChecker().canRunInsecureContent(document.securityOrigin(), m_url)) {
309             failAsynchronously();
310             return { };
311         }
312     }
313 
314     String protocolString;
315     if (!protocols.isEmpty())
316         protocolString = joinStrings(protocols, subprotocolSeparator());
317 
318     if (m_channel-&gt;connect(m_url, protocolString) == ThreadableWebSocketChannel::ConnectStatus::KO) {
319         failAsynchronously();
320         return { };
321     }
322 
323     m_pendingActivity = makePendingActivity(*this);
324 
325     return { };
326 }
327 
</pre>
<hr />
<pre>
477 }
478 
479 EventTargetInterface WebSocket::eventTargetInterface() const
480 {
481     return WebSocketEventTargetInterfaceType;
482 }
483 
484 ScriptExecutionContext* WebSocket::scriptExecutionContext() const
485 {
486     return ActiveDOMObject::scriptExecutionContext();
487 }
488 
489 void WebSocket::contextDestroyed()
490 {
491     LOG(Network, &quot;WebSocket %p contextDestroyed()&quot;, this);
492     ASSERT(!m_channel);
493     ASSERT(m_state == CLOSED);
494     ActiveDOMObject::contextDestroyed();
495 }
496 
<span class="line-removed">497 bool WebSocket::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">498 {</span>
<span class="line-removed">499     return true;</span>
<span class="line-removed">500 }</span>
<span class="line-removed">501 </span>
502 void WebSocket::suspend(ReasonForSuspension reason)
503 {
504     if (m_resumeTimer.isActive())
505         m_resumeTimer.stop();
506 
507     m_shouldDelayEventFiring = true;
508 
509     if (m_channel) {
<span class="line-modified">510         if (reason == ReasonForSuspension::PageCache) {</span>
511             // This will cause didClose() to be called.
512             m_channel-&gt;fail(&quot;WebSocket is closed due to suspension.&quot;);
513         } else
514             m_channel-&gt;suspend();
515     }
516 }
517 
518 void WebSocket::resume()
519 {
520     if (m_channel)
521         m_channel-&gt;resume();
522     else if (!m_pendingEvents.isEmpty() &amp;&amp; !m_resumeTimer.isActive()) {
523         // Fire the pending events in a timer as we are not allowed to execute arbitrary JS from resume().
524         m_resumeTimer.startOneShot(0_s);
525     }
526 
527     m_shouldDelayEventFiring = false;
528 }
529 
530 void WebSocket::resumeTimerFired()
</pre>
<hr />
<pre>
567     m_subprotocol = m_channel-&gt;subprotocol();
568     m_extensions = m_channel-&gt;extensions();
569     dispatchEvent(Event::create(eventNames().openEvent, Event::CanBubble::No, Event::IsCancelable::No));
570 }
571 
572 void WebSocket::didReceiveMessage(const String&amp; msg)
573 {
574     LOG(Network, &quot;WebSocket %p didReceiveMessage() Text message &#39;%s&#39;&quot;, this, msg.utf8().data());
575     if (m_state != OPEN)
576         return;
577     ASSERT(scriptExecutionContext());
578     dispatchEvent(MessageEvent::create(msg, SecurityOrigin::create(m_url)-&gt;toString()));
579 }
580 
581 void WebSocket::didReceiveBinaryData(Vector&lt;uint8_t&gt;&amp;&amp; binaryData)
582 {
583     LOG(Network, &quot;WebSocket %p didReceiveBinaryData() %u byte binary message&quot;, this, static_cast&lt;unsigned&gt;(binaryData.size()));
584     switch (m_binaryType) {
585     case BinaryType::Blob:
586         // FIXME: We just received the data from NetworkProcess, and are sending it back. This is inefficient.
<span class="line-modified">587         dispatchEvent(MessageEvent::create(Blob::create(scriptExecutionContext()-&gt;sessionID(), WTFMove(binaryData), emptyString()), SecurityOrigin::create(m_url)-&gt;toString()));</span>
588         break;
589     case BinaryType::ArrayBuffer:
590         dispatchEvent(MessageEvent::create(ArrayBuffer::create(binaryData.data(), binaryData.size()), SecurityOrigin::create(m_url)-&gt;toString()));
591         break;
592     }
593 }
594 
595 void WebSocket::didReceiveMessageError()
596 {
597     LOG(Network, &quot;WebSocket %p didReceiveErrorMessage()&quot;, this);
598     m_state = CLOSED;
599     ASSERT(scriptExecutionContext());
600     dispatchOrQueueErrorEvent();
601 }
602 
603 void WebSocket::didUpdateBufferedAmount(unsigned bufferedAmount)
604 {
605     LOG(Network, &quot;WebSocket %p didUpdateBufferedAmount() New bufferedAmount is %u&quot;, this, bufferedAmount);
606     if (m_state == CLOSED)
607         return;
</pre>
</td>
<td>
<hr />
<pre>
 86         &amp;&amp; character != &#39;{&#39; &amp;&amp; character != &#39;}&#39;;
 87 }
 88 
 89 static bool isValidProtocolString(StringView protocol)
 90 {
 91     if (protocol.isEmpty())
 92         return false;
 93     for (auto codeUnit : protocol.codeUnits()) {
 94         if (!isValidProtocolCharacter(codeUnit))
 95             return false;
 96     }
 97     return true;
 98 }
 99 
100 static String encodeProtocolString(const String&amp; protocol)
101 {
102     StringBuilder builder;
103     for (size_t i = 0; i &lt; protocol.length(); i++) {
104         if (protocol[i] &lt; 0x20 || protocol[i] &gt; 0x7E) {
105             builder.appendLiteral(&quot;\\u&quot;);
<span class="line-modified">106             builder.append(hex(protocol[i], 4));</span>
107         } else if (protocol[i] == 0x5c)
108             builder.appendLiteral(&quot;\\\\&quot;);
109         else
110             builder.append(protocol[i]);
111     }
112     return builder.toString();
113 }
114 
115 static String joinStrings(const Vector&lt;String&gt;&amp; strings, const char* separator)
116 {
117     StringBuilder builder;
118     for (size_t i = 0; i &lt; strings.size(); ++i) {
119         if (i)
120             builder.append(separator);
121         builder.append(strings[i]);
122     }
123     return builder.toString();
124 }
125 
126 static unsigned saturateAdd(unsigned a, unsigned b)
</pre>
<hr />
<pre>
281     // and MUST all be unique strings.&quot;
282     //
283     // Here, we throw SyntaxError if the given protocols do not meet the latter criteria. This behavior does not
284     // comply with WebSocket API specification, but it seems to be the only reasonable way to handle this conflict.
285     for (auto&amp; protocol : protocols) {
286         if (!isValidProtocolString(protocol)) {
287             context.addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Wrong protocol for WebSocket &#39;&quot; + encodeProtocolString(protocol) + &quot;&#39;&quot;);
288             m_state = CLOSED;
289             return Exception { SyntaxError };
290         }
291     }
292     HashSet&lt;String&gt; visited;
293     for (auto&amp; protocol : protocols) {
294         if (!visited.add(protocol).isNewEntry) {
295             context.addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;WebSocket protocols contain duplicates: &#39;&quot; + encodeProtocolString(protocol) + &quot;&#39;&quot;);
296             m_state = CLOSED;
297             return Exception { SyntaxError };
298         }
299     }
300 
<span class="line-modified">301     RunLoop::main().dispatch([targetURL = m_url.isolatedCopy(), mainFrameURL = context.url().isolatedCopy()]() {</span>
<span class="line-modified">302         ResourceLoadObserver::shared().logWebSocketLoading(targetURL, mainFrameURL);</span>
303     });
304 
305     if (is&lt;Document&gt;(context)) {
306         Document&amp; document = downcast&lt;Document&gt;(context);
307         RefPtr&lt;Frame&gt; frame = document.frame();
<span class="line-added">308         // FIXME: make the mixed content check equivalent to the non-document mixed content check currently in WorkerThreadableWebSocketChannel::Bridge::connect()</span>
309         if (!frame || !frame-&gt;loader().mixedContentChecker().canRunInsecureContent(document.securityOrigin(), m_url)) {
310             failAsynchronously();
311             return { };
312         }
313     }
314 
315     String protocolString;
316     if (!protocols.isEmpty())
317         protocolString = joinStrings(protocols, subprotocolSeparator());
318 
319     if (m_channel-&gt;connect(m_url, protocolString) == ThreadableWebSocketChannel::ConnectStatus::KO) {
320         failAsynchronously();
321         return { };
322     }
323 
324     m_pendingActivity = makePendingActivity(*this);
325 
326     return { };
327 }
328 
</pre>
<hr />
<pre>
478 }
479 
480 EventTargetInterface WebSocket::eventTargetInterface() const
481 {
482     return WebSocketEventTargetInterfaceType;
483 }
484 
485 ScriptExecutionContext* WebSocket::scriptExecutionContext() const
486 {
487     return ActiveDOMObject::scriptExecutionContext();
488 }
489 
490 void WebSocket::contextDestroyed()
491 {
492     LOG(Network, &quot;WebSocket %p contextDestroyed()&quot;, this);
493     ASSERT(!m_channel);
494     ASSERT(m_state == CLOSED);
495     ActiveDOMObject::contextDestroyed();
496 }
497 





498 void WebSocket::suspend(ReasonForSuspension reason)
499 {
500     if (m_resumeTimer.isActive())
501         m_resumeTimer.stop();
502 
503     m_shouldDelayEventFiring = true;
504 
505     if (m_channel) {
<span class="line-modified">506         if (reason == ReasonForSuspension::BackForwardCache) {</span>
507             // This will cause didClose() to be called.
508             m_channel-&gt;fail(&quot;WebSocket is closed due to suspension.&quot;);
509         } else
510             m_channel-&gt;suspend();
511     }
512 }
513 
514 void WebSocket::resume()
515 {
516     if (m_channel)
517         m_channel-&gt;resume();
518     else if (!m_pendingEvents.isEmpty() &amp;&amp; !m_resumeTimer.isActive()) {
519         // Fire the pending events in a timer as we are not allowed to execute arbitrary JS from resume().
520         m_resumeTimer.startOneShot(0_s);
521     }
522 
523     m_shouldDelayEventFiring = false;
524 }
525 
526 void WebSocket::resumeTimerFired()
</pre>
<hr />
<pre>
563     m_subprotocol = m_channel-&gt;subprotocol();
564     m_extensions = m_channel-&gt;extensions();
565     dispatchEvent(Event::create(eventNames().openEvent, Event::CanBubble::No, Event::IsCancelable::No));
566 }
567 
568 void WebSocket::didReceiveMessage(const String&amp; msg)
569 {
570     LOG(Network, &quot;WebSocket %p didReceiveMessage() Text message &#39;%s&#39;&quot;, this, msg.utf8().data());
571     if (m_state != OPEN)
572         return;
573     ASSERT(scriptExecutionContext());
574     dispatchEvent(MessageEvent::create(msg, SecurityOrigin::create(m_url)-&gt;toString()));
575 }
576 
577 void WebSocket::didReceiveBinaryData(Vector&lt;uint8_t&gt;&amp;&amp; binaryData)
578 {
579     LOG(Network, &quot;WebSocket %p didReceiveBinaryData() %u byte binary message&quot;, this, static_cast&lt;unsigned&gt;(binaryData.size()));
580     switch (m_binaryType) {
581     case BinaryType::Blob:
582         // FIXME: We just received the data from NetworkProcess, and are sending it back. This is inefficient.
<span class="line-modified">583         dispatchEvent(MessageEvent::create(Blob::create(WTFMove(binaryData), emptyString()), SecurityOrigin::create(m_url)-&gt;toString()));</span>
584         break;
585     case BinaryType::ArrayBuffer:
586         dispatchEvent(MessageEvent::create(ArrayBuffer::create(binaryData.data(), binaryData.size()), SecurityOrigin::create(m_url)-&gt;toString()));
587         break;
588     }
589 }
590 
591 void WebSocket::didReceiveMessageError()
592 {
593     LOG(Network, &quot;WebSocket %p didReceiveErrorMessage()&quot;, this);
594     m_state = CLOSED;
595     ASSERT(scriptExecutionContext());
596     dispatchOrQueueErrorEvent();
597 }
598 
599 void WebSocket::didUpdateBufferedAmount(unsigned bufferedAmount)
600 {
601     LOG(Network, &quot;WebSocket %p didUpdateBufferedAmount() New bufferedAmount is %u&quot;, this, bufferedAmount);
602     if (m_state == CLOSED)
603         return;
</pre>
</td>
</tr>
</table>
<center><a href="ThreadableWebSocketChannel.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebSocket.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Path.h b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Path.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Path.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Path.h
@@ -48,10 +48,14 @@
 interface ID2D1PathGeometry;
 interface ID2D1GeometrySink;
 
 typedef ID2D1GeometryGroup PlatformPath;
 
+namespace WebCore {
+class PlatformContextDirect2D;
+}
+
 #elif USE(CAIRO)
 
 namespace WebCore {
 class CairoPath;
 }
@@ -85,151 +89,252 @@
 class TextStream;
 }
 
 namespace WebCore {
 
-    class AffineTransform;
-    class FloatPoint;
-    class FloatRoundedRect;
-    class FloatSize;
-    class GraphicsContext;
-    class PathTraversalState;
-    class RoundedRect;
-    class StrokeStyleApplier;
-
-    enum PathElementType {
-        PathElementMoveToPoint, // The points member will contain 1 value.
-        PathElementAddLineToPoint, // The points member will contain 1 value.
-        PathElementAddQuadCurveToPoint, // The points member will contain 2 values.
-        PathElementAddCurveToPoint, // The points member will contain 3 values.
-        PathElementCloseSubpath // The points member will contain no values.
+class AffineTransform;
+class FloatPoint;
+class FloatRoundedRect;
+class FloatSize;
+class GraphicsContext;
+class PathTraversalState;
+class RoundedRect;
+class StrokeStyleApplier;
+
+// The points in the structure are the same as those that would be used with the
+// add... method. For example, a line returns the endpoint, while a cubic returns
+// two tangent points and the endpoint.
+struct PathElement {
+    enum class Type : uint8_t {
+        MoveToPoint, // The points member will contain 1 value.
+        AddLineToPoint, // The points member will contain 1 value.
+        AddQuadCurveToPoint, // The points member will contain 2 values.
+        AddCurveToPoint, // The points member will contain 3 values.
+        CloseSubpath // The points member will contain no values.
     };
 
-    // The points in the structure are the same as those that would be used with the
-    // add... method. For example, a line returns the endpoint, while a cubic returns
-    // two tangent points and the endpoint.
-    struct PathElement {
-        PathElementType type;
-        FloatPoint* points;
-    };
+    FloatPoint points[3];
+    Type type;
+};
 
-    using PathApplierFunction = WTF::Function<void (const PathElement&)>;
+using PathApplierFunction = WTF::Function<void(const PathElement&)>;
 
-    class Path {
-        WTF_MAKE_FAST_ALLOCATED;
-    public:
-        WEBCORE_EXPORT Path();
+class Path {
+    WTF_MAKE_FAST_ALLOCATED;
+public:
+    WEBCORE_EXPORT Path();
 #if USE(CG)
-        Path(RetainPtr<CGMutablePathRef>);
+    Path(RetainPtr<CGMutablePathRef>);
 #endif
-        WEBCORE_EXPORT ~Path();
-
-        WEBCORE_EXPORT Path(const Path&);
-        WEBCORE_EXPORT Path(Path&&);
-        WEBCORE_EXPORT Path& operator=(const Path&);
-        WEBCORE_EXPORT Path& operator=(Path&&);
-
-        static Path polygonPathFromPoints(const Vector<FloatPoint>&);
-
-        bool contains(const FloatPoint&, WindRule = WindRule::NonZero) const;
-        bool strokeContains(StrokeStyleApplier*, const FloatPoint&) const;
-        // fastBoundingRect() should equal or contain boundingRect(); boundingRect()
-        // should perfectly bound the points within the path.
-        FloatRect boundingRect() const;
-        WEBCORE_EXPORT FloatRect fastBoundingRect() const;
-        FloatRect strokeBoundingRect(StrokeStyleApplier* = 0) const;
-
-        float length() const;
-        PathTraversalState traversalStateAtLength(float length, bool& success) const;
-        FloatPoint pointAtLength(float length, bool& success) const;
-        float normalAngleAtLength(float length, bool& success) const;
-
-        WEBCORE_EXPORT void clear();
-        bool isNull() const { return !m_path; }
-        bool isEmpty() const;
-        // Gets the current point of the current path, which is conceptually the final point reached by the path so far.
-        // Note the Path can be empty (isEmpty() == true) and still have a current point.
-        bool hasCurrentPoint() const;
-        FloatPoint currentPoint() const;
-
-        WEBCORE_EXPORT void moveTo(const FloatPoint&);
-        WEBCORE_EXPORT void addLineTo(const FloatPoint&);
-        WEBCORE_EXPORT void addQuadCurveTo(const FloatPoint& controlPoint, const FloatPoint& endPoint);
-        WEBCORE_EXPORT void addBezierCurveTo(const FloatPoint& controlPoint1, const FloatPoint& controlPoint2, const FloatPoint& endPoint);
-        void addArcTo(const FloatPoint&, const FloatPoint&, float radius);
-        WEBCORE_EXPORT void closeSubpath();
-
-        void addArc(const FloatPoint&, float radius, float startAngle, float endAngle, bool anticlockwise);
-        void addRect(const FloatRect&);
-        void addEllipse(FloatPoint, float radiusX, float radiusY, float rotation, float startAngle, float endAngle, bool anticlockwise);
-        void addEllipse(const FloatRect&);
-
-        enum RoundedRectStrategy {
-            PreferNativeRoundedRect,
-            PreferBezierRoundedRect
-        };
-
-        WEBCORE_EXPORT void addRoundedRect(const FloatRect&, const FloatSize& roundingRadii, RoundedRectStrategy = PreferNativeRoundedRect);
-        WEBCORE_EXPORT void addRoundedRect(const FloatRoundedRect&, RoundedRectStrategy = PreferNativeRoundedRect);
-        void addRoundedRect(const RoundedRect&);
-
-        void addPath(const Path&, const AffineTransform&);
-
-        void translate(const FloatSize&);
-
-        // To keep Path() cheap, it does not allocate a PlatformPath immediately
-        // meaning Path::platformPath() can return null.
+    WEBCORE_EXPORT ~Path();
+
+    WEBCORE_EXPORT Path(const Path&);
+    WEBCORE_EXPORT Path(Path&&);
+    WEBCORE_EXPORT Path& operator=(const Path&);
+    WEBCORE_EXPORT Path& operator=(Path&&);
+
+    static Path polygonPathFromPoints(const Vector<FloatPoint>&);
+
+    bool contains(const FloatPoint&, WindRule = WindRule::NonZero) const;
+    bool strokeContains(StrokeStyleApplier&, const FloatPoint&) const;
+    // fastBoundingRect() should equal or contain boundingRect(); boundingRect()
+    // should perfectly bound the points within the path.
+    FloatRect boundingRect() const;
+    WEBCORE_EXPORT FloatRect fastBoundingRect() const;
+    FloatRect strokeBoundingRect(StrokeStyleApplier* = 0) const;
+
+    float length() const;
+    PathTraversalState traversalStateAtLength(float length) const;
+    FloatPoint pointAtLength(float length) const;
+
+    WEBCORE_EXPORT void clear();
+    bool isNull() const { return !m_path; }
+    bool isEmpty() const;
+    // Gets the current point of the current path, which is conceptually the final point reached by the path so far.
+    // Note the Path can be empty (isEmpty() == true) and still have a current point.
+    bool hasCurrentPoint() const;
+    FloatPoint currentPoint() const;
+
+    WEBCORE_EXPORT void moveTo(const FloatPoint&);
+    WEBCORE_EXPORT void addLineTo(const FloatPoint&);
+    WEBCORE_EXPORT void addQuadCurveTo(const FloatPoint& controlPoint, const FloatPoint& endPoint);
+    WEBCORE_EXPORT void addBezierCurveTo(const FloatPoint& controlPoint1, const FloatPoint& controlPoint2, const FloatPoint& endPoint);
+    void addArcTo(const FloatPoint&, const FloatPoint&, float radius);
+    WEBCORE_EXPORT void closeSubpath();
+
+    void addArc(const FloatPoint&, float radius, float startAngle, float endAngle, bool anticlockwise);
+    void addRect(const FloatRect&);
+    void addEllipse(FloatPoint, float radiusX, float radiusY, float rotation, float startAngle, float endAngle, bool anticlockwise);
+    void addEllipse(const FloatRect&);
+
+    enum class RoundedRectStrategy : uint8_t {
+        PreferNative,
+        PreferBezier
+    };
+
+    WEBCORE_EXPORT void addRoundedRect(const FloatRect&, const FloatSize& roundingRadii, RoundedRectStrategy = RoundedRectStrategy::PreferNative);
+    WEBCORE_EXPORT void addRoundedRect(const FloatRoundedRect&, RoundedRectStrategy = RoundedRectStrategy::PreferNative);
+    void addRoundedRect(const RoundedRect&);
+
+    void addPath(const Path&, const AffineTransform&);
+
+    void translate(const FloatSize&);
+
+    // To keep Path() cheap, it does not allocate a PlatformPath immediately
+    // meaning Path::platformPath() can return null.
 #if USE(DIRECT2D)
-        PlatformPathPtr platformPath() const { return m_path.get(); }
+    FloatRect fastBoundingRectForStroke(const PlatformContextDirect2D&) const;
+    PlatformPathPtr platformPath() const { return m_path.get(); }
 #else
-        PlatformPathPtr platformPath() const { return m_path; }
+    PlatformPathPtr platformPath() const { return m_path; }
 #endif
-        // ensurePlatformPath() will allocate a PlatformPath if it has not yet been and will never return null.
-        WEBCORE_EXPORT PlatformPathPtr ensurePlatformPath();
+    // ensurePlatformPath() will allocate a PlatformPath if it has not yet been and will never return null.
+    WEBCORE_EXPORT PlatformPathPtr ensurePlatformPath();
 
-        WEBCORE_EXPORT void apply(const PathApplierFunction&) const;
-        void transform(const AffineTransform&);
+    WEBCORE_EXPORT void apply(const PathApplierFunction&) const;
+    void transform(const AffineTransform&);
 
-        static float circleControlPoint()
-        {
-            // Approximation of control point positions on a bezier to simulate a quarter of a circle.
-            // This is 1-kappa, where kappa = 4 * (sqrt(2) - 1) / 3
-            return 0.447715;
-        }
+    static float circleControlPoint()
+    {
+        // Approximation of control point positions on a bezier to simulate a quarter of a circle.
+        // This is 1-kappa, where kappa = 4 * (sqrt(2) - 1) / 3
+        return 0.447715;
+    }
 
-        void addBeziersForRoundedRect(const FloatRect&, const FloatSize& topLeftRadius, const FloatSize& topRightRadius, const FloatSize& bottomLeftRadius, const FloatSize& bottomRightRadius);
+    void addBeziersForRoundedRect(const FloatRect&, const FloatSize& topLeftRadius, const FloatSize& topRightRadius, const FloatSize& bottomLeftRadius, const FloatSize& bottomRightRadius);
 
 #if USE(CG) || USE(DIRECT2D)
-        void platformAddPathForRoundedRect(const FloatRect&, const FloatSize& topLeftRadius, const FloatSize& topRightRadius, const FloatSize& bottomLeftRadius, const FloatSize& bottomRightRadius);
+    void platformAddPathForRoundedRect(const FloatRect&, const FloatSize& topLeftRadius, const FloatSize& topRightRadius, const FloatSize& bottomLeftRadius, const FloatSize& bottomRightRadius);
 #endif
 
 #if USE(DIRECT2D)
-        ID2D1GeometrySink* activePath() const { return m_activePath.get(); }
-        void appendGeometry(ID2D1Geometry*);
-        void createGeometryWithFillMode(WindRule, COMPtr<ID2D1GeometryGroup>&) const;
-        void drawDidComplete();
-
-        HRESULT initializePathState();
-        void openFigureAtCurrentPointIfNecessary();
-        void closeAnyOpenGeometries();
+    void appendGeometry(ID2D1Geometry*);
+    void createGeometryWithFillMode(WindRule, COMPtr<ID2D1GeometryGroup>&) const;
+
+    void openFigureAtCurrentPointIfNecessary();
+    void closeAnyOpenGeometries(unsigned figureEndStyle) const;
+    void clearGeometries();
 #endif
 
 #ifndef NDEBUG
-        void dump() const;
+    void dump() const;
 #endif
 
-    private:
+    template<class Encoder> void encode(Encoder&) const;
+    template<class Decoder> static Optional<Path> decode(Decoder&);
+
+private:
 #if USE(DIRECT2D)
-        COMPtr<ID2D1GeometryGroup> m_path;
-        COMPtr<ID2D1PathGeometry> m_activePathGeometry;
-        COMPtr<ID2D1GeometrySink> m_activePath;
-        size_t m_openFigureCount { 0 };
+    Vector<ID2D1Geometry*> m_geometries;
+    COMPtr<ID2D1GeometryGroup> m_path;
+    mutable COMPtr<ID2D1GeometrySink> m_activePath;
+    mutable bool m_figureIsOpened { false };
 #else
-        PlatformPathPtr m_path { nullptr };
+    PlatformPathPtr m_path { nullptr };
 #endif
-    };
+};
 
 WTF::TextStream& operator<<(WTF::TextStream&, const Path&);
 
+template<class Encoder> void Path::encode(Encoder& encoder) const
+{
+    uint64_t numPoints = 0;
+    apply([&numPoints](const PathElement&) {
+        ++numPoints;
+    });
+
+    encoder << numPoints;
+
+    apply([&](auto& element) {
+        encoder.encodeEnum(element.type);
+
+        switch (element.type) {
+        case PathElement::Type::MoveToPoint:
+            encoder << element.points[0];
+            break;
+        case PathElement::Type::AddLineToPoint:
+            encoder << element.points[0];
+            break;
+        case PathElement::Type::AddQuadCurveToPoint:
+            encoder << element.points[0];
+            encoder << element.points[1];
+            break;
+        case PathElement::Type::AddCurveToPoint:
+            encoder << element.points[0];
+            encoder << element.points[1];
+            encoder << element.points[2];
+            break;
+        case PathElement::Type::CloseSubpath:
+            break;
+        }
+    });
+}
+
+template<class Decoder> Optional<Path> Path::decode(Decoder& decoder)
+{
+    Path path;
+    uint64_t numPoints;
+    if (!decoder.decode(numPoints))
+        return WTF::nullopt;
+
+    path.clear();
+
+    for (uint64_t i = 0; i < numPoints; ++i) {
+        PathElement::Type elementType;
+        if (!decoder.decodeEnum(elementType))
+            return WTF::nullopt;
+
+        switch (elementType) {
+        case PathElement::Type::MoveToPoint: {
+            FloatPoint point;
+            if (!decoder.decode(point))
+                return WTF::nullopt;
+            path.moveTo(point);
+            break;
+        }
+        case PathElement::Type::AddLineToPoint: {
+            FloatPoint point;
+            if (!decoder.decode(point))
+                return WTF::nullopt;
+            path.addLineTo(point);
+            break;
+        }
+        case PathElement::Type::AddQuadCurveToPoint: {
+            FloatPoint controlPoint;
+            if (!decoder.decode(controlPoint))
+                return WTF::nullopt;
+
+            FloatPoint endPoint;
+            if (!decoder.decode(endPoint))
+                return WTF::nullopt;
+
+            path.addQuadCurveTo(controlPoint, endPoint);
+            break;
+        }
+        case PathElement::Type::AddCurveToPoint: {
+            FloatPoint controlPoint1;
+            if (!decoder.decode(controlPoint1))
+                return WTF::nullopt;
+
+            FloatPoint controlPoint2;
+            if (!decoder.decode(controlPoint2))
+                return WTF::nullopt;
+
+            FloatPoint endPoint;
+            if (!decoder.decode(endPoint))
+                return WTF::nullopt;
+
+            path.addBezierCurveTo(controlPoint1, controlPoint2, endPoint);
+            break;
+        }
+        case PathElement::Type::CloseSubpath:
+            path.closeSubpath();
+            break;
+        }
+    }
+
+    return path;
+}
+
 }
 
 #endif

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSPropertyParserHelpers.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Copyright 2016 The Chromium Authors. All rights reserved.
  2 // Copyright (C) 2016 Apple Inc. All rights reserved.
  3 //
  4 // Redistribution and use in source and binary forms, with or without
  5 // modification, are permitted provided that the following conditions are
  6 // met:
  7 //
  8 //    * Redistributions of source code must retain the above copyright
  9 // notice, this list of conditions and the following disclaimer.
 10 //    * Redistributions in binary form must reproduce the above
 11 // copyright notice, this list of conditions and the following disclaimer
 12 // in the documentation and/or other materials provided with the
 13 // distribution.
 14 //    * Neither the name of Google Inc. nor the names of its
 15 // contributors may be used to endorse or promote products derived from
 16 // this software without specific prior written permission.
 17 //
 18 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29 
 30 #pragma once
 31 
 32 #include &quot;CSSFunctionValue.h&quot;
 33 #include &quot;CSSParserContext.h&quot;
 34 #include &quot;CSSParserTokenRange.h&quot;
 35 #include &quot;CSSPrimitiveValue.h&quot;
 36 #include &quot;CSSShadowValue.h&quot;
 37 #include &quot;CSSValuePool.h&quot;
 38 #include &quot;Length.h&quot; // For ValueRange
 39 #include &lt;wtf/OptionSet.h&gt;
 40 
 41 namespace WebCore {
 42 
 43 // When these functions are successful, they will consume all the relevant
 44 // tokens from the range and also consume any whitespace which follows. When
 45 // the start of the range doesn&#39;t match the type we&#39;re looking for, the range
 46 // will not be modified.
 47 namespace CSSPropertyParserHelpers {
 48 
 49 // FIXME: These should probably just be consumeComma and consumeSlash.
 50 bool consumeCommaIncludingWhitespace(CSSParserTokenRange&amp;);
 51 bool consumeSlashIncludingWhitespace(CSSParserTokenRange&amp;);
 52 // consumeFunction expects the range starts with a FunctionToken.
 53 CSSParserTokenRange consumeFunction(CSSParserTokenRange&amp;);
 54 
 55 enum class UnitlessQuirk { Allow, Forbid };
 56 enum class AllowXResolutionUnit { Allow, Forbid };
 57 
 58 RefPtr&lt;CSSPrimitiveValue&gt; consumeInteger(CSSParserTokenRange&amp;, double minimumValue = -std::numeric_limits&lt;double&gt;::max());
 59 RefPtr&lt;CSSPrimitiveValue&gt; consumePositiveInteger(CSSParserTokenRange&amp;);
 60 bool consumeNumberRaw(CSSParserTokenRange&amp;, double&amp; result);
 61 RefPtr&lt;CSSPrimitiveValue&gt; consumeNumber(CSSParserTokenRange&amp;, ValueRange);
 62 RefPtr&lt;CSSPrimitiveValue&gt; consumeFontWeightNumber(CSSParserTokenRange&amp;);
 63 RefPtr&lt;CSSPrimitiveValue&gt; consumeLength(CSSParserTokenRange&amp;, CSSParserMode, ValueRange, UnitlessQuirk = UnitlessQuirk::Forbid);
 64 RefPtr&lt;CSSPrimitiveValue&gt; consumePercent(CSSParserTokenRange&amp;, ValueRange);
 65 RefPtr&lt;CSSPrimitiveValue&gt; consumeLengthOrPercent(CSSParserTokenRange&amp;, CSSParserMode, ValueRange, UnitlessQuirk = UnitlessQuirk::Forbid);
 66 RefPtr&lt;CSSPrimitiveValue&gt; consumeAngle(CSSParserTokenRange&amp;, CSSParserMode, UnitlessQuirk = UnitlessQuirk::Forbid);
 67 RefPtr&lt;CSSPrimitiveValue&gt; consumeTime(CSSParserTokenRange&amp;, CSSParserMode, ValueRange, UnitlessQuirk = UnitlessQuirk::Forbid);
 68 RefPtr&lt;CSSPrimitiveValue&gt; consumeResolution(CSSParserTokenRange&amp;, AllowXResolutionUnit = AllowXResolutionUnit::Forbid);
 69 
 70 RefPtr&lt;CSSPrimitiveValue&gt; consumeIdent(CSSParserTokenRange&amp;);
 71 RefPtr&lt;CSSPrimitiveValue&gt; consumeIdentRange(CSSParserTokenRange&amp;, CSSValueID lower, CSSValueID upper);
 72 template&lt;CSSValueID, CSSValueID...&gt; inline bool identMatches(CSSValueID id);
 73 template&lt;CSSValueID... allowedIdents&gt; RefPtr&lt;CSSPrimitiveValue&gt; consumeIdent(CSSParserTokenRange&amp;);
 74 
 75 RefPtr&lt;CSSPrimitiveValue&gt; consumeCustomIdent(CSSParserTokenRange&amp;);
 76 RefPtr&lt;CSSPrimitiveValue&gt; consumeString(CSSParserTokenRange&amp;);
 77 StringView consumeUrlAsStringView(CSSParserTokenRange&amp;);
 78 RefPtr&lt;CSSPrimitiveValue&gt; consumeUrl(CSSParserTokenRange&amp;);
 79 
 80 RefPtr&lt;CSSPrimitiveValue&gt; consumeColor(CSSParserTokenRange&amp;, CSSParserMode, bool acceptQuirkyColors = false);
 81 
 82 enum class PositionSyntax {
 83     Position, // &lt;position&gt;
 84     BackgroundPosition // &lt;bg-position&gt;
 85 };
 86 
 87 RefPtr&lt;CSSPrimitiveValue&gt; consumePosition(CSSParserTokenRange&amp;, CSSParserMode, UnitlessQuirk, PositionSyntax);
 88 bool consumePosition(CSSParserTokenRange&amp;, CSSParserMode, UnitlessQuirk, PositionSyntax, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultX, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultY);
 89 bool consumeOneOrTwoValuedPosition(CSSParserTokenRange&amp;, CSSParserMode, UnitlessQuirk, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultX, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultY);
 90 
 91 enum class AllowedImageType : uint8_t {
 92     URLFunction = 1 &lt;&lt; 0,
 93     RawStringAsURL = 1 &lt;&lt; 1,
 94     ImageSet = 1 &lt;&lt; 2,
 95     GeneratedImage = 1 &lt;&lt; 3
 96 };
 97 
 98 RefPtr&lt;CSSValue&gt; consumeImage(CSSParserTokenRange&amp;, CSSParserContext, OptionSet&lt;AllowedImageType&gt; = { AllowedImageType::URLFunction, AllowedImageType::ImageSet, AllowedImageType::GeneratedImage });
 99 
100 RefPtr&lt;CSSValue&gt; consumeImageOrNone(CSSParserTokenRange&amp;, CSSParserContext);
101 
102 enum class AllowedFilterFunctions {
103     PixelFilters,
104     ColorFilters
105 };
106 
107 RefPtr&lt;CSSValue&gt; consumeFilter(CSSParserTokenRange&amp;, const CSSParserContext&amp;, AllowedFilterFunctions);
108 RefPtr&lt;CSSShadowValue&gt; consumeSingleShadow(CSSParserTokenRange&amp;, CSSParserMode, bool allowInset, bool allowSpread);
109 
110 // Template implementations are at the bottom of the file for readability.
111 
112 template&lt;typename... emptyBaseCase&gt; inline bool identMatches(CSSValueID) { return false; }
113 template&lt;CSSValueID head, CSSValueID... tail&gt; inline bool identMatches(CSSValueID id)
114 {
115     return id == head || identMatches&lt;tail...&gt;(id);
116 }
117 
118 // FIXME-NEWPARSER - converted to a RefPtr return type from a raw ptr.
119 template&lt;CSSValueID... names&gt; RefPtr&lt;CSSPrimitiveValue&gt; consumeIdent(CSSParserTokenRange&amp; range)
120 {
121     if (range.peek().type() != IdentToken || !identMatches&lt;names...&gt;(range.peek().id()))
122         return nullptr;
123     return CSSValuePool::singleton().createIdentifierValue(range.consumeIncludingWhitespace().id());
124 }
125 
126 static inline bool isCSSWideKeyword(const CSSValueID&amp; id)
127 {
128     return id == CSSValueInitial || id == CSSValueInherit || id == CSSValueUnset || id == CSSValueRevert || id == CSSValueDefault;
129 }
130 
131 } // namespace CSSPropertyParserHelpers
132 
133 } // namespace WebCore
    </pre>
  </body>
</html>
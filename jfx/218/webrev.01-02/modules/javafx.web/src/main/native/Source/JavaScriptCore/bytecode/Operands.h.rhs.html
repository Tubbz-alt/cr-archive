<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/Operands.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;CallFrame.h&quot;
 29 #include &quot;VirtualRegister.h&quot;
 30 
 31 #include &lt;wtf/PrintStream.h&gt;
 32 #include &lt;wtf/Vector.h&gt;
 33 
 34 namespace JSC {
 35 
 36 template&lt;typename T&gt; struct OperandValueTraits;
 37 
<a name="2" id="anc2"></a><span class="line-modified"> 38 constexpr unsigned maxNumCheckpointTmps = 4;</span>
<span class="line-added"> 39 </span>
<span class="line-added"> 40 // A OperandKind::Tmp is one that exists for exiting to a checkpoint but does not exist between bytecodes.</span>
<span class="line-added"> 41 enum class OperandKind : uint32_t { Argument, Local, Tmp }; // Keep bit-width in sync with Operand::operandKindBits&#39; definition.</span>
<span class="line-added"> 42 static constexpr OperandKind lastOperandKind = OperandKind::Tmp;</span>
<span class="line-added"> 43 </span>
<span class="line-added"> 44 class Operand {</span>
<span class="line-added"> 45 public:</span>
<span class="line-added"> 46     static constexpr unsigned kindBits = WTF::getMSBSetConstexpr(static_cast&lt;std::underlying_type_t&lt;OperandKind&gt;&gt;(lastOperandKind)) + 1;</span>
<span class="line-added"> 47     static constexpr unsigned maxBits = 32 + kindBits;</span>
<span class="line-added"> 48     static_assert(maxBits == 34);</span>
<span class="line-added"> 49 </span>
<span class="line-added"> 50     Operand() = default;</span>
<span class="line-added"> 51     Operand(const Operand&amp;) = default;</span>
<span class="line-added"> 52 </span>
<span class="line-added"> 53     Operand(VirtualRegister operand)</span>
<span class="line-added"> 54         : Operand(operand.isLocal() ? OperandKind::Local : OperandKind::Argument, operand.offset())</span>
<span class="line-added"> 55     { }</span>
<span class="line-added"> 56 </span>
<span class="line-added"> 57     Operand(OperandKind kind, int operand)</span>
<span class="line-added"> 58 #if CPU(LITTLE_ENDIAN)</span>
<span class="line-added"> 59         : m_operand(operand)</span>
<span class="line-added"> 60         , m_kind(kind)</span>
<span class="line-added"> 61 #else</span>
<span class="line-added"> 62         : m_kind(kind)</span>
<span class="line-added"> 63         , m_operand(operand)</span>
<span class="line-added"> 64 #endif</span>
<span class="line-added"> 65     {</span>
<span class="line-added"> 66         ASSERT(kind == OperandKind::Tmp || VirtualRegister(operand).isLocal() == (kind == OperandKind::Local));</span>
<span class="line-added"> 67     }</span>
<span class="line-added"> 68     static Operand tmp(uint32_t index) { return Operand(OperandKind::Tmp, index); }</span>
<span class="line-added"> 69 </span>
<span class="line-added"> 70     OperandKind kind() const { return m_kind; }</span>
<span class="line-added"> 71     int value() const { return m_operand; }</span>
<span class="line-added"> 72     VirtualRegister virtualRegister() const</span>
<span class="line-added"> 73     {</span>
<span class="line-added"> 74         ASSERT(m_kind != OperandKind::Tmp);</span>
<span class="line-added"> 75         return VirtualRegister(m_operand);</span>
<span class="line-added"> 76     }</span>
<span class="line-added"> 77     uint64_t asBits() const</span>
<span class="line-added"> 78     {</span>
<span class="line-added"> 79         uint64_t bits = bitwise_cast&lt;uint64_t&gt;(*this);</span>
<span class="line-added"> 80         ASSERT(bits &lt; (1ULL &lt;&lt; maxBits));</span>
<span class="line-added"> 81         return bits;</span>
<span class="line-added"> 82     }</span>
<span class="line-added"> 83     static Operand fromBits(uint64_t value);</span>
<span class="line-added"> 84 </span>
<span class="line-added"> 85     bool isTmp() const { return kind() == OperandKind::Tmp; }</span>
<span class="line-added"> 86     bool isArgument() const { return kind() == OperandKind::Argument; }</span>
<span class="line-added"> 87     bool isLocal() const { return kind() == OperandKind::Local &amp;&amp; virtualRegister().isLocal(); }</span>
<span class="line-added"> 88     bool isHeader() const { return kind() != OperandKind::Tmp &amp;&amp; virtualRegister().isHeader(); }</span>
<span class="line-added"> 89     bool isConstant() const { return kind() != OperandKind::Tmp &amp;&amp; virtualRegister().isConstant(); }</span>
<span class="line-added"> 90 </span>
<span class="line-added"> 91     int toArgument() const { ASSERT(isArgument()); return virtualRegister().toArgument(); }</span>
<span class="line-added"> 92     int toLocal() const { ASSERT(isLocal()); return virtualRegister().toLocal(); }</span>
<span class="line-added"> 93 </span>
<span class="line-added"> 94     inline bool isValid() const;</span>
<span class="line-added"> 95 </span>
<span class="line-added"> 96     inline bool operator==(const Operand&amp;) const;</span>
<span class="line-added"> 97 </span>
<span class="line-added"> 98     void dump(PrintStream&amp;) const;</span>
<span class="line-added"> 99 </span>
<span class="line-added">100 private:</span>
<span class="line-added">101 #if CPU(LITTLE_ENDIAN)</span>
<span class="line-added">102     int m_operand { VirtualRegister::invalidVirtualRegister };</span>
<span class="line-added">103     OperandKind m_kind { OperandKind::Argument };</span>
<span class="line-added">104 #else</span>
<span class="line-added">105     OperandKind m_kind { OperandKind::Argument };</span>
<span class="line-added">106     int m_operand { VirtualRegister::invalidVirtualRegister };</span>
<span class="line-added">107 #endif</span>
<span class="line-added">108 };</span>
<span class="line-added">109 </span>
<span class="line-added">110 ALWAYS_INLINE bool Operand::operator==(const Operand&amp; other) const</span>
<span class="line-added">111 {</span>
<span class="line-added">112     if (kind() != other.kind())</span>
<span class="line-added">113         return false;</span>
<span class="line-added">114     if (isTmp())</span>
<span class="line-added">115         return value() == other.value();</span>
<span class="line-added">116     return virtualRegister() == other.virtualRegister();</span>
<span class="line-added">117 }</span>
<span class="line-added">118 </span>
<span class="line-added">119 inline bool Operand::isValid() const</span>
<span class="line-added">120 {</span>
<span class="line-added">121     if (isTmp())</span>
<span class="line-added">122         return value() &gt;= 0;</span>
<span class="line-added">123     return virtualRegister().isValid();</span>
<span class="line-added">124 }</span>
<span class="line-added">125 </span>
<span class="line-added">126 inline Operand Operand::fromBits(uint64_t value)</span>
<span class="line-added">127 {</span>
<span class="line-added">128     Operand result = bitwise_cast&lt;Operand&gt;(value);</span>
<span class="line-added">129     ASSERT(result.isValid());</span>
<span class="line-added">130     return result;</span>
<span class="line-added">131 }</span>
<span class="line-added">132 </span>
<span class="line-added">133 static_assert(sizeof(Operand) == sizeof(uint64_t), &quot;Operand::asBits() relies on this.&quot;);</span>
134 
135 enum OperandsLikeTag { OperandsLike };
136 
137 template&lt;typename T&gt;
138 class Operands {
139 public:
<a name="3" id="anc3"></a><span class="line-modified">140     using Storage = std::conditional_t&lt;std::is_same_v&lt;T, bool&gt;, FastBitVector, Vector&lt;T, 0, UnsafeVectorOverflow&gt;&gt;;</span>
<span class="line-modified">141     using RefType = std::conditional_t&lt;std::is_same_v&lt;T, bool&gt;, FastBitReference, T&amp;&gt;;</span>
<span class="line-added">142     using ConstRefType = std::conditional_t&lt;std::is_same_v&lt;T, bool&gt;, bool, const T&amp;&gt;;</span>
<span class="line-added">143 </span>
<span class="line-added">144     Operands() = default;</span>
145 
<a name="4" id="anc4"></a><span class="line-modified">146     explicit Operands(size_t numArguments, size_t numLocals, size_t numTmps)</span>
147         : m_numArguments(numArguments)
<a name="5" id="anc5"></a><span class="line-added">148         , m_numLocals(numLocals)</span>
149     {
<a name="6" id="anc6"></a><span class="line-modified">150         size_t size = numArguments + numLocals + numTmps;</span>
<span class="line-modified">151         m_values.grow(size);</span>
<span class="line-modified">152         if (!WTF::VectorTraits&lt;T&gt;::needsInitialization)</span>
<span class="line-modified">153             m_values.fill(T());</span>

154     }
155 
<a name="7" id="anc7"></a><span class="line-modified">156     explicit Operands(size_t numArguments, size_t numLocals, size_t numTmps, const T&amp; initialValue)</span>
157         : m_numArguments(numArguments)
<a name="8" id="anc8"></a><span class="line-added">158         , m_numLocals(numLocals)</span>
159     {
<a name="9" id="anc9"></a><span class="line-modified">160         m_values.grow(numArguments + numLocals + numTmps);</span>
<span class="line-added">161         m_values.fill(initialValue);</span>
162     }
163 
164     template&lt;typename U&gt;
<a name="10" id="anc10"></a><span class="line-modified">165     explicit Operands(OperandsLikeTag, const Operands&lt;U&gt;&amp; other, const T&amp; initialValue = T())</span>
166         : m_numArguments(other.numberOfArguments())
<a name="11" id="anc11"></a><span class="line-added">167         , m_numLocals(other.numberOfLocals())</span>
168     {
<a name="12" id="anc12"></a><span class="line-modified">169         m_values.grow(other.size());</span>
<span class="line-added">170         m_values.fill(initialValue);</span>
171     }
172 
173     size_t numberOfArguments() const { return m_numArguments; }
<a name="13" id="anc13"></a><span class="line-modified">174     size_t numberOfLocals() const { return m_numLocals; }</span>
<span class="line-added">175     size_t numberOfTmps() const { return m_values.size() - numberOfArguments() - numberOfLocals(); }</span>
176 
<a name="14" id="anc14"></a><span class="line-added">177     size_t tmpIndex(size_t idx) const</span>
<span class="line-added">178     {</span>
<span class="line-added">179         ASSERT(idx &lt; numberOfTmps());</span>
<span class="line-added">180         return idx + numberOfArguments() + numberOfLocals();</span>
<span class="line-added">181     }</span>
182     size_t argumentIndex(size_t idx) const
183     {
<a name="15" id="anc15"></a><span class="line-modified">184         ASSERT(idx &lt; numberOfArguments());</span>
185         return idx;
186     }
187 
188     size_t localIndex(size_t idx) const
189     {
<a name="16" id="anc16"></a><span class="line-modified">190         ASSERT(idx &lt; numberOfLocals());</span>
<span class="line-added">191         return numberOfArguments() + idx;</span>
192     }
193 
<a name="17" id="anc17"></a><span class="line-modified">194     RefType tmp(size_t idx) { return m_values[tmpIndex(idx)]; }</span>
<span class="line-modified">195     ConstRefType tmp(size_t idx) const { return m_values[tmpIndex(idx)]; }</span>
<span class="line-modified">196 </span>
<span class="line-modified">197     RefType argument(size_t idx) { return m_values[argumentIndex(idx)]; }</span>
<span class="line-modified">198     ConstRefType argument(size_t idx) const { return m_values[argumentIndex(idx)]; }</span>



199 
<a name="18" id="anc18"></a><span class="line-modified">200     RefType local(size_t idx) { return m_values[localIndex(idx)]; }</span>
<span class="line-modified">201     ConstRefType local(size_t idx) const { return m_values[localIndex(idx)]; }</span>
202 
203     template&lt;OperandKind operandKind&gt;
204     size_t sizeFor() const
205     {
<a name="19" id="anc19"></a><span class="line-modified">206         switch (operandKind) {</span>
<span class="line-added">207         case OperandKind::Tmp:</span>
<span class="line-added">208             return numberOfTmps();</span>
<span class="line-added">209         case OperandKind::Argument:</span>
210             return numberOfArguments();
<a name="20" id="anc20"></a><span class="line-modified">211         case OperandKind::Local:</span>
<span class="line-added">212             return numberOfLocals();</span>
<span class="line-added">213         }</span>
<span class="line-added">214         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">215         return 0;</span>
216     }
217     template&lt;OperandKind operandKind&gt;
<a name="21" id="anc21"></a><span class="line-modified">218     RefType atFor(size_t idx)</span>
219     {
<a name="22" id="anc22"></a><span class="line-modified">220         switch (operandKind) {</span>
<span class="line-added">221         case OperandKind::Tmp:</span>
<span class="line-added">222             return tmp(idx);</span>
<span class="line-added">223         case OperandKind::Argument:</span>
224             return argument(idx);
<a name="23" id="anc23"></a><span class="line-modified">225         case OperandKind::Local:</span>
<span class="line-added">226             return local(idx);</span>
<span class="line-added">227         }</span>
<span class="line-added">228         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">229         return tmp(0);</span>
230     }
231     template&lt;OperandKind operandKind&gt;
<a name="24" id="anc24"></a><span class="line-modified">232     ConstRefType atFor(size_t idx) const</span>
233     {
<a name="25" id="anc25"></a><span class="line-modified">234         switch (operandKind) {</span>
<span class="line-added">235         case OperandKind::Tmp:</span>
<span class="line-added">236             return tmp(idx);</span>
<span class="line-added">237         case OperandKind::Argument:</span>
238             return argument(idx);
<a name="26" id="anc26"></a><span class="line-modified">239         case OperandKind::Local:</span>
<span class="line-added">240             return local(idx);</span>
<span class="line-added">241         }</span>
<span class="line-added">242         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">243         return tmp(0);</span>
244     }
245 
<a name="27" id="anc27"></a><span class="line-modified">246     void ensureLocals(size_t size, const T&amp; ensuredValue = T())</span>
247     {
<a name="28" id="anc28"></a><span class="line-modified">248         if (size &lt;= numberOfLocals())</span>


249             return;
250 
<a name="29" id="anc29"></a><span class="line-added">251         size_t newSize = numberOfArguments() + numberOfTmps() + size;</span>
<span class="line-added">252         size_t oldNumLocals = numberOfLocals();</span>
<span class="line-added">253         size_t oldNumTmps = numberOfTmps();</span>
254         m_values.grow(newSize);
<a name="30" id="anc30"></a><span class="line-modified">255         for (size_t i = 0; i &lt; oldNumTmps; ++i)</span>
<span class="line-modified">256             m_values[newSize - 1 - i] = m_values[tmpIndex(oldNumTmps - 1 - i)];</span>
<span class="line-modified">257 </span>
<span class="line-added">258         m_numLocals = size;</span>
<span class="line-added">259         if (ensuredValue != T() || !WTF::VectorTraits&lt;T&gt;::needsInitialization) {</span>
<span class="line-added">260             for (size_t i = 0; i &lt; size - oldNumLocals; ++i)</span>
<span class="line-added">261                 m_values[localIndex(oldNumLocals + i)] = ensuredValue;</span>
262         }
263     }
264 
<a name="31" id="anc31"></a><span class="line-modified">265     void ensureTmps(size_t size, const T&amp; ensuredValue = T())</span>
266     {
<a name="32" id="anc32"></a><span class="line-modified">267         if (size &lt;= numberOfTmps())</span>


268             return;
269 
<a name="33" id="anc33"></a><span class="line-added">270         size_t oldSize = m_values.size();</span>
<span class="line-added">271         size_t newSize = numberOfArguments() + numberOfLocals() + size;</span>
272         m_values.grow(newSize);
<a name="34" id="anc34"></a><span class="line-modified">273 </span>
<span class="line-modified">274         if (ensuredValue != T() || !WTF::VectorTraits&lt;T&gt;::needsInitialization) {</span>
<span class="line-added">275             for (size_t i = oldSize; i &lt; newSize; ++i)</span>
<span class="line-added">276                 m_values[i] = ensuredValue;</span>
<span class="line-added">277         }</span>
278     }
279 
280     void setLocal(size_t idx, const T&amp; value)
281     {
282         ensureLocals(idx + 1);
283         local(idx) = value;
284     }
285 
286     T getLocal(size_t idx)
287     {
288         return idx &gt;= numberOfLocals() ? T() : local(idx);
289     }
290 
291     void setArgumentFirstTime(size_t idx, const T&amp; value)
292     {
293         ASSERT(m_values[idx] == T());
294         argument(idx) = value;
295     }
296 
297     void setLocalFirstTime(size_t idx, const T&amp; value)
298     {
299         ASSERT(idx &gt;= numberOfLocals() || local(idx) == T());
300         setLocal(idx, value);
301     }
302 
<a name="35" id="anc35"></a><span class="line-modified">303     RefType getForOperandIndex(size_t index) { return m_values[index]; }</span>
<span class="line-added">304     ConstRefType getForOperandIndex(size_t index) const { return const_cast&lt;Operands*&gt;(this)-&gt;getForOperandIndex(index); }</span>
<span class="line-added">305 </span>
<span class="line-added">306     size_t operandIndex(VirtualRegister operand) const</span>
307     {
<a name="36" id="anc36"></a><span class="line-modified">308         if (operand.isArgument())</span>
<span class="line-modified">309             return argumentIndex(operand.toArgument());</span>
<span class="line-modified">310         return localIndex(operand.toLocal());</span>
311     }
312 
<a name="37" id="anc37"></a><span class="line-modified">313     size_t operandIndex(Operand op) const</span>
314     {
<a name="38" id="anc38"></a><span class="line-modified">315         if (!op.isTmp())</span>
<span class="line-added">316             return operandIndex(op.virtualRegister());</span>
<span class="line-added">317         return tmpIndex(op.value());</span>
318     }
319 
<a name="39" id="anc39"></a><span class="line-modified">320     RefType operand(VirtualRegister operand)</span>
321     {
<a name="40" id="anc40"></a><span class="line-modified">322         if (operand.isArgument())</span>
<span class="line-modified">323             return argument(operand.toArgument());</span>
<span class="line-modified">324         return local(operand.toLocal());</span>
325     }
326 
<a name="41" id="anc41"></a><span class="line-modified">327     RefType operand(Operand op)</span>
328     {
<a name="42" id="anc42"></a><span class="line-modified">329         if (!op.isTmp())</span>
<span class="line-added">330             return operand(op.virtualRegister());</span>
<span class="line-added">331         return tmp(op.value());</span>
332     }
333 
<a name="43" id="anc43"></a><span class="line-modified">334     ConstRefType operand(VirtualRegister operand) const { return const_cast&lt;Operands*&gt;(this)-&gt;operand(operand); }</span>
<span class="line-modified">335     ConstRefType operand(Operand operand) const { return const_cast&lt;Operands*&gt;(this)-&gt;operand(operand); }</span>
336 
<a name="44" id="anc44"></a><span class="line-modified">337     bool hasOperand(VirtualRegister operand) const</span>
338     {
<a name="45" id="anc45"></a><span class="line-modified">339         if (operand.isArgument())</span>
340             return true;
<a name="46" id="anc46"></a><span class="line-modified">341         return static_cast&lt;size_t&gt;(operand.toLocal()) &lt; numberOfLocals();</span>
342     }
<a name="47" id="anc47"></a><span class="line-modified">343     bool hasOperand(Operand op) const</span>
344     {
<a name="48" id="anc48"></a><span class="line-modified">345         if (op.isTmp()) {</span>
<span class="line-added">346             ASSERT(op.value() &gt;= 0);</span>
<span class="line-added">347             return static_cast&lt;size_t&gt;(op.value()) &lt; numberOfTmps();</span>
<span class="line-added">348         }</span>
<span class="line-added">349         return hasOperand(op.virtualRegister());</span>
350     }
351 
<a name="49" id="anc49"></a><span class="line-modified">352     void setOperand(Operand operand, const T&amp; value)</span>
353     {
354         this-&gt;operand(operand) = value;
355     }
356 
<a name="50" id="anc50"></a>




357     size_t size() const { return m_values.size(); }
<a name="51" id="anc51"></a><span class="line-modified">358     ConstRefType at(size_t index) const { return m_values[index]; }</span>
<span class="line-modified">359     RefType at(size_t index) { return m_values[index]; }</span>
<span class="line-modified">360     ConstRefType operator[](size_t index) const { return at(index); }</span>
<span class="line-modified">361     RefType operator[](size_t index) { return at(index); }</span>













362 
<a name="52" id="anc52"></a><span class="line-modified">363     Operand operandForIndex(size_t index) const</span>
364     {
<a name="53" id="anc53"></a><span class="line-modified">365         if (index &lt; numberOfArguments())</span>
<span class="line-modified">366             return virtualRegisterForArgumentIncludingThis(index);</span>
<span class="line-modified">367         else if (index &lt; numberOfLocals() + numberOfArguments())</span>
<span class="line-modified">368             return virtualRegisterForLocal(index - numberOfArguments());</span>
<span class="line-modified">369         return Operand::tmp(index - (numberOfLocals() + numberOfArguments()));</span>

370     }
371 
372     void fill(T value)
373     {
374         for (size_t i = 0; i &lt; m_values.size(); ++i)
375             m_values[i] = value;
376     }
377 
378     void clear()
379     {
380         fill(T());
381     }
382 
383     bool operator==(const Operands&amp; other) const
384     {
385         ASSERT(numberOfArguments() == other.numberOfArguments());
386         ASSERT(numberOfLocals() == other.numberOfLocals());
<a name="54" id="anc54"></a><span class="line-added">387         ASSERT(numberOfTmps() == other.numberOfTmps());</span>
388 
389         return m_values == other.m_values;
390     }
391 
392     void dumpInContext(PrintStream&amp; out, DumpContext* context) const;
393     void dump(PrintStream&amp; out) const;
394 
395 private:
<a name="55" id="anc55"></a><span class="line-modified">396     // The first m_numArguments of m_values are arguments, the next m_numLocals are locals, and the rest are tmps.</span>
<span class="line-modified">397     Storage m_values;</span>
<span class="line-modified">398     unsigned m_numArguments { 0 };</span>
<span class="line-added">399     unsigned m_numLocals { 0 };</span>
400 };
401 
402 } // namespace JSC
<a name="56" id="anc56"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="56" type="hidden" />
</body>
</html>
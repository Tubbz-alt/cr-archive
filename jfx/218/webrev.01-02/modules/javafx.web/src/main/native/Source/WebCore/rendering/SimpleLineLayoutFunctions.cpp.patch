diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutFunctions.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutFunctions.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutFunctions.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutFunctions.cpp
@@ -129,12 +129,14 @@
             continue;
 
         String textWithHyphen;
         if (run.hasHyphen())
             textWithHyphen = run.textWithHyphen();
-        // x position indicates the line offset from the rootbox. It's always 0 in case of simple line layout.
-        TextRun textRun { run.hasHyphen() ? textWithHyphen : run.text(), 0, run.expansion(), run.expansionBehavior() };
+        // xPos is relative to the line box's logical left.
+        // We don't have any line geometry here in SLL, so let's get the first run's logical left in the current line and use it as the line's logical left.
+        auto lineLogicalLeft = (*resolver.rangeForLine(run.lineIndex()).begin()).logicalLeft();
+        TextRun textRun { run.hasHyphen() ? textWithHyphen : run.text(), run.logicalLeft() - lineLogicalLeft, run.expansion(), run.expansionBehavior() };
         textRun.setTabSize(!style.collapseWhiteSpace(), style.tabSize());
         FloatPoint textOrigin { rect.x() + paintOffset.x(), roundToDevicePixel(run.baselinePosition() + paintOffset.y(), deviceScaleFactor) };
 
         textPainter.setGlyphDisplayListIfNeeded(run.simpleRun(), paintInfo, style.fontCascade(), paintInfo.context(), textRun);
         textPainter.paint(textRun, rect, textOrigin);
@@ -181,54 +183,10 @@
         flow.addLayoutOverflow(LayoutRect(lineRect));
         flow.addVisualOverflow(visualOverflowRect);
     }
 }
 
-IntRect computeBoundingBox(const RenderObject& renderer, const Layout& layout)
-{
-    auto& resolver = layout.runResolver();
-    FloatRect boundingBoxRect;
-    for (auto run : resolver.rangeForRenderer(renderer)) {
-        FloatRect rect = run.rect();
-        if (boundingBoxRect == FloatRect())
-            boundingBoxRect = rect;
-        else
-            boundingBoxRect.uniteEvenIfEmpty(rect);
-    }
-    return enclosingIntRect(boundingBoxRect);
-}
-
-IntPoint computeFirstRunLocation(const RenderObject& renderer, const Layout& layout)
-{
-    auto& resolver = layout.runResolver();
-    auto range = resolver.rangeForRenderer(renderer);
-    auto begin = range.begin();
-    if (begin == range.end())
-        return IntPoint(0, 0);
-    return flooredIntPoint((*begin).rect().location());
-}
-
-Vector<IntRect> collectAbsoluteRects(const RenderObject& renderer, const Layout& layout, const LayoutPoint& accumulatedOffset)
-{
-    Vector<IntRect> rects;
-    auto& resolver = layout.runResolver();
-    for (auto run : resolver.rangeForRenderer(renderer)) {
-        FloatRect rect = run.rect();
-        rects.append(enclosingIntRect(FloatRect(accumulatedOffset + rect.location(), rect.size())));
-    }
-    return rects;
-}
-
-Vector<FloatQuad> collectAbsoluteQuads(const RenderObject& renderer, const Layout& layout, bool* wasFixed)
-{
-    Vector<FloatQuad> quads;
-    auto& resolver = layout.runResolver();
-    for (auto run : resolver.rangeForRenderer(renderer))
-        quads.append(renderer.localToAbsoluteQuad(FloatQuad(run.rect()), UseTransforms, wasFixed));
-    return quads;
-}
-
 unsigned textOffsetForPoint(const LayoutPoint& point, const RenderText& renderer, const Layout& layout)
 {
     auto& flow = downcast<RenderBlockFlow>(*renderer.parent());
     ASSERT(flow.firstChild() == flow.lastChild());
     auto& resolver = layout.runResolver();
@@ -240,16 +198,18 @@
     TextRun textRun(run.text(), run.logicalLeft(), run.expansion(), run.expansionBehavior());
     textRun.setTabSize(!style.collapseWhiteSpace(), style.tabSize());
     return run.start() + style.fontCascade().offsetForPosition(textRun, point.x() - run.logicalLeft(), true);
 }
 
-Vector<FloatQuad> collectAbsoluteQuadsForRange(const RenderObject& renderer, unsigned start, unsigned end, const Layout& layout, bool* wasFixed)
+Vector<FloatQuad> collectAbsoluteQuadsForRange(const RenderObject& renderer, unsigned start, unsigned end, const Layout& layout, bool ignoreEmptyTextSelections, bool* wasFixed)
 {
     auto& style = downcast<RenderBlockFlow>(*renderer.parent()).style();
     Vector<FloatQuad> quads;
     auto& resolver = layout.runResolver();
     for (auto run : resolver.rangeForRendererWithOffsets(renderer, start, end)) {
+        if (ignoreEmptyTextSelections && run.start() == run.end())
+            continue;
         // This run is fully contained.
         if (start <= run.start() && end >= run.end()) {
             quads.append(renderer.localToAbsoluteQuad(FloatQuad(run.rect()), UseTransforms, wasFixed));
             continue;
         }
@@ -265,20 +225,16 @@
         }
         auto localStart = std::max(run.start(), start) - run.start();
         auto localEnd = std::min(run.end(), end) - run.start();
         ASSERT(localStart <= localEnd);
         style.fontCascade().adjustSelectionRectForText(textRun, runRect, localStart, localEnd);
+        runRect = snappedSelectionRect(runRect, run.logicalRight(), runRect.y(), runRect.height(), true /* isHorizontal */);
         quads.append(renderer.localToAbsoluteQuad(FloatQuad(runRect), UseTransforms, wasFixed));
     }
     return quads;
 }
 
-const RenderObject& rendererForPosition(const FlowContents& flowContents, unsigned position)
-{
-    return flowContents.segmentForPosition(position).renderer;
-}
-
 void simpleLineLayoutWillBeDeleted(const Layout& layout)
 {
     for (unsigned i = 0; i < layout.runCount(); ++i)
         TextPainter::removeGlyphDisplayList(layout.runAt(i));
 }
@@ -390,20 +346,20 @@
     printedCharacters = 0;
     while (++printedCharacters <= depth * 2)
         stream << " ";
 }
 
-void outputLineLayoutForFlow(TextStream& stream, const RenderBlockFlow& flow, const Layout& layout, int depth)
+void outputLineLayoutForFlow(TextStream& stream, const RenderBlockFlow&, const Layout& layout, int depth)
 {
     int printedCharacters = 0;
     printPrefix(stream, printedCharacters, depth);
 
     stream << "SimpleLineLayout (" << layout.lineCount() << " lines, " << layout.runCount() << " runs) (" << &layout << ")";
     stream.nextLine();
     ++depth;
 
-    for (auto run : runResolver(flow, layout)) {
+    for (auto run : layout.runResolver()) {
         FloatRect rect = run.rect();
         printPrefix(stream, printedCharacters, depth);
         if (run.start() < run.end()) {
             stream << "line " << run.lineIndex() << " run(" << run.start() << ", " << run.end() << ") " << rect << " \"" << run.text().toStringWithoutCopying().utf8().data() << "\"";
         } else {

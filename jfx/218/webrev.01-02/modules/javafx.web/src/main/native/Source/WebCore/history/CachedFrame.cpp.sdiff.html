<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/history/CachedFrame.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BackForwardItemIdentifier.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CachedFramePlatformData.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/history/CachedFrame.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;CachedFrame.h&quot;
 28 

 29 #include &quot;CSSAnimationController.h&quot;
 30 #include &quot;CachedFramePlatformData.h&quot;
 31 #include &quot;CachedPage.h&quot;
 32 #include &quot;CustomHeaderFields.h&quot;
 33 #include &quot;DOMWindow.h&quot;
 34 #include &quot;Document.h&quot;
 35 #include &quot;DocumentLoader.h&quot;
 36 #include &quot;DocumentTimeline.h&quot;
 37 #include &quot;Frame.h&quot;
 38 #include &quot;FrameLoader.h&quot;
 39 #include &quot;FrameLoaderClient.h&quot;
 40 #include &quot;FrameView.h&quot;
 41 #include &quot;Logging.h&quot;
 42 #include &quot;NavigationDisabler.h&quot;
 43 #include &quot;Page.h&quot;
<span class="line-removed"> 44 #include &quot;PageCache.h&quot;</span>
 45 #include &quot;RenderWidget.h&quot;
<span class="line-removed"> 46 #include &quot;RuntimeEnabledFeatures.h&quot;</span>
 47 #include &quot;SVGDocumentExtensions.h&quot;
 48 #include &quot;ScriptController.h&quot;
 49 #include &quot;SerializedScriptValue.h&quot;
 50 #include &quot;StyleTreeResolver.h&quot;

 51 #include &lt;wtf/RefCountedLeakCounter.h&gt;
 52 #include &lt;wtf/text/CString.h&gt;
 53 
 54 #if PLATFORM(IOS_FAMILY) || ENABLE(TOUCH_EVENTS)
 55 #include &quot;Chrome.h&quot;
 56 #include &quot;ChromeClient.h&quot;
 57 #endif
 58 
 59 namespace WebCore {
 60 
 61 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, cachedFrameCounter, (&quot;CachedFrame&quot;));
 62 
 63 CachedFrameBase::CachedFrameBase(Frame&amp; frame)
 64     : m_document(frame.document())
 65     , m_documentLoader(frame.loader().documentLoader())
 66     , m_view(frame.view())
 67     , m_url(frame.document()-&gt;url())
 68     , m_isMainFrame(!frame.tree().parent())
 69 {
 70 }
</pre>
<hr />
<pre>
 90 }
 91 
 92 void CachedFrameBase::restore()
 93 {
 94     ASSERT(m_document-&gt;view() == m_view);
 95 
 96     if (m_isMainFrame)
 97         m_view-&gt;setParentVisible(true);
 98 
 99     auto frame = makeRef(m_view-&gt;frame());
100     {
101         Style::PostResolutionCallbackDisabler disabler(*m_document);
102         WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
103         NavigationDisabler disableNavigation { nullptr }; // Disable navigation globally.
104 
105         m_cachedFrameScriptData-&gt;restore(frame.get());
106 
107         if (m_document-&gt;svgExtensions())
108             m_document-&gt;accessSVGExtensions().unpauseAnimations();
109 
<span class="line-modified">110         m_document-&gt;resume(ReasonForSuspension::PageCache);</span>
111 
112         // It is necessary to update any platform script objects after restoring the
113         // cached page.
114         frame-&gt;script().updatePlatformScriptObjects();
115 
<span class="line-modified">116         frame-&gt;loader().client().didRestoreFromPageCache();</span>
117 
118         pruneDetachedChildFrames();
119 
120         // Reconstruct the FrameTree. And open the child CachedFrames in their respective FrameLoaders.
121         for (auto&amp; childFrame : m_childFrames) {
122             ASSERT(childFrame-&gt;view()-&gt;frame().page());
123             frame-&gt;tree().appendChild(childFrame-&gt;view()-&gt;frame());
124             childFrame-&gt;open();
125             ASSERT_WITH_SECURITY_IMPLICATION(m_document == frame-&gt;document());
126         }
127     }
128 
129 #if PLATFORM(IOS_FAMILY)
130     if (m_isMainFrame) {
131         frame-&gt;loader().client().didRestoreFrameHierarchyForCachedFrame();
132 
133         if (DOMWindow* domWindow = m_document-&gt;domWindow()) {
134             // FIXME: Add SCROLL_LISTENER to the list of event types on Document, and use m_document-&gt;hasListenerType(). See &lt;rdar://problem/9615482&gt;.
135             // FIXME: Can use Document::hasListenerType() now.
136             if (domWindow-&gt;scrollEventListenerCount() &amp;&amp; frame-&gt;page())
137                 frame-&gt;page()-&gt;chrome().client().setNeedsScrollNotifications(frame, true);
138         }
139     }
140 #endif
141 
<span class="line-modified">142     frame-&gt;view()-&gt;didRestoreFromPageCache();</span>
143 }
144 
145 CachedFrame::CachedFrame(Frame&amp; frame)
146     : CachedFrameBase(frame)
147 {
148 #ifndef NDEBUG
149     cachedFrameCounter.increment();
150 #endif
151     ASSERT(m_document);
152     ASSERT(m_documentLoader);
153     ASSERT(m_view);
<span class="line-modified">154     ASSERT(m_document-&gt;pageCacheState() == Document::InPageCache);</span>
155 
156     RELEASE_ASSERT(m_document-&gt;domWindow());
157     RELEASE_ASSERT(m_document-&gt;frame());
158     RELEASE_ASSERT(m_document-&gt;domWindow()-&gt;frame());
159 
160     // FIXME: We have evidence that constructing CachedFrames for descendant frames may detach the document from its frame (rdar://problem/49877867).
161     // This sets the flag to help find the guilty code.
162     m_document-&gt;setMayBeDetachedFromFrame(false);
163 
164     // Create the CachedFrames for all Frames in the FrameTree.
165     for (Frame* child = frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling())
166         m_childFrames.append(makeUnique&lt;CachedFrame&gt;(*child));
167 
168     RELEASE_ASSERT(m_document-&gt;domWindow());
169     RELEASE_ASSERT(m_document-&gt;frame());
170     RELEASE_ASSERT(m_document-&gt;domWindow()-&gt;frame());
171 
172     // Active DOM objects must be suspended before we cache the frame script data.
<span class="line-modified">173     m_document-&gt;suspend(ReasonForSuspension::PageCache);</span>
174 
175     m_cachedFrameScriptData = makeUnique&lt;ScriptCachedFrameData&gt;(frame);
176 
<span class="line-modified">177     m_document-&gt;domWindow()-&gt;suspendForPageCache();</span>
178 
179     // Clear FrameView to reset flags such as &#39;firstVisuallyNonEmptyLayoutCallbackPending&#39; so that the
<span class="line-modified">180     // &#39;DidFirstVisuallyNonEmptyLayout&#39; callback gets called against when restoring from PageCache.</span>
181     m_view-&gt;resetLayoutMilestones();
182 




183     frame.loader().client().savePlatformDataToCachedFrame(this);
184 
<span class="line-modified">185     // documentWillSuspendForPageCache() can set up a layout timer on the FrameView, so clear timers after that.</span>
186     frame.clearTimers();
187 
188     // Deconstruct the FrameTree, to restore it later.
189     // We do this for two reasons:
190     // 1 - We reuse the main frame, so when it navigates to a new page load it needs to start with a blank FrameTree.
<span class="line-modified">191     // 2 - It&#39;s much easier to destroy a CachedFrame while it resides in the PageCache if it is disconnected from its parent.</span>
192     for (unsigned i = 0; i &lt; m_childFrames.size(); ++i)
193         frame.tree().removeChild(m_childFrames[i]-&gt;view()-&gt;frame());
194 
195     if (!m_isMainFrame)
196         frame.page()-&gt;decrementSubframeCount();
197 
<span class="line-removed">198     frame.loader().client().didSaveToPageCache();</span>
<span class="line-removed">199 </span>
200 #ifndef NDEBUG
201     if (m_isMainFrame)
<span class="line-modified">202         LOG(PageCache, &quot;Finished creating CachedFrame for main frame url &#39;%s&#39; and DocumentLoader %p\n&quot;, m_url.string().utf8().data(), m_documentLoader.get());</span>
203     else
<span class="line-modified">204         LOG(PageCache, &quot;Finished creating CachedFrame for child frame with url &#39;%s&#39; and DocumentLoader %p\n&quot;, m_url.string().utf8().data(), m_documentLoader.get());</span>
205 #endif
206 
207 #if PLATFORM(IOS_FAMILY)
208     if (m_isMainFrame) {
209         if (DOMWindow* domWindow = m_document-&gt;domWindow()) {
210             if (domWindow-&gt;scrollEventListenerCount() &amp;&amp; frame.page())
211                 frame.page()-&gt;chrome().client().setNeedsScrollNotifications(frame, false);
212         }
213     }
214 #endif
215 
216     m_document-&gt;setMayBeDetachedFromFrame(true);
217     m_document-&gt;detachFromCachedFrame(*this);
218 
219     ASSERT_WITH_SECURITY_IMPLICATION(!m_documentLoader-&gt;isLoading());
220 }
221 
222 void CachedFrame::open()
223 {
224     ASSERT(m_view);
225     ASSERT(m_document);
226     if (!m_isMainFrame)
227         m_view-&gt;frame().page()-&gt;incrementSubframeCount();
228 
229     m_view-&gt;frame().loader().open(*this);
230 }
231 
232 void CachedFrame::clear()
233 {
234     if (!m_document)
235         return;
236 
<span class="line-modified">237     // clear() should only be called for Frames representing documents that are no longer in the page cache.</span>
238     // This means the CachedFrame has been:
239     // 1 - Successfully restore()&#39;d by going back/forward.
<span class="line-modified">240     // 2 - destroy()&#39;ed because the PageCache is pruning or the WebView was closed.</span>
<span class="line-modified">241     ASSERT(m_document-&gt;pageCacheState() == Document::NotInPageCache);</span>
242     ASSERT(m_view);
243     ASSERT(!m_document-&gt;frame() || m_document-&gt;frame() == &amp;m_view-&gt;frame());
244 
245     for (int i = m_childFrames.size() - 1; i &gt;= 0; --i)
246         m_childFrames[i]-&gt;clear();
247 
248     m_document = nullptr;
249     m_view = nullptr;
250     m_url = URL();
251 
252     m_cachedFramePlatformData = nullptr;
253     m_cachedFrameScriptData = nullptr;
254 }
255 
256 void CachedFrame::destroy()
257 {
258     if (!m_document)
259         return;
260 
<span class="line-modified">261     // Only CachedFrames that are still in the PageCache should be destroyed in this manner</span>
<span class="line-modified">262     ASSERT(m_document-&gt;pageCacheState() == Document::InPageCache);</span>
263     ASSERT(m_view);
264     ASSERT(!m_document-&gt;frame());
265 
266     m_document-&gt;domWindow()-&gt;willDestroyCachedFrame();
267 
268     if (!m_isMainFrame &amp;&amp; m_view-&gt;frame().page()) {
269         m_view-&gt;frame().loader().detachViewsAndDocumentLoader();
270         m_view-&gt;frame().detachFromPage();
271     }
272 
273     for (int i = m_childFrames.size() - 1; i &gt;= 0; --i)
274         m_childFrames[i]-&gt;destroy();
275 
276     if (m_cachedFramePlatformData)
277         m_cachedFramePlatformData-&gt;clear();
278 
279     Frame::clearTimers(m_view.get(), m_document.get());
280 
281     m_view-&gt;frame().animation().detachFromDocument(m_document.get());
282 
<span class="line-modified">283     // FIXME: Why do we need to call removeAllEventListeners here? When the document is in page cache, this method won&#39;t work</span>
284     // fully anyway, because the document won&#39;t be able to access its DOMWindow object (due to being frameless).
285     m_document-&gt;removeAllEventListeners();
286 
<span class="line-modified">287     m_document-&gt;setPageCacheState(Document::NotInPageCache);</span>
288     m_document-&gt;prepareForDestruction();
289 
290     clear();
291 }
292 
293 void CachedFrame::setCachedFramePlatformData(std::unique_ptr&lt;CachedFramePlatformData&gt; data)
294 {
295     m_cachedFramePlatformData = WTFMove(data);
296 }
297 
298 CachedFramePlatformData* CachedFrame::cachedFramePlatformData()
299 {
300     return m_cachedFramePlatformData.get();
301 }
302 
303 void CachedFrame::setHasInsecureContent(HasInsecureContent hasInsecureContent)
304 {
305     m_hasInsecureContent = hasInsecureContent;
306 }
307 
</pre>
</td>
<td>
<hr />
<pre>
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;CachedFrame.h&quot;
 28 
<span class="line-added"> 29 #include &quot;BackForwardCache.h&quot;</span>
 30 #include &quot;CSSAnimationController.h&quot;
 31 #include &quot;CachedFramePlatformData.h&quot;
 32 #include &quot;CachedPage.h&quot;
 33 #include &quot;CustomHeaderFields.h&quot;
 34 #include &quot;DOMWindow.h&quot;
 35 #include &quot;Document.h&quot;
 36 #include &quot;DocumentLoader.h&quot;
 37 #include &quot;DocumentTimeline.h&quot;
 38 #include &quot;Frame.h&quot;
 39 #include &quot;FrameLoader.h&quot;
 40 #include &quot;FrameLoaderClient.h&quot;
 41 #include &quot;FrameView.h&quot;
 42 #include &quot;Logging.h&quot;
 43 #include &quot;NavigationDisabler.h&quot;
 44 #include &quot;Page.h&quot;

 45 #include &quot;RenderWidget.h&quot;

 46 #include &quot;SVGDocumentExtensions.h&quot;
 47 #include &quot;ScriptController.h&quot;
 48 #include &quot;SerializedScriptValue.h&quot;
 49 #include &quot;StyleTreeResolver.h&quot;
<span class="line-added"> 50 #include &quot;WindowEventLoop.h&quot;</span>
 51 #include &lt;wtf/RefCountedLeakCounter.h&gt;
 52 #include &lt;wtf/text/CString.h&gt;
 53 
 54 #if PLATFORM(IOS_FAMILY) || ENABLE(TOUCH_EVENTS)
 55 #include &quot;Chrome.h&quot;
 56 #include &quot;ChromeClient.h&quot;
 57 #endif
 58 
 59 namespace WebCore {
 60 
 61 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, cachedFrameCounter, (&quot;CachedFrame&quot;));
 62 
 63 CachedFrameBase::CachedFrameBase(Frame&amp; frame)
 64     : m_document(frame.document())
 65     , m_documentLoader(frame.loader().documentLoader())
 66     , m_view(frame.view())
 67     , m_url(frame.document()-&gt;url())
 68     , m_isMainFrame(!frame.tree().parent())
 69 {
 70 }
</pre>
<hr />
<pre>
 90 }
 91 
 92 void CachedFrameBase::restore()
 93 {
 94     ASSERT(m_document-&gt;view() == m_view);
 95 
 96     if (m_isMainFrame)
 97         m_view-&gt;setParentVisible(true);
 98 
 99     auto frame = makeRef(m_view-&gt;frame());
100     {
101         Style::PostResolutionCallbackDisabler disabler(*m_document);
102         WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
103         NavigationDisabler disableNavigation { nullptr }; // Disable navigation globally.
104 
105         m_cachedFrameScriptData-&gt;restore(frame.get());
106 
107         if (m_document-&gt;svgExtensions())
108             m_document-&gt;accessSVGExtensions().unpauseAnimations();
109 
<span class="line-modified">110         m_document-&gt;resume(ReasonForSuspension::BackForwardCache);</span>
111 
112         // It is necessary to update any platform script objects after restoring the
113         // cached page.
114         frame-&gt;script().updatePlatformScriptObjects();
115 
<span class="line-modified">116         frame-&gt;loader().client().didRestoreFromBackForwardCache();</span>
117 
118         pruneDetachedChildFrames();
119 
120         // Reconstruct the FrameTree. And open the child CachedFrames in their respective FrameLoaders.
121         for (auto&amp; childFrame : m_childFrames) {
122             ASSERT(childFrame-&gt;view()-&gt;frame().page());
123             frame-&gt;tree().appendChild(childFrame-&gt;view()-&gt;frame());
124             childFrame-&gt;open();
125             ASSERT_WITH_SECURITY_IMPLICATION(m_document == frame-&gt;document());
126         }
127     }
128 
129 #if PLATFORM(IOS_FAMILY)
130     if (m_isMainFrame) {
131         frame-&gt;loader().client().didRestoreFrameHierarchyForCachedFrame();
132 
133         if (DOMWindow* domWindow = m_document-&gt;domWindow()) {
134             // FIXME: Add SCROLL_LISTENER to the list of event types on Document, and use m_document-&gt;hasListenerType(). See &lt;rdar://problem/9615482&gt;.
135             // FIXME: Can use Document::hasListenerType() now.
136             if (domWindow-&gt;scrollEventListenerCount() &amp;&amp; frame-&gt;page())
137                 frame-&gt;page()-&gt;chrome().client().setNeedsScrollNotifications(frame, true);
138         }
139     }
140 #endif
141 
<span class="line-modified">142     frame-&gt;view()-&gt;didRestoreFromBackForwardCache();</span>
143 }
144 
145 CachedFrame::CachedFrame(Frame&amp; frame)
146     : CachedFrameBase(frame)
147 {
148 #ifndef NDEBUG
149     cachedFrameCounter.increment();
150 #endif
151     ASSERT(m_document);
152     ASSERT(m_documentLoader);
153     ASSERT(m_view);
<span class="line-modified">154     ASSERT(m_document-&gt;backForwardCacheState() == Document::InBackForwardCache);</span>
155 
156     RELEASE_ASSERT(m_document-&gt;domWindow());
157     RELEASE_ASSERT(m_document-&gt;frame());
158     RELEASE_ASSERT(m_document-&gt;domWindow()-&gt;frame());
159 
160     // FIXME: We have evidence that constructing CachedFrames for descendant frames may detach the document from its frame (rdar://problem/49877867).
161     // This sets the flag to help find the guilty code.
162     m_document-&gt;setMayBeDetachedFromFrame(false);
163 
164     // Create the CachedFrames for all Frames in the FrameTree.
165     for (Frame* child = frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling())
166         m_childFrames.append(makeUnique&lt;CachedFrame&gt;(*child));
167 
168     RELEASE_ASSERT(m_document-&gt;domWindow());
169     RELEASE_ASSERT(m_document-&gt;frame());
170     RELEASE_ASSERT(m_document-&gt;domWindow()-&gt;frame());
171 
172     // Active DOM objects must be suspended before we cache the frame script data.
<span class="line-modified">173     m_document-&gt;suspend(ReasonForSuspension::BackForwardCache);</span>
174 
175     m_cachedFrameScriptData = makeUnique&lt;ScriptCachedFrameData&gt;(frame);
176 
<span class="line-modified">177     m_document-&gt;domWindow()-&gt;suspendForBackForwardCache();</span>
178 
179     // Clear FrameView to reset flags such as &#39;firstVisuallyNonEmptyLayoutCallbackPending&#39; so that the
<span class="line-modified">180     // &#39;DidFirstVisuallyNonEmptyLayout&#39; callback gets called against when restoring from the BackForwardCache.</span>
181     m_view-&gt;resetLayoutMilestones();
182 
<span class="line-added">183     // The main frame is reused for the navigation and the opener link to its should thus persist.</span>
<span class="line-added">184     if (!frame.isMainFrame())</span>
<span class="line-added">185         frame.loader().detachFromAllOpenedFrames();</span>
<span class="line-added">186 </span>
187     frame.loader().client().savePlatformDataToCachedFrame(this);
188 
<span class="line-modified">189     // documentWillSuspendForBackForwardCache() can set up a layout timer on the FrameView, so clear timers after that.</span>
190     frame.clearTimers();
191 
192     // Deconstruct the FrameTree, to restore it later.
193     // We do this for two reasons:
194     // 1 - We reuse the main frame, so when it navigates to a new page load it needs to start with a blank FrameTree.
<span class="line-modified">195     // 2 - It&#39;s much easier to destroy a CachedFrame while it resides in the BackForwardCache if it is disconnected from its parent.</span>
196     for (unsigned i = 0; i &lt; m_childFrames.size(); ++i)
197         frame.tree().removeChild(m_childFrames[i]-&gt;view()-&gt;frame());
198 
199     if (!m_isMainFrame)
200         frame.page()-&gt;decrementSubframeCount();
201 


202 #ifndef NDEBUG
203     if (m_isMainFrame)
<span class="line-modified">204         LOG(BackForwardCache, &quot;Finished creating CachedFrame for main frame url &#39;%s&#39; and DocumentLoader %p\n&quot;, m_url.string().utf8().data(), m_documentLoader.get());</span>
205     else
<span class="line-modified">206         LOG(BackForwardCache, &quot;Finished creating CachedFrame for child frame with url &#39;%s&#39; and DocumentLoader %p\n&quot;, m_url.string().utf8().data(), m_documentLoader.get());</span>
207 #endif
208 
209 #if PLATFORM(IOS_FAMILY)
210     if (m_isMainFrame) {
211         if (DOMWindow* domWindow = m_document-&gt;domWindow()) {
212             if (domWindow-&gt;scrollEventListenerCount() &amp;&amp; frame.page())
213                 frame.page()-&gt;chrome().client().setNeedsScrollNotifications(frame, false);
214         }
215     }
216 #endif
217 
218     m_document-&gt;setMayBeDetachedFromFrame(true);
219     m_document-&gt;detachFromCachedFrame(*this);
220 
221     ASSERT_WITH_SECURITY_IMPLICATION(!m_documentLoader-&gt;isLoading());
222 }
223 
224 void CachedFrame::open()
225 {
226     ASSERT(m_view);
227     ASSERT(m_document);
228     if (!m_isMainFrame)
229         m_view-&gt;frame().page()-&gt;incrementSubframeCount();
230 
231     m_view-&gt;frame().loader().open(*this);
232 }
233 
234 void CachedFrame::clear()
235 {
236     if (!m_document)
237         return;
238 
<span class="line-modified">239     // clear() should only be called for Frames representing documents that are no longer in the back/forward cache.</span>
240     // This means the CachedFrame has been:
241     // 1 - Successfully restore()&#39;d by going back/forward.
<span class="line-modified">242     // 2 - destroy()&#39;ed because the BackForwardCache is pruning or the WebView was closed.</span>
<span class="line-modified">243     ASSERT(m_document-&gt;backForwardCacheState() == Document::NotInBackForwardCache);</span>
244     ASSERT(m_view);
245     ASSERT(!m_document-&gt;frame() || m_document-&gt;frame() == &amp;m_view-&gt;frame());
246 
247     for (int i = m_childFrames.size() - 1; i &gt;= 0; --i)
248         m_childFrames[i]-&gt;clear();
249 
250     m_document = nullptr;
251     m_view = nullptr;
252     m_url = URL();
253 
254     m_cachedFramePlatformData = nullptr;
255     m_cachedFrameScriptData = nullptr;
256 }
257 
258 void CachedFrame::destroy()
259 {
260     if (!m_document)
261         return;
262 
<span class="line-modified">263     // Only CachedFrames that are still in the BackForwardCache should be destroyed in this manner</span>
<span class="line-modified">264     ASSERT(m_document-&gt;backForwardCacheState() == Document::InBackForwardCache);</span>
265     ASSERT(m_view);
266     ASSERT(!m_document-&gt;frame());
267 
268     m_document-&gt;domWindow()-&gt;willDestroyCachedFrame();
269 
270     if (!m_isMainFrame &amp;&amp; m_view-&gt;frame().page()) {
271         m_view-&gt;frame().loader().detachViewsAndDocumentLoader();
272         m_view-&gt;frame().detachFromPage();
273     }
274 
275     for (int i = m_childFrames.size() - 1; i &gt;= 0; --i)
276         m_childFrames[i]-&gt;destroy();
277 
278     if (m_cachedFramePlatformData)
279         m_cachedFramePlatformData-&gt;clear();
280 
281     Frame::clearTimers(m_view.get(), m_document.get());
282 
283     m_view-&gt;frame().animation().detachFromDocument(m_document.get());
284 
<span class="line-modified">285     // FIXME: Why do we need to call removeAllEventListeners here? When the document is in back/forward cache, this method won&#39;t work</span>
286     // fully anyway, because the document won&#39;t be able to access its DOMWindow object (due to being frameless).
287     m_document-&gt;removeAllEventListeners();
288 
<span class="line-modified">289     m_document-&gt;setBackForwardCacheState(Document::NotInBackForwardCache);</span>
290     m_document-&gt;prepareForDestruction();
291 
292     clear();
293 }
294 
295 void CachedFrame::setCachedFramePlatformData(std::unique_ptr&lt;CachedFramePlatformData&gt; data)
296 {
297     m_cachedFramePlatformData = WTFMove(data);
298 }
299 
300 CachedFramePlatformData* CachedFrame::cachedFramePlatformData()
301 {
302     return m_cachedFramePlatformData.get();
303 }
304 
305 void CachedFrame::setHasInsecureContent(HasInsecureContent hasInsecureContent)
306 {
307     m_hasInsecureContent = hasInsecureContent;
308 }
309 
</pre>
</td>
</tr>
</table>
<center><a href="BackForwardItemIdentifier.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CachedFramePlatformData.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
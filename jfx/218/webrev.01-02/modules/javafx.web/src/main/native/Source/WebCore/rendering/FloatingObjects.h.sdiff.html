<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/FloatingObjects.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FloatingObjects.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="GridTrackSizingAlgorithm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/FloatingObjects.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  6  * Copyright (C) Research In Motion Limited 2010. All rights reserved.
  7  *
  8  * This library is free software; you can redistribute it and/or
  9  * modify it under the terms of the GNU Library General Public
 10  * License as published by the Free Software Foundation; either
 11  * version 2 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  */
 23 
 24 #pragma once
 25 
<span class="line-removed"> 26 #include &quot;PODIntervalTree.h&quot;</span>
 27 #include &quot;RootInlineBox.h&quot;
 28 #include &lt;wtf/ListHashSet.h&gt;
 29 #include &lt;wtf/WeakPtr.h&gt;
 30 
 31 namespace WebCore {
 32 
 33 class RenderBlockFlow;
 34 class RenderBox;
 35 



 36 class FloatingObject {
 37     WTF_MAKE_NONCOPYABLE(FloatingObject); WTF_MAKE_FAST_ALLOCATED;
 38 public:
 39     // Note that Type uses bits so you can use FloatLeftRight as a mask to query for both left and right.
 40     enum Type { FloatLeft = 1, FloatRight = 2, FloatLeftRight = 3 };
 41 
 42     static std::unique_ptr&lt;FloatingObject&gt; create(RenderBox&amp;);
 43     std::unique_ptr&lt;FloatingObject&gt; copyToNewContainer(LayoutSize, bool shouldPaint = false, bool isDescendant = false) const;
 44     std::unique_ptr&lt;FloatingObject&gt; cloneForNewParent() const;
 45 
 46     explicit FloatingObject(RenderBox&amp;);
 47     FloatingObject(RenderBox&amp;, Type, const LayoutRect&amp;, const LayoutSize&amp;, bool shouldPaint, bool isDescendant);
 48 
 49     Type type() const { return static_cast&lt;Type&gt;(m_type); }
 50     RenderBox&amp; renderer() const { return *m_renderer; }
 51 
 52     bool isPlaced() const { return m_isPlaced; }
 53     void setIsPlaced(bool placed = true) { m_isPlaced = placed; }
 54 
 55     LayoutUnit x() const { ASSERT(isPlaced()); return m_frameRect.x(); }
 56     LayoutUnit maxX() const { ASSERT(isPlaced()); return m_frameRect.maxX(); }
 57     LayoutUnit y() const { ASSERT(isPlaced()); return m_frameRect.y(); }
 58     LayoutUnit maxY() const { ASSERT(isPlaced()); return m_frameRect.maxY(); }
 59     LayoutUnit width() const { return m_frameRect.width(); }
 60     LayoutUnit height() const { return m_frameRect.height(); }
 61 
 62     void setX(LayoutUnit x) { ASSERT(!isInPlacedTree()); m_frameRect.setX(x); }
 63     void setY(LayoutUnit y) { ASSERT(!isInPlacedTree()); m_frameRect.setY(y); }
 64     void setWidth(LayoutUnit width) { ASSERT(!isInPlacedTree()); m_frameRect.setWidth(width); }
 65     void setHeight(LayoutUnit height) { ASSERT(!isInPlacedTree()); m_frameRect.setHeight(height); }
 66 
 67     void setMarginOffset(LayoutSize offset) { ASSERT(!isInPlacedTree()); m_marginOffset = offset; }
 68 
 69     const LayoutRect&amp; frameRect() const { ASSERT(isPlaced()); return m_frameRect; }
 70     void setFrameRect(const LayoutRect&amp; frameRect) { ASSERT(!isInPlacedTree()); m_frameRect = frameRect; }
 71 
 72     LayoutUnit paginationStrut() const { return m_paginationStrut; }
 73     void setPaginationStrut(LayoutUnit strut) { m_paginationStrut = strut; }
 74 
<span class="line-modified"> 75 #ifndef NDEBUG</span>
 76     bool isInPlacedTree() const { return m_isInPlacedTree; }
 77     void setIsInPlacedTree(bool value) { m_isInPlacedTree = value; }
 78 #endif
 79 
 80     bool shouldPaint() const { return m_shouldPaint; }
 81     void setShouldPaint(bool shouldPaint) { m_shouldPaint = shouldPaint; }
 82     bool isDescendant() const { return m_isDescendant; }
 83     void setIsDescendant(bool isDescendant) { m_isDescendant = isDescendant; }
 84 
 85     // FIXME: Callers of these methods are dangerous and should be whitelisted explicitly or removed.
 86     RootInlineBox* originatingLine() const { return m_originatingLine.get(); }
 87     void clearOriginatingLine() { m_originatingLine = nullptr; }
 88     void setOriginatingLine(RootInlineBox&amp; line) { m_originatingLine = makeWeakPtr(line); }
 89 
 90     LayoutSize locationOffsetOfBorderBox() const
 91     {
 92         ASSERT(isPlaced());
 93         return LayoutSize(m_frameRect.location().x() + m_marginOffset.width(), m_frameRect.location().y() + m_marginOffset.height());
 94     }
 95     LayoutSize marginOffset() const { ASSERT(isPlaced()); return m_marginOffset; }
 96     LayoutSize translationOffsetToAncestor() const;
 97 
<span class="line-removed"> 98     String debugString() const;</span>
<span class="line-removed"> 99 </span>
100 private:
101     WeakPtr&lt;RenderBox&gt; m_renderer;
102     WeakPtr&lt;RootInlineBox&gt; m_originatingLine;
103     LayoutRect m_frameRect;
104     LayoutUnit m_paginationStrut;
105     LayoutSize m_marginOffset;
106 
107     unsigned m_type : 2; // Type (left or right aligned)
108     unsigned m_shouldPaint : 1;
109     unsigned m_isDescendant : 1;
110     unsigned m_isPlaced : 1;
<span class="line-modified">111 #ifndef NDEBUG</span>
112     unsigned m_isInPlacedTree : 1;
113 #endif
114 };
115 
116 // FIXME: This could be simplified if we made it inherit from PtrHash&lt;std::unique_ptr&lt;FloatingObject&gt;&gt; and
117 // changed PtrHashBase to have all of its hash and equal functions bottleneck through single functions (as
118 // is done here). That would allow us to only override those master hash and equal functions.
119 struct FloatingObjectHashFunctions {
120     typedef std::unique_ptr&lt;FloatingObject&gt; T;
121     typedef typename WTF::GetPtrHelper&lt;T&gt;::PtrType PtrType;
122 
123     static unsigned hash(PtrType key) { return PtrHash&lt;RenderBox*&gt;::hash(&amp;key-&gt;renderer()); }
124     static bool equal(PtrType a, PtrType b) { return &amp;a-&gt;renderer() == &amp;b-&gt;renderer(); }
125     static const bool safeToCompareToEmptyOrDeleted = true;
126 
127     static unsigned hash(const T&amp; key) { return hash(WTF::getPtr(key)); }
128     static bool equal(const T&amp; a, const T&amp; b) { return equal(WTF::getPtr(a), WTF::getPtr(b)); }
129     static bool equal(PtrType a, const T&amp; b) { return equal(a, WTF::getPtr(b)); }
130     static bool equal(const T&amp; a, PtrType b) { return equal(WTF::getPtr(a), b); }
131 };
</pre>
<hr />
<pre>
170 
171     LayoutUnit findNextFloatLogicalBottomBelow(LayoutUnit logicalHeight);
172     LayoutUnit findNextFloatLogicalBottomBelowForBlock(LayoutUnit logicalHeight);
173 
174 private:
175     const RenderBlockFlow&amp; renderer() const { return *m_renderer; }
176     void computePlacedFloatsTree();
177     const FloatingObjectTree* placedFloatsTree();
178     void increaseObjectsCount(FloatingObject::Type);
179     void decreaseObjectsCount(FloatingObject::Type);
180     FloatingObjectInterval intervalForFloatingObject(FloatingObject*);
181 
182     FloatingObjectSet m_set;
183     std::unique_ptr&lt;FloatingObjectTree&gt; m_placedFloatsTree;
184     unsigned m_leftObjectsCount;
185     unsigned m_rightObjectsCount;
186     bool m_horizontalWritingMode;
187     WeakPtr&lt;const RenderBlockFlow&gt; m_renderer;
188 };
189 
<span class="line-removed">190 } // namespace WebCore</span>
<span class="line-removed">191 </span>
192 #ifndef NDEBUG
<span class="line-modified">193 </span>
<span class="line-removed">194 namespace WTF {</span>
<span class="line-removed">195 </span>
<span class="line-removed">196 // This helper is used by PODIntervalTree for debugging purposes.</span>
<span class="line-removed">197 template&lt;&gt; struct ValueToString&lt;WebCore::FloatingObject*&gt; {</span>
<span class="line-removed">198     static String string(const WebCore::FloatingObject* floatingObject) { return floatingObject-&gt;debugString(); }</span>
<span class="line-removed">199 };</span>
<span class="line-removed">200 </span>
<span class="line-removed">201 } // namespace WTF</span>
<span class="line-removed">202 </span>
203 #endif


</pre>
</td>
<td>
<hr />
<pre>
  6  * Copyright (C) Research In Motion Limited 2010. All rights reserved.
  7  *
  8  * This library is free software; you can redistribute it and/or
  9  * modify it under the terms of the GNU Library General Public
 10  * License as published by the Free Software Foundation; either
 11  * version 2 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  */
 23 
 24 #pragma once
 25 

 26 #include &quot;RootInlineBox.h&quot;
 27 #include &lt;wtf/ListHashSet.h&gt;
 28 #include &lt;wtf/WeakPtr.h&gt;
 29 
 30 namespace WebCore {
 31 
 32 class RenderBlockFlow;
 33 class RenderBox;
 34 
<span class="line-added"> 35 template&lt;typename, typename&gt; class PODInterval;</span>
<span class="line-added"> 36 template&lt;typename, typename&gt; class PODIntervalTree;</span>
<span class="line-added"> 37 </span>
 38 class FloatingObject {
 39     WTF_MAKE_NONCOPYABLE(FloatingObject); WTF_MAKE_FAST_ALLOCATED;
 40 public:
 41     // Note that Type uses bits so you can use FloatLeftRight as a mask to query for both left and right.
 42     enum Type { FloatLeft = 1, FloatRight = 2, FloatLeftRight = 3 };
 43 
 44     static std::unique_ptr&lt;FloatingObject&gt; create(RenderBox&amp;);
 45     std::unique_ptr&lt;FloatingObject&gt; copyToNewContainer(LayoutSize, bool shouldPaint = false, bool isDescendant = false) const;
 46     std::unique_ptr&lt;FloatingObject&gt; cloneForNewParent() const;
 47 
 48     explicit FloatingObject(RenderBox&amp;);
 49     FloatingObject(RenderBox&amp;, Type, const LayoutRect&amp;, const LayoutSize&amp;, bool shouldPaint, bool isDescendant);
 50 
 51     Type type() const { return static_cast&lt;Type&gt;(m_type); }
 52     RenderBox&amp; renderer() const { return *m_renderer; }
 53 
 54     bool isPlaced() const { return m_isPlaced; }
 55     void setIsPlaced(bool placed = true) { m_isPlaced = placed; }
 56 
 57     LayoutUnit x() const { ASSERT(isPlaced()); return m_frameRect.x(); }
 58     LayoutUnit maxX() const { ASSERT(isPlaced()); return m_frameRect.maxX(); }
 59     LayoutUnit y() const { ASSERT(isPlaced()); return m_frameRect.y(); }
 60     LayoutUnit maxY() const { ASSERT(isPlaced()); return m_frameRect.maxY(); }
 61     LayoutUnit width() const { return m_frameRect.width(); }
 62     LayoutUnit height() const { return m_frameRect.height(); }
 63 
 64     void setX(LayoutUnit x) { ASSERT(!isInPlacedTree()); m_frameRect.setX(x); }
 65     void setY(LayoutUnit y) { ASSERT(!isInPlacedTree()); m_frameRect.setY(y); }
 66     void setWidth(LayoutUnit width) { ASSERT(!isInPlacedTree()); m_frameRect.setWidth(width); }
 67     void setHeight(LayoutUnit height) { ASSERT(!isInPlacedTree()); m_frameRect.setHeight(height); }
 68 
 69     void setMarginOffset(LayoutSize offset) { ASSERT(!isInPlacedTree()); m_marginOffset = offset; }
 70 
 71     const LayoutRect&amp; frameRect() const { ASSERT(isPlaced()); return m_frameRect; }
 72     void setFrameRect(const LayoutRect&amp; frameRect) { ASSERT(!isInPlacedTree()); m_frameRect = frameRect; }
 73 
 74     LayoutUnit paginationStrut() const { return m_paginationStrut; }
 75     void setPaginationStrut(LayoutUnit strut) { m_paginationStrut = strut; }
 76 
<span class="line-modified"> 77 #if ASSERT_ENABLED</span>
 78     bool isInPlacedTree() const { return m_isInPlacedTree; }
 79     void setIsInPlacedTree(bool value) { m_isInPlacedTree = value; }
 80 #endif
 81 
 82     bool shouldPaint() const { return m_shouldPaint; }
 83     void setShouldPaint(bool shouldPaint) { m_shouldPaint = shouldPaint; }
 84     bool isDescendant() const { return m_isDescendant; }
 85     void setIsDescendant(bool isDescendant) { m_isDescendant = isDescendant; }
 86 
 87     // FIXME: Callers of these methods are dangerous and should be whitelisted explicitly or removed.
 88     RootInlineBox* originatingLine() const { return m_originatingLine.get(); }
 89     void clearOriginatingLine() { m_originatingLine = nullptr; }
 90     void setOriginatingLine(RootInlineBox&amp; line) { m_originatingLine = makeWeakPtr(line); }
 91 
 92     LayoutSize locationOffsetOfBorderBox() const
 93     {
 94         ASSERT(isPlaced());
 95         return LayoutSize(m_frameRect.location().x() + m_marginOffset.width(), m_frameRect.location().y() + m_marginOffset.height());
 96     }
 97     LayoutSize marginOffset() const { ASSERT(isPlaced()); return m_marginOffset; }
 98     LayoutSize translationOffsetToAncestor() const;
 99 


100 private:
101     WeakPtr&lt;RenderBox&gt; m_renderer;
102     WeakPtr&lt;RootInlineBox&gt; m_originatingLine;
103     LayoutRect m_frameRect;
104     LayoutUnit m_paginationStrut;
105     LayoutSize m_marginOffset;
106 
107     unsigned m_type : 2; // Type (left or right aligned)
108     unsigned m_shouldPaint : 1;
109     unsigned m_isDescendant : 1;
110     unsigned m_isPlaced : 1;
<span class="line-modified">111 #if ASSERT_ENABLED</span>
112     unsigned m_isInPlacedTree : 1;
113 #endif
114 };
115 
116 // FIXME: This could be simplified if we made it inherit from PtrHash&lt;std::unique_ptr&lt;FloatingObject&gt;&gt; and
117 // changed PtrHashBase to have all of its hash and equal functions bottleneck through single functions (as
118 // is done here). That would allow us to only override those master hash and equal functions.
119 struct FloatingObjectHashFunctions {
120     typedef std::unique_ptr&lt;FloatingObject&gt; T;
121     typedef typename WTF::GetPtrHelper&lt;T&gt;::PtrType PtrType;
122 
123     static unsigned hash(PtrType key) { return PtrHash&lt;RenderBox*&gt;::hash(&amp;key-&gt;renderer()); }
124     static bool equal(PtrType a, PtrType b) { return &amp;a-&gt;renderer() == &amp;b-&gt;renderer(); }
125     static const bool safeToCompareToEmptyOrDeleted = true;
126 
127     static unsigned hash(const T&amp; key) { return hash(WTF::getPtr(key)); }
128     static bool equal(const T&amp; a, const T&amp; b) { return equal(WTF::getPtr(a), WTF::getPtr(b)); }
129     static bool equal(PtrType a, const T&amp; b) { return equal(a, WTF::getPtr(b)); }
130     static bool equal(const T&amp; a, PtrType b) { return equal(WTF::getPtr(a), b); }
131 };
</pre>
<hr />
<pre>
170 
171     LayoutUnit findNextFloatLogicalBottomBelow(LayoutUnit logicalHeight);
172     LayoutUnit findNextFloatLogicalBottomBelowForBlock(LayoutUnit logicalHeight);
173 
174 private:
175     const RenderBlockFlow&amp; renderer() const { return *m_renderer; }
176     void computePlacedFloatsTree();
177     const FloatingObjectTree* placedFloatsTree();
178     void increaseObjectsCount(FloatingObject::Type);
179     void decreaseObjectsCount(FloatingObject::Type);
180     FloatingObjectInterval intervalForFloatingObject(FloatingObject*);
181 
182     FloatingObjectSet m_set;
183     std::unique_ptr&lt;FloatingObjectTree&gt; m_placedFloatsTree;
184     unsigned m_leftObjectsCount;
185     unsigned m_rightObjectsCount;
186     bool m_horizontalWritingMode;
187     WeakPtr&lt;const RenderBlockFlow&gt; m_renderer;
188 };
189 


190 #ifndef NDEBUG
<span class="line-modified">191 TextStream&amp; operator&lt;&lt;(TextStream&amp;, const FloatingObject&amp;);</span>









192 #endif
<span class="line-added">193 </span>
<span class="line-added">194 } // namespace WebCore</span>
</pre>
</td>
</tr>
</table>
<center><a href="FloatingObjects.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="GridTrackSizingAlgorithm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
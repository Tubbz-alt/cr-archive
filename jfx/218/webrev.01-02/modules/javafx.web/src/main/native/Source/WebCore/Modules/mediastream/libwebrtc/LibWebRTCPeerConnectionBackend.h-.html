<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/libwebrtc/LibWebRTCPeerConnectionBackend.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1.  Redistributions of source code must retain the above copyright
  8  *     notice, this list of conditions and the following disclaimer.
  9  * 2.  Redistributions in binary form must reproduce the above copyright
 10  *     notice, this list of conditions and the following disclaimer in the
 11  *     documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 15  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 16  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 17  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 18  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 19  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 20  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 21  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 22  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 23  */
 24 
 25 #pragma once
 26 
 27 #if USE(LIBWEBRTC)
 28 
 29 #include &quot;PeerConnectionBackend.h&quot;
 30 #include &lt;wtf/HashMap.h&gt;
 31 
 32 namespace webrtc {
 33 class IceCandidateInterface;
 34 }
 35 
 36 namespace WebCore {
 37 
 38 class LibWebRTCMediaEndpoint;
 39 class LibWebRTCProvider;
 40 class LibWebRTCRtpSenderBackend;
 41 class LibWebRTCRtpTransceiverBackend;
 42 class RTCRtpReceiver;
 43 class RTCRtpReceiverBackend;
 44 class RTCSessionDescription;
 45 class RTCStatsReport;
 46 class RealtimeIncomingAudioSource;
 47 class RealtimeIncomingVideoSource;
 48 class RealtimeMediaSource;
 49 class RealtimeOutgoingAudioSource;
 50 class RealtimeOutgoingVideoSource;
 51 
 52 class LibWebRTCPeerConnectionBackend final : public PeerConnectionBackend {
 53     WTF_MAKE_FAST_ALLOCATED;
 54 public:
 55     LibWebRTCPeerConnectionBackend(RTCPeerConnection&amp;, LibWebRTCProvider&amp;);
 56     ~LibWebRTCPeerConnectionBackend();
 57 
 58     void replaceTrack(RTCRtpSender&amp;, RefPtr&lt;MediaStreamTrack&gt;&amp;&amp;, DOMPromiseDeferred&lt;void&gt;&amp;&amp;);
 59 
 60     bool shouldOfferAllowToReceive(const char*) const;
 61 
 62 private:
 63     void doCreateOffer(RTCOfferOptions&amp;&amp;) final;
 64     void doCreateAnswer(RTCAnswerOptions&amp;&amp;) final;
 65     void doSetLocalDescription(RTCSessionDescription&amp;) final;
 66     void doSetRemoteDescription(RTCSessionDescription&amp;) final;
 67     void doAddIceCandidate(RTCIceCandidate&amp;) final;
 68     void doStop() final;
 69     std::unique_ptr&lt;RTCDataChannelHandler&gt; createDataChannelHandler(const String&amp;, const RTCDataChannelInit&amp;) final;
 70     bool setConfiguration(MediaEndpointConfiguration&amp;&amp;) final;
 71     void getStats(Ref&lt;DeferredPromise&gt;&amp;&amp;) final;
 72     void getStats(RTCRtpSender&amp;, Ref&lt;DeferredPromise&gt;&amp;&amp;) final;
 73     void getStats(RTCRtpReceiver&amp;, Ref&lt;DeferredPromise&gt;&amp;&amp;) final;
 74 
 75     RefPtr&lt;RTCSessionDescription&gt; localDescription() const final;
 76     RefPtr&lt;RTCSessionDescription&gt; currentLocalDescription() const final;
 77     RefPtr&lt;RTCSessionDescription&gt; pendingLocalDescription() const final;
 78 
 79     RefPtr&lt;RTCSessionDescription&gt; remoteDescription() const final;
 80     RefPtr&lt;RTCSessionDescription&gt; currentRemoteDescription() const final;
 81     RefPtr&lt;RTCSessionDescription&gt; pendingRemoteDescription() const final;
 82 
 83     void emulatePlatformEvent(const String&amp;) final { }
 84     void applyRotationForOutgoingVideoSources() final;
 85 
 86     friend class LibWebRTCMediaEndpoint;
 87     friend class LibWebRTCRtpSenderBackend;
 88     RTCPeerConnection&amp; connection() { return m_peerConnection; }
 89 
 90     void getStatsSucceeded(const DeferredPromise&amp;, Ref&lt;RTCStatsReport&gt;&amp;&amp;);
 91 
 92     ExceptionOr&lt;Ref&lt;RTCRtpSender&gt;&gt; addTrack(MediaStreamTrack&amp;, Vector&lt;String&gt;&amp;&amp;) final;
 93     void removeTrack(RTCRtpSender&amp;) final;
 94 
 95     ExceptionOr&lt;Ref&lt;RTCRtpTransceiver&gt;&gt; addTransceiver(const String&amp;, const RTCRtpTransceiverInit&amp;) final;
 96     ExceptionOr&lt;Ref&lt;RTCRtpTransceiver&gt;&gt; addTransceiver(Ref&lt;MediaStreamTrack&gt;&amp;&amp;, const RTCRtpTransceiverInit&amp;) final;
 97     void setSenderSourceFromTrack(LibWebRTCRtpSenderBackend&amp;, MediaStreamTrack&amp;);
 98 
 99     RTCRtpTransceiver* existingTransceiver(WTF::Function&lt;bool(LibWebRTCRtpTransceiverBackend&amp;)&gt;&amp;&amp;);
100     RTCRtpTransceiver&amp; newRemoteTransceiver(std::unique_ptr&lt;LibWebRTCRtpTransceiverBackend&gt;&amp;&amp;, Ref&lt;RealtimeMediaSource&gt;&amp;&amp;);
101 
102     void collectTransceivers() final;
103 
104     struct VideoReceiver {
105         Ref&lt;RTCRtpReceiver&gt; receiver;
106         Ref&lt;RealtimeIncomingVideoSource&gt; source;
107     };
108     struct AudioReceiver {
109         Ref&lt;RTCRtpReceiver&gt; receiver;
110         Ref&lt;RealtimeIncomingAudioSource&gt; source;
111     };
112     VideoReceiver videoReceiver(String&amp;&amp; trackId);
113     AudioReceiver audioReceiver(String&amp;&amp; trackId);
114 
115 private:
116     bool isLocalDescriptionSet() const final { return m_isLocalDescriptionSet; }
117 
118     Ref&lt;RTCRtpTransceiver&gt; completeAddTransceiver(Ref&lt;RTCRtpSender&gt;&amp;&amp;, const RTCRtpTransceiverInit&amp;, const String&amp; trackId, const String&amp; trackKind);
119 
120     Ref&lt;RTCRtpReceiver&gt; createReceiver(const String&amp; trackKind, const String&amp; trackId);
121 
122     template&lt;typename T&gt;
123     ExceptionOr&lt;Ref&lt;RTCRtpTransceiver&gt;&gt; addUnifiedPlanTransceiver(T&amp;&amp; trackOrKind, const RTCRtpTransceiverInit&amp;);
124 
125     Ref&lt;RTCRtpReceiver&gt; createReceiverForSource(Ref&lt;RealtimeMediaSource&gt;&amp;&amp;, std::unique_ptr&lt;RTCRtpReceiverBackend&gt;&amp;&amp;);
126 
127     Ref&lt;LibWebRTCMediaEndpoint&gt; m_endpoint;
128     bool m_isLocalDescriptionSet { false };
129     bool m_isRemoteDescriptionSet { false };
130 
131     Vector&lt;std::unique_ptr&lt;webrtc::IceCandidateInterface&gt;&gt; m_pendingCandidates;
132     Vector&lt;Ref&lt;RTCRtpReceiver&gt;&gt; m_pendingReceivers;
133 };
134 
135 } // namespace WebCore
136 
137 #endif // USE(LIBWEBRTC)
    </pre>
  </body>
</html>
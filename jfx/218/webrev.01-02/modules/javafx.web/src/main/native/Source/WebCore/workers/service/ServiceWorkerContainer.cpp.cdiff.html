<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerContainer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ServiceWorkerClient.idl.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ServiceWorkerContainer.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerContainer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,48 ***</span>
  #include &quot;config.h&quot;
  #include &quot;ServiceWorkerContainer.h&quot;
  
  #if ENABLE(SERVICE_WORKER)
  
  #include &quot;Document.h&quot;
  #include &quot;Event.h&quot;
  #include &quot;EventNames.h&quot;
  #include &quot;Exception.h&quot;
  #include &quot;IDLTypes.h&quot;
  #include &quot;JSDOMPromiseDeferred.h&quot;
  #include &quot;JSServiceWorkerRegistration.h&quot;
  #include &quot;Logging.h&quot;
  #include &quot;MessageEvent.h&quot;
  #include &quot;NavigatorBase.h&quot;
  #include &quot;ResourceError.h&quot;
<span class="line-removed">- #include &quot;SchemeRegistry.h&quot;</span>
  #include &quot;ScriptExecutionContext.h&quot;
  #include &quot;SecurityOrigin.h&quot;
  #include &quot;ServiceWorker.h&quot;
  #include &quot;ServiceWorkerFetchResult.h&quot;
  #include &quot;ServiceWorkerGlobalScope.h&quot;
  #include &quot;ServiceWorkerJob.h&quot;
  #include &quot;ServiceWorkerJobData.h&quot;
  #include &quot;ServiceWorkerProvider.h&quot;
  #include &quot;ServiceWorkerThread.h&quot;
  #include &lt;wtf/IsoMallocInlines.h&gt;
  #include &lt;wtf/RunLoop.h&gt;
  #include &lt;wtf/Scope.h&gt;
  #include &lt;wtf/URL.h&gt;
  
  #define CONTAINER_RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), ServiceWorker, &quot;%p - ServiceWorkerContainer::&quot; fmt, this, ##__VA_ARGS__)
  #define CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(fmt, ...) RELEASE_LOG_ERROR_IF(isAlwaysOnLoggingAllowed(), ServiceWorker, &quot;%p - ServiceWorkerContainer::&quot; fmt, this, ##__VA_ARGS__)
  
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(ServiceWorkerContainer);
  
  ServiceWorkerContainer::ServiceWorkerContainer(ScriptExecutionContext* context, NavigatorBase&amp; navigator)
      : ActiveDOMObject(context)
      , m_navigator(navigator)
  {
      suspendIfNeeded();
  }
  
  ServiceWorkerContainer::~ServiceWorkerContainer()
  {
  #ifndef NDEBUG
<span class="line-new-header">--- 26,61 ---</span>
  #include &quot;config.h&quot;
  #include &quot;ServiceWorkerContainer.h&quot;
  
  #if ENABLE(SERVICE_WORKER)
  
<span class="line-added">+ #include &quot;DOMPromiseProxy.h&quot;</span>
  #include &quot;Document.h&quot;
  #include &quot;Event.h&quot;
<span class="line-added">+ #include &quot;EventLoop.h&quot;</span>
  #include &quot;EventNames.h&quot;
  #include &quot;Exception.h&quot;
  #include &quot;IDLTypes.h&quot;
  #include &quot;JSDOMPromiseDeferred.h&quot;
  #include &quot;JSServiceWorkerRegistration.h&quot;
<span class="line-added">+ #include &quot;LegacySchemeRegistry.h&quot;</span>
  #include &quot;Logging.h&quot;
  #include &quot;MessageEvent.h&quot;
  #include &quot;NavigatorBase.h&quot;
<span class="line-added">+ #include &quot;Page.h&quot;</span>
  #include &quot;ResourceError.h&quot;
  #include &quot;ScriptExecutionContext.h&quot;
  #include &quot;SecurityOrigin.h&quot;
  #include &quot;ServiceWorker.h&quot;
  #include &quot;ServiceWorkerFetchResult.h&quot;
  #include &quot;ServiceWorkerGlobalScope.h&quot;
  #include &quot;ServiceWorkerJob.h&quot;
  #include &quot;ServiceWorkerJobData.h&quot;
  #include &quot;ServiceWorkerProvider.h&quot;
  #include &quot;ServiceWorkerThread.h&quot;
<span class="line-added">+ #include &quot;WorkerSWClientConnection.h&quot;</span>
  #include &lt;wtf/IsoMallocInlines.h&gt;
  #include &lt;wtf/RunLoop.h&gt;
  #include &lt;wtf/Scope.h&gt;
  #include &lt;wtf/URL.h&gt;
  
  #define CONTAINER_RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), ServiceWorker, &quot;%p - ServiceWorkerContainer::&quot; fmt, this, ##__VA_ARGS__)
  #define CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(fmt, ...) RELEASE_LOG_ERROR_IF(isAlwaysOnLoggingAllowed(), ServiceWorker, &quot;%p - ServiceWorkerContainer::&quot; fmt, this, ##__VA_ARGS__)
  
  namespace WebCore {
  
<span class="line-added">+ static inline SWClientConnection&amp; mainThreadConnection()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return ServiceWorkerProvider::singleton().serviceWorkerConnection();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  WTF_MAKE_ISO_ALLOCATED_IMPL(ServiceWorkerContainer);
  
  ServiceWorkerContainer::ServiceWorkerContainer(ScriptExecutionContext* context, NavigatorBase&amp; navigator)
      : ActiveDOMObject(context)
      , m_navigator(navigator)
  {
      suspendIfNeeded();
<span class="line-added">+ </span>
<span class="line-added">+     // We should queue messages until the DOMContentLoaded event has fired or startMessages() has been called.</span>
<span class="line-added">+     if (is&lt;Document&gt;(context) &amp;&amp; downcast&lt;Document&gt;(*context).parsing())</span>
<span class="line-added">+         m_shouldDeferMessageEvents = true;</span>
  }
  
  ServiceWorkerContainer::~ServiceWorkerContainer()
  {
  #ifndef NDEBUG
</pre>
<hr />
<pre>
<span class="line-old-header">*** 88,27 ***</span>
  auto ServiceWorkerContainer::ready() -&gt; ReadyPromise&amp;
  {
      if (!m_readyPromise) {
          m_readyPromise = makeUnique&lt;ReadyPromise&gt;();
  
<span class="line-modified">!         if (m_isStopped || !scriptExecutionContext()-&gt;sessionID().isValid())</span>
              return *m_readyPromise;
  
          auto&amp; context = *scriptExecutionContext();
<span class="line-modified">!         auto contextIdentifier = this-&gt;contextIdentifier();</span>
<span class="line-modified">!         callOnMainThread([connection = makeRef(ensureSWClientConnection()), topOrigin = context.topOrigin().isolatedCopy(), clientURL = context.url().isolatedCopy(), contextIdentifier]() mutable {</span>
<span class="line-modified">!             connection-&gt;whenRegistrationReady(topOrigin, clientURL, [contextIdentifier](auto&amp;&amp; registrationData) {</span>
<span class="line-modified">!                 ScriptExecutionContext::postTaskTo(contextIdentifier, [registrationData = crossThreadCopy(registrationData)](auto&amp; context) mutable {</span>
<span class="line-removed">-                     auto* serviceWorkerContainer = context.serviceWorkerContainer();</span>
<span class="line-removed">-                     if (!serviceWorkerContainer)</span>
<span class="line-removed">-                         return;</span>
<span class="line-removed">-                     if (serviceWorkerContainer-&gt;m_isStopped || !context.sessionID().isValid())</span>
<span class="line-removed">-                         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     auto registration = ServiceWorkerRegistration::getOrCreate(context, *serviceWorkerContainer, WTFMove(registrationData));</span>
<span class="line-removed">-                     serviceWorkerContainer-&gt;m_readyPromise-&gt;resolve(WTFMove(registration));</span>
<span class="line-removed">-                 });</span>
              });
          });
      }
      return *m_readyPromise;
  }
<span class="line-new-header">--- 101,18 ---</span>
  auto ServiceWorkerContainer::ready() -&gt; ReadyPromise&amp;
  {
      if (!m_readyPromise) {
          m_readyPromise = makeUnique&lt;ReadyPromise&gt;();
  
<span class="line-modified">!         if (m_isStopped)</span>
              return *m_readyPromise;
  
          auto&amp; context = *scriptExecutionContext();
<span class="line-modified">!         ensureSWClientConnection().whenRegistrationReady(context.topOrigin().data(), context.url(), [this, protectedThis = makeRef(*this)](auto&amp;&amp; registrationData) mutable {</span>
<span class="line-modified">!             queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [this, registrationData = WTFMove(registrationData)]() mutable {</span>
<span class="line-modified">!                 auto registration = ServiceWorkerRegistration::getOrCreate(*scriptExecutionContext(), *this, WTFMove(registrationData));</span>
<span class="line-modified">!                 m_readyPromise-&gt;resolve(WTFMove(registration));</span>
              });
          });
      }
      return *m_readyPromise;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 121,11 ***</span>
  }
  
  void ServiceWorkerContainer::addRegistration(const String&amp; relativeScriptURL, const RegistrationOptions&amp; options, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
  {
      auto* context = scriptExecutionContext();
<span class="line-modified">!     if (m_isStopped || !context-&gt;sessionID().isValid()) {</span>
          promise-&gt;reject(Exception(InvalidStateError));
          return;
      }
  
      if (relativeScriptURL.isEmpty()) {
<span class="line-new-header">--- 125,11 ---</span>
  }
  
  void ServiceWorkerContainer::addRegistration(const String&amp; relativeScriptURL, const RegistrationOptions&amp; options, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
  {
      auto* context = scriptExecutionContext();
<span class="line-modified">!     if (m_isStopped) {</span>
          promise-&gt;reject(Exception(InvalidStateError));
          return;
      }
  
      if (relativeScriptURL.isEmpty()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 140,11 ***</span>
          CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;addRegistration: Invalid scriptURL&quot;);
          promise-&gt;reject(Exception { TypeError, &quot;serviceWorker.register() must be called with a valid relative script URL&quot;_s });
          return;
      }
  
<span class="line-modified">!     if (!SchemeRegistry::canServiceWorkersHandleURLScheme(jobData.scriptURL.protocol().toStringWithoutCopying())) {</span>
          CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;addRegistration: Invalid scriptURL scheme is not HTTP or HTTPS&quot;);
          promise-&gt;reject(Exception { TypeError, &quot;serviceWorker.register() must be called with a script URL whose protocol is either HTTP or HTTPS&quot;_s });
          return;
      }
  
<span class="line-new-header">--- 144,11 ---</span>
          CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;addRegistration: Invalid scriptURL&quot;);
          promise-&gt;reject(Exception { TypeError, &quot;serviceWorker.register() must be called with a valid relative script URL&quot;_s });
          return;
      }
  
<span class="line-modified">!     if (!LegacySchemeRegistry::canServiceWorkersHandleURLScheme(jobData.scriptURL.protocol().toStringWithoutCopying())) {</span>
          CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;addRegistration: Invalid scriptURL scheme is not HTTP or HTTPS&quot;);
          promise-&gt;reject(Exception { TypeError, &quot;serviceWorker.register() must be called with a script URL whose protocol is either HTTP or HTTPS&quot;_s });
          return;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 158,11 ***</span>
      if (!options.scope.isEmpty())
          jobData.scopeURL = context-&gt;completeURL(options.scope);
      else
          jobData.scopeURL = URL(jobData.scriptURL, &quot;./&quot;);
  
<span class="line-modified">!     if (!jobData.scopeURL.isNull() &amp;&amp; !SchemeRegistry::canServiceWorkersHandleURLScheme(jobData.scopeURL.protocol().toStringWithoutCopying())) {</span>
          CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;addRegistration: scopeURL scheme is not HTTP or HTTPS&quot;);
          promise-&gt;reject(Exception { TypeError, &quot;Scope URL provided to serviceWorker.register() must be either HTTP or HTTPS&quot;_s });
          return;
      }
  
<span class="line-new-header">--- 162,11 ---</span>
      if (!options.scope.isEmpty())
          jobData.scopeURL = context-&gt;completeURL(options.scope);
      else
          jobData.scopeURL = URL(jobData.scriptURL, &quot;./&quot;);
  
<span class="line-modified">!     if (!jobData.scopeURL.isNull() &amp;&amp; !LegacySchemeRegistry::canServiceWorkersHandleURLScheme(jobData.scopeURL.protocol().toStringWithoutCopying())) {</span>
          CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;addRegistration: scopeURL scheme is not HTTP or HTTPS&quot;);
          promise-&gt;reject(Exception { TypeError, &quot;Scope URL provided to serviceWorker.register() must be either HTTP or HTTPS&quot;_s });
          return;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 184,11 ***</span>
  }
  
  void ServiceWorkerContainer::removeRegistration(const URL&amp; scopeURL, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
  {
      auto* context = scriptExecutionContext();
<span class="line-modified">!     if (!context || !context-&gt;sessionID().isValid()) {</span>
          ASSERT_NOT_REACHED();
          promise-&gt;reject(Exception(InvalidStateError));
          return;
      }
  
<span class="line-new-header">--- 188,11 ---</span>
  }
  
  void ServiceWorkerContainer::removeRegistration(const URL&amp; scopeURL, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
  {
      auto* context = scriptExecutionContext();
<span class="line-modified">!     if (!context) {</span>
          ASSERT_NOT_REACHED();
          promise-&gt;reject(Exception(InvalidStateError));
          return;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 212,11 ***</span>
  void ServiceWorkerContainer::updateRegistration(const URL&amp; scopeURL, const URL&amp; scriptURL, WorkerType, RefPtr&lt;DeferredPromise&gt;&amp;&amp; promise)
  {
      ASSERT(!m_isStopped);
  
      auto&amp; context = *scriptExecutionContext();
<span class="line-removed">-     ASSERT(context.sessionID().isValid());</span>
  
      if (!m_swConnection) {
          ASSERT_NOT_REACHED();
          if (promise)
              promise-&gt;reject(Exception(InvalidStateError));
<span class="line-new-header">--- 216,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 247,139 ***</span>
      auto&amp; jobData = job-&gt;data();
      auto jobIdentifier = job-&gt;identifier();
      ASSERT(!m_jobMap.contains(jobIdentifier));
      m_jobMap.add(jobIdentifier, OngoingJob { WTFMove(job), makePendingActivity(*this) });
  
<span class="line-modified">!     callOnMainThread([connection = m_swConnection, contextIdentifier = this-&gt;contextIdentifier(), jobData = jobData.isolatedCopy()] {</span>
<span class="line-removed">-         connection-&gt;scheduleJob(contextIdentifier, jobData);</span>
<span class="line-removed">-     });</span>
  }
  
  void ServiceWorkerContainer::getRegistration(const String&amp; clientURL, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
  {
<span class="line-modified">!     auto* context = scriptExecutionContext();</span>
<span class="line-removed">-     if (m_isStopped || !context-&gt;sessionID().isValid()) {</span>
          promise-&gt;reject(Exception { InvalidStateError });
          return;
      }
  
<span class="line-modified">!     URL parsedURL = context-&gt;completeURL(clientURL);</span>
<span class="line-modified">!     if (!protocolHostAndPortAreEqual(parsedURL, context-&gt;url())) {</span>
          promise-&gt;reject(Exception { SecurityError, &quot;Origin of clientURL is not client&#39;s origin&quot;_s });
          return;
      }
  
<span class="line-modified">!     uint64_t pendingPromiseIdentifier = ++m_lastPendingPromiseIdentifier;</span>
<span class="line-modified">!     auto pendingPromise = makeUnique&lt;PendingPromise&gt;(WTFMove(promise), makePendingActivity(*this));</span>
<span class="line-modified">!     m_pendingPromises.add(pendingPromiseIdentifier, WTFMove(pendingPromise));</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto contextIdentifier = this-&gt;contextIdentifier();</span>
<span class="line-modified">!     callOnMainThread([connection = makeRef(ensureSWClientConnection()), topOrigin = context-&gt;topOrigin().data().isolatedCopy(), parsedURL = parsedURL.isolatedCopy(), contextIdentifier, pendingPromiseIdentifier]() mutable {</span>
<span class="line-modified">!         connection-&gt;matchRegistration(WTFMove(topOrigin), parsedURL, [contextIdentifier, pendingPromiseIdentifier] (auto&amp;&amp; result) mutable {</span>
<span class="line-removed">-             ScriptExecutionContext::postTaskTo(contextIdentifier, [pendingPromiseIdentifier, result = crossThreadCopy(result)](auto&amp; context) mutable {</span>
<span class="line-removed">-                 auto* serviceWorkerContainer = context.serviceWorkerContainer();</span>
<span class="line-removed">-                 if (!serviceWorkerContainer)</span>
<span class="line-removed">-                     return;</span>
<span class="line-removed">-                 if (serviceWorkerContainer-&gt;m_isStopped || !context.sessionID().isValid())</span>
<span class="line-removed">-                     return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 serviceWorkerContainer-&gt;didFinishGetRegistrationRequest(pendingPromiseIdentifier, WTFMove(result));</span>
<span class="line-removed">-             });</span>
          });
      });
  }
  
<span class="line-modified">! void ServiceWorkerContainer::didFinishGetRegistrationRequest(uint64_t pendingPromiseIdentifier, Optional&lt;ServiceWorkerRegistrationData&gt;&amp;&amp; result)</span>
  {
<span class="line-modified">! #ifndef NDEBUG</span>
<span class="line-removed">-     ASSERT(m_creationThread.ptr() == &amp;Thread::current());</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto pendingPromise = m_pendingPromises.take(pendingPromiseIdentifier);</span>
<span class="line-removed">-     if (!pendingPromise)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_isStopped || !scriptExecutionContext()-&gt;sessionID().isValid()) {</span>
<span class="line-removed">-         pendingPromise-&gt;promise-&gt;reject(Exception { InvalidStateError });</span>
          return;
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     if (!result) {</span>
<span class="line-modified">!         pendingPromise-&gt;promise-&gt;resolve();</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     auto registration = ServiceWorkerRegistration::getOrCreate(*scriptExecutionContext(), *this, WTFMove(result.value()));</span>
<span class="line-modified">!     pendingPromise-&gt;promise-&gt;resolve&lt;IDLInterface&lt;ServiceWorkerRegistration&gt;&gt;(WTFMove(registration));</span>
  }
  
<span class="line-modified">! void ServiceWorkerContainer::updateRegistrationState(ServiceWorkerRegistrationIdentifier identifier, ServiceWorkerRegistrationState state, const Optional&lt;ServiceWorkerData&gt;&amp; serviceWorkerData)</span>
  {
      if (m_isStopped)
          return;
  
<span class="line-modified">!     RefPtr&lt;ServiceWorker&gt; serviceWorker;</span>
<span class="line-modified">!     if (serviceWorkerData)</span>
<span class="line-modified">!         serviceWorker = ServiceWorker::getOrCreate(*scriptExecutionContext(), ServiceWorkerData { *serviceWorkerData });</span>
<span class="line-modified">! </span>
<span class="line-removed">-     if (auto* registration = m_registrations.get(identifier))</span>
<span class="line-removed">-         registration-&gt;updateStateFromServer(state, WTFMove(serviceWorker));</span>
  }
  
  void ServiceWorkerContainer::getRegistrations(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
  {
<span class="line-modified">!     auto* context = scriptExecutionContext();</span>
<span class="line-removed">-     if (m_isStopped || !context-&gt;sessionID().isValid()) {</span>
          promise-&gt;reject(Exception { InvalidStateError });
          return;
      }
  
<span class="line-modified">!     uint64_t pendingPromiseIdentifier = ++m_lastPendingPromiseIdentifier;</span>
<span class="line-modified">!     auto pendingPromise = makeUnique&lt;PendingPromise&gt;(WTFMove(promise), makePendingActivity(*this));</span>
<span class="line-modified">!     m_pendingPromises.add(pendingPromiseIdentifier, WTFMove(pendingPromise));</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto contextIdentifier = this-&gt;contextIdentifier();</span>
<span class="line-removed">-     auto contextURL = context-&gt;url();</span>
<span class="line-removed">-     callOnMainThread([connection = makeRef(ensureSWClientConnection()), topOrigin = context-&gt;topOrigin().data().isolatedCopy(), contextURL = contextURL.isolatedCopy(), contextIdentifier, pendingPromiseIdentifier]() mutable {</span>
<span class="line-removed">-         connection-&gt;getRegistrations(WTFMove(topOrigin), contextURL, [contextIdentifier, pendingPromiseIdentifier] (auto&amp;&amp; registrationDatas) mutable {</span>
<span class="line-removed">-             ScriptExecutionContext::postTaskTo(contextIdentifier, [pendingPromiseIdentifier, registrationDatas = crossThreadCopy(registrationDatas)](auto&amp; context) mutable {</span>
<span class="line-removed">-                 auto* serviceWorkerContainer = context.serviceWorkerContainer();</span>
<span class="line-removed">-                 if (!serviceWorkerContainer)</span>
<span class="line-removed">-                     return;</span>
<span class="line-removed">-                 if (serviceWorkerContainer-&gt;m_isStopped || !context.sessionID().isValid())</span>
<span class="line-removed">-                     return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 serviceWorkerContainer-&gt;didFinishGetRegistrationsRequest(pendingPromiseIdentifier, WTFMove(registrationDatas));</span>
              });
          });
      });
  }
  
<span class="line-removed">- void ServiceWorkerContainer::didFinishGetRegistrationsRequest(uint64_t pendingPromiseIdentifier, Vector&lt;ServiceWorkerRegistrationData&gt;&amp;&amp; registrationDatas)</span>
<span class="line-removed">- {</span>
<span class="line-removed">- #ifndef NDEBUG</span>
<span class="line-removed">-     ASSERT(m_creationThread.ptr() == &amp;Thread::current());</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto pendingPromise = m_pendingPromises.take(pendingPromiseIdentifier);</span>
<span class="line-removed">-     if (!pendingPromise)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_isStopped || !scriptExecutionContext()-&gt;sessionID().isValid()) {</span>
<span class="line-removed">-         pendingPromise-&gt;promise-&gt;reject(Exception { InvalidStateError });</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto registrations = WTF::map(WTFMove(registrationDatas), [&amp;] (auto&amp;&amp; registrationData) {</span>
<span class="line-removed">-         return ServiceWorkerRegistration::getOrCreate(*this-&gt;scriptExecutionContext(), *this, WTFMove(registrationData));</span>
<span class="line-removed">-     });</span>
<span class="line-removed">- </span>
<span class="line-removed">-     pendingPromise-&gt;promise-&gt;resolve&lt;IDLSequence&lt;IDLInterface&lt;ServiceWorkerRegistration&gt;&gt;&gt;(WTFMove(registrations));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void ServiceWorkerContainer::startMessages()
  {
  }
  
  void ServiceWorkerContainer::jobFailedWithException(ServiceWorkerJob&amp; job, const Exception&amp; exception)
  {
  #ifndef NDEBUG
<span class="line-new-header">--- 250,88 ---</span>
      auto&amp; jobData = job-&gt;data();
      auto jobIdentifier = job-&gt;identifier();
      ASSERT(!m_jobMap.contains(jobIdentifier));
      m_jobMap.add(jobIdentifier, OngoingJob { WTFMove(job), makePendingActivity(*this) });
  
<span class="line-modified">!     m_swConnection-&gt;scheduleJob(contextIdentifier(), jobData);</span>
  }
  
  void ServiceWorkerContainer::getRegistration(const String&amp; clientURL, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
  {
<span class="line-modified">!     if (m_isStopped) {</span>
          promise-&gt;reject(Exception { InvalidStateError });
          return;
      }
  
<span class="line-modified">!     auto&amp; context = *scriptExecutionContext();</span>
<span class="line-modified">!     URL parsedURL = context.completeURL(clientURL);</span>
<span class="line-added">+     if (!protocolHostAndPortAreEqual(parsedURL, context.url())) {</span>
          promise-&gt;reject(Exception { SecurityError, &quot;Origin of clientURL is not client&#39;s origin&quot;_s });
          return;
      }
  
<span class="line-modified">!     ensureSWClientConnection().matchRegistration(SecurityOriginData { context.topOrigin().data() }, parsedURL, [this, protectedThis = makeRef(*this), promise = WTFMove(promise)](auto&amp;&amp; result) mutable {</span>
<span class="line-modified">!         queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [this, promise = WTFMove(promise), result = WTFMove(result)]() mutable {</span>
<span class="line-modified">!             if (!result) {</span>
<span class="line-modified">!                 promise-&gt;resolve();</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             promise-&gt;resolve&lt;IDLInterface&lt;ServiceWorkerRegistration&gt;&gt;(ServiceWorkerRegistration::getOrCreate(*scriptExecutionContext(), *this, WTFMove(result.value())));</span>
          });
      });
  }
  
<span class="line-modified">! void ServiceWorkerContainer::updateRegistrationState(ServiceWorkerRegistrationIdentifier identifier, ServiceWorkerRegistrationState state, const Optional&lt;ServiceWorkerData&gt;&amp; serviceWorkerData)</span>
  {
<span class="line-modified">!     if (m_isStopped)</span>
          return;
  
<span class="line-modified">!     queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [this, identifier, state, serviceWorkerData = Optional&lt;ServiceWorkerData&gt; { serviceWorkerData }]() mutable {</span>
<span class="line-modified">!         RefPtr&lt;ServiceWorker&gt; serviceWorker;</span>
<span class="line-modified">!         if (serviceWorkerData)</span>
<span class="line-modified">!             serviceWorker = ServiceWorker::getOrCreate(*scriptExecutionContext(), WTFMove(*serviceWorkerData));</span>
  
<span class="line-modified">!         if (auto* registration = m_registrations.get(identifier))</span>
<span class="line-modified">!             registration-&gt;updateStateFromServer(state, WTFMove(serviceWorker));</span>
<span class="line-added">+     });</span>
  }
  
<span class="line-modified">! void ServiceWorkerContainer::updateWorkerState(ServiceWorkerIdentifier identifier, ServiceWorkerState state)</span>
  {
      if (m_isStopped)
          return;
  
<span class="line-modified">!     queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [this, identifier, state] {</span>
<span class="line-modified">!         if (auto* serviceWorker = scriptExecutionContext()-&gt;serviceWorker(identifier))</span>
<span class="line-modified">!             serviceWorker-&gt;updateState(state);</span>
<span class="line-modified">!     });</span>
  }
  
  void ServiceWorkerContainer::getRegistrations(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
  {
<span class="line-modified">!     if (m_isStopped) {</span>
          promise-&gt;reject(Exception { InvalidStateError });
          return;
      }
  
<span class="line-modified">!     auto&amp; context = *scriptExecutionContext();</span>
<span class="line-modified">!     ensureSWClientConnection().getRegistrations(SecurityOriginData { context.topOrigin().data() }, context.url(), [this, protectedThis = makeRef(*this), promise = WTFMove(promise)] (auto&amp;&amp; registrationDatas) mutable {</span>
<span class="line-modified">!         queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [this, promise = WTFMove(promise), registrationDatas = WTFMove(registrationDatas)]() mutable {</span>
<span class="line-modified">!             auto registrations = WTF::map(WTFMove(registrationDatas), [&amp;](auto&amp;&amp; registrationData) {</span>
<span class="line-modified">!                 return ServiceWorkerRegistration::getOrCreate(*scriptExecutionContext(), *this, WTFMove(registrationData));</span>
              });
<span class="line-added">+             promise-&gt;resolve&lt;IDLSequence&lt;IDLInterface&lt;ServiceWorkerRegistration&gt;&gt;&gt;(WTFMove(registrations));</span>
          });
      });
  }
  
  void ServiceWorkerContainer::startMessages()
  {
<span class="line-added">+     m_shouldDeferMessageEvents = false;</span>
<span class="line-added">+     auto deferredMessageEvents = WTFMove(m_deferredMessageEvents);</span>
<span class="line-added">+     for (auto&amp; messageEvent : deferredMessageEvents)</span>
<span class="line-added">+         queueTaskToDispatchEvent(*this, TaskSource::DOMManipulation, WTFMove(messageEvent));</span>
  }
  
  void ServiceWorkerContainer::jobFailedWithException(ServiceWorkerJob&amp; job, const Exception&amp; exception)
  {
  #ifndef NDEBUG
</pre>
<hr />
<pre>
<span class="line-old-header">*** 396,25 ***</span>
  
      auto promise = job.takePromise();
      if (!promise)
          return;
  
<span class="line-modified">!     if (auto* context = scriptExecutionContext()) {</span>
<span class="line-modified">!         context-&gt;postTask([promise = WTFMove(promise), exception](auto&amp;) mutable {</span>
<span class="line-modified">!             promise-&gt;reject(exception);</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-     }</span>
  }
  
<span class="line-modified">! void ServiceWorkerContainer::fireUpdateFoundEvent(ServiceWorkerRegistrationIdentifier identifier)</span>
  {
  #ifndef NDEBUG
      ASSERT(m_creationThread.ptr() == &amp;Thread::current());
  #endif
  
      if (auto* registration = m_registrations.get(identifier))
<span class="line-modified">!         registration-&gt;fireUpdateFoundEvent();</span>
  }
  
  void ServiceWorkerContainer::jobResolvedWithRegistration(ServiceWorkerJob&amp; job, ServiceWorkerRegistrationData&amp;&amp; data, ShouldNotifyWhenResolved shouldNotifyWhenResolved)
  {
  #ifndef NDEBUG
<span class="line-new-header">--- 348,23 ---</span>
  
      auto promise = job.takePromise();
      if (!promise)
          return;
  
<span class="line-modified">!     queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [promise = WTFMove(promise), exception]() mutable {</span>
<span class="line-modified">!         promise-&gt;reject(exception);</span>
<span class="line-modified">!     });</span>
  }
  
<span class="line-modified">! void ServiceWorkerContainer::queueTaskToFireUpdateFoundEvent(ServiceWorkerRegistrationIdentifier identifier)</span>
  {
  #ifndef NDEBUG
      ASSERT(m_creationThread.ptr() == &amp;Thread::current());
  #endif
  
      if (auto* registration = m_registrations.get(identifier))
<span class="line-modified">!         registration-&gt;queueTaskToFireUpdateFoundEvent();</span>
  }
  
  void ServiceWorkerContainer::jobResolvedWithRegistration(ServiceWorkerJob&amp; job, ServiceWorkerRegistrationData&amp;&amp; data, ShouldNotifyWhenResolved shouldNotifyWhenResolved)
  {
  #ifndef NDEBUG
</pre>
<hr />
<pre>
<span class="line-old-header">*** 431,39 ***</span>
  
      auto guard = WTF::makeScopeExit([this, &amp;job] {
          destroyJob(job);
      });
  
<span class="line-modified">!     auto notifyIfExitEarly = WTF::makeScopeExit([this, &amp;data, &amp;shouldNotifyWhenResolved] {</span>
          if (shouldNotifyWhenResolved == ShouldNotifyWhenResolved::Yes)
<span class="line-modified">!             notifyRegistrationIsSettled(data.key);</span>
      });
  
      if (isStopped())
          return;
  
      auto promise = job.takePromise();
      if (!promise)
          return;
  
<span class="line-modified">!     notifyIfExitEarly.release();</span>
  
<span class="line-modified">!     scriptExecutionContext()-&gt;postTask([this, protectedThis = RefPtr&lt;ServiceWorkerContainer&gt;(this), promise = WTFMove(promise), jobIdentifier = job.identifier(), data = WTFMove(data), shouldNotifyWhenResolved](ScriptExecutionContext&amp; context) mutable {</span>
<span class="line-removed">-         if (isStopped() || !context.sessionID().isValid()) {</span>
<span class="line-removed">-             if (shouldNotifyWhenResolved == ShouldNotifyWhenResolved::Yes)</span>
<span class="line-removed">-                 notifyRegistrationIsSettled(data.key);</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto registration = ServiceWorkerRegistration::getOrCreate(context, *this, WTFMove(data));</span>
  
          CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;jobResolvedWithRegistration: Resolving promise for job %&quot; PRIu64 &quot;. Registration ID: %&quot; PRIu64, jobIdentifier.toUInt64(), registration-&gt;identifier().toUInt64());
  
          if (shouldNotifyWhenResolved == ShouldNotifyWhenResolved::Yes) {
              m_ongoingSettledRegistrations.add(++m_lastOngoingSettledRegistrationIdentifier, registration-&gt;data().key);
              promise-&gt;whenSettled([this, protectedThis = WTFMove(protectedThis), identifier = m_lastOngoingSettledRegistrationIdentifier] {
<span class="line-modified">!                 notifyRegistrationIsSettled(m_ongoingSettledRegistrations.take(identifier));</span>
              });
          }
  
          promise-&gt;resolve&lt;IDLInterface&lt;ServiceWorkerRegistration&gt;&gt;(WTFMove(registration));
      });
<span class="line-new-header">--- 381,37 ---</span>
  
      auto guard = WTF::makeScopeExit([this, &amp;job] {
          destroyJob(job);
      });
  
<span class="line-modified">!     auto notifyIfExitEarly = WTF::makeScopeExit([this, protectedThis = makeRef(*this), key = data.key, shouldNotifyWhenResolved] {</span>
          if (shouldNotifyWhenResolved == ShouldNotifyWhenResolved::Yes)
<span class="line-modified">!             notifyRegistrationIsSettled(key);</span>
      });
  
      if (isStopped())
          return;
  
      auto promise = job.takePromise();
      if (!promise)
          return;
  
<span class="line-modified">!     queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [this, protectedThis = makeRef(*this), promise = WTFMove(promise), jobIdentifier = job.identifier(), data = WTFMove(data), shouldNotifyWhenResolved, notifyIfExitEarly = WTFMove(notifyIfExitEarly)]() mutable {</span>
<span class="line-added">+         notifyIfExitEarly.release();</span>
  
<span class="line-modified">!         auto registration = ServiceWorkerRegistration::getOrCreate(*scriptExecutionContext(), *this, WTFMove(data));</span>
  
          CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;jobResolvedWithRegistration: Resolving promise for job %&quot; PRIu64 &quot;. Registration ID: %&quot; PRIu64, jobIdentifier.toUInt64(), registration-&gt;identifier().toUInt64());
  
          if (shouldNotifyWhenResolved == ShouldNotifyWhenResolved::Yes) {
              m_ongoingSettledRegistrations.add(++m_lastOngoingSettledRegistrationIdentifier, registration-&gt;data().key);
              promise-&gt;whenSettled([this, protectedThis = WTFMove(protectedThis), identifier = m_lastOngoingSettledRegistrationIdentifier] {
<span class="line-modified">!                 auto iterator = m_ongoingSettledRegistrations.find(identifier);</span>
<span class="line-added">+                 if (iterator == m_ongoingSettledRegistrations.end())</span>
<span class="line-added">+                     return;</span>
<span class="line-added">+                 notifyRegistrationIsSettled(iterator-&gt;value);</span>
<span class="line-added">+                 m_ongoingSettledRegistrations.remove(iterator);</span>
              });
          }
  
          promise-&gt;resolve&lt;IDLInterface&lt;ServiceWorkerRegistration&gt;&gt;(WTFMove(registration));
      });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 473,18 ***</span>
  {
      auto&amp; context = *scriptExecutionContext();
      MessageEventSource source = RefPtr&lt;ServiceWorker&gt; { ServiceWorker::getOrCreate(context, WTFMove(sourceData)) };
  
      auto messageEvent = MessageEvent::create(MessagePort::entanglePorts(context, WTFMove(message.transferredPorts)), message.message.releaseNonNull(), sourceOrigin, { }, WTFMove(source));
<span class="line-modified">!     dispatchEvent(messageEvent);</span>
  }
  
  void ServiceWorkerContainer::notifyRegistrationIsSettled(const ServiceWorkerRegistrationKey&amp; registrationKey)
  {
<span class="line-modified">!     callOnMainThread([connection = m_swConnection, registrationKey = registrationKey.isolatedCopy()] {</span>
<span class="line-removed">-         connection-&gt;didResolveRegistrationPromise(registrationKey);</span>
<span class="line-removed">-     });</span>
  }
  
  void ServiceWorkerContainer::jobResolvedWithUnregistrationResult(ServiceWorkerJob&amp; job, bool unregistrationResult)
  {
  #ifndef NDEBUG
<span class="line-new-header">--- 421,21 ---</span>
  {
      auto&amp; context = *scriptExecutionContext();
      MessageEventSource source = RefPtr&lt;ServiceWorker&gt; { ServiceWorker::getOrCreate(context, WTFMove(sourceData)) };
  
      auto messageEvent = MessageEvent::create(MessagePort::entanglePorts(context, WTFMove(message.transferredPorts)), message.message.releaseNonNull(), sourceOrigin, { }, WTFMove(source));
<span class="line-modified">!     if (m_shouldDeferMessageEvents)</span>
<span class="line-added">+         m_deferredMessageEvents.append(WTFMove(messageEvent));</span>
<span class="line-added">+     else {</span>
<span class="line-added">+         ASSERT(m_deferredMessageEvents.isEmpty());</span>
<span class="line-added">+         queueTaskToDispatchEvent(*this, TaskSource::DOMManipulation, WTFMove(messageEvent));</span>
<span class="line-added">+     }</span>
  }
  
  void ServiceWorkerContainer::notifyRegistrationIsSettled(const ServiceWorkerRegistrationKey&amp; registrationKey)
  {
<span class="line-modified">!     ensureSWClientConnection().didResolveRegistrationPromise(registrationKey);</span>
  }
  
  void ServiceWorkerContainer::jobResolvedWithUnregistrationResult(ServiceWorkerJob&amp; job, bool unregistrationResult)
  {
  #ifndef NDEBUG
</pre>
<hr />
<pre>
<span class="line-old-header">*** 503,11 ***</span>
      if (!context) {
          LOG_ERROR(&quot;ServiceWorkerContainer::jobResolvedWithUnregistrationResult called but the containers ScriptExecutionContext is gone&quot;);
          return;
      }
  
<span class="line-modified">!     context-&gt;postTask([promise = job.takePromise(), unregistrationResult](auto&amp;) mutable {</span>
          promise-&gt;resolve&lt;IDLBoolean&gt;(unregistrationResult);
      });
  }
  
  void ServiceWorkerContainer::startScriptFetchForJob(ServiceWorkerJob&amp; job, FetchOptions::Cache cachePolicy)
<span class="line-new-header">--- 454,11 ---</span>
      if (!context) {
          LOG_ERROR(&quot;ServiceWorkerContainer::jobResolvedWithUnregistrationResult called but the containers ScriptExecutionContext is gone&quot;);
          return;
      }
  
<span class="line-modified">!     queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [promise = job.takePromise(), unregistrationResult]() mutable {</span>
          promise-&gt;resolve&lt;IDLBoolean&gt;(unregistrationResult);
      });
  }
  
  void ServiceWorkerContainer::startScriptFetchForJob(ServiceWorkerJob&amp; job, FetchOptions::Cache cachePolicy)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 535,13 ***</span>
      ASSERT(m_creationThread.ptr() == &amp;Thread::current());
  #endif
  
      CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;jobFinishedLoadingScript: Successfuly finished fetching script for job %&quot; PRIu64, job.identifier().toUInt64());
  
<span class="line-modified">!     callOnMainThread([connection = m_swConnection, jobDataIdentifier = job.data().identifier(), registrationKey = job.data().registrationKey().isolatedCopy(), script = script.isolatedCopy(), contentSecurityPolicy = contentSecurityPolicy.isolatedCopy(), referrerPolicy = referrerPolicy.isolatedCopy()] {</span>
<span class="line-removed">-         connection-&gt;finishFetchingScriptInServer({ jobDataIdentifier, registrationKey, script, contentSecurityPolicy, referrerPolicy, { } });</span>
<span class="line-removed">-     });</span>
  }
  
  void ServiceWorkerContainer::jobFailedLoadingScript(ServiceWorkerJob&amp; job, const ResourceError&amp; error, Exception&amp;&amp; exception)
  {
  #ifndef NDEBUG
<span class="line-new-header">--- 486,11 ---</span>
      ASSERT(m_creationThread.ptr() == &amp;Thread::current());
  #endif
  
      CONTAINER_RELEASE_LOG_IF_ALLOWED(&quot;jobFinishedLoadingScript: Successfuly finished fetching script for job %&quot; PRIu64, job.identifier().toUInt64());
  
<span class="line-modified">!     ensureSWClientConnection().finishFetchingScriptInServer({ job.data().identifier(), job.data().registrationKey(), script, contentSecurityPolicy, referrerPolicy, { } });</span>
  }
  
  void ServiceWorkerContainer::jobFailedLoadingScript(ServiceWorkerJob&amp; job, const ResourceError&amp; error, Exception&amp;&amp; exception)
  {
  #ifndef NDEBUG
</pre>
<hr />
<pre>
<span class="line-old-header">*** 549,22 ***</span>
  #endif
      ASSERT_WITH_MESSAGE(job.hasPromise() || job.data().type == ServiceWorkerJobType::Update, &quot;Only soft updates have no promise&quot;);
  
      CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;jobFinishedLoadingScript: Failed to fetch script for job %&quot; PRIu64 &quot;, error: %s&quot;, job.identifier().toUInt64(), error.localizedDescription().utf8().data());
  
<span class="line-modified">!     if (auto promise = job.takePromise())</span>
<span class="line-modified">!         promise-&gt;reject(WTFMove(exception));</span>
  
      notifyFailedFetchingScript(job, error);
      destroyJob(job);
  }
  
  void ServiceWorkerContainer::notifyFailedFetchingScript(ServiceWorkerJob&amp; job, const ResourceError&amp; error)
  {
<span class="line-modified">!     callOnMainThread([connection = m_swConnection, jobIdentifier = job.identifier(), registrationKey = job.data().registrationKey().isolatedCopy(), error = error.isolatedCopy()] {</span>
<span class="line-removed">-         connection-&gt;failedFetchingScript(jobIdentifier, registrationKey, error);</span>
<span class="line-removed">-     });</span>
  }
  
  void ServiceWorkerContainer::destroyJob(ServiceWorkerJob&amp; job)
  {
  #ifndef NDEBUG
<span class="line-new-header">--- 498,23 ---</span>
  #endif
      ASSERT_WITH_MESSAGE(job.hasPromise() || job.data().type == ServiceWorkerJobType::Update, &quot;Only soft updates have no promise&quot;);
  
      CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(&quot;jobFinishedLoadingScript: Failed to fetch script for job %&quot; PRIu64 &quot;, error: %s&quot;, job.identifier().toUInt64(), error.localizedDescription().utf8().data());
  
<span class="line-modified">!     if (auto promise = job.takePromise()) {</span>
<span class="line-modified">!         queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [promise = WTFMove(promise), exception = WTFMove(exception)]() mutable {</span>
<span class="line-added">+             promise-&gt;reject(WTFMove(exception));</span>
<span class="line-added">+         });</span>
<span class="line-added">+     }</span>
  
      notifyFailedFetchingScript(job, error);
      destroyJob(job);
  }
  
  void ServiceWorkerContainer::notifyFailedFetchingScript(ServiceWorkerJob&amp; job, const ResourceError&amp; error)
  {
<span class="line-modified">!     ensureSWClientConnection().finishFetchingScriptInServer(serviceWorkerFetchError(job.data().identifier(), ServiceWorkerRegistrationKey { job.data().registrationKey() }, ResourceError { error }));</span>
  }
  
  void ServiceWorkerContainer::destroyJob(ServiceWorkerJob&amp; job)
  {
  #ifndef NDEBUG
</pre>
<hr />
<pre>
<span class="line-old-header">*** 578,24 ***</span>
  const char* ServiceWorkerContainer::activeDOMObjectName() const
  {
      return &quot;ServiceWorkerContainer&quot;;
  }
  
<span class="line-removed">- bool ServiceWorkerContainer::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return !hasPendingActivity();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  SWClientConnection&amp; ServiceWorkerContainer::ensureSWClientConnection()
  {
      ASSERT(scriptExecutionContext());
<span class="line-removed">-     ASSERT(scriptExecutionContext()-&gt;sessionID().isValid());</span>
      if (!m_swConnection) {
<span class="line-modified">!         ASSERT(scriptExecutionContext());</span>
<span class="line-modified">!         callOnMainThreadAndWait([this, sessionID = scriptExecutionContext()-&gt;sessionID()]() {</span>
<span class="line-modified">!             m_swConnection = &amp;ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(sessionID);</span>
<span class="line-modified">!         });</span>
      }
      return *m_swConnection;
  }
  
  void ServiceWorkerContainer::addRegistration(ServiceWorkerRegistration&amp; registration)
<span class="line-new-header">--- 528,19 ---</span>
  const char* ServiceWorkerContainer::activeDOMObjectName() const
  {
      return &quot;ServiceWorkerContainer&quot;;
  }
  
  SWClientConnection&amp; ServiceWorkerContainer::ensureSWClientConnection()
  {
      ASSERT(scriptExecutionContext());
      if (!m_swConnection) {
<span class="line-modified">!         auto&amp; context = *scriptExecutionContext();</span>
<span class="line-modified">!         if (is&lt;WorkerGlobalScope&gt;(context))</span>
<span class="line-modified">!             m_swConnection = &amp;downcast&lt;WorkerGlobalScope&gt;(context).swClientConnection();</span>
<span class="line-modified">!         else</span>
<span class="line-added">+             m_swConnection = &amp;mainThreadConnection();</span>
      }
      return *m_swConnection;
  }
  
  void ServiceWorkerContainer::addRegistration(ServiceWorkerRegistration&amp; registration)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 616,27 ***</span>
  
      m_swConnection-&gt;removeServiceWorkerRegistrationInServer(registration.identifier());
      m_registrations.remove(registration.identifier());
  }
  
<span class="line-modified">! void ServiceWorkerContainer::fireControllerChangeEvent()</span>
  {
  #ifndef NDEBUG
      ASSERT(m_creationThread.ptr() == &amp;Thread::current());
  #endif
  
<span class="line-modified">!     if (m_isStopped)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     dispatchEvent(Event::create(eventNames().controllerchangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
  }
  
  void ServiceWorkerContainer::stop()
  {
      m_isStopped = true;
      removeAllEventListeners();
<span class="line-removed">-     m_pendingPromises.clear();</span>
      m_readyPromise = nullptr;
      auto jobMap = WTFMove(m_jobMap);
      for (auto&amp; ongoingJob : jobMap.values()) {
          if (ongoingJob.job-&gt;cancelPendingLoad())
              notifyFailedFetchingScript(*ongoingJob.job.get(), ResourceError { errorDomainWebKitInternal, 0, ongoingJob.job-&gt;data().scriptURL, &quot;Job cancelled&quot;_s, ResourceError::Type::Cancellation });
<span class="line-new-header">--- 561,23 ---</span>
  
      m_swConnection-&gt;removeServiceWorkerRegistrationInServer(registration.identifier());
      m_registrations.remove(registration.identifier());
  }
  
<span class="line-modified">! void ServiceWorkerContainer::queueTaskToDispatchControllerChangeEvent()</span>
  {
  #ifndef NDEBUG
      ASSERT(m_creationThread.ptr() == &amp;Thread::current());
  #endif
  
<span class="line-modified">!     queueTaskToDispatchEvent(*this, TaskSource::DOMManipulation, Event::create(eventNames().controllerchangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
  }
  
  void ServiceWorkerContainer::stop()
  {
      m_isStopped = true;
      removeAllEventListeners();
      m_readyPromise = nullptr;
      auto jobMap = WTFMove(m_jobMap);
      for (auto&amp; ongoingJob : jobMap.values()) {
          if (ongoingJob.job-&gt;cancelPendingLoad())
              notifyFailedFetchingScript(*ongoingJob.job.get(), ResourceError { errorDomainWebKitInternal, 0, ongoingJob.job-&gt;data().scriptURL, &quot;Job cancelled&quot;_s, ResourceError::Type::Cancellation });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 671,15 ***</span>
  {
      auto* context = scriptExecutionContext();
      if (!context)
          return false;
  
<span class="line-modified">!     if (is&lt;Document&gt;(*context))</span>
<span class="line-modified">!         return downcast&lt;Document&gt;(*context).sessionID().isAlwaysOnLoggingAllowed();</span>
  
      // FIXME: No logging inside service workers for now.
      return false;
  }
  
  } // namespace WebCore
  
  #endif // ENABLE(SERVICE_WORKER)
<span class="line-new-header">--- 612,27 ---</span>
  {
      auto* context = scriptExecutionContext();
      if (!context)
          return false;
  
<span class="line-modified">!     if (is&lt;Document&gt;(*context)) {</span>
<span class="line-modified">!         auto* page = downcast&lt;Document&gt;(*context).page();</span>
<span class="line-added">+         return page &amp;&amp; page-&gt;sessionID().isAlwaysOnLoggingAllowed();</span>
<span class="line-added">+     }</span>
  
      // FIXME: No logging inside service workers for now.
      return false;
  }
  
<span class="line-added">+ bool ServiceWorkerContainer::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; eventListener, const AddEventListenerOptions&amp; options)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // Setting the onmessage EventHandler attribute on the ServiceWorkerContainer should start the messages</span>
<span class="line-added">+     // automatically.</span>
<span class="line-added">+     if (eventListener-&gt;isAttribute() &amp;&amp; eventType == eventNames().messageEvent)</span>
<span class="line-added">+         startMessages();</span>
<span class="line-added">+ </span>
<span class="line-added">+     return EventTargetWithInlineData::addEventListener(eventType, WTFMove(eventListener), options);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  } // namespace WebCore
  
  #endif // ENABLE(SERVICE_WORKER)
</pre>
<center><a href="ServiceWorkerClient.idl.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ServiceWorkerContainer.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
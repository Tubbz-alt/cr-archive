<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilderMultiColumn.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2007 David Smith (catfish.man@gmail.com)
  5  * Copyright (C) 2003-2015, 2017 Apple Inc. All rights reserved.
  6  * Copyright (C) Research In Motion Limited 2010. All rights reserved.
  7  *
  8  * This library is free software; you can redistribute it and/or
  9  * modify it under the terms of the GNU Library General Public
 10  * License as published by the Free Software Foundation; either
 11  * version 2 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;RenderTreeBuilderMultiColumn.h&quot;
 26 
 27 #include &quot;RenderBlockFlow.h&quot;
 28 #include &quot;RenderChildIterator.h&quot;
 29 #include &quot;RenderMultiColumnFlow.h&quot;
 30 #include &quot;RenderMultiColumnSet.h&quot;
 31 #include &quot;RenderMultiColumnSpannerPlaceholder.h&quot;
 32 #include &quot;RenderTreeBuilder.h&quot;
 33 #include &quot;RenderTreeBuilderBlock.h&quot;
 34 #include &quot;RenderView.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 static RenderMultiColumnSet* findSetRendering(const RenderMultiColumnFlow&amp; fragmentedFlow, const RenderObject&amp; renderer)
 39 {
 40     // Find the set inside which the specified renderer would be rendered.
 41     for (auto* multicolSet = fragmentedFlow.firstMultiColumnSet(); multicolSet; multicolSet = multicolSet-&gt;nextSiblingMultiColumnSet()) {
 42         if (multicolSet-&gt;containsRendererInFragmentedFlow(renderer))
 43             return multicolSet;
 44     }
 45     return nullptr;
 46 }
 47 
 48 static RenderObject* spannerPlacehoderCandidate(const RenderObject&amp; renderer, const RenderMultiColumnFlow&amp; stayWithin)
 49 {
 50     // Spanner candidate is a next sibling/ancestor&#39;s next child within the flow thread and
 51     // it is in the same inflow/out-of-flow layout context.
 52     if (renderer.isOutOfFlowPositioned())
 53         return nullptr;
 54 
 55     ASSERT(renderer.isDescendantOf(&amp;stayWithin));
 56     auto* current = &amp;renderer;
 57     while (true) {
 58         // Skip to the first in-flow sibling.
 59         auto* nextSibling = current-&gt;nextSibling();
 60         while (nextSibling &amp;&amp; nextSibling-&gt;isOutOfFlowPositioned())
 61             nextSibling = nextSibling-&gt;nextSibling();
 62         if (nextSibling)
 63             return nextSibling;
 64         // No sibling candidate, jump to the parent and check its siblings.
 65         current = current-&gt;parent();
 66         if (!current || current == &amp;stayWithin || current-&gt;isOutOfFlowPositioned())
 67             return nullptr;
 68     }
 69     return nullptr;
 70 }
 71 
 72 static bool isValidColumnSpanner(const RenderMultiColumnFlow&amp; fragmentedFlow, const RenderObject&amp; descendant)
 73 {
 74     // We assume that we&#39;re inside the flow thread. This function is not to be called otherwise.
 75     ASSERT(descendant.isDescendantOf(&amp;fragmentedFlow));
 76     // First make sure that the renderer itself has the right properties for becoming a spanner.
 77     if (!is&lt;RenderBox&gt;(descendant))
 78         return false;
 79 
 80     auto&amp; descendantBox = downcast&lt;RenderBox&gt;(descendant);
 81     if (descendantBox.isFloatingOrOutOfFlowPositioned())
 82         return false;
 83 
 84     if (descendantBox.style().columnSpan() != ColumnSpan::All)
 85         return false;
 86 
 87     auto* parent = descendantBox.parent();
 88     if (!is&lt;RenderBlockFlow&gt;(*parent) || parent-&gt;childrenInline()) {
 89         // Needs to be block-level.
 90         return false;
 91     }
 92 
 93     // We need to have the flow thread as the containing block. A spanner cannot break out of the flow thread.
 94     auto* enclosingFragmentedFlow = descendantBox.enclosingFragmentedFlow();
 95     if (enclosingFragmentedFlow != &amp;fragmentedFlow)
 96         return false;
 97 
 98     // This looks like a spanner, but if we&#39;re inside something unbreakable, it&#39;s not to be treated as one.
 99     for (auto* ancestor = descendantBox.containingBlock(); ancestor; ancestor = ancestor-&gt;containingBlock()) {
100         if (is&lt;RenderView&gt;(*ancestor))
101             return false;
102         if (is&lt;RenderFragmentedFlow&gt;(*ancestor)) {
103             // Don&#39;t allow any intervening non-multicol fragmentation contexts. The spec doesn&#39;t say
104             // anything about disallowing this, but it&#39;s just going to be too complicated to
105             // implement (not to mention specify behavior).
106             return ancestor == &amp;fragmentedFlow;
107         }
108         // This ancestor (descendent of the fragmentedFlow) will create columns later. The spanner belongs to it.
109         if (is&lt;RenderBlockFlow&gt;(*ancestor) &amp;&amp; downcast&lt;RenderBlockFlow&gt;(*ancestor).willCreateColumns())
110             return false;
111         ASSERT(ancestor-&gt;style().columnSpan() != ColumnSpan::All || !isValidColumnSpanner(fragmentedFlow, *ancestor));
112         if (ancestor-&gt;isUnsplittableForPagination())
113             return false;
114     }
115     ASSERT_NOT_REACHED();
116     return false;
117 }
118 
119 RenderTreeBuilder::MultiColumn::MultiColumn(RenderTreeBuilder&amp; builder)
120     : m_builder(builder)
121 {
122 }
123 
124 void RenderTreeBuilder::MultiColumn::updateAfterDescendants(RenderBlockFlow&amp; flow)
125 {
126     bool needsFragmentedFlow = flow.requiresColumns(flow.style().columnCount());
127     bool hasFragmentedFlow = flow.multiColumnFlow();
128 
129     if (!hasFragmentedFlow &amp;&amp; needsFragmentedFlow) {
130         createFragmentedFlow(flow);
131         return;
132     }
133     if (hasFragmentedFlow &amp;&amp; !needsFragmentedFlow) {
134         destroyFragmentedFlow(flow);
135         return;
136     }
137 }
138 
139 void RenderTreeBuilder::MultiColumn::createFragmentedFlow(RenderBlockFlow&amp; flow)
140 {
141     flow.setChildrenInline(false); // Do this to avoid wrapping inline children that are just going to move into the flow thread.
142     flow.deleteLines();
143     // If this soon-to-be multicolumn flow is already part of a multicolumn context, we need to move back the descendant spanners
144     // to their original position before moving subtrees around.
145     auto* enclosingflow = flow.enclosingFragmentedFlow();
146     if (is&lt;RenderMultiColumnFlow&gt;(enclosingflow)) {
147         auto&amp; spanners = downcast&lt;RenderMultiColumnFlow&gt;(enclosingflow)-&gt;spannerMap();
148         Vector&lt;RenderMultiColumnSpannerPlaceholder*&gt; placeholdersToDelete;
149         for (auto&amp; spannerAndPlaceholder : spanners) {
150             auto&amp; placeholder = *spannerAndPlaceholder.value;
151             if (!placeholder.isDescendantOf(&amp;flow))
152                 continue;
153             placeholdersToDelete.append(&amp;placeholder);
154         }
155         for (auto* placeholder : placeholdersToDelete) {
156             auto* spanner = placeholder-&gt;spanner();
157             if (!spanner) {
158                 ASSERT_NOT_REACHED();
159                 continue;
160             }
161             // Move the spanner back to its original position.
162             auto&amp; spannerOriginalParent = *placeholder-&gt;parent();
163             // Detaching the spanner takes care of removing the placeholder (and merges the RenderMultiColumnSets).
164             auto spannerToReInsert = m_builder.detach(*spanner-&gt;parent(), *spanner);
165             m_builder.attach(spannerOriginalParent, WTFMove(spannerToReInsert));
166         }
167     }
168 
169     auto newFragmentedFlow = WebCore::createRenderer&lt;RenderMultiColumnFlow&gt;(flow.document(), RenderStyle::createAnonymousStyleWithDisplay(flow.style(), DisplayType::Block));
170     newFragmentedFlow-&gt;initializeStyle();
171     auto&amp; fragmentedFlow = *newFragmentedFlow;
172     m_builder.blockBuilder().attach(flow, WTFMove(newFragmentedFlow), nullptr);
173 
174     // Reparent children preceding the fragmented flow into the fragmented flow.
175     m_builder.moveChildren(flow, fragmentedFlow, flow.firstChild(), &amp;fragmentedFlow, RenderTreeBuilder::NormalizeAfterInsertion::Yes);
176     if (flow.isFieldset()) {
177         // Keep legends out of the flow thread.
178         for (auto&amp; box : childrenOfType&lt;RenderBox&gt;(fragmentedFlow)) {
179             if (box.isLegend())
180                 m_builder.move(fragmentedFlow, flow, box, RenderTreeBuilder::NormalizeAfterInsertion::Yes);
181         }
182     }
183 
184     flow.setMultiColumnFlow(fragmentedFlow);
185 }
186 
187 void RenderTreeBuilder::MultiColumn::destroyFragmentedFlow(RenderBlockFlow&amp; flow)
188 {
189     auto&amp; multiColumnFlow = *flow.multiColumnFlow();
190     multiColumnFlow.deleteLines();
191 
192     // Move spanners back to their original DOM position in the tree, and destroy the placeholders.
193     auto&amp; spanners = multiColumnFlow.spannerMap();
194     Vector&lt;RenderMultiColumnSpannerPlaceholder*&gt; placeholdersToDelete;
195     for (auto&amp; spannerAndPlaceholder : spanners)
196         placeholdersToDelete.append(spannerAndPlaceholder.value.get());
197     Vector&lt;std::pair&lt;RenderElement*, RenderPtr&lt;RenderObject&gt;&gt;&gt; parentAndSpannerList;
198     for (auto* placeholder : placeholdersToDelete) {
199         auto* spannerOriginalParent = placeholder-&gt;parent();
200         if (spannerOriginalParent == &amp;multiColumnFlow)
201             spannerOriginalParent = &amp;flow;
202         // Detaching the spanner takes care of removing the placeholder (and merges the RenderMultiColumnSets).
203         auto* spanner = placeholder-&gt;spanner();
204         parentAndSpannerList.append(std::make_pair(spannerOriginalParent, m_builder.detach(*spanner-&gt;parent(), *spanner)));
205     }
206     while (auto* columnSet = multiColumnFlow.firstMultiColumnSet())
207         m_builder.destroy(*columnSet);
208 
209     flow.clearMultiColumnFlow();
210     m_builder.moveAllChildren(multiColumnFlow, flow, RenderTreeBuilder::NormalizeAfterInsertion::Yes);
211     m_builder.destroy(multiColumnFlow);
212     for (auto&amp; parentAndSpanner : parentAndSpannerList)
213         m_builder.attach(*parentAndSpanner.first, WTFMove(parentAndSpanner.second));
214 }
215 
216 
217 RenderObject* RenderTreeBuilder::MultiColumn::resolveMovedChild(RenderFragmentedFlow&amp; enclosingFragmentedFlow, RenderObject* beforeChild)
218 {
219     if (!beforeChild)
220         return nullptr;
221 
222     if (!is&lt;RenderBox&gt;(*beforeChild))
223         return beforeChild;
224 
225     if (!is&lt;RenderMultiColumnFlow&gt;(enclosingFragmentedFlow))
226         return beforeChild;
227 
228     // We only need to resolve for column spanners.
229     if (beforeChild-&gt;style().columnSpan() != ColumnSpan::All)
230         return beforeChild;
231 
232     // The renderer for the actual DOM node that establishes a spanner is moved from its original
233     // location in the render tree to becoming a sibling of the column sets. In other words, it&#39;s
234     // moved out from the flow thread (and becomes a sibling of it). When we for instance want to
235     // create and insert a renderer for the sibling node immediately preceding the spanner, we need
236     // to map that spanner renderer to the spanner&#39;s placeholder, which is where the new inserted
237     // renderer belongs.
238     if (auto* placeholder = downcast&lt;RenderMultiColumnFlow&gt;(enclosingFragmentedFlow).findColumnSpannerPlaceholder(downcast&lt;RenderBox&gt;(beforeChild)))
239         return placeholder;
240 
241     // This is an invalid spanner, or its placeholder hasn&#39;t been created yet. This happens when
242     // moving an entire subtree into the flow thread, when we are processing the insertion of this
243     // spanner&#39;s preceding sibling, and we obviously haven&#39;t got as far as processing this spanner
244     // yet.
245     return beforeChild;
246 }
247 
248 static bool gShiftingSpanner = false;
249 
250 void RenderTreeBuilder::MultiColumn::multiColumnDescendantInserted(RenderMultiColumnFlow&amp; flow, RenderObject&amp; newDescendant)
251 {
252     if (gShiftingSpanner || newDescendant.isInFlowRenderFragmentedFlow())
253         return;
254 
255     auto* subtreeRoot = &amp;newDescendant;
256     auto* descendant = subtreeRoot;
257     while (descendant) {
258         // Skip nested multicolumn flows.
259         if (is&lt;RenderMultiColumnFlow&gt;(*descendant)) {
260             descendant = descendant-&gt;nextSibling();
261             continue;
262         }
263         if (is&lt;RenderMultiColumnSpannerPlaceholder&gt;(*descendant)) {
264             // A spanner&#39;s placeholder has been inserted. The actual spanner renderer is moved from
265             // where it would otherwise occur (if it weren&#39;t a spanner) to becoming a sibling of the
266             // column sets.
267             RenderMultiColumnSpannerPlaceholder&amp; placeholder = downcast&lt;RenderMultiColumnSpannerPlaceholder&gt;(*descendant);
268             ASSERT(!flow.spannerMap().get(placeholder.spanner()));
269             flow.spannerMap().add(placeholder.spanner(), makeWeakPtr(downcast&lt;RenderMultiColumnSpannerPlaceholder&gt;(descendant)));
270             ASSERT(!placeholder.firstChild()); // There should be no children here, but if there are, we ought to skip them.
271         } else
272             descendant = processPossibleSpannerDescendant(flow, subtreeRoot, *descendant);
273         if (descendant)
274             descendant = descendant-&gt;nextInPreOrder(subtreeRoot);
275     }
276 }
277 
278 RenderObject* RenderTreeBuilder::MultiColumn::processPossibleSpannerDescendant(RenderMultiColumnFlow&amp; flow, RenderObject*&amp; subtreeRoot, RenderObject&amp; descendant)
279 {
280     RenderBlockFlow* multicolContainer = flow.multiColumnBlockFlow();
281     RenderObject* nextRendererInFragmentedFlow = spannerPlacehoderCandidate(descendant, flow);
282     RenderObject* insertBeforeMulticolChild = nullptr;
283     RenderObject* nextDescendant = &amp;descendant;
284 
285     if (!multicolContainer)
286         return nullptr;
287 
288     if (isValidColumnSpanner(flow, descendant)) {
289         // This is a spanner (column-span:all). Such renderers are moved from where they would
290         // otherwise occur in the render tree to becoming a direct child of the multicol container,
291         // so that they live among the column sets. This simplifies the layout implementation, and
292         // basically just relies on regular block layout done by the RenderBlockFlow that
293         // establishes the multicol container.
294         RenderBlockFlow* container = downcast&lt;RenderBlockFlow&gt;(descendant.parent());
295         RenderMultiColumnSet* setToSplit = nullptr;
296         if (nextRendererInFragmentedFlow) {
297             setToSplit = findSetRendering(flow, descendant);
298             if (setToSplit) {
299                 setToSplit-&gt;setNeedsLayout();
300                 insertBeforeMulticolChild = setToSplit-&gt;nextSibling();
301             }
302         }
303         // Moving a spanner&#39;s renderer so that it becomes a sibling of the column sets requires us
304         // to insert an anonymous placeholder in the tree where the spanner&#39;s renderer otherwise
305         // would have been. This is needed for a two reasons: We need a way of separating inline
306         // content before and after the spanner, so that it becomes separate line boxes. Secondly,
307         // this placeholder serves as a break point for column sets, so that, when encountered, we
308         // end flowing one column set and move to the next one.
309         auto newPlaceholder = RenderMultiColumnSpannerPlaceholder::createAnonymous(flow, downcast&lt;RenderBox&gt;(descendant), container-&gt;style());
310         auto&amp; placeholder = *newPlaceholder;
311         m_builder.attach(*container, WTFMove(newPlaceholder), descendant.nextSibling());
312         auto takenDescendant = m_builder.detach(*container, descendant);
313 
314         // This is a guard to stop an ancestor flow thread from processing the spanner.
315         gShiftingSpanner = true;
316         m_builder.blockBuilder().attach(*multicolContainer, WTFMove(takenDescendant), insertBeforeMulticolChild);
317         gShiftingSpanner = false;
318 
319         // The spanner has now been moved out from the flow thread, but we don&#39;t want to
320         // examine its children anyway. They are all part of the spanner and shouldn&#39;t trigger
321         // creation of column sets or anything like that. Continue at its original position in
322         // the tree, i.e. where the placeholder was just put.
323         if (subtreeRoot == &amp;descendant)
324             subtreeRoot = &amp;placeholder;
325         nextDescendant = &amp;placeholder;
326     } else {
327         // This is regular multicol content, i.e. not part of a spanner.
328         if (is&lt;RenderMultiColumnSpannerPlaceholder&gt;(nextRendererInFragmentedFlow)) {
329             // Inserted right before a spanner. Is there a set for us there?
330             RenderMultiColumnSpannerPlaceholder&amp; placeholder = downcast&lt;RenderMultiColumnSpannerPlaceholder&gt;(*nextRendererInFragmentedFlow);
331             if (RenderObject* previous = placeholder.spanner()-&gt;previousSibling()) {
332                 if (is&lt;RenderMultiColumnSet&gt;(*previous))
333                     return nextDescendant; // There&#39;s already a set there. Nothing to do.
334             }
335             insertBeforeMulticolChild = placeholder.spanner();
336         } else if (RenderMultiColumnSet* lastSet = flow.lastMultiColumnSet()) {
337             // This child is not an immediate predecessor of a spanner, which means that if this
338             // child precedes a spanner at all, there has to be a column set created for us there
339             // already. If it doesn&#39;t precede any spanner at all, on the other hand, we need a
340             // column set at the end of the multicol container. We don&#39;t really check here if the
341             // child inserted precedes any spanner or not (as that&#39;s an expensive operation). Just
342             // make sure we have a column set at the end. It&#39;s no big deal if it remains unused.
343             if (!lastSet-&gt;nextSibling())
344                 return nextDescendant;
345         }
346     }
347     // Need to create a new column set when there&#39;s no set already created. We also always insert
348     // another column set after a spanner. Even if it turns out that there are no renderers
349     // following the spanner, there may be bottom margins there, which take up space.
350     auto newSet = createRenderer&lt;RenderMultiColumnSet&gt;(flow, RenderStyle::createAnonymousStyleWithDisplay(multicolContainer-&gt;style(), DisplayType::Block));
351     newSet-&gt;initializeStyle();
352     auto&amp; set = *newSet;
353     m_builder.blockBuilder().attach(*multicolContainer, WTFMove(newSet), insertBeforeMulticolChild);
354     flow.invalidateFragments();
355 
356     // We cannot handle immediate column set siblings at the moment (and there&#39;s no need for
357     // it, either). There has to be at least one spanner separating them.
358     ASSERT_UNUSED(set, !RenderMultiColumnFlow::previousColumnSetOrSpannerSiblingOf(&amp;set)
359         || !RenderMultiColumnFlow::previousColumnSetOrSpannerSiblingOf(&amp;set)-&gt;isRenderMultiColumnSet());
360     ASSERT(!RenderMultiColumnFlow::nextColumnSetOrSpannerSiblingOf(&amp;set)
361         || !RenderMultiColumnFlow::nextColumnSetOrSpannerSiblingOf(&amp;set)-&gt;isRenderMultiColumnSet());
362 
363     return nextDescendant;
364 }
365 
366 void RenderTreeBuilder::MultiColumn::handleSpannerRemoval(RenderMultiColumnFlow&amp; flow, RenderObject&amp; spanner)
367 {
368     // The placeholder may already have been removed, but if it hasn&#39;t, do so now.
369     if (auto placeholder = flow.spannerMap().take(&amp;downcast&lt;RenderBox&gt;(spanner)))
370         m_builder.destroy(*placeholder);
371 
372     if (auto* next = spanner.nextSibling()) {
373         if (auto* previous = spanner.previousSibling()) {
374             if (previous-&gt;isRenderMultiColumnSet() &amp;&amp; next-&gt;isRenderMultiColumnSet()) {
375                 // Merge two sets that no longer will be separated by a spanner.
376                 m_builder.destroy(*next);
377                 previous-&gt;setNeedsLayout();
378             }
379         }
380     }
381 }
382 
383 void RenderTreeBuilder::MultiColumn::multiColumnRelativeWillBeRemoved(RenderMultiColumnFlow&amp; flow, RenderObject&amp; relative)
384 {
385     flow.invalidateFragments();
386     if (is&lt;RenderMultiColumnSpannerPlaceholder&gt;(relative)) {
387         // Remove the map entry for this spanner, but leave the actual spanner renderer alone. Also
388         // keep the reference to the spanner, since the placeholder may be about to be re-inserted
389         // in the tree.
390         ASSERT(relative.isDescendantOf(&amp;flow));
391         flow.spannerMap().remove(downcast&lt;RenderMultiColumnSpannerPlaceholder&gt;(relative).spanner());
392         return;
393     }
394     if (relative.style().columnSpan() == ColumnSpan::All) {
395         if (relative.parent() != flow.parent())
396             return; // not a valid spanner.
397 
398         handleSpannerRemoval(flow, relative);
399     }
400     // Note that we might end up with empty column sets if all column content is removed. That&#39;s no
401     // big deal though (and locating them would be expensive), and they will be found and re-used if
402     // content is added again later.
403 }
404 
405 RenderObject* RenderTreeBuilder::MultiColumn::adjustBeforeChildForMultiColumnSpannerIfNeeded(RenderObject&amp; beforeChild)
406 {
407     if (!is&lt;RenderBox&gt;(beforeChild))
408         return &amp;beforeChild;
409 
410     auto* nextSibling = beforeChild.nextSibling();
411     if (!nextSibling)
412         return &amp;beforeChild;
413 
414     if (!is&lt;RenderMultiColumnSet&gt;(*nextSibling))
415         return &amp;beforeChild;
416 
417     auto* multiColumnFlow = downcast&lt;RenderMultiColumnSet&gt;(*nextSibling).multiColumnFlow();
418     if (!multiColumnFlow)
419         return &amp;beforeChild;
420 
421     return multiColumnFlow-&gt;findColumnSpannerPlaceholder(downcast&lt;RenderBox&gt;(&amp;beforeChild));
422 }
423 
424 }
    </pre>
  </body>
</html>
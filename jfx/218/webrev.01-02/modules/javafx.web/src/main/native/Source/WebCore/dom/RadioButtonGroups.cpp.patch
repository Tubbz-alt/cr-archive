diff a/modules/javafx.web/src/main/native/Source/WebCore/dom/RadioButtonGroups.cpp b/modules/javafx.web/src/main/native/Source/WebCore/dom/RadioButtonGroups.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/dom/RadioButtonGroups.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/dom/RadioButtonGroups.cpp
@@ -21,62 +21,67 @@
 #include "config.h"
 #include "RadioButtonGroups.h"
 
 #include "HTMLInputElement.h"
 #include "Range.h"
-#include <wtf/HashSet.h>
+#include <wtf/WeakHashSet.h>
+#include <wtf/WeakPtr.h>
 
 namespace WebCore {
 
 class RadioButtonGroup {
     WTF_MAKE_FAST_ALLOCATED;
 public:
-    bool isEmpty() const { return m_members.isEmpty(); }
+    bool isEmpty() const { return m_members.computesEmpty(); }
     bool isRequired() const { return m_requiredCount; }
-    HTMLInputElement* checkedButton() const { return m_checkedButton; }
+    RefPtr<HTMLInputElement> checkedButton() const { return m_checkedButton.get(); }
     void add(HTMLInputElement&);
     void updateCheckedState(HTMLInputElement&);
     void requiredStateChanged(HTMLInputElement&);
     void remove(HTMLInputElement&);
     bool contains(HTMLInputElement&) const;
-    Vector<HTMLInputElement*> members() const;
+    Vector<Ref<HTMLInputElement>> members() const;
 
 private:
     void setNeedsStyleRecalcForAllButtons();
     void updateValidityForAllButtons();
     bool isValid() const;
     void setCheckedButton(HTMLInputElement*);
 
-    HashSet<HTMLInputElement*> m_members;
-    HTMLInputElement* m_checkedButton { nullptr };
+    WeakHashSet<HTMLInputElement> m_members;
+    WeakPtr<HTMLInputElement> m_checkedButton;
     size_t m_requiredCount { 0 };
 };
 
 inline bool RadioButtonGroup::isValid() const
 {
     return !isRequired() || m_checkedButton;
 }
 
-Vector<HTMLInputElement*> RadioButtonGroup::members() const
+Vector<Ref<HTMLInputElement>> RadioButtonGroup::members() const
 {
-    auto members = copyToVector(m_members);
-    std::sort(members.begin(), members.end(), documentOrderComparator);
-    return members;
+    Vector<Ref<HTMLInputElement>> sortedMembers;
+    for (auto& memeber : m_members)
+        sortedMembers.append(memeber);
+    std::sort(sortedMembers.begin(), sortedMembers.end(), [](auto& a, auto& b) {
+        return documentOrderComparator(a.ptr(), b.ptr());
+    });
+    return sortedMembers;
 }
 
 void RadioButtonGroup::setCheckedButton(HTMLInputElement* button)
 {
-    RefPtr<HTMLInputElement> oldCheckedButton = m_checkedButton;
+    RefPtr<HTMLInputElement> oldCheckedButton = m_checkedButton.get();
     if (oldCheckedButton == button)
         return;
 
-    bool hadCheckedButton = m_checkedButton;
+    bool hadCheckedButton = m_checkedButton.get();
     bool willHaveCheckedButton = button;
     if (hadCheckedButton != willHaveCheckedButton)
         setNeedsStyleRecalcForAllButtons();
 
-    m_checkedButton = button;
+    m_checkedButton = makeWeakPtr(button);
     if (oldCheckedButton)
         oldCheckedButton->setChecked(false);
 }
 
 void RadioButtonGroup::add(HTMLInputElement& button)
@@ -101,11 +106,11 @@
 }
 
 void RadioButtonGroup::updateCheckedState(HTMLInputElement& button)
 {
     ASSERT(button.isRadioButton());
-    ASSERT(m_members.contains(&button));
+    ASSERT(m_members.contains(button));
     bool wasValid = isValid();
     if (button.checked())
         setCheckedButton(&button);
     else {
         if (m_checkedButton == &button)
@@ -116,11 +121,11 @@
 }
 
 void RadioButtonGroup::requiredStateChanged(HTMLInputElement& button)
 {
     ASSERT(button.isRadioButton());
-    ASSERT(m_members.contains(&button));
+    ASSERT(m_members.contains(button));
     bool wasValid = isValid();
     if (button.isRequired())
         ++m_requiredCount;
     else {
         ASSERT(m_requiredCount);
@@ -131,16 +136,15 @@
 }
 
 void RadioButtonGroup::remove(HTMLInputElement& button)
 {
     ASSERT(button.isRadioButton());
-    auto it = m_members.find(&button);
-    if (it == m_members.end())
+    if (!m_members.contains(button))
         return;
 
     bool wasValid = isValid();
-    m_members.remove(it);
+    m_members.remove(button);
     if (button.isRequired()) {
         ASSERT(m_requiredCount);
         --m_requiredCount;
     }
     if (m_checkedButton) {
@@ -149,11 +153,11 @@
             m_checkedButton = nullptr;
             setNeedsStyleRecalcForAllButtons();
         }
     }
 
-    if (m_members.isEmpty()) {
+    if (m_members.computesEmpty()) {
         ASSERT(!m_requiredCount);
         ASSERT(!m_checkedButton);
     } else if (wasValid != isValid())
         updateValidityForAllButtons();
     if (!wasValid) {
@@ -164,26 +168,26 @@
 }
 
 void RadioButtonGroup::setNeedsStyleRecalcForAllButtons()
 {
     for (auto& button : m_members) {
-        ASSERT(button->isRadioButton());
-        button->invalidateStyleForSubtree();
+        ASSERT(button.isRadioButton());
+        button.invalidateStyleForSubtree();
     }
 }
 
 void RadioButtonGroup::updateValidityForAllButtons()
 {
     for (auto& button : m_members) {
-        ASSERT(button->isRadioButton());
-        button->updateValidity();
+        ASSERT(button.isRadioButton());
+        button.updateValidity();
     }
 }
 
 bool RadioButtonGroup::contains(HTMLInputElement& button) const
 {
-    return m_members.contains(&button);
+    return m_members.contains(button);
 }
 
 // ----------------------------------------------------------------
 
 // Explicitly define default constructor and destructor here outside the header
@@ -195,110 +199,89 @@
 {
     ASSERT(element.isRadioButton());
     if (element.name().isEmpty())
         return;
 
-    if (!m_nameToGroupMap)
-        m_nameToGroupMap = makeUnique<NameToGroupMap>();
-
-    auto& group = m_nameToGroupMap->add(element.name().impl(), nullptr).iterator->value;
+    auto& group = m_nameToGroupMap.add(element.name().impl(), nullptr).iterator->value;
     if (!group)
         group = makeUnique<RadioButtonGroup>();
     group->add(element);
 }
 
-Vector<HTMLInputElement*> RadioButtonGroups::groupMembers(const HTMLInputElement& element) const
+Vector<Ref<HTMLInputElement>> RadioButtonGroups::groupMembers(const HTMLInputElement& element) const
 {
     ASSERT(element.isRadioButton());
     if (!element.isRadioButton())
         return { };
 
     auto* name = element.name().impl();
     if (!name)
         return { };
 
-    if (!m_nameToGroupMap)
-        return { };
-
-    auto* group = m_nameToGroupMap->get(name);
+    auto* group = m_nameToGroupMap.get(name);
     if (!group)
         return { };
     return group->members();
 }
 
 void RadioButtonGroups::updateCheckedState(HTMLInputElement& element)
 {
     ASSERT(element.isRadioButton());
     if (element.name().isEmpty())
         return;
-    ASSERT(m_nameToGroupMap);
-    if (!m_nameToGroupMap)
-        return;
-    m_nameToGroupMap->get(element.name().impl())->updateCheckedState(element);
+    m_nameToGroupMap.get(element.name().impl())->updateCheckedState(element);
 }
 
 void RadioButtonGroups::requiredStateChanged(HTMLInputElement& element)
 {
     ASSERT(element.isRadioButton());
     if (element.name().isEmpty())
         return;
-    ASSERT(m_nameToGroupMap);
-    if (!m_nameToGroupMap)
-        return;
-    auto* group = m_nameToGroupMap->get(element.name().impl());
+    auto* group = m_nameToGroupMap.get(element.name().impl());
     ASSERT(group);
     group->requiredStateChanged(element);
 }
 
-HTMLInputElement* RadioButtonGroups::checkedButtonForGroup(const AtomString& name) const
+RefPtr<HTMLInputElement> RadioButtonGroups::checkedButtonForGroup(const AtomString& name) const
 {
-    if (!m_nameToGroupMap)
-        return nullptr;
-    m_nameToGroupMap->checkConsistency();
-    RadioButtonGroup* group = m_nameToGroupMap->get(name.impl());
+    m_nameToGroupMap.checkConsistency();
+    RadioButtonGroup* group = m_nameToGroupMap.get(name.impl());
     return group ? group->checkedButton() : nullptr;
 }
 
 bool RadioButtonGroups::hasCheckedButton(const HTMLInputElement& element) const
 {
     ASSERT(element.isRadioButton());
     const AtomString& name = element.name();
-    if (name.isEmpty() || !m_nameToGroupMap)
+    if (name.isEmpty())
         return element.checked();
-    return m_nameToGroupMap->get(name.impl())->checkedButton();
+    auto* group = m_nameToGroupMap.get(name.impl());
+    if (!group)
+        return false; // FIXME: Update the radio button group before author script had a chance to run in didFinishInsertingNode().
+    return group->checkedButton();
 }
 
 bool RadioButtonGroups::isInRequiredGroup(HTMLInputElement& element) const
 {
     ASSERT(element.isRadioButton());
     if (element.name().isEmpty())
         return false;
-    if (!m_nameToGroupMap)
-        return false;
-    auto* group = m_nameToGroupMap->get(element.name().impl());
+    auto* group = m_nameToGroupMap.get(element.name().impl());
     return group && group->isRequired() && group->contains(element);
 }
 
 void RadioButtonGroups::removeButton(HTMLInputElement& element)
 {
     ASSERT(element.isRadioButton());
     if (element.name().isEmpty())
         return;
-    if (!m_nameToGroupMap)
-        return;
 
-    m_nameToGroupMap->checkConsistency();
-    auto it = m_nameToGroupMap->find(element.name().impl());
-    if (it == m_nameToGroupMap->end())
+    m_nameToGroupMap.checkConsistency();
+    auto it = m_nameToGroupMap.find(element.name().impl());
+    if (it == m_nameToGroupMap.end())
         return;
     it->value->remove(element);
-    if (it->value->isEmpty()) {
-        // FIXME: We may skip deallocating the empty RadioButtonGroup for
-        // performance improvement. If we do so, we need to change the key type
-        // of m_nameToGroupMap from AtomStringImpl* to RefPtr<AtomStringImpl>.
-        m_nameToGroupMap->remove(it);
-        if (m_nameToGroupMap->isEmpty())
-            m_nameToGroupMap = nullptr;
-    }
+    if (it->value->isEmpty())
+        m_nameToGroupMap.remove(it);
 }
 
 } // namespace

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/page/Frame.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1998, 1999 Torben Weis &lt;weis@kde.org&gt;
  3  *                     1999-2001 Lars Knoll &lt;knoll@kde.org&gt;
  4  *                     1999-2001 Antti Koivisto &lt;koivisto@kde.org&gt;
  5  *                     2000-2001 Simon Hausmann &lt;hausmann@kde.org&gt;
  6  *                     2000-2001 Dirk Mueller &lt;mueller@kde.org&gt;
  7  *                     2000 Stefan Schimanski &lt;1Stein@gmx.de&gt;
  8  * Copyright (C) 2004-2018 Apple Inc. All rights reserved.
  9  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
 10  * Copyright (C) 2008 Eric Seidel &lt;eric@webkit.org&gt;
 11  *
 12  * This library is free software; you can redistribute it and/or
 13  * modify it under the terms of the GNU Library General Public
 14  * License as published by the Free Software Foundation; either
 15  * version 2 of the License, or (at your option) any later version.
 16  *
 17  * This library is distributed in the hope that it will be useful,
 18  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 19  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 20  * Library General Public License for more details.
 21  *
 22  * You should have received a copy of the GNU Library General Public License
 23  * along with this library; see the file COPYING.LIB.  If not, write to
 24  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 25  * Boston, MA 02110-1301, USA.
 26  */
 27 
 28 #pragma once
 29 
 30 #include &quot;AbstractFrame.h&quot;
 31 #include &quot;AdjustViewSizeOrNot.h&quot;
 32 #include &quot;FrameTree.h&quot;
 33 #include &quot;ScrollTypes.h&quot;
 34 #include &quot;UserScriptTypes.h&quot;
 35 #include &lt;wtf/HashSet.h&gt;
 36 #include &lt;wtf/UniqueRef.h&gt;
 37 
 38 #if PLATFORM(IOS_FAMILY)
 39 #include &quot;Timer.h&quot;
 40 #include &quot;ViewportArguments.h&quot;
 41 #include &quot;VisibleSelection.h&quot;
 42 #endif
 43 
 44 #if PLATFORM(WIN)
 45 #include &quot;FrameWin.h&quot;
 46 #endif
 47 
 48 #if PLATFORM(COCOA)
 49 OBJC_CLASS NSArray;
 50 #endif
 51 
 52 #if PLATFORM(WIN)
 53 typedef struct HBITMAP__* HBITMAP;
 54 #endif
 55 
 56 namespace JSC { namespace Yarr {
 57 class RegularExpression;
 58 } }
 59 
 60 namespace WebCore {
 61 
 62 class CSSAnimationController;
 63 class Color;
 64 class DOMWindow;
 65 class Document;
 66 class Editor;
 67 class Element;
 68 class EventHandler;
 69 class FloatSize;
 70 class FrameDestructionObserver;
 71 class FrameLoader;
 72 class FrameLoaderClient;
 73 class FrameSelection;
 74 class FrameView;
 75 class HTMLFrameOwnerElement;
 76 class HTMLTableCellElement;
 77 class HitTestResult;
 78 class ImageBuffer;
 79 class IntPoint;
 80 class IntRect;
 81 class IntSize;
 82 class NavigationScheduler;
 83 class Node;
 84 class Page;
 85 class Range;
 86 class RenderLayer;
 87 class RenderView;
 88 class RenderWidget;
 89 class ScriptController;
 90 class SecurityOrigin;
 91 class Settings;
 92 class VisiblePosition;
 93 class Widget;
 94 
 95 #if PLATFORM(IOS_FAMILY)
 96 enum {
 97     OverflowScrollNone = 0,
 98     OverflowScrollLeft = 1 &lt;&lt; 0,
 99     OverflowScrollRight = 1 &lt;&lt; 1,
100     OverflowScrollUp = 1 &lt;&lt; 2,
101     OverflowScrollDown = 1 &lt;&lt; 3
102 };
103 
104 enum OverflowScrollAction { DoNotPerformOverflowScroll, PerformOverflowScroll };
105 using NodeQualifier = Function&lt;Node* (const HitTestResult&amp;, Node* terminationNode, IntRect* nodeBounds)&gt;;
106 #endif
107 
108 enum {
109     LayerTreeFlagsIncludeDebugInfo              = 1 &lt;&lt; 0,
110     LayerTreeFlagsIncludeVisibleRects           = 1 &lt;&lt; 1,
111     LayerTreeFlagsIncludeTileCaches             = 1 &lt;&lt; 2,
112     LayerTreeFlagsIncludeRepaintRects           = 1 &lt;&lt; 3,
113     LayerTreeFlagsIncludePaintingPhases         = 1 &lt;&lt; 4,
114     LayerTreeFlagsIncludeContentLayers          = 1 &lt;&lt; 5,
115     LayerTreeFlagsIncludeAcceleratesDrawing     = 1 &lt;&lt; 6,
116     LayerTreeFlagsIncludeClipping               = 1 &lt;&lt; 7,
117     LayerTreeFlagsIncludeBackingStoreAttached   = 1 &lt;&lt; 8,
118     LayerTreeFlagsIncludeRootLayerProperties    = 1 &lt;&lt; 9,
119     LayerTreeFlagsIncludeEventRegion            = 1 &lt;&lt; 10,
120     LayerTreeFlagsIncludeDeepColor              = 1 &lt;&lt; 11,
121 };
122 typedef unsigned LayerTreeFlags;
123 
124 // FIXME: Rename Frame to LocalFrame and AbstractFrame to Frame.
125 class Frame final : public AbstractFrame {
126 public:
127     WEBCORE_EXPORT static Ref&lt;Frame&gt; create(Page*, HTMLFrameOwnerElement*, FrameLoaderClient*);
128 
129     WEBCORE_EXPORT void init();
130 #if PLATFORM(IOS_FAMILY)
131     // Creates &lt;html&gt;&lt;body style=&quot;...&quot;&gt;&lt;/body&gt;&lt;/html&gt; doing minimal amount of work.
132     WEBCORE_EXPORT void initWithSimpleHTMLDocument(const String&amp; style, const URL&amp;);
133 #endif
134     WEBCORE_EXPORT void setView(RefPtr&lt;FrameView&gt;&amp;&amp;);
135     WEBCORE_EXPORT void createView(const IntSize&amp;, const Optional&lt;Color&gt;&amp; backgroundColor,
136         const IntSize&amp; fixedLayoutSize, const IntRect&amp; fixedVisibleContentRect,
137         bool useFixedLayout = false, ScrollbarMode = ScrollbarAuto, bool horizontalLock = false,
138         ScrollbarMode = ScrollbarAuto, bool verticalLock = false);
139 
140     WEBCORE_EXPORT ~Frame();
141 
142     WEBCORE_EXPORT DOMWindow* window() const;
143 
144     void addDestructionObserver(FrameDestructionObserver*);
145     void removeDestructionObserver(FrameDestructionObserver*);
146 
147     WEBCORE_EXPORT void willDetachPage();
148     void detachFromPage();
149     void disconnectOwnerElement();
150 
151     Frame&amp; mainFrame() const;
152     bool isMainFrame() const { return this == static_cast&lt;void*&gt;(&amp;m_mainFrame); }
153 
154     Page* page() const;
155     HTMLFrameOwnerElement* ownerElement() const;
156 
157     Document* document() const;
158     FrameView* view() const;
159 
160     Editor&amp; editor() { return m_editor; }
161     const Editor&amp; editor() const { return m_editor; }
162     EventHandler&amp; eventHandler() { return m_eventHandler; }
163     const EventHandler&amp; eventHandler() const { return m_eventHandler; }
164     FrameLoader&amp; loader() const;
165     NavigationScheduler&amp; navigationScheduler() const;
166     FrameSelection&amp; selection() { return m_selection; }
167     const FrameSelection&amp; selection() const { return m_selection; }
168     FrameTree&amp; tree() const;
169     CSSAnimationController&amp; animation() { return m_animationController; }
170     const CSSAnimationController&amp; animation() const { return m_animationController; }
171     ScriptController&amp; script() { return m_script; }
172     const ScriptController&amp; script() const { return m_script; }
173 
174     WEBCORE_EXPORT RenderView* contentRenderer() const; // Root of the render tree for the document contained in this frame.
175     WEBCORE_EXPORT RenderWidget* ownerRenderer() const; // Renderer for the element that contains this frame.
176 
177     bool documentIsBeingReplaced() const { return m_documentIsBeingReplaced; }
178 
179     bool hasHadUserInteraction() const { return m_hasHadUserInteraction; }
180     void setHasHadUserInteraction() { m_hasHadUserInteraction = true; }
181 
182     bool requestDOMPasteAccess();
183 
184 // ======== All public functions below this point are candidates to move out of Frame into another class. ========
185 
186     WEBCORE_EXPORT void injectUserScripts(UserScriptInjectionTime);
187     WEBCORE_EXPORT void injectUserScriptImmediately(DOMWrapperWorld&amp;, const UserScript&amp;);
188 
189     WEBCORE_EXPORT String layerTreeAsText(LayerTreeFlags = 0) const;
190     WEBCORE_EXPORT String trackedRepaintRectsAsText() const;
191 
192     WEBCORE_EXPORT static Frame* frameForWidget(const Widget&amp;);
193 
194     Settings&amp; settings() const { return *m_settings; }
195 
196     void setPrinting(bool printing, const FloatSize&amp; pageSize, const FloatSize&amp; originalPageSize, float maximumShrinkRatio, AdjustViewSizeOrNot);
197     bool shouldUsePrintingLayout() const;
198     WEBCORE_EXPORT FloatSize resizePageRectsKeepingRatio(const FloatSize&amp; originalSize, const FloatSize&amp; expectedSize);
199 
200     void setDocument(RefPtr&lt;Document&gt;&amp;&amp;);
201 
202     WEBCORE_EXPORT void setPageZoomFactor(float);
203     float pageZoomFactor() const { return m_pageZoomFactor; }
204     WEBCORE_EXPORT void setTextZoomFactor(float);
205     float textZoomFactor() const { return m_textZoomFactor; }
206     WEBCORE_EXPORT void setPageAndTextZoomFactors(float pageZoomFactor, float textZoomFactor);
207 
208     // Scale factor of this frame with respect to the container.
209     WEBCORE_EXPORT float frameScaleFactor() const;
210 
211     void deviceOrPageScaleFactorChanged();
212 
213 #if ENABLE(DATA_DETECTION)
214     void setDataDetectionResults(NSArray *results) { m_dataDetectionResults = results; }
215     NSArray *dataDetectionResults() const { return m_dataDetectionResults.get(); }
216 #endif
217 
218 #if PLATFORM(IOS_FAMILY)
219     const ViewportArguments&amp; viewportArguments() const;
220     WEBCORE_EXPORT void setViewportArguments(const ViewportArguments&amp;);
221 
222     WEBCORE_EXPORT Node* deepestNodeAtLocation(const FloatPoint&amp; viewportLocation);
223     WEBCORE_EXPORT Node* nodeRespondingToClickEvents(const FloatPoint&amp; viewportLocation, FloatPoint&amp; adjustedViewportLocation, SecurityOrigin* = nullptr);
224     WEBCORE_EXPORT Node* nodeRespondingToDoubleClickEvent(const FloatPoint&amp; viewportLocation, FloatPoint&amp; adjustedViewportLocation);
225     WEBCORE_EXPORT Node* nodeRespondingToInteraction(const FloatPoint&amp; viewportLocation, FloatPoint&amp; adjustedViewportLocation);
226     WEBCORE_EXPORT Node* nodeRespondingToScrollWheelEvents(const FloatPoint&amp; viewportLocation);
227     WEBCORE_EXPORT Node* approximateNodeAtViewportLocationLegacy(const FloatPoint&amp; viewportLocation, FloatPoint&amp; adjustedViewportLocation);
228 
229     WEBCORE_EXPORT NSArray *wordsInCurrentParagraph() const;
230     WEBCORE_EXPORT CGRect renderRectForPoint(CGPoint, bool* isReplaced, float* fontSize) const;
231 
232     WEBCORE_EXPORT void setSelectionChangeCallbacksDisabled(bool = true);
233     bool selectionChangeCallbacksDisabled() const;
234 
235     enum ViewportOffsetChangeType { IncrementalScrollOffset, CompletedScrollOffset };
236     WEBCORE_EXPORT void viewportOffsetChanged(ViewportOffsetChangeType);
237     bool containsTiledBackingLayers() const;
238 
239     WEBCORE_EXPORT void overflowScrollPositionChangedForNode(const IntPoint&amp;, Node*, bool isUserScroll);
240 
241     WEBCORE_EXPORT void resetAllGeolocationPermission();
242 #endif
243 
244 #if ENABLE(ORIENTATION_EVENTS)
245     // Orientation is the interface orientation in degrees. Some examples are:
246     //  0 is straight up; -90 is when the device is rotated 90 clockwise;
247     //  90 is when rotated counter clockwise.
248     WEBCORE_EXPORT void orientationChanged();
249     int orientation() const;
250 #endif
251 
252     void clearTimers();
253     static void clearTimers(FrameView*, Document*);
254 
255     WEBCORE_EXPORT String displayStringModifiedByEncoding(const String&amp;) const;
256 
257     WEBCORE_EXPORT VisiblePosition visiblePositionForPoint(const IntPoint&amp; framePoint) const;
258     Document* documentAtPoint(const IntPoint&amp; windowPoint);
259     WEBCORE_EXPORT RefPtr&lt;Range&gt; rangeForPoint(const IntPoint&amp; framePoint);
260 
261     WEBCORE_EXPORT String searchForLabelsAboveCell(const JSC::Yarr::RegularExpression&amp;, HTMLTableCellElement*, size_t* resultDistanceFromStartOfCell);
262     String searchForLabelsBeforeElement(const Vector&lt;String&gt;&amp; labels, Element*, size_t* resultDistance, bool* resultIsInCellAbove);
263     String matchLabelsAgainstElement(const Vector&lt;String&gt;&amp; labels, Element*);
264 
265 #if PLATFORM(IOS_FAMILY)
266     WEBCORE_EXPORT int preferredHeight() const;
267     WEBCORE_EXPORT void updateLayout() const;
268     WEBCORE_EXPORT NSRect caretRect();
269     WEBCORE_EXPORT NSRect rectForScrollToVisible();
270     WEBCORE_EXPORT unsigned formElementsCharacterCount() const;
271 
272     // This function is used by Legacy WebKit.
273     WEBCORE_EXPORT void setTimersPaused(bool);
274 
275     WEBCORE_EXPORT void dispatchPageHideEventBeforePause();
276     WEBCORE_EXPORT void dispatchPageShowEventBeforeResume();
277     WEBCORE_EXPORT void setRangedSelectionBaseToCurrentSelection();
278     WEBCORE_EXPORT void setRangedSelectionBaseToCurrentSelectionStart();
279     WEBCORE_EXPORT void setRangedSelectionBaseToCurrentSelectionEnd();
280     WEBCORE_EXPORT void clearRangedSelectionInitialExtent();
281     WEBCORE_EXPORT void setRangedSelectionInitialExtentToCurrentSelectionStart();
282     WEBCORE_EXPORT void setRangedSelectionInitialExtentToCurrentSelectionEnd();
283     WEBCORE_EXPORT VisibleSelection rangedSelectionBase() const;
284     WEBCORE_EXPORT VisibleSelection rangedSelectionInitialExtent() const;
285     WEBCORE_EXPORT void recursiveSetUpdateAppearanceEnabled(bool);
286     WEBCORE_EXPORT NSArray *interpretationsForCurrentRoot() const;
287 #endif
288     void suspendActiveDOMObjectsAndAnimations();
289     void resumeActiveDOMObjectsAndAnimations();
290     bool activeDOMObjectsAndAnimationsSuspended() const { return m_activeDOMObjectsAndAnimationsSuspendedCount &gt; 0; }
291 
292     WEBCORE_EXPORT bool isAlwaysOnLoggingAllowed() const;
293 
294     void didPrewarmLocalStorage();
295     bool mayPrewarmLocalStorage() const;
296 
297 // ========
298 
299     void selfOnlyRef();
300     void selfOnlyDeref();
301 
302 private:
303     friend class NavigationDisabler;
304 
305     Frame(Page&amp;, HTMLFrameOwnerElement*, FrameLoaderClient&amp;);
306 
307     void dropChildren();
308 
309     bool isLocalFrame() const final { return true; }
310     bool isRemoteFrame() const final { return false; }
311 
312     AbstractDOMWindow* virtualWindow() const final;
313 
314     HashSet&lt;FrameDestructionObserver*&gt; m_destructionObservers;
315 
316     Frame&amp; m_mainFrame;
317     Page* m_page;
318     const RefPtr&lt;Settings&gt; m_settings;
319     mutable FrameTree m_treeNode;
320     mutable UniqueRef&lt;FrameLoader&gt; m_loader;
321     mutable UniqueRef&lt;NavigationScheduler&gt; m_navigationScheduler;
322 
323     HTMLFrameOwnerElement* m_ownerElement;
324     RefPtr&lt;FrameView&gt; m_view;
325     RefPtr&lt;Document&gt; m_doc;
326 
327     UniqueRef&lt;ScriptController&gt; m_script;
328     UniqueRef&lt;Editor&gt; m_editor;
329     UniqueRef&lt;FrameSelection&gt; m_selection;
330     UniqueRef&lt;CSSAnimationController&gt; m_animationController;
331 
332 #if ENABLE(DATA_DETECTION)
333     RetainPtr&lt;NSArray&gt; m_dataDetectionResults;
334 #endif
335 #if PLATFORM(IOS_FAMILY)
336     void betterApproximateNode(const IntPoint&amp; testPoint, const NodeQualifier&amp;, Node*&amp; best, Node* failedNode, IntPoint&amp; bestPoint, IntRect&amp; bestRect, const IntRect&amp; testRect);
337     bool hitTestResultAtViewportLocation(const FloatPoint&amp; viewportLocation, HitTestResult&amp;, IntPoint&amp; center);
338 
339     enum class ShouldApproximate : bool { No, Yes };
340     enum class ShouldFindRootEditableElement : bool { No, Yes };
341     Node* qualifyingNodeAtViewportLocation(const FloatPoint&amp; viewportLocation, FloatPoint&amp; adjustedViewportLocation, const NodeQualifier&amp;, ShouldApproximate, ShouldFindRootEditableElement = ShouldFindRootEditableElement::Yes);
342 
343     void setTimersPausedInternal(bool);
344 
345     ViewportArguments m_viewportArguments;
346     bool m_selectionChangeCallbacksDisabled { false };
347     VisibleSelection m_rangedSelectionBase;
348     VisibleSelection m_rangedSelectionInitialExtent;
349 #endif
350 
351     float m_pageZoomFactor;
352     float m_textZoomFactor;
353 
354     int m_activeDOMObjectsAndAnimationsSuspendedCount { 0 };
355     bool m_documentIsBeingReplaced { false };
356     unsigned m_navigationDisableCount { 0 };
357     unsigned m_selfOnlyRefCount { 0 };
358     bool m_hasHadUserInteraction { false };
359     unsigned m_localStoragePrewarmingCount { 0 };
360 
361 protected:
362     UniqueRef&lt;EventHandler&gt; m_eventHandler;
363 };
364 
365 inline FrameLoader&amp; Frame::loader() const
366 {
367     return m_loader.get();
368 }
369 
370 inline NavigationScheduler&amp; Frame::navigationScheduler() const
371 {
372     return m_navigationScheduler.get();
373 }
374 
375 inline FrameView* Frame::view() const
376 {
377     return m_view.get();
378 }
379 
380 inline Document* Frame::document() const
381 {
382     return m_doc.get();
383 }
384 
385 inline HTMLFrameOwnerElement* Frame::ownerElement() const
386 {
387     return m_ownerElement;
388 }
389 
390 inline FrameTree&amp; Frame::tree() const
391 {
392     return m_treeNode;
393 }
394 
395 inline Page* Frame::page() const
396 {
397     return m_page;
398 }
399 
400 inline void Frame::detachFromPage()
401 {
402     m_page = nullptr;
403 }
404 
405 inline Frame&amp; Frame::mainFrame() const
406 {
407     return m_mainFrame;
408 }
409 
410 } // namespace WebCore
411 
412 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::Frame)
413     static bool isType(const WebCore::AbstractFrame&amp; frame) { return frame.isLocalFrame(); }
414 SPECIALIZE_TYPE_TRAITS_END()
    </pre>
  </body>
</html>
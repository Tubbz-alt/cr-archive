<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSTokenizer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 // Copyright 2015 The Chromium Authors. All rights reserved.
  2 // Copyright (C) 2016 Apple Inc. All rights reserved.
  3 //
  4 // Redistribution and use in source and binary forms, with or without
  5 // modification, are permitted provided that the following conditions are
  6 // met:
  7 //
  8 //    * Redistributions of source code must retain the above copyright
  9 // notice, this list of conditions and the following disclaimer.
 10 //    * Redistributions in binary form must reproduce the above
 11 // copyright notice, this list of conditions and the following disclaimer
 12 // in the documentation and/or other materials provided with the
 13 // distribution.
 14 //    * Neither the name of Google Inc. nor the names of its
 15 // contributors may be used to endorse or promote products derived from
 16 // this software without specific prior written permission.
 17 //
 18 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;CSSTokenizer.h&quot;
 32 
 33 #include &quot;CSSParserIdioms.h&quot;
 34 #include &quot;CSSParserObserverWrapper.h&quot;
 35 #include &quot;CSSParserTokenRange.h&quot;
 36 #include &quot;CSSTokenizerInputStream.h&quot;
 37 #include &quot;HTMLParserIdioms.h&quot;
 38 #include &lt;wtf/text/StringBuilder.h&gt;
 39 #include &lt;wtf/unicode/CharacterNames.h&gt;
 40 
 41 namespace WebCore {
 42 
 43 CSSTokenizer::CSSTokenizer(const String&amp; string)
 44     : m_input(string)
 45 {
 46     // According to the spec, we should perform preprocessing here.
 47     // See: http://dev.w3.org/csswg/css-syntax/#input-preprocessing
 48     //
 49     // However, we can skip this step since:
 50     // * We&#39;re using HTML spaces (which accept \r and \f as a valid white space)
 51     // * Do not count white spaces
 52     // * CSSTokenizerInputStream::nextInputChar() replaces NULLs for replacement characters
 53 
 54     if (string.isEmpty())
 55         return;
 56 
 57     // To avoid resizing we err on the side of reserving too much space.
 58     // Most strings we tokenize have about 3.5 to 5 characters per token.
 59     m_tokens.reserveInitialCapacity(string.length() / 3);
 60 
 61     while (true) {
 62         CSSParserToken token = nextToken();
 63         if (token.type() == CommentToken)
 64             continue;
 65         if (token.type() == EOFToken)
 66             return;
 67         m_tokens.append(token);
 68     }
 69 }
 70 
 71 CSSTokenizer::CSSTokenizer(const String&amp; string, CSSParserObserverWrapper&amp; wrapper)
 72     : m_input(string)
 73 {
 74     if (string.isEmpty())
 75         return;
 76 
 77     unsigned offset = 0;
 78     while (true) {
 79         CSSParserToken token = nextToken();
 80         if (token.type() == EOFToken)
 81             break;
 82         if (token.type() == CommentToken)
 83             wrapper.addComment(offset, m_input.offset(), m_tokens.size());
 84         else {
 85             m_tokens.append(token);
 86             wrapper.addToken(offset);
 87         }
 88         offset = m_input.offset();
 89     }
 90 
 91     wrapper.addToken(offset);
 92     wrapper.finalizeConstruction(m_tokens.begin());
 93 }
 94 
 95 CSSParserTokenRange CSSTokenizer::tokenRange() const
 96 {
 97     return m_tokens;
 98 }
 99 
100 unsigned CSSTokenizer::tokenCount()
101 {
102     return m_tokens.size();
103 }
104 
105 static bool isNewLine(UChar cc)
106 {
107     // We check \r and \f here, since we have no preprocessing stage
108     return (cc == &#39;\r&#39; || cc == &#39;\n&#39; || cc == &#39;\f&#39;);
109 }
110 
111 // http://dev.w3.org/csswg/css-syntax/#check-if-two-code-points-are-a-valid-escape
112 static bool twoCharsAreValidEscape(UChar first, UChar second)
113 {
114     return first == &#39;\\&#39; &amp;&amp; !isNewLine(second);
115 }
116 
117 void CSSTokenizer::reconsume(UChar c)
118 {
119     m_input.pushBack(c);
120 }
121 
122 UChar CSSTokenizer::consume()
123 {
124     UChar current = m_input.nextInputChar();
125     m_input.advance();
126     return current;
127 }
128 
129 CSSParserToken CSSTokenizer::whiteSpace(UChar /*cc*/)
130 {
131     m_input.advanceUntilNonWhitespace();
132     return CSSParserToken(WhitespaceToken);
133 }
134 
135 CSSParserToken CSSTokenizer::blockStart(CSSParserTokenType type)
136 {
137     m_blockStack.append(type);
138     return CSSParserToken(type, CSSParserToken::BlockStart);
139 }
140 
141 CSSParserToken CSSTokenizer::blockStart(CSSParserTokenType blockType, CSSParserTokenType type, StringView name)
142 {
143     m_blockStack.append(blockType);
144     return CSSParserToken(type, name, CSSParserToken::BlockStart);
145 }
146 
147 CSSParserToken CSSTokenizer::blockEnd(CSSParserTokenType type, CSSParserTokenType startType)
148 {
149     if (!m_blockStack.isEmpty() &amp;&amp; m_blockStack.last() == startType) {
150         m_blockStack.removeLast();
151         return CSSParserToken(type, CSSParserToken::BlockEnd);
152     }
153     return CSSParserToken(type);
154 }
155 
156 CSSParserToken CSSTokenizer::leftParenthesis(UChar /*cc*/)
157 {
158     return blockStart(LeftParenthesisToken);
159 }
160 
161 CSSParserToken CSSTokenizer::rightParenthesis(UChar /*cc*/)
162 {
163     return blockEnd(RightParenthesisToken, LeftParenthesisToken);
164 }
165 
166 CSSParserToken CSSTokenizer::leftBracket(UChar /*cc*/)
167 {
168     return blockStart(LeftBracketToken);
169 }
170 
171 CSSParserToken CSSTokenizer::rightBracket(UChar /*cc*/)
172 {
173     return blockEnd(RightBracketToken, LeftBracketToken);
174 }
175 
176 CSSParserToken CSSTokenizer::leftBrace(UChar /*cc*/)
177 {
178     return blockStart(LeftBraceToken);
179 }
180 
181 CSSParserToken CSSTokenizer::rightBrace(UChar /*cc*/)
182 {
183     return blockEnd(RightBraceToken, LeftBraceToken);
184 }
185 
186 CSSParserToken CSSTokenizer::plusOrFullStop(UChar cc)
187 {
188     if (nextCharsAreNumber(cc)) {
189         reconsume(cc);
190         return consumeNumericToken();
191     }
192     return CSSParserToken(DelimiterToken, cc);
193 }
194 
195 CSSParserToken CSSTokenizer::asterisk(UChar cc)
196 {
197     ASSERT_UNUSED(cc, cc == &#39;*&#39;);
198     if (consumeIfNext(&#39;=&#39;))
199         return CSSParserToken(SubstringMatchToken);
200     return CSSParserToken(DelimiterToken, &#39;*&#39;);
201 }
202 
203 CSSParserToken CSSTokenizer::lessThan(UChar cc)
204 {
205     ASSERT_UNUSED(cc, cc == &#39;&lt;&#39;);
206     if (m_input.peekWithoutReplacement(0) == &#39;!&#39;
207         &amp;&amp; m_input.peekWithoutReplacement(1) == &#39;-&#39;
208         &amp;&amp; m_input.peekWithoutReplacement(2) == &#39;-&#39;) {
209         m_input.advance(3);
210         return CSSParserToken(CDOToken);
211     }
212     return CSSParserToken(DelimiterToken, &#39;&lt;&#39;);
213 }
214 
215 CSSParserToken CSSTokenizer::comma(UChar /*cc*/)
216 {
217     return CSSParserToken(CommaToken);
218 }
219 
220 CSSParserToken CSSTokenizer::hyphenMinus(UChar cc)
221 {
222     if (nextCharsAreNumber(cc)) {
223         reconsume(cc);
224         return consumeNumericToken();
225     }
226     if (m_input.peekWithoutReplacement(0) == &#39;-&#39;
227         &amp;&amp; m_input.peekWithoutReplacement(1) == &#39;&gt;&#39;) {
228         m_input.advance(2);
229         return CSSParserToken(CDCToken);
230     }
231     if (nextCharsAreIdentifier(cc)) {
232         reconsume(cc);
233         return consumeIdentLikeToken();
234     }
235     return CSSParserToken(DelimiterToken, cc);
236 }
237 
238 CSSParserToken CSSTokenizer::solidus(UChar cc)
239 {
240     if (consumeIfNext(&#39;*&#39;)) {
241         // These get ignored, but we need a value to return.
242         consumeUntilCommentEndFound();
243         return CSSParserToken(CommentToken);
244     }
245 
246     return CSSParserToken(DelimiterToken, cc);
247 }
248 
249 CSSParserToken CSSTokenizer::colon(UChar /*cc*/)
250 {
251     return CSSParserToken(ColonToken);
252 }
253 
254 CSSParserToken CSSTokenizer::semiColon(UChar /*cc*/)
255 {
256     return CSSParserToken(SemicolonToken);
257 }
258 
259 CSSParserToken CSSTokenizer::hash(UChar cc)
260 {
261     UChar nextChar = m_input.peekWithoutReplacement(0);
262     if (isNameCodePoint(nextChar) || twoCharsAreValidEscape(nextChar, m_input.peekWithoutReplacement(1))) {
263         HashTokenType type = nextCharsAreIdentifier() ? HashTokenId : HashTokenUnrestricted;
264         return CSSParserToken(type, consumeName());
265     }
266 
267     return CSSParserToken(DelimiterToken, cc);
268 }
269 
270 CSSParserToken CSSTokenizer::circumflexAccent(UChar cc)
271 {
272     ASSERT_UNUSED(cc, cc == &#39;^&#39;);
273     if (consumeIfNext(&#39;=&#39;))
274         return CSSParserToken(PrefixMatchToken);
275     return CSSParserToken(DelimiterToken, &#39;^&#39;);
276 }
277 
278 CSSParserToken CSSTokenizer::dollarSign(UChar cc)
279 {
280     ASSERT_UNUSED(cc, cc == &#39;$&#39;);
281     if (consumeIfNext(&#39;=&#39;))
282         return CSSParserToken(SuffixMatchToken);
283     return CSSParserToken(DelimiterToken, &#39;$&#39;);
284 }
285 
286 CSSParserToken CSSTokenizer::verticalLine(UChar cc)
287 {
288     ASSERT_UNUSED(cc, cc == &#39;|&#39;);
289     if (consumeIfNext(&#39;=&#39;))
290         return CSSParserToken(DashMatchToken);
291     if (consumeIfNext(&#39;|&#39;))
292         return CSSParserToken(ColumnToken);
293     return CSSParserToken(DelimiterToken, &#39;|&#39;);
294 }
295 
296 CSSParserToken CSSTokenizer::tilde(UChar cc)
297 {
298     ASSERT_UNUSED(cc, cc == &#39;~&#39;);
299     if (consumeIfNext(&#39;=&#39;))
300         return CSSParserToken(IncludeMatchToken);
301     return CSSParserToken(DelimiterToken, &#39;~&#39;);
302 }
303 
304 CSSParserToken CSSTokenizer::commercialAt(UChar cc)
305 {
306     ASSERT_UNUSED(cc, cc == &#39;@&#39;);
307     if (nextCharsAreIdentifier())
308         return CSSParserToken(AtKeywordToken, consumeName());
309     return CSSParserToken(DelimiterToken, &#39;@&#39;);
310 }
311 
312 CSSParserToken CSSTokenizer::reverseSolidus(UChar cc)
313 {
314     if (twoCharsAreValidEscape(cc, m_input.peekWithoutReplacement(0))) {
315         reconsume(cc);
316         return consumeIdentLikeToken();
317     }
318     return CSSParserToken(DelimiterToken, cc);
319 }
320 
321 CSSParserToken CSSTokenizer::asciiDigit(UChar cc)
322 {
323     reconsume(cc);
324     return consumeNumericToken();
325 }
326 
327 CSSParserToken CSSTokenizer::letterU(UChar cc)
328 {
329     if (m_input.peekWithoutReplacement(0) == &#39;+&#39;
330         &amp;&amp; (isASCIIHexDigit(m_input.peekWithoutReplacement(1)) || m_input.peekWithoutReplacement(1) == &#39;?&#39;)) {
331         m_input.advance();
332         return consumeUnicodeRange();
333     }
334     reconsume(cc);
335     return consumeIdentLikeToken();
336 }
337 
338 CSSParserToken CSSTokenizer::nameStart(UChar cc)
339 {
340     reconsume(cc);
341     return consumeIdentLikeToken();
342 }
343 
344 CSSParserToken CSSTokenizer::stringStart(UChar cc)
345 {
346     return consumeStringTokenUntil(cc);
347 }
348 
349 CSSParserToken CSSTokenizer::endOfFile(UChar /*cc*/)
350 {
351     return CSSParserToken(EOFToken);
352 }
353 
354 const CSSTokenizer::CodePoint CSSTokenizer::codePoints[128] = {
355     &amp;CSSTokenizer::endOfFile,
356     0,
357     0,
358     0,
359     0,
360     0,
361     0,
362     0,
363     0,
364     &amp;CSSTokenizer::whiteSpace,
365     &amp;CSSTokenizer::whiteSpace,
366     0,
367     &amp;CSSTokenizer::whiteSpace,
368     &amp;CSSTokenizer::whiteSpace,
369     0,
370     0,
371     0,
372     0,
373     0,
374     0,
375     0,
376     0,
377     0,
378     0,
379     0,
380     0,
381     0,
382     0,
383     0,
384     0,
385     0,
386     0,
387     &amp;CSSTokenizer::whiteSpace,
388     0,
389     &amp;CSSTokenizer::stringStart,
390     &amp;CSSTokenizer::hash,
391     &amp;CSSTokenizer::dollarSign,
392     0,
393     0,
394     &amp;CSSTokenizer::stringStart,
395     &amp;CSSTokenizer::leftParenthesis,
396     &amp;CSSTokenizer::rightParenthesis,
397     &amp;CSSTokenizer::asterisk,
398     &amp;CSSTokenizer::plusOrFullStop,
399     &amp;CSSTokenizer::comma,
400     &amp;CSSTokenizer::hyphenMinus,
401     &amp;CSSTokenizer::plusOrFullStop,
402     &amp;CSSTokenizer::solidus,
403     &amp;CSSTokenizer::asciiDigit,
404     &amp;CSSTokenizer::asciiDigit,
405     &amp;CSSTokenizer::asciiDigit,
406     &amp;CSSTokenizer::asciiDigit,
407     &amp;CSSTokenizer::asciiDigit,
408     &amp;CSSTokenizer::asciiDigit,
409     &amp;CSSTokenizer::asciiDigit,
410     &amp;CSSTokenizer::asciiDigit,
411     &amp;CSSTokenizer::asciiDigit,
412     &amp;CSSTokenizer::asciiDigit,
413     &amp;CSSTokenizer::colon,
414     &amp;CSSTokenizer::semiColon,
415     &amp;CSSTokenizer::lessThan,
416     0,
417     0,
418     0,
419     &amp;CSSTokenizer::commercialAt,
420     &amp;CSSTokenizer::nameStart,
421     &amp;CSSTokenizer::nameStart,
422     &amp;CSSTokenizer::nameStart,
423     &amp;CSSTokenizer::nameStart,
424     &amp;CSSTokenizer::nameStart,
425     &amp;CSSTokenizer::nameStart,
426     &amp;CSSTokenizer::nameStart,
427     &amp;CSSTokenizer::nameStart,
428     &amp;CSSTokenizer::nameStart,
429     &amp;CSSTokenizer::nameStart,
430     &amp;CSSTokenizer::nameStart,
431     &amp;CSSTokenizer::nameStart,
432     &amp;CSSTokenizer::nameStart,
433     &amp;CSSTokenizer::nameStart,
434     &amp;CSSTokenizer::nameStart,
435     &amp;CSSTokenizer::nameStart,
436     &amp;CSSTokenizer::nameStart,
437     &amp;CSSTokenizer::nameStart,
438     &amp;CSSTokenizer::nameStart,
439     &amp;CSSTokenizer::nameStart,
440     &amp;CSSTokenizer::letterU,
441     &amp;CSSTokenizer::nameStart,
442     &amp;CSSTokenizer::nameStart,
443     &amp;CSSTokenizer::nameStart,
444     &amp;CSSTokenizer::nameStart,
445     &amp;CSSTokenizer::nameStart,
446     &amp;CSSTokenizer::leftBracket,
447     &amp;CSSTokenizer::reverseSolidus,
448     &amp;CSSTokenizer::rightBracket,
449     &amp;CSSTokenizer::circumflexAccent,
450     &amp;CSSTokenizer::nameStart,
451     0,
452     &amp;CSSTokenizer::nameStart,
453     &amp;CSSTokenizer::nameStart,
454     &amp;CSSTokenizer::nameStart,
455     &amp;CSSTokenizer::nameStart,
456     &amp;CSSTokenizer::nameStart,
457     &amp;CSSTokenizer::nameStart,
458     &amp;CSSTokenizer::nameStart,
459     &amp;CSSTokenizer::nameStart,
460     &amp;CSSTokenizer::nameStart,
461     &amp;CSSTokenizer::nameStart,
462     &amp;CSSTokenizer::nameStart,
463     &amp;CSSTokenizer::nameStart,
464     &amp;CSSTokenizer::nameStart,
465     &amp;CSSTokenizer::nameStart,
466     &amp;CSSTokenizer::nameStart,
467     &amp;CSSTokenizer::nameStart,
468     &amp;CSSTokenizer::nameStart,
469     &amp;CSSTokenizer::nameStart,
470     &amp;CSSTokenizer::nameStart,
471     &amp;CSSTokenizer::nameStart,
472     &amp;CSSTokenizer::letterU,
473     &amp;CSSTokenizer::nameStart,
474     &amp;CSSTokenizer::nameStart,
475     &amp;CSSTokenizer::nameStart,
476     &amp;CSSTokenizer::nameStart,
477     &amp;CSSTokenizer::nameStart,
478     &amp;CSSTokenizer::leftBrace,
479     &amp;CSSTokenizer::verticalLine,
480     &amp;CSSTokenizer::rightBrace,
481     &amp;CSSTokenizer::tilde,
482     0,
483 };
484 #if !ASSERT_WITH_SECURITY_IMPLICATION_DISABLED
485 const unsigned codePointsNumber = 128;
486 #endif
487 
488 CSSParserToken CSSTokenizer::nextToken()
489 {
490     // Unlike the HTMLTokenizer, the CSS Syntax spec is written
491     // as a stateless, (fixed-size) look-ahead tokenizer.
492     // We could move to the stateful model and instead create
493     // states for all the &quot;next 3 codepoints are X&quot; cases.
494     // State-machine tokenizers are easier to write to handle
495     // incremental tokenization of partial sources.
496     // However, for now we follow the spec exactly.
497     UChar cc = consume();
498     CodePoint codePointFunc = 0;
499 
500     if (isASCII(cc)) {
501         ASSERT_WITH_SECURITY_IMPLICATION(cc &lt; codePointsNumber);
502         codePointFunc = codePoints[cc];
503     } else
504         codePointFunc = &amp;CSSTokenizer::nameStart;
505 
506     if (codePointFunc)
507         return ((this)-&gt;*(codePointFunc))(cc);
508     return CSSParserToken(DelimiterToken, cc);
509 }
510 
511 // This method merges the following spec sections for efficiency
512 // http://www.w3.org/TR/css3-syntax/#consume-a-number
513 // http://www.w3.org/TR/css3-syntax/#convert-a-string-to-a-number
514 CSSParserToken CSSTokenizer::consumeNumber()
515 {
516     ASSERT(nextCharsAreNumber());
517 
518     NumericValueType type = IntegerValueType;
519     NumericSign sign = NoSign;
520     unsigned numberLength = 0;
521 
522     UChar next = m_input.peekWithoutReplacement(0);
523     if (next == &#39;+&#39;) {
524         ++numberLength;
525         sign = PlusSign;
526     } else if (next == &#39;-&#39;) {
527         ++numberLength;
528         sign = MinusSign;
529     }
530 
531     numberLength = m_input.skipWhilePredicate&lt;isASCIIDigit&gt;(numberLength);
532     next = m_input.peekWithoutReplacement(numberLength);
533     if (next == &#39;.&#39; &amp;&amp; isASCIIDigit(m_input.peekWithoutReplacement(numberLength + 1))) {
534         type = NumberValueType;
535         numberLength = m_input.skipWhilePredicate&lt;isASCIIDigit&gt;(numberLength + 2);
536         next = m_input.peekWithoutReplacement(numberLength);
537     }
538 
539     if (next == &#39;E&#39; || next == &#39;e&#39;) {
540         next = m_input.peekWithoutReplacement(numberLength + 1);
541         if (isASCIIDigit(next)) {
542             type = NumberValueType;
543             numberLength = m_input.skipWhilePredicate&lt;isASCIIDigit&gt;(numberLength + 1);
544         } else if ((next == &#39;+&#39; || next == &#39;-&#39;) &amp;&amp; isASCIIDigit(m_input.peekWithoutReplacement(numberLength + 2))) {
545             type = NumberValueType;
546             numberLength = m_input.skipWhilePredicate&lt;isASCIIDigit&gt;(numberLength + 3);
547         }
548     }
549 
550     double value = m_input.getDouble(0, numberLength);
551     m_input.advance(numberLength);
552 
553     return CSSParserToken(NumberToken, value, type, sign);
554 }
555 
556 // http://www.w3.org/TR/css3-syntax/#consume-a-numeric-token
557 CSSParserToken CSSTokenizer::consumeNumericToken()
558 {
559     CSSParserToken token = consumeNumber();
560     if (nextCharsAreIdentifier())
561         token.convertToDimensionWithUnit(consumeName());
562     else if (consumeIfNext(&#39;%&#39;))
563         token.convertToPercentage();
564     return token;
565 }
566 
567 // http://dev.w3.org/csswg/css-syntax/#consume-ident-like-token
568 CSSParserToken CSSTokenizer::consumeIdentLikeToken()
569 {
570     StringView name = consumeName();
571     if (consumeIfNext(&#39;(&#39;)) {
572         if (equalIgnoringASCIICase(name, &quot;url&quot;)) {
573             // The spec is slightly different so as to avoid dropping whitespace
574             // tokens, but they wouldn&#39;t be used and this is easier.
575             m_input.advanceUntilNonWhitespace();
576             UChar next = m_input.peekWithoutReplacement(0);
577             if (next != &#39;&quot;&#39; &amp;&amp; next != &#39;\&#39;&#39;)
578                 return consumeUrlToken();
579         }
580         return blockStart(LeftParenthesisToken, FunctionToken, name);
581     }
582     return CSSParserToken(IdentToken, name);
583 }
584 
585 // http://dev.w3.org/csswg/css-syntax/#consume-a-string-token
586 CSSParserToken CSSTokenizer::consumeStringTokenUntil(UChar endingCodePoint)
587 {
588     // Strings without escapes get handled without allocations
589     for (unsigned size = 0; ; size++) {
590         UChar cc = m_input.peekWithoutReplacement(size);
591         if (cc == endingCodePoint) {
592             unsigned startOffset = m_input.offset();
593             m_input.advance(size + 1);
594             return CSSParserToken(StringToken, m_input.rangeAt(startOffset, size));
595         }
596         if (isNewLine(cc)) {
597             m_input.advance(size);
598             return CSSParserToken(BadStringToken);
599         }
600         if (cc == &#39;\0&#39; || cc == &#39;\\&#39;)
601             break;
602     }
603 
604     StringBuilder output;
605     while (true) {
606         UChar cc = consume();
607         if (cc == endingCodePoint || cc == kEndOfFileMarker)
608             return CSSParserToken(StringToken, registerString(output.toString()));
609         if (isNewLine(cc)) {
610             reconsume(cc);
611             return CSSParserToken(BadStringToken);
612         }
613         if (cc == &#39;\\&#39;) {
614             if (m_input.nextInputChar() == kEndOfFileMarker)
615                 continue;
616             if (isNewLine(m_input.peekWithoutReplacement(0)))
617                 consumeSingleWhitespaceIfNext(); // This handles \r\n for us
618             else
619                 output.appendCharacter(consumeEscape());
620         } else
621             output.append(cc);
622     }
623 }
624 
625 CSSParserToken CSSTokenizer::consumeUnicodeRange()
626 {
627     ASSERT(isASCIIHexDigit(m_input.peekWithoutReplacement(0)) || m_input.peekWithoutReplacement(0) == &#39;?&#39;);
628     int lengthRemaining = 6;
629     UChar32 start = 0;
630 
631     while (lengthRemaining &amp;&amp; isASCIIHexDigit(m_input.peekWithoutReplacement(0))) {
632         start = start * 16 + toASCIIHexValue(consume());
633         --lengthRemaining;
634     }
635 
636     UChar32 end = start;
637     if (lengthRemaining &amp;&amp; consumeIfNext(&#39;?&#39;)) {
638         do {
639             start *= 16;
640             end = end * 16 + 0xF;
641             --lengthRemaining;
642         } while (lengthRemaining &amp;&amp; consumeIfNext(&#39;?&#39;));
643     } else if (m_input.peekWithoutReplacement(0) == &#39;-&#39; &amp;&amp; isASCIIHexDigit(m_input.peekWithoutReplacement(1))) {
644         m_input.advance();
645         lengthRemaining = 6;
646         end = 0;
647         do {
648             end = end * 16 + toASCIIHexValue(consume());
649             --lengthRemaining;
650         } while (lengthRemaining &amp;&amp; isASCIIHexDigit(m_input.peekWithoutReplacement(0)));
651     }
652 
653     return CSSParserToken(UnicodeRangeToken, start, end);
654 }
655 
656 // http://dev.w3.org/csswg/css-syntax/#non-printable-code-point
657 static bool isNonPrintableCodePoint(UChar cc)
658 {
659     return cc &lt;= &#39;\x8&#39; || cc == &#39;\xb&#39; || (cc &gt;= &#39;\xe&#39; &amp;&amp; cc &lt;= &#39;\x1f&#39;) || cc == &#39;\x7f&#39;;
660 }
661 
662 // http://dev.w3.org/csswg/css-syntax/#consume-url-token
663 CSSParserToken CSSTokenizer::consumeUrlToken()
664 {
665     m_input.advanceUntilNonWhitespace();
666 
667     // URL tokens without escapes get handled without allocations
668     for (unsigned size = 0; ; size++) {
669         UChar cc = m_input.peekWithoutReplacement(size);
670         if (cc == &#39;)&#39;) {
671             unsigned startOffset = m_input.offset();
672             m_input.advance(size + 1);
673             return CSSParserToken(UrlToken, m_input.rangeAt(startOffset, size));
674         }
675         if (cc &lt;= &#39; &#39; || cc == &#39;\\&#39; || cc == &#39;&quot;&#39; || cc == &#39;\&#39;&#39; || cc == &#39;(&#39; || cc == &#39;\x7f&#39;)
676             break;
677     }
678 
679     StringBuilder result;
680     while (true) {
681         UChar cc = consume();
682         if (cc == &#39;)&#39; || cc == kEndOfFileMarker)
683             return CSSParserToken(UrlToken, registerString(result.toString()));
684 
685         if (isHTMLSpace(cc)) {
686             m_input.advanceUntilNonWhitespace();
687             if (consumeIfNext(&#39;)&#39;) || m_input.nextInputChar() == kEndOfFileMarker)
688                 return CSSParserToken(UrlToken, registerString(result.toString()));
689             break;
690         }
691 
692         if (cc == &#39;&quot;&#39; || cc == &#39;\&#39;&#39; || cc == &#39;(&#39; || isNonPrintableCodePoint(cc))
693             break;
694 
695         if (cc == &#39;\\&#39;) {
696             if (twoCharsAreValidEscape(cc, m_input.peekWithoutReplacement(0))) {
697                 result.appendCharacter(consumeEscape());
698                 continue;
699             }
700             break;
701         }
702 
703         result.append(cc);
704     }
705 
706     consumeBadUrlRemnants();
707     return CSSParserToken(BadUrlToken);
708 }
709 
710 // http://dev.w3.org/csswg/css-syntax/#consume-the-remnants-of-a-bad-url
711 void CSSTokenizer::consumeBadUrlRemnants()
712 {
713     while (true) {
714         UChar cc = consume();
715         if (cc == &#39;)&#39; || cc == kEndOfFileMarker)
716             return;
717         if (twoCharsAreValidEscape(cc, m_input.peekWithoutReplacement(0)))
718             consumeEscape();
719     }
720 }
721 
722 void CSSTokenizer::consumeSingleWhitespaceIfNext()
723 {
724     // We check for \r\n and HTML spaces since we don&#39;t do preprocessing
725     UChar next = m_input.peekWithoutReplacement(0);
726     if (next == &#39;\r&#39; &amp;&amp; m_input.peekWithoutReplacement(1) == &#39;\n&#39;)
727         m_input.advance(2);
728     else if (isHTMLSpace(next))
729         m_input.advance();
730 }
731 
732 void CSSTokenizer::consumeUntilCommentEndFound()
733 {
734     UChar c = consume();
735     while (true) {
736         if (c == kEndOfFileMarker)
737             return;
738         if (c != &#39;*&#39;) {
739             c = consume();
740             continue;
741         }
742         c = consume();
743         if (c == &#39;/&#39;)
744             return;
745     }
746 }
747 
748 bool CSSTokenizer::consumeIfNext(UChar character)
749 {
750     // Since we&#39;re not doing replacement we can&#39;t tell the difference from
751     // a NUL in the middle and the kEndOfFileMarker, so character must not be
752     // NUL.
753     ASSERT(character);
754     if (m_input.peekWithoutReplacement(0) == character) {
755         m_input.advance();
756         return true;
757     }
758     return false;
759 }
760 
761 // http://www.w3.org/TR/css3-syntax/#consume-a-name
762 StringView CSSTokenizer::consumeName()
763 {
764     // Names without escapes get handled without allocations
765     for (unsigned size = 0; ; ++size) {
766         UChar cc = m_input.peekWithoutReplacement(size);
767         if (isNameCodePoint(cc))
768             continue;
769         // peekWithoutReplacement will return NUL when we hit the end of the
770         // input. In that case we want to still use the rangeAt() fast path
771         // below.
772         if (cc == &#39;\0&#39; &amp;&amp; m_input.offset() + size &lt; m_input.length())
773             break;
774         if (cc == &#39;\\&#39;)
775             break;
776         unsigned startOffset = m_input.offset();
777         m_input.advance(size);
778         return m_input.rangeAt(startOffset, size);
779     }
780 
781     StringBuilder result;
782     while (true) {
783         UChar cc = consume();
784         if (isNameCodePoint(cc)) {
785             result.append(cc);
786             continue;
787         }
788         if (twoCharsAreValidEscape(cc, m_input.peekWithoutReplacement(0))) {
789             result.appendCharacter(consumeEscape());
790             continue;
791         }
792         reconsume(cc);
793         return registerString(result.toString());
794     }
795 }
796 
797 // http://dev.w3.org/csswg/css-syntax/#consume-an-escaped-code-point
798 UChar32 CSSTokenizer::consumeEscape()
799 {
800     UChar cc = consume();
801     ASSERT(!isNewLine(cc));
802     if (isASCIIHexDigit(cc)) {
803         unsigned consumedHexDigits = 1;
804         StringBuilder hexChars;
805         hexChars.append(cc);
806         while (consumedHexDigits &lt; 6 &amp;&amp; isASCIIHexDigit(m_input.peekWithoutReplacement(0))) {
807             cc = consume();
808             hexChars.append(cc);
809             consumedHexDigits++;
810         };
811         consumeSingleWhitespaceIfNext();
812         bool ok = false;
813         UChar32 codePoint = hexChars.toString().toUIntStrict(&amp;ok, 16);
814         ASSERT(ok);
815         if (!codePoint || (0xD800 &lt;= codePoint &amp;&amp; codePoint &lt;= 0xDFFF) || codePoint &gt; 0x10FFFF)
816             return replacementCharacter;
817         return codePoint;
818     }
819 
820     if (cc == kEndOfFileMarker)
821         return replacementCharacter;
822     return cc;
823 }
824 
825 bool CSSTokenizer::nextTwoCharsAreValidEscape()
826 {
827     return twoCharsAreValidEscape(m_input.peekWithoutReplacement(0), m_input.peekWithoutReplacement(1));
828 }
829 
830 // http://www.w3.org/TR/css3-syntax/#starts-with-a-number
831 bool CSSTokenizer::nextCharsAreNumber(UChar first)
832 {
833     UChar second = m_input.peekWithoutReplacement(0);
834     if (isASCIIDigit(first))
835         return true;
836     if (first == &#39;+&#39; || first == &#39;-&#39;)
837         return ((isASCIIDigit(second)) || (second == &#39;.&#39; &amp;&amp; isASCIIDigit(m_input.peekWithoutReplacement(1))));
838     if (first ==&#39;.&#39;)
839         return (isASCIIDigit(second));
840     return false;
841 }
842 
843 bool CSSTokenizer::nextCharsAreNumber()
844 {
845     UChar first = consume();
846     bool areNumber = nextCharsAreNumber(first);
847     reconsume(first);
848     return areNumber;
849 }
850 
851 // http://dev.w3.org/csswg/css-syntax/#would-start-an-identifier
852 bool CSSTokenizer::nextCharsAreIdentifier(UChar first)
853 {
854     UChar second = m_input.peekWithoutReplacement(0);
855     if (isNameStartCodePoint(first) || twoCharsAreValidEscape(first, second))
856         return true;
857 
858     if (first == &#39;-&#39;)
859         return isNameStartCodePoint(second) || second == &#39;-&#39; || nextTwoCharsAreValidEscape();
860 
861     return false;
862 }
863 
864 bool CSSTokenizer::nextCharsAreIdentifier()
865 {
866     UChar first = consume();
867     bool areIdentifier = nextCharsAreIdentifier(first);
868     reconsume(first);
869     return areIdentifier;
870 }
871 
872 StringView CSSTokenizer::registerString(const String&amp; string)
873 {
874     m_stringPool.append(string);
875     return string;
876 }
877 
878 } // namespace WebCore
    </pre>
  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerThread.cpp b/modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerThread.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerThread.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerThread.cpp
@@ -25,17 +25,15 @@
  */
 
 #include "config.h"
 #include "WorkerThread.h"
 
-#include "ContentSecurityPolicyResponseHeaders.h"
 #include "IDBConnectionProxy.h"
 #include "ScriptSourceCode.h"
 #include "SecurityOrigin.h"
 #include "SocketProvider.h"
 #include "ThreadGlobalData.h"
-#include <wtf/URL.h>
 #include "WorkerGlobalScope.h"
 #include "WorkerInspectorController.h"
 #include <utility>
 #include <wtf/Lock.h>
 #include <wtf/NeverDestroyed.h>
@@ -73,54 +71,53 @@
 {
     LockHolder lock(workerThreadsMutex());
     return workerThreads(lock).size();
 }
 
+WorkerParameters WorkerParameters::isolatedCopy() const
+{
+    return {
+        scriptURL.isolatedCopy(),
+        name.isolatedCopy(),
+        identifier.isolatedCopy(),
+        userAgent.isolatedCopy(),
+        isOnline,
+        contentSecurityPolicyResponseHeaders,
+        shouldBypassMainWorldContentSecurityPolicy,
+        timeOrigin,
+        referrerPolicy,
+    };
+}
+
 struct WorkerThreadStartupData {
     WTF_MAKE_NONCOPYABLE(WorkerThreadStartupData); WTF_MAKE_FAST_ALLOCATED;
 public:
-    WorkerThreadStartupData(const URL& scriptURL, const String& name, const String& identifier, const String& userAgent, bool isOnline, const String& sourceCode, WorkerThreadStartMode, const ContentSecurityPolicyResponseHeaders&, bool shouldBypassMainWorldContentSecurityPolicy, const SecurityOrigin& topOrigin, MonotonicTime timeOrigin, PAL::SessionID);
-
-    URL m_scriptURL;
-    Ref<SecurityOrigin> m_origin;
-    String m_name;
-    String m_identifier;
-    String m_userAgent;
-    String m_sourceCode;
-    WorkerThreadStartMode m_startMode;
-    ContentSecurityPolicyResponseHeaders m_contentSecurityPolicyResponseHeaders;
-    bool m_shouldBypassMainWorldContentSecurityPolicy;
-    bool m_isOnline;
-    Ref<SecurityOrigin> m_topOrigin;
-    MonotonicTime m_timeOrigin;
-    PAL::SessionID m_sessionID;
+    WorkerThreadStartupData(const WorkerParameters& params, const String& sourceCode, WorkerThreadStartMode, const SecurityOrigin& topOrigin);
+
+    WorkerParameters params;
+    Ref<SecurityOrigin> origin;
+    String sourceCode;
+    WorkerThreadStartMode startMode;
+    Ref<SecurityOrigin> topOrigin;
 };
 
-WorkerThreadStartupData::WorkerThreadStartupData(const URL& scriptURL, const String& name, const String& identifier, const String& userAgent, bool isOnline, const String& sourceCode, WorkerThreadStartMode startMode, const ContentSecurityPolicyResponseHeaders& contentSecurityPolicyResponseHeaders, bool shouldBypassMainWorldContentSecurityPolicy, const SecurityOrigin& topOrigin, MonotonicTime timeOrigin, PAL::SessionID sessionID)
-    : m_scriptURL(scriptURL.isolatedCopy())
-    , m_origin(SecurityOrigin::create(m_scriptURL)->isolatedCopy())
-    , m_name(name.isolatedCopy())
-    , m_identifier(identifier.isolatedCopy())
-    , m_userAgent(userAgent.isolatedCopy())
-    , m_sourceCode(sourceCode.isolatedCopy())
-    , m_startMode(startMode)
-    , m_contentSecurityPolicyResponseHeaders(contentSecurityPolicyResponseHeaders.isolatedCopy())
-    , m_shouldBypassMainWorldContentSecurityPolicy(shouldBypassMainWorldContentSecurityPolicy)
-    , m_isOnline(isOnline)
-    , m_topOrigin(topOrigin.isolatedCopy())
-    , m_timeOrigin(timeOrigin)
-    , m_sessionID(sessionID.isolatedCopy())
+WorkerThreadStartupData::WorkerThreadStartupData(const WorkerParameters& other, const String& sourceCode, WorkerThreadStartMode startMode, const SecurityOrigin& topOrigin)
+    : params(other.isolatedCopy())
+    , origin(SecurityOrigin::create(other.scriptURL)->isolatedCopy())
+    , sourceCode(sourceCode.isolatedCopy())
+    , startMode(startMode)
+    , topOrigin(topOrigin.isolatedCopy())
 {
 }
 
-WorkerThread::WorkerThread(const URL& scriptURL, const String& name, const String& identifier, const String& userAgent, bool isOnline, const String& sourceCode, WorkerLoaderProxy& workerLoaderProxy, WorkerDebuggerProxy& workerDebuggerProxy, WorkerReportingProxy& workerReportingProxy, WorkerThreadStartMode startMode, const ContentSecurityPolicyResponseHeaders& contentSecurityPolicyResponseHeaders, bool shouldBypassMainWorldContentSecurityPolicy, const SecurityOrigin& topOrigin, MonotonicTime timeOrigin, IDBClient::IDBConnectionProxy* connectionProxy, SocketProvider* socketProvider, JSC::RuntimeFlags runtimeFlags, PAL::SessionID sessionID)
-    : m_identifier(identifier.isolatedCopy())
+WorkerThread::WorkerThread(const WorkerParameters& params, const String& sourceCode, WorkerLoaderProxy& workerLoaderProxy, WorkerDebuggerProxy& workerDebuggerProxy, WorkerReportingProxy& workerReportingProxy, WorkerThreadStartMode startMode, const SecurityOrigin& topOrigin, IDBClient::IDBConnectionProxy* connectionProxy, SocketProvider* socketProvider, JSC::RuntimeFlags runtimeFlags)
+    : m_identifier(params.identifier.isolatedCopy())
     , m_workerLoaderProxy(workerLoaderProxy)
     , m_workerDebuggerProxy(workerDebuggerProxy)
     , m_workerReportingProxy(workerReportingProxy)
     , m_runtimeFlags(runtimeFlags)
-    , m_startupData(makeUnique<WorkerThreadStartupData>(scriptURL, name, identifier, userAgent, isOnline, sourceCode, startMode, contentSecurityPolicyResponseHeaders, shouldBypassMainWorldContentSecurityPolicy, topOrigin, timeOrigin, sessionID))
+    , m_startupData(makeUnique<WorkerThreadStartupData>(params, sourceCode, startMode, topOrigin))
 #if ENABLE(INDEXED_DATABASE)
     , m_idbConnectionProxy(connectionProxy)
 #endif
     , m_socketProvider(socketProvider)
 {
@@ -175,11 +172,11 @@
     {
         // Mutex protection is necessary to ensure that we don't change m_workerGlobalScope
         // while WorkerThread::stop() is accessing it. Note that WorkerThread::stop() can
         // be called before we've finished creating the WorkerGlobalScope.
         LockHolder lock(m_threadCreationAndWorkerGlobalScopeMutex);
-        m_workerGlobalScope = createWorkerGlobalScope(m_startupData->m_scriptURL, WTFMove(m_startupData->m_origin), m_startupData->m_name, m_startupData->m_identifier, m_startupData->m_userAgent, m_startupData->m_isOnline, m_startupData->m_contentSecurityPolicyResponseHeaders, m_startupData->m_shouldBypassMainWorldContentSecurityPolicy, WTFMove(m_startupData->m_topOrigin), m_startupData->m_timeOrigin, m_startupData->m_sessionID);
+        m_workerGlobalScope = createWorkerGlobalScope(m_startupData->params, WTFMove(m_startupData->origin), WTFMove(m_startupData->topOrigin));
 
         scriptController = m_workerGlobalScope->script();
 
         if (m_runLoop.terminated()) {
             // The worker was terminated before the thread had a chance to run. Since the context didn't exist yet,
@@ -187,20 +184,22 @@
             scriptController->scheduleExecutionTermination();
             scriptController->forbidExecution();
         }
     }
 
-    if (m_startupData->m_startMode == WorkerThreadStartMode::WaitForInspector) {
+    if (m_startupData->startMode == WorkerThreadStartMode::WaitForInspector) {
         startRunningDebuggerTasks();
 
         // If the worker was somehow terminated while processing debugger commands.
         if (m_runLoop.terminated())
             scriptController->forbidExecution();
     }
 
     String exceptionMessage;
-    scriptController->evaluate(ScriptSourceCode(m_startupData->m_sourceCode, URL(m_startupData->m_scriptURL)), &exceptionMessage);
+    scriptController->evaluate(ScriptSourceCode(m_startupData->sourceCode, URL(m_startupData->params.scriptURL)), &exceptionMessage);
+
+    finishedEvaluatingScript();
 
     callOnMainThread([evaluateCallback = WTFMove(m_evaluateCallback), message = exceptionMessage.isolatedCopy()] {
         if (evaluateCallback)
             evaluateCallback(message);
     });
@@ -270,10 +269,35 @@
 {
     // Does not return until terminated.
     m_runLoop.run(m_workerGlobalScope.get());
 }
 
+void WorkerThread::suspend()
+{
+    m_isSuspended = true;
+    runLoop().postTask([&](ScriptExecutionContext&) {
+#if ENABLE(INDEXED_DATABASE)
+        if (m_workerGlobalScope)
+            m_workerGlobalScope->suspend();
+#endif
+
+        m_suspensionSemaphore.wait();
+
+#if ENABLE(INDEXED_DATABASE)
+        if (m_workerGlobalScope)
+            m_workerGlobalScope->resume();
+#endif
+    });
+}
+
+void WorkerThread::resume()
+{
+    ASSERT(m_isSuspended);
+    m_isSuspended = false;
+    m_suspensionSemaphore.signal();
+}
+
 void WorkerThread::stop(WTF::Function<void()>&& stoppedCallback)
 {
     // Mutex protection is necessary to ensure that m_workerGlobalScope isn't changed by
     // WorkerThread::workerThread() while we're accessing it. Note also that stop() can
     // be called before m_workerGlobalScope is fully created.
@@ -285,10 +309,14 @@
             stop(WTFMove(stoppedCallback));
         });
         return;
     }
 
+    // If the thread is suspended, resume it now so that we can dispatch the cleanup tasks below.
+    if (m_isSuspended)
+        resume();
+
     ASSERT(!m_stoppedCallback);
     m_stoppedCallback = WTFMove(stoppedCallback);
 
     // Ensure that tasks are being handled by thread event loop. If script execution weren't forbidden, a while(1) loop in JS could keep the thread alive forever.
     if (m_workerGlobalScope) {

diff a/modules/javafx.web/src/main/native/Source/WebCore/page/animation/CSSAnimationController.cpp b/modules/javafx.web/src/main/native/Source/WebCore/page/animation/CSSAnimationController.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/page/animation/CSSAnimationController.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/page/animation/CSSAnimationController.cpp
@@ -148,11 +148,11 @@
             if (timeToNextService && timeToNextService.value() == 0_s) {
                 if (callSetChanged != CallSetChanged)
                     break;
 
                 Element& element = *compositeAnimation.key;
-                ASSERT(element.document().pageCacheState() == Document::NotInPageCache);
+                ASSERT(element.document().backForwardCacheState() == Document::NotInBackForwardCache);
                 element.invalidateStyle();
                 calledSetChanged = true;
             }
         }
     }
@@ -223,13 +223,13 @@
     // fire all the events
     Vector<EventToDispatch> eventsToDispatch = WTFMove(m_eventsToDispatch);
     for (auto& event : eventsToDispatch) {
         Element& element = event.element;
         if (event.eventType == eventNames().transitionendEvent)
-            element.dispatchEvent(TransitionEvent::create(event.eventType, event.name, event.elapsedTime, PseudoElement::pseudoElementNameForEvents(element.pseudoId())));
+            element.dispatchEvent(TransitionEvent::create(event.eventType, event.name, event.elapsedTime, PseudoElement::pseudoElementNameForEvents(element.pseudoId()), WTF::nullopt, nullptr));
         else
-            element.dispatchEvent(AnimationEvent::create(event.eventType, event.name, event.elapsedTime));
+            element.dispatchEvent(AnimationEvent::create(event.eventType, event.name, event.elapsedTime, PseudoElement::pseudoElementNameForEvents(element.pseudoId()), WTF::nullopt, nullptr));
     }
 
     for (auto& change : m_elementChangesToDispatch)
         change->invalidateStyle();
 
@@ -252,11 +252,11 @@
 }
 
 void CSSAnimationControllerPrivate::addElementChangeToDispatch(Element& element)
 {
     m_elementChangesToDispatch.append(element);
-    ASSERT(m_elementChangesToDispatch.last()->document().pageCacheState() == Document::NotInPageCache);
+    ASSERT(m_elementChangesToDispatch.last()->document().backForwardCacheState() == Document::NotInBackForwardCache);
     startUpdateStyleIfNeededDispatcher();
 }
 
 void CSSAnimationControllerPrivate::animationFrameCallbackFired()
 {
@@ -607,21 +607,21 @@
     if (!m_data->clear(element))
         return;
 
     if (element.document().renderTreeBeingDestroyed())
         return;
-    ASSERT(element.document().pageCacheState() == Document::NotInPageCache);
+    ASSERT(element.document().backForwardCacheState() == Document::NotInBackForwardCache);
     element.invalidateStyle();
 }
 
 AnimationUpdate CSSAnimationController::updateAnimations(Element& element, const RenderStyle& newStyle, const RenderStyle* oldStyle)
 {
     bool hasOrHadAnimations = (oldStyle && oldStyle->hasAnimationsOrTransitions()) || newStyle.hasAnimationsOrTransitions();
     if (!hasOrHadAnimations)
         return { };
 
-    if (element.document().pageCacheState() != Document::NotInPageCache)
+    if (element.document().backForwardCacheState() != Document::NotInBackForwardCache)
         return { };
 
     // Don't run transitions when printing.
     if (element.document().renderView()->printing())
         return { };

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/AccessCase.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AccessCase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessCaseSnippetParams.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/AccessCase.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2017 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(JIT)
 29 

 30 #include &quot;JSFunctionInlines.h&quot;
 31 #include &quot;ObjectPropertyConditionSet.h&quot;
 32 #include &quot;PolyProtoAccessChain.h&quot;
 33 #include &lt;wtf/CommaPrinter.h&gt;
 34 
 35 namespace JSC {
 36 
 37 struct AccessGenerationState;
 38 


 39 // An AccessCase describes one of the cases of a PolymorphicAccess. A PolymorphicAccess represents a
 40 // planned (to generate in future) or generated stub for some inline cache. That stub contains fast
 41 // path code for some finite number of fast cases, each described by an AccessCase object.
 42 //
 43 // An AccessCase object has a lifecycle that proceeds through several states. Note that the states
 44 // of AccessCase have a lot to do with the global effect epoch (we&#39;ll say epoch for short). This is
 45 // a simple way of reasoning about the state of the system outside this AccessCase. Any observable
 46 // effect - like storing to a property, changing an object&#39;s structure, etc. - increments the epoch.
 47 // The states are:
 48 //
 49 // Primordial:   This is an AccessCase that was just allocated. It does not correspond to any actual
 50 //               code and it is not owned by any PolymorphicAccess. In this state, the AccessCase
 51 //               assumes that it is in the same epoch as when it was created. This is important
 52 //               because it may make claims about itself (&quot;I represent a valid case so long as you
 53 //               register a watchpoint on this set&quot;) that could be contradicted by some outside
 54 //               effects (like firing and deleting the watchpoint set in question). This is also the
 55 //               state that an AccessCase is in when it is cloned (AccessCase::clone()).
 56 //
 57 // Committed:    This happens as soon as some PolymorphicAccess takes ownership of this AccessCase.
 58 //               In this state, the AccessCase no longer assumes anything about the epoch. To
</pre>
<hr />
<pre>
 60 //               during the same epoch when the AccessCase was created, either by the client or by
 61 //               clone(). When created by the client, committing during the same epoch works because
 62 //               we can be sure that whatever watchpoint sets they spoke of are still valid. When
 63 //               created by clone(), we can be sure that the set is still valid because the original
 64 //               of the clone still has watchpoints on it.
 65 //
 66 // Generated:    This is the state when the PolymorphicAccess generates code for this case by
 67 //               calling AccessCase::generate() or AccessCase::generateWithGuard(). At this point
 68 //               the case object will have some extra stuff in it, like possibly the CallLinkInfo
 69 //               object associated with the inline cache.
 70 //               FIXME: Moving into the Generated state should not mutate the AccessCase object or
 71 //               put more stuff into it. If we fix this, then we can get rid of AccessCase::clone().
 72 //               https://bugs.webkit.org/show_bug.cgi?id=156456
 73 //
 74 // An AccessCase may be destroyed while in any of these states.
 75 //
 76 // We will sometimes buffer committed AccessCases in the PolymorphicAccess object before generating
 77 // code. This allows us to only regenerate once we&#39;ve accumulated (hopefully) more than one new
 78 // AccessCase.
 79 class AccessCase {
<span class="line-modified"> 80     WTF_MAKE_FAST_ALLOCATED;</span>
 81 public:
 82     enum AccessType : uint8_t {
 83         Load,
 84         Transition,
 85         Replace,
 86         Miss,
 87         GetGetter,
 88         Getter,
 89         Setter,
 90         CustomValueGetter,
 91         CustomAccessorGetter,
 92         CustomValueSetter,
 93         CustomAccessorSetter,
 94         IntrinsicGetter,
 95         InHit,
 96         InMiss,
 97         ArrayLength,
 98         StringLength,
 99         DirectArgumentsLength,
100         ScopedArgumentsLength,
101         ModuleNamespaceLoad,
102         InstanceOfHit,
103         InstanceOfMiss,
<span class="line-modified">104         InstanceOfGeneric</span>
















105     };
106 
107     enum State : uint8_t {
108         Primordial,
109         Committed,
110         Generated
111     };
112 
113     template&lt;typename T&gt;
114     T&amp; as() { return *static_cast&lt;T*&gt;(this); }
115 
116     template&lt;typename T&gt;
117     const T&amp; as() const { return *static_cast&lt;const T*&gt;(this); }
118 
119 
120     template&lt;typename AccessCaseType, typename... Arguments&gt;
121     static std::unique_ptr&lt;AccessCaseType&gt; create(Arguments... arguments)
122     {
123         return std::unique_ptr&lt;AccessCaseType&gt;(new AccessCaseType(arguments...));
124     }
125 
<span class="line-modified">126     static std::unique_ptr&lt;AccessCase&gt; create(VM&amp;, JSCell* owner, AccessType, PropertyOffset = invalidOffset,</span>
127         Structure* = nullptr, const ObjectPropertyConditionSet&amp; = ObjectPropertyConditionSet(), std::unique_ptr&lt;PolyProtoAccessChain&gt; = nullptr);
128 
129     // This create method should be used for transitions.
<span class="line-modified">130     static std::unique_ptr&lt;AccessCase&gt; create(VM&amp;, JSCell* owner, PropertyOffset, Structure* oldStructure,</span>
131         Structure* newStructure, const ObjectPropertyConditionSet&amp;, std::unique_ptr&lt;PolyProtoAccessChain&gt;);
132 
<span class="line-modified">133     static std::unique_ptr&lt;AccessCase&gt; fromStructureStubInfo(VM&amp;, JSCell* owner, StructureStubInfo&amp;);</span>
134 
135     AccessType type() const { return m_type; }
136     State state() const { return m_state; }
137     PropertyOffset offset() const { return m_offset; }
138 
139     Structure* structure() const
140     {
141         if (m_type == Transition)
142             return m_structure-&gt;previousID();
143         return m_structure.get();
144     }
<span class="line-modified">145     bool guardedByStructureCheck() const;</span>
146 
147     Structure* newStructure() const
148     {
149         ASSERT(m_type == Transition);
150         return m_structure.get();
151     }
152 
153     ObjectPropertyConditionSet conditionSet() const { return m_conditionSet; }
154 
155     virtual bool hasAlternateBase() const;
156     virtual JSObject* alternateBase() const;
157 
158     virtual WatchpointSet* additionalSet() const { return nullptr; }
159     bool viaProxy() const { return m_viaProxy; }
160 
161     // If you supply the optional vector, this will append the set of cells that this will need to keep alive
162     // past the call.
<span class="line-modified">163     bool doesCalls(Vector&lt;JSCell*&gt;* cellsToMark = nullptr) const;</span>













164 
165     bool isGetter() const
166     {
167         switch (type()) {
168         case Getter:
169         case CustomValueGetter:
170         case CustomAccessorGetter:
171             return true;
172         default:
173             return false;
174         }
175     }
176 
177     bool isAccessor() const { return isGetter() || type() == Setter; }
178 
179     // Is it still possible for this case to ever be taken? Must call this as a prerequisite for
180     // calling generate() and friends. If this returns true, then you can call generate(). If
181     // this returns false, then generate() will crash. You must call generate() in the same epoch
182     // as when you called couldStillSucceed().
183     bool couldStillSucceed() const;
184 
185     // If this method returns true, then it&#39;s a good idea to remove &#39;other&#39; from the access once &#39;this&#39;
186     // is added. This method assumes that in case of contradictions, &#39;this&#39; represents a newer, and so
187     // more useful, truth. This method can be conservative; it will return false when it doubt.
188     bool canReplace(const AccessCase&amp; other) const;
189 
190     void dump(PrintStream&amp; out) const;
191     virtual void dumpImpl(PrintStream&amp;, CommaPrinter&amp;) const { }
192 
193     virtual ~AccessCase();
194 
195     bool usesPolyProto() const
196     {
197         return !!m_polyProtoAccessChain;
198     }
199 















200 protected:
<span class="line-modified">201     AccessCase(VM&amp;, JSCell* owner, AccessType, PropertyOffset, Structure*, const ObjectPropertyConditionSet&amp;, std::unique_ptr&lt;PolyProtoAccessChain&gt;);</span>
202     AccessCase(AccessCase&amp;&amp;) = default;
203     AccessCase(const AccessCase&amp; other)
204         : m_type(other.m_type)
205         , m_state(other.m_state)
206         , m_viaProxy(other.m_viaProxy)
207         , m_offset(other.m_offset)
208         , m_structure(other.m_structure)
209         , m_conditionSet(other.m_conditionSet)

210     {
211         if (other.m_polyProtoAccessChain)
212             m_polyProtoAccessChain = other.m_polyProtoAccessChain-&gt;clone();
213     }
214 
215     AccessCase&amp; operator=(const AccessCase&amp;) = delete;
216     void resetState() { m_state = Primordial; }
217 
218 private:
219     friend class CodeBlock;
220     friend class PolymorphicAccess;
221 




222     bool visitWeak(VM&amp;) const;
223     bool propagateTransitions(SlotVisitor&amp;) const;
224 
225     // FIXME: This only exists because of how AccessCase puts post-generation things into itself.
226     // https://bugs.webkit.org/show_bug.cgi?id=156456
227     virtual std::unique_ptr&lt;AccessCase&gt; clone() const;
228 
229     // Perform any action that must be performed before the end of the epoch in which the case
230     // was created. Returns a set of watchpoint sets that will need to be watched.
<span class="line-modified">231     Vector&lt;WatchpointSet*, 2&gt; commit(VM&amp;, const Identifier&amp;);</span>
232 
233     // Fall through on success. Two kinds of failures are supported: fall-through, which means that we
234     // should try a different case; and failure, which means that this was the right case but it needs
235     // help from the slow path.
236     void generateWithGuard(AccessGenerationState&amp;, MacroAssembler::JumpList&amp; fallThrough);
237 
238     // Fall through on success, add a jump to the failure list on failure.
239     void generate(AccessGenerationState&amp;);
240 
241     void generateImpl(AccessGenerationState&amp;);
242 


243     AccessType m_type;
244     State m_state { Primordial };
245 protected:
246     // m_viaProxy is true only if the instance inherits (or it is) ProxyableAccessCase.
247     // We put this value here instead of ProxyableAccessCase to reduce the size of ProxyableAccessCase and its
248     // derived classes, which are super frequently allocated.
249     bool m_viaProxy { false };
250 private:
251     PropertyOffset m_offset;
252 
253     // Usually this is the structure that we expect the base object to have. But, this is the *new*
254     // structure for a transition and we rely on the fact that it has a strong reference to the old
255     // structure. For proxies, this is the structure of the object behind the proxy.
256     WriteBarrier&lt;Structure&gt; m_structure;
257 
258     ObjectPropertyConditionSet m_conditionSet;
259 
260     std::unique_ptr&lt;PolyProtoAccessChain&gt; m_polyProtoAccessChain;


261 };
262 
263 } // namespace JSC
264 
265 #endif
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2017-2020 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(JIT)
 29 
<span class="line-added"> 30 #include &quot;CacheableIdentifier.h&quot;</span>
 31 #include &quot;JSFunctionInlines.h&quot;
 32 #include &quot;ObjectPropertyConditionSet.h&quot;
 33 #include &quot;PolyProtoAccessChain.h&quot;
 34 #include &lt;wtf/CommaPrinter.h&gt;
 35 
 36 namespace JSC {
 37 
 38 struct AccessGenerationState;
 39 
<span class="line-added"> 40 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(AccessCase);</span>
<span class="line-added"> 41 </span>
 42 // An AccessCase describes one of the cases of a PolymorphicAccess. A PolymorphicAccess represents a
 43 // planned (to generate in future) or generated stub for some inline cache. That stub contains fast
 44 // path code for some finite number of fast cases, each described by an AccessCase object.
 45 //
 46 // An AccessCase object has a lifecycle that proceeds through several states. Note that the states
 47 // of AccessCase have a lot to do with the global effect epoch (we&#39;ll say epoch for short). This is
 48 // a simple way of reasoning about the state of the system outside this AccessCase. Any observable
 49 // effect - like storing to a property, changing an object&#39;s structure, etc. - increments the epoch.
 50 // The states are:
 51 //
 52 // Primordial:   This is an AccessCase that was just allocated. It does not correspond to any actual
 53 //               code and it is not owned by any PolymorphicAccess. In this state, the AccessCase
 54 //               assumes that it is in the same epoch as when it was created. This is important
 55 //               because it may make claims about itself (&quot;I represent a valid case so long as you
 56 //               register a watchpoint on this set&quot;) that could be contradicted by some outside
 57 //               effects (like firing and deleting the watchpoint set in question). This is also the
 58 //               state that an AccessCase is in when it is cloned (AccessCase::clone()).
 59 //
 60 // Committed:    This happens as soon as some PolymorphicAccess takes ownership of this AccessCase.
 61 //               In this state, the AccessCase no longer assumes anything about the epoch. To
</pre>
<hr />
<pre>
 63 //               during the same epoch when the AccessCase was created, either by the client or by
 64 //               clone(). When created by the client, committing during the same epoch works because
 65 //               we can be sure that whatever watchpoint sets they spoke of are still valid. When
 66 //               created by clone(), we can be sure that the set is still valid because the original
 67 //               of the clone still has watchpoints on it.
 68 //
 69 // Generated:    This is the state when the PolymorphicAccess generates code for this case by
 70 //               calling AccessCase::generate() or AccessCase::generateWithGuard(). At this point
 71 //               the case object will have some extra stuff in it, like possibly the CallLinkInfo
 72 //               object associated with the inline cache.
 73 //               FIXME: Moving into the Generated state should not mutate the AccessCase object or
 74 //               put more stuff into it. If we fix this, then we can get rid of AccessCase::clone().
 75 //               https://bugs.webkit.org/show_bug.cgi?id=156456
 76 //
 77 // An AccessCase may be destroyed while in any of these states.
 78 //
 79 // We will sometimes buffer committed AccessCases in the PolymorphicAccess object before generating
 80 // code. This allows us to only regenerate once we&#39;ve accumulated (hopefully) more than one new
 81 // AccessCase.
 82 class AccessCase {
<span class="line-modified"> 83     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(AccessCase);</span>
 84 public:
 85     enum AccessType : uint8_t {
 86         Load,
 87         Transition,
 88         Replace,
 89         Miss,
 90         GetGetter,
 91         Getter,
 92         Setter,
 93         CustomValueGetter,
 94         CustomAccessorGetter,
 95         CustomValueSetter,
 96         CustomAccessorSetter,
 97         IntrinsicGetter,
 98         InHit,
 99         InMiss,
100         ArrayLength,
101         StringLength,
102         DirectArgumentsLength,
103         ScopedArgumentsLength,
104         ModuleNamespaceLoad,
105         InstanceOfHit,
106         InstanceOfMiss,
<span class="line-modified">107         InstanceOfGeneric,</span>
<span class="line-added">108         IndexedInt32Load,</span>
<span class="line-added">109         IndexedDoubleLoad,</span>
<span class="line-added">110         IndexedContiguousLoad,</span>
<span class="line-added">111         IndexedArrayStorageLoad,</span>
<span class="line-added">112         IndexedScopedArgumentsLoad,</span>
<span class="line-added">113         IndexedDirectArgumentsLoad,</span>
<span class="line-added">114         IndexedTypedArrayInt8Load,</span>
<span class="line-added">115         IndexedTypedArrayUint8Load,</span>
<span class="line-added">116         IndexedTypedArrayUint8ClampedLoad,</span>
<span class="line-added">117         IndexedTypedArrayInt16Load,</span>
<span class="line-added">118         IndexedTypedArrayUint16Load,</span>
<span class="line-added">119         IndexedTypedArrayInt32Load,</span>
<span class="line-added">120         IndexedTypedArrayUint32Load,</span>
<span class="line-added">121         IndexedTypedArrayFloat32Load,</span>
<span class="line-added">122         IndexedTypedArrayFloat64Load,</span>
<span class="line-added">123         IndexedStringLoad</span>
124     };
125 
126     enum State : uint8_t {
127         Primordial,
128         Committed,
129         Generated
130     };
131 
132     template&lt;typename T&gt;
133     T&amp; as() { return *static_cast&lt;T*&gt;(this); }
134 
135     template&lt;typename T&gt;
136     const T&amp; as() const { return *static_cast&lt;const T*&gt;(this); }
137 
138 
139     template&lt;typename AccessCaseType, typename... Arguments&gt;
140     static std::unique_ptr&lt;AccessCaseType&gt; create(Arguments... arguments)
141     {
142         return std::unique_ptr&lt;AccessCaseType&gt;(new AccessCaseType(arguments...));
143     }
144 
<span class="line-modified">145     static std::unique_ptr&lt;AccessCase&gt; create(VM&amp;, JSCell* owner, AccessType, CacheableIdentifier, PropertyOffset = invalidOffset,</span>
146         Structure* = nullptr, const ObjectPropertyConditionSet&amp; = ObjectPropertyConditionSet(), std::unique_ptr&lt;PolyProtoAccessChain&gt; = nullptr);
147 
148     // This create method should be used for transitions.
<span class="line-modified">149     static std::unique_ptr&lt;AccessCase&gt; create(VM&amp;, JSCell* owner, CacheableIdentifier, PropertyOffset, Structure* oldStructure,</span>
150         Structure* newStructure, const ObjectPropertyConditionSet&amp;, std::unique_ptr&lt;PolyProtoAccessChain&gt;);
151 
<span class="line-modified">152     static std::unique_ptr&lt;AccessCase&gt; fromStructureStubInfo(VM&amp;, JSCell* owner, CacheableIdentifier, StructureStubInfo&amp;);</span>
153 
154     AccessType type() const { return m_type; }
155     State state() const { return m_state; }
156     PropertyOffset offset() const { return m_offset; }
157 
158     Structure* structure() const
159     {
160         if (m_type == Transition)
161             return m_structure-&gt;previousID();
162         return m_structure.get();
163     }
<span class="line-modified">164     bool guardedByStructureCheck(const StructureStubInfo&amp;) const;</span>
165 
166     Structure* newStructure() const
167     {
168         ASSERT(m_type == Transition);
169         return m_structure.get();
170     }
171 
172     ObjectPropertyConditionSet conditionSet() const { return m_conditionSet; }
173 
174     virtual bool hasAlternateBase() const;
175     virtual JSObject* alternateBase() const;
176 
177     virtual WatchpointSet* additionalSet() const { return nullptr; }
178     bool viaProxy() const { return m_viaProxy; }
179 
180     // If you supply the optional vector, this will append the set of cells that this will need to keep alive
181     // past the call.
<span class="line-modified">182     bool doesCalls(VM&amp;, Vector&lt;JSCell*&gt;* cellsToMark = nullptr) const;</span>
<span class="line-added">183 </span>
<span class="line-added">184     bool isCustom() const</span>
<span class="line-added">185     {</span>
<span class="line-added">186         switch (type()) {</span>
<span class="line-added">187         case CustomValueGetter:</span>
<span class="line-added">188         case CustomAccessorGetter:</span>
<span class="line-added">189         case CustomValueSetter:</span>
<span class="line-added">190         case CustomAccessorSetter:</span>
<span class="line-added">191             return true;</span>
<span class="line-added">192         default:</span>
<span class="line-added">193             return false;</span>
<span class="line-added">194         }</span>
<span class="line-added">195     }</span>
196 
197     bool isGetter() const
198     {
199         switch (type()) {
200         case Getter:
201         case CustomValueGetter:
202         case CustomAccessorGetter:
203             return true;
204         default:
205             return false;
206         }
207     }
208 
209     bool isAccessor() const { return isGetter() || type() == Setter; }
210 
211     // Is it still possible for this case to ever be taken? Must call this as a prerequisite for
212     // calling generate() and friends. If this returns true, then you can call generate(). If
213     // this returns false, then generate() will crash. You must call generate() in the same epoch
214     // as when you called couldStillSucceed().
215     bool couldStillSucceed() const;
216 
217     // If this method returns true, then it&#39;s a good idea to remove &#39;other&#39; from the access once &#39;this&#39;
218     // is added. This method assumes that in case of contradictions, &#39;this&#39; represents a newer, and so
219     // more useful, truth. This method can be conservative; it will return false when it doubt.
220     bool canReplace(const AccessCase&amp; other) const;
221 
222     void dump(PrintStream&amp; out) const;
223     virtual void dumpImpl(PrintStream&amp;, CommaPrinter&amp;) const { }
224 
225     virtual ~AccessCase();
226 
227     bool usesPolyProto() const
228     {
229         return !!m_polyProtoAccessChain;
230     }
231 
<span class="line-added">232     bool requiresIdentifierNameMatch() const;</span>
<span class="line-added">233     bool requiresInt32PropertyCheck() const;</span>
<span class="line-added">234     bool needsScratchFPR() const;</span>
<span class="line-added">235 </span>
<span class="line-added">236     static TypedArrayType toTypedArrayType(AccessType);</span>
<span class="line-added">237 </span>
<span class="line-added">238     UniquedStringImpl* uid() const { return m_identifier.uid(); }</span>
<span class="line-added">239     CacheableIdentifier identifier() const { return m_identifier; }</span>
<span class="line-added">240 </span>
<span class="line-added">241 #if ASSERT_ENABLED</span>
<span class="line-added">242     void checkConsistency(StructureStubInfo&amp;);</span>
<span class="line-added">243 #else</span>
<span class="line-added">244     ALWAYS_INLINE void checkConsistency(StructureStubInfo&amp;) { }</span>
<span class="line-added">245 #endif</span>
<span class="line-added">246 </span>
247 protected:
<span class="line-modified">248     AccessCase(VM&amp;, JSCell* owner, AccessType, CacheableIdentifier, PropertyOffset, Structure*, const ObjectPropertyConditionSet&amp;, std::unique_ptr&lt;PolyProtoAccessChain&gt;);</span>
249     AccessCase(AccessCase&amp;&amp;) = default;
250     AccessCase(const AccessCase&amp; other)
251         : m_type(other.m_type)
252         , m_state(other.m_state)
253         , m_viaProxy(other.m_viaProxy)
254         , m_offset(other.m_offset)
255         , m_structure(other.m_structure)
256         , m_conditionSet(other.m_conditionSet)
<span class="line-added">257         , m_identifier(other.m_identifier)</span>
258     {
259         if (other.m_polyProtoAccessChain)
260             m_polyProtoAccessChain = other.m_polyProtoAccessChain-&gt;clone();
261     }
262 
263     AccessCase&amp; operator=(const AccessCase&amp;) = delete;
264     void resetState() { m_state = Primordial; }
265 
266 private:
267     friend class CodeBlock;
268     friend class PolymorphicAccess;
269 
<span class="line-added">270     template&lt;typename Functor&gt;</span>
<span class="line-added">271     void forEachDependentCell(VM&amp;, const Functor&amp;) const;</span>
<span class="line-added">272 </span>
<span class="line-added">273     void visitAggregate(SlotVisitor&amp;) const;</span>
274     bool visitWeak(VM&amp;) const;
275     bool propagateTransitions(SlotVisitor&amp;) const;
276 
277     // FIXME: This only exists because of how AccessCase puts post-generation things into itself.
278     // https://bugs.webkit.org/show_bug.cgi?id=156456
279     virtual std::unique_ptr&lt;AccessCase&gt; clone() const;
280 
281     // Perform any action that must be performed before the end of the epoch in which the case
282     // was created. Returns a set of watchpoint sets that will need to be watched.
<span class="line-modified">283     Vector&lt;WatchpointSet*, 2&gt; commit(VM&amp;);</span>
284 
285     // Fall through on success. Two kinds of failures are supported: fall-through, which means that we
286     // should try a different case; and failure, which means that this was the right case but it needs
287     // help from the slow path.
288     void generateWithGuard(AccessGenerationState&amp;, MacroAssembler::JumpList&amp; fallThrough);
289 
290     // Fall through on success, add a jump to the failure list on failure.
291     void generate(AccessGenerationState&amp;);
292 
293     void generateImpl(AccessGenerationState&amp;);
294 
<span class="line-added">295     bool guardedByStructureCheckSkippingConstantIdentifierCheck() const;</span>
<span class="line-added">296 </span>
297     AccessType m_type;
298     State m_state { Primordial };
299 protected:
300     // m_viaProxy is true only if the instance inherits (or it is) ProxyableAccessCase.
301     // We put this value here instead of ProxyableAccessCase to reduce the size of ProxyableAccessCase and its
302     // derived classes, which are super frequently allocated.
303     bool m_viaProxy { false };
304 private:
305     PropertyOffset m_offset;
306 
307     // Usually this is the structure that we expect the base object to have. But, this is the *new*
308     // structure for a transition and we rely on the fact that it has a strong reference to the old
309     // structure. For proxies, this is the structure of the object behind the proxy.
310     WriteBarrier&lt;Structure&gt; m_structure;
311 
312     ObjectPropertyConditionSet m_conditionSet;
313 
314     std::unique_ptr&lt;PolyProtoAccessChain&gt; m_polyProtoAccessChain;
<span class="line-added">315 </span>
<span class="line-added">316     CacheableIdentifier m_identifier;</span>
317 };
318 
319 } // namespace JSC
320 
321 #endif
</pre>
</td>
</tr>
</table>
<center><a href="AccessCase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessCaseSnippetParams.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
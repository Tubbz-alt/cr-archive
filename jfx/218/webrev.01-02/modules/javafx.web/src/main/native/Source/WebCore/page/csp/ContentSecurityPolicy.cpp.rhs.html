<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/page/csp/ContentSecurityPolicy.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011 Google, Inc. All rights reserved.
  3  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY GOOGLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;ContentSecurityPolicy.h&quot;
 29 
 30 #include &quot;ContentSecurityPolicyClient.h&quot;
 31 #include &quot;ContentSecurityPolicyDirective.h&quot;
 32 #include &quot;ContentSecurityPolicyDirectiveList.h&quot;
 33 #include &quot;ContentSecurityPolicyDirectiveNames.h&quot;
 34 #include &quot;ContentSecurityPolicyHash.h&quot;
 35 #include &quot;ContentSecurityPolicySource.h&quot;
 36 #include &quot;ContentSecurityPolicySourceList.h&quot;
 37 #include &quot;CustomHeaderFields.h&quot;
 38 #include &quot;DOMStringList.h&quot;
 39 #include &quot;Document.h&quot;
 40 #include &quot;DocumentLoader.h&quot;
 41 #include &quot;EventNames.h&quot;
 42 #include &quot;FormData.h&quot;
 43 #include &quot;Frame.h&quot;
 44 #include &quot;HTMLParserIdioms.h&quot;
 45 #include &quot;InspectorInstrumentation.h&quot;
 46 #include &quot;JSExecState.h&quot;
 47 #include &quot;JSWindowProxy.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 48 #include &quot;LegacySchemeRegistry.h&quot;</span>
 49 #include &quot;ParsingUtilities.h&quot;
 50 #include &quot;PingLoader.h&quot;
 51 #include &quot;ResourceRequest.h&quot;
<a name="2" id="anc2"></a>

 52 #include &quot;SecurityOrigin.h&quot;
 53 #include &quot;SecurityPolicyViolationEvent.h&quot;
 54 #include &quot;Settings.h&quot;
 55 #include &quot;TextEncoding.h&quot;
 56 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 57 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
 58 #include &lt;pal/crypto/CryptoDigest.h&gt;
 59 #include &lt;wtf/JSONValues.h&gt;
 60 #include &lt;wtf/SetForScope.h&gt;
 61 #include &lt;wtf/text/StringBuilder.h&gt;
 62 #include &lt;wtf/text/TextPosition.h&gt;
 63 
 64 
 65 namespace WebCore {
 66 using namespace Inspector;
 67 
 68 static String consoleMessageForViolation(const char* effectiveViolatedDirective, const ContentSecurityPolicyDirective&amp; violatedDirective, const URL&amp; blockedURL, const char* prefix, const char* subject = &quot;it&quot;)
 69 {
 70     StringBuilder result;
 71     if (violatedDirective.directiveList().isReportOnly())
 72         result.appendLiteral(&quot;[Report Only] &quot;);
 73     result.append(prefix);
 74     if (!blockedURL.isEmpty()) {
 75         result.append(&#39; &#39;);
 76         result.append(blockedURL.stringCenterEllipsizedToLength());
 77     }
 78     result.appendLiteral(&quot; because &quot;);
 79     result.append(subject);
 80     if (violatedDirective.isDefaultSrc()) {
 81         result.appendLiteral(&quot; appears in neither the &quot;);
 82         result.append(effectiveViolatedDirective);
 83         result.appendLiteral(&quot; directive nor the default-src directive of the Content Security Policy.&quot;);
 84     } else {
 85         result.appendLiteral(&quot; does not appear in the &quot;);
 86         result.append(effectiveViolatedDirective);
 87         result.appendLiteral(&quot; directive of the Content Security Policy.&quot;);
 88     }
 89     return result.toString();
 90 }
 91 
 92 ContentSecurityPolicy::ContentSecurityPolicy(URL&amp;&amp; protectedURL, ContentSecurityPolicyClient* client)
 93     : m_client { client }
 94     , m_protectedURL { WTFMove(protectedURL) }
 95 {
 96     updateSourceSelf(SecurityOrigin::create(m_protectedURL).get());
 97 }
 98 
 99 ContentSecurityPolicy::ContentSecurityPolicy(URL&amp;&amp; protectedURL, ScriptExecutionContext&amp; scriptExecutionContext)
100     : m_scriptExecutionContext(&amp;scriptExecutionContext)
101     , m_protectedURL { WTFMove(protectedURL) }
102 {
103     ASSERT(scriptExecutionContext.securityOrigin());
104     updateSourceSelf(*scriptExecutionContext.securityOrigin());
105 }
106 
107 ContentSecurityPolicy::~ContentSecurityPolicy() = default;
108 
109 void ContentSecurityPolicy::copyStateFrom(const ContentSecurityPolicy* other)
110 {
111     if (m_hasAPIPolicy)
112         return;
113     ASSERT(m_policies.isEmpty());
114     for (auto&amp; policy : other-&gt;m_policies)
115         didReceiveHeader(policy-&gt;header(), policy-&gt;headerType(), ContentSecurityPolicy::PolicyFrom::Inherited, String { });
116     m_referrer = other-&gt;m_referrer;
117     m_httpStatusCode = other-&gt;m_httpStatusCode;
118 }
119 
120 void ContentSecurityPolicy::createPolicyForPluginDocumentFrom(const ContentSecurityPolicy&amp; other)
121 {
122     if (m_hasAPIPolicy)
123         return;
124     ASSERT(m_policies.isEmpty());
125     for (auto&amp; policy : other.m_policies)
126         didReceiveHeader(policy-&gt;header(), policy-&gt;headerType(), ContentSecurityPolicy::PolicyFrom::InheritedForPluginDocument, String { });
127     m_referrer = other.m_referrer;
128     m_httpStatusCode = other.m_httpStatusCode;
129 }
130 
131 void ContentSecurityPolicy::copyUpgradeInsecureRequestStateFrom(const ContentSecurityPolicy&amp; other)
132 {
133     m_upgradeInsecureRequests = other.m_upgradeInsecureRequests;
134     m_insecureNavigationRequestsToUpgrade.add(other.m_insecureNavigationRequestsToUpgrade.begin(), other.m_insecureNavigationRequestsToUpgrade.end());
135 }
136 
137 bool ContentSecurityPolicy::allowRunningOrDisplayingInsecureContent(const URL&amp; url)
138 {
139     bool allow = true;
140     bool isReportOnly = false;
141     for (auto&amp; policy : m_policies) {
142         if (!policy-&gt;hasBlockAllMixedContentDirective())
143             continue;
144 
145         isReportOnly = policy-&gt;isReportOnly();
146 
147         StringBuilder consoleMessage;
148         if (isReportOnly)
149             consoleMessage.appendLiteral(&quot;[Report Only] &quot;);
150         consoleMessage.append(&quot;Blocked mixed content &quot;);
151         consoleMessage.append(url.stringCenterEllipsizedToLength());
152         consoleMessage.appendLiteral(&quot; because &quot;);
153         consoleMessage.append(&quot;&#39;block-all-mixed-content&#39; appears in the Content Security Policy.&quot;);
154         reportViolation(ContentSecurityPolicyDirectiveNames::blockAllMixedContent, ContentSecurityPolicyDirectiveNames::blockAllMixedContent, *policy, url, consoleMessage.toString());
155 
156         if (!isReportOnly)
157             allow = false;
158     }
159     return allow;
160 }
161 
162 void ContentSecurityPolicy::didCreateWindowProxy(JSWindowProxy&amp; windowProxy) const
163 {
164     auto* window = windowProxy.window();
165     ASSERT(window);
166     ASSERT(window-&gt;scriptExecutionContext());
167     ASSERT(window-&gt;scriptExecutionContext()-&gt;contentSecurityPolicy() == this);
168     if (!windowProxy.world().isNormal()) {
169         window-&gt;setEvalEnabled(true);
170         return;
171     }
172     window-&gt;setEvalEnabled(m_lastPolicyEvalDisabledErrorMessage.isNull(), m_lastPolicyEvalDisabledErrorMessage);
173     window-&gt;setWebAssemblyEnabled(m_lastPolicyWebAssemblyDisabledErrorMessage.isNull(), m_lastPolicyWebAssemblyDisabledErrorMessage);
174 }
175 
176 ContentSecurityPolicyResponseHeaders ContentSecurityPolicy::responseHeaders() const
177 {
178     if (!m_cachedResponseHeaders) {
179         ContentSecurityPolicyResponseHeaders result;
180         result.m_headers.reserveInitialCapacity(m_policies.size());
181         for (auto&amp; policy : m_policies)
182             result.m_headers.uncheckedAppend({ policy-&gt;header(), policy-&gt;headerType() });
183         result.m_httpStatusCode = m_httpStatusCode;
184         m_cachedResponseHeaders = WTFMove(result);
185     }
186     return *m_cachedResponseHeaders;
187 }
188 
189 void ContentSecurityPolicy::didReceiveHeaders(const ContentSecurityPolicyResponseHeaders&amp; headers, String&amp;&amp; referrer, ReportParsingErrors reportParsingErrors)
190 {
191     SetForScope&lt;bool&gt; isReportingEnabled(m_isReportingEnabled, reportParsingErrors == ReportParsingErrors::Yes);
192     for (auto&amp; header : headers.m_headers)
193         didReceiveHeader(header.first, header.second, ContentSecurityPolicy::PolicyFrom::HTTPHeader, String { });
194     m_referrer = WTFMove(referrer);
195     m_httpStatusCode = headers.m_httpStatusCode;
196 }
197 
198 void ContentSecurityPolicy::didReceiveHeader(const String&amp; header, ContentSecurityPolicyHeaderType type, ContentSecurityPolicy::PolicyFrom policyFrom, String&amp;&amp; referrer, int httpStatusCode)
199 {
200     if (m_hasAPIPolicy)
201         return;
202 
203     m_referrer = WTFMove(referrer);
204     m_httpStatusCode = httpStatusCode;
205 
206     if (policyFrom == PolicyFrom::API) {
207         ASSERT(m_policies.isEmpty());
208         m_hasAPIPolicy = true;
209     }
210 
211     m_cachedResponseHeaders = WTF::nullopt;
212 
213     // RFC2616, section 4.2 specifies that headers appearing multiple times can
214     // be combined with a comma. Walk the header string, and parse each comma
215     // separated chunk as a separate header.
216     auto characters = StringView(header).upconvertedCharacters();
217     const UChar* begin = characters;
218     const UChar* position = begin;
219     const UChar* end = begin + header.length();
220     while (position &lt; end) {
221         skipUntil&lt;UChar&gt;(position, end, &#39;,&#39;);
222 
223         // header1,header2 OR header1
224         //        ^                  ^
225         m_policies.append(ContentSecurityPolicyDirectiveList::create(*this, String(begin, position - begin), type, policyFrom));
226 
227         // Skip the comma, and begin the next header from the current position.
228         ASSERT(position == end || *position == &#39;,&#39;);
229         skipExactly&lt;UChar&gt;(position, end, &#39;,&#39;);
230         begin = position;
231     }
232 
233     if (m_scriptExecutionContext)
234         applyPolicyToScriptExecutionContext();
235 }
236 
237 void ContentSecurityPolicy::updateSourceSelf(const SecurityOrigin&amp; securityOrigin)
238 {
239     m_selfSourceProtocol = securityOrigin.protocol();
240     m_selfSource = makeUnique&lt;ContentSecurityPolicySource&gt;(*this, m_selfSourceProtocol, securityOrigin.host(), securityOrigin.port(), emptyString(), false, false);
241 }
242 
243 void ContentSecurityPolicy::applyPolicyToScriptExecutionContext()
244 {
245     ASSERT(m_scriptExecutionContext);
246 
247     // Update source self as the security origin may have changed between the time we were created and now.
248     // For instance, we may have been initially created for an about:blank iframe that later inherited the
249     // security origin of its owner document.
250     ASSERT(m_scriptExecutionContext-&gt;securityOrigin());
251     updateSourceSelf(*m_scriptExecutionContext-&gt;securityOrigin());
252 
253     bool enableStrictMixedContentMode = false;
254     for (auto&amp; policy : m_policies) {
255         const ContentSecurityPolicyDirective* violatedDirective = policy-&gt;violatedDirectiveForUnsafeEval();
256         if (violatedDirective &amp;&amp; !violatedDirective-&gt;directiveList().isReportOnly()) {
257             m_lastPolicyEvalDisabledErrorMessage = policy-&gt;evalDisabledErrorMessage();
258             m_lastPolicyWebAssemblyDisabledErrorMessage = policy-&gt;webAssemblyDisabledErrorMessage();
259         }
260         if (policy-&gt;hasBlockAllMixedContentDirective() &amp;&amp; !policy-&gt;isReportOnly())
261             enableStrictMixedContentMode = true;
262     }
263 
264     if (!m_lastPolicyEvalDisabledErrorMessage.isNull())
265         m_scriptExecutionContext-&gt;disableEval(m_lastPolicyEvalDisabledErrorMessage);
266     if (!m_lastPolicyWebAssemblyDisabledErrorMessage.isNull())
267         m_scriptExecutionContext-&gt;disableWebAssembly(m_lastPolicyWebAssemblyDisabledErrorMessage);
268     if (m_sandboxFlags != SandboxNone &amp;&amp; is&lt;Document&gt;(m_scriptExecutionContext))
269         m_scriptExecutionContext-&gt;enforceSandboxFlags(m_sandboxFlags);
270     if (enableStrictMixedContentMode)
271         m_scriptExecutionContext-&gt;setStrictMixedContentMode(true);
272 }
273 
274 void ContentSecurityPolicy::setOverrideAllowInlineStyle(bool value)
275 {
276     m_overrideInlineStyleAllowed = value;
277 }
278 
279 bool ContentSecurityPolicy::urlMatchesSelf(const URL&amp; url) const
280 {
281     return m_selfSource-&gt;matches(url);
282 }
283 
284 bool ContentSecurityPolicy::allowContentSecurityPolicySourceStarToMatchAnyProtocol() const
285 {
286     if (is&lt;Document&gt;(m_scriptExecutionContext))
287         return downcast&lt;Document&gt;(*m_scriptExecutionContext).settings().allowContentSecurityPolicySourceStarToMatchAnyProtocol();
288     return false;
289 }
290 
291 bool ContentSecurityPolicy::protocolMatchesSelf(const URL&amp; url) const
292 {
293     if (equalLettersIgnoringASCIICase(m_selfSourceProtocol, &quot;http&quot;))
294         return url.protocolIsInHTTPFamily();
295     return equalIgnoringASCIICase(url.protocol(), m_selfSourceProtocol);
296 }
297 
298 template&lt;typename Predicate, typename... Args&gt;
299 typename std::enable_if&lt;!std::is_convertible&lt;Predicate, ContentSecurityPolicy::ViolatedDirectiveCallback&gt;::value, bool&gt;::type ContentSecurityPolicy::allPoliciesWithDispositionAllow(Disposition disposition, Predicate&amp;&amp; predicate, Args&amp;&amp;... args) const
300 {
301     bool isReportOnly = disposition == ContentSecurityPolicy::Disposition::ReportOnly;
302     for (auto&amp; policy : m_policies) {
303         if (policy-&gt;isReportOnly() != isReportOnly)
304             continue;
305         if ((policy.get()-&gt;*predicate)(std::forward&lt;Args&gt;(args)...))
306             return false;
307     }
308     return true;
309 }
310 
311 template&lt;typename Predicate, typename... Args&gt;
312 bool ContentSecurityPolicy::allPoliciesWithDispositionAllow(Disposition disposition, ViolatedDirectiveCallback&amp;&amp; callback, Predicate&amp;&amp; predicate, Args&amp;&amp;... args) const
313 {
314     bool isReportOnly = disposition == ContentSecurityPolicy::Disposition::ReportOnly;
315     bool isAllowed = true;
316     for (auto&amp; policy : m_policies) {
317         if (policy-&gt;isReportOnly() != isReportOnly)
318             continue;
319         if (const ContentSecurityPolicyDirective* violatedDirective = (policy.get()-&gt;*predicate)(std::forward&lt;Args&gt;(args)...)) {
320             isAllowed = false;
321             callback(*violatedDirective);
322         }
323     }
324     return isAllowed;
325 }
326 
327 template&lt;typename Predicate, typename... Args&gt;
328 bool ContentSecurityPolicy::allPoliciesAllow(ViolatedDirectiveCallback&amp;&amp; callback, Predicate&amp;&amp; predicate, Args&amp;&amp;... args) const
329 {
330     bool isAllowed = true;
331     for (auto&amp; policy : m_policies) {
332         if (const ContentSecurityPolicyDirective* violatedDirective = (policy.get()-&gt;*predicate)(std::forward&lt;Args&gt;(args)...)) {
333             if (!violatedDirective-&gt;directiveList().isReportOnly())
334                 isAllowed = false;
335             callback(*violatedDirective);
336         }
337     }
338     return isAllowed;
339 }
340 
341 template&lt;typename Predicate&gt;
342 ContentSecurityPolicy::HashInEnforcedAndReportOnlyPoliciesPair ContentSecurityPolicy::findHashOfContentInPolicies(Predicate&amp;&amp; predicate, const String&amp; content, OptionSet&lt;ContentSecurityPolicyHashAlgorithm&gt; algorithms) const
343 {
344     if (algorithms.isEmpty() || content.isEmpty())
345         return { false, false };
346 
347     // FIXME: We should compute the document encoding once and cache it instead of computing it on each invocation.
348     TextEncoding documentEncoding;
349     if (is&lt;Document&gt;(m_scriptExecutionContext))
350         documentEncoding = downcast&lt;Document&gt;(*m_scriptExecutionContext).textEncoding();
351     const TextEncoding&amp; encodingToUse = documentEncoding.isValid() ? documentEncoding : UTF8Encoding();
352 
353     // FIXME: Compute the digest with respect to the raw bytes received from the page.
354     // See &lt;https://bugs.webkit.org/show_bug.cgi?id=155184&gt;.
355     auto encodedContent = encodingToUse.encode(content, UnencodableHandling::Entities);
356     bool foundHashInEnforcedPolicies = false;
357     bool foundHashInReportOnlyPolicies = false;
358     for (auto algorithm : algorithms) {
359         ContentSecurityPolicyHash hash = cryptographicDigestForBytes(algorithm, encodedContent.data(), encodedContent.size());
360         if (!foundHashInEnforcedPolicies &amp;&amp; allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::Enforce, std::forward&lt;Predicate&gt;(predicate), hash))
361             foundHashInEnforcedPolicies = true;
362         if (!foundHashInReportOnlyPolicies &amp;&amp; allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::ReportOnly, std::forward&lt;Predicate&gt;(predicate), hash))
363             foundHashInReportOnlyPolicies = true;
364         if (foundHashInEnforcedPolicies &amp;&amp; foundHashInReportOnlyPolicies)
365             break;
366     }
367     return { foundHashInEnforcedPolicies, foundHashInReportOnlyPolicies };
368 }
369 
370 bool ContentSecurityPolicy::allowJavaScriptURLs(const String&amp; contextURL, const WTF::OrdinalNumber&amp; contextLine, bool overrideContentSecurityPolicy) const
371 {
372     if (overrideContentSecurityPolicy)
373         return true;
374     bool didNotifyInspector = false;
375     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
376         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), &quot;Refused to execute a script&quot;, &quot;its hash, its nonce, or &#39;unsafe-inline&#39;&quot;);
377         reportViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), consoleMessage, contextURL, TextPosition(contextLine, WTF::OrdinalNumber()));
378         if (!didNotifyInspector &amp;&amp; violatedDirective.directiveList().isReportOnly()) {
379             reportBlockedScriptExecutionToInspector(violatedDirective.text());
380             didNotifyInspector = true;
381         }
382     };
383     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeInlineScript);
384 }
385 
386 bool ContentSecurityPolicy::allowInlineEventHandlers(const String&amp; contextURL, const WTF::OrdinalNumber&amp; contextLine, bool overrideContentSecurityPolicy) const
387 {
388     if (overrideContentSecurityPolicy)
389         return true;
390     bool didNotifyInspector = false;
391     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
392         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), &quot;Refused to execute a script for an inline event handler&quot;, &quot;&#39;unsafe-inline&#39;&quot;);
393         reportViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), consoleMessage, contextURL, TextPosition(contextLine, WTF::OrdinalNumber()));
394         if (!didNotifyInspector &amp;&amp; !violatedDirective.directiveList().isReportOnly()) {
395             reportBlockedScriptExecutionToInspector(violatedDirective.text());
396             didNotifyInspector = true;
397         }
398     };
399     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeInlineScript);
400 }
401 
402 bool ContentSecurityPolicy::allowScriptWithNonce(const String&amp; nonce, bool overrideContentSecurityPolicy) const
403 {
404     if (overrideContentSecurityPolicy)
405         return true;
406     String strippedNonce = stripLeadingAndTrailingHTMLSpaces(nonce);
407     if (strippedNonce.isEmpty())
408         return false;
409     // FIXME: We need to report violations in report-only policies. See &lt;https://bugs.webkit.org/show_bug.cgi?id=159830&gt;.
410     return allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::Enforce, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForScriptNonce, strippedNonce);
411 }
412 
413 bool ContentSecurityPolicy::allowStyleWithNonce(const String&amp; nonce, bool overrideContentSecurityPolicy) const
414 {
415     if (overrideContentSecurityPolicy)
416         return true;
417     String strippedNonce = stripLeadingAndTrailingHTMLSpaces(nonce);
418     if (strippedNonce.isEmpty())
419         return false;
420     // FIXME: We need to report violations in report-only policies. See &lt;https://bugs.webkit.org/show_bug.cgi?id=159830&gt;.
421     return allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::Enforce, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForStyleNonce, strippedNonce);
422 }
423 
424 bool ContentSecurityPolicy::allowInlineScript(const String&amp; contextURL, const WTF::OrdinalNumber&amp; contextLine, const String&amp; scriptContent, bool overrideContentSecurityPolicy) const
425 {
426     if (overrideContentSecurityPolicy)
427         return true;
428     bool didNotifyInspector = false;
429     auto [foundHashInEnforcedPolicies, foundHashInReportOnlyPolicies] = findHashOfContentInPolicies(&amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForScriptHash, scriptContent, m_hashAlgorithmsForInlineScripts);
430     if (foundHashInEnforcedPolicies &amp;&amp; foundHashInReportOnlyPolicies)
431         return true;
432     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
433         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), &quot;Refused to execute a script&quot;, &quot;its hash, its nonce, or &#39;unsafe-inline&#39;&quot;);
434         reportViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), consoleMessage, contextURL, TextPosition(contextLine, WTF::OrdinalNumber()));
435         if (!didNotifyInspector &amp;&amp; !violatedDirective.directiveList().isReportOnly()) {
436             reportBlockedScriptExecutionToInspector(violatedDirective.text());
437             didNotifyInspector = true;
438         }
439     };
440     // FIXME: We should not report that the inline script violated a policy when its hash matched a source
441     // expression in the policy and the page has more than one policy. See &lt;https://bugs.webkit.org/show_bug.cgi?id=159832&gt;.
442     if (!foundHashInReportOnlyPolicies)
443         allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::ReportOnly, handleViolatedDirective, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeInlineScript);
444     return foundHashInEnforcedPolicies || allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::Enforce, handleViolatedDirective, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeInlineScript);
445 }
446 
447 bool ContentSecurityPolicy::allowInlineStyle(const String&amp; contextURL, const WTF::OrdinalNumber&amp; contextLine, const String&amp; styleContent, bool overrideContentSecurityPolicy) const
448 {
449     if (overrideContentSecurityPolicy)
450         return true;
451     if (m_overrideInlineStyleAllowed)
452         return true;
453     auto [foundHashInEnforcedPolicies, foundHashInReportOnlyPolicies] = findHashOfContentInPolicies(&amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForStyleHash, styleContent, m_hashAlgorithmsForInlineStylesheets);
454     if (foundHashInEnforcedPolicies &amp;&amp; foundHashInReportOnlyPolicies)
455         return true;
456     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
457         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::styleSrc, violatedDirective, URL(), &quot;Refused to apply a stylesheet&quot;, &quot;its hash, its nonce, or &#39;unsafe-inline&#39;&quot;);
458         reportViolation(ContentSecurityPolicyDirectiveNames::styleSrc, violatedDirective, URL(), consoleMessage, contextURL, TextPosition(contextLine, WTF::OrdinalNumber()));
459     };
460     // FIXME: We should not report that the inline stylesheet violated a policy when its hash matched a source
461     // expression in the policy and the page has more than one policy. See &lt;https://bugs.webkit.org/show_bug.cgi?id=159832&gt;.
462     if (!foundHashInReportOnlyPolicies)
463         allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::ReportOnly, handleViolatedDirective, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeInlineStyle);
464     return foundHashInEnforcedPolicies || allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::Enforce, handleViolatedDirective, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeInlineStyle);
465 }
466 
<a name="3" id="anc3"></a><span class="line-modified">467 bool ContentSecurityPolicy::allowEval(JSC::JSGlobalObject* state, bool overrideContentSecurityPolicy) const</span>
468 {
469     if (overrideContentSecurityPolicy)
470         return true;
471     bool didNotifyInspector = false;
472     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
473         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), &quot;Refused to execute a script&quot;, &quot;&#39;unsafe-eval&#39;&quot;);
474         reportViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), consoleMessage, state);
475         if (!didNotifyInspector &amp;&amp; !violatedDirective.directiveList().isReportOnly()) {
476             reportBlockedScriptExecutionToInspector(violatedDirective.text());
477             didNotifyInspector = true;
478         }
479     };
480     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeEval);
481 }
482 
483 bool ContentSecurityPolicy::allowFrameAncestors(const Frame&amp; frame, const URL&amp; url, bool overrideContentSecurityPolicy) const
484 {
485     if (overrideContentSecurityPolicy)
486         return true;
487     Frame&amp; topFrame = frame.tree().top();
488     if (&amp;frame == &amp;topFrame)
489         return true;
490     String sourceURL;
491     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
492     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
493         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::frameAncestors, violatedDirective, url, &quot;Refused to load&quot;);
494         reportViolation(ContentSecurityPolicyDirectiveNames::frameAncestors, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
495     };
496     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForFrameAncestor, frame);
497 }
498 
499 bool ContentSecurityPolicy::overridesXFrameOptions() const
500 {
501     // If a resource is delivered with an policy that includes a directive named frame-ancestors and whose disposition
502     // is &quot;enforce&quot;, then the X-Frame-Options header MUST be ignored.
503     // https://www.w3.org/TR/CSP3/#frame-ancestors-and-frame-options
504     for (auto&amp; policy : m_policies) {
505         if (!policy-&gt;isReportOnly() &amp;&amp; policy-&gt;hasFrameAncestorsDirective())
506             return true;
507     }
508     return false;
509 }
510 
511 bool ContentSecurityPolicy::allowFrameAncestors(const Vector&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp; ancestorOrigins, const URL&amp; url, bool overrideContentSecurityPolicy) const
512 {
513     if (overrideContentSecurityPolicy)
514         return true;
515     bool isTopLevelFrame = ancestorOrigins.isEmpty();
516     if (isTopLevelFrame)
517         return true;
518     String sourceURL;
519     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
520     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
521         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::frameAncestors, violatedDirective, url, &quot;Refused to load&quot;);
522         reportViolation(ContentSecurityPolicyDirectiveNames::frameAncestors, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
523     };
524     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForFrameAncestorOrigins, ancestorOrigins);
525 }
526 
527 bool ContentSecurityPolicy::allowPluginType(const String&amp; type, const String&amp; typeAttribute, const URL&amp; url, bool overrideContentSecurityPolicy) const
528 {
529     if (overrideContentSecurityPolicy)
530         return true;
531     String sourceURL;
532     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
533     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
534         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::pluginTypes, violatedDirective, url, &quot;Refused to load&quot;, &quot;its MIME type&quot;);
535         reportViolation(ContentSecurityPolicyDirectiveNames::pluginTypes, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
536     };
537     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForPluginType, type, typeAttribute);
538 }
539 
540 bool ContentSecurityPolicy::allowObjectFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
541 {
<a name="4" id="anc4"></a><span class="line-modified">542     if (LegacySchemeRegistry::schemeShouldBypassContentSecurityPolicy(url.protocol().toStringWithoutCopying()))</span>
543         return true;
544     // As per section object-src of the Content Security Policy Level 3 spec., &lt;http://w3c.github.io/webappsec-csp&gt; (Editor&#39;s Draft, 29 February 2016),
545     // &quot;If plugin content is loaded without an associated URL (perhaps an object element lacks a data attribute, but loads some default plugin based
546     // on the specified type), it MUST be blocked if object-src&#39;s value is &#39;none&#39;, but will otherwise be allowed&quot;.
547     String sourceURL;
548     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
549     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
550         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::objectSrc, violatedDirective, url, &quot;Refused to load&quot;);
551         reportViolation(ContentSecurityPolicyDirectiveNames::objectSrc, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
552     };
553     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForObjectSource, url, redirectResponseReceived == RedirectResponseReceived::Yes, ContentSecurityPolicySourceListDirective::ShouldAllowEmptyURLIfSourceListIsNotNone::Yes);
554 }
555 
556 bool ContentSecurityPolicy::allowChildFrameFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
557 {
<a name="5" id="anc5"></a><span class="line-modified">558     if (LegacySchemeRegistry::schemeShouldBypassContentSecurityPolicy(url.protocol().toStringWithoutCopying()))</span>
559         return true;
560     String sourceURL;
561     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
562     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
563         const char* effectiveViolatedDirective = violatedDirective.name() == ContentSecurityPolicyDirectiveNames::frameSrc ? ContentSecurityPolicyDirectiveNames::frameSrc : ContentSecurityPolicyDirectiveNames::childSrc;
564         String consoleMessage = consoleMessageForViolation(effectiveViolatedDirective, violatedDirective, url, &quot;Refused to load&quot;);
565         reportViolation(effectiveViolatedDirective, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
566     };
567     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForFrame, url, redirectResponseReceived == RedirectResponseReceived::Yes);
568 }
569 
570 bool ContentSecurityPolicy::allowResourceFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived, const char* name, ResourcePredicate resourcePredicate) const
571 {
<a name="6" id="anc6"></a><span class="line-modified">572     if (LegacySchemeRegistry::schemeShouldBypassContentSecurityPolicy(url.protocol().toStringWithoutCopying()))</span>
573         return true;
574     String sourceURL;
575     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
576     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
577         String consoleMessage = consoleMessageForViolation(name, violatedDirective, url, &quot;Refused to load&quot;);
578         reportViolation(name, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
579     };
580     return allPoliciesAllow(WTFMove(handleViolatedDirective), resourcePredicate, url, redirectResponseReceived == RedirectResponseReceived::Yes);
581 }
582 
583 bool ContentSecurityPolicy::allowChildContextFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
584 {
585     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::childSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForChildContext);
586 }
587 
588 bool ContentSecurityPolicy::allowScriptFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
589 {
590     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::scriptSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForScript);
591 }
592 
593 bool ContentSecurityPolicy::allowImageFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
594 {
595     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::imgSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForImage);
596 }
597 
598 bool ContentSecurityPolicy::allowStyleFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
599 {
600     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::styleSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForStyle);
601 }
602 
603 bool ContentSecurityPolicy::allowFontFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
604 {
605     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::fontSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForFont);
606 }
607 
608 #if ENABLE(APPLICATION_MANIFEST)
609 bool ContentSecurityPolicy::allowManifestFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
610 {
611     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::manifestSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForManifest);
612 }
613 #endif // ENABLE(APPLICATION_MANIFEST)
614 
615 bool ContentSecurityPolicy::allowMediaFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
616 {
617     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::mediaSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForMedia);
618 }
619 
620 bool ContentSecurityPolicy::allowConnectToSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
621 {
<a name="7" id="anc7"></a><span class="line-modified">622     if (LegacySchemeRegistry::schemeShouldBypassContentSecurityPolicy(url.protocol().toStringWithoutCopying()))</span>
623         return true;
624     String sourceURL;
625     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
626     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
627         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::connectSrc, violatedDirective, url, &quot;Refused to connect to&quot;);
628         reportViolation(ContentSecurityPolicyDirectiveNames::connectSrc, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
629     };
630     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForConnectSource, url, redirectResponseReceived == RedirectResponseReceived::Yes);
631 }
632 
633 bool ContentSecurityPolicy::allowFormAction(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
634 {
635     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::formAction, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForFormAction);
636 }
637 
638 bool ContentSecurityPolicy::allowBaseURI(const URL&amp; url, bool overrideContentSecurityPolicy) const
639 {
640     if (overrideContentSecurityPolicy)
641         return true;
<a name="8" id="anc8"></a><span class="line-modified">642     if (LegacySchemeRegistry::schemeShouldBypassContentSecurityPolicy(url.protocol().toStringWithoutCopying()))</span>
643         return true;
644     String sourceURL;
645     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
646     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
647         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::baseURI, violatedDirective, url, &quot;Refused to change the document base URL to&quot;);
648         reportViolation(ContentSecurityPolicyDirectiveNames::baseURI, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
649     };
650     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForBaseURI, url);
651 }
652 
653 String ContentSecurityPolicy::deprecatedURLForReporting(const URL&amp; url) const
654 {
655     if (!url.isValid())
656         return { };
657     if (!url.isHierarchical() || url.protocolIs(&quot;file&quot;))
658         return url.protocol().toString();
659     return static_cast&lt;SecurityOriginData&gt;(*m_selfSource).securityOrigin()-&gt;canRequest(url) ? url.strippedForUseAsReferrer() : SecurityOrigin::create(url)-&gt;toString();
660 }
661 
<a name="9" id="anc9"></a><span class="line-modified">662 void ContentSecurityPolicy::reportViolation(const String&amp; violatedDirective, const ContentSecurityPolicyDirective&amp; effectiveViolatedDirective, const URL&amp; blockedURL, const String&amp; consoleMessage, JSC::JSGlobalObject* state) const</span>
663 {
664     // FIXME: Extract source file and source position from JSC::ExecState.
665     return reportViolation(violatedDirective, effectiveViolatedDirective.text(), effectiveViolatedDirective.directiveList(), blockedURL, consoleMessage, String(), TextPosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber::beforeFirst()), state);
666 }
667 
<a name="10" id="anc10"></a><span class="line-modified">668 void ContentSecurityPolicy::reportViolation(const String&amp; effectiveViolatedDirective, const String&amp; violatedDirective, const ContentSecurityPolicyDirectiveList&amp; violatedDirectiveList, const URL&amp; blockedURL, const String&amp; consoleMessage, JSC::JSGlobalObject* state) const</span>
669 {
670     // FIXME: Extract source file and source position from JSC::ExecState.
671     return reportViolation(effectiveViolatedDirective, violatedDirective, violatedDirectiveList, blockedURL, consoleMessage, String(), TextPosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber::beforeFirst()), state);
672 }
673 
<a name="11" id="anc11"></a><span class="line-modified">674 void ContentSecurityPolicy::reportViolation(const String&amp; effectiveViolatedDirective, const ContentSecurityPolicyDirective&amp; violatedDirective, const URL&amp; blockedURL, const String&amp; consoleMessage, const String&amp; sourceURL, const TextPosition&amp; sourcePosition, JSC::JSGlobalObject* state) const</span>
675 {
676     return reportViolation(effectiveViolatedDirective, violatedDirective.text(), violatedDirective.directiveList(), blockedURL, consoleMessage, sourceURL, sourcePosition, state);
677 }
678 
<a name="12" id="anc12"></a><span class="line-modified">679 void ContentSecurityPolicy::reportViolation(const String&amp; effectiveViolatedDirective, const String&amp; violatedDirective, const ContentSecurityPolicyDirectiveList&amp; violatedDirectiveList, const URL&amp; blockedURL, const String&amp; consoleMessage, const String&amp; sourceURL, const TextPosition&amp; sourcePosition, JSC::JSGlobalObject* state) const</span>
680 {
681     logToConsole(consoleMessage, sourceURL, sourcePosition.m_line, sourcePosition.m_column, state);
682 
683     if (!m_isReportingEnabled)
684         return;
685 
686     // FIXME: Support sending reports from worker.
687     CSPInfo info;
688     info.documentURI = blockedURL;
689     if (m_client)
690         m_client-&gt;willSendCSPViolationReport(info);
691     else {
692         if (!is&lt;Document&gt;(m_scriptExecutionContext))
693             return;
694 
695         auto&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);
696         auto* frame = document.frame();
697         if (!frame)
698             return;
699 
700         info.documentURI = document.url().strippedForUseAsReferrer();
701 
702         auto stack = createScriptCallStack(JSExecState::currentState(), 2);
703         auto* callFrame = stack-&gt;firstNonNativeCallFrame();
704         if (callFrame &amp;&amp; callFrame-&gt;lineNumber()) {
705             info.sourceFile = deprecatedURLForReporting(URL { URL { }, callFrame-&gt;sourceURL() });
706             info.lineNumber = callFrame-&gt;lineNumber();
707             info.columnNumber = callFrame-&gt;columnNumber();
708         }
709     }
710     ASSERT(m_client || is&lt;Document&gt;(m_scriptExecutionContext));
711 
712     String blockedURI = deprecatedURLForReporting(blockedURL);
713     // FIXME: Is it policy to not use the status code for HTTPS, or is that a bug?
714     unsigned short httpStatusCode = m_selfSourceProtocol == &quot;http&quot; ? m_httpStatusCode : 0;
715 
716     // 1. Dispatch violation event.
717     SecurityPolicyViolationEvent::Init violationEventInit;
718     violationEventInit.documentURI = info.documentURI;
719     violationEventInit.referrer = m_referrer;
720     violationEventInit.blockedURI = blockedURI;
721     violationEventInit.violatedDirective = violatedDirective;
722     violationEventInit.effectiveDirective = effectiveViolatedDirective;
723     violationEventInit.originalPolicy = violatedDirectiveList.header();
724     violationEventInit.sourceFile = info.sourceFile;
725     violationEventInit.statusCode = httpStatusCode;
726     violationEventInit.lineNumber =  info.lineNumber;
727     violationEventInit.columnNumber = info.columnNumber;
728     if (m_client)
729         m_client-&gt;enqueueSecurityPolicyViolationEvent(WTFMove(violationEventInit));
730     else
731         downcast&lt;Document&gt;(*m_scriptExecutionContext).enqueueSecurityPolicyViolationEvent(WTFMove(violationEventInit));
732 
733     // 2. Send violation report (if applicable).
734     auto&amp; reportURIs = violatedDirectiveList.reportURIs();
735     if (reportURIs.isEmpty())
736         return;
737 
738     // We need to be careful here when deciding what information to send to the
739     // report-uri. Currently, we send only the current document&#39;s URL and the
740     // directive that was violated. The document&#39;s URL is safe to send because
741     // it&#39;s the document itself that&#39;s requesting that it be sent. You could
742     // make an argument that we shouldn&#39;t send HTTPS document URLs to HTTP
743     // report-uris (for the same reasons that we suppress the Referer in that
744     // case), but the Referer is sent implicitly whereas this request is only
745     // sent explicitly. As for which directive was violated, that&#39;s pretty
746     // harmless information.
747 
748     auto cspReport = JSON::Object::create();
749     cspReport-&gt;setString(&quot;document-uri&quot;_s, info.documentURI);
750     cspReport-&gt;setString(&quot;referrer&quot;_s, m_referrer);
751     cspReport-&gt;setString(&quot;violated-directive&quot;_s, violatedDirective);
752     cspReport-&gt;setString(&quot;effective-directive&quot;_s, effectiveViolatedDirective);
753     cspReport-&gt;setString(&quot;original-policy&quot;_s, violatedDirectiveList.header());
754     cspReport-&gt;setString(&quot;blocked-uri&quot;_s, blockedURI);
755     cspReport-&gt;setInteger(&quot;status-code&quot;_s, httpStatusCode);
756     if (!info.sourceFile.isNull()) {
757         cspReport-&gt;setString(&quot;source-file&quot;_s, info.sourceFile);
758         cspReport-&gt;setInteger(&quot;line-number&quot;_s, info.lineNumber);
759         cspReport-&gt;setInteger(&quot;column-number&quot;_s, info.columnNumber);
760     }
761 
762     auto reportObject = JSON::Object::create();
763     reportObject-&gt;setObject(&quot;csp-report&quot;_s, WTFMove(cspReport));
764 
765     auto report = FormData::create(reportObject-&gt;toJSONString().utf8());
766 
767     if (m_client) {
768         for (const auto&amp; url : reportURIs)
769             m_client-&gt;sendCSPViolationReport(URL { m_protectedURL, url }, report.copyRef());
770     } else {
771         auto&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);
772         for (const auto&amp; url : reportURIs)
773             PingLoader::sendViolationReport(*document.frame(), URL { m_protectedURL, url }, report.copyRef(), ViolationReportType::ContentSecurityPolicy);
774     }
775 }
776 
777 void ContentSecurityPolicy::reportUnsupportedDirective(const String&amp; name) const
778 {
779     String message;
780     if (equalLettersIgnoringASCIICase(name, &quot;allow&quot;))
781         message = &quot;The &#39;allow&#39; directive has been replaced with &#39;default-src&#39;. Please use that directive instead, as &#39;allow&#39; has no effect.&quot;_s;
782     else if (equalLettersIgnoringASCIICase(name, &quot;options&quot;))
783         message = &quot;The &#39;options&#39; directive has been replaced with &#39;unsafe-inline&#39; and &#39;unsafe-eval&#39; source expressions for the &#39;script-src&#39; and &#39;style-src&#39; directives. Please use those directives instead, as &#39;options&#39; has no effect.&quot;_s;
784     else if (equalLettersIgnoringASCIICase(name, &quot;policy-uri&quot;))
785         message = &quot;The &#39;policy-uri&#39; directive has been removed from the specification. Please specify a complete policy via the Content-Security-Policy header.&quot;_s;
786     else
787         message = makeString(&quot;Unrecognized Content-Security-Policy directive &#39;&quot;, name, &quot;&#39;.\n&quot;); // FIXME: Why does this include a newline?
788 
789     logToConsole(message);
790 }
791 
792 void ContentSecurityPolicy::reportDirectiveAsSourceExpression(const String&amp; directiveName, const String&amp; sourceExpression) const
793 {
794     logToConsole(&quot;The Content Security Policy directive &#39;&quot; + directiveName + &quot;&#39; contains &#39;&quot; + sourceExpression + &quot;&#39; as a source expression. Did you mean &#39;&quot; + directiveName + &quot; ...; &quot; + sourceExpression + &quot;...&#39; (note the semicolon)?&quot;);
795 }
796 
797 void ContentSecurityPolicy::reportDuplicateDirective(const String&amp; name) const
798 {
799     logToConsole(makeString(&quot;Ignoring duplicate Content-Security-Policy directive &#39;&quot;, name, &quot;&#39;.\n&quot;));
800 }
801 
802 void ContentSecurityPolicy::reportInvalidPluginTypes(const String&amp; pluginType) const
803 {
804     String message;
805     if (pluginType.isNull())
806         message = &quot;&#39;plugin-types&#39; Content Security Policy directive is empty; all plugins will be blocked.\n&quot;;
807     else
808         message = makeString(&quot;Invalid plugin type in &#39;plugin-types&#39; Content Security Policy directive: &#39;&quot;, pluginType, &quot;&#39;.\n&quot;);
809     logToConsole(message);
810 }
811 
812 void ContentSecurityPolicy::reportInvalidSandboxFlags(const String&amp; invalidFlags) const
813 {
814     logToConsole(&quot;Error while parsing the &#39;sandbox&#39; Content Security Policy directive: &quot; + invalidFlags);
815 }
816 
817 void ContentSecurityPolicy::reportInvalidDirectiveInReportOnlyMode(const String&amp; directiveName) const
818 {
819     logToConsole(&quot;The Content Security Policy directive &#39;&quot; + directiveName + &quot;&#39; is ignored when delivered in a report-only policy.&quot;);
820 }
821 
822 void ContentSecurityPolicy::reportInvalidDirectiveInHTTPEquivMeta(const String&amp; directiveName) const
823 {
824     logToConsole(&quot;The Content Security Policy directive &#39;&quot; + directiveName + &quot;&#39; is ignored when delivered via an HTML meta element.&quot;);
825 }
826 
827 void ContentSecurityPolicy::reportInvalidDirectiveValueCharacter(const String&amp; directiveName, const String&amp; value) const
828 {
829     String message = makeString(&quot;The value for Content Security Policy directive &#39;&quot;, directiveName, &quot;&#39; contains an invalid character: &#39;&quot;, value, &quot;&#39;. Non-whitespace characters outside ASCII 0x21-0x7E must be percent-encoded, as described in RFC 3986, section 2.1: http://tools.ietf.org/html/rfc3986#section-2.1.&quot;);
830     logToConsole(message);
831 }
832 
833 void ContentSecurityPolicy::reportInvalidPathCharacter(const String&amp; directiveName, const String&amp; value, const char invalidChar) const
834 {
835     ASSERT(invalidChar == &#39;#&#39; || invalidChar == &#39;?&#39;);
836 
837     String ignoring;
838     if (invalidChar == &#39;?&#39;)
839         ignoring = &quot;The query component, including the &#39;?&#39;, will be ignored.&quot;;
840     else
841         ignoring = &quot;The fragment identifier, including the &#39;#&#39;, will be ignored.&quot;;
842 
843     String message = makeString(&quot;The source list for Content Security Policy directive &#39;&quot;, directiveName, &quot;&#39; contains a source with an invalid path: &#39;&quot;, value, &quot;&#39;. &quot;, ignoring);
844     logToConsole(message);
845 }
846 
847 void ContentSecurityPolicy::reportInvalidSourceExpression(const String&amp; directiveName, const String&amp; source) const
848 {
849     String message = makeString(&quot;The source list for Content Security Policy directive &#39;&quot;, directiveName, &quot;&#39; contains an invalid source: &#39;&quot;, source, &quot;&#39;. It will be ignored.&quot;);
850     if (equalLettersIgnoringASCIICase(source, &quot;&#39;none&#39;&quot;))
851         message = makeString(message, &quot; Note that &#39;none&#39; has no effect unless it is the only expression in the source list.&quot;);
852     logToConsole(message);
853 }
854 
855 void ContentSecurityPolicy::reportMissingReportURI(const String&amp; policy) const
856 {
857     logToConsole(&quot;The Content Security Policy &#39;&quot; + policy + &quot;&#39; was delivered in report-only mode, but does not specify a &#39;report-uri&#39;; the policy will have no effect. Please either add a &#39;report-uri&#39; directive, or deliver the policy via the &#39;Content-Security-Policy&#39; header.&quot;);
858 }
859 
<a name="13" id="anc13"></a><span class="line-modified">860 void ContentSecurityPolicy::logToConsole(const String&amp; message, const String&amp; contextURL, const WTF::OrdinalNumber&amp; contextLine, const WTF::OrdinalNumber&amp; contextColumn, JSC::JSGlobalObject* state) const</span>
861 {
862     if (!m_isReportingEnabled)
863         return;
864 
865     if (m_client)
866         m_client-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message, 0);
867     else if (m_scriptExecutionContext)
868         m_scriptExecutionContext-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message, contextURL, contextLine.oneBasedInt(), contextColumn.oneBasedInt(), state);
869 }
870 
871 void ContentSecurityPolicy::reportBlockedScriptExecutionToInspector(const String&amp; directiveText) const
872 {
873     if (m_scriptExecutionContext)
874         InspectorInstrumentation::scriptExecutionBlockedByCSP(m_scriptExecutionContext, directiveText);
875 }
876 
877 void ContentSecurityPolicy::upgradeInsecureRequestIfNeeded(ResourceRequest&amp; request, InsecureRequestType requestType) const
878 {
879     URL url = request.url();
880     upgradeInsecureRequestIfNeeded(url, requestType);
881     request.setURL(url);
882 }
883 
884 void ContentSecurityPolicy::upgradeInsecureRequestIfNeeded(URL&amp; url, InsecureRequestType requestType) const
885 {
886     if (!url.protocolIs(&quot;http&quot;) &amp;&amp; !url.protocolIs(&quot;ws&quot;))
887         return;
888 
889     bool upgradeRequest = m_insecureNavigationRequestsToUpgrade.contains(SecurityOriginData::fromURL(url));
890     if (requestType == InsecureRequestType::Load || requestType == InsecureRequestType::FormSubmission)
891         upgradeRequest |= m_upgradeInsecureRequests;
892 
893     if (!upgradeRequest)
894         return;
895 
896     if (url.protocolIs(&quot;http&quot;))
897         url.setProtocol(&quot;https&quot;);
898     else {
899         ASSERT(url.protocolIs(&quot;ws&quot;));
900         url.setProtocol(&quot;wss&quot;);
901     }
902 
903     if (url.port() &amp;&amp; url.port().value() == 80)
904         url.setPort(443);
905 }
906 
907 void ContentSecurityPolicy::setUpgradeInsecureRequests(bool upgradeInsecureRequests)
908 {
909     m_upgradeInsecureRequests = upgradeInsecureRequests;
910     if (!m_upgradeInsecureRequests)
911         return;
912 
913     if (!m_scriptExecutionContext)
914         return;
915 
916     // Store the upgrade domain as an &#39;insecure&#39; protocol so we can quickly identify
917     // origins we should upgrade.
918     URL upgradeURL = m_scriptExecutionContext-&gt;url();
919     if (upgradeURL.protocolIs(&quot;https&quot;))
920         upgradeURL.setProtocol(&quot;http&quot;);
921     else if (upgradeURL.protocolIs(&quot;wss&quot;))
922         upgradeURL.setProtocol(&quot;ws&quot;);
923 
924     m_insecureNavigationRequestsToUpgrade.add(SecurityOriginData::fromURL(upgradeURL));
925 }
926 
927 void ContentSecurityPolicy::inheritInsecureNavigationRequestsToUpgradeFromOpener(const ContentSecurityPolicy&amp; other)
928 {
929     m_insecureNavigationRequestsToUpgrade.add(other.m_insecureNavigationRequestsToUpgrade.begin(), other.m_insecureNavigationRequestsToUpgrade.end());
930 }
931 
932 HashSet&lt;SecurityOriginData&gt; ContentSecurityPolicy::takeNavigationRequestsToUpgrade()
933 {
934     return WTFMove(m_insecureNavigationRequestsToUpgrade);
935 }
936 
937 void ContentSecurityPolicy::setInsecureNavigationRequestsToUpgrade(HashSet&lt;SecurityOriginData&gt;&amp;&amp; insecureNavigationRequests)
938 {
939     m_insecureNavigationRequestsToUpgrade = WTFMove(insecureNavigationRequests);
940 }
941 
942 }
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasource/SourceBuffer.h b/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasource/SourceBuffer.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasource/SourceBuffer.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasource/SourceBuffer.h
@@ -77,12 +77,15 @@
     double timestampOffset() const;
     ExceptionOr<void> setTimestampOffset(double);
 
 #if ENABLE(VIDEO_TRACK)
     VideoTrackList& videoTracks();
+    VideoTrackList* videoTracksIfExists() const { return m_videoTracks.get(); }
     AudioTrackList& audioTracks();
+    AudioTrackList* audioTracksIfExists() const { return m_audioTracks.get(); }
     TextTrackList& textTracks();
+    TextTrackList* textTracksIfExists() const { return m_textTracks.get(); }
 #endif
 
     double appendWindowStart() const;
     ExceptionOr<void> setAppendWindowStart(double);
     double appendWindowEnd() const;
@@ -142,15 +145,12 @@
     SourceBuffer(Ref<SourceBufferPrivate>&&, MediaSource*);
 
     void refEventTarget() final { ref(); }
     void derefEventTarget() final { deref(); }
 
-    void suspend(ReasonForSuspension) final;
-    void resume() final;
     void stop() final;
     const char* activeDOMObjectName() const final;
-    bool canSuspendForDocumentSuspension() const final;
 
     void sourceBufferPrivateDidReceiveInitializationSegment(const InitializationSegment&) final;
     void sourceBufferPrivateDidReceiveSample(MediaSample&) final;
     bool sourceBufferPrivateHasAudio() const final;
     bool sourceBufferPrivateHasVideo() const final;
@@ -215,11 +215,11 @@
     WEBCORE_EXPORT MediaTime minimumUpcomingPresentationTimeForTrackID(const AtomString&);
     WEBCORE_EXPORT void setMaximumQueueDepthForTrackID(const AtomString&, size_t);
 
     Ref<SourceBufferPrivate> m_private;
     MediaSource* m_source;
-    GenericEventQueue m_asyncEventQueue;
+    UniqueRef<MainThreadGenericEventQueue> m_asyncEventQueue;
     AppendMode m_mode { AppendMode::Segments };
 
     Vector<unsigned char> m_pendingAppendData;
     Timer m_appendBufferTimer;
 

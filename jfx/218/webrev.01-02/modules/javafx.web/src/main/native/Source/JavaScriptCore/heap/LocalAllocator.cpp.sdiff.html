<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/LocalAllocator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IsoSubspacePerVM.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LocalAllocator.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/LocalAllocator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 93 {
 94     if (!m_lastActiveBlock)
 95         return;
 96 
 97     m_lastActiveBlock-&gt;resumeAllocating(m_freeList);
 98     m_currentBlock = m_lastActiveBlock;
 99     m_lastActiveBlock = nullptr;
100 }
101 
102 void LocalAllocator::prepareForAllocation()
103 {
104     reset();
105 }
106 
107 void LocalAllocator::stopAllocatingForGood()
108 {
109     stopAllocating();
110     reset();
111 }
112 
<span class="line-modified">113 void* LocalAllocator::allocateSlowCase(GCDeferralContext* deferralContext, AllocationFailureMode failureMode)</span>
114 {
115     SuperSamplerScope superSamplerScope(false);
<span class="line-removed">116     Heap&amp; heap = *m_directory-&gt;m_heap;</span>
117     ASSERT(heap.vm().currentThreadIsHoldingAPILock());
<span class="line-modified">118     doTestCollectionsIfNeeded(deferralContext);</span>
119 
120     ASSERT(!m_directory-&gt;markedSpace().isIterating());
121     heap.didAllocate(m_freeList.originalSize());
122 
123     didConsumeFreeList();
124 
125     AllocatingScope helpingHeap(heap);
126 
127     heap.collectIfNecessaryOrDefer(deferralContext);
128 
129     // Goofy corner case: the GC called a callback and now this directory has a currentBlock. This only
130     // happens when running WebKit tests, which inject a callback into the GC&#39;s finalization.
131     if (UNLIKELY(m_currentBlock))
<span class="line-modified">132         return allocate(deferralContext, failureMode);</span>
133 
134     void* result = tryAllocateWithoutCollecting();
135 
<span class="line-modified">136     if (LIKELY(result != 0))</span>
137         return result;
138 
<span class="line-modified">139     MarkedBlock::Handle* block = m_directory-&gt;tryAllocateBlock();</span>






140     if (!block) {
141         if (failureMode == AllocationFailureMode::Assert)
142             RELEASE_ASSERT_NOT_REACHED();
143         else
144             return nullptr;
145     }
146     m_directory-&gt;addBlock(block);
147     result = allocateIn(block);
148     ASSERT(result);
149     return result;
150 }
151 
152 void LocalAllocator::didConsumeFreeList()
153 {
154     if (m_currentBlock)
155         m_currentBlock-&gt;didConsumeFreeList();
156 
157     m_freeList.clear();
158     m_currentBlock = nullptr;
159 }
</pre>
<hr />
<pre>
226         ASSERT(block-&gt;isFreeListed());
227         block-&gt;unsweepWithNoNewlyAllocated();
228         ASSERT(!block-&gt;isFreeListed());
229         ASSERT(!m_directory-&gt;isEmpty(NoLockingNecessary, block));
230         ASSERT(!m_directory-&gt;isCanAllocateButNotEmpty(NoLockingNecessary, block));
231         return nullptr;
232     }
233 
234     m_currentBlock = block;
235 
236     void* result = m_freeList.allocate(
237         [] () -&gt; HeapCell* {
238             RELEASE_ASSERT_NOT_REACHED();
239             return nullptr;
240         });
241     m_directory-&gt;setIsEden(NoLockingNecessary, m_currentBlock, true);
242     m_directory-&gt;markedSpace().didAllocateInBlock(m_currentBlock);
243     return result;
244 }
245 
<span class="line-modified">246 void LocalAllocator::doTestCollectionsIfNeeded(GCDeferralContext* deferralContext)</span>
247 {
248     if (!Options::slowPathAllocsBetweenGCs())
249         return;
250 
251     static unsigned allocationCount = 0;
252     if (!allocationCount) {
<span class="line-modified">253         if (!m_directory-&gt;m_heap-&gt;isDeferred()) {</span>
254             if (deferralContext)
255                 deferralContext-&gt;m_shouldGC = true;
256             else
<span class="line-modified">257                 m_directory-&gt;m_heap-&gt;collectNow(Sync, CollectionScope::Full);</span>
258         }
259     }
260     if (++allocationCount &gt;= Options::slowPathAllocsBetweenGCs())
261         allocationCount = 0;
262 }
263 
264 bool LocalAllocator::isFreeListedCell(const void* target) const
265 {
266     // This abomination exists to detect when an object is in the dead-but-not-destructed state.
267     // Therefore, it&#39;s not even clear that this needs to do anything beyond returning &quot;false&quot;, since
268     // if we know that the block owning the object is free-listed, then it&#39;s impossible for any
269     // objects to be in the dead-but-not-destructed state.
270     // FIXME: Get rid of this abomination. https://bugs.webkit.org/show_bug.cgi?id=181655
271     return m_freeList.contains(bitwise_cast&lt;HeapCell*&gt;(target));
272 }
273 
274 } // namespace JSC
275 
</pre>
</td>
<td>
<hr />
<pre>
 93 {
 94     if (!m_lastActiveBlock)
 95         return;
 96 
 97     m_lastActiveBlock-&gt;resumeAllocating(m_freeList);
 98     m_currentBlock = m_lastActiveBlock;
 99     m_lastActiveBlock = nullptr;
100 }
101 
102 void LocalAllocator::prepareForAllocation()
103 {
104     reset();
105 }
106 
107 void LocalAllocator::stopAllocatingForGood()
108 {
109     stopAllocating();
110     reset();
111 }
112 
<span class="line-modified">113 void* LocalAllocator::allocateSlowCase(Heap&amp; heap, GCDeferralContext* deferralContext, AllocationFailureMode failureMode)</span>
114 {
115     SuperSamplerScope superSamplerScope(false);

116     ASSERT(heap.vm().currentThreadIsHoldingAPILock());
<span class="line-modified">117     doTestCollectionsIfNeeded(heap, deferralContext);</span>
118 
119     ASSERT(!m_directory-&gt;markedSpace().isIterating());
120     heap.didAllocate(m_freeList.originalSize());
121 
122     didConsumeFreeList();
123 
124     AllocatingScope helpingHeap(heap);
125 
126     heap.collectIfNecessaryOrDefer(deferralContext);
127 
128     // Goofy corner case: the GC called a callback and now this directory has a currentBlock. This only
129     // happens when running WebKit tests, which inject a callback into the GC&#39;s finalization.
130     if (UNLIKELY(m_currentBlock))
<span class="line-modified">131         return allocate(heap, deferralContext, failureMode);</span>
132 
133     void* result = tryAllocateWithoutCollecting();
134 
<span class="line-modified">135     if (LIKELY(result != nullptr))</span>
136         return result;
137 
<span class="line-modified">138     Subspace* subspace = m_directory-&gt;m_subspace;</span>
<span class="line-added">139     if (subspace-&gt;isIsoSubspace()) {</span>
<span class="line-added">140         if (void* result = static_cast&lt;IsoSubspace*&gt;(subspace)-&gt;tryAllocateFromLowerTier())</span>
<span class="line-added">141             return result;</span>
<span class="line-added">142     }</span>
<span class="line-added">143 </span>
<span class="line-added">144     MarkedBlock::Handle* block = m_directory-&gt;tryAllocateBlock(heap);</span>
145     if (!block) {
146         if (failureMode == AllocationFailureMode::Assert)
147             RELEASE_ASSERT_NOT_REACHED();
148         else
149             return nullptr;
150     }
151     m_directory-&gt;addBlock(block);
152     result = allocateIn(block);
153     ASSERT(result);
154     return result;
155 }
156 
157 void LocalAllocator::didConsumeFreeList()
158 {
159     if (m_currentBlock)
160         m_currentBlock-&gt;didConsumeFreeList();
161 
162     m_freeList.clear();
163     m_currentBlock = nullptr;
164 }
</pre>
<hr />
<pre>
231         ASSERT(block-&gt;isFreeListed());
232         block-&gt;unsweepWithNoNewlyAllocated();
233         ASSERT(!block-&gt;isFreeListed());
234         ASSERT(!m_directory-&gt;isEmpty(NoLockingNecessary, block));
235         ASSERT(!m_directory-&gt;isCanAllocateButNotEmpty(NoLockingNecessary, block));
236         return nullptr;
237     }
238 
239     m_currentBlock = block;
240 
241     void* result = m_freeList.allocate(
242         [] () -&gt; HeapCell* {
243             RELEASE_ASSERT_NOT_REACHED();
244             return nullptr;
245         });
246     m_directory-&gt;setIsEden(NoLockingNecessary, m_currentBlock, true);
247     m_directory-&gt;markedSpace().didAllocateInBlock(m_currentBlock);
248     return result;
249 }
250 
<span class="line-modified">251 void LocalAllocator::doTestCollectionsIfNeeded(Heap&amp; heap, GCDeferralContext* deferralContext)</span>
252 {
253     if (!Options::slowPathAllocsBetweenGCs())
254         return;
255 
256     static unsigned allocationCount = 0;
257     if (!allocationCount) {
<span class="line-modified">258         if (!heap.isDeferred()) {</span>
259             if (deferralContext)
260                 deferralContext-&gt;m_shouldGC = true;
261             else
<span class="line-modified">262                 heap.collectNow(Sync, CollectionScope::Full);</span>
263         }
264     }
265     if (++allocationCount &gt;= Options::slowPathAllocsBetweenGCs())
266         allocationCount = 0;
267 }
268 
269 bool LocalAllocator::isFreeListedCell(const void* target) const
270 {
271     // This abomination exists to detect when an object is in the dead-but-not-destructed state.
272     // Therefore, it&#39;s not even clear that this needs to do anything beyond returning &quot;false&quot;, since
273     // if we know that the block owning the object is free-listed, then it&#39;s impossible for any
274     // objects to be in the dead-but-not-destructed state.
275     // FIXME: Get rid of this abomination. https://bugs.webkit.org/show_bug.cgi?id=181655
276     return m_freeList.contains(bitwise_cast&lt;HeapCell*&gt;(target));
277 }
278 
279 } // namespace JSC
280 
</pre>
</td>
</tr>
</table>
<center><a href="IsoSubspacePerVM.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LocalAllocator.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
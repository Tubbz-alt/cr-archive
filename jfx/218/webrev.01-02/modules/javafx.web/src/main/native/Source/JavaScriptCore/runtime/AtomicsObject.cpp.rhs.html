<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/AtomicsObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;AtomicsObject.h&quot;
 28 
 29 #include &quot;FrameTracers.h&quot;
 30 #include &quot;JSCInlines.h&quot;
 31 #include &quot;JSTypedArrays.h&quot;
 32 #include &quot;ObjectPrototype.h&quot;
 33 #include &quot;ReleaseHeapAccessScope.h&quot;
 34 #include &quot;TypedArrayController.h&quot;
 35 
 36 namespace JSC {
 37 
 38 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(AtomicsObject);
 39 
 40 #define FOR_EACH_ATOMICS_FUNC(macro)                                    \
 41     macro(add, Add, 3)                                                  \
 42     macro(and, And, 3)                                                  \
 43     macro(compareExchange, CompareExchange, 4)                          \
 44     macro(exchange, Exchange, 3)                                        \
 45     macro(isLockFree, IsLockFree, 1)                                    \
 46     macro(load, Load, 2)                                                \
 47     macro(or, Or, 3)                                                    \
 48     macro(store, Store, 3)                                              \
 49     macro(sub, Sub, 3)                                                  \
 50     macro(wait, Wait, 4)                                                \
 51     macro(wake, Wake, 3)                                                \
 52     macro(xor, Xor, 3)
 53 
 54 #define DECLARE_FUNC_PROTO(lowerName, upperName, count)                 \
<a name="1" id="anc1"></a><span class="line-modified"> 55     EncodedJSValue JSC_HOST_CALL atomicsFunc ## upperName(JSGlobalObject*, CallFrame*);</span>
 56 FOR_EACH_ATOMICS_FUNC(DECLARE_FUNC_PROTO)
 57 #undef DECLARE_FUNC_PROTO
 58 
 59 const ClassInfo AtomicsObject::s_info = { &quot;Atomics&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(AtomicsObject) };
 60 
 61 AtomicsObject::AtomicsObject(VM&amp; vm, Structure* structure)
 62     : JSNonFinalObject(vm, structure)
 63 {
 64 }
 65 
 66 AtomicsObject* AtomicsObject::create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 67 {
 68     AtomicsObject* object = new (NotNull, allocateCell&lt;AtomicsObject&gt;(vm.heap)) AtomicsObject(vm, structure);
 69     object-&gt;finishCreation(vm, globalObject);
 70     return object;
 71 }
 72 
 73 Structure* AtomicsObject::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 74 {
 75     return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 76 }
 77 
 78 void AtomicsObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 79 {
 80     Base::finishCreation(vm);
 81     ASSERT(inherits(vm, info()));
 82 
 83 #define PUT_DIRECT_NATIVE_FUNC(lowerName, upperName, count) \
 84     putDirectNativeFunctionWithoutTransition(vm, globalObject, Identifier::fromString(vm, #lowerName), count, atomicsFunc ## upperName, Atomics ## upperName ## Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 85     FOR_EACH_ATOMICS_FUNC(PUT_DIRECT_NATIVE_FUNC)
 86 #undef PUT_DIRECT_NATIVE_FUNC
 87 }
 88 
 89 namespace {
 90 
 91 template&lt;typename Adaptor, typename Func&gt;
<a name="2" id="anc2"></a><span class="line-modified"> 92 EncodedJSValue atomicOperationWithArgsCase(JSGlobalObject* globalObject, const JSValue* args, ThrowScope&amp; scope, JSArrayBufferView* typedArrayView, unsigned accessIndex, const Func&amp; func)</span>
 93 {
 94     JSGenericTypedArrayView&lt;Adaptor&gt;* typedArray = jsCast&lt;JSGenericTypedArrayView&lt;Adaptor&gt;*&gt;(typedArrayView);
 95 
 96     double extraArgs[Func::numExtraArgs + 1]; // Add 1 to avoid 0 size array error in VS.
 97     for (unsigned i = 0; i &lt; Func::numExtraArgs; ++i) {
<a name="3" id="anc3"></a><span class="line-modified"> 98         double value = args[2 + i].toInteger(globalObject);</span>
 99         RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
100         extraArgs[i] = value;
101     }
102 
103     return JSValue::encode(func(typedArray-&gt;typedVector() + accessIndex, extraArgs));
104 }
105 
<a name="4" id="anc4"></a><span class="line-modified">106 unsigned validatedAccessIndex(VM&amp; vm, JSGlobalObject* globalObject, JSValue accessIndexValue, JSArrayBufferView* typedArrayView)</span>
107 {
108     auto scope = DECLARE_THROW_SCOPE(vm);
109     if (UNLIKELY(!accessIndexValue.isInt32())) {
<a name="5" id="anc5"></a><span class="line-modified">110         double accessIndexDouble = accessIndexValue.toNumber(globalObject);</span>
111         RETURN_IF_EXCEPTION(scope, 0);
112         if (accessIndexDouble == 0)
113             accessIndexValue = jsNumber(0);
114         else {
115             accessIndexValue = jsNumber(accessIndexDouble);
116             if (!accessIndexValue.isInt32()) {
<a name="6" id="anc6"></a><span class="line-modified">117                 throwRangeError(globalObject, scope, &quot;Access index is not an integer.&quot;_s);</span>
118                 return 0;
119             }
120         }
121     }
122     int32_t accessIndex = accessIndexValue.asInt32();
123 
124     ASSERT(typedArrayView-&gt;length() &lt;= static_cast&lt;unsigned&gt;(INT_MAX));
125     if (static_cast&lt;unsigned&gt;(accessIndex) &gt;= typedArrayView-&gt;length()) {
<a name="7" id="anc7"></a><span class="line-modified">126         throwRangeError(globalObject, scope, &quot;Access index out of bounds for atomic access.&quot;_s);</span>
127         return 0;
128     }
129 
130     return accessIndex;
131 }
132 
133 template&lt;typename Func&gt;
<a name="8" id="anc8"></a><span class="line-modified">134 EncodedJSValue atomicOperationWithArgs(VM&amp; vm, JSGlobalObject* globalObject, const JSValue* args, const Func&amp; func)</span>
135 {
136     auto scope = DECLARE_THROW_SCOPE(vm);
137 
138     JSValue typedArrayValue = args[0];
139     if (!typedArrayValue.isCell()) {
<a name="9" id="anc9"></a><span class="line-modified">140         throwTypeError(globalObject, scope, &quot;Typed array argument must be a cell.&quot;_s);</span>
141         return JSValue::encode(jsUndefined());
142     }
143 
144     JSCell* typedArrayCell = typedArrayValue.asCell();
145 
146     JSType type = typedArrayCell-&gt;type();
147     switch (type) {
148     case Int8ArrayType:
149     case Int16ArrayType:
150     case Int32ArrayType:
151     case Uint8ArrayType:
152     case Uint16ArrayType:
153     case Uint32ArrayType:
154         break;
155     default:
<a name="10" id="anc10"></a><span class="line-modified">156         throwTypeError(globalObject, scope, &quot;Typed array argument must be an Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, or Uint32Array.&quot;_s);</span>
157         return JSValue::encode(jsUndefined());
158     }
159 
160     JSArrayBufferView* typedArrayView = jsCast&lt;JSArrayBufferView*&gt;(typedArrayCell);
161     if (!typedArrayView-&gt;isShared()) {
<a name="11" id="anc11"></a><span class="line-modified">162         throwTypeError(globalObject, scope, &quot;Typed array argument must wrap a SharedArrayBuffer.&quot;_s);</span>
163         return JSValue::encode(jsUndefined());
164     }
165 
<a name="12" id="anc12"></a><span class="line-modified">166     unsigned accessIndex = validatedAccessIndex(vm, globalObject, args[1], typedArrayView);</span>
167     RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
168 
169     switch (type) {
170     case Int8ArrayType:
<a name="13" id="anc13"></a><span class="line-modified">171         return atomicOperationWithArgsCase&lt;Int8Adaptor&gt;(globalObject, args, scope, typedArrayView, accessIndex, func);</span>
172     case Int16ArrayType:
<a name="14" id="anc14"></a><span class="line-modified">173         return atomicOperationWithArgsCase&lt;Int16Adaptor&gt;(globalObject, args, scope, typedArrayView, accessIndex, func);</span>
174     case Int32ArrayType:
<a name="15" id="anc15"></a><span class="line-modified">175         return atomicOperationWithArgsCase&lt;Int32Adaptor&gt;(globalObject, args, scope, typedArrayView, accessIndex, func);</span>
176     case Uint8ArrayType:
<a name="16" id="anc16"></a><span class="line-modified">177         return atomicOperationWithArgsCase&lt;Uint8Adaptor&gt;(globalObject, args, scope, typedArrayView, accessIndex, func);</span>
178     case Uint16ArrayType:
<a name="17" id="anc17"></a><span class="line-modified">179         return atomicOperationWithArgsCase&lt;Uint16Adaptor&gt;(globalObject, args, scope, typedArrayView, accessIndex, func);</span>
180     case Uint32ArrayType:
<a name="18" id="anc18"></a><span class="line-modified">181         return atomicOperationWithArgsCase&lt;Uint32Adaptor&gt;(globalObject, args, scope, typedArrayView, accessIndex, func);</span>
182     default:
183         RELEASE_ASSERT_NOT_REACHED();
184         return JSValue::encode(jsUndefined());
185     }
186 }
187 
188 template&lt;typename Func&gt;
<a name="19" id="anc19"></a><span class="line-modified">189 EncodedJSValue atomicOperationWithArgs(JSGlobalObject* globalObject, CallFrame* callFrame, const Func&amp; func)</span>
190 {
191     JSValue args[2 + Func::numExtraArgs];
192     for (unsigned i = 2 + Func::numExtraArgs; i--;)
<a name="20" id="anc20"></a><span class="line-modified">193         args[i] = callFrame-&gt;argument(i);</span>
<span class="line-modified">194     return atomicOperationWithArgs(globalObject-&gt;vm(), globalObject, args, func);</span>
195 }
196 
197 struct AddFunc {
<a name="21" id="anc21"></a><span class="line-modified">198     static constexpr unsigned numExtraArgs = 1;</span>
199 
200     template&lt;typename T&gt;
201     JSValue operator()(T* ptr, const double* args) const
202     {
203         return jsNumber(WTF::atomicExchangeAdd(ptr, toInt32(args[0])));
204     }
205 };
206 
207 struct AndFunc {
<a name="22" id="anc22"></a><span class="line-modified">208     static constexpr unsigned numExtraArgs = 1;</span>
209 
210     template&lt;typename T&gt;
211     JSValue operator()(T* ptr, const double* args) const
212     {
213         return jsNumber(WTF::atomicExchangeAnd(ptr, toInt32(args[0])));
214     }
215 };
216 
217 struct CompareExchangeFunc {
<a name="23" id="anc23"></a><span class="line-modified">218     static constexpr unsigned numExtraArgs = 2;</span>
219 
220     template&lt;typename T&gt;
221     JSValue operator()(T* ptr, const double* args) const
222     {
223         T expected = static_cast&lt;T&gt;(toInt32(args[0]));
224         T newValue = static_cast&lt;T&gt;(toInt32(args[1]));
225         return jsNumber(WTF::atomicCompareExchangeStrong(ptr, expected, newValue));
226     }
227 };
228 
229 struct ExchangeFunc {
<a name="24" id="anc24"></a><span class="line-modified">230     static constexpr unsigned numExtraArgs = 1;</span>
231 
232     template&lt;typename T&gt;
233     JSValue operator()(T* ptr, const double* args) const
234     {
235         return jsNumber(WTF::atomicExchange(ptr, static_cast&lt;T&gt;(toInt32(args[0]))));
236     }
237 };
238 
239 struct LoadFunc {
<a name="25" id="anc25"></a><span class="line-modified">240     static constexpr unsigned numExtraArgs = 0;</span>
241 
242     template&lt;typename T&gt;
243     JSValue operator()(T* ptr, const double*) const
244     {
245         return jsNumber(WTF::atomicLoadFullyFenced(ptr));
246     }
247 };
248 
249 struct OrFunc {
<a name="26" id="anc26"></a><span class="line-modified">250     static constexpr unsigned numExtraArgs = 1;</span>
251 
252     template&lt;typename T&gt;
253     JSValue operator()(T* ptr, const double* args) const
254     {
255         return jsNumber(WTF::atomicExchangeOr(ptr, toInt32(args[0])));
256     }
257 };
258 
259 struct StoreFunc {
<a name="27" id="anc27"></a><span class="line-modified">260     static constexpr unsigned numExtraArgs = 1;</span>
261 
262     template&lt;typename T&gt;
263     JSValue operator()(T* ptr, const double* args) const
264     {
265         double valueAsInt = args[0];
266         T valueAsT = static_cast&lt;T&gt;(toInt32(valueAsInt));
267         WTF::atomicStoreFullyFenced(ptr, valueAsT);
268         return jsNumber(valueAsInt);
269     }
270 };
271 
272 struct SubFunc {
<a name="28" id="anc28"></a><span class="line-modified">273     static constexpr unsigned numExtraArgs = 1;</span>
274 
275     template&lt;typename T&gt;
276     JSValue operator()(T* ptr, const double* args) const
277     {
278         return jsNumber(WTF::atomicExchangeSub(ptr, toInt32(args[0])));
279     }
280 };
281 
282 struct XorFunc {
<a name="29" id="anc29"></a><span class="line-modified">283     static constexpr unsigned numExtraArgs = 1;</span>
284 
285     template&lt;typename T&gt;
286     JSValue operator()(T* ptr, const double* args) const
287     {
288         return jsNumber(WTF::atomicExchangeXor(ptr, toInt32(args[0])));
289     }
290 };
291 
<a name="30" id="anc30"></a><span class="line-modified">292 EncodedJSValue isLockFree(JSGlobalObject* globalObject, JSValue arg)</span>
293 {
<a name="31" id="anc31"></a><span class="line-modified">294     VM&amp; vm = globalObject-&gt;vm();</span>
295     auto scope = DECLARE_THROW_SCOPE(vm);
296 
<a name="32" id="anc32"></a><span class="line-modified">297     int32_t size = arg.toInt32(globalObject);</span>
298     RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
299 
300     bool result;
301     switch (size) {
302     case 1:
303     case 2:
304     case 4:
305         result = true;
306         break;
307     default:
308         result = false;
309         break;
310     }
311     return JSValue::encode(jsBoolean(result));
312 }
313 
314 } // anonymous namespace
315 
<a name="33" id="anc33"></a><span class="line-modified">316 EncodedJSValue JSC_HOST_CALL atomicsFuncAdd(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
317 {
<a name="34" id="anc34"></a><span class="line-modified">318     return atomicOperationWithArgs(globalObject, callFrame, AddFunc());</span>
319 }
320 
<a name="35" id="anc35"></a><span class="line-modified">321 EncodedJSValue JSC_HOST_CALL atomicsFuncAnd(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
322 {
<a name="36" id="anc36"></a><span class="line-modified">323     return atomicOperationWithArgs(globalObject, callFrame, AndFunc());</span>
324 }
325 
<a name="37" id="anc37"></a><span class="line-modified">326 EncodedJSValue JSC_HOST_CALL atomicsFuncCompareExchange(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
327 {
<a name="38" id="anc38"></a><span class="line-modified">328     return atomicOperationWithArgs(globalObject, callFrame, CompareExchangeFunc());</span>
329 }
330 
<a name="39" id="anc39"></a><span class="line-modified">331 EncodedJSValue JSC_HOST_CALL atomicsFuncExchange(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
332 {
<a name="40" id="anc40"></a><span class="line-modified">333     return atomicOperationWithArgs(globalObject, callFrame, ExchangeFunc());</span>
334 }
335 
<a name="41" id="anc41"></a><span class="line-modified">336 EncodedJSValue JSC_HOST_CALL atomicsFuncIsLockFree(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
337 {
<a name="42" id="anc42"></a><span class="line-modified">338     return isLockFree(globalObject, callFrame-&gt;argument(0));</span>
339 }
340 
<a name="43" id="anc43"></a><span class="line-modified">341 EncodedJSValue JSC_HOST_CALL atomicsFuncLoad(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
342 {
<a name="44" id="anc44"></a><span class="line-modified">343     return atomicOperationWithArgs(globalObject, callFrame, LoadFunc());</span>
344 }
345 
<a name="45" id="anc45"></a><span class="line-modified">346 EncodedJSValue JSC_HOST_CALL atomicsFuncOr(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
347 {
<a name="46" id="anc46"></a><span class="line-modified">348     return atomicOperationWithArgs(globalObject, callFrame, OrFunc());</span>
349 }
350 
<a name="47" id="anc47"></a><span class="line-modified">351 EncodedJSValue JSC_HOST_CALL atomicsFuncStore(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
352 {
<a name="48" id="anc48"></a><span class="line-modified">353     return atomicOperationWithArgs(globalObject, callFrame, StoreFunc());</span>
354 }
355 
<a name="49" id="anc49"></a><span class="line-modified">356 EncodedJSValue JSC_HOST_CALL atomicsFuncSub(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
357 {
<a name="50" id="anc50"></a><span class="line-modified">358     return atomicOperationWithArgs(globalObject, callFrame, SubFunc());</span>
359 }
360 
<a name="51" id="anc51"></a><span class="line-modified">361 EncodedJSValue JSC_HOST_CALL atomicsFuncWait(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
362 {
<a name="52" id="anc52"></a><span class="line-modified">363     VM&amp; vm = globalObject-&gt;vm();</span>
364     auto scope = DECLARE_THROW_SCOPE(vm);
365 
<a name="53" id="anc53"></a><span class="line-modified">366     JSInt32Array* typedArray = jsDynamicCast&lt;JSInt32Array*&gt;(vm, callFrame-&gt;argument(0));</span>
367     if (!typedArray) {
<a name="54" id="anc54"></a><span class="line-modified">368         throwTypeError(globalObject, scope, &quot;Typed array for wait/wake must be an Int32Array.&quot;_s);</span>
369         return JSValue::encode(jsUndefined());
370     }
371 
372     if (!typedArray-&gt;isShared()) {
<a name="55" id="anc55"></a><span class="line-modified">373         throwTypeError(globalObject, scope, &quot;Typed array for wait/wake must wrap a SharedArrayBuffer.&quot;_s);</span>
374         return JSValue::encode(jsUndefined());
375     }
376 
<a name="56" id="anc56"></a><span class="line-modified">377     unsigned accessIndex = validatedAccessIndex(vm, globalObject, callFrame-&gt;argument(1), typedArray);</span>
378     RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
379 
380     int32_t* ptr = typedArray-&gt;typedVector() + accessIndex;
381 
<a name="57" id="anc57"></a><span class="line-modified">382     int32_t expectedValue = callFrame-&gt;argument(2).toInt32(globalObject);</span>
383     RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
384 
<a name="58" id="anc58"></a><span class="line-modified">385     double timeoutInMilliseconds = callFrame-&gt;argument(3).toNumber(globalObject);</span>
386     RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
387 
388     if (!vm.m_typedArrayController-&gt;isAtomicsWaitAllowedOnCurrentThread()) {
<a name="59" id="anc59"></a><span class="line-modified">389         throwTypeError(globalObject, scope, &quot;Atomics.wait cannot be called from the current thread.&quot;_s);</span>
390         return JSValue::encode(jsUndefined());
391     }
392 
393     Seconds timeout = Seconds::fromMilliseconds(timeoutInMilliseconds);
394 
395     // This covers the proposed rule:
396     //
397     // 4. If timeout is not provided or is undefined then let t be +inf. Otherwise:
398     //     a. Let q be ? ToNumber(timeout).
399     //     b. If q is NaN then let t be +inf, otherwise let t be max(0, q).
400     //
<a name="60" id="anc60"></a><span class="line-modified">401     // callFrame-&gt;argument(3) returns undefined if it&#39;s not provided and ToNumber(undefined) returns NaN,</span>
402     // so NaN is the only special case.
403     if (!std::isnan(timeout))
404         timeout = std::max(0_s, timeout);
405     else
406         timeout = Seconds::infinity();
407 
408     bool didPassValidation = false;
409     ParkingLot::ParkResult result;
410     {
411         ReleaseHeapAccessScope releaseHeapAccessScope(vm.heap);
412         result = ParkingLot::parkConditionally(
413             ptr,
414             [&amp;] () -&gt; bool {
415                 didPassValidation = WTF::atomicLoad(ptr) == expectedValue;
416                 return didPassValidation;
417             },
418             [] () { },
419             MonotonicTime::now() + timeout);
420     }
421     const char* resultString;
422     if (!didPassValidation)
423         resultString = &quot;not-equal&quot;;
424     else if (!result.wasUnparked)
425         resultString = &quot;timed-out&quot;;
426     else
427         resultString = &quot;ok&quot;;
428     return JSValue::encode(jsString(vm, resultString));
429 }
430 
<a name="61" id="anc61"></a><span class="line-modified">431 EncodedJSValue JSC_HOST_CALL atomicsFuncWake(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
432 {
<a name="62" id="anc62"></a><span class="line-modified">433     VM&amp; vm = globalObject-&gt;vm();</span>
434     auto scope = DECLARE_THROW_SCOPE(vm);
435 
<a name="63" id="anc63"></a><span class="line-modified">436     JSInt32Array* typedArray = jsDynamicCast&lt;JSInt32Array*&gt;(vm, callFrame-&gt;argument(0));</span>
437     if (!typedArray) {
<a name="64" id="anc64"></a><span class="line-modified">438         throwTypeError(globalObject, scope, &quot;Typed array for wait/wake must be an Int32Array.&quot;_s);</span>
439         return JSValue::encode(jsUndefined());
440     }
441 
442     if (!typedArray-&gt;isShared()) {
<a name="65" id="anc65"></a><span class="line-modified">443         throwTypeError(globalObject, scope, &quot;Typed array for wait/wake must wrap a SharedArrayBuffer.&quot;_s);</span>
444         return JSValue::encode(jsUndefined());
445     }
446 
<a name="66" id="anc66"></a><span class="line-modified">447     unsigned accessIndex = validatedAccessIndex(vm, globalObject, callFrame-&gt;argument(1), typedArray);</span>
448     RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
449 
450     int32_t* ptr = typedArray-&gt;typedVector() + accessIndex;
451 
<a name="67" id="anc67"></a><span class="line-modified">452     JSValue countValue = callFrame-&gt;argument(2);</span>
453     unsigned count = UINT_MAX;
454     if (!countValue.isUndefined()) {
<a name="68" id="anc68"></a><span class="line-modified">455         int32_t countInt = countValue.toInt32(globalObject);</span>
456         RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
457         count = std::max(0, countInt);
458     }
459 
460     return JSValue::encode(jsNumber(ParkingLot::unparkCount(ptr, count)));
461 }
462 
<a name="69" id="anc69"></a><span class="line-modified">463 EncodedJSValue JSC_HOST_CALL atomicsFuncXor(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
464 {
<a name="70" id="anc70"></a><span class="line-modified">465     return atomicOperationWithArgs(globalObject, callFrame, XorFunc());</span>
466 }
467 
<a name="71" id="anc71"></a><span class="line-modified">468 IGNORE_WARNINGS_BEGIN(&quot;frame-address&quot;)</span>
<span class="line-added">469 </span>
<span class="line-added">470 EncodedJSValue JIT_OPERATION operationAtomicsAdd(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
471 {
<a name="72" id="anc72"></a><span class="line-modified">472     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">473     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">474     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
475     JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<a name="73" id="anc73"></a><span class="line-modified">476     return atomicOperationWithArgs(vm, globalObject, args, AddFunc());</span>
477 }
478 
<a name="74" id="anc74"></a><span class="line-modified">479 EncodedJSValue JIT_OPERATION operationAtomicsAnd(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
480 {
<a name="75" id="anc75"></a><span class="line-modified">481     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">482     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">483     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
484     JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<a name="76" id="anc76"></a><span class="line-modified">485     return atomicOperationWithArgs(vm, globalObject, args, AndFunc());</span>
486 }
487 
<a name="77" id="anc77"></a><span class="line-modified">488 EncodedJSValue JIT_OPERATION operationAtomicsCompareExchange(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index, EncodedJSValue expected, EncodedJSValue newValue)</span>
489 {
<a name="78" id="anc78"></a><span class="line-modified">490     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">491     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">492     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
493     JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(expected), JSValue::decode(newValue)};
<a name="79" id="anc79"></a><span class="line-modified">494     return atomicOperationWithArgs(vm, globalObject, args, CompareExchangeFunc());</span>
495 }
496 
<a name="80" id="anc80"></a><span class="line-modified">497 EncodedJSValue JIT_OPERATION operationAtomicsExchange(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
498 {
<a name="81" id="anc81"></a><span class="line-modified">499     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">500     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">501     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
502     JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<a name="82" id="anc82"></a><span class="line-modified">503     return atomicOperationWithArgs(vm, globalObject, args, ExchangeFunc());</span>
504 }
505 
<a name="83" id="anc83"></a><span class="line-modified">506 EncodedJSValue JIT_OPERATION operationAtomicsIsLockFree(JSGlobalObject* globalObject, EncodedJSValue size)</span>
507 {
<a name="84" id="anc84"></a><span class="line-modified">508     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">509     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">510     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">511     return isLockFree(globalObject, JSValue::decode(size));</span>
512 }
513 
<a name="85" id="anc85"></a><span class="line-modified">514 EncodedJSValue JIT_OPERATION operationAtomicsLoad(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index)</span>
515 {
<a name="86" id="anc86"></a><span class="line-modified">516     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">517     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">518     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
519     JSValue args[] = {JSValue::decode(base), JSValue::decode(index)};
<a name="87" id="anc87"></a><span class="line-modified">520     return atomicOperationWithArgs(vm, globalObject, args, LoadFunc());</span>
521 }
522 
<a name="88" id="anc88"></a><span class="line-modified">523 EncodedJSValue JIT_OPERATION operationAtomicsOr(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
524 {
<a name="89" id="anc89"></a><span class="line-modified">525     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">526     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">527     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
528     JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<a name="90" id="anc90"></a><span class="line-modified">529     return atomicOperationWithArgs(vm, globalObject, args, OrFunc());</span>
530 }
531 
<a name="91" id="anc91"></a><span class="line-modified">532 EncodedJSValue JIT_OPERATION operationAtomicsStore(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
533 {
<a name="92" id="anc92"></a><span class="line-modified">534     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">535     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">536     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
537     JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<a name="93" id="anc93"></a><span class="line-modified">538     return atomicOperationWithArgs(vm, globalObject, args, StoreFunc());</span>
539 }
540 
<a name="94" id="anc94"></a><span class="line-modified">541 EncodedJSValue JIT_OPERATION operationAtomicsSub(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
542 {
<a name="95" id="anc95"></a><span class="line-modified">543     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">544     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">545     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
546     JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<a name="96" id="anc96"></a><span class="line-modified">547     return atomicOperationWithArgs(vm, globalObject, args, SubFunc());</span>
548 }
549 
<a name="97" id="anc97"></a><span class="line-modified">550 EncodedJSValue JIT_OPERATION operationAtomicsXor(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
551 {
<a name="98" id="anc98"></a><span class="line-modified">552     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">553     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">554     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
555     JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<a name="99" id="anc99"></a><span class="line-modified">556     return atomicOperationWithArgs(vm, globalObject, args, XorFunc());</span>
557 }
558 
<a name="100" id="anc100"></a><span class="line-added">559 IGNORE_WARNINGS_END</span>
<span class="line-added">560 </span>
561 } // namespace JSC
562 
<a name="101" id="anc101"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="101" type="hidden" />
</body>
</html>
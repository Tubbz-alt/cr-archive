<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/accessibility/AXObjectCache.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../WebCorePrefix.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AXObjectCache.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/accessibility/AXObjectCache.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  15  *     from this software without specific prior written permission.
  16  *
  17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 
  31 #if ENABLE(ACCESSIBILITY)
  32 
  33 #include &quot;AXObjectCache.h&quot;
  34 

  35 #include &quot;AXIsolatedTree.h&quot;
<span class="line-removed">  36 #include &quot;AXIsolatedTreeNode.h&quot;</span>
  37 #include &quot;AccessibilityARIAGrid.h&quot;
  38 #include &quot;AccessibilityARIAGridCell.h&quot;
  39 #include &quot;AccessibilityARIAGridRow.h&quot;
  40 #include &quot;AccessibilityAttachment.h&quot;
  41 #include &quot;AccessibilityImageMapLink.h&quot;
  42 #include &quot;AccessibilityLabel.h&quot;
  43 #include &quot;AccessibilityList.h&quot;
  44 #include &quot;AccessibilityListBox.h&quot;
  45 #include &quot;AccessibilityListBoxOption.h&quot;
  46 #include &quot;AccessibilityMathMLElement.h&quot;
  47 #include &quot;AccessibilityMediaControls.h&quot;
  48 #include &quot;AccessibilityMediaObject.h&quot;
  49 #include &quot;AccessibilityMenuList.h&quot;
  50 #include &quot;AccessibilityMenuListOption.h&quot;
  51 #include &quot;AccessibilityMenuListPopup.h&quot;
  52 #include &quot;AccessibilityProgressIndicator.h&quot;
  53 #include &quot;AccessibilityRenderObject.h&quot;
  54 #include &quot;AccessibilitySVGElement.h&quot;
  55 #include &quot;AccessibilitySVGRoot.h&quot;
  56 #include &quot;AccessibilityScrollView.h&quot;
</pre>
<hr />
<pre>
  78 #include &quot;HTMLMeterElement.h&quot;
  79 #include &quot;HTMLNames.h&quot;
  80 #include &quot;HTMLParserIdioms.h&quot;
  81 #include &quot;HTMLTextFormControlElement.h&quot;
  82 #include &quot;InlineElementBox.h&quot;
  83 #include &quot;MathMLElement.h&quot;
  84 #include &quot;Page.h&quot;
  85 #include &quot;RenderAttachment.h&quot;
  86 #include &quot;RenderLineBreak.h&quot;
  87 #include &quot;RenderListBox.h&quot;
  88 #include &quot;RenderMathMLOperator.h&quot;
  89 #include &quot;RenderMenuList.h&quot;
  90 #include &quot;RenderMeter.h&quot;
  91 #include &quot;RenderProgress.h&quot;
  92 #include &quot;RenderSVGRoot.h&quot;
  93 #include &quot;RenderSlider.h&quot;
  94 #include &quot;RenderTable.h&quot;
  95 #include &quot;RenderTableCell.h&quot;
  96 #include &quot;RenderTableRow.h&quot;
  97 #include &quot;RenderView.h&quot;

  98 #include &quot;SVGElement.h&quot;
  99 #include &quot;ScriptDisallowedScope.h&quot;
 100 #include &quot;ScrollView.h&quot;
 101 #include &quot;TextBoundaries.h&quot;
 102 #include &quot;TextControlInnerElements.h&quot;
 103 #include &quot;TextIterator.h&quot;





 104 #include &lt;wtf/DataLog.h&gt;
 105 #include &lt;wtf/SetForScope.h&gt;
 106 
 107 #if ENABLE(VIDEO)
 108 #include &quot;MediaControlElements.h&quot;
 109 #endif
 110 
 111 #if COMPILER(MSVC)
 112 // See https://msdn.microsoft.com/en-us/library/1wea5zwe.aspx
 113 #pragma warning(disable: 4701)
 114 #endif
 115 
 116 namespace WebCore {
 117 
 118 using namespace HTMLNames;
 119 
 120 const AXID InvalidAXID = 0;
 121 
 122 // Post value change notifications for password fields or elements contained in password fields at a 40hz interval to thwart analysis of typing cadence
 123 static const Seconds accessibilityPasswordValueChangeNotificationInterval { 25_ms };
</pre>
<hr />
<pre>
 192 {
 193     gAccessibilityEnabled = true;
 194 }
 195 
 196 void AXObjectCache::disableAccessibility()
 197 {
 198     gAccessibilityEnabled = false;
 199 }
 200 
 201 void AXObjectCache::setEnhancedUserInterfaceAccessibility(bool flag)
 202 {
 203     gAccessibilityEnhancedUserInterfaceEnabled = flag;
 204 #if PLATFORM(MAC)
 205     if (flag)
 206         enableAccessibility();
 207 #endif
 208 }
 209 
 210 AXObjectCache::AXObjectCache(Document&amp; document)
 211     : m_document(document)

 212     , m_notificationPostTimer(*this, &amp;AXObjectCache::notificationPostTimerFired)
 213     , m_passwordNotificationPostTimer(*this, &amp;AXObjectCache::passwordNotificationPostTimerFired)
 214     , m_liveRegionChangedPostTimer(*this, &amp;AXObjectCache::liveRegionChangedNotificationPostTimerFired)
 215     , m_focusModalNodeTimer(*this, &amp;AXObjectCache::focusModalNodeTimerFired)
 216     , m_currentModalNode(nullptr)
 217     , m_performCacheUpdateTimer(*this, &amp;AXObjectCache::performCacheUpdateTimerFired)
 218 {
 219     findModalNodes();
 220 }
 221 
 222 AXObjectCache::~AXObjectCache()
 223 {
 224     m_notificationPostTimer.stop();
 225     m_liveRegionChangedPostTimer.stop();
 226     m_focusModalNodeTimer.stop();
 227     m_performCacheUpdateTimer.stop();
 228 
<span class="line-modified"> 229     for (const auto&amp; object : m_objects.values()) {</span>
<span class="line-modified"> 230         detachWrapper(object.get(), AccessibilityDetachmentType::CacheDestroyed);</span>





 231         object-&gt;detach(AccessibilityDetachmentType::CacheDestroyed);
<span class="line-removed"> 232         object-&gt;setAXObjectID(0);</span>
<span class="line-removed"> 233     }</span>
 234 }
 235 
 236 void AXObjectCache::findModalNodes()
 237 {
 238     // Traverse the DOM tree to look for the aria-modal=true nodes.
 239     for (Element* element = ElementTraversal::firstWithin(document().rootNode()); element; element = ElementTraversal::nextIncludingPseudo(*element)) {
 240 
 241         // Must have dialog or alertdialog role
 242         if (!nodeHasRole(element, &quot;dialog&quot;) &amp;&amp; !nodeHasRole(element, &quot;alertdialog&quot;))
 243             continue;
 244         if (!equalLettersIgnoringASCIICase(element-&gt;attributeWithoutSynchronization(aria_modalAttr), &quot;true&quot;))
 245             continue;
 246 
 247         m_modalNodesSet.add(element);
 248     }
 249 
 250     // Set the current valid aria-modal node if possible.
 251     updateCurrentModalNode();
 252 }
 253 
</pre>
<hr />
<pre>
 321 AccessibilityObject* AXObjectCache::focusedImageMapUIElement(HTMLAreaElement* areaElement)
 322 {
 323     // Find the corresponding accessibility object for the HTMLAreaElement. This should be
 324     // in the list of children for its corresponding image.
 325     if (!areaElement)
 326         return nullptr;
 327 
 328     HTMLImageElement* imageElement = areaElement-&gt;imageElement();
 329     if (!imageElement)
 330         return nullptr;
 331 
 332     AccessibilityObject* axRenderImage = areaElement-&gt;document().axObjectCache()-&gt;getOrCreate(imageElement);
 333     if (!axRenderImage)
 334         return nullptr;
 335 
 336     for (const auto&amp; child : axRenderImage-&gt;children()) {
 337         if (!is&lt;AccessibilityImageMapLink&gt;(*child))
 338             continue;
 339 
 340         if (downcast&lt;AccessibilityImageMapLink&gt;(*child).areaElement() == areaElement)
<span class="line-modified"> 341             return child.get();</span>
 342     }
 343 
 344     return nullptr;
 345 }
 346 
<span class="line-modified"> 347 AccessibilityObject* AXObjectCache::focusedUIElementForPage(const Page* page)</span>
 348 {
<span class="line-modified"> 349     if (!gAccessibilityEnabled)</span>
<span class="line-removed"> 350         return nullptr;</span>
<span class="line-removed"> 351 </span>
<span class="line-removed"> 352     // get the focused node in the page</span>
<span class="line-removed"> 353     Document* focusedDocument = page-&gt;focusController().focusedOrMainFrame().document();</span>
<span class="line-removed"> 354     Element* focusedElement = focusedDocument-&gt;focusedElement();</span>
 355     if (is&lt;HTMLAreaElement&gt;(focusedElement))
 356         return focusedImageMapUIElement(downcast&lt;HTMLAreaElement&gt;(focusedElement));
 357 
<span class="line-modified"> 358     AccessibilityObject* obj = focusedDocument-&gt;axObjectCache()-&gt;getOrCreate(focusedElement ? static_cast&lt;Node*&gt;(focusedElement) : focusedDocument);</span>
<span class="line-modified"> 359     if (!obj)</span>
 360         return nullptr;
 361 
<span class="line-modified"> 362     if (obj-&gt;shouldFocusActiveDescendant()) {</span>
<span class="line-modified"> 363         if (AccessibilityObject* descendant = obj-&gt;activeDescendant())</span>
<span class="line-modified"> 364             obj = descendant;</span>




 365     }
 366 
 367     // the HTML element, for example, is focusable but has an AX object that is ignored
<span class="line-modified"> 368     if (obj-&gt;accessibilityIsIgnored())</span>
<span class="line-modified"> 369         obj = obj-&gt;parentObjectUnignored();</span>





















 370 
<span class="line-modified"> 371     return obj;</span>


































 372 }
 373 
 374 AccessibilityObject* AXObjectCache::get(Widget* widget)
 375 {
 376     if (!widget)
 377         return nullptr;
 378 
 379     AXID axID = m_widgetObjectMapping.get(widget);
 380     ASSERT(!HashTraits&lt;AXID&gt;::isDeletedValue(axID));
 381     if (!axID)
 382         return nullptr;
 383 
 384     return m_objects.get(axID);
 385 }
 386 
 387 AccessibilityObject* AXObjectCache::get(RenderObject* renderer)
 388 {
 389     if (!renderer)
 390         return nullptr;
 391 
</pre>
<hr />
<pre>
 519             return AccessibilityAttachment::create(&amp;downcast&lt;RenderAttachment&gt;(cssBox));
 520 #endif
 521 #if ENABLE(METER_ELEMENT)
 522         if (is&lt;RenderMeter&gt;(cssBox))
 523             return AccessibilityProgressIndicator::create(&amp;downcast&lt;RenderMeter&gt;(cssBox));
 524 #endif
 525 
 526         // input type=range
 527         if (is&lt;RenderSlider&gt;(cssBox))
 528             return AccessibilitySlider::create(&amp;downcast&lt;RenderSlider&gt;(cssBox));
 529     }
 530 
 531     return AccessibilityRenderObject::create(renderer);
 532 }
 533 
 534 static Ref&lt;AccessibilityObject&gt; createFromNode(Node* node)
 535 {
 536     return AccessibilityNodeObject::create(node);
 537 }
 538 















 539 AccessibilityObject* AXObjectCache::getOrCreate(Widget* widget)
 540 {
 541     if (!widget)
 542         return nullptr;
 543 
 544     if (AccessibilityObject* obj = get(widget))
 545         return obj;
 546 
 547     RefPtr&lt;AccessibilityObject&gt; newObj;
 548     if (is&lt;ScrollView&gt;(*widget))
 549         newObj = AccessibilityScrollView::create(downcast&lt;ScrollView&gt;(widget));
 550     else if (is&lt;Scrollbar&gt;(*widget))
 551         newObj = AccessibilityScrollbar::create(downcast&lt;Scrollbar&gt;(widget));
 552 
 553     // Will crash later if we have two objects for the same widget.
 554     ASSERT(!get(widget));
 555 
 556     // Catch the case if an (unsupported) widget type is used. Only FrameView and ScrollBar are supported now.
 557     ASSERT(newObj);
 558     if (!newObj)
 559         return nullptr;
 560 
<span class="line-modified"> 561     getAXID(newObj.get());</span>
<span class="line-removed"> 562 </span>
<span class="line-removed"> 563     m_widgetObjectMapping.set(widget, newObj-&gt;axObjectID());</span>
<span class="line-removed"> 564     m_objects.set(newObj-&gt;axObjectID(), newObj);</span>
<span class="line-removed"> 565     newObj-&gt;init();</span>
<span class="line-removed"> 566     attachWrapper(newObj.get());</span>
 567     return newObj.get();
 568 }
 569 
 570 AccessibilityObject* AXObjectCache::getOrCreate(Node* node)
 571 {
 572     if (!node)
 573         return nullptr;
 574 
 575     if (AccessibilityObject* obj = get(node))
 576         return obj;
 577 
 578     if (node-&gt;renderer())
 579         return getOrCreate(node-&gt;renderer());
 580 
 581     if (!node-&gt;parentElement())
 582         return nullptr;
 583 
 584     // It&#39;s only allowed to create an AccessibilityObject from a Node if it&#39;s in a canvas subtree.
 585     // Or if it&#39;s a hidden element, but we still want to expose it because of other ARIA attributes.
 586     bool inCanvasSubtree = lineageOfType&lt;HTMLCanvasElement&gt;(*node-&gt;parentElement()).first();
</pre>
<hr />
<pre>
 589     bool insideMeterElement = false;
 590 #if ENABLE(METER_ELEMENT)
 591     insideMeterElement = is&lt;HTMLMeterElement&gt;(*node-&gt;parentElement());
 592 #endif
 593 
 594     if (!inCanvasSubtree &amp;&amp; !isHidden &amp;&amp; !insideMeterElement)
 595         return nullptr;
 596 
 597     auto protectedNode = makeRef(*node);
 598 
 599     // Fallback content is only focusable as long as the canvas is displayed and visible.
 600     // Update the style before Element::isFocusable() gets called.
 601     if (inCanvasSubtree)
 602         node-&gt;document().updateStyleIfNeeded();
 603 
 604     RefPtr&lt;AccessibilityObject&gt; newObj = createFromNode(node);
 605 
 606     // Will crash later if we have two objects for the same node.
 607     ASSERT(!get(node));
 608 
<span class="line-modified"> 609     getAXID(newObj.get());</span>
<span class="line-removed"> 610 </span>
<span class="line-removed"> 611     m_nodeObjectMapping.set(node, newObj-&gt;axObjectID());</span>
<span class="line-removed"> 612     m_objects.set(newObj-&gt;axObjectID(), newObj);</span>
<span class="line-removed"> 613     newObj-&gt;init();</span>
<span class="line-removed"> 614     attachWrapper(newObj.get());</span>
 615     newObj-&gt;setLastKnownIsIgnoredValue(newObj-&gt;accessibilityIsIgnored());
 616     // Sometimes asking accessibilityIsIgnored() will cause the newObject to be deallocated, and then
 617     // it will disappear when this function is finished, leading to a use-after-free.
 618     if (newObj-&gt;isDetached())
 619         return nullptr;
 620 
 621     return newObj.get();
 622 }
 623 
 624 AccessibilityObject* AXObjectCache::getOrCreate(RenderObject* renderer)
 625 {
 626     if (!renderer)
 627         return nullptr;
 628 
 629     if (AccessibilityObject* obj = get(renderer))
 630         return obj;
 631 
 632     RefPtr&lt;AccessibilityObject&gt; newObj = createFromRenderer(renderer);
 633 
 634     // Will crash later if we have two objects for the same renderer.
 635     ASSERT(!get(renderer));
 636 
<span class="line-modified"> 637     getAXID(newObj.get());</span>
<span class="line-removed"> 638 </span>
<span class="line-removed"> 639     m_renderObjectMapping.set(renderer, newObj-&gt;axObjectID());</span>
<span class="line-removed"> 640     m_objects.set(newObj-&gt;axObjectID(), newObj);</span>
<span class="line-removed"> 641     newObj-&gt;init();</span>
<span class="line-removed"> 642     attachWrapper(newObj.get());</span>
 643     newObj-&gt;setLastKnownIsIgnoredValue(newObj-&gt;accessibilityIsIgnored());
 644     // Sometimes asking accessibilityIsIgnored() will cause the newObject to be deallocated, and then
 645     // it will disappear when this function is finished, leading to a use-after-free.
 646     if (newObj-&gt;isDetached())
 647         return nullptr;
 648 
 649     return newObj.get();
 650 }
 651 
<span class="line-modified"> 652 AccessibilityObject* AXObjectCache::rootObject()</span>













 653 {
 654     if (!gAccessibilityEnabled)
 655         return nullptr;
 656 





 657     return getOrCreate(m_document.view());
 658 }
 659 









































 660 AccessibilityObject* AXObjectCache::rootObjectForFrame(Frame* frame)
 661 {
 662     if (!gAccessibilityEnabled)
 663         return nullptr;
 664 
 665     if (!frame)
 666         return nullptr;
 667     return getOrCreate(frame-&gt;view());
 668 }
 669 
 670 AccessibilityObject* AXObjectCache::getOrCreate(AccessibilityRole role)
 671 {
<span class="line-modified"> 672     RefPtr&lt;AccessibilityObject&gt; obj = nullptr;</span>
 673 
 674     // will be filled in...
 675     switch (role) {
 676     case AccessibilityRole::ListBoxOption:
 677         obj = AccessibilityListBoxOption::create();
 678         break;
 679     case AccessibilityRole::ImageMapLink:
 680         obj = AccessibilityImageMapLink::create();
 681         break;
 682     case AccessibilityRole::Column:
 683         obj = AccessibilityTableColumn::create();
 684         break;
 685     case AccessibilityRole::TableHeaderContainer:
 686         obj = AccessibilityTableHeaderContainer::create();
 687         break;
 688     case AccessibilityRole::SliderThumb:
 689         obj = AccessibilitySliderThumb::create();
 690         break;
 691     case AccessibilityRole::MenuListPopup:
 692         obj = AccessibilityMenuListPopup::create();
 693         break;
 694     case AccessibilityRole::MenuListOption:
 695         obj = AccessibilityMenuListOption::create();
 696         break;
 697     case AccessibilityRole::SpinButton:
 698         obj = AccessibilitySpinButton::create();
 699         break;
 700     case AccessibilityRole::SpinButtonPart:
 701         obj = AccessibilitySpinButtonPart::create();
 702         break;
 703     default:
 704         obj = nullptr;
 705     }
 706 
<span class="line-modified"> 707     if (obj)</span>
<span class="line-removed"> 708         getAXID(obj.get());</span>
<span class="line-removed"> 709     else</span>
 710         return nullptr;
 711 
<span class="line-modified"> 712     m_objects.set(obj-&gt;axObjectID(), obj);</span>
<span class="line-removed"> 713     obj-&gt;init();</span>
<span class="line-removed"> 714     attachWrapper(obj.get());</span>
 715     return obj.get();
 716 }
 717 
 718 void AXObjectCache::remove(AXID axID)
 719 {
 720     if (!axID)
 721         return;
 722 







 723     auto object = m_objects.take(axID);
 724     if (!object)
 725         return;
 726 
<span class="line-modified"> 727     detachWrapper(object.get(), AccessibilityDetachmentType::ElementDestroyed);</span>
<span class="line-removed"> 728     object-&gt;detach(AccessibilityDetachmentType::ElementDestroyed, this);</span>
<span class="line-removed"> 729     object-&gt;setAXObjectID(0);</span>
 730 
 731     m_idsInUse.remove(axID);
<span class="line-removed"> 732 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)</span>
<span class="line-removed"> 733     if (auto pageID = m_document.pageID())</span>
<span class="line-removed"> 734         AXIsolatedTree::treeForPageID(*pageID)-&gt;removeNode(axID);</span>
<span class="line-removed"> 735 #endif</span>
<span class="line-removed"> 736 </span>
 737     ASSERT(m_objects.size() &gt;= m_idsInUse.size());
 738 }
 739 
 740 void AXObjectCache::remove(RenderObject* renderer)
 741 {
 742     if (!renderer)
 743         return;
 744     remove(m_renderObjectMapping.take(renderer));
 745 }
 746 
 747 void AXObjectCache::remove(Node&amp; node)
 748 {
 749     if (is&lt;Element&gt;(node)) {
 750         m_deferredRecomputeIsIgnoredList.remove(downcast&lt;Element&gt;(&amp;node));
 751         m_deferredSelectedChildredChangedList.remove(downcast&lt;Element&gt;(&amp;node));
 752         m_deferredTextFormControlValue.remove(downcast&lt;Element&gt;(&amp;node));
 753         m_deferredAttributeChange.remove(downcast&lt;Element&gt;(&amp;node));
 754     }
 755     m_deferredChildrenChangedNodeList.remove(&amp;node);
 756     m_deferredTextChangedList.remove(&amp;node);
 757     // Remove the entry if the new focused node is being removed.
 758     m_deferredFocusedNodeChange.removeAllMatching([&amp;node](auto&amp; entry) -&gt; bool {
 759         return entry.second == &amp;node;
 760     });






 761     removeNodeForUse(node);
 762 
 763     remove(m_nodeObjectMapping.take(&amp;node));
 764 
 765     if (m_currentModalNode == &amp;node)
 766         m_currentModalNode = nullptr;
 767     m_modalNodesSet.remove(&amp;node);
 768 
 769     remove(node.renderer());
 770 }
 771 
 772 void AXObjectCache::remove(Widget* view)
 773 {
 774     if (!view)
 775         return;
 776     remove(m_widgetObjectMapping.take(view));
 777 }
 778 
 779 
 780 #if !PLATFORM(WIN)
 781 AXID AXObjectCache::platformGenerateAXID() const
 782 {
 783     static AXID lastUsedID = 0;
 784 
 785     // Generate a new ID.
 786     AXID objID = lastUsedID;
 787     do {
 788         ++objID;
 789     } while (!objID || HashTraits&lt;AXID&gt;::isDeletedValue(objID) || m_idsInUse.contains(objID));
 790 
 791     lastUsedID = objID;
 792 
 793     return objID;
 794 }
 795 #endif
 796 
 797 AXID AXObjectCache::getAXID(AccessibilityObject* obj)
 798 {
 799     // check for already-assigned ID
<span class="line-modified"> 800     AXID objID = obj-&gt;axObjectID();</span>
 801     if (objID) {
 802         ASSERT(m_idsInUse.contains(objID));
 803         return objID;
 804     }
 805 
 806     objID = platformGenerateAXID();
 807 
 808     m_idsInUse.add(objID);
<span class="line-modified"> 809     obj-&gt;setAXObjectID(objID);</span>
 810 
 811     return objID;
 812 }
 813 
 814 void AXObjectCache::textChanged(Node* node)
 815 {
 816     textChanged(getOrCreate(node));
 817 }
 818 
 819 void AXObjectCache::textChanged(AccessibilityObject* obj)
 820 {
 821     if (!obj)
 822         return;
 823 
 824     bool parentAlreadyExists = obj-&gt;parentObjectIfExists();
 825     obj-&gt;textChanged();
 826     postNotification(obj, obj-&gt;document(), AXObjectCache::AXTextChanged);
 827     if (parentAlreadyExists)
 828         obj-&gt;notifyIfIgnoredValueChanged();
 829 }
</pre>
<hr />
<pre>
 862 
 863 void AXObjectCache::childrenChanged(Node* node, Node* newChild)
 864 {
 865     if (newChild)
 866         m_deferredChildrenChangedNodeList.add(newChild);
 867 
 868     childrenChanged(get(node));
 869 }
 870 
 871 void AXObjectCache::childrenChanged(RenderObject* renderer, RenderObject* newChild)
 872 {
 873     if (!renderer)
 874         return;
 875 
 876     if (newChild &amp;&amp; newChild-&gt;node())
 877         m_deferredChildrenChangedNodeList.add(newChild-&gt;node());
 878 
 879     childrenChanged(get(renderer));
 880 }
 881 
<span class="line-modified"> 882 void AXObjectCache::childrenChanged(AccessibilityObject* obj)</span>
 883 {
 884     if (!obj)
 885         return;
 886 
<span class="line-modified"> 887     m_deferredChildredChangedList.add(obj);</span>
 888 }
 889 
 890 void AXObjectCache::notificationPostTimerFired()
 891 {
 892     Ref&lt;Document&gt; protectorForCacheOwner(m_document);
 893     m_notificationPostTimer.stop();
 894 
 895     // In tests, posting notifications has a tendency to immediately queue up other notifications, which can lead to unexpected behavior
 896     // when the notification list is cleared at the end. Instead copy this list at the start.
 897     auto notifications = WTFMove(m_notificationsToPost);
 898 
 899     for (const auto&amp; note : notifications) {
<span class="line-modified"> 900         AccessibilityObject* obj = note.first.get();</span>
<span class="line-modified"> 901         if (!obj-&gt;axObjectID())</span>
 902             continue;
 903 
 904         if (!obj-&gt;axObjectCache())
 905             continue;
 906 
 907 #ifndef NDEBUG
 908         // Make sure none of the render views are in the process of being layed out.
 909         // Notifications should only be sent after the renderer has finished
 910         if (is&lt;AccessibilityRenderObject&gt;(*obj)) {
 911             if (auto* renderer = downcast&lt;AccessibilityRenderObject&gt;(*obj).renderer())
 912                 ASSERT(!renderer-&gt;view().frameView().layoutContext().layoutState());
 913         }
 914 #endif
 915 
 916         AXNotification notification = note.second;
 917 
 918         // Ensure that this menu really is a menu. We do this check here so that we don&#39;t have to create
 919         // the axChildren when the menu is marked as opening.
 920         if (notification == AXMenuOpened) {
 921             obj-&gt;updateChildrenIfNecessary();
</pre>
<hr />
<pre>
 969 {
 970     if (!node)
 971         return;
 972 
 973     stopCachingComputedObjectAttributes();
 974 
 975     // Get an accessibility object that already exists. One should not be created here
 976     // because a render update may be in progress and creating an AX object can re-trigger a layout
 977     RefPtr&lt;AccessibilityObject&gt; object = get(node);
 978     while (!object &amp;&amp; node) {
 979         node = node-&gt;parentNode();
 980         object = get(node);
 981     }
 982 
 983     if (!node)
 984         return;
 985 
 986     postNotification(object.get(), &amp;node-&gt;document(), notification, postTarget, postType);
 987 }
 988 
<span class="line-modified"> 989 void AXObjectCache::postNotification(AccessibilityObject* object, Document* document, AXNotification notification, PostTarget postTarget, PostType postType)</span>
 990 {
 991     stopCachingComputedObjectAttributes();
 992 
 993     if (object &amp;&amp; postTarget == TargetObservableParent)
 994         object = object-&gt;observableObject();
 995 
 996     if (!object &amp;&amp; document)
 997         object = get(document-&gt;renderView());
 998 
 999     if (!object)
1000         return;
1001 
1002     if (postType == PostAsynchronously) {
1003         m_notificationsToPost.append(std::make_pair(object, notification));
1004         if (!m_notificationPostTimer.isActive())
1005             m_notificationPostTimer.startOneShot(0_s);
1006     } else
1007         postPlatformNotification(object, notification);
1008 }
1009 
</pre>
<hr />
<pre>
1021         return;
1022 
1023     if (!downcast&lt;Element&gt;(*node).focused() &amp;&amp; !equalLettersIgnoringASCIICase(downcast&lt;Element&gt;(*node).attributeWithoutSynchronization(aria_selectedAttr), &quot;true&quot;))
1024         return;
1025 
1026     postNotification(getOrCreate(node), &amp;document(), AXMenuListItemSelected);
1027 }
1028 
1029 void AXObjectCache::deferFocusedUIElementChangeIfNeeded(Node* oldNode, Node* newNode)
1030 {
1031     if (nodeAndRendererAreValid(newNode) &amp;&amp; rendererNeedsDeferredUpdate(*newNode-&gt;renderer())) {
1032         m_deferredFocusedNodeChange.append({ oldNode, newNode });
1033         if (!newNode-&gt;renderer()-&gt;needsLayout() &amp;&amp; !m_performCacheUpdateTimer.isActive())
1034             m_performCacheUpdateTimer.startOneShot(0_s);
1035     } else
1036         handleFocusedUIElementChanged(oldNode, newNode);
1037 }
1038 
1039 void AXObjectCache::handleFocusedUIElementChanged(Node* oldNode, Node* newNode)
1040 {




1041     handleMenuItemSelected(newNode);
1042     platformHandleFocusedUIElementChanged(oldNode, newNode);
1043 }
1044 
1045 void AXObjectCache::selectedChildrenChanged(Node* node)
1046 {
1047     handleMenuItemSelected(node);
1048 
1049     // postTarget is TargetObservableParent so that you can pass in any child of an element and it will go up the parent tree
1050     // to find the container which should send out the notification.
1051     postNotification(node, AXSelectedChildrenChanged, TargetObservableParent);
1052 }
1053 
1054 void AXObjectCache::selectedChildrenChanged(RenderObject* renderer)
1055 {
1056     if (renderer)
1057         handleMenuItemSelected(renderer-&gt;node());
1058 
1059     // postTarget is TargetObservableParent so that you can pass in any child of an element and it will go up the parent tree
1060     // to find the container which should send out the notification.
</pre>
<hr />
<pre>
1479 
1480     // If an AXObject has yet to be created, then there&#39;s no need to process attribute changes.
1481     // Some of these notifications are processed on the parent, so allow that to proceed as well
1482     if (get(element) || get(element-&gt;parentNode()))
1483         return true;
1484 
1485     return false;
1486 }
1487 
1488 void AXObjectCache::handleAttributeChange(const QualifiedName&amp; attrName, Element* element)
1489 {
1490     if (!shouldProcessAttributeChange(attrName, element))
1491         return;
1492 
1493     if (attrName == roleAttr)
1494         handleAriaRoleChanged(element);
1495     else if (attrName == altAttr || attrName == titleAttr)
1496         textChanged(element);
1497     else if (attrName == forAttr &amp;&amp; is&lt;HTMLLabelElement&gt;(*element))
1498         labelChanged(element);


1499 
1500     if (!attrName.localName().string().startsWith(&quot;aria-&quot;))
1501         return;
1502 
1503     if (attrName == aria_activedescendantAttr)
1504         handleActiveDescendantChanged(element);
1505     else if (attrName == aria_busyAttr)
1506         postNotification(element, AXObjectCache::AXElementBusyChanged);
1507     else if (attrName == aria_valuenowAttr || attrName == aria_valuetextAttr)
1508         postNotification(element, AXObjectCache::AXValueChanged);
1509     else if (attrName == aria_labelAttr || attrName == aria_labeledbyAttr || attrName == aria_labelledbyAttr)
1510         textChanged(element);
1511     else if (attrName == aria_checkedAttr)
1512         checkedStateChanged(element);
1513     else if (attrName == aria_selectedAttr)
1514         selectedChildrenChanged(element);
1515     else if (attrName == aria_expandedAttr)
1516         handleAriaExpandedChange(element);
1517     else if (attrName == aria_hiddenAttr)
1518         childrenChanged(element-&gt;parentNode(), element);
</pre>
<hr />
<pre>
1915         return;
1916 
1917     Node* domNode = characterOffset.node;
1918     if (is&lt;HTMLInputElement&gt;(*domNode) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*domNode).isPasswordField()) {
1919         textMarkerData.ignored = true;
1920         return;
1921     }
1922 
1923     RefPtr&lt;AccessibilityObject&gt; obj = this-&gt;getOrCreate(domNode);
1924     if (!obj)
1925         return;
1926 
1927     // Convert to visible position.
1928     VisiblePosition visiblePosition = visiblePositionFromCharacterOffset(characterOffset);
1929     int vpOffset = 0;
1930     if (!visiblePosition.isNull()) {
1931         Position deepPos = visiblePosition.deepEquivalent();
1932         vpOffset = deepPos.deprecatedEditingOffset();
1933     }
1934 
<span class="line-modified">1935     textMarkerData.axID = obj.get()-&gt;axObjectID();</span>
1936     textMarkerData.node = domNode;
1937     textMarkerData.characterOffset = characterOffset.offset;
1938     textMarkerData.characterStartIndex = characterOffset.startIndex;
1939     textMarkerData.offset = vpOffset;
1940     textMarkerData.affinity = visiblePosition.affinity();
1941 
1942     this-&gt;setNodeInUse(domNode);
1943 }
1944 
1945 CharacterOffset AXObjectCache::startOrEndCharacterOffsetForRange(RefPtr&lt;Range&gt; range, bool isStart, bool enterTextControls)
1946 {
1947     if (!range)
1948         return CharacterOffset();
1949 
1950     // When getting the end CharacterOffset at node boundary, we don&#39;t want to collapse to the previous node.
1951     if (!isStart &amp;&amp; !range-&gt;endOffset())
1952         return characterOffsetForNodeAndOffset(range-&gt;endContainer(), 0, TraverseOptionIncludeStart);
1953 
1954     // If it&#39;s end text marker, we want to go to the end of the range, and stay within the range.
1955     bool stayWithinRange = !isStart;
</pre>
<hr />
<pre>
2209     // If the visible position has an anchor type referring to a node other than the anchored node, we should
2210     // set the text marker data with CharacterOffset so that the offset will correspond to the node.
2211     CharacterOffset characterOffset = characterOffsetFromVisiblePosition(visiblePos);
2212     if (deepPos.anchorType() == Position::PositionIsAfterAnchor || deepPos.anchorType() == Position::PositionIsAfterChildren) {
2213         TextMarkerData textMarkerData;
2214         textMarkerDataForCharacterOffset(textMarkerData, characterOffset);
2215         return textMarkerData;
2216     }
2217 
2218     // find or create an accessibility object for this node
2219     AXObjectCache* cache = domNode-&gt;document().axObjectCache();
2220     if (!cache)
2221         return WTF::nullopt;
2222     RefPtr&lt;AccessibilityObject&gt; obj = cache-&gt;getOrCreate(domNode);
2223 
2224     // This memory must be zero&#39;d so instances of TextMarkerData can be tested for byte-equivalence.
2225     // Warning: This is risky and bad because TextMarkerData is a nontrivial type.
2226     TextMarkerData textMarkerData;
2227     memset(static_cast&lt;void*&gt;(&amp;textMarkerData), 0, sizeof(TextMarkerData));
2228 
<span class="line-modified">2229     textMarkerData.axID = obj.get()-&gt;axObjectID();</span>
2230     textMarkerData.node = domNode;
2231     textMarkerData.offset = deepPos.deprecatedEditingOffset();
2232     textMarkerData.affinity = visiblePos.affinity();
2233 
2234     textMarkerData.characterOffset = characterOffset.offset;
2235     textMarkerData.characterStartIndex = characterOffset.startIndex;
2236 
2237     cache-&gt;setNodeInUse(domNode);
2238 
2239     return textMarkerData;
2240 }
2241 
2242 // This function exits as a performance optimization to avoid a synchronous layout.
2243 Optional&lt;TextMarkerData&gt; AXObjectCache::textMarkerDataForFirstPositionInTextControl(HTMLTextFormControlElement&amp; textControl)
2244 {
2245     if (is&lt;HTMLInputElement&gt;(textControl) &amp;&amp; downcast&lt;HTMLInputElement&gt;(textControl).isPasswordField())
2246         return WTF::nullopt;
2247 
2248     AXObjectCache* cache = textControl.document().axObjectCache();
2249     if (!cache)
2250         return WTF::nullopt;
2251 
2252     RefPtr&lt;AccessibilityObject&gt; obj = cache-&gt;getOrCreate(&amp;textControl);
2253     if (!obj)
2254         return WTF::nullopt;
2255 
2256     // This memory must be zero&#39;d so instances of TextMarkerData can be tested for byte-equivalence.
2257     // Warning: This is risky and bad because TextMarkerData is a nontrivial type.
2258     TextMarkerData textMarkerData;
2259     memset(static_cast&lt;void*&gt;(&amp;textMarkerData), 0, sizeof(TextMarkerData));
2260 
<span class="line-modified">2261     textMarkerData.axID = obj.get()-&gt;axObjectID();</span>
2262     textMarkerData.node = &amp;textControl;
2263 
2264     cache-&gt;setNodeInUse(&amp;textControl);
2265 
2266     return textMarkerData;
2267 }
2268 
2269 CharacterOffset AXObjectCache::nextCharacterOffset(const CharacterOffset&amp; characterOffset, bool ignoreNextNodeStart)
2270 {
2271     if (characterOffset.isNull())
2272         return CharacterOffset();
2273 
2274     // We don&#39;t always move one &#39;character&#39; at a time since there might be composed characters.
2275     int nextOffset = Position::uncheckedNextOffset(characterOffset.node, characterOffset.offset);
2276     CharacterOffset next = characterOffsetForNodeAndOffset(*characterOffset.node, nextOffset);
2277 
2278     // To be consistent with VisiblePosition, we should consider the case that current node end to next node start counts 1 offset.
2279     if (!ignoreNextNodeStart &amp;&amp; !next.isNull() &amp;&amp; !isReplacedNodeOrBR(next.node) &amp;&amp; next.node != characterOffset.node) {
2280         int length = TextIterator::rangeLength(rangeForUnorderedCharacterOffsets(characterOffset, next).get());
2281         if (length &gt; nextOffset - characterOffset.offset)
</pre>
<hr />
<pre>
2372 {
2373     CharacterOffset start = startCharacterOffsetOfWord(characterOffset, LeftWordIfOnBoundary);
2374     CharacterOffset end = endCharacterOffsetOfWord(start);
2375     return rangeForUnorderedCharacterOffsets(start, end);
2376 }
2377 
2378 RefPtr&lt;Range&gt; AXObjectCache::rightWordRange(const CharacterOffset&amp; characterOffset)
2379 {
2380     CharacterOffset start = startCharacterOffsetOfWord(characterOffset, RightWordIfOnBoundary);
2381     CharacterOffset end = endCharacterOffsetOfWord(start);
2382     return rangeForUnorderedCharacterOffsets(start, end);
2383 }
2384 
2385 static UChar32 characterForCharacterOffset(const CharacterOffset&amp; characterOffset)
2386 {
2387     if (characterOffset.isNull() || !characterOffset.node-&gt;isTextNode())
2388         return 0;
2389 
2390     UChar32 ch = 0;
2391     unsigned offset = characterOffset.startIndex + characterOffset.offset;
<span class="line-modified">2392     if (offset &lt; characterOffset.node-&gt;textContent().length())</span>


2393         U16_NEXT(characterOffset.node-&gt;textContent(), offset, characterOffset.node-&gt;textContent().length(), ch);


2394     return ch;
2395 }
2396 
2397 UChar32 AXObjectCache::characterAfter(const CharacterOffset&amp; characterOffset)
2398 {
2399     return characterForCharacterOffset(nextCharacterOffset(characterOffset));
2400 }
2401 
2402 UChar32 AXObjectCache::characterBefore(const CharacterOffset&amp; characterOffset)
2403 {
2404     return characterForCharacterOffset(characterOffset);
2405 }
2406 
2407 static bool characterOffsetNodeIsBR(const CharacterOffset&amp; characterOffset)
2408 {
2409     if (characterOffset.isNull())
2410         return false;
2411 
2412     return characterOffset.node-&gt;hasTagName(brTag);
2413 }
</pre>
<hr />
<pre>
2686         renderer = &amp;inlineBox-&gt;renderer();
2687 
2688     if (is&lt;RenderLineBreak&gt;(renderer) &amp;&amp; downcast&lt;RenderLineBreak&gt;(renderer)-&gt;inlineBoxWrapper() != inlineBox)
2689         return IntRect();
2690 
2691     return renderer-&gt;localCaretRect(inlineBox, caretOffset);
2692 }
2693 
2694 IntRect AXObjectCache::absoluteCaretBoundsForCharacterOffset(const CharacterOffset&amp; characterOffset)
2695 {
2696     RenderBlock* caretPainter = nullptr;
2697 
2698     // First compute a rect local to the renderer at the selection start.
2699     RenderObject* renderer = nullptr;
2700     LayoutRect localRect = localCaretRectForCharacterOffset(renderer, characterOffset);
2701 
2702     localRect = localCaretRectInRendererForRect(localRect, characterOffset.node, renderer, caretPainter);
2703     return absoluteBoundsForLocalCaretRect(caretPainter, localRect);
2704 }
2705 
<span class="line-modified">2706 CharacterOffset AXObjectCache::characterOffsetForPoint(const IntPoint &amp;point, AccessibilityObject* obj)</span>
2707 {
2708     if (!obj)
2709         return CharacterOffset();
2710 
2711     VisiblePosition vp = obj-&gt;visiblePositionForPoint(point);
2712     RefPtr&lt;Range&gt; range = makeRange(vp, vp);
2713     return startOrEndCharacterOffsetForRange(range, true);
2714 }
2715 
2716 CharacterOffset AXObjectCache::characterOffsetForPoint(const IntPoint &amp;point)
2717 {
2718     RefPtr&lt;Range&gt; caretRange = m_document.caretRangeFromPoint(LayoutPoint(point));
2719     return startOrEndCharacterOffsetForRange(caretRange, true);
2720 }
2721 
2722 CharacterOffset AXObjectCache::characterOffsetForBounds(const IntRect&amp; rect, bool first)
2723 {
2724     if (rect.isEmpty())
2725         return CharacterOffset();
2726 
</pre>
<hr />
<pre>
2752     if (characterOffset.isNull())
2753         return CharacterOffset();
2754 
2755     VisiblePosition vp = visiblePositionFromCharacterOffset(characterOffset);
2756     VisiblePosition endLine = endOfLine(vp);
2757 
2758     return characterOffsetFromVisiblePosition(endLine);
2759 }
2760 
2761 CharacterOffset AXObjectCache::startCharacterOffsetOfLine(const CharacterOffset&amp; characterOffset)
2762 {
2763     if (characterOffset.isNull())
2764         return CharacterOffset();
2765 
2766     VisiblePosition vp = visiblePositionFromCharacterOffset(characterOffset);
2767     VisiblePosition startLine = startOfLine(vp);
2768 
2769     return characterOffsetFromVisiblePosition(startLine);
2770 }
2771 
<span class="line-modified">2772 CharacterOffset AXObjectCache::characterOffsetForIndex(int index, const AccessibilityObject* obj)</span>
2773 {
2774     if (!obj)
2775         return CharacterOffset();
2776 
2777     VisiblePosition vp = obj-&gt;visiblePositionForIndex(index);
2778     CharacterOffset validate = characterOffsetFromVisiblePosition(vp);
2779     // In text control, VisiblePosition always gives the before position of a
2780     // BR node, while CharacterOffset will do the opposite.
2781     if (obj-&gt;isTextControl() &amp;&amp; characterOffsetNodeIsBR(validate))
2782         validate.offset = 1;
2783 
2784     RefPtr&lt;Range&gt; range = obj-&gt;elementRange();
2785     CharacterOffset start = startOrEndCharacterOffsetForRange(range, true, true);
2786     CharacterOffset end = startOrEndCharacterOffsetForRange(range, false, true);
2787     CharacterOffset result = start;
2788     for (int i = 0; i &lt; index; i++) {
2789         if (result.isEqual(validate)) {
2790             // Do not include the new line character, always move the offset to the start of next node.
2791             if ((validate.node-&gt;isTextNode() || characterOffsetNodeIsBR(validate))) {
2792                 CharacterOffset next = nextCharacterOffset(validate, false);
</pre>
<hr />
<pre>
2886     // If there&#39;s a pending layout, let the layout trigger the AX update.
2887     if (!document().view() || document().view()-&gt;needsLayout())
2888         return;
2889 
2890     performDeferredCacheUpdate();
2891 }
2892 
2893 void AXObjectCache::performDeferredCacheUpdate()
2894 {
2895     if (m_performingDeferredCacheUpdate)
2896         return;
2897 
2898     SetForScope&lt;bool&gt; performingDeferredCacheUpdate(m_performingDeferredCacheUpdate, true);
2899 
2900     for (auto* nodeChild : m_deferredChildrenChangedNodeList) {
2901         handleMenuOpened(nodeChild);
2902         handleLiveRegionCreated(nodeChild);
2903     }
2904     m_deferredChildrenChangedNodeList.clear();
2905 
<span class="line-modified">2906     for (auto&amp; child : m_deferredChildredChangedList)</span>
2907         child-&gt;childrenChanged();
<span class="line-modified">2908     m_deferredChildredChangedList.clear();</span>
2909 
2910     for (auto* node : m_deferredTextChangedList)
2911         textChanged(node);
2912     m_deferredTextChangedList.clear();
2913 
2914     for (auto* element : m_deferredRecomputeIsIgnoredList) {
2915         if (auto* renderer = element-&gt;renderer())
2916             recomputeIsIgnored(renderer);
2917     }
2918     m_deferredRecomputeIsIgnoredList.clear();
2919 
2920     for (auto* selectElement : m_deferredSelectedChildredChangedList)
2921         selectedChildrenChanged(selectElement);
2922     m_deferredSelectedChildredChangedList.clear();
2923 
2924     for (auto&amp; deferredFormControlContext : m_deferredTextFormControlValue) {
2925         auto&amp; textFormControlElement = downcast&lt;HTMLTextFormControlElement&gt;(*deferredFormControlContext.key);
2926         postTextReplacementNotificationForTextControl(textFormControlElement, deferredFormControlContext.value, textFormControlElement.innerTextValue());
2927     }
2928     m_deferredTextFormControlValue.clear();
2929 
2930     for (auto&amp; deferredAttributeChangeContext : m_deferredAttributeChange)
2931         handleAttributeChange(deferredAttributeChangeContext.value, deferredAttributeChangeContext.key);
2932     m_deferredAttributeChange.clear();
2933 
2934     for (auto&amp; deferredFocusedChangeContext : m_deferredFocusedNodeChange)
2935         handleFocusedUIElementChanged(deferredFocusedChangeContext.first, deferredFocusedChangeContext.second);
2936     m_deferredFocusedNodeChange.clear();
2937 
2938     platformPerformDeferredCacheUpdate();
2939 }
2940 
2941 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)
<span class="line-modified">2942 Ref&lt;AXIsolatedTreeNode&gt; AXObjectCache::createIsolatedAccessibilityTreeHierarchy(AccessibilityObject&amp; object, AXID parentID, AXIsolatedTree&amp; tree, Vector&lt;Ref&lt;AXIsolatedTreeNode&gt;&gt;&amp; nodeChanges)</span>
2943 {
<span class="line-modified">2944     auto isolatedTreeNode = AXIsolatedTreeNode::create(object);</span>
2945     nodeChanges.append(isolatedTreeNode.copyRef());
2946 

2947     isolatedTreeNode-&gt;setParent(parentID);
<span class="line-modified">2948     associateIsolatedTreeNode(object, isolatedTreeNode, tree.treeIdentifier());</span>
2949 
<span class="line-modified">2950     for (auto child : object.children()) {</span>
<span class="line-modified">2951         auto staticChild = createIsolatedAccessibilityTreeHierarchy(*child, isolatedTreeNode-&gt;identifier(), tree, nodeChanges);</span>
<span class="line-modified">2952         isolatedTreeNode-&gt;appendChild(staticChild-&gt;identifier());</span>
2953     }
2954 
2955     return isolatedTreeNode;
2956 }
2957 
<span class="line-modified">2958 Ref&lt;AXIsolatedTree&gt; AXObjectCache::generateIsolatedAccessibilityTree()</span>
2959 {
2960     RELEASE_ASSERT(isMainThread());
2961 
<span class="line-modified">2962     auto tree = AXIsolatedTree::treeForPageID(*m_document.pageID());</span>
<span class="line-modified">2963     if (!tree)</span>
<span class="line-modified">2964         tree = AXIsolatedTree::createTreeForPageID(*m_document.pageID());</span>













2965 
<span class="line-modified">2966     Vector&lt;Ref&lt;AXIsolatedTreeNode&gt;&gt; nodeChanges;</span>
<span class="line-modified">2967     auto root = createIsolatedAccessibilityTreeHierarchy(*rootObject(), InvalidAXID, *tree, nodeChanges);</span>
<span class="line-modified">2968     tree-&gt;setRootNodeID(root-&gt;identifier());</span>
<span class="line-removed">2969     tree-&gt;appendNodeChanges(nodeChanges);</span>
2970 
2971     return makeRef(*tree);
2972 }
2973 #endif
2974 
2975 void AXObjectCache::deferRecomputeIsIgnoredIfNeeded(Element* element)
2976 {
2977     if (!nodeAndRendererAreValid(element))
2978         return;
2979 
2980     if (rendererNeedsDeferredUpdate(*element-&gt;renderer())) {
2981         m_deferredRecomputeIsIgnoredList.add(element);
2982         return;
2983     }
2984     recomputeIsIgnored(element-&gt;renderer());
2985 }
2986 
2987 void AXObjectCache::deferRecomputeIsIgnored(Element* element)
2988 {
2989     if (!nodeAndRendererAreValid(element))
</pre>
<hr />
<pre>
3042             const AtomString&amp; ariaHiddenValue = downcast&lt;Element&gt;(*testNode).attributeWithoutSynchronization(aria_hiddenAttr);
3043             if (equalLettersIgnoringASCIICase(ariaHiddenValue, &quot;true&quot;))
3044                 return false;
3045 
3046             bool ariaHiddenFalse = equalLettersIgnoringASCIICase(ariaHiddenValue, &quot;false&quot;);
3047             if (!testNode-&gt;renderer() &amp;&amp; !ariaHiddenFalse)
3048                 return false;
3049             if (!ariaHiddenFalsePresent &amp;&amp; ariaHiddenFalse)
3050                 ariaHiddenFalsePresent = true;
3051             // We should break early when it gets to a rendered object.
3052             if (testNode-&gt;renderer())
3053                 break;
3054         }
3055     }
3056 
3057     return !requiresAriaHiddenFalse || ariaHiddenFalsePresent;
3058 }
3059 
3060 AccessibilityObject* AXObjectCache::rootWebArea()
3061 {
<span class="line-modified">3062     AccessibilityObject* rootObject = this-&gt;rootObject();</span>
3063     if (!rootObject || !rootObject-&gt;isAccessibilityScrollView())
3064         return nullptr;
3065     return downcast&lt;AccessibilityScrollView&gt;(*rootObject).webAreaObject();
3066 }
3067 
3068 AXAttributeCacheEnabler::AXAttributeCacheEnabler(AXObjectCache* cache)
3069     : m_cache(cache)
3070 {
3071     if (m_cache)
3072         m_cache-&gt;startCachingComputedObjectAttributesUntilTreeMutates();
3073 }
3074 
3075 AXAttributeCacheEnabler::~AXAttributeCacheEnabler()
3076 {
3077     if (m_cache)
3078         m_cache-&gt;stopCachingComputedObjectAttributes();
3079 }
3080 
3081 #if !PLATFORM(COCOA)
3082 AXTextChange AXObjectCache::textChangeForEditType(AXTextEditType type)
</pre>
</td>
<td>
<hr />
<pre>
  15  *     from this software without specific prior written permission.
  16  *
  17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 
  31 #if ENABLE(ACCESSIBILITY)
  32 
  33 #include &quot;AXObjectCache.h&quot;
  34 
<span class="line-added">  35 #include &quot;AXIsolatedObject.h&quot;</span>
  36 #include &quot;AXIsolatedTree.h&quot;

  37 #include &quot;AccessibilityARIAGrid.h&quot;
  38 #include &quot;AccessibilityARIAGridCell.h&quot;
  39 #include &quot;AccessibilityARIAGridRow.h&quot;
  40 #include &quot;AccessibilityAttachment.h&quot;
  41 #include &quot;AccessibilityImageMapLink.h&quot;
  42 #include &quot;AccessibilityLabel.h&quot;
  43 #include &quot;AccessibilityList.h&quot;
  44 #include &quot;AccessibilityListBox.h&quot;
  45 #include &quot;AccessibilityListBoxOption.h&quot;
  46 #include &quot;AccessibilityMathMLElement.h&quot;
  47 #include &quot;AccessibilityMediaControls.h&quot;
  48 #include &quot;AccessibilityMediaObject.h&quot;
  49 #include &quot;AccessibilityMenuList.h&quot;
  50 #include &quot;AccessibilityMenuListOption.h&quot;
  51 #include &quot;AccessibilityMenuListPopup.h&quot;
  52 #include &quot;AccessibilityProgressIndicator.h&quot;
  53 #include &quot;AccessibilityRenderObject.h&quot;
  54 #include &quot;AccessibilitySVGElement.h&quot;
  55 #include &quot;AccessibilitySVGRoot.h&quot;
  56 #include &quot;AccessibilityScrollView.h&quot;
</pre>
<hr />
<pre>
  78 #include &quot;HTMLMeterElement.h&quot;
  79 #include &quot;HTMLNames.h&quot;
  80 #include &quot;HTMLParserIdioms.h&quot;
  81 #include &quot;HTMLTextFormControlElement.h&quot;
  82 #include &quot;InlineElementBox.h&quot;
  83 #include &quot;MathMLElement.h&quot;
  84 #include &quot;Page.h&quot;
  85 #include &quot;RenderAttachment.h&quot;
  86 #include &quot;RenderLineBreak.h&quot;
  87 #include &quot;RenderListBox.h&quot;
  88 #include &quot;RenderMathMLOperator.h&quot;
  89 #include &quot;RenderMenuList.h&quot;
  90 #include &quot;RenderMeter.h&quot;
  91 #include &quot;RenderProgress.h&quot;
  92 #include &quot;RenderSVGRoot.h&quot;
  93 #include &quot;RenderSlider.h&quot;
  94 #include &quot;RenderTable.h&quot;
  95 #include &quot;RenderTableCell.h&quot;
  96 #include &quot;RenderTableRow.h&quot;
  97 #include &quot;RenderView.h&quot;
<span class="line-added">  98 #include &quot;RuntimeEnabledFeatures.h&quot;</span>
  99 #include &quot;SVGElement.h&quot;
 100 #include &quot;ScriptDisallowedScope.h&quot;
 101 #include &quot;ScrollView.h&quot;
 102 #include &quot;TextBoundaries.h&quot;
 103 #include &quot;TextControlInnerElements.h&quot;
 104 #include &quot;TextIterator.h&quot;
<span class="line-added"> 105 </span>
<span class="line-added"> 106 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE) &amp;&amp; PLATFORM(MAC)</span>
<span class="line-added"> 107 #include &lt;pal/spi/mac/HIServicesSPI.h&gt;</span>
<span class="line-added"> 108 #endif</span>
<span class="line-added"> 109 </span>
 110 #include &lt;wtf/DataLog.h&gt;
 111 #include &lt;wtf/SetForScope.h&gt;
 112 
 113 #if ENABLE(VIDEO)
 114 #include &quot;MediaControlElements.h&quot;
 115 #endif
 116 
 117 #if COMPILER(MSVC)
 118 // See https://msdn.microsoft.com/en-us/library/1wea5zwe.aspx
 119 #pragma warning(disable: 4701)
 120 #endif
 121 
 122 namespace WebCore {
 123 
 124 using namespace HTMLNames;
 125 
 126 const AXID InvalidAXID = 0;
 127 
 128 // Post value change notifications for password fields or elements contained in password fields at a 40hz interval to thwart analysis of typing cadence
 129 static const Seconds accessibilityPasswordValueChangeNotificationInterval { 25_ms };
</pre>
<hr />
<pre>
 198 {
 199     gAccessibilityEnabled = true;
 200 }
 201 
 202 void AXObjectCache::disableAccessibility()
 203 {
 204     gAccessibilityEnabled = false;
 205 }
 206 
 207 void AXObjectCache::setEnhancedUserInterfaceAccessibility(bool flag)
 208 {
 209     gAccessibilityEnhancedUserInterfaceEnabled = flag;
 210 #if PLATFORM(MAC)
 211     if (flag)
 212         enableAccessibility();
 213 #endif
 214 }
 215 
 216 AXObjectCache::AXObjectCache(Document&amp; document)
 217     : m_document(document)
<span class="line-added"> 218     , m_pageID(document.pageID())</span>
 219     , m_notificationPostTimer(*this, &amp;AXObjectCache::notificationPostTimerFired)
 220     , m_passwordNotificationPostTimer(*this, &amp;AXObjectCache::passwordNotificationPostTimerFired)
 221     , m_liveRegionChangedPostTimer(*this, &amp;AXObjectCache::liveRegionChangedNotificationPostTimerFired)
 222     , m_focusModalNodeTimer(*this, &amp;AXObjectCache::focusModalNodeTimerFired)
 223     , m_currentModalNode(nullptr)
 224     , m_performCacheUpdateTimer(*this, &amp;AXObjectCache::performCacheUpdateTimerFired)
 225 {
 226     findModalNodes();
 227 }
 228 
 229 AXObjectCache::~AXObjectCache()
 230 {
 231     m_notificationPostTimer.stop();
 232     m_liveRegionChangedPostTimer.stop();
 233     m_focusModalNodeTimer.stop();
 234     m_performCacheUpdateTimer.stop();
 235 
<span class="line-modified"> 236 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)</span>
<span class="line-modified"> 237     // Destroy the IsolatedTree before destroying the live tree.</span>
<span class="line-added"> 238     if (m_pageID)</span>
<span class="line-added"> 239         AXIsolatedTree::removeTreeForPageID(*m_pageID);</span>
<span class="line-added"> 240 #endif</span>
<span class="line-added"> 241 </span>
<span class="line-added"> 242     for (const auto&amp; object : m_objects.values())</span>
 243         object-&gt;detach(AccessibilityDetachmentType::CacheDestroyed);


 244 }
 245 
 246 void AXObjectCache::findModalNodes()
 247 {
 248     // Traverse the DOM tree to look for the aria-modal=true nodes.
 249     for (Element* element = ElementTraversal::firstWithin(document().rootNode()); element; element = ElementTraversal::nextIncludingPseudo(*element)) {
 250 
 251         // Must have dialog or alertdialog role
 252         if (!nodeHasRole(element, &quot;dialog&quot;) &amp;&amp; !nodeHasRole(element, &quot;alertdialog&quot;))
 253             continue;
 254         if (!equalLettersIgnoringASCIICase(element-&gt;attributeWithoutSynchronization(aria_modalAttr), &quot;true&quot;))
 255             continue;
 256 
 257         m_modalNodesSet.add(element);
 258     }
 259 
 260     // Set the current valid aria-modal node if possible.
 261     updateCurrentModalNode();
 262 }
 263 
</pre>
<hr />
<pre>
 331 AccessibilityObject* AXObjectCache::focusedImageMapUIElement(HTMLAreaElement* areaElement)
 332 {
 333     // Find the corresponding accessibility object for the HTMLAreaElement. This should be
 334     // in the list of children for its corresponding image.
 335     if (!areaElement)
 336         return nullptr;
 337 
 338     HTMLImageElement* imageElement = areaElement-&gt;imageElement();
 339     if (!imageElement)
 340         return nullptr;
 341 
 342     AccessibilityObject* axRenderImage = areaElement-&gt;document().axObjectCache()-&gt;getOrCreate(imageElement);
 343     if (!axRenderImage)
 344         return nullptr;
 345 
 346     for (const auto&amp; child : axRenderImage-&gt;children()) {
 347         if (!is&lt;AccessibilityImageMapLink&gt;(*child))
 348             continue;
 349 
 350         if (downcast&lt;AccessibilityImageMapLink&gt;(*child).areaElement() == areaElement)
<span class="line-modified"> 351             return downcast&lt;AccessibilityImageMapLink&gt;(child.get());</span>
 352     }
 353 
 354     return nullptr;
 355 }
 356 
<span class="line-modified"> 357 AXCoreObject* AXObjectCache::focusedObject(Document&amp; document)</span>
 358 {
<span class="line-modified"> 359     Element* focusedElement = document.focusedElement();</span>





 360     if (is&lt;HTMLAreaElement&gt;(focusedElement))
 361         return focusedImageMapUIElement(downcast&lt;HTMLAreaElement&gt;(focusedElement));
 362 
<span class="line-modified"> 363     auto* axObjectCache = document.axObjectCache();</span>
<span class="line-modified"> 364     if (!axObjectCache)</span>
 365         return nullptr;
 366 
<span class="line-modified"> 367     AXCoreObject* focus = axObjectCache-&gt;getOrCreate(focusedElement ? focusedElement : static_cast&lt;Node*&gt;(&amp;document));</span>
<span class="line-modified"> 368     if (!focus)</span>
<span class="line-modified"> 369         return nullptr;</span>
<span class="line-added"> 370 </span>
<span class="line-added"> 371     if (focus-&gt;shouldFocusActiveDescendant()) {</span>
<span class="line-added"> 372         if (auto* descendant = focus-&gt;activeDescendant())</span>
<span class="line-added"> 373             focus = descendant;</span>
 374     }
 375 
 376     // the HTML element, for example, is focusable but has an AX object that is ignored
<span class="line-modified"> 377     if (focus-&gt;accessibilityIsIgnored())</span>
<span class="line-modified"> 378         focus = focus-&gt;parentObjectUnignored();</span>
<span class="line-added"> 379 </span>
<span class="line-added"> 380     return focus;</span>
<span class="line-added"> 381 }</span>
<span class="line-added"> 382 </span>
<span class="line-added"> 383 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)</span>
<span class="line-added"> 384 AXCoreObject* AXObjectCache::isolatedTreeFocusedObject(Document&amp; document)</span>
<span class="line-added"> 385 {</span>
<span class="line-added"> 386     auto pageID = document.pageID();</span>
<span class="line-added"> 387     if (!pageID)</span>
<span class="line-added"> 388         return nullptr;</span>
<span class="line-added"> 389 </span>
<span class="line-added"> 390     auto tree = AXIsolatedTree::treeForPageID(*pageID);</span>
<span class="line-added"> 391     if (!tree) {</span>
<span class="line-added"> 392         tree = generateIsolatedTree(*pageID, document);</span>
<span class="line-added"> 393         // Now that we have created our tree, initialize the secondary thread,</span>
<span class="line-added"> 394         // so future requests come in on the other thread.</span>
<span class="line-added"> 395         _AXUIElementUseSecondaryAXThread(true);</span>
<span class="line-added"> 396     }</span>
<span class="line-added"> 397 </span>
<span class="line-added"> 398     if (tree)</span>
<span class="line-added"> 399         return tree-&gt;focusedUIElement().get();</span>
 400 
<span class="line-modified"> 401     // Should not get here, couldn&#39;t create the IsolatedTree.</span>
<span class="line-added"> 402     ASSERT_NOT_REACHED();</span>
<span class="line-added"> 403     return nullptr;</span>
<span class="line-added"> 404 }</span>
<span class="line-added"> 405 </span>
<span class="line-added"> 406 void AXObjectCache::setIsolatedTreeFocusedObject(Node* focusedNode)</span>
<span class="line-added"> 407 {</span>
<span class="line-added"> 408     ASSERT(isMainThread());</span>
<span class="line-added"> 409     if (!m_pageID)</span>
<span class="line-added"> 410         return;</span>
<span class="line-added"> 411 </span>
<span class="line-added"> 412     auto* focus = getOrCreate(focusedNode);</span>
<span class="line-added"> 413 </span>
<span class="line-added"> 414     if (auto tree = AXIsolatedTree::treeForPageID(*m_pageID))</span>
<span class="line-added"> 415         tree-&gt;setFocusedNodeID(focus ? focus-&gt;objectID() : InvalidAXID);</span>
<span class="line-added"> 416 }</span>
<span class="line-added"> 417 #endif</span>
<span class="line-added"> 418 </span>
<span class="line-added"> 419 AXCoreObject* AXObjectCache::focusedUIElementForPage(const Page* page)</span>
<span class="line-added"> 420 {</span>
<span class="line-added"> 421     ASSERT(isMainThread());</span>
<span class="line-added"> 422     if (!gAccessibilityEnabled)</span>
<span class="line-added"> 423         return nullptr;</span>
<span class="line-added"> 424 </span>
<span class="line-added"> 425     // get the focused node in the page</span>
<span class="line-added"> 426     Document* focusedDocument = page-&gt;focusController().focusedOrMainFrame().document();</span>
<span class="line-added"> 427     if (!focusedDocument)</span>
<span class="line-added"> 428         return nullptr;</span>
<span class="line-added"> 429 </span>
<span class="line-added"> 430 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)</span>
<span class="line-added"> 431     if (clientSupportsIsolatedTree())</span>
<span class="line-added"> 432         return isolatedTreeFocusedObject(*focusedDocument);</span>
<span class="line-added"> 433 #endif</span>
<span class="line-added"> 434 </span>
<span class="line-added"> 435     return focusedObject(*focusedDocument);</span>
 436 }
 437 
 438 AccessibilityObject* AXObjectCache::get(Widget* widget)
 439 {
 440     if (!widget)
 441         return nullptr;
 442 
 443     AXID axID = m_widgetObjectMapping.get(widget);
 444     ASSERT(!HashTraits&lt;AXID&gt;::isDeletedValue(axID));
 445     if (!axID)
 446         return nullptr;
 447 
 448     return m_objects.get(axID);
 449 }
 450 
 451 AccessibilityObject* AXObjectCache::get(RenderObject* renderer)
 452 {
 453     if (!renderer)
 454         return nullptr;
 455 
</pre>
<hr />
<pre>
 583             return AccessibilityAttachment::create(&amp;downcast&lt;RenderAttachment&gt;(cssBox));
 584 #endif
 585 #if ENABLE(METER_ELEMENT)
 586         if (is&lt;RenderMeter&gt;(cssBox))
 587             return AccessibilityProgressIndicator::create(&amp;downcast&lt;RenderMeter&gt;(cssBox));
 588 #endif
 589 
 590         // input type=range
 591         if (is&lt;RenderSlider&gt;(cssBox))
 592             return AccessibilitySlider::create(&amp;downcast&lt;RenderSlider&gt;(cssBox));
 593     }
 594 
 595     return AccessibilityRenderObject::create(renderer);
 596 }
 597 
 598 static Ref&lt;AccessibilityObject&gt; createFromNode(Node* node)
 599 {
 600     return AccessibilityNodeObject::create(node);
 601 }
 602 
<span class="line-added"> 603 void AXObjectCache::cacheAndInitializeWrapper(AccessibilityObject* newObject, DOMObjectVariant domObject)</span>
<span class="line-added"> 604 {</span>
<span class="line-added"> 605     ASSERT(newObject);</span>
<span class="line-added"> 606     AXID axID = getAXID(newObject);</span>
<span class="line-added"> 607     WTF::switchOn(domObject,</span>
<span class="line-added"> 608         [&amp;axID, this] (RenderObject* typedValue) { m_renderObjectMapping.set(typedValue, axID); },</span>
<span class="line-added"> 609         [&amp;axID, this] (Node* typedValue) { m_nodeObjectMapping.set(typedValue, axID); },</span>
<span class="line-added"> 610         [&amp;axID, this] (Widget* typedValue) { m_widgetObjectMapping.set(typedValue, axID); },</span>
<span class="line-added"> 611         [] (auto&amp;) { }</span>
<span class="line-added"> 612     );</span>
<span class="line-added"> 613     m_objects.set(axID, newObject);</span>
<span class="line-added"> 614     newObject-&gt;init();</span>
<span class="line-added"> 615     attachWrapper(newObject);</span>
<span class="line-added"> 616 }</span>
<span class="line-added"> 617 </span>
 618 AccessibilityObject* AXObjectCache::getOrCreate(Widget* widget)
 619 {
 620     if (!widget)
 621         return nullptr;
 622 
 623     if (AccessibilityObject* obj = get(widget))
 624         return obj;
 625 
 626     RefPtr&lt;AccessibilityObject&gt; newObj;
 627     if (is&lt;ScrollView&gt;(*widget))
 628         newObj = AccessibilityScrollView::create(downcast&lt;ScrollView&gt;(widget));
 629     else if (is&lt;Scrollbar&gt;(*widget))
 630         newObj = AccessibilityScrollbar::create(downcast&lt;Scrollbar&gt;(widget));
 631 
 632     // Will crash later if we have two objects for the same widget.
 633     ASSERT(!get(widget));
 634 
 635     // Catch the case if an (unsupported) widget type is used. Only FrameView and ScrollBar are supported now.
 636     ASSERT(newObj);
 637     if (!newObj)
 638         return nullptr;
 639 
<span class="line-modified"> 640     cacheAndInitializeWrapper(newObj.get(), widget);</span>





 641     return newObj.get();
 642 }
 643 
 644 AccessibilityObject* AXObjectCache::getOrCreate(Node* node)
 645 {
 646     if (!node)
 647         return nullptr;
 648 
 649     if (AccessibilityObject* obj = get(node))
 650         return obj;
 651 
 652     if (node-&gt;renderer())
 653         return getOrCreate(node-&gt;renderer());
 654 
 655     if (!node-&gt;parentElement())
 656         return nullptr;
 657 
 658     // It&#39;s only allowed to create an AccessibilityObject from a Node if it&#39;s in a canvas subtree.
 659     // Or if it&#39;s a hidden element, but we still want to expose it because of other ARIA attributes.
 660     bool inCanvasSubtree = lineageOfType&lt;HTMLCanvasElement&gt;(*node-&gt;parentElement()).first();
</pre>
<hr />
<pre>
 663     bool insideMeterElement = false;
 664 #if ENABLE(METER_ELEMENT)
 665     insideMeterElement = is&lt;HTMLMeterElement&gt;(*node-&gt;parentElement());
 666 #endif
 667 
 668     if (!inCanvasSubtree &amp;&amp; !isHidden &amp;&amp; !insideMeterElement)
 669         return nullptr;
 670 
 671     auto protectedNode = makeRef(*node);
 672 
 673     // Fallback content is only focusable as long as the canvas is displayed and visible.
 674     // Update the style before Element::isFocusable() gets called.
 675     if (inCanvasSubtree)
 676         node-&gt;document().updateStyleIfNeeded();
 677 
 678     RefPtr&lt;AccessibilityObject&gt; newObj = createFromNode(node);
 679 
 680     // Will crash later if we have two objects for the same node.
 681     ASSERT(!get(node));
 682 
<span class="line-modified"> 683     cacheAndInitializeWrapper(newObj.get(), node);</span>





 684     newObj-&gt;setLastKnownIsIgnoredValue(newObj-&gt;accessibilityIsIgnored());
 685     // Sometimes asking accessibilityIsIgnored() will cause the newObject to be deallocated, and then
 686     // it will disappear when this function is finished, leading to a use-after-free.
 687     if (newObj-&gt;isDetached())
 688         return nullptr;
 689 
 690     return newObj.get();
 691 }
 692 
 693 AccessibilityObject* AXObjectCache::getOrCreate(RenderObject* renderer)
 694 {
 695     if (!renderer)
 696         return nullptr;
 697 
 698     if (AccessibilityObject* obj = get(renderer))
 699         return obj;
 700 
 701     RefPtr&lt;AccessibilityObject&gt; newObj = createFromRenderer(renderer);
 702 
 703     // Will crash later if we have two objects for the same renderer.
 704     ASSERT(!get(renderer));
 705 
<span class="line-modified"> 706     cacheAndInitializeWrapper(newObj.get(), renderer);</span>





 707     newObj-&gt;setLastKnownIsIgnoredValue(newObj-&gt;accessibilityIsIgnored());
 708     // Sometimes asking accessibilityIsIgnored() will cause the newObject to be deallocated, and then
 709     // it will disappear when this function is finished, leading to a use-after-free.
 710     if (newObj-&gt;isDetached())
 711         return nullptr;
 712 
 713     return newObj.get();
 714 }
 715 
<span class="line-modified"> 716 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)</span>
<span class="line-added"> 717 bool AXObjectCache::clientSupportsIsolatedTree()</span>
<span class="line-added"> 718 {</span>
<span class="line-added"> 719     if (!RuntimeEnabledFeatures::sharedFeatures().isAccessibilityIsolatedTreeEnabled())</span>
<span class="line-added"> 720         return false;</span>
<span class="line-added"> 721 </span>
<span class="line-added"> 722     AXClientType type = _AXGetClientForCurrentRequestUntrusted();</span>
<span class="line-added"> 723     // FIXME: Remove unknown client before setting isAccessibilityIsolatedTreeEnabled initial value = true.</span>
<span class="line-added"> 724     return type == kAXClientTypeVoiceOver</span>
<span class="line-added"> 725         || type == kAXClientTypeUnknown;</span>
<span class="line-added"> 726 }</span>
<span class="line-added"> 727 #endif</span>
<span class="line-added"> 728 </span>
<span class="line-added"> 729 AXCoreObject* AXObjectCache::rootObject()</span>
 730 {
 731     if (!gAccessibilityEnabled)
 732         return nullptr;
 733 
<span class="line-added"> 734 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)</span>
<span class="line-added"> 735     if (clientSupportsIsolatedTree())</span>
<span class="line-added"> 736         return isolatedTreeRootObject();</span>
<span class="line-added"> 737 #endif</span>
<span class="line-added"> 738 </span>
 739     return getOrCreate(m_document.view());
 740 }
 741 
<span class="line-added"> 742 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)</span>
<span class="line-added"> 743 AXCoreObject* AXObjectCache::isolatedTreeRootObject()</span>
<span class="line-added"> 744 {</span>
<span class="line-added"> 745     if (!m_pageID)</span>
<span class="line-added"> 746         return nullptr;</span>
<span class="line-added"> 747 </span>
<span class="line-added"> 748     auto tree = AXIsolatedTree::treeForPageID(*m_pageID);</span>
<span class="line-added"> 749     if (!tree) {</span>
<span class="line-added"> 750         tree = Accessibility::retrieveValueFromMainThread&lt;RefPtr&lt;AXIsolatedTree&gt;&gt;([this] () -&gt; RefPtr&lt;AXIsolatedTree&gt; {</span>
<span class="line-added"> 751             return generateIsolatedTree(*m_pageID, m_document);</span>
<span class="line-added"> 752         });</span>
<span class="line-added"> 753 </span>
<span class="line-added"> 754         // Now that we have created our tree, initialize the secondary thread,</span>
<span class="line-added"> 755         // so future requests come in on the other thread.</span>
<span class="line-added"> 756         _AXUIElementUseSecondaryAXThread(true);</span>
<span class="line-added"> 757     }</span>
<span class="line-added"> 758 </span>
<span class="line-added"> 759     if (tree)</span>
<span class="line-added"> 760         return tree-&gt;rootNode().get();</span>
<span class="line-added"> 761 </span>
<span class="line-added"> 762     // Should not get here, couldn&#39;t create the IsolatedTree.</span>
<span class="line-added"> 763     ASSERT_NOT_REACHED();</span>
<span class="line-added"> 764     return nullptr;</span>
<span class="line-added"> 765 }</span>
<span class="line-added"> 766 #endif</span>
<span class="line-added"> 767 </span>
<span class="line-added"> 768 bool AXObjectCache::canUseSecondaryAXThread()</span>
<span class="line-added"> 769 {</span>
<span class="line-added"> 770 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE) &amp;&amp; PLATFORM(MAC)</span>
<span class="line-added"> 771     if (_AXUIElementRequestServicedBySecondaryAXThread())</span>
<span class="line-added"> 772         return true;</span>
<span class="line-added"> 773 </span>
<span class="line-added"> 774     // _AXUIElementRequestServicedBySecondaryAXThread returns false for</span>
<span class="line-added"> 775     // LayoutTests, but we still want to run LayoutTests using isolated tree on</span>
<span class="line-added"> 776     // a secondary thread to simulate the actual execution.</span>
<span class="line-added"> 777     return clientSupportsIsolatedTree();</span>
<span class="line-added"> 778 #else</span>
<span class="line-added"> 779     return false;</span>
<span class="line-added"> 780 #endif</span>
<span class="line-added"> 781 }</span>
<span class="line-added"> 782 </span>
 783 AccessibilityObject* AXObjectCache::rootObjectForFrame(Frame* frame)
 784 {
 785     if (!gAccessibilityEnabled)
 786         return nullptr;
 787 
 788     if (!frame)
 789         return nullptr;
 790     return getOrCreate(frame-&gt;view());
 791 }
 792 
 793 AccessibilityObject* AXObjectCache::getOrCreate(AccessibilityRole role)
 794 {
<span class="line-modified"> 795     RefPtr&lt;AccessibilityObject&gt; obj;</span>
 796 
 797     // will be filled in...
 798     switch (role) {
 799     case AccessibilityRole::ListBoxOption:
 800         obj = AccessibilityListBoxOption::create();
 801         break;
 802     case AccessibilityRole::ImageMapLink:
 803         obj = AccessibilityImageMapLink::create();
 804         break;
 805     case AccessibilityRole::Column:
 806         obj = AccessibilityTableColumn::create();
 807         break;
 808     case AccessibilityRole::TableHeaderContainer:
 809         obj = AccessibilityTableHeaderContainer::create();
 810         break;
 811     case AccessibilityRole::SliderThumb:
 812         obj = AccessibilitySliderThumb::create();
 813         break;
 814     case AccessibilityRole::MenuListPopup:
 815         obj = AccessibilityMenuListPopup::create();
 816         break;
 817     case AccessibilityRole::MenuListOption:
 818         obj = AccessibilityMenuListOption::create();
 819         break;
 820     case AccessibilityRole::SpinButton:
 821         obj = AccessibilitySpinButton::create();
 822         break;
 823     case AccessibilityRole::SpinButtonPart:
 824         obj = AccessibilitySpinButtonPart::create();
 825         break;
 826     default:
 827         obj = nullptr;
 828     }
 829 
<span class="line-modified"> 830     if (!obj)</span>


 831         return nullptr;
 832 
<span class="line-modified"> 833     cacheAndInitializeWrapper(obj.get());</span>


 834     return obj.get();
 835 }
 836 
 837 void AXObjectCache::remove(AXID axID)
 838 {
 839     if (!axID)
 840         return;
 841 
<span class="line-added"> 842 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)</span>
<span class="line-added"> 843     if (m_pageID) {</span>
<span class="line-added"> 844         if (auto tree = AXIsolatedTree::treeForPageID(*m_pageID))</span>
<span class="line-added"> 845             tree-&gt;removeNode(axID);</span>
<span class="line-added"> 846     }</span>
<span class="line-added"> 847 #endif</span>
<span class="line-added"> 848 </span>
 849     auto object = m_objects.take(axID);
 850     if (!object)
 851         return;
 852 
<span class="line-modified"> 853     object-&gt;detach(AccessibilityDetachmentType::ElementDestroyed);</span>


 854 
 855     m_idsInUse.remove(axID);





 856     ASSERT(m_objects.size() &gt;= m_idsInUse.size());
 857 }
 858 
 859 void AXObjectCache::remove(RenderObject* renderer)
 860 {
 861     if (!renderer)
 862         return;
 863     remove(m_renderObjectMapping.take(renderer));
 864 }
 865 
 866 void AXObjectCache::remove(Node&amp; node)
 867 {
 868     if (is&lt;Element&gt;(node)) {
 869         m_deferredRecomputeIsIgnoredList.remove(downcast&lt;Element&gt;(&amp;node));
 870         m_deferredSelectedChildredChangedList.remove(downcast&lt;Element&gt;(&amp;node));
 871         m_deferredTextFormControlValue.remove(downcast&lt;Element&gt;(&amp;node));
 872         m_deferredAttributeChange.remove(downcast&lt;Element&gt;(&amp;node));
 873     }
 874     m_deferredChildrenChangedNodeList.remove(&amp;node);
 875     m_deferredTextChangedList.remove(&amp;node);
 876     // Remove the entry if the new focused node is being removed.
 877     m_deferredFocusedNodeChange.removeAllMatching([&amp;node](auto&amp; entry) -&gt; bool {
 878         return entry.second == &amp;node;
 879     });
<span class="line-added"> 880     // Set nullptr to the old focused node if it is being removed.</span>
<span class="line-added"> 881     std::for_each(m_deferredFocusedNodeChange.begin(), m_deferredFocusedNodeChange.end(), [&amp;node](auto&amp; entry) {</span>
<span class="line-added"> 882         if (entry.first == &amp;node)</span>
<span class="line-added"> 883             entry.first = nullptr;</span>
<span class="line-added"> 884     });</span>
<span class="line-added"> 885 </span>
 886     removeNodeForUse(node);
 887 
 888     remove(m_nodeObjectMapping.take(&amp;node));
 889 
 890     if (m_currentModalNode == &amp;node)
 891         m_currentModalNode = nullptr;
 892     m_modalNodesSet.remove(&amp;node);
 893 
 894     remove(node.renderer());
 895 }
 896 
 897 void AXObjectCache::remove(Widget* view)
 898 {
 899     if (!view)
 900         return;
 901     remove(m_widgetObjectMapping.take(view));
 902 }
 903 
 904 
 905 #if !PLATFORM(WIN)
 906 AXID AXObjectCache::platformGenerateAXID() const
 907 {
 908     static AXID lastUsedID = 0;
 909 
 910     // Generate a new ID.
 911     AXID objID = lastUsedID;
 912     do {
 913         ++objID;
 914     } while (!objID || HashTraits&lt;AXID&gt;::isDeletedValue(objID) || m_idsInUse.contains(objID));
 915 
 916     lastUsedID = objID;
 917 
 918     return objID;
 919 }
 920 #endif
 921 
 922 AXID AXObjectCache::getAXID(AccessibilityObject* obj)
 923 {
 924     // check for already-assigned ID
<span class="line-modified"> 925     AXID objID = obj-&gt;objectID();</span>
 926     if (objID) {
 927         ASSERT(m_idsInUse.contains(objID));
 928         return objID;
 929     }
 930 
 931     objID = platformGenerateAXID();
 932 
 933     m_idsInUse.add(objID);
<span class="line-modified"> 934     obj-&gt;setObjectID(objID);</span>
 935 
 936     return objID;
 937 }
 938 
 939 void AXObjectCache::textChanged(Node* node)
 940 {
 941     textChanged(getOrCreate(node));
 942 }
 943 
 944 void AXObjectCache::textChanged(AccessibilityObject* obj)
 945 {
 946     if (!obj)
 947         return;
 948 
 949     bool parentAlreadyExists = obj-&gt;parentObjectIfExists();
 950     obj-&gt;textChanged();
 951     postNotification(obj, obj-&gt;document(), AXObjectCache::AXTextChanged);
 952     if (parentAlreadyExists)
 953         obj-&gt;notifyIfIgnoredValueChanged();
 954 }
</pre>
<hr />
<pre>
 987 
 988 void AXObjectCache::childrenChanged(Node* node, Node* newChild)
 989 {
 990     if (newChild)
 991         m_deferredChildrenChangedNodeList.add(newChild);
 992 
 993     childrenChanged(get(node));
 994 }
 995 
 996 void AXObjectCache::childrenChanged(RenderObject* renderer, RenderObject* newChild)
 997 {
 998     if (!renderer)
 999         return;
1000 
1001     if (newChild &amp;&amp; newChild-&gt;node())
1002         m_deferredChildrenChangedNodeList.add(newChild-&gt;node());
1003 
1004     childrenChanged(get(renderer));
1005 }
1006 
<span class="line-modified">1007 void AXObjectCache::childrenChanged(AXCoreObject* obj)</span>
1008 {
1009     if (!obj)
1010         return;
1011 
<span class="line-modified">1012     m_deferredChildrenChangedList.add(obj);</span>
1013 }
1014 
1015 void AXObjectCache::notificationPostTimerFired()
1016 {
1017     Ref&lt;Document&gt; protectorForCacheOwner(m_document);
1018     m_notificationPostTimer.stop();
1019 
1020     // In tests, posting notifications has a tendency to immediately queue up other notifications, which can lead to unexpected behavior
1021     // when the notification list is cleared at the end. Instead copy this list at the start.
1022     auto notifications = WTFMove(m_notificationsToPost);
1023 
1024     for (const auto&amp; note : notifications) {
<span class="line-modified">1025         AXCoreObject* obj = note.first.get();</span>
<span class="line-modified">1026         if (!obj-&gt;objectID())</span>
1027             continue;
1028 
1029         if (!obj-&gt;axObjectCache())
1030             continue;
1031 
1032 #ifndef NDEBUG
1033         // Make sure none of the render views are in the process of being layed out.
1034         // Notifications should only be sent after the renderer has finished
1035         if (is&lt;AccessibilityRenderObject&gt;(*obj)) {
1036             if (auto* renderer = downcast&lt;AccessibilityRenderObject&gt;(*obj).renderer())
1037                 ASSERT(!renderer-&gt;view().frameView().layoutContext().layoutState());
1038         }
1039 #endif
1040 
1041         AXNotification notification = note.second;
1042 
1043         // Ensure that this menu really is a menu. We do this check here so that we don&#39;t have to create
1044         // the axChildren when the menu is marked as opening.
1045         if (notification == AXMenuOpened) {
1046             obj-&gt;updateChildrenIfNecessary();
</pre>
<hr />
<pre>
1094 {
1095     if (!node)
1096         return;
1097 
1098     stopCachingComputedObjectAttributes();
1099 
1100     // Get an accessibility object that already exists. One should not be created here
1101     // because a render update may be in progress and creating an AX object can re-trigger a layout
1102     RefPtr&lt;AccessibilityObject&gt; object = get(node);
1103     while (!object &amp;&amp; node) {
1104         node = node-&gt;parentNode();
1105         object = get(node);
1106     }
1107 
1108     if (!node)
1109         return;
1110 
1111     postNotification(object.get(), &amp;node-&gt;document(), notification, postTarget, postType);
1112 }
1113 
<span class="line-modified">1114 void AXObjectCache::postNotification(AXCoreObject* object, Document* document, AXNotification notification, PostTarget postTarget, PostType postType)</span>
1115 {
1116     stopCachingComputedObjectAttributes();
1117 
1118     if (object &amp;&amp; postTarget == TargetObservableParent)
1119         object = object-&gt;observableObject();
1120 
1121     if (!object &amp;&amp; document)
1122         object = get(document-&gt;renderView());
1123 
1124     if (!object)
1125         return;
1126 
1127     if (postType == PostAsynchronously) {
1128         m_notificationsToPost.append(std::make_pair(object, notification));
1129         if (!m_notificationPostTimer.isActive())
1130             m_notificationPostTimer.startOneShot(0_s);
1131     } else
1132         postPlatformNotification(object, notification);
1133 }
1134 
</pre>
<hr />
<pre>
1146         return;
1147 
1148     if (!downcast&lt;Element&gt;(*node).focused() &amp;&amp; !equalLettersIgnoringASCIICase(downcast&lt;Element&gt;(*node).attributeWithoutSynchronization(aria_selectedAttr), &quot;true&quot;))
1149         return;
1150 
1151     postNotification(getOrCreate(node), &amp;document(), AXMenuListItemSelected);
1152 }
1153 
1154 void AXObjectCache::deferFocusedUIElementChangeIfNeeded(Node* oldNode, Node* newNode)
1155 {
1156     if (nodeAndRendererAreValid(newNode) &amp;&amp; rendererNeedsDeferredUpdate(*newNode-&gt;renderer())) {
1157         m_deferredFocusedNodeChange.append({ oldNode, newNode });
1158         if (!newNode-&gt;renderer()-&gt;needsLayout() &amp;&amp; !m_performCacheUpdateTimer.isActive())
1159             m_performCacheUpdateTimer.startOneShot(0_s);
1160     } else
1161         handleFocusedUIElementChanged(oldNode, newNode);
1162 }
1163 
1164 void AXObjectCache::handleFocusedUIElementChanged(Node* oldNode, Node* newNode)
1165 {
<span class="line-added">1166 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)</span>
<span class="line-added">1167     setIsolatedTreeFocusedObject(newNode);</span>
<span class="line-added">1168 #endif</span>
<span class="line-added">1169 </span>
1170     handleMenuItemSelected(newNode);
1171     platformHandleFocusedUIElementChanged(oldNode, newNode);
1172 }
1173 
1174 void AXObjectCache::selectedChildrenChanged(Node* node)
1175 {
1176     handleMenuItemSelected(node);
1177 
1178     // postTarget is TargetObservableParent so that you can pass in any child of an element and it will go up the parent tree
1179     // to find the container which should send out the notification.
1180     postNotification(node, AXSelectedChildrenChanged, TargetObservableParent);
1181 }
1182 
1183 void AXObjectCache::selectedChildrenChanged(RenderObject* renderer)
1184 {
1185     if (renderer)
1186         handleMenuItemSelected(renderer-&gt;node());
1187 
1188     // postTarget is TargetObservableParent so that you can pass in any child of an element and it will go up the parent tree
1189     // to find the container which should send out the notification.
</pre>
<hr />
<pre>
1608 
1609     // If an AXObject has yet to be created, then there&#39;s no need to process attribute changes.
1610     // Some of these notifications are processed on the parent, so allow that to proceed as well
1611     if (get(element) || get(element-&gt;parentNode()))
1612         return true;
1613 
1614     return false;
1615 }
1616 
1617 void AXObjectCache::handleAttributeChange(const QualifiedName&amp; attrName, Element* element)
1618 {
1619     if (!shouldProcessAttributeChange(attrName, element))
1620         return;
1621 
1622     if (attrName == roleAttr)
1623         handleAriaRoleChanged(element);
1624     else if (attrName == altAttr || attrName == titleAttr)
1625         textChanged(element);
1626     else if (attrName == forAttr &amp;&amp; is&lt;HTMLLabelElement&gt;(*element))
1627         labelChanged(element);
<span class="line-added">1628     else if (attrName == tabindexAttr)</span>
<span class="line-added">1629         childrenChanged(element-&gt;parentNode(), element);</span>
1630 
1631     if (!attrName.localName().string().startsWith(&quot;aria-&quot;))
1632         return;
1633 
1634     if (attrName == aria_activedescendantAttr)
1635         handleActiveDescendantChanged(element);
1636     else if (attrName == aria_busyAttr)
1637         postNotification(element, AXObjectCache::AXElementBusyChanged);
1638     else if (attrName == aria_valuenowAttr || attrName == aria_valuetextAttr)
1639         postNotification(element, AXObjectCache::AXValueChanged);
1640     else if (attrName == aria_labelAttr || attrName == aria_labeledbyAttr || attrName == aria_labelledbyAttr)
1641         textChanged(element);
1642     else if (attrName == aria_checkedAttr)
1643         checkedStateChanged(element);
1644     else if (attrName == aria_selectedAttr)
1645         selectedChildrenChanged(element);
1646     else if (attrName == aria_expandedAttr)
1647         handleAriaExpandedChange(element);
1648     else if (attrName == aria_hiddenAttr)
1649         childrenChanged(element-&gt;parentNode(), element);
</pre>
<hr />
<pre>
2046         return;
2047 
2048     Node* domNode = characterOffset.node;
2049     if (is&lt;HTMLInputElement&gt;(*domNode) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*domNode).isPasswordField()) {
2050         textMarkerData.ignored = true;
2051         return;
2052     }
2053 
2054     RefPtr&lt;AccessibilityObject&gt; obj = this-&gt;getOrCreate(domNode);
2055     if (!obj)
2056         return;
2057 
2058     // Convert to visible position.
2059     VisiblePosition visiblePosition = visiblePositionFromCharacterOffset(characterOffset);
2060     int vpOffset = 0;
2061     if (!visiblePosition.isNull()) {
2062         Position deepPos = visiblePosition.deepEquivalent();
2063         vpOffset = deepPos.deprecatedEditingOffset();
2064     }
2065 
<span class="line-modified">2066     textMarkerData.axID = obj.get()-&gt;objectID();</span>
2067     textMarkerData.node = domNode;
2068     textMarkerData.characterOffset = characterOffset.offset;
2069     textMarkerData.characterStartIndex = characterOffset.startIndex;
2070     textMarkerData.offset = vpOffset;
2071     textMarkerData.affinity = visiblePosition.affinity();
2072 
2073     this-&gt;setNodeInUse(domNode);
2074 }
2075 
2076 CharacterOffset AXObjectCache::startOrEndCharacterOffsetForRange(RefPtr&lt;Range&gt; range, bool isStart, bool enterTextControls)
2077 {
2078     if (!range)
2079         return CharacterOffset();
2080 
2081     // When getting the end CharacterOffset at node boundary, we don&#39;t want to collapse to the previous node.
2082     if (!isStart &amp;&amp; !range-&gt;endOffset())
2083         return characterOffsetForNodeAndOffset(range-&gt;endContainer(), 0, TraverseOptionIncludeStart);
2084 
2085     // If it&#39;s end text marker, we want to go to the end of the range, and stay within the range.
2086     bool stayWithinRange = !isStart;
</pre>
<hr />
<pre>
2340     // If the visible position has an anchor type referring to a node other than the anchored node, we should
2341     // set the text marker data with CharacterOffset so that the offset will correspond to the node.
2342     CharacterOffset characterOffset = characterOffsetFromVisiblePosition(visiblePos);
2343     if (deepPos.anchorType() == Position::PositionIsAfterAnchor || deepPos.anchorType() == Position::PositionIsAfterChildren) {
2344         TextMarkerData textMarkerData;
2345         textMarkerDataForCharacterOffset(textMarkerData, characterOffset);
2346         return textMarkerData;
2347     }
2348 
2349     // find or create an accessibility object for this node
2350     AXObjectCache* cache = domNode-&gt;document().axObjectCache();
2351     if (!cache)
2352         return WTF::nullopt;
2353     RefPtr&lt;AccessibilityObject&gt; obj = cache-&gt;getOrCreate(domNode);
2354 
2355     // This memory must be zero&#39;d so instances of TextMarkerData can be tested for byte-equivalence.
2356     // Warning: This is risky and bad because TextMarkerData is a nontrivial type.
2357     TextMarkerData textMarkerData;
2358     memset(static_cast&lt;void*&gt;(&amp;textMarkerData), 0, sizeof(TextMarkerData));
2359 
<span class="line-modified">2360     textMarkerData.axID = obj.get()-&gt;objectID();</span>
2361     textMarkerData.node = domNode;
2362     textMarkerData.offset = deepPos.deprecatedEditingOffset();
2363     textMarkerData.affinity = visiblePos.affinity();
2364 
2365     textMarkerData.characterOffset = characterOffset.offset;
2366     textMarkerData.characterStartIndex = characterOffset.startIndex;
2367 
2368     cache-&gt;setNodeInUse(domNode);
2369 
2370     return textMarkerData;
2371 }
2372 
2373 // This function exits as a performance optimization to avoid a synchronous layout.
2374 Optional&lt;TextMarkerData&gt; AXObjectCache::textMarkerDataForFirstPositionInTextControl(HTMLTextFormControlElement&amp; textControl)
2375 {
2376     if (is&lt;HTMLInputElement&gt;(textControl) &amp;&amp; downcast&lt;HTMLInputElement&gt;(textControl).isPasswordField())
2377         return WTF::nullopt;
2378 
2379     AXObjectCache* cache = textControl.document().axObjectCache();
2380     if (!cache)
2381         return WTF::nullopt;
2382 
2383     RefPtr&lt;AccessibilityObject&gt; obj = cache-&gt;getOrCreate(&amp;textControl);
2384     if (!obj)
2385         return WTF::nullopt;
2386 
2387     // This memory must be zero&#39;d so instances of TextMarkerData can be tested for byte-equivalence.
2388     // Warning: This is risky and bad because TextMarkerData is a nontrivial type.
2389     TextMarkerData textMarkerData;
2390     memset(static_cast&lt;void*&gt;(&amp;textMarkerData), 0, sizeof(TextMarkerData));
2391 
<span class="line-modified">2392     textMarkerData.axID = obj.get()-&gt;objectID();</span>
2393     textMarkerData.node = &amp;textControl;
2394 
2395     cache-&gt;setNodeInUse(&amp;textControl);
2396 
2397     return textMarkerData;
2398 }
2399 
2400 CharacterOffset AXObjectCache::nextCharacterOffset(const CharacterOffset&amp; characterOffset, bool ignoreNextNodeStart)
2401 {
2402     if (characterOffset.isNull())
2403         return CharacterOffset();
2404 
2405     // We don&#39;t always move one &#39;character&#39; at a time since there might be composed characters.
2406     int nextOffset = Position::uncheckedNextOffset(characterOffset.node, characterOffset.offset);
2407     CharacterOffset next = characterOffsetForNodeAndOffset(*characterOffset.node, nextOffset);
2408 
2409     // To be consistent with VisiblePosition, we should consider the case that current node end to next node start counts 1 offset.
2410     if (!ignoreNextNodeStart &amp;&amp; !next.isNull() &amp;&amp; !isReplacedNodeOrBR(next.node) &amp;&amp; next.node != characterOffset.node) {
2411         int length = TextIterator::rangeLength(rangeForUnorderedCharacterOffsets(characterOffset, next).get());
2412         if (length &gt; nextOffset - characterOffset.offset)
</pre>
<hr />
<pre>
2503 {
2504     CharacterOffset start = startCharacterOffsetOfWord(characterOffset, LeftWordIfOnBoundary);
2505     CharacterOffset end = endCharacterOffsetOfWord(start);
2506     return rangeForUnorderedCharacterOffsets(start, end);
2507 }
2508 
2509 RefPtr&lt;Range&gt; AXObjectCache::rightWordRange(const CharacterOffset&amp; characterOffset)
2510 {
2511     CharacterOffset start = startCharacterOffsetOfWord(characterOffset, RightWordIfOnBoundary);
2512     CharacterOffset end = endCharacterOffsetOfWord(start);
2513     return rangeForUnorderedCharacterOffsets(start, end);
2514 }
2515 
2516 static UChar32 characterForCharacterOffset(const CharacterOffset&amp; characterOffset)
2517 {
2518     if (characterOffset.isNull() || !characterOffset.node-&gt;isTextNode())
2519         return 0;
2520 
2521     UChar32 ch = 0;
2522     unsigned offset = characterOffset.startIndex + characterOffset.offset;
<span class="line-modified">2523     if (offset &lt; characterOffset.node-&gt;textContent().length()) {</span>
<span class="line-added">2524 // FIXME: Remove IGNORE_CLANG_WARNINGS macros once one of &lt;rdar://problem/58615489&amp;58615391&gt; is fixed.</span>
<span class="line-added">2525 IGNORE_CLANG_WARNINGS_BEGIN(&quot;conditional-uninitialized&quot;)</span>
2526         U16_NEXT(characterOffset.node-&gt;textContent(), offset, characterOffset.node-&gt;textContent().length(), ch);
<span class="line-added">2527 IGNORE_CLANG_WARNINGS_END</span>
<span class="line-added">2528     }</span>
2529     return ch;
2530 }
2531 
2532 UChar32 AXObjectCache::characterAfter(const CharacterOffset&amp; characterOffset)
2533 {
2534     return characterForCharacterOffset(nextCharacterOffset(characterOffset));
2535 }
2536 
2537 UChar32 AXObjectCache::characterBefore(const CharacterOffset&amp; characterOffset)
2538 {
2539     return characterForCharacterOffset(characterOffset);
2540 }
2541 
2542 static bool characterOffsetNodeIsBR(const CharacterOffset&amp; characterOffset)
2543 {
2544     if (characterOffset.isNull())
2545         return false;
2546 
2547     return characterOffset.node-&gt;hasTagName(brTag);
2548 }
</pre>
<hr />
<pre>
2821         renderer = &amp;inlineBox-&gt;renderer();
2822 
2823     if (is&lt;RenderLineBreak&gt;(renderer) &amp;&amp; downcast&lt;RenderLineBreak&gt;(renderer)-&gt;inlineBoxWrapper() != inlineBox)
2824         return IntRect();
2825 
2826     return renderer-&gt;localCaretRect(inlineBox, caretOffset);
2827 }
2828 
2829 IntRect AXObjectCache::absoluteCaretBoundsForCharacterOffset(const CharacterOffset&amp; characterOffset)
2830 {
2831     RenderBlock* caretPainter = nullptr;
2832 
2833     // First compute a rect local to the renderer at the selection start.
2834     RenderObject* renderer = nullptr;
2835     LayoutRect localRect = localCaretRectForCharacterOffset(renderer, characterOffset);
2836 
2837     localRect = localCaretRectInRendererForRect(localRect, characterOffset.node, renderer, caretPainter);
2838     return absoluteBoundsForLocalCaretRect(caretPainter, localRect);
2839 }
2840 
<span class="line-modified">2841 CharacterOffset AXObjectCache::characterOffsetForPoint(const IntPoint &amp;point, AXCoreObject* obj)</span>
2842 {
2843     if (!obj)
2844         return CharacterOffset();
2845 
2846     VisiblePosition vp = obj-&gt;visiblePositionForPoint(point);
2847     RefPtr&lt;Range&gt; range = makeRange(vp, vp);
2848     return startOrEndCharacterOffsetForRange(range, true);
2849 }
2850 
2851 CharacterOffset AXObjectCache::characterOffsetForPoint(const IntPoint &amp;point)
2852 {
2853     RefPtr&lt;Range&gt; caretRange = m_document.caretRangeFromPoint(LayoutPoint(point));
2854     return startOrEndCharacterOffsetForRange(caretRange, true);
2855 }
2856 
2857 CharacterOffset AXObjectCache::characterOffsetForBounds(const IntRect&amp; rect, bool first)
2858 {
2859     if (rect.isEmpty())
2860         return CharacterOffset();
2861 
</pre>
<hr />
<pre>
2887     if (characterOffset.isNull())
2888         return CharacterOffset();
2889 
2890     VisiblePosition vp = visiblePositionFromCharacterOffset(characterOffset);
2891     VisiblePosition endLine = endOfLine(vp);
2892 
2893     return characterOffsetFromVisiblePosition(endLine);
2894 }
2895 
2896 CharacterOffset AXObjectCache::startCharacterOffsetOfLine(const CharacterOffset&amp; characterOffset)
2897 {
2898     if (characterOffset.isNull())
2899         return CharacterOffset();
2900 
2901     VisiblePosition vp = visiblePositionFromCharacterOffset(characterOffset);
2902     VisiblePosition startLine = startOfLine(vp);
2903 
2904     return characterOffsetFromVisiblePosition(startLine);
2905 }
2906 
<span class="line-modified">2907 CharacterOffset AXObjectCache::characterOffsetForIndex(int index, const AXCoreObject* obj)</span>
2908 {
2909     if (!obj)
2910         return CharacterOffset();
2911 
2912     VisiblePosition vp = obj-&gt;visiblePositionForIndex(index);
2913     CharacterOffset validate = characterOffsetFromVisiblePosition(vp);
2914     // In text control, VisiblePosition always gives the before position of a
2915     // BR node, while CharacterOffset will do the opposite.
2916     if (obj-&gt;isTextControl() &amp;&amp; characterOffsetNodeIsBR(validate))
2917         validate.offset = 1;
2918 
2919     RefPtr&lt;Range&gt; range = obj-&gt;elementRange();
2920     CharacterOffset start = startOrEndCharacterOffsetForRange(range, true, true);
2921     CharacterOffset end = startOrEndCharacterOffsetForRange(range, false, true);
2922     CharacterOffset result = start;
2923     for (int i = 0; i &lt; index; i++) {
2924         if (result.isEqual(validate)) {
2925             // Do not include the new line character, always move the offset to the start of next node.
2926             if ((validate.node-&gt;isTextNode() || characterOffsetNodeIsBR(validate))) {
2927                 CharacterOffset next = nextCharacterOffset(validate, false);
</pre>
<hr />
<pre>
3021     // If there&#39;s a pending layout, let the layout trigger the AX update.
3022     if (!document().view() || document().view()-&gt;needsLayout())
3023         return;
3024 
3025     performDeferredCacheUpdate();
3026 }
3027 
3028 void AXObjectCache::performDeferredCacheUpdate()
3029 {
3030     if (m_performingDeferredCacheUpdate)
3031         return;
3032 
3033     SetForScope&lt;bool&gt; performingDeferredCacheUpdate(m_performingDeferredCacheUpdate, true);
3034 
3035     for (auto* nodeChild : m_deferredChildrenChangedNodeList) {
3036         handleMenuOpened(nodeChild);
3037         handleLiveRegionCreated(nodeChild);
3038     }
3039     m_deferredChildrenChangedNodeList.clear();
3040 
<span class="line-modified">3041     for (auto&amp; child : m_deferredChildrenChangedList)</span>
3042         child-&gt;childrenChanged();
<span class="line-modified">3043     m_deferredChildrenChangedList.clear();</span>
3044 
3045     for (auto* node : m_deferredTextChangedList)
3046         textChanged(node);
3047     m_deferredTextChangedList.clear();
3048 
3049     for (auto* element : m_deferredRecomputeIsIgnoredList) {
3050         if (auto* renderer = element-&gt;renderer())
3051             recomputeIsIgnored(renderer);
3052     }
3053     m_deferredRecomputeIsIgnoredList.clear();
3054 
3055     for (auto* selectElement : m_deferredSelectedChildredChangedList)
3056         selectedChildrenChanged(selectElement);
3057     m_deferredSelectedChildredChangedList.clear();
3058 
3059     for (auto&amp; deferredFormControlContext : m_deferredTextFormControlValue) {
3060         auto&amp; textFormControlElement = downcast&lt;HTMLTextFormControlElement&gt;(*deferredFormControlContext.key);
3061         postTextReplacementNotificationForTextControl(textFormControlElement, deferredFormControlContext.value, textFormControlElement.innerTextValue());
3062     }
3063     m_deferredTextFormControlValue.clear();
3064 
3065     for (auto&amp; deferredAttributeChangeContext : m_deferredAttributeChange)
3066         handleAttributeChange(deferredAttributeChangeContext.value, deferredAttributeChangeContext.key);
3067     m_deferredAttributeChange.clear();
3068 
3069     for (auto&amp; deferredFocusedChangeContext : m_deferredFocusedNodeChange)
3070         handleFocusedUIElementChanged(deferredFocusedChangeContext.first, deferredFocusedChangeContext.second);
3071     m_deferredFocusedNodeChange.clear();
3072 
3073     platformPerformDeferredCacheUpdate();
3074 }
3075 
3076 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)
<span class="line-modified">3077 Ref&lt;AXIsolatedObject&gt; AXObjectCache::createIsolatedTreeHierarchy(AXCoreObject&amp; object, AXID parentID, AXObjectCache* axObjectCache, AXIsolatedTree&amp; tree, Vector&lt;Ref&lt;AXIsolatedObject&gt;&gt;&amp; nodeChanges, bool isRoot)</span>
3078 {
<span class="line-modified">3079     auto isolatedTreeNode = AXIsolatedObject::create(object, isRoot);</span>
3080     nodeChanges.append(isolatedTreeNode.copyRef());
3081 
<span class="line-added">3082     isolatedTreeNode-&gt;setTreeIdentifier(tree.treeIdentifier());</span>
3083     isolatedTreeNode-&gt;setParent(parentID);
<span class="line-modified">3084     axObjectCache-&gt;attachWrapper(&amp;isolatedTreeNode.get(), object.wrapper());</span>
3085 
<span class="line-modified">3086     for (const auto&amp; child : object.children()) {</span>
<span class="line-modified">3087         auto staticChild = createIsolatedTreeHierarchy(*child, isolatedTreeNode-&gt;objectID(), axObjectCache, tree, nodeChanges, false);</span>
<span class="line-modified">3088         isolatedTreeNode-&gt;appendChild(staticChild-&gt;objectID());</span>
3089     }
3090 
3091     return isolatedTreeNode;
3092 }
3093 
<span class="line-modified">3094 Ref&lt;AXIsolatedTree&gt; AXObjectCache::generateIsolatedTree(PageIdentifier pageID, Document&amp; document)</span>
3095 {
3096     RELEASE_ASSERT(isMainThread());
3097 
<span class="line-modified">3098     RefPtr&lt;AXIsolatedTree&gt; tree(AXIsolatedTree::createTreeForPageID(pageID));</span>
<span class="line-modified">3099 </span>
<span class="line-modified">3100     // Set the root and focused objects in the isolated tree. For that, we need</span>
<span class="line-added">3101     // the root and the focused object in the AXObject tree.</span>
<span class="line-added">3102     auto* axObjectCache = document.axObjectCache();</span>
<span class="line-added">3103     if (!axObjectCache)</span>
<span class="line-added">3104         return makeRef(*tree);</span>
<span class="line-added">3105     tree-&gt;setAXObjectCache(axObjectCache);</span>
<span class="line-added">3106 </span>
<span class="line-added">3107     auto* axRoot = axObjectCache-&gt;getOrCreate(document.view());</span>
<span class="line-added">3108     if (axRoot) {</span>
<span class="line-added">3109         Vector&lt;Ref&lt;AXIsolatedObject&gt;&gt; nodeChanges;</span>
<span class="line-added">3110         auto isolatedRoot = createIsolatedTreeHierarchy(*axRoot, InvalidAXID, axObjectCache, *tree, nodeChanges, true);</span>
<span class="line-added">3111         tree-&gt;setRootNode(isolatedRoot);</span>
<span class="line-added">3112         tree-&gt;appendNodeChanges(nodeChanges);</span>
<span class="line-added">3113     }</span>
3114 
<span class="line-modified">3115     auto* axFocus = axObjectCache-&gt;focusedObject(document);</span>
<span class="line-modified">3116     if (axFocus)</span>
<span class="line-modified">3117         tree-&gt;setFocusedNodeID(axFocus-&gt;objectID());</span>

3118 
3119     return makeRef(*tree);
3120 }
3121 #endif
3122 
3123 void AXObjectCache::deferRecomputeIsIgnoredIfNeeded(Element* element)
3124 {
3125     if (!nodeAndRendererAreValid(element))
3126         return;
3127 
3128     if (rendererNeedsDeferredUpdate(*element-&gt;renderer())) {
3129         m_deferredRecomputeIsIgnoredList.add(element);
3130         return;
3131     }
3132     recomputeIsIgnored(element-&gt;renderer());
3133 }
3134 
3135 void AXObjectCache::deferRecomputeIsIgnored(Element* element)
3136 {
3137     if (!nodeAndRendererAreValid(element))
</pre>
<hr />
<pre>
3190             const AtomString&amp; ariaHiddenValue = downcast&lt;Element&gt;(*testNode).attributeWithoutSynchronization(aria_hiddenAttr);
3191             if (equalLettersIgnoringASCIICase(ariaHiddenValue, &quot;true&quot;))
3192                 return false;
3193 
3194             bool ariaHiddenFalse = equalLettersIgnoringASCIICase(ariaHiddenValue, &quot;false&quot;);
3195             if (!testNode-&gt;renderer() &amp;&amp; !ariaHiddenFalse)
3196                 return false;
3197             if (!ariaHiddenFalsePresent &amp;&amp; ariaHiddenFalse)
3198                 ariaHiddenFalsePresent = true;
3199             // We should break early when it gets to a rendered object.
3200             if (testNode-&gt;renderer())
3201                 break;
3202         }
3203     }
3204 
3205     return !requiresAriaHiddenFalse || ariaHiddenFalsePresent;
3206 }
3207 
3208 AccessibilityObject* AXObjectCache::rootWebArea()
3209 {
<span class="line-modified">3210     AXCoreObject* rootObject = this-&gt;rootObject();</span>
3211     if (!rootObject || !rootObject-&gt;isAccessibilityScrollView())
3212         return nullptr;
3213     return downcast&lt;AccessibilityScrollView&gt;(*rootObject).webAreaObject();
3214 }
3215 
3216 AXAttributeCacheEnabler::AXAttributeCacheEnabler(AXObjectCache* cache)
3217     : m_cache(cache)
3218 {
3219     if (m_cache)
3220         m_cache-&gt;startCachingComputedObjectAttributesUntilTreeMutates();
3221 }
3222 
3223 AXAttributeCacheEnabler::~AXAttributeCacheEnabler()
3224 {
3225     if (m_cache)
3226         m_cache-&gt;stopCachingComputedObjectAttributes();
3227 }
3228 
3229 #if !PLATFORM(COCOA)
3230 AXTextChange AXObjectCache::textChangeForEditType(AXTextEditType type)
</pre>
</td>
</tr>
</table>
<center><a href="../WebCorePrefix.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AXObjectCache.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
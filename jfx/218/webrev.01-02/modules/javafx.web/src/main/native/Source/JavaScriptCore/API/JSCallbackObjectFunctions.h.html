<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSCallbackObjectFunctions.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2006-2020 Apple Inc. All rights reserved.
  3  * Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;APICast.h&quot;
 30 #include &quot;Error.h&quot;
 31 #include &quot;ExceptionHelpers.h&quot;
 32 #include &quot;JSCallbackFunction.h&quot;
 33 #include &quot;JSClassRef.h&quot;
 34 #include &quot;JSFunction.h&quot;
 35 #include &quot;JSGlobalObject.h&quot;
 36 #include &quot;JSLock.h&quot;
 37 #include &quot;JSObjectRef.h&quot;
 38 #include &quot;JSString.h&quot;
 39 #include &quot;OpaqueJSString.h&quot;
 40 #include &quot;PropertyNameArray.h&quot;
 41 #include &lt;wtf/Vector.h&gt;
 42 
 43 namespace JSC {
 44 
 45 template &lt;class Parent&gt;
 46 inline JSCallbackObject&lt;Parent&gt;* JSCallbackObject&lt;Parent&gt;::asCallbackObject(JSValue value)
 47 {
 48     ASSERT(asObject(value)-&gt;inherits(value.getObject()-&gt;vm(), info()));
 49     return jsCast&lt;JSCallbackObject*&gt;(asObject(value));
 50 }
 51 
 52 template &lt;class Parent&gt;
 53 inline JSCallbackObject&lt;Parent&gt;* JSCallbackObject&lt;Parent&gt;::asCallbackObject(EncodedJSValue encodedValue)
 54 {
 55     JSValue value = JSValue::decode(encodedValue);
 56     ASSERT(asObject(value)-&gt;inherits(value.getObject()-&gt;vm(), info()));
 57     return jsCast&lt;JSCallbackObject*&gt;(asObject(value));
 58 }
 59 
 60 template &lt;class Parent&gt;
 61 JSCallbackObject&lt;Parent&gt;::JSCallbackObject(JSGlobalObject* globalObject, Structure* structure, JSClassRef jsClass, void* data)
 62     : Parent(getVM(globalObject), structure)
 63     , m_callbackObjectData(makeUnique&lt;JSCallbackObjectData&gt;(data, jsClass))
 64 {
 65 }
 66 
 67 // Global object constructor.
 68 // FIXME: Move this into a separate JSGlobalCallbackObject class derived from this one.
 69 template &lt;class Parent&gt;
 70 JSCallbackObject&lt;Parent&gt;::JSCallbackObject(VM&amp; vm, JSClassRef jsClass, Structure* structure)
 71     : Parent(vm, structure)
 72     , m_callbackObjectData(makeUnique&lt;JSCallbackObjectData&gt;(nullptr, jsClass))
 73 {
 74 }
 75 
 76 template &lt;class Parent&gt;
 77 JSCallbackObject&lt;Parent&gt;::~JSCallbackObject()
 78 {
 79     VM&amp; vm = this-&gt;HeapCell::vm();
 80     vm.currentlyDestructingCallbackObject = this;
 81     ASSERT(m_classInfo);
 82     vm.currentlyDestructingCallbackObjectClassInfo = m_classInfo;
 83     JSObjectRef thisRef = toRef(static_cast&lt;JSObject*&gt;(this));
 84     for (JSClassRef jsClass = classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
 85         if (JSObjectFinalizeCallback finalize = jsClass-&gt;finalize)
 86             finalize(thisRef);
 87     }
 88     vm.currentlyDestructingCallbackObject = nullptr;
 89     vm.currentlyDestructingCallbackObjectClassInfo = nullptr;
 90 }
 91 
 92 template &lt;class Parent&gt;
 93 void JSCallbackObject&lt;Parent&gt;::finishCreation(JSGlobalObject* globalObject)
 94 {
 95     VM&amp; vm = getVM(globalObject);
 96     Base::finishCreation(vm);
 97     ASSERT(Parent::inherits(vm, info()));
 98     init(globalObject);
 99 }
100 
101 // This is just for Global object, so we can assume that Base::finishCreation is JSGlobalObject::finishCreation.
102 template &lt;class Parent&gt;
103 void JSCallbackObject&lt;Parent&gt;::finishCreation(VM&amp; vm)
104 {
105     ASSERT(Parent::inherits(vm, info()));
106     ASSERT(Parent::isGlobalObject());
107     Base::finishCreation(vm);
108     init(jsCast&lt;JSGlobalObject*&gt;(this));
109 }
110 
111 template &lt;class Parent&gt;
112 void JSCallbackObject&lt;Parent&gt;::init(JSGlobalObject* globalObject)
113 {
114     ASSERT(globalObject);
115 
116     Vector&lt;JSObjectInitializeCallback, 16&gt; initRoutines;
117     JSClassRef jsClass = classRef();
118     do {
119         if (JSObjectInitializeCallback initialize = jsClass-&gt;initialize)
120             initRoutines.append(initialize);
121     } while ((jsClass = jsClass-&gt;parentClass));
122 
123     // initialize from base to derived
124     for (int i = static_cast&lt;int&gt;(initRoutines.size()) - 1; i &gt;= 0; i--) {
125         JSLock::DropAllLocks dropAllLocks(globalObject);
126         JSObjectInitializeCallback initialize = initRoutines[i];
127         initialize(toRef(globalObject), toRef(jsCast&lt;JSObject*&gt;(this)));
128     }
129 
130     m_classInfo = this-&gt;classInfo(getVM(globalObject));
131 }
132 
133 template &lt;class Parent&gt;
134 String JSCallbackObject&lt;Parent&gt;::className(const JSObject* object, VM&amp; vm)
135 {
136     const JSCallbackObject* thisObject = jsCast&lt;const JSCallbackObject*&gt;(object);
137     String thisClassName = thisObject-&gt;classRef()-&gt;className();
138     if (!thisClassName.isEmpty())
139         return thisClassName;
140 
141     return Parent::className(object, vm);
142 }
143 
144 template &lt;class Parent&gt;
145 String JSCallbackObject&lt;Parent&gt;::toStringName(const JSObject* object, JSGlobalObject* globalObject)
146 {
147     VM&amp; vm = getVM(globalObject);
148     const ClassInfo* info = object-&gt;classInfo(vm);
149     ASSERT(info);
150     return info-&gt;methodTable.className(object, vm);
151 }
152 
153 template &lt;class Parent&gt;
154 bool JSCallbackObject&lt;Parent&gt;::getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)
155 {
156     VM&amp; vm = getVM(globalObject);
157     auto scope = DECLARE_THROW_SCOPE(vm);
158 
159     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(object);
160     JSContextRef ctx = toRef(globalObject);
161     JSObjectRef thisRef = toRef(jsCast&lt;JSObject*&gt;(thisObject));
162     RefPtr&lt;OpaqueJSString&gt; propertyNameRef;
163 
164     if (StringImpl* name = propertyName.uid()) {
165         for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
166             // optional optimization to bypass getProperty in cases when we only need to know if the property exists
167             if (JSObjectHasPropertyCallback hasProperty = jsClass-&gt;hasProperty) {
168                 if (!propertyNameRef)
169                     propertyNameRef = OpaqueJSString::tryCreate(name);
170                 JSLock::DropAllLocks dropAllLocks(globalObject);
171                 if (hasProperty(ctx, thisRef, propertyNameRef.get())) {
172                     slot.setCustom(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, callbackGetter);
173                     return true;
174                 }
175             } else if (JSObjectGetPropertyCallback getProperty = jsClass-&gt;getProperty) {
176                 if (!propertyNameRef)
177                     propertyNameRef = OpaqueJSString::tryCreate(name);
178                 JSValueRef exception = 0;
179                 JSValueRef value;
180                 {
181                     JSLock::DropAllLocks dropAllLocks(globalObject);
182                     value = getProperty(ctx, thisRef, propertyNameRef.get(), &amp;exception);
183                 }
184                 if (exception) {
185                     throwException(globalObject, scope, toJS(globalObject, exception));
186                     slot.setValue(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, jsUndefined());
187                     return true;
188                 }
189                 if (value) {
190                     slot.setValue(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, toJS(globalObject, value));
191                     return true;
192                 }
193             }
194 
195             if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(globalObject)) {
196                 if (staticValues-&gt;contains(name)) {
197                     JSValue value = thisObject-&gt;getStaticValue(globalObject, propertyName);
198                     if (value) {
199                         slot.setValue(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, value);
200                         return true;
201                     }
202                 }
203             }
204 
205             if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(globalObject)) {
206                 if (staticFunctions-&gt;contains(name)) {
207                     slot.setCustom(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, staticFunctionGetter);
208                     return true;
209                 }
210             }
211         }
212     }
213 
214     return Parent::getOwnPropertySlot(thisObject, globalObject, propertyName, slot);
215 }
216 
217 template &lt;class Parent&gt;
218 bool JSCallbackObject&lt;Parent&gt;::getOwnPropertySlotByIndex(JSObject* object, JSGlobalObject* globalObject, unsigned propertyName, PropertySlot&amp; slot)
219 {
220     VM&amp; vm = getVM(globalObject);
221     return object-&gt;methodTable(vm)-&gt;getOwnPropertySlot(object, globalObject, Identifier::from(vm, propertyName), slot);
222 }
223 
224 template &lt;class Parent&gt;
225 JSValue JSCallbackObject&lt;Parent&gt;::defaultValue(const JSObject* object, JSGlobalObject* globalObject, PreferredPrimitiveType hint)
226 {
227     VM&amp; vm = getVM(globalObject);
228     auto scope = DECLARE_THROW_SCOPE(vm);
229 
230     const JSCallbackObject* thisObject = jsCast&lt;const JSCallbackObject*&gt;(object);
231     JSContextRef ctx = toRef(globalObject);
232     JSObjectRef thisRef = toRef(jsCast&lt;const JSObject*&gt;(thisObject));
233     ::JSType jsHint = hint == PreferString ? kJSTypeString : kJSTypeNumber;
234 
235     for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
236         if (JSObjectConvertToTypeCallback convertToType = jsClass-&gt;convertToType) {
237             JSValueRef exception = 0;
238             JSValueRef result = convertToType(ctx, thisRef, jsHint, &amp;exception);
239             if (exception) {
240                 throwException(globalObject, scope, toJS(globalObject, exception));
241                 return jsUndefined();
242             }
243             if (result)
244                 return toJS(globalObject, result);
245         }
246     }
247 
248     return Parent::defaultValue(object, globalObject, hint);
249 }
250 
251 template &lt;class Parent&gt;
252 bool JSCallbackObject&lt;Parent&gt;::put(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
253 {
254     VM&amp; vm = getVM(globalObject);
255     auto scope = DECLARE_THROW_SCOPE(vm);
256 
257     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
258     JSContextRef ctx = toRef(globalObject);
259     JSObjectRef thisRef = toRef(jsCast&lt;JSObject*&gt;(thisObject));
260     RefPtr&lt;OpaqueJSString&gt; propertyNameRef;
261     JSValueRef valueRef = toRef(globalObject, value);
262 
263     if (StringImpl* name = propertyName.uid()) {
264         for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
265             if (JSObjectSetPropertyCallback setProperty = jsClass-&gt;setProperty) {
266                 if (!propertyNameRef)
267                     propertyNameRef = OpaqueJSString::tryCreate(name);
268                 JSValueRef exception = 0;
269                 bool result;
270                 {
271                     JSLock::DropAllLocks dropAllLocks(globalObject);
272                     result = setProperty(ctx, thisRef, propertyNameRef.get(), valueRef, &amp;exception);
273                 }
274                 if (exception)
275                     throwException(globalObject, scope, toJS(globalObject, exception));
276                 if (result || exception)
277                     return result;
278             }
279 
280             if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(globalObject)) {
281                 if (StaticValueEntry* entry = staticValues-&gt;get(name)) {
282                     if (entry-&gt;attributes &amp; kJSPropertyAttributeReadOnly)
283                         return false;
284                     if (JSObjectSetPropertyCallback setProperty = entry-&gt;setProperty) {
285                         JSValueRef exception = 0;
286                         bool result;
287                         {
288                             JSLock::DropAllLocks dropAllLocks(globalObject);
289                             result = setProperty(ctx, thisRef, entry-&gt;propertyNameRef.get(), valueRef, &amp;exception);
290                         }
291                         if (exception)
292                             throwException(globalObject, scope, toJS(globalObject, exception));
293                         if (result || exception)
294                             return result;
295                     }
296                 }
297             }
298 
299             if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(globalObject)) {
300                 if (StaticFunctionEntry* entry = staticFunctions-&gt;get(name)) {
301                     PropertySlot getSlot(thisObject, PropertySlot::InternalMethodType::VMInquiry);
302                     if (Parent::getOwnPropertySlot(thisObject, globalObject, propertyName, getSlot))
303                         return Parent::put(thisObject, globalObject, propertyName, value, slot);
304                     if (entry-&gt;attributes &amp; kJSPropertyAttributeReadOnly)
305                         return false;
306                     return thisObject-&gt;JSCallbackObject&lt;Parent&gt;::putDirect(vm, propertyName, value); // put as override property
307                 }
308             }
309         }
310     }
311 
312     return Parent::put(thisObject, globalObject, propertyName, value, slot);
313 }
314 
315 template &lt;class Parent&gt;
316 bool JSCallbackObject&lt;Parent&gt;::putByIndex(JSCell* cell, JSGlobalObject* globalObject, unsigned propertyIndex, JSValue value, bool shouldThrow)
317 {
318     VM&amp; vm = getVM(globalObject);
319     auto scope = DECLARE_THROW_SCOPE(vm);
320 
321     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
322     JSContextRef ctx = toRef(globalObject);
323     JSObjectRef thisRef = toRef(jsCast&lt;JSObject*&gt;(thisObject));
324     RefPtr&lt;OpaqueJSString&gt; propertyNameRef;
325     JSValueRef valueRef = toRef(globalObject, value);
326     Identifier propertyName = Identifier::from(vm, propertyIndex);
327 
328     for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
329         if (JSObjectSetPropertyCallback setProperty = jsClass-&gt;setProperty) {
330             if (!propertyNameRef)
331                 propertyNameRef = OpaqueJSString::tryCreate(propertyName.impl());
332             JSValueRef exception = 0;
333             bool result;
334             {
335                 JSLock::DropAllLocks dropAllLocks(globalObject);
336                 result = setProperty(ctx, thisRef, propertyNameRef.get(), valueRef, &amp;exception);
337             }
338             if (exception)
339                 throwException(globalObject, scope, toJS(globalObject, exception));
340             if (result || exception)
341                 return result;
342         }
343 
344         if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(globalObject)) {
345             if (StaticValueEntry* entry = staticValues-&gt;get(propertyName.impl())) {
346                 if (entry-&gt;attributes &amp; kJSPropertyAttributeReadOnly)
347                     return false;
348                 if (JSObjectSetPropertyCallback setProperty = entry-&gt;setProperty) {
349                     JSValueRef exception = 0;
350                     bool result;
351                     {
352                         JSLock::DropAllLocks dropAllLocks(globalObject);
353                         result = setProperty(ctx, thisRef, entry-&gt;propertyNameRef.get(), valueRef, &amp;exception);
354                     }
355                     if (exception)
356                         throwException(globalObject, scope, toJS(globalObject, exception));
357                     if (result || exception)
358                         return result;
359                 }
360             }
361         }
362 
363         if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(globalObject)) {
364             if (StaticFunctionEntry* entry = staticFunctions-&gt;get(propertyName.impl())) {
365                 if (entry-&gt;attributes &amp; kJSPropertyAttributeReadOnly)
366                     return false;
367                 break;
368             }
369         }
370     }
371 
372     return Parent::putByIndex(thisObject, globalObject, propertyIndex, value, shouldThrow);
373 }
374 
375 template &lt;class Parent&gt;
376 bool JSCallbackObject&lt;Parent&gt;::deleteProperty(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)
377 {
378     VM&amp; vm = getVM(globalObject);
379     auto scope = DECLARE_THROW_SCOPE(vm);
380 
381     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
382     JSContextRef ctx = toRef(globalObject);
383     JSObjectRef thisRef = toRef(jsCast&lt;JSObject*&gt;(thisObject));
384     RefPtr&lt;OpaqueJSString&gt; propertyNameRef;
385 
386     if (StringImpl* name = propertyName.uid()) {
387         for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
388             if (JSObjectDeletePropertyCallback deleteProperty = jsClass-&gt;deleteProperty) {
389                 if (!propertyNameRef)
390                     propertyNameRef = OpaqueJSString::tryCreate(name);
391                 JSValueRef exception = 0;
392                 bool result;
393                 {
394                     JSLock::DropAllLocks dropAllLocks(globalObject);
395                     result = deleteProperty(ctx, thisRef, propertyNameRef.get(), &amp;exception);
396                 }
397                 if (exception)
398                     throwException(globalObject, scope, toJS(globalObject, exception));
399                 if (result || exception)
400                     return true;
401             }
402 
403             if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(globalObject)) {
404                 if (StaticValueEntry* entry = staticValues-&gt;get(name)) {
405                     if (entry-&gt;attributes &amp; kJSPropertyAttributeDontDelete)
406                         return false;
407                     return true;
408                 }
409             }
410 
411             if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(globalObject)) {
412                 if (StaticFunctionEntry* entry = staticFunctions-&gt;get(name)) {
413                     if (entry-&gt;attributes &amp; kJSPropertyAttributeDontDelete)
414                         return false;
415                     return true;
416                 }
417             }
418         }
419     }
420 
421     return Parent::deleteProperty(thisObject, globalObject, propertyName);
422 }
423 
424 template &lt;class Parent&gt;
425 bool JSCallbackObject&lt;Parent&gt;::deletePropertyByIndex(JSCell* cell, JSGlobalObject* globalObject, unsigned propertyName)
426 {
427     VM&amp; vm = getVM(globalObject);
428     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
429     return thisObject-&gt;methodTable(vm)-&gt;deleteProperty(thisObject, globalObject, Identifier::from(vm, propertyName));
430 }
431 
432 template &lt;class Parent&gt;
433 ConstructType JSCallbackObject&lt;Parent&gt;::getConstructData(JSCell* cell, ConstructData&amp; constructData)
434 {
435     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
436     for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
437         if (jsClass-&gt;callAsConstructor) {
438             constructData.native.function = construct;
439             return ConstructType::Host;
440         }
441     }
442     return ConstructType::None;
443 }
444 
445 template &lt;class Parent&gt;
446 EncodedJSValue JSCallbackObject&lt;Parent&gt;::construct(JSGlobalObject* globalObject, CallFrame* callFrame)
447 {
448     VM&amp; vm = getVM(globalObject);
449     auto scope = DECLARE_THROW_SCOPE(vm);
450 
451     JSObject* constructor = callFrame-&gt;jsCallee();
452     JSContextRef execRef = toRef(globalObject);
453     JSObjectRef constructorRef = toRef(constructor);
454 
455     for (JSClassRef jsClass = jsCast&lt;JSCallbackObject&lt;Parent&gt;*&gt;(constructor)-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
456         if (JSObjectCallAsConstructorCallback callAsConstructor = jsClass-&gt;callAsConstructor) {
457             size_t argumentCount = callFrame-&gt;argumentCount();
458             Vector&lt;JSValueRef, 16&gt; arguments;
459             arguments.reserveInitialCapacity(argumentCount);
460             for (size_t i = 0; i &lt; argumentCount; ++i)
461                 arguments.uncheckedAppend(toRef(globalObject, callFrame-&gt;uncheckedArgument(i)));
462             JSValueRef exception = 0;
463             JSObject* result;
464             {
465                 JSLock::DropAllLocks dropAllLocks(globalObject);
466                 result = toJS(callAsConstructor(execRef, constructorRef, argumentCount, arguments.data(), &amp;exception));
467             }
468             if (exception)
469                 throwException(globalObject, scope, toJS(globalObject, exception));
470             return JSValue::encode(result);
471         }
472     }
473 
474     RELEASE_ASSERT_NOT_REACHED(); // getConstructData should prevent us from reaching here
475     return JSValue::encode(JSValue());
476 }
477 
478 template &lt;class Parent&gt;
479 bool JSCallbackObject&lt;Parent&gt;::customHasInstance(JSObject* object, JSGlobalObject* globalObject, JSValue value)
480 {
481     VM&amp; vm = getVM(globalObject);
482     auto scope = DECLARE_THROW_SCOPE(vm);
483 
484     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(object);
485     JSContextRef execRef = toRef(globalObject);
486     JSObjectRef thisRef = toRef(jsCast&lt;JSObject*&gt;(thisObject));
487 
488     for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
489         if (JSObjectHasInstanceCallback hasInstance = jsClass-&gt;hasInstance) {
490             JSValueRef valueRef = toRef(globalObject, value);
491             JSValueRef exception = 0;
492             bool result;
493             {
494                 JSLock::DropAllLocks dropAllLocks(globalObject);
495                 result = hasInstance(execRef, thisRef, valueRef, &amp;exception);
496             }
497             if (exception)
498                 throwException(globalObject, scope, toJS(globalObject, exception));
499             return result;
500         }
501     }
502     return false;
503 }
504 
505 template &lt;class Parent&gt;
506 CallType JSCallbackObject&lt;Parent&gt;::getCallData(JSCell* cell, CallData&amp; callData)
507 {
508     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
509     for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
510         if (jsClass-&gt;callAsFunction) {
511             callData.native.function = call;
512             return CallType::Host;
513         }
514     }
515     return CallType::None;
516 }
517 
518 template &lt;class Parent&gt;
519 EncodedJSValue JSCallbackObject&lt;Parent&gt;::call(JSGlobalObject* globalObject, CallFrame* callFrame)
520 {
521     VM&amp; vm = getVM(globalObject);
522     auto scope = DECLARE_THROW_SCOPE(vm);
523 
524     JSContextRef execRef = toRef(globalObject);
525     JSObjectRef functionRef = toRef(callFrame-&gt;jsCallee());
526     JSObjectRef thisObjRef = toRef(jsCast&lt;JSObject*&gt;(callFrame-&gt;thisValue().toThis(globalObject, NotStrictMode)));
527 
528     for (JSClassRef jsClass = jsCast&lt;JSCallbackObject&lt;Parent&gt;*&gt;(toJS(functionRef))-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
529         if (JSObjectCallAsFunctionCallback callAsFunction = jsClass-&gt;callAsFunction) {
530             size_t argumentCount = callFrame-&gt;argumentCount();
531             Vector&lt;JSValueRef, 16&gt; arguments;
532             arguments.reserveInitialCapacity(argumentCount);
533             for (size_t i = 0; i &lt; argumentCount; ++i)
534                 arguments.uncheckedAppend(toRef(globalObject, callFrame-&gt;uncheckedArgument(i)));
535             JSValueRef exception = 0;
536             JSValue result;
537             {
538                 JSLock::DropAllLocks dropAllLocks(globalObject);
539                 result = toJS(globalObject, callAsFunction(execRef, functionRef, thisObjRef, argumentCount, arguments.data(), &amp;exception));
540             }
541             if (exception)
542                 throwException(globalObject, scope, toJS(globalObject, exception));
543             return JSValue::encode(result);
544         }
545     }
546 
547     RELEASE_ASSERT_NOT_REACHED(); // getCallData should prevent us from reaching here
548     return JSValue::encode(JSValue());
549 }
550 
551 template &lt;class Parent&gt;
552 void JSCallbackObject&lt;Parent&gt;::getOwnNonIndexPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)
553 {
554     VM&amp; vm = getVM(globalObject);
555     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(object);
556     JSContextRef execRef = toRef(globalObject);
557     JSObjectRef thisRef = toRef(jsCast&lt;JSObject*&gt;(thisObject));
558 
559     for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
560         if (JSObjectGetPropertyNamesCallback getPropertyNames = jsClass-&gt;getPropertyNames) {
561             JSLock::DropAllLocks dropAllLocks(globalObject);
562             getPropertyNames(execRef, thisRef, toRef(&amp;propertyNames));
563         }
564 
565         if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(globalObject)) {
566             typedef OpaqueJSClassStaticValuesTable::const_iterator iterator;
567             iterator end = staticValues-&gt;end();
568             for (iterator it = staticValues-&gt;begin(); it != end; ++it) {
569                 StringImpl* name = it-&gt;key.get();
570                 StaticValueEntry* entry = it-&gt;value.get();
571                 if (entry-&gt;getProperty &amp;&amp; (!(entry-&gt;attributes &amp; kJSPropertyAttributeDontEnum) || mode.includeDontEnumProperties())) {
572                     ASSERT(!name-&gt;isSymbol());
573                     propertyNames.add(Identifier::fromString(vm, String(name)));
574                 }
575             }
576         }
577 
578         if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(globalObject)) {
579             typedef OpaqueJSClassStaticFunctionsTable::const_iterator iterator;
580             iterator end = staticFunctions-&gt;end();
581             for (iterator it = staticFunctions-&gt;begin(); it != end; ++it) {
582                 StringImpl* name = it-&gt;key.get();
583                 StaticFunctionEntry* entry = it-&gt;value.get();
584                 if (!(entry-&gt;attributes &amp; kJSPropertyAttributeDontEnum) || mode.includeDontEnumProperties()) {
585                     ASSERT(!name-&gt;isSymbol());
586                     propertyNames.add(Identifier::fromString(vm, String(name)));
587                 }
588             }
589         }
590     }
591 
592     Parent::getOwnNonIndexPropertyNames(thisObject, globalObject, propertyNames, mode);
593 }
594 
595 template &lt;class Parent&gt;
596 void JSCallbackObject&lt;Parent&gt;::setPrivate(void* data)
597 {
598     m_callbackObjectData-&gt;privateData = data;
599 }
600 
601 template &lt;class Parent&gt;
602 void* JSCallbackObject&lt;Parent&gt;::getPrivate()
603 {
604     return m_callbackObjectData-&gt;privateData;
605 }
606 
607 template &lt;class Parent&gt;
608 bool JSCallbackObject&lt;Parent&gt;::inherits(JSClassRef c) const
609 {
610     for (JSClassRef jsClass = classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
611         if (jsClass == c)
612             return true;
613     }
614     return false;
615 }
616 
617 template &lt;class Parent&gt;
618 JSValue JSCallbackObject&lt;Parent&gt;::getStaticValue(JSGlobalObject* globalObject, PropertyName propertyName)
619 {
620     VM&amp; vm = getVM(globalObject);
621     auto scope = DECLARE_THROW_SCOPE(vm);
622 
623     JSObjectRef thisRef = toRef(jsCast&lt;JSObject*&gt;(this));
624 
625     if (StringImpl* name = propertyName.uid()) {
626         for (JSClassRef jsClass = classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
627             if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(globalObject)) {
628                 if (StaticValueEntry* entry = staticValues-&gt;get(name)) {
629                     if (JSObjectGetPropertyCallback getProperty = entry-&gt;getProperty) {
630                         JSValueRef exception = 0;
631                         JSValueRef value;
632                         {
633                             JSLock::DropAllLocks dropAllLocks(globalObject);
634                             value = getProperty(toRef(globalObject), thisRef, entry-&gt;propertyNameRef.get(), &amp;exception);
635                         }
636                         if (exception) {
637                             throwException(globalObject, scope, toJS(globalObject, exception));
638                             return jsUndefined();
639                         }
640                         if (value)
641                             return toJS(globalObject, value);
642                     }
643                 }
644             }
645         }
646     }
647 
648     return JSValue();
649 }
650 
651 template &lt;class Parent&gt;
652 EncodedJSValue JSCallbackObject&lt;Parent&gt;::staticFunctionGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName propertyName)
653 {
654     VM&amp; vm = getVM(globalObject);
655     auto scope = DECLARE_THROW_SCOPE(vm);
656 
657     JSCallbackObject* thisObj = asCallbackObject(thisValue);
658 
659     // Check for cached or override property.
660     PropertySlot slot2(thisObj, PropertySlot::InternalMethodType::VMInquiry);
661     if (Parent::getOwnPropertySlot(thisObj, globalObject, propertyName, slot2))
662         return JSValue::encode(slot2.getValue(globalObject, propertyName));
663 
664     if (StringImpl* name = propertyName.uid()) {
665         for (JSClassRef jsClass = thisObj-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
666             if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(globalObject)) {
667                 if (StaticFunctionEntry* entry = staticFunctions-&gt;get(name)) {
668                     if (JSObjectCallAsFunctionCallback callAsFunction = entry-&gt;callAsFunction) {
669                         JSObject* o = JSCallbackFunction::create(vm, thisObj-&gt;globalObject(vm), callAsFunction, name);
670                         thisObj-&gt;putDirect(vm, propertyName, o, entry-&gt;attributes);
671                         return JSValue::encode(o);
672                     }
673                 }
674             }
675         }
676     }
677 
678     return JSValue::encode(throwException(globalObject, scope, createReferenceError(globalObject, &quot;Static function property defined with NULL callAsFunction callback.&quot;_s)));
679 }
680 
681 template &lt;class Parent&gt;
682 EncodedJSValue JSCallbackObject&lt;Parent&gt;::callbackGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName propertyName)
683 {
684     VM&amp; vm = getVM(globalObject);
685     auto scope = DECLARE_THROW_SCOPE(vm);
686 
687     JSCallbackObject* thisObj = asCallbackObject(thisValue);
688 
689     JSObjectRef thisRef = toRef(jsCast&lt;JSObject*&gt;(thisObj));
690     RefPtr&lt;OpaqueJSString&gt; propertyNameRef;
691 
692     if (StringImpl* name = propertyName.uid()) {
693         for (JSClassRef jsClass = thisObj-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
694             if (JSObjectGetPropertyCallback getProperty = jsClass-&gt;getProperty) {
695                 if (!propertyNameRef)
696                     propertyNameRef = OpaqueJSString::tryCreate(name);
697                 JSValueRef exception = 0;
698                 JSValueRef value;
699                 {
700                     JSLock::DropAllLocks dropAllLocks(globalObject);
701                     value = getProperty(toRef(globalObject), thisRef, propertyNameRef.get(), &amp;exception);
702                 }
703                 if (exception) {
704                     throwException(globalObject, scope, toJS(globalObject, exception));
705                     return JSValue::encode(jsUndefined());
706                 }
707                 if (value)
708                     return JSValue::encode(toJS(globalObject, value));
709             }
710         }
711     }
712 
713     return JSValue::encode(throwException(globalObject, scope, createReferenceError(globalObject, &quot;hasProperty callback returned true for a property that doesn&#39;t exist.&quot;_s)));
714 }
715 
716 } // namespace JSC
    </pre>
  </body>
</html>
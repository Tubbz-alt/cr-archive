<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLSemanticMatcher.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WHLSLPruneUnreachableStandardLibraryFunctions.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLStandardLibrary.txt.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLSemanticMatcher.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 44 namespace WebCore {
 45 
 46 namespace WHLSL {
 47 
 48 static bool matchMode(Binding::BindingDetails bindingType, AST::ResourceSemantic::Mode mode)
 49 {
 50     return WTF::visit(WTF::makeVisitor([&amp;](UniformBufferBinding) -&gt; bool {
 51         return mode == AST::ResourceSemantic::Mode::Buffer;
 52     }, [&amp;](SamplerBinding) -&gt; bool {
 53         return mode == AST::ResourceSemantic::Mode::Sampler;
 54     }, [&amp;](TextureBinding) -&gt; bool {
 55         return mode == AST::ResourceSemantic::Mode::Texture;
 56     }, [&amp;](StorageBufferBinding) -&gt; bool {
 57         return mode == AST::ResourceSemantic::Mode::UnorderedAccessView;
 58     }), bindingType);
 59 }
 60 
 61 static Optional&lt;HashMap&lt;Binding*, size_t&gt;&gt; matchResources(Vector&lt;EntryPointItem&gt;&amp; entryPointItems, Layout&amp; layout, ShaderStage shaderStage)
 62 {
 63     HashMap&lt;Binding*, size_t&gt; result;
<span class="line-modified"> 64     HashSet&lt;size_t&gt; itemIndices;</span>
<span class="line-removed"> 65     if (entryPointItems.size() == std::numeric_limits&lt;size_t&gt;::max())</span>
<span class="line-removed"> 66         return WTF::nullopt; // Work around the fact that HashSet&#39;s keys are restricted.</span>
 67     for (auto&amp; bindGroup : layout) {
 68         auto space = bindGroup.name;
 69         for (auto&amp; binding : bindGroup.bindings) {
 70             if (!binding.visibility.contains(shaderStage))
 71                 continue;
 72             for (size_t i = 0; i &lt; entryPointItems.size(); ++i) {
 73                 auto&amp; item = entryPointItems[i];
 74                 auto&amp; semantic = *item.semantic;
 75                 if (!WTF::holds_alternative&lt;AST::ResourceSemantic&gt;(semantic))
 76                     continue;
 77                 auto&amp; resourceSemantic = WTF::get&lt;AST::ResourceSemantic&gt;(semantic);
 78                 if (!matchMode(binding.binding, resourceSemantic.mode()))
 79                     continue;
 80                 if (binding.externalName != resourceSemantic.index())
 81                     continue;
 82                 if (space != resourceSemantic.space())
 83                     continue;
 84                 result.add(&amp;binding, i);
<span class="line-modified"> 85                 itemIndices.add(i + 1); // Work around the fact that HashSet&#39;s keys are restricted.</span>
 86             }
 87         }
 88     }
 89 
 90     for (size_t i = 0; i &lt; entryPointItems.size(); ++i) {
 91         auto&amp; item = entryPointItems[i];
 92         auto&amp; semantic = *item.semantic;
 93         if (!WTF::holds_alternative&lt;AST::ResourceSemantic&gt;(semantic))
 94             continue;
<span class="line-modified"> 95         if (!itemIndices.contains(i + 1))</span>
 96             return WTF::nullopt;
 97     }
 98 
 99     return result;
100 }
101 
102 static bool matchInputsOutputs(Vector&lt;EntryPointItem&gt;&amp; vertexOutputs, Vector&lt;EntryPointItem&gt;&amp; fragmentInputs)
103 {
104     for (auto&amp; fragmentInput : fragmentInputs) {
105         if (!WTF::holds_alternative&lt;AST::StageInOutSemantic&gt;(*fragmentInput.semantic))
106             continue;
107         auto&amp; fragmentInputStageInOutSemantic = WTF::get&lt;AST::StageInOutSemantic&gt;(*fragmentInput.semantic);
108         bool found = false;
109         for (auto&amp; vertexOutput : vertexOutputs) {
110             if (!WTF::holds_alternative&lt;AST::StageInOutSemantic&gt;(*vertexOutput.semantic))
111                 continue;
112             auto&amp; vertexOutputStageInOutSemantic = WTF::get&lt;AST::StageInOutSemantic&gt;(*vertexOutput.semantic);
113             if (fragmentInputStageInOutSemantic.index() == vertexOutputStageInOutSemantic.index()) {
114                 if (matches(*fragmentInput.unnamedType, *vertexOutput.unnamedType)) {
115                     found = true;
</pre>
<hr />
<pre>
125 }
126 
127 static bool isAcceptableFormat(VertexFormat vertexFormat, AST::UnnamedType&amp; unnamedType, Intrinsics&amp; intrinsics)
128 {
129     switch (vertexFormat) {
130     case VertexFormat::FloatR32G32B32A32:
131         return matches(unnamedType, intrinsics.float4Type());
132     case VertexFormat::FloatR32G32B32:
133         return matches(unnamedType, intrinsics.float3Type());
134     case VertexFormat::FloatR32G32:
135         return matches(unnamedType, intrinsics.float2Type());
136     default:
137         ASSERT(vertexFormat == VertexFormat::FloatR32);
138         return matches(unnamedType, intrinsics.floatType());
139     }
140 }
141 
142 static Optional&lt;HashMap&lt;VertexAttribute*, size_t&gt;&gt; matchVertexAttributes(Vector&lt;EntryPointItem&gt;&amp; vertexInputs, VertexAttributes&amp; vertexAttributes, Intrinsics&amp; intrinsics)
143 {
144     HashMap&lt;VertexAttribute*, size_t&gt; result;
<span class="line-modified">145     HashSet&lt;size_t&gt; itemIndices;</span>
<span class="line-removed">146     if (vertexInputs.size() == std::numeric_limits&lt;size_t&gt;::max())</span>
<span class="line-removed">147         return WTF::nullopt; // Work around the fact that HashSet&#39;s keys are restricted.</span>
148     for (auto&amp; vertexAttribute : vertexAttributes) {
149         for (size_t i = 0; i &lt; vertexInputs.size(); ++i) {
150             auto&amp; item = vertexInputs[i];
151             auto&amp; semantic = *item.semantic;
152             if (!WTF::holds_alternative&lt;AST::StageInOutSemantic&gt;(semantic))
153                 continue;
154             auto&amp; stageInOutSemantic = WTF::get&lt;AST::StageInOutSemantic&gt;(semantic);
155             if (stageInOutSemantic.index() != vertexAttribute.shaderLocation)
156                 continue;
157             if (!isAcceptableFormat(vertexAttribute.vertexFormat, *item.unnamedType, intrinsics))
158                 return WTF::nullopt;
159             result.add(&amp;vertexAttribute, i);
<span class="line-modified">160             itemIndices.add(i + 1); // Work around the fact that HashSet&#39;s keys are restricted.</span>
161         }
162     }
163 
164     for (size_t i = 0; i &lt; vertexInputs.size(); ++i) {
165         auto&amp; item = vertexInputs[i];
166         auto&amp; semantic = *item.semantic;
167         if (!WTF::holds_alternative&lt;AST::StageInOutSemantic&gt;(semantic))
168             continue;
<span class="line-modified">169         if (!itemIndices.contains(i + 1))</span>
170             return WTF::nullopt;
171     }
172 
173     return result;
174 }
175 
176 static bool isAcceptableFormat(TextureFormat textureFormat, AST::UnnamedType&amp; unnamedType, Intrinsics&amp; intrinsics, bool isColor)
177 {
178     if (isColor) {
179         switch (textureFormat) {
180         case TextureFormat::R8Unorm:
181         case TextureFormat::R8UnormSrgb:
182         case TextureFormat::R8Snorm:
183         case TextureFormat::R16Unorm:
184         case TextureFormat::R16Snorm:
185         case TextureFormat::R16Float:
186         case TextureFormat::R32Float:
187             return matches(unnamedType, intrinsics.floatType());
188         case TextureFormat::RG8Unorm:
189         case TextureFormat::RG8UnormSrgb:
</pre>
<hr />
<pre>
213             return matches(unnamedType, intrinsics.intType());
214         case TextureFormat::RG32Uint:
215             return matches(unnamedType, intrinsics.uint2Type());
216         case TextureFormat::RG32Sint:
217             return matches(unnamedType, intrinsics.int2Type());
218         case TextureFormat::RGBA32Uint:
219             return matches(unnamedType, intrinsics.uint4Type());
220         case TextureFormat::RGBA32Sint:
221             return matches(unnamedType, intrinsics.int4Type());
222         default:
223             ASSERT_NOT_REACHED();
224             return false;
225         }
226     }
227     return false;
228 }
229 
230 static Optional&lt;HashMap&lt;AttachmentDescriptor*, size_t&gt;&gt; matchColorAttachments(Vector&lt;EntryPointItem&gt;&amp; fragmentOutputs, Vector&lt;AttachmentDescriptor&gt;&amp; attachmentDescriptors, Intrinsics&amp; intrinsics)
231 {
232     HashMap&lt;AttachmentDescriptor*, size_t&gt; result;
<span class="line-modified">233     HashSet&lt;size_t&gt; itemIndices;</span>
<span class="line-removed">234     if (attachmentDescriptors.size() == std::numeric_limits&lt;size_t&gt;::max())</span>
<span class="line-removed">235         return WTF::nullopt; // Work around the fact that HashSet&#39;s keys are restricted.</span>
236     for (auto&amp; attachmentDescriptor : attachmentDescriptors) {
237         for (size_t i = 0; i &lt; fragmentOutputs.size(); ++i) {
238             auto&amp; item = fragmentOutputs[i];
239             auto&amp; semantic = *item.semantic;
240             if (!WTF::holds_alternative&lt;AST::StageInOutSemantic&gt;(semantic))
241                 continue;
242             auto&amp; stageInOutSemantic = WTF::get&lt;AST::StageInOutSemantic&gt;(semantic);
243             if (stageInOutSemantic.index() != attachmentDescriptor.name)
244                 continue;
245             if (!isAcceptableFormat(attachmentDescriptor.textureFormat, *item.unnamedType, intrinsics, true))
246                 return WTF::nullopt;
247             result.add(&amp;attachmentDescriptor, i);
<span class="line-modified">248             itemIndices.add(i + 1); // Work around the fact that HashSet&#39;s keys are restricted.</span>
249         }
250     }
251 
252     for (size_t i = 0; i &lt; fragmentOutputs.size(); ++i) {
253         auto&amp; item = fragmentOutputs[i];
254         auto&amp; semantic = *item.semantic;
255         if (!WTF::holds_alternative&lt;AST::StageInOutSemantic&gt;(semantic))
256             continue;
<span class="line-modified">257         if (!itemIndices.contains(i + 1))</span>
258             return WTF::nullopt;
259     }
260 
261     return result;
262 }
263 
264 static bool matchDepthAttachment(Vector&lt;EntryPointItem&gt;&amp; fragmentOutputs, Optional&lt;AttachmentDescriptor&gt;&amp; depthStencilAttachmentDescriptor, Intrinsics&amp; intrinsics)
265 {
266     auto iterator = std::find_if(fragmentOutputs.begin(), fragmentOutputs.end(), [&amp;](EntryPointItem&amp; item) {
267         auto&amp; semantic = *item.semantic;
268         if (!WTF::holds_alternative&lt;AST::BuiltInSemantic&gt;(semantic))
269             return false;
270         auto&amp; builtInSemantic = WTF::get&lt;AST::BuiltInSemantic&gt;(semantic);
271         return builtInSemantic.variable() == AST::BuiltInSemantic::Variable::SVDepth;
272     });
273     if (iterator == fragmentOutputs.end())
274         return true;
275 
276     if (depthStencilAttachmentDescriptor) {
277         ASSERT(!depthStencilAttachmentDescriptor-&gt;name);
</pre>
</td>
<td>
<hr />
<pre>
 44 namespace WebCore {
 45 
 46 namespace WHLSL {
 47 
 48 static bool matchMode(Binding::BindingDetails bindingType, AST::ResourceSemantic::Mode mode)
 49 {
 50     return WTF::visit(WTF::makeVisitor([&amp;](UniformBufferBinding) -&gt; bool {
 51         return mode == AST::ResourceSemantic::Mode::Buffer;
 52     }, [&amp;](SamplerBinding) -&gt; bool {
 53         return mode == AST::ResourceSemantic::Mode::Sampler;
 54     }, [&amp;](TextureBinding) -&gt; bool {
 55         return mode == AST::ResourceSemantic::Mode::Texture;
 56     }, [&amp;](StorageBufferBinding) -&gt; bool {
 57         return mode == AST::ResourceSemantic::Mode::UnorderedAccessView;
 58     }), bindingType);
 59 }
 60 
 61 static Optional&lt;HashMap&lt;Binding*, size_t&gt;&gt; matchResources(Vector&lt;EntryPointItem&gt;&amp; entryPointItems, Layout&amp; layout, ShaderStage shaderStage)
 62 {
 63     HashMap&lt;Binding*, size_t&gt; result;
<span class="line-modified"> 64     HashSet&lt;size_t, DefaultHash&lt;size_t&gt;::Hash, WTF::UnsignedWithZeroKeyHashTraits&lt;size_t&gt;&gt; itemIndices;</span>


 65     for (auto&amp; bindGroup : layout) {
 66         auto space = bindGroup.name;
 67         for (auto&amp; binding : bindGroup.bindings) {
 68             if (!binding.visibility.contains(shaderStage))
 69                 continue;
 70             for (size_t i = 0; i &lt; entryPointItems.size(); ++i) {
 71                 auto&amp; item = entryPointItems[i];
 72                 auto&amp; semantic = *item.semantic;
 73                 if (!WTF::holds_alternative&lt;AST::ResourceSemantic&gt;(semantic))
 74                     continue;
 75                 auto&amp; resourceSemantic = WTF::get&lt;AST::ResourceSemantic&gt;(semantic);
 76                 if (!matchMode(binding.binding, resourceSemantic.mode()))
 77                     continue;
 78                 if (binding.externalName != resourceSemantic.index())
 79                     continue;
 80                 if (space != resourceSemantic.space())
 81                     continue;
 82                 result.add(&amp;binding, i);
<span class="line-modified"> 83                 itemIndices.add(i);</span>
 84             }
 85         }
 86     }
 87 
 88     for (size_t i = 0; i &lt; entryPointItems.size(); ++i) {
 89         auto&amp; item = entryPointItems[i];
 90         auto&amp; semantic = *item.semantic;
 91         if (!WTF::holds_alternative&lt;AST::ResourceSemantic&gt;(semantic))
 92             continue;
<span class="line-modified"> 93         if (!itemIndices.contains(i))</span>
 94             return WTF::nullopt;
 95     }
 96 
 97     return result;
 98 }
 99 
100 static bool matchInputsOutputs(Vector&lt;EntryPointItem&gt;&amp; vertexOutputs, Vector&lt;EntryPointItem&gt;&amp; fragmentInputs)
101 {
102     for (auto&amp; fragmentInput : fragmentInputs) {
103         if (!WTF::holds_alternative&lt;AST::StageInOutSemantic&gt;(*fragmentInput.semantic))
104             continue;
105         auto&amp; fragmentInputStageInOutSemantic = WTF::get&lt;AST::StageInOutSemantic&gt;(*fragmentInput.semantic);
106         bool found = false;
107         for (auto&amp; vertexOutput : vertexOutputs) {
108             if (!WTF::holds_alternative&lt;AST::StageInOutSemantic&gt;(*vertexOutput.semantic))
109                 continue;
110             auto&amp; vertexOutputStageInOutSemantic = WTF::get&lt;AST::StageInOutSemantic&gt;(*vertexOutput.semantic);
111             if (fragmentInputStageInOutSemantic.index() == vertexOutputStageInOutSemantic.index()) {
112                 if (matches(*fragmentInput.unnamedType, *vertexOutput.unnamedType)) {
113                     found = true;
</pre>
<hr />
<pre>
123 }
124 
125 static bool isAcceptableFormat(VertexFormat vertexFormat, AST::UnnamedType&amp; unnamedType, Intrinsics&amp; intrinsics)
126 {
127     switch (vertexFormat) {
128     case VertexFormat::FloatR32G32B32A32:
129         return matches(unnamedType, intrinsics.float4Type());
130     case VertexFormat::FloatR32G32B32:
131         return matches(unnamedType, intrinsics.float3Type());
132     case VertexFormat::FloatR32G32:
133         return matches(unnamedType, intrinsics.float2Type());
134     default:
135         ASSERT(vertexFormat == VertexFormat::FloatR32);
136         return matches(unnamedType, intrinsics.floatType());
137     }
138 }
139 
140 static Optional&lt;HashMap&lt;VertexAttribute*, size_t&gt;&gt; matchVertexAttributes(Vector&lt;EntryPointItem&gt;&amp; vertexInputs, VertexAttributes&amp; vertexAttributes, Intrinsics&amp; intrinsics)
141 {
142     HashMap&lt;VertexAttribute*, size_t&gt; result;
<span class="line-modified">143     HashSet&lt;size_t, DefaultHash&lt;size_t&gt;::Hash, WTF::UnsignedWithZeroKeyHashTraits&lt;size_t&gt;&gt; itemIndices;</span>


144     for (auto&amp; vertexAttribute : vertexAttributes) {
145         for (size_t i = 0; i &lt; vertexInputs.size(); ++i) {
146             auto&amp; item = vertexInputs[i];
147             auto&amp; semantic = *item.semantic;
148             if (!WTF::holds_alternative&lt;AST::StageInOutSemantic&gt;(semantic))
149                 continue;
150             auto&amp; stageInOutSemantic = WTF::get&lt;AST::StageInOutSemantic&gt;(semantic);
151             if (stageInOutSemantic.index() != vertexAttribute.shaderLocation)
152                 continue;
153             if (!isAcceptableFormat(vertexAttribute.vertexFormat, *item.unnamedType, intrinsics))
154                 return WTF::nullopt;
155             result.add(&amp;vertexAttribute, i);
<span class="line-modified">156             itemIndices.add(i);</span>
157         }
158     }
159 
160     for (size_t i = 0; i &lt; vertexInputs.size(); ++i) {
161         auto&amp; item = vertexInputs[i];
162         auto&amp; semantic = *item.semantic;
163         if (!WTF::holds_alternative&lt;AST::StageInOutSemantic&gt;(semantic))
164             continue;
<span class="line-modified">165         if (!itemIndices.contains(i))</span>
166             return WTF::nullopt;
167     }
168 
169     return result;
170 }
171 
172 static bool isAcceptableFormat(TextureFormat textureFormat, AST::UnnamedType&amp; unnamedType, Intrinsics&amp; intrinsics, bool isColor)
173 {
174     if (isColor) {
175         switch (textureFormat) {
176         case TextureFormat::R8Unorm:
177         case TextureFormat::R8UnormSrgb:
178         case TextureFormat::R8Snorm:
179         case TextureFormat::R16Unorm:
180         case TextureFormat::R16Snorm:
181         case TextureFormat::R16Float:
182         case TextureFormat::R32Float:
183             return matches(unnamedType, intrinsics.floatType());
184         case TextureFormat::RG8Unorm:
185         case TextureFormat::RG8UnormSrgb:
</pre>
<hr />
<pre>
209             return matches(unnamedType, intrinsics.intType());
210         case TextureFormat::RG32Uint:
211             return matches(unnamedType, intrinsics.uint2Type());
212         case TextureFormat::RG32Sint:
213             return matches(unnamedType, intrinsics.int2Type());
214         case TextureFormat::RGBA32Uint:
215             return matches(unnamedType, intrinsics.uint4Type());
216         case TextureFormat::RGBA32Sint:
217             return matches(unnamedType, intrinsics.int4Type());
218         default:
219             ASSERT_NOT_REACHED();
220             return false;
221         }
222     }
223     return false;
224 }
225 
226 static Optional&lt;HashMap&lt;AttachmentDescriptor*, size_t&gt;&gt; matchColorAttachments(Vector&lt;EntryPointItem&gt;&amp; fragmentOutputs, Vector&lt;AttachmentDescriptor&gt;&amp; attachmentDescriptors, Intrinsics&amp; intrinsics)
227 {
228     HashMap&lt;AttachmentDescriptor*, size_t&gt; result;
<span class="line-modified">229     HashSet&lt;size_t, DefaultHash&lt;size_t&gt;::Hash, WTF::UnsignedWithZeroKeyHashTraits&lt;size_t&gt;&gt; itemIndices;</span>


230     for (auto&amp; attachmentDescriptor : attachmentDescriptors) {
231         for (size_t i = 0; i &lt; fragmentOutputs.size(); ++i) {
232             auto&amp; item = fragmentOutputs[i];
233             auto&amp; semantic = *item.semantic;
234             if (!WTF::holds_alternative&lt;AST::StageInOutSemantic&gt;(semantic))
235                 continue;
236             auto&amp; stageInOutSemantic = WTF::get&lt;AST::StageInOutSemantic&gt;(semantic);
237             if (stageInOutSemantic.index() != attachmentDescriptor.name)
238                 continue;
239             if (!isAcceptableFormat(attachmentDescriptor.textureFormat, *item.unnamedType, intrinsics, true))
240                 return WTF::nullopt;
241             result.add(&amp;attachmentDescriptor, i);
<span class="line-modified">242             itemIndices.add(i);</span>
243         }
244     }
245 
246     for (size_t i = 0; i &lt; fragmentOutputs.size(); ++i) {
247         auto&amp; item = fragmentOutputs[i];
248         auto&amp; semantic = *item.semantic;
249         if (!WTF::holds_alternative&lt;AST::StageInOutSemantic&gt;(semantic))
250             continue;
<span class="line-modified">251         if (!itemIndices.contains(i))</span>
252             return WTF::nullopt;
253     }
254 
255     return result;
256 }
257 
258 static bool matchDepthAttachment(Vector&lt;EntryPointItem&gt;&amp; fragmentOutputs, Optional&lt;AttachmentDescriptor&gt;&amp; depthStencilAttachmentDescriptor, Intrinsics&amp; intrinsics)
259 {
260     auto iterator = std::find_if(fragmentOutputs.begin(), fragmentOutputs.end(), [&amp;](EntryPointItem&amp; item) {
261         auto&amp; semantic = *item.semantic;
262         if (!WTF::holds_alternative&lt;AST::BuiltInSemantic&gt;(semantic))
263             return false;
264         auto&amp; builtInSemantic = WTF::get&lt;AST::BuiltInSemantic&gt;(semantic);
265         return builtInSemantic.variable() == AST::BuiltInSemantic::Variable::SVDepth;
266     });
267     if (iterator == fragmentOutputs.end())
268         return true;
269 
270     if (depthStencilAttachmentDescriptor) {
271         ASSERT(!depthStencilAttachmentDescriptor-&gt;name);
</pre>
</td>
</tr>
</table>
<center><a href="WHLSLPruneUnreachableStandardLibraryFunctions.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLStandardLibrary.txt.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
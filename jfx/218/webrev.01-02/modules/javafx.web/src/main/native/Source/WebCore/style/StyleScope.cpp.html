<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/style/StyleScope.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
  5  *           (C) 2006 Alexey Proskuryakov (ap@webkit.org)
  6  * Copyright (C) 2004-2009, 2011-2012, 2015-2017 Apple Inc. All rights reserved.
  7  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  8  * Copyright (C) 2008, 2009, 2011, 2012 Google Inc. All rights reserved.
  9  * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
 10  * Copyright (C) Research In Motion Limited 2010-2011. All rights reserved.
 11  *
 12  * This library is free software; you can redistribute it and/or
 13  * modify it under the terms of the GNU Library General Public
 14  * License as published by the Free Software Foundation; either
 15  * version 2 of the License, or (at your option) any later version.
 16  *
 17  * This library is distributed in the hope that it will be useful,
 18  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 19  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 20  * Library General Public License for more details.
 21  *
 22  * You should have received a copy of the GNU Library General Public License
 23  * along with this library; see the file COPYING.LIB.  If not, write to
 24  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 25  * Boston, MA 02110-1301, USA.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;StyleScope.h&quot;
 30 
 31 #include &quot;CSSFontSelector.h&quot;
 32 #include &quot;CSSStyleSheet.h&quot;
 33 #include &quot;Element.h&quot;
 34 #include &quot;ElementChildIterator.h&quot;
 35 #include &quot;ExtensionStyleSheets.h&quot;
 36 #include &quot;HTMLHeadElement.h&quot;
 37 #include &quot;HTMLIFrameElement.h&quot;
 38 #include &quot;HTMLLinkElement.h&quot;
 39 #include &quot;HTMLSlotElement.h&quot;
 40 #include &quot;HTMLStyleElement.h&quot;
 41 #include &quot;InspectorInstrumentation.h&quot;
 42 #include &quot;ProcessingInstruction.h&quot;
 43 #include &quot;SVGStyleElement.h&quot;
 44 #include &quot;Settings.h&quot;
 45 #include &quot;ShadowRoot.h&quot;
 46 #include &quot;StyleInvalidator.h&quot;
 47 #include &quot;StyleResolver.h&quot;
 48 #include &quot;StyleSheetContents.h&quot;
 49 #include &quot;StyleSheetList.h&quot;
 50 #include &quot;UserContentController.h&quot;
 51 #include &quot;UserContentURLPattern.h&quot;
 52 #include &quot;UserStyleSheet.h&quot;
 53 #include &lt;wtf/SetForScope.h&gt;
 54 
 55 namespace WebCore {
 56 
 57 using namespace HTMLNames;
 58 
 59 namespace Style {
 60 
 61 Scope::Scope(Document&amp; document)
 62     : m_document(document)
 63     , m_pendingUpdateTimer(*this, &amp;Scope::pendingUpdateTimerFired)
 64 {
 65 }
 66 
 67 Scope::Scope(ShadowRoot&amp; shadowRoot)
 68     : m_document(shadowRoot.documentScope())
 69     , m_shadowRoot(&amp;shadowRoot)
 70     , m_pendingUpdateTimer(*this, &amp;Scope::pendingUpdateTimerFired)
 71 {
 72 }
 73 
 74 Scope::~Scope()
 75 {
 76     ASSERT(!hasPendingSheets());
 77 }
 78 
 79 bool Scope::shouldUseSharedUserAgentShadowTreeStyleResolver() const
 80 {
 81     if (!m_shadowRoot)
 82         return false;
 83     if (m_shadowRoot-&gt;mode() != ShadowRootMode::UserAgent)
 84         return false;
 85     // If we have stylesheets in the user agent shadow tree use per-scope resolver.
 86     if (!m_styleSheetCandidateNodes.isEmpty())
 87         return false;
 88     return true;
 89 }
 90 
 91 Resolver&amp; Scope::resolver()
 92 {
 93     if (shouldUseSharedUserAgentShadowTreeStyleResolver())
 94         return m_document.userAgentShadowTreeStyleResolver();
 95 
 96     if (!m_resolver) {
 97         SetForScope&lt;bool&gt; isUpdatingStyleResolver { m_isUpdatingStyleResolver, true };
 98 
 99         m_resolver = makeUnique&lt;Resolver&gt;(m_document);
100 
101         if (!m_shadowRoot) {
102             m_document.fontSelector().buildStarted();
103             m_resolver-&gt;ruleSets().initializeUserStyle();
104         } else {
105             m_resolver-&gt;ruleSets().setIsForShadowScope();
106             m_resolver-&gt;ruleSets().setUsesSharedUserStyle(m_shadowRoot-&gt;mode() != ShadowRootMode::UserAgent);
107         }
108 
109         m_resolver-&gt;addCurrentSVGFontFaceRules();
110         m_resolver-&gt;appendAuthorStyleSheets(m_activeStyleSheets);
111 
112         if (!m_shadowRoot)
113             m_document.fontSelector().buildCompleted();
114     }
115     ASSERT(!m_shadowRoot || &amp;m_document == &amp;m_shadowRoot-&gt;document());
116     ASSERT(&amp;m_resolver-&gt;document() == &amp;m_document);
117     return *m_resolver;
118 }
119 
120 Resolver* Scope::resolverIfExists()
121 {
122     if (shouldUseSharedUserAgentShadowTreeStyleResolver())
123         return &amp;m_document.userAgentShadowTreeStyleResolver();
124 
125     return m_resolver.get();
126 }
127 
128 void Scope::clearResolver()
129 {
130     m_resolver = nullptr;
131 
132     if (!m_shadowRoot)
133         m_document.didClearStyleResolver();
134 }
135 
136 void Scope::releaseMemory()
137 {
138     if (!m_shadowRoot) {
139         for (auto* descendantShadowRoot : m_document.inDocumentShadowRoots())
140             descendantShadowRoot-&gt;styleScope().releaseMemory();
141     }
142 
143 #if ENABLE(CSS_SELECTOR_JIT)
144     for (auto&amp; sheet : m_activeStyleSheets) {
145         sheet-&gt;contents().traverseRules([] (const StyleRuleBase&amp; rule) {
146             if (is&lt;StyleRule&gt;(rule))
147                 downcast&lt;StyleRule&gt;(rule).releaseCompiledSelectors();
148             return false;
149         });
150     }
151 #endif
152     clearResolver();
153 }
154 
155 Scope&amp; Scope::forNode(Node&amp; node)
156 {
157     ASSERT(node.isConnected());
158     auto* shadowRoot = node.containingShadowRoot();
159     if (shadowRoot)
160         return shadowRoot-&gt;styleScope();
161     return node.document().styleScope();
162 }
163 
164 Scope* Scope::forOrdinal(Element&amp; element, ScopeOrdinal ordinal)
165 {
166     switch (ordinal) {
167     case ScopeOrdinal::Element:
168         return &amp;forNode(element);
169     case ScopeOrdinal::ContainingHost: {
170         auto* containingShadowRoot = element.containingShadowRoot();
171         if (!containingShadowRoot)
172             return nullptr;
173         return &amp;forNode(*containingShadowRoot-&gt;host());
174     }
175     case ScopeOrdinal::Shadow: {
176         auto* shadowRoot = element.shadowRoot();
177         if (!shadowRoot)
178             return nullptr;
179         return &amp;shadowRoot-&gt;styleScope();
180     }
181     default: {
182         ASSERT(ordinal &gt;= ScopeOrdinal::FirstSlot);
183         auto slotIndex = ScopeOrdinal::FirstSlot;
184         for (auto* slot = element.assignedSlot(); slot; slot = slot-&gt;assignedSlot(), ++slotIndex) {
185             if (slotIndex == ordinal)
186                 return &amp;forNode(*slot);
187         }
188         return nullptr;
189     }
190     }
191 }
192 
193 void Scope::setPreferredStylesheetSetName(const String&amp; name)
194 {
195     if (m_preferredStylesheetSetName == name)
196         return;
197     m_preferredStylesheetSetName = name;
198     didChangeActiveStyleSheetCandidates();
199 }
200 
201 void Scope::addPendingSheet(const Element&amp; element)
202 {
203     ASSERT(!hasPendingSheet(element));
204 
205     bool isInHead = ancestorsOfType&lt;HTMLHeadElement&gt;(element).first();
206     if (isInHead)
207         m_elementsInHeadWithPendingSheets.add(&amp;element);
208     else
209         m_elementsInBodyWithPendingSheets.add(&amp;element);
210 }
211 
212 // This method is called whenever a top-level stylesheet has finished loading.
213 void Scope::removePendingSheet(const Element&amp; element)
214 {
215     ASSERT(hasPendingSheet(element));
216 
217     if (!m_elementsInHeadWithPendingSheets.remove(&amp;element))
218         m_elementsInBodyWithPendingSheets.remove(&amp;element);
219 
220     didRemovePendingStylesheet();
221 }
222 
223 void Scope::addPendingSheet(const ProcessingInstruction&amp; processingInstruction)
224 {
225     ASSERT(!m_processingInstructionsWithPendingSheets.contains(&amp;processingInstruction));
226 
227     m_processingInstructionsWithPendingSheets.add(&amp;processingInstruction);
228 }
229 
230 void Scope::removePendingSheet(const ProcessingInstruction&amp; processingInstruction)
231 {
232     ASSERT(m_processingInstructionsWithPendingSheets.contains(&amp;processingInstruction));
233 
234     m_processingInstructionsWithPendingSheets.remove(&amp;processingInstruction);
235 
236     didRemovePendingStylesheet();
237 }
238 
239 void Scope::didRemovePendingStylesheet()
240 {
241     if (hasPendingSheets())
242         return;
243 
244     didChangeActiveStyleSheetCandidates();
245 
246     if (!m_shadowRoot)
247         m_document.didRemoveAllPendingStylesheet();
248 }
249 
250 bool Scope::hasPendingSheet(const Element&amp; element) const
251 {
252     return m_elementsInHeadWithPendingSheets.contains(&amp;element) || hasPendingSheetInBody(element);
253 }
254 
255 bool Scope::hasPendingSheetInBody(const Element&amp; element) const
256 {
257     return m_elementsInBodyWithPendingSheets.contains(&amp;element);
258 }
259 
260 bool Scope::hasPendingSheet(const ProcessingInstruction&amp; processingInstruction) const
261 {
262     return m_processingInstructionsWithPendingSheets.contains(&amp;processingInstruction);
263 }
264 
265 void Scope::addStyleSheetCandidateNode(Node&amp; node, bool createdByParser)
266 {
267     if (!node.isConnected())
268         return;
269 
270     // Until the &lt;body&gt; exists, we have no choice but to compare document positions,
271     // since styles outside of the body and head continue to be shunted into the head
272     // (and thus can shift to end up before dynamically added DOM content that is also
273     // outside the body).
274     if ((createdByParser &amp;&amp; m_document.bodyOrFrameset()) || m_styleSheetCandidateNodes.isEmpty()) {
275         m_styleSheetCandidateNodes.add(&amp;node);
276         return;
277     }
278 
279     // Determine an appropriate insertion point.
280     auto begin = m_styleSheetCandidateNodes.begin();
281     auto end = m_styleSheetCandidateNodes.end();
282     auto it = end;
283     Node* followingNode = nullptr;
284     do {
285         --it;
286         Node* n = *it;
287         unsigned short position = n-&gt;compareDocumentPosition(node);
288         if (position == Node::DOCUMENT_POSITION_FOLLOWING) {
289             m_styleSheetCandidateNodes.insertBefore(followingNode, &amp;node);
290             return;
291         }
292         followingNode = n;
293     } while (it != begin);
294 
295     m_styleSheetCandidateNodes.insertBefore(followingNode, &amp;node);
296 }
297 
298 void Scope::removeStyleSheetCandidateNode(Node&amp; node)
299 {
300     if (m_styleSheetCandidateNodes.remove(&amp;node))
301         didChangeActiveStyleSheetCandidates();
302 }
303 
304 #if ENABLE(XSLT)
305 // FIXME: &lt;https://webkit.org/b/178830&gt; Remove XSLT relaed code from Style::Scope.
306 Vector&lt;Ref&lt;ProcessingInstruction&gt;&gt; Scope::collectXSLTransforms()
307 {
308     Vector&lt;Ref&lt;ProcessingInstruction&gt;&gt; processingInstructions;
309     for (auto&amp; node : m_styleSheetCandidateNodes) {
310         if (is&lt;ProcessingInstruction&gt;(*node) &amp;&amp; downcast&lt;ProcessingInstruction&gt;(*node).isXSL())
311             processingInstructions.append(downcast&lt;ProcessingInstruction&gt;(*node));
312     }
313     return processingInstructions;
314 }
315 #endif
316 
317 void Scope::collectActiveStyleSheets(Vector&lt;RefPtr&lt;StyleSheet&gt;&gt;&amp; sheets)
318 {
319     if (!m_document.settings().authorAndUserStylesEnabled())
320         return;
321 
322     for (auto&amp; node : m_styleSheetCandidateNodes) {
323         RefPtr&lt;StyleSheet&gt; sheet;
324         if (is&lt;ProcessingInstruction&gt;(*node)) {
325             if (!downcast&lt;ProcessingInstruction&gt;(*node).isCSS())
326                 continue;
327             // We don&#39;t support linking to embedded CSS stylesheets, see &lt;https://bugs.webkit.org/show_bug.cgi?id=49281&gt; for discussion.
328             sheet = downcast&lt;ProcessingInstruction&gt;(*node).sheet();
329         } else if (is&lt;HTMLLinkElement&gt;(*node) || is&lt;HTMLStyleElement&gt;(*node) || is&lt;SVGStyleElement&gt;(*node)) {
330             Element&amp; element = downcast&lt;Element&gt;(*node);
331             AtomString title = element.isInShadowTree() ? nullAtom() : element.attributeWithoutSynchronization(titleAttr);
332             bool enabledViaScript = false;
333             if (is&lt;HTMLLinkElement&gt;(element)) {
334                 // &lt;LINK&gt; element
335                 HTMLLinkElement&amp; linkElement = downcast&lt;HTMLLinkElement&gt;(element);
336                 if (linkElement.isDisabled())
337                     continue;
338                 enabledViaScript = linkElement.isEnabledViaScript();
339                 if (linkElement.styleSheetIsLoading()) {
340                     // it is loading but we should still decide which style sheet set to use
341                     if (!enabledViaScript &amp;&amp; !title.isEmpty() &amp;&amp; m_preferredStylesheetSetName.isEmpty()) {
342                         if (!linkElement.attributeWithoutSynchronization(relAttr).contains(&quot;alternate&quot;))
343                             m_preferredStylesheetSetName = title;
344                     }
345                     continue;
346                 }
347                 if (!linkElement.sheet())
348                     title = nullAtom();
349             }
350             // Get the current preferred styleset. This is the
351             // set of sheets that will be enabled.
352             if (is&lt;SVGStyleElement&gt;(element))
353                 sheet = downcast&lt;SVGStyleElement&gt;(element).sheet();
354             else if (is&lt;HTMLLinkElement&gt;(element))
355                 sheet = downcast&lt;HTMLLinkElement&gt;(element).sheet();
356             else
357                 sheet = downcast&lt;HTMLStyleElement&gt;(element).sheet();
358             // Check to see if this sheet belongs to a styleset
359             // (thus making it PREFERRED or ALTERNATE rather than
360             // PERSISTENT).
361             auto&amp; rel = element.attributeWithoutSynchronization(relAttr);
362             if (!enabledViaScript &amp;&amp; !title.isEmpty()) {
363                 // Yes, we have a title.
364                 if (m_preferredStylesheetSetName.isEmpty()) {
365                     // No preferred set has been established. If
366                     // we are NOT an alternate sheet, then establish
367                     // us as the preferred set. Otherwise, just ignore
368                     // this sheet.
369                     if (is&lt;HTMLStyleElement&gt;(element) || !rel.contains(&quot;alternate&quot;))
370                         m_preferredStylesheetSetName = title;
371                 }
372                 if (title != m_preferredStylesheetSetName)
373                     sheet = nullptr;
374             }
375 
376             if (rel.contains(&quot;alternate&quot;) &amp;&amp; title.isEmpty())
377                 sheet = nullptr;
378         }
379         if (sheet)
380             sheets.append(WTFMove(sheet));
381     }
382 }
383 
384 Scope::StyleSheetChange Scope::analyzeStyleSheetChange(const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; newStylesheets)
385 {
386     unsigned newStylesheetCount = newStylesheets.size();
387 
388     if (!resolverIfExists())
389         return { ResolverUpdateType::Reconstruct };
390 
391     // Find out which stylesheets are new.
392     unsigned oldStylesheetCount = m_activeStyleSheets.size();
393     if (newStylesheetCount &lt; oldStylesheetCount)
394         return { ResolverUpdateType::Reconstruct };
395 
396     Vector&lt;StyleSheetContents*&gt; addedSheets;
397     unsigned newIndex = 0;
398     for (unsigned oldIndex = 0; oldIndex &lt; oldStylesheetCount; ++oldIndex) {
399         if (newIndex &gt;= newStylesheetCount)
400             return { ResolverUpdateType::Reconstruct };
401 
402         while (m_activeStyleSheets[oldIndex] != newStylesheets[newIndex]) {
403             addedSheets.append(&amp;newStylesheets[newIndex]-&gt;contents());
404             ++newIndex;
405             if (newIndex == newStylesheetCount)
406                 return { ResolverUpdateType::Reconstruct };
407         }
408         ++newIndex;
409     }
410     bool hasInsertions = !addedSheets.isEmpty();
411     while (newIndex &lt; newStylesheetCount) {
412         addedSheets.append(&amp;newStylesheets[newIndex]-&gt;contents());
413         ++newIndex;
414     }
415 
416     // If all new sheets were added at the end of the list we can just add them to existing Resolver.
417     // If there were insertions we need to re-add all the stylesheets so rules are ordered correctly.
418     return { hasInsertions ? ResolverUpdateType::Reset : ResolverUpdateType::Additive, WTFMove(addedSheets) };
419 }
420 
421 static void filterEnabledNonemptyCSSStyleSheets(Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; result, const Vector&lt;RefPtr&lt;StyleSheet&gt;&gt;&amp; sheets)
422 {
423     for (auto&amp; sheet : sheets) {
424         if (!is&lt;CSSStyleSheet&gt;(*sheet))
425             continue;
426         CSSStyleSheet&amp; styleSheet = downcast&lt;CSSStyleSheet&gt;(*sheet);
427         if (styleSheet.isLoading())
428             continue;
429         if (styleSheet.disabled())
430             continue;
431         if (!styleSheet.length())
432             continue;
433         result.append(&amp;styleSheet);
434     }
435 }
436 
437 void Scope::updateActiveStyleSheets(UpdateType updateType)
438 {
439     ASSERT(!m_pendingUpdate);
440 
441     if (!m_document.hasLivingRenderTree())
442         return;
443 
444     if (m_document.inStyleRecalc() || m_document.inRenderTreeUpdate()) {
445         // Protect against deleting style resolver in the middle of a style resolution.
446         // Crash stacks indicate we can get here when a resource load fails synchronously (for example due to content blocking).
447         // FIXME: These kind of cases should be eliminated and this path replaced by an assert.
448         m_pendingUpdate = UpdateType::ContentsOrInterpretation;
449         m_document.scheduleFullStyleRebuild();
450         return;
451     }
452 
453     Vector&lt;RefPtr&lt;StyleSheet&gt;&gt; activeStyleSheets;
454     collectActiveStyleSheets(activeStyleSheets);
455 
456     Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt; activeCSSStyleSheets;
457     activeCSSStyleSheets.appendVector(m_document.extensionStyleSheets().injectedAuthorStyleSheets());
458     activeCSSStyleSheets.appendVector(m_document.extensionStyleSheets().authorStyleSheetsForTesting());
459     filterEnabledNonemptyCSSStyleSheets(activeCSSStyleSheets, activeStyleSheets);
460 
461     auto styleSheetChange = StyleSheetChange { ResolverUpdateType::Reconstruct };
462     if (updateType == UpdateType::ActiveSet)
463         styleSheetChange = analyzeStyleSheetChange(activeCSSStyleSheets);
464 
465     updateResolver(activeCSSStyleSheets, styleSheetChange.resolverUpdateType);
466 
467     m_weakCopyOfActiveStyleSheetListForFastLookup = nullptr;
468     m_activeStyleSheets.swap(activeCSSStyleSheets);
469     m_styleSheetsForStyleSheetList.swap(activeStyleSheets);
470 
471     InspectorInstrumentation::activeStyleSheetsUpdated(m_document);
472 
473     for (const auto&amp; sheet : m_activeStyleSheets) {
474         if (sheet-&gt;contents().usesStyleBasedEditability())
475             m_usesStyleBasedEditability = true;
476     }
477 
478     invalidateStyleAfterStyleSheetChange(styleSheetChange);
479 }
480 
481 void Scope::invalidateStyleAfterStyleSheetChange(const StyleSheetChange&amp; styleSheetChange)
482 {
483     // If we are already parsing the body and so may have significant amount of elements, put some effort into trying to avoid style recalcs.
484     bool invalidateAll = !m_document.bodyOrFrameset() || m_document.hasNodesWithNonFinalStyle() || m_document.hasNodesWithMissingStyle();
485 
486     if (styleSheetChange.resolverUpdateType == ResolverUpdateType::Reconstruct || invalidateAll) {
487         Invalidator::invalidateAllStyle(*this);
488         return;
489     }
490 
491     Invalidator invalidator(styleSheetChange.addedSheets, m_resolver-&gt;mediaQueryEvaluator());
492     invalidator.invalidateStyle(*this);
493 }
494 
495 void Scope::updateResolver(Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; activeStyleSheets, ResolverUpdateType updateType)
496 {
497     if (updateType == ResolverUpdateType::Reconstruct) {
498         clearResolver();
499         return;
500     }
501     auto&amp; styleResolver = resolver();
502 
503     SetForScope&lt;bool&gt; isUpdatingStyleResolver { m_isUpdatingStyleResolver, true };
504     if (updateType == ResolverUpdateType::Reset) {
505         styleResolver.ruleSets().resetAuthorStyle();
506         styleResolver.appendAuthorStyleSheets(activeStyleSheets);
507     } else {
508         ASSERT(updateType == ResolverUpdateType::Additive);
509         unsigned firstNewIndex = m_activeStyleSheets.size();
510         Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt; newStyleSheets;
511         newStyleSheets.appendRange(activeStyleSheets.begin() + firstNewIndex, activeStyleSheets.end());
512         styleResolver.appendAuthorStyleSheets(newStyleSheets);
513     }
514 }
515 
516 const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt; Scope::activeStyleSheetsForInspector()
517 {
518     Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt; result;
519 
520     if (auto* pageUserSheet = m_document.extensionStyleSheets().pageUserSheet())
521         result.append(pageUserSheet);
522     result.appendVector(m_document.extensionStyleSheets().documentUserStyleSheets());
523     result.appendVector(m_document.extensionStyleSheets().injectedUserStyleSheets());
524     result.appendVector(m_document.extensionStyleSheets().injectedAuthorStyleSheets());
525     result.appendVector(m_document.extensionStyleSheets().authorStyleSheetsForTesting());
526 
527     for (auto&amp; styleSheet : m_styleSheetsForStyleSheetList) {
528         if (!is&lt;CSSStyleSheet&gt;(*styleSheet))
529             continue;
530 
531         CSSStyleSheet&amp; sheet = downcast&lt;CSSStyleSheet&gt;(*styleSheet);
532         if (sheet.disabled())
533             continue;
534 
535         result.append(&amp;sheet);
536     }
537 
538     return result;
539 }
540 
541 bool Scope::activeStyleSheetsContains(const CSSStyleSheet* sheet) const
542 {
543     if (!m_weakCopyOfActiveStyleSheetListForFastLookup) {
544         m_weakCopyOfActiveStyleSheetListForFastLookup = makeUnique&lt;HashSet&lt;const CSSStyleSheet*&gt;&gt;();
545         for (auto&amp; activeStyleSheet : m_activeStyleSheets)
546             m_weakCopyOfActiveStyleSheetListForFastLookup-&gt;add(activeStyleSheet.get());
547     }
548     return m_weakCopyOfActiveStyleSheetListForFastLookup-&gt;contains(sheet);
549 }
550 
551 void Scope::flushPendingSelfUpdate()
552 {
553     ASSERT(m_pendingUpdate);
554 
555     auto updateType = *m_pendingUpdate;
556 
557     clearPendingUpdate();
558     updateActiveStyleSheets(updateType);
559 }
560 
561 void Scope::flushPendingDescendantUpdates()
562 {
563     ASSERT(m_hasDescendantWithPendingUpdate);
564     ASSERT(!m_shadowRoot);
565     for (auto* descendantShadowRoot : m_document.inDocumentShadowRoots())
566         descendantShadowRoot-&gt;styleScope().flushPendingUpdate();
567     m_hasDescendantWithPendingUpdate = false;
568 }
569 
570 void Scope::clearPendingUpdate()
571 {
572     m_pendingUpdateTimer.stop();
573     m_pendingUpdate = { };
574 }
575 
576 void Scope::scheduleUpdate(UpdateType update)
577 {
578     if (update == UpdateType::ContentsOrInterpretation) {
579         // :host and ::slotted rules might go away.
580         if (m_shadowRoot)
581             Invalidator::invalidateHostAndSlottedStyleIfNeeded(*m_shadowRoot);
582         // FIXME: Animation code may trigger resource load in middle of style recalc and that can add a rule to a content extension stylesheet.
583         //        Fix and remove isResolvingTreeStyle() test below, see https://bugs.webkit.org/show_bug.cgi?id=194335
584         // FIXME: The m_isUpdatingStyleResolver test is here because extension stylesheets can get us here from Resolver::appendAuthorStyleSheets.
585         if (!m_isUpdatingStyleResolver &amp;&amp; !m_document.isResolvingTreeStyle())
586             clearResolver();
587     }
588 
589     if (!m_pendingUpdate || *m_pendingUpdate &lt; update) {
590         m_pendingUpdate = update;
591         if (m_shadowRoot)
592             m_document.styleScope().m_hasDescendantWithPendingUpdate = true;
593     }
594 
595     if (m_pendingUpdateTimer.isActive())
596         return;
597     m_pendingUpdateTimer.startOneShot(0_s);
598 }
599 
600 void Scope::evaluateMediaQueriesForViewportChange()
601 {
602     evaluateMediaQueries([] (Resolver&amp; resolver) {
603         return resolver.evaluateDynamicMediaQueries();
604     });
605 }
606 
607 void Scope::evaluateMediaQueriesForAccessibilitySettingsChange()
608 {
609     evaluateMediaQueries([] (Resolver&amp; resolver) {
610         return resolver.evaluateDynamicMediaQueries();
611     });
612 }
613 
614 void Scope::evaluateMediaQueriesForAppearanceChange()
615 {
616     evaluateMediaQueries([] (Resolver&amp; resolver) {
617         return resolver.evaluateDynamicMediaQueries();
618     });
619 }
620 
621 template &lt;typename TestFunction&gt;
622 void Scope::evaluateMediaQueries(TestFunction&amp;&amp; testFunction)
623 {
624     auto* resolver = resolverIfExists();
625     if (!resolver)
626         return;
627 
628     auto evaluationChanges = testFunction(*resolver);
629     if (evaluationChanges) {
630         switch (evaluationChanges-&gt;type) {
631         case DynamicMediaQueryEvaluationChanges::Type::InvalidateStyle: {
632             Invalidator invalidator(evaluationChanges-&gt;invalidationRuleSets);
633             invalidator.invalidateStyle(*this);
634             break;
635         }
636         case DynamicMediaQueryEvaluationChanges::Type::ResetStyle:
637             scheduleUpdate(UpdateType::ContentsOrInterpretation);
638             break;
639         }
640 
641         InspectorInstrumentation::mediaQueryResultChanged(m_document);
642     }
643 
644     if (!m_shadowRoot) {
645         for (auto* descendantShadowRoot : m_document.inDocumentShadowRoots())
646             descendantShadowRoot-&gt;styleScope().evaluateMediaQueries(testFunction);
647     }
648 }
649 
650 void Scope::didChangeActiveStyleSheetCandidates()
651 {
652     scheduleUpdate(UpdateType::ActiveSet);
653 }
654 
655 void Scope::didChangeStyleSheetContents()
656 {
657     scheduleUpdate(UpdateType::ContentsOrInterpretation);
658 }
659 
660 void Scope::didChangeStyleSheetEnvironment()
661 {
662     if (!m_shadowRoot) {
663         for (auto* descendantShadowRoot : m_document.inDocumentShadowRoots()) {
664             // Stylesheets is author shadow roots are potentially affected.
665             if (descendantShadowRoot-&gt;mode() != ShadowRootMode::UserAgent)
666                 descendantShadowRoot-&gt;styleScope().scheduleUpdate(UpdateType::ContentsOrInterpretation);
667         }
668     }
669     scheduleUpdate(UpdateType::ContentsOrInterpretation);
670 }
671 
672 void Scope::invalidateMatchedDeclarationsCache()
673 {
674     if (!m_shadowRoot) {
675         for (auto* descendantShadowRoot : m_document.inDocumentShadowRoots())
676             descendantShadowRoot-&gt;styleScope().invalidateMatchedDeclarationsCache();
677     }
678 
679     if (auto* resolver = resolverIfExists())
680         resolver-&gt;invalidateMatchedDeclarationsCache();
681 }
682 
683 
684 void Scope::pendingUpdateTimerFired()
685 {
686     flushPendingUpdate();
687 }
688 
689 const Vector&lt;RefPtr&lt;StyleSheet&gt;&gt;&amp; Scope::styleSheetsForStyleSheetList()
690 {
691     // FIXME: StyleSheetList content should be updated separately from style resolver updates.
692     flushPendingUpdate();
693     return m_styleSheetsForStyleSheetList;
694 }
695 
696 }
697 }
    </pre>
  </body>
</html>
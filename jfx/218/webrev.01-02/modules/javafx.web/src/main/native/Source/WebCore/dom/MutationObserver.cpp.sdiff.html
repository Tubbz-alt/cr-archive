<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/MutationObserver.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MutationEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MutationObserver.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/MutationObserver.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 
 34 #include &quot;MutationObserver.h&quot;
 35 
 36 #include &quot;Document.h&quot;
 37 #include &quot;GCReachableRef.h&quot;
 38 #include &quot;HTMLSlotElement.h&quot;
 39 #include &quot;InspectorInstrumentation.h&quot;
<span class="line-removed"> 40 #include &quot;Microtasks.h&quot;</span>
 41 #include &quot;MutationCallback.h&quot;
 42 #include &quot;MutationObserverRegistration.h&quot;
 43 #include &quot;MutationRecord.h&quot;

 44 #include &lt;algorithm&gt;
 45 #include &lt;wtf/IsoMallocInlines.h&gt;
 46 #include &lt;wtf/MainThread.h&gt;
 47 #include &lt;wtf/NeverDestroyed.h&gt;
 48 
 49 namespace WebCore {
 50 
 51 WTF_MAKE_ISO_ALLOCATED_IMPL(MutationObserver);
 52 
 53 static unsigned s_observerPriority = 0;
 54 
 55 Ref&lt;MutationObserver&gt; MutationObserver::create(Ref&lt;MutationCallback&gt;&amp;&amp; callback)
 56 {
 57     ASSERT(isMainThread());
 58     return adoptRef(*new MutationObserver(WTFMove(callback)));
 59 }
 60 
 61 MutationObserver::MutationObserver(Ref&lt;MutationCallback&gt;&amp;&amp; callback)
 62     : m_callback(WTFMove(callback))
 63     , m_priority(s_observerPriority++)
</pre>
<hr />
<pre>
120 {
121     m_pendingTargets.clear();
122     m_records.clear();
123     HashSet&lt;MutationObserverRegistration*&gt; registrations(m_registrations);
124     for (auto* registration : registrations)
125         registration-&gt;node().unregisterMutationObserver(*registration);
126 }
127 
128 void MutationObserver::observationStarted(MutationObserverRegistration&amp; registration)
129 {
130     ASSERT(!m_registrations.contains(&amp;registration));
131     m_registrations.add(&amp;registration);
132 }
133 
134 void MutationObserver::observationEnded(MutationObserverRegistration&amp; registration)
135 {
136     ASSERT(m_registrations.contains(&amp;registration));
137     m_registrations.remove(&amp;registration);
138 }
139 
<span class="line-removed">140 typedef HashSet&lt;RefPtr&lt;MutationObserver&gt;&gt; MutationObserverSet;</span>
<span class="line-removed">141 </span>
<span class="line-removed">142 static MutationObserverSet&amp; activeMutationObservers()</span>
<span class="line-removed">143 {</span>
<span class="line-removed">144     static NeverDestroyed&lt;MutationObserverSet&gt; activeObservers;</span>
<span class="line-removed">145     return activeObservers;</span>
<span class="line-removed">146 }</span>
<span class="line-removed">147 </span>
<span class="line-removed">148 static MutationObserverSet&amp; suspendedMutationObservers()</span>
<span class="line-removed">149 {</span>
<span class="line-removed">150     static NeverDestroyed&lt;MutationObserverSet&gt; suspendedObservers;</span>
<span class="line-removed">151     return suspendedObservers;</span>
<span class="line-removed">152 }</span>
<span class="line-removed">153 </span>
<span class="line-removed">154 // https://dom.spec.whatwg.org/#signal-slot-list</span>
<span class="line-removed">155 static Vector&lt;GCReachableRef&lt;HTMLSlotElement&gt;&gt;&amp; signalSlotList()</span>
<span class="line-removed">156 {</span>
<span class="line-removed">157     static NeverDestroyed&lt;Vector&lt;GCReachableRef&lt;HTMLSlotElement&gt;&gt;&gt; list;</span>
<span class="line-removed">158     return list;</span>
<span class="line-removed">159 }</span>
<span class="line-removed">160 </span>
<span class="line-removed">161 static bool mutationObserverCompoundMicrotaskQueuedFlag;</span>
<span class="line-removed">162 </span>
<span class="line-removed">163 class MutationObserverMicrotask final : public Microtask {</span>
<span class="line-removed">164     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-removed">165 private:</span>
<span class="line-removed">166     Result run() final</span>
<span class="line-removed">167     {</span>
<span class="line-removed">168         MutationObserver::notifyMutationObservers();</span>
<span class="line-removed">169         return Result::Done;</span>
<span class="line-removed">170     }</span>
<span class="line-removed">171 };</span>
<span class="line-removed">172 </span>
<span class="line-removed">173 static void queueMutationObserverCompoundMicrotask()</span>
<span class="line-removed">174 {</span>
<span class="line-removed">175     if (mutationObserverCompoundMicrotaskQueuedFlag)</span>
<span class="line-removed">176         return;</span>
<span class="line-removed">177     mutationObserverCompoundMicrotaskQueuedFlag = true;</span>
<span class="line-removed">178     MicrotaskQueue::mainThreadQueue().append(makeUnique&lt;MutationObserverMicrotask&gt;());</span>
<span class="line-removed">179 }</span>
<span class="line-removed">180 </span>
181 void MutationObserver::enqueueMutationRecord(Ref&lt;MutationRecord&gt;&amp;&amp; mutation)
182 {
183     ASSERT(isMainThread());
184     ASSERT(mutation-&gt;target());


185     m_pendingTargets.add(*mutation-&gt;target());
186     m_records.append(WTFMove(mutation));
<span class="line-removed">187     activeMutationObservers().add(this);</span>
188 
<span class="line-modified">189     queueMutationObserverCompoundMicrotask();</span>


190 }
191 
192 void MutationObserver::enqueueSlotChangeEvent(HTMLSlotElement&amp; slot)
193 {
194     ASSERT(isMainThread());
<span class="line-modified">195     ASSERT(signalSlotList().findMatching([&amp;slot](auto&amp; entry) { return entry.ptr() == &amp;slot; }) == notFound);</span>
<span class="line-modified">196     signalSlotList().append(slot);</span>


197 
<span class="line-modified">198     queueMutationObserverCompoundMicrotask();</span>
199 }
200 
<span class="line-modified">201 void MutationObserver::setHasTransientRegistration()</span>
202 {
<span class="line-modified">203     ASSERT(isMainThread());</span>
<span class="line-modified">204     activeMutationObservers().add(this);</span>
<span class="line-modified">205 </span>
<span class="line-removed">206     queueMutationObserverCompoundMicrotask();</span>
207 }
208 
209 HashSet&lt;Node*&gt; MutationObserver::observedNodes() const
210 {
211     HashSet&lt;Node*&gt; observedNodes;
212     for (auto* registration : m_registrations)
213         registration-&gt;addRegistrationNodesToSet(observedNodes);
214     return observedNodes;
215 }
216 
217 bool MutationObserver::canDeliver()
218 {
219     return m_callback-&gt;canInvokeCallback();
220 }
221 
222 void MutationObserver::deliver()
223 {
224     ASSERT(canDeliver());
225 
226     // Calling takeTransientRegistrations() can modify m_registrations, so it&#39;s necessary
</pre>
<hr />
<pre>
233         if (registration-&gt;hasTransientRegistrations())
234             transientRegistrations.append(registration);
235     }
236     for (auto&amp; registration : transientRegistrations)
237         nodesToKeepAlive.append(registration-&gt;takeTransientRegistrations());
238 
239     if (m_records.isEmpty()) {
240         ASSERT(m_pendingTargets.isEmpty());
241         return;
242     }
243 
244     Vector&lt;Ref&lt;MutationRecord&gt;&gt; records;
245     records.swap(m_records);
246 
247     // FIXME: Keep mutation observer callback as long as its observed nodes are alive. See https://webkit.org/b/179224.
248     if (m_callback-&gt;hasCallback()) {
249         auto* context = m_callback-&gt;scriptExecutionContext();
250         if (!context)
251             return;
252 
<span class="line-modified">253         InspectorInstrumentationCookie cookie = InspectorInstrumentation::willFireObserverCallback(*context, &quot;MutationObserver&quot;_s);</span>
254         m_callback-&gt;handleEvent(*this, records, *this);
<span class="line-modified">255         InspectorInstrumentation::didFireObserverCallback(cookie);</span>
256     }
257 }
258 
<span class="line-modified">259 void MutationObserver::notifyMutationObservers()</span>

260 {
<span class="line-modified">261     // https://dom.spec.whatwg.org/#notify-mutation-observers</span>
<span class="line-modified">262     // 1. Unset mutation observer compound microtask queued flag.</span>
<span class="line-removed">263     mutationObserverCompoundMicrotaskQueuedFlag = false;</span>
<span class="line-removed">264 </span>
<span class="line-removed">265     ASSERT(isMainThread());</span>
<span class="line-removed">266     static bool deliveryInProgress = false;</span>
<span class="line-removed">267     if (deliveryInProgress)</span>
<span class="line-removed">268         return;</span>
<span class="line-removed">269     deliveryInProgress = true;</span>
<span class="line-removed">270 </span>
<span class="line-removed">271     if (!suspendedMutationObservers().isEmpty()) {</span>
<span class="line-removed">272         for (auto&amp; observer : copyToVector(suspendedMutationObservers())) {</span>
273             if (!observer-&gt;canDeliver())
274                 continue;
275 
<span class="line-modified">276             suspendedMutationObservers().remove(observer);</span>
<span class="line-modified">277             activeMutationObservers().add(observer);</span>
278         }
279     }
280 
<span class="line-modified">281     while (!activeMutationObservers().isEmpty() || !signalSlotList().isEmpty()) {</span>
282         // 2. Let notify list be a copy of unit of related similar-origin browsing contexts&#39; list of MutationObserver objects.
<span class="line-modified">283         auto notifyList = copyToVector(activeMutationObservers());</span>
<span class="line-modified">284         activeMutationObservers().clear();</span>
285         std::sort(notifyList.begin(), notifyList.end(), [](auto&amp; lhs, auto&amp; rhs) {
286             return lhs-&gt;m_priority &lt; rhs-&gt;m_priority;
287         });
288 
289         // 3. Let signalList be a copy of unit of related similar-origin browsing contexts&#39; signal slot list.
290         // 4. Empty unit of related similar-origin browsing contexts&#39; signal slot list.
291         Vector&lt;GCReachableRef&lt;HTMLSlotElement&gt;&gt; slotList;
<span class="line-modified">292         if (!signalSlotList().isEmpty()) {</span>
<span class="line-modified">293             slotList.swap(signalSlotList());</span>
294             for (auto&amp; slot : slotList)
295                 slot-&gt;didRemoveFromSignalSlotList();
296         }
297 
298         // 5. For each MutationObserver object mo in notify list, execute a compound microtask subtask
299         for (auto&amp; observer : notifyList) {
300             if (observer-&gt;canDeliver())
301                 observer-&gt;deliver();
302             else
<span class="line-modified">303                 suspendedMutationObservers().add(observer);</span>
304         }
305 
306         // 6. For each slot slot in signalList, in order, fire an event named slotchange, with its bubbles attribute set to true, at slot.
307         for (auto&amp; slot : slotList)
308             slot-&gt;dispatchSlotChangeEvent();
309     }
<span class="line-removed">310 </span>
<span class="line-removed">311     deliveryInProgress = false;</span>
312 }
313 
314 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 
 34 #include &quot;MutationObserver.h&quot;
 35 
 36 #include &quot;Document.h&quot;
 37 #include &quot;GCReachableRef.h&quot;
 38 #include &quot;HTMLSlotElement.h&quot;
 39 #include &quot;InspectorInstrumentation.h&quot;

 40 #include &quot;MutationCallback.h&quot;
 41 #include &quot;MutationObserverRegistration.h&quot;
 42 #include &quot;MutationRecord.h&quot;
<span class="line-added"> 43 #include &quot;WindowEventLoop.h&quot;</span>
 44 #include &lt;algorithm&gt;
 45 #include &lt;wtf/IsoMallocInlines.h&gt;
 46 #include &lt;wtf/MainThread.h&gt;
 47 #include &lt;wtf/NeverDestroyed.h&gt;
 48 
 49 namespace WebCore {
 50 
 51 WTF_MAKE_ISO_ALLOCATED_IMPL(MutationObserver);
 52 
 53 static unsigned s_observerPriority = 0;
 54 
 55 Ref&lt;MutationObserver&gt; MutationObserver::create(Ref&lt;MutationCallback&gt;&amp;&amp; callback)
 56 {
 57     ASSERT(isMainThread());
 58     return adoptRef(*new MutationObserver(WTFMove(callback)));
 59 }
 60 
 61 MutationObserver::MutationObserver(Ref&lt;MutationCallback&gt;&amp;&amp; callback)
 62     : m_callback(WTFMove(callback))
 63     , m_priority(s_observerPriority++)
</pre>
<hr />
<pre>
120 {
121     m_pendingTargets.clear();
122     m_records.clear();
123     HashSet&lt;MutationObserverRegistration*&gt; registrations(m_registrations);
124     for (auto* registration : registrations)
125         registration-&gt;node().unregisterMutationObserver(*registration);
126 }
127 
128 void MutationObserver::observationStarted(MutationObserverRegistration&amp; registration)
129 {
130     ASSERT(!m_registrations.contains(&amp;registration));
131     m_registrations.add(&amp;registration);
132 }
133 
134 void MutationObserver::observationEnded(MutationObserverRegistration&amp; registration)
135 {
136     ASSERT(m_registrations.contains(&amp;registration));
137     m_registrations.remove(&amp;registration);
138 }
139 









































140 void MutationObserver::enqueueMutationRecord(Ref&lt;MutationRecord&gt;&amp;&amp; mutation)
141 {
142     ASSERT(isMainThread());
143     ASSERT(mutation-&gt;target());
<span class="line-added">144     auto document = makeRef(mutation-&gt;target()-&gt;document());</span>
<span class="line-added">145 </span>
146     m_pendingTargets.add(*mutation-&gt;target());
147     m_records.append(WTFMove(mutation));

148 
<span class="line-modified">149     auto eventLoop = makeRef(document-&gt;windowEventLoop());</span>
<span class="line-added">150     eventLoop-&gt;activeMutationObservers().add(this);</span>
<span class="line-added">151     eventLoop-&gt;queueMutationObserverCompoundMicrotask();</span>
152 }
153 
154 void MutationObserver::enqueueSlotChangeEvent(HTMLSlotElement&amp; slot)
155 {
156     ASSERT(isMainThread());
<span class="line-modified">157     auto eventLoop = makeRef(slot.document().windowEventLoop());</span>
<span class="line-modified">158     auto&amp; list = eventLoop-&gt;signalSlotList();</span>
<span class="line-added">159     ASSERT(list.findMatching([&amp;slot](auto&amp; entry) { return entry.ptr() == &amp;slot; }) == notFound);</span>
<span class="line-added">160     list.append(slot);</span>
161 
<span class="line-modified">162     eventLoop-&gt;queueMutationObserverCompoundMicrotask();</span>
163 }
164 
<span class="line-modified">165 void MutationObserver::setHasTransientRegistration(Document&amp; document)</span>
166 {
<span class="line-modified">167     auto eventLoop = makeRef(document.windowEventLoop());</span>
<span class="line-modified">168     eventLoop-&gt;activeMutationObservers().add(this);</span>
<span class="line-modified">169     eventLoop-&gt;queueMutationObserverCompoundMicrotask();</span>

170 }
171 
172 HashSet&lt;Node*&gt; MutationObserver::observedNodes() const
173 {
174     HashSet&lt;Node*&gt; observedNodes;
175     for (auto* registration : m_registrations)
176         registration-&gt;addRegistrationNodesToSet(observedNodes);
177     return observedNodes;
178 }
179 
180 bool MutationObserver::canDeliver()
181 {
182     return m_callback-&gt;canInvokeCallback();
183 }
184 
185 void MutationObserver::deliver()
186 {
187     ASSERT(canDeliver());
188 
189     // Calling takeTransientRegistrations() can modify m_registrations, so it&#39;s necessary
</pre>
<hr />
<pre>
196         if (registration-&gt;hasTransientRegistrations())
197             transientRegistrations.append(registration);
198     }
199     for (auto&amp; registration : transientRegistrations)
200         nodesToKeepAlive.append(registration-&gt;takeTransientRegistrations());
201 
202     if (m_records.isEmpty()) {
203         ASSERT(m_pendingTargets.isEmpty());
204         return;
205     }
206 
207     Vector&lt;Ref&lt;MutationRecord&gt;&gt; records;
208     records.swap(m_records);
209 
210     // FIXME: Keep mutation observer callback as long as its observed nodes are alive. See https://webkit.org/b/179224.
211     if (m_callback-&gt;hasCallback()) {
212         auto* context = m_callback-&gt;scriptExecutionContext();
213         if (!context)
214             return;
215 
<span class="line-modified">216         InspectorInstrumentation::willFireObserverCallback(*context, &quot;MutationObserver&quot;_s);</span>
217         m_callback-&gt;handleEvent(*this, records, *this);
<span class="line-modified">218         InspectorInstrumentation::didFireObserverCallback(*context);</span>
219     }
220 }
221 
<span class="line-modified">222 // https://dom.spec.whatwg.org/#notify-mutation-observers</span>
<span class="line-added">223 void MutationObserver::notifyMutationObservers(WindowEventLoop&amp; eventLoop)</span>
224 {
<span class="line-modified">225     if (!eventLoop.suspendedMutationObservers().isEmpty()) {</span>
<span class="line-modified">226         for (auto&amp; observer : copyToVector(eventLoop.suspendedMutationObservers())) {</span>










227             if (!observer-&gt;canDeliver())
228                 continue;
229 
<span class="line-modified">230             eventLoop.suspendedMutationObservers().remove(observer);</span>
<span class="line-modified">231             eventLoop.activeMutationObservers().add(observer);</span>
232         }
233     }
234 
<span class="line-modified">235     while (!eventLoop.activeMutationObservers().isEmpty() || !eventLoop.signalSlotList().isEmpty()) {</span>
236         // 2. Let notify list be a copy of unit of related similar-origin browsing contexts&#39; list of MutationObserver objects.
<span class="line-modified">237         auto notifyList = copyToVector(eventLoop.activeMutationObservers());</span>
<span class="line-modified">238         eventLoop.activeMutationObservers().clear();</span>
239         std::sort(notifyList.begin(), notifyList.end(), [](auto&amp; lhs, auto&amp; rhs) {
240             return lhs-&gt;m_priority &lt; rhs-&gt;m_priority;
241         });
242 
243         // 3. Let signalList be a copy of unit of related similar-origin browsing contexts&#39; signal slot list.
244         // 4. Empty unit of related similar-origin browsing contexts&#39; signal slot list.
245         Vector&lt;GCReachableRef&lt;HTMLSlotElement&gt;&gt; slotList;
<span class="line-modified">246         if (!eventLoop.signalSlotList().isEmpty()) {</span>
<span class="line-modified">247             slotList.swap(eventLoop.signalSlotList());</span>
248             for (auto&amp; slot : slotList)
249                 slot-&gt;didRemoveFromSignalSlotList();
250         }
251 
252         // 5. For each MutationObserver object mo in notify list, execute a compound microtask subtask
253         for (auto&amp; observer : notifyList) {
254             if (observer-&gt;canDeliver())
255                 observer-&gt;deliver();
256             else
<span class="line-modified">257                 eventLoop.suspendedMutationObservers().add(observer);</span>
258         }
259 
260         // 6. For each slot slot in signalList, in order, fire an event named slotchange, with its bubbles attribute set to true, at slot.
261         for (auto&amp; slot : slotList)
262             slot-&gt;dispatchSlotChangeEvent();
263     }


264 }
265 
266 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="MutationEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MutationObserver.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/layout/FormattingContext.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 29 
 30 #include &quot;LayoutContainer.h&quot;
 31 #include &quot;LayoutUnit.h&quot;
 32 #include &quot;LayoutUnits.h&quot;
 33 #include &lt;wtf/IsoMalloc.h&gt;
 34 #include &lt;wtf/WeakPtr.h&gt;
 35 
 36 namespace WebCore {
 37 
 38 namespace Display {
 39 class Box;
 40 }
 41 class LayoutSize;
 42 struct Length;
 43 
 44 namespace Layout {
 45 
 46 class Box;
 47 struct ComputedHorizontalMargin;
 48 struct ComputedVerticalMargin;
 49 class Container;
 50 struct ContentHeightAndMargin;
 51 struct ContentWidthAndMargin;
 52 struct Edges;
 53 class FormattingState;
 54 struct HorizontalGeometry;
 55 class InvalidationState;
 56 class LayoutState;
 57 struct OverrideHorizontalValues;
 58 struct OverrideVerticalValues;
 59 struct VerticalGeometry;
 60 
 61 class FormattingContext {
 62     WTF_MAKE_ISO_ALLOCATED(FormattingContext);
 63 public:
 64     FormattingContext(const Container&amp; formattingContextRoot, FormattingState&amp;);
 65     virtual ~FormattingContext();
 66 
 67     virtual void layoutInFlowContent(InvalidationState&amp;, const HorizontalConstraints&amp;, const VerticalConstraints&amp;) = 0;
 68     void layoutOutOfFlowContent(InvalidationState&amp;, const HorizontalConstraints&amp;, const VerticalConstraints&amp;);
 69 
 70     struct IntrinsicWidthConstraints {
 71         void expand(LayoutUnit horizontalValue);
 72         IntrinsicWidthConstraints&amp; operator+=(const IntrinsicWidthConstraints&amp;);
 73 
 74         LayoutUnit minimum;
 75         LayoutUnit maximum;
 76     };
 77     virtual IntrinsicWidthConstraints computedIntrinsicWidthConstraints() = 0;
 78 
 79     LayoutUnit mapTopToFormattingContextRoot(const Box&amp;) const;
 80     LayoutUnit mapLeftToFormattingContextRoot(const Box&amp;) const;
 81     LayoutUnit mapRightToFormattingContextRoot(const Box&amp;) const;
 82 
 83     bool isBlockFormattingContext() const { return root().establishesBlockFormattingContext(); }
 84     bool isInlineFormattingContext() const { return root().establishesInlineFormattingContext(); }
 85     bool isTableFormattingContext() const { return root().establishesTableFormattingContext(); }
 86 
 87     enum class EscapeReason {
 88         NeedsGeometryFromEstablishedFormattingContext,
 89         OutOfFlowBoxNeedsInFlowGeometry,
 90         FloatBoxNeedsToBeInAbsoluteCoordinates,
 91         FindFixedHeightAncestorQuirk,
 92         BodyStrechesToViewportQuirk,
 93         StrokeOverflowNeedsViewportGeometry,
 94         TableNeedsAccessToTableWrapper
 95     };
 96     const Display::Box&amp; geometryForBox(const Box&amp;, Optional&lt;EscapeReason&gt; = WTF::nullopt) const;
 97 
 98 protected:
 99     using LayoutQueue = Vector&lt;const Box*&gt;;
100 
101     const Container&amp; root() const { return *m_root; }
102     LayoutState&amp; layoutState() const;
103     const FormattingState&amp; formattingState() const { return m_formattingState; }
104     FormattingState&amp; formattingState() { return m_formattingState; }
105 
106     void computeBorderAndPadding(const Box&amp;, const HorizontalConstraints&amp;);
107 
108 #ifndef NDEBUG
109     virtual void validateGeometryConstraintsAfterLayout() const;
110 #endif
111 
112     // This class implements generic positioning and sizing.
113     class Geometry {
114     public:
115         VerticalGeometry outOfFlowVerticalGeometry(const Box&amp;, const HorizontalConstraints&amp;, const VerticalConstraints&amp;, const OverrideVerticalValues&amp;) const;
116         HorizontalGeometry outOfFlowHorizontalGeometry(const Box&amp;, const HorizontalConstraints&amp;, const OverrideHorizontalValues&amp;);
117 
118         ContentHeightAndMargin floatingHeightAndMargin(const Box&amp;, const HorizontalConstraints&amp;, const OverrideVerticalValues&amp;) const;
119         ContentWidthAndMargin floatingWidthAndMargin(const Box&amp;, const HorizontalConstraints&amp;, const OverrideHorizontalValues&amp;);
120 
121         ContentHeightAndMargin inlineReplacedHeightAndMargin(const Box&amp;, const HorizontalConstraints&amp;, Optional&lt;VerticalConstraints&gt;, const OverrideVerticalValues&amp;) const;
122         ContentWidthAndMargin inlineReplacedWidthAndMargin(const Box&amp;, const HorizontalConstraints&amp;, const OverrideHorizontalValues&amp;) const;
123 
124         LayoutSize inFlowPositionedPositionOffset(const Box&amp;, const HorizontalConstraints&amp;) const;
125 
126         ContentHeightAndMargin complicatedCases(const Box&amp;, const HorizontalConstraints&amp;, const OverrideVerticalValues&amp;) const;
127         LayoutUnit shrinkToFitWidth(const Box&amp;, LayoutUnit availableWidth);
128 
129         Edges computedBorder(const Box&amp;) const;
130         Optional&lt;Edges&gt; computedPadding(const Box&amp;, const HorizontalConstraints&amp;) const;
131 
132         ComputedHorizontalMargin computedHorizontalMargin(const Box&amp;, const HorizontalConstraints&amp;) const;
133         ComputedVerticalMargin computedVerticalMargin(const Box&amp;, const HorizontalConstraints&amp;) const;
134 
135         Optional&lt;LayoutUnit&gt; computedValueIfNotAuto(const Length&amp; geometryProperty, LayoutUnit containingBlockWidth) const;
136         Optional&lt;LayoutUnit&gt; fixedValue(const Length&amp; geometryProperty) const;
137 
138         Optional&lt;LayoutUnit&gt; computedMinHeight(const Box&amp;, Optional&lt;LayoutUnit&gt; containingBlockHeight = WTF::nullopt) const;
139         Optional&lt;LayoutUnit&gt; computedMaxHeight(const Box&amp;, Optional&lt;LayoutUnit&gt; containingBlockHeight = WTF::nullopt) const;
140 
141         Optional&lt;LayoutUnit&gt; computedMinWidth(const Box&amp;, LayoutUnit containingBlockWidth) const;
142         Optional&lt;LayoutUnit&gt; computedMaxWidth(const Box&amp;, LayoutUnit containingBlockWidth) const;
143 
144         FormattingContext::IntrinsicWidthConstraints constrainByMinMaxWidth(const Box&amp;, IntrinsicWidthConstraints) const;
145 
146         LayoutUnit contentHeightForFormattingContextRoot(const Box&amp;) const;
147 
148         static HorizontalConstraints horizontalConstraintsForOutOfFlow(const Display::Box&amp; containingBlockGeometry);
149         static VerticalConstraints verticalConstraintsForOutOfFlow(const Display::Box&amp; containingBlockGeometry);
150         static HorizontalConstraints horizontalConstraintsForInFlow(const Display::Box&amp; containingBlockGeometry);
151         static VerticalConstraints verticalConstraintsForInFlow(const Display::Box&amp; containingBlockGeometry);
152 
153     protected:
154         friend class FormattingContext;
155         Geometry(const FormattingContext&amp;);
156 
157         enum class HeightType { Min, Max, Normal };
158         Optional&lt;LayoutUnit&gt; computedHeightValue(const Box&amp;, HeightType, Optional&lt;LayoutUnit&gt; containingBlockHeight) const;
159         Optional&lt;LayoutUnit&gt; computedContentHeight(const Box&amp;, Optional&lt;LayoutUnit&gt; containingBlockHeight = WTF::nullopt) const;
160         Optional&lt;LayoutUnit&gt; computedContentWidth(const Box&amp;, LayoutUnit containingBlockWidth) const;
161 
162         const LayoutState&amp; layoutState() const { return m_formattingContext.layoutState(); }
163         LayoutState&amp; layoutState() { return m_formattingContext.layoutState(); }
164         const FormattingContext&amp; formattingContext() const { return m_formattingContext; }
165 
166     private:
167         VerticalGeometry outOfFlowReplacedVerticalGeometry(const Box&amp;, const HorizontalConstraints&amp;, const VerticalConstraints&amp;, const OverrideVerticalValues&amp;) const;
168         HorizontalGeometry outOfFlowReplacedHorizontalGeometry(const Box&amp;, const HorizontalConstraints&amp;, const OverrideHorizontalValues&amp;) const;
169 
170         VerticalGeometry outOfFlowNonReplacedVerticalGeometry(const Box&amp;, const HorizontalConstraints&amp;, const VerticalConstraints&amp;, const OverrideVerticalValues&amp;) const;
171         HorizontalGeometry outOfFlowNonReplacedHorizontalGeometry(const Box&amp;, const HorizontalConstraints&amp;, const OverrideHorizontalValues&amp;);
172 
173         ContentHeightAndMargin floatingReplacedHeightAndMargin(const Box&amp;, const HorizontalConstraints&amp;, const OverrideVerticalValues&amp;) const;
174         ContentWidthAndMargin floatingReplacedWidthAndMargin(const Box&amp;, const HorizontalConstraints&amp;, const OverrideHorizontalValues&amp;) const;
175 
176         ContentWidthAndMargin floatingNonReplacedWidthAndMargin(const Box&amp;, const HorizontalConstraints&amp;, const OverrideHorizontalValues&amp;);
177 
178         LayoutUnit staticVerticalPositionForOutOfFlowPositioned(const Box&amp;, const VerticalConstraints&amp;) const;
179         LayoutUnit staticHorizontalPositionForOutOfFlowPositioned(const Box&amp;, const HorizontalConstraints&amp;) const;
180 
181         const FormattingContext&amp; m_formattingContext;
182     };
183     FormattingContext::Geometry geometry() const { return Geometry(*this); }
184 
185     class Quirks {
186     public:
187         LayoutUnit heightValueOfNearestContainingBlockWithFixedHeight(const Box&amp;);
188 
189     protected:
190         friend class FormattingContext;
191         Quirks(const FormattingContext&amp;);
192 
193         const LayoutState&amp; layoutState() const { return m_formattingContext.layoutState(); }
194         LayoutState&amp; layoutState() { return m_formattingContext.layoutState(); }
195         const FormattingContext&amp; formattingContext() const { return m_formattingContext; }
196 
197         const FormattingContext&amp; m_formattingContext;
198     };
199     FormattingContext::Quirks quirks() const { return Quirks(*this); }
200 
201 private:
202     void collectOutOfFlowDescendantsIfNeeded();
203     void computeOutOfFlowVerticalGeometry(const Box&amp;, const HorizontalConstraints&amp;, const VerticalConstraints&amp;);
204     void computeOutOfFlowHorizontalGeometry(const Box&amp;, const HorizontalConstraints&amp;);
205 
206     WeakPtr&lt;const Container&gt; m_root;
207     FormattingState&amp; m_formattingState;
208 };
209 
210 inline FormattingContext::Geometry::Geometry(const FormattingContext&amp; formattingContext)
211     : m_formattingContext(formattingContext)
212 {
213 }
214 
215 inline FormattingContext::Quirks::Quirks(const FormattingContext&amp; formattingContext)
216     : m_formattingContext(formattingContext)
217 {
218 }
219 
220 inline void FormattingContext::IntrinsicWidthConstraints::expand(LayoutUnit horizontalValue)
221 {
222     minimum += horizontalValue;
223     maximum += horizontalValue;
224 }
225 
226 inline FormattingContext::IntrinsicWidthConstraints&amp; FormattingContext::IntrinsicWidthConstraints::operator+=(const IntrinsicWidthConstraints&amp; other)
227 {
228     minimum += other.minimum;
229     maximum += other.maximum;
230     return *this;
231 }
232 
233 }
234 }
235 
236 #define SPECIALIZE_TYPE_TRAITS_LAYOUT_FORMATTING_CONTEXT(ToValueTypeName, predicate) \
237 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::Layout::ToValueTypeName) \
238     static bool isType(const WebCore::Layout::FormattingContext&amp; formattingContext) { return formattingContext.predicate; } \
239 SPECIALIZE_TYPE_TRAITS_END()
240 
241 #endif
    </pre>
  </body>
</html>
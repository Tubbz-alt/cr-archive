<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/SyntaxChecker.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SourceProviderCacheItem.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VariableEnvironment.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/SyntaxChecker.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 138,15 ***</span>
      typedef int DestructuringPattern;
      typedef DestructuringPattern ArrayPattern;
      typedef DestructuringPattern ObjectPattern;
      typedef DestructuringPattern RestPattern;
  
<span class="line-modified">!     static const bool CreatesAST = false;</span>
<span class="line-modified">!     static const bool NeedsFreeVariableInfo = false;</span>
<span class="line-modified">!     static const bool CanUseFunctionCache = true;</span>
<span class="line-modified">!     static const unsigned DontBuildKeywords = LexexFlagsDontBuildKeywords;</span>
<span class="line-modified">!     static const unsigned DontBuildStrings = LexerFlagsDontBuildStrings;</span>
  
      int createSourceElements() { return SourceElementsResult; }
      ExpressionType makeFunctionCallNode(const JSTokenLocation&amp;, ExpressionType, bool, int, int, int, int, size_t, bool) { return CallExpr; }
      ExpressionType createCommaExpr(const JSTokenLocation&amp;, ExpressionType expr) { return expr; }
      ExpressionType appendToCommaExpr(const JSTokenLocation&amp;, ExpressionType&amp; head, ExpressionType, ExpressionType next) { head = next; return next; }
<span class="line-new-header">--- 138,15 ---</span>
      typedef int DestructuringPattern;
      typedef DestructuringPattern ArrayPattern;
      typedef DestructuringPattern ObjectPattern;
      typedef DestructuringPattern RestPattern;
  
<span class="line-modified">!     static constexpr bool CreatesAST = false;</span>
<span class="line-modified">!     static constexpr bool NeedsFreeVariableInfo = false;</span>
<span class="line-modified">!     static constexpr bool CanUseFunctionCache = true;</span>
<span class="line-modified">!     static constexpr OptionSet&lt;LexerFlags&gt; DontBuildKeywords = LexerFlags::DontBuildKeywords;</span>
<span class="line-modified">!     static constexpr OptionSet&lt;LexerFlags&gt; DontBuildStrings = LexerFlags::DontBuildStrings;</span>
  
      int createSourceElements() { return SourceElementsResult; }
      ExpressionType makeFunctionCallNode(const JSTokenLocation&amp;, ExpressionType, bool, int, int, int, int, size_t, bool) { return CallExpr; }
      ExpressionType createCommaExpr(const JSTokenLocation&amp;, ExpressionType expr) { return expr; }
      ExpressionType appendToCommaExpr(const JSTokenLocation&amp;, ExpressionType&amp; head, ExpressionType, ExpressionType next) { head = next; return next; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 234,10 ***</span>
<span class="line-new-header">--- 234,14 ---</span>
      }
      Property createProperty(int, int, PropertyNode::Type type, PropertyNode::PutType, bool, SuperBinding, ClassElementTag)
      {
          return Property(type);
      }
<span class="line-added">+     Property createProperty(const Identifier*, int, int, PropertyNode::Type type, PropertyNode::PutType, bool, SuperBinding, ClassElementTag)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         return Property(type);</span>
<span class="line-added">+     }</span>
      int createPropertyList(const JSTokenLocation&amp;, Property) { return PropertyListResult; }
      int createPropertyList(const JSTokenLocation&amp;, Property, int) { return PropertyListResult; }
      int createElementList(int, int) { return ElementsListResult; }
      int createElementList(int, int, int) { return ElementsListResult; }
      int createElementList(int) { return ElementsListResult; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 245,10 ***</span>
<span class="line-new-header">--- 249,11 ---</span>
      void appendParameter(int, DestructuringPattern, int) { }
      int createClause(int, int) { return ClauseResult; }
      int createClauseList(int) { return ClauseListResult; }
      int createClauseList(int, int) { return ClauseListResult; }
      int createFuncDeclStatement(const JSTokenLocation&amp;, const ParserFunctionInfo&lt;SyntaxChecker&gt;&amp;) { return StatementResult; }
<span class="line-added">+     int createDefineField(const JSTokenLocation&amp;, const Identifier*, int, DefineFieldNode::Type) { return 0; }</span>
      int createClassDeclStatement(const JSTokenLocation&amp;, ClassExpression,
          const JSTextPosition&amp;, const JSTextPosition&amp;, int, int) { return StatementResult; }
      int createBlockStatement(const JSTokenLocation&amp;, int, int, int, VariableEnvironment&amp;, DeclarationStacks::FunctionStack&amp;&amp;) { return StatementResult; }
      int createExprStatement(const JSTokenLocation&amp;, int, int, int) { return StatementResult; }
      int createIfStatement(const JSTokenLocation&amp;, int, int, int, int) { return StatementResult; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 327,13 ***</span>
  
      void appendUnaryToken(int&amp; stackDepth, int tok, int) { stackDepth = 1; m_topUnaryToken = tok; }
      int unaryTokenStackLastType(int&amp;) { return m_topUnaryToken; }
      JSTextPosition unaryTokenStackLastStart(int&amp;) { return JSTextPosition(0, 0, 0); }
      void unaryTokenStackRemoveLast(int&amp; stackDepth) { stackDepth = 0; }
  
<span class="line-modified">!     void assignmentStackAppend(int, int, int, int, int, Operator) { }</span>
<span class="line-modified">!     int createAssignment(const JSTokenLocation&amp;, int, int, int, int, int) { RELEASE_ASSERT_NOT_REACHED(); return AssignmentExpr; }</span>
      const Identifier* getName(const Property&amp; property) const { return property.name; }
      PropertyNode::Type getType(const Property&amp; property) const { return property.type; }
      bool isResolve(ExpressionType expr) const { return expr == ResolveExpr || expr == ResolveEvalExpr; }
      ExpressionType createDestructuringAssignment(const JSTokenLocation&amp;, int, ExpressionType)
      {
<span class="line-new-header">--- 332,15 ---</span>
  
      void appendUnaryToken(int&amp; stackDepth, int tok, int) { stackDepth = 1; m_topUnaryToken = tok; }
      int unaryTokenStackLastType(int&amp;) { return m_topUnaryToken; }
      JSTextPosition unaryTokenStackLastStart(int&amp;) { return JSTextPosition(0, 0, 0); }
      void unaryTokenStackRemoveLast(int&amp; stackDepth) { stackDepth = 0; }
<span class="line-added">+     int unaryTokenStackDepth() const { return 0; }</span>
<span class="line-added">+     void setUnaryTokenStackDepth(int) { }</span>
  
<span class="line-modified">!     void assignmentStackAppend(int&amp; assignmentStackDepth, int, int, int, int, Operator) { assignmentStackDepth = 1; }</span>
<span class="line-modified">!     int createAssignment(const JSTokenLocation&amp;, int&amp; assignmentStackDepth, int, int, int, int) { assignmentStackDepth = 0; return AssignmentExpr; }</span>
      const Identifier* getName(const Property&amp; property) const { return property.name; }
      PropertyNode::Type getType(const Property&amp; property) const { return property.type; }
      bool isResolve(ExpressionType expr) const { return expr == ResolveExpr || expr == ResolveEvalExpr; }
      ExpressionType createDestructuringAssignment(const JSTokenLocation&amp;, int, ExpressionType)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 428,11 ***</span>
  
      void setEndOffset(int, int) { }
      int endOffset(int) { return 0; }
      void setStartOffset(int, int) { }
  
<span class="line-modified">!     JSTextPosition breakpointLocation(int) { return JSTextPosition(-1, 0, 0); }</span>
  
      void propagateArgumentsUse() { }
  
  private:
      int m_topBinaryExpr;
<span class="line-new-header">--- 435,11 ---</span>
  
      void setEndOffset(int, int) { }
      int endOffset(int) { return 0; }
      void setStartOffset(int, int) { }
  
<span class="line-modified">!     JSTextPosition breakpointLocation(int) { return { }; }</span>
  
      void propagateArgumentsUse() { }
  
  private:
      int m_topBinaryExpr;
</pre>
<center><a href="SourceProviderCacheItem.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VariableEnvironment.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
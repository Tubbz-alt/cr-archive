<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/loader/cache/MemoryCache.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="KeepaliveRequestTracker.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MemoryCache.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/cache/MemoryCache.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 202,56 ***</span>
  {
      // Live resource capacity is whatever is left over after calculating dead resource capacity.
      return m_capacity - deadCapacity();
  }
  
<span class="line-removed">- static CachedImageClient&amp; dummyCachedImageClient()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     static NeverDestroyed&lt;CachedImageClient&gt; client;</span>
<span class="line-removed">-     return client;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool MemoryCache::addImageToCache(NativeImagePtr&amp;&amp; image, const URL&amp; url, const String&amp; domainForCachePartition, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(image);</span>
<span class="line-removed">-     removeImageFromCache(url, domainForCachePartition); // Remove cache entry if it already exists.</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto bitmapImage = BitmapImage::create(WTFMove(image), nullptr);</span>
<span class="line-removed">-     auto cachedImage = makeUnique&lt;CachedImage&gt;(url, bitmapImage.ptr(), sessionID, cookieJar, domainForCachePartition);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     cachedImage-&gt;addClient(dummyCachedImageClient());</span>
<span class="line-removed">-     cachedImage-&gt;setDecodedSize(bitmapImage-&gt;decodedSize());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return add(*cachedImage.release());</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void MemoryCache::removeImageFromCache(const URL&amp; url, const String&amp; domainForCachePartition)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto* resources = sessionResourceMap(PAL::SessionID::defaultSessionID());</span>
<span class="line-removed">-     if (!resources)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto key = std::make_pair(url, ResourceRequest::partitionName(domainForCachePartition));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     CachedResource* resource = resources-&gt;get(key);</span>
<span class="line-removed">-     if (!resource)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // A resource exists and is not a manually cached image, so just remove it.</span>
<span class="line-removed">-     if (!is&lt;CachedImage&gt;(*resource) || !downcast&lt;CachedImage&gt;(*resource).isManuallyCached()) {</span>
<span class="line-removed">-         remove(*resource);</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Removing the last client of a CachedImage turns the resource</span>
<span class="line-removed">-     // into a dead resource which will eventually be evicted when</span>
<span class="line-removed">-     // dead resources are pruned. That might be immediately since</span>
<span class="line-removed">-     // removing the last client triggers a MemoryCache::prune, so the</span>
<span class="line-removed">-     // resource may be deleted after this call.</span>
<span class="line-removed">-     downcast&lt;CachedImage&gt;(*resource).removeClient(dummyCachedImageClient());</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void MemoryCache::pruneLiveResources(bool shouldDestroyDecodedDataForAllLiveResources)
  {
      unsigned capacity = shouldDestroyDecodedDataForAllLiveResources ? 0 : liveCapacity();
      if (capacity &amp;&amp; m_liveSize &lt;= capacity)
          return;
<span class="line-new-header">--- 202,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 440,10 ***</span>
<span class="line-new-header">--- 394,12 ---</span>
      // who needed a fresh copy for a reload. See &lt;http://bugs.webkit.org/show_bug.cgi?id=12479#c6&gt;.
      if (auto* resources = sessionResourceMap(resource.sessionID())) {
          auto key = std::make_pair(resource.url(), resource.cachePartition());
  
          if (resource.inCache()) {
<span class="line-added">+             ASSERT_WITH_MESSAGE(resource.response().source() != ResourceResponse::Source::InspectorOverride, &quot;InspectorOverride responses should not get into the MemoryCache&quot;);</span>
<span class="line-added">+ </span>
              // Remove resource from the resource map.
              resources-&gt;remove(key);
              resource.setInCache(false);
  
              // If the resource map is now empty, remove it from m_sessionResources.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 465,11 ***</span>
  
  auto MemoryCache::lruListFor(CachedResource&amp; resource) -&gt; LRUList&amp;
  {
      unsigned accessCount = std::max(resource.accessCount(), 1U);
      unsigned queueIndex = WTF::fastLog2(resource.size() / accessCount);
<span class="line-modified">! #ifndef NDEBUG</span>
      resource.m_lruIndex = queueIndex;
  #endif
  
      m_allResources.reserveCapacity(queueIndex + 1);
      while (m_allResources.size() &lt;= queueIndex)
<span class="line-new-header">--- 421,11 ---</span>
  
  auto MemoryCache::lruListFor(CachedResource&amp; resource) -&gt; LRUList&amp;
  {
      unsigned accessCount = std::max(resource.accessCount(), 1U);
      unsigned queueIndex = WTF::fastLog2(resource.size() / accessCount);
<span class="line-modified">! #if ASSERT_ENABLED</span>
      resource.m_lruIndex = queueIndex;
  #endif
  
      m_allResources.reserveCapacity(queueIndex + 1);
      while (m_allResources.size() &lt;= queueIndex)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 481,11 ***</span>
  {
      // If we&#39;ve never been accessed, then we&#39;re brand new and not in any list.
      if (!resource.accessCount())
          return;
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      unsigned oldListIndex = resource.m_lruIndex;
  #endif
  
      LRUList&amp; list = lruListFor(resource);
  
<span class="line-new-header">--- 437,11 ---</span>
  {
      // If we&#39;ve never been accessed, then we&#39;re brand new and not in any list.
      if (!resource.accessCount())
          return;
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
      unsigned oldListIndex = resource.m_lruIndex;
  #endif
  
      LRUList&amp; list = lruListFor(resource);
  
</pre>
<center><a href="KeepaliveRequestTracker.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MemoryCache.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
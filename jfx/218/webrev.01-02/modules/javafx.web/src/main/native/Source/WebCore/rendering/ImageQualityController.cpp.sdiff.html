<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/ImageQualityController.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GridTrackSizingAlgorithm.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InlineBox.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/ImageQualityController.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 85     if (m_renderView.frameView().inLiveResize()) {
 86         restartTimer();
 87         return;
 88     }
 89 
 90     for (auto it = m_objectLayerSizeMap.begin(), end = m_objectLayerSizeMap.end(); it != end; ++it)
 91         it-&gt;key-&gt;repaint();
 92 
 93     m_liveResizeOptimizationIsActive = false;
 94 }
 95 
 96 void ImageQualityController::restartTimer()
 97 {
 98     m_timer.startOneShot(lowQualityTimeThreshold);
 99 }
100 
101 Optional&lt;InterpolationQuality&gt; ImageQualityController::interpolationQualityFromStyle(const RenderStyle&amp; style)
102 {
103     switch (style.imageRendering()) {
104     case ImageRendering::OptimizeSpeed:
<span class="line-modified">105         return InterpolationLow;</span>
106     case ImageRendering::CrispEdges:
107     case ImageRendering::Pixelated:
<span class="line-modified">108         return InterpolationNone;</span>
109     case ImageRendering::OptimizeQuality:
<span class="line-modified">110         return InterpolationDefault; // FIXME: CSS 3 Images says that optimizeQuality should behave like &#39;auto&#39;, but that prevents authors from overriding this low quality rendering behavior.</span>
111     case ImageRendering::Auto:
112         break;
113     }
114     return WTF::nullopt;
115 }
116 
117 InterpolationQuality ImageQualityController::chooseInterpolationQuality(GraphicsContext&amp; context, RenderBoxModelObject* object, Image&amp; image, const void* layer, const LayoutSize&amp; size)
118 {
119     // If the image is not a bitmap image, then none of this is relevant and we just paint at high quality.
120     if (!(image.isBitmapImage() || image.isPDFDocumentImage()) || context.paintingDisabled())
<span class="line-modified">121         return InterpolationDefault;</span>
122 
123     if (Optional&lt;InterpolationQuality&gt; styleInterpolation = interpolationQualityFromStyle(object-&gt;style()))
124         return styleInterpolation.value();
125 
126     // Make sure to use the unzoomed image size, since if a full page zoom is in effect, the image
127     // is actually being scaled.
128     IntSize imageSize(image.width(), image.height());
129 
130     // Look ourselves up in the hashtables.
131     auto i = m_objectLayerSizeMap.find(object);
132     LayerSizeMap* innerMap = i != m_objectLayerSizeMap.end() ? &amp;i-&gt;value : 0;
133     LayoutSize oldSize;
134     bool isFirstResize = true;
135     if (innerMap) {
136         LayerSizeMap::iterator j = innerMap-&gt;find(layer);
137         if (j != innerMap-&gt;end()) {
138             isFirstResize = false;
139             oldSize = j-&gt;value;
140         }
141     }
142 
143     // If the containing FrameView is being resized, paint at low quality until resizing is finished.
144     if (Frame* frame = object-&gt;document().frame()) {
145         bool frameViewIsCurrentlyInLiveResize = frame-&gt;view() &amp;&amp; frame-&gt;view()-&gt;inLiveResize();
146         if (frameViewIsCurrentlyInLiveResize) {
147             set(object, innerMap, layer, size);
148             restartTimer();
149             m_liveResizeOptimizationIsActive = true;
<span class="line-modified">150             return InterpolationLow;</span>
151         }
152         if (m_liveResizeOptimizationIsActive)
<span class="line-modified">153             return InterpolationDefault;</span>
154     }
155 
156     const AffineTransform&amp; currentTransform = context.getCTM();
157     bool contextIsScaled = !currentTransform.isIdentityOrTranslationOrFlipped();
158     if (!contextIsScaled &amp;&amp; size == imageSize) {
159         // There is no scale in effect. If we had a scale in effect before, we can just remove this object from the list.
160         removeLayer(object, innerMap, layer);
<span class="line-modified">161         return InterpolationDefault;</span>
162     }
163 
164     // There is no need to hash scaled images that always use low quality mode when the page demands it. This is the iChat case.
165     if (m_renderView.page().inLowQualityImageInterpolationMode()) {
166         double totalPixels = static_cast&lt;double&gt;(image.width()) * static_cast&lt;double&gt;(image.height());
167         if (totalPixels &gt; cInterpolationCutoff)
<span class="line-modified">168             return InterpolationLow;</span>
169     }
170 
171     // If an animated resize is active, paint in low quality and kick the timer ahead.
172     if (m_animatedResizeIsActive) {
173         set(object, innerMap, layer, size);
174         restartTimer();
<span class="line-modified">175         return InterpolationLow;</span>
176     }
177     // If this is the first time resizing this image, or its size is the
178     // same as the last resize, draw at high res, but record the paint
179     // size and set the timer.
180     if (isFirstResize || oldSize == size) {
181         restartTimer();
182         set(object, innerMap, layer, size);
<span class="line-modified">183         return InterpolationDefault;</span>
184     }
185     // If the timer is no longer active, draw at high quality and don&#39;t
186     // set the timer.
187     if (!m_timer.isActive()) {
188         removeLayer(object, innerMap, layer);
<span class="line-modified">189         return InterpolationDefault;</span>
190     }
191     // This object has been resized to two different sizes while the timer
192     // is active, so draw at low quality, set the flag for animated resizes and
193     // the object to the list for high quality redraw.
194     set(object, innerMap, layer, size);
195     m_animatedResizeIsActive = true;
196     restartTimer();
<span class="line-modified">197     return InterpolationLow;</span>
198 }
199 
200 }
</pre>
</td>
<td>
<hr />
<pre>
 85     if (m_renderView.frameView().inLiveResize()) {
 86         restartTimer();
 87         return;
 88     }
 89 
 90     for (auto it = m_objectLayerSizeMap.begin(), end = m_objectLayerSizeMap.end(); it != end; ++it)
 91         it-&gt;key-&gt;repaint();
 92 
 93     m_liveResizeOptimizationIsActive = false;
 94 }
 95 
 96 void ImageQualityController::restartTimer()
 97 {
 98     m_timer.startOneShot(lowQualityTimeThreshold);
 99 }
100 
101 Optional&lt;InterpolationQuality&gt; ImageQualityController::interpolationQualityFromStyle(const RenderStyle&amp; style)
102 {
103     switch (style.imageRendering()) {
104     case ImageRendering::OptimizeSpeed:
<span class="line-modified">105         return InterpolationQuality::Low;</span>
106     case ImageRendering::CrispEdges:
107     case ImageRendering::Pixelated:
<span class="line-modified">108         return InterpolationQuality::DoNotInterpolate;</span>
109     case ImageRendering::OptimizeQuality:
<span class="line-modified">110         return InterpolationQuality::Default; // FIXME: CSS 3 Images says that optimizeQuality should behave like &#39;auto&#39;, but that prevents authors from overriding this low quality rendering behavior.</span>
111     case ImageRendering::Auto:
112         break;
113     }
114     return WTF::nullopt;
115 }
116 
117 InterpolationQuality ImageQualityController::chooseInterpolationQuality(GraphicsContext&amp; context, RenderBoxModelObject* object, Image&amp; image, const void* layer, const LayoutSize&amp; size)
118 {
119     // If the image is not a bitmap image, then none of this is relevant and we just paint at high quality.
120     if (!(image.isBitmapImage() || image.isPDFDocumentImage()) || context.paintingDisabled())
<span class="line-modified">121         return InterpolationQuality::Default;</span>
122 
123     if (Optional&lt;InterpolationQuality&gt; styleInterpolation = interpolationQualityFromStyle(object-&gt;style()))
124         return styleInterpolation.value();
125 
126     // Make sure to use the unzoomed image size, since if a full page zoom is in effect, the image
127     // is actually being scaled.
128     IntSize imageSize(image.width(), image.height());
129 
130     // Look ourselves up in the hashtables.
131     auto i = m_objectLayerSizeMap.find(object);
132     LayerSizeMap* innerMap = i != m_objectLayerSizeMap.end() ? &amp;i-&gt;value : 0;
133     LayoutSize oldSize;
134     bool isFirstResize = true;
135     if (innerMap) {
136         LayerSizeMap::iterator j = innerMap-&gt;find(layer);
137         if (j != innerMap-&gt;end()) {
138             isFirstResize = false;
139             oldSize = j-&gt;value;
140         }
141     }
142 
143     // If the containing FrameView is being resized, paint at low quality until resizing is finished.
144     if (Frame* frame = object-&gt;document().frame()) {
145         bool frameViewIsCurrentlyInLiveResize = frame-&gt;view() &amp;&amp; frame-&gt;view()-&gt;inLiveResize();
146         if (frameViewIsCurrentlyInLiveResize) {
147             set(object, innerMap, layer, size);
148             restartTimer();
149             m_liveResizeOptimizationIsActive = true;
<span class="line-modified">150             return InterpolationQuality::Low;</span>
151         }
152         if (m_liveResizeOptimizationIsActive)
<span class="line-modified">153             return InterpolationQuality::Default;</span>
154     }
155 
156     const AffineTransform&amp; currentTransform = context.getCTM();
157     bool contextIsScaled = !currentTransform.isIdentityOrTranslationOrFlipped();
158     if (!contextIsScaled &amp;&amp; size == imageSize) {
159         // There is no scale in effect. If we had a scale in effect before, we can just remove this object from the list.
160         removeLayer(object, innerMap, layer);
<span class="line-modified">161         return InterpolationQuality::Default;</span>
162     }
163 
164     // There is no need to hash scaled images that always use low quality mode when the page demands it. This is the iChat case.
165     if (m_renderView.page().inLowQualityImageInterpolationMode()) {
166         double totalPixels = static_cast&lt;double&gt;(image.width()) * static_cast&lt;double&gt;(image.height());
167         if (totalPixels &gt; cInterpolationCutoff)
<span class="line-modified">168             return InterpolationQuality::Low;</span>
169     }
170 
171     // If an animated resize is active, paint in low quality and kick the timer ahead.
172     if (m_animatedResizeIsActive) {
173         set(object, innerMap, layer, size);
174         restartTimer();
<span class="line-modified">175         return InterpolationQuality::Low;</span>
176     }
177     // If this is the first time resizing this image, or its size is the
178     // same as the last resize, draw at high res, but record the paint
179     // size and set the timer.
180     if (isFirstResize || oldSize == size) {
181         restartTimer();
182         set(object, innerMap, layer, size);
<span class="line-modified">183         return InterpolationQuality::Default;</span>
184     }
185     // If the timer is no longer active, draw at high quality and don&#39;t
186     // set the timer.
187     if (!m_timer.isActive()) {
188         removeLayer(object, innerMap, layer);
<span class="line-modified">189         return InterpolationQuality::Default;</span>
190     }
191     // This object has been resized to two different sizes while the timer
192     // is active, so draw at low quality, set the flag for animated resizes and
193     // the object to the list for high quality redraw.
194     set(object, innerMap, layer, size);
195     m_animatedResizeIsActive = true;
196     restartTimer();
<span class="line-modified">197     return InterpolationQuality::Low;</span>
198 }
199 
200 }
</pre>
</td>
</tr>
</table>
<center><a href="GridTrackSizingAlgorithm.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InlineBox.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
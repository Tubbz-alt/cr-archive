<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/MacroAssemblerX86Common.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MacroAssemblerX86Common.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MacroAssemblerX86_64.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/MacroAssemblerX86Common.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2008-2018 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(ASSEMBLER)
  29 
  30 #include &quot;X86Assembler.h&quot;
  31 #include &quot;AbstractMacroAssembler.h&quot;
  32 #include &lt;array&gt;
  33 #include &lt;wtf/Optional.h&gt;
  34 
  35 namespace JSC {
  36 
  37 using Assembler = TARGET_ASSEMBLER;
  38 
  39 class MacroAssemblerX86Common : public AbstractMacroAssembler&lt;Assembler&gt; {
  40 public:
  41 #if CPU(X86_64)
  42     // Use this directly only if you&#39;re not generating code with it.
<span class="line-modified">  43     static const X86Registers::RegisterID s_scratchRegister = X86Registers::r11;</span>
  44 
  45     // Use this when generating code so that we get enforcement of the disallowing of scratch register
  46     // usage.
  47     X86Registers::RegisterID scratchRegister()
  48     {
  49         RELEASE_ASSERT(m_allowScratchRegister);
  50         return s_scratchRegister;
  51     }
  52 #endif
  53 
  54 protected:
<span class="line-modified">  55     static const int DoubleConditionBitInvert = 0x10;</span>
<span class="line-modified">  56     static const int DoubleConditionBitSpecial = 0x20;</span>
<span class="line-modified">  57     static const int DoubleConditionBits = DoubleConditionBitInvert | DoubleConditionBitSpecial;</span>
  58 
  59 public:
  60     typedef X86Assembler::XMMRegisterID XMMRegisterID;
  61 
  62     static bool isCompactPtrAlignedAddressOffset(ptrdiff_t value)
  63     {
  64         return value &gt;= -128 &amp;&amp; value &lt;= 127;
  65     }
  66 
  67     enum RelationalCondition {
  68         Equal = X86Assembler::ConditionE,
  69         NotEqual = X86Assembler::ConditionNE,
  70         Above = X86Assembler::ConditionA,
  71         AboveOrEqual = X86Assembler::ConditionAE,
  72         Below = X86Assembler::ConditionB,
  73         BelowOrEqual = X86Assembler::ConditionBE,
  74         GreaterThan = X86Assembler::ConditionG,
  75         GreaterThanOrEqual = X86Assembler::ConditionGE,
  76         LessThan = X86Assembler::ConditionL,
  77         LessThanOrEqual = X86Assembler::ConditionLE
</pre>
<hr />
<pre>
  89     enum DoubleCondition {
  90         // These conditions will only evaluate to true if the comparison is ordered - i.e. neither operand is NaN.
  91         DoubleEqual = X86Assembler::ConditionE | DoubleConditionBitSpecial,
  92         DoubleNotEqual = X86Assembler::ConditionNE,
  93         DoubleGreaterThan = X86Assembler::ConditionA,
  94         DoubleGreaterThanOrEqual = X86Assembler::ConditionAE,
  95         DoubleLessThan = X86Assembler::ConditionA | DoubleConditionBitInvert,
  96         DoubleLessThanOrEqual = X86Assembler::ConditionAE | DoubleConditionBitInvert,
  97         // If either operand is NaN, these conditions always evaluate to true.
  98         DoubleEqualOrUnordered = X86Assembler::ConditionE,
  99         DoubleNotEqualOrUnordered = X86Assembler::ConditionNE | DoubleConditionBitSpecial,
 100         DoubleGreaterThanOrUnordered = X86Assembler::ConditionB | DoubleConditionBitInvert,
 101         DoubleGreaterThanOrEqualOrUnordered = X86Assembler::ConditionBE | DoubleConditionBitInvert,
 102         DoubleLessThanOrUnordered = X86Assembler::ConditionB,
 103         DoubleLessThanOrEqualOrUnordered = X86Assembler::ConditionBE,
 104     };
 105     COMPILE_ASSERT(
 106         !((X86Assembler::ConditionE | X86Assembler::ConditionNE | X86Assembler::ConditionA | X86Assembler::ConditionAE | X86Assembler::ConditionB | X86Assembler::ConditionBE) &amp; DoubleConditionBits),
 107         DoubleConditionBits_should_not_interfere_with_X86Assembler_Condition_codes);
 108 
<span class="line-modified"> 109     static const RegisterID stackPointerRegister = X86Registers::esp;</span>
<span class="line-modified"> 110     static const RegisterID framePointerRegister = X86Registers::ebp;</span>
 111 
 112     static bool canBlind() { return true; }
 113     static bool shouldBlindForSpecificArch(uint32_t value) { return value &gt;= 0x00ffffff; }
 114     static bool shouldBlindForSpecificArch(uint64_t value) { return value &gt;= 0x00ffffff; }
 115 
 116     // Integer arithmetic operations:
 117     //
 118     // Operations are typically two operand - operation(source, srcDst)
 119     // For many operations the source may be an TrustedImm32, the srcDst operand
 120     // may often be a memory location (explictly described using an Address
 121     // object).
 122 
 123     void add32(RegisterID src, RegisterID dest)
 124     {
 125         m_assembler.addl_rr(src, dest);
 126     }
 127 
 128     void add32(TrustedImm32 imm, Address address)
 129     {
 130         m_assembler.addl_im(imm.m_value, address.offset, address.base);
</pre>
<hr />
<pre>
1086     }
1087 
1088     void sqrtDouble(Address src, FPRegisterID dst)
1089     {
1090         m_assembler.sqrtsd_mr(src.offset, src.base, dst);
1091     }
1092 
1093     void sqrtFloat(FPRegisterID src, FPRegisterID dst)
1094     {
1095         m_assembler.sqrtss_rr(src, dst);
1096     }
1097 
1098     void sqrtFloat(Address src, FPRegisterID dst)
1099     {
1100         m_assembler.sqrtss_mr(src.offset, src.base, dst);
1101     }
1102 
1103     void absDouble(FPRegisterID src, FPRegisterID dst)
1104     {
1105         ASSERT(src != dst);
<span class="line-modified">1106         static const double negativeZeroConstant = -0.0;</span>
1107         loadDouble(TrustedImmPtr(&amp;negativeZeroConstant), dst);
1108         m_assembler.andnpd_rr(src, dst);
1109     }
1110 
1111     void negateDouble(FPRegisterID src, FPRegisterID dst)
1112     {
1113         ASSERT(src != dst);
<span class="line-modified">1114         static const double negativeZeroConstant = -0.0;</span>
1115         loadDouble(TrustedImmPtr(&amp;negativeZeroConstant), dst);
1116         m_assembler.xorpd_rr(src, dst);
1117     }
1118 
1119     void ceilDouble(FPRegisterID src, FPRegisterID dst)
1120     {
1121         m_assembler.roundsd_rr(src, dst, X86Assembler::RoundingType::TowardInfiniti);
1122     }
1123 
1124     void ceilDouble(Address src, FPRegisterID dst)
1125     {
1126         m_assembler.roundsd_mr(src.offset, src.base, dst, X86Assembler::RoundingType::TowardInfiniti);
1127     }
1128 
1129     void ceilFloat(FPRegisterID src, FPRegisterID dst)
1130     {
1131         m_assembler.roundss_rr(src, dst, X86Assembler::RoundingType::TowardInfiniti);
1132     }
1133 
1134     void ceilFloat(Address src, FPRegisterID dst)
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(ASSEMBLER)
  29 
  30 #include &quot;X86Assembler.h&quot;
  31 #include &quot;AbstractMacroAssembler.h&quot;
  32 #include &lt;array&gt;
  33 #include &lt;wtf/Optional.h&gt;
  34 
  35 namespace JSC {
  36 
  37 using Assembler = TARGET_ASSEMBLER;
  38 
  39 class MacroAssemblerX86Common : public AbstractMacroAssembler&lt;Assembler&gt; {
  40 public:
  41 #if CPU(X86_64)
  42     // Use this directly only if you&#39;re not generating code with it.
<span class="line-modified">  43     static constexpr X86Registers::RegisterID s_scratchRegister = X86Registers::r11;</span>
  44 
  45     // Use this when generating code so that we get enforcement of the disallowing of scratch register
  46     // usage.
  47     X86Registers::RegisterID scratchRegister()
  48     {
  49         RELEASE_ASSERT(m_allowScratchRegister);
  50         return s_scratchRegister;
  51     }
  52 #endif
  53 
  54 protected:
<span class="line-modified">  55     static constexpr int DoubleConditionBitInvert = 0x10;</span>
<span class="line-modified">  56     static constexpr int DoubleConditionBitSpecial = 0x20;</span>
<span class="line-modified">  57     static constexpr int DoubleConditionBits = DoubleConditionBitInvert | DoubleConditionBitSpecial;</span>
  58 
  59 public:
  60     typedef X86Assembler::XMMRegisterID XMMRegisterID;
  61 
  62     static bool isCompactPtrAlignedAddressOffset(ptrdiff_t value)
  63     {
  64         return value &gt;= -128 &amp;&amp; value &lt;= 127;
  65     }
  66 
  67     enum RelationalCondition {
  68         Equal = X86Assembler::ConditionE,
  69         NotEqual = X86Assembler::ConditionNE,
  70         Above = X86Assembler::ConditionA,
  71         AboveOrEqual = X86Assembler::ConditionAE,
  72         Below = X86Assembler::ConditionB,
  73         BelowOrEqual = X86Assembler::ConditionBE,
  74         GreaterThan = X86Assembler::ConditionG,
  75         GreaterThanOrEqual = X86Assembler::ConditionGE,
  76         LessThan = X86Assembler::ConditionL,
  77         LessThanOrEqual = X86Assembler::ConditionLE
</pre>
<hr />
<pre>
  89     enum DoubleCondition {
  90         // These conditions will only evaluate to true if the comparison is ordered - i.e. neither operand is NaN.
  91         DoubleEqual = X86Assembler::ConditionE | DoubleConditionBitSpecial,
  92         DoubleNotEqual = X86Assembler::ConditionNE,
  93         DoubleGreaterThan = X86Assembler::ConditionA,
  94         DoubleGreaterThanOrEqual = X86Assembler::ConditionAE,
  95         DoubleLessThan = X86Assembler::ConditionA | DoubleConditionBitInvert,
  96         DoubleLessThanOrEqual = X86Assembler::ConditionAE | DoubleConditionBitInvert,
  97         // If either operand is NaN, these conditions always evaluate to true.
  98         DoubleEqualOrUnordered = X86Assembler::ConditionE,
  99         DoubleNotEqualOrUnordered = X86Assembler::ConditionNE | DoubleConditionBitSpecial,
 100         DoubleGreaterThanOrUnordered = X86Assembler::ConditionB | DoubleConditionBitInvert,
 101         DoubleGreaterThanOrEqualOrUnordered = X86Assembler::ConditionBE | DoubleConditionBitInvert,
 102         DoubleLessThanOrUnordered = X86Assembler::ConditionB,
 103         DoubleLessThanOrEqualOrUnordered = X86Assembler::ConditionBE,
 104     };
 105     COMPILE_ASSERT(
 106         !((X86Assembler::ConditionE | X86Assembler::ConditionNE | X86Assembler::ConditionA | X86Assembler::ConditionAE | X86Assembler::ConditionB | X86Assembler::ConditionBE) &amp; DoubleConditionBits),
 107         DoubleConditionBits_should_not_interfere_with_X86Assembler_Condition_codes);
 108 
<span class="line-modified"> 109     static constexpr RegisterID stackPointerRegister = X86Registers::esp;</span>
<span class="line-modified"> 110     static constexpr RegisterID framePointerRegister = X86Registers::ebp;</span>
 111 
 112     static bool canBlind() { return true; }
 113     static bool shouldBlindForSpecificArch(uint32_t value) { return value &gt;= 0x00ffffff; }
 114     static bool shouldBlindForSpecificArch(uint64_t value) { return value &gt;= 0x00ffffff; }
 115 
 116     // Integer arithmetic operations:
 117     //
 118     // Operations are typically two operand - operation(source, srcDst)
 119     // For many operations the source may be an TrustedImm32, the srcDst operand
 120     // may often be a memory location (explictly described using an Address
 121     // object).
 122 
 123     void add32(RegisterID src, RegisterID dest)
 124     {
 125         m_assembler.addl_rr(src, dest);
 126     }
 127 
 128     void add32(TrustedImm32 imm, Address address)
 129     {
 130         m_assembler.addl_im(imm.m_value, address.offset, address.base);
</pre>
<hr />
<pre>
1086     }
1087 
1088     void sqrtDouble(Address src, FPRegisterID dst)
1089     {
1090         m_assembler.sqrtsd_mr(src.offset, src.base, dst);
1091     }
1092 
1093     void sqrtFloat(FPRegisterID src, FPRegisterID dst)
1094     {
1095         m_assembler.sqrtss_rr(src, dst);
1096     }
1097 
1098     void sqrtFloat(Address src, FPRegisterID dst)
1099     {
1100         m_assembler.sqrtss_mr(src.offset, src.base, dst);
1101     }
1102 
1103     void absDouble(FPRegisterID src, FPRegisterID dst)
1104     {
1105         ASSERT(src != dst);
<span class="line-modified">1106         static constexpr double negativeZeroConstant = -0.0;</span>
1107         loadDouble(TrustedImmPtr(&amp;negativeZeroConstant), dst);
1108         m_assembler.andnpd_rr(src, dst);
1109     }
1110 
1111     void negateDouble(FPRegisterID src, FPRegisterID dst)
1112     {
1113         ASSERT(src != dst);
<span class="line-modified">1114         static constexpr double negativeZeroConstant = -0.0;</span>
1115         loadDouble(TrustedImmPtr(&amp;negativeZeroConstant), dst);
1116         m_assembler.xorpd_rr(src, dst);
1117     }
1118 
1119     void ceilDouble(FPRegisterID src, FPRegisterID dst)
1120     {
1121         m_assembler.roundsd_rr(src, dst, X86Assembler::RoundingType::TowardInfiniti);
1122     }
1123 
1124     void ceilDouble(Address src, FPRegisterID dst)
1125     {
1126         m_assembler.roundsd_mr(src.offset, src.base, dst, X86Assembler::RoundingType::TowardInfiniti);
1127     }
1128 
1129     void ceilFloat(FPRegisterID src, FPRegisterID dst)
1130     {
1131         m_assembler.roundss_rr(src, dst, X86Assembler::RoundingType::TowardInfiniti);
1132     }
1133 
1134     void ceilFloat(Address src, FPRegisterID dst)
</pre>
</td>
</tr>
</table>
<center><a href="MacroAssemblerX86Common.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MacroAssemblerX86_64.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/MarkedBlock.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MarkStackMergingConstraint.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MarkedBlock.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/MarkedBlock.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 40,15 ***</span>
  namespace JSC {
  namespace MarkedBlockInternal {
  static constexpr bool verbose = false;
  }
  
<span class="line-modified">! const size_t MarkedBlock::blockSize;</span>
<span class="line-removed">- </span>
<span class="line-removed">- static const bool computeBalance = false;</span>
  static size_t balance;
  
  MarkedBlock::Handle* MarkedBlock::tryCreate(Heap&amp; heap, AlignedMemoryAllocator* alignedMemoryAllocator)
  {
      if (computeBalance) {
          balance++;
          if (!(balance % 10))
<span class="line-new-header">--- 40,16 ---</span>
  namespace JSC {
  namespace MarkedBlockInternal {
  static constexpr bool verbose = false;
  }
  
<span class="line-modified">! static constexpr bool computeBalance = false;</span>
  static size_t balance;
  
<span class="line-added">+ DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(MarkedBlock);</span>
<span class="line-added">+ DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(MarkedBlockHandle);</span>
<span class="line-added">+ </span>
  MarkedBlock::Handle* MarkedBlock::tryCreate(Heap&amp; heap, AlignedMemoryAllocator* alignedMemoryAllocator)
  {
      if (computeBalance) {
          balance++;
          if (!(balance % 10))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 62,16 ***</span>
      return new Handle(heap, alignedMemoryAllocator, blockSpace);
  }
  
  MarkedBlock::Handle::Handle(Heap&amp; heap, AlignedMemoryAllocator* alignedMemoryAllocator, void* blockSpace)
      : m_alignedMemoryAllocator(alignedMemoryAllocator)
<span class="line-modified">!     , m_weakSet(heap.vm(), CellContainer())</span>
  {
      m_block = new (NotNull, blockSpace) MarkedBlock(heap.vm(), *this);
  
<span class="line-removed">-     m_weakSet.setContainer(*m_block);</span>
<span class="line-removed">- </span>
      heap.didAllocateBlock(blockSize);
  }
  
  MarkedBlock::Handle::~Handle()
  {
<span class="line-new-header">--- 63,14 ---</span>
      return new Handle(heap, alignedMemoryAllocator, blockSpace);
  }
  
  MarkedBlock::Handle::Handle(Heap&amp; heap, AlignedMemoryAllocator* alignedMemoryAllocator, void* blockSpace)
      : m_alignedMemoryAllocator(alignedMemoryAllocator)
<span class="line-modified">!     , m_weakSet(heap.vm())</span>
  {
      m_block = new (NotNull, blockSpace) MarkedBlock(heap.vm(), *this);
  
      heap.didAllocateBlock(blockSize);
  }
  
  MarkedBlock::Handle::~Handle()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 115,16 ***</span>
  {
      RELEASE_ASSERT(m_isFreeListed);
      m_isFreeListed = false;
  }
  
<span class="line-removed">- void MarkedBlock::Handle::setIsFreeListed()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_directory-&gt;setIsEmpty(NoLockingNecessary, this, false);</span>
<span class="line-removed">-     m_isFreeListed = true;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void MarkedBlock::Handle::stopAllocating(const FreeList&amp; freeList)
  {
      auto locker = holdLock(blockFooter().m_lock);
  
      if (MarkedBlockInternal::verbose)
<span class="line-new-header">--- 114,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 149,11 ***</span>
  
      blockFooter().m_newlyAllocated.clearAll();
      blockFooter().m_newlyAllocatedVersion = heap()-&gt;objectSpace().newlyAllocatedVersion();
  
      forEachCell(
<span class="line-modified">!         [&amp;] (HeapCell* cell, HeapCell::Kind) -&gt; IterationStatus {</span>
              block().setNewlyAllocated(cell);
              return IterationStatus::Continue;
          });
  
      freeList.forEach(
<span class="line-new-header">--- 142,11 ---</span>
  
      blockFooter().m_newlyAllocated.clearAll();
      blockFooter().m_newlyAllocatedVersion = heap()-&gt;objectSpace().newlyAllocatedVersion();
  
      forEachCell(
<span class="line-modified">!         [&amp;] (size_t, HeapCell* cell, HeapCell::Kind) -&gt; IterationStatus {</span>
              block().setNewlyAllocated(cell);
              return IterationStatus::Continue;
          });
  
      freeList.forEach(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 270,16 ***</span>
      if (areMarksStale())
          footer().m_marks.clearAll();
      footer().m_markingVersion = MarkedSpace::nullVersion;
  }
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
  void MarkedBlock::assertMarksNotStale()
  {
      ASSERT(footer().m_markingVersion == vm().heap.objectSpace().markingVersion());
  }
<span class="line-modified">! #endif // !ASSERT_DISABLED</span>
  
  bool MarkedBlock::areMarksStale()
  {
      return areMarksStale(vm().heap.objectSpace().markingVersion());
  }
<span class="line-new-header">--- 263,16 ---</span>
      if (areMarksStale())
          footer().m_marks.clearAll();
      footer().m_markingVersion = MarkedSpace::nullVersion;
  }
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
  void MarkedBlock::assertMarksNotStale()
  {
      ASSERT(footer().m_markingVersion == vm().heap.objectSpace().markingVersion());
  }
<span class="line-modified">! #endif // ASSERT_ENABLED</span>
  
  bool MarkedBlock::areMarksStale()
  {
      return areMarksStale(vm().heap.objectSpace().markingVersion());
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 326,13 ***</span>
          return;
  
      m_directory-&gt;removeBlock(this);
  }
  
<span class="line-modified">! void MarkedBlock::Handle::didAddToDirectory(BlockDirectory* directory, size_t index)</span>
  {
<span class="line-modified">!     ASSERT(m_index == std::numeric_limits&lt;size_t&gt;::max());</span>
      ASSERT(!m_directory);
  
      RELEASE_ASSERT(directory-&gt;subspace()-&gt;alignedMemoryAllocator() == m_alignedMemoryAllocator);
  
      m_index = index;
<span class="line-new-header">--- 319,13 ---</span>
          return;
  
      m_directory-&gt;removeBlock(this);
  }
  
<span class="line-modified">! void MarkedBlock::Handle::didAddToDirectory(BlockDirectory* directory, unsigned index)</span>
  {
<span class="line-modified">!     ASSERT(m_index == std::numeric_limits&lt;unsigned&gt;::max());</span>
      ASSERT(!m_directory);
  
      RELEASE_ASSERT(directory-&gt;subspace()-&gt;alignedMemoryAllocator() == m_alignedMemoryAllocator);
  
      m_index = index;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 358,33 ***</span>
      blockFooter().m_biasedMarkCount = blockFooter().m_markCountBias = static_cast&lt;int16_t&gt;(markCountBias);
  }
  
  void MarkedBlock::Handle::didRemoveFromDirectory()
  {
<span class="line-modified">!     ASSERT(m_index != std::numeric_limits&lt;size_t&gt;::max());</span>
      ASSERT(m_directory);
  
<span class="line-modified">!     m_index = std::numeric_limits&lt;size_t&gt;::max();</span>
      m_directory = nullptr;
      blockFooter().m_subspace = nullptr;
  }
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
  void MarkedBlock::assertValidCell(VM&amp; vm, HeapCell* cell) const
  {
      RELEASE_ASSERT(&amp;vm == &amp;this-&gt;vm());
      RELEASE_ASSERT(const_cast&lt;MarkedBlock*&gt;(this)-&gt;handle().cellAlign(cell) == cell);
  }
<span class="line-modified">! #endif</span>
  
  void MarkedBlock::Handle::dumpState(PrintStream&amp; out)
  {
      CommaPrinter comma;
      directory()-&gt;forEachBitVectorWithName(
          holdLock(directory()-&gt;bitvectorLock()),
<span class="line-modified">!         [&amp;] (FastBitVector&amp; bitvector, const char* name) {</span>
<span class="line-modified">!             out.print(comma, name, &quot;:&quot;, bitvector[index()] ? &quot;YES&quot; : &quot;no&quot;);</span>
          });
  }
  
  Subspace* MarkedBlock::Handle::subspace() const
  {
<span class="line-new-header">--- 351,33 ---</span>
      blockFooter().m_biasedMarkCount = blockFooter().m_markCountBias = static_cast&lt;int16_t&gt;(markCountBias);
  }
  
  void MarkedBlock::Handle::didRemoveFromDirectory()
  {
<span class="line-modified">!     ASSERT(m_index != std::numeric_limits&lt;unsigned&gt;::max());</span>
      ASSERT(m_directory);
  
<span class="line-modified">!     m_index = std::numeric_limits&lt;unsigned&gt;::max();</span>
      m_directory = nullptr;
      blockFooter().m_subspace = nullptr;
  }
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
  void MarkedBlock::assertValidCell(VM&amp; vm, HeapCell* cell) const
  {
      RELEASE_ASSERT(&amp;vm == &amp;this-&gt;vm());
      RELEASE_ASSERT(const_cast&lt;MarkedBlock*&gt;(this)-&gt;handle().cellAlign(cell) == cell);
  }
<span class="line-modified">! #endif // ASSERT_ENABLED</span>
  
  void MarkedBlock::Handle::dumpState(PrintStream&amp; out)
  {
      CommaPrinter comma;
      directory()-&gt;forEachBitVectorWithName(
          holdLock(directory()-&gt;bitvectorLock()),
<span class="line-modified">!         [&amp;](auto vectorRef, const char* name) {</span>
<span class="line-modified">!             out.print(comma, name, &quot;:&quot;, vectorRef[index()] ? &quot;YES&quot; : &quot;no&quot;);</span>
          });
  }
  
  Subspace* MarkedBlock::Handle::subspace() const
  {
</pre>
<center><a href="MarkStackMergingConstraint.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MarkedBlock.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
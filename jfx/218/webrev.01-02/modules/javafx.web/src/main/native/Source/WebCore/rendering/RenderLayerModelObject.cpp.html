<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerModelObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2005 Allan Sandfeld Jensen (kde@carewolf.com)
  5  *           (C) 2005, 2006 Samuel Weinig (sam.weinig@gmail.com)
  6  * Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
  7  * Copyright (C) 2010, 2012 Google Inc. All rights reserved.
  8  *
  9  * This library is free software; you can redistribute it and/or
 10  * modify it under the terms of the GNU Library General Public
 11  * License as published by the Free Software Foundation; either
 12  * version 2 of the License, or (at your option) any later version.
 13  *
 14  * This library is distributed in the hope that it will be useful,
 15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 17  * Library General Public License for more details.
 18  *
 19  * You should have received a copy of the GNU Library General Public License
 20  * along with this library; see the file COPYING.LIB.  If not, write to
 21  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 22  * Boston, MA 02110-1301, USA.
 23  */
 24 
 25 #include &quot;config.h&quot;
 26 #include &quot;RenderLayerModelObject.h&quot;
 27 
 28 #include &quot;RenderLayer.h&quot;
 29 #include &quot;RenderLayerBacking.h&quot;
 30 #include &quot;RenderLayerCompositor.h&quot;
 31 #include &quot;RenderView.h&quot;
 32 #include &quot;Settings.h&quot;
 33 #include &quot;StyleScrollSnapPoints.h&quot;
 34 #include &lt;wtf/IsoMallocInlines.h&gt;
 35 
 36 namespace WebCore {
 37 
 38 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderLayerModelObject);
 39 
 40 bool RenderLayerModelObject::s_wasFloating = false;
 41 bool RenderLayerModelObject::s_hadLayer = false;
 42 bool RenderLayerModelObject::s_hadTransform = false;
 43 bool RenderLayerModelObject::s_layerWasSelfPainting = false;
 44 
 45 typedef WTF::HashMap&lt;const RenderLayerModelObject*, RepaintLayoutRects&gt; RepaintLayoutRectsMap;
 46 static RepaintLayoutRectsMap* gRepaintLayoutRectsMap = nullptr;
 47 
 48 RepaintLayoutRects::RepaintLayoutRects(const RenderLayerModelObject&amp; renderer, const RenderLayerModelObject* repaintContainer, const RenderGeometryMap* geometryMap)
 49     : m_repaintRect(renderer.clippedOverflowRectForRepaint(repaintContainer))
 50     , m_outlineBox(renderer.outlineBoundsForRepaint(repaintContainer, geometryMap))
 51 {
 52 }
 53 
 54 RenderLayerModelObject::RenderLayerModelObject(Element&amp; element, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 55     : RenderElement(element, WTFMove(style), baseTypeFlags | RenderLayerModelObjectFlag)
 56 {
 57 }
 58 
 59 RenderLayerModelObject::RenderLayerModelObject(Document&amp; document, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 60     : RenderElement(document, WTFMove(style), baseTypeFlags | RenderLayerModelObjectFlag)
 61 {
 62 }
 63 
 64 RenderLayerModelObject::~RenderLayerModelObject()
 65 {
 66     // Do not add any code here. Add it to willBeDestroyed() instead.
 67 }
 68 
 69 void RenderLayerModelObject::willBeDestroyed()
 70 {
 71     if (isPositioned()) {
 72         if (style().hasViewportConstrainedPosition())
 73             view().frameView().removeViewportConstrainedObject(this);
 74     }
 75 
 76     if (hasLayer()) {
 77         setHasLayer(false);
 78         destroyLayer();
 79     }
 80 
 81     RenderElement::willBeDestroyed();
 82 
 83     clearRepaintLayoutRects();
 84 }
 85 
 86 void RenderLayerModelObject::destroyLayer()
 87 {
 88     ASSERT(!hasLayer());
 89     ASSERT(m_layer);
 90     if (m_layer-&gt;isSelfPaintingLayer())
 91         clearRepaintLayoutRects();
 92     m_layer = nullptr;
 93 }
 94 
 95 void RenderLayerModelObject::createLayer()
 96 {
 97     ASSERT(!m_layer);
 98     m_layer = makeUnique&lt;RenderLayer&gt;(*this);
 99     setHasLayer(true);
100     m_layer-&gt;insertOnlyThisLayer(RenderLayer::LayerChangeTiming::StyleChange);
101 }
102 
103 bool RenderLayerModelObject::hasSelfPaintingLayer() const
104 {
105     return m_layer &amp;&amp; m_layer-&gt;isSelfPaintingLayer();
106 }
107 
108 void RenderLayerModelObject::styleWillChange(StyleDifference diff, const RenderStyle&amp; newStyle)
109 {
110     s_wasFloating = isFloating();
111     s_hadLayer = hasLayer();
112     s_hadTransform = hasTransform();
113     if (s_hadLayer)
114         s_layerWasSelfPainting = layer()-&gt;isSelfPaintingLayer();
115 
116     // If our z-index changes value or our visibility changes,
117     // we need to dirty our stacking context&#39;s z-order list.
118     const RenderStyle* oldStyle = hasInitializedStyle() ? &amp;style() : nullptr;
119     if (oldStyle) {
120         if (parent()) {
121             // Do a repaint with the old style first, e.g., for example if we go from
122             // having an outline to not having an outline.
123             if (diff == StyleDifference::RepaintLayer) {
124                 layer()-&gt;repaintIncludingDescendants();
125                 if (!(oldStyle-&gt;clip() == newStyle.clip()))
126                     layer()-&gt;clearClipRectsIncludingDescendants();
127             } else if (diff == StyleDifference::Repaint || newStyle.outlineSize() &lt; oldStyle-&gt;outlineSize())
128                 repaint();
129         }
130 
131         if (diff == StyleDifference::Layout || diff == StyleDifference::SimplifiedLayout) {
132             // When a layout hint happens, we do a repaint of the layer, since the layer could end up being destroyed.
133             if (hasLayer()) {
134                 if (oldStyle-&gt;position() != newStyle.position()
135                     || oldStyle-&gt;usedZIndex() != newStyle.usedZIndex()
136                     || oldStyle-&gt;hasAutoUsedZIndex() != newStyle.hasAutoUsedZIndex()
137                     || !(oldStyle-&gt;clip() == newStyle.clip())
138                     || oldStyle-&gt;hasClip() != newStyle.hasClip()
139                     || oldStyle-&gt;opacity() != newStyle.opacity()
140                     || oldStyle-&gt;transform() != newStyle.transform()
141                     || oldStyle-&gt;filter() != newStyle.filter()
142                     )
143                 layer()-&gt;repaintIncludingDescendants();
144             } else if (newStyle.hasTransform() || newStyle.opacity() &lt; 1 || newStyle.hasFilter() || newStyle.hasBackdropFilter()) {
145                 // If we don&#39;t have a layer yet, but we are going to get one because of transform or opacity,
146                 //  then we need to repaint the old position of the object.
147                 repaint();
148             }
149         }
150     }
151 
152     RenderElement::styleWillChange(diff, newStyle);
153 }
154 
155 #if ENABLE(CSS_SCROLL_SNAP)
156 static bool scrollSnapContainerRequiresUpdateForStyleUpdate(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
157 {
158     return oldStyle.scrollSnapPort() != newStyle.scrollSnapPort();
159 }
160 #endif
161 
162 void RenderLayerModelObject::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
163 {
164     RenderElement::styleDidChange(diff, oldStyle);
165     updateFromStyle();
166 
167     if (requiresLayer()) {
168         if (!layer() &amp;&amp; layerCreationAllowedForSubtree()) {
169             if (s_wasFloating &amp;&amp; isFloating())
170                 setChildNeedsLayout();
171             createLayer();
172             if (parent() &amp;&amp; !needsLayout() &amp;&amp; containingBlock())
173                 layer()-&gt;setRepaintStatus(NeedsFullRepaint);
174         }
175     } else if (layer() &amp;&amp; layer()-&gt;parent()) {
176 #if ENABLE(CSS_COMPOSITING)
177         if (oldStyle-&gt;hasBlendMode())
178             layer()-&gt;willRemoveChildWithBlendMode();
179 #endif
180         setHasTransformRelatedProperty(false); // All transform-related properties force layers, so we know we don&#39;t have one or the object doesn&#39;t support them.
181         setHasReflection(false);
182         // Repaint the about to be destroyed self-painting layer when style change also triggers repaint.
183         if (layer()-&gt;isSelfPaintingLayer() &amp;&amp; layer()-&gt;repaintStatus() == NeedsFullRepaint &amp;&amp; hasRepaintLayoutRects())
184             repaintUsingContainer(containerForRepaint(), repaintLayoutRects().m_repaintRect);
185 
186         layer()-&gt;removeOnlyThisLayer(RenderLayer::LayerChangeTiming::StyleChange); // calls destroyLayer() which clears m_layer
187         if (s_wasFloating &amp;&amp; isFloating())
188             setChildNeedsLayout();
189         if (s_hadTransform)
190             setNeedsLayoutAndPrefWidthsRecalc();
191     }
192 
193     if (layer()) {
194         layer()-&gt;styleChanged(diff, oldStyle);
195         if (s_hadLayer &amp;&amp; layer()-&gt;isSelfPaintingLayer() != s_layerWasSelfPainting)
196             setChildNeedsLayout();
197     }
198 
199     bool newStyleIsViewportConstrained = style().hasViewportConstrainedPosition();
200     bool oldStyleIsViewportConstrained = oldStyle &amp;&amp; oldStyle-&gt;hasViewportConstrainedPosition();
201     if (newStyleIsViewportConstrained != oldStyleIsViewportConstrained) {
202         if (newStyleIsViewportConstrained &amp;&amp; layer())
203             view().frameView().addViewportConstrainedObject(this);
204         else
205             view().frameView().removeViewportConstrainedObject(this);
206     }
207 
208 #if ENABLE(CSS_SCROLL_SNAP)
209     const RenderStyle&amp; newStyle = style();
210     if (oldStyle &amp;&amp; scrollSnapContainerRequiresUpdateForStyleUpdate(*oldStyle, newStyle)) {
211         if (RenderLayer* renderLayer = layer()) {
212             renderLayer-&gt;updateSnapOffsets();
213             renderLayer-&gt;updateScrollSnapState();
214         } else if (isBody() || isDocumentElementRenderer()) {
215             FrameView&amp; frameView = view().frameView();
216             frameView.updateSnapOffsets();
217             frameView.updateScrollSnapState();
218             frameView.updateScrollingCoordinatorScrollSnapProperties();
219         }
220     }
221     if (oldStyle &amp;&amp; oldStyle-&gt;scrollSnapArea() != newStyle.scrollSnapArea()) {
222         auto* scrollSnapBox = enclosingScrollableContainerForSnapping();
223         if (scrollSnapBox &amp;&amp; scrollSnapBox-&gt;layer()) {
224             const RenderStyle&amp; style = scrollSnapBox-&gt;style();
225             if (style.scrollSnapType().strictness != ScrollSnapStrictness::None) {
226                 scrollSnapBox-&gt;layer()-&gt;updateSnapOffsets();
227                 scrollSnapBox-&gt;layer()-&gt;updateScrollSnapState();
228                 if (scrollSnapBox-&gt;isBody() || scrollSnapBox-&gt;isDocumentElementRenderer())
229                     scrollSnapBox-&gt;view().frameView().updateScrollingCoordinatorScrollSnapProperties();
230             }
231         }
232     }
233 #endif
234 }
235 
236 bool RenderLayerModelObject::shouldPlaceBlockDirectionScrollbarOnLeft() const
237 {
238 // RTL Scrollbars require some system support, and this system support does not exist on certain versions of OS X. iOS uses a separate mechanism.
239 #if PLATFORM(IOS_FAMILY)
240     return false;
241 #else
242     switch (settings().userInterfaceDirectionPolicy()) {
243     case UserInterfaceDirectionPolicy::Content:
244         return style().shouldPlaceBlockDirectionScrollbarOnLeft();
245     case UserInterfaceDirectionPolicy::System:
246         return settings().systemLayoutDirection() == TextDirection::RTL;
247     }
248     ASSERT_NOT_REACHED();
249     return style().shouldPlaceBlockDirectionScrollbarOnLeft();
250 #endif
251 }
252 
253 bool RenderLayerModelObject::hasRepaintLayoutRects() const
254 {
255     return gRepaintLayoutRectsMap &amp;&amp; gRepaintLayoutRectsMap-&gt;contains(this);
256 }
257 
258 void RenderLayerModelObject::setRepaintLayoutRects(const RepaintLayoutRects&amp; rects)
259 {
260     if (!gRepaintLayoutRectsMap)
261         gRepaintLayoutRectsMap = new RepaintLayoutRectsMap();
262     gRepaintLayoutRectsMap-&gt;set(this, rects);
263 }
264 
265 void RenderLayerModelObject::clearRepaintLayoutRects()
266 {
267     if (gRepaintLayoutRectsMap)
268         gRepaintLayoutRectsMap-&gt;remove(this);
269 }
270 
271 RepaintLayoutRects RenderLayerModelObject::repaintLayoutRects() const
272 {
273     if (!hasRepaintLayoutRects())
274         return RepaintLayoutRects();
275     return gRepaintLayoutRectsMap-&gt;get(this);
276 }
277 
278 void RenderLayerModelObject::computeRepaintLayoutRects(const RenderLayerModelObject* repaintContainer, const RenderGeometryMap* geometryMap)
279 {
280     if (!m_layer || !m_layer-&gt;isSelfPaintingLayer())
281         clearRepaintLayoutRects();
282     else
283         setRepaintLayoutRects(RepaintLayoutRects(*this, repaintContainer, geometryMap));
284 }
285 
286 bool RenderLayerModelObject::startTransition(double timeOffset, CSSPropertyID propertyId, const RenderStyle* fromStyle, const RenderStyle* toStyle)
287 {
288     if (!layer() || !layer()-&gt;backing())
289         return false;
290     return layer()-&gt;backing()-&gt;startTransition(timeOffset, propertyId, fromStyle, toStyle);
291 }
292 
293 void RenderLayerModelObject::transitionPaused(double timeOffset, CSSPropertyID propertyId)
294 {
295     if (!layer() || !layer()-&gt;backing())
296         return;
297     layer()-&gt;backing()-&gt;transitionPaused(timeOffset, propertyId);
298 }
299 
300 void RenderLayerModelObject::transitionFinished(CSSPropertyID propertyId)
301 {
302     if (!layer() || !layer()-&gt;backing())
303         return;
304     layer()-&gt;backing()-&gt;transitionFinished(propertyId);
305 }
306 
307 bool RenderLayerModelObject::startAnimation(double timeOffset, const Animation&amp; animation, const KeyframeList&amp; keyframes)
308 {
309     if (!layer() || !layer()-&gt;backing())
310         return false;
311     return layer()-&gt;backing()-&gt;startAnimation(timeOffset, animation, keyframes);
312 }
313 
314 void RenderLayerModelObject::animationPaused(double timeOffset, const String&amp; name)
315 {
316     if (!layer() || !layer()-&gt;backing())
317         return;
318     layer()-&gt;backing()-&gt;animationPaused(timeOffset, name);
319 }
320 
321 void RenderLayerModelObject::animationSeeked(double timeOffset, const String&amp; name)
322 {
323     if (!layer() || !layer()-&gt;backing())
324         return;
325     layer()-&gt;backing()-&gt;animationSeeked(timeOffset, name);
326 }
327 
328 void RenderLayerModelObject::animationFinished(const String&amp; name)
329 {
330     if (!layer() || !layer()-&gt;backing())
331         return;
332     layer()-&gt;backing()-&gt;animationFinished(name);
333 }
334 
335 void RenderLayerModelObject::suspendAnimations(MonotonicTime time)
336 {
337     if (!layer() || !layer()-&gt;backing())
338         return;
339     layer()-&gt;backing()-&gt;suspendAnimations(time);
340 }
341 
342 } // namespace WebCore
343 
    </pre>
  </body>
</html>
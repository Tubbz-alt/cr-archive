<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/filters/FilterEffect.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2008 Alex Mathews &lt;possessedpenguinbob@gmail.com&gt;
  3  * Copyright (C) 2009 Dirk Schulze &lt;krit@webkit.org&gt;
  4  * Copyright (C) Research In Motion Limited 2010. All rights reserved.
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB.  If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;ColorSpace.h&quot;
 25 #include &quot;FloatRect.h&quot;
 26 #include &quot;IntRect.h&quot;
<a name="1" id="anc1"></a>
 27 #include &lt;JavaScriptCore/Uint8ClampedArray.h&gt;
 28 #include &lt;wtf/MathExtras.h&gt;
 29 #include &lt;wtf/RefCounted.h&gt;
 30 #include &lt;wtf/RefPtr.h&gt;
 31 #include &lt;wtf/Vector.h&gt;
 32 
 33 namespace WTF {
 34 class TextStream;
 35 }
 36 
 37 namespace WebCore {
 38 
 39 class Filter;
 40 class FilterEffect;
 41 class ImageBuffer;
 42 
 43 typedef Vector&lt;RefPtr&lt;FilterEffect&gt;&gt; FilterEffectVector;
 44 
 45 enum FilterEffectType {
 46     FilterEffectTypeUnknown,
 47     FilterEffectTypeImage,
 48     FilterEffectTypeTile,
 49     FilterEffectTypeSourceInput
 50 };
 51 
 52 class FilterEffect : public RefCounted&lt;FilterEffect&gt; {
 53 public:
 54     virtual ~FilterEffect();
 55 
 56     void clearResult();
 57     void clearResultsRecursive();
 58 
 59     ImageBuffer* imageBufferResult();
 60     RefPtr&lt;Uint8ClampedArray&gt; unmultipliedResult(const IntRect&amp;);
 61     RefPtr&lt;Uint8ClampedArray&gt; premultipliedResult(const IntRect&amp;);
 62 
 63     void copyUnmultipliedResult(Uint8ClampedArray&amp; destination, const IntRect&amp;);
 64     void copyPremultipliedResult(Uint8ClampedArray&amp; destination, const IntRect&amp;);
 65 
 66     FilterEffectVector&amp; inputEffects() { return m_inputEffects; }
 67     FilterEffect* inputEffect(unsigned) const;
 68     unsigned numberOfEffectInputs() const { return m_inputEffects.size(); }
 69     unsigned totalNumberOfEffectInputs() const;
 70 
 71     inline bool hasResult() const
 72     {
 73         // This function needs platform specific checks, if the memory managment is not done by FilterEffect.
 74         return m_imageBufferResult
 75             || m_unmultipliedImageResult
 76             || m_premultipliedImageResult;
 77     }
 78 
 79     FloatRect drawingRegionOfInputImage(const IntRect&amp;) const;
 80     IntRect requestedRegionOfInputImageData(const IntRect&amp;) const;
 81 
 82     // Recurses on inputs.
 83     FloatRect determineFilterPrimitiveSubregion();
 84 
 85     // Solid black image with different alpha values.
 86     bool isAlphaImage() const { return m_alphaImage; }
 87     void setIsAlphaImage(bool alphaImage) { m_alphaImage = alphaImage; }
 88 
 89     IntRect absolutePaintRect() const { return m_absolutePaintRect; }
 90     void setAbsolutePaintRect(const IntRect&amp; absolutePaintRect) { m_absolutePaintRect = absolutePaintRect; }
 91 
 92     FloatRect maxEffectRect() const { return m_maxEffectRect; }
 93     void setMaxEffectRect(const FloatRect&amp; maxEffectRect) { m_maxEffectRect = maxEffectRect; }
 94 
 95     void apply();
 96 
 97     // Correct any invalid pixels, if necessary, in the result of a filter operation.
 98     // This method is used to ensure valid pixel values on filter inputs and the final result.
 99     // Only the arithmetic composite filter ever needs to perform correction.
100     virtual void correctFilterResultIfNeeded() { }
101 
102     virtual void determineAbsolutePaintRect();
103 
104     virtual FilterEffectType filterEffectType() const { return FilterEffectTypeUnknown; }
105 
<a name="2" id="anc2"></a>

106     enum class RepresentationType { TestOutput, Debugging };
107     virtual WTF::TextStream&amp; externalRepresentation(WTF::TextStream&amp;, RepresentationType = RepresentationType::TestOutput) const;
108 
109     // The following functions are SVG specific and will move to RenderSVGResourceFilterPrimitive.
110     // See bug https://bugs.webkit.org/show_bug.cgi?id=45614.
111     bool hasX() const { return m_hasX; }
112     void setHasX(bool value) { m_hasX = value; }
113 
114     bool hasY() const { return m_hasY; }
115     void setHasY(bool value) { m_hasY = value; }
116 
117     bool hasWidth() const { return m_hasWidth; }
118     void setHasWidth(bool value) { m_hasWidth = value; }
119 
120     bool hasHeight() const { return m_hasHeight; }
121     void setHasHeight(bool value) { m_hasHeight = value; }
122 
123     FloatRect filterPrimitiveSubregion() const { return m_filterPrimitiveSubregion; }
124     void setFilterPrimitiveSubregion(const FloatRect&amp; filterPrimitiveSubregion) { m_filterPrimitiveSubregion = filterPrimitiveSubregion; }
125 
126     FloatRect effectBoundaries() const { return m_effectBoundaries; }
127     void setEffectBoundaries(const FloatRect&amp; effectBoundaries) { m_effectBoundaries = effectBoundaries; }
128 
129     void setUnclippedAbsoluteSubregion(const FloatRect&amp; r) { m_absoluteUnclippedSubregion = r; }
130 
131     FloatPoint mapPointFromUserSpaceToBuffer(FloatPoint) const;
132 
133     Filter&amp; filter() { return m_filter; }
134     const Filter&amp; filter() const { return m_filter; }
135 
136     bool clipsToBounds() const { return m_clipsToBounds; }
137     void setClipsToBounds(bool value) { m_clipsToBounds = value; }
138 
139     ColorSpace operatingColorSpace() const { return m_operatingColorSpace; }
140     virtual void setOperatingColorSpace(ColorSpace colorSpace) { m_operatingColorSpace = colorSpace; }
141     ColorSpace resultColorSpace() const { return m_resultColorSpace; }
142     virtual void setResultColorSpace(ColorSpace colorSpace) { m_resultColorSpace = colorSpace; }
143 
144     virtual void transformResultColorSpace(FilterEffect* in, const int) { in-&gt;transformResultColorSpace(m_operatingColorSpace); }
145     void transformResultColorSpace(ColorSpace);
146 
147 protected:
148     FilterEffect(Filter&amp;);
149 
150     virtual const char* filterName() const = 0;
151 
152     ImageBuffer* createImageBufferResult();
153     Uint8ClampedArray* createUnmultipliedImageResult();
154     Uint8ClampedArray* createPremultipliedImageResult();
155 
156     // Return true if the filter will only operate correctly on valid RGBA values, with
157     // alpha in [0,255] and each color component in [0, alpha].
158     virtual bool requiresValidPreMultipliedPixels() { return true; }
159 
160     // If a pre-multiplied image, check every pixel for validity and correct if necessary.
161     void forceValidPreMultipliedPixels();
162 
163     void clipAbsolutePaintRect();
164 
165     static Vector&lt;float&gt; normalizedFloats(const Vector&lt;float&gt;&amp; values)
166     {
167         Vector&lt;float&gt; normalizedValues(values.size());
168         for (size_t i = 0; i &lt; values.size(); ++i)
169             normalizedValues[i] = normalizedFloat(values[i]);
170         return normalizedValues;
171     }
172 
173 private:
174     virtual void platformApplySoftware() = 0;
175 
176     void copyImageBytes(const Uint8ClampedArray&amp; source, Uint8ClampedArray&amp; destination, const IntRect&amp;) const;
177 
178     Filter&amp; m_filter;
179     FilterEffectVector m_inputEffects;
180 
181     std::unique_ptr&lt;ImageBuffer&gt; m_imageBufferResult;
182     RefPtr&lt;Uint8ClampedArray&gt; m_unmultipliedImageResult;
183     RefPtr&lt;Uint8ClampedArray&gt; m_premultipliedImageResult;
184 
185     IntRect m_absolutePaintRect;
186 
187     // The maximum size of a filter primitive. In SVG this is the primitive subregion in absolute coordinate space.
188     // The absolute paint rect should never be bigger than m_maxEffectRect.
189     FloatRect m_maxEffectRect;
190 
191     // The subregion of a filter primitive according to the SVG Filter specification in local coordinates.
192     // This is SVG specific and needs to move to RenderSVGResourceFilterPrimitive.
193     FloatRect m_filterPrimitiveSubregion;
194 
195     // x, y, width and height of the actual SVGFE*Element. Is needed to determine the subregion of the
196     // filter primitive on a later step.
197     FloatRect m_effectBoundaries;
198 
199     // filterPrimitiveSubregion mapped to absolute coordinates before clipping.
200     FloatRect m_absoluteUnclippedSubregion;
201 
202     bool m_alphaImage { false };
203     bool m_hasX { false };
204     bool m_hasY { false };
205     bool m_hasWidth { false };
206     bool m_hasHeight { false };
207 
208     // Should the effect clip to its primitive region, or expand to use the combined region of its inputs.
209     bool m_clipsToBounds { true };
210 
<a name="3" id="anc3"></a><span class="line-modified">211     ColorSpace m_operatingColorSpace { ColorSpaceLinearRGB };</span>
<span class="line-modified">212     ColorSpace m_resultColorSpace { ColorSpaceSRGB };</span>
213 };
214 
215 WEBCORE_EXPORT WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const FilterEffect&amp;);
216 
217 } // namespace WebCore
218 
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSHTMLElementCustom.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSHTMLDocumentCustom.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSHTMLTemplateElementCustom.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSHTMLElementCustom.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 39,95 ***</span>
  
  namespace WebCore {
  
  using namespace JSC;
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL constructJSHTMLElement(ExecState&amp; exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     auto* jsConstructor = jsCast&lt;JSDOMConstructorBase*&gt;(exec.jsCallee());</span>
      ASSERT(jsConstructor);
  
      auto* context = jsConstructor-&gt;scriptExecutionContext();
      if (!context)
<span class="line-modified">!         return throwConstructorScriptExecutionContextUnavailableError(exec, scope, &quot;HTMLElement&quot;);</span>
      ASSERT(context-&gt;isDocument());
  
<span class="line-modified">!     JSValue newTargetValue = exec.thisValue();</span>
      auto* newTarget = newTargetValue.getObject();
<span class="line-modified">!     auto* globalObject = jsCast&lt;JSDOMGlobalObject*&gt;(newTarget-&gt;globalObject(vm));</span>
<span class="line-modified">!     JSValue htmlElementConstructorValue = JSHTMLElement::getConstructor(vm, globalObject);</span>
      if (newTargetValue == htmlElementConstructorValue)
<span class="line-modified">!         return throwVMTypeError(&amp;exec, scope, &quot;new.target is not a valid custom element constructor&quot;_s);</span>
  
      auto&amp; document = downcast&lt;Document&gt;(*context);
  
      auto* window = document.domWindow();
      if (!window)
<span class="line-modified">!         return throwVMTypeError(&amp;exec, scope, &quot;new.target is not a valid custom element constructor&quot;_s);</span>
  
      auto* registry = window-&gt;customElementRegistry();
      if (!registry)
<span class="line-modified">!         return throwVMTypeError(&amp;exec, scope, &quot;new.target is not a valid custom element constructor&quot;_s);</span>
  
      auto* elementInterface = registry-&gt;findInterface(newTarget);
      if (!elementInterface)
<span class="line-modified">!         return throwVMTypeError(&amp;exec, scope, &quot;new.target does not define a custom element&quot;_s);</span>
  
      if (!elementInterface-&gt;isUpgradingElement()) {
<span class="line-modified">!         Structure* baseStructure = getDOMStructure&lt;JSHTMLElement&gt;(vm, *globalObject);</span>
<span class="line-modified">!         auto* newElementStructure = InternalFunction::createSubclassStructure(&amp;exec, newTargetValue, baseStructure);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
          Ref&lt;HTMLElement&gt; element = HTMLElement::create(elementInterface-&gt;name(), document);
          element-&gt;setIsDefinedCustomElement(*elementInterface);
<span class="line-modified">!         auto* jsElement = JSHTMLElement::create(newElementStructure, globalObject, element.get());</span>
<span class="line-modified">!         cacheWrapper(globalObject-&gt;world(), element.ptr(), jsElement);</span>
          return JSValue::encode(jsElement);
      }
  
      Element* elementToUpgrade = elementInterface-&gt;lastElementInConstructionStack();
      if (!elementToUpgrade) {
<span class="line-modified">!         throwTypeError(&amp;exec, scope, &quot;Cannot instantiate a custom element inside its own constructor during upgrades&quot;_s);</span>
          return JSValue::encode(jsUndefined());
      }
  
<span class="line-modified">!     JSValue elementWrapperValue = toJS(&amp;exec, jsConstructor-&gt;globalObject(), *elementToUpgrade);</span>
      ASSERT(elementWrapperValue.isObject());
  
<span class="line-modified">!     JSValue newPrototype = newTarget-&gt;get(&amp;exec, vm.propertyNames-&gt;prototype);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      JSObject* elementWrapperObject = asObject(elementWrapperValue);
<span class="line-modified">!     JSObject::setPrototype(elementWrapperObject, &amp;exec, newPrototype, true /* shouldThrowIfCantSet */);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      elementInterface-&gt;didUpgradeLastElementInConstructionStack();
  
      return JSValue::encode(elementWrapperValue);
  }
  
<span class="line-modified">! JSScope* JSHTMLElement::pushEventHandlerScope(ExecState* exec, JSScope* scope) const</span>
  {
      HTMLElement&amp; element = wrapped();
  
      // The document is put on first, fall back to searching it only after the element and form.
      // FIXME: This probably may use the wrong global object. If this is called from a native
      // function, then it would be correct but not optimal since the native function would *know*
      // the global object. But, it may be that globalObject() is more correct.
      // https://bugs.webkit.org/show_bug.cgi?id=134932
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">-     JSGlobalObject* lexicalGlobalObject = exec-&gt;lexicalGlobalObject();</span>
  
<span class="line-modified">!     scope = JSWithScope::create(vm, lexicalGlobalObject, scope, asObject(toJS(exec, globalObject(), element.document())));</span>
  
      // The form is next, searched before the document, but after the element itself.
      if (HTMLFormElement* form = element.form())
<span class="line-modified">!         scope = JSWithScope::create(vm, lexicalGlobalObject, scope, asObject(toJS(exec, globalObject(), *form)));</span>
  
      // The element is on top, searched first.
<span class="line-modified">!     return JSWithScope::create(vm, lexicalGlobalObject, scope, asObject(toJS(exec, globalObject(), element)));</span>
  }
  
  } // namespace WebCore
<span class="line-new-header">--- 39,94 ---</span>
  
  namespace WebCore {
  
  using namespace JSC;
  
<span class="line-modified">! EncodedJSValue constructJSHTMLElement(JSGlobalObject* lexicalGlobalObject, CallFrame&amp; callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     auto* jsConstructor = jsCast&lt;JSDOMConstructorBase*&gt;(callFrame.jsCallee());</span>
      ASSERT(jsConstructor);
  
      auto* context = jsConstructor-&gt;scriptExecutionContext();
      if (!context)
<span class="line-modified">!         return throwConstructorScriptExecutionContextUnavailableError(*lexicalGlobalObject, scope, &quot;HTMLElement&quot;);</span>
      ASSERT(context-&gt;isDocument());
  
<span class="line-modified">!     JSValue newTargetValue = callFrame.thisValue();</span>
      auto* newTarget = newTargetValue.getObject();
<span class="line-modified">!     auto* newTargetGlobalObject = jsCast&lt;JSDOMGlobalObject*&gt;(newTarget-&gt;globalObject(vm));</span>
<span class="line-modified">!     JSValue htmlElementConstructorValue = JSHTMLElement::getConstructor(vm, newTargetGlobalObject);</span>
      if (newTargetValue == htmlElementConstructorValue)
<span class="line-modified">!         return throwVMTypeError(lexicalGlobalObject, scope, &quot;new.target is not a valid custom element constructor&quot;_s);</span>
  
      auto&amp; document = downcast&lt;Document&gt;(*context);
  
      auto* window = document.domWindow();
      if (!window)
<span class="line-modified">!         return throwVMTypeError(lexicalGlobalObject, scope, &quot;new.target is not a valid custom element constructor&quot;_s);</span>
  
      auto* registry = window-&gt;customElementRegistry();
      if (!registry)
<span class="line-modified">!         return throwVMTypeError(lexicalGlobalObject, scope, &quot;new.target is not a valid custom element constructor&quot;_s);</span>
  
      auto* elementInterface = registry-&gt;findInterface(newTarget);
      if (!elementInterface)
<span class="line-modified">!         return throwVMTypeError(lexicalGlobalObject, scope, &quot;new.target does not define a custom element&quot;_s);</span>
  
      if (!elementInterface-&gt;isUpgradingElement()) {
<span class="line-modified">!         Structure* baseStructure = getDOMStructure&lt;JSHTMLElement&gt;(vm, *newTargetGlobalObject);</span>
<span class="line-modified">!         auto* newElementStructure = InternalFunction::createSubclassStructure(lexicalGlobalObject, jsConstructor, newTargetValue, baseStructure);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
          Ref&lt;HTMLElement&gt; element = HTMLElement::create(elementInterface-&gt;name(), document);
          element-&gt;setIsDefinedCustomElement(*elementInterface);
<span class="line-modified">!         auto* jsElement = JSHTMLElement::create(newElementStructure, newTargetGlobalObject, element.get());</span>
<span class="line-modified">!         cacheWrapper(newTargetGlobalObject-&gt;world(), element.ptr(), jsElement);</span>
          return JSValue::encode(jsElement);
      }
  
      Element* elementToUpgrade = elementInterface-&gt;lastElementInConstructionStack();
      if (!elementToUpgrade) {
<span class="line-modified">!         throwTypeError(lexicalGlobalObject, scope, &quot;Cannot instantiate a custom element inside its own constructor during upgrades&quot;_s);</span>
          return JSValue::encode(jsUndefined());
      }
  
<span class="line-modified">!     JSValue elementWrapperValue = toJS(lexicalGlobalObject, jsConstructor-&gt;globalObject(), *elementToUpgrade);</span>
      ASSERT(elementWrapperValue.isObject());
  
<span class="line-modified">!     JSValue newPrototype = newTarget-&gt;get(lexicalGlobalObject, vm.propertyNames-&gt;prototype);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      JSObject* elementWrapperObject = asObject(elementWrapperValue);
<span class="line-modified">!     JSObject::setPrototype(elementWrapperObject, lexicalGlobalObject, newPrototype, true /* shouldThrowIfCantSet */);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      elementInterface-&gt;didUpgradeLastElementInConstructionStack();
  
      return JSValue::encode(elementWrapperValue);
  }
  
<span class="line-modified">! JSScope* JSHTMLElement::pushEventHandlerScope(JSGlobalObject* lexicalGlobalObject, JSScope* scope) const</span>
  {
      HTMLElement&amp; element = wrapped();
  
      // The document is put on first, fall back to searching it only after the element and form.
      // FIXME: This probably may use the wrong global object. If this is called from a native
      // function, then it would be correct but not optimal since the native function would *know*
      // the global object. But, it may be that globalObject() is more correct.
      // https://bugs.webkit.org/show_bug.cgi?id=134932
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
  
<span class="line-modified">!     scope = JSWithScope::create(vm, lexicalGlobalObject, scope, asObject(toJS(lexicalGlobalObject, globalObject(), element.document())));</span>
  
      // The form is next, searched before the document, but after the element itself.
      if (HTMLFormElement* form = element.form())
<span class="line-modified">!         scope = JSWithScope::create(vm, lexicalGlobalObject, scope, asObject(toJS(lexicalGlobalObject, globalObject(), *form)));</span>
  
      // The element is on top, searched first.
<span class="line-modified">!     return JSWithScope::create(vm, lexicalGlobalObject, scope, asObject(toJS(lexicalGlobalObject, globalObject(), element)));</span>
  }
  
  } // namespace WebCore
</pre>
<center><a href="JSHTMLDocumentCustom.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSHTMLTemplateElementCustom.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParserSelector.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSParserObserver.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSParserSelector.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParserSelector.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 36 {
 37     CSSSelector::PagePseudoClassType pseudoType;
 38     if (equalLettersIgnoringASCIICase(pseudoTypeString, &quot;first&quot;))
 39         pseudoType = CSSSelector::PagePseudoClassFirst;
 40     else if (equalLettersIgnoringASCIICase(pseudoTypeString, &quot;left&quot;))
 41         pseudoType = CSSSelector::PagePseudoClassLeft;
 42     else if (equalLettersIgnoringASCIICase(pseudoTypeString, &quot;right&quot;))
 43         pseudoType = CSSSelector::PagePseudoClassRight;
 44     else
 45         return nullptr;
 46 
 47     auto selector = makeUnique&lt;CSSParserSelector&gt;();
 48     selector-&gt;m_selector-&gt;setMatch(CSSSelector::PagePseudoClass);
 49     selector-&gt;m_selector-&gt;setPagePseudoType(pseudoType);
 50     return selector;
 51 }
 52 
 53 std::unique_ptr&lt;CSSParserSelector&gt; CSSParserSelector::parsePseudoElementSelector(StringView pseudoTypeString)
 54 {
 55     auto pseudoType = CSSSelector::parsePseudoElementType(pseudoTypeString);
<span class="line-modified"> 56     if (pseudoType == CSSSelector::PseudoElementUnknown) {</span>
<span class="line-modified"> 57         // FIXME-NEWPARSER: We can&#39;t add &quot;slotted&quot; to the map without breaking the old</span>
<span class="line-removed"> 58         // parser, so this hack ensures the new parser still recognizes it. When the new</span>
<span class="line-removed"> 59         // parser turns on, we can add &quot;slotted&quot; to the map and remove this code.</span>
<span class="line-removed"> 60         if (pseudoTypeString.startsWithIgnoringASCIICase(&quot;slotted&quot;))</span>
<span class="line-removed"> 61             pseudoType = CSSSelector::PseudoElementSlotted;</span>
<span class="line-removed"> 62         else</span>
<span class="line-removed"> 63             return nullptr;</span>
<span class="line-removed"> 64     }</span>
 65 
 66     auto selector = makeUnique&lt;CSSParserSelector&gt;();
 67     selector-&gt;m_selector-&gt;setMatch(CSSSelector::PseudoElement);
 68     selector-&gt;m_selector-&gt;setPseudoElementType(pseudoType);
 69     AtomString name;
 70     if (pseudoType != CSSSelector::PseudoElementWebKitCustomLegacyPrefixed)
 71         name = pseudoTypeString.convertToASCIILowercase();
 72     else {
 73         ASSERT_WITH_MESSAGE(equalLettersIgnoringASCIICase(pseudoTypeString, &quot;-webkit-input-placeholder&quot;), &quot;-webkit-input-placeholder is the only LegacyPrefix pseudo type.&quot;);
 74         if (equalLettersIgnoringASCIICase(pseudoTypeString, &quot;-webkit-input-placeholder&quot;))
 75             name = AtomString(&quot;placeholder&quot;, AtomString::ConstructFromLiteral);
 76         else
 77             name = pseudoTypeString.convertToASCIILowercase();
 78     }
 79     selector-&gt;m_selector-&gt;setValue(name);
 80     return selector;
 81 }
 82 
 83 std::unique_ptr&lt;CSSParserSelector&gt; CSSParserSelector::parsePseudoClassSelector(StringView pseudoTypeString)
 84 {
</pre>
<hr />
<pre>
112 CSSParserSelector::~CSSParserSelector()
113 {
114     if (!m_tagHistory)
115         return;
116     Vector&lt;std::unique_ptr&lt;CSSParserSelector&gt;, 16&gt; toDelete;
117     std::unique_ptr&lt;CSSParserSelector&gt; selector = WTFMove(m_tagHistory);
118     while (true) {
119         std::unique_ptr&lt;CSSParserSelector&gt; next = WTFMove(selector-&gt;m_tagHistory);
120         toDelete.append(WTFMove(selector));
121         if (!next)
122             break;
123         selector = WTFMove(next);
124     }
125 }
126 
127 void CSSParserSelector::adoptSelectorVector(Vector&lt;std::unique_ptr&lt;CSSParserSelector&gt;&gt;&amp;&amp; selectorVector)
128 {
129     m_selector-&gt;setSelectorList(makeUnique&lt;CSSSelectorList&gt;(WTFMove(selectorVector)));
130 }
131 
<span class="line-modified">132 void CSSParserSelector::setLangArgumentList(std::unique_ptr&lt;Vector&lt;AtomString&gt;&gt; argumentList)</span>
133 {
134     ASSERT_WITH_MESSAGE(!argumentList-&gt;isEmpty(), &quot;No CSS Selector takes an empty argument list.&quot;);
<span class="line-modified">135     m_selector-&gt;setLangArgumentList(WTFMove(argumentList));</span>
136 }
137 
138 void CSSParserSelector::setSelectorList(std::unique_ptr&lt;CSSSelectorList&gt; selectorList)
139 {
140     m_selector-&gt;setSelectorList(WTFMove(selectorList));
141 }
142 
143 static bool selectorListMatchesPseudoElement(const CSSSelectorList* selectorList)
144 {
145     if (!selectorList)
146         return false;
147 
148     for (const CSSSelector* subSelector = selectorList-&gt;first(); subSelector; subSelector = CSSSelectorList::next(subSelector)) {
149         for (const CSSSelector* selector = subSelector; selector; selector = selector-&gt;tagHistory()) {
150             if (selector-&gt;matchesPseudoElement())
151                 return true;
152             if (const CSSSelectorList* subselectorList = selector-&gt;selectorList()) {
153                 if (selectorListMatchesPseudoElement(subselectorList))
154                     return true;
155             }
</pre>
</td>
<td>
<hr />
<pre>
 36 {
 37     CSSSelector::PagePseudoClassType pseudoType;
 38     if (equalLettersIgnoringASCIICase(pseudoTypeString, &quot;first&quot;))
 39         pseudoType = CSSSelector::PagePseudoClassFirst;
 40     else if (equalLettersIgnoringASCIICase(pseudoTypeString, &quot;left&quot;))
 41         pseudoType = CSSSelector::PagePseudoClassLeft;
 42     else if (equalLettersIgnoringASCIICase(pseudoTypeString, &quot;right&quot;))
 43         pseudoType = CSSSelector::PagePseudoClassRight;
 44     else
 45         return nullptr;
 46 
 47     auto selector = makeUnique&lt;CSSParserSelector&gt;();
 48     selector-&gt;m_selector-&gt;setMatch(CSSSelector::PagePseudoClass);
 49     selector-&gt;m_selector-&gt;setPagePseudoType(pseudoType);
 50     return selector;
 51 }
 52 
 53 std::unique_ptr&lt;CSSParserSelector&gt; CSSParserSelector::parsePseudoElementSelector(StringView pseudoTypeString)
 54 {
 55     auto pseudoType = CSSSelector::parsePseudoElementType(pseudoTypeString);
<span class="line-modified"> 56     if (pseudoType == CSSSelector::PseudoElementUnknown)</span>
<span class="line-modified"> 57         return nullptr;</span>







 58 
 59     auto selector = makeUnique&lt;CSSParserSelector&gt;();
 60     selector-&gt;m_selector-&gt;setMatch(CSSSelector::PseudoElement);
 61     selector-&gt;m_selector-&gt;setPseudoElementType(pseudoType);
 62     AtomString name;
 63     if (pseudoType != CSSSelector::PseudoElementWebKitCustomLegacyPrefixed)
 64         name = pseudoTypeString.convertToASCIILowercase();
 65     else {
 66         ASSERT_WITH_MESSAGE(equalLettersIgnoringASCIICase(pseudoTypeString, &quot;-webkit-input-placeholder&quot;), &quot;-webkit-input-placeholder is the only LegacyPrefix pseudo type.&quot;);
 67         if (equalLettersIgnoringASCIICase(pseudoTypeString, &quot;-webkit-input-placeholder&quot;))
 68             name = AtomString(&quot;placeholder&quot;, AtomString::ConstructFromLiteral);
 69         else
 70             name = pseudoTypeString.convertToASCIILowercase();
 71     }
 72     selector-&gt;m_selector-&gt;setValue(name);
 73     return selector;
 74 }
 75 
 76 std::unique_ptr&lt;CSSParserSelector&gt; CSSParserSelector::parsePseudoClassSelector(StringView pseudoTypeString)
 77 {
</pre>
<hr />
<pre>
105 CSSParserSelector::~CSSParserSelector()
106 {
107     if (!m_tagHistory)
108         return;
109     Vector&lt;std::unique_ptr&lt;CSSParserSelector&gt;, 16&gt; toDelete;
110     std::unique_ptr&lt;CSSParserSelector&gt; selector = WTFMove(m_tagHistory);
111     while (true) {
112         std::unique_ptr&lt;CSSParserSelector&gt; next = WTFMove(selector-&gt;m_tagHistory);
113         toDelete.append(WTFMove(selector));
114         if (!next)
115             break;
116         selector = WTFMove(next);
117     }
118 }
119 
120 void CSSParserSelector::adoptSelectorVector(Vector&lt;std::unique_ptr&lt;CSSParserSelector&gt;&gt;&amp;&amp; selectorVector)
121 {
122     m_selector-&gt;setSelectorList(makeUnique&lt;CSSSelectorList&gt;(WTFMove(selectorVector)));
123 }
124 
<span class="line-modified">125 void CSSParserSelector::setArgumentList(std::unique_ptr&lt;Vector&lt;AtomString&gt;&gt; argumentList)</span>
126 {
127     ASSERT_WITH_MESSAGE(!argumentList-&gt;isEmpty(), &quot;No CSS Selector takes an empty argument list.&quot;);
<span class="line-modified">128     m_selector-&gt;setArgumentList(WTFMove(argumentList));</span>
129 }
130 
131 void CSSParserSelector::setSelectorList(std::unique_ptr&lt;CSSSelectorList&gt; selectorList)
132 {
133     m_selector-&gt;setSelectorList(WTFMove(selectorList));
134 }
135 
136 static bool selectorListMatchesPseudoElement(const CSSSelectorList* selectorList)
137 {
138     if (!selectorList)
139         return false;
140 
141     for (const CSSSelector* subSelector = selectorList-&gt;first(); subSelector; subSelector = CSSSelectorList::next(subSelector)) {
142         for (const CSSSelector* selector = subSelector; selector; selector = selector-&gt;tagHistory()) {
143             if (selector-&gt;matchesPseudoElement())
144                 return true;
145             if (const CSSSelectorList* subselectorList = selector-&gt;selectorList()) {
146                 if (selectorListMatchesPseudoElement(subselectorList))
147                     return true;
148             }
</pre>
</td>
</tr>
</table>
<center><a href="CSSParserObserver.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSParserSelector.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
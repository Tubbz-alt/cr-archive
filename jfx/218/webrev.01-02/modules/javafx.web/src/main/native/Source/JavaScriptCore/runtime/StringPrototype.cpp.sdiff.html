<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StringPrototype.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StringObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StringPrototype.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StringPrototype.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;StringPrototype.h&quot;
  25 
  26 #include &quot;BuiltinNames.h&quot;
  27 #include &quot;ButterflyInlines.h&quot;
  28 #include &quot;CachedCall.h&quot;
  29 #include &quot;Error.h&quot;
  30 #include &quot;FrameTracers.h&quot;
  31 #include &quot;InterpreterInlines.h&quot;
  32 #include &quot;IntlCollator.h&quot;
  33 #include &quot;IntlObject.h&quot;
  34 #include &quot;JITCodeInlines.h&quot;
  35 #include &quot;JSArray.h&quot;
  36 #include &quot;JSCBuiltins.h&quot;
  37 #include &quot;JSCInlines.h&quot;
  38 #include &quot;JSFunction.h&quot;
  39 #include &quot;JSGlobalObjectFunctions.h&quot;
  40 #include &quot;JSStringIterator.h&quot;
  41 #include &quot;Lookup.h&quot;

  42 #include &quot;ObjectPrototype.h&quot;
  43 #include &quot;ParseInt.h&quot;
  44 #include &quot;PropertyNameArray.h&quot;
  45 #include &quot;RegExpCache.h&quot;
  46 #include &quot;RegExpConstructor.h&quot;
  47 #include &quot;RegExpGlobalDataInlines.h&quot;
  48 #include &quot;StringPrototypeInlines.h&quot;
  49 #include &quot;SuperSampler.h&quot;
  50 #include &lt;algorithm&gt;
  51 #include &lt;unicode/uconfig.h&gt;
  52 #include &lt;unicode/unorm2.h&gt;
  53 #include &lt;unicode/ustring.h&gt;
  54 #include &lt;wtf/ASCIICType.h&gt;
  55 #include &lt;wtf/MathExtras.h&gt;
  56 #include &lt;wtf/text/StringBuilder.h&gt;
  57 #include &lt;wtf/text/StringView.h&gt;
  58 #include &lt;wtf/unicode/Collator.h&gt;
  59 
  60 namespace JSC {
  61 
  62 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(StringPrototype);
  63 
<span class="line-modified">  64 EncodedJSValue JSC_HOST_CALL stringProtoFuncToString(ExecState*);</span>
<span class="line-modified">  65 EncodedJSValue JSC_HOST_CALL stringProtoFuncCharAt(ExecState*);</span>
<span class="line-modified">  66 EncodedJSValue JSC_HOST_CALL stringProtoFuncCharCodeAt(ExecState*);</span>
<span class="line-modified">  67 EncodedJSValue JSC_HOST_CALL stringProtoFuncCodePointAt(ExecState*);</span>
<span class="line-modified">  68 EncodedJSValue JSC_HOST_CALL stringProtoFuncIndexOf(ExecState*);</span>
<span class="line-modified">  69 EncodedJSValue JSC_HOST_CALL stringProtoFuncLastIndexOf(ExecState*);</span>
<span class="line-modified">  70 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingRegExp(ExecState*);</span>
<span class="line-modified">  71 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingStringSearch(ExecState*);</span>
<span class="line-modified">  72 EncodedJSValue JSC_HOST_CALL stringProtoFuncSlice(ExecState*);</span>
<span class="line-modified">  73 EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstr(ExecState*);</span>
<span class="line-modified">  74 EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstring(ExecState*);</span>
<span class="line-modified">  75 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLowerCase(ExecState*);</span>
<span class="line-modified">  76 EncodedJSValue JSC_HOST_CALL stringProtoFuncToUpperCase(ExecState*);</span>
<span class="line-modified">  77 EncodedJSValue JSC_HOST_CALL stringProtoFuncLocaleCompare(ExecState*);</span>
<span class="line-modified">  78 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleLowerCase(ExecState*);</span>
<span class="line-modified">  79 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleUpperCase(ExecState*);</span>
<span class="line-modified">  80 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrim(ExecState*);</span>
<span class="line-modified">  81 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimStart(ExecState*);</span>
<span class="line-modified">  82 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimEnd(ExecState*);</span>
<span class="line-modified">  83 EncodedJSValue JSC_HOST_CALL stringProtoFuncStartsWith(ExecState*);</span>
<span class="line-modified">  84 EncodedJSValue JSC_HOST_CALL stringProtoFuncEndsWith(ExecState*);</span>
<span class="line-modified">  85 EncodedJSValue JSC_HOST_CALL stringProtoFuncIncludes(ExecState*);</span>
<span class="line-modified">  86 EncodedJSValue JSC_HOST_CALL stringProtoFuncNormalize(ExecState*);</span>
<span class="line-modified">  87 EncodedJSValue JSC_HOST_CALL stringProtoFuncIterator(ExecState*);</span>

  88 
  89 }
  90 
  91 #include &quot;StringPrototype.lut.h&quot;
  92 
  93 namespace JSC {
  94 
  95 const ClassInfo StringPrototype::s_info = { &quot;String&quot;, &amp;StringObject::s_info, &amp;stringPrototypeTable, nullptr, CREATE_METHOD_TABLE(StringPrototype) };
  96 
  97 /* Source for StringConstructor.lut.h
  98 @begin stringPrototypeTable
<span class="line-modified">  99     concat    JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified"> 100     match     JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified"> 101     matchAll  JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified"> 102     padStart  JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified"> 103     padEnd    JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified"> 104     repeat    JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified"> 105     replace   JSBuiltin    DontEnum|Function 2</span>
<span class="line-modified"> 106     search    JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified"> 107     split     JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified"> 108     anchor    JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified"> 109     big       JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified"> 110     bold      JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified"> 111     blink     JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified"> 112     fixed     JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified"> 113     fontcolor JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified"> 114     fontsize  JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified"> 115     italics   JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified"> 116     link      JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified"> 117     small     JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified"> 118     strike    JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified"> 119     sub       JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified"> 120     sup       JSBuiltin    DontEnum|Function 0</span>

 121 @end
 122 */
 123 
 124 // ECMA 15.5.4
 125 StringPrototype::StringPrototype(VM&amp; vm, Structure* structure)
 126     : StringObject(vm, structure)
 127 {
 128 }
 129 
 130 void StringPrototype::finishCreation(VM&amp; vm, JSGlobalObject* globalObject, JSString* nameAndMessage)
 131 {
 132     Base::finishCreation(vm, nameAndMessage);
 133     ASSERT(inherits(vm, info()));
 134 
 135     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;toString, stringProtoFuncToString, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, StringPrototypeValueOfIntrinsic);
 136     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;valueOf, stringProtoFuncToString, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, StringPrototypeValueOfIntrinsic);
 137     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;charAt&quot;, stringProtoFuncCharAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, CharAtIntrinsic);
 138     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;charCodeAt&quot;, stringProtoFuncCharCodeAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, CharCodeAtIntrinsic);
<span class="line-modified"> 139     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;codePointAt&quot;, stringProtoFuncCodePointAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);</span>
 140     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;indexOf&quot;, stringProtoFuncIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 141     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;lastIndexOf&quot;, stringProtoFuncLastIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 142     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().replaceUsingRegExpPrivateName(), stringProtoFuncReplaceUsingRegExp, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2, StringPrototypeReplaceRegExpIntrinsic);
 143     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().replaceUsingStringSearchPrivateName(), stringProtoFuncReplaceUsingStringSearch, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);

 144     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;slice&quot;, stringProtoFuncSlice, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2, StringPrototypeSliceIntrinsic);
 145     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;substr&quot;, stringProtoFuncSubstr, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
 146     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;substring&quot;, stringProtoFuncSubstring, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
 147     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;toLowerCase&quot;, stringProtoFuncToLowerCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, StringPrototypeToLowerCaseIntrinsic);
 148     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toUpperCase&quot;, stringProtoFuncToUpperCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 149     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;localeCompare&quot;, stringProtoFuncLocaleCompare, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 150 #if ENABLE(INTL)
 151     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleLowerCase&quot;, stringProtoFuncToLocaleLowerCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 152     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleUpperCase&quot;, stringProtoFuncToLocaleUpperCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 153 #else
 154     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleLowerCase&quot;, stringProtoFuncToLowerCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 155     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleUpperCase&quot;, stringProtoFuncToUpperCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 156 #endif
 157     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;trim&quot;, stringProtoFuncTrim, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 158     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;startsWith&quot;, stringProtoFuncStartsWith, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 159     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;endsWith&quot;, stringProtoFuncEndsWith, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 160     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;includes&quot;, stringProtoFuncIncludes, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 161     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;normalize&quot;, stringProtoFuncNormalize, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 162     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().charCodeAtPrivateName(), stringProtoFuncCharCodeAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, CharCodeAtIntrinsic);
 163 
</pre>
<hr />
<pre>
 199             ++i;
 200             result.append(replacement.substring(offset, i - offset));
 201             offset = i + 1;
 202             continue;
 203         }
 204 
 205         int backrefStart;
 206         int backrefLength;
 207         int advance = 0;
 208         if (ref == &#39;&amp;&#39;) {
 209             backrefStart = ovector[0];
 210             backrefLength = ovector[1] - backrefStart;
 211         } else if (ref == &#39;`&#39;) {
 212             backrefStart = 0;
 213             backrefLength = ovector[0];
 214         } else if (ref == &#39;\&#39;&#39;) {
 215             backrefStart = ovector[1];
 216             backrefLength = source.length() - backrefStart;
 217         } else if (reg &amp;&amp; ref == &#39;&lt;&#39;) {
 218             // Named back reference
<span class="line-modified"> 219             if (!hasNamedCaptures) {</span>
<span class="line-removed"> 220                 result.append(replacement.substring(i, 2));</span>
<span class="line-removed"> 221                 offset = i + 2;</span>
<span class="line-removed"> 222                 advance = 1;</span>
 223                 continue;
<span class="line-removed"> 224             }</span>
 225 
 226             size_t closingBracket = replacement.find(&#39;&gt;&#39;, i + 2);
<span class="line-modified"> 227             if (closingBracket == WTF::notFound) {</span>
<span class="line-removed"> 228                 // FIXME: https://bugs.webkit.org/show_bug.cgi?id=176434</span>
<span class="line-removed"> 229                 // Current proposed spec change throws a syntax error in this case.</span>
<span class="line-removed"> 230                 // We have made the case that it makes more sense to treat this a literal</span>
<span class="line-removed"> 231                 // If throwSyntaxError(exec, scope, &quot;Missing closing &#39;&gt;&#39; in replacement text&quot;);</span>
 232                 continue;
<span class="line-removed"> 233             }</span>
 234 
 235             unsigned nameLength = closingBracket - i - 2;
 236             unsigned backrefIndex = reg-&gt;subpatternForName(replacement.substring(i + 2, nameLength).toString());
 237 
 238             if (!backrefIndex || backrefIndex &gt; reg-&gt;numSubpatterns()) {
<span class="line-removed"> 239                 // FIXME: https://bugs.webkit.org/show_bug.cgi?id=176434</span>
<span class="line-removed"> 240                 // Proposed spec change throws a throw syntax error in this case.</span>
<span class="line-removed"> 241                 // We have made the case that a non-existent back reference should be replaced with</span>
<span class="line-removed"> 242                 // and empty string.</span>
<span class="line-removed"> 243                 // throwSyntaxError(exec, scope, makeString(&quot;Replacement text references non-existent backreference \&quot;&quot; + replacement.substring(i + 2, nameLength).toString()));</span>
 244                 backrefStart = 0;
 245                 backrefLength = 0;
 246             } else {
 247                 backrefStart = ovector[2 * backrefIndex];
 248                 backrefLength = ovector[2 * backrefIndex + 1] - backrefStart;
 249             }
 250             advance = nameLength + 1;
 251         } else if (reg &amp;&amp; isASCIIDigit(ref)) {
 252             // 1- and 2-digit back references are allowed
 253             unsigned backrefIndex = ref - &#39;0&#39;;
 254             if (backrefIndex &gt; reg-&gt;numSubpatterns())
 255                 continue;
 256             if (replacement.length() &gt; i + 2) {
 257                 ref = replacement[i + 2];
 258                 if (isASCIIDigit(ref)) {
 259                     backrefIndex = 10 * backrefIndex + ref - &#39;0&#39;;
 260                     if (backrefIndex &gt; reg-&gt;numSubpatterns())
 261                         backrefIndex = backrefIndex / 10;   // Fall back to the 1-digit reference
 262                     else
 263                         advance = 1;
</pre>
<hr />
<pre>
 294 void substituteBackreferences(StringBuilder&amp; result, const String&amp; replacement, StringView source, const int* ovector, RegExp* reg)
 295 {
 296     substituteBackreferencesInline(result, replacement, source, ovector, reg);
 297 }
 298 
 299 struct StringRange {
 300     StringRange(int pos, int len)
 301         : position(pos)
 302         , length(len)
 303     {
 304     }
 305 
 306     StringRange()
 307     {
 308     }
 309 
 310     int position;
 311     int length;
 312 };
 313 
<span class="line-modified"> 314 static ALWAYS_INLINE JSString* jsSpliceSubstrings(ExecState* exec, JSString* sourceVal, const String&amp; source, const StringRange* substringRanges, int rangeCount)</span>
 315 {
<span class="line-modified"> 316     VM&amp; vm = exec-&gt;vm();</span>
 317     auto scope = DECLARE_THROW_SCOPE(vm);
 318 
 319     if (rangeCount == 1) {
 320         int sourceSize = source.length();
 321         int position = substringRanges[0].position;
 322         int length = substringRanges[0].length;
 323         if (position &lt;= 0 &amp;&amp; length &gt;= sourceSize)
 324             return sourceVal;
 325         // We could call String::substringSharingImpl(), but this would result in redundant checks.
 326         RELEASE_AND_RETURN(scope, jsString(vm, StringImpl::createSubstringSharingImpl(*source.impl(), std::max(0, position), std::min(sourceSize, length))));
 327     }
 328 
 329     // We know that the sum of substringRanges lengths cannot exceed length of
 330     // source because the substringRanges were computed from the source string
 331     // in removeUsingRegExpSearch(). Hence, totalLength cannot exceed
 332     // String::MaxLength, and therefore, cannot overflow.
 333     Checked&lt;int, AssertNoOverflow&gt; totalLength = 0;
 334     for (int i = 0; i &lt; rangeCount; i++)
 335         totalLength += substringRanges[i].length;
 336     ASSERT(totalLength &lt;= String::MaxLength);
 337 
 338     if (!totalLength)
 339         return jsEmptyString(vm);
 340 
 341     if (source.is8Bit()) {
 342         LChar* buffer;
 343         const LChar* sourceData = source.characters8();
 344         auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 345         if (!impl) {
<span class="line-modified"> 346             throwOutOfMemoryError(exec, scope);</span>
 347             return nullptr;
 348         }
 349 
 350         Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 351         for (int i = 0; i &lt; rangeCount; i++) {
 352             if (int srcLen = substringRanges[i].length) {
 353                 StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), sourceData + substringRanges[i].position, srcLen);
 354                 bufferPos += srcLen;
 355             }
 356         }
 357 
 358         RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(impl)));
 359     }
 360 
 361     UChar* buffer;
 362     const UChar* sourceData = source.characters16();
 363 
 364     auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 365     if (!impl) {
<span class="line-modified"> 366         throwOutOfMemoryError(exec, scope);</span>
 367         return nullptr;
 368     }
 369 
 370     Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 371     for (int i = 0; i &lt; rangeCount; i++) {
 372         if (int srcLen = substringRanges[i].length) {
 373             StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), sourceData + substringRanges[i].position, srcLen);
 374             bufferPos += srcLen;
 375         }
 376     }
 377 
 378     RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(impl)));
 379 }
 380 
<span class="line-modified"> 381 static ALWAYS_INLINE JSString* jsSpliceSubstringsWithSeparators(ExecState* exec, JSString* sourceVal, const String&amp; source, const StringRange* substringRanges, int rangeCount, const String* separators, int separatorCount)</span>
 382 {
<span class="line-modified"> 383     VM&amp; vm = exec-&gt;vm();</span>
 384     auto scope = DECLARE_THROW_SCOPE(vm);
 385 
 386     if (rangeCount == 1 &amp;&amp; separatorCount == 0) {
 387         int sourceSize = source.length();
 388         int position = substringRanges[0].position;
 389         int length = substringRanges[0].length;
 390         if (position &lt;= 0 &amp;&amp; length &gt;= sourceSize)
 391             return sourceVal;
 392         // We could call String::substringSharingImpl(), but this would result in redundant checks.
 393         RELEASE_AND_RETURN(scope, jsString(vm, StringImpl::createSubstringSharingImpl(*source.impl(), std::max(0, position), std::min(sourceSize, length))));
 394     }
 395 






 396     Checked&lt;int, RecordOverflow&gt; totalLength = 0;
 397     bool allSeparators8Bit = true;
 398     for (int i = 0; i &lt; rangeCount; i++)
 399         totalLength += substringRanges[i].length;
 400     for (int i = 0; i &lt; separatorCount; i++) {
 401         totalLength += separators[i].length();
 402         if (separators[i].length() &amp;&amp; !separators[i].is8Bit())
 403             allSeparators8Bit = false;
 404     }
 405     if (totalLength.hasOverflowed()) {
<span class="line-modified"> 406         throwOutOfMemoryError(exec, scope);</span>
 407         return nullptr;
 408     }
 409 
 410     if (!totalLength)
 411         return jsEmptyString(vm);
 412 
 413     if (source.is8Bit() &amp;&amp; allSeparators8Bit) {
 414         LChar* buffer;
 415         const LChar* sourceData = source.characters8();
 416 
 417         auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 418         if (!impl) {
<span class="line-modified"> 419             throwOutOfMemoryError(exec, scope);</span>
 420             return nullptr;
 421         }
 422 
 423         int maxCount = std::max(rangeCount, separatorCount);
 424         Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 425         for (int i = 0; i &lt; maxCount; i++) {
 426             if (i &lt; rangeCount) {
 427                 if (int srcLen = substringRanges[i].length) {
 428                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), sourceData + substringRanges[i].position, srcLen);
 429                     bufferPos += srcLen;
 430                 }
 431             }
 432             if (i &lt; separatorCount) {
 433                 if (int sepLen = separators[i].length()) {
 434                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), separators[i].characters8(), sepLen);
 435                     bufferPos += sepLen;
 436                 }
 437             }
 438         }
 439 
 440         RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(impl)));
 441     }
 442 
 443     UChar* buffer;
 444     auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 445     if (!impl) {
<span class="line-modified"> 446         throwOutOfMemoryError(exec, scope);</span>
 447         return nullptr;
 448     }
 449 
 450     int maxCount = std::max(rangeCount, separatorCount);
 451     Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 452     for (int i = 0; i &lt; maxCount; i++) {
 453         if (i &lt; rangeCount) {
 454             if (int srcLen = substringRanges[i].length) {
 455                 if (source.is8Bit())
 456                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), source.characters8() + substringRanges[i].position, srcLen);
 457                 else
 458                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), source.characters16() + substringRanges[i].position, srcLen);
 459                 bufferPos += srcLen;
 460             }
 461         }
 462         if (i &lt; separatorCount) {
 463             if (int sepLen = separators[i].length()) {
 464                 if (separators[i].is8Bit())
 465                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), separators[i].characters8(), sepLen);
 466                 else
 467                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), separators[i].characters16(), sepLen);
 468                 bufferPos += sepLen;
 469             }
 470         }
 471     }
 472 
 473     RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(impl)));
 474 }
 475 
 476 #define OUT_OF_MEMORY(exec__, scope__) \
 477     do { \
 478         throwOutOfMemoryError(exec__, scope__); \
 479         return nullptr; \
 480     } while (false)
 481 
<span class="line-modified"> 482 static ALWAYS_INLINE JSString* removeUsingRegExpSearch(VM&amp; vm, ExecState* exec, JSString* string, const String&amp; source, RegExp* regExp)</span>
 483 {
 484     auto scope = DECLARE_THROW_SCOPE(vm);
 485     SuperSamplerScope superSamplerScope(false);
 486 
 487     size_t lastIndex = 0;
 488     unsigned startPosition = 0;
 489 
 490     Vector&lt;StringRange, 16&gt; sourceRanges;
<span class="line-removed"> 491     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
 492     unsigned sourceLen = source.length();
 493 
 494     while (true) {
 495         MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, source, startPosition);
 496         RETURN_IF_EXCEPTION(scope, nullptr);
 497         if (!result)
 498             break;
 499 
 500         if (lastIndex &lt; result.start) {
 501             if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
<span class="line-modified"> 502                 OUT_OF_MEMORY(exec, scope);</span>
 503         }
 504         lastIndex = result.end;
 505         startPosition = lastIndex;
 506 
 507         // special case of empty match
 508         if (result.empty()) {
 509             startPosition++;
 510             if (startPosition &gt; sourceLen)
 511                 break;
 512         }
 513     }
 514 
 515     if (!lastIndex)
 516         return string;
 517 
 518     if (static_cast&lt;unsigned&gt;(lastIndex) &lt; sourceLen) {
 519         if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, sourceLen - lastIndex)))
<span class="line-modified"> 520             OUT_OF_MEMORY(exec, scope);</span>
 521     }
<span class="line-modified"> 522     RELEASE_AND_RETURN(scope, jsSpliceSubstrings(exec, string, source, sourceRanges.data(), sourceRanges.size()));</span>
 523 }
 524 
 525 static ALWAYS_INLINE JSString* replaceUsingRegExpSearch(
<span class="line-modified"> 526     VM&amp; vm, ExecState* exec, JSString* string, JSValue searchValue, CallData&amp; callData,</span>
 527     CallType callType, String&amp; replacementString, JSValue replaceValue)
 528 {
 529     auto scope = DECLARE_THROW_SCOPE(vm);
 530 
<span class="line-modified"> 531     String source = string-&gt;value(exec);</span>
 532     RETURN_IF_EXCEPTION(scope, nullptr);
 533     unsigned sourceLen = source.length();
 534     RETURN_IF_EXCEPTION(scope, nullptr);
 535     RegExpObject* regExpObject = jsCast&lt;RegExpObject*&gt;(searchValue);
 536     RegExp* regExp = regExpObject-&gt;regExp();
 537     bool global = regExp-&gt;global();
 538     bool hasNamedCaptures = regExp-&gt;hasNamedCaptures();
 539 
 540     if (global) {
 541         // ES5.1 15.5.4.10 step 8.a.
<span class="line-modified"> 542         regExpObject-&gt;setLastIndex(exec, 0);</span>
 543         RETURN_IF_EXCEPTION(scope, nullptr);
 544 
 545         if (callType == CallType::None &amp;&amp; !replacementString.length())
<span class="line-modified"> 546             RELEASE_AND_RETURN(scope, removeUsingRegExpSearch(vm, exec, string, source, regExp));</span>
 547     }
 548 
<span class="line-removed"> 549     // FIXME: This is wrong because we may be called directly from the FTL.</span>
<span class="line-removed"> 550     // https://bugs.webkit.org/show_bug.cgi?id=154874</span>
<span class="line-removed"> 551     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-removed"> 552 </span>
 553     size_t lastIndex = 0;
 554     unsigned startPosition = 0;
 555 
 556     Vector&lt;StringRange, 16&gt; sourceRanges;
 557     Vector&lt;String, 16&gt; replacements;
 558 
 559     // This is either a loop (if global is set) or a one-way (if not).
 560     if (global &amp;&amp; callType == CallType::JS) {
 561         // regExp-&gt;numSubpatterns() + 1 for pattern args, + 2 for match start and string
 562         int argCount = regExp-&gt;numSubpatterns() + 1 + 2;
 563         if (hasNamedCaptures)
 564             ++argCount;
 565         JSFunction* func = jsCast&lt;JSFunction*&gt;(replaceValue);
<span class="line-modified"> 566         CachedCall cachedCall(exec, func, argCount);</span>
 567         RETURN_IF_EXCEPTION(scope, nullptr);
 568         while (true) {
 569             int* ovector;
 570             MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, source, startPosition, &amp;ovector);
 571             RETURN_IF_EXCEPTION(scope, nullptr);
 572             if (!result)
 573                 break;
 574 
 575             if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
<span class="line-modified"> 576                 OUT_OF_MEMORY(exec, scope);</span>
 577 
 578             cachedCall.clearArguments();
<span class="line-modified"> 579 </span>
<span class="line-removed"> 580             JSObject* groups = nullptr;</span>
<span class="line-removed"> 581 </span>
<span class="line-removed"> 582             if (hasNamedCaptures) {</span>
<span class="line-removed"> 583                 JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-removed"> 584                 groups = JSFinalObject::create(vm, JSFinalObject::createStructure(vm, globalObject, globalObject-&gt;objectPrototype(), 0));</span>
<span class="line-removed"> 585             }</span>
 586 
 587             for (unsigned i = 0; i &lt; regExp-&gt;numSubpatterns() + 1; ++i) {
 588                 int matchStart = ovector[i * 2];
 589                 int matchLen = ovector[i * 2 + 1] - matchStart;
 590 
 591                 JSValue patternValue;
 592 
 593                 if (matchStart &lt; 0)
 594                     patternValue = jsUndefined();
 595                 else
 596                     patternValue = jsSubstring(vm, source, matchStart, matchLen);
 597 
 598                 cachedCall.appendArgument(patternValue);
 599 
 600                 if (i &amp;&amp; hasNamedCaptures) {
 601                     String groupName = regExp-&gt;getCaptureGroupName(i);
 602                     if (!groupName.isEmpty())
 603                         groups-&gt;putDirect(vm, Identifier::fromString(vm, groupName), patternValue);
 604                 }
 605             }
 606 
 607             cachedCall.appendArgument(jsNumber(result.start));
 608             cachedCall.appendArgument(string);
 609             if (hasNamedCaptures)
 610                 cachedCall.appendArgument(groups);
 611 
 612             cachedCall.setThis(jsUndefined());
 613             if (UNLIKELY(cachedCall.hasOverflowedArguments())) {
<span class="line-modified"> 614                 throwOutOfMemoryError(exec, scope);</span>
 615                 return nullptr;
 616             }
 617 
 618             JSValue jsResult = cachedCall.call();
 619             RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 620             replacements.append(jsResult.toWTFString(exec));</span>
 621             RETURN_IF_EXCEPTION(scope, nullptr);
 622 
 623             lastIndex = result.end;
 624             startPosition = lastIndex;
 625 
 626             // special case of empty match
 627             if (result.empty()) {
 628                 startPosition++;
 629                 if (startPosition &gt; sourceLen)
 630                     break;
 631             }
 632         }
 633     } else {
 634         do {
 635             int* ovector;
 636             MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, source, startPosition, &amp;ovector);
 637             RETURN_IF_EXCEPTION(scope, nullptr);
 638             if (!result)
 639                 break;
 640 
 641             if (callType != CallType::None) {
 642                 if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
<span class="line-modified"> 643                     OUT_OF_MEMORY(exec, scope);</span>
 644 
 645                 MarkedArgumentBuffer args;
<span class="line-modified"> 646                 JSObject* groups = nullptr;</span>
<span class="line-removed"> 647 </span>
<span class="line-removed"> 648                 if (hasNamedCaptures) {</span>
<span class="line-removed"> 649                     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-removed"> 650                     groups = JSFinalObject::create(vm, JSFinalObject::createStructure(vm, globalObject, globalObject-&gt;objectPrototype(), 0));</span>
<span class="line-removed"> 651                 }</span>
 652 
 653                 for (unsigned i = 0; i &lt; regExp-&gt;numSubpatterns() + 1; ++i) {
 654                     int matchStart = ovector[i * 2];
 655                     int matchLen = ovector[i * 2 + 1] - matchStart;
 656 
 657                     JSValue patternValue;
 658 
 659                     if (matchStart &lt; 0)
 660                         patternValue = jsUndefined();
 661                     else {
 662                         patternValue = jsSubstring(vm, source, matchStart, matchLen);
 663                         RETURN_IF_EXCEPTION(scope, nullptr);
 664                     }
 665 
 666                     args.append(patternValue);
 667 
 668                     if (i &amp;&amp; hasNamedCaptures) {
 669                         String groupName = regExp-&gt;getCaptureGroupName(i);
 670                         if (!groupName.isEmpty())
 671                             groups-&gt;putDirect(vm, Identifier::fromString(vm, groupName), patternValue);
 672                     }
<span class="line-removed"> 673 </span>
 674                 }
 675 
 676                 args.append(jsNumber(result.start));
 677                 args.append(string);
 678                 if (hasNamedCaptures)
 679                     args.append(groups);
 680                 if (UNLIKELY(args.hasOverflowed())) {
<span class="line-modified"> 681                     throwOutOfMemoryError(exec, scope);</span>
 682                     return nullptr;
 683                 }
 684 
<span class="line-modified"> 685                 JSValue replacement = call(exec, replaceValue, callType, callData, jsUndefined(), args);</span>
 686                 RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 687                 String replacementString = replacement.toWTFString(exec);</span>
 688                 RETURN_IF_EXCEPTION(scope, nullptr);
 689                 replacements.append(replacementString);
 690                 RETURN_IF_EXCEPTION(scope, nullptr);
 691             } else {
 692                 int replLen = replacementString.length();
 693                 if (lastIndex &lt; result.start || replLen) {
 694                     if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
<span class="line-modified"> 695                         OUT_OF_MEMORY(exec, scope);</span>
 696 
 697                     if (replLen) {
 698                         StringBuilder replacement(StringBuilder::OverflowHandler::RecordOverflow);
 699                         substituteBackreferences(replacement, replacementString, source, ovector, regExp);
 700                         if (UNLIKELY(replacement.hasOverflowed()))
<span class="line-modified"> 701                             OUT_OF_MEMORY(exec, scope);</span>
 702                         replacements.append(replacement.toString());
 703                     } else
 704                         replacements.append(String());
 705                 }
 706             }
 707 
 708             lastIndex = result.end;
 709             startPosition = lastIndex;
 710 
 711             // special case of empty match
 712             if (result.empty()) {
 713                 startPosition++;
 714                 if (startPosition &gt; sourceLen)
 715                     break;
 716             }
 717         } while (global);
 718     }
 719 
 720     if (!lastIndex &amp;&amp; replacements.isEmpty())
 721         return string;
 722 
 723     if (static_cast&lt;unsigned&gt;(lastIndex) &lt; sourceLen) {
 724         if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, sourceLen - lastIndex)))
<span class="line-modified"> 725             OUT_OF_MEMORY(exec, scope);</span>
 726     }
<span class="line-modified"> 727     RELEASE_AND_RETURN(scope, jsSpliceSubstringsWithSeparators(exec, string, source, sourceRanges.data(), sourceRanges.size(), replacements.data(), replacements.size()));</span>
 728 }
 729 
<span class="line-modified"> 730 JSCell* JIT_OPERATION operationStringProtoFuncReplaceRegExpEmptyStr(</span>
<span class="line-modified"> 731     ExecState* exec, JSString* thisValue, RegExpObject* searchValue)</span>

 732 {
<span class="line-modified"> 733     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 734     NativeCallFrameTracer tracer(vm, exec);</span>

 735     auto scope = DECLARE_THROW_SCOPE(vm);
 736 
 737     RegExp* regExp = searchValue-&gt;regExp();
 738     if (regExp-&gt;global()) {
 739         // ES5.1 15.5.4.10 step 8.a.
<span class="line-modified"> 740         searchValue-&gt;setLastIndex(exec, 0);</span>
 741         RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 742         String source = thisValue-&gt;value(exec);</span>
 743         RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 744         RELEASE_AND_RETURN(scope, removeUsingRegExpSearch(vm, exec, thisValue, source, regExp));</span>
 745     }
 746 
 747     CallData callData;
 748     String replacementString = emptyString();
 749     RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
<span class="line-modified"> 750         vm, exec, thisValue, searchValue, callData, CallType::None, replacementString, JSValue()));</span>
 751 }
 752 
<span class="line-modified"> 753 JSCell* JIT_OPERATION operationStringProtoFuncReplaceRegExpString(</span>
<span class="line-removed"> 754     ExecState* exec, JSString* thisValue, RegExpObject* searchValue, JSString* replaceString)</span>
 755 {
<span class="line-modified"> 756     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 757     NativeCallFrameTracer tracer(vm, exec);</span>

 758     auto scope = DECLARE_THROW_SCOPE(vm);
 759 
 760     CallData callData;
<span class="line-modified"> 761     String replacementString = replaceString-&gt;value(exec);</span>
 762     RETURN_IF_EXCEPTION(scope, nullptr);
 763     RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
<span class="line-modified"> 764         vm, exec, thisValue, searchValue, callData, CallType::None, replacementString, replaceString));</span>
 765 }
 766 
<span class="line-modified"> 767 static ALWAYS_INLINE JSString* replaceUsingRegExpSearch(VM&amp; vm, ExecState* exec, JSString* string, JSValue searchValue, JSValue replaceValue)</span>
 768 {
 769     auto scope = DECLARE_THROW_SCOPE(vm);
 770 
 771     String replacementString;
 772     CallData callData;
 773     CallType callType = getCallData(vm, replaceValue, callData);
 774     if (callType == CallType::None) {
<span class="line-modified"> 775         replacementString = replaceValue.toWTFString(exec);</span>
 776         RETURN_IF_EXCEPTION(scope, nullptr);
 777     }
 778 
 779     RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
<span class="line-modified"> 780         vm, exec, string, searchValue, callData, callType, replacementString, replaceValue));</span>
 781 }
 782 
<span class="line-modified"> 783 static ALWAYS_INLINE JSString* replaceUsingStringSearch(VM&amp; vm, ExecState* exec, JSString* jsString, JSValue searchValue, JSValue replaceValue)</span>


 784 {
 785     auto scope = DECLARE_THROW_SCOPE(vm);
 786 
<span class="line-modified"> 787     String string = jsString-&gt;value(exec);</span>
 788     RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 789     String searchString = searchValue.toWTFString(exec);</span>
 790     RETURN_IF_EXCEPTION(scope, nullptr);
 791 
<span class="line-removed"> 792     size_t matchStart = string.find(searchString);</span>
<span class="line-removed"> 793 </span>
<span class="line-removed"> 794     if (matchStart == notFound)</span>
<span class="line-removed"> 795         return jsString;</span>
<span class="line-removed"> 796 </span>
 797     CallData callData;
 798     CallType callType = getCallData(vm, replaceValue, callData);
<span class="line-modified"> 799     if (callType != CallType::None) {</span>
<span class="line-modified"> 800         MarkedArgumentBuffer args;</span>
<span class="line-modified"> 801         auto* substring = jsSubstring(vm, string, matchStart, searchString.impl()-&gt;length());</span>

 802         RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 803         args.append(substring);</span>
<span class="line-modified"> 804         args.append(jsNumber(matchStart));</span>
<span class="line-removed"> 805         args.append(jsString);</span>
<span class="line-removed"> 806         ASSERT(!args.hasOverflowed());</span>
<span class="line-removed"> 807         replaceValue = call(exec, replaceValue, callType, callData, jsUndefined(), args);</span>
 808         RETURN_IF_EXCEPTION(scope, nullptr);

 809     }
 810 
<span class="line-modified"> 811     String replaceString = replaceValue.toWTFString(exec);</span>
<span class="line-modified"> 812     RETURN_IF_EXCEPTION(scope, nullptr);</span>

 813 
<span class="line-modified"> 814     StringImpl* stringImpl = string.impl();</span>
<span class="line-modified"> 815     String leftPart(StringImpl::createSubstringSharingImpl(*stringImpl, 0, matchStart));</span>




























 816 
<span class="line-modified"> 817     size_t matchEnd = matchStart + searchString.impl()-&gt;length();</span>
<span class="line-modified"> 818     int ovector[2] = { static_cast&lt;int&gt;(matchStart),  static_cast&lt;int&gt;(matchEnd)};</span>
<span class="line-removed"> 819     String middlePart;</span>
<span class="line-removed"> 820     if (callType != CallType::None)</span>
<span class="line-removed"> 821         middlePart = replaceString;</span>
<span class="line-removed"> 822     else {</span>
<span class="line-removed"> 823         StringBuilder replacement(StringBuilder::OverflowHandler::RecordOverflow);</span>
<span class="line-removed"> 824         substituteBackreferences(replacement, replaceString, string, ovector, 0);</span>
<span class="line-removed"> 825         if (UNLIKELY(replacement.hasOverflowed()))</span>
<span class="line-removed"> 826             OUT_OF_MEMORY(exec, scope);</span>
<span class="line-removed"> 827         middlePart = replacement.toString();</span>
<span class="line-removed"> 828     }</span>
 829 
<span class="line-modified"> 830     size_t leftLength = stringImpl-&gt;length() - matchEnd;</span>
<span class="line-modified"> 831     String rightPart(StringImpl::createSubstringSharingImpl(*stringImpl, matchEnd, leftLength));</span>
<span class="line-modified"> 832     RELEASE_AND_RETURN(scope, JSC::jsString(exec, leftPart, middlePart, rightPart));</span>


















 833 }
 834 
 835 static inline bool checkObjectCoercible(JSValue thisValue)
 836 {
 837     if (thisValue.isString())
 838         return true;
 839 
 840     if (thisValue.isUndefinedOrNull())
 841         return false;
 842 
 843     if (thisValue.isObject() &amp;&amp; asObject(thisValue)-&gt;isEnvironment())
 844         return false;
 845 
 846     return true;
 847 }
 848 
<span class="line-modified"> 849 EncodedJSValue JSC_HOST_CALL stringProtoFuncRepeatCharacter(ExecState* exec)</span>
 850 {
<span class="line-modified"> 851     VM&amp; vm = exec-&gt;vm();</span>
 852     auto scope = DECLARE_THROW_SCOPE(vm);
 853 
 854     // For a string which length is single, instead of creating ropes,
 855     // allocating a sequential buffer and fill with the repeated string for efficiency.
<span class="line-modified"> 856     ASSERT(exec-&gt;argumentCount() == 2);</span>
 857 
<span class="line-modified"> 858     ASSERT(exec-&gt;uncheckedArgument(0).isString());</span>
<span class="line-modified"> 859     JSString* string = asString(exec-&gt;uncheckedArgument(0));</span>
 860     ASSERT(string-&gt;length() == 1);
 861 
<span class="line-modified"> 862     JSValue repeatCountValue = exec-&gt;uncheckedArgument(1);</span>
 863     RELEASE_ASSERT(repeatCountValue.isNumber());
 864     int32_t repeatCount;
 865     double value = repeatCountValue.asNumber();
 866     if (value &gt; JSString::MaxLength)
<span class="line-modified"> 867         return JSValue::encode(throwOutOfMemoryError(exec, scope));</span>
 868     repeatCount = static_cast&lt;int32_t&gt;(value);
 869     ASSERT(repeatCount &gt;= 0);
 870     ASSERT(!repeatCountValue.isDouble() || repeatCountValue.asDouble() == repeatCount);
 871 
<span class="line-modified"> 872     auto viewWithString = string-&gt;viewWithUnderlyingString(exec);</span>
 873     StringView view = viewWithString.view;
 874     ASSERT(view.length() == 1);
 875     scope.assertNoException();
 876     UChar character = view[0];
 877     scope.release();
 878     if (isLatin1(character))
<span class="line-modified"> 879         return JSValue::encode(repeatCharacter(*exec, static_cast&lt;LChar&gt;(character), repeatCount));</span>
<span class="line-modified"> 880     return JSValue::encode(repeatCharacter(*exec, character, repeatCount));</span>
 881 }
 882 
 883 ALWAYS_INLINE JSString* replace(
<span class="line-modified"> 884     VM&amp; vm, ExecState* exec, JSString* string, JSValue searchValue, JSValue replaceValue)</span>
 885 {
 886     if (searchValue.inherits&lt;RegExpObject&gt;(vm))
<span class="line-modified"> 887         return replaceUsingRegExpSearch(vm, exec, string, searchValue, replaceValue);</span>
<span class="line-modified"> 888     return replaceUsingStringSearch(vm, exec, string, searchValue, replaceValue);</span>
 889 }
 890 
 891 ALWAYS_INLINE JSString* replace(
<span class="line-modified"> 892     VM&amp; vm, ExecState* exec, JSValue thisValue, JSValue searchValue, JSValue replaceValue)</span>
 893 {
 894     auto scope = DECLARE_THROW_SCOPE(vm);
 895 
 896     if (!checkObjectCoercible(thisValue)) {
<span class="line-modified"> 897         throwVMTypeError(exec, scope);</span>
 898         return nullptr;
 899     }
<span class="line-modified"> 900     JSString* string = thisValue.toString(exec);</span>
 901     RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 902     RELEASE_AND_RETURN(scope, replace(vm, exec, string, searchValue, replaceValue));</span>
 903 }
 904 
<span class="line-modified"> 905 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingRegExp(ExecState* exec)</span>
 906 {
<span class="line-modified"> 907     VM&amp; vm = exec-&gt;vm();</span>
 908     auto scope = DECLARE_THROW_SCOPE(vm);
 909 
<span class="line-modified"> 910     JSString* string = exec-&gt;thisValue().toString(exec);</span>
 911     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 912 
<span class="line-modified"> 913     JSValue searchValue = exec-&gt;argument(0);</span>
 914     if (!searchValue.inherits&lt;RegExpObject&gt;(vm))
 915         return JSValue::encode(jsUndefined());
 916 
<span class="line-modified"> 917     RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingRegExpSearch(vm, exec, string, searchValue, exec-&gt;argument(1))));</span>











 918 }
 919 
<span class="line-modified"> 920 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingStringSearch(ExecState* exec)</span>
 921 {
<span class="line-modified"> 922     VM&amp; vm = exec-&gt;vm();</span>
 923     auto scope = DECLARE_THROW_SCOPE(vm);
 924 
<span class="line-modified"> 925     JSString* string = exec-&gt;thisValue().toString(exec);</span>
 926     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 927 
<span class="line-modified"> 928     RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingStringSearch(vm, exec, string, exec-&gt;argument(0), exec-&gt;argument(1))));</span>
 929 }
 930 
<span class="line-modified"> 931 JSCell* JIT_OPERATION operationStringProtoFuncReplaceGeneric(</span>
<span class="line-removed"> 932     ExecState* exec, EncodedJSValue thisValue, EncodedJSValue searchValue,</span>
<span class="line-removed"> 933     EncodedJSValue replaceValue)</span>
 934 {
<span class="line-modified"> 935     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 936     NativeCallFrameTracer tracer(vm, exec);</span>

 937 
 938     return replace(
<span class="line-modified"> 939         vm, exec, JSValue::decode(thisValue), JSValue::decode(searchValue),</span>
 940         JSValue::decode(replaceValue));
 941 }
 942 
<span class="line-modified"> 943 EncodedJSValue JSC_HOST_CALL stringProtoFuncToString(ExecState* exec)</span>


 944 {
<span class="line-modified"> 945     VM&amp; vm = exec-&gt;vm();</span>
 946     auto scope = DECLARE_THROW_SCOPE(vm);
 947 
<span class="line-modified"> 948     JSValue thisValue = exec-&gt;thisValue();</span>
 949     // Also used for valueOf.
 950 
 951     if (thisValue.isString())
 952         return JSValue::encode(thisValue);
 953 
 954     auto* stringObject = jsDynamicCast&lt;StringObject*&gt;(vm, thisValue);
 955     if (stringObject)
 956         return JSValue::encode(stringObject-&gt;internalValue());
 957 
<span class="line-modified"> 958     return throwVMTypeError(exec, scope);</span>
 959 }
 960 
<span class="line-modified"> 961 EncodedJSValue JSC_HOST_CALL stringProtoFuncCharAt(ExecState* exec)</span>
 962 {
<span class="line-modified"> 963     VM&amp; vm = exec-&gt;vm();</span>
 964     auto scope = DECLARE_THROW_SCOPE(vm);
 965 
<span class="line-modified"> 966     JSValue thisValue = exec-&gt;thisValue();</span>
 967     if (!checkObjectCoercible(thisValue))
<span class="line-modified"> 968         return throwVMTypeError(exec, scope);</span>
<span class="line-modified"> 969     auto viewWithString = thisValue.toString(exec)-&gt;viewWithUnderlyingString(exec);</span>
 970     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 971     StringView view = viewWithString.view;
 972     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified"> 973     JSValue a0 = exec-&gt;argument(0);</span>
 974     if (a0.isUInt32()) {
 975         uint32_t i = a0.asUInt32();
 976         if (i &lt; view.length())
 977             return JSValue::encode(jsSingleCharacterString(vm, view[i]));
 978         return JSValue::encode(jsEmptyString(vm));
 979     }
<span class="line-modified"> 980     double dpos = a0.toInteger(exec);</span>
 981     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 982     if (dpos &gt;= 0 &amp;&amp; dpos &lt; view.length())
 983         return JSValue::encode(jsSingleCharacterString(vm, view[static_cast&lt;unsigned&gt;(dpos)]));
 984     return JSValue::encode(jsEmptyString(vm));
 985 }
 986 
<span class="line-modified"> 987 EncodedJSValue JSC_HOST_CALL stringProtoFuncCharCodeAt(ExecState* exec)</span>
 988 {
<span class="line-modified"> 989     VM&amp; vm = exec-&gt;vm();</span>
 990     auto scope = DECLARE_THROW_SCOPE(vm);
 991 
<span class="line-modified"> 992     JSValue thisValue = exec-&gt;thisValue();</span>
 993     if (!checkObjectCoercible(thisValue))
<span class="line-modified"> 994         return throwVMTypeError(exec, scope);</span>
<span class="line-modified"> 995     auto viewWithString = thisValue.toString(exec)-&gt;viewWithUnderlyingString(exec);</span>
 996     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 997     StringView view = viewWithString.view;
<span class="line-modified"> 998     JSValue a0 = exec-&gt;argument(0);</span>
 999     if (a0.isUInt32()) {
1000         uint32_t i = a0.asUInt32();
1001         if (i &lt; view.length())
1002             return JSValue::encode(jsNumber(view[i]));
1003         return JSValue::encode(jsNaN());
1004     }
<span class="line-modified">1005     double dpos = a0.toInteger(exec);</span>
1006     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1007     if (dpos &gt;= 0 &amp;&amp; dpos &lt; view.length())
1008         return JSValue::encode(jsNumber(view[static_cast&lt;int&gt;(dpos)]));
1009     return JSValue::encode(jsNaN());
1010 }
1011 
1012 static inline UChar32 codePointAt(const String&amp; string, unsigned position, unsigned length)
1013 {
1014     RELEASE_ASSERT(position &lt; length);
1015     if (string.is8Bit())
1016         return string.characters8()[position];
1017     UChar32 character;
1018     U16_NEXT(string.characters16(), position, length, character);
1019     return character;
1020 }
1021 
<span class="line-modified">1022 EncodedJSValue JSC_HOST_CALL stringProtoFuncCodePointAt(ExecState* exec)</span>
1023 {
<span class="line-modified">1024     VM&amp; vm = exec-&gt;vm();</span>
1025     auto scope = DECLARE_THROW_SCOPE(vm);
1026 
<span class="line-modified">1027     JSValue thisValue = exec-&gt;thisValue();</span>
1028     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1029         return throwVMTypeError(exec, scope);</span>
1030 
<span class="line-modified">1031     String string = thisValue.toWTFString(exec);</span>
1032     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1033     unsigned length = string.length();
1034 
<span class="line-modified">1035     JSValue argument0 = exec-&gt;argument(0);</span>
1036     if (argument0.isUInt32()) {
1037         unsigned position = argument0.asUInt32();
1038         if (position &lt; length)
1039             return JSValue::encode(jsNumber(codePointAt(string, position, length)));
1040         return JSValue::encode(jsUndefined());
1041     }
1042 
1043     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1044 
<span class="line-modified">1045     double doublePosition = argument0.toInteger(exec);</span>
1046     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1047     if (doublePosition &gt;= 0 &amp;&amp; doublePosition &lt; length)
1048         return JSValue::encode(jsNumber(codePointAt(string, static_cast&lt;unsigned&gt;(doublePosition), length)));
1049     return JSValue::encode(jsUndefined());
1050 }
1051 
<span class="line-modified">1052 EncodedJSValue JSC_HOST_CALL stringProtoFuncIndexOf(ExecState* exec)</span>
1053 {
<span class="line-modified">1054     VM&amp; vm = exec-&gt;vm();</span>
1055     auto scope = DECLARE_THROW_SCOPE(vm);
1056 
<span class="line-modified">1057     JSValue thisValue = exec-&gt;thisValue();</span>
1058     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1059         return throwVMTypeError(exec, scope);</span>
1060 
<span class="line-modified">1061     JSValue a0 = exec-&gt;argument(0);</span>
<span class="line-modified">1062     JSValue a1 = exec-&gt;argument(1);</span>
1063 
<span class="line-modified">1064     JSString* thisJSString = thisValue.toString(exec);</span>
1065     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1066     JSString* otherJSString = a0.toString(exec);</span>
1067     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1068 
1069     unsigned pos = 0;
1070     if (!a1.isUndefined()) {
1071         int len = thisJSString-&gt;length();
1072         RELEASE_ASSERT(len &gt;= 0);
1073         if (a1.isUInt32())
1074             pos = std::min&lt;uint32_t&gt;(a1.asUInt32(), len);
1075         else {
<span class="line-modified">1076             double dpos = a1.toInteger(exec);</span>
1077             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1078             if (dpos &lt; 0)
1079                 dpos = 0;
1080             else if (dpos &gt; len)
1081                 dpos = len;
1082             pos = static_cast&lt;unsigned&gt;(dpos);
1083         }
1084     }
1085 
1086     if (thisJSString-&gt;length() &lt; otherJSString-&gt;length() + pos)
1087         return JSValue::encode(jsNumber(-1));
1088 
<span class="line-modified">1089     auto thisViewWithString = thisJSString-&gt;viewWithUnderlyingString(exec);</span>
1090     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1091     auto otherViewWithString = otherJSString-&gt;viewWithUnderlyingString(exec);</span>
1092     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1093     size_t result = thisViewWithString.view.find(otherViewWithString.view, pos);
1094     if (result == notFound)
1095         return JSValue::encode(jsNumber(-1));
1096     return JSValue::encode(jsNumber(result));
1097 }
1098 
<span class="line-modified">1099 EncodedJSValue JSC_HOST_CALL stringProtoFuncLastIndexOf(ExecState* exec)</span>
1100 {
<span class="line-modified">1101     VM&amp; vm = exec-&gt;vm();</span>
1102     auto scope = DECLARE_THROW_SCOPE(vm);
1103 
<span class="line-modified">1104     JSValue thisValue = exec-&gt;thisValue();</span>
1105     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1106         return throwVMTypeError(exec, scope);</span>
1107 
<span class="line-modified">1108     JSValue a0 = exec-&gt;argument(0);</span>
<span class="line-modified">1109     JSValue a1 = exec-&gt;argument(1);</span>
1110 
<span class="line-modified">1111     JSString* thisJSString = thisValue.toString(exec);</span>
1112     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1113     unsigned len = thisJSString-&gt;length();
<span class="line-modified">1114     JSString* otherJSString = a0.toString(exec);</span>
1115     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1116 
<span class="line-modified">1117     double dpos = a1.toIntegerPreserveNaN(exec);</span>
1118     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1119     unsigned startPosition;
1120     if (dpos &lt; 0)
1121         startPosition = 0;
1122     else if (!(dpos &lt;= len)) // true for NaN
1123         startPosition = len;
1124     else
1125         startPosition = static_cast&lt;unsigned&gt;(dpos);
1126 
1127     if (len &lt; otherJSString-&gt;length())
1128         return JSValue::encode(jsNumber(-1));
1129 
<span class="line-modified">1130     String thisString = thisJSString-&gt;value(exec);</span>
1131     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1132     String otherString = otherJSString-&gt;value(exec);</span>
1133     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1134     size_t result;
1135     if (!startPosition)
1136         result = thisString.startsWith(otherString) ? 0 : notFound;
1137     else
1138         result = thisString.reverseFind(otherString, startPosition);
1139     if (result == notFound)
1140         return JSValue::encode(jsNumber(-1));
1141     return JSValue::encode(jsNumber(result));
1142 }
1143 
<span class="line-modified">1144 EncodedJSValue JSC_HOST_CALL stringProtoFuncSlice(ExecState* exec)</span>
1145 {
<span class="line-modified">1146     VM&amp; vm = exec-&gt;vm();</span>
1147     auto scope = DECLARE_THROW_SCOPE(vm);
1148 
<span class="line-modified">1149     JSValue thisValue = exec-&gt;thisValue();</span>
1150     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1151         return throwVMTypeError(exec, scope);</span>
<span class="line-modified">1152     JSString* string = thisValue.toString(exec);</span>
1153     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1154 
<span class="line-modified">1155     JSValue a0 = exec-&gt;argument(0);</span>
<span class="line-modified">1156     JSValue a1 = exec-&gt;argument(1);</span>
1157 
1158     int length = string-&gt;length();
1159     RELEASE_ASSERT(length &gt;= 0);
1160 
1161     // The arg processing is very much like ArrayProtoFunc::Slice
<span class="line-modified">1162     double start = a0.toInteger(exec);</span>
1163     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1164     double end = a1.isUndefined() ? length : a1.toInteger(exec);</span>
1165     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1166     RELEASE_AND_RETURN(scope, JSValue::encode(stringSlice(exec, vm, string, length, start, end)));</span>
1167 }
1168 
1169 // Return true in case of early return (resultLength got to limitLength).
1170 template&lt;typename CharacterType&gt;
<span class="line-modified">1171 static ALWAYS_INLINE bool splitStringByOneCharacterImpl(ExecState* exec, JSArray* result, JSValue originalValue, const String&amp; input, StringImpl* string, UChar separatorCharacter, size_t&amp; position, unsigned&amp; resultLength, unsigned limitLength)</span>
1172 {
<span class="line-modified">1173     VM&amp; vm = exec-&gt;vm();</span>
1174     auto scope = DECLARE_THROW_SCOPE(vm);
1175 
1176     // 12. Let q = p.
1177     size_t matchPosition;
1178     const CharacterType* characters = string-&gt;characters&lt;CharacterType&gt;();
1179     // 13. Repeat, while q != s
1180     //   a. Call SplitMatch(S, q, R) and let z be its MatchResult result.
1181     //   b. If z is failure, then let q = q+1.
1182     //   c. Else, z is not failure
1183     while ((matchPosition = WTF::find(characters, string-&gt;length(), separatorCharacter, position)) != notFound) {
1184         // 1. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
1185         //    through q (exclusive).
1186         // 2. Call the [[DefineOwnProperty]] internal method of A with arguments ToString(lengthA),
1187         //    Property Descriptor {[[Value]]: T, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false.
<span class="line-modified">1188         auto* substring = jsSubstring(exec, originalValue, input, position, matchPosition - position);</span>
1189         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">1190         result-&gt;putDirectIndex(exec, resultLength, substring);</span>
1191         RETURN_IF_EXCEPTION(scope, false);
1192         // 3. Increment lengthA by 1.
1193         // 4. If lengthA == lim, return A.
1194         if (++resultLength == limitLength)
1195             return true;
1196 
1197         // 5. Let p = e.
1198         // 8. Let q = p.
1199         position = matchPosition + 1;
1200     }
1201     return false;
1202 }
1203 
1204 // ES 21.1.3.17 String.prototype.split(separator, limit)
<span class="line-modified">1205 EncodedJSValue JSC_HOST_CALL stringProtoFuncSplitFast(ExecState* exec)</span>
1206 {
<span class="line-modified">1207     VM&amp; vm = exec-&gt;vm();</span>
1208     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">1209     JSValue thisValue = exec-&gt;thisValue();</span>
1210     ASSERT(checkObjectCoercible(thisValue));
1211 
1212     // 3. Let S be the result of calling ToString, giving it the this value as its argument.
1213     // 7. Let s be the number of characters in S.
<span class="line-modified">1214     String input = thisValue.toWTFString(exec);</span>
1215     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1216     ASSERT(!input.isNull());
1217 
1218     // 4. Let A be a new array created as if by the expression new Array()
1219     //    where Array is the standard built-in constructor with that name.
<span class="line-modified">1220     JSArray* result = constructEmptyArray(exec, 0);</span>
1221     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1222 
1223     // 5. Let lengthA be 0.
1224     unsigned resultLength = 0;
1225 
1226     // 6. If limit is undefined, let lim = 2^32-1; else let lim = ToUint32(limit).
<span class="line-modified">1227     JSValue limitValue = exec-&gt;uncheckedArgument(1);</span>
<span class="line-modified">1228     unsigned limit = limitValue.isUndefined() ? 0xFFFFFFFFu : limitValue.toUInt32(exec);</span>
1229     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1230 
1231     // 8. Let p = 0.
1232     size_t position = 0;
1233 
1234     // 9. If separator is a RegExp object (its [[Class]] is &quot;RegExp&quot;), let R = separator;
1235     //    otherwise let R = ToString(separator).
<span class="line-modified">1236     JSValue separatorValue = exec-&gt;uncheckedArgument(0);</span>
<span class="line-modified">1237     String separator = separatorValue.toWTFString(exec);</span>
1238     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1239 
1240     // 10. If lim == 0, return A.
1241     if (!limit)
1242         return JSValue::encode(result);
1243 
1244     // 11. If separator is undefined, then
1245     if (separatorValue.isUndefined()) {
1246         // a. Call the [[DefineOwnProperty]] internal method of A with arguments &quot;0&quot;,
1247         scope.release();
<span class="line-modified">1248         result-&gt;putDirectIndex(exec, 0, jsStringWithReuse(exec, thisValue, input));</span>
1249         // b. Return A.
1250         return JSValue::encode(result);
1251     }
1252 
1253     // 12. If s == 0, then
1254     if (input.isEmpty()) {
1255         // a. Let z be SplitMatch(S, 0, R) where S is input, R is separator.
1256         // b. If z is not false, return A.
1257         // c. Call CreateDataProperty(A, &quot;0&quot;, S).
1258         // d. Return A.
1259         if (!separator.isEmpty()) {
1260             scope.release();
<span class="line-modified">1261             result-&gt;putDirectIndex(exec, 0, jsStringWithReuse(exec, thisValue, input));</span>
1262         }
1263         return JSValue::encode(result);
1264     }
1265 
1266     // Optimized case for splitting on the empty string.
1267     if (separator.isEmpty()) {
1268         limit = std::min(limit, input.length());
1269         // Zero limt/input length handled in steps 9/11 respectively, above.
1270         ASSERT(limit);
1271 
1272         do {
<span class="line-modified">1273             result-&gt;putDirectIndex(exec, position, jsSingleCharacterString(vm, input[position]));</span>
1274             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1275         } while (++position &lt; limit);
1276 
1277         return JSValue::encode(result);
1278     }
1279 
1280     // 3 cases:
1281     // -separator length == 1, 8 bits
1282     // -separator length == 1, 16 bits
1283     // -separator length &gt; 1
1284     StringImpl* stringImpl = input.impl();
1285     StringImpl* separatorImpl = separator.impl();
1286     size_t separatorLength = separatorImpl-&gt;length();
1287 
1288     if (separatorLength == 1) {
1289         UChar separatorCharacter;
1290         if (separatorImpl-&gt;is8Bit())
1291             separatorCharacter = separatorImpl-&gt;characters8()[0];
1292         else
1293             separatorCharacter = separatorImpl-&gt;characters16()[0];
1294 
1295         if (stringImpl-&gt;is8Bit()) {
<span class="line-modified">1296             if (splitStringByOneCharacterImpl&lt;LChar&gt;(exec, result, thisValue, input, stringImpl, separatorCharacter, position, resultLength, limit))</span>
1297                 RELEASE_AND_RETURN(scope, JSValue::encode(result));
1298         } else {
<span class="line-modified">1299             if (splitStringByOneCharacterImpl&lt;UChar&gt;(exec, result, thisValue, input, stringImpl, separatorCharacter, position, resultLength, limit))</span>
1300                 RELEASE_AND_RETURN(scope, JSValue::encode(result));
1301         }
1302         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1303     } else {
1304         // 13. Let q = p.
1305         size_t matchPosition;
1306         // 14. Repeat, while q != s
1307         //   a. let e be SplitMatch(S, q, R).
1308         //   b. If e is failure, then let q = q+1.
1309         //   c. Else, e is an integer index &lt;= s.
1310         while ((matchPosition = stringImpl-&gt;find(separatorImpl, position)) != notFound) {
1311             // 1. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
1312             //    through q (exclusive).
1313             // 2. Call CreateDataProperty(A, ToString(lengthA), T).
<span class="line-modified">1314             auto* substring = jsSubstring(exec, thisValue, input, position, matchPosition - position);</span>
1315             RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">1316             result-&gt;putDirectIndex(exec, resultLength, substring);</span>
1317             RETURN_IF_EXCEPTION(scope, { });
1318             // 3. Increment lengthA by 1.
1319             // 4. If lengthA == lim, return A.
1320             if (++resultLength == limit)
1321                 return JSValue::encode(result);
1322 
1323             // 5. Let p = e.
1324             // 6. Let q = p.
1325             position = matchPosition + separator.length();
1326         }
1327     }
1328 
1329     // 15. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
1330     //     through s (exclusive).
1331     // 16. Call CreateDataProperty(A, ToString(lengthA), T).
<span class="line-modified">1332     auto* substring = jsSubstring(exec, thisValue, input, position, input.length() - position);</span>
1333     RETURN_IF_EXCEPTION(scope, { });
1334     scope.release();
<span class="line-modified">1335     result-&gt;putDirectIndex(exec, resultLength++, substring);</span>
1336 
1337     // 17. Return A.
1338     return JSValue::encode(result);
1339 }
1340 
<span class="line-modified">1341 EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstr(ExecState* exec)</span>
1342 {
<span class="line-modified">1343     VM&amp; vm = exec-&gt;vm();</span>
1344     auto scope = DECLARE_THROW_SCOPE(vm);
1345 
<span class="line-modified">1346     JSValue thisValue = exec-&gt;thisValue();</span>
1347     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1348         return throwVMTypeError(exec, scope);</span>
1349     unsigned len;
1350     JSString* jsString = 0;
1351     String uString;
1352     if (thisValue.isString()) {
1353         jsString = asString(thisValue);
1354         len = jsString-&gt;length();
1355     } else {
<span class="line-modified">1356         uString = thisValue.toWTFString(exec);</span>
1357         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1358         len = uString.length();
1359     }
1360 
<span class="line-modified">1361     JSValue a0 = exec-&gt;argument(0);</span>
<span class="line-modified">1362     JSValue a1 = exec-&gt;argument(1);</span>
1363 
<span class="line-modified">1364     double start = a0.toInteger(exec);</span>
1365     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1366     double length = a1.isUndefined() ? len : a1.toInteger(exec);</span>
1367     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1368     if (start &gt;= len || length &lt;= 0)
1369         return JSValue::encode(jsEmptyString(vm));
1370     if (start &lt; 0) {
1371         start += len;
1372         if (start &lt; 0)
1373             start = 0;
1374     }
1375     if (start + length &gt; len)
1376         length = len - start;
1377     unsigned substringStart = static_cast&lt;unsigned&gt;(start);
1378     unsigned substringLength = static_cast&lt;unsigned&gt;(length);
1379     scope.release();
1380     if (jsString)
<span class="line-modified">1381         return JSValue::encode(jsSubstring(exec, jsString, substringStart, substringLength));</span>
1382     return JSValue::encode(jsSubstring(vm, uString, substringStart, substringLength));
1383 }
1384 
<span class="line-modified">1385 EncodedJSValue JSC_HOST_CALL builtinStringSubstrInternal(ExecState* exec)</span>





1386 {
1387     // @substrInternal should not have any observable side effects (e.g. it should not call
1388     // GetMethod(..., @@toPrimitive) on the thisValue).
1389 
1390     // It is ok to use the default stringProtoFuncSubstr as the implementation of
1391     // @substrInternal because @substrInternal will only be called by builtins, which will
1392     // guarantee that we only pass it a string thisValue. As a result, stringProtoFuncSubstr
1393     // will not need to call toString() on the thisValue, and there will be no observable
1394     // side-effects.
<span class="line-modified">1395     ASSERT(exec-&gt;thisValue().isString());</span>
<span class="line-modified">1396     return stringProtoFuncSubstr(exec);</span>
1397 }
1398 
<span class="line-modified">1399 EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstring(ExecState* exec)</span>
1400 {
<span class="line-modified">1401     VM&amp; vm = exec-&gt;vm();</span>
1402     auto scope = DECLARE_THROW_SCOPE(vm);
1403 
<span class="line-modified">1404     JSValue thisValue = exec-&gt;thisValue();</span>
1405     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1406         return throwVMTypeError(exec, scope);</span>
1407 
<span class="line-modified">1408     JSString* jsString = thisValue.toString(exec);</span>
1409     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1410 
<span class="line-modified">1411     JSValue a0 = exec-&gt;argument(0);</span>
<span class="line-modified">1412     JSValue a1 = exec-&gt;argument(1);</span>
1413     int len = jsString-&gt;length();
1414     RELEASE_ASSERT(len &gt;= 0);
1415 
<span class="line-modified">1416     double start = a0.toNumber(exec);</span>
1417     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1418     double end;
1419     if (!(start &gt;= 0)) // check for negative values or NaN
1420         start = 0;
1421     else if (start &gt; len)
1422         start = len;
1423     if (a1.isUndefined())
1424         end = len;
1425     else {
<span class="line-modified">1426         end = a1.toNumber(exec);</span>
1427         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1428         if (!(end &gt;= 0)) // check for negative values or NaN
1429             end = 0;
1430         else if (end &gt; len)
1431             end = len;
1432     }
1433     if (start &gt; end) {
1434         double temp = end;
1435         end = start;
1436         start = temp;
1437     }
1438     unsigned substringStart = static_cast&lt;unsigned&gt;(start);
1439     unsigned substringLength = static_cast&lt;unsigned&gt;(end) - substringStart;
<span class="line-modified">1440     RELEASE_AND_RETURN(scope, JSValue::encode(jsSubstring(exec, jsString, substringStart, substringLength)));</span>
1441 }
1442 
<span class="line-modified">1443 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLowerCase(ExecState* exec)</span>
1444 {
<span class="line-modified">1445     VM&amp; vm = exec-&gt;vm();</span>
1446     auto scope = DECLARE_THROW_SCOPE(vm);
1447 
<span class="line-modified">1448     JSValue thisValue = exec-&gt;thisValue();</span>
1449     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1450         return throwVMTypeError(exec, scope);</span>
<span class="line-modified">1451     JSString* sVal = thisValue.toString(exec);</span>
1452     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1453     String s = sVal-&gt;value(exec);</span>
1454     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1455     String lowercasedString = s.convertToLowercaseWithoutLocale();
1456     if (lowercasedString.impl() == s.impl())
1457         return JSValue::encode(sVal);
1458     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, lowercasedString)));
1459 }
1460 
<span class="line-modified">1461 EncodedJSValue JSC_HOST_CALL stringProtoFuncToUpperCase(ExecState* exec)</span>
1462 {
<span class="line-modified">1463     VM&amp; vm = exec-&gt;vm();</span>
1464     auto scope = DECLARE_THROW_SCOPE(vm);
1465 
<span class="line-modified">1466     JSValue thisValue = exec-&gt;thisValue();</span>
1467     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1468         return throwVMTypeError(exec, scope);</span>
<span class="line-modified">1469     JSString* sVal = thisValue.toString(exec);</span>
1470     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1471     String s = sVal-&gt;value(exec);</span>
1472     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1473     String uppercasedString = s.convertToUppercaseWithoutLocale();
1474     if (uppercasedString.impl() == s.impl())
1475         return JSValue::encode(sVal);
1476     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, uppercasedString)));
1477 }
1478 
<span class="line-modified">1479 EncodedJSValue JSC_HOST_CALL stringProtoFuncLocaleCompare(ExecState* exec)</span>
1480 {
1481     // 13.1.1 String.prototype.localeCompare (that [, locales [, options ]]) (ECMA-402 2.0)
1482     // http://ecma-international.org/publications/standards/Ecma-402.htm
1483 
<span class="line-modified">1484     VM&amp; vm = exec-&gt;vm();</span>
1485     auto scope = DECLARE_THROW_SCOPE(vm);
1486 
1487     // 1. Let O be RequireObjectCoercible(this value).
<span class="line-modified">1488     JSValue thisValue = exec-&gt;thisValue();</span>
1489     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1490         return throwVMTypeError(exec, scope, &quot;String.prototype.localeCompare requires that |this| not be null or undefined&quot;_s);</span>
1491 
1492     // 2. Let S be ToString(O).
1493     // 3. ReturnIfAbrupt(S).
<span class="line-modified">1494     String string = thisValue.toWTFString(exec);</span>
1495     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1496 
1497     // 4. Let That be ToString(that).
1498     // 5. ReturnIfAbrupt(That).
<span class="line-modified">1499     JSValue thatValue = exec-&gt;argument(0);</span>
<span class="line-modified">1500     String that = thatValue.toWTFString(exec);</span>
1501     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1502 
1503 #if ENABLE(INTL)
<span class="line-modified">1504     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-modified">1505     JSValue locales = exec-&gt;argument(1);</span>
<span class="line-removed">1506     JSValue options = exec-&gt;argument(2);</span>
1507     IntlCollator* collator = nullptr;
<span class="line-modified">1508     if (locales.isUndefined() &amp;&amp; options.isUndefined()) {</span>
<span class="line-modified">1509         collator = globalObject-&gt;defaultCollator(exec);</span>
<span class="line-modified">1510         RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed">1511     } else {</span>
1512         collator = IntlCollator::create(vm, globalObject-&gt;collatorStructure());
<span class="line-modified">1513         collator-&gt;initializeCollator(*exec, locales, options);</span>
1514         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1515     }
<span class="line-modified">1516     RELEASE_AND_RETURN(scope, JSValue::encode(collator-&gt;compareStrings(*exec, string, that)));</span>
1517 #else
1518     return JSValue::encode(jsNumber(Collator().collate(string, that)));
1519 #endif
1520 }
1521 
1522 #if ENABLE(INTL)
<span class="line-modified">1523 static EncodedJSValue toLocaleCase(ExecState* state, int32_t (*convertCase)(UChar*, int32_t, const UChar*, int32_t, const char*, UErrorCode*))</span>





1524 {
<span class="line-modified">1525     VM&amp; vm = state-&gt;vm();</span>
1526     auto scope = DECLARE_THROW_SCOPE(vm);
1527 






1528     // 1. Let O be RequireObjectCoercible(this value).
<span class="line-modified">1529     JSValue thisValue = state-&gt;thisValue();</span>
1530     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1531         return throwVMTypeError(state, scope);</span>
1532 
1533     // 2. Let S be ToString(O).
<span class="line-modified">1534     JSString* sVal = thisValue.toString(state);</span>
1535     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1536     const String&amp; s = sVal-&gt;value(state);</span>
1537 
1538     // 3. ReturnIfAbrupt(S).
1539     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1540 
1541     // Optimization for empty strings.
1542     if (s.isEmpty())
1543         return JSValue::encode(sVal);
1544 
1545     // 4. Let requestedLocales be CanonicalizeLocaleList(locales).
<span class="line-modified">1546     Vector&lt;String&gt; requestedLocales = canonicalizeLocaleList(*state, state-&gt;argument(0));</span>
1547 
1548     // 5. ReturnIfAbrupt(requestedLocales).
1549     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1550 
1551     // 6. Let len be the number of elements in requestedLocales.
1552     size_t len = requestedLocales.size();
1553 
1554     // 7. If len &gt; 0, then
1555     // a. Let requestedLocale be the first element of requestedLocales.
1556     // 8. Else
1557     // a. Let requestedLocale be DefaultLocale().
<span class="line-modified">1558     String requestedLocale = len &gt; 0 ? requestedLocales.first() : defaultLocale(*state);</span>
1559 
1560     // 9. Let noExtensionsLocale be the String value that is requestedLocale with all Unicode locale extension sequences (6.2.1) removed.
1561     String noExtensionsLocale = removeUnicodeLocaleExtension(requestedLocale);
1562 
1563     // 10. Let availableLocales be a List with the language tags of the languages for which the Unicode character database contains language sensitive case mappings.
1564     // Note 1: As of Unicode 5.1, the availableLocales list contains the elements &quot;az&quot;, &quot;lt&quot;, and &quot;tr&quot;.
1565     const HashSet&lt;String&gt; availableLocales({ &quot;az&quot;_s, &quot;lt&quot;_s, &quot;tr&quot;_s });
1566 
1567     // 11. Let locale be BestAvailableLocale(availableLocales, noExtensionsLocale).
1568     String locale = bestAvailableLocale(availableLocales, noExtensionsLocale);
1569 
1570     // 12. If locale is undefined, let locale be &quot;und&quot;.
1571     if (locale.isNull())
1572         locale = &quot;und&quot;_s;
1573 
1574     CString utf8LocaleBuffer = locale.utf8();
1575     const StringView view(s);
1576     const int32_t viewLength = view.length();
1577 
1578     // Delegate the following steps to icu u_strToLower or u_strToUpper.
1579     // 13. Let cpList be a List containing in order the code points of S as defined in ES2015, 6.1.4, starting at the first element of S.
1580     // 14. For each code point c in cpList, if the Unicode Character Database provides a lower(/upper) case equivalent of c that is either language insensitive or for the language locale, then replace c in cpList with that/those equivalent code point(s).
1581     // 15. Let cuList be a new List.
1582     // 16. For each code point c in cpList, in order, append to cuList the elements of the UTF-16 Encoding (defined in ES2015, 6.1.4) of c.
1583     // 17. Let L be a String whose elements are, in order, the elements of cuList.
1584 
1585     // Most strings lower/upper case will be the same size as original, so try that first.
1586     UErrorCode error(U_ZERO_ERROR);
1587     Vector&lt;UChar&gt; buffer(viewLength);
1588     String lower;
1589     const int32_t resultLength = convertCase(buffer.data(), viewLength, view.upconvertedCharacters(), viewLength, utf8LocaleBuffer.data(), &amp;error);
1590     if (U_SUCCESS(error))
1591         lower = String(buffer.data(), resultLength);
1592     else if (error == U_BUFFER_OVERFLOW_ERROR) {
1593         // Converted case needs more space than original. Try again.
1594         UErrorCode error(U_ZERO_ERROR);
1595         Vector&lt;UChar&gt; buffer(resultLength);
1596         convertCase(buffer.data(), resultLength, view.upconvertedCharacters(), viewLength, utf8LocaleBuffer.data(), &amp;error);
1597         if (U_FAILURE(error))
<span class="line-modified">1598             return throwVMTypeError(state, scope, u_errorName(error));</span>
1599         lower = String(buffer.data(), resultLength);
1600     } else
<span class="line-modified">1601         return throwVMTypeError(state, scope, u_errorName(error));</span>
1602 
1603     // 18. Return L.
1604     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, lower)));
1605 }
1606 
<span class="line-modified">1607 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleLowerCase(ExecState* state)</span>
1608 {
1609     // 13.1.2 String.prototype.toLocaleLowerCase ([locales])
1610     // http://ecma-international.org/publications/standards/Ecma-402.htm
<span class="line-modified">1611     return toLocaleCase(state, u_strToLower);</span>
1612 }
1613 
<span class="line-modified">1614 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleUpperCase(ExecState* state)</span>
1615 {
1616     // 13.1.3 String.prototype.toLocaleUpperCase ([locales])
1617     // http://ecma-international.org/publications/standards/Ecma-402.htm
1618     // This function interprets a string value as a sequence of code points, as described in ES2015, 6.1.4. This function behaves in exactly the same way as String.prototype.toLocaleLowerCase, except that characters are mapped to their uppercase equivalents as specified in the Unicode character database.
<span class="line-modified">1619     return toLocaleCase(state, u_strToUpper);</span>
1620 }
1621 #endif // ENABLE(INTL)
1622 
1623 enum {
1624     TrimStart = 1,
1625     TrimEnd = 2
1626 };
1627 
<span class="line-modified">1628 static inline JSValue trimString(ExecState* exec, JSValue thisValue, int trimKind)</span>
1629 {
<span class="line-modified">1630     VM&amp; vm = exec-&gt;vm();</span>
1631     auto scope = DECLARE_THROW_SCOPE(vm);
1632 
1633     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1634         return throwTypeError(exec, scope);</span>
<span class="line-modified">1635     String str = thisValue.toWTFString(exec);</span>
1636     RETURN_IF_EXCEPTION(scope, { });
1637 
1638     unsigned left = 0;
1639     if (trimKind &amp; TrimStart) {
1640         while (left &lt; str.length() &amp;&amp; isStrWhiteSpace(str[left]))
1641             left++;
1642     }
1643     unsigned right = str.length();
1644     if (trimKind &amp; TrimEnd) {
1645         while (right &gt; left &amp;&amp; isStrWhiteSpace(str[right - 1]))
1646             right--;
1647     }
1648 
1649     // Don&#39;t gc allocate a new string if we don&#39;t have to.
1650     if (left == 0 &amp;&amp; right == str.length() &amp;&amp; thisValue.isString())
1651         return thisValue;
1652 
1653     RELEASE_AND_RETURN(scope, jsString(vm, str.substringSharingImpl(left, right - left)));
1654 }
1655 
<span class="line-modified">1656 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrim(ExecState* exec)</span>
1657 {
<span class="line-modified">1658     JSValue thisValue = exec-&gt;thisValue();</span>
<span class="line-modified">1659     return JSValue::encode(trimString(exec, thisValue, TrimStart | TrimEnd));</span>
1660 }
1661 
<span class="line-modified">1662 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimStart(ExecState* exec)</span>
1663 {
<span class="line-modified">1664     JSValue thisValue = exec-&gt;thisValue();</span>
<span class="line-modified">1665     return JSValue::encode(trimString(exec, thisValue, TrimStart));</span>
1666 }
1667 
<span class="line-modified">1668 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimEnd(ExecState* exec)</span>
1669 {
<span class="line-modified">1670     JSValue thisValue = exec-&gt;thisValue();</span>
<span class="line-modified">1671     return JSValue::encode(trimString(exec, thisValue, TrimEnd));</span>
1672 }
1673 
1674 static inline unsigned clampAndTruncateToUnsigned(double value, unsigned min, unsigned max)
1675 {
1676     if (value &lt; min)
1677         return min;
1678     if (value &gt; max)
1679         return max;
1680     return static_cast&lt;unsigned&gt;(value);
1681 }
1682 
<span class="line-modified">1683 EncodedJSValue JSC_HOST_CALL stringProtoFuncStartsWith(ExecState* exec)</span>
1684 {
<span class="line-modified">1685     VM&amp; vm = exec-&gt;vm();</span>
1686     auto scope = DECLARE_THROW_SCOPE(vm);
1687 
<span class="line-modified">1688     JSValue thisValue = exec-&gt;thisValue();</span>
1689     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1690         return throwVMTypeError(exec, scope);</span>
1691 
<span class="line-modified">1692     String stringToSearchIn = thisValue.toWTFString(exec);</span>
1693     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1694 
<span class="line-modified">1695     JSValue a0 = exec-&gt;argument(0);</span>
<span class="line-modified">1696     bool isRegularExpression = isRegExp(vm, exec, a0);</span>
1697     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1698     if (isRegularExpression)
<span class="line-modified">1699         return throwVMTypeError(exec, scope, &quot;Argument to String.prototype.startsWith cannot be a RegExp&quot;);</span>
1700 
<span class="line-modified">1701     String searchString = a0.toWTFString(exec);</span>
1702     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1703 
<span class="line-modified">1704     JSValue positionArg = exec-&gt;argument(1);</span>
1705     unsigned start = 0;
1706     if (positionArg.isInt32())
1707         start = std::max(0, positionArg.asInt32());
1708     else {
1709         unsigned length = stringToSearchIn.length();
<span class="line-modified">1710         start = clampAndTruncateToUnsigned(positionArg.toInteger(exec), 0, length);</span>
1711         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1712     }
1713 
1714     return JSValue::encode(jsBoolean(stringToSearchIn.hasInfixStartingAt(searchString, start)));
1715 }
1716 
<span class="line-modified">1717 EncodedJSValue JSC_HOST_CALL stringProtoFuncEndsWith(ExecState* exec)</span>
1718 {
<span class="line-modified">1719     VM&amp; vm = exec-&gt;vm();</span>
1720     auto scope = DECLARE_THROW_SCOPE(vm);
1721 
<span class="line-modified">1722     JSValue thisValue = exec-&gt;thisValue();</span>
1723     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1724         return throwVMTypeError(exec, scope);</span>
1725 
<span class="line-modified">1726     String stringToSearchIn = thisValue.toWTFString(exec);</span>
1727     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1728 
<span class="line-modified">1729     JSValue a0 = exec-&gt;argument(0);</span>
<span class="line-modified">1730     bool isRegularExpression = isRegExp(vm, exec, a0);</span>
1731     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1732     if (isRegularExpression)
<span class="line-modified">1733         return throwVMTypeError(exec, scope, &quot;Argument to String.prototype.endsWith cannot be a RegExp&quot;);</span>
1734 
<span class="line-modified">1735     String searchString = a0.toWTFString(exec);</span>
1736     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1737 
1738     unsigned length = stringToSearchIn.length();
1739 
<span class="line-modified">1740     JSValue endPositionArg = exec-&gt;argument(1);</span>
1741     unsigned end = length;
1742     if (endPositionArg.isInt32())
1743         end = std::max(0, endPositionArg.asInt32());
1744     else if (!endPositionArg.isUndefined()) {
<span class="line-modified">1745         end = clampAndTruncateToUnsigned(endPositionArg.toInteger(exec), 0, length);</span>
1746         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1747     }
1748 
1749     return JSValue::encode(jsBoolean(stringToSearchIn.hasInfixEndingAt(searchString, std::min(end, length))));
1750 }
1751 
<span class="line-modified">1752 static EncodedJSValue JSC_HOST_CALL stringIncludesImpl(VM&amp; vm, ExecState* exec, String stringToSearchIn, String searchString, JSValue positionArg)</span>
1753 {
1754     auto scope = DECLARE_THROW_SCOPE(vm);
1755     unsigned start = 0;
1756     if (positionArg.isInt32())
1757         start = std::max(0, positionArg.asInt32());
1758     else {
1759         unsigned length = stringToSearchIn.length();
<span class="line-modified">1760         start = clampAndTruncateToUnsigned(positionArg.toInteger(exec), 0, length);</span>
1761         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1762     }
1763 
1764     return JSValue::encode(jsBoolean(stringToSearchIn.find(searchString, start) != notFound));
1765 }
1766 
<span class="line-modified">1767 EncodedJSValue JSC_HOST_CALL stringProtoFuncIncludes(ExecState* exec)</span>
1768 {
<span class="line-modified">1769     VM&amp; vm = exec-&gt;vm();</span>
1770     auto scope = DECLARE_THROW_SCOPE(vm);
1771 
<span class="line-modified">1772     JSValue thisValue = exec-&gt;thisValue();</span>
1773     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1774         return throwVMTypeError(exec, scope);</span>
1775 
<span class="line-modified">1776     String stringToSearchIn = thisValue.toWTFString(exec);</span>
1777     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1778 
<span class="line-modified">1779     JSValue a0 = exec-&gt;argument(0);</span>
<span class="line-modified">1780     bool isRegularExpression = isRegExp(vm, exec, a0);</span>
1781     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1782     if (isRegularExpression)
<span class="line-modified">1783         return throwVMTypeError(exec, scope, &quot;Argument to String.prototype.includes cannot be a RegExp&quot;);</span>
1784 
<span class="line-modified">1785     String searchString = a0.toWTFString(exec);</span>
1786     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1787 
<span class="line-modified">1788     JSValue positionArg = exec-&gt;argument(1);</span>
1789 
<span class="line-modified">1790     RELEASE_AND_RETURN(scope, stringIncludesImpl(vm, exec, stringToSearchIn, searchString, positionArg));</span>
1791 }
1792 
<span class="line-modified">1793 EncodedJSValue JSC_HOST_CALL builtinStringIncludesInternal(ExecState* exec)</span>
1794 {
<span class="line-modified">1795     VM&amp; vm = exec-&gt;vm();</span>
1796     auto scope = DECLARE_THROW_SCOPE(vm);
1797 
<span class="line-modified">1798     JSValue thisValue = exec-&gt;thisValue();</span>
1799     ASSERT(checkObjectCoercible(thisValue));
1800 
<span class="line-modified">1801     String stringToSearchIn = thisValue.toWTFString(exec);</span>
1802     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1803 
<span class="line-modified">1804     JSValue a0 = exec-&gt;uncheckedArgument(0);</span>
<span class="line-modified">1805     String searchString = a0.toWTFString(exec);</span>
1806     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1807 
<span class="line-modified">1808     JSValue positionArg = exec-&gt;argument(1);</span>
1809 
<span class="line-modified">1810     RELEASE_AND_RETURN(scope, stringIncludesImpl(vm, exec, stringToSearchIn, searchString, positionArg));</span>
1811 }
1812 
<span class="line-modified">1813 EncodedJSValue JSC_HOST_CALL stringProtoFuncIterator(ExecState* exec)</span>
1814 {
<span class="line-modified">1815     VM&amp; vm = exec-&gt;vm();</span>
1816     auto scope = DECLARE_THROW_SCOPE(vm);
1817 
<span class="line-modified">1818     JSValue thisValue = exec-&gt;thisValue();</span>
1819     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1820         return throwVMTypeError(exec, scope);</span>
<span class="line-modified">1821     JSString* string = thisValue.toString(exec);</span>
1822     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1823     return JSValue::encode(JSStringIterator::create(exec, exec-&gt;jsCallee()-&gt;globalObject(vm)-&gt;stringIteratorStructure(), string));</span>
1824 }
1825 
1826 enum class NormalizationForm { NFC, NFD, NFKC, NFKD };
1827 
1828 static constexpr bool normalizationAffects8Bit(NormalizationForm form)
1829 {
1830     switch (form) {
1831     case NormalizationForm::NFC:
1832         return false;
1833     case NormalizationForm::NFD:
1834         return true;
1835     case NormalizationForm::NFKC:
1836         return false;
1837     case NormalizationForm::NFKD:
1838         return true;
1839     default:
1840         ASSERT_NOT_REACHED();
1841     }
1842     return true;
1843 }
</pre>
<hr />
<pre>
1848     const UNormalizer2* normalizer = nullptr;
1849     switch (form) {
1850     case NormalizationForm::NFC:
1851         normalizer = unorm2_getNFCInstance(&amp;status);
1852         break;
1853     case NormalizationForm::NFD:
1854         normalizer = unorm2_getNFDInstance(&amp;status);
1855         break;
1856     case NormalizationForm::NFKC:
1857         normalizer = unorm2_getNFKCInstance(&amp;status);
1858         break;
1859     case NormalizationForm::NFKD:
1860         normalizer = unorm2_getNFKDInstance(&amp;status);
1861         break;
1862     }
1863     ASSERT(normalizer);
1864     ASSERT(U_SUCCESS(status));
1865     return normalizer;
1866 }
1867 
<span class="line-modified">1868 static JSValue normalize(ExecState* exec, JSString* string, NormalizationForm form)</span>
1869 {
<span class="line-modified">1870     VM&amp; vm = exec-&gt;vm();</span>
1871     auto scope = DECLARE_THROW_SCOPE(vm);
1872 
<span class="line-modified">1873     auto viewWithString = string-&gt;viewWithUnderlyingString(exec);</span>
1874     RETURN_IF_EXCEPTION(scope, { });
1875 
1876     StringView view = viewWithString.view;
1877     if (view.is8Bit() &amp;&amp; (!normalizationAffects8Bit(form) || charactersAreAllASCII(view.characters8(), view.length())))
1878         RELEASE_AND_RETURN(scope, string);
1879 
1880     const UNormalizer2* normalizer = JSC::normalizer(form);
1881 
1882     // Since ICU does not offer functions that can perform normalization or check for
1883     // normalization with input that is Latin-1, we need to upconvert to UTF-16 at this point.
1884     auto characters = view.upconvertedCharacters();
1885 
1886     UErrorCode status = U_ZERO_ERROR;
1887     UBool isNormalized = unorm2_isNormalized(normalizer, characters, view.length(), &amp;status);
1888     ASSERT(U_SUCCESS(status));
1889     if (isNormalized)
1890         RELEASE_AND_RETURN(scope, string);
1891 
1892     int32_t normalizedStringLength = unorm2_normalize(normalizer, characters, view.length(), nullptr, 0, &amp;status);
1893     ASSERT(status == U_BUFFER_OVERFLOW_ERROR);
1894 
1895     UChar* buffer;
1896     auto result = StringImpl::tryCreateUninitialized(normalizedStringLength, buffer);
1897     if (!result)
<span class="line-modified">1898         return throwOutOfMemoryError(exec, scope);</span>
1899 
1900     status = U_ZERO_ERROR;
1901     unorm2_normalize(normalizer, characters, view.length(), buffer, normalizedStringLength, &amp;status);
1902     ASSERT(U_SUCCESS(status));
1903 
1904     RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(result)));
1905 }
1906 
<span class="line-modified">1907 EncodedJSValue JSC_HOST_CALL stringProtoFuncNormalize(ExecState* exec)</span>
1908 {
<span class="line-modified">1909     VM&amp; vm = exec-&gt;vm();</span>
1910     auto scope = DECLARE_THROW_SCOPE(vm);
1911 
<span class="line-modified">1912     JSValue thisValue = exec-&gt;thisValue();</span>
1913     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1914         return throwVMTypeError(exec, scope);</span>
<span class="line-modified">1915     JSString* string = thisValue.toString(exec);</span>
1916     RETURN_IF_EXCEPTION(scope, { });
1917 
1918     auto form = NormalizationForm::NFC;
<span class="line-modified">1919     JSValue formValue = exec-&gt;argument(0);</span>
1920     if (!formValue.isUndefined()) {
<span class="line-modified">1921         String formString = formValue.toWTFString(exec);</span>
1922         RETURN_IF_EXCEPTION(scope, { });
1923 
1924         if (formString == &quot;NFC&quot;)
1925             form = NormalizationForm::NFC;
1926         else if (formString == &quot;NFD&quot;)
1927             form = NormalizationForm::NFD;
1928         else if (formString == &quot;NFKC&quot;)
1929             form = NormalizationForm::NFKC;
1930         else if (formString == &quot;NFKD&quot;)
1931             form = NormalizationForm::NFKD;
1932         else
<span class="line-modified">1933             return throwVMRangeError(exec, scope, &quot;argument does not match any normalization form&quot;_s);</span>
1934     }
1935 
<span class="line-modified">1936     RELEASE_AND_RETURN(scope, JSValue::encode(normalize(exec, string, form)));</span>
1937 }
1938 
1939 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;StringPrototype.h&quot;
  25 
  26 #include &quot;BuiltinNames.h&quot;
  27 #include &quot;ButterflyInlines.h&quot;
  28 #include &quot;CachedCall.h&quot;
  29 #include &quot;Error.h&quot;
  30 #include &quot;FrameTracers.h&quot;
  31 #include &quot;InterpreterInlines.h&quot;
  32 #include &quot;IntlCollator.h&quot;
  33 #include &quot;IntlObject.h&quot;
  34 #include &quot;JITCodeInlines.h&quot;
  35 #include &quot;JSArray.h&quot;
  36 #include &quot;JSCBuiltins.h&quot;
  37 #include &quot;JSCInlines.h&quot;
  38 #include &quot;JSFunction.h&quot;
  39 #include &quot;JSGlobalObjectFunctions.h&quot;
  40 #include &quot;JSStringIterator.h&quot;
  41 #include &quot;Lookup.h&quot;
<span class="line-added">  42 #include &quot;ObjectConstructor.h&quot;</span>
  43 #include &quot;ObjectPrototype.h&quot;
  44 #include &quot;ParseInt.h&quot;
  45 #include &quot;PropertyNameArray.h&quot;
  46 #include &quot;RegExpCache.h&quot;
  47 #include &quot;RegExpConstructor.h&quot;
  48 #include &quot;RegExpGlobalDataInlines.h&quot;
  49 #include &quot;StringPrototypeInlines.h&quot;
  50 #include &quot;SuperSampler.h&quot;
  51 #include &lt;algorithm&gt;
  52 #include &lt;unicode/uconfig.h&gt;
  53 #include &lt;unicode/unorm2.h&gt;
  54 #include &lt;unicode/ustring.h&gt;
  55 #include &lt;wtf/ASCIICType.h&gt;
  56 #include &lt;wtf/MathExtras.h&gt;
  57 #include &lt;wtf/text/StringBuilder.h&gt;
  58 #include &lt;wtf/text/StringView.h&gt;
  59 #include &lt;wtf/unicode/Collator.h&gt;
  60 
  61 namespace JSC {
  62 
  63 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(StringPrototype);
  64 
<span class="line-modified">  65 EncodedJSValue JSC_HOST_CALL stringProtoFuncToString(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  66 EncodedJSValue JSC_HOST_CALL stringProtoFuncCharAt(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  67 EncodedJSValue JSC_HOST_CALL stringProtoFuncCharCodeAt(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  68 EncodedJSValue JSC_HOST_CALL stringProtoFuncCodePointAt(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  69 EncodedJSValue JSC_HOST_CALL stringProtoFuncIndexOf(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  70 EncodedJSValue JSC_HOST_CALL stringProtoFuncLastIndexOf(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  71 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingRegExp(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  72 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingStringSearch(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  73 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceAllUsingStringSearch(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  74 EncodedJSValue JSC_HOST_CALL stringProtoFuncSlice(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  75 EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstr(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  76 EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstring(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  77 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLowerCase(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  78 EncodedJSValue JSC_HOST_CALL stringProtoFuncToUpperCase(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  79 EncodedJSValue JSC_HOST_CALL stringProtoFuncLocaleCompare(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  80 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleLowerCase(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  81 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleUpperCase(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  82 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrim(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  83 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimStart(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  84 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimEnd(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  85 EncodedJSValue JSC_HOST_CALL stringProtoFuncStartsWith(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  86 EncodedJSValue JSC_HOST_CALL stringProtoFuncEndsWith(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  87 EncodedJSValue JSC_HOST_CALL stringProtoFuncIncludes(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  88 EncodedJSValue JSC_HOST_CALL stringProtoFuncNormalize(JSGlobalObject*, CallFrame*);</span>
<span class="line-added">  89 EncodedJSValue JSC_HOST_CALL stringProtoFuncIterator(JSGlobalObject*, CallFrame*);</span>
  90 
  91 }
  92 
  93 #include &quot;StringPrototype.lut.h&quot;
  94 
  95 namespace JSC {
  96 
  97 const ClassInfo StringPrototype::s_info = { &quot;String&quot;, &amp;StringObject::s_info, &amp;stringPrototypeTable, nullptr, CREATE_METHOD_TABLE(StringPrototype) };
  98 
  99 /* Source for StringConstructor.lut.h
 100 @begin stringPrototypeTable
<span class="line-modified"> 101     concat        JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified"> 102     match         JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified"> 103     matchAll      JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified"> 104     padStart      JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified"> 105     padEnd        JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified"> 106     repeat        JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified"> 107     replace       JSBuiltin    DontEnum|Function 2</span>
<span class="line-modified"> 108     replaceAll    JSBuiltin    DontEnum|Function 2</span>
<span class="line-modified"> 109     search        JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified"> 110     split         JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified"> 111     anchor        JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified"> 112     big           JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified"> 113     bold          JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified"> 114     blink         JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified"> 115     fixed         JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified"> 116     fontcolor     JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified"> 117     fontsize      JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified"> 118     italics       JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified"> 119     link          JSBuiltin    DontEnum|Function 1</span>
<span class="line-modified"> 120     small         JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified"> 121     strike        JSBuiltin    DontEnum|Function 0</span>
<span class="line-modified"> 122     sub           JSBuiltin    DontEnum|Function 0</span>
<span class="line-added"> 123     sup           JSBuiltin    DontEnum|Function 0</span>
 124 @end
 125 */
 126 
 127 // ECMA 15.5.4
 128 StringPrototype::StringPrototype(VM&amp; vm, Structure* structure)
 129     : StringObject(vm, structure)
 130 {
 131 }
 132 
 133 void StringPrototype::finishCreation(VM&amp; vm, JSGlobalObject* globalObject, JSString* nameAndMessage)
 134 {
 135     Base::finishCreation(vm, nameAndMessage);
 136     ASSERT(inherits(vm, info()));
 137 
 138     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;toString, stringProtoFuncToString, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, StringPrototypeValueOfIntrinsic);
 139     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;valueOf, stringProtoFuncToString, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, StringPrototypeValueOfIntrinsic);
 140     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;charAt&quot;, stringProtoFuncCharAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, CharAtIntrinsic);
 141     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;charCodeAt&quot;, stringProtoFuncCharCodeAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, CharCodeAtIntrinsic);
<span class="line-modified"> 142     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;codePointAt&quot;, stringProtoFuncCodePointAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, StringPrototypeCodePointAtIntrinsic);</span>
 143     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;indexOf&quot;, stringProtoFuncIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 144     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;lastIndexOf&quot;, stringProtoFuncLastIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 145     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().replaceUsingRegExpPrivateName(), stringProtoFuncReplaceUsingRegExp, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2, StringPrototypeReplaceRegExpIntrinsic);
 146     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().replaceUsingStringSearchPrivateName(), stringProtoFuncReplaceUsingStringSearch, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
<span class="line-added"> 147     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().replaceAllUsingStringSearchPrivateName(), stringProtoFuncReplaceAllUsingStringSearch, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);</span>
 148     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;slice&quot;, stringProtoFuncSlice, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2, StringPrototypeSliceIntrinsic);
 149     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;substr&quot;, stringProtoFuncSubstr, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
 150     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;substring&quot;, stringProtoFuncSubstring, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
 151     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;toLowerCase&quot;, stringProtoFuncToLowerCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, StringPrototypeToLowerCaseIntrinsic);
 152     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toUpperCase&quot;, stringProtoFuncToUpperCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 153     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;localeCompare&quot;, stringProtoFuncLocaleCompare, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 154 #if ENABLE(INTL)
 155     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleLowerCase&quot;, stringProtoFuncToLocaleLowerCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 156     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleUpperCase&quot;, stringProtoFuncToLocaleUpperCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 157 #else
 158     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleLowerCase&quot;, stringProtoFuncToLowerCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 159     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleUpperCase&quot;, stringProtoFuncToUpperCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 160 #endif
 161     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;trim&quot;, stringProtoFuncTrim, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 162     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;startsWith&quot;, stringProtoFuncStartsWith, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 163     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;endsWith&quot;, stringProtoFuncEndsWith, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 164     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;includes&quot;, stringProtoFuncIncludes, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 165     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;normalize&quot;, stringProtoFuncNormalize, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 166     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().charCodeAtPrivateName(), stringProtoFuncCharCodeAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, CharCodeAtIntrinsic);
 167 
</pre>
<hr />
<pre>
 203             ++i;
 204             result.append(replacement.substring(offset, i - offset));
 205             offset = i + 1;
 206             continue;
 207         }
 208 
 209         int backrefStart;
 210         int backrefLength;
 211         int advance = 0;
 212         if (ref == &#39;&amp;&#39;) {
 213             backrefStart = ovector[0];
 214             backrefLength = ovector[1] - backrefStart;
 215         } else if (ref == &#39;`&#39;) {
 216             backrefStart = 0;
 217             backrefLength = ovector[0];
 218         } else if (ref == &#39;\&#39;&#39;) {
 219             backrefStart = ovector[1];
 220             backrefLength = source.length() - backrefStart;
 221         } else if (reg &amp;&amp; ref == &#39;&lt;&#39;) {
 222             // Named back reference
<span class="line-modified"> 223             if (!hasNamedCaptures)</span>



 224                 continue;

 225 
 226             size_t closingBracket = replacement.find(&#39;&gt;&#39;, i + 2);
<span class="line-modified"> 227             if (closingBracket == WTF::notFound)</span>




 228                 continue;

 229 
 230             unsigned nameLength = closingBracket - i - 2;
 231             unsigned backrefIndex = reg-&gt;subpatternForName(replacement.substring(i + 2, nameLength).toString());
 232 
 233             if (!backrefIndex || backrefIndex &gt; reg-&gt;numSubpatterns()) {





 234                 backrefStart = 0;
 235                 backrefLength = 0;
 236             } else {
 237                 backrefStart = ovector[2 * backrefIndex];
 238                 backrefLength = ovector[2 * backrefIndex + 1] - backrefStart;
 239             }
 240             advance = nameLength + 1;
 241         } else if (reg &amp;&amp; isASCIIDigit(ref)) {
 242             // 1- and 2-digit back references are allowed
 243             unsigned backrefIndex = ref - &#39;0&#39;;
 244             if (backrefIndex &gt; reg-&gt;numSubpatterns())
 245                 continue;
 246             if (replacement.length() &gt; i + 2) {
 247                 ref = replacement[i + 2];
 248                 if (isASCIIDigit(ref)) {
 249                     backrefIndex = 10 * backrefIndex + ref - &#39;0&#39;;
 250                     if (backrefIndex &gt; reg-&gt;numSubpatterns())
 251                         backrefIndex = backrefIndex / 10;   // Fall back to the 1-digit reference
 252                     else
 253                         advance = 1;
</pre>
<hr />
<pre>
 284 void substituteBackreferences(StringBuilder&amp; result, const String&amp; replacement, StringView source, const int* ovector, RegExp* reg)
 285 {
 286     substituteBackreferencesInline(result, replacement, source, ovector, reg);
 287 }
 288 
 289 struct StringRange {
 290     StringRange(int pos, int len)
 291         : position(pos)
 292         , length(len)
 293     {
 294     }
 295 
 296     StringRange()
 297     {
 298     }
 299 
 300     int position;
 301     int length;
 302 };
 303 
<span class="line-modified"> 304 static ALWAYS_INLINE JSString* jsSpliceSubstrings(JSGlobalObject* globalObject, JSString* sourceVal, const String&amp; source, const StringRange* substringRanges, int rangeCount)</span>
 305 {
<span class="line-modified"> 306     VM&amp; vm = globalObject-&gt;vm();</span>
 307     auto scope = DECLARE_THROW_SCOPE(vm);
 308 
 309     if (rangeCount == 1) {
 310         int sourceSize = source.length();
 311         int position = substringRanges[0].position;
 312         int length = substringRanges[0].length;
 313         if (position &lt;= 0 &amp;&amp; length &gt;= sourceSize)
 314             return sourceVal;
 315         // We could call String::substringSharingImpl(), but this would result in redundant checks.
 316         RELEASE_AND_RETURN(scope, jsString(vm, StringImpl::createSubstringSharingImpl(*source.impl(), std::max(0, position), std::min(sourceSize, length))));
 317     }
 318 
 319     // We know that the sum of substringRanges lengths cannot exceed length of
 320     // source because the substringRanges were computed from the source string
 321     // in removeUsingRegExpSearch(). Hence, totalLength cannot exceed
 322     // String::MaxLength, and therefore, cannot overflow.
 323     Checked&lt;int, AssertNoOverflow&gt; totalLength = 0;
 324     for (int i = 0; i &lt; rangeCount; i++)
 325         totalLength += substringRanges[i].length;
 326     ASSERT(totalLength &lt;= String::MaxLength);
 327 
 328     if (!totalLength)
 329         return jsEmptyString(vm);
 330 
 331     if (source.is8Bit()) {
 332         LChar* buffer;
 333         const LChar* sourceData = source.characters8();
 334         auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 335         if (!impl) {
<span class="line-modified"> 336             throwOutOfMemoryError(globalObject, scope);</span>
 337             return nullptr;
 338         }
 339 
 340         Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 341         for (int i = 0; i &lt; rangeCount; i++) {
 342             if (int srcLen = substringRanges[i].length) {
 343                 StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), sourceData + substringRanges[i].position, srcLen);
 344                 bufferPos += srcLen;
 345             }
 346         }
 347 
 348         RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(impl)));
 349     }
 350 
 351     UChar* buffer;
 352     const UChar* sourceData = source.characters16();
 353 
 354     auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 355     if (!impl) {
<span class="line-modified"> 356         throwOutOfMemoryError(globalObject, scope);</span>
 357         return nullptr;
 358     }
 359 
 360     Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 361     for (int i = 0; i &lt; rangeCount; i++) {
 362         if (int srcLen = substringRanges[i].length) {
 363             StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), sourceData + substringRanges[i].position, srcLen);
 364             bufferPos += srcLen;
 365         }
 366     }
 367 
 368     RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(impl)));
 369 }
 370 
<span class="line-modified"> 371 static ALWAYS_INLINE JSString* jsSpliceSubstringsWithSeparators(JSGlobalObject* globalObject, JSString* sourceVal, const String&amp; source, const StringRange* substringRanges, int rangeCount, const String* separators, int separatorCount)</span>
 372 {
<span class="line-modified"> 373     VM&amp; vm = globalObject-&gt;vm();</span>
 374     auto scope = DECLARE_THROW_SCOPE(vm);
 375 
 376     if (rangeCount == 1 &amp;&amp; separatorCount == 0) {
 377         int sourceSize = source.length();
 378         int position = substringRanges[0].position;
 379         int length = substringRanges[0].length;
 380         if (position &lt;= 0 &amp;&amp; length &gt;= sourceSize)
 381             return sourceVal;
 382         // We could call String::substringSharingImpl(), but this would result in redundant checks.
 383         RELEASE_AND_RETURN(scope, jsString(vm, StringImpl::createSubstringSharingImpl(*source.impl(), std::max(0, position), std::min(sourceSize, length))));
 384     }
 385 
<span class="line-added"> 386     if (rangeCount == 2 &amp;&amp; separatorCount == 1) {</span>
<span class="line-added"> 387         String leftPart(StringImpl::createSubstringSharingImpl(*source.impl(), substringRanges[0].position, substringRanges[0].length));</span>
<span class="line-added"> 388         String rightPart(StringImpl::createSubstringSharingImpl(*source.impl(), substringRanges[1].position, substringRanges[1].length));</span>
<span class="line-added"> 389         RELEASE_AND_RETURN(scope, jsString(globalObject, leftPart, separators[0], rightPart));</span>
<span class="line-added"> 390     }</span>
<span class="line-added"> 391 </span>
 392     Checked&lt;int, RecordOverflow&gt; totalLength = 0;
 393     bool allSeparators8Bit = true;
 394     for (int i = 0; i &lt; rangeCount; i++)
 395         totalLength += substringRanges[i].length;
 396     for (int i = 0; i &lt; separatorCount; i++) {
 397         totalLength += separators[i].length();
 398         if (separators[i].length() &amp;&amp; !separators[i].is8Bit())
 399             allSeparators8Bit = false;
 400     }
 401     if (totalLength.hasOverflowed()) {
<span class="line-modified"> 402         throwOutOfMemoryError(globalObject, scope);</span>
 403         return nullptr;
 404     }
 405 
 406     if (!totalLength)
 407         return jsEmptyString(vm);
 408 
 409     if (source.is8Bit() &amp;&amp; allSeparators8Bit) {
 410         LChar* buffer;
 411         const LChar* sourceData = source.characters8();
 412 
 413         auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 414         if (!impl) {
<span class="line-modified"> 415             throwOutOfMemoryError(globalObject, scope);</span>
 416             return nullptr;
 417         }
 418 
 419         int maxCount = std::max(rangeCount, separatorCount);
 420         Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 421         for (int i = 0; i &lt; maxCount; i++) {
 422             if (i &lt; rangeCount) {
 423                 if (int srcLen = substringRanges[i].length) {
 424                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), sourceData + substringRanges[i].position, srcLen);
 425                     bufferPos += srcLen;
 426                 }
 427             }
 428             if (i &lt; separatorCount) {
 429                 if (int sepLen = separators[i].length()) {
 430                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), separators[i].characters8(), sepLen);
 431                     bufferPos += sepLen;
 432                 }
 433             }
 434         }
 435 
 436         RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(impl)));
 437     }
 438 
 439     UChar* buffer;
 440     auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 441     if (!impl) {
<span class="line-modified"> 442         throwOutOfMemoryError(globalObject, scope);</span>
 443         return nullptr;
 444     }
 445 
 446     int maxCount = std::max(rangeCount, separatorCount);
 447     Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 448     for (int i = 0; i &lt; maxCount; i++) {
 449         if (i &lt; rangeCount) {
 450             if (int srcLen = substringRanges[i].length) {
 451                 if (source.is8Bit())
 452                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), source.characters8() + substringRanges[i].position, srcLen);
 453                 else
 454                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), source.characters16() + substringRanges[i].position, srcLen);
 455                 bufferPos += srcLen;
 456             }
 457         }
 458         if (i &lt; separatorCount) {
 459             if (int sepLen = separators[i].length()) {
 460                 if (separators[i].is8Bit())
 461                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), separators[i].characters8(), sepLen);
 462                 else
 463                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), separators[i].characters16(), sepLen);
 464                 bufferPos += sepLen;
 465             }
 466         }
 467     }
 468 
 469     RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(impl)));
 470 }
 471 
 472 #define OUT_OF_MEMORY(exec__, scope__) \
 473     do { \
 474         throwOutOfMemoryError(exec__, scope__); \
 475         return nullptr; \
 476     } while (false)
 477 
<span class="line-modified"> 478 static ALWAYS_INLINE JSString* removeUsingRegExpSearch(VM&amp; vm, JSGlobalObject* globalObject, JSString* string, const String&amp; source, RegExp* regExp)</span>
 479 {
 480     auto scope = DECLARE_THROW_SCOPE(vm);
 481     SuperSamplerScope superSamplerScope(false);
 482 
 483     size_t lastIndex = 0;
 484     unsigned startPosition = 0;
 485 
 486     Vector&lt;StringRange, 16&gt; sourceRanges;

 487     unsigned sourceLen = source.length();
 488 
 489     while (true) {
 490         MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, source, startPosition);
 491         RETURN_IF_EXCEPTION(scope, nullptr);
 492         if (!result)
 493             break;
 494 
 495         if (lastIndex &lt; result.start) {
 496             if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
<span class="line-modified"> 497                 OUT_OF_MEMORY(globalObject, scope);</span>
 498         }
 499         lastIndex = result.end;
 500         startPosition = lastIndex;
 501 
 502         // special case of empty match
 503         if (result.empty()) {
 504             startPosition++;
 505             if (startPosition &gt; sourceLen)
 506                 break;
 507         }
 508     }
 509 
 510     if (!lastIndex)
 511         return string;
 512 
 513     if (static_cast&lt;unsigned&gt;(lastIndex) &lt; sourceLen) {
 514         if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, sourceLen - lastIndex)))
<span class="line-modified"> 515             OUT_OF_MEMORY(globalObject, scope);</span>
 516     }
<span class="line-modified"> 517     RELEASE_AND_RETURN(scope, jsSpliceSubstrings(globalObject, string, source, sourceRanges.data(), sourceRanges.size()));</span>
 518 }
 519 
 520 static ALWAYS_INLINE JSString* replaceUsingRegExpSearch(
<span class="line-modified"> 521     VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame, JSString* string, JSValue searchValue, CallData&amp; callData,</span>
 522     CallType callType, String&amp; replacementString, JSValue replaceValue)
 523 {
 524     auto scope = DECLARE_THROW_SCOPE(vm);
 525 
<span class="line-modified"> 526     String source = string-&gt;value(globalObject);</span>
 527     RETURN_IF_EXCEPTION(scope, nullptr);
 528     unsigned sourceLen = source.length();
 529     RETURN_IF_EXCEPTION(scope, nullptr);
 530     RegExpObject* regExpObject = jsCast&lt;RegExpObject*&gt;(searchValue);
 531     RegExp* regExp = regExpObject-&gt;regExp();
 532     bool global = regExp-&gt;global();
 533     bool hasNamedCaptures = regExp-&gt;hasNamedCaptures();
 534 
 535     if (global) {
 536         // ES5.1 15.5.4.10 step 8.a.
<span class="line-modified"> 537         regExpObject-&gt;setLastIndex(globalObject, 0);</span>
 538         RETURN_IF_EXCEPTION(scope, nullptr);
 539 
 540         if (callType == CallType::None &amp;&amp; !replacementString.length())
<span class="line-modified"> 541             RELEASE_AND_RETURN(scope, removeUsingRegExpSearch(vm, globalObject, string, source, regExp));</span>
 542     }
 543 




 544     size_t lastIndex = 0;
 545     unsigned startPosition = 0;
 546 
 547     Vector&lt;StringRange, 16&gt; sourceRanges;
 548     Vector&lt;String, 16&gt; replacements;
 549 
 550     // This is either a loop (if global is set) or a one-way (if not).
 551     if (global &amp;&amp; callType == CallType::JS) {
 552         // regExp-&gt;numSubpatterns() + 1 for pattern args, + 2 for match start and string
 553         int argCount = regExp-&gt;numSubpatterns() + 1 + 2;
 554         if (hasNamedCaptures)
 555             ++argCount;
 556         JSFunction* func = jsCast&lt;JSFunction*&gt;(replaceValue);
<span class="line-modified"> 557         CachedCall cachedCall(globalObject, callFrame, func, argCount);</span>
 558         RETURN_IF_EXCEPTION(scope, nullptr);
 559         while (true) {
 560             int* ovector;
 561             MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, source, startPosition, &amp;ovector);
 562             RETURN_IF_EXCEPTION(scope, nullptr);
 563             if (!result)
 564                 break;
 565 
 566             if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
<span class="line-modified"> 567                 OUT_OF_MEMORY(globalObject, scope);</span>
 568 
 569             cachedCall.clearArguments();
<span class="line-modified"> 570             JSObject* groups = hasNamedCaptures ? constructEmptyObject(vm, globalObject-&gt;nullPrototypeObjectStructure()) : nullptr;</span>






 571 
 572             for (unsigned i = 0; i &lt; regExp-&gt;numSubpatterns() + 1; ++i) {
 573                 int matchStart = ovector[i * 2];
 574                 int matchLen = ovector[i * 2 + 1] - matchStart;
 575 
 576                 JSValue patternValue;
 577 
 578                 if (matchStart &lt; 0)
 579                     patternValue = jsUndefined();
 580                 else
 581                     patternValue = jsSubstring(vm, source, matchStart, matchLen);
 582 
 583                 cachedCall.appendArgument(patternValue);
 584 
 585                 if (i &amp;&amp; hasNamedCaptures) {
 586                     String groupName = regExp-&gt;getCaptureGroupName(i);
 587                     if (!groupName.isEmpty())
 588                         groups-&gt;putDirect(vm, Identifier::fromString(vm, groupName), patternValue);
 589                 }
 590             }
 591 
 592             cachedCall.appendArgument(jsNumber(result.start));
 593             cachedCall.appendArgument(string);
 594             if (hasNamedCaptures)
 595                 cachedCall.appendArgument(groups);
 596 
 597             cachedCall.setThis(jsUndefined());
 598             if (UNLIKELY(cachedCall.hasOverflowedArguments())) {
<span class="line-modified"> 599                 throwOutOfMemoryError(globalObject, scope);</span>
 600                 return nullptr;
 601             }
 602 
 603             JSValue jsResult = cachedCall.call();
 604             RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 605             replacements.append(jsResult.toWTFString(globalObject));</span>
 606             RETURN_IF_EXCEPTION(scope, nullptr);
 607 
 608             lastIndex = result.end;
 609             startPosition = lastIndex;
 610 
 611             // special case of empty match
 612             if (result.empty()) {
 613                 startPosition++;
 614                 if (startPosition &gt; sourceLen)
 615                     break;
 616             }
 617         }
 618     } else {
 619         do {
 620             int* ovector;
 621             MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, source, startPosition, &amp;ovector);
 622             RETURN_IF_EXCEPTION(scope, nullptr);
 623             if (!result)
 624                 break;
 625 
 626             if (callType != CallType::None) {
 627                 if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
<span class="line-modified"> 628                     OUT_OF_MEMORY(globalObject, scope);</span>
 629 
 630                 MarkedArgumentBuffer args;
<span class="line-modified"> 631                 JSObject* groups = hasNamedCaptures ? constructEmptyObject(vm, globalObject-&gt;nullPrototypeObjectStructure()) : nullptr;</span>





 632 
 633                 for (unsigned i = 0; i &lt; regExp-&gt;numSubpatterns() + 1; ++i) {
 634                     int matchStart = ovector[i * 2];
 635                     int matchLen = ovector[i * 2 + 1] - matchStart;
 636 
 637                     JSValue patternValue;
 638 
 639                     if (matchStart &lt; 0)
 640                         patternValue = jsUndefined();
 641                     else {
 642                         patternValue = jsSubstring(vm, source, matchStart, matchLen);
 643                         RETURN_IF_EXCEPTION(scope, nullptr);
 644                     }
 645 
 646                     args.append(patternValue);
 647 
 648                     if (i &amp;&amp; hasNamedCaptures) {
 649                         String groupName = regExp-&gt;getCaptureGroupName(i);
 650                         if (!groupName.isEmpty())
 651                             groups-&gt;putDirect(vm, Identifier::fromString(vm, groupName), patternValue);
 652                     }

 653                 }
 654 
 655                 args.append(jsNumber(result.start));
 656                 args.append(string);
 657                 if (hasNamedCaptures)
 658                     args.append(groups);
 659                 if (UNLIKELY(args.hasOverflowed())) {
<span class="line-modified"> 660                     throwOutOfMemoryError(globalObject, scope);</span>
 661                     return nullptr;
 662                 }
 663 
<span class="line-modified"> 664                 JSValue replacement = call(globalObject, replaceValue, callType, callData, jsUndefined(), args);</span>
 665                 RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 666                 String replacementString = replacement.toWTFString(globalObject);</span>
 667                 RETURN_IF_EXCEPTION(scope, nullptr);
 668                 replacements.append(replacementString);
 669                 RETURN_IF_EXCEPTION(scope, nullptr);
 670             } else {
 671                 int replLen = replacementString.length();
 672                 if (lastIndex &lt; result.start || replLen) {
 673                     if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
<span class="line-modified"> 674                         OUT_OF_MEMORY(globalObject, scope);</span>
 675 
 676                     if (replLen) {
 677                         StringBuilder replacement(StringBuilder::OverflowHandler::RecordOverflow);
 678                         substituteBackreferences(replacement, replacementString, source, ovector, regExp);
 679                         if (UNLIKELY(replacement.hasOverflowed()))
<span class="line-modified"> 680                             OUT_OF_MEMORY(globalObject, scope);</span>
 681                         replacements.append(replacement.toString());
 682                     } else
 683                         replacements.append(String());
 684                 }
 685             }
 686 
 687             lastIndex = result.end;
 688             startPosition = lastIndex;
 689 
 690             // special case of empty match
 691             if (result.empty()) {
 692                 startPosition++;
 693                 if (startPosition &gt; sourceLen)
 694                     break;
 695             }
 696         } while (global);
 697     }
 698 
 699     if (!lastIndex &amp;&amp; replacements.isEmpty())
 700         return string;
 701 
 702     if (static_cast&lt;unsigned&gt;(lastIndex) &lt; sourceLen) {
 703         if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, sourceLen - lastIndex)))
<span class="line-modified"> 704             OUT_OF_MEMORY(globalObject, scope);</span>
 705     }
<span class="line-modified"> 706     RELEASE_AND_RETURN(scope, jsSpliceSubstringsWithSeparators(globalObject, string, source, sourceRanges.data(), sourceRanges.size(), replacements.data(), replacements.size()));</span>
 707 }
 708 
<span class="line-modified"> 709 IGNORE_WARNINGS_BEGIN(&quot;frame-address&quot;)</span>
<span class="line-modified"> 710 </span>
<span class="line-added"> 711 JSCell* JIT_OPERATION operationStringProtoFuncReplaceRegExpEmptyStr(JSGlobalObject* globalObject, JSString* thisValue, RegExpObject* searchValue)</span>
 712 {
<span class="line-modified"> 713     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 714     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 715     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 716     auto scope = DECLARE_THROW_SCOPE(vm);
 717 
 718     RegExp* regExp = searchValue-&gt;regExp();
 719     if (regExp-&gt;global()) {
 720         // ES5.1 15.5.4.10 step 8.a.
<span class="line-modified"> 721         searchValue-&gt;setLastIndex(globalObject, 0);</span>
 722         RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 723         String source = thisValue-&gt;value(globalObject);</span>
 724         RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 725         RELEASE_AND_RETURN(scope, removeUsingRegExpSearch(vm, globalObject, thisValue, source, regExp));</span>
 726     }
 727 
 728     CallData callData;
 729     String replacementString = emptyString();
 730     RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
<span class="line-modified"> 731         vm, globalObject, callFrame, thisValue, searchValue, callData, CallType::None, replacementString, JSValue()));</span>
 732 }
 733 
<span class="line-modified"> 734 JSCell* JIT_OPERATION operationStringProtoFuncReplaceRegExpString(JSGlobalObject* globalObject, JSString* thisValue, RegExpObject* searchValue, JSString* replaceString)</span>

 735 {
<span class="line-modified"> 736     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 737     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 738     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 739     auto scope = DECLARE_THROW_SCOPE(vm);
 740 
 741     CallData callData;
<span class="line-modified"> 742     String replacementString = replaceString-&gt;value(globalObject);</span>
 743     RETURN_IF_EXCEPTION(scope, nullptr);
 744     RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
<span class="line-modified"> 745         vm, globalObject, callFrame, thisValue, searchValue, callData, CallType::None, replacementString, replaceString));</span>
 746 }
 747 
<span class="line-modified"> 748 static ALWAYS_INLINE JSString* replaceUsingRegExpSearch(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame, JSString* string, JSValue searchValue, JSValue replaceValue)</span>
 749 {
 750     auto scope = DECLARE_THROW_SCOPE(vm);
 751 
 752     String replacementString;
 753     CallData callData;
 754     CallType callType = getCallData(vm, replaceValue, callData);
 755     if (callType == CallType::None) {
<span class="line-modified"> 756         replacementString = replaceValue.toWTFString(globalObject);</span>
 757         RETURN_IF_EXCEPTION(scope, nullptr);
 758     }
 759 
 760     RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
<span class="line-modified"> 761         vm, globalObject, callFrame, string, searchValue, callData, callType, replacementString, replaceValue));</span>
 762 }
 763 
<span class="line-modified"> 764 enum class ReplaceMode : bool { Single, Global };</span>
<span class="line-added"> 765 </span>
<span class="line-added"> 766 static ALWAYS_INLINE JSString* replaceUsingStringSearch(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame, JSString* jsString, JSValue searchValue, JSValue replaceValue, ReplaceMode mode)</span>
 767 {
 768     auto scope = DECLARE_THROW_SCOPE(vm);
 769 
<span class="line-modified"> 770     String string = jsString-&gt;value(globalObject);</span>
 771     RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 772     String searchString = searchValue.toWTFString(globalObject);</span>
 773     RETURN_IF_EXCEPTION(scope, nullptr);
 774 





 775     CallData callData;
 776     CallType callType = getCallData(vm, replaceValue, callData);
<span class="line-modified"> 777     Optional&lt;CachedCall&gt; cachedCall;</span>
<span class="line-modified"> 778     String replaceString;</span>
<span class="line-modified"> 779     if (callType == CallType::None) {</span>
<span class="line-added"> 780         replaceString = replaceValue.toWTFString(globalObject);</span>
 781         RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 782     } else if (callType == CallType::JS) {</span>
<span class="line-modified"> 783         cachedCall.emplace(globalObject, callFrame, jsCast&lt;JSFunction*&gt;(replaceValue), 3);</span>



 784         RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-added"> 785         cachedCall-&gt;setThis(jsUndefined());</span>
 786     }
 787 
<span class="line-modified"> 788     size_t matchStart = string.find(searchString);</span>
<span class="line-modified"> 789     if (matchStart == notFound)</span>
<span class="line-added"> 790         return jsString;</span>
 791 
<span class="line-modified"> 792     size_t endOfLastMatch = 0;</span>
<span class="line-modified"> 793     size_t searchStringLength = searchString.length();</span>
<span class="line-added"> 794     Vector&lt;StringRange, 16&gt; sourceRanges;</span>
<span class="line-added"> 795     Vector&lt;String, 16&gt; replacements;</span>
<span class="line-added"> 796     do {</span>
<span class="line-added"> 797         if (callType != CallType::None) {</span>
<span class="line-added"> 798             JSValue replacement;</span>
<span class="line-added"> 799             if (cachedCall) {</span>
<span class="line-added"> 800                 auto* substring = jsSubstring(vm, string, matchStart, searchStringLength);</span>
<span class="line-added"> 801                 RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added"> 802                 cachedCall-&gt;clearArguments();</span>
<span class="line-added"> 803                 cachedCall-&gt;appendArgument(substring);</span>
<span class="line-added"> 804                 cachedCall-&gt;appendArgument(jsNumber(matchStart));</span>
<span class="line-added"> 805                 cachedCall-&gt;appendArgument(jsString);</span>
<span class="line-added"> 806                 ASSERT(!cachedCall-&gt;hasOverflowedArguments());</span>
<span class="line-added"> 807                 replacement = cachedCall-&gt;call();</span>
<span class="line-added"> 808             } else {</span>
<span class="line-added"> 809                 MarkedArgumentBuffer args;</span>
<span class="line-added"> 810                 auto* substring = jsSubstring(vm, string, matchStart, searchString.impl()-&gt;length());</span>
<span class="line-added"> 811                 RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added"> 812                 args.append(substring);</span>
<span class="line-added"> 813                 args.append(jsNumber(matchStart));</span>
<span class="line-added"> 814                 args.append(jsString);</span>
<span class="line-added"> 815                 ASSERT(!args.hasOverflowed());</span>
<span class="line-added"> 816                 replacement = call(globalObject, replaceValue, callType, callData, jsUndefined(), args);</span>
<span class="line-added"> 817             }</span>
<span class="line-added"> 818             RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added"> 819             replaceString = replacement.toWTFString(globalObject);</span>
<span class="line-added"> 820             RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added"> 821         }</span>
 822 
<span class="line-modified"> 823         if (UNLIKELY(!sourceRanges.tryConstructAndAppend(endOfLastMatch, matchStart - endOfLastMatch)))</span>
<span class="line-modified"> 824             OUT_OF_MEMORY(globalObject, scope);</span>










 825 
<span class="line-modified"> 826         size_t matchEnd = matchStart + searchStringLength;</span>
<span class="line-modified"> 827         if (callType != CallType::None)</span>
<span class="line-modified"> 828             replacements.append(replaceString);</span>
<span class="line-added"> 829         else {</span>
<span class="line-added"> 830             StringBuilder replacement(StringBuilder::OverflowHandler::RecordOverflow);</span>
<span class="line-added"> 831             int ovector[2] = { static_cast&lt;int&gt;(matchStart),  static_cast&lt;int&gt;(matchEnd) };</span>
<span class="line-added"> 832             substituteBackreferences(replacement, replaceString, string, ovector, nullptr);</span>
<span class="line-added"> 833             if (UNLIKELY(replacement.hasOverflowed()))</span>
<span class="line-added"> 834                 OUT_OF_MEMORY(globalObject, scope);</span>
<span class="line-added"> 835             replacements.append(replacement.toString());</span>
<span class="line-added"> 836         }</span>
<span class="line-added"> 837 </span>
<span class="line-added"> 838         endOfLastMatch = matchEnd;</span>
<span class="line-added"> 839         if (mode == ReplaceMode::Single)</span>
<span class="line-added"> 840             break;</span>
<span class="line-added"> 841         matchStart = string.find(searchString, !searchStringLength ? endOfLastMatch + 1 : endOfLastMatch);</span>
<span class="line-added"> 842     } while (matchStart != notFound);</span>
<span class="line-added"> 843 </span>
<span class="line-added"> 844     if (UNLIKELY(!sourceRanges.tryConstructAndAppend(endOfLastMatch, string.length() - endOfLastMatch)))</span>
<span class="line-added"> 845         OUT_OF_MEMORY(globalObject, scope);</span>
<span class="line-added"> 846     RELEASE_AND_RETURN(scope, jsSpliceSubstringsWithSeparators(globalObject, jsString, string, sourceRanges.data(), sourceRanges.size(), replacements.data(), replacements.size()));</span>
 847 }
 848 
 849 static inline bool checkObjectCoercible(JSValue thisValue)
 850 {
 851     if (thisValue.isString())
 852         return true;
 853 
 854     if (thisValue.isUndefinedOrNull())
 855         return false;
 856 
 857     if (thisValue.isObject() &amp;&amp; asObject(thisValue)-&gt;isEnvironment())
 858         return false;
 859 
 860     return true;
 861 }
 862 
<span class="line-modified"> 863 EncodedJSValue JSC_HOST_CALL stringProtoFuncRepeatCharacter(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
 864 {
<span class="line-modified"> 865     VM&amp; vm = globalObject-&gt;vm();</span>
 866     auto scope = DECLARE_THROW_SCOPE(vm);
 867 
 868     // For a string which length is single, instead of creating ropes,
 869     // allocating a sequential buffer and fill with the repeated string for efficiency.
<span class="line-modified"> 870     ASSERT(callFrame-&gt;argumentCount() == 2);</span>
 871 
<span class="line-modified"> 872     ASSERT(callFrame-&gt;uncheckedArgument(0).isString());</span>
<span class="line-modified"> 873     JSString* string = asString(callFrame-&gt;uncheckedArgument(0));</span>
 874     ASSERT(string-&gt;length() == 1);
 875 
<span class="line-modified"> 876     JSValue repeatCountValue = callFrame-&gt;uncheckedArgument(1);</span>
 877     RELEASE_ASSERT(repeatCountValue.isNumber());
 878     int32_t repeatCount;
 879     double value = repeatCountValue.asNumber();
 880     if (value &gt; JSString::MaxLength)
<span class="line-modified"> 881         return JSValue::encode(throwOutOfMemoryError(globalObject, scope));</span>
 882     repeatCount = static_cast&lt;int32_t&gt;(value);
 883     ASSERT(repeatCount &gt;= 0);
 884     ASSERT(!repeatCountValue.isDouble() || repeatCountValue.asDouble() == repeatCount);
 885 
<span class="line-modified"> 886     auto viewWithString = string-&gt;viewWithUnderlyingString(globalObject);</span>
 887     StringView view = viewWithString.view;
 888     ASSERT(view.length() == 1);
 889     scope.assertNoException();
 890     UChar character = view[0];
 891     scope.release();
 892     if (isLatin1(character))
<span class="line-modified"> 893         return JSValue::encode(repeatCharacter(globalObject, static_cast&lt;LChar&gt;(character), repeatCount));</span>
<span class="line-modified"> 894     return JSValue::encode(repeatCharacter(globalObject, character, repeatCount));</span>
 895 }
 896 
 897 ALWAYS_INLINE JSString* replace(
<span class="line-modified"> 898     VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame, JSString* string, JSValue searchValue, JSValue replaceValue)</span>
 899 {
 900     if (searchValue.inherits&lt;RegExpObject&gt;(vm))
<span class="line-modified"> 901         return replaceUsingRegExpSearch(vm, globalObject, callFrame, string, searchValue, replaceValue);</span>
<span class="line-modified"> 902     return replaceUsingStringSearch(vm, globalObject, callFrame, string, searchValue, replaceValue, ReplaceMode::Single);</span>
 903 }
 904 
 905 ALWAYS_INLINE JSString* replace(
<span class="line-modified"> 906     VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame, JSValue thisValue, JSValue searchValue, JSValue replaceValue)</span>
 907 {
 908     auto scope = DECLARE_THROW_SCOPE(vm);
 909 
 910     if (!checkObjectCoercible(thisValue)) {
<span class="line-modified"> 911         throwVMTypeError(globalObject, scope);</span>
 912         return nullptr;
 913     }
<span class="line-modified"> 914     JSString* string = thisValue.toString(globalObject);</span>
 915     RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 916     RELEASE_AND_RETURN(scope, replace(vm, globalObject, callFrame, string, searchValue, replaceValue));</span>
 917 }
 918 
<span class="line-modified"> 919 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingRegExp(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
 920 {
<span class="line-modified"> 921     VM&amp; vm = globalObject-&gt;vm();</span>
 922     auto scope = DECLARE_THROW_SCOPE(vm);
 923 
<span class="line-modified"> 924     JSString* string = callFrame-&gt;thisValue().toString(globalObject);</span>
 925     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 926 
<span class="line-modified"> 927     JSValue searchValue = callFrame-&gt;argument(0);</span>
 928     if (!searchValue.inherits&lt;RegExpObject&gt;(vm))
 929         return JSValue::encode(jsUndefined());
 930 
<span class="line-modified"> 931     RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingRegExpSearch(vm, globalObject, callFrame, string, searchValue, callFrame-&gt;argument(1))));</span>
<span class="line-added"> 932 }</span>
<span class="line-added"> 933 </span>
<span class="line-added"> 934 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingStringSearch(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
<span class="line-added"> 935 {</span>
<span class="line-added"> 936     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added"> 937     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added"> 938 </span>
<span class="line-added"> 939     JSString* string = callFrame-&gt;thisValue().toString(globalObject);</span>
<span class="line-added"> 940     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added"> 941 </span>
<span class="line-added"> 942     RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingStringSearch(vm, globalObject, callFrame, string, callFrame-&gt;argument(0), callFrame-&gt;argument(1), ReplaceMode::Single)));</span>
 943 }
 944 
<span class="line-modified"> 945 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceAllUsingStringSearch(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
 946 {
<span class="line-modified"> 947     VM&amp; vm = globalObject-&gt;vm();</span>
 948     auto scope = DECLARE_THROW_SCOPE(vm);
 949 
<span class="line-modified"> 950     JSString* string = callFrame-&gt;thisValue().toString(globalObject);</span>
 951     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 952 
<span class="line-modified"> 953     RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingStringSearch(vm, globalObject, callFrame, string, callFrame-&gt;argument(0), callFrame-&gt;argument(1), ReplaceMode::Global)));</span>
 954 }
 955 
<span class="line-modified"> 956 JSCell* JIT_OPERATION operationStringProtoFuncReplaceGeneric(JSGlobalObject* globalObject, EncodedJSValue thisValue, EncodedJSValue searchValue, EncodedJSValue replaceValue)</span>


 957 {
<span class="line-modified"> 958     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 959     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 960     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 961 
 962     return replace(
<span class="line-modified"> 963         vm, globalObject, callFrame, JSValue::decode(thisValue), JSValue::decode(searchValue),</span>
 964         JSValue::decode(replaceValue));
 965 }
 966 
<span class="line-modified"> 967 IGNORE_WARNINGS_END</span>
<span class="line-added"> 968 </span>
<span class="line-added"> 969 EncodedJSValue JSC_HOST_CALL stringProtoFuncToString(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
 970 {
<span class="line-modified"> 971     VM&amp; vm = globalObject-&gt;vm();</span>
 972     auto scope = DECLARE_THROW_SCOPE(vm);
 973 
<span class="line-modified"> 974     JSValue thisValue = callFrame-&gt;thisValue();</span>
 975     // Also used for valueOf.
 976 
 977     if (thisValue.isString())
 978         return JSValue::encode(thisValue);
 979 
 980     auto* stringObject = jsDynamicCast&lt;StringObject*&gt;(vm, thisValue);
 981     if (stringObject)
 982         return JSValue::encode(stringObject-&gt;internalValue());
 983 
<span class="line-modified"> 984     return throwVMTypeError(globalObject, scope);</span>
 985 }
 986 
<span class="line-modified"> 987 EncodedJSValue JSC_HOST_CALL stringProtoFuncCharAt(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
 988 {
<span class="line-modified"> 989     VM&amp; vm = globalObject-&gt;vm();</span>
 990     auto scope = DECLARE_THROW_SCOPE(vm);
 991 
<span class="line-modified"> 992     JSValue thisValue = callFrame-&gt;thisValue();</span>
 993     if (!checkObjectCoercible(thisValue))
<span class="line-modified"> 994         return throwVMTypeError(globalObject, scope);</span>
<span class="line-modified"> 995     auto viewWithString = thisValue.toString(globalObject)-&gt;viewWithUnderlyingString(globalObject);</span>
 996     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 997     StringView view = viewWithString.view;
 998     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified"> 999     JSValue a0 = callFrame-&gt;argument(0);</span>
1000     if (a0.isUInt32()) {
1001         uint32_t i = a0.asUInt32();
1002         if (i &lt; view.length())
1003             return JSValue::encode(jsSingleCharacterString(vm, view[i]));
1004         return JSValue::encode(jsEmptyString(vm));
1005     }
<span class="line-modified">1006     double dpos = a0.toInteger(globalObject);</span>
1007     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1008     if (dpos &gt;= 0 &amp;&amp; dpos &lt; view.length())
1009         return JSValue::encode(jsSingleCharacterString(vm, view[static_cast&lt;unsigned&gt;(dpos)]));
1010     return JSValue::encode(jsEmptyString(vm));
1011 }
1012 
<span class="line-modified">1013 EncodedJSValue JSC_HOST_CALL stringProtoFuncCharCodeAt(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1014 {
<span class="line-modified">1015     VM&amp; vm = globalObject-&gt;vm();</span>
1016     auto scope = DECLARE_THROW_SCOPE(vm);
1017 
<span class="line-modified">1018     JSValue thisValue = callFrame-&gt;thisValue();</span>
1019     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1020         return throwVMTypeError(globalObject, scope);</span>
<span class="line-modified">1021     auto viewWithString = thisValue.toString(globalObject)-&gt;viewWithUnderlyingString(globalObject);</span>
1022     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1023     StringView view = viewWithString.view;
<span class="line-modified">1024     JSValue a0 = callFrame-&gt;argument(0);</span>
1025     if (a0.isUInt32()) {
1026         uint32_t i = a0.asUInt32();
1027         if (i &lt; view.length())
1028             return JSValue::encode(jsNumber(view[i]));
1029         return JSValue::encode(jsNaN());
1030     }
<span class="line-modified">1031     double dpos = a0.toInteger(globalObject);</span>
1032     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1033     if (dpos &gt;= 0 &amp;&amp; dpos &lt; view.length())
1034         return JSValue::encode(jsNumber(view[static_cast&lt;int&gt;(dpos)]));
1035     return JSValue::encode(jsNaN());
1036 }
1037 
1038 static inline UChar32 codePointAt(const String&amp; string, unsigned position, unsigned length)
1039 {
1040     RELEASE_ASSERT(position &lt; length);
1041     if (string.is8Bit())
1042         return string.characters8()[position];
1043     UChar32 character;
1044     U16_NEXT(string.characters16(), position, length, character);
1045     return character;
1046 }
1047 
<span class="line-modified">1048 EncodedJSValue JSC_HOST_CALL stringProtoFuncCodePointAt(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1049 {
<span class="line-modified">1050     VM&amp; vm = globalObject-&gt;vm();</span>
1051     auto scope = DECLARE_THROW_SCOPE(vm);
1052 
<span class="line-modified">1053     JSValue thisValue = callFrame-&gt;thisValue();</span>
1054     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1055         return throwVMTypeError(globalObject, scope);</span>
1056 
<span class="line-modified">1057     String string = thisValue.toWTFString(globalObject);</span>
1058     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1059     unsigned length = string.length();
1060 
<span class="line-modified">1061     JSValue argument0 = callFrame-&gt;argument(0);</span>
1062     if (argument0.isUInt32()) {
1063         unsigned position = argument0.asUInt32();
1064         if (position &lt; length)
1065             return JSValue::encode(jsNumber(codePointAt(string, position, length)));
1066         return JSValue::encode(jsUndefined());
1067     }
1068 
1069     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1070 
<span class="line-modified">1071     double doublePosition = argument0.toInteger(globalObject);</span>
1072     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1073     if (doublePosition &gt;= 0 &amp;&amp; doublePosition &lt; length)
1074         return JSValue::encode(jsNumber(codePointAt(string, static_cast&lt;unsigned&gt;(doublePosition), length)));
1075     return JSValue::encode(jsUndefined());
1076 }
1077 
<span class="line-modified">1078 EncodedJSValue JSC_HOST_CALL stringProtoFuncIndexOf(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1079 {
<span class="line-modified">1080     VM&amp; vm = globalObject-&gt;vm();</span>
1081     auto scope = DECLARE_THROW_SCOPE(vm);
1082 
<span class="line-modified">1083     JSValue thisValue = callFrame-&gt;thisValue();</span>
1084     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1085         return throwVMTypeError(globalObject, scope);</span>
1086 
<span class="line-modified">1087     JSValue a0 = callFrame-&gt;argument(0);</span>
<span class="line-modified">1088     JSValue a1 = callFrame-&gt;argument(1);</span>
1089 
<span class="line-modified">1090     JSString* thisJSString = thisValue.toString(globalObject);</span>
1091     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1092     JSString* otherJSString = a0.toString(globalObject);</span>
1093     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1094 
1095     unsigned pos = 0;
1096     if (!a1.isUndefined()) {
1097         int len = thisJSString-&gt;length();
1098         RELEASE_ASSERT(len &gt;= 0);
1099         if (a1.isUInt32())
1100             pos = std::min&lt;uint32_t&gt;(a1.asUInt32(), len);
1101         else {
<span class="line-modified">1102             double dpos = a1.toInteger(globalObject);</span>
1103             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1104             if (dpos &lt; 0)
1105                 dpos = 0;
1106             else if (dpos &gt; len)
1107                 dpos = len;
1108             pos = static_cast&lt;unsigned&gt;(dpos);
1109         }
1110     }
1111 
1112     if (thisJSString-&gt;length() &lt; otherJSString-&gt;length() + pos)
1113         return JSValue::encode(jsNumber(-1));
1114 
<span class="line-modified">1115     auto thisViewWithString = thisJSString-&gt;viewWithUnderlyingString(globalObject);</span>
1116     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1117     auto otherViewWithString = otherJSString-&gt;viewWithUnderlyingString(globalObject);</span>
1118     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1119     size_t result = thisViewWithString.view.find(otherViewWithString.view, pos);
1120     if (result == notFound)
1121         return JSValue::encode(jsNumber(-1));
1122     return JSValue::encode(jsNumber(result));
1123 }
1124 
<span class="line-modified">1125 EncodedJSValue JSC_HOST_CALL stringProtoFuncLastIndexOf(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1126 {
<span class="line-modified">1127     VM&amp; vm = globalObject-&gt;vm();</span>
1128     auto scope = DECLARE_THROW_SCOPE(vm);
1129 
<span class="line-modified">1130     JSValue thisValue = callFrame-&gt;thisValue();</span>
1131     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1132         return throwVMTypeError(globalObject, scope);</span>
1133 
<span class="line-modified">1134     JSValue a0 = callFrame-&gt;argument(0);</span>
<span class="line-modified">1135     JSValue a1 = callFrame-&gt;argument(1);</span>
1136 
<span class="line-modified">1137     JSString* thisJSString = thisValue.toString(globalObject);</span>
1138     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1139     unsigned len = thisJSString-&gt;length();
<span class="line-modified">1140     JSString* otherJSString = a0.toString(globalObject);</span>
1141     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1142 
<span class="line-modified">1143     double dpos = a1.toIntegerPreserveNaN(globalObject);</span>
1144     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1145     unsigned startPosition;
1146     if (dpos &lt; 0)
1147         startPosition = 0;
1148     else if (!(dpos &lt;= len)) // true for NaN
1149         startPosition = len;
1150     else
1151         startPosition = static_cast&lt;unsigned&gt;(dpos);
1152 
1153     if (len &lt; otherJSString-&gt;length())
1154         return JSValue::encode(jsNumber(-1));
1155 
<span class="line-modified">1156     String thisString = thisJSString-&gt;value(globalObject);</span>
1157     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1158     String otherString = otherJSString-&gt;value(globalObject);</span>
1159     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1160     size_t result;
1161     if (!startPosition)
1162         result = thisString.startsWith(otherString) ? 0 : notFound;
1163     else
1164         result = thisString.reverseFind(otherString, startPosition);
1165     if (result == notFound)
1166         return JSValue::encode(jsNumber(-1));
1167     return JSValue::encode(jsNumber(result));
1168 }
1169 
<span class="line-modified">1170 EncodedJSValue JSC_HOST_CALL stringProtoFuncSlice(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1171 {
<span class="line-modified">1172     VM&amp; vm = globalObject-&gt;vm();</span>
1173     auto scope = DECLARE_THROW_SCOPE(vm);
1174 
<span class="line-modified">1175     JSValue thisValue = callFrame-&gt;thisValue();</span>
1176     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1177         return throwVMTypeError(globalObject, scope);</span>
<span class="line-modified">1178     JSString* string = thisValue.toString(globalObject);</span>
1179     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1180 
<span class="line-modified">1181     JSValue a0 = callFrame-&gt;argument(0);</span>
<span class="line-modified">1182     JSValue a1 = callFrame-&gt;argument(1);</span>
1183 
1184     int length = string-&gt;length();
1185     RELEASE_ASSERT(length &gt;= 0);
1186 
1187     // The arg processing is very much like ArrayProtoFunc::Slice
<span class="line-modified">1188     double start = a0.toInteger(globalObject);</span>
1189     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1190     double end = a1.isUndefined() ? length : a1.toInteger(globalObject);</span>
1191     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1192     RELEASE_AND_RETURN(scope, JSValue::encode(stringSlice(globalObject, vm, string, length, start, end)));</span>
1193 }
1194 
1195 // Return true in case of early return (resultLength got to limitLength).
1196 template&lt;typename CharacterType&gt;
<span class="line-modified">1197 static ALWAYS_INLINE bool splitStringByOneCharacterImpl(JSGlobalObject* globalObject, JSArray* result, JSValue originalValue, const String&amp; input, StringImpl* string, UChar separatorCharacter, size_t&amp; position, unsigned&amp; resultLength, unsigned limitLength)</span>
1198 {
<span class="line-modified">1199     VM&amp; vm = globalObject-&gt;vm();</span>
1200     auto scope = DECLARE_THROW_SCOPE(vm);
1201 
1202     // 12. Let q = p.
1203     size_t matchPosition;
1204     const CharacterType* characters = string-&gt;characters&lt;CharacterType&gt;();
1205     // 13. Repeat, while q != s
1206     //   a. Call SplitMatch(S, q, R) and let z be its MatchResult result.
1207     //   b. If z is failure, then let q = q+1.
1208     //   c. Else, z is not failure
1209     while ((matchPosition = WTF::find(characters, string-&gt;length(), separatorCharacter, position)) != notFound) {
1210         // 1. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
1211         //    through q (exclusive).
1212         // 2. Call the [[DefineOwnProperty]] internal method of A with arguments ToString(lengthA),
1213         //    Property Descriptor {[[Value]]: T, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false.
<span class="line-modified">1214         auto* substring = jsSubstring(globalObject, originalValue, input, position, matchPosition - position);</span>
1215         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">1216         result-&gt;putDirectIndex(globalObject, resultLength, substring);</span>
1217         RETURN_IF_EXCEPTION(scope, false);
1218         // 3. Increment lengthA by 1.
1219         // 4. If lengthA == lim, return A.
1220         if (++resultLength == limitLength)
1221             return true;
1222 
1223         // 5. Let p = e.
1224         // 8. Let q = p.
1225         position = matchPosition + 1;
1226     }
1227     return false;
1228 }
1229 
1230 // ES 21.1.3.17 String.prototype.split(separator, limit)
<span class="line-modified">1231 EncodedJSValue JSC_HOST_CALL stringProtoFuncSplitFast(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1232 {
<span class="line-modified">1233     VM&amp; vm = globalObject-&gt;vm();</span>
1234     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">1235     JSValue thisValue = callFrame-&gt;thisValue();</span>
1236     ASSERT(checkObjectCoercible(thisValue));
1237 
1238     // 3. Let S be the result of calling ToString, giving it the this value as its argument.
1239     // 7. Let s be the number of characters in S.
<span class="line-modified">1240     String input = thisValue.toWTFString(globalObject);</span>
1241     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1242     ASSERT(!input.isNull());
1243 
1244     // 4. Let A be a new array created as if by the expression new Array()
1245     //    where Array is the standard built-in constructor with that name.
<span class="line-modified">1246     JSArray* result = constructEmptyArray(globalObject, 0);</span>
1247     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1248 
1249     // 5. Let lengthA be 0.
1250     unsigned resultLength = 0;
1251 
1252     // 6. If limit is undefined, let lim = 2^32-1; else let lim = ToUint32(limit).
<span class="line-modified">1253     JSValue limitValue = callFrame-&gt;uncheckedArgument(1);</span>
<span class="line-modified">1254     unsigned limit = limitValue.isUndefined() ? 0xFFFFFFFFu : limitValue.toUInt32(globalObject);</span>
1255     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1256 
1257     // 8. Let p = 0.
1258     size_t position = 0;
1259 
1260     // 9. If separator is a RegExp object (its [[Class]] is &quot;RegExp&quot;), let R = separator;
1261     //    otherwise let R = ToString(separator).
<span class="line-modified">1262     JSValue separatorValue = callFrame-&gt;uncheckedArgument(0);</span>
<span class="line-modified">1263     String separator = separatorValue.toWTFString(globalObject);</span>
1264     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1265 
1266     // 10. If lim == 0, return A.
1267     if (!limit)
1268         return JSValue::encode(result);
1269 
1270     // 11. If separator is undefined, then
1271     if (separatorValue.isUndefined()) {
1272         // a. Call the [[DefineOwnProperty]] internal method of A with arguments &quot;0&quot;,
1273         scope.release();
<span class="line-modified">1274         result-&gt;putDirectIndex(globalObject, 0, jsStringWithReuse(globalObject, thisValue, input));</span>
1275         // b. Return A.
1276         return JSValue::encode(result);
1277     }
1278 
1279     // 12. If s == 0, then
1280     if (input.isEmpty()) {
1281         // a. Let z be SplitMatch(S, 0, R) where S is input, R is separator.
1282         // b. If z is not false, return A.
1283         // c. Call CreateDataProperty(A, &quot;0&quot;, S).
1284         // d. Return A.
1285         if (!separator.isEmpty()) {
1286             scope.release();
<span class="line-modified">1287             result-&gt;putDirectIndex(globalObject, 0, jsStringWithReuse(globalObject, thisValue, input));</span>
1288         }
1289         return JSValue::encode(result);
1290     }
1291 
1292     // Optimized case for splitting on the empty string.
1293     if (separator.isEmpty()) {
1294         limit = std::min(limit, input.length());
1295         // Zero limt/input length handled in steps 9/11 respectively, above.
1296         ASSERT(limit);
1297 
1298         do {
<span class="line-modified">1299             result-&gt;putDirectIndex(globalObject, position, jsSingleCharacterString(vm, input[position]));</span>
1300             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1301         } while (++position &lt; limit);
1302 
1303         return JSValue::encode(result);
1304     }
1305 
1306     // 3 cases:
1307     // -separator length == 1, 8 bits
1308     // -separator length == 1, 16 bits
1309     // -separator length &gt; 1
1310     StringImpl* stringImpl = input.impl();
1311     StringImpl* separatorImpl = separator.impl();
1312     size_t separatorLength = separatorImpl-&gt;length();
1313 
1314     if (separatorLength == 1) {
1315         UChar separatorCharacter;
1316         if (separatorImpl-&gt;is8Bit())
1317             separatorCharacter = separatorImpl-&gt;characters8()[0];
1318         else
1319             separatorCharacter = separatorImpl-&gt;characters16()[0];
1320 
1321         if (stringImpl-&gt;is8Bit()) {
<span class="line-modified">1322             if (splitStringByOneCharacterImpl&lt;LChar&gt;(globalObject, result, thisValue, input, stringImpl, separatorCharacter, position, resultLength, limit))</span>
1323                 RELEASE_AND_RETURN(scope, JSValue::encode(result));
1324         } else {
<span class="line-modified">1325             if (splitStringByOneCharacterImpl&lt;UChar&gt;(globalObject, result, thisValue, input, stringImpl, separatorCharacter, position, resultLength, limit))</span>
1326                 RELEASE_AND_RETURN(scope, JSValue::encode(result));
1327         }
1328         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1329     } else {
1330         // 13. Let q = p.
1331         size_t matchPosition;
1332         // 14. Repeat, while q != s
1333         //   a. let e be SplitMatch(S, q, R).
1334         //   b. If e is failure, then let q = q+1.
1335         //   c. Else, e is an integer index &lt;= s.
1336         while ((matchPosition = stringImpl-&gt;find(separatorImpl, position)) != notFound) {
1337             // 1. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
1338             //    through q (exclusive).
1339             // 2. Call CreateDataProperty(A, ToString(lengthA), T).
<span class="line-modified">1340             auto* substring = jsSubstring(globalObject, thisValue, input, position, matchPosition - position);</span>
1341             RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">1342             result-&gt;putDirectIndex(globalObject, resultLength, substring);</span>
1343             RETURN_IF_EXCEPTION(scope, { });
1344             // 3. Increment lengthA by 1.
1345             // 4. If lengthA == lim, return A.
1346             if (++resultLength == limit)
1347                 return JSValue::encode(result);
1348 
1349             // 5. Let p = e.
1350             // 6. Let q = p.
1351             position = matchPosition + separator.length();
1352         }
1353     }
1354 
1355     // 15. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
1356     //     through s (exclusive).
1357     // 16. Call CreateDataProperty(A, ToString(lengthA), T).
<span class="line-modified">1358     auto* substring = jsSubstring(globalObject, thisValue, input, position, input.length() - position);</span>
1359     RETURN_IF_EXCEPTION(scope, { });
1360     scope.release();
<span class="line-modified">1361     result-&gt;putDirectIndex(globalObject, resultLength++, substring);</span>
1362 
1363     // 17. Return A.
1364     return JSValue::encode(result);
1365 }
1366 
<span class="line-modified">1367 static EncodedJSValue stringProtoFuncSubstrImpl(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1368 {
<span class="line-modified">1369     VM&amp; vm = globalObject-&gt;vm();</span>
1370     auto scope = DECLARE_THROW_SCOPE(vm);
1371 
<span class="line-modified">1372     JSValue thisValue = callFrame-&gt;thisValue();</span>
1373     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1374         return throwVMTypeError(globalObject, scope);</span>
1375     unsigned len;
1376     JSString* jsString = 0;
1377     String uString;
1378     if (thisValue.isString()) {
1379         jsString = asString(thisValue);
1380         len = jsString-&gt;length();
1381     } else {
<span class="line-modified">1382         uString = thisValue.toWTFString(globalObject);</span>
1383         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1384         len = uString.length();
1385     }
1386 
<span class="line-modified">1387     JSValue a0 = callFrame-&gt;argument(0);</span>
<span class="line-modified">1388     JSValue a1 = callFrame-&gt;argument(1);</span>
1389 
<span class="line-modified">1390     double start = a0.toInteger(globalObject);</span>
1391     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1392     double length = a1.isUndefined() ? len : a1.toInteger(globalObject);</span>
1393     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1394     if (start &gt;= len || length &lt;= 0)
1395         return JSValue::encode(jsEmptyString(vm));
1396     if (start &lt; 0) {
1397         start += len;
1398         if (start &lt; 0)
1399             start = 0;
1400     }
1401     if (start + length &gt; len)
1402         length = len - start;
1403     unsigned substringStart = static_cast&lt;unsigned&gt;(start);
1404     unsigned substringLength = static_cast&lt;unsigned&gt;(length);
1405     scope.release();
1406     if (jsString)
<span class="line-modified">1407         return JSValue::encode(jsSubstring(globalObject, jsString, substringStart, substringLength));</span>
1408     return JSValue::encode(jsSubstring(vm, uString, substringStart, substringLength));
1409 }
1410 
<span class="line-modified">1411 EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstr(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
<span class="line-added">1412 {</span>
<span class="line-added">1413     return stringProtoFuncSubstrImpl(globalObject, callFrame);</span>
<span class="line-added">1414 }</span>
<span class="line-added">1415 </span>
<span class="line-added">1416 EncodedJSValue JSC_HOST_CALL builtinStringSubstrInternal(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1417 {
1418     // @substrInternal should not have any observable side effects (e.g. it should not call
1419     // GetMethod(..., @@toPrimitive) on the thisValue).
1420 
1421     // It is ok to use the default stringProtoFuncSubstr as the implementation of
1422     // @substrInternal because @substrInternal will only be called by builtins, which will
1423     // guarantee that we only pass it a string thisValue. As a result, stringProtoFuncSubstr
1424     // will not need to call toString() on the thisValue, and there will be no observable
1425     // side-effects.
<span class="line-modified">1426     ASSERT(callFrame-&gt;thisValue().isString());</span>
<span class="line-modified">1427     return stringProtoFuncSubstrImpl(globalObject, callFrame);</span>
1428 }
1429 
<span class="line-modified">1430 EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstring(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1431 {
<span class="line-modified">1432     VM&amp; vm = globalObject-&gt;vm();</span>
1433     auto scope = DECLARE_THROW_SCOPE(vm);
1434 
<span class="line-modified">1435     JSValue thisValue = callFrame-&gt;thisValue();</span>
1436     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1437         return throwVMTypeError(globalObject, scope);</span>
1438 
<span class="line-modified">1439     JSString* jsString = thisValue.toString(globalObject);</span>
1440     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1441 
<span class="line-modified">1442     JSValue a0 = callFrame-&gt;argument(0);</span>
<span class="line-modified">1443     JSValue a1 = callFrame-&gt;argument(1);</span>
1444     int len = jsString-&gt;length();
1445     RELEASE_ASSERT(len &gt;= 0);
1446 
<span class="line-modified">1447     double start = a0.toNumber(globalObject);</span>
1448     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1449     double end;
1450     if (!(start &gt;= 0)) // check for negative values or NaN
1451         start = 0;
1452     else if (start &gt; len)
1453         start = len;
1454     if (a1.isUndefined())
1455         end = len;
1456     else {
<span class="line-modified">1457         end = a1.toNumber(globalObject);</span>
1458         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1459         if (!(end &gt;= 0)) // check for negative values or NaN
1460             end = 0;
1461         else if (end &gt; len)
1462             end = len;
1463     }
1464     if (start &gt; end) {
1465         double temp = end;
1466         end = start;
1467         start = temp;
1468     }
1469     unsigned substringStart = static_cast&lt;unsigned&gt;(start);
1470     unsigned substringLength = static_cast&lt;unsigned&gt;(end) - substringStart;
<span class="line-modified">1471     RELEASE_AND_RETURN(scope, JSValue::encode(jsSubstring(globalObject, jsString, substringStart, substringLength)));</span>
1472 }
1473 
<span class="line-modified">1474 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLowerCase(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1475 {
<span class="line-modified">1476     VM&amp; vm = globalObject-&gt;vm();</span>
1477     auto scope = DECLARE_THROW_SCOPE(vm);
1478 
<span class="line-modified">1479     JSValue thisValue = callFrame-&gt;thisValue();</span>
1480     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1481         return throwVMTypeError(globalObject, scope);</span>
<span class="line-modified">1482     JSString* sVal = thisValue.toString(globalObject);</span>
1483     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1484     String s = sVal-&gt;value(globalObject);</span>
1485     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1486     String lowercasedString = s.convertToLowercaseWithoutLocale();
1487     if (lowercasedString.impl() == s.impl())
1488         return JSValue::encode(sVal);
1489     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, lowercasedString)));
1490 }
1491 
<span class="line-modified">1492 EncodedJSValue JSC_HOST_CALL stringProtoFuncToUpperCase(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1493 {
<span class="line-modified">1494     VM&amp; vm = globalObject-&gt;vm();</span>
1495     auto scope = DECLARE_THROW_SCOPE(vm);
1496 
<span class="line-modified">1497     JSValue thisValue = callFrame-&gt;thisValue();</span>
1498     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1499         return throwVMTypeError(globalObject, scope);</span>
<span class="line-modified">1500     JSString* sVal = thisValue.toString(globalObject);</span>
1501     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1502     String s = sVal-&gt;value(globalObject);</span>
1503     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1504     String uppercasedString = s.convertToUppercaseWithoutLocale();
1505     if (uppercasedString.impl() == s.impl())
1506         return JSValue::encode(sVal);
1507     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, uppercasedString)));
1508 }
1509 
<span class="line-modified">1510 EncodedJSValue JSC_HOST_CALL stringProtoFuncLocaleCompare(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1511 {
1512     // 13.1.1 String.prototype.localeCompare (that [, locales [, options ]]) (ECMA-402 2.0)
1513     // http://ecma-international.org/publications/standards/Ecma-402.htm
1514 
<span class="line-modified">1515     VM&amp; vm = globalObject-&gt;vm();</span>
1516     auto scope = DECLARE_THROW_SCOPE(vm);
1517 
1518     // 1. Let O be RequireObjectCoercible(this value).
<span class="line-modified">1519     JSValue thisValue = callFrame-&gt;thisValue();</span>
1520     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1521         return throwVMTypeError(globalObject, scope, &quot;String.prototype.localeCompare requires that |this| not be null or undefined&quot;_s);</span>
1522 
1523     // 2. Let S be ToString(O).
1524     // 3. ReturnIfAbrupt(S).
<span class="line-modified">1525     String string = thisValue.toWTFString(globalObject);</span>
1526     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1527 
1528     // 4. Let That be ToString(that).
1529     // 5. ReturnIfAbrupt(That).
<span class="line-modified">1530     JSValue thatValue = callFrame-&gt;argument(0);</span>
<span class="line-modified">1531     String that = thatValue.toWTFString(globalObject);</span>
1532     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1533 
1534 #if ENABLE(INTL)
<span class="line-modified">1535     JSValue locales = callFrame-&gt;argument(1);</span>
<span class="line-modified">1536     JSValue options = callFrame-&gt;argument(2);</span>

1537     IntlCollator* collator = nullptr;
<span class="line-modified">1538     if (locales.isUndefined() &amp;&amp; options.isUndefined())</span>
<span class="line-modified">1539         collator = globalObject-&gt;defaultCollator();</span>
<span class="line-modified">1540     else {</span>

1541         collator = IntlCollator::create(vm, globalObject-&gt;collatorStructure());
<span class="line-modified">1542         collator-&gt;initializeCollator(globalObject, locales, options);</span>
1543         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1544     }
<span class="line-modified">1545     RELEASE_AND_RETURN(scope, JSValue::encode(collator-&gt;compareStrings(globalObject, string, that)));</span>
1546 #else
1547     return JSValue::encode(jsNumber(Collator().collate(string, that)));
1548 #endif
1549 }
1550 
1551 #if ENABLE(INTL)
<span class="line-modified">1552 enum class CaseConversionMode {</span>
<span class="line-added">1553     Upper,</span>
<span class="line-added">1554     Lower,</span>
<span class="line-added">1555 };</span>
<span class="line-added">1556 template&lt;CaseConversionMode mode&gt;</span>
<span class="line-added">1557 static EncodedJSValue toLocaleCase(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1558 {
<span class="line-modified">1559     VM&amp; vm = globalObject-&gt;vm();</span>
1560     auto scope = DECLARE_THROW_SCOPE(vm);
1561 
<span class="line-added">1562     auto convertCase = [&amp;] (auto&amp;&amp;... args) {</span>
<span class="line-added">1563         if (mode == CaseConversionMode::Lower)</span>
<span class="line-added">1564             return u_strToLower(std::forward&lt;decltype(args)&gt;(args)...);</span>
<span class="line-added">1565         return u_strToUpper(std::forward&lt;decltype(args)&gt;(args)...);</span>
<span class="line-added">1566     };</span>
<span class="line-added">1567 </span>
1568     // 1. Let O be RequireObjectCoercible(this value).
<span class="line-modified">1569     JSValue thisValue = callFrame-&gt;thisValue();</span>
1570     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1571         return throwVMTypeError(globalObject, scope);</span>
1572 
1573     // 2. Let S be ToString(O).
<span class="line-modified">1574     JSString* sVal = thisValue.toString(globalObject);</span>
1575     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1576     String s = sVal-&gt;value(globalObject);</span>
1577 
1578     // 3. ReturnIfAbrupt(S).
1579     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1580 
1581     // Optimization for empty strings.
1582     if (s.isEmpty())
1583         return JSValue::encode(sVal);
1584 
1585     // 4. Let requestedLocales be CanonicalizeLocaleList(locales).
<span class="line-modified">1586     Vector&lt;String&gt; requestedLocales = canonicalizeLocaleList(globalObject, callFrame-&gt;argument(0));</span>
1587 
1588     // 5. ReturnIfAbrupt(requestedLocales).
1589     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1590 
1591     // 6. Let len be the number of elements in requestedLocales.
1592     size_t len = requestedLocales.size();
1593 
1594     // 7. If len &gt; 0, then
1595     // a. Let requestedLocale be the first element of requestedLocales.
1596     // 8. Else
1597     // a. Let requestedLocale be DefaultLocale().
<span class="line-modified">1598     String requestedLocale = len &gt; 0 ? requestedLocales.first() : defaultLocale(globalObject);</span>
1599 
1600     // 9. Let noExtensionsLocale be the String value that is requestedLocale with all Unicode locale extension sequences (6.2.1) removed.
1601     String noExtensionsLocale = removeUnicodeLocaleExtension(requestedLocale);
1602 
1603     // 10. Let availableLocales be a List with the language tags of the languages for which the Unicode character database contains language sensitive case mappings.
1604     // Note 1: As of Unicode 5.1, the availableLocales list contains the elements &quot;az&quot;, &quot;lt&quot;, and &quot;tr&quot;.
1605     const HashSet&lt;String&gt; availableLocales({ &quot;az&quot;_s, &quot;lt&quot;_s, &quot;tr&quot;_s });
1606 
1607     // 11. Let locale be BestAvailableLocale(availableLocales, noExtensionsLocale).
1608     String locale = bestAvailableLocale(availableLocales, noExtensionsLocale);
1609 
1610     // 12. If locale is undefined, let locale be &quot;und&quot;.
1611     if (locale.isNull())
1612         locale = &quot;und&quot;_s;
1613 
1614     CString utf8LocaleBuffer = locale.utf8();
1615     const StringView view(s);
1616     const int32_t viewLength = view.length();
1617 
1618     // Delegate the following steps to icu u_strToLower or u_strToUpper.
1619     // 13. Let cpList be a List containing in order the code points of S as defined in ES2015, 6.1.4, starting at the first element of S.
1620     // 14. For each code point c in cpList, if the Unicode Character Database provides a lower(/upper) case equivalent of c that is either language insensitive or for the language locale, then replace c in cpList with that/those equivalent code point(s).
1621     // 15. Let cuList be a new List.
1622     // 16. For each code point c in cpList, in order, append to cuList the elements of the UTF-16 Encoding (defined in ES2015, 6.1.4) of c.
1623     // 17. Let L be a String whose elements are, in order, the elements of cuList.
1624 
1625     // Most strings lower/upper case will be the same size as original, so try that first.
1626     UErrorCode error(U_ZERO_ERROR);
1627     Vector&lt;UChar&gt; buffer(viewLength);
1628     String lower;
1629     const int32_t resultLength = convertCase(buffer.data(), viewLength, view.upconvertedCharacters(), viewLength, utf8LocaleBuffer.data(), &amp;error);
1630     if (U_SUCCESS(error))
1631         lower = String(buffer.data(), resultLength);
1632     else if (error == U_BUFFER_OVERFLOW_ERROR) {
1633         // Converted case needs more space than original. Try again.
1634         UErrorCode error(U_ZERO_ERROR);
1635         Vector&lt;UChar&gt; buffer(resultLength);
1636         convertCase(buffer.data(), resultLength, view.upconvertedCharacters(), viewLength, utf8LocaleBuffer.data(), &amp;error);
1637         if (U_FAILURE(error))
<span class="line-modified">1638             return throwVMTypeError(globalObject, scope, u_errorName(error));</span>
1639         lower = String(buffer.data(), resultLength);
1640     } else
<span class="line-modified">1641         return throwVMTypeError(globalObject, scope, u_errorName(error));</span>
1642 
1643     // 18. Return L.
1644     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, lower)));
1645 }
1646 
<span class="line-modified">1647 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleLowerCase(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1648 {
1649     // 13.1.2 String.prototype.toLocaleLowerCase ([locales])
1650     // http://ecma-international.org/publications/standards/Ecma-402.htm
<span class="line-modified">1651     return toLocaleCase&lt;CaseConversionMode::Lower&gt;(globalObject, callFrame);</span>
1652 }
1653 
<span class="line-modified">1654 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleUpperCase(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1655 {
1656     // 13.1.3 String.prototype.toLocaleUpperCase ([locales])
1657     // http://ecma-international.org/publications/standards/Ecma-402.htm
1658     // This function interprets a string value as a sequence of code points, as described in ES2015, 6.1.4. This function behaves in exactly the same way as String.prototype.toLocaleLowerCase, except that characters are mapped to their uppercase equivalents as specified in the Unicode character database.
<span class="line-modified">1659     return toLocaleCase&lt;CaseConversionMode::Upper&gt;(globalObject,callFrame);</span>
1660 }
1661 #endif // ENABLE(INTL)
1662 
1663 enum {
1664     TrimStart = 1,
1665     TrimEnd = 2
1666 };
1667 
<span class="line-modified">1668 static inline JSValue trimString(JSGlobalObject* globalObject, JSValue thisValue, int trimKind)</span>
1669 {
<span class="line-modified">1670     VM&amp; vm = globalObject-&gt;vm();</span>
1671     auto scope = DECLARE_THROW_SCOPE(vm);
1672 
1673     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1674         return throwTypeError(globalObject, scope);</span>
<span class="line-modified">1675     String str = thisValue.toWTFString(globalObject);</span>
1676     RETURN_IF_EXCEPTION(scope, { });
1677 
1678     unsigned left = 0;
1679     if (trimKind &amp; TrimStart) {
1680         while (left &lt; str.length() &amp;&amp; isStrWhiteSpace(str[left]))
1681             left++;
1682     }
1683     unsigned right = str.length();
1684     if (trimKind &amp; TrimEnd) {
1685         while (right &gt; left &amp;&amp; isStrWhiteSpace(str[right - 1]))
1686             right--;
1687     }
1688 
1689     // Don&#39;t gc allocate a new string if we don&#39;t have to.
1690     if (left == 0 &amp;&amp; right == str.length() &amp;&amp; thisValue.isString())
1691         return thisValue;
1692 
1693     RELEASE_AND_RETURN(scope, jsString(vm, str.substringSharingImpl(left, right - left)));
1694 }
1695 
<span class="line-modified">1696 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrim(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1697 {
<span class="line-modified">1698     JSValue thisValue = callFrame-&gt;thisValue();</span>
<span class="line-modified">1699     return JSValue::encode(trimString(globalObject, thisValue, TrimStart | TrimEnd));</span>
1700 }
1701 
<span class="line-modified">1702 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimStart(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1703 {
<span class="line-modified">1704     JSValue thisValue = callFrame-&gt;thisValue();</span>
<span class="line-modified">1705     return JSValue::encode(trimString(globalObject, thisValue, TrimStart));</span>
1706 }
1707 
<span class="line-modified">1708 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimEnd(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1709 {
<span class="line-modified">1710     JSValue thisValue = callFrame-&gt;thisValue();</span>
<span class="line-modified">1711     return JSValue::encode(trimString(globalObject, thisValue, TrimEnd));</span>
1712 }
1713 
1714 static inline unsigned clampAndTruncateToUnsigned(double value, unsigned min, unsigned max)
1715 {
1716     if (value &lt; min)
1717         return min;
1718     if (value &gt; max)
1719         return max;
1720     return static_cast&lt;unsigned&gt;(value);
1721 }
1722 
<span class="line-modified">1723 EncodedJSValue JSC_HOST_CALL stringProtoFuncStartsWith(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1724 {
<span class="line-modified">1725     VM&amp; vm = globalObject-&gt;vm();</span>
1726     auto scope = DECLARE_THROW_SCOPE(vm);
1727 
<span class="line-modified">1728     JSValue thisValue = callFrame-&gt;thisValue();</span>
1729     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1730         return throwVMTypeError(globalObject, scope);</span>
1731 
<span class="line-modified">1732     String stringToSearchIn = thisValue.toWTFString(globalObject);</span>
1733     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1734 
<span class="line-modified">1735     JSValue a0 = callFrame-&gt;argument(0);</span>
<span class="line-modified">1736     bool isRegularExpression = isRegExp(vm, globalObject, a0);</span>
1737     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1738     if (isRegularExpression)
<span class="line-modified">1739         return throwVMTypeError(globalObject, scope, &quot;Argument to String.prototype.startsWith cannot be a RegExp&quot;);</span>
1740 
<span class="line-modified">1741     String searchString = a0.toWTFString(globalObject);</span>
1742     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1743 
<span class="line-modified">1744     JSValue positionArg = callFrame-&gt;argument(1);</span>
1745     unsigned start = 0;
1746     if (positionArg.isInt32())
1747         start = std::max(0, positionArg.asInt32());
1748     else {
1749         unsigned length = stringToSearchIn.length();
<span class="line-modified">1750         start = clampAndTruncateToUnsigned(positionArg.toInteger(globalObject), 0, length);</span>
1751         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1752     }
1753 
1754     return JSValue::encode(jsBoolean(stringToSearchIn.hasInfixStartingAt(searchString, start)));
1755 }
1756 
<span class="line-modified">1757 EncodedJSValue JSC_HOST_CALL stringProtoFuncEndsWith(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1758 {
<span class="line-modified">1759     VM&amp; vm = globalObject-&gt;vm();</span>
1760     auto scope = DECLARE_THROW_SCOPE(vm);
1761 
<span class="line-modified">1762     JSValue thisValue = callFrame-&gt;thisValue();</span>
1763     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1764         return throwVMTypeError(globalObject, scope);</span>
1765 
<span class="line-modified">1766     String stringToSearchIn = thisValue.toWTFString(globalObject);</span>
1767     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1768 
<span class="line-modified">1769     JSValue a0 = callFrame-&gt;argument(0);</span>
<span class="line-modified">1770     bool isRegularExpression = isRegExp(vm, globalObject, a0);</span>
1771     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1772     if (isRegularExpression)
<span class="line-modified">1773         return throwVMTypeError(globalObject, scope, &quot;Argument to String.prototype.endsWith cannot be a RegExp&quot;);</span>
1774 
<span class="line-modified">1775     String searchString = a0.toWTFString(globalObject);</span>
1776     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1777 
1778     unsigned length = stringToSearchIn.length();
1779 
<span class="line-modified">1780     JSValue endPositionArg = callFrame-&gt;argument(1);</span>
1781     unsigned end = length;
1782     if (endPositionArg.isInt32())
1783         end = std::max(0, endPositionArg.asInt32());
1784     else if (!endPositionArg.isUndefined()) {
<span class="line-modified">1785         end = clampAndTruncateToUnsigned(endPositionArg.toInteger(globalObject), 0, length);</span>
1786         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1787     }
1788 
1789     return JSValue::encode(jsBoolean(stringToSearchIn.hasInfixEndingAt(searchString, std::min(end, length))));
1790 }
1791 
<span class="line-modified">1792 static EncodedJSValue stringIncludesImpl(JSGlobalObject* globalObject, VM&amp; vm, String stringToSearchIn, String searchString, JSValue positionArg)</span>
1793 {
1794     auto scope = DECLARE_THROW_SCOPE(vm);
1795     unsigned start = 0;
1796     if (positionArg.isInt32())
1797         start = std::max(0, positionArg.asInt32());
1798     else {
1799         unsigned length = stringToSearchIn.length();
<span class="line-modified">1800         start = clampAndTruncateToUnsigned(positionArg.toInteger(globalObject), 0, length);</span>
1801         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1802     }
1803 
1804     return JSValue::encode(jsBoolean(stringToSearchIn.find(searchString, start) != notFound));
1805 }
1806 
<span class="line-modified">1807 EncodedJSValue JSC_HOST_CALL stringProtoFuncIncludes(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1808 {
<span class="line-modified">1809     VM&amp; vm = globalObject-&gt;vm();</span>
1810     auto scope = DECLARE_THROW_SCOPE(vm);
1811 
<span class="line-modified">1812     JSValue thisValue = callFrame-&gt;thisValue();</span>
1813     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1814         return throwVMTypeError(globalObject, scope);</span>
1815 
<span class="line-modified">1816     String stringToSearchIn = thisValue.toWTFString(globalObject);</span>
1817     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1818 
<span class="line-modified">1819     JSValue a0 = callFrame-&gt;argument(0);</span>
<span class="line-modified">1820     bool isRegularExpression = isRegExp(vm, globalObject, a0);</span>
1821     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1822     if (isRegularExpression)
<span class="line-modified">1823         return throwVMTypeError(globalObject, scope, &quot;Argument to String.prototype.includes cannot be a RegExp&quot;);</span>
1824 
<span class="line-modified">1825     String searchString = a0.toWTFString(globalObject);</span>
1826     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1827 
<span class="line-modified">1828     JSValue positionArg = callFrame-&gt;argument(1);</span>
1829 
<span class="line-modified">1830     RELEASE_AND_RETURN(scope, stringIncludesImpl(globalObject, vm, stringToSearchIn, searchString, positionArg));</span>
1831 }
1832 
<span class="line-modified">1833 EncodedJSValue JSC_HOST_CALL builtinStringIncludesInternal(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1834 {
<span class="line-modified">1835     VM&amp; vm = globalObject-&gt;vm();</span>
1836     auto scope = DECLARE_THROW_SCOPE(vm);
1837 
<span class="line-modified">1838     JSValue thisValue = callFrame-&gt;thisValue();</span>
1839     ASSERT(checkObjectCoercible(thisValue));
1840 
<span class="line-modified">1841     String stringToSearchIn = thisValue.toWTFString(globalObject);</span>
1842     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1843 
<span class="line-modified">1844     JSValue a0 = callFrame-&gt;uncheckedArgument(0);</span>
<span class="line-modified">1845     String searchString = a0.toWTFString(globalObject);</span>
1846     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1847 
<span class="line-modified">1848     JSValue positionArg = callFrame-&gt;argument(1);</span>
1849 
<span class="line-modified">1850     RELEASE_AND_RETURN(scope, stringIncludesImpl(globalObject, vm, stringToSearchIn, searchString, positionArg));</span>
1851 }
1852 
<span class="line-modified">1853 EncodedJSValue JSC_HOST_CALL stringProtoFuncIterator(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1854 {
<span class="line-modified">1855     VM&amp; vm = globalObject-&gt;vm();</span>
1856     auto scope = DECLARE_THROW_SCOPE(vm);
1857 
<span class="line-modified">1858     JSValue thisValue = callFrame-&gt;thisValue();</span>
1859     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1860         return throwVMTypeError(globalObject, scope);</span>
<span class="line-modified">1861     JSString* string = thisValue.toString(globalObject);</span>
1862     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1863     return JSValue::encode(JSStringIterator::create(vm, globalObject-&gt;stringIteratorStructure(), string));</span>
1864 }
1865 
1866 enum class NormalizationForm { NFC, NFD, NFKC, NFKD };
1867 
1868 static constexpr bool normalizationAffects8Bit(NormalizationForm form)
1869 {
1870     switch (form) {
1871     case NormalizationForm::NFC:
1872         return false;
1873     case NormalizationForm::NFD:
1874         return true;
1875     case NormalizationForm::NFKC:
1876         return false;
1877     case NormalizationForm::NFKD:
1878         return true;
1879     default:
1880         ASSERT_NOT_REACHED();
1881     }
1882     return true;
1883 }
</pre>
<hr />
<pre>
1888     const UNormalizer2* normalizer = nullptr;
1889     switch (form) {
1890     case NormalizationForm::NFC:
1891         normalizer = unorm2_getNFCInstance(&amp;status);
1892         break;
1893     case NormalizationForm::NFD:
1894         normalizer = unorm2_getNFDInstance(&amp;status);
1895         break;
1896     case NormalizationForm::NFKC:
1897         normalizer = unorm2_getNFKCInstance(&amp;status);
1898         break;
1899     case NormalizationForm::NFKD:
1900         normalizer = unorm2_getNFKDInstance(&amp;status);
1901         break;
1902     }
1903     ASSERT(normalizer);
1904     ASSERT(U_SUCCESS(status));
1905     return normalizer;
1906 }
1907 
<span class="line-modified">1908 static JSValue normalize(JSGlobalObject* globalObject, JSString* string, NormalizationForm form)</span>
1909 {
<span class="line-modified">1910     VM&amp; vm = globalObject-&gt;vm();</span>
1911     auto scope = DECLARE_THROW_SCOPE(vm);
1912 
<span class="line-modified">1913     auto viewWithString = string-&gt;viewWithUnderlyingString(globalObject);</span>
1914     RETURN_IF_EXCEPTION(scope, { });
1915 
1916     StringView view = viewWithString.view;
1917     if (view.is8Bit() &amp;&amp; (!normalizationAffects8Bit(form) || charactersAreAllASCII(view.characters8(), view.length())))
1918         RELEASE_AND_RETURN(scope, string);
1919 
1920     const UNormalizer2* normalizer = JSC::normalizer(form);
1921 
1922     // Since ICU does not offer functions that can perform normalization or check for
1923     // normalization with input that is Latin-1, we need to upconvert to UTF-16 at this point.
1924     auto characters = view.upconvertedCharacters();
1925 
1926     UErrorCode status = U_ZERO_ERROR;
1927     UBool isNormalized = unorm2_isNormalized(normalizer, characters, view.length(), &amp;status);
1928     ASSERT(U_SUCCESS(status));
1929     if (isNormalized)
1930         RELEASE_AND_RETURN(scope, string);
1931 
1932     int32_t normalizedStringLength = unorm2_normalize(normalizer, characters, view.length(), nullptr, 0, &amp;status);
1933     ASSERT(status == U_BUFFER_OVERFLOW_ERROR);
1934 
1935     UChar* buffer;
1936     auto result = StringImpl::tryCreateUninitialized(normalizedStringLength, buffer);
1937     if (!result)
<span class="line-modified">1938         return throwOutOfMemoryError(globalObject, scope);</span>
1939 
1940     status = U_ZERO_ERROR;
1941     unorm2_normalize(normalizer, characters, view.length(), buffer, normalizedStringLength, &amp;status);
1942     ASSERT(U_SUCCESS(status));
1943 
1944     RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(result)));
1945 }
1946 
<span class="line-modified">1947 EncodedJSValue JSC_HOST_CALL stringProtoFuncNormalize(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1948 {
<span class="line-modified">1949     VM&amp; vm = globalObject-&gt;vm();</span>
1950     auto scope = DECLARE_THROW_SCOPE(vm);
1951 
<span class="line-modified">1952     JSValue thisValue = callFrame-&gt;thisValue();</span>
1953     if (!checkObjectCoercible(thisValue))
<span class="line-modified">1954         return throwVMTypeError(globalObject, scope);</span>
<span class="line-modified">1955     JSString* string = thisValue.toString(globalObject);</span>
1956     RETURN_IF_EXCEPTION(scope, { });
1957 
1958     auto form = NormalizationForm::NFC;
<span class="line-modified">1959     JSValue formValue = callFrame-&gt;argument(0);</span>
1960     if (!formValue.isUndefined()) {
<span class="line-modified">1961         String formString = formValue.toWTFString(globalObject);</span>
1962         RETURN_IF_EXCEPTION(scope, { });
1963 
1964         if (formString == &quot;NFC&quot;)
1965             form = NormalizationForm::NFC;
1966         else if (formString == &quot;NFD&quot;)
1967             form = NormalizationForm::NFD;
1968         else if (formString == &quot;NFKC&quot;)
1969             form = NormalizationForm::NFKC;
1970         else if (formString == &quot;NFKD&quot;)
1971             form = NormalizationForm::NFKD;
1972         else
<span class="line-modified">1973             return throwVMRangeError(globalObject, scope, &quot;argument does not match any normalization form&quot;_s);</span>
1974     }
1975 
<span class="line-modified">1976     RELEASE_AND_RETURN(scope, JSValue::encode(normalize(globalObject, string, form)));</span>
1977 }
1978 
1979 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="StringObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StringPrototype.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/messageports/MessagePortChannelRegistry.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MessagePortChannelProviderImpl.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MessagePortChannelRegistry.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/messageports/MessagePortChannelRegistry.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;MessagePortChannelRegistry.h&quot;
 28 
 29 #include &quot;Logging.h&quot;
 30 #include &lt;wtf/CompletionHandler.h&gt;
 31 #include &lt;wtf/MainThread.h&gt;
 32 
 33 namespace WebCore {
 34 
<span class="line-modified"> 35 MessagePortChannelRegistry::MessagePortChannelRegistry(MessagePortChannelProvider&amp; provider)</span>
<span class="line-modified"> 36     : m_provider(provider)</span>
 37 {
 38 }
 39 
 40 MessagePortChannelRegistry::~MessagePortChannelRegistry()
 41 {
 42     ASSERT(m_openChannels.isEmpty());
 43 }
 44 
 45 void MessagePortChannelRegistry::didCreateMessagePortChannel(const MessagePortIdentifier&amp; port1, const MessagePortIdentifier&amp; port2)
 46 {
 47     LOG(MessagePorts, &quot;Registry: Creating MessagePortChannel %p linking %s and %s&quot;, this, port1.logString().utf8().data(), port2.logString().utf8().data());
 48     ASSERT(isMainThread());
 49 
 50     MessagePortChannel::create(*this, port1, port2);
 51 }
 52 
 53 void MessagePortChannelRegistry::messagePortChannelCreated(MessagePortChannel&amp; channel)
 54 {
 55     ASSERT(isMainThread());
 56 
</pre>
<hr />
<pre>
124     // FIXME: When making message ports be multi-process, this should probably push a notification
125     // to the remaining port to tell it this port closed.
126 }
127 
128 bool MessagePortChannelRegistry::didPostMessageToRemote(MessageWithMessagePorts&amp;&amp; message, const MessagePortIdentifier&amp; remoteTarget)
129 {
130     ASSERT(isMainThread());
131 
132     LOG(MessagePorts, &quot;Registry: Posting message to MessagePort %s in registry&quot;, remoteTarget.logString().utf8().data());
133 
134     // The channel might be gone if the remote side was closed.
135     auto* channel = m_openChannels.get(remoteTarget);
136     if (!channel) {
137         LOG(MessagePorts, &quot;Registry: Could not find MessagePortChannel for port %s; It was probably closed. Message will be dropped.&quot;, remoteTarget.logString().utf8().data());
138         return false;
139     }
140 
141     return channel-&gt;postMessageToRemote(WTFMove(message), remoteTarget);
142 }
143 
<span class="line-modified">144 void MessagePortChannelRegistry::takeAllMessagesForPort(const MessagePortIdentifier&amp; port, Function&lt;void(Vector&lt;MessageWithMessagePorts&gt;&amp;&amp;, Function&lt;void()&gt;&amp;&amp;)&gt;&amp;&amp; callback)</span>
145 {
146     ASSERT(isMainThread());
147 
148     LOG(MessagePorts, &quot;Registry: Taking all messages for MessagePort %s&quot;, port.logString().utf8().data());
149 
150     // The channel might be gone if the remote side was closed.
151     auto* channel = m_openChannels.get(port);
152     if (!channel) {
153         callback({ }, [] { });
154         return;
155     }
156 
157     channel-&gt;takeAllMessagesForPort(port, WTFMove(callback));
158 }
159 
<span class="line-modified">160 void MessagePortChannelRegistry::checkRemotePortForActivity(const MessagePortIdentifier&amp; remoteTarget, Function&lt;void(MessagePortChannelProvider::HasActivity)&gt;&amp;&amp; callback)</span>
161 {
162     ASSERT(isMainThread());
163 
164     // The channel might be gone if the remote side was closed.
165     auto* channel = m_openChannels.get(remoteTarget);
166     if (!channel) {
167         callback(MessagePortChannelProvider::HasActivity::No);
168         return;
169     }
170 
171     channel-&gt;checkRemotePortForActivity(remoteTarget, WTFMove(callback));
172 }
173 
174 MessagePortChannel* MessagePortChannelRegistry::existingChannelContainingPort(const MessagePortIdentifier&amp; port)
175 {
176     ASSERT(isMainThread());
177 
178     return m_openChannels.get(port);
179 }
180 





181 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;MessagePortChannelRegistry.h&quot;
 28 
 29 #include &quot;Logging.h&quot;
 30 #include &lt;wtf/CompletionHandler.h&gt;
 31 #include &lt;wtf/MainThread.h&gt;
 32 
 33 namespace WebCore {
 34 
<span class="line-modified"> 35 MessagePortChannelRegistry::MessagePortChannelRegistry(CheckProcessLocalPortForActivityCallback&amp;&amp; checkProcessLocalPortForActivityCallback)</span>
<span class="line-modified"> 36     : m_checkProcessLocalPortForActivityCallback(WTFMove(checkProcessLocalPortForActivityCallback))</span>
 37 {
 38 }
 39 
 40 MessagePortChannelRegistry::~MessagePortChannelRegistry()
 41 {
 42     ASSERT(m_openChannels.isEmpty());
 43 }
 44 
 45 void MessagePortChannelRegistry::didCreateMessagePortChannel(const MessagePortIdentifier&amp; port1, const MessagePortIdentifier&amp; port2)
 46 {
 47     LOG(MessagePorts, &quot;Registry: Creating MessagePortChannel %p linking %s and %s&quot;, this, port1.logString().utf8().data(), port2.logString().utf8().data());
 48     ASSERT(isMainThread());
 49 
 50     MessagePortChannel::create(*this, port1, port2);
 51 }
 52 
 53 void MessagePortChannelRegistry::messagePortChannelCreated(MessagePortChannel&amp; channel)
 54 {
 55     ASSERT(isMainThread());
 56 
</pre>
<hr />
<pre>
124     // FIXME: When making message ports be multi-process, this should probably push a notification
125     // to the remaining port to tell it this port closed.
126 }
127 
128 bool MessagePortChannelRegistry::didPostMessageToRemote(MessageWithMessagePorts&amp;&amp; message, const MessagePortIdentifier&amp; remoteTarget)
129 {
130     ASSERT(isMainThread());
131 
132     LOG(MessagePorts, &quot;Registry: Posting message to MessagePort %s in registry&quot;, remoteTarget.logString().utf8().data());
133 
134     // The channel might be gone if the remote side was closed.
135     auto* channel = m_openChannels.get(remoteTarget);
136     if (!channel) {
137         LOG(MessagePorts, &quot;Registry: Could not find MessagePortChannel for port %s; It was probably closed. Message will be dropped.&quot;, remoteTarget.logString().utf8().data());
138         return false;
139     }
140 
141     return channel-&gt;postMessageToRemote(WTFMove(message), remoteTarget);
142 }
143 
<span class="line-modified">144 void MessagePortChannelRegistry::takeAllMessagesForPort(const MessagePortIdentifier&amp; port, CompletionHandler&lt;void(Vector&lt;MessageWithMessagePorts&gt;&amp;&amp;, Function&lt;void()&gt;&amp;&amp;)&gt;&amp;&amp; callback)</span>
145 {
146     ASSERT(isMainThread());
147 
148     LOG(MessagePorts, &quot;Registry: Taking all messages for MessagePort %s&quot;, port.logString().utf8().data());
149 
150     // The channel might be gone if the remote side was closed.
151     auto* channel = m_openChannels.get(port);
152     if (!channel) {
153         callback({ }, [] { });
154         return;
155     }
156 
157     channel-&gt;takeAllMessagesForPort(port, WTFMove(callback));
158 }
159 
<span class="line-modified">160 void MessagePortChannelRegistry::checkRemotePortForActivity(const MessagePortIdentifier&amp; remoteTarget, CompletionHandler&lt;void(MessagePortChannelProvider::HasActivity)&gt;&amp;&amp; callback)</span>
161 {
162     ASSERT(isMainThread());
163 
164     // The channel might be gone if the remote side was closed.
165     auto* channel = m_openChannels.get(remoteTarget);
166     if (!channel) {
167         callback(MessagePortChannelProvider::HasActivity::No);
168         return;
169     }
170 
171     channel-&gt;checkRemotePortForActivity(remoteTarget, WTFMove(callback));
172 }
173 
174 MessagePortChannel* MessagePortChannelRegistry::existingChannelContainingPort(const MessagePortIdentifier&amp; port)
175 {
176     ASSERT(isMainThread());
177 
178     return m_openChannels.get(port);
179 }
180 
<span class="line-added">181 void MessagePortChannelRegistry::checkProcessLocalPortForActivity(const MessagePortIdentifier&amp; messagePortIdentifier, ProcessIdentifier processIdentifier, CompletionHandler&lt;void(MessagePortChannelProvider::HasActivity)&gt;&amp;&amp; callback)</span>
<span class="line-added">182 {</span>
<span class="line-added">183     m_checkProcessLocalPortForActivityCallback(messagePortIdentifier, processIdentifier, WTFMove(callback));</span>
<span class="line-added">184 }</span>
<span class="line-added">185 </span>
186 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="MessagePortChannelProviderImpl.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MessagePortChannelRegistry.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderVTTCue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2012 Victor Carbune (victor@rosedu.org)
  3  * Copyright (C) 2014 Apple Inc.  All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 
 29 #if ENABLE(VIDEO_TRACK)
 30 #include &quot;RenderVTTCue.h&quot;
 31 
 32 #include &quot;RenderInline.h&quot;
 33 #include &quot;RenderLayoutState.h&quot;
 34 #include &quot;RenderView.h&quot;
 35 #include &quot;TextTrackCueGeneric.h&quot;
 36 #include &quot;VTTCue.h&quot;
 37 #include &lt;wtf/IsoMallocInlines.h&gt;
 38 #include &lt;wtf/StackStats.h&gt;
 39 
 40 namespace WebCore {
 41 
 42 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderVTTCue);
 43 
 44 RenderVTTCue::RenderVTTCue(VTTCueBox&amp; element, RenderStyle&amp;&amp; style)
 45     : RenderBlockFlow(element, WTFMove(style))
<a name="1" id="anc1"></a><span class="line-modified"> 46     , m_cue(toVTTCue(element.getCue()))</span>
 47 {
<a name="2" id="anc2"></a><span class="line-added"> 48     ASSERT(m_cue);</span>
<span class="line-added"> 49     ASSERT(is&lt;VTTCue&gt;(m_cue));</span>
 50 }
 51 
 52 void RenderVTTCue::layout()
 53 {
 54     StackStats::LayoutCheckPoint layoutCheckPoint;
 55     RenderBlockFlow::layout();
 56 
 57     // If WebVTT Regions are used, the regular WebVTT layout algorithm is no
 58     // longer necessary, since cues having the region parameter set do not have
 59     // any positioning parameters. Also, in this case, the regions themselves
 60     // have positioning information.
 61     if (!m_cue-&gt;regionId().isEmpty())
 62         return;
 63 
 64     LayoutStateMaintainer statePusher(*this, locationOffset(), hasTransform() || hasReflection() || style().isFlippedBlocksWritingMode());
 65 
 66     if (m_cue-&gt;cueType()== TextTrackCue::WebVTT) {
 67         if (toVTTCue(m_cue)-&gt;snapToLines())
 68             repositionCueSnapToLinesSet();
 69         else
 70             repositionCueSnapToLinesNotSet();
 71     } else
 72         repositionGenericCue();
 73 }
 74 
 75 bool RenderVTTCue::initializeLayoutParameters(InlineFlowBox*&amp; firstLineBox, LayoutUnit&amp; step, LayoutUnit&amp; position)
 76 {
 77     ASSERT(firstChild());
 78     if (!firstChild())
 79         return false;
 80 
 81     RenderBlock* parentBlock = containingBlock();
 82 
 83     // firstChild() returns the wrapping (backdrop) &lt;div&gt;. The cue object is
 84     // the &lt;div&gt;&#39;s first child.
 85     RenderObject&amp; firstChild = *this-&gt;firstChild();
 86     RenderElement&amp; backdropElement = downcast&lt;RenderElement&gt;(firstChild);
 87 
 88     firstLineBox = downcast&lt;RenderInline&gt;(*backdropElement.firstChild()).firstLineBox();
 89     if (!firstLineBox)
 90         firstLineBox = this-&gt;firstRootBox();
 91 
 92     // 1. Horizontal: Let step be the height of the first line box in boxes.
 93     //    Vertical: Let step be the width of the first line box in boxes.
 94     step = m_cue-&gt;getWritingDirection() == VTTCue::Horizontal ? firstLineBox-&gt;height() : firstLineBox-&gt;width();
 95 
 96     // 2. If step is zero, then jump to the step labeled done positioning below.
 97     if (!step)
 98         return false;
 99 
100     // 3. Let line position be the text track cue computed line position.
101     int linePosition = m_cue-&gt;calculateComputedLinePosition();
102 
103     // 4. Vertical Growing Left: Add one to line position then negate it.
104     if (m_cue-&gt;getWritingDirection() == VTTCue::VerticalGrowingLeft)
105         linePosition = -(linePosition + 1);
106 
107     // 5. Let position be the result of multiplying step and line position.
108     position = step * linePosition;
109 
110     // 6. Vertical Growing Left: Decrease position by the width of the
111     // bounding box of the boxes in boxes, then increase position by step.
112     if (m_cue-&gt;getWritingDirection() == VTTCue::VerticalGrowingLeft) {
113         position -= width();
114         position += step;
115     }
116 
117     // 7. If line position is less than zero...
118     if (linePosition &lt; 0) {
119         // Horizontal / Vertical: ... then increase position by the
120         // height / width of the video&#39;s rendering area ...
121         position += m_cue-&gt;getWritingDirection() == VTTCue::Horizontal ? parentBlock-&gt;height() : parentBlock-&gt;width();
122 
123         // ... and negate step.
124         step = -step;
125     }
126 
127     return true;
128 }
129 
130 void RenderVTTCue::placeBoxInDefaultPosition(LayoutUnit position, bool&amp; switched)
131 {
132     // 8. Move all boxes in boxes ...
133     if (m_cue-&gt;getWritingDirection() == VTTCue::Horizontal)
134         // Horizontal: ... down by the distance given by position
135         setY(y() + position);
136     else
137         // Vertical: ... right by the distance given by position
138         setX(x() + position);
139 
140     // 9. Default: Remember the position of all the boxes in boxes as their
141     // default position.
142     m_fallbackPosition = FloatPoint(x(), y());
143 
144     // 10. Let switched be false.
145     switched = false;
146 }
147 
148 bool RenderVTTCue::isOutside() const
149 {
150     return !rectIsWithinContainer(absoluteContentBox());
151 }
152 
153 bool RenderVTTCue::rectIsWithinContainer(const IntRect&amp; rect) const
154 {
155     return containingBlock()-&gt;absoluteBoundingBoxRect().contains(rect);
156 }
157 
158 
159 bool RenderVTTCue::isOverlapping() const
160 {
161     return overlappingObject();
162 }
163 
164 RenderObject* RenderVTTCue::overlappingObject() const
165 {
166     return overlappingObjectForRect(absoluteBoundingBoxRect());
167 }
168 
169 RenderObject* RenderVTTCue::overlappingObjectForRect(const IntRect&amp; rect) const
170 {
171     for (RenderObject* box = previousSibling(); box; box = box-&gt;previousSibling()) {
172         IntRect boxRect = box-&gt;absoluteBoundingBoxRect();
173 
174         if (rect.intersects(boxRect))
175             return box;
176     }
177 
178     return 0;
179 }
180 
181 bool RenderVTTCue::shouldSwitchDirection(InlineFlowBox* firstLineBox, LayoutUnit step) const
182 {
183     LayoutUnit top = y();
184     LayoutUnit left = x();
185     LayoutUnit bottom { top + firstLineBox-&gt;height() };
186     LayoutUnit right { left + firstLineBox-&gt;width() };
187 
188     // 12. Horizontal: If step is negative and the top of the first line
189     // box in boxes is now above the top of the video&#39;s rendering area,
190     // or if step is positive and the bottom of the first line box in
191     // boxes is now below the bottom of the video&#39;s rendering area, jump
192     // to the step labeled switch direction.
193     LayoutUnit parentHeight = containingBlock()-&gt;height();
194     if (m_cue-&gt;getWritingDirection() == VTTCue::Horizontal &amp;&amp; ((step &lt; 0 &amp;&amp; top &lt; 0) || (step &gt; 0 &amp;&amp; bottom &gt; parentHeight)))
195         return true;
196 
197     // 12. Vertical: If step is negative and the left edge of the first line
198     // box in boxes is now to the left of the left edge of the video&#39;s
199     // rendering area, or if step is positive and the right edge of the
200     // first line box in boxes is now to the right of the right edge of
201     // the video&#39;s rendering area, jump to the step labeled switch direction.
202     LayoutUnit parentWidth = containingBlock()-&gt;width();
203     if (m_cue-&gt;getWritingDirection() != VTTCue::Horizontal &amp;&amp; ((step &lt; 0 &amp;&amp; left &lt; 0) || (step &gt; 0 &amp;&amp; right &gt; parentWidth)))
204         return true;
205 
206     return false;
207 }
208 
209 void RenderVTTCue::moveBoxesByStep(LayoutUnit step)
210 {
211     // 13. Horizontal: Move all the boxes in boxes down by the distance
212     // given by step. (If step is negative, then this will actually
213     // result in an upwards movement of the boxes in absolute terms.)
214     if (m_cue-&gt;getWritingDirection() == VTTCue::Horizontal)
215         setY(y() + step);
216 
217     // 13. Vertical: Move all the boxes in boxes right by the distance
218     // given by step. (If step is negative, then this will actually
219     // result in a leftwards movement of the boxes in absolute terms.)
220     else
221         setX(x() + step);
222 }
223 
224 bool RenderVTTCue::switchDirection(bool&amp; switched, LayoutUnit&amp; step)
225 {
226     // 15. Switch direction: Move all the boxes in boxes back to their
227     // default position as determined in the step above labeled default.
228     setX(m_fallbackPosition.x());
229     setY(m_fallbackPosition.y());
230 
231     // 16. If switched is true, jump to the step labeled done
232     // positioning below.
233     if (switched)
234         return false;
235 
236     // 17. Negate step.
237     step = -step;
238 
239     // 18. Set switched to true.
240     switched = true;
241     return true;
242 }
243 
244 void RenderVTTCue::moveIfNecessaryToKeepWithinContainer()
245 {
246     IntRect containerRect = containingBlock()-&gt;absoluteBoundingBoxRect();
247     IntRect cueRect = absoluteBoundingBoxRect();
248 
249     int topOverflow = cueRect.y() - containerRect.y();
250     int bottomOverflow = containerRect.maxY() - cueRect.maxY();
251 
252     int verticalAdjustment = 0;
253     if (topOverflow &lt; 0)
254         verticalAdjustment = -topOverflow;
255     else if (bottomOverflow &lt; 0)
256         verticalAdjustment = bottomOverflow;
257 
258     if (verticalAdjustment)
259         setY(y() + verticalAdjustment);
260 
261     int leftOverflow = cueRect.x() - containerRect.x();
262     int rightOverflow = containerRect.maxX() - cueRect.maxX();
263 
264     int horizontalAdjustment = 0;
265     if (leftOverflow &lt; 0)
266         horizontalAdjustment = -leftOverflow;
267     else if (rightOverflow &lt; 0)
268         horizontalAdjustment = rightOverflow;
269 
270     if (horizontalAdjustment)
271         setX(x() + horizontalAdjustment);
272 }
273 
274 bool RenderVTTCue::findNonOverlappingPosition(int&amp; newX, int&amp; newY) const
275 {
276     newX = x();
277     newY = y();
278     IntRect srcRect = absoluteBoundingBoxRect();
279     IntRect destRect = srcRect;
280 
281     // Move the box up, looking for a non-overlapping position:
282     while (RenderObject* box = overlappingObjectForRect(destRect)) {
283         if (m_cue-&gt;getWritingDirection() == VTTCue::Horizontal)
284             destRect.setY(box-&gt;absoluteBoundingBoxRect().y() - destRect.height());
285         else
286             destRect.setX(box-&gt;absoluteBoundingBoxRect().x() - destRect.width());
287     }
288 
289     if (rectIsWithinContainer(destRect)) {
290         newX += destRect.x() - srcRect.x();
291         newY += destRect.y() - srcRect.y();
292         return true;
293     }
294 
295     destRect = srcRect;
296 
297     // Move the box down, looking for a non-overlapping position:
298     while (RenderObject* box = overlappingObjectForRect(destRect)) {
299         if (m_cue-&gt;getWritingDirection() == VTTCue::Horizontal)
300             destRect.setY(box-&gt;absoluteBoundingBoxRect().maxY());
301         else
302             destRect.setX(box-&gt;absoluteBoundingBoxRect().maxX());
303     }
304 
305     if (rectIsWithinContainer(destRect)) {
306         newX += destRect.x() - srcRect.x();
307         newY += destRect.y() - srcRect.y();
308         return true;
309     }
310 
311     return false;
312 }
313 
314 void RenderVTTCue::repositionCueSnapToLinesSet()
315 {
316     InlineFlowBox* firstLineBox;
317     LayoutUnit step;
318     LayoutUnit position;
319     if (!initializeLayoutParameters(firstLineBox, step, position))
320         return;
321 
322     bool switched;
323     placeBoxInDefaultPosition(position, switched);
324 
325     // 11. Step loop: If none of the boxes in boxes would overlap any of the boxes
326     // in output and all the boxes in output are within the video&#39;s rendering area
327     // then jump to the step labeled done positioning.
328     while (isOutside() || isOverlapping()) {
329         if (!shouldSwitchDirection(firstLineBox, step))
330             // 13. Move all the boxes in boxes ...
331             // 14. Jump back to the step labeled step loop.
332             moveBoxesByStep(step);
333         else if (!switchDirection(switched, step))
334             break;
335 
336         // 19. Jump back to the step labeled step loop.
337     }
338 
339     // Acommodate extra top and bottom padding, border or margin.
340     // Note: this is supported only for internal UA styling, not through the cue selector.
341     if (hasInlineDirectionBordersPaddingOrMargin())
342         moveIfNecessaryToKeepWithinContainer();
343 }
344 
345 void RenderVTTCue::repositionGenericCue()
346 {
347     ASSERT(firstChild());
348 
349     // firstChild() returns the wrapping (backdrop) &lt;div&gt;. The cue object is
350     // the &lt;div&gt;&#39;s first child.
351     RenderObject&amp; firstChild = *this-&gt;firstChild();
352     RenderElement&amp; backdropElement = downcast&lt;RenderElement&gt;(firstChild);
353 
354     InlineFlowBox* firstLineBox = downcast&lt;RenderInline&gt;(*backdropElement.firstChild()).firstLineBox();
355     if (static_cast&lt;TextTrackCueGeneric*&gt;(m_cue)-&gt;useDefaultPosition() &amp;&amp; firstLineBox) {
356         LayoutUnit parentWidth = containingBlock()-&gt;logicalWidth();
357         LayoutUnit width { firstLineBox-&gt;width() };
358         LayoutUnit right = (parentWidth / 2) - (width / 2);
359         setX(right);
360     }
361     repositionCueSnapToLinesNotSet();
362 }
363 
364 void RenderVTTCue::repositionCueSnapToLinesNotSet()
365 {
366     // 3. If none of the boxes in boxes would overlap any of the boxes in output, and all the boxes in
367     // output are within the video&#39;s rendering area, then jump to the step labeled done positioning below.
368     if (!isOutside() &amp;&amp; !isOverlapping())
369         return;
370 
371     // 4. If there is a position to which the boxes in boxes can be moved while maintaining the relative
372     // positions of the boxes in boxes to each other such that none of the boxes in boxes would overlap
373     // any of the boxes in output, and all the boxes in output would be within the video&#39;s rendering area,
374     // then move the boxes in boxes to the closest such position to their current position, and then jump
375     // to the step labeled done positioning below. If there are multiple such positions that are equidistant
376     // from their current position, use the highest one amongst them; if there are several at that height,
377     // then use the leftmost one amongst them.
378     moveIfNecessaryToKeepWithinContainer();
379     int x = 0;
380     int y = 0;
381     if (!findNonOverlappingPosition(x, y))
382         return;
383 
384     setX(x);
385     setY(y);
386 }
387 
388 } // namespace WebCore
389 
390 #endif
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
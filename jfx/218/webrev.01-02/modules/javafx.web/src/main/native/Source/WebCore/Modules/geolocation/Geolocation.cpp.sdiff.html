<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/geolocation/Geolocation.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../gamepad/GamepadEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Geolocation.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/geolocation/Geolocation.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
129     copy = copyToVector(m_idToNotifierMap.values());
130 }
131 
132 Ref&lt;Geolocation&gt; Geolocation::create(Navigator&amp; navigator)
133 {
134     auto geolocation = adoptRef(*new Geolocation(navigator));
135     geolocation.get().suspendIfNeeded();
136     return geolocation;
137 }
138 
139 Geolocation::Geolocation(Navigator&amp; navigator)
140     : ActiveDOMObject(navigator.scriptExecutionContext())
141     , m_navigator(makeWeakPtr(navigator))
142     , m_resumeTimer(*this, &amp;Geolocation::resumeTimerFired)
143 {
144 }
145 
146 Geolocation::~Geolocation()
147 {
148     ASSERT(m_allowGeolocation != InProgress);

149 }
150 
151 SecurityOrigin* Geolocation::securityOrigin() const
152 {
153     return scriptExecutionContext()-&gt;securityOrigin();
154 }
155 
156 Page* Geolocation::page() const
157 {
158     return document() ? document()-&gt;page() : nullptr;
159 }
160 
<span class="line-removed">161 bool Geolocation::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">162 {</span>
<span class="line-removed">163     return true;</span>
<span class="line-removed">164 }</span>
<span class="line-removed">165 </span>
166 void Geolocation::suspend(ReasonForSuspension reason)
167 {
<span class="line-modified">168     if (reason == ReasonForSuspension::PageCache) {</span>
169         stop();
170         m_resetOnResume = true;
171     }
172 
173     // Suspend GeoNotifier timeout timers.
174     if (hasListeners())
175         stopTimers();
176 
177     m_isSuspended = true;
178     m_resumeTimer.stop();
179     ActiveDOMObject::suspend(reason);
180 }
181 
182 void Geolocation::resume()
183 {
184 #if USE(WEB_THREAD)
185     ASSERT(WebThreadIsLockedOrDisabled());
186 #endif
187     ActiveDOMObject::resume();
188 
</pre>
<hr />
<pre>
194 {
195     m_isSuspended = false;
196 
197     if (m_resetOnResume) {
198         resetAllGeolocationPermission();
199         m_resetOnResume = false;
200     }
201 
202     // Resume GeoNotifier timeout timers.
203     if (hasListeners()) {
204         for (auto&amp; notifier : m_oneShots)
205             notifier-&gt;startTimerIfNeeded();
206         GeoNotifierVector watcherCopy;
207         m_watchers.getNotifiersVector(watcherCopy);
208         for (auto&amp; watcher : watcherCopy)
209             watcher-&gt;startTimerIfNeeded();
210     }
211 
212     if ((isAllowed() || isDenied()) &amp;&amp; !m_pendingForPermissionNotifiers.isEmpty()) {
213         // The pending permission was granted while the object was suspended.
<span class="line-modified">214         setIsAllowed(isAllowed());</span>
215         ASSERT(!m_hasChangedPosition);
216         ASSERT(!m_errorWaitingForResume);
217         return;
218     }
219 
220     if (isDenied() &amp;&amp; hasListeners()) {
221         // The permission was revoked while the object was suspended.
<span class="line-modified">222         setIsAllowed(false);</span>
223         return;
224     }
225 
226     if (m_hasChangedPosition) {
227         positionChanged();
228         m_hasChangedPosition = false;
229     }
230 
231     if (m_errorWaitingForResume) {
232         handleError(*m_errorWaitingForResume);
233         m_errorWaitingForResume = nullptr;
234     }
235 }
236 
237 void Geolocation::resetAllGeolocationPermission()
238 {
239     if (m_isSuspended) {
240         m_resetOnResume = true;
241         return;
242     }
243 
244     if (m_allowGeolocation == InProgress) {
245         Page* page = this-&gt;page();
246         if (page)
247             GeolocationController::from(page)-&gt;cancelPermissionRequest(*this);
248 
249         // This return is not technically correct as GeolocationController::cancelPermissionRequest() should have cleared the active request.
250         // Neither iOS nor OS X supports cancelPermissionRequest() (https://bugs.webkit.org/show_bug.cgi?id=89524), so we workaround that and let ongoing requests complete. :(
251         return;
252     }
253 
254     // 1) Reset our own state.
255     stopUpdating();
<span class="line-modified">256     m_allowGeolocation = Unknown;</span>
257     m_hasChangedPosition = false;
258     m_errorWaitingForResume = nullptr;
259 
260     // 2) Request new permission for the active notifiers.
261     stopTimers();
262 
263     // Go over the one shot and re-request permission.
264     for (auto&amp; notifier : m_oneShots)
265         startRequest(notifier.get());
266     // Go over the watchers and re-request permission.
267     GeoNotifierVector watcherCopy;
268     m_watchers.getNotifiersVector(watcherCopy);
269     for (auto&amp; watcher : watcherCopy)
270         startRequest(watcher.get());
271 }
272 
273 void Geolocation::stop()
274 {
275     Page* page = this-&gt;page();
276     if (page &amp;&amp; m_allowGeolocation == InProgress)
277         GeolocationController::from(page)-&gt;cancelPermissionRequest(*this);
278     // The frame may be moving to a new page and we want to get the permissions from the new page&#39;s client.
<span class="line-modified">279     m_allowGeolocation = Unknown;</span>
280     cancelAllRequests();
281     stopUpdating();
282     m_hasChangedPosition = false;
283     m_errorWaitingForResume = nullptr;
284     m_pendingForPermissionNotifiers.clear();
285 }
286 
287 const char* Geolocation::activeDOMObjectName() const
288 {
289     return &quot;Geolocation&quot;;
290 }
291 
292 GeolocationPosition* Geolocation::lastPosition()
293 {
294     Page* page = this-&gt;page();
295     if (!page)
296         return nullptr;
297 
298     m_lastPosition = createGeolocationPosition(GeolocationController::from(page)-&gt;lastPosition());
299 
</pre>
<hr />
<pre>
468         return false;
469     if (!options.maximumAge)
470         return false;
471     DOMTimeStamp currentTimeMillis = convertSecondsToDOMTimeStamp(WallTime::now().secondsSinceEpoch());
472     return cachedPosition-&gt;timestamp() &gt; currentTimeMillis - options.maximumAge;
473 }
474 
475 void Geolocation::clearWatch(int watchID)
476 {
477     if (watchID &lt;= 0)
478         return;
479 
480     if (GeoNotifier* notifier = m_watchers.find(watchID))
481         m_pendingForPermissionNotifiers.remove(notifier);
482     m_watchers.remove(watchID);
483 
484     if (!hasListeners())
485         stopUpdating();
486 }
487 
<span class="line-modified">488 void Geolocation::setIsAllowed(bool allowed)</span>
489 {
490     // Protect the Geolocation object from garbage collection during a callback.
491     Ref&lt;Geolocation&gt; protectedThis(*this);
492 
493     // This may be due to either a new position from the service, or a cached
494     // position.
495     m_allowGeolocation = allowed ? Yes : No;

496 
497     if (m_isSuspended)
498         return;
499 
500     // Permission request was made during the startRequest process
501     if (!m_pendingForPermissionNotifiers.isEmpty()) {
502         handlePendingPermissionNotifiers();
503         m_pendingForPermissionNotifiers.clear();
504         return;
505     }
506 
507     if (!isAllowed()) {
508         auto error = GeolocationPositionError::create(GeolocationPositionError::PERMISSION_DENIED, permissionDeniedErrorMessage);
509         error-&gt;setIsFatal(true);
510         handleError(error);
511         m_requestsAwaitingCachedPosition.clear();
512         m_hasChangedPosition = false;
513         m_errorWaitingForResume = nullptr;
514         return;
515     }
</pre>
<hr />
<pre>
625 
626     // Maintain a reference to the cached notifiers until their timer fires.
627     copyToSet(oneShotsWithCachedPosition, m_oneShots);
628 }
629 
630 void Geolocation::requestPermission()
631 {
632     if (m_allowGeolocation &gt; Unknown)
633         return;
634 
635     Page* page = this-&gt;page();
636     if (!page)
637         return;
638 
639     m_allowGeolocation = InProgress;
640 
641     // Ask the embedder: it maintains the geolocation challenge policy itself.
642     GeolocationController::from(page)-&gt;requestPermission(*this);
643 }
644 


















645 void Geolocation::makeSuccessCallbacks(GeolocationPosition&amp; position)
646 {
647     ASSERT(lastPosition());
648     ASSERT(isAllowed());
649 
650     auto oneShotsCopy = copyToVector(m_oneShots);
651 
652     GeoNotifierVector watchersCopy;
653     m_watchers.getNotifiersVector(watchersCopy);
654 
655     // Clear the lists before we make the callbacks, to avoid clearing notifiers
656     // added by calls to Geolocation methods from the callbacks, and to prevent
657     // further callbacks to these notifiers.
658     m_oneShots.clear();
659 
660     sendPosition(oneShotsCopy, position);
661     sendPosition(watchersCopy, position);
662 
663     if (!hasListeners())
664         stopUpdating();
</pre>
</td>
<td>
<hr />
<pre>
129     copy = copyToVector(m_idToNotifierMap.values());
130 }
131 
132 Ref&lt;Geolocation&gt; Geolocation::create(Navigator&amp; navigator)
133 {
134     auto geolocation = adoptRef(*new Geolocation(navigator));
135     geolocation.get().suspendIfNeeded();
136     return geolocation;
137 }
138 
139 Geolocation::Geolocation(Navigator&amp; navigator)
140     : ActiveDOMObject(navigator.scriptExecutionContext())
141     , m_navigator(makeWeakPtr(navigator))
142     , m_resumeTimer(*this, &amp;Geolocation::resumeTimerFired)
143 {
144 }
145 
146 Geolocation::~Geolocation()
147 {
148     ASSERT(m_allowGeolocation != InProgress);
<span class="line-added">149     revokeAuthorizationTokenIfNecessary();</span>
150 }
151 
152 SecurityOrigin* Geolocation::securityOrigin() const
153 {
154     return scriptExecutionContext()-&gt;securityOrigin();
155 }
156 
157 Page* Geolocation::page() const
158 {
159     return document() ? document()-&gt;page() : nullptr;
160 }
161 





162 void Geolocation::suspend(ReasonForSuspension reason)
163 {
<span class="line-modified">164     if (reason == ReasonForSuspension::BackForwardCache) {</span>
165         stop();
166         m_resetOnResume = true;
167     }
168 
169     // Suspend GeoNotifier timeout timers.
170     if (hasListeners())
171         stopTimers();
172 
173     m_isSuspended = true;
174     m_resumeTimer.stop();
175     ActiveDOMObject::suspend(reason);
176 }
177 
178 void Geolocation::resume()
179 {
180 #if USE(WEB_THREAD)
181     ASSERT(WebThreadIsLockedOrDisabled());
182 #endif
183     ActiveDOMObject::resume();
184 
</pre>
<hr />
<pre>
190 {
191     m_isSuspended = false;
192 
193     if (m_resetOnResume) {
194         resetAllGeolocationPermission();
195         m_resetOnResume = false;
196     }
197 
198     // Resume GeoNotifier timeout timers.
199     if (hasListeners()) {
200         for (auto&amp; notifier : m_oneShots)
201             notifier-&gt;startTimerIfNeeded();
202         GeoNotifierVector watcherCopy;
203         m_watchers.getNotifiersVector(watcherCopy);
204         for (auto&amp; watcher : watcherCopy)
205             watcher-&gt;startTimerIfNeeded();
206     }
207 
208     if ((isAllowed() || isDenied()) &amp;&amp; !m_pendingForPermissionNotifiers.isEmpty()) {
209         // The pending permission was granted while the object was suspended.
<span class="line-modified">210         setIsAllowed(isAllowed(), authorizationToken());</span>
211         ASSERT(!m_hasChangedPosition);
212         ASSERT(!m_errorWaitingForResume);
213         return;
214     }
215 
216     if (isDenied() &amp;&amp; hasListeners()) {
217         // The permission was revoked while the object was suspended.
<span class="line-modified">218         setIsAllowed(false, { });</span>
219         return;
220     }
221 
222     if (m_hasChangedPosition) {
223         positionChanged();
224         m_hasChangedPosition = false;
225     }
226 
227     if (m_errorWaitingForResume) {
228         handleError(*m_errorWaitingForResume);
229         m_errorWaitingForResume = nullptr;
230     }
231 }
232 
233 void Geolocation::resetAllGeolocationPermission()
234 {
235     if (m_isSuspended) {
236         m_resetOnResume = true;
237         return;
238     }
239 
240     if (m_allowGeolocation == InProgress) {
241         Page* page = this-&gt;page();
242         if (page)
243             GeolocationController::from(page)-&gt;cancelPermissionRequest(*this);
244 
245         // This return is not technically correct as GeolocationController::cancelPermissionRequest() should have cleared the active request.
246         // Neither iOS nor OS X supports cancelPermissionRequest() (https://bugs.webkit.org/show_bug.cgi?id=89524), so we workaround that and let ongoing requests complete. :(
247         return;
248     }
249 
250     // 1) Reset our own state.
251     stopUpdating();
<span class="line-modified">252     resetIsAllowed();</span>
253     m_hasChangedPosition = false;
254     m_errorWaitingForResume = nullptr;
255 
256     // 2) Request new permission for the active notifiers.
257     stopTimers();
258 
259     // Go over the one shot and re-request permission.
260     for (auto&amp; notifier : m_oneShots)
261         startRequest(notifier.get());
262     // Go over the watchers and re-request permission.
263     GeoNotifierVector watcherCopy;
264     m_watchers.getNotifiersVector(watcherCopy);
265     for (auto&amp; watcher : watcherCopy)
266         startRequest(watcher.get());
267 }
268 
269 void Geolocation::stop()
270 {
271     Page* page = this-&gt;page();
272     if (page &amp;&amp; m_allowGeolocation == InProgress)
273         GeolocationController::from(page)-&gt;cancelPermissionRequest(*this);
274     // The frame may be moving to a new page and we want to get the permissions from the new page&#39;s client.
<span class="line-modified">275     resetIsAllowed();</span>
276     cancelAllRequests();
277     stopUpdating();
278     m_hasChangedPosition = false;
279     m_errorWaitingForResume = nullptr;
280     m_pendingForPermissionNotifiers.clear();
281 }
282 
283 const char* Geolocation::activeDOMObjectName() const
284 {
285     return &quot;Geolocation&quot;;
286 }
287 
288 GeolocationPosition* Geolocation::lastPosition()
289 {
290     Page* page = this-&gt;page();
291     if (!page)
292         return nullptr;
293 
294     m_lastPosition = createGeolocationPosition(GeolocationController::from(page)-&gt;lastPosition());
295 
</pre>
<hr />
<pre>
464         return false;
465     if (!options.maximumAge)
466         return false;
467     DOMTimeStamp currentTimeMillis = convertSecondsToDOMTimeStamp(WallTime::now().secondsSinceEpoch());
468     return cachedPosition-&gt;timestamp() &gt; currentTimeMillis - options.maximumAge;
469 }
470 
471 void Geolocation::clearWatch(int watchID)
472 {
473     if (watchID &lt;= 0)
474         return;
475 
476     if (GeoNotifier* notifier = m_watchers.find(watchID))
477         m_pendingForPermissionNotifiers.remove(notifier);
478     m_watchers.remove(watchID);
479 
480     if (!hasListeners())
481         stopUpdating();
482 }
483 
<span class="line-modified">484 void Geolocation::setIsAllowed(bool allowed, const String&amp; authorizationToken)</span>
485 {
486     // Protect the Geolocation object from garbage collection during a callback.
487     Ref&lt;Geolocation&gt; protectedThis(*this);
488 
489     // This may be due to either a new position from the service, or a cached
490     // position.
491     m_allowGeolocation = allowed ? Yes : No;
<span class="line-added">492     m_authorizationToken = authorizationToken;</span>
493 
494     if (m_isSuspended)
495         return;
496 
497     // Permission request was made during the startRequest process
498     if (!m_pendingForPermissionNotifiers.isEmpty()) {
499         handlePendingPermissionNotifiers();
500         m_pendingForPermissionNotifiers.clear();
501         return;
502     }
503 
504     if (!isAllowed()) {
505         auto error = GeolocationPositionError::create(GeolocationPositionError::PERMISSION_DENIED, permissionDeniedErrorMessage);
506         error-&gt;setIsFatal(true);
507         handleError(error);
508         m_requestsAwaitingCachedPosition.clear();
509         m_hasChangedPosition = false;
510         m_errorWaitingForResume = nullptr;
511         return;
512     }
</pre>
<hr />
<pre>
622 
623     // Maintain a reference to the cached notifiers until their timer fires.
624     copyToSet(oneShotsWithCachedPosition, m_oneShots);
625 }
626 
627 void Geolocation::requestPermission()
628 {
629     if (m_allowGeolocation &gt; Unknown)
630         return;
631 
632     Page* page = this-&gt;page();
633     if (!page)
634         return;
635 
636     m_allowGeolocation = InProgress;
637 
638     // Ask the embedder: it maintains the geolocation challenge policy itself.
639     GeolocationController::from(page)-&gt;requestPermission(*this);
640 }
641 
<span class="line-added">642 void Geolocation::revokeAuthorizationTokenIfNecessary()</span>
<span class="line-added">643 {</span>
<span class="line-added">644     if (m_authorizationToken.isNull())</span>
<span class="line-added">645         return;</span>
<span class="line-added">646 </span>
<span class="line-added">647     Page* page = this-&gt;page();</span>
<span class="line-added">648     if (!page)</span>
<span class="line-added">649         return;</span>
<span class="line-added">650 </span>
<span class="line-added">651     GeolocationController::from(page)-&gt;revokeAuthorizationToken(std::exchange(m_authorizationToken, String()));</span>
<span class="line-added">652 }</span>
<span class="line-added">653 </span>
<span class="line-added">654 void Geolocation::resetIsAllowed()</span>
<span class="line-added">655 {</span>
<span class="line-added">656     m_allowGeolocation = Unknown;</span>
<span class="line-added">657     revokeAuthorizationTokenIfNecessary();</span>
<span class="line-added">658 }</span>
<span class="line-added">659 </span>
660 void Geolocation::makeSuccessCallbacks(GeolocationPosition&amp; position)
661 {
662     ASSERT(lastPosition());
663     ASSERT(isAllowed());
664 
665     auto oneShotsCopy = copyToVector(m_oneShots);
666 
667     GeoNotifierVector watchersCopy;
668     m_watchers.getNotifiersVector(watchersCopy);
669 
670     // Clear the lists before we make the callbacks, to avoid clearing notifiers
671     // added by calls to Geolocation methods from the callbacks, and to prevent
672     // further callbacks to these notifiers.
673     m_oneShots.clear();
674 
675     sendPosition(oneShotsCopy, position);
676     sendPosition(watchersCopy, position);
677 
678     if (!hasListeners())
679         stopUpdating();
</pre>
</td>
</tr>
</table>
<center><a href="../gamepad/GamepadEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Geolocation.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorCanvas.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorAuditAccessibilityObject.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InspectorCanvas.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorCanvas.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;InspectorCanvas.h&quot;
  28 
  29 #include &quot;AffineTransform.h&quot;
  30 #include &quot;CachedImage.h&quot;
  31 #include &quot;CanvasGradient.h&quot;
  32 #include &quot;CanvasPattern.h&quot;
  33 #include &quot;CanvasRenderingContext.h&quot;
  34 #include &quot;CanvasRenderingContext2D.h&quot;
  35 #include &quot;Document.h&quot;

  36 #include &quot;FloatPoint.h&quot;
  37 #include &quot;Gradient.h&quot;
  38 #include &quot;HTMLCanvasElement.h&quot;
  39 #include &quot;HTMLImageElement.h&quot;
  40 #include &quot;HTMLVideoElement.h&quot;
  41 #include &quot;Image.h&quot;
  42 #include &quot;ImageBitmap.h&quot;
  43 #include &quot;ImageBitmapRenderingContext.h&quot;
  44 #include &quot;ImageBuffer.h&quot;
  45 #include &quot;ImageData.h&quot;
  46 #include &quot;InspectorDOMAgent.h&quot;
  47 #include &quot;JSCanvasDirection.h&quot;
  48 #include &quot;JSCanvasFillRule.h&quot;
  49 #include &quot;JSCanvasLineCap.h&quot;
  50 #include &quot;JSCanvasLineJoin.h&quot;

  51 #include &quot;JSCanvasTextAlign.h&quot;
  52 #include &quot;JSCanvasTextBaseline.h&quot;
  53 #include &quot;JSExecState.h&quot;

  54 #include &quot;JSImageSmoothingQuality.h&quot;
  55 #include &quot;Path2D.h&quot;
  56 #include &quot;Pattern.h&quot;
  57 #include &quot;RecordingSwizzleTypes.h&quot;
  58 #include &quot;SVGPathUtilities.h&quot;
  59 #include &quot;StringAdaptors.h&quot;




  60 #if ENABLE(CSS_TYPED_OM)
  61 #include &quot;TypedOMCSSImageValue.h&quot;
  62 #endif

  63 #if ENABLE(WEBGL)

  64 #include &quot;WebGLRenderingContext.h&quot;
  65 #endif

  66 #if ENABLE(WEBGL2)

  67 #include &quot;WebGL2RenderingContext.h&quot;
  68 #endif

  69 #if ENABLE(WEBGPU)
  70 #include &quot;GPUCanvasContext.h&quot;


  71 #endif
<span class="line-removed">  72 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;</span>
<span class="line-removed">  73 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;</span>
<span class="line-removed">  74 #include &lt;wtf/Function.h&gt;</span>
  75 
  76 namespace WebCore {
  77 
  78 using namespace Inspector;
  79 


















  80 Ref&lt;InspectorCanvas&gt; InspectorCanvas::create(CanvasRenderingContext&amp; context)
  81 {
  82     return adoptRef(*new InspectorCanvas(context));
  83 }
  84 







  85 InspectorCanvas::InspectorCanvas(CanvasRenderingContext&amp; context)
  86     : m_identifier(&quot;canvas:&quot; + IdentifiersFactory::createIdentifier())
  87     , m_context(context)
  88 {



















  89 }
  90 
<span class="line-modified">  91 HTMLCanvasElement* InspectorCanvas::canvasElement()</span>
  92 {
<span class="line-modified">  93     if (is&lt;HTMLCanvasElement&gt;(m_context.canvasBase()))</span>
<span class="line-modified">  94         return &amp;downcast&lt;HTMLCanvasElement&gt;(m_context.canvasBase());</span>































  95     return nullptr;
  96 }
  97 




























































































  98 void InspectorCanvas::canvasChanged()
  99 {
<span class="line-modified"> 100     if (!m_context.callTracingActive())</span>



 101         return;
 102 
 103     // Since 2D contexts are able to be fully reproduced in the frontend, we don&#39;t need snapshots.
<span class="line-modified"> 104     if (is&lt;CanvasRenderingContext2D&gt;(m_context))</span>
 105         return;
 106 
 107     m_contentChanged = true;
 108 }
 109 
 110 void InspectorCanvas::resetRecordingData()
 111 {
 112     m_initialState = nullptr;
 113     m_frames = nullptr;
 114     m_currentActions = nullptr;
 115     m_serializedDuplicateData = nullptr;
 116     m_indexedDuplicateData.clear();
 117     m_recordingName = { };
 118     m_bufferLimit = 100 * 1024 * 1024;
 119     m_bufferUsed = 0;
 120     m_frameCount = WTF::nullopt;
 121     m_framesCaptured = 0;
 122     m_contentChanged = false;
 123 
<span class="line-modified"> 124     m_context.setCallTracingActive(false);</span>




 125 }
 126 
 127 bool InspectorCanvas::hasRecordingData() const
 128 {
 129     return m_bufferUsed &gt; 0;
 130 }
 131 
 132 bool InspectorCanvas::currentFrameHasData() const
 133 {
 134     return !!m_frames;
 135 }
 136 
 137 static bool shouldSnapshotBitmapRendererAction(const String&amp; name)
 138 {
 139     return name == &quot;transferFromImageBitmap&quot;;
 140 }
 141 
 142 #if ENABLE(WEBGL)
 143 static bool shouldSnapshotWebGLAction(const String&amp; name)
 144 {
</pre>
<hr />
<pre>
 174 
 175     if (!m_currentActions) {
 176         m_currentActions = JSON::ArrayOf&lt;JSON::Value&gt;::create();
 177 
 178         auto frame = Inspector::Protocol::Recording::Frame::create()
 179             .setActions(m_currentActions)
 180             .release();
 181 
 182         m_frames-&gt;addItem(WTFMove(frame));
 183         ++m_framesCaptured;
 184 
 185         m_currentFrameStartTime = MonotonicTime::now();
 186     }
 187 
 188     appendActionSnapshotIfNeeded();
 189 
 190     m_lastRecordedAction = buildAction(name, WTFMove(parameters));
 191     m_bufferUsed += m_lastRecordedAction-&gt;memoryCost();
 192     m_currentActions-&gt;addItem(m_lastRecordedAction.get());
 193 
<span class="line-modified"> 194     if (is&lt;ImageBitmapRenderingContext&gt;(m_context) &amp;&amp; shouldSnapshotBitmapRendererAction(name))</span>




 195         m_contentChanged = true;
 196 #if ENABLE(WEBGL)
<span class="line-modified"> 197     else if (is&lt;WebGLRenderingContext&gt;(m_context) &amp;&amp; shouldSnapshotWebGLAction(name))</span>
 198         m_contentChanged = true;
 199 #endif
 200 #if ENABLE(WEBGL2)
<span class="line-modified"> 201     else if (is&lt;WebGL2RenderingContext&gt;(m_context) &amp;&amp; shouldSnapshotWebGL2Action(name))</span>
 202         m_contentChanged = true;
 203 #endif
 204 }
 205 
 206 void InspectorCanvas::finalizeFrame()
 207 {
 208     appendActionSnapshotIfNeeded();
 209 
 210     if (m_frames &amp;&amp; m_frames-&gt;length() &amp;&amp; !std::isnan(m_currentFrameStartTime)) {
 211         auto currentFrame = static_cast&lt;Inspector::Protocol::Recording::Frame*&gt;(m_frames-&gt;get(m_frames-&gt;length() - 1).get());
 212         currentFrame-&gt;setDuration((MonotonicTime::now() - m_currentFrameStartTime).milliseconds());
 213 
 214         m_currentFrameStartTime = MonotonicTime::nan();
 215     }
 216 
 217     m_currentActions = nullptr;
 218 }
 219 
 220 void InspectorCanvas::markCurrentFrameIncomplete()
 221 {
</pre>
<hr />
<pre>
 233 bool InspectorCanvas::hasBufferSpace() const
 234 {
 235     return m_bufferUsed &lt; m_bufferLimit;
 236 }
 237 
 238 void InspectorCanvas::setFrameCount(long frameCount)
 239 {
 240     if (frameCount &gt; 0)
 241         m_frameCount = std::min&lt;long&gt;(frameCount, std::numeric_limits&lt;int&gt;::max());
 242     else
 243         m_frameCount = WTF::nullopt;
 244 }
 245 
 246 bool InspectorCanvas::overFrameCount() const
 247 {
 248     return m_frameCount &amp;&amp; m_framesCaptured &gt;= m_frameCount.value();
 249 }
 250 
 251 Ref&lt;Inspector::Protocol::Canvas::Canvas&gt; InspectorCanvas::buildObjectForCanvas(bool captureBacktrace)
 252 {
<span class="line-modified"> 253     Inspector::Protocol::Canvas::ContextType contextType;</span>
<span class="line-modified"> 254     if (is&lt;CanvasRenderingContext2D&gt;(m_context))</span>
<span class="line-modified"> 255         contextType = Inspector::Protocol::Canvas::ContextType::Canvas2D;</span>
<span class="line-modified"> 256     else if (is&lt;ImageBitmapRenderingContext&gt;(m_context))</span>
<span class="line-modified"> 257         contextType = Inspector::Protocol::Canvas::ContextType::BitmapRenderer;</span>



 258 #if ENABLE(WEBGL)
<span class="line-modified"> 259     else if (is&lt;WebGLRenderingContext&gt;(m_context))</span>
<span class="line-modified"> 260         contextType = Inspector::Protocol::Canvas::ContextType::WebGL;</span>
 261 #endif
 262 #if ENABLE(WEBGL2)
<span class="line-modified"> 263     else if (is&lt;WebGL2RenderingContext&gt;(m_context))</span>
<span class="line-modified"> 264         contextType = Inspector::Protocol::Canvas::ContextType::WebGL2;</span>
 265 #endif


 266 #if ENABLE(WEBGPU)
<span class="line-modified"> 267     else if (is&lt;GPUCanvasContext&gt;(m_context))</span>
<span class="line-modified"> 268         contextType = Inspector::Protocol::Canvas::ContextType::WebGPU;</span>

 269 #endif
<span class="line-modified"> 270     else {</span>





 271         ASSERT_NOT_REACHED();
 272         contextType = Inspector::Protocol::Canvas::ContextType::Canvas2D;
 273     }
 274 
 275     auto canvas = Inspector::Protocol::Canvas::Canvas::create()
 276         .setCanvasId(m_identifier)
<span class="line-modified"> 277         .setContextType(contextType)</span>
 278         .release();
 279 
 280     if (auto* node = canvasElement()) {
 281         String cssCanvasName = node-&gt;document().nameForCSSCanvasElement(*node);
 282         if (!cssCanvasName.isEmpty())
 283             canvas-&gt;setCssCanvasName(cssCanvasName);
 284 
 285         // FIXME: &lt;https://webkit.org/b/178282&gt; Web Inspector: send a DOM node with each Canvas payload and eliminate Canvas.requestNode
 286     }
 287 
<span class="line-modified"> 288     if (is&lt;ImageBitmapRenderingContext&gt;(m_context)) {</span>
<span class="line-modified"> 289         auto contextAttributes = Inspector::Protocol::Canvas::ContextAttributes::create()</span>
<span class="line-modified"> 290             .release();</span>
<span class="line-modified"> 291         contextAttributes-&gt;setAlpha(downcast&lt;ImageBitmapRenderingContext&gt;(m_context).hasAlpha());</span>
<span class="line-modified"> 292         canvas-&gt;setContextAttributes(WTFMove(contextAttributes));</span>
<span class="line-modified"> 293     }</span>





 294 #if ENABLE(WEBGL)
<span class="line-modified"> 295     else if (is&lt;WebGLRenderingContextBase&gt;(m_context)) {</span>
<span class="line-modified"> 296         if (Optional&lt;WebGLContextAttributes&gt; attributes = downcast&lt;WebGLRenderingContextBase&gt;(m_context).getContextAttributes()) {</span>
<span class="line-modified"> 297             auto contextAttributes = Inspector::Protocol::Canvas::ContextAttributes::create()</span>
<span class="line-modified"> 298                 .release();</span>
<span class="line-modified"> 299             contextAttributes-&gt;setAlpha(attributes-&gt;alpha);</span>
<span class="line-modified"> 300             contextAttributes-&gt;setDepth(attributes-&gt;depth);</span>
<span class="line-modified"> 301             contextAttributes-&gt;setStencil(attributes-&gt;stencil);</span>
<span class="line-modified"> 302             contextAttributes-&gt;setAntialias(attributes-&gt;antialias);</span>
<span class="line-modified"> 303             contextAttributes-&gt;setPremultipliedAlpha(attributes-&gt;premultipliedAlpha);</span>
<span class="line-modified"> 304             contextAttributes-&gt;setPreserveDrawingBuffer(attributes-&gt;preserveDrawingBuffer);</span>
<span class="line-modified"> 305             contextAttributes-&gt;setFailIfMajorPerformanceCaveat(attributes-&gt;failIfMajorPerformanceCaveat);</span>
<span class="line-modified"> 306             canvas-&gt;setContextAttributes(WTFMove(contextAttributes));</span>
<span class="line-modified"> 307         }</span>
<span class="line-modified"> 308     }</span>











 309 #endif































 310 
 311     // FIXME: &lt;https://webkit.org/b/180833&gt; Web Inspector: support OffscreenCanvas for Canvas related operations
 312 
 313     if (auto* node = canvasElement()) {
 314         if (size_t memoryCost = node-&gt;memoryCost())
 315             canvas-&gt;setMemoryCost(memoryCost);
 316     }
 317 
 318     if (captureBacktrace) {
 319         auto stackTrace = Inspector::createScriptCallStack(JSExecState::currentState(), Inspector::ScriptCallStack::maxCallStackSizeToCapture);
 320         canvas-&gt;setBacktrace(stackTrace-&gt;buildInspectorArray());
 321     }
 322 
 323     return canvas;
 324 }
 325 
 326 Ref&lt;Inspector::Protocol::Recording::Recording&gt; InspectorCanvas::releaseObjectForRecording()
 327 {
 328     ASSERT(!m_currentActions);
 329     ASSERT(!m_lastRecordedAction);
 330     ASSERT(!m_frames);
 331 




 332     Inspector::Protocol::Recording::Type type;
<span class="line-modified"> 333     if (is&lt;CanvasRenderingContext2D&gt;(m_context))</span>
 334         type = Inspector::Protocol::Recording::Type::Canvas2D;
<span class="line-modified"> 335     else if (is&lt;ImageBitmapRenderingContext&gt;(m_context))</span>
 336         type = Inspector::Protocol::Recording::Type::CanvasBitmapRenderer;
 337 #if ENABLE(WEBGL)
<span class="line-modified"> 338     else if (is&lt;WebGLRenderingContext&gt;(m_context))</span>
 339         type = Inspector::Protocol::Recording::Type::CanvasWebGL;
 340 #endif
 341 #if ENABLE(WEBGL2)
<span class="line-modified"> 342     else if (is&lt;WebGL2RenderingContext&gt;(m_context))</span>
 343         type = Inspector::Protocol::Recording::Type::CanvasWebGL2;
 344 #endif
 345     else {
 346         ASSERT_NOT_REACHED();
 347         type = Inspector::Protocol::Recording::Type::Canvas2D;
 348     }
 349 
 350     auto recording = Inspector::Protocol::Recording::Recording::create()
 351         .setVersion(Inspector::Protocol::Recording::VERSION)
 352         .setType(type)
 353         .setInitialState(m_initialState.releaseNonNull())
 354         .setData(m_serializedDuplicateData.releaseNonNull())
 355         .release();
 356 
 357     if (!m_recordingName.isEmpty())
 358         recording-&gt;setName(m_recordingName);
 359 
 360     resetRecordingData();
 361 
 362     return recording;
 363 }
 364 
 365 String InspectorCanvas::getCanvasContentAsDataURL(ErrorString&amp; errorString)
 366 {
<span class="line-removed"> 367     // FIXME: &lt;https://webkit.org/b/173621&gt; Web Inspector: Support getting the content of WebMetal context;</span>
<span class="line-removed"> 368     if (!is&lt;CanvasRenderingContext2D&gt;(m_context)</span>
<span class="line-removed"> 369 #if ENABLE(WEBGL)</span>
<span class="line-removed"> 370         &amp;&amp; !is&lt;WebGLRenderingContextBase&gt;(m_context)</span>
<span class="line-removed"> 371 #endif</span>
<span class="line-removed"> 372         &amp;&amp; !is&lt;ImageBitmapRenderingContext&gt;(m_context)) {</span>
<span class="line-removed"> 373         errorString = &quot;Unsupported canvas context type&quot;_s;</span>
<span class="line-removed"> 374         return emptyString();</span>
<span class="line-removed"> 375     }</span>
<span class="line-removed"> 376 </span>
<span class="line-removed"> 377     // FIXME: &lt;https://webkit.org/b/180833&gt; Web Inspector: support OffscreenCanvas for Canvas related operations</span>
 378     auto* node = canvasElement();
 379     if (!node) {
<span class="line-modified"> 380         errorString = &quot;Context isn&#39;t related to an HTMLCanvasElement&quot;_s;</span>
 381         return emptyString();
 382     }
 383 
 384 #if ENABLE(WEBGL)
<span class="line-modified"> 385     if (is&lt;WebGLRenderingContextBase&gt;(m_context))</span>
<span class="line-modified"> 386         downcast&lt;WebGLRenderingContextBase&gt;(m_context).setPreventBufferClearForInspector(true);</span>

 387 #endif
 388 
 389     ExceptionOr&lt;UncachedString&gt; result = node-&gt;toDataURL(&quot;image/png&quot;_s);
 390 
 391 #if ENABLE(WEBGL)
<span class="line-modified"> 392     if (is&lt;WebGLRenderingContextBase&gt;(m_context))</span>
<span class="line-modified"> 393         downcast&lt;WebGLRenderingContextBase&gt;(m_context).setPreventBufferClearForInspector(false);</span>
 394 #endif
 395 
 396     if (result.hasException()) {
 397         errorString = result.releaseException().releaseMessage();
 398         return emptyString();
 399     }
 400 
 401     return result.releaseReturnValue().string;
 402 }
 403 
 404 void InspectorCanvas::appendActionSnapshotIfNeeded()
 405 {
 406     if (!m_lastRecordedAction)
 407         return;
 408 
 409     if (m_contentChanged) {
 410         m_bufferUsed -= m_lastRecordedAction-&gt;memoryCost();
 411 
 412         ErrorString ignored;
 413         m_lastRecordedAction-&gt;addItem(indexForData(getCanvasContentAsDataURL(ignored)));
</pre>
<hr />
<pre>
 499             if (auto* cachedImage = cssImageValue-&gt;image()) {
 500                 auto* image = cachedImage-&gt;image();
 501                 if (image &amp;&amp; image != &amp;Image::nullImage()) {
 502                     auto imageBuffer = ImageBuffer::create(image-&gt;size(), RenderingMode::Unaccelerated);
 503                     imageBuffer-&gt;context().drawImage(*image, FloatPoint(0, 0));
 504                     dataURL = imageBuffer-&gt;toDataURL(&quot;image/png&quot;);
 505                 }
 506             }
 507 
 508             index = indexForData(dataURL);
 509         },
 510 #endif
 511         [&amp;] (const ScriptCallFrame&amp; scriptCallFrame) {
 512             auto array = JSON::ArrayOf&lt;double&gt;::create();
 513             array-&gt;addItem(indexForData(scriptCallFrame.functionName()));
 514             array-&gt;addItem(indexForData(scriptCallFrame.sourceURL()));
 515             array-&gt;addItem(static_cast&lt;int&gt;(scriptCallFrame.lineNumber()));
 516             array-&gt;addItem(static_cast&lt;int&gt;(scriptCallFrame.columnNumber()));
 517             item = WTFMove(array);
 518         },












 519         [&amp;] (const String&amp; value) { item = JSON::Value::create(value); }
 520     );
 521 
 522     if (item) {
 523         m_bufferUsed += item-&gt;memoryCost();
 524         m_serializedDuplicateData-&gt;addItem(WTFMove(item));
 525 
 526         m_indexedDuplicateData.append(data);
 527         index = m_indexedDuplicateData.size() - 1;
 528     }
 529 
 530     ASSERT(index &lt; static_cast&lt;size_t&gt;(std::numeric_limits&lt;int&gt;::max()));
 531     return static_cast&lt;int&gt;(index);
 532 }
 533 
 534 String InspectorCanvas::stringIndexForKey(const String&amp; key)
 535 {
 536     return String::number(indexForData(key));
 537 }
 538 
</pre>
<hr />
<pre>
 541     auto array = JSON::ArrayOf&lt;double&gt;::create();
 542     array-&gt;addItem(affineTransform.a());
 543     array-&gt;addItem(affineTransform.b());
 544     array-&gt;addItem(affineTransform.c());
 545     array-&gt;addItem(affineTransform.d());
 546     array-&gt;addItem(affineTransform.e());
 547     array-&gt;addItem(affineTransform.f());
 548     return array;
 549 }
 550 
 551 template&lt;typename T&gt; static Ref&lt;JSON::ArrayOf&lt;JSON::Value&gt;&gt; buildArrayForVector(const Vector&lt;T&gt;&amp; vector)
 552 {
 553     auto array = JSON::ArrayOf&lt;JSON::Value&gt;::create();
 554     for (auto&amp; item : vector)
 555         array-&gt;addItem(item);
 556     return array;
 557 }
 558 
 559 Ref&lt;Inspector::Protocol::Recording::InitialState&gt; InspectorCanvas::buildInitialState()
 560 {




 561     auto initialStatePayload = Inspector::Protocol::Recording::InitialState::create().release();
 562 
 563     auto attributesPayload = JSON::Object::create();
<span class="line-modified"> 564     attributesPayload-&gt;setInteger(&quot;width&quot;_s, m_context.canvasBase().width());</span>
<span class="line-modified"> 565     attributesPayload-&gt;setInteger(&quot;height&quot;_s, m_context.canvasBase().height());</span>
 566 
 567     auto statesPayload = JSON::ArrayOf&lt;JSON::Object&gt;::create();
 568 
 569     auto parametersPayload = JSON::ArrayOf&lt;JSON::Value&gt;::create();
 570 
<span class="line-modified"> 571     if (is&lt;CanvasRenderingContext2D&gt;(m_context)) {</span>
<span class="line-modified"> 572         auto&amp; context2d = downcast&lt;CanvasRenderingContext2D&gt;(m_context);</span>
 573         for (auto&amp; state : context2d.stateStack()) {
 574             auto statePayload = JSON::Object::create();
 575 
 576             statePayload-&gt;setArray(stringIndexForKey(&quot;setTransform&quot;_s), buildArrayForAffineTransform(state.transform));
 577             statePayload-&gt;setDouble(stringIndexForKey(&quot;globalAlpha&quot;_s), context2d.globalAlpha());
 578             statePayload-&gt;setInteger(stringIndexForKey(&quot;globalCompositeOperation&quot;_s), indexForData(context2d.globalCompositeOperation()));
 579             statePayload-&gt;setDouble(stringIndexForKey(&quot;lineWidth&quot;_s), context2d.lineWidth());
 580             statePayload-&gt;setInteger(stringIndexForKey(&quot;lineCap&quot;_s), indexForData(convertEnumerationToString(context2d.lineCap())));
 581             statePayload-&gt;setInteger(stringIndexForKey(&quot;lineJoin&quot;_s), indexForData(convertEnumerationToString(context2d.lineJoin())));
 582             statePayload-&gt;setDouble(stringIndexForKey(&quot;miterLimit&quot;_s), context2d.miterLimit());
 583             statePayload-&gt;setDouble(stringIndexForKey(&quot;shadowOffsetX&quot;_s), context2d.shadowOffsetX());
 584             statePayload-&gt;setDouble(stringIndexForKey(&quot;shadowOffsetY&quot;_s), context2d.shadowOffsetY());
 585             statePayload-&gt;setDouble(stringIndexForKey(&quot;shadowBlur&quot;_s), context2d.shadowBlur());
 586             statePayload-&gt;setInteger(stringIndexForKey(&quot;shadowColor&quot;_s), indexForData(context2d.shadowColor()));
 587 
 588             // The parameter to `setLineDash` is itself an array, so we need to wrap the parameters
 589             // list in an array to allow spreading.
 590             auto setLineDash = JSON::ArrayOf&lt;JSON::Value&gt;::create();
 591             setLineDash-&gt;addItem(buildArrayForVector(state.lineDash));
 592             statePayload-&gt;setArray(stringIndexForKey(&quot;setLineDash&quot;_s), WTFMove(setLineDash));
</pre>
<hr />
<pre>
 609             int fillStyleIndex;
 610             if (auto canvasGradient = state.fillStyle.canvasGradient())
 611                 fillStyleIndex = indexForData(canvasGradient);
 612             else if (auto canvasPattern = state.fillStyle.canvasPattern())
 613                 fillStyleIndex = indexForData(canvasPattern);
 614             else
 615                 fillStyleIndex = indexForData(state.fillStyle.color());
 616             statePayload-&gt;setInteger(stringIndexForKey(&quot;fillStyle&quot;_s), fillStyleIndex);
 617 
 618             statePayload-&gt;setBoolean(stringIndexForKey(&quot;imageSmoothingEnabled&quot;_s), context2d.imageSmoothingEnabled());
 619             statePayload-&gt;setInteger(stringIndexForKey(&quot;imageSmoothingQuality&quot;_s), indexForData(convertEnumerationToString(context2d.imageSmoothingQuality())));
 620 
 621             auto setPath = JSON::ArrayOf&lt;JSON::Value&gt;::create();
 622             setPath-&gt;addItem(indexForData(buildStringFromPath(context2d.getPath()-&gt;path())));
 623             statePayload-&gt;setArray(stringIndexForKey(&quot;setPath&quot;_s), WTFMove(setPath));
 624 
 625             statesPayload-&gt;addItem(WTFMove(statePayload));
 626         }
 627     }
 628 #if ENABLE(WEBGL)
<span class="line-modified"> 629     else if (is&lt;WebGLRenderingContextBase&gt;(m_context)) {</span>
<span class="line-modified"> 630         WebGLRenderingContextBase&amp; contextWebGLBase = downcast&lt;WebGLRenderingContextBase&gt;(m_context);</span>
 631         if (Optional&lt;WebGLContextAttributes&gt; webGLContextAttributes = contextWebGLBase.getContextAttributes()) {
 632             auto webGLContextAttributesPayload = JSON::Object::create();
 633             webGLContextAttributesPayload-&gt;setBoolean(&quot;alpha&quot;_s, webGLContextAttributes-&gt;alpha);
 634             webGLContextAttributesPayload-&gt;setBoolean(&quot;depth&quot;_s, webGLContextAttributes-&gt;depth);
 635             webGLContextAttributesPayload-&gt;setBoolean(&quot;stencil&quot;_s, webGLContextAttributes-&gt;stencil);
 636             webGLContextAttributesPayload-&gt;setBoolean(&quot;antialias&quot;_s, webGLContextAttributes-&gt;antialias);
 637             webGLContextAttributesPayload-&gt;setBoolean(&quot;premultipliedAlpha&quot;_s, webGLContextAttributes-&gt;premultipliedAlpha);
 638             webGLContextAttributesPayload-&gt;setBoolean(&quot;preserveDrawingBuffer&quot;_s, webGLContextAttributes-&gt;preserveDrawingBuffer);
 639             webGLContextAttributesPayload-&gt;setBoolean(&quot;failIfMajorPerformanceCaveat&quot;_s, webGLContextAttributes-&gt;failIfMajorPerformanceCaveat);
 640             parametersPayload-&gt;addItem(WTFMove(webGLContextAttributesPayload));
 641         }
 642     }
 643 #endif
 644 
 645     initialStatePayload-&gt;setAttributes(WTFMove(attributesPayload));
 646 
 647     if (statesPayload-&gt;length())
 648         initialStatePayload-&gt;setStates(WTFMove(statesPayload));
 649 
 650     if (parametersPayload-&gt;length())
</pre>
<hr />
<pre>
 771             [&amp;] (const RefPtr&lt;CanvasGradient&gt;&amp; value) {
 772                 if (value)
 773                     addParameter(indexForData(value), RecordingSwizzleTypes::CanvasGradient);
 774             },
 775             [&amp;] (const RefPtr&lt;CanvasPattern&gt;&amp; value) {
 776                 if (value)
 777                     addParameter(indexForData(value), RecordingSwizzleTypes::CanvasPattern);
 778             },
 779             [&amp;] (const RefPtr&lt;Float32Array&gt;&amp; value) {
 780                 if (value)
 781                     addParameter(0, RecordingSwizzleTypes::TypedArray);
 782             },
 783             [&amp;] (const RefPtr&lt;HTMLCanvasElement&gt;&amp; value) {
 784                 if (value)
 785                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);
 786             },
 787             [&amp;] (const RefPtr&lt;HTMLImageElement&gt;&amp; value) {
 788                 if (value)
 789                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);
 790             },






 791 #if ENABLE(VIDEO)
 792             [&amp;] (const RefPtr&lt;HTMLVideoElement&gt;&amp; value) {
 793                 if (value)
 794                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);
 795             },
 796 #endif
 797 #if ENABLE(CSS_TYPED_OM)
 798             [&amp;] (const RefPtr&lt;TypedOMCSSImageValue&gt;&amp; value) {
 799                 if (value)
 800                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);
 801             },
 802 #endif
 803             [&amp;] (const RefPtr&lt;ImageBitmap&gt;&amp; value) {
 804                 if (value)
 805                     addParameter(indexForData(value), RecordingSwizzleTypes::ImageBitmap);
 806             },
 807             [&amp;] (const RefPtr&lt;ImageData&gt;&amp; value) {
 808                 if (value)
 809                     addParameter(indexForData(value), RecordingSwizzleTypes::ImageData);
 810             },
 811             [&amp;] (const RefPtr&lt;Int32Array&gt;&amp; value) {
 812                 if (value)
 813                     addParameter(0, RecordingSwizzleTypes::TypedArray);
 814             },
 815             [&amp;] (const RefPtr&lt;Uint32Array&gt;&amp; value) {
 816                 if (value)
 817                     addParameter(0, RecordingSwizzleTypes::TypedArray);
 818             },
 819             [&amp;] (const CanvasImageSource&amp; value) {
 820                 WTF::visit(parseParameter, value);
 821             },
<span class="line-modified"> 822             [&amp;] (const CanvasRenderingContext2DBase::Style&amp; value) {</span>
 823                 WTF::visit(parseParameter, value);
 824             },
 825 #if ENABLE(WEBGL)
 826             [&amp;] (const WebGLRenderingContextBase::BufferDataSource&amp; value) {
 827                 WTF::visit(parseParameter, value);
 828             },
 829             [&amp;] (const Optional&lt;WebGLRenderingContextBase::BufferDataSource&gt;&amp; value) {
 830                 if (value)
 831                     parseParameter(value.value());
 832             },
 833             [&amp;] (const WebGLRenderingContextBase::TexImageSource&amp; value) {
 834                 WTF::visit(parseParameter, value);
 835             },
 836             [&amp;] (const Optional&lt;WebGLRenderingContextBase::TexImageSource&gt;&amp; value) {
 837                 if (value)
 838                     parseParameter(value.value());
 839             },
 840 #endif
 841             [&amp;] (const Vector&lt;String&gt;&amp; value) {
 842                 auto deduplicated = value.map([&amp;] (const String&amp; item) {
</pre>
</td>
<td>
<hr />
<pre>
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;InspectorCanvas.h&quot;
  28 
  29 #include &quot;AffineTransform.h&quot;
  30 #include &quot;CachedImage.h&quot;
  31 #include &quot;CanvasGradient.h&quot;
  32 #include &quot;CanvasPattern.h&quot;
  33 #include &quot;CanvasRenderingContext.h&quot;
  34 #include &quot;CanvasRenderingContext2D.h&quot;
  35 #include &quot;Document.h&quot;
<span class="line-added">  36 #include &quot;Element.h&quot;</span>
  37 #include &quot;FloatPoint.h&quot;
  38 #include &quot;Gradient.h&quot;
  39 #include &quot;HTMLCanvasElement.h&quot;
  40 #include &quot;HTMLImageElement.h&quot;
  41 #include &quot;HTMLVideoElement.h&quot;
  42 #include &quot;Image.h&quot;
  43 #include &quot;ImageBitmap.h&quot;
  44 #include &quot;ImageBitmapRenderingContext.h&quot;
  45 #include &quot;ImageBuffer.h&quot;
  46 #include &quot;ImageData.h&quot;
  47 #include &quot;InspectorDOMAgent.h&quot;
  48 #include &quot;JSCanvasDirection.h&quot;
  49 #include &quot;JSCanvasFillRule.h&quot;
  50 #include &quot;JSCanvasLineCap.h&quot;
  51 #include &quot;JSCanvasLineJoin.h&quot;
<span class="line-added">  52 #include &quot;JSCanvasRenderingContext2D.h&quot;</span>
  53 #include &quot;JSCanvasTextAlign.h&quot;
  54 #include &quot;JSCanvasTextBaseline.h&quot;
  55 #include &quot;JSExecState.h&quot;
<span class="line-added">  56 #include &quot;JSImageBitmapRenderingContext.h&quot;</span>
  57 #include &quot;JSImageSmoothingQuality.h&quot;
  58 #include &quot;Path2D.h&quot;
  59 #include &quot;Pattern.h&quot;
  60 #include &quot;RecordingSwizzleTypes.h&quot;
  61 #include &quot;SVGPathUtilities.h&quot;
  62 #include &quot;StringAdaptors.h&quot;
<span class="line-added">  63 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;</span>
<span class="line-added">  64 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;</span>
<span class="line-added">  65 #include &lt;wtf/Function.h&gt;</span>
<span class="line-added">  66 </span>
  67 #if ENABLE(CSS_TYPED_OM)
  68 #include &quot;TypedOMCSSImageValue.h&quot;
  69 #endif
<span class="line-added">  70 </span>
  71 #if ENABLE(WEBGL)
<span class="line-added">  72 #include &quot;JSWebGLRenderingContext.h&quot;</span>
  73 #include &quot;WebGLRenderingContext.h&quot;
  74 #endif
<span class="line-added">  75 </span>
  76 #if ENABLE(WEBGL2)
<span class="line-added">  77 #include &quot;JSWebGL2RenderingContext.h&quot;</span>
  78 #include &quot;WebGL2RenderingContext.h&quot;
  79 #endif
<span class="line-added">  80 </span>
  81 #if ENABLE(WEBGPU)
  82 #include &quot;GPUCanvasContext.h&quot;
<span class="line-added">  83 #include &quot;JSWebGPUDevice.h&quot;</span>
<span class="line-added">  84 #include &quot;WebGPUDevice.h&quot;</span>
  85 #endif



  86 
  87 namespace WebCore {
  88 
  89 using namespace Inspector;
  90 
<span class="line-added">  91 #if ENABLE(WEBGPU)</span>
<span class="line-added">  92 static HTMLCanvasElement* canvasIfContextMatchesDevice(CanvasRenderingContext&amp; context, WebGPUDevice&amp; device)</span>
<span class="line-added">  93 {</span>
<span class="line-added">  94     if (is&lt;GPUCanvasContext&gt;(context)) {</span>
<span class="line-added">  95         auto&amp; contextGPU = downcast&lt;GPUCanvasContext&gt;(context);</span>
<span class="line-added">  96         if (auto* webGPUSwapChain = contextGPU.swapChain()) {</span>
<span class="line-added">  97             if (auto* gpuSwapChain = webGPUSwapChain-&gt;swapChain()) {</span>
<span class="line-added">  98                 if (gpuSwapChain == device.device().swapChain()) {</span>
<span class="line-added">  99                     if (is&lt;HTMLCanvasElement&gt;(contextGPU.canvasBase()))</span>
<span class="line-added"> 100                         return &amp;downcast&lt;HTMLCanvasElement&gt;(contextGPU.canvasBase());</span>
<span class="line-added"> 101                 }</span>
<span class="line-added"> 102             }</span>
<span class="line-added"> 103         }</span>
<span class="line-added"> 104     }</span>
<span class="line-added"> 105     return nullptr;</span>
<span class="line-added"> 106 }</span>
<span class="line-added"> 107 #endif</span>
<span class="line-added"> 108 </span>
 109 Ref&lt;InspectorCanvas&gt; InspectorCanvas::create(CanvasRenderingContext&amp; context)
 110 {
 111     return adoptRef(*new InspectorCanvas(context));
 112 }
 113 
<span class="line-added"> 114 #if ENABLE(WEBGPU)</span>
<span class="line-added"> 115 Ref&lt;InspectorCanvas&gt; InspectorCanvas::create(WebGPUDevice&amp; device)</span>
<span class="line-added"> 116 {</span>
<span class="line-added"> 117     return adoptRef(*new InspectorCanvas(device));</span>
<span class="line-added"> 118 }</span>
<span class="line-added"> 119 #endif</span>
<span class="line-added"> 120 </span>
 121 InspectorCanvas::InspectorCanvas(CanvasRenderingContext&amp; context)
 122     : m_identifier(&quot;canvas:&quot; + IdentifiersFactory::createIdentifier())
 123     , m_context(context)
 124 {
<span class="line-added"> 125 #if ENABLE(WEBGPU)</span>
<span class="line-added"> 126     // The actual &quot;context&quot; for WebGPU is the `WebGPUDevice`, not the &lt;canvas&gt;.</span>
<span class="line-added"> 127     ASSERT(!is&lt;GPUCanvasContext&gt;(context));</span>
<span class="line-added"> 128 #endif</span>
<span class="line-added"> 129 }</span>
<span class="line-added"> 130 </span>
<span class="line-added"> 131 #if ENABLE(WEBGPU)</span>
<span class="line-added"> 132 InspectorCanvas::InspectorCanvas(WebGPUDevice&amp; device)</span>
<span class="line-added"> 133     : m_identifier(&quot;canvas:&quot; + IdentifiersFactory::createIdentifier())</span>
<span class="line-added"> 134     , m_context(device)</span>
<span class="line-added"> 135 {</span>
<span class="line-added"> 136 }</span>
<span class="line-added"> 137 #endif</span>
<span class="line-added"> 138 </span>
<span class="line-added"> 139 CanvasRenderingContext* InspectorCanvas::canvasContext() const</span>
<span class="line-added"> 140 {</span>
<span class="line-added"> 141     if (auto* contextWrapper = WTF::get_if&lt;std::reference_wrapper&lt;CanvasRenderingContext&gt;&gt;(m_context))</span>
<span class="line-added"> 142         return &amp;contextWrapper-&gt;get();</span>
<span class="line-added"> 143     return nullptr;</span>
 144 }
 145 
<span class="line-modified"> 146 HTMLCanvasElement* InspectorCanvas::canvasElement() const</span>
 147 {
<span class="line-modified"> 148     return WTF::switchOn(m_context,</span>
<span class="line-modified"> 149         [] (std::reference_wrapper&lt;CanvasRenderingContext&gt; contextWrapper) -&gt; HTMLCanvasElement* {</span>
<span class="line-added"> 150             auto&amp; context = contextWrapper.get();</span>
<span class="line-added"> 151             if (is&lt;HTMLCanvasElement&gt;(context.canvasBase()))</span>
<span class="line-added"> 152                 return &amp;downcast&lt;HTMLCanvasElement&gt;(context.canvasBase());</span>
<span class="line-added"> 153             return nullptr;</span>
<span class="line-added"> 154         },</span>
<span class="line-added"> 155 #if ENABLE(WEBGPU)</span>
<span class="line-added"> 156         [&amp;] (std::reference_wrapper&lt;WebGPUDevice&gt; deviceWrapper) -&gt; HTMLCanvasElement* {</span>
<span class="line-added"> 157             auto&amp; device = deviceWrapper.get();</span>
<span class="line-added"> 158             {</span>
<span class="line-added"> 159                 LockHolder lock(CanvasRenderingContext::instancesMutex());</span>
<span class="line-added"> 160                 for (auto* canvasRenderingContext : CanvasRenderingContext::instances(lock)) {</span>
<span class="line-added"> 161                     if (auto* canvasElement = canvasIfContextMatchesDevice(*canvasRenderingContext, device))</span>
<span class="line-added"> 162                         return canvasElement;</span>
<span class="line-added"> 163                 }</span>
<span class="line-added"> 164             }</span>
<span class="line-added"> 165             return nullptr;</span>
<span class="line-added"> 166         },</span>
<span class="line-added"> 167 #endif</span>
<span class="line-added"> 168         [] (Monostate) {</span>
<span class="line-added"> 169             ASSERT_NOT_REACHED();</span>
<span class="line-added"> 170             return nullptr;</span>
<span class="line-added"> 171         }</span>
<span class="line-added"> 172     );</span>
<span class="line-added"> 173     return nullptr;</span>
<span class="line-added"> 174 }</span>
<span class="line-added"> 175 </span>
<span class="line-added"> 176 #if ENABLE(WEBGPU)</span>
<span class="line-added"> 177 WebGPUDevice* InspectorCanvas::deviceContext() const</span>
<span class="line-added"> 178 {</span>
<span class="line-added"> 179     if (auto* deviceWrapper = WTF::get_if&lt;std::reference_wrapper&lt;WebGPUDevice&gt;&gt;(m_context))</span>
<span class="line-added"> 180         return &amp;deviceWrapper-&gt;get();</span>
 181     return nullptr;
 182 }
 183 
<span class="line-added"> 184 bool InspectorCanvas::isDeviceForCanvasContext(CanvasRenderingContext&amp; context) const</span>
<span class="line-added"> 185 {</span>
<span class="line-added"> 186     if (auto* device = deviceContext())</span>
<span class="line-added"> 187         return canvasIfContextMatchesDevice(context, *device);</span>
<span class="line-added"> 188     return false;</span>
<span class="line-added"> 189 }</span>
<span class="line-added"> 190 #endif</span>
<span class="line-added"> 191 </span>
<span class="line-added"> 192 ScriptExecutionContext* InspectorCanvas::scriptExecutionContext() const</span>
<span class="line-added"> 193 {</span>
<span class="line-added"> 194     return WTF::switchOn(m_context,</span>
<span class="line-added"> 195         [] (std::reference_wrapper&lt;CanvasRenderingContext&gt; contextWrapper) {</span>
<span class="line-added"> 196             auto&amp; context = contextWrapper.get();</span>
<span class="line-added"> 197             return context.canvasBase().scriptExecutionContext();</span>
<span class="line-added"> 198         },</span>
<span class="line-added"> 199 #if ENABLE(WEBGPU)</span>
<span class="line-added"> 200         [] (std::reference_wrapper&lt;WebGPUDevice&gt; deviceWrapper) {</span>
<span class="line-added"> 201             auto&amp; device = deviceWrapper.get();</span>
<span class="line-added"> 202             return device.scriptExecutionContext();</span>
<span class="line-added"> 203         },</span>
<span class="line-added"> 204 #endif</span>
<span class="line-added"> 205         [] (Monostate) {</span>
<span class="line-added"> 206             ASSERT_NOT_REACHED();</span>
<span class="line-added"> 207             return nullptr;</span>
<span class="line-added"> 208         }</span>
<span class="line-added"> 209     );</span>
<span class="line-added"> 210 }</span>
<span class="line-added"> 211 </span>
<span class="line-added"> 212 JSC::JSValue InspectorCanvas::resolveContext(JSC::JSGlobalObject* exec) const</span>
<span class="line-added"> 213 {</span>
<span class="line-added"> 214     JSC::JSLockHolder lock(exec);</span>
<span class="line-added"> 215 </span>
<span class="line-added"> 216     auto* globalObject = deprecatedGlobalObjectForPrototype(exec);</span>
<span class="line-added"> 217 </span>
<span class="line-added"> 218     return WTF::switchOn(m_context,</span>
<span class="line-added"> 219         [&amp;] (std::reference_wrapper&lt;CanvasRenderingContext&gt; contextWrapper) {</span>
<span class="line-added"> 220             auto&amp; context = contextWrapper.get();</span>
<span class="line-added"> 221             if (is&lt;CanvasRenderingContext2D&gt;(context))</span>
<span class="line-added"> 222                 return toJS(exec, globalObject, downcast&lt;CanvasRenderingContext2D&gt;(context));</span>
<span class="line-added"> 223             if (is&lt;ImageBitmapRenderingContext&gt;(context))</span>
<span class="line-added"> 224                 return toJS(exec, globalObject, downcast&lt;ImageBitmapRenderingContext&gt;(context));</span>
<span class="line-added"> 225 #if ENABLE(WEBGL)</span>
<span class="line-added"> 226             if (is&lt;WebGLRenderingContext&gt;(context))</span>
<span class="line-added"> 227                 return toJS(exec, globalObject, downcast&lt;WebGLRenderingContext&gt;(context));</span>
<span class="line-added"> 228 #endif</span>
<span class="line-added"> 229 #if ENABLE(WEBGL2)</span>
<span class="line-added"> 230             if (is&lt;WebGL2RenderingContext&gt;(context))</span>
<span class="line-added"> 231                 return toJS(exec, globalObject, downcast&lt;WebGL2RenderingContext&gt;(context));</span>
<span class="line-added"> 232 #endif</span>
<span class="line-added"> 233             return JSC::JSValue();</span>
<span class="line-added"> 234         },</span>
<span class="line-added"> 235 #if ENABLE(WEBGPU)</span>
<span class="line-added"> 236         [&amp;] (std::reference_wrapper&lt;WebGPUDevice&gt; deviceWrapper) {</span>
<span class="line-added"> 237             return toJS(exec, globalObject, deviceWrapper.get());</span>
<span class="line-added"> 238         },</span>
<span class="line-added"> 239 #endif</span>
<span class="line-added"> 240         [] (Monostate) {</span>
<span class="line-added"> 241             ASSERT_NOT_REACHED();</span>
<span class="line-added"> 242             return JSC::JSValue();</span>
<span class="line-added"> 243         }</span>
<span class="line-added"> 244     );</span>
<span class="line-added"> 245 }</span>
<span class="line-added"> 246 </span>
<span class="line-added"> 247 HashSet&lt;Element*&gt; InspectorCanvas::clientNodes() const</span>
<span class="line-added"> 248 {</span>
<span class="line-added"> 249     return WTF::switchOn(m_context,</span>
<span class="line-added"> 250         [] (std::reference_wrapper&lt;CanvasRenderingContext&gt; contextWrapper) {</span>
<span class="line-added"> 251             auto&amp; context = contextWrapper.get();</span>
<span class="line-added"> 252             return context.canvasBase().cssCanvasClients();</span>
<span class="line-added"> 253         },</span>
<span class="line-added"> 254 #if ENABLE(WEBGPU)</span>
<span class="line-added"> 255         [&amp;] (std::reference_wrapper&lt;WebGPUDevice&gt; deviceWrapper) {</span>
<span class="line-added"> 256             auto&amp; device = deviceWrapper.get();</span>
<span class="line-added"> 257 </span>
<span class="line-added"> 258             HashSet&lt;Element*&gt; canvasElementClients;</span>
<span class="line-added"> 259             {</span>
<span class="line-added"> 260                 LockHolder lock(CanvasRenderingContext::instancesMutex());</span>
<span class="line-added"> 261                 for (auto* canvasRenderingContext : CanvasRenderingContext::instances(lock)) {</span>
<span class="line-added"> 262                     if (auto* canvasElement = canvasIfContextMatchesDevice(*canvasRenderingContext, device))</span>
<span class="line-added"> 263                         canvasElementClients.add(canvasElement);</span>
<span class="line-added"> 264                 }</span>
<span class="line-added"> 265             }</span>
<span class="line-added"> 266             return canvasElementClients;</span>
<span class="line-added"> 267         },</span>
<span class="line-added"> 268 #endif</span>
<span class="line-added"> 269         [] (Monostate) {</span>
<span class="line-added"> 270             ASSERT_NOT_REACHED();</span>
<span class="line-added"> 271             return HashSet&lt;Element*&gt;();</span>
<span class="line-added"> 272         }</span>
<span class="line-added"> 273     );</span>
<span class="line-added"> 274 }</span>
<span class="line-added"> 275 </span>
 276 void InspectorCanvas::canvasChanged()
 277 {
<span class="line-modified"> 278     auto* context = canvasContext();</span>
<span class="line-added"> 279     ASSERT(context);</span>
<span class="line-added"> 280 </span>
<span class="line-added"> 281     if (!context-&gt;callTracingActive())</span>
 282         return;
 283 
 284     // Since 2D contexts are able to be fully reproduced in the frontend, we don&#39;t need snapshots.
<span class="line-modified"> 285     if (is&lt;CanvasRenderingContext2D&gt;(context))</span>
 286         return;
 287 
 288     m_contentChanged = true;
 289 }
 290 
 291 void InspectorCanvas::resetRecordingData()
 292 {
 293     m_initialState = nullptr;
 294     m_frames = nullptr;
 295     m_currentActions = nullptr;
 296     m_serializedDuplicateData = nullptr;
 297     m_indexedDuplicateData.clear();
 298     m_recordingName = { };
 299     m_bufferLimit = 100 * 1024 * 1024;
 300     m_bufferUsed = 0;
 301     m_frameCount = WTF::nullopt;
 302     m_framesCaptured = 0;
 303     m_contentChanged = false;
 304 
<span class="line-modified"> 305     auto* context = canvasContext();</span>
<span class="line-added"> 306     ASSERT(context);</span>
<span class="line-added"> 307     // FIXME: &lt;https://webkit.org/b/201651&gt; Web Inspector: Canvas: support canvas recordings for WebGPUDevice</span>
<span class="line-added"> 308 </span>
<span class="line-added"> 309     context-&gt;setCallTracingActive(false);</span>
 310 }
 311 
 312 bool InspectorCanvas::hasRecordingData() const
 313 {
 314     return m_bufferUsed &gt; 0;
 315 }
 316 
 317 bool InspectorCanvas::currentFrameHasData() const
 318 {
 319     return !!m_frames;
 320 }
 321 
 322 static bool shouldSnapshotBitmapRendererAction(const String&amp; name)
 323 {
 324     return name == &quot;transferFromImageBitmap&quot;;
 325 }
 326 
 327 #if ENABLE(WEBGL)
 328 static bool shouldSnapshotWebGLAction(const String&amp; name)
 329 {
</pre>
<hr />
<pre>
 359 
 360     if (!m_currentActions) {
 361         m_currentActions = JSON::ArrayOf&lt;JSON::Value&gt;::create();
 362 
 363         auto frame = Inspector::Protocol::Recording::Frame::create()
 364             .setActions(m_currentActions)
 365             .release();
 366 
 367         m_frames-&gt;addItem(WTFMove(frame));
 368         ++m_framesCaptured;
 369 
 370         m_currentFrameStartTime = MonotonicTime::now();
 371     }
 372 
 373     appendActionSnapshotIfNeeded();
 374 
 375     m_lastRecordedAction = buildAction(name, WTFMove(parameters));
 376     m_bufferUsed += m_lastRecordedAction-&gt;memoryCost();
 377     m_currentActions-&gt;addItem(m_lastRecordedAction.get());
 378 
<span class="line-modified"> 379     auto* context = canvasContext();</span>
<span class="line-added"> 380     ASSERT(context);</span>
<span class="line-added"> 381     // FIXME: &lt;https://webkit.org/b/201651&gt; Web Inspector: Canvas: support canvas recordings for WebGPUDevice</span>
<span class="line-added"> 382 </span>
<span class="line-added"> 383     if (is&lt;ImageBitmapRenderingContext&gt;(context) &amp;&amp; shouldSnapshotBitmapRendererAction(name))</span>
 384         m_contentChanged = true;
 385 #if ENABLE(WEBGL)
<span class="line-modified"> 386     else if (is&lt;WebGLRenderingContext&gt;(context) &amp;&amp; shouldSnapshotWebGLAction(name))</span>
 387         m_contentChanged = true;
 388 #endif
 389 #if ENABLE(WEBGL2)
<span class="line-modified"> 390     else if (is&lt;WebGL2RenderingContext&gt;(context) &amp;&amp; shouldSnapshotWebGL2Action(name))</span>
 391         m_contentChanged = true;
 392 #endif
 393 }
 394 
 395 void InspectorCanvas::finalizeFrame()
 396 {
 397     appendActionSnapshotIfNeeded();
 398 
 399     if (m_frames &amp;&amp; m_frames-&gt;length() &amp;&amp; !std::isnan(m_currentFrameStartTime)) {
 400         auto currentFrame = static_cast&lt;Inspector::Protocol::Recording::Frame*&gt;(m_frames-&gt;get(m_frames-&gt;length() - 1).get());
 401         currentFrame-&gt;setDuration((MonotonicTime::now() - m_currentFrameStartTime).milliseconds());
 402 
 403         m_currentFrameStartTime = MonotonicTime::nan();
 404     }
 405 
 406     m_currentActions = nullptr;
 407 }
 408 
 409 void InspectorCanvas::markCurrentFrameIncomplete()
 410 {
</pre>
<hr />
<pre>
 422 bool InspectorCanvas::hasBufferSpace() const
 423 {
 424     return m_bufferUsed &lt; m_bufferLimit;
 425 }
 426 
 427 void InspectorCanvas::setFrameCount(long frameCount)
 428 {
 429     if (frameCount &gt; 0)
 430         m_frameCount = std::min&lt;long&gt;(frameCount, std::numeric_limits&lt;int&gt;::max());
 431     else
 432         m_frameCount = WTF::nullopt;
 433 }
 434 
 435 bool InspectorCanvas::overFrameCount() const
 436 {
 437     return m_frameCount &amp;&amp; m_framesCaptured &gt;= m_frameCount.value();
 438 }
 439 
 440 Ref&lt;Inspector::Protocol::Canvas::Canvas&gt; InspectorCanvas::buildObjectForCanvas(bool captureBacktrace)
 441 {
<span class="line-modified"> 442     using ContextTypeType = Optional&lt;Inspector::Protocol::Canvas::ContextType&gt;;</span>
<span class="line-modified"> 443     auto contextType = WTF::switchOn(m_context,</span>
<span class="line-modified"> 444         [] (std::reference_wrapper&lt;CanvasRenderingContext&gt; contextWrapper) -&gt; ContextTypeType {</span>
<span class="line-modified"> 445             auto&amp; context = contextWrapper.get();</span>
<span class="line-modified"> 446             if (is&lt;CanvasRenderingContext2D&gt;(context))</span>
<span class="line-added"> 447                 return Inspector::Protocol::Canvas::ContextType::Canvas2D;</span>
<span class="line-added"> 448             if (is&lt;ImageBitmapRenderingContext&gt;(context))</span>
<span class="line-added"> 449                 return Inspector::Protocol::Canvas::ContextType::BitmapRenderer;</span>
 450 #if ENABLE(WEBGL)
<span class="line-modified"> 451             if (is&lt;WebGLRenderingContext&gt;(context))</span>
<span class="line-modified"> 452                 return Inspector::Protocol::Canvas::ContextType::WebGL;</span>
 453 #endif
 454 #if ENABLE(WEBGL2)
<span class="line-modified"> 455             if (is&lt;WebGL2RenderingContext&gt;(context))</span>
<span class="line-modified"> 456                 return Inspector::Protocol::Canvas::ContextType::WebGL2;</span>
 457 #endif
<span class="line-added"> 458             return WTF::nullopt;</span>
<span class="line-added"> 459         },</span>
 460 #if ENABLE(WEBGPU)
<span class="line-modified"> 461         [] (std::reference_wrapper&lt;WebGPUDevice&gt;) {</span>
<span class="line-modified"> 462             return Inspector::Protocol::Canvas::ContextType::WebGPU;</span>
<span class="line-added"> 463         },</span>
 464 #endif
<span class="line-modified"> 465         [] (Monostate) {</span>
<span class="line-added"> 466             ASSERT_NOT_REACHED();</span>
<span class="line-added"> 467             return WTF::nullopt;</span>
<span class="line-added"> 468         }</span>
<span class="line-added"> 469     );</span>
<span class="line-added"> 470     if (!contextType) {</span>
 471         ASSERT_NOT_REACHED();
 472         contextType = Inspector::Protocol::Canvas::ContextType::Canvas2D;
 473     }
 474 
 475     auto canvas = Inspector::Protocol::Canvas::Canvas::create()
 476         .setCanvasId(m_identifier)
<span class="line-modified"> 477         .setContextType(contextType.value())</span>
 478         .release();
 479 
 480     if (auto* node = canvasElement()) {
 481         String cssCanvasName = node-&gt;document().nameForCSSCanvasElement(*node);
 482         if (!cssCanvasName.isEmpty())
 483             canvas-&gt;setCssCanvasName(cssCanvasName);
 484 
 485         // FIXME: &lt;https://webkit.org/b/178282&gt; Web Inspector: send a DOM node with each Canvas payload and eliminate Canvas.requestNode
 486     }
 487 
<span class="line-modified"> 488     using ContextAttributesType = RefPtr&lt;Inspector::Protocol::Canvas::ContextAttributes&gt;;</span>
<span class="line-modified"> 489     auto contextAttributes = WTF::switchOn(m_context,</span>
<span class="line-modified"> 490         [] (std::reference_wrapper&lt;CanvasRenderingContext&gt; contextWrapper) -&gt; ContextAttributesType {</span>
<span class="line-modified"> 491             auto&amp; context = contextWrapper.get();</span>
<span class="line-modified"> 492             if (is&lt;ImageBitmapRenderingContext&gt;(context)) {</span>
<span class="line-modified"> 493                 auto contextAttributesPayload = Inspector::Protocol::Canvas::ContextAttributes::create()</span>
<span class="line-added"> 494                     .release();</span>
<span class="line-added"> 495                 contextAttributesPayload-&gt;setAlpha(downcast&lt;ImageBitmapRenderingContext&gt;(context).hasAlpha());</span>
<span class="line-added"> 496                 return contextAttributesPayload;</span>
<span class="line-added"> 497             }</span>
<span class="line-added"> 498 </span>
 499 #if ENABLE(WEBGL)
<span class="line-modified"> 500             if (is&lt;WebGLRenderingContextBase&gt;(context)) {</span>
<span class="line-modified"> 501                 if (const auto&amp; attributes = downcast&lt;WebGLRenderingContextBase&gt;(context).getContextAttributes()) {</span>
<span class="line-modified"> 502                     auto contextAttributesPayload = Inspector::Protocol::Canvas::ContextAttributes::create()</span>
<span class="line-modified"> 503                         .release();</span>
<span class="line-modified"> 504                     contextAttributesPayload-&gt;setAlpha(attributes-&gt;alpha);</span>
<span class="line-modified"> 505                     contextAttributesPayload-&gt;setDepth(attributes-&gt;depth);</span>
<span class="line-modified"> 506                     contextAttributesPayload-&gt;setStencil(attributes-&gt;stencil);</span>
<span class="line-modified"> 507                     contextAttributesPayload-&gt;setAntialias(attributes-&gt;antialias);</span>
<span class="line-modified"> 508                     contextAttributesPayload-&gt;setPremultipliedAlpha(attributes-&gt;premultipliedAlpha);</span>
<span class="line-modified"> 509                     contextAttributesPayload-&gt;setPreserveDrawingBuffer(attributes-&gt;preserveDrawingBuffer);</span>
<span class="line-modified"> 510                     switch (attributes-&gt;powerPreference) {</span>
<span class="line-modified"> 511                     case WebGLPowerPreference::Default:</span>
<span class="line-modified"> 512                         contextAttributesPayload-&gt;setPowerPreference(&quot;default&quot;);</span>
<span class="line-modified"> 513                         break;</span>
<span class="line-added"> 514                     case WebGLPowerPreference::LowPower:</span>
<span class="line-added"> 515                         contextAttributesPayload-&gt;setPowerPreference(&quot;low-power&quot;);</span>
<span class="line-added"> 516                         break;</span>
<span class="line-added"> 517                     case WebGLPowerPreference::HighPerformance:</span>
<span class="line-added"> 518                         contextAttributesPayload-&gt;setPowerPreference(&quot;high-performance&quot;);</span>
<span class="line-added"> 519                         break;</span>
<span class="line-added"> 520                     }</span>
<span class="line-added"> 521                     contextAttributesPayload-&gt;setFailIfMajorPerformanceCaveat(attributes-&gt;failIfMajorPerformanceCaveat);</span>
<span class="line-added"> 522                     return contextAttributesPayload;</span>
<span class="line-added"> 523                 }</span>
<span class="line-added"> 524             }</span>
 525 #endif
<span class="line-added"> 526             return nullptr;</span>
<span class="line-added"> 527         },</span>
<span class="line-added"> 528 #if ENABLE(WEBGPU)</span>
<span class="line-added"> 529         [] (std::reference_wrapper&lt;WebGPUDevice&gt; deviceWrapper) -&gt; ContextAttributesType {</span>
<span class="line-added"> 530             auto&amp; device = deviceWrapper.get();</span>
<span class="line-added"> 531             if (const auto&amp; options = device.adapter().options()) {</span>
<span class="line-added"> 532                 auto contextAttributesPayload = Inspector::Protocol::Canvas::ContextAttributes::create()</span>
<span class="line-added"> 533                     .release();</span>
<span class="line-added"> 534                 if (const auto&amp; powerPreference = options-&gt;powerPreference) {</span>
<span class="line-added"> 535                     switch (powerPreference.value()) {</span>
<span class="line-added"> 536                     case GPUPowerPreference::LowPower:</span>
<span class="line-added"> 537                         contextAttributesPayload-&gt;setPowerPreference(&quot;low-power&quot;);</span>
<span class="line-added"> 538                         break;</span>
<span class="line-added"> 539 </span>
<span class="line-added"> 540                     case GPUPowerPreference::HighPerformance:</span>
<span class="line-added"> 541                         contextAttributesPayload-&gt;setPowerPreference(&quot;high-performance&quot;);</span>
<span class="line-added"> 542                         break;</span>
<span class="line-added"> 543                     }</span>
<span class="line-added"> 544                 }</span>
<span class="line-added"> 545                 return WTFMove(contextAttributesPayload);</span>
<span class="line-added"> 546             }</span>
<span class="line-added"> 547             return nullptr;</span>
<span class="line-added"> 548         },</span>
<span class="line-added"> 549 #endif</span>
<span class="line-added"> 550         [] (Monostate) {</span>
<span class="line-added"> 551             ASSERT_NOT_REACHED();</span>
<span class="line-added"> 552             return nullptr;</span>
<span class="line-added"> 553         }</span>
<span class="line-added"> 554     );</span>
<span class="line-added"> 555     if (contextAttributes)</span>
<span class="line-added"> 556         canvas-&gt;setContextAttributes(WTFMove(contextAttributes));</span>
 557 
 558     // FIXME: &lt;https://webkit.org/b/180833&gt; Web Inspector: support OffscreenCanvas for Canvas related operations
 559 
 560     if (auto* node = canvasElement()) {
 561         if (size_t memoryCost = node-&gt;memoryCost())
 562             canvas-&gt;setMemoryCost(memoryCost);
 563     }
 564 
 565     if (captureBacktrace) {
 566         auto stackTrace = Inspector::createScriptCallStack(JSExecState::currentState(), Inspector::ScriptCallStack::maxCallStackSizeToCapture);
 567         canvas-&gt;setBacktrace(stackTrace-&gt;buildInspectorArray());
 568     }
 569 
 570     return canvas;
 571 }
 572 
 573 Ref&lt;Inspector::Protocol::Recording::Recording&gt; InspectorCanvas::releaseObjectForRecording()
 574 {
 575     ASSERT(!m_currentActions);
 576     ASSERT(!m_lastRecordedAction);
 577     ASSERT(!m_frames);
 578 
<span class="line-added"> 579     auto* context = canvasContext();</span>
<span class="line-added"> 580     ASSERT(context);</span>
<span class="line-added"> 581     // FIXME: &lt;https://webkit.org/b/201651&gt; Web Inspector: Canvas: support canvas recordings for WebGPUDevice</span>
<span class="line-added"> 582 </span>
 583     Inspector::Protocol::Recording::Type type;
<span class="line-modified"> 584     if (is&lt;CanvasRenderingContext2D&gt;(context))</span>
 585         type = Inspector::Protocol::Recording::Type::Canvas2D;
<span class="line-modified"> 586     else if (is&lt;ImageBitmapRenderingContext&gt;(context))</span>
 587         type = Inspector::Protocol::Recording::Type::CanvasBitmapRenderer;
 588 #if ENABLE(WEBGL)
<span class="line-modified"> 589     else if (is&lt;WebGLRenderingContext&gt;(context))</span>
 590         type = Inspector::Protocol::Recording::Type::CanvasWebGL;
 591 #endif
 592 #if ENABLE(WEBGL2)
<span class="line-modified"> 593     else if (is&lt;WebGL2RenderingContext&gt;(context))</span>
 594         type = Inspector::Protocol::Recording::Type::CanvasWebGL2;
 595 #endif
 596     else {
 597         ASSERT_NOT_REACHED();
 598         type = Inspector::Protocol::Recording::Type::Canvas2D;
 599     }
 600 
 601     auto recording = Inspector::Protocol::Recording::Recording::create()
 602         .setVersion(Inspector::Protocol::Recording::VERSION)
 603         .setType(type)
 604         .setInitialState(m_initialState.releaseNonNull())
 605         .setData(m_serializedDuplicateData.releaseNonNull())
 606         .release();
 607 
 608     if (!m_recordingName.isEmpty())
 609         recording-&gt;setName(m_recordingName);
 610 
 611     resetRecordingData();
 612 
 613     return recording;
 614 }
 615 
 616 String InspectorCanvas::getCanvasContentAsDataURL(ErrorString&amp; errorString)
 617 {











 618     auto* node = canvasElement();
 619     if (!node) {
<span class="line-modified"> 620         errorString = &quot;Missing HTMLCanvasElement of canvas for given canvasId&quot;_s;</span>
 621         return emptyString();
 622     }
 623 
 624 #if ENABLE(WEBGL)
<span class="line-modified"> 625     auto* context = node-&gt;renderingContext();</span>
<span class="line-modified"> 626     if (is&lt;WebGLRenderingContextBase&gt;(context))</span>
<span class="line-added"> 627         downcast&lt;WebGLRenderingContextBase&gt;(*context).setPreventBufferClearForInspector(true);</span>
 628 #endif
 629 
 630     ExceptionOr&lt;UncachedString&gt; result = node-&gt;toDataURL(&quot;image/png&quot;_s);
 631 
 632 #if ENABLE(WEBGL)
<span class="line-modified"> 633     if (is&lt;WebGLRenderingContextBase&gt;(context))</span>
<span class="line-modified"> 634         downcast&lt;WebGLRenderingContextBase&gt;(*context).setPreventBufferClearForInspector(false);</span>
 635 #endif
 636 
 637     if (result.hasException()) {
 638         errorString = result.releaseException().releaseMessage();
 639         return emptyString();
 640     }
 641 
 642     return result.releaseReturnValue().string;
 643 }
 644 
 645 void InspectorCanvas::appendActionSnapshotIfNeeded()
 646 {
 647     if (!m_lastRecordedAction)
 648         return;
 649 
 650     if (m_contentChanged) {
 651         m_bufferUsed -= m_lastRecordedAction-&gt;memoryCost();
 652 
 653         ErrorString ignored;
 654         m_lastRecordedAction-&gt;addItem(indexForData(getCanvasContentAsDataURL(ignored)));
</pre>
<hr />
<pre>
 740             if (auto* cachedImage = cssImageValue-&gt;image()) {
 741                 auto* image = cachedImage-&gt;image();
 742                 if (image &amp;&amp; image != &amp;Image::nullImage()) {
 743                     auto imageBuffer = ImageBuffer::create(image-&gt;size(), RenderingMode::Unaccelerated);
 744                     imageBuffer-&gt;context().drawImage(*image, FloatPoint(0, 0));
 745                     dataURL = imageBuffer-&gt;toDataURL(&quot;image/png&quot;);
 746                 }
 747             }
 748 
 749             index = indexForData(dataURL);
 750         },
 751 #endif
 752         [&amp;] (const ScriptCallFrame&amp; scriptCallFrame) {
 753             auto array = JSON::ArrayOf&lt;double&gt;::create();
 754             array-&gt;addItem(indexForData(scriptCallFrame.functionName()));
 755             array-&gt;addItem(indexForData(scriptCallFrame.sourceURL()));
 756             array-&gt;addItem(static_cast&lt;int&gt;(scriptCallFrame.lineNumber()));
 757             array-&gt;addItem(static_cast&lt;int&gt;(scriptCallFrame.columnNumber()));
 758             item = WTFMove(array);
 759         },
<span class="line-added"> 760 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added"> 761         [&amp;] (const RefPtr&lt;OffscreenCanvas&gt; offscreenCanvas) {</span>
<span class="line-added"> 762             String dataURL = &quot;data:,&quot;_s;</span>
<span class="line-added"> 763 </span>
<span class="line-added"> 764             if (offscreenCanvas-&gt;originClean() &amp;&amp; offscreenCanvas-&gt;hasCreatedImageBuffer()) {</span>
<span class="line-added"> 765                 if (auto *buffer = offscreenCanvas-&gt;buffer())</span>
<span class="line-added"> 766                     dataURL = buffer-&gt;toDataURL(&quot;image/png&quot;);</span>
<span class="line-added"> 767             }</span>
<span class="line-added"> 768 </span>
<span class="line-added"> 769             index = indexForData(dataURL);</span>
<span class="line-added"> 770         },</span>
<span class="line-added"> 771 #endif</span>
 772         [&amp;] (const String&amp; value) { item = JSON::Value::create(value); }
 773     );
 774 
 775     if (item) {
 776         m_bufferUsed += item-&gt;memoryCost();
 777         m_serializedDuplicateData-&gt;addItem(WTFMove(item));
 778 
 779         m_indexedDuplicateData.append(data);
 780         index = m_indexedDuplicateData.size() - 1;
 781     }
 782 
 783     ASSERT(index &lt; static_cast&lt;size_t&gt;(std::numeric_limits&lt;int&gt;::max()));
 784     return static_cast&lt;int&gt;(index);
 785 }
 786 
 787 String InspectorCanvas::stringIndexForKey(const String&amp; key)
 788 {
 789     return String::number(indexForData(key));
 790 }
 791 
</pre>
<hr />
<pre>
 794     auto array = JSON::ArrayOf&lt;double&gt;::create();
 795     array-&gt;addItem(affineTransform.a());
 796     array-&gt;addItem(affineTransform.b());
 797     array-&gt;addItem(affineTransform.c());
 798     array-&gt;addItem(affineTransform.d());
 799     array-&gt;addItem(affineTransform.e());
 800     array-&gt;addItem(affineTransform.f());
 801     return array;
 802 }
 803 
 804 template&lt;typename T&gt; static Ref&lt;JSON::ArrayOf&lt;JSON::Value&gt;&gt; buildArrayForVector(const Vector&lt;T&gt;&amp; vector)
 805 {
 806     auto array = JSON::ArrayOf&lt;JSON::Value&gt;::create();
 807     for (auto&amp; item : vector)
 808         array-&gt;addItem(item);
 809     return array;
 810 }
 811 
 812 Ref&lt;Inspector::Protocol::Recording::InitialState&gt; InspectorCanvas::buildInitialState()
 813 {
<span class="line-added"> 814     auto* context = canvasContext();</span>
<span class="line-added"> 815     ASSERT(context);</span>
<span class="line-added"> 816     // FIXME: &lt;https://webkit.org/b/201651&gt; Web Inspector: Canvas: support canvas recordings for WebGPUDevice</span>
<span class="line-added"> 817 </span>
 818     auto initialStatePayload = Inspector::Protocol::Recording::InitialState::create().release();
 819 
 820     auto attributesPayload = JSON::Object::create();
<span class="line-modified"> 821     attributesPayload-&gt;setInteger(&quot;width&quot;_s, context-&gt;canvasBase().width());</span>
<span class="line-modified"> 822     attributesPayload-&gt;setInteger(&quot;height&quot;_s, context-&gt;canvasBase().height());</span>
 823 
 824     auto statesPayload = JSON::ArrayOf&lt;JSON::Object&gt;::create();
 825 
 826     auto parametersPayload = JSON::ArrayOf&lt;JSON::Value&gt;::create();
 827 
<span class="line-modified"> 828     if (is&lt;CanvasRenderingContext2D&gt;(context)) {</span>
<span class="line-modified"> 829         auto&amp; context2d = downcast&lt;CanvasRenderingContext2D&gt;(*context);</span>
 830         for (auto&amp; state : context2d.stateStack()) {
 831             auto statePayload = JSON::Object::create();
 832 
 833             statePayload-&gt;setArray(stringIndexForKey(&quot;setTransform&quot;_s), buildArrayForAffineTransform(state.transform));
 834             statePayload-&gt;setDouble(stringIndexForKey(&quot;globalAlpha&quot;_s), context2d.globalAlpha());
 835             statePayload-&gt;setInteger(stringIndexForKey(&quot;globalCompositeOperation&quot;_s), indexForData(context2d.globalCompositeOperation()));
 836             statePayload-&gt;setDouble(stringIndexForKey(&quot;lineWidth&quot;_s), context2d.lineWidth());
 837             statePayload-&gt;setInteger(stringIndexForKey(&quot;lineCap&quot;_s), indexForData(convertEnumerationToString(context2d.lineCap())));
 838             statePayload-&gt;setInteger(stringIndexForKey(&quot;lineJoin&quot;_s), indexForData(convertEnumerationToString(context2d.lineJoin())));
 839             statePayload-&gt;setDouble(stringIndexForKey(&quot;miterLimit&quot;_s), context2d.miterLimit());
 840             statePayload-&gt;setDouble(stringIndexForKey(&quot;shadowOffsetX&quot;_s), context2d.shadowOffsetX());
 841             statePayload-&gt;setDouble(stringIndexForKey(&quot;shadowOffsetY&quot;_s), context2d.shadowOffsetY());
 842             statePayload-&gt;setDouble(stringIndexForKey(&quot;shadowBlur&quot;_s), context2d.shadowBlur());
 843             statePayload-&gt;setInteger(stringIndexForKey(&quot;shadowColor&quot;_s), indexForData(context2d.shadowColor()));
 844 
 845             // The parameter to `setLineDash` is itself an array, so we need to wrap the parameters
 846             // list in an array to allow spreading.
 847             auto setLineDash = JSON::ArrayOf&lt;JSON::Value&gt;::create();
 848             setLineDash-&gt;addItem(buildArrayForVector(state.lineDash));
 849             statePayload-&gt;setArray(stringIndexForKey(&quot;setLineDash&quot;_s), WTFMove(setLineDash));
</pre>
<hr />
<pre>
 866             int fillStyleIndex;
 867             if (auto canvasGradient = state.fillStyle.canvasGradient())
 868                 fillStyleIndex = indexForData(canvasGradient);
 869             else if (auto canvasPattern = state.fillStyle.canvasPattern())
 870                 fillStyleIndex = indexForData(canvasPattern);
 871             else
 872                 fillStyleIndex = indexForData(state.fillStyle.color());
 873             statePayload-&gt;setInteger(stringIndexForKey(&quot;fillStyle&quot;_s), fillStyleIndex);
 874 
 875             statePayload-&gt;setBoolean(stringIndexForKey(&quot;imageSmoothingEnabled&quot;_s), context2d.imageSmoothingEnabled());
 876             statePayload-&gt;setInteger(stringIndexForKey(&quot;imageSmoothingQuality&quot;_s), indexForData(convertEnumerationToString(context2d.imageSmoothingQuality())));
 877 
 878             auto setPath = JSON::ArrayOf&lt;JSON::Value&gt;::create();
 879             setPath-&gt;addItem(indexForData(buildStringFromPath(context2d.getPath()-&gt;path())));
 880             statePayload-&gt;setArray(stringIndexForKey(&quot;setPath&quot;_s), WTFMove(setPath));
 881 
 882             statesPayload-&gt;addItem(WTFMove(statePayload));
 883         }
 884     }
 885 #if ENABLE(WEBGL)
<span class="line-modified"> 886     else if (is&lt;WebGLRenderingContextBase&gt;(context)) {</span>
<span class="line-modified"> 887         auto&amp; contextWebGLBase = downcast&lt;WebGLRenderingContextBase&gt;(*context);</span>
 888         if (Optional&lt;WebGLContextAttributes&gt; webGLContextAttributes = contextWebGLBase.getContextAttributes()) {
 889             auto webGLContextAttributesPayload = JSON::Object::create();
 890             webGLContextAttributesPayload-&gt;setBoolean(&quot;alpha&quot;_s, webGLContextAttributes-&gt;alpha);
 891             webGLContextAttributesPayload-&gt;setBoolean(&quot;depth&quot;_s, webGLContextAttributes-&gt;depth);
 892             webGLContextAttributesPayload-&gt;setBoolean(&quot;stencil&quot;_s, webGLContextAttributes-&gt;stencil);
 893             webGLContextAttributesPayload-&gt;setBoolean(&quot;antialias&quot;_s, webGLContextAttributes-&gt;antialias);
 894             webGLContextAttributesPayload-&gt;setBoolean(&quot;premultipliedAlpha&quot;_s, webGLContextAttributes-&gt;premultipliedAlpha);
 895             webGLContextAttributesPayload-&gt;setBoolean(&quot;preserveDrawingBuffer&quot;_s, webGLContextAttributes-&gt;preserveDrawingBuffer);
 896             webGLContextAttributesPayload-&gt;setBoolean(&quot;failIfMajorPerformanceCaveat&quot;_s, webGLContextAttributes-&gt;failIfMajorPerformanceCaveat);
 897             parametersPayload-&gt;addItem(WTFMove(webGLContextAttributesPayload));
 898         }
 899     }
 900 #endif
 901 
 902     initialStatePayload-&gt;setAttributes(WTFMove(attributesPayload));
 903 
 904     if (statesPayload-&gt;length())
 905         initialStatePayload-&gt;setStates(WTFMove(statesPayload));
 906 
 907     if (parametersPayload-&gt;length())
</pre>
<hr />
<pre>
1028             [&amp;] (const RefPtr&lt;CanvasGradient&gt;&amp; value) {
1029                 if (value)
1030                     addParameter(indexForData(value), RecordingSwizzleTypes::CanvasGradient);
1031             },
1032             [&amp;] (const RefPtr&lt;CanvasPattern&gt;&amp; value) {
1033                 if (value)
1034                     addParameter(indexForData(value), RecordingSwizzleTypes::CanvasPattern);
1035             },
1036             [&amp;] (const RefPtr&lt;Float32Array&gt;&amp; value) {
1037                 if (value)
1038                     addParameter(0, RecordingSwizzleTypes::TypedArray);
1039             },
1040             [&amp;] (const RefPtr&lt;HTMLCanvasElement&gt;&amp; value) {
1041                 if (value)
1042                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);
1043             },
1044             [&amp;] (const RefPtr&lt;HTMLImageElement&gt;&amp; value) {
1045                 if (value)
1046                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);
1047             },
<span class="line-added">1048 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">1049             [&amp;] (const RefPtr&lt;OffscreenCanvas&gt;&amp; value) {</span>
<span class="line-added">1050                 if (value)</span>
<span class="line-added">1051                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);</span>
<span class="line-added">1052             },</span>
<span class="line-added">1053 #endif</span>
1054 #if ENABLE(VIDEO)
1055             [&amp;] (const RefPtr&lt;HTMLVideoElement&gt;&amp; value) {
1056                 if (value)
1057                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);
1058             },
1059 #endif
1060 #if ENABLE(CSS_TYPED_OM)
1061             [&amp;] (const RefPtr&lt;TypedOMCSSImageValue&gt;&amp; value) {
1062                 if (value)
1063                     addParameter(indexForData(value), RecordingSwizzleTypes::Image);
1064             },
1065 #endif
1066             [&amp;] (const RefPtr&lt;ImageBitmap&gt;&amp; value) {
1067                 if (value)
1068                     addParameter(indexForData(value), RecordingSwizzleTypes::ImageBitmap);
1069             },
1070             [&amp;] (const RefPtr&lt;ImageData&gt;&amp; value) {
1071                 if (value)
1072                     addParameter(indexForData(value), RecordingSwizzleTypes::ImageData);
1073             },
1074             [&amp;] (const RefPtr&lt;Int32Array&gt;&amp; value) {
1075                 if (value)
1076                     addParameter(0, RecordingSwizzleTypes::TypedArray);
1077             },
1078             [&amp;] (const RefPtr&lt;Uint32Array&gt;&amp; value) {
1079                 if (value)
1080                     addParameter(0, RecordingSwizzleTypes::TypedArray);
1081             },
1082             [&amp;] (const CanvasImageSource&amp; value) {
1083                 WTF::visit(parseParameter, value);
1084             },
<span class="line-modified">1085             [&amp;] (const CanvasRenderingContext2DBase::StyleVariant&amp; value) {</span>
1086                 WTF::visit(parseParameter, value);
1087             },
1088 #if ENABLE(WEBGL)
1089             [&amp;] (const WebGLRenderingContextBase::BufferDataSource&amp; value) {
1090                 WTF::visit(parseParameter, value);
1091             },
1092             [&amp;] (const Optional&lt;WebGLRenderingContextBase::BufferDataSource&gt;&amp; value) {
1093                 if (value)
1094                     parseParameter(value.value());
1095             },
1096             [&amp;] (const WebGLRenderingContextBase::TexImageSource&amp; value) {
1097                 WTF::visit(parseParameter, value);
1098             },
1099             [&amp;] (const Optional&lt;WebGLRenderingContextBase::TexImageSource&gt;&amp; value) {
1100                 if (value)
1101                     parseParameter(value.value());
1102             },
1103 #endif
1104             [&amp;] (const Vector&lt;String&gt;&amp; value) {
1105                 auto deduplicated = value.map([&amp;] (const String&amp; item) {
</pre>
</td>
</tr>
</table>
<center><a href="InspectorAuditAccessibilityObject.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InspectorCanvas.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
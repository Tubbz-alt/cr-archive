<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOSRAvailabilityAnalysisPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2013-2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGOSRAvailabilityAnalysisPhase.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;DFGBasicBlockInlines.h&quot;
 32 #include &quot;DFGGraph.h&quot;
 33 #include &quot;DFGInsertionSet.h&quot;
 34 #include &quot;DFGPhase.h&quot;
 35 #include &quot;JSCInlines.h&quot;
 36 
 37 namespace JSC { namespace DFG {
 38 
 39 class OSRAvailabilityAnalysisPhase : public Phase {
 40     static constexpr bool verbose = false;
 41 public:
 42     OSRAvailabilityAnalysisPhase(Graph&amp; graph)
 43         : Phase(graph, &quot;OSR availability analysis&quot;)
 44     {
 45     }
 46 
 47     bool run()
 48     {
 49         ASSERT(m_graph.m_form == SSA);
 50 
 51         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
 52             BasicBlock* block = m_graph.block(blockIndex);
 53             if (!block)
 54                 continue;
 55             block-&gt;ssa-&gt;availabilityAtHead.clear();
 56             block-&gt;ssa-&gt;availabilityAtTail.clear();
 57         }
 58 
 59         BasicBlock* root = m_graph.block(0);
 60         root-&gt;ssa-&gt;availabilityAtHead.m_locals.fill(Availability::unavailable());
 61 
 62         for (unsigned argument = 0; argument &lt; m_graph.block(0)-&gt;valuesAtHead.numberOfArguments(); ++argument)
 63             root-&gt;ssa-&gt;availabilityAtHead.m_locals.argument(argument) = Availability::unavailable();
 64 
 65         // This could be made more efficient by processing blocks in reverse postorder.
 66 
 67         auto dumpAvailability = [] (BasicBlock* block) {
 68             dataLogLn(block-&gt;ssa-&gt;availabilityAtHead);
 69             dataLogLn(block-&gt;ssa-&gt;availabilityAtTail);
 70         };
 71 
 72         auto dumpBytecodeLivenessAtHead = [&amp;] (BasicBlock* block) {
 73             dataLog(&quot;Live: &quot;);
 74             m_graph.forAllLiveInBytecode(
 75                 block-&gt;at(0)-&gt;origin.forExit,
 76                 [&amp;] (Operand operand) {
 77                     dataLog(operand, &quot; &quot;);
 78                 });
 79             dataLogLn(&quot;&quot;);
 80         };
 81 
 82         LocalOSRAvailabilityCalculator calculator(m_graph);
 83         bool changed;
 84         do {
 85             changed = false;
 86 
 87             for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
 88                 BasicBlock* block = m_graph.block(blockIndex);
 89                 if (!block)
 90                     continue;
 91 
 92                 if (verbose) {
 93                     dataLogLn(&quot;Before changing Block #&quot;, block-&gt;index);
 94                     dumpAvailability(block);
 95                 }
 96                 calculator.beginBlock(block);
 97 
 98                 for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex)
 99                     calculator.executeNode(block-&gt;at(nodeIndex));
100 
101                 if (calculator.m_availability == block-&gt;ssa-&gt;availabilityAtTail)
102                     continue;
103 
104                 block-&gt;ssa-&gt;availabilityAtTail = calculator.m_availability;
105                 changed = true;
106 
107                 if (verbose) {
108                     dataLogLn(&quot;After changing Block #&quot;, block-&gt;index);
109                     dumpAvailability(block);
110                 }
111 
112                 for (unsigned successorIndex = block-&gt;numSuccessors(); successorIndex--;) {
113                     BasicBlock* successor = block-&gt;successor(successorIndex);
114                     successor-&gt;ssa-&gt;availabilityAtHead.merge(calculator.m_availability);
115                 }
116 
117                 for (unsigned successorIndex = block-&gt;numSuccessors(); successorIndex--;) {
118                     BasicBlock* successor = block-&gt;successor(successorIndex);
119                     successor-&gt;ssa-&gt;availabilityAtHead.pruneByLiveness(
120                         m_graph, successor-&gt;at(0)-&gt;origin.forExit);
121                     if (verbose) {
122                         dataLogLn(&quot;After pruning Block #&quot;, successor-&gt;index);
123                         dumpAvailability(successor);
124                         dumpBytecodeLivenessAtHead(successor);
125                     }
126                 }
127             }
128         } while (changed);
129 
130         if (validationEnabled()) {
131 
132             for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
133                 BasicBlock* block = m_graph.block(blockIndex);
134                 if (!block)
135                     continue;
136 
137                 calculator.beginBlock(block);
138 
139                 for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
140                     if (block-&gt;at(nodeIndex)-&gt;origin.exitOK) {
141                         // If we&#39;re allowed to exit here, the heap must be in a state
142                         // where exiting wouldn&#39;t crash. These particular fields are
143                         // required for correctness because we use them during OSR exit
144                         // to do meaningful things. It would be wrong for any of them
145                         // to be dead.
146 
147                         AvailabilityMap availabilityMap = calculator.m_availability;
148                         availabilityMap.pruneByLiveness(m_graph, block-&gt;at(nodeIndex)-&gt;origin.forExit);
149 
150                         for (auto heapPair : availabilityMap.m_heap) {
151                             switch (heapPair.key.kind()) {
152                             case ActivationScopePLoc:
153                             case ActivationSymbolTablePLoc:
154                             case FunctionActivationPLoc:
155                             case FunctionExecutablePLoc:
156                             case StructurePLoc:
157                                 if (heapPair.value.isDead()) {
158                                     dataLogLn(&quot;PromotedHeapLocation is dead, but should not be: &quot;, heapPair.key);
159                                     availabilityMap.dump(WTF::dataFile());
160                                     CRASH();
161                                 }
162                                 break;
163 
164                             default:
165                                 break;
166                             }
167                         }
168                     }
169 
170                     calculator.executeNode(block-&gt;at(nodeIndex));
171                 }
172             }
173         }
174 
175         return true;
176     }
177 
178 };
179 
180 bool performOSRAvailabilityAnalysis(Graph&amp; graph)
181 {
182     return runPhase&lt;OSRAvailabilityAnalysisPhase&gt;(graph);
183 }
184 
185 LocalOSRAvailabilityCalculator::LocalOSRAvailabilityCalculator(Graph&amp; graph)
186     : m_graph(graph)
187 {
188 }
189 
190 LocalOSRAvailabilityCalculator::~LocalOSRAvailabilityCalculator()
191 {
192 }
193 
194 void LocalOSRAvailabilityCalculator::beginBlock(BasicBlock* block)
195 {
196     m_availability = block-&gt;ssa-&gt;availabilityAtHead;
197 }
198 
199 void LocalOSRAvailabilityCalculator::endBlock(BasicBlock* block)
200 {
201     m_availability = block-&gt;ssa-&gt;availabilityAtTail;
202 }
203 
204 void LocalOSRAvailabilityCalculator::executeNode(Node* node)
205 {
206     switch (node-&gt;op()) {
207     case PutStack: {
208         StackAccessData* data = node-&gt;stackAccessData();
209         m_availability.m_locals.operand(data-&gt;operand).setFlush(data-&gt;flushedAt());
210         break;
211     }
212 
213     case KillStack: {
214         m_availability.m_locals.operand(node-&gt;unlinkedOperand()).setFlush(FlushedAt(ConflictingFlush));
215         break;
216     }
217 
218     case GetStack: {
219         StackAccessData* data = node-&gt;stackAccessData();
220         m_availability.m_locals.operand(data-&gt;operand) = Availability(node, data-&gt;flushedAt());
221         break;
222     }
223 
224     case MovHint: {
225         m_availability.m_locals.operand(node-&gt;unlinkedOperand()).setNode(node-&gt;child1().node());
226         break;
227     }
228 
229     case ZombieHint: {
230         m_availability.m_locals.operand(node-&gt;unlinkedOperand()).setNodeUnavailable();
231         break;
232     }
233 
234     case InitializeEntrypointArguments: {
235         unsigned entrypointIndex = node-&gt;entrypointIndex();
236         const Vector&lt;FlushFormat&gt;&amp; argumentFormats = m_graph.m_argumentFormats[entrypointIndex];
237         for (unsigned argument = argumentFormats.size(); argument--; ) {
238             FlushedAt flushedAt = FlushedAt(argumentFormats[argument], virtualRegisterForArgumentIncludingThis(argument));
239             m_availability.m_locals.argument(argument) = Availability(flushedAt);
240         }
241         break;
242     }
243 
244     case VarargsLength: {
245         break;
246     }
247 
248     case LoadVarargs:
249     case ForwardVarargs: {
250         LoadVarargsData* data = node-&gt;loadVarargsData();
251         m_availability.m_locals.operand(data-&gt;count) = Availability(FlushedAt(FlushedInt32, data-&gt;machineCount));
252         for (unsigned i = data-&gt;limit; i--;) {
253             m_availability.m_locals.operand(data-&gt;start + i) =
254                 Availability(FlushedAt(FlushedJSValue, data-&gt;machineStart + i));
255         }
256         break;
257     }
258 
259     case PhantomCreateRest:
260     case PhantomDirectArguments:
261     case PhantomClonedArguments: {
262         InlineCallFrame* inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();
263         if (!inlineCallFrame) {
264             // We don&#39;t need to record anything about how the arguments are to be recovered. It&#39;s just a
265             // given that we can read them from the stack.
266             break;
267         }
268 
269         unsigned numberOfArgumentsToSkip = 0;
270         if (node-&gt;op() == PhantomCreateRest)
271             numberOfArgumentsToSkip = node-&gt;numberOfArgumentsToSkip();
272 
273         if (inlineCallFrame-&gt;isVarargs()) {
274             // Record how to read each argument and the argument count.
275             Availability argumentCount =
276                 m_availability.m_locals.operand(VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCountIncludingThis));
277 
278             m_availability.m_heap.set(PromotedHeapLocation(ArgumentCountPLoc, node), argumentCount);
279         }
280 
281         if (inlineCallFrame-&gt;isClosureCall) {
282             Availability callee = m_availability.m_locals.operand(
283                 VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee));
284             m_availability.m_heap.set(PromotedHeapLocation(ArgumentsCalleePLoc, node), callee);
285         }
286 
287         for (unsigned i = numberOfArgumentsToSkip; i &lt; static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1); ++i) {
288             Availability argument = m_availability.m_locals.operand(
289                 VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrame::argumentOffset(i)));
290 
291             m_availability.m_heap.set(PromotedHeapLocation(ArgumentPLoc, node, i), argument);
292         }
293         break;
294     }
295 
296     case PutHint: {
297         m_availability.m_heap.set(
298             PromotedHeapLocation(node-&gt;child1().node(), node-&gt;promotedLocationDescriptor()),
299             Availability(node-&gt;child2().node()));
300         break;
301     }
302 
303     case PhantomSpread:
304         m_availability.m_heap.set(PromotedHeapLocation(SpreadPLoc, node), Availability(node-&gt;child1().node()));
305         break;
306 
307     case PhantomNewArrayWithSpread:
308         for (unsigned i = 0; i &lt; node-&gt;numChildren(); i++) {
309             Node* child = m_graph.varArgChild(node, i).node();
310             m_availability.m_heap.set(PromotedHeapLocation(NewArrayWithSpreadArgumentPLoc, node, i), Availability(child));
311         }
312         break;
313 
314     case PhantomNewArrayBuffer:
315         m_availability.m_heap.set(PromotedHeapLocation(NewArrayBufferPLoc, node), Availability(node-&gt;child1().node()));
316         break;
317 
318     default:
319         break;
320     }
321 }
322 
323 } } // namespace JSC::DFG
324 
325 #endif // ENABLE(DFG_JIT)
326 
    </pre>
  </body>
</html>
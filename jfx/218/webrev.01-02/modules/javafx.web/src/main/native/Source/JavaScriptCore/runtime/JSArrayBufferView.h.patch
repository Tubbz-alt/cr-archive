diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArrayBufferView.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArrayBufferView.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArrayBufferView.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArrayBufferView.h
@@ -93,17 +93,24 @@
 // implementation of those has no need to even exist - we could at any time sink
 // code into JSGenericTypedArrayView if it was convenient.
 
 class JSArrayBufferView : public JSNonFinalObject {
 public:
-    typedef JSNonFinalObject Base;
-    static const unsigned fastSizeLimit = 1000;
+    using Base = JSNonFinalObject;
+
+    template<typename, SubspaceAccess>
+    static void subspaceFor(VM&)
+    {
+        RELEASE_ASSERT_NOT_REACHED();
+    }
+
+    static constexpr unsigned fastSizeLimit = 1000;
     using VectorPtr = CagedBarrierPtr<Gigacage::Primitive, void, tagCagedPtr>;
 
     static size_t sizeOf(uint32_t length, uint32_t elementSize)
     {
-        return (length * elementSize + sizeof(EncodedJSValue) - 1)
+        return (static_cast<size_t>(length) * elementSize + sizeof(EncodedJSValue) - 1)
             & ~(sizeof(EncodedJSValue) - 1);
     }
 
     static size_t allocationSize(Checked<size_t> inlineCapacity)
     {
@@ -150,32 +157,34 @@
     };
 
     JS_EXPORT_PRIVATE JSArrayBufferView(VM&, ConstructionContext&);
     JS_EXPORT_PRIVATE void finishCreation(VM&);
 
-    static bool put(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&);
+    static bool put(JSCell*, JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&);
 
     static void visitChildren(JSCell*, SlotVisitor&);
 
 public:
     TypedArrayMode mode() const { return m_mode; }
     bool hasArrayBuffer() const { return JSC::hasArrayBuffer(mode()); }
 
     bool isShared();
     JS_EXPORT_PRIVATE ArrayBuffer* unsharedBuffer();
-    ArrayBuffer* possiblySharedBuffer();
-    JSArrayBuffer* unsharedJSBuffer(ExecState* exec);
-    JSArrayBuffer* possiblySharedJSBuffer(ExecState* exec);
+    inline ArrayBuffer* possiblySharedBuffer();
+    JSArrayBuffer* unsharedJSBuffer(JSGlobalObject* globalObject);
+    JSArrayBuffer* possiblySharedJSBuffer(JSGlobalObject* globalObject);
     RefPtr<ArrayBufferView> unsharedImpl();
     JS_EXPORT_PRIVATE RefPtr<ArrayBufferView> possiblySharedImpl();
     bool isNeutered() { return hasArrayBuffer() && !hasVector(); }
     void neuter();
 
     bool hasVector() const { return !!m_vector; }
     void* vector() const { return m_vector.getMayBeNull(length()); }
 
-    unsigned byteOffset();
+    inline unsigned byteOffset();
+    inline Optional<unsigned> byteOffsetConcurrently();
+
     unsigned length() const { return m_length; }
 
     DECLARE_EXPORT_INFO;
 
     static ptrdiff_t offsetOfVector() { return OBJECT_OFFSETOF(JSArrayBufferView, m_vector); }
@@ -183,19 +192,23 @@
     static ptrdiff_t offsetOfMode() { return OBJECT_OFFSETOF(JSArrayBufferView, m_mode); }
 
     static RefPtr<ArrayBufferView> toWrapped(VM&, JSValue);
 
 private:
+    enum Requester { Mutator, ConcurrentThread };
+    template<Requester, typename ResultType> ResultType byteOffsetImpl();
+    template<Requester> ArrayBuffer* possiblySharedBufferImpl();
+
     JS_EXPORT_PRIVATE ArrayBuffer* slowDownAndWasteMemory();
     static void finalize(JSCell*);
 
 protected:
     friend class LLIntOffsetsExtractor;
 
     ArrayBuffer* existingBufferInButterfly();
 
-    static String toStringName(const JSObject*, ExecState*);
+    static String toStringName(const JSObject*, JSGlobalObject*);
 
     VectorPtr m_vector;
     uint32_t m_length;
     TypedArrayMode m_mode;
 };

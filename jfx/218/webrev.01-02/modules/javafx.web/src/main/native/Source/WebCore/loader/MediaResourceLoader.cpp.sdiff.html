<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/loader/MediaResourceLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LoaderStrategy.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MixedContentChecker.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/MediaResourceLoader.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 78     // FIXME: Workaround for &lt;rdar://problem/26071607&gt;. We are not able to do CORS checking on 304 responses because they are usually missing the headers we need.
 79     if (!m_crossOriginMode.isNull())
 80         request.makeUnconditional();
 81 #endif
 82 
 83     ContentSecurityPolicyImposition contentSecurityPolicyImposition = m_mediaElement &amp;&amp; m_mediaElement-&gt;isInUserAgentShadowTree() ? ContentSecurityPolicyImposition::SkipPolicyCheck : ContentSecurityPolicyImposition::DoPolicyCheck;
 84     ResourceLoaderOptions loaderOptions {
 85         SendCallbackPolicy::SendCallbacks,
 86         ContentSniffingPolicy::DoNotSniffContent,
 87         bufferingPolicy,
 88         StoredCredentialsPolicy::Use,
 89         ClientCredentialPolicy::MayAskClientForCredentials,
 90         FetchOptions::Credentials::Include,
 91         SecurityCheckPolicy::DoSecurityCheck,
 92         FetchOptions::Mode::NoCors,
 93         CertificateInfoPolicy::DoNotIncludeCertificateInfo,
 94         contentSecurityPolicyImposition,
 95         DefersLoadingPolicy::AllowDefersLoading,
 96         cachingPolicy };
 97     loaderOptions.destination = m_mediaElement &amp;&amp; !m_mediaElement-&gt;isVideo() ? FetchOptions::Destination::Audio : FetchOptions::Destination::Video;
<span class="line-modified"> 98     auto cachedRequest = createPotentialAccessControlRequest(WTFMove(request), *m_document, m_crossOriginMode, WTFMove(loaderOptions));</span>
 99     if (m_mediaElement)
100         cachedRequest.setInitiator(*m_mediaElement);
101 
102     auto resource = m_document-&gt;cachedResourceLoader().requestMedia(WTFMove(cachedRequest)).value_or(nullptr);
103     if (!resource)
104         return nullptr;
105 
106     Ref&lt;MediaResource&gt; mediaResource = MediaResource::create(*this, resource);
107     m_resources.add(mediaResource.ptr());
108 
109     return mediaResource;
110 }
111 
112 void MediaResourceLoader::removeResource(MediaResource&amp; mediaResource)
113 {
114     ASSERT(m_resources.contains(&amp;mediaResource));
115     m_resources.remove(&amp;mediaResource);
116 }
117 
118 void MediaResourceLoader::addResponseForTesting(const ResourceResponse&amp; response)
</pre>
<hr />
<pre>
155 {
156     ASSERT_UNUSED(resource, &amp;resource == m_resource);
157     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(completionHandler));
158 
159     if (!m_loader-&gt;document())
160         return;
161 
162     RefPtr&lt;MediaResource&gt; protectedThis(this);
163     if (m_resource-&gt;resourceError().isAccessControl()) {
164         static NeverDestroyed&lt;const String&gt; consoleMessage(&quot;Cross-origin media resource load denied by Cross-Origin Resource Sharing policy.&quot;);
165         m_loader-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, consoleMessage.get());
166         m_didPassAccessControlCheck = false;
167         if (m_client)
168             m_client-&gt;accessControlCheckFailed(*this, ResourceError(errorDomainWebKitInternal, 0, response.url(), consoleMessage.get()));
169         stop();
170         return;
171     }
172 
173     m_didPassAccessControlCheck = m_resource-&gt;options().mode == FetchOptions::Mode::Cors;
174     if (m_client)
<span class="line-modified">175         m_client-&gt;responseReceived(*this, response, [this, protectedThis = makeRef(*this), completionHandler = completionHandlerCaller.release()] (ShouldContinue shouldContinue) mutable {</span>
176             if (completionHandler)
177                 completionHandler();
<span class="line-modified">178             if (shouldContinue == ShouldContinue::No)</span>
179                 stop();
180         });
181 
182     m_loader-&gt;addResponseForTesting(response);
183 }
184 
185 bool MediaResource::shouldCacheResponse(CachedResource&amp; resource, const ResourceResponse&amp; response)
186 {
187     ASSERT_UNUSED(resource, &amp;resource == m_resource);
188 
189     RefPtr&lt;MediaResource&gt; protectedThis(this);
190     if (m_client)
191         return m_client-&gt;shouldCacheResponse(*this, response);
192     return true;
193 }
194 
195 void MediaResource::redirectReceived(CachedResource&amp; resource, ResourceRequest&amp;&amp; request, const ResourceResponse&amp; response, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler)
196 {
197     ASSERT_UNUSED(resource, &amp;resource == m_resource);
198 
</pre>
</td>
<td>
<hr />
<pre>
 78     // FIXME: Workaround for &lt;rdar://problem/26071607&gt;. We are not able to do CORS checking on 304 responses because they are usually missing the headers we need.
 79     if (!m_crossOriginMode.isNull())
 80         request.makeUnconditional();
 81 #endif
 82 
 83     ContentSecurityPolicyImposition contentSecurityPolicyImposition = m_mediaElement &amp;&amp; m_mediaElement-&gt;isInUserAgentShadowTree() ? ContentSecurityPolicyImposition::SkipPolicyCheck : ContentSecurityPolicyImposition::DoPolicyCheck;
 84     ResourceLoaderOptions loaderOptions {
 85         SendCallbackPolicy::SendCallbacks,
 86         ContentSniffingPolicy::DoNotSniffContent,
 87         bufferingPolicy,
 88         StoredCredentialsPolicy::Use,
 89         ClientCredentialPolicy::MayAskClientForCredentials,
 90         FetchOptions::Credentials::Include,
 91         SecurityCheckPolicy::DoSecurityCheck,
 92         FetchOptions::Mode::NoCors,
 93         CertificateInfoPolicy::DoNotIncludeCertificateInfo,
 94         contentSecurityPolicyImposition,
 95         DefersLoadingPolicy::AllowDefersLoading,
 96         cachingPolicy };
 97     loaderOptions.destination = m_mediaElement &amp;&amp; !m_mediaElement-&gt;isVideo() ? FetchOptions::Destination::Audio : FetchOptions::Destination::Video;
<span class="line-modified"> 98     auto cachedRequest = createPotentialAccessControlRequest(WTFMove(request), WTFMove(loaderOptions), *m_document, m_crossOriginMode);</span>
 99     if (m_mediaElement)
100         cachedRequest.setInitiator(*m_mediaElement);
101 
102     auto resource = m_document-&gt;cachedResourceLoader().requestMedia(WTFMove(cachedRequest)).value_or(nullptr);
103     if (!resource)
104         return nullptr;
105 
106     Ref&lt;MediaResource&gt; mediaResource = MediaResource::create(*this, resource);
107     m_resources.add(mediaResource.ptr());
108 
109     return mediaResource;
110 }
111 
112 void MediaResourceLoader::removeResource(MediaResource&amp; mediaResource)
113 {
114     ASSERT(m_resources.contains(&amp;mediaResource));
115     m_resources.remove(&amp;mediaResource);
116 }
117 
118 void MediaResourceLoader::addResponseForTesting(const ResourceResponse&amp; response)
</pre>
<hr />
<pre>
155 {
156     ASSERT_UNUSED(resource, &amp;resource == m_resource);
157     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(completionHandler));
158 
159     if (!m_loader-&gt;document())
160         return;
161 
162     RefPtr&lt;MediaResource&gt; protectedThis(this);
163     if (m_resource-&gt;resourceError().isAccessControl()) {
164         static NeverDestroyed&lt;const String&gt; consoleMessage(&quot;Cross-origin media resource load denied by Cross-Origin Resource Sharing policy.&quot;);
165         m_loader-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, consoleMessage.get());
166         m_didPassAccessControlCheck = false;
167         if (m_client)
168             m_client-&gt;accessControlCheckFailed(*this, ResourceError(errorDomainWebKitInternal, 0, response.url(), consoleMessage.get()));
169         stop();
170         return;
171     }
172 
173     m_didPassAccessControlCheck = m_resource-&gt;options().mode == FetchOptions::Mode::Cors;
174     if (m_client)
<span class="line-modified">175         m_client-&gt;responseReceived(*this, response, [this, protectedThis = makeRef(*this), completionHandler = completionHandlerCaller.release()] (auto shouldContinue) mutable {</span>
176             if (completionHandler)
177                 completionHandler();
<span class="line-modified">178             if (shouldContinue == PolicyChecker::ShouldContinue::No)</span>
179                 stop();
180         });
181 
182     m_loader-&gt;addResponseForTesting(response);
183 }
184 
185 bool MediaResource::shouldCacheResponse(CachedResource&amp; resource, const ResourceResponse&amp; response)
186 {
187     ASSERT_UNUSED(resource, &amp;resource == m_resource);
188 
189     RefPtr&lt;MediaResource&gt; protectedThis(this);
190     if (m_client)
191         return m_client-&gt;shouldCacheResponse(*this, response);
192     return true;
193 }
194 
195 void MediaResource::redirectReceived(CachedResource&amp; resource, ResourceRequest&amp;&amp; request, const ResourceResponse&amp; response, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler)
196 {
197     ASSERT_UNUSED(resource, &amp;resource == m_resource);
198 
</pre>
</td>
</tr>
</table>
<center><a href="LoaderStrategy.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MixedContentChecker.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
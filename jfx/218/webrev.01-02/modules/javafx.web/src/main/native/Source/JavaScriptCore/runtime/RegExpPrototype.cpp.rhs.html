<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/RegExpPrototype.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2003-2019 Apple Inc. All Rights Reserved.
  4  *
  5  *  This library is free software; you can redistribute it and/or
  6  *  modify it under the terms of the GNU Lesser General Public
  7  *  License as published by the Free Software Foundation; either
  8  *  version 2 of the License, or (at your option) any later version.
  9  *
 10  *  This library is distributed in the hope that it will be useful,
 11  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  *  Lesser General Public License for more details.
 14  *
 15  *  You should have received a copy of the GNU Lesser General Public
 16  *  License along with this library; if not, write to the Free Software
 17  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 18  *
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;RegExpPrototype.h&quot;
 23 
 24 #include &quot;ArrayPrototype.h&quot;
 25 #include &quot;BuiltinNames.h&quot;
 26 #include &quot;Error.h&quot;
 27 #include &quot;JSArray.h&quot;
 28 #include &quot;JSCBuiltins.h&quot;
 29 #include &quot;JSCInlines.h&quot;
 30 #include &quot;JSCJSValue.h&quot;
 31 #include &quot;JSFunction.h&quot;
 32 #include &quot;JSStringInlines.h&quot;
 33 #include &quot;Lexer.h&quot;
 34 #include &quot;ObjectPrototype.h&quot;
 35 #include &quot;RegExpCache.h&quot;
 36 #include &quot;RegExpObject.h&quot;
 37 #include &quot;RegExpObjectInlines.h&quot;
 38 #include &quot;StringObject.h&quot;
 39 #include &quot;StringRecursionChecker.h&quot;
 40 #include &quot;YarrFlags.h&quot;
 41 #include &lt;wtf/text/StringBuilder.h&gt;
 42 
 43 namespace JSC {
 44 
<a name="1" id="anc1"></a><span class="line-modified"> 45 static EncodedJSValue JSC_HOST_CALL regExpProtoFuncExec(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 46 static EncodedJSValue JSC_HOST_CALL regExpProtoFuncCompile(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 47 static EncodedJSValue JSC_HOST_CALL regExpProtoFuncToString(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 48 static EncodedJSValue JSC_HOST_CALL regExpProtoGetterGlobal(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 49 static EncodedJSValue JSC_HOST_CALL regExpProtoGetterIgnoreCase(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 50 static EncodedJSValue JSC_HOST_CALL regExpProtoGetterMultiline(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 51 static EncodedJSValue JSC_HOST_CALL regExpProtoGetterDotAll(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 52 static EncodedJSValue JSC_HOST_CALL regExpProtoGetterSticky(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 53 static EncodedJSValue JSC_HOST_CALL regExpProtoGetterUnicode(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 54 static EncodedJSValue JSC_HOST_CALL regExpProtoGetterSource(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 55 static EncodedJSValue JSC_HOST_CALL regExpProtoGetterFlags(JSGlobalObject*, CallFrame*);</span>
 56 
 57 const ClassInfo RegExpPrototype::s_info = { &quot;Object&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(RegExpPrototype) };
 58 
 59 RegExpPrototype::RegExpPrototype(VM&amp; vm, Structure* structure)
 60     : JSNonFinalObject(vm, structure)
 61 {
 62 }
 63 
 64 void RegExpPrototype::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 65 {
 66     Base::finishCreation(vm);
 67     ASSERT(inherits(vm, info()));
 68     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;compile, regExpProtoFuncCompile, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
 69     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;exec, regExpProtoFuncExec, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, RegExpExecIntrinsic);
 70     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;toString, regExpProtoFuncToString, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 71     JSC_NATIVE_GETTER_WITHOUT_TRANSITION(vm.propertyNames-&gt;global, regExpProtoGetterGlobal, PropertyAttribute::DontEnum | PropertyAttribute::Accessor);
 72     JSC_NATIVE_GETTER_WITHOUT_TRANSITION(vm.propertyNames-&gt;dotAll, regExpProtoGetterDotAll, PropertyAttribute::DontEnum | PropertyAttribute::Accessor);
 73     JSC_NATIVE_GETTER_WITHOUT_TRANSITION(vm.propertyNames-&gt;ignoreCase, regExpProtoGetterIgnoreCase, PropertyAttribute::DontEnum | PropertyAttribute::Accessor);
 74     JSC_NATIVE_GETTER_WITHOUT_TRANSITION(vm.propertyNames-&gt;multiline, regExpProtoGetterMultiline, PropertyAttribute::DontEnum | PropertyAttribute::Accessor);
 75     JSC_NATIVE_GETTER_WITHOUT_TRANSITION(vm.propertyNames-&gt;sticky, regExpProtoGetterSticky, PropertyAttribute::DontEnum | PropertyAttribute::Accessor);
 76     JSC_NATIVE_GETTER_WITHOUT_TRANSITION(vm.propertyNames-&gt;unicode, regExpProtoGetterUnicode, PropertyAttribute::DontEnum | PropertyAttribute::Accessor);
 77     JSC_NATIVE_GETTER_WITHOUT_TRANSITION(vm.propertyNames-&gt;source, regExpProtoGetterSource, PropertyAttribute::DontEnum | PropertyAttribute::Accessor);
 78     JSC_NATIVE_GETTER_WITHOUT_TRANSITION(vm.propertyNames-&gt;flags, regExpProtoGetterFlags, PropertyAttribute::DontEnum | PropertyAttribute::Accessor);
 79     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;matchSymbol, regExpPrototypeMatchCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 80     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;matchAllSymbol, regExpPrototypeMatchAllCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 81     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;replaceSymbol, regExpPrototypeReplaceCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 82     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;searchSymbol, regExpPrototypeSearchCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 83     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;splitSymbol, regExpPrototypeSplitCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 84     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;test, regExpPrototypeTestCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 85 }
 86 
 87 // ------------------------------ Functions ---------------------------
 88 
<a name="2" id="anc2"></a><span class="line-modified"> 89 EncodedJSValue JSC_HOST_CALL regExpProtoFuncTestFast(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
 90 {
<a name="3" id="anc3"></a><span class="line-modified"> 91     VM&amp; vm = globalObject-&gt;vm();</span>
 92     auto scope = DECLARE_THROW_SCOPE(vm);
 93 
<a name="4" id="anc4"></a><span class="line-modified"> 94     JSValue thisValue = callFrame-&gt;thisValue();</span>
 95     auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
 96     if (UNLIKELY(!regexp))
<a name="5" id="anc5"></a><span class="line-modified"> 97         return throwVMTypeError(globalObject, scope);</span>
<span class="line-modified"> 98     JSString* string = callFrame-&gt;argument(0).toStringOrNull(globalObject);</span>
 99     EXCEPTION_ASSERT(!!scope.exception() == !string);
100     if (!string)
101         return JSValue::encode(jsUndefined());
<a name="6" id="anc6"></a><span class="line-modified">102     RELEASE_AND_RETURN(scope, JSValue::encode(jsBoolean(regexp-&gt;test(globalObject, string))));</span>
103 }
104 
<a name="7" id="anc7"></a><span class="line-modified">105 EncodedJSValue JSC_HOST_CALL regExpProtoFuncExec(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
106 {
<a name="8" id="anc8"></a><span class="line-modified">107     VM&amp; vm = globalObject-&gt;vm();</span>
108     auto scope = DECLARE_THROW_SCOPE(vm);
109 
<a name="9" id="anc9"></a><span class="line-modified">110     JSValue thisValue = callFrame-&gt;thisValue();</span>
111     auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
112     if (UNLIKELY(!regexp))
<a name="10" id="anc10"></a><span class="line-modified">113         return throwVMTypeError(globalObject, scope, &quot;Builtin RegExp exec can only be called on a RegExp object&quot;);</span>
<span class="line-modified">114     JSString* string = callFrame-&gt;argument(0).toStringOrNull(globalObject);</span>
115     EXCEPTION_ASSERT(!!scope.exception() == !string);
116     if (!string)
117         return JSValue::encode(jsUndefined());
<a name="11" id="anc11"></a><span class="line-modified">118     RELEASE_AND_RETURN(scope, JSValue::encode(regexp-&gt;exec(globalObject, string)));</span>
119 }
120 
<a name="12" id="anc12"></a><span class="line-modified">121 EncodedJSValue JSC_HOST_CALL regExpProtoFuncMatchFast(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
122 {
<a name="13" id="anc13"></a><span class="line-modified">123     RegExpObject* thisObject = jsCast&lt;RegExpObject*&gt;(callFrame-&gt;thisValue());</span>
<span class="line-modified">124     JSString* string = jsCast&lt;JSString*&gt;(callFrame-&gt;uncheckedArgument(0));</span>
125     if (!thisObject-&gt;regExp()-&gt;global())
<a name="14" id="anc14"></a><span class="line-modified">126         return JSValue::encode(thisObject-&gt;exec(globalObject, string));</span>
<span class="line-modified">127     return JSValue::encode(thisObject-&gt;matchGlobal(globalObject, string));</span>
128 }
129 
<a name="15" id="anc15"></a><span class="line-modified">130 EncodedJSValue JSC_HOST_CALL regExpProtoFuncCompile(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
131 {
<a name="16" id="anc16"></a><span class="line-modified">132     VM&amp; vm = globalObject-&gt;vm();</span>
133     auto scope = DECLARE_THROW_SCOPE(vm);
134 
<a name="17" id="anc17"></a><span class="line-modified">135     JSValue thisValue = callFrame-&gt;thisValue();</span>
136     auto* thisRegExp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
137     if (UNLIKELY(!thisRegExp))
<a name="18" id="anc18"></a><span class="line-modified">138         return throwVMTypeError(globalObject, scope);</span>
139 
140     RegExp* regExp;
<a name="19" id="anc19"></a><span class="line-modified">141     JSValue arg0 = callFrame-&gt;argument(0);</span>
<span class="line-modified">142     JSValue arg1 = callFrame-&gt;argument(1);</span>
143 
144     if (auto* regExpObject = jsDynamicCast&lt;RegExpObject*&gt;(vm, arg0)) {
145         if (!arg1.isUndefined())
<a name="20" id="anc20"></a><span class="line-modified">146             return throwVMTypeError(globalObject, scope, &quot;Cannot supply flags when constructing one RegExp from another.&quot;_s);</span>
147         regExp = regExpObject-&gt;regExp();
148     } else {
<a name="21" id="anc21"></a><span class="line-modified">149         String pattern = arg0.isUndefined() ? emptyString() : arg0.toWTFString(globalObject);</span>
150         RETURN_IF_EXCEPTION(scope, encodedJSValue());
151 
<a name="22" id="anc22"></a><span class="line-modified">152         auto flags = arg1.isUndefined() ? makeOptional(OptionSet&lt;Yarr::Flags&gt; { }) : Yarr::parseFlags(arg1.toWTFString(globalObject));</span>
153         RETURN_IF_EXCEPTION(scope, encodedJSValue());
154         if (!flags)
<a name="23" id="anc23"></a><span class="line-modified">155             return throwVMError(globalObject, scope, createSyntaxError(globalObject, &quot;Invalid flags supplied to RegExp constructor.&quot;_s));</span>
156 
157         regExp = RegExp::create(vm, pattern, flags.value());
158     }
159 
160     if (!regExp-&gt;isValid())
<a name="24" id="anc24"></a><span class="line-modified">161         return throwVMError(globalObject, scope, regExp-&gt;errorToThrow(globalObject));</span>
162 
163     thisRegExp-&gt;setRegExp(vm, regExp);
164     scope.release();
<a name="25" id="anc25"></a><span class="line-modified">165     thisRegExp-&gt;setLastIndex(globalObject, 0);</span>
166     return JSValue::encode(thisRegExp);
167 }
168 
169 typedef std::array&lt;char, 6 + 1&gt; FlagsString; // 6 different flags and a null character terminator.
170 
<a name="26" id="anc26"></a><span class="line-modified">171 static inline FlagsString flagsString(JSGlobalObject* globalObject, JSObject* regexp)</span>
172 {
<a name="27" id="anc27"></a><span class="line-modified">173     FlagsString string{};</span>

174 
<a name="28" id="anc28"></a><span class="line-modified">175     VM&amp; vm = globalObject-&gt;vm();</span>
176     auto scope = DECLARE_THROW_SCOPE(vm);
177 
<a name="29" id="anc29"></a><span class="line-modified">178     JSValue globalValue = regexp-&gt;get(globalObject, vm.propertyNames-&gt;global);</span>
179     RETURN_IF_EXCEPTION(scope, string);
<a name="30" id="anc30"></a><span class="line-modified">180     JSValue ignoreCaseValue = regexp-&gt;get(globalObject, vm.propertyNames-&gt;ignoreCase);</span>
181     RETURN_IF_EXCEPTION(scope, string);
<a name="31" id="anc31"></a><span class="line-modified">182     JSValue multilineValue = regexp-&gt;get(globalObject, vm.propertyNames-&gt;multiline);</span>
183     RETURN_IF_EXCEPTION(scope, string);
<a name="32" id="anc32"></a><span class="line-modified">184     JSValue dotAllValue = regexp-&gt;get(globalObject, vm.propertyNames-&gt;dotAll);</span>
185     RETURN_IF_EXCEPTION(scope, string);
<a name="33" id="anc33"></a><span class="line-modified">186     JSValue unicodeValue = regexp-&gt;get(globalObject, vm.propertyNames-&gt;unicode);</span>
187     RETURN_IF_EXCEPTION(scope, string);
<a name="34" id="anc34"></a><span class="line-modified">188     JSValue stickyValue = regexp-&gt;get(globalObject, vm.propertyNames-&gt;sticky);</span>
189     RETURN_IF_EXCEPTION(scope, string);
190 
191     unsigned index = 0;
<a name="35" id="anc35"></a><span class="line-modified">192     if (globalValue.toBoolean(globalObject))</span>
193         string[index++] = &#39;g&#39;;
<a name="36" id="anc36"></a><span class="line-modified">194     if (ignoreCaseValue.toBoolean(globalObject))</span>
195         string[index++] = &#39;i&#39;;
<a name="37" id="anc37"></a><span class="line-modified">196     if (multilineValue.toBoolean(globalObject))</span>
197         string[index++] = &#39;m&#39;;
<a name="38" id="anc38"></a><span class="line-modified">198     if (dotAllValue.toBoolean(globalObject))</span>
199         string[index++] = &#39;s&#39;;
<a name="39" id="anc39"></a><span class="line-modified">200     if (unicodeValue.toBoolean(globalObject))</span>
201         string[index++] = &#39;u&#39;;
<a name="40" id="anc40"></a><span class="line-modified">202     if (stickyValue.toBoolean(globalObject))</span>
203         string[index++] = &#39;y&#39;;
204     ASSERT(index &lt; string.size());
205     string[index] = 0;
206     return string;
207 }
208 
<a name="41" id="anc41"></a><span class="line-modified">209 EncodedJSValue JSC_HOST_CALL regExpProtoFuncToString(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
210 {
<a name="42" id="anc42"></a><span class="line-modified">211     VM&amp; vm = globalObject-&gt;vm();</span>
212     auto scope = DECLARE_THROW_SCOPE(vm);
213 
<a name="43" id="anc43"></a><span class="line-modified">214     JSValue thisValue = callFrame-&gt;thisValue();</span>
215     if (!thisValue.isObject())
<a name="44" id="anc44"></a><span class="line-modified">216         return throwVMTypeError(globalObject, scope);</span>
217 
218     JSObject* thisObject = asObject(thisValue);
219 
<a name="45" id="anc45"></a><span class="line-modified">220     StringRecursionChecker checker(globalObject, thisObject);</span>
221     EXCEPTION_ASSERT(!scope.exception() || checker.earlyReturnValue());
222     if (JSValue earlyReturnValue = checker.earlyReturnValue())
223         return JSValue::encode(earlyReturnValue);
224 
<a name="46" id="anc46"></a><span class="line-modified">225     JSValue sourceValue = thisObject-&gt;get(globalObject, vm.propertyNames-&gt;source);</span>
226     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<a name="47" id="anc47"></a><span class="line-modified">227     String source = sourceValue.toWTFString(globalObject);</span>
228     RETURN_IF_EXCEPTION(scope, encodedJSValue());
229 
<a name="48" id="anc48"></a><span class="line-modified">230     JSValue flagsValue = thisObject-&gt;get(globalObject, vm.propertyNames-&gt;flags);</span>
231     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<a name="49" id="anc49"></a><span class="line-modified">232     String flags = flagsValue.toWTFString(globalObject);</span>
233     RETURN_IF_EXCEPTION(scope, encodedJSValue());
234 
<a name="50" id="anc50"></a><span class="line-modified">235     RELEASE_AND_RETURN(scope, JSValue::encode(jsMakeNontrivialString(globalObject, &#39;/&#39;, source, &#39;/&#39;, flags)));</span>
236 }
237 
<a name="51" id="anc51"></a><span class="line-modified">238 EncodedJSValue JSC_HOST_CALL regExpProtoGetterGlobal(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
239 {
<a name="52" id="anc52"></a><span class="line-modified">240     VM&amp; vm = globalObject-&gt;vm();</span>
241     auto scope = DECLARE_THROW_SCOPE(vm);
242 
<a name="53" id="anc53"></a><span class="line-modified">243     JSValue thisValue = callFrame-&gt;thisValue();</span>
244     auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
245     if (UNLIKELY(!regexp)) {
246         if (thisValue.inherits&lt;RegExpPrototype&gt;(vm))
247             return JSValue::encode(jsUndefined());
<a name="54" id="anc54"></a><span class="line-modified">248         return throwVMTypeError(globalObject, scope, &quot;The RegExp.prototype.global getter can only be called on a RegExp object&quot;_s);</span>
249     }
250 
251     return JSValue::encode(jsBoolean(regexp-&gt;regExp()-&gt;global()));
252 }
253 
<a name="55" id="anc55"></a><span class="line-modified">254 EncodedJSValue JSC_HOST_CALL regExpProtoGetterIgnoreCase(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
255 {
<a name="56" id="anc56"></a><span class="line-modified">256     VM&amp; vm = globalObject-&gt;vm();</span>
257     auto scope = DECLARE_THROW_SCOPE(vm);
258 
<a name="57" id="anc57"></a><span class="line-modified">259     JSValue thisValue = callFrame-&gt;thisValue();</span>
260     auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
261     if (UNLIKELY(!regexp)) {
262         if (thisValue.inherits&lt;RegExpPrototype&gt;(vm))
263             return JSValue::encode(jsUndefined());
<a name="58" id="anc58"></a><span class="line-modified">264         return throwVMTypeError(globalObject, scope, &quot;The RegExp.prototype.ignoreCase getter can only be called on a RegExp object&quot;_s);</span>
265     }
266 
267     return JSValue::encode(jsBoolean(regexp-&gt;regExp()-&gt;ignoreCase()));
268 }
269 
<a name="59" id="anc59"></a><span class="line-modified">270 EncodedJSValue JSC_HOST_CALL regExpProtoGetterMultiline(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
271 {
<a name="60" id="anc60"></a><span class="line-modified">272     VM&amp; vm = globalObject-&gt;vm();</span>
273     auto scope = DECLARE_THROW_SCOPE(vm);
274 
<a name="61" id="anc61"></a><span class="line-modified">275     JSValue thisValue = callFrame-&gt;thisValue();</span>
276     auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
277     if (UNLIKELY(!regexp)) {
278         if (thisValue.inherits&lt;RegExpPrototype&gt;(vm))
279             return JSValue::encode(jsUndefined());
<a name="62" id="anc62"></a><span class="line-modified">280         return throwVMTypeError(globalObject, scope, &quot;The RegExp.prototype.multiline getter can only be called on a RegExp object&quot;_s);</span>
281     }
282 
283     return JSValue::encode(jsBoolean(regexp-&gt;regExp()-&gt;multiline()));
284 }
285 
<a name="63" id="anc63"></a><span class="line-modified">286 EncodedJSValue JSC_HOST_CALL regExpProtoGetterDotAll(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
287 {
<a name="64" id="anc64"></a><span class="line-modified">288     VM&amp; vm = globalObject-&gt;vm();</span>
289     auto scope = DECLARE_THROW_SCOPE(vm);
290 
<a name="65" id="anc65"></a><span class="line-modified">291     JSValue thisValue = callFrame-&gt;thisValue();</span>
292     auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
293     if (UNLIKELY(!regexp)) {
294         if (thisValue.inherits&lt;RegExpPrototype&gt;(vm))
295             return JSValue::encode(jsUndefined());
<a name="66" id="anc66"></a><span class="line-modified">296         return throwVMTypeError(globalObject, scope, &quot;The RegExp.prototype.dotAll getter can only be called on a RegExp object&quot;_s);</span>
297     }
298 
299     return JSValue::encode(jsBoolean(regexp-&gt;regExp()-&gt;dotAll()));
300 }
301 
<a name="67" id="anc67"></a><span class="line-modified">302 EncodedJSValue JSC_HOST_CALL regExpProtoGetterSticky(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
303 {
<a name="68" id="anc68"></a><span class="line-modified">304     VM&amp; vm = globalObject-&gt;vm();</span>
305     auto scope = DECLARE_THROW_SCOPE(vm);
306 
<a name="69" id="anc69"></a><span class="line-modified">307     JSValue thisValue = callFrame-&gt;thisValue();</span>
308     auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
309     if (UNLIKELY(!regexp)) {
310         if (thisValue.inherits&lt;RegExpPrototype&gt;(vm))
311             return JSValue::encode(jsUndefined());
<a name="70" id="anc70"></a><span class="line-modified">312         return throwVMTypeError(globalObject, scope, &quot;The RegExp.prototype.sticky getter can only be called on a RegExp object&quot;_s);</span>
313     }
314 
315     return JSValue::encode(jsBoolean(regexp-&gt;regExp()-&gt;sticky()));
316 }
317 
<a name="71" id="anc71"></a><span class="line-modified">318 EncodedJSValue JSC_HOST_CALL regExpProtoGetterUnicode(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
319 {
<a name="72" id="anc72"></a><span class="line-modified">320     VM&amp; vm = globalObject-&gt;vm();</span>
321     auto scope = DECLARE_THROW_SCOPE(vm);
322 
<a name="73" id="anc73"></a><span class="line-modified">323     JSValue thisValue = callFrame-&gt;thisValue();</span>
324     auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
325     if (UNLIKELY(!regexp)) {
326         if (thisValue.inherits&lt;RegExpPrototype&gt;(vm))
327             return JSValue::encode(jsUndefined());
<a name="74" id="anc74"></a><span class="line-modified">328         return throwVMTypeError(globalObject, scope, &quot;The RegExp.prototype.unicode getter can only be called on a RegExp object&quot;_s);</span>
329     }
330 
331     return JSValue::encode(jsBoolean(regexp-&gt;regExp()-&gt;unicode()));
332 }
333 
<a name="75" id="anc75"></a><span class="line-modified">334 EncodedJSValue JSC_HOST_CALL regExpProtoGetterFlags(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
335 {
<a name="76" id="anc76"></a><span class="line-modified">336     VM&amp; vm = globalObject-&gt;vm();</span>
337     auto scope = DECLARE_THROW_SCOPE(vm);
338 
<a name="77" id="anc77"></a><span class="line-modified">339     JSValue thisValue = callFrame-&gt;thisValue();</span>
340     if (UNLIKELY(!thisValue.isObject()))
<a name="78" id="anc78"></a><span class="line-modified">341         return throwVMTypeError(globalObject, scope, &quot;The RegExp.prototype.flags getter can only be called on an object&quot;_s);</span>
342 
<a name="79" id="anc79"></a><span class="line-modified">343     auto flags = flagsString(globalObject, asObject(thisValue));</span>
344     RETURN_IF_EXCEPTION(scope, encodedJSValue());
345 
346     return JSValue::encode(jsString(vm, flags.data()));
347 }
348 
349 template &lt;typename CharacterType&gt;
350 static inline void appendLineTerminatorEscape(StringBuilder&amp;, CharacterType);
351 
352 template &lt;&gt;
353 inline void appendLineTerminatorEscape&lt;LChar&gt;(StringBuilder&amp; builder, LChar lineTerminator)
354 {
355     if (lineTerminator == &#39;\n&#39;)
356         builder.append(&#39;n&#39;);
357     else
358         builder.append(&#39;r&#39;);
359 }
360 
361 template &lt;&gt;
362 inline void appendLineTerminatorEscape&lt;UChar&gt;(StringBuilder&amp; builder, UChar lineTerminator)
363 {
364     if (lineTerminator == &#39;\n&#39;)
365         builder.append(&#39;n&#39;);
366     else if (lineTerminator == &#39;\r&#39;)
367         builder.append(&#39;r&#39;);
368     else if (lineTerminator == 0x2028)
369         builder.appendLiteral(&quot;u2028&quot;);
370     else
371         builder.appendLiteral(&quot;u2029&quot;);
372 }
373 
374 template &lt;typename CharacterType&gt;
<a name="80" id="anc80"></a><span class="line-modified">375 static inline JSValue regExpProtoGetterSourceInternal(JSGlobalObject* globalObject, const String&amp; pattern, const CharacterType* characters, unsigned length)</span>
376 {
<a name="81" id="anc81"></a><span class="line-modified">377     VM&amp; vm = globalObject-&gt;vm();</span>
378     bool previousCharacterWasBackslash = false;
379     bool inBrackets = false;
380     bool shouldEscape = false;
381 
382     // 15.10.6.4 specifies that RegExp.prototype.toString must return &#39;/&#39; + source + &#39;/&#39;,
383     // and also states that the result must be a valid RegularExpressionLiteral. &#39;//&#39; is
384     // not a valid RegularExpressionLiteral (since it is a single line comment), and hence
385     // source cannot ever validly be &quot;&quot;. If the source is empty, return a different Pattern
386     // that would match the same thing.
387     if (!length)
388         return jsNontrivialString(vm, &quot;(?:)&quot;_s);
389 
390     // early return for strings that don&#39;t contain a forwards slash and LineTerminator
391     for (unsigned i = 0; i &lt; length; ++i) {
392         CharacterType ch = characters[i];
393         if (!previousCharacterWasBackslash) {
394             if (inBrackets) {
395                 if (ch == &#39;]&#39;)
396                     inBrackets = false;
397             } else {
398                 if (ch == &#39;/&#39;) {
399                     shouldEscape = true;
400                     break;
401                 }
402                 if (ch == &#39;[&#39;)
403                     inBrackets = true;
404             }
405         }
406 
407         if (Lexer&lt;CharacterType&gt;::isLineTerminator(ch)) {
408             shouldEscape = true;
409             break;
410         }
411 
412         if (previousCharacterWasBackslash)
413             previousCharacterWasBackslash = false;
414         else
415             previousCharacterWasBackslash = ch == &#39;\\&#39;;
416     }
417 
418     if (!shouldEscape)
419         return jsString(vm, pattern);
420 
421     previousCharacterWasBackslash = false;
422     inBrackets = false;
423     StringBuilder result;
424     for (unsigned i = 0; i &lt; length; ++i) {
425         CharacterType ch = characters[i];
426         if (!previousCharacterWasBackslash) {
427             if (inBrackets) {
428                 if (ch == &#39;]&#39;)
429                     inBrackets = false;
430             } else {
431                 if (ch == &#39;/&#39;)
432                     result.append(&#39;\\&#39;);
433                 else if (ch == &#39;[&#39;)
434                     inBrackets = true;
435             }
436         }
437 
438         // escape LineTerminator
439         if (Lexer&lt;CharacterType&gt;::isLineTerminator(ch)) {
440             if (!previousCharacterWasBackslash)
441                 result.append(&#39;\\&#39;);
442 
443             appendLineTerminatorEscape&lt;CharacterType&gt;(result, ch);
444         } else
445             result.append(ch);
446 
447         if (previousCharacterWasBackslash)
448             previousCharacterWasBackslash = false;
449         else
450             previousCharacterWasBackslash = ch == &#39;\\&#39;;
451     }
452 
453     return jsString(vm, result.toString());
454 }
455 
<a name="82" id="anc82"></a><span class="line-modified">456 EncodedJSValue JSC_HOST_CALL regExpProtoGetterSource(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
457 {
<a name="83" id="anc83"></a><span class="line-modified">458     VM&amp; vm = globalObject-&gt;vm();</span>
459     auto scope = DECLARE_THROW_SCOPE(vm);
460 
<a name="84" id="anc84"></a><span class="line-modified">461     JSValue thisValue = callFrame-&gt;thisValue();</span>
462     auto* regexp = jsDynamicCast&lt;RegExpObject*&gt;(vm, thisValue);
463     if (UNLIKELY(!regexp)) {
464         if (thisValue.inherits&lt;RegExpPrototype&gt;(vm))
<a name="85" id="anc85"></a><span class="line-modified">465             return JSValue::encode(jsNontrivialString(vm, &quot;(?:)&quot;_s));</span>
<span class="line-modified">466         return throwVMTypeError(globalObject, scope, &quot;The RegExp.prototype.source getter can only be called on a RegExp object&quot;_s);</span>
467     }
468 
469     String pattern = regexp-&gt;regExp()-&gt;pattern();
470     if (pattern.is8Bit())
<a name="86" id="anc86"></a><span class="line-modified">471         return JSValue::encode(regExpProtoGetterSourceInternal(globalObject, pattern, pattern.characters8(), pattern.length()));</span>
<span class="line-modified">472     return JSValue::encode(regExpProtoGetterSourceInternal(globalObject, pattern, pattern.characters16(), pattern.length()));</span>
473 }
474 
<a name="87" id="anc87"></a><span class="line-modified">475 EncodedJSValue JSC_HOST_CALL regExpProtoFuncSearchFast(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
476 {
<a name="88" id="anc88"></a><span class="line-modified">477     VM&amp; vm = globalObject-&gt;vm();</span>
478     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="89" id="anc89"></a><span class="line-modified">479     JSValue thisValue = callFrame-&gt;thisValue();</span>
480     RegExp* regExp = jsCast&lt;RegExpObject*&gt;(thisValue)-&gt;regExp();
481 
<a name="90" id="anc90"></a><span class="line-modified">482     JSString* string = callFrame-&gt;uncheckedArgument(0).toString(globalObject);</span>
<span class="line-modified">483     String s = string-&gt;value(globalObject);</span>
484     RETURN_IF_EXCEPTION(scope, encodedJSValue());
485 
<a name="91" id="anc91"></a>
486     MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, s, 0);
487     RETURN_IF_EXCEPTION(scope, encodedJSValue());
488     return JSValue::encode(result ? jsNumber(result.start) : jsNumber(-1));
489 }
490 
491 static inline unsigned advanceStringIndex(String str, unsigned strSize, unsigned index, bool isUnicode)
492 {
493     if (!isUnicode)
494         return ++index;
495     return advanceStringUnicode(str, strSize, index);
496 }
497 
498 enum SplitControl {
499     ContinueSplit,
500     AbortSplit
501 };
502 
503 template&lt;typename ControlFunc, typename PushFunc&gt;
504 void genericSplit(
505     VM&amp; vm, RegExp* regexp, const String&amp; input, unsigned inputSize, unsigned&amp; position,
506     unsigned&amp; matchPosition, bool regExpIsSticky, bool regExpIsUnicode,
507     const ControlFunc&amp; control, const PushFunc&amp; push)
508 {
509     Vector&lt;int&gt; ovector;
510 
511     while (matchPosition &lt; inputSize) {
512         if (control() == AbortSplit)
513             return;
514 
515         ovector.shrink(0);
516 
517         // a. Perform ? Set(splitter, &quot;lastIndex&quot;, q, true).
518         // b. Let z be ? RegExpExec(splitter, S).
519         int mpos = regexp-&gt;match(vm, input, matchPosition, ovector);
520 
521         // c. If z is null, let q be AdvanceStringIndex(S, q, unicodeMatching).
522         if (mpos &lt; 0) {
523             if (!regExpIsSticky)
524                 break;
525             matchPosition = advanceStringIndex(input, inputSize, matchPosition, regExpIsUnicode);
526             continue;
527         }
528         if (static_cast&lt;unsigned&gt;(mpos) &gt;= inputSize) {
529             // The spec redoes the RegExpExec starting at the next character of the input.
530             // But in our case, mpos &lt; 0 means that the native regexp already searched all permutations
531             // and know that we won&#39;t be able to find a match for the separator even if we redo the
532             // RegExpExec starting at the next character of the input. So, just bail.
533             break;
534         }
535 
536         // d. Else, z is not null
537         //    i. Let e be ? ToLength(? Get(splitter, &quot;lastIndex&quot;)).
538         //   ii. Let e be min(e, size).
539         matchPosition = mpos;
540         unsigned matchEnd = ovector[1];
541 
542         //  iii. If e = p, let q be AdvanceStringIndex(S, q, unicodeMatching).
543         if (matchEnd == position) {
544             matchPosition = advanceStringIndex(input, inputSize, matchPosition, regExpIsUnicode);
545             continue;
546         }
547         // if matchEnd == 0 then position should also be zero and thus matchEnd should equal position.
548         ASSERT(matchEnd);
549 
550         //   iv. Else e != p,
551         unsigned numberOfCaptures = regexp-&gt;numSubpatterns();
552 
553         // 1. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through q (exclusive).
554         // 2. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
555         if (push(true, position, matchPosition - position) == AbortSplit)
556             return;
557 
558         // 5. Let p be e.
559         position = matchEnd;
560 
561         // 6. Let numberOfCaptures be ? ToLength(? Get(z, &quot;length&quot;)).
562         // 7. Let numberOfCaptures be max(numberOfCaptures-1, 0).
563         // 8. Let i be 1.
564         // 9. Repeat, while i &lt;= numberOfCaptures,
565         for (unsigned i = 1; i &lt;= numberOfCaptures; ++i) {
566             // a. Let nextCapture be ? Get(z, ! ToString(i)).
567             // b. Perform ! CreateDataProperty(A, ! ToString(lengthA), nextCapture).
568             int sub = ovector[i * 2];
569             if (push(sub &gt;= 0, sub, ovector[i * 2 + 1] - sub) == AbortSplit)
570                 return;
571         }
572 
573         // 10. Let q be p.
574         matchPosition = position;
575     }
576 }
577 
578 // ES 21.2.5.11 RegExp.prototype[@@split](string, limit)
<a name="92" id="anc92"></a><span class="line-modified">579 EncodedJSValue JSC_HOST_CALL regExpProtoFuncSplitFast(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
580 {
<a name="93" id="anc93"></a><span class="line-modified">581     VM&amp; vm = globalObject-&gt;vm();</span>
582     auto scope = DECLARE_THROW_SCOPE(vm);
583 
584     // 1. [handled by JS builtin] Let rx be the this value.
585     // 2. [handled by JS builtin] If Type(rx) is not Object, throw a TypeError exception.
<a name="94" id="anc94"></a><span class="line-modified">586     JSValue thisValue = callFrame-&gt;thisValue();</span>
587     RegExp* regexp = jsCast&lt;RegExpObject*&gt;(thisValue)-&gt;regExp();
588 
589     // 3. [handled by JS builtin] Let S be ? ToString(string).
<a name="95" id="anc95"></a><span class="line-modified">590     JSString* inputString = callFrame-&gt;argument(0).toString(globalObject);</span>
<span class="line-modified">591     String input = inputString-&gt;value(globalObject);</span>
592     RETURN_IF_EXCEPTION(scope, encodedJSValue());
593     ASSERT(!input.isNull());
594 
595     // 4. [handled by JS builtin] Let C be ? SpeciesConstructor(rx, %RegExp%).
596     // 5. [handled by JS builtin] Let flags be ? ToString(? Get(rx, &quot;flags&quot;)).
597     // 6. [handled by JS builtin] If flags contains &quot;u&quot;, let unicodeMatching be true.
598     // 7. [handled by JS builtin] Else, let unicodeMatching be false.
599     // 8. [handled by JS builtin] If flags contains &quot;y&quot;, let newFlags be flags.
600     // 9. [handled by JS builtin] Else, let newFlags be the string that is the concatenation of flags and &quot;y&quot;.
601     // 10. [handled by JS builtin] Let splitter be ? Construct(C, « rx, newFlags »).
602 
603     // 11. Let A be ArrayCreate(0).
604     // 12. Let lengthA be 0.
<a name="96" id="anc96"></a><span class="line-modified">605     JSArray* result = constructEmptyArray(globalObject, 0);</span>
606     RETURN_IF_EXCEPTION(scope, encodedJSValue());
607     unsigned resultLength = 0;
608 
609     // 13. If limit is undefined, let lim be 2^32-1; else let lim be ? ToUint32(limit).
<a name="97" id="anc97"></a><span class="line-modified">610     JSValue limitValue = callFrame-&gt;argument(1);</span>
<span class="line-modified">611     unsigned limit = limitValue.isUndefined() ? 0xFFFFFFFFu : limitValue.toUInt32(globalObject);</span>
612     RETURN_IF_EXCEPTION(scope, encodedJSValue());
613 
614     // 14. Let size be the number of elements in S.
615     unsigned inputSize = input.length();
616 
617     // 15. Let p = 0.
618     unsigned position = 0;
619 
620     // 16. If lim == 0, return A.
621     if (!limit)
622         return JSValue::encode(result);
623 
624     // 17. If size == 0, then
625     if (input.isEmpty()) {
626         // a. Let z be ? RegExpExec(splitter, S).
627         // b. If z is not null, return A.
628         // c. Perform ! CreateDataProperty(A, &quot;0&quot;, S).
629         // d. Return A.
630         if (!regexp-&gt;match(vm, input, 0)) {
<a name="98" id="anc98"></a><span class="line-modified">631             result-&gt;putDirectIndex(globalObject, 0, inputString);</span>
632             RETURN_IF_EXCEPTION(scope, encodedJSValue());
633         }
634         return JSValue::encode(result);
635     }
636 
637     // 18. Let q = p.
638     unsigned matchPosition = position;
639     // 19. Repeat, while q &lt; size
640     bool regExpIsSticky = regexp-&gt;sticky();
641     bool regExpIsUnicode = regexp-&gt;unicode();
642 
643     unsigned maxSizeForDirectPath = 100000;
644 
645     genericSplit(
646         vm, regexp, input, inputSize, position, matchPosition, regExpIsSticky, regExpIsUnicode,
647         [&amp;] () -&gt; SplitControl {
648             if (resultLength &gt;= maxSizeForDirectPath)
649                 return AbortSplit;
650             return ContinueSplit;
651         },
652         [&amp;] (bool isDefined, unsigned start, unsigned length) -&gt; SplitControl {
<a name="99" id="anc99"></a><span class="line-modified">653             result-&gt;putDirectIndex(globalObject, resultLength++, isDefined ? jsSubstringOfResolved(vm, inputString, start, length) : jsUndefined());</span>
654             RETURN_IF_EXCEPTION(scope, AbortSplit);
655             if (resultLength &gt;= limit)
656                 return AbortSplit;
657             return ContinueSplit;
658         });
659     RETURN_IF_EXCEPTION(scope, encodedJSValue());
660 
661     if (resultLength &gt;= limit)
662         return JSValue::encode(result);
663     if (resultLength &lt; maxSizeForDirectPath) {
664         // 20. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through size (exclusive).
665         // 21. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
666         scope.release();
<a name="100" id="anc100"></a><span class="line-modified">667         result-&gt;putDirectIndex(globalObject, resultLength, jsSubstringOfResolved(vm, inputString, position, inputSize - position));</span>
668 
669         // 22. Return A.
670         return JSValue::encode(result);
671     }
672 
673     // Now do a dry run to see how big things get. Give up if they get absurd.
674     unsigned savedPosition = position;
675     unsigned savedMatchPosition = matchPosition;
676     unsigned dryRunCount = 0;
677     genericSplit(
678         vm, regexp, input, inputSize, position, matchPosition, regExpIsSticky, regExpIsUnicode,
679         [&amp;] () -&gt; SplitControl {
680             if (resultLength + dryRunCount &gt; MAX_STORAGE_VECTOR_LENGTH)
681                 return AbortSplit;
682             return ContinueSplit;
683         },
684         [&amp;] (bool, unsigned, unsigned) -&gt; SplitControl {
685             dryRunCount++;
686             if (resultLength + dryRunCount &gt;= limit)
687                 return AbortSplit;
688             return ContinueSplit;
689         });
690 
691     if (resultLength + dryRunCount &gt; MAX_STORAGE_VECTOR_LENGTH) {
<a name="101" id="anc101"></a><span class="line-modified">692         throwOutOfMemoryError(globalObject, scope);</span>
693         return encodedJSValue();
694     }
695 
696     // OK, we know that if we finish the split, we won&#39;t have to OOM.
697     position = savedPosition;
698     matchPosition = savedMatchPosition;
699 
700     genericSplit(
701         vm, regexp, input, inputSize, position, matchPosition, regExpIsSticky, regExpIsUnicode,
702         [&amp;] () -&gt; SplitControl {
703             return ContinueSplit;
704         },
705         [&amp;] (bool isDefined, unsigned start, unsigned length) -&gt; SplitControl {
<a name="102" id="anc102"></a><span class="line-modified">706             result-&gt;putDirectIndex(globalObject, resultLength++, isDefined ? jsSubstringOfResolved(vm, inputString, start, length) : jsUndefined());</span>
707             RETURN_IF_EXCEPTION(scope, AbortSplit);
708             if (resultLength &gt;= limit)
709                 return AbortSplit;
710             return ContinueSplit;
711         });
712     RETURN_IF_EXCEPTION(scope, encodedJSValue());
713 
714     if (resultLength &gt;= limit)
715         return JSValue::encode(result);
716 
717     // 20. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through size (exclusive).
718     // 21. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
719     scope.release();
<a name="103" id="anc103"></a><span class="line-modified">720     result-&gt;putDirectIndex(globalObject, resultLength, jsSubstringOfResolved(vm, inputString, position, inputSize - position));</span>
721     // 22. Return A.
722     return JSValue::encode(result);
723 }
724 
725 } // namespace JSC
<a name="104" id="anc104"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="104" type="hidden" />
</body>
</html>
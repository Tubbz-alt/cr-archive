<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderElement.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderEmbeddedObject.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderElement.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 41     static RenderPtr&lt;RenderElement&gt; createFor(Element&amp;, RenderStyle&amp;&amp;, RendererCreationType = CreateAllRenderers);
 42 
 43     bool hasInitializedStyle() const { return m_hasInitializedStyle; }
 44 
 45     const RenderStyle&amp; style() const { return m_style; }
 46     const RenderStyle&amp; firstLineStyle() const;
 47 
 48     // FIXME: Style shouldn&#39;t be mutated.
 49     RenderStyle&amp; mutableStyle() { return m_style; }
 50 
 51     void initializeStyle();
 52 
 53     // Calling with minimalStyleDifference &gt; StyleDifference::Equal indicates that
 54     // out-of-band state (e.g. animations) requires that styleDidChange processing
 55     // continue even if the style isn&#39;t different from the current style.
 56     void setStyle(RenderStyle&amp;&amp;, StyleDifference minimalStyleDifference = StyleDifference::Equal);
 57 
 58     // The pseudo element style can be cached or uncached.  Use the cached method if the pseudo element doesn&#39;t respect
 59     // any pseudo classes (and therefore has no concept of changing state).
 60     const RenderStyle* getCachedPseudoStyle(PseudoId, const RenderStyle* parentStyle = nullptr) const;
<span class="line-modified"> 61     std::unique_ptr&lt;RenderStyle&gt; getUncachedPseudoStyle(const PseudoStyleRequest&amp;, const RenderStyle* parentStyle = nullptr, const RenderStyle* ownStyle = nullptr) const;</span>
 62 
 63     // This is null for anonymous renderers.
 64     Element* element() const { return downcast&lt;Element&gt;(RenderObject::node()); }
 65     Element* nonPseudoElement() const { return downcast&lt;Element&gt;(RenderObject::nonPseudoNode()); }
 66     Element* generatingElement() const;
 67 
 68     RenderObject* firstChild() const { return m_firstChild; }
 69     RenderObject* lastChild() const { return m_lastChild; }
 70 
 71     bool canContainFixedPositionObjects() const;
 72     bool canContainAbsolutelyPositionedObjects() const;
 73 
 74     Color selectionColor(CSSPropertyID) const;
 75     std::unique_ptr&lt;RenderStyle&gt; selectionPseudoStyle() const;
 76 
 77     // Obtains the selection colors that should be used when painting a selection.
 78     Color selectionBackgroundColor() const;
 79     Color selectionForegroundColor() const;
 80     Color selectionEmphasisMarkColor() const;
 81 
</pre>
<hr />
<pre>
328     bool shouldWillChangeCreateStackingContext() const;
329     void issueRepaintForOutlineAuto(float outlineSize);
330 
331     unsigned m_baseTypeFlags : 6;
332     unsigned m_ancestorLineBoxDirty : 1;
333     unsigned m_hasInitializedStyle : 1;
334 
335     unsigned m_renderInlineAlwaysCreatesLineBoxes : 1;
336     unsigned m_renderBoxNeedsLazyRepaint : 1;
337     unsigned m_hasPausedImageAnimations : 1;
338     unsigned m_hasCounterNodeMap : 1;
339     unsigned m_hasContinuationChainNode : 1;
340     unsigned m_isContinuation : 1;
341     unsigned m_isFirstLetter : 1;
342     mutable unsigned m_hasValidCachedFirstLineStyle : 1;
343 
344     unsigned m_renderBlockHasMarginBeforeQuirk : 1;
345     unsigned m_renderBlockHasMarginAfterQuirk : 1;
346     unsigned m_renderBlockShouldForceRelayoutChildren : 1;
347     unsigned m_renderBlockFlowHasMarkupTruncation : 1;
<span class="line-modified">348     unsigned m_renderBlockFlowLineLayoutPath : 2;</span>
349 
350     unsigned m_isRegisteredForVisibleInViewportCallback : 1;
351     unsigned m_visibleInViewportState : 2;
352 
353     RenderObject* m_firstChild;
354     RenderObject* m_lastChild;
355 
356     RenderStyle m_style;
357 };
358 
359 inline void RenderElement::setAncestorLineBoxDirty(bool f)
360 {
361     m_ancestorLineBoxDirty = f;
362     if (m_ancestorLineBoxDirty)
363         setNeedsLayout();
364 }
365 
366 inline void RenderElement::setChildNeedsLayout(MarkingBehavior markParents)
367 {
368     ASSERT(!isSetNeedsLayoutForbidden());
</pre>
</td>
<td>
<hr />
<pre>
 41     static RenderPtr&lt;RenderElement&gt; createFor(Element&amp;, RenderStyle&amp;&amp;, RendererCreationType = CreateAllRenderers);
 42 
 43     bool hasInitializedStyle() const { return m_hasInitializedStyle; }
 44 
 45     const RenderStyle&amp; style() const { return m_style; }
 46     const RenderStyle&amp; firstLineStyle() const;
 47 
 48     // FIXME: Style shouldn&#39;t be mutated.
 49     RenderStyle&amp; mutableStyle() { return m_style; }
 50 
 51     void initializeStyle();
 52 
 53     // Calling with minimalStyleDifference &gt; StyleDifference::Equal indicates that
 54     // out-of-band state (e.g. animations) requires that styleDidChange processing
 55     // continue even if the style isn&#39;t different from the current style.
 56     void setStyle(RenderStyle&amp;&amp;, StyleDifference minimalStyleDifference = StyleDifference::Equal);
 57 
 58     // The pseudo element style can be cached or uncached.  Use the cached method if the pseudo element doesn&#39;t respect
 59     // any pseudo classes (and therefore has no concept of changing state).
 60     const RenderStyle* getCachedPseudoStyle(PseudoId, const RenderStyle* parentStyle = nullptr) const;
<span class="line-modified"> 61     std::unique_ptr&lt;RenderStyle&gt; getUncachedPseudoStyle(const Style::PseudoElementRequest&amp;, const RenderStyle* parentStyle = nullptr, const RenderStyle* ownStyle = nullptr) const;</span>
 62 
 63     // This is null for anonymous renderers.
 64     Element* element() const { return downcast&lt;Element&gt;(RenderObject::node()); }
 65     Element* nonPseudoElement() const { return downcast&lt;Element&gt;(RenderObject::nonPseudoNode()); }
 66     Element* generatingElement() const;
 67 
 68     RenderObject* firstChild() const { return m_firstChild; }
 69     RenderObject* lastChild() const { return m_lastChild; }
 70 
 71     bool canContainFixedPositionObjects() const;
 72     bool canContainAbsolutelyPositionedObjects() const;
 73 
 74     Color selectionColor(CSSPropertyID) const;
 75     std::unique_ptr&lt;RenderStyle&gt; selectionPseudoStyle() const;
 76 
 77     // Obtains the selection colors that should be used when painting a selection.
 78     Color selectionBackgroundColor() const;
 79     Color selectionForegroundColor() const;
 80     Color selectionEmphasisMarkColor() const;
 81 
</pre>
<hr />
<pre>
328     bool shouldWillChangeCreateStackingContext() const;
329     void issueRepaintForOutlineAuto(float outlineSize);
330 
331     unsigned m_baseTypeFlags : 6;
332     unsigned m_ancestorLineBoxDirty : 1;
333     unsigned m_hasInitializedStyle : 1;
334 
335     unsigned m_renderInlineAlwaysCreatesLineBoxes : 1;
336     unsigned m_renderBoxNeedsLazyRepaint : 1;
337     unsigned m_hasPausedImageAnimations : 1;
338     unsigned m_hasCounterNodeMap : 1;
339     unsigned m_hasContinuationChainNode : 1;
340     unsigned m_isContinuation : 1;
341     unsigned m_isFirstLetter : 1;
342     mutable unsigned m_hasValidCachedFirstLineStyle : 1;
343 
344     unsigned m_renderBlockHasMarginBeforeQuirk : 1;
345     unsigned m_renderBlockHasMarginAfterQuirk : 1;
346     unsigned m_renderBlockShouldForceRelayoutChildren : 1;
347     unsigned m_renderBlockFlowHasMarkupTruncation : 1;
<span class="line-modified">348     unsigned m_renderBlockFlowLineLayoutPath : 3;</span>
349 
350     unsigned m_isRegisteredForVisibleInViewportCallback : 1;
351     unsigned m_visibleInViewportState : 2;
352 
353     RenderObject* m_firstChild;
354     RenderObject* m_lastChild;
355 
356     RenderStyle m_style;
357 };
358 
359 inline void RenderElement::setAncestorLineBoxDirty(bool f)
360 {
361     m_ancestorLineBoxDirty = f;
362     if (m_ancestorLineBoxDirty)
363         setNeedsLayout();
364 }
365 
366 inline void RenderElement::setChildNeedsLayout(MarkingBehavior markParents)
367 {
368     ASSERT(!isSetNeedsLayoutForbidden());
</pre>
</td>
</tr>
</table>
<center><a href="RenderElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderEmbeddedObject.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
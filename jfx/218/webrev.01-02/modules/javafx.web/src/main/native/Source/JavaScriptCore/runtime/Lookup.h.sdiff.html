<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Lookup.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LiteralParser.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MachineContext.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Lookup.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 27 #include &quot;DOMJITSignature.h&quot;
 28 #include &quot;Identifier.h&quot;
 29 #include &quot;IdentifierInlines.h&quot;
 30 #include &quot;Intrinsic.h&quot;
 31 #include &quot;JSFunction.h&quot;
 32 #include &quot;JSGlobalObject.h&quot;
 33 #include &quot;LazyProperty.h&quot;
 34 #include &quot;PropertySlot.h&quot;
 35 #include &quot;PutPropertySlot.h&quot;
 36 #include &quot;TypeError.h&quot;
 37 #include &lt;wtf/Assertions.h&gt;
 38 
 39 namespace JSC {
 40 
 41 struct CompactHashIndex {
 42     const int16_t value;
 43     const int16_t next;
 44 };
 45 
 46 // FIXME: There is no reason this get function can&#39;t be simpler.
<span class="line-modified"> 47 // ie. typedef JSValue (*GetFunction)(ExecState*, JSObject* baseObject)</span>
 48 typedef PropertySlot::GetValueFunc GetFunction;
 49 typedef PutPropertySlot::PutValueFunc PutFunction;
 50 typedef FunctionExecutable* (*BuiltinGenerator)(VM&amp;);
 51 typedef JSValue (*LazyPropertyCallback)(VM&amp;, JSObject*);
 52 
 53 // Hash table generated by the create_hash_table script.
 54 struct HashTableValue {
 55     const char* m_key; // property name
 56     unsigned m_attributes; // JSObject attributes
 57     Intrinsic m_intrinsic;
 58     union ValueStorage {
 59         constexpr ValueStorage(intptr_t value1, intptr_t value2)
 60             : value1(value1)
 61             , value2(value2)
 62         { }
 63         constexpr ValueStorage(long long constant)
 64             : constant(constant)
 65         { }
 66 
 67         struct {
</pre>
<hr />
<pre>
249     }
250 
251     slot.setCacheableCustom(thisObject, attributesForStructure(entry-&gt;attributes()), entry-&gt;propertyGetter());
252     return true;
253 }
254 
255 inline bool replaceStaticPropertySlot(VM&amp; vm, JSObject* thisObject, PropertyName propertyName, JSValue value)
256 {
257     if (!thisObject-&gt;putDirect(vm, propertyName, value))
258         return false;
259 
260     if (!thisObject-&gt;staticPropertiesReified(vm))
261         thisObject-&gt;JSObject::setStructure(vm, Structure::attributeChangeTransition(vm, thisObject-&gt;structure(vm), propertyName, 0));
262 
263     return true;
264 }
265 
266 // &#39;base&#39; means the object holding the property (possibly in the prototype chain of the object put was called on).
267 // &#39;thisValue&#39; is the object that put is being applied to (in the case of a proxy, the proxy target).
268 // &#39;slot.thisValue()&#39; is the object the put was originally performed on (in the case of a proxy, the proxy itself).
<span class="line-modified">269 inline bool putEntry(ExecState* exec, const ClassInfo*, const HashTableValue* entry, JSObject* base, JSObject* thisValue, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
270 {
<span class="line-modified">271     VM&amp; vm = exec-&gt;vm();</span>
272     auto scope = DECLARE_THROW_SCOPE(vm);
273 
274     if (entry-&gt;attributes() &amp; PropertyAttribute::BuiltinOrFunctionOrLazyProperty) {
275         if (!(entry-&gt;attributes() &amp; PropertyAttribute::ReadOnly)) {
276             // If this is a function or lazy property put then we just do the put because
277             // logically the object already had the property, so this is just a replace.
278             if (JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, thisValue))
279                 thisObject-&gt;putDirect(vm, propertyName, value);
280             return true;
281         }
<span class="line-modified">282         return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);</span>
283     }
284 
285     if (entry-&gt;attributes() &amp; PropertyAttribute::Accessor)
<span class="line-modified">286         return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);</span>
287 
288     if (!(entry-&gt;attributes() &amp; PropertyAttribute::ReadOnly)) {
289         ASSERT_WITH_MESSAGE(!(entry-&gt;attributes() &amp; PropertyAttribute::DOMJITAttribute), &quot;DOMJITAttribute supports readonly attributes currently.&quot;);
290         bool isAccessor = entry-&gt;attributes() &amp; PropertyAttribute::CustomAccessor;
291         JSValue updateThisValue = entry-&gt;attributes() &amp; PropertyAttribute::CustomAccessor ? slot.thisValue() : JSValue(base);
292         // We need to make sure that we decide to cache this property before we potentially execute aribitrary JS.
293         if (isAccessor)
294             slot.setCustomAccessor(base, entry-&gt;propertyPutter());
295         else
296             slot.setCustomValue(base, entry-&gt;propertyPutter());
297 
<span class="line-modified">298         bool result = callCustomSetter(exec, entry-&gt;propertyPutter(), isAccessor, updateThisValue, value);</span>
299         RETURN_IF_EXCEPTION(scope, false);
300         return result;
301     }
302 
<span class="line-modified">303     return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);</span>
304 }
305 
306 /**
307  * This one is for &quot;put&quot;.
308  * It looks up a hash entry for the property to be set.  If an entry
309  * is found it sets the value and returns true, else it returns false.
310  */
<span class="line-modified">311 inline bool lookupPut(ExecState* exec, PropertyName propertyName, JSObject* base, JSValue value, const HashTable&amp; table, PutPropertySlot&amp; slot, bool&amp; putResult)</span>
312 {
313     const HashTableValue* entry = table.entry(propertyName);
314 
315     if (!entry)
316         return false;
317 
<span class="line-modified">318     putResult = putEntry(exec, table.classForThis, entry, base, base, propertyName, value, slot);</span>
319     return true;
320 }
321 
322 inline void reifyStaticProperty(VM&amp; vm, const ClassInfo* classInfo, const PropertyName&amp; propertyName, const HashTableValue&amp; value, JSObject&amp; thisObj)
323 {
324     if (value.attributes() &amp; PropertyAttribute::Builtin) {
325         if (value.attributes() &amp; PropertyAttribute::Accessor)
326             reifyStaticAccessor(vm, value, thisObj, propertyName);
327         else
328             thisObj.putDirectBuiltinFunction(vm, thisObj.globalObject(vm), propertyName, value.builtinGenerator()(vm), attributesForStructure(value.attributes()));
329         return;
330     }
331 
332     if (value.attributes() &amp; PropertyAttribute::Function) {
333         if (value.attributes() &amp; PropertyAttribute::DOMJITFunction) {
334             thisObj.putDirectNativeFunction(
335                 vm, thisObj.globalObject(vm), propertyName, value.functionLength(),
336                 value.function(), value.intrinsic(), value.signature(), attributesForStructure(value.attributes()));
337             return;
338         }
</pre>
<hr />
<pre>
344 
345     if (value.attributes() &amp; PropertyAttribute::ConstantInteger) {
346         thisObj.putDirect(vm, propertyName, jsNumber(value.constantInteger()), attributesForStructure(value.attributes()));
347         return;
348     }
349 
350     if (value.attributes() &amp; PropertyAttribute::Accessor) {
351         reifyStaticAccessor(vm, value, thisObj, propertyName);
352         return;
353     }
354 
355     if (value.attributes() &amp; PropertyAttribute::CellProperty) {
356         LazyCellProperty* property = bitwise_cast&lt;LazyCellProperty*&gt;(
357             bitwise_cast&lt;char*&gt;(&amp;thisObj) + value.lazyCellPropertyOffset());
358         JSCell* result = property-&gt;get(&amp;thisObj);
359         thisObj.putDirect(vm, propertyName, result, attributesForStructure(value.attributes()));
360         return;
361     }
362 
363     if (value.attributes() &amp; PropertyAttribute::ClassStructure) {
<span class="line-modified">364         LazyClassStructure* structure = bitwise_cast&lt;LazyClassStructure*&gt;(</span>
365             bitwise_cast&lt;char*&gt;(&amp;thisObj) + value.lazyClassStructureOffset());
<span class="line-modified">366         structure-&gt;get(jsCast&lt;JSGlobalObject*&gt;(&amp;thisObj));</span>

367         return;
368     }
369 
370     if (value.attributes() &amp; PropertyAttribute::PropertyCallback) {
371         JSValue result = value.lazyPropertyCallback()(vm, &amp;thisObj);
372         thisObj.putDirect(vm, propertyName, result, attributesForStructure(value.attributes()));
373         return;
374     }
375 
376     if (value.attributes() &amp; PropertyAttribute::DOMJITAttribute) {
377         ASSERT_WITH_MESSAGE(classInfo, &quot;DOMJITAttribute should have class info for type checking.&quot;);
378         const DOMJIT::GetterSetter* domJIT = value.domJIT();
379         auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), value.propertyPutter(), DOMAttributeAnnotation { classInfo, domJIT });
380         thisObj.putDirectCustomAccessor(vm, propertyName, customGetterSetter, attributesForStructure(value.attributes()));
381         return;
382     }
383 
384     if (value.attributes() &amp; PropertyAttribute::DOMAttribute) {
385         ASSERT_WITH_MESSAGE(classInfo, &quot;DOMAttribute should have class info for type checking.&quot;);
386         auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, value.propertyGetter(), value.propertyPutter(), DOMAttributeAnnotation { classInfo, nullptr });
387         thisObj.putDirectCustomAccessor(vm, propertyName, customGetterSetter, attributesForStructure(value.attributes()));
388         return;
389     }
390 
391     CustomGetterSetter* customGetterSetter = CustomGetterSetter::create(vm, value.propertyGetter(), value.propertyPutter());
392     thisObj.putDirectCustomAccessor(vm, propertyName, customGetterSetter, attributesForStructure(value.attributes()));
393 }
394 
395 template&lt;unsigned numberOfValues&gt;
396 inline void reifyStaticProperties(VM&amp; vm, const ClassInfo* classInfo, const HashTableValue (&amp;values)[numberOfValues], JSObject&amp; thisObj)
397 {
398     BatchedTransitionOptimizer transitionOptimizer(vm, &amp;thisObj);
399     for (auto&amp; value : values) {
400         if (!value.m_key)
401             continue;
402         auto key = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(value.m_key), strlen(value.m_key));
403         reifyStaticProperty(vm, classInfo, key, value, thisObj);
404     }
405 }
406 
<span class="line-modified">407 template&lt;RawNativeFunction nativeFunction, int length&gt; EncodedJSValue nonCachingStaticFunctionGetter(ExecState* state, EncodedJSValue, PropertyName propertyName)</span>
408 {
<span class="line-modified">409     return JSValue::encode(JSFunction::create(state-&gt;vm(), state-&gt;lexicalGlobalObject(), length, propertyName.publicName(), nativeFunction));</span>
410 }
411 
412 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 27 #include &quot;DOMJITSignature.h&quot;
 28 #include &quot;Identifier.h&quot;
 29 #include &quot;IdentifierInlines.h&quot;
 30 #include &quot;Intrinsic.h&quot;
 31 #include &quot;JSFunction.h&quot;
 32 #include &quot;JSGlobalObject.h&quot;
 33 #include &quot;LazyProperty.h&quot;
 34 #include &quot;PropertySlot.h&quot;
 35 #include &quot;PutPropertySlot.h&quot;
 36 #include &quot;TypeError.h&quot;
 37 #include &lt;wtf/Assertions.h&gt;
 38 
 39 namespace JSC {
 40 
 41 struct CompactHashIndex {
 42     const int16_t value;
 43     const int16_t next;
 44 };
 45 
 46 // FIXME: There is no reason this get function can&#39;t be simpler.
<span class="line-modified"> 47 // ie. typedef JSValue (*GetFunction)(JSGlobalObject*, JSObject* baseObject)</span>
 48 typedef PropertySlot::GetValueFunc GetFunction;
 49 typedef PutPropertySlot::PutValueFunc PutFunction;
 50 typedef FunctionExecutable* (*BuiltinGenerator)(VM&amp;);
 51 typedef JSValue (*LazyPropertyCallback)(VM&amp;, JSObject*);
 52 
 53 // Hash table generated by the create_hash_table script.
 54 struct HashTableValue {
 55     const char* m_key; // property name
 56     unsigned m_attributes; // JSObject attributes
 57     Intrinsic m_intrinsic;
 58     union ValueStorage {
 59         constexpr ValueStorage(intptr_t value1, intptr_t value2)
 60             : value1(value1)
 61             , value2(value2)
 62         { }
 63         constexpr ValueStorage(long long constant)
 64             : constant(constant)
 65         { }
 66 
 67         struct {
</pre>
<hr />
<pre>
249     }
250 
251     slot.setCacheableCustom(thisObject, attributesForStructure(entry-&gt;attributes()), entry-&gt;propertyGetter());
252     return true;
253 }
254 
255 inline bool replaceStaticPropertySlot(VM&amp; vm, JSObject* thisObject, PropertyName propertyName, JSValue value)
256 {
257     if (!thisObject-&gt;putDirect(vm, propertyName, value))
258         return false;
259 
260     if (!thisObject-&gt;staticPropertiesReified(vm))
261         thisObject-&gt;JSObject::setStructure(vm, Structure::attributeChangeTransition(vm, thisObject-&gt;structure(vm), propertyName, 0));
262 
263     return true;
264 }
265 
266 // &#39;base&#39; means the object holding the property (possibly in the prototype chain of the object put was called on).
267 // &#39;thisValue&#39; is the object that put is being applied to (in the case of a proxy, the proxy target).
268 // &#39;slot.thisValue()&#39; is the object the put was originally performed on (in the case of a proxy, the proxy itself).
<span class="line-modified">269 inline bool putEntry(JSGlobalObject* globalObject, const ClassInfo*, const HashTableValue* entry, JSObject* base, JSObject* thisValue, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
270 {
<span class="line-modified">271     VM&amp; vm = getVM(globalObject);</span>
272     auto scope = DECLARE_THROW_SCOPE(vm);
273 
274     if (entry-&gt;attributes() &amp; PropertyAttribute::BuiltinOrFunctionOrLazyProperty) {
275         if (!(entry-&gt;attributes() &amp; PropertyAttribute::ReadOnly)) {
276             // If this is a function or lazy property put then we just do the put because
277             // logically the object already had the property, so this is just a replace.
278             if (JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, thisValue))
279                 thisObject-&gt;putDirect(vm, propertyName, value);
280             return true;
281         }
<span class="line-modified">282         return typeError(globalObject, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);</span>
283     }
284 
285     if (entry-&gt;attributes() &amp; PropertyAttribute::Accessor)
<span class="line-modified">286         return typeError(globalObject, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);</span>
287 
288     if (!(entry-&gt;attributes() &amp; PropertyAttribute::ReadOnly)) {
289         ASSERT_WITH_MESSAGE(!(entry-&gt;attributes() &amp; PropertyAttribute::DOMJITAttribute), &quot;DOMJITAttribute supports readonly attributes currently.&quot;);
290         bool isAccessor = entry-&gt;attributes() &amp; PropertyAttribute::CustomAccessor;
291         JSValue updateThisValue = entry-&gt;attributes() &amp; PropertyAttribute::CustomAccessor ? slot.thisValue() : JSValue(base);
292         // We need to make sure that we decide to cache this property before we potentially execute aribitrary JS.
293         if (isAccessor)
294             slot.setCustomAccessor(base, entry-&gt;propertyPutter());
295         else
296             slot.setCustomValue(base, entry-&gt;propertyPutter());
297 
<span class="line-modified">298         bool result = callCustomSetter(globalObject, entry-&gt;propertyPutter(), isAccessor, updateThisValue, value);</span>
299         RETURN_IF_EXCEPTION(scope, false);
300         return result;
301     }
302 
<span class="line-modified">303     return typeError(globalObject, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);</span>
304 }
305 
306 /**
307  * This one is for &quot;put&quot;.
308  * It looks up a hash entry for the property to be set.  If an entry
309  * is found it sets the value and returns true, else it returns false.
310  */
<span class="line-modified">311 inline bool lookupPut(JSGlobalObject* globalObject, PropertyName propertyName, JSObject* base, JSValue value, const HashTable&amp; table, PutPropertySlot&amp; slot, bool&amp; putResult)</span>
312 {
313     const HashTableValue* entry = table.entry(propertyName);
314 
315     if (!entry)
316         return false;
317 
<span class="line-modified">318     putResult = putEntry(globalObject, table.classForThis, entry, base, base, propertyName, value, slot);</span>
319     return true;
320 }
321 
322 inline void reifyStaticProperty(VM&amp; vm, const ClassInfo* classInfo, const PropertyName&amp; propertyName, const HashTableValue&amp; value, JSObject&amp; thisObj)
323 {
324     if (value.attributes() &amp; PropertyAttribute::Builtin) {
325         if (value.attributes() &amp; PropertyAttribute::Accessor)
326             reifyStaticAccessor(vm, value, thisObj, propertyName);
327         else
328             thisObj.putDirectBuiltinFunction(vm, thisObj.globalObject(vm), propertyName, value.builtinGenerator()(vm), attributesForStructure(value.attributes()));
329         return;
330     }
331 
332     if (value.attributes() &amp; PropertyAttribute::Function) {
333         if (value.attributes() &amp; PropertyAttribute::DOMJITFunction) {
334             thisObj.putDirectNativeFunction(
335                 vm, thisObj.globalObject(vm), propertyName, value.functionLength(),
336                 value.function(), value.intrinsic(), value.signature(), attributesForStructure(value.attributes()));
337             return;
338         }
</pre>
<hr />
<pre>
344 
345     if (value.attributes() &amp; PropertyAttribute::ConstantInteger) {
346         thisObj.putDirect(vm, propertyName, jsNumber(value.constantInteger()), attributesForStructure(value.attributes()));
347         return;
348     }
349 
350     if (value.attributes() &amp; PropertyAttribute::Accessor) {
351         reifyStaticAccessor(vm, value, thisObj, propertyName);
352         return;
353     }
354 
355     if (value.attributes() &amp; PropertyAttribute::CellProperty) {
356         LazyCellProperty* property = bitwise_cast&lt;LazyCellProperty*&gt;(
357             bitwise_cast&lt;char*&gt;(&amp;thisObj) + value.lazyCellPropertyOffset());
358         JSCell* result = property-&gt;get(&amp;thisObj);
359         thisObj.putDirect(vm, propertyName, result, attributesForStructure(value.attributes()));
360         return;
361     }
362 
363     if (value.attributes() &amp; PropertyAttribute::ClassStructure) {
<span class="line-modified">364         LazyClassStructure* lazyStructure = bitwise_cast&lt;LazyClassStructure*&gt;(</span>
365             bitwise_cast&lt;char*&gt;(&amp;thisObj) + value.lazyClassStructureOffset());
<span class="line-modified">366         JSObject* constructor = lazyStructure-&gt;constructor(jsCast&lt;JSGlobalObject*&gt;(&amp;thisObj));</span>
<span class="line-added">367         thisObj.putDirect(vm, propertyName, constructor, attributesForStructure(value.attributes()));</span>
368         return;
369     }
370 
371     if (value.attributes() &amp; PropertyAttribute::PropertyCallback) {
372         JSValue result = value.lazyPropertyCallback()(vm, &amp;thisObj);
373         thisObj.putDirect(vm, propertyName, result, attributesForStructure(value.attributes()));
374         return;
375     }
376 
377     if (value.attributes() &amp; PropertyAttribute::DOMJITAttribute) {
378         ASSERT_WITH_MESSAGE(classInfo, &quot;DOMJITAttribute should have class info for type checking.&quot;);
379         const DOMJIT::GetterSetter* domJIT = value.domJIT();
380         auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), value.propertyPutter(), DOMAttributeAnnotation { classInfo, domJIT });
381         thisObj.putDirectCustomAccessor(vm, propertyName, customGetterSetter, attributesForStructure(value.attributes()));
382         return;
383     }
384 
385     if (value.attributes() &amp; PropertyAttribute::DOMAttribute) {
386         ASSERT_WITH_MESSAGE(classInfo, &quot;DOMAttribute should have class info for type checking.&quot;);
387         auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, value.propertyGetter(), value.propertyPutter(), DOMAttributeAnnotation { classInfo, nullptr });
388         thisObj.putDirectCustomAccessor(vm, propertyName, customGetterSetter, attributesForStructure(value.attributes()));
389         return;
390     }
391 
392     CustomGetterSetter* customGetterSetter = CustomGetterSetter::create(vm, value.propertyGetter(), value.propertyPutter());
393     thisObj.putDirectCustomAccessor(vm, propertyName, customGetterSetter, attributesForStructure(value.attributes()));
394 }
395 
396 template&lt;unsigned numberOfValues&gt;
397 inline void reifyStaticProperties(VM&amp; vm, const ClassInfo* classInfo, const HashTableValue (&amp;values)[numberOfValues], JSObject&amp; thisObj)
398 {
399     BatchedTransitionOptimizer transitionOptimizer(vm, &amp;thisObj);
400     for (auto&amp; value : values) {
401         if (!value.m_key)
402             continue;
403         auto key = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(value.m_key), strlen(value.m_key));
404         reifyStaticProperty(vm, classInfo, key, value, thisObj);
405     }
406 }
407 
<span class="line-modified">408 template&lt;RawNativeFunction nativeFunction, int length&gt; EncodedJSValue nonCachingStaticFunctionGetter(JSGlobalObject* globalObject, EncodedJSValue, PropertyName propertyName)</span>
409 {
<span class="line-modified">410     return JSValue::encode(JSFunction::create(globalObject-&gt;vm(), globalObject, length, propertyName.publicName(), nativeFunction));</span>
411 }
412 
413 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="LiteralParser.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MachineContext.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
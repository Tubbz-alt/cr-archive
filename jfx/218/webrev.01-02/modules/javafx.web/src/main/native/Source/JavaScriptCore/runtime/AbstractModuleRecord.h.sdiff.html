<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/AbstractModuleRecord.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AbstractModuleRecord.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ArgList.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/AbstractModuleRecord.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;Identifier.h&quot;
 29 #include &quot;JSDestructibleObject.h&quot;
 30 #include &lt;wtf/ListHashSet.h&gt;
 31 
 32 namespace JSC {
 33 
 34 class JSModuleEnvironment;
 35 class JSModuleNamespaceObject;
 36 class JSMap;
 37 
 38 // Based on the Source Text Module Record
 39 // http://www.ecma-international.org/ecma-262/6.0/#sec-source-text-module-records
<span class="line-modified"> 40 class AbstractModuleRecord : public JSDestructibleObject {</span>
 41     friend class LLIntOffsetsExtractor;
 42 public:
<span class="line-modified"> 43     typedef JSDestructibleObject Base;</span>








 44 
 45     // https://tc39.github.io/ecma262/#sec-source-text-module-records
 46     struct ExportEntry {
 47         enum class Type {
 48             Local,
 49             Indirect
 50         };
 51 
 52         static ExportEntry createLocal(const Identifier&amp; exportName, const Identifier&amp; localName);
 53         static ExportEntry createIndirect(const Identifier&amp; exportName, const Identifier&amp; importName, const Identifier&amp; moduleName);
 54 
 55         Type type;
 56         Identifier exportName;
 57         Identifier moduleName;
 58         Identifier importName;
 59         Identifier localName;
 60     };
 61 
 62     enum class ImportEntryType { Single, Namespace };
 63     struct ImportEntry {
</pre>
<hr />
<pre>
 84     const Identifier&amp; moduleKey() const { return m_moduleKey; }
 85     const OrderedIdentifierSet&amp; requestedModules() const { return m_requestedModules; }
 86     const ExportEntries&amp; exportEntries() const { return m_exportEntries; }
 87     const ImportEntries&amp; importEntries() const { return m_importEntries; }
 88     const OrderedIdentifierSet&amp; starExportEntries() const { return m_starExportEntries; }
 89 
 90     void dump();
 91 
 92     struct Resolution {
 93         enum class Type { Resolved, NotFound, Ambiguous, Error };
 94 
 95         static Resolution notFound();
 96         static Resolution error();
 97         static Resolution ambiguous();
 98 
 99         Type type;
100         AbstractModuleRecord* moduleRecord;
101         Identifier localName;
102     };
103 
<span class="line-modified">104     Resolution resolveExport(ExecState*, const Identifier&amp; exportName);</span>
<span class="line-modified">105     Resolution resolveImport(ExecState*, const Identifier&amp; localName);</span>
106 
<span class="line-modified">107     AbstractModuleRecord* hostResolveImportedModule(ExecState*, const Identifier&amp; moduleName);</span>
108 
<span class="line-modified">109     JSModuleNamespaceObject* getModuleNamespace(ExecState*);</span>
110 
111     JSModuleEnvironment* moduleEnvironment()
112     {
113         ASSERT(m_moduleEnvironment);
114         return m_moduleEnvironment.get();
115     }
116 
117     JSModuleEnvironment* moduleEnvironmentMayBeNull()
118     {
119         return m_moduleEnvironment.get();
120     }
121 
<span class="line-modified">122     void link(ExecState*, JSValue scriptFetcher);</span>
<span class="line-modified">123     JS_EXPORT_PRIVATE JSValue evaluate(ExecState*);</span>
124 
125 protected:
126     AbstractModuleRecord(VM&amp;, Structure*, const Identifier&amp;);
<span class="line-modified">127     void finishCreation(ExecState*, VM&amp;);</span>
128 
129     static void visitChildren(JSCell*, SlotVisitor&amp;);
<span class="line-removed">130     static void destroy(JSCell*);</span>
131 
132     WriteBarrier&lt;JSModuleEnvironment&gt; m_moduleEnvironment;
133 
134 private:
135     struct ResolveQuery;
<span class="line-modified">136     static Resolution resolveExportImpl(ExecState*, const ResolveQuery&amp;);</span>
137     Optional&lt;Resolution&gt; tryGetCachedResolution(UniquedStringImpl* exportName);
138     void cacheResolution(UniquedStringImpl* exportName, const Resolution&amp;);
139 
140     // The loader resolves the given module name to the module key. The module key is the unique value to represent this module.
141     Identifier m_moduleKey;
142 
143     // Currently, we don&#39;t keep the occurrence order of the import / export entries.
144     // So, we does not guarantee the order of the errors.
145     // e.g. The import declaration that occurr later than the another import declaration may
146     //      throw the error even if the former import declaration also has the invalid content.
147     //
148     //      import ... // (1) this has some invalid content.
149     //      import ... // (2) this also has some invalid content.
150     //
151     //      In the above case, (2) may throw the error earlier than (1)
152     //
153     // But, in all the cases, we will throw the syntax error. So except for the content of the syntax error,
154     // there are no difference.
155 
156     // Map localName -&gt; ImportEntry.
</pre>
</td>
<td>
<hr />
<pre>
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;Identifier.h&quot;
 29 #include &quot;JSDestructibleObject.h&quot;
 30 #include &lt;wtf/ListHashSet.h&gt;
 31 
 32 namespace JSC {
 33 
 34 class JSModuleEnvironment;
 35 class JSModuleNamespaceObject;
 36 class JSMap;
 37 
 38 // Based on the Source Text Module Record
 39 // http://www.ecma-international.org/ecma-262/6.0/#sec-source-text-module-records
<span class="line-modified"> 40 class AbstractModuleRecord : public JSNonFinalObject {</span>
 41     friend class LLIntOffsetsExtractor;
 42 public:
<span class="line-modified"> 43     using Base = JSNonFinalObject;</span>
<span class="line-added"> 44 </span>
<span class="line-added"> 45     static constexpr bool needsDestruction = true;</span>
<span class="line-added"> 46 </span>
<span class="line-added"> 47     template&lt;typename CellType, SubspaceAccess&gt;</span>
<span class="line-added"> 48     static void subspaceFor(VM&amp;)</span>
<span class="line-added"> 49     {</span>
<span class="line-added"> 50         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added"> 51     }</span>
 52 
 53     // https://tc39.github.io/ecma262/#sec-source-text-module-records
 54     struct ExportEntry {
 55         enum class Type {
 56             Local,
 57             Indirect
 58         };
 59 
 60         static ExportEntry createLocal(const Identifier&amp; exportName, const Identifier&amp; localName);
 61         static ExportEntry createIndirect(const Identifier&amp; exportName, const Identifier&amp; importName, const Identifier&amp; moduleName);
 62 
 63         Type type;
 64         Identifier exportName;
 65         Identifier moduleName;
 66         Identifier importName;
 67         Identifier localName;
 68     };
 69 
 70     enum class ImportEntryType { Single, Namespace };
 71     struct ImportEntry {
</pre>
<hr />
<pre>
 92     const Identifier&amp; moduleKey() const { return m_moduleKey; }
 93     const OrderedIdentifierSet&amp; requestedModules() const { return m_requestedModules; }
 94     const ExportEntries&amp; exportEntries() const { return m_exportEntries; }
 95     const ImportEntries&amp; importEntries() const { return m_importEntries; }
 96     const OrderedIdentifierSet&amp; starExportEntries() const { return m_starExportEntries; }
 97 
 98     void dump();
 99 
100     struct Resolution {
101         enum class Type { Resolved, NotFound, Ambiguous, Error };
102 
103         static Resolution notFound();
104         static Resolution error();
105         static Resolution ambiguous();
106 
107         Type type;
108         AbstractModuleRecord* moduleRecord;
109         Identifier localName;
110     };
111 
<span class="line-modified">112     Resolution resolveExport(JSGlobalObject*, const Identifier&amp; exportName);</span>
<span class="line-modified">113     Resolution resolveImport(JSGlobalObject*, const Identifier&amp; localName);</span>
114 
<span class="line-modified">115     AbstractModuleRecord* hostResolveImportedModule(JSGlobalObject*, const Identifier&amp; moduleName);</span>
116 
<span class="line-modified">117     JSModuleNamespaceObject* getModuleNamespace(JSGlobalObject*);</span>
118 
119     JSModuleEnvironment* moduleEnvironment()
120     {
121         ASSERT(m_moduleEnvironment);
122         return m_moduleEnvironment.get();
123     }
124 
125     JSModuleEnvironment* moduleEnvironmentMayBeNull()
126     {
127         return m_moduleEnvironment.get();
128     }
129 
<span class="line-modified">130     void link(JSGlobalObject*, JSValue scriptFetcher);</span>
<span class="line-modified">131     JS_EXPORT_PRIVATE JSValue evaluate(JSGlobalObject*);</span>
132 
133 protected:
134     AbstractModuleRecord(VM&amp;, Structure*, const Identifier&amp;);
<span class="line-modified">135     void finishCreation(JSGlobalObject*, VM&amp;);</span>
136 
137     static void visitChildren(JSCell*, SlotVisitor&amp;);

138 
139     WriteBarrier&lt;JSModuleEnvironment&gt; m_moduleEnvironment;
140 
141 private:
142     struct ResolveQuery;
<span class="line-modified">143     static Resolution resolveExportImpl(JSGlobalObject*, const ResolveQuery&amp;);</span>
144     Optional&lt;Resolution&gt; tryGetCachedResolution(UniquedStringImpl* exportName);
145     void cacheResolution(UniquedStringImpl* exportName, const Resolution&amp;);
146 
147     // The loader resolves the given module name to the module key. The module key is the unique value to represent this module.
148     Identifier m_moduleKey;
149 
150     // Currently, we don&#39;t keep the occurrence order of the import / export entries.
151     // So, we does not guarantee the order of the errors.
152     // e.g. The import declaration that occurr later than the another import declaration may
153     //      throw the error even if the former import declaration also has the invalid content.
154     //
155     //      import ... // (1) this has some invalid content.
156     //      import ... // (2) this also has some invalid content.
157     //
158     //      In the above case, (2) may throw the error earlier than (1)
159     //
160     // But, in all the cases, we will throw the syntax error. So except for the content of the syntax error,
161     // there are no difference.
162 
163     // Map localName -&gt; ImportEntry.
</pre>
</td>
</tr>
</table>
<center><a href="AbstractModuleRecord.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ArgList.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOSREntry.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGOSREntry.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
<a name="1" id="anc1"></a><span class="line-added"> 31 #include &quot;BytecodeStructs.h&quot;</span>
 32 #include &quot;CallFrame.h&quot;
 33 #include &quot;CodeBlock.h&quot;
 34 #include &quot;DFGJITCode.h&quot;
 35 #include &quot;DFGNode.h&quot;
 36 #include &quot;InterpreterInlines.h&quot;
 37 #include &quot;JIT.h&quot;
 38 #include &quot;JSCInlines.h&quot;
 39 #include &quot;VMInlines.h&quot;
 40 #include &lt;wtf/CommaPrinter.h&gt;
 41 
 42 namespace JSC { namespace DFG {
 43 
 44 void OSREntryData::dumpInContext(PrintStream&amp; out, DumpContext* context) const
 45 {
<a name="2" id="anc2"></a><span class="line-modified"> 46     out.print(m_bytecodeIndex, &quot;, machine code = &quot;, RawPointer(m_machineCode.executableAddress()));</span>
 47     out.print(&quot;, stack rules = [&quot;);
 48 
 49     auto printOperand = [&amp;] (VirtualRegister reg) {
 50         out.print(inContext(m_expectedValues.operand(reg), context), &quot; (&quot;);
 51         VirtualRegister toReg;
 52         bool overwritten = false;
 53         for (OSREntryReshuffling reshuffling : m_reshufflings) {
 54             if (reg == VirtualRegister(reshuffling.fromOffset)) {
 55                 toReg = VirtualRegister(reshuffling.toOffset);
 56                 break;
 57             }
 58             if (reg == VirtualRegister(reshuffling.toOffset))
 59                 overwritten = true;
 60         }
 61         if (!overwritten &amp;&amp; !toReg.isValid())
 62             toReg = reg;
 63         if (toReg.isValid()) {
 64             if (toReg.isLocal() &amp;&amp; !m_machineStackUsed.get(toReg.toLocal()))
 65                 out.print(&quot;ignored&quot;);
 66             else
 67                 out.print(&quot;maps to &quot;, toReg);
 68         } else
 69             out.print(&quot;overwritten&quot;);
 70         if (reg.isLocal() &amp;&amp; m_localsForcedDouble.get(reg.toLocal()))
 71             out.print(&quot;, forced double&quot;);
 72         if (reg.isLocal() &amp;&amp; m_localsForcedAnyInt.get(reg.toLocal()))
 73             out.print(&quot;, forced machine int&quot;);
 74         out.print(&quot;)&quot;);
 75     };
 76 
 77     CommaPrinter comma;
 78     for (size_t argumentIndex = m_expectedValues.numberOfArguments(); argumentIndex--;) {
 79         out.print(comma, &quot;arg&quot;, argumentIndex, &quot;:&quot;);
<a name="3" id="anc3"></a><span class="line-modified"> 80         printOperand(virtualRegisterForArgumentIncludingThis(argumentIndex));</span>
 81     }
 82     for (size_t localIndex = 0; localIndex &lt; m_expectedValues.numberOfLocals(); ++localIndex) {
 83         out.print(comma, &quot;loc&quot;, localIndex, &quot;:&quot;);
 84         printOperand(virtualRegisterForLocal(localIndex));
 85     }
 86 
 87     out.print(&quot;], machine stack used = &quot;, m_machineStackUsed);
 88 }
 89 
 90 void OSREntryData::dump(PrintStream&amp; out) const
 91 {
 92     dumpInContext(out, nullptr);
 93 }
 94 
 95 SUPPRESS_ASAN
<a name="4" id="anc4"></a><span class="line-modified"> 96 void* prepareOSREntry(VM&amp; vm, CallFrame* callFrame, CodeBlock* codeBlock, BytecodeIndex bytecodeIndex)</span>
 97 {
 98     ASSERT(JITCode::isOptimizingJIT(codeBlock-&gt;jitType()));
 99     ASSERT(codeBlock-&gt;alternative());
100     ASSERT(codeBlock-&gt;alternative()-&gt;jitType() == JITType::BaselineJIT);
101     ASSERT(!codeBlock-&gt;jitCodeMap());
102     ASSERT(codeBlock-&gt;jitCode()-&gt;dfgCommon()-&gt;isStillValid);
103 
104     if (!Options::useOSREntryToDFG())
105         return nullptr;
106 
<a name="5" id="anc5"></a><span class="line-modified">107     dataLogLnIf(Options::verboseOSR(),</span>
<span class="line-modified">108         &quot;DFG OSR in &quot;, *codeBlock-&gt;alternative(), &quot; -&gt; &quot;, *codeBlock,</span>
<span class="line-modified">109         &quot; from &quot;, bytecodeIndex);</span>




110 
111     sanitizeStackForVM(vm);
112 
113     if (bytecodeIndex)
114         codeBlock-&gt;ownerExecutable()-&gt;setDidTryToEnterInLoop(true);
115 
116     if (codeBlock-&gt;jitType() != JITType::DFGJIT) {
117         RELEASE_ASSERT(codeBlock-&gt;jitType() == JITType::FTLJIT);
118 
119         // When will this happen? We could have:
120         //
121         // - An exit from the FTL JIT into the baseline JIT followed by an attempt
122         //   to reenter. We&#39;re fine with allowing this to fail. If it happens
123         //   enough we&#39;ll just reoptimize. It basically means that the OSR exit cost
124         //   us dearly and so reoptimizing is the right thing to do.
125         //
126         // - We have recursive code with hot loops. Consider that foo has a hot loop
127         //   that calls itself. We have two foo&#39;s on the stack, lets call them foo1
128         //   and foo2, with foo1 having called foo2 from foo&#39;s hot loop. foo2 gets
129         //   optimized all the way into the FTL. Then it returns into foo1, and then
130         //   foo1 wants to get optimized. It might reach this conclusion from its
131         //   hot loop and attempt to OSR enter. And we&#39;ll tell it that it can&#39;t. It
132         //   might be worth addressing this case, but I just think this case will
133         //   be super rare. For now, if it does happen, it&#39;ll cause some compilation
134         //   thrashing.
135 
<a name="6" id="anc6"></a><span class="line-modified">136         dataLogLnIf(Options::verboseOSR(), &quot;    OSR failed because the target code block is not DFG.&quot;);</span>

137         return nullptr;
138     }
139 
140     JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
141     OSREntryData* entry = jitCode-&gt;osrEntryDataForBytecodeIndex(bytecodeIndex);
142 
143     if (!entry) {
<a name="7" id="anc7"></a><span class="line-modified">144         dataLogLnIf(Options::verboseOSR(), &quot;    OSR failed because the entrypoint was optimized out.&quot;);</span>

145         return nullptr;
146     }
147 
148     ASSERT(entry-&gt;m_bytecodeIndex == bytecodeIndex);
149 
150     // The code below checks if it is safe to perform OSR entry. It may find
151     // that it is unsafe to do so, for any number of reasons, which are documented
152     // below. If the code decides not to OSR then it returns 0, and it&#39;s the caller&#39;s
153     // responsibility to patch up the state in such a way as to ensure that it&#39;s
154     // both safe and efficient to continue executing baseline code for now. This
155     // should almost certainly include calling either codeBlock-&gt;optimizeAfterWarmUp()
156     // or codeBlock-&gt;dontOptimizeAnytimeSoon().
157 
158     // 1) Verify predictions. If the predictions are inconsistent with the actual
159     //    values, then OSR entry is not possible at this time. It&#39;s tempting to
160     //    assume that we could somehow avoid this case. We can certainly avoid it
161     //    for first-time loop OSR - that is, OSR into a CodeBlock that we have just
162     //    compiled. Then we are almost guaranteed that all of the predictions will
163     //    check out. It would be pretty easy to make that a hard guarantee. But
164     //    then there would still be the case where two call frames with the same
165     //    baseline CodeBlock are on the stack at the same time. The top one
166     //    triggers compilation and OSR. In that case, we may no longer have
167     //    accurate value profiles for the one deeper in the stack. Hence, when we
168     //    pop into the CodeBlock that is deeper on the stack, we might OSR and
169     //    realize that the predictions are wrong. Probably, in most cases, this is
170     //    just an anomaly in the sense that the older CodeBlock simply went off
171     //    into a less-likely path. So, the wisest course of action is to simply not
172     //    OSR at this time.
173 
174     for (size_t argument = 0; argument &lt; entry-&gt;m_expectedValues.numberOfArguments(); ++argument) {
175         JSValue value;
176         if (!argument)
<a name="8" id="anc8"></a><span class="line-modified">177             value = callFrame-&gt;thisValue();</span>
178         else
<a name="9" id="anc9"></a><span class="line-modified">179             value = callFrame-&gt;argument(argument - 1);</span>
180 
181         if (!entry-&gt;m_expectedValues.argument(argument).validateOSREntryValue(value, FlushedJSValue)) {
<a name="10" id="anc10"></a><span class="line-modified">182             dataLogLnIf(Options::verboseOSR(),</span>
<span class="line-modified">183                 &quot;    OSR failed because argument &quot;, argument, &quot; is &quot;, value,</span>
<span class="line-modified">184                 &quot;, expected &quot;, entry-&gt;m_expectedValues.argument(argument));</span>


185             return nullptr;
186         }
187     }
188 
189     for (size_t local = 0; local &lt; entry-&gt;m_expectedValues.numberOfLocals(); ++local) {
190         int localOffset = virtualRegisterForLocal(local).offset();
<a name="11" id="anc11"></a><span class="line-modified">191         JSValue value = callFrame-&gt;registers()[localOffset].asanUnsafeJSValue();</span>
192         FlushFormat format = FlushedJSValue;
193 
194         if (entry-&gt;m_localsForcedAnyInt.get(local)) {
195             if (!value.isAnyInt()) {
196                 dataLogLnIf(Options::verboseOSR(),
197                     &quot;    OSR failed because variable &quot;, localOffset, &quot; is &quot;,
198                     value, &quot;, expected &quot;,
199                     &quot;machine int.&quot;);
200                 return nullptr;
201             }
202             value = jsDoubleNumber(value.asAnyInt());
203             format = FlushedInt52;
204         }
205 
206         if (entry-&gt;m_localsForcedDouble.get(local)) {
207             if (!value.isNumber()) {
208                 dataLogLnIf(Options::verboseOSR(),
209                     &quot;    OSR failed because variable &quot;, localOffset, &quot; is &quot;,
210                     value, &quot;, expected number.&quot;);
211                 return nullptr;
212             }
213             value = jsDoubleNumber(value.asNumber());
214             format = FlushedDouble;
215         }
216 
217         if (!entry-&gt;m_expectedValues.local(local).validateOSREntryValue(value, format)) {
218             dataLogLnIf(Options::verboseOSR(),
219                 &quot;    OSR failed because variable &quot;, VirtualRegister(localOffset), &quot; is &quot;,
220                 value, &quot;, expected &quot;,
221                 entry-&gt;m_expectedValues.local(local), &quot;.&quot;);
222             return nullptr;
223         }
224     }
225 
226     // 2) Check the stack height. The DFG JIT may require a taller stack than the
227     //    baseline JIT, in some cases. If we can&#39;t grow the stack, then don&#39;t do
228     //    OSR right now. That&#39;s the only option we have unless we want basic block
229     //    boundaries to start throwing RangeErrors. Although that would be possible,
230     //    it seems silly: you&#39;d be diverting the program to error handling when it
231     //    would have otherwise just kept running albeit less quickly.
232 
233     unsigned frameSizeForCheck = jitCode-&gt;common.requiredRegisterCountForExecutionAndExit();
<a name="12" id="anc12"></a><span class="line-modified">234     if (UNLIKELY(!vm.ensureStackCapacityFor(&amp;callFrame-&gt;registers()[virtualRegisterForLocal(frameSizeForCheck - 1).offset()]))) {</span>
<span class="line-modified">235         dataLogLnIf(Options::verboseOSR(), &quot;    OSR failed because stack growth failed.&quot;);</span>

236         return nullptr;
237     }
238 
<a name="13" id="anc13"></a><span class="line-modified">239     dataLogLnIf(Options::verboseOSR(), &quot;    OSR should succeed.&quot;);</span>

240 
241     // At this point we&#39;re committed to entering. We will do some work to set things up,
242     // but we also rely on our caller recognizing that when we return a non-null pointer,
243     // that means that we&#39;re already past the point of no return and we must succeed at
244     // entering.
245 
246     // 3) Set up the data in the scratch buffer and perform data format conversions.
247 
248     unsigned frameSize = jitCode-&gt;common.frameRegisterCount;
249     unsigned baselineFrameSize = entry-&gt;m_expectedValues.numberOfLocals();
250     unsigned maxFrameSize = std::max(frameSize, baselineFrameSize);
251 
252     Register* scratch = bitwise_cast&lt;Register*&gt;(vm.scratchBufferForSize(sizeof(Register) * (2 + CallFrame::headerSizeInRegisters + maxFrameSize))-&gt;dataBuffer());
253 
254     *bitwise_cast&lt;size_t*&gt;(scratch + 0) = frameSize;
255 
256     void* targetPC = entry-&gt;m_machineCode.executableAddress();
257     RELEASE_ASSERT(codeBlock-&gt;jitCode()-&gt;contains(entry-&gt;m_machineCode.untaggedExecutableAddress()));
<a name="14" id="anc14"></a><span class="line-modified">258     dataLogLnIf(Options::verboseOSR(), &quot;    OSR using target PC &quot;, RawPointer(targetPC));</span>

259     RELEASE_ASSERT(targetPC);
<a name="15" id="anc15"></a><span class="line-modified">260     *bitwise_cast&lt;void**&gt;(scratch + 1) = retagCodePtr(targetPC, OSREntryPtrTag, bitwise_cast&lt;PtrTag&gt;(callFrame));</span>
261 
262     Register* pivot = scratch + 2 + CallFrame::headerSizeInRegisters;
263 
264     for (int index = -CallFrame::headerSizeInRegisters; index &lt; static_cast&lt;int&gt;(baselineFrameSize); ++index) {
265         VirtualRegister reg(-1 - index);
266 
267         if (reg.isLocal()) {
268             if (entry-&gt;m_localsForcedDouble.get(reg.toLocal())) {
<a name="16" id="anc16"></a><span class="line-modified">269                 *bitwise_cast&lt;double*&gt;(pivot + index) = callFrame-&gt;registers()[reg.offset()].asanUnsafeJSValue().asNumber();</span>
270                 continue;
271             }
272 
273             if (entry-&gt;m_localsForcedAnyInt.get(reg.toLocal())) {
<a name="17" id="anc17"></a><span class="line-modified">274                 *bitwise_cast&lt;int64_t*&gt;(pivot + index) = callFrame-&gt;registers()[reg.offset()].asanUnsafeJSValue().asAnyInt() &lt;&lt; JSValue::int52ShiftAmount;</span>
275                 continue;
276             }
277         }
278 
<a name="18" id="anc18"></a><span class="line-modified">279         pivot[index] = callFrame-&gt;registers()[reg.offset()].asanUnsafeJSValue();</span>
280     }
281 
282     // 4) Reshuffle those registers that need reshuffling.
283     Vector&lt;JSValue&gt; temporaryLocals(entry-&gt;m_reshufflings.size());
284     for (unsigned i = entry-&gt;m_reshufflings.size(); i--;)
285         temporaryLocals[i] = pivot[VirtualRegister(entry-&gt;m_reshufflings[i].fromOffset).toLocal()].asanUnsafeJSValue();
286     for (unsigned i = entry-&gt;m_reshufflings.size(); i--;)
287         pivot[VirtualRegister(entry-&gt;m_reshufflings[i].toOffset).toLocal()] = temporaryLocals[i];
288 
289     // 5) Clear those parts of the call frame that the DFG ain&#39;t using. This helps GC on
290     //    some programs by eliminating some stale pointer pathologies.
291     for (unsigned i = frameSize; i--;) {
292         if (entry-&gt;m_machineStackUsed.get(i))
293             continue;
294         pivot[i] = JSValue();
295     }
296 
297     // 6) Copy our callee saves to buffer.
298 #if NUMBER_OF_CALLEE_SAVES_REGISTERS &gt; 0
299     const RegisterAtOffsetList* registerSaveLocations = codeBlock-&gt;calleeSaveRegisters();
300     RegisterAtOffsetList* allCalleeSaves = RegisterSet::vmCalleeSaveRegisterOffsets();
301     RegisterSet dontSaveRegisters = RegisterSet(RegisterSet::stackRegisters(), RegisterSet::allFPRs());
302 
303     unsigned registerCount = registerSaveLocations-&gt;size();
304     VMEntryRecord* record = vmEntryRecord(vm.topEntryFrame);
305     for (unsigned i = 0; i &lt; registerCount; i++) {
306         RegisterAtOffset currentEntry = registerSaveLocations-&gt;at(i);
307         if (dontSaveRegisters.get(currentEntry.reg()))
308             continue;
309         RegisterAtOffset* calleeSavesEntry = allCalleeSaves-&gt;find(currentEntry.reg());
310 
<a name="19" id="anc19"></a><span class="line-modified">311         if constexpr (CallerFrameAndPC::sizeInRegisters == 2)</span>
<span class="line-added">312             *(bitwise_cast&lt;intptr_t*&gt;(pivot - 1) - currentEntry.offsetAsIndex()) = record-&gt;calleeSaveRegistersBuffer[calleeSavesEntry-&gt;offsetAsIndex()];</span>
<span class="line-added">313         else {</span>
<span class="line-added">314             // We need to adjust 4-bytes on 32-bits, otherwise we will clobber some parts of</span>
<span class="line-added">315             // pivot[-1] when currentEntry.offsetAsIndex() returns -1. This region contains</span>
<span class="line-added">316             // CallerFrameAndPC and if it is cloberred, we will have a corrupted stack.</span>
<span class="line-added">317             // Also, we need to store callee-save registers swapped in pairs on scratch buffer,</span>
<span class="line-added">318             // otherwise they will be swapped when copied to call frame during OSR Entry code.</span>
<span class="line-added">319             // Here is how we would like to have the buffer configured:</span>
<span class="line-added">320             //</span>
<span class="line-added">321             // pivot[-4] = ArgumentCountIncludingThis</span>
<span class="line-added">322             // pivot[-3] = Callee</span>
<span class="line-added">323             // pivot[-2] = CodeBlock</span>
<span class="line-added">324             // pivot[-1] = CallerFrameAndReturnPC</span>
<span class="line-added">325             // pivot[0]  = csr1/csr0</span>
<span class="line-added">326             // pivot[1]  = csr3/csr2</span>
<span class="line-added">327             // ...</span>
<span class="line-added">328             ASSERT(sizeof(intptr_t) == 4);</span>
<span class="line-added">329             ASSERT(CallerFrameAndPC::sizeInRegisters == 1);</span>
<span class="line-added">330             ASSERT(currentEntry.offsetAsIndex() &lt; 0);</span>
<span class="line-added">331 </span>
<span class="line-added">332             int offsetAsIndex = currentEntry.offsetAsIndex();</span>
<span class="line-added">333             int properIndex = offsetAsIndex % 2 ? offsetAsIndex - 1 : offsetAsIndex + 1;</span>
<span class="line-added">334             *(bitwise_cast&lt;intptr_t*&gt;(pivot - 1) + 1 - properIndex) = record-&gt;calleeSaveRegistersBuffer[calleeSavesEntry-&gt;offsetAsIndex()];</span>
<span class="line-added">335         }</span>
336     }
337 #endif
338 
339     // 7) Fix the call frame to have the right code block.
340 
<a name="20" id="anc20"></a><span class="line-modified">341     *bitwise_cast&lt;CodeBlock**&gt;(pivot - (CallFrameSlot::codeBlock + 1)) = codeBlock;</span>
342 
<a name="21" id="anc21"></a><span class="line-modified">343     dataLogLnIf(Options::verboseOSR(), &quot;    OSR returning data buffer &quot;, RawPointer(scratch));</span>

344     return scratch;
345 }
346 
<a name="22" id="anc22"></a><span class="line-modified">347 MacroAssemblerCodePtr&lt;ExceptionHandlerPtrTag&gt; prepareCatchOSREntry(VM&amp; vm, CallFrame* callFrame, CodeBlock* baselineCodeBlock, CodeBlock* optimizedCodeBlock, BytecodeIndex bytecodeIndex)</span>
348 {
<a name="23" id="anc23"></a><span class="line-modified">349     ASSERT(optimizedCodeBlock-&gt;jitType() == JITType::DFGJIT || optimizedCodeBlock-&gt;jitType() == JITType::FTLJIT);</span>
<span class="line-modified">350     ASSERT(optimizedCodeBlock-&gt;jitCode()-&gt;dfgCommon()-&gt;isStillValid);</span>
351 
<a name="24" id="anc24"></a><span class="line-modified">352     if (!Options::useOSREntryToDFG() &amp;&amp; optimizedCodeBlock-&gt;jitCode()-&gt;jitType() == JITType::DFGJIT)</span>
353         return nullptr;
<a name="25" id="anc25"></a><span class="line-modified">354     if (!Options::useOSREntryToFTL() &amp;&amp; optimizedCodeBlock-&gt;jitCode()-&gt;jitType() == JITType::FTLJIT)</span>
355         return nullptr;
356 
<a name="26" id="anc26"></a><span class="line-modified">357     CommonData* dfgCommon = optimizedCodeBlock-&gt;jitCode()-&gt;dfgCommon();</span>


358     RELEASE_ASSERT(dfgCommon);
359     DFG::CatchEntrypointData* catchEntrypoint = dfgCommon-&gt;catchOSREntryDataForBytecodeIndex(bytecodeIndex);
360     if (!catchEntrypoint) {
361         // This can be null under some circumstances. The most common is that we didn&#39;t
362         // compile this op_catch as an entrypoint since it had never executed when starting
363         // the compilation.
364         return nullptr;
365     }
366 
367     // We&#39;re only allowed to OSR enter if we&#39;ve proven we have compatible argument types.
368     for (unsigned argument = 0; argument &lt; catchEntrypoint-&gt;argumentFormats.size(); ++argument) {
<a name="27" id="anc27"></a><span class="line-modified">369         JSValue value = callFrame-&gt;uncheckedR(virtualRegisterForArgumentIncludingThis(argument)).jsValue();</span>
370         switch (catchEntrypoint-&gt;argumentFormats[argument]) {
371         case DFG::FlushedInt32:
372             if (!value.isInt32())
373                 return nullptr;
374             break;
375         case DFG::FlushedCell:
376             if (!value.isCell())
377                 return nullptr;
378             break;
379         case DFG::FlushedBoolean:
380             if (!value.isBoolean())
381                 return nullptr;
382             break;
383         case DFG::DeadFlush:
384             // This means the argument is not alive. Therefore, it&#39;s allowed to be any type.
385             break;
386         case DFG::FlushedJSValue:
387             // An argument is trivially a JSValue.
388             break;
389         default:
390             RELEASE_ASSERT_NOT_REACHED();
391         }
392     }
393 
394     unsigned frameSizeForCheck = dfgCommon-&gt;requiredRegisterCountForExecutionAndExit();
<a name="28" id="anc28"></a><span class="line-modified">395     if (UNLIKELY(!vm.ensureStackCapacityFor(&amp;callFrame-&gt;registers()[virtualRegisterForLocal(frameSizeForCheck).offset()])))</span>
396         return nullptr;
397 
<a name="29" id="anc29"></a><span class="line-modified">398     auto instruction = baselineCodeBlock-&gt;instructions().at(callFrame-&gt;bytecodeIndex());</span>
399     ASSERT(instruction-&gt;is&lt;OpCatch&gt;());
<a name="30" id="anc30"></a><span class="line-modified">400     ValueProfileAndVirtualRegisterBuffer* buffer = instruction-&gt;as&lt;OpCatch&gt;().metadata(baselineCodeBlock).m_buffer;</span>
401     JSValue* dataBuffer = reinterpret_cast&lt;JSValue*&gt;(dfgCommon-&gt;catchOSREntryBuffer-&gt;dataBuffer());
402     unsigned index = 0;
<a name="31" id="anc31"></a><span class="line-modified">403     buffer-&gt;forEach([&amp;] (ValueProfileAndVirtualRegister&amp; profile) {</span>
404         if (!VirtualRegister(profile.m_operand).isLocal())
405             return;
<a name="32" id="anc32"></a><span class="line-modified">406         dataBuffer[index] = callFrame-&gt;uncheckedR(profile.m_operand).jsValue();</span>
407         ++index;
408     });
409 
410     // The active length of catchOSREntryBuffer will be zeroed by ClearCatchLocals node.
411     dfgCommon-&gt;catchOSREntryBuffer-&gt;setActiveLength(sizeof(JSValue) * index);
412     return catchEntrypoint-&gt;machineCode;
413 }
414 
415 } } // namespace JSC::DFG
416 
417 #endif // ENABLE(DFG_JIT)
<a name="33" id="anc33"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="33" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/RTCPeerConnection.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RTCPeerConnection.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RTCPeerConnection.idl.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/RTCPeerConnection.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 79 {
 80     WTF_MAKE_ISO_ALLOCATED(RTCPeerConnection);
 81 public:
 82     static Ref&lt;RTCPeerConnection&gt; create(ScriptExecutionContext&amp;);
 83     virtual ~RTCPeerConnection();
 84 
 85     using DataChannelInit = RTCDataChannelInit;
 86 
 87     ExceptionOr&lt;void&gt; initializeWith(Document&amp;, RTCConfiguration&amp;&amp;);
 88 
 89     struct CertificateParameters {
 90         String name;
 91         String hash;
 92         String namedCurve;
 93         Optional&lt;uint32_t&gt; modulusLength;
 94         RefPtr&lt;Uint8Array&gt; publicExponent;
 95         Optional&lt;double&gt; expires;
 96     };
 97 
 98     using AlgorithmIdentifier = Variant&lt;JSC::Strong&lt;JSC::JSObject&gt;, String&gt;;
<span class="line-modified"> 99     static void generateCertificate(JSC::ExecState&amp;, AlgorithmIdentifier&amp;&amp;, DOMPromiseDeferred&lt;IDLInterface&lt;RTCCertificate&gt;&gt;&amp;&amp;);</span>
100 
101     // 4.3.2 RTCPeerConnection Interface
102     void queuedCreateOffer(RTCOfferOptions&amp;&amp;, PeerConnection::SessionDescriptionPromise&amp;&amp;);
103     void queuedCreateAnswer(RTCAnswerOptions&amp;&amp;, PeerConnection::SessionDescriptionPromise&amp;&amp;);
104 
105     void queuedSetLocalDescription(RTCSessionDescription&amp;, DOMPromiseDeferred&lt;void&gt;&amp;&amp;);
106     RefPtr&lt;RTCSessionDescription&gt; localDescription() const;
107     RefPtr&lt;RTCSessionDescription&gt; currentLocalDescription() const;
108     RefPtr&lt;RTCSessionDescription&gt; pendingLocalDescription() const;
109 
110     void queuedSetRemoteDescription(RTCSessionDescription&amp;, DOMPromiseDeferred&lt;void&gt;&amp;&amp;);
111     RefPtr&lt;RTCSessionDescription&gt; remoteDescription() const;
112     RefPtr&lt;RTCSessionDescription&gt; currentRemoteDescription() const;
113     RefPtr&lt;RTCSessionDescription&gt; pendingRemoteDescription() const;
114 
115     void queuedAddIceCandidate(RTCIceCandidate*, DOMPromiseDeferred&lt;void&gt;&amp;&amp;);
116 
117     RTCSignalingState signalingState() const { return m_signalingState; }
118     RTCIceGatheringState iceGatheringState() const { return m_iceGatheringState; }
119     RTCIceConnectionState iceConnectionState() const { return m_iceConnectionState; }
</pre>
<hr />
<pre>
125 
126     bool isClosed() const { return m_connectionState == RTCPeerConnectionState::Closed; }
127     bool isStopped() const { return m_isStopped; }
128 
129     void addInternalTransceiver(Ref&lt;RTCRtpTransceiver&gt;&amp;&amp; transceiver) { m_transceiverSet-&gt;append(WTFMove(transceiver)); }
130 
131     // 5.1 RTCPeerConnection extensions
132     Vector&lt;std::reference_wrapper&lt;RTCRtpSender&gt;&gt; getSenders() const;
133     Vector&lt;std::reference_wrapper&lt;RTCRtpReceiver&gt;&gt; getReceivers() const;
134     const Vector&lt;RefPtr&lt;RTCRtpTransceiver&gt;&gt;&amp; getTransceivers() const;
135 
136     const Vector&lt;RefPtr&lt;RTCRtpTransceiver&gt;&gt;&amp; currentTransceivers() const { return m_transceiverSet-&gt;list(); }
137 
138     ExceptionOr&lt;Ref&lt;RTCRtpSender&gt;&gt; addTrack(Ref&lt;MediaStreamTrack&gt;&amp;&amp;, const Vector&lt;std::reference_wrapper&lt;MediaStream&gt;&gt;&amp;);
139     ExceptionOr&lt;void&gt; removeTrack(RTCRtpSender&amp;);
140 
141     using AddTransceiverTrackOrKind = Variant&lt;RefPtr&lt;MediaStreamTrack&gt;, String&gt;;
142     ExceptionOr&lt;Ref&lt;RTCRtpTransceiver&gt;&gt; addTransceiver(AddTransceiverTrackOrKind&amp;&amp;, const RTCRtpTransceiverInit&amp;);
143 
144     // 6.1 Peer-to-peer data API
<span class="line-modified">145     ExceptionOr&lt;Ref&lt;RTCDataChannel&gt;&gt; createDataChannel(ScriptExecutionContext&amp;, String&amp;&amp;, RTCDataChannelInit&amp;&amp;);</span>
146 
147     // 8.2 Statistics API
148     void getStats(MediaStreamTrack*, Ref&lt;DeferredPromise&gt;&amp;&amp;);
149 
150     // EventTarget
151     EventTargetInterface eventTargetInterface() const final { return RTCPeerConnectionEventTargetInterfaceType; }
152     ScriptExecutionContext* scriptExecutionContext() const final { return ActiveDOMObject::scriptExecutionContext(); }
153 
154     using RefCounted::ref;
155     using RefCounted::deref;
156 
157     // Used for testing with a mock
158     WEBCORE_EXPORT void emulatePlatformEvent(const String&amp; action);
159 
160     // API used by PeerConnectionBackend and relatives
161     void addTransceiver(Ref&lt;RTCRtpTransceiver&gt;&amp;&amp;);
162     void setSignalingState(RTCSignalingState);
163     void updateIceGatheringState(RTCIceGatheringState);
164     void updateIceConnectionState(RTCIceConnectionState);
165 
166     void scheduleNegotiationNeededEvent();
167 
<span class="line-modified">168     void fireEvent(Event&amp;);</span>
169 
170     void disableICECandidateFiltering() { m_backend-&gt;disableICECandidateFiltering(); }
171     void enableICECandidateFiltering() { m_backend-&gt;enableICECandidateFiltering(); }
172 
173     void clearController() { m_controller = nullptr; }
174 
175     // ActiveDOMObject.
176     bool hasPendingActivity() const final;
177 




178 #if !RELEASE_LOG_DISABLED
179     const Logger&amp; logger() const final { return m_logger.get(); }
180     const void* logIdentifier() const final { return m_logIdentifier; }
181     const char* logClassName() const final { return &quot;RTCPeerConnection&quot;; }
182     WTFLogChannel&amp; logChannel() const final;
183 #endif
184 
185 private:
<span class="line-modified">186     RTCPeerConnection(ScriptExecutionContext&amp;);</span>





187 
188     ExceptionOr&lt;void&gt; initializeConfiguration(RTCConfiguration&amp;&amp;);
189     Ref&lt;RTCRtpTransceiver&gt; completeAddTransceiver(Ref&lt;RTCRtpSender&gt;&amp;&amp;, const RTCRtpTransceiverInit&amp;, const String&amp; trackId, const String&amp; trackKind);
190 
191     void registerToController(RTCController&amp;);
192     void unregisterFromController();
193 
194     friend class Internals;
195     void applyRotationForOutgoingVideoSources() { m_backend-&gt;applyRotationForOutgoingVideoSources(); }
196 
197     // EventTarget implementation.
198     void refEventTarget() final { ref(); }
199     void derefEventTarget() final { deref(); }
200     void dispatchEvent(Event&amp;) final;
201 
202     // ActiveDOMObject
203     WEBCORE_EXPORT void stop() final;
204     const char* activeDOMObjectName() const final;
<span class="line-modified">205     bool canSuspendForDocumentSuspension() const final;</span>

206 
207     void updateConnectionState();
208     bool doClose();
209     void doStop();
210 
211     ExceptionOr&lt;Vector&lt;MediaEndpointConfiguration::CertificatePEM&gt;&gt; certificatesFromConfiguration(const RTCConfiguration&amp;);
212 
213     bool m_isStopped { false };
214     RTCSignalingState m_signalingState { RTCSignalingState::Stable };
215     RTCIceGatheringState m_iceGatheringState { RTCIceGatheringState::New };
216     RTCIceConnectionState m_iceConnectionState { RTCIceConnectionState::New };
217     RTCPeerConnectionState m_connectionState { RTCPeerConnectionState::New };
218 
219 #if !RELEASE_LOG_DISABLED
220     Ref&lt;const Logger&gt; m_logger;
221     const void* m_logIdentifier;
222 #endif
223 
224     std::unique_ptr&lt;RtpTransceiverSet&gt; m_transceiverSet { std::unique_ptr&lt;RtpTransceiverSet&gt;(new RtpTransceiverSet()) };
225 
226     std::unique_ptr&lt;PeerConnectionBackend&gt; m_backend;
227 
228     RTCConfiguration m_configuration;
229     RTCController* m_controller { nullptr };
230     Vector&lt;RefPtr&lt;RTCCertificate&gt;&gt; m_certificates;
<span class="line-modified">231     RefPtr&lt;PendingActivity&lt;RTCPeerConnection&gt;&gt; m_pendingActivity;</span>

232 };
233 
234 } // namespace WebCore
235 
236 #endif // ENABLE(WEB_RTC)
</pre>
</td>
<td>
<hr />
<pre>
 79 {
 80     WTF_MAKE_ISO_ALLOCATED(RTCPeerConnection);
 81 public:
 82     static Ref&lt;RTCPeerConnection&gt; create(ScriptExecutionContext&amp;);
 83     virtual ~RTCPeerConnection();
 84 
 85     using DataChannelInit = RTCDataChannelInit;
 86 
 87     ExceptionOr&lt;void&gt; initializeWith(Document&amp;, RTCConfiguration&amp;&amp;);
 88 
 89     struct CertificateParameters {
 90         String name;
 91         String hash;
 92         String namedCurve;
 93         Optional&lt;uint32_t&gt; modulusLength;
 94         RefPtr&lt;Uint8Array&gt; publicExponent;
 95         Optional&lt;double&gt; expires;
 96     };
 97 
 98     using AlgorithmIdentifier = Variant&lt;JSC::Strong&lt;JSC::JSObject&gt;, String&gt;;
<span class="line-modified"> 99     static void generateCertificate(JSC::JSGlobalObject&amp;, AlgorithmIdentifier&amp;&amp;, DOMPromiseDeferred&lt;IDLInterface&lt;RTCCertificate&gt;&gt;&amp;&amp;);</span>
100 
101     // 4.3.2 RTCPeerConnection Interface
102     void queuedCreateOffer(RTCOfferOptions&amp;&amp;, PeerConnection::SessionDescriptionPromise&amp;&amp;);
103     void queuedCreateAnswer(RTCAnswerOptions&amp;&amp;, PeerConnection::SessionDescriptionPromise&amp;&amp;);
104 
105     void queuedSetLocalDescription(RTCSessionDescription&amp;, DOMPromiseDeferred&lt;void&gt;&amp;&amp;);
106     RefPtr&lt;RTCSessionDescription&gt; localDescription() const;
107     RefPtr&lt;RTCSessionDescription&gt; currentLocalDescription() const;
108     RefPtr&lt;RTCSessionDescription&gt; pendingLocalDescription() const;
109 
110     void queuedSetRemoteDescription(RTCSessionDescription&amp;, DOMPromiseDeferred&lt;void&gt;&amp;&amp;);
111     RefPtr&lt;RTCSessionDescription&gt; remoteDescription() const;
112     RefPtr&lt;RTCSessionDescription&gt; currentRemoteDescription() const;
113     RefPtr&lt;RTCSessionDescription&gt; pendingRemoteDescription() const;
114 
115     void queuedAddIceCandidate(RTCIceCandidate*, DOMPromiseDeferred&lt;void&gt;&amp;&amp;);
116 
117     RTCSignalingState signalingState() const { return m_signalingState; }
118     RTCIceGatheringState iceGatheringState() const { return m_iceGatheringState; }
119     RTCIceConnectionState iceConnectionState() const { return m_iceConnectionState; }
</pre>
<hr />
<pre>
125 
126     bool isClosed() const { return m_connectionState == RTCPeerConnectionState::Closed; }
127     bool isStopped() const { return m_isStopped; }
128 
129     void addInternalTransceiver(Ref&lt;RTCRtpTransceiver&gt;&amp;&amp; transceiver) { m_transceiverSet-&gt;append(WTFMove(transceiver)); }
130 
131     // 5.1 RTCPeerConnection extensions
132     Vector&lt;std::reference_wrapper&lt;RTCRtpSender&gt;&gt; getSenders() const;
133     Vector&lt;std::reference_wrapper&lt;RTCRtpReceiver&gt;&gt; getReceivers() const;
134     const Vector&lt;RefPtr&lt;RTCRtpTransceiver&gt;&gt;&amp; getTransceivers() const;
135 
136     const Vector&lt;RefPtr&lt;RTCRtpTransceiver&gt;&gt;&amp; currentTransceivers() const { return m_transceiverSet-&gt;list(); }
137 
138     ExceptionOr&lt;Ref&lt;RTCRtpSender&gt;&gt; addTrack(Ref&lt;MediaStreamTrack&gt;&amp;&amp;, const Vector&lt;std::reference_wrapper&lt;MediaStream&gt;&gt;&amp;);
139     ExceptionOr&lt;void&gt; removeTrack(RTCRtpSender&amp;);
140 
141     using AddTransceiverTrackOrKind = Variant&lt;RefPtr&lt;MediaStreamTrack&gt;, String&gt;;
142     ExceptionOr&lt;Ref&lt;RTCRtpTransceiver&gt;&gt; addTransceiver(AddTransceiverTrackOrKind&amp;&amp;, const RTCRtpTransceiverInit&amp;);
143 
144     // 6.1 Peer-to-peer data API
<span class="line-modified">145     ExceptionOr&lt;Ref&lt;RTCDataChannel&gt;&gt; createDataChannel(String&amp;&amp;, RTCDataChannelInit&amp;&amp;);</span>
146 
147     // 8.2 Statistics API
148     void getStats(MediaStreamTrack*, Ref&lt;DeferredPromise&gt;&amp;&amp;);
149 
150     // EventTarget
151     EventTargetInterface eventTargetInterface() const final { return RTCPeerConnectionEventTargetInterfaceType; }
152     ScriptExecutionContext* scriptExecutionContext() const final { return ActiveDOMObject::scriptExecutionContext(); }
153 
154     using RefCounted::ref;
155     using RefCounted::deref;
156 
157     // Used for testing with a mock
158     WEBCORE_EXPORT void emulatePlatformEvent(const String&amp; action);
159 
160     // API used by PeerConnectionBackend and relatives
161     void addTransceiver(Ref&lt;RTCRtpTransceiver&gt;&amp;&amp;);
162     void setSignalingState(RTCSignalingState);
163     void updateIceGatheringState(RTCIceGatheringState);
164     void updateIceConnectionState(RTCIceConnectionState);
165 
166     void scheduleNegotiationNeededEvent();
167 
<span class="line-modified">168     void dispatchEventWhenFeasible(Ref&lt;Event&gt;&amp;&amp;);</span>
169 
170     void disableICECandidateFiltering() { m_backend-&gt;disableICECandidateFiltering(); }
171     void enableICECandidateFiltering() { m_backend-&gt;enableICECandidateFiltering(); }
172 
173     void clearController() { m_controller = nullptr; }
174 
175     // ActiveDOMObject.
176     bool hasPendingActivity() const final;
177 
<span class="line-added">178     Document* document();</span>
<span class="line-added">179 </span>
<span class="line-added">180     void doTask(Function&lt;void()&gt;&amp;&amp;);</span>
<span class="line-added">181 </span>
182 #if !RELEASE_LOG_DISABLED
183     const Logger&amp; logger() const final { return m_logger.get(); }
184     const void* logIdentifier() const final { return m_logIdentifier; }
185     const char* logClassName() const final { return &quot;RTCPeerConnection&quot;; }
186     WTFLogChannel&amp; logChannel() const final;
187 #endif
188 
189 private:
<span class="line-modified">190     template&lt;typename PromiseType&gt; void addPendingPromise(PromiseType&amp; promise)</span>
<span class="line-added">191     {</span>
<span class="line-added">192         promise.whenSettled([pendingActivity = makePendingActivity(*this)] { });</span>
<span class="line-added">193     }</span>
<span class="line-added">194 </span>
<span class="line-added">195     RTCPeerConnection(Document&amp;);</span>
196 
197     ExceptionOr&lt;void&gt; initializeConfiguration(RTCConfiguration&amp;&amp;);
198     Ref&lt;RTCRtpTransceiver&gt; completeAddTransceiver(Ref&lt;RTCRtpSender&gt;&amp;&amp;, const RTCRtpTransceiverInit&amp;, const String&amp; trackId, const String&amp; trackKind);
199 
200     void registerToController(RTCController&amp;);
201     void unregisterFromController();
202 
203     friend class Internals;
204     void applyRotationForOutgoingVideoSources() { m_backend-&gt;applyRotationForOutgoingVideoSources(); }
205 
206     // EventTarget implementation.
207     void refEventTarget() final { ref(); }
208     void derefEventTarget() final { deref(); }
209     void dispatchEvent(Event&amp;) final;
210 
211     // ActiveDOMObject
212     WEBCORE_EXPORT void stop() final;
213     const char* activeDOMObjectName() const final;
<span class="line-modified">214     void suspend(ReasonForSuspension) final;</span>
<span class="line-added">215     void resume() final;</span>
216 
217     void updateConnectionState();
218     bool doClose();
219     void doStop();
220 
221     ExceptionOr&lt;Vector&lt;MediaEndpointConfiguration::CertificatePEM&gt;&gt; certificatesFromConfiguration(const RTCConfiguration&amp;);
222 
223     bool m_isStopped { false };
224     RTCSignalingState m_signalingState { RTCSignalingState::Stable };
225     RTCIceGatheringState m_iceGatheringState { RTCIceGatheringState::New };
226     RTCIceConnectionState m_iceConnectionState { RTCIceConnectionState::New };
227     RTCPeerConnectionState m_connectionState { RTCPeerConnectionState::New };
228 
229 #if !RELEASE_LOG_DISABLED
230     Ref&lt;const Logger&gt; m_logger;
231     const void* m_logIdentifier;
232 #endif
233 
234     std::unique_ptr&lt;RtpTransceiverSet&gt; m_transceiverSet { std::unique_ptr&lt;RtpTransceiverSet&gt;(new RtpTransceiverSet()) };
235 
236     std::unique_ptr&lt;PeerConnectionBackend&gt; m_backend;
237 
238     RTCConfiguration m_configuration;
239     RTCController* m_controller { nullptr };
240     Vector&lt;RefPtr&lt;RTCCertificate&gt;&gt; m_certificates;
<span class="line-modified">241     bool m_shouldDelayTasks { false };</span>
<span class="line-added">242     Vector&lt;Function&lt;void()&gt;&gt; m_pendingTasks;</span>
243 };
244 
245 } // namespace WebCore
246 
247 #endif // ENABLE(WEB_RTC)
</pre>
</td>
</tr>
</table>
<center><a href="RTCPeerConnection.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RTCPeerConnection.idl.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutFunctions.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SimpleLineLayoutCoverage.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SimpleLineLayoutFunctions.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutFunctions.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
114         }
115     }
116 
117     LayoutRect paintRect = paintInfo.rect;
118     paintRect.moveBy(-paintOffset);
119 
120     auto&amp; resolver = layout.runResolver();
121     float deviceScaleFactor = flow.document().deviceScaleFactor();
122     for (auto run : resolver.rangeForRect(paintRect)) {
123         if (run.start() == run.end())
124             continue;
125 
126         FloatRect rect = run.rect();
127         FloatRect visualOverflowRect = computeOverflow(flow, rect);
128         if (paintRect.y() &gt; visualOverflowRect.maxY() || paintRect.maxY() &lt; visualOverflowRect.y())
129             continue;
130 
131         String textWithHyphen;
132         if (run.hasHyphen())
133             textWithHyphen = run.textWithHyphen();
<span class="line-modified">134         // x position indicates the line offset from the rootbox. It&#39;s always 0 in case of simple line layout.</span>
<span class="line-modified">135         TextRun textRun { run.hasHyphen() ? textWithHyphen : run.text(), 0, run.expansion(), run.expansionBehavior() };</span>


136         textRun.setTabSize(!style.collapseWhiteSpace(), style.tabSize());
137         FloatPoint textOrigin { rect.x() + paintOffset.x(), roundToDevicePixel(run.baselinePosition() + paintOffset.y(), deviceScaleFactor) };
138 
139         textPainter.setGlyphDisplayListIfNeeded(run.simpleRun(), paintInfo, style.fontCascade(), paintInfo.context(), textRun);
140         textPainter.paint(textRun, rect, textOrigin);
141         if (textDecorationPainter) {
142             textDecorationPainter-&gt;setWidth(rect.width());
143             textDecorationPainter-&gt;paintTextDecoration(textRun, textOrigin, rect.location() + paintOffset);
144         }
145     }
146 }
147 
148 bool hitTestFlow(const RenderBlockFlow&amp; flow, const Layout&amp; layout, const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
149 {
150     if (hitTestAction != HitTestForeground)
151         return false;
152 
153     if (!layout.runCount())
154         return false;
155 
</pre>
<hr />
<pre>
166         lineRect.moveBy(accumulatedOffset);
167         auto&amp; renderer = const_cast&lt;RenderObject&amp;&gt;(it.renderer());
168         if (!locationInContainer.intersects(lineRect))
169             continue;
170         renderer.updateHitTestResult(result, locationInContainer.point() - toLayoutSize(accumulatedOffset));
171         if (result.addNodeToListBasedTestResult(renderer.node(), request, locationInContainer, lineRect) == HitTestProgress::Stop)
172             return true;
173     }
174     return false;
175 }
176 
177 void collectFlowOverflow(RenderBlockFlow&amp; flow, const Layout&amp; layout)
178 {
179     for (auto lineRect : lineResolver(layout.runResolver())) {
180         LayoutRect visualOverflowRect = LayoutRect(computeOverflow(flow, lineRect));
181         flow.addLayoutOverflow(LayoutRect(lineRect));
182         flow.addVisualOverflow(visualOverflowRect);
183     }
184 }
185 
<span class="line-removed">186 IntRect computeBoundingBox(const RenderObject&amp; renderer, const Layout&amp; layout)</span>
<span class="line-removed">187 {</span>
<span class="line-removed">188     auto&amp; resolver = layout.runResolver();</span>
<span class="line-removed">189     FloatRect boundingBoxRect;</span>
<span class="line-removed">190     for (auto run : resolver.rangeForRenderer(renderer)) {</span>
<span class="line-removed">191         FloatRect rect = run.rect();</span>
<span class="line-removed">192         if (boundingBoxRect == FloatRect())</span>
<span class="line-removed">193             boundingBoxRect = rect;</span>
<span class="line-removed">194         else</span>
<span class="line-removed">195             boundingBoxRect.uniteEvenIfEmpty(rect);</span>
<span class="line-removed">196     }</span>
<span class="line-removed">197     return enclosingIntRect(boundingBoxRect);</span>
<span class="line-removed">198 }</span>
<span class="line-removed">199 </span>
<span class="line-removed">200 IntPoint computeFirstRunLocation(const RenderObject&amp; renderer, const Layout&amp; layout)</span>
<span class="line-removed">201 {</span>
<span class="line-removed">202     auto&amp; resolver = layout.runResolver();</span>
<span class="line-removed">203     auto range = resolver.rangeForRenderer(renderer);</span>
<span class="line-removed">204     auto begin = range.begin();</span>
<span class="line-removed">205     if (begin == range.end())</span>
<span class="line-removed">206         return IntPoint(0, 0);</span>
<span class="line-removed">207     return flooredIntPoint((*begin).rect().location());</span>
<span class="line-removed">208 }</span>
<span class="line-removed">209 </span>
<span class="line-removed">210 Vector&lt;IntRect&gt; collectAbsoluteRects(const RenderObject&amp; renderer, const Layout&amp; layout, const LayoutPoint&amp; accumulatedOffset)</span>
<span class="line-removed">211 {</span>
<span class="line-removed">212     Vector&lt;IntRect&gt; rects;</span>
<span class="line-removed">213     auto&amp; resolver = layout.runResolver();</span>
<span class="line-removed">214     for (auto run : resolver.rangeForRenderer(renderer)) {</span>
<span class="line-removed">215         FloatRect rect = run.rect();</span>
<span class="line-removed">216         rects.append(enclosingIntRect(FloatRect(accumulatedOffset + rect.location(), rect.size())));</span>
<span class="line-removed">217     }</span>
<span class="line-removed">218     return rects;</span>
<span class="line-removed">219 }</span>
<span class="line-removed">220 </span>
<span class="line-removed">221 Vector&lt;FloatQuad&gt; collectAbsoluteQuads(const RenderObject&amp; renderer, const Layout&amp; layout, bool* wasFixed)</span>
<span class="line-removed">222 {</span>
<span class="line-removed">223     Vector&lt;FloatQuad&gt; quads;</span>
<span class="line-removed">224     auto&amp; resolver = layout.runResolver();</span>
<span class="line-removed">225     for (auto run : resolver.rangeForRenderer(renderer))</span>
<span class="line-removed">226         quads.append(renderer.localToAbsoluteQuad(FloatQuad(run.rect()), UseTransforms, wasFixed));</span>
<span class="line-removed">227     return quads;</span>
<span class="line-removed">228 }</span>
<span class="line-removed">229 </span>
230 unsigned textOffsetForPoint(const LayoutPoint&amp; point, const RenderText&amp; renderer, const Layout&amp; layout)
231 {
232     auto&amp; flow = downcast&lt;RenderBlockFlow&gt;(*renderer.parent());
233     ASSERT(flow.firstChild() == flow.lastChild());
234     auto&amp; resolver = layout.runResolver();
235     auto it = resolver.runForPoint(point);
236     if (it == resolver.end())
237         return renderer.text().length();
238     auto run = *it;
239     auto&amp; style = flow.style();
240     TextRun textRun(run.text(), run.logicalLeft(), run.expansion(), run.expansionBehavior());
241     textRun.setTabSize(!style.collapseWhiteSpace(), style.tabSize());
242     return run.start() + style.fontCascade().offsetForPosition(textRun, point.x() - run.logicalLeft(), true);
243 }
244 
<span class="line-modified">245 Vector&lt;FloatQuad&gt; collectAbsoluteQuadsForRange(const RenderObject&amp; renderer, unsigned start, unsigned end, const Layout&amp; layout, bool* wasFixed)</span>
246 {
247     auto&amp; style = downcast&lt;RenderBlockFlow&gt;(*renderer.parent()).style();
248     Vector&lt;FloatQuad&gt; quads;
249     auto&amp; resolver = layout.runResolver();
250     for (auto run : resolver.rangeForRendererWithOffsets(renderer, start, end)) {


251         // This run is fully contained.
252         if (start &lt;= run.start() &amp;&amp; end &gt;= run.end()) {
253             quads.append(renderer.localToAbsoluteQuad(FloatQuad(run.rect()), UseTransforms, wasFixed));
254             continue;
255         }
256         // Partially contained run.
257         TextRun textRun(run.text(), run.logicalLeft(), run.expansion(), run.expansionBehavior());
258         textRun.setTabSize(!style.collapseWhiteSpace(), style.tabSize());
259         LayoutRect runRect(run.rect());
260         // Special case empty ranges.
261         if (start == end) {
262             runRect.setWidth(0);
263             quads.append(renderer.localToAbsoluteQuad(FloatQuad(runRect), UseTransforms, wasFixed));
264             continue;
265         }
266         auto localStart = std::max(run.start(), start) - run.start();
267         auto localEnd = std::min(run.end(), end) - run.start();
268         ASSERT(localStart &lt;= localEnd);
269         style.fontCascade().adjustSelectionRectForText(textRun, runRect, localStart, localEnd);

270         quads.append(renderer.localToAbsoluteQuad(FloatQuad(runRect), UseTransforms, wasFixed));
271     }
272     return quads;
273 }
274 
<span class="line-removed">275 const RenderObject&amp; rendererForPosition(const FlowContents&amp; flowContents, unsigned position)</span>
<span class="line-removed">276 {</span>
<span class="line-removed">277     return flowContents.segmentForPosition(position).renderer;</span>
<span class="line-removed">278 }</span>
<span class="line-removed">279 </span>
280 void simpleLineLayoutWillBeDeleted(const Layout&amp; layout)
281 {
282     for (unsigned i = 0; i &lt; layout.runCount(); ++i)
283         TextPainter::removeGlyphDisplayList(layout.runAt(i));
284 }
285 
286 bool canUseForLineBoxTree(RenderBlockFlow&amp; flow, const Layout&amp; layout)
287 {
288     // Line breaking requires some context that SLL can&#39;t provide at the moment (see RootInlineBox::setLineBreakInfo).
289     if (layout.lineCount() &gt; 1)
290         return false;
291 
292     if (layout.isPaginated())
293         return false;
294 
295     if (flow.style().preserveNewline())
296         return false;
297 
298     if (!flow.firstChild())
299         return false;
</pre>
<hr />
<pre>
375         auto iter = range.begin();
376         auto firstRun = *iter;
377         rootLineBox.setLogicalLeft(firstRun.logicalLeft());
378         rootLineBox.setLogicalWidth(lineWidth);
379         auto lineTop = firstRun.rect().y();
380         auto lineHeight = firstRun.rect().height();
381         rootLineBox.setLogicalTop(lineTop);
382         rootLineBox.setLineTopBottomPositions(LayoutUnit(lineTop), LayoutUnit(lineTop + lineHeight), LayoutUnit(lineTop), LayoutUnit(lineTop + lineHeight));
383     }
384 }
385 
386 #if ENABLE(TREE_DEBUGGING)
387 static void printPrefix(TextStream&amp; stream, int&amp; printedCharacters, int depth)
388 {
389     stream &lt;&lt; &quot;-------- --&quot;;
390     printedCharacters = 0;
391     while (++printedCharacters &lt;= depth * 2)
392         stream &lt;&lt; &quot; &quot;;
393 }
394 
<span class="line-modified">395 void outputLineLayoutForFlow(TextStream&amp; stream, const RenderBlockFlow&amp; flow, const Layout&amp; layout, int depth)</span>
396 {
397     int printedCharacters = 0;
398     printPrefix(stream, printedCharacters, depth);
399 
400     stream &lt;&lt; &quot;SimpleLineLayout (&quot; &lt;&lt; layout.lineCount() &lt;&lt; &quot; lines, &quot; &lt;&lt; layout.runCount() &lt;&lt; &quot; runs) (&quot; &lt;&lt; &amp;layout &lt;&lt; &quot;)&quot;;
401     stream.nextLine();
402     ++depth;
403 
<span class="line-modified">404     for (auto run : runResolver(flow, layout)) {</span>
405         FloatRect rect = run.rect();
406         printPrefix(stream, printedCharacters, depth);
407         if (run.start() &lt; run.end()) {
408             stream &lt;&lt; &quot;line &quot; &lt;&lt; run.lineIndex() &lt;&lt; &quot; run(&quot; &lt;&lt; run.start() &lt;&lt; &quot;, &quot; &lt;&lt; run.end() &lt;&lt; &quot;) &quot; &lt;&lt; rect &lt;&lt; &quot; \&quot;&quot; &lt;&lt; run.text().toStringWithoutCopying().utf8().data() &lt;&lt; &quot;\&quot;&quot;;
409         } else {
410             ASSERT(run.start() == run.end());
411             stream &lt;&lt; &quot;line break &quot; &lt;&lt; run.lineIndex() &lt;&lt; &quot; run(&quot; &lt;&lt; run.start() &lt;&lt; &quot;, &quot; &lt;&lt; run.end() &lt;&lt; &quot;) &quot; &lt;&lt; rect;
412         }
413     }
414     stream.nextLine();
415 }
416 #endif
417 
418 }
419 }
</pre>
</td>
<td>
<hr />
<pre>
114         }
115     }
116 
117     LayoutRect paintRect = paintInfo.rect;
118     paintRect.moveBy(-paintOffset);
119 
120     auto&amp; resolver = layout.runResolver();
121     float deviceScaleFactor = flow.document().deviceScaleFactor();
122     for (auto run : resolver.rangeForRect(paintRect)) {
123         if (run.start() == run.end())
124             continue;
125 
126         FloatRect rect = run.rect();
127         FloatRect visualOverflowRect = computeOverflow(flow, rect);
128         if (paintRect.y() &gt; visualOverflowRect.maxY() || paintRect.maxY() &lt; visualOverflowRect.y())
129             continue;
130 
131         String textWithHyphen;
132         if (run.hasHyphen())
133             textWithHyphen = run.textWithHyphen();
<span class="line-modified">134         // xPos is relative to the line box&#39;s logical left.</span>
<span class="line-modified">135         // We don&#39;t have any line geometry here in SLL, so let&#39;s get the first run&#39;s logical left in the current line and use it as the line&#39;s logical left.</span>
<span class="line-added">136         auto lineLogicalLeft = (*resolver.rangeForLine(run.lineIndex()).begin()).logicalLeft();</span>
<span class="line-added">137         TextRun textRun { run.hasHyphen() ? textWithHyphen : run.text(), run.logicalLeft() - lineLogicalLeft, run.expansion(), run.expansionBehavior() };</span>
138         textRun.setTabSize(!style.collapseWhiteSpace(), style.tabSize());
139         FloatPoint textOrigin { rect.x() + paintOffset.x(), roundToDevicePixel(run.baselinePosition() + paintOffset.y(), deviceScaleFactor) };
140 
141         textPainter.setGlyphDisplayListIfNeeded(run.simpleRun(), paintInfo, style.fontCascade(), paintInfo.context(), textRun);
142         textPainter.paint(textRun, rect, textOrigin);
143         if (textDecorationPainter) {
144             textDecorationPainter-&gt;setWidth(rect.width());
145             textDecorationPainter-&gt;paintTextDecoration(textRun, textOrigin, rect.location() + paintOffset);
146         }
147     }
148 }
149 
150 bool hitTestFlow(const RenderBlockFlow&amp; flow, const Layout&amp; layout, const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
151 {
152     if (hitTestAction != HitTestForeground)
153         return false;
154 
155     if (!layout.runCount())
156         return false;
157 
</pre>
<hr />
<pre>
168         lineRect.moveBy(accumulatedOffset);
169         auto&amp; renderer = const_cast&lt;RenderObject&amp;&gt;(it.renderer());
170         if (!locationInContainer.intersects(lineRect))
171             continue;
172         renderer.updateHitTestResult(result, locationInContainer.point() - toLayoutSize(accumulatedOffset));
173         if (result.addNodeToListBasedTestResult(renderer.node(), request, locationInContainer, lineRect) == HitTestProgress::Stop)
174             return true;
175     }
176     return false;
177 }
178 
179 void collectFlowOverflow(RenderBlockFlow&amp; flow, const Layout&amp; layout)
180 {
181     for (auto lineRect : lineResolver(layout.runResolver())) {
182         LayoutRect visualOverflowRect = LayoutRect(computeOverflow(flow, lineRect));
183         flow.addLayoutOverflow(LayoutRect(lineRect));
184         flow.addVisualOverflow(visualOverflowRect);
185     }
186 }
187 












































188 unsigned textOffsetForPoint(const LayoutPoint&amp; point, const RenderText&amp; renderer, const Layout&amp; layout)
189 {
190     auto&amp; flow = downcast&lt;RenderBlockFlow&gt;(*renderer.parent());
191     ASSERT(flow.firstChild() == flow.lastChild());
192     auto&amp; resolver = layout.runResolver();
193     auto it = resolver.runForPoint(point);
194     if (it == resolver.end())
195         return renderer.text().length();
196     auto run = *it;
197     auto&amp; style = flow.style();
198     TextRun textRun(run.text(), run.logicalLeft(), run.expansion(), run.expansionBehavior());
199     textRun.setTabSize(!style.collapseWhiteSpace(), style.tabSize());
200     return run.start() + style.fontCascade().offsetForPosition(textRun, point.x() - run.logicalLeft(), true);
201 }
202 
<span class="line-modified">203 Vector&lt;FloatQuad&gt; collectAbsoluteQuadsForRange(const RenderObject&amp; renderer, unsigned start, unsigned end, const Layout&amp; layout, bool ignoreEmptyTextSelections, bool* wasFixed)</span>
204 {
205     auto&amp; style = downcast&lt;RenderBlockFlow&gt;(*renderer.parent()).style();
206     Vector&lt;FloatQuad&gt; quads;
207     auto&amp; resolver = layout.runResolver();
208     for (auto run : resolver.rangeForRendererWithOffsets(renderer, start, end)) {
<span class="line-added">209         if (ignoreEmptyTextSelections &amp;&amp; run.start() == run.end())</span>
<span class="line-added">210             continue;</span>
211         // This run is fully contained.
212         if (start &lt;= run.start() &amp;&amp; end &gt;= run.end()) {
213             quads.append(renderer.localToAbsoluteQuad(FloatQuad(run.rect()), UseTransforms, wasFixed));
214             continue;
215         }
216         // Partially contained run.
217         TextRun textRun(run.text(), run.logicalLeft(), run.expansion(), run.expansionBehavior());
218         textRun.setTabSize(!style.collapseWhiteSpace(), style.tabSize());
219         LayoutRect runRect(run.rect());
220         // Special case empty ranges.
221         if (start == end) {
222             runRect.setWidth(0);
223             quads.append(renderer.localToAbsoluteQuad(FloatQuad(runRect), UseTransforms, wasFixed));
224             continue;
225         }
226         auto localStart = std::max(run.start(), start) - run.start();
227         auto localEnd = std::min(run.end(), end) - run.start();
228         ASSERT(localStart &lt;= localEnd);
229         style.fontCascade().adjustSelectionRectForText(textRun, runRect, localStart, localEnd);
<span class="line-added">230         runRect = snappedSelectionRect(runRect, run.logicalRight(), runRect.y(), runRect.height(), true /* isHorizontal */);</span>
231         quads.append(renderer.localToAbsoluteQuad(FloatQuad(runRect), UseTransforms, wasFixed));
232     }
233     return quads;
234 }
235 





236 void simpleLineLayoutWillBeDeleted(const Layout&amp; layout)
237 {
238     for (unsigned i = 0; i &lt; layout.runCount(); ++i)
239         TextPainter::removeGlyphDisplayList(layout.runAt(i));
240 }
241 
242 bool canUseForLineBoxTree(RenderBlockFlow&amp; flow, const Layout&amp; layout)
243 {
244     // Line breaking requires some context that SLL can&#39;t provide at the moment (see RootInlineBox::setLineBreakInfo).
245     if (layout.lineCount() &gt; 1)
246         return false;
247 
248     if (layout.isPaginated())
249         return false;
250 
251     if (flow.style().preserveNewline())
252         return false;
253 
254     if (!flow.firstChild())
255         return false;
</pre>
<hr />
<pre>
331         auto iter = range.begin();
332         auto firstRun = *iter;
333         rootLineBox.setLogicalLeft(firstRun.logicalLeft());
334         rootLineBox.setLogicalWidth(lineWidth);
335         auto lineTop = firstRun.rect().y();
336         auto lineHeight = firstRun.rect().height();
337         rootLineBox.setLogicalTop(lineTop);
338         rootLineBox.setLineTopBottomPositions(LayoutUnit(lineTop), LayoutUnit(lineTop + lineHeight), LayoutUnit(lineTop), LayoutUnit(lineTop + lineHeight));
339     }
340 }
341 
342 #if ENABLE(TREE_DEBUGGING)
343 static void printPrefix(TextStream&amp; stream, int&amp; printedCharacters, int depth)
344 {
345     stream &lt;&lt; &quot;-------- --&quot;;
346     printedCharacters = 0;
347     while (++printedCharacters &lt;= depth * 2)
348         stream &lt;&lt; &quot; &quot;;
349 }
350 
<span class="line-modified">351 void outputLineLayoutForFlow(TextStream&amp; stream, const RenderBlockFlow&amp;, const Layout&amp; layout, int depth)</span>
352 {
353     int printedCharacters = 0;
354     printPrefix(stream, printedCharacters, depth);
355 
356     stream &lt;&lt; &quot;SimpleLineLayout (&quot; &lt;&lt; layout.lineCount() &lt;&lt; &quot; lines, &quot; &lt;&lt; layout.runCount() &lt;&lt; &quot; runs) (&quot; &lt;&lt; &amp;layout &lt;&lt; &quot;)&quot;;
357     stream.nextLine();
358     ++depth;
359 
<span class="line-modified">360     for (auto run : layout.runResolver()) {</span>
361         FloatRect rect = run.rect();
362         printPrefix(stream, printedCharacters, depth);
363         if (run.start() &lt; run.end()) {
364             stream &lt;&lt; &quot;line &quot; &lt;&lt; run.lineIndex() &lt;&lt; &quot; run(&quot; &lt;&lt; run.start() &lt;&lt; &quot;, &quot; &lt;&lt; run.end() &lt;&lt; &quot;) &quot; &lt;&lt; rect &lt;&lt; &quot; \&quot;&quot; &lt;&lt; run.text().toStringWithoutCopying().utf8().data() &lt;&lt; &quot;\&quot;&quot;;
365         } else {
366             ASSERT(run.start() == run.end());
367             stream &lt;&lt; &quot;line break &quot; &lt;&lt; run.lineIndex() &lt;&lt; &quot; run(&quot; &lt;&lt; run.start() &lt;&lt; &quot;, &quot; &lt;&lt; run.end() &lt;&lt; &quot;) &quot; &lt;&lt; rect;
368         }
369     }
370     stream.nextLine();
371 }
372 #endif
373 
374 }
375 }
</pre>
</td>
</tr>
</table>
<center><a href="SimpleLineLayoutCoverage.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SimpleLineLayoutFunctions.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
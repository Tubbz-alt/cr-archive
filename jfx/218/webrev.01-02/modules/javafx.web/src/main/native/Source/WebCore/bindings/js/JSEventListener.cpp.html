<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSEventListener.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
  3  *  Copyright (C) 2003-2019 Apple Inc. All Rights Reserved.
  4  *
  5  *  This library is free software; you can redistribute it and/or
  6  *  modify it under the terms of the GNU Lesser General Public
  7  *  License as published by the Free Software Foundation; either
  8  *  version 2 of the License, or (at your option) any later version.
  9  *
 10  *  This library is distributed in the hope that it will be useful,
 11  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  *  Lesser General Public License for more details.
 14  *
 15  *  You should have received a copy of the GNU Lesser General Public
 16  *  License along with this library; if not, write to the Free Software
 17  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 18  */
 19 
 20 #include &quot;config.h&quot;
 21 #include &quot;JSEventListener.h&quot;
 22 
 23 #include &quot;BeforeUnloadEvent.h&quot;
 24 #include &quot;ContentSecurityPolicy.h&quot;
 25 #include &quot;EventNames.h&quot;
 26 #include &quot;Frame.h&quot;
 27 #include &quot;HTMLElement.h&quot;
 28 #include &quot;JSDOMConvertNullable.h&quot;
 29 #include &quot;JSDOMConvertStrings.h&quot;
 30 #include &quot;JSDOMGlobalObject.h&quot;
 31 #include &quot;JSDocument.h&quot;
 32 #include &quot;JSEvent.h&quot;
 33 #include &quot;JSEventTarget.h&quot;
 34 #include &quot;JSExecState.h&quot;
 35 #include &quot;JSExecStateInstrumentation.h&quot;
 36 #include &quot;JSWorkerGlobalScope.h&quot;
 37 #include &quot;ScriptController.h&quot;
 38 #include &quot;WorkerGlobalScope.h&quot;
 39 #include &lt;JavaScriptCore/ExceptionHelpers.h&gt;
 40 #include &lt;JavaScriptCore/JSLock.h&gt;
 41 #include &lt;JavaScriptCore/VMEntryScope.h&gt;
 42 #include &lt;JavaScriptCore/Watchdog.h&gt;
 43 #include &lt;wtf/Ref.h&gt;
 44 
 45 namespace WebCore {
 46 using namespace JSC;
 47 
 48 JSEventListener::JSEventListener(JSObject* function, JSObject* wrapper, bool isAttribute, DOMWrapperWorld&amp; isolatedWorld)
 49     : EventListener(JSEventListenerType)
 50     , m_wrapper(wrapper)
 51     , m_isAttribute(isAttribute)
 52     , m_isolatedWorld(isolatedWorld)
 53 {
 54     if (wrapper) {
 55         JSC::Heap::heap(wrapper)-&gt;writeBarrier(wrapper, function);
 56         m_jsFunction = JSC::Weak&lt;JSC::JSObject&gt;(function);
 57     } else
 58         ASSERT(!function);
 59 }
 60 
 61 JSEventListener::~JSEventListener() = default;
 62 
 63 Ref&lt;JSEventListener&gt; JSEventListener::create(JSC::JSObject* listener, JSC::JSObject* wrapper, bool isAttribute, DOMWrapperWorld&amp; world)
 64 {
 65     return adoptRef(*new JSEventListener(listener, wrapper, isAttribute, world));
 66 }
 67 
 68 RefPtr&lt;JSEventListener&gt; JSEventListener::create(JSC::JSValue listener, JSC::JSObject&amp; wrapper, bool isAttribute, DOMWrapperWorld&amp; world)
 69 {
 70     if (UNLIKELY(!listener.isObject()))
 71         return nullptr;
 72 
 73     return create(JSC::asObject(listener), &amp;wrapper, isAttribute, world);
 74 }
 75 
 76 JSObject* JSEventListener::initializeJSFunction(ScriptExecutionContext&amp;) const
 77 {
 78     return nullptr;
 79 }
 80 
 81 void JSEventListener::visitJSFunction(SlotVisitor&amp; visitor)
 82 {
 83     // If m_wrapper is null, then m_jsFunction is zombied, and should never be accessed.
 84     if (!m_wrapper)
 85         return;
 86 
 87     visitor.append(m_jsFunction);
 88 }
 89 
 90 static void handleBeforeUnloadEventReturnValue(BeforeUnloadEvent&amp; event, const String&amp; returnValue)
 91 {
 92     if (returnValue.isNull())
 93         return;
 94 
 95     event.preventDefault();
 96     if (event.returnValue().isEmpty())
 97         event.setReturnValue(returnValue);
 98 }
 99 
100 void JSEventListener::handleEvent(ScriptExecutionContext&amp; scriptExecutionContext, Event&amp; event)
101 {
102     if (scriptExecutionContext.isJSExecutionForbidden())
103         return;
104 
105     VM&amp; vm = scriptExecutionContext.vm();
106     JSLockHolder lock(vm);
107     auto scope = DECLARE_CATCH_SCOPE(vm);
108 
109     // See https://dom.spec.whatwg.org/#dispatching-events spec on calling handleEvent.
110     // &quot;If this throws an exception, report the exception.&quot; It should not propagate the
111     // exception.
112 
113     JSObject* jsFunction = this-&gt;jsFunction(scriptExecutionContext);
114     if (!jsFunction)
115         return;
116 
117     JSDOMGlobalObject* globalObject = toJSDOMGlobalObject(scriptExecutionContext, m_isolatedWorld);
118     if (!globalObject)
119         return;
120 
121     if (scriptExecutionContext.isDocument()) {
122         JSDOMWindow* window = jsCast&lt;JSDOMWindow*&gt;(globalObject);
123         if (!window-&gt;wrapped().isCurrentlyDisplayedInFrame())
124             return;
125         if (wasCreatedFromMarkup() &amp;&amp; !scriptExecutionContext.contentSecurityPolicy()-&gt;allowInlineEventHandlers(sourceURL(), sourcePosition().m_line))
126             return;
127         // FIXME: Is this check needed for other contexts?
128         ScriptController&amp; script = window-&gt;wrapped().frame()-&gt;script();
129         if (!script.canExecuteScripts(AboutToExecuteScript) || script.isPaused())
130             return;
131     }
132 
133     JSGlobalObject* lexicalGlobalObject = globalObject;
134 
135     JSValue handleEventFunction = jsFunction;
136 
137     CallData callData;
138     CallType callType = getCallData(vm, handleEventFunction, callData);
139 
140     // If jsFunction is not actually a function and this is an EventListener, see if it implements callback interface.
141     if (callType == CallType::None) {
142         if (m_isAttribute)
143             return;
144 
145         handleEventFunction = jsFunction-&gt;get(lexicalGlobalObject, Identifier::fromString(vm, &quot;handleEvent&quot;));
146         if (UNLIKELY(scope.exception())) {
147             auto* exception = scope.exception();
148             scope.clearException();
149             event.target()-&gt;uncaughtExceptionInEventHandler();
150             reportException(lexicalGlobalObject, exception);
151             return;
152         }
153         callType = getCallData(vm, handleEventFunction, callData);
154         if (callType == CallType::None) {
155             event.target()-&gt;uncaughtExceptionInEventHandler();
156             reportException(lexicalGlobalObject, createTypeError(lexicalGlobalObject, &quot;&#39;handleEvent&#39; property of event listener should be callable&quot;_s));
157             return;
158         }
159     }
160 
161     Ref&lt;JSEventListener&gt; protectedThis(*this);
162 
163     MarkedArgumentBuffer args;
164     args.append(toJS(lexicalGlobalObject, globalObject, &amp;event));
165     ASSERT(!args.hasOverflowed());
166 
167     Event* savedEvent = globalObject-&gt;currentEvent();
168 
169     // window.event should not be set when the target is inside a shadow tree, as per the DOM specification.
170     bool isTargetInsideShadowTree = is&lt;Node&gt;(event.currentTarget()) &amp;&amp; downcast&lt;Node&gt;(*event.currentTarget()).isInShadowTree();
171     if (!isTargetInsideShadowTree)
172         globalObject-&gt;setCurrentEvent(&amp;event);
173 
174     VMEntryScope entryScope(vm, vm.entryScope ? vm.entryScope-&gt;globalObject() : globalObject);
175 
176     JSExecState::instrumentFunctionCall(&amp;scriptExecutionContext, callType, callData);
177 
178     JSValue thisValue = handleEventFunction == jsFunction ? toJS(lexicalGlobalObject, globalObject, event.currentTarget()) : jsFunction;
179     NakedPtr&lt;JSC::Exception&gt; exception;
180     JSValue retval = JSExecState::profiledCall(lexicalGlobalObject, JSC::ProfilingReason::Other, handleEventFunction, callType, callData, thisValue, args, exception);
181 
182     InspectorInstrumentation::didCallFunction(&amp;scriptExecutionContext);
183 
184     globalObject-&gt;setCurrentEvent(savedEvent);
185 
186     if (is&lt;WorkerGlobalScope&gt;(scriptExecutionContext)) {
187         auto&amp; scriptController = *downcast&lt;WorkerGlobalScope&gt;(scriptExecutionContext).script();
188         bool terminatorCausedException = (scope.exception() &amp;&amp; isTerminatedExecutionException(vm, scope.exception()));
189         if (terminatorCausedException || scriptController.isTerminatingExecution())
190             scriptController.forbidExecution();
191     }
192 
193     if (exception) {
194         event.target()-&gt;uncaughtExceptionInEventHandler();
195         reportException(lexicalGlobalObject, exception);
196         return;
197     }
198 
199     if (!m_isAttribute) {
200         // This is an EventListener and there is therefore no need for any return value handling.
201         return;
202     }
203 
204     // Do return value handling for event handlers (https://html.spec.whatwg.org/#the-event-handler-processing-algorithm).
205 
206     if (event.type() == eventNames().beforeunloadEvent) {
207         // This is a OnBeforeUnloadEventHandler, and therefore the return value must be coerced into a String.
208         if (is&lt;BeforeUnloadEvent&gt;(event))
209             handleBeforeUnloadEventReturnValue(downcast&lt;BeforeUnloadEvent&gt;(event), convert&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(*lexicalGlobalObject, retval));
210         return;
211     }
212 
213     if (retval.isFalse())
214         event.preventDefault();
215 }
216 
217 bool JSEventListener::operator==(const EventListener&amp; listener) const
218 {
219     if (!is&lt;JSEventListener&gt;(listener))
220         return false;
221     auto&amp; other = downcast&lt;JSEventListener&gt;(listener);
222     return m_jsFunction == other.m_jsFunction &amp;&amp; m_isAttribute == other.m_isAttribute;
223 }
224 
225 String JSEventListener::functionName() const
226 {
227     if (!m_wrapper || !m_jsFunction)
228         return { };
229 
230     auto&amp; vm = isolatedWorld().vm();
231     JSC::JSLockHolder lock(vm);
232 
233     auto* handlerFunction = JSC::jsDynamicCast&lt;JSC::JSFunction*&gt;(vm, m_jsFunction.get());
234     if (!handlerFunction)
235         return { };
236 
237     return handlerFunction-&gt;name(vm);
238 }
239 
240 static inline JSC::JSValue eventHandlerAttribute(EventListener* abstractListener, ScriptExecutionContext&amp; context)
241 {
242     if (!is&lt;JSEventListener&gt;(abstractListener))
243         return jsNull();
244 
245     auto* function = downcast&lt;JSEventListener&gt;(*abstractListener).jsFunction(context);
246     if (!function)
247         return jsNull();
248 
249     return function;
250 }
251 
252 static inline RefPtr&lt;JSEventListener&gt; createEventListenerForEventHandlerAttribute(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue listener, JSC::JSObject&amp; wrapper)
253 {
254     if (!listener.isObject())
255         return nullptr;
256     return JSEventListener::create(asObject(listener), &amp;wrapper, true, currentWorld(lexicalGlobalObject));
257 }
258 
259 JSC::JSValue eventHandlerAttribute(EventTarget&amp; target, const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
260 {
261     return eventHandlerAttribute(target.attributeEventListener(eventType, isolatedWorld), *target.scriptExecutionContext());
262 }
263 
264 void setEventHandlerAttribute(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject&amp; wrapper, EventTarget&amp; target, const AtomString&amp; eventType, JSC::JSValue value)
265 {
266     target.setAttributeEventListener(eventType, createEventListenerForEventHandlerAttribute(lexicalGlobalObject, value, wrapper), currentWorld(lexicalGlobalObject));
267 }
268 
269 JSC::JSValue windowEventHandlerAttribute(HTMLElement&amp; element, const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
270 {
271     auto&amp; document = element.document();
272     return eventHandlerAttribute(document.getWindowAttributeEventListener(eventType, isolatedWorld), document);
273 }
274 
275 void setWindowEventHandlerAttribute(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject&amp; wrapper, HTMLElement&amp; element, const AtomString&amp; eventType, JSC::JSValue value)
276 {
277     ASSERT(wrapper.globalObject());
278     element.document().setWindowAttributeEventListener(eventType, createEventListenerForEventHandlerAttribute(lexicalGlobalObject, value, *wrapper.globalObject()), currentWorld(lexicalGlobalObject));
279 }
280 
281 JSC::JSValue windowEventHandlerAttribute(DOMWindow&amp; window, const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
282 {
283     return eventHandlerAttribute(window, eventType, isolatedWorld);
284 }
285 
286 void setWindowEventHandlerAttribute(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject&amp; wrapper, DOMWindow&amp; window, const AtomString&amp; eventType, JSC::JSValue value)
287 {
288     setEventHandlerAttribute(lexicalGlobalObject, wrapper, window, eventType, value);
289 }
290 
291 JSC::JSValue documentEventHandlerAttribute(HTMLElement&amp; element, const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
292 {
293     auto&amp; document = element.document();
294     return eventHandlerAttribute(document.attributeEventListener(eventType, isolatedWorld), document);
295 }
296 
297 void setDocumentEventHandlerAttribute(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject&amp; wrapper, HTMLElement&amp; element, const AtomString&amp; eventType, JSC::JSValue value)
298 {
299     ASSERT(wrapper.globalObject());
300     auto&amp; document = element.document();
301     auto* documentWrapper = JSC::jsCast&lt;JSDocument*&gt;(toJS(&amp;lexicalGlobalObject, JSC::jsCast&lt;JSDOMGlobalObject*&gt;(wrapper.globalObject()), document));
302     ASSERT(documentWrapper);
303     document.setAttributeEventListener(eventType, createEventListenerForEventHandlerAttribute(lexicalGlobalObject, value, *documentWrapper), currentWorld(lexicalGlobalObject));
304 }
305 
306 JSC::JSValue documentEventHandlerAttribute(Document&amp; document, const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
307 {
308     return eventHandlerAttribute(document, eventType, isolatedWorld);
309 }
310 
311 void setDocumentEventHandlerAttribute(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject&amp; wrapper, Document&amp; document, const AtomString&amp; eventType, JSC::JSValue value)
312 {
313     setEventHandlerAttribute(lexicalGlobalObject, wrapper, document, eventType, value);
314 }
315 
316 } // namespace WebCore
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/shared/IDBDatabaseInfo.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;IDBDatabaseInfo.h&quot;
 28 
 29 #include &lt;wtf/text/StringBuilder.h&gt;
 30 
 31 #if ENABLE(INDEXED_DATABASE)
 32 
 33 namespace WebCore {
 34 
 35 IDBDatabaseInfo::IDBDatabaseInfo()
 36 {
 37 }
 38 
 39 IDBDatabaseInfo::IDBDatabaseInfo(const String&amp; name, uint64_t version, uint64_t maxIndexID)
 40     : m_name(name)
 41     , m_version(version)
 42     , m_maxIndexID(maxIndexID)
 43 {
 44 }
 45 
 46 IDBDatabaseInfo::IDBDatabaseInfo(const IDBDatabaseInfo&amp; other, IsolatedCopyTag)
 47     : m_name(other.m_name.isolatedCopy())
 48     , m_version(other.m_version)
 49     , m_maxObjectStoreID(other.m_maxObjectStoreID)
 50     , m_maxIndexID(other.m_maxIndexID)
 51 {
 52     for (const auto&amp; entry : other.m_objectStoreMap)
 53         m_objectStoreMap.set(entry.key, entry.value.isolatedCopy());
 54 }
 55 
 56 IDBDatabaseInfo IDBDatabaseInfo::isolatedCopy() const
 57 {
 58     return { *this, IDBDatabaseInfo::IsolatedCopy };
 59 }
 60 
 61 bool IDBDatabaseInfo::hasObjectStore(const String&amp; name) const
 62 {
 63     for (auto&amp; objectStore : m_objectStoreMap.values()) {
 64         if (objectStore.name() == name)
 65             return true;
 66     }
 67 
 68     return false;
 69 }
 70 
 71 IDBObjectStoreInfo IDBDatabaseInfo::createNewObjectStore(const String&amp; name, Optional&lt;IDBKeyPath&gt;&amp;&amp; keyPath, bool autoIncrement)
 72 {
 73     IDBObjectStoreInfo info(++m_maxObjectStoreID, name, WTFMove(keyPath), autoIncrement);
 74     m_objectStoreMap.set(info.identifier(), info);
 75     return info;
 76 }
 77 
 78 void IDBDatabaseInfo::addExistingObjectStore(const IDBObjectStoreInfo&amp; info)
 79 {
 80     ASSERT(!m_objectStoreMap.contains(info.identifier()));
 81 
 82     if (info.identifier() &gt; m_maxObjectStoreID)
 83         m_maxObjectStoreID = info.identifier();
 84 
 85     m_objectStoreMap.set(info.identifier(), info);
 86 }
 87 
 88 IDBObjectStoreInfo* IDBDatabaseInfo::getInfoForExistingObjectStore(uint64_t objectStoreIdentifier)
 89 {
 90     auto iterator = m_objectStoreMap.find(objectStoreIdentifier);
 91     if (iterator == m_objectStoreMap.end())
 92         return nullptr;
 93 
 94     return &amp;iterator-&gt;value;
 95 }
 96 
 97 IDBObjectStoreInfo* IDBDatabaseInfo::getInfoForExistingObjectStore(const String&amp; name)
 98 {
 99     for (auto&amp; objectStore : m_objectStoreMap.values()) {
100         if (objectStore.name() == name)
101             return &amp;objectStore;
102     }
103 
104     return nullptr;
105 }
106 
107 const IDBObjectStoreInfo* IDBDatabaseInfo::infoForExistingObjectStore(uint64_t objectStoreIdentifier) const
108 {
109     return const_cast&lt;IDBDatabaseInfo*&gt;(this)-&gt;getInfoForExistingObjectStore(objectStoreIdentifier);
110 }
111 
112 IDBObjectStoreInfo* IDBDatabaseInfo::infoForExistingObjectStore(uint64_t objectStoreIdentifier)
113 {
114     return getInfoForExistingObjectStore(objectStoreIdentifier);
115 }
116 
117 const IDBObjectStoreInfo* IDBDatabaseInfo::infoForExistingObjectStore(const String&amp; name) const
118 {
119     return const_cast&lt;IDBDatabaseInfo*&gt;(this)-&gt;getInfoForExistingObjectStore(name);
120 }
121 
122 IDBObjectStoreInfo* IDBDatabaseInfo::infoForExistingObjectStore(const String&amp; name)
123 {
124     return getInfoForExistingObjectStore(name);
125 }
126 
127 void IDBDatabaseInfo::renameObjectStore(uint64_t objectStoreIdentifier, const String&amp; newName)
128 {
129     auto* info = infoForExistingObjectStore(objectStoreIdentifier);
130     if (!info)
131         return;
132 
133     info-&gt;rename(newName);
134 }
135 
136 Vector&lt;String&gt; IDBDatabaseInfo::objectStoreNames() const
137 {
138     Vector&lt;String&gt; names;
139     names.reserveCapacity(m_objectStoreMap.size());
140     for (auto&amp; objectStore : m_objectStoreMap.values())
141         names.uncheckedAppend(objectStore.name());
142 
143     return names;
144 }
145 
146 void IDBDatabaseInfo::deleteObjectStore(const String&amp; objectStoreName)
147 {
148     auto* info = infoForExistingObjectStore(objectStoreName);
149     if (!info)
150         return;
151 
152     m_objectStoreMap.remove(info-&gt;identifier());
153 }
154 
155 void IDBDatabaseInfo::deleteObjectStore(uint64_t objectStoreIdentifier)
156 {
157     m_objectStoreMap.remove(objectStoreIdentifier);
158 }
159 
160 #if !LOG_DISABLED
161 
162 String IDBDatabaseInfo::loggingString() const
163 {
164     StringBuilder builder;
165     builder.append(&quot;Database:&quot;, m_name, &quot; version &quot;, m_version, &#39;\n&#39;);
166     for (auto&amp; objectStore : m_objectStoreMap.values())
167         builder.append(objectStore.loggingString(1), &#39;\n&#39;);
168     return builder.toString();
169 }
170 
171 #endif
172 
173 void IDBDatabaseInfo::setMaxIndexID(uint64_t maxIndexID)
174 {
175     ASSERT(maxIndexID &gt; m_maxIndexID || (!maxIndexID &amp;&amp; !m_maxIndexID));
176     m_maxIndexID = maxIndexID;
177 }
178 
179 } // namespace WebCore
180 
181 #endif // ENABLE(INDEXED_DATABASE)
    </pre>
  </body>
</html>
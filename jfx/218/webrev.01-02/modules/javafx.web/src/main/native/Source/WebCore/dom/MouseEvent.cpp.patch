diff a/modules/javafx.web/src/main/native/Source/WebCore/dom/MouseEvent.cpp b/modules/javafx.web/src/main/native/Source/WebCore/dom/MouseEvent.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/dom/MouseEvent.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/dom/MouseEvent.cpp
@@ -21,24 +21,28 @@
  */
 
 #include "config.h"
 #include "MouseEvent.h"
 
-#include "DataTransfer.h"
 #include "EventNames.h"
 #include "Frame.h"
 #include "FrameView.h"
 #include "HTMLIFrameElement.h"
 #include "JSDOMConvertInterface.h"
 #include "JSDOMConvertNullable.h"
 #include "JSEventTarget.h"
 #include "JSEventTargetCustom.h"
 #include "PlatformMouseEvent.h"
 #include "RuntimeApplicationChecks.h"
+#include <JavaScriptCore/CallFrame.h>
+#include <JavaScriptCore/JSGlobalObjectInlines.h>
+#include <wtf/IsoMallocInlines.h>
 
 namespace WebCore {
 
+WTF_MAKE_ISO_ALLOCATED_IMPL(MouseEvent);
+
 using namespace JSC;
 
 Ref<MouseEvent> MouseEvent::create(const AtomString& type, const MouseEventInit& initializer)
 {
     return adoptRef(*new MouseEvent(type, initializer));
@@ -61,14 +65,14 @@
         event.modifiers(), event.button(), event.buttons(), relatedTarget, event.force(), event.syntheticClickType());
 }
 
 Ref<MouseEvent> MouseEvent::create(const AtomString& type, CanBubble canBubble, IsCancelable isCancelable, IsComposed isComposed, MonotonicTime timestamp, RefPtr<WindowProxy>&& view, int detail,
     const IntPoint& screenLocation, const IntPoint& windowLocation, const IntPoint& movementDelta, OptionSet<Modifier> modifiers, short button, unsigned short buttons,
-    EventTarget* relatedTarget, double force, unsigned short syntheticClickType, DataTransfer* dataTransfer, IsSimulated isSimulated, IsTrusted isTrusted)
+    EventTarget* relatedTarget, double force, unsigned short syntheticClickType, IsSimulated isSimulated, IsTrusted isTrusted)
 {
     return adoptRef(*new MouseEvent(type, canBubble, isCancelable, isComposed, timestamp, WTFMove(view), detail,
-        screenLocation, windowLocation, movementDelta, modifiers, button, buttons, relatedTarget, force, syntheticClickType, dataTransfer, isSimulated, isTrusted));
+        screenLocation, windowLocation, movementDelta, modifiers, button, buttons, relatedTarget, force, syntheticClickType, isSimulated, isTrusted));
 }
 
 Ref<MouseEvent> MouseEvent::create(const AtomString& eventType, CanBubble canBubble, IsCancelable isCancelable, IsComposed isComposed, RefPtr<WindowProxy>&& view, int detail,
     int screenX, int screenY, int clientX, int clientY, OptionSet<Modifier> modifiers, short button, unsigned short buttons,
     unsigned short syntheticClickType, EventTarget* relatedTarget)
@@ -79,19 +83,18 @@
 MouseEvent::MouseEvent() = default;
 
 MouseEvent::MouseEvent(const AtomString& eventType, CanBubble canBubble, IsCancelable isCancelable, IsComposed isComposed,
     MonotonicTime timestamp, RefPtr<WindowProxy>&& view, int detail,
     const IntPoint& screenLocation, const IntPoint& windowLocation, const IntPoint& movementDelta, OptionSet<Modifier> modifiers, short button, unsigned short buttons,
-    EventTarget* relatedTarget, double force, unsigned short syntheticClickType, DataTransfer* dataTransfer, IsSimulated isSimulated, IsTrusted isTrusted)
+    EventTarget* relatedTarget, double force, unsigned short syntheticClickType, IsSimulated isSimulated, IsTrusted isTrusted)
     : MouseRelatedEvent(eventType, canBubble, isCancelable, isComposed, timestamp, WTFMove(view), detail, screenLocation, windowLocation, movementDelta, modifiers, isSimulated, isTrusted)
     , m_button(button == -2 ? 0 : button)
     , m_buttons(buttons)
     , m_syntheticClickType(button == -2 ? 0 : syntheticClickType)
     , m_buttonDown(button != -2)
     , m_relatedTarget(relatedTarget)
     , m_force(force)
-    , m_dataTransfer(dataTransfer)
 {
 }
 
 MouseEvent::MouseEvent(const AtomString& eventType, CanBubble canBubble, IsCancelable isCancelable, IsComposed isComposed,
     RefPtr<WindowProxy>&& view, int detail, const IntPoint& screenLocation, const IntPoint& clientLocation,
@@ -134,16 +137,15 @@
     m_relatedTarget = relatedTarget;
 
     initCoordinates(IntPoint(clientX, clientY));
 
     setIsSimulated(false);
-    m_dataTransfer = nullptr;
 }
 
 // FIXME: We need this quirk because iAd Producer is calling this function with a relatedTarget that is not an EventTarget (rdar://problem/30640101).
 // We should remove this quirk when possible.
-void MouseEvent::initMouseEventQuirk(ExecState& state, ScriptExecutionContext& scriptExecutionContext, const AtomString& type, bool canBubble, bool cancelable, RefPtr<WindowProxy>&& view, int detail, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, short button, JSValue relatedTargetValue)
+void MouseEvent::initMouseEventQuirk(JSGlobalObject& state, ScriptExecutionContext& scriptExecutionContext, const AtomString& type, bool canBubble, bool cancelable, RefPtr<WindowProxy>&& view, int detail, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, short button, JSValue relatedTargetValue)
 {
     EventTarget* relatedTarget = nullptr;
 #if PLATFORM(MAC)
     // Impacts iBooks too because of widgets generated by iAd Producer (rdar://problem/30797958).
     if (MacApplication::isIAdProducer() || MacApplication::isIBooks()) {
@@ -156,11 +158,11 @@
 #else
     UNUSED_PARAM(scriptExecutionContext);
 #endif
         // This is what the bindings generator would have produced.
         auto throwScope = DECLARE_THROW_SCOPE(state.vm());
-        relatedTarget = convert<IDLNullable<IDLInterface<EventTarget>>>(state, relatedTargetValue, [](ExecState& state, ThrowScope& scope) {
+        relatedTarget = convert<IDLNullable<IDLInterface<EventTarget>>>(state, relatedTargetValue, [](JSGlobalObject& state, ThrowScope& scope) {
             throwArgumentTypeError(state, scope, 14, "relatedTarget", "MouseEvent", "initMouseEvent", "EventTarget");
         });
         RETURN_IF_EXCEPTION(throwScope, void());
 #if PLATFORM(MAC)
     }
@@ -176,25 +178,10 @@
 bool MouseEvent::isMouseEvent() const
 {
     return true;
 }
 
-bool MouseEvent::isDragEvent() const
-{
-    // This function is only used to decide to return nullptr for dataTransfer even when m_dataTransfer is non-null.
-    // FIXME: Is that really valuable? Why will m_dataTransfer be non-null but we need to return null for dataTransfer?
-    // Quite peculiar to decide based on the type string; may have been be provided by call to JavaScript constructor.
-    auto& type = this->type();
-    return type == eventNames().dragEvent
-        || type == eventNames().dragendEvent
-        || type == eventNames().dragenterEvent
-        || type == eventNames().dragleaveEvent
-        || type == eventNames().dragoverEvent
-        || type == eventNames().dragstartEvent
-        || type == eventNames().dropEvent;
-}
-
 bool MouseEvent::canTriggerActivationBehavior(const Event& event)
 {
     return event.type() == eventNames().clickEvent && (!is<MouseEvent>(event) || downcast<MouseEvent>(event).button() != RightButton);
 }
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/Frame.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FocusController.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Frame.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/Frame.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  14  * This library is free software; you can redistribute it and/or
  15  * modify it under the terms of the GNU Library General Public
  16  * License as published by the Free Software Foundation; either
  17  * version 2 of the License, or (at your option) any later version.
  18  *
  19  * This library is distributed in the hope that it will be useful,
  20  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  21  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  22  * Library General Public License for more details.
  23  *
  24  * You should have received a copy of the GNU Library General Public License
  25  * along with this library; see the file COPYING.LIB.  If not, write to
  26  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  27  * Boston, MA 02110-1301, USA.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;Frame.h&quot;
  32 
  33 #include &quot;ApplyStyleCommand.h&quot;

  34 #include &quot;BackForwardController.h&quot;
  35 #include &quot;CSSAnimationController.h&quot;
  36 #include &quot;CSSComputedStyleDeclaration.h&quot;
  37 #include &quot;CSSPropertyNames.h&quot;
  38 #include &quot;CachedCSSStyleSheet.h&quot;
  39 #include &quot;CachedResourceLoader.h&quot;
  40 #include &quot;Chrome.h&quot;
  41 #include &quot;ChromeClient.h&quot;
  42 #include &quot;DOMWindow.h&quot;
  43 #include &quot;DocumentTimeline.h&quot;
  44 #include &quot;DocumentType.h&quot;
  45 #include &quot;Editing.h&quot;
  46 #include &quot;Editor.h&quot;
  47 #include &quot;EditorClient.h&quot;
  48 #include &quot;Event.h&quot;
  49 #include &quot;EventHandler.h&quot;
  50 #include &quot;EventNames.h&quot;
  51 #include &quot;FloatQuad.h&quot;
  52 #include &quot;FocusController.h&quot;
  53 #include &quot;FrameDestructionObserver.h&quot;
</pre>
<hr />
<pre>
  56 #include &quot;FrameSelection.h&quot;
  57 #include &quot;FrameView.h&quot;
  58 #include &quot;GraphicsContext.h&quot;
  59 #include &quot;GraphicsLayer.h&quot;
  60 #include &quot;HTMLFormControlElement.h&quot;
  61 #include &quot;HTMLFormElement.h&quot;
  62 #include &quot;HTMLFrameElementBase.h&quot;
  63 #include &quot;HTMLNames.h&quot;
  64 #include &quot;HTMLTableCellElement.h&quot;
  65 #include &quot;HTMLTableRowElement.h&quot;
  66 #include &quot;HitTestResult.h&quot;
  67 #include &quot;ImageBuffer.h&quot;
  68 #include &quot;InspectorInstrumentation.h&quot;
  69 #include &quot;JSWindowProxy.h&quot;
  70 #include &quot;Logging.h&quot;
  71 #include &quot;NavigationScheduler.h&quot;
  72 #include &quot;Navigator.h&quot;
  73 #include &quot;NodeList.h&quot;
  74 #include &quot;NodeTraversal.h&quot;
  75 #include &quot;Page.h&quot;
<span class="line-removed">  76 #include &quot;PageCache.h&quot;</span>
  77 #include &quot;ProcessWarming.h&quot;
  78 #include &quot;RenderLayerCompositor.h&quot;
  79 #include &quot;RenderTableCell.h&quot;
  80 #include &quot;RenderText.h&quot;
  81 #include &quot;RenderTextControl.h&quot;
  82 #include &quot;RenderTheme.h&quot;
  83 #include &quot;RenderView.h&quot;
  84 #include &quot;RenderWidget.h&quot;
  85 #include &quot;RuntimeEnabledFeatures.h&quot;
  86 #include &quot;SVGDocument.h&quot;
  87 #include &quot;SVGDocumentExtensions.h&quot;
  88 #include &quot;ScriptController.h&quot;
  89 #include &quot;ScriptSourceCode.h&quot;
  90 #include &quot;ScrollingCoordinator.h&quot;
  91 #include &quot;Settings.h&quot;
  92 #include &quot;StyleProperties.h&quot;
  93 #include &quot;StyleScope.h&quot;
  94 #include &quot;TextNodeTraversal.h&quot;
  95 #include &quot;TextResourceDecoder.h&quot;
  96 #include &quot;UserContentController.h&quot;
</pre>
<hr />
<pre>
 213 {
 214     m_destructionObservers.add(observer);
 215 }
 216 
 217 void Frame::removeDestructionObserver(FrameDestructionObserver* observer)
 218 {
 219     m_destructionObservers.remove(observer);
 220 }
 221 
 222 void Frame::setView(RefPtr&lt;FrameView&gt;&amp;&amp; view)
 223 {
 224     // We the custom scroll bars as early as possible to prevent m_doc-&gt;detach()
 225     // from messing with the view such that its scroll bars won&#39;t be torn down.
 226     // FIXME: We should revisit this.
 227     if (m_view)
 228         m_view-&gt;prepareForDetach();
 229 
 230     // Prepare for destruction now, so any unload event handlers get run and the DOMWindow is
 231     // notified. If we wait until the view is destroyed, then things won&#39;t be hooked up enough for
 232     // these calls to work.
<span class="line-modified"> 233     if (!view &amp;&amp; m_doc &amp;&amp; m_doc-&gt;pageCacheState() != Document::InPageCache)</span>
 234         m_doc-&gt;prepareForDestruction();
 235 
 236     if (m_view)
 237         m_view-&gt;layoutContext().unscheduleLayout();
 238 
 239     m_eventHandler-&gt;clear();
 240 
 241     RELEASE_ASSERT(!m_doc || !m_doc-&gt;hasLivingRenderTree());
 242 
 243     m_view = WTFMove(view);
 244 
 245     // Only one form submission is allowed per view of a part.
 246     // Since this part may be getting reused as a result of being
 247     // pulled from the back/forward cache, reset this flag.
 248     loader().resetMultipleFormSubmissionProtection();
 249 }
 250 
 251 void Frame::setDocument(RefPtr&lt;Document&gt;&amp;&amp; newDocument)
 252 {
 253     ASSERT(!newDocument || newDocument-&gt;frame() == this);
</pre>
<hr />
<pre>
 258     m_documentIsBeingReplaced = true;
 259 
 260     if (isMainFrame()) {
 261         if (m_page)
 262             m_page-&gt;didChangeMainDocument();
 263         m_loader-&gt;client().dispatchDidChangeMainDocument();
 264 
 265         // We want to generate the same unique names whenever a page is loaded to avoid making layout tests
 266         // flaky and for things like form state restoration to work. To achieve this, we reset our frame
 267         // identifier generator every time the page is navigated.
 268         tree().resetFrameIdentifiers();
 269     }
 270 
 271 #if ENABLE(ATTACHMENT_ELEMENT)
 272     if (m_doc) {
 273         for (auto&amp; attachment : m_doc-&gt;attachmentElementsByIdentifier().values())
 274             editor().didRemoveAttachmentElement(attachment);
 275     }
 276 #endif
 277 
<span class="line-modified"> 278     if (m_doc &amp;&amp; m_doc-&gt;pageCacheState() != Document::InPageCache)</span>
 279         m_doc-&gt;prepareForDestruction();
 280 
 281     m_doc = newDocument.copyRef();
 282     ASSERT(!m_doc || m_doc-&gt;domWindow());
 283     ASSERT(!m_doc || m_doc-&gt;domWindow()-&gt;frame() == this);
 284 
 285     // Don&#39;t use m_doc because it can be overwritten and we want to guarantee
 286     // that the document is not destroyed during this function call.
 287     if (newDocument)
 288         newDocument-&gt;didBecomeCurrentDocumentInFrame();
 289 
 290 #if ENABLE(ATTACHMENT_ELEMENT)
 291     if (m_doc) {
 292         for (auto&amp; attachment : m_doc-&gt;attachmentElementsByIdentifier().values())
 293             editor().didInsertAttachmentElement(attachment);
 294     }
 295 #endif
 296 
 297     InspectorInstrumentation::frameDocumentUpdated(*this);
 298 
</pre>
<hr />
<pre>
 540             return true;
 541         case DOMPasteAccessResponse::DeniedForGesture:
 542             return false;
 543         }
 544     }
 545     }
 546 
 547     ASSERT_NOT_REACHED();
 548     return false;
 549 }
 550 
 551 void Frame::setPrinting(bool printing, const FloatSize&amp; pageSize, const FloatSize&amp; originalPageSize, float maximumShrinkRatio, AdjustViewSizeOrNot shouldAdjustViewSize)
 552 {
 553     if (!view())
 554         return;
 555     // In setting printing, we should not validate resources already cached for the document.
 556     // See https://bugs.webkit.org/show_bug.cgi?id=43704
 557     ResourceCacheValidationSuppressor validationSuppressor(m_doc-&gt;cachedResourceLoader());
 558 
 559     m_doc-&gt;setPrinting(printing);
<span class="line-modified"> 560     auto&amp; frameView = *view();</span>
<span class="line-removed"> 561     frameView.adjustMediaTypeForPrinting(printing);</span>
 562 

 563     m_doc-&gt;styleScope().didChangeStyleSheetEnvironment();





 564     if (shouldUsePrintingLayout())
 565         frameView.forceLayoutForPagination(pageSize, originalPageSize, maximumShrinkRatio, shouldAdjustViewSize);
 566     else {
 567         frameView.forceLayout();
 568         if (shouldAdjustViewSize == AdjustViewSize)
 569             frameView.adjustViewSize();
 570     }
 571 
 572     // Subframes of the one we&#39;re printing don&#39;t lay out to the page size.
 573     for (RefPtr&lt;Frame&gt; child = tree().firstChild(); child; child = child-&gt;tree().nextSibling())
 574         child-&gt;setPrinting(printing, FloatSize(), FloatSize(), 0, shouldAdjustViewSize);
 575 }
 576 
 577 bool Frame::shouldUsePrintingLayout() const
 578 {
 579     // Only top frame being printed should be fit to page size.
 580     // Subframes should be constrained by parents only.
 581     return m_doc-&gt;printing() &amp;&amp; (!tree().parent() || !tree().parent()-&gt;m_doc-&gt;printing());
 582 }
 583 
</pre>
<hr />
<pre>
 612     m_page-&gt;userContentProvider().forEachUserScript([this, protectedThis = makeRef(*this), injectionTime](DOMWrapperWorld&amp; world, const UserScript&amp; script) {
 613         if (script.injectionTime() == injectionTime)
 614             injectUserScriptImmediately(world, script);
 615     });
 616 }
 617 
 618 void Frame::injectUserScriptImmediately(DOMWrapperWorld&amp; world, const UserScript&amp; script)
 619 {
 620     auto* document = this-&gt;document();
 621     if (!document)
 622         return;
 623     if (script.injectedFrames() == InjectInTopFrameOnly &amp;&amp; !isMainFrame())
 624         return;
 625     if (!UserContentURLPattern::matchesPatterns(document-&gt;url(), script.whitelist(), script.blacklist()))
 626         return;
 627     if (!m_script-&gt;shouldAllowUserAgentScripts(*document))
 628         return;
 629 
 630     document-&gt;setAsRunningUserScripts();
 631     loader().client().willInjectUserScript(world);
<span class="line-modified"> 632     m_script-&gt;evaluateInWorld(ScriptSourceCode(script.source(), URL(script.url())), world);</span>
 633 }
 634 
 635 RenderView* Frame::contentRenderer() const
 636 {
 637     return document() ? document()-&gt;renderView() : nullptr;
 638 }
 639 
 640 RenderWidget* Frame::ownerRenderer() const
 641 {
 642     auto* ownerElement = m_ownerElement;
 643     if (!ownerElement)
 644         return nullptr;
 645     auto* object = ownerElement-&gt;renderer();
 646     // FIXME: If &lt;object&gt; is ever fixed to disassociate itself from frames
 647     // that it has started but canceled, then this can turn into an ASSERT
 648     // since m_ownerElement would be nullptr when the load is canceled.
 649     // https://bugs.webkit.org/show_bug.cgi?id=18585
 650     if (!is&lt;RenderWidget&gt;(object))
 651         return nullptr;
 652     return downcast&lt;RenderWidget&gt;(object);
</pre>
<hr />
<pre>
 689         observer-&gt;willDetachPage();
 690 
 691     // FIXME: It&#39;s unclear as to why this is called more than once, but it is,
 692     // so page() could be NULL.
 693     if (page() &amp;&amp; page()-&gt;focusController().focusedFrame() == this)
 694         page()-&gt;focusController().setFocusedFrame(nullptr);
 695 
 696     if (page() &amp;&amp; page()-&gt;scrollingCoordinator() &amp;&amp; m_view)
 697         page()-&gt;scrollingCoordinator()-&gt;willDestroyScrollableArea(*m_view);
 698 
 699     script().clearScriptObjects();
 700     script().updatePlatformScriptObjects();
 701 
 702     // We promise that the Frame is always connected to a Page while the render tree is live.
 703     //
 704     // The render tree can be torn down in a few different ways, but the two important ones are:
 705     //
 706     // - When calling Frame::setView() with a null FrameView*. This is always done before calling
 707     //   Frame::willDetachPage (this function.) Hence the assertion below.
 708     //
<span class="line-modified"> 709     // - When adding a document to the page cache, the tree is torn down before instantiating</span>
 710     //   the CachedPage+CachedFrame object tree.
 711     ASSERT(!document() || !document()-&gt;renderView());
 712 }
 713 
 714 void Frame::disconnectOwnerElement()
 715 {
 716     if (m_ownerElement) {
 717         m_ownerElement-&gt;clearContentFrame();
 718         if (m_page)
 719             m_page-&gt;decrementSubframeCount();
 720     }
 721     m_ownerElement = nullptr;
 722 
 723     if (auto* document = this-&gt;document())
 724         document-&gt;frameWasDisconnectedFromOwner();
 725 }
 726 
 727 String Frame::displayStringModifiedByEncoding(const String&amp; str) const
 728 {
 729     return document() ? document()-&gt;displayStringModifiedByEncoding(str) : str;
</pre>
<hr />
<pre>
 897 
 898     m_pageZoomFactor = pageZoomFactor;
 899     m_textZoomFactor = textZoomFactor;
 900 
 901     document-&gt;resolveStyle(Document::ResolveStyleType::Rebuild);
 902 
 903     for (RefPtr&lt;Frame&gt; child = tree().firstChild(); child; child = child-&gt;tree().nextSibling())
 904         child-&gt;setPageAndTextZoomFactors(m_pageZoomFactor, m_textZoomFactor);
 905 
 906     if (FrameView* view = this-&gt;view()) {
 907         if (document-&gt;renderView() &amp;&amp; document-&gt;renderView()-&gt;needsLayout() &amp;&amp; view-&gt;didFirstLayout())
 908             view-&gt;layoutContext().layout();
 909     }
 910 }
 911 
 912 float Frame::frameScaleFactor() const
 913 {
 914     Page* page = this-&gt;page();
 915 
 916     // Main frame is scaled with respect to he container but inner frames are not scaled with respect to the main frame.
<span class="line-modified"> 917     if (!page || &amp;page-&gt;mainFrame() != this || settings().delegatesPageScaling())</span>



 918         return 1;
 919 
 920     return page-&gt;pageScaleFactor();
 921 }
 922 
 923 void Frame::suspendActiveDOMObjectsAndAnimations()
 924 {
 925     bool wasSuspended = activeDOMObjectsAndAnimationsSuspended();
 926 
 927     m_activeDOMObjectsAndAnimationsSuspendedCount++;
 928 
 929     if (wasSuspended)
 930         return;
 931 
 932     // FIXME: Suspend/resume calls will not match if the frame is navigated, and gets a new document.
 933     clearTimers(); // Suspends animations and pending relayouts.
 934     if (m_doc)
 935         m_doc-&gt;suspendScheduledTasks(ReasonForSuspension::PageWillBeSuspended);
 936 }
 937 
 938 void Frame::resumeActiveDOMObjectsAndAnimations()
 939 {
 940     if (!activeDOMObjectsAndAnimationsSuspended())
 941         return;
 942 
 943     m_activeDOMObjectsAndAnimationsSuspendedCount--;
 944 
 945     if (activeDOMObjectsAndAnimationsSuspended())
 946         return;
 947 
 948     if (!m_doc)
 949         return;
 950 
 951     // FIXME: Suspend/resume calls will not match if the frame is navigated, and gets a new document.
 952     m_doc-&gt;resumeScheduledTasks(ReasonForSuspension::PageWillBeSuspended);
 953 
 954     // Frame::clearTimers() suspended animations and pending relayouts.
<span class="line-modified"> 955     animation().resumeAnimationsForDocument(m_doc.get());</span>





 956     if (m_view)
 957         m_view-&gt;layoutContext().scheduleLayout();
 958 }
 959 
 960 void Frame::deviceOrPageScaleFactorChanged()
 961 {
 962     for (RefPtr&lt;Frame&gt; child = tree().firstChild(); child; child = child-&gt;tree().nextSibling())
 963         child-&gt;deviceOrPageScaleFactorChanged();
 964 
 965     if (RenderView* root = contentRenderer())
 966         root-&gt;compositor().deviceOrPageScaleFactorChanged();
 967 }
 968 
 969 bool Frame::isAlwaysOnLoggingAllowed() const
 970 {
 971     return page() &amp;&amp; page()-&gt;isAlwaysOnLoggingAllowed();
 972 }
 973 
 974 void Frame::dropChildren()
 975 {
</pre>
<hr />
<pre>
 996     ASSERT(isMainFrame());
 997     if (m_selfOnlyRefCount++)
 998         return;
 999 
1000     ref();
1001 }
1002 
1003 void Frame::selfOnlyDeref()
1004 {
1005     ASSERT(isMainFrame());
1006     ASSERT(m_selfOnlyRefCount);
1007     if (--m_selfOnlyRefCount)
1008         return;
1009 
1010     if (hasOneRef())
1011         dropChildren();
1012 
1013     deref();
1014 }
1015 
<span class="line-removed">1016 PAL::SessionID Frame::sessionID() const</span>
<span class="line-removed">1017 {</span>
<span class="line-removed">1018     return m_loader-&gt;client().sessionID();</span>
<span class="line-removed">1019 }</span>
<span class="line-removed">1020 </span>
1021 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  14  * This library is free software; you can redistribute it and/or
  15  * modify it under the terms of the GNU Library General Public
  16  * License as published by the Free Software Foundation; either
  17  * version 2 of the License, or (at your option) any later version.
  18  *
  19  * This library is distributed in the hope that it will be useful,
  20  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  21  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  22  * Library General Public License for more details.
  23  *
  24  * You should have received a copy of the GNU Library General Public License
  25  * along with this library; see the file COPYING.LIB.  If not, write to
  26  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  27  * Boston, MA 02110-1301, USA.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;Frame.h&quot;
  32 
  33 #include &quot;ApplyStyleCommand.h&quot;
<span class="line-added">  34 #include &quot;BackForwardCache.h&quot;</span>
  35 #include &quot;BackForwardController.h&quot;
  36 #include &quot;CSSAnimationController.h&quot;
  37 #include &quot;CSSComputedStyleDeclaration.h&quot;
  38 #include &quot;CSSPropertyNames.h&quot;
  39 #include &quot;CachedCSSStyleSheet.h&quot;
  40 #include &quot;CachedResourceLoader.h&quot;
  41 #include &quot;Chrome.h&quot;
  42 #include &quot;ChromeClient.h&quot;
  43 #include &quot;DOMWindow.h&quot;
  44 #include &quot;DocumentTimeline.h&quot;
  45 #include &quot;DocumentType.h&quot;
  46 #include &quot;Editing.h&quot;
  47 #include &quot;Editor.h&quot;
  48 #include &quot;EditorClient.h&quot;
  49 #include &quot;Event.h&quot;
  50 #include &quot;EventHandler.h&quot;
  51 #include &quot;EventNames.h&quot;
  52 #include &quot;FloatQuad.h&quot;
  53 #include &quot;FocusController.h&quot;
  54 #include &quot;FrameDestructionObserver.h&quot;
</pre>
<hr />
<pre>
  57 #include &quot;FrameSelection.h&quot;
  58 #include &quot;FrameView.h&quot;
  59 #include &quot;GraphicsContext.h&quot;
  60 #include &quot;GraphicsLayer.h&quot;
  61 #include &quot;HTMLFormControlElement.h&quot;
  62 #include &quot;HTMLFormElement.h&quot;
  63 #include &quot;HTMLFrameElementBase.h&quot;
  64 #include &quot;HTMLNames.h&quot;
  65 #include &quot;HTMLTableCellElement.h&quot;
  66 #include &quot;HTMLTableRowElement.h&quot;
  67 #include &quot;HitTestResult.h&quot;
  68 #include &quot;ImageBuffer.h&quot;
  69 #include &quot;InspectorInstrumentation.h&quot;
  70 #include &quot;JSWindowProxy.h&quot;
  71 #include &quot;Logging.h&quot;
  72 #include &quot;NavigationScheduler.h&quot;
  73 #include &quot;Navigator.h&quot;
  74 #include &quot;NodeList.h&quot;
  75 #include &quot;NodeTraversal.h&quot;
  76 #include &quot;Page.h&quot;

  77 #include &quot;ProcessWarming.h&quot;
  78 #include &quot;RenderLayerCompositor.h&quot;
  79 #include &quot;RenderTableCell.h&quot;
  80 #include &quot;RenderText.h&quot;
  81 #include &quot;RenderTextControl.h&quot;
  82 #include &quot;RenderTheme.h&quot;
  83 #include &quot;RenderView.h&quot;
  84 #include &quot;RenderWidget.h&quot;
  85 #include &quot;RuntimeEnabledFeatures.h&quot;
  86 #include &quot;SVGDocument.h&quot;
  87 #include &quot;SVGDocumentExtensions.h&quot;
  88 #include &quot;ScriptController.h&quot;
  89 #include &quot;ScriptSourceCode.h&quot;
  90 #include &quot;ScrollingCoordinator.h&quot;
  91 #include &quot;Settings.h&quot;
  92 #include &quot;StyleProperties.h&quot;
  93 #include &quot;StyleScope.h&quot;
  94 #include &quot;TextNodeTraversal.h&quot;
  95 #include &quot;TextResourceDecoder.h&quot;
  96 #include &quot;UserContentController.h&quot;
</pre>
<hr />
<pre>
 213 {
 214     m_destructionObservers.add(observer);
 215 }
 216 
 217 void Frame::removeDestructionObserver(FrameDestructionObserver* observer)
 218 {
 219     m_destructionObservers.remove(observer);
 220 }
 221 
 222 void Frame::setView(RefPtr&lt;FrameView&gt;&amp;&amp; view)
 223 {
 224     // We the custom scroll bars as early as possible to prevent m_doc-&gt;detach()
 225     // from messing with the view such that its scroll bars won&#39;t be torn down.
 226     // FIXME: We should revisit this.
 227     if (m_view)
 228         m_view-&gt;prepareForDetach();
 229 
 230     // Prepare for destruction now, so any unload event handlers get run and the DOMWindow is
 231     // notified. If we wait until the view is destroyed, then things won&#39;t be hooked up enough for
 232     // these calls to work.
<span class="line-modified"> 233     if (!view &amp;&amp; m_doc &amp;&amp; m_doc-&gt;backForwardCacheState() != Document::InBackForwardCache)</span>
 234         m_doc-&gt;prepareForDestruction();
 235 
 236     if (m_view)
 237         m_view-&gt;layoutContext().unscheduleLayout();
 238 
 239     m_eventHandler-&gt;clear();
 240 
 241     RELEASE_ASSERT(!m_doc || !m_doc-&gt;hasLivingRenderTree());
 242 
 243     m_view = WTFMove(view);
 244 
 245     // Only one form submission is allowed per view of a part.
 246     // Since this part may be getting reused as a result of being
 247     // pulled from the back/forward cache, reset this flag.
 248     loader().resetMultipleFormSubmissionProtection();
 249 }
 250 
 251 void Frame::setDocument(RefPtr&lt;Document&gt;&amp;&amp; newDocument)
 252 {
 253     ASSERT(!newDocument || newDocument-&gt;frame() == this);
</pre>
<hr />
<pre>
 258     m_documentIsBeingReplaced = true;
 259 
 260     if (isMainFrame()) {
 261         if (m_page)
 262             m_page-&gt;didChangeMainDocument();
 263         m_loader-&gt;client().dispatchDidChangeMainDocument();
 264 
 265         // We want to generate the same unique names whenever a page is loaded to avoid making layout tests
 266         // flaky and for things like form state restoration to work. To achieve this, we reset our frame
 267         // identifier generator every time the page is navigated.
 268         tree().resetFrameIdentifiers();
 269     }
 270 
 271 #if ENABLE(ATTACHMENT_ELEMENT)
 272     if (m_doc) {
 273         for (auto&amp; attachment : m_doc-&gt;attachmentElementsByIdentifier().values())
 274             editor().didRemoveAttachmentElement(attachment);
 275     }
 276 #endif
 277 
<span class="line-modified"> 278     if (m_doc &amp;&amp; m_doc-&gt;backForwardCacheState() != Document::InBackForwardCache)</span>
 279         m_doc-&gt;prepareForDestruction();
 280 
 281     m_doc = newDocument.copyRef();
 282     ASSERT(!m_doc || m_doc-&gt;domWindow());
 283     ASSERT(!m_doc || m_doc-&gt;domWindow()-&gt;frame() == this);
 284 
 285     // Don&#39;t use m_doc because it can be overwritten and we want to guarantee
 286     // that the document is not destroyed during this function call.
 287     if (newDocument)
 288         newDocument-&gt;didBecomeCurrentDocumentInFrame();
 289 
 290 #if ENABLE(ATTACHMENT_ELEMENT)
 291     if (m_doc) {
 292         for (auto&amp; attachment : m_doc-&gt;attachmentElementsByIdentifier().values())
 293             editor().didInsertAttachmentElement(attachment);
 294     }
 295 #endif
 296 
 297     InspectorInstrumentation::frameDocumentUpdated(*this);
 298 
</pre>
<hr />
<pre>
 540             return true;
 541         case DOMPasteAccessResponse::DeniedForGesture:
 542             return false;
 543         }
 544     }
 545     }
 546 
 547     ASSERT_NOT_REACHED();
 548     return false;
 549 }
 550 
 551 void Frame::setPrinting(bool printing, const FloatSize&amp; pageSize, const FloatSize&amp; originalPageSize, float maximumShrinkRatio, AdjustViewSizeOrNot shouldAdjustViewSize)
 552 {
 553     if (!view())
 554         return;
 555     // In setting printing, we should not validate resources already cached for the document.
 556     // See https://bugs.webkit.org/show_bug.cgi?id=43704
 557     ResourceCacheValidationSuppressor validationSuppressor(m_doc-&gt;cachedResourceLoader());
 558 
 559     m_doc-&gt;setPrinting(printing);
<span class="line-modified"> 560     view()-&gt;adjustMediaTypeForPrinting(printing);</span>

 561 
<span class="line-added"> 562     // FIXME: Consider invoking Page::updateRendering or an equivalent.</span>
 563     m_doc-&gt;styleScope().didChangeStyleSheetEnvironment();
<span class="line-added"> 564     m_doc-&gt;evaluateMediaQueriesAndReportChanges();</span>
<span class="line-added"> 565     if (!view())</span>
<span class="line-added"> 566         return;</span>
<span class="line-added"> 567 </span>
<span class="line-added"> 568     auto&amp; frameView = *view();</span>
 569     if (shouldUsePrintingLayout())
 570         frameView.forceLayoutForPagination(pageSize, originalPageSize, maximumShrinkRatio, shouldAdjustViewSize);
 571     else {
 572         frameView.forceLayout();
 573         if (shouldAdjustViewSize == AdjustViewSize)
 574             frameView.adjustViewSize();
 575     }
 576 
 577     // Subframes of the one we&#39;re printing don&#39;t lay out to the page size.
 578     for (RefPtr&lt;Frame&gt; child = tree().firstChild(); child; child = child-&gt;tree().nextSibling())
 579         child-&gt;setPrinting(printing, FloatSize(), FloatSize(), 0, shouldAdjustViewSize);
 580 }
 581 
 582 bool Frame::shouldUsePrintingLayout() const
 583 {
 584     // Only top frame being printed should be fit to page size.
 585     // Subframes should be constrained by parents only.
 586     return m_doc-&gt;printing() &amp;&amp; (!tree().parent() || !tree().parent()-&gt;m_doc-&gt;printing());
 587 }
 588 
</pre>
<hr />
<pre>
 617     m_page-&gt;userContentProvider().forEachUserScript([this, protectedThis = makeRef(*this), injectionTime](DOMWrapperWorld&amp; world, const UserScript&amp; script) {
 618         if (script.injectionTime() == injectionTime)
 619             injectUserScriptImmediately(world, script);
 620     });
 621 }
 622 
 623 void Frame::injectUserScriptImmediately(DOMWrapperWorld&amp; world, const UserScript&amp; script)
 624 {
 625     auto* document = this-&gt;document();
 626     if (!document)
 627         return;
 628     if (script.injectedFrames() == InjectInTopFrameOnly &amp;&amp; !isMainFrame())
 629         return;
 630     if (!UserContentURLPattern::matchesPatterns(document-&gt;url(), script.whitelist(), script.blacklist()))
 631         return;
 632     if (!m_script-&gt;shouldAllowUserAgentScripts(*document))
 633         return;
 634 
 635     document-&gt;setAsRunningUserScripts();
 636     loader().client().willInjectUserScript(world);
<span class="line-modified"> 637     m_script-&gt;evaluateInWorldIgnoringException(ScriptSourceCode(script.source(), URL(script.url())), world);</span>
 638 }
 639 
 640 RenderView* Frame::contentRenderer() const
 641 {
 642     return document() ? document()-&gt;renderView() : nullptr;
 643 }
 644 
 645 RenderWidget* Frame::ownerRenderer() const
 646 {
 647     auto* ownerElement = m_ownerElement;
 648     if (!ownerElement)
 649         return nullptr;
 650     auto* object = ownerElement-&gt;renderer();
 651     // FIXME: If &lt;object&gt; is ever fixed to disassociate itself from frames
 652     // that it has started but canceled, then this can turn into an ASSERT
 653     // since m_ownerElement would be nullptr when the load is canceled.
 654     // https://bugs.webkit.org/show_bug.cgi?id=18585
 655     if (!is&lt;RenderWidget&gt;(object))
 656         return nullptr;
 657     return downcast&lt;RenderWidget&gt;(object);
</pre>
<hr />
<pre>
 694         observer-&gt;willDetachPage();
 695 
 696     // FIXME: It&#39;s unclear as to why this is called more than once, but it is,
 697     // so page() could be NULL.
 698     if (page() &amp;&amp; page()-&gt;focusController().focusedFrame() == this)
 699         page()-&gt;focusController().setFocusedFrame(nullptr);
 700 
 701     if (page() &amp;&amp; page()-&gt;scrollingCoordinator() &amp;&amp; m_view)
 702         page()-&gt;scrollingCoordinator()-&gt;willDestroyScrollableArea(*m_view);
 703 
 704     script().clearScriptObjects();
 705     script().updatePlatformScriptObjects();
 706 
 707     // We promise that the Frame is always connected to a Page while the render tree is live.
 708     //
 709     // The render tree can be torn down in a few different ways, but the two important ones are:
 710     //
 711     // - When calling Frame::setView() with a null FrameView*. This is always done before calling
 712     //   Frame::willDetachPage (this function.) Hence the assertion below.
 713     //
<span class="line-modified"> 714     // - When adding a document to the back/forward cache, the tree is torn down before instantiating</span>
 715     //   the CachedPage+CachedFrame object tree.
 716     ASSERT(!document() || !document()-&gt;renderView());
 717 }
 718 
 719 void Frame::disconnectOwnerElement()
 720 {
 721     if (m_ownerElement) {
 722         m_ownerElement-&gt;clearContentFrame();
 723         if (m_page)
 724             m_page-&gt;decrementSubframeCount();
 725     }
 726     m_ownerElement = nullptr;
 727 
 728     if (auto* document = this-&gt;document())
 729         document-&gt;frameWasDisconnectedFromOwner();
 730 }
 731 
 732 String Frame::displayStringModifiedByEncoding(const String&amp; str) const
 733 {
 734     return document() ? document()-&gt;displayStringModifiedByEncoding(str) : str;
</pre>
<hr />
<pre>
 902 
 903     m_pageZoomFactor = pageZoomFactor;
 904     m_textZoomFactor = textZoomFactor;
 905 
 906     document-&gt;resolveStyle(Document::ResolveStyleType::Rebuild);
 907 
 908     for (RefPtr&lt;Frame&gt; child = tree().firstChild(); child; child = child-&gt;tree().nextSibling())
 909         child-&gt;setPageAndTextZoomFactors(m_pageZoomFactor, m_textZoomFactor);
 910 
 911     if (FrameView* view = this-&gt;view()) {
 912         if (document-&gt;renderView() &amp;&amp; document-&gt;renderView()-&gt;needsLayout() &amp;&amp; view-&gt;didFirstLayout())
 913             view-&gt;layoutContext().layout();
 914     }
 915 }
 916 
 917 float Frame::frameScaleFactor() const
 918 {
 919     Page* page = this-&gt;page();
 920 
 921     // Main frame is scaled with respect to he container but inner frames are not scaled with respect to the main frame.
<span class="line-modified"> 922     if (!page || !isMainFrame())</span>
<span class="line-added"> 923         return 1;</span>
<span class="line-added"> 924 </span>
<span class="line-added"> 925     if (page-&gt;delegatesScaling())</span>
 926         return 1;
 927 
 928     return page-&gt;pageScaleFactor();
 929 }
 930 
 931 void Frame::suspendActiveDOMObjectsAndAnimations()
 932 {
 933     bool wasSuspended = activeDOMObjectsAndAnimationsSuspended();
 934 
 935     m_activeDOMObjectsAndAnimationsSuspendedCount++;
 936 
 937     if (wasSuspended)
 938         return;
 939 
 940     // FIXME: Suspend/resume calls will not match if the frame is navigated, and gets a new document.
 941     clearTimers(); // Suspends animations and pending relayouts.
 942     if (m_doc)
 943         m_doc-&gt;suspendScheduledTasks(ReasonForSuspension::PageWillBeSuspended);
 944 }
 945 
 946 void Frame::resumeActiveDOMObjectsAndAnimations()
 947 {
 948     if (!activeDOMObjectsAndAnimationsSuspended())
 949         return;
 950 
 951     m_activeDOMObjectsAndAnimationsSuspendedCount--;
 952 
 953     if (activeDOMObjectsAndAnimationsSuspended())
 954         return;
 955 
 956     if (!m_doc)
 957         return;
 958 
 959     // FIXME: Suspend/resume calls will not match if the frame is navigated, and gets a new document.
 960     m_doc-&gt;resumeScheduledTasks(ReasonForSuspension::PageWillBeSuspended);
 961 
 962     // Frame::clearTimers() suspended animations and pending relayouts.
<span class="line-modified"> 963 </span>
<span class="line-added"> 964     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {</span>
<span class="line-added"> 965         if (auto* timeline = m_doc-&gt;existingTimeline())</span>
<span class="line-added"> 966             timeline-&gt;resumeAnimations();</span>
<span class="line-added"> 967     } else</span>
<span class="line-added"> 968         animation().resumeAnimationsForDocument(m_doc.get());</span>
 969     if (m_view)
 970         m_view-&gt;layoutContext().scheduleLayout();
 971 }
 972 
 973 void Frame::deviceOrPageScaleFactorChanged()
 974 {
 975     for (RefPtr&lt;Frame&gt; child = tree().firstChild(); child; child = child-&gt;tree().nextSibling())
 976         child-&gt;deviceOrPageScaleFactorChanged();
 977 
 978     if (RenderView* root = contentRenderer())
 979         root-&gt;compositor().deviceOrPageScaleFactorChanged();
 980 }
 981 
 982 bool Frame::isAlwaysOnLoggingAllowed() const
 983 {
 984     return page() &amp;&amp; page()-&gt;isAlwaysOnLoggingAllowed();
 985 }
 986 
 987 void Frame::dropChildren()
 988 {
</pre>
<hr />
<pre>
1009     ASSERT(isMainFrame());
1010     if (m_selfOnlyRefCount++)
1011         return;
1012 
1013     ref();
1014 }
1015 
1016 void Frame::selfOnlyDeref()
1017 {
1018     ASSERT(isMainFrame());
1019     ASSERT(m_selfOnlyRefCount);
1020     if (--m_selfOnlyRefCount)
1021         return;
1022 
1023     if (hasOneRef())
1024         dropChildren();
1025 
1026     deref();
1027 }
1028 





1029 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="FocusController.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Frame.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
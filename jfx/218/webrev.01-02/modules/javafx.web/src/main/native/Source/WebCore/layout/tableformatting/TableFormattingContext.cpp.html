<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/layout/tableformatting/TableFormattingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;TableFormattingContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &quot;DisplayBox.h&quot;
 32 #include &quot;InvalidationState.h&quot;
 33 #include &quot;LayoutBox.h&quot;
 34 #include &quot;LayoutChildIterator.h&quot;
 35 #include &quot;LayoutContext.h&quot;
 36 #include &quot;TableFormattingState.h&quot;
 37 #include &lt;wtf/IsoMallocInlines.h&gt;
 38 
 39 namespace WebCore {
 40 namespace Layout {
 41 
 42 WTF_MAKE_ISO_ALLOCATED_IMPL(TableFormattingContext);
 43 
 44 // FIXME: This is temporary. Remove this function when table formatting is complete.
 45 void TableFormattingContext::initializeDisplayBoxToBlank(Display::Box&amp; displayBox) const
 46 {
 47     displayBox.setBorder({ });
 48     displayBox.setPadding({ });
 49     displayBox.setHorizontalMargin({ });
 50     displayBox.setHorizontalComputedMargin({ });
 51     displayBox.setVerticalMargin({ { }, { } });
 52     displayBox.setTopLeft({ });
 53     displayBox.setContentBoxWidth({ });
 54     displayBox.setContentBoxHeight({ });
 55 }
 56 
 57 // https://www.w3.org/TR/css-tables-3/#table-layout-algorithm
 58 TableFormattingContext::TableFormattingContext(const Container&amp; formattingContextRoot, TableFormattingState&amp; formattingState)
 59     : FormattingContext(formattingContextRoot, formattingState)
 60 {
 61 }
 62 
 63 void TableFormattingContext::layoutInFlowContent(InvalidationState&amp; invalidationState, const HorizontalConstraints&amp; horizontalConstraints, const VerticalConstraints&amp;)
 64 {
 65     auto&amp; grid = formattingState().tableGrid();
 66     auto&amp; columnsContext = grid.columnsContext();
 67 
 68     computeAndDistributeExtraHorizontalSpace();
 69     // 1. Position each column.
 70     // FIXME: This should also deal with collapsing borders etc.
 71     auto horizontalSpacing = grid.horizontalSpacing();
 72     auto columnLogicalLeft = horizontalSpacing;
 73     for (auto&amp; column : columnsContext.columns()) {
 74         column.setLogicalLeft(columnLogicalLeft);
 75         columnLogicalLeft += (column.logicalWidth() + horizontalSpacing);
 76     }
 77 
 78     // 2. Layout each table cell (and compute row height as well).
 79     auto&amp; columnList = columnsContext.columns();
 80     auto&amp; cellList = grid.cells();
 81     ASSERT(!cellList.isEmpty());
 82     for (auto&amp; cell : cellList) {
 83         auto&amp; cellLayoutBox = cell-&gt;tableCellBox;
 84         layoutTableCellBox(cellLayoutBox, columnList.at(cell-&gt;position.x()), invalidationState, horizontalConstraints);
 85         // FIXME: Add support for column and row spanning and this requires a 2 pass layout.
 86         auto&amp; row = grid.rows().at(cell-&gt;position.y());
 87         row.setLogicalHeight(std::max(row.logicalHeight(), geometryForBox(cellLayoutBox).marginBoxHeight()));
 88     }
 89     // This is after the second pass when cell heights are fully computed.
 90     auto rowLogicalTop = grid.verticalSpacing();
 91     for (auto&amp; row : grid.rows()) {
 92         row.setLogicalTop(rowLogicalTop);
 93         rowLogicalTop += (row.logicalHeight() + grid.verticalSpacing());
 94     }
 95 
 96     // 3. Finalize size and position.
 97     positionTableCells();
 98     setComputedGeometryForSections();
 99     setComputedGeometryForRows();
100 }
101 
102 void TableFormattingContext::layoutTableCellBox(const Box&amp; cellLayoutBox, const TableGrid::Column&amp; column, InvalidationState&amp; invalidationState, const HorizontalConstraints&amp; horizontalConstraints)
103 {
104     computeBorderAndPadding(cellLayoutBox, horizontalConstraints);
105     // Margins do not apply to internal table elements.
106     auto&amp; cellDisplayBox = formattingState().displayBox(cellLayoutBox);
107     cellDisplayBox.setHorizontalMargin({ });
108     cellDisplayBox.setHorizontalComputedMargin({ });
109     // Don&#39;t know the actual position yet.
110     cellDisplayBox.setTopLeft({ });
111     cellDisplayBox.setContentBoxWidth(column.logicalWidth() - cellDisplayBox.horizontalMarginBorderAndPadding());
112 
113     ASSERT(cellLayoutBox.establishesBlockFormattingContext());
114     if (is&lt;Container&gt;(cellLayoutBox) &amp;&amp; downcast&lt;Container&gt;(cellLayoutBox).hasInFlowOrFloatingChild())
115         LayoutContext::createFormattingContext(downcast&lt;Container&gt;(cellLayoutBox), layoutState())-&gt;layoutInFlowContent(invalidationState, Geometry::horizontalConstraintsForInFlow(cellDisplayBox), Geometry::verticalConstraintsForInFlow(cellDisplayBox));
116     cellDisplayBox.setVerticalMargin({ { }, { } });
117     cellDisplayBox.setContentBoxHeight(geometry().tableCellHeightAndMargin(cellLayoutBox).contentHeight);
118     // FIXME: Check what to do with out-of-flow content.
119 }
120 
121 void TableFormattingContext::positionTableCells()
122 {
123     auto&amp; grid = formattingState().tableGrid();
124     auto&amp; rowList = grid.rows();
125     auto&amp; columnList = grid.columnsContext().columns();
126     for (auto&amp; cell : grid.cells()) {
127         auto&amp; cellDisplayBox = formattingState().displayBox(cell-&gt;tableCellBox);
128         cellDisplayBox.setTop(rowList.at(cell-&gt;position.y()).logicalTop());
129         cellDisplayBox.setLeft(columnList.at(cell-&gt;position.x()).logicalLeft());
130     }
131 }
132 
133 void TableFormattingContext::setComputedGeometryForRows()
134 {
135     auto&amp; grid = formattingState().tableGrid();
136     auto rowWidth = grid.columnsContext().logicalWidth() + 2 * grid.horizontalSpacing();
137 
138     auto&amp; rowList = grid.rows();
139     for (auto&amp; row : rowList) {
140         auto&amp; rowDisplayBox = formattingState().displayBox(row.box());
141         initializeDisplayBoxToBlank(rowDisplayBox);
142         rowDisplayBox.setContentBoxHeight(row.logicalHeight());
143         rowDisplayBox.setContentBoxWidth(rowWidth);
144         rowDisplayBox.setTop(row.logicalTop());
145     }
146 }
147 
148 void TableFormattingContext::setComputedGeometryForSections()
149 {
150     auto&amp; grid = formattingState().tableGrid();
151     auto sectionWidth = grid.columnsContext().logicalWidth() + 2 * grid.horizontalSpacing();
152 
153     for (auto&amp; section : childrenOfType&lt;Box&gt;(root())) {
154         auto&amp; sectionDisplayBox = formattingState().displayBox(section);
155         initializeDisplayBoxToBlank(sectionDisplayBox);
156         // FIXME: Size table sections properly.
157         sectionDisplayBox.setContentBoxWidth(sectionWidth);
158         sectionDisplayBox.setContentBoxHeight(grid.rows().last().logicalBottom() + grid.verticalSpacing());
159     }
160 }
161 
162 FormattingContext::IntrinsicWidthConstraints TableFormattingContext::computedIntrinsicWidthConstraints()
163 {
164     // Tables have a slighty different concept of shrink to fit. It&#39;s really only different with non-auto &quot;width&quot; values, where
165     // a generic shrink-to fit block level box like a float box would be just sized to the computed value of &quot;width&quot;, tables
166     // can actually be streched way over.
167     auto&amp; grid = formattingState().tableGrid();
168     if (!grid.hasComputedWidthConstraints()) {
169         // 1. Ensure each cell slot is occupied by at least one cell.
170         ensureTableGrid();
171         // 2. Compute the minimum/maximum width of each column.
172         computePreferredWidthForColumns();
173     }
174     return grid.widthConstraints();
175 }
176 
177 void TableFormattingContext::ensureTableGrid()
178 {
179     auto&amp; tableBox = root();
180     auto&amp; tableGrid = formattingState().tableGrid();
181     tableGrid.setHorizontalSpacing(LayoutUnit { tableBox.style().horizontalBorderSpacing() });
182     tableGrid.setVerticalSpacing(LayoutUnit { tableBox.style().verticalBorderSpacing() });
183 
184     auto* firstChild = tableBox.firstChild();
185     const Box* tableCaption = nullptr;
186     const Box* colgroup = nullptr;
187     // Table caption is an optional element; if used, it is always the first child of a &lt;table&gt;.
188     if (firstChild-&gt;isTableCaption())
189         tableCaption = firstChild;
190     // The &lt;colgroup&gt; must appear after any optional &lt;caption&gt; element but before any &lt;thead&gt;, &lt;th&gt;, &lt;tbody&gt;, &lt;tfoot&gt; and &lt;tr&gt; element.
191     auto* colgroupCandidate = firstChild;
192     if (tableCaption)
193         colgroupCandidate = tableCaption-&gt;nextSibling();
194     if (colgroupCandidate-&gt;isTableColumnGroup())
195         colgroup = colgroupCandidate;
196 
197     if (colgroup) {
198         auto&amp; columnsContext = tableGrid.columnsContext();
199         for (auto* column = downcast&lt;Container&gt;(*colgroup).firstChild(); column; column = column-&gt;nextSibling()) {
200             ASSERT(column-&gt;isTableColumn());
201             auto columnSpanCount = column-&gt;columnSpan();
202             ASSERT(columnSpanCount &gt; 0);
203             while (columnSpanCount--)
204                 columnsContext.addColumn(column);
205         }
206     }
207 
208     auto* firstSection = colgroup ? colgroup-&gt;nextSibling() : tableCaption ? tableCaption-&gt;nextSibling() : firstChild;
209     for (auto* section = firstSection; section; section = section-&gt;nextSibling()) {
210         ASSERT(section-&gt;isTableHeader() || section-&gt;isTableBody() || section-&gt;isTableFooter());
211         for (auto* row = downcast&lt;Container&gt;(*section).firstChild(); row; row = row-&gt;nextSibling()) {
212             ASSERT(row-&gt;isTableRow());
213             for (auto* cell = downcast&lt;Container&gt;(*row).firstChild(); cell; cell = cell-&gt;nextSibling()) {
214                 ASSERT(cell-&gt;isTableCell());
215                 tableGrid.appendCell(*cell);
216             }
217         }
218     }
219 }
220 
221 void TableFormattingContext::computePreferredWidthForColumns()
222 {
223     auto&amp; formattingState = this-&gt;formattingState();
224     auto&amp; grid = formattingState.tableGrid();
225     ASSERT(!grid.hasComputedWidthConstraints());
226 
227     // 1. Calculate the minimum content width (MCW) of each cell: the formatted content may span any number of lines but may not overflow the cell box.
228     //    If the specified &#39;width&#39; (W) of the cell is greater than MCW, W is the minimum cell width. A value of &#39;auto&#39; means that MCW is the minimum cell width.
229     //    Also, calculate the &quot;maximum&quot; cell width of each cell: formatting the content without breaking lines other than where explicit line breaks occur.
230     for (auto&amp; cell : grid.cells()) {
231         auto&amp; tableCellBox = cell-&gt;tableCellBox;
232         ASSERT(tableCellBox.establishesFormattingContext());
233 
234         auto intrinsicWidth = formattingState.intrinsicWidthConstraintsForBox(tableCellBox);
235         if (!intrinsicWidth) {
236             intrinsicWidth = IntrinsicWidthConstraints { };
237             if (is&lt;Container&gt;(tableCellBox))
238                 intrinsicWidth = LayoutContext::createFormattingContext(downcast&lt;Container&gt;(tableCellBox), layoutState())-&gt;computedIntrinsicWidthConstraints();
239             intrinsicWidth = geometry().constrainByMinMaxWidth(tableCellBox, *intrinsicWidth);
240             auto border = geometry().computedBorder(tableCellBox);
241             auto padding = *geometry().computedPadding(tableCellBox, { });
242 
243             intrinsicWidth-&gt;expand(border.horizontal.width() + padding.horizontal.width());
244             formattingState.setIntrinsicWidthConstraintsForBox(tableCellBox, *intrinsicWidth);
245         }
246 
247         auto columnSpan = cell-&gt;size.width();
248         auto slotIntrinsicWidth = FormattingContext::IntrinsicWidthConstraints { intrinsicWidth-&gt;minimum / columnSpan, intrinsicWidth-&gt;maximum / columnSpan };
249         auto initialPosition = cell-&gt;position;
250         for (auto i = 0; i &lt; columnSpan; ++i)
251             grid.slot({ initialPosition.x() + i, initialPosition.y() })-&gt;widthConstraints = slotIntrinsicWidth;
252     }
253     // 2. For each column, determine a maximum and minimum column width from the cells that span only that column.
254     //    The minimum is that required by the cell with the largest minimum cell width (or the column &#39;width&#39;, whichever is larger).
255     //    The maximum is that required by the cell with the largest maximum cell width (or the column &#39;width&#39;, whichever is larger).
256     auto&amp; columns = grid.columnsContext().columns();
257     int numberOfRows = grid.rows().size();
258     int numberOfColumns = columns.size();
259     for (int columnIndex = 0; columnIndex &lt; numberOfColumns; ++columnIndex) {
260         auto columnIntrinsicWidths = FormattingContext::IntrinsicWidthConstraints { };
261         for (int rowIndex = 0; rowIndex &lt; numberOfRows; ++rowIndex) {
262             auto* slot = grid.slot({ columnIndex, rowIndex });
263             columnIntrinsicWidths.minimum = std::max(slot-&gt;widthConstraints.minimum, columnIntrinsicWidths.minimum);
264             columnIntrinsicWidths.maximum = std::max(slot-&gt;widthConstraints.maximum, columnIntrinsicWidths.maximum);
265         }
266         // Now that we have the content driven min/max widths, check if &lt;col&gt; sets a preferred width on this column.
267         if (auto* columnBox = columns[columnIndex].columnBox()) {
268             if (auto columnPreferredWidth = geometry().computedColumnWidth(*columnBox)) {
269                 // Let&#39;s stay at least as wide as the preferred width.
270                 columnIntrinsicWidths.minimum = std::max(columnIntrinsicWidths.minimum, *columnPreferredWidth);
271             }
272         }
273         columns[columnIndex].setWidthConstraints(columnIntrinsicWidths);
274     }
275 }
276 
277 void TableFormattingContext::computeAndDistributeExtraHorizontalSpace()
278 {
279     auto&amp; grid = formattingState().tableGrid();
280     ASSERT(grid.hasComputedWidthConstraints());
281     auto tableWidthConstraints = grid.widthConstraints();
282 
283     // Column and caption widths influence the final table width as follows:
284     // If the &#39;table&#39; or &#39;inline-table&#39; element&#39;s &#39;width&#39; property has a computed value (W) other than &#39;auto&#39;, the used width is the greater of
285     // W, CAPMIN, and the minimum width required by all the columns plus cell spacing or borders (MIN).
286     // If the used width is greater than MIN, the extra width should be distributed over the columns.
287     // If the &#39;table&#39; or &#39;inline-table&#39; element has &#39;width: auto&#39;, the used width is the greater of the table&#39;s containing block width,
288     // CAPMIN, and MIN. However, if either CAPMIN or the maximum width required by the columns plus cell spacing or borders (MAX) is
289     // less than that of the containing block, use max(MAX, CAPMIN).
290     auto distributeExtraHorizontalSpace = [&amp;](auto extraHorizontalSpace) {
291         auto&amp; columns = grid.columnsContext().columns();
292         ASSERT(!columns.isEmpty());
293 
294         auto tableMinimumContentWidth = tableWidthConstraints.minimum - grid.totalHorizontalSpacing();
295         auto adjustabledHorizontalSpace = tableMinimumContentWidth;
296         auto numberOfColumns = columns.size();
297         // Fixed width columns don&#39;t participate in available space distribution.
298         for (auto&amp; column : columns) {
299             if (!column.hasFixedWidth())
300                 continue;
301             auto columnFixedWidth = *column.columnBox()-&gt;columnWidth();
302             column.setLogicalWidth(columnFixedWidth);
303 
304             --numberOfColumns;
305             adjustabledHorizontalSpace -= columnFixedWidth;
306         }
307         if (!numberOfColumns || !adjustabledHorizontalSpace)
308             return;
309         // FIXME: Right now just distribute the extra space equaly among the columns using the minimum width.
310         ASSERT(adjustabledHorizontalSpace &gt; 0);
311         for (auto&amp; column : columns) {
312             if (column.hasFixedWidth())
313                 continue;
314             auto columnExtraSpace = extraHorizontalSpace / adjustabledHorizontalSpace * column.widthConstraints().minimum;
315             column.setLogicalWidth(column.widthConstraints().minimum + columnExtraSpace);
316         }
317     };
318 
319     auto&amp; tableBox = root();
320     auto containingBlockWidth = geometryForBox(*tableBox.containingBlock(), EscapeReason::TableNeedsAccessToTableWrapper).contentBoxWidth();
321     auto contentWidth = geometry().computedContentWidth(tableBox, containingBlockWidth);
322     if (contentWidth) {
323         if (*contentWidth &gt; tableWidthConstraints.minimum)
324             distributeExtraHorizontalSpace(*contentWidth - tableWidthConstraints.minimum);
325         else
326             useAsContentLogicalWidth(WidthConstraintsType::Minimum);
327     } else {
328         if (tableWidthConstraints.minimum &gt; containingBlockWidth)
329             useAsContentLogicalWidth(WidthConstraintsType::Minimum);
330         else if (tableWidthConstraints.maximum &lt; containingBlockWidth)
331             useAsContentLogicalWidth(WidthConstraintsType::Maximum);
332         else
333             distributeExtraHorizontalSpace(containingBlockWidth - tableWidthConstraints.minimum);
334     }
335 }
336 
337 void TableFormattingContext::useAsContentLogicalWidth(WidthConstraintsType type)
338 {
339     auto&amp; columns = formattingState().tableGrid().columnsContext().columns();
340     ASSERT(!columns.isEmpty());
341 
342     for (auto&amp; column : columns)
343         column.setLogicalWidth(type == WidthConstraintsType::Minimum ? column.widthConstraints().minimum : column.widthConstraints().maximum);
344 }
345 
346 }
347 }
348 
349 #endif
    </pre>
  </body>
</html>
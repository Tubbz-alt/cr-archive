<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/loader/cache/MemoryCache.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="KeepaliveRequestTracker.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MemoryCache.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/cache/MemoryCache.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
187 
188     auto key = std::make_pair(url, request.cachePartition());
189     return resources.get(key);
190 }
191 
192 unsigned MemoryCache::deadCapacity() const
193 {
194     // Dead resource capacity is whatever space is not occupied by live resources, bounded by an independent minimum and maximum.
195     unsigned capacity = m_capacity - std::min(m_liveSize, m_capacity); // Start with available capacity.
196     capacity = std::max(capacity, m_minDeadCapacity); // Make sure it&#39;s above the minimum.
197     capacity = std::min(capacity, m_maxDeadCapacity); // Make sure it&#39;s below the maximum.
198     return capacity;
199 }
200 
201 unsigned MemoryCache::liveCapacity() const
202 {
203     // Live resource capacity is whatever is left over after calculating dead resource capacity.
204     return m_capacity - deadCapacity();
205 }
206 
<span class="line-removed">207 static CachedImageClient&amp; dummyCachedImageClient()</span>
<span class="line-removed">208 {</span>
<span class="line-removed">209     static NeverDestroyed&lt;CachedImageClient&gt; client;</span>
<span class="line-removed">210     return client;</span>
<span class="line-removed">211 }</span>
<span class="line-removed">212 </span>
<span class="line-removed">213 bool MemoryCache::addImageToCache(NativeImagePtr&amp;&amp; image, const URL&amp; url, const String&amp; domainForCachePartition, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)</span>
<span class="line-removed">214 {</span>
<span class="line-removed">215     ASSERT(image);</span>
<span class="line-removed">216     removeImageFromCache(url, domainForCachePartition); // Remove cache entry if it already exists.</span>
<span class="line-removed">217 </span>
<span class="line-removed">218     auto bitmapImage = BitmapImage::create(WTFMove(image), nullptr);</span>
<span class="line-removed">219     auto cachedImage = makeUnique&lt;CachedImage&gt;(url, bitmapImage.ptr(), sessionID, cookieJar, domainForCachePartition);</span>
<span class="line-removed">220 </span>
<span class="line-removed">221     cachedImage-&gt;addClient(dummyCachedImageClient());</span>
<span class="line-removed">222     cachedImage-&gt;setDecodedSize(bitmapImage-&gt;decodedSize());</span>
<span class="line-removed">223 </span>
<span class="line-removed">224     return add(*cachedImage.release());</span>
<span class="line-removed">225 }</span>
<span class="line-removed">226 </span>
<span class="line-removed">227 void MemoryCache::removeImageFromCache(const URL&amp; url, const String&amp; domainForCachePartition)</span>
<span class="line-removed">228 {</span>
<span class="line-removed">229     auto* resources = sessionResourceMap(PAL::SessionID::defaultSessionID());</span>
<span class="line-removed">230     if (!resources)</span>
<span class="line-removed">231         return;</span>
<span class="line-removed">232 </span>
<span class="line-removed">233     auto key = std::make_pair(url, ResourceRequest::partitionName(domainForCachePartition));</span>
<span class="line-removed">234 </span>
<span class="line-removed">235     CachedResource* resource = resources-&gt;get(key);</span>
<span class="line-removed">236     if (!resource)</span>
<span class="line-removed">237         return;</span>
<span class="line-removed">238 </span>
<span class="line-removed">239     // A resource exists and is not a manually cached image, so just remove it.</span>
<span class="line-removed">240     if (!is&lt;CachedImage&gt;(*resource) || !downcast&lt;CachedImage&gt;(*resource).isManuallyCached()) {</span>
<span class="line-removed">241         remove(*resource);</span>
<span class="line-removed">242         return;</span>
<span class="line-removed">243     }</span>
<span class="line-removed">244 </span>
<span class="line-removed">245     // Removing the last client of a CachedImage turns the resource</span>
<span class="line-removed">246     // into a dead resource which will eventually be evicted when</span>
<span class="line-removed">247     // dead resources are pruned. That might be immediately since</span>
<span class="line-removed">248     // removing the last client triggers a MemoryCache::prune, so the</span>
<span class="line-removed">249     // resource may be deleted after this call.</span>
<span class="line-removed">250     downcast&lt;CachedImage&gt;(*resource).removeClient(dummyCachedImageClient());</span>
<span class="line-removed">251 }</span>
<span class="line-removed">252 </span>
253 void MemoryCache::pruneLiveResources(bool shouldDestroyDecodedDataForAllLiveResources)
254 {
255     unsigned capacity = shouldDestroyDecodedDataForAllLiveResources ? 0 : liveCapacity();
256     if (capacity &amp;&amp; m_liveSize &lt;= capacity)
257         return;
258 
259     unsigned targetSize = static_cast&lt;unsigned&gt;(capacity * cTargetPrunePercentage); // Cut by a percentage to avoid immediately pruning again.
260 
261     pruneLiveResourcesToSize(targetSize, shouldDestroyDecodedDataForAllLiveResources);
262 }
263 
264 void MemoryCache::forEachResource(const WTF::Function&lt;void(CachedResource&amp;)&gt;&amp; function)
265 {
266     for (auto&amp; unprotectedLRUList : m_allResources) {
267         for (auto&amp; resource : copyToVector(*unprotectedLRUList))
268             function(*resource);
269     }
270 }
271 
272 void MemoryCache::forEachSessionResource(PAL::SessionID sessionID, const WTF::Function&lt;void (CachedResource&amp;)&gt;&amp; function)
</pre>
<hr />
<pre>
425 void MemoryCache::setCapacities(unsigned minDeadBytes, unsigned maxDeadBytes, unsigned totalBytes)
426 {
427     ASSERT(minDeadBytes &lt;= maxDeadBytes);
428     ASSERT(maxDeadBytes &lt;= totalBytes);
429     m_minDeadCapacity = minDeadBytes;
430     m_maxDeadCapacity = maxDeadBytes;
431     m_capacity = totalBytes;
432     prune();
433 }
434 
435 void MemoryCache::remove(CachedResource&amp; resource)
436 {
437     ASSERT(WTF::isMainThread());
438     LOG(ResourceLoading, &quot;Evicting resource %p for &#39;%.255s&#39; from cache&quot;, &amp;resource, resource.url().string().latin1().data());
439     // The resource may have already been removed by someone other than our caller,
440     // who needed a fresh copy for a reload. See &lt;http://bugs.webkit.org/show_bug.cgi?id=12479#c6&gt;.
441     if (auto* resources = sessionResourceMap(resource.sessionID())) {
442         auto key = std::make_pair(resource.url(), resource.cachePartition());
443 
444         if (resource.inCache()) {


445             // Remove resource from the resource map.
446             resources-&gt;remove(key);
447             resource.setInCache(false);
448 
449             // If the resource map is now empty, remove it from m_sessionResources.
450             if (resources-&gt;isEmpty())
451                 m_sessionResources.remove(resource.sessionID());
452 
453             // Remove from the appropriate LRU list.
454             removeFromLRUList(resource);
455             removeFromLiveDecodedResourcesList(resource);
456             adjustSize(resource.hasClients(), -static_cast&lt;long long&gt;(resource.size()));
457         } else {
458             ASSERT(resources-&gt;get(key) != &amp;resource);
459             LOG(ResourceLoading, &quot;  resource %p is not in cache&quot;, &amp;resource);
460         }
461     }
462 
463     resource.deleteIfPossible();
464 }
465 
466 auto MemoryCache::lruListFor(CachedResource&amp; resource) -&gt; LRUList&amp;
467 {
468     unsigned accessCount = std::max(resource.accessCount(), 1U);
469     unsigned queueIndex = WTF::fastLog2(resource.size() / accessCount);
<span class="line-modified">470 #ifndef NDEBUG</span>
471     resource.m_lruIndex = queueIndex;
472 #endif
473 
474     m_allResources.reserveCapacity(queueIndex + 1);
475     while (m_allResources.size() &lt;= queueIndex)
476         m_allResources.uncheckedAppend(makeUnique&lt;LRUList&gt;());
477     return *m_allResources[queueIndex];
478 }
479 
480 void MemoryCache::removeFromLRUList(CachedResource&amp; resource)
481 {
482     // If we&#39;ve never been accessed, then we&#39;re brand new and not in any list.
483     if (!resource.accessCount())
484         return;
485 
<span class="line-modified">486 #if !ASSERT_DISABLED</span>
487     unsigned oldListIndex = resource.m_lruIndex;
488 #endif
489 
490     LRUList&amp; list = lruListFor(resource);
491 
492     // Verify that the list we got is the list we want.
493     ASSERT(resource.m_lruIndex == oldListIndex);
494 
495     bool removed = list.remove(&amp;resource);
496     ASSERT_UNUSED(removed, removed);
497 }
498 
499 void MemoryCache::insertInLRUList(CachedResource&amp; resource)
500 {
501     ASSERT(resource.inCache());
502     ASSERT(resource.accessCount() &gt; 0);
503 
504     auto addResult = lruListFor(resource).add(&amp;resource);
505     ASSERT_UNUSED(addResult, addResult.isNewEntry);
506 }
</pre>
</td>
<td>
<hr />
<pre>
187 
188     auto key = std::make_pair(url, request.cachePartition());
189     return resources.get(key);
190 }
191 
192 unsigned MemoryCache::deadCapacity() const
193 {
194     // Dead resource capacity is whatever space is not occupied by live resources, bounded by an independent minimum and maximum.
195     unsigned capacity = m_capacity - std::min(m_liveSize, m_capacity); // Start with available capacity.
196     capacity = std::max(capacity, m_minDeadCapacity); // Make sure it&#39;s above the minimum.
197     capacity = std::min(capacity, m_maxDeadCapacity); // Make sure it&#39;s below the maximum.
198     return capacity;
199 }
200 
201 unsigned MemoryCache::liveCapacity() const
202 {
203     // Live resource capacity is whatever is left over after calculating dead resource capacity.
204     return m_capacity - deadCapacity();
205 }
206 














































207 void MemoryCache::pruneLiveResources(bool shouldDestroyDecodedDataForAllLiveResources)
208 {
209     unsigned capacity = shouldDestroyDecodedDataForAllLiveResources ? 0 : liveCapacity();
210     if (capacity &amp;&amp; m_liveSize &lt;= capacity)
211         return;
212 
213     unsigned targetSize = static_cast&lt;unsigned&gt;(capacity * cTargetPrunePercentage); // Cut by a percentage to avoid immediately pruning again.
214 
215     pruneLiveResourcesToSize(targetSize, shouldDestroyDecodedDataForAllLiveResources);
216 }
217 
218 void MemoryCache::forEachResource(const WTF::Function&lt;void(CachedResource&amp;)&gt;&amp; function)
219 {
220     for (auto&amp; unprotectedLRUList : m_allResources) {
221         for (auto&amp; resource : copyToVector(*unprotectedLRUList))
222             function(*resource);
223     }
224 }
225 
226 void MemoryCache::forEachSessionResource(PAL::SessionID sessionID, const WTF::Function&lt;void (CachedResource&amp;)&gt;&amp; function)
</pre>
<hr />
<pre>
379 void MemoryCache::setCapacities(unsigned minDeadBytes, unsigned maxDeadBytes, unsigned totalBytes)
380 {
381     ASSERT(minDeadBytes &lt;= maxDeadBytes);
382     ASSERT(maxDeadBytes &lt;= totalBytes);
383     m_minDeadCapacity = minDeadBytes;
384     m_maxDeadCapacity = maxDeadBytes;
385     m_capacity = totalBytes;
386     prune();
387 }
388 
389 void MemoryCache::remove(CachedResource&amp; resource)
390 {
391     ASSERT(WTF::isMainThread());
392     LOG(ResourceLoading, &quot;Evicting resource %p for &#39;%.255s&#39; from cache&quot;, &amp;resource, resource.url().string().latin1().data());
393     // The resource may have already been removed by someone other than our caller,
394     // who needed a fresh copy for a reload. See &lt;http://bugs.webkit.org/show_bug.cgi?id=12479#c6&gt;.
395     if (auto* resources = sessionResourceMap(resource.sessionID())) {
396         auto key = std::make_pair(resource.url(), resource.cachePartition());
397 
398         if (resource.inCache()) {
<span class="line-added">399             ASSERT_WITH_MESSAGE(resource.response().source() != ResourceResponse::Source::InspectorOverride, &quot;InspectorOverride responses should not get into the MemoryCache&quot;);</span>
<span class="line-added">400 </span>
401             // Remove resource from the resource map.
402             resources-&gt;remove(key);
403             resource.setInCache(false);
404 
405             // If the resource map is now empty, remove it from m_sessionResources.
406             if (resources-&gt;isEmpty())
407                 m_sessionResources.remove(resource.sessionID());
408 
409             // Remove from the appropriate LRU list.
410             removeFromLRUList(resource);
411             removeFromLiveDecodedResourcesList(resource);
412             adjustSize(resource.hasClients(), -static_cast&lt;long long&gt;(resource.size()));
413         } else {
414             ASSERT(resources-&gt;get(key) != &amp;resource);
415             LOG(ResourceLoading, &quot;  resource %p is not in cache&quot;, &amp;resource);
416         }
417     }
418 
419     resource.deleteIfPossible();
420 }
421 
422 auto MemoryCache::lruListFor(CachedResource&amp; resource) -&gt; LRUList&amp;
423 {
424     unsigned accessCount = std::max(resource.accessCount(), 1U);
425     unsigned queueIndex = WTF::fastLog2(resource.size() / accessCount);
<span class="line-modified">426 #if ASSERT_ENABLED</span>
427     resource.m_lruIndex = queueIndex;
428 #endif
429 
430     m_allResources.reserveCapacity(queueIndex + 1);
431     while (m_allResources.size() &lt;= queueIndex)
432         m_allResources.uncheckedAppend(makeUnique&lt;LRUList&gt;());
433     return *m_allResources[queueIndex];
434 }
435 
436 void MemoryCache::removeFromLRUList(CachedResource&amp; resource)
437 {
438     // If we&#39;ve never been accessed, then we&#39;re brand new and not in any list.
439     if (!resource.accessCount())
440         return;
441 
<span class="line-modified">442 #if ASSERT_ENABLED</span>
443     unsigned oldListIndex = resource.m_lruIndex;
444 #endif
445 
446     LRUList&amp; list = lruListFor(resource);
447 
448     // Verify that the list we got is the list we want.
449     ASSERT(resource.m_lruIndex == oldListIndex);
450 
451     bool removed = list.remove(&amp;resource);
452     ASSERT_UNUSED(removed, removed);
453 }
454 
455 void MemoryCache::insertInLRUList(CachedResource&amp; resource)
456 {
457     ASSERT(resource.inCache());
458     ASSERT(resource.accessCount() &gt; 0);
459 
460     auto addResult = lruListFor(resource).add(&amp;resource);
461     ASSERT_UNUSED(addResult, addResult.isNewEntry);
462 }
</pre>
</td>
</tr>
</table>
<center><a href="KeepaliveRequestTracker.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MemoryCache.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
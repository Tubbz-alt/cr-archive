<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/RTCDataChannel.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RTCDTMFToneChangeEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RTCDataChannel.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/RTCDataChannel.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  *     documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 16  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 17  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 18  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 19  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 20  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 21  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 23  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RTCDataChannel.h&quot;
 28 
 29 #if ENABLE(WEB_RTC)
 30 
 31 #include &quot;Blob.h&quot;
<span class="line-removed"> 32 #include &quot;Event.h&quot;</span>
 33 #include &quot;EventNames.h&quot;
 34 #include &quot;MessageEvent.h&quot;
<span class="line-removed"> 35 #include &quot;RTCDataChannelHandler.h&quot;</span>
 36 #include &quot;ScriptExecutionContext.h&quot;
 37 #include &quot;SharedBuffer.h&quot;
<span class="line-removed"> 38 #include &lt;JavaScriptCore/ArrayBuffer.h&gt;</span>
 39 #include &lt;JavaScriptCore/ArrayBufferView.h&gt;
 40 #include &lt;wtf/IsoMallocInlines.h&gt;
 41 #include &lt;wtf/NeverDestroyed.h&gt;
 42 
 43 namespace WebCore {
 44 
 45 WTF_MAKE_ISO_ALLOCATED_IMPL(RTCDataChannel);
 46 
 47 static const AtomString&amp; blobKeyword()
 48 {
 49     static NeverDestroyed&lt;AtomString&gt; blob(&quot;blob&quot;, AtomString::ConstructFromLiteral);
 50     return blob;
 51 }
 52 
 53 static const AtomString&amp; arraybufferKeyword()
 54 {
 55     static NeverDestroyed&lt;AtomString&gt; arraybuffer(&quot;arraybuffer&quot;, AtomString::ConstructFromLiteral);
 56     return arraybuffer;
 57 }
 58 
<span class="line-modified"> 59 Ref&lt;RTCDataChannel&gt; RTCDataChannel::create(ScriptExecutionContext&amp; context, std::unique_ptr&lt;RTCDataChannelHandler&gt;&amp;&amp; handler, String&amp;&amp; label, RTCDataChannelInit&amp;&amp; options)</span>
 60 {
 61     ASSERT(handler);
<span class="line-modified"> 62     auto channel = adoptRef(*new RTCDataChannel(context, WTFMove(handler), WTFMove(label), WTFMove(options)));</span>
 63     channel-&gt;suspendIfNeeded();
 64     channel-&gt;m_handler-&gt;setClient(channel.get());
 65     channel-&gt;setPendingActivity(channel.get());
 66     return channel;
 67 }
 68 
<span class="line-modified"> 69 RTCDataChannel::RTCDataChannel(ScriptExecutionContext&amp; context, std::unique_ptr&lt;RTCDataChannelHandler&gt;&amp;&amp; handler, String&amp;&amp; label, RTCDataChannelInit&amp;&amp; options)</span>
<span class="line-modified"> 70     : ActiveDOMObject(&amp;context)</span>















 71     , m_handler(WTFMove(handler))
<span class="line-removed"> 72     , m_scheduledEventTimer(*this, &amp;RTCDataChannel::scheduledEventTimerFired)</span>
 73     , m_label(WTFMove(label))
 74     , m_options(WTFMove(options))

 75 {
 76 }
 77 
 78 size_t RTCDataChannel::bufferedAmount() const
 79 {
 80     // FIXME: We should compute our own bufferedAmount and not count on m_handler which is made null at closing time.
 81     if (m_stopped)
 82         return 0;
 83     return m_handler-&gt;bufferedAmount();
 84 }
 85 
 86 const AtomString&amp; RTCDataChannel::binaryType() const
 87 {
 88     switch (m_binaryType) {
 89     case BinaryType::Blob:
 90         return blobKeyword();
 91     case BinaryType::ArrayBuffer:
 92         return arraybufferKeyword();
 93     }
 94 
</pre>
<hr />
<pre>
 97 }
 98 
 99 ExceptionOr&lt;void&gt; RTCDataChannel::setBinaryType(const AtomString&amp; binaryType)
100 {
101     if (binaryType == blobKeyword()) {
102         m_binaryType = BinaryType::Blob;
103         return { };
104     }
105     if (binaryType == arraybufferKeyword()) {
106         m_binaryType = BinaryType::ArrayBuffer;
107         return { };
108     }
109     return Exception { TypeMismatchError };
110 }
111 
112 ExceptionOr&lt;void&gt; RTCDataChannel::send(const String&amp; data)
113 {
114     if (m_readyState != RTCDataChannelState::Open)
115         return Exception { InvalidStateError };
116 
<span class="line-modified">117     if (!m_handler-&gt;sendStringData(data)) {</span>
<span class="line-removed">118         // FIXME: Decide what the right exception here is.</span>
<span class="line-removed">119         return Exception { SyntaxError };</span>
<span class="line-removed">120     }</span>
<span class="line-removed">121 </span>
122     return { };
123 }
124 
<span class="line-modified">125 ExceptionOr&lt;void&gt; RTCDataChannel::sendRawData(const char* data, size_t length)</span>
126 {
127     if (m_readyState != RTCDataChannelState::Open)
128         return Exception { InvalidStateError };
129 
<span class="line-modified">130     if (!length)</span>
<span class="line-removed">131         return { };</span>
<span class="line-removed">132 </span>
<span class="line-removed">133     if (!m_handler-&gt;sendRawData(data, length)) {</span>
<span class="line-removed">134         // FIXME: Decide what the right exception here is.</span>
<span class="line-removed">135         return Exception { SyntaxError };</span>
<span class="line-removed">136     }</span>
<span class="line-removed">137 </span>
138     return { };
139 }
140 
<span class="line-removed">141 </span>
<span class="line-removed">142 ExceptionOr&lt;void&gt; RTCDataChannel::send(ArrayBuffer&amp; data)</span>
<span class="line-removed">143 {</span>
<span class="line-removed">144     return sendRawData(static_cast&lt;const char*&gt;(data.data()), data.byteLength());</span>
<span class="line-removed">145 }</span>
<span class="line-removed">146 </span>
147 ExceptionOr&lt;void&gt; RTCDataChannel::send(ArrayBufferView&amp; data)
148 {
<span class="line-modified">149     return sendRawData(static_cast&lt;const char*&gt;(data.baseAddress()), data.byteLength());</span>




150 }
151 
<span class="line-modified">152 ExceptionOr&lt;void&gt; RTCDataChannel::send(Blob&amp;)</span>
153 {
<span class="line-modified">154     // FIXME: Implement.</span>
<span class="line-modified">155     return Exception { NotSupportedError };</span>



156 }
157 
158 void RTCDataChannel::close()
159 {
160     if (m_stopped)
161         return;
162 
163     m_stopped = true;
164     m_readyState = RTCDataChannelState::Closed;
165 


166     m_handler-&gt;close();
167     m_handler = nullptr;
168     unsetPendingActivity(*this);
169 }
170 
171 void RTCDataChannel::didChangeReadyState(RTCDataChannelState newState)
172 {
173     if (m_stopped || m_readyState == RTCDataChannelState::Closed || m_readyState == newState)
174         return;
175 
176     m_readyState = newState;
177 
178     switch (m_readyState) {
179     case RTCDataChannelState::Open:
180         scheduleDispatchEvent(Event::create(eventNames().openEvent, Event::CanBubble::No, Event::IsCancelable::No));
181         break;
182     case RTCDataChannelState::Closed:
183         scheduleDispatchEvent(Event::create(eventNames().closeEvent, Event::CanBubble::No, Event::IsCancelable::No));
184         break;
185     default:
186         break;
187     }
188 }
189 
190 void RTCDataChannel::didReceiveStringData(const String&amp; text)
191 {
<span class="line-removed">192     if (m_stopped)</span>
<span class="line-removed">193         return;</span>
<span class="line-removed">194 </span>
195     scheduleDispatchEvent(MessageEvent::create(text));
196 }
197 
198 void RTCDataChannel::didReceiveRawData(const char* data, size_t dataLength)
199 {
<span class="line-removed">200     if (m_stopped)</span>
<span class="line-removed">201         return;</span>
<span class="line-removed">202 </span>
203     switch (m_binaryType) {
204     case BinaryType::Blob:
<span class="line-modified">205         scheduleDispatchEvent(MessageEvent::create(Blob::create(scriptExecutionContext()-&gt;sessionID(), SharedBuffer::create(data, dataLength), emptyString()), { }));</span>
206         return;
207     case BinaryType::ArrayBuffer:
208         scheduleDispatchEvent(MessageEvent::create(ArrayBuffer::create(data, dataLength)));
209         return;
210     }
211     ASSERT_NOT_REACHED();
212 }
213 
214 void RTCDataChannel::didDetectError()
215 {
<span class="line-removed">216     if (m_stopped)</span>
<span class="line-removed">217         return;</span>
<span class="line-removed">218 </span>
219     scheduleDispatchEvent(Event::create(eventNames().errorEvent, Event::CanBubble::No, Event::IsCancelable::No));
220 }
221 
222 void RTCDataChannel::bufferedAmountIsDecreasing(size_t amount)
223 {
<span class="line-removed">224     if (m_stopped)</span>
<span class="line-removed">225         return;</span>
<span class="line-removed">226 </span>
227     if (amount &lt;= m_bufferedAmountLowThreshold)
228         scheduleDispatchEvent(Event::create(eventNames().bufferedamountlowEvent, Event::CanBubble::No, Event::IsCancelable::No));
229 }
230 
231 void RTCDataChannel::stop()
232 {
233     close();
234 }
235 
236 void RTCDataChannel::scheduleDispatchEvent(Ref&lt;Event&gt;&amp;&amp; event)
<span class="line-removed">237 {</span>
<span class="line-removed">238     m_scheduledEvents.append(WTFMove(event));</span>
<span class="line-removed">239 </span>
<span class="line-removed">240     if (!m_scheduledEventTimer.isActive())</span>
<span class="line-removed">241         m_scheduledEventTimer.startOneShot(0_s);</span>
<span class="line-removed">242 }</span>
<span class="line-removed">243 </span>
<span class="line-removed">244 void RTCDataChannel::scheduledEventTimerFired()</span>
245 {
246     if (m_stopped)
247         return;
248 
<span class="line-modified">249     Vector&lt;Ref&lt;Event&gt;&gt; events;</span>
<span class="line-modified">250     events.swap(m_scheduledEvents);</span>
<span class="line-removed">251 </span>
<span class="line-removed">252     for (auto&amp; event : events)</span>
<span class="line-removed">253         dispatchEvent(event);</span>
254 }
255 
256 } // namespace WebCore
257 
258 #endif // ENABLE(WEB_RTC)
</pre>
</td>
<td>
<hr />
<pre>
 12  *     documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 16  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 17  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 18  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 19  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 20  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 21  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 23  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RTCDataChannel.h&quot;
 28 
 29 #if ENABLE(WEB_RTC)
 30 
 31 #include &quot;Blob.h&quot;

 32 #include &quot;EventNames.h&quot;
 33 #include &quot;MessageEvent.h&quot;

 34 #include &quot;ScriptExecutionContext.h&quot;
 35 #include &quot;SharedBuffer.h&quot;

 36 #include &lt;JavaScriptCore/ArrayBufferView.h&gt;
 37 #include &lt;wtf/IsoMallocInlines.h&gt;
 38 #include &lt;wtf/NeverDestroyed.h&gt;
 39 
 40 namespace WebCore {
 41 
 42 WTF_MAKE_ISO_ALLOCATED_IMPL(RTCDataChannel);
 43 
 44 static const AtomString&amp; blobKeyword()
 45 {
 46     static NeverDestroyed&lt;AtomString&gt; blob(&quot;blob&quot;, AtomString::ConstructFromLiteral);
 47     return blob;
 48 }
 49 
 50 static const AtomString&amp; arraybufferKeyword()
 51 {
 52     static NeverDestroyed&lt;AtomString&gt; arraybuffer(&quot;arraybuffer&quot;, AtomString::ConstructFromLiteral);
 53     return arraybuffer;
 54 }
 55 
<span class="line-modified"> 56 Ref&lt;RTCDataChannel&gt; RTCDataChannel::create(Document&amp; document, std::unique_ptr&lt;RTCDataChannelHandler&gt;&amp;&amp; handler, String&amp;&amp; label, RTCDataChannelInit&amp;&amp; options)</span>
 57 {
 58     ASSERT(handler);
<span class="line-modified"> 59     auto channel = adoptRef(*new RTCDataChannel(document, WTFMove(handler), WTFMove(label), WTFMove(options)));</span>
 60     channel-&gt;suspendIfNeeded();
 61     channel-&gt;m_handler-&gt;setClient(channel.get());
 62     channel-&gt;setPendingActivity(channel.get());
 63     return channel;
 64 }
 65 
<span class="line-modified"> 66 NetworkSendQueue RTCDataChannel::createMessageQueue(Document&amp; document, RTCDataChannel&amp; channel)</span>
<span class="line-modified"> 67 {</span>
<span class="line-added"> 68     return { document, [&amp;channel](const String&amp; data) {</span>
<span class="line-added"> 69         if (!channel.m_handler-&gt;sendStringData(data))</span>
<span class="line-added"> 70             channel.scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Error sending string through RTCDataChannel.&quot;_s);</span>
<span class="line-added"> 71     }, [&amp;channel](auto* data, size_t length) {</span>
<span class="line-added"> 72         if (!channel.m_handler-&gt;sendRawData(data, length))</span>
<span class="line-added"> 73             channel.scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Error sending binary data through RTCDataChannel.&quot;_s);</span>
<span class="line-added"> 74     }, [&amp;channel](int errorCode) {</span>
<span class="line-added"> 75         if (auto* context = channel.scriptExecutionContext())</span>
<span class="line-added"> 76             context-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, makeString(&quot;Error &quot;, errorCode, &quot; in retrieving a blob data to be sent through RTCDataChannel.&quot;));</span>
<span class="line-added"> 77         return NetworkSendQueue::Continue::Yes;</span>
<span class="line-added"> 78     } };</span>
<span class="line-added"> 79 }</span>
<span class="line-added"> 80 </span>
<span class="line-added"> 81 RTCDataChannel::RTCDataChannel(Document&amp; document, std::unique_ptr&lt;RTCDataChannelHandler&gt;&amp;&amp; handler, String&amp;&amp; label, RTCDataChannelInit&amp;&amp; options)</span>
<span class="line-added"> 82     : ActiveDOMObject(document)</span>
 83     , m_handler(WTFMove(handler))

 84     , m_label(WTFMove(label))
 85     , m_options(WTFMove(options))
<span class="line-added"> 86     , m_messageQueue(createMessageQueue(document, *this))</span>
 87 {
 88 }
 89 
 90 size_t RTCDataChannel::bufferedAmount() const
 91 {
 92     // FIXME: We should compute our own bufferedAmount and not count on m_handler which is made null at closing time.
 93     if (m_stopped)
 94         return 0;
 95     return m_handler-&gt;bufferedAmount();
 96 }
 97 
 98 const AtomString&amp; RTCDataChannel::binaryType() const
 99 {
100     switch (m_binaryType) {
101     case BinaryType::Blob:
102         return blobKeyword();
103     case BinaryType::ArrayBuffer:
104         return arraybufferKeyword();
105     }
106 
</pre>
<hr />
<pre>
109 }
110 
111 ExceptionOr&lt;void&gt; RTCDataChannel::setBinaryType(const AtomString&amp; binaryType)
112 {
113     if (binaryType == blobKeyword()) {
114         m_binaryType = BinaryType::Blob;
115         return { };
116     }
117     if (binaryType == arraybufferKeyword()) {
118         m_binaryType = BinaryType::ArrayBuffer;
119         return { };
120     }
121     return Exception { TypeMismatchError };
122 }
123 
124 ExceptionOr&lt;void&gt; RTCDataChannel::send(const String&amp; data)
125 {
126     if (m_readyState != RTCDataChannelState::Open)
127         return Exception { InvalidStateError };
128 
<span class="line-modified">129     m_messageQueue.enqueue(data);</span>




130     return { };
131 }
132 
<span class="line-modified">133 ExceptionOr&lt;void&gt; RTCDataChannel::send(ArrayBuffer&amp; data)</span>
134 {
135     if (m_readyState != RTCDataChannelState::Open)
136         return Exception { InvalidStateError };
137 
<span class="line-modified">138     m_messageQueue.enqueue(data, 0, data.byteLength());</span>







139     return { };
140 }
141 






142 ExceptionOr&lt;void&gt; RTCDataChannel::send(ArrayBufferView&amp; data)
143 {
<span class="line-modified">144     if (m_readyState != RTCDataChannelState::Open)</span>
<span class="line-added">145         return Exception { InvalidStateError };</span>
<span class="line-added">146 </span>
<span class="line-added">147     m_messageQueue.enqueue(*data.unsharedBuffer(), data.byteOffset(), data.byteLength());</span>
<span class="line-added">148     return { };</span>
149 }
150 
<span class="line-modified">151 ExceptionOr&lt;void&gt; RTCDataChannel::send(Blob&amp; blob)</span>
152 {
<span class="line-modified">153     if (m_readyState != RTCDataChannelState::Open)</span>
<span class="line-modified">154         return Exception { InvalidStateError };</span>
<span class="line-added">155 </span>
<span class="line-added">156     m_messageQueue.enqueue(blob);</span>
<span class="line-added">157     return { };</span>
158 }
159 
160 void RTCDataChannel::close()
161 {
162     if (m_stopped)
163         return;
164 
165     m_stopped = true;
166     m_readyState = RTCDataChannelState::Closed;
167 
<span class="line-added">168     m_messageQueue.clear();</span>
<span class="line-added">169 </span>
170     m_handler-&gt;close();
171     m_handler = nullptr;
172     unsetPendingActivity(*this);
173 }
174 
175 void RTCDataChannel::didChangeReadyState(RTCDataChannelState newState)
176 {
177     if (m_stopped || m_readyState == RTCDataChannelState::Closed || m_readyState == newState)
178         return;
179 
180     m_readyState = newState;
181 
182     switch (m_readyState) {
183     case RTCDataChannelState::Open:
184         scheduleDispatchEvent(Event::create(eventNames().openEvent, Event::CanBubble::No, Event::IsCancelable::No));
185         break;
186     case RTCDataChannelState::Closed:
187         scheduleDispatchEvent(Event::create(eventNames().closeEvent, Event::CanBubble::No, Event::IsCancelable::No));
188         break;
189     default:
190         break;
191     }
192 }
193 
194 void RTCDataChannel::didReceiveStringData(const String&amp; text)
195 {



196     scheduleDispatchEvent(MessageEvent::create(text));
197 }
198 
199 void RTCDataChannel::didReceiveRawData(const char* data, size_t dataLength)
200 {



201     switch (m_binaryType) {
202     case BinaryType::Blob:
<span class="line-modified">203         scheduleDispatchEvent(MessageEvent::create(Blob::create(SharedBuffer::create(data, dataLength), emptyString()), { }));</span>
204         return;
205     case BinaryType::ArrayBuffer:
206         scheduleDispatchEvent(MessageEvent::create(ArrayBuffer::create(data, dataLength)));
207         return;
208     }
209     ASSERT_NOT_REACHED();
210 }
211 
212 void RTCDataChannel::didDetectError()
213 {



214     scheduleDispatchEvent(Event::create(eventNames().errorEvent, Event::CanBubble::No, Event::IsCancelable::No));
215 }
216 
217 void RTCDataChannel::bufferedAmountIsDecreasing(size_t amount)
218 {



219     if (amount &lt;= m_bufferedAmountLowThreshold)
220         scheduleDispatchEvent(Event::create(eventNames().bufferedamountlowEvent, Event::CanBubble::No, Event::IsCancelable::No));
221 }
222 
223 void RTCDataChannel::stop()
224 {
225     close();
226 }
227 
228 void RTCDataChannel::scheduleDispatchEvent(Ref&lt;Event&gt;&amp;&amp; event)








229 {
230     if (m_stopped)
231         return;
232 
<span class="line-modified">233     // https://w3c.github.io/webrtc-pc/#operation</span>
<span class="line-modified">234     queueTaskToDispatchEvent(*this, TaskSource::Networking, WTFMove(event));</span>



235 }
236 
237 } // namespace WebCore
238 
239 #endif // ENABLE(WEB_RTC)
</pre>
</td>
</tr>
</table>
<center><a href="RTCDTMFToneChangeEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RTCDataChannel.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
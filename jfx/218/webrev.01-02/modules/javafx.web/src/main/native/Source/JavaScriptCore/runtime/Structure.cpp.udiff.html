<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Structure.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StringRecursionChecker.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Structure.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Structure.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -85,26 +85,26 @@</span>
          WeakSet::deallocate(impl);
      WeakImpl* impl = WeakSet::allocate(structure, &amp;singleSlotTransitionWeakOwner(), this);
      m_data = bitwise_cast&lt;intptr_t&gt;(impl) | UsingSingleSlotFlag;
  }
  
<span class="udiff-line-modified-removed">- bool StructureTransitionTable::contains(UniquedStringImpl* rep, unsigned attributes) const</span>
<span class="udiff-line-modified-added">+ bool StructureTransitionTable::contains(UniquedStringImpl* rep, unsigned attributes, bool isAddition) const</span>
  {
      if (isUsingSingleSlot()) {
          Structure* transition = singleTransition();
<span class="udiff-line-modified-removed">-         return transition &amp;&amp; transition-&gt;m_nameInPrevious == rep &amp;&amp; transition-&gt;attributesInPrevious() == attributes;</span>
<span class="udiff-line-modified-added">+         return transition &amp;&amp; transition-&gt;m_transitionPropertyName == rep &amp;&amp; transition-&gt;transitionPropertyAttributes() == attributes &amp;&amp; transition-&gt;isPropertyDeletionTransition() == !isAddition;</span>
      }
<span class="udiff-line-modified-removed">-     return map()-&gt;get(std::make_pair(rep, attributes));</span>
<span class="udiff-line-modified-added">+     return map()-&gt;get(StructureTransitionTable::Hash::Key(rep, attributes, isAddition));</span>
  }
  
<span class="udiff-line-modified-removed">- inline Structure* StructureTransitionTable::get(UniquedStringImpl* rep, unsigned attributes) const</span>
<span class="udiff-line-modified-added">+ inline Structure* StructureTransitionTable::get(UniquedStringImpl* rep, unsigned attributes, bool isAddition) const</span>
  {
      if (isUsingSingleSlot()) {
          Structure* transition = singleTransition();
<span class="udiff-line-modified-removed">-         return (transition &amp;&amp; transition-&gt;m_nameInPrevious == rep &amp;&amp; transition-&gt;attributesInPrevious() == attributes) ? transition : 0;</span>
<span class="udiff-line-modified-added">+         return (transition &amp;&amp; transition-&gt;m_transitionPropertyName == rep &amp;&amp; transition-&gt;transitionPropertyAttributes() == attributes &amp;&amp; transition-&gt;isPropertyDeletionTransition() == !isAddition) ? transition : 0;</span>
      }
<span class="udiff-line-modified-removed">-     return map()-&gt;get(std::make_pair(rep, attributes));</span>
<span class="udiff-line-modified-added">+     return map()-&gt;get(StructureTransitionTable::Hash::Key(rep, attributes, isAddition));</span>
  }
  
  void StructureTransitionTable::add(VM&amp; vm, Structure* structure)
  {
      if (isUsingSingleSlot()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -121,15 +121,11 @@</span>
          setMap(new TransitionMap(vm));
          add(vm, existingTransition);
      }
  
      // Add the structure to the map.
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-     // Newer versions of the STL have an std::make_pair function that takes rvalue references.</span>
<span class="udiff-line-removed">-     // When either of the parameters are bitfields, the C++ compiler will try to bind them as lvalues, which is invalid. To work around this, use unary &quot;+&quot; to make the parameter an rvalue.</span>
<span class="udiff-line-removed">-     // See https://bugs.webkit.org/show_bug.cgi?id=59261 for more details</span>
<span class="udiff-line-removed">-     map()-&gt;set(std::make_pair(structure-&gt;m_nameInPrevious.get(), +structure-&gt;attributesInPrevious()), structure);</span>
<span class="udiff-line-modified-added">+     map()-&gt;set(StructureTransitionTable::Hash::Key(structure-&gt;m_transitionPropertyName.get(), structure-&gt;transitionPropertyAttributes(), !structure-&gt;isPropertyDeletionTransition()), structure);</span>
  }
  
  void Structure::dumpStatistics()
  {
  #if DUMP_STRUCTURE_ID_STATISTICS
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -183,27 +179,29 @@</span>
      , m_bitField(0)
      , m_globalObject(vm, this, globalObject, WriteBarrier&lt;JSGlobalObject&gt;::MayBeNull)
      , m_prototype(vm, this, prototype)
      , m_classInfo(classInfo)
      , m_transitionWatchpointSet(IsWatched)
<span class="udiff-line-removed">-     , m_offset(invalidOffset)</span>
      , m_propertyHash(0)
  {
      setDictionaryKind(NoneDictionaryKind);
      setIsPinnedPropertyTable(false);
      setHasGetterSetterProperties(classInfo-&gt;hasStaticSetterOrReadonlyProperties());
      setHasCustomGetterSetterProperties(false);
      setHasReadOnlyOrGetterSetterPropertiesExcludingProto(classInfo-&gt;hasStaticSetterOrReadonlyProperties());
      setHasUnderscoreProtoPropertyExcludingOriginalProto(false);
      setIsQuickPropertyAccessAllowedForEnumeration(true);
<span class="udiff-line-modified-removed">-     setAttributesInPrevious(0);</span>
<span class="udiff-line-modified-added">+     setTransitionPropertyAttributes(0);</span>
      setDidPreventExtensions(false);
      setDidTransition(false);
      setStaticPropertiesReified(false);
      setTransitionWatchpointIsLikelyToBeFired(false);
      setHasBeenDictionary(false);
<span class="udiff-line-modified-removed">-     setIsAddingPropertyForTransition(false);</span>
<span class="udiff-line-modified-added">+     setProtectPropertyTableWhileTransitioning(false);</span>
<span class="udiff-line-added">+     setIsPropertyDeletionTransition(false);</span>
<span class="udiff-line-added">+     setTransitionOffset(vm, invalidOffset);</span>
<span class="udiff-line-added">+     setMaxOffset(vm, invalidOffset);</span>
  
      ASSERT(inlineCapacity &lt;= JSFinalObject::maxInlineCapacity());
      ASSERT(static_cast&lt;PropertyOffset&gt;(inlineCapacity) &lt; firstOutOfLineOffset);
      ASSERT(!hasRareData());
      ASSERT(hasReadOnlyOrGetterSetterPropertiesExcludingProto() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -218,27 +216,29 @@</span>
      , m_inlineCapacity(0)
      , m_bitField(0)
      , m_prototype(vm, this, jsNull())
      , m_classInfo(info())
      , m_transitionWatchpointSet(IsWatched)
<span class="udiff-line-removed">-     , m_offset(invalidOffset)</span>
      , m_propertyHash(0)
  {
      setDictionaryKind(NoneDictionaryKind);
      setIsPinnedPropertyTable(false);
      setHasGetterSetterProperties(m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
      setHasCustomGetterSetterProperties(false);
      setHasReadOnlyOrGetterSetterPropertiesExcludingProto(m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
      setHasUnderscoreProtoPropertyExcludingOriginalProto(false);
      setIsQuickPropertyAccessAllowedForEnumeration(true);
<span class="udiff-line-modified-removed">-     setAttributesInPrevious(0);</span>
<span class="udiff-line-modified-added">+     setTransitionPropertyAttributes(0);</span>
      setDidPreventExtensions(false);
      setDidTransition(false);
      setStaticPropertiesReified(false);
      setTransitionWatchpointIsLikelyToBeFired(false);
      setHasBeenDictionary(false);
<span class="udiff-line-modified-removed">-     setIsAddingPropertyForTransition(false);</span>
<span class="udiff-line-modified-added">+     setProtectPropertyTableWhileTransitioning(false);</span>
<span class="udiff-line-added">+     setIsPropertyDeletionTransition(false);</span>
<span class="udiff-line-added">+     setTransitionOffset(vm, invalidOffset);</span>
<span class="udiff-line-added">+     setMaxOffset(vm, invalidOffset);</span>
  
      TypeInfo typeInfo = TypeInfo(CellType, StructureFlags);
      m_blob = StructureIDBlob(vm.heap.structureIDTable().allocateID(this), 0, typeInfo);
      m_outOfLineTypeFlags = typeInfo.outOfLineTypeFlags();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -252,27 +252,30 @@</span>
      , m_inlineCapacity(previous-&gt;m_inlineCapacity)
      , m_bitField(0)
      , m_prototype(vm, this, previous-&gt;m_prototype.get())
      , m_classInfo(previous-&gt;m_classInfo)
      , m_transitionWatchpointSet(IsWatched)
<span class="udiff-line-removed">-     , m_offset(invalidOffset)</span>
      , m_propertyHash(previous-&gt;m_propertyHash)
<span class="udiff-line-added">+     , m_seenProperties(previous-&gt;m_seenProperties)</span>
  {
      setDictionaryKind(previous-&gt;dictionaryKind());
      setIsPinnedPropertyTable(false);
      setHasBeenFlattenedBefore(previous-&gt;hasBeenFlattenedBefore());
      setHasGetterSetterProperties(previous-&gt;hasGetterSetterProperties());
      setHasCustomGetterSetterProperties(previous-&gt;hasCustomGetterSetterProperties());
      setHasReadOnlyOrGetterSetterPropertiesExcludingProto(previous-&gt;hasReadOnlyOrGetterSetterPropertiesExcludingProto());
      setHasUnderscoreProtoPropertyExcludingOriginalProto(previous-&gt;hasUnderscoreProtoPropertyExcludingOriginalProto());
      setIsQuickPropertyAccessAllowedForEnumeration(previous-&gt;isQuickPropertyAccessAllowedForEnumeration());
<span class="udiff-line-modified-removed">-     setAttributesInPrevious(0);</span>
<span class="udiff-line-modified-added">+     setTransitionPropertyAttributes(0);</span>
      setDidPreventExtensions(previous-&gt;didPreventExtensions());
      setDidTransition(true);
      setStaticPropertiesReified(previous-&gt;staticPropertiesReified());
      setHasBeenDictionary(previous-&gt;hasBeenDictionary());
<span class="udiff-line-modified-removed">-     setIsAddingPropertyForTransition(false);</span>
<span class="udiff-line-modified-added">+     setProtectPropertyTableWhileTransitioning(false);</span>
<span class="udiff-line-added">+     setIsPropertyDeletionTransition(false);</span>
<span class="udiff-line-added">+     setTransitionOffset(vm, invalidOffset);</span>
<span class="udiff-line-added">+     setMaxOffset(vm, invalidOffset);</span>
  
      TypeInfo typeInfo = previous-&gt;typeInfo();
      m_blob = StructureIDBlob(vm.heap.structureIDTable().allocateID(this), previous-&gt;indexingModeIncludingHistory(), typeInfo);
      m_outOfLineTypeFlags = typeInfo.outOfLineTypeFlags();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -308,16 +311,16 @@</span>
      Structure* result = create(vm, globalObject, prototype, typeInfo, classInfo, indexingType, inlineCapacity);
  
      unsigned oldOutOfLineCapacity = result-&gt;outOfLineCapacity();
      result-&gt;addPropertyWithoutTransition(
          vm, vm.propertyNames-&gt;builtinNames().polyProtoName(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum),
<span class="udiff-line-modified-removed">-         [&amp;] (const GCSafeConcurrentJSLocker&amp;, PropertyOffset offset, PropertyOffset newLastOffset) {</span>
<span class="udiff-line-modified-removed">-             RELEASE_ASSERT(Structure::outOfLineCapacity(newLastOffset) == oldOutOfLineCapacity);</span>
<span class="udiff-line-modified-added">+         [&amp;] (const GCSafeConcurrentJSLocker&amp;, PropertyOffset offset, PropertyOffset newMaxOffset) {</span>
<span class="udiff-line-modified-added">+             RELEASE_ASSERT(Structure::outOfLineCapacity(newMaxOffset) == oldOutOfLineCapacity);</span>
              RELEASE_ASSERT(offset == knownPolyProtoOffset);
              RELEASE_ASSERT(isInlineOffset(knownPolyProtoOffset));
              result-&gt;m_prototype.setWithoutWriteBarrier(JSValue());
<span class="udiff-line-modified-removed">-             result-&gt;setLastOffset(newLastOffset);</span>
<span class="udiff-line-modified-added">+             result-&gt;setMaxOffset(vm, newMaxOffset);</span>
          });
  
      return result;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -350,21 +353,21 @@</span>
  }
  
  PropertyTable* Structure::materializePropertyTable(VM&amp; vm, bool setPropertyTable)
  {
      ASSERT(structure(vm)-&gt;classInfo() == info());
<span class="udiff-line-modified-removed">-     ASSERT(!isAddingPropertyForTransition());</span>
<span class="udiff-line-modified-added">+     ASSERT(!protectPropertyTableWhileTransitioning());</span>
  
      DeferGC deferGC(vm.heap);
  
      Vector&lt;Structure*, 8&gt; structures;
      Structure* structure;
      PropertyTable* table;
  
      findStructuresAndMapForMaterialization(structures, structure, table);
  
<span class="udiff-line-modified-removed">-     unsigned capacity = numberOfSlotsForLastOffset(m_offset, m_inlineCapacity);</span>
<span class="udiff-line-modified-added">+     unsigned capacity = numberOfSlotsForMaxOffset(maxOffset(), m_inlineCapacity);</span>
      if (table) {
          table = table-&gt;copy(vm, capacity);
          structure-&gt;m_lock.unlock();
      } else
          table = PropertyTable::create(vm, capacity);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -376,14 +379,25 @@</span>
      if (setPropertyTable)
          this-&gt;setPropertyTable(vm, table);
  
      for (size_t i = structures.size(); i--;) {
          structure = structures[i];
<span class="udiff-line-modified-removed">-         if (!structure-&gt;m_nameInPrevious)</span>
<span class="udiff-line-modified-added">+         if (!structure-&gt;m_transitionPropertyName)</span>
<span class="udiff-line-added">+             continue;</span>
<span class="udiff-line-added">+         if (structure-&gt;isPropertyDeletionTransition()) {</span>
<span class="udiff-line-added">+             auto item = table-&gt;find(structure-&gt;m_transitionPropertyName.get());</span>
<span class="udiff-line-added">+             ASSERT(item.first);</span>
<span class="udiff-line-added">+             table-&gt;remove(item);</span>
<span class="udiff-line-added">+             table-&gt;addDeletedOffset(structure-&gt;transitionOffset());</span>
              continue;
<span class="udiff-line-modified-removed">-         PropertyMapEntry entry(structure-&gt;m_nameInPrevious.get(), structure-&gt;m_offset, structure-&gt;attributesInPrevious());</span>
<span class="udiff-line-modified-removed">-         table-&gt;add(entry, m_offset, PropertyTable::PropertyOffsetMustNotChange);</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+         PropertyMapEntry entry(structure-&gt;m_transitionPropertyName.get(), structure-&gt;transitionOffset(), structure-&gt;transitionPropertyAttributes());</span>
<span class="udiff-line-added">+         auto nextOffset = table-&gt;nextOffset(structure-&gt;inlineCapacity());</span>
<span class="udiff-line-added">+         ASSERT_UNUSED(nextOffset, nextOffset == structure-&gt;transitionOffset());</span>
<span class="udiff-line-added">+         auto result = table-&gt;add(entry);</span>
<span class="udiff-line-added">+         ASSERT_UNUSED(result, result.second);</span>
<span class="udiff-line-added">+         ASSERT_UNUSED(result, result.first.first-&gt;offset == nextOffset);</span>
      }
  
      checkOffsetConsistency(
          table,
          [&amp;] () {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -402,13 +416,14 @@</span>
  Structure* Structure::addPropertyTransitionToExistingStructureImpl(Structure* structure, UniquedStringImpl* uid, unsigned attributes, PropertyOffset&amp; offset)
  {
      ASSERT(!structure-&gt;isDictionary());
      ASSERT(structure-&gt;isObject());
  
<span class="udiff-line-modified-removed">-     if (Structure* existingTransition = structure-&gt;m_transitionTable.get(uid, attributes)) {</span>
<span class="udiff-line-modified-removed">-         validateOffset(existingTransition-&gt;m_offset, existingTransition-&gt;inlineCapacity());</span>
<span class="udiff-line-modified-removed">-         offset = existingTransition-&gt;m_offset;</span>
<span class="udiff-line-modified-added">+     constexpr bool isAddition = true;</span>
<span class="udiff-line-modified-added">+     if (Structure* existingTransition = structure-&gt;m_transitionTable.get(uid, attributes, isAddition)) {</span>
<span class="udiff-line-modified-added">+         validateOffset(existingTransition-&gt;transitionOffset(), existingTransition-&gt;inlineCapacity());</span>
<span class="udiff-line-added">+         offset = existingTransition-&gt;transitionOffset();</span>
          return existingTransition;
      }
  
      return 0;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -471,11 +486,11 @@</span>
      int maxTransitionLength;
      if (context == PutPropertySlot::PutById)
          maxTransitionLength = s_maxTransitionLengthForNonEvalPutById;
      else
          maxTransitionLength = s_maxTransitionLength;
<span class="udiff-line-modified-removed">-     if (structure-&gt;transitionCount() &gt; maxTransitionLength) {</span>
<span class="udiff-line-modified-added">+     if (structure-&gt;transitionCountEstimate() &gt; maxTransitionLength) {</span>
          ASSERT(!isCopyOnWrite(structure-&gt;indexingMode()));
          Structure* transition = toCacheableDictionaryTransition(vm, structure, deferred);
          ASSERT(structure != transition);
          offset = transition-&gt;add(vm, propertyName, attributes);
          return transition;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -484,68 +499,126 @@</span>
      Structure* transition = create(vm, structure, deferred);
  
      transition-&gt;m_cachedPrototypeChain.setMayBeNull(vm, transition, structure-&gt;m_cachedPrototypeChain.get());
  
      // While we are adding the property, rematerializing the property table is super weird: we already
<span class="udiff-line-modified-removed">-     // have a m_nameInPrevious and attributesInPrevious but the m_offset is still wrong. If the</span>
<span class="udiff-line-modified-added">+     // have a m_transitionPropertyName and transitionPropertyAttributes but the m_transitionOffset is still wrong. If the</span>
      // materialization algorithm runs, it&#39;ll build a property table that already has the property but
      // at a bogus offset. Rather than try to teach the materialization code how to create a table under
      // those conditions, we just tell the GC not to blow the table away during this period of time.
      // Holding the lock ensures that we either do this before the GC starts scanning the structure, in
      // which case the GC will not blow the table away, or we do it after the GC already ran in which
      // case all is well.  If it wasn&#39;t for the lock, the GC would have TOCTOU: if could read
<span class="udiff-line-modified-removed">-     // isAddingPropertyForTransition before we set it to true, and then blow the table away after.</span>
<span class="udiff-line-modified-added">+     // protectPropertyTableWhileTransitioning before we set it to true, and then blow the table away after.</span>
      {
          ConcurrentJSLocker locker(transition-&gt;m_lock);
<span class="udiff-line-modified-removed">-         transition-&gt;setIsAddingPropertyForTransition(true);</span>
<span class="udiff-line-modified-added">+         transition-&gt;setProtectPropertyTableWhileTransitioning(true);</span>
      }
  
      transition-&gt;m_blob.setIndexingModeIncludingHistory(structure-&gt;indexingModeIncludingHistory() &amp; ~CopyOnWrite);
<span class="udiff-line-modified-removed">-     transition-&gt;m_nameInPrevious = propertyName.uid();</span>
<span class="udiff-line-modified-removed">-     transition-&gt;setAttributesInPrevious(attributes);</span>
<span class="udiff-line-modified-added">+     transition-&gt;m_transitionPropertyName = propertyName.uid();</span>
<span class="udiff-line-modified-added">+     transition-&gt;setTransitionPropertyAttributes(attributes);</span>
      transition-&gt;setPropertyTable(vm, structure-&gt;takePropertyTableOrCloneIfPinned(vm));
<span class="udiff-line-modified-removed">-     transition-&gt;m_offset = structure-&gt;m_offset;</span>
<span class="udiff-line-modified-added">+     transition-&gt;setMaxOffset(vm, structure-&gt;maxOffset());</span>
  
      offset = transition-&gt;add(vm, propertyName, attributes);
<span class="udiff-line-added">+     transition-&gt;setTransitionOffset(vm, offset);</span>
  
      // Now that everything is fine with the new structure&#39;s bookkeeping, the GC is free to blow the
      // table away if it wants. We can now rebuild it fine.
      WTF::storeStoreFence();
<span class="udiff-line-modified-removed">-     transition-&gt;setIsAddingPropertyForTransition(false);</span>
<span class="udiff-line-modified-added">+     transition-&gt;setProtectPropertyTableWhileTransitioning(false);</span>
  
<span class="udiff-line-modified-removed">-     checkOffset(transition-&gt;m_offset, transition-&gt;inlineCapacity());</span>
<span class="udiff-line-modified-added">+     checkOffset(transition-&gt;transitionOffset(), transition-&gt;inlineCapacity());</span>
      {
<span class="udiff-line-modified-removed">-         ConcurrentJSLocker locker(structure-&gt;m_lock);</span>
<span class="udiff-line-removed">-         DeferGC deferGC(vm.heap);</span>
<span class="udiff-line-modified-added">+         GCSafeConcurrentJSLocker locker(structure-&gt;m_lock, vm.heap);</span>
          structure-&gt;m_transitionTable.add(vm, transition);
      }
      transition-&gt;checkOffsetConsistency();
      structure-&gt;checkOffsetConsistency();
      return transition;
  }
  
<span class="udiff-line-modified-removed">- Structure* Structure::removePropertyTransition(VM&amp; vm, Structure* structure, PropertyName propertyName, PropertyOffset&amp; offset)</span>
<span class="udiff-line-modified-removed">- {</span>
<span class="udiff-line-modified-removed">-     // NOTE: There are some good reasons why this goes directly to uncacheable dictionary rather than</span>
<span class="udiff-line-modified-removed">-     // caching the removal. We can fix all of these things, but we must remember to do so, if we ever try</span>
<span class="udiff-line-modified-removed">-     // to optimize this case.</span>
<span class="udiff-line-modified-removed">-     //</span>
<span class="udiff-line-modified-removed">-     // - Cached transitions usually steal the property table, and assume that this is possible because they</span>
<span class="udiff-line-modified-removed">-     //   can just rebuild the table by looking at past transitions. That code assumes that the table only</span>
<span class="udiff-line-modified-removed">-     //   grew and never shrank. To support removals, we&#39;d have to change the property table materialization</span>
<span class="udiff-line-modified-removed">-     //   code to handle deletions. Also, we have logic to get the list of properties on a structure that</span>
<span class="udiff-line-modified-removed">-     //   lacks a property table by just looking back through the set of transitions since the last</span>
<span class="udiff-line-modified-removed">-     //   structure that had a pinned table. That logic would also have to be changed to handle cached</span>
<span class="udiff-line-modified-removed">-     //   removals.</span>
<span class="udiff-line-modified-removed">-     //</span>
<span class="udiff-line-modified-added">+ Structure* Structure::removePropertyTransition(VM&amp; vm, Structure* structure, PropertyName propertyName, PropertyOffset&amp; offset, DeferredStructureTransitionWatchpointFire* deferred)</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-modified-added">+     Structure* newStructure = removePropertyTransitionFromExistingStructure(</span>
<span class="udiff-line-modified-added">+         vm, structure, propertyName, offset, deferred);</span>
<span class="udiff-line-modified-added">+     if (newStructure)</span>
<span class="udiff-line-modified-added">+         return newStructure;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     return removeNewPropertyTransition(</span>
<span class="udiff-line-modified-added">+         vm, structure, propertyName, offset, deferred);</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ Structure* Structure::removePropertyTransitionFromExistingStructure(VM&amp; vm, Structure* structure, PropertyName propertyName, PropertyOffset&amp; offset, DeferredStructureTransitionWatchpointFire*)</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-modified-added">+     ASSERT(!isCompilationThread());</span>
      ASSERT(!structure-&gt;isUncacheableDictionary());
<span class="udiff-line-added">+     ASSERT(structure-&gt;isObject());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     unsigned attributes;</span>
<span class="udiff-line-added">+     structure-&gt;get(vm, propertyName, attributes);</span>
  
<span class="udiff-line-modified-removed">-     Structure* transition = toUncacheableDictionaryTransition(vm, structure);</span>
<span class="udiff-line-modified-added">+     constexpr bool isAddition = false;</span>
<span class="udiff-line-added">+     if (Structure* existingTransition = structure-&gt;m_transitionTable.get(propertyName.uid(), attributes, isAddition)) {</span>
<span class="udiff-line-added">+         validateOffset(existingTransition-&gt;transitionOffset(), existingTransition-&gt;inlineCapacity());</span>
<span class="udiff-line-added">+         offset = existingTransition-&gt;transitionOffset();</span>
<span class="udiff-line-added">+         return existingTransition;</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-     offset = transition-&gt;remove(propertyName);</span>
<span class="udiff-line-modified-added">+     return nullptr;</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-added">+ Structure* Structure::removeNewPropertyTransition(VM&amp; vm, Structure* structure, PropertyName propertyName, PropertyOffset&amp; offset, DeferredStructureTransitionWatchpointFire* deferred)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     ASSERT(!structure-&gt;isUncacheableDictionary());</span>
<span class="udiff-line-added">+     ASSERT(structure-&gt;isObject());</span>
<span class="udiff-line-added">+     ASSERT(!Structure::removePropertyTransitionFromExistingStructure(vm, structure, propertyName, offset, deferred));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     int transitionCount = 0;</span>
<span class="udiff-line-added">+     for (auto* s = structure; s &amp;&amp; transitionCount &lt;= s_maxTransitionLength; s = s-&gt;previousID())</span>
<span class="udiff-line-added">+         ++transitionCount;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (transitionCount &gt; s_maxTransitionLength) {</span>
<span class="udiff-line-added">+         ASSERT(!isCopyOnWrite(structure-&gt;indexingMode()));</span>
<span class="udiff-line-added">+         Structure* transition = toUncacheableDictionaryTransition(vm, structure, deferred);</span>
<span class="udiff-line-added">+         ASSERT(structure != transition);</span>
<span class="udiff-line-added">+         offset = transition-&gt;remove(vm, propertyName);</span>
<span class="udiff-line-added">+         return transition;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Structure* transition = create(vm, structure, deferred);</span>
<span class="udiff-line-added">+     transition-&gt;m_cachedPrototypeChain.setMayBeNull(vm, transition, structure-&gt;m_cachedPrototypeChain.get());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // While we are deleting the property, we need to make sure the table is not cleared.</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         ConcurrentJSLocker locker(transition-&gt;m_lock);</span>
<span class="udiff-line-added">+         transition-&gt;setProtectPropertyTableWhileTransitioning(true);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     transition-&gt;m_blob.setIndexingModeIncludingHistory(structure-&gt;indexingModeIncludingHistory() &amp; ~CopyOnWrite);</span>
<span class="udiff-line-added">+     transition-&gt;m_transitionPropertyName = propertyName.uid();</span>
<span class="udiff-line-added">+     transition-&gt;setPropertyTable(vm, structure-&gt;takePropertyTableOrCloneIfPinned(vm));</span>
<span class="udiff-line-added">+     transition-&gt;setMaxOffset(vm, structure-&gt;maxOffset());</span>
<span class="udiff-line-added">+     transition-&gt;setIsPropertyDeletionTransition(true);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     offset = transition-&gt;remove(vm, propertyName);</span>
<span class="udiff-line-added">+     ASSERT(offset != invalidOffset);</span>
<span class="udiff-line-added">+     transition-&gt;setTransitionOffset(vm, offset);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Now that everything is fine with the new structure&#39;s bookkeeping, the GC is free to blow the</span>
<span class="udiff-line-added">+     // table away if it wants. We can now rebuild it fine.</span>
<span class="udiff-line-added">+     WTF::storeStoreFence();</span>
<span class="udiff-line-added">+     transition-&gt;setProtectPropertyTableWhileTransitioning(false);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     checkOffset(transition-&gt;transitionOffset(), transition-&gt;inlineCapacity());</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         GCSafeConcurrentJSLocker locker(structure-&gt;m_lock, vm.heap);</span>
<span class="udiff-line-added">+         structure-&gt;m_transitionTable.add(vm, transition);</span>
<span class="udiff-line-added">+     }</span>
      transition-&gt;checkOffsetConsistency();
<span class="udiff-line-added">+     structure-&gt;checkOffsetConsistency();</span>
      return transition;
  }
  
  Structure* Structure::changePrototypeTransition(VM&amp; vm, Structure* structure, JSValue prototype, DeferredStructureTransitionWatchpointFire&amp; deferred)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -556,11 +629,11 @@</span>
  
      transition-&gt;m_prototype.set(vm, transition, prototype);
  
      PropertyTable* table = structure-&gt;copyPropertyTableForPinning(vm);
      transition-&gt;pin(holdLock(transition-&gt;m_lock), vm, table);
<span class="udiff-line-modified-removed">-     transition-&gt;m_offset = structure-&gt;m_offset;</span>
<span class="udiff-line-modified-added">+     transition-&gt;setMaxOffset(vm, structure-&gt;maxOffset());</span>
  
      transition-&gt;checkOffsetConsistency();
      return transition;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -569,11 +642,11 @@</span>
      if (!structure-&gt;isUncacheableDictionary()) {
          Structure* transition = create(vm, structure);
  
          PropertyTable* table = structure-&gt;copyPropertyTableForPinning(vm);
          transition-&gt;pin(holdLock(transition-&gt;m_lock), vm, table);
<span class="udiff-line-modified-removed">-         transition-&gt;m_offset = structure-&gt;m_offset;</span>
<span class="udiff-line-modified-added">+         transition-&gt;setMaxOffset(vm, structure-&gt;maxOffset());</span>
  
          structure = transition;
      }
  
      PropertyMapEntry* entry = structure-&gt;ensurePropertyTable(vm)-&gt;get(propertyName.uid());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -591,11 +664,11 @@</span>
  
      Structure* transition = create(vm, structure, deferred);
  
      PropertyTable* table = structure-&gt;copyPropertyTableForPinning(vm);
      transition-&gt;pin(holdLock(transition-&gt;m_lock), vm, table);
<span class="udiff-line-modified-removed">-     transition-&gt;m_offset = structure-&gt;m_offset;</span>
<span class="udiff-line-modified-added">+     transition-&gt;setMaxOffset(vm, structure-&gt;maxOffset());</span>
      transition-&gt;setDictionaryKind(kind);
      transition-&gt;setHasBeenDictionary(true);
  
      transition-&gt;checkOffsetConsistency();
      return transition;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -604,13 +677,13 @@</span>
  Structure* Structure::toCacheableDictionaryTransition(VM&amp; vm, Structure* structure, DeferredStructureTransitionWatchpointFire* deferred)
  {
      return toDictionaryTransition(vm, structure, CachedDictionaryKind, deferred);
  }
  
<span class="udiff-line-modified-removed">- Structure* Structure::toUncacheableDictionaryTransition(VM&amp; vm, Structure* structure)</span>
<span class="udiff-line-modified-added">+ Structure* Structure::toUncacheableDictionaryTransition(VM&amp; vm, Structure* structure, DeferredStructureTransitionWatchpointFire* deferred)</span>
  {
<span class="udiff-line-modified-removed">-     return toDictionaryTransition(vm, structure, UncachedDictionaryKind);</span>
<span class="udiff-line-modified-added">+     return toDictionaryTransition(vm, structure, UncachedDictionaryKind, deferred);</span>
  }
  
  Structure* Structure::sealTransition(VM&amp; vm, Structure* structure)
  {
      return nonPropertyTransition(vm, structure, NonPropertyTransition::Seal);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -645,20 +718,21 @@</span>
  {
      unsigned attributes = toAttributes(transitionKind);
      IndexingType indexingModeIncludingHistory = newIndexingType(structure-&gt;indexingModeIncludingHistory(), transitionKind);
  
      Structure* existingTransition;
<span class="udiff-line-modified-removed">-     if (!structure-&gt;isDictionary() &amp;&amp; (existingTransition = structure-&gt;m_transitionTable.get(0, attributes))) {</span>
<span class="udiff-line-modified-removed">-         ASSERT(existingTransition-&gt;attributesInPrevious() == attributes);</span>
<span class="udiff-line-modified-added">+     constexpr bool isAddition = true;</span>
<span class="udiff-line-modified-added">+     if (!structure-&gt;isDictionary() &amp;&amp; (existingTransition = structure-&gt;m_transitionTable.get(0, attributes, isAddition))) {</span>
<span class="udiff-line-added">+         ASSERT(existingTransition-&gt;transitionPropertyAttributes() == attributes);</span>
          ASSERT(existingTransition-&gt;indexingModeIncludingHistory() == indexingModeIncludingHistory);
          return existingTransition;
      }
  
      DeferGC deferGC(vm.heap);
  
      Structure* transition = create(vm, structure);
<span class="udiff-line-modified-removed">-     transition-&gt;setAttributesInPrevious(attributes);</span>
<span class="udiff-line-modified-added">+     transition-&gt;setTransitionPropertyAttributes(attributes);</span>
      transition-&gt;m_blob.setIndexingModeIncludingHistory(indexingModeIncludingHistory);
  
      if (preventsExtensions(transitionKind))
          transition-&gt;setDidPreventExtensions(true);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -668,11 +742,11 @@</span>
          // table, since our logic for walking the property transition chain to rematerialize the
          // table doesn&#39;t know how to take into account such wholesale edits.
  
          PropertyTable* table = structure-&gt;copyPropertyTableForPinning(vm);
          transition-&gt;pinForCaching(holdLock(transition-&gt;m_lock), vm, table);
<span class="udiff-line-modified-removed">-         transition-&gt;m_offset = structure-&gt;m_offset;</span>
<span class="udiff-line-modified-added">+         transition-&gt;setMaxOffset(vm, structure-&gt;maxOffset());</span>
  
          table = transition-&gt;propertyTableOrNull();
          RELEASE_ASSERT(table);
          for (auto&amp; entry : *table) {
              if (setsDontDeleteOnAllProperties(transitionKind))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -680,12 +754,12 @@</span>
              if (setsReadOnlyOnNonAccessorProperties(transitionKind) &amp;&amp; !(entry.attributes &amp; PropertyAttribute::Accessor))
                  entry.attributes |= static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly);
          }
      } else {
          transition-&gt;setPropertyTable(vm, structure-&gt;takePropertyTableOrCloneIfPinned(vm));
<span class="udiff-line-modified-removed">-         transition-&gt;m_offset = structure-&gt;m_offset;</span>
<span class="udiff-line-modified-removed">-         checkOffset(transition-&gt;m_offset, transition-&gt;inlineCapacity());</span>
<span class="udiff-line-modified-added">+         transition-&gt;setMaxOffset(vm, structure-&gt;maxOffset());</span>
<span class="udiff-line-modified-added">+         checkOffset(transition-&gt;maxOffset(), transition-&gt;inlineCapacity());</span>
      }
  
      if (setsReadOnlyOnNonAccessorProperties(transitionKind)
          &amp;&amp; !transition-&gt;propertyTableOrNull()-&gt;isEmpty())
          transition-&gt;setHasReadOnlyOrGetterSetterPropertiesExcludingProto(true);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -742,10 +816,11 @@</span>
  
  Structure* Structure::flattenDictionaryStructure(VM&amp; vm, JSObject* object)
  {
      checkOffsetConsistency();
      ASSERT(isDictionary());
<span class="udiff-line-added">+     ASSERT(object-&gt;structure(vm) == this);</span>
  
      GCSafeConcurrentJSLocker locker(m_lock, vm.heap);
  
      object-&gt;setStructureIDDirectly(nuke(id()));
      WTF::storeStoreFence();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -761,34 +836,35 @@</span>
          Vector&lt;JSValue&gt; values(propertyCount);
  
          // Copies out our values from their hashed locations, compacting property table offsets as we go.
          unsigned i = 0;
          PropertyTable::iterator end = table-&gt;end();
<span class="udiff-line-modified-removed">-         m_offset = invalidOffset;</span>
<span class="udiff-line-modified-added">+         auto offset = invalidOffset;</span>
          for (PropertyTable::iterator iter = table-&gt;begin(); iter != end; ++iter, ++i) {
              values[i] = object-&gt;getDirect(iter-&gt;offset);
<span class="udiff-line-modified-removed">-             m_offset = iter-&gt;offset = offsetForPropertyNumber(i, m_inlineCapacity);</span>
<span class="udiff-line-modified-added">+             offset = iter-&gt;offset = offsetForPropertyNumber(i, m_inlineCapacity);</span>
          }
<span class="udiff-line-added">+         setMaxOffset(vm, offset);</span>
<span class="udiff-line-added">+         ASSERT(transitionOffset() == invalidOffset);</span>
  
          // Copies in our values to their compacted locations.
          for (unsigned i = 0; i &lt; propertyCount; i++)
              object-&gt;putDirect(vm, offsetForPropertyNumber(i, m_inlineCapacity), values[i]);
  
          table-&gt;clearDeletedOffsets();
  
          // We need to zero our unused property space; otherwise the GC might see a
          // stale pointer when we add properties in the future.
<span class="udiff-line-modified-removed">-         memset(</span>
<span class="udiff-line-modified-added">+         gcSafeZeroMemory(</span>
              object-&gt;inlineStorageUnsafe() + inlineSize(),
<span class="udiff-line-removed">-             0,</span>
              (inlineCapacity() - inlineSize()) * sizeof(EncodedJSValue));
  
          Butterfly* butterfly = object-&gt;butterfly();
          size_t preCapacity = butterfly-&gt;indexingHeader()-&gt;preCapacity(this);
          void* base = butterfly-&gt;base(preCapacity, beforeOutOfLineCapacity);
          void* startOfPropertyStorageSlots = reinterpret_cast&lt;EncodedJSValue*&gt;(base) + preCapacity;
<span class="udiff-line-modified-removed">-         memset(startOfPropertyStorageSlots, 0, (beforeOutOfLineCapacity - outOfLineSize()) * sizeof(EncodedJSValue));</span>
<span class="udiff-line-modified-added">+         gcSafeZeroMemory(static_cast&lt;JSValue*&gt;(startOfPropertyStorageSlots), (beforeOutOfLineCapacity - outOfLineSize()) * sizeof(EncodedJSValue));</span>
          checkOffsetConsistency();
      }
  
      setDictionaryKind(NoneDictionaryKind);
      setHasBeenFlattenedBefore(true);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -821,18 +897,18 @@</span>
  void Structure::pin(const AbstractLocker&amp;, VM&amp; vm, PropertyTable* table)
  {
      setIsPinnedPropertyTable(true);
      setPropertyTable(vm, table);
      clearPreviousID();
<span class="udiff-line-modified-removed">-     m_nameInPrevious = nullptr;</span>
<span class="udiff-line-modified-added">+     m_transitionPropertyName = nullptr;</span>
  }
  
  void Structure::pinForCaching(const AbstractLocker&amp;, VM&amp; vm, PropertyTable* table)
  {
      setIsPinnedPropertyTable(true);
      setPropertyTable(vm, table);
<span class="udiff-line-modified-removed">-     m_nameInPrevious = nullptr;</span>
<span class="udiff-line-modified-added">+     m_transitionPropertyName = nullptr;</span>
  }
  
  void Structure::allocateRareData(VM&amp; vm)
  {
      ASSERT(!hasRareData());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -960,18 +1036,20 @@</span>
  
  PropertyOffset Structure::add(VM&amp; vm, PropertyName propertyName, unsigned attributes)
  {
      return add&lt;ShouldPin::No&gt;(
          vm, propertyName, attributes,
<span class="udiff-line-modified-removed">-         [this] (const GCSafeConcurrentJSLocker&amp;, PropertyOffset, PropertyOffset newLastOffset) {</span>
<span class="udiff-line-modified-removed">-             setLastOffset(newLastOffset);</span>
<span class="udiff-line-modified-added">+         [this, &amp;vm] (const GCSafeConcurrentJSLocker&amp;, PropertyOffset, PropertyOffset newMaxOffset) {</span>
<span class="udiff-line-modified-added">+             setMaxOffset(vm, newMaxOffset);</span>
          });
  }
  
<span class="udiff-line-modified-removed">- PropertyOffset Structure::remove(PropertyName propertyName)</span>
<span class="udiff-line-modified-added">+ PropertyOffset Structure::remove(VM&amp; vm, PropertyName propertyName)</span>
  {
<span class="udiff-line-modified-removed">-     return remove(propertyName, [] (const ConcurrentJSLocker&amp;, PropertyOffset) { });</span>
<span class="udiff-line-modified-added">+     return remove&lt;ShouldPin::No&gt;(vm, propertyName, [this, &amp;vm] (const GCSafeConcurrentJSLocker&amp;, PropertyOffset, PropertyOffset newMaxOffset) {</span>
<span class="udiff-line-added">+         setMaxOffset(vm, newMaxOffset);</span>
<span class="udiff-line-added">+     });</span>
  }
  
  void Structure::getPropertyNamesFromStructure(VM&amp; vm, PropertyNameArray&amp; propertyNames, EnumerationMode mode)
  {
      PropertyTable* table = ensurePropertyTableIfNotEmpty(vm);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1047,11 +1125,11 @@</span>
          visitor.append(thisObject-&gt;m_prototype);
          visitor.append(thisObject-&gt;m_cachedPrototypeChain);
      }
      visitor.append(thisObject-&gt;m_previousOrRareData);
  
<span class="udiff-line-modified-removed">-     if (thisObject-&gt;isPinnedPropertyTable() || thisObject-&gt;isAddingPropertyForTransition()) {</span>
<span class="udiff-line-modified-added">+     if (thisObject-&gt;isPinnedPropertyTable() || thisObject-&gt;protectPropertyTableWhileTransitioning()) {</span>
          // NOTE: This can interleave in pin(), in which case it may see a null property table.
          // That&#39;s fine, because then the barrier will fire and we will scan this again.
          visitor.append(thisObject-&gt;m_propertyTableUnsafe);
      } else if (visitor.isAnalyzingHeap())
          visitor.append(thisObject-&gt;m_propertyTableUnsafe);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1205,24 +1283,26 @@</span>
      if (!hasRareData())
          return nullptr;
      return rareData()-&gt;cachedPropertyNameEnumerator();
  }
  
<span class="udiff-line-modified-removed">- bool Structure::canCachePropertyNameEnumerator() const</span>
<span class="udiff-line-modified-added">+ bool Structure::canCachePropertyNameEnumerator(VM&amp; vm) const</span>
  {
      if (!this-&gt;canCacheOwnKeys())
          return false;
  
      StructureChain* structureChain = m_cachedPrototypeChain.get();
      ASSERT(structureChain);
<span class="udiff-line-modified-removed">-     WriteBarrier&lt;Structure&gt;* structure = structureChain-&gt;head();</span>
<span class="udiff-line-modified-added">+     StructureID* currentStructureID = structureChain-&gt;head();</span>
      while (true) {
<span class="udiff-line-modified-removed">-         if (!structure-&gt;get())</span>
<span class="udiff-line-modified-added">+         StructureID structureID = *currentStructureID;</span>
<span class="udiff-line-added">+         if (!structureID)</span>
              return true;
<span class="udiff-line-modified-removed">-         if (!structure-&gt;get()-&gt;canCacheOwnKeys())</span>
<span class="udiff-line-modified-added">+         Structure* structure = vm.getStructure(structureID);</span>
<span class="udiff-line-added">+         if (!structure-&gt;canCacheOwnKeys())</span>
              return false;
<span class="udiff-line-modified-removed">-         structure++;</span>
<span class="udiff-line-modified-added">+         currentStructureID++;</span>
      }
  
      ASSERT_NOT_REACHED();
      return true;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1236,6 +1316,17 @@</span>
      if (isUncacheableDictionary())
          return false;
      return true;
  }
  
<span class="udiff-line-added">+ auto Structure::findPropertyHashEntry(PropertyName propertyName) const -&gt; Optional&lt;PropertyHashEntry&gt;</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     for (const ClassInfo* info = classInfo(); info; info = info-&gt;parentClass) {</span>
<span class="udiff-line-added">+         if (const HashTable* propHashTable = info-&gt;staticPropHashTable) {</span>
<span class="udiff-line-added">+             if (const HashTableValue* entry = propHashTable-&gt;entry(propertyName))</span>
<span class="udiff-line-added">+                 return PropertyHashEntry { propHashTable, entry };</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return WTF::nullopt;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  } // namespace JSC
</pre>
<center><a href="StringRecursionChecker.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Structure.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
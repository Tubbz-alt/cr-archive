<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2009-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebGLBuffer.h&quot;
 28 
 29 #if ENABLE(WEBGL)
 30 
 31 #include &quot;WebGLContextGroup.h&quot;
 32 #include &quot;WebGLRenderingContextBase.h&quot;
 33 #include &lt;JavaScriptCore/ArrayBuffer.h&gt;
 34 
 35 namespace WebCore {
 36 
 37 Ref&lt;WebGLBuffer&gt; WebGLBuffer::create(WebGLRenderingContextBase&amp; ctx)
 38 {
 39     return adoptRef(*new WebGLBuffer(ctx));
 40 }
 41 
 42 WebGLBuffer::WebGLBuffer(WebGLRenderingContextBase&amp; ctx)
 43     : WebGLSharedObject(ctx)
 44 {
 45     setObject(ctx.graphicsContextGL()-&gt;createBuffer());
 46     clearCachedMaxIndices();
 47 }
 48 
 49 WebGLBuffer::~WebGLBuffer()
 50 {
 51     deleteObject(0);
 52 }
 53 
 54 void WebGLBuffer::deleteObjectImpl(GraphicsContextGLOpenGL* context3d, PlatformGLObject object)
 55 {
 56     context3d-&gt;deleteBuffer(object);
 57 }
 58 
 59 bool WebGLBuffer::associateBufferDataImpl(const void* data, GCGLsizeiptr byteLength)
 60 {
 61     if (byteLength &lt; 0)
 62         return false;
 63 
 64     switch (m_target) {
 65     case GraphicsContextGL::ELEMENT_ARRAY_BUFFER:
 66         if (byteLength &gt; std::numeric_limits&lt;unsigned&gt;::max())
 67             return false;
 68         m_byteLength = byteLength;
 69         clearCachedMaxIndices();
 70         if (byteLength) {
 71             m_elementArrayBuffer = ArrayBuffer::tryCreate(byteLength, 1);
 72             if (!m_elementArrayBuffer) {
 73                 m_byteLength = 0;
 74                 return false;
 75             }
 76             if (data) {
 77                 // We must always clone the incoming data because client-side
 78                 // modifications without calling bufferData or bufferSubData
 79                 // must never be able to change the validation results.
 80                 memcpy(m_elementArrayBuffer-&gt;data(), data, byteLength);
 81             }
 82         } else
 83             m_elementArrayBuffer = nullptr;
 84         return true;
 85     case GraphicsContextGL::ARRAY_BUFFER:
 86         m_byteLength = byteLength;
 87         return true;
 88     default:
 89 #if ENABLE(WEBGL2)
 90         switch (m_target) {
 91         case GraphicsContextGL::COPY_READ_BUFFER:
 92         case GraphicsContextGL::COPY_WRITE_BUFFER:
 93         case GraphicsContextGL::PIXEL_PACK_BUFFER:
 94         case GraphicsContextGL::PIXEL_UNPACK_BUFFER:
 95         case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:
 96         case GraphicsContextGL::UNIFORM_BUFFER:
 97             m_byteLength = byteLength;
 98             return true;
 99         }
100 #endif
101         return false;
102     }
103 }
104 
105 bool WebGLBuffer::associateBufferData(GCGLsizeiptr size)
106 {
107     return associateBufferDataImpl(nullptr, size);
108 }
109 
110 bool WebGLBuffer::associateBufferData(ArrayBuffer* array)
111 {
112     if (!array)
113         return false;
114     return associateBufferDataImpl(array-&gt;data(), array-&gt;byteLength());
115 }
116 
117 bool WebGLBuffer::associateBufferData(ArrayBufferView* array)
118 {
119     if (!array)
120         return false;
121     return associateBufferDataImpl(array-&gt;baseAddress(), array-&gt;byteLength());
122 }
123 
124 bool WebGLBuffer::associateBufferSubDataImpl(GCGLintptr offset, const void* data, GCGLsizeiptr byteLength)
125 {
126     if (!data || offset &lt; 0 || byteLength &lt; 0)
127         return false;
128 
129     if (byteLength) {
130         Checked&lt;GCGLintptr, RecordOverflow&gt; checkedBufferOffset(offset);
131         Checked&lt;GCGLsizeiptr, RecordOverflow&gt; checkedDataLength(byteLength);
132         Checked&lt;GCGLintptr, RecordOverflow&gt; checkedBufferMax = checkedBufferOffset + checkedDataLength;
133         if (checkedBufferMax.hasOverflowed() || offset &gt; m_byteLength || checkedBufferMax.unsafeGet() &gt; m_byteLength)
134             return false;
135     }
136 
137     switch (m_target) {
138     case GraphicsContextGL::ELEMENT_ARRAY_BUFFER:
139         clearCachedMaxIndices();
140         if (byteLength) {
141             if (!m_elementArrayBuffer)
142                 return false;
143             memcpy(static_cast&lt;unsigned char*&gt;(m_elementArrayBuffer-&gt;data()) + offset, data, byteLength);
144         }
145         return true;
146     case GraphicsContextGL::ARRAY_BUFFER:
147         return true;
148     default:
149 #if ENABLE(WEBGL2)
150         switch (m_target) {
151         case GraphicsContextGL::COPY_READ_BUFFER:
152         case GraphicsContextGL::COPY_WRITE_BUFFER:
153         case GraphicsContextGL::PIXEL_PACK_BUFFER:
154         case GraphicsContextGL::PIXEL_UNPACK_BUFFER:
155         case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:
156         case GraphicsContextGL::UNIFORM_BUFFER:
157             return true;
158         }
159 #endif
160         return false;
161     }
162 }
163 
164 bool WebGLBuffer::associateBufferSubData(GCGLintptr offset, ArrayBuffer* array)
165 {
166     if (!array)
167         return false;
168     return associateBufferSubDataImpl(offset, array-&gt;data(), array-&gt;byteLength());
169 }
170 
171 bool WebGLBuffer::associateBufferSubData(GCGLintptr offset, ArrayBufferView* array)
172 {
173     if (!array)
174         return false;
175     return associateBufferSubDataImpl(offset, array-&gt;baseAddress(), array-&gt;byteLength());
176 }
177 
178 bool WebGLBuffer::associateCopyBufferSubData(const WebGLBuffer&amp; readBuffer, GCGLintptr readOffset, GCGLintptr writeOffset, GCGLsizeiptr size)
179 {
180     if (readOffset &lt; 0 || writeOffset &lt; 0 || size &lt; 0)
181         return false;
182 
183     if (size) {
184         Checked&lt;GCGLintptr, RecordOverflow&gt; checkedReadBufferOffset(readOffset);
185         Checked&lt;GCGLsizeiptr, RecordOverflow&gt; checkedDataLength(size);
186         Checked&lt;GCGLintptr, RecordOverflow&gt; checkedReadBufferMax = checkedReadBufferOffset + checkedDataLength;
187         if (checkedReadBufferMax.hasOverflowed() || readOffset &gt; readBuffer.byteLength() || checkedReadBufferMax.unsafeGet() &gt; readBuffer.byteLength())
188             return false;
189 
190         Checked&lt;GCGLintptr, RecordOverflow&gt; checkedWriteBufferOffset(writeOffset);
191         Checked&lt;GCGLintptr, RecordOverflow&gt; checkedWriteBufferMax = checkedWriteBufferOffset + checkedDataLength;
192         if (checkedWriteBufferMax.hasOverflowed() || writeOffset &gt; m_byteLength || checkedWriteBufferMax.unsafeGet() &gt; m_byteLength)
193             return false;
194     }
195 
196     switch (m_target) {
197     case GraphicsContextGL::ELEMENT_ARRAY_BUFFER:
198         clearCachedMaxIndices();
199         if (size) {
200             if (!m_elementArrayBuffer)
201                 return false;
202             memcpy(static_cast&lt;unsigned char*&gt;(m_elementArrayBuffer-&gt;data()) + writeOffset, static_cast&lt;const unsigned char*&gt;(readBuffer.elementArrayBuffer()-&gt;data()) + readOffset, size);
203         }
204         return true;
205     case GraphicsContextGL::ARRAY_BUFFER:
206         return true;
207     default:
208 #if ENABLE(WEBGL2)
209         switch (m_target) {
210         case GraphicsContextGL::COPY_READ_BUFFER:
211         case GraphicsContextGL::COPY_WRITE_BUFFER:
212         case GraphicsContextGL::PIXEL_PACK_BUFFER:
213         case GraphicsContextGL::PIXEL_UNPACK_BUFFER:
214         case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:
215         case GraphicsContextGL::UNIFORM_BUFFER:
216             return true;
217         }
218 #endif
219         return false;
220     }
221 }
222 
223 void WebGLBuffer::disassociateBufferData()
224 {
225     m_byteLength = 0;
226     clearCachedMaxIndices();
227 }
228 
229 GCGLsizeiptr WebGLBuffer::byteLength() const
230 {
231     return m_byteLength;
232 }
233 
234 Optional&lt;unsigned&gt; WebGLBuffer::getCachedMaxIndex(GCGLenum type)
235 {
236     for (auto&amp; cache : m_maxIndexCache) {
237         if (cache.type == type)
238             return cache.maxIndex;
239     }
240     return WTF::nullopt;
241 }
242 
243 void WebGLBuffer::setCachedMaxIndex(GCGLenum type, unsigned value)
244 {
245     for (auto&amp; cache : m_maxIndexCache) {
246         if (cache.type == type) {
247             cache.maxIndex = value;
248             return;
249         }
250     }
251     m_maxIndexCache[m_nextAvailableCacheEntry].type = type;
252     m_maxIndexCache[m_nextAvailableCacheEntry].maxIndex = value;
253     m_nextAvailableCacheEntry = (m_nextAvailableCacheEntry + 1) % WTF_ARRAY_LENGTH(m_maxIndexCache);
254 }
255 
256 void WebGLBuffer::setTarget(GCGLenum target)
257 {
258     m_target = target;
259 
260     if (target == GraphicsContextGL::ARRAY_BUFFER || target == GraphicsContextGL::ELEMENT_ARRAY_BUFFER) {
261         ASSERT(!m_arrayBufferOrElementArrayBuffer || target == m_arrayBufferOrElementArrayBuffer);
262         m_arrayBufferOrElementArrayBuffer = target;
263     }
264 }
265 
266 void WebGLBuffer::clearCachedMaxIndices()
267 {
268     memset(m_maxIndexCache, 0, sizeof(m_maxIndexCache));
269 }
270 
271 }
272 
273 #endif // ENABLE(WEBGL)
    </pre>
  </body>
</html>
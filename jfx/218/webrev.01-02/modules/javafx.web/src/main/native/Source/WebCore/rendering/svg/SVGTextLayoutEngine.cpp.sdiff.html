<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGTextLayoutEngine.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGSubpathData.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGTextLayoutEngineBaseline.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGTextLayoutEngine.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  6  * License as published by the Free Software Foundation; either
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public License
 15  * along with this library; see the file COPYING.LIB.  If not, write to
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  */
 19 
 20 #include &quot;config.h&quot;
 21 #include &quot;SVGTextLayoutEngine.h&quot;
 22 
 23 #include &quot;PathTraversalState.h&quot;
 24 #include &quot;RenderSVGTextPath.h&quot;
 25 #include &quot;SVGElement.h&quot;

 26 #include &quot;SVGInlineTextBox.h&quot;
 27 #include &quot;SVGLengthContext.h&quot;
 28 #include &quot;SVGTextContentElement.h&quot;
 29 #include &quot;SVGTextLayoutEngineBaseline.h&quot;
 30 #include &quot;SVGTextLayoutEngineSpacing.h&quot;
 31 
 32 // Set to a value &gt; 0 to dump the text fragments
 33 #define DUMP_TEXT_FRAGMENTS 0
 34 
 35 namespace WebCore {
 36 
 37 SVGTextLayoutEngine::SVGTextLayoutEngine(Vector&lt;SVGTextLayoutAttributes*&gt;&amp; layoutAttributes)
 38     : m_layoutAttributes(layoutAttributes)
 39     , m_layoutAttributesPosition(0)
 40     , m_logicalCharacterOffset(0)
 41     , m_logicalMetricsListOffset(0)
 42     , m_visualCharacterOffset(0)
 43     , m_visualMetricsListOffset(0)
 44     , m_x(0)
 45     , m_y(0)
</pre>
<hr />
<pre>
153         }
154 
155         if (currentParent-&gt;isSVGText())
156             return false;
157 
158         currentParent = currentParent-&gt;parent();
159     }
160 
161     ASSERT_NOT_REACHED();
162     return false;
163 }
164 
165 void SVGTextLayoutEngine::beginTextPathLayout(RenderSVGTextPath&amp; textPath, SVGTextLayoutEngine&amp; lineLayout)
166 {
167     m_inPathLayout = true;
168 
169     m_textPath = textPath.layoutPath();
170     if (m_textPath.isEmpty())
171         return;
172 
<span class="line-modified">173     m_textPathStartOffset = textPath.startOffset();</span>
174     m_textPathLength = m_textPath.length();
<span class="line-modified">175     if (m_textPathStartOffset &gt; 0 &amp;&amp; m_textPathStartOffset &lt;= 1)</span>
<span class="line-modified">176         m_textPathStartOffset *= m_textPathLength;</span>









177 
178     lineLayout.m_chunkLayoutBuilder.buildTextChunks(lineLayout.m_lineLayoutBoxes);
179 
180     // Handle text-anchor as additional start offset for text paths.
181     m_textPathStartOffset += lineLayout.m_chunkLayoutBuilder.totalAnchorShift();
182     m_textPathCurrentOffset = m_textPathStartOffset;
183 
184     // Eventually handle textLength adjustments.
185     auto* textContentElement = SVGTextContentElement::elementFromRenderer(&amp;textPath);
186     if (!textContentElement)
187         return;
188 
189     SVGLengthContext lengthContext(textContentElement);
190     float desiredTextLength = textContentElement-&gt;specifiedTextLength().value(lengthContext);
191     if (!desiredTextLength)
192         return;
193 
194     float totalLength = lineLayout.m_chunkLayoutBuilder.totalLength();
195     unsigned totalCharacters = lineLayout.m_chunkLayoutBuilder.totalCharacters();
196 
</pre>
<hr />
<pre>
514                 yOrientationShift += m_dy - baselineShift;
515             }
516 
517             // Calculate current offset along path.
518             textPathOffset = m_textPathCurrentOffset + scaledGlyphAdvance / 2;
519 
520             // Move to next character.
521             m_textPathCurrentOffset += scaledGlyphAdvance + m_textPathSpacing + spacing * m_textPathScaling;
522 
523             // Skip character, if we&#39;re before the path.
524             if (textPathOffset &lt; 0) {
525                 advanceToNextLogicalCharacter(logicalMetrics);
526                 advanceToNextVisualCharacter(visualMetrics);
527                 continue;
528             }
529 
530             // Stop processing, if the next character lies behind the path.
531             if (textPathOffset &gt; m_textPathLength)
532                 break;
533 
<span class="line-modified">534             bool success = false;</span>
<span class="line-modified">535             auto traversalState(m_textPath.traversalStateAtLength(textPathOffset, success));</span>
<span class="line-removed">536             ASSERT(success);</span>
537 
538             FloatPoint point = traversalState.current();
539             x = point.x();
540             y = point.y();
541 
542             angle = traversalState.normalAngle();
543 
544             // For vertical text on path, the actual angle has to be rotated 90 degrees anti-clockwise, not the orientation angle!
545             if (m_isVerticalText)
546                 angle -= 90;
547         } else {
548             // Apply all previously calculated shift values.
549             if (m_isVerticalText)
550                 x += baselineShift;
551             else
552                 y -= baselineShift;
553 
554             x += m_dx;
555             y += m_dy;
556         }
</pre>
</td>
<td>
<hr />
<pre>
  6  * License as published by the Free Software Foundation; either
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public License
 15  * along with this library; see the file COPYING.LIB.  If not, write to
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  */
 19 
 20 #include &quot;config.h&quot;
 21 #include &quot;SVGTextLayoutEngine.h&quot;
 22 
 23 #include &quot;PathTraversalState.h&quot;
 24 #include &quot;RenderSVGTextPath.h&quot;
 25 #include &quot;SVGElement.h&quot;
<span class="line-added"> 26 #include &quot;SVGGeometryElement.h&quot;</span>
 27 #include &quot;SVGInlineTextBox.h&quot;
 28 #include &quot;SVGLengthContext.h&quot;
 29 #include &quot;SVGTextContentElement.h&quot;
 30 #include &quot;SVGTextLayoutEngineBaseline.h&quot;
 31 #include &quot;SVGTextLayoutEngineSpacing.h&quot;
 32 
 33 // Set to a value &gt; 0 to dump the text fragments
 34 #define DUMP_TEXT_FRAGMENTS 0
 35 
 36 namespace WebCore {
 37 
 38 SVGTextLayoutEngine::SVGTextLayoutEngine(Vector&lt;SVGTextLayoutAttributes*&gt;&amp; layoutAttributes)
 39     : m_layoutAttributes(layoutAttributes)
 40     , m_layoutAttributesPosition(0)
 41     , m_logicalCharacterOffset(0)
 42     , m_logicalMetricsListOffset(0)
 43     , m_visualCharacterOffset(0)
 44     , m_visualMetricsListOffset(0)
 45     , m_x(0)
 46     , m_y(0)
</pre>
<hr />
<pre>
154         }
155 
156         if (currentParent-&gt;isSVGText())
157             return false;
158 
159         currentParent = currentParent-&gt;parent();
160     }
161 
162     ASSERT_NOT_REACHED();
163     return false;
164 }
165 
166 void SVGTextLayoutEngine::beginTextPathLayout(RenderSVGTextPath&amp; textPath, SVGTextLayoutEngine&amp; lineLayout)
167 {
168     m_inPathLayout = true;
169 
170     m_textPath = textPath.layoutPath();
171     if (m_textPath.isEmpty())
172         return;
173 
<span class="line-modified">174     const auto&amp; startOffset = textPath.startOffset();</span>
175     m_textPathLength = m_textPath.length();
<span class="line-modified">176 </span>
<span class="line-modified">177     if (textPath.startOffset().lengthType() == SVGLengthType::Percentage)</span>
<span class="line-added">178         m_textPathStartOffset = startOffset.valueAsPercentage() * m_textPathLength;</span>
<span class="line-added">179     else {</span>
<span class="line-added">180         m_textPathStartOffset = startOffset.valueInSpecifiedUnits();</span>
<span class="line-added">181         if (auto* tragetElement = textPath.targetElement()) {</span>
<span class="line-added">182             // FIXME: A value of zero is valid. Need to differentiate this case from being unspecified.</span>
<span class="line-added">183             if (float pathLength = tragetElement-&gt;pathLength())</span>
<span class="line-added">184                 m_textPathStartOffset *= m_textPathLength / pathLength;</span>
<span class="line-added">185         }</span>
<span class="line-added">186     }</span>
187 
188     lineLayout.m_chunkLayoutBuilder.buildTextChunks(lineLayout.m_lineLayoutBoxes);
189 
190     // Handle text-anchor as additional start offset for text paths.
191     m_textPathStartOffset += lineLayout.m_chunkLayoutBuilder.totalAnchorShift();
192     m_textPathCurrentOffset = m_textPathStartOffset;
193 
194     // Eventually handle textLength adjustments.
195     auto* textContentElement = SVGTextContentElement::elementFromRenderer(&amp;textPath);
196     if (!textContentElement)
197         return;
198 
199     SVGLengthContext lengthContext(textContentElement);
200     float desiredTextLength = textContentElement-&gt;specifiedTextLength().value(lengthContext);
201     if (!desiredTextLength)
202         return;
203 
204     float totalLength = lineLayout.m_chunkLayoutBuilder.totalLength();
205     unsigned totalCharacters = lineLayout.m_chunkLayoutBuilder.totalCharacters();
206 
</pre>
<hr />
<pre>
524                 yOrientationShift += m_dy - baselineShift;
525             }
526 
527             // Calculate current offset along path.
528             textPathOffset = m_textPathCurrentOffset + scaledGlyphAdvance / 2;
529 
530             // Move to next character.
531             m_textPathCurrentOffset += scaledGlyphAdvance + m_textPathSpacing + spacing * m_textPathScaling;
532 
533             // Skip character, if we&#39;re before the path.
534             if (textPathOffset &lt; 0) {
535                 advanceToNextLogicalCharacter(logicalMetrics);
536                 advanceToNextVisualCharacter(visualMetrics);
537                 continue;
538             }
539 
540             // Stop processing, if the next character lies behind the path.
541             if (textPathOffset &gt; m_textPathLength)
542                 break;
543 
<span class="line-modified">544             auto traversalState(m_textPath.traversalStateAtLength(textPathOffset));</span>
<span class="line-modified">545             ASSERT(traversalState.success());</span>

546 
547             FloatPoint point = traversalState.current();
548             x = point.x();
549             y = point.y();
550 
551             angle = traversalState.normalAngle();
552 
553             // For vertical text on path, the actual angle has to be rotated 90 degrees anti-clockwise, not the orientation angle!
554             if (m_isVerticalText)
555                 angle -= 90;
556         } else {
557             // Apply all previously calculated shift values.
558             if (m_isVerticalText)
559                 x += baselineShift;
560             else
561                 y -= baselineShift;
562 
563             x += m_dx;
564             y += m_dy;
565         }
</pre>
</td>
</tr>
</table>
<center><a href="SVGSubpathData.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGTextLayoutEngineBaseline.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
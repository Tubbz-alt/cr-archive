<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3StackmapValue.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(B3_JIT)
 29 
 30 #include &quot;B3ConstrainedValue.h&quot;
 31 #include &quot;B3Value.h&quot;
 32 #include &quot;B3ValueRep.h&quot;
 33 #include &quot;RegisterSet.h&quot;
 34 #include &lt;wtf/SharedTask.h&gt;
 35 
 36 namespace JSC {
 37 
 38 class CCallHelpers;
 39 
 40 namespace B3 {
 41 
 42 class StackmapGenerationParams;
 43 
 44 typedef void StackmapGeneratorFunction(CCallHelpers&amp;, const StackmapGenerationParams&amp;);
 45 typedef SharedTask&lt;StackmapGeneratorFunction&gt; StackmapGenerator;
 46 
 47 class JS_EXPORT_PRIVATE StackmapValue : public Value {
 48 public:
 49     static bool accepts(Kind kind)
 50     {
 51         // This needs to include opcodes of all subclasses.
 52         switch (kind.opcode()) {
 53         case CheckAdd:
 54         case CheckSub:
 55         case CheckMul:
 56         case Check:
 57         case Patchpoint:
 58             return true;
 59         default:
 60             return false;
 61         }
 62     }
 63 
 64     ~StackmapValue();
 65 
 66     // Use this to add children.
 67     void append(const ConstrainedValue&amp; value)
 68     {
 69         ASSERT(value.value()-&gt;type().isNumeric());
 70         append(value.value(), value.rep());
 71     }
 72 
 73     void append(Value*, const ValueRep&amp;);
 74 
 75     template&lt;typename VectorType&gt;
 76     void appendVector(const VectorType&amp; vector)
 77     {
 78         for (const auto&amp; value : vector)
 79             append(value);
 80     }
 81 
 82     // Helper for appending a bunch of values with some ValueRep.
 83     template&lt;typename VectorType&gt;
 84     void appendVectorWithRep(const VectorType&amp; vector, const ValueRep&amp; rep)
 85     {
 86         for (Value* value : vector)
 87             append(value, rep);
 88     }
 89 
 90     // Helper for appending cold any&#39;s. This often used by clients to implement OSR.
 91     template&lt;typename VectorType&gt;
 92     void appendColdAnys(const VectorType&amp; vector)
 93     {
 94         appendVectorWithRep(vector, ValueRep::ColdAny);
 95     }
 96     template&lt;typename VectorType&gt;
 97     void appendLateColdAnys(const VectorType&amp; vector)
 98     {
 99         appendVectorWithRep(vector, ValueRep::LateColdAny);
100     }
101 
102     // This is a helper for something you might do a lot of: append a value that should be constrained
103     // to SomeRegister.
104     void appendSomeRegister(Value*);
105     void appendSomeRegisterWithClobber(Value*);
106 
107     const Vector&lt;ValueRep&gt;&amp; reps() const { return m_reps; }
108 
109     // Stackmaps allow you to specify that the operation may clobber some registers. Clobbering a register
110     // means that the operation appears to store a value into the register, but the compiler doesn&#39;t
111     // assume to know anything about what kind of value might have been stored. In B3&#39;s model of
112     // execution, registers are read or written at instruction boundaries rather than inside the
113     // instructions themselves. A register could be read or written immediately before the instruction
114     // executes, or immediately after. Note that at a boundary between instruction A and instruction B we
115     // simultaneously look at what A does after it executes and what B does before it executes. This is
116     // because when the compiler considers what happens to registers, it views the boundary between two
117     // instructions as a kind of atomic point where the late effects of A happen at the same time as the
118     // early effects of B.
119     //
120     // The compiler views a stackmap as a single instruction, even though of course the stackmap may be
121     // composed of any number of instructions (if it&#39;s a Patchpoint). You can claim that a stackmap value
122     // clobbers a set of registers before the stackmap&#39;s instruction or after. Clobbering before is called
123     // early clobber, while clobbering after is called late clobber.
124     //
125     // This is quite flexible but it has its limitations. Any register listed as an early clobber will
126     // interfere with all uses of the stackmap. Any register listed as a late clobber will interfere with
127     // all defs of the stackmap (i.e. the result). This means that it&#39;s currently not possible to claim
128     // to clobber a register while still allowing that register to be used for both an input and an output
129     // of the instruction. It just so happens that B3&#39;s sole client (the FTL) currently never wants to
130     // convey such a constraint, but it will want it eventually (FIXME:
131     // https://bugs.webkit.org/show_bug.cgi?id=151823).
132     //
133     // Note that a common use case of early clobber sets is to indicate that this is the set of registers
134     // that shall not be used for inputs to the value. But B3 supports two different ways of specifying
135     // this, the other being LateUse in combination with late clobber (not yet available to stackmaps
136     // directly, FIXME: https://bugs.webkit.org/show_bug.cgi?id=151335). A late use makes the use of that
137     // value appear to happen after the instruction. This means that a late use cannot use the same
138     // register as the result and it cannot use the same register as either early or late clobbered
139     // registers. Late uses are usually a better way of saying that a clobbered register cannot be used
140     // for an input. Early clobber means that some register(s) interfere with *all* inputs, while LateUse
141     // means that some value interferes with whatever is live after the instruction. Below is a list of
142     // examples of how the FTL can handle its various kinds of scenarios using a combination of early
143     // clobber, late clobber, and late use. These examples are for X86_64, w.l.o.g.
144     //
145     // Basic ById patchpoint: Early and late clobber of r11. Early clobber prevents any inputs from using
146     // r11 since that would mess with the MacroAssembler&#39;s assumptions when we
147     // AllowMacroScratchRegisterUsage. Late clobber tells B3 that the patchpoint may overwrite r11.
148     //
149     // ById patchpoint in a try block with some live state: This might throw an exception after already
150     // assigning to the result. So, this should LateUse all stackmap values to ensure that the stackmap
151     // values don&#39;t interfere with the result. Note that we do not LateUse the non-OSR inputs of the ById
152     // since LateUse implies that the use is cold: the register allocator will assume that the use is not
153     // important for the critical path. Also, early and late clobber of r11.
154     //
155     // Basic ByIdFlush patchpoint: We could do Flush the same way we did it with LLVM: ignore it and let
156     // PolymorphicAccess figure it out. Or, we could add internal clobber support (FIXME:
157     // https://bugs.webkit.org/show_bug.cgi?id=151823). Or, we could do it by early clobbering r11, late
158     // clobbering all volatile registers, and constraining the result to some register. Or, we could do
159     // that but leave the result constrained to SomeRegister, which will cause it to use a callee-save
160     // register. Internal clobber support would allow us to use SomeRegister while getting the result into
161     // a volatile register.
162     //
163     // ByIdFlush patchpoint in a try block with some live state: LateUse all for-OSR stackmap values,
164     // early clobber of r11 to prevent the other inputs from using r11, and late clobber of all volatile
165     // registers to make way for the call. To handle the result, we could do any of what is listed in the
166     // previous paragraph.
167     //
168     // Basic JS call: Force all non-OSR inputs into specific locations (register, stack, whatever).
169     // All volatile registers are late-clobbered. The output is constrained to a register as well.
170     //
171     // JS call in a try block with some live state: LateUse all for-OSR stackmap values, fully constrain
172     // all non-OSR inputs and the result, and late clobber all volatile registers.
173     //
174     // JS tail call: Pass all inputs as a warm variant of Any (FIXME:
175     // https://bugs.webkit.org/show_bug.cgi?id=151811).
176     //
177     // Note that we cannot yet do all of these things because although Air already supports all of these
178     // various forms of uses (LateUse and warm unconstrained use), B3 doesn&#39;t yet expose all of it. The
179     // bugs are:
180     // https://bugs.webkit.org/show_bug.cgi?id=151335 (LateUse)
181     // https://bugs.webkit.org/show_bug.cgi?id=151811 (warm Any)
182     void clobberEarly(const RegisterSet&amp; set)
183     {
184         m_earlyClobbered.merge(set);
185     }
186 
187     void clobberLate(const RegisterSet&amp; set)
188     {
189         m_lateClobbered.merge(set);
190     }
191 
192     void clobber(const RegisterSet&amp; set)
193     {
194         clobberEarly(set);
195         clobberLate(set);
196     }
197 
198     RegisterSet&amp; earlyClobbered() { return m_earlyClobbered; }
199     RegisterSet&amp; lateClobbered() { return m_lateClobbered; }
200     const RegisterSet&amp; earlyClobbered() const { return m_earlyClobbered; }
201     const RegisterSet&amp; lateClobbered() const { return m_lateClobbered; }
202 
203     void setGenerator(RefPtr&lt;StackmapGenerator&gt; generator)
204     {
205         m_generator = generator;
206     }
207 
208     template&lt;typename Functor&gt;
209     void setGenerator(const Functor&amp; functor)
210     {
211         m_generator = createSharedTask&lt;StackmapGeneratorFunction&gt;(functor);
212     }
213 
214     RefPtr&lt;StackmapGenerator&gt; generator() const { return m_generator; }
215 
216     ConstrainedValue constrainedChild(unsigned index) const
217     {
218         return ConstrainedValue(child(index), index &lt; m_reps.size() ? m_reps[index] : ValueRep::ColdAny);
219     }
220 
221     void setConstrainedChild(unsigned index, const ConstrainedValue&amp;);
222 
223     void setConstraint(unsigned index, const ValueRep&amp;);
224 
225     class ConstrainedValueCollection {
226     public:
227 
228         ConstrainedValueCollection(const StackmapValue&amp; value)
229             : m_value(value)
230         {
231         }
232 
233         unsigned size() const { return m_value.numChildren(); }
234 
235         ConstrainedValue at(unsigned index) const { return m_value.constrainedChild(index); }
236 
237         ConstrainedValue operator[](unsigned index) const { return at(index); }
238 
239         class iterator {
240         public:
241             using iterator_category = std::forward_iterator_tag;
242             using value_type = ConstrainedValue;
243             using difference_type = int;
244             using pointer = void;
245             using reference = ConstrainedValue;
246 
247             iterator()
248                 : m_collection(nullptr)
249                 , m_index(0)
250             {
251             }
252 
253             iterator(const ConstrainedValueCollection&amp; collection, unsigned index)
254                 : m_collection(&amp;collection)
255                 , m_index(index)
256             {
257             }
258 
259             ConstrainedValue operator*() const
260             {
261                 return m_collection-&gt;at(m_index);
262             }
263 
264             iterator&amp; operator++()
265             {
266                 m_index++;
267                 return *this;
268             }
269 
270             bool operator==(const iterator&amp; other) const
271             {
272                 ASSERT(m_collection == other.m_collection);
273                 return m_index == other.m_index;
274             }
275 
276             bool operator!=(const iterator&amp; other) const
277             {
278                 return !(*this == other);
279             }
280 
281         private:
282             const ConstrainedValueCollection* m_collection;
283             unsigned m_index;
284         };
285 
286         iterator begin() const { return iterator(*this, 0); }
287         iterator end() const { return iterator(*this, size()); }
288 
289     private:
290         const StackmapValue&amp; m_value;
291     };
292 
293     ConstrainedValueCollection constrainedChildren() const
294     {
295         return ConstrainedValueCollection(*this);
296     }
297 
298     B3_SPECIALIZE_VALUE_FOR_VARARGS_CHILDREN
299 
300 protected:
301     void dumpChildren(CommaPrinter&amp;, PrintStream&amp;) const override;
302     void dumpMeta(CommaPrinter&amp;, PrintStream&amp;) const override;
303 
304     StackmapValue(CheckedOpcodeTag, Kind, Type, Origin);
305 
306 private:
307     friend class CheckSpecial;
308     friend class PatchpointSpecial;
309     friend class StackmapGenerationParams;
310     friend class StackmapSpecial;
311 
312     Vector&lt;ValueRep&gt; m_reps;
313     RefPtr&lt;StackmapGenerator&gt; m_generator;
314     RegisterSet m_earlyClobbered;
315     RegisterSet m_lateClobbered;
316     RegisterSet m_usedRegisters; // Stackmaps could be further duplicated by Air, but that&#39;s unlikely, so we just merge the used registers sets if that were to happen.
317 };
318 
319 } } // namespace JSC::B3
320 
321 #endif // ENABLE(B3_JIT)
    </pre>
  </body>
</html>
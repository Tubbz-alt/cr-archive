<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/animation/KeyframeEffect.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DocumentTimeline.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="KeyframeEffect.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/animation/KeyframeEffect.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 37,24 ***</span>
<span class="line-new-header">--- 37,31 ---</span>
  #include &quot;CSSTransition.h&quot;
  #include &quot;Element.h&quot;
  #include &quot;FontCascade.h&quot;
  #include &quot;FrameView.h&quot;
  #include &quot;GeometryUtilities.h&quot;
<span class="line-added">+ #include &quot;InspectorInstrumentation.h&quot;</span>
  #include &quot;JSCompositeOperation.h&quot;
  #include &quot;JSCompositeOperationOrAuto.h&quot;
<span class="line-added">+ #include &quot;JSDOMConvert.h&quot;</span>
  #include &quot;JSKeyframeEffect.h&quot;
<span class="line-added">+ #include &quot;KeyframeEffectStack.h&quot;</span>
<span class="line-added">+ #include &quot;Logging.h&quot;</span>
  #include &quot;RenderBox.h&quot;
  #include &quot;RenderBoxModelObject.h&quot;
  #include &quot;RenderElement.h&quot;
  #include &quot;RenderStyle.h&quot;
<span class="line-added">+ #include &quot;RuntimeEnabledFeatures.h&quot;</span>
<span class="line-added">+ #include &quot;StyleAdjuster.h&quot;</span>
  #include &quot;StylePendingResources.h&quot;
  #include &quot;StyleResolver.h&quot;
  #include &quot;TimingFunction.h&quot;
  #include &quot;TranslateTransformOperation.h&quot;
  #include &quot;WillChangeData.h&quot;
  #include &lt;JavaScriptCore/Exception.h&gt;
  #include &lt;wtf/UUID.h&gt;
<span class="line-added">+ #include &lt;wtf/text/TextStream.h&gt;</span>
  
  namespace WebCore {
  using namespace JSC;
  
  static inline void invalidateElement(Element* element)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,15 ***</span>
          }
          indexOfLastKeyframeWithNonNullOffset = i;
      }
  }
  
<span class="line-modified">! static inline ExceptionOr&lt;KeyframeEffect::KeyframeLikeObject&gt; processKeyframeLikeObject(ExecState&amp; state, Strong&lt;JSObject&gt;&amp;&amp; keyframesInput, bool allowLists)</span>
  {
      // https://drafts.csswg.org/web-animations-1/#process-a-keyframe-like-object
  
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 1. Run the procedure to convert an ECMAScript value to a dictionary type [WEBIDL] with keyframe input as the ECMAScript value as follows:
      //
      //    If allow lists is true, use the following dictionary type:
<span class="line-new-header">--- 162,15 ---</span>
          }
          indexOfLastKeyframeWithNonNullOffset = i;
      }
  }
  
<span class="line-modified">! static inline ExceptionOr&lt;KeyframeEffect::KeyframeLikeObject&gt; processKeyframeLikeObject(JSGlobalObject&amp; lexicalGlobalObject, Strong&lt;JSObject&gt;&amp;&amp; keyframesInput, bool allowLists)</span>
  {
      // https://drafts.csswg.org/web-animations-1/#process-a-keyframe-like-object
  
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 1. Run the procedure to convert an ECMAScript value to a dictionary type [WEBIDL] with keyframe input as the ECMAScript value as follows:
      //
      //    If allow lists is true, use the following dictionary type:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 183,19 ***</span>
      //    };
      //
      //    Store the result of this procedure as keyframe output.
      KeyframeEffect::BasePropertyIndexedKeyframe baseProperties;
      if (allowLists)
<span class="line-modified">!         baseProperties = convert&lt;IDLDictionary&lt;KeyframeEffect::BasePropertyIndexedKeyframe&gt;&gt;(state, keyframesInput.get());</span>
      else {
<span class="line-modified">!         auto baseKeyframe = convert&lt;IDLDictionary&lt;KeyframeEffect::BaseKeyframe&gt;&gt;(state, keyframesInput.get());</span>
          if (baseKeyframe.offset)
              baseProperties.offset = baseKeyframe.offset.value();
          else
              baseProperties.offset = nullptr;
          baseProperties.easing = baseKeyframe.easing;
<span class="line-modified">!         baseProperties.composite = baseKeyframe.composite;</span>
      }
      RETURN_IF_EXCEPTION(scope, Exception { TypeError });
  
      KeyframeEffect::KeyframeLikeObject keyframeOuput;
      keyframeOuput.baseProperties = baseProperties;
<span class="line-new-header">--- 190,20 ---</span>
      //    };
      //
      //    Store the result of this procedure as keyframe output.
      KeyframeEffect::BasePropertyIndexedKeyframe baseProperties;
      if (allowLists)
<span class="line-modified">!         baseProperties = convert&lt;IDLDictionary&lt;KeyframeEffect::BasePropertyIndexedKeyframe&gt;&gt;(lexicalGlobalObject, keyframesInput.get());</span>
      else {
<span class="line-modified">!         auto baseKeyframe = convert&lt;IDLDictionary&lt;KeyframeEffect::BaseKeyframe&gt;&gt;(lexicalGlobalObject, keyframesInput.get());</span>
          if (baseKeyframe.offset)
              baseProperties.offset = baseKeyframe.offset.value();
          else
              baseProperties.offset = nullptr;
          baseProperties.easing = baseKeyframe.easing;
<span class="line-modified">!         if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCompositeOperationsEnabled())</span>
<span class="line-added">+             baseProperties.composite = baseKeyframe.composite;</span>
      }
      RETURN_IF_EXCEPTION(scope, Exception { TypeError });
  
      KeyframeEffect::KeyframeLikeObject keyframeOuput;
      keyframeOuput.baseProperties = baseProperties;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 207,11 ***</span>
      //    2. Convert each property name in animatable properties to the equivalent IDL attribute by applying the animation property
      //       name to IDL attribute name algorithm.
  
      // 3. Let input properties be the result of calling the EnumerableOwnNames operation with keyframe input as the object.
      PropertyNameArray inputProperties(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
<span class="line-modified">!     JSObject::getOwnPropertyNames(keyframesInput.get(), &amp;state, inputProperties, EnumerationMode());</span>
  
      // 4. Make up a new list animation properties that consists of all of the properties that are in both input properties and animatable
      //    properties, or which are in input properties and conform to the &lt;custom-property-name&gt; production.
      Vector&lt;JSC::Identifier&gt; animationProperties;
      size_t numberOfProperties = inputProperties.size();
<span class="line-new-header">--- 215,11 ---</span>
      //    2. Convert each property name in animatable properties to the equivalent IDL attribute by applying the animation property
      //       name to IDL attribute name algorithm.
  
      // 3. Let input properties be the result of calling the EnumerableOwnNames operation with keyframe input as the object.
      PropertyNameArray inputProperties(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
<span class="line-modified">!     JSObject::getOwnPropertyNames(keyframesInput.get(), &amp;lexicalGlobalObject, inputProperties, EnumerationMode());</span>
  
      // 4. Make up a new list animation properties that consists of all of the properties that are in both input properties and animatable
      //    properties, or which are in input properties and conform to the &lt;custom-property-name&gt; production.
      Vector&lt;JSC::Identifier&gt; animationProperties;
      size_t numberOfProperties = inputProperties.size();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 228,11 ***</span>
      // 6. For each property name in animation properties,
      size_t numberOfAnimationProperties = animationProperties.size();
      for (size_t i = 0; i &lt; numberOfAnimationProperties; ++i) {
          // 1. Let raw value be the result of calling the [[Get]] internal method on keyframe input, with property name as the property
          //    key and keyframe input as the receiver.
<span class="line-modified">!         auto rawValue = keyframesInput-&gt;get(&amp;state, animationProperties[i]);</span>
  
          // 2. Check the completion record of raw value.
          RETURN_IF_EXCEPTION(scope, Exception { TypeError });
  
          // 3. Convert raw value to a DOMString or sequence of DOMStrings property values as follows:
<span class="line-new-header">--- 236,11 ---</span>
      // 6. For each property name in animation properties,
      size_t numberOfAnimationProperties = animationProperties.size();
      for (size_t i = 0; i &lt; numberOfAnimationProperties; ++i) {
          // 1. Let raw value be the result of calling the [[Get]] internal method on keyframe input, with property name as the property
          //    key and keyframe input as the receiver.
<span class="line-modified">!         auto rawValue = keyframesInput-&gt;get(&amp;lexicalGlobalObject, animationProperties[i]);</span>
  
          // 2. Check the completion record of raw value.
          RETURN_IF_EXCEPTION(scope, Exception { TypeError });
  
          // 3. Convert raw value to a DOMString or sequence of DOMStrings property values as follows:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 241,18 ***</span>
              // If allow lists is true,
              // Let property values be the result of converting raw value to IDL type (DOMString or sequence&lt;DOMString&gt;)
              // using the procedures defined for converting an ECMAScript value to an IDL value [WEBIDL].
              // If property values is a single DOMString, replace property values with a sequence of DOMStrings with the original value of property
              // Values as the only element.
<span class="line-modified">!             if (rawValue.isString())</span>
<span class="line-modified">!                 propertyValues = { rawValue.toWTFString(&amp;state) };</span>
<span class="line-modified">!             else if (rawValue.isObject())</span>
<span class="line-modified">!                 propertyValues = convert&lt;IDLSequence&lt;IDLDOMString&gt;&gt;(state, rawValue);</span>
          } else {
              // Otherwise,
              // Let property values be the result of converting raw value to a DOMString using the procedure for converting an ECMAScript value to a DOMString.
<span class="line-modified">!             propertyValues = { convert&lt;IDLDOMString&gt;(state, rawValue) };</span>
          }
          RETURN_IF_EXCEPTION(scope, Exception { TypeError });
  
          // 4. Calculate the normalized property name as the result of applying the IDL attribute name to animation property name algorithm to property name.
          auto cssPropertyID = IDLAttributeNameToAnimationPropertyName(animationProperties[i].string());
<span class="line-new-header">--- 249,18 ---</span>
              // If allow lists is true,
              // Let property values be the result of converting raw value to IDL type (DOMString or sequence&lt;DOMString&gt;)
              // using the procedures defined for converting an ECMAScript value to an IDL value [WEBIDL].
              // If property values is a single DOMString, replace property values with a sequence of DOMStrings with the original value of property
              // Values as the only element.
<span class="line-modified">!             if (rawValue.isObject())</span>
<span class="line-modified">!                 propertyValues = convert&lt;IDLSequence&lt;IDLDOMString&gt;&gt;(lexicalGlobalObject, rawValue);</span>
<span class="line-modified">!             else</span>
<span class="line-modified">!                 propertyValues = { rawValue.toWTFString(&amp;lexicalGlobalObject) };</span>
          } else {
              // Otherwise,
              // Let property values be the result of converting raw value to a DOMString using the procedure for converting an ECMAScript value to a DOMString.
<span class="line-modified">!             propertyValues = { convert&lt;IDLDOMString&gt;(lexicalGlobalObject, rawValue) };</span>
          }
          RETURN_IF_EXCEPTION(scope, Exception { TypeError });
  
          // 4. Calculate the normalized property name as the result of applying the IDL attribute name to animation property name algorithm to property name.
          auto cssPropertyID = IDLAttributeNameToAnimationPropertyName(animationProperties[i].string());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 263,24 ***</span>
  
      // 7. Return keyframe output.
      return { WTFMove(keyframeOuput) };
  }
  
<span class="line-modified">! static inline ExceptionOr&lt;void&gt; processIterableKeyframes(ExecState&amp; state, Strong&lt;JSObject&gt;&amp;&amp; keyframesInput, JSValue method, Vector&lt;KeyframeEffect::ParsedKeyframe&gt;&amp; parsedKeyframes)</span>
  {
      // 1. Let iter be GetIterator(object, method).
<span class="line-modified">!     forEachInIterable(state, keyframesInput.get(), method, [&amp;parsedKeyframes](VM&amp; vm, ExecState&amp; state, JSValue nextValue) -&gt; ExceptionOr&lt;void&gt; {</span>
          // Steps 2 through 6 are already implemented by forEachInIterable().
          auto scope = DECLARE_THROW_SCOPE(vm);
          if (!nextValue || !nextValue.isObject()) {
<span class="line-modified">!             throwException(&amp;state, scope, JSC::Exception::create(vm, createTypeError(&amp;state)));</span>
              return { };
          }
  
          // 7. Append to processed keyframes the result of running the procedure to process a keyframe-like object passing nextItem
          // as the keyframe input and with the allow lists flag set to false.
<span class="line-modified">!         auto processKeyframeLikeObjectResult = processKeyframeLikeObject(state, Strong&lt;JSObject&gt;(vm, nextValue.toObject(&amp;state)), false);</span>
          if (processKeyframeLikeObjectResult.hasException())
              return processKeyframeLikeObjectResult.releaseException();
          auto keyframeLikeObject = processKeyframeLikeObjectResult.returnValue();
  
          KeyframeEffect::ParsedKeyframe keyframeOutput;
<span class="line-new-header">--- 271,24 ---</span>
  
      // 7. Return keyframe output.
      return { WTFMove(keyframeOuput) };
  }
  
<span class="line-modified">! static inline ExceptionOr&lt;void&gt; processIterableKeyframes(JSGlobalObject&amp; lexicalGlobalObject, Strong&lt;JSObject&gt;&amp;&amp; keyframesInput, JSValue method, Vector&lt;KeyframeEffect::ParsedKeyframe&gt;&amp; parsedKeyframes)</span>
  {
      // 1. Let iter be GetIterator(object, method).
<span class="line-modified">!     forEachInIterable(lexicalGlobalObject, keyframesInput.get(), method, [&amp;parsedKeyframes](VM&amp; vm, JSGlobalObject&amp; lexicalGlobalObject, JSValue nextValue) -&gt; ExceptionOr&lt;void&gt; {</span>
          // Steps 2 through 6 are already implemented by forEachInIterable().
          auto scope = DECLARE_THROW_SCOPE(vm);
          if (!nextValue || !nextValue.isObject()) {
<span class="line-modified">!             throwException(&amp;lexicalGlobalObject, scope, JSC::Exception::create(vm, createTypeError(&amp;lexicalGlobalObject)));</span>
              return { };
          }
  
          // 7. Append to processed keyframes the result of running the procedure to process a keyframe-like object passing nextItem
          // as the keyframe input and with the allow lists flag set to false.
<span class="line-modified">!         auto processKeyframeLikeObjectResult = processKeyframeLikeObject(lexicalGlobalObject, Strong&lt;JSObject&gt;(vm, nextValue.toObject(&amp;lexicalGlobalObject)), false);</span>
          if (processKeyframeLikeObjectResult.hasException())
              return processKeyframeLikeObjectResult.releaseException();
          auto keyframeLikeObject = processKeyframeLikeObjectResult.returnValue();
  
          KeyframeEffect::ParsedKeyframe keyframeOutput;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 297,12 ***</span>
          ASSERT(WTF::holds_alternative&lt;String&gt;(keyframeLikeObject.baseProperties.easing));
          keyframeOutput.easing = WTF::get&lt;String&gt;(keyframeLikeObject.baseProperties.easing);
  
          // When calling processKeyframeLikeObject() with the &quot;allow lists&quot; flag set to false, the only composite
          // alternatives we should expect is CompositeOperationAuto.
<span class="line-modified">!         ASSERT(WTF::holds_alternative&lt;CompositeOperationOrAuto&gt;(keyframeLikeObject.baseProperties.composite));</span>
<span class="line-modified">!         keyframeOutput.composite = WTF::get&lt;CompositeOperationOrAuto&gt;(keyframeLikeObject.baseProperties.composite);</span>
  
          for (auto&amp; propertyAndValue : keyframeLikeObject.propertiesAndValues) {
              auto cssPropertyId = propertyAndValue.property;
              // When calling processKeyframeLikeObject() with the &quot;allow lists&quot; flag set to false,
              // there should only ever be a single value for a given property.
<span class="line-new-header">--- 305,14 ---</span>
          ASSERT(WTF::holds_alternative&lt;String&gt;(keyframeLikeObject.baseProperties.easing));
          keyframeOutput.easing = WTF::get&lt;String&gt;(keyframeLikeObject.baseProperties.easing);
  
          // When calling processKeyframeLikeObject() with the &quot;allow lists&quot; flag set to false, the only composite
          // alternatives we should expect is CompositeOperationAuto.
<span class="line-modified">!         if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCompositeOperationsEnabled()) {</span>
<span class="line-modified">!             ASSERT(WTF::holds_alternative&lt;CompositeOperationOrAuto&gt;(keyframeLikeObject.baseProperties.composite));</span>
<span class="line-added">+             keyframeOutput.composite = WTF::get&lt;CompositeOperationOrAuto&gt;(keyframeLikeObject.baseProperties.composite);</span>
<span class="line-added">+         }</span>
  
          for (auto&amp; propertyAndValue : keyframeLikeObject.propertiesAndValues) {
              auto cssPropertyId = propertyAndValue.property;
              // When calling processKeyframeLikeObject() with the &quot;allow lists&quot; flag set to false,
              // there should only ever be a single value for a given property.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 318,14 ***</span>
      });
  
      return { };
  }
  
<span class="line-modified">! static inline ExceptionOr&lt;void&gt; processPropertyIndexedKeyframes(ExecState&amp; state, Strong&lt;JSObject&gt;&amp;&amp; keyframesInput, Vector&lt;KeyframeEffect::ParsedKeyframe&gt;&amp; parsedKeyframes, Vector&lt;String&gt;&amp; unusedEasings)</span>
  {
      // 1. Let property-indexed keyframe be the result of running the procedure to process a keyframe-like object passing object as the keyframe input.
<span class="line-modified">!     auto processKeyframeLikeObjectResult = processKeyframeLikeObject(state, WTFMove(keyframesInput), true);</span>
      if (processKeyframeLikeObjectResult.hasException())
          return processKeyframeLikeObjectResult.releaseException();
      auto propertyIndexedKeyframe = processKeyframeLikeObjectResult.returnValue();
  
      // 2. For each member, m, in property-indexed keyframe, perform the following steps:
<span class="line-new-header">--- 328,14 ---</span>
      });
  
      return { };
  }
  
<span class="line-modified">! static inline ExceptionOr&lt;void&gt; processPropertyIndexedKeyframes(JSGlobalObject&amp; lexicalGlobalObject, Strong&lt;JSObject&gt;&amp;&amp; keyframesInput, Vector&lt;KeyframeEffect::ParsedKeyframe&gt;&amp; parsedKeyframes, Vector&lt;String&gt;&amp; unusedEasings)</span>
  {
      // 1. Let property-indexed keyframe be the result of running the procedure to process a keyframe-like object passing object as the keyframe input.
<span class="line-modified">!     auto processKeyframeLikeObjectResult = processKeyframeLikeObject(lexicalGlobalObject, WTFMove(keyframesInput), true);</span>
      if (processKeyframeLikeObjectResult.hasException())
          return processKeyframeLikeObjectResult.releaseException();
      auto propertyIndexedKeyframe = processKeyframeLikeObjectResult.returnValue();
  
      // 2. For each member, m, in property-indexed keyframe, perform the following steps:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 433,37 ***</span>
      //     is reached.
      for (size_t i = 0; i &lt; parsedKeyframes.size(); ++i)
          parsedKeyframes[i].easing = easings[i];
  
      // 12. If the “composite” member of the property-indexed keyframe is not an empty sequence:
<span class="line-modified">!     Vector&lt;CompositeOperationOrAuto&gt; compositeModes;</span>
<span class="line-modified">!     if (WTF::holds_alternative&lt;Vector&lt;CompositeOperationOrAuto&gt;&gt;(propertyIndexedKeyframe.baseProperties.composite))</span>
<span class="line-modified">!         compositeModes = WTF::get&lt;Vector&lt;CompositeOperationOrAuto&gt;&gt;(propertyIndexedKeyframe.baseProperties.composite);</span>
<span class="line-modified">!     else if (WTF::holds_alternative&lt;CompositeOperationOrAuto&gt;(propertyIndexedKeyframe.baseProperties.composite))</span>
<span class="line-modified">!         compositeModes.append(WTF::get&lt;CompositeOperationOrAuto&gt;(propertyIndexedKeyframe.baseProperties.composite));</span>
<span class="line-modified">!     if (!compositeModes.isEmpty()) {</span>
<span class="line-modified">!         // 1. Let composite modes be a sequence of CompositeOperationOrAuto values assigned from the “composite” member of property-indexed keyframe. If that member is a single</span>
<span class="line-modified">!         //    CompositeOperationOrAuto value operation, let composite modes be a sequence of length one, with the value of the “composite” as its single item.</span>
<span class="line-modified">!         // 2. As with easings, if composite modes has fewer items than processed keyframes, repeat the elements in composite modes successively starting from the beginning of</span>
<span class="line-modified">!         //    the list until composite modes has as many items as processed keyframes.</span>
<span class="line-modified">!         if (compositeModes.size() &lt; parsedKeyframes.size()) {</span>
<span class="line-modified">!             size_t initialNumberOfCompositeModes = compositeModes.size();</span>
<span class="line-modified">!             for (i = initialNumberOfCompositeModes; i &lt; parsedKeyframes.size(); ++i)</span>
<span class="line-modified">!                 compositeModes.append(compositeModes[i % initialNumberOfCompositeModes]);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         // 3. Assign each value in composite modes that is not auto to the keyframe-specific composite operation on the keyframe with the corresponding position in processed</span>
<span class="line-modified">!         //    keyframes until the end of processed keyframes is reached.</span>
<span class="line-modified">!         for (size_t i = 0; i &lt; compositeModes.size() &amp;&amp; i &lt; parsedKeyframes.size(); ++i) {</span>
<span class="line-modified">!             if (compositeModes[i] != CompositeOperationOrAuto::Auto)</span>
<span class="line-modified">!                 parsedKeyframes[i].composite = compositeModes[i];</span>
          }
      }
  
      return { };
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;KeyframeEffect&gt;&gt; KeyframeEffect::create(ExecState&amp; state, Element* target, Strong&lt;JSObject&gt;&amp;&amp; keyframes, Optional&lt;Variant&lt;double, KeyframeEffectOptions&gt;&gt;&amp;&amp; options)</span>
  {
      auto keyframeEffect = adoptRef(*new KeyframeEffect(target));
  
      if (options) {
          OptionalEffectTiming timing;
<span class="line-new-header">--- 443,39 ---</span>
      //     is reached.
      for (size_t i = 0; i &lt; parsedKeyframes.size(); ++i)
          parsedKeyframes[i].easing = easings[i];
  
      // 12. If the “composite” member of the property-indexed keyframe is not an empty sequence:
<span class="line-modified">!     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCompositeOperationsEnabled()) {</span>
<span class="line-modified">!         Vector&lt;CompositeOperationOrAuto&gt; compositeModes;</span>
<span class="line-modified">!         if (WTF::holds_alternative&lt;Vector&lt;CompositeOperationOrAuto&gt;&gt;(propertyIndexedKeyframe.baseProperties.composite))</span>
<span class="line-modified">!             compositeModes = WTF::get&lt;Vector&lt;CompositeOperationOrAuto&gt;&gt;(propertyIndexedKeyframe.baseProperties.composite);</span>
<span class="line-modified">!         else if (WTF::holds_alternative&lt;CompositeOperationOrAuto&gt;(propertyIndexedKeyframe.baseProperties.composite))</span>
<span class="line-modified">!             compositeModes.append(WTF::get&lt;CompositeOperationOrAuto&gt;(propertyIndexedKeyframe.baseProperties.composite));</span>
<span class="line-modified">!         if (!compositeModes.isEmpty()) {</span>
<span class="line-modified">!             // 1. Let composite modes be a sequence of CompositeOperationOrAuto values assigned from the “composite” member of property-indexed keyframe. If that member is a single</span>
<span class="line-modified">!             //    CompositeOperationOrAuto value operation, let composite modes be a sequence of length one, with the value of the “composite” as its single item.</span>
<span class="line-modified">!             // 2. As with easings, if composite modes has fewer items than processed keyframes, repeat the elements in composite modes successively starting from the beginning of</span>
<span class="line-modified">!             //    the list until composite modes has as many items as processed keyframes.</span>
<span class="line-modified">!             if (compositeModes.size() &lt; parsedKeyframes.size()) {</span>
<span class="line-modified">!                 size_t initialNumberOfCompositeModes = compositeModes.size();</span>
<span class="line-modified">!                 for (i = initialNumberOfCompositeModes; i &lt; parsedKeyframes.size(); ++i)</span>
<span class="line-modified">!                     compositeModes.append(compositeModes[i % initialNumberOfCompositeModes]);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             // 3. Assign each value in composite modes that is not auto to the keyframe-specific composite operation on the keyframe with the corresponding position in processed</span>
<span class="line-modified">!             //    keyframes until the end of processed keyframes is reached.</span>
<span class="line-modified">!             for (size_t i = 0; i &lt; compositeModes.size() &amp;&amp; i &lt; parsedKeyframes.size(); ++i) {</span>
<span class="line-modified">!                 if (compositeModes[i] != CompositeOperationOrAuto::Auto)</span>
<span class="line-added">+                     parsedKeyframes[i].composite = compositeModes[i];</span>
<span class="line-added">+             }</span>
          }
      }
  
      return { };
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;KeyframeEffect&gt;&gt; KeyframeEffect::create(JSGlobalObject&amp; lexicalGlobalObject, Element* target, Strong&lt;JSObject&gt;&amp;&amp; keyframes, Optional&lt;Variant&lt;double, KeyframeEffectOptions&gt;&gt;&amp;&amp; options)</span>
  {
      auto keyframeEffect = adoptRef(*new KeyframeEffect(target));
  
      if (options) {
          OptionalEffectTiming timing;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 487,18 ***</span>
          auto updateTimingResult = keyframeEffect-&gt;updateTiming(timing);
          if (updateTimingResult.hasException())
              return updateTimingResult.releaseException();
      }
  
<span class="line-modified">!     auto processKeyframesResult = keyframeEffect-&gt;processKeyframes(state, WTFMove(keyframes));</span>
      if (processKeyframesResult.hasException())
          return processKeyframesResult.releaseException();
  
      return keyframeEffect;
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;KeyframeEffect&gt;&gt; KeyframeEffect::create(JSC::ExecState&amp;, Ref&lt;KeyframeEffect&gt;&amp;&amp; source)</span>
  {
      auto keyframeEffect = adoptRef(*new KeyframeEffect(nullptr));
      keyframeEffect-&gt;copyPropertiesFromSource(WTFMove(source));
      return keyframeEffect;
  }
<span class="line-new-header">--- 499,18 ---</span>
          auto updateTimingResult = keyframeEffect-&gt;updateTiming(timing);
          if (updateTimingResult.hasException())
              return updateTimingResult.releaseException();
      }
  
<span class="line-modified">!     auto processKeyframesResult = keyframeEffect-&gt;processKeyframes(lexicalGlobalObject, WTFMove(keyframes));</span>
      if (processKeyframesResult.hasException())
          return processKeyframesResult.releaseException();
  
      return keyframeEffect;
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;KeyframeEffect&gt;&gt; KeyframeEffect::create(JSC::JSGlobalObject&amp;, Ref&lt;KeyframeEffect&gt;&amp;&amp; source)</span>
  {
      auto keyframeEffect = adoptRef(*new KeyframeEffect(nullptr));
      keyframeEffect-&gt;copyPropertiesFromSource(WTFMove(source));
      return keyframeEffect;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 507,11 ***</span>
  {
      return adoptRef(*new KeyframeEffect(const_cast&lt;Element*&gt;(&amp;target)));
  }
  
  KeyframeEffect::KeyframeEffect(Element* target)
<span class="line-modified">!     : m_target(target)</span>
  {
  }
  
  void KeyframeEffect::copyPropertiesFromSource(Ref&lt;KeyframeEffect&gt;&amp;&amp; source)
  {
<span class="line-new-header">--- 519,11 ---</span>
  {
      return adoptRef(*new KeyframeEffect(const_cast&lt;Element*&gt;(&amp;target)));
  }
  
  KeyframeEffect::KeyframeEffect(Element* target)
<span class="line-modified">!     : m_target(makeWeakPtr(target))</span>
  {
  }
  
  void KeyframeEffect::copyPropertiesFromSource(Ref&lt;KeyframeEffect&gt;&amp;&amp; source)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 539,10 ***</span>
<span class="line-new-header">--- 551,11 ---</span>
      setDirection(source-&gt;direction());
      setIterations(source-&gt;iterations());
      setTimingFunction(source-&gt;timingFunction());
      setIterationStart(source-&gt;iterationStart());
      setIterationDuration(source-&gt;iterationDuration());
<span class="line-added">+     updateStaticTimingProperties();</span>
  
      KeyframeList keyframeList(&quot;keyframe-effect-&quot; + createCanonicalUUIDString());
      for (auto&amp; keyframe : source-&gt;m_blendingKeyframes.keyframes()) {
          KeyframeValue keyframeValue(keyframe.key(), RenderStyle::clonePtr(*keyframe.style()));
          for (auto propertyId : keyframe.properties())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 550,15 ***</span>
          keyframeList.insert(WTFMove(keyframeValue));
      }
      setBlendingKeyframes(keyframeList);
  }
  
<span class="line-modified">! Vector&lt;Strong&lt;JSObject&gt;&gt; KeyframeEffect::getKeyframes(ExecState&amp; state)</span>
  {
      // https://drafts.csswg.org/web-animations-1/#dom-keyframeeffectreadonly-getkeyframes
  
<span class="line-modified">!     auto lock = JSLockHolder { &amp;state };</span>
  
      // Since keyframes are represented by a partially open-ended dictionary type that is not currently able to be expressed with WebIDL,
      // the procedure used to prepare the result of this method is defined in prose below:
      //
      // 1. Let result be an empty sequence of objects.
<span class="line-new-header">--- 563,15 ---</span>
          keyframeList.insert(WTFMove(keyframeValue));
      }
      setBlendingKeyframes(keyframeList);
  }
  
<span class="line-modified">! Vector&lt;Strong&lt;JSObject&gt;&gt; KeyframeEffect::getKeyframes(JSGlobalObject&amp; lexicalGlobalObject)</span>
  {
      // https://drafts.csswg.org/web-animations-1/#dom-keyframeeffectreadonly-getkeyframes
  
<span class="line-modified">!     auto lock = JSLockHolder { &amp;lexicalGlobalObject };</span>
  
      // Since keyframes are represented by a partially open-ended dictionary type that is not currently able to be expressed with WebIDL,
      // the procedure used to prepare the result of this method is defined in prose below:
      //
      // 1. Let result be an empty sequence of objects.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 566,10 ***</span>
<span class="line-new-header">--- 579,11 ---</span>
  
      // 2. Let keyframes be the result of applying the procedure to compute missing keyframe offsets to the keyframes for this keyframe effect.
  
      // 3. For each keyframe in keyframes perform the following steps:
      if (is&lt;DeclarativeAnimation&gt;(animation())) {
<span class="line-added">+         auto* renderer = m_target-&gt;renderer();</span>
          auto computedStyleExtractor = ComputedStyleExtractor(m_target.get());
          for (size_t i = 0; i &lt; m_blendingKeyframes.size(); ++i) {
              // 1. Initialize a dictionary object, output keyframe, using the following definition:
              //
              // dictionary BaseComputedKeyframe {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 584,36 ***</span>
              // 2. Set offset, computedOffset, easing members of output keyframe to the respective values keyframe offset, computed keyframe offset,
              // and keyframe-specific timing function of keyframe.
              BaseComputedKeyframe computedKeyframe;
              computedKeyframe.offset = keyframe.key();
              computedKeyframe.computedOffset = keyframe.key();
<span class="line-modified">!             // For CSS transitions, there are only two keyframes and the second keyframe should always report &quot;linear&quot;. In practice, this value</span>
<span class="line-modified">!             // has no bearing since, as the last keyframe, its value will never be used.</span>
<span class="line-removed">-             computedKeyframe.easing = is&lt;CSSTransition&gt;(animation()) &amp;&amp; i == 1 ? &quot;linear&quot; : timingFunctionForKeyframeAtIndex(0)-&gt;cssText();</span>
  
<span class="line-modified">!             auto outputKeyframe = convertDictionaryToJS(state, *jsCast&lt;JSDOMGlobalObject*&gt;(state.lexicalGlobalObject()), computedKeyframe);</span>
  
              // 3. For each animation property-value pair specified on keyframe, declaration, perform the following steps:
              auto&amp; style = *keyframe.style();
              for (auto cssPropertyId : keyframe.properties()) {
                  if (cssPropertyId == CSSPropertyCustom)
                      continue;
                  // 1. Let property name be the result of applying the animation property name to IDL attribute name algorithm to the property name of declaration.
                  auto propertyName = CSSPropertyIDToIDLAttributeName(cssPropertyId);
                  // 2. Let IDL value be the result of serializing the property value of declaration by passing declaration to the algorithm to serialize a CSS value.
                  String idlValue = &quot;&quot;;
<span class="line-modified">!                 if (auto cssValue = computedStyleExtractor.valueForPropertyInStyle(style, cssPropertyId))</span>
                      idlValue = cssValue-&gt;cssText();
                  // 3. Let value be the result of converting IDL value to an ECMAScript String value.
<span class="line-modified">!                 auto value = toJS&lt;IDLDOMString&gt;(state, idlValue);</span>
                  // 4. Call the [[DefineOwnProperty]] internal method on output keyframe with property name property name,
                  //    Property Descriptor { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true, [[Value]]: value } and Boolean flag false.
<span class="line-modified">!                 JSObject::defineOwnProperty(outputKeyframe, &amp;state, AtomString(propertyName).impl(), PropertyDescriptor(value, 0), false);</span>
              }
  
              // 5. Append output keyframe to result.
<span class="line-modified">!             result.append(JSC::Strong&lt;JSC::JSObject&gt; { state.vm(), outputKeyframe });</span>
          }
      } else {
          for (size_t i = 0; i &lt; m_parsedKeyframes.size(); ++i) {
              // 1. Initialize a dictionary object, output keyframe, using the following definition:
              //
<span class="line-new-header">--- 598,35 ---</span>
              // 2. Set offset, computedOffset, easing members of output keyframe to the respective values keyframe offset, computed keyframe offset,
              // and keyframe-specific timing function of keyframe.
              BaseComputedKeyframe computedKeyframe;
              computedKeyframe.offset = keyframe.key();
              computedKeyframe.computedOffset = keyframe.key();
<span class="line-modified">!             // For CSS transitions, all keyframes should return &quot;linear&quot; since the effect&#39;s global timing function applies.</span>
<span class="line-modified">!             computedKeyframe.easing = is&lt;CSSTransition&gt;(animation()) ? &quot;linear&quot; : timingFunctionForKeyframeAtIndex(i)-&gt;cssText();</span>
  
<span class="line-modified">!             auto outputKeyframe = convertDictionaryToJS(lexicalGlobalObject, *jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject), computedKeyframe);</span>
  
              // 3. For each animation property-value pair specified on keyframe, declaration, perform the following steps:
              auto&amp; style = *keyframe.style();
              for (auto cssPropertyId : keyframe.properties()) {
                  if (cssPropertyId == CSSPropertyCustom)
                      continue;
                  // 1. Let property name be the result of applying the animation property name to IDL attribute name algorithm to the property name of declaration.
                  auto propertyName = CSSPropertyIDToIDLAttributeName(cssPropertyId);
                  // 2. Let IDL value be the result of serializing the property value of declaration by passing declaration to the algorithm to serialize a CSS value.
                  String idlValue = &quot;&quot;;
<span class="line-modified">!                 if (auto cssValue = computedStyleExtractor.valueForPropertyInStyle(style, cssPropertyId, renderer))</span>
                      idlValue = cssValue-&gt;cssText();
                  // 3. Let value be the result of converting IDL value to an ECMAScript String value.
<span class="line-modified">!                 auto value = toJS&lt;IDLDOMString&gt;(lexicalGlobalObject, idlValue);</span>
                  // 4. Call the [[DefineOwnProperty]] internal method on output keyframe with property name property name,
                  //    Property Descriptor { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true, [[Value]]: value } and Boolean flag false.
<span class="line-modified">!                 JSObject::defineOwnProperty(outputKeyframe, &amp;lexicalGlobalObject, AtomString(propertyName).impl(), PropertyDescriptor(value, 0), false);</span>
              }
  
              // 5. Append output keyframe to result.
<span class="line-modified">!             result.append(JSC::Strong&lt;JSC::JSObject&gt; { lexicalGlobalObject.vm(), outputKeyframe });</span>
          }
      } else {
          for (size_t i = 0; i &lt; m_parsedKeyframes.size(); ++i) {
              // 1. Initialize a dictionary object, output keyframe, using the following definition:
              //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 630,64 ***</span>
              // offset, keyframe-specific timing function and keyframe-specific composite operation of keyframe.
              BaseComputedKeyframe computedKeyframe;
              computedKeyframe.offset = parsedKeyframe.offset;
              computedKeyframe.computedOffset = parsedKeyframe.computedOffset;
              computedKeyframe.easing = timingFunctionForKeyframeAtIndex(i)-&gt;cssText();
<span class="line-modified">!             computedKeyframe.composite = parsedKeyframe.composite;</span>
  
<span class="line-modified">!             auto outputKeyframe = convertDictionaryToJS(state, *jsCast&lt;JSDOMGlobalObject*&gt;(state.lexicalGlobalObject()), computedKeyframe);</span>
  
              // 3. For each animation property-value pair specified on keyframe, declaration, perform the following steps:
              for (auto it = parsedKeyframe.unparsedStyle.begin(), end = parsedKeyframe.unparsedStyle.end(); it != end; ++it) {
                  // 1. Let property name be the result of applying the animation property name to IDL attribute name algorithm to the property name of declaration.
                  auto propertyName = CSSPropertyIDToIDLAttributeName(it-&gt;key);
                  // 2. Let IDL value be the result of serializing the property value of declaration by passing declaration to the algorithm to serialize a CSS value.
                  // 3. Let value be the result of converting IDL value to an ECMAScript String value.
<span class="line-modified">!                 auto value = toJS&lt;IDLDOMString&gt;(state, it-&gt;value);</span>
                  // 4. Call the [[DefineOwnProperty]] internal method on output keyframe with property name property name,
                  //    Property Descriptor { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true, [[Value]]: value } and Boolean flag false.
<span class="line-modified">!                 JSObject::defineOwnProperty(outputKeyframe, &amp;state, AtomString(propertyName).impl(), PropertyDescriptor(value, 0), false);</span>
              }
  
              // 4. Append output keyframe to result.
<span class="line-modified">!             result.append(JSC::Strong&lt;JSC::JSObject&gt; { state.vm(), outputKeyframe });</span>
          }
      }
  
      // 4. Return result.
      return result;
  }
  
<span class="line-modified">! ExceptionOr&lt;void&gt; KeyframeEffect::setKeyframes(ExecState&amp; state, Strong&lt;JSObject&gt;&amp;&amp; keyframesInput)</span>
  {
<span class="line-modified">!     return processKeyframes(state, WTFMove(keyframesInput));</span>
  }
  
<span class="line-modified">! ExceptionOr&lt;void&gt; KeyframeEffect::processKeyframes(ExecState&amp; state, Strong&lt;JSObject&gt;&amp;&amp; keyframesInput)</span>
  {
      // 1. If object is null, return an empty sequence of keyframes.
      if (!keyframesInput.get())
          return { };
  
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 2. Let processed keyframes be an empty sequence of keyframes.
      Vector&lt;ParsedKeyframe&gt; parsedKeyframes;
  
      // 3. Let method be the result of GetMethod(object, @@iterator).
<span class="line-modified">!     auto method = keyframesInput.get()-&gt;get(&amp;state, vm.propertyNames-&gt;iteratorSymbol);</span>
  
      // 4. Check the completion record of method.
      RETURN_IF_EXCEPTION(scope, Exception { TypeError });
  
      // 5. Perform the steps corresponding to the first matching condition from below,
      Vector&lt;String&gt; unusedEasings;
      if (!method.isUndefined())
<span class="line-modified">!         processIterableKeyframes(state, WTFMove(keyframesInput), WTFMove(method), parsedKeyframes);</span>
      else
<span class="line-modified">!         processPropertyIndexedKeyframes(state, WTFMove(keyframesInput), parsedKeyframes, unusedEasings);</span>
  
      // 6. If processed keyframes is not loosely sorted by offset, throw a TypeError and abort these steps.
      // 7. If there exist any keyframe in processed keyframes whose keyframe offset is non-null and less than
      //    zero or greater than one, throw a TypeError and abort these steps.
      double lastNonNullOffset = -1;
<span class="line-new-header">--- 643,68 ---</span>
              // offset, keyframe-specific timing function and keyframe-specific composite operation of keyframe.
              BaseComputedKeyframe computedKeyframe;
              computedKeyframe.offset = parsedKeyframe.offset;
              computedKeyframe.computedOffset = parsedKeyframe.computedOffset;
              computedKeyframe.easing = timingFunctionForKeyframeAtIndex(i)-&gt;cssText();
<span class="line-modified">!             if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCompositeOperationsEnabled())</span>
<span class="line-added">+                 computedKeyframe.composite = parsedKeyframe.composite;</span>
  
<span class="line-modified">!             auto outputKeyframe = convertDictionaryToJS(lexicalGlobalObject, *jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject), computedKeyframe);</span>
  
              // 3. For each animation property-value pair specified on keyframe, declaration, perform the following steps:
              for (auto it = parsedKeyframe.unparsedStyle.begin(), end = parsedKeyframe.unparsedStyle.end(); it != end; ++it) {
                  // 1. Let property name be the result of applying the animation property name to IDL attribute name algorithm to the property name of declaration.
                  auto propertyName = CSSPropertyIDToIDLAttributeName(it-&gt;key);
                  // 2. Let IDL value be the result of serializing the property value of declaration by passing declaration to the algorithm to serialize a CSS value.
                  // 3. Let value be the result of converting IDL value to an ECMAScript String value.
<span class="line-modified">!                 auto value = toJS&lt;IDLDOMString&gt;(lexicalGlobalObject, it-&gt;value);</span>
                  // 4. Call the [[DefineOwnProperty]] internal method on output keyframe with property name property name,
                  //    Property Descriptor { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true, [[Value]]: value } and Boolean flag false.
<span class="line-modified">!                 JSObject::defineOwnProperty(outputKeyframe, &amp;lexicalGlobalObject, AtomString(propertyName).impl(), PropertyDescriptor(value, 0), false);</span>
              }
  
              // 4. Append output keyframe to result.
<span class="line-modified">!             result.append(JSC::Strong&lt;JSC::JSObject&gt; { lexicalGlobalObject.vm(), outputKeyframe });</span>
          }
      }
  
      // 4. Return result.
      return result;
  }
  
<span class="line-modified">! ExceptionOr&lt;void&gt; KeyframeEffect::setKeyframes(JSGlobalObject&amp; lexicalGlobalObject, Strong&lt;JSObject&gt;&amp;&amp; keyframesInput)</span>
  {
<span class="line-modified">!     auto processKeyframesResult = processKeyframes(lexicalGlobalObject, WTFMove(keyframesInput));</span>
<span class="line-added">+     if (!processKeyframesResult.hasException() &amp;&amp; animation())</span>
<span class="line-added">+         animation()-&gt;effectTimingDidChange();</span>
<span class="line-added">+     return processKeyframesResult;</span>
  }
  
<span class="line-modified">! ExceptionOr&lt;void&gt; KeyframeEffect::processKeyframes(JSGlobalObject&amp; lexicalGlobalObject, Strong&lt;JSObject&gt;&amp;&amp; keyframesInput)</span>
  {
      // 1. If object is null, return an empty sequence of keyframes.
      if (!keyframesInput.get())
          return { };
  
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 2. Let processed keyframes be an empty sequence of keyframes.
      Vector&lt;ParsedKeyframe&gt; parsedKeyframes;
  
      // 3. Let method be the result of GetMethod(object, @@iterator).
<span class="line-modified">!     auto method = keyframesInput.get()-&gt;get(&amp;lexicalGlobalObject, vm.propertyNames-&gt;iteratorSymbol);</span>
  
      // 4. Check the completion record of method.
      RETURN_IF_EXCEPTION(scope, Exception { TypeError });
  
      // 5. Perform the steps corresponding to the first matching condition from below,
      Vector&lt;String&gt; unusedEasings;
      if (!method.isUndefined())
<span class="line-modified">!         processIterableKeyframes(lexicalGlobalObject, WTFMove(keyframesInput), WTFMove(method), parsedKeyframes);</span>
      else
<span class="line-modified">!         processPropertyIndexedKeyframes(lexicalGlobalObject, WTFMove(keyframesInput), parsedKeyframes, unusedEasings);</span>
  
      // 6. If processed keyframes is not loosely sorted by offset, throw a TypeError and abort these steps.
      // 7. If there exist any keyframe in processed keyframes whose keyframe offset is non-null and less than
      //    zero or greater than one, throw a TypeError and abort these steps.
      double lastNonNullOffset = -1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 724,39 ***</span>
              return timingFunctionResult.releaseException();
      }
  
      m_parsedKeyframes = WTFMove(parsedKeyframes);
  
<span class="line-modified">!     m_blendingKeyframes.clear();</span>
  
      return { };
  }
  
  void KeyframeEffect::updateBlendingKeyframes(RenderStyle&amp; elementStyle)
  {
      if (!m_blendingKeyframes.isEmpty() || !m_target)
          return;
  
      KeyframeList keyframeList(&quot;keyframe-effect-&quot; + createCanonicalUUIDString());
<span class="line-modified">!     StyleResolver&amp; styleResolver = m_target-&gt;styleResolver();</span>
  
      for (auto&amp; keyframe : m_parsedKeyframes) {
<span class="line-removed">-         styleResolver.setNewStateWithElement(*m_target);</span>
          KeyframeValue keyframeValue(keyframe.computedOffset, nullptr);
  
          auto styleProperties = keyframe.style-&gt;immutableCopyIfNeeded();
          for (unsigned i = 0; i &lt; styleProperties-&gt;propertyCount(); ++i)
              keyframeList.addProperty(styleProperties-&gt;propertyAt(i).id());
  
          auto keyframeRule = StyleRuleKeyframe::create(WTFMove(styleProperties));
<span class="line-modified">!         keyframeValue.setStyle(styleResolver.styleForKeyframe(&amp;elementStyle, keyframeRule.ptr(), keyframeValue));</span>
          keyframeList.insert(WTFMove(keyframeValue));
      }
  
      setBlendingKeyframes(keyframeList);
  }
  
  bool KeyframeEffect::forceLayoutIfNeeded()
  {
      if (!m_needsForcedLayout || !m_target)
          return false;
  
<span class="line-new-header">--- 741,52 ---</span>
              return timingFunctionResult.releaseException();
      }
  
      m_parsedKeyframes = WTFMove(parsedKeyframes);
  
<span class="line-modified">!     clearBlendingKeyframes();</span>
  
      return { };
  }
  
  void KeyframeEffect::updateBlendingKeyframes(RenderStyle&amp; elementStyle)
  {
      if (!m_blendingKeyframes.isEmpty() || !m_target)
          return;
  
      KeyframeList keyframeList(&quot;keyframe-effect-&quot; + createCanonicalUUIDString());
<span class="line-modified">!     auto&amp; styleResolver = m_target-&gt;styleResolver();</span>
  
      for (auto&amp; keyframe : m_parsedKeyframes) {
          KeyframeValue keyframeValue(keyframe.computedOffset, nullptr);
  
          auto styleProperties = keyframe.style-&gt;immutableCopyIfNeeded();
          for (unsigned i = 0; i &lt; styleProperties-&gt;propertyCount(); ++i)
              keyframeList.addProperty(styleProperties-&gt;propertyAt(i).id());
  
          auto keyframeRule = StyleRuleKeyframe::create(WTFMove(styleProperties));
<span class="line-modified">!         keyframeValue.setStyle(styleResolver.styleForKeyframe(*m_target, &amp;elementStyle, keyframeRule.ptr(), keyframeValue));</span>
          keyframeList.insert(WTFMove(keyframeValue));
      }
  
      setBlendingKeyframes(keyframeList);
  }
  
<span class="line-added">+ bool KeyframeEffect::animatesProperty(CSSPropertyID property) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!m_blendingKeyframes.isEmpty())</span>
<span class="line-added">+         return m_blendingKeyframes.properties().contains(property);</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (auto&amp; keyframe : m_parsedKeyframes) {</span>
<span class="line-added">+         for (auto keyframeProperty : keyframe.unparsedStyle.keys()) {</span>
<span class="line-added">+             if (keyframeProperty == property)</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool KeyframeEffect::forceLayoutIfNeeded()
  {
      if (!m_needsForcedLayout || !m_target)
          return false;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 770,17 ***</span>
  
      frameView-&gt;forceLayout();
      return true;
  }
  
  void KeyframeEffect::setBlendingKeyframes(KeyframeList&amp; blendingKeyframes)
  {
      m_blendingKeyframes = WTFMove(blendingKeyframes);
  
      computedNeedsForcedLayout();
      computeStackingContextImpact();
<span class="line-modified">!     computeShouldRunAccelerated();</span>
  
      checkForMatchingTransformFunctionLists();
      checkForMatchingFilterFunctionLists();
  #if ENABLE(FILTERS_LEVEL_2)
      checkForMatchingBackdropFilterFunctionLists();
<span class="line-new-header">--- 800,25 ---</span>
  
      frameView-&gt;forceLayout();
      return true;
  }
  
<span class="line-added">+ </span>
<span class="line-added">+ void KeyframeEffect::clearBlendingKeyframes()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_blendingKeyframesSource = BlendingKeyframesSource::WebAnimation;</span>
<span class="line-added">+     m_unanimatedStyle = nullptr;</span>
<span class="line-added">+     m_blendingKeyframes.clear();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void KeyframeEffect::setBlendingKeyframes(KeyframeList&amp; blendingKeyframes)
  {
      m_blendingKeyframes = WTFMove(blendingKeyframes);
  
      computedNeedsForcedLayout();
      computeStackingContextImpact();
<span class="line-modified">!     computeAcceleratedPropertiesState();</span>
  
      checkForMatchingTransformFunctionLists();
      checkForMatchingFilterFunctionLists();
  #if ENABLE(FILTERS_LEVEL_2)
      checkForMatchingBackdropFilterFunctionLists();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 885,32 ***</span>
  
  void KeyframeEffect::computeDeclarativeAnimationBlendingKeyframes(const RenderStyle* oldStyle, const RenderStyle&amp; newStyle)
  {
      ASSERT(is&lt;DeclarativeAnimation&gt;(animation()));
      if (is&lt;CSSAnimation&gt;(animation()))
<span class="line-modified">!         computeCSSAnimationBlendingKeyframes();</span>
      else if (is&lt;CSSTransition&gt;(animation()))
          computeCSSTransitionBlendingKeyframes(oldStyle, newStyle);
  }
  
<span class="line-modified">! void KeyframeEffect::computeCSSAnimationBlendingKeyframes()</span>
  {
      ASSERT(is&lt;CSSAnimation&gt;(animation()));
  
      auto cssAnimation = downcast&lt;CSSAnimation&gt;(animation());
      auto&amp; backingAnimation = cssAnimation-&gt;backingAnimation();
  
      KeyframeList keyframeList(backingAnimation.name());
      if (auto* styleScope = Style::Scope::forOrdinal(*m_target, backingAnimation.nameStyleScopeOrdinal()))
<span class="line-modified">!         styleScope-&gt;resolver().keyframeStylesForAnimation(*m_target, &amp;cssAnimation-&gt;unanimatedStyle(), keyframeList);</span>
  
      // Ensure resource loads for all the frames.
      for (auto&amp; keyframe : keyframeList.keyframes()) {
          if (auto* style = const_cast&lt;RenderStyle*&gt;(keyframe.style()))
              Style::loadPendingResources(*style, m_target-&gt;document(), m_target.get());
      }
  
      setBlendingKeyframes(keyframeList);
  }
  
  void KeyframeEffect::computeCSSTransitionBlendingKeyframes(const RenderStyle* oldStyle, const RenderStyle&amp; newStyle)
  {
<span class="line-new-header">--- 923,33 ---</span>
  
  void KeyframeEffect::computeDeclarativeAnimationBlendingKeyframes(const RenderStyle* oldStyle, const RenderStyle&amp; newStyle)
  {
      ASSERT(is&lt;DeclarativeAnimation&gt;(animation()));
      if (is&lt;CSSAnimation&gt;(animation()))
<span class="line-modified">!         computeCSSAnimationBlendingKeyframes(newStyle);</span>
      else if (is&lt;CSSTransition&gt;(animation()))
          computeCSSTransitionBlendingKeyframes(oldStyle, newStyle);
  }
  
<span class="line-modified">! void KeyframeEffect::computeCSSAnimationBlendingKeyframes(const RenderStyle&amp; unanimatedStyle)</span>
  {
      ASSERT(is&lt;CSSAnimation&gt;(animation()));
  
      auto cssAnimation = downcast&lt;CSSAnimation&gt;(animation());
      auto&amp; backingAnimation = cssAnimation-&gt;backingAnimation();
  
      KeyframeList keyframeList(backingAnimation.name());
      if (auto* styleScope = Style::Scope::forOrdinal(*m_target, backingAnimation.nameStyleScopeOrdinal()))
<span class="line-modified">!         styleScope-&gt;resolver().keyframeStylesForAnimation(*m_target, &amp;unanimatedStyle, keyframeList);</span>
  
      // Ensure resource loads for all the frames.
      for (auto&amp; keyframe : keyframeList.keyframes()) {
          if (auto* style = const_cast&lt;RenderStyle*&gt;(keyframe.style()))
              Style::loadPendingResources(*style, m_target-&gt;document(), m_target.get());
      }
  
<span class="line-added">+     m_blendingKeyframesSource = BlendingKeyframesSource::CSSAnimation;</span>
      setBlendingKeyframes(keyframeList);
  }
  
  void KeyframeEffect::computeCSSTransitionBlendingKeyframes(const RenderStyle* oldStyle, const RenderStyle&amp; newStyle)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 934,10 ***</span>
<span class="line-new-header">--- 973,11 ---</span>
  
      KeyframeValue toKeyframeValue(1, WTFMove(toStyle));
      toKeyframeValue.addProperty(property);
      keyframeList.insert(WTFMove(toKeyframeValue));
  
<span class="line-added">+     m_blendingKeyframesSource = BlendingKeyframesSource::CSSTransition;</span>
      setBlendingKeyframes(keyframeList);
  }
  
  void KeyframeEffect::computedNeedsForcedLayout()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 976,75 ***</span>
              break;
          }
      }
  }
  
  void KeyframeEffect::setTarget(RefPtr&lt;Element&gt;&amp;&amp; newTarget)
  {
<span class="line-modified">!     if (m_target == newTarget)</span>
          return;
  
<span class="line-modified">!     auto previousTarget = std::exchange(m_target, WTFMove(newTarget));</span>
  
      if (auto* effectAnimation = animation())
          effectAnimation-&gt;effectTargetDidChange(previousTarget.get(), m_target.get());
  
<span class="line-modified">!     m_blendingKeyframes.clear();</span>
  
      // We need to invalidate the effect now that the target has changed
      // to ensure the effect&#39;s styles are applied to the new target right away.
      invalidate();
  
      // Likewise, we need to invalidate styles on the previous target so that
      // any animated styles are removed immediately.
      invalidateElement(previousTarget.get());
  }
  
  void KeyframeEffect::apply(RenderStyle&amp; targetStyle)
  {
      if (!m_target)
          return;
  
      updateBlendingKeyframes(targetStyle);
  
<span class="line-modified">!     updateAcceleratedAnimationState();</span>
  
<span class="line-modified">!     auto progress = getComputedTiming().progress;</span>
<span class="line-modified">!     if (!progress)</span>
          return;
  
<span class="line-modified">!     setAnimatedPropertiesInStyle(targetStyle, progress.value());</span>
  
<span class="line-modified">!     // https://w3c.github.io/web-animations/#side-effects-section</span>
<span class="line-modified">!     // For every property targeted by at least one animation effect that is current or in effect, the user agent</span>
<span class="line-modified">!     // must act as if the will-change property ([css-will-change-1]) on the target element includes the property.</span>
<span class="line-modified">!     if (m_triggersStackingContext &amp;&amp; targetStyle.hasAutoZIndex())</span>
<span class="line-modified">!         targetStyle.setZIndex(0);</span>
  }
  
  void KeyframeEffect::invalidate()
  {
      invalidateElement(m_target.get());
  }
  
<span class="line-modified">! void KeyframeEffect::computeShouldRunAccelerated()</span>
  {
<span class="line-modified">!     m_shouldRunAccelerated = hasBlendingKeyframes();</span>
      for (auto cssPropertyId : m_blendingKeyframes.properties()) {
<span class="line-modified">!         if (!CSSPropertyAnimation::animationOfPropertyIsAccelerated(cssPropertyId)) {</span>
<span class="line-modified">!             m_shouldRunAccelerated = false;</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
      }
  }
  
  void KeyframeEffect::getAnimatedStyle(std::unique_ptr&lt;RenderStyle&gt;&amp; animatedStyle)
  {
      if (!m_target || !animation())
          return;
  
      auto progress = getComputedTiming().progress;
      if (!progress)
          return;
  
      if (!animatedStyle)
          animatedStyle = RenderStyle::clonePtr(renderer()-&gt;style());
<span class="line-new-header">--- 1016,155 ---</span>
              break;
          }
      }
  }
  
<span class="line-added">+ void KeyframeEffect::animationTimelineDidChange(AnimationTimeline* timeline)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!m_target)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (timeline)</span>
<span class="line-added">+         m_inTargetEffectStack = m_target-&gt;ensureKeyframeEffectStack().addEffect(*this);</span>
<span class="line-added">+     else {</span>
<span class="line-added">+         m_target-&gt;ensureKeyframeEffectStack().removeEffect(*this);</span>
<span class="line-added">+         m_inTargetEffectStack = false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void KeyframeEffect::animationTimingDidChange()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     updateEffectStackMembership();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void KeyframeEffect::updateEffectStackMembership()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!m_target)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool isRelevant = animation() &amp;&amp; animation()-&gt;isRelevant();</span>
<span class="line-added">+     if (isRelevant &amp;&amp; !m_inTargetEffectStack)</span>
<span class="line-added">+         m_inTargetEffectStack = m_target-&gt;ensureKeyframeEffectStack().addEffect(*this);</span>
<span class="line-added">+     else if (!isRelevant &amp;&amp; m_inTargetEffectStack) {</span>
<span class="line-added">+         m_target-&gt;ensureKeyframeEffectStack().removeEffect(*this);</span>
<span class="line-added">+         m_inTargetEffectStack = false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void KeyframeEffect::setAnimation(WebAnimation* animation)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     bool animationChanged = animation != this-&gt;animation();</span>
<span class="line-added">+     AnimationEffect::setAnimation(animation);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!animationChanged)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (animation)</span>
<span class="line-added">+         animation-&gt;updateRelevance();</span>
<span class="line-added">+     updateEffectStackMembership();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void KeyframeEffect::setTarget(RefPtr&lt;Element&gt;&amp;&amp; newTarget)
  {
<span class="line-modified">!     if (m_target.get() == newTarget.get())</span>
          return;
  
<span class="line-modified">!     auto previousTarget = std::exchange(m_target, makeWeakPtr(newTarget.get()));</span>
  
      if (auto* effectAnimation = animation())
          effectAnimation-&gt;effectTargetDidChange(previousTarget.get(), m_target.get());
  
<span class="line-modified">!     clearBlendingKeyframes();</span>
  
      // We need to invalidate the effect now that the target has changed
      // to ensure the effect&#39;s styles are applied to the new target right away.
      invalidate();
  
      // Likewise, we need to invalidate styles on the previous target so that
      // any animated styles are removed immediately.
      invalidateElement(previousTarget.get());
<span class="line-added">+ </span>
<span class="line-added">+     if (previousTarget) {</span>
<span class="line-added">+         previousTarget-&gt;ensureKeyframeEffectStack().removeEffect(*this);</span>
<span class="line-added">+         m_inTargetEffectStack = false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (m_target)</span>
<span class="line-added">+         m_inTargetEffectStack = m_target-&gt;ensureKeyframeEffectStack().addEffect(*this);</span>
  }
  
  void KeyframeEffect::apply(RenderStyle&amp; targetStyle)
  {
      if (!m_target)
          return;
  
      updateBlendingKeyframes(targetStyle);
  
<span class="line-modified">!     auto computedTiming = getComputedTiming();</span>
<span class="line-added">+     m_phaseAtLastApplication = computedTiming.phase;</span>
  
<span class="line-modified">!     InspectorInstrumentation::willApplyKeyframeEffect(*m_target, *this, computedTiming);</span>
<span class="line-modified">! </span>
<span class="line-added">+     if (!computedTiming.progress)</span>
          return;
  
<span class="line-modified">!     if (!m_unanimatedStyle)</span>
<span class="line-added">+         m_unanimatedStyle = RenderStyle::clonePtr(targetStyle);</span>
<span class="line-added">+ </span>
<span class="line-added">+     setAnimatedPropertiesInStyle(targetStyle, computedTiming.progress.value());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool KeyframeEffect::isCurrentlyAffectingProperty(CSSPropertyID property, Accelerated accelerated) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (accelerated == Accelerated::Yes &amp;&amp; !isRunningAccelerated() &amp;&amp; !isAboutToRunAccelerated())</span>
<span class="line-added">+         return false;</span>
  
<span class="line-modified">!     if (!m_blendingKeyframes.properties().contains(property))</span>
<span class="line-modified">!         return false;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     return m_phaseAtLastApplication == AnimationEffectPhase::Active;</span>
<span class="line-modified">! }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool KeyframeEffect::isRunningAcceleratedAnimationForProperty(CSSPropertyID property) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return m_isRunningAccelerated &amp;&amp; CSSPropertyAnimation::animationOfPropertyIsAccelerated(property) &amp;&amp; m_blendingKeyframes.properties().contains(property);</span>
  }
  
  void KeyframeEffect::invalidate()
  {
      invalidateElement(m_target.get());
  }
  
<span class="line-modified">! void KeyframeEffect::computeAcceleratedPropertiesState()</span>
  {
<span class="line-modified">!     bool hasSomeAcceleratedProperties = false;</span>
<span class="line-added">+     bool hasSomeUnacceleratedProperties = false;</span>
<span class="line-added">+ </span>
      for (auto cssPropertyId : m_blendingKeyframes.properties()) {
<span class="line-modified">!         // If any animated property can be accelerated, then the animation should run accelerated.</span>
<span class="line-modified">!         if (CSSPropertyAnimation::animationOfPropertyIsAccelerated(cssPropertyId))</span>
<span class="line-modified">!             hasSomeAcceleratedProperties = true;</span>
<span class="line-modified">!         else</span>
<span class="line-added">+             hasSomeUnacceleratedProperties = true;</span>
<span class="line-added">+         if (hasSomeAcceleratedProperties &amp;&amp; hasSomeUnacceleratedProperties)</span>
<span class="line-added">+             break;</span>
      }
<span class="line-added">+ </span>
<span class="line-added">+     if (!hasSomeAcceleratedProperties)</span>
<span class="line-added">+         m_acceleratedPropertiesState = AcceleratedProperties::None;</span>
<span class="line-added">+     else if (hasSomeUnacceleratedProperties)</span>
<span class="line-added">+         m_acceleratedPropertiesState = AcceleratedProperties::Some;</span>
<span class="line-added">+     else</span>
<span class="line-added">+         m_acceleratedPropertiesState = AcceleratedProperties::All;</span>
  }
  
  void KeyframeEffect::getAnimatedStyle(std::unique_ptr&lt;RenderStyle&gt;&amp; animatedStyle)
  {
      if (!m_target || !animation())
          return;
  
      auto progress = getComputedTiming().progress;
<span class="line-added">+     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;KeyframeEffect &quot; &lt;&lt; this &lt;&lt; &quot; getAnimatedStyle - progress &quot; &lt;&lt; progress);</span>
      if (!progress)
          return;
  
      if (!animatedStyle)
          animatedStyle = RenderStyle::clonePtr(renderer()-&gt;style());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1052,23 ***</span>
      setAnimatedPropertiesInStyle(*animatedStyle.get(), progress.value());
  }
  
  void KeyframeEffect::setAnimatedPropertiesInStyle(RenderStyle&amp; targetStyle, double iterationProgress)
  {
      // 4.4.3. The effect value of a keyframe effect
      // https://drafts.csswg.org/web-animations-1/#the-effect-value-of-a-keyframe-animation-effect
      //
      // The effect value of a single property referenced by a keyframe effect as one of its target properties,
      // for a given iteration progress, current iteration and underlying value is calculated as follows.
  
      updateBlendingKeyframes(targetStyle);
      if (m_blendingKeyframes.isEmpty())
          return;
  
<span class="line-modified">!     bool isCSSAnimation = is&lt;CSSAnimation&gt;(animation());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     for (auto cssPropertyId : m_blendingKeyframes.properties()) {</span>
          // 1. If iteration progress is unresolved abort this procedure.
          // 2. Let target property be the longhand property for which the effect value is to be calculated.
          // 3. If animation type of the target property is not animatable abort this procedure since the effect cannot be applied.
          // 4. Define the neutral value for composition as a value which, when combined with an underlying value using the add composite operation,
          //    produces the underlying value.
<span class="line-new-header">--- 1172,32 ---</span>
      setAnimatedPropertiesInStyle(*animatedStyle.get(), progress.value());
  }
  
  void KeyframeEffect::setAnimatedPropertiesInStyle(RenderStyle&amp; targetStyle, double iterationProgress)
  {
<span class="line-added">+     auto&amp; properties = m_blendingKeyframes.properties();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // In the case of CSS Transitions we already know that there are only two keyframes, one where offset=0 and one where offset=1,</span>
<span class="line-added">+     // and only a single CSS property so we can simply blend based on the style available on those keyframes with the provided iteration</span>
<span class="line-added">+     // progress which already accounts for the transition&#39;s timing function.</span>
<span class="line-added">+     if (m_blendingKeyframesSource == BlendingKeyframesSource::CSSTransition) {</span>
<span class="line-added">+         ASSERT(properties.size() == 1);</span>
<span class="line-added">+         CSSPropertyAnimation::blendProperties(this, *properties.begin(), &amp;targetStyle, m_blendingKeyframes[0].style(), m_blendingKeyframes[1].style(), iterationProgress);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      // 4.4.3. The effect value of a keyframe effect
      // https://drafts.csswg.org/web-animations-1/#the-effect-value-of-a-keyframe-animation-effect
      //
      // The effect value of a single property referenced by a keyframe effect as one of its target properties,
      // for a given iteration progress, current iteration and underlying value is calculated as follows.
  
      updateBlendingKeyframes(targetStyle);
      if (m_blendingKeyframes.isEmpty())
          return;
  
<span class="line-modified">!     for (auto cssPropertyId : properties) {</span>
          // 1. If iteration progress is unresolved abort this procedure.
          // 2. Let target property be the longhand property for which the effect value is to be calculated.
          // 3. If animation type of the target property is not animatable abort this procedure since the effect cannot be applied.
          // 4. Define the neutral value for composition as a value which, when combined with an underlying value using the add composite operation,
          //    produces the underlying value.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1082,11 ***</span>
              auto&amp; keyframe = m_blendingKeyframes[i];
              auto offset = keyframe.key();
              if (!keyframe.containsProperty(cssPropertyId)) {
                  // If we&#39;re dealing with a CSS animation, we consider the first and last keyframes to always have the property listed
                  // since the underlying style was provided and should be captured.
<span class="line-modified">!                 if (!isCSSAnimation || (offset &amp;&amp; offset &lt; 1))</span>
                      continue;
              }
              if (!offset)
                  numberOfKeyframesWithZeroOffset++;
              if (offset == 1)
<span class="line-new-header">--- 1211,11 ---</span>
              auto&amp; keyframe = m_blendingKeyframes[i];
              auto offset = keyframe.key();
              if (!keyframe.containsProperty(cssPropertyId)) {
                  // If we&#39;re dealing with a CSS animation, we consider the first and last keyframes to always have the property listed
                  // since the underlying style was provided and should be captured.
<span class="line-modified">!                 if (m_blendingKeyframesSource == BlendingKeyframesSource::WebAnimation || (offset &amp;&amp; offset &lt; 1))</span>
                      continue;
              }
              if (!offset)
                  numberOfKeyframesWithZeroOffset++;
              if (offset == 1)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1219,80 ***</span>
      }
  
      return nullptr;
  }
  
<span class="line-modified">! void KeyframeEffect::updateAcceleratedAnimationState()</span>
  {
<span class="line-modified">!     if (!m_shouldRunAccelerated)</span>
          return;
  
<span class="line-modified">!     if (!renderer()) {</span>
<span class="line-modified">!         if (isRunningAccelerated())</span>
<span class="line-modified">!             addPendingAcceleratedAction(AcceleratedAction::Stop);</span>
          return;
      }
  
<span class="line-modified">!     auto localTime = animation()-&gt;currentTime();</span>
<span class="line-modified">! </span>
<span class="line-modified">!     // If we don&#39;t have a localTime or localTime &lt; 0, we either don&#39;t have a start time or we&#39;re before the startTime</span>
<span class="line-removed">-     // so we shouldn&#39;t be running.</span>
<span class="line-removed">-     if (!localTime || localTime.value() &lt; 0_s) {</span>
<span class="line-removed">-         if (isRunningAccelerated())</span>
<span class="line-removed">-             addPendingAcceleratedAction(AcceleratedAction::Stop);</span>
          return;
      }
  
      auto playState = animation()-&gt;playState();
      if (playState == WebAnimation::PlayState::Paused) {
          if (m_lastRecordedAcceleratedAction != AcceleratedAction::Pause) {
              if (m_lastRecordedAcceleratedAction == AcceleratedAction::Stop)
                  addPendingAcceleratedAction(AcceleratedAction::Play);
              addPendingAcceleratedAction(AcceleratedAction::Pause);
          }
<span class="line-modified">!         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (playState == WebAnimation::PlayState::Finished) {</span>
<span class="line-removed">-         if (isRunningAccelerated())</span>
<span class="line-removed">-             addPendingAcceleratedAction(AcceleratedAction::Stop);</span>
<span class="line-removed">-         else {</span>
<span class="line-removed">-             m_lastRecordedAcceleratedAction = AcceleratedAction::Stop;</span>
<span class="line-removed">-             m_pendingAcceleratedActions.clear();</span>
<span class="line-removed">-             animation()-&gt;acceleratedStateDidChange();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (playState == WebAnimation::PlayState::Running &amp;&amp; localTime &gt;= 0_s) {</span>
          if (m_lastRecordedAcceleratedAction != AcceleratedAction::Play)
              addPendingAcceleratedAction(AcceleratedAction::Play);
<span class="line-removed">-         return;</span>
      }
  }
  
  void KeyframeEffect::addPendingAcceleratedAction(AcceleratedAction action)
  {
      if (action == AcceleratedAction::Stop)
          m_pendingAcceleratedActions.clear();
      m_pendingAcceleratedActions.append(action);
      if (action != AcceleratedAction::Seek)
          m_lastRecordedAcceleratedAction = action;
      animation()-&gt;acceleratedStateDidChange();
  }
  
  void KeyframeEffect::animationDidSeek()
  {
      // There is no need to seek if we&#39;re not playing an animation already. If seeking
<span class="line-modified">!     // means we&#39;re moving into an active state, we&#39;ll pick this up in apply().</span>
<span class="line-modified">!     if (m_shouldRunAccelerated &amp;&amp; isRunningAccelerated())</span>
          addPendingAcceleratedAction(AcceleratedAction::Seek);
  }
  
  void KeyframeEffect::animationSuspensionStateDidChange(bool animationIsSuspended)
  {
<span class="line-modified">!     if (m_shouldRunAccelerated)</span>
          addPendingAcceleratedAction(animationIsSuspended ? AcceleratedAction::Pause : AcceleratedAction::Play);
  }
  
  void KeyframeEffect::applyPendingAcceleratedActions()
  {
<span class="line-new-header">--- 1348,94 ---</span>
      }
  
      return nullptr;
  }
  
<span class="line-modified">! void KeyframeEffect::updateAcceleratedActions()</span>
  {
<span class="line-modified">!     if (m_acceleratedPropertiesState == AcceleratedProperties::None)</span>
          return;
  
<span class="line-modified">!     auto computedTiming = getComputedTiming();</span>
<span class="line-modified">! </span>
<span class="line-modified">!     // If we&#39;re not already running accelerated, the only thing we&#39;re interested in is whether we need to start the animation</span>
<span class="line-added">+     // which we need to do once we&#39;re in the active phase. Otherwise, there&#39;s no change in accelerated state to consider.</span>
<span class="line-added">+     bool isActive = computedTiming.phase == AnimationEffectPhase::Active;</span>
<span class="line-added">+     if (!m_isRunningAccelerated) {</span>
<span class="line-added">+         if (isActive &amp;&amp; animation()-&gt;playState() == WebAnimation::PlayState::Running)</span>
<span class="line-added">+             addPendingAcceleratedAction(AcceleratedAction::Play);</span>
          return;
      }
  
<span class="line-modified">!     // If we&#39;re no longer active, we need to remove the accelerated animation.</span>
<span class="line-modified">!     if (!isActive) {</span>
<span class="line-modified">!         addPendingAcceleratedAction(AcceleratedAction::Stop);</span>
          return;
      }
  
      auto playState = animation()-&gt;playState();
<span class="line-added">+     // The only thing left to consider is whether we need to pause or resume the animation following a change of play-state.</span>
      if (playState == WebAnimation::PlayState::Paused) {
          if (m_lastRecordedAcceleratedAction != AcceleratedAction::Pause) {
              if (m_lastRecordedAcceleratedAction == AcceleratedAction::Stop)
                  addPendingAcceleratedAction(AcceleratedAction::Play);
              addPendingAcceleratedAction(AcceleratedAction::Pause);
          }
<span class="line-modified">!     } else if (playState == WebAnimation::PlayState::Running &amp;&amp; isActive) {</span>
          if (m_lastRecordedAcceleratedAction != AcceleratedAction::Play)
              addPendingAcceleratedAction(AcceleratedAction::Play);
      }
  }
  
  void KeyframeEffect::addPendingAcceleratedAction(AcceleratedAction action)
  {
<span class="line-added">+     if (action == m_lastRecordedAcceleratedAction)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
      if (action == AcceleratedAction::Stop)
          m_pendingAcceleratedActions.clear();
      m_pendingAcceleratedActions.append(action);
      if (action != AcceleratedAction::Seek)
          m_lastRecordedAcceleratedAction = action;
      animation()-&gt;acceleratedStateDidChange();
  }
  
<span class="line-added">+ void KeyframeEffect::animationDidTick()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     invalidate();</span>
<span class="line-added">+     updateAcceleratedActions();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void KeyframeEffect::animationDidPlay()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_acceleratedPropertiesState != AcceleratedProperties::None)</span>
<span class="line-added">+         addPendingAcceleratedAction(AcceleratedAction::Play);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void KeyframeEffect::animationDidSeek()
  {
      // There is no need to seek if we&#39;re not playing an animation already. If seeking
<span class="line-modified">!     // means we&#39;re moving into an active lexicalGlobalObject, we&#39;ll pick this up in apply().</span>
<span class="line-modified">!     if (m_isRunningAccelerated || isAboutToRunAccelerated())</span>
          addPendingAcceleratedAction(AcceleratedAction::Seek);
  }
  
<span class="line-added">+ void KeyframeEffect::animationWasCanceled()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_isRunningAccelerated || isAboutToRunAccelerated())</span>
<span class="line-added">+         addPendingAcceleratedAction(AcceleratedAction::Stop);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void KeyframeEffect::willChangeRenderer()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_isRunningAccelerated || isAboutToRunAccelerated())</span>
<span class="line-added">+         addPendingAcceleratedAction(AcceleratedAction::Stop);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void KeyframeEffect::animationSuspensionStateDidChange(bool animationIsSuspended)
  {
<span class="line-modified">!     if (m_isRunningAccelerated || isAboutToRunAccelerated())</span>
          addPendingAcceleratedAction(animationIsSuspended ? AcceleratedAction::Pause : AcceleratedAction::Play);
  }
  
  void KeyframeEffect::applyPendingAcceleratedActions()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1303,41 ***</span>
  
      if (m_pendingAcceleratedActions.isEmpty())
          return;
  
      auto* renderer = this-&gt;renderer();
<span class="line-modified">!     if (!renderer || !renderer-&gt;isComposited())</span>
          return;
  
      auto pendingAcceleratedActions = m_pendingAcceleratedActions;
      m_pendingAcceleratedActions.clear();
  
<span class="line-removed">-     auto* compositedRenderer = downcast&lt;RenderBoxModelObject&gt;(renderer);</span>
<span class="line-removed">- </span>
      // To simplify the code we use a default of 0s for an unresolved current time since for a Stop action that is acceptable.
      auto timeOffset = animation()-&gt;currentTime().valueOr(0_s).seconds() - delay().seconds();
  
      for (const auto&amp; action : pendingAcceleratedActions) {
          switch (action) {
          case AcceleratedAction::Play:
<span class="line-modified">!             if (!compositedRenderer-&gt;startAnimation(timeOffset, backingAnimationForCompositedRenderer(), m_blendingKeyframes)) {</span>
<span class="line-modified">!                 m_shouldRunAccelerated = false;</span>
                  m_lastRecordedAcceleratedAction = AcceleratedAction::Stop;
<span class="line-removed">-                 animation()-&gt;acceleratedStateDidChange();</span>
                  return;
              }
              break;
          case AcceleratedAction::Pause:
<span class="line-modified">!             compositedRenderer-&gt;animationPaused(timeOffset, m_blendingKeyframes.animationName());</span>
              break;
          case AcceleratedAction::Seek:
<span class="line-modified">!             compositedRenderer-&gt;animationSeeked(timeOffset, m_blendingKeyframes.animationName());</span>
              break;
          case AcceleratedAction::Stop:
<span class="line-modified">!             compositedRenderer-&gt;animationFinished(m_blendingKeyframes.animationName());</span>
              if (!m_target-&gt;document().renderTreeBeingDestroyed())
                  m_target-&gt;invalidateStyleAndLayerComposition();
              break;
          }
      }
  }
  
<span class="line-new-header">--- 1446,46 ---</span>
  
      if (m_pendingAcceleratedActions.isEmpty())
          return;
  
      auto* renderer = this-&gt;renderer();
<span class="line-modified">!     if (!renderer || !renderer-&gt;isComposited()) {</span>
<span class="line-added">+         // The renderer may no longer be composited because the accelerated animation ended before we had a chance to update it,</span>
<span class="line-added">+         // in which case if we asked for the animation to stop, we can discard the current set of accelerated actions.</span>
<span class="line-added">+         if (m_lastRecordedAcceleratedAction == AcceleratedAction::Stop) {</span>
<span class="line-added">+             m_pendingAcceleratedActions.clear();</span>
<span class="line-added">+             m_isRunningAccelerated = false;</span>
<span class="line-added">+         }</span>
          return;
<span class="line-added">+     }</span>
  
      auto pendingAcceleratedActions = m_pendingAcceleratedActions;
      m_pendingAcceleratedActions.clear();
  
      // To simplify the code we use a default of 0s for an unresolved current time since for a Stop action that is acceptable.
      auto timeOffset = animation()-&gt;currentTime().valueOr(0_s).seconds() - delay().seconds();
  
      for (const auto&amp; action : pendingAcceleratedActions) {
          switch (action) {
          case AcceleratedAction::Play:
<span class="line-modified">!             m_isRunningAccelerated = renderer-&gt;startAnimation(timeOffset, backingAnimationForCompositedRenderer(), m_blendingKeyframes);</span>
<span class="line-modified">!             if (!m_isRunningAccelerated) {</span>
                  m_lastRecordedAcceleratedAction = AcceleratedAction::Stop;
                  return;
              }
              break;
          case AcceleratedAction::Pause:
<span class="line-modified">!             renderer-&gt;animationPaused(timeOffset, m_blendingKeyframes.animationName());</span>
              break;
          case AcceleratedAction::Seek:
<span class="line-modified">!             renderer-&gt;animationSeeked(timeOffset, m_blendingKeyframes.animationName());</span>
              break;
          case AcceleratedAction::Stop:
<span class="line-modified">!             renderer-&gt;animationFinished(m_blendingKeyframes.animationName());</span>
              if (!m_target-&gt;document().renderTreeBeingDestroyed())
                  m_target-&gt;invalidateStyleAndLayerComposition();
<span class="line-added">+             m_isRunningAccelerated = false;</span>
              break;
          }
      }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1409,11 ***</span>
          return true; // Non-boxes don&#39;t get transformed;
  
      auto&amp; box = downcast&lt;RenderBox&gt;(*renderer());
      auto rendererBox = snapRectToDevicePixels(box.borderBoxRect(), box.document().deviceScaleFactor());
  
<span class="line-modified">!     auto cumulativeBounds = bounds;</span>
  
      for (const auto&amp; keyframe : m_blendingKeyframes.keyframes()) {
          const auto* keyframeStyle = keyframe.style();
  
          // FIXME: maybe for declarative animations we always say it&#39;s true for the first and last keyframe.
<span class="line-new-header">--- 1557,11 ---</span>
          return true; // Non-boxes don&#39;t get transformed;
  
      auto&amp; box = downcast&lt;RenderBox&gt;(*renderer());
      auto rendererBox = snapRectToDevicePixels(box.borderBoxRect(), box.document().deviceScaleFactor());
  
<span class="line-modified">!     LayoutRect cumulativeBounds;</span>
  
      for (const auto&amp; keyframe : m_blendingKeyframes.keyframes()) {
          const auto* keyframeStyle = keyframe.style();
  
          // FIXME: maybe for declarative animations we always say it&#39;s true for the first and last keyframe.
</pre>
<center><a href="DocumentTimeline.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="KeyframeEffect.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
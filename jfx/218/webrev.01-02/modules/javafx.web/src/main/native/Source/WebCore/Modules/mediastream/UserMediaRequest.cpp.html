<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/UserMediaRequest.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011 Ericsson AB. All rights reserved.
  3  * Copyright (C) 2012 Google Inc. All rights reserved.
  4  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.
  5  * Copyright (C) 2013 Nokia Corporation and/or its subsidiary(-ies).
  6  *
  7  * Redistribution and use in source and binary forms, with or without
  8  * modification, are permitted provided that the following conditions
  9  * are met:
 10  *
 11  * 1. Redistributions of source code must retain the above copyright
 12  *    notice, this list of conditions and the following disclaimer.
 13  * 2. Redistributions in binary form must reproduce the above copyright
 14  *    notice, this list of conditions and the following disclaimer
 15  *    in the documentation and/or other materials provided with the
 16  *    distribution.
 17  * 3. Neither the name of Ericsson nor the names of its contributors
 18  *    may be used to endorse or promote products derived from this
 19  *    software without specific prior written permission.
 20  *
 21  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 22  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 23  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 24  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 25  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 26  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 27  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 28  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 29  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 30  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 31  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32  */
 33 
 34 #include &quot;config.h&quot;
 35 #include &quot;UserMediaRequest.h&quot;
 36 
 37 #if ENABLE(MEDIA_STREAM)
 38 
 39 #include &quot;Document.h&quot;
 40 #include &quot;Frame.h&quot;
 41 #include &quot;JSDOMPromiseDeferred.h&quot;
 42 #include &quot;JSMediaStream.h&quot;
 43 #include &quot;JSOverconstrainedError.h&quot;
 44 #include &quot;Logging.h&quot;
 45 #include &quot;MediaConstraints.h&quot;
 46 #include &quot;PlatformMediaSessionManager.h&quot;
 47 #include &quot;RealtimeMediaSourceCenter.h&quot;
 48 #include &quot;Settings.h&quot;
 49 #include &quot;UserMediaController.h&quot;
 50 #include &quot;WindowEventLoop.h&quot;
 51 #include &lt;wtf/Scope.h&gt;
 52 
 53 namespace WebCore {
 54 
 55 Ref&lt;UserMediaRequest&gt; UserMediaRequest::create(Document&amp; document, MediaStreamRequest&amp;&amp; request, DOMPromiseDeferred&lt;IDLInterface&lt;MediaStream&gt;&gt;&amp;&amp; promise)
 56 {
 57     auto result = adoptRef(*new UserMediaRequest(document, WTFMove(request), WTFMove(promise)));
 58     result-&gt;suspendIfNeeded();
 59     return result;
 60 }
 61 
 62 UserMediaRequest::UserMediaRequest(Document&amp; document, MediaStreamRequest&amp;&amp; request, DOMPromiseDeferred&lt;IDLInterface&lt;MediaStream&gt;&gt;&amp;&amp; promise)
 63     : ActiveDOMObject(document)
 64     , m_identifier(UserMediaRequestIdentifier::generate())
 65     , m_promise(makeUniqueRef&lt;DOMPromiseDeferred&lt;IDLInterface&lt;MediaStream&gt;&gt;&gt;(WTFMove(promise)))
 66     , m_request(WTFMove(request))
 67 {
 68 }
 69 
 70 UserMediaRequest::~UserMediaRequest()
 71 {
 72     if (m_allowCompletionHandler)
 73         m_allowCompletionHandler();
 74 }
 75 
 76 SecurityOrigin* UserMediaRequest::userMediaDocumentOrigin() const
 77 {
 78     if (!m_scriptExecutionContext)
 79         return nullptr;
 80     return m_scriptExecutionContext-&gt;securityOrigin();
 81 }
 82 
 83 SecurityOrigin* UserMediaRequest::topLevelDocumentOrigin() const
 84 {
 85     if (!m_scriptExecutionContext)
 86         return nullptr;
 87     return &amp;m_scriptExecutionContext-&gt;topOrigin();
 88 }
 89 
 90 static bool hasInvalidGetDisplayMediaConstraint(const MediaConstraints&amp; constraints)
 91 {
 92     // https://w3c.github.io/mediacapture-screen-share/#navigator-additions
 93     // 1. Let constraints be the method&#39;s first argument.
 94     // 2. For each member present in constraints whose value, value, is a dictionary, run the following steps:
 95     //     1. If value contains a member named advanced, return a promise rejected with a newly created TypeError.
 96     //     2. If value contains a member which in turn is a dictionary containing a member named either min or
 97     //        exact, return a promise rejected with a newly created TypeError.
 98     if (!constraints.isValid)
 99         return false;
100 
101     if (!constraints.advancedConstraints.isEmpty())
102         return true;
103 
104     bool invalid = false;
105     constraints.mandatoryConstraints.filter([&amp;invalid] (const MediaConstraint&amp; constraint) mutable {
106         switch (constraint.constraintType()) {
107         case MediaConstraintType::Width:
108         case MediaConstraintType::Height: {
109             auto&amp; intConstraint = downcast&lt;IntConstraint&gt;(constraint);
110             int value;
111             invalid = intConstraint.getExact(value) || intConstraint.getMin(value);
112             break;
113         }
114 
115         case MediaConstraintType::AspectRatio:
116         case MediaConstraintType::FrameRate: {
117             auto&amp; doubleConstraint = downcast&lt;DoubleConstraint&gt;(constraint);
118             double value;
119             invalid = doubleConstraint.getExact(value) || doubleConstraint.getMin(value);
120             break;
121         }
122 
123         case MediaConstraintType::DisplaySurface:
124         case MediaConstraintType::LogicalSurface: {
125             auto&amp; boolConstraint = downcast&lt;BooleanConstraint&gt;(constraint);
126             bool value;
127             invalid = boolConstraint.getExact(value);
128             break;
129         }
130 
131         case MediaConstraintType::FacingMode:
132         case MediaConstraintType::DeviceId:
133         case MediaConstraintType::GroupId: {
134             auto&amp; stringConstraint = downcast&lt;StringConstraint&gt;(constraint);
135             Vector&lt;String&gt; values;
136             invalid = stringConstraint.getExact(values);
137             break;
138         }
139 
140         case MediaConstraintType::SampleRate:
141         case MediaConstraintType::SampleSize:
142         case MediaConstraintType::Volume:
143         case MediaConstraintType::EchoCancellation:
144             // Ignored.
145             break;
146 
147         case MediaConstraintType::Unknown:
148             ASSERT_NOT_REACHED();
149             break;
150         }
151 
152         return invalid;
153     });
154 
155     return invalid;
156 }
157 
158 void UserMediaRequest::start()
159 {
160     ASSERT(m_scriptExecutionContext);
161     if (!m_scriptExecutionContext) {
162         deny(MediaAccessDenialReason::UserMediaDisabled);
163         return;
164     }
165 
166     if (m_request.type == MediaStreamRequest::Type::DisplayMedia) {
167         if (hasInvalidGetDisplayMediaConstraint(m_request.videoConstraints)) {
168             deny(MediaAccessDenialReason::IllegalConstraint);
169             return;
170         }
171     }
172 
173     // https://w3c.github.io/mediacapture-main/getusermedia.html#dom-mediadevices-getusermedia()
174     // 1. Let constraints be the method&#39;s first argument.
175     // 2. Let requestedMediaTypes be the set of media types in constraints with either a dictionary
176     //    value or a value of &quot;true&quot;.
177     // 3. If requestedMediaTypes is the empty set, return a promise rejected with a TypeError. The word
178     //    &quot;optional&quot; occurs in the WebIDL due to WebIDL rules, but the argument must be supplied in order
179     //    for the call to succeed.
180     if (!m_request.audioConstraints.isValid &amp;&amp; !m_request.videoConstraints.isValid) {
181         deny(MediaAccessDenialReason::NoConstraints);
182         return;
183     }
184 
185     // 4. If the current settings object&#39;s responsible document is NOT allowed to use the feature indicated by
186     //    attribute name allowusermedia, return a promise rejected with a DOMException object whose name
187     //    attribute has the value SecurityError.
188     auto&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);
189     auto* controller = UserMediaController::from(document.page());
190     if (!controller) {
191         deny(MediaAccessDenialReason::UserMediaDisabled);
192         return;
193     }
194 
195     // 6.3 Optionally, e.g., based on a previously-established user preference, for security reasons,
196     //     or due to platform limitations, jump to the step labeled Permission Failure below.
197     // ...
198     // 6.10 Permission Failure: Reject p with a new DOMException object whose name attribute has
199     //      the value NotAllowedError.
200 
201     switch (m_request.type) {
202     case MediaStreamRequest::Type::DisplayMedia:
203         if (!isFeaturePolicyAllowedByDocumentAndAllOwners(FeaturePolicy::Type::DisplayCapture, document)) {
204             deny(MediaAccessDenialReason::PermissionDenied);
205             controller-&gt;logGetDisplayMediaDenial(document);
206             return;
207         }
208         break;
209     case MediaStreamRequest::Type::UserMedia:
210         if (m_request.audioConstraints.isValid &amp;&amp; !isFeaturePolicyAllowedByDocumentAndAllOwners(FeaturePolicy::Type::Microphone, document)) {
211             deny(MediaAccessDenialReason::PermissionDenied);
212             controller-&gt;logGetUserMediaDenial(document);
213             return;
214         }
215         if (m_request.videoConstraints.isValid &amp;&amp; !isFeaturePolicyAllowedByDocumentAndAllOwners(FeaturePolicy::Type::Camera, document)) {
216             deny(MediaAccessDenialReason::PermissionDenied);
217             controller-&gt;logGetUserMediaDenial(document);
218             return;
219         }
220         break;
221     }
222 
223     PlatformMediaSessionManager::sharedManager().prepareToSendUserMediaPermissionRequest();
224     controller-&gt;requestUserMediaAccess(*this);
225 }
226 
227 static inline bool isMediaStreamCorrectlyStarted(const MediaStream&amp; stream)
228 {
229     if (stream.getTracks().isEmpty())
230         return false;
231 
232     return WTF::allOf(stream.getTracks(), [](auto&amp; track) {
233         return !track-&gt;source().captureDidFail();
234     });
235 }
236 
237 void UserMediaRequest::allow(CaptureDevice&amp;&amp; audioDevice, CaptureDevice&amp;&amp; videoDevice, String&amp;&amp; deviceIdentifierHashSalt, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
238 {
239     RELEASE_LOG(MediaStream, &quot;UserMediaRequest::allow %s %s&quot;, audioDevice ? audioDevice.persistentId().utf8().data() : &quot;&quot;, videoDevice ? videoDevice.persistentId().utf8().data() : &quot;&quot;);
240     m_allowCompletionHandler = WTFMove(completionHandler);
241     queueTaskKeepingObjectAlive(*this, TaskSource::UserInteraction, [this, audioDevice = WTFMove(audioDevice), videoDevice = WTFMove(videoDevice), deviceIdentifierHashSalt = WTFMove(deviceIdentifierHashSalt)]() mutable {
242         auto callback = [this, protector = makePendingActivity(*this)](auto privateStreamOrError) mutable {
243             auto scopeExit = makeScopeExit([completionHandler = WTFMove(m_allowCompletionHandler)]() mutable {
244                 completionHandler();
245             });
246             if (isContextStopped())
247                 return;
248 
249             if (!privateStreamOrError.has_value()) {
250                 RELEASE_LOG(MediaStream, &quot;UserMediaRequest::allow failed to create media stream!&quot;);
251                 scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, privateStreamOrError.error());
252                 deny(MediaAccessDenialReason::HardwareError);
253                 return;
254             }
255             auto privateStream = WTFMove(privateStreamOrError).value();
256 
257             auto&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);
258             privateStream-&gt;monitorOrientation(document.orientationNotifier());
259 
260             auto stream = MediaStream::create(document, WTFMove(privateStream));
261             stream-&gt;startProducingData();
262 
263             if (!isMediaStreamCorrectlyStarted(stream)) {
264                 deny(MediaAccessDenialReason::HardwareError);
265                 return;
266             }
267 
268             ASSERT(document.isCapturing());
269             stream-&gt;document()-&gt;setHasCaptureMediaStreamTrack();
270             m_promise-&gt;resolve(WTFMove(stream));
271         };
272 
273         auto&amp; document = downcast&lt;Document&gt;(*scriptExecutionContext());
274         document.setDeviceIDHashSalt(deviceIdentifierHashSalt);
275 
276         RealtimeMediaSourceCenter::singleton().createMediaStream(document.logger(), WTFMove(callback), WTFMove(deviceIdentifierHashSalt), WTFMove(audioDevice), WTFMove(videoDevice), m_request);
277 
278         if (!m_scriptExecutionContext)
279             return;
280 
281 #if ENABLE(WEB_RTC)
282         if (auto* page = document.page())
283             page-&gt;rtcController().disableICECandidateFilteringForDocument(document);
284 #endif
285     });
286 }
287 
288 void UserMediaRequest::deny(MediaAccessDenialReason reason, const String&amp; message)
289 {
290     if (!m_scriptExecutionContext)
291         return;
292 
293     ExceptionCode code;
294     switch (reason) {
295     case MediaAccessDenialReason::IllegalConstraint:
296         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - invalid constraints&quot;);
297         code = TypeError;
298         break;
299     case MediaAccessDenialReason::NoConstraints:
300         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - no constraints&quot;);
301         code = TypeError;
302         break;
303     case MediaAccessDenialReason::UserMediaDisabled:
304         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - user media disabled&quot;);
305         code = SecurityError;
306         break;
307     case MediaAccessDenialReason::NoCaptureDevices:
308         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - no capture devices&quot;);
309         code = NotFoundError;
310         break;
311     case MediaAccessDenialReason::InvalidConstraint:
312         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - invalid constraint - %s&quot;, message.utf8().data());
313         m_promise-&gt;rejectType&lt;IDLInterface&lt;OverconstrainedError&gt;&gt;(OverconstrainedError::create(message, &quot;Invalid constraint&quot;_s).get());
314         return;
315     case MediaAccessDenialReason::HardwareError:
316         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - hardware error&quot;);
317         code = NotReadableError;
318         break;
319     case MediaAccessDenialReason::OtherFailure:
320         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - other failure&quot;);
321         code = AbortError;
322         break;
323     case MediaAccessDenialReason::PermissionDenied:
324         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - permission denied&quot;);
325         code = NotAllowedError;
326         break;
327     case MediaAccessDenialReason::InvalidAccess:
328         RELEASE_LOG(MediaStream, &quot;UserMediaRequest::deny - invalid access&quot;);
329         code = InvalidAccessError;
330         break;
331     }
332 
333     if (!message.isEmpty())
334         m_promise-&gt;reject(code, message);
335     else
336         m_promise-&gt;reject(code);
337 }
338 
339 void UserMediaRequest::stop()
340 {
341     auto&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);
342     if (auto* controller = UserMediaController::from(document.page()))
343         controller-&gt;cancelUserMediaAccessRequest(*this);
344 }
345 
346 const char* UserMediaRequest::activeDOMObjectName() const
347 {
348     return &quot;UserMediaRequest&quot;;
349 }
350 
351 Document* UserMediaRequest::document() const
352 {
353     return downcast&lt;Document&gt;(m_scriptExecutionContext);
354 }
355 
356 void UserMediaRequest::mediaStreamDidFail(RealtimeMediaSource::Type type)
357 {
358     RELEASE_LOG(MediaStream, &quot;UserMediaRequest::mediaStreamDidFail&quot;);
359     const char* typeDescription = &quot;&quot;;
360     switch (type) {
361     case RealtimeMediaSource::Type::Audio:
362         typeDescription = &quot;audio&quot;;
363         break;
364     case RealtimeMediaSource::Type::Video:
365         typeDescription = &quot;video&quot;;
366         break;
367     case RealtimeMediaSource::Type::None:
368         typeDescription = &quot;unknown&quot;;
369         break;
370     }
371     m_promise-&gt;reject(NotReadableError, makeString(&quot;Failed starting capture of a &quot;_s, typeDescription, &quot; track&quot;_s));
372 }
373 
374 } // namespace WebCore
375 
376 #endif // ENABLE(MEDIA_STREAM)
    </pre>
  </body>
</html>
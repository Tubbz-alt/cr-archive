<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/generateWasmOpsHeader.py</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmWorklist.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="js/JSToWasm.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/generateWasmOpsHeader.py</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -38,14 +38,20 @@</span>
  types = wasm.types
  opcodes = wasm.opcodes
  wasmOpsHFile = open(args[2], &quot;w&quot;)
  
  
<span class="udiff-line-modified-removed">- def cppMacro(wasmOpcode, value, b3, inc):</span>
<span class="udiff-line-modified-removed">-     return &quot; \\\n    macro(&quot; + wasm.toCpp(wasmOpcode) + &quot;, &quot; + hex(int(value)) + &quot;, &quot; + b3 + &quot;, &quot; + str(inc) + &quot;)&quot;</span>
<span class="udiff-line-modified-added">+ def cppType(type):</span>
<span class="udiff-line-modified-added">+     if type == &quot;bool&quot;:</span>
<span class="udiff-line-added">+         return &quot;I32&quot;</span>
<span class="udiff-line-added">+     return type.capitalize()</span>
  
  
<span class="udiff-line-added">+ def cppMacro(wasmOpcode, value, b3, inc, *extraArgs):</span>
<span class="udiff-line-added">+     extraArgsStr = &quot;, &quot; + &quot;, &quot;.join(extraArgs) if len(extraArgs) else &quot;&quot;</span>
<span class="udiff-line-added">+     return &quot; \\\n    macro(&quot; + wasm.toCpp(wasmOpcode) + &quot;, &quot; + hex(int(value)) + &quot;, &quot; + b3 + &quot;, &quot; + str(inc) + extraArgsStr + &quot;)&quot;</span>
<span class="udiff-line-added">+ </span>
  def typeMacroizer():
      inc = 0
      for ty in wasm.types:
          yield cppMacro(ty, wasm.types[ty][&quot;value&quot;], wasm.types[ty][&quot;b3type&quot;], inc)
          inc += 1
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -53,37 +59,59 @@</span>
  type_definitions = [&quot;#define FOR_EACH_WASM_TYPE(macro)&quot;]
  type_definitions.extend([t for t in typeMacroizer()])
  type_definitions = &quot;&quot;.join(type_definitions)
  
  
<span class="udiff-line-modified-removed">- def opcodeMacroizer(filter, opcodeField=&quot;value&quot;):</span>
<span class="udiff-line-modified-added">+ def opcodeMacroizer(filter, opcodeField=&quot;value&quot;, modifier=None):</span>
      inc = 0
      for op in wasm.opcodeIterator(filter):
          b3op = &quot;Oops&quot;
          if isSimple(op[&quot;opcode&quot;]):
              b3op = op[&quot;opcode&quot;][&quot;b3op&quot;]
<span class="udiff-line-modified-removed">-         yield cppMacro(op[&quot;name&quot;], op[&quot;opcode&quot;][opcodeField], b3op, inc)</span>
<span class="udiff-line-modified-added">+         extraArgs = []</span>
<span class="udiff-line-added">+         if modifier:</span>
<span class="udiff-line-added">+             extraArgs = modifier(op[&quot;opcode&quot;])</span>
<span class="udiff-line-added">+         yield cppMacro(op[&quot;name&quot;], op[&quot;opcode&quot;][opcodeField], b3op, inc, *extraArgs)</span>
          inc += 1
  
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ def opcodeWithTypesMacroizer(filter):</span>
<span class="udiff-line-added">+     def modifier(op):</span>
<span class="udiff-line-added">+         return [cppType(type) for type in op[&quot;parameter&quot;] + op[&quot;return&quot;]]</span>
<span class="udiff-line-added">+     return opcodeMacroizer(filter, modifier=modifier)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ def memoryLoadMacroizer():</span>
<span class="udiff-line-added">+     def modifier(op):</span>
<span class="udiff-line-added">+         return [cppType(op[&quot;return&quot;][0])]</span>
<span class="udiff-line-added">+     return opcodeMacroizer(lambda op: (op[&quot;category&quot;] == &quot;memory&quot; and len(op[&quot;return&quot;]) == 1), modifier=modifier)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ def memoryStoreMacroizer():</span>
<span class="udiff-line-added">+     def modifier(op):</span>
<span class="udiff-line-added">+         return [cppType(op[&quot;parameter&quot;][1])]</span>
<span class="udiff-line-added">+     return opcodeMacroizer(lambda op: (op[&quot;category&quot;] == &quot;memory&quot; and len(op[&quot;return&quot;]) == 0), modifier=modifier)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  defines = [&quot;#define FOR_EACH_WASM_SPECIAL_OP(macro)&quot;]
  defines.extend([op for op in opcodeMacroizer(lambda op: not (isUnary(op) or isBinary(op) or op[&quot;category&quot;] == &quot;control&quot; or op[&quot;category&quot;] == &quot;memory&quot; or op[&quot;category&quot;] == &quot;exttable&quot;))])
  defines.append(&quot;\n\n#define FOR_EACH_WASM_CONTROL_FLOW_OP(macro)&quot;)
  defines.extend([op for op in opcodeMacroizer(lambda op: op[&quot;category&quot;] == &quot;control&quot;)])
  defines.append(&quot;\n\n#define FOR_EACH_WASM_SIMPLE_UNARY_OP(macro)&quot;)
<span class="udiff-line-modified-removed">- defines.extend([op for op in opcodeMacroizer(lambda op: isUnary(op) and isSimple(op))])</span>
<span class="udiff-line-modified-added">+ defines.extend([op for op in opcodeWithTypesMacroizer(lambda op: isUnary(op) and isSimple(op))])</span>
  defines.append(&quot;\n\n#define FOR_EACH_WASM_UNARY_OP(macro) \\\n    FOR_EACH_WASM_SIMPLE_UNARY_OP(macro)&quot;)
<span class="udiff-line-modified-removed">- defines.extend([op for op in opcodeMacroizer(lambda op: isUnary(op) and not (isSimple(op)))])</span>
<span class="udiff-line-modified-added">+ defines.extend([op for op in opcodeWithTypesMacroizer(lambda op: isUnary(op) and not (isSimple(op)))])</span>
  defines.append(&quot;\n\n#define FOR_EACH_WASM_SIMPLE_BINARY_OP(macro)&quot;)
<span class="udiff-line-modified-removed">- defines.extend([op for op in opcodeMacroizer(lambda op: isBinary(op) and isSimple(op))])</span>
<span class="udiff-line-modified-added">+ defines.extend([op for op in opcodeWithTypesMacroizer(lambda op: isBinary(op) and isSimple(op))])</span>
  defines.append(&quot;\n\n#define FOR_EACH_WASM_BINARY_OP(macro) \\\n    FOR_EACH_WASM_SIMPLE_BINARY_OP(macro)&quot;)
<span class="udiff-line-modified-removed">- defines.extend([op for op in opcodeMacroizer(lambda op: isBinary(op) and not (isSimple(op)))])</span>
<span class="udiff-line-modified-added">+ defines.extend([op for op in opcodeWithTypesMacroizer(lambda op: isBinary(op) and not (isSimple(op)))])</span>
  defines.append(&quot;\n\n#define FOR_EACH_WASM_MEMORY_LOAD_OP(macro)&quot;)
<span class="udiff-line-modified-removed">- defines.extend([op for op in opcodeMacroizer(lambda op: (op[&quot;category&quot;] == &quot;memory&quot; and len(op[&quot;return&quot;]) == 1))])</span>
<span class="udiff-line-modified-added">+ defines.extend([op for op in memoryLoadMacroizer()])</span>
  defines.append(&quot;\n\n#define FOR_EACH_WASM_MEMORY_STORE_OP(macro)&quot;)
<span class="udiff-line-modified-removed">- defines.extend([op for op in opcodeMacroizer(lambda op: (op[&quot;category&quot;] == &quot;memory&quot; and len(op[&quot;return&quot;]) == 0))])</span>
<span class="udiff-line-modified-added">+ defines.extend([op for op in memoryStoreMacroizer()])</span>
  defines.append(&quot;\n\n#define FOR_EACH_WASM_EXT_TABLE_OP(macro)&quot;)
<span class="udiff-line-modified-removed">- defines.extend([op for op in opcodeMacroizer(lambda op: (op[&quot;category&quot;] == &quot;exttable&quot;), &quot;extendedOp&quot;)])</span>
<span class="udiff-line-modified-added">+ defines.extend([op for op in opcodeMacroizer(lambda op: (op[&quot;category&quot;] == &quot;exttable&quot;), opcodeField=&quot;extendedOp&quot;)])</span>
  defines.append(&quot;\n\n&quot;)
  
  defines = &quot;&quot;.join(defines)
  
  opValueSet = set([op for op in wasm.opcodeIterator(lambda op: True, lambda op: opcodes[op][&quot;value&quot;])])
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -131,17 +159,17 @@</span>
  static constexpr unsigned expectedVersionNumber = &quot;&quot;&quot; + wasm.expectedVersionNumber + &quot;&quot;&quot;;
  
  static constexpr unsigned numTypes = &quot;&quot;&quot; + str(len(types)) + &quot;&quot;&quot;;
  
  &quot;&quot;&quot; + type_definitions + &quot;&quot;&quot;
<span class="udiff-line-modified-removed">- #define CREATE_ENUM_VALUE(name, id, b3type, inc) name = id,</span>
<span class="udiff-line-modified-added">+ #define CREATE_ENUM_VALUE(name, id, ...) name = id,</span>
  enum Type : int8_t {
      FOR_EACH_WASM_TYPE(CREATE_ENUM_VALUE)
  };
  #undef CREATE_ENUM_VALUE
  
<span class="udiff-line-modified-removed">- #define CREATE_CASE(name, id, b3type, inc) case id: return true;</span>
<span class="udiff-line-modified-added">+ #define CREATE_CASE(name, id, ...) case id: return true;</span>
  template &lt;typename Int&gt;
  inline bool isValidType(Int i)
  {
      switch (i) {
      default: return false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -150,44 +178,44 @@</span>
      RELEASE_ASSERT_NOT_REACHED();
      return false;
  }
  #undef CREATE_CASE
  
<span class="udiff-line-modified-removed">- #define CREATE_CASE(name, id, b3type, inc) case name: return b3type;</span>
<span class="udiff-line-modified-added">+ #define CREATE_CASE(name, id, b3type, ...) case name: return b3type;</span>
  inline B3::Type toB3Type(Type type)
  {
      switch (type) {
      FOR_EACH_WASM_TYPE(CREATE_CASE)
      }
      RELEASE_ASSERT_NOT_REACHED();
      return B3::Void;
  }
  #undef CREATE_CASE
  
<span class="udiff-line-modified-removed">- #define CREATE_CASE(name, id, b3type, inc) case name: return #name;</span>
<span class="udiff-line-modified-added">+ #define CREATE_CASE(name, ...) case name: return #name;</span>
  inline const char* makeString(Type type)
  {
      switch (type) {
      FOR_EACH_WASM_TYPE(CREATE_CASE)
      }
      RELEASE_ASSERT_NOT_REACHED();
      return nullptr;
  }
  #undef CREATE_CASE
  
<span class="udiff-line-modified-removed">- #define CREATE_CASE(name, id, b3type, inc) case id: return inc;</span>
<span class="udiff-line-modified-added">+ #define CREATE_CASE(name, id, b3type, inc, ...) case id: return inc;</span>
  inline int linearizeType(Type type)
  {
      switch (type) {
      FOR_EACH_WASM_TYPE(CREATE_CASE)
      }
      RELEASE_ASSERT_NOT_REACHED();
      return 0;
  }
  #undef CREATE_CASE
  
<span class="udiff-line-modified-removed">- #define CREATE_CASE(name, id, b3type, inc) case inc: return name;</span>
<span class="udiff-line-modified-added">+ #define CREATE_CASE(name, id, b3type, inc, ...) case inc: return name;</span>
  inline Type linearizedToType(int i)
  {
      switch (i) {
      FOR_EACH_WASM_TYPE(CREATE_CASE)
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -205,11 +233,11 @@</span>
      FOR_EACH_WASM_BINARY_OP(macro) \\
      FOR_EACH_WASM_MEMORY_LOAD_OP(macro) \\
      FOR_EACH_WASM_MEMORY_STORE_OP(macro) \\
      macro(ExtTable, 0xFC, Oops, 0)
  
<span class="udiff-line-modified-removed">- #define CREATE_ENUM_VALUE(name, id, b3op, inc) name = id,</span>
<span class="udiff-line-modified-added">+ #define CREATE_ENUM_VALUE(name, id, ...) name = id,</span>
  
  enum OpType : uint8_t {
      FOR_EACH_WASM_OP(CREATE_ENUM_VALUE)
  };
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -244,11 +272,11 @@</span>
  #undef CREATE_ENUM_VALUE
  
  inline bool isControlOp(OpType op)
  {
      switch (op) {
<span class="udiff-line-modified-removed">- #define CREATE_CASE(name, id, b3op, inc) case OpType::name:</span>
<span class="udiff-line-modified-added">+ #define CREATE_CASE(name, ...) case OpType::name:</span>
      FOR_EACH_WASM_CONTROL_FLOW_OP(CREATE_CASE)
          return true;
  #undef CREATE_CASE
      default:
          break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -257,11 +285,11 @@</span>
  }
  
  inline bool isSimple(UnaryOpType op)
  {
      switch (op) {
<span class="udiff-line-modified-removed">- #define CREATE_CASE(name, id, b3op, inc) case UnaryOpType::name:</span>
<span class="udiff-line-modified-added">+ #define CREATE_CASE(name, ...) case UnaryOpType::name:</span>
      FOR_EACH_WASM_SIMPLE_UNARY_OP(CREATE_CASE)
          return true;
  #undef CREATE_CASE
      default:
          break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -270,11 +298,11 @@</span>
  }
  
  inline bool isSimple(BinaryOpType op)
  {
      switch (op) {
<span class="udiff-line-modified-removed">- #define CREATE_CASE(name, id, b3op, inc) case BinaryOpType::name:</span>
<span class="udiff-line-modified-added">+ #define CREATE_CASE(name, ...) case BinaryOpType::name:</span>
      FOR_EACH_WASM_SIMPLE_BINARY_OP(CREATE_CASE)
          return true;
  #undef CREATE_CASE
      default:
          break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -292,11 +320,11 @@</span>
      }
      RELEASE_ASSERT_NOT_REACHED();
      return 0;
  }
  
<span class="udiff-line-modified-removed">- #define CREATE_CASE(name, id, b3type, inc) case name: return #name;</span>
<span class="udiff-line-modified-added">+ #define CREATE_CASE(name, ...) case name: return #name;</span>
  inline const char* makeString(OpType op)
  {
      switch (op) {
      FOR_EACH_WASM_OP(CREATE_CASE)
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -305,10 +333,24 @@</span>
  }
  #undef CREATE_CASE
  
  } } // namespace JSC::Wasm
  
<span class="udiff-line-added">+ namespace WTF {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline void printInternal(PrintStream&amp; out, JSC::Wasm::Type type)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     out.print(JSC::Wasm::makeString(type));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline void printInternal(PrintStream&amp; out, JSC::Wasm::OpType op)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     out.print(JSC::Wasm::makeString(op));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ } // namespace WTF</span>
<span class="udiff-line-added">+ </span>
  #endif // ENABLE(WEBASSEMBLY)
  
  &quot;&quot;&quot;
  
  wasmOpsHFile.write(contents)
</pre>
<center><a href="WasmWorklist.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="js/JSToWasm.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
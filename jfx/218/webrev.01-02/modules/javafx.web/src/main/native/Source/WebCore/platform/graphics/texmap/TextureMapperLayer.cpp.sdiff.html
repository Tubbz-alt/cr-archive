<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperLayer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TextureMapperJava.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TextureMapperLayer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperLayer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 51 }
 52 
 53 void TextureMapperLayer::computeTransformsRecursive()
 54 {
 55     if (m_state.size.isEmpty() &amp;&amp; m_state.masksToBounds)
 56         return;
 57 
 58     // Compute transforms recursively on the way down to leafs.
 59     {
 60         TransformationMatrix parentTransform;
 61         if (m_parent)
 62             parentTransform = m_parent-&gt;m_layerTransforms.combinedForChildren;
 63         else if (m_effectTarget)
 64             parentTransform = m_effectTarget-&gt;m_layerTransforms.combined;
 65 
 66         const float originX = m_state.anchorPoint.x() * m_state.size.width();
 67         const float originY = m_state.anchorPoint.y() * m_state.size.height();
 68 
 69         m_layerTransforms.combined = parentTransform;
 70         m_layerTransforms.combined
<span class="line-modified"> 71             .translate3d(originX + m_state.pos.x(), originY + m_state.pos.y(), m_state.anchorPoint.z())</span>
 72             .multiply(m_layerTransforms.localTransform);
 73 
 74         m_layerTransforms.combinedForChildren = m_layerTransforms.combined;
 75         m_layerTransforms.combined.translate3d(-originX, -originY, -m_state.anchorPoint.z());
 76 
 77         if (!m_state.preserves3D)
 78             m_layerTransforms.combinedForChildren = m_layerTransforms.combinedForChildren.to2dTransform();
 79         m_layerTransforms.combinedForChildren.multiply(m_state.childrenTransform);
 80         m_layerTransforms.combinedForChildren.translate3d(-originX, -originY, -m_state.anchorPoint.z());
 81 
 82 #if USE(COORDINATED_GRAPHICS)
 83         // Compute transforms for the future as well.
 84         TransformationMatrix futureParentTransform;
 85         if (m_parent)
 86             futureParentTransform = m_parent-&gt;m_layerTransforms.futureCombinedForChildren;
 87         else if (m_effectTarget)
 88             futureParentTransform = m_effectTarget-&gt;m_layerTransforms.futureCombined;
 89 
 90         m_layerTransforms.futureCombined = futureParentTransform;
 91         m_layerTransforms.futureCombined
<span class="line-modified"> 92             .translate3d(originX + m_state.pos.x(), originY + m_state.pos.y(), m_state.anchorPoint.z())</span>
 93             .multiply(m_layerTransforms.futureLocalTransform);
 94 
 95         m_layerTransforms.futureCombinedForChildren = m_layerTransforms.futureCombined;
 96         m_layerTransforms.futureCombined.translate3d(-originX, -originY, -m_state.anchorPoint.z());
 97 
 98         if (!m_state.preserves3D)
 99             m_layerTransforms.futureCombinedForChildren = m_layerTransforms.futureCombinedForChildren.to2dTransform();
100         m_layerTransforms.futureCombinedForChildren.multiply(m_state.childrenTransform);
101         m_layerTransforms.futureCombinedForChildren.translate3d(-originX, -originY, -m_state.anchorPoint.z());
102 #endif
103     }
104 
105     m_state.visible = m_state.backfaceVisibility || !m_layerTransforms.combined.isBackFaceVisible();
106 
107     if (m_parent &amp;&amp; m_parent-&gt;m_state.preserves3D)
108         m_centerZ = m_layerTransforms.combined.mapPoint(FloatPoint3D(m_state.size.width() / 2, m_state.size.height() / 2, 0)).z();
109 
110     if (m_state.maskLayer)
111         m_state.maskLayer-&gt;computeTransformsRecursive();
112     if (m_state.replicaLayer)
</pre>
<hr />
<pre>
281     Region newOverlapRegion(newRegion);
282     newOverlapRegion.intersect(nonOverlapRegion);
283     nonOverlapRegion.subtract(newOverlapRegion);
284     overlapRegion.unite(newOverlapRegion);
285     newRegion.subtract(overlapRegion);
286     nonOverlapRegion.unite(newRegion);
287 }
288 
289 void TextureMapperLayer::computeOverlapRegions(Region&amp; overlapRegion, Region&amp; nonOverlapRegion, ResolveSelfOverlapMode mode)
290 {
291     if (!m_state.visible || !m_state.contentsVisible)
292         return;
293 
294     FloatRect boundingRect;
295     if (m_backingStore || m_state.masksToBounds || m_state.maskLayer || hasFilters())
296         boundingRect = layerRect();
297     else if (m_contentsLayer || m_state.solidColor.isVisible())
298         boundingRect = m_state.contentsRect;
299 
300     if (m_currentFilters.hasOutsets()) {
<span class="line-modified">301         FilterOutsets outsets = m_currentFilters.outsets();</span>
302         IntRect unfilteredTargetRect(boundingRect);
303         boundingRect.move(std::max(0, -outsets.left()), std::max(0, -outsets.top()));
304         boundingRect.expand(outsets.left() + outsets.right(), outsets.top() + outsets.bottom());
305         boundingRect.unite(unfilteredTargetRect);
306     }
307 
308     TransformationMatrix replicaMatrix;
309     if (m_state.replicaLayer) {
310         replicaMatrix = replicaTransform();
311         boundingRect.unite(replicaMatrix.mapRect(boundingRect));
312     }
313 
314     boundingRect = m_layerTransforms.combined.mapRect(boundingRect);
315 
316     // Count all masks and filters as overlap layers.
317     if (hasFilters() || m_state.maskLayer || (m_state.replicaLayer &amp;&amp; m_state.replicaLayer-&gt;m_state.maskLayer)) {
318         Region newOverlapRegion(enclosingIntRect(boundingRect));
319         nonOverlapRegion.subtract(newOverlapRegion);
320         overlapRegion.unite(newOverlapRegion);
321         return;
</pre>
<hr />
<pre>
525         maskLayer-&gt;m_effectTarget = makeWeakPtr(*this);
526         m_state.maskLayer = makeWeakPtr(*maskLayer);
527     } else
528         m_state.maskLayer = nullptr;
529 }
530 
531 void TextureMapperLayer::setReplicaLayer(TextureMapperLayer* replicaLayer)
532 {
533     if (replicaLayer) {
534         replicaLayer-&gt;m_effectTarget = makeWeakPtr(*this);
535         m_state.replicaLayer = makeWeakPtr(*replicaLayer);
536     } else
537         m_state.replicaLayer = nullptr;
538 }
539 
540 void TextureMapperLayer::setPosition(const FloatPoint&amp; position)
541 {
542     m_state.pos = position;
543 }
544 





545 void TextureMapperLayer::setSize(const FloatSize&amp; size)
546 {
547     m_state.size = size;
548 }
549 
550 void TextureMapperLayer::setAnchorPoint(const FloatPoint3D&amp; anchorPoint)
551 {
552     m_state.anchorPoint = anchorPoint;
553 }
554 
555 void TextureMapperLayer::setPreserves3D(bool preserves3D)
556 {
557     m_state.preserves3D = preserves3D;
558 }
559 
560 void TextureMapperLayer::setTransform(const TransformationMatrix&amp; transform)
561 {
562     m_state.transform = transform;
563 }
564 
</pre>
</td>
<td>
<hr />
<pre>
 51 }
 52 
 53 void TextureMapperLayer::computeTransformsRecursive()
 54 {
 55     if (m_state.size.isEmpty() &amp;&amp; m_state.masksToBounds)
 56         return;
 57 
 58     // Compute transforms recursively on the way down to leafs.
 59     {
 60         TransformationMatrix parentTransform;
 61         if (m_parent)
 62             parentTransform = m_parent-&gt;m_layerTransforms.combinedForChildren;
 63         else if (m_effectTarget)
 64             parentTransform = m_effectTarget-&gt;m_layerTransforms.combined;
 65 
 66         const float originX = m_state.anchorPoint.x() * m_state.size.width();
 67         const float originY = m_state.anchorPoint.y() * m_state.size.height();
 68 
 69         m_layerTransforms.combined = parentTransform;
 70         m_layerTransforms.combined
<span class="line-modified"> 71             .translate3d(originX + (m_state.pos.x() - m_state.boundsOrigin.x()), originY + (m_state.pos.y() - m_state.boundsOrigin.y()), m_state.anchorPoint.z())</span>
 72             .multiply(m_layerTransforms.localTransform);
 73 
 74         m_layerTransforms.combinedForChildren = m_layerTransforms.combined;
 75         m_layerTransforms.combined.translate3d(-originX, -originY, -m_state.anchorPoint.z());
 76 
 77         if (!m_state.preserves3D)
 78             m_layerTransforms.combinedForChildren = m_layerTransforms.combinedForChildren.to2dTransform();
 79         m_layerTransforms.combinedForChildren.multiply(m_state.childrenTransform);
 80         m_layerTransforms.combinedForChildren.translate3d(-originX, -originY, -m_state.anchorPoint.z());
 81 
 82 #if USE(COORDINATED_GRAPHICS)
 83         // Compute transforms for the future as well.
 84         TransformationMatrix futureParentTransform;
 85         if (m_parent)
 86             futureParentTransform = m_parent-&gt;m_layerTransforms.futureCombinedForChildren;
 87         else if (m_effectTarget)
 88             futureParentTransform = m_effectTarget-&gt;m_layerTransforms.futureCombined;
 89 
 90         m_layerTransforms.futureCombined = futureParentTransform;
 91         m_layerTransforms.futureCombined
<span class="line-modified"> 92             .translate3d(originX + (m_state.pos.x() - m_state.boundsOrigin.x()), originY + (m_state.pos.y() - m_state.boundsOrigin.y()), m_state.anchorPoint.z())</span>
 93             .multiply(m_layerTransforms.futureLocalTransform);
 94 
 95         m_layerTransforms.futureCombinedForChildren = m_layerTransforms.futureCombined;
 96         m_layerTransforms.futureCombined.translate3d(-originX, -originY, -m_state.anchorPoint.z());
 97 
 98         if (!m_state.preserves3D)
 99             m_layerTransforms.futureCombinedForChildren = m_layerTransforms.futureCombinedForChildren.to2dTransform();
100         m_layerTransforms.futureCombinedForChildren.multiply(m_state.childrenTransform);
101         m_layerTransforms.futureCombinedForChildren.translate3d(-originX, -originY, -m_state.anchorPoint.z());
102 #endif
103     }
104 
105     m_state.visible = m_state.backfaceVisibility || !m_layerTransforms.combined.isBackFaceVisible();
106 
107     if (m_parent &amp;&amp; m_parent-&gt;m_state.preserves3D)
108         m_centerZ = m_layerTransforms.combined.mapPoint(FloatPoint3D(m_state.size.width() / 2, m_state.size.height() / 2, 0)).z();
109 
110     if (m_state.maskLayer)
111         m_state.maskLayer-&gt;computeTransformsRecursive();
112     if (m_state.replicaLayer)
</pre>
<hr />
<pre>
281     Region newOverlapRegion(newRegion);
282     newOverlapRegion.intersect(nonOverlapRegion);
283     nonOverlapRegion.subtract(newOverlapRegion);
284     overlapRegion.unite(newOverlapRegion);
285     newRegion.subtract(overlapRegion);
286     nonOverlapRegion.unite(newRegion);
287 }
288 
289 void TextureMapperLayer::computeOverlapRegions(Region&amp; overlapRegion, Region&amp; nonOverlapRegion, ResolveSelfOverlapMode mode)
290 {
291     if (!m_state.visible || !m_state.contentsVisible)
292         return;
293 
294     FloatRect boundingRect;
295     if (m_backingStore || m_state.masksToBounds || m_state.maskLayer || hasFilters())
296         boundingRect = layerRect();
297     else if (m_contentsLayer || m_state.solidColor.isVisible())
298         boundingRect = m_state.contentsRect;
299 
300     if (m_currentFilters.hasOutsets()) {
<span class="line-modified">301         auto outsets = m_currentFilters.outsets();</span>
302         IntRect unfilteredTargetRect(boundingRect);
303         boundingRect.move(std::max(0, -outsets.left()), std::max(0, -outsets.top()));
304         boundingRect.expand(outsets.left() + outsets.right(), outsets.top() + outsets.bottom());
305         boundingRect.unite(unfilteredTargetRect);
306     }
307 
308     TransformationMatrix replicaMatrix;
309     if (m_state.replicaLayer) {
310         replicaMatrix = replicaTransform();
311         boundingRect.unite(replicaMatrix.mapRect(boundingRect));
312     }
313 
314     boundingRect = m_layerTransforms.combined.mapRect(boundingRect);
315 
316     // Count all masks and filters as overlap layers.
317     if (hasFilters() || m_state.maskLayer || (m_state.replicaLayer &amp;&amp; m_state.replicaLayer-&gt;m_state.maskLayer)) {
318         Region newOverlapRegion(enclosingIntRect(boundingRect));
319         nonOverlapRegion.subtract(newOverlapRegion);
320         overlapRegion.unite(newOverlapRegion);
321         return;
</pre>
<hr />
<pre>
525         maskLayer-&gt;m_effectTarget = makeWeakPtr(*this);
526         m_state.maskLayer = makeWeakPtr(*maskLayer);
527     } else
528         m_state.maskLayer = nullptr;
529 }
530 
531 void TextureMapperLayer::setReplicaLayer(TextureMapperLayer* replicaLayer)
532 {
533     if (replicaLayer) {
534         replicaLayer-&gt;m_effectTarget = makeWeakPtr(*this);
535         m_state.replicaLayer = makeWeakPtr(*replicaLayer);
536     } else
537         m_state.replicaLayer = nullptr;
538 }
539 
540 void TextureMapperLayer::setPosition(const FloatPoint&amp; position)
541 {
542     m_state.pos = position;
543 }
544 
<span class="line-added">545 void TextureMapperLayer::setBoundsOrigin(const FloatPoint&amp; boundsOrigin)</span>
<span class="line-added">546 {</span>
<span class="line-added">547     m_state.boundsOrigin = boundsOrigin;</span>
<span class="line-added">548 }</span>
<span class="line-added">549 </span>
550 void TextureMapperLayer::setSize(const FloatSize&amp; size)
551 {
552     m_state.size = size;
553 }
554 
555 void TextureMapperLayer::setAnchorPoint(const FloatPoint3D&amp; anchorPoint)
556 {
557     m_state.anchorPoint = anchorPoint;
558 }
559 
560 void TextureMapperLayer::setPreserves3D(bool preserves3D)
561 {
562     m_state.preserves3D = preserves3D;
563 }
564 
565 void TextureMapperLayer::setTransform(const TransformationMatrix&amp; transform)
566 {
567     m_state.transform = transform;
568 }
569 
</pre>
</td>
</tr>
</table>
<center><a href="TextureMapperJava.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TextureMapperLayer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
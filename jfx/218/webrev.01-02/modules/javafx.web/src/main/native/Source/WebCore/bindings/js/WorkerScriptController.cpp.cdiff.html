<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/WorkerScriptController.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WindowProxy.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../scripts/CodeGenerator.pm.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/WorkerScriptController.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 40,11 ***</span>
  #include &lt;JavaScriptCore/Exception.h&gt;
  #include &lt;JavaScriptCore/ExceptionHelpers.h&gt;
  #include &lt;JavaScriptCore/GCActivityCallback.h&gt;
  #include &lt;JavaScriptCore/JSCInlines.h&gt;
  #include &lt;JavaScriptCore/JSLock.h&gt;
<span class="line-modified">! #include &lt;JavaScriptCore/PromiseDeferredTimer.h&gt;</span>
  #include &lt;JavaScriptCore/StrongInlines.h&gt;
  
  namespace WebCore {
  using namespace JSC;
  
<span class="line-new-header">--- 40,11 ---</span>
  #include &lt;JavaScriptCore/Exception.h&gt;
  #include &lt;JavaScriptCore/ExceptionHelpers.h&gt;
  #include &lt;JavaScriptCore/GCActivityCallback.h&gt;
  #include &lt;JavaScriptCore/JSCInlines.h&gt;
  #include &lt;JavaScriptCore/JSLock.h&gt;
<span class="line-modified">! #include &lt;JavaScriptCore/PromiseTimer.h&gt;</span>
  #include &lt;JavaScriptCore/StrongInlines.h&gt;
  
  namespace WebCore {
  using namespace JSC;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 132,26 ***</span>
  
      NakedPtr&lt;JSC::Exception&gt; exception;
      evaluate(sourceCode, exception, returnedExceptionMessage);
      if (exception) {
          JSLockHolder lock(vm());
<span class="line-modified">!         reportException(m_workerGlobalScopeWrapper-&gt;globalExec(), exception);</span>
      }
  }
  
  void WorkerScriptController::evaluate(const ScriptSourceCode&amp; sourceCode, NakedPtr&lt;JSC::Exception&gt;&amp; returnedException, String* returnedExceptionMessage)
  {
      if (isExecutionForbidden())
          return;
  
      initScriptIfNeeded();
  
<span class="line-modified">!     auto&amp; state = *m_workerGlobalScopeWrapper-&gt;globalExec();</span>
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      JSLockHolder lock { vm };
  
<span class="line-modified">!     JSExecState::profiledEvaluate(&amp;state, JSC::ProfilingReason::Other, sourceCode.jsSourceCode(), m_workerGlobalScopeWrapper-&gt;globalThis(), returnedException);</span>
  
      if ((returnedException &amp;&amp; isTerminatedExecutionException(vm, returnedException)) || isTerminatingExecution()) {
          forbidExecution();
          return;
      }
<span class="line-new-header">--- 132,26 ---</span>
  
      NakedPtr&lt;JSC::Exception&gt; exception;
      evaluate(sourceCode, exception, returnedExceptionMessage);
      if (exception) {
          JSLockHolder lock(vm());
<span class="line-modified">!         reportException(m_workerGlobalScopeWrapper.get(), exception);</span>
      }
  }
  
  void WorkerScriptController::evaluate(const ScriptSourceCode&amp; sourceCode, NakedPtr&lt;JSC::Exception&gt;&amp; returnedException, String* returnedExceptionMessage)
  {
      if (isExecutionForbidden())
          return;
  
      initScriptIfNeeded();
  
<span class="line-modified">!     auto&amp; globalObject = *m_workerGlobalScopeWrapper.get();</span>
<span class="line-modified">!     VM&amp; vm = globalObject.vm();</span>
      JSLockHolder lock { vm };
  
<span class="line-modified">!     JSExecState::profiledEvaluate(&amp;globalObject, JSC::ProfilingReason::Other, sourceCode.jsSourceCode(), m_workerGlobalScopeWrapper-&gt;globalThis(), returnedException);</span>
  
      if ((returnedException &amp;&amp; isTerminatedExecutionException(vm, returnedException)) || isTerminatingExecution()) {
          forbidExecution();
          return;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 159,38 ***</span>
      if (returnedException) {
          if (m_workerGlobalScope-&gt;canIncludeErrorDetails(sourceCode.cachedScript(), sourceCode.url().string())) {
              // FIXME: It&#39;s not great that this can run arbitrary code to string-ify the value of the exception.
              // Do we need to do anything to handle that properly, if it, say, raises another exception?
              if (returnedExceptionMessage)
<span class="line-modified">!                 *returnedExceptionMessage = returnedException-&gt;value().toWTFString(&amp;state);</span>
          } else {
              // Overwrite the detailed error with a generic error.
              String genericErrorMessage { &quot;Script error.&quot;_s };
              if (returnedExceptionMessage)
                  *returnedExceptionMessage = genericErrorMessage;
<span class="line-modified">!             returnedException = JSC::Exception::create(vm, createError(&amp;state, genericErrorMessage));</span>
          }
      }
  }
  
  void WorkerScriptController::setException(JSC::Exception* exception)
  {
<span class="line-modified">!     JSC::ExecState* exec = m_workerGlobalScopeWrapper-&gt;globalExec();</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     throwException(exec, scope, exception);</span>
  }
  
  void WorkerScriptController::scheduleExecutionTermination()
  {
      if (m_isTerminatingExecution)
          return;
  
      {
          // The mutex provides a memory barrier to ensure that once
          // termination is scheduled, isTerminatingExecution() will
<span class="line-modified">!         // accurately reflect that state when called from another thread.</span>
          LockHolder locker(m_scheduledTerminationMutex);
          m_isTerminatingExecution = true;
      }
      m_vm-&gt;notifyNeedTermination();
  }
<span class="line-new-header">--- 159,38 ---</span>
      if (returnedException) {
          if (m_workerGlobalScope-&gt;canIncludeErrorDetails(sourceCode.cachedScript(), sourceCode.url().string())) {
              // FIXME: It&#39;s not great that this can run arbitrary code to string-ify the value of the exception.
              // Do we need to do anything to handle that properly, if it, say, raises another exception?
              if (returnedExceptionMessage)
<span class="line-modified">!                 *returnedExceptionMessage = returnedException-&gt;value().toWTFString(&amp;globalObject);</span>
          } else {
              // Overwrite the detailed error with a generic error.
              String genericErrorMessage { &quot;Script error.&quot;_s };
              if (returnedExceptionMessage)
                  *returnedExceptionMessage = genericErrorMessage;
<span class="line-modified">!             returnedException = JSC::Exception::create(vm, createError(&amp;globalObject, genericErrorMessage));</span>
          }
      }
  }
  
  void WorkerScriptController::setException(JSC::Exception* exception)
  {
<span class="line-modified">!     JSC::JSGlobalObject* lexicalGlobalObject = m_workerGlobalScopeWrapper.get();</span>
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     throwException(lexicalGlobalObject, scope, exception);</span>
  }
  
  void WorkerScriptController::scheduleExecutionTermination()
  {
      if (m_isTerminatingExecution)
          return;
  
      {
          // The mutex provides a memory barrier to ensure that once
          // termination is scheduled, isTerminatingExecution() will
<span class="line-modified">!         // accurately reflect that lexicalGlobalObject when called from another thread.</span>
          LockHolder locker(m_scheduledTerminationMutex);
          m_isTerminatingExecution = true;
      }
      m_vm-&gt;notifyNeedTermination();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 248,11 ***</span>
          timer-&gt;addTimerSetNotification(callback);
      };
  
      processTimer(m_vm-&gt;heap.fullActivityCallback());
      processTimer(m_vm-&gt;heap.edenActivityCallback());
<span class="line-modified">!     processTimer(m_vm-&gt;promiseDeferredTimer.ptr());</span>
  }
  
  void WorkerScriptController::removeTimerSetNotification(JSC::JSRunLoopTimer::TimerNotificationCallback callback)
  {
      auto processTimer = [&amp;] (JSRunLoopTimer* timer) {
<span class="line-new-header">--- 248,11 ---</span>
          timer-&gt;addTimerSetNotification(callback);
      };
  
      processTimer(m_vm-&gt;heap.fullActivityCallback());
      processTimer(m_vm-&gt;heap.edenActivityCallback());
<span class="line-modified">!     processTimer(m_vm-&gt;promiseTimer.ptr());</span>
  }
  
  void WorkerScriptController::removeTimerSetNotification(JSC::JSRunLoopTimer::TimerNotificationCallback callback)
  {
      auto processTimer = [&amp;] (JSRunLoopTimer* timer) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 261,20 ***</span>
          timer-&gt;removeTimerSetNotification(callback);
      };
  
      processTimer(m_vm-&gt;heap.fullActivityCallback());
      processTimer(m_vm-&gt;heap.edenActivityCallback());
<span class="line-modified">!     processTimer(m_vm-&gt;promiseDeferredTimer.ptr());</span>
  }
  
  void WorkerScriptController::attachDebugger(JSC::Debugger* debugger)
  {
      initScriptIfNeeded();
<span class="line-modified">!     debugger-&gt;attach(m_workerGlobalScopeWrapper-&gt;globalObject());</span>
  }
  
  void WorkerScriptController::detachDebugger(JSC::Debugger* debugger)
  {
<span class="line-modified">!     debugger-&gt;detach(m_workerGlobalScopeWrapper-&gt;globalObject(), JSC::Debugger::TerminatingDebuggingSession);</span>
  }
  
  } // namespace WebCore
<span class="line-new-header">--- 261,20 ---</span>
          timer-&gt;removeTimerSetNotification(callback);
      };
  
      processTimer(m_vm-&gt;heap.fullActivityCallback());
      processTimer(m_vm-&gt;heap.edenActivityCallback());
<span class="line-modified">!     processTimer(m_vm-&gt;promiseTimer.ptr());</span>
  }
  
  void WorkerScriptController::attachDebugger(JSC::Debugger* debugger)
  {
      initScriptIfNeeded();
<span class="line-modified">!     debugger-&gt;attach(m_workerGlobalScopeWrapper.get());</span>
  }
  
  void WorkerScriptController::detachDebugger(JSC::Debugger* debugger)
  {
<span class="line-modified">!     debugger-&gt;detach(m_workerGlobalScopeWrapper.get(), JSC::Debugger::TerminatingDebuggingSession);</span>
  }
  
  } // namespace WebCore
</pre>
<center><a href="WindowProxy.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../scripts/CodeGenerator.pm.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
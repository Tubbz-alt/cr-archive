<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertSequences.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSDOMConvertScheduledAction.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMConvertSerializedScriptValue.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertSequences.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 25 
 26 #pragma once
 27 
 28 #include &quot;IDLTypes.h&quot;
 29 #include &quot;JSDOMConvertBase.h&quot;
 30 #include &quot;JSDOMConvertNumbers.h&quot;
 31 #include &quot;JSDOMGlobalObject.h&quot;
 32 #include &lt;JavaScriptCore/IteratorOperations.h&gt;
 33 #include &lt;JavaScriptCore/JSArray.h&gt;
 34 #include &lt;JavaScriptCore/JSGlobalObjectInlines.h&gt;
 35 #include &lt;JavaScriptCore/ObjectConstructor.h&gt;
 36 
 37 namespace WebCore {
 38 
 39 namespace Detail {
 40 
 41 template&lt;typename IDLType&gt;
 42 struct GenericSequenceConverter {
 43     using ReturnType = Vector&lt;typename IDLType::ImplementationType&gt;;
 44 
<span class="line-modified"> 45     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object)</span>
 46     {
<span class="line-modified"> 47         return convert(state, object, ReturnType());</span>
 48     }
 49 
<span class="line-modified"> 50     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object, ReturnType&amp;&amp; result)</span>
 51     {
<span class="line-modified"> 52         forEachInIterable(&amp;state, object, [&amp;result](JSC::VM&amp; vm, JSC::ExecState* state, JSC::JSValue nextValue) {</span>
 53             auto scope = DECLARE_THROW_SCOPE(vm);
 54 
<span class="line-modified"> 55             auto convertedValue = Converter&lt;IDLType&gt;::convert(*state, nextValue);</span>
 56             if (UNLIKELY(scope.exception()))
 57                 return;
 58             result.append(WTFMove(convertedValue));
 59         });
 60         return WTFMove(result);
 61     }
 62 
<span class="line-modified"> 63     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object, JSC::JSValue method)</span>
 64     {
<span class="line-modified"> 65         return convert(state, object, method, ReturnType());</span>
 66     }
 67 
<span class="line-modified"> 68     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object, JSC::JSValue method, ReturnType&amp;&amp; result)</span>
 69     {
<span class="line-modified"> 70         forEachInIterable(state, object, method, [&amp;result](JSC::VM&amp; vm, JSC::ExecState&amp; state, JSC::JSValue nextValue) {</span>
 71             auto scope = DECLARE_THROW_SCOPE(vm);
 72 
<span class="line-modified"> 73             auto convertedValue = Converter&lt;IDLType&gt;::convert(state, nextValue);</span>
 74             if (UNLIKELY(scope.exception()))
 75                 return;
 76             result.append(WTFMove(convertedValue));
 77         });
 78         return WTFMove(result);
 79     }
 80 };
 81 
 82 // Specialization for numeric types
 83 // FIXME: This is only implemented for the IDLFloatingPointTypes and IDLLong. To add
 84 // support for more numeric types, add an overload of Converter&lt;IDLType&gt;::convert that
 85 // takes an ExecState, ThrowScope, double as its arguments.
 86 template&lt;typename IDLType&gt;
 87 struct NumericSequenceConverter {
 88     using GenericConverter = GenericSequenceConverter&lt;IDLType&gt;;
 89     using ReturnType = typename GenericConverter::ReturnType;
 90 
<span class="line-modified"> 91     static ReturnType convertArray(JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope, JSC::JSArray* array, unsigned length, JSC::IndexingType indexingType, ReturnType&amp;&amp; result)</span>
 92     {
 93         if (indexingType == JSC::Int32Shape) {
 94             for (unsigned i = 0; i &lt; length; i++) {
 95                 auto indexValue = array-&gt;butterfly()-&gt;contiguousInt32().at(array, i).get();
 96                 ASSERT(!indexValue || indexValue.isInt32());
 97                 if (!indexValue)
 98                     result.uncheckedAppend(0);
 99                 else
100                     result.uncheckedAppend(indexValue.asInt32());
101             }
102             return WTFMove(result);
103         }
104 
105         ASSERT(indexingType == JSC::DoubleShape);
106         for (unsigned i = 0; i &lt; length; i++) {
107             double doubleValue = array-&gt;butterfly()-&gt;contiguousDouble().at(array, i);
108             if (std::isnan(doubleValue))
109                 result.uncheckedAppend(0);
110             else {
<span class="line-modified">111                 auto convertedValue = Converter&lt;IDLType&gt;::convert(state, scope, doubleValue);</span>
112                 RETURN_IF_EXCEPTION(scope, { });
113 
114                 result.uncheckedAppend(convertedValue);
115             }
116         }
117         return WTFMove(result);
118     }
119 
<span class="line-modified">120     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value)</span>
121     {
<span class="line-modified">122         auto&amp; vm = state.vm();</span>
123         auto scope = DECLARE_THROW_SCOPE(vm);
124 
125         if (!value.isObject()) {
<span class="line-modified">126             throwSequenceTypeError(state, scope);</span>
127             return { };
128         }
129 
130         JSC::JSObject* object = JSC::asObject(value);
131         if (!JSC::isJSArray(object))
<span class="line-modified">132             return GenericConverter::convert(state, object);</span>
133 
134         JSC::JSArray* array = JSC::asArray(object);
135         if (!array-&gt;isIteratorProtocolFastAndNonObservable())
<span class="line-modified">136             return GenericConverter::convert(state, object);</span>
137 
138         unsigned length = array-&gt;length();
139         ReturnType result;
140         // If we&#39;re not an int32/double array, it&#39;s possible that converting a
141         // JSValue to a number could cause the iterator protocol to change, hence,
142         // we may need more capacity, or less. In such cases, we use the length
143         // as a proxy for the capacity we will most likely need (it&#39;s unlikely that
144         // a program is written with a valueOf that will augment the iterator protocol).
145         // If we are an int32/double array, then length is precisely the capacity we need.
146         if (!result.tryReserveCapacity(length)) {
147             // FIXME: Is the right exception to throw?
<span class="line-modified">148             throwTypeError(&amp;state, scope);</span>
149             return { };
150         }
151 
152         JSC::IndexingType indexingType = array-&gt;indexingType() &amp; JSC::IndexingShapeMask;
153         if (indexingType != JSC::Int32Shape &amp;&amp; indexingType != JSC::DoubleShape)
<span class="line-modified">154             return GenericConverter::convert(state, object, WTFMove(result));</span>
155 
<span class="line-modified">156         return convertArray(state, scope, array, length, indexingType, WTFMove(result));</span>
157     }
158 
<span class="line-modified">159     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object, JSC::JSValue method)</span>
160     {
<span class="line-modified">161         auto&amp; vm = state.vm();</span>
162         auto scope = DECLARE_THROW_SCOPE(vm);
163 
164         if (!JSC::isJSArray(object))
<span class="line-modified">165             return GenericConverter::convert(state, object, method);</span>
166 
167         JSC::JSArray* array = JSC::asArray(object);
168         if (!array-&gt;isIteratorProtocolFastAndNonObservable())
<span class="line-modified">169             return GenericConverter::convert(state, object, method);</span>
170 
171         unsigned length = array-&gt;length();
172         ReturnType result;
173         // If we&#39;re not an int32/double array, it&#39;s possible that converting a
174         // JSValue to a number could cause the iterator protocol to change, hence,
175         // we may need more capacity, or less. In such cases, we use the length
176         // as a proxy for the capacity we will most likely need (it&#39;s unlikely that
177         // a program is written with a valueOf that will augment the iterator protocol).
178         // If we are an int32/double array, then length is precisely the capacity we need.
179         if (!result.tryReserveCapacity(length)) {
180             // FIXME: Is the right exception to throw?
<span class="line-modified">181             throwTypeError(&amp;state, scope);</span>
182             return { };
183         }
184 
185         JSC::IndexingType indexingType = array-&gt;indexingType() &amp; JSC::IndexingShapeMask;
186         if (indexingType != JSC::Int32Shape &amp;&amp; indexingType != JSC::DoubleShape)
<span class="line-modified">187             return GenericConverter::convert(state, object, method, WTFMove(result));</span>
188 
<span class="line-modified">189         return convertArray(state, scope, array, length, indexingType, WTFMove(result));</span>
190     }
191 };
192 
193 template&lt;typename IDLType&gt;
194 struct SequenceConverter {
195     using GenericConverter = GenericSequenceConverter&lt;IDLType&gt;;
196     using ReturnType = typename GenericConverter::ReturnType;
197 
<span class="line-modified">198     static ReturnType convertArray(JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope, JSC::JSArray* array)</span>
199     {
200         unsigned length = array-&gt;length();
201 
202         ReturnType result;
203         if (!result.tryReserveCapacity(length)) {
204             // FIXME: Is the right exception to throw?
<span class="line-modified">205             throwTypeError(&amp;state, scope);</span>
206             return { };
207         }
208 
209         JSC::IndexingType indexingType = array-&gt;indexingType() &amp; JSC::IndexingShapeMask;
210 
211         if (indexingType == JSC::ContiguousShape) {
212             for (unsigned i = 0; i &lt; length; i++) {
213                 auto indexValue = array-&gt;butterfly()-&gt;contiguous().at(array, i).get();
214                 if (!indexValue)
215                     indexValue = JSC::jsUndefined();
216 
<span class="line-modified">217                 auto convertedValue = Converter&lt;IDLType&gt;::convert(state, indexValue);</span>
218                 RETURN_IF_EXCEPTION(scope, { });
219 
220                 result.uncheckedAppend(convertedValue);
221             }
222             return result;
223         }
224 
225         for (unsigned i = 0; i &lt; length; i++) {
<span class="line-modified">226             auto indexValue = array-&gt;getDirectIndex(&amp;state, i);</span>
227             RETURN_IF_EXCEPTION(scope, { });
228 
229             if (!indexValue)
230                 indexValue = JSC::jsUndefined();
231 
<span class="line-modified">232             auto convertedValue = Converter&lt;IDLType&gt;::convert(state, indexValue);</span>
233             RETURN_IF_EXCEPTION(scope, { });
234 
235             result.uncheckedAppend(convertedValue);
236         }
237         return result;
238     }
239 
<span class="line-modified">240     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value)</span>
241     {
<span class="line-modified">242         auto&amp; vm = state.vm();</span>
243         auto scope = DECLARE_THROW_SCOPE(vm);
244 
245         if (!value.isObject()) {
<span class="line-modified">246             throwSequenceTypeError(state, scope);</span>
247             return { };
248         }
249 
250         JSC::JSObject* object = JSC::asObject(value);
251         if (Converter&lt;IDLType&gt;::conversionHasSideEffects)
<span class="line-modified">252             return GenericConverter::convert(state, object);</span>
253 
254         if (!JSC::isJSArray(object))
<span class="line-modified">255             return GenericConverter::convert(state, object);</span>
256 
257         JSC::JSArray* array = JSC::asArray(object);
258         if (!array-&gt;isIteratorProtocolFastAndNonObservable())
<span class="line-modified">259             return GenericConverter::convert(state, object);</span>
260 
<span class="line-modified">261         return convertArray(state, scope, array);</span>
262     }
263 
<span class="line-modified">264     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object, JSC::JSValue method)</span>
265     {
<span class="line-modified">266         auto&amp; vm = state.vm();</span>
267         auto scope = DECLARE_THROW_SCOPE(vm);
268 
269         if (Converter&lt;IDLType&gt;::conversionHasSideEffects)
<span class="line-modified">270             return GenericConverter::convert(state, object, method);</span>
271 
272         if (!JSC::isJSArray(object))
<span class="line-modified">273             return GenericConverter::convert(state, object, method);</span>
274 
275         JSC::JSArray* array = JSC::asArray(object);
276         if (!array-&gt;isIteratorProtocolFastAndNonObservable())
<span class="line-modified">277             return GenericConverter::convert(state, object, method);</span>
278 
<span class="line-modified">279         return convertArray(state, scope, array);</span>
280     }
281 };
282 
283 template&lt;&gt;
284 struct SequenceConverter&lt;IDLLong&gt; {
285     using ReturnType = typename GenericSequenceConverter&lt;IDLLong&gt;::ReturnType;
286 
<span class="line-modified">287     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value)</span>
288     {
<span class="line-modified">289         return NumericSequenceConverter&lt;IDLLong&gt;::convert(state, value);</span>
290     }
291 
<span class="line-modified">292     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object, JSC::JSValue method)</span>
293     {
<span class="line-modified">294         return NumericSequenceConverter&lt;IDLLong&gt;::convert(state, object, method);</span>
295     }
296 };
297 
298 template&lt;&gt;
299 struct SequenceConverter&lt;IDLFloat&gt; {
300     using ReturnType = typename GenericSequenceConverter&lt;IDLFloat&gt;::ReturnType;
301 
<span class="line-modified">302     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value)</span>
303     {
<span class="line-modified">304         return NumericSequenceConverter&lt;IDLFloat&gt;::convert(state, value);</span>
305     }
306 
<span class="line-modified">307     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object, JSC::JSValue method)</span>
308     {
<span class="line-modified">309         return NumericSequenceConverter&lt;IDLFloat&gt;::convert(state, object, method);</span>
310     }
311 };
312 
313 template&lt;&gt;
314 struct SequenceConverter&lt;IDLUnrestrictedFloat&gt; {
315     using ReturnType = typename GenericSequenceConverter&lt;IDLUnrestrictedFloat&gt;::ReturnType;
316 
<span class="line-modified">317     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value)</span>
318     {
<span class="line-modified">319         return NumericSequenceConverter&lt;IDLUnrestrictedFloat&gt;::convert(state, value);</span>
320     }
321 
<span class="line-modified">322     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object, JSC::JSValue method)</span>
323     {
<span class="line-modified">324         return NumericSequenceConverter&lt;IDLUnrestrictedFloat&gt;::convert(state, object, method);</span>
325     }
326 };
327 
328 template&lt;&gt;
329 struct SequenceConverter&lt;IDLDouble&gt; {
330     using ReturnType = typename GenericSequenceConverter&lt;IDLDouble&gt;::ReturnType;
331 
<span class="line-modified">332     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value)</span>
333     {
<span class="line-modified">334         return NumericSequenceConverter&lt;IDLDouble&gt;::convert(state, value);</span>
335     }
336 
<span class="line-modified">337     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object, JSC::JSValue method)</span>
338     {
<span class="line-modified">339         return NumericSequenceConverter&lt;IDLDouble&gt;::convert(state, object, method);</span>
340     }
341 };
342 
343 template&lt;&gt;
344 struct SequenceConverter&lt;IDLUnrestrictedDouble&gt; {
345     using ReturnType = typename GenericSequenceConverter&lt;IDLUnrestrictedDouble&gt;::ReturnType;
346 
<span class="line-modified">347     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value)</span>
348     {
<span class="line-modified">349         return NumericSequenceConverter&lt;IDLUnrestrictedDouble&gt;::convert(state, value);</span>
350     }
351 
<span class="line-modified">352     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object, JSC::JSValue method)</span>
353     {
<span class="line-modified">354         return NumericSequenceConverter&lt;IDLUnrestrictedDouble&gt;::convert(state, object, method);</span>
355     }
356 };
357 
358 }
359 
360 template&lt;typename T&gt; struct Converter&lt;IDLSequence&lt;T&gt;&gt; : DefaultConverter&lt;IDLSequence&lt;T&gt;&gt; {
361     using ReturnType = typename Detail::SequenceConverter&lt;T&gt;::ReturnType;
362 
<span class="line-modified">363     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value)</span>
364     {
<span class="line-modified">365         return Detail::SequenceConverter&lt;T&gt;::convert(state, value);</span>
366     }
367 
<span class="line-modified">368     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object, JSC::JSValue method)</span>
369     {
<span class="line-modified">370         return Detail::SequenceConverter&lt;T&gt;::convert(state, object, method);</span>
371     }
372 };
373 
374 template&lt;typename T&gt; struct JSConverter&lt;IDLSequence&lt;T&gt;&gt; {
375     static constexpr bool needsState = true;
376     static constexpr bool needsGlobalObject = true;
377 
378     template&lt;typename U, size_t inlineCapacity&gt;
<span class="line-modified">379     static JSC::JSValue convert(JSC::ExecState&amp; exec, JSDOMGlobalObject&amp; globalObject, const Vector&lt;U, inlineCapacity&gt;&amp; vector)</span>
380     {
<span class="line-modified">381         JSC::VM&amp; vm = exec.vm();</span>
382         auto scope = DECLARE_THROW_SCOPE(vm);
383         JSC::MarkedArgumentBuffer list;
384         for (auto&amp; element : vector)
<span class="line-modified">385             list.append(toJS&lt;T&gt;(exec, globalObject, element));</span>
386         if (UNLIKELY(list.hasOverflowed())) {
<span class="line-modified">387             throwOutOfMemoryError(&amp;exec, scope);</span>
388             return { };
389         }
<span class="line-modified">390         return JSC::constructArray(&amp;exec, nullptr, &amp;globalObject, list);</span>
391     }
392 };
393 
394 template&lt;typename T&gt; struct Converter&lt;IDLFrozenArray&lt;T&gt;&gt; : DefaultConverter&lt;IDLFrozenArray&lt;T&gt;&gt; {
395     using ReturnType = typename Detail::SequenceConverter&lt;T&gt;::ReturnType;
396 
<span class="line-modified">397     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value)</span>
398     {
<span class="line-modified">399         return Detail::SequenceConverter&lt;T&gt;::convert(state, value);</span>
400     }
401 
<span class="line-modified">402     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSObject* object, JSC::JSValue method)</span>
403     {
<span class="line-modified">404         return Detail::SequenceConverter&lt;T&gt;::convert(state, object, method);</span>
405     }
406 };
407 
408 template&lt;typename T&gt; struct JSConverter&lt;IDLFrozenArray&lt;T&gt;&gt; {
409     static constexpr bool needsState = true;
410     static constexpr bool needsGlobalObject = true;
411 
412     template&lt;typename U, size_t inlineCapacity&gt;
<span class="line-modified">413     static JSC::JSValue convert(JSC::ExecState&amp; exec, JSDOMGlobalObject&amp; globalObject, const Vector&lt;U, inlineCapacity&gt;&amp; vector)</span>
414     {
<span class="line-modified">415         JSC::VM&amp; vm = exec.vm();</span>
416         auto scope = DECLARE_THROW_SCOPE(vm);
417         JSC::MarkedArgumentBuffer list;
418         for (auto&amp; element : vector)
<span class="line-modified">419             list.append(toJS&lt;T&gt;(exec, globalObject, element));</span>
420         if (UNLIKELY(list.hasOverflowed())) {
<span class="line-modified">421             throwOutOfMemoryError(&amp;exec, scope);</span>
422             return { };
423         }
<span class="line-modified">424         auto* array = JSC::constructArray(&amp;exec, nullptr, &amp;globalObject, list);</span>
<span class="line-modified">425         return JSC::objectConstructorFreeze(&amp;exec, array);</span>
426     }
427 };
428 
429 } // namespace WebCore
430 
</pre>
</td>
<td>
<hr />
<pre>
 25 
 26 #pragma once
 27 
 28 #include &quot;IDLTypes.h&quot;
 29 #include &quot;JSDOMConvertBase.h&quot;
 30 #include &quot;JSDOMConvertNumbers.h&quot;
 31 #include &quot;JSDOMGlobalObject.h&quot;
 32 #include &lt;JavaScriptCore/IteratorOperations.h&gt;
 33 #include &lt;JavaScriptCore/JSArray.h&gt;
 34 #include &lt;JavaScriptCore/JSGlobalObjectInlines.h&gt;
 35 #include &lt;JavaScriptCore/ObjectConstructor.h&gt;
 36 
 37 namespace WebCore {
 38 
 39 namespace Detail {
 40 
 41 template&lt;typename IDLType&gt;
 42 struct GenericSequenceConverter {
 43     using ReturnType = Vector&lt;typename IDLType::ImplementationType&gt;;
 44 
<span class="line-modified"> 45     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject* object)</span>
 46     {
<span class="line-modified"> 47         return convert(lexicalGlobalObject, object, ReturnType());</span>
 48     }
 49 
<span class="line-modified"> 50     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject* object, ReturnType&amp;&amp; result)</span>
 51     {
<span class="line-modified"> 52         forEachInIterable(&amp;lexicalGlobalObject, object, [&amp;result](JSC::VM&amp; vm, JSC::JSGlobalObject* lexicalGlobalObject, JSC::JSValue nextValue) {</span>
 53             auto scope = DECLARE_THROW_SCOPE(vm);
 54 
<span class="line-modified"> 55             auto convertedValue = Converter&lt;IDLType&gt;::convert(*lexicalGlobalObject, nextValue);</span>
 56             if (UNLIKELY(scope.exception()))
 57                 return;
 58             result.append(WTFMove(convertedValue));
 59         });
 60         return WTFMove(result);
 61     }
 62 
<span class="line-modified"> 63     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject* object, JSC::JSValue method)</span>
 64     {
<span class="line-modified"> 65         return convert(lexicalGlobalObject, object, method, ReturnType());</span>
 66     }
 67 
<span class="line-modified"> 68     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject* object, JSC::JSValue method, ReturnType&amp;&amp; result)</span>
 69     {
<span class="line-modified"> 70         forEachInIterable(lexicalGlobalObject, object, method, [&amp;result](JSC::VM&amp; vm, JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue nextValue) {</span>
 71             auto scope = DECLARE_THROW_SCOPE(vm);
 72 
<span class="line-modified"> 73             auto convertedValue = Converter&lt;IDLType&gt;::convert(lexicalGlobalObject, nextValue);</span>
 74             if (UNLIKELY(scope.exception()))
 75                 return;
 76             result.append(WTFMove(convertedValue));
 77         });
 78         return WTFMove(result);
 79     }
 80 };
 81 
 82 // Specialization for numeric types
 83 // FIXME: This is only implemented for the IDLFloatingPointTypes and IDLLong. To add
 84 // support for more numeric types, add an overload of Converter&lt;IDLType&gt;::convert that
 85 // takes an ExecState, ThrowScope, double as its arguments.
 86 template&lt;typename IDLType&gt;
 87 struct NumericSequenceConverter {
 88     using GenericConverter = GenericSequenceConverter&lt;IDLType&gt;;
 89     using ReturnType = typename GenericConverter::ReturnType;
 90 
<span class="line-modified"> 91     static ReturnType convertArray(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope, JSC::JSArray* array, unsigned length, JSC::IndexingType indexingType, ReturnType&amp;&amp; result)</span>
 92     {
 93         if (indexingType == JSC::Int32Shape) {
 94             for (unsigned i = 0; i &lt; length; i++) {
 95                 auto indexValue = array-&gt;butterfly()-&gt;contiguousInt32().at(array, i).get();
 96                 ASSERT(!indexValue || indexValue.isInt32());
 97                 if (!indexValue)
 98                     result.uncheckedAppend(0);
 99                 else
100                     result.uncheckedAppend(indexValue.asInt32());
101             }
102             return WTFMove(result);
103         }
104 
105         ASSERT(indexingType == JSC::DoubleShape);
106         for (unsigned i = 0; i &lt; length; i++) {
107             double doubleValue = array-&gt;butterfly()-&gt;contiguousDouble().at(array, i);
108             if (std::isnan(doubleValue))
109                 result.uncheckedAppend(0);
110             else {
<span class="line-modified">111                 auto convertedValue = Converter&lt;IDLType&gt;::convert(lexicalGlobalObject, scope, doubleValue);</span>
112                 RETURN_IF_EXCEPTION(scope, { });
113 
114                 result.uncheckedAppend(convertedValue);
115             }
116         }
117         return WTFMove(result);
118     }
119 
<span class="line-modified">120     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
121     {
<span class="line-modified">122         auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
123         auto scope = DECLARE_THROW_SCOPE(vm);
124 
125         if (!value.isObject()) {
<span class="line-modified">126             throwSequenceTypeError(lexicalGlobalObject, scope);</span>
127             return { };
128         }
129 
130         JSC::JSObject* object = JSC::asObject(value);
131         if (!JSC::isJSArray(object))
<span class="line-modified">132             return GenericConverter::convert(lexicalGlobalObject, object);</span>
133 
134         JSC::JSArray* array = JSC::asArray(object);
135         if (!array-&gt;isIteratorProtocolFastAndNonObservable())
<span class="line-modified">136             return GenericConverter::convert(lexicalGlobalObject, object);</span>
137 
138         unsigned length = array-&gt;length();
139         ReturnType result;
140         // If we&#39;re not an int32/double array, it&#39;s possible that converting a
141         // JSValue to a number could cause the iterator protocol to change, hence,
142         // we may need more capacity, or less. In such cases, we use the length
143         // as a proxy for the capacity we will most likely need (it&#39;s unlikely that
144         // a program is written with a valueOf that will augment the iterator protocol).
145         // If we are an int32/double array, then length is precisely the capacity we need.
146         if (!result.tryReserveCapacity(length)) {
147             // FIXME: Is the right exception to throw?
<span class="line-modified">148             throwTypeError(&amp;lexicalGlobalObject, scope);</span>
149             return { };
150         }
151 
152         JSC::IndexingType indexingType = array-&gt;indexingType() &amp; JSC::IndexingShapeMask;
153         if (indexingType != JSC::Int32Shape &amp;&amp; indexingType != JSC::DoubleShape)
<span class="line-modified">154             return GenericConverter::convert(lexicalGlobalObject, object, WTFMove(result));</span>
155 
<span class="line-modified">156         return convertArray(lexicalGlobalObject, scope, array, length, indexingType, WTFMove(result));</span>
157     }
158 
<span class="line-modified">159     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject* object, JSC::JSValue method)</span>
160     {
<span class="line-modified">161         auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
162         auto scope = DECLARE_THROW_SCOPE(vm);
163 
164         if (!JSC::isJSArray(object))
<span class="line-modified">165             return GenericConverter::convert(lexicalGlobalObject, object, method);</span>
166 
167         JSC::JSArray* array = JSC::asArray(object);
168         if (!array-&gt;isIteratorProtocolFastAndNonObservable())
<span class="line-modified">169             return GenericConverter::convert(lexicalGlobalObject, object, method);</span>
170 
171         unsigned length = array-&gt;length();
172         ReturnType result;
173         // If we&#39;re not an int32/double array, it&#39;s possible that converting a
174         // JSValue to a number could cause the iterator protocol to change, hence,
175         // we may need more capacity, or less. In such cases, we use the length
176         // as a proxy for the capacity we will most likely need (it&#39;s unlikely that
177         // a program is written with a valueOf that will augment the iterator protocol).
178         // If we are an int32/double array, then length is precisely the capacity we need.
179         if (!result.tryReserveCapacity(length)) {
180             // FIXME: Is the right exception to throw?
<span class="line-modified">181             throwTypeError(&amp;lexicalGlobalObject, scope);</span>
182             return { };
183         }
184 
185         JSC::IndexingType indexingType = array-&gt;indexingType() &amp; JSC::IndexingShapeMask;
186         if (indexingType != JSC::Int32Shape &amp;&amp; indexingType != JSC::DoubleShape)
<span class="line-modified">187             return GenericConverter::convert(lexicalGlobalObject, object, method, WTFMove(result));</span>
188 
<span class="line-modified">189         return convertArray(lexicalGlobalObject, scope, array, length, indexingType, WTFMove(result));</span>
190     }
191 };
192 
193 template&lt;typename IDLType&gt;
194 struct SequenceConverter {
195     using GenericConverter = GenericSequenceConverter&lt;IDLType&gt;;
196     using ReturnType = typename GenericConverter::ReturnType;
197 
<span class="line-modified">198     static ReturnType convertArray(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope, JSC::JSArray* array)</span>
199     {
200         unsigned length = array-&gt;length();
201 
202         ReturnType result;
203         if (!result.tryReserveCapacity(length)) {
204             // FIXME: Is the right exception to throw?
<span class="line-modified">205             throwTypeError(&amp;lexicalGlobalObject, scope);</span>
206             return { };
207         }
208 
209         JSC::IndexingType indexingType = array-&gt;indexingType() &amp; JSC::IndexingShapeMask;
210 
211         if (indexingType == JSC::ContiguousShape) {
212             for (unsigned i = 0; i &lt; length; i++) {
213                 auto indexValue = array-&gt;butterfly()-&gt;contiguous().at(array, i).get();
214                 if (!indexValue)
215                     indexValue = JSC::jsUndefined();
216 
<span class="line-modified">217                 auto convertedValue = Converter&lt;IDLType&gt;::convert(lexicalGlobalObject, indexValue);</span>
218                 RETURN_IF_EXCEPTION(scope, { });
219 
220                 result.uncheckedAppend(convertedValue);
221             }
222             return result;
223         }
224 
225         for (unsigned i = 0; i &lt; length; i++) {
<span class="line-modified">226             auto indexValue = array-&gt;getDirectIndex(&amp;lexicalGlobalObject, i);</span>
227             RETURN_IF_EXCEPTION(scope, { });
228 
229             if (!indexValue)
230                 indexValue = JSC::jsUndefined();
231 
<span class="line-modified">232             auto convertedValue = Converter&lt;IDLType&gt;::convert(lexicalGlobalObject, indexValue);</span>
233             RETURN_IF_EXCEPTION(scope, { });
234 
235             result.uncheckedAppend(convertedValue);
236         }
237         return result;
238     }
239 
<span class="line-modified">240     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
241     {
<span class="line-modified">242         auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
243         auto scope = DECLARE_THROW_SCOPE(vm);
244 
245         if (!value.isObject()) {
<span class="line-modified">246             throwSequenceTypeError(lexicalGlobalObject, scope);</span>
247             return { };
248         }
249 
250         JSC::JSObject* object = JSC::asObject(value);
251         if (Converter&lt;IDLType&gt;::conversionHasSideEffects)
<span class="line-modified">252             return GenericConverter::convert(lexicalGlobalObject, object);</span>
253 
254         if (!JSC::isJSArray(object))
<span class="line-modified">255             return GenericConverter::convert(lexicalGlobalObject, object);</span>
256 
257         JSC::JSArray* array = JSC::asArray(object);
258         if (!array-&gt;isIteratorProtocolFastAndNonObservable())
<span class="line-modified">259             return GenericConverter::convert(lexicalGlobalObject, object);</span>
260 
<span class="line-modified">261         return convertArray(lexicalGlobalObject, scope, array);</span>
262     }
263 
<span class="line-modified">264     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject* object, JSC::JSValue method)</span>
265     {
<span class="line-modified">266         auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
267         auto scope = DECLARE_THROW_SCOPE(vm);
268 
269         if (Converter&lt;IDLType&gt;::conversionHasSideEffects)
<span class="line-modified">270             return GenericConverter::convert(lexicalGlobalObject, object, method);</span>
271 
272         if (!JSC::isJSArray(object))
<span class="line-modified">273             return GenericConverter::convert(lexicalGlobalObject, object, method);</span>
274 
275         JSC::JSArray* array = JSC::asArray(object);
276         if (!array-&gt;isIteratorProtocolFastAndNonObservable())
<span class="line-modified">277             return GenericConverter::convert(lexicalGlobalObject, object, method);</span>
278 
<span class="line-modified">279         return convertArray(lexicalGlobalObject, scope, array);</span>
280     }
281 };
282 
283 template&lt;&gt;
284 struct SequenceConverter&lt;IDLLong&gt; {
285     using ReturnType = typename GenericSequenceConverter&lt;IDLLong&gt;::ReturnType;
286 
<span class="line-modified">287     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
288     {
<span class="line-modified">289         return NumericSequenceConverter&lt;IDLLong&gt;::convert(lexicalGlobalObject, value);</span>
290     }
291 
<span class="line-modified">292     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject* object, JSC::JSValue method)</span>
293     {
<span class="line-modified">294         return NumericSequenceConverter&lt;IDLLong&gt;::convert(lexicalGlobalObject, object, method);</span>
295     }
296 };
297 
298 template&lt;&gt;
299 struct SequenceConverter&lt;IDLFloat&gt; {
300     using ReturnType = typename GenericSequenceConverter&lt;IDLFloat&gt;::ReturnType;
301 
<span class="line-modified">302     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
303     {
<span class="line-modified">304         return NumericSequenceConverter&lt;IDLFloat&gt;::convert(lexicalGlobalObject, value);</span>
305     }
306 
<span class="line-modified">307     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject* object, JSC::JSValue method)</span>
308     {
<span class="line-modified">309         return NumericSequenceConverter&lt;IDLFloat&gt;::convert(lexicalGlobalObject, object, method);</span>
310     }
311 };
312 
313 template&lt;&gt;
314 struct SequenceConverter&lt;IDLUnrestrictedFloat&gt; {
315     using ReturnType = typename GenericSequenceConverter&lt;IDLUnrestrictedFloat&gt;::ReturnType;
316 
<span class="line-modified">317     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
318     {
<span class="line-modified">319         return NumericSequenceConverter&lt;IDLUnrestrictedFloat&gt;::convert(lexicalGlobalObject, value);</span>
320     }
321 
<span class="line-modified">322     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject* object, JSC::JSValue method)</span>
323     {
<span class="line-modified">324         return NumericSequenceConverter&lt;IDLUnrestrictedFloat&gt;::convert(lexicalGlobalObject, object, method);</span>
325     }
326 };
327 
328 template&lt;&gt;
329 struct SequenceConverter&lt;IDLDouble&gt; {
330     using ReturnType = typename GenericSequenceConverter&lt;IDLDouble&gt;::ReturnType;
331 
<span class="line-modified">332     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
333     {
<span class="line-modified">334         return NumericSequenceConverter&lt;IDLDouble&gt;::convert(lexicalGlobalObject, value);</span>
335     }
336 
<span class="line-modified">337     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject* object, JSC::JSValue method)</span>
338     {
<span class="line-modified">339         return NumericSequenceConverter&lt;IDLDouble&gt;::convert(lexicalGlobalObject, object, method);</span>
340     }
341 };
342 
343 template&lt;&gt;
344 struct SequenceConverter&lt;IDLUnrestrictedDouble&gt; {
345     using ReturnType = typename GenericSequenceConverter&lt;IDLUnrestrictedDouble&gt;::ReturnType;
346 
<span class="line-modified">347     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
348     {
<span class="line-modified">349         return NumericSequenceConverter&lt;IDLUnrestrictedDouble&gt;::convert(lexicalGlobalObject, value);</span>
350     }
351 
<span class="line-modified">352     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject* object, JSC::JSValue method)</span>
353     {
<span class="line-modified">354         return NumericSequenceConverter&lt;IDLUnrestrictedDouble&gt;::convert(lexicalGlobalObject, object, method);</span>
355     }
356 };
357 
358 }
359 
360 template&lt;typename T&gt; struct Converter&lt;IDLSequence&lt;T&gt;&gt; : DefaultConverter&lt;IDLSequence&lt;T&gt;&gt; {
361     using ReturnType = typename Detail::SequenceConverter&lt;T&gt;::ReturnType;
362 
<span class="line-modified">363     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
364     {
<span class="line-modified">365         return Detail::SequenceConverter&lt;T&gt;::convert(lexicalGlobalObject, value);</span>
366     }
367 
<span class="line-modified">368     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject* object, JSC::JSValue method)</span>
369     {
<span class="line-modified">370         return Detail::SequenceConverter&lt;T&gt;::convert(lexicalGlobalObject, object, method);</span>
371     }
372 };
373 
374 template&lt;typename T&gt; struct JSConverter&lt;IDLSequence&lt;T&gt;&gt; {
375     static constexpr bool needsState = true;
376     static constexpr bool needsGlobalObject = true;
377 
378     template&lt;typename U, size_t inlineCapacity&gt;
<span class="line-modified">379     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const Vector&lt;U, inlineCapacity&gt;&amp; vector)</span>
380     {
<span class="line-modified">381         JSC::VM&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
382         auto scope = DECLARE_THROW_SCOPE(vm);
383         JSC::MarkedArgumentBuffer list;
384         for (auto&amp; element : vector)
<span class="line-modified">385             list.append(toJS&lt;T&gt;(lexicalGlobalObject, globalObject, element));</span>
386         if (UNLIKELY(list.hasOverflowed())) {
<span class="line-modified">387             throwOutOfMemoryError(&amp;lexicalGlobalObject, scope);</span>
388             return { };
389         }
<span class="line-modified">390         return JSC::constructArray(&amp;globalObject, static_cast&lt;JSC::ArrayAllocationProfile*&gt;(nullptr), list);</span>
391     }
392 };
393 
394 template&lt;typename T&gt; struct Converter&lt;IDLFrozenArray&lt;T&gt;&gt; : DefaultConverter&lt;IDLFrozenArray&lt;T&gt;&gt; {
395     using ReturnType = typename Detail::SequenceConverter&lt;T&gt;::ReturnType;
396 
<span class="line-modified">397     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
398     {
<span class="line-modified">399         return Detail::SequenceConverter&lt;T&gt;::convert(lexicalGlobalObject, value);</span>
400     }
401 
<span class="line-modified">402     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject* object, JSC::JSValue method)</span>
403     {
<span class="line-modified">404         return Detail::SequenceConverter&lt;T&gt;::convert(lexicalGlobalObject, object, method);</span>
405     }
406 };
407 
408 template&lt;typename T&gt; struct JSConverter&lt;IDLFrozenArray&lt;T&gt;&gt; {
409     static constexpr bool needsState = true;
410     static constexpr bool needsGlobalObject = true;
411 
412     template&lt;typename U, size_t inlineCapacity&gt;
<span class="line-modified">413     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const Vector&lt;U, inlineCapacity&gt;&amp; vector)</span>
414     {
<span class="line-modified">415         JSC::VM&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
416         auto scope = DECLARE_THROW_SCOPE(vm);
417         JSC::MarkedArgumentBuffer list;
418         for (auto&amp; element : vector)
<span class="line-modified">419             list.append(toJS&lt;T&gt;(lexicalGlobalObject, globalObject, element));</span>
420         if (UNLIKELY(list.hasOverflowed())) {
<span class="line-modified">421             throwOutOfMemoryError(&amp;lexicalGlobalObject, scope);</span>
422             return { };
423         }
<span class="line-modified">424         auto* array = JSC::constructArray(&amp;globalObject, static_cast&lt;JSC::ArrayAllocationProfile*&gt;(nullptr), list);</span>
<span class="line-modified">425         return JSC::objectConstructorFreeze(&amp;lexicalGlobalObject, array);</span>
426     }
427 };
428 
429 } // namespace WebCore
430 
</pre>
</td>
</tr>
</table>
<center><a href="JSDOMConvertScheduledAction.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMConvertSerializedScriptValue.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2003 Lars Knoll (knoll@kde.org)
  3  * Copyright (C) 2005 Allan Sandfeld Jensen (kde@carewolf.com)
  4  * Copyright (C) 2004-2016 Apple Inc. All rights reserved.
  5  * Copyright (C) 2007 Nicholas Shanks &lt;webkit@nickshanks.com&gt;
  6  * Copyright (C) 2008 Eric Seidel &lt;eric@webkit.org&gt;
  7  * Copyright (C) 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  8  * Copyright (C) 2012, 2013 Adobe Systems Incorporated. All rights reserved.
  9  * Copyright (C) 2012 Intel Corporation. All rights reserved.
 10  * Copyright (C) 2014 Google Inc. All rights reserved.
 11  *
 12  * This library is free software; you can redistribute it and/or
 13  * modify it under the terms of the GNU Library General Public
 14  * License as published by the Free Software Foundation; either
 15  * version 2 of the License, or (at your option) any later version.
 16  *
 17  * This library is distributed in the hope that it will be useful,
 18  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 19  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 20  * Library General Public License for more details.
 21  *
 22  * You should have received a copy of the GNU Library General Public License
 23  * along with this library; see the file COPYING.LIB.  If not, write to
 24  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 25  * Boston, MA 02110-1301, USA.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;CSSParser.h&quot;
 30 
 31 #include &quot;CSSCustomPropertyValue.h&quot;
 32 #include &quot;CSSKeyframeRule.h&quot;
 33 #include &quot;CSSParserFastPaths.h&quot;
 34 #include &quot;CSSParserImpl.h&quot;
 35 #include &quot;CSSParserTokenRange.h&quot;
 36 #include &quot;CSSPendingSubstitutionValue.h&quot;
 37 #include &quot;CSSPropertyParser.h&quot;
 38 #include &quot;CSSPropertyParserHelpers.h&quot;
 39 #include &quot;CSSSelectorParser.h&quot;
 40 #include &quot;CSSSupportsParser.h&quot;
 41 #include &quot;CSSTokenizer.h&quot;
 42 #include &quot;CSSValuePool.h&quot;
 43 #include &quot;CSSVariableData.h&quot;
 44 #include &quot;CSSVariableReferenceValue.h&quot;
 45 #include &quot;Document.h&quot;
 46 #include &quot;Element.h&quot;
 47 #include &quot;Page.h&quot;
 48 #include &quot;RenderStyle.h&quot;
 49 #include &quot;RenderTheme.h&quot;
 50 #include &quot;Settings.h&quot;
 51 #include &quot;StyleBuilder.h&quot;
 52 #include &quot;StyleColor.h&quot;
 53 #include &quot;StyleResolver.h&quot;
 54 #include &quot;StyleRule.h&quot;
 55 #include &quot;StyleSheetContents.h&quot;
 56 #include &lt;wtf/NeverDestroyed.h&gt;
 57 #include &lt;wtf/text/StringBuilder.h&gt;
 58 
 59 namespace WebCore {
 60 
 61 CSSParser::CSSParser(const CSSParserContext&amp; context)
 62     : m_context(context)
 63 {
 64 }
 65 
 66 CSSParser::~CSSParser() = default;
 67 
 68 void CSSParser::parseSheet(StyleSheetContents* sheet, const String&amp; string, RuleParsing ruleParsing)
 69 {
 70     return CSSParserImpl::parseStyleSheet(string, m_context, sheet, ruleParsing);
 71 }
 72 
 73 void CSSParser::parseSheetForInspector(const CSSParserContext&amp; context, StyleSheetContents* sheet, const String&amp; string, CSSParserObserver&amp; observer)
 74 {
 75     return CSSParserImpl::parseStyleSheetForInspector(string, context, sheet, observer);
 76 }
 77 
 78 RefPtr&lt;StyleRuleBase&gt; CSSParser::parseRule(const CSSParserContext&amp; context, StyleSheetContents* sheet, const String&amp; string)
 79 {
 80     return CSSParserImpl::parseRule(string, context, sheet, CSSParserImpl::AllowImportRules);
 81 }
 82 
 83 RefPtr&lt;StyleRuleKeyframe&gt; CSSParser::parseKeyframeRule(const String&amp; string)
 84 {
 85     RefPtr&lt;StyleRuleBase&gt; keyframe = CSSParserImpl::parseRule(string, m_context, nullptr, CSSParserImpl::KeyframeRules);
 86     return downcast&lt;StyleRuleKeyframe&gt;(keyframe.get());
 87 }
 88 
 89 bool CSSParser::parseSupportsCondition(const String&amp; condition)
 90 {
 91     CSSParserImpl parser(m_context, condition);
 92     return CSSSupportsParser::supportsCondition(parser.tokenizer()-&gt;tokenRange(), parser, CSSSupportsParser::ForWindowCSS) == CSSSupportsParser::Supported;
 93 }
 94 
 95 Color CSSParser::parseColor(const String&amp; string, bool strict)
 96 {
 97     if (string.isEmpty())
 98         return Color();
 99 
100     // Try named colors first.
101     Color namedColor { string };
102     if (namedColor.isValid())
103         return namedColor;
104 
105     // Try the fast path to parse hex and rgb.
106     RefPtr&lt;CSSValue&gt; value = CSSParserFastPaths::parseColor(string, strict ? HTMLStandardMode : HTMLQuirksMode, CSSValuePool::singleton());
107 
108     // If that fails, try the full parser.
109     if (!value)
110         value = parseSingleValue(CSSPropertyColor, string, strictCSSParserContext());
111     if (!value || !value-&gt;isPrimitiveValue())
112         return Color();
113     const auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*value);
114     if (!primitiveValue.isRGBColor())
115         return Color();
116     return primitiveValue.color();
117 }
118 
119 Color CSSParser::parseColorWorkerSafe(const String&amp; string, CSSValuePool&amp; valuePool, bool strict)
120 {
121     if (string.isEmpty())
122         return Color();
123 
124     // Try named colors first.
125     Color namedColor { string };
126     if (namedColor.isValid())
127         return namedColor;
128 
129     // Try the fast path to parse hex and rgb.
130     RefPtr&lt;CSSValue&gt; value = CSSParserFastPaths::parseColor(string, strict ? HTMLStandardMode : HTMLQuirksMode, valuePool);
131 
132     if (!value || !value-&gt;isPrimitiveValue())
133         return Color();
134     const auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*value);
135     if (!primitiveValue.isRGBColor())
136         return Color();
137     return primitiveValue.color();
138 }
139 
140 Color CSSParser::parseSystemColor(const String&amp; string, const CSSParserContext* context)
141 {
142     CSSValueID id = cssValueKeywordID(string);
143     if (!StyleColor::isSystemColor(id))
144         return Color();
145 
146     OptionSet&lt;StyleColor::Options&gt; options;
147     if (context &amp;&amp; context-&gt;useSystemAppearance)
148         options.add(StyleColor::Options::UseSystemAppearance);
149     return RenderTheme::singleton().systemColor(id, options);
150 }
151 
152 RefPtr&lt;CSSValue&gt; CSSParser::parseSingleValue(CSSPropertyID propertyID, const String&amp; string, const CSSParserContext&amp; context)
153 {
154     if (string.isEmpty())
155         return nullptr;
156     if (RefPtr&lt;CSSValue&gt; value = CSSParserFastPaths::maybeParseValue(propertyID, string, context.mode))
157         return value;
158     CSSTokenizer tokenizer(string);
159     return CSSPropertyParser::parseSingleValue(propertyID, tokenizer.tokenRange(), context);
160 }
161 
162 CSSParser::ParseResult CSSParser::parseValue(MutableStyleProperties&amp; declaration, CSSPropertyID propertyID, const String&amp; string, bool important, const CSSParserContext&amp; context)
163 {
164     ASSERT(!string.isEmpty());
165     RefPtr&lt;CSSValue&gt; value = CSSParserFastPaths::maybeParseValue(propertyID, string, context.mode);
166     if (value)
167         return declaration.addParsedProperty(CSSProperty(propertyID, WTFMove(value), important)) ? CSSParser::ParseResult::Changed : CSSParser::ParseResult::Unchanged;
168 
169     CSSParser parser(context);
170     return parser.parseValue(declaration, propertyID, string, important);
171 }
172 
173 CSSParser::ParseResult CSSParser::parseCustomPropertyValue(MutableStyleProperties&amp; declaration, const AtomString&amp; propertyName, const String&amp; string, bool important, const CSSParserContext&amp; context)
174 {
175     return CSSParserImpl::parseCustomPropertyValue(&amp;declaration, propertyName, string, important, context);
176 }
177 
178 CSSParser::ParseResult CSSParser::parseValue(MutableStyleProperties&amp; declaration, CSSPropertyID propertyID, const String&amp; string, bool important)
179 {
180     return CSSParserImpl::parseValue(&amp;declaration, propertyID, string, important, m_context);
181 }
182 
183 void CSSParser::parseSelector(const String&amp; string, CSSSelectorList&amp; selectorList)
184 {
185     CSSTokenizer tokenizer(string);
186     selectorList = CSSSelectorParser::parseSelector(tokenizer.tokenRange(), m_context, nullptr);
187 }
188 
189 Ref&lt;ImmutableStyleProperties&gt; CSSParser::parseInlineStyleDeclaration(const String&amp; string, const Element* element)
190 {
191     return CSSParserImpl::parseInlineStyleDeclaration(string, element);
192 }
193 
194 bool CSSParser::parseDeclaration(MutableStyleProperties&amp; declaration, const String&amp; string)
195 {
196     return CSSParserImpl::parseDeclarationList(&amp;declaration, string, m_context);
197 }
198 
199 void CSSParser::parseDeclarationForInspector(const CSSParserContext&amp; context, const String&amp; string, CSSParserObserver&amp; observer)
200 {
201     CSSParserImpl::parseDeclarationListForInspector(string, context, observer);
202 }
203 
204 RefPtr&lt;CSSValue&gt; CSSParser::parseValueWithVariableReferences(CSSPropertyID propID, const CSSValue&amp; value, Style::BuilderState&amp; builderState)
205 {
206     ASSERT((propID == CSSPropertyCustom &amp;&amp; value.isCustomPropertyValue()) || (propID != CSSPropertyCustom &amp;&amp; !value.isCustomPropertyValue()));
207     auto&amp; style = builderState.style();
208     auto direction = style.direction();
209     auto writingMode = style.writingMode();
210 
211     if (value.isPendingSubstitutionValue()) {
212         // FIXME: Should have a resolvedShorthands cache to stop this from being done
213         // over and over for each longhand value.
214         const CSSPendingSubstitutionValue&amp; pendingSubstitution = downcast&lt;CSSPendingSubstitutionValue&gt;(value);
215         CSSPropertyID shorthandID = pendingSubstitution.shorthandPropertyId();
216         if (CSSProperty::isDirectionAwareProperty(shorthandID))
217             shorthandID = CSSProperty::resolveDirectionAwareProperty(shorthandID, direction, writingMode);
218         CSSVariableReferenceValue* shorthandValue = pendingSubstitution.shorthandValue();
219 
220         auto resolvedData = shorthandValue-&gt;resolveVariableReferences(builderState);
221         if (!resolvedData)
222             return nullptr;
223         Vector&lt;CSSParserToken&gt; resolvedTokens = resolvedData-&gt;tokens();
224 
225         ParsedPropertyVector parsedProperties;
226         if (!CSSPropertyParser::parseValue(shorthandID, false, resolvedTokens, m_context, parsedProperties, StyleRuleType::Style))
227             return nullptr;
228 
229         for (auto&amp; property : parsedProperties) {
230             if (property.id() == propID)
231                 return property.value();
232         }
233 
234         return nullptr;
235     }
236 
237     if (value.isVariableReferenceValue()) {
238         const CSSVariableReferenceValue&amp; valueWithReferences = downcast&lt;CSSVariableReferenceValue&gt;(value);
239         auto resolvedData = valueWithReferences.resolveVariableReferences(builderState);
240         if (!resolvedData)
241             return nullptr;
242         return CSSPropertyParser::parseSingleValue(propID, resolvedData-&gt;tokens(), m_context);
243     }
244 
245     const auto&amp; customPropValue = downcast&lt;CSSCustomPropertyValue&gt;(value);
246     const auto&amp; valueWithReferences = WTF::get&lt;Ref&lt;CSSVariableReferenceValue&gt;&gt;(customPropValue.value()).get();
247 
248     auto&amp; name = downcast&lt;CSSCustomPropertyValue&gt;(value).name();
249     auto* registered = builderState.document().getCSSRegisteredCustomPropertySet().get(name);
250     auto&amp; syntax = registered ? registered-&gt;syntax : &quot;*&quot;;
251     auto resolvedData = valueWithReferences.resolveVariableReferences(builderState);
252 
253     if (!resolvedData)
254         return nullptr;
255 
256     // FIXME handle REM cycles.
257     HashSet&lt;CSSPropertyID&gt; dependencies;
258     CSSPropertyParser::collectParsedCustomPropertyValueDependencies(syntax, false, dependencies, resolvedData-&gt;tokens(), m_context);
259 
260     for (auto id : dependencies)
261         builderState.builder().applyProperty(id);
262 
263     return CSSPropertyParser::parseTypedCustomPropertyValue(name, syntax, resolvedData-&gt;tokens(), builderState, m_context);
264 }
265 
266 std::unique_ptr&lt;Vector&lt;double&gt;&gt; CSSParser::parseKeyframeKeyList(const String&amp; selector)
267 {
268     return CSSParserImpl::parseKeyframeKeyList(selector);
269 }
270 
271 RefPtr&lt;CSSValue&gt; CSSParser::parseFontFaceDescriptor(CSSPropertyID propertyID, const String&amp; propertyValue, const CSSParserContext&amp; context)
272 {
273     String string = makeString(&quot;@font-face { &quot;, getPropertyNameString(propertyID), &quot; : &quot;, propertyValue, &quot;; }&quot;);
274     RefPtr&lt;StyleRuleBase&gt; rule = parseRule(context, nullptr, string);
275     if (!rule || !rule-&gt;isFontFaceRule())
276         return nullptr;
277     return downcast&lt;StyleRuleFontFace&gt;(*rule.get()).properties().getPropertyCSSValue(propertyID);
278 }
279 
280 }
    </pre>
  </body>
</html>
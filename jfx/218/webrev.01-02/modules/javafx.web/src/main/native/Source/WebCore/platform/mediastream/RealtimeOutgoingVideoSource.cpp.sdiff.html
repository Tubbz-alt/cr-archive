<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/mediastream/RealtimeOutgoingVideoSource.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RealtimeOutgoingAudioSource.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RealtimeOutgoingVideoSource.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/mediastream/RealtimeOutgoingVideoSource.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 39 #include &lt;webrtc/common_video/libyuv/include/webrtc_libyuv.h&gt;
 40 
 41 ALLOW_UNUSED_PARAMETERS_END
 42 
 43 #include &lt;wtf/MainThread.h&gt;
 44 
 45 namespace WebCore {
 46 
 47 RealtimeOutgoingVideoSource::RealtimeOutgoingVideoSource(Ref&lt;MediaStreamTrackPrivate&gt;&amp;&amp; videoSource)
 48     : m_videoSource(WTFMove(videoSource))
 49     , m_blackFrameTimer(*this, &amp;RealtimeOutgoingVideoSource::sendOneBlackFrame)
 50 #if !RELEASE_LOG_DISABLED
 51     , m_logger(m_videoSource-&gt;logger())
 52     , m_logIdentifier(m_videoSource-&gt;logIdentifier())
 53 #endif
 54 {
 55 }
 56 
 57 RealtimeOutgoingVideoSource::~RealtimeOutgoingVideoSource()
 58 {




 59     ASSERT(m_sinks.isEmpty());
 60     stop();
 61 }
 62 
 63 void RealtimeOutgoingVideoSource::observeSource()
 64 {

 65     m_videoSource-&gt;addObserver(*this);
 66     initializeFromSource();
 67 }
 68 
 69 void RealtimeOutgoingVideoSource::unobserveSource()
 70 {
 71     m_videoSource-&gt;removeObserver(*this);
 72 }
 73 
<span class="line-modified"> 74 bool RealtimeOutgoingVideoSource::setSource(Ref&lt;MediaStreamTrackPrivate&gt;&amp;&amp; newSource)</span>
 75 {
<span class="line-modified"> 76     if (!m_initialSettings)</span>
<span class="line-removed"> 77         m_initialSettings = m_videoSource-&gt;source().settings();</span>
<span class="line-removed"> 78 </span>
<span class="line-removed"> 79     auto locker = holdLock(m_sinksLock);</span>
<span class="line-removed"> 80     bool hasSinks = !m_sinks.isEmpty();</span>
<span class="line-removed"> 81 </span>
<span class="line-removed"> 82     if (hasSinks)</span>
<span class="line-removed"> 83         unobserveSource();</span>
 84     m_videoSource = WTFMove(newSource);
<span class="line-removed"> 85     if (hasSinks)</span>
<span class="line-removed"> 86         observeSource();</span>
<span class="line-removed"> 87 </span>
<span class="line-removed"> 88     return true;</span>
 89 }
 90 
 91 void RealtimeOutgoingVideoSource::stop()
 92 {
 93     ASSERT(isMainThread());
 94     unobserveSource();
 95     m_blackFrameTimer.stop();
 96 }
 97 
 98 void RealtimeOutgoingVideoSource::updateBlackFramesSending()
 99 {
100     if (!m_muted &amp;&amp; m_enabled) {
101         if (m_blackFrameTimer.isActive())
102             m_blackFrameTimer.stop();
103         return;
104     }
105 
106     sendBlackFramesIfNeeded();
107 }
108 
</pre>
<hr />
<pre>
126 
127 void RealtimeOutgoingVideoSource::initializeFromSource()
128 {
129     const auto&amp; settings = m_videoSource-&gt;source().settings();
130     m_width = settings.width();
131     m_height = settings.height();
132 
133     m_muted = m_videoSource-&gt;muted();
134     m_enabled = m_videoSource-&gt;enabled();
135 
136     updateBlackFramesSending();
137 }
138 
139 void RealtimeOutgoingVideoSource::AddOrUpdateSink(rtc::VideoSinkInterface&lt;webrtc::VideoFrame&gt;* sink, const rtc::VideoSinkWants&amp; sinkWants)
140 {
141     ASSERT(!sinkWants.black_frames);
142 
143     if (sinkWants.rotation_applied)
144         m_shouldApplyRotation = true;
145 
<span class="line-removed">146     {</span>
147     auto locker = holdLock(m_sinksLock);
<span class="line-modified">148     if (!m_sinks.add(sink) || m_sinks.size() != 1)</span>
<span class="line-removed">149         return;</span>
<span class="line-removed">150     }</span>
<span class="line-removed">151 </span>
<span class="line-removed">152     callOnMainThread([protectedThis = makeRef(*this)]() {</span>
<span class="line-removed">153         protectedThis-&gt;observeSource();</span>
<span class="line-removed">154     });</span>
155 }
156 
157 void RealtimeOutgoingVideoSource::RemoveSink(rtc::VideoSinkInterface&lt;webrtc::VideoFrame&gt;* sink)
158 {
<span class="line-removed">159     {</span>
160     auto locker = holdLock(m_sinksLock);
<span class="line-modified">161 </span>
<span class="line-removed">162     if (!m_sinks.remove(sink) || m_sinks.size())</span>
<span class="line-removed">163         return;</span>
<span class="line-removed">164     }</span>
<span class="line-removed">165 </span>
<span class="line-removed">166     unobserveSource();</span>
<span class="line-removed">167 </span>
<span class="line-removed">168     callOnMainThread([protectedThis = makeRef(*this)]() {</span>
<span class="line-removed">169         if (protectedThis-&gt;m_blackFrameTimer.isActive())</span>
<span class="line-removed">170             protectedThis-&gt;m_blackFrameTimer.stop();</span>
<span class="line-removed">171     });</span>
172 }
173 
174 void RealtimeOutgoingVideoSource::sendBlackFramesIfNeeded()
175 {
176     if (m_blackFrameTimer.isActive())
177         return;
178 
179     if (!m_muted &amp;&amp; m_enabled)
180         return;
181 
182     if (!m_width || !m_height)
183         return;
184 
185     if (!m_blackFrame) {
186         auto width = m_width;
187         auto height = m_height;
188         if (m_shouldApplyRotation &amp;&amp; (m_currentRotation == webrtc::kVideoRotation_0 || m_currentRotation == webrtc::kVideoRotation_90))
189             std::swap(width, height);
190         m_blackFrame = createBlackFrame(width, height);
191         ASSERT(m_blackFrame);
</pre>
</td>
<td>
<hr />
<pre>
 39 #include &lt;webrtc/common_video/libyuv/include/webrtc_libyuv.h&gt;
 40 
 41 ALLOW_UNUSED_PARAMETERS_END
 42 
 43 #include &lt;wtf/MainThread.h&gt;
 44 
 45 namespace WebCore {
 46 
 47 RealtimeOutgoingVideoSource::RealtimeOutgoingVideoSource(Ref&lt;MediaStreamTrackPrivate&gt;&amp;&amp; videoSource)
 48     : m_videoSource(WTFMove(videoSource))
 49     , m_blackFrameTimer(*this, &amp;RealtimeOutgoingVideoSource::sendOneBlackFrame)
 50 #if !RELEASE_LOG_DISABLED
 51     , m_logger(m_videoSource-&gt;logger())
 52     , m_logIdentifier(m_videoSource-&gt;logIdentifier())
 53 #endif
 54 {
 55 }
 56 
 57 RealtimeOutgoingVideoSource::~RealtimeOutgoingVideoSource()
 58 {
<span class="line-added"> 59 ASSERT(!m_videoSource-&gt;hasObserver(*this));</span>
<span class="line-added"> 60 #if ASSERT_ENABLED</span>
<span class="line-added"> 61     auto locker = holdLock(m_sinksLock);</span>
<span class="line-added"> 62 #endif</span>
 63     ASSERT(m_sinks.isEmpty());
 64     stop();
 65 }
 66 
 67 void RealtimeOutgoingVideoSource::observeSource()
 68 {
<span class="line-added"> 69     ASSERT(!m_videoSource-&gt;hasObserver(*this));</span>
 70     m_videoSource-&gt;addObserver(*this);
 71     initializeFromSource();
 72 }
 73 
 74 void RealtimeOutgoingVideoSource::unobserveSource()
 75 {
 76     m_videoSource-&gt;removeObserver(*this);
 77 }
 78 
<span class="line-modified"> 79 void RealtimeOutgoingVideoSource::setSource(Ref&lt;MediaStreamTrackPrivate&gt;&amp;&amp; newSource)</span>
 80 {
<span class="line-modified"> 81     ASSERT(!m_videoSource-&gt;hasObserver(*this));</span>







 82     m_videoSource = WTFMove(newSource);




 83 }
 84 
 85 void RealtimeOutgoingVideoSource::stop()
 86 {
 87     ASSERT(isMainThread());
 88     unobserveSource();
 89     m_blackFrameTimer.stop();
 90 }
 91 
 92 void RealtimeOutgoingVideoSource::updateBlackFramesSending()
 93 {
 94     if (!m_muted &amp;&amp; m_enabled) {
 95         if (m_blackFrameTimer.isActive())
 96             m_blackFrameTimer.stop();
 97         return;
 98     }
 99 
100     sendBlackFramesIfNeeded();
101 }
102 
</pre>
<hr />
<pre>
120 
121 void RealtimeOutgoingVideoSource::initializeFromSource()
122 {
123     const auto&amp; settings = m_videoSource-&gt;source().settings();
124     m_width = settings.width();
125     m_height = settings.height();
126 
127     m_muted = m_videoSource-&gt;muted();
128     m_enabled = m_videoSource-&gt;enabled();
129 
130     updateBlackFramesSending();
131 }
132 
133 void RealtimeOutgoingVideoSource::AddOrUpdateSink(rtc::VideoSinkInterface&lt;webrtc::VideoFrame&gt;* sink, const rtc::VideoSinkWants&amp; sinkWants)
134 {
135     ASSERT(!sinkWants.black_frames);
136 
137     if (sinkWants.rotation_applied)
138         m_shouldApplyRotation = true;
139 

140     auto locker = holdLock(m_sinksLock);
<span class="line-modified">141     m_sinks.add(sink);</span>






142 }
143 
144 void RealtimeOutgoingVideoSource::RemoveSink(rtc::VideoSinkInterface&lt;webrtc::VideoFrame&gt;* sink)
145 {

146     auto locker = holdLock(m_sinksLock);
<span class="line-modified">147     m_sinks.remove(sink);</span>










148 }
149 
150 void RealtimeOutgoingVideoSource::sendBlackFramesIfNeeded()
151 {
152     if (m_blackFrameTimer.isActive())
153         return;
154 
155     if (!m_muted &amp;&amp; m_enabled)
156         return;
157 
158     if (!m_width || !m_height)
159         return;
160 
161     if (!m_blackFrame) {
162         auto width = m_width;
163         auto height = m_height;
164         if (m_shouldApplyRotation &amp;&amp; (m_currentRotation == webrtc::kVideoRotation_0 || m_currentRotation == webrtc::kVideoRotation_90))
165             std::swap(width, height);
166         m_blackFrame = createBlackFrame(width, height);
167         ASSERT(m_blackFrame);
</pre>
</td>
</tr>
</table>
<center><a href="RealtimeOutgoingAudioSource.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RealtimeOutgoingVideoSource.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMAbstractOperations.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSCustomXPathNSResolver.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMAttribute.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMAbstractOperations.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 38,11 ***</span>
  };
  
  // An implementation of the &#39;named property visibility algorithm&#39;
  // https://heycam.github.io/webidl/#dfn-named-property-visibility
  template&lt;OverrideBuiltins overrideBuiltins, class JSClass&gt;
<span class="line-modified">! static bool isVisibleNamedProperty(JSC::ExecState&amp; state, JSClass&amp; thisObject, JSC::PropertyName propertyName)</span>
  {
      // FIXME: It seems unfortunate that have to do two lookups for the property name,
      // one for isSupportedPropertyName and one by the user of this algorithm to access
      // that property. It would be nice if we could smuggle the result, or an iterator
      // out so the duplicate lookup could be avoided.
<span class="line-new-header">--- 38,11 ---</span>
  };
  
  // An implementation of the &#39;named property visibility algorithm&#39;
  // https://heycam.github.io/webidl/#dfn-named-property-visibility
  template&lt;OverrideBuiltins overrideBuiltins, class JSClass&gt;
<span class="line-modified">! static bool isVisibleNamedProperty(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSClass&amp; thisObject, JSC::PropertyName propertyName)</span>
  {
      // FIXME: It seems unfortunate that have to do two lookups for the property name,
      // one for isSupportedPropertyName and one by the user of this algorithm to access
      // that property. It would be nice if we could smuggle the result, or an iterator
      // out so the duplicate lookup could be avoided.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 58,11 ***</span>
      if (!impl.isSupportedPropertyName(propertyNameToString(propertyName)))
          return false;
  
      // 2. If O has an own property named P, then return false.
      JSC::PropertySlot slot { &amp;thisObject, JSC::PropertySlot::InternalMethodType::VMInquiry };
<span class="line-modified">!     if (JSC::JSObject::getOwnPropertySlot(&amp;thisObject, &amp;state, propertyName, slot))</span>
          return false;
  
      // 3. If O implements an interface that has the [OverrideBuiltins] extended attribute, then return true.
      if (overrideBuiltins == OverrideBuiltins::Yes)
          return true;
<span class="line-new-header">--- 58,11 ---</span>
      if (!impl.isSupportedPropertyName(propertyNameToString(propertyName)))
          return false;
  
      // 2. If O has an own property named P, then return false.
      JSC::PropertySlot slot { &amp;thisObject, JSC::PropertySlot::InternalMethodType::VMInquiry };
<span class="line-modified">!     if (JSC::JSObject::getOwnPropertySlot(&amp;thisObject, &amp;lexicalGlobalObject, propertyName, slot))</span>
          return false;
  
      // 3. If O implements an interface that has the [OverrideBuiltins] extended attribute, then return true.
      if (overrideBuiltins == OverrideBuiltins::Yes)
          return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 70,12 ***</span>
      // 4. Initialize prototype to be the value of the internal [[Prototype]] property of O.
      // 5. While prototype is not null:
      //    1. If prototype is not a named properties object, and prototype has an own property named P, then return false.
      // FIXME: Implement checking for &#39;named properties object&#39;.
      //    2. Set prototype to be the value of the internal [[Prototype]] property of prototype.
<span class="line-modified">!     auto prototype = thisObject.getPrototypeDirect(state.vm());</span>
<span class="line-modified">!     if (prototype.isObject() &amp;&amp; JSC::asObject(prototype)-&gt;getPropertySlot(&amp;state, propertyName, slot))</span>
          return false;
  
      // 6. Return true.
      return true;
  }
<span class="line-new-header">--- 70,12 ---</span>
      // 4. Initialize prototype to be the value of the internal [[Prototype]] property of O.
      // 5. While prototype is not null:
      //    1. If prototype is not a named properties object, and prototype has an own property named P, then return false.
      // FIXME: Implement checking for &#39;named properties object&#39;.
      //    2. Set prototype to be the value of the internal [[Prototype]] property of prototype.
<span class="line-modified">!     auto prototype = thisObject.getPrototypeDirect(JSC::getVM(&amp;lexicalGlobalObject));</span>
<span class="line-modified">!     if (prototype.isObject() &amp;&amp; JSC::asObject(prototype)-&gt;getPropertySlot(&amp;lexicalGlobalObject, propertyName, slot))</span>
          return false;
  
      // 6. Return true.
      return true;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 84,11 ***</span>
  // &#39;supported property name&#39; check with direct access to the implementation value returned
  // for the property name, via passed in functor. This allows us to avoid two looking up the
  // the property name twice; once for &#39;named property visibility algorithm&#39; check, and then
  // again when the value is needed.
  template&lt;OverrideBuiltins overrideBuiltins, class JSClass, class Functor&gt;
<span class="line-modified">! static auto accessVisibleNamedProperty(JSC::ExecState&amp; state, JSClass&amp; thisObject, JSC::PropertyName propertyName, Functor&amp;&amp; itemAccessor) -&gt; decltype(itemAccessor(thisObject, propertyName))</span>
  {
      // NOTE: While it is not specified, a Symbol can never be a &#39;supported property
      // name&#39; so we check that first.
      if (propertyName.isSymbol())
          return WTF::nullopt;
<span class="line-new-header">--- 84,11 ---</span>
  // &#39;supported property name&#39; check with direct access to the implementation value returned
  // for the property name, via passed in functor. This allows us to avoid two looking up the
  // the property name twice; once for &#39;named property visibility algorithm&#39; check, and then
  // again when the value is needed.
  template&lt;OverrideBuiltins overrideBuiltins, class JSClass, class Functor&gt;
<span class="line-modified">! static auto accessVisibleNamedProperty(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSClass&amp; thisObject, JSC::PropertyName propertyName, Functor&amp;&amp; itemAccessor) -&gt; decltype(itemAccessor(thisObject, propertyName))</span>
  {
      // NOTE: While it is not specified, a Symbol can never be a &#39;supported property
      // name&#39; so we check that first.
      if (propertyName.isSymbol())
          return WTF::nullopt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 98,11 ***</span>
      if (!result)
          return WTF::nullopt;
  
      // 2. If O has an own property named P, then return false.
      JSC::PropertySlot slot { &amp;thisObject, JSC::PropertySlot::InternalMethodType::VMInquiry };
<span class="line-modified">!     if (JSC::JSObject::getOwnPropertySlot(&amp;thisObject, &amp;state, propertyName, slot))</span>
          return WTF::nullopt;
  
      // 3. If O implements an interface that has the [OverrideBuiltins] extended attribute, then return true.
      if (overrideBuiltins == OverrideBuiltins::Yes &amp;&amp; !worldForDOMObject(thisObject).shouldDisableOverrideBuiltinsBehavior())
          return result;
<span class="line-new-header">--- 98,11 ---</span>
      if (!result)
          return WTF::nullopt;
  
      // 2. If O has an own property named P, then return false.
      JSC::PropertySlot slot { &amp;thisObject, JSC::PropertySlot::InternalMethodType::VMInquiry };
<span class="line-modified">!     if (JSC::JSObject::getOwnPropertySlot(&amp;thisObject, &amp;lexicalGlobalObject, propertyName, slot))</span>
          return WTF::nullopt;
  
      // 3. If O implements an interface that has the [OverrideBuiltins] extended attribute, then return true.
      if (overrideBuiltins == OverrideBuiltins::Yes &amp;&amp; !worldForDOMObject(thisObject).shouldDisableOverrideBuiltinsBehavior())
          return result;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 110,12 ***</span>
      // 4. Initialize prototype to be the value of the internal [[Prototype]] property of O.
      // 5. While prototype is not null:
      //    1. If prototype is not a named properties object, and prototype has an own property named P, then return false.
      // FIXME: Implement checking for &#39;named properties object&#39;.
      //    2. Set prototype to be the value of the internal [[Prototype]] property of prototype.
<span class="line-modified">!     auto prototype = thisObject.getPrototypeDirect(state.vm());</span>
<span class="line-modified">!     if (prototype.isObject() &amp;&amp; JSC::asObject(prototype)-&gt;getPropertySlot(&amp;state, propertyName, slot))</span>
          return WTF::nullopt;
  
      // 6. Return true.
      return result;
  }
<span class="line-new-header">--- 110,12 ---</span>
      // 4. Initialize prototype to be the value of the internal [[Prototype]] property of O.
      // 5. While prototype is not null:
      //    1. If prototype is not a named properties object, and prototype has an own property named P, then return false.
      // FIXME: Implement checking for &#39;named properties object&#39;.
      //    2. Set prototype to be the value of the internal [[Prototype]] property of prototype.
<span class="line-modified">!     auto prototype = thisObject.getPrototypeDirect(JSC::getVM(&amp;lexicalGlobalObject));</span>
<span class="line-modified">!     if (prototype.isObject() &amp;&amp; JSC::asObject(prototype)-&gt;getPropertySlot(&amp;lexicalGlobalObject, propertyName, slot))</span>
          return WTF::nullopt;
  
      // 6. Return true.
      return result;
  }
</pre>
<center><a href="JSCustomXPathNSResolver.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMAttribute.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ErrorInstance.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ErrorConstructor.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ErrorInstance.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ErrorInstance.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 22 #include &quot;ErrorInstance.h&quot;
 23 
 24 #include &quot;CodeBlock.h&quot;
 25 #include &quot;InlineCallFrame.h&quot;
 26 #include &quot;Interpreter.h&quot;
 27 #include &quot;JSScope.h&quot;
 28 #include &quot;JSCInlines.h&quot;
 29 #include &quot;ParseInt.h&quot;
 30 #include &quot;StackFrame.h&quot;
 31 #include &lt;wtf/text/StringBuilder.h&gt;
 32 
 33 namespace JSC {
 34 
 35 const ClassInfo ErrorInstance::s_info = { &quot;Error&quot;, &amp;JSNonFinalObject::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ErrorInstance) };
 36 
 37 ErrorInstance::ErrorInstance(VM&amp; vm, Structure* structure)
 38     : Base(vm, structure)
 39 {
 40 }
 41 
<span class="line-modified"> 42 ErrorInstance* ErrorInstance::create(ExecState* state, Structure* structure, JSValue message, SourceAppender appender, RuntimeType type, bool useCurrentFrame)</span>
 43 {
<span class="line-modified"> 44     VM&amp; vm = state-&gt;vm();</span>
 45     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 46     String messageString = message.isUndefined() ? String() : message.toWTFString(state);</span>
 47     RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 48     return create(state, vm, structure, messageString, appender, type, useCurrentFrame);</span>
 49 }
 50 
<span class="line-modified"> 51 static void appendSourceToError(CallFrame* callFrame, ErrorInstance* exception, unsigned bytecodeOffset)</span>
 52 {
 53     ErrorInstance::SourceAppender appender = exception-&gt;sourceAppender();
 54     exception-&gt;clearSourceAppender();
 55     RuntimeType type = exception-&gt;runtimeTypeForCause();
 56     exception-&gt;clearRuntimeTypeForCause();
 57 
 58     if (!callFrame-&gt;codeBlock()-&gt;hasExpressionInfo())
 59         return;
 60 
 61     int startOffset = 0;
 62     int endOffset = 0;
 63     int divotPoint = 0;
 64     unsigned line = 0;
 65     unsigned column = 0;
 66 
 67     CodeBlock* codeBlock;
 68     CodeOrigin codeOrigin = callFrame-&gt;codeOrigin();
 69     if (codeOrigin &amp;&amp; codeOrigin.inlineCallFrame())
 70         codeBlock = baselineCodeBlockForInlineCallFrame(codeOrigin.inlineCallFrame());
 71     else
 72         codeBlock = callFrame-&gt;codeBlock();
 73 
<span class="line-modified"> 74     codeBlock-&gt;expressionRangeForBytecodeOffset(bytecodeOffset, divotPoint, startOffset, endOffset, line, column);</span>
 75 
 76     int expressionStart = divotPoint - startOffset;
 77     int expressionStop = divotPoint + endOffset;
 78 
 79     StringView sourceString = codeBlock-&gt;source().provider()-&gt;source();
 80     if (!expressionStop || expressionStart &gt; static_cast&lt;int&gt;(sourceString.length()))
 81         return;
 82 
<span class="line-modified"> 83     VM&amp; vm = callFrame-&gt;vm();</span>
 84     JSValue jsMessage = exception-&gt;getDirect(vm, vm.propertyNames-&gt;message);
 85     if (!jsMessage || !jsMessage.isString())
 86         return;
 87 
<span class="line-modified"> 88     String message = asString(jsMessage)-&gt;value(callFrame);</span>
 89     if (expressionStart &lt; expressionStop)
 90         message = appender(message, codeBlock-&gt;source().provider()-&gt;getRange(expressionStart, expressionStop).toString(), type, ErrorInstance::FoundExactSource);
 91     else {
 92         // No range information, so give a few characters of context.
 93         int dataLength = sourceString.length();
 94         int start = expressionStart;
 95         int stop = expressionStart;
 96         // Get up to 20 characters of context to the left and right of the divot, clamping to the line.
 97         // Then strip whitespace.
 98         while (start &gt; 0 &amp;&amp; (expressionStart - start &lt; 20) &amp;&amp; sourceString[start - 1] != &#39;\n&#39;)
 99             start--;
100         while (start &lt; (expressionStart - 1) &amp;&amp; isStrWhiteSpace(sourceString[start]))
101             start++;
102         while (stop &lt; dataLength &amp;&amp; (stop - expressionStart &lt; 20) &amp;&amp; sourceString[stop] != &#39;\n&#39;)
103             stop++;
104         while (stop &gt; expressionStart &amp;&amp; isStrWhiteSpace(sourceString[stop - 1]))
105             stop--;
106         message = appender(message, codeBlock-&gt;source().provider()-&gt;getRange(start, stop).toString(), type, ErrorInstance::FoundApproximateSource);
107     }
108     exception-&gt;putDirect(vm, vm.propertyNames-&gt;message, jsString(vm, message));
109 
110 }
111 
<span class="line-modified">112 void ErrorInstance::finishCreation(ExecState* exec, VM&amp; vm, const String&amp; message, bool useCurrentFrame)</span>
113 {
114     Base::finishCreation(vm);
115     ASSERT(inherits(vm, info()));
116     if (!message.isNull())
117         putDirect(vm, vm.propertyNames-&gt;message, jsString(vm, message), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
118 
<span class="line-modified">119     std::unique_ptr&lt;Vector&lt;StackFrame&gt;&gt; stackTrace = getStackTrace(exec, vm, this, useCurrentFrame);</span>
120     {
121         auto locker = holdLock(cellLock());
122         m_stackTrace = WTFMove(stackTrace);
123     }
124     vm.heap.writeBarrier(this);
125 
126     if (m_stackTrace &amp;&amp; !m_stackTrace-&gt;isEmpty() &amp;&amp; hasSourceAppender()) {
<span class="line-modified">127         unsigned bytecodeOffset;</span>
128         CallFrame* callFrame;
<span class="line-modified">129         getBytecodeOffset(exec, vm, m_stackTrace.get(), callFrame, bytecodeOffset);</span>
<span class="line-modified">130         if (callFrame &amp;&amp; callFrame-&gt;codeBlock()) {</span>
<span class="line-modified">131             ASSERT(!callFrame-&gt;callee().isWasm());</span>
<span class="line-removed">132             appendSourceToError(callFrame, this, bytecodeOffset);</span>
<span class="line-removed">133         }</span>
134     }
135 }
136 
<span class="line-removed">137 void ErrorInstance::destroy(JSCell* cell)</span>
<span class="line-removed">138 {</span>
<span class="line-removed">139     static_cast&lt;ErrorInstance*&gt;(cell)-&gt;ErrorInstance::~ErrorInstance();</span>
<span class="line-removed">140 }</span>
<span class="line-removed">141 </span>
142 // Based on ErrorPrototype&#39;s errorProtoFuncToString(), but is modified to
143 // have no observable side effects to the user (i.e. does not call proxies,
144 // and getters).
<span class="line-modified">145 String ErrorInstance::sanitizedToString(ExecState* exec)</span>
146 {
<span class="line-modified">147     VM&amp; vm = exec-&gt;vm();</span>
148     auto scope = DECLARE_THROW_SCOPE(vm);
149 
150     JSValue nameValue;
151     auto namePropertName = vm.propertyNames-&gt;name;
152     PropertySlot nameSlot(this, PropertySlot::InternalMethodType::VMInquiry);
153 
154     JSValue currentObj = this;
155     unsigned prototypeDepth = 0;
156 
157     // We only check the current object and its prototype (2 levels) because normal
158     // Error objects may have a name property, and if not, its prototype should have
159     // a name property for the type of error e.g. &quot;SyntaxError&quot;.
160     while (currentObj.isCell() &amp;&amp; prototypeDepth++ &lt; 2) {
161         JSObject* obj = jsCast&lt;JSObject*&gt;(currentObj);
<span class="line-modified">162         if (JSObject::getOwnPropertySlot(obj, exec, namePropertName, nameSlot) &amp;&amp; nameSlot.isValue()) {</span>
<span class="line-modified">163             nameValue = nameSlot.getValue(exec, namePropertName);</span>
164             break;
165         }
166         currentObj = obj-&gt;getPrototypeDirect(vm);
167     }
168     scope.assertNoException();
169 
170     String nameString;
171     if (!nameValue)
172         nameString = &quot;Error&quot;_s;
173     else {
<span class="line-modified">174         nameString = nameValue.toWTFString(exec);</span>
175         RETURN_IF_EXCEPTION(scope, String());
176     }
177 
178     JSValue messageValue;
179     auto messagePropertName = vm.propertyNames-&gt;message;
180     PropertySlot messageSlot(this, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">181     if (JSObject::getOwnPropertySlot(this, exec, messagePropertName, messageSlot) &amp;&amp; messageSlot.isValue())</span>
<span class="line-modified">182         messageValue = messageSlot.getValue(exec, messagePropertName);</span>
183     scope.assertNoException();
184 
185     String messageString;
186     if (!messageValue)
187         messageString = String();
188     else {
<span class="line-modified">189         messageString = messageValue.toWTFString(exec);</span>
190         RETURN_IF_EXCEPTION(scope, String());
191     }
192 
193     if (!nameString.length())
194         return messageString;
195 
196     if (!messageString.length())
197         return nameString;
198 
199     StringBuilder builder;
200     builder.append(nameString);
201     builder.appendLiteral(&quot;: &quot;);
202     builder.append(messageString);
203     return builder.toString();
204 }
205 
206 void ErrorInstance::finalizeUnconditionally(VM&amp; vm)
207 {
208     if (!m_stackTrace)
209         return;
</pre>
<hr />
<pre>
221 
222 void ErrorInstance::computeErrorInfo(VM&amp; vm)
223 {
224     ASSERT(!m_errorInfoMaterialized);
225 
226     if (m_stackTrace &amp;&amp; !m_stackTrace-&gt;isEmpty()) {
227         getLineColumnAndSource(m_stackTrace.get(), m_line, m_column, m_sourceURL);
228         m_stackString = Interpreter::stackTraceAsString(vm, *m_stackTrace.get());
229         m_stackTrace = nullptr;
230     }
231 }
232 
233 bool ErrorInstance::materializeErrorInfoIfNeeded(VM&amp; vm)
234 {
235     if (m_errorInfoMaterialized)
236         return false;
237 
238     computeErrorInfo(vm);
239 
240     if (!m_stackString.isNull()) {
<span class="line-modified">241         putDirect(vm, vm.propertyNames-&gt;line, jsNumber(m_line));</span>
<span class="line-modified">242         putDirect(vm, vm.propertyNames-&gt;column, jsNumber(m_column));</span>


243         if (!m_sourceURL.isEmpty())
<span class="line-modified">244             putDirect(vm, vm.propertyNames-&gt;sourceURL, jsString(vm, WTFMove(m_sourceURL)));</span>
245 
<span class="line-modified">246         putDirect(vm, vm.propertyNames-&gt;stack, jsString(vm, WTFMove(m_stackString)), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
247     }
248 
249     m_errorInfoMaterialized = true;
250     return true;
251 }
252 
253 bool ErrorInstance::materializeErrorInfoIfNeeded(VM&amp; vm, PropertyName propertyName)
254 {
255     if (propertyName == vm.propertyNames-&gt;line
256         || propertyName == vm.propertyNames-&gt;column
257         || propertyName == vm.propertyNames-&gt;sourceURL
258         || propertyName == vm.propertyNames-&gt;stack)
259         return materializeErrorInfoIfNeeded(vm);
260     return false;
261 }
262 
<span class="line-modified">263 bool ErrorInstance::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
264 {
<span class="line-modified">265     VM&amp; vm = exec-&gt;vm();</span>
266     ErrorInstance* thisObject = jsCast&lt;ErrorInstance*&gt;(object);
267     thisObject-&gt;materializeErrorInfoIfNeeded(vm, propertyName);
<span class="line-modified">268     return Base::getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>
269 }
270 
<span class="line-modified">271 void ErrorInstance::getOwnNonIndexPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNameArray, EnumerationMode enumerationMode)</span>
272 {
<span class="line-modified">273     VM&amp; vm = exec-&gt;vm();</span>
274     ErrorInstance* thisObject = jsCast&lt;ErrorInstance*&gt;(object);
275     thisObject-&gt;materializeErrorInfoIfNeeded(vm);
<span class="line-modified">276     Base::getOwnNonIndexPropertyNames(thisObject, exec, propertyNameArray, enumerationMode);</span>
277 }
278 
<span class="line-modified">279 void ErrorInstance::getStructurePropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNameArray, EnumerationMode enumerationMode)</span>
280 {
<span class="line-modified">281     VM&amp; vm = exec-&gt;vm();</span>
282     ErrorInstance* thisObject = jsCast&lt;ErrorInstance*&gt;(object);
283     thisObject-&gt;materializeErrorInfoIfNeeded(vm);
<span class="line-modified">284     Base::getStructurePropertyNames(thisObject, exec, propertyNameArray, enumerationMode);</span>
285 }
286 
<span class="line-modified">287 bool ErrorInstance::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
288 {
<span class="line-modified">289     VM&amp; vm = exec-&gt;vm();</span>
290     ErrorInstance* thisObject = jsCast&lt;ErrorInstance*&gt;(object);
291     thisObject-&gt;materializeErrorInfoIfNeeded(vm, propertyName);
<span class="line-modified">292     return Base::defineOwnProperty(thisObject, exec, propertyName, descriptor, shouldThrow);</span>
293 }
294 
<span class="line-modified">295 bool ErrorInstance::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
296 {
<span class="line-modified">297     VM&amp; vm = exec-&gt;vm();</span>
298     ErrorInstance* thisObject = jsCast&lt;ErrorInstance*&gt;(cell);
299     bool materializedProperties = thisObject-&gt;materializeErrorInfoIfNeeded(vm, propertyName);
300     if (materializedProperties)
301         slot.disableCaching();
<span class="line-modified">302     return Base::put(thisObject, exec, propertyName, value, slot);</span>
303 }
304 
<span class="line-modified">305 bool ErrorInstance::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)</span>
306 {
<span class="line-modified">307     VM&amp; vm = exec-&gt;vm();</span>
308     ErrorInstance* thisObject = jsCast&lt;ErrorInstance*&gt;(cell);
309     thisObject-&gt;materializeErrorInfoIfNeeded(vm, propertyName);
<span class="line-modified">310     return Base::deleteProperty(thisObject, exec, propertyName);</span>
311 }
312 
313 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 22 #include &quot;ErrorInstance.h&quot;
 23 
 24 #include &quot;CodeBlock.h&quot;
 25 #include &quot;InlineCallFrame.h&quot;
 26 #include &quot;Interpreter.h&quot;
 27 #include &quot;JSScope.h&quot;
 28 #include &quot;JSCInlines.h&quot;
 29 #include &quot;ParseInt.h&quot;
 30 #include &quot;StackFrame.h&quot;
 31 #include &lt;wtf/text/StringBuilder.h&gt;
 32 
 33 namespace JSC {
 34 
 35 const ClassInfo ErrorInstance::s_info = { &quot;Error&quot;, &amp;JSNonFinalObject::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ErrorInstance) };
 36 
 37 ErrorInstance::ErrorInstance(VM&amp; vm, Structure* structure)
 38     : Base(vm, structure)
 39 {
 40 }
 41 
<span class="line-modified"> 42 ErrorInstance* ErrorInstance::create(JSGlobalObject* globalObject, Structure* structure, JSValue message, SourceAppender appender, RuntimeType type, bool useCurrentFrame)</span>
 43 {
<span class="line-modified"> 44     VM&amp; vm = globalObject-&gt;vm();</span>
 45     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 46     String messageString = message.isUndefined() ? String() : message.toWTFString(globalObject);</span>
 47     RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 48     return create(globalObject, vm, structure, messageString, appender, type, useCurrentFrame);</span>
 49 }
 50 
<span class="line-modified"> 51 static void appendSourceToError(JSGlobalObject* globalObject, CallFrame* callFrame, ErrorInstance* exception, BytecodeIndex bytecodeIndex)</span>
 52 {
 53     ErrorInstance::SourceAppender appender = exception-&gt;sourceAppender();
 54     exception-&gt;clearSourceAppender();
 55     RuntimeType type = exception-&gt;runtimeTypeForCause();
 56     exception-&gt;clearRuntimeTypeForCause();
 57 
 58     if (!callFrame-&gt;codeBlock()-&gt;hasExpressionInfo())
 59         return;
 60 
 61     int startOffset = 0;
 62     int endOffset = 0;
 63     int divotPoint = 0;
 64     unsigned line = 0;
 65     unsigned column = 0;
 66 
 67     CodeBlock* codeBlock;
 68     CodeOrigin codeOrigin = callFrame-&gt;codeOrigin();
 69     if (codeOrigin &amp;&amp; codeOrigin.inlineCallFrame())
 70         codeBlock = baselineCodeBlockForInlineCallFrame(codeOrigin.inlineCallFrame());
 71     else
 72         codeBlock = callFrame-&gt;codeBlock();
 73 
<span class="line-modified"> 74     codeBlock-&gt;expressionRangeForBytecodeIndex(bytecodeIndex, divotPoint, startOffset, endOffset, line, column);</span>
 75 
 76     int expressionStart = divotPoint - startOffset;
 77     int expressionStop = divotPoint + endOffset;
 78 
 79     StringView sourceString = codeBlock-&gt;source().provider()-&gt;source();
 80     if (!expressionStop || expressionStart &gt; static_cast&lt;int&gt;(sourceString.length()))
 81         return;
 82 
<span class="line-modified"> 83     VM&amp; vm = globalObject-&gt;vm();</span>
 84     JSValue jsMessage = exception-&gt;getDirect(vm, vm.propertyNames-&gt;message);
 85     if (!jsMessage || !jsMessage.isString())
 86         return;
 87 
<span class="line-modified"> 88     String message = asString(jsMessage)-&gt;value(globalObject);</span>
 89     if (expressionStart &lt; expressionStop)
 90         message = appender(message, codeBlock-&gt;source().provider()-&gt;getRange(expressionStart, expressionStop).toString(), type, ErrorInstance::FoundExactSource);
 91     else {
 92         // No range information, so give a few characters of context.
 93         int dataLength = sourceString.length();
 94         int start = expressionStart;
 95         int stop = expressionStart;
 96         // Get up to 20 characters of context to the left and right of the divot, clamping to the line.
 97         // Then strip whitespace.
 98         while (start &gt; 0 &amp;&amp; (expressionStart - start &lt; 20) &amp;&amp; sourceString[start - 1] != &#39;\n&#39;)
 99             start--;
100         while (start &lt; (expressionStart - 1) &amp;&amp; isStrWhiteSpace(sourceString[start]))
101             start++;
102         while (stop &lt; dataLength &amp;&amp; (stop - expressionStart &lt; 20) &amp;&amp; sourceString[stop] != &#39;\n&#39;)
103             stop++;
104         while (stop &gt; expressionStart &amp;&amp; isStrWhiteSpace(sourceString[stop - 1]))
105             stop--;
106         message = appender(message, codeBlock-&gt;source().provider()-&gt;getRange(start, stop).toString(), type, ErrorInstance::FoundApproximateSource);
107     }
108     exception-&gt;putDirect(vm, vm.propertyNames-&gt;message, jsString(vm, message));
109 
110 }
111 
<span class="line-modified">112 void ErrorInstance::finishCreation(JSGlobalObject* globalObject, VM&amp; vm, const String&amp; message, bool useCurrentFrame)</span>
113 {
114     Base::finishCreation(vm);
115     ASSERT(inherits(vm, info()));
116     if (!message.isNull())
117         putDirect(vm, vm.propertyNames-&gt;message, jsString(vm, message), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
118 
<span class="line-modified">119     std::unique_ptr&lt;Vector&lt;StackFrame&gt;&gt; stackTrace = getStackTrace(globalObject, vm, this, useCurrentFrame);</span>
120     {
121         auto locker = holdLock(cellLock());
122         m_stackTrace = WTFMove(stackTrace);
123     }
124     vm.heap.writeBarrier(this);
125 
126     if (m_stackTrace &amp;&amp; !m_stackTrace-&gt;isEmpty() &amp;&amp; hasSourceAppender()) {
<span class="line-modified">127         BytecodeIndex bytecodeIndex;</span>
128         CallFrame* callFrame;
<span class="line-modified">129         getBytecodeIndex(vm, vm.topCallFrame, m_stackTrace.get(), callFrame, bytecodeIndex);</span>
<span class="line-modified">130         if (callFrame &amp;&amp; callFrame-&gt;codeBlock() &amp;&amp; !callFrame-&gt;callee().isWasm())</span>
<span class="line-modified">131             appendSourceToError(globalObject, callFrame, this, bytecodeIndex);</span>


132     }
133 }
134 





135 // Based on ErrorPrototype&#39;s errorProtoFuncToString(), but is modified to
136 // have no observable side effects to the user (i.e. does not call proxies,
137 // and getters).
<span class="line-modified">138 String ErrorInstance::sanitizedToString(JSGlobalObject* globalObject)</span>
139 {
<span class="line-modified">140     VM&amp; vm = globalObject-&gt;vm();</span>
141     auto scope = DECLARE_THROW_SCOPE(vm);
142 
143     JSValue nameValue;
144     auto namePropertName = vm.propertyNames-&gt;name;
145     PropertySlot nameSlot(this, PropertySlot::InternalMethodType::VMInquiry);
146 
147     JSValue currentObj = this;
148     unsigned prototypeDepth = 0;
149 
150     // We only check the current object and its prototype (2 levels) because normal
151     // Error objects may have a name property, and if not, its prototype should have
152     // a name property for the type of error e.g. &quot;SyntaxError&quot;.
153     while (currentObj.isCell() &amp;&amp; prototypeDepth++ &lt; 2) {
154         JSObject* obj = jsCast&lt;JSObject*&gt;(currentObj);
<span class="line-modified">155         if (JSObject::getOwnPropertySlot(obj, globalObject, namePropertName, nameSlot) &amp;&amp; nameSlot.isValue()) {</span>
<span class="line-modified">156             nameValue = nameSlot.getValue(globalObject, namePropertName);</span>
157             break;
158         }
159         currentObj = obj-&gt;getPrototypeDirect(vm);
160     }
161     scope.assertNoException();
162 
163     String nameString;
164     if (!nameValue)
165         nameString = &quot;Error&quot;_s;
166     else {
<span class="line-modified">167         nameString = nameValue.toWTFString(globalObject);</span>
168         RETURN_IF_EXCEPTION(scope, String());
169     }
170 
171     JSValue messageValue;
172     auto messagePropertName = vm.propertyNames-&gt;message;
173     PropertySlot messageSlot(this, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">174     if (JSObject::getOwnPropertySlot(this, globalObject, messagePropertName, messageSlot) &amp;&amp; messageSlot.isValue())</span>
<span class="line-modified">175         messageValue = messageSlot.getValue(globalObject, messagePropertName);</span>
176     scope.assertNoException();
177 
178     String messageString;
179     if (!messageValue)
180         messageString = String();
181     else {
<span class="line-modified">182         messageString = messageValue.toWTFString(globalObject);</span>
183         RETURN_IF_EXCEPTION(scope, String());
184     }
185 
186     if (!nameString.length())
187         return messageString;
188 
189     if (!messageString.length())
190         return nameString;
191 
192     StringBuilder builder;
193     builder.append(nameString);
194     builder.appendLiteral(&quot;: &quot;);
195     builder.append(messageString);
196     return builder.toString();
197 }
198 
199 void ErrorInstance::finalizeUnconditionally(VM&amp; vm)
200 {
201     if (!m_stackTrace)
202         return;
</pre>
<hr />
<pre>
214 
215 void ErrorInstance::computeErrorInfo(VM&amp; vm)
216 {
217     ASSERT(!m_errorInfoMaterialized);
218 
219     if (m_stackTrace &amp;&amp; !m_stackTrace-&gt;isEmpty()) {
220         getLineColumnAndSource(m_stackTrace.get(), m_line, m_column, m_sourceURL);
221         m_stackString = Interpreter::stackTraceAsString(vm, *m_stackTrace.get());
222         m_stackTrace = nullptr;
223     }
224 }
225 
226 bool ErrorInstance::materializeErrorInfoIfNeeded(VM&amp; vm)
227 {
228     if (m_errorInfoMaterialized)
229         return false;
230 
231     computeErrorInfo(vm);
232 
233     if (!m_stackString.isNull()) {
<span class="line-modified">234         auto attributes = static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum);</span>
<span class="line-modified">235 </span>
<span class="line-added">236         putDirect(vm, vm.propertyNames-&gt;line, jsNumber(m_line), attributes);</span>
<span class="line-added">237         putDirect(vm, vm.propertyNames-&gt;column, jsNumber(m_column), attributes);</span>
238         if (!m_sourceURL.isEmpty())
<span class="line-modified">239             putDirect(vm, vm.propertyNames-&gt;sourceURL, jsString(vm, WTFMove(m_sourceURL)), attributes);</span>
240 
<span class="line-modified">241         putDirect(vm, vm.propertyNames-&gt;stack, jsString(vm, WTFMove(m_stackString)), attributes);</span>
242     }
243 
244     m_errorInfoMaterialized = true;
245     return true;
246 }
247 
248 bool ErrorInstance::materializeErrorInfoIfNeeded(VM&amp; vm, PropertyName propertyName)
249 {
250     if (propertyName == vm.propertyNames-&gt;line
251         || propertyName == vm.propertyNames-&gt;column
252         || propertyName == vm.propertyNames-&gt;sourceURL
253         || propertyName == vm.propertyNames-&gt;stack)
254         return materializeErrorInfoIfNeeded(vm);
255     return false;
256 }
257 
<span class="line-modified">258 bool ErrorInstance::getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
259 {
<span class="line-modified">260     VM&amp; vm = globalObject-&gt;vm();</span>
261     ErrorInstance* thisObject = jsCast&lt;ErrorInstance*&gt;(object);
262     thisObject-&gt;materializeErrorInfoIfNeeded(vm, propertyName);
<span class="line-modified">263     return Base::getOwnPropertySlot(thisObject, globalObject, propertyName, slot);</span>
264 }
265 
<span class="line-modified">266 void ErrorInstance::getOwnNonIndexPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNameArray, EnumerationMode enumerationMode)</span>
267 {
<span class="line-modified">268     VM&amp; vm = globalObject-&gt;vm();</span>
269     ErrorInstance* thisObject = jsCast&lt;ErrorInstance*&gt;(object);
270     thisObject-&gt;materializeErrorInfoIfNeeded(vm);
<span class="line-modified">271     Base::getOwnNonIndexPropertyNames(thisObject, globalObject, propertyNameArray, enumerationMode);</span>
272 }
273 
<span class="line-modified">274 void ErrorInstance::getStructurePropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNameArray, EnumerationMode enumerationMode)</span>
275 {
<span class="line-modified">276     VM&amp; vm = globalObject-&gt;vm();</span>
277     ErrorInstance* thisObject = jsCast&lt;ErrorInstance*&gt;(object);
278     thisObject-&gt;materializeErrorInfoIfNeeded(vm);
<span class="line-modified">279     Base::getStructurePropertyNames(thisObject, globalObject, propertyNameArray, enumerationMode);</span>
280 }
281 
<span class="line-modified">282 bool ErrorInstance::defineOwnProperty(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
283 {
<span class="line-modified">284     VM&amp; vm = globalObject-&gt;vm();</span>
285     ErrorInstance* thisObject = jsCast&lt;ErrorInstance*&gt;(object);
286     thisObject-&gt;materializeErrorInfoIfNeeded(vm, propertyName);
<span class="line-modified">287     return Base::defineOwnProperty(thisObject, globalObject, propertyName, descriptor, shouldThrow);</span>
288 }
289 
<span class="line-modified">290 bool ErrorInstance::put(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
291 {
<span class="line-modified">292     VM&amp; vm = globalObject-&gt;vm();</span>
293     ErrorInstance* thisObject = jsCast&lt;ErrorInstance*&gt;(cell);
294     bool materializedProperties = thisObject-&gt;materializeErrorInfoIfNeeded(vm, propertyName);
295     if (materializedProperties)
296         slot.disableCaching();
<span class="line-modified">297     return Base::put(thisObject, globalObject, propertyName, value, slot);</span>
298 }
299 
<span class="line-modified">300 bool ErrorInstance::deleteProperty(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)</span>
301 {
<span class="line-modified">302     VM&amp; vm = globalObject-&gt;vm();</span>
303     ErrorInstance* thisObject = jsCast&lt;ErrorInstance*&gt;(cell);
304     thisObject-&gt;materializeErrorInfoIfNeeded(vm, propertyName);
<span class="line-modified">305     return Base::deleteProperty(thisObject, globalObject, propertyName);</span>
306 }
307 
308 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="ErrorConstructor.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ErrorInstance.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
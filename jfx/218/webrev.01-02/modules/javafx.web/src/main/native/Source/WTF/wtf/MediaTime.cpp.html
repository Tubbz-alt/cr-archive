<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/wtf/MediaTime.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2012-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &lt;wtf/MediaTime.h&gt;
 31 
 32 #include &lt;algorithm&gt;
 33 #include &lt;cstdlib&gt;
 34 #include &lt;wtf/Assertions.h&gt;
 35 #include &lt;wtf/CheckedArithmetic.h&gt;
 36 #include &lt;wtf/JSONValues.h&gt;
 37 #include &lt;wtf/MathExtras.h&gt;
 38 #include &lt;wtf/PrintStream.h&gt;
 39 #include &lt;wtf/text/StringBuilder.h&gt;
 40 #include &lt;wtf/text/TextStream.h&gt;
 41 
 42 namespace WTF {
 43 
 44 static_assert(std::is_trivially_destructible_v&lt;MediaTime&gt;, &quot;MediaTime should be trivially destructible.&quot;);
 45 
 46 static uint32_t greatestCommonDivisor(uint32_t a, uint32_t b)
 47 {
 48     ASSERT(a);
 49     ASSERT(b);
 50 
 51     // Euclid&#39;s Algorithm
 52     uint32_t temp = 0;
 53     while (b) {
 54         temp = b;
 55         b = a % b;
 56         a = temp;
 57     }
 58 
 59     ASSERT(a);
 60     return a;
 61 }
 62 
 63 static uint32_t leastCommonMultiple(uint32_t a, uint32_t b, uint32_t &amp;result)
 64 {
 65     return safeMultiply(a, b / greatestCommonDivisor(a, b), result);
 66 }
 67 
 68 static int64_t signum(int64_t val)
 69 {
 70     return (0 &lt; val) - (val &lt; 0);
 71 }
 72 
 73 const uint32_t MediaTime::MaximumTimeScale = 1000000000;
 74 
 75 MediaTime::MediaTime(const MediaTime&amp; rhs)
 76 {
 77     *this = rhs;
 78 }
 79 
 80 MediaTime MediaTime::createWithFloat(float floatTime)
 81 {
 82     if (floatTime != floatTime)
 83         return invalidTime();
 84     if (std::isinf(floatTime))
 85         return std::signbit(floatTime) ? negativeInfiniteTime() : positiveInfiniteTime();
 86 
 87     MediaTime value(0, DefaultTimeScale, Valid | DoubleValue);
 88     value.m_timeValueAsDouble = floatTime;
 89     return value;
 90 }
 91 
 92 MediaTime MediaTime::createWithFloat(float floatTime, uint32_t timeScale)
 93 {
 94     if (floatTime != floatTime)
 95         return invalidTime();
 96     if (std::isinf(floatTime))
 97         return std::signbit(floatTime) ? negativeInfiniteTime() : positiveInfiniteTime();
 98     if (floatTime &gt; std::numeric_limits&lt;int64_t&gt;::max())
 99         return positiveInfiniteTime();
100     if (floatTime &lt; std::numeric_limits&lt;int64_t&gt;::min())
101         return negativeInfiniteTime();
102     if (!timeScale)
103         return std::signbit(floatTime) ? negativeInfiniteTime() : positiveInfiniteTime();
104 
105     while (floatTime * timeScale &gt; std::numeric_limits&lt;int64_t&gt;::max())
106         timeScale /= 2;
107     return MediaTime(static_cast&lt;int64_t&gt;(floatTime * timeScale), timeScale, Valid);
108 }
109 
110 MediaTime MediaTime::createWithDouble(double doubleTime)
111 {
112     if (doubleTime != doubleTime)
113         return invalidTime();
114     if (std::isinf(doubleTime))
115         return std::signbit(doubleTime) ? negativeInfiniteTime() : positiveInfiniteTime();
116 
117     MediaTime value(0, DefaultTimeScale, Valid | DoubleValue);
118     value.m_timeValueAsDouble = doubleTime;
119     return value;
120 }
121 
122 MediaTime MediaTime::createWithDouble(double doubleTime, uint32_t timeScale)
123 {
124     if (doubleTime != doubleTime)
125         return invalidTime();
126     if (std::isinf(doubleTime))
127         return std::signbit(doubleTime) ? negativeInfiniteTime() : positiveInfiniteTime();
128     if (doubleTime &gt; std::numeric_limits&lt;int64_t&gt;::max())
129         return positiveInfiniteTime();
130     if (doubleTime &lt; std::numeric_limits&lt;int64_t&gt;::min())
131         return negativeInfiniteTime();
132     if (!timeScale)
133         return std::signbit(doubleTime) ? negativeInfiniteTime() : positiveInfiniteTime();
134 
135     while (doubleTime * timeScale &gt; std::numeric_limits&lt;int64_t&gt;::max())
136         timeScale /= 2;
137     return MediaTime(static_cast&lt;int64_t&gt;(std::round(doubleTime * timeScale)), timeScale, Valid);
138 }
139 
140 float MediaTime::toFloat() const
141 {
142     if (isInvalid() || isIndefinite())
143         return std::numeric_limits&lt;float&gt;::quiet_NaN();
144     if (isPositiveInfinite())
145         return std::numeric_limits&lt;float&gt;::infinity();
146     if (isNegativeInfinite())
147         return -std::numeric_limits&lt;float&gt;::infinity();
148     if (hasDoubleValue())
149         return m_timeValueAsDouble;
150     return static_cast&lt;float&gt;(m_timeValue) / m_timeScale;
151 }
152 
153 double MediaTime::toDouble() const
154 {
155     if (isInvalid() || isIndefinite())
156         return std::numeric_limits&lt;double&gt;::quiet_NaN();
157     if (isPositiveInfinite())
158         return std::numeric_limits&lt;double&gt;::infinity();
159     if (isNegativeInfinite())
160         return -std::numeric_limits&lt;double&gt;::infinity();
161     if (hasDoubleValue())
162         return m_timeValueAsDouble;
163     return static_cast&lt;double&gt;(m_timeValue) / m_timeScale;
164 }
165 
166 MediaTime&amp; MediaTime::operator=(const MediaTime&amp; rhs)
167 {
168     m_timeValue = rhs.m_timeValue;
169     m_timeScale = rhs.m_timeScale;
170     m_timeFlags = rhs.m_timeFlags;
171     return *this;
172 }
173 
174 MediaTime MediaTime::operator+(const MediaTime&amp; rhs) const
175 {
176     if (rhs.isInvalid() || isInvalid())
177         return invalidTime();
178 
179     if (rhs.isIndefinite() || isIndefinite())
180         return indefiniteTime();
181 
182     if (isPositiveInfinite() &amp;&amp; rhs.isNegativeInfinite())
183         return invalidTime();
184 
185     if (isNegativeInfinite() &amp;&amp; rhs.isPositiveInfinite())
186         return invalidTime();
187 
188     if (isPositiveInfinite() || rhs.isPositiveInfinite())
189         return positiveInfiniteTime();
190 
191     if (isNegativeInfinite() || rhs.isNegativeInfinite())
192         return negativeInfiniteTime();
193 
194     if (hasDoubleValue() &amp;&amp; rhs.hasDoubleValue())
195         return MediaTime::createWithDouble(m_timeValueAsDouble + rhs.m_timeValueAsDouble);
196 
197     if (hasDoubleValue() || rhs.hasDoubleValue())
198         return MediaTime::createWithDouble(toDouble() + rhs.toDouble());
199 
200     MediaTime a = *this;
201     MediaTime b = rhs;
202 
203     uint32_t commonTimeScale;
204     if (!leastCommonMultiple(a.m_timeScale, b.m_timeScale, commonTimeScale) || commonTimeScale &gt; MaximumTimeScale)
205         commonTimeScale = MaximumTimeScale;
206     a.setTimeScale(commonTimeScale);
207     b.setTimeScale(commonTimeScale);
208     while (!safeAdd(a.m_timeValue, b.m_timeValue, a.m_timeValue)) {
209         if (commonTimeScale == 1)
210             return a.m_timeValue &gt; 0 ? positiveInfiniteTime() : negativeInfiniteTime();
211         commonTimeScale /= 2;
212         a.setTimeScale(commonTimeScale);
213         b.setTimeScale(commonTimeScale);
214     }
215     return a;
216 }
217 
218 MediaTime MediaTime::operator-(const MediaTime&amp; rhs) const
219 {
220     if (rhs.isInvalid() || isInvalid())
221         return invalidTime();
222 
223     if (rhs.isIndefinite() || isIndefinite())
224         return indefiniteTime();
225 
226     if (isPositiveInfinite() &amp;&amp; rhs.isPositiveInfinite())
227         return invalidTime();
228 
229     if (isNegativeInfinite() &amp;&amp; rhs.isNegativeInfinite())
230         return invalidTime();
231 
232     if (isPositiveInfinite() || rhs.isNegativeInfinite())
233         return positiveInfiniteTime();
234 
235     if (isNegativeInfinite() || rhs.isPositiveInfinite())
236         return negativeInfiniteTime();
237 
238     if (hasDoubleValue() &amp;&amp; rhs.hasDoubleValue())
239         return MediaTime::createWithDouble(m_timeValueAsDouble - rhs.m_timeValueAsDouble);
240 
241     if (hasDoubleValue() || rhs.hasDoubleValue())
242         return MediaTime::createWithDouble(toDouble() - rhs.toDouble());
243 
244     MediaTime a = *this;
245     MediaTime b = rhs;
246 
247     uint32_t commonTimeScale;
248     if (!leastCommonMultiple(this-&gt;m_timeScale, rhs.m_timeScale, commonTimeScale) || commonTimeScale &gt; MaximumTimeScale)
249         commonTimeScale = MaximumTimeScale;
250     a.setTimeScale(commonTimeScale);
251     b.setTimeScale(commonTimeScale);
252     while (!safeSub(a.m_timeValue, b.m_timeValue, a.m_timeValue)) {
253         if (commonTimeScale == 1)
254             return a.m_timeValue &gt; 0 ? positiveInfiniteTime() : negativeInfiniteTime();
255         commonTimeScale /= 2;
256         a.setTimeScale(commonTimeScale);
257         b.setTimeScale(commonTimeScale);
258     }
259     return a;
260 }
261 
262 MediaTime MediaTime::operator-() const
263 {
264     if (isInvalid())
265         return invalidTime();
266 
267     if (isIndefinite())
268         return indefiniteTime();
269 
270     if (isPositiveInfinite())
271         return negativeInfiniteTime();
272 
273     if (isNegativeInfinite())
274         return positiveInfiniteTime();
275 
276     MediaTime negativeTime = *this;
277     if (negativeTime.hasDoubleValue())
278         negativeTime.m_timeValueAsDouble = -negativeTime.m_timeValueAsDouble;
279     else
280         negativeTime.m_timeValue = -negativeTime.m_timeValue;
281     return negativeTime;
282 }
283 
284 MediaTime MediaTime::operator*(int32_t rhs) const
285 {
286     if (isInvalid())
287         return invalidTime();
288 
289     if (isIndefinite())
290         return indefiniteTime();
291 
292     if (!rhs)
293         return zeroTime();
294 
295     if (isPositiveInfinite()) {
296         if (rhs &gt; 0)
297             return positiveInfiniteTime();
298         return negativeInfiniteTime();
299     }
300 
301     if (isNegativeInfinite()) {
302         if (rhs &gt; 0)
303             return negativeInfiniteTime();
304         return positiveInfiniteTime();
305     }
306 
307     MediaTime a = *this;
308 
309     if (a.hasDoubleValue()) {
310         a.m_timeValueAsDouble *= rhs;
311         return a;
312     }
313 
314     while (!safeMultiply(a.m_timeValue, rhs, a.m_timeValue)) {
315         if (a.m_timeScale == 1)
316             return signum(a.m_timeValue) == signum(rhs) ? positiveInfiniteTime() : negativeInfiniteTime();
317         a.setTimeScale(a.m_timeScale / 2);
318     }
319 
320     return a;
321 }
322 
323 bool MediaTime::operator!() const
324 {
325     return (m_timeFlags == Valid &amp;&amp; !m_timeValue)
326         || (m_timeFlags == (Valid | DoubleValue) &amp;&amp; !m_timeValueAsDouble)
327         || isInvalid();
328 }
329 
330 MediaTime::operator bool() const
331 {
332     return !(m_timeFlags == Valid &amp;&amp; !m_timeValue)
333         &amp;&amp; !(m_timeFlags == (Valid | DoubleValue) &amp;&amp; !m_timeValueAsDouble)
334         &amp;&amp; !isInvalid();
335 }
336 
337 MediaTime::ComparisonFlags MediaTime::compare(const MediaTime&amp; rhs) const
338 {
339     auto andFlags = m_timeFlags &amp; rhs.m_timeFlags;
340     if (andFlags &amp; (PositiveInfinite | NegativeInfinite | Indefinite))
341         return EqualTo;
342 
343     auto orFlags = m_timeFlags | rhs.m_timeFlags;
344     if (!(orFlags &amp; Valid))
345         return EqualTo;
346 
347     if (!(andFlags &amp; Valid))
348         return isInvalid() ? GreaterThan : LessThan;
349 
350     if (orFlags &amp; NegativeInfinite)
351         return isNegativeInfinite() ? LessThan : GreaterThan;
352 
353     if (orFlags &amp; PositiveInfinite)
354         return isPositiveInfinite() ? GreaterThan : LessThan;
355 
356     if (orFlags &amp; Indefinite)
357         return isIndefinite() ? GreaterThan : LessThan;
358 
359     if (andFlags &amp; DoubleValue) {
360         if (m_timeValueAsDouble == rhs.m_timeValueAsDouble)
361             return EqualTo;
362 
363         return m_timeValueAsDouble &lt; rhs.m_timeValueAsDouble ? LessThan : GreaterThan;
364     }
365 
366     if (orFlags &amp; DoubleValue) {
367         double a = toDouble();
368         double b = rhs.toDouble();
369         if (a &gt; b)
370             return GreaterThan;
371         if (a &lt; b)
372             return LessThan;
373         return EqualTo;
374     }
375 
376     if ((m_timeValue &lt; 0) != (rhs.m_timeValue &lt; 0))
377         return m_timeValue &lt; 0 ? LessThan : GreaterThan;
378 
379     if (!m_timeValue &amp;&amp; !rhs.m_timeValue)
380         return EqualTo;
381 
382     if (m_timeScale == rhs.m_timeScale) {
383         if (m_timeValue == rhs.m_timeValue)
384             return EqualTo;
385         return m_timeValue &lt; rhs.m_timeValue ? LessThan : GreaterThan;
386     }
387 
388     if (m_timeValue == rhs.m_timeValue)
389         return m_timeScale &lt; rhs.m_timeScale ? GreaterThan : LessThan;
390 
391     if (m_timeValue &gt;= 0) {
392         if (m_timeValue &lt; rhs.m_timeValue &amp;&amp; m_timeScale &gt; rhs.m_timeScale)
393             return LessThan;
394 
395         if (m_timeValue &gt; rhs.m_timeValue &amp;&amp; m_timeScale &lt; rhs.m_timeScale)
396             return GreaterThan;
397     } else {
398         if (m_timeValue &lt; rhs.m_timeValue &amp;&amp; m_timeScale &lt; rhs.m_timeScale)
399             return LessThan;
400 
401         if (m_timeValue &gt; rhs.m_timeValue &amp;&amp; m_timeScale &gt; rhs.m_timeScale)
402             return GreaterThan;
403     }
404 
405     int64_t lhsFactor;
406     int64_t rhsFactor;
407     if (safeMultiply(m_timeValue, static_cast&lt;int64_t&gt;(rhs.m_timeScale), lhsFactor)
408         &amp;&amp; safeMultiply(rhs.m_timeValue, static_cast&lt;int64_t&gt;(m_timeScale), rhsFactor)) {
409         if (lhsFactor == rhsFactor)
410             return EqualTo;
411         return lhsFactor &lt; rhsFactor ? LessThan : GreaterThan;
412     }
413 
414     int64_t rhsWhole = rhs.m_timeValue / rhs.m_timeScale;
415     int64_t lhsWhole = m_timeValue / m_timeScale;
416     if (lhsWhole &gt; rhsWhole)
417         return GreaterThan;
418     if (lhsWhole &lt; rhsWhole)
419         return LessThan;
420 
421     int64_t rhsRemain = rhs.m_timeValue % rhs.m_timeScale;
422     int64_t lhsRemain = m_timeValue % m_timeScale;
423     lhsFactor = lhsRemain * rhs.m_timeScale;
424     rhsFactor = rhsRemain * m_timeScale;
425 
426     if (lhsFactor == rhsFactor)
427         return EqualTo;
428     return lhsFactor &gt; rhsFactor ? GreaterThan : LessThan;
429 }
430 
431 bool MediaTime::isBetween(const MediaTime&amp; a, const MediaTime&amp; b) const
432 {
433     if (a &gt; b)
434         return *this &gt; b &amp;&amp; *this &lt; a;
435     return *this &gt; a &amp;&amp; *this &lt; b;
436 }
437 
438 const MediaTime&amp; MediaTime::zeroTime()
439 {
440     static const MediaTime time(0, 1, Valid);
441     return time;
442 }
443 
444 const MediaTime&amp; MediaTime::invalidTime()
445 {
446     static const MediaTime time(-1, 1, 0);
447     return time;
448 }
449 
450 const MediaTime&amp; MediaTime::positiveInfiniteTime()
451 {
452     static const MediaTime time(0, 1, PositiveInfinite | Valid);
453     return time;
454 }
455 
456 const MediaTime&amp; MediaTime::negativeInfiniteTime()
457 {
458     static const MediaTime time(-1, 1, NegativeInfinite | Valid);
459     return time;
460 }
461 
462 const MediaTime&amp; MediaTime::indefiniteTime()
463 {
464     static const MediaTime time(0, 1, Indefinite | Valid);
465     return time;
466 }
467 
468 MediaTime MediaTime::toTimeScale(uint32_t timeScale, RoundingFlags flags) const
469 {
470     MediaTime result = *this;
471     result.setTimeScale(timeScale, flags);
472     return result;
473 }
474 
475 void MediaTime::setTimeScale(uint32_t timeScale, RoundingFlags flags)
476 {
477     if (hasDoubleValue()) {
478         *this = MediaTime::createWithDouble(m_timeValueAsDouble, timeScale);
479         return;
480     }
481 
482     if (!timeScale) {
483         *this = m_timeValue &lt; 0 ? negativeInfiniteTime() : positiveInfiniteTime();
484         return;
485     }
486 
487     if (timeScale == m_timeScale)
488         return;
489 
490     timeScale = std::min(MaximumTimeScale, timeScale);
491 
492 #if HAVE(INT128_T)
493     __int128_t newValue = static_cast&lt;__int128_t&gt;(m_timeValue) * timeScale;
494     int64_t remainder = newValue % m_timeScale;
495     newValue = newValue / m_timeScale;
496 
497     if (newValue &lt; std::numeric_limits&lt;int64_t&gt;::min()) {
498         *this = negativeInfiniteTime();
499         return;
500     }
501 
502     if (newValue &gt; std::numeric_limits&lt;int64_t&gt;::max()) {
503         *this = positiveInfiniteTime();
504         return;
505     }
506 #else
507     int64_t newValue = m_timeValue / m_timeScale;
508     int64_t partialRemainder = (m_timeValue % m_timeScale) * timeScale;
509     int64_t remainder = partialRemainder % m_timeScale;
510 
511     if (!safeMultiply&lt;int64_t&gt;(newValue, static_cast&lt;int64_t&gt;(timeScale), newValue)
512         || !safeAdd(newValue, partialRemainder / m_timeScale, newValue)) {
513         *this = newValue &lt; 0 ? negativeInfiniteTime() : positiveInfiniteTime();
514         return;
515     }
516 #endif
517 
518     m_timeValue = newValue;
519     std::swap(m_timeScale, timeScale);
520 
521     if (!remainder)
522         return;
523 
524     m_timeFlags |= HasBeenRounded;
525     switch (flags) {
526     case RoundingFlags::HalfAwayFromZero:
527         if (static_cast&lt;int64_t&gt;(llabs(remainder)) * 2 &gt;= static_cast&lt;int64_t&gt;(timeScale)) {
528             // round up (away from zero)
529             if (remainder &lt; 0)
530                 m_timeValue--;
531             else
532                 m_timeValue++;
533         }
534         break;
535 
536     case RoundingFlags::TowardZero:
537         break;
538 
539     case RoundingFlags::AwayFromZero:
540         if (remainder &lt; 0)
541             m_timeValue--;
542         else
543             m_timeValue++;
544         break;
545 
546     case RoundingFlags::TowardPositiveInfinity:
547         if (remainder &gt; 0)
548             m_timeValue++;
549         break;
550 
551     case RoundingFlags::TowardNegativeInfinity:
552         if (remainder &lt; 0)
553             m_timeValue--;
554         break;
555     }
556 }
557 
558 void MediaTime::dump(PrintStream&amp; out) const
559 {
560     out.print(&quot;{&quot;);
561     if (!hasDoubleValue())
562         out.print(m_timeValue, &quot;/&quot;, m_timeScale, &quot; = &quot;);
563     out.print(toDouble(), &quot;}&quot;);
564 }
565 
566 String MediaTime::toString() const
567 {
568     StringBuilder builder;
569     builder.append(&#39;{&#39;);
570     if (!hasDoubleValue())
571         builder.append(m_timeValue, &#39;/&#39;, m_timeScale, &quot; = &quot;);
572     builder.append(toDouble());
573     if (isInvalid())
574         builder.appendLiteral(&quot;, invalid&quot;);
575     builder.append(&#39;}&#39;);
576     return builder.toString();
577 }
578 
579 Ref&lt;JSON::Object&gt; MediaTime::toJSONObject() const
580 {
581     auto object = JSON::Object::create();
582 
583     if (hasDoubleValue()) {
584         object-&gt;setDouble(&quot;value&quot;_s, toDouble());
585         return object;
586     }
587 
588     if (isInvalid())
589         object-&gt;setBoolean(&quot;invalid&quot;_s, true);
590     else if (isIndefinite())
591         object-&gt;setString(&quot;value&quot;_s, &quot;NaN&quot;_s);
592     else if (isPositiveInfinite())
593         object-&gt;setString(&quot;value&quot;_s, &quot;POSITIVE_INFINITY&quot;_s);
594     else if (isNegativeInfinite())
595         object-&gt;setString(&quot;value&quot;_s, &quot;NEGATIVE_INFINITY&quot;_s);
596     else
597         object-&gt;setDouble(&quot;value&quot;_s, toDouble());
598 
599     object-&gt;setDouble(&quot;numerator&quot;_s, static_cast&lt;double&gt;(m_timeValue));
600     object-&gt;setInteger(&quot;denominator&quot;_s, m_timeScale);
601     object-&gt;setInteger(&quot;flags&quot;_s, m_timeFlags);
602 
603     return object;
604 }
605 
606 String MediaTime::toJSONString() const
607 {
608     return toJSONObject()-&gt;toJSONString();
609 }
610 
611 MediaTime abs(const MediaTime&amp; rhs)
612 {
613     if (rhs.isInvalid())
614         return MediaTime::invalidTime();
615     if (rhs.isNegativeInfinite() || rhs.isPositiveInfinite())
616         return MediaTime::positiveInfiniteTime();
617     if (rhs.hasDoubleValue())
618         return MediaTime::createWithDouble(fabs(rhs.m_timeValueAsDouble));
619 
620     MediaTime val = rhs;
621     val.m_timeValue = std::abs(rhs.m_timeValue);
622     return val;
623 }
624 
625 String MediaTimeRange::toJSONString() const
626 {
627     auto object = JSON::Object::create();
628 
629     object-&gt;setObject(&quot;start&quot;_s, start.toJSONObject());
630     object-&gt;setObject(&quot;end&quot;_s, end.toJSONObject());
631 
632     return object-&gt;toJSONString();
633 }
634 
635 #ifndef NDEBUG
636 
637 TextStream&amp; operator&lt;&lt;(TextStream&amp; stream, const MediaTime&amp; time)
638 {
639     return stream &lt;&lt; time.toJSONString();
640 }
641 
642 #endif
643 
644 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/AsyncScrollingCoordinator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2014-2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #if ENABLE(ASYNC_SCROLLING)
 29 #include &quot;AsyncScrollingCoordinator.h&quot;
 30 
 31 #include &quot;DebugPageOverlays.h&quot;
 32 #include &quot;Document.h&quot;
 33 #include &quot;EditorClient.h&quot;
 34 #include &quot;Frame.h&quot;
 35 #include &quot;FrameView.h&quot;
 36 #include &quot;GraphicsLayer.h&quot;
 37 #include &quot;Logging.h&quot;
 38 #include &quot;Page.h&quot;
 39 #include &quot;PerformanceLoggingClient.h&quot;
 40 #include &quot;RenderLayerCompositor.h&quot;
 41 #include &quot;RenderView.h&quot;
 42 #include &quot;ScrollAnimator.h&quot;
 43 #include &quot;ScrollingConstraints.h&quot;
 44 #include &quot;ScrollingStateFixedNode.h&quot;
 45 #include &quot;ScrollingStateFrameHostingNode.h&quot;
 46 #include &quot;ScrollingStateFrameScrollingNode.h&quot;
 47 #include &quot;ScrollingStateOverflowScrollProxyNode.h&quot;
 48 #include &quot;ScrollingStateOverflowScrollingNode.h&quot;
 49 #include &quot;ScrollingStatePositionedNode.h&quot;
 50 #include &quot;ScrollingStateStickyNode.h&quot;
 51 #include &quot;ScrollingStateTree.h&quot;
 52 #include &quot;Settings.h&quot;
<a name="1" id="anc1"></a><span class="line-modified"> 53 #include &quot;WheelEventTestMonitor.h&quot;</span>
 54 #include &lt;wtf/ProcessID.h&gt;
 55 #include &lt;wtf/text/TextStream.h&gt;
 56 
 57 namespace WebCore {
 58 
 59 AsyncScrollingCoordinator::AsyncScrollingCoordinator(Page* page)
 60     : ScrollingCoordinator(page)
 61     , m_updateNodeScrollPositionTimer(*this, &amp;AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScrollTimerFired)
 62     , m_scrollingStateTree(makeUnique&lt;ScrollingStateTree&gt;(this))
 63 {
 64 }
 65 
 66 AsyncScrollingCoordinator::~AsyncScrollingCoordinator() = default;
 67 
 68 void AsyncScrollingCoordinator::scrollingStateTreePropertiesChanged()
 69 {
 70     scheduleTreeStateCommit();
 71 }
 72 
 73 #if ENABLE(CSS_SCROLL_SNAP)
 74 static inline void setStateScrollingNodeSnapOffsetsAsFloat(ScrollingStateScrollingNode&amp; node, ScrollEventAxis axis, const Vector&lt;LayoutUnit&gt;* snapOffsets, const Vector&lt;ScrollOffsetRange&lt;LayoutUnit&gt;&gt;* snapOffsetRanges, float deviceScaleFactor)
 75 {
 76     // FIXME: Incorporate current page scale factor in snapping to device pixel. Perhaps we should just convert to float here and let UI process do the pixel snapping?
 77     Vector&lt;float&gt; snapOffsetsAsFloat;
 78     if (snapOffsets) {
 79         snapOffsetsAsFloat.reserveInitialCapacity(snapOffsets-&gt;size());
 80         for (auto&amp; offset : *snapOffsets)
 81             snapOffsetsAsFloat.uncheckedAppend(roundToDevicePixel(offset, deviceScaleFactor, false));
 82     }
 83 
 84     Vector&lt;ScrollOffsetRange&lt;float&gt;&gt; snapOffsetRangesAsFloat;
 85     if (snapOffsetRanges) {
 86         snapOffsetRangesAsFloat.reserveInitialCapacity(snapOffsetRanges-&gt;size());
 87         for (auto&amp; range : *snapOffsetRanges)
 88             snapOffsetRangesAsFloat.uncheckedAppend({ roundToDevicePixel(range.start, deviceScaleFactor, false), roundToDevicePixel(range.end, deviceScaleFactor, false) });
 89     }
 90     if (axis == ScrollEventAxis::Horizontal) {
 91         node.setHorizontalSnapOffsets(snapOffsetsAsFloat);
 92         node.setHorizontalSnapOffsetRanges(snapOffsetRangesAsFloat);
 93     } else {
 94         node.setVerticalSnapOffsets(snapOffsetsAsFloat);
 95         node.setVerticalSnapOffsetRanges(snapOffsetRangesAsFloat);
 96     }
 97 }
 98 #endif
 99 
100 void AsyncScrollingCoordinator::setEventTrackingRegionsDirty()
101 {
102     m_eventTrackingRegionsDirty = true;
103     // We have to schedule a commit, but the computed non-fast region may not have actually changed.
104     scheduleTreeStateCommit();
105 }
106 
107 void AsyncScrollingCoordinator::willCommitTree()
108 {
109     updateEventTrackingRegions();
110 }
111 
112 void AsyncScrollingCoordinator::updateEventTrackingRegions()
113 {
114     if (!m_eventTrackingRegionsDirty)
115         return;
116 
117     if (!m_scrollingStateTree-&gt;rootStateNode())
118         return;
119 
120     m_scrollingStateTree-&gt;rootStateNode()-&gt;setEventTrackingRegions(absoluteEventTrackingRegions());
121     m_eventTrackingRegionsDirty = false;
122 }
123 
124 void AsyncScrollingCoordinator::frameViewLayoutUpdated(FrameView&amp; frameView)
125 {
126     ASSERT(isMainThread());
127     ASSERT(m_page);
128 
129     // If there isn&#39;t a root node yet, don&#39;t do anything. We&#39;ll be called again after creating one.
130     if (!m_scrollingStateTree-&gt;rootStateNode())
131         return;
132 
133     setEventTrackingRegionsDirty();
134 
135 #if PLATFORM(COCOA)
136     if (!coordinatesScrollingForFrameView(frameView))
137         return;
138 
139     auto* page = frameView.frame().page();
<a name="2" id="anc2"></a><span class="line-modified">140     if (page &amp;&amp; page-&gt;isMonitoringWheelEvents()) {</span>
<span class="line-modified">141         LOG_WITH_STREAM(WheelEventTestMonitor, stream &lt;&lt; &quot;    AsyncScrollingCoordinator::frameViewLayoutUpdated: Expects wheel event test trigger: &quot; &lt;&lt; page-&gt;isMonitoringWheelEvents());</span>
142 
143         auto* node = m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID());
144         if (!is&lt;ScrollingStateFrameScrollingNode&gt;(node))
145             return;
146 
147         auto&amp; frameScrollingNode = downcast&lt;ScrollingStateFrameScrollingNode&gt;(*node);
<a name="3" id="anc3"></a><span class="line-modified">148         frameScrollingNode.setIsMonitoringWheelEvents(page-&gt;isMonitoringWheelEvents());</span>
149     }
150 #else
151     UNUSED_PARAM(frameView);
152 #endif
153 }
154 
155 void AsyncScrollingCoordinator::frameViewVisualViewportChanged(FrameView&amp; frameView)
156 {
157     ASSERT(isMainThread());
158     ASSERT(m_page);
159 
160     if (!coordinatesScrollingForFrameView(frameView))
161         return;
162 
163     // If the root layer does not have a ScrollingStateNode, then we should create one.
164     auto* node = m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID());
165     if (!node)
166         return;
167 
168     auto&amp; frameScrollingNode = downcast&lt;ScrollingStateFrameScrollingNode&gt;(*node);
169 
170     auto visualViewportIsSmallerThanLayoutViewport = [](const FrameView&amp; frameView) {
171         auto layoutViewport = frameView.layoutViewportRect();
172         auto visualViewport = frameView.visualViewportRect();
173         return visualViewport.width() &lt; layoutViewport.width() || visualViewport.height() &lt; layoutViewport.height();
174     };
175     frameScrollingNode.setVisualViewportIsSmallerThanLayoutViewport(visualViewportIsSmallerThanLayoutViewport(frameView));
176 }
177 
<a name="4" id="anc4"></a><span class="line-modified">178 void AsyncScrollingCoordinator::updateIsMonitoringWheelEventsForFrameView(const FrameView&amp; frameView)</span>
179 {
180     auto* page = frameView.frame().page();
181     if (!page)
182         return;
183 
184     auto* node = downcast&lt;ScrollingStateFrameScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
185     if (!node)
186         return;
187 
<a name="5" id="anc5"></a><span class="line-modified">188     node-&gt;setIsMonitoringWheelEvents(page-&gt;isMonitoringWheelEvents());</span>
189 }
190 
191 void AsyncScrollingCoordinator::frameViewEventTrackingRegionsChanged(FrameView&amp; frameView)
192 {
193     if (!m_scrollingStateTree-&gt;rootStateNode())
194         return;
195 
196     setEventTrackingRegionsDirty();
197     DebugPageOverlays::didChangeEventHandlers(frameView.frame());
198 }
199 
200 void AsyncScrollingCoordinator::frameViewRootLayerDidChange(FrameView&amp; frameView)
201 {
202     ASSERT(isMainThread());
203     ASSERT(m_page);
204 
205     if (!coordinatesScrollingForFrameView(frameView))
206         return;
207 
208     // FIXME: In some navigation scenarios, the FrameView has no RenderView or that RenderView has not been composited.
209     // This needs cleaning up: https://bugs.webkit.org/show_bug.cgi?id=132724
210     if (!frameView.scrollingNodeID())
211         return;
212 
213     // If the root layer does not have a ScrollingStateNode, then we should create one.
214     ensureRootStateNodeForFrameView(frameView);
215     ASSERT(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
216 
217     ScrollingCoordinator::frameViewRootLayerDidChange(frameView);
218 
219     auto* node = downcast&lt;ScrollingStateFrameScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
220     node-&gt;setScrollContainerLayer(scrollContainerLayerForFrameView(frameView));
221     node-&gt;setScrolledContentsLayer(scrolledContentsLayerForFrameView(frameView));
222     node-&gt;setRootContentsLayer(rootContentsLayerForFrameView(frameView));
223     node-&gt;setCounterScrollingLayer(counterScrollingLayerForFrameView(frameView));
224     node-&gt;setInsetClipLayer(insetClipLayerForFrameView(frameView));
225     node-&gt;setContentShadowLayer(contentShadowLayerForFrameView(frameView));
226     node-&gt;setHeaderLayer(headerLayerForFrameView(frameView));
227     node-&gt;setFooterLayer(footerLayerForFrameView(frameView));
228     node-&gt;setScrollBehaviorForFixedElements(frameView.scrollBehaviorForFixedElements());
229     node-&gt;setVerticalScrollbarLayer(frameView.layerForVerticalScrollbar());
230     node-&gt;setHorizontalScrollbarLayer(frameView.layerForHorizontalScrollbar());
231 }
232 
<a name="6" id="anc6"></a><span class="line-modified">233 bool AsyncScrollingCoordinator::requestScrollPositionUpdate(ScrollableArea&amp; scrollableArea, const IntPoint&amp; scrollPosition, ScrollType scrollType, ScrollClamping clamping)</span>
234 {
235     ASSERT(isMainThread());
236     ASSERT(m_page);
237 
238     auto scrollingNodeID = scrollableArea.scrollingNodeID();
239     if (!scrollingNodeID)
240         return false;
241 
242     auto* frameView = frameViewForScrollingNode(scrollingNodeID);
243     if (!frameView)
244         return false;
245 
246     if (!coordinatesScrollingForFrameView(*frameView))
247         return false;
248 
<a name="7" id="anc7"></a><span class="line-modified">249     bool inBackForwardCache = frameView-&gt;frame().document()-&gt;backForwardCacheState() != Document::NotInBackForwardCache;</span>
250     bool inProgrammaticScroll = scrollableArea.currentScrollType() == ScrollType::Programmatic;
<a name="8" id="anc8"></a><span class="line-modified">251     if (inProgrammaticScroll || inBackForwardCache)</span>
252         updateScrollPositionAfterAsyncScroll(scrollingNodeID, scrollPosition, { }, ScrollType::Programmatic, ScrollingLayerPositionAction::Set);
253 
<a name="9" id="anc9"></a><span class="line-modified">254     ASSERT(inProgrammaticScroll == (scrollType == ScrollType::Programmatic));</span>
<span class="line-added">255 </span>
<span class="line-added">256     // If this frame view&#39;s document is being put into the back/forward cache, we don&#39;t want to update our</span>
257     // main frame scroll position. Just let the FrameView think that we did.
<a name="10" id="anc10"></a><span class="line-modified">258     if (inBackForwardCache)</span>
259         return true;
260 
261     auto* stateNode = downcast&lt;ScrollingStateScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(scrollingNodeID));
262     if (!stateNode)
263         return false;
264 
<a name="11" id="anc11"></a><span class="line-modified">265     stateNode-&gt;setRequestedScrollData({ scrollPosition, scrollType, clamping });</span>
266     return true;
267 }
268 
269 void AsyncScrollingCoordinator::applyScrollingTreeLayerPositions()
270 {
271     m_scrollingTree-&gt;applyLayerPositions();
272 }
273 
274 void AsyncScrollingCoordinator::scheduleUpdateScrollPositionAfterAsyncScroll(ScrollingNodeID nodeID, const FloatPoint&amp; scrollPosition, const Optional&lt;FloatPoint&gt;&amp; layoutViewportOrigin, ScrollingLayerPositionAction scrollingLayerPositionAction)
275 {
276     ScheduledScrollUpdate scrollUpdate(nodeID, scrollPosition, layoutViewportOrigin, scrollingLayerPositionAction);
277 
278     if (m_updateNodeScrollPositionTimer.isActive()) {
279         if (m_scheduledScrollUpdate.matchesUpdateType(scrollUpdate)) {
280             m_scheduledScrollUpdate.scrollPosition = scrollPosition;
281             m_scheduledScrollUpdate.layoutViewportOrigin = layoutViewportOrigin;
282             return;
283         }
284 
285         // If the parameters don&#39;t match what was previously scheduled, dispatch immediately.
286         m_updateNodeScrollPositionTimer.stop();
287         updateScrollPositionAfterAsyncScroll(m_scheduledScrollUpdate.nodeID, m_scheduledScrollUpdate.scrollPosition, m_scheduledScrollUpdate.layoutViewportOrigin, ScrollType::User, m_scheduledScrollUpdate.updateLayerPositionAction);
288         updateScrollPositionAfterAsyncScroll(nodeID, scrollPosition, layoutViewportOrigin, ScrollType::User, scrollingLayerPositionAction);
289         return;
290     }
291 
292     m_scheduledScrollUpdate = scrollUpdate;
293     m_updateNodeScrollPositionTimer.startOneShot(0_s);
294 }
295 
296 void AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScrollTimerFired()
297 {
298     updateScrollPositionAfterAsyncScroll(m_scheduledScrollUpdate.nodeID, m_scheduledScrollUpdate.scrollPosition, m_scheduledScrollUpdate.layoutViewportOrigin, ScrollType::User, m_scheduledScrollUpdate.updateLayerPositionAction);
299 }
300 
301 FrameView* AsyncScrollingCoordinator::frameViewForScrollingNode(ScrollingNodeID scrollingNodeID) const
302 {
303     if (!m_scrollingStateTree-&gt;rootStateNode())
304         return nullptr;
305 
306     if (scrollingNodeID == m_scrollingStateTree-&gt;rootStateNode()-&gt;scrollingNodeID())
307         return m_page-&gt;mainFrame().view();
308 
309     auto* stateNode = m_scrollingStateTree-&gt;stateNodeForID(scrollingNodeID);
310     if (!stateNode)
311         return nullptr;
312 
313     // Find the enclosing frame scrolling node.
314     auto* parentNode = stateNode;
315     while (parentNode &amp;&amp; !parentNode-&gt;isFrameScrollingNode())
316         parentNode = parentNode-&gt;parent();
317 
318     if (!parentNode)
319         return nullptr;
320 
321     // Walk the frame tree to find the matching FrameView. This is not ideal, but avoids back pointers to FrameViews
322     // from ScrollingTreeStateNodes.
323     for (Frame* frame = &amp;m_page-&gt;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
324         if (auto* view = frame-&gt;view()) {
325             if (view-&gt;scrollingNodeID() == parentNode-&gt;scrollingNodeID())
326                 return view;
327         }
328     }
329 
330     return nullptr;
331 }
332 
333 void AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScroll(ScrollingNodeID scrollingNodeID, const FloatPoint&amp; scrollPosition, Optional&lt;FloatPoint&gt; layoutViewportOrigin, ScrollType scrollType, ScrollingLayerPositionAction scrollingLayerPositionAction)
334 {
335     ASSERT(isMainThread());
336 
337     if (!m_page)
338         return;
339 
340     auto* frameViewPtr = frameViewForScrollingNode(scrollingNodeID);
341     if (!frameViewPtr)
342         return;
343 
344     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScroll node &quot; &lt;&lt; scrollingNodeID &lt;&lt; &quot; scrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; action &quot; &lt;&lt; scrollingLayerPositionAction);
345 
346     auto&amp; frameView = *frameViewPtr;
347 
<a name="12" id="anc12"></a><span class="line-added">348     if (!frameViewPtr-&gt;frame().isMainFrame()) {</span>
<span class="line-added">349         if (scrollingLayerPositionAction == ScrollingLayerPositionAction::Set)</span>
<span class="line-added">350             m_page-&gt;editorClient().subFrameScrollPositionChanged();</span>
<span class="line-added">351     }</span>
<span class="line-added">352 </span>
353     if (scrollingNodeID == frameView.scrollingNodeID()) {
354         reconcileScrollingState(frameView, scrollPosition, layoutViewportOrigin, scrollType, ViewportRectStability::Stable, scrollingLayerPositionAction);
<a name="13" id="anc13"></a>








355         return;
356     }
357 
358     // Overflow-scroll area.
359     if (auto* scrollableArea = frameView.scrollableAreaForScrollLayerID(scrollingNodeID)) {
360         auto previousScrollType = scrollableArea-&gt;currentScrollType();
361         scrollableArea-&gt;setCurrentScrollType(scrollType);
<a name="14" id="anc14"></a><span class="line-modified">362         scrollableArea-&gt;notifyScrollPositionChanged(roundedIntPoint(scrollPosition));</span>
363         scrollableArea-&gt;setCurrentScrollType(previousScrollType);
364 
365         if (scrollingLayerPositionAction == ScrollingLayerPositionAction::Set)
366             m_page-&gt;editorClient().overflowScrollPositionChanged();
<a name="15" id="anc15"></a>







367     }
368 }
369 
370 void AsyncScrollingCoordinator::reconcileScrollingState(FrameView&amp; frameView, const FloatPoint&amp; scrollPosition, const LayoutViewportOriginOrOverrideRect&amp; layoutViewportOriginOrOverrideRect, ScrollType scrollType, ViewportRectStability viewportRectStability, ScrollingLayerPositionAction scrollingLayerPositionAction)
371 {
372     auto previousScrollType = frameView.currentScrollType();
373     frameView.setCurrentScrollType(scrollType);
374 
375     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; getCurrentProcessID() &lt;&lt; &quot; AsyncScrollingCoordinator &quot; &lt;&lt; this &lt;&lt; &quot; reconcileScrollingState scrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; type &quot; &lt;&lt; scrollType &lt;&lt; &quot; stability &quot; &lt;&lt; viewportRectStability &lt;&lt; &quot; &quot; &lt;&lt; scrollingLayerPositionAction);
376 
377     Optional&lt;FloatRect&gt; layoutViewportRect;
378 
379     WTF::switchOn(layoutViewportOriginOrOverrideRect,
380         [&amp;frameView](Optional&lt;FloatPoint&gt; origin) {
381             if (origin)
382                 frameView.setBaseLayoutViewportOrigin(LayoutPoint(origin.value()), FrameView::TriggerLayoutOrNot::No);
383         }, [&amp;frameView, &amp;layoutViewportRect, viewportRectStability](Optional&lt;FloatRect&gt; overrideRect) {
384             if (!overrideRect)
385                 return;
386 
387             layoutViewportRect = overrideRect;
388             if (viewportRectStability != ViewportRectStability::ChangingObscuredInsetsInteractively)
389                 frameView.setLayoutViewportOverrideRect(LayoutRect(overrideRect.value()), viewportRectStability == ViewportRectStability::Stable ? FrameView::TriggerLayoutOrNot::Yes : FrameView::TriggerLayoutOrNot::No);
390         }
391     );
392 
393     frameView.setConstrainsScrollingToContentEdge(false);
394     frameView.notifyScrollPositionChanged(roundedIntPoint(scrollPosition));
395     frameView.setConstrainsScrollingToContentEdge(true);
396 
397     frameView.setCurrentScrollType(previousScrollType);
398 
399     if (scrollType == ScrollType::User &amp;&amp; scrollingLayerPositionAction != ScrollingLayerPositionAction::Set) {
400         auto scrollingNodeID = frameView.scrollingNodeID();
401         if (viewportRectStability == ViewportRectStability::Stable)
402             reconcileViewportConstrainedLayerPositions(scrollingNodeID, frameView.rectForFixedPositionLayout(), scrollingLayerPositionAction);
403         else if (layoutViewportRect)
404             reconcileViewportConstrainedLayerPositions(scrollingNodeID, LayoutRect(layoutViewportRect.value()), scrollingLayerPositionAction);
405     }
406 
407     if (!scrolledContentsLayerForFrameView(frameView))
408         return;
409 
410     auto* counterScrollingLayer = counterScrollingLayerForFrameView(frameView);
411     auto* insetClipLayer = insetClipLayerForFrameView(frameView);
412     auto* contentShadowLayer = contentShadowLayerForFrameView(frameView);
413     auto* rootContentsLayer = rootContentsLayerForFrameView(frameView);
414     auto* headerLayer = headerLayerForFrameView(frameView);
415     auto* footerLayer = footerLayerForFrameView(frameView);
416 
417     ASSERT(frameView.scrollPosition() == roundedIntPoint(scrollPosition));
418     LayoutPoint scrollPositionForFixed = frameView.scrollPositionForFixedPosition();
419     float topContentInset = frameView.topContentInset();
420 
421     FloatPoint positionForInsetClipLayer;
422     if (insetClipLayer)
423         positionForInsetClipLayer = FloatPoint(insetClipLayer-&gt;position().x(), FrameView::yPositionForInsetClipLayer(scrollPosition, topContentInset));
424     FloatPoint positionForContentsLayer = frameView.positionForRootContentLayer();
425 
426     FloatPoint positionForHeaderLayer = FloatPoint(scrollPositionForFixed.x(), FrameView::yPositionForHeaderLayer(scrollPosition, topContentInset));
427     FloatPoint positionForFooterLayer = FloatPoint(scrollPositionForFixed.x(),
428         FrameView::yPositionForFooterLayer(scrollPosition, topContentInset, frameView.totalContentsSize().height(), frameView.footerHeight()));
429 
430     if (scrollType == ScrollType::Programmatic || scrollingLayerPositionAction == ScrollingLayerPositionAction::Set) {
431         reconcileScrollPosition(frameView, ScrollingLayerPositionAction::Set);
432 
433         if (counterScrollingLayer)
434             counterScrollingLayer-&gt;setPosition(scrollPositionForFixed);
435         if (insetClipLayer)
436             insetClipLayer-&gt;setPosition(positionForInsetClipLayer);
437         if (contentShadowLayer)
438             contentShadowLayer-&gt;setPosition(positionForContentsLayer);
439         if (rootContentsLayer)
440             rootContentsLayer-&gt;setPosition(positionForContentsLayer);
441         if (headerLayer)
442             headerLayer-&gt;setPosition(positionForHeaderLayer);
443         if (footerLayer)
444             footerLayer-&gt;setPosition(positionForFooterLayer);
445     } else {
446         reconcileScrollPosition(frameView, ScrollingLayerPositionAction::Sync);
447 
448         if (counterScrollingLayer)
449             counterScrollingLayer-&gt;syncPosition(scrollPositionForFixed);
450         if (insetClipLayer)
451             insetClipLayer-&gt;syncPosition(positionForInsetClipLayer);
452         if (contentShadowLayer)
453             contentShadowLayer-&gt;syncPosition(positionForContentsLayer);
454         if (rootContentsLayer)
455             rootContentsLayer-&gt;syncPosition(positionForContentsLayer);
456         if (headerLayer)
457             headerLayer-&gt;syncPosition(positionForHeaderLayer);
458         if (footerLayer)
459             footerLayer-&gt;syncPosition(positionForFooterLayer);
460     }
461 }
462 
463 void AsyncScrollingCoordinator::reconcileScrollPosition(FrameView&amp; frameView, ScrollingLayerPositionAction scrollingLayerPositionAction)
464 {
465 #if PLATFORM(IOS_FAMILY)
466     // Doing all scrolling like this (UIScrollView style) would simplify code.
467     auto* scrollContainerLayer = scrollContainerLayerForFrameView(frameView);
468     if (!scrollContainerLayer)
469         return;
470     if (scrollingLayerPositionAction == ScrollingLayerPositionAction::Set)
471         scrollContainerLayer-&gt;setBoundsOrigin(frameView.scrollPosition());
472     else
473         scrollContainerLayer-&gt;syncBoundsOrigin(frameView.scrollPosition());
474 #else
475     // This uses scrollPosition because the root content layer accounts for scrollOrigin (see FrameView::positionForRootContentLayer()).
476     auto* scrolledContentsLayer = scrolledContentsLayerForFrameView(frameView);
477     if (!scrolledContentsLayer)
478         return;
479     if (scrollingLayerPositionAction == ScrollingLayerPositionAction::Set)
480         scrolledContentsLayer-&gt;setPosition(-frameView.scrollPosition());
481     else
482         scrolledContentsLayer-&gt;syncPosition(-frameView.scrollPosition());
483 #endif
484 }
485 
486 void AsyncScrollingCoordinator::scrollableAreaScrollbarLayerDidChange(ScrollableArea&amp; scrollableArea, ScrollbarOrientation orientation)
487 {
488     ASSERT(isMainThread());
489     ASSERT(m_page);
490 
491     auto* node = m_scrollingStateTree-&gt;stateNodeForID(scrollableArea.scrollingNodeID());
492     if (is&lt;ScrollingStateScrollingNode&gt;(node)) {
493         auto&amp; scrollingNode = downcast&lt;ScrollingStateScrollingNode&gt;(*node);
494         if (orientation == VerticalScrollbar)
495             scrollingNode.setVerticalScrollbarLayer(scrollableArea.layerForVerticalScrollbar());
496         else
497             scrollingNode.setHorizontalScrollbarLayer(scrollableArea.layerForHorizontalScrollbar());
498     }
499 
500     if (orientation == VerticalScrollbar)
501         scrollableArea.verticalScrollbarLayerDidChange();
502     else
503         scrollableArea.horizontalScrollbarLayerDidChange();
504 }
505 
506 ScrollingNodeID AsyncScrollingCoordinator::createNode(ScrollingNodeType nodeType, ScrollingNodeID newNodeID)
507 {
508     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;AsyncScrollingCoordinator::createNode &quot; &lt;&lt; nodeType &lt;&lt; &quot; node &quot; &lt;&lt; newNodeID);
509     return m_scrollingStateTree-&gt;createUnparentedNode(nodeType, newNodeID);
510 }
511 
512 ScrollingNodeID AsyncScrollingCoordinator::insertNode(ScrollingNodeType nodeType, ScrollingNodeID newNodeID, ScrollingNodeID parentID, size_t childIndex)
513 {
514     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;AsyncScrollingCoordinator::insertNode &quot; &lt;&lt; nodeType &lt;&lt; &quot; node &quot; &lt;&lt; newNodeID &lt;&lt; &quot; parent &quot; &lt;&lt; parentID &lt;&lt; &quot; index &quot; &lt;&lt; childIndex);
515     return m_scrollingStateTree-&gt;insertNode(nodeType, newNodeID, parentID, childIndex);
516 }
517 
518 void AsyncScrollingCoordinator::unparentNode(ScrollingNodeID nodeID)
519 {
520     m_scrollingStateTree-&gt;unparentNode(nodeID);
521 }
522 
523 void AsyncScrollingCoordinator::unparentChildrenAndDestroyNode(ScrollingNodeID nodeID)
524 {
525     m_scrollingStateTree-&gt;unparentChildrenAndDestroyNode(nodeID);
526 }
527 
528 void AsyncScrollingCoordinator::detachAndDestroySubtree(ScrollingNodeID nodeID)
529 {
530     m_scrollingStateTree-&gt;detachAndDestroySubtree(nodeID);
531 }
532 
533 void AsyncScrollingCoordinator::clearAllNodes()
534 {
535     m_scrollingStateTree-&gt;clear();
536 }
537 
538 ScrollingNodeID AsyncScrollingCoordinator::parentOfNode(ScrollingNodeID nodeID) const
539 {
540     auto* scrollingNode = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
541     if (!scrollingNode)
542         return 0;
543 
544     return scrollingNode-&gt;parentNodeID();
545 }
546 
547 Vector&lt;ScrollingNodeID&gt; AsyncScrollingCoordinator::childrenOfNode(ScrollingNodeID nodeID) const
548 {
549     auto* scrollingNode = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
550     if (!scrollingNode)
551         return { };
552 
553     auto* children = scrollingNode-&gt;children();
554     if (!children || children-&gt;isEmpty())
555         return { };
556 
557     Vector&lt;ScrollingNodeID&gt; childNodeIDs;
558     childNodeIDs.reserveInitialCapacity(children-&gt;size());
559     for (const auto&amp; childNode : *children)
560         childNodeIDs.uncheckedAppend(childNode-&gt;scrollingNodeID());
561 
562     return childNodeIDs;
563 }
564 
565 void AsyncScrollingCoordinator::reconcileViewportConstrainedLayerPositions(ScrollingNodeID scrollingNodeID, const LayoutRect&amp; viewportRect, ScrollingLayerPositionAction action)
566 {
567     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; getCurrentProcessID() &lt;&lt; &quot; AsyncScrollingCoordinator::reconcileViewportConstrainedLayerPositions for viewport rect &quot; &lt;&lt; viewportRect &lt;&lt; &quot; and node &quot; &lt;&lt; scrollingNodeID);
568 
569     m_scrollingStateTree-&gt;reconcileViewportConstrainedLayerPositions(scrollingNodeID, viewportRect, action);
570 }
571 
572 void AsyncScrollingCoordinator::ensureRootStateNodeForFrameView(FrameView&amp; frameView)
573 {
574     ASSERT(frameView.scrollingNodeID());
575     if (m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()))
576         return;
577 
578     // For non-main frames, it is only possible to arrive in this function from
579     // RenderLayerCompositor::updateBacking where the node has already been created.
580     ASSERT(frameView.frame().isMainFrame());
581     insertNode(ScrollingNodeType::MainFrame, frameView.scrollingNodeID(), 0, 0);
582 }
583 
584 void AsyncScrollingCoordinator::setNodeLayers(ScrollingNodeID nodeID, const NodeLayers&amp; nodeLayers)
585 {
586     auto* node = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
587     ASSERT(node);
588     if (!node)
589         return;
590 
591     node-&gt;setLayer(nodeLayers.layer);
592 
593     if (is&lt;ScrollingStateScrollingNode&gt;(node)) {
594         auto&amp; scrollingNode = downcast&lt;ScrollingStateScrollingNode&gt;(*node);
595         scrollingNode.setScrollContainerLayer(nodeLayers.scrollContainerLayer);
596         scrollingNode.setScrolledContentsLayer(nodeLayers.scrolledContentsLayer);
597         scrollingNode.setHorizontalScrollbarLayer(nodeLayers.horizontalScrollbarLayer);
598         scrollingNode.setVerticalScrollbarLayer(nodeLayers.verticalScrollbarLayer);
599 
600         if (is&lt;ScrollingStateFrameScrollingNode&gt;(node)) {
601             auto&amp; frameScrollingNode = downcast&lt;ScrollingStateFrameScrollingNode&gt;(*node);
602             frameScrollingNode.setInsetClipLayer(nodeLayers.insetClipLayer);
603             frameScrollingNode.setCounterScrollingLayer(nodeLayers.counterScrollingLayer);
604             frameScrollingNode.setRootContentsLayer(nodeLayers.rootContentsLayer);
605         }
606     }
607 }
608 
609 void AsyncScrollingCoordinator::setRectRelativeToParentNode(ScrollingNodeID nodeID, const LayoutRect&amp; parentRelativeScrollableRect)
610 {
611     auto* stateNode = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
612     ASSERT(stateNode);
613     if (!stateNode)
614         return;
615 
616     if (is&lt;ScrollingStateFrameHostingNode&gt;(*stateNode)) {
617         auto&amp; frameHostingStateNode = downcast&lt;ScrollingStateFrameHostingNode&gt;(*stateNode);
618         frameHostingStateNode.setParentRelativeScrollableRect(parentRelativeScrollableRect);
619         return;
620     }
621 
622     if (is&lt;ScrollingStateScrollingNode&gt;(stateNode)) {
623         auto&amp; scrollingStateNode = downcast&lt;ScrollingStateScrollingNode&gt;(*stateNode);
624         scrollingStateNode.setParentRelativeScrollableRect(parentRelativeScrollableRect);
625     }
626 }
627 
628 void AsyncScrollingCoordinator::setFrameScrollingNodeState(ScrollingNodeID nodeID, const FrameView&amp; frameView)
629 {
630     auto* stateNode = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
631     ASSERT(stateNode);
632     if (!is&lt;ScrollingStateFrameScrollingNode&gt;(stateNode))
633         return;
634 
635     auto&amp; frameScrollingNode = downcast&lt;ScrollingStateFrameScrollingNode&gt;(*stateNode);
636 
637     frameScrollingNode.setFrameScaleFactor(frameView.frame().frameScaleFactor());
638     frameScrollingNode.setHeaderHeight(frameView.headerHeight());
639     frameScrollingNode.setFooterHeight(frameView.footerHeight());
640     frameScrollingNode.setTopContentInset(frameView.topContentInset());
641     frameScrollingNode.setLayoutViewport(frameView.layoutViewportRect());
642     frameScrollingNode.setAsyncFrameOrOverflowScrollingEnabled(asyncFrameOrOverflowScrollingEnabled());
643 
644     frameScrollingNode.setMinLayoutViewportOrigin(frameView.minStableLayoutViewportOrigin());
645     frameScrollingNode.setMaxLayoutViewportOrigin(frameView.maxStableLayoutViewportOrigin());
646 
647     if (auto visualOverrideRect = frameView.visualViewportOverrideRect())
648         frameScrollingNode.setOverrideVisualViewportSize(FloatSize(visualOverrideRect.value().size()));
649     else
650         frameScrollingNode.setOverrideVisualViewportSize(WTF::nullopt);
651 
652     frameScrollingNode.setFixedElementsLayoutRelativeToFrame(frameView.fixedElementsLayoutRelativeToFrame());
653 
654     auto visualViewportIsSmallerThanLayoutViewport = [](const FrameView&amp; frameView) {
655         auto layoutViewport = frameView.layoutViewportRect();
656         auto visualViewport = frameView.visualViewportRect();
657         return visualViewport.width() &lt; layoutViewport.width() || visualViewport.height() &lt; layoutViewport.height();
658     };
659     frameScrollingNode.setVisualViewportIsSmallerThanLayoutViewport(visualViewportIsSmallerThanLayoutViewport(frameView));
660 
661     frameScrollingNode.setScrollBehaviorForFixedElements(frameView.scrollBehaviorForFixedElements());
662 }
663 
664 void AsyncScrollingCoordinator::setScrollingNodeScrollableAreaGeometry(ScrollingNodeID nodeID, ScrollableArea&amp; scrollableArea)
665 {
666     auto* stateNode = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
667     ASSERT(stateNode);
668     if (!stateNode)
669         return;
670 
671     auto&amp; scrollingNode = downcast&lt;ScrollingStateScrollingNode&gt;(*stateNode);
672 
673     auto* verticalScrollbar = scrollableArea.verticalScrollbar();
674     auto* horizontalScrollbar = scrollableArea.horizontalScrollbar();
675     scrollingNode.setScrollerImpsFromScrollbars(verticalScrollbar, horizontalScrollbar);
676 
677     scrollingNode.setScrollOrigin(scrollableArea.scrollOrigin());
678     scrollingNode.setScrollPosition(scrollableArea.scrollPosition());
679     scrollingNode.setTotalContentsSize(scrollableArea.totalContentsSize());
680     scrollingNode.setReachableContentsSize(scrollableArea.reachableTotalContentsSize());
681     scrollingNode.setScrollableAreaSize(scrollableArea.visibleSize());
682 
683     ScrollableAreaParameters scrollParameters;
684     scrollParameters.horizontalScrollElasticity = scrollableArea.horizontalScrollElasticity();
685     scrollParameters.verticalScrollElasticity = scrollableArea.verticalScrollElasticity();
686     scrollParameters.hasEnabledHorizontalScrollbar = horizontalScrollbar &amp;&amp; horizontalScrollbar-&gt;enabled();
687     scrollParameters.hasEnabledVerticalScrollbar = verticalScrollbar &amp;&amp; verticalScrollbar-&gt;enabled();
688     scrollParameters.horizontalScrollbarMode = scrollableArea.horizontalScrollbarMode();
689     scrollParameters.verticalScrollbarMode = scrollableArea.verticalScrollbarMode();
690     scrollParameters.horizontalScrollbarHiddenByStyle = scrollableArea.horizontalScrollbarHiddenByStyle();
691     scrollParameters.verticalScrollbarHiddenByStyle = scrollableArea.verticalScrollbarHiddenByStyle();
692     scrollParameters.useDarkAppearanceForScrollbars = scrollableArea.useDarkAppearanceForScrollbars();
693 
694     scrollingNode.setScrollableAreaParameters(scrollParameters);
695 
696 #if ENABLE(CSS_SCROLL_SNAP)
697     scrollableArea.updateSnapOffsets();
698     setStateScrollingNodeSnapOffsetsAsFloat(scrollingNode, ScrollEventAxis::Horizontal, scrollableArea.horizontalSnapOffsets(), scrollableArea.horizontalSnapOffsetRanges(), m_page-&gt;deviceScaleFactor());
699     setStateScrollingNodeSnapOffsetsAsFloat(scrollingNode, ScrollEventAxis::Vertical, scrollableArea.verticalSnapOffsets(), scrollableArea.verticalSnapOffsetRanges(), m_page-&gt;deviceScaleFactor());
700     scrollingNode.setCurrentHorizontalSnapPointIndex(scrollableArea.currentHorizontalSnapPointIndex());
701     scrollingNode.setCurrentVerticalSnapPointIndex(scrollableArea.currentVerticalSnapPointIndex());
702 #endif
703 }
704 
705 void AsyncScrollingCoordinator::setViewportConstraintedNodeConstraints(ScrollingNodeID nodeID, const ViewportConstraints&amp; constraints)
706 {
707     auto* node = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
708     if (!node)
709         return;
710 
711     switch (constraints.constraintType()) {
712     case ViewportConstraints::FixedPositionConstraint: {
713         auto&amp; fixedNode = downcast&lt;ScrollingStateFixedNode&gt;(*node);
714         fixedNode.updateConstraints((const FixedPositionViewportConstraints&amp;)constraints);
715         break;
716     }
717     case ViewportConstraints::StickyPositionConstraint: {
718         auto&amp; stickyNode = downcast&lt;ScrollingStateStickyNode&gt;(*node);
719         stickyNode.updateConstraints((const StickyPositionViewportConstraints&amp;)constraints);
720         break;
721     }
722     }
723 }
724 
725 void AsyncScrollingCoordinator::setPositionedNodeConstraints(ScrollingNodeID nodeID, const AbsolutePositionConstraints&amp; constraints)
726 {
727     auto* node = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
728     if (!node)
729         return;
730 
731     ASSERT(is&lt;ScrollingStatePositionedNode&gt;(*node));
732     if (auto* positionedNode = downcast&lt;ScrollingStatePositionedNode&gt;(node))
733         positionedNode-&gt;updateConstraints(constraints);
734 }
735 
736 void AsyncScrollingCoordinator::setRelatedOverflowScrollingNodes(ScrollingNodeID nodeID, Vector&lt;ScrollingNodeID&gt;&amp;&amp; relatedNodes)
737 {
738     auto* node = m_scrollingStateTree-&gt;stateNodeForID(nodeID);
739     if (!node)
740         return;
741 
742     if (is&lt;ScrollingStatePositionedNode&gt;(node))
743         downcast&lt;ScrollingStatePositionedNode&gt;(node)-&gt;setRelatedOverflowScrollingNodes(WTFMove(relatedNodes));
744     else if (is&lt;ScrollingStateOverflowScrollProxyNode&gt;(node)) {
745         auto* overflowScrollProxyNode = downcast&lt;ScrollingStateOverflowScrollProxyNode&gt;(node);
746         if (!relatedNodes.isEmpty())
747             overflowScrollProxyNode-&gt;setOverflowScrollingNode(relatedNodes[0]);
748         else
749             overflowScrollProxyNode-&gt;setOverflowScrollingNode(0);
750     } else
751         ASSERT_NOT_REACHED();
752 }
753 
754 void AsyncScrollingCoordinator::setSynchronousScrollingReasons(FrameView&amp; frameView, SynchronousScrollingReasons reasons)
755 {
756     auto* scrollingStateNode = static_cast&lt;ScrollingStateFrameScrollingNode*&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
757     if (!scrollingStateNode)
758         return;
759 
760     // The FrameView&#39;s GraphicsLayer is likely to be out-of-synch with the PlatformLayer
761     // at this point. So we&#39;ll update it before we switch back to main thread scrolling
762     // in order to avoid layer positioning bugs.
763     if (reasons)
764         reconcileScrollPosition(frameView, ScrollingLayerPositionAction::Set);
765     scrollingStateNode-&gt;setSynchronousScrollingReasons(reasons);
766 }
767 
768 bool AsyncScrollingCoordinator::isRubberBandInProgress() const
769 {
770     return scrollingTree()-&gt;isRubberBandInProgress();
771 }
772 
773 void AsyncScrollingCoordinator::setScrollPinningBehavior(ScrollPinningBehavior pinning)
774 {
775     scrollingTree()-&gt;setScrollPinningBehavior(pinning);
776 }
777 
778 bool AsyncScrollingCoordinator::asyncFrameOrOverflowScrollingEnabled() const
779 {
780     auto&amp; settings = m_page-&gt;mainFrame().settings();
781     return settings.asyncFrameScrollingEnabled() || settings.asyncOverflowScrollingEnabled();
782 }
783 
784 ScrollingNodeID AsyncScrollingCoordinator::scrollableContainerNodeID(const RenderObject&amp; renderer) const
785 {
786     if (auto overflowScrollingNodeID = renderer.view().compositor().asyncScrollableContainerNodeID(renderer))
787         return overflowScrollingNodeID;
788 
789     // If we&#39;re in a scrollable frame, return that.
790     auto* frameView = renderer.frame().view();
791     if (!frameView)
792         return 0;
793 
794     if (auto scrollingNodeID = frameView-&gt;scrollingNodeID())
795         return scrollingNodeID;
796 
797     // Otherwise, look for a scrollable element in the containing frame.
798     if (auto* ownerElement = renderer.document().ownerElement()) {
799         if (auto* frameRenderer = ownerElement-&gt;renderer())
800             return scrollableContainerNodeID(*frameRenderer);
801     }
802 
803     return 0;
804 }
805 
806 String AsyncScrollingCoordinator::scrollingStateTreeAsText(ScrollingStateTreeAsTextBehavior behavior) const
807 {
808     if (m_scrollingStateTree-&gt;rootStateNode()) {
809         if (m_eventTrackingRegionsDirty)
810             m_scrollingStateTree-&gt;rootStateNode()-&gt;setEventTrackingRegions(absoluteEventTrackingRegions());
811         return m_scrollingStateTree-&gt;rootStateNode()-&gt;scrollingStateTreeAsText(behavior);
812     }
813 
814     return String();
815 }
816 
817 #if PLATFORM(COCOA)
818 void AsyncScrollingCoordinator::setActiveScrollSnapIndices(ScrollingNodeID scrollingNodeID, unsigned horizontalIndex, unsigned verticalIndex)
819 {
820     ASSERT(isMainThread());
821 
822     if (!m_page)
823         return;
824 
825     auto* frameView = frameViewForScrollingNode(scrollingNodeID);
826     if (!frameView)
827         return;
828 
829     if (scrollingNodeID == frameView-&gt;scrollingNodeID()) {
830         frameView-&gt;setCurrentHorizontalSnapPointIndex(horizontalIndex);
831         frameView-&gt;setCurrentVerticalSnapPointIndex(verticalIndex);
832         return;
833     }
834 
835     // Overflow-scroll area.
836     if (auto* scrollableArea = frameView-&gt;scrollableAreaForScrollLayerID(scrollingNodeID)) {
837         scrollableArea-&gt;setCurrentHorizontalSnapPointIndex(horizontalIndex);
838         scrollableArea-&gt;setCurrentVerticalSnapPointIndex(verticalIndex);
839     }
840 }
841 
<a name="16" id="anc16"></a><span class="line-modified">842 void AsyncScrollingCoordinator::deferWheelEventTestCompletionForReason(WheelEventTestMonitor::ScrollableAreaIdentifier identifier, WheelEventTestMonitor::DeferReason reason) const</span>
843 {
844     ASSERT(isMainThread());
<a name="17" id="anc17"></a><span class="line-modified">845     if (!m_page || !m_page-&gt;isMonitoringWheelEvents())</span>
846         return;
847 
<a name="18" id="anc18"></a><span class="line-modified">848     if (const auto&amp; trigger = m_page-&gt;wheelEventTestMonitor()) {</span>
<span class="line-modified">849         LOG_WITH_STREAM(WheelEventTestMonitor, stream &lt;&lt; &quot;    (!) AsyncScrollingCoordinator::deferForReason: Deferring &quot; &lt;&lt; identifier &lt;&lt; &quot; for reason &quot; &lt;&lt; reason);</span>
<span class="line-modified">850         trigger-&gt;deferForReason(identifier, reason);</span>
851     }
852 }
853 
<a name="19" id="anc19"></a><span class="line-modified">854 void AsyncScrollingCoordinator::removeWheelEventTestCompletionDeferralForReason(WheelEventTestMonitor::ScrollableAreaIdentifier identifier, WheelEventTestMonitor::DeferReason reason) const</span>
855 {
856     ASSERT(isMainThread());
<a name="20" id="anc20"></a><span class="line-modified">857     if (!m_page || !m_page-&gt;isMonitoringWheelEvents())</span>
858         return;
859 
<a name="21" id="anc21"></a><span class="line-modified">860     if (const auto&amp; trigger = m_page-&gt;wheelEventTestMonitor()) {</span>
<span class="line-modified">861         LOG_WITH_STREAM(WheelEventTestMonitor, stream &lt;&lt; &quot;    (!) AsyncScrollingCoordinator::removeWheelEventTestCompletionDeferralForReason: Deferring &quot; &lt;&lt; identifier &lt;&lt; &quot; for reason &quot; &lt;&lt; reason);</span>
<span class="line-modified">862         trigger-&gt;removeDeferralForReason(identifier, reason);</span>
863     }
864 }
865 #endif
866 
867 #if ENABLE(CSS_SCROLL_SNAP)
868 bool AsyncScrollingCoordinator::isScrollSnapInProgress() const
869 {
870     return scrollingTree()-&gt;isScrollSnapInProgress();
871 }
872 
873 void AsyncScrollingCoordinator::updateScrollSnapPropertiesWithFrameView(const FrameView&amp; frameView)
874 {
875     if (auto node = downcast&lt;ScrollingStateFrameScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()))) {
876         setStateScrollingNodeSnapOffsetsAsFloat(*node, ScrollEventAxis::Horizontal, frameView.horizontalSnapOffsets(), frameView.horizontalSnapOffsetRanges(), m_page-&gt;deviceScaleFactor());
877         setStateScrollingNodeSnapOffsetsAsFloat(*node, ScrollEventAxis::Vertical, frameView.verticalSnapOffsets(), frameView.verticalSnapOffsetRanges(), m_page-&gt;deviceScaleFactor());
878         node-&gt;setCurrentHorizontalSnapPointIndex(frameView.currentHorizontalSnapPointIndex());
879         node-&gt;setCurrentVerticalSnapPointIndex(frameView.currentVerticalSnapPointIndex());
880     }
881 }
882 #endif
883 
884 void AsyncScrollingCoordinator::reportExposedUnfilledArea(MonotonicTime timestamp, unsigned unfilledArea)
885 {
886     if (m_page &amp;&amp; m_page-&gt;performanceLoggingClient())
887         m_page-&gt;performanceLoggingClient()-&gt;logScrollingEvent(PerformanceLoggingClient::ScrollingEvent::ExposedTilelessArea, timestamp, unfilledArea);
888 }
889 
890 void AsyncScrollingCoordinator::reportSynchronousScrollingReasonsChanged(MonotonicTime timestamp, SynchronousScrollingReasons reasons)
891 {
892     if (m_page &amp;&amp; m_page-&gt;performanceLoggingClient())
893         m_page-&gt;performanceLoggingClient()-&gt;logScrollingEvent(PerformanceLoggingClient::ScrollingEvent::SwitchedScrollingMode, timestamp, reasons);
894 }
895 
896 } // namespace WebCore
897 
898 #endif // ENABLE(ASYNC_SCROLLING)
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
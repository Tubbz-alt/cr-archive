<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoTLSInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IsoTLSEntryInlines.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IsoTLSLayout.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoTLSInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,10 ***</span>
<span class="line-new-header">--- 28,14 ---</span>
  #include &quot;Environment.h&quot;
  #include &quot;IsoHeapImpl.h&quot;
  #include &quot;IsoTLS.h&quot;
  #include &quot;bmalloc.h&quot;
  
<span class="line-added">+ #if BOS(DARWIN)</span>
<span class="line-added">+ #include &lt;malloc/malloc.h&gt;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  namespace bmalloc {
  
  template&lt;typename Type&gt;
  void* IsoTLS::allocate(api::IsoHeap&lt;Type&gt;&amp; handle, bool abortOnFailure)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 54,11 ***</span>
          return;
      if (!handle.isInitialized())
          return;
      unsigned offset = handle.allocatorOffset();
      if (offset &lt; tls-&gt;m_extent)
<span class="line-modified">!         reinterpret_cast&lt;IsoAllocator&lt;typename api::IsoHeap&lt;Type&gt;::Config&gt;*&gt;(tls-&gt;m_data + offset)-&gt;scavenge();</span>
      offset = handle.deallocatorOffset();
      if (offset &lt; tls-&gt;m_extent)
          reinterpret_cast&lt;IsoDeallocator&lt;typename api::IsoHeap&lt;Type&gt;::Config&gt;*&gt;(tls-&gt;m_data + offset)-&gt;scavenge();
      handle.impl().scavengeNow();
  }
<span class="line-new-header">--- 58,11 ---</span>
          return;
      if (!handle.isInitialized())
          return;
      unsigned offset = handle.allocatorOffset();
      if (offset &lt; tls-&gt;m_extent)
<span class="line-modified">!         reinterpret_cast&lt;IsoAllocator&lt;typename api::IsoHeap&lt;Type&gt;::Config&gt;*&gt;(tls-&gt;m_data + offset)-&gt;scavenge(handle.impl());</span>
      offset = handle.deallocatorOffset();
      if (offset &lt; tls-&gt;m_extent)
          reinterpret_cast&lt;IsoDeallocator&lt;typename api::IsoHeap&lt;Type&gt;::Config&gt;*&gt;(tls-&gt;m_data + offset)-&gt;scavenge();
      handle.impl().scavengeNow();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 68,17 ***</span>
  {
      unsigned offset = handle.allocatorOffset();
      IsoTLS* tls = get();
      if (!tls || offset &gt;= tls-&gt;m_extent)
          return allocateSlow&lt;Config&gt;(handle, abortOnFailure);
<span class="line-modified">!     return tls-&gt;allocateFast&lt;Config&gt;(offset, abortOnFailure);</span>
  }
  
<span class="line-modified">! template&lt;typename Config&gt;</span>
<span class="line-modified">! void* IsoTLS::allocateFast(unsigned offset, bool abortOnFailure)</span>
  {
<span class="line-modified">!     return reinterpret_cast&lt;IsoAllocator&lt;Config&gt;*&gt;(m_data + offset)-&gt;allocate(abortOnFailure);</span>
  }
  
  template&lt;typename Config, typename Type&gt;
  BNO_INLINE void* IsoTLS::allocateSlow(api::IsoHeap&lt;Type&gt;&amp; handle, bool abortOnFailure)
  {
<span class="line-new-header">--- 72,17 ---</span>
  {
      unsigned offset = handle.allocatorOffset();
      IsoTLS* tls = get();
      if (!tls || offset &gt;= tls-&gt;m_extent)
          return allocateSlow&lt;Config&gt;(handle, abortOnFailure);
<span class="line-modified">!     return tls-&gt;allocateFast&lt;Config&gt;(handle, offset, abortOnFailure);</span>
  }
  
<span class="line-modified">! template&lt;typename Config, typename Type&gt;</span>
<span class="line-modified">! void* IsoTLS::allocateFast(api::IsoHeap&lt;Type&gt;&amp; handle, unsigned offset, bool abortOnFailure)</span>
  {
<span class="line-modified">!     return reinterpret_cast&lt;IsoAllocator&lt;Config&gt;*&gt;(m_data + offset)-&gt;allocate(handle.impl(), abortOnFailure);</span>
  }
  
  template&lt;typename Config, typename Type&gt;
  BNO_INLINE void* IsoTLS::allocateSlow(api::IsoHeap&lt;Type&gt;&amp; handle, bool abortOnFailure)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 86,11 ***</span>
<span class="line-new-header">--- 90,15 ---</span>
          switch (s_mallocFallbackState) {
          case MallocFallbackState::Undecided:
              determineMallocFallbackState();
              continue;
          case MallocFallbackState::FallBackToMalloc:
<span class="line-added">+ #if BENABLE_MALLOC_HEAP_BREAKDOWN</span>
<span class="line-added">+             return malloc_zone_malloc(handle.m_zone, Config::objectSize);</span>
<span class="line-added">+ #else</span>
              return api::tryMalloc(Config::objectSize);
<span class="line-added">+ #endif</span>
          case MallocFallbackState::DoNotFallBack:
              break;
          }
          break;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 98,11 ***</span>
      // If debug heap is enabled, s_mallocFallbackState becomes MallocFallbackState::FallBackToMalloc.
      BASSERT(!Environment::get()-&gt;isDebugHeapEnabled());
  
      IsoTLS* tls = ensureHeapAndEntries(handle);
  
<span class="line-modified">!     return tls-&gt;allocateFast&lt;Config&gt;(handle.allocatorOffset(), abortOnFailure);</span>
  }
  
  template&lt;typename Config, typename Type&gt;
  void IsoTLS::deallocateImpl(api::IsoHeap&lt;Type&gt;&amp; handle, void* p)
  {
<span class="line-new-header">--- 106,11 ---</span>
      // If debug heap is enabled, s_mallocFallbackState becomes MallocFallbackState::FallBackToMalloc.
      BASSERT(!Environment::get()-&gt;isDebugHeapEnabled());
  
      IsoTLS* tls = ensureHeapAndEntries(handle);
  
<span class="line-modified">!     return tls-&gt;allocateFast&lt;Config&gt;(handle, handle.allocatorOffset(), abortOnFailure);</span>
  }
  
  template&lt;typename Config, typename Type&gt;
  void IsoTLS::deallocateImpl(api::IsoHeap&lt;Type&gt;&amp; handle, void* p)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 129,11 ***</span>
<span class="line-new-header">--- 137,15 ---</span>
          switch (s_mallocFallbackState) {
          case MallocFallbackState::Undecided:
              determineMallocFallbackState();
              continue;
          case MallocFallbackState::FallBackToMalloc:
<span class="line-added">+ #if BENABLE_MALLOC_HEAP_BREAKDOWN</span>
<span class="line-added">+             return malloc_zone_free(handle.m_zone, p);</span>
<span class="line-added">+ #else</span>
              return api::free(p);
<span class="line-added">+ #endif</span>
          case MallocFallbackState::DoNotFallBack:
              break;
          }
          break;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 170,11 ***</span>
  
  template&lt;typename Type&gt;
  void IsoTLS::ensureHeap(api::IsoHeap&lt;Type&gt;&amp; handle)
  {
      if (!handle.isInitialized()) {
<span class="line-modified">!         std::lock_guard&lt;Mutex&gt; locker(handle.m_initializationLock);</span>
          if (!handle.isInitialized())
              handle.initialize();
      }
  }
  
<span class="line-new-header">--- 182,11 ---</span>
  
  template&lt;typename Type&gt;
  void IsoTLS::ensureHeap(api::IsoHeap&lt;Type&gt;&amp; handle)
  {
      if (!handle.isInitialized()) {
<span class="line-modified">!         LockHolder locker(handle.m_initializationLock);</span>
          if (!handle.isInitialized())
              handle.initialize();
      }
  }
  
</pre>
<center><a href="IsoTLSEntryInlines.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IsoTLSLayout.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
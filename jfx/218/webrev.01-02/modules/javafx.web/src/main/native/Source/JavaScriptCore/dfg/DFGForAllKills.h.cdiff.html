<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGForAllKills.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGFixupPhase.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGGraph.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGForAllKills.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2015 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 30,10 ***</span>
<span class="line-new-header">--- 30,14 ---</span>
  #include &quot;DFGOSRAvailabilityAnalysisPhase.h&quot;
  #include &quot;FullBytecodeLiveness.h&quot;
  
  namespace JSC { namespace DFG {
  
<span class="line-added">+ namespace ForAllKillsInternal {</span>
<span class="line-added">+ constexpr bool verbose = false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Utilities for finding the last points where a node is live in DFG SSA. This accounts for liveness due
  // to OSR exit. This is usually used for enumerating over all of the program points where a node is live,
  // by exploring all blocks where the node is live at tail and then exploring all program points where the
  // node is killed. A prerequisite to using these utilities is having liveness and OSR availability
  // computed.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 51,63 ***</span>
          return;
      }
  
      CodeOrigin after = nodeAfter-&gt;origin.forExit;
  
<span class="line-modified">!     VirtualRegister alreadyNoted;</span>
      // If we MovHint something that is live at the time, then we kill the old value.
      if (nodeAfter-&gt;containsMovHint()) {
<span class="line-modified">!         VirtualRegister reg = nodeAfter-&gt;unlinkedLocal();</span>
<span class="line-modified">!         if (graph.isLiveInBytecode(reg, after)) {</span>
<span class="line-modified">!             functor(reg);</span>
<span class="line-modified">!             alreadyNoted = reg;</span>
          }
      }
  
      if (before == after)
          return;
  
      // It&#39;s easier to do this if the inline call frames are the same. This is way faster than the
      // other loop, below.
      auto* beforeInlineCallFrame = before.inlineCallFrame();
      if (beforeInlineCallFrame == after.inlineCallFrame()) {
<span class="line-removed">-         int stackOffset = beforeInlineCallFrame ? beforeInlineCallFrame-&gt;stackOffset : 0;</span>
          CodeBlock* codeBlock = graph.baselineCodeBlockFor(beforeInlineCallFrame);
          FullBytecodeLiveness&amp; fullLiveness = graph.livenessFor(codeBlock);
<span class="line-modified">!         const FastBitVector&amp; liveBefore = fullLiveness.getLiveness(before.bytecodeIndex());</span>
<span class="line-modified">!         const FastBitVector&amp; liveAfter = fullLiveness.getLiveness(after.bytecodeIndex());</span>
  
          (liveBefore &amp; ~liveAfter).forEachSetBit(
              [&amp;] (size_t relativeLocal) {
<span class="line-modified">!                 functor(virtualRegisterForLocal(relativeLocal) + stackOffset);</span>
              });
          return;
      }
  
      // Detect kills the super conservative way: it is killed if it was live before and dead after.
<span class="line-modified">!     BitVector liveAfter = graph.localsLiveInBytecode(after);</span>
<span class="line-modified">!     graph.forAllLocalsLiveInBytecode(</span>
          before,
<span class="line-modified">!         [&amp;] (VirtualRegister reg) {</span>
<span class="line-modified">!             if (reg == alreadyNoted)</span>
                  return;
<span class="line-modified">!             if (liveAfter.get(reg.toLocal()))</span>
                  return;
<span class="line-modified">!             functor(reg);</span>
          });
  }
  
  // Tells you all of the nodes that would no longer be live across the node at this nodeIndex.
  template&lt;typename Functor&gt;
  void forAllKilledNodesAtNodeIndex(
      Graph&amp; graph, AvailabilityMap&amp; availabilityMap, BasicBlock* block, unsigned nodeIndex,
      const Functor&amp; functor)
  {
<span class="line-modified">!     static const unsigned seenInClosureFlag = 1;</span>
<span class="line-modified">!     static const unsigned calledFunctorFlag = 2;</span>
      HashMap&lt;Node*, unsigned&gt; flags;
  
      Node* node = block-&gt;at(nodeIndex);
  
      graph.doToChildren(
          node,
          [&amp;] (Edge edge) {
<span class="line-new-header">--- 55,83 ---</span>
          return;
      }
  
      CodeOrigin after = nodeAfter-&gt;origin.forExit;
  
<span class="line-modified">!     Operand alreadyNoted;</span>
      // If we MovHint something that is live at the time, then we kill the old value.
      if (nodeAfter-&gt;containsMovHint()) {
<span class="line-modified">!         Operand operand = nodeAfter-&gt;unlinkedOperand();</span>
<span class="line-modified">!         if (graph.isLiveInBytecode(operand, after)) {</span>
<span class="line-modified">!             functor(operand);</span>
<span class="line-modified">!             alreadyNoted = operand;</span>
          }
      }
  
      if (before == after)
          return;
  
      // It&#39;s easier to do this if the inline call frames are the same. This is way faster than the
      // other loop, below.
      auto* beforeInlineCallFrame = before.inlineCallFrame();
      if (beforeInlineCallFrame == after.inlineCallFrame()) {
          CodeBlock* codeBlock = graph.baselineCodeBlockFor(beforeInlineCallFrame);
<span class="line-added">+         if (after.bytecodeIndex().checkpoint()) {</span>
<span class="line-added">+             ASSERT(before.bytecodeIndex().checkpoint() != after.bytecodeIndex().checkpoint());</span>
<span class="line-added">+             ASSERT_WITH_MESSAGE(before.bytecodeIndex().offset() == after.bytecodeIndex().offset(), &quot;When the DFG does code motion it should change the forExit origin to match the surrounding bytecodes.&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+             auto liveBefore = tmpLivenessForCheckpoint(*codeBlock, before.bytecodeIndex());</span>
<span class="line-added">+             auto liveAfter = tmpLivenessForCheckpoint(*codeBlock, after.bytecodeIndex());</span>
<span class="line-added">+             liveAfter.invert();</span>
<span class="line-added">+             liveBefore.filter(liveAfter);</span>
<span class="line-added">+ </span>
<span class="line-added">+             liveBefore.forEachSetBit([&amp;] (size_t tmp) {</span>
<span class="line-added">+                 functor(remapOperand(beforeInlineCallFrame, Operand::tmp(tmp)));</span>
<span class="line-added">+             });</span>
<span class="line-added">+             // No locals can die at a checkpoint.</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          FullBytecodeLiveness&amp; fullLiveness = graph.livenessFor(codeBlock);
<span class="line-modified">!         const FastBitVector&amp; liveBefore = fullLiveness.getLiveness(before.bytecodeIndex(), LivenessCalculationPoint::BeforeUse);</span>
<span class="line-modified">!         const FastBitVector&amp; liveAfter = fullLiveness.getLiveness(after.bytecodeIndex(), LivenessCalculationPoint::BeforeUse);</span>
  
          (liveBefore &amp; ~liveAfter).forEachSetBit(
              [&amp;] (size_t relativeLocal) {
<span class="line-modified">!                 functor(remapOperand(beforeInlineCallFrame, virtualRegisterForLocal(relativeLocal)));</span>
              });
          return;
      }
  
<span class="line-added">+     ASSERT_WITH_MESSAGE(!after.bytecodeIndex().checkpoint(), &quot;Transitioning across a checkpoint but before and after don&#39;t share an inlineCallFrame.&quot;);</span>
<span class="line-added">+ </span>
      // Detect kills the super conservative way: it is killed if it was live before and dead after.
<span class="line-modified">!     BitVector liveAfter = graph.localsAndTmpsLiveInBytecode(after);</span>
<span class="line-modified">!     unsigned numLocals = graph.block(0)-&gt;variablesAtHead.numberOfLocals();</span>
<span class="line-added">+     graph.forAllLocalsAndTmpsLiveInBytecode(</span>
          before,
<span class="line-modified">!         [&amp;] (Operand operand) {</span>
<span class="line-modified">!             if (operand == alreadyNoted)</span>
                  return;
<span class="line-modified">!             unsigned offset = operand.isTmp() ? numLocals + operand.value() : operand.toLocal();</span>
<span class="line-added">+             if (liveAfter.get(offset))</span>
                  return;
<span class="line-modified">!             functor(operand);</span>
          });
  }
  
  // Tells you all of the nodes that would no longer be live across the node at this nodeIndex.
  template&lt;typename Functor&gt;
  void forAllKilledNodesAtNodeIndex(
      Graph&amp; graph, AvailabilityMap&amp; availabilityMap, BasicBlock* block, unsigned nodeIndex,
      const Functor&amp; functor)
  {
<span class="line-modified">!     static constexpr unsigned seenInClosureFlag = 1;</span>
<span class="line-modified">!     static constexpr unsigned calledFunctorFlag = 2;</span>
      HashMap&lt;Node*, unsigned&gt; flags;
  
<span class="line-added">+     ASSERT(nodeIndex);</span>
      Node* node = block-&gt;at(nodeIndex);
  
      graph.doToChildren(
          node,
          [&amp;] (Edge edge) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 118,19 ***</span>
                      result |= calledFunctorFlag;
                  }
              }
          });
  
<span class="line-modified">!     Node* before = nullptr;</span>
<span class="line-removed">-     if (nodeIndex)</span>
<span class="line-removed">-         before = block-&gt;at(nodeIndex - 1);</span>
  
      forAllKilledOperands(
          graph, before, node,
<span class="line-modified">!         [&amp;] (VirtualRegister reg) {</span>
              availabilityMap.closeStartingWithLocal(
<span class="line-modified">!                 reg,</span>
                  [&amp;] (Node* node) -&gt; bool {
                      return flags.get(node) &amp; seenInClosureFlag;
                  },
                  [&amp;] (Node* node) -&gt; bool {
                      auto&amp; resultFlags = flags.add(node, 0).iterator-&gt;value;
<span class="line-new-header">--- 142,17 ---</span>
                      result |= calledFunctorFlag;
                  }
              }
          });
  
<span class="line-modified">!     Node* before = block-&gt;at(nodeIndex - 1);</span>
  
      forAllKilledOperands(
          graph, before, node,
<span class="line-modified">!         [&amp;] (Operand operand) {</span>
              availabilityMap.closeStartingWithLocal(
<span class="line-modified">!                 operand,</span>
                  [&amp;] (Node* node) -&gt; bool {
                      return flags.get(node) &amp; seenInClosureFlag;
                  },
                  [&amp;] (Node* node) -&gt; bool {
                      auto&amp; resultFlags = flags.add(node, 0).iterator-&gt;value;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 157,10 ***</span>
<span class="line-new-header">--- 179,11 ---</span>
      LocalOSRAvailabilityCalculator localAvailability(graph);
      localAvailability.beginBlock(block);
      // Start at the second node, because the functor is expected to only inspect nodes from the start of
      // the block up to nodeIndex (exclusive), so if nodeIndex is zero then the functor has nothing to do.
      for (unsigned nodeIndex = 1; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
<span class="line-added">+         dataLogLnIf(ForAllKillsInternal::verbose, &quot;local availability at index: &quot;, nodeIndex, &quot; &quot;, localAvailability.m_availability);</span>
          forAllKilledNodesAtNodeIndex(
              graph, localAvailability.m_availability, block, nodeIndex,
              [&amp;] (Node* node) {
                  functor(nodeIndex, node);
              });
</pre>
<center><a href="DFGFixupPhase.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGGraph.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
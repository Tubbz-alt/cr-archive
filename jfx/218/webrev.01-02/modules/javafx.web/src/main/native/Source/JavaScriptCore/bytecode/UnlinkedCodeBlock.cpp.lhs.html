<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedCodeBlock.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2012-2019 Apple Inc. All Rights Reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #include &quot;UnlinkedCodeBlock.h&quot;
 29 
 30 #include &quot;BytecodeGenerator.h&quot;
 31 #include &quot;BytecodeLivenessAnalysis.h&quot;
 32 #include &quot;BytecodeRewriter.h&quot;
 33 #include &quot;ClassInfo.h&quot;
 34 #include &quot;CodeCache.h&quot;
 35 #include &quot;ExecutableInfo.h&quot;
 36 #include &quot;FunctionOverrides.h&quot;
 37 #include &quot;InstructionStream.h&quot;
 38 #include &quot;JSCInlines.h&quot;
 39 #include &quot;JSString.h&quot;
 40 #include &quot;Opcode.h&quot;
 41 #include &quot;Parser.h&quot;
 42 #include &quot;PreciseJumpTargetsInlines.h&quot;
 43 #include &quot;SourceProvider.h&quot;
 44 #include &quot;Structure.h&quot;
 45 #include &quot;SymbolTable.h&quot;
 46 #include &quot;UnlinkedEvalCodeBlock.h&quot;
 47 #include &quot;UnlinkedFunctionCodeBlock.h&quot;
 48 #include &quot;UnlinkedMetadataTableInlines.h&quot;
 49 #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
 50 #include &quot;UnlinkedProgramCodeBlock.h&quot;
 51 #include &lt;wtf/DataLog.h&gt;
 52 
 53 namespace JSC {
 54 
 55 const ClassInfo UnlinkedCodeBlock::s_info = { &quot;UnlinkedCodeBlock&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(UnlinkedCodeBlock) };
 56 
 57 UnlinkedCodeBlock::UnlinkedCodeBlock(VM&amp; vm, Structure* structure, CodeType codeType, const ExecutableInfo&amp; info, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode)
 58     : Base(vm, structure)
 59     , m_usesEval(info.usesEval())
 60     , m_isStrictMode(info.isStrictMode())
 61     , m_isConstructor(info.isConstructor())
 62     , m_hasCapturedVariables(false)
 63     , m_isBuiltinFunction(info.isBuiltinFunction())
 64     , m_superBinding(static_cast&lt;unsigned&gt;(info.superBinding()))
 65     , m_scriptMode(static_cast&lt;unsigned&gt;(info.scriptMode()))
 66     , m_isArrowFunctionContext(info.isArrowFunctionContext())
 67     , m_isClassContext(info.isClassContext())
 68     , m_hasTailCalls(false)
 69     , m_constructorKind(static_cast&lt;unsigned&gt;(info.constructorKind()))
 70     , m_derivedContextType(static_cast&lt;unsigned&gt;(info.derivedContextType()))
 71     , m_evalContextType(static_cast&lt;unsigned&gt;(info.evalContextType()))
 72     , m_codeType(static_cast&lt;unsigned&gt;(codeType))
 73     , m_didOptimize(static_cast&lt;unsigned&gt;(MixedTriState))
 74     , m_age(0)
<a name="1" id="anc1"></a>
 75     , m_parseMode(info.parseMode())
 76     , m_codeGenerationMode(codeGenerationMode)
 77     , m_metadata(UnlinkedMetadataTable::create())
 78 {
<a name="2" id="anc2"></a><span class="line-removed"> 79     for (auto&amp; constantRegisterIndex : m_linkTimeConstants)</span>
<span class="line-removed"> 80         constantRegisterIndex = 0;</span>
 81     ASSERT(m_constructorKind == static_cast&lt;unsigned&gt;(info.constructorKind()));
 82     ASSERT(m_codeType == static_cast&lt;unsigned&gt;(codeType));
 83     ASSERT(m_didOptimize == static_cast&lt;unsigned&gt;(MixedTriState));
<a name="3" id="anc3"></a>



 84 }
 85 
 86 void UnlinkedCodeBlock::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 87 {
 88     UnlinkedCodeBlock* thisObject = jsCast&lt;UnlinkedCodeBlock*&gt;(cell);
 89     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 90     Base::visitChildren(thisObject, visitor);
 91     auto locker = holdLock(thisObject-&gt;cellLock());
 92     if (visitor.isFirstVisit())
 93         thisObject-&gt;m_age = std::min&lt;unsigned&gt;(static_cast&lt;unsigned&gt;(thisObject-&gt;m_age) + 1, maxAge);
<a name="4" id="anc4"></a><span class="line-modified"> 94     for (FunctionExpressionVector::iterator ptr = thisObject-&gt;m_functionDecls.begin(), end = thisObject-&gt;m_functionDecls.end(); ptr != end; ++ptr)</span>
<span class="line-modified"> 95         visitor.append(*ptr);</span>
<span class="line-modified"> 96     for (FunctionExpressionVector::iterator ptr = thisObject-&gt;m_functionExprs.begin(), end = thisObject-&gt;m_functionExprs.end(); ptr != end; ++ptr)</span>
<span class="line-modified"> 97         visitor.append(*ptr);</span>
 98     visitor.appendValues(thisObject-&gt;m_constantRegisters.data(), thisObject-&gt;m_constantRegisters.size());
 99     size_t extraMemory = thisObject-&gt;m_metadata-&gt;sizeInBytes();
100     if (thisObject-&gt;m_instructions)
101         extraMemory += thisObject-&gt;m_instructions-&gt;sizeInBytes();
102     visitor.reportExtraMemoryVisited(extraMemory);
103 }
104 
105 size_t UnlinkedCodeBlock::estimatedSize(JSCell* cell, VM&amp; vm)
106 {
107     UnlinkedCodeBlock* thisObject = jsCast&lt;UnlinkedCodeBlock*&gt;(cell);
108     size_t extraSize = thisObject-&gt;m_metadata-&gt;sizeInBytes();
109     if (thisObject-&gt;m_instructions)
110         extraSize += thisObject-&gt;m_instructions-&gt;sizeInBytes();
111     return Base::estimatedSize(cell, vm) + extraSize;
112 }
113 
<a name="5" id="anc5"></a><span class="line-modified">114 int UnlinkedCodeBlock::lineNumberForBytecodeOffset(unsigned bytecodeOffset)</span>
115 {
<a name="6" id="anc6"></a><span class="line-modified">116     ASSERT(bytecodeOffset &lt; instructions().size());</span>
117     int divot { 0 };
118     int startOffset { 0 };
119     int endOffset { 0 };
120     unsigned line { 0 };
121     unsigned column { 0 };
<a name="7" id="anc7"></a><span class="line-modified">122     expressionRangeForBytecodeOffset(bytecodeOffset, divot, startOffset, endOffset, line, column);</span>
123     return line;
124 }
125 
126 inline void UnlinkedCodeBlock::getLineAndColumn(const ExpressionRangeInfo&amp; info,
127     unsigned&amp; line, unsigned&amp; column) const
128 {
129     switch (info.mode) {
130     case ExpressionRangeInfo::FatLineMode:
131         info.decodeFatLineMode(line, column);
132         break;
133     case ExpressionRangeInfo::FatColumnMode:
134         info.decodeFatColumnMode(line, column);
135         break;
136     case ExpressionRangeInfo::FatLineAndColumnMode: {
137         unsigned fatIndex = info.position;
138         ExpressionRangeInfo::FatPosition&amp; fatPos = m_rareData-&gt;m_expressionInfoFatPositions[fatIndex];
139         line = fatPos.line;
140         column = fatPos.column;
141         break;
142     }
143     } // switch
144 }
145 
146 #ifndef NDEBUG
147 static void dumpLineColumnEntry(size_t index, const InstructionStream&amp; instructionStream, unsigned instructionOffset, unsigned line, unsigned column)
148 {
149     const auto instruction = instructionStream.at(instructionOffset);
150     const char* event = &quot;&quot;;
151     if (instruction-&gt;is&lt;OpDebug&gt;()) {
152         switch (instruction-&gt;as&lt;OpDebug&gt;().m_debugHookType) {
153         case WillExecuteProgram: event = &quot; WillExecuteProgram&quot;; break;
154         case DidExecuteProgram: event = &quot; DidExecuteProgram&quot;; break;
155         case DidEnterCallFrame: event = &quot; DidEnterCallFrame&quot;; break;
<a name="8" id="anc8"></a><span class="line-modified">156         case DidReachBreakpoint: event = &quot; DidReachBreakpoint&quot;; break;</span>
157         case WillLeaveCallFrame: event = &quot; WillLeaveCallFrame&quot;; break;
158         case WillExecuteStatement: event = &quot; WillExecuteStatement&quot;; break;
159         case WillExecuteExpression: event = &quot; WillExecuteExpression&quot;; break;
160         }
161     }
162     dataLogF(&quot;  [%zu] pc %u @ line %u col %u : %s%s\n&quot;, index, instructionOffset, line, column, instruction-&gt;name(), event);
163 }
164 
165 void UnlinkedCodeBlock::dumpExpressionRangeInfo()
166 {
<a name="9" id="anc9"></a><span class="line-modified">167     Vector&lt;ExpressionRangeInfo&gt;&amp; expressionInfo = m_expressionInfo;</span>
168 
169     size_t size = m_expressionInfo.size();
170     dataLogF(&quot;UnlinkedCodeBlock %p expressionRangeInfo[%zu] {\n&quot;, this, size);
171     for (size_t i = 0; i &lt; size; i++) {
172         ExpressionRangeInfo&amp; info = expressionInfo[i];
173         unsigned line;
174         unsigned column;
175         getLineAndColumn(info, line, column);
176         dumpLineColumnEntry(i, instructions(), info.instructionOffset, line, column);
177     }
178     dataLog(&quot;}\n&quot;);
179 }
180 #endif
181 
<a name="10" id="anc10"></a><span class="line-modified">182 void UnlinkedCodeBlock::expressionRangeForBytecodeOffset(unsigned bytecodeOffset,</span>
183     int&amp; divot, int&amp; startOffset, int&amp; endOffset, unsigned&amp; line, unsigned&amp; column) const
184 {
<a name="11" id="anc11"></a><span class="line-modified">185     ASSERT(bytecodeOffset &lt; instructions().size());</span>
186 
187     if (!m_expressionInfo.size()) {
188         startOffset = 0;
189         endOffset = 0;
190         divot = 0;
191         line = 0;
192         column = 0;
193         return;
194     }
195 
<a name="12" id="anc12"></a><span class="line-modified">196     const Vector&lt;ExpressionRangeInfo&gt;&amp; expressionInfo = m_expressionInfo;</span>
197 
198     int low = 0;
199     int high = expressionInfo.size();
200     while (low &lt; high) {
201         int mid = low + (high - low) / 2;
<a name="13" id="anc13"></a><span class="line-modified">202         if (expressionInfo[mid].instructionOffset &lt;= bytecodeOffset)</span>
203             low = mid + 1;
204         else
205             high = mid;
206     }
207 
208     if (!low)
209         low = 1;
210 
211     const ExpressionRangeInfo&amp; info = expressionInfo[low - 1];
212     startOffset = info.startOffset;
213     endOffset = info.endOffset;
214     divot = info.divotPoint;
215     getLineAndColumn(info, line, column);
216 }
217 
<a name="14" id="anc14"></a><span class="line-removed">218 void UnlinkedCodeBlock::addExpressionInfo(unsigned instructionOffset,</span>
<span class="line-removed">219     int divot, int startOffset, int endOffset, unsigned line, unsigned column)</span>
<span class="line-removed">220 {</span>
<span class="line-removed">221     if (divot &gt; ExpressionRangeInfo::MaxDivot) {</span>
<span class="line-removed">222         // Overflow has occurred, we can only give line number info for errors for this region</span>
<span class="line-removed">223         divot = 0;</span>
<span class="line-removed">224         startOffset = 0;</span>
<span class="line-removed">225         endOffset = 0;</span>
<span class="line-removed">226     } else if (startOffset &gt; ExpressionRangeInfo::MaxOffset) {</span>
<span class="line-removed">227         // If the start offset is out of bounds we clear both offsets</span>
<span class="line-removed">228         // so we only get the divot marker. Error message will have to be reduced</span>
<span class="line-removed">229         // to line and charPosition number.</span>
<span class="line-removed">230         startOffset = 0;</span>
<span class="line-removed">231         endOffset = 0;</span>
<span class="line-removed">232     } else if (endOffset &gt; ExpressionRangeInfo::MaxOffset) {</span>
<span class="line-removed">233         // The end offset is only used for additional context, and is much more likely</span>
<span class="line-removed">234         // to overflow (eg. function call arguments) so we are willing to drop it without</span>
<span class="line-removed">235         // dropping the rest of the range.</span>
<span class="line-removed">236         endOffset = 0;</span>
<span class="line-removed">237     }</span>
<span class="line-removed">238 </span>
<span class="line-removed">239     unsigned positionMode =</span>
<span class="line-removed">240         (line &lt;= ExpressionRangeInfo::MaxFatLineModeLine &amp;&amp; column &lt;= ExpressionRangeInfo::MaxFatLineModeColumn)</span>
<span class="line-removed">241         ? ExpressionRangeInfo::FatLineMode</span>
<span class="line-removed">242         : (line &lt;= ExpressionRangeInfo::MaxFatColumnModeLine &amp;&amp; column &lt;= ExpressionRangeInfo::MaxFatColumnModeColumn)</span>
<span class="line-removed">243         ? ExpressionRangeInfo::FatColumnMode</span>
<span class="line-removed">244         : ExpressionRangeInfo::FatLineAndColumnMode;</span>
<span class="line-removed">245 </span>
<span class="line-removed">246     ExpressionRangeInfo info;</span>
<span class="line-removed">247     info.instructionOffset = instructionOffset;</span>
<span class="line-removed">248     info.divotPoint = divot;</span>
<span class="line-removed">249     info.startOffset = startOffset;</span>
<span class="line-removed">250     info.endOffset = endOffset;</span>
<span class="line-removed">251 </span>
<span class="line-removed">252     info.mode = positionMode;</span>
<span class="line-removed">253     switch (positionMode) {</span>
<span class="line-removed">254     case ExpressionRangeInfo::FatLineMode:</span>
<span class="line-removed">255         info.encodeFatLineMode(line, column);</span>
<span class="line-removed">256         break;</span>
<span class="line-removed">257     case ExpressionRangeInfo::FatColumnMode:</span>
<span class="line-removed">258         info.encodeFatColumnMode(line, column);</span>
<span class="line-removed">259         break;</span>
<span class="line-removed">260     case ExpressionRangeInfo::FatLineAndColumnMode: {</span>
<span class="line-removed">261         createRareDataIfNecessary();</span>
<span class="line-removed">262         unsigned fatIndex = m_rareData-&gt;m_expressionInfoFatPositions.size();</span>
<span class="line-removed">263         ExpressionRangeInfo::FatPosition fatPos = { line, column };</span>
<span class="line-removed">264         m_rareData-&gt;m_expressionInfoFatPositions.append(fatPos);</span>
<span class="line-removed">265         info.position = fatIndex;</span>
<span class="line-removed">266     }</span>
<span class="line-removed">267     } // switch</span>
<span class="line-removed">268 </span>
<span class="line-removed">269     m_expressionInfo.append(info);</span>
<span class="line-removed">270 }</span>
<span class="line-removed">271 </span>
272 bool UnlinkedCodeBlock::typeProfilerExpressionInfoForBytecodeOffset(unsigned bytecodeOffset, unsigned&amp; startDivot, unsigned&amp; endDivot)
273 {
<a name="15" id="anc15"></a><span class="line-modified">274     static const bool verbose = false;</span>
275     if (!m_rareData) {
276         if (verbose)
277             dataLogF(&quot;Don&#39;t have assignment info for offset:%u\n&quot;, bytecodeOffset);
278         startDivot = UINT_MAX;
279         endDivot = UINT_MAX;
280         return false;
281     }
282 
283     auto iter = m_rareData-&gt;m_typeProfilerInfoMap.find(bytecodeOffset);
284     if (iter == m_rareData-&gt;m_typeProfilerInfoMap.end()) {
285         if (verbose)
286             dataLogF(&quot;Don&#39;t have assignment info for offset:%u\n&quot;, bytecodeOffset);
287         startDivot = UINT_MAX;
288         endDivot = UINT_MAX;
289         return false;
290     }
291 
292     RareData::TypeProfilerExpressionRange&amp; range = iter-&gt;value;
293     startDivot = range.m_startDivot;
294     endDivot = range.m_endDivot;
295     return true;
296 }
297 
<a name="16" id="anc16"></a><span class="line-removed">298 void UnlinkedCodeBlock::addTypeProfilerExpressionInfo(unsigned instructionOffset, unsigned startDivot, unsigned endDivot)</span>
<span class="line-removed">299 {</span>
<span class="line-removed">300     createRareDataIfNecessary();</span>
<span class="line-removed">301     RareData::TypeProfilerExpressionRange range;</span>
<span class="line-removed">302     range.m_startDivot = startDivot;</span>
<span class="line-removed">303     range.m_endDivot = endDivot;</span>
<span class="line-removed">304     m_rareData-&gt;m_typeProfilerInfoMap.set(instructionOffset, range);</span>
<span class="line-removed">305 }</span>
<span class="line-removed">306 </span>
307 UnlinkedCodeBlock::~UnlinkedCodeBlock()
308 {
309 }
310 
<a name="17" id="anc17"></a><span class="line-removed">311 void UnlinkedCodeBlock::setInstructions(std::unique_ptr&lt;InstructionStream&gt; instructions)</span>
<span class="line-removed">312 {</span>
<span class="line-removed">313     ASSERT(instructions);</span>
<span class="line-removed">314     {</span>
<span class="line-removed">315         auto locker = holdLock(cellLock());</span>
<span class="line-removed">316         m_instructions = WTFMove(instructions);</span>
<span class="line-removed">317         m_metadata-&gt;finalize();</span>
<span class="line-removed">318     }</span>
<span class="line-removed">319     Heap::heap(this)-&gt;reportExtraMemoryAllocated(m_instructions-&gt;sizeInBytes() + m_metadata-&gt;sizeInBytes());</span>
<span class="line-removed">320 }</span>
<span class="line-removed">321 </span>
322 const InstructionStream&amp; UnlinkedCodeBlock::instructions() const
323 {
324     ASSERT(m_instructions.get());
325     return *m_instructions;
326 }
327 
<a name="18" id="anc18"></a><span class="line-modified">328 UnlinkedHandlerInfo* UnlinkedCodeBlock::handlerForBytecodeOffset(unsigned bytecodeOffset, RequiredHandler requiredHandler)</span>
329 {
<a name="19" id="anc19"></a><span class="line-modified">330     return handlerForIndex(bytecodeOffset, requiredHandler);</span>
331 }
332 
333 UnlinkedHandlerInfo* UnlinkedCodeBlock::handlerForIndex(unsigned index, RequiredHandler requiredHandler)
334 {
335     if (!m_rareData)
336         return nullptr;
<a name="20" id="anc20"></a><span class="line-modified">337     return UnlinkedHandlerInfo::handlerForIndex(m_rareData-&gt;m_exceptionHandlers, index, requiredHandler);</span>
<span class="line-removed">338 }</span>
<span class="line-removed">339 </span>
<span class="line-removed">340 void UnlinkedCodeBlock::applyModification(BytecodeRewriter&amp; rewriter, InstructionStreamWriter&amp; instructions)</span>
<span class="line-removed">341 {</span>
<span class="line-removed">342     // Before applying the changes, we adjust the jumps based on the original bytecode offset, the offset to the jump target, and</span>
<span class="line-removed">343     // the insertion information.</span>
<span class="line-removed">344 </span>
<span class="line-removed">345     rewriter.adjustJumpTargets();</span>
<span class="line-removed">346 </span>
<span class="line-removed">347     // Then, exception handlers should be adjusted.</span>
<span class="line-removed">348     if (m_rareData) {</span>
<span class="line-removed">349         for (UnlinkedHandlerInfo&amp; handler : m_rareData-&gt;m_exceptionHandlers) {</span>
<span class="line-removed">350             handler.target = rewriter.adjustAbsoluteOffset(handler.target);</span>
<span class="line-removed">351             handler.start = rewriter.adjustAbsoluteOffset(handler.start);</span>
<span class="line-removed">352             handler.end = rewriter.adjustAbsoluteOffset(handler.end);</span>
<span class="line-removed">353         }</span>
<span class="line-removed">354 </span>
<span class="line-removed">355         for (size_t i = 0; i &lt; m_rareData-&gt;m_opProfileControlFlowBytecodeOffsets.size(); ++i)</span>
<span class="line-removed">356             m_rareData-&gt;m_opProfileControlFlowBytecodeOffsets[i] = rewriter.adjustAbsoluteOffset(m_rareData-&gt;m_opProfileControlFlowBytecodeOffsets[i]);</span>
<span class="line-removed">357 </span>
<span class="line-removed">358         if (!m_rareData-&gt;m_typeProfilerInfoMap.isEmpty()) {</span>
<span class="line-removed">359             HashMap&lt;unsigned, RareData::TypeProfilerExpressionRange&gt; adjustedTypeProfilerInfoMap;</span>
<span class="line-removed">360             for (auto&amp; entry : m_rareData-&gt;m_typeProfilerInfoMap)</span>
<span class="line-removed">361                 adjustedTypeProfilerInfoMap.set(rewriter.adjustAbsoluteOffset(entry.key), entry.value);</span>
<span class="line-removed">362             m_rareData-&gt;m_typeProfilerInfoMap.swap(adjustedTypeProfilerInfoMap);</span>
<span class="line-removed">363         }</span>
<span class="line-removed">364     }</span>
<span class="line-removed">365 </span>
<span class="line-removed">366     for (size_t i = 0; i &lt; m_propertyAccessInstructions.size(); ++i)</span>
<span class="line-removed">367         m_propertyAccessInstructions[i] = rewriter.adjustAbsoluteOffset(m_propertyAccessInstructions[i]);</span>
<span class="line-removed">368 </span>
<span class="line-removed">369     for (size_t i = 0; i &lt; m_expressionInfo.size(); ++i)</span>
<span class="line-removed">370         m_expressionInfo[i].instructionOffset = rewriter.adjustAbsoluteOffset(m_expressionInfo[i].instructionOffset);</span>
<span class="line-removed">371 </span>
<span class="line-removed">372     // Then, modify the unlinked instructions.</span>
<span class="line-removed">373     rewriter.applyModification();</span>
<span class="line-removed">374 </span>
<span class="line-removed">375     // And recompute the jump target based on the modified unlinked instructions.</span>
<span class="line-removed">376     m_jumpTargets.clear();</span>
<span class="line-removed">377     recomputePreciseJumpTargets(this, instructions, m_jumpTargets);</span>
<span class="line-removed">378 }</span>
<span class="line-removed">379 </span>
<span class="line-removed">380 void UnlinkedCodeBlock::shrinkToFit()</span>
<span class="line-removed">381 {</span>
<span class="line-removed">382     auto locker = holdLock(cellLock());</span>
<span class="line-removed">383 </span>
<span class="line-removed">384     m_jumpTargets.shrinkToFit();</span>
<span class="line-removed">385     m_propertyAccessInstructions.shrinkToFit();</span>
<span class="line-removed">386     m_identifiers.shrinkToFit();</span>
<span class="line-removed">387     m_constantRegisters.shrinkToFit();</span>
<span class="line-removed">388     m_constantsSourceCodeRepresentation.shrinkToFit();</span>
<span class="line-removed">389     m_functionDecls.shrinkToFit();</span>
<span class="line-removed">390     m_functionExprs.shrinkToFit();</span>
<span class="line-removed">391     m_expressionInfo.shrinkToFit();</span>
<span class="line-removed">392 </span>
<span class="line-removed">393     if (m_rareData) {</span>
<span class="line-removed">394         m_rareData-&gt;m_exceptionHandlers.shrinkToFit();</span>
<span class="line-removed">395         m_rareData-&gt;m_switchJumpTables.shrinkToFit();</span>
<span class="line-removed">396         m_rareData-&gt;m_stringSwitchJumpTables.shrinkToFit();</span>
<span class="line-removed">397         m_rareData-&gt;m_expressionInfoFatPositions.shrinkToFit();</span>
<span class="line-removed">398         m_rareData-&gt;m_opProfileControlFlowBytecodeOffsets.shrinkToFit();</span>
<span class="line-removed">399         m_rareData-&gt;m_bitVectors.shrinkToFit();</span>
<span class="line-removed">400         m_rareData-&gt;m_constantIdentifierSets.shrinkToFit();</span>
<span class="line-removed">401     }</span>
402 }
403 
404 void UnlinkedCodeBlock::dump(PrintStream&amp;) const
405 {
406 }
407 
408 BytecodeLivenessAnalysis&amp; UnlinkedCodeBlock::livenessAnalysisSlow(CodeBlock* codeBlock)
409 {
410     RELEASE_ASSERT(codeBlock-&gt;unlinkedCodeBlock() == this);
411 
412     {
413         ConcurrentJSLocker locker(m_lock);
414         if (!m_liveness) {
415             // There is a chance two compiler threads raced to the slow path.
416             // Grabbing the lock above defends against computing liveness twice.
417             m_liveness = makeUnique&lt;BytecodeLivenessAnalysis&gt;(codeBlock);
418         }
419     }
420 
421     return *m_liveness;
422 }
423 
<a name="21" id="anc21"></a><span class="line-removed">424 void UnlinkedCodeBlock::addOutOfLineJumpTarget(InstructionStream::Offset bytecodeOffset, int target)</span>
<span class="line-removed">425 {</span>
<span class="line-removed">426     RELEASE_ASSERT(target);</span>
<span class="line-removed">427     m_outOfLineJumpTargets.set(bytecodeOffset, target);</span>
<span class="line-removed">428 }</span>
<span class="line-removed">429 </span>
430 int UnlinkedCodeBlock::outOfLineJumpOffset(InstructionStream::Offset bytecodeOffset)
431 {
432     ASSERT(m_outOfLineJumpTargets.contains(bytecodeOffset));
433     return m_outOfLineJumpTargets.get(bytecodeOffset);
434 }
435 
436 } // namespace JSC
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
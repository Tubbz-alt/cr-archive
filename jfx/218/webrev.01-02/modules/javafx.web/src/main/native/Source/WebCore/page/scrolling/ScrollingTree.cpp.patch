diff a/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingTree.cpp b/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingTree.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingTree.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingTree.cpp
@@ -69,11 +69,11 @@
         IntPoint roundedPosition = roundedIntPoint(position);
 
         // Event regions are affected by page scale, so no need to map through scale.
         bool isSynchronousDispatchRegion = m_treeState.eventTrackingRegions.trackingTypeForPoint(names.wheelEvent, roundedPosition) == TrackingType::Synchronous
             || m_treeState.eventTrackingRegions.trackingTypeForPoint(names.mousewheelEvent, roundedPosition) == TrackingType::Synchronous;
-        LOG_WITH_STREAM(Scrolling, stream << "ScrollingTree::shouldHandleWheelEventSynchronously: wheelEvent at " << wheelEvent.position() << " mapped to content point " << position << ", in non-fast region " << isSynchronousDispatchRegion);
+        LOG_WITH_STREAM(Scrolling, stream << "\n\nScrollingTree::shouldHandleWheelEventSynchronously: wheelEvent " << wheelEvent << " mapped to content point " << position << ", in non-fast region " << isSynchronousDispatchRegion);
 
         if (isSynchronousDispatchRegion)
             return true;
     }
     return false;
@@ -138,10 +138,11 @@
     m_rootNode->wasScrolledByDelegatedScrolling(scrollPosition, layoutViewport);
 }
 
 void ScrollingTree::commitTreeState(std::unique_ptr<ScrollingStateTree> scrollingStateTree)
 {
+    SetForScope<bool> inCommitTreeState(m_inCommitTreeState, true);
     LockHolder locker(m_treeMutex);
 
     bool rootStateNodeChanged = scrollingStateTree->hasNewRootStateNode();
 
     LOG(Scrolling, "\nScrollingTree %p commitTreeState", this);
@@ -149,21 +150,25 @@
     auto* rootNode = scrollingStateTree->rootStateNode();
     if (rootNode
         && (rootStateNodeChanged
             || rootNode->hasChangedProperty(ScrollingStateFrameScrollingNode::EventTrackingRegion)
             || rootNode->hasChangedProperty(ScrollingStateScrollingNode::ScrolledContentsLayer)
-            || rootNode->hasChangedProperty(ScrollingStateFrameScrollingNode::AsyncFrameOrOverflowScrollingEnabled))) {
+            || rootNode->hasChangedProperty(ScrollingStateFrameScrollingNode::AsyncFrameOrOverflowScrollingEnabled)
+            || rootNode->hasChangedProperty(ScrollingStateFrameScrollingNode::IsMonitoringWheelEvents))) {
         LockHolder lock(m_treeStateMutex);
 
         if (rootStateNodeChanged || rootNode->hasChangedProperty(ScrollingStateScrollingNode::ScrolledContentsLayer))
             m_treeState.mainFrameScrollPosition = { };
 
         if (rootStateNodeChanged || rootNode->hasChangedProperty(ScrollingStateFrameScrollingNode::EventTrackingRegion))
             m_treeState.eventTrackingRegions = scrollingStateTree->rootStateNode()->eventTrackingRegions();
 
         if (rootStateNodeChanged || rootNode->hasChangedProperty(ScrollingStateFrameScrollingNode::AsyncFrameOrOverflowScrollingEnabled))
             m_asyncFrameOrOverflowScrollingEnabled = scrollingStateTree->rootStateNode()->asyncFrameOrOverflowScrollingEnabled();
+
+        if (rootStateNodeChanged || rootNode->hasChangedProperty(ScrollingStateFrameScrollingNode::IsMonitoringWheelEvents))
+            m_isMonitoringWheelEvents = scrollingStateTree->rootStateNode()->isMonitoringWheelEvents();
     }
 
     // unvisitedNodes starts with all nodes in the map; we remove nodes as we visit them. At the end, it's the unvisited nodes.
     // We can't use orphanNodes for this, because orphanNodes won't contain descendants of removed nodes.
     HashSet<ScrollingNodeID> unvisitedNodes;
@@ -238,17 +243,15 @@
     }
 
     node->commitStateBeforeChildren(*stateNode);
 
     // Move all children into the orphanNodes map. Live ones will get added back as we recurse over children.
-    if (auto nodeChildren = node->children()) {
-        for (auto& childScrollingNode : *nodeChildren) {
-            childScrollingNode->setParent(nullptr);
-            orphanNodes.add(childScrollingNode->scrollingNodeID(), childScrollingNode.get());
-        }
-        nodeChildren->clear();
+    for (auto& childScrollingNode : node->children()) {
+        childScrollingNode->setParent(nullptr);
+        orphanNodes.add(childScrollingNode->scrollingNodeID(), childScrollingNode.ptr());
     }
+    node->removeAllChildren();
 
     // Now update the children if we have any.
     if (auto children = stateNode->children()) {
         for (auto& child : *children)
             updateTreeFromStateNode(child.get(), orphanNodes, unvisitedNodes);
@@ -280,18 +283,16 @@
     applyLayerPositionsRecursive(*m_rootNode);
 
     LOG(Scrolling, "ScrollingTree %p applyLayerPositions - done\n", this);
 }
 
-void ScrollingTree::applyLayerPositionsRecursive(ScrollingTreeNode& currNode)
+void ScrollingTree::applyLayerPositionsRecursive(ScrollingTreeNode& node)
 {
-    currNode.applyLayerPositions();
+    node.applyLayerPositions();
 
-    if (auto children = currNode.children()) {
-        for (auto& child : *children)
-            applyLayerPositionsRecursive(*child);
-    }
+    for (auto& child : node.children())
+        applyLayerPositionsRecursive(child.get());
 }
 
 ScrollingTreeNode* ScrollingTree::nodeForID(ScrollingNodeID nodeID) const
 {
     if (!nodeID)
@@ -318,19 +319,16 @@
 
 void ScrollingTree::notifyRelatedNodesRecursive(ScrollingTreeNode& node)
 {
     node.applyLayerPositions();
 
-    if (!node.children())
-        return;
-
-    for (auto& child : *node.children()) {
+    for (auto& child : node.children()) {
         // Never need to cross frame boundaries, since scroll layer adjustments are isolated to each document.
         if (is<ScrollingTreeFrameScrollingNode>(child))
             continue;
 
-        notifyRelatedNodesRecursive(*child);
+        notifyRelatedNodesRecursive(child.get());
     }
 }
 
 void ScrollingTree::setAsyncFrameOrOverflowScrollingEnabled(bool enabled)
 {

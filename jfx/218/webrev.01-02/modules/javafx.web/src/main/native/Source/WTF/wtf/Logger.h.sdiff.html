<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/Logger.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Logger.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LoggerHelper.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/Logger.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2017 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;wtf/Lock.h&gt;
 29 #include &lt;wtf/ThreadSafeRefCounted.h&gt;
 30 #include &lt;wtf/text/StringBuilder.h&gt;
 31 
 32 namespace WTF {
 33 
 34 template&lt;typename T&gt;
 35 struct LogArgument {
 36     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;U, bool&gt;::value, String&gt;::type toString(bool argument) { return argument ? &quot;true&quot;_s : &quot;false&quot;_s; }
 37     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;U, int&gt;::value, String&gt;::type toString(int argument) { return String::number(argument); }
 38     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;U, unsigned&gt;::value, String&gt;::type toString(unsigned argument) { return String::number(argument); }
 39     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;U, unsigned long&gt;::value, String&gt;::type toString(unsigned long argument) { return String::number(argument); }
 40     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;U, long&gt;::value, String&gt;::type toString(long argument) { return String::number(argument); }
 41     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;U, unsigned long long&gt;::value, String&gt;::type toString(unsigned long long argument) { return String::number(argument); }
 42     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;U, long long&gt;::value, String&gt;::type toString(long long argument) { return String::number(argument); }
 43     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_enum&lt;U&gt;::value, String&gt;::type toString(U argument) { return String::number(static_cast&lt;typename std::underlying_type&lt;U&gt;::type&gt;(argument)); }
<span class="line-modified"> 44     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;U, float&gt;::value, String&gt;::type toString(float argument) { return String::numberToStringFixedPrecision(argument); }</span>
<span class="line-modified"> 45     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;U, double&gt;::value, String&gt;::type toString(double argument) { return String::numberToStringFixedPrecision(argument); }</span>
 46     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;typename std::remove_reference&lt;U&gt;::type, AtomString&gt;::value, String&gt;::type toString(const AtomString&amp; argument) { return argument.string(); }
 47     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;typename std::remove_reference&lt;U&gt;::type, String&gt;::value, String&gt;::type toString(String argument) { return argument; }
 48     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;typename std::remove_reference&lt;U&gt;::type, StringBuilder*&gt;::value, String&gt;::type toString(StringBuilder* argument) { return argument-&gt;toString(); }
 49     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;U, const char*&gt;::value, String&gt;::type toString(const char* argument) { return String(argument); }
 50     template&lt;size_t length&gt; static String toString(const char (&amp;argument)[length]) { return String(argument); }
 51 };
 52 
 53 struct JSONLogValue {
 54     enum class Type { String, JSON };
 55     Type type { Type::JSON };
 56     String value;
 57 };
 58 
 59 template&lt;class C&gt;
 60 class HasToJSONString {
 61     template &lt;class T&gt; static std::true_type testSignature(String (T::*)() const);
 62 
 63     template &lt;class T&gt; static decltype(testSignature(&amp;T::toJSONString)) test(std::nullptr_t);
 64     template &lt;class T&gt; static std::false_type test(...);
 65 
 66 public:
<span class="line-modified"> 67     static const bool value = decltype(test&lt;C&gt;(nullptr))::value;</span>
 68 };
 69 
 70 template&lt;typename Argument, bool hasJSON = HasToJSONString&lt;Argument&gt;::value&gt;
 71 struct ConsoleLogValueImpl;
 72 
 73 template&lt;typename Argument&gt;
 74 struct ConsoleLogValueImpl&lt;Argument, true&gt; {
 75     static JSONLogValue toValue(const Argument&amp; value)
 76     {
 77         return JSONLogValue { JSONLogValue::Type::JSON, value.toJSONString() };
 78     }
 79 };
 80 
 81 template&lt;typename Argument&gt;
 82 struct ConsoleLogValueImpl&lt;Argument, false&gt; {
 83     static JSONLogValue toValue(const Argument&amp; value)
 84     {
 85         return JSONLogValue { JSONLogValue::Type::String, LogArgument&lt;Argument&gt;::toString(value) };
 86     }
 87 };
</pre>
<hr />
<pre>
168     template&lt;typename... Arguments&gt;
169     inline void debug(WTFLogChannel&amp; channel, const Arguments&amp;... arguments) const
170     {
171         if (!willLog(channel, WTFLogLevel::Debug))
172             return;
173 
174         log(channel, WTFLogLevel::Debug, arguments...);
175     }
176 
177     inline bool willLog(const WTFLogChannel&amp; channel, WTFLogLevel level) const
178     {
179         if (!m_enabled)
180             return false;
181 
182         if (level &lt;= WTFLogLevel::Error)
183             return true;
184 
185         if (channel.state == WTFLogChannelState::Off || level &gt; channel.level)
186             return false;
187 
<span class="line-modified">188         return m_enabled;</span>
189     }
190 
191     bool enabled() const { return m_enabled; }
192     void setEnabled(const void* owner, bool enabled)
193     {
194         ASSERT(owner == m_owner);
195         if (owner == m_owner)
196             m_enabled = enabled;
197     }
198 
199     struct LogSiteIdentifier {
200         LogSiteIdentifier(const char* methodName, const void* objectPtr)
201             : methodName { methodName }
202             , objectPtr { reinterpret_cast&lt;uintptr_t&gt;(objectPtr) }
203         {
204         }
205 
206         LogSiteIdentifier(const char* className, const char* methodName, const void* objectPtr)
207             : className { className }
208             , methodName { methodName }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2017-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;wtf/Lock.h&gt;
 29 #include &lt;wtf/ThreadSafeRefCounted.h&gt;
 30 #include &lt;wtf/text/StringBuilder.h&gt;
 31 
 32 namespace WTF {
 33 
 34 template&lt;typename T&gt;
 35 struct LogArgument {
 36     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;U, bool&gt;::value, String&gt;::type toString(bool argument) { return argument ? &quot;true&quot;_s : &quot;false&quot;_s; }
 37     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;U, int&gt;::value, String&gt;::type toString(int argument) { return String::number(argument); }
 38     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;U, unsigned&gt;::value, String&gt;::type toString(unsigned argument) { return String::number(argument); }
 39     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;U, unsigned long&gt;::value, String&gt;::type toString(unsigned long argument) { return String::number(argument); }
 40     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;U, long&gt;::value, String&gt;::type toString(long argument) { return String::number(argument); }
 41     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;U, unsigned long long&gt;::value, String&gt;::type toString(unsigned long long argument) { return String::number(argument); }
 42     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;U, long long&gt;::value, String&gt;::type toString(long long argument) { return String::number(argument); }
 43     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_enum&lt;U&gt;::value, String&gt;::type toString(U argument) { return String::number(static_cast&lt;typename std::underlying_type&lt;U&gt;::type&gt;(argument)); }
<span class="line-modified"> 44     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;U, float&gt;::value, String&gt;::type toString(float argument) { return String::number(argument); }</span>
<span class="line-modified"> 45     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;U, double&gt;::value, String&gt;::type toString(double argument) { return String::number(argument); }</span>
 46     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;typename std::remove_reference&lt;U&gt;::type, AtomString&gt;::value, String&gt;::type toString(const AtomString&amp; argument) { return argument.string(); }
 47     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;typename std::remove_reference&lt;U&gt;::type, String&gt;::value, String&gt;::type toString(String argument) { return argument; }
 48     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;typename std::remove_reference&lt;U&gt;::type, StringBuilder*&gt;::value, String&gt;::type toString(StringBuilder* argument) { return argument-&gt;toString(); }
 49     template&lt;typename U = T&gt; static typename std::enable_if&lt;std::is_same&lt;U, const char*&gt;::value, String&gt;::type toString(const char* argument) { return String(argument); }
 50     template&lt;size_t length&gt; static String toString(const char (&amp;argument)[length]) { return String(argument); }
 51 };
 52 
 53 struct JSONLogValue {
 54     enum class Type { String, JSON };
 55     Type type { Type::JSON };
 56     String value;
 57 };
 58 
 59 template&lt;class C&gt;
 60 class HasToJSONString {
 61     template &lt;class T&gt; static std::true_type testSignature(String (T::*)() const);
 62 
 63     template &lt;class T&gt; static decltype(testSignature(&amp;T::toJSONString)) test(std::nullptr_t);
 64     template &lt;class T&gt; static std::false_type test(...);
 65 
 66 public:
<span class="line-modified"> 67     static constexpr bool value = decltype(test&lt;C&gt;(nullptr))::value;</span>
 68 };
 69 
 70 template&lt;typename Argument, bool hasJSON = HasToJSONString&lt;Argument&gt;::value&gt;
 71 struct ConsoleLogValueImpl;
 72 
 73 template&lt;typename Argument&gt;
 74 struct ConsoleLogValueImpl&lt;Argument, true&gt; {
 75     static JSONLogValue toValue(const Argument&amp; value)
 76     {
 77         return JSONLogValue { JSONLogValue::Type::JSON, value.toJSONString() };
 78     }
 79 };
 80 
 81 template&lt;typename Argument&gt;
 82 struct ConsoleLogValueImpl&lt;Argument, false&gt; {
 83     static JSONLogValue toValue(const Argument&amp; value)
 84     {
 85         return JSONLogValue { JSONLogValue::Type::String, LogArgument&lt;Argument&gt;::toString(value) };
 86     }
 87 };
</pre>
<hr />
<pre>
168     template&lt;typename... Arguments&gt;
169     inline void debug(WTFLogChannel&amp; channel, const Arguments&amp;... arguments) const
170     {
171         if (!willLog(channel, WTFLogLevel::Debug))
172             return;
173 
174         log(channel, WTFLogLevel::Debug, arguments...);
175     }
176 
177     inline bool willLog(const WTFLogChannel&amp; channel, WTFLogLevel level) const
178     {
179         if (!m_enabled)
180             return false;
181 
182         if (level &lt;= WTFLogLevel::Error)
183             return true;
184 
185         if (channel.state == WTFLogChannelState::Off || level &gt; channel.level)
186             return false;
187 
<span class="line-modified">188         return true;</span>
189     }
190 
191     bool enabled() const { return m_enabled; }
192     void setEnabled(const void* owner, bool enabled)
193     {
194         ASSERT(owner == m_owner);
195         if (owner == m_owner)
196             m_enabled = enabled;
197     }
198 
199     struct LogSiteIdentifier {
200         LogSiteIdentifier(const char* methodName, const void* objectPtr)
201             : methodName { methodName }
202             , objectPtr { reinterpret_cast&lt;uintptr_t&gt;(objectPtr) }
203         {
204         }
205 
206         LogSiteIdentifier(const char* className, const char* methodName, const void* objectPtr)
207             : className { className }
208             , methodName { methodName }
</pre>
</td>
</tr>
</table>
<center><a href="Logger.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LoggerHelper.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineLineBreaker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InlineItem.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InlineLineBreaker.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineLineBreaker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -26,77 +26,434 @@</span>
  #include &quot;config.h&quot;
  #include &quot;InlineLineBreaker.h&quot;
  
  #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  
<span class="udiff-line-added">+ #include &quot;FontCascade.h&quot;</span>
  #include &quot;Hyphenation.h&quot;
  #include &quot;InlineItem.h&quot;
  #include &quot;InlineTextItem.h&quot;
<span class="udiff-line-modified-removed">- #include &quot;LayoutState.h&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;RuntimeEnabledFeatures.h&quot;</span>
<span class="udiff-line-added">+ #include &quot;TextUtil.h&quot;</span>
  
  namespace WebCore {
  namespace Layout {
  
<span class="udiff-line-modified-removed">- LineBreaker::BreakingContext LineBreaker::breakingContext(const InlineItem&amp; inlineItem, LayoutUnit logicalWidth, const LineContext&amp; lineContext)</span>
<span class="udiff-line-modified-added">+ static inline bool isWrappingAllowed(const RenderStyle&amp; style)</span>
  {
<span class="udiff-line-modified-removed">-     // First content always stays on line.</span>
<span class="udiff-line-modified-removed">-     if (lineContext.isEmpty || logicalWidth &lt;= lineContext.availableWidth)</span>
<span class="udiff-line-modified-removed">-         return { BreakingBehavior::Keep, isAtBreakingOpportunity(inlineItem) };</span>
<span class="udiff-line-modified-added">+     // Do not try to push overflown &#39;pre&#39; and &#39;no-wrap&#39; content to next line.</span>
<span class="udiff-line-modified-added">+     return style.whiteSpace() != WhiteSpace::Pre &amp;&amp; style.whiteSpace() != WhiteSpace::NoWrap;</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static inline bool shouldKeepBeginningOfLineWhitespace(const RenderStyle&amp; style)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     auto whitespace = style.whiteSpace();</span>
<span class="udiff-line-added">+     return whitespace == WhiteSpace::Pre || whitespace == WhiteSpace::PreWrap || whitespace == WhiteSpace::BreakSpaces;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static inline Optional&lt;size_t&gt; lastWrapOpportunityIndex(const LineBreaker::RunList&amp; runList)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     // &lt;span style=&quot;white-space: pre&quot;&gt;no_wrap&lt;/span&gt;&lt;span&gt;yes wrap&lt;/span&gt;&lt;span style=&quot;white-space: pre&quot;&gt;no_wrap&lt;/span&gt;.</span>
<span class="udiff-line-added">+     // [container start][no_wrap][container end][container start][yes] &lt;- continuous content</span>
<span class="udiff-line-added">+     // [ ] &lt;- continuous content</span>
<span class="udiff-line-added">+     // [wrap][container end][container start][no_wrap][container end] &lt;- continuous content</span>
<span class="udiff-line-added">+     // Return #0 as the index where the second continuous content can wrap at.</span>
<span class="udiff-line-added">+     ASSERT(!runList.isEmpty());</span>
<span class="udiff-line-added">+     auto lastItemIndex = runList.size() - 1;</span>
<span class="udiff-line-added">+     return isWrappingAllowed(runList[lastItemIndex].inlineItem.style()) ? makeOptional(lastItemIndex) : WTF::nullopt;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ struct ContinuousContent {</span>
<span class="udiff-line-added">+     ContinuousContent(const LineBreaker::RunList&amp;, InlineLayoutUnit contentLogicalWidth);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     const LineBreaker::RunList&amp; runs() const { return m_runs; }</span>
<span class="udiff-line-added">+     bool isEmpty() const { return m_runs.isEmpty(); }</span>
<span class="udiff-line-added">+     bool hasTextContentOnly() const;</span>
<span class="udiff-line-added">+     bool isVisuallyEmptyWhitespaceContentOnly() const;</span>
<span class="udiff-line-added">+     bool hasNonContentRunsOnly() const;</span>
<span class="udiff-line-added">+     size_t size() const { return m_runs.size(); }</span>
<span class="udiff-line-added">+     InlineLayoutUnit width() const { return m_width; }</span>
<span class="udiff-line-added">+     InlineLayoutUnit nonCollapsibleWidth() const { return m_width - m_trailingCollapsibleContent.width; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bool hasTrailingCollapsibleContent() const { return !!m_trailingCollapsibleContent.width; }</span>
<span class="udiff-line-added">+     bool isTrailingContentFullyCollapsible() const { return m_trailingCollapsibleContent.isFullyCollapsible; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Optional&lt;size_t&gt; firstTextRunIndex() const;</span>
<span class="udiff-line-added">+     Optional&lt;size_t&gt; lastContentRunIndex() const;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ private:</span>
<span class="udiff-line-added">+     const LineBreaker::RunList&amp; m_runs;</span>
<span class="udiff-line-added">+     struct TrailingCollapsibleContent {</span>
<span class="udiff-line-added">+         void reset();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         bool isFullyCollapsible { false };</span>
<span class="udiff-line-added">+         InlineLayoutUnit width { 0 };</span>
<span class="udiff-line-added">+     };</span>
<span class="udiff-line-added">+     TrailingCollapsibleContent m_trailingCollapsibleContent;</span>
<span class="udiff-line-added">+     InlineLayoutUnit m_width { 0 };</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ struct WrappedTextContent {</span>
<span class="udiff-line-added">+     unsigned trailingRunIndex { 0 };</span>
<span class="udiff-line-added">+     bool contentOverflows { false };</span>
<span class="udiff-line-added">+     Optional&lt;LineBreaker::PartialRun&gt; partialTrailingRun;</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool LineBreaker::isContentWrappingAllowed(const ContinuousContent&amp; candidateRuns) const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     // Use the last inline item with content (where we would be wrapping) to decide if content wrapping is allowed.</span>
<span class="udiff-line-added">+     auto runIndex = candidateRuns.lastContentRunIndex().valueOr(candidateRuns.size() - 1);</span>
<span class="udiff-line-added">+     return isWrappingAllowed(candidateRuns.runs()[runIndex].inlineItem.style());</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool LineBreaker::shouldKeepEndOfLineWhitespace(const ContinuousContent&amp; candidateRuns) const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     // Grab the style and check for white-space property to decided whether we should let this whitespace content overflow the current line.</span>
<span class="udiff-line-added">+     // Note that the &quot;keep&quot; in the context means we let the whitespace content sit on the current line.</span>
<span class="udiff-line-added">+     // It might very well get collapsed when we close the line (normal/nowrap/pre-line).</span>
<span class="udiff-line-added">+     // See https://www.w3.org/TR/css-text-3/#white-space-property</span>
<span class="udiff-line-added">+     auto whitespace = candidateRuns.runs()[*candidateRuns.firstTextRunIndex()].inlineItem.style().whiteSpace();</span>
<span class="udiff-line-added">+     return whitespace == WhiteSpace::Normal || whitespace == WhiteSpace::NoWrap || whitespace == WhiteSpace::PreWrap || whitespace == WhiteSpace::PreLine;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ LineBreaker::Result LineBreaker::shouldWrapInlineContent(const RunList&amp; candidateRuns, InlineLayoutUnit candidateContentLogicalWidth, const LineStatus&amp; lineStatus)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     auto inlineContentWrapping = [&amp;] {</span>
<span class="udiff-line-added">+         if (candidateContentLogicalWidth &lt;= lineStatus.availableWidth)</span>
<span class="udiff-line-added">+             return Result { Result::Action::Keep };</span>
<span class="udiff-line-added">+ #if USE_FLOAT_AS_INLINE_LAYOUT_UNIT</span>
<span class="udiff-line-added">+         // Preferred width computation sums up floats while line breaker substracts them. This can lead to epsilon-scale differences.</span>
<span class="udiff-line-added">+         if (WTF::areEssentiallyEqual(candidateContentLogicalWidth, lineStatus.availableWidth))</span>
<span class="udiff-line-added">+             return Result { Result::Action::Keep };</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+         return tryWrappingInlineContent(candidateRuns, candidateContentLogicalWidth, lineStatus);</span>
<span class="udiff-line-added">+     };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto result = inlineContentWrapping();</span>
<span class="udiff-line-added">+     if (result.action == Result::Action::Keep) {</span>
<span class="udiff-line-added">+         // If this is not the end of the line, hold on to the last eligible line wrap opportunity so that we could revert back</span>
<span class="udiff-line-added">+         // to this position if no other line breaking opportunity exists in this content.</span>
<span class="udiff-line-added">+         if (auto lastLineWrapOpportunityIndex = lastWrapOpportunityIndex(candidateRuns)) {</span>
<span class="udiff-line-added">+             auto isEligibleLineWrapOpportunity = [&amp;] (auto&amp; candidateItem) {</span>
<span class="udiff-line-added">+                 // Just check for leading collapsible whitespace for now.</span>
<span class="udiff-line-added">+                 if (!lineStatus.lineIsEmpty || !candidateItem.isText() || !downcast&lt;InlineTextItem&gt;(candidateItem).isWhitespace())</span>
<span class="udiff-line-added">+                     return true;</span>
<span class="udiff-line-added">+                 return shouldKeepBeginningOfLineWhitespace(candidateItem.style());</span>
<span class="udiff-line-added">+             };</span>
<span class="udiff-line-added">+             auto&amp; inlineItem = candidateRuns[*lastLineWrapOpportunityIndex].inlineItem;</span>
<span class="udiff-line-added">+             if (isEligibleLineWrapOpportunity(inlineItem))</span>
<span class="udiff-line-added">+                 m_lastWrapOpportunity = &amp;inlineItem;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return result;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ LineBreaker::Result LineBreaker::tryWrappingInlineContent(const RunList&amp; candidateRuns, InlineLayoutUnit candidateContentLogicalWidth, const LineStatus&amp; lineStatus) const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     auto candidateContent = ContinuousContent { candidateRuns, candidateContentLogicalWidth };</span>
<span class="udiff-line-added">+     ASSERT(!candidateContent.isEmpty());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     ASSERT(candidateContent.width() &gt; lineStatus.availableWidth);</span>
<span class="udiff-line-added">+     if (candidateContent.hasTrailingCollapsibleContent()) {</span>
<span class="udiff-line-added">+         ASSERT(candidateContent.hasTextContentOnly());</span>
<span class="udiff-line-added">+         auto IsEndOfLine = isContentWrappingAllowed(candidateContent) ? IsEndOfLine::Yes : IsEndOfLine::No;</span>
<span class="udiff-line-added">+         // First check if the content fits without the trailing collapsible part.</span>
<span class="udiff-line-added">+         if (candidateContent.nonCollapsibleWidth() &lt;= lineStatus.availableWidth)</span>
<span class="udiff-line-added">+             return { Result::Action::Keep, IsEndOfLine };</span>
<span class="udiff-line-added">+         // Now check if we can trim the line too.</span>
<span class="udiff-line-added">+         if (lineStatus.lineHasFullyCollapsibleTrailingRun &amp;&amp; candidateContent.isTrailingContentFullyCollapsible()) {</span>
<span class="udiff-line-added">+             // If this new content is fully collapsible, it should surely fit.</span>
<span class="udiff-line-added">+             return { Result::Action::Keep, IsEndOfLine };</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     } else if (lineStatus.collapsibleWidth &amp;&amp; candidateContent.hasNonContentRunsOnly()) {</span>
<span class="udiff-line-added">+         // Let&#39;s see if the non-content runs fit when the line has trailing collapsible content.</span>
<span class="udiff-line-added">+         // &quot;text content &lt;span style=&quot;padding: 1px&quot;&gt;&lt;/span&gt;&quot; &lt;- the &lt;span&gt;&lt;/span&gt; runs could fit after collapsing the trailing whitespace.</span>
<span class="udiff-line-added">+         if (candidateContent.width() &lt;= lineStatus.availableWidth + lineStatus.collapsibleWidth)</span>
<span class="udiff-line-added">+             return { Result::Action::Keep };</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (candidateContent.isVisuallyEmptyWhitespaceContentOnly() &amp;&amp; shouldKeepEndOfLineWhitespace(candidateContent)) {</span>
<span class="udiff-line-added">+         // This overflowing content apparently falls into the remove/hang end-of-line-spaces category.</span>
<span class="udiff-line-added">+         // see https://www.w3.org/TR/css-text-3/#white-space-property matrix</span>
<span class="udiff-line-added">+         return { Result::Action::Keep };</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (candidateContent.hasTextContentOnly()) {</span>
<span class="udiff-line-added">+         auto&amp; runs = candidateContent.runs();</span>
<span class="udiff-line-added">+         if (auto wrappedTextContent = wrapTextContent(runs, lineStatus)) {</span>
<span class="udiff-line-added">+             if (!wrappedTextContent-&gt;trailingRunIndex &amp;&amp; wrappedTextContent-&gt;contentOverflows) {</span>
<span class="udiff-line-added">+                 // We tried to split the content but the available space can&#39;t even accommodate the first character.</span>
<span class="udiff-line-added">+                 // 1. Push the content over to the next line when we&#39;ve got content on the line already.</span>
<span class="udiff-line-added">+                 // 2. Keep the first character on the empty line (or keep the whole run if it has only one character).</span>
<span class="udiff-line-added">+                 if (!lineStatus.lineIsEmpty)</span>
<span class="udiff-line-added">+                     return { Result::Action::Push, IsEndOfLine::Yes, { } };</span>
<span class="udiff-line-added">+                 auto firstTextRunIndex = *candidateContent.firstTextRunIndex();</span>
<span class="udiff-line-added">+                 auto&amp; inlineTextItem = downcast&lt;InlineTextItem&gt;(runs[firstTextRunIndex].inlineItem);</span>
<span class="udiff-line-added">+                 ASSERT(inlineTextItem.length());</span>
<span class="udiff-line-added">+                 if (inlineTextItem.length() == 1)</span>
<span class="udiff-line-added">+                     return Result { Result::Action::Keep, IsEndOfLine::Yes };</span>
<span class="udiff-line-added">+                 auto firstCharacterWidth = TextUtil::width(inlineTextItem, inlineTextItem.start(), inlineTextItem.start() + 1);</span>
<span class="udiff-line-added">+                 auto firstCharacterRun = PartialRun { 1, firstCharacterWidth, false };</span>
<span class="udiff-line-added">+                 return { Result::Action::Split, IsEndOfLine::Yes, Result::PartialTrailingContent { firstTextRunIndex, firstCharacterRun } };</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             auto splitContent = Result::PartialTrailingContent { wrappedTextContent-&gt;trailingRunIndex, wrappedTextContent-&gt;partialTrailingRun };</span>
<span class="udiff-line-added">+             return { Result::Action::Split, IsEndOfLine::Yes, splitContent };</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     // If we are not allowed to break this overflowing content, we still need to decide whether keep it or push it to the next line.</span>
<span class="udiff-line-added">+     if (lineStatus.lineIsEmpty) {</span>
<span class="udiff-line-added">+         ASSERT(!m_lastWrapOpportunity);</span>
<span class="udiff-line-added">+         return { Result::Action::Keep, IsEndOfLine::No };</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     // Now either wrap here or at an earlier position, or not wrap at all.</span>
<span class="udiff-line-added">+     if (isContentWrappingAllowed(candidateContent))</span>
<span class="udiff-line-added">+         return { Result::Action::Push, IsEndOfLine::Yes };</span>
<span class="udiff-line-added">+     if (m_lastWrapOpportunity)</span>
<span class="udiff-line-added">+         return { Result::Action::Revert, IsEndOfLine::Yes, { }, m_lastWrapOpportunity };</span>
<span class="udiff-line-added">+     return { Result::Action::Keep, IsEndOfLine::No };</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-     if (inlineItem.isHardLineBreak())</span>
<span class="udiff-line-modified-removed">-         return { BreakingBehavior::Keep, isAtBreakingOpportunity(inlineItem) };</span>
<span class="udiff-line-modified-added">+ bool LineBreaker::shouldWrapFloatBox(InlineLayoutUnit floatLogicalWidth, InlineLayoutUnit availableWidth, bool lineIsEmpty)</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-added">+     return !lineIsEmpty &amp;&amp; floatLogicalWidth &gt; availableWidth;</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-     if (is&lt;InlineTextItem&gt;(inlineItem))</span>
<span class="udiff-line-modified-removed">-         return { wordBreakingBehavior(downcast&lt;InlineTextItem&gt;(inlineItem), lineContext.isEmpty), isAtBreakingOpportunity(inlineItem) };</span>
<span class="udiff-line-modified-added">+ Optional&lt;WrappedTextContent&gt; LineBreaker::wrapTextContent(const RunList&amp; runs, const LineStatus&amp; lineStatus) const</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-added">+     auto isContentSplitAllowed = [] (auto&amp; run) {</span>
<span class="udiff-line-added">+         ASSERT(run.inlineItem.isText() || run.inlineItem.isContainerStart() || run.inlineItem.isContainerEnd());</span>
<span class="udiff-line-added">+         if (!run.inlineItem.isText()) {</span>
<span class="udiff-line-added">+             // Can&#39;t split horizontal spacing -&gt; e.g. &lt;span style=&quot;padding-right: 100px;&quot;&gt;textcontent&lt;/span&gt;, if the [container end] is the overflown inline item</span>
<span class="udiff-line-added">+             // we need to check if there&#39;s another inline item beyond the [container end] to split.</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return isWrappingAllowed(run.inlineItem.style());</span>
<span class="udiff-line-added">+     };</span>
  
<span class="udiff-line-modified-removed">-     // Wrap non-text boxes to the next line unless we can trim trailing whitespace.</span>
<span class="udiff-line-modified-removed">-     auto availableWidth = lineContext.availableWidth + lineContext.trimmableWidth;</span>
<span class="udiff-line-modified-removed">-     if (logicalWidth &lt;= availableWidth)</span>
<span class="udiff-line-modified-removed">-         return { BreakingBehavior::Keep, isAtBreakingOpportunity(inlineItem) };</span>
<span class="udiff-line-modified-removed">-     return { BreakingBehavior::Wrap, isAtBreakingOpportunity(inlineItem) };</span>
<span class="udiff-line-modified-added">+     // Check where the overflow occurs and use the corresponding style to figure out the breaking behaviour.</span>
<span class="udiff-line-modified-added">+     // &lt;span style=&quot;word-break: normal&quot;&gt;first&lt;/span&gt;&lt;span style=&quot;word-break: break-all&quot;&gt;second&lt;/span&gt;&lt;span style=&quot;word-break: normal&quot;&gt;third&lt;/span&gt;</span>
<span class="udiff-line-modified-added">+     InlineLayoutUnit accumulatedRunWidth = 0;</span>
<span class="udiff-line-modified-added">+     unsigned index = 0;</span>
<span class="udiff-line-modified-added">+     while (index &lt; runs.size()) {</span>
<span class="udiff-line-added">+         auto&amp; run = runs[index];</span>
<span class="udiff-line-added">+         ASSERT(run.inlineItem.isText() || run.inlineItem.isContainerStart() || run.inlineItem.isContainerEnd());</span>
<span class="udiff-line-added">+         if (accumulatedRunWidth + run.logicalWidth &gt; lineStatus.availableWidth &amp;&amp; isContentSplitAllowed(run)) {</span>
<span class="udiff-line-added">+             // At this point the available width can very well be negative e.g. when some part of the continuous text content can not be broken into parts -&gt;</span>
<span class="udiff-line-added">+             // &lt;span style=&quot;word-break: keep-all&quot;&gt;textcontentwithnobreak&lt;/span&gt;&lt;span&gt;textcontentwithyesbreak&lt;/span&gt;</span>
<span class="udiff-line-added">+             // When the first span computes longer than the available space, by the time we get to the second span, the adjusted available space becomes negative.</span>
<span class="udiff-line-added">+             auto adjustedAvailableWidth = std::max&lt;InlineLayoutUnit&gt;(0, lineStatus.availableWidth - accumulatedRunWidth);</span>
<span class="udiff-line-added">+             if (auto partialRun = tryBreakingTextRun(run, adjustedAvailableWidth)) {</span>
<span class="udiff-line-added">+                  if (partialRun-&gt;length)</span>
<span class="udiff-line-added">+                      return WrappedTextContent { index, false, partialRun };</span>
<span class="udiff-line-added">+                  // When the content is wrapped at the run boundary, the trailing run is the previous run.</span>
<span class="udiff-line-added">+                  if (index)</span>
<span class="udiff-line-added">+                      return WrappedTextContent { index - 1, false, { } };</span>
<span class="udiff-line-added">+                  // Sometimes we can&#39;t accommodate even the very first character.</span>
<span class="udiff-line-added">+                  return WrappedTextContent { 0, true, { } };</span>
<span class="udiff-line-added">+              }</span>
<span class="udiff-line-added">+             // If this run is not breakable, we need to check if any previous run is breakable</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         accumulatedRunWidth += run.logicalWidth;</span>
<span class="udiff-line-added">+         ++index;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     // We did not manage to break the run that actually overflows the line.</span>
<span class="udiff-line-added">+     // Let&#39;s try to find the first breakable run and wrap it at the content boundary (as it surely fits).</span>
<span class="udiff-line-added">+     while (index--) {</span>
<span class="udiff-line-added">+         auto&amp; run = runs[index];</span>
<span class="udiff-line-added">+         if (isContentSplitAllowed(run)) {</span>
<span class="udiff-line-added">+             ASSERT(run.inlineItem.isText());</span>
<span class="udiff-line-added">+             if (auto partialRun = tryBreakingTextRun(run, maxInlineLayoutUnit())) {</span>
<span class="udiff-line-added">+                  // We know this run fits, so if wrapping is allowed on the run, it should return a non-empty left-side.</span>
<span class="udiff-line-added">+                  ASSERT(partialRun-&gt;length);</span>
<span class="udiff-line-added">+                  return WrappedTextContent { index, false, partialRun };</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     // Give up, there&#39;s no breakable run in here.</span>
<span class="udiff-line-added">+     return { };</span>
  }
  
<span class="udiff-line-modified-removed">- LineBreaker::BreakingBehavior LineBreaker::wordBreakingBehavior(const InlineTextItem&amp; inlineItem, bool lineIsEmpty) const</span>
<span class="udiff-line-modified-added">+ LineBreaker::WordBreakRule LineBreaker::wordBreakBehavior(const RenderStyle&amp; style) const</span>
  {
<span class="udiff-line-modified-removed">-     // Word breaking behaviour:</span>
<span class="udiff-line-modified-removed">-     // 1. Whitesapce collapse on -&gt; push whitespace to next line.</span>
<span class="udiff-line-modified-removed">-     // 2. Whitespace collapse off -&gt; whitespace is split where possible.</span>
<span class="udiff-line-modified-removed">-     // 3. Non-whitespace -&gt; first run on the line -&gt; either split or kept on the line. (depends on overflow-wrap)</span>
<span class="udiff-line-modified-removed">-     // 4. Non-whitespace -&gt; already content on the line -&gt; either gets split (word-break: break-all) or gets pushed to the next line.</span>
<span class="udiff-line-modified-removed">-     // (Hyphenate when possible)</span>
<span class="udiff-line-modified-removed">-     // 5. Non-text type -&gt; next line</span>
<span class="udiff-line-modified-removed">-     auto&amp; style = inlineItem.style();</span>
<span class="udiff-line-modified-added">+     // Disregard any prohibition against line breaks mandated by the word-break property.</span>
<span class="udiff-line-modified-added">+     // The different wrapping opportunities must not be prioritized. Hyphenation is not applied.</span>
<span class="udiff-line-modified-added">+     if (style.lineBreak() == LineBreak::Anywhere)</span>
<span class="udiff-line-modified-added">+         return WordBreakRule::AtArbitraryPosition;</span>
<span class="udiff-line-modified-added">+     // Breaking is allowed within “words”.</span>
<span class="udiff-line-modified-added">+     if (style.wordBreak() == WordBreak::BreakAll)</span>
<span class="udiff-line-modified-added">+         return WordBreakRule::AtArbitraryPosition;</span>
<span class="udiff-line-modified-added">+     // Breaking is forbidden within “words”.</span>
<span class="udiff-line-added">+     if (style.wordBreak() == WordBreak::KeepAll)</span>
<span class="udiff-line-added">+         return WordBreakRule::NoBreak;</span>
<span class="udiff-line-added">+     // For compatibility with legacy content, the word-break property also supports a deprecated break-word keyword.</span>
<span class="udiff-line-added">+     // When specified, this has the same effect as word-break: normal and overflow-wrap: anywhere, regardless of the actual value of the overflow-wrap property.</span>
<span class="udiff-line-added">+     if (style.wordBreak() == WordBreak::BreakWord &amp;&amp; !m_lastWrapOpportunity)</span>
<span class="udiff-line-added">+         return WordBreakRule::AtArbitraryPosition;</span>
<span class="udiff-line-added">+     // OverflowWrap::Break: An otherwise unbreakable sequence of characters may be broken at an arbitrary point if there are no otherwise-acceptable break points in the line.</span>
<span class="udiff-line-added">+     if (style.overflowWrap() == OverflowWrap::Break &amp;&amp; !m_lastWrapOpportunity)</span>
<span class="udiff-line-added">+         return WordBreakRule::AtArbitraryPosition;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (!n_hyphenationIsDisabled &amp;&amp; style.hyphens() == Hyphens::Auto &amp;&amp; canHyphenate(style.locale()))</span>
<span class="udiff-line-added">+         return WordBreakRule::OnlyHyphenationAllowed;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return WordBreakRule::NoBreak;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ Optional&lt;LineBreaker::PartialRun&gt; LineBreaker::tryBreakingTextRun(const Run&amp; overflowRun, InlineLayoutUnit availableWidth) const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     ASSERT(overflowRun.inlineItem.isText());</span>
<span class="udiff-line-added">+     auto&amp; inlineTextItem = downcast&lt;InlineTextItem&gt;(overflowRun.inlineItem);</span>
<span class="udiff-line-added">+     auto&amp; style = inlineTextItem.style();</span>
<span class="udiff-line-added">+     auto findLastBreakablePosition = availableWidth == maxInlineLayoutUnit();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto breakRule = wordBreakBehavior(style);</span>
<span class="udiff-line-added">+     if (breakRule == WordBreakRule::AtArbitraryPosition) {</span>
<span class="udiff-line-added">+         if (findLastBreakablePosition) {</span>
<span class="udiff-line-added">+             // When the run can be split at arbitrary position,</span>
<span class="udiff-line-added">+             // let&#39;s just return the entire run when it is intended to fit on the line.</span>
<span class="udiff-line-added">+             return PartialRun { inlineTextItem.length(), overflowRun.logicalWidth, false };</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         // FIXME: Pass in the content logical left to be able to measure tabs.</span>
<span class="udiff-line-added">+         auto splitData = TextUtil::split(inlineTextItem.layoutBox(), inlineTextItem.start(), inlineTextItem.length(), overflowRun.logicalWidth, availableWidth, { });</span>
<span class="udiff-line-added">+         return PartialRun { splitData.length, splitData.logicalWidth, false };</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (breakRule == WordBreakRule::OnlyHyphenationAllowed) {</span>
<span class="udiff-line-added">+         // Find the hyphen position as follows:</span>
<span class="udiff-line-added">+         // 1. Split the text by taking the hyphen width into account</span>
<span class="udiff-line-added">+         // 2. Find the last hyphen position before the split position</span>
<span class="udiff-line-added">+         auto runLength = inlineTextItem.length();</span>
<span class="udiff-line-added">+         unsigned limitBefore = style.hyphenationLimitBefore() == RenderStyle::initialHyphenationLimitBefore() ? 0 : style.hyphenationLimitBefore();</span>
<span class="udiff-line-added">+         unsigned limitAfter = style.hyphenationLimitAfter() == RenderStyle::initialHyphenationLimitAfter() ? 0 : style.hyphenationLimitAfter();</span>
<span class="udiff-line-added">+         // Check if this run can accommodate the before/after limits at all before start measuring text.</span>
<span class="udiff-line-added">+         if (limitBefore &gt;= runLength || limitAfter &gt;= runLength || limitBefore + limitAfter &gt; runLength)</span>
<span class="udiff-line-added">+             return { };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         unsigned leftSideLength = runLength;</span>
<span class="udiff-line-added">+         // FIXME: We might want to cache the hyphen width.</span>
<span class="udiff-line-added">+         auto&amp; fontCascade = style.fontCascade();</span>
<span class="udiff-line-added">+         auto hyphenWidth = InlineLayoutUnit { fontCascade.width(TextRun { StringView { style.hyphenString() } }) };</span>
<span class="udiff-line-added">+         if (!findLastBreakablePosition) {</span>
<span class="udiff-line-added">+             auto availableWidthExcludingHyphen = availableWidth - hyphenWidth;</span>
<span class="udiff-line-added">+             if (availableWidthExcludingHyphen &lt;= 0 || !enoughWidthForHyphenation(availableWidthExcludingHyphen, fontCascade.pixelSize()))</span>
<span class="udiff-line-added">+                 return { };</span>
<span class="udiff-line-added">+             leftSideLength = TextUtil::split(inlineTextItem.layoutBox(), inlineTextItem.start(), runLength, overflowRun.logicalWidth, availableWidthExcludingHyphen, { }).length;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (leftSideLength &lt; limitBefore)</span>
<span class="udiff-line-added">+             return { };</span>
<span class="udiff-line-added">+         auto textContent = inlineTextItem.layoutBox().textContext()-&gt;content;</span>
<span class="udiff-line-added">+         // Adjust before index to accommodate the limit-after value (it&#39;s the last potential hyphen location in this run).</span>
<span class="udiff-line-added">+         auto hyphenBefore = std::min(leftSideLength, runLength - limitAfter) + 1;</span>
<span class="udiff-line-added">+         unsigned hyphenLocation = lastHyphenLocation(StringView(textContent).substring(inlineTextItem.start(), inlineTextItem.length()), hyphenBefore, style.locale());</span>
<span class="udiff-line-added">+         if (!hyphenLocation || hyphenLocation &lt; limitBefore)</span>
<span class="udiff-line-added">+             return { };</span>
<span class="udiff-line-added">+         // hyphenLocation is relative to the start of this InlineItemText.</span>
<span class="udiff-line-added">+         auto trailingPartialRunWidthWithHyphen = TextUtil::width(inlineTextItem, inlineTextItem.start(), inlineTextItem.start() + hyphenLocation) + hyphenWidth;</span>
<span class="udiff-line-added">+         return PartialRun { hyphenLocation, trailingPartialRunWidthWithHyphen, true };</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     ASSERT(breakRule == WordBreakRule::NoBreak);</span>
<span class="udiff-line-added">+     return { };</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-     if (inlineItem.isWhitespace())</span>
<span class="udiff-line-modified-removed">-         return style.collapseWhiteSpace() ? BreakingBehavior::Wrap : BreakingBehavior::Split;</span>
<span class="udiff-line-modified-added">+ ContinuousContent::ContinuousContent(const LineBreaker::RunList&amp; runs, InlineLayoutUnit contentLogicalWidth)</span>
<span class="udiff-line-modified-added">+     : m_runs(runs)</span>
<span class="udiff-line-added">+     , m_width(contentLogicalWidth)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     // Figure out the trailing collapsible state.</span>
<span class="udiff-line-added">+     for (auto&amp; run : WTF::makeReversedRange(m_runs)) {</span>
<span class="udiff-line-added">+         auto&amp; inlineItem = run.inlineItem;</span>
<span class="udiff-line-added">+         if (inlineItem.isBox()) {</span>
<span class="udiff-line-added">+             // We did reach a non-collapsible content. We have all the trailing whitespace now.</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (inlineItem.isText()) {</span>
<span class="udiff-line-added">+             auto&amp; inlineTextItem = downcast&lt;InlineTextItem&gt;(inlineItem);</span>
<span class="udiff-line-added">+             auto isFullyCollapsible = [&amp;] {</span>
<span class="udiff-line-added">+                 return inlineTextItem.isWhitespace() &amp;&amp; !TextUtil::shouldPreserveTrailingWhitespace(inlineTextItem.style());</span>
<span class="udiff-line-added">+             };</span>
<span class="udiff-line-added">+             if (isFullyCollapsible()) {</span>
<span class="udiff-line-added">+                 m_trailingCollapsibleContent.width += run.logicalWidth;</span>
<span class="udiff-line-added">+                 m_trailingCollapsibleContent.isFullyCollapsible = true;</span>
<span class="udiff-line-added">+                 // Let&#39;s see if we&#39;ve got more trailing whitespace content.</span>
<span class="udiff-line-added">+                 continue;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             if (!RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled()) {</span>
<span class="udiff-line-added">+                 // A run with trailing letter spacing is partially collapsible.</span>
<span class="udiff-line-added">+                 if (auto collapsibleWidth = inlineTextItem.style().letterSpacing()) {</span>
<span class="udiff-line-added">+                     m_trailingCollapsibleContent.width += collapsibleWidth;</span>
<span class="udiff-line-added">+                     m_trailingCollapsibleContent.isFullyCollapsible = false;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             // End of whitespace content.</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-     auto shouldHypenate = !m_hyphenationIsDisabled &amp;&amp; style.hyphens() == Hyphens::Auto &amp;&amp; canHyphenate(style.locale());</span>
<span class="udiff-line-modified-removed">-     if (shouldHypenate)</span>
<span class="udiff-line-modified-removed">-         return BreakingBehavior::Split;</span>
<span class="udiff-line-modified-added">+ bool ContinuousContent::hasTextContentOnly() const</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-modified-added">+     // &lt;span&gt;text&lt;/span&gt; is considered a text run even with the [container start][container end] inline items.</span>
<span class="udiff-line-added">+     // Due to commit boundary rules, we just need to check the first non-typeless inline item (can&#39;t have both [img] and [text])</span>
<span class="udiff-line-added">+     for (auto&amp; run : m_runs) {</span>
<span class="udiff-line-added">+         auto&amp; inlineItem = run.inlineItem;</span>
<span class="udiff-line-added">+         if (inlineItem.isContainerStart() || inlineItem.isContainerEnd())</span>
<span class="udiff-line-added">+             continue;</span>
<span class="udiff-line-added">+         return inlineItem.isText();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-     if (style.autoWrap()) {</span>
<span class="udiff-line-modified-removed">-         // Break any word</span>
<span class="udiff-line-modified-removed">-         if (style.wordBreak() == WordBreak::BreakAll)</span>
<span class="udiff-line-modified-removed">-             return BreakingBehavior::Split;</span>
<span class="udiff-line-modified-added">+ bool ContinuousContent::isVisuallyEmptyWhitespaceContentOnly() const</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-modified-added">+     // [&lt;span&gt;&lt;/span&gt; ] [&lt;span&gt; &lt;/span&gt;] [ &lt;span style=&quot;padding: 0px;&quot;&gt;&lt;/span&gt;] are all considered visually empty whitespace content.</span>
<span class="udiff-line-modified-added">+     // [&lt;span style=&quot;border: 1px solid red&quot;&gt;&lt;/span&gt; ] while this is whitespace content only, it is not considered visually empty.</span>
<span class="udiff-line-added">+     // Due to commit boundary rules, we just need to check the first non-typeless inline item (can&#39;t have both [img] and [text])</span>
<span class="udiff-line-added">+     for (auto&amp; run : m_runs) {</span>
<span class="udiff-line-added">+         auto&amp; inlineItem = run.inlineItem;</span>
<span class="udiff-line-added">+         // FIXME: check for padding border etc.</span>
<span class="udiff-line-added">+         if (inlineItem.isContainerStart() || inlineItem.isContainerEnd())</span>
<span class="udiff-line-added">+             continue;</span>
<span class="udiff-line-added">+         return inlineItem.isText() &amp;&amp; downcast&lt;InlineTextItem&gt;(inlineItem).isWhitespace();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-         // Break first run on line.</span>
<span class="udiff-line-modified-removed">-         if (lineIsEmpty &amp;&amp; style.breakWords() &amp;&amp; style.preserveNewline())</span>
<span class="udiff-line-modified-removed">-             return BreakingBehavior::Split;</span>
<span class="udiff-line-modified-added">+ Optional&lt;size_t&gt; ContinuousContent::firstTextRunIndex() const</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-modified-added">+     for (size_t index = 0; index &lt; m_runs.size(); ++index) {</span>
<span class="udiff-line-added">+         if (m_runs[index].inlineItem.isText())</span>
<span class="udiff-line-added">+             return index;</span>
      }
<span class="udiff-line-added">+     return { };</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-     // Non-breakable non-whitespace run.</span>
<span class="udiff-line-modified-removed">-     return lineIsEmpty ? BreakingBehavior::Keep : BreakingBehavior::Wrap;</span>
<span class="udiff-line-modified-added">+ Optional&lt;size_t&gt; ContinuousContent::lastContentRunIndex() const</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-added">+     for (size_t index = m_runs.size(); index--;) {</span>
<span class="udiff-line-added">+         if (m_runs[index].inlineItem.isText() || m_runs[index].inlineItem.isBox())</span>
<span class="udiff-line-added">+             return index;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return { };</span>
  }
  
<span class="udiff-line-modified-removed">- bool LineBreaker::isAtBreakingOpportunity(const InlineItem&amp; inlineItem)</span>
<span class="udiff-line-modified-added">+ bool ContinuousContent::hasNonContentRunsOnly() const</span>
  {
<span class="udiff-line-modified-removed">-     if (inlineItem.isHardLineBreak())</span>
<span class="udiff-line-modified-removed">-         return true;</span>
<span class="udiff-line-modified-added">+     // &lt;span&gt;&lt;/span&gt; &lt;- non content runs.</span>
<span class="udiff-line-modified-added">+     for (auto&amp; run : m_runs) {</span>
<span class="udiff-line-added">+         auto&amp; inlineItem = run.inlineItem;</span>
<span class="udiff-line-added">+         if (inlineItem.isContainerStart() || inlineItem.isContainerEnd())</span>
<span class="udiff-line-added">+             continue;</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-     if (is&lt;InlineTextItem&gt;(inlineItem))</span>
<span class="udiff-line-modified-removed">-         return downcast&lt;InlineTextItem&gt;(inlineItem).isWhitespace();</span>
<span class="udiff-line-modified-removed">-     return !inlineItem.isFloat() &amp;&amp; !inlineItem.isContainerStart() &amp;&amp; !inlineItem.isContainerEnd();</span>
<span class="udiff-line-modified-added">+ void ContinuousContent::TrailingCollapsibleContent::reset()</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-modified-added">+     isFullyCollapsible = false;</span>
<span class="udiff-line-added">+     width = 0_lu;</span>
  }
  
  }
  }
  #endif
</pre>
<center><a href="InlineItem.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InlineLineBreaker.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
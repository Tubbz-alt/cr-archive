<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/EventHandler.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="EditorClient.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EventHandler.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/EventHandler.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2006 Alexey Proskuryakov (ap@webkit.org)
   4  * Copyright (C) 2012 Digia Plc. and/or its subsidiary(-ies)
   5  *
   6  * Redistribution and use in source and binary forms, with or without
   7  * modification, are permitted provided that the following conditions
   8  * are met:
   9  * 1. Redistributions of source code must retain the above copyright
  10  *    notice, this list of conditions and the following disclaimer.
  11  * 2. Redistributions in binary form must reproduce the above copyright
  12  *    notice, this list of conditions and the following disclaimer in the
  13  *    documentation and/or other materials provided with the distribution.
  14  *
  15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  26  */
  27 
  28 #include &quot;config.h&quot;
  29 #include &quot;EventHandler.h&quot;
  30 
  31 #include &quot;AutoscrollController.h&quot;
  32 #include &quot;BackForwardController.h&quot;
  33 #include &quot;CachedImage.h&quot;
  34 #include &quot;Chrome.h&quot;
  35 #include &quot;ChromeClient.h&quot;
  36 #include &quot;ComposedTreeAncestorIterator.h&quot;

  37 #include &quot;CursorList.h&quot;
  38 #include &quot;DocumentMarkerController.h&quot;
  39 #include &quot;DragController.h&quot;

  40 #include &quot;DragState.h&quot;
  41 #include &quot;Editing.h&quot;
  42 #include &quot;Editor.h&quot;
  43 #include &quot;EditorClient.h&quot;
  44 #include &quot;EventNames.h&quot;
  45 #include &quot;FileList.h&quot;
  46 #include &quot;FloatPoint.h&quot;
  47 #include &quot;FloatRect.h&quot;
  48 #include &quot;FocusController.h&quot;
  49 #include &quot;Frame.h&quot;
  50 #include &quot;FrameLoader.h&quot;
  51 #include &quot;FrameSelection.h&quot;
  52 #include &quot;FrameTree.h&quot;
  53 #include &quot;FrameView.h&quot;
  54 #include &quot;FullscreenManager.h&quot;
  55 #include &quot;HTMLDocument.h&quot;
  56 #include &quot;HTMLFrameElement.h&quot;
  57 #include &quot;HTMLFrameSetElement.h&quot;
  58 #include &quot;HTMLHtmlElement.h&quot;
  59 #include &quot;HTMLIFrameElement.h&quot;
</pre>
<hr />
<pre>
 110 #include &quot;PlatformTouchEventIOS.h&quot;
 111 #endif
 112 
 113 #if ENABLE(TOUCH_EVENTS)
 114 #include &quot;TouchEvent.h&quot;
 115 #include &quot;TouchList.h&quot;
 116 #endif
 117 
 118 #if ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
 119 #include &quot;PlatformTouchEvent.h&quot;
 120 #endif
 121 
 122 #if ENABLE(MAC_GESTURE_EVENTS)
 123 #include &quot;PlatformGestureEventMac.h&quot;
 124 #endif
 125 
 126 #if ENABLE(POINTER_LOCK)
 127 #include &quot;PointerLockController.h&quot;
 128 #endif
 129 
<span class="line-removed"> 130 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-removed"> 131 #include &quot;RuntimeEnabledFeatures.h&quot;</span>
<span class="line-removed"> 132 #endif</span>
<span class="line-removed"> 133 </span>
 134 #if PLATFORM(IOS_FAMILY)
 135 #include &quot;DOMTimerHoldingTank.h&quot;
 136 #endif
 137 
 138 namespace WebCore {
 139 
 140 using namespace HTMLNames;
 141 
 142 #if ENABLE(DRAG_SUPPORT)
 143 // The link drag hysteresis is much larger than the others because there
 144 // needs to be enough space to cancel the link press without starting a link drag,
 145 // and because dragging links is rare.
 146 const int LinkDragHysteresis = 40;
 147 const int ImageDragHysteresis = 5;
 148 const int TextDragHysteresis = 3;
 149 const int ColorDragHystersis = 3;
 150 const int GeneralDragHysteresis = 3;
 151 #if PLATFORM(MAC)
 152 const Seconds EventHandler::TextDragDelay { 150_ms };
 153 #else
</pre>
<hr />
<pre>
 162 #if ENABLE(IOS_TOUCH_EVENTS)
 163 // FIXME: Share this constant with EventHandler and SliderThumbElement.
 164 const unsigned InvalidTouchIdentifier = 0;
 165 #endif
 166 
 167 // Match key code of composition keydown event on windows.
 168 // IE sends VK_PROCESSKEY which has value 229;
 169 const int CompositionEventKeyCode = 229;
 170 
 171 using namespace SVGNames;
 172 
 173 #if !ENABLE(IOS_TOUCH_EVENTS)
 174 // The amount of time to wait before sending a fake mouse event, triggered
 175 // during a scroll. The short interval is used if the content responds to the mouse events
 176 // in fakeMouseMoveDurationThreshold or less, otherwise the long interval is used.
 177 const double fakeMouseMoveDurationThreshold = 0.01;
 178 const Seconds fakeMouseMoveShortInterval = { 100_ms };
 179 const Seconds fakeMouseMoveLongInterval = { 250_ms };
 180 #endif
 181 
<span class="line-removed"> 182 #if ENABLE(CURSOR_SUPPORT)</span>
 183 // The amount of time to wait for a cursor update on style and layout changes
 184 // Set to 50Hz, no need to be faster than common screen refresh rate
 185 static const Seconds cursorUpdateInterval { 20_ms };
 186 
 187 const int maximumCursorSize = 128;
<span class="line-removed"> 188 #endif</span>
 189 
 190 #if ENABLE(MOUSE_CURSOR_SCALE)
 191 // It&#39;s pretty unlikely that a scale of less than one would ever be used. But all we really
 192 // need to ensure here is that the scale isn&#39;t so small that integer overflow can occur when
 193 // dividing cursor sizes (limited above) by the scale.
 194 const double minimumCursorScale = 0.001;
 195 #endif
 196 
 197 class MaximumDurationTracker {
 198 public:
 199     explicit MaximumDurationTracker(double *maxDuration)
 200         : m_maxDuration(maxDuration)
 201         , m_start(MonotonicTime::now())
 202     {
 203     }
 204 
 205     ~MaximumDurationTracker()
 206     {
 207         *m_maxDuration = std::max(*m_maxDuration, (MonotonicTime::now() - m_start).seconds());
 208     }
 209 
 210 private:
 211     double* m_maxDuration;
 212     MonotonicTime m_start;
 213 };
 214 
 215 #if ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
 216 class SyntheticTouchPoint : public PlatformTouchPoint {
 217 public:
 218 
 219     // The default values are based on http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html
 220     explicit SyntheticTouchPoint(const PlatformMouseEvent&amp; event)
 221     {
<span class="line-modified"> 222         const static int idDefaultValue = 0;</span>
<span class="line-modified"> 223         const static int radiusYDefaultValue = 1;</span>
<span class="line-modified"> 224         const static int radiusXDefaultValue = 1;</span>
<span class="line-modified"> 225         const static float rotationAngleDefaultValue = 0.0f;</span>
<span class="line-modified"> 226         const static float forceDefaultValue = 1.0f;</span>
 227 
 228         m_id = idDefaultValue; // There is only one active TouchPoint.
 229         m_screenPos = event.globalPosition();
 230         m_pos = event.position();
 231         m_radiusY = radiusYDefaultValue;
 232         m_radiusX = radiusXDefaultValue;
 233         m_rotationAngle = rotationAngleDefaultValue;
 234         m_force = forceDefaultValue;
 235 
 236         PlatformEvent::Type type = event.type();
 237         ASSERT(type == PlatformEvent::MouseMoved || type == PlatformEvent::MousePressed || type == PlatformEvent::MouseReleased);
 238 
 239         switch (type) {
 240         case PlatformEvent::MouseMoved:
 241             m_state = TouchMoved;
 242             break;
 243         case PlatformEvent::MousePressed:
 244             m_state = TouchPressed;
 245             break;
 246         case PlatformEvent::MouseReleased:
</pre>
<hr />
<pre>
 289     case WheelEvent::DOM_DELTA_PIXEL:
 290         return ScrollByPixel;
 291     default:
 292         return ScrollByPixel;
 293     }
 294 }
 295 
 296 static inline bool didScrollInScrollableArea(ScrollableArea* scrollableArea, WheelEvent&amp; wheelEvent)
 297 {
 298     ScrollGranularity scrollGranularity = wheelGranularityToScrollGranularity(wheelEvent.deltaMode());
 299     bool didHandleWheelEvent = false;
 300     if (float absoluteDelta = std::abs(wheelEvent.deltaX()))
 301         didHandleWheelEvent |= scrollableArea-&gt;scroll(wheelEvent.deltaX() &gt; 0 ? ScrollRight : ScrollLeft, scrollGranularity, absoluteDelta);
 302 
 303     if (float absoluteDelta = std::abs(wheelEvent.deltaY()))
 304         didHandleWheelEvent |= scrollableArea-&gt;scroll(wheelEvent.deltaY() &gt; 0 ? ScrollDown : ScrollUp, scrollGranularity, absoluteDelta);
 305 
 306     return didHandleWheelEvent;
 307 }
 308 
<span class="line-modified"> 309 static inline bool handleWheelEventInAppropriateEnclosingBox(Node* startNode, WheelEvent&amp; wheelEvent, Element** stopElement, const FloatSize&amp; filteredPlatformDelta, const FloatSize&amp; filteredVelocity)</span>
 310 {
 311     bool shouldHandleEvent = wheelEvent.deltaX() || wheelEvent.deltaY();
 312 #if PLATFORM(MAC)
 313     shouldHandleEvent |= wheelEvent.phase() == PlatformWheelEventPhaseEnded;
 314 #if ENABLE(CSS_SCROLL_SNAP)
 315     shouldHandleEvent |= wheelEvent.momentumPhase() == PlatformWheelEventPhaseEnded;
 316 #endif
 317 #endif
 318     if (!startNode-&gt;renderer() || !shouldHandleEvent)
 319         return false;
 320 
 321     RenderBox&amp; initialEnclosingBox = startNode-&gt;renderer()-&gt;enclosingBox();
 322     if (initialEnclosingBox.isListBox())
 323         return didScrollInScrollableArea(static_cast&lt;RenderListBox*&gt;(&amp;initialEnclosingBox), wheelEvent);
 324 
 325     RenderBox* currentEnclosingBox = &amp;initialEnclosingBox;
 326     while (currentEnclosingBox) {
 327         if (RenderLayer* boxLayer = currentEnclosingBox-&gt;layer()) {
 328             auto platformEvent = wheelEvent.underlyingPlatformEvent();
 329             bool scrollingWasHandled;
 330             if (platformEvent) {
 331                 auto copiedEvent = platformEvent-&gt;copyWithDeltasAndVelocity(filteredPlatformDelta.width(), filteredPlatformDelta.height(), filteredVelocity);
 332                 scrollingWasHandled = boxLayer-&gt;handleWheelEvent(copiedEvent);
 333             } else
 334                 scrollingWasHandled = didScrollInScrollableArea(boxLayer, wheelEvent);
 335 
 336             if (scrollingWasHandled) {
<span class="line-modified"> 337                 if (stopElement)</span>
<span class="line-removed"> 338                     *stopElement = currentEnclosingBox-&gt;element();</span>
 339                 return true;
 340             }
 341         }
 342 
<span class="line-modified"> 343         if (stopElement &amp;&amp; *stopElement &amp;&amp; *stopElement == currentEnclosingBox-&gt;element())</span>
 344             return true;
 345 
 346         currentEnclosingBox = currentEnclosingBox-&gt;containingBlock();
 347         if (!currentEnclosingBox || currentEnclosingBox-&gt;isRenderView())
 348             return false;
 349     }
 350     return false;
 351 }
 352 
 353 #if (ENABLE(TOUCH_EVENTS) &amp;&amp; !PLATFORM(IOS_FAMILY))
 354 static inline bool shouldGesturesTriggerActive()
 355 {
 356     // If the platform we&#39;re on supports GestureTapDown and GestureTapCancel then we&#39;ll
 357     // rely on them to set the active state. Unfortunately there&#39;s no generic way to
 358     // know in advance what event types are supported.
 359     return false;
 360 }
 361 #endif
 362 
 363 #if !PLATFORM(COCOA)
 364 
 365 inline bool EventHandler::eventLoopHandleMouseUp(const MouseEventWithHitTestResults&amp;)
 366 {
 367     return false;
 368 }
 369 
 370 #if ENABLE(DRAG_SUPPORT)
 371 inline bool EventHandler::eventLoopHandleMouseDragged(const MouseEventWithHitTestResults&amp;)
 372 {
 373     return false;
 374 }
 375 #endif
 376 
 377 #endif
 378 
 379 EventHandler::EventHandler(Frame&amp; frame)
 380     : m_frame(frame)
 381     , m_hoverTimer(*this, &amp;EventHandler::hoverTimerFired)
<span class="line-removed"> 382 #if ENABLE(CURSOR_SUPPORT)</span>
 383     , m_cursorUpdateTimer(*this, &amp;EventHandler::cursorUpdateTimerFired)
<span class="line-removed"> 384 #endif</span>
 385 #if PLATFORM(MAC)
 386     , m_pendingMomentumWheelEventsTimer(*this, &amp;EventHandler::clearLatchedState)
 387 #endif
 388     , m_autoscrollController(makeUnique&lt;AutoscrollController&gt;())
 389 #if !ENABLE(IOS_TOUCH_EVENTS)
 390     , m_fakeMouseMoveEventTimer(*this, &amp;EventHandler::fakeMouseMoveEventTimerFired)
 391 #endif
 392 #if ENABLE(CURSOR_VISIBILITY)
 393     , m_autoHideCursorTimer(*this, &amp;EventHandler::autoHideCursorTimerFired)
 394 #endif
 395 {
 396 }
 397 
 398 EventHandler::~EventHandler()
 399 {
 400 #if !ENABLE(IOS_TOUCH_EVENTS)
 401     ASSERT(!m_fakeMouseMoveEventTimer.isActive());
 402 #endif
 403 #if ENABLE(CURSOR_VISIBILITY)
 404     ASSERT(!m_autoHideCursorTimer.isActive());
 405 #endif
 406 }
 407 
 408 #if ENABLE(DRAG_SUPPORT)
 409 
 410 DragState&amp; EventHandler::dragState()
 411 {
 412     static NeverDestroyed&lt;DragState&gt; state;
 413     return state;
 414 }
 415 
 416 #endif
 417 
 418 void EventHandler::clear()
 419 {
 420     m_hoverTimer.stop();
<span class="line-removed"> 421 #if ENABLE(CURSOR_SUPPORT)</span>
 422     m_cursorUpdateTimer.stop();
<span class="line-removed"> 423 #endif</span>
 424 #if !ENABLE(IOS_TOUCH_EVENTS)
 425     m_fakeMouseMoveEventTimer.stop();
 426 #endif
 427 #if ENABLE(CURSOR_VISIBILITY)
 428     cancelAutoHideCursorTimer();
 429 #endif
 430     m_resizeLayer = nullptr;
 431     m_elementUnderMouse = nullptr;
 432     m_lastElementUnderMouse = nullptr;
 433     m_lastMouseMoveEventSubframe = nullptr;
 434     m_lastScrollbarUnderMouse = nullptr;
 435     m_clickCount = 0;
 436     m_clickNode = nullptr;
 437 #if ENABLE(IOS_GESTURE_EVENTS)
 438     m_gestureInitialDiameter = GestureUnknown;
 439     m_gestureInitialRotation = GestureUnknown;
 440 #endif
 441 #if ENABLE(IOS_GESTURE_EVENTS) || ENABLE(MAC_GESTURE_EVENTS)
 442     m_gestureLastDiameter = GestureUnknown;
 443     m_gestureLastRotation = GestureUnknown;
</pre>
<hr />
<pre>
 723                 newSelection = VisibleSelection(start, pos);
 724         } else
 725             newSelection.setExtent(pos);
 726 
 727         if (m_frame.selection().granularity() != CharacterGranularity) {
 728             granularity = m_frame.selection().granularity();
 729             newSelection.expandUsingGranularity(m_frame.selection().granularity());
 730         }
 731     } else
 732         newSelection = expandSelectionToRespectSelectOnMouseDown(*targetNode, visiblePos);
 733 
 734     bool handled = updateSelectionForMouseDownDispatchingSelectStart(targetNode, newSelection, granularity);
 735 
 736     if (event.event().button() == MiddleButton) {
 737         // Ignore handled, since we want to paste to where the caret was placed anyway.
 738         handled = handlePasteGlobalSelection(event.event()) || handled;
 739     }
 740     return handled;
 741 }
 742 
<span class="line-modified"> 743 static inline bool canMouseDownStartSelect(Node* node)</span>
 744 {







 745     if (!node || !node-&gt;renderer())
 746         return true;
 747 
 748     return node-&gt;canStartSelection() || Position::nodeIsUserSelectAll(node);
 749 }
 750 
 751 bool EventHandler::handleMousePressEvent(const MouseEventWithHitTestResults&amp; event)
 752 {
 753     Ref&lt;Frame&gt; protectedFrame(m_frame);
 754 
 755 #if ENABLE(DRAG_SUPPORT)
 756     // Reset drag state.
 757     dragState().source = nullptr;
 758 #endif
 759 
 760 #if !ENABLE(IOS_TOUCH_EVENTS)
 761     cancelFakeMouseMoveEvent();
 762 #endif
 763 
 764     m_frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
 765 
 766     if (ScrollView* scrollView = m_frame.view()) {
 767         if (scrollView-&gt;isPointInScrollbarCorner(event.event().position()))
 768             return false;
 769     }
 770 
 771     bool singleClick = event.event().clickCount() &lt;= 1;
 772 
 773     // If we got the event back, that must mean it wasn&#39;t prevented,
 774     // so it&#39;s allowed to start a drag or selection if it wasn&#39;t in a scrollbar.
<span class="line-modified"> 775     m_mouseDownMayStartSelect = canMouseDownStartSelect(event.targetNode()) &amp;&amp; !event.scrollbar();</span>
 776 
 777 #if ENABLE(DRAG_SUPPORT)
 778     // Careful that the drag starting logic stays in sync with eventMayStartDrag()
 779     // FIXME: eventMayStartDrag() does not check for shift key press, link or image event targets.
 780     // Bug: https://bugs.webkit.org/show_bug.cgi?id=155390
 781 
 782     // Single mouse down on links or images can always trigger drag-n-drop.
 783     bool isMouseDownOnLinkOrImage = event.isOverLink() || event.hitTestResult().image();
 784     m_mouseDownMayStartDrag = singleClick &amp;&amp; (!event.event().shiftKey() || isMouseDownOnLinkOrImage) &amp;&amp; shouldAllowMouseDownToStartDrag();
 785 #endif
 786 
 787     m_mouseDownWasSingleClickInSelection = false;
 788 
 789     m_mouseDown = event.event();
 790 
 791     if (m_immediateActionStage != ImmediateActionStage::PerformedHitTest)
 792         m_immediateActionStage = ImmediateActionStage::None;
 793 
 794     if (event.isOverWidget() &amp;&amp; passWidgetMouseDownEventToWidget(event))
 795         return true;
</pre>
<hr />
<pre>
1326         return 0;
1327     return subframeForTargetNode(hitTestResult.targetNode());
1328 }
1329 
1330 Frame* EventHandler::subframeForTargetNode(Node* node)
1331 {
1332     if (!node)
1333         return nullptr;
1334 
1335     auto renderer = node-&gt;renderer();
1336     if (!is&lt;RenderWidget&gt;(renderer))
1337         return nullptr;
1338 
1339     Widget* widget = downcast&lt;RenderWidget&gt;(*renderer).widget();
1340     if (!is&lt;FrameView&gt;(widget))
1341         return nullptr;
1342 
1343     return &amp;downcast&lt;FrameView&gt;(*widget).frame();
1344 }
1345 
<span class="line-removed">1346 #if ENABLE(CURSOR_SUPPORT)</span>
1347 static bool isSubmitImage(Node* node)
1348 {
1349     return is&lt;HTMLInputElement&gt;(node) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*node).isImageButton();
1350 }
1351 
1352 // Returns true if the node&#39;s editable block is not current focused for editing
1353 static bool nodeIsNotBeingEdited(const Node&amp; node, const Frame&amp; frame)
1354 {
1355     return frame.selection().selection().rootEditableElement() != node.rootEditableElement();
1356 }
1357 
1358 bool EventHandler::useHandCursor(Node* node, bool isOverLink, bool shiftKey)
1359 {
1360     if (!node)
1361         return false;
1362 
1363     bool editable = node-&gt;hasEditableStyle();
1364     bool editableLinkEnabled = false;
1365 
1366     // If the link is editable, then we need to check the settings to see whether or not the link should be followed
</pre>
<hr />
<pre>
1383         case EditableLinkOnlyLiveWithShiftKey:
1384             editableLinkEnabled = shiftKey;
1385             break;
1386         }
1387     }
1388 
1389     return ((isOverLink || isSubmitImage(node)) &amp;&amp; (!editable || editableLinkEnabled));
1390 }
1391 
1392 void EventHandler::cursorUpdateTimerFired()
1393 {
1394     ASSERT(m_frame.document());
1395     updateCursor();
1396 }
1397 
1398 void EventHandler::updateCursor()
1399 {
1400     if (m_mousePositionIsUnknown)
1401         return;
1402 





1403     FrameView* view = m_frame.view();
1404     if (!view)
1405         return;
1406 
1407     auto* document = m_frame.document();
1408     if (!document)
1409         return;
1410 
1411     if (!view-&gt;shouldSetCursor())
1412         return;
1413 
1414     bool shiftKey;
1415     bool ctrlKey;
1416     bool altKey;
1417     bool metaKey;
1418     PlatformKeyboardEvent::getCurrentModifierState(shiftKey, ctrlKey, altKey, metaKey);
1419 
1420     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::AllowFrameScrollbars);
1421     HitTestResult result(view-&gt;windowToContents(m_lastKnownMousePosition));
1422     document-&gt;hitTest(request, result);
</pre>
<hr />
<pre>
1603         return eastWestResizeCursor();
1604     case CursorType::NSResize:
1605         return northSouthResizeCursor();
1606     case CursorType::NESWResize:
1607         return northEastSouthWestResizeCursor();
1608     case CursorType::NWSEResize:
1609         return northWestSouthEastResizeCursor();
1610     case CursorType::ColumnResize:
1611         return columnResizeCursor();
1612     case CursorType::RowResize:
1613         return rowResizeCursor();
1614     case CursorType::AllScroll:
1615         return moveCursor();
1616     case CursorType::ZoomIn:
1617         return zoomInCursor();
1618     case CursorType::ZoomOut:
1619         return zoomOutCursor();
1620     }
1621     return pointerCursor();
1622 }
<span class="line-removed">1623 #endif // ENABLE(CURSOR_SUPPORT)</span>
1624 
1625 #if ENABLE(CURSOR_VISIBILITY)
1626 void EventHandler::startAutoHideCursorTimer()
1627 {
1628     Page* page = m_frame.page();
1629     if (!page)
1630         return;
1631 
1632     m_autoHideCursorTimer.startOneShot(page-&gt;settings().timeWithoutMouseMovementBeforeHidingControls());
1633 
1634 #if !ENABLE(IOS_TOUCH_EVENTS)
1635     // The fake mouse move event screws up the auto-hide feature (by resetting the auto-hide timer)
1636     // so cancel any pending fake mouse moves.
1637     if (m_fakeMouseMoveEventTimer.isActive())
1638         m_fakeMouseMoveEventTimer.stop();
1639 #endif
1640 }
1641 
1642 void EventHandler::cancelAutoHideCursorTimer()
1643 {
</pre>
<hr />
<pre>
1897 
1898     HitTestResult hoveredNode = HitTestResult(LayoutPoint());
1899     bool result = handleMouseMoveEvent(event, &amp;hoveredNode);
1900 
1901     Page* page = m_frame.page();
1902     if (!page)
1903         return result;
1904 
1905     if (auto scrolledArea = enclosingScrollableArea(hoveredNode.innerNode())) {
1906         if (FrameView* frameView = m_frame.view()) {
1907             if (frameView-&gt;containsScrollableArea(scrolledArea))
1908                 scrolledArea-&gt;mouseMovedInContentArea();
1909         }
1910     }
1911 
1912     if (FrameView* frameView = m_frame.view())
1913         frameView-&gt;mouseMovedInContentArea();
1914 
1915     hoveredNode.setToNonUserAgentShadowAncestor();
1916     page-&gt;chrome().mouseDidMoveOverElement(hoveredNode, event.modifierFlags());
<span class="line-removed">1917     page-&gt;chrome().setToolTip(hoveredNode);</span>
1918     return result;
1919 }
1920 
1921 bool EventHandler::passMouseMovedEventToScrollbars(const PlatformMouseEvent&amp; event)
1922 {
1923     HitTestResult hoveredNode;
1924     return handleMouseMoveEvent(event, &amp;hoveredNode, true);
1925 }
1926 
1927 bool EventHandler::handleMouseMoveEvent(const PlatformMouseEvent&amp; platformMouseEvent, HitTestResult* hoveredNode, bool onlyUpdateScrollbars)
1928 {
1929 #if ENABLE(TOUCH_EVENTS)
1930     bool defaultPrevented = dispatchSyntheticTouchEventIfEnabled(platformMouseEvent);
1931     if (defaultPrevented)
1932         return true;
1933 #endif
1934 
1935     Ref&lt;Frame&gt; protectedFrame(m_frame);
1936     RefPtr&lt;FrameView&gt; protector(m_frame.view());
1937 
1938 #if ENABLE(POINTER_LOCK)
1939     if (m_frame.page()-&gt;pointerLockController().isLocked()) {
1940         m_frame.page()-&gt;pointerLockController().dispatchLockedMouseEvent(platformMouseEvent, eventNames().mousemoveEvent);
1941         return true;
1942     }
1943 #endif
1944 
1945     setLastKnownMousePosition(platformMouseEvent);
1946 
1947     if (m_hoverTimer.isActive())
1948         m_hoverTimer.stop();
1949 
<span class="line-removed">1950 #if ENABLE(CURSOR_SUPPORT)</span>
1951     m_cursorUpdateTimer.stop();
<span class="line-removed">1952 #endif</span>
1953 
1954 #if !ENABLE(IOS_TOUCH_EVENTS)
1955     cancelFakeMouseMoveEvent();
1956 #endif
1957 
1958     if (m_svgPan) {
1959         downcast&lt;SVGDocument&gt;(*m_frame.document()).updatePan(m_frame.view()-&gt;windowToContents(m_lastKnownMousePosition));
1960         return true;
1961     }
1962 
1963     if (m_frameSetBeingResized)
1964         return !dispatchMouseEvent(eventNames().mousemoveEvent, m_frameSetBeingResized.get(), false, 0, platformMouseEvent, false);
1965 
1966     // On iOS, our scrollbars are managed by UIKit.
1967 #if !PLATFORM(IOS_FAMILY)
1968     // Send events right to a scrollbar if the mouse is pressed.
1969     if (m_lastScrollbarUnderMouse &amp;&amp; m_mousePressed)
1970         return m_lastScrollbarUnderMouse-&gt;mouseMoved(platformMouseEvent);
1971 #endif
1972 
</pre>
<hr />
<pre>
2011     }
2012 
2013     bool swallowEvent = false;
2014     RefPtr&lt;Frame&gt; newSubframe = m_capturingMouseEventsElement.get() ? subframeForTargetNode(m_capturingMouseEventsElement.get()) : subframeForHitTestResult(mouseEvent);
2015 
2016     // We want mouseouts to happen first, from the inside out.  First send a move event to the last subframe so that it will fire mouseouts.
2017     if (m_lastMouseMoveEventSubframe &amp;&amp; m_lastMouseMoveEventSubframe-&gt;tree().isDescendantOf(&amp;m_frame) &amp;&amp; m_lastMouseMoveEventSubframe != newSubframe)
2018         passMouseMoveEventToSubframe(mouseEvent, m_lastMouseMoveEventSubframe.get());
2019 
2020     if (newSubframe) {
2021         // Update over/out state before passing the event to the subframe.
2022         updateMouseEventTargetNode(mouseEvent.targetNode(), platformMouseEvent, FireMouseOverOut::Yes);
2023 
2024         // Event dispatch in updateMouseEventTargetNode may have caused the subframe of the target
2025         // node to be detached from its FrameView, in which case the event should not be passed.
2026         if (newSubframe-&gt;view())
2027             swallowEvent |= passMouseMoveEventToSubframe(mouseEvent, newSubframe.get(), hoveredNode);
2028     }
2029 
2030     if (!newSubframe || mouseEvent.scrollbar()) {
<span class="line-removed">2031 #if ENABLE(CURSOR_SUPPORT)</span>
2032         if (auto* view = m_frame.view())
2033             updateCursor(*view, mouseEvent.hitTestResult(), platformMouseEvent.shiftKey());
<span class="line-removed">2034 #endif</span>
2035     }
2036 
2037     m_lastMouseMoveEventSubframe = newSubframe;
2038 
2039     if (swallowEvent)
2040         return true;
2041 
2042     swallowEvent = !dispatchMouseEvent(eventNames().mousemoveEvent, mouseEvent.targetNode(), false, 0, platformMouseEvent, true);
2043 #if ENABLE(DRAG_SUPPORT)
2044     if (!swallowEvent)
2045         swallowEvent = handleMouseDraggedEvent(mouseEvent);
2046 #endif
2047 
2048     return swallowEvent;
2049 }
2050 
2051 bool EventHandler::shouldSendMouseEventsToInactiveWindows() const
2052 {
2053 #if PLATFORM(GTK)
2054     return true;
</pre>
<hr />
<pre>
2245     Frame&amp; focusFrame = m_frame.page()-&gt;focusController().focusedOrMainFrame();
2246     // Do not paste here if the focus was moved somewhere else.
2247     if (&amp;m_frame == &amp;focusFrame &amp;&amp; m_frame.editor().client()-&gt;supportsGlobalSelection())
2248         return m_frame.editor().command(&quot;PasteGlobalSelection&quot;_s).execute();
2249 
2250     return false;
2251 }
2252 
2253 #if ENABLE(DRAG_SUPPORT)
2254 
2255 bool EventHandler::dispatchDragEvent(const AtomString&amp; eventType, Element&amp; dragTarget, const PlatformMouseEvent&amp; event, DataTransfer&amp; dataTransfer)
2256 {
2257     Ref&lt;Frame&gt; protectedFrame(m_frame);
2258     FrameView* view = m_frame.view();
2259 
2260     // FIXME: We might want to dispatch a dragleave even if the view is gone.
2261     if (!view)
2262         return false;
2263 
2264     view-&gt;disableLayerFlushThrottlingTemporarilyForInteraction();
<span class="line-modified">2265     // FIXME: Use MouseEvent::create which takes PlatformMouseEvent.</span>
<span class="line-modified">2266     Ref&lt;MouseEvent&gt; me = MouseEvent::create(eventType, Event::CanBubble::Yes, Event::IsCancelable::Yes, Event::IsComposed::Yes,</span>
2267         event.timestamp().approximateMonotonicTime(), &amp;m_frame.windowProxy(), 0,
2268         event.globalPosition(), event.position(),
2269 #if ENABLE(POINTER_LOCK)
2270         event.movementDelta(),
2271 #else
2272         { },
2273 #endif
2274         event.modifiers(), 0, 0, nullptr, event.force(), NoTap, &amp;dataTransfer);
2275 
<span class="line-modified">2276     dragTarget.dispatchEvent(me);</span>
<span class="line-modified">2277     return me-&gt;defaultPrevented();</span>
2278 }
2279 
2280 static bool targetIsFrame(Node* target, Frame*&amp; frame)
2281 {
2282     if (!is&lt;HTMLFrameElementBase&gt;(target))
2283         return false;
2284 
2285     frame = downcast&lt;HTMLFrameElementBase&gt;(*target).contentFrame();
2286     return true;
2287 }
2288 
2289 static DragOperation convertDropZoneOperationToDragOperation(const String&amp; dragOperation)
2290 {
2291     if (dragOperation == &quot;copy&quot;)
2292         return DragOperationCopy;
2293     if (dragOperation == &quot;move&quot;)
2294         return DragOperationMove;
2295     if (dragOperation == &quot;link&quot;)
2296         return DragOperationLink;
2297     return DragOperationNone;
</pre>
<hr />
<pre>
2376             newTarget = targetNode-&gt;parentOrShadowHostElement();
2377         else
2378             newTarget = downcast&lt;Element&gt;(targetNode);
2379     }
2380 
2381     m_autoscrollController-&gt;updateDragAndDrop(newTarget.get(), event.position(), event.timestamp());
2382 
2383     DragTargetResponse response;
2384     if (m_dragTarget != newTarget) {
2385         // FIXME: this ordering was explicitly chosen to match WinIE. However,
2386         // it is sometimes incorrect when dragging within subframes, as seen with
2387         // LayoutTests/fast/events/drag-in-frames.html.
2388         //
2389         // Moreover, this ordering conforms to section 7.9.4 of the HTML 5 spec. &lt;http://dev.w3.org/html5/spec/Overview.html#drag-and-drop-processing-model&gt;.
2390         Frame* targetFrame;
2391         if (targetIsFrame(newTarget.get(), targetFrame)) {
2392             if (targetFrame)
2393                 response = targetFrame-&gt;eventHandler().updateDragAndDrop(event, makePasteboard, sourceOperation, draggingFiles);
2394         } else if (newTarget) {
2395             // As per section 7.9.4 of the HTML 5 spec., we must always fire a drag event before firing a dragenter, dragleave, or dragover event.
<span class="line-modified">2396             if (dragState().source &amp;&amp; dragState().shouldDispatchEvents)</span>
<span class="line-removed">2397                 dispatchDragSrcEvent(eventNames().dragEvent, event);</span>
2398             response = dispatchDragEnterOrDragOverEvent(eventNames().dragenterEvent, *newTarget, event, makePasteboard(), sourceOperation, draggingFiles);
2399         }
2400 
2401         if (targetIsFrame(m_dragTarget.get(), targetFrame)) {
2402             // FIXME: Recursing again here doesn&#39;t make sense if the newTarget and m_dragTarget were in the same frame.
2403             if (targetFrame)
2404                 response = targetFrame-&gt;eventHandler().updateDragAndDrop(event, makePasteboard, sourceOperation, draggingFiles);
2405         } else if (m_dragTarget) {
2406             auto dataTransfer = DataTransfer::createForUpdatingDropTarget(m_dragTarget-&gt;document(), makePasteboard(), sourceOperation, draggingFiles);
2407             dispatchDragEvent(eventNames().dragleaveEvent, *m_dragTarget, event, dataTransfer.get());
2408             dataTransfer-&gt;makeInvalidForSecurity();
2409         }
2410 
2411         if (newTarget) {
2412             // We do not explicitly call dispatchDragEvent here because it could ultimately result in the appearance that
2413             // two dragover events fired. So, we mark that we should only fire a dragover event on the next call to this function.
2414             m_shouldOnlyFireDragOverEvent = true;
2415         }
2416     } else {
2417         Frame* targetFrame;
2418         if (targetIsFrame(newTarget.get(), targetFrame)) {
2419             if (targetFrame)
2420                 response = targetFrame-&gt;eventHandler().updateDragAndDrop(event, makePasteboard, sourceOperation, draggingFiles);
2421         } else if (newTarget) {
2422             // Note, when dealing with sub-frames, we may need to fire only a dragover event as a drag event may have been fired earlier.
<span class="line-modified">2423             if (!m_shouldOnlyFireDragOverEvent &amp;&amp; dragState().source &amp;&amp; dragState().shouldDispatchEvents)</span>
<span class="line-modified">2424                 dispatchDragSrcEvent(eventNames().dragEvent, event);</span>
2425             response = dispatchDragEnterOrDragOverEvent(eventNames().dragoverEvent, *newTarget, event, makePasteboard(), sourceOperation, draggingFiles);
2426             m_shouldOnlyFireDragOverEvent = false;
2427         }
2428     }
2429     m_dragTarget = WTFMove(newTarget);
2430     return response;
2431 }
2432 
2433 void EventHandler::cancelDragAndDrop(const PlatformMouseEvent&amp; event, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; pasteboard, DragOperation sourceOperation, bool draggingFiles)
2434 {
2435     Ref&lt;Frame&gt; protectedFrame(m_frame);
2436 
2437     Frame* targetFrame;
2438     if (targetIsFrame(m_dragTarget.get(), targetFrame)) {
2439         if (targetFrame)
2440             targetFrame-&gt;eventHandler().cancelDragAndDrop(event, WTFMove(pasteboard), sourceOperation, draggingFiles);
2441     } else if (m_dragTarget) {
<span class="line-modified">2442         if (dragState().source &amp;&amp; dragState().shouldDispatchEvents)</span>
<span class="line-removed">2443             dispatchDragSrcEvent(eventNames().dragEvent, event);</span>
2444 
2445         auto dataTransfer = DataTransfer::createForUpdatingDropTarget(m_dragTarget-&gt;document(), WTFMove(pasteboard), sourceOperation, draggingFiles);
2446         dispatchDragEvent(eventNames().dragleaveEvent, *m_dragTarget, event, dataTransfer.get());
2447         dataTransfer-&gt;makeInvalidForSecurity();
2448     }
2449     clearDragState();
2450 }
2451 
2452 bool EventHandler::performDragAndDrop(const PlatformMouseEvent&amp; event, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; pasteboard, DragOperation sourceOperation, bool draggingFiles)
2453 {
2454     Ref&lt;Frame&gt; protectedFrame(m_frame);
2455 
2456     Frame* targetFrame;
2457     bool preventedDefault = false;
2458     if (targetIsFrame(m_dragTarget.get(), targetFrame)) {
2459         if (targetFrame)
2460             preventedDefault = targetFrame-&gt;eventHandler().performDragAndDrop(event, WTFMove(pasteboard), sourceOperation, draggingFiles);
2461     } else if (m_dragTarget) {
2462         auto dataTransfer = DataTransfer::createForDrop(m_dragTarget-&gt;document(), WTFMove(pasteboard), sourceOperation, draggingFiles);
2463         preventedDefault = dispatchDragEvent(eventNames().dropEvent, *m_dragTarget, event, dataTransfer);
</pre>
<hr />
<pre>
2606             if (m_lastElementUnderMouse)
2607                 m_lastElementUnderMouse-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseoutEvent, 0, m_elementUnderMouse.get());
2608 
2609             for (auto&amp; chain : leftElementsChain) {
2610                 if (hasCapturingMouseLeaveListener || chain-&gt;hasEventListeners(eventNames().pointerleaveEvent) || chain-&gt;hasEventListeners(eventNames().mouseleaveEvent))
2611                     chain-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseleaveEvent, 0, m_elementUnderMouse.get());
2612             }
2613 
2614             if (m_elementUnderMouse)
2615                 m_elementUnderMouse-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseoverEvent, 0, m_lastElementUnderMouse.get());
2616 
2617             for (auto&amp; chain : WTF::makeReversedRange(enteredElementsChain)) {
2618                 if (hasCapturingMouseEnterListener || chain-&gt;hasEventListeners(eventNames().pointerenterEvent) || chain-&gt;hasEventListeners(eventNames().mouseenterEvent))
2619                     chain-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseenterEvent, 0, m_lastElementUnderMouse.get());
2620             }
2621         }
2622         m_lastElementUnderMouse = m_elementUnderMouse;
2623     }
2624 }
2625 













2626 bool EventHandler::dispatchMouseEvent(const AtomString&amp; eventType, Node* targetNode, bool /*cancelable*/, int clickCount, const PlatformMouseEvent&amp; platformMouseEvent, bool setUnder)
2627 {
2628     Ref&lt;Frame&gt; protectedFrame(m_frame);
2629 
2630     if (auto* view = m_frame.view())
2631         view-&gt;disableLayerFlushThrottlingTemporarilyForInteraction();
2632 
2633     updateMouseEventTargetNode(targetNode, platformMouseEvent, setUnder ? FireMouseOverOut::Yes : FireMouseOverOut::No);
2634 
2635     if (m_elementUnderMouse &amp;&amp; !m_elementUnderMouse-&gt;dispatchMouseEvent(platformMouseEvent, eventType, clickCount))
2636         return false;
2637 
2638     if (eventType != eventNames().mousedownEvent)
2639         return true;
2640 
2641     // If clicking on a frame scrollbar, do not make any change to which element is focused.
2642     auto* view = m_frame.view();
2643     if (view &amp;&amp; view-&gt;scrollbarAtPoint(platformMouseEvent.position()))
2644         return true;
2645 
2646     // The layout needs to be up to date to determine if an element is focusable.
2647     m_frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
2648 
2649     // Remove focus from the currently focused element when a link or button is clicked.
2650     // This is expected by some sites that rely on change event handlers running
2651     // from form fields before the button click is processed, behavior that was inherited
2652     // from the user interface of Windows, where pushing a button moves focus to the button.
2653 
2654     // Walk up the DOM tree to search for an element to focus.
2655     RefPtr&lt;Element&gt; element;
2656     for (element = m_elementUnderMouse.get(); element; element = element-&gt;parentElementInComposedTree()) {






2657         if (element-&gt;isMouseFocusable())
2658             break;
2659     }
2660 
2661     // To fix &lt;rdar://problem/4895428&gt; Can&#39;t drag selected ToDo, we don&#39;t focus an
2662     // element on mouse down if it&#39;s selected and inside a focused element. It will be
2663     // focused if the user does a mouseup over it, however, because the mouseup
2664     // will set a selection inside it, which will also set the focused element.
2665     if (element &amp;&amp; m_frame.selection().isRange()) {
2666         if (auto range = m_frame.selection().toNormalizedRange()) {
2667             auto result = range-&gt;compareNode(*element);
2668             if (!result.hasException() &amp;&amp; result.releaseReturnValue() == Range::NODE_INSIDE &amp;&amp; element-&gt;isDescendantOf(m_frame.document()-&gt;focusedElement()))
2669                 return true;
2670         }
2671     }
2672 
2673     // Only change the focus when clicking scrollbars if it can be transferred to a mouse focusable node.
2674     if (!element &amp;&amp; isInsideScrollbar(platformMouseEvent.position()))
2675         return false;
2676 
</pre>
<hr />
<pre>
2885     if (auto filter = page-&gt;wheelEventDeltaFilter())
2886         filter-&gt;endFilteringDeltas();
2887 }
2888 
2889 void EventHandler::defaultWheelEventHandler(Node* startNode, WheelEvent&amp; wheelEvent)
2890 {
2891     if (!startNode)
2892         return;
2893 
2894     auto protectedFrame = makeRef(m_frame);
2895 
2896     FloatSize filteredPlatformDelta(wheelEvent.deltaX(), wheelEvent.deltaY());
2897     FloatSize filteredVelocity;
2898     if (auto platformWheelEvent = wheelEvent.underlyingPlatformEvent()) {
2899         filteredPlatformDelta.setWidth(platformWheelEvent-&gt;deltaX());
2900         filteredPlatformDelta.setHeight(platformWheelEvent-&gt;deltaY());
2901     }
2902 
2903 #if PLATFORM(MAC)
2904     ScrollLatchingState* latchedState = m_frame.page() ? m_frame.page()-&gt;latchingState() : nullptr;
<span class="line-modified">2905     Element* stopElement = latchedState ? latchedState-&gt;previousWheelScrolledElement() : nullptr;</span>
2906 
2907     if (m_frame.page() &amp;&amp; m_frame.page()-&gt;wheelEventDeltaFilter()-&gt;isFilteringDeltas()) {
2908         filteredPlatformDelta = m_frame.page()-&gt;wheelEventDeltaFilter()-&gt;filteredDelta();
2909         filteredVelocity = m_frame.page()-&gt;wheelEventDeltaFilter()-&gt;filteredVelocity();
2910     }
2911 #else
<span class="line-modified">2912     Element* stopElement = nullptr;</span>
2913 #endif
2914 
<span class="line-modified">2915     if (handleWheelEventInAppropriateEnclosingBox(startNode, wheelEvent, &amp;stopElement, filteredPlatformDelta, filteredVelocity))</span>
2916         wheelEvent.setDefaultHandled();
2917 
2918 #if PLATFORM(MAC)
2919     if (latchedState &amp;&amp; !latchedState-&gt;wheelEventElement())
<span class="line-modified">2920         latchedState-&gt;setPreviousWheelScrolledElement(stopElement);</span>
2921 #endif
2922 }
2923 
<span class="line-modified">2924 #if ENABLE(CONTEXT_MENUS)</span>
2925 bool EventHandler::sendContextMenuEvent(const PlatformMouseEvent&amp; event)
2926 {
2927     Ref&lt;Frame&gt; protectedFrame(m_frame);
2928 
2929     Document* doc = m_frame.document();
2930     FrameView* view = m_frame.view();
2931     if (!view)
2932         return false;
2933 
2934     // Caret blinking is normally un-suspended in handleMouseReleaseEvent, but we
2935     // won&#39;t receive that event once the context menu is up.
2936     m_frame.selection().setCaretBlinkingSuspended(false);
2937     // Clear mouse press state to avoid initiating a drag while context menu is up.
2938     m_mousePressed = false;
2939     bool swallowEvent;
2940     LayoutPoint viewportPos = view-&gt;windowToContents(event.position());
2941     HitTestRequest request(HitTestRequest::Active | HitTestRequest::DisallowUserAgentShadowContent);
2942     MouseEventWithHitTestResults mouseEvent = doc-&gt;prepareMouseEvent(request, viewportPos, event);
2943 
2944     // Do not show context menus when clicking on scrollbars.
</pre>
<hr />
<pre>
3019         targetNode = doc;
3020 
3021     // Use the focused node as the target for hover and active.
3022     HitTestResult result(position);
3023     result.setInnerNode(targetNode);
3024     doc-&gt;updateHoverActiveState(HitTestRequest::Active | HitTestRequest::DisallowUserAgentShadowContent, result.targetElement());
3025 
3026     // The contextmenu event is a mouse event even when invoked using the keyboard.
3027     // This is required for web compatibility.
3028 
3029 #if OS(WINDOWS)
3030     PlatformEvent::Type eventType = PlatformEvent::MouseReleased;
3031 #else
3032     PlatformEvent::Type eventType = PlatformEvent::MousePressed;
3033 #endif
3034 
3035     PlatformMouseEvent platformMouseEvent(position, globalPosition, RightButton, eventType, 1, false, false, false, false, WallTime::now(), ForceAtClick, NoTap);
3036 
3037     return sendContextMenuEvent(platformMouseEvent);
3038 }
<span class="line-modified">3039 #endif // ENABLE(CONTEXT_MENUS)</span>
3040 
3041 void EventHandler::scheduleHoverStateUpdate()
3042 {
3043     if (!m_hoverTimer.isActive())
3044         m_hoverTimer.startOneShot(0_s);
3045 }
3046 
<span class="line-removed">3047 #if ENABLE(CURSOR_SUPPORT)</span>
3048 void EventHandler::scheduleCursorUpdate()
3049 {





3050     if (!m_cursorUpdateTimer.isActive())
3051         m_cursorUpdateTimer.startOneShot(cursorUpdateInterval);
3052 }
<span class="line-removed">3053 #endif</span>
3054 
3055 void EventHandler::dispatchFakeMouseMoveEventSoon()
3056 {
3057 #if !ENABLE(IOS_TOUCH_EVENTS)
3058     if (m_mousePressed)
3059         return;
3060 
3061     if (m_mousePositionIsUnknown)
3062         return;
3063 
3064     if (Page* page = m_frame.page()) {
3065         if (!page-&gt;chrome().client().shouldDispatchFakeMouseMoveEvents())
3066             return;
3067     }
3068 
3069     // If the content has ever taken longer than fakeMouseMoveShortInterval we
3070     // reschedule the timer and use a longer time. This will cause the content
3071     // to receive these moves only after the user is done scrolling, reducing
3072     // pauses during the scroll.
3073     if (m_fakeMouseMoveEventTimer.isActive())
</pre>
<hr />
<pre>
3329     // 2. if an input method handles the event, its keyCode is set to 229 in keydown event.
3330     m_frame.editor().handleInputMethodKeydown(keydown.get());
3331 
3332     bool handledByInputMethod = keydown-&gt;defaultHandled();
3333 
3334     if (handledByInputMethod) {
3335         keyDownEvent.setWindowsVirtualKeyCode(CompositionEventKeyCode);
3336         keydown = KeyboardEvent::create(keyDownEvent, &amp;m_frame.windowProxy());
3337         keydown-&gt;setTarget(element);
3338         keydown-&gt;setIsDefaultEventHandlerIgnored();
3339     }
3340 
3341     if (accessibilityPreventsEventPropagation(keydown))
3342         keydown-&gt;stopPropagation();
3343 
3344 #if PLATFORM(IOS_FAMILY)
3345     DeferDOMTimersForScope deferralScope { m_frame.document()-&gt;quirks().needsDeferKeyDownAndKeyPressTimersUntilNextEditingCommand() };
3346 #endif
3347 
3348     element-&gt;dispatchEvent(keydown);
<span class="line-modified">3349     if (handledByInputMethod)</span>

3350         return true;

3351 
3352     // If frame changed as a result of keydown dispatch, then return early to avoid sending a subsequent keypress message to the new frame.
3353     bool changedFocusedFrame = m_frame.page() &amp;&amp; &amp;m_frame != &amp;m_frame.page()-&gt;focusController().focusedOrMainFrame();
3354     bool keydownResult = keydown-&gt;defaultHandled() || keydown-&gt;defaultPrevented() || changedFocusedFrame;
3355     if (keydownResult &amp;&amp; !backwardCompatibilityMode)
3356         return keydownResult;
3357 
3358     // Focus may have changed during keydown handling, so refetch element.
3359     // But if we are dispatching a fake backward compatibility keypress, then we pretend that the keypress happened on the original element.
3360     if (!keydownResult) {
3361         element = eventTargetElementForDocument(m_frame.document());
3362         if (!element)
3363             return false;
3364     }
3365 
3366     PlatformKeyboardEvent keyPressEvent = initialKeyEvent;
3367     keyPressEvent.disambiguateKeyDownEvent(PlatformEvent::Char, backwardCompatibilityMode);
3368     if (keyPressEvent.text().isEmpty())
3369         return keydownResult;
3370     auto keypress = KeyboardEvent::create(keyPressEvent, &amp;m_frame.windowProxy());
</pre>
<hr />
<pre>
3620     else {
3621         Position startPosition(dragSource.get(), Position::PositionIsBeforeAnchor);
3622         Position endPosition(dragSource.get(), Position::PositionIsAfterAnchor);
3623         draggedContentRange = Range::create(dragSource-&gt;document(), startPosition, endPosition);
3624     }
3625 
3626     if (draggedContentRange) {
3627         draggedContentRange-&gt;ownerDocument().markers().addDraggedContentMarker(*draggedContentRange);
3628         if (auto* renderer = m_frame.contentRenderer())
3629             renderer-&gt;repaintRootContents();
3630     }
3631 #endif
3632 }
3633 
3634 void EventHandler::dragSourceEndedAt(const PlatformMouseEvent&amp; event, DragOperation operation, MayExtendDragSession mayExtendDragSession)
3635 {
3636     // Send a hit test request so that RenderLayer gets a chance to update the :hover and :active pseudoclasses.
3637     HitTestRequest request(HitTestRequest::Release | HitTestRequest::DisallowUserAgentShadowContent);
3638     prepareMouseEvent(request, event);
3639 
<span class="line-modified">3640     if (dragState().source &amp;&amp; dragState().shouldDispatchEvents) {</span>
3641         dragState().dataTransfer-&gt;setDestinationOperation(operation);
<span class="line-modified">3642         dispatchDragSrcEvent(eventNames().dragendEvent, event);</span>
3643     }
3644     invalidateDataTransfer();
3645 
3646     if (mayExtendDragSession == MayExtendDragSession::No) {
3647         if (auto* page = m_frame.page())
3648             removeDraggedContentDocumentMarkersFromAllFramesInPage(*page);
3649     }
3650 
3651     dragState().source = nullptr;
3652     // In case the drag was ended due to an escape key press we need to ensure
3653     // that consecutive mousemove events don&#39;t reinitiate the drag and drop.
3654     m_mouseDownMayStartDrag = false;
3655 }
3656 
3657 void EventHandler::updateDragStateAfterEditDragIfNeeded(Element&amp; rootEditableElement)
3658 {
3659     // If inserting the dragged contents removed the drag source, we still want to fire dragend at the root editable element.
3660     if (dragState().source &amp;&amp; !dragState().source-&gt;isConnected())
3661         dragState().source = &amp;rootEditableElement;
3662 }
3663 
<span class="line-modified">3664 void EventHandler::dispatchDragSrcEvent(const AtomString&amp; eventType, const PlatformMouseEvent&amp; event)</span>





3665 {
<span class="line-modified">3666     ASSERT(dragState().dataTransfer);</span>
<span class="line-modified">3667     dispatchDragEvent(eventType, *dragState().source, event, *dragState().dataTransfer);</span>
3668 }
3669 
3670 bool EventHandler::dispatchDragStartEventOnSourceElement(DataTransfer&amp; dataTransfer)
3671 {
3672     return !dispatchDragEvent(eventNames().dragstartEvent, *dragState().source, m_mouseDown, dataTransfer) &amp;&amp; !m_frame.selection().selection().isInPasswordField();
3673 }
3674 
3675 static bool ExactlyOneBitSet(DragSourceAction n)
3676 {
3677     return n &amp;&amp; !(n &amp; (n - 1));
3678 }
3679 
3680 RefPtr&lt;Element&gt; EventHandler::draggedElement() const
3681 {
3682     return dragState().source;
3683 }
3684 
3685 bool EventHandler::handleDrag(const MouseEventWithHitTestResults&amp; event, CheckDragHysteresis checkDragHysteresis)
3686 {
3687     if (event.event().button() != LeftButton || event.event().type() != PlatformEvent::MouseMoved) {
</pre>
<hr />
<pre>
3749         ASSERT(ExactlyOneBitSet(static_cast&lt;DragSourceAction&gt;(dragState().type &amp; ~DragSourceActionSelection)));
3750 
3751         dragState().type = DragSourceActionSelection;
3752     }
3753 
3754     // We are starting a text/image/url drag, so the cursor should be an arrow
3755     if (FrameView* view = m_frame.view()) {
3756         // FIXME &lt;rdar://7577595&gt;: Custom cursors aren&#39;t supported during drag and drop (default to pointer).
3757         view-&gt;setCursor(pointerCursor());
3758     }
3759 
3760     if (checkDragHysteresis == ShouldCheckDragHysteresis &amp;&amp; !dragHysteresisExceeded(event.event().position()))
3761         return true;
3762 
3763     // Once we&#39;re past the hysteresis point, we don&#39;t want to treat this gesture as a click
3764     invalidateClick();
3765 
3766     DragOperation srcOp = DragOperationNone;
3767 
3768     // This does work only if we missed a dragEnd. Do it anyway, just to make sure the old dataTransfer gets numbed.

3769     invalidateDataTransfer();
3770 
<span class="line-modified">3771     dragState().dataTransfer = DataTransfer::createForDrag(*m_frame.document());</span>
3772     HasNonDefaultPasteboardData hasNonDefaultPasteboardData = HasNonDefaultPasteboardData::No;
3773 
3774     if (dragState().shouldDispatchEvents) {
3775         ASSERT(dragState().source);
3776         auto dragStartDataTransfer = DataTransfer::createForDragStartEvent(dragState().source-&gt;document());
3777         m_mouseDownMayStartDrag = dispatchDragStartEventOnSourceElement(dragStartDataTransfer);
3778         hasNonDefaultPasteboardData = dragStartDataTransfer-&gt;pasteboard().hasData() ? HasNonDefaultPasteboardData::Yes : HasNonDefaultPasteboardData::No;
3779         dragState().dataTransfer-&gt;moveDragState(WTFMove(dragStartDataTransfer));
3780 
3781         if (dragState().source &amp;&amp; dragState().type == DragSourceActionDHTML &amp;&amp; !dragState().dataTransfer-&gt;hasDragImage()) {
3782             dragState().source-&gt;document().updateStyleIfNeeded();
3783             if (auto* renderer = dragState().source-&gt;renderer()) {
3784                 auto absolutePosition = renderer-&gt;localToAbsolute();
3785                 auto delta = m_mouseDownPos - roundedIntPoint(absolutePosition);
3786                 dragState().dataTransfer-&gt;setDragImage(dragState().source.get(), delta.width(), delta.height());
3787             } else {
<span class="line-modified">3788                 dispatchDragSrcEvent(eventNames().dragendEvent, event.event());</span>
3789                 m_mouseDownMayStartDrag = false;
3790                 invalidateDataTransfer();
3791                 dragState().source = nullptr;
3792                 return true;
3793             }
3794         }
3795 
3796         dragState().dataTransfer-&gt;makeInvalidForSecurity();
3797 
3798         if (m_mouseDownMayStartDrag) {
3799             // Gather values from DHTML element, if it set any.
3800             srcOp = dragState().dataTransfer-&gt;sourceOperation();
3801 
3802             // Yuck, a draggedImage:moveTo: message can be fired as a result of kicking off the
3803             // drag with dragImage! Because of that dumb reentrancy, we may think we&#39;ve not
3804             // started the drag when that happens. So we have to assume it&#39;s started before we kick it off.
3805             dragState().dataTransfer-&gt;setDragHasStarted();
3806         }
3807     }
3808 
3809     if (m_mouseDownMayStartDrag) {
3810         Page* page = m_frame.page();
3811         m_didStartDrag = page &amp;&amp; page-&gt;dragController().startDrag(m_frame, dragState(), srcOp, event.event(), m_mouseDownPos, hasNonDefaultPasteboardData);
3812         // In WebKit2 we could re-enter this code and start another drag.
3813         // On OS X this causes problems with the ownership of the pasteboard and the promised types.
3814         if (m_didStartDrag) {
3815             m_mouseDownMayStartDrag = false;
3816             return true;
3817         }
<span class="line-modified">3818         if (dragState().source &amp;&amp; dragState().shouldDispatchEvents) {</span>
3819             // Drag was canned at the last minute. We owe dragSource a dragend event.
<span class="line-modified">3820             dispatchDragSrcEvent(eventNames().dragendEvent, event.event());</span>
3821             m_mouseDownMayStartDrag = false;
3822         }
3823     }
3824 
3825     if (!m_mouseDownMayStartDrag) {
3826         // Something failed to start the drag, clean up.
3827         invalidateDataTransfer();
3828         dragState().source = nullptr;
3829     }
3830 
3831     // No more default handling (like selection), whether we&#39;re past the hysteresis bounds or not
3832     return true;
3833 }
3834 #endif // ENABLE(DRAG_SUPPORT)
3835 
3836 bool EventHandler::mouseMovementExceedsThreshold(const FloatPoint&amp; viewportLocation, int pointsThreshold) const
3837 {
3838     FrameView* view = m_frame.view();
3839     if (!view)
3840         return false;
</pre>
<hr />
<pre>
3996     Page* page = m_frame.page();
3997     if (!page)
3998         return;
3999     if (!page-&gt;tabKeyCyclesThroughElements())
4000         return;
4001 
4002     FocusDirection focusDirection = event.shiftKey() ? FocusDirectionBackward : FocusDirectionForward;
4003 
4004     // Tabs can be used in design mode editing.
4005     if (m_frame.document()-&gt;inDesignMode())
4006         return;
4007 
4008     if (page-&gt;focusController().advanceFocus(focusDirection, &amp;event))
4009         event.setDefaultHandled();
4010 }
4011 
4012 void EventHandler::sendScrollEvent()
4013 {
4014     Ref&lt;Frame&gt; protectedFrame(m_frame);
4015     setFrameWasScrolledByUser();
<span class="line-modified">4016     if (m_frame.view() &amp;&amp; m_frame.document())</span>
<span class="line-modified">4017         m_frame.document()-&gt;eventQueue().enqueueOrDispatchScrollEvent(*m_frame.document());</span>




4018 }
4019 
4020 void EventHandler::setFrameWasScrolledByUser()
4021 {
4022     FrameView* v = m_frame.view();
4023     if (v)
4024         v-&gt;setWasScrolledByUser(true);
4025 }
4026 
4027 bool EventHandler::passMousePressEventToScrollbar(MouseEventWithHitTestResults&amp; mouseEvent, Scrollbar* scrollbar)
4028 {
4029     if (!scrollbar || !scrollbar-&gt;enabled())
4030         return false;
4031     setFrameWasScrolledByUser();
4032     return scrollbar-&gt;mouseDown(mouseEvent.event());
4033 }
4034 
4035 // If scrollbar (under mouse) is different from last, send a mouse exited.
4036 void EventHandler::updateLastScrollbarUnderMouse(Scrollbar* scrollbar, SetOrClearLastScrollbar setOrClear)
4037 {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2006-2020 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2006 Alexey Proskuryakov (ap@webkit.org)
   4  * Copyright (C) 2012 Digia Plc. and/or its subsidiary(-ies)
   5  *
   6  * Redistribution and use in source and binary forms, with or without
   7  * modification, are permitted provided that the following conditions
   8  * are met:
   9  * 1. Redistributions of source code must retain the above copyright
  10  *    notice, this list of conditions and the following disclaimer.
  11  * 2. Redistributions in binary form must reproduce the above copyright
  12  *    notice, this list of conditions and the following disclaimer in the
  13  *    documentation and/or other materials provided with the distribution.
  14  *
  15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  26  */
  27 
  28 #include &quot;config.h&quot;
  29 #include &quot;EventHandler.h&quot;
  30 
  31 #include &quot;AutoscrollController.h&quot;
  32 #include &quot;BackForwardController.h&quot;
  33 #include &quot;CachedImage.h&quot;
  34 #include &quot;Chrome.h&quot;
  35 #include &quot;ChromeClient.h&quot;
  36 #include &quot;ComposedTreeAncestorIterator.h&quot;
<span class="line-added">  37 #include &quot;ComposedTreeIterator.h&quot;</span>
  38 #include &quot;CursorList.h&quot;
  39 #include &quot;DocumentMarkerController.h&quot;
  40 #include &quot;DragController.h&quot;
<span class="line-added">  41 #include &quot;DragEvent.h&quot;</span>
  42 #include &quot;DragState.h&quot;
  43 #include &quot;Editing.h&quot;
  44 #include &quot;Editor.h&quot;
  45 #include &quot;EditorClient.h&quot;
  46 #include &quot;EventNames.h&quot;
  47 #include &quot;FileList.h&quot;
  48 #include &quot;FloatPoint.h&quot;
  49 #include &quot;FloatRect.h&quot;
  50 #include &quot;FocusController.h&quot;
  51 #include &quot;Frame.h&quot;
  52 #include &quot;FrameLoader.h&quot;
  53 #include &quot;FrameSelection.h&quot;
  54 #include &quot;FrameTree.h&quot;
  55 #include &quot;FrameView.h&quot;
  56 #include &quot;FullscreenManager.h&quot;
  57 #include &quot;HTMLDocument.h&quot;
  58 #include &quot;HTMLFrameElement.h&quot;
  59 #include &quot;HTMLFrameSetElement.h&quot;
  60 #include &quot;HTMLHtmlElement.h&quot;
  61 #include &quot;HTMLIFrameElement.h&quot;
</pre>
<hr />
<pre>
 112 #include &quot;PlatformTouchEventIOS.h&quot;
 113 #endif
 114 
 115 #if ENABLE(TOUCH_EVENTS)
 116 #include &quot;TouchEvent.h&quot;
 117 #include &quot;TouchList.h&quot;
 118 #endif
 119 
 120 #if ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
 121 #include &quot;PlatformTouchEvent.h&quot;
 122 #endif
 123 
 124 #if ENABLE(MAC_GESTURE_EVENTS)
 125 #include &quot;PlatformGestureEventMac.h&quot;
 126 #endif
 127 
 128 #if ENABLE(POINTER_LOCK)
 129 #include &quot;PointerLockController.h&quot;
 130 #endif
 131 




 132 #if PLATFORM(IOS_FAMILY)
 133 #include &quot;DOMTimerHoldingTank.h&quot;
 134 #endif
 135 
 136 namespace WebCore {
 137 
 138 using namespace HTMLNames;
 139 
 140 #if ENABLE(DRAG_SUPPORT)
 141 // The link drag hysteresis is much larger than the others because there
 142 // needs to be enough space to cancel the link press without starting a link drag,
 143 // and because dragging links is rare.
 144 const int LinkDragHysteresis = 40;
 145 const int ImageDragHysteresis = 5;
 146 const int TextDragHysteresis = 3;
 147 const int ColorDragHystersis = 3;
 148 const int GeneralDragHysteresis = 3;
 149 #if PLATFORM(MAC)
 150 const Seconds EventHandler::TextDragDelay { 150_ms };
 151 #else
</pre>
<hr />
<pre>
 160 #if ENABLE(IOS_TOUCH_EVENTS)
 161 // FIXME: Share this constant with EventHandler and SliderThumbElement.
 162 const unsigned InvalidTouchIdentifier = 0;
 163 #endif
 164 
 165 // Match key code of composition keydown event on windows.
 166 // IE sends VK_PROCESSKEY which has value 229;
 167 const int CompositionEventKeyCode = 229;
 168 
 169 using namespace SVGNames;
 170 
 171 #if !ENABLE(IOS_TOUCH_EVENTS)
 172 // The amount of time to wait before sending a fake mouse event, triggered
 173 // during a scroll. The short interval is used if the content responds to the mouse events
 174 // in fakeMouseMoveDurationThreshold or less, otherwise the long interval is used.
 175 const double fakeMouseMoveDurationThreshold = 0.01;
 176 const Seconds fakeMouseMoveShortInterval = { 100_ms };
 177 const Seconds fakeMouseMoveLongInterval = { 250_ms };
 178 #endif
 179 

 180 // The amount of time to wait for a cursor update on style and layout changes
 181 // Set to 50Hz, no need to be faster than common screen refresh rate
 182 static const Seconds cursorUpdateInterval { 20_ms };
 183 
 184 const int maximumCursorSize = 128;

 185 
 186 #if ENABLE(MOUSE_CURSOR_SCALE)
 187 // It&#39;s pretty unlikely that a scale of less than one would ever be used. But all we really
 188 // need to ensure here is that the scale isn&#39;t so small that integer overflow can occur when
 189 // dividing cursor sizes (limited above) by the scale.
 190 const double minimumCursorScale = 0.001;
 191 #endif
 192 
 193 class MaximumDurationTracker {
 194 public:
 195     explicit MaximumDurationTracker(double *maxDuration)
 196         : m_maxDuration(maxDuration)
 197         , m_start(MonotonicTime::now())
 198     {
 199     }
 200 
 201     ~MaximumDurationTracker()
 202     {
 203         *m_maxDuration = std::max(*m_maxDuration, (MonotonicTime::now() - m_start).seconds());
 204     }
 205 
 206 private:
 207     double* m_maxDuration;
 208     MonotonicTime m_start;
 209 };
 210 
 211 #if ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
 212 class SyntheticTouchPoint : public PlatformTouchPoint {
 213 public:
 214 
 215     // The default values are based on http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html
 216     explicit SyntheticTouchPoint(const PlatformMouseEvent&amp; event)
 217     {
<span class="line-modified"> 218         static constexpr int idDefaultValue = 0;</span>
<span class="line-modified"> 219         static constexpr int radiusYDefaultValue = 1;</span>
<span class="line-modified"> 220         static constexpr int radiusXDefaultValue = 1;</span>
<span class="line-modified"> 221         static constexpr float rotationAngleDefaultValue = 0.0f;</span>
<span class="line-modified"> 222         static constexpr float forceDefaultValue = 1.0f;</span>
 223 
 224         m_id = idDefaultValue; // There is only one active TouchPoint.
 225         m_screenPos = event.globalPosition();
 226         m_pos = event.position();
 227         m_radiusY = radiusYDefaultValue;
 228         m_radiusX = radiusXDefaultValue;
 229         m_rotationAngle = rotationAngleDefaultValue;
 230         m_force = forceDefaultValue;
 231 
 232         PlatformEvent::Type type = event.type();
 233         ASSERT(type == PlatformEvent::MouseMoved || type == PlatformEvent::MousePressed || type == PlatformEvent::MouseReleased);
 234 
 235         switch (type) {
 236         case PlatformEvent::MouseMoved:
 237             m_state = TouchMoved;
 238             break;
 239         case PlatformEvent::MousePressed:
 240             m_state = TouchPressed;
 241             break;
 242         case PlatformEvent::MouseReleased:
</pre>
<hr />
<pre>
 285     case WheelEvent::DOM_DELTA_PIXEL:
 286         return ScrollByPixel;
 287     default:
 288         return ScrollByPixel;
 289     }
 290 }
 291 
 292 static inline bool didScrollInScrollableArea(ScrollableArea* scrollableArea, WheelEvent&amp; wheelEvent)
 293 {
 294     ScrollGranularity scrollGranularity = wheelGranularityToScrollGranularity(wheelEvent.deltaMode());
 295     bool didHandleWheelEvent = false;
 296     if (float absoluteDelta = std::abs(wheelEvent.deltaX()))
 297         didHandleWheelEvent |= scrollableArea-&gt;scroll(wheelEvent.deltaX() &gt; 0 ? ScrollRight : ScrollLeft, scrollGranularity, absoluteDelta);
 298 
 299     if (float absoluteDelta = std::abs(wheelEvent.deltaY()))
 300         didHandleWheelEvent |= scrollableArea-&gt;scroll(wheelEvent.deltaY() &gt; 0 ? ScrollDown : ScrollUp, scrollGranularity, absoluteDelta);
 301 
 302     return didHandleWheelEvent;
 303 }
 304 
<span class="line-modified"> 305 static inline bool handleWheelEventInAppropriateEnclosingBox(Node* startNode, WheelEvent&amp; wheelEvent, RefPtr&lt;Element&gt;&amp; stopElement, const FloatSize&amp; filteredPlatformDelta, const FloatSize&amp; filteredVelocity)</span>
 306 {
 307     bool shouldHandleEvent = wheelEvent.deltaX() || wheelEvent.deltaY();
 308 #if PLATFORM(MAC)
 309     shouldHandleEvent |= wheelEvent.phase() == PlatformWheelEventPhaseEnded;
 310 #if ENABLE(CSS_SCROLL_SNAP)
 311     shouldHandleEvent |= wheelEvent.momentumPhase() == PlatformWheelEventPhaseEnded;
 312 #endif
 313 #endif
 314     if (!startNode-&gt;renderer() || !shouldHandleEvent)
 315         return false;
 316 
 317     RenderBox&amp; initialEnclosingBox = startNode-&gt;renderer()-&gt;enclosingBox();
 318     if (initialEnclosingBox.isListBox())
 319         return didScrollInScrollableArea(static_cast&lt;RenderListBox*&gt;(&amp;initialEnclosingBox), wheelEvent);
 320 
 321     RenderBox* currentEnclosingBox = &amp;initialEnclosingBox;
 322     while (currentEnclosingBox) {
 323         if (RenderLayer* boxLayer = currentEnclosingBox-&gt;layer()) {
 324             auto platformEvent = wheelEvent.underlyingPlatformEvent();
 325             bool scrollingWasHandled;
 326             if (platformEvent) {
 327                 auto copiedEvent = platformEvent-&gt;copyWithDeltasAndVelocity(filteredPlatformDelta.width(), filteredPlatformDelta.height(), filteredVelocity);
 328                 scrollingWasHandled = boxLayer-&gt;handleWheelEvent(copiedEvent);
 329             } else
 330                 scrollingWasHandled = didScrollInScrollableArea(boxLayer, wheelEvent);
 331 
 332             if (scrollingWasHandled) {
<span class="line-modified"> 333                 stopElement = currentEnclosingBox-&gt;element();</span>

 334                 return true;
 335             }
 336         }
 337 
<span class="line-modified"> 338         if (stopElement.get() &amp;&amp; stopElement.get() == currentEnclosingBox-&gt;element())</span>
 339             return true;
 340 
 341         currentEnclosingBox = currentEnclosingBox-&gt;containingBlock();
 342         if (!currentEnclosingBox || currentEnclosingBox-&gt;isRenderView())
 343             return false;
 344     }
 345     return false;
 346 }
 347 
 348 #if (ENABLE(TOUCH_EVENTS) &amp;&amp; !PLATFORM(IOS_FAMILY))
 349 static inline bool shouldGesturesTriggerActive()
 350 {
 351     // If the platform we&#39;re on supports GestureTapDown and GestureTapCancel then we&#39;ll
 352     // rely on them to set the active state. Unfortunately there&#39;s no generic way to
 353     // know in advance what event types are supported.
 354     return false;
 355 }
 356 #endif
 357 
 358 #if !PLATFORM(COCOA)
 359 
 360 inline bool EventHandler::eventLoopHandleMouseUp(const MouseEventWithHitTestResults&amp;)
 361 {
 362     return false;
 363 }
 364 
 365 #if ENABLE(DRAG_SUPPORT)
 366 inline bool EventHandler::eventLoopHandleMouseDragged(const MouseEventWithHitTestResults&amp;)
 367 {
 368     return false;
 369 }
 370 #endif
 371 
 372 #endif
 373 
 374 EventHandler::EventHandler(Frame&amp; frame)
 375     : m_frame(frame)
 376     , m_hoverTimer(*this, &amp;EventHandler::hoverTimerFired)

 377     , m_cursorUpdateTimer(*this, &amp;EventHandler::cursorUpdateTimerFired)

 378 #if PLATFORM(MAC)
 379     , m_pendingMomentumWheelEventsTimer(*this, &amp;EventHandler::clearLatchedState)
 380 #endif
 381     , m_autoscrollController(makeUnique&lt;AutoscrollController&gt;())
 382 #if !ENABLE(IOS_TOUCH_EVENTS)
 383     , m_fakeMouseMoveEventTimer(*this, &amp;EventHandler::fakeMouseMoveEventTimerFired)
 384 #endif
 385 #if ENABLE(CURSOR_VISIBILITY)
 386     , m_autoHideCursorTimer(*this, &amp;EventHandler::autoHideCursorTimerFired)
 387 #endif
 388 {
 389 }
 390 
 391 EventHandler::~EventHandler()
 392 {
 393 #if !ENABLE(IOS_TOUCH_EVENTS)
 394     ASSERT(!m_fakeMouseMoveEventTimer.isActive());
 395 #endif
 396 #if ENABLE(CURSOR_VISIBILITY)
 397     ASSERT(!m_autoHideCursorTimer.isActive());
 398 #endif
 399 }
 400 
 401 #if ENABLE(DRAG_SUPPORT)
 402 
 403 DragState&amp; EventHandler::dragState()
 404 {
 405     static NeverDestroyed&lt;DragState&gt; state;
 406     return state;
 407 }
 408 
 409 #endif
 410 
 411 void EventHandler::clear()
 412 {
 413     m_hoverTimer.stop();

 414     m_cursorUpdateTimer.stop();

 415 #if !ENABLE(IOS_TOUCH_EVENTS)
 416     m_fakeMouseMoveEventTimer.stop();
 417 #endif
 418 #if ENABLE(CURSOR_VISIBILITY)
 419     cancelAutoHideCursorTimer();
 420 #endif
 421     m_resizeLayer = nullptr;
 422     m_elementUnderMouse = nullptr;
 423     m_lastElementUnderMouse = nullptr;
 424     m_lastMouseMoveEventSubframe = nullptr;
 425     m_lastScrollbarUnderMouse = nullptr;
 426     m_clickCount = 0;
 427     m_clickNode = nullptr;
 428 #if ENABLE(IOS_GESTURE_EVENTS)
 429     m_gestureInitialDiameter = GestureUnknown;
 430     m_gestureInitialRotation = GestureUnknown;
 431 #endif
 432 #if ENABLE(IOS_GESTURE_EVENTS) || ENABLE(MAC_GESTURE_EVENTS)
 433     m_gestureLastDiameter = GestureUnknown;
 434     m_gestureLastRotation = GestureUnknown;
</pre>
<hr />
<pre>
 714                 newSelection = VisibleSelection(start, pos);
 715         } else
 716             newSelection.setExtent(pos);
 717 
 718         if (m_frame.selection().granularity() != CharacterGranularity) {
 719             granularity = m_frame.selection().granularity();
 720             newSelection.expandUsingGranularity(m_frame.selection().granularity());
 721         }
 722     } else
 723         newSelection = expandSelectionToRespectSelectOnMouseDown(*targetNode, visiblePos);
 724 
 725     bool handled = updateSelectionForMouseDownDispatchingSelectStart(targetNode, newSelection, granularity);
 726 
 727     if (event.event().button() == MiddleButton) {
 728         // Ignore handled, since we want to paste to where the caret was placed anyway.
 729         handled = handlePasteGlobalSelection(event.event()) || handled;
 730     }
 731     return handled;
 732 }
 733 
<span class="line-modified"> 734 bool EventHandler::canMouseDownStartSelect(const MouseEventWithHitTestResults&amp; event)</span>
 735 {
<span class="line-added"> 736     auto* node = event.targetNode();</span>
<span class="line-added"> 737 </span>
<span class="line-added"> 738     if (Page* page = m_frame.page()) {</span>
<span class="line-added"> 739         if (!page-&gt;chrome().client().shouldUseMouseEventForSelection(event.event()))</span>
<span class="line-added"> 740             return false;</span>
<span class="line-added"> 741     }</span>
<span class="line-added"> 742 </span>
 743     if (!node || !node-&gt;renderer())
 744         return true;
 745 
 746     return node-&gt;canStartSelection() || Position::nodeIsUserSelectAll(node);
 747 }
 748 
 749 bool EventHandler::handleMousePressEvent(const MouseEventWithHitTestResults&amp; event)
 750 {
 751     Ref&lt;Frame&gt; protectedFrame(m_frame);
 752 
 753 #if ENABLE(DRAG_SUPPORT)
 754     // Reset drag state.
 755     dragState().source = nullptr;
 756 #endif
 757 
 758 #if !ENABLE(IOS_TOUCH_EVENTS)
 759     cancelFakeMouseMoveEvent();
 760 #endif
 761 
 762     m_frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
 763 
 764     if (ScrollView* scrollView = m_frame.view()) {
 765         if (scrollView-&gt;isPointInScrollbarCorner(event.event().position()))
 766             return false;
 767     }
 768 
 769     bool singleClick = event.event().clickCount() &lt;= 1;
 770 
 771     // If we got the event back, that must mean it wasn&#39;t prevented,
 772     // so it&#39;s allowed to start a drag or selection if it wasn&#39;t in a scrollbar.
<span class="line-modified"> 773     m_mouseDownMayStartSelect = canMouseDownStartSelect(event) &amp;&amp; !event.scrollbar();</span>
 774 
 775 #if ENABLE(DRAG_SUPPORT)
 776     // Careful that the drag starting logic stays in sync with eventMayStartDrag()
 777     // FIXME: eventMayStartDrag() does not check for shift key press, link or image event targets.
 778     // Bug: https://bugs.webkit.org/show_bug.cgi?id=155390
 779 
 780     // Single mouse down on links or images can always trigger drag-n-drop.
 781     bool isMouseDownOnLinkOrImage = event.isOverLink() || event.hitTestResult().image();
 782     m_mouseDownMayStartDrag = singleClick &amp;&amp; (!event.event().shiftKey() || isMouseDownOnLinkOrImage) &amp;&amp; shouldAllowMouseDownToStartDrag();
 783 #endif
 784 
 785     m_mouseDownWasSingleClickInSelection = false;
 786 
 787     m_mouseDown = event.event();
 788 
 789     if (m_immediateActionStage != ImmediateActionStage::PerformedHitTest)
 790         m_immediateActionStage = ImmediateActionStage::None;
 791 
 792     if (event.isOverWidget() &amp;&amp; passWidgetMouseDownEventToWidget(event))
 793         return true;
</pre>
<hr />
<pre>
1324         return 0;
1325     return subframeForTargetNode(hitTestResult.targetNode());
1326 }
1327 
1328 Frame* EventHandler::subframeForTargetNode(Node* node)
1329 {
1330     if (!node)
1331         return nullptr;
1332 
1333     auto renderer = node-&gt;renderer();
1334     if (!is&lt;RenderWidget&gt;(renderer))
1335         return nullptr;
1336 
1337     Widget* widget = downcast&lt;RenderWidget&gt;(*renderer).widget();
1338     if (!is&lt;FrameView&gt;(widget))
1339         return nullptr;
1340 
1341     return &amp;downcast&lt;FrameView&gt;(*widget).frame();
1342 }
1343 

1344 static bool isSubmitImage(Node* node)
1345 {
1346     return is&lt;HTMLInputElement&gt;(node) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*node).isImageButton();
1347 }
1348 
1349 // Returns true if the node&#39;s editable block is not current focused for editing
1350 static bool nodeIsNotBeingEdited(const Node&amp; node, const Frame&amp; frame)
1351 {
1352     return frame.selection().selection().rootEditableElement() != node.rootEditableElement();
1353 }
1354 
1355 bool EventHandler::useHandCursor(Node* node, bool isOverLink, bool shiftKey)
1356 {
1357     if (!node)
1358         return false;
1359 
1360     bool editable = node-&gt;hasEditableStyle();
1361     bool editableLinkEnabled = false;
1362 
1363     // If the link is editable, then we need to check the settings to see whether or not the link should be followed
</pre>
<hr />
<pre>
1380         case EditableLinkOnlyLiveWithShiftKey:
1381             editableLinkEnabled = shiftKey;
1382             break;
1383         }
1384     }
1385 
1386     return ((isOverLink || isSubmitImage(node)) &amp;&amp; (!editable || editableLinkEnabled));
1387 }
1388 
1389 void EventHandler::cursorUpdateTimerFired()
1390 {
1391     ASSERT(m_frame.document());
1392     updateCursor();
1393 }
1394 
1395 void EventHandler::updateCursor()
1396 {
1397     if (m_mousePositionIsUnknown)
1398         return;
1399 
<span class="line-added">1400     if (Page* page = m_frame.page()) {</span>
<span class="line-added">1401         if (!page-&gt;chrome().client().supportsSettingCursor())</span>
<span class="line-added">1402             return;</span>
<span class="line-added">1403     }</span>
<span class="line-added">1404 </span>
1405     FrameView* view = m_frame.view();
1406     if (!view)
1407         return;
1408 
1409     auto* document = m_frame.document();
1410     if (!document)
1411         return;
1412 
1413     if (!view-&gt;shouldSetCursor())
1414         return;
1415 
1416     bool shiftKey;
1417     bool ctrlKey;
1418     bool altKey;
1419     bool metaKey;
1420     PlatformKeyboardEvent::getCurrentModifierState(shiftKey, ctrlKey, altKey, metaKey);
1421 
1422     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::AllowFrameScrollbars);
1423     HitTestResult result(view-&gt;windowToContents(m_lastKnownMousePosition));
1424     document-&gt;hitTest(request, result);
</pre>
<hr />
<pre>
1605         return eastWestResizeCursor();
1606     case CursorType::NSResize:
1607         return northSouthResizeCursor();
1608     case CursorType::NESWResize:
1609         return northEastSouthWestResizeCursor();
1610     case CursorType::NWSEResize:
1611         return northWestSouthEastResizeCursor();
1612     case CursorType::ColumnResize:
1613         return columnResizeCursor();
1614     case CursorType::RowResize:
1615         return rowResizeCursor();
1616     case CursorType::AllScroll:
1617         return moveCursor();
1618     case CursorType::ZoomIn:
1619         return zoomInCursor();
1620     case CursorType::ZoomOut:
1621         return zoomOutCursor();
1622     }
1623     return pointerCursor();
1624 }

1625 
1626 #if ENABLE(CURSOR_VISIBILITY)
1627 void EventHandler::startAutoHideCursorTimer()
1628 {
1629     Page* page = m_frame.page();
1630     if (!page)
1631         return;
1632 
1633     m_autoHideCursorTimer.startOneShot(page-&gt;settings().timeWithoutMouseMovementBeforeHidingControls());
1634 
1635 #if !ENABLE(IOS_TOUCH_EVENTS)
1636     // The fake mouse move event screws up the auto-hide feature (by resetting the auto-hide timer)
1637     // so cancel any pending fake mouse moves.
1638     if (m_fakeMouseMoveEventTimer.isActive())
1639         m_fakeMouseMoveEventTimer.stop();
1640 #endif
1641 }
1642 
1643 void EventHandler::cancelAutoHideCursorTimer()
1644 {
</pre>
<hr />
<pre>
1898 
1899     HitTestResult hoveredNode = HitTestResult(LayoutPoint());
1900     bool result = handleMouseMoveEvent(event, &amp;hoveredNode);
1901 
1902     Page* page = m_frame.page();
1903     if (!page)
1904         return result;
1905 
1906     if (auto scrolledArea = enclosingScrollableArea(hoveredNode.innerNode())) {
1907         if (FrameView* frameView = m_frame.view()) {
1908             if (frameView-&gt;containsScrollableArea(scrolledArea))
1909                 scrolledArea-&gt;mouseMovedInContentArea();
1910         }
1911     }
1912 
1913     if (FrameView* frameView = m_frame.view())
1914         frameView-&gt;mouseMovedInContentArea();
1915 
1916     hoveredNode.setToNonUserAgentShadowAncestor();
1917     page-&gt;chrome().mouseDidMoveOverElement(hoveredNode, event.modifierFlags());

1918     return result;
1919 }
1920 
1921 bool EventHandler::passMouseMovedEventToScrollbars(const PlatformMouseEvent&amp; event)
1922 {
1923     HitTestResult hoveredNode;
1924     return handleMouseMoveEvent(event, &amp;hoveredNode, true);
1925 }
1926 
1927 bool EventHandler::handleMouseMoveEvent(const PlatformMouseEvent&amp; platformMouseEvent, HitTestResult* hoveredNode, bool onlyUpdateScrollbars)
1928 {
1929 #if ENABLE(TOUCH_EVENTS)
1930     bool defaultPrevented = dispatchSyntheticTouchEventIfEnabled(platformMouseEvent);
1931     if (defaultPrevented)
1932         return true;
1933 #endif
1934 
1935     Ref&lt;Frame&gt; protectedFrame(m_frame);
1936     RefPtr&lt;FrameView&gt; protector(m_frame.view());
1937 
1938 #if ENABLE(POINTER_LOCK)
1939     if (m_frame.page()-&gt;pointerLockController().isLocked()) {
1940         m_frame.page()-&gt;pointerLockController().dispatchLockedMouseEvent(platformMouseEvent, eventNames().mousemoveEvent);
1941         return true;
1942     }
1943 #endif
1944 
1945     setLastKnownMousePosition(platformMouseEvent);
1946 
1947     if (m_hoverTimer.isActive())
1948         m_hoverTimer.stop();
1949 

1950     m_cursorUpdateTimer.stop();

1951 
1952 #if !ENABLE(IOS_TOUCH_EVENTS)
1953     cancelFakeMouseMoveEvent();
1954 #endif
1955 
1956     if (m_svgPan) {
1957         downcast&lt;SVGDocument&gt;(*m_frame.document()).updatePan(m_frame.view()-&gt;windowToContents(m_lastKnownMousePosition));
1958         return true;
1959     }
1960 
1961     if (m_frameSetBeingResized)
1962         return !dispatchMouseEvent(eventNames().mousemoveEvent, m_frameSetBeingResized.get(), false, 0, platformMouseEvent, false);
1963 
1964     // On iOS, our scrollbars are managed by UIKit.
1965 #if !PLATFORM(IOS_FAMILY)
1966     // Send events right to a scrollbar if the mouse is pressed.
1967     if (m_lastScrollbarUnderMouse &amp;&amp; m_mousePressed)
1968         return m_lastScrollbarUnderMouse-&gt;mouseMoved(platformMouseEvent);
1969 #endif
1970 
</pre>
<hr />
<pre>
2009     }
2010 
2011     bool swallowEvent = false;
2012     RefPtr&lt;Frame&gt; newSubframe = m_capturingMouseEventsElement.get() ? subframeForTargetNode(m_capturingMouseEventsElement.get()) : subframeForHitTestResult(mouseEvent);
2013 
2014     // We want mouseouts to happen first, from the inside out.  First send a move event to the last subframe so that it will fire mouseouts.
2015     if (m_lastMouseMoveEventSubframe &amp;&amp; m_lastMouseMoveEventSubframe-&gt;tree().isDescendantOf(&amp;m_frame) &amp;&amp; m_lastMouseMoveEventSubframe != newSubframe)
2016         passMouseMoveEventToSubframe(mouseEvent, m_lastMouseMoveEventSubframe.get());
2017 
2018     if (newSubframe) {
2019         // Update over/out state before passing the event to the subframe.
2020         updateMouseEventTargetNode(mouseEvent.targetNode(), platformMouseEvent, FireMouseOverOut::Yes);
2021 
2022         // Event dispatch in updateMouseEventTargetNode may have caused the subframe of the target
2023         // node to be detached from its FrameView, in which case the event should not be passed.
2024         if (newSubframe-&gt;view())
2025             swallowEvent |= passMouseMoveEventToSubframe(mouseEvent, newSubframe.get(), hoveredNode);
2026     }
2027 
2028     if (!newSubframe || mouseEvent.scrollbar()) {

2029         if (auto* view = m_frame.view())
2030             updateCursor(*view, mouseEvent.hitTestResult(), platformMouseEvent.shiftKey());

2031     }
2032 
2033     m_lastMouseMoveEventSubframe = newSubframe;
2034 
2035     if (swallowEvent)
2036         return true;
2037 
2038     swallowEvent = !dispatchMouseEvent(eventNames().mousemoveEvent, mouseEvent.targetNode(), false, 0, platformMouseEvent, true);
2039 #if ENABLE(DRAG_SUPPORT)
2040     if (!swallowEvent)
2041         swallowEvent = handleMouseDraggedEvent(mouseEvent);
2042 #endif
2043 
2044     return swallowEvent;
2045 }
2046 
2047 bool EventHandler::shouldSendMouseEventsToInactiveWindows() const
2048 {
2049 #if PLATFORM(GTK)
2050     return true;
</pre>
<hr />
<pre>
2241     Frame&amp; focusFrame = m_frame.page()-&gt;focusController().focusedOrMainFrame();
2242     // Do not paste here if the focus was moved somewhere else.
2243     if (&amp;m_frame == &amp;focusFrame &amp;&amp; m_frame.editor().client()-&gt;supportsGlobalSelection())
2244         return m_frame.editor().command(&quot;PasteGlobalSelection&quot;_s).execute();
2245 
2246     return false;
2247 }
2248 
2249 #if ENABLE(DRAG_SUPPORT)
2250 
2251 bool EventHandler::dispatchDragEvent(const AtomString&amp; eventType, Element&amp; dragTarget, const PlatformMouseEvent&amp; event, DataTransfer&amp; dataTransfer)
2252 {
2253     Ref&lt;Frame&gt; protectedFrame(m_frame);
2254     FrameView* view = m_frame.view();
2255 
2256     // FIXME: We might want to dispatch a dragleave even if the view is gone.
2257     if (!view)
2258         return false;
2259 
2260     view-&gt;disableLayerFlushThrottlingTemporarilyForInteraction();
<span class="line-modified">2261 </span>
<span class="line-modified">2262     auto dragEvent = DragEvent::create(eventType, Event::CanBubble::Yes, Event::IsCancelable::Yes, Event::IsComposed::Yes,</span>
2263         event.timestamp().approximateMonotonicTime(), &amp;m_frame.windowProxy(), 0,
2264         event.globalPosition(), event.position(),
2265 #if ENABLE(POINTER_LOCK)
2266         event.movementDelta(),
2267 #else
2268         { },
2269 #endif
2270         event.modifiers(), 0, 0, nullptr, event.force(), NoTap, &amp;dataTransfer);
2271 
<span class="line-modified">2272     dragTarget.dispatchEvent(dragEvent);</span>
<span class="line-modified">2273     return dragEvent-&gt;defaultPrevented();</span>
2274 }
2275 
2276 static bool targetIsFrame(Node* target, Frame*&amp; frame)
2277 {
2278     if (!is&lt;HTMLFrameElementBase&gt;(target))
2279         return false;
2280 
2281     frame = downcast&lt;HTMLFrameElementBase&gt;(*target).contentFrame();
2282     return true;
2283 }
2284 
2285 static DragOperation convertDropZoneOperationToDragOperation(const String&amp; dragOperation)
2286 {
2287     if (dragOperation == &quot;copy&quot;)
2288         return DragOperationCopy;
2289     if (dragOperation == &quot;move&quot;)
2290         return DragOperationMove;
2291     if (dragOperation == &quot;link&quot;)
2292         return DragOperationLink;
2293     return DragOperationNone;
</pre>
<hr />
<pre>
2372             newTarget = targetNode-&gt;parentOrShadowHostElement();
2373         else
2374             newTarget = downcast&lt;Element&gt;(targetNode);
2375     }
2376 
2377     m_autoscrollController-&gt;updateDragAndDrop(newTarget.get(), event.position(), event.timestamp());
2378 
2379     DragTargetResponse response;
2380     if (m_dragTarget != newTarget) {
2381         // FIXME: this ordering was explicitly chosen to match WinIE. However,
2382         // it is sometimes incorrect when dragging within subframes, as seen with
2383         // LayoutTests/fast/events/drag-in-frames.html.
2384         //
2385         // Moreover, this ordering conforms to section 7.9.4 of the HTML 5 spec. &lt;http://dev.w3.org/html5/spec/Overview.html#drag-and-drop-processing-model&gt;.
2386         Frame* targetFrame;
2387         if (targetIsFrame(newTarget.get(), targetFrame)) {
2388             if (targetFrame)
2389                 response = targetFrame-&gt;eventHandler().updateDragAndDrop(event, makePasteboard, sourceOperation, draggingFiles);
2390         } else if (newTarget) {
2391             // As per section 7.9.4 of the HTML 5 spec., we must always fire a drag event before firing a dragenter, dragleave, or dragover event.
<span class="line-modified">2392             dispatchEventToDragSourceElement(eventNames().dragEvent, event);</span>

2393             response = dispatchDragEnterOrDragOverEvent(eventNames().dragenterEvent, *newTarget, event, makePasteboard(), sourceOperation, draggingFiles);
2394         }
2395 
2396         if (targetIsFrame(m_dragTarget.get(), targetFrame)) {
2397             // FIXME: Recursing again here doesn&#39;t make sense if the newTarget and m_dragTarget were in the same frame.
2398             if (targetFrame)
2399                 response = targetFrame-&gt;eventHandler().updateDragAndDrop(event, makePasteboard, sourceOperation, draggingFiles);
2400         } else if (m_dragTarget) {
2401             auto dataTransfer = DataTransfer::createForUpdatingDropTarget(m_dragTarget-&gt;document(), makePasteboard(), sourceOperation, draggingFiles);
2402             dispatchDragEvent(eventNames().dragleaveEvent, *m_dragTarget, event, dataTransfer.get());
2403             dataTransfer-&gt;makeInvalidForSecurity();
2404         }
2405 
2406         if (newTarget) {
2407             // We do not explicitly call dispatchDragEvent here because it could ultimately result in the appearance that
2408             // two dragover events fired. So, we mark that we should only fire a dragover event on the next call to this function.
2409             m_shouldOnlyFireDragOverEvent = true;
2410         }
2411     } else {
2412         Frame* targetFrame;
2413         if (targetIsFrame(newTarget.get(), targetFrame)) {
2414             if (targetFrame)
2415                 response = targetFrame-&gt;eventHandler().updateDragAndDrop(event, makePasteboard, sourceOperation, draggingFiles);
2416         } else if (newTarget) {
2417             // Note, when dealing with sub-frames, we may need to fire only a dragover event as a drag event may have been fired earlier.
<span class="line-modified">2418             if (!m_shouldOnlyFireDragOverEvent)</span>
<span class="line-modified">2419                 dispatchEventToDragSourceElement(eventNames().dragEvent, event);</span>
2420             response = dispatchDragEnterOrDragOverEvent(eventNames().dragoverEvent, *newTarget, event, makePasteboard(), sourceOperation, draggingFiles);
2421             m_shouldOnlyFireDragOverEvent = false;
2422         }
2423     }
2424     m_dragTarget = WTFMove(newTarget);
2425     return response;
2426 }
2427 
2428 void EventHandler::cancelDragAndDrop(const PlatformMouseEvent&amp; event, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; pasteboard, DragOperation sourceOperation, bool draggingFiles)
2429 {
2430     Ref&lt;Frame&gt; protectedFrame(m_frame);
2431 
2432     Frame* targetFrame;
2433     if (targetIsFrame(m_dragTarget.get(), targetFrame)) {
2434         if (targetFrame)
2435             targetFrame-&gt;eventHandler().cancelDragAndDrop(event, WTFMove(pasteboard), sourceOperation, draggingFiles);
2436     } else if (m_dragTarget) {
<span class="line-modified">2437         dispatchEventToDragSourceElement(eventNames().dragEvent, event);</span>

2438 
2439         auto dataTransfer = DataTransfer::createForUpdatingDropTarget(m_dragTarget-&gt;document(), WTFMove(pasteboard), sourceOperation, draggingFiles);
2440         dispatchDragEvent(eventNames().dragleaveEvent, *m_dragTarget, event, dataTransfer.get());
2441         dataTransfer-&gt;makeInvalidForSecurity();
2442     }
2443     clearDragState();
2444 }
2445 
2446 bool EventHandler::performDragAndDrop(const PlatformMouseEvent&amp; event, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; pasteboard, DragOperation sourceOperation, bool draggingFiles)
2447 {
2448     Ref&lt;Frame&gt; protectedFrame(m_frame);
2449 
2450     Frame* targetFrame;
2451     bool preventedDefault = false;
2452     if (targetIsFrame(m_dragTarget.get(), targetFrame)) {
2453         if (targetFrame)
2454             preventedDefault = targetFrame-&gt;eventHandler().performDragAndDrop(event, WTFMove(pasteboard), sourceOperation, draggingFiles);
2455     } else if (m_dragTarget) {
2456         auto dataTransfer = DataTransfer::createForDrop(m_dragTarget-&gt;document(), WTFMove(pasteboard), sourceOperation, draggingFiles);
2457         preventedDefault = dispatchDragEvent(eventNames().dropEvent, *m_dragTarget, event, dataTransfer);
</pre>
<hr />
<pre>
2600             if (m_lastElementUnderMouse)
2601                 m_lastElementUnderMouse-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseoutEvent, 0, m_elementUnderMouse.get());
2602 
2603             for (auto&amp; chain : leftElementsChain) {
2604                 if (hasCapturingMouseLeaveListener || chain-&gt;hasEventListeners(eventNames().pointerleaveEvent) || chain-&gt;hasEventListeners(eventNames().mouseleaveEvent))
2605                     chain-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseleaveEvent, 0, m_elementUnderMouse.get());
2606             }
2607 
2608             if (m_elementUnderMouse)
2609                 m_elementUnderMouse-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseoverEvent, 0, m_lastElementUnderMouse.get());
2610 
2611             for (auto&amp; chain : WTF::makeReversedRange(enteredElementsChain)) {
2612                 if (hasCapturingMouseEnterListener || chain-&gt;hasEventListeners(eventNames().pointerenterEvent) || chain-&gt;hasEventListeners(eventNames().mouseenterEvent))
2613                     chain-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseenterEvent, 0, m_lastElementUnderMouse.get());
2614             }
2615         }
2616         m_lastElementUnderMouse = m_elementUnderMouse;
2617     }
2618 }
2619 
<span class="line-added">2620 static RefPtr&lt;Element&gt; findFirstMouseFocusableElementInComposedTree(Element&amp; host)</span>
<span class="line-added">2621 {</span>
<span class="line-added">2622     ASSERT(host.shadowRoot());</span>
<span class="line-added">2623     for (auto&amp; node : composedTreeDescendants(host)) {</span>
<span class="line-added">2624         if (!is&lt;Element&gt;(node))</span>
<span class="line-added">2625             continue;</span>
<span class="line-added">2626         auto&amp; element = downcast&lt;Element&gt;(node);</span>
<span class="line-added">2627         if (element.isMouseFocusable())</span>
<span class="line-added">2628             return &amp;element;</span>
<span class="line-added">2629     }</span>
<span class="line-added">2630     return nullptr;</span>
<span class="line-added">2631 }</span>
<span class="line-added">2632 </span>
2633 bool EventHandler::dispatchMouseEvent(const AtomString&amp; eventType, Node* targetNode, bool /*cancelable*/, int clickCount, const PlatformMouseEvent&amp; platformMouseEvent, bool setUnder)
2634 {
2635     Ref&lt;Frame&gt; protectedFrame(m_frame);
2636 
2637     if (auto* view = m_frame.view())
2638         view-&gt;disableLayerFlushThrottlingTemporarilyForInteraction();
2639 
2640     updateMouseEventTargetNode(targetNode, platformMouseEvent, setUnder ? FireMouseOverOut::Yes : FireMouseOverOut::No);
2641 
2642     if (m_elementUnderMouse &amp;&amp; !m_elementUnderMouse-&gt;dispatchMouseEvent(platformMouseEvent, eventType, clickCount))
2643         return false;
2644 
2645     if (eventType != eventNames().mousedownEvent)
2646         return true;
2647 
2648     // If clicking on a frame scrollbar, do not make any change to which element is focused.
2649     auto* view = m_frame.view();
2650     if (view &amp;&amp; view-&gt;scrollbarAtPoint(platformMouseEvent.position()))
2651         return true;
2652 
2653     // The layout needs to be up to date to determine if an element is focusable.
2654     m_frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
2655 
2656     // Remove focus from the currently focused element when a link or button is clicked.
2657     // This is expected by some sites that rely on change event handlers running
2658     // from form fields before the button click is processed, behavior that was inherited
2659     // from the user interface of Windows, where pushing a button moves focus to the button.
2660 
2661     // Walk up the DOM tree to search for an element to focus.
2662     RefPtr&lt;Element&gt; element;
2663     for (element = m_elementUnderMouse.get(); element; element = element-&gt;parentElementInComposedTree()) {
<span class="line-added">2664         if (auto* shadowRoot = element-&gt;shadowRoot()) {</span>
<span class="line-added">2665             if (shadowRoot-&gt;delegatesFocus()) {</span>
<span class="line-added">2666                 element = findFirstMouseFocusableElementInComposedTree(*element);</span>
<span class="line-added">2667                 break;</span>
<span class="line-added">2668             }</span>
<span class="line-added">2669         }</span>
2670         if (element-&gt;isMouseFocusable())
2671             break;
2672     }
2673 
2674     // To fix &lt;rdar://problem/4895428&gt; Can&#39;t drag selected ToDo, we don&#39;t focus an
2675     // element on mouse down if it&#39;s selected and inside a focused element. It will be
2676     // focused if the user does a mouseup over it, however, because the mouseup
2677     // will set a selection inside it, which will also set the focused element.
2678     if (element &amp;&amp; m_frame.selection().isRange()) {
2679         if (auto range = m_frame.selection().toNormalizedRange()) {
2680             auto result = range-&gt;compareNode(*element);
2681             if (!result.hasException() &amp;&amp; result.releaseReturnValue() == Range::NODE_INSIDE &amp;&amp; element-&gt;isDescendantOf(m_frame.document()-&gt;focusedElement()))
2682                 return true;
2683         }
2684     }
2685 
2686     // Only change the focus when clicking scrollbars if it can be transferred to a mouse focusable node.
2687     if (!element &amp;&amp; isInsideScrollbar(platformMouseEvent.position()))
2688         return false;
2689 
</pre>
<hr />
<pre>
2898     if (auto filter = page-&gt;wheelEventDeltaFilter())
2899         filter-&gt;endFilteringDeltas();
2900 }
2901 
2902 void EventHandler::defaultWheelEventHandler(Node* startNode, WheelEvent&amp; wheelEvent)
2903 {
2904     if (!startNode)
2905         return;
2906 
2907     auto protectedFrame = makeRef(m_frame);
2908 
2909     FloatSize filteredPlatformDelta(wheelEvent.deltaX(), wheelEvent.deltaY());
2910     FloatSize filteredVelocity;
2911     if (auto platformWheelEvent = wheelEvent.underlyingPlatformEvent()) {
2912         filteredPlatformDelta.setWidth(platformWheelEvent-&gt;deltaX());
2913         filteredPlatformDelta.setHeight(platformWheelEvent-&gt;deltaY());
2914     }
2915 
2916 #if PLATFORM(MAC)
2917     ScrollLatchingState* latchedState = m_frame.page() ? m_frame.page()-&gt;latchingState() : nullptr;
<span class="line-modified">2918     RefPtr&lt;Element&gt; stopElement = latchedState ? latchedState-&gt;previousWheelScrolledElement() : nullptr;</span>
2919 
2920     if (m_frame.page() &amp;&amp; m_frame.page()-&gt;wheelEventDeltaFilter()-&gt;isFilteringDeltas()) {
2921         filteredPlatformDelta = m_frame.page()-&gt;wheelEventDeltaFilter()-&gt;filteredDelta();
2922         filteredVelocity = m_frame.page()-&gt;wheelEventDeltaFilter()-&gt;filteredVelocity();
2923     }
2924 #else
<span class="line-modified">2925     RefPtr&lt;Element&gt; stopElement;</span>
2926 #endif
2927 
<span class="line-modified">2928     if (handleWheelEventInAppropriateEnclosingBox(startNode, wheelEvent, stopElement, filteredPlatformDelta, filteredVelocity))</span>
2929         wheelEvent.setDefaultHandled();
2930 
2931 #if PLATFORM(MAC)
2932     if (latchedState &amp;&amp; !latchedState-&gt;wheelEventElement())
<span class="line-modified">2933         latchedState-&gt;setPreviousWheelScrolledElement(WTFMove(stopElement));</span>
2934 #endif
2935 }
2936 
<span class="line-modified">2937 #if ENABLE(CONTEXT_MENU_EVENT)</span>
2938 bool EventHandler::sendContextMenuEvent(const PlatformMouseEvent&amp; event)
2939 {
2940     Ref&lt;Frame&gt; protectedFrame(m_frame);
2941 
2942     Document* doc = m_frame.document();
2943     FrameView* view = m_frame.view();
2944     if (!view)
2945         return false;
2946 
2947     // Caret blinking is normally un-suspended in handleMouseReleaseEvent, but we
2948     // won&#39;t receive that event once the context menu is up.
2949     m_frame.selection().setCaretBlinkingSuspended(false);
2950     // Clear mouse press state to avoid initiating a drag while context menu is up.
2951     m_mousePressed = false;
2952     bool swallowEvent;
2953     LayoutPoint viewportPos = view-&gt;windowToContents(event.position());
2954     HitTestRequest request(HitTestRequest::Active | HitTestRequest::DisallowUserAgentShadowContent);
2955     MouseEventWithHitTestResults mouseEvent = doc-&gt;prepareMouseEvent(request, viewportPos, event);
2956 
2957     // Do not show context menus when clicking on scrollbars.
</pre>
<hr />
<pre>
3032         targetNode = doc;
3033 
3034     // Use the focused node as the target for hover and active.
3035     HitTestResult result(position);
3036     result.setInnerNode(targetNode);
3037     doc-&gt;updateHoverActiveState(HitTestRequest::Active | HitTestRequest::DisallowUserAgentShadowContent, result.targetElement());
3038 
3039     // The contextmenu event is a mouse event even when invoked using the keyboard.
3040     // This is required for web compatibility.
3041 
3042 #if OS(WINDOWS)
3043     PlatformEvent::Type eventType = PlatformEvent::MouseReleased;
3044 #else
3045     PlatformEvent::Type eventType = PlatformEvent::MousePressed;
3046 #endif
3047 
3048     PlatformMouseEvent platformMouseEvent(position, globalPosition, RightButton, eventType, 1, false, false, false, false, WallTime::now(), ForceAtClick, NoTap);
3049 
3050     return sendContextMenuEvent(platformMouseEvent);
3051 }
<span class="line-modified">3052 #endif // ENABLE(CONTEXT_MENU_EVENT)</span>
3053 
3054 void EventHandler::scheduleHoverStateUpdate()
3055 {
3056     if (!m_hoverTimer.isActive())
3057         m_hoverTimer.startOneShot(0_s);
3058 }
3059 

3060 void EventHandler::scheduleCursorUpdate()
3061 {
<span class="line-added">3062     if (Page* page = m_frame.page()) {</span>
<span class="line-added">3063         if (!page-&gt;chrome().client().supportsSettingCursor())</span>
<span class="line-added">3064             return;</span>
<span class="line-added">3065     }</span>
<span class="line-added">3066 </span>
3067     if (!m_cursorUpdateTimer.isActive())
3068         m_cursorUpdateTimer.startOneShot(cursorUpdateInterval);
3069 }

3070 
3071 void EventHandler::dispatchFakeMouseMoveEventSoon()
3072 {
3073 #if !ENABLE(IOS_TOUCH_EVENTS)
3074     if (m_mousePressed)
3075         return;
3076 
3077     if (m_mousePositionIsUnknown)
3078         return;
3079 
3080     if (Page* page = m_frame.page()) {
3081         if (!page-&gt;chrome().client().shouldDispatchFakeMouseMoveEvents())
3082             return;
3083     }
3084 
3085     // If the content has ever taken longer than fakeMouseMoveShortInterval we
3086     // reschedule the timer and use a longer time. This will cause the content
3087     // to receive these moves only after the user is done scrolling, reducing
3088     // pauses during the scroll.
3089     if (m_fakeMouseMoveEventTimer.isActive())
</pre>
<hr />
<pre>
3345     // 2. if an input method handles the event, its keyCode is set to 229 in keydown event.
3346     m_frame.editor().handleInputMethodKeydown(keydown.get());
3347 
3348     bool handledByInputMethod = keydown-&gt;defaultHandled();
3349 
3350     if (handledByInputMethod) {
3351         keyDownEvent.setWindowsVirtualKeyCode(CompositionEventKeyCode);
3352         keydown = KeyboardEvent::create(keyDownEvent, &amp;m_frame.windowProxy());
3353         keydown-&gt;setTarget(element);
3354         keydown-&gt;setIsDefaultEventHandlerIgnored();
3355     }
3356 
3357     if (accessibilityPreventsEventPropagation(keydown))
3358         keydown-&gt;stopPropagation();
3359 
3360 #if PLATFORM(IOS_FAMILY)
3361     DeferDOMTimersForScope deferralScope { m_frame.document()-&gt;quirks().needsDeferKeyDownAndKeyPressTimersUntilNextEditingCommand() };
3362 #endif
3363 
3364     element-&gt;dispatchEvent(keydown);
<span class="line-modified">3365     if (handledByInputMethod) {</span>
<span class="line-added">3366         m_frame.editor().didDispatchInputMethodKeydown(keydown.get());</span>
3367         return true;
<span class="line-added">3368     }</span>
3369 
3370     // If frame changed as a result of keydown dispatch, then return early to avoid sending a subsequent keypress message to the new frame.
3371     bool changedFocusedFrame = m_frame.page() &amp;&amp; &amp;m_frame != &amp;m_frame.page()-&gt;focusController().focusedOrMainFrame();
3372     bool keydownResult = keydown-&gt;defaultHandled() || keydown-&gt;defaultPrevented() || changedFocusedFrame;
3373     if (keydownResult &amp;&amp; !backwardCompatibilityMode)
3374         return keydownResult;
3375 
3376     // Focus may have changed during keydown handling, so refetch element.
3377     // But if we are dispatching a fake backward compatibility keypress, then we pretend that the keypress happened on the original element.
3378     if (!keydownResult) {
3379         element = eventTargetElementForDocument(m_frame.document());
3380         if (!element)
3381             return false;
3382     }
3383 
3384     PlatformKeyboardEvent keyPressEvent = initialKeyEvent;
3385     keyPressEvent.disambiguateKeyDownEvent(PlatformEvent::Char, backwardCompatibilityMode);
3386     if (keyPressEvent.text().isEmpty())
3387         return keydownResult;
3388     auto keypress = KeyboardEvent::create(keyPressEvent, &amp;m_frame.windowProxy());
</pre>
<hr />
<pre>
3638     else {
3639         Position startPosition(dragSource.get(), Position::PositionIsBeforeAnchor);
3640         Position endPosition(dragSource.get(), Position::PositionIsAfterAnchor);
3641         draggedContentRange = Range::create(dragSource-&gt;document(), startPosition, endPosition);
3642     }
3643 
3644     if (draggedContentRange) {
3645         draggedContentRange-&gt;ownerDocument().markers().addDraggedContentMarker(*draggedContentRange);
3646         if (auto* renderer = m_frame.contentRenderer())
3647             renderer-&gt;repaintRootContents();
3648     }
3649 #endif
3650 }
3651 
3652 void EventHandler::dragSourceEndedAt(const PlatformMouseEvent&amp; event, DragOperation operation, MayExtendDragSession mayExtendDragSession)
3653 {
3654     // Send a hit test request so that RenderLayer gets a chance to update the :hover and :active pseudoclasses.
3655     HitTestRequest request(HitTestRequest::Release | HitTestRequest::DisallowUserAgentShadowContent);
3656     prepareMouseEvent(request, event);
3657 
<span class="line-modified">3658     if (shouldDispatchEventsToDragSourceElement()) {</span>
3659         dragState().dataTransfer-&gt;setDestinationOperation(operation);
<span class="line-modified">3660         dispatchEventToDragSourceElement(eventNames().dragendEvent, event);</span>
3661     }
3662     invalidateDataTransfer();
3663 
3664     if (mayExtendDragSession == MayExtendDragSession::No) {
3665         if (auto* page = m_frame.page())
3666             removeDraggedContentDocumentMarkersFromAllFramesInPage(*page);
3667     }
3668 
3669     dragState().source = nullptr;
3670     // In case the drag was ended due to an escape key press we need to ensure
3671     // that consecutive mousemove events don&#39;t reinitiate the drag and drop.
3672     m_mouseDownMayStartDrag = false;
3673 }
3674 
3675 void EventHandler::updateDragStateAfterEditDragIfNeeded(Element&amp; rootEditableElement)
3676 {
3677     // If inserting the dragged contents removed the drag source, we still want to fire dragend at the root editable element.
3678     if (dragState().source &amp;&amp; !dragState().source-&gt;isConnected())
3679         dragState().source = &amp;rootEditableElement;
3680 }
3681 
<span class="line-modified">3682 bool EventHandler::shouldDispatchEventsToDragSourceElement()</span>
<span class="line-added">3683 {</span>
<span class="line-added">3684     return dragState().source &amp;&amp; dragState().dataTransfer &amp;&amp; dragState().shouldDispatchEvents;</span>
<span class="line-added">3685 }</span>
<span class="line-added">3686 </span>
<span class="line-added">3687 void EventHandler::dispatchEventToDragSourceElement(const AtomString&amp; eventType, const PlatformMouseEvent&amp; event)</span>
3688 {
<span class="line-modified">3689     if (shouldDispatchEventsToDragSourceElement())</span>
<span class="line-modified">3690         dispatchDragEvent(eventType, *dragState().source, event, *dragState().dataTransfer);</span>
3691 }
3692 
3693 bool EventHandler::dispatchDragStartEventOnSourceElement(DataTransfer&amp; dataTransfer)
3694 {
3695     return !dispatchDragEvent(eventNames().dragstartEvent, *dragState().source, m_mouseDown, dataTransfer) &amp;&amp; !m_frame.selection().selection().isInPasswordField();
3696 }
3697 
3698 static bool ExactlyOneBitSet(DragSourceAction n)
3699 {
3700     return n &amp;&amp; !(n &amp; (n - 1));
3701 }
3702 
3703 RefPtr&lt;Element&gt; EventHandler::draggedElement() const
3704 {
3705     return dragState().source;
3706 }
3707 
3708 bool EventHandler::handleDrag(const MouseEventWithHitTestResults&amp; event, CheckDragHysteresis checkDragHysteresis)
3709 {
3710     if (event.event().button() != LeftButton || event.event().type() != PlatformEvent::MouseMoved) {
</pre>
<hr />
<pre>
3772         ASSERT(ExactlyOneBitSet(static_cast&lt;DragSourceAction&gt;(dragState().type &amp; ~DragSourceActionSelection)));
3773 
3774         dragState().type = DragSourceActionSelection;
3775     }
3776 
3777     // We are starting a text/image/url drag, so the cursor should be an arrow
3778     if (FrameView* view = m_frame.view()) {
3779         // FIXME &lt;rdar://7577595&gt;: Custom cursors aren&#39;t supported during drag and drop (default to pointer).
3780         view-&gt;setCursor(pointerCursor());
3781     }
3782 
3783     if (checkDragHysteresis == ShouldCheckDragHysteresis &amp;&amp; !dragHysteresisExceeded(event.event().position()))
3784         return true;
3785 
3786     // Once we&#39;re past the hysteresis point, we don&#39;t want to treat this gesture as a click
3787     invalidateClick();
3788 
3789     DragOperation srcOp = DragOperationNone;
3790 
3791     // This does work only if we missed a dragEnd. Do it anyway, just to make sure the old dataTransfer gets numbed.
<span class="line-added">3792     // FIXME: Consider doing this earlier in this function as the earliest point we&#39;re sure it would be safe to drop an old drag.</span>
3793     invalidateDataTransfer();
3794 
<span class="line-modified">3795     dragState().dataTransfer = DataTransfer::createForDrag();</span>
3796     HasNonDefaultPasteboardData hasNonDefaultPasteboardData = HasNonDefaultPasteboardData::No;
3797 
3798     if (dragState().shouldDispatchEvents) {
3799         ASSERT(dragState().source);
3800         auto dragStartDataTransfer = DataTransfer::createForDragStartEvent(dragState().source-&gt;document());
3801         m_mouseDownMayStartDrag = dispatchDragStartEventOnSourceElement(dragStartDataTransfer);
3802         hasNonDefaultPasteboardData = dragStartDataTransfer-&gt;pasteboard().hasData() ? HasNonDefaultPasteboardData::Yes : HasNonDefaultPasteboardData::No;
3803         dragState().dataTransfer-&gt;moveDragState(WTFMove(dragStartDataTransfer));
3804 
3805         if (dragState().source &amp;&amp; dragState().type == DragSourceActionDHTML &amp;&amp; !dragState().dataTransfer-&gt;hasDragImage()) {
3806             dragState().source-&gt;document().updateStyleIfNeeded();
3807             if (auto* renderer = dragState().source-&gt;renderer()) {
3808                 auto absolutePosition = renderer-&gt;localToAbsolute();
3809                 auto delta = m_mouseDownPos - roundedIntPoint(absolutePosition);
3810                 dragState().dataTransfer-&gt;setDragImage(dragState().source.get(), delta.width(), delta.height());
3811             } else {
<span class="line-modified">3812                 dispatchEventToDragSourceElement(eventNames().dragendEvent, event.event());</span>
3813                 m_mouseDownMayStartDrag = false;
3814                 invalidateDataTransfer();
3815                 dragState().source = nullptr;
3816                 return true;
3817             }
3818         }
3819 
3820         dragState().dataTransfer-&gt;makeInvalidForSecurity();
3821 
3822         if (m_mouseDownMayStartDrag) {
3823             // Gather values from DHTML element, if it set any.
3824             srcOp = dragState().dataTransfer-&gt;sourceOperation();
3825 
3826             // Yuck, a draggedImage:moveTo: message can be fired as a result of kicking off the
3827             // drag with dragImage! Because of that dumb reentrancy, we may think we&#39;ve not
3828             // started the drag when that happens. So we have to assume it&#39;s started before we kick it off.
3829             dragState().dataTransfer-&gt;setDragHasStarted();
3830         }
3831     }
3832 
3833     if (m_mouseDownMayStartDrag) {
3834         Page* page = m_frame.page();
3835         m_didStartDrag = page &amp;&amp; page-&gt;dragController().startDrag(m_frame, dragState(), srcOp, event.event(), m_mouseDownPos, hasNonDefaultPasteboardData);
3836         // In WebKit2 we could re-enter this code and start another drag.
3837         // On OS X this causes problems with the ownership of the pasteboard and the promised types.
3838         if (m_didStartDrag) {
3839             m_mouseDownMayStartDrag = false;
3840             return true;
3841         }
<span class="line-modified">3842         if (shouldDispatchEventsToDragSourceElement()) {</span>
3843             // Drag was canned at the last minute. We owe dragSource a dragend event.
<span class="line-modified">3844             dispatchEventToDragSourceElement(eventNames().dragendEvent, event.event());</span>
3845             m_mouseDownMayStartDrag = false;
3846         }
3847     }
3848 
3849     if (!m_mouseDownMayStartDrag) {
3850         // Something failed to start the drag, clean up.
3851         invalidateDataTransfer();
3852         dragState().source = nullptr;
3853     }
3854 
3855     // No more default handling (like selection), whether we&#39;re past the hysteresis bounds or not
3856     return true;
3857 }
3858 #endif // ENABLE(DRAG_SUPPORT)
3859 
3860 bool EventHandler::mouseMovementExceedsThreshold(const FloatPoint&amp; viewportLocation, int pointsThreshold) const
3861 {
3862     FrameView* view = m_frame.view();
3863     if (!view)
3864         return false;
</pre>
<hr />
<pre>
4020     Page* page = m_frame.page();
4021     if (!page)
4022         return;
4023     if (!page-&gt;tabKeyCyclesThroughElements())
4024         return;
4025 
4026     FocusDirection focusDirection = event.shiftKey() ? FocusDirectionBackward : FocusDirectionForward;
4027 
4028     // Tabs can be used in design mode editing.
4029     if (m_frame.document()-&gt;inDesignMode())
4030         return;
4031 
4032     if (page-&gt;focusController().advanceFocus(focusDirection, &amp;event))
4033         event.setDefaultHandled();
4034 }
4035 
4036 void EventHandler::sendScrollEvent()
4037 {
4038     Ref&lt;Frame&gt; protectedFrame(m_frame);
4039     setFrameWasScrolledByUser();
<span class="line-modified">4040     if (!m_frame.view())</span>
<span class="line-modified">4041         return;</span>
<span class="line-added">4042     auto document = makeRefPtr(m_frame.document());</span>
<span class="line-added">4043     if (!document)</span>
<span class="line-added">4044         return;</span>
<span class="line-added">4045     document-&gt;addPendingScrollEventTarget(*document);</span>
4046 }
4047 
4048 void EventHandler::setFrameWasScrolledByUser()
4049 {
4050     FrameView* v = m_frame.view();
4051     if (v)
4052         v-&gt;setWasScrolledByUser(true);
4053 }
4054 
4055 bool EventHandler::passMousePressEventToScrollbar(MouseEventWithHitTestResults&amp; mouseEvent, Scrollbar* scrollbar)
4056 {
4057     if (!scrollbar || !scrollbar-&gt;enabled())
4058         return false;
4059     setFrameWasScrolledByUser();
4060     return scrollbar-&gt;mouseDown(mouseEvent.event());
4061 }
4062 
4063 // If scrollbar (under mouse) is different from last, send a mouse exited.
4064 void EventHandler::updateLastScrollbarUnderMouse(Scrollbar* scrollbar, SetOrClearLastScrollbar setOrClear)
4065 {
</pre>
</td>
</tr>
</table>
<center><a href="EditorClient.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EventHandler.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
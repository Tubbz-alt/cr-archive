<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/dom/MutationObserver.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011 Google Inc. All rights reserved.
  3  * Copyright (C) 2018 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 
 34 #include &quot;MutationObserver.h&quot;
 35 
 36 #include &quot;Document.h&quot;
 37 #include &quot;GCReachableRef.h&quot;
 38 #include &quot;HTMLSlotElement.h&quot;
 39 #include &quot;InspectorInstrumentation.h&quot;
 40 #include &quot;MutationCallback.h&quot;
 41 #include &quot;MutationObserverRegistration.h&quot;
 42 #include &quot;MutationRecord.h&quot;
 43 #include &quot;WindowEventLoop.h&quot;
 44 #include &lt;algorithm&gt;
 45 #include &lt;wtf/IsoMallocInlines.h&gt;
 46 #include &lt;wtf/MainThread.h&gt;
 47 #include &lt;wtf/NeverDestroyed.h&gt;
 48 
 49 namespace WebCore {
 50 
 51 WTF_MAKE_ISO_ALLOCATED_IMPL(MutationObserver);
 52 
 53 static unsigned s_observerPriority = 0;
 54 
 55 Ref&lt;MutationObserver&gt; MutationObserver::create(Ref&lt;MutationCallback&gt;&amp;&amp; callback)
 56 {
 57     ASSERT(isMainThread());
 58     return adoptRef(*new MutationObserver(WTFMove(callback)));
 59 }
 60 
 61 MutationObserver::MutationObserver(Ref&lt;MutationCallback&gt;&amp;&amp; callback)
 62     : m_callback(WTFMove(callback))
 63     , m_priority(s_observerPriority++)
 64 {
 65 }
 66 
 67 MutationObserver::~MutationObserver()
 68 {
 69     ASSERT(m_registrations.isEmpty());
 70 }
 71 
 72 bool MutationObserver::validateOptions(MutationObserverOptions options)
 73 {
 74     return (options &amp; (Attributes | CharacterData | ChildList))
 75         &amp;&amp; ((options &amp; Attributes) || !(options &amp; AttributeOldValue))
 76         &amp;&amp; ((options &amp; Attributes) || !(options &amp; AttributeFilter))
 77         &amp;&amp; ((options &amp; CharacterData) || !(options &amp; CharacterDataOldValue));
 78 }
 79 
 80 ExceptionOr&lt;void&gt; MutationObserver::observe(Node&amp; node, const Init&amp; init)
 81 {
 82     MutationObserverOptions options = 0;
 83 
 84     if (init.childList)
 85         options |= ChildList;
 86     if (init.subtree)
 87         options |= Subtree;
 88     if (init.attributeOldValue.valueOr(false))
 89         options |= AttributeOldValue;
 90     if (init.characterDataOldValue.valueOr(false))
 91         options |= CharacterDataOldValue;
 92 
 93     HashSet&lt;AtomString&gt; attributeFilter;
 94     if (init.attributeFilter) {
 95         for (auto&amp; value : init.attributeFilter.value())
 96             attributeFilter.add(value);
 97         options |= AttributeFilter;
 98     }
 99 
100     if (init.attributes ? init.attributes.value() : (options &amp; (AttributeFilter | AttributeOldValue)))
101         options |= Attributes;
102 
103     if (init.characterData ? init.characterData.value() : (options &amp; CharacterDataOldValue))
104         options |= CharacterData;
105 
106     if (!validateOptions(options))
107         return Exception { TypeError };
108 
109     node.registerMutationObserver(*this, options, attributeFilter);
110 
111     return { };
112 }
113 
114 auto MutationObserver::takeRecords() -&gt; TakenRecords
115 {
116     return { WTFMove(m_records), WTFMove(m_pendingTargets) };
117 }
118 
119 void MutationObserver::disconnect()
120 {
121     m_pendingTargets.clear();
122     m_records.clear();
123     HashSet&lt;MutationObserverRegistration*&gt; registrations(m_registrations);
124     for (auto* registration : registrations)
125         registration-&gt;node().unregisterMutationObserver(*registration);
126 }
127 
128 void MutationObserver::observationStarted(MutationObserverRegistration&amp; registration)
129 {
130     ASSERT(!m_registrations.contains(&amp;registration));
131     m_registrations.add(&amp;registration);
132 }
133 
134 void MutationObserver::observationEnded(MutationObserverRegistration&amp; registration)
135 {
136     ASSERT(m_registrations.contains(&amp;registration));
137     m_registrations.remove(&amp;registration);
138 }
139 
140 void MutationObserver::enqueueMutationRecord(Ref&lt;MutationRecord&gt;&amp;&amp; mutation)
141 {
142     ASSERT(isMainThread());
143     ASSERT(mutation-&gt;target());
144     auto document = makeRef(mutation-&gt;target()-&gt;document());
145 
146     m_pendingTargets.add(*mutation-&gt;target());
147     m_records.append(WTFMove(mutation));
148 
149     auto eventLoop = makeRef(document-&gt;windowEventLoop());
150     eventLoop-&gt;activeMutationObservers().add(this);
151     eventLoop-&gt;queueMutationObserverCompoundMicrotask();
152 }
153 
154 void MutationObserver::enqueueSlotChangeEvent(HTMLSlotElement&amp; slot)
155 {
156     ASSERT(isMainThread());
157     auto eventLoop = makeRef(slot.document().windowEventLoop());
158     auto&amp; list = eventLoop-&gt;signalSlotList();
159     ASSERT(list.findMatching([&amp;slot](auto&amp; entry) { return entry.ptr() == &amp;slot; }) == notFound);
160     list.append(slot);
161 
162     eventLoop-&gt;queueMutationObserverCompoundMicrotask();
163 }
164 
165 void MutationObserver::setHasTransientRegistration(Document&amp; document)
166 {
167     auto eventLoop = makeRef(document.windowEventLoop());
168     eventLoop-&gt;activeMutationObservers().add(this);
169     eventLoop-&gt;queueMutationObserverCompoundMicrotask();
170 }
171 
172 HashSet&lt;Node*&gt; MutationObserver::observedNodes() const
173 {
174     HashSet&lt;Node*&gt; observedNodes;
175     for (auto* registration : m_registrations)
176         registration-&gt;addRegistrationNodesToSet(observedNodes);
177     return observedNodes;
178 }
179 
180 bool MutationObserver::canDeliver()
181 {
182     return m_callback-&gt;canInvokeCallback();
183 }
184 
185 void MutationObserver::deliver()
186 {
187     ASSERT(canDeliver());
188 
189     // Calling takeTransientRegistrations() can modify m_registrations, so it&#39;s necessary
190     // to make a copy of the transient registrations before operating on them.
191     Vector&lt;MutationObserverRegistration*, 1&gt; transientRegistrations;
192     Vector&lt;std::unique_ptr&lt;HashSet&lt;GCReachableRef&lt;Node&gt;&gt;&gt;, 1&gt; nodesToKeepAlive;
193     HashSet&lt;GCReachableRef&lt;Node&gt;&gt; pendingTargets;
194     pendingTargets.swap(m_pendingTargets);
195     for (auto* registration : m_registrations) {
196         if (registration-&gt;hasTransientRegistrations())
197             transientRegistrations.append(registration);
198     }
199     for (auto&amp; registration : transientRegistrations)
200         nodesToKeepAlive.append(registration-&gt;takeTransientRegistrations());
201 
202     if (m_records.isEmpty()) {
203         ASSERT(m_pendingTargets.isEmpty());
204         return;
205     }
206 
207     Vector&lt;Ref&lt;MutationRecord&gt;&gt; records;
208     records.swap(m_records);
209 
210     // FIXME: Keep mutation observer callback as long as its observed nodes are alive. See https://webkit.org/b/179224.
211     if (m_callback-&gt;hasCallback()) {
212         auto* context = m_callback-&gt;scriptExecutionContext();
213         if (!context)
214             return;
215 
216         InspectorInstrumentation::willFireObserverCallback(*context, &quot;MutationObserver&quot;_s);
217         m_callback-&gt;handleEvent(*this, records, *this);
218         InspectorInstrumentation::didFireObserverCallback(*context);
219     }
220 }
221 
222 // https://dom.spec.whatwg.org/#notify-mutation-observers
223 void MutationObserver::notifyMutationObservers(WindowEventLoop&amp; eventLoop)
224 {
225     if (!eventLoop.suspendedMutationObservers().isEmpty()) {
226         for (auto&amp; observer : copyToVector(eventLoop.suspendedMutationObservers())) {
227             if (!observer-&gt;canDeliver())
228                 continue;
229 
230             eventLoop.suspendedMutationObservers().remove(observer);
231             eventLoop.activeMutationObservers().add(observer);
232         }
233     }
234 
235     while (!eventLoop.activeMutationObservers().isEmpty() || !eventLoop.signalSlotList().isEmpty()) {
236         // 2. Let notify list be a copy of unit of related similar-origin browsing contexts&#39; list of MutationObserver objects.
237         auto notifyList = copyToVector(eventLoop.activeMutationObservers());
238         eventLoop.activeMutationObservers().clear();
239         std::sort(notifyList.begin(), notifyList.end(), [](auto&amp; lhs, auto&amp; rhs) {
240             return lhs-&gt;m_priority &lt; rhs-&gt;m_priority;
241         });
242 
243         // 3. Let signalList be a copy of unit of related similar-origin browsing contexts&#39; signal slot list.
244         // 4. Empty unit of related similar-origin browsing contexts&#39; signal slot list.
245         Vector&lt;GCReachableRef&lt;HTMLSlotElement&gt;&gt; slotList;
246         if (!eventLoop.signalSlotList().isEmpty()) {
247             slotList.swap(eventLoop.signalSlotList());
248             for (auto&amp; slot : slotList)
249                 slot-&gt;didRemoveFromSignalSlotList();
250         }
251 
252         // 5. For each MutationObserver object mo in notify list, execute a compound microtask subtask
253         for (auto&amp; observer : notifyList) {
254             if (observer-&gt;canDeliver())
255                 observer-&gt;deliver();
256             else
257                 eventLoop.suspendedMutationObservers().add(observer);
258         }
259 
260         // 6. For each slot slot in signalList, in order, fire an event named slotchange, with its bubbles attribute set to true, at slot.
261         for (auto&amp; slot : slotList)
262             slot-&gt;dispatchSlotChangeEvent();
263     }
264 }
265 
266 } // namespace WebCore
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/StackVisitor.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ShadowChickenInlines.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StackVisitor.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/StackVisitor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;StackVisitor.h&quot;
 28 
<span class="line-removed"> 29 #include &quot;CallFrameInlines.h&quot;</span>
 30 #include &quot;ClonedArguments.h&quot;
 31 #include &quot;DebuggerPrimitives.h&quot;
 32 #include &quot;InlineCallFrame.h&quot;
 33 #include &quot;Interpreter.h&quot;
 34 #include &quot;JSCInlines.h&quot;

 35 #include &quot;WasmCallee.h&quot;
 36 #include &quot;WasmIndexOrName.h&quot;
 37 #include &quot;WebAssemblyFunction.h&quot;
 38 #include &lt;wtf/text/StringBuilder.h&gt;
 39 
 40 namespace JSC {
 41 
<span class="line-modified"> 42 StackVisitor::StackVisitor(CallFrame* startFrame, VM* vm)</span>
 43 {
 44     m_frame.m_index = 0;
 45     m_frame.m_isWasmFrame = false;
 46     CallFrame* topFrame;
 47     if (startFrame) {
<span class="line-modified"> 48         ASSERT(vm);</span>
<span class="line-removed"> 49         ASSERT(!vm-&gt;topCallFrame || reinterpret_cast&lt;void*&gt;(vm-&gt;topCallFrame) != vm-&gt;topEntryFrame);</span>
 50 
<span class="line-modified"> 51         m_frame.m_entryFrame = vm-&gt;topEntryFrame;</span>
<span class="line-modified"> 52         topFrame = vm-&gt;topCallFrame;</span>
 53 
 54         if (topFrame &amp;&amp; topFrame-&gt;isStackOverflowFrame()) {
 55             topFrame = topFrame-&gt;callerFrame(m_frame.m_entryFrame);
<span class="line-modified"> 56             m_topEntryFrameIsEmpty = (m_frame.m_entryFrame != vm-&gt;topEntryFrame);</span>
<span class="line-modified"> 57             if (startFrame == vm-&gt;topCallFrame)</span>
 58                 startFrame = topFrame;
 59         }
 60 
 61     } else {
 62         m_frame.m_entryFrame = 0;
 63         topFrame = 0;
 64     }
 65     m_frame.m_callerIsEntryFrame = false;
 66     readFrame(topFrame);
 67 
 68     // Find the frame the caller wants to start unwinding from.
 69     while (m_frame.callFrame() &amp;&amp; m_frame.callFrame() != startFrame)
 70         gotoNextFrame();
 71 }
 72 
 73 void StackVisitor::gotoNextFrame()
 74 {
 75     m_frame.m_index++;
 76 #if ENABLE(DFG_JIT)
 77     if (m_frame.isInlinedFrame()) {
</pre>
<hr />
<pre>
153 
154     readInlinedFrame(callFrame, &amp;codeOrigin);
155 #endif // !ENABLE(DFG_JIT)
156 }
157 
158 void StackVisitor::readNonInlinedFrame(CallFrame* callFrame, CodeOrigin* codeOrigin)
159 {
160     m_frame.m_callFrame = callFrame;
161     m_frame.m_argumentCountIncludingThis = callFrame-&gt;argumentCountIncludingThis();
162     m_frame.m_callerEntryFrame = m_frame.m_entryFrame;
163     m_frame.m_callerFrame = callFrame-&gt;callerFrame(m_frame.m_callerEntryFrame);
164     m_frame.m_callerIsEntryFrame = m_frame.m_callerEntryFrame != m_frame.m_entryFrame;
165     m_frame.m_isWasmFrame = false;
166 
167     CalleeBits callee = callFrame-&gt;callee();
168     m_frame.m_callee = callee;
169 
170     if (callFrame-&gt;isAnyWasmCallee()) {
171         m_frame.m_isWasmFrame = true;
172         m_frame.m_codeBlock = nullptr;
<span class="line-modified">173         m_frame.m_bytecodeOffset = 0;</span>
174 #if ENABLE(WEBASSEMBLY)
175         CalleeBits bits = callFrame-&gt;callee();
176         if (bits.isWasm())
177             m_frame.m_wasmFunctionIndexOrName = bits.asWasmCallee()-&gt;indexOrName();
178 #endif
179     } else {
180         m_frame.m_codeBlock = callFrame-&gt;codeBlock();
<span class="line-modified">181         m_frame.m_bytecodeOffset = !m_frame.codeBlock() ? 0</span>
182             : codeOrigin ? codeOrigin-&gt;bytecodeIndex()
<span class="line-modified">183             : callFrame-&gt;bytecodeOffset();</span>
184 
185     }
186 
187 #if ENABLE(DFG_JIT)
188     m_frame.m_inlineCallFrame = 0;
189 #endif
190 }
191 
192 #if ENABLE(DFG_JIT)
193 static int inlinedFrameOffset(CodeOrigin* codeOrigin)
194 {
195     InlineCallFrame* inlineCallFrame = codeOrigin-&gt;inlineCallFrame();
196     int frameOffset = inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0;
197     return frameOffset;
198 }
199 
200 void StackVisitor::readInlinedFrame(CallFrame* callFrame, CodeOrigin* codeOrigin)
201 {
202     ASSERT(codeOrigin);
203     m_frame.m_isWasmFrame = false;
204 
205     int frameOffset = inlinedFrameOffset(codeOrigin);
206     bool isInlined = !!frameOffset;
207     if (isInlined) {
208         InlineCallFrame* inlineCallFrame = codeOrigin-&gt;inlineCallFrame();
209 
210         m_frame.m_callFrame = callFrame;
211         m_frame.m_inlineCallFrame = inlineCallFrame;
212         if (inlineCallFrame-&gt;argumentCountRegister.isValid())
<span class="line-modified">213             m_frame.m_argumentCountIncludingThis = callFrame-&gt;r(inlineCallFrame-&gt;argumentCountRegister.offset()).unboxedInt32();</span>
214         else
215             m_frame.m_argumentCountIncludingThis = inlineCallFrame-&gt;argumentCountIncludingThis;
216         m_frame.m_codeBlock = inlineCallFrame-&gt;baselineCodeBlock.get();
<span class="line-modified">217         m_frame.m_bytecodeOffset = codeOrigin-&gt;bytecodeIndex();</span>
218 
219         JSFunction* callee = inlineCallFrame-&gt;calleeForCallFrame(callFrame);
220         m_frame.m_callee = callee;
221         ASSERT(!!m_frame.callee().rawPtr());
222 
223         // The callerFrame just needs to be non-null to indicate that we
224         // haven&#39;t reached the last frame yet. Setting it to the root
225         // frame (i.e. the callFrame that this inlined frame is called from)
226         // would work just fine.
227         m_frame.m_callerFrame = callFrame;
228         return;
229     }
230 
231     readNonInlinedFrame(callFrame, codeOrigin);
232 }
233 #endif // ENABLE(DFG_JIT)
234 
235 StackVisitor::Frame::CodeType StackVisitor::Frame::codeType() const
236 {
237     if (isWasmFrame())
</pre>
<hr />
<pre>
249         return CodeType::Function;
250     case GlobalCode:
251         return CodeType::Global;
252     }
253     RELEASE_ASSERT_NOT_REACHED();
254     return CodeType::Global;
255 }
256 
257 #if ENABLE(ASSEMBLER)
258 Optional&lt;RegisterAtOffsetList&gt; StackVisitor::Frame::calleeSaveRegistersForUnwinding()
259 {
260     if (!NUMBER_OF_CALLEE_SAVES_REGISTERS)
261         return WTF::nullopt;
262 
263     if (isInlinedFrame())
264         return WTF::nullopt;
265 
266 #if ENABLE(WEBASSEMBLY)
267     if (isWasmFrame()) {
268         if (callee().isCell()) {
<span class="line-modified">269             RELEASE_ASSERT(isWebAssemblyToJSCallee(callee().asCell()));</span>
270             return WTF::nullopt;
271         }
272         Wasm::Callee* wasmCallee = callee().asWasmCallee();
273         return *wasmCallee-&gt;calleeSaveRegisters();
274     }
275 
276     if (callee().isCell()) {
277         if (auto* jsToWasmICCallee = jsDynamicCast&lt;JSToWasmICCallee*&gt;(callee().asCell()-&gt;vm(), callee().asCell()))
278             return jsToWasmICCallee-&gt;function()-&gt;usedCalleeSaveRegisters();
279     }
280 #endif // ENABLE(WEBASSEMBLY)
281 
282     if (CodeBlock* codeBlock = this-&gt;codeBlock())
283         return *codeBlock-&gt;calleeSaveRegisters();
284 
285     return WTF::nullopt;
286 }
287 #endif // ENABLE(ASSEMBLER)
288 
289 String StackVisitor::Frame::functionName() const
290 {
291     String traceLine;
292 
293     switch (codeType()) {
294     case CodeType::Wasm:
295         traceLine = makeString(m_wasmFunctionIndexOrName);
296         break;
297     case CodeType::Eval:
298         traceLine = &quot;eval code&quot;_s;
299         break;
300     case CodeType::Module:
301         traceLine = &quot;module code&quot;_s;
302         break;
303     case CodeType::Native: {
304         JSCell* callee = this-&gt;callee().asCell();
305         if (callee)
<span class="line-modified">306             traceLine = getCalculatedDisplayName(callFrame()-&gt;vm(), jsCast&lt;JSObject*&gt;(callee)).impl();</span>
307         break;
308     }
309     case CodeType::Function:
<span class="line-modified">310         traceLine = getCalculatedDisplayName(callFrame()-&gt;vm(), jsCast&lt;JSObject*&gt;(this-&gt;callee().asCell())).impl();</span>
311         break;
312     case CodeType::Global:
313         traceLine = &quot;global code&quot;_s;
314         break;
315     }
316     return traceLine.isNull() ? emptyString() : traceLine;
317 }
318 
319 String StackVisitor::Frame::sourceURL() const
320 {
321     String traceLine;
322 
323     switch (codeType()) {
324     case CodeType::Eval:
325     case CodeType::Module:
326     case CodeType::Function:
327     case CodeType::Global: {
328         String sourceURL = codeBlock()-&gt;ownerExecutable()-&gt;sourceURL();
329         if (!sourceURL.isEmpty())
330             traceLine = sourceURL.impl();
</pre>
<hr />
<pre>
353         if (hasLineAndColumnInfo()) {
354             unsigned line = 0;
355             unsigned column = 0;
356             computeLineAndColumn(line, column);
357             traceBuild.append(&#39;:&#39;);
358             traceBuild.appendNumber(line);
359             traceBuild.append(&#39;:&#39;);
360             traceBuild.appendNumber(column);
361         }
362     }
363     return traceBuild.toString().impl();
364 }
365 
366 intptr_t StackVisitor::Frame::sourceID()
367 {
368     if (CodeBlock* codeBlock = this-&gt;codeBlock())
369         return codeBlock-&gt;ownerExecutable()-&gt;sourceID();
370     return noSourceID;
371 }
372 
<span class="line-modified">373 ClonedArguments* StackVisitor::Frame::createArguments()</span>
374 {
375     ASSERT(m_callFrame);
376     CallFrame* physicalFrame = m_callFrame;



377     ClonedArguments* arguments;
378     ArgumentsMode mode;
379     if (Options::useFunctionDotArguments())
380         mode = ArgumentsMode::Cloned;
381     else
382         mode = ArgumentsMode::FakeValues;
383 #if ENABLE(DFG_JIT)
384     if (isInlinedFrame()) {
385         ASSERT(m_inlineCallFrame);
<span class="line-modified">386         arguments = ClonedArguments::createWithInlineFrame(physicalFrame, physicalFrame, m_inlineCallFrame, mode);</span>
387     } else
388 #endif
<span class="line-modified">389         arguments = ClonedArguments::createWithMachineFrame(physicalFrame, physicalFrame, mode);</span>
390     return arguments;
391 }
392 
393 bool StackVisitor::Frame::hasLineAndColumnInfo() const
394 {
395     return !!codeBlock();
396 }
397 
398 void StackVisitor::Frame::computeLineAndColumn(unsigned&amp; line, unsigned&amp; column) const
399 {
400     CodeBlock* codeBlock = this-&gt;codeBlock();
401     if (!codeBlock) {
402         line = 0;
403         column = 0;
404         return;
405     }
406 
407     int divot = 0;
408     int unusedStartOffset = 0;
409     int unusedEndOffset = 0;
410     unsigned divotLine = 0;
411     unsigned divotColumn = 0;
412     retrieveExpressionInfo(divot, unusedStartOffset, unusedEndOffset, divotLine, divotColumn);
413 
414     line = divotLine + codeBlock-&gt;ownerExecutable()-&gt;firstLine();
415     column = divotColumn + (divotLine ? 1 : codeBlock-&gt;firstLineColumnOffset());
416 
417     if (Optional&lt;int&gt; overrideLineNumber = codeBlock-&gt;ownerExecutable()-&gt;overrideLineNumber(codeBlock-&gt;vm()))
418         line = overrideLineNumber.value();
419 }
420 
421 void StackVisitor::Frame::retrieveExpressionInfo(int&amp; divot, int&amp; startOffset, int&amp; endOffset, unsigned&amp; line, unsigned&amp; column) const
422 {
423     CodeBlock* codeBlock = this-&gt;codeBlock();
<span class="line-modified">424     codeBlock-&gt;unlinkedCodeBlock()-&gt;expressionRangeForBytecodeOffset(bytecodeOffset(), divot, startOffset, endOffset, line, column);</span>
425     divot += codeBlock-&gt;sourceOffset();
426 }
427 
428 void StackVisitor::Frame::setToEnd()
429 {
430     m_callFrame = 0;
431 #if ENABLE(DFG_JIT)
432     m_inlineCallFrame = 0;
433 #endif
434     m_isWasmFrame = false;
435 }
436 
437 void StackVisitor::Frame::dump(PrintStream&amp; out, Indenter indent) const
438 {
439     dump(out, indent, [] (PrintStream&amp;) { });
440 }
441 
442 void StackVisitor::Frame::dump(PrintStream&amp; out, Indenter indent, WTF::Function&lt;void(PrintStream&amp;)&gt; prefix) const
443 {
444     if (!this-&gt;callFrame()) {
</pre>
<hr />
<pre>
466         isInlined = isInlinedFrame();
467         out.print(indent, &quot;isInlinedFrame: &quot;, isInlinedFrame(), &quot;\n&quot;);
468         if (isInlinedFrame())
469             out.print(indent, &quot;InlineCallFrame: &quot;, RawPointer(m_inlineCallFrame), &quot;\n&quot;);
470 #endif
471 
472         out.print(indent, &quot;callee: &quot;, RawPointer(callee().rawPtr()), &quot;\n&quot;);
473         out.print(indent, &quot;returnPC: &quot;, RawPointer(returnPC), &quot;\n&quot;);
474         out.print(indent, &quot;callerFrame: &quot;, RawPointer(callerFrame), &quot;\n&quot;);
475         uintptr_t locationRawBits = callFrame-&gt;callSiteAsRawBits();
476         out.print(indent, &quot;rawLocationBits: &quot;, locationRawBits,
477             &quot; &quot;, RawPointer(reinterpret_cast&lt;void*&gt;(locationRawBits)), &quot;\n&quot;);
478         out.print(indent, &quot;codeBlock: &quot;, RawPointer(codeBlock));
479         if (codeBlock)
480             out.print(&quot; &quot;, *codeBlock);
481         out.print(&quot;\n&quot;);
482         if (codeBlock &amp;&amp; !isInlined) {
483             indent++;
484 
485             if (callFrame-&gt;callSiteBitsAreBytecodeOffset()) {
<span class="line-modified">486                 unsigned bytecodeOffset = callFrame-&gt;bytecodeOffset();</span>
<span class="line-modified">487                 out.print(indent, &quot;bytecodeOffset: &quot;, bytecodeOffset, &quot; of &quot;, codeBlock-&gt;instructions().size(), &quot;\n&quot;);</span>
488 #if ENABLE(DFG_JIT)
489             } else {
490                 out.print(indent, &quot;hasCodeOrigins: &quot;, codeBlock-&gt;hasCodeOrigins(), &quot;\n&quot;);
491                 if (codeBlock-&gt;hasCodeOrigins()) {
492                     CallSiteIndex callSiteIndex = callFrame-&gt;callSiteIndex();
493                     out.print(indent, &quot;callSiteIndex: &quot;, callSiteIndex.bits(), &quot; of &quot;, codeBlock-&gt;codeOrigins().size(), &quot;\n&quot;);
494 
495                     JITType jitType = codeBlock-&gt;jitType();
496                     if (jitType != JITType::FTLJIT) {
497                         JITCode* jitCode = codeBlock-&gt;jitCode().get();
498                         out.print(indent, &quot;jitCode: &quot;, RawPointer(jitCode),
499                             &quot; start &quot;, RawPointer(jitCode-&gt;start()),
500                             &quot; end &quot;, RawPointer(jitCode-&gt;end()), &quot;\n&quot;);
501                     }
502                 }
503 #endif
504             }
505             unsigned line = 0;
506             unsigned column = 0;
507             computeLineAndColumn(line, column);
</pre>
</td>
<td>
<hr />
<pre>
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;StackVisitor.h&quot;
 28 

 29 #include &quot;ClonedArguments.h&quot;
 30 #include &quot;DebuggerPrimitives.h&quot;
 31 #include &quot;InlineCallFrame.h&quot;
 32 #include &quot;Interpreter.h&quot;
 33 #include &quot;JSCInlines.h&quot;
<span class="line-added"> 34 #include &quot;RegisterAtOffsetList.h&quot;</span>
 35 #include &quot;WasmCallee.h&quot;
 36 #include &quot;WasmIndexOrName.h&quot;
 37 #include &quot;WebAssemblyFunction.h&quot;
 38 #include &lt;wtf/text/StringBuilder.h&gt;
 39 
 40 namespace JSC {
 41 
<span class="line-modified"> 42 StackVisitor::StackVisitor(CallFrame* startFrame, VM&amp; vm)</span>
 43 {
 44     m_frame.m_index = 0;
 45     m_frame.m_isWasmFrame = false;
 46     CallFrame* topFrame;
 47     if (startFrame) {
<span class="line-modified"> 48         ASSERT(!vm.topCallFrame || reinterpret_cast&lt;void*&gt;(vm.topCallFrame) != vm.topEntryFrame);</span>

 49 
<span class="line-modified"> 50         m_frame.m_entryFrame = vm.topEntryFrame;</span>
<span class="line-modified"> 51         topFrame = vm.topCallFrame;</span>
 52 
 53         if (topFrame &amp;&amp; topFrame-&gt;isStackOverflowFrame()) {
 54             topFrame = topFrame-&gt;callerFrame(m_frame.m_entryFrame);
<span class="line-modified"> 55             m_topEntryFrameIsEmpty = (m_frame.m_entryFrame != vm.topEntryFrame);</span>
<span class="line-modified"> 56             if (startFrame == vm.topCallFrame)</span>
 57                 startFrame = topFrame;
 58         }
 59 
 60     } else {
 61         m_frame.m_entryFrame = 0;
 62         topFrame = 0;
 63     }
 64     m_frame.m_callerIsEntryFrame = false;
 65     readFrame(topFrame);
 66 
 67     // Find the frame the caller wants to start unwinding from.
 68     while (m_frame.callFrame() &amp;&amp; m_frame.callFrame() != startFrame)
 69         gotoNextFrame();
 70 }
 71 
 72 void StackVisitor::gotoNextFrame()
 73 {
 74     m_frame.m_index++;
 75 #if ENABLE(DFG_JIT)
 76     if (m_frame.isInlinedFrame()) {
</pre>
<hr />
<pre>
152 
153     readInlinedFrame(callFrame, &amp;codeOrigin);
154 #endif // !ENABLE(DFG_JIT)
155 }
156 
157 void StackVisitor::readNonInlinedFrame(CallFrame* callFrame, CodeOrigin* codeOrigin)
158 {
159     m_frame.m_callFrame = callFrame;
160     m_frame.m_argumentCountIncludingThis = callFrame-&gt;argumentCountIncludingThis();
161     m_frame.m_callerEntryFrame = m_frame.m_entryFrame;
162     m_frame.m_callerFrame = callFrame-&gt;callerFrame(m_frame.m_callerEntryFrame);
163     m_frame.m_callerIsEntryFrame = m_frame.m_callerEntryFrame != m_frame.m_entryFrame;
164     m_frame.m_isWasmFrame = false;
165 
166     CalleeBits callee = callFrame-&gt;callee();
167     m_frame.m_callee = callee;
168 
169     if (callFrame-&gt;isAnyWasmCallee()) {
170         m_frame.m_isWasmFrame = true;
171         m_frame.m_codeBlock = nullptr;
<span class="line-modified">172         m_frame.m_bytecodeIndex = BytecodeIndex();</span>
173 #if ENABLE(WEBASSEMBLY)
174         CalleeBits bits = callFrame-&gt;callee();
175         if (bits.isWasm())
176             m_frame.m_wasmFunctionIndexOrName = bits.asWasmCallee()-&gt;indexOrName();
177 #endif
178     } else {
179         m_frame.m_codeBlock = callFrame-&gt;codeBlock();
<span class="line-modified">180         m_frame.m_bytecodeIndex = !m_frame.codeBlock() ? BytecodeIndex(0)</span>
181             : codeOrigin ? codeOrigin-&gt;bytecodeIndex()
<span class="line-modified">182             : callFrame-&gt;bytecodeIndex();</span>
183 
184     }
185 
186 #if ENABLE(DFG_JIT)
187     m_frame.m_inlineCallFrame = 0;
188 #endif
189 }
190 
191 #if ENABLE(DFG_JIT)
192 static int inlinedFrameOffset(CodeOrigin* codeOrigin)
193 {
194     InlineCallFrame* inlineCallFrame = codeOrigin-&gt;inlineCallFrame();
195     int frameOffset = inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0;
196     return frameOffset;
197 }
198 
199 void StackVisitor::readInlinedFrame(CallFrame* callFrame, CodeOrigin* codeOrigin)
200 {
201     ASSERT(codeOrigin);
202     m_frame.m_isWasmFrame = false;
203 
204     int frameOffset = inlinedFrameOffset(codeOrigin);
205     bool isInlined = !!frameOffset;
206     if (isInlined) {
207         InlineCallFrame* inlineCallFrame = codeOrigin-&gt;inlineCallFrame();
208 
209         m_frame.m_callFrame = callFrame;
210         m_frame.m_inlineCallFrame = inlineCallFrame;
211         if (inlineCallFrame-&gt;argumentCountRegister.isValid())
<span class="line-modified">212             m_frame.m_argumentCountIncludingThis = callFrame-&gt;r(inlineCallFrame-&gt;argumentCountRegister).unboxedInt32();</span>
213         else
214             m_frame.m_argumentCountIncludingThis = inlineCallFrame-&gt;argumentCountIncludingThis;
215         m_frame.m_codeBlock = inlineCallFrame-&gt;baselineCodeBlock.get();
<span class="line-modified">216         m_frame.m_bytecodeIndex = codeOrigin-&gt;bytecodeIndex();</span>
217 
218         JSFunction* callee = inlineCallFrame-&gt;calleeForCallFrame(callFrame);
219         m_frame.m_callee = callee;
220         ASSERT(!!m_frame.callee().rawPtr());
221 
222         // The callerFrame just needs to be non-null to indicate that we
223         // haven&#39;t reached the last frame yet. Setting it to the root
224         // frame (i.e. the callFrame that this inlined frame is called from)
225         // would work just fine.
226         m_frame.m_callerFrame = callFrame;
227         return;
228     }
229 
230     readNonInlinedFrame(callFrame, codeOrigin);
231 }
232 #endif // ENABLE(DFG_JIT)
233 
234 StackVisitor::Frame::CodeType StackVisitor::Frame::codeType() const
235 {
236     if (isWasmFrame())
</pre>
<hr />
<pre>
248         return CodeType::Function;
249     case GlobalCode:
250         return CodeType::Global;
251     }
252     RELEASE_ASSERT_NOT_REACHED();
253     return CodeType::Global;
254 }
255 
256 #if ENABLE(ASSEMBLER)
257 Optional&lt;RegisterAtOffsetList&gt; StackVisitor::Frame::calleeSaveRegistersForUnwinding()
258 {
259     if (!NUMBER_OF_CALLEE_SAVES_REGISTERS)
260         return WTF::nullopt;
261 
262     if (isInlinedFrame())
263         return WTF::nullopt;
264 
265 #if ENABLE(WEBASSEMBLY)
266     if (isWasmFrame()) {
267         if (callee().isCell()) {
<span class="line-modified">268             RELEASE_ASSERT(isWebAssemblyModule(callee().asCell()));</span>
269             return WTF::nullopt;
270         }
271         Wasm::Callee* wasmCallee = callee().asWasmCallee();
272         return *wasmCallee-&gt;calleeSaveRegisters();
273     }
274 
275     if (callee().isCell()) {
276         if (auto* jsToWasmICCallee = jsDynamicCast&lt;JSToWasmICCallee*&gt;(callee().asCell()-&gt;vm(), callee().asCell()))
277             return jsToWasmICCallee-&gt;function()-&gt;usedCalleeSaveRegisters();
278     }
279 #endif // ENABLE(WEBASSEMBLY)
280 
281     if (CodeBlock* codeBlock = this-&gt;codeBlock())
282         return *codeBlock-&gt;calleeSaveRegisters();
283 
284     return WTF::nullopt;
285 }
286 #endif // ENABLE(ASSEMBLER)
287 
288 String StackVisitor::Frame::functionName() const
289 {
290     String traceLine;
291 
292     switch (codeType()) {
293     case CodeType::Wasm:
294         traceLine = makeString(m_wasmFunctionIndexOrName);
295         break;
296     case CodeType::Eval:
297         traceLine = &quot;eval code&quot;_s;
298         break;
299     case CodeType::Module:
300         traceLine = &quot;module code&quot;_s;
301         break;
302     case CodeType::Native: {
303         JSCell* callee = this-&gt;callee().asCell();
304         if (callee)
<span class="line-modified">305             traceLine = getCalculatedDisplayName(callFrame()-&gt;deprecatedVM(), jsCast&lt;JSObject*&gt;(callee)).impl();</span>
306         break;
307     }
308     case CodeType::Function:
<span class="line-modified">309         traceLine = getCalculatedDisplayName(callFrame()-&gt;deprecatedVM(), jsCast&lt;JSObject*&gt;(this-&gt;callee().asCell())).impl();</span>
310         break;
311     case CodeType::Global:
312         traceLine = &quot;global code&quot;_s;
313         break;
314     }
315     return traceLine.isNull() ? emptyString() : traceLine;
316 }
317 
318 String StackVisitor::Frame::sourceURL() const
319 {
320     String traceLine;
321 
322     switch (codeType()) {
323     case CodeType::Eval:
324     case CodeType::Module:
325     case CodeType::Function:
326     case CodeType::Global: {
327         String sourceURL = codeBlock()-&gt;ownerExecutable()-&gt;sourceURL();
328         if (!sourceURL.isEmpty())
329             traceLine = sourceURL.impl();
</pre>
<hr />
<pre>
352         if (hasLineAndColumnInfo()) {
353             unsigned line = 0;
354             unsigned column = 0;
355             computeLineAndColumn(line, column);
356             traceBuild.append(&#39;:&#39;);
357             traceBuild.appendNumber(line);
358             traceBuild.append(&#39;:&#39;);
359             traceBuild.appendNumber(column);
360         }
361     }
362     return traceBuild.toString().impl();
363 }
364 
365 intptr_t StackVisitor::Frame::sourceID()
366 {
367     if (CodeBlock* codeBlock = this-&gt;codeBlock())
368         return codeBlock-&gt;ownerExecutable()-&gt;sourceID();
369     return noSourceID;
370 }
371 
<span class="line-modified">372 ClonedArguments* StackVisitor::Frame::createArguments(VM&amp; vm)</span>
373 {
374     ASSERT(m_callFrame);
375     CallFrame* physicalFrame = m_callFrame;
<span class="line-added">376     // FIXME: Revisit JSGlobalObject.</span>
<span class="line-added">377     // https://bugs.webkit.org/show_bug.cgi?id=203204</span>
<span class="line-added">378     JSGlobalObject* globalObject = physicalFrame-&gt;lexicalGlobalObject(vm);</span>
379     ClonedArguments* arguments;
380     ArgumentsMode mode;
381     if (Options::useFunctionDotArguments())
382         mode = ArgumentsMode::Cloned;
383     else
384         mode = ArgumentsMode::FakeValues;
385 #if ENABLE(DFG_JIT)
386     if (isInlinedFrame()) {
387         ASSERT(m_inlineCallFrame);
<span class="line-modified">388         arguments = ClonedArguments::createWithInlineFrame(globalObject, physicalFrame, m_inlineCallFrame, mode);</span>
389     } else
390 #endif
<span class="line-modified">391         arguments = ClonedArguments::createWithMachineFrame(globalObject, physicalFrame, mode);</span>
392     return arguments;
393 }
394 
395 bool StackVisitor::Frame::hasLineAndColumnInfo() const
396 {
397     return !!codeBlock();
398 }
399 
400 void StackVisitor::Frame::computeLineAndColumn(unsigned&amp; line, unsigned&amp; column) const
401 {
402     CodeBlock* codeBlock = this-&gt;codeBlock();
403     if (!codeBlock) {
404         line = 0;
405         column = 0;
406         return;
407     }
408 
409     int divot = 0;
410     int unusedStartOffset = 0;
411     int unusedEndOffset = 0;
412     unsigned divotLine = 0;
413     unsigned divotColumn = 0;
414     retrieveExpressionInfo(divot, unusedStartOffset, unusedEndOffset, divotLine, divotColumn);
415 
416     line = divotLine + codeBlock-&gt;ownerExecutable()-&gt;firstLine();
417     column = divotColumn + (divotLine ? 1 : codeBlock-&gt;firstLineColumnOffset());
418 
419     if (Optional&lt;int&gt; overrideLineNumber = codeBlock-&gt;ownerExecutable()-&gt;overrideLineNumber(codeBlock-&gt;vm()))
420         line = overrideLineNumber.value();
421 }
422 
423 void StackVisitor::Frame::retrieveExpressionInfo(int&amp; divot, int&amp; startOffset, int&amp; endOffset, unsigned&amp; line, unsigned&amp; column) const
424 {
425     CodeBlock* codeBlock = this-&gt;codeBlock();
<span class="line-modified">426     codeBlock-&gt;unlinkedCodeBlock()-&gt;expressionRangeForBytecodeIndex(bytecodeIndex(), divot, startOffset, endOffset, line, column);</span>
427     divot += codeBlock-&gt;sourceOffset();
428 }
429 
430 void StackVisitor::Frame::setToEnd()
431 {
432     m_callFrame = 0;
433 #if ENABLE(DFG_JIT)
434     m_inlineCallFrame = 0;
435 #endif
436     m_isWasmFrame = false;
437 }
438 
439 void StackVisitor::Frame::dump(PrintStream&amp; out, Indenter indent) const
440 {
441     dump(out, indent, [] (PrintStream&amp;) { });
442 }
443 
444 void StackVisitor::Frame::dump(PrintStream&amp; out, Indenter indent, WTF::Function&lt;void(PrintStream&amp;)&gt; prefix) const
445 {
446     if (!this-&gt;callFrame()) {
</pre>
<hr />
<pre>
468         isInlined = isInlinedFrame();
469         out.print(indent, &quot;isInlinedFrame: &quot;, isInlinedFrame(), &quot;\n&quot;);
470         if (isInlinedFrame())
471             out.print(indent, &quot;InlineCallFrame: &quot;, RawPointer(m_inlineCallFrame), &quot;\n&quot;);
472 #endif
473 
474         out.print(indent, &quot;callee: &quot;, RawPointer(callee().rawPtr()), &quot;\n&quot;);
475         out.print(indent, &quot;returnPC: &quot;, RawPointer(returnPC), &quot;\n&quot;);
476         out.print(indent, &quot;callerFrame: &quot;, RawPointer(callerFrame), &quot;\n&quot;);
477         uintptr_t locationRawBits = callFrame-&gt;callSiteAsRawBits();
478         out.print(indent, &quot;rawLocationBits: &quot;, locationRawBits,
479             &quot; &quot;, RawPointer(reinterpret_cast&lt;void*&gt;(locationRawBits)), &quot;\n&quot;);
480         out.print(indent, &quot;codeBlock: &quot;, RawPointer(codeBlock));
481         if (codeBlock)
482             out.print(&quot; &quot;, *codeBlock);
483         out.print(&quot;\n&quot;);
484         if (codeBlock &amp;&amp; !isInlined) {
485             indent++;
486 
487             if (callFrame-&gt;callSiteBitsAreBytecodeOffset()) {
<span class="line-modified">488                 BytecodeIndex bytecodeIndex = callFrame-&gt;bytecodeIndex();</span>
<span class="line-modified">489                 out.print(indent, bytecodeIndex, &quot; of &quot;, codeBlock-&gt;instructions().size(), &quot;\n&quot;);</span>
490 #if ENABLE(DFG_JIT)
491             } else {
492                 out.print(indent, &quot;hasCodeOrigins: &quot;, codeBlock-&gt;hasCodeOrigins(), &quot;\n&quot;);
493                 if (codeBlock-&gt;hasCodeOrigins()) {
494                     CallSiteIndex callSiteIndex = callFrame-&gt;callSiteIndex();
495                     out.print(indent, &quot;callSiteIndex: &quot;, callSiteIndex.bits(), &quot; of &quot;, codeBlock-&gt;codeOrigins().size(), &quot;\n&quot;);
496 
497                     JITType jitType = codeBlock-&gt;jitType();
498                     if (jitType != JITType::FTLJIT) {
499                         JITCode* jitCode = codeBlock-&gt;jitCode().get();
500                         out.print(indent, &quot;jitCode: &quot;, RawPointer(jitCode),
501                             &quot; start &quot;, RawPointer(jitCode-&gt;start()),
502                             &quot; end &quot;, RawPointer(jitCode-&gt;end()), &quot;\n&quot;);
503                     }
504                 }
505 #endif
506             }
507             unsigned line = 0;
508             unsigned column = 0;
509             computeLineAndColumn(line, column);
</pre>
</td>
</tr>
</table>
<center><a href="ShadowChickenInlines.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StackVisitor.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
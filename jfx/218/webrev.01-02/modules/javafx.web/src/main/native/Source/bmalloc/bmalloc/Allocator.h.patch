diff a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Allocator.h b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Allocator.h
--- a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Allocator.h
+++ b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Allocator.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2014-2018 Apple Inc. All rights reserved.
+ * Copyright (C) 2014-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -26,10 +26,11 @@
 #ifndef Allocator_h
 #define Allocator_h
 
 #include "BExport.h"
 #include "BumpAllocator.h"
+#include "FailureAction.h"
 #include <array>
 
 namespace bmalloc {
 
 class Deallocator;
@@ -40,31 +41,32 @@
 class Allocator {
 public:
     Allocator(Heap&, Deallocator&);
     ~Allocator();
 
-    BEXPORT void* tryAllocate(size_t);
-    void* allocate(size_t);
-    void* tryAllocate(size_t alignment, size_t);
-    void* allocate(size_t alignment, size_t);
-    void* tryReallocate(void*, size_t);
-    void* reallocate(void*, size_t);
+    void* tryAllocate(size_t size) { return allocateImpl(size, FailureAction::ReturnNull); }
+    void* allocate(size_t size) { return allocateImpl(size, FailureAction::Crash); }
+    void* tryAllocate(size_t alignment, size_t size) { return allocateImpl(alignment, size, FailureAction::ReturnNull); }
+    void* allocate(size_t alignment, size_t size) { return allocateImpl(alignment, size, FailureAction::Crash); }
+    void* tryReallocate(void* object, size_t newSize) { return reallocateImpl(object, newSize, FailureAction::ReturnNull); }
+    void* reallocate(void* object, size_t newSize) { return reallocateImpl(object, newSize, FailureAction::Crash); }
 
     void scavenge();
 
 private:
-    void* allocateImpl(size_t alignment, size_t, bool crashOnFailure);
-    void* reallocateImpl(void*, size_t, bool crashOnFailure);
+    void* allocateImpl(size_t, FailureAction);
+    void* allocateImpl(size_t alignment, size_t, FailureAction);
+    void* reallocateImpl(void*, size_t, FailureAction);
 
     bool allocateFastCase(size_t, void*&);
-    BEXPORT void* allocateSlowCase(size_t);
+    BEXPORT void* allocateSlowCase(size_t, FailureAction);
 
-    void* allocateLogSizeClass(size_t);
-    void* allocateLarge(size_t);
+    void* allocateLogSizeClass(size_t, FailureAction);
+    void* allocateLarge(size_t, FailureAction);
 
-    void refillAllocator(BumpAllocator&, size_t sizeClass);
-    void refillAllocatorSlowCase(BumpAllocator&, size_t sizeClass);
+    inline void refillAllocator(BumpAllocator&, size_t sizeClass, FailureAction);
+    void refillAllocatorSlowCase(BumpAllocator&, size_t sizeClass, FailureAction);
 
     std::array<BumpAllocator, sizeClassCount> m_bumpAllocators;
     std::array<BumpRangeCache, sizeClassCount> m_bumpRangeCaches;
 
     Heap& m_heap;
@@ -82,15 +84,15 @@
 
     object = allocator.allocate();
     return true;
 }
 
-inline void* Allocator::allocate(size_t size)
+inline void* Allocator::allocateImpl(size_t size, FailureAction action)
 {
     void* object;
     if (!allocateFastCase(size, object))
-        return allocateSlowCase(size);
+        return allocateSlowCase(size, action);
     return object;
 }
 
 } // namespace bmalloc
 

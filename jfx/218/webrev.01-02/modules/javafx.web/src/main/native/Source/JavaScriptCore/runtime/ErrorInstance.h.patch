diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ErrorInstance.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ErrorInstance.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ErrorInstance.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ErrorInstance.h
@@ -18,20 +18,32 @@
  *
  */
 
 #pragma once
 
-#include "JSDestructibleObject.h"
+#include "JSObject.h"
 #include "RuntimeType.h"
 #include "StackFrame.h"
 
 namespace JSC {
 
-class ErrorInstance : public JSDestructibleObject {
+class ErrorInstance : public JSNonFinalObject {
 public:
-    typedef JSDestructibleObject Base;
-    const static unsigned StructureFlags = Base::StructureFlags | OverridesGetOwnPropertySlot | OverridesGetPropertyNames;
+    using Base = JSNonFinalObject;
+    static constexpr unsigned StructureFlags = Base::StructureFlags | OverridesGetOwnPropertySlot | OverridesGetPropertyNames;
+    static constexpr bool needsDestruction = true;
+
+    static void destroy(JSCell* cell)
+    {
+        static_cast<ErrorInstance*>(cell)->ErrorInstance::~ErrorInstance();
+    }
+
+    template<typename CellType, SubspaceAccess mode>
+    static IsoSubspace* subspaceFor(VM& vm)
+    {
+        return vm.errorInstanceSpace<mode>();
+    }
 
     enum SourceTextWhereErrorOccurred { FoundExactSource, FoundApproximateSource };
     typedef String (*SourceAppender) (const String& originalMessage, const String& sourceText, RuntimeType, SourceTextWhereErrorOccurred);
 
     DECLARE_EXPORT_INFO;
@@ -39,20 +51,20 @@
     static Structure* createStructure(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
     {
         return Structure::create(vm, globalObject, prototype, TypeInfo(ErrorInstanceType, StructureFlags), info());
     }
 
-    static ErrorInstance* create(ExecState* exec, VM& vm, Structure* structure, const String& message, SourceAppender appender = nullptr, RuntimeType type = TypeNothing, bool useCurrentFrame = true)
+    static ErrorInstance* create(JSGlobalObject* globalObject, VM& vm, Structure* structure, const String& message, SourceAppender appender = nullptr, RuntimeType type = TypeNothing, bool useCurrentFrame = true)
     {
         ErrorInstance* instance = new (NotNull, allocateCell<ErrorInstance>(vm.heap)) ErrorInstance(vm, structure);
         instance->m_sourceAppender = appender;
         instance->m_runtimeTypeForCause = type;
-        instance->finishCreation(exec, vm, message, useCurrentFrame);
+        instance->finishCreation(globalObject, vm, message, useCurrentFrame);
         return instance;
     }
 
-    static ErrorInstance* create(ExecState*, Structure*, JSValue message, SourceAppender = nullptr, RuntimeType = TypeNothing, bool useCurrentFrame = true);
+    static ErrorInstance* create(JSGlobalObject*, Structure*, JSValue message, SourceAppender = nullptr, RuntimeType = TypeNothing, bool useCurrentFrame = true);
 
     bool hasSourceAppender() const { return !!m_sourceAppender; }
     SourceAppender sourceAppender() const { return m_sourceAppender; }
     void setSourceAppender(SourceAppender appender) { m_sourceAppender = appender; }
     void clearSourceAppender() { m_sourceAppender = nullptr; }
@@ -66,37 +78,30 @@
     bool isOutOfMemoryError() const { return m_outOfMemoryError; }
 
     void setNativeGetterTypeError() { m_nativeGetterTypeError = true; }
     bool isNativeGetterTypeError() const { return m_nativeGetterTypeError; }
 
-    JS_EXPORT_PRIVATE String sanitizedToString(ExecState*);
+    JS_EXPORT_PRIVATE String sanitizedToString(JSGlobalObject*);
 
     Vector<StackFrame>* stackTrace() { return m_stackTrace.get(); }
 
     bool materializeErrorInfoIfNeeded(VM&);
     bool materializeErrorInfoIfNeeded(VM&, PropertyName);
 
-    template<typename CellType, SubspaceAccess mode>
-    static IsoSubspace* subspaceFor(VM& vm)
-    {
-        return vm.errorInstanceSpace<mode>();
-    }
-
     void finalizeUnconditionally(VM&);
 
 protected:
     explicit ErrorInstance(VM&, Structure*);
 
-    void finishCreation(ExecState*, VM&, const String&, bool useCurrentFrame = true);
-    static void destroy(JSCell*);
+    void finishCreation(JSGlobalObject*, VM&, const String&, bool useCurrentFrame = true);
 
-    static bool getOwnPropertySlot(JSObject*, ExecState*, PropertyName, PropertySlot&);
-    static void getOwnNonIndexPropertyNames(JSObject*, ExecState*, PropertyNameArray&, EnumerationMode);
-    static void getStructurePropertyNames(JSObject*, ExecState*, PropertyNameArray&, EnumerationMode);
-    static bool defineOwnProperty(JSObject*, ExecState*, PropertyName, const PropertyDescriptor&, bool shouldThrow);
-    static bool put(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&);
-    static bool deleteProperty(JSCell*, ExecState*, PropertyName);
+    static bool getOwnPropertySlot(JSObject*, JSGlobalObject*, PropertyName, PropertySlot&);
+    static void getOwnNonIndexPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&, EnumerationMode);
+    static void getStructurePropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&, EnumerationMode);
+    static bool defineOwnProperty(JSObject*, JSGlobalObject*, PropertyName, const PropertyDescriptor&, bool shouldThrow);
+    static bool put(JSCell*, JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&);
+    static bool deleteProperty(JSCell*, JSGlobalObject*, PropertyName);
 
     void computeErrorInfo(VM&);
 
     SourceAppender m_sourceAppender { nullptr };
     std::unique_ptr<Vector<StackFrame>> m_stackTrace;

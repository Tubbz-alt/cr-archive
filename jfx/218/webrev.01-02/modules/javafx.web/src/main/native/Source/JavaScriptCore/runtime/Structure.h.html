<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Structure.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;ClassInfo.h&quot;
 29 #include &quot;ConcurrentJSLock.h&quot;
 30 #include &quot;IndexingType.h&quot;
 31 #include &quot;JSCJSValue.h&quot;
 32 #include &quot;JSCast.h&quot;
 33 #include &quot;JSType.h&quot;
 34 #include &quot;JSTypeInfo.h&quot;
 35 #include &quot;PropertyName.h&quot;
 36 #include &quot;PropertyNameArray.h&quot;
 37 #include &quot;PropertyOffset.h&quot;
 38 #include &quot;PutPropertySlot.h&quot;
 39 #include &quot;StructureIDBlob.h&quot;
 40 #include &quot;StructureRareData.h&quot;
 41 #include &quot;StructureTransitionTable.h&quot;
 42 #include &quot;TinyBloomFilter.h&quot;
 43 #include &quot;Watchpoint.h&quot;
 44 #include &quot;WriteBarrierInlines.h&quot;
 45 #include &lt;wtf/PrintStream.h&gt;
 46 
 47 namespace WTF {
 48 
 49 class UniquedStringImpl;
 50 
 51 } // namespace WTF
 52 
 53 namespace JSC {
 54 
 55 class DeferGC;
 56 class LLIntOffsetsExtractor;
 57 class PropertyNameArray;
 58 class PropertyNameArrayData;
 59 class PropertyTable;
 60 class StructureChain;
 61 class StructureShape;
 62 class SlotVisitor;
 63 class JSString;
 64 struct DumpContext;
 65 struct HashTable;
 66 struct HashTableValue;
 67 
 68 // The out-of-line property storage capacity to use when first allocating out-of-line
 69 // storage. Note that all objects start out without having any out-of-line storage;
 70 // this comes into play only on the first property store that exhausts inline storage.
 71 static constexpr unsigned initialOutOfLineCapacity = 4;
 72 
 73 // The factor by which to grow out-of-line storage when it is exhausted, after the
 74 // initial allocation.
 75 static constexpr unsigned outOfLineGrowthFactor = 2;
 76 
 77 struct PropertyMapEntry {
 78     UniquedStringImpl* key;
 79     PropertyOffset offset;
 80     uint8_t attributes;
 81 
 82     PropertyMapEntry()
 83         : key(nullptr)
 84         , offset(invalidOffset)
 85         , attributes(0)
 86     {
 87     }
 88 
 89     PropertyMapEntry(UniquedStringImpl* key, PropertyOffset offset, unsigned attributes)
 90         : key(key)
 91         , offset(offset)
 92         , attributes(attributes)
 93     {
 94         ASSERT(this-&gt;attributes == attributes);
 95     }
 96 };
 97 
 98 class StructureFireDetail : public FireDetail {
 99 public:
100     StructureFireDetail(const Structure* structure)
101         : m_structure(structure)
102     {
103     }
104 
105     void dump(PrintStream&amp; out) const override;
106 
107 private:
108     const Structure* m_structure;
109 };
110 
111 class DeferredStructureTransitionWatchpointFire : public DeferredWatchpointFire {
112     WTF_MAKE_NONCOPYABLE(DeferredStructureTransitionWatchpointFire);
113 public:
114     JS_EXPORT_PRIVATE DeferredStructureTransitionWatchpointFire(VM&amp;, Structure*);
115     JS_EXPORT_PRIVATE ~DeferredStructureTransitionWatchpointFire();
116 
117     void dump(PrintStream&amp; out) const override;
118 
119     const Structure* structure() const { return m_structure; }
120 
121 private:
122     const Structure* m_structure;
123 };
124 
125 class Structure final : public JSCell {
126     static constexpr uint16_t shortInvalidOffset = std::numeric_limits&lt;uint16_t&gt;::max() - 1;
127     static constexpr uint16_t useRareDataFlag = std::numeric_limits&lt;uint16_t&gt;::max();
128 public:
129     friend class StructureTransitionTable;
130 
131     typedef JSCell Base;
132     static constexpr unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;
133 
134     enum PolyProtoTag { PolyProto };
135     static Structure* create(VM&amp;, JSGlobalObject*, JSValue prototype, const TypeInfo&amp;, const ClassInfo*, IndexingType = NonArray, unsigned inlineCapacity = 0);
136     static Structure* create(PolyProtoTag, VM&amp;, JSGlobalObject*, JSObject* prototype, const TypeInfo&amp;, const ClassInfo*, IndexingType = NonArray, unsigned inlineCapacity = 0);
137 
138     ~Structure();
139 
140     template&lt;typename CellType, SubspaceAccess&gt;
141     static IsoSubspace* subspaceFor(VM&amp; vm)
142     {
143         return &amp;vm.structureSpace;
144     }
145 
146     JS_EXPORT_PRIVATE static bool isValidPrototype(JSValue);
147 
148 protected:
149     void finishCreation(VM&amp; vm)
150     {
151         Base::finishCreation(vm);
152         ASSERT(m_prototype.get().isEmpty() || isValidPrototype(m_prototype.get()));
153     }
154 
155     void finishCreation(VM&amp; vm, const Structure* previous)
156     {
157         this-&gt;finishCreation(vm);
158         if (previous-&gt;hasRareData()) {
159             const StructureRareData* previousRareData = previous-&gt;rareData();
160             if (previousRareData-&gt;hasSharedPolyProtoWatchpoint()) {
161                 ensureRareData(vm);
162                 rareData()-&gt;setSharedPolyProtoWatchpoint(previousRareData-&gt;copySharedPolyProtoWatchpoint());
163             }
164         }
165     }
166 
167     void finishCreation(VM&amp; vm, CreatingEarlyCellTag)
168     {
169         Base::finishCreation(vm, this, CreatingEarlyCell);
170         ASSERT(m_prototype);
171         ASSERT(m_prototype.isNull());
172         ASSERT(!vm.structureStructure);
173     }
174 
175 public:
176     StructureID id() const { return m_blob.structureID(); }
177     int32_t objectInitializationBlob() const { return m_blob.blobExcludingStructureID(); }
178     int64_t idBlob() const { return m_blob.blob(); }
179 
180     bool isProxy() const
181     {
182         JSType type = m_blob.type();
183         return type == ImpureProxyType || type == PureForwardingProxyType || type == ProxyObjectType;
184     }
185 
186     static void dumpStatistics();
187 
188     JS_EXPORT_PRIVATE static Structure* addPropertyTransition(VM&amp;, Structure*, PropertyName, unsigned attributes, PropertyOffset&amp;);
189     JS_EXPORT_PRIVATE static Structure* addNewPropertyTransition(VM&amp;, Structure*, PropertyName, unsigned attributes, PropertyOffset&amp;, PutPropertySlot::Context = PutPropertySlot::UnknownContext, DeferredStructureTransitionWatchpointFire* = nullptr);
190     static Structure* addPropertyTransitionToExistingStructureConcurrently(Structure*, UniquedStringImpl* uid, unsigned attributes, PropertyOffset&amp;);
191     JS_EXPORT_PRIVATE static Structure* addPropertyTransitionToExistingStructure(Structure*, PropertyName, unsigned attributes, PropertyOffset&amp;);
192     static Structure* removeNewPropertyTransition(VM&amp;, Structure*, PropertyName, PropertyOffset&amp;, DeferredStructureTransitionWatchpointFire* = nullptr);
193     static Structure* removePropertyTransition(VM&amp;, Structure*, PropertyName, PropertyOffset&amp;, DeferredStructureTransitionWatchpointFire* = nullptr);
194     static Structure* removePropertyTransitionFromExistingStructure(VM&amp;, Structure*, PropertyName, PropertyOffset&amp;, DeferredStructureTransitionWatchpointFire* = nullptr);
195     static Structure* changePrototypeTransition(VM&amp;, Structure*, JSValue prototype, DeferredStructureTransitionWatchpointFire&amp;);
196     JS_EXPORT_PRIVATE static Structure* attributeChangeTransition(VM&amp;, Structure*, PropertyName, unsigned attributes);
197     JS_EXPORT_PRIVATE static Structure* toCacheableDictionaryTransition(VM&amp;, Structure*, DeferredStructureTransitionWatchpointFire* = nullptr);
198     static Structure* toUncacheableDictionaryTransition(VM&amp;, Structure*, DeferredStructureTransitionWatchpointFire* = nullptr);
199     JS_EXPORT_PRIVATE static Structure* sealTransition(VM&amp;, Structure*);
200     JS_EXPORT_PRIVATE static Structure* freezeTransition(VM&amp;, Structure*);
201     static Structure* preventExtensionsTransition(VM&amp;, Structure*);
202     static Structure* nonPropertyTransition(VM&amp;, Structure*, NonPropertyTransition);
203     JS_EXPORT_PRIVATE static Structure* nonPropertyTransitionSlow(VM&amp;, Structure*, NonPropertyTransition);
204 
205     JS_EXPORT_PRIVATE bool isSealed(VM&amp;);
206     JS_EXPORT_PRIVATE bool isFrozen(VM&amp;);
207     bool isStructureExtensible() const { return !didPreventExtensions(); }
208 
209     JS_EXPORT_PRIVATE Structure* flattenDictionaryStructure(VM&amp;, JSObject*);
210 
211     static constexpr bool needsDestruction = true;
212     static void destroy(JSCell*);
213 
214     // Versions that take a func will call it after making the change but while still holding
215     // the lock. The callback is not called if there is no change being made, like if you call
216     // removePropertyWithoutTransition() and the property is not found.
217     template&lt;typename Func&gt;
218     PropertyOffset addPropertyWithoutTransition(VM&amp;, PropertyName, unsigned attributes, const Func&amp;);
219     template&lt;typename Func&gt;
220     PropertyOffset removePropertyWithoutTransition(VM&amp;, PropertyName, const Func&amp;);
221     void setPrototypeWithoutTransition(VM&amp;, JSValue prototype);
222 
223     bool isDictionary() const { return dictionaryKind() != NoneDictionaryKind; }
224     bool isUncacheableDictionary() const { return dictionaryKind() == UncachedDictionaryKind; }
225 
226     bool prototypeQueriesAreCacheable()
227     {
228         return !typeInfo().prohibitsPropertyCaching();
229     }
230 
231     bool propertyAccessesAreCacheable()
232     {
233         return dictionaryKind() != UncachedDictionaryKind
234             &amp;&amp; prototypeQueriesAreCacheable()
235             &amp;&amp; !(typeInfo().getOwnPropertySlotIsImpure() &amp;&amp; !typeInfo().newImpurePropertyFiresWatchpoints());
236     }
237 
238     bool propertyAccessesAreCacheableForAbsence()
239     {
240         return !typeInfo().getOwnPropertySlotIsImpureForPropertyAbsence();
241     }
242 
243     bool needImpurePropertyWatchpoint()
244     {
245         return propertyAccessesAreCacheable()
246             &amp;&amp; typeInfo().getOwnPropertySlotIsImpure()
247             &amp;&amp; typeInfo().newImpurePropertyFiresWatchpoints();
248     }
249 
250     bool isImmutablePrototypeExoticObject()
251     {
252         return typeInfo().isImmutablePrototypeExoticObject();
253     }
254 
255     // We use SlowPath in GetByStatus for structures that may get new impure properties later to prevent
256     // DFG from inlining property accesses since structures don&#39;t transition when a new impure property appears.
257     bool takesSlowPathInDFGForImpureProperty()
258     {
259         return typeInfo().getOwnPropertySlotIsImpure();
260     }
261 
262     // Type accessors.
263     TypeInfo typeInfo() const { return m_blob.typeInfo(m_outOfLineTypeFlags); }
264     bool isObject() const { return typeInfo().isObject(); }
265 
266     IndexingType indexingType() const { return m_blob.indexingModeIncludingHistory() &amp; AllWritableArrayTypes; }
267     IndexingType indexingMode() const  { return m_blob.indexingModeIncludingHistory() &amp; AllArrayTypes; }
268     IndexingType indexingModeIncludingHistory() const { return m_blob.indexingModeIncludingHistory(); }
269 
270     inline bool mayInterceptIndexedAccesses() const;
271 
272     bool holesMustForwardToPrototype(VM&amp;, JSObject*) const;
273 
274     JSGlobalObject* globalObject() const { return m_globalObject.get(); }
275 
276     // NOTE: This method should only be called during the creation of structures, since the global
277     // object of a structure is presumed to be immutable in a bunch of places.
278     void setGlobalObject(VM&amp;, JSGlobalObject*);
279 
280     ALWAYS_INLINE bool hasMonoProto() const
281     {
282         return !m_prototype.get().isEmpty();
283     }
284     ALWAYS_INLINE bool hasPolyProto() const
285     {
286         return !hasMonoProto();
287     }
288     ALWAYS_INLINE JSValue storedPrototype() const
289     {
290         ASSERT(hasMonoProto());
291         return m_prototype.get();
292     }
293     JSValue storedPrototype(const JSObject*) const;
294     JSObject* storedPrototypeObject(const JSObject*) const;
295     Structure* storedPrototypeStructure(const JSObject*) const;
296 
297     JSObject* storedPrototypeObject() const;
298     Structure* storedPrototypeStructure() const;
299     JSValue prototypeForLookup(JSGlobalObject*) const;
300     JSValue prototypeForLookup(JSGlobalObject*, JSCell* base) const;
301     StructureChain* prototypeChain(VM&amp;, JSGlobalObject*, JSObject* base) const;
302     StructureChain* prototypeChain(JSGlobalObject*, JSObject* base) const;
303     static void visitChildren(JSCell*, SlotVisitor&amp;);
304 
305     // A Structure is cheap to mark during GC if doing so would only add a small and bounded amount
306     // to our heap footprint. For example, if the structure refers to a global object that is not
307     // yet marked, then as far as we know, the decision to mark this Structure would lead to a large
308     // increase in footprint because no other object refers to that global object. This method
309     // returns true if all user-controlled (and hence unbounded in size) objects referenced from the
310     // Structure are already marked.
311     bool isCheapDuringGC(VM&amp;);
312 
313     // Returns true if this structure is now marked.
314     bool markIfCheap(SlotVisitor&amp;);
315 
316     bool hasRareData() const
317     {
318         return isRareData(m_previousOrRareData.get());
319     }
320 
321     StructureRareData* rareData()
322     {
323         ASSERT(hasRareData());
324         return static_cast&lt;StructureRareData*&gt;(m_previousOrRareData.get());
325     }
326 
327     const StructureRareData* rareData() const
328     {
329         ASSERT(hasRareData());
330         return static_cast&lt;const StructureRareData*&gt;(m_previousOrRareData.get());
331     }
332 
333     const StructureRareData* rareDataConcurrently() const
334     {
335         JSCell* cell = m_previousOrRareData.get();
336         if (isRareData(cell))
337             return static_cast&lt;StructureRareData*&gt;(cell);
338         return nullptr;
339     }
340 
341     StructureRareData* ensureRareData(VM&amp; vm)
342     {
343         if (!hasRareData())
344             allocateRareData(vm);
345         return rareData();
346     }
347 
348     Structure* previousID() const
349     {
350         ASSERT(structure()-&gt;classInfo() == info());
351         // This is so written because it&#39;s used concurrently. We only load from m_previousOrRareData
352         // once, and this load is guaranteed atomic.
353         JSCell* cell = m_previousOrRareData.get();
354         if (isRareData(cell))
355             return static_cast&lt;StructureRareData*&gt;(cell)-&gt;previousID();
356         return static_cast&lt;Structure*&gt;(cell);
357     }
358     bool transitivelyTransitionedFrom(Structure* structureToFind);
359 
360     PropertyOffset maxOffset() const
361     {
362         uint16_t maxOffset = m_maxOffset;
363         if (maxOffset == shortInvalidOffset)
364             return invalidOffset;
365         if (maxOffset == useRareDataFlag)
366             return rareData()-&gt;m_maxOffset;
367         return maxOffset;
368     }
369 
370     void setMaxOffset(VM&amp; vm, PropertyOffset offset)
371     {
372         if (offset == invalidOffset)
373             m_maxOffset = shortInvalidOffset;
374         else if (offset &lt; useRareDataFlag &amp;&amp; offset &lt; shortInvalidOffset)
375             m_maxOffset = offset;
376         else if (m_maxOffset == useRareDataFlag)
377             rareData()-&gt;m_maxOffset = offset;
378         else {
379             ensureRareData(vm)-&gt;m_maxOffset = offset;
380             WTF::storeStoreFence();
381             m_maxOffset = useRareDataFlag;
382         }
383     }
384 
385     PropertyOffset transitionOffset() const
386     {
387         uint16_t transitionOffset = m_transitionOffset;
388         if (transitionOffset == shortInvalidOffset)
389             return invalidOffset;
390         if (transitionOffset == useRareDataFlag)
391             return rareData()-&gt;m_transitionOffset;
392         return transitionOffset;
393     }
394 
395     void setTransitionOffset(VM&amp; vm, PropertyOffset offset)
396     {
397         if (offset == invalidOffset)
398             m_transitionOffset = shortInvalidOffset;
399         else if (offset &lt; useRareDataFlag &amp;&amp; offset &lt; shortInvalidOffset)
400             m_transitionOffset = offset;
401         else if (m_transitionOffset == useRareDataFlag)
402             rareData()-&gt;m_transitionOffset = offset;
403         else {
404             ensureRareData(vm)-&gt;m_transitionOffset = offset;
405             WTF::storeStoreFence();
406             m_transitionOffset = useRareDataFlag;
407         }
408     }
409 
410     static unsigned outOfLineCapacity(PropertyOffset maxOffset)
411     {
412         unsigned outOfLineSize = Structure::outOfLineSize(maxOffset);
413 
414         // This algorithm completely determines the out-of-line property storage growth algorithm.
415         // The JSObject code will only trigger a resize if the value returned by this algorithm
416         // changed between the new and old structure. So, it&#39;s important to keep this simple because
417         // it&#39;s on a fast path.
418 
419         if (!outOfLineSize)
420             return 0;
421 
422         if (outOfLineSize &lt;= initialOutOfLineCapacity)
423             return initialOutOfLineCapacity;
424 
425         ASSERT(outOfLineSize &gt; initialOutOfLineCapacity);
426         COMPILE_ASSERT(outOfLineGrowthFactor == 2, outOfLineGrowthFactor_is_two);
427         return WTF::roundUpToPowerOfTwo(outOfLineSize);
428     }
429 
430     static unsigned outOfLineSize(PropertyOffset maxOffset)
431     {
432         return numberOfOutOfLineSlotsForMaxOffset(maxOffset);
433     }
434 
435     unsigned outOfLineCapacity() const
436     {
437         return outOfLineCapacity(maxOffset());
438     }
439     unsigned outOfLineSize() const
440     {
441         return outOfLineSize(maxOffset());
442     }
443     bool hasInlineStorage() const
444     {
445         return !!m_inlineCapacity;
446     }
447     unsigned inlineCapacity() const
448     {
449         return m_inlineCapacity;
450     }
451     unsigned inlineSize() const
452     {
453         return std::min&lt;unsigned&gt;(maxOffset() + 1, m_inlineCapacity);
454     }
455     unsigned totalStorageCapacity() const
456     {
457         ASSERT(structure()-&gt;classInfo() == info());
458         return outOfLineCapacity() + inlineCapacity();
459     }
460 
461     bool isValidOffset(PropertyOffset offset) const
462     {
463         return JSC::isValidOffset(offset)
464             &amp;&amp; offset &lt;= maxOffset()
465             &amp;&amp; (offset &lt; m_inlineCapacity || offset &gt;= firstOutOfLineOffset);
466     }
467 
468     bool hijacksIndexingHeader() const
469     {
470         return isTypedView(m_classInfo-&gt;typedArrayStorageType);
471     }
472 
473     bool couldHaveIndexingHeader() const
474     {
475         return hasIndexedProperties(indexingType())
476             || hijacksIndexingHeader();
477     }
478 
479     bool hasIndexingHeader(const JSCell*) const;
480 
481     bool masqueradesAsUndefined(JSGlobalObject* lexicalGlobalObject);
482 
483     PropertyOffset get(VM&amp;, PropertyName);
484     PropertyOffset get(VM&amp;, PropertyName, unsigned&amp; attributes);
485 
486     // This is a somewhat internalish method. It will call your functor while possibly holding the
487     // Structure&#39;s lock. There is no guarantee whether the lock is held or not in any particular
488     // call. So, you have to assume the worst. Also, the functor returns true if it wishes for you
489     // to continue or false if it&#39;s done.
490     template&lt;typename Functor&gt;
491     void forEachPropertyConcurrently(const Functor&amp;);
492 
493     template&lt;typename Functor&gt;
494     void forEachProperty(VM&amp;, const Functor&amp;);
495 
496     PropertyOffset getConcurrently(UniquedStringImpl* uid);
497     PropertyOffset getConcurrently(UniquedStringImpl* uid, unsigned&amp; attributes);
498 
499     Vector&lt;PropertyMapEntry&gt; getPropertiesConcurrently();
500 
501     void setHasGetterSetterPropertiesWithProtoCheck(bool is__proto__)
502     {
503         setHasGetterSetterProperties(true);
504         if (!is__proto__)
505             setHasReadOnlyOrGetterSetterPropertiesExcludingProto(true);
506     }
507 
508     void setContainsReadOnlyProperties() { setHasReadOnlyOrGetterSetterPropertiesExcludingProto(true); }
509 
510     void setHasCustomGetterSetterPropertiesWithProtoCheck(bool is__proto__)
511     {
512         setHasCustomGetterSetterProperties(true);
513         if (!is__proto__)
514             setHasReadOnlyOrGetterSetterPropertiesExcludingProto(true);
515     }
516 
517     void setCachedPropertyNameEnumerator(VM&amp;, JSPropertyNameEnumerator*);
518     JSPropertyNameEnumerator* cachedPropertyNameEnumerator() const;
519     bool canCachePropertyNameEnumerator(VM&amp;) const;
520     bool canAccessPropertiesQuicklyForEnumeration() const;
521 
522     void setCachedOwnKeys(VM&amp;, JSImmutableButterfly*);
523     JSImmutableButterfly* cachedOwnKeys() const;
524     JSImmutableButterfly* cachedOwnKeysIgnoringSentinel() const;
525     bool canCacheOwnKeys() const;
526 
527     void getPropertyNamesFromStructure(VM&amp;, PropertyNameArray&amp;, EnumerationMode);
528 
529     JSString* objectToStringValue()
530     {
531         if (!hasRareData())
532             return 0;
533         return rareData()-&gt;objectToStringValue();
534     }
535 
536     void setObjectToStringValue(JSGlobalObject*, VM&amp;, JSString* value, PropertySlot toStringTagSymbolSlot);
537 
538     const ClassInfo* classInfo() const { return m_classInfo; }
539 
540     static ptrdiff_t structureIDOffset()
541     {
542         return OBJECT_OFFSETOF(Structure, m_blob) + StructureIDBlob::structureIDOffset();
543     }
544 
545     static ptrdiff_t prototypeOffset()
546     {
547         return OBJECT_OFFSETOF(Structure, m_prototype);
548     }
549 
550     static ptrdiff_t globalObjectOffset()
551     {
552         return OBJECT_OFFSETOF(Structure, m_globalObject);
553     }
554 
555     static ptrdiff_t classInfoOffset()
556     {
557         return OBJECT_OFFSETOF(Structure, m_classInfo);
558     }
559 
560     static ptrdiff_t indexingModeIncludingHistoryOffset()
561     {
562         return OBJECT_OFFSETOF(Structure, m_blob) + StructureIDBlob::indexingModeIncludingHistoryOffset();
563     }
564 
565     static ptrdiff_t propertyTableUnsafeOffset()
566     {
567         return OBJECT_OFFSETOF(Structure, m_propertyTableUnsafe);
568     }
569 
570     static ptrdiff_t inlineCapacityOffset()
571     {
572         return OBJECT_OFFSETOF(Structure, m_inlineCapacity);
573     }
574 
575     static ptrdiff_t previousOrRareDataOffset()
576     {
577         return OBJECT_OFFSETOF(Structure, m_previousOrRareData);
578     }
579 
580     static Structure* createStructure(VM&amp;);
581 
582     bool transitionWatchpointSetHasBeenInvalidated() const
583     {
584         return m_transitionWatchpointSet.hasBeenInvalidated();
585     }
586 
587     bool transitionWatchpointSetIsStillValid() const
588     {
589         return m_transitionWatchpointSet.isStillValid();
590     }
591 
592     bool dfgShouldWatchIfPossible() const
593     {
594         // FIXME: We would like to not watch things that are unprofitable to watch, like
595         // dictionaries. Unfortunately, we can&#39;t do such things: a dictionary could get flattened,
596         // in which case it will start to appear watchable and so the DFG will think that it is
597         // watching it. We should come up with a comprehensive story for not watching things that
598         // aren&#39;t profitable to watch.
599         // https://bugs.webkit.org/show_bug.cgi?id=133625
600 
601         // - We don&#39;t watch Structures that either decided not to be watched, or whose predecessors
602         //   decided not to be watched. This happens when a transition is fired while being watched.
603         if (transitionWatchpointIsLikelyToBeFired())
604             return false;
605 
606         // - Don&#39;t watch Structures that had been dictionaries.
607         if (hasBeenDictionary())
608             return false;
609 
610         return true;
611     }
612 
613     bool dfgShouldWatch() const
614     {
615         return dfgShouldWatchIfPossible() &amp;&amp; transitionWatchpointSetIsStillValid();
616     }
617 
618     void addTransitionWatchpoint(Watchpoint* watchpoint) const
619     {
620         ASSERT(transitionWatchpointSetIsStillValid());
621         m_transitionWatchpointSet.add(watchpoint);
622     }
623 
624     void didTransitionFromThisStructure(DeferredStructureTransitionWatchpointFire* = nullptr) const;
625 
626     InlineWatchpointSet&amp; transitionWatchpointSet() const
627     {
628         return m_transitionWatchpointSet;
629     }
630 
631     WatchpointSet* ensurePropertyReplacementWatchpointSet(VM&amp;, PropertyOffset);
632     void startWatchingPropertyForReplacements(VM&amp; vm, PropertyOffset offset)
633     {
634         ensurePropertyReplacementWatchpointSet(vm, offset);
635     }
636     void startWatchingPropertyForReplacements(VM&amp;, PropertyName);
637     WatchpointSet* propertyReplacementWatchpointSet(PropertyOffset);
638     void didReplaceProperty(PropertyOffset);
639     void didCachePropertyReplacement(VM&amp;, PropertyOffset);
640 
641     void startWatchingInternalPropertiesIfNecessary(VM&amp; vm)
642     {
643         if (LIKELY(didWatchInternalProperties()))
644             return;
645         startWatchingInternalProperties(vm);
646     }
647 
648     Ref&lt;StructureShape&gt; toStructureShape(JSValue, bool&amp; sawPolyProtoStructure);
649 
650     void dump(PrintStream&amp;) const;
651     void dumpInContext(PrintStream&amp;, DumpContext*) const;
652     void dumpBrief(PrintStream&amp;, const CString&amp;) const;
653 
654     static void dumpContextHeader(PrintStream&amp;);
655 
656     ConcurrentJSLock&amp; lock() { return m_lock; }
657 
658     unsigned propertyHash() const { return m_propertyHash; }
659 
660     static bool shouldConvertToPolyProto(const Structure* a, const Structure* b);
661 
662     struct PropertyHashEntry {
663         const HashTable* table;
664         const HashTableValue* value;
665     };
666     Optional&lt;PropertyHashEntry&gt; findPropertyHashEntry(PropertyName) const;
667 
668     DECLARE_EXPORT_INFO;
669 
670 private:
671     typedef enum {
672         NoneDictionaryKind = 0,
673         CachedDictionaryKind = 1,
674         UncachedDictionaryKind = 2
675     } DictionaryKind;
676 
677 public:
678 #define DEFINE_BITFIELD(type, lowerName, upperName, width, offset) \
679     static constexpr uint32_t s_##lowerName##Shift = offset;\
680     static constexpr uint32_t s_##lowerName##Mask = ((1 &lt;&lt; (width - 1)) | ((1 &lt;&lt; (width - 1)) - 1));\
681     static constexpr uint32_t s_bitWidthOf##upperName = width;\
682     type lowerName() const { return static_cast&lt;type&gt;((m_bitField &gt;&gt; offset) &amp; s_##lowerName##Mask); }\
683     void set##upperName(type newValue) \
684     {\
685         m_bitField &amp;= ~(s_##lowerName##Mask &lt;&lt; offset);\
686         m_bitField |= (newValue &amp; s_##lowerName##Mask) &lt;&lt; offset;\
687     }
688 
689     DEFINE_BITFIELD(DictionaryKind, dictionaryKind, DictionaryKind, 2, 0);
690     DEFINE_BITFIELD(bool, isPinnedPropertyTable, IsPinnedPropertyTable, 1, 2);
691     DEFINE_BITFIELD(bool, hasGetterSetterProperties, HasGetterSetterProperties, 1, 3);
692     DEFINE_BITFIELD(bool, hasReadOnlyOrGetterSetterPropertiesExcludingProto, HasReadOnlyOrGetterSetterPropertiesExcludingProto, 1, 4);
693     DEFINE_BITFIELD(bool, isQuickPropertyAccessAllowedForEnumeration, IsQuickPropertyAccessAllowedForEnumeration, 1, 5);
694     DEFINE_BITFIELD(unsigned, transitionPropertyAttributes, TransitionPropertyAttributes, 14, 6);
695     DEFINE_BITFIELD(bool, didPreventExtensions, DidPreventExtensions, 1, 20);
696     DEFINE_BITFIELD(bool, didTransition, DidTransition, 1, 21);
697     DEFINE_BITFIELD(bool, staticPropertiesReified, StaticPropertiesReified, 1, 22);
698     DEFINE_BITFIELD(bool, hasBeenFlattenedBefore, HasBeenFlattenedBefore, 1, 23);
699     DEFINE_BITFIELD(bool, hasCustomGetterSetterProperties, HasCustomGetterSetterProperties, 1, 24);
700     DEFINE_BITFIELD(bool, didWatchInternalProperties, DidWatchInternalProperties, 1, 25);
701     DEFINE_BITFIELD(bool, transitionWatchpointIsLikelyToBeFired, TransitionWatchpointIsLikelyToBeFired, 1, 26);
702     DEFINE_BITFIELD(bool, hasBeenDictionary, HasBeenDictionary, 1, 27);
703     DEFINE_BITFIELD(bool, protectPropertyTableWhileTransitioning, ProtectPropertyTableWhileTransitioning, 1, 28);
704     DEFINE_BITFIELD(bool, hasUnderscoreProtoPropertyExcludingOriginalProto, HasUnderscoreProtoPropertyExcludingOriginalProto, 1, 29);
705     DEFINE_BITFIELD(bool, isPropertyDeletionTransition, IsPropertyDeletionTransition, 1, 30);
706 
707     static_assert(s_bitWidthOfTransitionPropertyAttributes &lt;= sizeof(TransitionPropertyAttributes) * 8);
708 
709 private:
710     friend class LLIntOffsetsExtractor;
711 
712     JS_EXPORT_PRIVATE Structure(VM&amp;, JSGlobalObject*, JSValue prototype, const TypeInfo&amp;, const ClassInfo*, IndexingType, unsigned inlineCapacity);
713     Structure(VM&amp;);
714     Structure(VM&amp;, Structure*, DeferredStructureTransitionWatchpointFire*);
715 
716     static Structure* create(VM&amp;, Structure*, DeferredStructureTransitionWatchpointFire* = nullptr);
717 
718     static Structure* addPropertyTransitionToExistingStructureImpl(Structure*, UniquedStringImpl* uid, unsigned attributes, PropertyOffset&amp;);
719 
720     // This will return the structure that has a usable property table, that property table,
721     // and the list of structures that we visited before we got to it. If it returns a
722     // non-null structure, it will also lock the structure that it returns; it is your job
723     // to unlock it.
724     void findStructuresAndMapForMaterialization(Vector&lt;Structure*, 8&gt;&amp; structures, Structure*&amp;, PropertyTable*&amp;);
725 
726     static Structure* toDictionaryTransition(VM&amp;, Structure*, DictionaryKind, DeferredStructureTransitionWatchpointFire* = nullptr);
727 
728     enum class ShouldPin { No, Yes };
729     template&lt;ShouldPin, typename Func&gt;
730     PropertyOffset add(VM&amp;, PropertyName, unsigned attributes, const Func&amp;);
731     PropertyOffset add(VM&amp;, PropertyName, unsigned attributes);
732     template&lt;ShouldPin, typename Func&gt;
733     PropertyOffset remove(VM&amp;, PropertyName, const Func&amp;);
734     PropertyOffset remove(VM&amp;, PropertyName);
735 
736     void checkConsistency();
737 
738     // This may grab the lock, or not. Do not call when holding the Structure&#39;s lock.
739     PropertyTable* ensurePropertyTableIfNotEmpty(VM&amp; vm)
740     {
741         if (PropertyTable* result = m_propertyTableUnsafe.get())
742             return result;
743         if (!previousID())
744             return nullptr;
745         return materializePropertyTable(vm);
746     }
747 
748     // This may grab the lock, or not. Do not call when holding the Structure&#39;s lock.
749     PropertyTable* ensurePropertyTable(VM&amp; vm)
750     {
751         if (PropertyTable* result = m_propertyTableUnsafe.get())
752             return result;
753         return materializePropertyTable(vm);
754     }
755 
756     PropertyTable* propertyTableOrNull() const
757     {
758         return m_propertyTableUnsafe.get();
759     }
760 
761     // This will grab the lock. Do not call when holding the Structure&#39;s lock.
762     JS_EXPORT_PRIVATE PropertyTable* materializePropertyTable(VM&amp;, bool setPropertyTable = true);
763 
764     void setPropertyTable(VM&amp; vm, PropertyTable* table);
765 
766     PropertyTable* takePropertyTableOrCloneIfPinned(VM&amp;);
767     PropertyTable* copyPropertyTableForPinning(VM&amp;);
768 
769     void setPreviousID(VM&amp;, Structure*);
770 
771     void clearPreviousID()
772     {
773         if (hasRareData())
774             rareData()-&gt;clearPreviousID();
775         else
776             m_previousOrRareData.clear();
777     }
778 
779     int transitionCountEstimate() const
780     {
781         // Since the number of transitions is often the same as the last offset (except if there are deletes)
782         // we keep the size of Structure down by not storing both.
783         return numberOfSlotsForMaxOffset(maxOffset(), m_inlineCapacity);
784     }
785 
786     bool isValid(JSGlobalObject*, StructureChain* cachedPrototypeChain, JSObject* base) const;
787 
788     // You have to hold the structure lock to do these.
789     JS_EXPORT_PRIVATE void pin(const AbstractLocker&amp;, VM&amp;, PropertyTable*);
790     void pinForCaching(const AbstractLocker&amp;, VM&amp;, PropertyTable*);
791 
792     bool isRareData(JSCell* cell) const
793     {
794         return cell &amp;&amp; cell-&gt;structureID() != structureID();
795     }
796 
797     template&lt;typename DetailsFunc&gt;
798     bool checkOffsetConsistency(PropertyTable*, const DetailsFunc&amp;) const;
799     bool checkOffsetConsistency() const;
800 
801     JS_EXPORT_PRIVATE void allocateRareData(VM&amp;);
802 
803     void startWatchingInternalProperties(VM&amp;);
804 
805     static constexpr int s_maxTransitionLength = 64;
806     static constexpr int s_maxTransitionLengthForNonEvalPutById = 512;
807 
808     // These need to be properly aligned at the beginning of the &#39;Structure&#39;
809     // part of the object.
810     StructureIDBlob m_blob;
811     TypeInfo::OutOfLineTypeFlags m_outOfLineTypeFlags;
812 
813     uint8_t m_inlineCapacity;
814 
815     ConcurrentJSLock m_lock;
816 
817     uint32_t m_bitField;
818 
819     WriteBarrier&lt;JSGlobalObject&gt; m_globalObject;
820     WriteBarrier&lt;Unknown&gt; m_prototype;
821     mutable WriteBarrier&lt;StructureChain&gt; m_cachedPrototypeChain;
822 
823     WriteBarrier&lt;JSCell&gt; m_previousOrRareData;
824 
825     RefPtr&lt;UniquedStringImpl&gt; m_transitionPropertyName;
826 
827     const ClassInfo* m_classInfo;
828 
829     StructureTransitionTable m_transitionTable;
830 
831     // Should be accessed through ensurePropertyTable(). During GC, it may be set to 0 by another thread.
832     // During a Heap Snapshot GC we avoid clearing the table so it is safe to use.
833     WriteBarrier&lt;PropertyTable&gt; m_propertyTableUnsafe;
834 
835     mutable InlineWatchpointSet m_transitionWatchpointSet;
836 
837     COMPILE_ASSERT(firstOutOfLineOffset &lt; 256, firstOutOfLineOffset_fits);
838 
839     uint16_t m_transitionOffset;
840     uint16_t m_maxOffset;
841 
842     uint32_t m_propertyHash;
843     TinyBloomFilter m_seenProperties;
844 
845     friend class VMInspector;
846     friend class JSDollarVMHelper;
847 };
848 
849 } // namespace JSC
    </pre>
  </body>
</html>
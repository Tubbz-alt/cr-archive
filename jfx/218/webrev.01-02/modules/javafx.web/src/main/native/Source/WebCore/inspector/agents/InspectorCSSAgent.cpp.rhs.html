<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorCSSAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2010 Google Inc. All rights reserved.
   3  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1.  Redistributions of source code must retain the above copyright
   9  *     notice, this list of conditions and the following disclaimer.
  10  * 2.  Redistributions in binary form must reproduce the above copyright
  11  *     notice, this list of conditions and the following disclaimer in the
  12  *     documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  16  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  17  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  18  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  19  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  20  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  21  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  23  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;InspectorCSSAgent.h&quot;
  28 
  29 #include &quot;CSSComputedStyleDeclaration.h&quot;
  30 #include &quot;CSSImportRule.h&quot;
  31 #include &quot;CSSParserFastPaths.h&quot;
  32 #include &quot;CSSParserMode.h&quot;
  33 #include &quot;CSSPropertyNames.h&quot;
  34 #include &quot;CSSPropertySourceData.h&quot;
  35 #include &quot;CSSRule.h&quot;
  36 #include &quot;CSSRuleList.h&quot;
  37 #include &quot;CSSStyleRule.h&quot;
  38 #include &quot;CSSStyleSheet.h&quot;
  39 #include &quot;CSSValueKeywords.h&quot;
  40 #include &quot;ContentSecurityPolicy.h&quot;
  41 #include &quot;DOMWindow.h&quot;
  42 #include &quot;FontCache.h&quot;
  43 #include &quot;Frame.h&quot;
  44 #include &quot;HTMLHeadElement.h&quot;
  45 #include &quot;HTMLStyleElement.h&quot;
  46 #include &quot;InspectorDOMAgent.h&quot;
  47 #include &quot;InspectorHistory.h&quot;
  48 #include &quot;InspectorPageAgent.h&quot;
  49 #include &quot;InstrumentingAgents.h&quot;
  50 #include &quot;Node.h&quot;
  51 #include &quot;NodeList.h&quot;
  52 #include &quot;PseudoElement.h&quot;
  53 #include &quot;RenderStyleConstants.h&quot;
  54 #include &quot;SVGStyleElement.h&quot;
  55 #include &quot;SelectorChecker.h&quot;
  56 #include &quot;ShadowRoot.h&quot;
  57 #include &quot;StyleProperties.h&quot;
  58 #include &quot;StylePropertyShorthand.h&quot;
  59 #include &quot;StyleResolver.h&quot;
  60 #include &quot;StyleRule.h&quot;
  61 #include &quot;StyleScope.h&quot;
  62 #include &quot;StyleSheetList.h&quot;
  63 #include &lt;JavaScriptCore/InspectorProtocolObjects.h&gt;
  64 #include &lt;wtf/Optional.h&gt;
  65 #include &lt;wtf/Ref.h&gt;
  66 #include &lt;wtf/Vector.h&gt;
  67 #include &lt;wtf/text/CString.h&gt;
  68 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  69 
  70 namespace WebCore {
  71 
  72 using namespace Inspector;
  73 
  74 enum ForcePseudoClassFlags {
  75     PseudoClassNone = 0,
  76     PseudoClassHover = 1 &lt;&lt; 0,
  77     PseudoClassFocus = 1 &lt;&lt; 1,
  78     PseudoClassActive = 1 &lt;&lt; 2,
  79     PseudoClassVisited = 1 &lt;&lt; 3
  80 };
  81 
  82 static unsigned computePseudoClassMask(const JSON::Array&amp; pseudoClassArray)
  83 {
  84     static NeverDestroyed&lt;String&gt; active(MAKE_STATIC_STRING_IMPL(&quot;active&quot;));
  85     static NeverDestroyed&lt;String&gt; hover(MAKE_STATIC_STRING_IMPL(&quot;hover&quot;));
  86     static NeverDestroyed&lt;String&gt; focus(MAKE_STATIC_STRING_IMPL(&quot;focus&quot;));
  87     static NeverDestroyed&lt;String&gt; visited(MAKE_STATIC_STRING_IMPL(&quot;visited&quot;));
  88     if (!pseudoClassArray.length())
  89         return PseudoClassNone;
  90 
  91     unsigned result = PseudoClassNone;
  92     for (auto&amp; pseudoClassValue : pseudoClassArray) {
  93         String pseudoClass;
  94         bool success = pseudoClassValue-&gt;asString(pseudoClass);
  95         if (!success)
  96             continue;
  97         if (pseudoClass == active)
  98             result |= PseudoClassActive;
  99         else if (pseudoClass == hover)
 100             result |= PseudoClassHover;
 101         else if (pseudoClass == focus)
 102             result |= PseudoClassFocus;
 103         else if (pseudoClass == visited)
 104             result |= PseudoClassVisited;
 105     }
 106 
 107     return result;
 108 }
 109 
 110 class InspectorCSSAgent::StyleSheetAction : public InspectorHistory::Action {
 111     WTF_MAKE_NONCOPYABLE(StyleSheetAction);
 112 public:
 113     StyleSheetAction(InspectorStyleSheet* styleSheet)
 114         : InspectorHistory::Action()
 115         , m_styleSheet(styleSheet)
 116     {
 117     }
 118 
 119 protected:
 120     RefPtr&lt;InspectorStyleSheet&gt; m_styleSheet;
 121 };
 122 
 123 class InspectorCSSAgent::SetStyleSheetTextAction final : public InspectorCSSAgent::StyleSheetAction {
 124     WTF_MAKE_NONCOPYABLE(SetStyleSheetTextAction);
 125 public:
 126     SetStyleSheetTextAction(InspectorStyleSheet* styleSheet, const String&amp; text)
 127         : InspectorCSSAgent::StyleSheetAction(styleSheet)
 128         , m_text(text)
 129     {
 130     }
 131 
 132 private:
 133     ExceptionOr&lt;void&gt; perform() final
 134     {
 135         auto result = m_styleSheet-&gt;text();
 136         if (result.hasException())
 137             return result.releaseException();
 138         m_oldText = result.releaseReturnValue();
 139         return redo();
 140     }
 141 
 142     ExceptionOr&lt;void&gt; undo() final
 143     {
 144         auto result = m_styleSheet-&gt;setText(m_oldText);
 145         if (result.hasException())
 146             return result.releaseException();
 147         m_styleSheet-&gt;reparseStyleSheet(m_oldText);
 148         return { };
 149     }
 150 
 151     ExceptionOr&lt;void&gt; redo() final
 152     {
 153         auto result = m_styleSheet-&gt;setText(m_text);
 154         if (result.hasException())
 155             return result.releaseException();
 156         m_styleSheet-&gt;reparseStyleSheet(m_text);
 157         return { };
 158     }
 159 
 160     String mergeId() final
 161     {
 162         return &quot;SetStyleSheetText &quot; + m_styleSheet-&gt;id();
 163     }
 164 
 165     void merge(std::unique_ptr&lt;Action&gt; action) override
 166     {
 167         ASSERT(action-&gt;mergeId() == mergeId());
 168         m_text = static_cast&lt;SetStyleSheetTextAction&amp;&gt;(*action).m_text;
 169     }
 170 
 171     String m_text;
 172     String m_oldText;
 173 };
 174 
 175 class InspectorCSSAgent::SetStyleTextAction final : public InspectorCSSAgent::StyleSheetAction {
 176     WTF_MAKE_NONCOPYABLE(SetStyleTextAction);
 177 public:
 178     SetStyleTextAction(InspectorStyleSheet* styleSheet, const InspectorCSSId&amp; cssId, const String&amp; text)
 179         : InspectorCSSAgent::StyleSheetAction(styleSheet)
 180         , m_cssId(cssId)
 181         , m_text(text)
 182     {
 183     }
 184 
 185     ExceptionOr&lt;void&gt; perform() override
 186     {
 187         return redo();
 188     }
 189 
 190     ExceptionOr&lt;void&gt; undo() override
 191     {
 192         return m_styleSheet-&gt;setStyleText(m_cssId, m_oldText, nullptr);
 193     }
 194 
 195     ExceptionOr&lt;void&gt; redo() override
 196     {
 197         return m_styleSheet-&gt;setStyleText(m_cssId, m_text, &amp;m_oldText);
 198     }
 199 
 200     String mergeId() override
 201     {
 202         ASSERT(m_styleSheet-&gt;id() == m_cssId.styleSheetId());
 203         return makeString(&quot;SetStyleText &quot;, m_styleSheet-&gt;id(), &#39;:&#39;, m_cssId.ordinal());
 204     }
 205 
 206     void merge(std::unique_ptr&lt;Action&gt; action) override
 207     {
 208         ASSERT(action-&gt;mergeId() == mergeId());
 209 
 210         SetStyleTextAction* other = static_cast&lt;SetStyleTextAction*&gt;(action.get());
 211         m_text = other-&gt;m_text;
 212     }
 213 
 214 private:
 215     InspectorCSSId m_cssId;
 216     String m_text;
 217     String m_oldText;
 218 };
 219 
 220 class InspectorCSSAgent::SetRuleSelectorAction final : public InspectorCSSAgent::StyleSheetAction {
 221     WTF_MAKE_NONCOPYABLE(SetRuleSelectorAction);
 222 public:
 223     SetRuleSelectorAction(InspectorStyleSheet* styleSheet, const InspectorCSSId&amp; cssId, const String&amp; selector)
 224         : InspectorCSSAgent::StyleSheetAction(styleSheet)
 225         , m_cssId(cssId)
 226         , m_selector(selector)
 227     {
 228     }
 229 
 230 private:
 231     ExceptionOr&lt;void&gt; perform() final
 232     {
 233         auto result = m_styleSheet-&gt;ruleSelector(m_cssId);
 234         if (result.hasException())
 235             return result.releaseException();
 236         m_oldSelector = result.releaseReturnValue();
 237         return redo();
 238     }
 239 
 240     ExceptionOr&lt;void&gt; undo() final
 241     {
 242         return m_styleSheet-&gt;setRuleSelector(m_cssId, m_oldSelector);
 243     }
 244 
 245     ExceptionOr&lt;void&gt; redo() final
 246     {
 247         return m_styleSheet-&gt;setRuleSelector(m_cssId, m_selector);
 248     }
 249 
 250     InspectorCSSId m_cssId;
 251     String m_selector;
 252     String m_oldSelector;
 253 };
 254 
 255 class InspectorCSSAgent::AddRuleAction final : public InspectorCSSAgent::StyleSheetAction {
 256     WTF_MAKE_NONCOPYABLE(AddRuleAction);
 257 public:
 258     AddRuleAction(InspectorStyleSheet* styleSheet, const String&amp; selector)
 259         : InspectorCSSAgent::StyleSheetAction(styleSheet)
 260         , m_selector(selector)
 261     {
 262     }
 263 
 264     InspectorCSSId newRuleId() const { return m_newId; }
 265 
 266 private:
 267     ExceptionOr&lt;void&gt; perform() final
 268     {
 269         return redo();
 270     }
 271 
 272     ExceptionOr&lt;void&gt; undo() final
 273     {
 274         return m_styleSheet-&gt;deleteRule(m_newId);
 275     }
 276 
 277     ExceptionOr&lt;void&gt; redo() final
 278     {
 279         auto result = m_styleSheet-&gt;addRule(m_selector);
 280         if (result.hasException())
 281             return result.releaseException();
 282         m_newId = m_styleSheet-&gt;ruleId(result.releaseReturnValue());
 283         return { };
 284     }
 285 
 286     InspectorCSSId m_newId;
 287     String m_selector;
 288     String m_oldSelector;
 289 };
 290 
 291 CSSStyleRule* InspectorCSSAgent::asCSSStyleRule(CSSRule&amp; rule)
 292 {
 293     if (!is&lt;CSSStyleRule&gt;(rule))
 294         return nullptr;
 295     return downcast&lt;CSSStyleRule&gt;(&amp;rule);
 296 }
 297 
 298 InspectorCSSAgent::InspectorCSSAgent(WebAgentContext&amp; context)
 299     : InspectorAgentBase(&quot;CSS&quot;_s, context)
 300     , m_frontendDispatcher(makeUnique&lt;CSSFrontendDispatcher&gt;(context.frontendRouter))
 301     , m_backendDispatcher(CSSBackendDispatcher::create(context.backendDispatcher, this))
 302 {
 303 }
 304 
 305 InspectorCSSAgent::~InspectorCSSAgent() = default;
 306 
 307 void InspectorCSSAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
 308 {
 309 }
 310 
 311 void InspectorCSSAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
 312 {
 313     String unused;
 314     disable(unused);
 315 }
 316 
 317 void InspectorCSSAgent::reset()
 318 {
 319     // FIXME: Should we be resetting on main frame navigations?
 320     m_idToInspectorStyleSheet.clear();
 321     m_cssStyleSheetToInspectorStyleSheet.clear();
 322     m_nodeToInspectorStyleSheet.clear();
 323     m_documentToInspectorStyleSheet.clear();
 324     m_documentToKnownCSSStyleSheets.clear();
 325     resetPseudoStates();
 326 }
 327 
 328 void InspectorCSSAgent::enable(ErrorString&amp;)
 329 {
 330     if (m_instrumentingAgents.inspectorCSSAgent() == this)
 331         return;
 332 
 333     m_instrumentingAgents.setInspectorCSSAgent(this);
 334 
 335     if (auto* domAgent = m_instrumentingAgents.inspectorDOMAgent()) {
 336         for (auto* document : domAgent-&gt;documents())
 337             activeStyleSheetsUpdated(*document);
 338     }
 339 }
 340 
 341 void InspectorCSSAgent::disable(ErrorString&amp;)
 342 {
 343     m_instrumentingAgents.setInspectorCSSAgent(nullptr);
 344 
 345     reset();
 346 }
 347 
 348 void InspectorCSSAgent::documentDetached(Document&amp; document)
 349 {
 350     Vector&lt;CSSStyleSheet*&gt; emptyList;
 351     setActiveStyleSheetsForDocument(document, emptyList);
 352 
 353     m_documentToKnownCSSStyleSheets.remove(&amp;document);
 354     m_documentToInspectorStyleSheet.remove(&amp;document);
 355     m_documentsWithForcedPseudoStates.remove(&amp;document);
 356 }
 357 
 358 void InspectorCSSAgent::mediaQueryResultChanged()
 359 {
 360     m_frontendDispatcher-&gt;mediaQueryResultChanged();
 361 }
 362 
 363 void InspectorCSSAgent::activeStyleSheetsUpdated(Document&amp; document)
 364 {
 365     Vector&lt;CSSStyleSheet*&gt; cssStyleSheets;
 366     collectAllDocumentStyleSheets(document, cssStyleSheets);
 367 
 368     setActiveStyleSheetsForDocument(document, cssStyleSheets);
 369 }
 370 
 371 void InspectorCSSAgent::setActiveStyleSheetsForDocument(Document&amp; document, Vector&lt;CSSStyleSheet*&gt;&amp; activeStyleSheets)
 372 {
 373     HashSet&lt;CSSStyleSheet*&gt;&amp; previouslyKnownActiveStyleSheets = m_documentToKnownCSSStyleSheets.add(&amp;document, HashSet&lt;CSSStyleSheet*&gt;()).iterator-&gt;value;
 374 
 375     HashSet&lt;CSSStyleSheet*&gt; removedStyleSheets(previouslyKnownActiveStyleSheets);
 376     Vector&lt;CSSStyleSheet*&gt; addedStyleSheets;
 377     for (auto&amp; activeStyleSheet : activeStyleSheets) {
 378         if (removedStyleSheets.contains(activeStyleSheet))
 379             removedStyleSheets.remove(activeStyleSheet);
 380         else
 381             addedStyleSheets.append(activeStyleSheet);
 382     }
 383 
 384     for (auto* cssStyleSheet : removedStyleSheets) {
 385         previouslyKnownActiveStyleSheets.remove(cssStyleSheet);
 386         RefPtr&lt;InspectorStyleSheet&gt; inspectorStyleSheet = m_cssStyleSheetToInspectorStyleSheet.get(cssStyleSheet);
 387         if (m_idToInspectorStyleSheet.contains(inspectorStyleSheet-&gt;id())) {
 388             String id = unbindStyleSheet(inspectorStyleSheet.get());
 389             m_frontendDispatcher-&gt;styleSheetRemoved(id);
 390         }
 391     }
 392 
 393     for (auto* cssStyleSheet : addedStyleSheets) {
 394         previouslyKnownActiveStyleSheets.add(cssStyleSheet);
 395         if (!m_cssStyleSheetToInspectorStyleSheet.contains(cssStyleSheet)) {
 396             InspectorStyleSheet* inspectorStyleSheet = bindStyleSheet(cssStyleSheet);
 397             m_frontendDispatcher-&gt;styleSheetAdded(inspectorStyleSheet-&gt;buildObjectForStyleSheetInfo());
 398         }
 399     }
 400 }
 401 
 402 bool InspectorCSSAgent::forcePseudoState(const Element&amp; element, CSSSelector::PseudoClassType pseudoClassType)
 403 {
 404     if (m_nodeIdToForcedPseudoState.isEmpty())
 405         return false;
 406 
 407     auto* domAgent = m_instrumentingAgents.inspectorDOMAgent();
 408     if (!domAgent)
 409         return false;
 410 
 411     int nodeId = domAgent-&gt;boundNodeId(&amp;element);
 412     if (!nodeId)
 413         return false;
 414 
 415     unsigned forcedPseudoState = m_nodeIdToForcedPseudoState.get(nodeId);
 416     switch (pseudoClassType) {
 417     case CSSSelector::PseudoClassActive:
 418         return forcedPseudoState &amp; PseudoClassActive;
 419     case CSSSelector::PseudoClassFocus:
 420         return forcedPseudoState &amp; PseudoClassFocus;
 421     case CSSSelector::PseudoClassHover:
 422         return forcedPseudoState &amp; PseudoClassHover;
 423     case CSSSelector::PseudoClassVisited:
 424         return forcedPseudoState &amp; PseudoClassVisited;
 425     default:
 426         return false;
 427     }
 428 }
 429 
 430 static Optional&lt;Inspector::Protocol::CSS::PseudoId&gt; protocolValueForPseudoId(PseudoId pseudoId)
 431 {
 432     switch (pseudoId) {
 433     case PseudoId::FirstLine:
 434         return Inspector::Protocol::CSS::PseudoId::FirstLine;
 435     case PseudoId::FirstLetter:
 436         return Inspector::Protocol::CSS::PseudoId::FirstLetter;
 437     case PseudoId::Marker:
 438         return Inspector::Protocol::CSS::PseudoId::Marker;
 439     case PseudoId::Before:
 440         return Inspector::Protocol::CSS::PseudoId::Before;
 441     case PseudoId::After:
 442         return Inspector::Protocol::CSS::PseudoId::After;
 443     case PseudoId::Selection:
 444         return Inspector::Protocol::CSS::PseudoId::Selection;
<a name="1" id="anc1"></a><span class="line-added"> 445     case PseudoId::Highlight:</span>
<span class="line-added"> 446         return Inspector::Protocol::CSS::PseudoId::Highlight;</span>
 447     case PseudoId::Scrollbar:
 448         return Inspector::Protocol::CSS::PseudoId::Scrollbar;
 449     case PseudoId::ScrollbarThumb:
 450         return Inspector::Protocol::CSS::PseudoId::ScrollbarThumb;
 451     case PseudoId::ScrollbarButton:
 452         return Inspector::Protocol::CSS::PseudoId::ScrollbarButton;
 453     case PseudoId::ScrollbarTrack:
 454         return Inspector::Protocol::CSS::PseudoId::ScrollbarTrack;
 455     case PseudoId::ScrollbarTrackPiece:
 456         return Inspector::Protocol::CSS::PseudoId::ScrollbarTrackPiece;
 457     case PseudoId::ScrollbarCorner:
 458         return Inspector::Protocol::CSS::PseudoId::ScrollbarCorner;
 459     case PseudoId::Resizer:
 460         return Inspector::Protocol::CSS::PseudoId::Resizer;
 461 
 462     default:
 463         ASSERT_NOT_REACHED();
 464         return { };
 465     }
 466 }
 467 
 468 void InspectorCSSAgent::getMatchedStylesForNode(ErrorString&amp; errorString, int nodeId, const bool* includePseudo, const bool* includeInherited, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::CSS::RuleMatch&gt;&gt;&amp; matchedCSSRules, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::CSS::PseudoIdMatches&gt;&gt;&amp; pseudoIdMatches, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::CSS::InheritedStyleEntry&gt;&gt;&amp; inheritedEntries)
 469 {
 470     Element* element = elementForId(errorString, nodeId);
 471     if (!element)
 472         return;
 473 
 474     Element* originalElement = element;
 475     PseudoId elementPseudoId = element-&gt;pseudoId();
 476     if (elementPseudoId != PseudoId::None) {
 477         element = downcast&lt;PseudoElement&gt;(*element).hostElement();
 478         if (!element) {
 479             errorString = &quot;Missing parent of pseudo-element node for given nodeId&quot;_s;
 480             return;
 481         }
 482     }
 483 
 484     // Matched rules.
<a name="2" id="anc2"></a><span class="line-modified"> 485     auto&amp; styleResolver = element-&gt;styleResolver();</span>
<span class="line-modified"> 486     auto matchedRules = styleResolver.pseudoStyleRulesForElement(element, elementPseudoId, Style::Resolver::AllCSSRules);</span>
 487     matchedCSSRules = buildArrayForMatchedRuleList(matchedRules, styleResolver, *element, elementPseudoId);
 488 
 489     if (!originalElement-&gt;isPseudoElement()) {
 490         // Pseudo elements.
 491         if (!includePseudo || *includePseudo) {
 492             auto pseudoElements = JSON::ArrayOf&lt;Inspector::Protocol::CSS::PseudoIdMatches&gt;::create();
 493             for (PseudoId pseudoId = PseudoId::FirstPublicPseudoId; pseudoId &lt; PseudoId::AfterLastInternalPseudoId; pseudoId = static_cast&lt;PseudoId&gt;(static_cast&lt;unsigned&gt;(pseudoId) + 1)) {
 494                 if (auto protocolPseudoId = protocolValueForPseudoId(pseudoId)) {
<a name="3" id="anc3"></a><span class="line-modified"> 495                     auto matchedRules = styleResolver.pseudoStyleRulesForElement(element, pseudoId, Style::Resolver::AllCSSRules);</span>
 496                     if (!matchedRules.isEmpty()) {
 497                         auto matches = Inspector::Protocol::CSS::PseudoIdMatches::create()
 498                             .setPseudoId(protocolPseudoId.value())
 499                             .setMatches(buildArrayForMatchedRuleList(matchedRules, styleResolver, *element, pseudoId))
 500                             .release();
 501                         pseudoElements-&gt;addItem(WTFMove(matches));
 502                     }
 503                 }
 504             }
 505 
 506             pseudoIdMatches = WTFMove(pseudoElements);
 507         }
 508 
 509         // Inherited styles.
 510         if (!includeInherited || *includeInherited) {
 511             auto entries = JSON::ArrayOf&lt;Inspector::Protocol::CSS::InheritedStyleEntry&gt;::create();
 512             Element* parentElement = element-&gt;parentElement();
 513             while (parentElement) {
<a name="4" id="anc4"></a><span class="line-modified"> 514                 auto&amp; parentStyleResolver = parentElement-&gt;styleResolver();</span>
<span class="line-modified"> 515                 auto parentMatchedRules = parentStyleResolver.styleRulesForElement(parentElement, Style::Resolver::AllCSSRules);</span>
 516                 auto entry = Inspector::Protocol::CSS::InheritedStyleEntry::create()
 517                     .setMatchedCSSRules(buildArrayForMatchedRuleList(parentMatchedRules, styleResolver, *parentElement, PseudoId::None))
 518                     .release();
 519                 if (is&lt;StyledElement&gt;(*parentElement) &amp;&amp; downcast&lt;StyledElement&gt;(*parentElement).cssomStyle().length()) {
 520                     auto&amp; styleSheet = asInspectorStyleSheet(downcast&lt;StyledElement&gt;(*parentElement));
 521                     entry-&gt;setInlineStyle(styleSheet.buildObjectForStyle(styleSheet.styleForId(InspectorCSSId(styleSheet.id(), 0))));
 522                 }
 523 
 524                 entries-&gt;addItem(WTFMove(entry));
 525                 parentElement = parentElement-&gt;parentElement();
 526             }
 527 
 528             inheritedEntries = WTFMove(entries);
 529         }
 530     }
 531 }
 532 
 533 void InspectorCSSAgent::getInlineStylesForNode(ErrorString&amp; errorString, int nodeId, RefPtr&lt;Inspector::Protocol::CSS::CSSStyle&gt;&amp; inlineStyle, RefPtr&lt;Inspector::Protocol::CSS::CSSStyle&gt;&amp; attributesStyle)
 534 {
 535     auto* element = elementForId(errorString, nodeId);
 536     if (!is&lt;StyledElement&gt;(element))
 537         return;
 538 
 539     auto&amp; styledElement = downcast&lt;StyledElement&gt;(*element);
 540     auto&amp; styleSheet = asInspectorStyleSheet(styledElement);
 541     inlineStyle = styleSheet.buildObjectForStyle(&amp;styledElement.cssomStyle());
 542     if (auto attributes = buildObjectForAttributesStyle(styledElement))
 543         attributesStyle = WTFMove(attributes);
 544     else
 545         attributesStyle = nullptr;
 546 }
 547 
 548 void InspectorCSSAgent::getComputedStyleForNode(ErrorString&amp; errorString, int nodeId, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSComputedStyleProperty&gt;&gt;&amp; style)
 549 {
 550     auto* element = elementForId(errorString, nodeId);
 551     if (!element)
 552         return;
 553 
 554     auto computedStyleInfo = CSSComputedStyleDeclaration::create(*element, true);
 555     auto inspectorStyle = InspectorStyle::create(InspectorCSSId(), WTFMove(computedStyleInfo), nullptr);
 556     style = inspectorStyle-&gt;buildArrayForComputedStyle();
 557 }
 558 
 559 void InspectorCSSAgent::getAllStyleSheets(ErrorString&amp;, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSStyleSheetHeader&gt;&gt;&amp; styleInfos)
 560 {
 561     styleInfos = JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSStyleSheetHeader&gt;::create();
 562 
 563     Vector&lt;InspectorStyleSheet*&gt; inspectorStyleSheets;
 564     collectAllStyleSheets(inspectorStyleSheets);
 565     for (auto* inspectorStyleSheet : inspectorStyleSheets)
 566         styleInfos-&gt;addItem(inspectorStyleSheet-&gt;buildObjectForStyleSheetInfo());
 567 }
 568 
 569 void InspectorCSSAgent::collectAllStyleSheets(Vector&lt;InspectorStyleSheet*&gt;&amp; result)
 570 {
 571     Vector&lt;CSSStyleSheet*&gt; cssStyleSheets;
 572     if (auto* domAgent = m_instrumentingAgents.inspectorDOMAgent()) {
 573         for (auto* document : domAgent-&gt;documents())
 574             collectAllDocumentStyleSheets(*document, cssStyleSheets);
 575     }
 576 
 577     for (auto* cssStyleSheet : cssStyleSheets)
 578         result.append(bindStyleSheet(cssStyleSheet));
 579 }
 580 
 581 void InspectorCSSAgent::collectAllDocumentStyleSheets(Document&amp; document, Vector&lt;CSSStyleSheet*&gt;&amp; result)
 582 {
 583     auto cssStyleSheets = document.styleScope().activeStyleSheetsForInspector();
 584     for (auto&amp; cssStyleSheet : cssStyleSheets)
 585         collectStyleSheets(cssStyleSheet.get(), result);
 586 }
 587 
 588 void InspectorCSSAgent::collectStyleSheets(CSSStyleSheet* styleSheet, Vector&lt;CSSStyleSheet*&gt;&amp; result)
 589 {
 590     result.append(styleSheet);
 591 
 592     for (unsigned i = 0, size = styleSheet-&gt;length(); i &lt; size; ++i) {
 593         CSSRule* rule = styleSheet-&gt;item(i);
 594         if (is&lt;CSSImportRule&gt;(*rule)) {
 595             if (CSSStyleSheet* importedStyleSheet = downcast&lt;CSSImportRule&gt;(*rule).styleSheet())
 596                 collectStyleSheets(importedStyleSheet, result);
 597         }
 598     }
 599 }
 600 
 601 void InspectorCSSAgent::getStyleSheet(ErrorString&amp; errorString, const String&amp; styleSheetId, RefPtr&lt;Inspector::Protocol::CSS::CSSStyleSheetBody&gt;&amp; styleSheetObject)
 602 {
 603     InspectorStyleSheet* inspectorStyleSheet = assertStyleSheetForId(errorString, styleSheetId);
 604     if (!inspectorStyleSheet)
 605         return;
 606 
 607     styleSheetObject = inspectorStyleSheet-&gt;buildObjectForStyleSheet();
 608 }
 609 
 610 void InspectorCSSAgent::getStyleSheetText(ErrorString&amp; errorString, const String&amp; styleSheetId, String* result)
 611 {
 612     InspectorStyleSheet* inspectorStyleSheet = assertStyleSheetForId(errorString, styleSheetId);
 613     if (!inspectorStyleSheet)
 614         return;
 615 
 616     auto text = inspectorStyleSheet-&gt;text();
 617     if (!text.hasException())
 618         *result = text.releaseReturnValue();
 619 }
 620 
 621 void InspectorCSSAgent::setStyleSheetText(ErrorString&amp; errorString, const String&amp; styleSheetId, const String&amp; text)
 622 {
 623     InspectorStyleSheet* inspectorStyleSheet = assertStyleSheetForId(errorString, styleSheetId);
 624     if (!inspectorStyleSheet)
 625         return;
 626 
 627     auto* domAgent = m_instrumentingAgents.inspectorDOMAgent();
 628     if (!domAgent) {
 629         errorString = &quot;DOM domain must be enabled&quot;_s;
 630         return;
 631     }
 632 
 633     auto result = domAgent-&gt;history()-&gt;perform(makeUnique&lt;SetStyleSheetTextAction&gt;(inspectorStyleSheet, text));
 634     if (result.hasException())
 635         errorString = InspectorDOMAgent::toErrorString(result.releaseException());
 636 }
 637 
 638 void InspectorCSSAgent::setStyleText(ErrorString&amp; errorString, const JSON::Object&amp; fullStyleId, const String&amp; text, RefPtr&lt;Inspector::Protocol::CSS::CSSStyle&gt;&amp; result)
 639 {
 640     InspectorCSSId compoundId(fullStyleId);
 641     ASSERT(!compoundId.isEmpty());
 642 
 643     InspectorStyleSheet* inspectorStyleSheet = assertStyleSheetForId(errorString, compoundId.styleSheetId());
 644     if (!inspectorStyleSheet)
 645         return;
 646 
 647     auto* domAgent = m_instrumentingAgents.inspectorDOMAgent();
 648     if (!domAgent) {
 649         errorString = &quot;DOM domain must be enabled&quot;_s;
 650         return;
 651     }
 652 
 653     auto performResult = domAgent-&gt;history()-&gt;perform(makeUnique&lt;SetStyleTextAction&gt;(inspectorStyleSheet, compoundId, text));
 654     if (performResult.hasException()) {
 655         errorString = InspectorDOMAgent::toErrorString(performResult.releaseException());
 656         return;
 657     }
 658 
 659     result = inspectorStyleSheet-&gt;buildObjectForStyle(inspectorStyleSheet-&gt;styleForId(compoundId));
 660 }
 661 
 662 void InspectorCSSAgent::setRuleSelector(ErrorString&amp; errorString, const JSON::Object&amp; fullRuleId, const String&amp; selector, RefPtr&lt;Inspector::Protocol::CSS::CSSRule&gt;&amp; result)
 663 {
 664     InspectorCSSId compoundId(fullRuleId);
 665     ASSERT(!compoundId.isEmpty());
 666 
 667     InspectorStyleSheet* inspectorStyleSheet = assertStyleSheetForId(errorString, compoundId.styleSheetId());
 668     if (!inspectorStyleSheet)
 669         return;
 670 
 671     auto* domAgent = m_instrumentingAgents.inspectorDOMAgent();
 672     if (!domAgent) {
 673         errorString = &quot;DOM domain must be enabled&quot;_s;
 674         return;
 675     }
 676 
 677     auto performResult = domAgent-&gt;history()-&gt;perform(makeUnique&lt;SetRuleSelectorAction&gt;(inspectorStyleSheet, compoundId, selector));
 678     if (performResult.hasException()) {
 679         errorString = InspectorDOMAgent::toErrorString(performResult.releaseException());
 680         return;
 681     }
 682 
 683     result = inspectorStyleSheet-&gt;buildObjectForRule(inspectorStyleSheet-&gt;ruleForId(compoundId), nullptr);
 684 }
 685 
 686 void InspectorCSSAgent::createStyleSheet(ErrorString&amp; errorString, const String&amp; frameId, String* styleSheetId)
 687 {
 688     auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();
 689     if (!pageAgent) {
 690         errorString = &quot;Page domain must be enabled&quot;_s;
 691         return;
 692     }
 693 
 694     auto* frame = pageAgent-&gt;assertFrame(errorString, frameId);
 695     if (!frame)
 696         return;
 697 
 698     Document* document = frame-&gt;document();
 699     if (!document) {
 700         errorString = &quot;Missing document of frame for given frameId&quot;_s;
 701         return;
 702     }
 703 
 704     InspectorStyleSheet* inspectorStyleSheet = createInspectorStyleSheetForDocument(*document);
 705     if (!inspectorStyleSheet) {
 706         errorString = &quot;Could not create style sheet for document of frame for given frameId&quot;_s;
 707         return;
 708     }
 709 
 710     *styleSheetId = inspectorStyleSheet-&gt;id();
 711 }
 712 
 713 InspectorStyleSheet* InspectorCSSAgent::createInspectorStyleSheetForDocument(Document&amp; document)
 714 {
 715     if (!document.isHTMLDocument() &amp;&amp; !document.isSVGDocument())
 716         return nullptr;
 717 
 718     auto styleElement = HTMLStyleElement::create(document);
 719     styleElement-&gt;setAttributeWithoutSynchronization(HTMLNames::typeAttr, AtomString(&quot;text/css&quot;, AtomString::ConstructFromLiteral));
 720 
 721     ContainerNode* targetNode;
 722     // HEAD is absent in ImageDocuments, for example.
 723     if (auto* head = document.head())
 724         targetNode = head;
 725     else if (auto* body = document.bodyOrFrameset())
 726         targetNode = body;
 727     else
 728         return nullptr;
 729 
 730     // Inserting this &lt;style&gt; into the document will trigger activeStyleSheetsUpdated
 731     // and we will create an InspectorStyleSheet for this &lt;style&gt;&#39;s CSSStyleSheet.
 732     // Set this flag, so when we create it, we put it into the via inspector map.
 733     m_creatingViaInspectorStyleSheet = true;
 734     InlineStyleOverrideScope overrideScope(document);
 735     auto appendResult = targetNode-&gt;appendChild(styleElement);
 736     document.styleScope().flushPendingUpdate();
 737     m_creatingViaInspectorStyleSheet = false;
 738     if (appendResult.hasException())
 739         return nullptr;
 740 
 741     auto iterator = m_documentToInspectorStyleSheet.find(&amp;document);
 742     ASSERT(iterator != m_documentToInspectorStyleSheet.end());
 743     if (iterator == m_documentToInspectorStyleSheet.end())
 744         return nullptr;
 745 
 746     auto&amp; inspectorStyleSheetsForDocument = iterator-&gt;value;
 747     ASSERT(!inspectorStyleSheetsForDocument.isEmpty());
 748     if (inspectorStyleSheetsForDocument.isEmpty())
 749         return nullptr;
 750 
 751     return inspectorStyleSheetsForDocument.last().get();
 752 }
 753 
 754 void InspectorCSSAgent::addRule(ErrorString&amp; errorString, const String&amp; styleSheetId, const String&amp; selector, RefPtr&lt;Inspector::Protocol::CSS::CSSRule&gt;&amp; result)
 755 {
 756     InspectorStyleSheet* inspectorStyleSheet = assertStyleSheetForId(errorString, styleSheetId);
 757     if (!inspectorStyleSheet)
 758         return;
 759 
 760     auto* domAgent = m_instrumentingAgents.inspectorDOMAgent();
 761     if (!domAgent) {
 762         errorString = &quot;DOM domain must be enabled&quot;_s;
 763         return;
 764     }
 765 
 766     auto action = makeUnique&lt;AddRuleAction&gt;(inspectorStyleSheet, selector);
 767     auto&amp; rawAction = *action;
 768     auto performResult = domAgent-&gt;history()-&gt;perform(WTFMove(action));
 769     if (performResult.hasException()) {
 770         errorString = InspectorDOMAgent::toErrorString(performResult.releaseException());
 771         return;
 772     }
 773 
 774     InspectorCSSId ruleId = rawAction.newRuleId();
 775     CSSStyleRule* rule = inspectorStyleSheet-&gt;ruleForId(ruleId);
 776     result = inspectorStyleSheet-&gt;buildObjectForRule(rule, nullptr);
 777 }
 778 
 779 void InspectorCSSAgent::getSupportedCSSProperties(ErrorString&amp;, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSPropertyInfo&gt;&gt;&amp; cssProperties)
 780 {
 781     auto properties = JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSPropertyInfo&gt;::create();
 782     for (int i = firstCSSProperty; i &lt;= lastCSSProperty; ++i) {
 783         CSSPropertyID propertyID = convertToCSSPropertyID(i);
 784         if (isInternalCSSProperty(propertyID) || !isEnabledCSSProperty(propertyID))
 785             continue;
 786 
 787         auto property = Inspector::Protocol::CSS::CSSPropertyInfo::create()
 788             .setName(getPropertyNameString(propertyID))
 789             .release();
 790 
 791         auto aliases = CSSProperty::aliasesForProperty(propertyID);
 792         if (!aliases.isEmpty()) {
 793             auto aliasesArray = JSON::ArrayOf&lt;String&gt;::create();
 794             for (auto&amp; alias : aliases)
 795                 aliasesArray-&gt;addItem(alias);
 796             property-&gt;setAliases(WTFMove(aliasesArray));
 797         }
 798 
 799         const StylePropertyShorthand&amp; shorthand = shorthandForProperty(propertyID);
 800         if (shorthand.length()) {
 801             auto longhands = JSON::ArrayOf&lt;String&gt;::create();
 802             for (unsigned j = 0; j &lt; shorthand.length(); ++j) {
 803                 CSSPropertyID longhandID = shorthand.properties()[j];
 804                 if (isEnabledCSSProperty(longhandID))
 805                     longhands-&gt;addItem(getPropertyNameString(longhandID));
 806             }
 807             property-&gt;setLonghands(WTFMove(longhands));
 808         }
 809 
 810         if (CSSParserFastPaths::isKeywordPropertyID(propertyID)) {
 811             auto values = JSON::ArrayOf&lt;String&gt;::create();
 812             for (int j = firstCSSValueKeyword; j &lt;= lastCSSValueKeyword; ++j) {
 813                 CSSValueID valueID = convertToCSSValueID(j);
 814                 if (CSSParserFastPaths::isValidKeywordPropertyAndValue(propertyID, valueID, strictCSSParserContext()))
 815                     values-&gt;addItem(getValueNameString(valueID));
 816             }
 817             if (values-&gt;length())
 818                 property-&gt;setValues(WTFMove(values));
 819         }
 820 
 821         if (CSSProperty::isInheritedProperty(propertyID))
 822             property-&gt;setInherited(true);
 823 
 824         properties-&gt;addItem(WTFMove(property));
 825     }
 826     cssProperties = WTFMove(properties);
 827 }
 828 
 829 void InspectorCSSAgent::getSupportedSystemFontFamilyNames(ErrorString&amp;, RefPtr&lt;JSON::ArrayOf&lt;String&gt;&gt;&amp; fontFamilyNames)
 830 {
 831     auto families = JSON::ArrayOf&lt;String&gt;::create();
 832 
 833     Vector&lt;String&gt; systemFontFamilies = FontCache::singleton().systemFontFamilies();
 834     for (const auto&amp; familyName : systemFontFamilies)
 835         families-&gt;addItem(familyName);
 836 
 837     fontFamilyNames = WTFMove(families);
 838 }
 839 
 840 void InspectorCSSAgent::forcePseudoState(ErrorString&amp; errorString, int nodeId, const JSON::Array&amp; forcedPseudoClasses)
 841 {
 842     auto* domAgent = m_instrumentingAgents.inspectorDOMAgent();
 843     if (!domAgent) {
 844         errorString = &quot;DOM domain must be enabled&quot;_s;
 845         return;
 846     }
 847 
 848     Element* element = domAgent-&gt;assertElement(errorString, nodeId);
 849     if (!element)
 850         return;
 851 
 852     // Return early if the forced pseudo state was already set correctly.
 853     unsigned forcedPseudoState = computePseudoClassMask(forcedPseudoClasses);
 854     if (forcedPseudoState) {
 855         auto iterator = m_nodeIdToForcedPseudoState.add(nodeId, 0).iterator;
 856         if (forcedPseudoState == iterator-&gt;value)
 857             return;
 858         iterator-&gt;value = forcedPseudoState;
 859         m_documentsWithForcedPseudoStates.add(&amp;element-&gt;document());
 860     } else {
 861         if (!m_nodeIdToForcedPseudoState.remove(nodeId))
 862             return;
 863         if (m_nodeIdToForcedPseudoState.isEmpty())
 864             m_documentsWithForcedPseudoStates.clear();
 865     }
 866 
 867     element-&gt;document().styleScope().didChangeStyleSheetEnvironment();
 868 }
 869 
 870 InspectorStyleSheetForInlineStyle&amp; InspectorCSSAgent::asInspectorStyleSheet(StyledElement&amp; element)
 871 {
 872     return m_nodeToInspectorStyleSheet.ensure(&amp;element, [this, &amp;element] {
 873         String newStyleSheetId = String::number(m_lastStyleSheetId++);
 874         auto inspectorStyleSheet = InspectorStyleSheetForInlineStyle::create(m_instrumentingAgents.inspectorPageAgent(), newStyleSheetId, element, Inspector::Protocol::CSS::StyleSheetOrigin::Regular, this);
 875         m_idToInspectorStyleSheet.set(newStyleSheetId, inspectorStyleSheet.copyRef());
 876         return inspectorStyleSheet;
 877     }).iterator-&gt;value;
 878 }
 879 
 880 Element* InspectorCSSAgent::elementForId(ErrorString&amp; errorString, int nodeId)
 881 {
 882     auto* domAgent = m_instrumentingAgents.inspectorDOMAgent();
 883     if (!domAgent) {
 884         errorString = &quot;DOM domain must be enabled&quot;_s;
 885         return nullptr;
 886     }
 887 
 888     return domAgent-&gt;assertElement(errorString, nodeId);
 889 }
 890 
 891 String InspectorCSSAgent::unbindStyleSheet(InspectorStyleSheet* inspectorStyleSheet)
 892 {
 893     String id = inspectorStyleSheet-&gt;id();
 894     m_idToInspectorStyleSheet.remove(id);
 895     if (inspectorStyleSheet-&gt;pageStyleSheet())
 896         m_cssStyleSheetToInspectorStyleSheet.remove(inspectorStyleSheet-&gt;pageStyleSheet());
 897     return id;
 898 }
 899 
 900 InspectorStyleSheet* InspectorCSSAgent::bindStyleSheet(CSSStyleSheet* styleSheet)
 901 {
 902     RefPtr&lt;InspectorStyleSheet&gt; inspectorStyleSheet = m_cssStyleSheetToInspectorStyleSheet.get(styleSheet);
 903     if (!inspectorStyleSheet) {
 904         String id = String::number(m_lastStyleSheetId++);
 905         Document* document = styleSheet-&gt;ownerDocument();
 906         inspectorStyleSheet = InspectorStyleSheet::create(m_instrumentingAgents.inspectorPageAgent(), id, styleSheet, detectOrigin(styleSheet, document), InspectorDOMAgent::documentURLString(document), this);
 907         m_idToInspectorStyleSheet.set(id, inspectorStyleSheet);
 908         m_cssStyleSheetToInspectorStyleSheet.set(styleSheet, inspectorStyleSheet);
 909         if (m_creatingViaInspectorStyleSheet) {
 910             auto&amp; inspectorStyleSheetsForDocument = m_documentToInspectorStyleSheet.add(document, Vector&lt;RefPtr&lt;InspectorStyleSheet&gt;&gt;()).iterator-&gt;value;
 911             inspectorStyleSheetsForDocument.append(inspectorStyleSheet);
 912         }
 913     }
 914     return inspectorStyleSheet.get();
 915 }
 916 
 917 InspectorStyleSheet* InspectorCSSAgent::assertStyleSheetForId(ErrorString&amp; errorString, const String&amp; styleSheetId)
 918 {
 919     IdToInspectorStyleSheet::iterator it = m_idToInspectorStyleSheet.find(styleSheetId);
 920     if (it == m_idToInspectorStyleSheet.end()) {
 921         errorString = &quot;Missing style sheet for given styleSheetId&quot;_s;
 922         return nullptr;
 923     }
 924     return it-&gt;value.get();
 925 }
 926 
 927 Inspector::Protocol::CSS::StyleSheetOrigin InspectorCSSAgent::detectOrigin(CSSStyleSheet* pageStyleSheet, Document* ownerDocument)
 928 {
 929     if (m_creatingViaInspectorStyleSheet)
 930         return Inspector::Protocol::CSS::StyleSheetOrigin::Inspector;
 931 
 932     if (pageStyleSheet &amp;&amp; !pageStyleSheet-&gt;ownerNode() &amp;&amp; pageStyleSheet-&gt;href().isEmpty())
 933         return Inspector::Protocol::CSS::StyleSheetOrigin::UserAgent;
 934 
 935     if (pageStyleSheet &amp;&amp; pageStyleSheet-&gt;ownerNode() &amp;&amp; pageStyleSheet-&gt;ownerNode()-&gt;nodeName() == &quot;#document&quot;)
 936         return Inspector::Protocol::CSS::StyleSheetOrigin::User;
 937 
 938     auto iterator = m_documentToInspectorStyleSheet.find(ownerDocument);
 939     if (iterator != m_documentToInspectorStyleSheet.end()) {
 940         for (auto&amp; inspectorStyleSheet : iterator-&gt;value) {
 941             if (pageStyleSheet == inspectorStyleSheet-&gt;pageStyleSheet())
 942                 return Inspector::Protocol::CSS::StyleSheetOrigin::Inspector;
 943         }
 944     }
 945 
 946     return Inspector::Protocol::CSS::StyleSheetOrigin::Regular;
 947 }
 948 
<a name="5" id="anc5"></a><span class="line-modified"> 949 RefPtr&lt;Inspector::Protocol::CSS::CSSRule&gt; InspectorCSSAgent::buildObjectForRule(const StyleRule* styleRule, Style::Resolver&amp; styleResolver, Element&amp; element)</span>
 950 {
 951     if (!styleRule)
 952         return nullptr;
 953 
<a name="6" id="anc6"></a><span class="line-modified"> 954     // StyleRules returned by Style::Resolver::styleRulesForElement lack parent pointers since that infomation is not cheaply available.</span>
 955     // Since the inspector wants to walk the parent chain, we construct the full wrappers here.
 956     styleResolver.inspectorCSSOMWrappers().collectDocumentWrappers(styleResolver.document().extensionStyleSheets());
 957     styleResolver.inspectorCSSOMWrappers().collectScopeWrappers(Style::Scope::forNode(element));
 958 
 959     // Possiblity of :host styles if this element has a shadow root.
 960     if (ShadowRoot* shadowRoot = element.shadowRoot())
 961         styleResolver.inspectorCSSOMWrappers().collectScopeWrappers(shadowRoot-&gt;styleScope());
 962 
 963     CSSStyleRule* cssomWrapper = styleResolver.inspectorCSSOMWrappers().getWrapperForRuleInSheets(styleRule);
 964     if (!cssomWrapper)
 965         return nullptr;
 966 
 967     InspectorStyleSheet* inspectorStyleSheet = bindStyleSheet(cssomWrapper-&gt;parentStyleSheet());
 968     return inspectorStyleSheet ? inspectorStyleSheet-&gt;buildObjectForRule(cssomWrapper, &amp;element) : nullptr;
 969 }
 970 
 971 RefPtr&lt;Inspector::Protocol::CSS::CSSRule&gt; InspectorCSSAgent::buildObjectForRule(CSSStyleRule* rule)
 972 {
 973     if (!rule)
 974         return nullptr;
 975 
 976     ASSERT(rule-&gt;parentStyleSheet());
 977     InspectorStyleSheet* inspectorStyleSheet = bindStyleSheet(rule-&gt;parentStyleSheet());
 978     return inspectorStyleSheet ? inspectorStyleSheet-&gt;buildObjectForRule(rule, nullptr) : nullptr;
 979 }
 980 
<a name="7" id="anc7"></a><span class="line-modified"> 981 RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::CSS::RuleMatch&gt;&gt; InspectorCSSAgent::buildArrayForMatchedRuleList(const Vector&lt;RefPtr&lt;const StyleRule&gt;&gt;&amp; matchedRules, Style::Resolver&amp; styleResolver, Element&amp; element, PseudoId pseudoId)</span>
 982 {
 983     auto result = JSON::ArrayOf&lt;Inspector::Protocol::CSS::RuleMatch&gt;::create();
 984 
 985     SelectorChecker::CheckingContext context(SelectorChecker::Mode::CollectingRules);
 986     context.pseudoId = pseudoId != PseudoId::None ? pseudoId : element.pseudoId();
 987     SelectorChecker selectorChecker(element.document());
 988 
 989     for (auto&amp; matchedRule : matchedRules) {
 990         RefPtr&lt;Inspector::Protocol::CSS::CSSRule&gt; ruleObject = buildObjectForRule(matchedRule.get(), styleResolver, element);
 991         if (!ruleObject)
 992             continue;
 993 
 994         auto matchingSelectors = JSON::ArrayOf&lt;int&gt;::create();
 995         const CSSSelectorList&amp; selectorList = matchedRule-&gt;selectorList();
 996         int index = 0;
 997         for (const CSSSelector* selector = selectorList.first(); selector; selector = CSSSelectorList::next(selector)) {
 998             unsigned ignoredSpecificity;
 999             bool matched = selectorChecker.match(*selector, element, context, ignoredSpecificity);
1000             if (matched)
1001                 matchingSelectors-&gt;addItem(index);
1002             ++index;
1003         }
1004 
1005         auto match = Inspector::Protocol::CSS::RuleMatch::create()
1006             .setRule(WTFMove(ruleObject))
1007             .setMatchingSelectors(WTFMove(matchingSelectors))
1008             .release();
1009         result-&gt;addItem(WTFMove(match));
1010     }
1011 
1012     return result;
1013 }
1014 
1015 RefPtr&lt;Inspector::Protocol::CSS::CSSStyle&gt; InspectorCSSAgent::buildObjectForAttributesStyle(StyledElement&amp; element)
1016 {
1017     // FIXME: Ugliness below.
1018     auto* attributeStyle = const_cast&lt;StyleProperties*&gt;(element.presentationAttributeStyle());
1019     if (!attributeStyle)
1020         return nullptr;
1021 
1022     auto&amp; mutableAttributeStyle = downcast&lt;MutableStyleProperties&gt;(*attributeStyle);
1023     auto inspectorStyle = InspectorStyle::create(InspectorCSSId(), mutableAttributeStyle.ensureCSSStyleDeclaration(), nullptr);
1024     return inspectorStyle-&gt;buildObjectForStyle();
1025 }
1026 
1027 void InspectorCSSAgent::didRemoveDOMNode(Node&amp; node, int nodeId)
1028 {
1029     m_nodeIdToForcedPseudoState.remove(nodeId);
1030 
1031     auto sheet = m_nodeToInspectorStyleSheet.take(&amp;node);
1032     if (!sheet)
1033         return;
1034     m_idToInspectorStyleSheet.remove(sheet.value()-&gt;id());
1035 }
1036 
1037 void InspectorCSSAgent::didModifyDOMAttr(Element&amp; element)
1038 {
1039     auto sheet = m_nodeToInspectorStyleSheet.get(&amp;element);
1040     if (!sheet)
1041         return;
1042     sheet-&gt;didModifyElementAttribute();
1043 }
1044 
1045 void InspectorCSSAgent::styleSheetChanged(InspectorStyleSheet* styleSheet)
1046 {
1047     m_frontendDispatcher-&gt;styleSheetChanged(styleSheet-&gt;id());
1048 }
1049 
1050 void InspectorCSSAgent::resetPseudoStates()
1051 {
1052     for (auto&amp; document : m_documentsWithForcedPseudoStates)
1053         document-&gt;styleScope().didChangeStyleSheetEnvironment();
1054 
1055     m_nodeIdToForcedPseudoState.clear();
1056     m_documentsWithForcedPseudoStates.clear();
1057 }
1058 
1059 } // namespace WebCore
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
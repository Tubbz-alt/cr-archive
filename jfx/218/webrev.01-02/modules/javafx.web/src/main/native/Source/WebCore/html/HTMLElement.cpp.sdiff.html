<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLDocument.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;HTMLElement.h&quot;
  27 
  28 #include &quot;CSSMarkup.h&quot;
  29 #include &quot;CSSPropertyNames.h&quot;
  30 #include &quot;CSSValueKeywords.h&quot;
  31 #include &quot;CSSValuePool.h&quot;
  32 #include &quot;Chrome.h&quot;
  33 #include &quot;ChromeClient.h&quot;
  34 #include &quot;DOMTokenList.h&quot;
  35 #include &quot;DocumentFragment.h&quot;
  36 #include &quot;ElementAncestorIterator.h&quot;

  37 #include &quot;Event.h&quot;
  38 #include &quot;EventListener.h&quot;
  39 #include &quot;EventNames.h&quot;
  40 #include &quot;Frame.h&quot;
  41 #include &quot;FrameLoader.h&quot;
  42 #include &quot;FrameView.h&quot;
  43 #include &quot;HTMLBDIElement.h&quot;
  44 #include &quot;HTMLBRElement.h&quot;
  45 #include &quot;HTMLButtonElement.h&quot;
  46 #include &quot;HTMLCollection.h&quot;
  47 #include &quot;HTMLDocument.h&quot;
  48 #include &quot;HTMLElementFactory.h&quot;
  49 #include &quot;HTMLFieldSetElement.h&quot;
  50 #include &quot;HTMLFormElement.h&quot;
  51 #include &quot;HTMLInputElement.h&quot;
  52 #include &quot;HTMLNames.h&quot;
  53 #include &quot;HTMLOptGroupElement.h&quot;
  54 #include &quot;HTMLOptionElement.h&quot;
  55 #include &quot;HTMLParserIdioms.h&quot;
  56 #include &quot;HTMLSelectElement.h&quot;
</pre>
<hr />
<pre>
  96 
  97 static inline CSSValueID unicodeBidiAttributeForDirAuto(HTMLElement&amp; element)
  98 {
  99     if (element.hasTagName(preTag) || element.hasTagName(textareaTag))
 100         return CSSValuePlaintext;
 101     // FIXME: For bdo element, dir=&quot;auto&quot; should result in &quot;bidi-override isolate&quot; but we don&#39;t support having multiple values in unicode-bidi yet.
 102     // See https://bugs.webkit.org/show_bug.cgi?id=73164.
 103     return CSSValueIsolate;
 104 }
 105 
 106 unsigned HTMLElement::parseBorderWidthAttribute(const AtomString&amp; value) const
 107 {
 108     if (auto optionalBorderWidth = parseHTMLNonNegativeInteger(value))
 109         return optionalBorderWidth.value();
 110 
 111     return hasTagName(tableTag) ? 1 : 0;
 112 }
 113 
 114 void HTMLElement::applyBorderAttributeToStyle(const AtomString&amp; value, MutableStyleProperties&amp; style)
 115 {
<span class="line-modified"> 116     addPropertyToPresentationAttributeStyle(style, CSSPropertyBorderWidth, parseBorderWidthAttribute(value), CSSPrimitiveValue::CSS_PX);</span>
 117     addPropertyToPresentationAttributeStyle(style, CSSPropertyBorderStyle, CSSValueSolid);
 118 }
 119 
 120 void HTMLElement::mapLanguageAttributeToLocale(const AtomString&amp; value, MutableStyleProperties&amp; style)
 121 {
 122     if (!value.isEmpty()) {
 123         // Have to quote so the locale id is treated as a string instead of as a CSS keyword.
 124         addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitLocale, serializeString(value));
 125     } else {
 126         // The empty string means the language is explicitly unknown.
 127         addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitLocale, CSSValueAuto);
 128     }
 129 }
 130 
 131 bool HTMLElement::isPresentationAttribute(const QualifiedName&amp; name) const
 132 {
 133     if (name == alignAttr || name == contenteditableAttr || name == hiddenAttr || name == langAttr || name.matches(XMLNames::langAttr) || name == draggableAttr || name == dirAttr)
 134         return true;
 135     return StyledElement::isPresentationAttribute(name);
 136 }
</pre>
<hr />
<pre>
 715 }
 716 
 717 bool HTMLElement::translate() const
 718 {
 719     for (auto&amp; element : lineageOfType&lt;HTMLElement&gt;(*this)) {
 720         const AtomString&amp; value = element.attributeWithoutSynchronization(translateAttr);
 721         if (equalLettersIgnoringASCIICase(value, &quot;yes&quot;) || (value.isEmpty() &amp;&amp; !value.isNull()))
 722             return true;
 723         if (equalLettersIgnoringASCIICase(value, &quot;no&quot;))
 724             return false;
 725     }
 726     // Default on the root element is translate=yes.
 727     return true;
 728 }
 729 
 730 void HTMLElement::setTranslate(bool enable)
 731 {
 732     setAttributeWithoutSynchronization(translateAttr, enable ? &quot;yes&quot; : &quot;no&quot;);
 733 }
 734 
<span class="line-modified"> 735 bool HTMLElement::rendererIsNeeded(const RenderStyle&amp; style)</span>
 736 {
 737     if (hasTagName(noscriptTag)) {
 738         RefPtr&lt;Frame&gt; frame = document().frame();
 739         if (frame &amp;&amp; frame-&gt;script().canExecuteScripts(NotAboutToExecuteScript))
 740             return false;
 741     } else if (hasTagName(noembedTag)) {
 742         RefPtr&lt;Frame&gt; frame = document().frame();
 743         if (frame &amp;&amp; frame-&gt;loader().subframeLoader().allowPlugins())
 744             return false;
 745     }
<span class="line-modified"> 746     return StyledElement::rendererIsNeeded(style);</span>
 747 }
 748 
 749 RenderPtr&lt;RenderElement&gt; HTMLElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 750 {
 751     return RenderElement::createFor(*this, WTFMove(style));
 752 }
 753 
 754 HTMLFormElement* HTMLElement::form() const
 755 {
 756     return HTMLFormElement::findClosestFormAncestor(*this);
 757 }
 758 
 759 FormNamedItem* HTMLElement::asFormNamedItem()
 760 {
 761     return nullptr;
 762 }
 763 
 764 FormAssociatedElement* HTMLElement::asFormAssociatedElement()
 765 {
 766     return nullptr;
</pre>
<hr />
<pre>
1051 {
1052     return !isDisabledFormControl() &amp;&amp; Element::willRespondToMouseClickEvents();
1053 }
1054 
1055 bool HTMLElement::canBeActuallyDisabled() const
1056 {
1057     return is&lt;HTMLButtonElement&gt;(*this)
1058         || is&lt;HTMLInputElement&gt;(*this)
1059         || is&lt;HTMLSelectElement&gt;(*this)
1060         || is&lt;HTMLTextAreaElement&gt;(*this)
1061         || is&lt;HTMLOptGroupElement&gt;(*this)
1062         || is&lt;HTMLOptionElement&gt;(*this)
1063         || is&lt;HTMLFieldSetElement&gt;(*this);
1064 }
1065 
1066 bool HTMLElement::isActuallyDisabled() const
1067 {
1068     return canBeActuallyDisabled() &amp;&amp; isDisabledFormControl();
1069 }
1070 
<span class="line-modified">1071 #if ENABLE(IOS_AUTOCORRECT_AND_AUTOCAPITALIZE)</span>
1072 
1073 const AtomString&amp; HTMLElement::autocapitalize() const
1074 {
1075     return stringForAutocapitalizeType(autocapitalizeType());
1076 }
1077 
1078 AutocapitalizeType HTMLElement::autocapitalizeType() const
1079 {
1080     return autocapitalizeTypeForAttributeValue(attributeWithoutSynchronization(HTMLNames::autocapitalizeAttr));
1081 }
1082 
1083 void HTMLElement::setAutocapitalize(const AtomString&amp; value)
1084 {
1085     setAttributeWithoutSynchronization(autocapitalizeAttr, value);
1086 }
1087 




1088 bool HTMLElement::shouldAutocorrect() const
1089 {
1090     auto&amp; autocorrectValue = attributeWithoutSynchronization(HTMLNames::autocorrectAttr);
1091     // Unrecognized values fall back to &quot;on&quot;.
1092     return !equalLettersIgnoringASCIICase(autocorrectValue, &quot;off&quot;);
1093 }
1094 
1095 void HTMLElement::setAutocorrect(bool autocorrect)
1096 {
1097     setAttributeWithoutSynchronization(autocorrectAttr, autocorrect ? AtomString(&quot;on&quot;, AtomString::ConstructFromLiteral) : AtomString(&quot;off&quot;, AtomString::ConstructFromLiteral));
1098 }
1099 
1100 #endif
1101 
1102 InputMode HTMLElement::canonicalInputMode() const
1103 {
1104     auto mode = inputModeForAttributeValue(attributeWithoutSynchronization(inputmodeAttr));
1105     if (mode == InputMode::Unspecified) {
1106         if (document().quirks().needsInputModeNoneImplicitly(*this))
1107             return InputMode::None;
1108     }
1109     return mode;
1110 }
1111 
1112 const AtomString&amp; HTMLElement::inputMode() const
1113 {
1114     return stringForInputMode(canonicalInputMode());
1115 }
1116 
1117 void HTMLElement::setInputMode(const AtomString&amp; value)
1118 {
1119     setAttributeWithoutSynchronization(inputmodeAttr, value);
1120 }
1121 















1122 } // namespace WebCore
1123 
1124 #ifndef NDEBUG
1125 
1126 // For use in the debugger
1127 void dumpInnerHTML(WebCore::HTMLElement*);
1128 
1129 void dumpInnerHTML(WebCore::HTMLElement* element)
1130 {
1131     printf(&quot;%s\n&quot;, element-&gt;innerHTML().ascii().data());
1132 }
1133 
1134 #endif
</pre>
</td>
<td>
<hr />
<pre>
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;HTMLElement.h&quot;
  27 
  28 #include &quot;CSSMarkup.h&quot;
  29 #include &quot;CSSPropertyNames.h&quot;
  30 #include &quot;CSSValueKeywords.h&quot;
  31 #include &quot;CSSValuePool.h&quot;
  32 #include &quot;Chrome.h&quot;
  33 #include &quot;ChromeClient.h&quot;
  34 #include &quot;DOMTokenList.h&quot;
  35 #include &quot;DocumentFragment.h&quot;
  36 #include &quot;ElementAncestorIterator.h&quot;
<span class="line-added">  37 #include &quot;EnterKeyHint.h&quot;</span>
  38 #include &quot;Event.h&quot;
  39 #include &quot;EventListener.h&quot;
  40 #include &quot;EventNames.h&quot;
  41 #include &quot;Frame.h&quot;
  42 #include &quot;FrameLoader.h&quot;
  43 #include &quot;FrameView.h&quot;
  44 #include &quot;HTMLBDIElement.h&quot;
  45 #include &quot;HTMLBRElement.h&quot;
  46 #include &quot;HTMLButtonElement.h&quot;
  47 #include &quot;HTMLCollection.h&quot;
  48 #include &quot;HTMLDocument.h&quot;
  49 #include &quot;HTMLElementFactory.h&quot;
  50 #include &quot;HTMLFieldSetElement.h&quot;
  51 #include &quot;HTMLFormElement.h&quot;
  52 #include &quot;HTMLInputElement.h&quot;
  53 #include &quot;HTMLNames.h&quot;
  54 #include &quot;HTMLOptGroupElement.h&quot;
  55 #include &quot;HTMLOptionElement.h&quot;
  56 #include &quot;HTMLParserIdioms.h&quot;
  57 #include &quot;HTMLSelectElement.h&quot;
</pre>
<hr />
<pre>
  97 
  98 static inline CSSValueID unicodeBidiAttributeForDirAuto(HTMLElement&amp; element)
  99 {
 100     if (element.hasTagName(preTag) || element.hasTagName(textareaTag))
 101         return CSSValuePlaintext;
 102     // FIXME: For bdo element, dir=&quot;auto&quot; should result in &quot;bidi-override isolate&quot; but we don&#39;t support having multiple values in unicode-bidi yet.
 103     // See https://bugs.webkit.org/show_bug.cgi?id=73164.
 104     return CSSValueIsolate;
 105 }
 106 
 107 unsigned HTMLElement::parseBorderWidthAttribute(const AtomString&amp; value) const
 108 {
 109     if (auto optionalBorderWidth = parseHTMLNonNegativeInteger(value))
 110         return optionalBorderWidth.value();
 111 
 112     return hasTagName(tableTag) ? 1 : 0;
 113 }
 114 
 115 void HTMLElement::applyBorderAttributeToStyle(const AtomString&amp; value, MutableStyleProperties&amp; style)
 116 {
<span class="line-modified"> 117     addPropertyToPresentationAttributeStyle(style, CSSPropertyBorderWidth, parseBorderWidthAttribute(value), CSSUnitType::CSS_PX);</span>
 118     addPropertyToPresentationAttributeStyle(style, CSSPropertyBorderStyle, CSSValueSolid);
 119 }
 120 
 121 void HTMLElement::mapLanguageAttributeToLocale(const AtomString&amp; value, MutableStyleProperties&amp; style)
 122 {
 123     if (!value.isEmpty()) {
 124         // Have to quote so the locale id is treated as a string instead of as a CSS keyword.
 125         addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitLocale, serializeString(value));
 126     } else {
 127         // The empty string means the language is explicitly unknown.
 128         addPropertyToPresentationAttributeStyle(style, CSSPropertyWebkitLocale, CSSValueAuto);
 129     }
 130 }
 131 
 132 bool HTMLElement::isPresentationAttribute(const QualifiedName&amp; name) const
 133 {
 134     if (name == alignAttr || name == contenteditableAttr || name == hiddenAttr || name == langAttr || name.matches(XMLNames::langAttr) || name == draggableAttr || name == dirAttr)
 135         return true;
 136     return StyledElement::isPresentationAttribute(name);
 137 }
</pre>
<hr />
<pre>
 716 }
 717 
 718 bool HTMLElement::translate() const
 719 {
 720     for (auto&amp; element : lineageOfType&lt;HTMLElement&gt;(*this)) {
 721         const AtomString&amp; value = element.attributeWithoutSynchronization(translateAttr);
 722         if (equalLettersIgnoringASCIICase(value, &quot;yes&quot;) || (value.isEmpty() &amp;&amp; !value.isNull()))
 723             return true;
 724         if (equalLettersIgnoringASCIICase(value, &quot;no&quot;))
 725             return false;
 726     }
 727     // Default on the root element is translate=yes.
 728     return true;
 729 }
 730 
 731 void HTMLElement::setTranslate(bool enable)
 732 {
 733     setAttributeWithoutSynchronization(translateAttr, enable ? &quot;yes&quot; : &quot;no&quot;);
 734 }
 735 
<span class="line-modified"> 736 bool HTMLElement::rendererIsEverNeeded()</span>
 737 {
 738     if (hasTagName(noscriptTag)) {
 739         RefPtr&lt;Frame&gt; frame = document().frame();
 740         if (frame &amp;&amp; frame-&gt;script().canExecuteScripts(NotAboutToExecuteScript))
 741             return false;
 742     } else if (hasTagName(noembedTag)) {
 743         RefPtr&lt;Frame&gt; frame = document().frame();
 744         if (frame &amp;&amp; frame-&gt;loader().subframeLoader().allowPlugins())
 745             return false;
 746     }
<span class="line-modified"> 747     return StyledElement::rendererIsEverNeeded();</span>
 748 }
 749 
 750 RenderPtr&lt;RenderElement&gt; HTMLElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 751 {
 752     return RenderElement::createFor(*this, WTFMove(style));
 753 }
 754 
 755 HTMLFormElement* HTMLElement::form() const
 756 {
 757     return HTMLFormElement::findClosestFormAncestor(*this);
 758 }
 759 
 760 FormNamedItem* HTMLElement::asFormNamedItem()
 761 {
 762     return nullptr;
 763 }
 764 
 765 FormAssociatedElement* HTMLElement::asFormAssociatedElement()
 766 {
 767     return nullptr;
</pre>
<hr />
<pre>
1052 {
1053     return !isDisabledFormControl() &amp;&amp; Element::willRespondToMouseClickEvents();
1054 }
1055 
1056 bool HTMLElement::canBeActuallyDisabled() const
1057 {
1058     return is&lt;HTMLButtonElement&gt;(*this)
1059         || is&lt;HTMLInputElement&gt;(*this)
1060         || is&lt;HTMLSelectElement&gt;(*this)
1061         || is&lt;HTMLTextAreaElement&gt;(*this)
1062         || is&lt;HTMLOptGroupElement&gt;(*this)
1063         || is&lt;HTMLOptionElement&gt;(*this)
1064         || is&lt;HTMLFieldSetElement&gt;(*this);
1065 }
1066 
1067 bool HTMLElement::isActuallyDisabled() const
1068 {
1069     return canBeActuallyDisabled() &amp;&amp; isDisabledFormControl();
1070 }
1071 
<span class="line-modified">1072 #if ENABLE(AUTOCAPITALIZE)</span>
1073 
1074 const AtomString&amp; HTMLElement::autocapitalize() const
1075 {
1076     return stringForAutocapitalizeType(autocapitalizeType());
1077 }
1078 
1079 AutocapitalizeType HTMLElement::autocapitalizeType() const
1080 {
1081     return autocapitalizeTypeForAttributeValue(attributeWithoutSynchronization(HTMLNames::autocapitalizeAttr));
1082 }
1083 
1084 void HTMLElement::setAutocapitalize(const AtomString&amp; value)
1085 {
1086     setAttributeWithoutSynchronization(autocapitalizeAttr, value);
1087 }
1088 
<span class="line-added">1089 #endif</span>
<span class="line-added">1090 </span>
<span class="line-added">1091 #if ENABLE(AUTOCORRECT)</span>
<span class="line-added">1092 </span>
1093 bool HTMLElement::shouldAutocorrect() const
1094 {
1095     auto&amp; autocorrectValue = attributeWithoutSynchronization(HTMLNames::autocorrectAttr);
1096     // Unrecognized values fall back to &quot;on&quot;.
1097     return !equalLettersIgnoringASCIICase(autocorrectValue, &quot;off&quot;);
1098 }
1099 
1100 void HTMLElement::setAutocorrect(bool autocorrect)
1101 {
1102     setAttributeWithoutSynchronization(autocorrectAttr, autocorrect ? AtomString(&quot;on&quot;, AtomString::ConstructFromLiteral) : AtomString(&quot;off&quot;, AtomString::ConstructFromLiteral));
1103 }
1104 
1105 #endif
1106 
1107 InputMode HTMLElement::canonicalInputMode() const
1108 {
1109     auto mode = inputModeForAttributeValue(attributeWithoutSynchronization(inputmodeAttr));
1110     if (mode == InputMode::Unspecified) {
1111         if (document().quirks().needsInputModeNoneImplicitly(*this))
1112             return InputMode::None;
1113     }
1114     return mode;
1115 }
1116 
1117 const AtomString&amp; HTMLElement::inputMode() const
1118 {
1119     return stringForInputMode(canonicalInputMode());
1120 }
1121 
1122 void HTMLElement::setInputMode(const AtomString&amp; value)
1123 {
1124     setAttributeWithoutSynchronization(inputmodeAttr, value);
1125 }
1126 
<span class="line-added">1127 EnterKeyHint HTMLElement::canonicalEnterKeyHint() const</span>
<span class="line-added">1128 {</span>
<span class="line-added">1129     return enterKeyHintForAttributeValue(attributeWithoutSynchronization(enterkeyhintAttr));</span>
<span class="line-added">1130 }</span>
<span class="line-added">1131 </span>
<span class="line-added">1132 String HTMLElement::enterKeyHint() const</span>
<span class="line-added">1133 {</span>
<span class="line-added">1134     return attributeValueForEnterKeyHint(canonicalEnterKeyHint());</span>
<span class="line-added">1135 }</span>
<span class="line-added">1136 </span>
<span class="line-added">1137 void HTMLElement::setEnterKeyHint(const String&amp; value)</span>
<span class="line-added">1138 {</span>
<span class="line-added">1139     setAttributeWithoutSynchronization(enterkeyhintAttr, value);</span>
<span class="line-added">1140 }</span>
<span class="line-added">1141 </span>
1142 } // namespace WebCore
1143 
1144 #ifndef NDEBUG
1145 
1146 // For use in the debugger
1147 void dumpInnerHTML(WebCore::HTMLElement*);
1148 
1149 void dumpInnerHTML(WebCore::HTMLElement* element)
1150 {
1151     printf(&quot;%s\n&quot;, element-&gt;innerHTML().ascii().data());
1152 }
1153 
1154 #endif
</pre>
</td>
</tr>
</table>
<center><a href="HTMLDocument.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSSelectorParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 // Copyright 2014 The Chromium Authors. All rights reserved.
  2 // Copyright (C) 2016 Apple Inc. All rights reserved.
  3 //
  4 // Redistribution and use in source and binary forms, with or without
  5 // modification, are permitted provided that the following conditions are
  6 // met:
  7 //
  8 //    * Redistributions of source code must retain the above copyright
  9 // notice, this list of conditions and the following disclaimer.
 10 //    * Redistributions in binary form must reproduce the above
 11 // copyright notice, this list of conditions and the following disclaimer
 12 // in the documentation and/or other materials provided with the
 13 // distribution.
 14 //    * Neither the name of Google Inc. nor the names of its
 15 // contributors may be used to endorse or promote products derived from
 16 // this software without specific prior written permission.
 17 //
 18 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;CSSSelectorParser.h&quot;
 32 
 33 #include &quot;CSSParserContext.h&quot;
 34 #include &quot;CSSSelectorList.h&quot;
 35 #include &quot;StyleSheetContents.h&quot;
 36 #include &lt;memory&gt;
 37 
 38 namespace WebCore {
 39 
 40 CSSSelectorList CSSSelectorParser::parseSelector(CSSParserTokenRange range, const CSSParserContext&amp; context, StyleSheetContents* styleSheet)
 41 {
 42     CSSSelectorParser parser(context, styleSheet);
 43     range.consumeWhitespace();
 44     CSSSelectorList result = parser.consumeComplexSelectorList(range);
 45     if (!range.atEnd())
 46         return CSSSelectorList();
 47     return result;
 48 }
 49 
 50 CSSSelectorParser::CSSSelectorParser(const CSSParserContext&amp; context, StyleSheetContents* styleSheet)
 51     : m_context(context)
 52     , m_styleSheet(styleSheet)
 53 {
 54 }
 55 
 56 CSSSelectorList CSSSelectorParser::consumeComplexSelectorList(CSSParserTokenRange&amp; range)
 57 {
 58     Vector&lt;std::unique_ptr&lt;CSSParserSelector&gt;&gt; selectorList;
 59     std::unique_ptr&lt;CSSParserSelector&gt; selector = consumeComplexSelector(range);
 60     if (!selector)
 61         return CSSSelectorList();
 62     selectorList.append(WTFMove(selector));
 63     while (!range.atEnd() &amp;&amp; range.peek().type() == CommaToken) {
 64         range.consumeIncludingWhitespace();
 65         selector = consumeComplexSelector(range);
 66         if (!selector)
 67             return CSSSelectorList();
 68         selectorList.append(WTFMove(selector));
 69     }
 70 
 71     if (m_failedParsing)
 72         return { };
 73     return CSSSelectorList { WTFMove(selectorList) };
 74 }
 75 
 76 CSSSelectorList CSSSelectorParser::consumeCompoundSelectorList(CSSParserTokenRange&amp; range)
 77 {
 78     Vector&lt;std::unique_ptr&lt;CSSParserSelector&gt;&gt; selectorList;
 79     std::unique_ptr&lt;CSSParserSelector&gt; selector = consumeCompoundSelector(range);
 80     range.consumeWhitespace();
 81     if (!selector)
 82         return CSSSelectorList();
 83     selectorList.append(WTFMove(selector));
 84     while (!range.atEnd() &amp;&amp; range.peek().type() == CommaToken) {
 85         range.consumeIncludingWhitespace();
 86         selector = consumeCompoundSelector(range);
 87         range.consumeWhitespace();
 88         if (!selector)
 89             return CSSSelectorList();
 90         selectorList.append(WTFMove(selector));
 91     }
 92 
 93     if (m_failedParsing)
 94         return { };
 95     return CSSSelectorList { WTFMove(selectorList) };
 96 }
 97 
 98 static bool consumeLangArgumentList(std::unique_ptr&lt;Vector&lt;AtomString&gt;&gt;&amp; argumentList, CSSParserTokenRange&amp; range)
 99 {
100     const CSSParserToken&amp; ident = range.consumeIncludingWhitespace();
101     if (ident.type() != IdentToken &amp;&amp; ident.type() != StringToken)
102         return false;
103     StringView string = ident.value();
104     if (string.startsWith(&quot;--&quot;))
105         return false;
106     argumentList-&gt;append(string.toAtomString());
107     while (!range.atEnd() &amp;&amp; range.peek().type() == CommaToken) {
108         range.consumeIncludingWhitespace();
109         const CSSParserToken&amp; ident = range.consumeIncludingWhitespace();
110         if (ident.type() != IdentToken &amp;&amp; ident.type() != StringToken)
111             return false;
112         StringView string = ident.value();
113         if (string.startsWith(&quot;--&quot;))
114             return false;
115         argumentList-&gt;append(string.toAtomString());
116     }
117     return range.atEnd();
118 }
119 
120 namespace {
121 
122 enum CompoundSelectorFlags {
123     HasPseudoElementForRightmostCompound = 1 &lt;&lt; 0,
124     HasContentPseudoElement = 1 &lt;&lt; 1
125 };
126 
127 unsigned extractCompoundFlags(const CSSParserSelector&amp; simpleSelector, CSSParserMode parserMode)
128 {
129     if (simpleSelector.match() != CSSSelector::PseudoElement)
130         return 0;
131 
132     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=161747
133     // The UASheetMode check is a work-around to allow this selector in mediaControls(New).css:
134     // input[type=&quot;range&quot; i]::-webkit-media-slider-container &gt; div {
135     if (parserMode == UASheetMode &amp;&amp; simpleSelector.pseudoElementType() == CSSSelector::PseudoElementWebKitCustom)
136         return 0;
137     return HasPseudoElementForRightmostCompound;
138 }
139 
140 } // namespace
141 
142 static bool isDescendantCombinator(CSSSelector::RelationType relation)
143 {
144     return relation == CSSSelector::DescendantSpace;
145 }
146 
147 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumeComplexSelector(CSSParserTokenRange&amp; range)
148 {
149     std::unique_ptr&lt;CSSParserSelector&gt; selector = consumeCompoundSelector(range);
150     if (!selector)
151         return nullptr;
152 
153     unsigned previousCompoundFlags = 0;
154 
155     for (CSSParserSelector* simple = selector.get(); simple &amp;&amp; !previousCompoundFlags; simple = simple-&gt;tagHistory())
156         previousCompoundFlags |= extractCompoundFlags(*simple, m_context.mode);
157 
158     while (auto combinator = consumeCombinator(range)) {
159         std::unique_ptr&lt;CSSParserSelector&gt; nextSelector = consumeCompoundSelector(range);
160         if (!nextSelector)
161             return isDescendantCombinator(combinator) ? WTFMove(selector) : nullptr;
162         if (previousCompoundFlags &amp; HasPseudoElementForRightmostCompound)
163             return nullptr;
164         CSSParserSelector* end = nextSelector.get();
165         unsigned compoundFlags = extractCompoundFlags(*end, m_context.mode);
166         while (end-&gt;tagHistory()) {
167             end = end-&gt;tagHistory();
168             compoundFlags |= extractCompoundFlags(*end, m_context.mode);
169         }
170         end-&gt;setRelation(combinator);
171         previousCompoundFlags = compoundFlags;
172         end-&gt;setTagHistory(WTFMove(selector));
173 
174         selector = WTFMove(nextSelector);
175     }
176 
177     return selector;
178 }
179 
180 namespace {
181 
182 bool isScrollbarPseudoClass(CSSSelector::PseudoClassType pseudo)
183 {
184     switch (pseudo) {
185     case CSSSelector::PseudoClassEnabled:
186     case CSSSelector::PseudoClassDisabled:
187     case CSSSelector::PseudoClassHover:
188     case CSSSelector::PseudoClassActive:
189     case CSSSelector::PseudoClassHorizontal:
190     case CSSSelector::PseudoClassVertical:
191     case CSSSelector::PseudoClassDecrement:
192     case CSSSelector::PseudoClassIncrement:
193     case CSSSelector::PseudoClassStart:
194     case CSSSelector::PseudoClassEnd:
195     case CSSSelector::PseudoClassDoubleButton:
196     case CSSSelector::PseudoClassSingleButton:
197     case CSSSelector::PseudoClassNoButton:
198     case CSSSelector::PseudoClassCornerPresent:
199     case CSSSelector::PseudoClassWindowInactive:
200         return true;
201     default:
202         return false;
203     }
204 }
205 
206 bool isUserActionPseudoClass(CSSSelector::PseudoClassType pseudo)
207 {
208     switch (pseudo) {
209     case CSSSelector::PseudoClassHover:
210     case CSSSelector::PseudoClassFocus:
211     case CSSSelector::PseudoClassActive:
<a name="1" id="anc1"></a><span class="line-added">212     case CSSSelector::PseudoClassFocusWithin:</span>
213         return true;
214     default:
215         return false;
216     }
217 }
218 
219 bool isPseudoClassValidAfterPseudoElement(CSSSelector::PseudoClassType pseudoClass, CSSSelector::PseudoElementType compoundPseudoElement)
220 {
221     switch (compoundPseudoElement) {
<a name="2" id="anc2"></a><span class="line-added">222     case CSSSelector::PseudoElementPart:</span>
<span class="line-added">223         return !isTreeStructuralPseudoClass(pseudoClass);</span>
224     case CSSSelector::PseudoElementResizer:
225     case CSSSelector::PseudoElementScrollbar:
226     case CSSSelector::PseudoElementScrollbarCorner:
227     case CSSSelector::PseudoElementScrollbarButton:
228     case CSSSelector::PseudoElementScrollbarThumb:
229     case CSSSelector::PseudoElementScrollbarTrack:
230     case CSSSelector::PseudoElementScrollbarTrackPiece:
231         return isScrollbarPseudoClass(pseudoClass);
232     case CSSSelector::PseudoElementSelection:
233         return pseudoClass == CSSSelector::PseudoClassWindowInactive;
234     case CSSSelector::PseudoElementWebKitCustom:
235     case CSSSelector::PseudoElementWebKitCustomLegacyPrefixed:
236         return isUserActionPseudoClass(pseudoClass);
237     default:
238         return false;
239     }
240 }
241 
242 bool isSimpleSelectorValidAfterPseudoElement(const CSSParserSelector&amp; simpleSelector, CSSSelector::PseudoElementType compoundPseudoElement)
243 {
244     if (compoundPseudoElement == CSSSelector::PseudoElementUnknown)
245         return true;
<a name="3" id="anc3"></a><span class="line-modified">246     if (compoundPseudoElement == CSSSelector::PseudoElementPart) {</span>
<span class="line-modified">247         if (simpleSelector.match() == CSSSelector::PseudoElement &amp;&amp; simpleSelector.pseudoElementType() != CSSSelector::PseudoElementPart)</span>
<span class="line-modified">248             return true;</span>
<span class="line-added">249     }</span>
250     if (simpleSelector.match() != CSSSelector::PseudoClass)
251         return false;
252     CSSSelector::PseudoClassType pseudo = simpleSelector.pseudoClassType();
253     if (pseudo == CSSSelector::PseudoClassNot) {
254         ASSERT(simpleSelector.selectorList());
255         ASSERT(simpleSelector.selectorList()-&gt;first());
256         pseudo = simpleSelector.selectorList()-&gt;first()-&gt;pseudoClassType();
257     }
258     return isPseudoClassValidAfterPseudoElement(pseudo, compoundPseudoElement);
259 }
260 
261 } // namespace
262 
263 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumeCompoundSelector(CSSParserTokenRange&amp; range)
264 {
265     std::unique_ptr&lt;CSSParserSelector&gt; compoundSelector;
266 
267     AtomString namespacePrefix;
268     AtomString elementName;
269     CSSSelector::PseudoElementType compoundPseudoElement = CSSSelector::PseudoElementUnknown;
270     if (!consumeName(range, elementName, namespacePrefix)) {
271         compoundSelector = consumeSimpleSelector(range);
272         if (!compoundSelector)
273             return nullptr;
274         if (compoundSelector-&gt;match() == CSSSelector::PseudoElement)
275             compoundPseudoElement = compoundSelector-&gt;pseudoElementType();
276     }
277 
278     while (std::unique_ptr&lt;CSSParserSelector&gt; simpleSelector = consumeSimpleSelector(range)) {
279         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=161747
280         // The UASheetMode check is a work-around to allow this selector in mediaControls(New).css:
281         // video::-webkit-media-text-track-region-container.scrolling
282         if (m_context.mode != UASheetMode &amp;&amp; !isSimpleSelectorValidAfterPseudoElement(*simpleSelector.get(), compoundPseudoElement)) {
283             m_failedParsing = true;
284             return nullptr;
285         }
286         if (simpleSelector-&gt;match() == CSSSelector::PseudoElement)
287             compoundPseudoElement = simpleSelector-&gt;pseudoElementType();
288 
289         if (compoundSelector)
290             compoundSelector = addSimpleSelectorToCompound(WTFMove(compoundSelector), WTFMove(simpleSelector));
291         else
292             compoundSelector = WTFMove(simpleSelector);
293     }
294 
295     if (!compoundSelector) {
296         AtomString namespaceURI = determineNamespace(namespacePrefix);
297         if (namespaceURI.isNull()) {
298             m_failedParsing = true;
299             return nullptr;
300         }
301         if (namespaceURI == defaultNamespace())
302             namespacePrefix = nullAtom();
303 
304         CSSParserSelector* rawSelector = new CSSParserSelector(QualifiedName(namespacePrefix, elementName, namespaceURI));
305         std::unique_ptr&lt;CSSParserSelector&gt; selector = std::unique_ptr&lt;CSSParserSelector&gt;(rawSelector);
306         return selector;
307     }
308     prependTypeSelectorIfNeeded(namespacePrefix, elementName, compoundSelector.get());
309     return splitCompoundAtImplicitShadowCrossingCombinator(WTFMove(compoundSelector), m_context);
310 }
311 
312 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumeSimpleSelector(CSSParserTokenRange&amp; range)
313 {
314     const CSSParserToken&amp; token = range.peek();
315     std::unique_ptr&lt;CSSParserSelector&gt; selector;
316     if (token.type() == HashToken)
317         selector = consumeId(range);
318     else if (token.type() == DelimiterToken &amp;&amp; token.delimiter() == &#39;.&#39;)
319         selector = consumeClass(range);
320     else if (token.type() == LeftBracketToken)
321         selector = consumeAttribute(range);
322     else if (token.type() == ColonToken)
323         selector = consumePseudo(range);
324     else
325         return nullptr;
326     if (!selector)
327         m_failedParsing = true;
328     return selector;
329 }
330 
331 bool CSSSelectorParser::consumeName(CSSParserTokenRange&amp; range, AtomString&amp; name, AtomString&amp; namespacePrefix)
332 {
333     name = nullAtom();
334     namespacePrefix = nullAtom();
335 
336     const CSSParserToken&amp; firstToken = range.peek();
337     if (firstToken.type() == IdentToken) {
338         name = firstToken.value().toAtomString();
339         range.consume();
340     } else if (firstToken.type() == DelimiterToken &amp;&amp; firstToken.delimiter() == &#39;*&#39;) {
341         name = starAtom();
342         range.consume();
343     } else if (firstToken.type() == DelimiterToken &amp;&amp; firstToken.delimiter() == &#39;|&#39;) {
344         // This is an empty namespace, which&#39;ll get assigned this value below
345         name = emptyAtom();
346     } else
347         return false;
348 
349     if (range.peek().type() != DelimiterToken || range.peek().delimiter() != &#39;|&#39;)
350         return true;
351     range.consume();
352 
353     namespacePrefix = name;
354     const CSSParserToken&amp; nameToken = range.consume();
355     if (nameToken.type() == IdentToken) {
356         name = nameToken.value().toAtomString();
357     } else if (nameToken.type() == DelimiterToken &amp;&amp; nameToken.delimiter() == &#39;*&#39;)
358         name = starAtom();
359     else {
360         name = nullAtom();
361         namespacePrefix = nullAtom();
362         return false;
363     }
364 
365     return true;
366 }
367 
368 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumeId(CSSParserTokenRange&amp; range)
369 {
370     ASSERT(range.peek().type() == HashToken);
371     if (range.peek().getHashTokenType() != HashTokenId)
372         return nullptr;
373     std::unique_ptr&lt;CSSParserSelector&gt; selector = std::unique_ptr&lt;CSSParserSelector&gt;(new CSSParserSelector());
374     selector-&gt;setMatch(CSSSelector::Id);
375 
376     // FIXME-NEWPARSER: Avoid having to do this, but the old parser does and we need
377     // to be compatible for now.
378     CSSParserToken token = range.consume();
379     selector-&gt;setValue(token.value().toAtomString(), m_context.mode == HTMLQuirksMode);
380     return selector;
381 }
382 
383 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumeClass(CSSParserTokenRange&amp; range)
384 {
385     ASSERT(range.peek().type() == DelimiterToken);
386     ASSERT(range.peek().delimiter() == &#39;.&#39;);
387     range.consume();
388     if (range.peek().type() != IdentToken)
389         return nullptr;
390     std::unique_ptr&lt;CSSParserSelector&gt; selector = std::unique_ptr&lt;CSSParserSelector&gt;(new CSSParserSelector());
391     selector-&gt;setMatch(CSSSelector::Class);
392 
393     // FIXME-NEWPARSER: Avoid having to do this, but the old parser does and we need
394     // to be compatible for now.
395     CSSParserToken token = range.consume();
396     selector-&gt;setValue(token.value().toAtomString(), m_context.mode == HTMLQuirksMode);
397 
398     return selector;
399 }
400 
401 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumeAttribute(CSSParserTokenRange&amp; range)
402 {
403     ASSERT(range.peek().type() == LeftBracketToken);
404     CSSParserTokenRange block = range.consumeBlock();
405     block.consumeWhitespace();
406 
407     AtomString namespacePrefix;
408     AtomString attributeName;
409     if (!consumeName(block, attributeName, namespacePrefix))
410         return nullptr;
411     block.consumeWhitespace();
412 
413     AtomString namespaceURI = determineNamespace(namespacePrefix);
414     if (namespaceURI.isNull())
415         return nullptr;
416 
417     QualifiedName qualifiedName = namespacePrefix.isNull()
418         ? QualifiedName(nullAtom(), attributeName, nullAtom())
419         : QualifiedName(namespacePrefix, attributeName, namespaceURI);
420 
421     std::unique_ptr&lt;CSSParserSelector&gt; selector = std::unique_ptr&lt;CSSParserSelector&gt;(new CSSParserSelector());
422 
423     if (block.atEnd()) {
424         selector-&gt;setAttribute(qualifiedName, m_context.isHTMLDocument, CSSSelector::CaseSensitive);
425         selector-&gt;setMatch(CSSSelector::Set);
426         return selector;
427     }
428 
429     selector-&gt;setMatch(consumeAttributeMatch(block));
430 
431     const CSSParserToken&amp; attributeValue = block.consumeIncludingWhitespace();
432     if (attributeValue.type() != IdentToken &amp;&amp; attributeValue.type() != StringToken)
433         return nullptr;
434     selector-&gt;setValue(attributeValue.value().toAtomString());
435 
436     selector-&gt;setAttribute(qualifiedName, m_context.isHTMLDocument, consumeAttributeFlags(block));
437 
438     if (!block.atEnd())
439         return nullptr;
440     return selector;
441 }
442 
443 static bool isOnlyPseudoClassFunction(CSSSelector::PseudoClassType pseudoClassType)
444 {
445     switch (pseudoClassType) {
446     case CSSSelector::PseudoClassNot:
447     case CSSSelector::PseudoClassMatches:
448     case CSSSelector::PseudoClassNthChild:
449     case CSSSelector::PseudoClassNthLastChild:
450     case CSSSelector::PseudoClassNthOfType:
451     case CSSSelector::PseudoClassNthLastOfType:
452     case CSSSelector::PseudoClassLang:
453     case CSSSelector::PseudoClassAny:
454 #if ENABLE(CSS_SELECTORS_LEVEL4)
455     case CSSSelector::PseudoClassDir:
456     case CSSSelector::PseudoClassRole:
457 #endif
458         return true;
459     default:
460         break;
461     }
462     return false;
463 }
464 
465 static bool isOnlyPseudoElementFunction(CSSSelector::PseudoElementType pseudoElementType)
466 {
467     // Note that we omit cue since it can be both an ident or a function.
468     switch (pseudoElementType) {
<a name="4" id="anc4"></a><span class="line-added">469     case CSSSelector::PseudoElementPart:</span>
470     case CSSSelector::PseudoElementSlotted:
471         return true;
472     default:
473         break;
474     }
475     return false;
476 }
477 
478 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::consumePseudo(CSSParserTokenRange&amp; range)
479 {
480     ASSERT(range.peek().type() == ColonToken);
481     range.consume();
482 
483     int colons = 1;
484     if (range.peek().type() == ColonToken) {
485         range.consume();
486         colons++;
487     }
488 
489     const CSSParserToken&amp; token = range.peek();
490     if (token.type() != IdentToken &amp;&amp; token.type() != FunctionToken)
491         return nullptr;
492 
493     std::unique_ptr&lt;CSSParserSelector&gt; selector;
494 
495     if (colons == 1) {
496         selector = CSSParserSelector::parsePseudoClassSelector(token.value());
<a name="5" id="anc5"></a><span class="line-modified">497         if (!selector)</span>

498             return nullptr;
<a name="6" id="anc6"></a><span class="line-added">499         if (selector-&gt;match() == CSSSelector::PseudoClass) {</span>
<span class="line-added">500             if (m_context.mode != UASheetMode &amp;&amp; selector-&gt;pseudoClassType() == CSSSelector::PseudoClassDirectFocus)</span>
<span class="line-added">501                 return nullptr;</span>
<span class="line-added">502 #if ENABLE(ATTACHMENT_ELEMENT)</span>
<span class="line-added">503             if (!m_context.attachmentEnabled &amp;&amp; selector-&gt;pseudoClassType() == CSSSelector::PseudoClassHasAttachment)</span>
<span class="line-added">504                 return nullptr;</span>
505 #endif
<a name="7" id="anc7"></a><span class="line-added">506         }</span>
507     } else {
508         selector = CSSParserSelector::parsePseudoElementSelector(token.value());
509 #if ENABLE(VIDEO_TRACK)
510         // Treat the ident version of cue as PseudoElementWebkitCustom.
511         if (token.type() == IdentToken &amp;&amp; selector &amp;&amp; selector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; selector-&gt;pseudoElementType() == CSSSelector::PseudoElementCue)
512             selector-&gt;setPseudoElementType(CSSSelector::PseudoElementWebKitCustom);
513 #endif
514     }
515 
516     if (!selector || (selector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; m_disallowPseudoElements))
517         return nullptr;
518 
519     if (token.type() == IdentToken) {
520         range.consume();
521         if ((selector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; (selector-&gt;pseudoElementType() == CSSSelector::PseudoElementUnknown || isOnlyPseudoElementFunction(selector-&gt;pseudoElementType())))
522             || (selector-&gt;match() == CSSSelector::PseudoClass &amp;&amp; (selector-&gt;pseudoClassType() == CSSSelector::PseudoClassUnknown || isOnlyPseudoClassFunction(selector-&gt;pseudoClassType()))))
523             return nullptr;
524         return selector;
525     }
526 
527     CSSParserTokenRange block = range.consumeBlock();
528     block.consumeWhitespace();
529     if (token.type() != FunctionToken)
530         return nullptr;
531 
532     const auto&amp; argumentStart = block.peek();
533 
534     if (selector-&gt;match() == CSSSelector::PseudoClass) {
535         switch (selector-&gt;pseudoClassType()) {
536         case CSSSelector::PseudoClassNot: {
537             DisallowPseudoElementsScope scope(this);
538             std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
539             *selectorList = consumeComplexSelectorList(block);
540             if (!selectorList-&gt;first() || !block.atEnd())
541                 return nullptr;
542             selector-&gt;setSelectorList(WTFMove(selectorList));
543             return selector;
544         }
545         case CSSSelector::PseudoClassNthChild:
546         case CSSSelector::PseudoClassNthLastChild:
547         case CSSSelector::PseudoClassNthOfType:
548         case CSSSelector::PseudoClassNthLastOfType: {
549             std::pair&lt;int, int&gt; ab;
550             if (!consumeANPlusB(block, ab))
551                 return nullptr;
552             block.consumeWhitespace();
553             const auto&amp; argumentEnd = block.peek();
554             auto rangeOfANPlusB = block.makeSubRange(&amp;argumentStart, &amp;argumentEnd);
555             auto argument = rangeOfANPlusB.serialize();
556             selector-&gt;setArgument(argument.stripWhiteSpace());
557             if (!block.atEnd()) {
558                 if (block.peek().type() != IdentToken)
559                     return nullptr;
560                 const CSSParserToken&amp; ident = block.consume();
561                 if (!equalIgnoringASCIICase(ident.value(), &quot;of&quot;))
562                     return nullptr;
563                 if (block.peek().type() != WhitespaceToken)
564                     return nullptr;
565                 DisallowPseudoElementsScope scope(this);
566                 block.consumeWhitespace();
567                 std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
568                 *selectorList = consumeComplexSelectorList(block);
569                 if (!selectorList-&gt;first() || !block.atEnd())
570                     return nullptr;
571                 selector-&gt;setSelectorList(WTFMove(selectorList));
572             }
573             selector-&gt;setNth(ab.first, ab.second);
574             return selector;
575         }
576         case CSSSelector::PseudoClassLang: {
577             // FIXME: CSS Selectors Level 4 allows :lang(*-foo)
578             auto argumentList = makeUnique&lt;Vector&lt;AtomString&gt;&gt;();
579             if (!consumeLangArgumentList(argumentList, block))
580                 return nullptr;
<a name="8" id="anc8"></a><span class="line-modified">581             selector-&gt;setArgumentList(WTFMove(argumentList));</span>
582             return selector;
583         }
584         case CSSSelector::PseudoClassMatches: {
585             std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
586             *selectorList = consumeComplexSelectorList(block);
587             if (!selectorList-&gt;first() || !block.atEnd())
588                 return nullptr;
589             selector-&gt;setSelectorList(WTFMove(selectorList));
590             return selector;
591         }
592         case CSSSelector::PseudoClassAny:
593         case CSSSelector::PseudoClassHost: {
594             std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
595             *selectorList = consumeCompoundSelectorList(block);
596             if (!selectorList-&gt;first() || !block.atEnd())
597                 return nullptr;
598             selector-&gt;setSelectorList(WTFMove(selectorList));
599             return selector;
600         }
601 #if ENABLE(CSS_SELECTORS_LEVEL4)
602         case CSSSelector::PseudoClassDir:
603         case CSSSelector::PseudoClassRole: {
604             const CSSParserToken&amp; ident = block.consumeIncludingWhitespace();
605             if (ident.type() != IdentToken || !block.atEnd())
606                 return nullptr;
607             selector-&gt;setArgument(ident.value().toAtomString());
608             return selector;
609         }
610 #endif
611         default:
612             break;
613         }
<a name="9" id="anc9"></a>
614     }
615 
616     if (selector-&gt;match() == CSSSelector::PseudoElement) {
617         switch (selector-&gt;pseudoElementType()) {
618 #if ENABLE(VIDEO_TRACK)
619         case CSSSelector::PseudoElementCue: {
620             DisallowPseudoElementsScope scope(this);
621             std::unique_ptr&lt;CSSSelectorList&gt; selectorList = std::unique_ptr&lt;CSSSelectorList&gt;(new CSSSelectorList());
622             *selectorList = consumeCompoundSelectorList(block);
623             if (!selectorList-&gt;isValid() || !block.atEnd())
624                 return nullptr;
625             selector-&gt;setSelectorList(WTFMove(selectorList));
626             return selector;
627         }
628 #endif
<a name="10" id="anc10"></a><span class="line-added">629         case CSSSelector::PseudoElementHighlight: {</span>
<span class="line-added">630             DisallowPseudoElementsScope scope(this);</span>
<span class="line-added">631 </span>
<span class="line-added">632             auto&amp; ident = block.consumeIncludingWhitespace();</span>
<span class="line-added">633             if (ident.type() != IdentToken || !block.atEnd())</span>
<span class="line-added">634                 return nullptr;</span>
<span class="line-added">635 </span>
<span class="line-added">636             auto argumentList = makeUnique&lt;Vector&lt;AtomString&gt;&gt;();</span>
<span class="line-added">637             argumentList-&gt;append(ident.value().toAtomString());</span>
<span class="line-added">638             selector-&gt;setArgumentList(WTFMove(argumentList));</span>
<span class="line-added">639 </span>
<span class="line-added">640             return selector;</span>
<span class="line-added">641         }</span>
<span class="line-added">642         case CSSSelector::PseudoElementPart: {</span>
<span class="line-added">643             auto argumentList = makeUnique&lt;Vector&lt;AtomString&gt;&gt;();</span>
<span class="line-added">644             do {</span>
<span class="line-added">645                 auto&amp; ident = block.consumeIncludingWhitespace();</span>
<span class="line-added">646                 if (ident.type() != IdentToken)</span>
<span class="line-added">647                     return nullptr;</span>
<span class="line-added">648                 argumentList-&gt;append(ident.value().toAtomString());</span>
<span class="line-added">649             } while (!block.atEnd());</span>
<span class="line-added">650 </span>
<span class="line-added">651             selector-&gt;setArgumentList(WTFMove(argumentList));</span>
<span class="line-added">652             return selector;</span>
<span class="line-added">653         }</span>
654         case CSSSelector::PseudoElementSlotted: {
655             DisallowPseudoElementsScope scope(this);
656 
657             std::unique_ptr&lt;CSSParserSelector&gt; innerSelector = consumeCompoundSelector(block);
658             block.consumeWhitespace();
659             if (!innerSelector || !block.atEnd())
660                 return nullptr;
661             selector-&gt;adoptSelectorVector(Vector&lt;std::unique_ptr&lt;CSSParserSelector&gt;&gt;::from(WTFMove(innerSelector)));
662             return selector;
663         }
664         default:
665             break;
666         }
667     }
668 
669     return nullptr;
670 }
671 
672 CSSSelector::RelationType CSSSelectorParser::consumeCombinator(CSSParserTokenRange&amp; range)
673 {
674     auto fallbackResult = CSSSelector::Subselector;
675     while (range.peek().type() == WhitespaceToken) {
676         range.consume();
677         fallbackResult = CSSSelector::DescendantSpace;
678     }
679 
680     if (range.peek().type() != DelimiterToken)
681         return fallbackResult;
682 
683     UChar delimiter = range.peek().delimiter();
684 
685     if (delimiter == &#39;+&#39; || delimiter == &#39;~&#39; || delimiter == &#39;&gt;&#39;) {
686         range.consumeIncludingWhitespace();
687         if (delimiter == &#39;+&#39;)
688             return CSSSelector::DirectAdjacent;
689         if (delimiter == &#39;~&#39;)
690             return CSSSelector::IndirectAdjacent;
691         return CSSSelector::Child;
692     }
693 
694     return fallbackResult;
695 }
696 
697 CSSSelector::Match CSSSelectorParser::consumeAttributeMatch(CSSParserTokenRange&amp; range)
698 {
699     const CSSParserToken&amp; token = range.consumeIncludingWhitespace();
700     switch (token.type()) {
701     case IncludeMatchToken:
702         return CSSSelector::List;
703     case DashMatchToken:
704         return CSSSelector::Hyphen;
705     case PrefixMatchToken:
706         return CSSSelector::Begin;
707     case SuffixMatchToken:
708         return CSSSelector::End;
709     case SubstringMatchToken:
710         return CSSSelector::Contain;
711     case DelimiterToken:
712         if (token.delimiter() == &#39;=&#39;)
713             return CSSSelector::Exact;
714         FALLTHROUGH;
715     default:
716         m_failedParsing = true;
717         return CSSSelector::Exact;
718     }
719 }
720 
721 CSSSelector::AttributeMatchType CSSSelectorParser::consumeAttributeFlags(CSSParserTokenRange&amp; range)
722 {
723     if (range.peek().type() != IdentToken)
724         return CSSSelector::CaseSensitive;
725     const CSSParserToken&amp; flag = range.consumeIncludingWhitespace();
726     if (equalIgnoringASCIICase(flag.value(), &quot;i&quot;))
727         return CSSSelector::CaseInsensitive;
728     m_failedParsing = true;
729     return CSSSelector::CaseSensitive;
730 }
731 
732 bool CSSSelectorParser::consumeANPlusB(CSSParserTokenRange&amp; range, std::pair&lt;int, int&gt;&amp; result)
733 {
734     const CSSParserToken&amp; token = range.consume();
735     if (token.type() == NumberToken &amp;&amp; token.numericValueType() == IntegerValueType) {
736         result = std::make_pair(0, static_cast&lt;int&gt;(token.numericValue()));
737         return true;
738     }
739     if (token.type() == IdentToken) {
740         if (equalIgnoringASCIICase(token.value(), &quot;odd&quot;)) {
741             result = std::make_pair(2, 1);
742             return true;
743         }
744         if (equalIgnoringASCIICase(token.value(), &quot;even&quot;)) {
745             result = std::make_pair(2, 0);
746             return true;
747         }
748     }
749 
750     // The &#39;n&#39; will end up as part of an ident or dimension. For a valid &lt;an+b&gt;,
751     // this will store a string of the form &#39;n&#39;, &#39;n-&#39;, or &#39;n-123&#39;.
752     String nString;
753 
754     if (token.type() == DelimiterToken &amp;&amp; token.delimiter() == &#39;+&#39; &amp;&amp; range.peek().type() == IdentToken) {
755         result.first = 1;
756         nString = range.consume().value().toString();
757     } else if (token.type() == DimensionToken &amp;&amp; token.numericValueType() == IntegerValueType) {
758         result.first = token.numericValue();
759         nString = token.value().toString();
760     } else if (token.type() == IdentToken) {
761         if (token.value()[0] == &#39;-&#39;) {
762             result.first = -1;
763             nString = token.value().substring(1).toString();
764         } else {
765             result.first = 1;
766             nString = token.value().toString();
767         }
768     }
769 
770     range.consumeWhitespace();
771 
772     if (nString.isEmpty() || !isASCIIAlphaCaselessEqual(nString[0], &#39;n&#39;))
773         return false;
774     if (nString.length() &gt; 1 &amp;&amp; nString[1] != &#39;-&#39;)
775         return false;
776 
777     if (nString.length() &gt; 2) {
778         bool valid;
779         result.second = nString.substring(1).toIntStrict(&amp;valid);
780         return valid;
781     }
782 
783     NumericSign sign = nString.length() == 1 ? NoSign : MinusSign;
784     if (sign == NoSign &amp;&amp; range.peek().type() == DelimiterToken) {
785         char delimiterSign = range.consumeIncludingWhitespace().delimiter();
786         if (delimiterSign == &#39;+&#39;)
787             sign = PlusSign;
788         else if (delimiterSign == &#39;-&#39;)
789             sign = MinusSign;
790         else
791             return false;
792     }
793 
794     if (sign == NoSign &amp;&amp; range.peek().type() != NumberToken) {
795         result.second = 0;
796         return true;
797     }
798 
799     const CSSParserToken&amp; b = range.consume();
800     if (b.type() != NumberToken || b.numericValueType() != IntegerValueType)
801         return false;
802     if ((b.numericSign() == NoSign) == (sign == NoSign))
803         return false;
804     result.second = b.numericValue();
805     if (sign == MinusSign)
806         result.second = -result.second;
807     return true;
808 }
809 
810 const AtomString&amp; CSSSelectorParser::defaultNamespace() const
811 {
812     if (!m_styleSheet)
813         return starAtom();
814     return m_styleSheet-&gt;defaultNamespace();
815 }
816 
817 const AtomString&amp; CSSSelectorParser::determineNamespace(const AtomString&amp; prefix)
818 {
819     if (prefix.isNull())
820         return defaultNamespace();
821     if (prefix.isEmpty())
822         return emptyAtom(); // No namespace. If an element/attribute has a namespace, we won&#39;t match it.
823     if (prefix == starAtom())
824         return starAtom(); // We&#39;ll match any namespace.
825     if (!m_styleSheet)
826         return nullAtom(); // Cannot resolve prefix to namespace without a stylesheet, syntax error.
827     return m_styleSheet-&gt;namespaceURIFromPrefix(prefix);
828 }
829 
830 void CSSSelectorParser::prependTypeSelectorIfNeeded(const AtomString&amp; namespacePrefix, const AtomString&amp; elementName, CSSParserSelector* compoundSelector)
831 {
832     bool isShadowDOM = compoundSelector-&gt;needsImplicitShadowCombinatorForMatching();
833 
834     if (elementName.isNull() &amp;&amp; defaultNamespace() == starAtom() &amp;&amp; !isShadowDOM)
835         return;
836 
837     AtomString determinedElementName = elementName.isNull() ? starAtom() : elementName;
838     AtomString namespaceURI = determineNamespace(namespacePrefix);
839     if (namespaceURI.isNull()) {
840         m_failedParsing = true;
841         return;
842     }
843     AtomString determinedPrefix = namespacePrefix;
844     if (namespaceURI == defaultNamespace())
845         determinedPrefix = nullAtom();
846     QualifiedName tag = QualifiedName(determinedPrefix, determinedElementName, namespaceURI);
847 
848     // *:host never matches, so we can&#39;t discard the *,
849     // otherwise we can&#39;t tell the difference between *:host and just :host.
850     //
851     // Also, selectors where we use a ShadowPseudo combinator between the
852     // element and the pseudo element for matching (custom pseudo elements,
853     // ::cue), we need a universal selector to set the combinator
854     // (relation) on in the cases where there are no simple selectors preceding
855     // the pseudo element.
856     bool explicitForHost = compoundSelector-&gt;isHostPseudoSelector() &amp;&amp; !elementName.isNull();
857     if (tag != anyQName() || explicitForHost || isShadowDOM)
858         compoundSelector-&gt;prependTagSelector(tag, determinedPrefix == nullAtom() &amp;&amp; determinedElementName == starAtom() &amp;&amp; !explicitForHost);
859 }
860 
861 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::addSimpleSelectorToCompound(std::unique_ptr&lt;CSSParserSelector&gt; compoundSelector, std::unique_ptr&lt;CSSParserSelector&gt; simpleSelector)
862 {
863     compoundSelector-&gt;appendTagHistory(CSSSelector::Subselector, WTFMove(simpleSelector));
864     return compoundSelector;
865 }
866 
867 std::unique_ptr&lt;CSSParserSelector&gt; CSSSelectorParser::splitCompoundAtImplicitShadowCrossingCombinator(std::unique_ptr&lt;CSSParserSelector&gt; compoundSelector, const CSSParserContext&amp; context)
868 {
869     // The tagHistory is a linked list that stores combinator separated compound selectors
870     // from right-to-left. Yet, within a single compound selector, stores the simple selectors
871     // from left-to-right.
872     //
873     // &quot;.a.b &gt; div#id&quot; is stored in a tagHistory as [div, #id, .a, .b], each element in the
874     // list stored with an associated relation (combinator or Subselector).
875     //
876     // ::cue, ::shadow, and custom pseudo elements have an implicit ShadowPseudo combinator
877     // to their left, which really makes for a new compound selector, yet it&#39;s consumed by
878     // the selector parser as a single compound selector.
879     //
880     // Example: input#x::-webkit-clear-button -&gt; [ ::-webkit-clear-button, input, #x ]
881     //
882     CSSParserSelector* splitAfter = compoundSelector.get();
883     while (splitAfter-&gt;tagHistory() &amp;&amp; !splitAfter-&gt;tagHistory()-&gt;needsImplicitShadowCombinatorForMatching())
884         splitAfter = splitAfter-&gt;tagHistory();
885 
886     if (!splitAfter || !splitAfter-&gt;tagHistory())
887         return compoundSelector;
888 
<a name="11" id="anc11"></a><span class="line-modified">889     // ::part() combines with other pseudo elements.</span>
<span class="line-modified">890     bool isPart = splitAfter-&gt;tagHistory()-&gt;match() == CSSSelector::PseudoElement &amp;&amp; splitAfter-&gt;tagHistory()-&gt;pseudoElementType() == CSSSelector::PseudoElementPart;</span>
<span class="line-modified">891 </span>
<span class="line-modified">892     std::unique_ptr&lt;CSSParserSelector&gt; secondCompound;</span>
<span class="line-added">893     if (context.mode == UASheetMode || isPart) {</span>
<span class="line-added">894         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=161747</span>
<span class="line-added">895         // We have to recur, since we have rules in media controls like video::a::b. This should not be allowed, and</span>
<span class="line-added">896         // we should remove this recursion once those rules are gone.</span>
<span class="line-added">897         secondCompound = splitCompoundAtImplicitShadowCrossingCombinator(splitAfter-&gt;releaseTagHistory(), context);</span>
<span class="line-added">898     } else</span>
<span class="line-added">899         secondCompound = splitAfter-&gt;releaseTagHistory();</span>
<span class="line-added">900 </span>
901     secondCompound-&gt;appendTagHistory(CSSSelector::ShadowDescendant, WTFMove(compoundSelector));
902     return secondCompound;
903 }
904 
905 } // namespace WebCore
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOutput.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOutput.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOutput.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOutput.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2013-2017 Apple Inc. All rights reserved.
+ * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -331,10 +331,22 @@
         });
     result->effects = Effects::none();
     return result;
 }
 
+LValue Output::doubleToInt64(LValue value)
+{
+    PatchpointValue* result = patchpoint(Int64);
+    result->append(value, ValueRep::SomeRegister);
+    result->setGenerator(
+        [] (CCallHelpers& jit, const StackmapGenerationParams& params) {
+            jit.truncateDoubleToInt64(params[1].fpr(), params[0].gpr());
+        });
+    result->effects = Effects::none();
+    return result;
+}
+
 LValue Output::doubleToUInt(LValue value)
 {
     PatchpointValue* result = patchpoint(Int32);
     result->append(value, ValueRep::SomeRegister);
     result->setGenerator(
@@ -641,19 +653,41 @@
 LValue Output::notZero64(LValue value)
 {
     return m_block->appendNew<B3::Value>(m_proc, B3::NotEqual, origin(), value, int64Zero);
 }
 
-LValue Output::select(LValue value, LValue taken, LValue notTaken)
+LValue Output::select(LValue value, LValue left, LValue right, SelectPredictability predictability)
 {
     if (value->hasInt32()) {
         if (value->asInt32())
-            return taken;
+            return left;
         else
-            return notTaken;
+            return right;
     }
-    return m_block->appendNew<B3::Value>(m_proc, B3::Select, origin(), value, taken, notTaken);
+
+    if (predictability == SelectPredictability::NotPredictable)
+        return m_block->appendNew<B3::Value>(m_proc, B3::Select, origin(), value, left, right);
+
+    LBasicBlock continuation = newBlock();
+    LBasicBlock leftTakenBlock = newBlock();
+    LBasicBlock rightTakenBlock = newBlock();
+
+    m_block->appendNewControlValue(
+        m_proc, B3::Branch, origin(), value,
+        FrequentedBlock(leftTakenBlock, predictability != SelectPredictability::RightLikely ? FrequencyClass::Normal : FrequencyClass::Rare),
+        FrequentedBlock(rightTakenBlock, predictability != SelectPredictability::LeftLikely ? FrequencyClass::Normal : FrequencyClass::Rare));
+
+    LValue phi = continuation->appendNew<B3::Value>(m_proc, B3::Phi, left->type(), origin());
+
+    leftTakenBlock->appendNew<B3::UpsilonValue>(m_proc, origin(), left, phi);
+    leftTakenBlock->appendNewControlValue(m_proc, B3::Jump, origin(), B3::FrequentedBlock(continuation));
+
+    rightTakenBlock->appendNew<B3::UpsilonValue>(m_proc, origin(), right, phi);
+    rightTakenBlock->appendNewControlValue(m_proc, B3::Jump, origin(), B3::FrequentedBlock(continuation));
+
+    m_block = continuation;
+    return phi;
 }
 
 LValue Output::atomicXchgAdd(LValue operand, TypedPointer pointer, Width width)
 {
     LValue result = m_block->appendNew<AtomicValue>(m_proc, AtomicXchgAdd, origin(), width, operand, pointer.value(), 0, HeapRange(), HeapRange());

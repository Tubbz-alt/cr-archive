<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/HashMapImpl.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;ExceptionHelpers.h&quot;
 29 #include &quot;JSCJSValueInlines.h&quot;
 30 #include &quot;JSObject.h&quot;
 31 
 32 namespace JSC {
 33 
 34 JS_EXPORT_PRIVATE const ClassInfo* getHashMapBucketKeyClassInfo();
 35 JS_EXPORT_PRIVATE const ClassInfo* getHashMapBucketKeyValueClassInfo();
 36 JS_EXPORT_PRIVATE const ClassInfo* getHashMapImplKeyClassInfo();
 37 JS_EXPORT_PRIVATE const ClassInfo* getHashMapImplKeyValueClassInfo();
 38 
 39 enum class HashTableType {
 40     Key,
 41     KeyValue
 42 };
 43 
 44 struct HashMapBucketDataKey {
 45     static const HashTableType Type = HashTableType::Key;
 46     WriteBarrier&lt;Unknown&gt; key;
 47 };
 48 
 49 struct HashMapBucketDataKeyValue {
 50     static const HashTableType Type = HashTableType::KeyValue;
 51     WriteBarrier&lt;Unknown&gt; key;
 52     WriteBarrier&lt;Unknown&gt; value;
 53 };
 54 
 55 template &lt;typename Data&gt;
<a name="1" id="anc1"></a><span class="line-modified"> 56 class HashMapBucket final : public JSCell {</span>
<span class="line-modified"> 57     using Base = JSCell;</span>
 58 
 59     template &lt;typename T = Data&gt;
 60     static typename std::enable_if&lt;std::is_same&lt;T, HashMapBucketDataKey&gt;::value, Structure*&gt;::type selectStructure(VM&amp; vm)
 61     {
 62         return vm.hashMapBucketSetStructure.get();
 63     }
 64 
 65     template &lt;typename T = Data&gt;
 66     static typename std::enable_if&lt;std::is_same&lt;T, HashMapBucketDataKeyValue&gt;::value, Structure*&gt;::type selectStructure(VM&amp; vm)
 67     {
 68         return vm.hashMapBucketMapStructure.get();
 69     }
 70 
 71 public:
 72     static const HashTableType Type = Data::Type;
 73     static const ClassInfo s_info; // This is never accessed directly, since that would break linkage on some compilers.
 74 
<a name="2" id="anc2"></a><span class="line-added"> 75     template&lt;typename CellType, SubspaceAccess mode&gt;</span>
<span class="line-added"> 76     static IsoSubspace* subspaceFor(VM&amp; vm)</span>
<span class="line-added"> 77     {</span>
<span class="line-added"> 78         if constexpr (Type == HashTableType::Key)</span>
<span class="line-added"> 79             return vm.setBucketSpace&lt;mode&gt;();</span>
<span class="line-added"> 80         else</span>
<span class="line-added"> 81             return vm.mapBucketSpace&lt;mode&gt;();</span>
<span class="line-added"> 82     }</span>
 83 
 84     static const ClassInfo* info()
 85     {
<a name="3" id="anc3"></a><span class="line-modified"> 86         if constexpr (Type == HashTableType::Key)</span>

 87             return getHashMapBucketKeyClassInfo();
<a name="4" id="anc4"></a><span class="line-modified"> 88         else</span>
 89             return getHashMapBucketKeyValueClassInfo();
<a name="5" id="anc5"></a>

 90     }
 91 
 92     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 93     {
 94         return Structure::create(vm, globalObject, prototype, TypeInfo(CellType, StructureFlags), info());
 95     }
 96 
 97     static HashMapBucket* create(VM&amp; vm)
 98     {
 99         HashMapBucket* bucket = new (NotNull, allocateCell&lt;HashMapBucket&lt;Data&gt;&gt;(vm.heap)) HashMapBucket(vm, selectStructure(vm));
100         bucket-&gt;finishCreation(vm);
101         ASSERT(!bucket-&gt;next());
102         ASSERT(!bucket-&gt;prev());
103         return bucket;
104     }
105 
106     static HashMapBucket* createSentinel(VM&amp; vm)
107     {
108         auto* bucket = create(vm);
109         bucket-&gt;setKey(vm, jsUndefined());
110         bucket-&gt;setValue(vm, jsUndefined());
111         ASSERT(!bucket-&gt;deleted());
112         return bucket;
113     }
114 
115     HashMapBucket(VM&amp; vm, Structure* structure)
116         : Base(vm, structure)
117     {
118         ASSERT(deleted());
119     }
120 
121     ALWAYS_INLINE void setNext(VM&amp; vm, HashMapBucket* bucket)
122     {
123         m_next.set(vm, this, bucket);
124     }
125     ALWAYS_INLINE void setPrev(VM&amp; vm, HashMapBucket* bucket)
126     {
127         m_prev.set(vm, this, bucket);
128     }
129 
130     ALWAYS_INLINE void setKey(VM&amp; vm, JSValue key)
131     {
132         m_data.key.set(vm, this, key);
133     }
134 
135     template &lt;typename T = Data&gt;
136     ALWAYS_INLINE typename std::enable_if&lt;std::is_same&lt;T, HashMapBucketDataKeyValue&gt;::value&gt;::type setValue(VM&amp; vm, JSValue value)
137     {
138         m_data.value.set(vm, this, value);
139     }
140     template &lt;typename T = Data&gt;
141     ALWAYS_INLINE typename std::enable_if&lt;std::is_same&lt;T, HashMapBucketDataKey&gt;::value&gt;::type setValue(VM&amp;, JSValue) { }
142 
143     ALWAYS_INLINE JSValue key() const { return m_data.key.get(); }
144 
145     template &lt;typename T = Data&gt;
146     ALWAYS_INLINE typename std::enable_if&lt;std::is_same&lt;T, HashMapBucketDataKeyValue&gt;::value, JSValue&gt;::type value() const
147     {
148         return m_data.value.get();
149     }
150 
151     static void visitChildren(JSCell*, SlotVisitor&amp;);
152 
153     ALWAYS_INLINE HashMapBucket* next() const { return m_next.get(); }
154     ALWAYS_INLINE HashMapBucket* prev() const { return m_prev.get(); }
155 
156     ALWAYS_INLINE bool deleted() const { return !key(); }
157     ALWAYS_INLINE void makeDeleted(VM&amp; vm)
158     {
159         setKey(vm, JSValue());
160         setValue(vm, JSValue());
161     }
162 
163     static ptrdiff_t offsetOfKey()
164     {
165         return OBJECT_OFFSETOF(HashMapBucket, m_data) + OBJECT_OFFSETOF(Data, key);
166     }
167 
168     template &lt;typename T = Data&gt;
169     static typename std::enable_if&lt;std::is_same&lt;T, HashMapBucketDataKeyValue&gt;::value, ptrdiff_t&gt;::type offsetOfValue()
170     {
171         return OBJECT_OFFSETOF(HashMapBucket, m_data) + OBJECT_OFFSETOF(Data, value);
172     }
173 
174     static ptrdiff_t offsetOfNext()
175     {
176         return OBJECT_OFFSETOF(HashMapBucket, m_next);
177     }
178 
179     template &lt;typename T = Data&gt;
180     ALWAYS_INLINE static typename std::enable_if&lt;std::is_same&lt;T, HashMapBucketDataKeyValue&gt;::value, JSValue&gt;::type extractValue(const HashMapBucket&amp; bucket)
181     {
182         return bucket.value();
183     }
184 
185     template &lt;typename T = Data&gt;
186     ALWAYS_INLINE static typename std::enable_if&lt;std::is_same&lt;T, HashMapBucketDataKey&gt;::value, JSValue&gt;::type extractValue(const HashMapBucket&amp;)
187     {
188         return JSValue();
189     }
190 
191 private:
192     WriteBarrier&lt;HashMapBucket&gt; m_next;
193     WriteBarrier&lt;HashMapBucket&gt; m_prev;
194     Data m_data;
195 };
196 
197 template &lt;typename BucketType&gt;
198 class HashMapBuffer {
199 public:
200     HashMapBuffer() = delete;
201 
202     static size_t allocationSize(Checked&lt;size_t&gt; capacity)
203     {
204         return (capacity * sizeof(BucketType*)).unsafeGet();
205     }
206 
207     ALWAYS_INLINE BucketType** buffer() const
208     {
209         return bitwise_cast&lt;BucketType**&gt;(this);
210     }
211 
<a name="6" id="anc6"></a><span class="line-modified">212     static HashMapBuffer* create(JSGlobalObject* globalObject, VM&amp; vm, JSCell*, uint32_t capacity)</span>
213     {
214         auto scope = DECLARE_THROW_SCOPE(vm);
215         size_t allocationSize = HashMapBuffer::allocationSize(capacity);
216         void* data = vm.jsValueGigacageAuxiliarySpace.allocateNonVirtual(vm, allocationSize, nullptr, AllocationFailureMode::ReturnNull);
217         if (!data) {
<a name="7" id="anc7"></a><span class="line-modified">218             throwOutOfMemoryError(globalObject, scope);</span>
219             return nullptr;
220         }
221 
222         HashMapBuffer* buffer = static_cast&lt;HashMapBuffer*&gt;(data);
223         buffer-&gt;reset(capacity);
224         return buffer;
225     }
226 
227     ALWAYS_INLINE void reset(uint32_t capacity)
228     {
229         memset(this, -1, allocationSize(capacity));
230     }
231 };
232 
<a name="8" id="anc8"></a><span class="line-modified">233 ALWAYS_INLINE static bool areKeysEqual(JSGlobalObject* globalObject, JSValue a, JSValue b)</span>
234 {
235     // We want +0 and -0 to be compared to true here. sameValue() itself doesn&#39;t
236     // guarantee that, however, we normalize all keys before comparing and storing
237     // them in the map. The normalization will convert -0.0 and 0.0 to the integer
238     // representation for 0.
<a name="9" id="anc9"></a><span class="line-modified">239     return sameValue(globalObject, a, b);</span>
240 }
241 
242 // Note that normalization is inlined in DFG&#39;s NormalizeMapKey.
243 // Keep in sync with the implementation of DFG and FTL normalization.
244 ALWAYS_INLINE JSValue normalizeMapKey(JSValue key)
245 {
246     if (!key.isNumber())
247         return key;
248 
249     if (key.isInt32())
250         return key;
251 
252     double d = key.asDouble();
253     if (std::isnan(d))
254         return jsNaN();
255 
256     int i = static_cast&lt;int&gt;(d);
257     if (i == d) {
258         // When a key is -0, we convert it to positive zero.
259         // When a key is the double representation for an integer, we convert it to an integer.
260         return jsNumber(i);
261     }
262     // This means key is definitely not negative zero, and it&#39;s definitely not a double representation of an integer.
263     return key;
264 }
265 
266 static ALWAYS_INLINE uint32_t wangsInt64Hash(uint64_t key)
267 {
268     key += ~(key &lt;&lt; 32);
269     key ^= (key &gt;&gt; 22);
270     key += ~(key &lt;&lt; 13);
271     key ^= (key &gt;&gt; 8);
272     key += (key &lt;&lt; 3);
273     key ^= (key &gt;&gt; 15);
274     key += ~(key &lt;&lt; 27);
275     key ^= (key &gt;&gt; 31);
276     return static_cast&lt;unsigned&gt;(key);
277 }
278 
<a name="10" id="anc10"></a><span class="line-modified">279 ALWAYS_INLINE uint32_t jsMapHash(JSGlobalObject* globalObject, VM&amp; vm, JSValue value)</span>
280 {
281     ASSERT_WITH_MESSAGE(normalizeMapKey(value) == value, &quot;We expect normalized values flowing into this function.&quot;);
282 
283     if (value.isString()) {
284         auto scope = DECLARE_THROW_SCOPE(vm);
<a name="11" id="anc11"></a><span class="line-modified">285         const String&amp; wtfString = asString(value)-&gt;value(globalObject);</span>
286         RETURN_IF_EXCEPTION(scope, UINT_MAX);
287         return wtfString.impl()-&gt;hash();
288     }
289 
290     return wangsInt64Hash(JSValue::encode(value));
291 }
292 
293 ALWAYS_INLINE Optional&lt;uint32_t&gt; concurrentJSMapHash(JSValue key)
294 {
295     key = normalizeMapKey(key);
296     if (key.isString()) {
297         JSString* string = asString(key);
298         if (string-&gt;length() &gt; 10 * 1024)
299             return WTF::nullopt;
300         const StringImpl* impl = string-&gt;tryGetValueImpl();
301         if (!impl)
302             return WTF::nullopt;
303         return impl-&gt;concurrentHash();
304     }
305 
306     uint64_t rawValue = JSValue::encode(key);
307     return wangsInt64Hash(rawValue);
308 }
309 
310 ALWAYS_INLINE uint32_t shouldShrink(uint32_t capacity, uint32_t keyCount)
311 {
312     return 8 * keyCount &lt;= capacity &amp;&amp; capacity &gt; 4;
313 }
314 
315 ALWAYS_INLINE uint32_t shouldRehashAfterAdd(uint32_t capacity, uint32_t keyCount, uint32_t deleteCount)
316 {
317     return 2 * (keyCount + deleteCount) &gt;= capacity;
318 }
319 
320 ALWAYS_INLINE uint32_t nextCapacity(uint32_t capacity, uint32_t keyCount)
321 {
322     if (shouldShrink(capacity, keyCount)) {
323         ASSERT((capacity / 2) &gt;= 4);
324         return capacity / 2;
325     }
326 
327     if (3 * keyCount &lt;= capacity &amp;&amp; capacity &gt; 64) {
328         // We stay at the same size if rehashing would cause us to be no more than
329         // 1/3rd full. This comes up for programs like this:
330         // Say the hash table grew to a key count of 64, causing it to grow to a capacity of 256.
331         // Then, the table added 63 items. The load is now 127. Then, 63 items are deleted.
332         // The load is still 127. Then, another item is added. The load is now 128, and we
333         // decide that we need to rehash. The key count is 65, almost exactly what it was
334         // when we grew to a capacity of 256. We don&#39;t really need to grow to a capacity
335         // of 512 in this situation. Instead, we choose to rehash at the same size. This
336         // will bring the load down to 65. We rehash into the same size when we determine
337         // that the new load ratio will be under 1/3rd. (We also pick a minumum capacity
338         // at which this rule kicks in because otherwise we will be too sensitive to rehashing
339         // at the same capacity).
340         return capacity;
341     }
342     return (Checked&lt;uint32_t&gt;(capacity) * 2).unsafeGet();
343 }
344 
345 template &lt;typename HashMapBucketType&gt;
346 class HashMapImpl : public JSNonFinalObject {
347     using Base = JSNonFinalObject;
348     using HashMapBufferType = HashMapBuffer&lt;HashMapBucketType&gt;;
349 
350 public:
351     using BucketType = HashMapBucketType;
352 
353     static void visitChildren(JSCell*, SlotVisitor&amp;);
354 
355     static size_t estimatedSize(JSCell*, VM&amp;);
356 
357     HashMapImpl(VM&amp; vm, Structure* structure)
358         : Base(vm, structure)
359         , m_keyCount(0)
360         , m_deleteCount(0)
361         , m_capacity(4)
362     {
363     }
364 
365     HashMapImpl(VM&amp; vm, Structure* structure, uint32_t sizeHint)
366         : Base(vm, structure)
367         , m_keyCount(0)
368         , m_deleteCount(0)
369     {
370         uint32_t capacity = ((Checked&lt;uint32_t&gt;(sizeHint) * 2) + 1).unsafeGet();
371         capacity = std::max&lt;uint32_t&gt;(WTF::roundUpToPowerOfTwo(capacity), 4U);
372         m_capacity = capacity;
373     }
374 
375     ALWAYS_INLINE HashMapBucketType** buffer() const
376     {
377         return m_buffer-&gt;buffer();
378     }
379 
<a name="12" id="anc12"></a><span class="line-modified">380     void finishCreation(JSGlobalObject* globalObject, VM&amp; vm)</span>
381     {
382         ASSERT_WITH_MESSAGE(HashMapBucket&lt;HashMapBucketDataKey&gt;::offsetOfKey() == HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey(), &quot;We assume this to be true in the DFG and FTL JIT.&quot;);
383 
384         auto scope = DECLARE_THROW_SCOPE(vm);
385         Base::finishCreation(vm);
386 
<a name="13" id="anc13"></a><span class="line-modified">387         makeAndSetNewBuffer(globalObject, vm);</span>
388         RETURN_IF_EXCEPTION(scope, void());
389 
<a name="14" id="anc14"></a><span class="line-modified">390         setUpHeadAndTail(globalObject, vm);</span>
391     }
392 
<a name="15" id="anc15"></a><span class="line-modified">393     void finishCreation(JSGlobalObject* globalObject, VM&amp; vm, HashMapImpl* base)</span>
394     {
395         auto scope = DECLARE_THROW_SCOPE(vm);
396         Base::finishCreation(vm);
397 
398         // This size should be the same to the case when you clone the map by calling add() repeatedly.
399         uint32_t capacity = ((Checked&lt;uint32_t&gt;(base-&gt;m_keyCount) * 2) + 1).unsafeGet();
400         RELEASE_ASSERT(capacity &lt;= (1U &lt;&lt; 31));
401         capacity = std::max&lt;uint32_t&gt;(WTF::roundUpToPowerOfTwo(capacity), 4U);
402         m_capacity = capacity;
<a name="16" id="anc16"></a><span class="line-modified">403         makeAndSetNewBuffer(globalObject, vm);</span>
404         RETURN_IF_EXCEPTION(scope, void());
405 
<a name="17" id="anc17"></a><span class="line-modified">406         setUpHeadAndTail(globalObject, vm);</span>
407 
408         HashMapBucketType* bucket = base-&gt;m_head.get()-&gt;next();
409         while (bucket) {
410             if (!bucket-&gt;deleted()) {
<a name="18" id="anc18"></a><span class="line-modified">411                 addNormalizedNonExistingForCloning(globalObject, bucket-&gt;key(), HashMapBucketType::extractValue(*bucket));</span>
412                 RETURN_IF_EXCEPTION(scope, void());
413             }
414             bucket = bucket-&gt;next();
415         }
416         checkConsistency();
417     }
418 
419     static HashMapBucketType* emptyValue()
420     {
421         return bitwise_cast&lt;HashMapBucketType*&gt;(static_cast&lt;uintptr_t&gt;(-1));
422     }
423 
424     static ALWAYS_INLINE bool isEmpty(HashMapBucketType* bucket)
425     {
426         return bucket == emptyValue();
427     }
428 
429     static HashMapBucketType* deletedValue()
430     {
431         return bitwise_cast&lt;HashMapBucketType*&gt;(static_cast&lt;uintptr_t&gt;(-3));
432     }
433 
434     static ALWAYS_INLINE bool isDeleted(HashMapBucketType* bucket)
435     {
436         return bucket == deletedValue();
437     }
438 
<a name="19" id="anc19"></a><span class="line-modified">439     ALWAYS_INLINE HashMapBucketType** findBucket(JSGlobalObject* globalObject, JSValue key)</span>
440     {
<a name="20" id="anc20"></a><span class="line-modified">441         VM&amp; vm = getVM(globalObject);</span>
442         auto scope = DECLARE_THROW_SCOPE(vm);
443         key = normalizeMapKey(key);
<a name="21" id="anc21"></a><span class="line-modified">444         uint32_t hash = jsMapHash(globalObject, vm, key);</span>
445         RETURN_IF_EXCEPTION(scope, nullptr);
<a name="22" id="anc22"></a><span class="line-modified">446         return findBucket(globalObject, key, hash);</span>
447     }
448 
<a name="23" id="anc23"></a><span class="line-modified">449     ALWAYS_INLINE HashMapBucketType** findBucket(JSGlobalObject* globalObject, JSValue key, uint32_t hash)</span>
450     {
451         ASSERT_WITH_MESSAGE(normalizeMapKey(key) == key, &quot;We expect normalized values flowing into this function.&quot;);
<a name="24" id="anc24"></a><span class="line-modified">452         return findBucketAlreadyHashedAndNormalized(globalObject, key, hash);</span>
453     }
454 
455     template &lt;typename T = HashMapBucketType&gt;
<a name="25" id="anc25"></a><span class="line-modified">456     ALWAYS_INLINE typename std::enable_if&lt;std::is_same&lt;T, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;&gt;::value, JSValue&gt;::type get(JSGlobalObject* globalObject, JSValue key)</span>
457     {
<a name="26" id="anc26"></a><span class="line-modified">458         if (HashMapBucketType** bucket = findBucket(globalObject, key))</span>
459             return (*bucket)-&gt;value();
460         return jsUndefined();
461     }
462 
<a name="27" id="anc27"></a><span class="line-modified">463     ALWAYS_INLINE bool has(JSGlobalObject* globalObject, JSValue key)</span>
464     {
<a name="28" id="anc28"></a><span class="line-modified">465         return !!findBucket(globalObject, key);</span>
466     }
467 
<a name="29" id="anc29"></a><span class="line-modified">468     ALWAYS_INLINE void add(JSGlobalObject* globalObject, JSValue key, JSValue value = JSValue())</span>
469     {
470         key = normalizeMapKey(key);
<a name="30" id="anc30"></a><span class="line-modified">471         addNormalizedInternal(globalObject, key, value, [&amp;] (HashMapBucketType* bucket) {</span>
<span class="line-modified">472             return !isDeleted(bucket) &amp;&amp; areKeysEqual(globalObject, key, bucket-&gt;key());</span>
473         });
474         if (shouldRehashAfterAdd())
<a name="31" id="anc31"></a><span class="line-modified">475             rehash(globalObject);</span>
476     }
477 
<a name="32" id="anc32"></a><span class="line-modified">478     ALWAYS_INLINE HashMapBucketType* addNormalized(JSGlobalObject* globalObject, JSValue key, JSValue value, uint32_t hash)</span>
479     {
480         ASSERT_WITH_MESSAGE(normalizeMapKey(key) == key, &quot;We expect normalized values flowing into this function.&quot;);
<a name="33" id="anc33"></a><span class="line-modified">481         ASSERT_WITH_MESSAGE(jsMapHash(globalObject, getVM(globalObject), key) == hash, &quot;We expect hash value is what we expect.&quot;);</span>
482 
<a name="34" id="anc34"></a><span class="line-modified">483         auto* bucket = addNormalizedInternal(getVM(globalObject), key, value, hash, [&amp;] (HashMapBucketType* bucket) {</span>
<span class="line-modified">484             return !isDeleted(bucket) &amp;&amp; areKeysEqual(globalObject, key, bucket-&gt;key());</span>
485         });
486         if (shouldRehashAfterAdd())
<a name="35" id="anc35"></a><span class="line-modified">487             rehash(globalObject);</span>
488         return bucket;
489     }
490 
<a name="36" id="anc36"></a><span class="line-modified">491     ALWAYS_INLINE bool remove(JSGlobalObject* globalObject, JSValue key)</span>
492     {
<a name="37" id="anc37"></a><span class="line-modified">493         HashMapBucketType** bucket = findBucket(globalObject, key);</span>
494         if (!bucket)
495             return false;
496 
<a name="38" id="anc38"></a><span class="line-modified">497         VM&amp; vm = getVM(globalObject);</span>
498         HashMapBucketType* impl = *bucket;
499         impl-&gt;next()-&gt;setPrev(vm, impl-&gt;prev());
500         impl-&gt;prev()-&gt;setNext(vm, impl-&gt;next());
501         impl-&gt;makeDeleted(vm);
502 
503         *bucket = deletedValue();
504 
505         ++m_deleteCount;
506         ASSERT(m_keyCount &gt; 0);
507         --m_keyCount;
508 
509         if (shouldShrink())
<a name="39" id="anc39"></a><span class="line-modified">510             rehash(globalObject);</span>
511 
512         return true;
513     }
514 
515     ALWAYS_INLINE uint32_t size() const
516     {
517         return m_keyCount;
518     }
519 
<a name="40" id="anc40"></a><span class="line-modified">520     ALWAYS_INLINE void clear(JSGlobalObject* globalObject)</span>
521     {
<a name="41" id="anc41"></a><span class="line-modified">522         VM&amp; vm = getVM(globalObject);</span>
523         m_keyCount = 0;
524         m_deleteCount = 0;
525         HashMapBucketType* head = m_head.get();
526         HashMapBucketType* bucket = m_head-&gt;next();
527         HashMapBucketType* tail = m_tail.get();
528         while (bucket != tail) {
529             HashMapBucketType* next = bucket-&gt;next();
530             // We restart each iterator by pointing it to the head of the list.
531             bucket-&gt;setNext(vm, head);
532             bucket-&gt;makeDeleted(vm);
533             bucket = next;
534         }
535         m_head-&gt;setNext(vm, m_tail.get());
536         m_tail-&gt;setPrev(vm, m_head.get());
537         m_capacity = 4;
<a name="42" id="anc42"></a><span class="line-modified">538         makeAndSetNewBuffer(globalObject, vm);</span>
539         checkConsistency();
540     }
541 
542     ALWAYS_INLINE size_t bufferSizeInBytes() const
543     {
544         return m_capacity * sizeof(HashMapBucketType*);
545     }
546 
547     static ptrdiff_t offsetOfHead()
548     {
549         return OBJECT_OFFSETOF(HashMapImpl&lt;HashMapBucketType&gt;, m_head);
550     }
551 
552     static ptrdiff_t offsetOfBuffer()
553     {
554         return OBJECT_OFFSETOF(HashMapImpl&lt;HashMapBucketType&gt;, m_buffer);
555     }
556 
557     static ptrdiff_t offsetOfCapacity()
558     {
559         return OBJECT_OFFSETOF(HashMapImpl&lt;HashMapBucketType&gt;, m_capacity);
560     }
561 
562     HashMapBucketType* head() { return m_head.get(); }
563     HashMapBucketType* tail() { return m_tail.get(); }
564 
565     size_t approximateSize() const
566     {
567         size_t size = sizeof(HashMapImpl);
568         size += bufferSizeInBytes();
569         size += 2 * sizeof(HashMapBucketType); // Head and tail members.
570         size += m_keyCount * sizeof(HashMapBucketType); // Number of members that are on the list.
571         return size;
572     }
573 
574 private:
575     ALWAYS_INLINE uint32_t shouldRehashAfterAdd() const
576     {
577         return JSC::shouldRehashAfterAdd(m_capacity, m_keyCount, m_deleteCount);
578     }
579 
580     ALWAYS_INLINE uint32_t shouldShrink() const
581     {
582         return JSC::shouldShrink(m_capacity, m_keyCount);
583     }
584 
<a name="43" id="anc43"></a><span class="line-modified">585     ALWAYS_INLINE void setUpHeadAndTail(JSGlobalObject*, VM&amp; vm)</span>
586     {
587         m_head.set(vm, this, HashMapBucketType::create(vm));
588         m_tail.set(vm, this, HashMapBucketType::create(vm));
589 
590         m_head-&gt;setNext(vm, m_tail.get());
591         m_tail-&gt;setPrev(vm, m_head.get());
592         ASSERT(m_head-&gt;deleted());
593         ASSERT(m_tail-&gt;deleted());
594     }
595 
<a name="44" id="anc44"></a><span class="line-modified">596     ALWAYS_INLINE void addNormalizedNonExistingForCloning(JSGlobalObject* globalObject, JSValue key, JSValue value = JSValue())</span>
597     {
<a name="45" id="anc45"></a><span class="line-modified">598         addNormalizedInternal(globalObject, key, value, [&amp;] (HashMapBucketType*) {</span>
599             return false;
600         });
601     }
602 
603     template&lt;typename CanUseBucket&gt;
<a name="46" id="anc46"></a><span class="line-modified">604     ALWAYS_INLINE void addNormalizedInternal(JSGlobalObject* globalObject, JSValue key, JSValue value, const CanUseBucket&amp; canUseBucket)</span>
605     {
<a name="47" id="anc47"></a><span class="line-modified">606         VM&amp; vm = getVM(globalObject);</span>
607         auto scope = DECLARE_THROW_SCOPE(vm);
608 
<a name="48" id="anc48"></a><span class="line-modified">609         uint32_t hash = jsMapHash(globalObject, vm, key);</span>
610         RETURN_IF_EXCEPTION(scope, void());
611         scope.release();
612         addNormalizedInternal(vm, key, value, hash, canUseBucket);
613     }
614 
615     template&lt;typename CanUseBucket&gt;
616     ALWAYS_INLINE HashMapBucketType* addNormalizedInternal(VM&amp; vm, JSValue key, JSValue value, uint32_t hash, const CanUseBucket&amp; canUseBucket)
617     {
618         ASSERT_WITH_MESSAGE(normalizeMapKey(key) == key, &quot;We expect normalized values flowing into this function.&quot;);
619 
620         const uint32_t mask = m_capacity - 1;
621         uint32_t index = hash &amp; mask;
622         HashMapBucketType** buffer = this-&gt;buffer();
623         HashMapBucketType* bucket = buffer[index];
624         while (!isEmpty(bucket)) {
625             if (canUseBucket(bucket)) {
626                 bucket-&gt;setValue(vm, value);
627                 return bucket;
628             }
629             index = (index + 1) &amp; mask;
630             bucket = buffer[index];
631         }
632 
633         HashMapBucketType* newEntry = m_tail.get();
634         buffer[index] = newEntry;
635         newEntry-&gt;setKey(vm, key);
636         newEntry-&gt;setValue(vm, value);
637         ASSERT(!newEntry-&gt;deleted());
638         HashMapBucketType* newTail = HashMapBucketType::create(vm);
639         m_tail.set(vm, this, newTail);
640         newTail-&gt;setPrev(vm, newEntry);
641         ASSERT(newTail-&gt;deleted());
642         newEntry-&gt;setNext(vm, newTail);
643 
644         ++m_keyCount;
645         return newEntry;
646     }
647 
<a name="49" id="anc49"></a><span class="line-modified">648     ALWAYS_INLINE HashMapBucketType** findBucketAlreadyHashedAndNormalized(JSGlobalObject* globalObject, JSValue key, uint32_t hash)</span>
649     {
650         const uint32_t mask = m_capacity - 1;
651         uint32_t index = hash &amp; mask;
652         HashMapBucketType** buffer = this-&gt;buffer();
653         HashMapBucketType* bucket = buffer[index];
654 
655         while (!isEmpty(bucket)) {
<a name="50" id="anc50"></a><span class="line-modified">656             if (!isDeleted(bucket) &amp;&amp; areKeysEqual(globalObject, key, bucket-&gt;key()))</span>
657                 return buffer + index;
658             index = (index + 1) &amp; mask;
659             bucket = buffer[index];
660         }
661         return nullptr;
662     }
663 
<a name="51" id="anc51"></a><span class="line-modified">664     void rehash(JSGlobalObject* globalObject)</span>
665     {
<a name="52" id="anc52"></a><span class="line-modified">666         VM&amp; vm = getVM(globalObject);</span>
667         auto scope = DECLARE_THROW_SCOPE(vm);
668 
669         uint32_t oldCapacity = m_capacity;
670         m_capacity = nextCapacity(m_capacity, m_keyCount);
671 
672         if (m_capacity != oldCapacity) {
<a name="53" id="anc53"></a><span class="line-modified">673             makeAndSetNewBuffer(globalObject, vm);</span>
674             RETURN_IF_EXCEPTION(scope, void());
675         } else {
676             m_buffer-&gt;reset(m_capacity);
677             assertBufferIsEmpty();
678         }
679 
680         HashMapBucketType* iter = m_head-&gt;next();
681         HashMapBucketType* end = m_tail.get();
682         const uint32_t mask = m_capacity - 1;
683         RELEASE_ASSERT(!(m_capacity &amp; (m_capacity - 1)));
684         HashMapBucketType** buffer = this-&gt;buffer();
685         while (iter != end) {
<a name="54" id="anc54"></a><span class="line-modified">686             uint32_t index = jsMapHash(globalObject, vm, iter-&gt;key()) &amp; mask;</span>
687             EXCEPTION_ASSERT_WITH_MESSAGE(!scope.exception(), &quot;All keys should already be hashed before, so this should not throw because it won&#39;t resolve ropes.&quot;);
688             {
689                 HashMapBucketType* bucket = buffer[index];
690                 while (!isEmpty(bucket)) {
691                     index = (index + 1) &amp; mask;
692                     bucket = buffer[index];
693                 }
694             }
695             buffer[index] = iter;
696             iter = iter-&gt;next();
697         }
698 
699         m_deleteCount = 0;
700 
701         checkConsistency();
702     }
703 
704     ALWAYS_INLINE void checkConsistency() const
705     {
<a name="55" id="anc55"></a><span class="line-modified">706         if (ASSERT_ENABLED) {</span>
707             HashMapBucketType* iter = m_head-&gt;next();
708             HashMapBucketType* end = m_tail.get();
709             uint32_t size = 0;
710             while (iter != end) {
711                 ++size;
712                 iter = iter-&gt;next();
713             }
714             ASSERT(size == m_keyCount);
715         }
716     }
717 
<a name="56" id="anc56"></a><span class="line-modified">718     void makeAndSetNewBuffer(JSGlobalObject* globalObject, VM&amp; vm)</span>
719     {
720         ASSERT(!(m_capacity &amp; (m_capacity - 1)));
721 
<a name="57" id="anc57"></a><span class="line-modified">722         HashMapBufferType* buffer = HashMapBufferType::create(globalObject, vm, this, m_capacity);</span>
723         if (UNLIKELY(!buffer))
724             return;
725 
726         m_buffer.set(vm, this, buffer);
727         assertBufferIsEmpty();
728     }
729 
730     ALWAYS_INLINE void assertBufferIsEmpty() const
731     {
<a name="58" id="anc58"></a><span class="line-modified">732         if (ASSERT_ENABLED) {</span>
733             for (unsigned i = 0; i &lt; m_capacity; i++)
734                 ASSERT(isEmpty(buffer()[i]));
735         }
736     }
737 
738     WriteBarrier&lt;HashMapBucketType&gt; m_head;
739     WriteBarrier&lt;HashMapBucketType&gt; m_tail;
740     AuxiliaryBarrier&lt;HashMapBufferType*&gt; m_buffer;
741     uint32_t m_keyCount;
742     uint32_t m_deleteCount;
743     uint32_t m_capacity;
744 };
745 
746 } // namespace JSC
<a name="59" id="anc59"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="59" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/pictureinpicture/HTMLVideoElementPictureInPicture.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Carlos Eduardo Ramalho &lt;cadubentzen@gmail.com&gt;.
  3  * Copyright (C) 2019 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 15  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 16  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 18  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 19  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 21  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 22  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 23  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 24  * THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;HTMLVideoElementPictureInPicture.h&quot;
 29 
 30 #if ENABLE(PICTURE_IN_PICTURE_API)
 31 
 32 #include &quot;EventNames.h&quot;
 33 #include &quot;HTMLVideoElement.h&quot;
 34 #include &quot;JSDOMPromiseDeferred.h&quot;
 35 #include &quot;JSPictureInPictureWindow.h&quot;
 36 #include &quot;Logging.h&quot;
 37 #include &quot;PictureInPictureSupport.h&quot;
 38 #include &quot;PictureInPictureWindow.h&quot;
 39 #include &quot;VideoTrackList.h&quot;
 40 #include &lt;wtf/IsoMallocInlines.h&gt;
 41 
 42 namespace WebCore {
 43 
 44 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLVideoElementPictureInPicture);
 45 
 46 HTMLVideoElementPictureInPicture::HTMLVideoElementPictureInPicture(HTMLVideoElement&amp; videoElement)
 47     : m_videoElement(videoElement)
 48     , m_pictureInPictureWindow(PictureInPictureWindow::create(videoElement.document()))
 49 #if !RELEASE_LOG_DISABLED
 50     , m_logger(videoElement.document().logger())
 51     , m_logIdentifier(uniqueLogIdentifier())
 52 #endif
 53 {
 54     ALWAYS_LOG(LOGIDENTIFIER);
 55     m_videoElement.setPictureInPictureObserver(this);
 56 }
 57 
 58 HTMLVideoElementPictureInPicture::~HTMLVideoElementPictureInPicture()
 59 {
 60     ALWAYS_LOG(LOGIDENTIFIER);
 61     m_videoElement.setPictureInPictureObserver(nullptr);
 62 }
 63 
 64 HTMLVideoElementPictureInPicture* HTMLVideoElementPictureInPicture::from(HTMLVideoElement&amp; videoElement)
 65 {
 66     HTMLVideoElementPictureInPicture* supplement = static_cast&lt;HTMLVideoElementPictureInPicture*&gt;(Supplement&lt;HTMLVideoElement&gt;::from(&amp;videoElement, supplementName()));
 67     if (!supplement) {
 68         auto newSupplement = makeUnique&lt;HTMLVideoElementPictureInPicture&gt;(videoElement);
 69         supplement = newSupplement.get();
 70         provideTo(&amp;videoElement, supplementName(), WTFMove(newSupplement));
 71     }
 72     return supplement;
 73 }
 74 
 75 void HTMLVideoElementPictureInPicture::providePictureInPictureTo(HTMLVideoElement&amp; videoElement)
 76 {
 77     provideTo(&amp;videoElement, supplementName(), makeUnique&lt;HTMLVideoElementPictureInPicture&gt;(videoElement));
 78 }
 79 
 80 void HTMLVideoElementPictureInPicture::requestPictureInPicture(HTMLVideoElement&amp; videoElement, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
 81 {
 82     if (!supportsPictureInPicture()) {
 83         promise-&gt;reject(NotSupportedError, &quot;The Picture-in-Picture mode is not supported.&quot;);
 84         return;
 85     }
 86 
 87     if (videoElement.readyState() == HTMLMediaElementEnums::HAVE_NOTHING) {
 88         promise-&gt;reject(InvalidStateError, &quot;The video element is not ready to enter the Picture-in-Picture mode.&quot;);
 89         return;
 90     }
 91 
 92 #if ENABLE(VIDEO_TRACK)
 93     if (!videoElement.videoTracks() || !videoElement.videoTracks()-&gt;length()) {
 94         promise-&gt;reject(InvalidStateError, &quot;The video element does not have a video track or it has not detected a video track yet.&quot;);
 95         return;
 96     }
 97 #endif
 98 
 99     bool userActivationRequired = !videoElement.document().pictureInPictureElement();
100     if (userActivationRequired &amp;&amp; !UserGestureIndicator::processingUserGesture()) {
101         promise-&gt;reject(NotAllowedError, &quot;The request is not triggered by a user activation.&quot;);
102         return;
103     }
104 
105     auto videoElementPictureInPicture = HTMLVideoElementPictureInPicture::from(videoElement);
106     if (videoElement.document().pictureInPictureElement() == &amp;videoElement) {
107         promise-&gt;resolve&lt;IDLInterface&lt;PictureInPictureWindow&gt;&gt;(*(videoElementPictureInPicture-&gt;m_pictureInPictureWindow));
108         return;
109     }
110 
111     if (videoElementPictureInPicture-&gt;m_enterPictureInPicturePromise || videoElementPictureInPicture-&gt;m_exitPictureInPicturePromise) {
112         promise-&gt;reject(NotAllowedError, &quot;The video element is processing a Picture-in-Picture request.&quot;);
113         return;
114     }
115 
116     if (videoElement.webkitSupportsPresentationMode(HTMLVideoElement::VideoPresentationMode::PictureInPicture)) {
117         videoElementPictureInPicture-&gt;m_enterPictureInPicturePromise = WTFMove(promise);
118         videoElement.webkitSetPresentationMode(HTMLVideoElement::VideoPresentationMode::PictureInPicture);
119     } else
120         promise-&gt;reject(NotSupportedError, &quot;The video element does not support the Picture-in-Picture mode.&quot;);
121 }
122 
123 bool HTMLVideoElementPictureInPicture::autoPictureInPicture(HTMLVideoElement&amp; videoElement)
124 {
125     return HTMLVideoElementPictureInPicture::from(videoElement)-&gt;m_autoPictureInPicture;
126 }
127 
128 void HTMLVideoElementPictureInPicture::setAutoPictureInPicture(HTMLVideoElement&amp; videoElement, bool autoPictureInPicture)
129 {
130     HTMLVideoElementPictureInPicture::from(videoElement)-&gt;m_autoPictureInPicture = autoPictureInPicture;
131 }
132 
133 bool HTMLVideoElementPictureInPicture::disablePictureInPicture(HTMLVideoElement&amp; videoElement)
134 {
135     return HTMLVideoElementPictureInPicture::from(videoElement)-&gt;m_disablePictureInPicture;
136 }
137 
138 void HTMLVideoElementPictureInPicture::setDisablePictureInPicture(HTMLVideoElement&amp; videoElement, bool disablePictureInPicture)
139 {
140     HTMLVideoElementPictureInPicture::from(videoElement)-&gt;m_disablePictureInPicture = disablePictureInPicture;
141 }
142 
143 void HTMLVideoElementPictureInPicture::exitPictureInPicture(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
144 {
145     INFO_LOG(LOGIDENTIFIER);
146     if (m_enterPictureInPicturePromise || m_exitPictureInPicturePromise) {
147         promise-&gt;reject(NotAllowedError);
148         return;
149     }
150 
151     m_exitPictureInPicturePromise = WTFMove(promise);
152     m_videoElement.webkitSetPresentationMode(HTMLVideoElement::VideoPresentationMode::Inline);
153 }
154 
155 void HTMLVideoElementPictureInPicture::didEnterPictureInPicture(const IntSize&amp; windowSize)
156 {
157     INFO_LOG(LOGIDENTIFIER);
158     m_videoElement.invalidateStyle();
159     m_videoElement.document().setPictureInPictureElement(&amp;m_videoElement);
160     m_pictureInPictureWindow-&gt;setSize(windowSize);
161 
162     EnterPictureInPictureEvent::Init initializer;
163     initializer.bubbles = true;
164     initializer.pictureInPictureWindow = m_pictureInPictureWindow;
165     m_videoElement.scheduleEvent(EnterPictureInPictureEvent::create(eventNames().enterpictureinpictureEvent, WTFMove(initializer)));
166 
167     if (m_enterPictureInPicturePromise) {
168         m_enterPictureInPicturePromise-&gt;resolve&lt;IDLInterface&lt;PictureInPictureWindow&gt;&gt;(*m_pictureInPictureWindow);
169         m_enterPictureInPicturePromise = nullptr;
170     }
171 }
172 
173 void HTMLVideoElementPictureInPicture::didExitPictureInPicture()
174 {
175     INFO_LOG(LOGIDENTIFIER);
176     m_videoElement.invalidateStyle();
177     m_pictureInPictureWindow-&gt;close();
178     m_videoElement.document().setPictureInPictureElement(nullptr);
179     m_videoElement.scheduleEvent(Event::create(eventNames().leavepictureinpictureEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
180 
181     if (m_exitPictureInPicturePromise) {
182         m_exitPictureInPicturePromise-&gt;resolve();
183         m_exitPictureInPicturePromise = nullptr;
184     }
185 }
186 
187 void HTMLVideoElementPictureInPicture::pictureInPictureWindowResized(const IntSize&amp; windowSize)
188 {
189     if (m_pictureInPictureWindow-&gt;width() == windowSize.width() &amp;&amp; m_pictureInPictureWindow-&gt;height() == windowSize.height())
190         return;
191 
192     m_pictureInPictureWindow-&gt;setSize(windowSize);
193     auto resizeEvent = Event::create(eventNames().resizeEvent, Event::CanBubble::Yes, Event::IsCancelable::No);
194     resizeEvent-&gt;setTarget(m_pictureInPictureWindow);
195     m_videoElement.scheduleEvent(WTFMove(resizeEvent));
196 }
197 
198 #if !RELEASE_LOG_DISABLED
199 WTFLogChannel&amp; HTMLVideoElementPictureInPicture::logChannel() const
200 {
201     return LogMedia;
202 }
203 #endif
204 
205 } // namespace WebCore
206 
207 #endif // ENABLE(PICTURE_IN_PICTURE_API)
    </pre>
  </body>
</html>
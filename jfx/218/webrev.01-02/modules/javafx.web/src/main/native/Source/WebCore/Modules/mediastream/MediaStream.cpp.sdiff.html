<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/MediaStream.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MediaDevices.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaStream.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/MediaStream.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 62     return adoptRef(*new MediaStream(document, tracks));
 63 }
 64 
 65 Ref&lt;MediaStream&gt; MediaStream::create(Document&amp; document, Ref&lt;MediaStreamPrivate&gt;&amp;&amp; streamPrivate)
 66 {
 67     return adoptRef(*new MediaStream(document, WTFMove(streamPrivate)));
 68 }
 69 
 70 static inline MediaStreamTrackPrivateVector createTrackPrivateVector(const MediaStreamTrackVector&amp; tracks)
 71 {
 72     MediaStreamTrackPrivateVector trackPrivates;
 73     trackPrivates.reserveCapacity(tracks.size());
 74     for (auto&amp; track : tracks)
 75         trackPrivates.append(&amp;track-&gt;privateTrack());
 76     return trackPrivates;
 77 }
 78 
 79 MediaStream::MediaStream(Document&amp; document, const MediaStreamTrackVector&amp; tracks)
 80     : ActiveDOMObject(document)
 81     , m_private(MediaStreamPrivate::create(document.logger(), createTrackPrivateVector(tracks)))
<span class="line-removed"> 82     , m_mediaSession(PlatformMediaSession::create(*this))</span>
 83 {
 84     // This constructor preserves MediaStreamTrack instances and must be used by calls originating
 85     // from the JavaScript MediaStream constructor.
 86 
 87     for (auto&amp; track : tracks) {
 88         track-&gt;addObserver(*this);
 89         m_trackSet.add(track-&gt;id(), track);
 90     }
 91 
 92     setIsActive(m_private-&gt;active());
 93     m_private-&gt;addObserver(*this);
 94     suspendIfNeeded();
 95 }
 96 
 97 MediaStream::MediaStream(Document&amp; document, Ref&lt;MediaStreamPrivate&gt;&amp;&amp; streamPrivate)
 98     : ActiveDOMObject(document)
 99     , m_private(WTFMove(streamPrivate))
<span class="line-removed">100     , m_mediaSession(PlatformMediaSession::create(*this))</span>
101 {
102     ALWAYS_LOG(LOGIDENTIFIER);
103 
<span class="line-removed">104     setIsActive(m_private-&gt;active());</span>
<span class="line-removed">105     m_private-&gt;addObserver(*this);</span>
<span class="line-removed">106 </span>
107     for (auto&amp; trackPrivate : m_private-&gt;tracks()) {
108         auto track = MediaStreamTrack::create(document, *trackPrivate);
109         track-&gt;addObserver(*this);
110         m_trackSet.add(track-&gt;id(), WTFMove(track));
111     }



112     suspendIfNeeded();
113 }
114 
115 MediaStream::~MediaStream()
116 {
117     // Set isActive to false immediately so any callbacks triggered by shutting down, e.g.
118     // mediaState(), are short circuited.
119     m_isActive = false;
120     m_private-&gt;removeObserver(*this);
121     for (auto&amp; track : m_trackSet.values())
122         track-&gt;removeObserver(*this);
123     if (Document* document = this-&gt;document()) {
124         if (m_isWaitingUntilMediaCanStart)
125             document-&gt;removeMediaCanStartListener(*this);
126     }
127 }
128 
129 RefPtr&lt;MediaStream&gt; MediaStream::clone()
130 {
131     ALWAYS_LOG(LOGIDENTIFIER);
</pre>
<hr />
<pre>
285     Document* document = this-&gt;document();
286     if (!document || !document-&gt;page())
287         return;
288 
289     ALWAYS_LOG(LOGIDENTIFIER);
290 
291     // If we can&#39;t start a load right away, start it later.
292     if (!document-&gt;page()-&gt;canStartMedia()) {
293         ALWAYS_LOG(LOGIDENTIFIER, &quot;not allowed to start in background, waiting&quot;);
294         if (m_isWaitingUntilMediaCanStart)
295             return;
296 
297         m_isWaitingUntilMediaCanStart = true;
298         document-&gt;addMediaCanStartListener(*this);
299         return;
300     }
301 
302     if (m_isProducingData)
303         return;
304     m_isProducingData = true;
<span class="line-removed">305 </span>
<span class="line-removed">306     m_mediaSession-&gt;canProduceAudioChanged();</span>
307     m_private-&gt;startProducingData();
308 }
309 
310 void MediaStream::stopProducingData()
311 {


312     if (!m_isProducingData)
313         return;
314 
<span class="line-removed">315     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-removed">316 </span>
317     m_isProducingData = false;
<span class="line-removed">318 </span>
<span class="line-removed">319     m_mediaSession-&gt;canProduceAudioChanged();</span>
<span class="line-removed">320 </span>
321     m_private-&gt;stopProducingData();
322 }
323 
324 MediaProducer::MediaStateFlags MediaStream::mediaState() const
325 {
326     MediaProducer::MediaStateFlags state = MediaProducer::IsNotPlaying;
327 
328     if (!m_isActive || !document() || !document()-&gt;page())
329         return state;
330 
331     for (const auto&amp; track : m_trackSet.values())
332         state |= track-&gt;mediaState();
333 
334     return state;
335 }
336 
337 void MediaStream::statusDidChange()
338 {
<span class="line-modified">339     m_mediaSession-&gt;canProduceAudioChanged();</span>
<span class="line-removed">340 </span>
<span class="line-removed">341     if (Document* document = this-&gt;document()) {</span>
342         if (!m_isActive)
343             return;
344         document-&gt;updateIsPlayingMedia();
345     }
346 }
347 
348 void MediaStream::characteristicsChanged()
349 {
350     auto state = mediaState();
351     if (m_state != state) {
352         m_state = state;
353         statusDidChange();
354     }
355 }
356 
357 void MediaStream::updateActiveState()
358 {
359     bool active = false;
360     for (auto&amp; track : m_trackSet.values()) {
361         if (!track-&gt;ended()) {
</pre>
<hr />
<pre>
382 }
383 
384 void MediaStream::addObserver(MediaStream::Observer* observer)
385 {
386     if (m_observers.find(observer) == notFound)
387         m_observers.append(observer);
388 }
389 
390 void MediaStream::removeObserver(MediaStream::Observer* observer)
391 {
392     size_t pos = m_observers.find(observer);
393     if (pos != notFound)
394         m_observers.remove(pos);
395 }
396 
397 Document* MediaStream::document() const
398 {
399     return downcast&lt;Document&gt;(scriptExecutionContext());
400 }
401 
<span class="line-removed">402 PlatformMediaSession::MediaType MediaStream::mediaType() const</span>
<span class="line-removed">403 {</span>
<span class="line-removed">404     // We only need to override the type when capturing audio, HTMLMediaElement and/or WebAudio</span>
<span class="line-removed">405     // will do the right thing when a stream is attached to a media element or an audio context.</span>
<span class="line-removed">406     if (m_private-&gt;hasAudio() &amp;&amp; m_isProducingData &amp;&amp; m_private-&gt;hasCaptureAudioSource())</span>
<span class="line-removed">407         return PlatformMediaSession::MediaStreamCapturingAudio;</span>
<span class="line-removed">408 </span>
<span class="line-removed">409     return PlatformMediaSession::None;</span>
<span class="line-removed">410 }</span>
<span class="line-removed">411 </span>
<span class="line-removed">412 PlatformMediaSession::MediaType MediaStream::presentationType() const</span>
<span class="line-removed">413 {</span>
<span class="line-removed">414     return mediaType();</span>
<span class="line-removed">415 }</span>
<span class="line-removed">416 </span>
<span class="line-removed">417 PlatformMediaSession::CharacteristicsFlags MediaStream::characteristics() const</span>
<span class="line-removed">418 {</span>
<span class="line-removed">419     PlatformMediaSession::CharacteristicsFlags state = PlatformMediaSession::HasNothing;</span>
<span class="line-removed">420 </span>
<span class="line-removed">421     if (!m_isProducingData)</span>
<span class="line-removed">422         return state;</span>
<span class="line-removed">423 </span>
<span class="line-removed">424     if (m_private-&gt;hasAudio())</span>
<span class="line-removed">425         state |= PlatformMediaSession::HasAudio;</span>
<span class="line-removed">426 </span>
<span class="line-removed">427     if (m_private-&gt;hasVideo())</span>
<span class="line-removed">428         state |= PlatformMediaSession::HasVideo;</span>
<span class="line-removed">429 </span>
<span class="line-removed">430     return state;</span>
<span class="line-removed">431 }</span>
<span class="line-removed">432 </span>
<span class="line-removed">433 void MediaStream::mayResumePlayback(bool)</span>
<span class="line-removed">434 {</span>
<span class="line-removed">435     // FIXME: should a media stream pay attention to this directly, or only when attached to a media element?</span>
<span class="line-removed">436 }</span>
<span class="line-removed">437 </span>
<span class="line-removed">438 void MediaStream::suspendPlayback()</span>
<span class="line-removed">439 {</span>
<span class="line-removed">440     // FIXME: should a media stream pay attention to this directly, or only when attached to a media element?</span>
<span class="line-removed">441 }</span>
<span class="line-removed">442 </span>
<span class="line-removed">443 String MediaStream::sourceApplicationIdentifier() const</span>
<span class="line-removed">444 {</span>
<span class="line-removed">445     Document* document = this-&gt;document();</span>
<span class="line-removed">446     if (document &amp;&amp; document-&gt;frame()) {</span>
<span class="line-removed">447         if (NetworkingContext* networkingContext = document-&gt;frame()-&gt;loader().networkingContext())</span>
<span class="line-removed">448             return networkingContext-&gt;sourceApplicationIdentifier();</span>
<span class="line-removed">449     }</span>
<span class="line-removed">450 </span>
<span class="line-removed">451     return emptyString();</span>
<span class="line-removed">452 }</span>
<span class="line-removed">453 </span>
<span class="line-removed">454 bool MediaStream::canProduceAudio() const</span>
<span class="line-removed">455 {</span>
<span class="line-removed">456     return !muted() &amp;&amp; active() &amp;&amp; m_private-&gt;hasAudio() &amp;&amp; m_isProducingData;</span>
<span class="line-removed">457 }</span>
<span class="line-removed">458 </span>
<span class="line-removed">459 bool MediaStream::processingUserGestureForMedia() const</span>
<span class="line-removed">460 {</span>
<span class="line-removed">461     return document() ? document()-&gt;processingUserGestureForMedia() : false;</span>
<span class="line-removed">462 }</span>
<span class="line-removed">463 </span>
464 void MediaStream::stop()
465 {
466     m_isActive = false;
467 }
468 
469 const char* MediaStream::activeDOMObjectName() const
470 {
471     return &quot;MediaStream&quot;;
472 }
473 
<span class="line-removed">474 bool MediaStream::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">475 {</span>
<span class="line-removed">476     return !hasPendingActivity();</span>
<span class="line-removed">477 }</span>
<span class="line-removed">478 </span>
479 bool MediaStream::hasPendingActivity() const
480 {
481     return m_isActive;
482 }
483 
484 #if !RELEASE_LOG_DISABLED
485 WTFLogChannel&amp; MediaStream::logChannel() const
486 {
487     return LogWebRTC;
488 }
489 #endif
490 
491 } // namespace WebCore
492 
493 #endif // ENABLE(MEDIA_STREAM)
</pre>
</td>
<td>
<hr />
<pre>
 62     return adoptRef(*new MediaStream(document, tracks));
 63 }
 64 
 65 Ref&lt;MediaStream&gt; MediaStream::create(Document&amp; document, Ref&lt;MediaStreamPrivate&gt;&amp;&amp; streamPrivate)
 66 {
 67     return adoptRef(*new MediaStream(document, WTFMove(streamPrivate)));
 68 }
 69 
 70 static inline MediaStreamTrackPrivateVector createTrackPrivateVector(const MediaStreamTrackVector&amp; tracks)
 71 {
 72     MediaStreamTrackPrivateVector trackPrivates;
 73     trackPrivates.reserveCapacity(tracks.size());
 74     for (auto&amp; track : tracks)
 75         trackPrivates.append(&amp;track-&gt;privateTrack());
 76     return trackPrivates;
 77 }
 78 
 79 MediaStream::MediaStream(Document&amp; document, const MediaStreamTrackVector&amp; tracks)
 80     : ActiveDOMObject(document)
 81     , m_private(MediaStreamPrivate::create(document.logger(), createTrackPrivateVector(tracks)))

 82 {
 83     // This constructor preserves MediaStreamTrack instances and must be used by calls originating
 84     // from the JavaScript MediaStream constructor.
 85 
 86     for (auto&amp; track : tracks) {
 87         track-&gt;addObserver(*this);
 88         m_trackSet.add(track-&gt;id(), track);
 89     }
 90 
 91     setIsActive(m_private-&gt;active());
 92     m_private-&gt;addObserver(*this);
 93     suspendIfNeeded();
 94 }
 95 
 96 MediaStream::MediaStream(Document&amp; document, Ref&lt;MediaStreamPrivate&gt;&amp;&amp; streamPrivate)
 97     : ActiveDOMObject(document)
 98     , m_private(WTFMove(streamPrivate))

 99 {
100     ALWAYS_LOG(LOGIDENTIFIER);
101 



102     for (auto&amp; trackPrivate : m_private-&gt;tracks()) {
103         auto track = MediaStreamTrack::create(document, *trackPrivate);
104         track-&gt;addObserver(*this);
105         m_trackSet.add(track-&gt;id(), WTFMove(track));
106     }
<span class="line-added">107 </span>
<span class="line-added">108     setIsActive(m_private-&gt;active());</span>
<span class="line-added">109     m_private-&gt;addObserver(*this);</span>
110     suspendIfNeeded();
111 }
112 
113 MediaStream::~MediaStream()
114 {
115     // Set isActive to false immediately so any callbacks triggered by shutting down, e.g.
116     // mediaState(), are short circuited.
117     m_isActive = false;
118     m_private-&gt;removeObserver(*this);
119     for (auto&amp; track : m_trackSet.values())
120         track-&gt;removeObserver(*this);
121     if (Document* document = this-&gt;document()) {
122         if (m_isWaitingUntilMediaCanStart)
123             document-&gt;removeMediaCanStartListener(*this);
124     }
125 }
126 
127 RefPtr&lt;MediaStream&gt; MediaStream::clone()
128 {
129     ALWAYS_LOG(LOGIDENTIFIER);
</pre>
<hr />
<pre>
283     Document* document = this-&gt;document();
284     if (!document || !document-&gt;page())
285         return;
286 
287     ALWAYS_LOG(LOGIDENTIFIER);
288 
289     // If we can&#39;t start a load right away, start it later.
290     if (!document-&gt;page()-&gt;canStartMedia()) {
291         ALWAYS_LOG(LOGIDENTIFIER, &quot;not allowed to start in background, waiting&quot;);
292         if (m_isWaitingUntilMediaCanStart)
293             return;
294 
295         m_isWaitingUntilMediaCanStart = true;
296         document-&gt;addMediaCanStartListener(*this);
297         return;
298     }
299 
300     if (m_isProducingData)
301         return;
302     m_isProducingData = true;


303     m_private-&gt;startProducingData();
304 }
305 
306 void MediaStream::stopProducingData()
307 {
<span class="line-added">308     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">309 </span>
310     if (!m_isProducingData)
311         return;
312 


313     m_isProducingData = false;



314     m_private-&gt;stopProducingData();
315 }
316 
317 MediaProducer::MediaStateFlags MediaStream::mediaState() const
318 {
319     MediaProducer::MediaStateFlags state = MediaProducer::IsNotPlaying;
320 
321     if (!m_isActive || !document() || !document()-&gt;page())
322         return state;
323 
324     for (const auto&amp; track : m_trackSet.values())
325         state |= track-&gt;mediaState();
326 
327     return state;
328 }
329 
330 void MediaStream::statusDidChange()
331 {
<span class="line-modified">332     if (auto* document = this-&gt;document()) {</span>


333         if (!m_isActive)
334             return;
335         document-&gt;updateIsPlayingMedia();
336     }
337 }
338 
339 void MediaStream::characteristicsChanged()
340 {
341     auto state = mediaState();
342     if (m_state != state) {
343         m_state = state;
344         statusDidChange();
345     }
346 }
347 
348 void MediaStream::updateActiveState()
349 {
350     bool active = false;
351     for (auto&amp; track : m_trackSet.values()) {
352         if (!track-&gt;ended()) {
</pre>
<hr />
<pre>
373 }
374 
375 void MediaStream::addObserver(MediaStream::Observer* observer)
376 {
377     if (m_observers.find(observer) == notFound)
378         m_observers.append(observer);
379 }
380 
381 void MediaStream::removeObserver(MediaStream::Observer* observer)
382 {
383     size_t pos = m_observers.find(observer);
384     if (pos != notFound)
385         m_observers.remove(pos);
386 }
387 
388 Document* MediaStream::document() const
389 {
390     return downcast&lt;Document&gt;(scriptExecutionContext());
391 }
392 






























































393 void MediaStream::stop()
394 {
395     m_isActive = false;
396 }
397 
398 const char* MediaStream::activeDOMObjectName() const
399 {
400     return &quot;MediaStream&quot;;
401 }
402 





403 bool MediaStream::hasPendingActivity() const
404 {
405     return m_isActive;
406 }
407 
408 #if !RELEASE_LOG_DISABLED
409 WTFLogChannel&amp; MediaStream::logChannel() const
410 {
411     return LogWebRTC;
412 }
413 #endif
414 
415 } // namespace WebCore
416 
417 #endif // ENABLE(MEDIA_STREAM)
</pre>
</td>
</tr>
</table>
<center><a href="MediaDevices.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaStream.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/DOMWindow.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DOMWindow.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DOMWindow.idl.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/DOMWindow.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;AbstractDOMWindow.h&quot;
 30 #include &quot;Base64Utilities.h&quot;
 31 #include &quot;ContextDestructionObserver.h&quot;
 32 #include &quot;ExceptionOr.h&quot;
 33 #include &quot;Frame.h&quot;
 34 #include &quot;FrameDestructionObserver.h&quot;
 35 #include &quot;ImageBitmap.h&quot;

 36 #include &quot;ScrollToOptions.h&quot;
 37 #include &quot;ScrollTypes.h&quot;
 38 #include &quot;Supplementable.h&quot;
 39 #include &lt;JavaScriptCore/HandleTypes.h&gt;

 40 #include &lt;wtf/Function.h&gt;
 41 #include &lt;wtf/HashSet.h&gt;

 42 #include &lt;wtf/WeakPtr.h&gt;
 43 
 44 namespace JSC {
<span class="line-modified"> 45 class ExecState;</span>
 46 class JSObject;
 47 class JSValue;
<span class="line-removed"> 48 template&lt;typename&gt; class Strong;</span>
 49 }
 50 
 51 namespace WebCore {
 52 
 53 class BarProp;
 54 class CSSRuleList;
 55 class CSSStyleDeclaration;
 56 class Crypto;
 57 class CustomElementRegistry;
 58 class DOMApplicationCache;
 59 class DOMSelection;
 60 class DOMWindowProperty;
 61 class DOMWrapperWorld;
 62 class Document;
 63 class Element;
 64 class EventListener;
 65 class FloatRect;
 66 class History;

 67 class Location;
 68 class MediaQueryList;
 69 class Navigator;
 70 class Node;
 71 class NodeList;
 72 class Page;
 73 class PageConsoleClient;
 74 class Performance;
 75 class PostMessageTimer;
 76 class RequestAnimationFrameCallback;

 77 class ScheduledAction;
 78 class Screen;
 79 class Storage;
 80 class StyleMedia;
 81 class VisualViewport;
 82 class WebKitNamespace;
 83 class WebKitPoint;
 84 
 85 #if ENABLE(DEVICE_ORIENTATION)
 86 class DeviceMotionController;
 87 class DeviceOrientationController;
 88 #endif
 89 

 90 struct ImageBitmapOptions;
 91 struct WindowFeatures;
 92 
 93 enum SetLocationLocking { LockHistoryBasedOnGestureState, LockHistoryAndBackForwardList };
 94 enum class IncludeTargetOrigin { No, Yes };
 95 










 96 // FIXME: Rename DOMWindow to LocalWindow and AbstractDOMWindow to DOMWindow.
 97 class DOMWindow final
 98     : public AbstractDOMWindow
 99     , public CanMakeWeakPtr&lt;DOMWindow&gt;
100     , public ContextDestructionObserver
101     , public Base64Utilities
102     , public Supplementable&lt;DOMWindow&gt; {
103     WTF_MAKE_ISO_ALLOCATED(DOMWindow);
104 public:
105 
106     static Ref&lt;DOMWindow&gt; create(Document&amp; document) { return adoptRef(*new DOMWindow(document)); }
107     WEBCORE_EXPORT virtual ~DOMWindow();
108 
109     // In some rare cases, we&#39;ll reuse a DOMWindow for a new Document. For example,
110     // when a script calls window.open(&quot;...&quot;), the browser gives JavaScript a window
111     // synchronously but kicks off the load in the window asynchronously. Web sites
112     // expect that modifications that they make to the window object synchronously
113     // won&#39;t be blown away when the network load commits. To make that happen, we
114     // &quot;securely transition&quot; the existing DOMWindow to the Document that results from
115     // the network load. See also SecurityContext::isSecureTransitionTo.
116     void didSecureTransitionTo(Document&amp;);
117 
118     class Observer {
119     public:
120         virtual ~Observer() { }
121 
<span class="line-modified">122         virtual void suspendForPageCache() { }</span>
<span class="line-modified">123         virtual void resumeFromPageCache() { }</span>
124         virtual void willDestroyGlobalObjectInCachedFrame() { }
125         virtual void willDestroyGlobalObjectInFrame() { }
126         virtual void willDetachGlobalObjectFromFrame() { }
127     };
128 
129     void registerObserver(Observer&amp;);
130     void unregisterObserver(Observer&amp;);
131 
132     void resetUnlessSuspendedForDocumentSuspension();
<span class="line-modified">133     void suspendForPageCache();</span>
<span class="line-modified">134     void resumeFromPageCache();</span>
135 
136     WEBCORE_EXPORT Frame* frame() const final;
137 
138     RefPtr&lt;MediaQueryList&gt; matchMedia(const String&amp;);
139 
140     WEBCORE_EXPORT unsigned pendingUnloadEventListeners() const;
141 
142     WEBCORE_EXPORT static bool dispatchAllPendingBeforeUnloadEvents();
143     WEBCORE_EXPORT static void dispatchAllPendingUnloadEvents();
144 
145     static FloatRect adjustWindowRect(Page&amp;, const FloatRect&amp; pendingChanges);
146 
147     bool allowPopUp(); // Call on first window, not target window.
148     static bool allowPopUp(Frame&amp; firstFrame);
149     static bool canShowModalDialog(const Frame&amp;);
150     WEBCORE_EXPORT void setCanShowModalDialogOverride(bool);
151 
152     Screen&amp; screen();
153     History&amp; history();
154     Crypto&amp; crypto() const;
155     BarProp&amp; locationbar();
156     BarProp&amp; menubar();
157     BarProp&amp; personalbar();
158     BarProp&amp; scrollbars();
159     BarProp&amp; statusbar();
160     BarProp&amp; toolbar();
161     WEBCORE_EXPORT Navigator&amp; navigator();
162     Navigator* optionalNavigator() const { return m_navigator.get(); }
163     Navigator&amp; clientInformation() { return navigator(); }
164 
<span class="line-modified">165     Location&amp; location();</span>







166     void setLocation(DOMWindow&amp; activeWindow, const URL&amp; completedURL, SetLocationLocking = LockHistoryBasedOnGestureState);
167 
168     DOMSelection* getSelection();
169 
170     Element* frameElement() const;
171 
172     WEBCORE_EXPORT void focus(bool allowFocus = false);
173     void focus(DOMWindow&amp; incumbentWindow);
174     void blur();
175     WEBCORE_EXPORT void close();
176     void close(Document&amp;);
177     void print();
178     void stop();
179 
180     WEBCORE_EXPORT ExceptionOr&lt;RefPtr&lt;WindowProxy&gt;&gt; open(DOMWindow&amp; activeWindow, DOMWindow&amp; firstWindow, const String&amp; urlString, const AtomString&amp; frameName, const String&amp; windowFeaturesString);
181 
182     void showModalDialog(const String&amp; urlString, const String&amp; dialogFeaturesString, DOMWindow&amp; activeWindow, DOMWindow&amp; firstWindow, const WTF::Function&lt;void(DOMWindow&amp;)&gt;&amp; prepareDialogFunction);
183 
184     void prewarmLocalStorageIfNecessary();
185 
186     void alert(const String&amp; message = emptyString());
<span class="line-modified">187     bool confirm(const String&amp; message);</span>
188     String prompt(const String&amp; message, const String&amp; defaultValue);
189 
190     bool find(const String&amp;, bool caseSensitive, bool backwards, bool wrap, bool wholeWord, bool searchInFrames, bool showDialog) const;
191 
192     bool offscreenBuffering() const;
193 
194     int outerHeight() const;
195     int outerWidth() const;
196     int innerHeight() const;
197     int innerWidth() const;
198     int screenX() const;
199     int screenY() const;
200     int screenLeft() const { return screenX(); }
201     int screenTop() const { return screenY(); }
202     int scrollX() const;
203     int scrollY() const;
204 
205     bool closed() const;
206 
207     unsigned length() const;
208 
209     String name() const;
210     void setName(const String&amp;);
211 
212     String status() const;
213     void setStatus(const String&amp;);
214     String defaultStatus() const;
215     void setDefaultStatus(const String&amp;);
216 
217     WindowProxy* opener() const;
218     void disownOpener();
219     WindowProxy* parent() const;
220     WindowProxy* top() const;
221 
222     String origin() const;

223 
224     // DOM Level 2 AbstractView Interface
225 
226     WEBCORE_EXPORT Document* document() const;
227 
228     // CSSOM View Module
229 
230     StyleMedia&amp; styleMedia();
231 
232     // DOM Level 2 Style Interface
233 
234     WEBCORE_EXPORT Ref&lt;CSSStyleDeclaration&gt; getComputedStyle(Element&amp;, const String&amp; pseudoElt) const;
235 
236     // WebKit extensions
237 
238     WEBCORE_EXPORT RefPtr&lt;CSSRuleList&gt; getMatchedCSSRules(Element*, const String&amp; pseudoElt, bool authorOnly = true) const;
239     double devicePixelRatio() const;
240 
241     RefPtr&lt;WebKitPoint&gt; webkitConvertPointFromPageToNode(Node*, const WebKitPoint*) const;
242     RefPtr&lt;WebKitPoint&gt; webkitConvertPointFromNodeToPage(Node*, const WebKitPoint*) const;
243 
244     PageConsoleClient* console() const;
245 
<span class="line-modified">246     void printErrorMessage(const String&amp;);</span>
247 
248     String crossDomainAccessErrorMessage(const DOMWindow&amp; activeWindow, IncludeTargetOrigin);
249 
<span class="line-modified">250     ExceptionOr&lt;void&gt; postMessage(JSC::ExecState&amp;, DOMWindow&amp; incumbentWindow, JSC::JSValue message, const String&amp; targetOrigin, Vector&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;&amp;&amp;);</span>





251     void postMessageTimerFired(PostMessageTimer&amp;);
252 
253     void languagesChanged();
254 
255     void scrollBy(const ScrollToOptions&amp;) const;
256     void scrollBy(double x, double y) const;
257     void scrollTo(const ScrollToOptions&amp;, ScrollClamping = ScrollClamping::Clamped) const;
258     void scrollTo(double x, double y, ScrollClamping = ScrollClamping::Clamped) const;
259 
260     void moveBy(float x, float y) const;
261     void moveTo(float x, float y) const;
262 
263     void resizeBy(float x, float y) const;
264     void resizeTo(float width, float height) const;
265 
266     VisualViewport&amp; visualViewport();
267 
268     // Timers
<span class="line-modified">269     ExceptionOr&lt;int&gt; setTimeout(JSC::ExecState&amp;, std::unique_ptr&lt;ScheduledAction&gt;, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments);</span>
270     void clearTimeout(int timeoutId);
<span class="line-modified">271     ExceptionOr&lt;int&gt; setInterval(JSC::ExecState&amp;, std::unique_ptr&lt;ScheduledAction&gt;, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments);</span>
272     void clearInterval(int timeoutId);
273 
274     int requestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp;);
275     int webkitRequestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp;);
276     void cancelAnimationFrame(int id);
277 



278     // ImageBitmap
279     void createImageBitmap(ImageBitmap::Source&amp;&amp;, ImageBitmapOptions&amp;&amp;, ImageBitmap::Promise&amp;&amp;);
280     void createImageBitmap(ImageBitmap::Source&amp;&amp;, int sx, int sy, int sw, int sh, ImageBitmapOptions&amp;&amp;, ImageBitmap::Promise&amp;&amp;);
281 
282     // Secure Contexts
283     bool isSecureContext() const;
284 
285     // Events
286     // EventTarget API
287     bool addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp;, const AddEventListenerOptions&amp;) final;
288     bool removeEventListener(const AtomString&amp; eventType, EventListener&amp;, const ListenerOptions&amp;) final;
289     void removeAllEventListeners() final;
290 
291     using EventTarget::dispatchEvent;
292     void dispatchEvent(Event&amp;, EventTarget*);
293 
294     void dispatchLoadEvent();
295 
296     void captureEvents();
297     void releaseEvents();
</pre>
<hr />
<pre>
424 #if PLATFORM(IOS_FAMILY)
425     unsigned m_scrollEventListenerCount { 0 };
426 #endif
427 
428 #if ENABLE(IOS_TOUCH_EVENTS) || ENABLE(IOS_GESTURE_EVENTS)
429     unsigned m_touchAndGestureEventListenerCount { 0 };
430 #endif
431 
432 #if ENABLE(GAMEPAD)
433     unsigned m_gamepadEventListenerCount { 0 };
434 #endif
435 
436     mutable RefPtr&lt;Storage&gt; m_sessionStorage;
437     mutable RefPtr&lt;Storage&gt; m_localStorage;
438     mutable RefPtr&lt;DOMApplicationCache&gt; m_applicationCache;
439 
440     RefPtr&lt;CustomElementRegistry&gt; m_customElementRegistry;
441 
442     mutable RefPtr&lt;Performance&gt; m_performance;
443 






444 #if ENABLE(USER_MESSAGE_HANDLERS)
445     mutable RefPtr&lt;WebKitNamespace&gt; m_webkitNamespace;
446 #endif
447 };
448 
449 inline String DOMWindow::status() const
450 {
451     return m_status;
452 }
453 
454 inline String DOMWindow::defaultStatus() const
455 {
456     return m_defaultStatus;
457 }
458 
459 } // namespace WebCore
460 
461 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::DOMWindow)
462     static bool isType(const WebCore::AbstractDOMWindow&amp; window) { return window.isLocalDOMWindow(); }
463     static bool isType(const WebCore::EventTarget&amp; target) { return target.eventTargetInterface() == WebCore::DOMWindowEventTargetInterfaceType; }
</pre>
</td>
<td>
<hr />
<pre>
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;AbstractDOMWindow.h&quot;
 30 #include &quot;Base64Utilities.h&quot;
 31 #include &quot;ContextDestructionObserver.h&quot;
 32 #include &quot;ExceptionOr.h&quot;
 33 #include &quot;Frame.h&quot;
 34 #include &quot;FrameDestructionObserver.h&quot;
 35 #include &quot;ImageBitmap.h&quot;
<span class="line-added"> 36 #include &quot;PostMessageOptions.h&quot;</span>
 37 #include &quot;ScrollToOptions.h&quot;
 38 #include &quot;ScrollTypes.h&quot;
 39 #include &quot;Supplementable.h&quot;
 40 #include &lt;JavaScriptCore/HandleTypes.h&gt;
<span class="line-added"> 41 #include &lt;JavaScriptCore/Strong.h&gt;</span>
 42 #include &lt;wtf/Function.h&gt;
 43 #include &lt;wtf/HashSet.h&gt;
<span class="line-added"> 44 #include &lt;wtf/MonotonicTime.h&gt;</span>
 45 #include &lt;wtf/WeakPtr.h&gt;
 46 
 47 namespace JSC {
<span class="line-modified"> 48 class CallFrame;</span>
 49 class JSObject;
 50 class JSValue;

 51 }
 52 
 53 namespace WebCore {
 54 
 55 class BarProp;
 56 class CSSRuleList;
 57 class CSSStyleDeclaration;
 58 class Crypto;
 59 class CustomElementRegistry;
 60 class DOMApplicationCache;
 61 class DOMSelection;
 62 class DOMWindowProperty;
 63 class DOMWrapperWorld;
 64 class Document;
 65 class Element;
 66 class EventListener;
 67 class FloatRect;
 68 class History;
<span class="line-added"> 69 class IdleRequestCallback;</span>
 70 class Location;
 71 class MediaQueryList;
 72 class Navigator;
 73 class Node;
 74 class NodeList;
 75 class Page;
 76 class PageConsoleClient;
 77 class Performance;
 78 class PostMessageTimer;
 79 class RequestAnimationFrameCallback;
<span class="line-added"> 80 class RequestIdleCallback;</span>
 81 class ScheduledAction;
 82 class Screen;
 83 class Storage;
 84 class StyleMedia;
 85 class VisualViewport;
 86 class WebKitNamespace;
 87 class WebKitPoint;
 88 
 89 #if ENABLE(DEVICE_ORIENTATION)
 90 class DeviceMotionController;
 91 class DeviceOrientationController;
 92 #endif
 93 
<span class="line-added"> 94 struct IdleRequestOptions;</span>
 95 struct ImageBitmapOptions;
 96 struct WindowFeatures;
 97 
 98 enum SetLocationLocking { LockHistoryBasedOnGestureState, LockHistoryAndBackForwardList };
 99 enum class IncludeTargetOrigin { No, Yes };
100 
<span class="line-added">101 struct WindowPostMessageOptions : public PostMessageOptions {</span>
<span class="line-added">102     WindowPostMessageOptions() = default;</span>
<span class="line-added">103     WindowPostMessageOptions(String&amp;&amp; targetOrigin, Vector&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;&amp;&amp; transfer)</span>
<span class="line-added">104         : PostMessageOptions(WTFMove(transfer))</span>
<span class="line-added">105         , targetOrigin(WTFMove(targetOrigin))</span>
<span class="line-added">106     { }</span>
<span class="line-added">107 </span>
<span class="line-added">108     String targetOrigin { &quot;/&quot;_s };</span>
<span class="line-added">109 };</span>
<span class="line-added">110 </span>
111 // FIXME: Rename DOMWindow to LocalWindow and AbstractDOMWindow to DOMWindow.
112 class DOMWindow final
113     : public AbstractDOMWindow
114     , public CanMakeWeakPtr&lt;DOMWindow&gt;
115     , public ContextDestructionObserver
116     , public Base64Utilities
117     , public Supplementable&lt;DOMWindow&gt; {
118     WTF_MAKE_ISO_ALLOCATED(DOMWindow);
119 public:
120 
121     static Ref&lt;DOMWindow&gt; create(Document&amp; document) { return adoptRef(*new DOMWindow(document)); }
122     WEBCORE_EXPORT virtual ~DOMWindow();
123 
124     // In some rare cases, we&#39;ll reuse a DOMWindow for a new Document. For example,
125     // when a script calls window.open(&quot;...&quot;), the browser gives JavaScript a window
126     // synchronously but kicks off the load in the window asynchronously. Web sites
127     // expect that modifications that they make to the window object synchronously
128     // won&#39;t be blown away when the network load commits. To make that happen, we
129     // &quot;securely transition&quot; the existing DOMWindow to the Document that results from
130     // the network load. See also SecurityContext::isSecureTransitionTo.
131     void didSecureTransitionTo(Document&amp;);
132 
133     class Observer {
134     public:
135         virtual ~Observer() { }
136 
<span class="line-modified">137         virtual void suspendForBackForwardCache() { }</span>
<span class="line-modified">138         virtual void resumeFromBackForwardCache() { }</span>
139         virtual void willDestroyGlobalObjectInCachedFrame() { }
140         virtual void willDestroyGlobalObjectInFrame() { }
141         virtual void willDetachGlobalObjectFromFrame() { }
142     };
143 
144     void registerObserver(Observer&amp;);
145     void unregisterObserver(Observer&amp;);
146 
147     void resetUnlessSuspendedForDocumentSuspension();
<span class="line-modified">148     void suspendForBackForwardCache();</span>
<span class="line-modified">149     void resumeFromBackForwardCache();</span>
150 
151     WEBCORE_EXPORT Frame* frame() const final;
152 
153     RefPtr&lt;MediaQueryList&gt; matchMedia(const String&amp;);
154 
155     WEBCORE_EXPORT unsigned pendingUnloadEventListeners() const;
156 
157     WEBCORE_EXPORT static bool dispatchAllPendingBeforeUnloadEvents();
158     WEBCORE_EXPORT static void dispatchAllPendingUnloadEvents();
159 
160     static FloatRect adjustWindowRect(Page&amp;, const FloatRect&amp; pendingChanges);
161 
162     bool allowPopUp(); // Call on first window, not target window.
163     static bool allowPopUp(Frame&amp; firstFrame);
164     static bool canShowModalDialog(const Frame&amp;);
165     WEBCORE_EXPORT void setCanShowModalDialogOverride(bool);
166 
167     Screen&amp; screen();
168     History&amp; history();
169     Crypto&amp; crypto() const;
170     BarProp&amp; locationbar();
171     BarProp&amp; menubar();
172     BarProp&amp; personalbar();
173     BarProp&amp; scrollbars();
174     BarProp&amp; statusbar();
175     BarProp&amp; toolbar();
176     WEBCORE_EXPORT Navigator&amp; navigator();
177     Navigator* optionalNavigator() const { return m_navigator.get(); }
178     Navigator&amp; clientInformation() { return navigator(); }
179 
<span class="line-modified">180     WEBCORE_EXPORT static void overrideTransientActivationDurationForTesting(Optional&lt;Seconds&gt;&amp;&amp;);</span>
<span class="line-added">181     void setLastActivationTimestamp(MonotonicTime lastActivationTimestamp) { m_lastActivationTimestamp = lastActivationTimestamp; }</span>
<span class="line-added">182     MonotonicTime lastActivationTimestamp() const { return m_lastActivationTimestamp; }</span>
<span class="line-added">183     void notifyActivated(MonotonicTime);</span>
<span class="line-added">184     bool hasTransientActivation() const;</span>
<span class="line-added">185     bool consumeTransientActivation();</span>
<span class="line-added">186 </span>
<span class="line-added">187     WEBCORE_EXPORT Location&amp; location();</span>
188     void setLocation(DOMWindow&amp; activeWindow, const URL&amp; completedURL, SetLocationLocking = LockHistoryBasedOnGestureState);
189 
190     DOMSelection* getSelection();
191 
192     Element* frameElement() const;
193 
194     WEBCORE_EXPORT void focus(bool allowFocus = false);
195     void focus(DOMWindow&amp; incumbentWindow);
196     void blur();
197     WEBCORE_EXPORT void close();
198     void close(Document&amp;);
199     void print();
200     void stop();
201 
202     WEBCORE_EXPORT ExceptionOr&lt;RefPtr&lt;WindowProxy&gt;&gt; open(DOMWindow&amp; activeWindow, DOMWindow&amp; firstWindow, const String&amp; urlString, const AtomString&amp; frameName, const String&amp; windowFeaturesString);
203 
204     void showModalDialog(const String&amp; urlString, const String&amp; dialogFeaturesString, DOMWindow&amp; activeWindow, DOMWindow&amp; firstWindow, const WTF::Function&lt;void(DOMWindow&amp;)&gt;&amp; prepareDialogFunction);
205 
206     void prewarmLocalStorageIfNecessary();
207 
208     void alert(const String&amp; message = emptyString());
<span class="line-modified">209     bool confirmForBindings(const String&amp; message);</span>
210     String prompt(const String&amp; message, const String&amp; defaultValue);
211 
212     bool find(const String&amp;, bool caseSensitive, bool backwards, bool wrap, bool wholeWord, bool searchInFrames, bool showDialog) const;
213 
214     bool offscreenBuffering() const;
215 
216     int outerHeight() const;
217     int outerWidth() const;
218     int innerHeight() const;
219     int innerWidth() const;
220     int screenX() const;
221     int screenY() const;
222     int screenLeft() const { return screenX(); }
223     int screenTop() const { return screenY(); }
224     int scrollX() const;
225     int scrollY() const;
226 
227     bool closed() const;
228 
229     unsigned length() const;
230 
231     String name() const;
232     void setName(const String&amp;);
233 
234     String status() const;
235     void setStatus(const String&amp;);
236     String defaultStatus() const;
237     void setDefaultStatus(const String&amp;);
238 
239     WindowProxy* opener() const;
240     void disownOpener();
241     WindowProxy* parent() const;
242     WindowProxy* top() const;
243 
244     String origin() const;
<span class="line-added">245     SecurityOrigin* securityOrigin() const;</span>
246 
247     // DOM Level 2 AbstractView Interface
248 
249     WEBCORE_EXPORT Document* document() const;
250 
251     // CSSOM View Module
252 
253     StyleMedia&amp; styleMedia();
254 
255     // DOM Level 2 Style Interface
256 
257     WEBCORE_EXPORT Ref&lt;CSSStyleDeclaration&gt; getComputedStyle(Element&amp;, const String&amp; pseudoElt) const;
258 
259     // WebKit extensions
260 
261     WEBCORE_EXPORT RefPtr&lt;CSSRuleList&gt; getMatchedCSSRules(Element*, const String&amp; pseudoElt, bool authorOnly = true) const;
262     double devicePixelRatio() const;
263 
264     RefPtr&lt;WebKitPoint&gt; webkitConvertPointFromPageToNode(Node*, const WebKitPoint*) const;
265     RefPtr&lt;WebKitPoint&gt; webkitConvertPointFromNodeToPage(Node*, const WebKitPoint*) const;
266 
267     PageConsoleClient* console() const;
268 
<span class="line-modified">269     void printErrorMessage(const String&amp;) const;</span>
270 
271     String crossDomainAccessErrorMessage(const DOMWindow&amp; activeWindow, IncludeTargetOrigin);
272 
<span class="line-modified">273     ExceptionOr&lt;void&gt; postMessage(JSC::JSGlobalObject&amp;, DOMWindow&amp; incumbentWindow, JSC::JSValue message, WindowPostMessageOptions&amp;&amp;);</span>
<span class="line-added">274     ExceptionOr&lt;void&gt; postMessage(JSC::JSGlobalObject&amp; globalObject, DOMWindow&amp; incumbentWindow, JSC::JSValue message, String&amp;&amp; targetOrigin, Vector&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;&amp;&amp; transfer)</span>
<span class="line-added">275     {</span>
<span class="line-added">276         return postMessage(globalObject, incumbentWindow, message, WindowPostMessageOptions { WTFMove(targetOrigin), WTFMove(transfer) });</span>
<span class="line-added">277     }</span>
<span class="line-added">278 </span>
279     void postMessageTimerFired(PostMessageTimer&amp;);
280 
281     void languagesChanged();
282 
283     void scrollBy(const ScrollToOptions&amp;) const;
284     void scrollBy(double x, double y) const;
285     void scrollTo(const ScrollToOptions&amp;, ScrollClamping = ScrollClamping::Clamped) const;
286     void scrollTo(double x, double y, ScrollClamping = ScrollClamping::Clamped) const;
287 
288     void moveBy(float x, float y) const;
289     void moveTo(float x, float y) const;
290 
291     void resizeBy(float x, float y) const;
292     void resizeTo(float width, float height) const;
293 
294     VisualViewport&amp; visualViewport();
295 
296     // Timers
<span class="line-modified">297     ExceptionOr&lt;int&gt; setTimeout(JSC::JSGlobalObject&amp;, std::unique_ptr&lt;ScheduledAction&gt;, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments);</span>
298     void clearTimeout(int timeoutId);
<span class="line-modified">299     ExceptionOr&lt;int&gt; setInterval(JSC::JSGlobalObject&amp;, std::unique_ptr&lt;ScheduledAction&gt;, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments);</span>
300     void clearInterval(int timeoutId);
301 
302     int requestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp;);
303     int webkitRequestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp;);
304     void cancelAnimationFrame(int id);
305 
<span class="line-added">306     int requestIdleCallback(Ref&lt;IdleRequestCallback&gt;&amp;&amp;, const IdleRequestOptions&amp;);</span>
<span class="line-added">307     void cancelIdleCallback(int id);</span>
<span class="line-added">308 </span>
309     // ImageBitmap
310     void createImageBitmap(ImageBitmap::Source&amp;&amp;, ImageBitmapOptions&amp;&amp;, ImageBitmap::Promise&amp;&amp;);
311     void createImageBitmap(ImageBitmap::Source&amp;&amp;, int sx, int sy, int sw, int sh, ImageBitmapOptions&amp;&amp;, ImageBitmap::Promise&amp;&amp;);
312 
313     // Secure Contexts
314     bool isSecureContext() const;
315 
316     // Events
317     // EventTarget API
318     bool addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp;, const AddEventListenerOptions&amp;) final;
319     bool removeEventListener(const AtomString&amp; eventType, EventListener&amp;, const ListenerOptions&amp;) final;
320     void removeAllEventListeners() final;
321 
322     using EventTarget::dispatchEvent;
323     void dispatchEvent(Event&amp;, EventTarget*);
324 
325     void dispatchLoadEvent();
326 
327     void captureEvents();
328     void releaseEvents();
</pre>
<hr />
<pre>
455 #if PLATFORM(IOS_FAMILY)
456     unsigned m_scrollEventListenerCount { 0 };
457 #endif
458 
459 #if ENABLE(IOS_TOUCH_EVENTS) || ENABLE(IOS_GESTURE_EVENTS)
460     unsigned m_touchAndGestureEventListenerCount { 0 };
461 #endif
462 
463 #if ENABLE(GAMEPAD)
464     unsigned m_gamepadEventListenerCount { 0 };
465 #endif
466 
467     mutable RefPtr&lt;Storage&gt; m_sessionStorage;
468     mutable RefPtr&lt;Storage&gt; m_localStorage;
469     mutable RefPtr&lt;DOMApplicationCache&gt; m_applicationCache;
470 
471     RefPtr&lt;CustomElementRegistry&gt; m_customElementRegistry;
472 
473     mutable RefPtr&lt;Performance&gt; m_performance;
474 
<span class="line-added">475     // For the purpose of tracking user activation, each Window W has a last activation timestamp. This is a number indicating the last time W got</span>
<span class="line-added">476     // an activation notification. It corresponds to a DOMHighResTimeStamp value except for two cases: positive infinity indicates that W has never</span>
<span class="line-added">477     // been activated, while negative infinity indicates that a user activation-gated API has consumed the last user activation of W. The initial</span>
<span class="line-added">478     // value is positive infinity.</span>
<span class="line-added">479     MonotonicTime m_lastActivationTimestamp { MonotonicTime::infinity() };</span>
<span class="line-added">480 </span>
481 #if ENABLE(USER_MESSAGE_HANDLERS)
482     mutable RefPtr&lt;WebKitNamespace&gt; m_webkitNamespace;
483 #endif
484 };
485 
486 inline String DOMWindow::status() const
487 {
488     return m_status;
489 }
490 
491 inline String DOMWindow::defaultStatus() const
492 {
493     return m_defaultStatus;
494 }
495 
496 } // namespace WebCore
497 
498 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::DOMWindow)
499     static bool isType(const WebCore::AbstractDOMWindow&amp; window) { return window.isLocalDOMWindow(); }
500     static bool isType(const WebCore::EventTarget&amp; target) { return target.eventTargetInterface() == WebCore::DOMWindowEventTargetInterfaceType; }
</pre>
</td>
</tr>
</table>
<center><a href="DOMWindow.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DOMWindow.idl.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
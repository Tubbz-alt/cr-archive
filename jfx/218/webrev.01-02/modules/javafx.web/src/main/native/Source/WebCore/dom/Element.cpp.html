<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/dom/Element.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2001 Peter Kelly (pmk@post.com)
   5  *           (C) 2001 Dirk Mueller (mueller@kde.org)
   6  *           (C) 2007 David Smith (catfish.man@gmail.com)
   7  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   8  *           (C) 2007 Eric Seidel (eric@webkit.org)
   9  *
  10  * This library is free software; you can redistribute it and/or
  11  * modify it under the terms of the GNU Library General Public
  12  * License as published by the Free Software Foundation; either
  13  * version 2 of the License, or (at your option) any later version.
  14  *
  15  * This library is distributed in the hope that it will be useful,
  16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  18  * Library General Public License for more details.
  19  *
  20  * You should have received a copy of the GNU Library General Public License
  21  * along with this library; see the file COPYING.LIB.  If not, write to
  22  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  23  * Boston, MA 02110-1301, USA.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;Element.h&quot;
  28 
  29 #include &quot;AXObjectCache.h&quot;
  30 #include &quot;Attr.h&quot;
  31 #include &quot;AttributeChangeInvalidation.h&quot;
  32 #include &quot;CSSAnimationController.h&quot;
  33 #include &quot;CSSParser.h&quot;
  34 #include &quot;Chrome.h&quot;
  35 #include &quot;ChromeClient.h&quot;
  36 #include &quot;ClassChangeInvalidation.h&quot;
  37 #include &quot;ComposedTreeAncestorIterator.h&quot;
  38 #include &quot;ComposedTreeIterator.h&quot;
  39 #include &quot;ContainerNodeAlgorithms.h&quot;
  40 #include &quot;CustomElementReactionQueue.h&quot;
  41 #include &quot;CustomElementRegistry.h&quot;
  42 #include &quot;DOMRect.h&quot;
  43 #include &quot;DOMRectList.h&quot;
  44 #include &quot;DOMTokenList.h&quot;
  45 #include &quot;DOMWindow.h&quot;
  46 #include &quot;DocumentSharedObjectPool.h&quot;
  47 #include &quot;DocumentTimeline.h&quot;
  48 #include &quot;Editing.h&quot;
  49 #include &quot;ElementIterator.h&quot;
  50 #include &quot;ElementRareData.h&quot;
  51 #include &quot;EventDispatcher.h&quot;
  52 #include &quot;EventHandler.h&quot;
  53 #include &quot;EventNames.h&quot;
  54 #include &quot;FocusController.h&quot;
  55 #include &quot;FocusEvent.h&quot;
  56 #include &quot;Frame.h&quot;
  57 #include &quot;FrameSelection.h&quot;
  58 #include &quot;FrameView.h&quot;
  59 #include &quot;FullscreenManager.h&quot;
  60 #include &quot;GetAnimationsOptions.h&quot;
  61 #include &quot;HTMLBodyElement.h&quot;
  62 #include &quot;HTMLCanvasElement.h&quot;
  63 #include &quot;HTMLCollection.h&quot;
  64 #include &quot;HTMLDocument.h&quot;
  65 #include &quot;HTMLHtmlElement.h&quot;
  66 #include &quot;HTMLLabelElement.h&quot;
  67 #include &quot;HTMLNameCollection.h&quot;
  68 #include &quot;HTMLObjectElement.h&quot;
  69 #include &quot;HTMLOptGroupElement.h&quot;
  70 #include &quot;HTMLOptionElement.h&quot;
  71 #include &quot;HTMLParserIdioms.h&quot;
  72 #include &quot;HTMLSelectElement.h&quot;
  73 #include &quot;HTMLTemplateElement.h&quot;
  74 #include &quot;IdChangeInvalidation.h&quot;
  75 #include &quot;IdTargetObserverRegistry.h&quot;
  76 #include &quot;InspectorInstrumentation.h&quot;
  77 #include &quot;JSLazyEventListener.h&quot;
  78 #include &quot;KeyboardEvent.h&quot;
  79 #include &quot;KeyframeAnimationOptions.h&quot;
  80 #include &quot;KeyframeEffect.h&quot;
  81 #include &quot;MutationObserverInterestGroup.h&quot;
  82 #include &quot;MutationRecord.h&quot;
  83 #include &quot;NodeRenderStyle.h&quot;
  84 #include &quot;PlatformMouseEvent.h&quot;
  85 #include &quot;PlatformWheelEvent.h&quot;
  86 #include &quot;PointerCaptureController.h&quot;
  87 #include &quot;PointerEvent.h&quot;
  88 #include &quot;PointerLockController.h&quot;
  89 #include &quot;RenderFragmentedFlow.h&quot;
  90 #include &quot;RenderLayer.h&quot;
  91 #include &quot;RenderLayerBacking.h&quot;
  92 #include &quot;RenderLayerCompositor.h&quot;
  93 #include &quot;RenderListBox.h&quot;
  94 #include &quot;RenderTheme.h&quot;
  95 #include &quot;RenderTreeUpdater.h&quot;
  96 #include &quot;RenderView.h&quot;
  97 #include &quot;RenderWidget.h&quot;
  98 #include &quot;RuntimeEnabledFeatures.h&quot;
  99 #include &quot;SVGDocumentExtensions.h&quot;
 100 #include &quot;SVGElement.h&quot;
 101 #include &quot;SVGNames.h&quot;
 102 #include &quot;SVGSVGElement.h&quot;
 103 #include &quot;ScriptDisallowedScope.h&quot;
 104 #include &quot;ScrollIntoViewOptions.h&quot;
 105 #include &quot;ScrollLatchingState.h&quot;
 106 #include &quot;SelectorQuery.h&quot;
 107 #include &quot;Settings.h&quot;
 108 #include &quot;SimulatedClick.h&quot;
 109 #include &quot;SlotAssignment.h&quot;
 110 #include &quot;StyleInvalidator.h&quot;
 111 #include &quot;StyleProperties.h&quot;
 112 #include &quot;StyleResolver.h&quot;
 113 #include &quot;StyleScope.h&quot;
 114 #include &quot;StyleTreeResolver.h&quot;
 115 #include &quot;TextIterator.h&quot;
 116 #include &quot;TouchAction.h&quot;
 117 #include &quot;VoidCallback.h&quot;
 118 #include &quot;WebAnimation.h&quot;
 119 #include &quot;WheelEvent.h&quot;
 120 #include &quot;XLinkNames.h&quot;
 121 #include &quot;XMLNSNames.h&quot;
 122 #include &quot;XMLNames.h&quot;
 123 #include &quot;markup.h&quot;
 124 #include &lt;wtf/IsoMallocInlines.h&gt;
 125 #include &lt;wtf/NeverDestroyed.h&gt;
 126 #include &lt;wtf/text/CString.h&gt;
 127 
 128 namespace WebCore {
 129 
 130 WTF_MAKE_ISO_ALLOCATED_IMPL(Element);
 131 
 132 using namespace HTMLNames;
 133 using namespace XMLNames;
 134 
 135 static HashMap&lt;Element*, Vector&lt;RefPtr&lt;Attr&gt;&gt;&gt;&amp; attrNodeListMap()
 136 {
 137     static NeverDestroyed&lt;HashMap&lt;Element*, Vector&lt;RefPtr&lt;Attr&gt;&gt;&gt;&gt; map;
 138     return map;
 139 }
 140 
 141 static Vector&lt;RefPtr&lt;Attr&gt;&gt;* attrNodeListForElement(Element&amp; element)
 142 {
 143     if (!element.hasSyntheticAttrChildNodes())
 144         return nullptr;
 145     ASSERT(attrNodeListMap().contains(&amp;element));
 146     return &amp;attrNodeListMap().find(&amp;element)-&gt;value;
 147 }
 148 
 149 static Vector&lt;RefPtr&lt;Attr&gt;&gt;&amp; ensureAttrNodeListForElement(Element&amp; element)
 150 {
 151     if (element.hasSyntheticAttrChildNodes()) {
 152         ASSERT(attrNodeListMap().contains(&amp;element));
 153         return attrNodeListMap().find(&amp;element)-&gt;value;
 154     }
 155     ASSERT(!attrNodeListMap().contains(&amp;element));
 156     element.setHasSyntheticAttrChildNodes(true);
 157     return attrNodeListMap().add(&amp;element, Vector&lt;RefPtr&lt;Attr&gt;&gt;()).iterator-&gt;value;
 158 }
 159 
 160 static void removeAttrNodeListForElement(Element&amp; element)
 161 {
 162     ASSERT(element.hasSyntheticAttrChildNodes());
 163     ASSERT(attrNodeListMap().contains(&amp;element));
 164     attrNodeListMap().remove(&amp;element);
 165     element.setHasSyntheticAttrChildNodes(false);
 166 }
 167 
 168 static Attr* findAttrNodeInList(Vector&lt;RefPtr&lt;Attr&gt;&gt;&amp; attrNodeList, const QualifiedName&amp; name)
 169 {
 170     for (auto&amp; node : attrNodeList) {
 171         if (node-&gt;qualifiedName().matches(name))
 172             return node.get();
 173     }
 174     return nullptr;
 175 }
 176 
 177 static Attr* findAttrNodeInList(Vector&lt;RefPtr&lt;Attr&gt;&gt;&amp; attrNodeList, const AtomString&amp; localName, bool shouldIgnoreAttributeCase)
 178 {
 179     const AtomString&amp; caseAdjustedName = shouldIgnoreAttributeCase ? localName.convertToASCIILowercase() : localName;
 180     for (auto&amp; node : attrNodeList) {
 181         if (node-&gt;qualifiedName().localName() == caseAdjustedName)
 182             return node.get();
 183     }
 184     return nullptr;
 185 }
 186 
 187 Ref&lt;Element&gt; Element::create(const QualifiedName&amp; tagName, Document&amp; document)
 188 {
 189     return adoptRef(*new Element(tagName, document, CreateElement));
 190 }
 191 
 192 Element::Element(const QualifiedName&amp; tagName, Document&amp; document, ConstructionType type)
 193     : ContainerNode(document, type)
 194     , m_tagName(tagName)
 195 {
 196 }
 197 
 198 Element::~Element()
 199 {
 200     ASSERT(!beforePseudoElement());
 201     ASSERT(!afterPseudoElement());
 202 
 203 #if ENABLE(INTERSECTION_OBSERVER)
 204     disconnectFromIntersectionObservers();
 205 #endif
 206 
 207 #if ENABLE(RESIZE_OBSERVER)
 208     disconnectFromResizeObservers();
 209 #endif
 210 
 211     removeShadowRoot();
 212 
 213     if (hasSyntheticAttrChildNodes())
 214         detachAllAttrNodesFromElement();
 215 
 216 #if ENABLE(CSS_TYPED_OM)
 217     if (hasRareData()) {
 218         if (auto* map = elementRareData()-&gt;attributeStyleMap())
 219             map-&gt;clearElement();
 220     }
 221 #endif
 222 
 223     if (hasPendingResources()) {
 224         document().accessSVGExtensions().removeElementFromPendingResources(*this);
 225         ASSERT(!hasPendingResources());
 226     }
 227 }
 228 
 229 inline ElementRareData* Element::elementRareData() const
 230 {
 231     ASSERT_WITH_SECURITY_IMPLICATION(hasRareData());
 232     return static_cast&lt;ElementRareData*&gt;(rareData());
 233 }
 234 
 235 inline ElementRareData&amp; Element::ensureElementRareData()
 236 {
 237     return static_cast&lt;ElementRareData&amp;&gt;(ensureRareData());
 238 }
 239 
 240 void Element::clearTabIndexExplicitlyIfNeeded()
 241 {
 242     if (hasRareData())
 243         elementRareData()-&gt;clearTabIndexExplicitly();
 244 }
 245 
 246 void Element::setTabIndexExplicitly(int tabIndex)
 247 {
 248     ensureElementRareData().setTabIndexExplicitly(tabIndex);
 249 }
 250 
 251 Optional&lt;int&gt; Element::tabIndexSetExplicitly() const
 252 {
 253     if (!hasRareData())
 254         return WTF::nullopt;
 255     return elementRareData()-&gt;tabIndex();
 256 }
 257 
 258 int Element::defaultTabIndex() const
 259 {
 260     return -1;
 261 }
 262 
 263 bool Element::supportsFocus() const
 264 {
 265     return !!tabIndexSetExplicitly();
 266 }
 267 
 268 RefPtr&lt;Element&gt; Element::focusDelegate()
 269 {
 270     return this;
 271 }
 272 
 273 int Element::tabIndexForBindings() const
 274 {
 275     return valueOrCompute(tabIndexSetExplicitly(), [&amp;] { return defaultTabIndex(); });
 276 }
 277 
 278 void Element::setTabIndexForBindings(int value)
 279 {
 280     setIntegralAttribute(tabindexAttr, value);
 281 }
 282 
 283 bool Element::isKeyboardFocusable(KeyboardEvent*) const
 284 {
 285     if (!(isFocusable() &amp;&amp; !shouldBeIgnoredInSequentialFocusNavigation() &amp;&amp; tabIndexSetExplicitly().valueOr(0) &gt;= 0))
 286         return false;
 287     if (auto* root = shadowRoot()) {
 288         if (root-&gt;delegatesFocus())
 289             return false;
 290     }
 291     return true;
 292 }
 293 
 294 bool Element::isMouseFocusable() const
 295 {
 296     return isFocusable();
 297 }
 298 
 299 bool Element::shouldUseInputMethod()
 300 {
 301     return computeEditability(UserSelectAllIsAlwaysNonEditable, ShouldUpdateStyle::Update) != Editability::ReadOnly;
 302 }
 303 
 304 static bool isForceEvent(const PlatformMouseEvent&amp; platformEvent)
 305 {
 306     return platformEvent.type() == PlatformEvent::MouseForceChanged || platformEvent.type() == PlatformEvent::MouseForceDown || platformEvent.type() == PlatformEvent::MouseForceUp;
 307 }
 308 
 309 #if ENABLE(POINTER_EVENTS)
 310 
 311 static bool isCompatibilityMouseEvent(const MouseEvent&amp; mouseEvent)
 312 {
 313     // https://www.w3.org/TR/pointerevents/#compatibility-mapping-with-mouse-events
 314     const auto&amp; type = mouseEvent.type();
 315     return type != eventNames().clickEvent &amp;&amp; type != eventNames().mouseoverEvent &amp;&amp; type != eventNames().mouseoutEvent &amp;&amp; type != eventNames().mouseenterEvent &amp;&amp; type != eventNames().mouseleaveEvent;
 316 }
 317 
 318 #endif
 319 
 320 enum class ShouldIgnoreMouseEvent : bool { No, Yes };
 321 static ShouldIgnoreMouseEvent dispatchPointerEventIfNeeded(Element&amp; element, const MouseEvent&amp; mouseEvent, const PlatformMouseEvent&amp; platformEvent, bool&amp; didNotSwallowEvent)
 322 {
 323 #if ENABLE(POINTER_EVENTS)
 324     if (RuntimeEnabledFeatures::sharedFeatures().pointerEventsEnabled()) {
 325         if (auto* page = element.document().page()) {
 326             auto&amp; pointerCaptureController = page-&gt;pointerCaptureController();
 327 #if ENABLE(TOUCH_EVENTS)
 328             if (platformEvent.pointerId() != mousePointerID &amp;&amp; mouseEvent.type() != eventNames().clickEvent &amp;&amp; pointerCaptureController.preventsCompatibilityMouseEventsForIdentifier(platformEvent.pointerId()))
 329                 return ShouldIgnoreMouseEvent::Yes;
 330 #else
 331             UNUSED_PARAM(platformEvent);
 332 #endif
 333             if (platformEvent.syntheticClickType() != NoTap)
 334                 return ShouldIgnoreMouseEvent::No;
 335 
 336             if (auto pointerEvent = pointerCaptureController.pointerEventForMouseEvent(mouseEvent)) {
 337                 pointerCaptureController.dispatchEvent(*pointerEvent, &amp;element);
 338                 if (isCompatibilityMouseEvent(mouseEvent) &amp;&amp; pointerCaptureController.preventsCompatibilityMouseEventsForIdentifier(pointerEvent-&gt;pointerId()))
 339                     return ShouldIgnoreMouseEvent::Yes;
 340                 if (pointerEvent-&gt;defaultPrevented() || pointerEvent-&gt;defaultHandled()) {
 341                     didNotSwallowEvent = false;
 342                     if (pointerEvent-&gt;type() == eventNames().pointerdownEvent)
 343                         return ShouldIgnoreMouseEvent::Yes;
 344                 }
 345             }
 346         }
 347     }
 348 #else
 349     UNUSED_PARAM(element);
 350     UNUSED_PARAM(mouseEvent);
 351     UNUSED_PARAM(platformEvent);
 352     UNUSED_PARAM(didNotSwallowEvent);
 353 #endif
 354 
 355     return ShouldIgnoreMouseEvent::No;
 356 }
 357 
 358 bool Element::dispatchMouseEvent(const PlatformMouseEvent&amp; platformEvent, const AtomString&amp; eventType, int detail, Element* relatedTarget)
 359 {
 360     if (isDisabledFormControl())
 361         return false;
 362 
 363     if (isForceEvent(platformEvent) &amp;&amp; !document().hasListenerTypeForEventType(platformEvent.type()))
 364         return false;
 365 
 366     Ref&lt;MouseEvent&gt; mouseEvent = MouseEvent::create(eventType, document().windowProxy(), platformEvent, detail, relatedTarget);
 367 
 368     if (mouseEvent-&gt;type().isEmpty())
 369         return true; // Shouldn&#39;t happen.
 370 
 371     bool didNotSwallowEvent = true;
 372 
 373     if (dispatchPointerEventIfNeeded(*this, mouseEvent.get(), platformEvent, didNotSwallowEvent) == ShouldIgnoreMouseEvent::Yes)
 374         return false;
 375 
 376     ASSERT(!mouseEvent-&gt;target() || mouseEvent-&gt;target() != relatedTarget);
 377     dispatchEvent(mouseEvent);
 378     if (mouseEvent-&gt;defaultPrevented() || mouseEvent-&gt;defaultHandled())
 379         didNotSwallowEvent = false;
 380 
 381     if (mouseEvent-&gt;type() == eventNames().clickEvent &amp;&amp; mouseEvent-&gt;detail() == 2) {
 382         // Special case: If it&#39;s a double click event, we also send the dblclick event. This is not part
 383         // of the DOM specs, but is used for compatibility with the ondblclick=&quot;&quot; attribute. This is treated
 384         // as a separate event in other DOM-compliant browsers like Firefox, and so we do the same.
 385         // FIXME: Is it okay that mouseEvent may have been mutated by scripts via initMouseEvent in dispatchEvent above?
 386         Ref&lt;MouseEvent&gt; doubleClickEvent = MouseEvent::create(eventNames().dblclickEvent,
 387             mouseEvent-&gt;bubbles() ? Event::CanBubble::Yes : Event::CanBubble::No,
 388             mouseEvent-&gt;cancelable() ? Event::IsCancelable::Yes : Event::IsCancelable::No,
 389             Event::IsComposed::Yes,
 390             mouseEvent-&gt;view(), mouseEvent-&gt;detail(),
 391             mouseEvent-&gt;screenX(), mouseEvent-&gt;screenY(), mouseEvent-&gt;clientX(), mouseEvent-&gt;clientY(),
 392             mouseEvent-&gt;modifierKeys(), mouseEvent-&gt;button(), mouseEvent-&gt;buttons(), mouseEvent-&gt;syntheticClickType(), relatedTarget);
 393 
 394         if (mouseEvent-&gt;defaultHandled())
 395             doubleClickEvent-&gt;setDefaultHandled();
 396 
 397         dispatchEvent(doubleClickEvent);
 398         if (doubleClickEvent-&gt;defaultHandled() || doubleClickEvent-&gt;defaultPrevented())
 399             return false;
 400     }
 401     return didNotSwallowEvent;
 402 }
 403 
 404 bool Element::dispatchWheelEvent(const PlatformWheelEvent&amp; platformEvent)
 405 {
 406     auto event = WheelEvent::create(platformEvent, document().windowProxy());
 407 
 408     // Events with no deltas are important because they convey platform information about scroll gestures
 409     // and momentum beginning or ending. However, those events should not be sent to the DOM since some
 410     // websites will break. They need to be dispatched because dispatching them will call into the default
 411     // event handler, and our platform code will correctly handle the phase changes. Calling stopPropogation()
 412     // will prevent the event from being sent to the DOM, but will still call the default event handler.
 413     // FIXME: Move this logic into WheelEvent::create.
 414     if (!platformEvent.deltaX() &amp;&amp; !platformEvent.deltaY())
 415         event-&gt;stopPropagation();
 416 
 417     dispatchEvent(event);
 418     return !event-&gt;defaultPrevented() &amp;&amp; !event-&gt;defaultHandled();
 419 }
 420 
 421 bool Element::dispatchKeyEvent(const PlatformKeyboardEvent&amp; platformEvent)
 422 {
 423     auto event = KeyboardEvent::create(platformEvent, document().windowProxy());
 424 
 425     if (Frame* frame = document().frame()) {
 426         if (frame-&gt;eventHandler().accessibilityPreventsEventPropagation(event))
 427             event-&gt;stopPropagation();
 428     }
 429 
 430     dispatchEvent(event);
 431     return !event-&gt;defaultPrevented() &amp;&amp; !event-&gt;defaultHandled();
 432 }
 433 
 434 void Element::dispatchSimulatedClick(Event* underlyingEvent, SimulatedClickMouseEventOptions eventOptions, SimulatedClickVisualOptions visualOptions)
 435 {
 436     simulateClick(*this, underlyingEvent, eventOptions, visualOptions, SimulatedClickSource::UserAgent);
 437 }
 438 
 439 Ref&lt;Node&gt; Element::cloneNodeInternal(Document&amp; targetDocument, CloningOperation type)
 440 {
 441     switch (type) {
 442     case CloningOperation::OnlySelf:
 443     case CloningOperation::SelfWithTemplateContent:
 444         return cloneElementWithoutChildren(targetDocument);
 445     case CloningOperation::Everything:
 446         break;
 447     }
 448     return cloneElementWithChildren(targetDocument);
 449 }
 450 
 451 Ref&lt;Element&gt; Element::cloneElementWithChildren(Document&amp; targetDocument)
 452 {
 453     Ref&lt;Element&gt; clone = cloneElementWithoutChildren(targetDocument);
 454     cloneChildNodes(clone);
 455     return clone;
 456 }
 457 
 458 Ref&lt;Element&gt; Element::cloneElementWithoutChildren(Document&amp; targetDocument)
 459 {
 460     Ref&lt;Element&gt; clone = cloneElementWithoutAttributesAndChildren(targetDocument);
 461 
 462     // This will catch HTML elements in the wrong namespace that are not correctly copied.
 463     // This is a sanity check as HTML overloads some of the DOM methods.
 464     ASSERT(isHTMLElement() == clone-&gt;isHTMLElement());
 465 
 466     clone-&gt;cloneDataFromElement(*this);
 467     return clone;
 468 }
 469 
 470 Ref&lt;Element&gt; Element::cloneElementWithoutAttributesAndChildren(Document&amp; targetDocument)
 471 {
 472     return targetDocument.createElement(tagQName(), false);
 473 }
 474 
 475 Ref&lt;Attr&gt; Element::detachAttribute(unsigned index)
 476 {
 477     ASSERT(elementData());
 478 
 479     const Attribute&amp; attribute = elementData()-&gt;attributeAt(index);
 480 
 481     RefPtr&lt;Attr&gt; attrNode = attrIfExists(attribute.name());
 482     if (attrNode)
 483         detachAttrNodeFromElementWithValue(attrNode.get(), attribute.value());
 484     else
 485         attrNode = Attr::create(document(), attribute.name(), attribute.value());
 486 
 487     removeAttributeInternal(index, NotInSynchronizationOfLazyAttribute);
 488     return attrNode.releaseNonNull();
 489 }
 490 
 491 bool Element::removeAttribute(const QualifiedName&amp; name)
 492 {
 493     if (!elementData())
 494         return false;
 495 
 496     unsigned index = elementData()-&gt;findAttributeIndexByName(name);
 497     if (index == ElementData::attributeNotFound)
 498         return false;
 499 
 500     removeAttributeInternal(index, NotInSynchronizationOfLazyAttribute);
 501     return true;
 502 }
 503 
 504 void Element::setBooleanAttribute(const QualifiedName&amp; name, bool value)
 505 {
 506     if (value)
 507         setAttribute(name, emptyAtom());
 508     else
 509         removeAttribute(name);
 510 }
 511 
 512 NamedNodeMap&amp; Element::attributes() const
 513 {
 514     ElementRareData&amp; rareData = const_cast&lt;Element*&gt;(this)-&gt;ensureElementRareData();
 515     if (NamedNodeMap* attributeMap = rareData.attributeMap())
 516         return *attributeMap;
 517 
 518     rareData.setAttributeMap(makeUnique&lt;NamedNodeMap&gt;(const_cast&lt;Element&amp;&gt;(*this)));
 519     return *rareData.attributeMap();
 520 }
 521 
 522 Node::NodeType Element::nodeType() const
 523 {
 524     return ELEMENT_NODE;
 525 }
 526 
 527 bool Element::hasAttribute(const QualifiedName&amp; name) const
 528 {
 529     return hasAttributeNS(name.namespaceURI(), name.localName());
 530 }
 531 
 532 void Element::synchronizeAllAttributes() const
 533 {
 534     if (!elementData())
 535         return;
 536     if (elementData()-&gt;styleAttributeIsDirty()) {
 537         ASSERT(isStyledElement());
 538         static_cast&lt;const StyledElement*&gt;(this)-&gt;synchronizeStyleAttributeInternal();
 539     }
 540 
 541     if (isSVGElement())
 542         downcast&lt;SVGElement&gt;(const_cast&lt;Element&amp;&gt;(*this)).synchronizeAllAttributes();
 543 }
 544 
 545 ALWAYS_INLINE void Element::synchronizeAttribute(const QualifiedName&amp; name) const
 546 {
 547     if (!elementData())
 548         return;
 549     if (UNLIKELY(name == styleAttr &amp;&amp; elementData()-&gt;styleAttributeIsDirty())) {
 550         ASSERT_WITH_SECURITY_IMPLICATION(isStyledElement());
 551         static_cast&lt;const StyledElement*&gt;(this)-&gt;synchronizeStyleAttributeInternal();
 552         return;
 553     }
 554 
 555     if (isSVGElement())
 556         downcast&lt;SVGElement&gt;(const_cast&lt;Element&amp;&gt;(*this)).synchronizeAttribute(name);
 557 }
 558 
 559 static ALWAYS_INLINE bool isStyleAttribute(const Element&amp; element, const AtomString&amp; attributeLocalName)
 560 {
 561     if (shouldIgnoreAttributeCase(element))
 562         return equalLettersIgnoringASCIICase(attributeLocalName, &quot;style&quot;);
 563     return attributeLocalName == styleAttr-&gt;localName();
 564 }
 565 
 566 ALWAYS_INLINE void Element::synchronizeAttribute(const AtomString&amp; localName) const
 567 {
 568     // This version of synchronizeAttribute() is streamlined for the case where you don&#39;t have a full QualifiedName,
 569     // e.g when called from DOM API.
 570     if (!elementData())
 571         return;
 572     if (elementData()-&gt;styleAttributeIsDirty() &amp;&amp; isStyleAttribute(*this, localName)) {
 573         ASSERT_WITH_SECURITY_IMPLICATION(isStyledElement());
 574         static_cast&lt;const StyledElement*&gt;(this)-&gt;synchronizeStyleAttributeInternal();
 575         return;
 576     }
 577 
 578     if (isSVGElement())
 579         downcast&lt;SVGElement&gt;(const_cast&lt;Element&amp;&gt;(*this)).synchronizeAttribute(QualifiedName(nullAtom(), localName, nullAtom()));
 580 }
 581 
 582 const AtomString&amp; Element::getAttribute(const QualifiedName&amp; name) const
 583 {
 584     if (!elementData())
 585         return nullAtom();
 586     synchronizeAttribute(name);
 587     if (const Attribute* attribute = findAttributeByName(name))
 588         return attribute-&gt;value();
 589     return nullAtom();
 590 }
 591 
 592 Vector&lt;String&gt; Element::getAttributeNames() const
 593 {
 594     Vector&lt;String&gt; attributesVector;
 595     if (!hasAttributes())
 596         return attributesVector;
 597 
 598     auto attributes = attributesIterator();
 599     attributesVector.reserveInitialCapacity(attributes.attributeCount());
 600     for (auto&amp; attribute : attributes)
 601         attributesVector.uncheckedAppend(attribute.name().toString());
 602     return attributesVector;
 603 }
 604 
 605 bool Element::isFocusable() const
 606 {
 607     if (!isConnected() || !supportsFocus())
 608         return false;
 609 
 610     if (!renderer()) {
 611         // If the node is in a display:none tree it might say it needs style recalc but
 612         // the whole document is actually up to date.
 613         // FIXME: We should be able to assert !needsStyleRecalc() || !document().childNeedsStyleRecalc()
 614         // but it hits too frequently on websites like Gmail and Microsoft Exchange.
 615 
 616         // Elements in canvas fallback content are not rendered, but they are allowed to be
 617         // focusable as long as their canvas is displayed and visible.
 618         if (auto* canvas = ancestorsOfType&lt;HTMLCanvasElement&gt;(*this).first())
 619             return canvas-&gt;renderer() &amp;&amp; canvas-&gt;renderer()-&gt;style().visibility() == Visibility::Visible;
 620     }
 621 
 622     // FIXME: Even if we are not visible, we might have a child that is visible.
 623     // Hyatt wants to fix that some day with a &quot;has visible content&quot; flag or the like.
 624     if (!renderer() || renderer()-&gt;style().visibility() != Visibility::Visible)
 625         return false;
 626 
 627     return true;
 628 }
 629 
 630 bool Element::isUserActionElementInActiveChain() const
 631 {
 632     ASSERT(isUserActionElement());
 633     return document().userActionElements().isInActiveChain(*this);
 634 }
 635 
 636 bool Element::isUserActionElementActive() const
 637 {
 638     ASSERT(isUserActionElement());
 639     return document().userActionElements().isActive(*this);
 640 }
 641 
 642 bool Element::isUserActionElementFocused() const
 643 {
 644     ASSERT(isUserActionElement());
 645     return document().userActionElements().isFocused(*this);
 646 }
 647 
 648 bool Element::isUserActionElementHovered() const
 649 {
 650     ASSERT(isUserActionElement());
 651     return document().userActionElements().isHovered(*this);
 652 }
 653 
 654 void Element::setActive(bool flag, bool pause)
 655 {
 656     if (flag == active())
 657         return;
 658 
 659     document().userActionElements().setActive(*this, flag);
 660 
 661     auto* renderStyle = renderOrDisplayContentsStyle();
 662     bool reactsToPress = (renderStyle &amp;&amp; renderStyle-&gt;affectedByActive()) || styleAffectedByActive();
 663     if (reactsToPress)
 664         invalidateStyleForSubtree();
 665 
 666     if (!renderer())
 667         return;
 668 
 669     if (renderer()-&gt;style().hasAppearance() &amp;&amp; renderer()-&gt;theme().stateChanged(*renderer(), ControlStates::PressedState))
 670         reactsToPress = true;
 671 
 672     // The rest of this function implements a feature that only works if the
 673     // platform supports immediate invalidations on the ChromeClient, so bail if
 674     // that isn&#39;t supported.
 675     if (!document().page()-&gt;chrome().client().supportsImmediateInvalidation())
 676         return;
 677 
 678     if (reactsToPress &amp;&amp; pause) {
 679         // The delay here is subtle. It relies on an assumption, namely that the amount of time it takes
 680         // to repaint the &quot;down&quot; state of the control is about the same time as it would take to repaint the
 681         // &quot;up&quot; state. Once you assume this, you can just delay for 100ms - that time (assuming that after you
 682         // leave this method, it will be about that long before the flush of the up state happens again).
 683 #ifdef HAVE_FUNC_USLEEP
 684         MonotonicTime startTime = MonotonicTime::now();
 685 #endif
 686 
 687         document().updateStyleIfNeeded();
 688 
 689         // Do an immediate repaint.
 690         if (renderer())
 691             renderer()-&gt;repaint();
 692 
 693         // FIXME: Come up with a less ridiculous way of doing this.
 694 #ifdef HAVE_FUNC_USLEEP
 695         // Now pause for a small amount of time (1/10th of a second from before we repainted in the pressed state)
 696         Seconds remainingTime = 100_ms - (MonotonicTime::now() - startTime);
 697         if (remainingTime &gt; 0_s)
 698             usleep(static_cast&lt;useconds_t&gt;(remainingTime.microseconds()));
 699 #endif
 700     }
 701 }
 702 
 703 void Element::setFocus(bool flag)
 704 {
 705     if (flag == focused())
 706         return;
 707 
 708     document().userActionElements().setFocused(*this, flag);
 709     invalidateStyleForSubtree();
 710 
 711     // Shadow host with a slot that contain focused element is not considered focused.
 712     for (auto* root = containingShadowRoot(); root; root = root-&gt;host()-&gt;containingShadowRoot()) {
 713         root-&gt;setContainsFocusedElement(flag);
 714         root-&gt;host()-&gt;invalidateStyle();
 715     }
 716 
 717     for (Element* element = this; element; element = element-&gt;parentElementInComposedTree())
 718         element-&gt;setHasFocusWithin(flag);
 719 }
 720 
 721 void Element::setHovered(bool flag)
 722 {
 723     if (flag == hovered())
 724         return;
 725 
 726     document().userActionElements().setHovered(*this, flag);
 727 
 728     auto* style = renderOrDisplayContentsStyle();
 729     if (style &amp;&amp; (style-&gt;affectedByHover() || childrenAffectedByHover()))
 730         invalidateStyleForSubtree();
 731 
 732     if (!renderer()) {
 733         // When setting hover to false, the style needs to be recalc&#39;d even when
 734         // there&#39;s no renderer (imagine setting display:none in the :hover class,
 735         // if a nil renderer would prevent this element from recalculating its
 736         // style, it would never go back to its normal style and remain
 737         // stuck in its hovered style).
 738         if (!flag &amp;&amp; !style)
 739             invalidateStyleForSubtree();
 740 
 741         return;
 742     }
 743 
 744     if (style-&gt;hasAppearance())
 745         renderer()-&gt;theme().stateChanged(*renderer(), ControlStates::HoverState);
 746 }
 747 
 748 inline ScrollAlignment toScrollAlignmentForInlineDirection(Optional&lt;ScrollLogicalPosition&gt; position, WritingMode writingMode, bool isLTR)
 749 {
 750     switch (position.valueOr(ScrollLogicalPosition::Nearest)) {
 751     case ScrollLogicalPosition::Start: {
 752         switch (writingMode) {
 753         case TopToBottomWritingMode:
 754         case BottomToTopWritingMode: {
 755             return isLTR ? ScrollAlignment::alignLeftAlways : ScrollAlignment::alignRightAlways;
 756         }
 757         case LeftToRightWritingMode:
 758         case RightToLeftWritingMode: {
 759             return isLTR ? ScrollAlignment::alignTopAlways : ScrollAlignment::alignBottomAlways;
 760         }
 761         default:
 762             ASSERT_NOT_REACHED();
 763             return ScrollAlignment::alignLeftAlways;
 764         }
 765     }
 766     case ScrollLogicalPosition::Center:
 767         return ScrollAlignment::alignCenterAlways;
 768     case ScrollLogicalPosition::End: {
 769         switch (writingMode) {
 770         case TopToBottomWritingMode:
 771         case BottomToTopWritingMode: {
 772             return isLTR ? ScrollAlignment::alignRightAlways : ScrollAlignment::alignLeftAlways;
 773         }
 774         case LeftToRightWritingMode:
 775         case RightToLeftWritingMode: {
 776             return isLTR ? ScrollAlignment::alignBottomAlways : ScrollAlignment::alignTopAlways;
 777         }
 778         default:
 779             ASSERT_NOT_REACHED();
 780             return ScrollAlignment::alignRightAlways;
 781         }
 782     }
 783     case ScrollLogicalPosition::Nearest:
 784         return ScrollAlignment::alignToEdgeIfNeeded;
 785     default:
 786         ASSERT_NOT_REACHED();
 787         return ScrollAlignment::alignToEdgeIfNeeded;
 788     }
 789 }
 790 
 791 inline ScrollAlignment toScrollAlignmentForBlockDirection(Optional&lt;ScrollLogicalPosition&gt; position, WritingMode writingMode)
 792 {
 793     switch (position.valueOr(ScrollLogicalPosition::Start)) {
 794     case ScrollLogicalPosition::Start: {
 795         switch (writingMode) {
 796         case TopToBottomWritingMode:
 797             return ScrollAlignment::alignTopAlways;
 798         case BottomToTopWritingMode:
 799             return ScrollAlignment::alignBottomAlways;
 800         case LeftToRightWritingMode:
 801             return ScrollAlignment::alignLeftAlways;
 802         case RightToLeftWritingMode:
 803             return ScrollAlignment::alignRightAlways;
 804         default:
 805             ASSERT_NOT_REACHED();
 806             return ScrollAlignment::alignTopAlways;
 807         }
 808     }
 809     case ScrollLogicalPosition::Center:
 810         return ScrollAlignment::alignCenterAlways;
 811     case ScrollLogicalPosition::End: {
 812         switch (writingMode) {
 813         case TopToBottomWritingMode:
 814             return ScrollAlignment::alignBottomAlways;
 815         case BottomToTopWritingMode:
 816             return ScrollAlignment::alignTopAlways;
 817         case LeftToRightWritingMode:
 818             return ScrollAlignment::alignRightAlways;
 819         case RightToLeftWritingMode:
 820             return ScrollAlignment::alignLeftAlways;
 821         default:
 822             ASSERT_NOT_REACHED();
 823             return ScrollAlignment::alignBottomAlways;
 824         }
 825     }
 826     case ScrollLogicalPosition::Nearest:
 827         return ScrollAlignment::alignToEdgeIfNeeded;
 828     default:
 829         ASSERT_NOT_REACHED();
 830         return ScrollAlignment::alignToEdgeIfNeeded;
 831     }
 832 }
 833 
 834 void Element::scrollIntoView(Optional&lt;Variant&lt;bool, ScrollIntoViewOptions&gt;&gt;&amp;&amp; arg)
 835 {
 836     document().updateLayoutIgnorePendingStylesheets();
 837 
 838     if (!renderer())
 839         return;
 840 
 841     bool insideFixed;
 842     LayoutRect absoluteBounds = renderer()-&gt;absoluteAnchorRect(&amp;insideFixed);
 843 
 844     // FIXME(webkit.org/b/188043): Support ScrollBehavior.
 845     ScrollIntoViewOptions options;
 846     if (arg) {
 847         auto value = arg.value();
 848         if (WTF::holds_alternative&lt;ScrollIntoViewOptions&gt;(value))
 849             options = WTF::get&lt;ScrollIntoViewOptions&gt;(value);
 850         else if (!WTF::get&lt;bool&gt;(value))
 851             options.blockPosition = ScrollLogicalPosition::End;
 852     }
 853 
 854     auto writingMode = renderer()-&gt;style().writingMode();
 855     ScrollAlignment alignX = toScrollAlignmentForInlineDirection(options.inlinePosition, writingMode, renderer()-&gt;style().isLeftToRightDirection());
 856     ScrollAlignment alignY = toScrollAlignmentForBlockDirection(options.blockPosition, writingMode);
 857 
 858     bool isHorizontal = renderer()-&gt;style().isHorizontalWritingMode();
 859     ScrollRectToVisibleOptions visibleOptions {
 860         SelectionRevealMode::Reveal,
 861         isHorizontal ? alignX : alignY,
 862         isHorizontal ? alignY : alignX,
 863         ShouldAllowCrossOriginScrolling::No
 864     };
 865     renderer()-&gt;scrollRectToVisible(absoluteBounds, insideFixed, visibleOptions);
 866 }
 867 
 868 void Element::scrollIntoView(bool alignToTop)
 869 {
 870     document().updateLayoutIgnorePendingStylesheets();
 871 
 872     if (!renderer())
 873         return;
 874 
 875     bool insideFixed;
 876     LayoutRect absoluteBounds = renderer()-&gt;absoluteAnchorRect(&amp;insideFixed);
 877     // Align to the top / bottom and to the closest edge.
 878     if (alignToTop)
 879         renderer()-&gt;scrollRectToVisible(absoluteBounds, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignToEdgeIfNeeded, ScrollAlignment::alignTopAlways, ShouldAllowCrossOriginScrolling::No });
 880     else
 881         renderer()-&gt;scrollRectToVisible(absoluteBounds, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignToEdgeIfNeeded, ScrollAlignment::alignBottomAlways, ShouldAllowCrossOriginScrolling::No });
 882 }
 883 
 884 void Element::scrollIntoViewIfNeeded(bool centerIfNeeded)
 885 {
 886     document().updateLayoutIgnorePendingStylesheets();
 887 
 888     if (!renderer())
 889         return;
 890 
 891     bool insideFixed;
 892     LayoutRect absoluteBounds = renderer()-&gt;absoluteAnchorRect(&amp;insideFixed);
 893     if (centerIfNeeded)
 894         renderer()-&gt;scrollRectToVisible(absoluteBounds, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignCenterIfNeeded, ScrollAlignment::alignCenterIfNeeded, ShouldAllowCrossOriginScrolling::No });
 895     else
 896         renderer()-&gt;scrollRectToVisible(absoluteBounds, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignToEdgeIfNeeded, ScrollAlignment::alignToEdgeIfNeeded, ShouldAllowCrossOriginScrolling::No });
 897 }
 898 
 899 void Element::scrollIntoViewIfNotVisible(bool centerIfNotVisible)
 900 {
 901     document().updateLayoutIgnorePendingStylesheets();
 902 
 903     if (!renderer())
 904         return;
 905 
 906     bool insideFixed;
 907     LayoutRect absoluteBounds = renderer()-&gt;absoluteAnchorRect(&amp;insideFixed);
 908     if (centerIfNotVisible)
 909         renderer()-&gt;scrollRectToVisible(absoluteBounds, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignCenterIfNotVisible, ScrollAlignment::alignCenterIfNotVisible, ShouldAllowCrossOriginScrolling::No });
 910     else
 911         renderer()-&gt;scrollRectToVisible(absoluteBounds, insideFixed, { SelectionRevealMode::Reveal, ScrollAlignment::alignToEdgeIfNotVisible, ScrollAlignment::alignToEdgeIfNotVisible, ShouldAllowCrossOriginScrolling::No });
 912 }
 913 
 914 void Element::scrollBy(const ScrollToOptions&amp; options)
 915 {
 916     ScrollToOptions scrollToOptions = normalizeNonFiniteCoordinatesOrFallBackTo(options, 0, 0);
 917     scrollToOptions.left.value() += scrollLeft();
 918     scrollToOptions.top.value() += scrollTop();
 919     scrollTo(scrollToOptions);
 920 }
 921 
 922 void Element::scrollBy(double x, double y)
 923 {
 924     scrollBy({ x, y });
 925 }
 926 
 927 void Element::scrollTo(const ScrollToOptions&amp; options, ScrollClamping clamping)
 928 {
 929     if (!document().settings().CSSOMViewScrollingAPIEnabled()) {
 930         // If the element is the root element and document is in quirks mode, terminate these steps.
 931         // Note that WebKit always uses quirks mode document scrolling behavior. See Document::scrollingElement().
 932         if (this == document().documentElement())
 933             return;
 934     }
 935 
 936     document().updateLayoutIgnorePendingStylesheets();
 937 
 938     if (document().scrollingElement() == this) {
 939         // If the element is the scrolling element and is not potentially scrollable,
 940         // invoke scroll() on window with options as the only argument, and terminate these steps.
 941         // FIXME: Scrolling an independently scrollable body is broken: webkit.org/b/161612.
 942         auto window = makeRefPtr(document().domWindow());
 943         if (!window)
 944             return;
 945 
 946         window-&gt;scrollTo(options, clamping);
 947         return;
 948     }
 949 
 950     // If the element does not have any associated CSS layout box, the element has no associated scrolling box,
 951     // or the element has no overflow, terminate these steps.
 952     RenderBox* renderer = renderBox();
 953     if (!renderer || !renderer-&gt;hasOverflowClip())
 954         return;
 955 
 956     ScrollToOptions scrollToOptions = normalizeNonFiniteCoordinatesOrFallBackTo(options,
 957         adjustForAbsoluteZoom(renderer-&gt;scrollLeft(), *renderer),
 958         adjustForAbsoluteZoom(renderer-&gt;scrollTop(), *renderer)
 959     );
 960     renderer-&gt;setScrollLeft(clampToInteger(scrollToOptions.left.value() * renderer-&gt;style().effectiveZoom()), ScrollType::Programmatic, clamping);
 961     renderer-&gt;setScrollTop(clampToInteger(scrollToOptions.top.value() * renderer-&gt;style().effectiveZoom()), ScrollType::Programmatic, clamping);
 962 }
 963 
 964 void Element::scrollTo(double x, double y)
 965 {
 966     scrollTo({ x, y });
 967 }
 968 
 969 void Element::scrollByUnits(int units, ScrollGranularity granularity)
 970 {
 971     document().updateLayoutIgnorePendingStylesheets();
 972 
 973     auto* renderer = this-&gt;renderer();
 974     if (!renderer)
 975         return;
 976 
 977     if (!renderer-&gt;hasOverflowClip())
 978         return;
 979 
 980     ScrollDirection direction = ScrollDown;
 981     if (units &lt; 0) {
 982         direction = ScrollUp;
 983         units = -units;
 984     }
 985     Element* stopElement = this;
 986     downcast&lt;RenderBox&gt;(*renderer).scroll(direction, granularity, units, &amp;stopElement);
 987 }
 988 
 989 void Element::scrollByLines(int lines)
 990 {
 991     scrollByUnits(lines, ScrollByLine);
 992 }
 993 
 994 void Element::scrollByPages(int pages)
 995 {
 996     scrollByUnits(pages, ScrollByPage);
 997 }
 998 
 999 static double localZoomForRenderer(const RenderElement&amp; renderer)
1000 {
1001     // FIXME: This does the wrong thing if two opposing zooms are in effect and canceled each
1002     // other out, but the alternative is that we&#39;d have to crawl up the whole render tree every
1003     // time (or store an additional bit in the RenderStyle to indicate that a zoom was specified).
1004     double zoomFactor = 1;
1005     if (renderer.style().effectiveZoom() != 1) {
1006         // Need to find the nearest enclosing RenderElement that set up
1007         // a differing zoom, and then we divide our result by it to eliminate the zoom.
1008         const RenderElement* prev = &amp;renderer;
1009         for (RenderElement* curr = prev-&gt;parent(); curr; curr = curr-&gt;parent()) {
1010             if (curr-&gt;style().effectiveZoom() != prev-&gt;style().effectiveZoom()) {
1011                 zoomFactor = prev-&gt;style().zoom();
1012                 break;
1013             }
1014             prev = curr;
1015         }
1016         if (prev-&gt;isRenderView())
1017             zoomFactor = prev-&gt;style().zoom();
1018     }
1019     return zoomFactor;
1020 }
1021 
1022 static double adjustForLocalZoom(LayoutUnit value, const RenderElement&amp; renderer, double&amp; zoomFactor)
1023 {
1024     zoomFactor = localZoomForRenderer(renderer);
1025     if (zoomFactor == 1)
1026         return value.toDouble();
1027     return value.toDouble() / zoomFactor;
1028 }
1029 
1030 static int adjustContentsScrollPositionOrSizeForZoom(int value, const Frame&amp; frame)
1031 {
1032     double zoomFactor = frame.pageZoomFactor() * frame.frameScaleFactor();
1033     if (zoomFactor == 1)
1034         return value;
1035     // FIXME (webkit.org/b/189397): Why can&#39;t we just ceil/floor?
1036     // Needed because of truncation (rather than rounding) when scaling up.
1037     if (zoomFactor &gt; 1)
1038         value++;
1039     return static_cast&lt;int&gt;(value / zoomFactor);
1040 }
1041 
1042 enum LegacyCSSOMElementMetricsRoundingStrategy { Round, Floor };
1043 
1044 static bool subpixelMetricsEnabled(const Document&amp; document)
1045 {
1046     return document.settings().subpixelCSSOMElementMetricsEnabled();
1047 }
1048 
1049 static double convertToNonSubpixelValueIfNeeded(double value, const Document&amp; document, LegacyCSSOMElementMetricsRoundingStrategy roundStrategy = Round)
1050 {
1051     return subpixelMetricsEnabled(document) ? value : roundStrategy == Round ? round(value) : floor(value);
1052 }
1053 
1054 static double adjustOffsetForZoomAndSubpixelLayout(RenderBoxModelObject* renderer, const LayoutUnit&amp; offset)
1055 {
1056     LayoutUnit offsetLeft = subpixelMetricsEnabled(renderer-&gt;document()) ? offset : LayoutUnit(roundToInt(offset));
1057     double zoomFactor = 1;
1058     double offsetLeftAdjustedWithZoom = adjustForLocalZoom(offsetLeft, *renderer, zoomFactor);
1059     return convertToNonSubpixelValueIfNeeded(offsetLeftAdjustedWithZoom, renderer-&gt;document(), zoomFactor == 1 ? Floor : Round);
1060 }
1061 
1062 static HashSet&lt;TreeScope*&gt; collectAncestorTreeScopeAsHashSet(Node&amp; node)
1063 {
1064     HashSet&lt;TreeScope*&gt; ancestors;
1065     for (auto* currentScope = &amp;node.treeScope(); currentScope; currentScope = currentScope-&gt;parentTreeScope())
1066         ancestors.add(currentScope);
1067     return ancestors;
1068 }
1069 
1070 double Element::offsetLeftForBindings()
1071 {
1072     auto offset = offsetLeft();
1073 
1074     auto parent = makeRefPtr(offsetParent());
1075     if (!parent || !parent-&gt;isInShadowTree())
1076         return offset;
1077 
1078     ASSERT(&amp;parent-&gt;document() == &amp;document());
1079     if (&amp;parent-&gt;treeScope() == &amp;treeScope())
1080         return offset;
1081 
1082     auto ancestorTreeScopes = collectAncestorTreeScopeAsHashSet(*this);
1083     while (parent &amp;&amp; !ancestorTreeScopes.contains(&amp;parent-&gt;treeScope())) {
1084         offset += parent-&gt;offsetLeft();
1085         parent = parent-&gt;offsetParent();
1086     }
1087 
1088     return offset;
1089 }
1090 
1091 double Element::offsetLeft()
1092 {
1093     document().updateLayoutIgnorePendingStylesheets();
1094     if (RenderBoxModelObject* renderer = renderBoxModelObject())
1095         return adjustOffsetForZoomAndSubpixelLayout(renderer, renderer-&gt;offsetLeft());
1096     return 0;
1097 }
1098 
1099 double Element::offsetTopForBindings()
1100 {
1101     auto offset = offsetTop();
1102 
1103     auto parent = makeRefPtr(offsetParent());
1104     if (!parent || !parent-&gt;isInShadowTree())
1105         return offset;
1106 
1107     ASSERT(&amp;parent-&gt;document() == &amp;document());
1108     if (&amp;parent-&gt;treeScope() == &amp;treeScope())
1109         return offset;
1110 
1111     auto ancestorTreeScopes = collectAncestorTreeScopeAsHashSet(*this);
1112     while (parent &amp;&amp; !ancestorTreeScopes.contains(&amp;parent-&gt;treeScope())) {
1113         offset += parent-&gt;offsetTop();
1114         parent = parent-&gt;offsetParent();
1115     }
1116 
1117     return offset;
1118 }
1119 
1120 double Element::offsetTop()
1121 {
1122     document().updateLayoutIgnorePendingStylesheets();
1123     if (RenderBoxModelObject* renderer = renderBoxModelObject())
1124         return adjustOffsetForZoomAndSubpixelLayout(renderer, renderer-&gt;offsetTop());
1125     return 0;
1126 }
1127 
1128 double Element::offsetWidth()
1129 {
1130     document().updateLayoutIfDimensionsOutOfDate(*this, WidthDimensionsCheck);
1131     if (RenderBoxModelObject* renderer = renderBoxModelObject()) {
1132         LayoutUnit offsetWidth = subpixelMetricsEnabled(renderer-&gt;document()) ? renderer-&gt;offsetWidth() : LayoutUnit(roundToInt(renderer-&gt;offsetWidth()));
1133         return convertToNonSubpixelValueIfNeeded(adjustLayoutUnitForAbsoluteZoom(offsetWidth, *renderer).toDouble(), renderer-&gt;document());
1134     }
1135     return 0;
1136 }
1137 
1138 double Element::offsetHeight()
1139 {
1140     document().updateLayoutIfDimensionsOutOfDate(*this, HeightDimensionsCheck);
1141     if (RenderBoxModelObject* renderer = renderBoxModelObject()) {
1142         LayoutUnit offsetHeight = subpixelMetricsEnabled(renderer-&gt;document()) ? renderer-&gt;offsetHeight() : LayoutUnit(roundToInt(renderer-&gt;offsetHeight()));
1143         return convertToNonSubpixelValueIfNeeded(adjustLayoutUnitForAbsoluteZoom(offsetHeight, *renderer).toDouble(), renderer-&gt;document());
1144     }
1145     return 0;
1146 }
1147 
1148 Element* Element::offsetParentForBindings()
1149 {
1150     Element* element = offsetParent();
1151     if (!element || !element-&gt;isInShadowTree())
1152         return element;
1153     while (element &amp;&amp; !isDescendantOrShadowDescendantOf(&amp;element-&gt;rootNode()))
1154         element = element-&gt;offsetParent();
1155     return element;
1156 }
1157 
1158 Element* Element::offsetParent()
1159 {
1160     document().updateLayoutIgnorePendingStylesheets();
1161     auto renderer = this-&gt;renderer();
1162     if (!renderer)
1163         return nullptr;
1164     auto offsetParent = renderer-&gt;offsetParent();
1165     if (!offsetParent)
1166         return nullptr;
1167     return offsetParent-&gt;element();
1168 }
1169 
1170 double Element::clientLeft()
1171 {
1172     document().updateLayoutIgnorePendingStylesheets();
1173 
1174     if (auto* renderer = renderBox()) {
1175         LayoutUnit clientLeft = subpixelMetricsEnabled(renderer-&gt;document()) ? renderer-&gt;clientLeft() : LayoutUnit(roundToInt(renderer-&gt;clientLeft()));
1176         return convertToNonSubpixelValueIfNeeded(adjustLayoutUnitForAbsoluteZoom(clientLeft, *renderer).toDouble(), renderer-&gt;document());
1177     }
1178     return 0;
1179 }
1180 
1181 double Element::clientTop()
1182 {
1183     document().updateLayoutIgnorePendingStylesheets();
1184 
1185     if (auto* renderer = renderBox()) {
1186         LayoutUnit clientTop = subpixelMetricsEnabled(renderer-&gt;document()) ? renderer-&gt;clientTop() : LayoutUnit(roundToInt(renderer-&gt;clientTop()));
1187         return convertToNonSubpixelValueIfNeeded(adjustLayoutUnitForAbsoluteZoom(clientTop, *renderer).toDouble(), renderer-&gt;document());
1188     }
1189     return 0;
1190 }
1191 
1192 double Element::clientWidth()
1193 {
1194     document().updateLayoutIfDimensionsOutOfDate(*this, WidthDimensionsCheck);
1195 
1196     if (!document().hasLivingRenderTree())
1197         return 0;
1198 
1199     RenderView&amp; renderView = *document().renderView();
1200 
1201     // When in strict mode, clientWidth for the document element should return the width of the containing frame.
1202     // When in quirks mode, clientWidth for the body element should return the width of the containing frame.
1203     bool inQuirksMode = document().inQuirksMode();
1204     if ((!inQuirksMode &amp;&amp; document().documentElement() == this) || (inQuirksMode &amp;&amp; isHTMLElement() &amp;&amp; document().bodyOrFrameset() == this))
1205         return adjustForAbsoluteZoom(renderView.frameView().layoutWidth(), renderView);
1206 
1207     if (RenderBox* renderer = renderBox()) {
1208         LayoutUnit clientWidth = subpixelMetricsEnabled(renderer-&gt;document()) ? renderer-&gt;clientWidth() : LayoutUnit(roundToInt(renderer-&gt;clientWidth()));
1209         // clientWidth/Height is the visual portion of the box content, not including
1210         // borders or scroll bars, but includes padding. And per
1211         // https://www.w3.org/TR/CSS2/tables.html#model,
1212         // table wrapper box is a principal block box that contains the table box
1213         // itself and any caption boxes, and table grid box is a block-level box that
1214         // contains the table&#39;s internal table boxes. When table&#39;s border is specified
1215         // in CSS, the border is added to table grid box, not table wrapper box.
1216         // Currently, WebKit doesn&#39;t have table wrapper box, and we are supposed to
1217         // retrieve clientWidth/Height from table wrapper box, not table grid box. So
1218         // when we retrieve clientWidth/Height, it includes table&#39;s border size.
1219         if (renderer-&gt;isTable())
1220             clientWidth += renderer-&gt;borderLeft() + renderer-&gt;borderRight();
1221         return convertToNonSubpixelValueIfNeeded(adjustLayoutUnitForAbsoluteZoom(clientWidth, *renderer).toDouble(), renderer-&gt;document());
1222     }
1223     return 0;
1224 }
1225 
1226 double Element::clientHeight()
1227 {
1228     document().updateLayoutIfDimensionsOutOfDate(*this, HeightDimensionsCheck);
1229     if (!document().hasLivingRenderTree())
1230         return 0;
1231 
1232     RenderView&amp; renderView = *document().renderView();
1233 
1234     // When in strict mode, clientHeight for the document element should return the height of the containing frame.
1235     // When in quirks mode, clientHeight for the body element should return the height of the containing frame.
1236     bool inQuirksMode = document().inQuirksMode();
1237     if ((!inQuirksMode &amp;&amp; document().documentElement() == this) || (inQuirksMode &amp;&amp; isHTMLElement() &amp;&amp; document().bodyOrFrameset() == this))
1238         return adjustForAbsoluteZoom(renderView.frameView().layoutHeight(), renderView);
1239 
1240     if (RenderBox* renderer = renderBox()) {
1241         LayoutUnit clientHeight = subpixelMetricsEnabled(renderer-&gt;document()) ? renderer-&gt;clientHeight() : LayoutUnit(roundToInt(renderer-&gt;clientHeight()));
1242         // clientWidth/Height is the visual portion of the box content, not including
1243         // borders or scroll bars, but includes padding. And per
1244         // https://www.w3.org/TR/CSS2/tables.html#model,
1245         // table wrapper box is a principal block box that contains the table box
1246         // itself and any caption boxes, and table grid box is a block-level box that
1247         // contains the table&#39;s internal table boxes. When table&#39;s border is specified
1248         // in CSS, the border is added to table grid box, not table wrapper box.
1249         // Currently, WebKit doesn&#39;t have table wrapper box, and we are supposed to
1250         // retrieve clientWidth/Height from table wrapper box, not table grid box. So
1251         // when we retrieve clientWidth/Height, it includes table&#39;s border size.
1252         if (renderer-&gt;isTable())
1253             clientHeight += renderer-&gt;borderTop() + renderer-&gt;borderBottom();
1254         return convertToNonSubpixelValueIfNeeded(adjustLayoutUnitForAbsoluteZoom(clientHeight, *renderer).toDouble(), renderer-&gt;document());
1255     }
1256     return 0;
1257 }
1258 
1259 ALWAYS_INLINE Frame* Element::documentFrameWithNonNullView() const
1260 {
1261     auto* frame = document().frame();
1262     return frame &amp;&amp; frame-&gt;view() ? frame : nullptr;
1263 }
1264 
1265 int Element::scrollLeft()
1266 {
1267     document().updateLayoutIgnorePendingStylesheets();
1268 
1269     if (document().scrollingElement() == this) {
1270         if (auto* frame = documentFrameWithNonNullView())
1271             return adjustContentsScrollPositionOrSizeForZoom(frame-&gt;view()-&gt;contentsScrollPosition().x(), *frame);
1272         return 0;
1273     }
1274 
1275     if (auto* renderer = renderBox())
1276         return adjustForAbsoluteZoom(renderer-&gt;scrollLeft(), *renderer);
1277     return 0;
1278 }
1279 
1280 int Element::scrollTop()
1281 {
1282     document().updateLayoutIgnorePendingStylesheets();
1283 
1284     if (document().scrollingElement() == this) {
1285         if (auto* frame = documentFrameWithNonNullView())
1286             return adjustContentsScrollPositionOrSizeForZoom(frame-&gt;view()-&gt;contentsScrollPosition().y(), *frame);
1287         return 0;
1288     }
1289 
1290     if (RenderBox* renderer = renderBox())
1291         return adjustForAbsoluteZoom(renderer-&gt;scrollTop(), *renderer);
1292     return 0;
1293 }
1294 
1295 void Element::setScrollLeft(int newLeft)
1296 {
1297     document().updateLayoutIgnorePendingStylesheets();
1298 
1299     if (document().scrollingElement() == this) {
1300         if (auto* frame = documentFrameWithNonNullView())
1301             frame-&gt;view()-&gt;setScrollPosition(IntPoint(static_cast&lt;int&gt;(newLeft * frame-&gt;pageZoomFactor() * frame-&gt;frameScaleFactor()), frame-&gt;view()-&gt;scrollY()));
1302         return;
1303     }
1304 
1305     if (auto* renderer = renderBox()) {
1306         renderer-&gt;setScrollLeft(static_cast&lt;int&gt;(newLeft * renderer-&gt;style().effectiveZoom()), ScrollType::Programmatic);
1307         if (auto* scrollableArea = renderer-&gt;layer())
1308             scrollableArea-&gt;setScrollShouldClearLatchedState(true);
1309     }
1310 }
1311 
1312 void Element::setScrollTop(int newTop)
1313 {
1314     document().updateLayoutIgnorePendingStylesheets();
1315 
1316     if (document().scrollingElement() == this) {
1317         if (auto* frame = documentFrameWithNonNullView())
1318             frame-&gt;view()-&gt;setScrollPosition(IntPoint(frame-&gt;view()-&gt;scrollX(), static_cast&lt;int&gt;(newTop * frame-&gt;pageZoomFactor() * frame-&gt;frameScaleFactor())));
1319         return;
1320     }
1321 
1322     if (auto* renderer = renderBox()) {
1323         renderer-&gt;setScrollTop(static_cast&lt;int&gt;(newTop * renderer-&gt;style().effectiveZoom()), ScrollType::Programmatic);
1324         if (auto* scrollableArea = renderer-&gt;layer())
1325             scrollableArea-&gt;setScrollShouldClearLatchedState(true);
1326     }
1327 }
1328 
1329 int Element::scrollWidth()
1330 {
1331     document().updateLayoutIfDimensionsOutOfDate(*this, WidthDimensionsCheck);
1332 
1333     if (document().scrollingElement() == this) {
1334         // FIXME (webkit.org/b/182289): updateLayoutIfDimensionsOutOfDate seems to ignore zoom level change.
1335         document().updateLayoutIgnorePendingStylesheets();
1336         if (auto* frame = documentFrameWithNonNullView())
1337             return adjustContentsScrollPositionOrSizeForZoom(frame-&gt;view()-&gt;contentsWidth(), *frame);
1338         return 0;
1339     }
1340 
1341     if (auto* renderer = renderBox())
1342         return adjustForAbsoluteZoom(renderer-&gt;scrollWidth(), *renderer);
1343     return 0;
1344 }
1345 
1346 int Element::scrollHeight()
1347 {
1348     document().updateLayoutIfDimensionsOutOfDate(*this, HeightDimensionsCheck);
1349 
1350     if (document().scrollingElement() == this) {
1351         // FIXME (webkit.org/b/182289): updateLayoutIfDimensionsOutOfDate seems to ignore zoom level change.
1352         document().updateLayoutIgnorePendingStylesheets();
1353         if (auto* frame = documentFrameWithNonNullView())
1354             return adjustContentsScrollPositionOrSizeForZoom(frame-&gt;view()-&gt;contentsHeight(), *frame);
1355         return 0;
1356     }
1357 
1358     if (auto* renderer = renderBox())
1359         return adjustForAbsoluteZoom(renderer-&gt;scrollHeight(), *renderer);
1360     return 0;
1361 }
1362 
1363 IntRect Element::boundsInRootViewSpace()
1364 {
1365     document().updateLayoutIgnorePendingStylesheets();
1366 
1367     FrameView* view = document().view();
1368     if (!view)
1369         return IntRect();
1370 
1371     Vector&lt;FloatQuad&gt; quads;
1372 
1373     if (isSVGElement() &amp;&amp; renderer()) {
1374         // Get the bounding rectangle from the SVG model.
1375         SVGElement&amp; svgElement = downcast&lt;SVGElement&gt;(*this);
1376         FloatRect localRect;
1377         if (svgElement.getBoundingBox(localRect))
1378             quads.append(renderer()-&gt;localToAbsoluteQuad(localRect));
1379     } else {
1380         // Get the bounding rectangle from the box model.
1381         if (renderBoxModelObject())
1382             renderBoxModelObject()-&gt;absoluteQuads(quads);
1383     }
1384 
1385     if (quads.isEmpty())
1386         return IntRect();
1387 
1388     IntRect result = quads[0].enclosingBoundingBox();
1389     for (size_t i = 1; i &lt; quads.size(); ++i)
1390         result.unite(quads[i].enclosingBoundingBox());
1391 
1392     result = view-&gt;contentsToRootView(result);
1393     return result;
1394 }
1395 
1396 static bool layoutOverflowRectContainsAllDescendants(const RenderBox&amp; renderBox)
1397 {
1398     if (renderBox.isRenderView())
1399         return true;
1400 
1401     if (!renderBox.element())
1402         return false;
1403 
1404     // If there are any position:fixed inside of us, game over.
1405     if (auto* viewPositionedObjects = renderBox.view().positionedObjects()) {
1406         for (auto* positionedBox : *viewPositionedObjects) {
1407             if (positionedBox == &amp;renderBox)
1408                 continue;
1409             if (positionedBox-&gt;isFixedPositioned() &amp;&amp; renderBox.element()-&gt;contains(positionedBox-&gt;element()))
1410                 return false;
1411         }
1412     }
1413 
1414     if (renderBox.canContainAbsolutelyPositionedObjects()) {
1415         // Our layout overflow will include all descendant positioned elements.
1416         return true;
1417     }
1418 
1419     // This renderer may have positioned descendants whose containing block is some ancestor.
1420     if (auto* containingBlock = renderBox.containingBlockForAbsolutePosition()) {
1421         if (auto* positionedObjects = containingBlock-&gt;positionedObjects()) {
1422             for (auto* positionedBox : *positionedObjects) {
1423                 if (positionedBox == &amp;renderBox)
1424                     continue;
1425                 if (renderBox.element()-&gt;contains(positionedBox-&gt;element()))
1426                     return false;
1427             }
1428         }
1429     }
1430     return false;
1431 }
1432 
1433 LayoutRect Element::absoluteEventBounds(bool&amp; boundsIncludeAllDescendantElements, bool&amp; includesFixedPositionElements)
1434 {
1435     boundsIncludeAllDescendantElements = false;
1436     includesFixedPositionElements = false;
1437 
1438     if (!renderer())
1439         return LayoutRect();
1440 
1441     LayoutRect result;
1442     if (isSVGElement()) {
1443         // Get the bounding rectangle from the SVG model.
1444         SVGElement&amp; svgElement = downcast&lt;SVGElement&gt;(*this);
1445         FloatRect localRect;
1446         if (svgElement.getBoundingBox(localRect, SVGLocatable::DisallowStyleUpdate))
1447             result = LayoutRect(renderer()-&gt;localToAbsoluteQuad(localRect, UseTransforms, &amp;includesFixedPositionElements).boundingBox());
1448     } else {
1449         auto* renderer = this-&gt;renderer();
1450         if (is&lt;RenderBox&gt;(renderer)) {
1451             auto&amp; box = downcast&lt;RenderBox&gt;(*renderer);
1452 
1453             bool computedBounds = false;
1454 
1455             if (RenderFragmentedFlow* fragmentedFlow = box.enclosingFragmentedFlow()) {
1456                 bool wasFixed = false;
1457                 Vector&lt;FloatQuad&gt; quads;
1458                 FloatRect localRect(0, 0, box.width(), box.height());
1459                 if (fragmentedFlow-&gt;absoluteQuadsForBox(quads, &amp;wasFixed, &amp;box, localRect.y(), localRect.maxY())) {
1460                     FloatRect quadBounds = quads[0].boundingBox();
1461                     for (size_t i = 1; i &lt; quads.size(); ++i)
1462                         quadBounds.unite(quads[i].boundingBox());
1463 
1464                     result = LayoutRect(quadBounds);
1465                     computedBounds = true;
1466                 } else {
1467                     // Probably columns. Just return the bounds of the multicol block for now.
1468                     // FIXME: this doesn&#39;t handle nested columns.
1469                     RenderElement* multicolContainer = fragmentedFlow-&gt;parent();
1470                     if (multicolContainer &amp;&amp; is&lt;RenderBox&gt;(multicolContainer)) {
1471                         auto overflowRect = downcast&lt;RenderBox&gt;(*multicolContainer).layoutOverflowRect();
1472                         result = LayoutRect(multicolContainer-&gt;localToAbsoluteQuad(FloatRect(overflowRect), UseTransforms, &amp;includesFixedPositionElements).boundingBox());
1473                         computedBounds = true;
1474                     }
1475                 }
1476             }
1477 
1478             if (!computedBounds) {
1479                 LayoutRect overflowRect = box.layoutOverflowRect();
1480                 result = LayoutRect(box.localToAbsoluteQuad(FloatRect(overflowRect), UseTransforms, &amp;includesFixedPositionElements).boundingBox());
1481                 boundsIncludeAllDescendantElements = layoutOverflowRectContainsAllDescendants(box);
1482             }
1483         } else
1484             result = LayoutRect(renderer-&gt;absoluteBoundingBoxRect(true /* useTransforms */, &amp;includesFixedPositionElements));
1485     }
1486 
1487     return result;
1488 }
1489 
1490 LayoutRect Element::absoluteEventBoundsOfElementAndDescendants(bool&amp; includesFixedPositionElements)
1491 {
1492     bool boundsIncludeDescendants;
1493     LayoutRect result = absoluteEventBounds(boundsIncludeDescendants, includesFixedPositionElements);
1494     if (boundsIncludeDescendants)
1495         return result;
1496 
1497     for (auto&amp; child : childrenOfType&lt;Element&gt;(*this)) {
1498         bool includesFixedPosition = false;
1499         LayoutRect childBounds = child.absoluteEventBoundsOfElementAndDescendants(includesFixedPosition);
1500         includesFixedPositionElements |= includesFixedPosition;
1501         result.unite(childBounds);
1502     }
1503 
1504     return result;
1505 }
1506 
1507 LayoutRect Element::absoluteEventHandlerBounds(bool&amp; includesFixedPositionElements)
1508 {
1509     // This is not web-exposed, so don&#39;t call the FOUC-inducing updateLayoutIgnorePendingStylesheets().
1510     FrameView* frameView = document().view();
1511     if (!frameView)
1512         return LayoutRect();
1513 
1514     return absoluteEventBoundsOfElementAndDescendants(includesFixedPositionElements);
1515 }
1516 
1517 static Optional&lt;std::pair&lt;RenderObject*, LayoutRect&gt;&gt; listBoxElementBoundingBox(Element&amp; element)
1518 {
1519     HTMLSelectElement* selectElement;
1520     bool isGroup;
1521     if (is&lt;HTMLOptionElement&gt;(element)) {
1522         selectElement = downcast&lt;HTMLOptionElement&gt;(element).ownerSelectElement();
1523         isGroup = false;
1524     } else if (is&lt;HTMLOptGroupElement&gt;(element)) {
1525         selectElement = downcast&lt;HTMLOptGroupElement&gt;(element).ownerSelectElement();
1526         isGroup = true;
1527     } else
1528         return WTF::nullopt;
1529 
1530     if (!selectElement || !selectElement-&gt;renderer() || !is&lt;RenderListBox&gt;(selectElement-&gt;renderer()))
1531         return WTF::nullopt;
1532 
1533     auto&amp; renderer = downcast&lt;RenderListBox&gt;(*selectElement-&gt;renderer());
1534     Optional&lt;LayoutRect&gt; boundingBox;
1535     int optionIndex = 0;
1536     for (auto* item : selectElement-&gt;listItems()) {
1537         if (item == &amp;element) {
1538             LayoutPoint additionOffset;
1539             boundingBox = renderer.itemBoundingBoxRect(additionOffset, optionIndex);
1540             if (!isGroup)
1541                 break;
1542         } else if (isGroup &amp;&amp; boundingBox) {
1543             if (item-&gt;parentNode() != &amp;element)
1544                 break;
1545             LayoutPoint additionOffset;
1546             boundingBox-&gt;setHeight(boundingBox-&gt;height() + renderer.itemBoundingBoxRect(additionOffset, optionIndex).height());
1547         }
1548         ++optionIndex;
1549     }
1550 
1551     if (!boundingBox)
1552         return WTF::nullopt;
1553 
1554     return std::pair&lt;RenderObject*, LayoutRect&gt; { &amp;renderer, boundingBox.value() };
1555 }
1556 
1557 Ref&lt;DOMRectList&gt; Element::getClientRects()
1558 {
1559     document().updateLayoutIgnorePendingStylesheets();
1560 
1561     RenderObject* renderer = this-&gt;renderer();
1562     Vector&lt;FloatQuad&gt; quads;
1563 
1564     if (auto pair = listBoxElementBoundingBox(*this)) {
1565         renderer = pair.value().first;
1566         quads.append(renderer-&gt;localToAbsoluteQuad(FloatQuad { pair.value().second }));
1567     } else if (auto* renderBoxModelObject = this-&gt;renderBoxModelObject())
1568         renderBoxModelObject-&gt;absoluteQuads(quads);
1569 
1570     // FIXME: Handle SVG elements.
1571     // FIXME: Handle table/inline-table with a caption.
1572 
1573     if (quads.isEmpty())
1574         return DOMRectList::create();
1575 
1576     document().convertAbsoluteToClientQuads(quads, renderer-&gt;style());
1577     return DOMRectList::create(quads);
1578 }
1579 
1580 Optional&lt;std::pair&lt;RenderObject*, FloatRect&gt;&gt; Element::boundingAbsoluteRectWithoutLayout()
1581 {
1582     RenderObject* renderer = this-&gt;renderer();
1583     Vector&lt;FloatQuad&gt; quads;
1584     if (isSVGElement() &amp;&amp; renderer &amp;&amp; !renderer-&gt;isSVGRoot()) {
1585         // Get the bounding rectangle from the SVG model.
1586         SVGElement&amp; svgElement = downcast&lt;SVGElement&gt;(*this);
1587         FloatRect localRect;
1588         if (svgElement.getBoundingBox(localRect))
1589             quads.append(renderer-&gt;localToAbsoluteQuad(localRect));
1590     } else if (auto pair = listBoxElementBoundingBox(*this)) {
1591         renderer = pair.value().first;
1592         quads.append(renderer-&gt;localToAbsoluteQuad(FloatQuad { pair.value().second }));
1593     } else if (auto* renderBoxModelObject = this-&gt;renderBoxModelObject())
1594         renderBoxModelObject-&gt;absoluteQuads(quads);
1595 
1596     if (quads.isEmpty())
1597         return WTF::nullopt;
1598 
1599     FloatRect result = quads[0].boundingBox();
1600     for (size_t i = 1; i &lt; quads.size(); ++i)
1601         result.unite(quads[i].boundingBox());
1602 
1603     return std::make_pair(renderer, result);
1604 }
1605 
1606 FloatRect Element::boundingClientRect()
1607 {
1608     document().updateLayoutIgnorePendingStylesheets();
1609     auto pair = boundingAbsoluteRectWithoutLayout();
1610     if (!pair)
1611         return { };
1612     RenderObject* renderer = pair-&gt;first;
1613     FloatRect result = pair-&gt;second;
1614     document().convertAbsoluteToClientRect(result, renderer-&gt;style());
1615     return result;
1616 }
1617 
1618 Ref&lt;DOMRect&gt; Element::getBoundingClientRect()
1619 {
1620     return DOMRect::create(boundingClientRect());
1621 }
1622 
1623 // Note that this is not web-exposed, and does not use the same coordinate system as getBoundingClientRect() and friends.
1624 IntRect Element::clientRect() const
1625 {
1626     if (RenderObject* renderer = this-&gt;renderer())
1627         return document().view()-&gt;contentsToRootView(renderer-&gt;absoluteBoundingBoxRect());
1628     return IntRect();
1629 }
1630 
1631 IntRect Element::screenRect() const
1632 {
1633     if (RenderObject* renderer = this-&gt;renderer())
1634         return document().view()-&gt;contentsToScreen(renderer-&gt;absoluteBoundingBoxRect());
1635     return IntRect();
1636 }
1637 
1638 const AtomString&amp; Element::getAttribute(const AtomString&amp; qualifiedName) const
1639 {
1640     if (!elementData())
1641         return nullAtom();
1642     synchronizeAttribute(qualifiedName);
1643     if (const Attribute* attribute = elementData()-&gt;findAttributeByName(qualifiedName, shouldIgnoreAttributeCase(*this)))
1644         return attribute-&gt;value();
1645     return nullAtom();
1646 }
1647 
1648 const AtomString&amp; Element::getAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName) const
1649 {
1650     return getAttribute(QualifiedName(nullAtom(), localName, namespaceURI));
1651 }
1652 
1653 // https://dom.spec.whatwg.org/#dom-element-toggleattribute
1654 ExceptionOr&lt;bool&gt; Element::toggleAttribute(const AtomString&amp; qualifiedName, Optional&lt;bool&gt; force)
1655 {
1656     if (!Document::isValidName(qualifiedName))
1657         return Exception { InvalidCharacterError };
1658 
1659     synchronizeAttribute(qualifiedName);
1660 
1661     auto caseAdjustedQualifiedName = shouldIgnoreAttributeCase(*this) ? qualifiedName.convertToASCIILowercase() : qualifiedName;
1662     unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(caseAdjustedQualifiedName, false) : ElementData::attributeNotFound;
1663     if (index == ElementData::attributeNotFound) {
1664         if (!force || *force) {
1665             setAttributeInternal(index, QualifiedName { nullAtom(), caseAdjustedQualifiedName, nullAtom() }, emptyString(), NotInSynchronizationOfLazyAttribute);
1666             return true;
1667         }
1668         return false;
1669     }
1670 
1671     if (!force || !*force) {
1672         removeAttributeInternal(index, NotInSynchronizationOfLazyAttribute);
1673         return false;
1674     }
1675     return true;
1676 }
1677 
1678 ExceptionOr&lt;void&gt; Element::setAttribute(const AtomString&amp; qualifiedName, const AtomString&amp; value)
1679 {
1680     if (!Document::isValidName(qualifiedName))
1681         return Exception { InvalidCharacterError };
1682 
1683     synchronizeAttribute(qualifiedName);
1684     auto caseAdjustedQualifiedName = shouldIgnoreAttributeCase(*this) ? qualifiedName.convertToASCIILowercase() : qualifiedName;
1685     unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(caseAdjustedQualifiedName, false) : ElementData::attributeNotFound;
1686     auto name = index != ElementData::attributeNotFound ? attributeAt(index).name() : QualifiedName { nullAtom(), caseAdjustedQualifiedName, nullAtom() };
1687     setAttributeInternal(index, name, value, NotInSynchronizationOfLazyAttribute);
1688 
1689     return { };
1690 }
1691 
1692 void Element::setAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
1693 {
1694     synchronizeAttribute(name);
1695     unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(name) : ElementData::attributeNotFound;
1696     setAttributeInternal(index, name, value, NotInSynchronizationOfLazyAttribute);
1697 }
1698 
1699 void Element::setAttributeWithoutSynchronization(const QualifiedName&amp; name, const AtomString&amp; value)
1700 {
1701     unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(name) : ElementData::attributeNotFound;
1702     setAttributeInternal(index, name, value, NotInSynchronizationOfLazyAttribute);
1703 }
1704 
1705 void Element::setSynchronizedLazyAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
1706 {
1707     unsigned index = elementData() ? elementData()-&gt;findAttributeIndexByName(name) : ElementData::attributeNotFound;
1708     setAttributeInternal(index, name, value, InSynchronizationOfLazyAttribute);
1709 }
1710 
1711 inline void Element::setAttributeInternal(unsigned index, const QualifiedName&amp; name, const AtomString&amp; newValue, SynchronizationOfLazyAttribute inSynchronizationOfLazyAttribute)
1712 {
1713     if (newValue.isNull()) {
1714         if (index != ElementData::attributeNotFound)
1715             removeAttributeInternal(index, inSynchronizationOfLazyAttribute);
1716         return;
1717     }
1718 
1719     if (index == ElementData::attributeNotFound) {
1720         addAttributeInternal(name, newValue, inSynchronizationOfLazyAttribute);
1721         return;
1722     }
1723 
1724     if (inSynchronizationOfLazyAttribute) {
1725         ensureUniqueElementData().attributeAt(index).setValue(newValue);
1726         return;
1727     }
1728 
1729     const Attribute&amp; attribute = attributeAt(index);
1730     QualifiedName attributeName = attribute.name();
1731     AtomString oldValue = attribute.value();
1732 
1733     willModifyAttribute(attributeName, oldValue, newValue);
1734 
1735     if (newValue != oldValue) {
1736         Style::AttributeChangeInvalidation styleInvalidation(*this, name, oldValue, newValue);
1737         ensureUniqueElementData().attributeAt(index).setValue(newValue);
1738     }
1739 
1740     didModifyAttribute(attributeName, oldValue, newValue);
1741 }
1742 
1743 static inline AtomString makeIdForStyleResolution(const AtomString&amp; value, bool inQuirksMode)
1744 {
1745     if (inQuirksMode)
1746         return value.convertToASCIILowercase();
1747     return value;
1748 }
1749 
1750 void Element::attributeChanged(const QualifiedName&amp; name, const AtomString&amp; oldValue, const AtomString&amp; newValue, AttributeModificationReason)
1751 {
1752     bool valueIsSameAsBefore = oldValue == newValue;
1753 
1754     if (!valueIsSameAsBefore) {
1755         if (name == HTMLNames::accesskeyAttr)
1756             document().invalidateAccessKeyCache();
1757         else if (name == HTMLNames::classAttr)
1758             classAttributeChanged(newValue);
1759         else if (name == HTMLNames::idAttr) {
1760             AtomString oldId = elementData()-&gt;idForStyleResolution();
1761             AtomString newId = makeIdForStyleResolution(newValue, document().inQuirksMode());
1762             if (newId != oldId) {
1763                 Style::IdChangeInvalidation styleInvalidation(*this, oldId, newId);
1764                 elementData()-&gt;setIdForStyleResolution(newId);
1765             }
1766 
1767             if (!oldValue.isEmpty())
1768                 treeScope().idTargetObserverRegistry().notifyObservers(*oldValue.impl());
1769             if (!newValue.isEmpty())
1770                 treeScope().idTargetObserverRegistry().notifyObservers(*newValue.impl());
1771         } else if (name == HTMLNames::nameAttr)
1772             elementData()-&gt;setHasNameAttribute(!newValue.isNull());
1773         else if (name == HTMLNames::pseudoAttr) {
1774             if (needsStyleInvalidation() &amp;&amp; isInShadowTree())
1775                 invalidateStyleForSubtree();
1776         } else if (name == HTMLNames::slotAttr) {
1777             if (auto* parent = parentElement()) {
1778                 if (auto* shadowRoot = parent-&gt;shadowRoot())
1779                     shadowRoot-&gt;hostChildElementDidChangeSlotAttribute(*this, oldValue, newValue);
1780             }
1781         } else if (name == HTMLNames::partAttr)
1782             partAttributeChanged(newValue);
1783         else if (name == HTMLNames::exportpartsAttr) {
1784             if (auto* shadowRoot = this-&gt;shadowRoot()) {
1785                 shadowRoot-&gt;invalidatePartMappings();
1786                 Style::Invalidator::invalidateShadowParts(*shadowRoot);
1787             }
1788         }
1789     }
1790 
1791     parseAttribute(name, newValue);
1792 
1793     document().incDOMTreeVersion();
1794 
1795     if (UNLIKELY(isDefinedCustomElement()))
1796         CustomElementReactionQueue::enqueueAttributeChangedCallbackIfNeeded(*this, name, oldValue, newValue);
1797 
1798     if (valueIsSameAsBefore)
1799         return;
1800 
1801     invalidateNodeListAndCollectionCachesInAncestorsForAttribute(name);
1802 
1803     if (AXObjectCache* cache = document().existingAXObjectCache())
1804         cache-&gt;deferAttributeChangeIfNeeded(name, this);
1805 }
1806 
1807 template &lt;typename CharacterType&gt;
1808 static inline bool isNonEmptyTokenList(const CharacterType* characters, unsigned length)
1809 {
1810     ASSERT(length &gt; 0);
1811 
1812     unsigned i = 0;
1813     do {
1814         if (isNotHTMLSpace(characters[i]))
1815             break;
1816         ++i;
1817     } while (i &lt; length);
1818 
1819     return i &lt; length;
1820 }
1821 
1822 static inline bool isNonEmptyTokenList(const AtomString&amp; stringValue)
1823 {
1824     unsigned length = stringValue.length();
1825 
1826     if (!length)
1827         return false;
1828 
1829     if (stringValue.is8Bit())
1830         return isNonEmptyTokenList(stringValue.characters8(), length);
1831     return isNonEmptyTokenList(stringValue.characters16(), length);
1832 }
1833 
1834 void Element::classAttributeChanged(const AtomString&amp; newClassString)
1835 {
1836     // Note: We&#39;ll need ElementData, but it doesn&#39;t have to be UniqueElementData.
1837     if (!elementData())
1838         ensureUniqueElementData();
1839 
1840     bool shouldFoldCase = document().inQuirksMode();
1841     bool newStringHasClasses = isNonEmptyTokenList(newClassString);
1842 
1843     auto oldClassNames = elementData()-&gt;classNames();
1844     auto newClassNames = newStringHasClasses ? SpaceSplitString(newClassString, shouldFoldCase) : SpaceSplitString();
1845     {
1846         Style::ClassChangeInvalidation styleInvalidation(*this, oldClassNames, newClassNames);
1847         elementData()-&gt;setClassNames(newClassNames);
1848     }
1849 
1850     if (hasRareData()) {
1851         if (auto* classList = elementRareData()-&gt;classList())
1852             classList-&gt;associatedAttributeValueChanged(newClassString);
1853     }
1854 }
1855 
1856 void Element::partAttributeChanged(const AtomString&amp; newValue)
1857 {
1858     if (!RuntimeEnabledFeatures::sharedFeatures().cssShadowPartsEnabled())
1859         return;
1860 
1861     bool hasParts = isNonEmptyTokenList(newValue);
1862     if (hasParts || !partNames().isEmpty()) {
1863         auto newParts = hasParts ? SpaceSplitString(newValue, false) : SpaceSplitString();
1864         ensureElementRareData().setPartNames(WTFMove(newParts));
1865     }
1866 
1867     if (hasRareData()) {
1868         if (auto* partList = elementRareData()-&gt;partList())
1869             partList-&gt;associatedAttributeValueChanged(newValue);
1870     }
1871 
1872     if (needsStyleInvalidation() &amp;&amp; isInShadowTree())
1873         invalidateStyleInternal();
1874 }
1875 
1876 URL Element::absoluteLinkURL() const
1877 {
1878     if (!isLink())
1879         return URL();
1880 
1881     AtomString linkAttribute;
1882     if (hasTagName(SVGNames::aTag))
1883         linkAttribute = getAttribute(SVGNames::hrefAttr, XLinkNames::hrefAttr);
1884     else
1885         linkAttribute = getAttribute(HTMLNames::hrefAttr);
1886 
1887     if (linkAttribute.isEmpty())
1888         return URL();
1889 
1890     return document().completeURL(stripLeadingAndTrailingHTMLSpaces(linkAttribute));
1891 }
1892 
1893 #if ENABLE(TOUCH_EVENTS)
1894 
1895 bool Element::allowsDoubleTapGesture() const
1896 {
1897 #if ENABLE(POINTER_EVENTS)
1898     if (renderStyle() &amp;&amp; renderStyle()-&gt;touchActions() != TouchAction::Auto)
1899         return false;
1900 #endif
1901 
1902     Element* parent = parentElement();
1903     return !parent || parent-&gt;allowsDoubleTapGesture();
1904 }
1905 
1906 #endif
1907 
1908 Style::Resolver&amp; Element::styleResolver()
1909 {
1910     if (auto* shadowRoot = containingShadowRoot())
1911         return shadowRoot-&gt;styleScope().resolver();
1912 
1913     return document().styleScope().resolver();
1914 }
1915 
1916 Style::ElementStyle Element::resolveStyle(const RenderStyle* parentStyle)
1917 {
1918     return styleResolver().styleForElement(*this, parentStyle);
1919 }
1920 
1921 static void invalidateForSiblingCombinators(Element* sibling)
1922 {
1923     for (; sibling; sibling = sibling-&gt;nextElementSibling()) {
1924         if (sibling-&gt;styleIsAffectedByPreviousSibling())
1925             sibling-&gt;invalidateStyleInternal();
1926         if (sibling-&gt;descendantsAffectedByPreviousSibling()) {
1927             for (auto* siblingChild = sibling-&gt;firstElementChild(); siblingChild; siblingChild = siblingChild-&gt;nextElementSibling())
1928                 siblingChild-&gt;invalidateStyleForSubtreeInternal();
1929         }
1930         if (!sibling-&gt;affectsNextSiblingElementStyle())
1931             return;
1932     }
1933 }
1934 
1935 static void invalidateSiblingsIfNeeded(Element&amp; element)
1936 {
1937     if (!element.affectsNextSiblingElementStyle())
1938         return;
1939     auto* parent = element.parentElement();
1940     if (parent &amp;&amp; parent-&gt;styleValidity() &gt;= Style::Validity::SubtreeInvalid)
1941         return;
1942 
1943     invalidateForSiblingCombinators(element.nextElementSibling());
1944 }
1945 
1946 void Element::invalidateStyle()
1947 {
1948     Node::invalidateStyle(Style::Validity::ElementInvalid);
1949     invalidateSiblingsIfNeeded(*this);
1950 }
1951 
1952 void Element::invalidateStyleAndLayerComposition()
1953 {
1954     Node::invalidateStyle(Style::Validity::ElementInvalid, Style::InvalidationMode::RecompositeLayer);
1955     invalidateSiblingsIfNeeded(*this);
1956 }
1957 
1958 void Element::invalidateStyleForSubtree()
1959 {
1960     Node::invalidateStyle(Style::Validity::SubtreeInvalid);
1961     invalidateSiblingsIfNeeded(*this);
1962 }
1963 
1964 void Element::invalidateStyleAndRenderersForSubtree()
1965 {
1966     Node::invalidateStyle(Style::Validity::SubtreeAndRenderersInvalid);
1967     invalidateSiblingsIfNeeded(*this);
1968 }
1969 
1970 void Element::invalidateStyleInternal()
1971 {
1972     Node::invalidateStyle(Style::Validity::ElementInvalid);
1973 }
1974 
1975 void Element::invalidateStyleForSubtreeInternal()
1976 {
1977     Node::invalidateStyle(Style::Validity::SubtreeInvalid);
1978 }
1979 
1980 bool Element::hasDisplayContents() const
1981 {
1982     if (!hasRareData())
1983         return false;
1984 
1985     const RenderStyle* style = elementRareData()-&gt;computedStyle();
1986     return style &amp;&amp; style-&gt;display() == DisplayType::Contents;
1987 }
1988 
1989 void Element::storeDisplayContentsStyle(std::unique_ptr&lt;RenderStyle&gt; style)
1990 {
1991     ASSERT(style &amp;&amp; style-&gt;display() == DisplayType::Contents);
1992     ASSERT(!renderer() || isPseudoElement());
1993     ensureElementRareData().setComputedStyle(WTFMove(style));
1994 }
1995 
1996 // Returns true is the given attribute is an event handler.
1997 // We consider an event handler any attribute that begins with &quot;on&quot;.
1998 // It is a simple solution that has the advantage of not requiring any
1999 // code or configuration change if a new event handler is defined.
2000 
2001 bool Element::isEventHandlerAttribute(const Attribute&amp; attribute) const
2002 {
2003     return attribute.name().namespaceURI().isNull() &amp;&amp; attribute.name().localName().startsWith(&quot;on&quot;);
2004 }
2005 
2006 bool Element::isJavaScriptURLAttribute(const Attribute&amp; attribute) const
2007 {
2008     return isURLAttribute(attribute) &amp;&amp; WTF::protocolIsJavaScript(stripLeadingAndTrailingHTMLSpaces(attribute.value()));
2009 }
2010 
2011 void Element::stripScriptingAttributes(Vector&lt;Attribute&gt;&amp; attributeVector) const
2012 {
2013     attributeVector.removeAllMatching([this](auto&amp; attribute) -&gt; bool {
2014         return this-&gt;isEventHandlerAttribute(attribute)
2015             || this-&gt;isJavaScriptURLAttribute(attribute)
2016             || this-&gt;isHTMLContentAttribute(attribute);
2017     });
2018 }
2019 
2020 void Element::parserSetAttributes(const Vector&lt;Attribute&gt;&amp; attributeVector)
2021 {
2022     ASSERT(!isConnected());
2023     ASSERT(!parentNode());
2024     ASSERT(!m_elementData);
2025 
2026     if (!attributeVector.isEmpty()) {
2027         if (document().sharedObjectPool())
2028             m_elementData = document().sharedObjectPool()-&gt;cachedShareableElementDataWithAttributes(attributeVector);
2029         else
2030             m_elementData = ShareableElementData::createWithAttributes(attributeVector);
2031 
2032     }
2033 
2034     parserDidSetAttributes();
2035 
2036     // Use attributeVector instead of m_elementData because attributeChanged might modify m_elementData.
2037     for (const auto&amp; attribute : attributeVector)
2038         attributeChanged(attribute.name(), nullAtom(), attribute.value(), ModifiedDirectly);
2039 }
2040 
2041 void Element::parserDidSetAttributes()
2042 {
2043 }
2044 
2045 void Element::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
2046 {
2047     ASSERT_WITH_SECURITY_IMPLICATION(&amp;document() == &amp;newDocument);
2048 
2049     if (oldDocument.inQuirksMode() != document().inQuirksMode()) {
2050         // ElementData::m_classNames or ElementData::m_idForStyleResolution need to be updated with the right case.
2051         if (hasID())
2052             attributeChanged(idAttr, nullAtom(), getIdAttribute());
2053         if (hasClass())
2054             attributeChanged(classAttr, nullAtom(), getAttribute(classAttr));
2055     }
2056 
2057     if (UNLIKELY(isDefinedCustomElement()))
2058         CustomElementReactionQueue::enqueueAdoptedCallbackIfNeeded(*this, oldDocument, newDocument);
2059 
2060 #if ENABLE(INTERSECTION_OBSERVER)
2061     if (auto* observerData = intersectionObserverData()) {
2062         for (const auto&amp; observer : observerData-&gt;observers) {
2063             if (observer-&gt;hasObservationTargets()) {
2064                 oldDocument.removeIntersectionObserver(*observer);
2065                 newDocument.addIntersectionObserver(*observer);
2066             }
2067         }
2068     }
2069 #endif
2070 }
2071 
2072 bool Element::hasAttributes() const
2073 {
2074     synchronizeAllAttributes();
2075     return elementData() &amp;&amp; elementData()-&gt;length();
2076 }
2077 
2078 bool Element::hasEquivalentAttributes(const Element&amp; other) const
2079 {
2080     synchronizeAllAttributes();
2081     other.synchronizeAllAttributes();
2082     if (elementData() == other.elementData())
2083         return true;
2084     if (elementData())
2085         return elementData()-&gt;isEquivalent(other.elementData());
2086     if (other.elementData())
2087         return other.elementData()-&gt;isEquivalent(elementData());
2088     return true;
2089 }
2090 
2091 String Element::nodeName() const
2092 {
2093     return m_tagName.toString();
2094 }
2095 
2096 String Element::nodeNamePreservingCase() const
2097 {
2098     return m_tagName.toString();
2099 }
2100 
2101 ExceptionOr&lt;void&gt; Element::setPrefix(const AtomString&amp; prefix)
2102 {
2103     auto result = checkSetPrefix(prefix);
2104     if (result.hasException())
2105         return result.releaseException();
2106 
2107     m_tagName.setPrefix(prefix.isEmpty() ? nullAtom() : prefix);
2108     return { };
2109 }
2110 
2111 const AtomString&amp; Element::imageSourceURL() const
2112 {
2113     return attributeWithoutSynchronization(srcAttr);
2114 }
2115 
2116 bool Element::rendererIsNeeded(const RenderStyle&amp; style)
2117 {
2118     return rendererIsEverNeeded() &amp;&amp; style.display() != DisplayType::None &amp;&amp; style.display() != DisplayType::Contents;
2119 }
2120 
2121 RenderPtr&lt;RenderElement&gt; Element::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
2122 {
2123     return RenderElement::createFor(*this, WTFMove(style));
2124 }
2125 
2126 Node::InsertedIntoAncestorResult Element::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
2127 {
2128     ContainerNode::insertedIntoAncestor(insertionType, parentOfInsertedTree);
2129 
2130 #if ENABLE(FULLSCREEN_API)
2131     if (containsFullScreenElement() &amp;&amp; parentElement() &amp;&amp; !parentElement()-&gt;containsFullScreenElement())
2132         setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(true);
2133 #endif
2134 
2135     if (parentNode() == &amp;parentOfInsertedTree) {
2136         if (auto* shadowRoot = parentNode()-&gt;shadowRoot())
2137             shadowRoot-&gt;hostChildElementDidChange(*this);
2138     }
2139 
2140     if (!parentOfInsertedTree.isInTreeScope())
2141         return InsertedIntoAncestorResult::Done;
2142 
2143     bool becomeConnected = insertionType.connectedToDocument;
2144     TreeScope* newScope = &amp;parentOfInsertedTree.treeScope();
2145     HTMLDocument* newDocument = becomeConnected &amp;&amp; is&lt;HTMLDocument&gt;(newScope-&gt;documentScope()) ? &amp;downcast&lt;HTMLDocument&gt;(newScope-&gt;documentScope()) : nullptr;
2146     if (!insertionType.treeScopeChanged)
2147         newScope = nullptr;
2148 
2149     const AtomString&amp; idValue = getIdAttribute();
2150     if (!idValue.isNull()) {
2151         if (newScope)
2152             updateIdForTreeScope(*newScope, nullAtom(), idValue);
2153         if (newDocument)
2154             updateIdForDocument(*newDocument, nullAtom(), idValue, AlwaysUpdateHTMLDocumentNamedItemMaps);
2155     }
2156 
2157     const AtomString&amp; nameValue = getNameAttribute();
2158     if (!nameValue.isNull()) {
2159         if (newScope)
2160             updateNameForTreeScope(*newScope, nullAtom(), nameValue);
2161         if (newDocument)
2162             updateNameForDocument(*newDocument, nullAtom(), nameValue);
2163     }
2164 
2165     if (newScope &amp;&amp; hasTagName(labelTag)) {
2166         if (newScope-&gt;shouldCacheLabelsByForAttribute())
2167             updateLabel(*newScope, nullAtom(), attributeWithoutSynchronization(forAttr));
2168     }
2169 
2170     if (becomeConnected) {
2171         if (UNLIKELY(isCustomElementUpgradeCandidate())) {
2172             ASSERT(isConnected());
2173             CustomElementReactionQueue::enqueueElementUpgradeIfDefined(*this);
2174         }
2175         if (UNLIKELY(isDefinedCustomElement()))
2176             CustomElementReactionQueue::enqueueConnectedCallbackIfNeeded(*this);
2177     }
2178 
2179     if (UNLIKELY(hasTagName(articleTag) &amp;&amp; newDocument))
2180         newDocument-&gt;registerArticleElement(*this);
2181 
2182     return InsertedIntoAncestorResult::Done;
2183 }
2184 
2185 void Element::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
2186 {
2187 #if ENABLE(FULLSCREEN_API)
2188     if (containsFullScreenElement())
2189         setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(false);
2190 #endif
2191 #if ENABLE(POINTER_LOCK)
2192     if (document().page())
2193         document().page()-&gt;pointerLockController().elementRemoved(*this);
2194 #endif
2195 #if ENABLE(POINTER_EVENTS)
2196     if (document().page() &amp;&amp; RuntimeEnabledFeatures::sharedFeatures().pointerEventsEnabled())
2197         document().page()-&gt;pointerCaptureController().elementWasRemoved(*this);
2198 #endif
2199 
2200     setSavedLayerScrollPosition(ScrollPosition());
2201 
2202     if (oldParentOfRemovedTree.isInTreeScope()) {
2203         TreeScope* oldScope = &amp;oldParentOfRemovedTree.treeScope();
2204         Document* oldDocument = removalType.disconnectedFromDocument ? &amp;oldScope-&gt;documentScope() : nullptr;
2205         HTMLDocument* oldHTMLDocument = oldDocument &amp;&amp; is&lt;HTMLDocument&gt;(*oldDocument) ? &amp;downcast&lt;HTMLDocument&gt;(*oldDocument) : nullptr;
2206         if (!removalType.treeScopeChanged)
2207             oldScope = nullptr;
2208 
2209         const AtomString&amp; idValue = getIdAttribute();
2210         if (!idValue.isNull()) {
2211             if (oldScope)
2212                 updateIdForTreeScope(*oldScope, idValue, nullAtom());
2213             if (oldHTMLDocument)
2214                 updateIdForDocument(*oldHTMLDocument, idValue, nullAtom(), AlwaysUpdateHTMLDocumentNamedItemMaps);
2215         }
2216 
2217         const AtomString&amp; nameValue = getNameAttribute();
2218         if (!nameValue.isNull()) {
2219             if (oldScope)
2220                 updateNameForTreeScope(*oldScope, nameValue, nullAtom());
2221             if (oldHTMLDocument)
2222                 updateNameForDocument(*oldHTMLDocument, nameValue, nullAtom());
2223         }
2224 
2225         if (oldScope &amp;&amp; hasTagName(labelTag)) {
2226             if (oldScope-&gt;shouldCacheLabelsByForAttribute())
2227                 updateLabel(*oldScope, attributeWithoutSynchronization(forAttr), nullAtom());
2228         }
2229 
2230         if (oldDocument) {
2231             if (oldDocument-&gt;cssTarget() == this)
2232                 oldDocument-&gt;setCSSTarget(nullptr);
2233             if (UNLIKELY(hasTagName(articleTag)))
2234                 oldDocument-&gt;unregisterArticleElement(*this);
2235         }
2236 
2237         if (removalType.disconnectedFromDocument &amp;&amp; UNLIKELY(isDefinedCustomElement()))
2238             CustomElementReactionQueue::enqueueDisconnectedCallbackIfNeeded(*this);
2239     }
2240 
2241     if (!parentNode()) {
2242         if (auto* shadowRoot = oldParentOfRemovedTree.shadowRoot())
2243             shadowRoot-&gt;hostChildElementDidChange(*this);
2244     }
2245 
2246     clearBeforePseudoElement();
2247     clearAfterPseudoElement();
2248 
2249     ContainerNode::removedFromAncestor(removalType, oldParentOfRemovedTree);
2250 
2251     if (hasPendingResources())
2252         document().accessSVGExtensions().removeElementFromPendingResources(*this);
2253 
2254     RefPtr&lt;Frame&gt; frame = document().frame();
2255     if (auto* timeline = document().existingTimeline())
2256         timeline-&gt;elementWasRemoved(*this);
2257 
2258     if (frame)
2259         frame-&gt;animation().cancelAnimations(*this);
2260 
2261 #if PLATFORM(MAC)
2262     if (frame &amp;&amp; frame-&gt;page())
2263         frame-&gt;page()-&gt;removeLatchingStateForTarget(*this);
2264 #endif
2265 
2266     if (hasRareData() &amp;&amp; elementRareData()-&gt;hasElementIdentifier()) {
2267         document().identifiedElementWasRemovedFromDocument(*this);
2268         elementRareData()-&gt;setHasElementIdentifier(false);
2269     }
2270 }
2271 
2272 ShadowRoot* Element::shadowRoot() const
2273 {
2274     return hasRareData() ? elementRareData()-&gt;shadowRoot() : nullptr;
2275 }
2276 
2277 void Element::addShadowRoot(Ref&lt;ShadowRoot&gt;&amp;&amp; newShadowRoot)
2278 {
2279     ASSERT(!newShadowRoot-&gt;hasChildNodes());
2280     ASSERT(!shadowRoot());
2281 
2282     ShadowRoot&amp; shadowRoot = newShadowRoot;
2283     {
2284         WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
2285         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2286         if (renderer())
2287             RenderTreeUpdater::tearDownRenderers(*this);
2288 
2289         ensureElementRareData().setShadowRoot(WTFMove(newShadowRoot));
2290 
2291         shadowRoot.setHost(this);
2292         shadowRoot.setParentTreeScope(treeScope());
2293 
2294 #if ASSERT_ENABLED
2295         ASSERT(notifyChildNodeInserted(*this, shadowRoot).isEmpty());
2296 #else
2297         notifyChildNodeInserted(*this, shadowRoot);
2298 #endif
2299 
2300         invalidateStyleAndRenderersForSubtree();
2301     }
2302 
2303     if (shadowRoot.mode() == ShadowRootMode::UserAgent)
2304         didAddUserAgentShadowRoot(shadowRoot);
2305 
2306     InspectorInstrumentation::didPushShadowRoot(*this, shadowRoot);
2307 }
2308 
2309 void Element::removeShadowRoot()
2310 {
2311     RefPtr&lt;ShadowRoot&gt; oldRoot = shadowRoot();
2312     if (!oldRoot)
2313         return;
2314 
2315     InspectorInstrumentation::willPopShadowRoot(*this, *oldRoot);
2316     document().adjustFocusedNodeOnNodeRemoval(*oldRoot);
2317 
2318     ASSERT(!oldRoot-&gt;renderer());
2319 
2320     elementRareData()-&gt;clearShadowRoot();
2321 
2322     oldRoot-&gt;setHost(nullptr);
2323     oldRoot-&gt;setParentTreeScope(document());
2324 }
2325 
2326 static bool canAttachAuthorShadowRoot(const Element&amp; element)
2327 {
2328     static NeverDestroyed&lt;HashSet&lt;AtomString&gt;&gt; tagNames = [] {
2329         static const HTMLQualifiedName* const tagList[] = {
2330             &amp;articleTag.get(),
2331             &amp;asideTag.get(),
2332             &amp;blockquoteTag.get(),
2333             &amp;bodyTag.get(),
2334             &amp;divTag.get(),
2335             &amp;footerTag.get(),
2336             &amp;h1Tag.get(),
2337             &amp;h2Tag.get(),
2338             &amp;h3Tag.get(),
2339             &amp;h4Tag.get(),
2340             &amp;h5Tag.get(),
2341             &amp;h6Tag.get(),
2342             &amp;headerTag.get(),
2343             &amp;mainTag.get(),
2344             &amp;navTag.get(),
2345             &amp;pTag.get(),
2346             &amp;sectionTag.get(),
2347             &amp;spanTag.get()
2348         };
2349         HashSet&lt;AtomString&gt; set;
2350         for (auto&amp; name : tagList)
2351             set.add(name-&gt;localName());
2352         return set;
2353     }();
2354 
2355     if (!is&lt;HTMLElement&gt;(element))
2356         return false;
2357 
2358     const auto&amp; localName = element.localName();
2359     return tagNames.get().contains(localName) || Document::validateCustomElementName(localName) == CustomElementNameValidationStatus::Valid;
2360 }
2361 
2362 ExceptionOr&lt;ShadowRoot&amp;&gt; Element::attachShadow(const ShadowRootInit&amp; init)
2363 {
2364     if (!canAttachAuthorShadowRoot(*this))
2365         return Exception { NotSupportedError };
2366     if (shadowRoot())
2367         return Exception { NotSupportedError };
2368     if (init.mode == ShadowRootMode::UserAgent)
2369         return Exception { TypeError };
2370     auto shadow = ShadowRoot::create(document(), init.mode, init.delegatesFocus ? ShadowRoot::DelegatesFocus::Yes : ShadowRoot::DelegatesFocus::No);
2371     auto&amp; result = shadow.get();
2372     addShadowRoot(WTFMove(shadow));
2373     return result;
2374 }
2375 
2376 ShadowRoot* Element::shadowRootForBindings(JSC::JSGlobalObject&amp; lexicalGlobalObject) const
2377 {
2378     auto* shadow = shadowRoot();
2379     if (!shadow)
2380         return nullptr;
2381     if (shadow-&gt;mode() == ShadowRootMode::Open)
2382         return shadow;
2383     if (JSC::jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject)-&gt;world().shadowRootIsAlwaysOpen())
2384         return shadow;
2385     return nullptr;
2386 }
2387 
2388 RefPtr&lt;ShadowRoot&gt; Element::userAgentShadowRoot() const
2389 {
2390     ASSERT(!shadowRoot() || shadowRoot()-&gt;mode() == ShadowRootMode::UserAgent);
2391     return shadowRoot();
2392 }
2393 
2394 ShadowRoot&amp; Element::ensureUserAgentShadowRoot()
2395 {
2396     if (auto shadow = userAgentShadowRoot())
2397         return *shadow;
2398     auto newShadow = ShadowRoot::create(document(), ShadowRootMode::UserAgent);
2399     ShadowRoot&amp; shadow = newShadow;
2400     addShadowRoot(WTFMove(newShadow));
2401     return shadow;
2402 }
2403 
2404 void Element::setIsDefinedCustomElement(JSCustomElementInterface&amp; elementInterface)
2405 {
2406     clearFlag(IsEditingTextOrUndefinedCustomElementFlag);
2407     setFlag(IsCustomElement);
2408     auto&amp; data = ensureElementRareData();
2409     if (!data.customElementReactionQueue())
2410         data.setCustomElementReactionQueue(makeUnique&lt;CustomElementReactionQueue&gt;(elementInterface));
2411     invalidateStyleForSubtree();
2412     InspectorInstrumentation::didChangeCustomElementState(*this);
2413 }
2414 
2415 void Element::setIsFailedCustomElement(JSCustomElementInterface&amp;)
2416 {
2417     ASSERT(isUndefinedCustomElement());
2418     ASSERT(getFlag(IsEditingTextOrUndefinedCustomElementFlag));
2419     clearFlag(IsCustomElement);
2420 
2421     if (hasRareData()) {
2422         // Clear the queue instead of deleting it since this function can be called inside CustomElementReactionQueue::invokeAll during upgrades.
2423         if (auto* queue = elementRareData()-&gt;customElementReactionQueue())
2424             queue-&gt;clear();
2425     }
2426     InspectorInstrumentation::didChangeCustomElementState(*this);
2427 }
2428 
2429 void Element::setIsCustomElementUpgradeCandidate()
2430 {
2431     ASSERT(!getFlag(IsCustomElement));
2432     setFlag(IsCustomElement);
2433     setFlag(IsEditingTextOrUndefinedCustomElementFlag);
2434     InspectorInstrumentation::didChangeCustomElementState(*this);
2435 }
2436 
2437 void Element::enqueueToUpgrade(JSCustomElementInterface&amp; elementInterface)
2438 {
2439     ASSERT(!isDefinedCustomElement() &amp;&amp; !isFailedCustomElement());
2440     setFlag(IsCustomElement);
2441     setFlag(IsEditingTextOrUndefinedCustomElementFlag);
2442     InspectorInstrumentation::didChangeCustomElementState(*this);
2443 
2444     auto&amp; data = ensureElementRareData();
2445     bool alreadyScheduledToUpgrade = data.customElementReactionQueue();
2446     if (!alreadyScheduledToUpgrade)
2447         data.setCustomElementReactionQueue(makeUnique&lt;CustomElementReactionQueue&gt;(elementInterface));
2448     data.customElementReactionQueue()-&gt;enqueueElementUpgrade(*this, alreadyScheduledToUpgrade);
2449 }
2450 
2451 CustomElementReactionQueue* Element::reactionQueue() const
2452 {
2453     ASSERT(isDefinedCustomElement() || isCustomElementUpgradeCandidate());
2454     if (!hasRareData())
2455         return nullptr;
2456     return elementRareData()-&gt;customElementReactionQueue();
2457 }
2458 
2459 const AtomString&amp; Element::shadowPseudoId() const
2460 {
2461     return pseudo();
2462 }
2463 
2464 bool Element::childTypeAllowed(NodeType type) const
2465 {
2466     switch (type) {
2467     case ELEMENT_NODE:
2468     case TEXT_NODE:
2469     case COMMENT_NODE:
2470     case PROCESSING_INSTRUCTION_NODE:
2471     case CDATA_SECTION_NODE:
2472         return true;
2473     default:
2474         break;
2475     }
2476     return false;
2477 }
2478 
2479 static void checkForEmptyStyleChange(Element&amp; element)
2480 {
2481     if (element.styleAffectedByEmpty()) {
2482         auto* style = element.renderStyle();
2483         if (!style || (!style-&gt;emptyState() || element.hasChildNodes()))
2484             element.invalidateStyleForSubtree();
2485     }
2486 }
2487 
2488 
2489 static void invalidateForForwardPositionalRules(Element&amp; parent, Element* elementAfterChange)
2490 {
2491     bool childrenAffected = parent.childrenAffectedByForwardPositionalRules();
2492     bool descendantsAffected = parent.descendantsAffectedByForwardPositionalRules();
2493 
2494     if (!childrenAffected &amp;&amp; !descendantsAffected)
2495         return;
2496 
2497     for (auto* sibling = elementAfterChange; sibling; sibling = sibling-&gt;nextElementSibling()) {
2498         if (childrenAffected)
2499             sibling-&gt;invalidateStyleInternal();
2500         if (descendantsAffected) {
2501             for (auto* siblingChild = sibling-&gt;firstElementChild(); siblingChild; siblingChild = siblingChild-&gt;nextElementSibling())
2502                 siblingChild-&gt;invalidateStyleForSubtreeInternal();
2503         }
2504     }
2505 }
2506 
2507 static void invalidateForBackwardPositionalRules(Element&amp; parent, Element* elementBeforeChange)
2508 {
2509     bool childrenAffected = parent.childrenAffectedByBackwardPositionalRules();
2510     bool descendantsAffected = parent.descendantsAffectedByBackwardPositionalRules();
2511 
2512     if (!childrenAffected &amp;&amp; !descendantsAffected)
2513         return;
2514 
2515     for (auto* sibling = elementBeforeChange; sibling; sibling = sibling-&gt;previousElementSibling()) {
2516         if (childrenAffected)
2517             sibling-&gt;invalidateStyleInternal();
2518         if (descendantsAffected) {
2519             for (auto* siblingChild = sibling-&gt;firstElementChild(); siblingChild; siblingChild = siblingChild-&gt;nextElementSibling())
2520                 siblingChild-&gt;invalidateStyleForSubtreeInternal();
2521         }
2522     }
2523 }
2524 
2525 enum SiblingCheckType { FinishedParsingChildren, SiblingElementRemoved, Other };
2526 
2527 static void checkForSiblingStyleChanges(Element&amp; parent, SiblingCheckType checkType, Element* elementBeforeChange, Element* elementAfterChange)
2528 {
2529     // :empty selector.
2530     checkForEmptyStyleChange(parent);
2531 
2532     if (parent.styleValidity() &gt;= Style::Validity::SubtreeInvalid)
2533         return;
2534 
2535     // :first-child.  In the parser callback case, we don&#39;t have to check anything, since we were right the first time.
2536     // In the DOM case, we only need to do something if |afterChange| is not 0.
2537     // |afterChange| is 0 in the parser case, so it works out that we&#39;ll skip this block.
2538     if (parent.childrenAffectedByFirstChildRules() &amp;&amp; elementAfterChange) {
2539         // Find our new first child.
2540         RefPtr&lt;Element&gt; newFirstElement = ElementTraversal::firstChild(parent);
2541         // Find the first element node following |afterChange|
2542 
2543         // This is the insert/append case.
2544         if (newFirstElement != elementAfterChange) {
2545             auto* style = elementAfterChange-&gt;renderStyle();
2546             if (!style || style-&gt;firstChildState())
2547                 elementAfterChange-&gt;invalidateStyleForSubtreeInternal();
2548         }
2549 
2550         // We also have to handle node removal.
2551         if (checkType == SiblingElementRemoved &amp;&amp; newFirstElement == elementAfterChange &amp;&amp; newFirstElement) {
2552             auto* style = newFirstElement-&gt;renderStyle();
2553             if (!style || !style-&gt;firstChildState())
2554                 newFirstElement-&gt;invalidateStyleForSubtreeInternal();
2555         }
2556     }
2557 
2558     // :last-child.  In the parser callback case, we don&#39;t have to check anything, since we were right the first time.
2559     // In the DOM case, we only need to do something if |afterChange| is not 0.
2560     if (parent.childrenAffectedByLastChildRules() &amp;&amp; elementBeforeChange) {
2561         // Find our new last child.
2562         RefPtr&lt;Element&gt; newLastElement = ElementTraversal::lastChild(parent);
2563 
2564         if (newLastElement != elementBeforeChange) {
2565             auto* style = elementBeforeChange-&gt;renderStyle();
2566             if (!style || style-&gt;lastChildState())
2567                 elementBeforeChange-&gt;invalidateStyleForSubtreeInternal();
2568         }
2569 
2570         // We also have to handle node removal.  The parser callback case is similar to node removal as well in that we need to change the last child
2571         // to match now.
2572         if ((checkType == SiblingElementRemoved || checkType == FinishedParsingChildren) &amp;&amp; newLastElement == elementBeforeChange &amp;&amp; newLastElement) {
2573             auto* style = newLastElement-&gt;renderStyle();
2574             if (!style || !style-&gt;lastChildState())
2575                 newLastElement-&gt;invalidateStyleForSubtreeInternal();
2576         }
2577     }
2578 
2579     invalidateForSiblingCombinators(elementAfterChange);
2580 
2581     invalidateForForwardPositionalRules(parent, elementAfterChange);
2582     invalidateForBackwardPositionalRules(parent, elementBeforeChange);
2583 }
2584 
2585 void Element::childrenChanged(const ChildChange&amp; change)
2586 {
2587     ContainerNode::childrenChanged(change);
2588     if (change.source == ChildChangeSource::Parser)
2589         checkForEmptyStyleChange(*this);
2590     else {
2591         SiblingCheckType checkType = change.type == ElementRemoved ? SiblingElementRemoved : Other;
2592         checkForSiblingStyleChanges(*this, checkType, change.previousSiblingElement, change.nextSiblingElement);
2593     }
2594 
2595     if (ShadowRoot* shadowRoot = this-&gt;shadowRoot()) {
2596         switch (change.type) {
2597         case ElementInserted:
2598         case ElementRemoved:
2599             // For elements, we notify shadowRoot in Element::insertedIntoAncestor and Element::removedFromAncestor.
2600             break;
2601         case AllChildrenRemoved:
2602         case AllChildrenReplaced:
2603             shadowRoot-&gt;didRemoveAllChildrenOfShadowHost();
2604             break;
2605         case TextInserted:
2606         case TextRemoved:
2607         case TextChanged:
2608             shadowRoot-&gt;didChangeDefaultSlot();
2609             break;
2610         case NonContentsChildInserted:
2611         case NonContentsChildRemoved:
2612             break;
2613         }
2614     }
2615 }
2616 
2617 void Element::setAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; attributeValue)
2618 {
2619     setAttributeEventListener(eventType, JSLazyEventListener::create(*this, attributeName, attributeValue), mainThreadNormalWorld());
2620 }
2621 
2622 void Element::removeAllEventListeners()
2623 {
2624     ContainerNode::removeAllEventListeners();
2625     if (ShadowRoot* shadowRoot = this-&gt;shadowRoot())
2626         shadowRoot-&gt;removeAllEventListeners();
2627 }
2628 
2629 void Element::beginParsingChildren()
2630 {
2631     clearIsParsingChildrenFinished();
2632 }
2633 
2634 void Element::finishParsingChildren()
2635 {
2636     ContainerNode::finishParsingChildren();
2637     setIsParsingChildrenFinished();
2638     checkForSiblingStyleChanges(*this, FinishedParsingChildren, ElementTraversal::lastChild(*this), nullptr);
2639 }
2640 
2641 #if ENABLE(TREE_DEBUGGING)
2642 
2643 void Element::formatForDebugger(char* buffer, unsigned length) const
2644 {
2645     StringBuilder result;
2646     String s;
2647 
2648     result.append(nodeName());
2649 
2650     s = getIdAttribute();
2651     if (s.length() &gt; 0) {
2652         if (result.length() &gt; 0)
2653             result.appendLiteral(&quot;; &quot;);
2654         result.appendLiteral(&quot;id=&quot;);
2655         result.append(s);
2656     }
2657 
2658     s = getAttribute(classAttr);
2659     if (s.length() &gt; 0) {
2660         if (result.length() &gt; 0)
2661             result.appendLiteral(&quot;; &quot;);
2662         result.appendLiteral(&quot;class=&quot;);
2663         result.append(s);
2664     }
2665 
2666     strncpy(buffer, result.toString().utf8().data(), length - 1);
2667 }
2668 
2669 #endif
2670 
2671 const Vector&lt;RefPtr&lt;Attr&gt;&gt;&amp; Element::attrNodeList()
2672 {
2673     ASSERT(hasSyntheticAttrChildNodes());
2674     return *attrNodeListForElement(*this);
2675 }
2676 
2677 void Element::attachAttributeNodeIfNeeded(Attr&amp; attrNode)
2678 {
2679     ASSERT(!attrNode.ownerElement() || attrNode.ownerElement() == this);
2680     if (attrNode.ownerElement() == this)
2681         return;
2682 
2683     ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2684 
2685     attrNode.attachToElement(*this);
2686     ensureAttrNodeListForElement(*this).append(&amp;attrNode);
2687 }
2688 
2689 ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; Element::setAttributeNode(Attr&amp; attrNode)
2690 {
2691     RefPtr&lt;Attr&gt; oldAttrNode = attrIfExists(attrNode.localName(), shouldIgnoreAttributeCase(*this));
2692     if (oldAttrNode.get() == &amp;attrNode)
2693         return oldAttrNode;
2694 
2695     // InUseAttributeError: Raised if node is an Attr that is already an attribute of another Element object.
2696     // The DOM user must explicitly clone Attr nodes to re-use them in other elements.
2697     if (attrNode.ownerElement() &amp;&amp; attrNode.ownerElement() != this)
2698         return Exception { InUseAttributeError };
2699 
2700     {
2701         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2702         synchronizeAllAttributes();
2703     }
2704 
2705     auto&amp; elementData = ensureUniqueElementData();
2706 
2707     auto existingAttributeIndex = elementData.findAttributeIndexByName(attrNode.localName(), shouldIgnoreAttributeCase(*this));
2708 
2709     // Attr::value() will return its &#39;m_standaloneValue&#39; member any time its Element is set to nullptr. We need to cache this value
2710     // before making changes to attrNode&#39;s Element connections.
2711     auto attrNodeValue = attrNode.value();
2712 
2713     if (existingAttributeIndex == ElementData::attributeNotFound) {
2714         attachAttributeNodeIfNeeded(attrNode);
2715         setAttributeInternal(elementData.findAttributeIndexByName(attrNode.qualifiedName()), attrNode.qualifiedName(), attrNodeValue, NotInSynchronizationOfLazyAttribute);
2716     } else {
2717         const Attribute&amp; attribute = attributeAt(existingAttributeIndex);
2718         if (oldAttrNode)
2719             detachAttrNodeFromElementWithValue(oldAttrNode.get(), attribute.value());
2720         else
2721             oldAttrNode = Attr::create(document(), attrNode.qualifiedName(), attribute.value());
2722 
2723         attachAttributeNodeIfNeeded(attrNode);
2724 
2725         if (attribute.name().matches(attrNode.qualifiedName()))
2726             setAttributeInternal(existingAttributeIndex, attrNode.qualifiedName(), attrNodeValue, NotInSynchronizationOfLazyAttribute);
2727         else {
2728             removeAttributeInternal(existingAttributeIndex, NotInSynchronizationOfLazyAttribute);
2729             setAttributeInternal(ensureUniqueElementData().findAttributeIndexByName(attrNode.qualifiedName()), attrNode.qualifiedName(), attrNodeValue, NotInSynchronizationOfLazyAttribute);
2730         }
2731     }
2732 
2733     return oldAttrNode;
2734 }
2735 
2736 ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; Element::setAttributeNodeNS(Attr&amp; attrNode)
2737 {
2738     RefPtr&lt;Attr&gt; oldAttrNode = attrIfExists(attrNode.qualifiedName());
2739     if (oldAttrNode.get() == &amp;attrNode)
2740         return oldAttrNode;
2741 
2742     // InUseAttributeError: Raised if node is an Attr that is already an attribute of another Element object.
2743     // The DOM user must explicitly clone Attr nodes to re-use them in other elements.
2744     if (attrNode.ownerElement() &amp;&amp; attrNode.ownerElement() != this)
2745         return Exception { InUseAttributeError };
2746 
2747     // Attr::value() will return its &#39;m_standaloneValue&#39; member any time its Element is set to nullptr. We need to cache this value
2748     // before making changes to attrNode&#39;s Element connections.
2749     auto attrNodeValue = attrNode.value();
2750     unsigned index = 0;
2751     {
2752         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2753         synchronizeAllAttributes();
2754         auto&amp; elementData = ensureUniqueElementData();
2755 
2756         index = elementData.findAttributeIndexByName(attrNode.qualifiedName());
2757 
2758         if (index != ElementData::attributeNotFound) {
2759             if (oldAttrNode)
2760                 detachAttrNodeFromElementWithValue(oldAttrNode.get(), elementData.attributeAt(index).value());
2761             else
2762                 oldAttrNode = Attr::create(document(), attrNode.qualifiedName(), elementData.attributeAt(index).value());
2763         }
2764     }
2765 
2766     attachAttributeNodeIfNeeded(attrNode);
2767     setAttributeInternal(index, attrNode.qualifiedName(), attrNodeValue, NotInSynchronizationOfLazyAttribute);
2768 
2769     return oldAttrNode;
2770 }
2771 
2772 ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Element::removeAttributeNode(Attr&amp; attr)
2773 {
2774     if (attr.ownerElement() != this)
2775         return Exception { NotFoundError };
2776 
2777     ASSERT(&amp;document() == &amp;attr.document());
2778 
2779     synchronizeAllAttributes();
2780 
2781     if (!m_elementData)
2782         return Exception { NotFoundError };
2783 
2784     auto existingAttributeIndex = m_elementData-&gt;findAttributeIndexByName(attr.qualifiedName());
2785     if (existingAttributeIndex == ElementData::attributeNotFound)
2786         return Exception { NotFoundError };
2787 
2788     Ref&lt;Attr&gt; oldAttrNode { attr };
2789 
2790     detachAttrNodeFromElementWithValue(&amp;attr, m_elementData-&gt;attributeAt(existingAttributeIndex).value());
2791     removeAttributeInternal(existingAttributeIndex, NotInSynchronizationOfLazyAttribute);
2792 
2793     return oldAttrNode;
2794 }
2795 
2796 ExceptionOr&lt;QualifiedName&gt; Element::parseAttributeName(const AtomString&amp; namespaceURI, const AtomString&amp; qualifiedName)
2797 {
2798     auto parseResult = Document::parseQualifiedName(namespaceURI, qualifiedName);
2799     if (parseResult.hasException())
2800         return parseResult.releaseException();
2801     QualifiedName parsedAttributeName { parseResult.releaseReturnValue() };
2802     if (!Document::hasValidNamespaceForAttributes(parsedAttributeName))
2803         return Exception { NamespaceError };
2804     return parsedAttributeName;
2805 }
2806 
2807 ExceptionOr&lt;void&gt; Element::setAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; qualifiedName, const AtomString&amp; value)
2808 {
2809     auto result = parseAttributeName(namespaceURI, qualifiedName);
2810     if (result.hasException())
2811         return result.releaseException();
2812     setAttribute(result.releaseReturnValue(), value);
2813     return { };
2814 }
2815 
2816 void Element::removeAttributeInternal(unsigned index, SynchronizationOfLazyAttribute inSynchronizationOfLazyAttribute)
2817 {
2818     ASSERT_WITH_SECURITY_IMPLICATION(index &lt; attributeCount());
2819 
2820     UniqueElementData&amp; elementData = ensureUniqueElementData();
2821 
2822     QualifiedName name = elementData.attributeAt(index).name();
2823     AtomString valueBeingRemoved = elementData.attributeAt(index).value();
2824 
2825     if (RefPtr&lt;Attr&gt; attrNode = attrIfExists(name))
2826         detachAttrNodeFromElementWithValue(attrNode.get(), elementData.attributeAt(index).value());
2827 
2828     if (inSynchronizationOfLazyAttribute) {
2829         elementData.removeAttribute(index);
2830         return;
2831     }
2832 
2833     ASSERT(!valueBeingRemoved.isNull());
2834     willModifyAttribute(name, valueBeingRemoved, nullAtom());
2835     {
2836         Style::AttributeChangeInvalidation styleInvalidation(*this, name, valueBeingRemoved, nullAtom());
2837         elementData.removeAttribute(index);
2838     }
2839 
2840     didRemoveAttribute(name, valueBeingRemoved);
2841 }
2842 
2843 void Element::addAttributeInternal(const QualifiedName&amp; name, const AtomString&amp; value, SynchronizationOfLazyAttribute inSynchronizationOfLazyAttribute)
2844 {
2845     if (inSynchronizationOfLazyAttribute) {
2846         ensureUniqueElementData().addAttribute(name, value);
2847         return;
2848     }
2849 
2850     willModifyAttribute(name, nullAtom(), value);
2851     {
2852         Style::AttributeChangeInvalidation styleInvalidation(*this, name, nullAtom(), value);
2853         ensureUniqueElementData().addAttribute(name, value);
2854     }
2855     didAddAttribute(name, value);
2856 }
2857 
2858 bool Element::removeAttribute(const AtomString&amp; qualifiedName)
2859 {
2860     if (!elementData())
2861         return false;
2862 
2863     AtomString caseAdjustedQualifiedName = shouldIgnoreAttributeCase(*this) ? qualifiedName.convertToASCIILowercase() : qualifiedName;
2864     unsigned index = elementData()-&gt;findAttributeIndexByName(caseAdjustedQualifiedName, false);
2865     if (index == ElementData::attributeNotFound) {
2866         if (UNLIKELY(caseAdjustedQualifiedName == styleAttr) &amp;&amp; elementData()-&gt;styleAttributeIsDirty() &amp;&amp; is&lt;StyledElement&gt;(*this))
2867             downcast&lt;StyledElement&gt;(*this).removeAllInlineStyleProperties();
2868         return false;
2869     }
2870 
2871     removeAttributeInternal(index, NotInSynchronizationOfLazyAttribute);
2872     return true;
2873 }
2874 
2875 bool Element::removeAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName)
2876 {
2877     return removeAttribute(QualifiedName(nullAtom(), localName, namespaceURI));
2878 }
2879 
2880 RefPtr&lt;Attr&gt; Element::getAttributeNode(const AtomString&amp; qualifiedName)
2881 {
2882     if (!elementData())
2883         return nullptr;
2884     synchronizeAttribute(qualifiedName);
2885     const Attribute* attribute = elementData()-&gt;findAttributeByName(qualifiedName, shouldIgnoreAttributeCase(*this));
2886     if (!attribute)
2887         return nullptr;
2888     return ensureAttr(attribute-&gt;name());
2889 }
2890 
2891 RefPtr&lt;Attr&gt; Element::getAttributeNodeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName)
2892 {
2893     if (!elementData())
2894         return 0;
2895     QualifiedName qName(nullAtom(), localName, namespaceURI);
2896     synchronizeAttribute(qName);
2897     const Attribute* attribute = elementData()-&gt;findAttributeByName(qName);
2898     if (!attribute)
2899         return 0;
2900     return ensureAttr(attribute-&gt;name());
2901 }
2902 
2903 bool Element::hasAttribute(const AtomString&amp; qualifiedName) const
2904 {
2905     if (!elementData())
2906         return false;
2907     synchronizeAttribute(qualifiedName);
2908     return elementData()-&gt;findAttributeByName(qualifiedName, shouldIgnoreAttributeCase(*this));
2909 }
2910 
2911 bool Element::hasAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName) const
2912 {
2913     if (!elementData())
2914         return false;
2915     QualifiedName qName(nullAtom(), localName, namespaceURI);
2916     synchronizeAttribute(qName);
2917     return elementData()-&gt;findAttributeByName(qName);
2918 }
2919 
2920 static RefPtr&lt;ShadowRoot&gt; shadowRootWithDelegatesFocus(const Element&amp; element)
2921 {
2922     if (auto* root = element.shadowRoot()) {
2923         if (root-&gt;delegatesFocus())
2924             return root;
2925     }
2926     return nullptr;
2927 }
2928 
2929 static bool isProgramaticallyFocusable(Element&amp; element)
2930 {
2931     ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2932 
2933     if (shadowRootWithDelegatesFocus(element))
2934         return false;
2935 
2936     // If the stylesheets have already been loaded we can reliably check isFocusable.
2937     // If not, we continue and set the focused node on the focus controller below so that it can be updated soon after attach.
2938     if (element.document().haveStylesheetsLoaded()) {
2939         if (!element.isFocusable())
2940             return false;
2941     }
2942     return element.supportsFocus();
2943 }
2944 
2945 static RefPtr&lt;Element&gt; findFirstProgramaticallyFocusableElementInComposedTree(Element&amp; host)
2946 {
2947     ASSERT(host.shadowRoot());
2948     for (auto&amp; node : composedTreeDescendants(host)) {
2949         if (!is&lt;Element&gt;(node))
2950             continue;
2951         auto&amp; element = downcast&lt;Element&gt;(node);
2952         if (isProgramaticallyFocusable(element))
2953             return &amp;element;
2954     }
2955     return nullptr;
2956 }
2957 
2958 void Element::focus(bool restorePreviousSelection, FocusDirection direction)
2959 {
2960     if (!isConnected())
2961         return;
2962 
2963     auto document = makeRef(this-&gt;document());
2964     if (document-&gt;focusedElement() == this) {
2965         if (document-&gt;page())
2966             document-&gt;page()-&gt;chrome().client().elementDidRefocus(*this);
2967         return;
2968     }
2969 
2970     RefPtr&lt;Element&gt; newTarget = this;
2971     if (document-&gt;haveStylesheetsLoaded())
2972         document-&gt;updateStyleIfNeeded();
2973 
2974     if (&amp;newTarget-&gt;document() != document.ptr())
2975         return;
2976 
2977     if (auto root = shadowRootWithDelegatesFocus(*this)) {
2978         auto currentlyFocusedElement = makeRefPtr(document-&gt;focusedElement());
2979         if (root-&gt;containsIncludingShadowDOM(currentlyFocusedElement.get())) {
2980             if (document-&gt;page())
2981                 document-&gt;page()-&gt;chrome().client().elementDidRefocus(*currentlyFocusedElement);
2982             return;
2983         }
2984 
2985         newTarget = findFirstProgramaticallyFocusableElementInComposedTree(*this);
2986         if (!newTarget)
2987             return;
2988     } else if (!isProgramaticallyFocusable(*newTarget))
2989         return;
2990 
2991     if (Page* page = document-&gt;page()) {
2992         auto&amp; frame = *document-&gt;frame();
2993         if (!frame.hasHadUserInteraction() &amp;&amp; !frame.isMainFrame() &amp;&amp; !document-&gt;topDocument().securityOrigin().canAccess(document-&gt;securityOrigin()))
2994             return;
2995 
2996         // Focus and change event handlers can cause us to lose our last ref.
2997         // If a focus event handler changes the focus to a different node it
2998         // does not make sense to continue and update appearence.
2999         if (!page-&gt;focusController().setFocusedElement(newTarget.get(), *document-&gt;frame(), direction))
3000             return;
3001     }
3002 
3003     SelectionRevealMode revealMode = SelectionRevealMode::Reveal;
3004 
3005 #if PLATFORM(IOS_FAMILY)
3006     // Focusing a form element triggers animation in UIKit to scroll to the right position.
3007     // Calling updateFocusAppearance() would generate an unnecessary call to ScrollView::setScrollPosition(),
3008     // which would jump us around during this animation. See &lt;rdar://problem/6699741&gt;.
3009     if (is&lt;HTMLFormControlElement&gt;(newTarget))
3010         revealMode = SelectionRevealMode::RevealUpToMainFrame;
3011 #endif
3012 
3013     auto target = focusAppearanceUpdateTarget();
3014     if (!target)
3015         return;
3016 
3017     target-&gt;updateFocusAppearance(restorePreviousSelection ? SelectionRestorationMode::Restore : SelectionRestorationMode::SetDefault, revealMode);
3018 }
3019 
3020 // https://html.spec.whatwg.org/#focus-processing-model
3021 RefPtr&lt;Element&gt; Element::focusAppearanceUpdateTarget()
3022 {
3023     return this;
3024 }
3025 
3026 void Element::updateFocusAppearance(SelectionRestorationMode, SelectionRevealMode revealMode)
3027 {
3028     if (isRootEditableElement()) {
3029         // Keep frame alive in this method, since setSelection() may release the last reference to |frame|.
3030         RefPtr&lt;Frame&gt; frame = document().frame();
3031         if (!frame)
3032             return;
3033 
3034         // When focusing an editable element in an iframe, don&#39;t reset the selection if it already contains a selection.
3035         if (this == frame-&gt;selection().selection().rootEditableElement())
3036             return;
3037 
3038         // FIXME: We should restore the previous selection if there is one.
3039         VisibleSelection newSelection = VisibleSelection(firstPositionInOrBeforeNode(this), DOWNSTREAM);
3040 
3041         if (frame-&gt;selection().shouldChangeSelection(newSelection)) {
3042             frame-&gt;selection().setSelection(newSelection, FrameSelection::defaultSetSelectionOptions(), Element::defaultFocusTextStateChangeIntent());
3043             frame-&gt;selection().revealSelection(revealMode);
3044             return;
3045         }
3046     }
3047 
3048     if (RefPtr&lt;FrameView&gt; view = document().view())
3049         view-&gt;scheduleScrollToFocusedElement(revealMode);
3050 }
3051 
3052 void Element::blur()
3053 {
3054     if (treeScope().focusedElementInScope() == this) {
3055         if (Frame* frame = document().frame())
3056             frame-&gt;page()-&gt;focusController().setFocusedElement(nullptr, *frame);
3057         else
3058             document().setFocusedElement(nullptr);
3059     }
3060 }
3061 
3062 void Element::dispatchFocusInEvent(const AtomString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement)
3063 {
3064     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
3065     ASSERT(eventType == eventNames().focusinEvent || eventType == eventNames().DOMFocusInEvent);
3066     dispatchScopedEvent(FocusEvent::create(eventType, Event::CanBubble::Yes, Event::IsCancelable::No, document().windowProxy(), 0, WTFMove(oldFocusedElement)));
3067 }
3068 
3069 void Element::dispatchFocusOutEvent(const AtomString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement)
3070 {
3071     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
3072     ASSERT(eventType == eventNames().focusoutEvent || eventType == eventNames().DOMFocusOutEvent);
3073     dispatchScopedEvent(FocusEvent::create(eventType, Event::CanBubble::Yes, Event::IsCancelable::No, document().windowProxy(), 0, WTFMove(newFocusedElement)));
3074 }
3075 
3076 void Element::dispatchFocusEvent(RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement, FocusDirection)
3077 {
3078     if (auto* page = document().page())
3079         page-&gt;chrome().client().elementDidFocus(*this);
3080     dispatchEvent(FocusEvent::create(eventNames().focusEvent, Event::CanBubble::No, Event::IsCancelable::No, document().windowProxy(), 0, WTFMove(oldFocusedElement)));
3081 }
3082 
3083 void Element::dispatchBlurEvent(RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement)
3084 {
3085     if (auto* page = document().page())
3086         page-&gt;chrome().client().elementDidBlur(*this);
3087     dispatchEvent(FocusEvent::create(eventNames().blurEvent, Event::CanBubble::No, Event::IsCancelable::No, document().windowProxy(), 0, WTFMove(newFocusedElement)));
3088 }
3089 
3090 void Element::dispatchWebKitImageReadyEventForTesting()
3091 {
3092     if (document().settings().webkitImageReadyEventEnabled())
3093         dispatchEvent(Event::create(&quot;webkitImageFrameReady&quot;, Event::CanBubble::Yes, Event::IsCancelable::Yes));
3094 }
3095 
3096 bool Element::dispatchMouseForceWillBegin()
3097 {
3098 #if ENABLE(MOUSE_FORCE_EVENTS)
3099     if (!document().hasListenerType(Document::FORCEWILLBEGIN_LISTENER))
3100         return false;
3101 
3102     Frame* frame = document().frame();
3103     if (!frame)
3104         return false;
3105 
3106     PlatformMouseEvent platformMouseEvent { frame-&gt;eventHandler().lastKnownMousePosition(), frame-&gt;eventHandler().lastKnownMouseGlobalPosition(), NoButton, PlatformEvent::NoType, 1, false, false, false, false, WallTime::now(), ForceAtClick, NoTap };
3107     auto mouseForceWillBeginEvent = MouseEvent::create(eventNames().webkitmouseforcewillbeginEvent, document().windowProxy(), platformMouseEvent, 0, nullptr);
3108     mouseForceWillBeginEvent-&gt;setTarget(this);
3109     dispatchEvent(mouseForceWillBeginEvent);
3110 
3111     if (mouseForceWillBeginEvent-&gt;defaultHandled() || mouseForceWillBeginEvent-&gt;defaultPrevented())
3112         return true;
3113 #endif
3114 
3115     return false;
3116 }
3117 
3118 ExceptionOr&lt;void&gt; Element::mergeWithNextTextNode(Text&amp; node)
3119 {
3120     auto* next = node.nextSibling();
3121     if (!is&lt;Text&gt;(next))
3122         return { };
3123     Ref&lt;Text&gt; textNext { downcast&lt;Text&gt;(*next) };
3124     node.appendData(textNext-&gt;data());
3125     return textNext-&gt;remove();
3126 }
3127 
3128 String Element::innerHTML() const
3129 {
3130     return serializeFragment(*this, SerializedNodes::SubtreesOfChildren);
3131 }
3132 
3133 String Element::outerHTML() const
3134 {
3135     return serializeFragment(*this, SerializedNodes::SubtreeIncludingNode);
3136 }
3137 
3138 ExceptionOr&lt;void&gt; Element::setOuterHTML(const String&amp; html)
3139 {
3140     auto* parentElement = this-&gt;parentElement();
3141     if (!is&lt;HTMLElement&gt;(parentElement))
3142         return Exception { NoModificationAllowedError };
3143 
3144     Ref&lt;HTMLElement&gt; parent = downcast&lt;HTMLElement&gt;(*parentElement);
3145     RefPtr&lt;Node&gt; prev = previousSibling();
3146     RefPtr&lt;Node&gt; next = nextSibling();
3147 
3148     auto fragment = createFragmentForInnerOuterHTML(parent, html, AllowScriptingContent);
3149     if (fragment.hasException())
3150         return fragment.releaseException();
3151 
3152     auto replaceResult = parent-&gt;replaceChild(fragment.releaseReturnValue().get(), *this);
3153     if (replaceResult.hasException())
3154         return replaceResult.releaseException();
3155 
3156     RefPtr&lt;Node&gt; node = next ? next-&gt;previousSibling() : nullptr;
3157     if (is&lt;Text&gt;(node)) {
3158         auto result = mergeWithNextTextNode(downcast&lt;Text&gt;(*node));
3159         if (result.hasException())
3160             return result.releaseException();
3161     }
3162     if (is&lt;Text&gt;(prev)) {
3163         auto result = mergeWithNextTextNode(downcast&lt;Text&gt;(*prev));
3164         if (result.hasException())
3165             return result.releaseException();
3166     }
3167     return { };
3168 }
3169 
3170 
3171 ExceptionOr&lt;void&gt; Element::setInnerHTML(const String&amp; html)
3172 {
3173     auto fragment = createFragmentForInnerOuterHTML(*this, html, AllowScriptingContent);
3174     if (fragment.hasException())
3175         return fragment.releaseException();
3176 
3177     ContainerNode* container;
3178     if (!is&lt;HTMLTemplateElement&gt;(*this))
3179         container = this;
3180     else
3181         container = &amp;downcast&lt;HTMLTemplateElement&gt;(*this).content();
3182 
3183     return replaceChildrenWithFragment(*container, fragment.releaseReturnValue());
3184 }
3185 
3186 String Element::innerText()
3187 {
3188     // We need to update layout, since plainText uses line boxes in the render tree.
3189     document().updateLayoutIgnorePendingStylesheets();
3190 
3191     if (!renderer())
3192         return textContent(true);
3193 
3194     return plainText(rangeOfContents(*this).ptr());
3195 }
3196 
3197 String Element::outerText()
3198 {
3199     // Getting outerText is the same as getting innerText, only
3200     // setting is different. You would think this should get the plain
3201     // text for the outer range, but this is wrong, &lt;br&gt; for instance
3202     // would return different values for inner and outer text by such
3203     // a rule, but it doesn&#39;t in WinIE, and we want to match that.
3204     return innerText();
3205 }
3206 
3207 String Element::title() const
3208 {
3209     return String();
3210 }
3211 
3212 const AtomString&amp; Element::pseudo() const
3213 {
3214     return attributeWithoutSynchronization(pseudoAttr);
3215 }
3216 
3217 void Element::setPseudo(const AtomString&amp; value)
3218 {
3219     setAttributeWithoutSynchronization(pseudoAttr, value);
3220 }
3221 
3222 LayoutSize Element::minimumSizeForResizing() const
3223 {
3224     return hasRareData() ? elementRareData()-&gt;minimumSizeForResizing() : defaultMinimumSizeForResizing();
3225 }
3226 
3227 void Element::setMinimumSizeForResizing(const LayoutSize&amp; size)
3228 {
3229     if (!hasRareData() &amp;&amp; size == defaultMinimumSizeForResizing())
3230         return;
3231     ensureElementRareData().setMinimumSizeForResizing(size);
3232 }
3233 
3234 void Element::willBecomeFullscreenElement()
3235 {
3236     for (auto&amp; child : descendantsOfType&lt;Element&gt;(*this))
3237         child.ancestorWillEnterFullscreen();
3238 }
3239 
3240 static PseudoElement* beforeOrAfterPseudoElement(Element&amp; host, PseudoId pseudoElementSpecifier)
3241 {
3242     switch (pseudoElementSpecifier) {
3243     case PseudoId::Before:
3244         return host.beforePseudoElement();
3245     case PseudoId::After:
3246         return host.afterPseudoElement();
3247     default:
3248         return nullptr;
3249     }
3250 }
3251 
3252 const RenderStyle* Element::existingComputedStyle() const
3253 {
3254     if (hasRareData()) {
3255         if (auto* style = elementRareData()-&gt;computedStyle())
3256             return style;
3257     }
3258 
3259     return renderStyle();
3260 }
3261 
3262 const RenderStyle* Element::renderOrDisplayContentsStyle() const
3263 {
3264     if (auto* style = renderStyle())
3265         return style;
3266 
3267     if (!hasRareData())
3268         return nullptr;
3269     auto* style = elementRareData()-&gt;computedStyle();
3270     if (style &amp;&amp; style-&gt;display() == DisplayType::Contents)
3271         return style;
3272 
3273     return nullptr;
3274 }
3275 
3276 const RenderStyle&amp; Element::resolveComputedStyle()
3277 {
3278     ASSERT(isConnected());
3279     ASSERT(!existingComputedStyle());
3280 
3281     Deque&lt;RefPtr&lt;Element&gt;, 32&gt; elementsRequiringComputedStyle({ this });
3282     const RenderStyle* computedStyle = nullptr;
3283 
3284     // Collect ancestors until we find one that has style.
3285     auto composedAncestors = composedTreeAncestors(*this);
3286     for (auto&amp; ancestor : composedAncestors) {
3287         if (auto* existingStyle = ancestor.existingComputedStyle()) {
3288             computedStyle = existingStyle;
3289             break;
3290         }
3291         elementsRequiringComputedStyle.prepend(&amp;ancestor);
3292     }
3293 
3294     // Resolve and cache styles starting from the most distant ancestor.
3295     for (auto&amp; element : elementsRequiringComputedStyle) {
3296         auto style = document().styleForElementIgnoringPendingStylesheets(*element, computedStyle);
3297         computedStyle = style.get();
3298         ElementRareData&amp; rareData = element-&gt;ensureElementRareData();
3299         rareData.setComputedStyle(WTFMove(style));
3300     }
3301 
3302     return *computedStyle;
3303 }
3304 
3305 const RenderStyle&amp; Element::resolvePseudoElementStyle(PseudoId pseudoElementSpecifier)
3306 {
3307     ASSERT(!isPseudoElement());
3308 
3309     auto* parentStyle = existingComputedStyle();
3310     ASSERT(parentStyle);
3311     ASSERT(!parentStyle-&gt;getCachedPseudoStyle(pseudoElementSpecifier));
3312 
3313     auto style = document().styleForElementIgnoringPendingStylesheets(*this, parentStyle, pseudoElementSpecifier);
3314     if (!style) {
3315         style = RenderStyle::createPtr();
3316         style-&gt;inheritFrom(*parentStyle);
3317         style-&gt;setStyleType(pseudoElementSpecifier);
3318     }
3319 
3320     auto* computedStyle = style.get();
3321     const_cast&lt;RenderStyle*&gt;(parentStyle)-&gt;addCachedPseudoStyle(WTFMove(style));
3322     return *computedStyle;
3323 }
3324 
3325 const RenderStyle* Element::computedStyle(PseudoId pseudoElementSpecifier)
3326 {
3327     if (!isConnected())
3328         return nullptr;
3329 
3330     if (PseudoElement* pseudoElement = beforeOrAfterPseudoElement(*this, pseudoElementSpecifier))
3331         return pseudoElement-&gt;computedStyle();
3332 
3333     auto* style = existingComputedStyle();
3334     if (!style)
3335         style = &amp;resolveComputedStyle();
3336 
3337     if (pseudoElementSpecifier != PseudoId::None) {
3338         if (auto* cachedPseudoStyle = style-&gt;getCachedPseudoStyle(pseudoElementSpecifier))
3339             return cachedPseudoStyle;
3340         return &amp;resolvePseudoElementStyle(pseudoElementSpecifier);
3341     }
3342 
3343     return style;
3344 }
3345 
3346 bool Element::needsStyleInvalidation() const
3347 {
3348     if (!inRenderedDocument())
3349         return false;
3350     if (styleValidity() &gt;= Style::Validity::SubtreeInvalid)
3351         return false;
3352     if (document().hasPendingFullStyleRebuild())
3353         return false;
3354 
3355     return true;
3356 }
3357 
3358 void Element::setChildIndex(unsigned index)
3359 {
3360     ElementRareData&amp; rareData = ensureElementRareData();
3361     rareData.setChildIndex(index);
3362 }
3363 
3364 bool Element::hasFlagsSetDuringStylingOfChildren() const
3365 {
3366     return styleAffectedByActive()
3367         || childrenAffectedByHover()
3368         || childrenAffectedByFirstChildRules()
3369         || childrenAffectedByLastChildRules()
3370         || childrenAffectedByDrag()
3371         || childrenAffectedByForwardPositionalRules()
3372         || descendantsAffectedByForwardPositionalRules()
3373         || childrenAffectedByBackwardPositionalRules()
3374         || descendantsAffectedByBackwardPositionalRules()
3375         || childrenAffectedByPropertyBasedBackwardPositionalRules();
3376 }
3377 
3378 unsigned Element::rareDataChildIndex() const
3379 {
3380     ASSERT(hasRareData());
3381     return elementRareData()-&gt;childIndex();
3382 }
3383 
3384 AtomString Element::computeInheritedLanguage() const
3385 {
3386     if (const ElementData* elementData = this-&gt;elementData()) {
3387         if (const Attribute* attribute = elementData-&gt;findLanguageAttribute())
3388             return attribute-&gt;value();
3389     }
3390 
3391     // The language property is inherited, so we iterate over the parents to find the first language.
3392     const Node* currentNode = this;
3393     while ((currentNode = currentNode-&gt;parentNode())) {
3394         if (is&lt;Element&gt;(*currentNode)) {
3395             if (const ElementData* elementData = downcast&lt;Element&gt;(*currentNode).elementData()) {
3396                 if (const Attribute* attribute = elementData-&gt;findLanguageAttribute())
3397                     return attribute-&gt;value();
3398             }
3399         } else if (is&lt;Document&gt;(*currentNode)) {
3400             // checking the MIME content-language
3401             return downcast&lt;Document&gt;(*currentNode).contentLanguage();
3402         }
3403     }
3404 
3405     return nullAtom();
3406 }
3407 
3408 Locale&amp; Element::locale() const
3409 {
3410     return document().getCachedLocale(computeInheritedLanguage());
3411 }
3412 
3413 void Element::normalizeAttributes()
3414 {
3415     if (!hasAttributes())
3416         return;
3417 
3418     auto* attrNodeList = attrNodeListForElement(*this);
3419     if (!attrNodeList)
3420         return;
3421 
3422     // Copy the Attr Vector because Node::normalize() can fire synchronous JS
3423     // events (e.g. DOMSubtreeModified) and a JS listener could add / remove
3424     // attributes while we are iterating.
3425     auto copyOfAttrNodeList = *attrNodeList;
3426     for (auto&amp; attrNode : copyOfAttrNodeList)
3427         attrNode-&gt;normalize();
3428 }
3429 
3430 PseudoElement* Element::beforePseudoElement() const
3431 {
3432     return hasRareData() ? elementRareData()-&gt;beforePseudoElement() : nullptr;
3433 }
3434 
3435 PseudoElement* Element::afterPseudoElement() const
3436 {
3437     return hasRareData() ? elementRareData()-&gt;afterPseudoElement() : nullptr;
3438 }
3439 
3440 void Element::setBeforePseudoElement(Ref&lt;PseudoElement&gt;&amp;&amp; element)
3441 {
3442     ensureElementRareData().setBeforePseudoElement(WTFMove(element));
3443 }
3444 
3445 void Element::setAfterPseudoElement(Ref&lt;PseudoElement&gt;&amp;&amp; element)
3446 {
3447     ensureElementRareData().setAfterPseudoElement(WTFMove(element));
3448 }
3449 
3450 static void disconnectPseudoElement(PseudoElement* pseudoElement)
3451 {
3452     if (!pseudoElement)
3453         return;
3454     ASSERT(!pseudoElement-&gt;renderer());
3455     ASSERT(pseudoElement-&gt;hostElement());
3456     pseudoElement-&gt;clearHostElement();
3457 }
3458 
3459 void Element::clearBeforePseudoElement()
3460 {
3461     if (!hasRareData())
3462         return;
3463     disconnectPseudoElement(elementRareData()-&gt;beforePseudoElement());
3464     elementRareData()-&gt;setBeforePseudoElement(nullptr);
3465 }
3466 
3467 void Element::clearAfterPseudoElement()
3468 {
3469     if (!hasRareData())
3470         return;
3471     disconnectPseudoElement(elementRareData()-&gt;afterPseudoElement());
3472     elementRareData()-&gt;setAfterPseudoElement(nullptr);
3473 }
3474 
3475 bool Element::matchesValidPseudoClass() const
3476 {
3477     return false;
3478 }
3479 
3480 bool Element::matchesInvalidPseudoClass() const
3481 {
3482     return false;
3483 }
3484 
3485 bool Element::matchesReadWritePseudoClass() const
3486 {
3487     return false;
3488 }
3489 
3490 bool Element::matchesIndeterminatePseudoClass() const
3491 {
3492     return shouldAppearIndeterminate();
3493 }
3494 
3495 bool Element::matchesDefaultPseudoClass() const
3496 {
3497     return false;
3498 }
3499 
3500 ExceptionOr&lt;bool&gt; Element::matches(const String&amp; selector)
3501 {
3502     auto query = document().selectorQueryForString(selector);
3503     if (query.hasException())
3504         return query.releaseException();
3505     return query.releaseReturnValue().matches(*this);
3506 }
3507 
3508 ExceptionOr&lt;Element*&gt; Element::closest(const String&amp; selector)
3509 {
3510     auto query = document().selectorQueryForString(selector);
3511     if (query.hasException())
3512         return query.releaseException();
3513     return query.releaseReturnValue().closest(*this);
3514 }
3515 
3516 bool Element::shouldAppearIndeterminate() const
3517 {
3518     return false;
3519 }
3520 
3521 bool Element::mayCauseRepaintInsideViewport(const IntRect* visibleRect) const
3522 {
3523     return renderer() &amp;&amp; renderer()-&gt;mayCauseRepaintInsideViewport(visibleRect);
3524 }
3525 
3526 DOMTokenList&amp; Element::classList()
3527 {
3528     ElementRareData&amp; data = ensureElementRareData();
3529     if (!data.classList())
3530         data.setClassList(makeUnique&lt;DOMTokenList&gt;(*this, HTMLNames::classAttr));
3531     return *data.classList();
3532 }
3533 
3534 SpaceSplitString Element::partNames() const
3535 {
3536     return hasRareData() ? elementRareData()-&gt;partNames() : SpaceSplitString();
3537 }
3538 
3539 DOMTokenList&amp; Element::part()
3540 {
3541     auto&amp; data = ensureElementRareData();
3542     if (!data.partList())
3543         data.setPartList(makeUnique&lt;DOMTokenList&gt;(*this, HTMLNames::partAttr));
3544     return *data.partList();
3545 }
3546 
3547 DatasetDOMStringMap&amp; Element::dataset()
3548 {
3549     ElementRareData&amp; data = ensureElementRareData();
3550     if (!data.dataset())
3551         data.setDataset(makeUnique&lt;DatasetDOMStringMap&gt;(*this));
3552     return *data.dataset();
3553 }
3554 
3555 URL Element::getURLAttribute(const QualifiedName&amp; name) const
3556 {
3557 #if ASSERT_ENABLED
3558     if (elementData()) {
3559         if (const Attribute* attribute = findAttributeByName(name))
3560             ASSERT(isURLAttribute(*attribute));
3561     }
3562 #endif
3563     return document().completeURL(stripLeadingAndTrailingHTMLSpaces(getAttribute(name)));
3564 }
3565 
3566 URL Element::getNonEmptyURLAttribute(const QualifiedName&amp; name) const
3567 {
3568 #if ASSERT_ENABLED
3569     if (elementData()) {
3570         if (const Attribute* attribute = findAttributeByName(name))
3571             ASSERT(isURLAttribute(*attribute));
3572     }
3573 #endif
3574     String value = stripLeadingAndTrailingHTMLSpaces(getAttribute(name));
3575     if (value.isEmpty())
3576         return URL();
3577     return document().completeURL(value);
3578 }
3579 
3580 int Element::getIntegralAttribute(const QualifiedName&amp; attributeName) const
3581 {
3582     return parseHTMLInteger(getAttribute(attributeName)).value_or(0);
3583 }
3584 
3585 void Element::setIntegralAttribute(const QualifiedName&amp; attributeName, int value)
3586 {
3587     setAttribute(attributeName, AtomString::number(value));
3588 }
3589 
3590 unsigned Element::getUnsignedIntegralAttribute(const QualifiedName&amp; attributeName) const
3591 {
3592     return parseHTMLNonNegativeInteger(getAttribute(attributeName)).value_or(0);
3593 }
3594 
3595 void Element::setUnsignedIntegralAttribute(const QualifiedName&amp; attributeName, unsigned value)
3596 {
3597     setAttribute(attributeName, AtomString::number(limitToOnlyHTMLNonNegative(value)));
3598 }
3599 
3600 bool Element::childShouldCreateRenderer(const Node&amp; child) const
3601 {
3602     // Only create renderers for SVG elements whose parents are SVG elements, or for proper &lt;svg xmlns=&quot;svgNS&quot;&gt; subdocuments.
3603     if (child.isSVGElement()) {
3604         ASSERT(!isSVGElement());
3605         const SVGElement&amp; childElement = downcast&lt;SVGElement&gt;(child);
3606         return is&lt;SVGSVGElement&gt;(childElement) &amp;&amp; childElement.isValid();
3607     }
3608     return true;
3609 }
3610 
3611 #if ENABLE(FULLSCREEN_API)
3612 
3613 static Element* parentCrossingFrameBoundaries(const Element* element)
3614 {
3615     ASSERT(element);
3616     if (auto* parent = element-&gt;parentElementInComposedTree())
3617         return parent;
3618     return element-&gt;document().ownerElement();
3619 }
3620 
3621 void Element::webkitRequestFullscreen()
3622 {
3623     document().fullscreenManager().requestFullscreenForElement(this, FullscreenManager::EnforceIFrameAllowFullscreenRequirement);
3624 }
3625 
3626 bool Element::containsFullScreenElement() const
3627 {
3628     return hasRareData() &amp;&amp; elementRareData()-&gt;containsFullScreenElement();
3629 }
3630 
3631 void Element::setContainsFullScreenElement(bool flag)
3632 {
3633     ensureElementRareData().setContainsFullScreenElement(flag);
3634     invalidateStyleAndLayerComposition();
3635 }
3636 
3637 void Element::setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(bool flag)
3638 {
3639     Element* element = this;
3640     while ((element = parentCrossingFrameBoundaries(element)))
3641         element-&gt;setContainsFullScreenElement(flag);
3642 }
3643 
3644 #endif
3645 
3646 #if ENABLE(POINTER_EVENTS)
3647 
3648 ExceptionOr&lt;void&gt; Element::setPointerCapture(int32_t pointerId)
3649 {
3650     if (document().page())
3651         return document().page()-&gt;pointerCaptureController().setPointerCapture(this, pointerId);
3652     return { };
3653 }
3654 
3655 ExceptionOr&lt;void&gt; Element::releasePointerCapture(int32_t pointerId)
3656 {
3657     if (document().page())
3658         return document().page()-&gt;pointerCaptureController().releasePointerCapture(this, pointerId);
3659     return { };
3660 }
3661 
3662 bool Element::hasPointerCapture(int32_t pointerId)
3663 {
3664     if (document().page())
3665         return document().page()-&gt;pointerCaptureController().hasPointerCapture(this, pointerId);
3666     return false;
3667 }
3668 
3669 #endif
3670 
3671 #if ENABLE(POINTER_LOCK)
3672 
3673 void Element::requestPointerLock()
3674 {
3675     if (document().page())
3676         document().page()-&gt;pointerLockController().requestPointerLock(this);
3677 }
3678 
3679 #endif
3680 
3681 #if ENABLE(INTERSECTION_OBSERVER)
3682 
3683 void Element::disconnectFromIntersectionObservers()
3684 {
3685     auto* observerData = intersectionObserverData();
3686     if (!observerData)
3687         return;
3688 
3689     for (const auto&amp; registration : observerData-&gt;registrations)
3690         registration.observer-&gt;targetDestroyed(*this);
3691     observerData-&gt;registrations.clear();
3692 
3693     for (const auto&amp; observer : observerData-&gt;observers)
3694         observer-&gt;rootDestroyed();
3695     observerData-&gt;observers.clear();
3696 }
3697 
3698 IntersectionObserverData&amp; Element::ensureIntersectionObserverData()
3699 {
3700     auto&amp; rareData = ensureElementRareData();
3701     if (!rareData.intersectionObserverData())
3702         rareData.setIntersectionObserverData(makeUnique&lt;IntersectionObserverData&gt;());
3703     return *rareData.intersectionObserverData();
3704 }
3705 
3706 IntersectionObserverData* Element::intersectionObserverData()
3707 {
3708     return hasRareData() ? elementRareData()-&gt;intersectionObserverData() : nullptr;
3709 }
3710 
3711 #endif
3712 
3713 KeyframeEffectStack* Element::keyframeEffectStack() const
3714 {
3715     return hasRareData() ? elementRareData()-&gt;keyframeEffectStack() : nullptr;
3716 }
3717 
3718 KeyframeEffectStack&amp; Element::ensureKeyframeEffectStack()
3719 {
3720     auto&amp; rareData = ensureElementRareData();
3721     if (!rareData.keyframeEffectStack())
3722         rareData.setKeyframeEffectStack(makeUnique&lt;KeyframeEffectStack&gt;());
3723     return *rareData.keyframeEffectStack();
3724 }
3725 
3726 bool Element::hasKeyframeEffects() const
3727 {
3728     if (!hasRareData())
3729         return false;
3730 
3731     auto* keyframeEffectStack = elementRareData()-&gt;keyframeEffectStack();
3732     return keyframeEffectStack &amp;&amp; keyframeEffectStack-&gt;hasEffects();
3733 }
3734 
3735 OptionSet&lt;AnimationImpact&gt; Element::applyKeyframeEffects(RenderStyle&amp; targetStyle)
3736 {
3737     OptionSet&lt;AnimationImpact&gt; impact;
3738 
3739     for (const auto&amp; effect : ensureKeyframeEffectStack().sortedEffects()) {
3740         ASSERT(effect-&gt;animation());
3741         effect-&gt;animation()-&gt;resolve(targetStyle);
3742 
3743         if (effect-&gt;isRunningAccelerated() || effect-&gt;isAboutToRunAccelerated())
3744             impact.add(AnimationImpact::RequiresRecomposite);
3745 
3746         if (effect-&gt;triggersStackingContext())
3747             impact.add(AnimationImpact::ForcesStackingContext);
3748     }
3749 
3750     return impact;
3751 }
3752 
3753 #if ENABLE(RESIZE_OBSERVER)
3754 
3755 void Element::disconnectFromResizeObservers()
3756 {
3757     auto* observerData = resizeObserverData();
3758     if (!observerData)
3759         return;
3760 
3761     for (const auto&amp; observer : observerData-&gt;observers)
3762         observer-&gt;targetDestroyed(*this);
3763     observerData-&gt;observers.clear();
3764 }
3765 
3766 ResizeObserverData&amp; Element::ensureResizeObserverData()
3767 {
3768     auto&amp; rareData = ensureElementRareData();
3769     if (!rareData.resizeObserverData())
3770         rareData.setResizeObserverData(makeUnique&lt;ResizeObserverData&gt;());
3771     return *rareData.resizeObserverData();
3772 }
3773 
3774 ResizeObserverData* Element::resizeObserverData()
3775 {
3776     return hasRareData() ? elementRareData()-&gt;resizeObserverData() : nullptr;
3777 }
3778 
3779 #endif
3780 
3781 bool Element::isSpellCheckingEnabled() const
3782 {
3783     for (auto* ancestor = this; ancestor; ancestor = ancestor-&gt;parentOrShadowHostElement()) {
3784         auto&amp; value = ancestor-&gt;attributeWithoutSynchronization(HTMLNames::spellcheckAttr);
3785         if (value.isNull())
3786             continue;
3787         if (value.isEmpty() || equalLettersIgnoringASCIICase(value, &quot;true&quot;))
3788             return true;
3789         if (equalLettersIgnoringASCIICase(value, &quot;false&quot;))
3790             return false;
3791     }
3792     return true;
3793 }
3794 
3795 #if ASSERT_ENABLED
3796 bool Element::fastAttributeLookupAllowed(const QualifiedName&amp; name) const
3797 {
3798     if (name == HTMLNames::styleAttr)
3799         return false;
3800 
3801     if (isSVGElement())
3802         return !downcast&lt;SVGElement&gt;(*this).isAnimatedPropertyAttribute(name);
3803 
3804     return true;
3805 }
3806 #endif
3807 
3808 #if DUMP_NODE_STATISTICS
3809 bool Element::hasNamedNodeMap() const
3810 {
3811     return hasRareData() &amp;&amp; elementRareData()-&gt;attributeMap();
3812 }
3813 #endif
3814 
3815 inline void Element::updateName(const AtomString&amp; oldName, const AtomString&amp; newName)
3816 {
3817     if (!isInTreeScope())
3818         return;
3819 
3820     if (oldName == newName)
3821         return;
3822 
3823     updateNameForTreeScope(treeScope(), oldName, newName);
3824 
3825     if (!isConnected())
3826         return;
3827     if (!is&lt;HTMLDocument&gt;(document()))
3828         return;
3829     updateNameForDocument(downcast&lt;HTMLDocument&gt;(document()), oldName, newName);
3830 }
3831 
3832 void Element::updateNameForTreeScope(TreeScope&amp; scope, const AtomString&amp; oldName, const AtomString&amp; newName)
3833 {
3834     ASSERT(oldName != newName);
3835 
3836     if (!oldName.isEmpty())
3837         scope.removeElementByName(*oldName.impl(), *this);
3838     if (!newName.isEmpty())
3839         scope.addElementByName(*newName.impl(), *this);
3840 }
3841 
3842 void Element::updateNameForDocument(HTMLDocument&amp; document, const AtomString&amp; oldName, const AtomString&amp; newName)
3843 {
3844     ASSERT(oldName != newName);
3845 
3846     if (isInShadowTree())
3847         return;
3848 
3849     if (WindowNameCollection::elementMatchesIfNameAttributeMatch(*this)) {
3850         const AtomString&amp; id = WindowNameCollection::elementMatchesIfIdAttributeMatch(*this) ? getIdAttribute() : nullAtom();
3851         if (!oldName.isEmpty() &amp;&amp; oldName != id)
3852             document.removeWindowNamedItem(*oldName.impl(), *this);
3853         if (!newName.isEmpty() &amp;&amp; newName != id)
3854             document.addWindowNamedItem(*newName.impl(), *this);
3855     }
3856 
3857     if (DocumentNameCollection::elementMatchesIfNameAttributeMatch(*this)) {
3858         const AtomString&amp; id = DocumentNameCollection::elementMatchesIfIdAttributeMatch(*this) ? getIdAttribute() : nullAtom();
3859         if (!oldName.isEmpty() &amp;&amp; oldName != id)
3860             document.removeDocumentNamedItem(*oldName.impl(), *this);
3861         if (!newName.isEmpty() &amp;&amp; newName != id)
3862             document.addDocumentNamedItem(*newName.impl(), *this);
3863     }
3864 }
3865 
3866 inline void Element::updateId(const AtomString&amp; oldId, const AtomString&amp; newId, NotifyObservers notifyObservers)
3867 {
3868     if (!isInTreeScope())
3869         return;
3870 
3871     if (oldId == newId)
3872         return;
3873 
3874     updateIdForTreeScope(treeScope(), oldId, newId, notifyObservers);
3875 
3876     if (!isConnected())
3877         return;
3878     if (!is&lt;HTMLDocument&gt;(document()))
3879         return;
3880     updateIdForDocument(downcast&lt;HTMLDocument&gt;(document()), oldId, newId, UpdateHTMLDocumentNamedItemMapsOnlyIfDiffersFromNameAttribute);
3881 }
3882 
3883 void Element::updateIdForTreeScope(TreeScope&amp; scope, const AtomString&amp; oldId, const AtomString&amp; newId, NotifyObservers notifyObservers)
3884 {
3885     ASSERT(isInTreeScope());
3886     ASSERT(oldId != newId);
3887 
3888     if (!oldId.isEmpty())
3889         scope.removeElementById(*oldId.impl(), *this, notifyObservers == NotifyObservers::Yes);
3890     if (!newId.isEmpty())
3891         scope.addElementById(*newId.impl(), *this, notifyObservers == NotifyObservers::Yes);
3892 }
3893 
3894 void Element::updateIdForDocument(HTMLDocument&amp; document, const AtomString&amp; oldId, const AtomString&amp; newId, HTMLDocumentNamedItemMapsUpdatingCondition condition)
3895 {
3896     ASSERT(isConnected());
3897     ASSERT(oldId != newId);
3898 
3899     if (isInShadowTree())
3900         return;
3901 
3902     if (WindowNameCollection::elementMatchesIfIdAttributeMatch(*this)) {
3903         const AtomString&amp; name = condition == UpdateHTMLDocumentNamedItemMapsOnlyIfDiffersFromNameAttribute &amp;&amp; WindowNameCollection::elementMatchesIfNameAttributeMatch(*this) ? getNameAttribute() : nullAtom();
3904         if (!oldId.isEmpty() &amp;&amp; oldId != name)
3905             document.removeWindowNamedItem(*oldId.impl(), *this);
3906         if (!newId.isEmpty() &amp;&amp; newId != name)
3907             document.addWindowNamedItem(*newId.impl(), *this);
3908     }
3909 
3910     if (DocumentNameCollection::elementMatchesIfIdAttributeMatch(*this)) {
3911         const AtomString&amp; name = condition == UpdateHTMLDocumentNamedItemMapsOnlyIfDiffersFromNameAttribute &amp;&amp; DocumentNameCollection::elementMatchesIfNameAttributeMatch(*this) ? getNameAttribute() : nullAtom();
3912         if (!oldId.isEmpty() &amp;&amp; oldId != name)
3913             document.removeDocumentNamedItem(*oldId.impl(), *this);
3914         if (!newId.isEmpty() &amp;&amp; newId != name)
3915             document.addDocumentNamedItem(*newId.impl(), *this);
3916     }
3917 }
3918 
3919 void Element::updateLabel(TreeScope&amp; scope, const AtomString&amp; oldForAttributeValue, const AtomString&amp; newForAttributeValue)
3920 {
3921     ASSERT(hasTagName(labelTag));
3922 
3923     if (!isConnected())
3924         return;
3925 
3926     if (oldForAttributeValue == newForAttributeValue)
3927         return;
3928 
3929     if (!oldForAttributeValue.isEmpty())
3930         scope.removeLabel(*oldForAttributeValue.impl(), downcast&lt;HTMLLabelElement&gt;(*this));
3931     if (!newForAttributeValue.isEmpty())
3932         scope.addLabel(*newForAttributeValue.impl(), downcast&lt;HTMLLabelElement&gt;(*this));
3933 }
3934 
3935 void Element::willModifyAttribute(const QualifiedName&amp; name, const AtomString&amp; oldValue, const AtomString&amp; newValue)
3936 {
3937     if (name == HTMLNames::idAttr)
3938         updateId(oldValue, newValue, NotifyObservers::No); // Will notify observers after the attribute is actually changed.
3939     else if (name == HTMLNames::nameAttr)
3940         updateName(oldValue, newValue);
3941     else if (name == HTMLNames::forAttr &amp;&amp; hasTagName(labelTag)) {
3942         if (treeScope().shouldCacheLabelsByForAttribute())
3943             updateLabel(treeScope(), oldValue, newValue);
3944     }
3945 
3946     if (auto recipients = MutationObserverInterestGroup::createForAttributesMutation(*this, name))
3947         recipients-&gt;enqueueMutationRecord(MutationRecord::createAttributes(*this, name, oldValue));
3948 
3949     InspectorInstrumentation::willModifyDOMAttr(document(), *this, oldValue, newValue);
3950 }
3951 
3952 void Element::didAddAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
3953 {
3954     attributeChanged(name, nullAtom(), value);
3955     InspectorInstrumentation::didModifyDOMAttr(document(), *this, name.toString(), value);
3956     dispatchSubtreeModifiedEvent();
3957 }
3958 
3959 void Element::didModifyAttribute(const QualifiedName&amp; name, const AtomString&amp; oldValue, const AtomString&amp; newValue)
3960 {
3961     attributeChanged(name, oldValue, newValue);
3962     InspectorInstrumentation::didModifyDOMAttr(document(), *this, name.toString(), newValue);
3963     // Do not dispatch a DOMSubtreeModified event here; see bug 81141.
3964 }
3965 
3966 void Element::didRemoveAttribute(const QualifiedName&amp; name, const AtomString&amp; oldValue)
3967 {
3968     attributeChanged(name, oldValue, nullAtom());
3969     InspectorInstrumentation::didRemoveDOMAttr(document(), *this, name.toString());
3970     dispatchSubtreeModifiedEvent();
3971 }
3972 
3973 IntPoint Element::savedLayerScrollPosition() const
3974 {
3975     return hasRareData() ? elementRareData()-&gt;savedLayerScrollPosition() : IntPoint();
3976 }
3977 
3978 void Element::setSavedLayerScrollPosition(const IntPoint&amp; position)
3979 {
3980     if (position.isZero() &amp;&amp; !hasRareData())
3981         return;
3982     ensureElementRareData().setSavedLayerScrollPosition(position);
3983 }
3984 
3985 RefPtr&lt;Attr&gt; Element::attrIfExists(const AtomString&amp; localName, bool shouldIgnoreAttributeCase)
3986 {
3987     if (auto* attrNodeList = attrNodeListForElement(*this))
3988         return findAttrNodeInList(*attrNodeList, localName, shouldIgnoreAttributeCase);
3989     return nullptr;
3990 }
3991 
3992 RefPtr&lt;Attr&gt; Element::attrIfExists(const QualifiedName&amp; name)
3993 {
3994     if (auto* attrNodeList = attrNodeListForElement(*this))
3995         return findAttrNodeInList(*attrNodeList, name);
3996     return nullptr;
3997 }
3998 
3999 Ref&lt;Attr&gt; Element::ensureAttr(const QualifiedName&amp; name)
4000 {
4001     auto&amp; attrNodeList = ensureAttrNodeListForElement(*this);
4002     RefPtr&lt;Attr&gt; attrNode = findAttrNodeInList(attrNodeList, name);
4003     if (!attrNode) {
4004         attrNode = Attr::create(*this, name);
4005         attrNode-&gt;setTreeScopeRecursively(treeScope());
4006         attrNodeList.append(attrNode);
4007     }
4008     return attrNode.releaseNonNull();
4009 }
4010 
4011 void Element::detachAttrNodeFromElementWithValue(Attr* attrNode, const AtomString&amp; value)
4012 {
4013     ASSERT(hasSyntheticAttrChildNodes());
4014     attrNode-&gt;detachFromElementWithValue(value);
4015 
4016     auto&amp; attrNodeList = *attrNodeListForElement(*this);
4017     bool found = attrNodeList.removeFirstMatching([attrNode](auto&amp; attribute) {
4018         return attribute-&gt;qualifiedName() == attrNode-&gt;qualifiedName();
4019     });
4020     ASSERT_UNUSED(found, found);
4021     if (attrNodeList.isEmpty())
4022         removeAttrNodeListForElement(*this);
4023 }
4024 
4025 void Element::detachAllAttrNodesFromElement()
4026 {
4027     auto* attrNodeList = attrNodeListForElement(*this);
4028     ASSERT(attrNodeList);
4029 
4030     for (const Attribute&amp; attribute : attributesIterator()) {
4031         if (RefPtr&lt;Attr&gt; attrNode = findAttrNodeInList(*attrNodeList, attribute.name()))
4032             attrNode-&gt;detachFromElementWithValue(attribute.value());
4033     }
4034 
4035     removeAttrNodeListForElement(*this);
4036 }
4037 
4038 void Element::resetComputedStyle()
4039 {
4040     if (!hasRareData() || !elementRareData()-&gt;computedStyle())
4041         return;
4042 
4043     auto reset = [](Element&amp; element) {
4044         if (!element.hasRareData() || !element.elementRareData()-&gt;computedStyle())
4045             return;
4046         if (element.hasCustomStyleResolveCallbacks())
4047             element.willResetComputedStyle();
4048         element.elementRareData()-&gt;resetComputedStyle();
4049     };
4050     reset(*this);
4051     for (auto&amp; child : descendantsOfType&lt;Element&gt;(*this))
4052         reset(child);
4053 }
4054 
4055 void Element::resetStyleRelations()
4056 {
4057     // FIXME: Make this code more consistent.
4058     clearFlag(StyleAffectedByFocusWithinFlag);
4059     clearStyleFlags();
4060     if (!hasRareData())
4061         return;
4062     elementRareData()-&gt;resetStyleRelations();
4063 }
4064 
4065 void Element::clearHoverAndActiveStatusBeforeDetachingRenderer()
4066 {
4067     if (!isUserActionElement())
4068         return;
4069     if (hovered())
4070         document().hoveredElementDidDetach(*this);
4071     if (isInActiveChain())
4072         document().elementInActiveChainDidDetach(*this);
4073     document().userActionElements().clearActiveAndHovered(*this);
4074 }
4075 
4076 void Element::willRecalcStyle(Style::Change)
4077 {
4078     ASSERT(hasCustomStyleResolveCallbacks());
4079 }
4080 
4081 void Element::didRecalcStyle(Style::Change)
4082 {
4083     ASSERT(hasCustomStyleResolveCallbacks());
4084 }
4085 
4086 void Element::willResetComputedStyle()
4087 {
4088     ASSERT(hasCustomStyleResolveCallbacks());
4089 }
4090 
4091 void Element::willAttachRenderers()
4092 {
4093     ASSERT(hasCustomStyleResolveCallbacks());
4094 }
4095 
4096 void Element::didAttachRenderers()
4097 {
4098     ASSERT(hasCustomStyleResolveCallbacks());
4099 }
4100 
4101 void Element::willDetachRenderers()
4102 {
4103     ASSERT(hasCustomStyleResolveCallbacks());
4104 }
4105 
4106 void Element::didDetachRenderers()
4107 {
4108     ASSERT(hasCustomStyleResolveCallbacks());
4109 }
4110 
4111 Optional&lt;Style::ElementStyle&gt; Element::resolveCustomStyle(const RenderStyle&amp;, const RenderStyle*)
4112 {
4113     ASSERT(hasCustomStyleResolveCallbacks());
4114     return WTF::nullopt;
4115 }
4116 
4117 void Element::cloneAttributesFromElement(const Element&amp; other)
4118 {
4119     if (hasSyntheticAttrChildNodes())
4120         detachAllAttrNodesFromElement();
4121 
4122     other.synchronizeAllAttributes();
4123     if (!other.m_elementData) {
4124         m_elementData = nullptr;
4125         return;
4126     }
4127 
4128     // We can&#39;t update window and document&#39;s named item maps since the presence of image and object elements depend on other attributes and children.
4129     // Fortunately, those named item maps are only updated when this element is in the document, which should never be the case.
4130     ASSERT(!isConnected());
4131 
4132     const AtomString&amp; oldID = getIdAttribute();
4133     const AtomString&amp; newID = other.getIdAttribute();
4134 
4135     if (!oldID.isNull() || !newID.isNull())
4136         updateId(oldID, newID, NotifyObservers::No); // Will notify observers after the attribute is actually changed.
4137 
4138     const AtomString&amp; oldName = getNameAttribute();
4139     const AtomString&amp; newName = other.getNameAttribute();
4140 
4141     if (!oldName.isNull() || !newName.isNull())
4142         updateName(oldName, newName);
4143 
4144     // If &#39;other&#39; has a mutable ElementData, convert it to an immutable one so we can share it between both elements.
4145     // We can only do this if there is no CSSOM wrapper for other&#39;s inline style, and there are no presentation attributes.
4146     if (is&lt;UniqueElementData&gt;(*other.m_elementData)
4147         &amp;&amp; !other.m_elementData-&gt;presentationAttributeStyle()
4148         &amp;&amp; (!other.m_elementData-&gt;inlineStyle() || !other.m_elementData-&gt;inlineStyle()-&gt;hasCSSOMWrapper()))
4149         const_cast&lt;Element&amp;&gt;(other).m_elementData = downcast&lt;UniqueElementData&gt;(*other.m_elementData).makeShareableCopy();
4150 
4151     if (!other.m_elementData-&gt;isUnique())
4152         m_elementData = other.m_elementData;
4153     else
4154         m_elementData = other.m_elementData-&gt;makeUniqueCopy();
4155 
4156     for (const Attribute&amp; attribute : attributesIterator())
4157         attributeChanged(attribute.name(), nullAtom(), attribute.value(), ModifiedByCloning);
4158 }
4159 
4160 void Element::cloneDataFromElement(const Element&amp; other)
4161 {
4162     cloneAttributesFromElement(other);
4163     copyNonAttributePropertiesFromElement(other);
4164 }
4165 
4166 void Element::createUniqueElementData()
4167 {
4168     if (!m_elementData)
4169         m_elementData = UniqueElementData::create();
4170     else
4171         m_elementData = downcast&lt;ShareableElementData&gt;(*m_elementData).makeUniqueCopy();
4172 }
4173 
4174 bool Element::hasPendingResources() const
4175 {
4176     return hasRareData() &amp;&amp; elementRareData()-&gt;hasPendingResources();
4177 }
4178 
4179 void Element::setHasPendingResources()
4180 {
4181     ensureElementRareData().setHasPendingResources(true);
4182 }
4183 
4184 void Element::clearHasPendingResources()
4185 {
4186     if (!hasRareData())
4187         return;
4188     elementRareData()-&gt;setHasPendingResources(false);
4189 }
4190 
4191 bool Element::hasCSSAnimation() const
4192 {
4193     return hasRareData() &amp;&amp; elementRareData()-&gt;hasCSSAnimation();
4194 }
4195 
4196 void Element::setHasCSSAnimation()
4197 {
4198     ensureElementRareData().setHasCSSAnimation(true);
4199 }
4200 
4201 void Element::clearHasCSSAnimation()
4202 {
4203     if (!hasRareData())
4204         return;
4205     elementRareData()-&gt;setHasCSSAnimation(false);
4206 }
4207 
4208 bool Element::canContainRangeEndPoint() const
4209 {
4210     return !equalLettersIgnoringASCIICase(attributeWithoutSynchronization(roleAttr), &quot;img&quot;);
4211 }
4212 
4213 String Element::completeURLsInAttributeValue(const URL&amp; base, const Attribute&amp; attribute) const
4214 {
4215     return URL(base, attribute.value()).string();
4216 }
4217 
4218 ExceptionOr&lt;Node*&gt; Element::insertAdjacent(const String&amp; where, Ref&lt;Node&gt;&amp;&amp; newChild)
4219 {
4220     // In Internet Explorer if the element has no parent and where is &quot;beforeBegin&quot; or &quot;afterEnd&quot;,
4221     // a document fragment is created and the elements appended in the correct order. This document
4222     // fragment isn&#39;t returned anywhere.
4223     //
4224     // This is impossible for us to implement as the DOM tree does not allow for such structures,
4225     // Opera also appears to disallow such usage.
4226 
4227     if (equalLettersIgnoringASCIICase(where, &quot;beforebegin&quot;)) {
4228         auto* parent = this-&gt;parentNode();
4229         if (!parent)
4230             return nullptr;
4231         auto result = parent-&gt;insertBefore(newChild, this);
4232         if (result.hasException())
4233             return result.releaseException();
4234         return newChild.ptr();
4235     }
4236 
4237     if (equalLettersIgnoringASCIICase(where, &quot;afterbegin&quot;)) {
4238         auto result = insertBefore(newChild, firstChild());
4239         if (result.hasException())
4240             return result.releaseException();
4241         return newChild.ptr();
4242     }
4243 
4244     if (equalLettersIgnoringASCIICase(where, &quot;beforeend&quot;)) {
4245         auto result = appendChild(newChild);
4246         if (result.hasException())
4247             return result.releaseException();
4248         return newChild.ptr();
4249     }
4250 
4251     if (equalLettersIgnoringASCIICase(where, &quot;afterend&quot;)) {
4252         auto* parent = this-&gt;parentNode();
4253         if (!parent)
4254             return nullptr;
4255         auto result = parent-&gt;insertBefore(newChild, nextSibling());
4256         if (result.hasException())
4257             return result.releaseException();
4258         return newChild.ptr();
4259     }
4260 
4261     return Exception { SyntaxError };
4262 }
4263 
4264 ExceptionOr&lt;Element*&gt; Element::insertAdjacentElement(const String&amp; where, Element&amp; newChild)
4265 {
4266     auto result = insertAdjacent(where, newChild);
4267     if (result.hasException())
4268         return result.releaseException();
4269     return downcast&lt;Element&gt;(result.releaseReturnValue());
4270 }
4271 
4272 // Step 1 of https://w3c.github.io/DOM-Parsing/#dom-element-insertadjacenthtml.
4273 static ExceptionOr&lt;ContainerNode&amp;&gt; contextNodeForInsertion(const String&amp; where, Element&amp; element)
4274 {
4275     if (equalLettersIgnoringASCIICase(where, &quot;beforebegin&quot;) || equalLettersIgnoringASCIICase(where, &quot;afterend&quot;)) {
4276         auto* parent = element.parentNode();
4277         if (!parent || is&lt;Document&gt;(*parent))
4278             return Exception { NoModificationAllowedError };
4279         return *parent;
4280     }
4281     if (equalLettersIgnoringASCIICase(where, &quot;afterbegin&quot;) || equalLettersIgnoringASCIICase(where, &quot;beforeend&quot;))
4282         return element;
4283     return Exception { SyntaxError };
4284 }
4285 
4286 // Step 2 of https://w3c.github.io/DOM-Parsing/#dom-element-insertadjacenthtml.
4287 static ExceptionOr&lt;Ref&lt;Element&gt;&gt; contextElementForInsertion(const String&amp; where, Element&amp; element)
4288 {
4289     auto contextNodeResult = contextNodeForInsertion(where, element);
4290     if (contextNodeResult.hasException())
4291         return contextNodeResult.releaseException();
4292     auto&amp; contextNode = contextNodeResult.releaseReturnValue();
4293     if (!is&lt;Element&gt;(contextNode) || (contextNode.document().isHTMLDocument() &amp;&amp; is&lt;HTMLHtmlElement&gt;(contextNode)))
4294         return Ref&lt;Element&gt; { HTMLBodyElement::create(contextNode.document()) };
4295     return Ref&lt;Element&gt; { downcast&lt;Element&gt;(contextNode) };
4296 }
4297 
4298 // https://w3c.github.io/DOM-Parsing/#dom-element-insertadjacenthtml
4299 ExceptionOr&lt;void&gt; Element::insertAdjacentHTML(const String&amp; where, const String&amp; markup, NodeVector* addedNodes)
4300 {
4301     // Steps 1 and 2.
4302     auto contextElement = contextElementForInsertion(where, *this);
4303     if (contextElement.hasException())
4304         return contextElement.releaseException();
4305     // Step 3.
4306     auto fragment = createFragmentForInnerOuterHTML(contextElement.releaseReturnValue(), markup, AllowScriptingContent);
4307     if (fragment.hasException())
4308         return fragment.releaseException();
4309 
4310     if (UNLIKELY(addedNodes)) {
4311         // Must be called before insertAdjacent, as otherwise the children of fragment will be moved
4312         // to their new parent and will be harder to keep track of.
4313         *addedNodes = collectChildNodes(fragment.returnValue());
4314     }
4315 
4316     // Step 4.
4317     auto result = insertAdjacent(where, fragment.releaseReturnValue());
4318     if (result.hasException())
4319         return result.releaseException();
4320     return { };
4321 }
4322 
4323 ExceptionOr&lt;void&gt; Element::insertAdjacentHTML(const String&amp; where, const String&amp; markup)
4324 {
4325     return insertAdjacentHTML(where, markup, nullptr);
4326 }
4327 
4328 ExceptionOr&lt;void&gt; Element::insertAdjacentText(const String&amp; where, const String&amp; text)
4329 {
4330     auto result = insertAdjacent(where, document().createTextNode(text));
4331     if (result.hasException())
4332         return result.releaseException();
4333     return { };
4334 }
4335 
4336 Element* Element::findAnchorElementForLink(String&amp; outAnchorName)
4337 {
4338     if (!isLink())
4339         return nullptr;
4340 
4341     const AtomString&amp; href = attributeWithoutSynchronization(HTMLNames::hrefAttr);
4342     if (href.isNull())
4343         return nullptr;
4344 
4345     Document&amp; document = this-&gt;document();
4346     URL url = document.completeURL(href);
4347     if (!url.isValid())
4348         return nullptr;
4349 
4350     if (url.hasFragmentIdentifier() &amp;&amp; equalIgnoringFragmentIdentifier(url, document.baseURL())) {
4351         outAnchorName = url.fragmentIdentifier();
4352         return document.findAnchor(outAnchorName);
4353     }
4354 
4355     return nullptr;
4356 }
4357 
4358 ExceptionOr&lt;Ref&lt;WebAnimation&gt;&gt; Element::animate(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::Strong&lt;JSC::JSObject&gt;&amp;&amp; keyframes, Optional&lt;Variant&lt;double, KeyframeAnimationOptions&gt;&gt;&amp;&amp; options)
4359 {
4360     String id = &quot;&quot;;
4361     Optional&lt;Variant&lt;double, KeyframeEffectOptions&gt;&gt; keyframeEffectOptions;
4362     if (options) {
4363         auto optionsValue = options.value();
4364         Variant&lt;double, KeyframeEffectOptions&gt; keyframeEffectOptionsVariant;
4365         if (WTF::holds_alternative&lt;double&gt;(optionsValue))
4366             keyframeEffectOptionsVariant = WTF::get&lt;double&gt;(optionsValue);
4367         else {
4368             auto keyframeEffectOptions = WTF::get&lt;KeyframeAnimationOptions&gt;(optionsValue);
4369             id = keyframeEffectOptions.id;
4370             keyframeEffectOptionsVariant = WTFMove(keyframeEffectOptions);
4371         }
4372         keyframeEffectOptions = keyframeEffectOptionsVariant;
4373     }
4374 
4375     auto keyframeEffectResult = KeyframeEffect::create(lexicalGlobalObject, this, WTFMove(keyframes), WTFMove(keyframeEffectOptions));
4376     if (keyframeEffectResult.hasException())
4377         return keyframeEffectResult.releaseException();
4378 
4379     auto animation = WebAnimation::create(document(), &amp;keyframeEffectResult.returnValue().get());
4380     animation-&gt;setId(id);
4381 
4382     auto animationPlayResult = animation-&gt;play();
4383     if (animationPlayResult.hasException())
4384         return animationPlayResult.releaseException();
4385 
4386     return animation;
4387 }
4388 
4389 Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; Element::getAnimations(Optional&lt;GetAnimationsOptions&gt; options)
4390 {
4391     // If we are to return animations in the subtree, we can get all of the document&#39;s animations and filter
4392     // animations targeting that are not registered on this element, one of its pseudo elements or a child&#39;s
4393     // pseudo element.
4394     if (options &amp;&amp; options-&gt;subtree) {
4395         Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animations;
4396         for (auto&amp; animation : document().getAnimations()) {
4397             auto* effect = animation-&gt;effect();
4398             ASSERT(is&lt;KeyframeEffect&gt;(animation-&gt;effect()));
4399             auto* target = downcast&lt;KeyframeEffect&gt;(*effect).target();
4400             ASSERT(target);
4401             if (is&lt;PseudoElement&gt;(target)) {
4402                 if (contains(downcast&lt;PseudoElement&gt;(*target).hostElement()))
4403                     animations.append(animation);
4404             } else if (contains(target))
4405                 animations.append(animation);
4406         }
4407         return animations;
4408     }
4409 
4410     // For the list of animations to be current, we need to account for any pending CSS changes,
4411     // such as updates to CSS Animations and CSS Transitions.
4412     // FIXME: We might be able to use ComputedStyleExtractor which is more optimized.
4413     document().updateStyleIfNeeded();
4414 
4415     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animations;
4416     if (auto timeline = document().existingTimeline()) {
4417         for (auto&amp; animation : timeline-&gt;animationsForElement(*this, AnimationTimeline::Ordering::Sorted)) {
4418             if (animation-&gt;isRelevant())
4419                 animations.append(animation);
4420         }
4421     }
4422     return animations;
4423 }
4424 
4425 ElementIdentifier Element::createElementIdentifier()
4426 {
4427     auto&amp; rareData = ensureElementRareData();
4428     ASSERT(!rareData.hasElementIdentifier());
4429 
4430     rareData.setHasElementIdentifier(true);
4431     return ElementIdentifier::generate();
4432 }
4433 
4434 #if ENABLE(CSS_TYPED_OM)
4435 
4436 StylePropertyMap* Element::attributeStyleMap()
4437 {
4438     if (!hasRareData())
4439         return nullptr;
4440     return elementRareData()-&gt;attributeStyleMap();
4441 }
4442 
4443 void Element::setAttributeStyleMap(Ref&lt;StylePropertyMap&gt;&amp;&amp; map)
4444 {
4445     ensureElementRareData().setAttributeStyleMap(WTFMove(map));
4446 }
4447 
4448 #endif
4449 
4450 } // namespace WebCore
    </pre>
  </body>
</html>
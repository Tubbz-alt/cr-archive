<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/mathml/MathMLElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../mapfile-vers.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MathMLOperatorDictionary.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/mathml/MathMLElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 17  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 18  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 19  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 20  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 21  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 22  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 23  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;MathMLElement.h&quot;
 31 
 32 #if ENABLE(MATHML)
 33 
 34 #include &quot;EventHandler.h&quot;
 35 #include &quot;FrameLoader.h&quot;
 36 #include &quot;HTMLAnchorElement.h&quot;


 37 #include &quot;HTMLParserIdioms.h&quot;
 38 #include &quot;MathMLNames.h&quot;
 39 #include &quot;MouseEvent.h&quot;
 40 #include &quot;RenderTableCell.h&quot;

 41 #include &lt;wtf/IsoMallocInlines.h&gt;
 42 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 43 
 44 namespace WebCore {
 45 
 46 WTF_MAKE_ISO_ALLOCATED_IMPL(MathMLElement);
 47 
 48 using namespace MathMLNames;
 49 
 50 MathMLElement::MathMLElement(const QualifiedName&amp; tagName, Document&amp; document)
 51     : StyledElement(tagName, document, CreateMathMLElement)
 52 {
 53 }
 54 
 55 Ref&lt;MathMLElement&gt; MathMLElement::create(const QualifiedName&amp; tagName, Document&amp; document)
 56 {
 57     return adoptRef(*new MathMLElement(tagName, document));
 58 }
 59 
 60 unsigned MathMLElement::colSpan() const
</pre>
<hr />
<pre>
 70     if (!hasTagName(mtdTag))
 71         return 1u;
 72     auto&amp; rowSpanValue = attributeWithoutSynchronization(rowspanAttr);
 73     static const unsigned maxRowspan = 8190; // This constant comes from HTMLTableCellElement.
 74     return std::max(1u, std::min(limitToOnlyHTMLNonNegative(rowSpanValue, 1u), maxRowspan));
 75 }
 76 
 77 void MathMLElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
 78 {
 79     if (name == hrefAttr) {
 80         bool wasLink = isLink();
 81         setIsLink(!value.isNull() &amp;&amp; !shouldProhibitLinks(this));
 82         if (wasLink != isLink())
 83             invalidateStyleForSubtree();
 84     } else if (name == rowspanAttr) {
 85         if (is&lt;RenderTableCell&gt;(renderer()) &amp;&amp; hasTagName(mtdTag))
 86             downcast&lt;RenderTableCell&gt;(*renderer()).colSpanOrRowSpanChanged();
 87     } else if (name == columnspanAttr) {
 88         if (is&lt;RenderTableCell&gt;(renderer()) &amp;&amp; hasTagName(mtdTag))
 89             downcast&lt;RenderTableCell&gt;(renderer())-&gt;colSpanOrRowSpanChanged();
<span class="line-modified"> 90     } else</span>











 91         StyledElement::parseAttribute(name, value);

 92 }
 93 
 94 bool MathMLElement::isPresentationAttribute(const QualifiedName&amp; name) const
 95 {
 96     if (name == backgroundAttr || name == colorAttr || name == dirAttr || name == fontfamilyAttr || name == fontsizeAttr || name == fontstyleAttr || name == fontweightAttr || name == mathbackgroundAttr || name == mathcolorAttr || name == mathsizeAttr)
 97         return true;
 98     return StyledElement::isPresentationAttribute(name);
 99 }
100 
101 static String convertMathSizeIfNeeded(const AtomString&amp; value)
102 {
103     if (value == &quot;small&quot;)
104         return &quot;0.75em&quot;;
105     if (value == &quot;normal&quot;)
106         return &quot;1em&quot;;
107     if (value == &quot;big&quot;)
108         return &quot;1.5em&quot;;
109 
110     // FIXME: mathsize accepts any MathML length, including named spaces (see parseMathMLLength).
111     // FIXME: Might be better to use double than float.
112     // FIXME: Might be better to use &quot;shortest&quot; numeric formatting instead of fixed width.
113     bool ok = false;
114     float unitlessValue = value.toFloat(&amp;ok);
115     if (!ok)
116         return value;
117     return makeString(FormattedNumber::fixedWidth(unitlessValue * 100, 3), &#39;%&#39;);
118 }
119 
120 void MathMLElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomString&amp; value, MutableStyleProperties&amp; style)
121 {
122     if (name == mathbackgroundAttr)
123         addPropertyToPresentationAttributeStyle(style, CSSPropertyBackgroundColor, value);
124     else if (name == mathsizeAttr)
125         addPropertyToPresentationAttributeStyle(style, CSSPropertyFontSize, convertMathSizeIfNeeded(value));
126     else if (name == mathcolorAttr)
127         addPropertyToPresentationAttributeStyle(style, CSSPropertyColor, value);
<span class="line-removed">128     // FIXME: The following are deprecated attributes that should lose if there is a conflict with a non-deprecated attribute.</span>
<span class="line-removed">129     else if (name == fontsizeAttr)</span>
<span class="line-removed">130         addPropertyToPresentationAttributeStyle(style, CSSPropertyFontSize, value);</span>
<span class="line-removed">131     else if (name == backgroundAttr)</span>
<span class="line-removed">132         addPropertyToPresentationAttributeStyle(style, CSSPropertyBackgroundColor, value);</span>
<span class="line-removed">133     else if (name == colorAttr)</span>
<span class="line-removed">134         addPropertyToPresentationAttributeStyle(style, CSSPropertyColor, value);</span>
<span class="line-removed">135     else if (name == fontstyleAttr)</span>
<span class="line-removed">136         addPropertyToPresentationAttributeStyle(style, CSSPropertyFontStyle, value);</span>
<span class="line-removed">137     else if (name == fontweightAttr)</span>
<span class="line-removed">138         addPropertyToPresentationAttributeStyle(style, CSSPropertyFontWeight, value);</span>
<span class="line-removed">139     else if (name == fontfamilyAttr)</span>
<span class="line-removed">140         addPropertyToPresentationAttributeStyle(style, CSSPropertyFontFamily, value);</span>
141     else if (name == dirAttr) {
<span class="line-modified">142         if (hasTagName(mathTag) || hasTagName(mrowTag) || hasTagName(mstyleTag) || isMathMLToken())</span>
143             addPropertyToPresentationAttributeStyle(style, CSSPropertyDirection, value);
<span class="line-modified">144     }  else {</span>
<span class="line-modified">145         ASSERT(!isPresentationAttribute(name));</span>
<span class="line-modified">146         StyledElement::collectStyleForPresentationAttribute(name, value, style);</span>



















147     }
148 }
149 
150 bool MathMLElement::childShouldCreateRenderer(const Node&amp; child) const
151 {
152     // In general, only MathML children are allowed. Text nodes are only visible in token MathML elements.
153     return is&lt;MathMLElement&gt;(child);
154 }
155 
156 bool MathMLElement::willRespondToMouseClickEvents()
157 {
158     return isLink() || StyledElement::willRespondToMouseClickEvents();
159 }
160 
161 void MathMLElement::defaultEventHandler(Event&amp; event)
162 {
163     if (isLink()) {
164         if (focused() &amp;&amp; isEnterKeyKeydownEvent(event)) {
165             event.setDefaultHandled();
166             dispatchSimulatedClick(&amp;event);
</pre>
</td>
<td>
<hr />
<pre>
 17  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 18  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 19  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 20  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 21  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 22  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 23  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;MathMLElement.h&quot;
 31 
 32 #if ENABLE(MATHML)
 33 
 34 #include &quot;EventHandler.h&quot;
 35 #include &quot;FrameLoader.h&quot;
 36 #include &quot;HTMLAnchorElement.h&quot;
<span class="line-added"> 37 #include &quot;HTMLElement.h&quot;</span>
<span class="line-added"> 38 #include &quot;HTMLNames.h&quot;</span>
 39 #include &quot;HTMLParserIdioms.h&quot;
 40 #include &quot;MathMLNames.h&quot;
 41 #include &quot;MouseEvent.h&quot;
 42 #include &quot;RenderTableCell.h&quot;
<span class="line-added"> 43 #include &quot;Settings.h&quot;</span>
 44 #include &lt;wtf/IsoMallocInlines.h&gt;
 45 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 46 
 47 namespace WebCore {
 48 
 49 WTF_MAKE_ISO_ALLOCATED_IMPL(MathMLElement);
 50 
 51 using namespace MathMLNames;
 52 
 53 MathMLElement::MathMLElement(const QualifiedName&amp; tagName, Document&amp; document)
 54     : StyledElement(tagName, document, CreateMathMLElement)
 55 {
 56 }
 57 
 58 Ref&lt;MathMLElement&gt; MathMLElement::create(const QualifiedName&amp; tagName, Document&amp; document)
 59 {
 60     return adoptRef(*new MathMLElement(tagName, document));
 61 }
 62 
 63 unsigned MathMLElement::colSpan() const
</pre>
<hr />
<pre>
 73     if (!hasTagName(mtdTag))
 74         return 1u;
 75     auto&amp; rowSpanValue = attributeWithoutSynchronization(rowspanAttr);
 76     static const unsigned maxRowspan = 8190; // This constant comes from HTMLTableCellElement.
 77     return std::max(1u, std::min(limitToOnlyHTMLNonNegative(rowSpanValue, 1u), maxRowspan));
 78 }
 79 
 80 void MathMLElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
 81 {
 82     if (name == hrefAttr) {
 83         bool wasLink = isLink();
 84         setIsLink(!value.isNull() &amp;&amp; !shouldProhibitLinks(this));
 85         if (wasLink != isLink())
 86             invalidateStyleForSubtree();
 87     } else if (name == rowspanAttr) {
 88         if (is&lt;RenderTableCell&gt;(renderer()) &amp;&amp; hasTagName(mtdTag))
 89             downcast&lt;RenderTableCell&gt;(*renderer()).colSpanOrRowSpanChanged();
 90     } else if (name == columnspanAttr) {
 91         if (is&lt;RenderTableCell&gt;(renderer()) &amp;&amp; hasTagName(mtdTag))
 92             downcast&lt;RenderTableCell&gt;(renderer())-&gt;colSpanOrRowSpanChanged();
<span class="line-modified"> 93     } else if (name == HTMLNames::tabindexAttr) {</span>
<span class="line-added"> 94         if (value.isEmpty())</span>
<span class="line-added"> 95             clearTabIndexExplicitlyIfNeeded();</span>
<span class="line-added"> 96         else if (auto optionalTabIndex = parseHTMLInteger(value))</span>
<span class="line-added"> 97             setTabIndexExplicitly(optionalTabIndex.value());</span>
<span class="line-added"> 98     } else {</span>
<span class="line-added"> 99         auto&amp; eventName = HTMLElement::eventNameForEventHandlerAttribute(name);</span>
<span class="line-added">100         if (!eventName.isNull()) {</span>
<span class="line-added">101             setAttributeEventListener(eventName, name, value);</span>
<span class="line-added">102             return;</span>
<span class="line-added">103         }</span>
<span class="line-added">104 </span>
105         StyledElement::parseAttribute(name, value);
<span class="line-added">106     }</span>
107 }
108 
109 bool MathMLElement::isPresentationAttribute(const QualifiedName&amp; name) const
110 {
111     if (name == backgroundAttr || name == colorAttr || name == dirAttr || name == fontfamilyAttr || name == fontsizeAttr || name == fontstyleAttr || name == fontweightAttr || name == mathbackgroundAttr || name == mathcolorAttr || name == mathsizeAttr)
112         return true;
113     return StyledElement::isPresentationAttribute(name);
114 }
115 
116 static String convertMathSizeIfNeeded(const AtomString&amp; value)
117 {
118     if (value == &quot;small&quot;)
119         return &quot;0.75em&quot;;
120     if (value == &quot;normal&quot;)
121         return &quot;1em&quot;;
122     if (value == &quot;big&quot;)
123         return &quot;1.5em&quot;;
124 
125     // FIXME: mathsize accepts any MathML length, including named spaces (see parseMathMLLength).
126     // FIXME: Might be better to use double than float.
127     // FIXME: Might be better to use &quot;shortest&quot; numeric formatting instead of fixed width.
128     bool ok = false;
129     float unitlessValue = value.toFloat(&amp;ok);
130     if (!ok)
131         return value;
132     return makeString(FormattedNumber::fixedWidth(unitlessValue * 100, 3), &#39;%&#39;);
133 }
134 
135 void MathMLElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomString&amp; value, MutableStyleProperties&amp; style)
136 {
137     if (name == mathbackgroundAttr)
138         addPropertyToPresentationAttributeStyle(style, CSSPropertyBackgroundColor, value);
139     else if (name == mathsizeAttr)
140         addPropertyToPresentationAttributeStyle(style, CSSPropertyFontSize, convertMathSizeIfNeeded(value));
141     else if (name == mathcolorAttr)
142         addPropertyToPresentationAttributeStyle(style, CSSPropertyColor, value);













143     else if (name == dirAttr) {
<span class="line-modified">144         if (document().settings().coreMathMLEnabled() || hasTagName(mathTag) || hasTagName(mrowTag) || hasTagName(mstyleTag) || isMathMLToken())</span>
145             addPropertyToPresentationAttributeStyle(style, CSSPropertyDirection, value);
<span class="line-modified">146     } else {</span>
<span class="line-modified">147         if (document().settings().coreMathMLEnabled()) {</span>
<span class="line-modified">148             StyledElement::collectStyleForPresentationAttribute(name, value, style);</span>
<span class="line-added">149             return;</span>
<span class="line-added">150         }</span>
<span class="line-added">151         // FIXME: The following are deprecated attributes that should lose if there is a conflict with a non-deprecated attribute.</span>
<span class="line-added">152         if (name == fontsizeAttr)</span>
<span class="line-added">153             addPropertyToPresentationAttributeStyle(style, CSSPropertyFontSize, value);</span>
<span class="line-added">154         else if (name == backgroundAttr)</span>
<span class="line-added">155             addPropertyToPresentationAttributeStyle(style, CSSPropertyBackgroundColor, value);</span>
<span class="line-added">156         else if (name == colorAttr)</span>
<span class="line-added">157             addPropertyToPresentationAttributeStyle(style, CSSPropertyColor, value);</span>
<span class="line-added">158         else if (name == fontstyleAttr)</span>
<span class="line-added">159             addPropertyToPresentationAttributeStyle(style, CSSPropertyFontStyle, value);</span>
<span class="line-added">160         else if (name == fontweightAttr)</span>
<span class="line-added">161             addPropertyToPresentationAttributeStyle(style, CSSPropertyFontWeight, value);</span>
<span class="line-added">162         else if (name == fontfamilyAttr)</span>
<span class="line-added">163             addPropertyToPresentationAttributeStyle(style, CSSPropertyFontFamily, value);</span>
<span class="line-added">164         else {</span>
<span class="line-added">165             ASSERT(!isPresentationAttribute(name));</span>
<span class="line-added">166             StyledElement::collectStyleForPresentationAttribute(name, value, style);</span>
<span class="line-added">167         }</span>
168     }
169 }
170 
171 bool MathMLElement::childShouldCreateRenderer(const Node&amp; child) const
172 {
173     // In general, only MathML children are allowed. Text nodes are only visible in token MathML elements.
174     return is&lt;MathMLElement&gt;(child);
175 }
176 
177 bool MathMLElement::willRespondToMouseClickEvents()
178 {
179     return isLink() || StyledElement::willRespondToMouseClickEvents();
180 }
181 
182 void MathMLElement::defaultEventHandler(Event&amp; event)
183 {
184     if (isLink()) {
185         if (focused() &amp;&amp; isEnterKeyKeydownEvent(event)) {
186             event.setDefaultHandled();
187             dispatchSimulatedClick(&amp;event);
</pre>
</td>
</tr>
</table>
<center><a href="../mapfile-vers.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MathMLOperatorDictionary.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
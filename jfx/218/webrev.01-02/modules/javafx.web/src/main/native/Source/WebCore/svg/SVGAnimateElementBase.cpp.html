<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/svg/SVGAnimateElementBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2004, 2005 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  3  * Copyright (C) 2004, 2005, 2006 Rob Buis &lt;buis@kde.org&gt;
  4  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
  5  * Copyright (C) Research In Motion Limited 2011. All rights reserved.
  6  * Copyright (C) 2014 Adobe Systems Incorporated. All rights reserved.
  7  *
  8  * This library is free software; you can redistribute it and/or
  9  * modify it under the terms of the GNU Library General Public
 10  * License as published by the Free Software Foundation; either
 11  * version 2 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;SVGAnimateElementBase.h&quot;
 26 
 27 #include &quot;QualifiedName.h&quot;
 28 #include &quot;SVGAttributeAnimator.h&quot;
 29 #include &quot;SVGElement.h&quot;
 30 #include &quot;SVGNames.h&quot;
 31 #include &lt;wtf/IsoMallocInlines.h&gt;
 32 
 33 namespace WebCore {
 34 
 35 WTF_MAKE_ISO_ALLOCATED_IMPL(SVGAnimateElementBase);
 36 
 37 SVGAnimateElementBase::SVGAnimateElementBase(const QualifiedName&amp; tagName, Document&amp; document)
 38     : SVGAnimationElement(tagName, document)
 39 {
 40     ASSERT(hasTagName(SVGNames::animateTag)
 41         || hasTagName(SVGNames::setTag)
 42         || hasTagName(SVGNames::animateColorTag)
 43         || hasTagName(SVGNames::animateTransformTag));
 44 }
 45 
 46 SVGAttributeAnimator* SVGAnimateElementBase::animator() const
 47 {
 48     ASSERT(targetElement());
 49     ASSERT(!hasInvalidCSSAttributeType());
 50 
 51     if (!m_animator)
 52         m_animator = targetElement()-&gt;createAnimator(attributeName(), animationMode(), calcMode(), isAccumulated(), isAdditive());
 53 
 54     return m_animator.get();
 55 }
 56 
 57 bool SVGAnimateElementBase::hasValidAttributeType() const
 58 {
 59     if (!targetElement() || hasInvalidCSSAttributeType())
 60         return false;
 61 
 62     return targetElement()-&gt;isAnimatedAttribute(attributeName());
 63 }
 64 
 65 bool SVGAnimateElementBase::hasInvalidCSSAttributeType() const
 66 {
 67     if (!targetElement())
 68         return false;
 69 
 70     if (!m_hasInvalidCSSAttributeType)
 71         m_hasInvalidCSSAttributeType = hasValidAttributeName() &amp;&amp; attributeType() == AttributeType::CSS &amp;&amp; !isTargetAttributeCSSProperty(targetElement(), attributeName());
 72 
 73     return m_hasInvalidCSSAttributeType.value();
 74 }
 75 
 76 bool SVGAnimateElementBase::isDiscreteAnimator() const
 77 {
 78     if (!hasValidAttributeType())
 79         return false;
 80 
 81     auto* animator = this-&gt;animator();
 82     return animator &amp;&amp; animator-&gt;isDiscrete();
 83 }
 84 
 85 void SVGAnimateElementBase::setTargetElement(SVGElement* target)
 86 {
 87     SVGAnimationElement::setTargetElement(target);
 88     resetAnimation();
 89 }
 90 
 91 void SVGAnimateElementBase::setAttributeName(const QualifiedName&amp; attributeName)
 92 {
 93     SVGSMILElement::setAttributeName(attributeName);
 94     resetAnimation();
 95 }
 96 
 97 void SVGAnimateElementBase::resetAnimation()
 98 {
 99     SVGAnimationElement::resetAnimation();
100     m_animator = nullptr;
101     m_hasInvalidCSSAttributeType = { };
102 }
103 
104 bool SVGAnimateElementBase::calculateFromAndToValues(const String&amp; fromString, const String&amp; toString)
105 {
106     if (!targetElement())
107         return false;
108 
109     if (auto* animator = this-&gt;animator()) {
110         animator-&gt;setFromAndToValues(targetElement(), animateRangeString(fromString), animateRangeString(toString));
111         return true;
112     }
113     return false;
114 }
115 
116 bool SVGAnimateElementBase::calculateFromAndByValues(const String&amp; fromString, const String&amp; byString)
117 {
118     if (!this-&gt;targetElement())
119         return false;
120 
121     if (animationMode() == AnimationMode::By &amp;&amp; (!isAdditive() || isDiscreteAnimator()))
122         return false;
123 
124     if (animationMode() == AnimationMode::FromBy &amp;&amp; isDiscreteAnimator())
125         return false;
126 
127     if (auto* animator = this-&gt;animator()) {
128         animator-&gt;setFromAndByValues(targetElement(), animateRangeString(fromString), animateRangeString(byString));
129         return true;
130     }
131     return false;
132 }
133 
134 bool SVGAnimateElementBase::calculateToAtEndOfDurationValue(const String&amp; toAtEndOfDurationString)
135 {
136     if (!targetElement() || toAtEndOfDurationString.isEmpty())
137         return false;
138 
139     if (isDiscreteAnimator())
140         return true;
141 
142     if (auto* animator = this-&gt;animator()) {
143         animator-&gt;setToAtEndOfDurationValue(animateRangeString(toAtEndOfDurationString));
144         return true;
145     }
146     return false;
147 }
148 
149 void SVGAnimateElementBase::startAnimation()
150 {
151     if (!targetElement())
152         return;
153 
154     if (auto protectedAnimator = makeRefPtr(this-&gt;animator()))
155         protectedAnimator-&gt;start(targetElement());
156 }
157 
158 void SVGAnimateElementBase::calculateAnimatedValue(float progress, unsigned repeatCount)
159 {
160     if (!targetElement())
161         return;
162 
163     ASSERT(progress &gt;= 0 &amp;&amp; progress &lt;= 1);
164     if (hasTagName(SVGNames::setTag))
165         progress = 1;
166 
167     if (calcMode() == CalcMode::Discrete)
168         progress = progress &lt; 0.5 ? 0 : 1;
169 
170     if (auto protectedAnimator = makeRefPtr(this-&gt;animator()))
171         protectedAnimator-&gt;animate(targetElement(), progress, repeatCount);
172 }
173 
174 void SVGAnimateElementBase::applyResultsToTarget()
175 {
176     if (!targetElement())
177         return;
178 
179     if (auto* animator = this-&gt;animator())
180         animator-&gt;apply(targetElement());
181 }
182 
183 void SVGAnimateElementBase::stopAnimation(SVGElement* targetElement)
184 {
185     if (!targetElement)
186         return;
187 
188     if (auto* animator = this-&gt;animatorIfExists())
189         animator-&gt;stop(targetElement);
190 }
191 
192 Optional&lt;float&gt; SVGAnimateElementBase::calculateDistance(const String&amp; fromString, const String&amp; toString)
193 {
194     // FIXME: A return value of float is not enough to support paced animations on lists.
195     if (!targetElement())
196         return { };
197 
198     if (auto* animator = this-&gt;animator())
199         return animator-&gt;calculateDistance(targetElement(), fromString, toString);
200 
201     return { };
202 }
203 
204 } // namespace WebCore
    </pre>
  </body>
</html>
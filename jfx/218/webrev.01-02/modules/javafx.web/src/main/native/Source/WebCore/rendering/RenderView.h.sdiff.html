<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderView.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderView.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RootInlineBox.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderView.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
168     void unregisterForVisibleInViewportCallback(RenderElement&amp;);
169     void resumePausedImageAnimationsIfNeeded(const IntRect&amp; visibleRect);
170     void addRendererWithPausedImageAnimations(RenderElement&amp;, CachedImage&amp;);
171     void removeRendererWithPausedImageAnimations(RenderElement&amp;);
172     void removeRendererWithPausedImageAnimations(RenderElement&amp;, CachedImage&amp;);
173 
174     class RepaintRegionAccumulator {
175         WTF_MAKE_NONCOPYABLE(RepaintRegionAccumulator);
176     public:
177         RepaintRegionAccumulator(RenderView*);
178         ~RepaintRegionAccumulator();
179 
180     private:
181         WeakPtr&lt;RenderView&gt; m_rootView;
182         bool m_wasAccumulatingRepaintRegion;
183     };
184 
185     void scheduleLazyRepaint(RenderBox&amp;);
186     void unscheduleLazyRepaint(RenderBox&amp;);
187 



188     void protectRenderWidgetUntilLayoutIsDone(RenderWidget&amp; widget) { m_protectedRenderWidgets.append(&amp;widget); }
189     void releaseProtectedRenderWidgets() { m_protectedRenderWidgets.clear(); }
190 
191 #if ENABLE(CSS_SCROLL_SNAP)
192     void registerBoxWithScrollSnapPositions(const RenderBox&amp;);
193     void unregisterBoxWithScrollSnapPositions(const RenderBox&amp;);
194     const HashSet&lt;const RenderBox*&gt;&amp; boxesWithScrollSnapPositions() { return m_boxesWithScrollSnapPositions; }
195 #endif
196 
197 protected:
198     void mapLocalToContainer(const RenderLayerModelObject* repaintContainer, TransformState&amp;, MapCoordinatesFlags, bool* wasFixed) const override;
199     const RenderObject* pushMappingToContainer(const RenderLayerModelObject* ancestorToStopAt, RenderGeometryMap&amp;) const override;
200     void mapAbsoluteToLocalPoint(MapCoordinatesFlags, TransformState&amp;) const override;
201     bool requiresColumns(int desiredColumnCount) const override;
202 
203 private:
204     void computeColumnCountAndWidth() override;
205 
206     bool shouldRepaint(const LayoutRect&amp;) const;
207     void flushAccumulatedRepaintRegion() const;
208 
209     void layoutContent(const RenderLayoutState&amp;);
210 
211     bool isScrollableOrRubberbandableBox() const override;
212 
213 private:
214     FrameView&amp; m_frameView;
215 
216     // Include this RenderView.
217     uint64_t m_rendererCount { 1 };
218 
219     mutable std::unique_ptr&lt;Region&gt; m_accumulatedRepaintRegion;
220     SelectionRangeData m_selection;
221 


222     // FIXME: Only used by embedded WebViews inside AppKit NSViews.  Find a way to remove.
223     struct LegacyPrinting {
224         int m_bestTruncatedAt { 0 };
225         int m_truncatedAt { 0 };
226         int m_truncatorWidth { 0 };
227         IntRect m_printRect;
228         bool m_forcedPageBreak { false };
229     };
230     LegacyPrinting m_legacyPrinting;
231     // End deprecated members.
232 
233     bool shouldUsePrintingLayout() const;
234 
235     void lazyRepaintTimerFired();
236 
237     Timer m_lazyRepaintTimer;
238     HashSet&lt;RenderBox*&gt; m_renderersNeedingLazyRepaint;
239 
240     std::unique_ptr&lt;ImageQualityController&gt; m_imageQualityController;
241     Optional&lt;LayoutSize&gt; m_pageLogicalSize;
</pre>
</td>
<td>
<hr />
<pre>
168     void unregisterForVisibleInViewportCallback(RenderElement&amp;);
169     void resumePausedImageAnimationsIfNeeded(const IntRect&amp; visibleRect);
170     void addRendererWithPausedImageAnimations(RenderElement&amp;, CachedImage&amp;);
171     void removeRendererWithPausedImageAnimations(RenderElement&amp;);
172     void removeRendererWithPausedImageAnimations(RenderElement&amp;, CachedImage&amp;);
173 
174     class RepaintRegionAccumulator {
175         WTF_MAKE_NONCOPYABLE(RepaintRegionAccumulator);
176     public:
177         RepaintRegionAccumulator(RenderView*);
178         ~RepaintRegionAccumulator();
179 
180     private:
181         WeakPtr&lt;RenderView&gt; m_rootView;
182         bool m_wasAccumulatingRepaintRegion;
183     };
184 
185     void scheduleLazyRepaint(RenderBox&amp;);
186     void unscheduleLazyRepaint(RenderBox&amp;);
187 
<span class="line-added">188     void layerChildrenChangedDuringStyleChange(RenderLayer&amp;);</span>
<span class="line-added">189     RenderLayer* takeStyleChangeLayerTreeMutationRoot();</span>
<span class="line-added">190 </span>
191     void protectRenderWidgetUntilLayoutIsDone(RenderWidget&amp; widget) { m_protectedRenderWidgets.append(&amp;widget); }
192     void releaseProtectedRenderWidgets() { m_protectedRenderWidgets.clear(); }
193 
194 #if ENABLE(CSS_SCROLL_SNAP)
195     void registerBoxWithScrollSnapPositions(const RenderBox&amp;);
196     void unregisterBoxWithScrollSnapPositions(const RenderBox&amp;);
197     const HashSet&lt;const RenderBox*&gt;&amp; boxesWithScrollSnapPositions() { return m_boxesWithScrollSnapPositions; }
198 #endif
199 
200 protected:
201     void mapLocalToContainer(const RenderLayerModelObject* repaintContainer, TransformState&amp;, MapCoordinatesFlags, bool* wasFixed) const override;
202     const RenderObject* pushMappingToContainer(const RenderLayerModelObject* ancestorToStopAt, RenderGeometryMap&amp;) const override;
203     void mapAbsoluteToLocalPoint(MapCoordinatesFlags, TransformState&amp;) const override;
204     bool requiresColumns(int desiredColumnCount) const override;
205 
206 private:
207     void computeColumnCountAndWidth() override;
208 
209     bool shouldRepaint(const LayoutRect&amp;) const;
210     void flushAccumulatedRepaintRegion() const;
211 
212     void layoutContent(const RenderLayoutState&amp;);
213 
214     bool isScrollableOrRubberbandableBox() const override;
215 
216 private:
217     FrameView&amp; m_frameView;
218 
219     // Include this RenderView.
220     uint64_t m_rendererCount { 1 };
221 
222     mutable std::unique_ptr&lt;Region&gt; m_accumulatedRepaintRegion;
223     SelectionRangeData m_selection;
224 
<span class="line-added">225     WeakPtr&lt;RenderLayer&gt; m_styleChangeLayerMutationRoot;</span>
<span class="line-added">226 </span>
227     // FIXME: Only used by embedded WebViews inside AppKit NSViews.  Find a way to remove.
228     struct LegacyPrinting {
229         int m_bestTruncatedAt { 0 };
230         int m_truncatedAt { 0 };
231         int m_truncatorWidth { 0 };
232         IntRect m_printRect;
233         bool m_forcedPageBreak { false };
234     };
235     LegacyPrinting m_legacyPrinting;
236     // End deprecated members.
237 
238     bool shouldUsePrintingLayout() const;
239 
240     void lazyRepaintTimerFired();
241 
242     Timer m_lazyRepaintTimer;
243     HashSet&lt;RenderBox*&gt; m_renderersNeedingLazyRepaint;
244 
245     std::unique_ptr&lt;ImageQualityController&gt; m_imageQualityController;
246     Optional&lt;LayoutSize&gt; m_pageLogicalSize;
</pre>
</td>
</tr>
</table>
<center><a href="RenderView.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RootInlineBox.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
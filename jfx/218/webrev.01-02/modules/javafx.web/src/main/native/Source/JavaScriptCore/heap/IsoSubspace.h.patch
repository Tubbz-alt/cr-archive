diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/IsoSubspace.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/IsoSubspace.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/IsoSubspace.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/IsoSubspace.h
@@ -35,42 +35,50 @@
 class IsoAlignedMemoryAllocator;
 class IsoCellSet;
 
 class IsoSubspace : public Subspace {
 public:
-    JS_EXPORT_PRIVATE IsoSubspace(CString name, Heap&, HeapCellType*, size_t size);
+    JS_EXPORT_PRIVATE IsoSubspace(CString name, Heap&, HeapCellType*, size_t size, uint8_t numberOfLowerTierCells);
     JS_EXPORT_PRIVATE ~IsoSubspace();
 
-    size_t size() const { return m_size; }
+    size_t cellSize() { return m_directory.cellSize(); }
 
     Allocator allocatorFor(size_t, AllocatorForMode) override;
     Allocator allocatorForNonVirtual(size_t, AllocatorForMode);
 
     void* allocate(VM&, size_t, GCDeferralContext*, AllocationFailureMode) override;
     void* allocateNonVirtual(VM&, size_t, GCDeferralContext*, AllocationFailureMode);
 
+    void sweepLowerTierCell(PreciseAllocation*);
+    void clearIsoCellSetBit(PreciseAllocation*);
+
+    void* tryAllocateFromLowerTier();
+    void destroyLowerTierFreeList();
+
+    void sweep();
+
 private:
     friend class IsoCellSet;
 
-    void didResizeBits(size_t newSize) override;
-    void didRemoveBlock(size_t blockIndex) override;
+    void didResizeBits(unsigned newSize) override;
+    void didRemoveBlock(unsigned blockIndex) override;
     void didBeginSweepingToFreeList(MarkedBlock::Handle*) override;
 
-    size_t m_size;
     BlockDirectory m_directory;
     LocalAllocator m_localAllocator;
     std::unique_ptr<IsoAlignedMemoryAllocator> m_isoAlignedMemoryAllocator;
-    SentinelLinkedList<IsoCellSet, BasicRawSentinelNode<IsoCellSet>> m_cellSets;
+    SentinelLinkedList<PreciseAllocation, PackedRawSentinelNode<PreciseAllocation>> m_lowerTierFreeList;
+    SentinelLinkedList<IsoCellSet, PackedRawSentinelNode<IsoCellSet>> m_cellSets;
 };
 
 ALWAYS_INLINE Allocator IsoSubspace::allocatorForNonVirtual(size_t size, AllocatorForMode)
 {
-    RELEASE_ASSERT(size == this->size());
+    RELEASE_ASSERT(WTF::roundUpToMultipleOf<MarkedBlock::atomSize>(size) == cellSize());
     return Allocator(&m_localAllocator);
 }
 
-#define ISO_SUBSPACE_INIT(heap, heapCellType, type) ("Isolated " #type " Space", (heap), (heapCellType), sizeof(type))
+#define ISO_SUBSPACE_INIT(heap, heapCellType, type) ("Isolated " #type " Space", (heap), (heapCellType), sizeof(type), type::numberOfLowerTierCells)
 
 template<typename T>
 struct isAllocatedFromIsoSubspace {
     static constexpr bool value = std::is_same<std::result_of_t<decltype(T::template subspaceFor<T, SubspaceAccess::OnMainThread>)&(VM&)>, IsoSubspace*>::value;
 };

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/editing/MarkupAccumulator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InsertListCommand.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderedPosition.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/MarkupAccumulator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 148,16 ***</span>
      size_t positionAfterLastEntity = 0;
      for (size_t i = 0; i &lt; length; ++i) {
          CharacterType character = text[i];
          uint8_t substitution = character &lt; WTF_ARRAY_LENGTH(entityMap) ? entityMap[character] : static_cast&lt;uint8_t&gt;(EntitySubstitutionNullIndex);
          if (UNLIKELY(substitution != EntitySubstitutionNullIndex) &amp;&amp; entitySubstitutionList[substitution].mask &amp; entityMask) {
<span class="line-modified">!             result.appendCharacters(text + positionAfterLastEntity, i - positionAfterLastEntity);</span>
              result.appendCharacters(entitySubstitutionList[substitution].characters, entitySubstitutionList[substitution].length);
              positionAfterLastEntity = i + 1;
          }
      }
<span class="line-modified">!     result.appendCharacters(text + positionAfterLastEntity, length - positionAfterLastEntity);</span>
  }
  
  void MarkupAccumulator::appendCharactersReplacingEntities(StringBuilder&amp; result, const String&amp; source, unsigned offset, unsigned length, EntityMask entityMask)
  {
      if (!(offset + length))
<span class="line-new-header">--- 148,16 ---</span>
      size_t positionAfterLastEntity = 0;
      for (size_t i = 0; i &lt; length; ++i) {
          CharacterType character = text[i];
          uint8_t substitution = character &lt; WTF_ARRAY_LENGTH(entityMap) ? entityMap[character] : static_cast&lt;uint8_t&gt;(EntitySubstitutionNullIndex);
          if (UNLIKELY(substitution != EntitySubstitutionNullIndex) &amp;&amp; entitySubstitutionList[substitution].mask &amp; entityMask) {
<span class="line-modified">!             result.appendSubstring(source, offset + positionAfterLastEntity, i - positionAfterLastEntity);</span>
              result.appendCharacters(entitySubstitutionList[substitution].characters, entitySubstitutionList[substitution].length);
              positionAfterLastEntity = i + 1;
          }
      }
<span class="line-modified">!     result.appendSubstring(source, offset + positionAfterLastEntity, length - positionAfterLastEntity);</span>
  }
  
  void MarkupAccumulator::appendCharactersReplacingEntities(StringBuilder&amp; result, const String&amp; source, unsigned offset, unsigned length, EntityMask entityMask)
  {
      if (!(offset + length))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 349,15 ***</span>
  void MarkupAccumulator::appendNamespace(StringBuilder&amp; result, const AtomString&amp; prefix, const AtomString&amp; namespaceURI, Namespaces&amp; namespaces, bool allowEmptyDefaultNS)
  {
      namespaces.checkConsistency();
      if (namespaceURI.isEmpty()) {
          // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-xhtml-syntax.html#xml-fragment-serialization-algorithm
<span class="line-modified">!         if (allowEmptyDefaultNS &amp;&amp; namespaces.get(emptyAtom().impl())) {</span>
<span class="line-modified">!             result.append(&#39; &#39;);</span>
<span class="line-removed">-             result.append(xmlnsAtom().string());</span>
<span class="line-removed">-             result.appendLiteral(&quot;=\&quot;\&quot;&quot;);</span>
<span class="line-removed">-         }</span>
          return;
      }
  
      // Use emptyAtom()s&#39;s impl() for both null and empty strings since the HashMap can&#39;t handle 0 as a key
      AtomStringImpl* pre = prefix.isEmpty() ? emptyAtom().impl() : prefix.impl();
<span class="line-new-header">--- 349,12 ---</span>
  void MarkupAccumulator::appendNamespace(StringBuilder&amp; result, const AtomString&amp; prefix, const AtomString&amp; namespaceURI, Namespaces&amp; namespaces, bool allowEmptyDefaultNS)
  {
      namespaces.checkConsistency();
      if (namespaceURI.isEmpty()) {
          // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-xhtml-syntax.html#xml-fragment-serialization-algorithm
<span class="line-modified">!         if (allowEmptyDefaultNS &amp;&amp; namespaces.get(emptyAtom().impl()))</span>
<span class="line-modified">!             result.append(&#39; &#39;, xmlnsAtom(), &quot;=\&quot;\&quot;&quot;);</span>
          return;
      }
  
      // Use emptyAtom()s&#39;s impl() for both null and empty strings since the HashMap can&#39;t handle 0 as a key
      AtomStringImpl* pre = prefix.isEmpty() ? emptyAtom().impl() : prefix.impl();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 368,27 ***</span>
          if (inXMLFragmentSerialization() &amp;&amp; !prefix.isEmpty())
              namespaces.set(namespaceURI.impl(), pre);
          // Make sure xml prefix and namespace are always known to uphold the constraints listed at http://www.w3.org/TR/xml-names11/#xmlReserved.
          if (namespaceURI.impl() == XMLNames::xmlNamespaceURI-&gt;impl())
              return;
<span class="line-modified">!         result.append(&#39; &#39;);</span>
<span class="line-modified">!         result.append(xmlnsAtom().string());</span>
<span class="line-modified">!         if (!prefix.isEmpty()) {</span>
<span class="line-removed">-             result.append(&#39;:&#39;);</span>
<span class="line-removed">-             result.append(prefix);</span>
<span class="line-removed">-         }</span>
  
          result.append(&#39;=&#39;);
          result.append(&#39;&quot;&#39;);
          appendAttributeValue(result, namespaceURI, false);
          result.append(&#39;&quot;&#39;);
      }
  }
  
  EntityMask MarkupAccumulator::entityMaskForText(const Text&amp; text) const
  {
<span class="line-modified">!     if (!text.document().isHTMLDocument())</span>
          return EntityMaskInPCDATA;
  
      const QualifiedName* parentName = nullptr;
      if (text.parentElement())
          parentName = &amp;text.parentElement()-&gt;tagQName();
<span class="line-new-header">--- 365,24 ---</span>
          if (inXMLFragmentSerialization() &amp;&amp; !prefix.isEmpty())
              namespaces.set(namespaceURI.impl(), pre);
          // Make sure xml prefix and namespace are always known to uphold the constraints listed at http://www.w3.org/TR/xml-names11/#xmlReserved.
          if (namespaceURI.impl() == XMLNames::xmlNamespaceURI-&gt;impl())
              return;
<span class="line-modified">!         result.append(&#39; &#39;, xmlnsAtom());</span>
<span class="line-modified">!         if (!prefix.isEmpty())</span>
<span class="line-modified">!             result.append(&#39;:&#39;, prefix);</span>
  
          result.append(&#39;=&#39;);
          result.append(&#39;&quot;&#39;);
          appendAttributeValue(result, namespaceURI, false);
          result.append(&#39;&quot;&#39;);
      }
  }
  
  EntityMask MarkupAccumulator::entityMaskForText(const Text&amp; text) const
  {
<span class="line-modified">!     if (!text.document().isHTMLDocument() || inXMLFragmentSerialization())</span>
          return EntityMaskInPCDATA;
  
      const QualifiedName* parentName = nullptr;
      if (text.parentElement())
          parentName = &amp;text.parentElement()-&gt;tagQName();
</pre>
<center><a href="InsertListCommand.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderedPosition.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
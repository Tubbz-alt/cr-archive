<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/page/PageRuntimeAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PageNetworkAgent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="PageRuntimeAgent.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/page/PageRuntimeAgent.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 30,33 ***</span>
   */
  
  #include &quot;config.h&quot;
  #include &quot;PageRuntimeAgent.h&quot;
  
<span class="line-modified">! #include &quot;Chrome.h&quot;</span>
<span class="line-removed">- #include &quot;ChromeClient.h&quot;</span>
  #include &quot;Document.h&quot;
  #include &quot;Frame.h&quot;
  #include &quot;InspectorPageAgent.h&quot;
  #include &quot;InstrumentingAgents.h&quot;
  #include &quot;JSDOMWindowBase.h&quot;
  #include &quot;Page.h&quot;
  #include &quot;PageConsoleClient.h&quot;
  #include &quot;ScriptController.h&quot;
  #include &quot;ScriptState.h&quot;
  #include &quot;SecurityOrigin.h&quot;
<span class="line-modified">! #include &quot;UserGestureIndicator.h&quot;</span>
  #include &lt;JavaScriptCore/InjectedScript.h&gt;
  #include &lt;JavaScriptCore/InjectedScriptManager.h&gt;
<span class="line-modified">! </span>
<span class="line-removed">- using Inspector::Protocol::Runtime::ExecutionContextDescription;</span>
<span class="line-removed">- </span>
  
  namespace WebCore {
  
  using namespace Inspector;
  
  PageRuntimeAgent::PageRuntimeAgent(PageAgentContext&amp; context)
      : InspectorRuntimeAgent(context)
      , m_frontendDispatcher(makeUnique&lt;Inspector::RuntimeFrontendDispatcher&gt;(context.frontendRouter))
      , m_backendDispatcher(Inspector::RuntimeBackendDispatcher::create(context.backendDispatcher, this))
      , m_instrumentingAgents(context.instrumentingAgents)
<span class="line-new-header">--- 30,35 ---</span>
   */
  
  #include &quot;config.h&quot;
  #include &quot;PageRuntimeAgent.h&quot;
  
<span class="line-modified">! #include &quot;DOMWrapperWorld.h&quot;</span>
  #include &quot;Document.h&quot;
  #include &quot;Frame.h&quot;
  #include &quot;InspectorPageAgent.h&quot;
  #include &quot;InstrumentingAgents.h&quot;
  #include &quot;JSDOMWindowBase.h&quot;
  #include &quot;Page.h&quot;
  #include &quot;PageConsoleClient.h&quot;
  #include &quot;ScriptController.h&quot;
  #include &quot;ScriptState.h&quot;
  #include &quot;SecurityOrigin.h&quot;
<span class="line-modified">! #include &quot;UserGestureEmulationScope.h&quot;</span>
  #include &lt;JavaScriptCore/InjectedScript.h&gt;
  #include &lt;JavaScriptCore/InjectedScriptManager.h&gt;
<span class="line-modified">! #include &lt;JavaScriptCore/InspectorProtocolObjects.h&gt;</span>
  
  namespace WebCore {
  
  using namespace Inspector;
  
<span class="line-added">+ static bool asBool(const bool* b)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return b &amp;&amp; *b;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  PageRuntimeAgent::PageRuntimeAgent(PageAgentContext&amp; context)
      : InspectorRuntimeAgent(context)
      , m_frontendDispatcher(makeUnique&lt;Inspector::RuntimeFrontendDispatcher&gt;(context.frontendRouter))
      , m_backendDispatcher(Inspector::RuntimeBackendDispatcher::create(context.backendDispatcher, this))
      , m_instrumentingAgents(context.instrumentingAgents)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,42 ***</span>
  
  PageRuntimeAgent::~PageRuntimeAgent() = default;
  
  void PageRuntimeAgent::enable(ErrorString&amp; errorString)
  {
<span class="line-modified">!     bool enabled = m_instrumentingAgents.pageRuntimeAgent() == this;</span>
  
      InspectorRuntimeAgent::enable(errorString);
  
<span class="line-modified">!     m_instrumentingAgents.setPageRuntimeAgent(this);</span>
  
<span class="line-modified">!     if (!enabled)</span>
<span class="line-removed">-         reportExecutionContextCreation();</span>
  }
  
  void PageRuntimeAgent::disable(ErrorString&amp; errorString)
  {
      m_instrumentingAgents.setPageRuntimeAgent(nullptr);
  
      InspectorRuntimeAgent::disable(errorString);
  }
  
<span class="line-modified">! void PageRuntimeAgent::didCreateMainWorldContext(Frame&amp; frame)</span>
  {
      auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();
      if (!pageAgent)
          return;
  
<span class="line-modified">!     auto frameId = pageAgent-&gt;frameId(&amp;frame);</span>
<span class="line-removed">-     auto* scriptState = mainWorldExecState(&amp;frame);</span>
<span class="line-removed">-     notifyContextCreated(frameId, scriptState, nullptr, true);</span>
  }
  
  InjectedScript PageRuntimeAgent::injectedScriptForEval(ErrorString&amp; errorString, const int* executionContextId)
  {
      if (!executionContextId) {
<span class="line-modified">!         JSC::ExecState* scriptState = mainWorldExecState(&amp;m_inspectedPage.mainFrame());</span>
          InjectedScript result = injectedScriptManager().injectedScriptFor(scriptState);
          if (result.hasNoValue())
              errorString = &quot;Internal error: main world execution context not found&quot;_s;
          return result;
      }
<span class="line-new-header">--- 68,50 ---</span>
  
  PageRuntimeAgent::~PageRuntimeAgent() = default;
  
  void PageRuntimeAgent::enable(ErrorString&amp; errorString)
  {
<span class="line-modified">!     if (m_instrumentingAgents.pageRuntimeAgent() == this)</span>
<span class="line-added">+         return;</span>
  
      InspectorRuntimeAgent::enable(errorString);
<span class="line-added">+     if (!errorString.isEmpty())</span>
<span class="line-added">+         return;</span>
  
<span class="line-modified">!     // Report initial contexts before enabling instrumentation as the reporting</span>
<span class="line-added">+     // can force creation of script state which could result in duplicate notifications.</span>
<span class="line-added">+     reportExecutionContextCreation();</span>
  
<span class="line-modified">!     m_instrumentingAgents.setPageRuntimeAgent(this);</span>
  }
  
  void PageRuntimeAgent::disable(ErrorString&amp; errorString)
  {
      m_instrumentingAgents.setPageRuntimeAgent(nullptr);
  
      InspectorRuntimeAgent::disable(errorString);
  }
  
<span class="line-modified">! void PageRuntimeAgent::frameNavigated(Frame&amp; frame)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // Ensure execution context is created for the frame even if it doesn&#39;t have scripts.</span>
<span class="line-added">+     mainWorldExecState(&amp;frame);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void PageRuntimeAgent::didClearWindowObjectInWorld(Frame&amp; frame, DOMWrapperWorld&amp; world)</span>
  {
      auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();
      if (!pageAgent)
          return;
  
<span class="line-modified">!     notifyContextCreated(pageAgent-&gt;frameId(&amp;frame), frame.script().globalObject(world), world);</span>
  }
  
  InjectedScript PageRuntimeAgent::injectedScriptForEval(ErrorString&amp; errorString, const int* executionContextId)
  {
      if (!executionContextId) {
<span class="line-modified">!         JSC::JSGlobalObject* scriptState = mainWorldExecState(&amp;m_inspectedPage.mainFrame());</span>
          InjectedScript result = injectedScriptManager().injectedScriptFor(scriptState);
          if (result.hasNoValue())
              errorString = &quot;Internal error: main world execution context not found&quot;_s;
          return result;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 126,64 ***</span>
  {
      auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();
      if (!pageAgent)
          return;
  
<span class="line-modified">!     Vector&lt;std::pair&lt;JSC::ExecState*, SecurityOrigin*&gt;&gt; isolatedContexts;</span>
<span class="line-removed">-     for (Frame* frame = &amp;m_inspectedPage.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
          if (!frame-&gt;script().canExecuteScripts(NotAboutToExecuteScript))
              continue;
  
<span class="line-modified">!         String frameId = pageAgent-&gt;frameId(frame);</span>
  
<span class="line-modified">!         JSC::ExecState* scriptState = mainWorldExecState(frame);</span>
<span class="line-modified">!         notifyContextCreated(frameId, scriptState, nullptr, true);</span>
<span class="line-modified">!         frame-&gt;script().collectIsolatedContexts(isolatedContexts);</span>
<span class="line-modified">!         if (isolatedContexts.isEmpty())</span>
<span class="line-modified">!             continue;</span>
<span class="line-modified">!         for (auto&amp; context : isolatedContexts)</span>
<span class="line-modified">!             notifyContextCreated(frameId, context.first, context.second, false);</span>
<span class="line-modified">!         isolatedContexts.clear();</span>
      }
  }
  
<span class="line-modified">! void PageRuntimeAgent::notifyContextCreated(const String&amp; frameId, JSC::ExecState* scriptState, SecurityOrigin* securityOrigin, bool isPageContext)</span>
  {
<span class="line-modified">!     ASSERT(securityOrigin || isPageContext);</span>
  
<span class="line-modified">!     InjectedScript result = injectedScriptManager().injectedScriptFor(scriptState);</span>
<span class="line-modified">!     if (result.hasNoValue())</span>
          return;
  
<span class="line-modified">!     int executionContextId = injectedScriptManager().injectedScriptIdFor(scriptState);</span>
<span class="line-modified">!     String name = securityOrigin ? securityOrigin-&gt;toRawString() : String();</span>
<span class="line-modified">!     m_frontendDispatcher-&gt;executionContextCreated(ExecutionContextDescription::create()</span>
<span class="line-modified">!         .setId(executionContextId)</span>
<span class="line-modified">!         .setIsPageContext(isPageContext)</span>
          .setName(name)
          .setFrameId(frameId)
          .release());
  }
  
  void PageRuntimeAgent::evaluate(ErrorString&amp; errorString, const String&amp; expression, const String* objectGroup, const bool* includeCommandLineAPI, const bool* doNotPauseOnExceptionsAndMuteConsole, const int* executionContextId, const bool* returnByValue, const bool* generatePreview, const bool* saveResult, const bool* emulateUserGesture, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result, Optional&lt;bool&gt;&amp; wasThrown, Optional&lt;int&gt;&amp; savedResultIndex)
  {
<span class="line-modified">!     auto&amp; pageChromeClient = m_inspectedPage.chrome().client();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto shouldEmulateUserGesture = emulateUserGesture &amp;&amp; *emulateUserGesture;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Optional&lt;ProcessingUserGestureState&gt; userGestureState = shouldEmulateUserGesture ? Optional&lt;ProcessingUserGestureState&gt;(ProcessingUserGesture) : WTF::nullopt;</span>
<span class="line-removed">-     UserGestureIndicator gestureIndicator(userGestureState);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bool userWasInteracting = false;</span>
<span class="line-removed">-     if (shouldEmulateUserGesture) {</span>
<span class="line-removed">-         userWasInteracting = pageChromeClient.userIsInteracting();</span>
<span class="line-removed">-         if (!userWasInteracting)</span>
<span class="line-removed">-             pageChromeClient.setUserIsInteracting(true);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      InspectorRuntimeAgent::evaluate(errorString, expression, objectGroup, includeCommandLineAPI, doNotPauseOnExceptionsAndMuteConsole, executionContextId, returnByValue, generatePreview, saveResult, emulateUserGesture, result, wasThrown, savedResultIndex);
  
<span class="line-modified">!     if (shouldEmulateUserGesture &amp;&amp; !userWasInteracting &amp;&amp; pageChromeClient.userIsInteracting())</span>
<span class="line-modified">!         pageChromeClient.setUserIsInteracting(false);</span>
  }
  
  } // namespace WebCore
<span class="line-new-header">--- 136,72 ---</span>
  {
      auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();
      if (!pageAgent)
          return;
  
<span class="line-modified">!     for (auto* frame = &amp;m_inspectedPage.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
          if (!frame-&gt;script().canExecuteScripts(NotAboutToExecuteScript))
              continue;
  
<span class="line-modified">!         auto frameId = pageAgent-&gt;frameId(frame);</span>
  
<span class="line-modified">!         // Always send the main world first.</span>
<span class="line-modified">!         auto* mainGlobalObject = mainWorldExecState(frame);</span>
<span class="line-modified">!         notifyContextCreated(frameId, mainGlobalObject, mainThreadNormalWorld());</span>
<span class="line-modified">! </span>
<span class="line-modified">!         for (auto&amp; jsWindowProxy : frame-&gt;windowProxy().jsWindowProxiesAsVector()) {</span>
<span class="line-modified">!             auto* globalObject = jsWindowProxy-&gt;window();</span>
<span class="line-modified">!             if (globalObject == mainGlobalObject)</span>
<span class="line-modified">!                 continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+             auto&amp; securityOrigin = downcast&lt;DOMWindow&gt;(jsWindowProxy-&gt;wrapped()).document()-&gt;securityOrigin();</span>
<span class="line-added">+             notifyContextCreated(frameId, globalObject, jsWindowProxy-&gt;world(), &amp;securityOrigin);</span>
<span class="line-added">+         }</span>
      }
  }
  
<span class="line-modified">! static Inspector::Protocol::Runtime::ExecutionContextType toProtocol(DOMWrapperWorld::Type type)</span>
  {
<span class="line-modified">!     switch (type) {</span>
<span class="line-added">+     case DOMWrapperWorld::Type::Normal:</span>
<span class="line-added">+         return Inspector::Protocol::Runtime::ExecutionContextType::Normal;</span>
<span class="line-added">+     case DOMWrapperWorld::Type::User:</span>
<span class="line-added">+         return Inspector::Protocol::Runtime::ExecutionContextType::User;</span>
<span class="line-added">+     case DOMWrapperWorld::Type::Internal:</span>
<span class="line-added">+         return Inspector::Protocol::Runtime::ExecutionContextType::Internal;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT_NOT_REACHED();</span>
<span class="line-added">+     return Inspector::Protocol::Runtime::ExecutionContextType::Internal;</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void PageRuntimeAgent::notifyContextCreated(const String&amp; frameId, JSC::JSGlobalObject* globalObject, const DOMWrapperWorld&amp; world, SecurityOrigin* securityOrigin)</span>
<span class="line-modified">! {</span>
<span class="line-added">+     auto injectedScript = injectedScriptManager().injectedScriptFor(globalObject);</span>
<span class="line-added">+     if (injectedScript.hasNoValue())</span>
          return;
  
<span class="line-modified">!     auto name = world.name();</span>
<span class="line-modified">!     if (name.isEmpty() &amp;&amp; securityOrigin)</span>
<span class="line-modified">!         name = securityOrigin-&gt;toRawString();</span>
<span class="line-modified">! </span>
<span class="line-modified">!     m_frontendDispatcher-&gt;executionContextCreated(Inspector::Protocol::Runtime::ExecutionContextDescription::create()</span>
<span class="line-added">+         .setId(injectedScriptManager().injectedScriptIdFor(globalObject))</span>
<span class="line-added">+         .setType(toProtocol(world.type()))</span>
          .setName(name)
          .setFrameId(frameId)
          .release());
  }
  
  void PageRuntimeAgent::evaluate(ErrorString&amp; errorString, const String&amp; expression, const String* objectGroup, const bool* includeCommandLineAPI, const bool* doNotPauseOnExceptionsAndMuteConsole, const int* executionContextId, const bool* returnByValue, const bool* generatePreview, const bool* saveResult, const bool* emulateUserGesture, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result, Optional&lt;bool&gt;&amp; wasThrown, Optional&lt;int&gt;&amp; savedResultIndex)
  {
<span class="line-modified">!     UserGestureEmulationScope userGestureScope(m_inspectedPage, asBool(emulateUserGesture));</span>
      InspectorRuntimeAgent::evaluate(errorString, expression, objectGroup, includeCommandLineAPI, doNotPauseOnExceptionsAndMuteConsole, executionContextId, returnByValue, generatePreview, saveResult, emulateUserGesture, result, wasThrown, savedResultIndex);
<span class="line-added">+ }</span>
  
<span class="line-modified">! void PageRuntimeAgent::callFunctionOn(ErrorString&amp; errorString, const String&amp; objectId, const String&amp; expression, const JSON::Array* optionalArguments, const bool* doNotPauseOnExceptionsAndMuteConsole, const bool* returnByValue, const bool* generatePreview, const bool* emulateUserGesture, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result, Optional&lt;bool&gt;&amp; wasThrown)</span>
<span class="line-modified">! {</span>
<span class="line-added">+     UserGestureEmulationScope userGestureScope(m_inspectedPage, asBool(emulateUserGesture));</span>
<span class="line-added">+     InspectorRuntimeAgent::callFunctionOn(errorString, objectId, expression, optionalArguments, doNotPauseOnExceptionsAndMuteConsole, returnByValue, generatePreview, emulateUserGesture, result, wasThrown);</span>
  }
  
  } // namespace WebCore
</pre>
<center><a href="PageNetworkAgent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="PageRuntimeAgent.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
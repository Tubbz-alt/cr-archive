<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CachedTypes.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;CachedTypes.h&quot;
  28 
  29 #include &quot;BytecodeCacheError.h&quot;
<a name="1" id="anc1"></a>
  30 #include &quot;BytecodeLivenessAnalysis.h&quot;
  31 #include &quot;JSCInlines.h&quot;
  32 #include &quot;JSImmutableButterfly.h&quot;
  33 #include &quot;JSTemplateObjectDescriptor.h&quot;
  34 #include &quot;ScopedArgumentsTable.h&quot;
  35 #include &quot;SourceCodeKey.h&quot;
  36 #include &quot;SourceProvider.h&quot;
  37 #include &quot;UnlinkedEvalCodeBlock.h&quot;
  38 #include &quot;UnlinkedFunctionCodeBlock.h&quot;
  39 #include &quot;UnlinkedMetadataTableInlines.h&quot;
  40 #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
  41 #include &quot;UnlinkedProgramCodeBlock.h&quot;
  42 #include &lt;wtf/FastMalloc.h&gt;
<a name="2" id="anc2"></a><span class="line-added">  43 #include &lt;wtf/MallocPtr.h&gt;</span>
  44 #include &lt;wtf/Optional.h&gt;
<a name="3" id="anc3"></a><span class="line-added">  45 #include &lt;wtf/Packed.h&gt;</span>
  46 #include &lt;wtf/UUID.h&gt;
  47 #include &lt;wtf/text/AtomStringImpl.h&gt;
  48 
  49 namespace JSC {
  50 
  51 namespace Yarr {
  52 enum class Flags : uint8_t;
  53 }
  54 
  55 template &lt;typename T, typename = void&gt;
  56 struct SourceTypeImpl {
  57     using type = T;
  58 };
  59 
  60 template&lt;typename T&gt;
  61 struct SourceTypeImpl&lt;T, std::enable_if_t&lt;!std::is_fundamental&lt;T&gt;::value &amp;&amp; !std::is_same&lt;typename T::SourceType_, void&gt;::value&gt;&gt; {
  62     using type = typename T::SourceType_;
  63 
  64 };
  65 
  66 template&lt;typename T&gt;
  67 using SourceType = typename SourceTypeImpl&lt;T&gt;::type;
  68 
<a name="4" id="anc4"></a><span class="line-added">  69 static constexpr unsigned jscBytecodeCacheVersion()</span>
<span class="line-added">  70 {</span>
<span class="line-added">  71     return StringHasher::computeHash(__TIMESTAMP__);</span>
<span class="line-added">  72 }</span>
<span class="line-added">  73 </span>
  74 class Encoder {
  75     WTF_MAKE_NONCOPYABLE(Encoder);
  76     WTF_FORBID_HEAP_ALLOCATION;
  77 
  78 public:
  79     class Allocation {
  80         friend class Encoder;
  81 
  82     public:
  83         uint8_t* buffer() const { return m_buffer; }
  84         ptrdiff_t offset() const { return m_offset; }
  85 
  86     private:
  87         Allocation(uint8_t* buffer, ptrdiff_t offset)
  88             : m_buffer(buffer)
  89             , m_offset(offset)
  90         {
  91         }
  92 
  93         uint8_t* m_buffer;
  94         ptrdiff_t m_offset;
  95     };
  96 
  97     Encoder(VM&amp; vm, FileSystem::PlatformFileHandle fd = FileSystem::invalidPlatformFileHandle)
  98         : m_vm(vm)
  99         , m_fd(fd)
 100         , m_baseOffset(0)
 101         , m_currentPage(nullptr)
 102     {
 103         allocateNewPage();
 104     }
 105 
 106     VM&amp; vm() { return m_vm; }
 107 
 108     Allocation malloc(unsigned size)
 109     {
 110         RELEASE_ASSERT(size);
 111         ptrdiff_t offset;
 112         if (m_currentPage-&gt;malloc(size, offset))
 113             return Allocation { m_currentPage-&gt;buffer() + offset, m_baseOffset + offset };
 114         allocateNewPage(size);
 115         return malloc(size);
 116     }
 117 
 118     template&lt;typename T, typename... Args&gt;
 119     T* malloc(Args&amp;&amp;... args)
 120     {
 121         return new (malloc(sizeof(T)).buffer()) T(std::forward&lt;Args&gt;(args)...);
 122     }
 123 
 124     ptrdiff_t offsetOf(const void* address)
 125     {
 126         ptrdiff_t offset;
 127         ptrdiff_t baseOffset = 0;
 128         for (const auto&amp; page : m_pages) {
 129             if (page.getOffset(address, offset))
 130                 return baseOffset + offset;
 131             baseOffset += page.size();
 132         }
 133         RELEASE_ASSERT_NOT_REACHED();
 134         return 0;
 135     }
 136 
 137     void cachePtr(const void* ptr, ptrdiff_t offset)
 138     {
 139         m_ptrToOffsetMap.add(ptr, offset);
 140     }
 141 
 142     Optional&lt;ptrdiff_t&gt; cachedOffsetForPtr(const void* ptr)
 143     {
 144         auto it = m_ptrToOffsetMap.find(ptr);
 145         if (it == m_ptrToOffsetMap.end())
 146             return WTF::nullopt;
 147         return { it-&gt;value };
 148     }
 149 
 150     void addLeafExecutable(const UnlinkedFunctionExecutable* executable, ptrdiff_t offset)
 151     {
 152         m_leafExecutables.add(executable, offset);
 153     }
 154 
 155     RefPtr&lt;CachedBytecode&gt; release(BytecodeCacheError&amp; error)
 156     {
 157         if (!m_currentPage)
 158             return nullptr;
 159         m_currentPage-&gt;alignEnd();
 160 
 161         if (FileSystem::isHandleValid(m_fd)) {
 162             return releaseMapped(error);
 163         }
 164 
 165         size_t size = m_baseOffset + m_currentPage-&gt;size();
<a name="5" id="anc5"></a><span class="line-modified"> 166         MallocPtr&lt;uint8_t, VMMalloc&gt; buffer = MallocPtr&lt;uint8_t, VMMalloc&gt;::malloc(size);</span>
 167         unsigned offset = 0;
 168         for (const auto&amp; page : m_pages) {
 169             memcpy(buffer.get() + offset, page.buffer(), page.size());
 170             offset += page.size();
 171         }
 172         RELEASE_ASSERT(offset == size);
 173         return CachedBytecode::create(WTFMove(buffer), size, WTFMove(m_leafExecutables));
 174     }
 175 
 176 private:
 177     RefPtr&lt;CachedBytecode&gt; releaseMapped(BytecodeCacheError&amp; error)
 178     {
 179         size_t size = m_baseOffset + m_currentPage-&gt;size();
 180         if (!FileSystem::truncateFile(m_fd, size)) {
 181             error = BytecodeCacheError::StandardError(errno);
 182             return nullptr;
 183         }
 184 
 185         for (const auto&amp; page : m_pages) {
 186             int bytesWritten = FileSystem::writeToFile(m_fd, reinterpret_cast&lt;char*&gt;(page.buffer()), page.size());
 187             if (bytesWritten == -1) {
 188                 error = BytecodeCacheError::StandardError(errno);
 189                 return nullptr;
 190             }
 191 
 192             if (static_cast&lt;size_t&gt;(bytesWritten) != page.size()) {
 193                 error = BytecodeCacheError::WriteError(bytesWritten, page.size());
 194                 return nullptr;
 195             }
 196         }
 197 
 198         bool success;
 199         FileSystem::MappedFileData mappedFileData(m_fd, FileSystem::MappedFileMode::Private, success);
 200         if (!success) {
 201             error = BytecodeCacheError::StandardError(errno);
 202             return nullptr;
 203         }
 204 
 205         return CachedBytecode::create(WTFMove(mappedFileData), WTFMove(m_leafExecutables));
 206     }
 207 
 208     class Page {
 209     public:
 210         Page(size_t size)
<a name="6" id="anc6"></a><span class="line-modified"> 211             : m_buffer(MallocPtr&lt;uint8_t, VMMalloc&gt;::malloc(size))</span>
 212             , m_capacity(size)
 213         {
<a name="7" id="anc7"></a>
 214         }
 215 
 216         bool malloc(size_t size, ptrdiff_t&amp; result)
 217         {
 218             size_t alignment = std::min(alignof(std::max_align_t), static_cast&lt;size_t&gt;(WTF::roundUpToPowerOfTwo(size)));
 219             ptrdiff_t offset = roundUpToMultipleOf(alignment, m_offset);
 220             size = roundUpToMultipleOf(alignment, size);
 221             if (static_cast&lt;size_t&gt;(offset + size) &gt; m_capacity)
 222                 return false;
 223 
 224             result = offset;
 225             m_offset = offset + size;
 226             return true;
 227         }
 228 
 229         uint8_t* buffer() const { return m_buffer.get(); }
 230         size_t size() const { return static_cast&lt;size_t&gt;(m_offset); }
 231 
 232         bool getOffset(const void* address, ptrdiff_t&amp; result) const
 233         {
 234             const uint8_t* addr = static_cast&lt;const uint8_t*&gt;(address);
 235             if (addr &gt;= m_buffer.get() &amp;&amp; addr &lt; m_buffer.get() + m_offset) {
 236                 result = addr - m_buffer.get();
 237                 return true;
 238             }
 239             return false;
 240         }
 241 
 242         void alignEnd()
 243         {
 244             ptrdiff_t size = roundUpToMultipleOf(alignof(std::max_align_t), m_offset);
 245             if (size == m_offset)
 246                 return;
 247             RELEASE_ASSERT(static_cast&lt;size_t&gt;(size) &lt;= m_capacity);
 248             m_offset = size;
 249         }
 250 
 251     private:
<a name="8" id="anc8"></a><span class="line-modified"> 252         MallocPtr&lt;uint8_t, VMMalloc&gt; m_buffer;</span>
<span class="line-modified"> 253         ptrdiff_t m_offset { 0 };</span>
 254         size_t m_capacity;
 255     };
 256 
 257     void allocateNewPage(size_t size = 0)
 258     {
 259         static size_t minPageSize = pageSize();
 260         if (m_currentPage) {
 261             m_currentPage-&gt;alignEnd();
 262             m_baseOffset += m_currentPage-&gt;size();
 263         }
 264         if (size &lt; minPageSize)
 265             size = minPageSize;
 266         else
 267             size = roundUpToMultipleOf(minPageSize, size);
 268         m_pages.append(Page { size });
 269         m_currentPage = &amp;m_pages.last();
 270     }
 271 
 272     VM&amp; m_vm;
 273     FileSystem::PlatformFileHandle m_fd;
 274     ptrdiff_t m_baseOffset;
 275     Page* m_currentPage;
 276     Vector&lt;Page&gt; m_pages;
 277     HashMap&lt;const void*, ptrdiff_t&gt; m_ptrToOffsetMap;
 278     LeafExecutableMap m_leafExecutables;
 279 };
 280 
 281 Decoder::Decoder(VM&amp; vm, Ref&lt;CachedBytecode&gt; cachedBytecode, RefPtr&lt;SourceProvider&gt; provider)
 282     : m_vm(vm)
 283     , m_cachedBytecode(WTFMove(cachedBytecode))
 284     , m_provider(provider)
 285 {
 286 }
 287 
 288 Decoder::~Decoder()
 289 {
 290     for (auto&amp; finalizer : m_finalizers)
 291         finalizer();
 292 }
 293 
 294 Ref&lt;Decoder&gt; Decoder::create(VM&amp; vm, Ref&lt;CachedBytecode&gt; cachedBytecode, RefPtr&lt;SourceProvider&gt; provider)
 295 {
 296     return adoptRef(*new Decoder(vm, WTFMove(cachedBytecode), WTFMove(provider)));
 297 }
 298 
 299 size_t Decoder::size() const
 300 {
 301     return m_cachedBytecode-&gt;size();
 302 }
 303 
 304 ptrdiff_t Decoder::offsetOf(const void* ptr)
 305 {
 306     const uint8_t* addr = static_cast&lt;const uint8_t*&gt;(ptr);
 307     ASSERT(addr &gt;= m_cachedBytecode-&gt;data() &amp;&amp; addr &lt; m_cachedBytecode-&gt;data() + m_cachedBytecode-&gt;size());
 308     return addr - m_cachedBytecode-&gt;data();
 309 }
 310 
 311 void Decoder::cacheOffset(ptrdiff_t offset, void* ptr)
 312 {
 313     m_offsetToPtrMap.add(offset, ptr);
 314 }
 315 
 316 WTF::Optional&lt;void*&gt; Decoder::cachedPtrForOffset(ptrdiff_t offset)
 317 {
 318     auto it = m_offsetToPtrMap.find(offset);
 319     if (it == m_offsetToPtrMap.end())
 320         return WTF::nullopt;
 321     return { it-&gt;value };
 322 }
 323 
 324 const void* Decoder::ptrForOffsetFromBase(ptrdiff_t offset)
 325 {
 326     ASSERT(offset &gt; 0 &amp;&amp; static_cast&lt;size_t&gt;(offset) &lt; m_cachedBytecode-&gt;size());
 327     return m_cachedBytecode-&gt;data() + offset;
 328 }
 329 
 330 CompactVariableMap::Handle Decoder::handleForEnvironment(CompactVariableEnvironment* environment) const
 331 {
 332     auto it = m_environmentToHandleMap.find(environment);
 333     RELEASE_ASSERT(it != m_environmentToHandleMap.end());
 334     return it-&gt;value;
 335 }
 336 
 337 void Decoder::setHandleForEnvironment(CompactVariableEnvironment* environment, const CompactVariableMap::Handle&amp; handle)
 338 {
 339     auto addResult = m_environmentToHandleMap.add(environment, handle);
 340     RELEASE_ASSERT(addResult.isNewEntry);
 341 }
 342 
 343 void Decoder::addLeafExecutable(const UnlinkedFunctionExecutable* executable, ptrdiff_t offset)
 344 {
 345     m_cachedBytecode-&gt;leafExecutables().add(executable, offset);
 346 }
 347 
 348 template&lt;typename Functor&gt;
 349 void Decoder::addFinalizer(const Functor&amp; fn)
 350 {
 351     m_finalizers.append(fn);
 352 }
 353 
 354 RefPtr&lt;SourceProvider&gt; Decoder::provider() const
 355 {
 356     return m_provider;
 357 }
 358 
 359 template&lt;typename T&gt;
 360 static std::enable_if_t&lt;std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value&gt; encode(Encoder&amp;, T&amp; dst, const SourceType&lt;T&gt;&amp; src)
 361 {
 362     dst = src;
 363 }
 364 
 365 template&lt;typename T&gt;
 366 static std::enable_if_t&lt;!std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value&gt; encode(Encoder&amp; encoder, T&amp; dst, const SourceType&lt;T&gt;&amp; src)
 367 {
 368     dst.encode(encoder, src);
 369 }
 370 
 371 template&lt;typename T, typename... Args&gt;
 372 static std::enable_if_t&lt;std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value&gt; decode(Decoder&amp;, const T&amp; src, SourceType&lt;T&gt;&amp; dst, Args...)
 373 {
 374     dst = src;
 375 }
 376 
 377 template&lt;typename T, typename... Args&gt;
 378 static std::enable_if_t&lt;!std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value&gt; decode(Decoder&amp; decoder, const T&amp; src, SourceType&lt;T&gt;&amp; dst, Args... args)
 379 {
 380     src.decode(decoder, dst, args...);
 381 }
 382 
 383 template&lt;typename T&gt;
 384 static std::enable_if_t&lt;std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value, T&gt; decode(Decoder&amp;, T src)
 385 {
 386     return src;
 387 }
 388 
 389 template&lt;typename T&gt;
 390 static std::enable_if_t&lt;!std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value, SourceType&lt;T&gt;&gt;&amp;&amp; decode(Decoder&amp; decoder, const T&amp; src)
 391 {
 392     return src.decode(decoder);
 393 }
 394 
 395 template&lt;typename Source&gt;
 396 class CachedObject {
 397     WTF_MAKE_NONCOPYABLE(CachedObject&lt;Source&gt;);
 398 
 399 public:
 400     using SourceType_ = Source;
 401 
 402     CachedObject() = default;
 403 
 404     inline void* operator new(size_t, void* where) { return where; }
 405     void* operator new[](size_t, void* where) { return where; }
 406 
 407     // Copied from WTF_FORBID_HEAP_ALLOCATION, since we only want to allow placement new
 408     void* operator new(size_t) = delete;
 409     void operator delete(void*) = delete;
 410     void* operator new[](size_t size) = delete;
 411     void operator delete[](void*) = delete;
 412     void* operator new(size_t, NotNullTag, void* location) = delete;
 413 };
 414 
 415 template&lt;typename Source&gt;
 416 class VariableLengthObject : public CachedObject&lt;Source&gt;, VariableLengthObjectBase {
 417     template&lt;typename, typename&gt;
 418     friend class CachedPtr;
 419     friend struct CachedPtrOffsets;
 420 
 421 public:
 422     VariableLengthObject()
 423         : VariableLengthObjectBase(s_invalidOffset)
 424     {
 425     }
 426 
 427     bool isEmpty() const
 428     {
 429         return m_offset == s_invalidOffset;
 430     }
 431 
 432 protected:
 433     const uint8_t* buffer() const
 434     {
 435         ASSERT(!isEmpty());
 436         return bitwise_cast&lt;const uint8_t*&gt;(this) + m_offset;
 437     }
 438 
 439     template&lt;typename T&gt;
 440     const T* buffer() const
 441     {
 442         ASSERT(!(bitwise_cast&lt;uintptr_t&gt;(buffer()) % alignof(T)));
 443         return bitwise_cast&lt;const T*&gt;(buffer());
 444     }
 445 
 446     uint8_t* allocate(Encoder&amp; encoder, size_t size)
 447     {
 448         ptrdiff_t offsetOffset = encoder.offsetOf(&amp;m_offset);
 449         auto result = encoder.malloc(size);
 450         m_offset = result.offset() - offsetOffset;
 451         return result.buffer();
 452     }
 453 
 454     template&lt;typename T&gt;
 455 #if CPU(ARM64) &amp;&amp; CPU(ADDRESS32)
 456     // FIXME: Remove this once it&#39;s no longer needed and LLVM doesn&#39;t miscompile us:
 457     // &lt;rdar://problem/49792205&gt;
 458     __attribute__((optnone))
 459 #endif
 460     T* allocate(Encoder&amp; encoder, unsigned size = 1)
 461     {
 462         uint8_t* result = allocate(encoder, sizeof(T) * size);
 463         ASSERT(!(bitwise_cast&lt;uintptr_t&gt;(result) % alignof(T)));
 464         return new (result) T[size];
 465     }
 466 
 467 private:
 468     constexpr static ptrdiff_t s_invalidOffset = std::numeric_limits&lt;ptrdiff_t&gt;::max();
 469 };
 470 
 471 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
 472 class CachedPtr : public VariableLengthObject&lt;Source*&gt; {
<a name="9" id="anc9"></a><span class="line-modified"> 473     template&lt;typename, typename, typename&gt;</span>
 474     friend class CachedRefPtr;
 475 
 476     friend struct CachedPtrOffsets;
 477 
 478 public:
 479     void encode(Encoder&amp; encoder, const Source* src)
 480     {
 481         if (!src)
 482             return;
 483 
 484         if (Optional&lt;ptrdiff_t&gt; offset = encoder.cachedOffsetForPtr(src)) {
 485             this-&gt;m_offset = *offset - encoder.offsetOf(&amp;this-&gt;m_offset);
 486             return;
 487         }
 488 
 489         T* cachedObject = this-&gt;template allocate&lt;T&gt;(encoder);
 490         cachedObject-&gt;encode(encoder, *src);
 491         encoder.cachePtr(src, encoder.offsetOf(cachedObject));
 492     }
 493 
 494     template&lt;typename... Args&gt;
 495     Source* decode(Decoder&amp; decoder, bool&amp; isNewAllocation, Args&amp;&amp;... args) const
 496     {
 497         if (this-&gt;isEmpty()) {
 498             isNewAllocation = false;
 499             return nullptr;
 500         }
 501 
 502         ptrdiff_t bufferOffset = decoder.offsetOf(this-&gt;buffer());
 503         if (Optional&lt;void*&gt; ptr = decoder.cachedPtrForOffset(bufferOffset)) {
 504             isNewAllocation = false;
 505             return static_cast&lt;Source*&gt;(*ptr);
 506         }
 507 
 508         isNewAllocation = true;
 509         Source* ptr = get()-&gt;decode(decoder, std::forward&lt;Args&gt;(args)...);
 510         decoder.cacheOffset(bufferOffset, ptr);
 511         return ptr;
 512     }
 513 
 514     template&lt;typename... Args&gt;
 515     Source* decode(Decoder&amp; decoder, Args&amp;&amp;... args) const
 516     {
 517         bool unusedIsNewAllocation;
 518         return decode(decoder, unusedIsNewAllocation, std::forward&lt;Args&gt;(args)...);
 519     }
 520 
 521     const T* operator-&gt;() const { return get(); }
 522 
 523 private:
 524     const T* get() const
 525     {
 526         RELEASE_ASSERT(!this-&gt;isEmpty());
 527         return this-&gt;template buffer&lt;T&gt;();
 528     }
 529 };
 530 
 531 ptrdiff_t CachedPtrOffsets::offsetOffset()
 532 {
 533     return OBJECT_OFFSETOF(CachedPtr&lt;void&gt;, m_offset);
 534 }
 535 
<a name="10" id="anc10"></a><span class="line-modified"> 536 template&lt;typename T, typename Source = SourceType&lt;T&gt;, typename PtrTraits = DumbPtrTraits&lt;Source&gt;&gt;</span>
<span class="line-modified"> 537 class CachedRefPtr : public CachedObject&lt;RefPtr&lt;Source, PtrTraits&gt;&gt; {</span>
 538 public:
 539     void encode(Encoder&amp; encoder, const Source* src)
 540     {
 541         m_ptr.encode(encoder, src);
 542     }
 543 
<a name="11" id="anc11"></a><span class="line-modified"> 544     void encode(Encoder&amp; encoder, const RefPtr&lt;Source, PtrTraits&gt; src)</span>
 545     {
 546         encode(encoder, src.get());
 547     }
 548 
<a name="12" id="anc12"></a><span class="line-modified"> 549     RefPtr&lt;Source, PtrTraits&gt; decode(Decoder&amp; decoder) const</span>
 550     {
 551         bool isNewAllocation;
 552         Source* decodedPtr = m_ptr.decode(decoder, isNewAllocation);
 553         if (!decodedPtr)
 554             return nullptr;
 555         if (isNewAllocation) {
 556             decoder.addFinalizer([=] {
 557                 derefIfNotNull(decodedPtr);
 558             });
 559         }
 560         refIfNotNull(decodedPtr);
 561         return adoptRef(decodedPtr);
 562     }
 563 
<a name="13" id="anc13"></a><span class="line-modified"> 564     void decode(Decoder&amp; decoder, RefPtr&lt;Source, PtrTraits&gt;&amp; src) const</span>
 565     {
 566         src = decode(decoder);
 567     }
 568 
 569 private:
 570     CachedPtr&lt;T, Source&gt; m_ptr;
 571 };
 572 
 573 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
 574 class CachedWriteBarrier : public CachedObject&lt;WriteBarrier&lt;Source&gt;&gt; {
 575     friend struct CachedWriteBarrierOffsets;
 576 
 577 public:
 578     bool isEmpty() const { return m_ptr.isEmpty(); }
 579 
 580     void encode(Encoder&amp; encoder, const WriteBarrier&lt;Source&gt; src)
 581     {
 582         m_ptr.encode(encoder, src.get());
 583     }
 584 
 585     void decode(Decoder&amp; decoder, WriteBarrier&lt;Source&gt;&amp; src, const JSCell* owner) const
 586     {
 587         Source* decodedPtr = m_ptr.decode(decoder);
 588         if (decodedPtr)
 589             src.set(decoder.vm(), owner, decodedPtr);
 590     }
 591 
 592 private:
 593     CachedPtr&lt;T, Source&gt; m_ptr;
 594 };
 595 
 596 ptrdiff_t CachedWriteBarrierOffsets::ptrOffset()
 597 {
 598     return OBJECT_OFFSETOF(CachedWriteBarrier&lt;void&gt;, m_ptr);
 599 }
 600 
<a name="14" id="anc14"></a><span class="line-modified"> 601 template&lt;typename T, size_t InlineCapacity = 0, typename OverflowHandler = CrashOnOverflow, typename Malloc = WTF::VectorMalloc&gt;</span>
<span class="line-modified"> 602 class CachedVector : public VariableLengthObject&lt;Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler, 16, Malloc&gt;&gt; {</span>
 603 public:
<a name="15" id="anc15"></a><span class="line-modified"> 604     void encode(Encoder&amp; encoder, const Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler, 16, Malloc&gt;&amp; vector)</span>
<span class="line-added"> 605     {</span>
<span class="line-added"> 606         m_size = vector.size();</span>
<span class="line-added"> 607         if (!m_size)</span>
<span class="line-added"> 608             return;</span>
<span class="line-added"> 609         T* buffer = this-&gt;template allocate&lt;T&gt;(encoder, m_size);</span>
<span class="line-added"> 610         for (unsigned i = 0; i &lt; m_size; ++i)</span>
<span class="line-added"> 611             ::JSC::encode(encoder, buffer[i], vector[i]);</span>
<span class="line-added"> 612     }</span>
<span class="line-added"> 613 </span>
<span class="line-added"> 614     void encode(Encoder&amp; encoder, const RefCountedArray&lt;SourceType&lt;T&gt;&gt;&amp; vector)</span>
 615     {
 616         m_size = vector.size();
 617         if (!m_size)
 618             return;
 619         T* buffer = this-&gt;template allocate&lt;T&gt;(encoder, m_size);
 620         for (unsigned i = 0; i &lt; m_size; ++i)
 621             ::JSC::encode(encoder, buffer[i], vector[i]);
 622     }
 623 
 624     template&lt;typename... Args&gt;
<a name="16" id="anc16"></a><span class="line-modified"> 625     void decode(Decoder&amp; decoder, Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler, 16, Malloc&gt;&amp; vector, Args... args) const</span>
 626     {
 627         if (!m_size)
 628             return;
 629         vector.resizeToFit(m_size);
 630         const T* buffer = this-&gt;template buffer&lt;T&gt;();
 631         for (unsigned i = 0; i &lt; m_size; ++i)
 632             ::JSC::decode(decoder, buffer[i], vector[i], args...);
 633     }
 634 
<a name="17" id="anc17"></a><span class="line-added"> 635     template&lt;typename... Args&gt;</span>
<span class="line-added"> 636     void decode(Decoder&amp; decoder, RefCountedArray&lt;SourceType&lt;T&gt;&gt;&amp; vector, Args... args) const</span>
<span class="line-added"> 637     {</span>
<span class="line-added"> 638         if (!m_size)</span>
<span class="line-added"> 639             return;</span>
<span class="line-added"> 640         vector = RefCountedArray&lt;SourceType&lt;T&gt;&gt;(m_size);</span>
<span class="line-added"> 641         const T* buffer = this-&gt;template buffer&lt;T&gt;();</span>
<span class="line-added"> 642         for (unsigned i = 0; i &lt; m_size; ++i)</span>
<span class="line-added"> 643             ::JSC::decode(decoder, buffer[i], vector[i], args...);</span>
<span class="line-added"> 644     }</span>
<span class="line-added"> 645 </span>
<span class="line-added"> 646 </span>
 647 private:
 648     unsigned m_size;
 649 };
 650 
 651 template&lt;typename First, typename Second&gt;
 652 class CachedPair : public CachedObject&lt;std::pair&lt;SourceType&lt;First&gt;, SourceType&lt;Second&gt;&gt;&gt; {
 653 public:
 654     void encode(Encoder&amp; encoder, const std::pair&lt;SourceType&lt;First&gt;, SourceType&lt;Second&gt;&gt;&amp; pair)
 655     {
 656         ::JSC::encode(encoder, m_first, pair.first);
 657         ::JSC::encode(encoder, m_second, pair.second);
 658     }
 659 
 660     void decode(Decoder&amp; decoder, std::pair&lt;SourceType&lt;First&gt;, SourceType&lt;Second&gt;&gt;&amp; pair) const
 661     {
 662         ::JSC::decode(decoder, m_first, pair.first);
 663         ::JSC::decode(decoder, m_second, pair.second);
 664     }
 665 
 666 private:
 667     First m_first;
 668     Second m_second;
 669 };
 670 
 671 template&lt;typename Key, typename Value, typename HashArg = typename DefaultHash&lt;SourceType&lt;Key&gt;&gt;::Hash, typename KeyTraitsArg = HashTraits&lt;SourceType&lt;Key&gt;&gt;, typename MappedTraitsArg = HashTraits&lt;SourceType&lt;Value&gt;&gt;&gt;
 672 class CachedHashMap : public VariableLengthObject&lt;HashMap&lt;SourceType&lt;Key&gt;, SourceType&lt;Value&gt;, HashArg, KeyTraitsArg, MappedTraitsArg&gt;&gt; {
 673     template&lt;typename K, typename V&gt;
 674     using Map = HashMap&lt;K, V, HashArg, KeyTraitsArg, MappedTraitsArg&gt;;
 675 
 676 public:
 677     void encode(Encoder&amp; encoder, const Map&lt;SourceType&lt;Key&gt;, SourceType&lt;Value&gt;&gt;&amp; map)
 678     {
 679         SourceType&lt;decltype(m_entries)&gt; entriesVector(map.size());
 680         unsigned i = 0;
 681         for (const auto&amp; it : map)
 682             entriesVector[i++] = { it.key, it.value };
 683         m_entries.encode(encoder, entriesVector);
 684     }
 685 
 686     void decode(Decoder&amp; decoder, Map&lt;SourceType&lt;Key&gt;, SourceType&lt;Value&gt;&gt;&amp; map) const
 687     {
 688         SourceType&lt;decltype(m_entries)&gt; decodedEntries;
 689         m_entries.decode(decoder, decodedEntries);
 690         for (const auto&amp; pair : decodedEntries)
 691             map.set(pair.first, pair.second);
 692     }
 693 
 694 private:
 695     CachedVector&lt;CachedPair&lt;Key, Value&gt;&gt; m_entries;
 696 };
 697 
 698 template&lt;typename T&gt;
 699 class CachedUniquedStringImplBase : public VariableLengthObject&lt;T&gt; {
 700 public:
 701     void encode(Encoder&amp; encoder, const StringImpl&amp; string)
 702     {
 703         m_isAtomic = string.isAtom();
 704         m_isSymbol = string.isSymbol();
 705         RefPtr&lt;StringImpl&gt; impl = const_cast&lt;StringImpl*&gt;(&amp;string);
 706 
 707         if (m_isSymbol) {
 708             SymbolImpl* symbol = static_cast&lt;SymbolImpl*&gt;(impl.get());
 709             if (!symbol-&gt;isNullSymbol()) {
 710                 // We have special handling for well-known symbols.
 711                 if (!symbol-&gt;isPrivate())
 712                     impl = encoder.vm().propertyNames-&gt;getPublicName(encoder.vm(), symbol).impl();
 713             }
 714         }
 715 
 716         m_is8Bit = impl-&gt;is8Bit();
 717         m_length = impl-&gt;length();
 718 
 719         if (!m_length)
 720             return;
 721 
 722         unsigned size = m_length;
 723         const void* payload;
 724         if (m_is8Bit)
 725             payload = impl-&gt;characters8();
 726         else {
 727             payload = impl-&gt;characters16();
 728             size *= 2;
 729         }
 730 
 731         uint8_t* buffer = this-&gt;allocate(encoder, size);
 732         memcpy(buffer, payload, size);
 733     }
 734 
 735     UniquedStringImpl* decode(Decoder&amp; decoder) const
 736     {
 737         auto create = [&amp;](const auto* buffer) -&gt; UniquedStringImpl* {
 738             if (!m_isSymbol)
 739                 return AtomStringImpl::add(buffer, m_length).leakRef();
 740 
 741             Identifier ident = Identifier::fromString(decoder.vm(), buffer, m_length);
 742             String str = decoder.vm().propertyNames-&gt;lookUpPrivateName(ident);
 743             StringImpl* impl = str.releaseImpl().get();
 744             ASSERT(impl-&gt;isSymbol());
 745             return static_cast&lt;UniquedStringImpl*&gt;(impl);
 746         };
 747 
 748         if (!m_length) {
 749             if (m_isSymbol)
 750                 return &amp;SymbolImpl::createNullSymbol().leakRef();
 751             return AtomStringImpl::add(&quot;&quot;).leakRef();
 752         }
 753 
 754         if (m_is8Bit)
 755             return create(this-&gt;template buffer&lt;LChar&gt;());
 756         return create(this-&gt;template buffer&lt;UChar&gt;());
 757     }
 758 
 759 private:
 760     bool m_is8Bit : 1;
 761     bool m_isSymbol : 1;
 762     bool m_isAtomic : 1;
 763     unsigned m_length;
 764 };
 765 
 766 class CachedUniquedStringImpl : public CachedUniquedStringImplBase&lt;UniquedStringImpl&gt; { };
 767 class CachedStringImpl : public CachedUniquedStringImplBase&lt;StringImpl&gt; { };
 768 
 769 class CachedString : public VariableLengthObject&lt;String&gt; {
 770 public:
 771     void encode(Encoder&amp; encoder, const String&amp; string)
 772     {
 773         m_impl.encode(encoder, static_cast&lt;UniquedStringImpl*&gt;(string.impl()));
 774     }
 775 
 776     String decode(Decoder&amp; decoder) const
 777     {
 778         return String(static_cast&lt;RefPtr&lt;StringImpl&gt;&gt;(m_impl.decode(decoder)));
 779     }
 780 
 781     void decode(Decoder&amp; decoder, String&amp; dst) const
 782     {
 783         dst = decode(decoder);
 784     }
 785 
 786 private:
 787     CachedRefPtr&lt;CachedUniquedStringImpl&gt; m_impl;
 788 };
 789 
 790 class CachedIdentifier : public VariableLengthObject&lt;Identifier&gt; {
 791 public:
 792     void encode(Encoder&amp; encoder, const Identifier&amp; identifier)
 793     {
 794         m_string.encode(encoder, identifier.string());
 795     }
 796 
 797     Identifier decode(Decoder&amp; decoder) const
 798     {
 799         String str = m_string.decode(decoder);
 800         if (str.isNull())
 801             return Identifier();
 802 
 803         return Identifier::fromUid(decoder.vm(), (UniquedStringImpl*)str.impl());
 804     }
 805 
 806     void decode(Decoder&amp; decoder, Identifier&amp; ident) const
 807     {
 808         ident = decode(decoder);
 809     }
 810 
 811 private:
 812     CachedString m_string;
 813 };
 814 
 815 template&lt;typename T&gt;
 816 class CachedOptional : public VariableLengthObject&lt;Optional&lt;SourceType&lt;T&gt;&gt;&gt; {
 817 public:
 818     void encode(Encoder&amp; encoder, const Optional&lt;SourceType&lt;T&gt;&gt;&amp; source)
 819     {
 820         if (!source)
 821             return;
 822 
 823         this-&gt;template allocate&lt;T&gt;(encoder)-&gt;encode(encoder, *source);
 824     }
 825 
 826     Optional&lt;SourceType&lt;T&gt;&gt; decode(Decoder&amp; decoder) const
 827     {
 828         if (this-&gt;isEmpty())
 829             return WTF::nullopt;
 830 
 831         return { this-&gt;template buffer&lt;T&gt;()-&gt;decode(decoder) };
 832     }
 833 
 834     void decode(Decoder&amp; decoder, Optional&lt;SourceType&lt;T&gt;&gt;&amp; dst) const
 835     {
 836         dst = decode(decoder);
 837     }
 838 
 839     void encode(Encoder&amp; encoder, const std::unique_ptr&lt;SourceType&lt;T&gt;&gt;&amp; source)
 840     {
 841         if (!source)
 842             encode(encoder, WTF::nullopt);
 843         else
 844             encode(encoder, { *source });
 845     }
 846 };
 847 
 848 class CachedSimpleJumpTable : public CachedObject&lt;UnlinkedSimpleJumpTable&gt; {
 849 public:
 850     void encode(Encoder&amp; encoder, const UnlinkedSimpleJumpTable&amp; jumpTable)
 851     {
 852         m_min = jumpTable.min;
 853         m_branchOffsets.encode(encoder, jumpTable.branchOffsets);
 854     }
 855 
 856     void decode(Decoder&amp; decoder, UnlinkedSimpleJumpTable&amp; jumpTable) const
 857     {
 858         jumpTable.min = m_min;
 859         m_branchOffsets.decode(decoder, jumpTable.branchOffsets);
 860     }
 861 
 862 private:
 863     int32_t m_min;
 864     CachedVector&lt;int32_t&gt; m_branchOffsets;
 865 };
 866 
 867 class CachedStringJumpTable : public CachedObject&lt;UnlinkedStringJumpTable&gt; {
 868 public:
 869     void encode(Encoder&amp; encoder, const UnlinkedStringJumpTable&amp; jumpTable)
 870     {
 871         m_offsetTable.encode(encoder, jumpTable.offsetTable);
 872     }
 873 
 874     void decode(Decoder&amp; decoder, UnlinkedStringJumpTable&amp; jumpTable) const
 875     {
 876         m_offsetTable.decode(decoder, jumpTable.offsetTable);
 877     }
 878 
 879 private:
 880     CachedHashMap&lt;CachedRefPtr&lt;CachedStringImpl&gt;, UnlinkedStringJumpTable:: OffsetLocation&gt; m_offsetTable;
 881 };
 882 
 883 class CachedBitVector : public VariableLengthObject&lt;BitVector&gt; {
 884 public:
 885     void encode(Encoder&amp; encoder, const BitVector&amp; bitVector)
 886     {
 887         m_numBits = bitVector.size();
 888         if (!m_numBits)
 889             return;
 890         size_t sizeInBytes = BitVector::byteCount(m_numBits);
 891         uint8_t* buffer = this-&gt;allocate(encoder, sizeInBytes);
 892         memcpy(buffer, bitVector.bits(), sizeInBytes);
 893     }
 894 
 895     void decode(Decoder&amp;, BitVector&amp; bitVector) const
 896     {
 897         if (!m_numBits)
 898             return;
 899         bitVector.ensureSize(m_numBits);
 900         size_t sizeInBytes = BitVector::byteCount(m_numBits);
 901         memcpy(bitVector.bits(), this-&gt;buffer(), sizeInBytes);
 902     }
 903 
 904 private:
 905     size_t m_numBits;
 906 };
 907 
 908 template&lt;typename T, typename HashArg = typename DefaultHash&lt;T&gt;::Hash&gt;
 909 class CachedHashSet : public CachedObject&lt;HashSet&lt;SourceType&lt;T&gt;, HashArg&gt;&gt; {
 910 public:
 911     void encode(Encoder&amp; encoder, const HashSet&lt;SourceType&lt;T&gt;, HashArg&gt;&amp; set)
 912     {
 913         SourceType&lt;decltype(m_entries)&gt; entriesVector(set.size());
 914         unsigned i = 0;
 915         for (const auto&amp; item : set)
 916             entriesVector[i++] = item;
 917         m_entries.encode(encoder, entriesVector);
 918     }
 919 
 920     void decode(Decoder&amp; decoder, HashSet&lt;SourceType&lt;T&gt;, HashArg&gt;&amp; set) const
 921     {
 922         SourceType&lt;decltype(m_entries)&gt; entriesVector;
 923         m_entries.decode(decoder, entriesVector);
 924         for (const auto&amp; item : entriesVector)
 925             set.add(item);
 926     }
 927 
 928 private:
 929     CachedVector&lt;T&gt; m_entries;
 930 };
 931 
 932 class CachedConstantIdentifierSetEntry : public VariableLengthObject&lt;ConstantIdentifierSetEntry&gt; {
 933 public:
 934     void encode(Encoder&amp; encoder, const ConstantIdentifierSetEntry&amp; entry)
 935     {
 936         m_constant = entry.second;
 937         m_set.encode(encoder, entry.first);
 938     }
 939 
 940     void decode(Decoder&amp; decoder, ConstantIdentifierSetEntry&amp; entry) const
 941     {
 942         entry.second = m_constant;
 943         m_set.decode(decoder, entry.first);
 944     }
 945 
 946 private:
 947     unsigned m_constant;
 948     CachedHashSet&lt;CachedRefPtr&lt;CachedUniquedStringImpl&gt;, IdentifierRepHash&gt; m_set;
 949 };
 950 
 951 class CachedCodeBlockRareData : public CachedObject&lt;UnlinkedCodeBlock::RareData&gt; {
 952 public:
 953     void encode(Encoder&amp; encoder, const UnlinkedCodeBlock::RareData&amp; rareData)
 954     {
 955         m_exceptionHandlers.encode(encoder, rareData.m_exceptionHandlers);
 956         m_switchJumpTables.encode(encoder, rareData.m_switchJumpTables);
 957         m_stringSwitchJumpTables.encode(encoder, rareData.m_stringSwitchJumpTables);
 958         m_expressionInfoFatPositions.encode(encoder, rareData.m_expressionInfoFatPositions);
 959         m_typeProfilerInfoMap.encode(encoder, rareData.m_typeProfilerInfoMap);
 960         m_opProfileControlFlowBytecodeOffsets.encode(encoder, rareData.m_opProfileControlFlowBytecodeOffsets);
 961         m_bitVectors.encode(encoder, rareData.m_bitVectors);
 962         m_constantIdentifierSets.encode(encoder, rareData.m_constantIdentifierSets);
<a name="18" id="anc18"></a><span class="line-added"> 963         m_needsClassFieldInitializer = rareData.m_needsClassFieldInitializer;</span>
 964     }
 965 
 966     UnlinkedCodeBlock::RareData* decode(Decoder&amp; decoder) const
 967     {
 968         UnlinkedCodeBlock::RareData* rareData = new UnlinkedCodeBlock::RareData { };
 969         m_exceptionHandlers.decode(decoder, rareData-&gt;m_exceptionHandlers);
 970         m_switchJumpTables.decode(decoder, rareData-&gt;m_switchJumpTables);
 971         m_stringSwitchJumpTables.decode(decoder, rareData-&gt;m_stringSwitchJumpTables);
 972         m_expressionInfoFatPositions.decode(decoder, rareData-&gt;m_expressionInfoFatPositions);
 973         m_typeProfilerInfoMap.decode(decoder, rareData-&gt;m_typeProfilerInfoMap);
 974         m_opProfileControlFlowBytecodeOffsets.decode(decoder, rareData-&gt;m_opProfileControlFlowBytecodeOffsets);
 975         m_bitVectors.decode(decoder, rareData-&gt;m_bitVectors);
 976         m_constantIdentifierSets.decode(decoder, rareData-&gt;m_constantIdentifierSets);
<a name="19" id="anc19"></a><span class="line-added"> 977         rareData-&gt;m_needsClassFieldInitializer = m_needsClassFieldInitializer;</span>
 978         return rareData;
 979     }
 980 
 981 private:
 982     CachedVector&lt;UnlinkedHandlerInfo&gt; m_exceptionHandlers;
 983     CachedVector&lt;CachedSimpleJumpTable&gt; m_switchJumpTables;
 984     CachedVector&lt;CachedStringJumpTable&gt; m_stringSwitchJumpTables;
 985     CachedVector&lt;ExpressionRangeInfo::FatPosition&gt; m_expressionInfoFatPositions;
 986     CachedHashMap&lt;unsigned, UnlinkedCodeBlock::RareData::TypeProfilerExpressionRange&gt; m_typeProfilerInfoMap;
 987     CachedVector&lt;InstructionStream::Offset&gt; m_opProfileControlFlowBytecodeOffsets;
 988     CachedVector&lt;CachedBitVector&gt; m_bitVectors;
 989     CachedVector&lt;CachedConstantIdentifierSetEntry&gt; m_constantIdentifierSets;
<a name="20" id="anc20"></a><span class="line-added"> 990     unsigned m_needsClassFieldInitializer : 1;</span>
 991 };
 992 
 993 class CachedVariableEnvironment : public CachedObject&lt;VariableEnvironment&gt; {
 994 public:
 995     void encode(Encoder&amp; encoder, const VariableEnvironment&amp; env)
 996     {
 997         m_isEverythingCaptured = env.m_isEverythingCaptured;
 998         m_map.encode(encoder, env.m_map);
 999     }
1000 
1001     void decode(Decoder&amp; decoder, VariableEnvironment&amp; env) const
1002     {
1003         env.m_isEverythingCaptured = m_isEverythingCaptured;
1004         m_map.decode(decoder, env.m_map);
1005     }
1006 
1007 private:
1008     bool m_isEverythingCaptured;
<a name="21" id="anc21"></a><span class="line-modified">1009     CachedHashMap&lt;CachedRefPtr&lt;CachedUniquedStringImpl, UniquedStringImpl, WTF::PackedPtrTraits&lt;UniquedStringImpl&gt;&gt;, VariableEnvironmentEntry, IdentifierRepHash, HashTraits&lt;RefPtr&lt;UniquedStringImpl&gt;&gt;, VariableEnvironmentEntryHashTraits&gt; m_map;</span>
1010 };
1011 
1012 class CachedCompactVariableEnvironment : public CachedObject&lt;CompactVariableEnvironment&gt; {
1013 public:
1014     void encode(Encoder&amp; encoder, const CompactVariableEnvironment&amp; env)
1015     {
1016         m_variables.encode(encoder, env.m_variables);
1017         m_variableMetadata.encode(encoder, env.m_variableMetadata);
1018         m_hash = env.m_hash;
1019         m_isEverythingCaptured = env.m_isEverythingCaptured;
1020     }
1021 
1022     void decode(Decoder&amp; decoder, CompactVariableEnvironment&amp; env) const
1023     {
1024         m_variables.decode(decoder, env.m_variables);
1025         m_variableMetadata.decode(decoder, env.m_variableMetadata);
1026         env.m_hash = m_hash;
1027         env.m_isEverythingCaptured = m_isEverythingCaptured;
1028     }
1029 
1030     CompactVariableEnvironment* decode(Decoder&amp; decoder) const
1031     {
1032         CompactVariableEnvironment* env = new CompactVariableEnvironment;
1033         decode(decoder, *env);
1034         return env;
1035     }
1036 
1037 private:
<a name="22" id="anc22"></a><span class="line-modified">1038     CachedVector&lt;CachedRefPtr&lt;CachedUniquedStringImpl, UniquedStringImpl, WTF::PackedPtrTraits&lt;UniquedStringImpl&gt;&gt;&gt; m_variables;</span>
1039     CachedVector&lt;VariableEnvironmentEntry&gt; m_variableMetadata;
1040     unsigned m_hash;
1041     bool m_isEverythingCaptured;
1042 };
1043 
1044 class CachedCompactVariableMapHandle : public CachedObject&lt;CompactVariableMap::Handle&gt; {
1045 public:
1046     void encode(Encoder&amp; encoder, const CompactVariableMap::Handle&amp; handle)
1047     {
1048         m_environment.encode(encoder, handle.m_environment);
1049     }
1050 
1051     CompactVariableMap::Handle decode(Decoder&amp; decoder) const
1052     {
1053         bool isNewAllocation;
1054         CompactVariableEnvironment* environment = m_environment.decode(decoder, isNewAllocation);
1055         if (!environment) {
1056             ASSERT(!isNewAllocation);
1057             return CompactVariableMap::Handle();
1058         }
1059 
1060         if (!isNewAllocation)
1061             return decoder.handleForEnvironment(environment);
1062         bool isNewEntry;
1063         CompactVariableMap::Handle handle = decoder.vm().m_compactVariableMap-&gt;get(environment, isNewEntry);
1064         if (!isNewEntry) {
1065             decoder.addFinalizer([=] {
1066                 delete environment;
1067             });
1068         }
1069         decoder.setHandleForEnvironment(environment, handle);
1070         return handle;
1071     }
1072 
1073 private:
1074     CachedPtr&lt;CachedCompactVariableEnvironment&gt; m_environment;
1075 };
1076 
1077 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
1078 class CachedArray : public VariableLengthObject&lt;Source*&gt; {
1079 public:
1080     void encode(Encoder&amp; encoder, const Source* array, unsigned size)
1081     {
1082         if (!size)
1083             return;
1084         T* dst = this-&gt;template allocate&lt;T&gt;(encoder, size);
1085         for (unsigned i = 0; i &lt; size; ++i)
1086             ::JSC::encode(encoder, dst[i], array[i]);
1087     }
1088 
1089     template&lt;typename... Args&gt;
1090     void decode(Decoder&amp; decoder, Source* array, unsigned size, Args... args) const
1091     {
1092         if (!size)
1093             return;
1094         const T* buffer = this-&gt;template buffer&lt;T&gt;();
1095         for (unsigned i = 0; i &lt; size; ++i)
1096             ::JSC::decode(decoder, buffer[i], array[i], args...);
1097     }
1098 };
1099 
1100 class CachedScopedArgumentsTable : public CachedObject&lt;ScopedArgumentsTable&gt; {
1101 public:
1102     void encode(Encoder&amp; encoder, const ScopedArgumentsTable&amp; scopedArgumentsTable)
1103     {
1104         m_length = scopedArgumentsTable.m_length;
1105         m_arguments.encode(encoder, scopedArgumentsTable.m_arguments.get(m_length), m_length);
1106     }
1107 
1108     ScopedArgumentsTable* decode(Decoder&amp; decoder) const
1109     {
1110         ScopedArgumentsTable* scopedArgumentsTable = ScopedArgumentsTable::create(decoder.vm(), m_length);
1111         m_arguments.decode(decoder, scopedArgumentsTable-&gt;m_arguments.get(m_length), m_length);
1112         return scopedArgumentsTable;
1113     }
1114 
1115 private:
1116     uint32_t m_length;
1117     CachedArray&lt;ScopeOffset&gt; m_arguments;
1118 };
1119 
1120 class CachedSymbolTableEntry : public CachedObject&lt;SymbolTableEntry&gt; {
1121 public:
1122     void encode(Encoder&amp;, const SymbolTableEntry&amp; symbolTableEntry)
1123     {
1124         m_bits = symbolTableEntry.m_bits | SymbolTableEntry::SlimFlag;
1125     }
1126 
1127     void decode(Decoder&amp;, SymbolTableEntry&amp; symbolTableEntry) const
1128     {
1129         symbolTableEntry.m_bits = m_bits;
1130     }
1131 
1132 private:
1133     intptr_t m_bits;
1134 };
1135 
1136 class CachedSymbolTable : public CachedObject&lt;SymbolTable&gt; {
1137 public:
1138     void encode(Encoder&amp; encoder, const SymbolTable&amp; symbolTable)
1139     {
1140         m_map.encode(encoder, symbolTable.m_map);
1141         m_maxScopeOffset = symbolTable.m_maxScopeOffset;
1142         m_usesNonStrictEval = symbolTable.m_usesNonStrictEval;
1143         m_nestedLexicalScope = symbolTable.m_nestedLexicalScope;
1144         m_scopeType = symbolTable.m_scopeType;
1145         m_arguments.encode(encoder, symbolTable.m_arguments.get());
1146     }
1147 
1148     SymbolTable* decode(Decoder&amp; decoder) const
1149     {
1150         SymbolTable* symbolTable = SymbolTable::create(decoder.vm());
1151         m_map.decode(decoder, symbolTable-&gt;m_map);
1152         symbolTable-&gt;m_maxScopeOffset = m_maxScopeOffset;
1153         symbolTable-&gt;m_usesNonStrictEval = m_usesNonStrictEval;
1154         symbolTable-&gt;m_nestedLexicalScope = m_nestedLexicalScope;
1155         symbolTable-&gt;m_scopeType = m_scopeType;
1156         ScopedArgumentsTable* scopedArgumentsTable = m_arguments.decode(decoder);
1157         if (scopedArgumentsTable)
1158             symbolTable-&gt;m_arguments.set(decoder.vm(), symbolTable, scopedArgumentsTable);
1159         return symbolTable;
1160     }
1161 
1162 private:
1163     CachedHashMap&lt;CachedRefPtr&lt;CachedUniquedStringImpl&gt;, CachedSymbolTableEntry, IdentifierRepHash, HashTraits&lt;RefPtr&lt;UniquedStringImpl&gt;&gt;, SymbolTableIndexHashTraits&gt; m_map;
1164     ScopeOffset m_maxScopeOffset;
1165     unsigned m_usesNonStrictEval : 1;
1166     unsigned m_nestedLexicalScope : 1;
1167     unsigned m_scopeType : 3;
1168     CachedPtr&lt;CachedScopedArgumentsTable&gt; m_arguments;
1169 };
1170 
1171 class CachedJSValue;
1172 class CachedImmutableButterfly : public CachedObject&lt;JSImmutableButterfly&gt; {
1173 public:
1174     CachedImmutableButterfly()
1175         : m_cachedDoubles()
1176     {
1177     }
1178 
1179     void encode(Encoder&amp; encoder, JSImmutableButterfly&amp; immutableButterfly)
1180     {
1181         m_length = immutableButterfly.length();
1182         m_indexingType = immutableButterfly.indexingTypeAndMisc();
1183         if (hasDouble(m_indexingType))
1184             m_cachedDoubles.encode(encoder, immutableButterfly.toButterfly()-&gt;contiguousDouble().data(), m_length);
1185         else
1186             m_cachedValues.encode(encoder, immutableButterfly.toButterfly()-&gt;contiguous().data(), m_length);
1187     }
1188 
1189     JSImmutableButterfly* decode(Decoder&amp; decoder) const
1190     {
1191         JSImmutableButterfly* immutableButterfly = JSImmutableButterfly::create(decoder.vm(), m_indexingType, m_length);
1192         if (hasDouble(m_indexingType))
1193             m_cachedDoubles.decode(decoder, immutableButterfly-&gt;toButterfly()-&gt;contiguousDouble().data(), m_length, immutableButterfly);
1194         else
1195             m_cachedValues.decode(decoder, immutableButterfly-&gt;toButterfly()-&gt;contiguous().data(), m_length, immutableButterfly);
1196         return immutableButterfly;
1197     }
1198 
1199 private:
1200     IndexingType m_indexingType;
1201     unsigned m_length;
1202     union {
1203         CachedArray&lt;double&gt; m_cachedDoubles;
1204         CachedArray&lt;CachedJSValue, WriteBarrier&lt;Unknown&gt;&gt; m_cachedValues;
1205     };
1206 };
1207 
1208 class CachedRegExp : public CachedObject&lt;RegExp&gt; {
1209 public:
1210     void encode(Encoder&amp; encoder, const RegExp&amp; regExp)
1211     {
1212         m_patternString.encode(encoder, regExp.m_patternString);
1213         m_flags = regExp.m_flags;
1214     }
1215 
1216     RegExp* decode(Decoder&amp; decoder) const
1217     {
1218         String pattern { m_patternString.decode(decoder) };
1219         return RegExp::create(decoder.vm(), pattern, m_flags);
1220     }
1221 
1222 private:
1223     CachedString m_patternString;
1224     OptionSet&lt;Yarr::Flags&gt; m_flags;
1225 };
1226 
1227 class CachedTemplateObjectDescriptor : public CachedObject&lt;TemplateObjectDescriptor&gt; {
1228 public:
1229     void encode(Encoder&amp; encoder, const JSTemplateObjectDescriptor&amp; descriptor)
1230     {
1231         m_rawStrings.encode(encoder, descriptor.descriptor().rawStrings());
1232         m_cookedStrings.encode(encoder, descriptor.descriptor().cookedStrings());
1233         m_endOffset = descriptor.endOffset();
1234     }
1235 
1236     JSTemplateObjectDescriptor* decode(Decoder&amp; decoder) const
1237     {
1238         TemplateObjectDescriptor::StringVector decodedRawStrings;
1239         TemplateObjectDescriptor::OptionalStringVector decodedCookedStrings;
1240         m_rawStrings.decode(decoder, decodedRawStrings);
1241         m_cookedStrings.decode(decoder, decodedCookedStrings);
1242         return JSTemplateObjectDescriptor::create(decoder.vm(), TemplateObjectDescriptor::create(WTFMove(decodedRawStrings), WTFMove(decodedCookedStrings)), m_endOffset);
1243     }
1244 
1245 private:
1246     CachedVector&lt;CachedString, 4&gt; m_rawStrings;
1247     CachedVector&lt;CachedOptional&lt;CachedString&gt;, 4&gt; m_cookedStrings;
1248     int m_endOffset;
1249 };
1250 
1251 class CachedBigInt : public VariableLengthObject&lt;JSBigInt&gt; {
1252 public:
1253     void encode(Encoder&amp; encoder, JSBigInt&amp; bigInt)
1254     {
1255         m_length = bigInt.length();
1256         m_sign = bigInt.sign();
1257 
1258         if (!m_length)
1259             return;
1260 
1261         unsigned size = sizeof(JSBigInt::Digit) * m_length;
1262         uint8_t* buffer = this-&gt;allocate(encoder, size);
1263         memcpy(buffer, bigInt.dataStorage(), size);
1264     }
1265 
1266     JSBigInt* decode(Decoder&amp; decoder) const
1267     {
1268         JSBigInt* bigInt = JSBigInt::createWithLengthUnchecked(decoder.vm(), m_length);
1269         bigInt-&gt;setSign(m_sign);
1270         if (m_length)
1271             memcpy(bigInt-&gt;dataStorage(), this-&gt;buffer(), sizeof(JSBigInt::Digit) * m_length);
1272         return bigInt;
1273     }
1274 
1275 private:
1276     unsigned m_length;
1277     bool m_sign;
1278 };
1279 
1280 class CachedJSValue : public VariableLengthObject&lt;WriteBarrier&lt;Unknown&gt;&gt; {
1281 public:
1282     void encode(Encoder&amp; encoder, const WriteBarrier&lt;Unknown&gt; value)
1283     {
1284         JSValue v = value.get();
1285 
1286         if (!v.isCell() || v.isEmpty()) {
1287             m_type = EncodedType::JSValue;
1288             *this-&gt;allocate&lt;EncodedJSValue&gt;(encoder) = JSValue::encode(v);
1289             return;
1290         }
1291 
1292         JSCell* cell = v.asCell();
1293         VM&amp; vm = encoder.vm();
1294 
1295         if (auto* symbolTable = jsDynamicCast&lt;SymbolTable*&gt;(vm, cell)) {
1296             m_type = EncodedType::SymbolTable;
1297             this-&gt;allocate&lt;CachedSymbolTable&gt;(encoder)-&gt;encode(encoder, *symbolTable);
1298             return;
1299         }
1300 
1301         if (auto* string = jsDynamicCast&lt;JSString*&gt;(vm, cell)) {
1302             m_type = EncodedType::String;
1303             StringImpl* impl = string-&gt;tryGetValue().impl();
1304             this-&gt;allocate&lt;CachedUniquedStringImpl&gt;(encoder)-&gt;encode(encoder, *impl);
1305             return;
1306         }
1307 
1308         if (auto* immutableButterfly = jsDynamicCast&lt;JSImmutableButterfly*&gt;(vm, cell)) {
1309             m_type = EncodedType::ImmutableButterfly;
1310             this-&gt;allocate&lt;CachedImmutableButterfly&gt;(encoder)-&gt;encode(encoder, *immutableButterfly);
1311             return;
1312         }
1313 
1314         if (auto* regexp = jsDynamicCast&lt;RegExp*&gt;(vm, cell)) {
1315             m_type = EncodedType::RegExp;
1316             this-&gt;allocate&lt;CachedRegExp&gt;(encoder)-&gt;encode(encoder, *regexp);
1317             return;
1318         }
1319 
1320         if (auto* templateObjectDescriptor = jsDynamicCast&lt;JSTemplateObjectDescriptor*&gt;(vm, cell)) {
1321             m_type = EncodedType::TemplateObjectDescriptor;
1322             this-&gt;allocate&lt;CachedTemplateObjectDescriptor&gt;(encoder)-&gt;encode(encoder, *templateObjectDescriptor);
1323             return;
1324         }
1325 
1326         if (auto* bigInt = jsDynamicCast&lt;JSBigInt*&gt;(vm, cell)) {
1327             m_type = EncodedType::BigInt;
1328             this-&gt;allocate&lt;CachedBigInt&gt;(encoder)-&gt;encode(encoder, *bigInt);
1329             return;
1330         }
1331 
1332         RELEASE_ASSERT_NOT_REACHED();
1333     }
1334 
1335     void decode(Decoder&amp; decoder, WriteBarrier&lt;Unknown&gt;&amp; value, const JSCell* owner) const
1336     {
1337         JSValue v;
1338         switch (m_type) {
1339         case EncodedType::JSValue:
1340             v = JSValue::decode(*this-&gt;buffer&lt;EncodedJSValue&gt;());
1341             break;
1342         case EncodedType::SymbolTable:
1343             v = this-&gt;buffer&lt;CachedSymbolTable&gt;()-&gt;decode(decoder);
1344             break;
1345         case EncodedType::String: {
1346             StringImpl* impl = this-&gt;buffer&lt;CachedUniquedStringImpl&gt;()-&gt;decode(decoder);
1347             v = jsString(decoder.vm(), adoptRef(*impl));
1348             break;
1349         }
1350         case EncodedType::ImmutableButterfly:
1351             v = this-&gt;buffer&lt;CachedImmutableButterfly&gt;()-&gt;decode(decoder);
1352             break;
1353         case EncodedType::RegExp:
1354             v = this-&gt;buffer&lt;CachedRegExp&gt;()-&gt;decode(decoder);
1355             break;
1356         case EncodedType::TemplateObjectDescriptor:
1357             v = this-&gt;buffer&lt;CachedTemplateObjectDescriptor&gt;()-&gt;decode(decoder);
1358             break;
1359         case EncodedType::BigInt:
1360             v = this-&gt;buffer&lt;CachedBigInt&gt;()-&gt;decode(decoder);
1361             break;
1362         default:
1363             RELEASE_ASSERT_NOT_REACHED();
1364         }
1365         value.set(decoder.vm(), owner, v);
1366     }
1367 
1368 private:
1369     enum class EncodedType : uint8_t {
1370         JSValue,
1371         SymbolTable,
1372         String,
1373         ImmutableButterfly,
1374         RegExp,
1375         TemplateObjectDescriptor,
1376         BigInt,
1377     };
1378 
1379     EncodedType m_type;
1380 };
1381 
1382 class CachedInstructionStream : public CachedObject&lt;InstructionStream&gt; {
1383 public:
1384     void encode(Encoder&amp; encoder, const InstructionStream&amp; stream)
1385     {
1386         m_instructions.encode(encoder, stream.m_instructions);
1387     }
1388 
1389     InstructionStream* decode(Decoder&amp; decoder) const
1390     {
<a name="23" id="anc23"></a><span class="line-modified">1391         Vector&lt;uint8_t, 0, UnsafeVectorOverflow, 16, InstructionStreamMalloc&gt; instructionsVector;</span>
1392         m_instructions.decode(decoder, instructionsVector);
1393         return new InstructionStream(WTFMove(instructionsVector));
1394     }
1395 
1396 private:
<a name="24" id="anc24"></a><span class="line-modified">1397     CachedVector&lt;uint8_t, 0, UnsafeVectorOverflow, InstructionStreamMalloc&gt; m_instructions;</span>
1398 };
1399 
1400 class CachedMetadataTable : public CachedObject&lt;UnlinkedMetadataTable&gt; {
1401 public:
1402     void encode(Encoder&amp;, const UnlinkedMetadataTable&amp; metadataTable)
1403     {
1404         ASSERT(metadataTable.m_isFinalized);
1405         m_hasMetadata = metadataTable.m_hasMetadata;
1406         if (!m_hasMetadata)
1407             return;
1408         m_is32Bit = metadataTable.m_is32Bit;
1409         if (m_is32Bit) {
1410             for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)
1411                 m_metadata[i] = metadataTable.offsetTable32()[i];
1412         } else {
1413             for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)
1414                 m_metadata[i] = metadataTable.offsetTable16()[i];
1415         }
1416     }
1417 
1418     Ref&lt;UnlinkedMetadataTable&gt; decode(Decoder&amp;) const
1419     {
1420         if (!m_hasMetadata)
1421             return UnlinkedMetadataTable::empty();
1422 
1423         Ref&lt;UnlinkedMetadataTable&gt; metadataTable = UnlinkedMetadataTable::create(m_is32Bit);
1424         metadataTable-&gt;m_isFinalized = true;
1425         metadataTable-&gt;m_isLinked = false;
1426         metadataTable-&gt;m_hasMetadata = m_hasMetadata;
1427         if (m_is32Bit) {
1428             for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)
1429                 metadataTable-&gt;offsetTable32()[i] = m_metadata[i];
1430         } else {
1431             for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)
1432                 metadataTable-&gt;offsetTable16()[i] = m_metadata[i];
1433         }
1434         return metadataTable;
1435     }
1436 
1437 private:
1438     bool m_hasMetadata;
1439     bool m_is32Bit;
1440     std::array&lt;unsigned, UnlinkedMetadataTable::s_offsetTableEntries&gt; m_metadata;
1441 };
1442 
1443 class CachedSourceOrigin : public CachedObject&lt;SourceOrigin&gt; {
1444 public:
1445     void encode(Encoder&amp; encoder, const SourceOrigin&amp; sourceOrigin)
1446     {
1447         m_string.encode(encoder, sourceOrigin.string());
1448     }
1449 
1450     SourceOrigin decode(Decoder&amp; decoder) const
1451     {
1452         return SourceOrigin { m_string.decode(decoder) };
1453     }
1454 
1455 private:
1456     CachedString m_string;
1457 };
1458 
1459 class CachedTextPosition : public CachedObject&lt;TextPosition&gt; {
1460 public:
1461     void encode(Encoder&amp;, TextPosition textPosition)
1462     {
1463         m_line = textPosition.m_line.zeroBasedInt();
1464         m_column = textPosition.m_column.zeroBasedInt();
1465     }
1466 
1467     TextPosition decode(Decoder&amp;) const
1468     {
1469         return TextPosition { OrdinalNumber::fromZeroBasedInt(m_line), OrdinalNumber::fromZeroBasedInt(m_column) };
1470     }
1471 
1472 private:
1473     int m_line;
1474     int m_column;
1475 };
1476 
1477 template &lt;typename Source, typename CachedType&gt;
1478 class CachedSourceProviderShape : public CachedObject&lt;Source&gt; {
1479 public:
1480     void encode(Encoder&amp; encoder, const SourceProvider&amp; sourceProvider)
1481     {
1482         m_sourceOrigin.encode(encoder, sourceProvider.sourceOrigin());
1483         m_url.encode(encoder, sourceProvider.url());
1484         m_sourceURLDirective.encode(encoder, sourceProvider.sourceURLDirective());
1485         m_sourceMappingURLDirective.encode(encoder, sourceProvider.sourceMappingURLDirective());
1486         m_startPosition.encode(encoder, sourceProvider.startPosition());
1487     }
1488 
1489     void decode(Decoder&amp; decoder, SourceProvider&amp; sourceProvider) const
1490     {
1491         sourceProvider.setSourceURLDirective(m_sourceURLDirective.decode(decoder));
1492         sourceProvider.setSourceMappingURLDirective(m_sourceMappingURLDirective.decode(decoder));
1493     }
1494 
1495 protected:
1496     CachedSourceOrigin m_sourceOrigin;
1497     CachedString m_url;
1498     CachedString m_sourceURLDirective;
1499     CachedString m_sourceMappingURLDirective;
1500     CachedTextPosition m_startPosition;
1501 };
1502 
1503 class CachedStringSourceProvider : public CachedSourceProviderShape&lt;StringSourceProvider, CachedStringSourceProvider&gt; {
1504     using Base = CachedSourceProviderShape&lt;StringSourceProvider, CachedStringSourceProvider&gt;;
1505 
1506 public:
1507     void encode(Encoder&amp; encoder, const StringSourceProvider&amp; sourceProvider)
1508     {
1509         Base::encode(encoder, sourceProvider);
1510         m_source.encode(encoder, sourceProvider.source().toString());
1511     }
1512 
1513     StringSourceProvider* decode(Decoder&amp; decoder, SourceProviderSourceType sourceType) const
1514     {
1515         String decodedSource = m_source.decode(decoder);
1516         SourceOrigin decodedSourceOrigin = m_sourceOrigin.decode(decoder);
1517         String decodedURL = m_url.decode(decoder);
1518         TextPosition decodedStartPosition = m_startPosition.decode(decoder);
1519 
1520         Ref&lt;StringSourceProvider&gt; sourceProvider = StringSourceProvider::create(decodedSource, decodedSourceOrigin, URL(URL(), decodedURL), decodedStartPosition, sourceType);
1521         Base::decode(decoder, sourceProvider.get());
1522         return &amp;sourceProvider.leakRef();
1523     }
1524 
1525 private:
1526     CachedString m_source;
1527 };
1528 
1529 #if ENABLE(WEBASSEMBLY)
1530 class CachedWebAssemblySourceProvider : public CachedSourceProviderShape&lt;WebAssemblySourceProvider, CachedWebAssemblySourceProvider&gt; {
1531     using Base = CachedSourceProviderShape&lt;WebAssemblySourceProvider, CachedWebAssemblySourceProvider&gt;;
1532 
1533 public:
1534     void encode(Encoder&amp; encoder, const WebAssemblySourceProvider&amp; sourceProvider)
1535     {
1536         Base::encode(encoder, sourceProvider);
1537         m_data.encode(encoder, sourceProvider.data());
1538     }
1539 
1540     WebAssemblySourceProvider* decode(Decoder&amp; decoder) const
1541     {
1542         Vector&lt;uint8_t&gt; decodedData;
1543         SourceOrigin decodedSourceOrigin = m_sourceOrigin.decode(decoder);
1544         String decodedURL = m_url.decode(decoder);
1545 
1546         m_data.decode(decoder, decodedData);
1547 
1548         Ref&lt;WebAssemblySourceProvider&gt; sourceProvider = WebAssemblySourceProvider::create(WTFMove(decodedData), decodedSourceOrigin, URL(URL(), decodedURL));
1549         Base::decode(decoder, sourceProvider.get());
1550 
1551         return &amp;sourceProvider.leakRef();
1552     }
1553 
1554 private:
1555     CachedVector&lt;uint8_t&gt; m_data;
1556 };
1557 #endif
1558 
1559 class CachedSourceProvider : public VariableLengthObject&lt;SourceProvider&gt; {
1560 public:
1561     void encode(Encoder&amp; encoder, const SourceProvider&amp; sourceProvider)
1562     {
1563         m_sourceType = sourceProvider.sourceType();
1564         switch (m_sourceType) {
1565         case SourceProviderSourceType::Program:
1566         case SourceProviderSourceType::Module:
1567             this-&gt;allocate&lt;CachedStringSourceProvider&gt;(encoder)-&gt;encode(encoder, reinterpret_cast&lt;const StringSourceProvider&amp;&gt;(sourceProvider));
1568             break;
1569 #if ENABLE(WEBASSEMBLY)
1570         case SourceProviderSourceType::WebAssembly:
1571             this-&gt;allocate&lt;CachedWebAssemblySourceProvider&gt;(encoder)-&gt;encode(encoder, reinterpret_cast&lt;const WebAssemblySourceProvider&amp;&gt;(sourceProvider));
1572             break;
1573 #endif
1574         default:
1575             RELEASE_ASSERT_NOT_REACHED();
1576         }
1577     }
1578 
1579     SourceProvider* decode(Decoder&amp; decoder) const
1580     {
1581         switch (m_sourceType) {
1582         case SourceProviderSourceType::Program:
1583         case SourceProviderSourceType::Module:
1584             return this-&gt;buffer&lt;CachedStringSourceProvider&gt;()-&gt;decode(decoder, m_sourceType);
1585 #if ENABLE(WEBASSEMBLY)
1586         case SourceProviderSourceType::WebAssembly:
1587             return this-&gt;buffer&lt;CachedWebAssemblySourceProvider&gt;()-&gt;decode(decoder);
1588 #endif
1589         default:
1590             RELEASE_ASSERT_NOT_REACHED();
1591         }
1592     }
1593 
1594 private:
1595     SourceProviderSourceType m_sourceType;
1596 };
1597 
1598 template&lt;typename Source&gt;
1599 class CachedUnlinkedSourceCodeShape : public CachedObject&lt;Source&gt; {
1600 public:
1601     void encode(Encoder&amp; encoder, const UnlinkedSourceCode&amp; sourceCode)
1602     {
1603         m_provider.encode(encoder, sourceCode.m_provider);
1604         m_startOffset = sourceCode.startOffset();
1605         m_endOffset = sourceCode.endOffset();
1606     }
1607 
1608     void decode(Decoder&amp; decoder, UnlinkedSourceCode&amp; sourceCode) const
1609     {
1610         sourceCode.m_provider = m_provider.decode(decoder);
1611         sourceCode.m_startOffset = m_startOffset;
1612         sourceCode.m_endOffset = m_endOffset;
1613     }
1614 
1615 private:
1616     CachedRefPtr&lt;CachedSourceProvider&gt; m_provider;
1617     int m_startOffset;
1618     int m_endOffset;
1619 };
1620 
1621 
1622 class CachedUnlinkedSourceCode : public CachedUnlinkedSourceCodeShape&lt;UnlinkedSourceCode&gt; { };
1623 
1624 class CachedSourceCode : public CachedUnlinkedSourceCodeShape&lt;SourceCode&gt; {
1625     using Base = CachedUnlinkedSourceCodeShape&lt;SourceCode&gt;;
1626 
1627 public:
1628     void encode(Encoder&amp; encoder, const SourceCode&amp; sourceCode)
1629     {
1630         Base::encode(encoder, sourceCode);
1631         m_firstLine = sourceCode.firstLine().zeroBasedInt();
1632         m_startColumn = sourceCode.startColumn().zeroBasedInt();
1633     }
1634 
1635     void decode(Decoder&amp; decoder, SourceCode&amp; sourceCode) const
1636     {
1637         Base::decode(decoder, sourceCode);
1638         sourceCode.m_firstLine = OrdinalNumber::fromZeroBasedInt(m_firstLine);
1639         sourceCode.m_startColumn = OrdinalNumber::fromZeroBasedInt(m_startColumn);
1640     }
1641 
1642 private:
1643     int m_firstLine;
1644     int m_startColumn;
1645 };
1646 
1647 class CachedSourceCodeWithoutProvider : public CachedObject&lt;SourceCode&gt; {
1648 public:
1649     void encode(Encoder&amp;, const SourceCode&amp; sourceCode)
1650     {
1651         m_hasProvider = !!sourceCode.provider();
1652         m_startOffset = sourceCode.startOffset();
1653         m_endOffset = sourceCode.endOffset();
1654         m_firstLine = sourceCode.firstLine().zeroBasedInt();
1655         m_startColumn = sourceCode.startColumn().zeroBasedInt();
1656     }
1657 
1658     void decode(Decoder&amp; decoder, SourceCode&amp; sourceCode) const
1659     {
1660         if (m_hasProvider)
1661             sourceCode.m_provider = decoder.provider();
1662         sourceCode.m_startOffset = m_startOffset;
1663         sourceCode.m_endOffset = m_endOffset;
1664         sourceCode.m_firstLine = OrdinalNumber::fromZeroBasedInt(m_firstLine);
1665         sourceCode.m_startColumn = OrdinalNumber::fromZeroBasedInt(m_startColumn);
1666     }
1667 
1668 private:
1669     bool m_hasProvider;
1670     int m_startOffset;
1671     int m_endOffset;
1672     int m_firstLine;
1673     int m_startColumn;
1674 };
1675 
1676 class CachedFunctionExecutableRareData : public CachedObject&lt;UnlinkedFunctionExecutable::RareData&gt; {
1677 public:
1678     void encode(Encoder&amp; encoder, const UnlinkedFunctionExecutable::RareData&amp; rareData)
1679     {
1680         m_classSource.encode(encoder, rareData.m_classSource);
1681         m_parentScopeTDZVariables.encode(encoder, rareData.m_parentScopeTDZVariables);
1682     }
1683 
1684     UnlinkedFunctionExecutable::RareData* decode(Decoder&amp; decoder) const
1685     {
1686         UnlinkedFunctionExecutable::RareData* rareData = new UnlinkedFunctionExecutable::RareData { };
1687         m_classSource.decode(decoder, rareData-&gt;m_classSource);
1688         auto parentScopeTDZVariables = m_parentScopeTDZVariables.decode(decoder);
1689         rareData-&gt;m_parentScopeTDZVariables = WTFMove(parentScopeTDZVariables);
1690         return rareData;
1691     }
1692 
1693 private:
1694     CachedSourceCodeWithoutProvider m_classSource;
1695     CachedCompactVariableMapHandle m_parentScopeTDZVariables;
1696 };
1697 
1698 class CachedFunctionExecutable : public CachedObject&lt;UnlinkedFunctionExecutable&gt; {
1699     friend struct CachedFunctionExecutableOffsets;
1700 
1701 public:
1702     void encode(Encoder&amp;, const UnlinkedFunctionExecutable&amp;);
1703     UnlinkedFunctionExecutable* decode(Decoder&amp;) const;
1704 
1705     unsigned firstLineOffset() const { return m_firstLineOffset; }
1706     unsigned lineCount() const { return m_lineCount; }
1707     unsigned unlinkedFunctionNameStart() const { return m_unlinkedFunctionNameStart; }
1708     unsigned unlinkedBodyStartColumn() const { return m_unlinkedBodyStartColumn; }
1709     unsigned unlinkedBodyEndColumn() const { return m_unlinkedBodyEndColumn; }
1710     unsigned startOffset() const { return m_startOffset; }
1711     unsigned sourceLength() const { return m_sourceLength; }
1712     unsigned parametersStartOffset() const { return m_parametersStartOffset; }
1713     unsigned typeProfilingStartOffset() const { return m_typeProfilingStartOffset; }
1714     unsigned typeProfilingEndOffset() const { return m_typeProfilingEndOffset; }
1715     unsigned parameterCount() const { return m_parameterCount; }
1716 
1717     CodeFeatures features() const { return m_mutableMetadata.m_features; }
1718     SourceParseMode sourceParseMode() const { return m_sourceParseMode; }
1719 
1720     unsigned isInStrictContext() const { return m_isInStrictContext; }
1721     unsigned hasCapturedVariables() const { return m_mutableMetadata.m_hasCapturedVariables; }
1722     unsigned isBuiltinFunction() const { return m_isBuiltinFunction; }
1723     unsigned isBuiltinDefaultClassConstructor() const { return m_isBuiltinDefaultClassConstructor; }
1724     unsigned constructAbility() const { return m_constructAbility; }
1725     unsigned constructorKind() const { return m_constructorKind; }
1726     unsigned functionMode() const { return m_functionMode; }
1727     unsigned scriptMode() const { return m_scriptMode; }
1728     unsigned superBinding() const { return m_superBinding; }
1729     unsigned derivedContextType() const { return m_derivedContextType; }
<a name="25" id="anc25"></a><span class="line-added">1730     unsigned needsClassFieldInitializer() const { return m_needsClassFieldInitializer; }</span>
1731 
1732     Identifier name(Decoder&amp; decoder) const { return m_name.decode(decoder); }
1733     Identifier ecmaName(Decoder&amp; decoder) const { return m_ecmaName.decode(decoder); }
1734 
1735     UnlinkedFunctionExecutable::RareData* rareData(Decoder&amp; decoder) const { return m_rareData.decode(decoder); }
1736 
1737     const CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt;&amp; unlinkedCodeBlockForCall() const { return m_unlinkedCodeBlockForCall; }
1738     const CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt;&amp; unlinkedCodeBlockForConstruct() const { return m_unlinkedCodeBlockForConstruct; }
1739 
1740 private:
1741     CachedFunctionExecutableMetadata m_mutableMetadata;
1742 
1743     unsigned m_firstLineOffset : 31;
1744     unsigned m_isInStrictContext : 1;
1745     unsigned m_lineCount : 31;
1746     unsigned m_isBuiltinFunction : 1;
1747     unsigned m_unlinkedFunctionNameStart : 31;
1748     unsigned m_isBuiltinDefaultClassConstructor : 1;
1749     unsigned m_unlinkedBodyStartColumn : 31;
1750     unsigned m_constructAbility: 1;
1751     unsigned m_unlinkedBodyEndColumn : 31;
1752     unsigned m_startOffset : 31;
1753     unsigned m_scriptMode: 1; // JSParserScriptMode
1754     unsigned m_sourceLength : 31;
1755     unsigned m_superBinding : 1;
1756     unsigned m_parametersStartOffset : 31;
1757     unsigned m_typeProfilingStartOffset;
1758     unsigned m_typeProfilingEndOffset;
1759     unsigned m_parameterCount;
1760     SourceParseMode m_sourceParseMode;
1761     unsigned m_constructorKind : 2;
1762     unsigned m_functionMode : 2; // FunctionMode
1763     unsigned m_derivedContextType: 2;
<a name="26" id="anc26"></a><span class="line-added">1764     unsigned m_needsClassFieldInitializer : 1;</span>
1765 
1766     CachedPtr&lt;CachedFunctionExecutableRareData&gt; m_rareData;
1767 
1768     CachedIdentifier m_name;
1769     CachedIdentifier m_ecmaName;
1770 
1771     CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt; m_unlinkedCodeBlockForCall;
1772     CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt; m_unlinkedCodeBlockForConstruct;
1773 };
1774 
1775 ptrdiff_t CachedFunctionExecutableOffsets::codeBlockForCallOffset()
1776 {
1777     return OBJECT_OFFSETOF(CachedFunctionExecutable, m_unlinkedCodeBlockForCall);
1778 }
1779 
1780 ptrdiff_t CachedFunctionExecutableOffsets::codeBlockForConstructOffset()
1781 {
1782     return OBJECT_OFFSETOF(CachedFunctionExecutable, m_unlinkedCodeBlockForConstruct);
1783 }
1784 
1785 ptrdiff_t CachedFunctionExecutableOffsets::metadataOffset()
1786 {
1787     return OBJECT_OFFSETOF(CachedFunctionExecutable, m_mutableMetadata);
1788 }
1789 
1790 template&lt;typename CodeBlockType&gt;
1791 class CachedCodeBlock : public CachedObject&lt;CodeBlockType&gt; {
1792 public:
1793     void encode(Encoder&amp;, const UnlinkedCodeBlock&amp;);
1794     void decode(Decoder&amp;, UnlinkedCodeBlock&amp;) const;
1795 
1796     InstructionStream* instructions(Decoder&amp; decoder) const { return m_instructions.decode(decoder); }
1797 
1798     VirtualRegister thisRegister() const { return m_thisRegister; }
1799     VirtualRegister scopeRegister() const { return m_scopeRegister; }
1800 
<a name="27" id="anc27"></a><span class="line-modified">1801     RefPtr&lt;StringImpl&gt; sourceURLDirective(Decoder&amp; decoder) const { return m_sourceURLDirective.decode(decoder); }</span>
<span class="line-modified">1802     RefPtr&lt;StringImpl&gt; sourceMappingURLDirective(Decoder&amp; decoder) const { return m_sourceMappingURLDirective.decode(decoder); }</span>
1803 
1804     Ref&lt;UnlinkedMetadataTable&gt; metadata(Decoder&amp; decoder) const { return m_metadata.decode(decoder); }
1805 
1806     unsigned usesEval() const { return m_usesEval; }
1807     unsigned isStrictMode() const { return m_isStrictMode; }
1808     unsigned isConstructor() const { return m_isConstructor; }
1809     unsigned hasCapturedVariables() const { return m_hasCapturedVariables; }
1810     unsigned isBuiltinFunction() const { return m_isBuiltinFunction; }
1811     unsigned superBinding() const { return m_superBinding; }
1812     unsigned scriptMode() const { return m_scriptMode; }
1813     unsigned isArrowFunctionContext() const { return m_isArrowFunctionContext; }
1814     unsigned isClassContext() const { return m_isClassContext; }
1815     unsigned constructorKind() const { return m_constructorKind; }
1816     unsigned derivedContextType() const { return m_derivedContextType; }
<a name="28" id="anc28"></a><span class="line-added">1817     unsigned needsClassFieldInitializer() const { return m_needsClassFieldInitializer; }</span>
1818     unsigned evalContextType() const { return m_evalContextType; }
1819     unsigned hasTailCalls() const { return m_hasTailCalls; }
<a name="29" id="anc29"></a><span class="line-added">1820     unsigned hasCheckpoints() const { return m_hasCheckpoints; }</span>
1821     unsigned lineCount() const { return m_lineCount; }
1822     unsigned endColumn() const { return m_endColumn; }
1823 
1824     int numVars() const { return m_numVars; }
1825     int numCalleeLocals() const { return m_numCalleeLocals; }
1826     int numParameters() const { return m_numParameters; }
1827 
1828     CodeFeatures features() const { return m_features; }
1829     SourceParseMode parseMode() const { return m_parseMode; }
1830     OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode() const { return m_codeGenerationMode; }
1831     unsigned codeType() const { return m_codeType; }
1832 
1833     UnlinkedCodeBlock::RareData* rareData(Decoder&amp; decoder) const { return m_rareData.decode(decoder); }
1834 
1835 private:
1836     VirtualRegister m_thisRegister;
1837     VirtualRegister m_scopeRegister;
<a name="30" id="anc30"></a>
1838 
1839     unsigned m_usesEval : 1;
1840     unsigned m_isStrictMode : 1;
1841     unsigned m_isConstructor : 1;
1842     unsigned m_hasCapturedVariables : 1;
1843     unsigned m_isBuiltinFunction : 1;
1844     unsigned m_superBinding : 1;
1845     unsigned m_scriptMode: 1;
1846     unsigned m_isArrowFunctionContext : 1;
1847     unsigned m_isClassContext : 1;
1848     unsigned m_constructorKind : 2;
1849     unsigned m_derivedContextType : 2;
<a name="31" id="anc31"></a><span class="line-added">1850     unsigned m_needsClassFieldInitializer : 1;</span>
1851     unsigned m_evalContextType : 2;
1852     unsigned m_hasTailCalls : 1;
1853     unsigned m_codeType : 2;
<a name="32" id="anc32"></a><span class="line-added">1854     unsigned m_hasCheckpoints : 1;</span>
1855 
1856     CodeFeatures m_features;
1857     SourceParseMode m_parseMode;
1858     OptionSet&lt;CodeGenerationMode&gt; m_codeGenerationMode;
1859 
1860     unsigned m_lineCount;
1861     unsigned m_endColumn;
1862 
1863     int m_numVars;
1864     int m_numCalleeLocals;
1865     int m_numParameters;
1866 
1867     CachedMetadataTable m_metadata;
1868 
1869     CachedPtr&lt;CachedCodeBlockRareData&gt; m_rareData;
1870 
<a name="33" id="anc33"></a><span class="line-modified">1871     CachedRefPtr&lt;CachedStringImpl&gt; m_sourceURLDirective;</span>
<span class="line-modified">1872     CachedRefPtr&lt;CachedStringImpl&gt; m_sourceMappingURLDirective;</span>
1873 
1874     CachedPtr&lt;CachedInstructionStream&gt; m_instructions;
1875     CachedVector&lt;InstructionStream::Offset&gt; m_jumpTargets;
<a name="34" id="anc34"></a>
1876     CachedVector&lt;CachedJSValue&gt; m_constantRegisters;
1877     CachedVector&lt;SourceCodeRepresentation&gt; m_constantsSourceCodeRepresentation;
1878     CachedVector&lt;ExpressionRangeInfo&gt; m_expressionInfo;
1879     CachedHashMap&lt;InstructionStream::Offset, int&gt; m_outOfLineJumpTargets;
1880 
1881     CachedVector&lt;CachedIdentifier&gt; m_identifiers;
1882     CachedVector&lt;CachedWriteBarrier&lt;CachedFunctionExecutable&gt;&gt; m_functionDecls;
1883     CachedVector&lt;CachedWriteBarrier&lt;CachedFunctionExecutable&gt;&gt; m_functionExprs;
1884 };
1885 
1886 class CachedProgramCodeBlock : public CachedCodeBlock&lt;UnlinkedProgramCodeBlock&gt; {
1887     using Base = CachedCodeBlock&lt;UnlinkedProgramCodeBlock&gt;;
1888 
1889 public:
1890     void encode(Encoder&amp; encoder, const UnlinkedProgramCodeBlock&amp; codeBlock)
1891     {
1892         Base::encode(encoder, codeBlock);
1893         m_varDeclarations.encode(encoder, codeBlock.m_varDeclarations);
1894         m_lexicalDeclarations.encode(encoder, codeBlock.m_lexicalDeclarations);
1895     }
1896 
1897     UnlinkedProgramCodeBlock* decode(Decoder&amp; decoder) const
1898     {
1899         UnlinkedProgramCodeBlock* codeBlock = new (NotNull, allocateCell&lt;UnlinkedProgramCodeBlock&gt;(decoder.vm().heap)) UnlinkedProgramCodeBlock(decoder, *this);
1900         codeBlock-&gt;finishCreation(decoder.vm());
1901         Base::decode(decoder, *codeBlock);
1902         m_varDeclarations.decode(decoder, codeBlock-&gt;m_varDeclarations);
1903         m_lexicalDeclarations.decode(decoder, codeBlock-&gt;m_lexicalDeclarations);
1904         return codeBlock;
1905     }
1906 
1907 private:
1908     CachedVariableEnvironment m_varDeclarations;
1909     CachedVariableEnvironment m_lexicalDeclarations;
1910 };
1911 
1912 class CachedModuleCodeBlock : public CachedCodeBlock&lt;UnlinkedModuleProgramCodeBlock&gt; {
1913     using Base = CachedCodeBlock&lt;UnlinkedModuleProgramCodeBlock&gt;;
1914 
1915 public:
1916     void encode(Encoder&amp; encoder, const UnlinkedModuleProgramCodeBlock&amp; codeBlock)
1917     {
1918         Base::encode(encoder, codeBlock);
1919         m_moduleEnvironmentSymbolTableConstantRegisterOffset = codeBlock.m_moduleEnvironmentSymbolTableConstantRegisterOffset;
1920     }
1921 
1922     UnlinkedModuleProgramCodeBlock* decode(Decoder&amp; decoder) const
1923     {
1924         UnlinkedModuleProgramCodeBlock* codeBlock = new (NotNull, allocateCell&lt;UnlinkedModuleProgramCodeBlock&gt;(decoder.vm().heap)) UnlinkedModuleProgramCodeBlock(decoder, *this);
1925         codeBlock-&gt;finishCreation(decoder.vm());
1926         Base::decode(decoder, *codeBlock);
1927         codeBlock-&gt;m_moduleEnvironmentSymbolTableConstantRegisterOffset = m_moduleEnvironmentSymbolTableConstantRegisterOffset;
1928         return codeBlock;
1929     }
1930 
1931 private:
1932     int m_moduleEnvironmentSymbolTableConstantRegisterOffset;
1933 };
1934 
1935 class CachedEvalCodeBlock : public CachedCodeBlock&lt;UnlinkedEvalCodeBlock&gt; {
1936     using Base = CachedCodeBlock&lt;UnlinkedEvalCodeBlock&gt;;
1937 
1938 public:
1939     void encode(Encoder&amp; encoder, const UnlinkedEvalCodeBlock&amp; codeBlock)
1940     {
1941         Base::encode(encoder, codeBlock);
1942         m_variables.encode(encoder, codeBlock.m_variables);
1943         m_functionHoistingCandidates.encode(encoder, codeBlock.m_functionHoistingCandidates);
1944     }
1945 
1946     UnlinkedEvalCodeBlock* decode(Decoder&amp; decoder) const
1947     {
1948         UnlinkedEvalCodeBlock* codeBlock = new (NotNull, allocateCell&lt;UnlinkedEvalCodeBlock&gt;(decoder.vm().heap)) UnlinkedEvalCodeBlock(decoder, *this);
1949         codeBlock-&gt;finishCreation(decoder.vm());
1950         Base::decode(decoder, *codeBlock);
1951         m_variables.decode(decoder, codeBlock-&gt;m_variables);
1952         m_functionHoistingCandidates.decode(decoder, codeBlock-&gt;m_functionHoistingCandidates);
1953         return codeBlock;
1954     }
1955 
1956 private:
1957     CachedVector&lt;CachedIdentifier, 0, UnsafeVectorOverflow&gt; m_variables;
1958     CachedVector&lt;CachedIdentifier, 0, UnsafeVectorOverflow&gt; m_functionHoistingCandidates;
1959 };
1960 
1961 class CachedFunctionCodeBlock : public CachedCodeBlock&lt;UnlinkedFunctionCodeBlock&gt; {
1962     using Base = CachedCodeBlock&lt;UnlinkedFunctionCodeBlock&gt;;
1963 
1964 public:
1965     void encode(Encoder&amp; encoder, const UnlinkedFunctionCodeBlock&amp; codeBlock)
1966     {
1967         Base::encode(encoder, codeBlock);
1968     }
1969 
1970     UnlinkedFunctionCodeBlock* decode(Decoder&amp; decoder) const
1971     {
1972         UnlinkedFunctionCodeBlock* codeBlock = new (NotNull, allocateCell&lt;UnlinkedFunctionCodeBlock&gt;(decoder.vm().heap)) UnlinkedFunctionCodeBlock(decoder, *this);
1973         codeBlock-&gt;finishCreation(decoder.vm());
1974         Base::decode(decoder, *codeBlock);
1975         return codeBlock;
1976     }
1977 };
1978 
1979 ALWAYS_INLINE UnlinkedFunctionCodeBlock::UnlinkedFunctionCodeBlock(Decoder&amp; decoder, const CachedFunctionCodeBlock&amp; cachedCodeBlock)
1980     : Base(decoder, decoder.vm().unlinkedFunctionCodeBlockStructure.get(), cachedCodeBlock)
1981 {
1982 }
1983 
1984 template&lt;typename T&gt;
1985 struct CachedCodeBlockTypeImpl;
1986 
1987 enum CachedCodeBlockTag {
1988     CachedProgramCodeBlockTag,
1989     CachedModuleCodeBlockTag,
1990     CachedEvalCodeBlockTag,
1991 };
1992 
1993 static CachedCodeBlockTag tagFromSourceCodeType(SourceCodeType type)
1994 {
1995     switch (type) {
1996     case SourceCodeType::ProgramType:
1997         return CachedProgramCodeBlockTag;
1998     case SourceCodeType::EvalType:
1999         return CachedEvalCodeBlockTag;
2000     case SourceCodeType::ModuleType:
2001         return CachedModuleCodeBlockTag;
2002     case SourceCodeType::FunctionType:
2003         break;
2004     }
2005     ASSERT_NOT_REACHED();
2006     return static_cast&lt;CachedCodeBlockTag&gt;(-1);
2007 }
2008 
2009 template&lt;&gt;
2010 struct CachedCodeBlockTypeImpl&lt;UnlinkedProgramCodeBlock&gt; {
2011     using type = CachedProgramCodeBlock;
2012     static constexpr CachedCodeBlockTag tag = CachedProgramCodeBlockTag;
2013 };
2014 
2015 template&lt;&gt;
2016 struct CachedCodeBlockTypeImpl&lt;UnlinkedModuleProgramCodeBlock&gt; {
2017     using type = CachedModuleCodeBlock;
2018     static constexpr CachedCodeBlockTag tag = CachedModuleCodeBlockTag;
2019 };
2020 
2021 template&lt;&gt;
2022 struct CachedCodeBlockTypeImpl&lt;UnlinkedEvalCodeBlock&gt; {
2023     using type = CachedEvalCodeBlock;
2024     static constexpr CachedCodeBlockTag tag = CachedEvalCodeBlockTag;
2025 };
2026 
2027 template&lt;typename T&gt;
2028 using CachedCodeBlockType = typename CachedCodeBlockTypeImpl&lt;T&gt;::type;
2029 
2030 template&lt;typename CodeBlockType&gt;
2031 ALWAYS_INLINE UnlinkedCodeBlock::UnlinkedCodeBlock(Decoder&amp; decoder, Structure* structure, const CachedCodeBlock&lt;CodeBlockType&gt;&amp; cachedCodeBlock)
2032     : Base(decoder.vm(), structure)
2033     , m_thisRegister(cachedCodeBlock.thisRegister())
2034     , m_scopeRegister(cachedCodeBlock.scopeRegister())
2035 
2036     , m_usesEval(cachedCodeBlock.usesEval())
2037     , m_isStrictMode(cachedCodeBlock.isStrictMode())
2038     , m_isConstructor(cachedCodeBlock.isConstructor())
2039     , m_hasCapturedVariables(cachedCodeBlock.hasCapturedVariables())
2040     , m_isBuiltinFunction(cachedCodeBlock.isBuiltinFunction())
2041     , m_superBinding(cachedCodeBlock.superBinding())
2042     , m_scriptMode(cachedCodeBlock.scriptMode())
2043     , m_isArrowFunctionContext(cachedCodeBlock.isArrowFunctionContext())
2044     , m_isClassContext(cachedCodeBlock.isClassContext())
2045     , m_hasTailCalls(cachedCodeBlock.hasTailCalls())
2046     , m_constructorKind(cachedCodeBlock.constructorKind())
2047     , m_derivedContextType(cachedCodeBlock.derivedContextType())
2048     , m_evalContextType(cachedCodeBlock.evalContextType())
2049     , m_codeType(cachedCodeBlock.codeType())
2050 
2051     , m_didOptimize(static_cast&lt;unsigned&gt;(MixedTriState))
2052     , m_age(0)
<a name="35" id="anc35"></a><span class="line-added">2053     , m_hasCheckpoints(cachedCodeBlock.hasCheckpoints())</span>
2054 
2055     , m_features(cachedCodeBlock.features())
2056     , m_parseMode(cachedCodeBlock.parseMode())
2057     , m_codeGenerationMode(cachedCodeBlock.codeGenerationMode())
2058 
2059     , m_lineCount(cachedCodeBlock.lineCount())
2060     , m_endColumn(cachedCodeBlock.endColumn())
2061     , m_numVars(cachedCodeBlock.numVars())
2062     , m_numCalleeLocals(cachedCodeBlock.numCalleeLocals())
2063     , m_numParameters(cachedCodeBlock.numParameters())
2064 
2065     , m_sourceURLDirective(cachedCodeBlock.sourceURLDirective(decoder))
2066     , m_sourceMappingURLDirective(cachedCodeBlock.sourceMappingURLDirective(decoder))
2067 
2068     , m_metadata(cachedCodeBlock.metadata(decoder))
2069     , m_instructions(cachedCodeBlock.instructions(decoder))
2070 
2071     , m_rareData(cachedCodeBlock.rareData(decoder))
2072 {
2073 }
2074 
2075 template&lt;typename CodeBlockType&gt;
2076 ALWAYS_INLINE void CachedCodeBlock&lt;CodeBlockType&gt;::decode(Decoder&amp; decoder, UnlinkedCodeBlock&amp; codeBlock) const
2077 {
<a name="36" id="anc36"></a>



2078     m_constantRegisters.decode(decoder, codeBlock.m_constantRegisters, &amp;codeBlock);
2079     m_constantsSourceCodeRepresentation.decode(decoder, codeBlock.m_constantsSourceCodeRepresentation);
2080     m_expressionInfo.decode(decoder, codeBlock.m_expressionInfo);
2081     m_outOfLineJumpTargets.decode(decoder, codeBlock.m_outOfLineJumpTargets);
2082     m_jumpTargets.decode(decoder, codeBlock.m_jumpTargets);
2083     m_identifiers.decode(decoder, codeBlock.m_identifiers);
2084     m_functionDecls.decode(decoder, codeBlock.m_functionDecls, &amp;codeBlock);
2085     m_functionExprs.decode(decoder, codeBlock.m_functionExprs, &amp;codeBlock);
2086 }
2087 
2088 ALWAYS_INLINE UnlinkedProgramCodeBlock::UnlinkedProgramCodeBlock(Decoder&amp; decoder, const CachedProgramCodeBlock&amp; cachedCodeBlock)
2089     : Base(decoder, decoder.vm().unlinkedProgramCodeBlockStructure.get(), cachedCodeBlock)
2090 {
2091 }
2092 
2093 ALWAYS_INLINE UnlinkedModuleProgramCodeBlock::UnlinkedModuleProgramCodeBlock(Decoder&amp; decoder, const CachedModuleCodeBlock&amp; cachedCodeBlock)
2094     : Base(decoder, decoder.vm().unlinkedModuleProgramCodeBlockStructure.get(), cachedCodeBlock)
2095 {
2096 }
2097 
2098 ALWAYS_INLINE UnlinkedEvalCodeBlock::UnlinkedEvalCodeBlock(Decoder&amp; decoder, const CachedEvalCodeBlock&amp; cachedCodeBlock)
2099     : Base(decoder, decoder.vm().unlinkedEvalCodeBlockStructure.get(), cachedCodeBlock)
2100 {
2101 }
2102 
2103 ALWAYS_INLINE void CachedFunctionExecutable::encode(Encoder&amp; encoder, const UnlinkedFunctionExecutable&amp; executable)
2104 {
2105     m_mutableMetadata.m_features = executable.m_features;
2106     m_mutableMetadata.m_hasCapturedVariables = executable.m_hasCapturedVariables;
2107 
2108     m_firstLineOffset = executable.m_firstLineOffset;
2109     m_lineCount = executable.m_lineCount;
2110     m_unlinkedFunctionNameStart = executable.m_unlinkedFunctionNameStart;
2111     m_unlinkedBodyStartColumn = executable.m_unlinkedBodyStartColumn;
2112     m_unlinkedBodyEndColumn = executable.m_unlinkedBodyEndColumn;
2113     m_startOffset = executable.m_startOffset;
2114     m_sourceLength = executable.m_sourceLength;
2115     m_parametersStartOffset = executable.m_parametersStartOffset;
2116     m_typeProfilingStartOffset = executable.m_typeProfilingStartOffset;
2117     m_typeProfilingEndOffset = executable.m_typeProfilingEndOffset;
2118     m_parameterCount = executable.m_parameterCount;
2119 
2120     m_sourceParseMode = executable.m_sourceParseMode;
2121 
2122     m_isInStrictContext = executable.m_isInStrictContext;
2123     m_isBuiltinFunction = executable.m_isBuiltinFunction;
2124     m_isBuiltinDefaultClassConstructor = executable.m_isBuiltinDefaultClassConstructor;
2125     m_constructAbility = executable.m_constructAbility;
2126     m_constructorKind = executable.m_constructorKind;
2127     m_functionMode = executable.m_functionMode;
2128     m_scriptMode = executable.m_scriptMode;
2129     m_superBinding = executable.m_superBinding;
2130     m_derivedContextType = executable.m_derivedContextType;
<a name="37" id="anc37"></a><span class="line-added">2131     m_needsClassFieldInitializer = executable.m_needsClassFieldInitializer;</span>
2132 
2133     m_rareData.encode(encoder, executable.m_rareData.get());
2134 
2135     m_name.encode(encoder, executable.name());
2136     m_ecmaName.encode(encoder, executable.ecmaName());
2137 
2138     m_unlinkedCodeBlockForCall.encode(encoder, executable.m_unlinkedCodeBlockForCall);
2139     m_unlinkedCodeBlockForConstruct.encode(encoder, executable.m_unlinkedCodeBlockForConstruct);
2140 
2141     if (!executable.m_unlinkedCodeBlockForCall || !executable.m_unlinkedCodeBlockForConstruct)
2142         encoder.addLeafExecutable(&amp;executable, encoder.offsetOf(this));
2143 }
2144 
2145 ALWAYS_INLINE UnlinkedFunctionExecutable* CachedFunctionExecutable::decode(Decoder&amp; decoder) const
2146 {
2147     UnlinkedFunctionExecutable* executable = new (NotNull, allocateCell&lt;UnlinkedFunctionExecutable&gt;(decoder.vm().heap)) UnlinkedFunctionExecutable(decoder, *this);
2148     executable-&gt;finishCreation(decoder.vm());
2149     return executable;
2150 }
2151 
2152 ALWAYS_INLINE UnlinkedFunctionExecutable::UnlinkedFunctionExecutable(Decoder&amp; decoder, const CachedFunctionExecutable&amp; cachedExecutable)
2153     : Base(decoder.vm(), decoder.vm().unlinkedFunctionExecutableStructure.get())
2154     , m_firstLineOffset(cachedExecutable.firstLineOffset())
2155     , m_isInStrictContext(cachedExecutable.isInStrictContext())
2156     , m_lineCount(cachedExecutable.lineCount())
2157     , m_hasCapturedVariables(cachedExecutable.hasCapturedVariables())
2158     , m_unlinkedFunctionNameStart(cachedExecutable.unlinkedFunctionNameStart())
2159     , m_isBuiltinFunction(cachedExecutable.isBuiltinFunction())
2160     , m_unlinkedBodyStartColumn(cachedExecutable.unlinkedBodyStartColumn())
2161     , m_isBuiltinDefaultClassConstructor(cachedExecutable.isBuiltinDefaultClassConstructor())
2162     , m_unlinkedBodyEndColumn(cachedExecutable.unlinkedBodyEndColumn())
2163     , m_constructAbility(cachedExecutable.constructAbility())
2164     , m_startOffset(cachedExecutable.startOffset())
2165     , m_scriptMode(cachedExecutable.scriptMode())
2166     , m_sourceLength(cachedExecutable.sourceLength())
2167     , m_superBinding(cachedExecutable.superBinding())
2168     , m_parametersStartOffset(cachedExecutable.parametersStartOffset())
2169     , m_isCached(false)
2170     , m_typeProfilingStartOffset(cachedExecutable.typeProfilingStartOffset())
2171     , m_typeProfilingEndOffset(cachedExecutable.typeProfilingEndOffset())
2172     , m_parameterCount(cachedExecutable.parameterCount())
2173     , m_features(cachedExecutable.features())
2174     , m_sourceParseMode(cachedExecutable.sourceParseMode())
2175     , m_constructorKind(cachedExecutable.constructorKind())
2176     , m_functionMode(cachedExecutable.functionMode())
2177     , m_derivedContextType(cachedExecutable.derivedContextType())
2178     , m_isGeneratedFromCache(true)
<a name="38" id="anc38"></a><span class="line-added">2179     , m_needsClassFieldInitializer(cachedExecutable.needsClassFieldInitializer())</span>
2180     , m_unlinkedCodeBlockForCall()
2181     , m_unlinkedCodeBlockForConstruct()
2182 
2183     , m_name(cachedExecutable.name(decoder))
2184     , m_ecmaName(cachedExecutable.ecmaName(decoder))
2185 
2186     , m_rareData(cachedExecutable.rareData(decoder))
2187 {
2188 
2189     uint32_t leafExecutables = 2;
2190     auto checkBounds = [&amp;](int32_t&amp; codeBlockOffset, auto&amp; cachedPtr) {
2191         if (!cachedPtr.isEmpty()) {
2192             ptrdiff_t offset = decoder.offsetOf(&amp;cachedPtr);
2193             if (static_cast&lt;size_t&gt;(offset) &lt; decoder.size()) {
2194                 codeBlockOffset = offset;
2195                 m_isCached = true;
2196                 leafExecutables--;
2197                 return;
2198             }
2199         }
2200 
2201         codeBlockOffset = 0;
2202     };
2203 
2204     if (!cachedExecutable.unlinkedCodeBlockForCall().isEmpty() || !cachedExecutable.unlinkedCodeBlockForConstruct().isEmpty()) {
2205         checkBounds(m_cachedCodeBlockForCallOffset, cachedExecutable.unlinkedCodeBlockForCall());
2206         checkBounds(m_cachedCodeBlockForConstructOffset, cachedExecutable.unlinkedCodeBlockForConstruct());
2207         if (m_isCached)
2208             m_decoder = &amp;decoder;
2209         else
2210             m_decoder = nullptr;
2211     }
2212 
2213     if (leafExecutables)
2214         decoder.addLeafExecutable(this, decoder.offsetOf(&amp;cachedExecutable));
2215 }
2216 
2217 template&lt;typename CodeBlockType&gt;
2218 ALWAYS_INLINE void CachedCodeBlock&lt;CodeBlockType&gt;::encode(Encoder&amp; encoder, const UnlinkedCodeBlock&amp; codeBlock)
2219 {
2220     m_thisRegister = codeBlock.m_thisRegister;
2221     m_scopeRegister = codeBlock.m_scopeRegister;
2222     m_usesEval = codeBlock.m_usesEval;
2223     m_isStrictMode = codeBlock.m_isStrictMode;
2224     m_isConstructor = codeBlock.m_isConstructor;
2225     m_hasCapturedVariables = codeBlock.m_hasCapturedVariables;
2226     m_isBuiltinFunction = codeBlock.m_isBuiltinFunction;
2227     m_superBinding = codeBlock.m_superBinding;
2228     m_scriptMode = codeBlock.m_scriptMode;
2229     m_isArrowFunctionContext = codeBlock.m_isArrowFunctionContext;
2230     m_isClassContext = codeBlock.m_isClassContext;
2231     m_hasTailCalls = codeBlock.m_hasTailCalls;
2232     m_constructorKind = codeBlock.m_constructorKind;
2233     m_derivedContextType = codeBlock.m_derivedContextType;
2234     m_evalContextType = codeBlock.m_evalContextType;
2235     m_lineCount = codeBlock.m_lineCount;
2236     m_endColumn = codeBlock.m_endColumn;
2237     m_numVars = codeBlock.m_numVars;
2238     m_numCalleeLocals = codeBlock.m_numCalleeLocals;
2239     m_numParameters = codeBlock.m_numParameters;
2240     m_features = codeBlock.m_features;
2241     m_parseMode = codeBlock.m_parseMode;
2242     m_codeGenerationMode = codeBlock.m_codeGenerationMode;
2243     m_codeType = codeBlock.m_codeType;
<a name="39" id="anc39"></a><span class="line-modified">2244     m_hasCheckpoints = codeBlock.m_hasCheckpoints;</span>


2245 
2246     m_metadata.encode(encoder, codeBlock.m_metadata.get());
2247     m_rareData.encode(encoder, codeBlock.m_rareData.get());
2248 
<a name="40" id="anc40"></a><span class="line-modified">2249     m_sourceURLDirective.encode(encoder, codeBlock.m_sourceURLDirective.get());</span>
<span class="line-modified">2250     m_sourceMappingURLDirective.encode(encoder, codeBlock.m_sourceURLDirective.get());</span>
2251 
2252     m_instructions.encode(encoder, codeBlock.m_instructions.get());
<a name="41" id="anc41"></a>
2253     m_constantRegisters.encode(encoder, codeBlock.m_constantRegisters);
2254     m_constantsSourceCodeRepresentation.encode(encoder, codeBlock.m_constantsSourceCodeRepresentation);
2255     m_expressionInfo.encode(encoder, codeBlock.m_expressionInfo);
2256     m_jumpTargets.encode(encoder, codeBlock.m_jumpTargets);
2257     m_outOfLineJumpTargets.encode(encoder, codeBlock.m_outOfLineJumpTargets);
2258 
2259     m_identifiers.encode(encoder, codeBlock.m_identifiers);
2260     m_functionDecls.encode(encoder, codeBlock.m_functionDecls);
2261     m_functionExprs.encode(encoder, codeBlock.m_functionExprs);
2262 }
2263 
2264 class CachedSourceCodeKey : public CachedObject&lt;SourceCodeKey&gt; {
2265 public:
2266     void encode(Encoder&amp; encoder, const SourceCodeKey&amp; key)
2267     {
2268         m_sourceCode.encode(encoder, key.m_sourceCode);
2269         m_name.encode(encoder, key.m_name);
2270         m_flags = key.m_flags.m_flags;
2271         m_hash = key.hash();
2272         m_functionConstructorParametersEndPosition = key.m_functionConstructorParametersEndPosition;
2273     }
2274 
2275     void decode(Decoder&amp; decoder, SourceCodeKey&amp; key) const
2276     {
2277         m_sourceCode.decode(decoder, key.m_sourceCode);
2278         m_name.decode(decoder, key.m_name);
2279         key.m_flags.m_flags = m_flags;
2280         key.m_hash = m_hash;
2281         key.m_functionConstructorParametersEndPosition = m_functionConstructorParametersEndPosition;
2282     }
2283 
2284 private:
2285     CachedUnlinkedSourceCode m_sourceCode;
2286     CachedString m_name;
2287     unsigned m_flags;
2288     unsigned m_hash;
2289     int m_functionConstructorParametersEndPosition;
2290 };
2291 
2292 class GenericCacheEntry {
2293 public:
2294     bool decode(Decoder&amp;, std::pair&lt;SourceCodeKey, UnlinkedCodeBlock*&gt;&amp;) const;
2295     bool isStillValid(Decoder&amp;, const SourceCodeKey&amp;, CachedCodeBlockTag) const;
2296 
2297 protected:
2298     GenericCacheEntry(Encoder&amp; encoder, CachedCodeBlockTag tag)
2299         : m_tag(tag)
2300     {
2301         m_bootSessionUUID.encode(encoder, bootSessionUUIDString());
2302     }
2303 
2304     CachedCodeBlockTag tag() const { return m_tag; }
2305 
2306     bool isUpToDate(Decoder&amp; decoder) const
2307     {
<a name="42" id="anc42"></a><span class="line-modified">2308         if (m_cacheVersion != jscBytecodeCacheVersion())</span>
2309             return false;
2310         if (m_bootSessionUUID.decode(decoder) != bootSessionUUIDString())
2311             return false;
2312         return true;
2313     }
2314 
2315 private:
<a name="43" id="anc43"></a><span class="line-modified">2316     uint32_t m_cacheVersion { jscBytecodeCacheVersion() };</span>
2317     CachedString m_bootSessionUUID;
2318     CachedCodeBlockTag m_tag;
2319 };
2320 
2321 template&lt;typename UnlinkedCodeBlockType&gt;
2322 class CacheEntry : public GenericCacheEntry {
2323 public:
2324     CacheEntry(Encoder&amp; encoder)
2325         : GenericCacheEntry(encoder, CachedCodeBlockTypeImpl&lt;UnlinkedCodeBlockType&gt;::tag)
2326     {
2327     }
2328 
2329     void encode(Encoder&amp; encoder, std::pair&lt;SourceCodeKey, const UnlinkedCodeBlockType*&gt; pair)
2330     {
2331         m_key.encode(encoder, pair.first);
2332         m_codeBlock.encode(encoder, pair.second);
2333     }
2334 
2335 private:
2336     friend GenericCacheEntry;
2337 
2338     bool isStillValid(Decoder&amp; decoder, const SourceCodeKey&amp; key) const
2339     {
2340         SourceCodeKey decodedKey;
2341         m_key.decode(decoder, decodedKey);
2342         return decodedKey == key;
2343     }
2344 
2345     bool decode(Decoder&amp; decoder, std::pair&lt;SourceCodeKey, UnlinkedCodeBlockType*&gt;&amp; result) const
2346     {
2347         ASSERT(tag() == CachedCodeBlockTypeImpl&lt;UnlinkedCodeBlockType&gt;::tag);
2348         SourceCodeKey decodedKey;
2349         m_key.decode(decoder, decodedKey);
2350         result = { WTFMove(decodedKey), m_codeBlock.decode(decoder) };
2351         return true;
2352     }
2353 
2354     CachedSourceCodeKey m_key;
2355     CachedPtr&lt;CachedCodeBlockType&lt;UnlinkedCodeBlockType&gt;&gt; m_codeBlock;
2356 };
2357 
2358 bool GenericCacheEntry::decode(Decoder&amp; decoder, std::pair&lt;SourceCodeKey, UnlinkedCodeBlock*&gt;&amp; result) const
2359 {
2360     if (!isUpToDate(decoder))
2361         return false;
2362 
2363     switch (m_tag) {
2364     case CachedProgramCodeBlockTag:
2365         return bitwise_cast&lt;const CacheEntry&lt;UnlinkedProgramCodeBlock&gt;*&gt;(this)-&gt;decode(decoder, reinterpret_cast&lt;std::pair&lt;SourceCodeKey, UnlinkedProgramCodeBlock*&gt;&amp;&gt;(result));
2366     case CachedModuleCodeBlockTag:
2367         return bitwise_cast&lt;const CacheEntry&lt;UnlinkedModuleProgramCodeBlock&gt;*&gt;(this)-&gt;decode(decoder, reinterpret_cast&lt;std::pair&lt;SourceCodeKey, UnlinkedModuleProgramCodeBlock*&gt;&amp;&gt;(result));
2368     case CachedEvalCodeBlockTag:
2369         // We do not cache eval code blocks
2370         RELEASE_ASSERT_NOT_REACHED();
2371     }
2372     RELEASE_ASSERT_NOT_REACHED();
2373 #if COMPILER(MSVC)
2374     // Without this, MSVC will complain that this path does not return a value.
2375     return false;
2376 #endif
2377 }
2378 
2379 bool GenericCacheEntry::isStillValid(Decoder&amp; decoder, const SourceCodeKey&amp; key, CachedCodeBlockTag tag) const
2380 {
2381     if (!isUpToDate(decoder))
2382         return false;
2383 
2384     switch (tag) {
2385     case CachedProgramCodeBlockTag:
2386         return bitwise_cast&lt;const CacheEntry&lt;UnlinkedProgramCodeBlock&gt;*&gt;(this)-&gt;isStillValid(decoder, key);
2387     case CachedModuleCodeBlockTag:
2388         return bitwise_cast&lt;const CacheEntry&lt;UnlinkedModuleProgramCodeBlock&gt;*&gt;(this)-&gt;isStillValid(decoder, key);
2389     case CachedEvalCodeBlockTag:
2390         // We do not cache eval code blocks
2391         RELEASE_ASSERT_NOT_REACHED();
2392     }
2393     RELEASE_ASSERT_NOT_REACHED();
2394     return false;
2395 }
2396 
2397 template&lt;typename UnlinkedCodeBlockType&gt;
2398 void encodeCodeBlock(Encoder&amp; encoder, const SourceCodeKey&amp; key, const UnlinkedCodeBlock* codeBlock)
2399 {
2400     auto* entry = encoder.template malloc&lt;CacheEntry&lt;UnlinkedCodeBlockType&gt;&gt;(encoder);
2401     entry-&gt;encode(encoder, { key, jsCast&lt;const UnlinkedCodeBlockType*&gt;(codeBlock) });
2402 }
2403 
2404 RefPtr&lt;CachedBytecode&gt; encodeCodeBlock(VM&amp; vm, const SourceCodeKey&amp; key, const UnlinkedCodeBlock* codeBlock, FileSystem::PlatformFileHandle fd, BytecodeCacheError&amp; error)
2405 {
2406     const ClassInfo* classInfo = codeBlock-&gt;classInfo(vm);
2407 
2408     Encoder encoder(vm, fd);
2409     if (classInfo == UnlinkedProgramCodeBlock::info())
2410         encodeCodeBlock&lt;UnlinkedProgramCodeBlock&gt;(encoder, key, codeBlock);
2411     else if (classInfo == UnlinkedModuleProgramCodeBlock::info())
2412         encodeCodeBlock&lt;UnlinkedModuleProgramCodeBlock&gt;(encoder, key, codeBlock);
2413     else
2414         ASSERT(classInfo == UnlinkedEvalCodeBlock::info());
2415 
2416     return encoder.release(error);
2417 }
2418 
2419 RefPtr&lt;CachedBytecode&gt; encodeCodeBlock(VM&amp; vm, const SourceCodeKey&amp; key, const UnlinkedCodeBlock* codeBlock)
2420 {
2421     BytecodeCacheError error;
2422     return encodeCodeBlock(vm, key, codeBlock, FileSystem::invalidPlatformFileHandle, error);
2423 }
2424 
2425 RefPtr&lt;CachedBytecode&gt; encodeFunctionCodeBlock(VM&amp; vm, const UnlinkedFunctionCodeBlock* codeBlock, BytecodeCacheError&amp; error)
2426 {
2427     Encoder encoder(vm);
2428     encoder.malloc&lt;CachedFunctionCodeBlock&gt;()-&gt;encode(encoder, *codeBlock);
2429     return encoder.release(error);
2430 }
2431 
2432 UnlinkedCodeBlock* decodeCodeBlockImpl(VM&amp; vm, const SourceCodeKey&amp; key, Ref&lt;CachedBytecode&gt; cachedBytecode)
2433 {
2434     const auto* cachedEntry = bitwise_cast&lt;const GenericCacheEntry*&gt;(cachedBytecode-&gt;data());
2435     Ref&lt;Decoder&gt; decoder = Decoder::create(vm, WTFMove(cachedBytecode), &amp;key.source().provider());
2436     std::pair&lt;SourceCodeKey, UnlinkedCodeBlock*&gt; entry;
2437     {
2438         DeferGC deferGC(vm.heap);
2439         if (!cachedEntry-&gt;decode(decoder.get(), entry))
2440             return nullptr;
2441     }
2442 
2443     if (entry.first != key)
2444         return nullptr;
2445     return entry.second;
2446 }
2447 
2448 bool isCachedBytecodeStillValid(VM&amp; vm, Ref&lt;CachedBytecode&gt; cachedBytecode, const SourceCodeKey&amp; key, SourceCodeType type)
2449 {
2450     const void* buffer = cachedBytecode-&gt;data();
2451     size_t size = cachedBytecode-&gt;size();
2452     if (!size)
2453         return false;
2454     const auto* cachedEntry = bitwise_cast&lt;const GenericCacheEntry*&gt;(buffer);
2455     Ref&lt;Decoder&gt; decoder = Decoder::create(vm, WTFMove(cachedBytecode));
2456     return cachedEntry-&gt;isStillValid(decoder.get(), key, tagFromSourceCodeType(type));
2457 }
2458 
2459 void decodeFunctionCodeBlock(Decoder&amp; decoder, int32_t cachedFunctionCodeBlockOffset, WriteBarrier&lt;UnlinkedFunctionCodeBlock&gt;&amp; codeBlock, const JSCell* owner)
2460 {
2461     ASSERT(decoder.vm().heap.isDeferred());
2462     auto* cachedCodeBlock = static_cast&lt;const CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt;*&gt;(decoder.ptrForOffsetFromBase(cachedFunctionCodeBlockOffset));
2463     cachedCodeBlock-&gt;decode(decoder, codeBlock, owner);
2464 }
2465 
2466 } // namespace JSC
<a name="44" id="anc44"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="44" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/testair.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="opcode_generator.rb.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../testb3.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/testair.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2016-2018 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 
  28 #include &quot;AirCode.h&quot;
  29 #include &quot;AirGenerate.h&quot;
  30 #include &quot;AirInstInlines.h&quot;
  31 #include &quot;AirSpecial.h&quot;
  32 #include &quot;AllowMacroScratchRegisterUsage.h&quot;
  33 #include &quot;B3BasicBlockInlines.h&quot;
  34 #include &quot;B3Compilation.h&quot;
  35 #include &quot;B3Procedure.h&quot;
  36 #include &quot;B3PatchpointSpecial.h&quot;
  37 #include &quot;CCallHelpers.h&quot;
  38 #include &quot;InitializeThreading.h&quot;
  39 #include &quot;JSCInlines.h&quot;
  40 #include &quot;LinkBuffer.h&quot;

  41 #include &quot;PureNaN.h&quot;
  42 #include &lt;cmath&gt;

  43 #include &lt;string&gt;
  44 #include &lt;wtf/Lock.h&gt;
  45 #include &lt;wtf/NumberOfCores.h&gt;
  46 #include &lt;wtf/StdMap.h&gt;
  47 #include &lt;wtf/Threading.h&gt;
  48 #include &lt;wtf/text/StringCommon.h&gt;
  49 
  50 // We don&#39;t have a NO_RETURN_DUE_TO_EXIT, nor should we. That&#39;s ridiculous.
  51 static bool hiddenTruthBecauseNoReturnIsStupid() { return true; }
  52 
  53 static void usage()
  54 {
  55     dataLog(&quot;Usage: testair [&lt;filter&gt;]\n&quot;);
  56     if (hiddenTruthBecauseNoReturnIsStupid())
  57         exit(1);
  58 }
  59 
  60 #if ENABLE(B3_JIT)
  61 
  62 using namespace JSC;
</pre>
<hr />
<pre>
2046     CHECK(r == a + b);
2047 }
2048 
2049 void testLea32()
2050 {
2051     B3::Procedure proc;
2052     Code&amp; code = proc.code();
2053 
2054     BasicBlock* root = code.addBlock();
2055 
2056     int32_t a = 0x11223344;
2057     int32_t b = 1 &lt;&lt; 13;
2058 
2059     root-&gt;append(Lea32, nullptr, Arg::addr(Tmp(GPRInfo::argumentGPR0), b), Tmp(GPRInfo::returnValueGPR));
2060     root-&gt;append(Ret32, nullptr, Tmp(GPRInfo::returnValueGPR));
2061 
2062     int32_t r = compileAndRun&lt;int32_t&gt;(proc, a);
2063     CHECK(r == a + b);
2064 }
2065 




























































































































































2066 #define PREFIX &quot;O&quot;, Options::defaultB3OptLevel(), &quot;: &quot;
2067 
2068 #define RUN(test) do {                                 \
2069         if (!shouldRun(#test))                         \
2070             break;                                     \
2071         tasks.append(                                  \
2072             createSharedTask&lt;void()&gt;(                  \
2073                 [&amp;] () {                               \
2074                     dataLog(PREFIX #test &quot;...\n&quot;);     \
2075                     test;                              \
2076                     dataLog(PREFIX #test &quot;: OK!\n&quot;);   \
2077                 }));                                   \
2078     } while (false);
2079 
2080 void run(const char* filter)
2081 {
2082     Deque&lt;RefPtr&lt;SharedTask&lt;void()&gt;&gt;&gt; tasks;
2083 
2084     auto shouldRun = [&amp;] (const char* testName) -&gt; bool {
2085         return !filter || WTF::findIgnoringASCIICaseWithoutLength(testName, filter) != WTF::notFound;
</pre>
<hr />
<pre>
2134     RUN(testX86VMULSDDestRexAddr());
2135     RUN(testX86VMULSDRegOpDestRexAddr());
2136     RUN(testX86VMULSDAddrOpDestRexAddr());
2137 
2138     RUN(testX86VMULSDBaseNeedsRex());
2139     RUN(testX86VMULSDIndexNeedsRex());
2140     RUN(testX86VMULSDBaseIndexNeedRex());
2141 #endif
2142 
2143 #if CPU(ARM64)
2144     RUN(testInvalidateCachedTempRegisters());
2145 #endif
2146 
2147     RUN(testArgumentRegPinned());
2148     RUN(testArgumentRegPinned2());
2149     RUN(testArgumentRegPinned3());
2150 
2151     RUN(testLea32());
2152     RUN(testLea64());
2153 




2154     if (tasks.isEmpty())
2155         usage();
2156 
2157     Lock lock;
2158 
2159     Vector&lt;Ref&lt;Thread&gt;&gt; threads;
2160     for (unsigned i = filter ? 1 : WTF::numberOfProcessorCores(); i--;) {
2161         threads.append(
2162             Thread::create(
2163                 &quot;testair thread&quot;,
2164                 [&amp;] () {
2165                     for (;;) {
2166                         RefPtr&lt;SharedTask&lt;void()&gt;&gt; task;
2167                         {
2168                             LockHolder locker(lock);
2169                             if (tasks.isEmpty())
2170                                 return;
2171                             task = tasks.takeFirst();
2172                         }
2173 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 
  28 #include &quot;AirCode.h&quot;
  29 #include &quot;AirGenerate.h&quot;
  30 #include &quot;AirInstInlines.h&quot;
  31 #include &quot;AirSpecial.h&quot;
  32 #include &quot;AllowMacroScratchRegisterUsage.h&quot;
  33 #include &quot;B3BasicBlockInlines.h&quot;
  34 #include &quot;B3Compilation.h&quot;
  35 #include &quot;B3Procedure.h&quot;
  36 #include &quot;B3PatchpointSpecial.h&quot;
  37 #include &quot;CCallHelpers.h&quot;
  38 #include &quot;InitializeThreading.h&quot;
  39 #include &quot;JSCInlines.h&quot;
  40 #include &quot;LinkBuffer.h&quot;
<span class="line-added">  41 #include &quot;ProbeContext.h&quot;</span>
  42 #include &quot;PureNaN.h&quot;
  43 #include &lt;cmath&gt;
<span class="line-added">  44 #include &lt;regex&gt;</span>
  45 #include &lt;string&gt;
  46 #include &lt;wtf/Lock.h&gt;
  47 #include &lt;wtf/NumberOfCores.h&gt;
  48 #include &lt;wtf/StdMap.h&gt;
  49 #include &lt;wtf/Threading.h&gt;
  50 #include &lt;wtf/text/StringCommon.h&gt;
  51 
  52 // We don&#39;t have a NO_RETURN_DUE_TO_EXIT, nor should we. That&#39;s ridiculous.
  53 static bool hiddenTruthBecauseNoReturnIsStupid() { return true; }
  54 
  55 static void usage()
  56 {
  57     dataLog(&quot;Usage: testair [&lt;filter&gt;]\n&quot;);
  58     if (hiddenTruthBecauseNoReturnIsStupid())
  59         exit(1);
  60 }
  61 
  62 #if ENABLE(B3_JIT)
  63 
  64 using namespace JSC;
</pre>
<hr />
<pre>
2048     CHECK(r == a + b);
2049 }
2050 
2051 void testLea32()
2052 {
2053     B3::Procedure proc;
2054     Code&amp; code = proc.code();
2055 
2056     BasicBlock* root = code.addBlock();
2057 
2058     int32_t a = 0x11223344;
2059     int32_t b = 1 &lt;&lt; 13;
2060 
2061     root-&gt;append(Lea32, nullptr, Arg::addr(Tmp(GPRInfo::argumentGPR0), b), Tmp(GPRInfo::returnValueGPR));
2062     root-&gt;append(Ret32, nullptr, Tmp(GPRInfo::returnValueGPR));
2063 
2064     int32_t r = compileAndRun&lt;int32_t&gt;(proc, a);
2065     CHECK(r == a + b);
2066 }
2067 
<span class="line-added">2068 inline Vector&lt;String&gt; matchAll(const CString&amp; source, std::regex regex)</span>
<span class="line-added">2069 {</span>
<span class="line-added">2070     Vector&lt;String&gt; matches;</span>
<span class="line-added">2071     std::smatch match;</span>
<span class="line-added">2072     for (std::string str = source.data(); std::regex_search(str, match, regex); str = match.suffix()) {</span>
<span class="line-added">2073         ASSERT(match.size() == 1);</span>
<span class="line-added">2074         matches.append(match[0].str().c_str());</span>
<span class="line-added">2075     }</span>
<span class="line-added">2076     return matches;</span>
<span class="line-added">2077 }</span>
<span class="line-added">2078 </span>
<span class="line-added">2079 void testElideSimpleMove()</span>
<span class="line-added">2080 {</span>
<span class="line-added">2081     for (unsigned tmpCount = 1; tmpCount &lt; 100; tmpCount++) {</span>
<span class="line-added">2082         B3::Procedure proc;</span>
<span class="line-added">2083         Code&amp; code = proc.code();</span>
<span class="line-added">2084 </span>
<span class="line-added">2085         BasicBlock* root = code.addBlock();</span>
<span class="line-added">2086 </span>
<span class="line-added">2087         Tmp tmp = code.newTmp(B3::GP);</span>
<span class="line-added">2088         root-&gt;append(Move, nullptr, Tmp(GPRInfo::argumentGPR0), tmp);</span>
<span class="line-added">2089         for (unsigned i = 0; i &lt; tmpCount; i++) {</span>
<span class="line-added">2090             Tmp newTmp = code.newTmp(B3::GP);</span>
<span class="line-added">2091             root-&gt;append(Move, nullptr, tmp, newTmp);</span>
<span class="line-added">2092             tmp = newTmp;</span>
<span class="line-added">2093         }</span>
<span class="line-added">2094         root-&gt;append(Move, nullptr, tmp, Tmp(GPRInfo::returnValueGPR));</span>
<span class="line-added">2095         root-&gt;append(Ret32, nullptr, Tmp(GPRInfo::returnValueGPR));</span>
<span class="line-added">2096 </span>
<span class="line-added">2097         auto compilation = compile(proc);</span>
<span class="line-added">2098         CString disassembly = compilation-&gt;disassembly();</span>
<span class="line-added">2099         std::regex findRRMove(isARM64() ? &quot;mov r\\d+, r\\d+\\n&quot; : &quot;mov %\\w+, %\\w+\\n&quot;);</span>
<span class="line-added">2100         auto result = matchAll(disassembly, findRRMove);</span>
<span class="line-added">2101         // sp -&gt; fp; arg0 -&gt; ret0; fp -&gt; sp</span>
<span class="line-added">2102         // fp -&gt; sp only happens in O0 because we don&#39;t actually need to move the stack in general.</span>
<span class="line-added">2103         CHECK(result.size() == 2 + !Options::defaultB3OptLevel());</span>
<span class="line-added">2104     }</span>
<span class="line-added">2105 }</span>
<span class="line-added">2106 </span>
<span class="line-added">2107 void testElideHandlesEarlyClobber()</span>
<span class="line-added">2108 {</span>
<span class="line-added">2109     B3::Procedure proc;</span>
<span class="line-added">2110     Code&amp; code = proc.code();</span>
<span class="line-added">2111 </span>
<span class="line-added">2112     BasicBlock* root = code.addBlock();</span>
<span class="line-added">2113 </span>
<span class="line-added">2114     const unsigned tmpCount = RegisterSet::allGPRs().numberOfSetRegisters() * 2;</span>
<span class="line-added">2115     Vector&lt;Tmp&gt; tmps(tmpCount);</span>
<span class="line-added">2116     for (unsigned i = 0; i &lt; tmpCount; ++i) {</span>
<span class="line-added">2117         tmps[i] = code.newTmp(B3::GP);</span>
<span class="line-added">2118         root-&gt;append(Move, nullptr, Arg::imm(i), tmps[i]);</span>
<span class="line-added">2119     }</span>
<span class="line-added">2120 </span>
<span class="line-added">2121     RegisterSet registers = RegisterSet::allGPRs();</span>
<span class="line-added">2122     registers.exclude(RegisterSet::reservedHardwareRegisters());</span>
<span class="line-added">2123     registers.exclude(RegisterSet::stackRegisters());</span>
<span class="line-added">2124     Reg firstCalleeSave;</span>
<span class="line-added">2125     Reg lastCalleeSave;</span>
<span class="line-added">2126     auto* patch = proc.add&lt;B3::PatchpointValue&gt;(B3::Int32, B3::Origin());</span>
<span class="line-added">2127     patch-&gt;clobberEarly(registers);</span>
<span class="line-added">2128     for (Reg reg : registers) {</span>
<span class="line-added">2129         if (!firstCalleeSave)</span>
<span class="line-added">2130             firstCalleeSave = reg;</span>
<span class="line-added">2131         lastCalleeSave = reg;</span>
<span class="line-added">2132     }</span>
<span class="line-added">2133     ASSERT(firstCalleeSave != lastCalleeSave);</span>
<span class="line-added">2134     patch-&gt;earlyClobbered().clear(firstCalleeSave);</span>
<span class="line-added">2135     patch-&gt;resultConstraints.append({ B3::ValueRep::reg(firstCalleeSave) });</span>
<span class="line-added">2136     patch-&gt;earlyClobbered().clear(lastCalleeSave);</span>
<span class="line-added">2137     patch-&gt;clobber(RegisterSet(lastCalleeSave));</span>
<span class="line-added">2138 </span>
<span class="line-added">2139     patch-&gt;setGenerator([=] (CCallHelpers&amp; jit, const JSC::B3::StackmapGenerationParams&amp;) {</span>
<span class="line-added">2140         jit.probe([=] (Probe::Context&amp; context) {</span>
<span class="line-added">2141             for (Reg reg : registers)</span>
<span class="line-added">2142                 context.gpr(reg.gpr()) = 0;</span>
<span class="line-added">2143         });</span>
<span class="line-added">2144     });</span>
<span class="line-added">2145 </span>
<span class="line-added">2146     Inst inst(Patch, patch, Arg::special(code.addSpecial(WTF::makeUnique&lt;JSC::B3::PatchpointSpecial&gt;())));</span>
<span class="line-added">2147     inst.args.append(Tmp(firstCalleeSave));</span>
<span class="line-added">2148     root-&gt;appendInst(WTFMove(inst));</span>
<span class="line-added">2149 </span>
<span class="line-added">2150     Tmp result = code.newTmp(B3::GP);</span>
<span class="line-added">2151     root-&gt;append(Move, nullptr, tmps[0], result);</span>
<span class="line-added">2152     for (Tmp tmp : tmps)</span>
<span class="line-added">2153         root-&gt;append(Add32, nullptr, tmp, result);</span>
<span class="line-added">2154 </span>
<span class="line-added">2155     root-&gt;append(Move, nullptr, result, Tmp(GPRInfo::returnValueGPR));</span>
<span class="line-added">2156     root-&gt;append(Ret32, nullptr, Tmp(GPRInfo::returnValueGPR));</span>
<span class="line-added">2157 </span>
<span class="line-added">2158     auto runResult = compileAndRun&lt;uint32_t&gt;(proc);</span>
<span class="line-added">2159     CHECK(runResult == (tmpCount * (tmpCount - 1)) / 2);</span>
<span class="line-added">2160 }</span>
<span class="line-added">2161 </span>
<span class="line-added">2162 void testElideMoveThenRealloc()</span>
<span class="line-added">2163 {</span>
<span class="line-added">2164     RegisterSet registers = RegisterSet::allGPRs();</span>
<span class="line-added">2165     registers.exclude(RegisterSet::stackRegisters());</span>
<span class="line-added">2166     registers.exclude(RegisterSet::reservedHardwareRegisters());</span>
<span class="line-added">2167 </span>
<span class="line-added">2168     for (Reg reg : registers) {</span>
<span class="line-added">2169         B3::Procedure proc;</span>
<span class="line-added">2170         Code&amp; code = proc.code();</span>
<span class="line-added">2171 </span>
<span class="line-added">2172         BasicBlock* root = code.addBlock();</span>
<span class="line-added">2173         BasicBlock* taken = code.addBlock();</span>
<span class="line-added">2174         BasicBlock* notTaken = code.addBlock();</span>
<span class="line-added">2175         BasicBlock* notTakenReturn = code.addBlock();</span>
<span class="line-added">2176         BasicBlock* ret = code.addBlock();</span>
<span class="line-added">2177         BasicBlock* continuation = code.addBlock();</span>
<span class="line-added">2178 </span>
<span class="line-added">2179         Tmp tmp = code.newTmp(B3::GP);</span>
<span class="line-added">2180         {</span>
<span class="line-added">2181             root-&gt;append(Move, nullptr, Arg::imm(1), Tmp(reg));</span>
<span class="line-added">2182 </span>
<span class="line-added">2183             root-&gt;append(BranchTest32, nullptr, Arg::resCond(MacroAssembler::NonZero), Tmp(reg), Arg::bitImm(-1));</span>
<span class="line-added">2184             root-&gt;setSuccessors(taken, notTaken);</span>
<span class="line-added">2185         }</span>
<span class="line-added">2186 </span>
<span class="line-added">2187         {</span>
<span class="line-added">2188             taken-&gt;append(Jump, nullptr);</span>
<span class="line-added">2189             taken-&gt;setSuccessors(continuation);</span>
<span class="line-added">2190         }</span>
<span class="line-added">2191 </span>
<span class="line-added">2192         {</span>
<span class="line-added">2193             notTaken-&gt;append(BranchTest32, nullptr, Arg::resCond(MacroAssembler::NonZero), Tmp(reg), Arg::bitImm(-1));</span>
<span class="line-added">2194             notTaken-&gt;setSuccessors(continuation, notTakenReturn);</span>
<span class="line-added">2195         }</span>
<span class="line-added">2196 </span>
<span class="line-added">2197         {</span>
<span class="line-added">2198             tmp = code.newTmp(B3::GP);</span>
<span class="line-added">2199             continuation-&gt;append(Move, nullptr, Arg::imm(42), tmp);</span>
<span class="line-added">2200             continuation-&gt;append(BranchTest32, nullptr, Arg::resCond(MacroAssembler::NonZero), tmp, Arg::bitImm(-1));</span>
<span class="line-added">2201             continuation-&gt;setSuccessors(ret, notTakenReturn);</span>
<span class="line-added">2202         }</span>
<span class="line-added">2203 </span>
<span class="line-added">2204         {</span>
<span class="line-added">2205             tmp = code.newTmp(B3::GP);</span>
<span class="line-added">2206             ret-&gt;append(Move, nullptr, Arg::imm(42), tmp);</span>
<span class="line-added">2207             ret-&gt;append(Move, nullptr, tmp, Tmp(reg));</span>
<span class="line-added">2208             ret-&gt;append(Move, nullptr, Tmp(reg), Tmp(GPRInfo::returnValueGPR));</span>
<span class="line-added">2209             ret-&gt;append(Add32, nullptr, Tmp(reg), Tmp(reg));</span>
<span class="line-added">2210             ret-&gt;append(Ret32, nullptr, Tmp(GPRInfo::returnValueGPR));</span>
<span class="line-added">2211         }</span>
<span class="line-added">2212 </span>
<span class="line-added">2213         {</span>
<span class="line-added">2214             notTakenReturn-&gt;append(Move, nullptr, Tmp(reg), Tmp(GPRInfo::returnValueGPR));</span>
<span class="line-added">2215             notTakenReturn-&gt;append(Ret32, nullptr, Tmp(GPRInfo::returnValueGPR));</span>
<span class="line-added">2216         }</span>
<span class="line-added">2217 </span>
<span class="line-added">2218         code.resetReachability();</span>
<span class="line-added">2219         auto runResult = compileAndRun&lt;uint32_t&gt;(proc);</span>
<span class="line-added">2220         CHECK(runResult == static_cast&lt;unsigned&gt;(42 + (42 * (reg == GPRInfo::returnValueGPR))));</span>
<span class="line-added">2221     }</span>
<span class="line-added">2222 }</span>
<span class="line-added">2223 </span>
2224 #define PREFIX &quot;O&quot;, Options::defaultB3OptLevel(), &quot;: &quot;
2225 
2226 #define RUN(test) do {                                 \
2227         if (!shouldRun(#test))                         \
2228             break;                                     \
2229         tasks.append(                                  \
2230             createSharedTask&lt;void()&gt;(                  \
2231                 [&amp;] () {                               \
2232                     dataLog(PREFIX #test &quot;...\n&quot;);     \
2233                     test;                              \
2234                     dataLog(PREFIX #test &quot;: OK!\n&quot;);   \
2235                 }));                                   \
2236     } while (false);
2237 
2238 void run(const char* filter)
2239 {
2240     Deque&lt;RefPtr&lt;SharedTask&lt;void()&gt;&gt;&gt; tasks;
2241 
2242     auto shouldRun = [&amp;] (const char* testName) -&gt; bool {
2243         return !filter || WTF::findIgnoringASCIICaseWithoutLength(testName, filter) != WTF::notFound;
</pre>
<hr />
<pre>
2292     RUN(testX86VMULSDDestRexAddr());
2293     RUN(testX86VMULSDRegOpDestRexAddr());
2294     RUN(testX86VMULSDAddrOpDestRexAddr());
2295 
2296     RUN(testX86VMULSDBaseNeedsRex());
2297     RUN(testX86VMULSDIndexNeedsRex());
2298     RUN(testX86VMULSDBaseIndexNeedRex());
2299 #endif
2300 
2301 #if CPU(ARM64)
2302     RUN(testInvalidateCachedTempRegisters());
2303 #endif
2304 
2305     RUN(testArgumentRegPinned());
2306     RUN(testArgumentRegPinned2());
2307     RUN(testArgumentRegPinned3());
2308 
2309     RUN(testLea32());
2310     RUN(testLea64());
2311 
<span class="line-added">2312     RUN(testElideSimpleMove());</span>
<span class="line-added">2313     RUN(testElideHandlesEarlyClobber());</span>
<span class="line-added">2314     RUN(testElideMoveThenRealloc());</span>
<span class="line-added">2315 </span>
2316     if (tasks.isEmpty())
2317         usage();
2318 
2319     Lock lock;
2320 
2321     Vector&lt;Ref&lt;Thread&gt;&gt; threads;
2322     for (unsigned i = filter ? 1 : WTF::numberOfProcessorCores(); i--;) {
2323         threads.append(
2324             Thread::create(
2325                 &quot;testair thread&quot;,
2326                 [&amp;] () {
2327                     for (;;) {
2328                         RefPtr&lt;SharedTask&lt;void()&gt;&gt; task;
2329                         {
2330                             LockHolder locker(lock);
2331                             if (tasks.isEmpty())
2332                                 return;
2333                             task = tasks.takeFirst();
2334                         }
2335 
</pre>
</td>
</tr>
</table>
<center><a href="opcode_generator.rb.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../testb3.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
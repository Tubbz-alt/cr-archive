diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTextLineBoxes.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTextLineBoxes.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTextLineBoxes.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTextLineBoxes.cpp
@@ -144,41 +144,10 @@
     // we are now in the correct text run
     position = (offset > currentOffset ? current->len() : current->len() - (currentOffset - offset));
     return current;
 }
 
-IntRect RenderTextLineBoxes::boundingBox(const RenderText& renderer) const
-{
-    if (!m_first)
-        return IntRect();
-
-    // Return the width of the minimal left side and the maximal right side.
-    float logicalLeftSide = 0;
-    float logicalRightSide = 0;
-    for (auto* current = m_first; current; current = current->nextTextBox()) {
-        if (current == m_first || current->logicalLeft() < logicalLeftSide)
-            logicalLeftSide = current->logicalLeft();
-        if (current == m_first || current->logicalRight() > logicalRightSide)
-            logicalRightSide = current->logicalRight();
-    }
-
-    bool isHorizontal = renderer.style().isHorizontalWritingMode();
-
-    float x = isHorizontal ? logicalLeftSide : m_first->x();
-    float y = isHorizontal ? m_first->y() : logicalLeftSide;
-    float width = isHorizontal ? logicalRightSide - logicalLeftSide : m_last->logicalBottom() - x;
-    float height = isHorizontal ? m_last->logicalBottom() - y : logicalRightSide - logicalLeftSide;
-    return enclosingIntRect(FloatRect(x, y, width, height));
-}
-
-IntPoint RenderTextLineBoxes::firstRunLocation() const
-{
-    if (!m_first)
-        return IntPoint();
-    return IntPoint(m_first->topLeft());
-}
-
 LayoutRect RenderTextLineBoxes::visualOverflowBoundingBox(const RenderText& renderer) const
 {
     if (!m_first)
         return LayoutRect();
 
@@ -198,86 +167,21 @@
     if (!renderer.style().isHorizontalWritingMode())
         rect = rect.transposedRect();
     return rect;
 }
 
-bool RenderTextLineBoxes::hasRenderedText() const
-{
-    for (auto* box = m_first; box; box = box->nextTextBox()) {
-        if (box->len())
-            return true;
-    }
-    return false;
-}
-
-int RenderTextLineBoxes::caretMinOffset() const
-{
-    auto box = m_first;
-    if (!box)
-        return 0;
-    int minOffset = box->start();
-    for (box = box->nextTextBox(); box; box = box->nextTextBox())
-        minOffset = std::min<int>(minOffset, box->start());
-    return minOffset;
-}
-
-int RenderTextLineBoxes::caretMaxOffset(const RenderText& renderer) const
-{
-    auto box = m_last;
-    if (!box)
-        return renderer.text().length();
-
-    int maxOffset = box->start() + box->len();
-    for (box = box->prevTextBox(); box; box = box->prevTextBox())
-        maxOffset = std::max<int>(maxOffset, box->start() + box->len());
-    return maxOffset;
-}
-
-bool RenderTextLineBoxes::containsOffset(const RenderText& renderer, unsigned offset, OffsetType type) const
-{
-    for (auto* box = m_first; box; box = box->nextTextBox()) {
-        if (offset < box->start() && !renderer.containsReversedText())
-            return false;
-        unsigned boxEnd = box->start() + box->len();
-        if (offset >= box->start() && offset <= boxEnd) {
-            if (offset == boxEnd && (type == CharacterOffset || box->isLineBreak()))
-                continue;
-            if (type == CharacterOffset)
-                return true;
-            // Return false for offsets inside composed characters.
-            return !offset || offset == static_cast<unsigned>(renderer.nextOffset(renderer.previousOffset(offset)));
-        }
-    }
-    return false;
-}
-
-unsigned RenderTextLineBoxes::countCharacterOffsetsUntil(unsigned offset) const
-{
-    unsigned result = 0;
-    for (auto* box = m_first; box; box = box->nextTextBox()) {
-        if (offset < box->start())
-            return result;
-        if (offset <= box->start() + box->len()) {
-            result += offset - box->start();
-            return result;
-        }
-        result += box->len();
-    }
-    return result;
-}
-
 enum ShouldAffinityBeDownstream { AlwaysDownstream, AlwaysUpstream, UpstreamIfPositionIsNotAtStart };
 
 static bool lineDirectionPointFitsInBox(int pointLineDirection, const InlineTextBox& box, ShouldAffinityBeDownstream& shouldAffinityBeDownstream)
 {
     shouldAffinityBeDownstream = AlwaysDownstream;
 
     // the x coordinate is equal to the left edge of this box
     // the affinity must be downstream so the position doesn't jump back to the previous line
     // except when box is the first box in the line
     if (pointLineDirection <= box.logicalLeft()) {
-        shouldAffinityBeDownstream = !box.prevLeafChild() ? UpstreamIfPositionIsNotAtStart : AlwaysDownstream;
+        shouldAffinityBeDownstream = !box.previousLeafOnLine() ? UpstreamIfPositionIsNotAtStart : AlwaysDownstream;
         return true;
     }
 
 #if !PLATFORM(IOS_FAMILY)
     // and the x coordinate is to the left of the right edge of this box
@@ -288,14 +192,14 @@
     }
 #endif
 
     // box is first on line
     // and the x coordinate is to the left of the first text box left edge
-    if (!box.prevLeafChildIgnoringLineBreak() && pointLineDirection < box.logicalLeft())
+    if (!box.previousLeafOnLineIgnoringLineBreak() && pointLineDirection < box.logicalLeft())
         return true;
 
-    if (!box.nextLeafChildIgnoringLineBreak()) {
+    if (!box.nextLeafOnLineIgnoringLineBreak()) {
         // box is last on line
         // and the x coordinate is to the right of the last text box right edge
         // generate VisiblePosition, use UPSTREAM affinity if possible
         shouldAffinityBeDownstream = UpstreamIfPositionIsNotAtStart;
         return true;
@@ -330,63 +234,63 @@
 
     bool positionIsAtStartOfBox = !offset;
     if (positionIsAtStartOfBox == box.isLeftToRightDirection()) {
         // offset is on the left edge
 
-        const InlineBox* prevBox = box.prevLeafChildIgnoringLineBreak();
+        const InlineBox* prevBox = box.previousLeafOnLineIgnoringLineBreak();
         if ((prevBox && prevBox->bidiLevel() == box.bidiLevel())
             || box.renderer().containingBlock()->style().direction() == box.direction()) // FIXME: left on 12CBA
             return createVisiblePositionForBox(box, box.caretLeftmostOffset(), shouldAffinityBeDownstream);
 
         if (prevBox && prevBox->bidiLevel() > box.bidiLevel()) {
             // e.g. left of B in aDC12BAb
             const InlineBox* leftmostBox;
             do {
                 leftmostBox = prevBox;
-                prevBox = leftmostBox->prevLeafChildIgnoringLineBreak();
+                prevBox = leftmostBox->previousLeafOnLineIgnoringLineBreak();
             } while (prevBox && prevBox->bidiLevel() > box.bidiLevel());
             return createVisiblePositionForBox(*leftmostBox, leftmostBox->caretRightmostOffset(), shouldAffinityBeDownstream);
         }
 
         if (!prevBox || prevBox->bidiLevel() < box.bidiLevel()) {
             // e.g. left of D in aDC12BAb
             const InlineBox* rightmostBox;
             const InlineBox* nextBox = &box;
             do {
                 rightmostBox = nextBox;
-                nextBox = rightmostBox->nextLeafChildIgnoringLineBreak();
+                nextBox = rightmostBox->nextLeafOnLineIgnoringLineBreak();
             } while (nextBox && nextBox->bidiLevel() >= box.bidiLevel());
             return createVisiblePositionForBox(*rightmostBox,
                 box.isLeftToRightDirection() ? rightmostBox->caretMaxOffset() : rightmostBox->caretMinOffset(), shouldAffinityBeDownstream);
         }
 
         return createVisiblePositionForBox(box, box.caretRightmostOffset(), shouldAffinityBeDownstream);
     }
 
-    const InlineBox* nextBox = box.nextLeafChildIgnoringLineBreak();
+    const InlineBox* nextBox = box.nextLeafOnLineIgnoringLineBreak();
     if ((nextBox && nextBox->bidiLevel() == box.bidiLevel())
         || box.renderer().containingBlock()->style().direction() == box.direction())
         return createVisiblePositionForBox(box, box.caretRightmostOffset(), shouldAffinityBeDownstream);
 
     // offset is on the right edge
     if (nextBox && nextBox->bidiLevel() > box.bidiLevel()) {
         // e.g. right of C in aDC12BAb
         const InlineBox* rightmostBox;
         do {
             rightmostBox = nextBox;
-            nextBox = rightmostBox->nextLeafChildIgnoringLineBreak();
+            nextBox = rightmostBox->nextLeafOnLineIgnoringLineBreak();
         } while (nextBox && nextBox->bidiLevel() > box.bidiLevel());
         return createVisiblePositionForBox(*rightmostBox, rightmostBox->caretLeftmostOffset(), shouldAffinityBeDownstream);
     }
 
     if (!nextBox || nextBox->bidiLevel() < box.bidiLevel()) {
         // e.g. right of A in aDC12BAb
         const InlineBox* leftmostBox;
         const InlineBox* prevBox = &box;
         do {
             leftmostBox = prevBox;
-            prevBox = leftmostBox->prevLeafChildIgnoringLineBreak();
+            prevBox = leftmostBox->previousLeafOnLineIgnoringLineBreak();
         } while (prevBox && prevBox->bidiLevel() >= box.bidiLevel());
         return createVisiblePositionForBox(*leftmostBox,
             box.isLeftToRightDirection() ? leftmostBox->caretMinOffset() : leftmostBox->caretMaxOffset(), shouldAffinityBeDownstream);
     }
 
@@ -402,11 +306,11 @@
     LayoutUnit pointBlockDirection = m_first->isHorizontal() ? point.y() : point.x();
     bool blocksAreFlipped = renderer.style().isFlippedBlocksWritingMode();
 
     InlineTextBox* lastBox = nullptr;
     for (auto* box = m_first; box; box = box->nextTextBox()) {
-        if (box->isLineBreak() && !box->prevLeafChild() && box->nextLeafChild() && !box->nextLeafChild()->isLineBreak())
+        if (box->isLineBreak() && !box->previousLeafOnLine() && box->nextLeafOnLine() && !box->nextLeafOnLine()->isLineBreak())
             box = box->nextTextBox();
 
         auto& rootBox = box->root();
         LayoutUnit top = std::min(rootBox.selectionTop(), rootBox.lineTop());
         if (pointBlockDirection > top || (!blocksAreFlipped && pointBlockDirection == top)) {
@@ -444,12 +348,12 @@
         for (auto* box = m_first; box; box = box->nextTextBox())
             box->root().setHasSelectedChildren(state == RenderObject::SelectionInside);
         return;
     }
 
-    auto start = renderer.view().selection().startPosition();
-    auto end = renderer.view().selection().endPosition();
+    auto start = renderer.view().selection().startOffset();
+    auto end = renderer.view().selection().endOffset();
     if (state == RenderObject::SelectionStart) {
         end = renderer.text().length();
         // to handle selection from end of text to end of line
         if (start && start == end)
             start = end - 1;
@@ -503,21 +407,13 @@
         if (!rect.size().isEmpty())
             rects.append(rect);
     }
 }
 
-Vector<IntRect> RenderTextLineBoxes::absoluteRects(const LayoutPoint& accumulatedOffset) const
-{
-    Vector<IntRect> rects;
-    for (auto* box = m_first; box; box = box->nextTextBox())
-        rects.append(enclosingIntRect(FloatRect(accumulatedOffset + box->topLeft(), box->size())));
-    return rects;
-}
-
 static FloatRect localQuadForTextBox(const InlineTextBox& box, unsigned start, unsigned end, bool useSelectionHeight)
 {
-    unsigned realEnd = std::min(box.end() + 1, end);
+    unsigned realEnd = std::min(box.end(), end);
     LayoutRect boxSelectionRect = box.localSelectionRect(start, realEnd);
     if (!boxSelectionRect.height())
         return FloatRect();
     if (useSelectionHeight)
         return boxSelectionRect;
@@ -531,16 +427,17 @@
         boxSelectionRect.setX(box.x());
     }
     return boxSelectionRect;
 }
 
-Vector<IntRect> RenderTextLineBoxes::absoluteRectsForRange(const RenderText& renderer, unsigned start, unsigned end, bool useSelectionHeight, bool* wasFixed) const
+Vector<FloatQuad> RenderTextLineBoxes::absoluteQuadsForRange(const RenderText& renderer, unsigned start, unsigned end, bool useSelectionHeight, bool ignoreEmptyTextSelections, bool* wasFixed) const
 {
-    Vector<IntRect> rects;
+    Vector<FloatQuad> quads;
     for (auto* box = m_first; box; box = box->nextTextBox()) {
-        // Note: box->end() returns the index of the last character, not the index past it
-        if (start <= box->start() && box->end() < end) {
+        if (ignoreEmptyTextSelections && !box->isSelected(start, end))
+            continue;
+        if (start <= box->start() && box->end() <= end) {
             FloatRect boundaries = box->calculateBoundaries();
             if (useSelectionHeight) {
                 LayoutRect selectionRect = box->localSelectionRect(start, end);
                 if (box->isHorizontal()) {
                     boundaries.setHeight(selectionRect.height());
@@ -548,18 +445,23 @@
                 } else {
                     boundaries.setWidth(selectionRect.width());
                     boundaries.setX(selectionRect.x());
                 }
             }
-            rects.append(renderer.localToAbsoluteQuad(boundaries, UseTransforms, wasFixed).enclosingBoundingBox());
+            quads.append(renderer.localToAbsoluteQuad(boundaries, UseTransforms, wasFixed));
             continue;
         }
         FloatRect rect = localQuadForTextBox(*box, start, end, useSelectionHeight);
         if (!rect.isZero())
-            rects.append(renderer.localToAbsoluteQuad(rect, UseTransforms, wasFixed).enclosingBoundingBox());
+            quads.append(renderer.localToAbsoluteQuad(rect, UseTransforms, wasFixed));
     }
-    return rects;
+    return quads;
+}
+
+Vector<IntRect> RenderTextLineBoxes::absoluteRectsForRange(const RenderText& renderer, unsigned start, unsigned end, bool useSelectionHeight, bool* wasFixed) const
+{
+    return absoluteQuadsForRange(renderer, start, end, useSelectionHeight, false /* ignoreEmptyTextSelections */, wasFixed).map([](auto& quad) { return quad.enclosingBoundingBox(); });
 }
 
 Vector<FloatQuad> RenderTextLineBoxes::absoluteQuads(const RenderText& renderer, bool* wasFixed, ClippingOption option) const
 {
     Vector<FloatQuad> quads;
@@ -578,37 +480,10 @@
         quads.append(renderer.localToAbsoluteQuad(boundaries, UseTransforms, wasFixed));
     }
     return quads;
 }
 
-Vector<FloatQuad> RenderTextLineBoxes::absoluteQuadsForRange(const RenderText& renderer, unsigned start, unsigned end, bool useSelectionHeight, bool* wasFixed) const
-{
-    Vector<FloatQuad> quads;
-    for (auto* box = m_first; box; box = box->nextTextBox()) {
-        // Note: box->end() returns the index of the last character, not the index past it
-        if (start <= box->start() && box->end() < end) {
-            FloatRect boundaries = box->calculateBoundaries();
-            if (useSelectionHeight) {
-                LayoutRect selectionRect = box->localSelectionRect(start, end);
-                if (box->isHorizontal()) {
-                    boundaries.setHeight(selectionRect.height());
-                    boundaries.setY(selectionRect.y());
-                } else {
-                    boundaries.setWidth(selectionRect.width());
-                    boundaries.setX(selectionRect.x());
-                }
-            }
-            quads.append(renderer.localToAbsoluteQuad(boundaries, UseTransforms, wasFixed));
-            continue;
-        }
-        FloatRect rect = localQuadForTextBox(*box, start, end, useSelectionHeight);
-        if (!rect.isZero())
-            quads.append(renderer.localToAbsoluteQuad(rect, UseTransforms, wasFixed));
-    }
-    return quads;
-}
-
 void RenderTextLineBoxes::dirtyAll()
 {
     for (auto* box = m_first; box; box = box->nextTextBox())
         box->dirtyLineBoxes();
 }
@@ -621,14 +496,14 @@
     // Dirty all text boxes that include characters in between offset and offset+len.
     bool dirtiedLines = false;
     for (auto* current = m_first; current; current = current->nextTextBox()) {
         // FIXME: This shouldn't rely on the end of a dirty line box. See https://bugs.webkit.org/show_bug.cgi?id=97264
         // Text run is entirely before the affected range.
-        if (current->end() < start)
+        if (current->end() <= start)
             continue;
         // Text run is entirely after the affected range.
-        if (current->start() > end) {
+        if (current->start() >= end) {
             current->offsetRun(lengthDelta);
             auto& rootBox = current->root();
             if (!firstRootBox) {
                 firstRootBox = &rootBox;
                 if (!dirtiedLines) {
@@ -638,11 +513,11 @@
                 }
             }
             lastRootBox = &rootBox;
             continue;
         }
-        if (current->end() >= start && current->end() <= end) {
+        if (current->end() > start && current->end() <= end) {
             // Text run overlaps with the left end of the affected range.
             current->dirtyLineBoxes();
             dirtiedLines = true;
             continue;
         }
@@ -650,11 +525,11 @@
             // Text run subsumes the affected range.
             current->dirtyLineBoxes();
             dirtiedLines = true;
             continue;
         }
-        if (current->start() <= end && current->end() >= end) {
+        if (current->start() < end && current->end() >= end) {
             // Text run overlaps with right end of the affected range.
             current->dirtyLineBoxes();
             dirtiedLines = true;
             continue;
         }
@@ -687,24 +562,24 @@
     return dirtiedLines;
 }
 
 inline void RenderTextLineBoxes::checkConsistency() const
 {
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
 #ifdef CHECK_CONSISTENCY
     const InlineTextBox* prev = nullptr;
     for (auto* child = m_first; child; child = child->nextTextBox()) {
         ASSERT(child->renderer() == this);
         ASSERT(child->prevTextBox() == prev);
         prev = child;
     }
     ASSERT(prev == m_last);
 #endif
-#endif
+#endif // ASSERT_ENABLED
 }
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
 RenderTextLineBoxes::~RenderTextLineBoxes()
 {
     ASSERT(!m_first);
     ASSERT(!m_last);
 }

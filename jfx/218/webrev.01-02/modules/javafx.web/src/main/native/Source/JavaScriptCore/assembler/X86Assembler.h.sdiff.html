<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/X86Assembler.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ProbeStack.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="X86Registers.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/X86Assembler.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2008-2018 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
3935     }
3936 
3937     static void* getRelocatedAddress(void* code, AssemblerLabel label)
3938     {
3939         ASSERT(label.isSet());
3940         return reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;ptrdiff_t&gt;(code) + label.m_offset);
3941     }
3942 
3943     static int getDifferenceBetweenLabels(AssemblerLabel a, AssemblerLabel b)
3944     {
3945         return b.m_offset - a.m_offset;
3946     }
3947 
3948     unsigned debugOffset() { return m_formatter.debugOffset(); }
3949 
3950     void nop()
3951     {
3952         m_formatter.oneByteOp(OP_NOP);
3953     }
3954 
<span class="line-modified">3955     template &lt;typename CopyFunction&gt;</span>
<span class="line-modified">3956     static void fillNops(void* base, size_t size, CopyFunction copy)</span>


3957     {
3958         UNUSED_PARAM(copy);
3959 #if CPU(X86_64)
3960         static const uint8_t nops[10][10] = {
3961             // nop
3962             {0x90},
3963             // xchg %ax,%ax
3964             {0x66, 0x90},
3965             // nopl (%[re]ax)
3966             {0x0f, 0x1f, 0x00},
3967             // nopl 8(%[re]ax)
3968             {0x0f, 0x1f, 0x40, 0x08},
3969             // nopl 8(%[re]ax,%[re]ax,1)
3970             {0x0f, 0x1f, 0x44, 0x00, 0x08},
3971             // nopw 8(%[re]ax,%[re]ax,1)
3972             {0x66, 0x0f, 0x1f, 0x44, 0x00, 0x08},
3973             // nopl 512(%[re]ax)
3974             {0x0f, 0x1f, 0x80, 0x00, 0x02, 0x00, 0x00},
3975             // nopl 512(%[re]ax,%[re]ax,1)
3976             {0x0f, 0x1f, 0x84, 0x00, 0x00, 0x02, 0x00, 0x00},
</pre>
<hr />
<pre>
4010 
4011     static void setInt32(void* where, int32_t value)
4012     {
4013         WTF::unalignedStore&lt;int32_t&gt;(bitwise_cast&lt;int32_t*&gt;(where) - 1, value);
4014     }
4015 
4016     static void setInt8(void* where, int8_t value)
4017     {
4018         WTF::unalignedStore&lt;int8_t&gt;(bitwise_cast&lt;int8_t*&gt;(where) - 1, value);
4019     }
4020 
4021     static void setRel32(void* from, void* to)
4022     {
4023         intptr_t offset = reinterpret_cast&lt;intptr_t&gt;(to) - reinterpret_cast&lt;intptr_t&gt;(from);
4024         ASSERT(offset == static_cast&lt;int32_t&gt;(offset));
4025 
4026         setInt32(from, offset);
4027     }
4028 
4029     class X86InstructionFormatter {
<span class="line-modified">4030         static const int maxInstructionSize = 16;</span>
4031 
4032     public:
4033         enum ModRmMode {
4034             ModRmMemoryNoDisp = 0,
4035             ModRmMemoryDisp8 = 1 &lt;&lt; 6,
4036             ModRmMemoryDisp32 = 2 &lt;&lt; 6,
4037             ModRmRegister = 3 &lt;&lt; 6,
4038         };
4039 
4040         // Legacy prefix bytes:
4041         //
4042         // These are emmitted prior to the instruction.
4043 
4044         void prefix(OneByteOpcodeID pre)
4045         {
4046             m_buffer.putByte(pre);
4047         }
4048 
4049 #if CPU(X86_64)
4050         // Byte operand register spl &amp; above require a REX prefix (to prevent the &#39;H&#39; registers be accessed).
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
3935     }
3936 
3937     static void* getRelocatedAddress(void* code, AssemblerLabel label)
3938     {
3939         ASSERT(label.isSet());
3940         return reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;ptrdiff_t&gt;(code) + label.m_offset);
3941     }
3942 
3943     static int getDifferenceBetweenLabels(AssemblerLabel a, AssemblerLabel b)
3944     {
3945         return b.m_offset - a.m_offset;
3946     }
3947 
3948     unsigned debugOffset() { return m_formatter.debugOffset(); }
3949 
3950     void nop()
3951     {
3952         m_formatter.oneByteOp(OP_NOP);
3953     }
3954 
<span class="line-modified">3955     using CopyFunction = void*(&amp;)(void*, const void*, size_t);</span>
<span class="line-modified">3956 </span>
<span class="line-added">3957     template &lt;CopyFunction copy&gt;</span>
<span class="line-added">3958     static void fillNops(void* base, size_t size)</span>
3959     {
3960         UNUSED_PARAM(copy);
3961 #if CPU(X86_64)
3962         static const uint8_t nops[10][10] = {
3963             // nop
3964             {0x90},
3965             // xchg %ax,%ax
3966             {0x66, 0x90},
3967             // nopl (%[re]ax)
3968             {0x0f, 0x1f, 0x00},
3969             // nopl 8(%[re]ax)
3970             {0x0f, 0x1f, 0x40, 0x08},
3971             // nopl 8(%[re]ax,%[re]ax,1)
3972             {0x0f, 0x1f, 0x44, 0x00, 0x08},
3973             // nopw 8(%[re]ax,%[re]ax,1)
3974             {0x66, 0x0f, 0x1f, 0x44, 0x00, 0x08},
3975             // nopl 512(%[re]ax)
3976             {0x0f, 0x1f, 0x80, 0x00, 0x02, 0x00, 0x00},
3977             // nopl 512(%[re]ax,%[re]ax,1)
3978             {0x0f, 0x1f, 0x84, 0x00, 0x00, 0x02, 0x00, 0x00},
</pre>
<hr />
<pre>
4012 
4013     static void setInt32(void* where, int32_t value)
4014     {
4015         WTF::unalignedStore&lt;int32_t&gt;(bitwise_cast&lt;int32_t*&gt;(where) - 1, value);
4016     }
4017 
4018     static void setInt8(void* where, int8_t value)
4019     {
4020         WTF::unalignedStore&lt;int8_t&gt;(bitwise_cast&lt;int8_t*&gt;(where) - 1, value);
4021     }
4022 
4023     static void setRel32(void* from, void* to)
4024     {
4025         intptr_t offset = reinterpret_cast&lt;intptr_t&gt;(to) - reinterpret_cast&lt;intptr_t&gt;(from);
4026         ASSERT(offset == static_cast&lt;int32_t&gt;(offset));
4027 
4028         setInt32(from, offset);
4029     }
4030 
4031     class X86InstructionFormatter {
<span class="line-modified">4032         static constexpr int maxInstructionSize = 16;</span>
4033 
4034     public:
4035         enum ModRmMode {
4036             ModRmMemoryNoDisp = 0,
4037             ModRmMemoryDisp8 = 1 &lt;&lt; 6,
4038             ModRmMemoryDisp32 = 2 &lt;&lt; 6,
4039             ModRmRegister = 3 &lt;&lt; 6,
4040         };
4041 
4042         // Legacy prefix bytes:
4043         //
4044         // These are emmitted prior to the instruction.
4045 
4046         void prefix(OneByteOpcodeID pre)
4047         {
4048             m_buffer.putByte(pre);
4049         }
4050 
4051 #if CPU(X86_64)
4052         // Byte operand register spl &amp; above require a REX prefix (to prevent the &#39;H&#39; registers be accessed).
</pre>
</td>
</tr>
</table>
<center><a href="ProbeStack.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="X86Registers.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGValidate.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGUseKind.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGVarargsForwardingPhase.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGValidate.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -284,10 +284,15 @@</span>
                      break;
                  case CompareEqPtr:
                      VALIDATE((node), !!node-&gt;child1());
                      VALIDATE((node), !!node-&gt;cellOperand()-&gt;value() &amp;&amp; node-&gt;cellOperand()-&gt;value().isCell());
                      break;
<span class="udiff-line-added">+                 case CheckArrayOrEmpty:</span>
<span class="udiff-line-added">+                     VALIDATE((node), is64Bit());</span>
<span class="udiff-line-added">+                     VALIDATE((node), !!node-&gt;child1());</span>
<span class="udiff-line-added">+                     VALIDATE((node), node-&gt;child1().useKind() == CellUse);</span>
<span class="udiff-line-added">+                     break;</span>
                  case CheckStructureOrEmpty:
                      VALIDATE((node), is64Bit());
                      VALIDATE((node), !!node-&gt;child1());
                      VALIDATE((node), node-&gt;child1().useKind() == CellUse);
                      break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -471,21 +476,21 @@</span>
                  HashSet&lt;Node*&gt; seenNodes;
                  for (size_t i = 0; i &lt; block-&gt;size(); ++i) {
                      Node* node = block-&gt;at(i);
                      m_graph.doToChildren(node, [&amp;] (const Edge&amp; edge) {
                          Node* child = edge.node();
<span class="udiff-line-modified-removed">-                         VALIDATE((node), block-&gt;isInPhis(child) || seenNodes.contains(child));</span>
<span class="udiff-line-modified-added">+                         VALIDATE((node, edge), block-&gt;isInPhis(child) || seenNodes.contains(child));</span>
                      });
                      seenNodes.add(node);
                  }
              }
  
              for (size_t i = 0; i &lt; block-&gt;phis.size(); ++i) {
                  Node* node = block-&gt;phis[i];
                  ASSERT(phisInThisBlock.contains(node));
                  VALIDATE((node), node-&gt;op() == Phi);
<span class="udiff-line-modified-removed">-                 VirtualRegister local = node-&gt;local();</span>
<span class="udiff-line-modified-added">+                 Operand operand = node-&gt;operand();</span>
                  for (unsigned j = 0; j &lt; m_graph.numChildren(node); ++j) {
                      // Phi children in LoadStore form are invalid.
                      if (m_graph.m_form == LoadStore &amp;&amp; block-&gt;isPhiIndex(i))
                          continue;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -517,56 +522,52 @@</span>
                      // its tail variables.
                      bool found = false;
                      for (unsigned k = 0; k &lt; block-&gt;predecessors.size(); ++k) {
                          BasicBlock* prevBlock = block-&gt;predecessors[k];
                          VALIDATE((block-&gt;predecessors[k]), prevBlock);
<span class="udiff-line-modified-removed">-                         Node* prevNode = prevBlock-&gt;variablesAtTail.operand(local);</span>
<span class="udiff-line-modified-added">+                         Node* prevNode = prevBlock-&gt;variablesAtTail.operand(operand);</span>
                          // If we have a Phi that is not referring to *this* block then all predecessors
                          // must have that local available.
<span class="udiff-line-modified-removed">-                         VALIDATE((local, block, block-&gt;predecessors[k]), prevNode);</span>
<span class="udiff-line-modified-added">+                         VALIDATE((operand, block, block-&gt;predecessors[k]), prevNode);</span>
                          switch (prevNode-&gt;op()) {
                          case GetLocal:
                          case Flush:
                          case PhantomLocal:
                              prevNode = prevNode-&gt;child1().node();
                              break;
                          default:
                              break;
                          }
                          if (node-&gt;shouldGenerate()) {
<span class="udiff-line-modified-removed">-                             VALIDATE((local, block-&gt;predecessors[k], prevNode),</span>
<span class="udiff-line-modified-added">+                             VALIDATE((operand, block-&gt;predecessors[k], prevNode),</span>
                                       prevNode-&gt;shouldGenerate());
                          }
                          VALIDATE(
<span class="udiff-line-modified-removed">-                             (local, block-&gt;predecessors[k], prevNode),</span>
<span class="udiff-line-modified-added">+                             (operand, block-&gt;predecessors[k], prevNode),</span>
                              prevNode-&gt;op() == SetLocal
                              || prevNode-&gt;op() == SetArgumentDefinitely
                              || prevNode-&gt;op() == SetArgumentMaybe
                              || prevNode-&gt;op() == Phi);
                          if (prevNode == edge.node()) {
                              found = true;
                              break;
                          }
                          // At this point it cannot refer into this block.
<span class="udiff-line-modified-removed">-                         VALIDATE((local, block-&gt;predecessors[k], prevNode), !prevBlock-&gt;isInBlock(edge.node()));</span>
<span class="udiff-line-modified-added">+                         VALIDATE((operand, block-&gt;predecessors[k], prevNode), !prevBlock-&gt;isInBlock(edge.node()));</span>
                      }
  
                      VALIDATE((node, edge), found);
                  }
              }
  
<span class="udiff-line-modified-removed">-             Operands&lt;size_t&gt; getLocalPositions(</span>
<span class="udiff-line-modified-removed">-                 block-&gt;variablesAtHead.numberOfArguments(),</span>
<span class="udiff-line-removed">-                 block-&gt;variablesAtHead.numberOfLocals());</span>
<span class="udiff-line-removed">-             Operands&lt;size_t&gt; setLocalPositions(</span>
<span class="udiff-line-removed">-                 block-&gt;variablesAtHead.numberOfArguments(),</span>
<span class="udiff-line-removed">-                 block-&gt;variablesAtHead.numberOfLocals());</span>
<span class="udiff-line-modified-added">+             Operands&lt;size_t&gt; getLocalPositions(OperandsLike, block-&gt;variablesAtHead);</span>
<span class="udiff-line-modified-added">+             Operands&lt;size_t&gt; setLocalPositions(OperandsLike, block-&gt;variablesAtHead);</span>
  
              for (size_t i = 0; i &lt; block-&gt;variablesAtHead.numberOfArguments(); ++i) {
<span class="udiff-line-modified-removed">-                 VALIDATE((virtualRegisterForArgument(i), block), !block-&gt;variablesAtHead.argument(i) || block-&gt;variablesAtHead.argument(i)-&gt;accessesStack(m_graph));</span>
<span class="udiff-line-modified-added">+                 VALIDATE((virtualRegisterForArgumentIncludingThis(i), block), !block-&gt;variablesAtHead.argument(i) || block-&gt;variablesAtHead.argument(i)-&gt;accessesStack(m_graph));</span>
                  if (m_graph.m_form == ThreadedCPS)
<span class="udiff-line-modified-removed">-                     VALIDATE((virtualRegisterForArgument(i), block), !block-&gt;variablesAtTail.argument(i) || block-&gt;variablesAtTail.argument(i)-&gt;accessesStack(m_graph));</span>
<span class="udiff-line-modified-added">+                     VALIDATE((virtualRegisterForArgumentIncludingThis(i), block), !block-&gt;variablesAtTail.argument(i) || block-&gt;variablesAtTail.argument(i)-&gt;accessesStack(m_graph));</span>
  
                  getLocalPositions.argument(i) = notSet;
                  setLocalPositions.argument(i) = notSet;
              }
              for (size_t i = 0; i &lt; block-&gt;variablesAtHead.numberOfLocals(); ++i) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -666,28 +667,28 @@</span>
                      // Ignore GetLocal&#39;s that we know to be dead, but that the graph
                      // doesn&#39;t yet know to be dead.
                      if (!m_myRefCounts.get(node))
                          break;
                      if (m_graph.m_form == ThreadedCPS) {
<span class="udiff-line-modified-removed">-                         VALIDATE((node, block), getLocalPositions.operand(node-&gt;local()) == notSet);</span>
<span class="udiff-line-modified-added">+                         VALIDATE((node, block), getLocalPositions.operand(node-&gt;operand()) == notSet);</span>
                          VALIDATE((node, block), !!node-&gt;child1());
                          VALIDATE((node, block), node-&gt;child1()-&gt;op() == SetArgumentDefinitely || node-&gt;child1()-&gt;op() == Phi);
                      }
<span class="udiff-line-modified-removed">-                     getLocalPositions.operand(node-&gt;local()) = i;</span>
<span class="udiff-line-modified-added">+                     getLocalPositions.operand(node-&gt;operand()) = i;</span>
                      break;
                  case SetLocal:
                      // Only record the first SetLocal. There may be multiple SetLocals
                      // because of flushing.
<span class="udiff-line-modified-removed">-                     if (setLocalPositions.operand(node-&gt;local()) != notSet)</span>
<span class="udiff-line-modified-added">+                     if (setLocalPositions.operand(node-&gt;operand()) != notSet)</span>
                          break;
<span class="udiff-line-modified-removed">-                     setLocalPositions.operand(node-&gt;local()) = i;</span>
<span class="udiff-line-modified-added">+                     setLocalPositions.operand(node-&gt;operand()) = i;</span>
                      break;
                  case SetArgumentDefinitely:
                      // This acts like a reset. It&#39;s ok to have a second GetLocal for a local in the same
                      // block if we had a SetArgumentDefinitely for that local.
<span class="udiff-line-modified-removed">-                     getLocalPositions.operand(node-&gt;local()) = notSet;</span>
<span class="udiff-line-modified-removed">-                     setLocalPositions.operand(node-&gt;local()) = notSet;</span>
<span class="udiff-line-modified-added">+                     getLocalPositions.operand(node-&gt;operand()) = notSet;</span>
<span class="udiff-line-modified-added">+                     setLocalPositions.operand(node-&gt;operand()) = notSet;</span>
                      break;
                  case SetArgumentMaybe:
                      break;
                  case Flush:
                  case PhantomLocal:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -709,11 +710,11 @@</span>
              if (m_graph.m_form == LoadStore)
                  continue;
  
              for (size_t i = 0; i &lt; block-&gt;variablesAtHead.numberOfArguments(); ++i) {
                  checkOperand(
<span class="udiff-line-modified-removed">-                     block, getLocalPositions, setLocalPositions, virtualRegisterForArgument(i));</span>
<span class="udiff-line-modified-added">+                     block, getLocalPositions, setLocalPositions, virtualRegisterForArgumentIncludingThis(i));</span>
              }
              for (size_t i = 0; i &lt; block-&gt;variablesAtHead.numberOfLocals(); ++i) {
                  checkOperand(
                      block, getLocalPositions, setLocalPositions, virtualRegisterForLocal(i));
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -757,11 +758,11 @@</span>
                      break;
                  case SetArgumentMaybe:
                      VALIDATE((node), !&quot;Should not reach SetArgumentMaybe. GetLocal that has data flow that reaches a SetArgumentMaybe is invalid IR.&quot;);
                      break;
                  default:
<span class="udiff-line-modified-removed">-                     VALIDATE((node), !&quot;Unexecpted node type.&quot;);</span>
<span class="udiff-line-modified-added">+                     VALIDATE((node), !&quot;Unexpected node type.&quot;);</span>
                      break;
                  }
              }
          }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -778,11 +779,11 @@</span>
  
          m_graph.initializeNodeOwners();
  
          auto&amp; dominators = m_graph.ensureSSADominators();
  
<span class="udiff-line-modified-removed">-         for (unsigned entrypointIndex : m_graph.m_entrypointIndexToCatchBytecodeOffset.keys())</span>
<span class="udiff-line-modified-added">+         for (unsigned entrypointIndex : m_graph.m_entrypointIndexToCatchBytecodeIndex.keys())</span>
              VALIDATE((), entrypointIndex &gt; 0); // By convention, 0 is the entrypoint index for the op_enter entrypoint, which can not be in a catch.
  
          for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
              BasicBlock* block = m_graph.block(blockIndex);
              if (!block)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -966,30 +967,30 @@</span>
      void reportValidationContext(Node* node, Edge edge)
      {
          dataLog(node, &quot; -&gt; &quot;, edge);
      }
  
<span class="udiff-line-modified-removed">-     void reportValidationContext(VirtualRegister local, BasicBlock* block)</span>
<span class="udiff-line-modified-added">+     void reportValidationContext(Operand operand, BasicBlock* block)</span>
      {
          if (!block) {
<span class="udiff-line-modified-removed">-             dataLog(local, &quot; in null Block &quot;);</span>
<span class="udiff-line-modified-added">+             dataLog(operand, &quot; in null Block &quot;);</span>
              return;
          }
  
<span class="udiff-line-modified-removed">-         dataLog(local, &quot; in Block &quot;, *block);</span>
<span class="udiff-line-modified-added">+         dataLog(operand, &quot; in Block &quot;, *block);</span>
      }
  
      void reportValidationContext(
<span class="udiff-line-modified-removed">-         VirtualRegister local, BasicBlock* sourceBlock, BasicBlock* destinationBlock)</span>
<span class="udiff-line-modified-added">+         Operand operand, BasicBlock* sourceBlock, BasicBlock* destinationBlock)</span>
      {
<span class="udiff-line-modified-removed">-         dataLog(local, &quot; in Block &quot;, *sourceBlock, &quot; -&gt; &quot;, *destinationBlock);</span>
<span class="udiff-line-modified-added">+         dataLog(operand, &quot; in Block &quot;, *sourceBlock, &quot; -&gt; &quot;, *destinationBlock);</span>
      }
  
      void reportValidationContext(
<span class="udiff-line-modified-removed">-         VirtualRegister local, BasicBlock* sourceBlock, Node* prevNode)</span>
<span class="udiff-line-modified-added">+         Operand operand, BasicBlock* sourceBlock, Node* prevNode)</span>
      {
<span class="udiff-line-modified-removed">-         dataLog(prevNode, &quot; for &quot;, local, &quot; in Block &quot;, *sourceBlock);</span>
<span class="udiff-line-modified-added">+         dataLog(prevNode, &quot; for &quot;, operand, &quot; in Block &quot;, *sourceBlock);</span>
      }
  
      void reportValidationContext(Node* node, BasicBlock* block)
      {
          dataLog(node, &quot; in Block &quot;, *block);
</pre>
<center><a href="DFGUseKind.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGVarargsForwardingPhase.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/dom/ShadowRoot.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011 Google Inc. All rights reserved.
  3  * Copyright (C) 2015 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Neither the name of Google Inc. nor the names of its
 12  * contributors may be used to endorse or promote products derived from
 13  * this software without specific prior written permission.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 16  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 17  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 18  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 19  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 20  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 21  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 22  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 23  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;ShadowRoot.h&quot;
 30 
 31 #include &quot;CSSStyleSheet.h&quot;
 32 #include &quot;ElementTraversal.h&quot;
 33 #include &quot;HTMLParserIdioms.h&quot;
 34 #include &quot;HTMLSlotElement.h&quot;
 35 #if ENABLE(PICTURE_IN_PICTURE_API)
 36 #include &quot;NotImplemented.h&quot;
 37 #endif
 38 #include &quot;RenderElement.h&quot;
 39 #include &quot;RuntimeEnabledFeatures.h&quot;
 40 #include &quot;SlotAssignment.h&quot;
 41 #include &quot;StyleResolver.h&quot;
 42 #include &quot;StyleScope.h&quot;
 43 #include &quot;StyleSheetList.h&quot;
 44 #include &quot;markup.h&quot;
 45 #include &lt;wtf/IsoMallocInlines.h&gt;
 46 
 47 namespace WebCore {
 48 
 49 WTF_MAKE_ISO_ALLOCATED_IMPL(ShadowRoot);
 50 
 51 struct SameSizeAsShadowRoot : public DocumentFragment, public TreeScope {
 52     bool flags[4];
 53     uint8_t mode;
 54     void* styleScope;
 55     void* styleSheetList;
 56     void* host;
 57     void* slotAssignment;
 58     Optional&lt;HashMap&lt;AtomString, AtomString&gt;&gt; partMappings;
 59 };
 60 
 61 COMPILE_ASSERT(sizeof(ShadowRoot) == sizeof(SameSizeAsShadowRoot), shadowroot_should_stay_small);
 62 
 63 ShadowRoot::ShadowRoot(Document&amp; document, ShadowRootMode type, DelegatesFocus delegatesFocus)
 64     : DocumentFragment(document, CreateShadowRoot)
 65     , TreeScope(*this, document)
 66     , m_delegatesFocus(delegatesFocus == DelegatesFocus::Yes)
 67     , m_type(type)
 68     , m_styleScope(makeUnique&lt;Style::Scope&gt;(*this))
 69 {
 70 }
 71 
 72 
 73 ShadowRoot::ShadowRoot(Document&amp; document, std::unique_ptr&lt;SlotAssignment&gt;&amp;&amp; slotAssignment)
 74     : DocumentFragment(document, CreateShadowRoot)
 75     , TreeScope(*this, document)
 76     , m_type(ShadowRootMode::UserAgent)
 77     , m_styleScope(makeUnique&lt;Style::Scope&gt;(*this))
 78     , m_slotAssignment(WTFMove(slotAssignment))
 79 {
 80 }
 81 
 82 
 83 ShadowRoot::~ShadowRoot()
 84 {
 85     if (isConnected())
 86         document().didRemoveInDocumentShadowRoot(*this);
 87 
 88     if (m_styleSheetList)
 89         m_styleSheetList-&gt;detach();
 90 
 91     // We cannot let ContainerNode destructor call willBeDeletedFrom()
 92     // for this ShadowRoot instance because TreeScope destructor
 93     // clears Node::m_treeScope thus ContainerNode is no longer able
 94     // to access it Document reference after that.
 95     willBeDeletedFrom(document());
 96 
 97     ASSERT(!m_hasBegunDeletingDetachedChildren);
 98     m_hasBegunDeletingDetachedChildren = true;
 99 
100     // We must remove all of our children first before the TreeScope destructor
101     // runs so we don&#39;t go through Node::setTreeScopeRecursively for each child with a
102     // destructed tree scope in each descendant.
103     removeDetachedChildren();
104 }
105 
106 Node::InsertedIntoAncestorResult ShadowRoot::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
107 {
108     DocumentFragment::insertedIntoAncestor(insertionType, parentOfInsertedTree);
109     if (insertionType.connectedToDocument)
110         document().didInsertInDocumentShadowRoot(*this);
111     return InsertedIntoAncestorResult::Done;
112 }
113 
114 void ShadowRoot::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
115 {
116     DocumentFragment::removedFromAncestor(removalType, oldParentOfRemovedTree);
117     if (removalType.disconnectedFromDocument)
118         document().didRemoveInDocumentShadowRoot(*this);
119 }
120 
121 void ShadowRoot::childrenChanged(const ChildChange&amp; childChange)
122 {
123     DocumentFragment::childrenChanged(childChange);
124 
125     if (!m_host || m_type == ShadowRootMode::UserAgent)
126         return; // Don&#39;t support first-child, nth-of-type, etc... in UA shadow roots as an optimization.
127 
128     // FIXME: Avoid always invalidating style just for first-child, etc... as done in Element::childrenChanged.
129     switch (childChange.type) {
130     case ElementInserted:
131     case ElementRemoved:
132         m_host-&gt;invalidateStyleForSubtreeInternal();
133         break;
134     case TextInserted:
135     case TextRemoved:
136     case TextChanged:
137     case AllChildrenRemoved:
138     case NonContentsChildRemoved:
139     case NonContentsChildInserted:
140     case AllChildrenReplaced:
141         break;
142     }
143 }
144 
145 void ShadowRoot::moveShadowRootToNewParentScope(TreeScope&amp; newScope, Document&amp; newDocument)
146 {
147     setParentTreeScope(newScope);
148     moveShadowRootToNewDocument(newDocument);
149 }
150 
151 void ShadowRoot::moveShadowRootToNewDocument(Document&amp; newDocument)
152 {
153     setDocumentScope(newDocument);
154     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!parentTreeScope() || &amp;parentTreeScope()-&gt;documentScope() == &amp;newDocument);
155 
156     // Style scopes are document specific.
157     m_styleScope = makeUnique&lt;Style::Scope&gt;(*this);
158     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(&amp;m_styleScope-&gt;document() == &amp;newDocument);
159 }
160 
161 Style::Scope&amp; ShadowRoot::styleScope()
162 {
163     return *m_styleScope;
164 }
165 
166 StyleSheetList&amp; ShadowRoot::styleSheets()
167 {
168     if (!m_styleSheetList)
169         m_styleSheetList = StyleSheetList::create(*this);
170     return *m_styleSheetList;
171 }
172 
173 String ShadowRoot::innerHTML() const
174 {
175     return serializeFragment(*this, SerializedNodes::SubtreesOfChildren);
176 }
177 
178 ExceptionOr&lt;void&gt; ShadowRoot::setInnerHTML(const String&amp; markup)
179 {
180     auto fragment = createFragmentForInnerOuterHTML(*host(), markup, AllowScriptingContent);
181     if (fragment.hasException())
182         return fragment.releaseException();
183     return replaceChildrenWithFragment(*this, fragment.releaseReturnValue());
184 }
185 
186 bool ShadowRoot::childTypeAllowed(NodeType type) const
187 {
188     switch (type) {
189     case ELEMENT_NODE:
190     case PROCESSING_INSTRUCTION_NODE:
191     case COMMENT_NODE:
192     case TEXT_NODE:
193     case CDATA_SECTION_NODE:
194         return true;
195     default:
196         return false;
197     }
198 }
199 
200 void ShadowRoot::setResetStyleInheritance(bool value)
201 {
202     // If this was ever changed after initialization, child styles would need to be invalidated here.
203     m_resetStyleInheritance = value;
204 }
205 
206 Ref&lt;Node&gt; ShadowRoot::cloneNodeInternal(Document&amp;, CloningOperation)
207 {
208     RELEASE_ASSERT_NOT_REACHED();
209     return *static_cast&lt;Node*&gt;(nullptr); // ShadowRoots should never be cloned.
210 }
211 
212 void ShadowRoot::removeAllEventListeners()
213 {
214     DocumentFragment::removeAllEventListeners();
215     for (Node* node = firstChild(); node; node = NodeTraversal::next(*node))
216         node-&gt;removeAllEventListeners();
217 }
218 
219 
220 HTMLSlotElement* ShadowRoot::findAssignedSlot(const Node&amp; node)
221 {
222     ASSERT(node.parentNode() == host());
223     if (!m_slotAssignment)
224         return nullptr;
225     return m_slotAssignment-&gt;findAssignedSlot(node, *this);
226 }
227 
228 void ShadowRoot::renameSlotElement(HTMLSlotElement&amp; slot, const AtomString&amp; oldName, const AtomString&amp; newName)
229 {
230     ASSERT(m_slotAssignment);
231     return m_slotAssignment-&gt;renameSlotElement(slot, oldName, newName, *this);
232 }
233 
234 void ShadowRoot::addSlotElementByName(const AtomString&amp; name, HTMLSlotElement&amp; slot)
235 {
236     ASSERT(&amp;slot.rootNode() == this);
237     if (!m_slotAssignment)
238         m_slotAssignment = makeUnique&lt;SlotAssignment&gt;();
239 
240     return m_slotAssignment-&gt;addSlotElementByName(name, slot, *this);
241 }
242 
243 void ShadowRoot::removeSlotElementByName(const AtomString&amp; name, HTMLSlotElement&amp; slot, ContainerNode&amp; oldParentOfRemovedTree)
244 {
245     ASSERT(m_slotAssignment);
246     return m_slotAssignment-&gt;removeSlotElementByName(name, slot, &amp;oldParentOfRemovedTree, *this);
247 }
248 
249 void ShadowRoot::slotFallbackDidChange(HTMLSlotElement&amp; slot)
250 {
251     ASSERT(&amp;slot.rootNode() == this);
252     return m_slotAssignment-&gt;slotFallbackDidChange(slot, *this);
253 }
254 
255 const Vector&lt;Node*&gt;* ShadowRoot::assignedNodesForSlot(const HTMLSlotElement&amp; slot)
256 {
257     if (!m_slotAssignment)
258         return nullptr;
259     return m_slotAssignment-&gt;assignedNodesForSlot(slot, *this);
260 }
261 
262 static Optional&lt;std::pair&lt;AtomString, AtomString&gt;&gt; parsePartMapping(StringView mappingString)
263 {
264     const auto end = mappingString.length();
265 
266     auto skipWhitespace = [&amp;](auto position) {
267         while (position &lt; end &amp;&amp; isHTMLSpace(mappingString[position]))
268             ++position;
269         return position;
270     };
271 
272     auto collectValue = [&amp;](auto position) {
273         while (position &lt; end &amp;&amp; (!isHTMLSpace(mappingString[position]) &amp;&amp; mappingString[position] != &#39;:&#39;))
274             ++position;
275         return position;
276     };
277 
278     size_t begin = 0;
279     begin = skipWhitespace(begin);
280 
281     auto firstPartEnd = collectValue(begin);
282     if (firstPartEnd == begin)
283         return { };
284 
285     auto firstPart = mappingString.substring(begin, firstPartEnd - begin).toAtomString();
286 
287     begin = skipWhitespace(firstPartEnd);
288     if (begin == end)
289         return std::make_pair(firstPart, firstPart);
290 
291     if (mappingString[begin] != &#39;:&#39;)
292         return { };
293 
294     begin = skipWhitespace(begin + 1);
295 
296     auto secondPartEnd = collectValue(begin);
297     if (secondPartEnd == begin)
298         return { };
299 
300     auto secondPart = mappingString.substring(begin, secondPartEnd - begin).toAtomString();
301 
302     begin = skipWhitespace(secondPartEnd);
303     if (begin != end)
304         return { };
305 
306     return std::make_pair(firstPart, secondPart);
307 }
308 
309 static ShadowRoot::PartMappings parsePartMappingsList(StringView mappingsListString)
310 {
311     if (!RuntimeEnabledFeatures::sharedFeatures().cssShadowPartsEnabled())
312         return { };
313 
314     ShadowRoot::PartMappings mappings;
315 
316     const auto end = mappingsListString.length();
317 
318     size_t begin = 0;
319     while (begin &lt; end) {
320         size_t mappingEnd = begin;
321         while (mappingEnd &lt; end &amp;&amp; mappingsListString[mappingEnd] != &#39;,&#39;)
322             ++mappingEnd;
323 
324         auto result = parsePartMapping(mappingsListString.substring(begin, mappingEnd - begin));
325         if (result)
326             mappings.add(result-&gt;first, Vector&lt;AtomString, 1&gt;()).iterator-&gt;value.append(result-&gt;second);
327 
328         if (mappingEnd == end)
329             break;
330 
331         begin = mappingEnd + 1;
332     }
333 
334     return mappings;
335 }
336 
337 const ShadowRoot::PartMappings&amp; ShadowRoot::partMappings() const
338 {
339     if (!m_partMappings) {
340         auto exportpartsValue = host()-&gt;attributeWithoutSynchronization(HTMLNames::exportpartsAttr);
341         m_partMappings = parsePartMappingsList(exportpartsValue);
342     }
343 
344     return *m_partMappings;
345 }
346 
347 void ShadowRoot::invalidatePartMappings()
348 {
349     m_partMappings = { };
350 }
351 
352 Vector&lt;ShadowRoot*&gt; assignedShadowRootsIfSlotted(const Node&amp; node)
353 {
354     Vector&lt;ShadowRoot*&gt; result;
355     for (auto* slot = node.assignedSlot(); slot; slot = slot-&gt;assignedSlot()) {
356         ASSERT(slot-&gt;containingShadowRoot());
357         result.append(slot-&gt;containingShadowRoot());
358     }
359     return result;
360 }
361 
362 #if ENABLE(PICTURE_IN_PICTURE_API)
363 HTMLVideoElement* ShadowRoot::pictureInPictureElement() const
364 {
365     notImplemented();
366     return nullptr;
367 }
368 #endif
369 
370 }
    </pre>
  </body>
</html>
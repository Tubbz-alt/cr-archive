diff a/modules/javafx.web/src/main/native/Source/WebCore/css/CSSComputedStyleDeclaration.cpp b/modules/javafx.web/src/main/native/Source/WebCore/css/CSSComputedStyleDeclaration.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/css/CSSComputedStyleDeclaration.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/css/CSSComputedStyleDeclaration.cpp
@@ -34,10 +34,11 @@
 #include "CSSFontFeatureValue.h"
 #include "CSSFontStyleValue.h"
 #include "CSSFontValue.h"
 #include "CSSFontVariationValue.h"
 #include "CSSFunctionValue.h"
+#include "CSSGridAutoRepeatValue.h"
 #include "CSSLineBoxContainValue.h"
 #include "CSSPrimitiveValue.h"
 #include "CSSPrimitiveValueMappings.h"
 #include "CSSPropertyNames.h"
 #include "CSSPropertyParser.h"
@@ -61,11 +62,10 @@
 #include "Rect.h"
 #include "RenderBlock.h"
 #include "RenderBox.h"
 #include "RenderInline.h"
 #include "RenderStyle.h"
-#include "RuntimeEnabledFeatures.h"
 #include "SVGElement.h"
 #include "Settings.h"
 #include "ShapeValue.h"
 #include "StyleProperties.h"
 #include "StylePropertyShorthand.h"
@@ -86,420 +86,38 @@
 
 namespace WebCore {
 
 WTF_MAKE_ISO_ALLOCATED_IMPL(CSSComputedStyleDeclaration);
 
-// List of all properties we know how to compute, omitting shorthands.
-static const CSSPropertyID computedProperties[] = {
-    CSSPropertyAlignContent,
-    CSSPropertyAlignItems,
-    CSSPropertyAlignSelf,
-    CSSPropertyAlignmentBaseline,
-    CSSPropertyAlt,
-    CSSPropertyAnimationDelay,
-    CSSPropertyAnimationDirection,
-    CSSPropertyAnimationDuration,
-    CSSPropertyAnimationFillMode,
-    CSSPropertyAnimationIterationCount,
-    CSSPropertyAnimationName,
-    CSSPropertyAnimationPlayState,
-    CSSPropertyAnimationTimingFunction,
-    CSSPropertyBackgroundAttachment,
-    CSSPropertyBackgroundBlendMode,
-    CSSPropertyBackgroundClip,
-    CSSPropertyBackgroundColor,
-    CSSPropertyBackgroundImage,
-    CSSPropertyBackgroundOrigin,
-    CSSPropertyBackgroundPosition, // more-specific background-position-x/y are non-standard
-    CSSPropertyBackgroundRepeat,
-    CSSPropertyBackgroundSize,
-    CSSPropertyBaselineShift,
-    CSSPropertyBorderBottomColor,
-    CSSPropertyBorderBottomLeftRadius,
-    CSSPropertyBorderBottomRightRadius,
-    CSSPropertyBorderBottomStyle,
-    CSSPropertyBorderBottomWidth,
-    CSSPropertyBorderCollapse,
-    CSSPropertyBorderImageOutset,
-    CSSPropertyBorderImageRepeat,
-    CSSPropertyBorderImageSlice,
-    CSSPropertyBorderImageSource,
-    CSSPropertyBorderImageWidth,
-    CSSPropertyBorderLeftColor,
-    CSSPropertyBorderLeftStyle,
-    CSSPropertyBorderLeftWidth,
-    CSSPropertyBorderRightColor,
-    CSSPropertyBorderRightStyle,
-    CSSPropertyBorderRightWidth,
-    CSSPropertyBorderTopColor,
-    CSSPropertyBorderTopLeftRadius,
-    CSSPropertyBorderTopRightRadius,
-    CSSPropertyBorderTopStyle,
-    CSSPropertyBorderTopWidth,
-    CSSPropertyBottom,
-    CSSPropertyBoxShadow,
-    CSSPropertyBoxSizing,
-    CSSPropertyBufferedRendering,
-    CSSPropertyCaptionSide,
-    CSSPropertyCaretColor,
-    CSSPropertyClear,
-    CSSPropertyClip,
-    CSSPropertyClipPath,
-    CSSPropertyClipRule,
-    CSSPropertyColor,
-    CSSPropertyColorInterpolation,
-    CSSPropertyColorInterpolationFilters,
-    CSSPropertyColorRendering,
-#if ENABLE(DARK_MODE_CSS)
-    CSSPropertyColorScheme,
-#endif
-    CSSPropertyColumnCount,
-    CSSPropertyColumnFill,
-    CSSPropertyColumnGap,
-    CSSPropertyColumnRuleColor,
-    CSSPropertyColumnRuleStyle,
-    CSSPropertyColumnRuleWidth,
-    CSSPropertyColumnSpan,
-    CSSPropertyColumnWidth,
-    CSSPropertyContent,
-    CSSPropertyCounterIncrement,
-    CSSPropertyCounterReset,
-    CSSPropertyCursor,
-    CSSPropertyCx,
-    CSSPropertyCy,
-    CSSPropertyDirection,
-    CSSPropertyDisplay,
-    CSSPropertyDominantBaseline,
-    CSSPropertyEmptyCells,
-    CSSPropertyFill,
-    CSSPropertyFillOpacity,
-    CSSPropertyFillRule,
-    CSSPropertyFilter,
-    CSSPropertyFlexBasis,
-    CSSPropertyFlexDirection,
-    CSSPropertyFlexFlow,
-    CSSPropertyFlexGrow,
-    CSSPropertyFlexShrink,
-    CSSPropertyFlexWrap,
-    CSSPropertyFloat,
-    CSSPropertyFloodColor,
-    CSSPropertyFloodOpacity,
-    CSSPropertyFontFamily,
-#if ENABLE(VARIATION_FONTS)
-    CSSPropertyFontOpticalSizing,
-#endif
-    CSSPropertyFontSize,
-    CSSPropertyFontStretch,
-    CSSPropertyFontStyle,
-    CSSPropertyFontSynthesis,
-    CSSPropertyFontVariant,
-    CSSPropertyFontVariantAlternates,
-    CSSPropertyFontVariantCaps,
-    CSSPropertyFontVariantEastAsian,
-    CSSPropertyFontVariantLigatures,
-    CSSPropertyFontVariantNumeric,
-    CSSPropertyFontVariantPosition,
-#if ENABLE(VARIATION_FONTS)
-    CSSPropertyFontVariationSettings,
-#endif
-    CSSPropertyFontWeight,
-    CSSPropertyGlyphOrientationHorizontal,
-    CSSPropertyGlyphOrientationVertical,
-    CSSPropertyGridAutoColumns,
-    CSSPropertyGridAutoFlow,
-    CSSPropertyGridAutoRows,
-    CSSPropertyGridColumnEnd,
-    CSSPropertyGridColumnStart,
-    CSSPropertyGridRowEnd,
-    CSSPropertyGridRowStart,
-    CSSPropertyGridTemplateAreas,
-    CSSPropertyGridTemplateColumns,
-    CSSPropertyGridTemplateRows,
-    CSSPropertyHangingPunctuation,
-    CSSPropertyHeight,
-#if ENABLE(CSS_IMAGE_ORIENTATION)
-    CSSPropertyImageOrientation,
-#endif
-    CSSPropertyImageRendering,
-#if ENABLE(CSS_IMAGE_RESOLUTION)
-    CSSPropertyImageResolution,
-#endif
-#if ENABLE(CSS_COMPOSITING)
-    CSSPropertyIsolation,
-#endif
-    CSSPropertyJustifyContent,
-    CSSPropertyJustifyItems,
-    CSSPropertyJustifySelf,
-    CSSPropertyKerning,
-    CSSPropertyLeft,
-    CSSPropertyLetterSpacing,
-    CSSPropertyLightingColor,
-    CSSPropertyLineBreak,
-    CSSPropertyLineHeight,
-    CSSPropertyListStyleImage,
-    CSSPropertyListStylePosition,
-    CSSPropertyListStyleType,
-    CSSPropertyMarginBottom,
-    CSSPropertyMarginLeft,
-    CSSPropertyMarginRight,
-    CSSPropertyMarginTop,
-    CSSPropertyMarkerEnd,
-    CSSPropertyMarkerMid,
-    CSSPropertyMarkerStart,
-    CSSPropertyMask,
-    CSSPropertyMaskType,
-    CSSPropertyMaxHeight,
-    CSSPropertyMaxWidth,
-    CSSPropertyMinHeight,
-    CSSPropertyMinWidth,
-#if ENABLE(CSS_COMPOSITING)
-    CSSPropertyMixBlendMode,
-#endif
-    CSSPropertyObjectFit,
-    CSSPropertyObjectPosition,
-    CSSPropertyOpacity,
-    CSSPropertyOrder,
-    CSSPropertyOrphans,
-    CSSPropertyOutlineColor,
-    CSSPropertyOutlineOffset,
-    CSSPropertyOutlineStyle,
-    CSSPropertyOutlineWidth,
-    CSSPropertyOverflowWrap,
-    CSSPropertyOverflowX,
-    CSSPropertyOverflowY,
-    CSSPropertyPaddingBottom,
-    CSSPropertyPaddingLeft,
-    CSSPropertyPaddingRight,
-    CSSPropertyPaddingTop,
-    CSSPropertyPageBreakAfter,
-    CSSPropertyPageBreakBefore,
-    CSSPropertyPageBreakInside,
-    CSSPropertyPaintOrder,
-    CSSPropertyPerspective,
-    CSSPropertyPerspectiveOrigin,
-    CSSPropertyPlaceContent,
-    CSSPropertyPlaceItems,
-    CSSPropertyPlaceSelf,
-    CSSPropertyPointerEvents,
-    CSSPropertyPosition,
-    CSSPropertyR,
-    CSSPropertyResize,
-    CSSPropertyRight,
-    CSSPropertyRowGap,
-    CSSPropertyRx,
-    CSSPropertyRy,
-#if ENABLE(CSS_SCROLL_SNAP)
-    CSSPropertyScrollPadding,
-    CSSPropertyScrollPaddingBottom,
-    CSSPropertyScrollPaddingLeft,
-    CSSPropertyScrollPaddingRight,
-    CSSPropertyScrollPaddingTop,
-    CSSPropertyScrollSnapAlign,
-    CSSPropertyScrollSnapMargin,
-    CSSPropertyScrollSnapMarginBottom,
-    CSSPropertyScrollSnapMarginLeft,
-    CSSPropertyScrollSnapMarginRight,
-    CSSPropertyScrollSnapMarginTop,
-    CSSPropertyScrollSnapType,
-#endif
-    CSSPropertyShapeImageThreshold,
-    CSSPropertyShapeMargin,
-    CSSPropertyShapeOutside,
-    CSSPropertyShapeRendering,
-    CSSPropertySpeakAs,
-    CSSPropertyStopColor,
-    CSSPropertyStopOpacity,
-    CSSPropertyStroke,
-    CSSPropertyStrokeColor,
-    CSSPropertyStrokeDasharray,
-    CSSPropertyStrokeDashoffset,
-    CSSPropertyStrokeLinecap,
-    CSSPropertyStrokeLinejoin,
-    CSSPropertyStrokeMiterlimit,
-    CSSPropertyStrokeOpacity,
-    CSSPropertyStrokeWidth,
-    CSSPropertyTabSize,
-    CSSPropertyTableLayout,
-    CSSPropertyTextAlign,
-    CSSPropertyTextAnchor,
-    CSSPropertyTextDecoration,
-    CSSPropertyTextDecorationColor,
-    CSSPropertyTextDecorationLine,
-    CSSPropertyTextDecorationSkip,
-    CSSPropertyTextDecorationStyle,
-    CSSPropertyTextIndent,
-    CSSPropertyTextOverflow,
-    CSSPropertyTextRendering,
-    CSSPropertyTextShadow,
-    CSSPropertyTextTransform,
-    CSSPropertyTextUnderlinePosition,
-    CSSPropertyTop,
-#if ENABLE(POINTER_EVENTS)
-    CSSPropertyTouchAction,
-#endif
-    CSSPropertyTransform,
-    CSSPropertyTransformBox,
-    CSSPropertyTransformOrigin,
-    CSSPropertyTransformStyle,
-    CSSPropertyTransitionDelay,
-    CSSPropertyTransitionDuration,
-    CSSPropertyTransitionProperty,
-    CSSPropertyTransitionTimingFunction,
-    CSSPropertyUnicodeBidi,
-    CSSPropertyVectorEffect,
-    CSSPropertyVerticalAlign,
-    CSSPropertyVisibility,
-    CSSPropertyWhiteSpace,
-    CSSPropertyWidows,
-    CSSPropertyWidth,
-    CSSPropertyWillChange,
-    CSSPropertyWordBreak,
-    CSSPropertyWordSpacing,
-    CSSPropertyWordWrap,
-    CSSPropertyWritingMode,
-    CSSPropertyX,
-    CSSPropertyY,
-    CSSPropertyZIndex,
-    CSSPropertyZoom,
-    CSSPropertyAppleColorFilter,
-    CSSPropertyWebkitAppearance,
-#if ENABLE(FILTERS_LEVEL_2)
-    CSSPropertyWebkitBackdropFilter,
-#endif
-    CSSPropertyWebkitBackfaceVisibility,
-    CSSPropertyWebkitBackgroundClip,
-    CSSPropertyWebkitBackgroundComposite,
-    CSSPropertyWebkitBackgroundOrigin,
-    CSSPropertyWebkitBackgroundSize,
-    CSSPropertyWebkitBorderFit,
-    CSSPropertyWebkitBorderHorizontalSpacing,
-    CSSPropertyWebkitBorderImage,
-    CSSPropertyWebkitBorderVerticalSpacing,
-    CSSPropertyWebkitBoxAlign,
-#if ENABLE(CSS_BOX_DECORATION_BREAK)
-    CSSPropertyWebkitBoxDecorationBreak,
-#endif
-    CSSPropertyWebkitBoxDirection,
-    CSSPropertyWebkitBoxFlex,
-    CSSPropertyWebkitBoxFlexGroup,
-    CSSPropertyWebkitBoxLines,
-    CSSPropertyWebkitBoxOrdinalGroup,
-    CSSPropertyWebkitBoxOrient,
-    CSSPropertyWebkitBoxPack,
-    CSSPropertyWebkitBoxReflect,
-    CSSPropertyWebkitBoxShadow,
-    CSSPropertyWebkitClipPath,
-    CSSPropertyWebkitColumnAxis,
-    CSSPropertyWebkitColumnBreakAfter,
-    CSSPropertyWebkitColumnBreakBefore,
-    CSSPropertyWebkitColumnBreakInside,
-    CSSPropertyWebkitColumnProgression,
-#if ENABLE(CURSOR_VISIBILITY)
-    CSSPropertyWebkitCursorVisibility,
-#endif
-    CSSPropertyWebkitFontKerning,
-    CSSPropertyWebkitFontSmoothing,
-    CSSPropertyWebkitHyphenateCharacter,
-    CSSPropertyWebkitHyphenateLimitAfter,
-    CSSPropertyWebkitHyphenateLimitBefore,
-    CSSPropertyWebkitHyphenateLimitLines,
-    CSSPropertyWebkitHyphens,
-    CSSPropertyWebkitInitialLetter,
-    CSSPropertyWebkitLineAlign,
-    CSSPropertyWebkitLineBoxContain,
-    CSSPropertyWebkitLineClamp,
-    CSSPropertyWebkitLineGrid,
-    CSSPropertyWebkitLineSnap,
-    CSSPropertyWebkitLocale,
-    CSSPropertyWebkitMarginAfterCollapse,
-    CSSPropertyWebkitMarginBeforeCollapse,
-    CSSPropertyWebkitMarqueeDirection,
-    CSSPropertyWebkitMarqueeIncrement,
-    CSSPropertyWebkitMarqueeRepetition,
-    CSSPropertyWebkitMarqueeStyle,
-    CSSPropertyWebkitMaskBoxImage,
-    CSSPropertyWebkitMaskBoxImageOutset,
-    CSSPropertyWebkitMaskBoxImageRepeat,
-    CSSPropertyWebkitMaskBoxImageSlice,
-    CSSPropertyWebkitMaskBoxImageSource,
-    CSSPropertyWebkitMaskBoxImageWidth,
-    CSSPropertyWebkitMaskClip,
-    CSSPropertyWebkitMaskComposite,
-    CSSPropertyWebkitMaskImage,
-    CSSPropertyWebkitMaskOrigin,
-    CSSPropertyWebkitMaskPosition,
-    CSSPropertyWebkitMaskRepeat,
-    CSSPropertyWebkitMaskSize,
-    CSSPropertyWebkitMaskSourceType,
-    CSSPropertyWebkitNbspMode,
-#if ENABLE(OVERFLOW_SCROLLING_TOUCH)
-    CSSPropertyWebkitOverflowScrolling,
-#endif
-    CSSPropertyWebkitPrintColorAdjust,
-    CSSPropertyWebkitRtlOrdering,
-#if ENABLE(TOUCH_EVENTS)
-    CSSPropertyWebkitTapHighlightColor,
-#endif
-#if ENABLE(CSS3_TEXT)
-    CSSPropertyWebkitTextAlignLast,
-#endif
-    CSSPropertyWebkitTextCombine,
-    CSSPropertyWebkitTextDecorationsInEffect,
-    CSSPropertyWebkitTextEmphasisColor,
-    CSSPropertyWebkitTextEmphasisPosition,
-    CSSPropertyWebkitTextEmphasisStyle,
-    CSSPropertyWebkitTextFillColor,
-#if ENABLE(CSS3_TEXT)
-    CSSPropertyWebkitTextJustify,
-#endif
-    CSSPropertyWebkitTextOrientation,
-    CSSPropertyWebkitTextSecurity,
-#if ENABLE(TEXT_AUTOSIZING)
-    CSSPropertyWebkitTextSizeAdjust,
-#endif
-    CSSPropertyWebkitTextStrokeColor,
-    CSSPropertyWebkitTextStrokeWidth,
-    CSSPropertyWebkitTextZoom,
-#if PLATFORM(IOS_FAMILY)
-    CSSPropertyWebkitTouchCallout,
-#endif
-    CSSPropertyWebkitTransformStyle,
-    CSSPropertyWebkitUserDrag,
-    CSSPropertyWebkitUserModify,
-    CSSPropertyWebkitUserSelect,
-};
-
-const unsigned numComputedProperties = WTF_ARRAY_LENGTH(computedProperties);
-
-static CSSValueID valueForRepeatRule(int rule)
+static CSSValueID valueForRepeatRule(NinePieceImageRule rule)
 {
     switch (rule) {
-        case RepeatImageRule:
-            return CSSValueRepeat;
-        case RoundImageRule:
-            return CSSValueRound;
-        case SpaceImageRule:
-            return CSSValueSpace;
-        default:
-            return CSSValueStretch;
+    case NinePieceImageRule::Repeat:
+        return CSSValueRepeat;
+    case NinePieceImageRule::Round:
+        return CSSValueRound;
+    case NinePieceImageRule::Space:
+        return CSSValueSpace;
+    default:
+        return CSSValueStretch;
     }
 }
 
 static Ref<CSSPrimitiveValue> valueForImageSliceSide(const Length& length)
 {
     // These values can be percentages, numbers, or while an animation of mixed types is in progress,
     // a calculation that combines a percentage and a number.
     if (length.isPercent())
-        return CSSValuePool::singleton().createValue(length.percent(), CSSPrimitiveValue::CSS_PERCENTAGE);
+        return CSSValuePool::singleton().createValue(length.percent(), CSSUnitType::CSS_PERCENTAGE);
     if (length.isFixed())
-        return CSSValuePool::singleton().createValue(length.value(), CSSPrimitiveValue::CSS_NUMBER);
+        return CSSValuePool::singleton().createValue(length.value(), CSSUnitType::CSS_NUMBER);
 
     // Calculating the actual length currently in use would require most of the code from RenderBoxModelObject::paintNinePieceImage.
     // And even if we could do that, it's not clear if that's exactly what we'd want during animation.
     // FIXME: For now, just return 0.
     ASSERT(length.isCalculated());
-    return CSSValuePool::singleton().createValue(0, CSSPrimitiveValue::CSS_NUMBER);
+    return CSSValuePool::singleton().createValue(0, CSSUnitType::CSS_NUMBER);
 }
 
 static Ref<CSSBorderImageSliceValue> valueForNinePieceImageSlice(const NinePieceImage& image)
 {
     auto& slices = image.imageSlices();
@@ -547,38 +165,38 @@
     RefPtr<CSSPrimitiveValue> left;
 
     auto& cssValuePool = CSSValuePool::singleton();
 
     if (box.top().isRelative())
-        top = cssValuePool.createValue(box.top().value(), CSSPrimitiveValue::CSS_NUMBER);
+        top = cssValuePool.createValue(box.top().value(), CSSUnitType::CSS_NUMBER);
     else
         top = cssValuePool.createValue(box.top());
 
     if (box.right() == box.top() && box.bottom() == box.top() && box.left() == box.top()) {
         right = top;
         bottom = top;
         left = top;
     } else {
         if (box.right().isRelative())
-            right = cssValuePool.createValue(box.right().value(), CSSPrimitiveValue::CSS_NUMBER);
+            right = cssValuePool.createValue(box.right().value(), CSSUnitType::CSS_NUMBER);
         else
             right = cssValuePool.createValue(box.right());
 
         if (box.bottom() == box.top() && box.right() == box.left()) {
             bottom = top;
             left = right;
         } else {
             if (box.bottom().isRelative())
-                bottom = cssValuePool.createValue(box.bottom().value(), CSSPrimitiveValue::CSS_NUMBER);
+                bottom = cssValuePool.createValue(box.bottom().value(), CSSUnitType::CSS_NUMBER);
             else
                 bottom = cssValuePool.createValue(box.bottom());
 
             if (box.left() == box.right())
                 left = right;
             else {
                 if (box.left().isRelative())
-                    left = cssValuePool.createValue(box.left().value(), CSSPrimitiveValue::CSS_NUMBER);
+                    left = cssValuePool.createValue(box.left().value(), CSSUnitType::CSS_NUMBER);
                 else
                     left = cssValuePool.createValue(box.left());
             }
         }
     }
@@ -629,19 +247,19 @@
     return createBorderImageValue(WTFMove(imageValue), WTFMove(imageSlices), WTFMove(borderSlices), WTFMove(outset), WTFMove(repeat));
 }
 
 inline static Ref<CSSPrimitiveValue> zoomAdjustedPixelValue(double value, const RenderStyle& style)
 {
-    return CSSValuePool::singleton().createValue(adjustFloatForAbsoluteZoom(value, style), CSSPrimitiveValue::CSS_PX);
+    return CSSValuePool::singleton().createValue(adjustFloatForAbsoluteZoom(value, style), CSSUnitType::CSS_PX);
 }
 
 inline static Ref<CSSPrimitiveValue> zoomAdjustedNumberValue(double value, const RenderStyle& style)
 {
-    return CSSValuePool::singleton().createValue(value / style.effectiveZoom(), CSSPrimitiveValue::CSS_NUMBER);
+    return CSSValuePool::singleton().createValue(value / style.effectiveZoom(), CSSUnitType::CSS_NUMBER);
 }
 
-static Ref<CSSValue> zoomAdjustedPixelValueForLength(const Length& length, const RenderStyle& style)
+static Ref<CSSPrimitiveValue> zoomAdjustedPixelValueForLength(const Length& length, const RenderStyle& style)
 {
     if (length.isFixed())
         return zoomAdjustedPixelValue(length.value(), style);
     return CSSValuePool::singleton().createValue(length, style);
 }
@@ -651,26 +269,26 @@
     if (!reflection)
         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
 
     RefPtr<CSSPrimitiveValue> offset;
     if (reflection->offset().isPercentOrCalculated())
-        offset = CSSValuePool::singleton().createValue(reflection->offset().percent(), CSSPrimitiveValue::CSS_PERCENTAGE);
+        offset = CSSValuePool::singleton().createValue(reflection->offset().percent(), CSSUnitType::CSS_PERCENTAGE);
     else
         offset = zoomAdjustedPixelValue(reflection->offset().value(), style);
 
     RefPtr<CSSPrimitiveValue> direction;
     switch (reflection->direction()) {
-    case ReflectionBelow:
+    case ReflectionDirection::Below:
         direction = CSSValuePool::singleton().createIdentifierValue(CSSValueBelow);
         break;
-    case ReflectionAbove:
+    case ReflectionDirection::Above:
         direction = CSSValuePool::singleton().createIdentifierValue(CSSValueAbove);
         break;
-    case ReflectionLeft:
+    case ReflectionDirection::Left:
         direction = CSSValuePool::singleton().createIdentifierValue(CSSValueLeft);
         break;
-    case ReflectionRight:
+    case ReflectionDirection::Right:
         direction = CSSValuePool::singleton().createIdentifierValue(CSSValueRight);
         break;
     }
 
     return CSSReflectValue::create(direction.releaseNonNull(), offset.releaseNonNull(), valueForNinePieceImage(reflection->mask()));
@@ -832,21 +450,21 @@
 }
 
 static Ref<CSSPrimitiveValue> percentageOrZoomAdjustedValue(Length length, const RenderStyle& style)
 {
     if (length.isPercent())
-        return CSSValuePool::singleton().createValue(length.percent(), CSSPrimitiveValue::CSS_PERCENTAGE);
+        return CSSValuePool::singleton().createValue(length.percent(), CSSUnitType::CSS_PERCENTAGE);
 
-    return zoomAdjustedPixelValue(valueForLength(length, 0), style);
+    return zoomAdjustedPixelValueForLength(length, style);
 }
 
 static Ref<CSSPrimitiveValue> autoOrZoomAdjustedValue(Length length, const RenderStyle& style)
 {
     if (length.isAuto())
         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
 
-    return zoomAdjustedPixelValue(valueForLength(length, 0), style);
+    return zoomAdjustedPixelValueForLength(length, style);
 }
 
 static Ref<CSSValueList> borderRadiusCornerValues(const LengthSize& radius, const RenderStyle& style)
 {
     auto list = CSSValueList::createSpaceSeparated();
@@ -918,38 +536,38 @@
     RefPtr<CSSFunctionValue> transformValue;
     auto& cssValuePool = CSSValuePool::singleton();
     if (transform.isAffine()) {
         transformValue = CSSFunctionValue::create(CSSValueMatrix);
 
-        transformValue->append(cssValuePool.createValue(transform.a(), CSSPrimitiveValue::CSS_NUMBER));
-        transformValue->append(cssValuePool.createValue(transform.b(), CSSPrimitiveValue::CSS_NUMBER));
-        transformValue->append(cssValuePool.createValue(transform.c(), CSSPrimitiveValue::CSS_NUMBER));
-        transformValue->append(cssValuePool.createValue(transform.d(), CSSPrimitiveValue::CSS_NUMBER));
+        transformValue->append(cssValuePool.createValue(transform.a(), CSSUnitType::CSS_NUMBER));
+        transformValue->append(cssValuePool.createValue(transform.b(), CSSUnitType::CSS_NUMBER));
+        transformValue->append(cssValuePool.createValue(transform.c(), CSSUnitType::CSS_NUMBER));
+        transformValue->append(cssValuePool.createValue(transform.d(), CSSUnitType::CSS_NUMBER));
         transformValue->append(zoomAdjustedNumberValue(transform.e(), style));
         transformValue->append(zoomAdjustedNumberValue(transform.f(), style));
     } else {
         transformValue = CSSFunctionValue::create(CSSValueMatrix3d);
 
-        transformValue->append(cssValuePool.createValue(transform.m11(), CSSPrimitiveValue::CSS_NUMBER));
-        transformValue->append(cssValuePool.createValue(transform.m12(), CSSPrimitiveValue::CSS_NUMBER));
-        transformValue->append(cssValuePool.createValue(transform.m13(), CSSPrimitiveValue::CSS_NUMBER));
-        transformValue->append(cssValuePool.createValue(transform.m14(), CSSPrimitiveValue::CSS_NUMBER));
+        transformValue->append(cssValuePool.createValue(transform.m11(), CSSUnitType::CSS_NUMBER));
+        transformValue->append(cssValuePool.createValue(transform.m12(), CSSUnitType::CSS_NUMBER));
+        transformValue->append(cssValuePool.createValue(transform.m13(), CSSUnitType::CSS_NUMBER));
+        transformValue->append(cssValuePool.createValue(transform.m14(), CSSUnitType::CSS_NUMBER));
 
-        transformValue->append(cssValuePool.createValue(transform.m21(), CSSPrimitiveValue::CSS_NUMBER));
-        transformValue->append(cssValuePool.createValue(transform.m22(), CSSPrimitiveValue::CSS_NUMBER));
-        transformValue->append(cssValuePool.createValue(transform.m23(), CSSPrimitiveValue::CSS_NUMBER));
-        transformValue->append(cssValuePool.createValue(transform.m24(), CSSPrimitiveValue::CSS_NUMBER));
+        transformValue->append(cssValuePool.createValue(transform.m21(), CSSUnitType::CSS_NUMBER));
+        transformValue->append(cssValuePool.createValue(transform.m22(), CSSUnitType::CSS_NUMBER));
+        transformValue->append(cssValuePool.createValue(transform.m23(), CSSUnitType::CSS_NUMBER));
+        transformValue->append(cssValuePool.createValue(transform.m24(), CSSUnitType::CSS_NUMBER));
 
-        transformValue->append(cssValuePool.createValue(transform.m31(), CSSPrimitiveValue::CSS_NUMBER));
-        transformValue->append(cssValuePool.createValue(transform.m32(), CSSPrimitiveValue::CSS_NUMBER));
-        transformValue->append(cssValuePool.createValue(transform.m33(), CSSPrimitiveValue::CSS_NUMBER));
-        transformValue->append(cssValuePool.createValue(transform.m34(), CSSPrimitiveValue::CSS_NUMBER));
+        transformValue->append(cssValuePool.createValue(transform.m31(), CSSUnitType::CSS_NUMBER));
+        transformValue->append(cssValuePool.createValue(transform.m32(), CSSUnitType::CSS_NUMBER));
+        transformValue->append(cssValuePool.createValue(transform.m33(), CSSUnitType::CSS_NUMBER));
+        transformValue->append(cssValuePool.createValue(transform.m34(), CSSUnitType::CSS_NUMBER));
 
         transformValue->append(zoomAdjustedNumberValue(transform.m41(), style));
         transformValue->append(zoomAdjustedNumberValue(transform.m42(), style));
         transformValue->append(zoomAdjustedNumberValue(transform.m43(), style));
-        transformValue->append(cssValuePool.createValue(transform.m44(), CSSPrimitiveValue::CSS_NUMBER));
+        transformValue->append(cssValuePool.createValue(transform.m44(), CSSUnitType::CSS_NUMBER));
     }
 
     return transformValue.releaseNonNull();
 }
 
@@ -973,11 +591,11 @@
     return list;
 }
 
 static inline Ref<CSSPrimitiveValue> adjustLengthForZoom(double length, const RenderStyle& style, AdjustPixelValuesForComputedStyle adjust)
 {
-    return adjust == AdjustPixelValues ? zoomAdjustedPixelValue(length, style) : CSSValuePool::singleton().createValue(length, CSSPrimitiveValue::CSS_PX);
+    return adjust == AdjustPixelValues ? zoomAdjustedPixelValue(length, style) : CSSValuePool::singleton().createValue(length, CSSUnitType::CSS_PX);
 }
 
 static inline Ref<CSSPrimitiveValue> adjustLengthForZoom(const Length& length, const RenderStyle& style, AdjustPixelValuesForComputedStyle adjust)
 {
     return adjust == AdjustPixelValues ? zoomAdjustedPixelValue(length.value(), style) : CSSValuePool::singleton().createValue(length);
@@ -993,11 +611,11 @@
     for (const ShadowData* currShadowData = shadow; currShadowData; currShadowData = currShadowData->next()) {
         auto x = adjustLengthForZoom(currShadowData->x(), style, adjust);
         auto y = adjustLengthForZoom(currShadowData->y(), style, adjust);
         auto blur = adjustLengthForZoom(currShadowData->radius(), style, adjust);
         auto spread = propertyID == CSSPropertyTextShadow ? RefPtr<CSSPrimitiveValue>() : adjustLengthForZoom(currShadowData->spread(), style, adjust);
-        auto style = propertyID == CSSPropertyTextShadow || currShadowData->style() == Normal ? RefPtr<CSSPrimitiveValue>() : cssValuePool.createIdentifierValue(CSSValueInset);
+        auto style = propertyID == CSSPropertyTextShadow || currShadowData->style() == ShadowStyle::Normal ? RefPtr<CSSPrimitiveValue>() : cssValuePool.createIdentifierValue(CSSValueInset);
         auto color = cssValuePool.createColorValue(currShadowData->color());
         list->prepend(CSSShadowValue::create(WTFMove(x), WTFMove(y), WTFMove(blur), WTFMove(spread), WTFMove(style), WTFMove(color)));
     }
     return list;
 }
@@ -1014,56 +632,56 @@
     for (Vector<RefPtr<FilterOperation>>::const_iterator it = filterOperations.operations().begin(); it != end; ++it) {
         FilterOperation& filterOperation = **it;
 
         if (filterOperation.type() == FilterOperation::REFERENCE) {
             ReferenceFilterOperation& referenceOperation = downcast<ReferenceFilterOperation>(filterOperation);
-            list->append(cssValuePool.createValue(referenceOperation.url(), CSSPrimitiveValue::CSS_URI));
+            list->append(cssValuePool.createValue(referenceOperation.url(), CSSUnitType::CSS_URI));
         } else {
             RefPtr<CSSFunctionValue> filterValue;
             switch (filterOperation.type()) {
             case FilterOperation::GRAYSCALE: {
                 filterValue = CSSFunctionValue::create(CSSValueGrayscale);
-                filterValue->append(cssValuePool.createValue(downcast<BasicColorMatrixFilterOperation>(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));
+                filterValue->append(cssValuePool.createValue(downcast<BasicColorMatrixFilterOperation>(filterOperation).amount(), CSSUnitType::CSS_NUMBER));
                 break;
             }
             case FilterOperation::SEPIA: {
                 filterValue = CSSFunctionValue::create(CSSValueSepia);
-                filterValue->append(cssValuePool.createValue(downcast<BasicColorMatrixFilterOperation>(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));
+                filterValue->append(cssValuePool.createValue(downcast<BasicColorMatrixFilterOperation>(filterOperation).amount(), CSSUnitType::CSS_NUMBER));
                 break;
             }
             case FilterOperation::SATURATE: {
                 filterValue = CSSFunctionValue::create(CSSValueSaturate);
-                filterValue->append(cssValuePool.createValue(downcast<BasicColorMatrixFilterOperation>(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));
+                filterValue->append(cssValuePool.createValue(downcast<BasicColorMatrixFilterOperation>(filterOperation).amount(), CSSUnitType::CSS_NUMBER));
                 break;
             }
             case FilterOperation::HUE_ROTATE: {
                 filterValue = CSSFunctionValue::create(CSSValueHueRotate);
-                filterValue->append(cssValuePool.createValue(downcast<BasicColorMatrixFilterOperation>(filterOperation).amount(), CSSPrimitiveValue::CSS_DEG));
+                filterValue->append(cssValuePool.createValue(downcast<BasicColorMatrixFilterOperation>(filterOperation).amount(), CSSUnitType::CSS_DEG));
                 break;
             }
             case FilterOperation::INVERT: {
                 filterValue = CSSFunctionValue::create(CSSValueInvert);
-                filterValue->append(cssValuePool.createValue(downcast<BasicComponentTransferFilterOperation>(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));
+                filterValue->append(cssValuePool.createValue(downcast<BasicComponentTransferFilterOperation>(filterOperation).amount(), CSSUnitType::CSS_NUMBER));
                 break;
             }
             case FilterOperation::APPLE_INVERT_LIGHTNESS: {
                 filterValue = CSSFunctionValue::create(CSSValueAppleInvertLightness);
                 break;
             }
             case FilterOperation::OPACITY: {
                 filterValue = CSSFunctionValue::create(CSSValueOpacity);
-                filterValue->append(cssValuePool.createValue(downcast<BasicComponentTransferFilterOperation>(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));
+                filterValue->append(cssValuePool.createValue(downcast<BasicComponentTransferFilterOperation>(filterOperation).amount(), CSSUnitType::CSS_NUMBER));
                 break;
             }
             case FilterOperation::BRIGHTNESS: {
                 filterValue = CSSFunctionValue::create(CSSValueBrightness);
-                filterValue->append(cssValuePool.createValue(downcast<BasicComponentTransferFilterOperation>(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));
+                filterValue->append(cssValuePool.createValue(downcast<BasicComponentTransferFilterOperation>(filterOperation).amount(), CSSUnitType::CSS_NUMBER));
                 break;
             }
             case FilterOperation::CONTRAST: {
                 filterValue = CSSFunctionValue::create(CSSValueContrast);
-                filterValue->append(cssValuePool.createValue(downcast<BasicComponentTransferFilterOperation>(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));
+                filterValue->append(cssValuePool.createValue(downcast<BasicComponentTransferFilterOperation>(filterOperation).amount(), CSSUnitType::CSS_NUMBER));
                 break;
             }
             case FilterOperation::BLUR: {
                 filterValue = CSSFunctionValue::create(CSSValueBlur);
                 filterValue->append(adjustLengthForZoom(downcast<BlurFilterOperation>(filterOperation).stdDeviation(), style, adjust));
@@ -1071,11 +689,11 @@
             }
             case FilterOperation::DROP_SHADOW: {
                 DropShadowFilterOperation& dropShadowOperation = downcast<DropShadowFilterOperation>(filterOperation);
                 filterValue = CSSFunctionValue::create(CSSValueDropShadow);
                 // We want our computed style to look like that of a text shadow (has neither spread nor inset style).
-                ShadowData shadowData = ShadowData(dropShadowOperation.location(), dropShadowOperation.stdDeviation(), 0, Normal, false, dropShadowOperation.color());
+                ShadowData shadowData = ShadowData(dropShadowOperation.location(), dropShadowOperation.stdDeviation(), 0, ShadowStyle::Normal, false, dropShadowOperation.color());
                 filterValue->append(valueForShadow(&shadowData, CSSPropertyTextShadow, style, adjust));
                 break;
             }
             default:
                 ASSERT_NOT_REACHED();
@@ -1089,11 +707,11 @@
 }
 
 static Ref<CSSValue> specifiedValueForGridTrackBreadth(const GridLength& trackBreadth, const RenderStyle& style)
 {
     if (!trackBreadth.isLength())
-        return CSSValuePool::singleton().createValue(trackBreadth.flex(), CSSPrimitiveValue::CSS_FR);
+        return CSSValuePool::singleton().createValue(trackBreadth.flex(), CSSUnitType::CSS_FR);
 
     const Length& trackBreadthLength = trackBreadth.length();
     if (trackBreadthLength.isAuto())
         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
     return zoomAdjustedPixelValueForLength(trackBreadthLength, style);
@@ -1110,11 +728,11 @@
         return fitContentTrackSize;
     }
     default:
         ASSERT(trackSize.type() == MinMaxTrackSizing);
         if (trackSize.minTrackBreadth().isAuto() && trackSize.maxTrackBreadth().isFlex())
-            return CSSValuePool::singleton().createValue(trackSize.maxTrackBreadth().flex(), CSSPrimitiveValue::CSS_FR);
+            return CSSValuePool::singleton().createValue(trackSize.maxTrackBreadth().flex(), CSSUnitType::CSS_FR);
 
         auto minMaxTrackBreadths = CSSFunctionValue::create(CSSValueMinmax);
         minMaxTrackBreadths->append(specifiedValueForGridTrackBreadth(trackSize.minTrackBreadth(), style));
         minMaxTrackBreadths->append(specifiedValueForGridTrackBreadth(trackSize.maxTrackBreadth(), style));
         return minMaxTrackBreadths;
@@ -1122,29 +740,52 @@
 }
 
 class OrderedNamedLinesCollector {
     WTF_MAKE_NONCOPYABLE(OrderedNamedLinesCollector);
 public:
-    OrderedNamedLinesCollector(const RenderStyle& style, bool isRowAxis, unsigned autoRepeatTracksCount)
+    OrderedNamedLinesCollector(const RenderStyle& style, bool isRowAxis)
         : m_orderedNamedGridLines(isRowAxis ? style.orderedNamedGridColumnLines() : style.orderedNamedGridRowLines())
         , m_orderedNamedAutoRepeatGridLines(isRowAxis ? style.autoRepeatOrderedNamedGridColumnLines() : style.autoRepeatOrderedNamedGridRowLines())
-        , m_insertionPoint(isRowAxis ? style.gridAutoRepeatColumnsInsertionPoint() : style.gridAutoRepeatRowsInsertionPoint())
-        , m_autoRepeatTotalTracks(autoRepeatTracksCount)
-        , m_autoRepeatTrackListLength(isRowAxis ? style.gridAutoRepeatColumns().size() : style.gridAutoRepeatRows().size())
     {
     }
+    virtual ~OrderedNamedLinesCollector() = default;
 
     bool isEmpty() const { return m_orderedNamedGridLines.isEmpty() && m_orderedNamedAutoRepeatGridLines.isEmpty(); }
-    void collectLineNamesForIndex(CSSGridLineNamesValue&, unsigned index) const;
+    virtual void collectLineNamesForIndex(CSSGridLineNamesValue&, unsigned index) const;
 
-private:
+protected:
 
     enum NamedLinesType { NamedLines, AutoRepeatNamedLines };
     void appendLines(CSSGridLineNamesValue&, unsigned index, NamedLinesType) const;
 
     const OrderedNamedGridLinesMap& m_orderedNamedGridLines;
     const OrderedNamedGridLinesMap& m_orderedNamedAutoRepeatGridLines;
+};
+
+class OrderedNamedLinesCollectorInsideRepeat : public OrderedNamedLinesCollector {
+public:
+    OrderedNamedLinesCollectorInsideRepeat(const RenderStyle& style, bool isRowAxis)
+        : OrderedNamedLinesCollector(style, isRowAxis)
+    {
+    }
+
+    void collectLineNamesForIndex(CSSGridLineNamesValue&, unsigned index) const override;
+};
+
+class OrderedNamedLinesCollectorInGridLayout : public OrderedNamedLinesCollector {
+public:
+    OrderedNamedLinesCollectorInGridLayout(const RenderStyle& style, bool isRowAxis, unsigned autoRepeatTracksCount, unsigned autoRepeatTrackListLength)
+        : OrderedNamedLinesCollector(style, isRowAxis)
+        , m_insertionPoint(isRowAxis ? style.gridAutoRepeatColumnsInsertionPoint() : style.gridAutoRepeatRowsInsertionPoint())
+        , m_autoRepeatTotalTracks(autoRepeatTracksCount)
+        , m_autoRepeatTrackListLength(autoRepeatTrackListLength)
+    {
+    }
+
+    void collectLineNamesForIndex(CSSGridLineNamesValue&, unsigned index) const override;
+
+private:
     unsigned m_insertionPoint;
     unsigned m_autoRepeatTotalTracks;
     unsigned m_autoRepeatTrackListLength;
 };
 
@@ -1155,17 +796,29 @@
     if (iter == endIter)
         return;
 
     auto& cssValuePool = CSSValuePool::singleton();
     for (const auto& lineName : iter->value)
-        lineNamesValue.append(cssValuePool.createValue(lineName, CSSPrimitiveValue::CSS_STRING));
+        lineNamesValue.append(cssValuePool.createValue(lineName, CSSUnitType::CSS_STRING));
 }
 
 void OrderedNamedLinesCollector::collectLineNamesForIndex(CSSGridLineNamesValue& lineNamesValue, unsigned i) const
 {
     ASSERT(!isEmpty());
-    if (m_orderedNamedAutoRepeatGridLines.isEmpty() || i < m_insertionPoint) {
+    appendLines(lineNamesValue, i, NamedLines);
+}
+
+void OrderedNamedLinesCollectorInsideRepeat::collectLineNamesForIndex(CSSGridLineNamesValue& lineNamesValue, unsigned i) const
+{
+    ASSERT(!isEmpty());
+    appendLines(lineNamesValue, i, AutoRepeatNamedLines);
+}
+
+void OrderedNamedLinesCollectorInGridLayout::collectLineNamesForIndex(CSSGridLineNamesValue& lineNamesValue, unsigned i) const
+{
+    ASSERT(!isEmpty());
+    if (!m_autoRepeatTrackListLength || i < m_insertionPoint) {
         appendLines(lineNamesValue, i, NamedLines);
         return;
     }
 
     ASSERT(m_autoRepeatTotalTracks);
@@ -1212,75 +865,97 @@
     for (auto& trackSize : autoTrackSizes)
         list->append(specifiedValueForGridTrackSize(trackSize, style));
     return list;
 }
 
+template <typename T, typename F>
+void populateGridTrackList(CSSValueList& list, OrderedNamedLinesCollector& collector, const Vector<T>& tracks, F getTrackSize, unsigned start, unsigned end, unsigned offset = 0)
+{
+    ASSERT(end <= tracks.size());
+    for (unsigned i = start; i < end; ++i) {
+        addValuesForNamedGridLinesAtIndex(collector, i + offset, list);
+        list.append(getTrackSize(tracks[i]));
+    }
+    addValuesForNamedGridLinesAtIndex(collector, end + offset, list);
+}
+
+template <typename T, typename F>
+void populateGridTrackList(CSSValueList& list, OrderedNamedLinesCollector& collector, const Vector<T>& tracks, F getTrackSize)
+{
+    populateGridTrackList<T>(list, collector, tracks, getTrackSize, 0, tracks.size());
+}
+
 static Ref<CSSValue> valueForGridTrackList(GridTrackSizingDirection direction, RenderObject* renderer, const RenderStyle& style)
 {
     bool isRowAxis = direction == ForColumns;
     bool isRenderGrid = is<RenderGrid>(renderer);
     auto& trackSizes = isRowAxis ? style.gridColumns() : style.gridRows();
     auto& autoRepeatTrackSizes = isRowAxis ? style.gridAutoRepeatColumns() : style.gridAutoRepeatRows();
 
     // Handle the 'none' case.
-    bool trackListIsEmpty = trackSizes.isEmpty() && autoRepeatTrackSizes.isEmpty();
-    if (isRenderGrid && trackListIsEmpty) {
-        // For grids we should consider every listed track, whether implicitly or explicitly
-        // created. Empty grids have a sole grid line per axis.
-        auto& grid = downcast<RenderGrid>(*renderer);
-        auto& positions = isRowAxis ? grid.columnPositions() : grid.rowPositions();
-        trackListIsEmpty = positions.size() == 1;
-    }
-
-    if (trackListIsEmpty)
+    if (trackSizes.isEmpty() && autoRepeatTrackSizes.isEmpty())
         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
 
-    unsigned autoRepeatTotalTracks = isRenderGrid ? downcast<RenderGrid>(renderer)->autoRepeatCountForDirection(direction) : 0;
-    OrderedNamedLinesCollector collector(style, isRowAxis, autoRepeatTotalTracks);
     auto list = CSSValueList::createSpaceSeparated();
-    unsigned insertionIndex;
-    if (isRenderGrid) {
-        auto computedTrackSizes = downcast<RenderGrid>(*renderer).trackSizesForComputedStyle(direction);
-        unsigned numTracks = computedTrackSizes.size();
-
-        for (unsigned i = 0; i < numTracks; ++i) {
-            addValuesForNamedGridLinesAtIndex(collector, i, list.get());
-            list->append(zoomAdjustedPixelValue(computedTrackSizes[i], style));
-        }
-        addValuesForNamedGridLinesAtIndex(collector, numTracks + 1, list.get());
-        insertionIndex = numTracks;
-    } else {
-        for (unsigned i = 0; i < trackSizes.size(); ++i) {
-            addValuesForNamedGridLinesAtIndex(collector, i, list.get());
-            list->append(specifiedValueForGridTrackSize(trackSizes[i], style));
-        }
-        insertionIndex = trackSizes.size();
-    }
 
-    // Those are the trailing <ident>* allowed in the syntax.
-    addValuesForNamedGridLinesAtIndex(collector, insertionIndex, list.get());
+    // If the element is a grid container, the resolved value is the used value,
+    // specifying track sizes in pixels and expanding the repeat() notation.
+    if (isRenderGrid) {
+        auto* grid = downcast<RenderGrid>(renderer);
+        OrderedNamedLinesCollectorInGridLayout collector(style, isRowAxis, grid->autoRepeatCountForDirection(direction), autoRepeatTrackSizes.size());
+        populateGridTrackList(list.get(), collector, grid->trackSizesForComputedStyle(direction), [&](const LayoutUnit& v) {
+            return zoomAdjustedPixelValue(v, style);
+        });
+        return list;
+    }
+
+    // Otherwise, the resolved value is the computed value, preserving repeat().
+    OrderedNamedLinesCollector collector(style, isRowAxis);
+    auto getTrackSize = [&](const GridTrackSize& v) {
+        return specifiedValueForGridTrackSize(v, style);
+    };
+
+    if (autoRepeatTrackSizes.isEmpty()) {
+        // If there's no auto repeat(), just add all the line names and track sizes.
+        populateGridTrackList(list.get(), collector, trackSizes, getTrackSize);
+        return list;
+    }
+
+    // Add the line names and track sizes that precede the auto repeat().
+    unsigned autoRepeatInsertionPoint = isRowAxis ? style.gridAutoRepeatColumnsInsertionPoint() : style.gridAutoRepeatRowsInsertionPoint();
+    populateGridTrackList(list.get(), collector, trackSizes, getTrackSize, 0, autoRepeatInsertionPoint);
+
+    // Add a CSSGridAutoRepeatValue with the contents of the auto repeat().
+    AutoRepeatType autoRepeatType = isRowAxis ? style.gridAutoRepeatColumnsType() : style.gridAutoRepeatRowsType();
+    auto repeatedValues = CSSGridAutoRepeatValue::create(autoRepeatType == AutoRepeatType::Fill ? CSSValueAutoFill : CSSValueAutoFit);
+    OrderedNamedLinesCollectorInsideRepeat repeatCollector(style, isRowAxis);
+    populateGridTrackList(repeatedValues.get(), repeatCollector, autoRepeatTrackSizes, getTrackSize);
+    list->append(repeatedValues.get());
+
+    // Add the line names and track sizes that follow the auto repeat().
+    populateGridTrackList(list.get(), collector, trackSizes, getTrackSize, autoRepeatInsertionPoint, trackSizes.size(), 1);
     return list;
 }
 
 static Ref<CSSValue> valueForGridPosition(const GridPosition& position)
 {
     auto& cssValuePool = CSSValuePool::singleton();
     if (position.isAuto())
         return cssValuePool.createIdentifierValue(CSSValueAuto);
 
     if (position.isNamedGridArea())
-        return cssValuePool.createValue(position.namedGridLine(), CSSPrimitiveValue::CSS_STRING);
+        return cssValuePool.createValue(position.namedGridLine(), CSSUnitType::CSS_STRING);
 
     auto list = CSSValueList::createSpaceSeparated();
     if (position.isSpan()) {
         list->append(cssValuePool.createIdentifierValue(CSSValueSpan));
-        list->append(cssValuePool.createValue(position.spanPosition(), CSSPrimitiveValue::CSS_NUMBER));
+        list->append(cssValuePool.createValue(position.spanPosition(), CSSUnitType::CSS_NUMBER));
     } else
-        list->append(cssValuePool.createValue(position.integerPosition(), CSSPrimitiveValue::CSS_NUMBER));
+        list->append(cssValuePool.createValue(position.integerPosition(), CSSUnitType::CSS_NUMBER));
 
     if (!position.namedGridLine().isNull())
-        list->append(cssValuePool.createValue(position.namedGridLine(), CSSPrimitiveValue::CSS_STRING));
+        list->append(cssValuePool.createValue(position.namedGridLine(), CSSUnitType::CSS_STRING));
     return list;
 }
 
 static Ref<CSSValue> createTransitionPropertyValue(const Animation& animation)
 {
@@ -1288,13 +963,13 @@
     case Animation::AnimateNone:
         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
     case Animation::AnimateAll:
         return CSSValuePool::singleton().createIdentifierValue(CSSValueAll);
     case Animation::AnimateSingleProperty:
-        return CSSValuePool::singleton().createValue(getPropertyNameString(animation.property()), CSSPrimitiveValue::CSS_STRING);
+        return CSSValuePool::singleton().createValue(getPropertyNameString(animation.property()), CSSUnitType::CSS_STRING);
     case Animation::AnimateUnknownProperty:
-        return CSSValuePool::singleton().createValue(animation.unknownProperty(), CSSPrimitiveValue::CSS_STRING);
+        return CSSValuePool::singleton().createValue(animation.unknownProperty(), CSSUnitType::CSS_STRING);
     }
     ASSERT_NOT_REACHED();
     return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
 }
 
@@ -1551,28 +1226,28 @@
 {
     auto& cssValuePool = CSSValuePool::singleton();
     auto list = CSSValueList::createCommaSeparated();
     if (animationList) {
         for (size_t i = 0; i < animationList->size(); ++i)
-            list->append(cssValuePool.createValue(animationList->animation(i).delay(), CSSPrimitiveValue::CSS_S));
+            list->append(cssValuePool.createValue(animationList->animation(i).delay(), CSSUnitType::CSS_S));
     } else {
         // Note that initialAnimationDelay() is used for both transitions and animations
-        list->append(cssValuePool.createValue(Animation::initialDelay(), CSSPrimitiveValue::CSS_S));
+        list->append(cssValuePool.createValue(Animation::initialDelay(), CSSUnitType::CSS_S));
     }
     return list;
 }
 
 static Ref<CSSValueList> durationValue(const AnimationList* animationList)
 {
     auto& cssValuePool = CSSValuePool::singleton();
     auto list = CSSValueList::createCommaSeparated();
     if (animationList) {
         for (size_t i = 0; i < animationList->size(); ++i)
-            list->append(cssValuePool.createValue(animationList->animation(i).duration(), CSSPrimitiveValue::CSS_S));
+            list->append(cssValuePool.createValue(animationList->animation(i).duration(), CSSUnitType::CSS_S));
     } else {
         // Note that initialAnimationDuration() is used for both transitions and animations
-        list->append(cssValuePool.createValue(Animation::initialDuration(), CSSPrimitiveValue::CSS_S));
+        list->append(cssValuePool.createValue(Animation::initialDuration(), CSSUnitType::CSS_S));
     }
     return list;
 }
 
 static Ref<CSSValue> createTimingFunctionValue(const TimingFunction& timingFunction)
@@ -1625,11 +1300,11 @@
         // Note that initialAnimationTimingFunction() is used for both transitions and animations
         list->append(createTimingFunctionValue(Animation::initialTimingFunction()));
     return list;
 }
 
-static Ref<CSSValue> createLineBoxContainValue(unsigned lineBoxContain)
+static Ref<CSSValue> createLineBoxContainValue(OptionSet<LineBoxContain> lineBoxContain)
 {
     if (!lineBoxContain)
         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
     return CSSLineBoxContainValue::create(lineBoxContain);
 }
@@ -1689,14 +1364,14 @@
 }
 
 String CSSComputedStyleDeclaration::cssText() const
 {
     StringBuilder result;
-    for (unsigned i = 0; i < numComputedProperties; i++) {
+    for (unsigned i = 0; i < numComputedPropertyIDs; i++) {
         if (i)
             result.append(' ');
-        result.append(getPropertyName(computedProperties[i]), ": ", getPropertyValue(computedProperties[i]), ';');
+        result.append(getPropertyName(computedPropertyIDs[i]), ": ", getPropertyValue(computedPropertyIDs[i]), ';');
     }
     return result.toString();
 }
 
 ExceptionOr<void> CSSComputedStyleDeclaration::setCssText(const String&)
@@ -1845,21 +1520,21 @@
 static Ref<CSSValue> textUnderlineOffsetToCSSValue(const TextUnderlineOffset& textUnderlineOffset)
 {
     if (textUnderlineOffset.isAuto())
         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
     ASSERT(textUnderlineOffset.isLength());
-    return CSSValuePool::singleton().createValue(textUnderlineOffset.lengthValue(), CSSPrimitiveValue::CSS_PX);
+    return CSSValuePool::singleton().createValue(textUnderlineOffset.lengthValue(), CSSUnitType::CSS_PX);
 }
 
 static Ref<CSSValue> textDecorationThicknessToCSSValue(const TextDecorationThickness& textDecorationThickness)
 {
     if (textDecorationThickness.isAuto())
         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
     if (textDecorationThickness.isFromFont())
         return CSSValuePool::singleton().createIdentifierValue(CSSValueFromFont);
     ASSERT(textDecorationThickness.isLength());
-    return CSSValuePool::singleton().createValue(textDecorationThickness.lengthValue(), CSSPrimitiveValue::CSS_PX);
+    return CSSValuePool::singleton().createValue(textDecorationThickness.lengthValue(), CSSUnitType::CSS_PX);
 }
 
 static Ref<CSSValue> renderEmphasisPositionFlagsToCSSValue(OptionSet<TextEmphasisPosition> textEmphasisPosition)
 {
     ASSERT(!((textEmphasisPosition & TextEmphasisPosition::Over) && (textEmphasisPosition & TextEmphasisPosition::Under)));
@@ -1959,24 +1634,24 @@
     return list;
 }
 
 static Ref<CSSValue> altTextToCSSValue(const RenderStyle& style)
 {
-    return CSSValuePool::singleton().createValue(style.contentAltText(), CSSPrimitiveValue::CSS_STRING);
+    return CSSValuePool::singleton().createValue(style.contentAltText(), CSSUnitType::CSS_STRING);
 }
 
 static Ref<CSSValueList> contentToCSSValue(const RenderStyle& style)
 {
     auto& cssValuePool = CSSValuePool::singleton();
     auto list = CSSValueList::createSpaceSeparated();
     for (auto* contentData = style.contentData(); contentData; contentData = contentData->next()) {
         if (is<CounterContentData>(*contentData))
-            list->append(cssValuePool.createValue(downcast<CounterContentData>(*contentData).counter().identifier(), CSSPrimitiveValue::CSS_COUNTER_NAME));
+            list->append(cssValuePool.createValue(downcast<CounterContentData>(*contentData).counter().identifier(), CSSUnitType::CSS_COUNTER_NAME));
         else if (is<ImageContentData>(*contentData))
             list->append(downcast<ImageContentData>(*contentData).image().cssValue());
         else if (is<TextContentData>(*contentData))
-            list->append(cssValuePool.createValue(downcast<TextContentData>(*contentData).text(), CSSPrimitiveValue::CSS_STRING));
+            list->append(cssValuePool.createValue(downcast<TextContentData>(*contentData).text(), CSSUnitType::CSS_STRING));
     }
     return list;
 }
 
 static Ref<CSSValue> counterToCSSValue(const RenderStyle& style, CSSPropertyID propertyID)
@@ -1986,26 +1661,17 @@
         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
 
     auto& cssValuePool = CSSValuePool::singleton();
     auto list = CSSValueList::createSpaceSeparated();
     for (auto& keyValue : *map) {
-        list->append(cssValuePool.createValue(keyValue.key, CSSPrimitiveValue::CSS_STRING));
+        list->append(cssValuePool.createValue(keyValue.key, CSSUnitType::CSS_STRING));
         double number = (propertyID == CSSPropertyCounterIncrement ? keyValue.value.incrementValue : keyValue.value.resetValue).valueOr(0);
-        list->append(cssValuePool.createValue(number, CSSPrimitiveValue::CSS_NUMBER));
+        list->append(cssValuePool.createValue(number, CSSUnitType::CSS_NUMBER));
     }
     return list;
 }
 
-static void logUnimplementedPropertyID(CSSPropertyID propertyID)
-{
-    static NeverDestroyed<HashSet<CSSPropertyID>> propertyIDSet;
-    if (!propertyIDSet.get().add(propertyID).isNewEntry)
-        return;
-
-    LOG_ERROR("WebKit does not yet implement getComputedStyle for '%s'.", getPropertyName(propertyID));
-}
-
 static Ref<CSSValueList> fontFamilyListFromStyle(const RenderStyle& style)
 {
     auto list = CSSValueList::createCommaSeparated();
     for (unsigned i = 0; i < style.fontCascade().familyCount(); ++i)
         list->append(valueForFamily(style.fontCascade().familyAt(i)));
@@ -2020,12 +1686,12 @@
 }
 
 static Ref<CSSPrimitiveValue> lineHeightFromStyle(const RenderStyle& style)
 {
     Length length = style.lineHeight();
-    if (length.isNegative()) // If true, line-height not set; use the font's line spacing.
-        return zoomAdjustedPixelValue(style.fontMetrics().floatLineSpacing(), style);
+    if (length.isNegative())
+        return CSSValuePool::singleton().createIdentifierValue(CSSValueNormal);
     if (length.isPercent()) {
         // This is imperfect, because it doesn't include the zoom factor and the real computation
         // for how high to be in pixels does include things like minimum font size and the zoom factor.
         // On the other hand, since font-size doesn't include the zoom factor, we really can't do
         // that here either.
@@ -2039,11 +1705,11 @@
     return zoomAdjustedPixelValue(style.fontDescription().computedSize(), style);
 }
 
 Ref<CSSPrimitiveValue> ComputedStyleExtractor::fontNonKeywordWeightFromStyleValue(FontSelectionValue weight)
 {
-    return CSSValuePool::singleton().createValue(static_cast<float>(weight), CSSPrimitiveValue::CSS_NUMBER);
+    return CSSValuePool::singleton().createValue(static_cast<float>(weight), CSSUnitType::CSS_NUMBER);
 }
 
 Ref<CSSPrimitiveValue> ComputedStyleExtractor::fontWeightFromStyleValue(FontSelectionValue weight)
 {
     if (auto value = fontWeightKeyword(weight))
@@ -2056,11 +1722,11 @@
     return ComputedStyleExtractor::fontWeightFromStyleValue(style.fontDescription().weight());
 }
 
 Ref<CSSPrimitiveValue> ComputedStyleExtractor::fontNonKeywordStretchFromStyleValue(FontSelectionValue stretch)
 {
-    return CSSValuePool::singleton().createValue(static_cast<float>(stretch), CSSPrimitiveValue::CSS_PERCENTAGE);
+    return CSSValuePool::singleton().createValue(static_cast<float>(stretch), CSSUnitType::CSS_PERCENTAGE);
 }
 
 Ref<CSSPrimitiveValue> ComputedStyleExtractor::fontStretchFromStyleValue(FontSelectionValue stretch)
 {
     if (auto keyword = fontStretchKeyword(stretch))
@@ -2073,11 +1739,11 @@
     return ComputedStyleExtractor::fontStretchFromStyleValue(style.fontDescription().stretch());
 }
 
 Ref<CSSFontStyleValue> ComputedStyleExtractor::fontNonKeywordStyleFromStyleValue(FontSelectionValue italic)
 {
-    return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueOblique), CSSValuePool::singleton().createValue(static_cast<float>(italic), CSSPrimitiveValue::CSS_DEG));
+    return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueOblique), CSSValuePool::singleton().createValue(static_cast<float>(italic), CSSUnitType::CSS_DEG));
 }
 
 Ref<CSSFontStyleValue> ComputedStyleExtractor::fontStyleFromStyleValue(Optional<FontSelectionValue> italic, FontStyleAxis fontStyleAxis)
 {
     if (auto keyword = fontStyleKeyword(italic, fontStyleAxis))
@@ -2714,11 +2380,11 @@
 
     auto weight = fontDescription.weight();
     if (auto value = fontWeightKeyword(weight))
         computedFont->weight = CSSValuePool::singleton().createIdentifierValue(value.value());
     else if (isCSS21Weight(weight))
-        computedFont->weight = CSSValuePool::singleton().createValue(static_cast<float>(weight), CSSPrimitiveValue::CSS_NUMBER);
+        computedFont->weight = CSSValuePool::singleton().createValue(static_cast<float>(weight), CSSUnitType::CSS_NUMBER);
     else
         return CSSFontValue::create();
 
     if (auto keyword = fontStretchKeyword(fontDescription.stretch()))
         computedFont->stretch = CSSValuePool::singleton().createIdentifierValue(keyword.value());
@@ -2962,17 +2628,17 @@
         return cssValuePool.createIdentifierValue(CSSValueClone);
 #endif
         case CSSPropertyWebkitBoxDirection:
             return cssValuePool.createValue(style.boxDirection());
         case CSSPropertyWebkitBoxFlex:
-            return cssValuePool.createValue(style.boxFlex(), CSSPrimitiveValue::CSS_NUMBER);
+            return cssValuePool.createValue(style.boxFlex(), CSSUnitType::CSS_NUMBER);
         case CSSPropertyWebkitBoxFlexGroup:
-            return cssValuePool.createValue(style.boxFlexGroup(), CSSPrimitiveValue::CSS_NUMBER);
+            return cssValuePool.createValue(style.boxFlexGroup(), CSSUnitType::CSS_NUMBER);
         case CSSPropertyWebkitBoxLines:
             return cssValuePool.createValue(style.boxLines());
         case CSSPropertyWebkitBoxOrdinalGroup:
-            return cssValuePool.createValue(style.boxOrdinalGroup(), CSSPrimitiveValue::CSS_NUMBER);
+            return cssValuePool.createValue(style.boxOrdinalGroup(), CSSUnitType::CSS_NUMBER);
         case CSSPropertyWebkitBoxOrient:
             return cssValuePool.createValue(style.boxOrient());
         case CSSPropertyWebkitBoxPack:
             return cssValuePool.createValue(style.boxPack());
         case CSSPropertyWebkitBoxReflect:
@@ -2993,11 +2659,11 @@
         case CSSPropertyWebkitColumnAxis:
             return cssValuePool.createValue(style.columnAxis());
         case CSSPropertyColumnCount:
             if (style.hasAutoColumnCount())
                 return cssValuePool.createIdentifierValue(CSSValueAuto);
-            return cssValuePool.createValue(style.columnCount(), CSSPrimitiveValue::CSS_NUMBER);
+            return cssValuePool.createValue(style.columnCount(), CSSUnitType::CSS_NUMBER);
         case CSSPropertyColumnFill:
             return cssValuePool.createValue(style.columnFill());
         case CSSPropertyColumnGap:
             if (style.columnGap().isNormal())
                 return cssValuePool.createIdentifierValue(CSSValueNormal);
@@ -3025,11 +2691,11 @@
         case CSSPropertyColumnWidth:
             if (style.hasAutoColumnWidth())
                 return cssValuePool.createIdentifierValue(CSSValueAuto);
             return zoomAdjustedPixelValue(style.columnWidth(), style);
         case CSSPropertyTabSize:
-            return cssValuePool.createValue(style.tabSize().widthInPixels(1.0), style.tabSize().isSpaces() ? CSSPrimitiveValue::CSS_NUMBER : CSSPrimitiveValue::CSS_PX);
+            return cssValuePool.createValue(style.tabSize().widthInPixels(1.0), style.tabSize().isSpaces() ? CSSUnitType::CSS_NUMBER : CSSUnitType::CSS_PX);
         case CSSPropertyCursor: {
             RefPtr<CSSValueList> list;
             auto* cursors = style.cursors();
             if (cursors && cursors->size() > 0) {
                 list = CSSValueList::createCommaSeparated();
@@ -3085,11 +2751,11 @@
         case CSSPropertyPlaceItems:
             return getCSSPropertyValuesForShorthandProperties(placeItemsShorthand());
         case CSSPropertyPlaceSelf:
             return getCSSPropertyValuesForShorthandProperties(placeSelfShorthand());
         case CSSPropertyOrder:
-            return cssValuePool.createValue(style.order(), CSSPrimitiveValue::CSS_NUMBER);
+            return cssValuePool.createValue(style.order(), CSSUnitType::CSS_NUMBER);
         case CSSPropertyFloat:
             if (style.display() != DisplayType::None && style.hasOutOfFlowPosition())
                 return cssValuePool.createIdentifierValue(CSSValueNone);
             return cssValuePool.createValue(style.floating());
         case CSSPropertyFont: {
@@ -3201,47 +2867,47 @@
         case CSSPropertyWebkitHyphens:
             return cssValuePool.createValue(style.hyphens());
         case CSSPropertyWebkitHyphenateCharacter:
             if (style.hyphenationString().isNull())
                 return cssValuePool.createIdentifierValue(CSSValueAuto);
-            return cssValuePool.createValue(style.hyphenationString(), CSSPrimitiveValue::CSS_STRING);
+            return cssValuePool.createValue(style.hyphenationString(), CSSUnitType::CSS_STRING);
         case CSSPropertyWebkitHyphenateLimitAfter:
             if (style.hyphenationLimitAfter() < 0)
                 return CSSPrimitiveValue::createIdentifier(CSSValueAuto);
-            return CSSPrimitiveValue::create(style.hyphenationLimitAfter(), CSSPrimitiveValue::CSS_NUMBER);
+            return CSSPrimitiveValue::create(style.hyphenationLimitAfter(), CSSUnitType::CSS_NUMBER);
         case CSSPropertyWebkitHyphenateLimitBefore:
             if (style.hyphenationLimitBefore() < 0)
                 return CSSPrimitiveValue::createIdentifier(CSSValueAuto);
-            return CSSPrimitiveValue::create(style.hyphenationLimitBefore(), CSSPrimitiveValue::CSS_NUMBER);
+            return CSSPrimitiveValue::create(style.hyphenationLimitBefore(), CSSUnitType::CSS_NUMBER);
         case CSSPropertyWebkitHyphenateLimitLines:
             if (style.hyphenationLimitLines() < 0)
                 return CSSPrimitiveValue::createIdentifier(CSSValueNoLimit);
-            return CSSPrimitiveValue::create(style.hyphenationLimitLines(), CSSPrimitiveValue::CSS_NUMBER);
+            return CSSPrimitiveValue::create(style.hyphenationLimitLines(), CSSUnitType::CSS_NUMBER);
         case CSSPropertyWebkitBorderFit:
             if (style.borderFit() == BorderFit::Border)
                 return cssValuePool.createIdentifierValue(CSSValueBorder);
             return cssValuePool.createIdentifierValue(CSSValueLines);
-#if ENABLE(CSS_IMAGE_ORIENTATION)
         case CSSPropertyImageOrientation:
-            return cssValuePool.createValue(style.imageOrientation());
-#endif
+            if (style.imageOrientation() == ImageOrientation::FromImage)
+                return cssValuePool.createIdentifierValue(CSSValueFromImage);
+            return cssValuePool.createIdentifierValue(CSSValueNone);
         case CSSPropertyImageRendering:
             return CSSPrimitiveValue::create(style.imageRendering());
 #if ENABLE(CSS_IMAGE_RESOLUTION)
         case CSSPropertyImageResolution:
-            return cssValuePool.createValue(style.imageResolution(), CSSPrimitiveValue::CSS_DPPX);
+            return cssValuePool.createValue(style.imageResolution(), CSSUnitType::CSS_DPPX);
 #endif
         case CSSPropertyLeft:
             return positionOffsetValue(style, CSSPropertyLeft, renderer);
         case CSSPropertyLetterSpacing:
             if (!style.letterSpacing())
                 return cssValuePool.createIdentifierValue(CSSValueNormal);
             return zoomAdjustedPixelValue(style.letterSpacing(), style);
         case CSSPropertyWebkitLineClamp:
             if (style.lineClamp().isNone())
                 return cssValuePool.createIdentifierValue(CSSValueNone);
-            return cssValuePool.createValue(style.lineClamp().value(), style.lineClamp().isPercentage() ? CSSPrimitiveValue::CSS_PERCENTAGE : CSSPrimitiveValue::CSS_NUMBER);
+            return cssValuePool.createValue(style.lineClamp().value(), style.lineClamp().isPercentage() ? CSSUnitType::CSS_PERCENTAGE : CSSUnitType::CSS_NUMBER);
         case CSSPropertyLineHeight:
             return lineHeightFromStyle(style);
         case CSSPropertyListStyleImage:
             if (style.listStyleImage())
                 return style.listStyleImage()->cssValue();
@@ -3251,11 +2917,11 @@
         case CSSPropertyListStyleType:
             return cssValuePool.createValue(style.listStyleType());
         case CSSPropertyWebkitLocale:
             if (style.locale().isNull())
                 return cssValuePool.createIdentifierValue(CSSValueAuto);
-            return cssValuePool.createValue(style.locale(), CSSPrimitiveValue::CSS_STRING);
+            return cssValuePool.createValue(style.locale(), CSSUnitType::CSS_STRING);
         case CSSPropertyMarginTop:
             return zoomAdjustedPaddingOrMarginPixelValue<&RenderStyle::marginTop, &RenderBoxModelObject::marginTop>(style, renderer);
         case CSSPropertyMarginRight: {
             Length marginRight = style.marginRight();
             if (marginRight.isFixed() || !is<RenderBox>(renderer))
@@ -3272,20 +2938,10 @@
         }
         case CSSPropertyMarginBottom:
             return zoomAdjustedPaddingOrMarginPixelValue<&RenderStyle::marginBottom, &RenderBoxModelObject::marginBottom>(style, renderer);
         case CSSPropertyMarginLeft:
             return zoomAdjustedPaddingOrMarginPixelValue<&RenderStyle::marginLeft, &RenderBoxModelObject::marginLeft>(style, renderer);
-        case CSSPropertyWebkitMarqueeDirection:
-            return cssValuePool.createValue(style.marqueeDirection());
-        case CSSPropertyWebkitMarqueeIncrement:
-            return cssValuePool.createValue(style.marqueeIncrement());
-        case CSSPropertyWebkitMarqueeRepetition:
-            if (style.marqueeLoopCount() < 0)
-                return cssValuePool.createIdentifierValue(CSSValueInfinite);
-            return cssValuePool.createValue(style.marqueeLoopCount(), CSSPrimitiveValue::CSS_NUMBER);
-        case CSSPropertyWebkitMarqueeStyle:
-            return cssValuePool.createValue(style.marqueeBehavior());
         case CSSPropertyWebkitUserModify:
             return cssValuePool.createValue(style.userModify());
         case CSSPropertyMaxHeight: {
             const Length& maxHeight = style.maxHeight();
             if (maxHeight.isUndefined())
@@ -3321,15 +2977,15 @@
             list->append(zoomAdjustedPixelValueForLength(style.objectPosition().x(), style));
             list->append(zoomAdjustedPixelValueForLength(style.objectPosition().y(), style));
             return list;
         }
         case CSSPropertyOpacity:
-            return cssValuePool.createValue(style.opacity(), CSSPrimitiveValue::CSS_NUMBER);
+            return cssValuePool.createValue(style.opacity(), CSSUnitType::CSS_NUMBER);
         case CSSPropertyOrphans:
             if (style.hasAutoOrphans())
                 return cssValuePool.createIdentifierValue(CSSValueAuto);
-            return cssValuePool.createValue(style.orphans(), CSSPrimitiveValue::CSS_NUMBER);
+            return cssValuePool.createValue(style.orphans(), CSSUnitType::CSS_NUMBER);
         case CSSPropertyOutlineColor:
             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyOutlineColor)) : currentColorOrValidColor(&style, style.outlineColor());
         case CSSPropertyOutlineOffset:
             return zoomAdjustedPixelValue(style.outlineOffset(), style);
         case CSSPropertyOutlineStyle:
@@ -3337,11 +2993,11 @@
                 return cssValuePool.createIdentifierValue(CSSValueAuto);
             return cssValuePool.createValue(style.outlineStyle());
         case CSSPropertyOutlineWidth:
             return zoomAdjustedPixelValue(style.outlineWidth(), style);
         case CSSPropertyOverflow:
-            return cssValuePool.createValue(std::max(style.overflowX(), style.overflowY()));
+            return getCSSPropertyValuesFor2SidesShorthand(overflowShorthand());
         case CSSPropertyOverflowWrap:
             return cssValuePool.createValue(style.overflowWrap());
         case CSSPropertyOverflowX:
             return cssValuePool.createValue(style.overflowX());
         case CSSPropertyOverflowY:
@@ -3413,14 +3069,14 @@
         case CSSPropertyWebkitTextEmphasisStyle:
             switch (style.textEmphasisMark()) {
             case TextEmphasisMark::None:
                 return cssValuePool.createIdentifierValue(CSSValueNone);
             case TextEmphasisMark::Custom:
-                return cssValuePool.createValue(style.textEmphasisCustomMark(), CSSPrimitiveValue::CSS_STRING);
+                return cssValuePool.createValue(style.textEmphasisCustomMark(), CSSUnitType::CSS_STRING);
             case TextEmphasisMark::Auto:
                 ASSERT_NOT_REACHED();
-#if ASSERT_DISABLED
+#if !ASSERT_ENABLED
                 FALLTHROUGH;
 #endif
             case TextEmphasisMark::Dot:
             case TextEmphasisMark::Circle:
             case TextEmphasisMark::DoubleCircle:
@@ -3465,11 +3121,11 @@
         case CSSPropertyWebkitTextSizeAdjust:
             if (style.textSizeAdjust().isAuto())
                 return cssValuePool.createIdentifierValue(CSSValueAuto);
             if (style.textSizeAdjust().isNone())
                 return cssValuePool.createIdentifierValue(CSSValueNone);
-            return CSSPrimitiveValue::create(style.textSizeAdjust().percentage(), CSSPrimitiveValue::CSS_PERCENTAGE);
+            return CSSPrimitiveValue::create(style.textSizeAdjust().percentage(), CSSUnitType::CSS_PERCENTAGE);
 #endif
         case CSSPropertyWebkitTextStrokeColor:
             return currentColorOrValidColor(&style, style.textStrokeColor());
         case CSSPropertyWebkitTextStrokeWidth:
             return zoomAdjustedPixelValue(style.textStrokeWidth(), style);
@@ -3509,11 +3165,11 @@
         case CSSPropertyWhiteSpace:
             return cssValuePool.createValue(style.whiteSpace());
         case CSSPropertyWidows:
             if (style.hasAutoWidows())
                 return cssValuePool.createIdentifierValue(CSSValueAuto);
-            return cssValuePool.createValue(style.widows(), CSSPrimitiveValue::CSS_NUMBER);
+            return cssValuePool.createValue(style.widows(), CSSUnitType::CSS_NUMBER);
         case CSSPropertyWidth:
             if (renderer && !renderer->isRenderSVGModelObject()) {
                 // According to http://www.w3.org/TR/CSS2/visudet.html#the-width-property,
                 // the "width" property does not apply for non-replaced inline elements.
                 if (!isNonReplacedInline(*renderer))
@@ -3549,15 +3205,15 @@
         case CSSPropertyFontVariantAlternates:
             return fontVariantAlternatesPropertyValue(style.fontDescription().variantAlternates());
         case CSSPropertyFontVariantEastAsian:
             return fontVariantEastAsianPropertyValue(style.fontDescription().variantEastAsianVariant(), style.fontDescription().variantEastAsianWidth(), style.fontDescription().variantEastAsianRuby());
         case CSSPropertyZIndex:
-            if (style.hasAutoZIndex())
+            if (style.hasAutoSpecifiedZIndex())
                 return cssValuePool.createIdentifierValue(CSSValueAuto);
-            return cssValuePool.createValue(style.zIndex(), CSSPrimitiveValue::CSS_NUMBER);
+            return cssValuePool.createValue(style.specifiedZIndex(), CSSUnitType::CSS_NUMBER);
         case CSSPropertyZoom:
-            return cssValuePool.createValue(style.zoom(), CSSPrimitiveValue::CSS_NUMBER);
+            return cssValuePool.createValue(style.zoom(), CSSUnitType::CSS_NUMBER);
         case CSSPropertyBoxSizing:
             if (style.boxSizing() == BoxSizing::ContentBox)
                 return cssValuePool.createIdentifierValue(CSSValueContentBox);
             return cssValuePool.createIdentifierValue(CSSValueBorderBox);
         case CSSPropertyAnimationDelay:
@@ -3619,22 +3275,22 @@
                 for (size_t i = 0; i < t->size(); ++i) {
                     double iterationCount = t->animation(i).iterationCount();
                     if (iterationCount == Animation::IterationCountInfinite)
                         list->append(cssValuePool.createIdentifierValue(CSSValueInfinite));
                     else
-                        list->append(cssValuePool.createValue(iterationCount, CSSPrimitiveValue::CSS_NUMBER));
+                        list->append(cssValuePool.createValue(iterationCount, CSSUnitType::CSS_NUMBER));
                 }
             } else
-                list->append(cssValuePool.createValue(Animation::initialIterationCount(), CSSPrimitiveValue::CSS_NUMBER));
+                list->append(cssValuePool.createValue(Animation::initialIterationCount(), CSSUnitType::CSS_NUMBER));
             return list;
         }
         case CSSPropertyAnimationName: {
             auto list = CSSValueList::createCommaSeparated();
             const AnimationList* t = style.animations();
             if (t) {
                 for (size_t i = 0; i < t->size(); ++i)
-                    list->append(cssValuePool.createValue(t->animation(i).name(), CSSPrimitiveValue::CSS_STRING));
+                    list->append(cssValuePool.createValue(t->animation(i).name(), CSSUnitType::CSS_STRING));
             } else
                 list->append(cssValuePool.createIdentifierValue(CSSValueNone));
             return list;
         }
         case CSSPropertyAnimationPlayState: {
@@ -3700,12 +3356,12 @@
             return cssValuePool.createIdentifierValue(CSSValueNone);
         case CSSPropertyWebkitFontSizeDelta:
             // Not a real style property -- used by the editing engine -- so has no computed value.
             break;
         case CSSPropertyWebkitInitialLetter: {
-            auto drop = !style.initialLetterDrop() ? cssValuePool.createIdentifierValue(CSSValueNormal) : cssValuePool.createValue(style.initialLetterDrop(), CSSPrimitiveValue::CSS_NUMBER);
-            auto size = !style.initialLetterHeight() ? cssValuePool.createIdentifierValue(CSSValueNormal) : cssValuePool.createValue(style.initialLetterHeight(), CSSPrimitiveValue::CSS_NUMBER);
+            auto drop = !style.initialLetterDrop() ? cssValuePool.createIdentifierValue(CSSValueNormal) : cssValuePool.createValue(style.initialLetterDrop(), CSSUnitType::CSS_NUMBER);
+            auto size = !style.initialLetterHeight() ? cssValuePool.createIdentifierValue(CSSValueNormal) : cssValuePool.createValue(style.initialLetterHeight(), CSSUnitType::CSS_NUMBER);
             return cssValuePool.createValue(Pair::create(WTFMove(drop), WTFMove(size)));
         }
         case CSSPropertyWebkitMarginBottomCollapse:
         case CSSPropertyWebkitMarginAfterCollapse:
             return cssValuePool.createValue(style.marginAfterCollapse());
@@ -3716,10 +3372,14 @@
         case CSSPropertyWebkitOverflowScrolling:
             if (!style.useTouchOverflowScrolling())
                 return cssValuePool.createIdentifierValue(CSSValueAuto);
             return cssValuePool.createIdentifierValue(CSSValueTouch);
 #endif
+        case CSSPropertyScrollBehavior:
+            if (!style.useSmoothScrolling())
+                return cssValuePool.createIdentifierValue(CSSValueAuto);
+            return cssValuePool.createIdentifierValue(CSSValueSmooth);
         case CSSPropertyPerspective:
             if (!style.hasPerspective())
                 return cssValuePool.createIdentifierValue(CSSValueNone);
             return zoomAdjustedPixelValue(style.perspective(), style);
         case CSSPropertyPerspectiveOrigin: {
@@ -3814,32 +3474,32 @@
                 auto transitionsList = CSSValueList::createCommaSeparated();
                 for (size_t i = 0; i < animationList->size(); ++i) {
                     auto list = CSSValueList::createSpaceSeparated();
                     auto& animation = animationList->animation(i);
                     list->append(createTransitionPropertyValue(animation));
-                    list->append(cssValuePool.createValue(animation.duration(), CSSPrimitiveValue::CSS_S));
+                    list->append(cssValuePool.createValue(animation.duration(), CSSUnitType::CSS_S));
                     list->append(createTimingFunctionValue(*animation.timingFunction()));
-                    list->append(cssValuePool.createValue(animation.delay(), CSSPrimitiveValue::CSS_S));
+                    list->append(cssValuePool.createValue(animation.delay(), CSSUnitType::CSS_S));
                     transitionsList->append(WTFMove(list));
                 }
                 return transitionsList;
             }
 
             auto list = CSSValueList::createSpaceSeparated();
             // transition-property default value.
             list->append(cssValuePool.createIdentifierValue(CSSValueAll));
-            list->append(cssValuePool.createValue(Animation::initialDuration(), CSSPrimitiveValue::CSS_S));
+            list->append(cssValuePool.createValue(Animation::initialDuration(), CSSUnitType::CSS_S));
             list->append(createTimingFunctionValue(Animation::initialTimingFunction()));
-            list->append(cssValuePool.createValue(Animation::initialDelay(), CSSPrimitiveValue::CSS_S));
+            list->append(cssValuePool.createValue(Animation::initialDelay(), CSSUnitType::CSS_S));
             return list;
         }
         case CSSPropertyPointerEvents:
             return cssValuePool.createValue(style.pointerEvents());
         case CSSPropertyWebkitLineGrid:
             if (style.lineGrid().isNull())
                 return cssValuePool.createIdentifierValue(CSSValueNone);
-            return cssValuePool.createValue(style.lineGrid(), CSSPrimitiveValue::CSS_STRING);
+            return cssValuePool.createValue(style.lineGrid(), CSSUnitType::CSS_STRING);
         case CSSPropertyWebkitLineSnap:
             return CSSPrimitiveValue::create(style.lineSnap());
         case CSSPropertyWebkitLineAlign:
             return CSSPrimitiveValue::create(style.lineAlign());
         case CSSPropertyWritingMode:
@@ -3856,16 +3516,16 @@
             return contentToCSSValue(style);
         case CSSPropertyCounterIncrement:
             return counterToCSSValue(style, propertyID);
         case CSSPropertyCounterReset:
             return counterToCSSValue(style, propertyID);
-        case CSSPropertyWebkitClipPath: {
+        case CSSPropertyClipPath: {
             auto* operation = style.clipPath();
             if (!operation)
                 return cssValuePool.createIdentifierValue(CSSValueNone);
             if (is<ReferenceClipPathOperation>(*operation))
-                return CSSPrimitiveValue::create(downcast<ReferenceClipPathOperation>(*operation).url(), CSSPrimitiveValue::CSS_URI);
+                return CSSPrimitiveValue::create(downcast<ReferenceClipPathOperation>(*operation).url(), CSSUnitType::CSS_URI);
             auto list = CSSValueList::createSpaceSeparated();
             if (is<ShapeClipPathOperation>(*operation)) {
                 auto& shapeOperation = downcast<ShapeClipPathOperation>(*operation);
                 list->append(valueForBasicShape(style, shapeOperation.basicShape()));
                 if (shapeOperation.referenceBox() != CSSBoxType::BoxMissing)
@@ -3876,11 +3536,11 @@
             return list;
         }
         case CSSPropertyShapeMargin:
             return cssValuePool.createValue(style.shapeMargin(), style);
         case CSSPropertyShapeImageThreshold:
-            return cssValuePool.createValue(style.shapeImageThreshold(), CSSPrimitiveValue::CSS_NUMBER);
+            return cssValuePool.createValue(style.shapeImageThreshold(), CSSUnitType::CSS_NUMBER);
         case CSSPropertyShapeOutside:
             return shapePropertyValue(style, style.shapeOutside());
         case CSSPropertyFilter:
             return valueForFilter(style, style.filter());
         case CSSPropertyAppleColorFilter:
@@ -4074,11 +3734,11 @@
         case CSSPropertyStrokeWidth:
             return zoomAdjustedPixelValueForLength(style.strokeWidth(), style);
         case CSSPropertyStrokeColor:
             return currentColorOrValidColor(&style, style.strokeColor());
         case CSSPropertyStrokeMiterlimit:
-            return CSSPrimitiveValue::create(style.strokeMiterLimit(), CSSPrimitiveValue::CSS_NUMBER);
+            return CSSPrimitiveValue::create(style.strokeMiterLimit(), CSSUnitType::CSS_NUMBER);
 
         /* Unimplemented CSS 3 properties (including CSS3 shorthand properties) */
         case CSSPropertyAll:
         case CSSPropertyAnimation:
         case CSSPropertyWebkitTextEmphasis:
@@ -4135,11 +3795,14 @@
             break;
 
         /* Unimplemented -webkit- properties */
         case CSSPropertyWebkitBorderRadius:
         case CSSPropertyWebkitMarginCollapse:
-        case CSSPropertyWebkitMarquee:
+        case CSSPropertyWebkitMarqueeDirection:
+        case CSSPropertyWebkitMarqueeIncrement:
+        case CSSPropertyWebkitMarqueeRepetition:
+        case CSSPropertyWebkitMarqueeStyle:
         case CSSPropertyWebkitMarqueeSpeed:
         case CSSPropertyWebkitMask:
         case CSSPropertyWebkitMaskRepeatX:
         case CSSPropertyWebkitMaskRepeatY:
         case CSSPropertyPerspectiveOriginX:
@@ -4157,11 +3820,10 @@
         case CSSPropertyUserZoom:
             break;
 #endif
 
         case CSSPropertyBufferedRendering:
-        case CSSPropertyClipPath:
         case CSSPropertyClipRule:
         case CSSPropertyMask:
         case CSSPropertyEnableBackground:
         case CSSPropertyFloodColor:
         case CSSPropertyFloodOpacity:
@@ -4196,11 +3858,10 @@
         case CSSPropertyCustom:
             ASSERT_NOT_REACHED();
             return nullptr;
     }
 
-    logUnimplementedPropertyID(propertyID);
     return nullptr;
 }
 
 String CSSComputedStyleDeclaration::getPropertyValue(CSSPropertyID propertyID) const
 {
@@ -4216,35 +3877,35 @@
 
     auto* style = m_element->computedStyle(m_pseudoElementSpecifier);
     if (!style)
         return 0;
 
-    return numComputedProperties + style->inheritedCustomProperties().size() + style->nonInheritedCustomProperties().size();
+    return numComputedPropertyIDs + style->inheritedCustomProperties().size() + style->nonInheritedCustomProperties().size();
 }
 
 String CSSComputedStyleDeclaration::item(unsigned i) const
 {
     if (i >= length())
         return String();
 
-    if (i < numComputedProperties)
-        return getPropertyNameString(computedProperties[i]);
+    if (i < numComputedPropertyIDs)
+        return getPropertyNameString(computedPropertyIDs[i]);
 
     auto* style = m_element->computedStyle(m_pseudoElementSpecifier);
     if (!style)
         return String();
 
     const auto& inheritedCustomProperties = style->inheritedCustomProperties();
 
-    if (i < numComputedProperties + inheritedCustomProperties.size()) {
+    if (i < numComputedPropertyIDs + inheritedCustomProperties.size()) {
         auto results = copyToVector(inheritedCustomProperties.keys());
-        return results.at(i - numComputedProperties);
+        return results.at(i - numComputedPropertyIDs);
     }
 
     const auto& nonInheritedCustomProperties = style->nonInheritedCustomProperties();
     auto results = copyToVector(nonInheritedCustomProperties.keys());
-    return results.at(i - inheritedCustomProperties.size() - numComputedProperties);
+    return results.at(i - inheritedCustomProperties.size() - numComputedPropertyIDs);
 }
 
 bool ComputedStyleExtractor::propertyMatches(CSSPropertyID propertyID, const CSSValue* value)
 {
     if (!m_element)
@@ -4261,15 +3922,10 @@
     }
     RefPtr<CSSValue> computedValue = propertyValue(propertyID);
     return computedValue && value && computedValue->equals(*value);
 }
 
-Ref<MutableStyleProperties> ComputedStyleExtractor::copyProperties()
-{
-    return copyPropertiesInSet(computedProperties, numComputedProperties);
-}
-
 Ref<CSSValueList> ComputedStyleExtractor::getCSSPropertyValuesForShorthandProperties(const StylePropertyShorthand& shorthand)
 {
     auto list = CSSValueList::createSpaceSeparated();
     for (size_t i = 0; i < shorthand.length(); ++i)
         list->append(propertyValue(shorthand.properties()[i], DoNotUpdateLayout).releaseNonNull());
@@ -4334,17 +3990,29 @@
     return list;
 }
 
 Ref<MutableStyleProperties> ComputedStyleExtractor::copyPropertiesInSet(const CSSPropertyID* set, unsigned length)
 {
-    Vector<CSSProperty, 256> list;
+    Vector<CSSProperty> list;
     list.reserveInitialCapacity(length);
     for (unsigned i = 0; i < length; ++i) {
         if (auto value = propertyValue(set[i]))
             list.append(CSSProperty(set[i], WTFMove(value), false));
     }
-    return MutableStyleProperties::create(list.data(), list.size());
+    return MutableStyleProperties::create(WTFMove(list));
+}
+
+Ref<MutableStyleProperties> ComputedStyleExtractor::copyProperties()
+{
+    Vector<CSSProperty> list;
+    list.reserveInitialCapacity(numCSSProperties);
+    for (unsigned i = firstCSSProperty; i < lastCSSProperty; ++i) {
+        auto propertyID = convertToCSSPropertyID(i);
+        if (auto value = propertyValue(propertyID))
+            list.append(CSSProperty(propertyID, WTFMove(value)));
+    }
+    return MutableStyleProperties::create(WTFMove(list));
 }
 
 CSSRule* CSSComputedStyleDeclaration::parentRule() const
 {
     return nullptr;

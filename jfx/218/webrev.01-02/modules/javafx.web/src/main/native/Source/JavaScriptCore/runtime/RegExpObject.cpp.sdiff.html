<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/RegExpObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RegExpMatchesArray.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RegExpObject.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/RegExpObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">  3  *  Copyright (C) 2003-2018 Apple Inc. All Rights Reserved.</span>
  4  *
  5  *  This library is free software; you can redistribute it and/or
  6  *  modify it under the terms of the GNU Lesser General Public
  7  *  License as published by the Free Software Foundation; either
  8  *  version 2 of the License, or (at your option) any later version.
  9  *
 10  *  This library is distributed in the hope that it will be useful,
 11  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  *  Lesser General Public License for more details.
 14  *
 15  *  You should have received a copy of the GNU Lesser General Public
 16  *  License along with this library; if not, write to the Free Software
 17  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 18  *
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;RegExpObject.h&quot;
 23 
</pre>
<hr />
<pre>
 42 {
 43     m_lastIndex.setWithoutWriteBarrier(jsNumber(0));
 44 }
 45 
 46 void RegExpObject::finishCreation(VM&amp; vm)
 47 {
 48     Base::finishCreation(vm);
 49     ASSERT(inherits(vm, info()));
 50     ASSERT(type() == RegExpObjectType);
 51 }
 52 
 53 void RegExpObject::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 54 {
 55     RegExpObject* thisObject = jsCast&lt;RegExpObject*&gt;(cell);
 56     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 57     Base::visitChildren(thisObject, visitor);
 58     visitor.appendUnbarriered(thisObject-&gt;regExp());
 59     visitor.append(thisObject-&gt;m_lastIndex);
 60 }
 61 
<span class="line-modified"> 62 bool RegExpObject::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
 63 {
<span class="line-modified"> 64     VM&amp; vm = exec-&gt;vm();</span>
 65     if (propertyName == vm.propertyNames-&gt;lastIndex) {
 66         RegExpObject* regExp = jsCast&lt;RegExpObject*&gt;(object);
 67         unsigned attributes = regExp-&gt;lastIndexIsWritable() ? PropertyAttribute::DontDelete | PropertyAttribute::DontEnum : PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly;
 68         slot.setValue(regExp, attributes, regExp-&gt;getLastIndex());
 69         return true;
 70     }
<span class="line-modified"> 71     return Base::getOwnPropertySlot(object, exec, propertyName, slot);</span>
 72 }
 73 
<span class="line-modified"> 74 bool RegExpObject::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)</span>
 75 {
<span class="line-modified"> 76     VM&amp; vm = exec-&gt;vm();</span>
 77     if (propertyName == vm.propertyNames-&gt;lastIndex)
 78         return false;
<span class="line-modified"> 79     return Base::deleteProperty(cell, exec, propertyName);</span>
 80 }
 81 
<span class="line-modified"> 82 void RegExpObject::getOwnNonIndexPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
 83 {
<span class="line-modified"> 84     VM&amp; vm = exec-&gt;vm();</span>
 85     if (mode.includeDontEnumProperties())
 86         propertyNames.add(vm.propertyNames-&gt;lastIndex);
<span class="line-modified"> 87     Base::getOwnNonIndexPropertyNames(object, exec, propertyNames, mode);</span>
 88 }
 89 
<span class="line-modified"> 90 void RegExpObject::getPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
 91 {
<span class="line-modified"> 92     VM&amp; vm = exec-&gt;vm();</span>
 93     if (mode.includeDontEnumProperties())
 94         propertyNames.add(vm.propertyNames-&gt;lastIndex);
<span class="line-modified"> 95     Base::getPropertyNames(object, exec, propertyNames, mode);</span>
 96 }
 97 
<span class="line-modified"> 98 void RegExpObject::getGenericPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
 99 {
<span class="line-modified">100     VM&amp; vm = exec-&gt;vm();</span>
101     if (mode.includeDontEnumProperties())
102         propertyNames.add(vm.propertyNames-&gt;lastIndex);
<span class="line-modified">103     Base::getGenericPropertyNames(object, exec, propertyNames, mode);</span>
104 }
105 
<span class="line-modified">106 bool RegExpObject::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
107 {
<span class="line-modified">108     VM&amp; vm = exec-&gt;vm();</span>
109     auto scope = DECLARE_THROW_SCOPE(vm);
110 
111     if (propertyName == vm.propertyNames-&gt;lastIndex) {
112         RegExpObject* regExp = jsCast&lt;RegExpObject*&gt;(object);
113         if (descriptor.configurablePresent() &amp;&amp; descriptor.configurable())
<span class="line-modified">114             return typeError(exec, scope, shouldThrow, UnconfigurablePropertyChangeConfigurabilityError);</span>
115         if (descriptor.enumerablePresent() &amp;&amp; descriptor.enumerable())
<span class="line-modified">116             return typeError(exec, scope, shouldThrow, UnconfigurablePropertyChangeEnumerabilityError);</span>
117         if (descriptor.isAccessorDescriptor())
<span class="line-modified">118             return typeError(exec, scope, shouldThrow, UnconfigurablePropertyChangeAccessMechanismError);</span>
119         if (!regExp-&gt;lastIndexIsWritable()) {
120             if (descriptor.writablePresent() &amp;&amp; descriptor.writable())
<span class="line-modified">121                 return typeError(exec, scope, shouldThrow, UnconfigurablePropertyChangeWritabilityError);</span>
<span class="line-modified">122             if (descriptor.value() &amp;&amp; !sameValue(exec, regExp-&gt;getLastIndex(), descriptor.value()))</span>
<span class="line-modified">123                 return typeError(exec, scope, shouldThrow, ReadonlyPropertyChangeError);</span>




124             return true;
125         }
126         if (descriptor.value()) {
<span class="line-modified">127             regExp-&gt;setLastIndex(exec, descriptor.value(), false);</span>
128             RETURN_IF_EXCEPTION(scope, false);
129         }
130         if (descriptor.writablePresent() &amp;&amp; !descriptor.writable())
131             regExp-&gt;setLastIndexIsNotWritable();
132         return true;
133     }
134 
<span class="line-modified">135     RELEASE_AND_RETURN(scope, Base::defineOwnProperty(object, exec, propertyName, descriptor, shouldThrow));</span>
136 }
137 
<span class="line-modified">138 static bool regExpObjectSetLastIndexStrict(ExecState* exec, EncodedJSValue thisValue, EncodedJSValue value)</span>
139 {
<span class="line-modified">140     return jsCast&lt;RegExpObject*&gt;(JSValue::decode(thisValue))-&gt;setLastIndex(exec, JSValue::decode(value), true);</span>
141 }
142 
<span class="line-modified">143 static bool regExpObjectSetLastIndexNonStrict(ExecState* exec, EncodedJSValue thisValue, EncodedJSValue value)</span>
144 {
<span class="line-modified">145     return jsCast&lt;RegExpObject*&gt;(JSValue::decode(thisValue))-&gt;setLastIndex(exec, JSValue::decode(value), false);</span>
146 }
147 
<span class="line-modified">148 bool RegExpObject::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
149 {
<span class="line-modified">150     VM&amp; vm = exec-&gt;vm();</span>
151     RegExpObject* thisObject = jsCast&lt;RegExpObject*&gt;(cell);
152 
153     if (UNLIKELY(isThisValueAltered(slot, thisObject)))
<span class="line-modified">154         return ordinarySetSlow(exec, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode());</span>
155 
156     if (propertyName == vm.propertyNames-&gt;lastIndex) {
<span class="line-modified">157         bool result = thisObject-&gt;setLastIndex(exec, value, slot.isStrictMode());</span>
158         slot.setCustomValue(thisObject, slot.isStrictMode()
159             ? regExpObjectSetLastIndexStrict
160             : regExpObjectSetLastIndexNonStrict);
161         return result;
162     }
<span class="line-modified">163     return Base::put(cell, exec, propertyName, value, slot);</span>
164 }
165 
<span class="line-modified">166 JSValue RegExpObject::exec(ExecState* exec, JSGlobalObject* globalObject, JSString* string)</span>
167 {
<span class="line-modified">168     return execInline(exec, globalObject, string);</span>
169 }
170 
171 // Shared implementation used by test and exec.
<span class="line-modified">172 MatchResult RegExpObject::match(ExecState* exec, JSGlobalObject* globalObject, JSString* string)</span>
173 {
<span class="line-modified">174     return matchInline(exec, globalObject, string);</span>
175 }
176 
<span class="line-modified">177 JSValue RegExpObject::matchGlobal(ExecState* exec, JSGlobalObject* globalObject, JSString* string)</span>
178 {
179     VM&amp; vm = globalObject-&gt;vm();
180     auto scope = DECLARE_THROW_SCOPE(vm);
181     RegExp* regExp = this-&gt;regExp();
182 
183     ASSERT(regExp-&gt;global());
184 
<span class="line-modified">185     setLastIndex(exec, 0);</span>
186     RETURN_IF_EXCEPTION(scope, { });
187 
<span class="line-modified">188     String s = string-&gt;value(exec);</span>
189     RETURN_IF_EXCEPTION(scope, { });
190 
191     ASSERT(!s.isNull());
192     if (regExp-&gt;unicode()) {
193         unsigned stringLength = s.length();
194         RELEASE_AND_RETURN(scope, collectMatches(
<span class="line-modified">195             vm, exec, string, s, globalObject, regExp,</span>
196             [&amp;] (size_t end) -&gt; size_t {
197                 return advanceStringUnicode(s, stringLength, end);
198             }));
199     }
200 
201     RELEASE_AND_RETURN(scope, collectMatches(
<span class="line-modified">202         vm, exec, string, s, globalObject, regExp,</span>
203         [&amp;] (size_t end) -&gt; size_t {
204             return end + 1;
205         }));
206 }
207 
208 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">  3  *  Copyright (C) 2003-2019 Apple Inc. All Rights Reserved.</span>
  4  *
  5  *  This library is free software; you can redistribute it and/or
  6  *  modify it under the terms of the GNU Lesser General Public
  7  *  License as published by the Free Software Foundation; either
  8  *  version 2 of the License, or (at your option) any later version.
  9  *
 10  *  This library is distributed in the hope that it will be useful,
 11  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  *  Lesser General Public License for more details.
 14  *
 15  *  You should have received a copy of the GNU Lesser General Public
 16  *  License along with this library; if not, write to the Free Software
 17  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 18  *
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;RegExpObject.h&quot;
 23 
</pre>
<hr />
<pre>
 42 {
 43     m_lastIndex.setWithoutWriteBarrier(jsNumber(0));
 44 }
 45 
 46 void RegExpObject::finishCreation(VM&amp; vm)
 47 {
 48     Base::finishCreation(vm);
 49     ASSERT(inherits(vm, info()));
 50     ASSERT(type() == RegExpObjectType);
 51 }
 52 
 53 void RegExpObject::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 54 {
 55     RegExpObject* thisObject = jsCast&lt;RegExpObject*&gt;(cell);
 56     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 57     Base::visitChildren(thisObject, visitor);
 58     visitor.appendUnbarriered(thisObject-&gt;regExp());
 59     visitor.append(thisObject-&gt;m_lastIndex);
 60 }
 61 
<span class="line-modified"> 62 bool RegExpObject::getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
 63 {
<span class="line-modified"> 64     VM&amp; vm = globalObject-&gt;vm();</span>
 65     if (propertyName == vm.propertyNames-&gt;lastIndex) {
 66         RegExpObject* regExp = jsCast&lt;RegExpObject*&gt;(object);
 67         unsigned attributes = regExp-&gt;lastIndexIsWritable() ? PropertyAttribute::DontDelete | PropertyAttribute::DontEnum : PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly;
 68         slot.setValue(regExp, attributes, regExp-&gt;getLastIndex());
 69         return true;
 70     }
<span class="line-modified"> 71     return Base::getOwnPropertySlot(object, globalObject, propertyName, slot);</span>
 72 }
 73 
<span class="line-modified"> 74 bool RegExpObject::deleteProperty(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)</span>
 75 {
<span class="line-modified"> 76     VM&amp; vm = globalObject-&gt;vm();</span>
 77     if (propertyName == vm.propertyNames-&gt;lastIndex)
 78         return false;
<span class="line-modified"> 79     return Base::deleteProperty(cell, globalObject, propertyName);</span>
 80 }
 81 
<span class="line-modified"> 82 void RegExpObject::getOwnNonIndexPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
 83 {
<span class="line-modified"> 84     VM&amp; vm = globalObject-&gt;vm();</span>
 85     if (mode.includeDontEnumProperties())
 86         propertyNames.add(vm.propertyNames-&gt;lastIndex);
<span class="line-modified"> 87     Base::getOwnNonIndexPropertyNames(object, globalObject, propertyNames, mode);</span>
 88 }
 89 
<span class="line-modified"> 90 void RegExpObject::getPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
 91 {
<span class="line-modified"> 92     VM&amp; vm = globalObject-&gt;vm();</span>
 93     if (mode.includeDontEnumProperties())
 94         propertyNames.add(vm.propertyNames-&gt;lastIndex);
<span class="line-modified"> 95     Base::getPropertyNames(object, globalObject, propertyNames, mode);</span>
 96 }
 97 
<span class="line-modified"> 98 void RegExpObject::getGenericPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
 99 {
<span class="line-modified">100     VM&amp; vm = globalObject-&gt;vm();</span>
101     if (mode.includeDontEnumProperties())
102         propertyNames.add(vm.propertyNames-&gt;lastIndex);
<span class="line-modified">103     Base::getGenericPropertyNames(object, globalObject, propertyNames, mode);</span>
104 }
105 
<span class="line-modified">106 bool RegExpObject::defineOwnProperty(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
107 {
<span class="line-modified">108     VM&amp; vm = globalObject-&gt;vm();</span>
109     auto scope = DECLARE_THROW_SCOPE(vm);
110 
111     if (propertyName == vm.propertyNames-&gt;lastIndex) {
112         RegExpObject* regExp = jsCast&lt;RegExpObject*&gt;(object);
113         if (descriptor.configurablePresent() &amp;&amp; descriptor.configurable())
<span class="line-modified">114             return typeError(globalObject, scope, shouldThrow, UnconfigurablePropertyChangeConfigurabilityError);</span>
115         if (descriptor.enumerablePresent() &amp;&amp; descriptor.enumerable())
<span class="line-modified">116             return typeError(globalObject, scope, shouldThrow, UnconfigurablePropertyChangeEnumerabilityError);</span>
117         if (descriptor.isAccessorDescriptor())
<span class="line-modified">118             return typeError(globalObject, scope, shouldThrow, UnconfigurablePropertyChangeAccessMechanismError);</span>
119         if (!regExp-&gt;lastIndexIsWritable()) {
120             if (descriptor.writablePresent() &amp;&amp; descriptor.writable())
<span class="line-modified">121                 return typeError(globalObject, scope, shouldThrow, UnconfigurablePropertyChangeWritabilityError);</span>
<span class="line-modified">122             if (descriptor.value()) {</span>
<span class="line-modified">123                 bool isSame = sameValue(globalObject, regExp-&gt;getLastIndex(), descriptor.value());</span>
<span class="line-added">124                 RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">125                 if (!isSame)</span>
<span class="line-added">126                     return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyChangeError);</span>
<span class="line-added">127             }</span>
128             return true;
129         }
130         if (descriptor.value()) {
<span class="line-modified">131             regExp-&gt;setLastIndex(globalObject, descriptor.value(), false);</span>
132             RETURN_IF_EXCEPTION(scope, false);
133         }
134         if (descriptor.writablePresent() &amp;&amp; !descriptor.writable())
135             regExp-&gt;setLastIndexIsNotWritable();
136         return true;
137     }
138 
<span class="line-modified">139     RELEASE_AND_RETURN(scope, Base::defineOwnProperty(object, globalObject, propertyName, descriptor, shouldThrow));</span>
140 }
141 
<span class="line-modified">142 static bool regExpObjectSetLastIndexStrict(JSGlobalObject* globalObject, EncodedJSValue thisValue, EncodedJSValue value)</span>
143 {
<span class="line-modified">144     return jsCast&lt;RegExpObject*&gt;(JSValue::decode(thisValue))-&gt;setLastIndex(globalObject, JSValue::decode(value), true);</span>
145 }
146 
<span class="line-modified">147 static bool regExpObjectSetLastIndexNonStrict(JSGlobalObject* globalObject, EncodedJSValue thisValue, EncodedJSValue value)</span>
148 {
<span class="line-modified">149     return jsCast&lt;RegExpObject*&gt;(JSValue::decode(thisValue))-&gt;setLastIndex(globalObject, JSValue::decode(value), false);</span>
150 }
151 
<span class="line-modified">152 bool RegExpObject::put(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
153 {
<span class="line-modified">154     VM&amp; vm = globalObject-&gt;vm();</span>
155     RegExpObject* thisObject = jsCast&lt;RegExpObject*&gt;(cell);
156 
157     if (UNLIKELY(isThisValueAltered(slot, thisObject)))
<span class="line-modified">158         return ordinarySetSlow(globalObject, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode());</span>
159 
160     if (propertyName == vm.propertyNames-&gt;lastIndex) {
<span class="line-modified">161         bool result = thisObject-&gt;setLastIndex(globalObject, value, slot.isStrictMode());</span>
162         slot.setCustomValue(thisObject, slot.isStrictMode()
163             ? regExpObjectSetLastIndexStrict
164             : regExpObjectSetLastIndexNonStrict);
165         return result;
166     }
<span class="line-modified">167     return Base::put(cell, globalObject, propertyName, value, slot);</span>
168 }
169 
<span class="line-modified">170 JSValue RegExpObject::exec(JSGlobalObject* globalObject, JSString* string)</span>
171 {
<span class="line-modified">172     return execInline(globalObject, string);</span>
173 }
174 
175 // Shared implementation used by test and exec.
<span class="line-modified">176 MatchResult RegExpObject::match(JSGlobalObject* globalObject, JSString* string)</span>
177 {
<span class="line-modified">178     return matchInline(globalObject, string);</span>
179 }
180 
<span class="line-modified">181 JSValue RegExpObject::matchGlobal(JSGlobalObject* globalObject, JSString* string)</span>
182 {
183     VM&amp; vm = globalObject-&gt;vm();
184     auto scope = DECLARE_THROW_SCOPE(vm);
185     RegExp* regExp = this-&gt;regExp();
186 
187     ASSERT(regExp-&gt;global());
188 
<span class="line-modified">189     setLastIndex(globalObject, 0);</span>
190     RETURN_IF_EXCEPTION(scope, { });
191 
<span class="line-modified">192     String s = string-&gt;value(globalObject);</span>
193     RETURN_IF_EXCEPTION(scope, { });
194 
195     ASSERT(!s.isNull());
196     if (regExp-&gt;unicode()) {
197         unsigned stringLength = s.length();
198         RELEASE_AND_RETURN(scope, collectMatches(
<span class="line-modified">199             vm, globalObject, string, s, regExp,</span>
200             [&amp;] (size_t end) -&gt; size_t {
201                 return advanceStringUnicode(s, stringLength, end);
202             }));
203     }
204 
205     RELEASE_AND_RETURN(scope, collectMatches(
<span class="line-modified">206         vm, globalObject, string, s, regExp,</span>
207         [&amp;] (size_t end) -&gt; size_t {
208             return end + 1;
209         }));
210 }
211 
212 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="RegExpMatchesArray.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RegExpObject.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
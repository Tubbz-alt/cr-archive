diff a/modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerContainer.cpp b/modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerContainer.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerContainer.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerContainer.cpp
@@ -26,48 +26,61 @@
 #include "config.h"
 #include "ServiceWorkerContainer.h"
 
 #if ENABLE(SERVICE_WORKER)
 
+#include "DOMPromiseProxy.h"
 #include "Document.h"
 #include "Event.h"
+#include "EventLoop.h"
 #include "EventNames.h"
 #include "Exception.h"
 #include "IDLTypes.h"
 #include "JSDOMPromiseDeferred.h"
 #include "JSServiceWorkerRegistration.h"
+#include "LegacySchemeRegistry.h"
 #include "Logging.h"
 #include "MessageEvent.h"
 #include "NavigatorBase.h"
+#include "Page.h"
 #include "ResourceError.h"
-#include "SchemeRegistry.h"
 #include "ScriptExecutionContext.h"
 #include "SecurityOrigin.h"
 #include "ServiceWorker.h"
 #include "ServiceWorkerFetchResult.h"
 #include "ServiceWorkerGlobalScope.h"
 #include "ServiceWorkerJob.h"
 #include "ServiceWorkerJobData.h"
 #include "ServiceWorkerProvider.h"
 #include "ServiceWorkerThread.h"
+#include "WorkerSWClientConnection.h"
 #include <wtf/IsoMallocInlines.h>
 #include <wtf/RunLoop.h>
 #include <wtf/Scope.h>
 #include <wtf/URL.h>
 
 #define CONTAINER_RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), ServiceWorker, "%p - ServiceWorkerContainer::" fmt, this, ##__VA_ARGS__)
 #define CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED(fmt, ...) RELEASE_LOG_ERROR_IF(isAlwaysOnLoggingAllowed(), ServiceWorker, "%p - ServiceWorkerContainer::" fmt, this, ##__VA_ARGS__)
 
 namespace WebCore {
 
+static inline SWClientConnection& mainThreadConnection()
+{
+    return ServiceWorkerProvider::singleton().serviceWorkerConnection();
+}
+
 WTF_MAKE_ISO_ALLOCATED_IMPL(ServiceWorkerContainer);
 
 ServiceWorkerContainer::ServiceWorkerContainer(ScriptExecutionContext* context, NavigatorBase& navigator)
     : ActiveDOMObject(context)
     , m_navigator(navigator)
 {
     suspendIfNeeded();
+
+    // We should queue messages until the DOMContentLoaded event has fired or startMessages() has been called.
+    if (is<Document>(context) && downcast<Document>(*context).parsing())
+        m_shouldDeferMessageEvents = true;
 }
 
 ServiceWorkerContainer::~ServiceWorkerContainer()
 {
 #ifndef NDEBUG
@@ -88,27 +101,18 @@
 auto ServiceWorkerContainer::ready() -> ReadyPromise&
 {
     if (!m_readyPromise) {
         m_readyPromise = makeUnique<ReadyPromise>();
 
-        if (m_isStopped || !scriptExecutionContext()->sessionID().isValid())
+        if (m_isStopped)
             return *m_readyPromise;
 
         auto& context = *scriptExecutionContext();
-        auto contextIdentifier = this->contextIdentifier();
-        callOnMainThread([connection = makeRef(ensureSWClientConnection()), topOrigin = context.topOrigin().isolatedCopy(), clientURL = context.url().isolatedCopy(), contextIdentifier]() mutable {
-            connection->whenRegistrationReady(topOrigin, clientURL, [contextIdentifier](auto&& registrationData) {
-                ScriptExecutionContext::postTaskTo(contextIdentifier, [registrationData = crossThreadCopy(registrationData)](auto& context) mutable {
-                    auto* serviceWorkerContainer = context.serviceWorkerContainer();
-                    if (!serviceWorkerContainer)
-                        return;
-                    if (serviceWorkerContainer->m_isStopped || !context.sessionID().isValid())
-                        return;
-
-                    auto registration = ServiceWorkerRegistration::getOrCreate(context, *serviceWorkerContainer, WTFMove(registrationData));
-                    serviceWorkerContainer->m_readyPromise->resolve(WTFMove(registration));
-                });
+        ensureSWClientConnection().whenRegistrationReady(context.topOrigin().data(), context.url(), [this, protectedThis = makeRef(*this)](auto&& registrationData) mutable {
+            queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [this, registrationData = WTFMove(registrationData)]() mutable {
+                auto registration = ServiceWorkerRegistration::getOrCreate(*scriptExecutionContext(), *this, WTFMove(registrationData));
+                m_readyPromise->resolve(WTFMove(registration));
             });
         });
     }
     return *m_readyPromise;
 }
@@ -121,11 +125,11 @@
 }
 
 void ServiceWorkerContainer::addRegistration(const String& relativeScriptURL, const RegistrationOptions& options, Ref<DeferredPromise>&& promise)
 {
     auto* context = scriptExecutionContext();
-    if (m_isStopped || !context->sessionID().isValid()) {
+    if (m_isStopped) {
         promise->reject(Exception(InvalidStateError));
         return;
     }
 
     if (relativeScriptURL.isEmpty()) {
@@ -140,11 +144,11 @@
         CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED("addRegistration: Invalid scriptURL");
         promise->reject(Exception { TypeError, "serviceWorker.register() must be called with a valid relative script URL"_s });
         return;
     }
 
-    if (!SchemeRegistry::canServiceWorkersHandleURLScheme(jobData.scriptURL.protocol().toStringWithoutCopying())) {
+    if (!LegacySchemeRegistry::canServiceWorkersHandleURLScheme(jobData.scriptURL.protocol().toStringWithoutCopying())) {
         CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED("addRegistration: Invalid scriptURL scheme is not HTTP or HTTPS");
         promise->reject(Exception { TypeError, "serviceWorker.register() must be called with a script URL whose protocol is either HTTP or HTTPS"_s });
         return;
     }
 
@@ -158,11 +162,11 @@
     if (!options.scope.isEmpty())
         jobData.scopeURL = context->completeURL(options.scope);
     else
         jobData.scopeURL = URL(jobData.scriptURL, "./");
 
-    if (!jobData.scopeURL.isNull() && !SchemeRegistry::canServiceWorkersHandleURLScheme(jobData.scopeURL.protocol().toStringWithoutCopying())) {
+    if (!jobData.scopeURL.isNull() && !LegacySchemeRegistry::canServiceWorkersHandleURLScheme(jobData.scopeURL.protocol().toStringWithoutCopying())) {
         CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED("addRegistration: scopeURL scheme is not HTTP or HTTPS");
         promise->reject(Exception { TypeError, "Scope URL provided to serviceWorker.register() must be either HTTP or HTTPS"_s });
         return;
     }
 
@@ -184,11 +188,11 @@
 }
 
 void ServiceWorkerContainer::removeRegistration(const URL& scopeURL, Ref<DeferredPromise>&& promise)
 {
     auto* context = scriptExecutionContext();
-    if (!context || !context->sessionID().isValid()) {
+    if (!context) {
         ASSERT_NOT_REACHED();
         promise->reject(Exception(InvalidStateError));
         return;
     }
 
@@ -212,11 +216,10 @@
 void ServiceWorkerContainer::updateRegistration(const URL& scopeURL, const URL& scriptURL, WorkerType, RefPtr<DeferredPromise>&& promise)
 {
     ASSERT(!m_isStopped);
 
     auto& context = *scriptExecutionContext();
-    ASSERT(context.sessionID().isValid());
 
     if (!m_swConnection) {
         ASSERT_NOT_REACHED();
         if (promise)
             promise->reject(Exception(InvalidStateError));
@@ -247,139 +250,88 @@
     auto& jobData = job->data();
     auto jobIdentifier = job->identifier();
     ASSERT(!m_jobMap.contains(jobIdentifier));
     m_jobMap.add(jobIdentifier, OngoingJob { WTFMove(job), makePendingActivity(*this) });
 
-    callOnMainThread([connection = m_swConnection, contextIdentifier = this->contextIdentifier(), jobData = jobData.isolatedCopy()] {
-        connection->scheduleJob(contextIdentifier, jobData);
-    });
+    m_swConnection->scheduleJob(contextIdentifier(), jobData);
 }
 
 void ServiceWorkerContainer::getRegistration(const String& clientURL, Ref<DeferredPromise>&& promise)
 {
-    auto* context = scriptExecutionContext();
-    if (m_isStopped || !context->sessionID().isValid()) {
+    if (m_isStopped) {
         promise->reject(Exception { InvalidStateError });
         return;
     }
 
-    URL parsedURL = context->completeURL(clientURL);
-    if (!protocolHostAndPortAreEqual(parsedURL, context->url())) {
+    auto& context = *scriptExecutionContext();
+    URL parsedURL = context.completeURL(clientURL);
+    if (!protocolHostAndPortAreEqual(parsedURL, context.url())) {
         promise->reject(Exception { SecurityError, "Origin of clientURL is not client's origin"_s });
         return;
     }
 
-    uint64_t pendingPromiseIdentifier = ++m_lastPendingPromiseIdentifier;
-    auto pendingPromise = makeUnique<PendingPromise>(WTFMove(promise), makePendingActivity(*this));
-    m_pendingPromises.add(pendingPromiseIdentifier, WTFMove(pendingPromise));
-
-    auto contextIdentifier = this->contextIdentifier();
-    callOnMainThread([connection = makeRef(ensureSWClientConnection()), topOrigin = context->topOrigin().data().isolatedCopy(), parsedURL = parsedURL.isolatedCopy(), contextIdentifier, pendingPromiseIdentifier]() mutable {
-        connection->matchRegistration(WTFMove(topOrigin), parsedURL, [contextIdentifier, pendingPromiseIdentifier] (auto&& result) mutable {
-            ScriptExecutionContext::postTaskTo(contextIdentifier, [pendingPromiseIdentifier, result = crossThreadCopy(result)](auto& context) mutable {
-                auto* serviceWorkerContainer = context.serviceWorkerContainer();
-                if (!serviceWorkerContainer)
-                    return;
-                if (serviceWorkerContainer->m_isStopped || !context.sessionID().isValid())
-                    return;
-
-                serviceWorkerContainer->didFinishGetRegistrationRequest(pendingPromiseIdentifier, WTFMove(result));
-            });
+    ensureSWClientConnection().matchRegistration(SecurityOriginData { context.topOrigin().data() }, parsedURL, [this, protectedThis = makeRef(*this), promise = WTFMove(promise)](auto&& result) mutable {
+        queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [this, promise = WTFMove(promise), result = WTFMove(result)]() mutable {
+            if (!result) {
+                promise->resolve();
+                return;
+            }
+            promise->resolve<IDLInterface<ServiceWorkerRegistration>>(ServiceWorkerRegistration::getOrCreate(*scriptExecutionContext(), *this, WTFMove(result.value())));
         });
     });
 }
 
-void ServiceWorkerContainer::didFinishGetRegistrationRequest(uint64_t pendingPromiseIdentifier, Optional<ServiceWorkerRegistrationData>&& result)
+void ServiceWorkerContainer::updateRegistrationState(ServiceWorkerRegistrationIdentifier identifier, ServiceWorkerRegistrationState state, const Optional<ServiceWorkerData>& serviceWorkerData)
 {
-#ifndef NDEBUG
-    ASSERT(m_creationThread.ptr() == &Thread::current());
-#endif
-
-    auto pendingPromise = m_pendingPromises.take(pendingPromiseIdentifier);
-    if (!pendingPromise)
-        return;
-
-    if (m_isStopped || !scriptExecutionContext()->sessionID().isValid()) {
-        pendingPromise->promise->reject(Exception { InvalidStateError });
+    if (m_isStopped)
         return;
-    }
 
-    if (!result) {
-        pendingPromise->promise->resolve();
-        return;
-    }
+    queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [this, identifier, state, serviceWorkerData = Optional<ServiceWorkerData> { serviceWorkerData }]() mutable {
+        RefPtr<ServiceWorker> serviceWorker;
+        if (serviceWorkerData)
+            serviceWorker = ServiceWorker::getOrCreate(*scriptExecutionContext(), WTFMove(*serviceWorkerData));
 
-    auto registration = ServiceWorkerRegistration::getOrCreate(*scriptExecutionContext(), *this, WTFMove(result.value()));
-    pendingPromise->promise->resolve<IDLInterface<ServiceWorkerRegistration>>(WTFMove(registration));
+        if (auto* registration = m_registrations.get(identifier))
+            registration->updateStateFromServer(state, WTFMove(serviceWorker));
+    });
 }
 
-void ServiceWorkerContainer::updateRegistrationState(ServiceWorkerRegistrationIdentifier identifier, ServiceWorkerRegistrationState state, const Optional<ServiceWorkerData>& serviceWorkerData)
+void ServiceWorkerContainer::updateWorkerState(ServiceWorkerIdentifier identifier, ServiceWorkerState state)
 {
     if (m_isStopped)
         return;
 
-    RefPtr<ServiceWorker> serviceWorker;
-    if (serviceWorkerData)
-        serviceWorker = ServiceWorker::getOrCreate(*scriptExecutionContext(), ServiceWorkerData { *serviceWorkerData });
-
-    if (auto* registration = m_registrations.get(identifier))
-        registration->updateStateFromServer(state, WTFMove(serviceWorker));
+    queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [this, identifier, state] {
+        if (auto* serviceWorker = scriptExecutionContext()->serviceWorker(identifier))
+            serviceWorker->updateState(state);
+    });
 }
 
 void ServiceWorkerContainer::getRegistrations(Ref<DeferredPromise>&& promise)
 {
-    auto* context = scriptExecutionContext();
-    if (m_isStopped || !context->sessionID().isValid()) {
+    if (m_isStopped) {
         promise->reject(Exception { InvalidStateError });
         return;
     }
 
-    uint64_t pendingPromiseIdentifier = ++m_lastPendingPromiseIdentifier;
-    auto pendingPromise = makeUnique<PendingPromise>(WTFMove(promise), makePendingActivity(*this));
-    m_pendingPromises.add(pendingPromiseIdentifier, WTFMove(pendingPromise));
-
-    auto contextIdentifier = this->contextIdentifier();
-    auto contextURL = context->url();
-    callOnMainThread([connection = makeRef(ensureSWClientConnection()), topOrigin = context->topOrigin().data().isolatedCopy(), contextURL = contextURL.isolatedCopy(), contextIdentifier, pendingPromiseIdentifier]() mutable {
-        connection->getRegistrations(WTFMove(topOrigin), contextURL, [contextIdentifier, pendingPromiseIdentifier] (auto&& registrationDatas) mutable {
-            ScriptExecutionContext::postTaskTo(contextIdentifier, [pendingPromiseIdentifier, registrationDatas = crossThreadCopy(registrationDatas)](auto& context) mutable {
-                auto* serviceWorkerContainer = context.serviceWorkerContainer();
-                if (!serviceWorkerContainer)
-                    return;
-                if (serviceWorkerContainer->m_isStopped || !context.sessionID().isValid())
-                    return;
-
-                serviceWorkerContainer->didFinishGetRegistrationsRequest(pendingPromiseIdentifier, WTFMove(registrationDatas));
+    auto& context = *scriptExecutionContext();
+    ensureSWClientConnection().getRegistrations(SecurityOriginData { context.topOrigin().data() }, context.url(), [this, protectedThis = makeRef(*this), promise = WTFMove(promise)] (auto&& registrationDatas) mutable {
+        queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [this, promise = WTFMove(promise), registrationDatas = WTFMove(registrationDatas)]() mutable {
+            auto registrations = WTF::map(WTFMove(registrationDatas), [&](auto&& registrationData) {
+                return ServiceWorkerRegistration::getOrCreate(*scriptExecutionContext(), *this, WTFMove(registrationData));
             });
+            promise->resolve<IDLSequence<IDLInterface<ServiceWorkerRegistration>>>(WTFMove(registrations));
         });
     });
 }
 
-void ServiceWorkerContainer::didFinishGetRegistrationsRequest(uint64_t pendingPromiseIdentifier, Vector<ServiceWorkerRegistrationData>&& registrationDatas)
-{
-#ifndef NDEBUG
-    ASSERT(m_creationThread.ptr() == &Thread::current());
-#endif
-
-    auto pendingPromise = m_pendingPromises.take(pendingPromiseIdentifier);
-    if (!pendingPromise)
-        return;
-
-    if (m_isStopped || !scriptExecutionContext()->sessionID().isValid()) {
-        pendingPromise->promise->reject(Exception { InvalidStateError });
-        return;
-    }
-
-    auto registrations = WTF::map(WTFMove(registrationDatas), [&] (auto&& registrationData) {
-        return ServiceWorkerRegistration::getOrCreate(*this->scriptExecutionContext(), *this, WTFMove(registrationData));
-    });
-
-    pendingPromise->promise->resolve<IDLSequence<IDLInterface<ServiceWorkerRegistration>>>(WTFMove(registrations));
-}
-
 void ServiceWorkerContainer::startMessages()
 {
+    m_shouldDeferMessageEvents = false;
+    auto deferredMessageEvents = WTFMove(m_deferredMessageEvents);
+    for (auto& messageEvent : deferredMessageEvents)
+        queueTaskToDispatchEvent(*this, TaskSource::DOMManipulation, WTFMove(messageEvent));
 }
 
 void ServiceWorkerContainer::jobFailedWithException(ServiceWorkerJob& job, const Exception& exception)
 {
 #ifndef NDEBUG
@@ -396,25 +348,23 @@
 
     auto promise = job.takePromise();
     if (!promise)
         return;
 
-    if (auto* context = scriptExecutionContext()) {
-        context->postTask([promise = WTFMove(promise), exception](auto&) mutable {
-            promise->reject(exception);
-        });
-    }
+    queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [promise = WTFMove(promise), exception]() mutable {
+        promise->reject(exception);
+    });
 }
 
-void ServiceWorkerContainer::fireUpdateFoundEvent(ServiceWorkerRegistrationIdentifier identifier)
+void ServiceWorkerContainer::queueTaskToFireUpdateFoundEvent(ServiceWorkerRegistrationIdentifier identifier)
 {
 #ifndef NDEBUG
     ASSERT(m_creationThread.ptr() == &Thread::current());
 #endif
 
     if (auto* registration = m_registrations.get(identifier))
-        registration->fireUpdateFoundEvent();
+        registration->queueTaskToFireUpdateFoundEvent();
 }
 
 void ServiceWorkerContainer::jobResolvedWithRegistration(ServiceWorkerJob& job, ServiceWorkerRegistrationData&& data, ShouldNotifyWhenResolved shouldNotifyWhenResolved)
 {
 #ifndef NDEBUG
@@ -431,39 +381,37 @@
 
     auto guard = WTF::makeScopeExit([this, &job] {
         destroyJob(job);
     });
 
-    auto notifyIfExitEarly = WTF::makeScopeExit([this, &data, &shouldNotifyWhenResolved] {
+    auto notifyIfExitEarly = WTF::makeScopeExit([this, protectedThis = makeRef(*this), key = data.key, shouldNotifyWhenResolved] {
         if (shouldNotifyWhenResolved == ShouldNotifyWhenResolved::Yes)
-            notifyRegistrationIsSettled(data.key);
+            notifyRegistrationIsSettled(key);
     });
 
     if (isStopped())
         return;
 
     auto promise = job.takePromise();
     if (!promise)
         return;
 
-    notifyIfExitEarly.release();
+    queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [this, protectedThis = makeRef(*this), promise = WTFMove(promise), jobIdentifier = job.identifier(), data = WTFMove(data), shouldNotifyWhenResolved, notifyIfExitEarly = WTFMove(notifyIfExitEarly)]() mutable {
+        notifyIfExitEarly.release();
 
-    scriptExecutionContext()->postTask([this, protectedThis = RefPtr<ServiceWorkerContainer>(this), promise = WTFMove(promise), jobIdentifier = job.identifier(), data = WTFMove(data), shouldNotifyWhenResolved](ScriptExecutionContext& context) mutable {
-        if (isStopped() || !context.sessionID().isValid()) {
-            if (shouldNotifyWhenResolved == ShouldNotifyWhenResolved::Yes)
-                notifyRegistrationIsSettled(data.key);
-            return;
-        }
-
-        auto registration = ServiceWorkerRegistration::getOrCreate(context, *this, WTFMove(data));
+        auto registration = ServiceWorkerRegistration::getOrCreate(*scriptExecutionContext(), *this, WTFMove(data));
 
         CONTAINER_RELEASE_LOG_IF_ALLOWED("jobResolvedWithRegistration: Resolving promise for job %" PRIu64 ". Registration ID: %" PRIu64, jobIdentifier.toUInt64(), registration->identifier().toUInt64());
 
         if (shouldNotifyWhenResolved == ShouldNotifyWhenResolved::Yes) {
             m_ongoingSettledRegistrations.add(++m_lastOngoingSettledRegistrationIdentifier, registration->data().key);
             promise->whenSettled([this, protectedThis = WTFMove(protectedThis), identifier = m_lastOngoingSettledRegistrationIdentifier] {
-                notifyRegistrationIsSettled(m_ongoingSettledRegistrations.take(identifier));
+                auto iterator = m_ongoingSettledRegistrations.find(identifier);
+                if (iterator == m_ongoingSettledRegistrations.end())
+                    return;
+                notifyRegistrationIsSettled(iterator->value);
+                m_ongoingSettledRegistrations.remove(iterator);
             });
         }
 
         promise->resolve<IDLInterface<ServiceWorkerRegistration>>(WTFMove(registration));
     });
@@ -473,18 +421,21 @@
 {
     auto& context = *scriptExecutionContext();
     MessageEventSource source = RefPtr<ServiceWorker> { ServiceWorker::getOrCreate(context, WTFMove(sourceData)) };
 
     auto messageEvent = MessageEvent::create(MessagePort::entanglePorts(context, WTFMove(message.transferredPorts)), message.message.releaseNonNull(), sourceOrigin, { }, WTFMove(source));
-    dispatchEvent(messageEvent);
+    if (m_shouldDeferMessageEvents)
+        m_deferredMessageEvents.append(WTFMove(messageEvent));
+    else {
+        ASSERT(m_deferredMessageEvents.isEmpty());
+        queueTaskToDispatchEvent(*this, TaskSource::DOMManipulation, WTFMove(messageEvent));
+    }
 }
 
 void ServiceWorkerContainer::notifyRegistrationIsSettled(const ServiceWorkerRegistrationKey& registrationKey)
 {
-    callOnMainThread([connection = m_swConnection, registrationKey = registrationKey.isolatedCopy()] {
-        connection->didResolveRegistrationPromise(registrationKey);
-    });
+    ensureSWClientConnection().didResolveRegistrationPromise(registrationKey);
 }
 
 void ServiceWorkerContainer::jobResolvedWithUnregistrationResult(ServiceWorkerJob& job, bool unregistrationResult)
 {
 #ifndef NDEBUG
@@ -503,11 +454,11 @@
     if (!context) {
         LOG_ERROR("ServiceWorkerContainer::jobResolvedWithUnregistrationResult called but the containers ScriptExecutionContext is gone");
         return;
     }
 
-    context->postTask([promise = job.takePromise(), unregistrationResult](auto&) mutable {
+    queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [promise = job.takePromise(), unregistrationResult]() mutable {
         promise->resolve<IDLBoolean>(unregistrationResult);
     });
 }
 
 void ServiceWorkerContainer::startScriptFetchForJob(ServiceWorkerJob& job, FetchOptions::Cache cachePolicy)
@@ -535,13 +486,11 @@
     ASSERT(m_creationThread.ptr() == &Thread::current());
 #endif
 
     CONTAINER_RELEASE_LOG_IF_ALLOWED("jobFinishedLoadingScript: Successfuly finished fetching script for job %" PRIu64, job.identifier().toUInt64());
 
-    callOnMainThread([connection = m_swConnection, jobDataIdentifier = job.data().identifier(), registrationKey = job.data().registrationKey().isolatedCopy(), script = script.isolatedCopy(), contentSecurityPolicy = contentSecurityPolicy.isolatedCopy(), referrerPolicy = referrerPolicy.isolatedCopy()] {
-        connection->finishFetchingScriptInServer({ jobDataIdentifier, registrationKey, script, contentSecurityPolicy, referrerPolicy, { } });
-    });
+    ensureSWClientConnection().finishFetchingScriptInServer({ job.data().identifier(), job.data().registrationKey(), script, contentSecurityPolicy, referrerPolicy, { } });
 }
 
 void ServiceWorkerContainer::jobFailedLoadingScript(ServiceWorkerJob& job, const ResourceError& error, Exception&& exception)
 {
 #ifndef NDEBUG
@@ -549,22 +498,23 @@
 #endif
     ASSERT_WITH_MESSAGE(job.hasPromise() || job.data().type == ServiceWorkerJobType::Update, "Only soft updates have no promise");
 
     CONTAINER_RELEASE_LOG_ERROR_IF_ALLOWED("jobFinishedLoadingScript: Failed to fetch script for job %" PRIu64 ", error: %s", job.identifier().toUInt64(), error.localizedDescription().utf8().data());
 
-    if (auto promise = job.takePromise())
-        promise->reject(WTFMove(exception));
+    if (auto promise = job.takePromise()) {
+        queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [promise = WTFMove(promise), exception = WTFMove(exception)]() mutable {
+            promise->reject(WTFMove(exception));
+        });
+    }
 
     notifyFailedFetchingScript(job, error);
     destroyJob(job);
 }
 
 void ServiceWorkerContainer::notifyFailedFetchingScript(ServiceWorkerJob& job, const ResourceError& error)
 {
-    callOnMainThread([connection = m_swConnection, jobIdentifier = job.identifier(), registrationKey = job.data().registrationKey().isolatedCopy(), error = error.isolatedCopy()] {
-        connection->failedFetchingScript(jobIdentifier, registrationKey, error);
-    });
+    ensureSWClientConnection().finishFetchingScriptInServer(serviceWorkerFetchError(job.data().identifier(), ServiceWorkerRegistrationKey { job.data().registrationKey() }, ResourceError { error }));
 }
 
 void ServiceWorkerContainer::destroyJob(ServiceWorkerJob& job)
 {
 #ifndef NDEBUG
@@ -578,24 +528,19 @@
 const char* ServiceWorkerContainer::activeDOMObjectName() const
 {
     return "ServiceWorkerContainer";
 }
 
-bool ServiceWorkerContainer::canSuspendForDocumentSuspension() const
-{
-    return !hasPendingActivity();
-}
-
 SWClientConnection& ServiceWorkerContainer::ensureSWClientConnection()
 {
     ASSERT(scriptExecutionContext());
-    ASSERT(scriptExecutionContext()->sessionID().isValid());
     if (!m_swConnection) {
-        ASSERT(scriptExecutionContext());
-        callOnMainThreadAndWait([this, sessionID = scriptExecutionContext()->sessionID()]() {
-            m_swConnection = &ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(sessionID);
-        });
+        auto& context = *scriptExecutionContext();
+        if (is<WorkerGlobalScope>(context))
+            m_swConnection = &downcast<WorkerGlobalScope>(context).swClientConnection();
+        else
+            m_swConnection = &mainThreadConnection();
     }
     return *m_swConnection;
 }
 
 void ServiceWorkerContainer::addRegistration(ServiceWorkerRegistration& registration)
@@ -616,27 +561,23 @@
 
     m_swConnection->removeServiceWorkerRegistrationInServer(registration.identifier());
     m_registrations.remove(registration.identifier());
 }
 
-void ServiceWorkerContainer::fireControllerChangeEvent()
+void ServiceWorkerContainer::queueTaskToDispatchControllerChangeEvent()
 {
 #ifndef NDEBUG
     ASSERT(m_creationThread.ptr() == &Thread::current());
 #endif
 
-    if (m_isStopped)
-        return;
-
-    dispatchEvent(Event::create(eventNames().controllerchangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
+    queueTaskToDispatchEvent(*this, TaskSource::DOMManipulation, Event::create(eventNames().controllerchangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
 }
 
 void ServiceWorkerContainer::stop()
 {
     m_isStopped = true;
     removeAllEventListeners();
-    m_pendingPromises.clear();
     m_readyPromise = nullptr;
     auto jobMap = WTFMove(m_jobMap);
     for (auto& ongoingJob : jobMap.values()) {
         if (ongoingJob.job->cancelPendingLoad())
             notifyFailedFetchingScript(*ongoingJob.job.get(), ResourceError { errorDomainWebKitInternal, 0, ongoingJob.job->data().scriptURL, "Job cancelled"_s, ResourceError::Type::Cancellation });
@@ -671,15 +612,27 @@
 {
     auto* context = scriptExecutionContext();
     if (!context)
         return false;
 
-    if (is<Document>(*context))
-        return downcast<Document>(*context).sessionID().isAlwaysOnLoggingAllowed();
+    if (is<Document>(*context)) {
+        auto* page = downcast<Document>(*context).page();
+        return page && page->sessionID().isAlwaysOnLoggingAllowed();
+    }
 
     // FIXME: No logging inside service workers for now.
     return false;
 }
 
+bool ServiceWorkerContainer::addEventListener(const AtomString& eventType, Ref<EventListener>&& eventListener, const AddEventListenerOptions& options)
+{
+    // Setting the onmessage EventHandler attribute on the ServiceWorkerContainer should start the messages
+    // automatically.
+    if (eventListener->isAttribute() && eventType == eventNames().messageEvent)
+        startMessages();
+
+    return EventTargetWithInlineData::addEventListener(eventType, WTFMove(eventListener), options);
+}
+
 } // namespace WebCore
 
 #endif // ENABLE(SERVICE_WORKER)

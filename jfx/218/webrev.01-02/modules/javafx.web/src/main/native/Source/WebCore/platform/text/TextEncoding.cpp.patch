diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/text/TextEncoding.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/text/TextEncoding.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/text/TextEncoding.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/text/TextEncoding.cpp
@@ -33,29 +33,33 @@
 #include "TextEncodingRegistry.h"
 #include <wtf/NeverDestroyed.h>
 #include <wtf/StdLibExtras.h>
 #include <wtf/text/StringView.h>
 
+#if USE(JAVA_UNICODE)
+#include "TextNormalizerJava.h"
+#endif
+
 namespace WebCore {
 
 static const TextEncoding& UTF7Encoding()
 {
     static NeverDestroyed<TextEncoding> globalUTF7Encoding("UTF-7");
     return globalUTF7Encoding;
 }
 
 TextEncoding::TextEncoding(const char* name)
-    : m_name(atomicCanonicalTextEncodingName(name))
+    : m_name(atomCanonicalTextEncodingName(name))
     , m_backslashAsCurrencySymbol(backslashAsCurrencySymbol())
 {
     // Aliases are valid, but not "replacement" itself.
     if (equalLettersIgnoringASCIICase(name, "replacement"))
         m_name = nullptr;
 }
 
 TextEncoding::TextEncoding(const String& name)
-    : m_name(atomicCanonicalTextEncodingName(name))
+    : m_name(atomCanonicalTextEncodingName(name))
     , m_backslashAsCurrencySymbol(backslashAsCurrencySymbol())
 {
     // Aliases are valid, but not "replacement" itself.
     if (equalLettersIgnoringASCIICase(name, "replacement"))
         m_name = nullptr;
@@ -75,12 +79,17 @@
         return { };
 
     // FIXME: What's the right place to do normalization?
     // It's a little strange to do it inside the encode function.
     // Perhaps normalization should be an explicit step done before calling encode.
+#if !USE(JAVA_UNICODE)
     auto normalizedString = normalizedNFC(string);
     return newTextCodec(*this)->encode(normalizedString.view, handling);
+#else
+    String normalized = TextNormalizer::normalize(text.upconvertedCharacters(), text.length(), TextNormalizer::NFC);
+    return newTextCodec(*this)->encode(StringView { normalized.characters16(), normalized.length() }, handling);
+#endif
 }
 
 const char* TextEncoding::domName() const
 {
     if (noExtendedTextEncodingNameUsed())
@@ -91,22 +100,22 @@
     // most Korean web servers even though they do use the encoding
     // 'windows-949' with the name 'EUC-KR'.
     // FIXME: This is not thread-safe. At the moment, this function is
     // only accessed in a single thread, but eventually has to be made
     // thread-safe along with usesVisualOrdering().
-    static const char* const a = atomicCanonicalTextEncodingName("windows-949");
+    static const char* const a = atomCanonicalTextEncodingName("windows-949");
     if (m_name == a)
         return "EUC-KR";
     return m_name;
 }
 
 bool TextEncoding::usesVisualOrdering() const
 {
     if (noExtendedTextEncodingNameUsed())
         return false;
 
-    static const char* const a = atomicCanonicalTextEncodingName("ISO-8859-8");
+    static const char* const a = atomCanonicalTextEncodingName("ISO-8859-8");
     return m_name == a;
 }
 
 bool TextEncoding::isJapanese() const
 {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/svg/SVGSVGElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGRectElement.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGSVGElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/svg/SVGSVGElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2004, 2005, 2006 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;</span>
  3  * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2010 Rob Buis &lt;buis@kde.org&gt;
  4  * Copyright (C) 2007-2019 Apple Inc. All rights reserved.
  5  * Copyright (C) 2014 Adobe Systems Incorporated. All rights reserved.
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  */
 22 
 23 #include &quot;config.h&quot;
 24 #include &quot;SVGSVGElement.h&quot;
 25 
 26 #include &quot;CSSHelper.h&quot;

 27 #include &quot;DOMWrapperWorld.h&quot;
 28 #include &quot;ElementIterator.h&quot;
 29 #include &quot;EventNames.h&quot;
 30 #include &quot;Frame.h&quot;
 31 #include &quot;FrameSelection.h&quot;
 32 #include &quot;RenderSVGResource.h&quot;
 33 #include &quot;RenderSVGRoot.h&quot;
 34 #include &quot;RenderSVGViewportContainer.h&quot;
 35 #include &quot;RenderView.h&quot;
 36 #include &quot;SMILTimeContainer.h&quot;
 37 #include &quot;SVGAngle.h&quot;
 38 #include &quot;SVGDocumentExtensions.h&quot;
 39 #include &quot;SVGLength.h&quot;
 40 #include &quot;SVGMatrix.h&quot;
 41 #include &quot;SVGNumber.h&quot;
 42 #include &quot;SVGPoint.h&quot;
 43 #include &quot;SVGRect.h&quot;
 44 #include &quot;SVGTransform.h&quot;
 45 #include &quot;SVGViewElement.h&quot;
 46 #include &quot;SVGViewSpec.h&quot;
 47 #include &quot;StaticNodeList.h&quot;
 48 #include &lt;wtf/IsoMallocInlines.h&gt;
 49 
 50 namespace WebCore {
 51 
 52 WTF_MAKE_ISO_ALLOCATED_IMPL(SVGSVGElement);
 53 
 54 inline SVGSVGElement::SVGSVGElement(const QualifiedName&amp; tagName, Document&amp; document)
 55     : SVGGraphicsElement(tagName, document)
<span class="line-removed"> 56     , SVGExternalResourcesRequired(this)</span>
 57     , SVGFitToViewBox(this)
 58     , m_timeContainer(SMILTimeContainer::create(*this))
 59 {
 60     ASSERT(hasTagName(SVGNames::svgTag));
 61     document.registerForDocumentSuspensionCallbacks(*this);
 62 
 63     static std::once_flag onceFlag;
 64     std::call_once(onceFlag, [] {
 65         PropertyRegistry::registerProperty&lt;SVGNames::xAttr, &amp;SVGSVGElement::m_x&gt;();
 66         PropertyRegistry::registerProperty&lt;SVGNames::yAttr, &amp;SVGSVGElement::m_y&gt;();
 67         PropertyRegistry::registerProperty&lt;SVGNames::widthAttr, &amp;SVGSVGElement::m_width&gt;();
 68         PropertyRegistry::registerProperty&lt;SVGNames::heightAttr, &amp;SVGSVGElement::m_height&gt;();
 69     });
 70 }
 71 
 72 Ref&lt;SVGSVGElement&gt; SVGSVGElement::create(const QualifiedName&amp; tagName, Document&amp; document)
 73 {
 74     return adoptRef(*new SVGSVGElement(tagName, document));
 75 }
 76 
 77 Ref&lt;SVGSVGElement&gt; SVGSVGElement::create(Document&amp; document)
 78 {
 79     return create(SVGNames::svgTag, document);
 80 }
 81 
 82 SVGSVGElement::~SVGSVGElement()
 83 {
 84     if (m_viewSpec)
 85         m_viewSpec-&gt;resetContextElement();
 86     document().unregisterForDocumentSuspensionCallbacks(*this);
 87     document().accessSVGExtensions().removeTimeContainer(*this);
 88 }
 89 
 90 void SVGSVGElement::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
 91 {
 92     oldDocument.unregisterForDocumentSuspensionCallbacks(*this);
 93     document().registerForDocumentSuspensionCallbacks(*this);
 94     SVGGraphicsElement::didMoveToNewDocument(oldDocument, newDocument);
 95 }
 96 
<span class="line-removed"> 97 const AtomString&amp; SVGSVGElement::contentScriptType() const</span>
<span class="line-removed"> 98 {</span>
<span class="line-removed"> 99     static NeverDestroyed&lt;AtomString&gt; defaultScriptType { &quot;text/ecmascript&quot; };</span>
<span class="line-removed">100     const AtomString&amp; type = attributeWithoutSynchronization(SVGNames::contentScriptTypeAttr);</span>
<span class="line-removed">101     return type.isNull() ? defaultScriptType.get() : type;</span>
<span class="line-removed">102 }</span>
<span class="line-removed">103 </span>
<span class="line-removed">104 void SVGSVGElement::setContentScriptType(const AtomString&amp; type)</span>
<span class="line-removed">105 {</span>
<span class="line-removed">106     setAttributeWithoutSynchronization(SVGNames::contentScriptTypeAttr, type);</span>
<span class="line-removed">107 }</span>
<span class="line-removed">108 </span>
<span class="line-removed">109 const AtomString&amp; SVGSVGElement::contentStyleType() const</span>
<span class="line-removed">110 {</span>
<span class="line-removed">111     static NeverDestroyed&lt;AtomString&gt; defaultStyleType { &quot;text/css&quot; };</span>
<span class="line-removed">112     const AtomString&amp; type = attributeWithoutSynchronization(SVGNames::contentStyleTypeAttr);</span>
<span class="line-removed">113     return type.isNull() ? defaultStyleType.get() : type;</span>
<span class="line-removed">114 }</span>
<span class="line-removed">115 </span>
<span class="line-removed">116 void SVGSVGElement::setContentStyleType(const AtomString&amp; type)</span>
<span class="line-removed">117 {</span>
<span class="line-removed">118     setAttributeWithoutSynchronization(SVGNames::contentStyleTypeAttr, type);</span>
<span class="line-removed">119 }</span>
<span class="line-removed">120 </span>
<span class="line-removed">121 Ref&lt;SVGRect&gt; SVGSVGElement::viewport() const</span>
<span class="line-removed">122 {</span>
<span class="line-removed">123     // FIXME: Not implemented.</span>
<span class="line-removed">124     return SVGRect::create();</span>
<span class="line-removed">125 }</span>
<span class="line-removed">126 </span>
<span class="line-removed">127 float SVGSVGElement::pixelUnitToMillimeterX() const</span>
<span class="line-removed">128 {</span>
<span class="line-removed">129     // There are 25.4 millimeters in an inch.</span>
<span class="line-removed">130     return 25.4f / cssPixelsPerInch;</span>
<span class="line-removed">131 }</span>
<span class="line-removed">132 </span>
<span class="line-removed">133 float SVGSVGElement::pixelUnitToMillimeterY() const</span>
<span class="line-removed">134 {</span>
<span class="line-removed">135     // There are 25.4 millimeters in an inch.</span>
<span class="line-removed">136     return 25.4f / cssPixelsPerInch;</span>
<span class="line-removed">137 }</span>
<span class="line-removed">138 </span>
<span class="line-removed">139 float SVGSVGElement::screenPixelToMillimeterX() const</span>
<span class="line-removed">140 {</span>
<span class="line-removed">141     return pixelUnitToMillimeterX();</span>
<span class="line-removed">142 }</span>
<span class="line-removed">143 </span>
<span class="line-removed">144 float SVGSVGElement::screenPixelToMillimeterY() const</span>
<span class="line-removed">145 {</span>
<span class="line-removed">146     return pixelUnitToMillimeterY();</span>
<span class="line-removed">147 }</span>
<span class="line-removed">148 </span>
149 SVGViewSpec&amp; SVGSVGElement::currentView()
150 {
151     if (!m_viewSpec)
152         m_viewSpec = SVGViewSpec::create(*this);
153     return *m_viewSpec;
154 }
155 
156 RefPtr&lt;Frame&gt; SVGSVGElement::frameForCurrentScale() const
157 {
158     // The behavior of currentScale() is undefined when we&#39;re dealing with non-standalone SVG documents.
159     // If the document is embedded, the scaling is handled by the host renderer.
160     if (!isConnected() || !isOutermostSVGSVGElement())
161         return nullptr;
162     auto frame = makeRefPtr(document().frame());
163     return frame &amp;&amp; frame-&gt;isMainFrame() ? frame : nullptr;
164 }
165 
166 float SVGSVGElement::currentScale() const
167 {
168     // When asking from inside an embedded SVG document, a scale value of 1 seems reasonable, as it doesn&#39;t
</pre>
<hr />
<pre>
178 }
179 
180 void SVGSVGElement::setCurrentTranslate(const FloatPoint&amp; translation)
181 {
182     if (m_currentTranslate-&gt;value() == translation)
183         return;
184     m_currentTranslate-&gt;setValue(translation);
185     updateCurrentTranslate();
186 }
187 
188 void SVGSVGElement::updateCurrentTranslate()
189 {
190     if (RenderObject* object = renderer())
191         object-&gt;setNeedsLayout();
192     if (parentNode() == &amp;document() &amp;&amp; document().renderView())
193         document().renderView()-&gt;repaint();
194 }
195 
196 void SVGSVGElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
197 {
<span class="line-modified">198     if (!nearestViewportElement()) {</span>
199         // For these events, the outermost &lt;svg&gt; element works like a &lt;body&gt; element does,
200         // setting certain event handlers directly on the window object.
201         if (name == HTMLNames::onunloadAttr) {
202             document().setWindowAttributeEventListener(eventNames().unloadEvent, name, value, mainThreadNormalWorld());
203             return;
204         }
205         if (name == HTMLNames::onresizeAttr) {
206             document().setWindowAttributeEventListener(eventNames().resizeEvent, name, value, mainThreadNormalWorld());
207             return;
208         }
209         if (name == HTMLNames::onscrollAttr) {
210             document().setWindowAttributeEventListener(eventNames().scrollEvent, name, value, mainThreadNormalWorld());
211             return;
212         }
213         if (name == SVGNames::onzoomAttr) {
214             document().setWindowAttributeEventListener(eventNames().zoomEvent, name, value, mainThreadNormalWorld());
215             return;
216         }
<span class="line-modified">217     }</span>
<span class="line-modified">218 </span>
<span class="line-modified">219     // For these events, any &lt;svg&gt; element works like a &lt;body&gt; element does,</span>
<span class="line-modified">220     // setting certain event handlers directly on the window object.</span>
<span class="line-modified">221     // FIXME: Why different from the events above that work only on the outermost &lt;svg&gt; element?</span>
<span class="line-modified">222     if (name == HTMLNames::onabortAttr) {</span>
<span class="line-modified">223         document().setWindowAttributeEventListener(eventNames().abortEvent, name, value, mainThreadNormalWorld());</span>
<span class="line-modified">224         return;</span>
<span class="line-removed">225     }</span>
<span class="line-removed">226     if (name == HTMLNames::onerrorAttr) {</span>
<span class="line-removed">227         document().setWindowAttributeEventListener(eventNames().errorEvent, name, value, mainThreadNormalWorld());</span>
<span class="line-removed">228         return;</span>
229     }
230 
231     SVGParsingError parseError = NoError;
232 
233     if (name == SVGNames::xAttr)
<span class="line-modified">234         m_x-&gt;setBaseValInternal(SVGLengthValue::construct(LengthModeWidth, value, parseError));</span>
235     else if (name == SVGNames::yAttr)
<span class="line-modified">236         m_y-&gt;setBaseValInternal(SVGLengthValue::construct(LengthModeHeight, value, parseError));</span>
237     else if (name == SVGNames::widthAttr) {
<span class="line-modified">238         auto length = SVGLengthValue::construct(LengthModeWidth, value, parseError, ForbidNegativeLengths);</span>
239         if (parseError != NoError || value.isEmpty()) {
240             // FIXME: This is definitely the correct behavior for a missing/removed attribute.
241             // Not sure it&#39;s correct for the empty string or for something that can&#39;t be parsed.
<span class="line-modified">242             length = SVGLengthValue(LengthModeWidth, &quot;100%&quot;_s);</span>
243         }
244         m_width-&gt;setBaseValInternal(length);
245     } else if (name == SVGNames::heightAttr) {
<span class="line-modified">246         auto length = SVGLengthValue::construct(LengthModeHeight, value, parseError, ForbidNegativeLengths);</span>
247         if (parseError != NoError || value.isEmpty()) {
248             // FIXME: This is definitely the correct behavior for a removed attribute.
249             // Not sure it&#39;s correct for the empty string or for something that can&#39;t be parsed.
<span class="line-modified">250             length = SVGLengthValue(LengthModeHeight, &quot;100%&quot;_s);</span>
251         }
252         m_height-&gt;setBaseValInternal(length);
253     }
254 
255     reportAttributeParsingError(parseError, name, value);
256 
257     SVGGraphicsElement::parseAttribute(name, value);
<span class="line-removed">258     SVGExternalResourcesRequired::parseAttribute(name, value);</span>
259     SVGFitToViewBox::parseAttribute(name, value);
260     SVGZoomAndPan::parseAttribute(name, value);
261 }
262 
263 void SVGSVGElement::svgAttributeChanged(const QualifiedName&amp; attrName)
264 {
265     if (PropertyRegistry::isKnownAttribute(attrName)) {
266         InstanceInvalidationGuard guard(*this);
267         invalidateSVGPresentationAttributeStyle();
268 
269         if (auto renderer = this-&gt;renderer())
270             RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer);
271         return;
272     }
273 
274     if (SVGFitToViewBox::isKnownAttribute(attrName)) {
275         if (auto* renderer = this-&gt;renderer()) {
276             renderer-&gt;setNeedsTransformUpdate();
277             RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer);
278         }
279         return;
280     }
281 
282     SVGGraphicsElement::svgAttributeChanged(attrName);
<span class="line-removed">283     SVGExternalResourcesRequired::svgAttributeChanged(attrName);</span>
<span class="line-removed">284 }</span>
<span class="line-removed">285 </span>
<span class="line-removed">286 unsigned SVGSVGElement::suspendRedraw(unsigned)</span>
<span class="line-removed">287 {</span>
<span class="line-removed">288     return 0;</span>
<span class="line-removed">289 }</span>
<span class="line-removed">290 </span>
<span class="line-removed">291 void SVGSVGElement::unsuspendRedraw(unsigned)</span>
<span class="line-removed">292 {</span>
<span class="line-removed">293 }</span>
<span class="line-removed">294 </span>
<span class="line-removed">295 void SVGSVGElement::unsuspendRedrawAll()</span>
<span class="line-removed">296 {</span>
<span class="line-removed">297 }</span>
<span class="line-removed">298 </span>
<span class="line-removed">299 void SVGSVGElement::forceRedraw()</span>
<span class="line-removed">300 {</span>
301 }
302 
303 Ref&lt;NodeList&gt; SVGSVGElement::collectIntersectionOrEnclosureList(SVGRect&amp; rect, SVGElement* referenceElement, bool (*checkFunction)(SVGElement&amp;, SVGRect&amp;))
304 {
305     Vector&lt;Ref&lt;Element&gt;&gt; elements;
306     for (auto&amp; element : descendantsOfType&lt;SVGElement&gt;(referenceElement ? *referenceElement : *this)) {
307         if (checkFunction(element, rect))
308             elements.append(element);
309     }
310     return StaticElementList::create(WTFMove(elements));
311 }
312 
313 static bool checkIntersectionWithoutUpdatingLayout(SVGElement&amp; element, SVGRect&amp; rect)
314 {
315     return RenderSVGModelObject::checkIntersection(element.renderer(), rect.value());
316 }
317 
318 static bool checkEnclosureWithoutUpdatingLayout(SVGElement&amp; element, SVGRect&amp; rect)
319 {
320     return RenderSVGModelObject::checkEnclosure(element.renderer(), rect.value());
321 }
322 
323 Ref&lt;NodeList&gt; SVGSVGElement::getIntersectionList(SVGRect&amp; rect, SVGElement* referenceElement)
324 {
325     document().updateLayoutIgnorePendingStylesheets();
326     return collectIntersectionOrEnclosureList(rect, referenceElement, checkIntersectionWithoutUpdatingLayout);
327 }
328 
329 Ref&lt;NodeList&gt; SVGSVGElement::getEnclosureList(SVGRect&amp; rect, SVGElement* referenceElement)
330 {
331     document().updateLayoutIgnorePendingStylesheets();
332     return collectIntersectionOrEnclosureList(rect, referenceElement, checkEnclosureWithoutUpdatingLayout);
333 }
334 
<span class="line-modified">335 bool SVGSVGElement::checkIntersection(RefPtr&lt;SVGElement&gt;&amp;&amp; element, SVGRect&amp; rect)</span>
336 {
<span class="line-removed">337     if (!element)</span>
<span class="line-removed">338         return false;</span>
339     element-&gt;document().updateLayoutIgnorePendingStylesheets();
<span class="line-modified">340     return checkIntersectionWithoutUpdatingLayout(*element, rect);</span>
341 }
342 
<span class="line-modified">343 bool SVGSVGElement::checkEnclosure(RefPtr&lt;SVGElement&gt;&amp;&amp; element, SVGRect&amp; rect)</span>
344 {
<span class="line-removed">345     if (!element)</span>
<span class="line-removed">346         return false;</span>
347     element-&gt;document().updateLayoutIgnorePendingStylesheets();
<span class="line-modified">348     return checkEnclosureWithoutUpdatingLayout(*element, rect);</span>
349 }
350 
351 void SVGSVGElement::deselectAll()
352 {
353     if (auto frame = makeRefPtr(document().frame()))
354         frame-&gt;selection().clear();
355 }
356 
357 Ref&lt;SVGNumber&gt; SVGSVGElement::createSVGNumber()
358 {
359     return SVGNumber::create();
360 }
361 
362 Ref&lt;SVGLength&gt; SVGSVGElement::createSVGLength()
363 {
364     return SVGLength::create();
365 }
366 
367 Ref&lt;SVGAngle&gt; SVGSVGElement::createSVGAngle()
368 {
</pre>
<hr />
<pre>
372 Ref&lt;SVGPoint&gt; SVGSVGElement::createSVGPoint()
373 {
374     return SVGPoint::create();
375 }
376 
377 Ref&lt;SVGMatrix&gt; SVGSVGElement::createSVGMatrix()
378 {
379     return SVGMatrix::create();
380 }
381 
382 Ref&lt;SVGRect&gt; SVGSVGElement::createSVGRect()
383 {
384     return SVGRect::create();
385 }
386 
387 Ref&lt;SVGTransform&gt; SVGSVGElement::createSVGTransform()
388 {
389     return SVGTransform::create(SVGTransformValue::SVG_TRANSFORM_MATRIX);
390 }
391 
<span class="line-modified">392 Ref&lt;SVGTransform&gt; SVGSVGElement::createSVGTransformFromMatrix(SVGMatrix&amp; matrix)</span>
393 {
<span class="line-modified">394     return SVGTransform::create(matrix.value());</span>













395 }
396 
397 AffineTransform SVGSVGElement::localCoordinateSpaceTransform(SVGLocatable::CTMScope mode) const
398 {
399     AffineTransform viewBoxTransform;
400     if (!hasEmptyViewBox()) {
401         FloatSize size = currentViewportSize();
402         viewBoxTransform = viewBoxToViewTransform(size.width(), size.height());
403     }
404 
405     AffineTransform transform;
406     if (!isOutermostSVGSVGElement()) {
407         SVGLengthContext lengthContext(this);
408         transform.translate(x().value(lengthContext), y().value(lengthContext));
409     } else if (mode == SVGLocatable::ScreenScope) {
410         if (auto* renderer = this-&gt;renderer()) {
411             FloatPoint location;
412             float zoomFactor = 1;
413 
414             // At the SVG/HTML boundary (aka RenderSVGRoot), we apply the localToBorderBoxTransform
</pre>
<hr />
<pre>
559 
560     if (renderer()) {
561         if (is&lt;RenderSVGRoot&gt;(*renderer())) {
562             auto&amp; root = downcast&lt;RenderSVGRoot&gt;(*renderer());
563             viewportSize = root.contentBoxRect().size() / root.style().effectiveZoom();
564         } else
565             viewportSize = downcast&lt;RenderSVGViewportContainer&gt;(*renderer()).viewport().size();
566     }
567 
568     if (!viewportSize.isEmpty())
569         return viewportSize;
570 
571     if (!(hasIntrinsicWidth() &amp;&amp; hasIntrinsicHeight()))
572         return { };
573 
574     return FloatSize(floatValueForLength(intrinsicWidth(), 0), floatValueForLength(intrinsicHeight(), 0));
575 }
576 
577 bool SVGSVGElement::hasIntrinsicWidth() const
578 {
<span class="line-modified">579     return width().unitType() != LengthTypePercentage;</span>
580 }
581 
582 bool SVGSVGElement::hasIntrinsicHeight() const
583 {
<span class="line-modified">584     return height().unitType() != LengthTypePercentage;</span>
585 }
586 
587 Length SVGSVGElement::intrinsicWidth() const
588 {
<span class="line-modified">589     if (width().unitType() == LengthTypePercentage)</span>
590         return Length(0, Fixed);
591 
592     SVGLengthContext lengthContext(this);
593     return Length(width().value(lengthContext), Fixed);
594 }
595 
596 Length SVGSVGElement::intrinsicHeight() const
597 {
<span class="line-modified">598     if (height().unitType() == LengthTypePercentage)</span>
599         return Length(0, Fixed);
600 
601     SVGLengthContext lengthContext(this);
602     return Length(height().value(lengthContext), Fixed);
603 }
604 
605 AffineTransform SVGSVGElement::viewBoxToViewTransform(float viewWidth, float viewHeight) const
606 {
607     if (!m_useCurrentView || !m_viewSpec)
608         return SVGFitToViewBox::viewBoxToViewTransform(currentViewBoxRect(), preserveAspectRatio(), viewWidth, viewHeight);
609 
610     AffineTransform transform = SVGFitToViewBox::viewBoxToViewTransform(currentViewBoxRect(), m_viewSpec-&gt;preserveAspectRatio(), viewWidth, viewHeight);
611     transform *= m_viewSpec-&gt;transform()-&gt;concatenate();
612     return transform;
613 }
614 
615 SVGViewElement* SVGSVGElement::findViewAnchor(const String&amp; fragmentIdentifier) const
616 {
617     auto* anchorElement = document().findAnchor(fragmentIdentifier);
618     return is&lt;SVGViewElement&gt;(anchorElement) ? downcast&lt;SVGViewElement&gt;(anchorElement): nullptr;
</pre>
<hr />
<pre>
649     }
650 
651     if (fragmentIdentifier.startsWith(&quot;svgView(&quot;)) {
652         if (!view)
653             view = &amp;currentView(); // Create the SVGViewSpec.
654         if (view-&gt;parseViewSpec(fragmentIdentifier))
655             m_useCurrentView = true;
656         else
657             view-&gt;reset();
658         if (renderer &amp;&amp; (hadUseCurrentView || m_useCurrentView))
659             RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer);
660         return m_useCurrentView;
661     }
662 
663     // Spec: If the SVG fragment identifier addresses a &quot;view&quot; element within an SVG document (e.g., MyDrawing.svg#MyView
664     // or MyDrawing.svg#xpointer(id(&#39;MyView&#39;))) then the closest ancestor &quot;svg&quot; element is displayed in the viewport.
665     // Any view specification attributes included on the given &quot;view&quot; element override the corresponding view specification
666     // attributes on the closest ancestor &quot;svg&quot; element.
667     if (auto* viewElement = findViewAnchor(fragmentIdentifier)) {
668         if (auto* rootElement = findRootAnchor(viewElement)) {













669             rootElement-&gt;inheritViewAttributes(*viewElement);
670             if (auto* renderer = rootElement-&gt;renderer())
671                 RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer);
672             m_currentViewFragmentIdentifier = fragmentIdentifier;
673             return true;
674         }
675     }
676 
677     // FIXME: We need to decide which &lt;svg&gt; to focus on, and zoom to it.
678     // FIXME: We need to actually &quot;highlight&quot; the viewTarget(s).
679     return false;
680 }
681 
682 void SVGSVGElement::resetScrollAnchor()
683 {
684     if (!m_useCurrentView &amp;&amp; m_currentViewFragmentIdentifier.isEmpty())
685         return;
686 
687     if (m_viewSpec)
688         m_viewSpec-&gt;reset();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2004, 2005, 2006, 2019 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;</span>
  3  * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2010 Rob Buis &lt;buis@kde.org&gt;
  4  * Copyright (C) 2007-2019 Apple Inc. All rights reserved.
  5  * Copyright (C) 2014 Adobe Systems Incorporated. All rights reserved.
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  */
 22 
 23 #include &quot;config.h&quot;
 24 #include &quot;SVGSVGElement.h&quot;
 25 
 26 #include &quot;CSSHelper.h&quot;
<span class="line-added"> 27 #include &quot;DOMMatrix2DInit.h&quot;</span>
 28 #include &quot;DOMWrapperWorld.h&quot;
 29 #include &quot;ElementIterator.h&quot;
 30 #include &quot;EventNames.h&quot;
 31 #include &quot;Frame.h&quot;
 32 #include &quot;FrameSelection.h&quot;
 33 #include &quot;RenderSVGResource.h&quot;
 34 #include &quot;RenderSVGRoot.h&quot;
 35 #include &quot;RenderSVGViewportContainer.h&quot;
 36 #include &quot;RenderView.h&quot;
 37 #include &quot;SMILTimeContainer.h&quot;
 38 #include &quot;SVGAngle.h&quot;
 39 #include &quot;SVGDocumentExtensions.h&quot;
 40 #include &quot;SVGLength.h&quot;
 41 #include &quot;SVGMatrix.h&quot;
 42 #include &quot;SVGNumber.h&quot;
 43 #include &quot;SVGPoint.h&quot;
 44 #include &quot;SVGRect.h&quot;
 45 #include &quot;SVGTransform.h&quot;
 46 #include &quot;SVGViewElement.h&quot;
 47 #include &quot;SVGViewSpec.h&quot;
 48 #include &quot;StaticNodeList.h&quot;
 49 #include &lt;wtf/IsoMallocInlines.h&gt;
 50 
 51 namespace WebCore {
 52 
 53 WTF_MAKE_ISO_ALLOCATED_IMPL(SVGSVGElement);
 54 
 55 inline SVGSVGElement::SVGSVGElement(const QualifiedName&amp; tagName, Document&amp; document)
 56     : SVGGraphicsElement(tagName, document)

 57     , SVGFitToViewBox(this)
 58     , m_timeContainer(SMILTimeContainer::create(*this))
 59 {
 60     ASSERT(hasTagName(SVGNames::svgTag));
 61     document.registerForDocumentSuspensionCallbacks(*this);
 62 
 63     static std::once_flag onceFlag;
 64     std::call_once(onceFlag, [] {
 65         PropertyRegistry::registerProperty&lt;SVGNames::xAttr, &amp;SVGSVGElement::m_x&gt;();
 66         PropertyRegistry::registerProperty&lt;SVGNames::yAttr, &amp;SVGSVGElement::m_y&gt;();
 67         PropertyRegistry::registerProperty&lt;SVGNames::widthAttr, &amp;SVGSVGElement::m_width&gt;();
 68         PropertyRegistry::registerProperty&lt;SVGNames::heightAttr, &amp;SVGSVGElement::m_height&gt;();
 69     });
 70 }
 71 
 72 Ref&lt;SVGSVGElement&gt; SVGSVGElement::create(const QualifiedName&amp; tagName, Document&amp; document)
 73 {
 74     return adoptRef(*new SVGSVGElement(tagName, document));
 75 }
 76 
 77 Ref&lt;SVGSVGElement&gt; SVGSVGElement::create(Document&amp; document)
 78 {
 79     return create(SVGNames::svgTag, document);
 80 }
 81 
 82 SVGSVGElement::~SVGSVGElement()
 83 {
 84     if (m_viewSpec)
 85         m_viewSpec-&gt;resetContextElement();
 86     document().unregisterForDocumentSuspensionCallbacks(*this);
 87     document().accessSVGExtensions().removeTimeContainer(*this);
 88 }
 89 
 90 void SVGSVGElement::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
 91 {
 92     oldDocument.unregisterForDocumentSuspensionCallbacks(*this);
 93     document().registerForDocumentSuspensionCallbacks(*this);
 94     SVGGraphicsElement::didMoveToNewDocument(oldDocument, newDocument);
 95 }
 96 




















































 97 SVGViewSpec&amp; SVGSVGElement::currentView()
 98 {
 99     if (!m_viewSpec)
100         m_viewSpec = SVGViewSpec::create(*this);
101     return *m_viewSpec;
102 }
103 
104 RefPtr&lt;Frame&gt; SVGSVGElement::frameForCurrentScale() const
105 {
106     // The behavior of currentScale() is undefined when we&#39;re dealing with non-standalone SVG documents.
107     // If the document is embedded, the scaling is handled by the host renderer.
108     if (!isConnected() || !isOutermostSVGSVGElement())
109         return nullptr;
110     auto frame = makeRefPtr(document().frame());
111     return frame &amp;&amp; frame-&gt;isMainFrame() ? frame : nullptr;
112 }
113 
114 float SVGSVGElement::currentScale() const
115 {
116     // When asking from inside an embedded SVG document, a scale value of 1 seems reasonable, as it doesn&#39;t
</pre>
<hr />
<pre>
126 }
127 
128 void SVGSVGElement::setCurrentTranslate(const FloatPoint&amp; translation)
129 {
130     if (m_currentTranslate-&gt;value() == translation)
131         return;
132     m_currentTranslate-&gt;setValue(translation);
133     updateCurrentTranslate();
134 }
135 
136 void SVGSVGElement::updateCurrentTranslate()
137 {
138     if (RenderObject* object = renderer())
139         object-&gt;setNeedsLayout();
140     if (parentNode() == &amp;document() &amp;&amp; document().renderView())
141         document().renderView()-&gt;repaint();
142 }
143 
144 void SVGSVGElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
145 {
<span class="line-modified">146     if (!nearestViewportElement() &amp;&amp; isConnected()) {</span>
147         // For these events, the outermost &lt;svg&gt; element works like a &lt;body&gt; element does,
148         // setting certain event handlers directly on the window object.
149         if (name == HTMLNames::onunloadAttr) {
150             document().setWindowAttributeEventListener(eventNames().unloadEvent, name, value, mainThreadNormalWorld());
151             return;
152         }
153         if (name == HTMLNames::onresizeAttr) {
154             document().setWindowAttributeEventListener(eventNames().resizeEvent, name, value, mainThreadNormalWorld());
155             return;
156         }
157         if (name == HTMLNames::onscrollAttr) {
158             document().setWindowAttributeEventListener(eventNames().scrollEvent, name, value, mainThreadNormalWorld());
159             return;
160         }
161         if (name == SVGNames::onzoomAttr) {
162             document().setWindowAttributeEventListener(eventNames().zoomEvent, name, value, mainThreadNormalWorld());
163             return;
164         }
<span class="line-modified">165         if (name == HTMLNames::onabortAttr) {</span>
<span class="line-modified">166             document().setWindowAttributeEventListener(eventNames().abortEvent, name, value, mainThreadNormalWorld());</span>
<span class="line-modified">167             return;</span>
<span class="line-modified">168         }</span>
<span class="line-modified">169         if (name == HTMLNames::onerrorAttr) {</span>
<span class="line-modified">170             document().setWindowAttributeEventListener(eventNames().errorEvent, name, value, mainThreadNormalWorld());</span>
<span class="line-modified">171             return;</span>
<span class="line-modified">172         }</span>




173     }
174 
175     SVGParsingError parseError = NoError;
176 
177     if (name == SVGNames::xAttr)
<span class="line-modified">178         m_x-&gt;setBaseValInternal(SVGLengthValue::construct(SVGLengthMode::Width, value, parseError));</span>
179     else if (name == SVGNames::yAttr)
<span class="line-modified">180         m_y-&gt;setBaseValInternal(SVGLengthValue::construct(SVGLengthMode::Height, value, parseError));</span>
181     else if (name == SVGNames::widthAttr) {
<span class="line-modified">182         auto length = SVGLengthValue::construct(SVGLengthMode::Width, value, parseError, SVGLengthNegativeValuesMode::Forbid);</span>
183         if (parseError != NoError || value.isEmpty()) {
184             // FIXME: This is definitely the correct behavior for a missing/removed attribute.
185             // Not sure it&#39;s correct for the empty string or for something that can&#39;t be parsed.
<span class="line-modified">186             length = SVGLengthValue(SVGLengthMode::Width, &quot;100%&quot;_s);</span>
187         }
188         m_width-&gt;setBaseValInternal(length);
189     } else if (name == SVGNames::heightAttr) {
<span class="line-modified">190         auto length = SVGLengthValue::construct(SVGLengthMode::Height, value, parseError, SVGLengthNegativeValuesMode::Forbid);</span>
191         if (parseError != NoError || value.isEmpty()) {
192             // FIXME: This is definitely the correct behavior for a removed attribute.
193             // Not sure it&#39;s correct for the empty string or for something that can&#39;t be parsed.
<span class="line-modified">194             length = SVGLengthValue(SVGLengthMode::Height, &quot;100%&quot;_s);</span>
195         }
196         m_height-&gt;setBaseValInternal(length);
197     }
198 
199     reportAttributeParsingError(parseError, name, value);
200 
201     SVGGraphicsElement::parseAttribute(name, value);

202     SVGFitToViewBox::parseAttribute(name, value);
203     SVGZoomAndPan::parseAttribute(name, value);
204 }
205 
206 void SVGSVGElement::svgAttributeChanged(const QualifiedName&amp; attrName)
207 {
208     if (PropertyRegistry::isKnownAttribute(attrName)) {
209         InstanceInvalidationGuard guard(*this);
210         invalidateSVGPresentationAttributeStyle();
211 
212         if (auto renderer = this-&gt;renderer())
213             RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer);
214         return;
215     }
216 
217     if (SVGFitToViewBox::isKnownAttribute(attrName)) {
218         if (auto* renderer = this-&gt;renderer()) {
219             renderer-&gt;setNeedsTransformUpdate();
220             RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer);
221         }
222         return;
223     }
224 
225     SVGGraphicsElement::svgAttributeChanged(attrName);


















226 }
227 
228 Ref&lt;NodeList&gt; SVGSVGElement::collectIntersectionOrEnclosureList(SVGRect&amp; rect, SVGElement* referenceElement, bool (*checkFunction)(SVGElement&amp;, SVGRect&amp;))
229 {
230     Vector&lt;Ref&lt;Element&gt;&gt; elements;
231     for (auto&amp; element : descendantsOfType&lt;SVGElement&gt;(referenceElement ? *referenceElement : *this)) {
232         if (checkFunction(element, rect))
233             elements.append(element);
234     }
235     return StaticElementList::create(WTFMove(elements));
236 }
237 
238 static bool checkIntersectionWithoutUpdatingLayout(SVGElement&amp; element, SVGRect&amp; rect)
239 {
240     return RenderSVGModelObject::checkIntersection(element.renderer(), rect.value());
241 }
242 
243 static bool checkEnclosureWithoutUpdatingLayout(SVGElement&amp; element, SVGRect&amp; rect)
244 {
245     return RenderSVGModelObject::checkEnclosure(element.renderer(), rect.value());
246 }
247 
248 Ref&lt;NodeList&gt; SVGSVGElement::getIntersectionList(SVGRect&amp; rect, SVGElement* referenceElement)
249 {
250     document().updateLayoutIgnorePendingStylesheets();
251     return collectIntersectionOrEnclosureList(rect, referenceElement, checkIntersectionWithoutUpdatingLayout);
252 }
253 
254 Ref&lt;NodeList&gt; SVGSVGElement::getEnclosureList(SVGRect&amp; rect, SVGElement* referenceElement)
255 {
256     document().updateLayoutIgnorePendingStylesheets();
257     return collectIntersectionOrEnclosureList(rect, referenceElement, checkEnclosureWithoutUpdatingLayout);
258 }
259 
<span class="line-modified">260 bool SVGSVGElement::checkIntersection(Ref&lt;SVGElement&gt;&amp;&amp; element, SVGRect&amp; rect)</span>
261 {


262     element-&gt;document().updateLayoutIgnorePendingStylesheets();
<span class="line-modified">263     return checkIntersectionWithoutUpdatingLayout(element, rect);</span>
264 }
265 
<span class="line-modified">266 bool SVGSVGElement::checkEnclosure(Ref&lt;SVGElement&gt;&amp;&amp; element, SVGRect&amp; rect)</span>
267 {


268     element-&gt;document().updateLayoutIgnorePendingStylesheets();
<span class="line-modified">269     return checkEnclosureWithoutUpdatingLayout(element, rect);</span>
270 }
271 
272 void SVGSVGElement::deselectAll()
273 {
274     if (auto frame = makeRefPtr(document().frame()))
275         frame-&gt;selection().clear();
276 }
277 
278 Ref&lt;SVGNumber&gt; SVGSVGElement::createSVGNumber()
279 {
280     return SVGNumber::create();
281 }
282 
283 Ref&lt;SVGLength&gt; SVGSVGElement::createSVGLength()
284 {
285     return SVGLength::create();
286 }
287 
288 Ref&lt;SVGAngle&gt; SVGSVGElement::createSVGAngle()
289 {
</pre>
<hr />
<pre>
293 Ref&lt;SVGPoint&gt; SVGSVGElement::createSVGPoint()
294 {
295     return SVGPoint::create();
296 }
297 
298 Ref&lt;SVGMatrix&gt; SVGSVGElement::createSVGMatrix()
299 {
300     return SVGMatrix::create();
301 }
302 
303 Ref&lt;SVGRect&gt; SVGSVGElement::createSVGRect()
304 {
305     return SVGRect::create();
306 }
307 
308 Ref&lt;SVGTransform&gt; SVGSVGElement::createSVGTransform()
309 {
310     return SVGTransform::create(SVGTransformValue::SVG_TRANSFORM_MATRIX);
311 }
312 
<span class="line-modified">313 Ref&lt;SVGTransform&gt; SVGSVGElement::createSVGTransformFromMatrix(DOMMatrix2DInit&amp;&amp; matrixInit)</span>
314 {
<span class="line-modified">315     AffineTransform transform;</span>
<span class="line-added">316     if (matrixInit.a.hasValue())</span>
<span class="line-added">317         transform.setA(matrixInit.a.value());</span>
<span class="line-added">318     if (matrixInit.b.hasValue())</span>
<span class="line-added">319         transform.setB(matrixInit.b.value());</span>
<span class="line-added">320     if (matrixInit.c.hasValue())</span>
<span class="line-added">321         transform.setC(matrixInit.c.value());</span>
<span class="line-added">322     if (matrixInit.d.hasValue())</span>
<span class="line-added">323         transform.setD(matrixInit.d.value());</span>
<span class="line-added">324     if (matrixInit.e.hasValue())</span>
<span class="line-added">325         transform.setE(matrixInit.e.value());</span>
<span class="line-added">326     if (matrixInit.f.hasValue())</span>
<span class="line-added">327         transform.setF(matrixInit.f.value());</span>
<span class="line-added">328     return SVGTransform::create(transform);</span>
329 }
330 
331 AffineTransform SVGSVGElement::localCoordinateSpaceTransform(SVGLocatable::CTMScope mode) const
332 {
333     AffineTransform viewBoxTransform;
334     if (!hasEmptyViewBox()) {
335         FloatSize size = currentViewportSize();
336         viewBoxTransform = viewBoxToViewTransform(size.width(), size.height());
337     }
338 
339     AffineTransform transform;
340     if (!isOutermostSVGSVGElement()) {
341         SVGLengthContext lengthContext(this);
342         transform.translate(x().value(lengthContext), y().value(lengthContext));
343     } else if (mode == SVGLocatable::ScreenScope) {
344         if (auto* renderer = this-&gt;renderer()) {
345             FloatPoint location;
346             float zoomFactor = 1;
347 
348             // At the SVG/HTML boundary (aka RenderSVGRoot), we apply the localToBorderBoxTransform
</pre>
<hr />
<pre>
493 
494     if (renderer()) {
495         if (is&lt;RenderSVGRoot&gt;(*renderer())) {
496             auto&amp; root = downcast&lt;RenderSVGRoot&gt;(*renderer());
497             viewportSize = root.contentBoxRect().size() / root.style().effectiveZoom();
498         } else
499             viewportSize = downcast&lt;RenderSVGViewportContainer&gt;(*renderer()).viewport().size();
500     }
501 
502     if (!viewportSize.isEmpty())
503         return viewportSize;
504 
505     if (!(hasIntrinsicWidth() &amp;&amp; hasIntrinsicHeight()))
506         return { };
507 
508     return FloatSize(floatValueForLength(intrinsicWidth(), 0), floatValueForLength(intrinsicHeight(), 0));
509 }
510 
511 bool SVGSVGElement::hasIntrinsicWidth() const
512 {
<span class="line-modified">513     return width().lengthType() != SVGLengthType::Percentage;</span>
514 }
515 
516 bool SVGSVGElement::hasIntrinsicHeight() const
517 {
<span class="line-modified">518     return height().lengthType() != SVGLengthType::Percentage;</span>
519 }
520 
521 Length SVGSVGElement::intrinsicWidth() const
522 {
<span class="line-modified">523     if (width().lengthType() == SVGLengthType::Percentage)</span>
524         return Length(0, Fixed);
525 
526     SVGLengthContext lengthContext(this);
527     return Length(width().value(lengthContext), Fixed);
528 }
529 
530 Length SVGSVGElement::intrinsicHeight() const
531 {
<span class="line-modified">532     if (height().lengthType() == SVGLengthType::Percentage)</span>
533         return Length(0, Fixed);
534 
535     SVGLengthContext lengthContext(this);
536     return Length(height().value(lengthContext), Fixed);
537 }
538 
539 AffineTransform SVGSVGElement::viewBoxToViewTransform(float viewWidth, float viewHeight) const
540 {
541     if (!m_useCurrentView || !m_viewSpec)
542         return SVGFitToViewBox::viewBoxToViewTransform(currentViewBoxRect(), preserveAspectRatio(), viewWidth, viewHeight);
543 
544     AffineTransform transform = SVGFitToViewBox::viewBoxToViewTransform(currentViewBoxRect(), m_viewSpec-&gt;preserveAspectRatio(), viewWidth, viewHeight);
545     transform *= m_viewSpec-&gt;transform()-&gt;concatenate();
546     return transform;
547 }
548 
549 SVGViewElement* SVGSVGElement::findViewAnchor(const String&amp; fragmentIdentifier) const
550 {
551     auto* anchorElement = document().findAnchor(fragmentIdentifier);
552     return is&lt;SVGViewElement&gt;(anchorElement) ? downcast&lt;SVGViewElement&gt;(anchorElement): nullptr;
</pre>
<hr />
<pre>
583     }
584 
585     if (fragmentIdentifier.startsWith(&quot;svgView(&quot;)) {
586         if (!view)
587             view = &amp;currentView(); // Create the SVGViewSpec.
588         if (view-&gt;parseViewSpec(fragmentIdentifier))
589             m_useCurrentView = true;
590         else
591             view-&gt;reset();
592         if (renderer &amp;&amp; (hadUseCurrentView || m_useCurrentView))
593             RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer);
594         return m_useCurrentView;
595     }
596 
597     // Spec: If the SVG fragment identifier addresses a &quot;view&quot; element within an SVG document (e.g., MyDrawing.svg#MyView
598     // or MyDrawing.svg#xpointer(id(&#39;MyView&#39;))) then the closest ancestor &quot;svg&quot; element is displayed in the viewport.
599     // Any view specification attributes included on the given &quot;view&quot; element override the corresponding view specification
600     // attributes on the closest ancestor &quot;svg&quot; element.
601     if (auto* viewElement = findViewAnchor(fragmentIdentifier)) {
602         if (auto* rootElement = findRootAnchor(viewElement)) {
<span class="line-added">603             if (rootElement-&gt;m_currentViewElement) {</span>
<span class="line-added">604                 ASSERT(rootElement-&gt;m_currentViewElement-&gt;targetElement() == rootElement);</span>
<span class="line-added">605 </span>
<span class="line-added">606                 // If the viewElement has changed, remove the link from the SVGViewElement to the previously selected SVGSVGElement.</span>
<span class="line-added">607                 if (rootElement-&gt;m_currentViewElement != viewElement)</span>
<span class="line-added">608                     rootElement-&gt;m_currentViewElement-&gt;resetTargetElement();</span>
<span class="line-added">609             }</span>
<span class="line-added">610 </span>
<span class="line-added">611             if (rootElement-&gt;m_currentViewElement != viewElement) {</span>
<span class="line-added">612                 rootElement-&gt;m_currentViewElement = viewElement;</span>
<span class="line-added">613                 rootElement-&gt;m_currentViewElement-&gt;setTargetElement(*rootElement);</span>
<span class="line-added">614             }</span>
<span class="line-added">615 </span>
616             rootElement-&gt;inheritViewAttributes(*viewElement);
617             if (auto* renderer = rootElement-&gt;renderer())
618                 RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer);
619             m_currentViewFragmentIdentifier = fragmentIdentifier;
620             return true;
621         }
622     }
623 
624     // FIXME: We need to decide which &lt;svg&gt; to focus on, and zoom to it.
625     // FIXME: We need to actually &quot;highlight&quot; the viewTarget(s).
626     return false;
627 }
628 
629 void SVGSVGElement::resetScrollAnchor()
630 {
631     if (!m_useCurrentView &amp;&amp; m_currentViewFragmentIdentifier.isEmpty())
632         return;
633 
634     if (m_viewSpec)
635         m_viewSpec-&gt;reset();
</pre>
</td>
</tr>
</table>
<center><a href="SVGRectElement.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGSVGElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
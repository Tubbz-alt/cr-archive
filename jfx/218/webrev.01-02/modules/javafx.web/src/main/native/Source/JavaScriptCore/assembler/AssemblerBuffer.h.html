<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/AssemblerBuffer.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(ASSEMBLER)
 29 
 30 #include &quot;ExecutableAllocator.h&quot;
 31 #include &quot;JITCompilationEffort.h&quot;
 32 #include &quot;stdint.h&quot;
 33 #include &lt;string.h&gt;
 34 #include &lt;wtf/Assertions.h&gt;
 35 #include &lt;wtf/FastMalloc.h&gt;
 36 #if CPU(ARM64E)
 37 #include &lt;wtf/PtrTag.h&gt;
 38 #endif
 39 #include &lt;wtf/StdLibExtras.h&gt;
 40 #include &lt;wtf/UnalignedAccess.h&gt;
 41 
 42 namespace JSC {
 43 
 44     class LinkBuffer;
 45 
 46     DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(AssemblerData);
 47 
 48     struct AssemblerLabel {
 49         AssemblerLabel()
 50             : m_offset(std::numeric_limits&lt;uint32_t&gt;::max())
 51         {
 52         }
 53 
 54         explicit AssemblerLabel(uint32_t offset)
 55             : m_offset(offset)
 56         {
 57         }
 58 
 59         bool isSet() const { return (m_offset != std::numeric_limits&lt;uint32_t&gt;::max()); }
 60 
 61         AssemblerLabel labelAtOffset(int offset) const
 62         {
 63             return AssemblerLabel(m_offset + offset);
 64         }
 65 
 66         bool operator==(const AssemblerLabel&amp; other) const { return m_offset == other.m_offset; }
 67 
 68         uint32_t m_offset;
 69     };
 70 
 71     class AssemblerData {
 72         WTF_MAKE_NONCOPYABLE(AssemblerData);
 73         static constexpr size_t InlineCapacity = 128;
 74     public:
 75         AssemblerData()
 76             : m_buffer(m_inlineBuffer)
 77             , m_capacity(InlineCapacity)
 78         {
 79         }
 80 
 81         AssemblerData(size_t initialCapacity)
 82         {
 83             if (initialCapacity &lt;= InlineCapacity) {
 84                 m_capacity = InlineCapacity;
 85                 m_buffer = m_inlineBuffer;
 86             } else {
 87                 m_capacity = initialCapacity;
 88                 m_buffer = static_cast&lt;char*&gt;(AssemblerDataMalloc::malloc(m_capacity));
 89             }
 90         }
 91 
 92         AssemblerData(AssemblerData&amp;&amp; other)
 93         {
 94             if (other.isInlineBuffer()) {
 95                 ASSERT(other.m_capacity == InlineCapacity);
 96                 memcpy(m_inlineBuffer, other.m_inlineBuffer, InlineCapacity);
 97                 m_buffer = m_inlineBuffer;
 98             } else
 99                 m_buffer = other.m_buffer;
100             m_capacity = other.m_capacity;
101 
102             other.m_buffer = nullptr;
103             other.m_capacity = 0;
104         }
105 
106         AssemblerData&amp; operator=(AssemblerData&amp;&amp; other)
107         {
108             if (m_buffer &amp;&amp; !isInlineBuffer())
109                 AssemblerDataMalloc::free(m_buffer);
110 
111             if (other.isInlineBuffer()) {
112                 ASSERT(other.m_capacity == InlineCapacity);
113                 memcpy(m_inlineBuffer, other.m_inlineBuffer, InlineCapacity);
114                 m_buffer = m_inlineBuffer;
115             } else
116                 m_buffer = other.m_buffer;
117             m_capacity = other.m_capacity;
118 
119             other.m_buffer = nullptr;
120             other.m_capacity = 0;
121             return *this;
122         }
123 
124         ~AssemblerData()
125         {
126             if (m_buffer &amp;&amp; !isInlineBuffer())
127                 AssemblerDataMalloc::free(m_buffer);
128         }
129 
130         char* buffer() const { return m_buffer; }
131 
132         unsigned capacity() const { return m_capacity; }
133 
134         void grow(unsigned extraCapacity = 0)
135         {
136             m_capacity = m_capacity + m_capacity / 2 + extraCapacity;
137             if (isInlineBuffer()) {
138                 m_buffer = static_cast&lt;char*&gt;(AssemblerDataMalloc::malloc(m_capacity));
139                 memcpy(m_buffer, m_inlineBuffer, InlineCapacity);
140             } else
141                 m_buffer = static_cast&lt;char*&gt;(AssemblerDataMalloc::realloc(m_buffer, m_capacity));
142         }
143 
144     private:
145         bool isInlineBuffer() const { return m_buffer == m_inlineBuffer; }
146         char* m_buffer;
147         char m_inlineBuffer[InlineCapacity];
148         unsigned m_capacity;
149     };
150 
151 #if CPU(ARM64E)
152     class ARM64EHash {
153     public:
154         ARM64EHash() = default;
155         ALWAYS_INLINE void update(uint32_t value)
156         {
157             uint64_t input = value ^ m_hash;
158             uint64_t a = static_cast&lt;uint32_t&gt;(tagInt(input, static_cast&lt;PtrTag&gt;(0)) &gt;&gt; 39);
159             uint64_t b = tagInt(input, static_cast&lt;PtrTag&gt;(0xb7e151628aed2a6a)) &gt;&gt; 23;
160             m_hash = a ^ b;
161         }
162         uint32_t finalHash() const
163         {
164             uint64_t hash = m_hash;
165             uint64_t a = static_cast&lt;uint32_t&gt;(tagInt(hash, static_cast&lt;PtrTag&gt;(0xbf7158809cf4f3c7)) &gt;&gt; 39);
166             uint64_t b = tagInt(hash, static_cast&lt;PtrTag&gt;(0x62e7160f38b4da56)) &gt;&gt; 23;
167             return static_cast&lt;uint32_t&gt;(a ^ b);
168         }
169     private:
170         uint32_t m_hash { 0 };
171     };
172 #endif
173 
174     class AssemblerBuffer {
175     public:
176         AssemblerBuffer()
177             : m_storage()
178             , m_index(0)
179         {
180         }
181 
182         bool isAvailable(unsigned space)
183         {
184             return m_index + space &lt;= m_storage.capacity();
185         }
186 
187         void ensureSpace(unsigned space)
188         {
189             while (!isAvailable(space))
190                 outOfLineGrow();
191         }
192 
193         bool isAligned(int alignment) const
194         {
195             return !(m_index &amp; (alignment - 1));
196         }
197 
198 #if !CPU(ARM64)
199         void putByteUnchecked(int8_t value) { putIntegralUnchecked(value); }
200         void putByte(int8_t value) { putIntegral(value); }
201         void putShortUnchecked(int16_t value) { putIntegralUnchecked(value); }
202         void putShort(int16_t value) { putIntegral(value); }
203         void putInt64Unchecked(int64_t value) { putIntegralUnchecked(value); }
204         void putInt64(int64_t value) { putIntegral(value); }
205 #endif
206         void putIntUnchecked(int32_t value) { putIntegralUnchecked(value); }
207         void putInt(int32_t value) { putIntegral(value); }
208 
209         size_t codeSize() const
210         {
211             return m_index;
212         }
213 
214 #if !CPU(ARM64)
215         void setCodeSize(size_t index)
216         {
217             // Warning: Only use this if you know exactly what you are doing.
218             // For example, say you want 40 bytes of nops, it&#39;s ok to grow
219             // and then fill 40 bytes of nops using bigger instructions.
220             m_index = index;
221             ASSERT(m_index &lt;= m_storage.capacity());
222         }
223 #endif
224 
225         AssemblerLabel label() const
226         {
227             return AssemblerLabel(m_index);
228         }
229 
230         unsigned debugOffset() { return m_index; }
231 
232         AssemblerData&amp;&amp; releaseAssemblerData() { return WTFMove(m_storage); }
233 
234         // LocalWriter is a trick to keep the storage buffer and the index
235         // in memory while issuing multiple Stores.
236         // It is created in a block scope and its attribute can stay live
237         // between writes.
238         //
239         // LocalWriter *CANNOT* be mixed with other types of access to AssemblerBuffer.
240         // AssemblerBuffer cannot be used until its LocalWriter goes out of scope.
241 #if !CPU(ARM64) // If we ever need to use this on arm64e, we would need to make the checksum aware of this.
242         class LocalWriter {
243         public:
244             LocalWriter(AssemblerBuffer&amp; buffer, unsigned requiredSpace)
245                 : m_buffer(buffer)
246             {
247                 buffer.ensureSpace(requiredSpace);
248                 m_storageBuffer = buffer.m_storage.buffer();
249                 m_index = buffer.m_index;
250 #if ASSERT_ENABLED
251                 m_initialIndex = m_index;
252                 m_requiredSpace = requiredSpace;
253 #endif
254             }
255 
256             ~LocalWriter()
257             {
258                 ASSERT(m_index - m_initialIndex &lt;= m_requiredSpace);
259                 ASSERT(m_buffer.m_index == m_initialIndex);
260                 ASSERT(m_storageBuffer == m_buffer.m_storage.buffer());
261                 m_buffer.m_index = m_index;
262             }
263 
264             void putByteUnchecked(int8_t value) { putIntegralUnchecked(value); }
265             void putShortUnchecked(int16_t value) { putIntegralUnchecked(value); }
266             void putIntUnchecked(int32_t value) { putIntegralUnchecked(value); }
267             void putInt64Unchecked(int64_t value) { putIntegralUnchecked(value); }
268         private:
269             template&lt;typename IntegralType&gt;
270             void putIntegralUnchecked(IntegralType value)
271             {
272                 ASSERT(m_index + sizeof(IntegralType) &lt;= m_buffer.m_storage.capacity());
273                 WTF::unalignedStore&lt;IntegralType&gt;(m_storageBuffer + m_index, value);
274                 m_index += sizeof(IntegralType);
275             }
276             AssemblerBuffer&amp; m_buffer;
277             char* m_storageBuffer;
278             unsigned m_index;
279 #if ASSERT_ENABLED
280             unsigned m_initialIndex;
281             unsigned m_requiredSpace;
282 #endif
283         };
284 #endif // !CPU(ARM64)
285 
286 #if CPU(ARM64E)
287         ARM64EHash hash() const { return m_hash; }
288 #endif
289 
290 #if !CPU(ARM64) // If we were to define this on arm64e, we&#39;d need a way to update the hash as we write directly into the buffer.
291         void* data() const { return m_storage.buffer(); }
292 #endif
293 
294 
295     protected:
296         template&lt;typename IntegralType&gt;
297         void putIntegral(IntegralType value)
298         {
299             unsigned nextIndex = m_index + sizeof(IntegralType);
300             if (UNLIKELY(nextIndex &gt; m_storage.capacity()))
301                 outOfLineGrow();
302             putIntegralUnchecked&lt;IntegralType&gt;(value);
303         }
304 
305         template&lt;typename IntegralType&gt;
306         void putIntegralUnchecked(IntegralType value)
307         {
308 #if CPU(ARM64)
309             static_assert(sizeof(value) == 4, &quot;&quot;);
310 #if CPU(ARM64E)
311             m_hash.update(value);
312 #endif
313 #endif
314             ASSERT(isAvailable(sizeof(IntegralType)));
315             WTF::unalignedStore&lt;IntegralType&gt;(m_storage.buffer() + m_index, value);
316             m_index += sizeof(IntegralType);
317         }
318 
319     private:
320         void grow(int extraCapacity = 0)
321         {
322             m_storage.grow(extraCapacity);
323         }
324 
325         NEVER_INLINE void outOfLineGrow()
326         {
327             m_storage.grow();
328         }
329 
330 #if !CPU(ARM64)
331         friend LocalWriter;
332 #endif
333         friend LinkBuffer;
334 
335         AssemblerData m_storage;
336         unsigned m_index;
337 #if CPU(ARM64E)
338         ARM64EHash m_hash;
339 #endif
340     };
341 
342 } // namespace JSC
343 
344 #endif // ENABLE(ASSEMBLER)
    </pre>
  </body>
</html>
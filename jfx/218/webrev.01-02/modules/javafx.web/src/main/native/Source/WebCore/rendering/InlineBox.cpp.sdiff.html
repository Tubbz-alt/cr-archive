<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ImageQualityController.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InlineBox.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineBox.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
115     int printedCharacters = 0;
116     if (mark) {
117         stream &lt;&lt; &quot;*&quot;;
118         ++printedCharacters;
119     }
120     while (++printedCharacters &lt;= depth * 2)
121         stream &lt;&lt; &quot; &quot;;
122     stream &lt;&lt; boxName() &lt;&lt; &quot; &quot; &lt;&lt; FloatRect(x(), y(), width(), height()) &lt;&lt; &quot; (&quot; &lt;&lt; this &lt;&lt; &quot;) renderer-&gt;(&quot; &lt;&lt; &amp;renderer() &lt;&lt; &quot;)&quot;;
123     stream.nextLine();
124 }
125 
126 #endif // ENABLE(TREE_DEBUGGING)
127 
128 float InlineBox::logicalHeight() const
129 {
130     if (hasVirtualLogicalHeight())
131         return virtualLogicalHeight();
132 
133     const RenderStyle&amp; lineStyle = this-&gt;lineStyle();
134     if (renderer().isTextOrLineBreak())
<span class="line-modified">135         return behavesLikeText() ? lineStyle.fontMetrics().height() : 0;</span>
136     if (is&lt;RenderBox&gt;(renderer()) &amp;&amp; parent())
137         return isHorizontal() ? downcast&lt;RenderBox&gt;(renderer()).height() : downcast&lt;RenderBox&gt;(renderer()).width();
138 
139     ASSERT(isInlineFlowBox());
140     RenderBoxModelObject* flowObject = boxModelObject();
141     const FontMetrics&amp; fontMetrics = lineStyle.fontMetrics();
142     float result = fontMetrics.height();
143     if (parent())
144         result += flowObject-&gt;borderAndPaddingLogicalHeight();
145     return result;
146 }
147 
148 int InlineBox::baselinePosition(FontBaseline baselineType) const
149 {
<span class="line-removed">150     if (renderer().isLineBreak() &amp;&amp; !behavesLikeText())</span>
<span class="line-removed">151         return 0;</span>
152     return boxModelObject()-&gt;baselinePosition(baselineType, m_bitfields.firstLine(), isHorizontal() ? HorizontalLine : VerticalLine, PositionOnContainingLine);
153 }
154 
155 LayoutUnit InlineBox::lineHeight() const
156 {
<span class="line-removed">157     if (renderer().isLineBreak() &amp;&amp; !behavesLikeText())</span>
<span class="line-removed">158         return 0;</span>
159     return boxModelObject()-&gt;lineHeight(m_bitfields.firstLine(), isHorizontal() ? HorizontalLine : VerticalLine, PositionOnContainingLine);
160 }
161 
162 int InlineBox::caretMinOffset() const
163 {
164     return m_renderer.caretMinOffset();
165 }
166 
167 int InlineBox::caretMaxOffset() const
168 {
169     return m_renderer.caretMaxOffset();
170 }
171 
172 void InlineBox::dirtyLineBoxes()
173 {
174     markDirty();
175     for (InlineFlowBox* curr = parent(); curr &amp;&amp; !curr-&gt;isDirty(); curr = curr-&gt;parent())
176         curr-&gt;markDirty();
177 }
178 
</pre>
<hr />
<pre>
203 
204 bool InlineBox::nextOnLineExists() const
205 {
206     if (!m_bitfields.determinedIfNextOnLineExists()) {
207         m_bitfields.setDeterminedIfNextOnLineExists(true);
208 
209         if (!parent())
210             m_bitfields.setNextOnLineExists(false);
211         else if (nextOnLine())
212             m_bitfields.setNextOnLineExists(true);
213         else
214             m_bitfields.setNextOnLineExists(parent()-&gt;nextOnLineExists());
215     }
216     return m_bitfields.nextOnLineExists();
217 }
218 
219 bool InlineBox::previousOnLineExists() const
220 {
221     if (!parent())
222         return false;
<span class="line-modified">223     if (prevOnLine())</span>
224         return true;
225     return parent()-&gt;previousOnLineExists();
226 }
227 
<span class="line-modified">228 InlineBox* InlineBox::nextLeafChild() const</span>
229 {
230     InlineBox* leaf = nullptr;
231     for (InlineBox* box = nextOnLine(); box &amp;&amp; !leaf; box = box-&gt;nextOnLine())
<span class="line-modified">232         leaf = box-&gt;isLeaf() ? box : downcast&lt;InlineFlowBox&gt;(*box).firstLeafChild();</span>
233     if (!leaf &amp;&amp; parent())
<span class="line-modified">234         leaf = parent()-&gt;nextLeafChild();</span>
235     return leaf;
236 }
237 
<span class="line-modified">238 InlineBox* InlineBox::prevLeafChild() const</span>
239 {
240     InlineBox* leaf = nullptr;
<span class="line-modified">241     for (InlineBox* box = prevOnLine(); box &amp;&amp; !leaf; box = box-&gt;prevOnLine())</span>
<span class="line-modified">242         leaf = box-&gt;isLeaf() ? box : downcast&lt;InlineFlowBox&gt;(*box).lastLeafChild();</span>
243     if (!leaf &amp;&amp; parent())
<span class="line-modified">244         leaf = parent()-&gt;prevLeafChild();</span>
245     return leaf;
246 }
247 
<span class="line-modified">248 InlineBox* InlineBox::nextLeafChildIgnoringLineBreak() const</span>
249 {
<span class="line-modified">250     InlineBox* leaf = nextLeafChild();</span>
251     if (leaf &amp;&amp; leaf-&gt;isLineBreak())
252         return nullptr;
253     return leaf;
254 }
255 
<span class="line-modified">256 InlineBox* InlineBox::prevLeafChildIgnoringLineBreak() const</span>
257 {
<span class="line-modified">258     InlineBox* leaf = prevLeafChild();</span>
259     if (leaf &amp;&amp; leaf-&gt;isLineBreak())
260         return nullptr;
261     return leaf;
262 }
263 
264 RenderObject::SelectionState InlineBox::selectionState()
265 {
266     return m_renderer.selectionState();
267 }
268 
269 bool InlineBox::canAccommodateEllipsis(bool ltr, int blockEdge, int ellipsisWidth) const
270 {
271     // Non-replaced elements can always accommodate an ellipsis.
272     if (!m_renderer.isReplaced())
273         return true;
274 
275     IntRect boxRect(left(), 0, m_logicalWidth, 10);
276     IntRect ellipsisRect(ltr ? blockEdge - ellipsisWidth : blockEdge, 0, ellipsisWidth, 10);
277     return !(boxRect.intersects(ellipsisRect));
278 }
</pre>
</td>
<td>
<hr />
<pre>
115     int printedCharacters = 0;
116     if (mark) {
117         stream &lt;&lt; &quot;*&quot;;
118         ++printedCharacters;
119     }
120     while (++printedCharacters &lt;= depth * 2)
121         stream &lt;&lt; &quot; &quot;;
122     stream &lt;&lt; boxName() &lt;&lt; &quot; &quot; &lt;&lt; FloatRect(x(), y(), width(), height()) &lt;&lt; &quot; (&quot; &lt;&lt; this &lt;&lt; &quot;) renderer-&gt;(&quot; &lt;&lt; &amp;renderer() &lt;&lt; &quot;)&quot;;
123     stream.nextLine();
124 }
125 
126 #endif // ENABLE(TREE_DEBUGGING)
127 
128 float InlineBox::logicalHeight() const
129 {
130     if (hasVirtualLogicalHeight())
131         return virtualLogicalHeight();
132 
133     const RenderStyle&amp; lineStyle = this-&gt;lineStyle();
134     if (renderer().isTextOrLineBreak())
<span class="line-modified">135         return lineStyle.fontMetrics().height();</span>
136     if (is&lt;RenderBox&gt;(renderer()) &amp;&amp; parent())
137         return isHorizontal() ? downcast&lt;RenderBox&gt;(renderer()).height() : downcast&lt;RenderBox&gt;(renderer()).width();
138 
139     ASSERT(isInlineFlowBox());
140     RenderBoxModelObject* flowObject = boxModelObject();
141     const FontMetrics&amp; fontMetrics = lineStyle.fontMetrics();
142     float result = fontMetrics.height();
143     if (parent())
144         result += flowObject-&gt;borderAndPaddingLogicalHeight();
145     return result;
146 }
147 
148 int InlineBox::baselinePosition(FontBaseline baselineType) const
149 {


150     return boxModelObject()-&gt;baselinePosition(baselineType, m_bitfields.firstLine(), isHorizontal() ? HorizontalLine : VerticalLine, PositionOnContainingLine);
151 }
152 
153 LayoutUnit InlineBox::lineHeight() const
154 {


155     return boxModelObject()-&gt;lineHeight(m_bitfields.firstLine(), isHorizontal() ? HorizontalLine : VerticalLine, PositionOnContainingLine);
156 }
157 
158 int InlineBox::caretMinOffset() const
159 {
160     return m_renderer.caretMinOffset();
161 }
162 
163 int InlineBox::caretMaxOffset() const
164 {
165     return m_renderer.caretMaxOffset();
166 }
167 
168 void InlineBox::dirtyLineBoxes()
169 {
170     markDirty();
171     for (InlineFlowBox* curr = parent(); curr &amp;&amp; !curr-&gt;isDirty(); curr = curr-&gt;parent())
172         curr-&gt;markDirty();
173 }
174 
</pre>
<hr />
<pre>
199 
200 bool InlineBox::nextOnLineExists() const
201 {
202     if (!m_bitfields.determinedIfNextOnLineExists()) {
203         m_bitfields.setDeterminedIfNextOnLineExists(true);
204 
205         if (!parent())
206             m_bitfields.setNextOnLineExists(false);
207         else if (nextOnLine())
208             m_bitfields.setNextOnLineExists(true);
209         else
210             m_bitfields.setNextOnLineExists(parent()-&gt;nextOnLineExists());
211     }
212     return m_bitfields.nextOnLineExists();
213 }
214 
215 bool InlineBox::previousOnLineExists() const
216 {
217     if (!parent())
218         return false;
<span class="line-modified">219     if (previousOnLine())</span>
220         return true;
221     return parent()-&gt;previousOnLineExists();
222 }
223 
<span class="line-modified">224 InlineBox* InlineBox::nextLeafOnLine() const</span>
225 {
226     InlineBox* leaf = nullptr;
227     for (InlineBox* box = nextOnLine(); box &amp;&amp; !leaf; box = box-&gt;nextOnLine())
<span class="line-modified">228         leaf = box-&gt;isLeaf() ? box : downcast&lt;InlineFlowBox&gt;(*box).firstLeafDescendant();</span>
229     if (!leaf &amp;&amp; parent())
<span class="line-modified">230         leaf = parent()-&gt;nextLeafOnLine();</span>
231     return leaf;
232 }
233 
<span class="line-modified">234 InlineBox* InlineBox::previousLeafOnLine() const</span>
235 {
236     InlineBox* leaf = nullptr;
<span class="line-modified">237     for (InlineBox* box = previousOnLine(); box &amp;&amp; !leaf; box = box-&gt;previousOnLine())</span>
<span class="line-modified">238         leaf = box-&gt;isLeaf() ? box : downcast&lt;InlineFlowBox&gt;(*box).lastLeafDescendant();</span>
239     if (!leaf &amp;&amp; parent())
<span class="line-modified">240         leaf = parent()-&gt;previousLeafOnLine();</span>
241     return leaf;
242 }
243 
<span class="line-modified">244 InlineBox* InlineBox::nextLeafOnLineIgnoringLineBreak() const</span>
245 {
<span class="line-modified">246     InlineBox* leaf = nextLeafOnLine();</span>
247     if (leaf &amp;&amp; leaf-&gt;isLineBreak())
248         return nullptr;
249     return leaf;
250 }
251 
<span class="line-modified">252 InlineBox* InlineBox::previousLeafOnLineIgnoringLineBreak() const</span>
253 {
<span class="line-modified">254     InlineBox* leaf = previousLeafOnLine();</span>
255     if (leaf &amp;&amp; leaf-&gt;isLineBreak())
256         return nullptr;
257     return leaf;
258 }
259 
260 RenderObject::SelectionState InlineBox::selectionState()
261 {
262     return m_renderer.selectionState();
263 }
264 
265 bool InlineBox::canAccommodateEllipsis(bool ltr, int blockEdge, int ellipsisWidth) const
266 {
267     // Non-replaced elements can always accommodate an ellipsis.
268     if (!m_renderer.isReplaced())
269         return true;
270 
271     IntRect boxRect(left(), 0, m_logicalWidth, 10);
272     IntRect ellipsisRect(ltr ? blockEdge - ellipsisWidth : blockEdge, 0, ellipsisWidth, 10);
273     return !(boxRect.intersects(ellipsisRect));
274 }
</pre>
</td>
</tr>
</table>
<center><a href="ImageQualityController.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InlineBox.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/track/VTTCue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2011, 2013 Google Inc.  All rights reserved.
   3  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions are
   7  * met:
   8  *
   9  *     * Redistributions of source code must retain the above copyright
  10  * notice, this list of conditions and the following disclaimer.
  11  *     * Redistributions in binary form must reproduce the above
  12  * copyright notice, this list of conditions and the following disclaimer
  13  * in the documentation and/or other materials provided with the
  14  * distribution.
  15  *     * Neither the name of Google Inc. nor the names of its
  16  * contributors may be used to endorse or promote products derived from
  17  * this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  30  */
  31 
  32 #include &quot;config.h&quot;
  33 #include &quot;VTTCue.h&quot;
  34 
  35 #if ENABLE(VIDEO_TRACK)
  36 
  37 #include &quot;CSSPropertyNames.h&quot;
  38 #include &quot;CSSValueKeywords.h&quot;
  39 #include &quot;DocumentFragment.h&quot;
  40 #include &quot;Event.h&quot;
  41 #include &quot;HTMLDivElement.h&quot;
  42 #include &quot;HTMLSpanElement.h&quot;
  43 #include &quot;HTMLStyleElement.h&quot;
  44 #include &quot;Logging.h&quot;
  45 #include &quot;NodeTraversal.h&quot;
  46 #include &quot;RenderVTTCue.h&quot;
  47 #include &quot;ScriptDisallowedScope.h&quot;
  48 #include &quot;Text.h&quot;
  49 #include &quot;TextTrack.h&quot;
  50 #include &quot;TextTrackCueGeneric.h&quot;
  51 #include &quot;TextTrackCueList.h&quot;
  52 #include &quot;VTTRegionList.h&quot;
  53 #include &quot;VTTScanner.h&quot;
  54 #include &quot;WebVTTElement.h&quot;
  55 #include &quot;WebVTTParser.h&quot;
  56 #include &lt;wtf/IsoMallocInlines.h&gt;
  57 #include &lt;wtf/MathExtras.h&gt;
  58 #include &lt;wtf/text/StringBuilder.h&gt;
  59 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  60 
  61 namespace WebCore {
  62 
  63 WTF_MAKE_ISO_ALLOCATED_IMPL(VTTCue);
  64 WTF_MAKE_ISO_ALLOCATED_IMPL(VTTCueBox);
  65 
  66 // This constant should correspond with the percentage returned by CaptionUserPreferences::captionFontSizeScaleAndImportance.
  67 static constexpr double DEFAULTCAPTIONFONTSIZEPERCENTAGE = 5;
  68 
  69 static constexpr int undefinedPosition = -1;
  70 
  71 static const CSSValueID displayWritingModeMap[] = {
  72     CSSValueHorizontalTb, CSSValueVerticalRl, CSSValueVerticalLr
  73 };
  74 COMPILE_ASSERT(WTF_ARRAY_LENGTH(displayWritingModeMap) == VTTCue::NumberOfWritingDirections, displayWritingModeMap_has_wrong_size);
  75 
  76 static const CSSValueID displayAlignmentMap[] = {
  77     CSSValueStart, CSSValueCenter, CSSValueEnd, CSSValueLeft, CSSValueRight
  78 };
  79 COMPILE_ASSERT(WTF_ARRAY_LENGTH(displayAlignmentMap) == VTTCue::NumberOfAlignments, displayAlignmentMap_has_wrong_size);
  80 
  81 static const String&amp; startKeyword()
  82 {
  83     static NeverDestroyed&lt;const String&gt; start(MAKE_STATIC_STRING_IMPL(&quot;start&quot;));
  84     return start;
  85 }
  86 
  87 static const String&amp; centerKeyword()
  88 {
  89     static NeverDestroyed&lt;const String&gt; center(MAKE_STATIC_STRING_IMPL(&quot;center&quot;));
  90     return center;
  91 }
  92 
  93 static const String&amp; endKeyword()
  94 {
  95     static NeverDestroyed&lt;const String&gt; end(MAKE_STATIC_STRING_IMPL(&quot;end&quot;));
  96     return end;
  97 }
  98 
  99 static const String&amp; leftKeyword()
 100 {
 101     static NeverDestroyed&lt;const String&gt; left(MAKE_STATIC_STRING_IMPL(&quot;left&quot;));
 102     return left;
 103 }
 104 
 105 static const String&amp; rightKeyword()
 106 {
 107     static NeverDestroyed&lt;const String&gt; right(MAKE_STATIC_STRING_IMPL(&quot;right&quot;));
 108     return right;
 109 }
 110 
 111 static const String&amp; horizontalKeyword()
 112 {
 113     return emptyString();
 114 }
 115 
 116 static const String&amp; verticalGrowingLeftKeyword()
 117 {
 118     static NeverDestroyed&lt;const String&gt; verticalrl(MAKE_STATIC_STRING_IMPL(&quot;rl&quot;));
 119     return verticalrl;
 120 }
 121 
 122 static const String&amp; verticalGrowingRightKeyword()
 123 {
 124     static NeverDestroyed&lt;const String&gt; verticallr(MAKE_STATIC_STRING_IMPL(&quot;lr&quot;));
 125     return verticallr;
 126 }
 127 
 128 // ----------------------------
 129 
 130 VTTCueBox::VTTCueBox(Document&amp; document, VTTCue&amp; cue)
 131     : TextTrackCueBox(document, cue)
 132 {
 133 }
 134 
 135 void VTTCueBox::applyCSSProperties(const IntSize&amp; videoSize)
 136 {
 137     auto textTrackCue = getCue();
 138     if (!textTrackCue)
 139         return;
 140 
 141     ASSERT(is&lt;VTTCue&gt;(textTrackCue) || is&lt;TextTrackCueGeneric&gt;(textTrackCue));
 142     auto cue = makeRef(*toVTTCue(textTrackCue));
 143 
 144     // FIXME: Apply all the initial CSS positioning properties. http://wkb.ug/79916
 145     if (!cue-&gt;regionId().isEmpty()) {
 146         setInlineStyleProperty(CSSPropertyPosition, CSSValueRelative);
 147         return;
 148     }
 149 
 150     // 3.5.1 On the (root) List of WebVTT Node Objects:
 151 
 152     // the &#39;position&#39; property must be set to &#39;absolute&#39;
 153     setInlineStyleProperty(CSSPropertyPosition, CSSValueAbsolute);
 154 
 155     //  the &#39;unicode-bidi&#39; property must be set to &#39;plaintext&#39;
 156     setInlineStyleProperty(CSSPropertyUnicodeBidi, CSSValuePlaintext);
 157 
 158     // the &#39;direction&#39; property must be set to direction
 159     setInlineStyleProperty(CSSPropertyDirection, cue-&gt;getCSSWritingDirection());
 160 
 161     // the &#39;writing-mode&#39; property must be set to writing-mode
 162     setInlineStyleProperty(CSSPropertyWritingMode, cue-&gt;getCSSWritingMode(), false);
 163 
 164     auto position = cue-&gt;getCSSPosition();
 165 
 166     // the &#39;top&#39; property must be set to top,
 167     setInlineStyleProperty(CSSPropertyTop, position.second, CSSUnitType::CSS_PERCENTAGE);
 168 
 169     // the &#39;left&#39; property must be set to left
 170     if (cue-&gt;vertical() == horizontalKeyword())
 171         setInlineStyleProperty(CSSPropertyLeft, position.first, CSSUnitType::CSS_PERCENTAGE);
 172     else if (cue-&gt;vertical() == verticalGrowingRightKeyword()) {
 173         // FIXME: Why use calc to do the math instead of doing the subtraction here?
 174         setInlineStyleProperty(CSSPropertyLeft, makeString(&quot;calc(-&quot;, videoSize.width(), &quot;px - &quot;, cue-&gt;getCSSSize(), &quot;px)&quot;));
 175     }
 176 
 177     double authorFontSize = std::min(videoSize.width(), videoSize.height()) * DEFAULTCAPTIONFONTSIZEPERCENTAGE / 100.0;
 178     double multiplier = 1.0;
 179     if (authorFontSize)
 180         multiplier = m_fontSizeFromCaptionUserPrefs / authorFontSize;
 181 
 182     double textPosition = cue-&gt;calculateComputedTextPosition();
 183     double maxSize = 100.0;
 184     CSSValueID alignment = cue-&gt;getCSSAlignment();
 185     if (alignment == CSSValueEnd || alignment == CSSValueRight)
 186         maxSize = textPosition;
 187     else if (alignment == CSSValueStart || alignment == CSSValueLeft)
 188         maxSize = 100.0 - textPosition;
 189 
 190     double newCueSize = std::min(cue-&gt;getCSSSize() * multiplier, 100.0);
 191     // the &#39;width&#39; property must be set to width, and the &#39;height&#39; property  must be set to height
 192     if (cue-&gt;vertical() == horizontalKeyword()) {
 193         setInlineStyleProperty(CSSPropertyWidth, newCueSize, CSSUnitType::CSS_PERCENTAGE);
 194         setInlineStyleProperty(CSSPropertyHeight, CSSValueAuto);
 195         setInlineStyleProperty(CSSPropertyMinWidth, &quot;min-content&quot;);
 196         setInlineStyleProperty(CSSPropertyMaxWidth, maxSize, CSSUnitType::CSS_PERCENTAGE);
 197         if ((alignment == CSSValueMiddle || alignment == CSSValueCenter) &amp;&amp; multiplier != 1.0)
 198             setInlineStyleProperty(CSSPropertyLeft, static_cast&lt;double&gt;(position.first - (newCueSize - cue-&gt;getCSSSize()) / 2), CSSUnitType::CSS_PERCENTAGE);
 199     } else {
 200         setInlineStyleProperty(CSSPropertyWidth, CSSValueAuto);
 201         setInlineStyleProperty(CSSPropertyHeight, newCueSize, CSSUnitType::CSS_PERCENTAGE);
 202         setInlineStyleProperty(CSSPropertyMinHeight, &quot;min-content&quot;);
 203         setInlineStyleProperty(CSSPropertyMaxHeight, maxSize, CSSUnitType::CSS_PERCENTAGE);
 204         if ((alignment == CSSValueMiddle || alignment == CSSValueCenter) &amp;&amp; multiplier != 1.0)
 205             setInlineStyleProperty(CSSPropertyTop, static_cast&lt;double&gt;(position.second - (newCueSize - cue-&gt;getCSSSize()) / 2), CSSUnitType::CSS_PERCENTAGE);
 206     }
 207 
 208     // The &#39;text-align&#39; property on the (root) List of WebVTT Node Objects must
 209     // be set to the value in the second cell of the row of the table below
 210     // whose first cell is the value of the corresponding cue&#39;s text track cue
 211     // alignment:
 212     setInlineStyleProperty(CSSPropertyTextAlign, cue-&gt;getCSSAlignment());
 213 
 214     if (!cue-&gt;snapToLines()) {
 215         // 10.13.1 Set up x and y:
 216         // Note: x and y are set through the CSS left and top above.
 217 
 218         // 10.13.2 Position the boxes in boxes such that the point x% along the
 219         // width of the bounding box of the boxes in boxes is x% of the way
 220         // across the width of the video&#39;s rendering area, and the point y%
 221         // along the height of the bounding box of the boxes in boxes is y%
 222         // of the way across the height of the video&#39;s rendering area, while
 223         // maintaining the relative positions of the boxes in boxes to each
 224         // other.
 225         setInlineStyleProperty(CSSPropertyTransform, makeString(&quot;translate(&quot;, -position.first, &quot;%, &quot;, -position.second, &quot;%)&quot;));
 226 
 227         setInlineStyleProperty(CSSPropertyWhiteSpace, CSSValuePre);
 228     }
 229 
 230     // Make sure shadow or stroke is not clipped.
 231     setInlineStyleProperty(CSSPropertyOverflow, CSSValueVisible);
 232     cue-&gt;element().setInlineStyleProperty(CSSPropertyOverflow, CSSValueVisible);
 233 }
 234 
 235 RenderPtr&lt;RenderElement&gt; VTTCueBox::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 236 {
 237     return createRenderer&lt;RenderVTTCue&gt;(*this, WTFMove(style));
 238 }
 239 
 240 // ----------------------------
 241 
 242 Ref&lt;VTTCue&gt; VTTCue::create(ScriptExecutionContext&amp; context, const WebVTTCueData&amp; data)
 243 {
 244     return adoptRef(*new VTTCue(context, data));
 245 }
 246 
 247 VTTCue::VTTCue(ScriptExecutionContext&amp; context, const MediaTime&amp; start, const MediaTime&amp; end, const String&amp; content)
 248     : TextTrackCue(context, start, end)
 249     , m_content(content)
 250 {
 251     initialize(context);
 252 }
 253 
 254 VTTCue::VTTCue(ScriptExecutionContext&amp; context, const WebVTTCueData&amp; cueData)
 255     : TextTrackCue(context, MediaTime::zeroTime(), MediaTime::zeroTime())
 256 {
 257     initialize(context);
 258     setText(cueData.content());
 259     setStartTime(cueData.startTime());
 260     setEndTime(cueData.endTime());
 261     setId(cueData.id());
 262     setCueSettings(cueData.settings());
 263     m_originalStartTime = cueData.originalStartTime();
 264 }
 265 
 266 VTTCue::~VTTCue()
 267 {
 268 }
 269 
 270 void VTTCue::initialize(ScriptExecutionContext&amp; context)
 271 {
 272     m_linePosition = undefinedPosition;
 273     m_computedLinePosition = undefinedPosition;
 274     m_textPosition = std::numeric_limits&lt;double&gt;::quiet_NaN();
 275     m_cueSize = 100;
 276     m_writingDirection = Horizontal;
 277     m_cueAlignment = Center;
 278     m_webVTTNodeTree = nullptr;
 279     m_cueBackdropBox = HTMLDivElement::create(downcast&lt;Document&gt;(context));
 280     m_cueHighlightBox = HTMLSpanElement::create(spanTag, downcast&lt;Document&gt;(context));
 281     m_displayDirection = CSSValueLtr;
 282     m_displaySize = 0;
 283     m_snapToLines = true;
 284     m_displayTreeShouldChange = true;
 285     m_notifyRegion = true;
 286     m_originalStartTime = MediaTime::zeroTime();
 287 }
 288 
 289 Ref&lt;VTTCueBox&gt; VTTCue::createDisplayTree()
 290 {
 291     return VTTCueBox::create(ownerDocument(), *this);
 292 }
 293 
 294 VTTCueBox&amp; VTTCue::displayTreeInternal()
 295 {
 296     if (!m_displayTree)
 297         m_displayTree = createDisplayTree();
 298     return *m_displayTree;
 299 }
 300 
 301 void VTTCue::didChange()
 302 {
 303     TextTrackCue::didChange();
 304     m_displayTreeShouldChange = true;
 305 }
 306 
 307 const String&amp; VTTCue::vertical() const
 308 {
 309     switch (m_writingDirection) {
 310     case Horizontal:
 311         return horizontalKeyword();
 312     case VerticalGrowingLeft:
 313         return verticalGrowingLeftKeyword();
 314     case VerticalGrowingRight:
 315         return verticalGrowingRightKeyword();
 316     default:
 317         ASSERT_NOT_REACHED();
 318         return emptyString();
 319     }
 320 }
 321 
 322 ExceptionOr&lt;void&gt; VTTCue::setVertical(const String&amp; value)
 323 {
 324     // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#dom-texttrackcue-vertical
 325     // On setting, the text track cue writing direction must be set to the value given
 326     // in the first cell of the row in the table above whose second cell is a
 327     // case-sensitive match for the new value, if any. If none of the values match, then
 328     // the user agent must instead throw a SyntaxError exception.
 329 
 330     WritingDirection direction = m_writingDirection;
 331     if (value == horizontalKeyword())
 332         direction = Horizontal;
 333     else if (value == verticalGrowingLeftKeyword())
 334         direction = VerticalGrowingLeft;
 335     else if (value == verticalGrowingRightKeyword())
 336         direction = VerticalGrowingRight;
 337     else
 338         return Exception { SyntaxError };
 339 
 340     if (direction == m_writingDirection)
 341         return { };
 342 
 343     willChange();
 344     m_writingDirection = direction;
 345     didChange();
 346 
 347     return { };
 348 }
 349 
 350 void VTTCue::setSnapToLines(bool value)
 351 {
 352     if (m_snapToLines == value)
 353         return;
 354 
 355     willChange();
 356     m_snapToLines = value;
 357     didChange();
 358 }
 359 
 360 ExceptionOr&lt;void&gt; VTTCue::setLine(double position)
 361 {
 362     // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#dom-texttrackcue-line
 363     // On setting, if the text track cue snap-to-lines flag is not set, and the new
 364     // value is negative or greater than 100, then throw an IndexSizeError exception.
 365     if (!m_snapToLines &amp;&amp; !(position &gt;= 0 &amp;&amp; position &lt;= 100))
 366         return Exception { IndexSizeError };
 367 
 368     // Otherwise, set the text track cue line position to the new value.
 369     if (m_linePosition == position)
 370         return { };
 371 
 372     willChange();
 373     m_linePosition = position;
 374     m_computedLinePosition = calculateComputedLinePosition();
 375     didChange();
 376 
 377     return { };
 378 }
 379 
 380 VTTCue::LineAndPositionSetting VTTCue::position() const
 381 {
 382     if (textPositionIsAuto())
 383         return Auto;
 384     return m_textPosition;
 385 }
 386 
 387 ExceptionOr&lt;void&gt; VTTCue::setPosition(const LineAndPositionSetting&amp; position)
 388 {
 389     // http://dev.w3.org/html5/webvtt/#dfn-vttcue-position
 390     // On setting, if the new value is negative or greater than 100, then an
 391     // IndexSizeError exception must be thrown. Otherwise, the WebVTT cue
 392     // position must be set to the new value; if the new value is the string
 393     // &quot;auto&quot;, then it must be interpreted as the special value auto.
 394     double textPosition = 0;
 395     if (WTF::holds_alternative&lt;AutoKeyword&gt;(position)) {
 396         if (textPositionIsAuto())
 397             return { };
 398         textPosition = std::numeric_limits&lt;double&gt;::quiet_NaN();
 399     } else {
 400         if (!(WTF::get&lt;double&gt;(position) &gt;= 0 &amp;&amp; WTF::get&lt;double&gt;(position) &lt;= 100))
 401             return Exception { IndexSizeError };
 402 
 403         // Otherwise, set the text track cue line position to the new value.
 404         textPosition = WTF::get&lt;double&gt;(position);
 405         if (m_textPosition == textPosition)
 406             return { };
 407     }
 408 
 409     willChange();
 410     m_textPosition = textPosition;
 411     didChange();
 412 
 413     return { };
 414 }
 415 
 416 ExceptionOr&lt;void&gt; VTTCue::setSize(int size)
 417 {
 418     // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#dom-texttrackcue-size
 419     // On setting, if the new value is negative or greater than 100, then throw an IndexSizeError
 420     // exception. Otherwise, set the text track cue size to the new value.
 421     if (!(size &gt;= 0 &amp;&amp; size &lt;= 100))
 422         return Exception { IndexSizeError };
 423 
 424     // Otherwise, set the text track cue line position to the new value.
 425     if (m_cueSize == size)
 426         return { };
 427 
 428     willChange();
 429     m_cueSize = size;
 430     didChange();
 431 
 432     return { };
 433 }
 434 
 435 const String&amp; VTTCue::align() const
 436 {
 437     switch (m_cueAlignment) {
 438     case Start:
 439         return startKeyword();
 440     case Center:
 441         return centerKeyword();
 442     case End:
 443         return endKeyword();
 444     case Left:
 445         return leftKeyword();
 446     case Right:
 447         return rightKeyword();
 448     default:
 449         ASSERT_NOT_REACHED();
 450         return emptyString();
 451     }
 452 }
 453 
 454 ExceptionOr&lt;void&gt; VTTCue::setAlign(const String&amp; value)
 455 {
 456     // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#dom-texttrackcue-align
 457     // On setting, the text track cue alignment must be set to the value given in the
 458     // first cell of the row in the table above whose second cell is a case-sensitive
 459     // match for the new value, if any. If none of the values match, then the user
 460     // agent must instead throw a SyntaxError exception.
 461 
 462     CueAlignment alignment;
 463     if (value == startKeyword())
 464         alignment = Start;
 465     else if (value == centerKeyword())
 466         alignment = Center;
 467     else if (value == endKeyword())
 468         alignment = End;
 469     else if (value == leftKeyword())
 470         alignment = Left;
 471     else if (value == rightKeyword())
 472         alignment = Right;
 473     else
 474         return Exception { SyntaxError };
 475 
 476     if (alignment == m_cueAlignment)
 477         return { };
 478 
 479     willChange();
 480     m_cueAlignment = alignment;
 481     didChange();
 482 
 483     return { };
 484 }
 485 
 486 void VTTCue::setText(const String&amp; text)
 487 {
 488     if (m_content == text)
 489         return;
 490 
 491     willChange();
 492     // Clear the document fragment but don&#39;t bother to create it again just yet as we can do that
 493     // when it is requested.
 494     m_webVTTNodeTree = nullptr;
 495     m_content = text;
 496     didChange();
 497 }
 498 
 499 void VTTCue::createWebVTTNodeTree()
 500 {
 501     if (!m_webVTTNodeTree)
 502         m_webVTTNodeTree = WebVTTParser::createDocumentFragmentFromCueText(ownerDocument(), m_content);
 503 }
 504 
 505 void VTTCue::copyWebVTTNodeToDOMTree(ContainerNode* webVTTNode, ContainerNode* parent)
 506 {
 507     for (RefPtr&lt;Node&gt; node = webVTTNode-&gt;firstChild(); node; node = node-&gt;nextSibling()) {
 508         RefPtr&lt;Node&gt; clonedNode;
 509         if (is&lt;WebVTTElement&gt;(*node))
 510             clonedNode = downcast&lt;WebVTTElement&gt;(*node).createEquivalentHTMLElement(ownerDocument());
 511         else
 512             clonedNode = node-&gt;cloneNode(false);
 513         parent-&gt;appendChild(*clonedNode);
 514         if (is&lt;ContainerNode&gt;(*node))
 515             copyWebVTTNodeToDOMTree(downcast&lt;ContainerNode&gt;(node.get()), downcast&lt;ContainerNode&gt;(clonedNode.get()));
 516     }
 517 }
 518 
 519 RefPtr&lt;DocumentFragment&gt; VTTCue::getCueAsHTML()
 520 {
 521     createWebVTTNodeTree();
 522     if (!m_webVTTNodeTree)
 523         return nullptr;
 524 
 525     auto clonedFragment = DocumentFragment::create(ownerDocument());
 526     copyWebVTTNodeToDOMTree(m_webVTTNodeTree.get(), clonedFragment.ptr());
 527     return clonedFragment;
 528 }
 529 
 530 RefPtr&lt;DocumentFragment&gt; VTTCue::createCueRenderingTree()
 531 {
 532     createWebVTTNodeTree();
 533     if (!m_webVTTNodeTree)
 534         return nullptr;
 535 
 536     auto clonedFragment = DocumentFragment::create(ownerDocument());
 537 
 538     // The cloned fragment is never exposed to author scripts so it&#39;s safe to dispatch events here.
 539     ScriptDisallowedScope::EventAllowedScope allowedScope(clonedFragment);
 540 
 541     m_webVTTNodeTree-&gt;cloneChildNodes(clonedFragment);
 542     return clonedFragment;
 543 }
 544 
 545 void VTTCue::setRegionId(const String&amp; regionId)
 546 {
 547     if (m_regionId == regionId)
 548         return;
 549 
 550     willChange();
 551     m_regionId = regionId;
 552     didChange();
 553 }
 554 
 555 void VTTCue::notifyRegionWhenRemovingDisplayTree(bool notifyRegion)
 556 {
 557     m_notifyRegion = notifyRegion;
 558 }
 559 
 560 void VTTCue::setIsActive(bool active)
 561 {
 562     TextTrackCue::setIsActive(active);
 563 
 564     if (!active) {
 565         if (!hasDisplayTree())
 566             return;
 567 
 568         // Remove the display tree as soon as the cue becomes inactive.
 569         removeDisplayTree();
 570     }
 571 }
 572 
 573 int VTTCue::calculateComputedLinePosition()
 574 {
 575     // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-computed-line-position
 576 
 577     // If the text track cue line position is numeric, then that is the text
 578     // track cue computed line position.
 579     if (m_linePosition != undefinedPosition)
 580         return m_linePosition;
 581 
 582     // If the text track cue snap-to-lines flag of the text track cue is not
 583     // set, the text track cue computed line position is the value 100;
 584     if (!m_snapToLines)
 585         return 100;
 586 
 587     // Otherwise, it is the value returned by the following algorithm:
 588 
 589     // If cue is not associated with a text track, return -1 and abort these
 590     // steps.
 591     if (!track())
 592         return -1;
 593 
 594     // Let n be the number of text tracks whose text track mode is showing or
 595     // showing by default and that are in the media element&#39;s list of text
 596     // tracks before track.
 597     int n = track()-&gt;trackIndexRelativeToRenderedTracks();
 598 
 599     // Increment n by one.
 600     n++;
 601 
 602     // Negate n.
 603     n = -n;
 604 
 605     return n;
 606 }
 607 
 608 static bool isCueParagraphSeparator(UChar character)
 609 {
 610     // Within a cue, paragraph boundaries are only denoted by Type B characters,
 611     // such as U+000A LINE FEED (LF), U+0085 NEXT LINE (NEL), and U+2029 PARAGRAPH SEPARATOR.
 612     return u_charType(character) == U_PARAGRAPH_SEPARATOR;
 613 }
 614 
 615 bool VTTCue::textPositionIsAuto() const
 616 {
 617     return std::isnan(m_textPosition);
 618 }
 619 
 620 void VTTCue::determineTextDirection()
 621 {
 622     static NeverDestroyed&lt;const String&gt; rtTag(MAKE_STATIC_STRING_IMPL(&quot;rt&quot;));
 623     createWebVTTNodeTree();
 624     if (!m_webVTTNodeTree)
 625         return;
 626 
 627     // Apply the Unicode Bidirectional Algorithm&#39;s Paragraph Level steps to the
 628     // concatenation of the values of each WebVTT Text Object in nodes, in a
 629     // pre-order, depth-first traversal, excluding WebVTT Ruby Text Objects and
 630     // their descendants.
 631     StringBuilder paragraphBuilder;
 632     for (RefPtr&lt;Node&gt; node = m_webVTTNodeTree-&gt;firstChild(); node; node = NodeTraversal::next(*node, m_webVTTNodeTree.get())) {
 633         // FIXME: The code does not match the comment above. This does not actually exclude Ruby Text Object descendant.
 634         if (!node-&gt;isTextNode() || node-&gt;localName() == rtTag)
 635             continue;
 636 
 637         paragraphBuilder.append(node-&gt;nodeValue());
 638     }
 639 
 640     String paragraph = paragraphBuilder.toString();
 641     if (!paragraph.length())
 642         return;
 643 
 644     for (size_t i = 0; i &lt; paragraph.length(); ++i) {
 645         UChar current = paragraph[i];
 646         if (!current || isCueParagraphSeparator(current))
 647             return;
 648 
 649         if (UChar current = paragraph[i]) {
 650             UCharDirection charDirection = u_charDirection(current);
 651             if (charDirection == U_LEFT_TO_RIGHT) {
 652                 m_displayDirection = CSSValueLtr;
 653                 return;
 654             }
 655             if (charDirection == U_RIGHT_TO_LEFT || charDirection == U_RIGHT_TO_LEFT_ARABIC) {
 656                 m_displayDirection = CSSValueRtl;
 657                 return;
 658             }
 659         }
 660     }
 661 }
 662 
 663 double VTTCue::calculateComputedTextPosition() const
 664 {
 665     // http://dev.w3.org/html5/webvtt/#dfn-cue-computed-position
 666 
 667     // 1. If the position is numeric, then return the value of the position and
 668     // abort these steps. (Otherwise, the position is the special value auto.)
 669     if (!textPositionIsAuto())
 670         return m_textPosition;
 671 
 672     switch (m_cueAlignment) {
 673     case Start:
 674     case Left:
 675         // 2. If the cue text alignment is start or left, return 0 and abort these
 676         // steps.
 677         return 0;
 678     case End:
 679     case Right:
 680         // 3. If the cue text alignment is end or right, return 100 and abort these
 681         // steps.
 682         return 100;
 683     case Center:
 684         // 4. If the cue text alignment is center, return 50 and abort these steps.
 685         return 50;
 686     default:
 687         ASSERT_NOT_REACHED();
 688         return 0;
 689     }
 690 }
 691 
 692 void VTTCue::calculateDisplayParameters()
 693 {
 694     // Steps 10.2, 10.3
 695     determineTextDirection();
 696 
 697     // 10.4 If the text track cue writing direction is horizontal, then let
 698     // block-flow be &#39;tb&#39;. Otherwise, if the text track cue writing direction is
 699     // vertical growing left, then let block-flow be &#39;lr&#39;. Otherwise, the text
 700     // track cue writing direction is vertical growing right; let block-flow be
 701     // &#39;rl&#39;.
 702 
 703     // The above step is done through the writing direction static map.
 704 
 705     // 10.5 Determine the value of maximum size for cue as per the appropriate
 706     // rules from the following list:
 707     double computedTextPosition = calculateComputedTextPosition();
 708     int maximumSize = computedTextPosition;
 709     if ((m_writingDirection == Horizontal &amp;&amp; m_cueAlignment == Start &amp;&amp; m_displayDirection == CSSValueLtr)
 710         || (m_writingDirection == Horizontal &amp;&amp; m_cueAlignment == End &amp;&amp; m_displayDirection == CSSValueRtl)
 711         || (m_writingDirection == Horizontal &amp;&amp; m_cueAlignment == Left)
 712         || (m_writingDirection == VerticalGrowingLeft &amp;&amp; (m_cueAlignment == Start || m_cueAlignment == Left))
 713         || (m_writingDirection == VerticalGrowingRight &amp;&amp; (m_cueAlignment == Start || m_cueAlignment == Left))) {
 714         maximumSize = 100 - computedTextPosition;
 715     } else if ((m_writingDirection == Horizontal &amp;&amp; m_cueAlignment == End &amp;&amp; m_displayDirection == CSSValueLtr)
 716         || (m_writingDirection == Horizontal &amp;&amp; m_cueAlignment == Start &amp;&amp; m_displayDirection == CSSValueRtl)
 717         || (m_writingDirection == Horizontal &amp;&amp; m_cueAlignment == Right)
 718         || (m_writingDirection == VerticalGrowingLeft &amp;&amp; (m_cueAlignment == End || m_cueAlignment == Right))
 719         || (m_writingDirection == VerticalGrowingRight &amp;&amp; (m_cueAlignment == End || m_cueAlignment == Right))) {
 720         maximumSize = computedTextPosition;
 721     } else if (m_cueAlignment == Center) {
 722         maximumSize = computedTextPosition &lt;= 50 ? computedTextPosition : (100 - computedTextPosition);
 723         maximumSize = maximumSize * 2;
 724     } else
 725         ASSERT_NOT_REACHED();
 726 
 727     // 10.6 If the text track cue size is less than maximum size, then let size
 728     // be text track cue size. Otherwise, let size be maximum size.
 729     m_displaySize = std::min(m_cueSize, maximumSize);
 730 
 731     // FIXME: Understand why step 10.7 is missing (just a copy/paste error?)
 732     // Could be done within a spec implementation check - http://crbug.com/301580
 733 
 734     // 10.8 Determine the value of x-position or y-position for cue as per the
 735     // appropriate rules from the following list:
 736     if (m_writingDirection == Horizontal) {
 737         switch (m_cueAlignment) {
 738         case Start:
 739             if (m_displayDirection == CSSValueLtr)
 740                 m_displayPosition.first = computedTextPosition;
 741             else
 742                 m_displayPosition.first = 100 - computedTextPosition - m_displaySize;
 743             break;
 744         case End:
 745             if (m_displayDirection == CSSValueRtl)
 746                 m_displayPosition.first = 100 - computedTextPosition;
 747             else
 748                 m_displayPosition.first = computedTextPosition - m_displaySize;
 749             break;
 750         case Left:
 751             if (m_displayDirection == CSSValueLtr)
 752                 m_displayPosition.first = computedTextPosition;
 753             else
 754                 m_displayPosition.first = 100 - computedTextPosition;
 755             break;
 756         case Right:
 757             if (m_displayDirection == CSSValueLtr)
 758                 m_displayPosition.first = computedTextPosition - m_displaySize;
 759             else
 760                 m_displayPosition.first = 100 - computedTextPosition - m_displaySize;
 761             break;
 762         case Center:
 763             if (m_displayDirection == CSSValueLtr)
 764                 m_displayPosition.first = computedTextPosition - m_displaySize / 2;
 765             else
 766                 m_displayPosition.first = 100 - computedTextPosition - m_displaySize / 2;
 767             break;
 768         case NumberOfAlignments:
 769             ASSERT_NOT_REACHED();
 770         }
 771     }
 772 
 773     // A text track cue has a text track cue computed line position whose value
 774     // is defined in terms of the other aspects of the cue.
 775     m_computedLinePosition = calculateComputedLinePosition();
 776 
 777     // 10.9 Determine the value of whichever of x-position or y-position is not
 778     // yet calculated for cue as per the appropriate rules from the following
 779     // list:
 780     if (m_snapToLines &amp;&amp; m_displayPosition.second == undefinedPosition &amp;&amp; m_writingDirection == Horizontal)
 781         m_displayPosition.second = 0;
 782 
 783     if (!m_snapToLines &amp;&amp; m_displayPosition.second == undefinedPosition &amp;&amp; m_writingDirection == Horizontal)
 784         m_displayPosition.second = m_computedLinePosition;
 785 
 786     if (m_snapToLines &amp;&amp; m_displayPosition.first == undefinedPosition
 787         &amp;&amp; (m_writingDirection == VerticalGrowingLeft || m_writingDirection == VerticalGrowingRight))
 788         m_displayPosition.first = 0;
 789 
 790     if (!m_snapToLines &amp;&amp; (m_writingDirection == VerticalGrowingLeft || m_writingDirection == VerticalGrowingRight))
 791         m_displayPosition.first = m_computedLinePosition;
 792 }
 793 
 794 void VTTCue::markFutureAndPastNodes(ContainerNode* root, const MediaTime&amp; previousTimestamp, const MediaTime&amp; movieTime)
 795 {
 796     static NeverDestroyed&lt;const String&gt; timestampTag(MAKE_STATIC_STRING_IMPL(&quot;timestamp&quot;));
 797 
 798     bool isPastNode = true;
 799     MediaTime currentTimestamp = previousTimestamp;
 800     if (currentTimestamp &gt; movieTime)
 801         isPastNode = false;
 802 
 803     for (RefPtr&lt;Node&gt; child = root-&gt;firstChild(); child; child = NodeTraversal::next(*child, root)) {
 804         if (child-&gt;nodeName() == timestampTag) {
 805             MediaTime currentTimestamp;
 806             bool check = WebVTTParser::collectTimeStamp(child-&gt;nodeValue(), currentTimestamp);
 807             ASSERT_UNUSED(check, check);
 808 
 809             currentTimestamp += m_originalStartTime;
 810             if (currentTimestamp &gt; movieTime)
 811                 isPastNode = false;
 812         }
 813 
 814         if (is&lt;WebVTTElement&gt;(*child)) {
 815             downcast&lt;WebVTTElement&gt;(*child).setIsPastNode(isPastNode);
 816             // Make an elemenet id match a cue id for style matching purposes.
 817             if (!id().isEmpty())
 818                 downcast&lt;WebVTTElement&gt;(*child).setIdAttribute(id());
 819         }
 820     }
 821 }
 822 
 823 void VTTCue::updateDisplayTree(const MediaTime&amp; movieTime)
 824 {
 825     // The display tree may contain WebVTT timestamp objects representing
 826     // timestamps (processing instructions), along with displayable nodes.
 827 
 828     if (!track()-&gt;isRendered())
 829         return;
 830 
 831     // Mutating the VTT contents is safe because it&#39;s never exposed to author scripts.
 832     ScriptDisallowedScope::EventAllowedScope allowedScopeForCueHighlightBox(*m_cueHighlightBox);
 833 
 834     // Clear the contents of the set.
 835     m_cueHighlightBox-&gt;removeChildren();
 836 
 837     // Update the two sets containing past and future WebVTT objects.
 838     RefPtr&lt;DocumentFragment&gt; referenceTree = createCueRenderingTree();
 839     if (!referenceTree)
 840         return;
 841 
 842     ScriptDisallowedScope::EventAllowedScope allowedScopeForReferenceTree(*referenceTree);
 843 
 844     markFutureAndPastNodes(referenceTree.get(), startMediaTime(), movieTime);
 845     m_cueHighlightBox-&gt;appendChild(*referenceTree);
 846 }
 847 
 848 RefPtr&lt;TextTrackCueBox&gt; VTTCue::getDisplayTree(const IntSize&amp; videoSize, int fontSize)
 849 {
 850     Ref&lt;VTTCueBox&gt; displayTree = displayTreeInternal();
 851     if (!m_displayTreeShouldChange || !track()-&gt;isRendered())
 852         return displayTree;
 853 
 854     // 10.1 - 10.10
 855     calculateDisplayParameters();
 856 
 857     // 10.11. Apply the terms of the CSS specifications to nodes within the
 858     // following constraints, thus obtaining a set of CSS boxes positioned
 859     // relative to an initial containing block:
 860     displayTree-&gt;removeChildren();
 861 
 862     // The document tree is the tree of WebVTT Node Objects rooted at nodes.
 863 
 864     // The children of the nodes must be wrapped in an anonymous box whose
 865     // &#39;display&#39; property has the value &#39;inline&#39;. This is the WebVTT cue
 866     // background box.
 867 
 868     // Note: This is contained by default in m_cueHighlightBox.
 869     m_cueHighlightBox-&gt;setPseudo(cueShadowPseudoId());
 870 
 871     m_cueBackdropBox-&gt;setPseudo(cueBackdropShadowPseudoId());
 872     m_cueBackdropBox-&gt;appendChild(*m_cueHighlightBox);
 873     displayTree-&gt;appendChild(*m_cueBackdropBox);
 874 
 875     // FIXME(BUG 79916): Runs of children of WebVTT Ruby Objects that are not
 876     // WebVTT Ruby Text Objects must be wrapped in anonymous boxes whose
 877     // &#39;display&#39; property has the value &#39;ruby-base&#39;.
 878 
 879     displayTree-&gt;setFontSizeFromCaptionUserPrefs(fontSize);
 880     displayTree-&gt;applyCSSProperties(videoSize);
 881 
 882     if (displayTree-&gt;document().page()) {
 883         auto cssString = displayTree-&gt;document().page()-&gt;captionUserPreferencesStyleSheet();
 884         auto style = HTMLStyleElement::create(HTMLNames::styleTag, displayTree-&gt;document(), false);
 885         style-&gt;setTextContent(cssString);
 886         displayTree-&gt;appendChild(style);
 887     }
 888 
 889     const auto&amp; styleSheets = track()-&gt;styleSheets();
 890     if (styleSheets) {
 891         for (const auto&amp; cssString : *styleSheets) {
 892             auto style = HTMLStyleElement::create(HTMLNames::styleTag, displayTree-&gt;document(), false);
 893             style-&gt;setTextContent(cssString);
 894             displayTree-&gt;appendChild(style);
 895         }
 896     }
 897 
 898     if (m_fontSize)
 899         displayTree-&gt;setInlineStyleProperty(CSSPropertyFontSize, m_fontSize, CSSUnitType::CSS_PX, m_fontSizeIsImportant);
 900 
 901     m_displayTreeShouldChange = false;
 902 
 903     if (track()) {
 904         if (auto* regions = track()-&gt;regions()) {
 905             if (auto region = regions-&gt;getRegionById(m_regionId))
 906                 region-&gt;cueStyleChanged();
 907         }
 908     }
 909 
 910     // 10.15. Let cue&#39;s text track cue display state have the CSS boxes in
 911     // boxes.
 912     return displayTree;
 913 }
 914 
 915 void VTTCue::removeDisplayTree()
 916 {
 917     if (!hasDisplayTree())
 918         return;
 919 
 920     // The region needs to be informed about the cue removal.
 921     if (m_notifyRegion &amp;&amp; track()) {
 922         if (VTTRegionList* regions = track()-&gt;regions()) {
 923             if (RefPtr&lt;VTTRegion&gt; region = regions-&gt;getRegionById(m_regionId)) {
 924                 if (hasDisplayTree())
 925                     region-&gt;willRemoveTextTrackCueBox(m_displayTree.get());
 926             }
 927         }
 928     }
 929 
 930     // The display tree is never exposed to author scripts so it&#39;s safe to dispatch events here.
 931     ScriptDisallowedScope::EventAllowedScope allowedScope(displayTreeInternal());
 932     displayTreeInternal().remove();
 933 }
 934 
 935 std::pair&lt;double, double&gt; VTTCue::getPositionCoordinates() const
 936 {
 937     // This method is used for setting x and y when snap to lines is not set.
 938     std::pair&lt;double, double&gt; coordinates;
 939 
 940     auto textPosition = calculateComputedTextPosition();
 941 
 942     if (m_writingDirection == Horizontal &amp;&amp; m_displayDirection == CSSValueLtr) {
 943         coordinates.first = textPosition;
 944         coordinates.second = m_computedLinePosition;
 945 
 946         return coordinates;
 947     }
 948 
 949     if (m_writingDirection == Horizontal &amp;&amp; m_displayDirection == CSSValueRtl) {
 950         coordinates.first = 100 - textPosition;
 951         coordinates.second = m_computedLinePosition;
 952 
 953         return coordinates;
 954     }
 955 
 956     if (m_writingDirection == VerticalGrowingLeft) {
 957         coordinates.first = 100 - m_computedLinePosition;
 958         coordinates.second = textPosition;
 959 
 960         return coordinates;
 961     }
 962 
 963     if (m_writingDirection == VerticalGrowingRight) {
 964         coordinates.first = m_computedLinePosition;
 965         coordinates.second = textPosition;
 966 
 967         return coordinates;
 968     }
 969 
 970     ASSERT_NOT_REACHED();
 971 
 972     return coordinates;
 973 }
 974 
 975 VTTCue::CueSetting VTTCue::settingName(VTTScanner&amp; input)
 976 {
 977     CueSetting parsedSetting = None;
 978     if (input.scan(&quot;vertical&quot;))
 979         parsedSetting = Vertical;
 980     else if (input.scan(&quot;line&quot;))
 981         parsedSetting = Line;
 982     else if (input.scan(&quot;position&quot;))
 983         parsedSetting = Position;
 984     else if (input.scan(&quot;size&quot;))
 985         parsedSetting = Size;
 986     else if (input.scan(&quot;align&quot;))
 987         parsedSetting = Align;
 988     else if (input.scan(&quot;region&quot;))
 989         parsedSetting = RegionId;
 990 
 991     // Verify that a &#39;:&#39; follows.
 992     if (parsedSetting != None &amp;&amp; input.scan(&#39;:&#39;))
 993         return parsedSetting;
 994 
 995     return None;
 996 }
 997 
 998 void VTTCue::setCueSettings(const String&amp; inputString)
 999 {
1000     if (inputString.isEmpty())
1001         return;
1002 
1003     VTTScanner input(inputString);
1004 
1005     while (!input.isAtEnd()) {
1006 
1007         // The WebVTT cue settings part of a WebVTT cue consists of zero or more of the following components, in any order,
1008         // separated from each other by one or more U+0020 SPACE characters or U+0009 CHARACTER TABULATION (tab) characters.
1009         input.skipWhile&lt;WebVTTParser::isValidSettingDelimiter&gt;();
1010         if (input.isAtEnd())
1011             break;
1012 
1013         // When the user agent is to parse the WebVTT settings given by a string input for a text track cue cue,
1014         // the user agent must run the following steps:
1015         // 1. Let settings be the result of splitting input on spaces.
1016         // 2. For each token setting in the list settings, run the following substeps:
1017         //    1. If setting does not contain a U+003A COLON character (:), or if the first U+003A COLON character (:)
1018         //       in setting is either the first or last character of setting, then jump to the step labeled next setting.
1019         //    2. Let name be the leading substring of setting up to and excluding the first U+003A COLON character (:) in that string.
1020         CueSetting name = settingName(input);
1021 
1022         // 3. Let value be the trailing substring of setting starting from the character immediately after the first U+003A COLON character (:) in that string.
1023         VTTScanner::Run valueRun = input.collectUntil&lt;WebVTTParser::isValidSettingDelimiter&gt;();
1024 
1025         // 4. Run the appropriate substeps that apply for the value of name, as follows:
1026         switch (name) {
1027         case Vertical: {
1028             // If name is a case-sensitive match for &quot;vertical&quot;
1029             // 1. If value is a case-sensitive match for the string &quot;rl&quot;, then let cue&#39;s text track cue writing direction
1030             //    be vertical growing left.
1031             if (input.scanRun(valueRun, verticalGrowingLeftKeyword()))
1032                 m_writingDirection = VerticalGrowingLeft;
1033 
1034             // 2. Otherwise, if value is a case-sensitive match for the string &quot;lr&quot;, then let cue&#39;s text track cue writing
1035             //    direction be vertical growing right.
1036             else if (input.scanRun(valueRun, verticalGrowingRightKeyword()))
1037                 m_writingDirection = VerticalGrowingRight;
1038 
1039             else
1040                 LOG(Media, &quot;VTTCue::setCueSettings, invalid Vertical&quot;);
1041             break;
1042         }
1043         case Line: {
1044             bool isValid = false;
1045             do {
1046                 // 1-2 - Collect chars that are either &#39;-&#39;, &#39;%&#39;, or a digit.
1047                 // 1. If value contains any characters other than U+002D HYPHEN-MINUS characters (-), U+0025 PERCENT SIGN
1048                 //    characters (%), and characters in the range U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE (9), then jump
1049                 //    to the step labeled next setting.
1050                 float linePosition;
1051                 bool isNegative;
1052                 if (!input.scanFloat(linePosition, &amp;isNegative))
1053                     break;
1054 
1055                 bool isPercentage = input.scan(&#39;%&#39;);
1056                 if (!input.isAt(valueRun.end())) {
1057                     if (!input.scan(&#39;,&#39;))
1058                         break;
1059                     // FIXME: implement handling of line setting alignment.
1060                     if (!input.scan(startKeyword().characters8(), startKeyword().length())
1061                         &amp;&amp; !input.scan(centerKeyword().characters8(), centerKeyword().length())
1062                         &amp;&amp; !input.scan(endKeyword().characters8(), endKeyword().length())) {
1063                         LOG(Media, &quot;VTTCue::setCueSettings, invalid line setting alignment&quot;);
1064                         break;
1065                     }
1066                 }
1067 
1068                 // 2. If value does not contain at least one character in the range U+0030 DIGIT ZERO (0) to U+0039 DIGIT
1069                 //    NINE (9), then jump to the step labeled next setting.
1070                 // 3. If any character in value other than the first character is a U+002D HYPHEN-MINUS character (-), then
1071                 //    jump to the step labeled next setting.
1072                 // 4. If any character in value other than the last character is a U+0025 PERCENT SIGN character (%), then
1073                 //    jump to the step labeled next setting.
1074                 // 5. If the first character in value is a U+002D HYPHEN-MINUS character (-) and the last character in value is a
1075                 //    U+0025 PERCENT SIGN character (%), then jump to the step labeled next setting.
1076                 if (isPercentage &amp;&amp; isNegative)
1077                     break;
1078 
1079                 // 6. Ignoring the trailing percent sign, if any, interpret value as a (potentially signed) integer, and
1080                 //    let number be that number.
1081                 // 7. If the last character in value is a U+0025 PERCENT SIGN character (%), but number is not in the range
1082                 //    0 ≤ number ≤ 100, then jump to the step labeled next setting.
1083                 // 8. Let cue&#39;s text track cue line position be number.
1084                 // 9. If the last character in value is a U+0025 PERCENT SIGN character (%), then let cue&#39;s text track cue
1085                 //    snap-to-lines flag be false. Otherwise, let it be true.
1086                 if (isPercentage) {
1087                     if (linePosition &lt; 0 || linePosition &gt; 100)
1088                         break;
1089 
1090                     // 10 - If &#39;%&#39; then set snap-to-lines flag to false.
1091                     m_snapToLines = false;
1092                 } else {
1093                     if (linePosition - static_cast&lt;int&gt;(linePosition))
1094                         break;
1095 
1096                     m_snapToLines = true;
1097                 }
1098 
1099                 m_linePosition = linePosition;
1100                 isValid = true;
1101             } while (0);
1102 
1103             if (!isValid)
1104                 LOG(Media, &quot;VTTCue::setCueSettings, invalid Line&quot;);
1105 
1106             break;
1107         }
1108         case Position: {
1109             float position;
1110             if (WebVTTParser::parseFloatPercentageValue(input, position) &amp;&amp; input.isAt(valueRun.end()))
1111                 m_textPosition = position;
1112             else
1113                 LOG(Media, &quot;VTTCue::setCueSettings, invalid Position&quot;);
1114             break;
1115         }
1116         case Size: {
1117             float cueSize;
1118             if (WebVTTParser::parseFloatPercentageValue(input, cueSize) &amp;&amp; input.isAt(valueRun.end()))
1119                 m_cueSize = cueSize;
1120             else
1121                 LOG(Media, &quot;VTTCue::setCueSettings, invalid Size&quot;);
1122             break;
1123         }
1124         case Align: {
1125             // 1. If value is a case-sensitive match for the string &quot;start&quot;, then let cue&#39;s text track cue alignment be start alignment.
1126             if (input.scanRun(valueRun, startKeyword()))
1127                 m_cueAlignment = Start;
1128 
1129             // 2. If value is a case-sensitive match for the string &quot;center&quot;, then let cue&#39;s text track cue alignment be center alignment.
1130             else if (input.scanRun(valueRun, centerKeyword()))
1131                 m_cueAlignment = Center;
1132 
1133             // 3. If value is a case-sensitive match for the string &quot;end&quot;, then let cue&#39;s text track cue alignment be end alignment.
1134             else if (input.scanRun(valueRun, endKeyword()))
1135                 m_cueAlignment = End;
1136 
1137             // 4. If value is a case-sensitive match for the string &quot;left&quot;, then let cue&#39;s text track cue alignment be left alignment.
1138             else if (input.scanRun(valueRun, leftKeyword()))
1139                 m_cueAlignment = Left;
1140 
1141             // 5. If value is a case-sensitive match for the string &quot;right&quot;, then let cue&#39;s text track cue alignment be right alignment.
1142             else if (input.scanRun(valueRun, rightKeyword()))
1143                 m_cueAlignment = Right;
1144 
1145             else
1146                 LOG(Media, &quot;VTTCue::setCueSettings, invalid Align&quot;);
1147 
1148             break;
1149         }
1150         case RegionId:
1151             m_regionId = input.extractString(valueRun);
1152             break;
1153         case None:
1154             break;
1155         }
1156 
1157         // Make sure the entire run is consumed.
1158         input.skipRun(valueRun);
1159     }
1160 
1161     // If cue&#39;s line position is not auto or cue&#39;s size is not 100 or cue&#39;s
1162     // writing direction is not horizontal, but cue&#39;s region identifier is not
1163     // the empty string, let cue&#39;s region identifier be the empty string.
1164     if (m_regionId.isEmpty())
1165         return;
1166 
1167     if (m_linePosition != undefinedPosition || m_cueSize != 100 || m_writingDirection != Horizontal)
1168         m_regionId = emptyString();
1169 }
1170 
1171 CSSValueID VTTCue::getCSSAlignment() const
1172 {
1173     return displayAlignmentMap[m_cueAlignment];
1174 }
1175 
1176 CSSValueID VTTCue::getCSSWritingDirection() const
1177 {
1178     return m_displayDirection;
1179 }
1180 
1181 CSSValueID VTTCue::getCSSWritingMode() const
1182 {
1183     return displayWritingModeMap[m_writingDirection];
1184 }
1185 
1186 int VTTCue::getCSSSize() const
1187 {
1188     return m_displaySize;
1189 }
1190 
1191 std::pair&lt;double, double&gt; VTTCue::getCSSPosition() const
1192 {
1193     if (!m_snapToLines)
1194         return getPositionCoordinates();
1195 
1196     return m_displayPosition;
1197 }
1198 
1199 bool VTTCue::cueContentsMatch(const TextTrackCue&amp; cue) const
1200 {
1201     RefPtr&lt;const VTTCue&gt; vttCue = toVTTCue(&amp;cue);
1202     if (text() != vttCue-&gt;text())
1203         return false;
1204     if (cueSettings() != vttCue-&gt;cueSettings())
1205         return false;
1206     if (position() != vttCue-&gt;position())
1207         return false;
1208     if (line() != vttCue-&gt;line())
1209         return false;
1210     if (size() != vttCue-&gt;size())
1211         return false;
1212     if (align() != vttCue-&gt;align())
1213         return false;
1214 
1215     return true;
1216 }
1217 
1218 bool VTTCue::isEqual(const TextTrackCue&amp; cue, TextTrackCue::CueMatchRules match) const
1219 {
1220     if (!TextTrackCue::isEqual(cue, match))
1221         return false;
1222 
1223     if (cue.cueType() != WebVTT)
1224         return false;
1225 
1226     return cueContentsMatch(cue);
1227 }
1228 
1229 bool VTTCue::doesExtendCue(const TextTrackCue&amp; cue) const
1230 {
1231     if (!cueContentsMatch(cue))
1232         return false;
1233 
1234     return TextTrackCue::doesExtendCue(cue);
1235 }
1236 
1237 void VTTCue::setFontSize(int fontSize, const IntSize&amp;, bool important)
1238 {
1239     if (fontSize == m_fontSize &amp;&amp; important == m_fontSizeIsImportant)
1240         return;
1241 
1242     m_displayTreeShouldChange = true;
1243     m_fontSizeIsImportant = important;
1244     m_fontSize = fontSize;
1245 }
1246 
1247 VTTCue* toVTTCue(TextTrackCue* cue)
1248 {
1249     return const_cast&lt;VTTCue*&gt;(toVTTCue(const_cast&lt;const TextTrackCue*&gt;(cue)));
1250 }
1251 
1252 const VTTCue* toVTTCue(const TextTrackCue* cue)
1253 {
1254     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(is&lt;VTTCue&gt;(cue) || is&lt;TextTrackCueGeneric&gt;(cue));
1255     return static_cast&lt;const VTTCue*&gt;(cue);
1256 }
1257 
1258 String VTTCue::toJSONString() const
1259 {
1260     auto object = JSON::Object::create();
1261     toJSON(object.get());
1262 
1263     return object-&gt;toJSONString();
1264 }
1265 
1266 void VTTCue::toJSON(JSON::Object&amp; object) const
1267 {
1268     TextTrackCue::toJSON(object);
1269 
1270 #if !LOG_DISABLED
1271     object.setString(&quot;text&quot;_s, text());
1272 #endif
1273     object.setString(&quot;vertical&quot;_s, vertical());
1274     object.setBoolean(&quot;snapToLines&quot;_s, snapToLines());
1275     object.setDouble(&quot;line&quot;_s, m_linePosition);
1276     if (textPositionIsAuto())
1277         object.setString(&quot;position&quot;_s, &quot;auto&quot;);
1278     else
1279         object.setDouble(&quot;position&quot;_s, m_textPosition);
1280     object.setInteger(&quot;size&quot;_s, m_cueSize);
1281     object.setString(&quot;align&quot;_s, align());
1282     object.setString(&quot;regionId&quot;_s, regionId());
1283 }
1284 
1285 } // namespace WebCore
1286 
1287 #endif
    </pre>
  </body>
</html>
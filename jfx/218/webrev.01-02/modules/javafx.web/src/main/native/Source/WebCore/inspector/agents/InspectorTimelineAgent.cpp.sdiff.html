<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorTimelineAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorPageAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorTimelineAgent.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorTimelineAgent.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 19 *
 20 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 21 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 22 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 23 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 24 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 25 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 26 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 27 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 28 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 29 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 30 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 31 */
 32 
 33 #include &quot;config.h&quot;
 34 #include &quot;InspectorTimelineAgent.h&quot;
 35 
 36 #include &quot;DOMWindow.h&quot;
 37 #include &quot;Event.h&quot;
 38 #include &quot;Frame.h&quot;

 39 #include &quot;InspectorCPUProfilerAgent.h&quot;
 40 #include &quot;InspectorClient.h&quot;
 41 #include &quot;InspectorController.h&quot;
 42 #include &quot;InspectorMemoryAgent.h&quot;
 43 #include &quot;InspectorPageAgent.h&quot;
 44 #include &quot;InstrumentingAgents.h&quot;
 45 #include &quot;JSDOMWindow.h&quot;
 46 #include &quot;PageHeapAgent.h&quot;
 47 #include &quot;PageScriptDebugServer.h&quot;
 48 #include &quot;RenderView.h&quot;
 49 #include &quot;ScriptState.h&quot;
 50 #include &quot;TimelineRecordFactory.h&quot;
 51 #include &quot;WebConsoleAgent.h&quot;

 52 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
<span class="line-removed"> 53 #include &lt;JavaScriptCore/InspectorDebuggerAgent.h&gt;</span>
 54 #include &lt;JavaScriptCore/InspectorScriptProfilerAgent.h&gt;
 55 #include &lt;JavaScriptCore/ScriptBreakpoint.h&gt;
 56 #include &lt;wtf/Stopwatch.h&gt;
 57 
 58 #if PLATFORM(IOS_FAMILY)
 59 #include &quot;RuntimeApplicationChecks.h&quot;
 60 #include &quot;WebCoreThreadInternal.h&quot;
 61 #endif
 62 
 63 #if PLATFORM(COCOA)
 64 #include &quot;RunLoopObserver.h&quot;
 65 #endif
 66 
 67 
 68 namespace WebCore {
 69 
 70 using namespace Inspector;
 71 
 72 #if PLATFORM(COCOA)
 73 static CFRunLoopRef currentRunLoop()
</pre>
<hr />
<pre>
235 
236 void InspectorTimelineAgent::internalStop()
237 {
238     if (!m_tracking)
239         return;
240 
241     m_instrumentingAgents.setTrackingInspectorTimelineAgent(nullptr);
242 
243     m_environment.scriptDebugServer().removeListener(this, true);
244 
245 #if PLATFORM(COCOA)
246     m_frameStartObserver = nullptr;
247     m_frameStopObserver = nullptr;
248     m_runLoopNestingLevel = 0;
249 
250     // Complete all pending records to prevent discarding events that are currently in progress.
251     while (!m_recordStack.isEmpty())
252         didCompleteCurrentRecord(m_recordStack.last().type);
253 #endif
254 
<span class="line-modified">255     clearRecordStack();</span>
256 
257     m_tracking = false;
258     m_startedComposite = false;
259     m_autoCapturePhase = AutoCapturePhase::None;
260 
261     m_frontendDispatcher-&gt;recordingStopped(timestamp());
262 
263     if (auto* client = m_inspectedPage.inspectorController().inspectorClient())
264         client-&gt;timelineRecordingChanged(false);
265 }
266 
267 double InspectorTimelineAgent::timestamp()
268 {
269     return m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
270 }
271 
<span class="line-modified">272 void InspectorTimelineAgent::startFromConsole(JSC::ExecState* exec, const String&amp; title)</span>
273 {
274     // Allow duplicate unnamed profiles. Disallow duplicate named profiles.
275     if (!title.isEmpty()) {
276         for (const TimelineRecordEntry&amp; record : m_pendingConsoleProfileRecords) {
277             String recordTitle;
278             record.data-&gt;getString(&quot;title&quot;_s, recordTitle);
279             if (recordTitle == title) {
280                 if (WebConsoleAgent* consoleAgent = m_instrumentingAgents.webConsoleAgent()) {
281                     // FIXME: Send an enum to the frontend for localization?
282                     String warning = title.isEmpty() ? &quot;Unnamed Profile already exists&quot;_s : makeString(&quot;Profile \&quot;&quot;, title, &quot;\&quot; already exists&quot;);
283                     consoleAgent-&gt;addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Profile, MessageLevel::Warning, warning));
284                 }
285                 return;
286             }
287         }
288     }
289 
290     if (!m_tracking &amp;&amp; m_pendingConsoleProfileRecords.isEmpty())
291         startProgrammaticCapture();
292 
293     m_pendingConsoleProfileRecords.append(createRecordEntry(TimelineRecordFactory::createConsoleProfileData(title), TimelineRecordType::ConsoleProfile, true, frameFromExecState(exec)));
294 }
295 
<span class="line-modified">296 void InspectorTimelineAgent::stopFromConsole(JSC::ExecState*, const String&amp; title)</span>
297 {
298     // Stop profiles in reverse order. If the title is empty, then stop the last profile.
299     // Otherwise, match the title of the profile to stop.
300     for (int i = m_pendingConsoleProfileRecords.size() - 1; i &gt;= 0; --i) {
301         const TimelineRecordEntry&amp; record = m_pendingConsoleProfileRecords[i];
302 
303         String recordTitle;
304         record.data-&gt;getString(&quot;title&quot;_s, recordTitle);
305         if (title.isEmpty() || recordTitle == title) {
306             didCompleteRecordEntry(record);
307             m_pendingConsoleProfileRecords.remove(i);
308 
309             if (!m_trackingFromFrontend &amp;&amp; m_pendingConsoleProfileRecords.isEmpty())
310                 stopProgrammaticCapture();
311 
312             return;
313         }
314     }
315 
316     if (WebConsoleAgent* consoleAgent = m_instrumentingAgents.webConsoleAgent()) {
</pre>
<hr />
<pre>
320     }
321 }
322 
323 void InspectorTimelineAgent::willCallFunction(const String&amp; scriptName, int scriptLine, int scriptColumn, Frame* frame)
324 {
325     pushCurrentRecord(TimelineRecordFactory::createFunctionCallData(scriptName, scriptLine, scriptColumn), TimelineRecordType::FunctionCall, true, frame);
326 }
327 
328 void InspectorTimelineAgent::didCallFunction(Frame*)
329 {
330     didCompleteCurrentRecord(TimelineRecordType::FunctionCall);
331 }
332 
333 void InspectorTimelineAgent::willDispatchEvent(const Event&amp; event, Frame* frame)
334 {
335     pushCurrentRecord(TimelineRecordFactory::createEventDispatchData(event), TimelineRecordType::EventDispatch, false, frame);
336 }
337 
338 void InspectorTimelineAgent::didDispatchEvent(bool defaultPrevented)
339 {



340     auto&amp; entry = m_recordStack.last();
341     ASSERT(entry.type == TimelineRecordType::EventDispatch);
342     entry.data-&gt;setBoolean(&quot;defaultPrevented&quot;_s, defaultPrevented);
343 
344     didCompleteCurrentRecord(TimelineRecordType::EventDispatch);
345 }
346 
347 void InspectorTimelineAgent::didInvalidateLayout(Frame&amp; frame)
348 {
349     appendRecord(JSON::Object::create(), TimelineRecordType::InvalidateLayout, true, &amp;frame);
350 }
351 
352 void InspectorTimelineAgent::willLayout(Frame&amp; frame)
353 {
354     pushCurrentRecord(JSON::Object::create(), TimelineRecordType::Layout, true, &amp;frame);
355 }
356 
357 void InspectorTimelineAgent::didLayout(RenderObject&amp; root)
358 {
359     if (m_recordStack.isEmpty())
</pre>
<hr />
<pre>
388 {
389     ASSERT(!m_startedComposite);
390     pushCurrentRecord(JSON::Object::create(), TimelineRecordType::Composite, true, &amp;frame);
391     m_startedComposite = true;
392 }
393 
394 void InspectorTimelineAgent::didComposite()
395 {
396     if (m_startedComposite)
397         didCompleteCurrentRecord(TimelineRecordType::Composite);
398     m_startedComposite = false;
399 }
400 
401 void InspectorTimelineAgent::willPaint(Frame&amp; frame)
402 {
403     pushCurrentRecord(JSON::Object::create(), TimelineRecordType::Paint, true, &amp;frame);
404 }
405 
406 void InspectorTimelineAgent::didPaint(RenderObject&amp; renderer, const LayoutRect&amp; clipRect)
407 {



408     TimelineRecordEntry&amp; entry = m_recordStack.last();
409     ASSERT(entry.type == TimelineRecordType::Paint);
410     FloatQuad quad;
411     localToPageQuad(renderer, clipRect, &amp;quad);
412     entry.data = TimelineRecordFactory::createPaintData(quad);
413     didCompleteCurrentRecord(TimelineRecordType::Paint);
414 }
415 
416 void InspectorTimelineAgent::didInstallTimer(int timerId, Seconds timeout, bool singleShot, Frame* frame)
417 {
418     appendRecord(TimelineRecordFactory::createTimerInstallData(timerId, timeout, singleShot), TimelineRecordType::TimerInstall, true, frame);
419 }
420 
421 void InspectorTimelineAgent::didRemoveTimer(int timerId, Frame* frame)
422 {
423     appendRecord(TimelineRecordFactory::createGenericTimerData(timerId), TimelineRecordType::TimerRemove, true, frame);
424 }
425 
426 void InspectorTimelineAgent::willFireTimer(int timerId, Frame* frame)
427 {
</pre>
<hr />
<pre>
455 
456 void InspectorTimelineAgent::timeEnd(Frame&amp; frame, const String&amp; message)
457 {
458     appendRecord(TimelineRecordFactory::createTimeStampData(message), TimelineRecordType::TimeEnd, true, &amp;frame);
459 }
460 
461 void InspectorTimelineAgent::mainFrameStartedLoading()
462 {
463     if (m_tracking)
464         return;
465 
466     if (!m_autoCaptureEnabled)
467         return;
468 
469     if (m_instruments.isEmpty())
470         return;
471 
472     m_autoCapturePhase = AutoCapturePhase::BeforeLoad;
473 
474     // Pre-emptively disable breakpoints. The frontend must re-enable them.
<span class="line-modified">475     if (InspectorDebuggerAgent* debuggerAgent = m_instrumentingAgents.inspectorDebuggerAgent()) {</span>
476         ErrorString ignored;
<span class="line-modified">477         debuggerAgent-&gt;setBreakpointsActive(ignored, false);</span>
478     }
479 
480     // Inform the frontend we started an auto capture. The frontend must stop capture.
481     m_frontendDispatcher-&gt;autoCaptureStarted();
482 
483     toggleInstruments(InstrumentState::Start);
484 }
485 
486 void InspectorTimelineAgent::mainFrameNavigated()
487 {
488     if (m_autoCapturePhase == AutoCapturePhase::BeforeLoad) {
489         m_autoCapturePhase = AutoCapturePhase::FirstNavigation;
490         toggleInstruments(InstrumentState::Start);
491         m_autoCapturePhase = AutoCapturePhase::AfterFirstNavigation;
492     }
493 }
494 
495 void InspectorTimelineAgent::startProgrammaticCapture()
496 {
497     ASSERT(!m_tracking);
498 
499     // Disable breakpoints during programmatic capture.
<span class="line-modified">500     if (InspectorDebuggerAgent* debuggerAgent = m_instrumentingAgents.inspectorDebuggerAgent()) {</span>
<span class="line-modified">501         m_programmaticCaptureRestoreBreakpointActiveValue = debuggerAgent-&gt;breakpointsActive();</span>
502         if (m_programmaticCaptureRestoreBreakpointActiveValue) {
503             ErrorString ignored;
<span class="line-modified">504             debuggerAgent-&gt;setBreakpointsActive(ignored, false);</span>
505         }
506     } else
507         m_programmaticCaptureRestoreBreakpointActiveValue = false;
508 
509     toggleScriptProfilerInstrument(InstrumentState::Start); // Ensure JavaScript samping data.
510     toggleTimelineInstrument(InstrumentState::Start); // Ensure Console Profile event records.
511     toggleInstruments(InstrumentState::Start); // Any other instruments the frontend wants us to record.
512 }
513 
514 void InspectorTimelineAgent::stopProgrammaticCapture()
515 {
516     ASSERT(m_tracking);
517     ASSERT(!m_trackingFromFrontend);
518 
519     toggleInstruments(InstrumentState::Stop);
520     toggleTimelineInstrument(InstrumentState::Stop);
521     toggleScriptProfilerInstrument(InstrumentState::Stop);
522 
523     // Re-enable breakpoints if they were enabled.
524     if (m_programmaticCaptureRestoreBreakpointActiveValue) {
<span class="line-modified">525         if (InspectorDebuggerAgent* debuggerAgent = m_instrumentingAgents.inspectorDebuggerAgent()) {</span>
526             ErrorString ignored;
<span class="line-modified">527             debuggerAgent-&gt;setBreakpointsActive(ignored, true);</span>
528         }
529     }
530 }
531 
532 void InspectorTimelineAgent::toggleInstruments(InstrumentState state)
533 {
534     for (auto instrumentType : m_instruments) {
535         switch (instrumentType) {
536         case Inspector::Protocol::Timeline::Instrument::ScriptProfiler: {
537             toggleScriptProfilerInstrument(state);
538             break;
539         }
540         case Inspector::Protocol::Timeline::Instrument::Heap: {
541             toggleHeapInstrument(state);
542             break;
543         }
544         case Inspector::Protocol::Timeline::Instrument::CPU: {
545             toggleCPUInstrument(state);
546             break;
547         }
548         case Inspector::Protocol::Timeline::Instrument::Memory: {
549             toggleMemoryInstrument(state);
550             break;
551         }
552         case Inspector::Protocol::Timeline::Instrument::Timeline:
553             toggleTimelineInstrument(state);
554             break;



555         }
556     }
557 }
558 
559 void InspectorTimelineAgent::toggleScriptProfilerInstrument(InstrumentState state)
560 {
561     if (auto* scriptProfilerAgent = m_instrumentingAgents.inspectorScriptProfilerAgent()) {
562         ErrorString ignored;
563         if (state == InstrumentState::Start) {
564             const bool includeSamples = true;
565             scriptProfilerAgent-&gt;startTracking(ignored, &amp;includeSamples);
566         } else
567             scriptProfilerAgent-&gt;stopTracking(ignored);
568     }
569 }
570 
571 void InspectorTimelineAgent::toggleHeapInstrument(InstrumentState state)
572 {
573     if (auto* heapAgent = m_instrumentingAgents.pageHeapAgent()) {
574         ErrorString ignored;
</pre>
<hr />
<pre>
601     if (InspectorMemoryAgent* memoryAgent = m_instrumentingAgents.inspectorMemoryAgent()) {
602         ErrorString ignored;
603         if (state == InstrumentState::Start)
604             memoryAgent-&gt;startTracking(ignored);
605         else
606             memoryAgent-&gt;stopTracking(ignored);
607     }
608 #else
609     UNUSED_PARAM(state);
610 #endif
611 }
612 
613 void InspectorTimelineAgent::toggleTimelineInstrument(InstrumentState state)
614 {
615     if (state == InstrumentState::Start)
616         internalStart();
617     else
618         internalStop();
619 }
620 











621 void InspectorTimelineAgent::didRequestAnimationFrame(int callbackId, Frame* frame)
622 {
623     appendRecord(TimelineRecordFactory::createAnimationFrameData(callbackId), TimelineRecordType::RequestAnimationFrame, true, frame);
624 }
625 
626 void InspectorTimelineAgent::didCancelAnimationFrame(int callbackId, Frame* frame)
627 {
628     appendRecord(TimelineRecordFactory::createAnimationFrameData(callbackId), TimelineRecordType::CancelAnimationFrame, true, frame);
629 }
630 
631 void InspectorTimelineAgent::willFireAnimationFrame(int callbackId, Frame* frame)
632 {
633     pushCurrentRecord(TimelineRecordFactory::createAnimationFrameData(callbackId), TimelineRecordType::FireAnimationFrame, false, frame);
634 }
635 
636 void InspectorTimelineAgent::didFireAnimationFrame()
637 {
638     didCompleteCurrentRecord(TimelineRecordType::FireAnimationFrame);
639 }
640 
641 void InspectorTimelineAgent::willFireObserverCallback(const String&amp; callbackType, Frame* frame)
642 {
643     pushCurrentRecord(TimelineRecordFactory::createObserverCallbackData(callbackType), TimelineRecordType::ObserverCallback, false, frame);
644 }
645 
646 void InspectorTimelineAgent::didFireObserverCallback()
647 {
648     didCompleteCurrentRecord(TimelineRecordType::ObserverCallback);
649 }
650 
651 // ScriptDebugListener
652 
<span class="line-modified">653 void InspectorTimelineAgent::breakpointActionProbe(JSC::ExecState&amp; state, const Inspector::ScriptBreakpointAction&amp; action, unsigned /*batchId*/, unsigned sampleId, JSC::JSValue)</span>
654 {
<span class="line-modified">655     appendRecord(TimelineRecordFactory::createProbeSampleData(action, sampleId), TimelineRecordType::ProbeSample, false, frameFromExecState(&amp;state));</span>
656 }
657 
658 static Inspector::Protocol::Timeline::EventType toProtocol(TimelineRecordType type)
659 {
660     switch (type) {
661     case TimelineRecordType::EventDispatch:
662         return Inspector::Protocol::Timeline::EventType::EventDispatch;
663     case TimelineRecordType::ScheduleStyleRecalculation:
664         return Inspector::Protocol::Timeline::EventType::ScheduleStyleRecalculation;
665     case TimelineRecordType::RecalculateStyles:
666         return Inspector::Protocol::Timeline::EventType::RecalculateStyles;
667     case TimelineRecordType::InvalidateLayout:
668         return Inspector::Protocol::Timeline::EventType::InvalidateLayout;
669     case TimelineRecordType::Layout:
670         return Inspector::Protocol::Timeline::EventType::Layout;
671     case TimelineRecordType::Paint:
672         return Inspector::Protocol::Timeline::EventType::Paint;
673     case TimelineRecordType::Composite:
674         return Inspector::Protocol::Timeline::EventType::Composite;
675     case TimelineRecordType::RenderingFrame:
</pre>
<hr />
<pre>
778 
779 void InspectorTimelineAgent::sendEvent(RefPtr&lt;JSON::Object&gt;&amp;&amp; event)
780 {
781     // FIXME: runtimeCast is a hack. We do it because we can&#39;t build TimelineEvent directly now.
782     auto recordChecked = BindingTraits&lt;Inspector::Protocol::Timeline::TimelineEvent&gt;::runtimeCast(WTFMove(event));
783     m_frontendDispatcher-&gt;eventRecorded(WTFMove(recordChecked));
784 }
785 
786 InspectorTimelineAgent::TimelineRecordEntry InspectorTimelineAgent::createRecordEntry(RefPtr&lt;JSON::Object&gt;&amp;&amp; data, TimelineRecordType type, bool captureCallStack, Frame* frame)
787 {
788     Ref&lt;JSON::Object&gt; record = TimelineRecordFactory::createGenericRecord(timestamp(), captureCallStack ? m_maxCallStackDepth : 0);
789     setFrameIdentifier(&amp;record.get(), frame);
790     return TimelineRecordEntry(WTFMove(record), WTFMove(data), JSON::Array::create(), type);
791 }
792 
793 void InspectorTimelineAgent::pushCurrentRecord(RefPtr&lt;JSON::Object&gt;&amp;&amp; data, TimelineRecordType type, bool captureCallStack, Frame* frame)
794 {
795     pushCurrentRecord(createRecordEntry(WTFMove(data), type, captureCallStack, frame));
796 }
797 
<span class="line-removed">798 void InspectorTimelineAgent::clearRecordStack()</span>
<span class="line-removed">799 {</span>
<span class="line-removed">800     m_recordStack.clear();</span>
<span class="line-removed">801     m_id++;</span>
<span class="line-removed">802 }</span>
<span class="line-removed">803 </span>
804 void InspectorTimelineAgent::localToPageQuad(const RenderObject&amp; renderer, const LayoutRect&amp; rect, FloatQuad* quad)
805 {
806     const FrameView&amp; frameView = renderer.view().frameView();
807     FloatQuad absolute = renderer.localToAbsoluteQuad(FloatQuad(rect));
808     quad-&gt;setP1(frameView.contentsToRootView(roundedIntPoint(absolute.p1())));
809     quad-&gt;setP2(frameView.contentsToRootView(roundedIntPoint(absolute.p2())));
810     quad-&gt;setP3(frameView.contentsToRootView(roundedIntPoint(absolute.p3())));
811     quad-&gt;setP4(frameView.contentsToRootView(roundedIntPoint(absolute.p4())));
812 }
813 
814 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 19 *
 20 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 21 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 22 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 23 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 24 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 25 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 26 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 27 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 28 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 29 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 30 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 31 */
 32 
 33 #include &quot;config.h&quot;
 34 #include &quot;InspectorTimelineAgent.h&quot;
 35 
 36 #include &quot;DOMWindow.h&quot;
 37 #include &quot;Event.h&quot;
 38 #include &quot;Frame.h&quot;
<span class="line-added"> 39 #include &quot;InspectorAnimationAgent.h&quot;</span>
 40 #include &quot;InspectorCPUProfilerAgent.h&quot;
 41 #include &quot;InspectorClient.h&quot;
 42 #include &quot;InspectorController.h&quot;
 43 #include &quot;InspectorMemoryAgent.h&quot;
 44 #include &quot;InspectorPageAgent.h&quot;
 45 #include &quot;InstrumentingAgents.h&quot;
 46 #include &quot;JSDOMWindow.h&quot;
 47 #include &quot;PageHeapAgent.h&quot;
 48 #include &quot;PageScriptDebugServer.h&quot;
 49 #include &quot;RenderView.h&quot;
 50 #include &quot;ScriptState.h&quot;
 51 #include &quot;TimelineRecordFactory.h&quot;
 52 #include &quot;WebConsoleAgent.h&quot;
<span class="line-added"> 53 #include &quot;WebDebuggerAgent.h&quot;</span>
 54 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;

 55 #include &lt;JavaScriptCore/InspectorScriptProfilerAgent.h&gt;
 56 #include &lt;JavaScriptCore/ScriptBreakpoint.h&gt;
 57 #include &lt;wtf/Stopwatch.h&gt;
 58 
 59 #if PLATFORM(IOS_FAMILY)
 60 #include &quot;RuntimeApplicationChecks.h&quot;
 61 #include &quot;WebCoreThreadInternal.h&quot;
 62 #endif
 63 
 64 #if PLATFORM(COCOA)
 65 #include &quot;RunLoopObserver.h&quot;
 66 #endif
 67 
 68 
 69 namespace WebCore {
 70 
 71 using namespace Inspector;
 72 
 73 #if PLATFORM(COCOA)
 74 static CFRunLoopRef currentRunLoop()
</pre>
<hr />
<pre>
236 
237 void InspectorTimelineAgent::internalStop()
238 {
239     if (!m_tracking)
240         return;
241 
242     m_instrumentingAgents.setTrackingInspectorTimelineAgent(nullptr);
243 
244     m_environment.scriptDebugServer().removeListener(this, true);
245 
246 #if PLATFORM(COCOA)
247     m_frameStartObserver = nullptr;
248     m_frameStopObserver = nullptr;
249     m_runLoopNestingLevel = 0;
250 
251     // Complete all pending records to prevent discarding events that are currently in progress.
252     while (!m_recordStack.isEmpty())
253         didCompleteCurrentRecord(m_recordStack.last().type);
254 #endif
255 
<span class="line-modified">256     m_recordStack.clear();</span>
257 
258     m_tracking = false;
259     m_startedComposite = false;
260     m_autoCapturePhase = AutoCapturePhase::None;
261 
262     m_frontendDispatcher-&gt;recordingStopped(timestamp());
263 
264     if (auto* client = m_inspectedPage.inspectorController().inspectorClient())
265         client-&gt;timelineRecordingChanged(false);
266 }
267 
268 double InspectorTimelineAgent::timestamp()
269 {
270     return m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
271 }
272 
<span class="line-modified">273 void InspectorTimelineAgent::startFromConsole(JSC::JSGlobalObject* exec, const String&amp; title)</span>
274 {
275     // Allow duplicate unnamed profiles. Disallow duplicate named profiles.
276     if (!title.isEmpty()) {
277         for (const TimelineRecordEntry&amp; record : m_pendingConsoleProfileRecords) {
278             String recordTitle;
279             record.data-&gt;getString(&quot;title&quot;_s, recordTitle);
280             if (recordTitle == title) {
281                 if (WebConsoleAgent* consoleAgent = m_instrumentingAgents.webConsoleAgent()) {
282                     // FIXME: Send an enum to the frontend for localization?
283                     String warning = title.isEmpty() ? &quot;Unnamed Profile already exists&quot;_s : makeString(&quot;Profile \&quot;&quot;, title, &quot;\&quot; already exists&quot;);
284                     consoleAgent-&gt;addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Profile, MessageLevel::Warning, warning));
285                 }
286                 return;
287             }
288         }
289     }
290 
291     if (!m_tracking &amp;&amp; m_pendingConsoleProfileRecords.isEmpty())
292         startProgrammaticCapture();
293 
294     m_pendingConsoleProfileRecords.append(createRecordEntry(TimelineRecordFactory::createConsoleProfileData(title), TimelineRecordType::ConsoleProfile, true, frameFromExecState(exec)));
295 }
296 
<span class="line-modified">297 void InspectorTimelineAgent::stopFromConsole(JSC::JSGlobalObject*, const String&amp; title)</span>
298 {
299     // Stop profiles in reverse order. If the title is empty, then stop the last profile.
300     // Otherwise, match the title of the profile to stop.
301     for (int i = m_pendingConsoleProfileRecords.size() - 1; i &gt;= 0; --i) {
302         const TimelineRecordEntry&amp; record = m_pendingConsoleProfileRecords[i];
303 
304         String recordTitle;
305         record.data-&gt;getString(&quot;title&quot;_s, recordTitle);
306         if (title.isEmpty() || recordTitle == title) {
307             didCompleteRecordEntry(record);
308             m_pendingConsoleProfileRecords.remove(i);
309 
310             if (!m_trackingFromFrontend &amp;&amp; m_pendingConsoleProfileRecords.isEmpty())
311                 stopProgrammaticCapture();
312 
313             return;
314         }
315     }
316 
317     if (WebConsoleAgent* consoleAgent = m_instrumentingAgents.webConsoleAgent()) {
</pre>
<hr />
<pre>
321     }
322 }
323 
324 void InspectorTimelineAgent::willCallFunction(const String&amp; scriptName, int scriptLine, int scriptColumn, Frame* frame)
325 {
326     pushCurrentRecord(TimelineRecordFactory::createFunctionCallData(scriptName, scriptLine, scriptColumn), TimelineRecordType::FunctionCall, true, frame);
327 }
328 
329 void InspectorTimelineAgent::didCallFunction(Frame*)
330 {
331     didCompleteCurrentRecord(TimelineRecordType::FunctionCall);
332 }
333 
334 void InspectorTimelineAgent::willDispatchEvent(const Event&amp; event, Frame* frame)
335 {
336     pushCurrentRecord(TimelineRecordFactory::createEventDispatchData(event), TimelineRecordType::EventDispatch, false, frame);
337 }
338 
339 void InspectorTimelineAgent::didDispatchEvent(bool defaultPrevented)
340 {
<span class="line-added">341     if (m_recordStack.isEmpty())</span>
<span class="line-added">342         return;</span>
<span class="line-added">343 </span>
344     auto&amp; entry = m_recordStack.last();
345     ASSERT(entry.type == TimelineRecordType::EventDispatch);
346     entry.data-&gt;setBoolean(&quot;defaultPrevented&quot;_s, defaultPrevented);
347 
348     didCompleteCurrentRecord(TimelineRecordType::EventDispatch);
349 }
350 
351 void InspectorTimelineAgent::didInvalidateLayout(Frame&amp; frame)
352 {
353     appendRecord(JSON::Object::create(), TimelineRecordType::InvalidateLayout, true, &amp;frame);
354 }
355 
356 void InspectorTimelineAgent::willLayout(Frame&amp; frame)
357 {
358     pushCurrentRecord(JSON::Object::create(), TimelineRecordType::Layout, true, &amp;frame);
359 }
360 
361 void InspectorTimelineAgent::didLayout(RenderObject&amp; root)
362 {
363     if (m_recordStack.isEmpty())
</pre>
<hr />
<pre>
392 {
393     ASSERT(!m_startedComposite);
394     pushCurrentRecord(JSON::Object::create(), TimelineRecordType::Composite, true, &amp;frame);
395     m_startedComposite = true;
396 }
397 
398 void InspectorTimelineAgent::didComposite()
399 {
400     if (m_startedComposite)
401         didCompleteCurrentRecord(TimelineRecordType::Composite);
402     m_startedComposite = false;
403 }
404 
405 void InspectorTimelineAgent::willPaint(Frame&amp; frame)
406 {
407     pushCurrentRecord(JSON::Object::create(), TimelineRecordType::Paint, true, &amp;frame);
408 }
409 
410 void InspectorTimelineAgent::didPaint(RenderObject&amp; renderer, const LayoutRect&amp; clipRect)
411 {
<span class="line-added">412     if (m_recordStack.isEmpty())</span>
<span class="line-added">413         return;</span>
<span class="line-added">414 </span>
415     TimelineRecordEntry&amp; entry = m_recordStack.last();
416     ASSERT(entry.type == TimelineRecordType::Paint);
417     FloatQuad quad;
418     localToPageQuad(renderer, clipRect, &amp;quad);
419     entry.data = TimelineRecordFactory::createPaintData(quad);
420     didCompleteCurrentRecord(TimelineRecordType::Paint);
421 }
422 
423 void InspectorTimelineAgent::didInstallTimer(int timerId, Seconds timeout, bool singleShot, Frame* frame)
424 {
425     appendRecord(TimelineRecordFactory::createTimerInstallData(timerId, timeout, singleShot), TimelineRecordType::TimerInstall, true, frame);
426 }
427 
428 void InspectorTimelineAgent::didRemoveTimer(int timerId, Frame* frame)
429 {
430     appendRecord(TimelineRecordFactory::createGenericTimerData(timerId), TimelineRecordType::TimerRemove, true, frame);
431 }
432 
433 void InspectorTimelineAgent::willFireTimer(int timerId, Frame* frame)
434 {
</pre>
<hr />
<pre>
462 
463 void InspectorTimelineAgent::timeEnd(Frame&amp; frame, const String&amp; message)
464 {
465     appendRecord(TimelineRecordFactory::createTimeStampData(message), TimelineRecordType::TimeEnd, true, &amp;frame);
466 }
467 
468 void InspectorTimelineAgent::mainFrameStartedLoading()
469 {
470     if (m_tracking)
471         return;
472 
473     if (!m_autoCaptureEnabled)
474         return;
475 
476     if (m_instruments.isEmpty())
477         return;
478 
479     m_autoCapturePhase = AutoCapturePhase::BeforeLoad;
480 
481     // Pre-emptively disable breakpoints. The frontend must re-enable them.
<span class="line-modified">482     if (auto* webDebuggerAgent = m_instrumentingAgents.webDebuggerAgent()) {</span>
483         ErrorString ignored;
<span class="line-modified">484         webDebuggerAgent-&gt;setBreakpointsActive(ignored, false);</span>
485     }
486 
487     // Inform the frontend we started an auto capture. The frontend must stop capture.
488     m_frontendDispatcher-&gt;autoCaptureStarted();
489 
490     toggleInstruments(InstrumentState::Start);
491 }
492 
493 void InspectorTimelineAgent::mainFrameNavigated()
494 {
495     if (m_autoCapturePhase == AutoCapturePhase::BeforeLoad) {
496         m_autoCapturePhase = AutoCapturePhase::FirstNavigation;
497         toggleInstruments(InstrumentState::Start);
498         m_autoCapturePhase = AutoCapturePhase::AfterFirstNavigation;
499     }
500 }
501 
502 void InspectorTimelineAgent::startProgrammaticCapture()
503 {
504     ASSERT(!m_tracking);
505 
506     // Disable breakpoints during programmatic capture.
<span class="line-modified">507     if (auto* webDebuggerAgent = m_instrumentingAgents.webDebuggerAgent()) {</span>
<span class="line-modified">508         m_programmaticCaptureRestoreBreakpointActiveValue = webDebuggerAgent-&gt;breakpointsActive();</span>
509         if (m_programmaticCaptureRestoreBreakpointActiveValue) {
510             ErrorString ignored;
<span class="line-modified">511             webDebuggerAgent-&gt;setBreakpointsActive(ignored, false);</span>
512         }
513     } else
514         m_programmaticCaptureRestoreBreakpointActiveValue = false;
515 
516     toggleScriptProfilerInstrument(InstrumentState::Start); // Ensure JavaScript samping data.
517     toggleTimelineInstrument(InstrumentState::Start); // Ensure Console Profile event records.
518     toggleInstruments(InstrumentState::Start); // Any other instruments the frontend wants us to record.
519 }
520 
521 void InspectorTimelineAgent::stopProgrammaticCapture()
522 {
523     ASSERT(m_tracking);
524     ASSERT(!m_trackingFromFrontend);
525 
526     toggleInstruments(InstrumentState::Stop);
527     toggleTimelineInstrument(InstrumentState::Stop);
528     toggleScriptProfilerInstrument(InstrumentState::Stop);
529 
530     // Re-enable breakpoints if they were enabled.
531     if (m_programmaticCaptureRestoreBreakpointActiveValue) {
<span class="line-modified">532         if (auto* webDebuggerAgent = m_instrumentingAgents.webDebuggerAgent()) {</span>
533             ErrorString ignored;
<span class="line-modified">534             webDebuggerAgent-&gt;setBreakpointsActive(ignored, true);</span>
535         }
536     }
537 }
538 
539 void InspectorTimelineAgent::toggleInstruments(InstrumentState state)
540 {
541     for (auto instrumentType : m_instruments) {
542         switch (instrumentType) {
543         case Inspector::Protocol::Timeline::Instrument::ScriptProfiler: {
544             toggleScriptProfilerInstrument(state);
545             break;
546         }
547         case Inspector::Protocol::Timeline::Instrument::Heap: {
548             toggleHeapInstrument(state);
549             break;
550         }
551         case Inspector::Protocol::Timeline::Instrument::CPU: {
552             toggleCPUInstrument(state);
553             break;
554         }
555         case Inspector::Protocol::Timeline::Instrument::Memory: {
556             toggleMemoryInstrument(state);
557             break;
558         }
559         case Inspector::Protocol::Timeline::Instrument::Timeline:
560             toggleTimelineInstrument(state);
561             break;
<span class="line-added">562         case Inspector::Protocol::Timeline::Instrument::Animation:</span>
<span class="line-added">563             toggleAnimationInstrument(state);</span>
<span class="line-added">564             break;</span>
565         }
566     }
567 }
568 
569 void InspectorTimelineAgent::toggleScriptProfilerInstrument(InstrumentState state)
570 {
571     if (auto* scriptProfilerAgent = m_instrumentingAgents.inspectorScriptProfilerAgent()) {
572         ErrorString ignored;
573         if (state == InstrumentState::Start) {
574             const bool includeSamples = true;
575             scriptProfilerAgent-&gt;startTracking(ignored, &amp;includeSamples);
576         } else
577             scriptProfilerAgent-&gt;stopTracking(ignored);
578     }
579 }
580 
581 void InspectorTimelineAgent::toggleHeapInstrument(InstrumentState state)
582 {
583     if (auto* heapAgent = m_instrumentingAgents.pageHeapAgent()) {
584         ErrorString ignored;
</pre>
<hr />
<pre>
611     if (InspectorMemoryAgent* memoryAgent = m_instrumentingAgents.inspectorMemoryAgent()) {
612         ErrorString ignored;
613         if (state == InstrumentState::Start)
614             memoryAgent-&gt;startTracking(ignored);
615         else
616             memoryAgent-&gt;stopTracking(ignored);
617     }
618 #else
619     UNUSED_PARAM(state);
620 #endif
621 }
622 
623 void InspectorTimelineAgent::toggleTimelineInstrument(InstrumentState state)
624 {
625     if (state == InstrumentState::Start)
626         internalStart();
627     else
628         internalStop();
629 }
630 
<span class="line-added">631 void InspectorTimelineAgent::toggleAnimationInstrument(InstrumentState state)</span>
<span class="line-added">632 {</span>
<span class="line-added">633     if (auto* animationAgent = m_instrumentingAgents.persistentInspectorAnimationAgent()) {</span>
<span class="line-added">634         ErrorString ignored;</span>
<span class="line-added">635         if (state == InstrumentState::Start)</span>
<span class="line-added">636             animationAgent-&gt;startTracking(ignored);</span>
<span class="line-added">637         else</span>
<span class="line-added">638             animationAgent-&gt;stopTracking(ignored);</span>
<span class="line-added">639     }</span>
<span class="line-added">640 }</span>
<span class="line-added">641 </span>
642 void InspectorTimelineAgent::didRequestAnimationFrame(int callbackId, Frame* frame)
643 {
644     appendRecord(TimelineRecordFactory::createAnimationFrameData(callbackId), TimelineRecordType::RequestAnimationFrame, true, frame);
645 }
646 
647 void InspectorTimelineAgent::didCancelAnimationFrame(int callbackId, Frame* frame)
648 {
649     appendRecord(TimelineRecordFactory::createAnimationFrameData(callbackId), TimelineRecordType::CancelAnimationFrame, true, frame);
650 }
651 
652 void InspectorTimelineAgent::willFireAnimationFrame(int callbackId, Frame* frame)
653 {
654     pushCurrentRecord(TimelineRecordFactory::createAnimationFrameData(callbackId), TimelineRecordType::FireAnimationFrame, false, frame);
655 }
656 
657 void InspectorTimelineAgent::didFireAnimationFrame()
658 {
659     didCompleteCurrentRecord(TimelineRecordType::FireAnimationFrame);
660 }
661 
662 void InspectorTimelineAgent::willFireObserverCallback(const String&amp; callbackType, Frame* frame)
663 {
664     pushCurrentRecord(TimelineRecordFactory::createObserverCallbackData(callbackType), TimelineRecordType::ObserverCallback, false, frame);
665 }
666 
667 void InspectorTimelineAgent::didFireObserverCallback()
668 {
669     didCompleteCurrentRecord(TimelineRecordType::ObserverCallback);
670 }
671 
672 // ScriptDebugListener
673 
<span class="line-modified">674 void InspectorTimelineAgent::breakpointActionProbe(JSC::JSGlobalObject* lexicalGlobalObject, const Inspector::ScriptBreakpointAction&amp; action, unsigned /*batchId*/, unsigned sampleId, JSC::JSValue)</span>
675 {
<span class="line-modified">676     appendRecord(TimelineRecordFactory::createProbeSampleData(action, sampleId), TimelineRecordType::ProbeSample, false, frameFromExecState(lexicalGlobalObject));</span>
677 }
678 
679 static Inspector::Protocol::Timeline::EventType toProtocol(TimelineRecordType type)
680 {
681     switch (type) {
682     case TimelineRecordType::EventDispatch:
683         return Inspector::Protocol::Timeline::EventType::EventDispatch;
684     case TimelineRecordType::ScheduleStyleRecalculation:
685         return Inspector::Protocol::Timeline::EventType::ScheduleStyleRecalculation;
686     case TimelineRecordType::RecalculateStyles:
687         return Inspector::Protocol::Timeline::EventType::RecalculateStyles;
688     case TimelineRecordType::InvalidateLayout:
689         return Inspector::Protocol::Timeline::EventType::InvalidateLayout;
690     case TimelineRecordType::Layout:
691         return Inspector::Protocol::Timeline::EventType::Layout;
692     case TimelineRecordType::Paint:
693         return Inspector::Protocol::Timeline::EventType::Paint;
694     case TimelineRecordType::Composite:
695         return Inspector::Protocol::Timeline::EventType::Composite;
696     case TimelineRecordType::RenderingFrame:
</pre>
<hr />
<pre>
799 
800 void InspectorTimelineAgent::sendEvent(RefPtr&lt;JSON::Object&gt;&amp;&amp; event)
801 {
802     // FIXME: runtimeCast is a hack. We do it because we can&#39;t build TimelineEvent directly now.
803     auto recordChecked = BindingTraits&lt;Inspector::Protocol::Timeline::TimelineEvent&gt;::runtimeCast(WTFMove(event));
804     m_frontendDispatcher-&gt;eventRecorded(WTFMove(recordChecked));
805 }
806 
807 InspectorTimelineAgent::TimelineRecordEntry InspectorTimelineAgent::createRecordEntry(RefPtr&lt;JSON::Object&gt;&amp;&amp; data, TimelineRecordType type, bool captureCallStack, Frame* frame)
808 {
809     Ref&lt;JSON::Object&gt; record = TimelineRecordFactory::createGenericRecord(timestamp(), captureCallStack ? m_maxCallStackDepth : 0);
810     setFrameIdentifier(&amp;record.get(), frame);
811     return TimelineRecordEntry(WTFMove(record), WTFMove(data), JSON::Array::create(), type);
812 }
813 
814 void InspectorTimelineAgent::pushCurrentRecord(RefPtr&lt;JSON::Object&gt;&amp;&amp; data, TimelineRecordType type, bool captureCallStack, Frame* frame)
815 {
816     pushCurrentRecord(createRecordEntry(WTFMove(data), type, captureCallStack, frame));
817 }
818 






819 void InspectorTimelineAgent::localToPageQuad(const RenderObject&amp; renderer, const LayoutRect&amp; rect, FloatQuad* quad)
820 {
821     const FrameView&amp; frameView = renderer.view().frameView();
822     FloatQuad absolute = renderer.localToAbsoluteQuad(FloatQuad(rect));
823     quad-&gt;setP1(frameView.contentsToRootView(roundedIntPoint(absolute.p1())));
824     quad-&gt;setP2(frameView.contentsToRootView(roundedIntPoint(absolute.p2())));
825     quad-&gt;setP3(frameView.contentsToRootView(roundedIntPoint(absolute.p3())));
826     quad-&gt;setP4(frameView.contentsToRootView(roundedIntPoint(absolute.p4())));
827 }
828 
829 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="InspectorPageAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorTimelineAgent.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
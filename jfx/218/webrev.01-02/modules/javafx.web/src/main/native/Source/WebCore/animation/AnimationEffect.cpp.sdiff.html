<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/animation/AnimationEffect.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Animatable.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AnimationEffect.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/animation/AnimationEffect.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 47     timing.delay = secondsToWebAnimationsAPITime(m_delay);
 48     timing.endDelay = secondsToWebAnimationsAPITime(m_endDelay);
 49     timing.fill = m_fill;
 50     timing.iterationStart = m_iterationStart;
 51     timing.iterations = m_iterations;
 52     if (m_iterationDuration == 0_s)
 53         timing.duration = &quot;auto&quot;;
 54     else
 55         timing.duration = secondsToWebAnimationsAPITime(m_iterationDuration);
 56     timing.direction = m_direction;
 57     timing.easing = m_timingFunction-&gt;cssText();
 58     return timing;
 59 }
 60 
 61 BasicEffectTiming AnimationEffect::getBasicTiming() const
 62 {
 63     // The Web Animations spec introduces a number of animation effect time-related definitions that refer
 64     // to each other a fair bit, so rather than implementing them as individual methods, it&#39;s more efficient
 65     // to return them all as a single BasicEffectTiming.
 66 
<span class="line-removed"> 67     auto activeDuration = [this]() -&gt; Seconds {</span>
<span class="line-removed"> 68         // 3.8.2. Calculating the active duration</span>
<span class="line-removed"> 69         // https://drafts.csswg.org/web-animations-1/#calculating-the-active-duration</span>
<span class="line-removed"> 70 </span>
<span class="line-removed"> 71         // The active duration is calculated as follows:</span>
<span class="line-removed"> 72         // active duration = iteration duration × iteration count</span>
<span class="line-removed"> 73         // If either the iteration duration or iteration count are zero, the active duration is zero.</span>
<span class="line-removed"> 74         if (!m_iterationDuration || !m_iterations)</span>
<span class="line-removed"> 75             return 0_s;</span>
<span class="line-removed"> 76         return m_iterationDuration * m_iterations;</span>
<span class="line-removed"> 77     }();</span>
<span class="line-removed"> 78 </span>
<span class="line-removed"> 79     auto endTime = [this, activeDuration]() -&gt; Seconds {</span>
<span class="line-removed"> 80         // 3.5.3 The active interval</span>
<span class="line-removed"> 81         // https://drafts.csswg.org/web-animations-1/#end-time</span>
<span class="line-removed"> 82 </span>
<span class="line-removed"> 83         // The end time of an animation effect is the result of evaluating max(start delay + active duration + end delay, 0).</span>
<span class="line-removed"> 84         auto endTime = m_delay + activeDuration + m_endDelay;</span>
<span class="line-removed"> 85         return endTime &gt; 0_s ? endTime : 0_s;</span>
<span class="line-removed"> 86     }();</span>
<span class="line-removed"> 87 </span>
 88     auto localTime = [this]() -&gt; Optional&lt;Seconds&gt; {
 89         // 4.5.4. Local time
 90         // https://drafts.csswg.org/web-animations-1/#local-time-section
 91 
 92         // The local time of an animation effect at a given moment is based on the first matching condition from the following:
 93         // If the animation effect is associated with an animation, the local time is the current time of the animation.
 94         // Otherwise, the local time is unresolved.
 95         if (m_animation)
 96             return m_animation-&gt;currentTime();
 97         return WTF::nullopt;
 98     }();
 99 
<span class="line-modified">100     auto phase = [this, endTime, localTime, activeDuration]() -&gt; AnimationEffectPhase {</span>
101         // 3.5.5. Animation effect phases and states
102         // https://drafts.csswg.org/web-animations-1/#animation-effect-phases-and-states
103 
104         bool animationIsBackwards = m_animation &amp;&amp; m_animation-&gt;playbackRate() &lt; 0;
<span class="line-modified">105         auto beforeActiveBoundaryTime = std::max(std::min(m_delay, endTime), 0_s);</span>
<span class="line-modified">106         auto activeAfterBoundaryTime = std::max(std::min(m_delay + activeDuration, endTime), 0_s);</span>
107 
108         // (This should be the last statement, but it&#39;s more efficient to cache the local time and return right away if it&#39;s not resolved.)
109         // Furthermore, it is often convenient to refer to the case when an animation effect is in none of the above phases
110         // as being in the idle phase.
111         if (!localTime)
112             return AnimationEffectPhase::Idle;
113 
114         // An animation effect is in the before phase if the animation effect’s local time is not unresolved and
115         // either of the following conditions are met:
116         //     1. the local time is less than the before-active boundary time, or
117         //     2. the animation direction is ‘backwards’ and the local time is equal to the before-active boundary time.
118         if ((*localTime + timeEpsilon) &lt; beforeActiveBoundaryTime || (animationIsBackwards &amp;&amp; std::abs(localTime-&gt;microseconds() - beforeActiveBoundaryTime.microseconds()) &lt; timeEpsilon.microseconds()))
119             return AnimationEffectPhase::Before;
120 
121         // An animation effect is in the after phase if the animation effect’s local time is not unresolved and
122         // either of the following conditions are met:
123         //     1. the local time is greater than the active-after boundary time, or
124         //     2. the animation direction is ‘forwards’ and the local time is equal to the active-after boundary time.
125         if ((*localTime - timeEpsilon) &gt; activeAfterBoundaryTime || (!animationIsBackwards &amp;&amp; std::abs(localTime-&gt;microseconds() - activeAfterBoundaryTime.microseconds()) &lt; timeEpsilon.microseconds()))
126             return AnimationEffectPhase::After;
127 
128         // An animation effect is in the active phase if the animation effect’s local time is not unresolved and it is not
129         // in either the before phase nor the after phase.
130         // (No need to check, we&#39;ve already established that local time was resolved).
131         return AnimationEffectPhase::Active;
132     }();
133 
<span class="line-modified">134     auto activeTime = [this, localTime, phase, activeDuration]() -&gt; Optional&lt;Seconds&gt; {</span>
135         // 3.8.3.1. Calculating the active time
136         // https://drafts.csswg.org/web-animations-1/#calculating-the-active-time
137 
138         // The active time is based on the local time and start delay. However, it is only defined
139         // when the animation effect should produce an output and hence depends on its fill mode
140         // and phase as follows,
141 
142         // If the animation effect is in the before phase, the result depends on the first matching
143         // condition from the following,
144         if (phase == AnimationEffectPhase::Before) {
145             // If the fill mode is backwards or both, return the result of evaluating
146             // max(local time - start delay, 0).
147             if (m_fill == FillMode::Backwards || m_fill == FillMode::Both)
148                 return std::max(*localTime - m_delay, 0_s);
149             // Otherwise, return an unresolved time value.
150             return WTF::nullopt;
151         }
152 
153         // If the animation effect is in the active phase, return the result of evaluating local time - start delay.
154         if (phase == AnimationEffectPhase::Active)
155             return *localTime - m_delay;
156 
157         // If the animation effect is in the after phase, the result depends on the first matching
158         // condition from the following,
159         if (phase == AnimationEffectPhase::After) {
160             // If the fill mode is forwards or both, return the result of evaluating
161             // max(min(local time - start delay, active duration), 0).
162             if (m_fill == FillMode::Forwards || m_fill == FillMode::Both)
<span class="line-modified">163                 return std::max(std::min(*localTime - m_delay, activeDuration), 0_s);</span>
164             // Otherwise, return an unresolved time value.
165             return WTF::nullopt;
166         }
167 
168         // Otherwise (the local time is unresolved), return an unresolved time value.
169         return WTF::nullopt;
170     }();
171 
<span class="line-modified">172     return { localTime, activeTime, endTime, activeDuration, phase };</span>
173 }
174 
175 ComputedEffectTiming AnimationEffect::getComputedTiming() const
176 {
177     // The Web Animations spec introduces a number of animation effect time-related definitions that refer
178     // to each other a fair bit, so rather than implementing them as individual methods, it&#39;s more efficient
179     // to return them all as a single ComputedEffectTiming.
180 
181     auto basicEffectTiming = getBasicTiming();
182     auto activeTime = basicEffectTiming.activeTime;
<span class="line-removed">183     auto activeDuration = basicEffectTiming.activeDuration;</span>
184     auto phase = basicEffectTiming.phase;
185 
186     auto overallProgress = [this, phase, activeTime]() -&gt; Optional&lt;double&gt; {
187         // 3.8.3.2. Calculating the overall progress
188         // https://drafts.csswg.org/web-animations-1/#calculating-the-overall-progress
189 
190         // The overall progress describes the number of iterations that have completed (including partial iterations) and is defined as follows:
191 
192         // 1. If the active time is unresolved, return unresolved.
193         if (!activeTime)
194             return WTF::nullopt;
195 
196         // 2. Calculate an initial value for overall progress based on the first matching condition from below,
197         double overallProgress;
198 
199         if (!m_iterationDuration) {
200             // If the iteration duration is zero, if the animation effect is in the before phase, let overall progress be zero,
201             // otherwise, let it be equal to the iteration count.
202             overallProgress = phase == AnimationEffectPhase::Before ? 0 : m_iterations;
203         } else {
204             // Otherwise, let overall progress be the result of calculating active time / iteration duration.
205             overallProgress = secondsToWebAnimationsAPITime(*activeTime) / secondsToWebAnimationsAPITime(m_iterationDuration);
206         }
207 
208         // 3. Return the result of calculating overall progress + iteration start.
209         overallProgress += m_iterationStart;
210         return std::abs(overallProgress);
211     }();
212 
<span class="line-modified">213     auto simpleIterationProgress = [this, overallProgress, phase, activeTime, activeDuration]() -&gt; Optional&lt;double&gt; {</span>
214         // 3.8.3.3. Calculating the simple iteration progress
215         // https://drafts.csswg.org/web-animations-1/#calculating-the-simple-iteration-progress
216 
217         // The simple iteration progress is a fraction of the progress through the current iteration that
218         // ignores transformations to the time introduced by the playback direction or timing functions
219         // applied to the effect, and is calculated as follows:
220 
221         // 1. If the overall progress is unresolved, return unresolved.
222         if (!overallProgress)
223             return WTF::nullopt;
224 
225         // 2. If overall progress is infinity, let the simple iteration progress be iteration start % 1.0,
226         // otherwise, let the simple iteration progress be overall progress % 1.0.
227         double simpleIterationProgress = std::isinf(*overallProgress) ? fmod(m_iterationStart, 1) : fmod(*overallProgress, 1);
228 
229         // 3. If all of the following conditions are true,
230         //
231         // the simple iteration progress calculated above is zero, and
232         // the animation effect is in the active phase or the after phase, and
233         // the active time is equal to the active duration, and
234         // the iteration count is not equal to zero.
235         // let the simple iteration progress be 1.0.
<span class="line-modified">236         if (!simpleIterationProgress &amp;&amp; (phase == AnimationEffectPhase::Active || phase == AnimationEffectPhase::After) &amp;&amp; std::abs(activeTime-&gt;microseconds() - activeDuration.microseconds()) &lt; timeEpsilon.microseconds() &amp;&amp; m_iterations)</span>
237             return 1;
238 
239         return simpleIterationProgress;
240     }();
241 
242     auto currentIteration = [this, activeTime, phase, simpleIterationProgress, overallProgress]() -&gt; Optional&lt;double&gt; {
243         // 3.8.4. Calculating the current iteration
244         // https://drafts.csswg.org/web-animations-1/#calculating-the-current-iteration
245 
246         // The current iteration can be calculated using the following steps:
247 
248         // 1. If the active time is unresolved, return unresolved.
249         if (!activeTime)
250             return WTF::nullopt;
251 
252         // 2. If the animation effect is in the after phase and the iteration count is infinity, return infinity.
253         if (phase == AnimationEffectPhase::After &amp;&amp; std::isinf(m_iterations))
254             return std::numeric_limits&lt;double&gt;::infinity();
255 
256         // 3. If the simple iteration progress is 1.0, return floor(overall progress) - 1.
</pre>
<hr />
<pre>
330                 before = (phase == AnimationEffectPhase::Before &amp;&amp; goingForwards) || (phase == AnimationEffectPhase::After &amp;&amp; !goingForwards);
331             }
332 
333             // 3. Return the result of evaluating the animation effect’s timing function passing directed progress as the
334             //    input progress value and before flag as the before flag.
335             return m_timingFunction-&gt;transformTime(*directedProgress, iterationDuration, before);
336         }
337 
338         return *directedProgress;
339     }();
340 
341     ComputedEffectTiming computedTiming;
342     computedTiming.delay = secondsToWebAnimationsAPITime(m_delay);
343     computedTiming.endDelay = secondsToWebAnimationsAPITime(m_endDelay);
344     computedTiming.fill = m_fill == FillMode::Auto ? FillMode::None : m_fill;
345     computedTiming.iterationStart = m_iterationStart;
346     computedTiming.iterations = m_iterations;
347     computedTiming.duration = secondsToWebAnimationsAPITime(m_iterationDuration);
348     computedTiming.direction = m_direction;
349     computedTiming.easing = m_timingFunction-&gt;cssText();
<span class="line-modified">350     computedTiming.endTime = secondsToWebAnimationsAPITime(basicEffectTiming.endTime);</span>
<span class="line-modified">351     computedTiming.activeDuration = secondsToWebAnimationsAPITime(activeDuration);</span>
352     if (basicEffectTiming.localTime)
353         computedTiming.localTime = secondsToWebAnimationsAPITime(*basicEffectTiming.localTime);
354     computedTiming.simpleIterationProgress = simpleIterationProgress;
355     computedTiming.progress = transformedProgress;
356     computedTiming.currentIteration = currentIteration;
357     computedTiming.phase = phase;
358     return computedTiming;
359 }
360 
361 ExceptionOr&lt;void&gt; AnimationEffect::updateTiming(Optional&lt;OptionalEffectTiming&gt; timing)
362 {
363     // 6.5.4. Updating the timing of an AnimationEffect
364     // https://drafts.csswg.org/web-animations/#updating-animationeffect-timing
365 
366     // To update the timing properties of an animation effect, effect, from an EffectTiming or OptionalEffectTiming object, input, perform the following steps:
367     if (!timing)
368         return { };
369 




370     // 1. If the iterationStart member of input is present and less than zero, throw a TypeError and abort this procedure.
371     if (timing-&gt;iterationStart) {
372         if (timing-&gt;iterationStart.value() &lt; 0)
373             return Exception { TypeError };
374     }
375 
376     // 2. If the iterations member of input is present, and less than zero or is the value NaN, throw a TypeError and abort this procedure.
377     if (timing-&gt;iterations) {
378         if (timing-&gt;iterations.value() &lt; 0 || std::isnan(timing-&gt;iterations.value()))
379             return Exception { TypeError };
380     }
381 
382     // 3. If the duration member of input is present, and less than zero or is the value NaN, throw a TypeError and abort this procedure.
383     // FIXME: should it not throw an exception on a string other than &quot;auto&quot;?
384     if (timing-&gt;duration) {
385         if (WTF::holds_alternative&lt;double&gt;(timing-&gt;duration.value())) {
386             auto durationAsDouble = WTF::get&lt;double&gt;(timing-&gt;duration.value());
387             if (durationAsDouble &lt; 0 || std::isnan(durationAsDouble))
388                 return Exception { TypeError };
389         } else {
</pre>
<hr />
<pre>
415         m_delay = Seconds::fromMilliseconds(timing-&gt;delay.value());
416 
417     if (timing-&gt;endDelay)
418         m_endDelay = Seconds::fromMilliseconds(timing-&gt;endDelay.value());
419 
420     if (timing-&gt;fill)
421         m_fill = timing-&gt;fill.value();
422 
423     if (timing-&gt;iterationStart)
424         m_iterationStart = timing-&gt;iterationStart.value();
425 
426     if (timing-&gt;iterations)
427         m_iterations = timing-&gt;iterations.value();
428 
429     if (timing-&gt;duration)
430         m_iterationDuration = WTF::holds_alternative&lt;double&gt;(timing-&gt;duration.value()) ? Seconds::fromMilliseconds(WTF::get&lt;double&gt;(timing-&gt;duration.value())) : 0_s;
431 
432     if (timing-&gt;direction)
433         m_direction = timing-&gt;direction.value();
434 


435     if (m_animation)
<span class="line-modified">436         m_animation-&gt;effectTimingDidChange();</span>
437 
438     return { };
439 }
440 






















441 ExceptionOr&lt;void&gt; AnimationEffect::setIterationStart(double iterationStart)
442 {
443     // https://drafts.csswg.org/web-animations-1/#dom-animationeffecttiming-iterationstart
444     // If an attempt is made to set this attribute to a value less than zero, a TypeError must
445     // be thrown and the value of the iterationStart attribute left unchanged.
446     if (iterationStart &lt; 0)
447         return Exception { TypeError };
448 
449     if (m_iterationStart == iterationStart)
450         return { };
451 
452     m_iterationStart = iterationStart;
453 
454     return { };
455 }
456 
457 ExceptionOr&lt;void&gt; AnimationEffect::setIterations(double iterations)
458 {
459     // https://drafts.csswg.org/web-animations-1/#dom-animationeffecttiming-iterations
460     // If an attempt is made to set this attribute to a value less than zero or a NaN value, a
</pre>
</td>
<td>
<hr />
<pre>
 47     timing.delay = secondsToWebAnimationsAPITime(m_delay);
 48     timing.endDelay = secondsToWebAnimationsAPITime(m_endDelay);
 49     timing.fill = m_fill;
 50     timing.iterationStart = m_iterationStart;
 51     timing.iterations = m_iterations;
 52     if (m_iterationDuration == 0_s)
 53         timing.duration = &quot;auto&quot;;
 54     else
 55         timing.duration = secondsToWebAnimationsAPITime(m_iterationDuration);
 56     timing.direction = m_direction;
 57     timing.easing = m_timingFunction-&gt;cssText();
 58     return timing;
 59 }
 60 
 61 BasicEffectTiming AnimationEffect::getBasicTiming() const
 62 {
 63     // The Web Animations spec introduces a number of animation effect time-related definitions that refer
 64     // to each other a fair bit, so rather than implementing them as individual methods, it&#39;s more efficient
 65     // to return them all as a single BasicEffectTiming.
 66 





















 67     auto localTime = [this]() -&gt; Optional&lt;Seconds&gt; {
 68         // 4.5.4. Local time
 69         // https://drafts.csswg.org/web-animations-1/#local-time-section
 70 
 71         // The local time of an animation effect at a given moment is based on the first matching condition from the following:
 72         // If the animation effect is associated with an animation, the local time is the current time of the animation.
 73         // Otherwise, the local time is unresolved.
 74         if (m_animation)
 75             return m_animation-&gt;currentTime();
 76         return WTF::nullopt;
 77     }();
 78 
<span class="line-modified"> 79     auto phase = [this, localTime]() -&gt; AnimationEffectPhase {</span>
 80         // 3.5.5. Animation effect phases and states
 81         // https://drafts.csswg.org/web-animations-1/#animation-effect-phases-and-states
 82 
 83         bool animationIsBackwards = m_animation &amp;&amp; m_animation-&gt;playbackRate() &lt; 0;
<span class="line-modified"> 84         auto beforeActiveBoundaryTime = std::max(std::min(m_delay, m_endTime), 0_s);</span>
<span class="line-modified"> 85         auto activeAfterBoundaryTime = std::max(std::min(m_delay + m_activeDuration, m_endTime), 0_s);</span>
 86 
 87         // (This should be the last statement, but it&#39;s more efficient to cache the local time and return right away if it&#39;s not resolved.)
 88         // Furthermore, it is often convenient to refer to the case when an animation effect is in none of the above phases
 89         // as being in the idle phase.
 90         if (!localTime)
 91             return AnimationEffectPhase::Idle;
 92 
 93         // An animation effect is in the before phase if the animation effect’s local time is not unresolved and
 94         // either of the following conditions are met:
 95         //     1. the local time is less than the before-active boundary time, or
 96         //     2. the animation direction is ‘backwards’ and the local time is equal to the before-active boundary time.
 97         if ((*localTime + timeEpsilon) &lt; beforeActiveBoundaryTime || (animationIsBackwards &amp;&amp; std::abs(localTime-&gt;microseconds() - beforeActiveBoundaryTime.microseconds()) &lt; timeEpsilon.microseconds()))
 98             return AnimationEffectPhase::Before;
 99 
100         // An animation effect is in the after phase if the animation effect’s local time is not unresolved and
101         // either of the following conditions are met:
102         //     1. the local time is greater than the active-after boundary time, or
103         //     2. the animation direction is ‘forwards’ and the local time is equal to the active-after boundary time.
104         if ((*localTime - timeEpsilon) &gt; activeAfterBoundaryTime || (!animationIsBackwards &amp;&amp; std::abs(localTime-&gt;microseconds() - activeAfterBoundaryTime.microseconds()) &lt; timeEpsilon.microseconds()))
105             return AnimationEffectPhase::After;
106 
107         // An animation effect is in the active phase if the animation effect’s local time is not unresolved and it is not
108         // in either the before phase nor the after phase.
109         // (No need to check, we&#39;ve already established that local time was resolved).
110         return AnimationEffectPhase::Active;
111     }();
112 
<span class="line-modified">113     auto activeTime = [this, localTime, phase]() -&gt; Optional&lt;Seconds&gt; {</span>
114         // 3.8.3.1. Calculating the active time
115         // https://drafts.csswg.org/web-animations-1/#calculating-the-active-time
116 
117         // The active time is based on the local time and start delay. However, it is only defined
118         // when the animation effect should produce an output and hence depends on its fill mode
119         // and phase as follows,
120 
121         // If the animation effect is in the before phase, the result depends on the first matching
122         // condition from the following,
123         if (phase == AnimationEffectPhase::Before) {
124             // If the fill mode is backwards or both, return the result of evaluating
125             // max(local time - start delay, 0).
126             if (m_fill == FillMode::Backwards || m_fill == FillMode::Both)
127                 return std::max(*localTime - m_delay, 0_s);
128             // Otherwise, return an unresolved time value.
129             return WTF::nullopt;
130         }
131 
132         // If the animation effect is in the active phase, return the result of evaluating local time - start delay.
133         if (phase == AnimationEffectPhase::Active)
134             return *localTime - m_delay;
135 
136         // If the animation effect is in the after phase, the result depends on the first matching
137         // condition from the following,
138         if (phase == AnimationEffectPhase::After) {
139             // If the fill mode is forwards or both, return the result of evaluating
140             // max(min(local time - start delay, active duration), 0).
141             if (m_fill == FillMode::Forwards || m_fill == FillMode::Both)
<span class="line-modified">142                 return std::max(std::min(*localTime - m_delay, m_activeDuration), 0_s);</span>
143             // Otherwise, return an unresolved time value.
144             return WTF::nullopt;
145         }
146 
147         // Otherwise (the local time is unresolved), return an unresolved time value.
148         return WTF::nullopt;
149     }();
150 
<span class="line-modified">151     return { localTime, activeTime, m_endTime, m_activeDuration, phase };</span>
152 }
153 
154 ComputedEffectTiming AnimationEffect::getComputedTiming() const
155 {
156     // The Web Animations spec introduces a number of animation effect time-related definitions that refer
157     // to each other a fair bit, so rather than implementing them as individual methods, it&#39;s more efficient
158     // to return them all as a single ComputedEffectTiming.
159 
160     auto basicEffectTiming = getBasicTiming();
161     auto activeTime = basicEffectTiming.activeTime;

162     auto phase = basicEffectTiming.phase;
163 
164     auto overallProgress = [this, phase, activeTime]() -&gt; Optional&lt;double&gt; {
165         // 3.8.3.2. Calculating the overall progress
166         // https://drafts.csswg.org/web-animations-1/#calculating-the-overall-progress
167 
168         // The overall progress describes the number of iterations that have completed (including partial iterations) and is defined as follows:
169 
170         // 1. If the active time is unresolved, return unresolved.
171         if (!activeTime)
172             return WTF::nullopt;
173 
174         // 2. Calculate an initial value for overall progress based on the first matching condition from below,
175         double overallProgress;
176 
177         if (!m_iterationDuration) {
178             // If the iteration duration is zero, if the animation effect is in the before phase, let overall progress be zero,
179             // otherwise, let it be equal to the iteration count.
180             overallProgress = phase == AnimationEffectPhase::Before ? 0 : m_iterations;
181         } else {
182             // Otherwise, let overall progress be the result of calculating active time / iteration duration.
183             overallProgress = secondsToWebAnimationsAPITime(*activeTime) / secondsToWebAnimationsAPITime(m_iterationDuration);
184         }
185 
186         // 3. Return the result of calculating overall progress + iteration start.
187         overallProgress += m_iterationStart;
188         return std::abs(overallProgress);
189     }();
190 
<span class="line-modified">191     auto simpleIterationProgress = [this, overallProgress, phase, activeTime]() -&gt; Optional&lt;double&gt; {</span>
192         // 3.8.3.3. Calculating the simple iteration progress
193         // https://drafts.csswg.org/web-animations-1/#calculating-the-simple-iteration-progress
194 
195         // The simple iteration progress is a fraction of the progress through the current iteration that
196         // ignores transformations to the time introduced by the playback direction or timing functions
197         // applied to the effect, and is calculated as follows:
198 
199         // 1. If the overall progress is unresolved, return unresolved.
200         if (!overallProgress)
201             return WTF::nullopt;
202 
203         // 2. If overall progress is infinity, let the simple iteration progress be iteration start % 1.0,
204         // otherwise, let the simple iteration progress be overall progress % 1.0.
205         double simpleIterationProgress = std::isinf(*overallProgress) ? fmod(m_iterationStart, 1) : fmod(*overallProgress, 1);
206 
207         // 3. If all of the following conditions are true,
208         //
209         // the simple iteration progress calculated above is zero, and
210         // the animation effect is in the active phase or the after phase, and
211         // the active time is equal to the active duration, and
212         // the iteration count is not equal to zero.
213         // let the simple iteration progress be 1.0.
<span class="line-modified">214         if (!simpleIterationProgress &amp;&amp; (phase == AnimationEffectPhase::Active || phase == AnimationEffectPhase::After) &amp;&amp; std::abs(activeTime-&gt;microseconds() - m_activeDuration.microseconds()) &lt; timeEpsilon.microseconds() &amp;&amp; m_iterations)</span>
215             return 1;
216 
217         return simpleIterationProgress;
218     }();
219 
220     auto currentIteration = [this, activeTime, phase, simpleIterationProgress, overallProgress]() -&gt; Optional&lt;double&gt; {
221         // 3.8.4. Calculating the current iteration
222         // https://drafts.csswg.org/web-animations-1/#calculating-the-current-iteration
223 
224         // The current iteration can be calculated using the following steps:
225 
226         // 1. If the active time is unresolved, return unresolved.
227         if (!activeTime)
228             return WTF::nullopt;
229 
230         // 2. If the animation effect is in the after phase and the iteration count is infinity, return infinity.
231         if (phase == AnimationEffectPhase::After &amp;&amp; std::isinf(m_iterations))
232             return std::numeric_limits&lt;double&gt;::infinity();
233 
234         // 3. If the simple iteration progress is 1.0, return floor(overall progress) - 1.
</pre>
<hr />
<pre>
308                 before = (phase == AnimationEffectPhase::Before &amp;&amp; goingForwards) || (phase == AnimationEffectPhase::After &amp;&amp; !goingForwards);
309             }
310 
311             // 3. Return the result of evaluating the animation effect’s timing function passing directed progress as the
312             //    input progress value and before flag as the before flag.
313             return m_timingFunction-&gt;transformTime(*directedProgress, iterationDuration, before);
314         }
315 
316         return *directedProgress;
317     }();
318 
319     ComputedEffectTiming computedTiming;
320     computedTiming.delay = secondsToWebAnimationsAPITime(m_delay);
321     computedTiming.endDelay = secondsToWebAnimationsAPITime(m_endDelay);
322     computedTiming.fill = m_fill == FillMode::Auto ? FillMode::None : m_fill;
323     computedTiming.iterationStart = m_iterationStart;
324     computedTiming.iterations = m_iterations;
325     computedTiming.duration = secondsToWebAnimationsAPITime(m_iterationDuration);
326     computedTiming.direction = m_direction;
327     computedTiming.easing = m_timingFunction-&gt;cssText();
<span class="line-modified">328     computedTiming.endTime = secondsToWebAnimationsAPITime(m_endTime);</span>
<span class="line-modified">329     computedTiming.activeDuration = secondsToWebAnimationsAPITime(m_activeDuration);</span>
330     if (basicEffectTiming.localTime)
331         computedTiming.localTime = secondsToWebAnimationsAPITime(*basicEffectTiming.localTime);
332     computedTiming.simpleIterationProgress = simpleIterationProgress;
333     computedTiming.progress = transformedProgress;
334     computedTiming.currentIteration = currentIteration;
335     computedTiming.phase = phase;
336     return computedTiming;
337 }
338 
339 ExceptionOr&lt;void&gt; AnimationEffect::updateTiming(Optional&lt;OptionalEffectTiming&gt; timing)
340 {
341     // 6.5.4. Updating the timing of an AnimationEffect
342     // https://drafts.csswg.org/web-animations/#updating-animationeffect-timing
343 
344     // To update the timing properties of an animation effect, effect, from an EffectTiming or OptionalEffectTiming object, input, perform the following steps:
345     if (!timing)
346         return { };
347 
<span class="line-added">348     Optional&lt;ComputedEffectTiming&gt; previousTiming;</span>
<span class="line-added">349     if (m_animation)</span>
<span class="line-added">350         previousTiming = getComputedTiming();</span>
<span class="line-added">351 </span>
352     // 1. If the iterationStart member of input is present and less than zero, throw a TypeError and abort this procedure.
353     if (timing-&gt;iterationStart) {
354         if (timing-&gt;iterationStart.value() &lt; 0)
355             return Exception { TypeError };
356     }
357 
358     // 2. If the iterations member of input is present, and less than zero or is the value NaN, throw a TypeError and abort this procedure.
359     if (timing-&gt;iterations) {
360         if (timing-&gt;iterations.value() &lt; 0 || std::isnan(timing-&gt;iterations.value()))
361             return Exception { TypeError };
362     }
363 
364     // 3. If the duration member of input is present, and less than zero or is the value NaN, throw a TypeError and abort this procedure.
365     // FIXME: should it not throw an exception on a string other than &quot;auto&quot;?
366     if (timing-&gt;duration) {
367         if (WTF::holds_alternative&lt;double&gt;(timing-&gt;duration.value())) {
368             auto durationAsDouble = WTF::get&lt;double&gt;(timing-&gt;duration.value());
369             if (durationAsDouble &lt; 0 || std::isnan(durationAsDouble))
370                 return Exception { TypeError };
371         } else {
</pre>
<hr />
<pre>
397         m_delay = Seconds::fromMilliseconds(timing-&gt;delay.value());
398 
399     if (timing-&gt;endDelay)
400         m_endDelay = Seconds::fromMilliseconds(timing-&gt;endDelay.value());
401 
402     if (timing-&gt;fill)
403         m_fill = timing-&gt;fill.value();
404 
405     if (timing-&gt;iterationStart)
406         m_iterationStart = timing-&gt;iterationStart.value();
407 
408     if (timing-&gt;iterations)
409         m_iterations = timing-&gt;iterations.value();
410 
411     if (timing-&gt;duration)
412         m_iterationDuration = WTF::holds_alternative&lt;double&gt;(timing-&gt;duration.value()) ? Seconds::fromMilliseconds(WTF::get&lt;double&gt;(timing-&gt;duration.value())) : 0_s;
413 
414     if (timing-&gt;direction)
415         m_direction = timing-&gt;direction.value();
416 
<span class="line-added">417     updateStaticTimingProperties();</span>
<span class="line-added">418 </span>
419     if (m_animation)
<span class="line-modified">420         m_animation-&gt;effectTimingDidChange(previousTiming);</span>
421 
422     return { };
423 }
424 
<span class="line-added">425 void AnimationEffect::updateStaticTimingProperties()</span>
<span class="line-added">426 {</span>
<span class="line-added">427     // 3.8.2. Calculating the active duration</span>
<span class="line-added">428     // https://drafts.csswg.org/web-animations-1/#calculating-the-active-duration</span>
<span class="line-added">429 </span>
<span class="line-added">430     // The active duration is calculated as follows:</span>
<span class="line-added">431     // active duration = iteration duration × iteration count</span>
<span class="line-added">432     // If either the iteration duration or iteration count are zero, the active duration is zero.</span>
<span class="line-added">433     if (!m_iterationDuration || !m_iterations)</span>
<span class="line-added">434         m_activeDuration = 0_s;</span>
<span class="line-added">435     else</span>
<span class="line-added">436         m_activeDuration = m_iterationDuration * m_iterations;</span>
<span class="line-added">437 </span>
<span class="line-added">438     // 3.5.3 The active interval</span>
<span class="line-added">439     // https://drafts.csswg.org/web-animations-1/#end-time</span>
<span class="line-added">440 </span>
<span class="line-added">441     // The end time of an animation effect is the result of evaluating max(start delay + active duration + end delay, 0).</span>
<span class="line-added">442     m_endTime = m_delay + m_activeDuration + m_endDelay;</span>
<span class="line-added">443     if (m_endTime &lt; 0_s)</span>
<span class="line-added">444         m_endTime = 0_s;</span>
<span class="line-added">445 }</span>
<span class="line-added">446 </span>
447 ExceptionOr&lt;void&gt; AnimationEffect::setIterationStart(double iterationStart)
448 {
449     // https://drafts.csswg.org/web-animations-1/#dom-animationeffecttiming-iterationstart
450     // If an attempt is made to set this attribute to a value less than zero, a TypeError must
451     // be thrown and the value of the iterationStart attribute left unchanged.
452     if (iterationStart &lt; 0)
453         return Exception { TypeError };
454 
455     if (m_iterationStart == iterationStart)
456         return { };
457 
458     m_iterationStart = iterationStart;
459 
460     return { };
461 }
462 
463 ExceptionOr&lt;void&gt; AnimationEffect::setIterations(double iterations)
464 {
465     // https://drafts.csswg.org/web-animations-1/#dom-animationeffecttiming-iterations
466     // If an attempt is made to set this attribute to a value less than zero or a NaN value, a
</pre>
</td>
</tr>
</table>
<center><a href="Animatable.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AnimationEffect.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
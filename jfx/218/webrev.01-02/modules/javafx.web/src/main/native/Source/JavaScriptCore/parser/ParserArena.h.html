<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/ParserArena.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2009-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;CommonIdentifiers.h&quot;
 29 #include &quot;Identifier.h&quot;
 30 #include &lt;array&gt;
 31 #include &lt;type_traits&gt;
 32 #include &lt;wtf/SegmentedVector.h&gt;
 33 
 34 namespace JSC {
 35 
 36     class ParserArenaDeletable;
 37 
 38     DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(IdentifierArena);
 39     class IdentifierArena {
 40         WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(IdentifierArena);
 41     public:
 42         IdentifierArena()
 43         {
 44             clear();
 45         }
 46 
 47         template &lt;typename T&gt;
 48         ALWAYS_INLINE const Identifier&amp; makeIdentifier(VM&amp;, const T* characters, size_t length);
 49         ALWAYS_INLINE const Identifier&amp; makeEmptyIdentifier(VM&amp;);
 50         ALWAYS_INLINE const Identifier&amp; makeIdentifierLCharFromUChar(VM&amp;, const UChar* characters, size_t length);
 51         ALWAYS_INLINE const Identifier&amp; makeIdentifier(VM&amp;, SymbolImpl*);
 52 
 53         const Identifier&amp; makeBigIntDecimalIdentifier(VM&amp;, const Identifier&amp;, uint8_t radix);
 54         const Identifier&amp; makeNumericIdentifier(VM&amp;, double number);
 55 
 56     public:
 57         static const int MaximumCachableCharacter = 128;
 58         typedef SegmentedVector&lt;Identifier, 64&gt; IdentifierVector;
 59         void clear()
 60         {
 61             m_identifiers.clear();
 62             for (int i = 0; i &lt; MaximumCachableCharacter; i++)
 63                 m_shortIdentifiers[i] = 0;
 64             for (int i = 0; i &lt; MaximumCachableCharacter; i++)
 65                 m_recentIdentifiers[i] = 0;
 66         }
 67 
 68     private:
 69         IdentifierVector m_identifiers;
 70         std::array&lt;Identifier*, MaximumCachableCharacter&gt; m_shortIdentifiers;
 71         std::array&lt;Identifier*, MaximumCachableCharacter&gt; m_recentIdentifiers;
 72     };
 73 
 74     template &lt;typename T&gt;
 75     ALWAYS_INLINE const Identifier&amp; IdentifierArena::makeIdentifier(VM&amp; vm, const T* characters, size_t length)
 76     {
 77         if (!length)
 78             return vm.propertyNames-&gt;emptyIdentifier;
 79         if (characters[0] &gt;= MaximumCachableCharacter) {
 80             m_identifiers.append(Identifier::fromString(vm, characters, length));
 81             return m_identifiers.last();
 82         }
 83         if (length == 1) {
 84             if (Identifier* ident = m_shortIdentifiers[characters[0]])
 85                 return *ident;
 86             m_identifiers.append(Identifier::fromString(vm, characters, length));
 87             m_shortIdentifiers[characters[0]] = &amp;m_identifiers.last();
 88             return m_identifiers.last();
 89         }
 90         Identifier* ident = m_recentIdentifiers[characters[0]];
 91         if (ident &amp;&amp; Identifier::equal(ident-&gt;impl(), characters, length))
 92             return *ident;
 93         m_identifiers.append(Identifier::fromString(vm, characters, length));
 94         m_recentIdentifiers[characters[0]] = &amp;m_identifiers.last();
 95         return m_identifiers.last();
 96     }
 97 
 98     ALWAYS_INLINE const Identifier&amp; IdentifierArena::makeIdentifier(VM&amp;, SymbolImpl* symbol)
 99     {
100         ASSERT(symbol);
101         m_identifiers.append(Identifier::fromUid(*symbol));
102         return m_identifiers.last();
103     }
104 
105     ALWAYS_INLINE const Identifier&amp; IdentifierArena::makeEmptyIdentifier(VM&amp; vm)
106     {
107         return vm.propertyNames-&gt;emptyIdentifier;
108     }
109 
110     ALWAYS_INLINE const Identifier&amp; IdentifierArena::makeIdentifierLCharFromUChar(VM&amp; vm, const UChar* characters, size_t length)
111     {
112         if (!length)
113             return vm.propertyNames-&gt;emptyIdentifier;
114         if (characters[0] &gt;= MaximumCachableCharacter) {
115             m_identifiers.append(Identifier::createLCharFromUChar(vm, characters, length));
116             return m_identifiers.last();
117         }
118         if (length == 1) {
119             if (Identifier* ident = m_shortIdentifiers[characters[0]])
120                 return *ident;
121             m_identifiers.append(Identifier::fromString(vm, characters, length));
122             m_shortIdentifiers[characters[0]] = &amp;m_identifiers.last();
123             return m_identifiers.last();
124         }
125         Identifier* ident = m_recentIdentifiers[characters[0]];
126         if (ident &amp;&amp; Identifier::equal(ident-&gt;impl(), characters, length))
127             return *ident;
128         m_identifiers.append(Identifier::createLCharFromUChar(vm, characters, length));
129         m_recentIdentifiers[characters[0]] = &amp;m_identifiers.last();
130         return m_identifiers.last();
131     }
132 
133     inline const Identifier&amp; IdentifierArena::makeNumericIdentifier(VM&amp; vm, double number)
134     {
135         // FIXME: Why doesn&#39;t this use the Identifier::from overload that takes a double?
136         // Seems we are missing out on multiple optimizations by not using it.
137         m_identifiers.append(Identifier::fromString(vm, String::number(number)));
138         return m_identifiers.last();
139     }
140 
141     DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(ParserArena);
142 
143     class ParserArena {
144         WTF_MAKE_NONCOPYABLE(ParserArena);
145     public:
146         ParserArena();
147         ~ParserArena();
148 
149         void swap(ParserArena&amp; otherArena)
150         {
151             std::swap(m_freeableMemory, otherArena.m_freeableMemory);
152             std::swap(m_freeablePoolEnd, otherArena.m_freeablePoolEnd);
153             m_identifierArena.swap(otherArena.m_identifierArena);
154             m_freeablePools.swap(otherArena.m_freeablePools);
155             m_deletableObjects.swap(otherArena.m_deletableObjects);
156         }
157 
158         void* allocateFreeable(size_t size)
159         {
160             ASSERT(size);
161             ASSERT(size &lt;= freeablePoolSize);
162             size_t alignedSize = alignSize(size);
163             ASSERT(alignedSize &lt;= freeablePoolSize);
164             if (UNLIKELY(static_cast&lt;size_t&gt;(m_freeablePoolEnd - m_freeableMemory) &lt; alignedSize))
165                 allocateFreeablePool();
166             void* block = m_freeableMemory;
167             m_freeableMemory += alignedSize;
168             return block;
169         }
170 
171         template&lt;typename T, typename = std::enable_if_t&lt;std::is_base_of&lt;ParserArenaDeletable, T&gt;::value&gt;&gt;
172         void* allocateDeletable(size_t size)
173         {
174             // T may extend ParserArenaDeletable via multiple inheritance, but not as T&#39;s first
175             // base class. m_deletableObjects is expecting pointers to objects of the shape of
176             // ParserArenaDeletable. We ensure this by allocating T, and casting it to
177             // ParserArenaDeletable to get the correct pointer to append to m_deletableObjects.
178             T* instance = static_cast&lt;T*&gt;(allocateFreeable(size));
179             ParserArenaDeletable* deletable = static_cast&lt;ParserArenaDeletable*&gt;(instance);
180             m_deletableObjects.append(deletable);
181             return instance;
182         }
183 
184         IdentifierArena&amp; identifierArena()
185         {
186             if (UNLIKELY (!m_identifierArena))
187                 m_identifierArena = makeUnique&lt;IdentifierArena&gt;();
188             return *m_identifierArena;
189         }
190 
191     private:
192         static const size_t freeablePoolSize = 8000;
193 
194         static size_t alignSize(size_t size)
195         {
196             return (size + sizeof(WTF::AllocAlignmentInteger) - 1) &amp; ~(sizeof(WTF::AllocAlignmentInteger) - 1);
197         }
198 
199         void* freeablePool();
200         void allocateFreeablePool();
201         void deallocateObjects();
202 
203         char* m_freeableMemory;
204         char* m_freeablePoolEnd;
205 
206         std::unique_ptr&lt;IdentifierArena&gt; m_identifierArena;
207         Vector&lt;void*&gt; m_freeablePools;
208         Vector&lt;ParserArenaDeletable*&gt; m_deletableObjects;
209     };
210 
211 } // namespace JSC
    </pre>
  </body>
</html>
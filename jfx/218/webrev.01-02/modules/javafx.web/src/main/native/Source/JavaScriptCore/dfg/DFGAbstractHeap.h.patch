diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractHeap.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractHeap.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractHeap.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractHeap.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
+ * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -26,10 +26,11 @@
 #pragma once
 
 #if ENABLE(DFG_JIT)
 
 #include "DOMJITHeapRange.h"
+#include "OperandsInlines.h"
 #include "VirtualRegister.h"
 #include <wtf/HashMap.h>
 #include <wtf/PrintStream.h>
 
 namespace JSC { namespace DFG {
@@ -54,30 +55,30 @@
     macro(GetterSetter_setter) \
     macro(JSCell_cellState) \
     macro(JSCell_indexingType) \
     macro(JSCell_structureID) \
     macro(JSCell_typeInfoFlags) \
-    macro(JSCell_typeInfoType) \
     macro(JSObject_butterfly) \
     macro(JSPropertyNameEnumerator_cachedPropertyNames) \
     macro(RegExpObject_lastIndex) \
     macro(NamedProperties) \
     macro(IndexedInt32Properties) \
     macro(IndexedDoubleProperties) \
     macro(IndexedContiguousProperties) \
     macro(IndexedArrayStorageProperties) \
-    macro(ArrayStorageProperties) \
     macro(DirectArgumentsProperties) \
     macro(ScopeProperties) \
     macro(TypedArrayProperties) \
     macro(HeapObjectCount) /* Used to reflect the fact that some allocations reveal object identity */\
     macro(RegExpState) \
     macro(MathDotRandomState) \
+    macro(JSDateFields) \
     macro(JSMapFields) \
     macro(JSSetFields) \
     macro(JSWeakMapFields) \
     macro(JSWeakSetFields) \
+    macro(JSInternalFields) \
     macro(InternalState) \
     macro(CatchLocals) \
     macro(Absolute) \
     /* DOMJIT tells the heap range with the pair of integers. */\
     macro(DOMState) \
@@ -121,13 +122,18 @@
             : m_isTop(false)
             , m_value(bitwise_cast<intptr_t>(pointer))
         {
         }
 
-        Payload(VirtualRegister operand)
+        Payload(Operand operand)
             : m_isTop(false)
-            , m_value(operand.offset())
+            , m_value(operand.asBits())
+        {
+        }
+
+        Payload(VirtualRegister operand)
+            : Payload(Operand(operand))
         {
         }
 
         static Payload top() { return Payload(true, 0); }
 
@@ -180,10 +186,11 @@
         {
             return !isDisjoint(other);
         }
 
         void dump(PrintStream&) const;
+        void dumpAsOperand(PrintStream&) const;
 
     private:
         bool m_isTop;
         int64_t m_value;
     };
@@ -201,10 +208,11 @@
 
     AbstractHeap(AbstractHeapKind kind, Payload payload)
     {
         ASSERT(kind != InvalidAbstractHeap && kind != World && kind != Heap && kind != SideState);
         m_value = encode(kind, payload);
+        ASSERT(this->kind() == kind && this->payload() == payload);
     }
 
     AbstractHeap(WTF::HashTableDeletedValueType)
     {
         m_value = encode(InvalidAbstractHeap, Payload::top());
@@ -216,10 +224,15 @@
     Payload payload() const
     {
         ASSERT(kind() != World && kind() != InvalidAbstractHeap);
         return payloadImpl();
     }
+    Operand operand() const
+    {
+        ASSERT(kind() == Stack && !payload().isTop());
+        return Operand::fromBits(payload().value());
+    }
 
     AbstractHeap supertype() const
     {
         ASSERT(kind() != InvalidAbstractHeap);
         switch (kind()) {
@@ -301,12 +314,13 @@
     }
 
     void dump(PrintStream& out) const;
 
 private:
-    static const unsigned valueShift = 15;
-    static const unsigned topShift = 14;
+    static constexpr unsigned valueShift = 15;
+    static constexpr unsigned topShift = 14;
+    static_assert((64 - valueShift) >= Operand::maxBits, "Operand should fit in Payload's encoded format");
 
     Payload payloadImpl() const
     {
         return Payload((m_value >> topShift) & 1, m_value >> valueShift);
     }
@@ -326,11 +340,11 @@
 };
 
 struct AbstractHeapHash {
     static unsigned hash(const AbstractHeap& key) { return key.hash(); }
     static bool equal(const AbstractHeap& a, const AbstractHeap& b) { return a == b; }
-    static const bool safeToCompareToEmptyOrDeleted = true;
+    static constexpr bool safeToCompareToEmptyOrDeleted = true;
 };
 
 } } // namespace JSC::DFG
 
 namespace WTF {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/FastMalloc.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FastBitVector.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FastMalloc.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/FastMalloc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 28 
 29 #include &lt;limits&gt;
 30 #include &lt;string.h&gt;
 31 #include &lt;wtf/CheckedArithmetic.h&gt;
 32 #include &lt;wtf/DataLog.h&gt;
 33 
 34 #if OS(WINDOWS)
 35 #include &lt;windows.h&gt;
 36 #else
 37 #include &lt;pthread.h&gt;
 38 #if HAVE(RESOURCE_H)
 39 #include &lt;sys/resource.h&gt;
 40 #endif // HAVE(RESOURCE_H)
 41 #endif
 42 
 43 #if OS(DARWIN)
 44 #include &lt;mach/mach_init.h&gt;
 45 #include &lt;malloc/malloc.h&gt;
 46 #endif
 47 














 48 namespace WTF {
 49 
 50 #if !defined(NDEBUG)
 51 namespace {
 52 // We do not use std::numeric_limits&lt;size_t&gt;::max() here due to the edge case in VC++.
 53 // https://bugs.webkit.org/show_bug.cgi?id=173720
 54 static size_t maxSingleAllocationSize = SIZE_MAX;
 55 };
 56 
 57 void fastSetMaxSingleAllocationSize(size_t size)
 58 {
 59     maxSingleAllocationSize = size;
 60 }
 61 
 62 #define ASSERT_IS_WITHIN_LIMIT(size) do { \
 63         size_t size__ = (size); \
 64         ASSERT_WITH_MESSAGE((size__) &lt;= maxSingleAllocationSize, &quot;Requested size (%zu) exceeds max single allocation size set for testing (%zu)&quot;, (size__), maxSingleAllocationSize); \
 65     } while (false)
 66 
 67 #define FAIL_IF_EXCEEDS_LIMIT(size) do { \
</pre>
<hr />
<pre>
243 #elif OS(WINDOWS)
244     return _msize(const_cast&lt;void*&gt;(p));
245 #else
246     UNUSED_PARAM(p);
247     return 1;
248 #endif
249 }
250 
251 void fastCommitAlignedMemory(void* ptr, size_t size)
252 {
253     OSAllocator::commit(ptr, size, true, false);
254 }
255 
256 void fastDecommitAlignedMemory(void* ptr, size_t size)
257 {
258     OSAllocator::decommit(ptr, size);
259 }
260 
261 void fastEnableMiniMode() { }
262 


263 } // namespace WTF
264 
265 #else // defined(USE_SYSTEM_MALLOC) &amp;&amp; USE_SYSTEM_MALLOC
266 
267 #include &lt;bmalloc/bmalloc.h&gt;
268 
269 namespace WTF {
270 




























































































































































































271 bool isFastMallocEnabled()
272 {
273     return bmalloc::api::isEnabled();
274 }
275 
276 void* fastMalloc(size_t size)
277 {
278     ASSERT_IS_WITHIN_LIMIT(size);
<span class="line-modified">279     return bmalloc::api::malloc(size);</span>





280 }
281 
282 void* fastCalloc(size_t numElements, size_t elementSize)
283 {
284     ASSERT_IS_WITHIN_LIMIT(numElements * elementSize);
285     Checked&lt;size_t&gt; checkedSize = elementSize;
286     checkedSize *= numElements;
287     void* result = fastZeroedMalloc(checkedSize.unsafeGet());
288     if (!result)
289         CRASH();
290     return result;
291 }
292 
293 void* fastRealloc(void* object, size_t size)
294 {
295     ASSERT_IS_WITHIN_LIMIT(size);
<span class="line-modified">296     return bmalloc::api::realloc(object, size);</span>





297 }
298 
299 void fastFree(void* object)
300 {
301     bmalloc::api::free(object);




302 }
303 
304 size_t fastMallocSize(const void*)
305 {
306     // FIXME: This is incorrect; best fix is probably to remove this function.
307     // Caller currently are all using this for assertion, not to actually check
308     // the size of the allocation, so maybe we can come up with something for that.
309     return 1;
310 }
311 
312 size_t fastMallocGoodSize(size_t size)
313 {
314     return size;
315 }
316 
317 void* fastAlignedMalloc(size_t alignment, size_t size)
318 {
319     ASSERT_IS_WITHIN_LIMIT(size);
<span class="line-modified">320     return bmalloc::api::memalign(alignment, size);</span>





321 }
322 
323 void* tryFastAlignedMalloc(size_t alignment, size_t size)
324 {
325     FAIL_IF_EXCEEDS_LIMIT(size);
<span class="line-modified">326     return bmalloc::api::tryMemalign(alignment, size);</span>





327 }
328 
329 void fastAlignedFree(void* p)
330 {
331     bmalloc::api::free(p);
332 }
333 
334 TryMallocReturnValue tryFastMalloc(size_t size)
335 {
336     FAIL_IF_EXCEEDS_LIMIT(size);
337     return bmalloc::api::tryMalloc(size);
338 }
339 
340 TryMallocReturnValue tryFastCalloc(size_t numElements, size_t elementSize)
341 {
342     FAIL_IF_EXCEEDS_LIMIT(numElements * elementSize);
343     Checked&lt;size_t, RecordOverflow&gt; checkedSize = elementSize;
344     checkedSize *= numElements;
345     if (checkedSize.hasOverflowed())
346         return nullptr;
</pre>
</td>
<td>
<hr />
<pre>
 28 
 29 #include &lt;limits&gt;
 30 #include &lt;string.h&gt;
 31 #include &lt;wtf/CheckedArithmetic.h&gt;
 32 #include &lt;wtf/DataLog.h&gt;
 33 
 34 #if OS(WINDOWS)
 35 #include &lt;windows.h&gt;
 36 #else
 37 #include &lt;pthread.h&gt;
 38 #if HAVE(RESOURCE_H)
 39 #include &lt;sys/resource.h&gt;
 40 #endif // HAVE(RESOURCE_H)
 41 #endif
 42 
 43 #if OS(DARWIN)
 44 #include &lt;mach/mach_init.h&gt;
 45 #include &lt;malloc/malloc.h&gt;
 46 #endif
 47 
<span class="line-added"> 48 #if ENABLE(MALLOC_HEAP_BREAKDOWN)</span>
<span class="line-added"> 49 #include &lt;wtf/Atomics.h&gt;</span>
<span class="line-added"> 50 #include &lt;wtf/HashMap.h&gt;</span>
<span class="line-added"> 51 #include &lt;wtf/Lock.h&gt;</span>
<span class="line-added"> 52 #include &lt;wtf/NeverDestroyed.h&gt;</span>
<span class="line-added"> 53 #include &lt;wtf/SetForScope.h&gt;</span>
<span class="line-added"> 54 #include &lt;wtf/StackShot.h&gt;</span>
<span class="line-added"> 55 </span>
<span class="line-added"> 56 #if PLATFORM(COCOA)</span>
<span class="line-added"> 57 #include &lt;notify.h&gt;</span>
<span class="line-added"> 58 #endif</span>
<span class="line-added"> 59 </span>
<span class="line-added"> 60 #endif</span>
<span class="line-added"> 61 </span>
 62 namespace WTF {
 63 
 64 #if !defined(NDEBUG)
 65 namespace {
 66 // We do not use std::numeric_limits&lt;size_t&gt;::max() here due to the edge case in VC++.
 67 // https://bugs.webkit.org/show_bug.cgi?id=173720
 68 static size_t maxSingleAllocationSize = SIZE_MAX;
 69 };
 70 
 71 void fastSetMaxSingleAllocationSize(size_t size)
 72 {
 73     maxSingleAllocationSize = size;
 74 }
 75 
 76 #define ASSERT_IS_WITHIN_LIMIT(size) do { \
 77         size_t size__ = (size); \
 78         ASSERT_WITH_MESSAGE((size__) &lt;= maxSingleAllocationSize, &quot;Requested size (%zu) exceeds max single allocation size set for testing (%zu)&quot;, (size__), maxSingleAllocationSize); \
 79     } while (false)
 80 
 81 #define FAIL_IF_EXCEEDS_LIMIT(size) do { \
</pre>
<hr />
<pre>
257 #elif OS(WINDOWS)
258     return _msize(const_cast&lt;void*&gt;(p));
259 #else
260     UNUSED_PARAM(p);
261     return 1;
262 #endif
263 }
264 
265 void fastCommitAlignedMemory(void* ptr, size_t size)
266 {
267     OSAllocator::commit(ptr, size, true, false);
268 }
269 
270 void fastDecommitAlignedMemory(void* ptr, size_t size)
271 {
272     OSAllocator::decommit(ptr, size);
273 }
274 
275 void fastEnableMiniMode() { }
276 
<span class="line-added">277 void fastMallocDumpMallocStats() { }</span>
<span class="line-added">278 </span>
279 } // namespace WTF
280 
281 #else // defined(USE_SYSTEM_MALLOC) &amp;&amp; USE_SYSTEM_MALLOC
282 
283 #include &lt;bmalloc/bmalloc.h&gt;
284 
285 namespace WTF {
286 
<span class="line-added">287 #define TRACK_MALLOC_CALLSTACK 0</span>
<span class="line-added">288 </span>
<span class="line-added">289 #if ENABLE(MALLOC_HEAP_BREAKDOWN) &amp;&amp; TRACK_MALLOC_CALLSTACK</span>
<span class="line-added">290 </span>
<span class="line-added">291 static ThreadSpecificKey avoidRecordingCountKey { InvalidThreadSpecificKey };</span>
<span class="line-added">292 class AvoidRecordingScope {</span>
<span class="line-added">293 public:</span>
<span class="line-added">294     AvoidRecordingScope();</span>
<span class="line-added">295     ~AvoidRecordingScope();</span>
<span class="line-added">296 </span>
<span class="line-added">297     static uintptr_t avoidRecordingCount()</span>
<span class="line-added">298     {</span>
<span class="line-added">299         return bitwise_cast&lt;uintptr_t&gt;(threadSpecificGet(avoidRecordingCountKey));</span>
<span class="line-added">300     }</span>
<span class="line-added">301 };</span>
<span class="line-added">302 </span>
<span class="line-added">303 AvoidRecordingScope::AvoidRecordingScope()</span>
<span class="line-added">304 {</span>
<span class="line-added">305     static std::once_flag onceKey;</span>
<span class="line-added">306     std::call_once(onceKey, [] {</span>
<span class="line-added">307         // The value stored in TLS is initially 0.</span>
<span class="line-added">308         threadSpecificKeyCreate(&amp;avoidRecordingCountKey, [](void*) { });</span>
<span class="line-added">309     });</span>
<span class="line-added">310     threadSpecificSet(avoidRecordingCountKey, bitwise_cast&lt;void*&gt;(avoidRecordingCount() + 1));</span>
<span class="line-added">311 }</span>
<span class="line-added">312 </span>
<span class="line-added">313 AvoidRecordingScope::~AvoidRecordingScope()</span>
<span class="line-added">314 {</span>
<span class="line-added">315     threadSpecificSet(avoidRecordingCountKey, bitwise_cast&lt;void*&gt;(avoidRecordingCount() - 1));</span>
<span class="line-added">316 }</span>
<span class="line-added">317 </span>
<span class="line-added">318 class MallocCallTracker {</span>
<span class="line-added">319 public:</span>
<span class="line-added">320     MallocCallTracker();</span>
<span class="line-added">321 </span>
<span class="line-added">322     void recordMalloc(void*, size_t);</span>
<span class="line-added">323     void recordRealloc(void* oldAddress, void* newAddress, size_t);</span>
<span class="line-added">324     void recordFree(void*);</span>
<span class="line-added">325 </span>
<span class="line-added">326     void dumpStats();</span>
<span class="line-added">327 </span>
<span class="line-added">328     static MallocCallTracker&amp; singleton();</span>
<span class="line-added">329 </span>
<span class="line-added">330 private:</span>
<span class="line-added">331     struct MallocSiteData {</span>
<span class="line-added">332         StackShot stack;</span>
<span class="line-added">333         size_t size;</span>
<span class="line-added">334 </span>
<span class="line-added">335         MallocSiteData(size_t stackSize, size_t allocationSize)</span>
<span class="line-added">336             : stack(stackSize)</span>
<span class="line-added">337             , size(allocationSize)</span>
<span class="line-added">338         {</span>
<span class="line-added">339         }</span>
<span class="line-added">340     };</span>
<span class="line-added">341 </span>
<span class="line-added">342     HashMap&lt;void*, std::unique_ptr&lt;MallocSiteData&gt;&gt; m_addressMallocSiteData;</span>
<span class="line-added">343     Lock m_mutex;</span>
<span class="line-added">344 };</span>
<span class="line-added">345 </span>
<span class="line-added">346 MallocCallTracker&amp; MallocCallTracker::singleton()</span>
<span class="line-added">347 {</span>
<span class="line-added">348     AvoidRecordingScope avoidRecording;</span>
<span class="line-added">349     static NeverDestroyed&lt;MallocCallTracker&gt; tracker;</span>
<span class="line-added">350     return tracker;</span>
<span class="line-added">351 }</span>
<span class="line-added">352 </span>
<span class="line-added">353 </span>
<span class="line-added">354 MallocCallTracker::MallocCallTracker()</span>
<span class="line-added">355 {</span>
<span class="line-added">356     int token;</span>
<span class="line-added">357     notify_register_dispatch(&quot;com.apple.WebKit.dumpUntrackedMallocs&quot;, &amp;token, dispatch_get_main_queue(), ^(int) {</span>
<span class="line-added">358         MallocCallTracker::singleton().dumpStats();</span>
<span class="line-added">359     });</span>
<span class="line-added">360 }</span>
<span class="line-added">361 </span>
<span class="line-added">362 void MallocCallTracker::recordMalloc(void* address, size_t allocationSize)</span>
<span class="line-added">363 {</span>
<span class="line-added">364     AvoidRecordingScope avoidRecording;</span>
<span class="line-added">365 </span>
<span class="line-added">366     // Intentionally using std::make_unique not to use FastMalloc for data structure tracking FastMalloc.</span>
<span class="line-added">367     const size_t stackSize = 10;</span>
<span class="line-added">368     auto siteData = std::make_unique&lt;MallocSiteData&gt;(stackSize, allocationSize);</span>
<span class="line-added">369 </span>
<span class="line-added">370     auto locker = holdLock(m_mutex);</span>
<span class="line-added">371     auto addResult = m_addressMallocSiteData.add(address, WTFMove(siteData));</span>
<span class="line-added">372     UNUSED_PARAM(addResult);</span>
<span class="line-added">373 }</span>
<span class="line-added">374 </span>
<span class="line-added">375 void MallocCallTracker::recordRealloc(void* oldAddress, void* newAddress, size_t newSize)</span>
<span class="line-added">376 {</span>
<span class="line-added">377     AvoidRecordingScope avoidRecording;</span>
<span class="line-added">378 </span>
<span class="line-added">379     auto locker = holdLock(m_mutex);</span>
<span class="line-added">380 </span>
<span class="line-added">381     auto it = m_addressMallocSiteData.find(oldAddress);</span>
<span class="line-added">382     if (it == m_addressMallocSiteData.end()) {</span>
<span class="line-added">383         ASSERT_NOT_REACHED();</span>
<span class="line-added">384         return;</span>
<span class="line-added">385     }</span>
<span class="line-added">386 </span>
<span class="line-added">387     it-&gt;value-&gt;size = newSize;</span>
<span class="line-added">388     if (oldAddress != newAddress) {</span>
<span class="line-added">389         auto value = WTFMove(it-&gt;value);</span>
<span class="line-added">390         m_addressMallocSiteData.remove(it);</span>
<span class="line-added">391         auto addResult = m_addressMallocSiteData.add(newAddress, WTFMove(value));</span>
<span class="line-added">392         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-added">393     }</span>
<span class="line-added">394 }</span>
<span class="line-added">395 </span>
<span class="line-added">396 void MallocCallTracker::recordFree(void* address)</span>
<span class="line-added">397 {</span>
<span class="line-added">398     AvoidRecordingScope avoidRecording;</span>
<span class="line-added">399 </span>
<span class="line-added">400     auto locker = holdLock(m_mutex);</span>
<span class="line-added">401     bool removed = m_addressMallocSiteData.remove(address);</span>
<span class="line-added">402     UNUSED_PARAM(removed);</span>
<span class="line-added">403 }</span>
<span class="line-added">404 </span>
<span class="line-added">405 void MallocCallTracker::dumpStats()</span>
<span class="line-added">406 {</span>
<span class="line-added">407     AvoidRecordingScope avoidRecording;</span>
<span class="line-added">408 </span>
<span class="line-added">409     {</span>
<span class="line-added">410         auto locker = holdLock(m_mutex);</span>
<span class="line-added">411 </span>
<span class="line-added">412         // Build a hash of stack to address vector</span>
<span class="line-added">413         struct MallocSiteTotals {</span>
<span class="line-added">414             Vector&lt;MallocSiteData*&gt; siteData;</span>
<span class="line-added">415             size_t count { 0 };</span>
<span class="line-added">416             size_t totalSize { 0 };</span>
<span class="line-added">417         };</span>
<span class="line-added">418 </span>
<span class="line-added">419         size_t totalUntrackedSize = 0;</span>
<span class="line-added">420         size_t totalUntrackedCount = 0;</span>
<span class="line-added">421 </span>
<span class="line-added">422         HashMap&lt;unsigned, std::unique_ptr&lt;MallocSiteTotals&gt;&gt; callSiteToMallocData;</span>
<span class="line-added">423         for (const auto&amp; it : m_addressMallocSiteData) {</span>
<span class="line-added">424             auto result = callSiteToMallocData.ensure(it.value-&gt;stack.hash(), [] () {</span>
<span class="line-added">425                 // Intentionally using std::make_unique not to use FastMalloc for data structure tracking FastMalloc.</span>
<span class="line-added">426                 return std::make_unique&lt;MallocSiteTotals&gt;();</span>
<span class="line-added">427             });</span>
<span class="line-added">428             auto&amp; siteTotal = result.iterator-&gt;value;</span>
<span class="line-added">429             siteTotal-&gt;siteData.append(it.value.get());</span>
<span class="line-added">430             ++siteTotal-&gt;count;</span>
<span class="line-added">431             siteTotal-&gt;totalSize += it.value-&gt;size;</span>
<span class="line-added">432             totalUntrackedSize += it.value-&gt;size;</span>
<span class="line-added">433             ++totalUntrackedCount;</span>
<span class="line-added">434         }</span>
<span class="line-added">435 </span>
<span class="line-added">436         Vector&lt;unsigned&gt; stackHashes;</span>
<span class="line-added">437         auto stackKeys = callSiteToMallocData.keys();</span>
<span class="line-added">438         for (auto key : stackKeys)</span>
<span class="line-added">439             stackHashes.append(key);</span>
<span class="line-added">440 </span>
<span class="line-added">441         // Sort by reverse total size.</span>
<span class="line-added">442         std::sort(stackHashes.begin(), stackHashes.end(), [&amp;] (unsigned a, unsigned b) {</span>
<span class="line-added">443             const auto&amp; aSiteTotals = callSiteToMallocData.get(a);</span>
<span class="line-added">444             const auto&amp; bSiteTotals = callSiteToMallocData.get(b);</span>
<span class="line-added">445 </span>
<span class="line-added">446             return aSiteTotals-&gt;totalSize &gt; bSiteTotals-&gt;totalSize;</span>
<span class="line-added">447         });</span>
<span class="line-added">448 </span>
<span class="line-added">449         WTFLogAlways(&quot;Total untracked bytes: %lu (%lu allocations)\n&quot;, totalUntrackedSize, totalUntrackedCount);</span>
<span class="line-added">450 </span>
<span class="line-added">451         const size_t numStacksToDump = 100;</span>
<span class="line-added">452         for (size_t i = 0; i &lt; std::min(numStacksToDump, stackHashes.size()); ++i) {</span>
<span class="line-added">453             const auto&amp; mallocDataForStack = callSiteToMallocData.get(stackHashes[i]);</span>
<span class="line-added">454 </span>
<span class="line-added">455             WTFLogAlways(&quot;Total allocation size: %lu (%lu allocations)\n&quot;, mallocDataForStack-&gt;totalSize, mallocDataForStack-&gt;count);</span>
<span class="line-added">456             // FIXME: Add a way to remove some entries in StackShot in a programable way.</span>
<span class="line-added">457             // https://bugs.webkit.org/show_bug.cgi?id=205701</span>
<span class="line-added">458             const size_t framesToSkip = 6;</span>
<span class="line-added">459             WTFPrintBacktrace(mallocDataForStack-&gt;siteData[0]-&gt;stack.array() + framesToSkip, mallocDataForStack-&gt;siteData[0]-&gt;stack.size() - framesToSkip);</span>
<span class="line-added">460             WTFLogAlways(&quot;\n&quot;);</span>
<span class="line-added">461         }</span>
<span class="line-added">462     }</span>
<span class="line-added">463 }</span>
<span class="line-added">464 void fastMallocDumpMallocStats()</span>
<span class="line-added">465 {</span>
<span class="line-added">466     MallocCallTracker::singleton().dumpStats();</span>
<span class="line-added">467 }</span>
<span class="line-added">468 #else</span>
<span class="line-added">469 void fastMallocDumpMallocStats()</span>
<span class="line-added">470 {</span>
<span class="line-added">471 }</span>
<span class="line-added">472 #endif</span>
<span class="line-added">473 </span>
<span class="line-added">474 </span>
475 bool isFastMallocEnabled()
476 {
477     return bmalloc::api::isEnabled();
478 }
479 
480 void* fastMalloc(size_t size)
481 {
482     ASSERT_IS_WITHIN_LIMIT(size);
<span class="line-modified">483     void* result = bmalloc::api::malloc(size);</span>
<span class="line-added">484 #if ENABLE(MALLOC_HEAP_BREAKDOWN) &amp;&amp; TRACK_MALLOC_CALLSTACK</span>
<span class="line-added">485     if (!AvoidRecordingScope::avoidRecordingCount())</span>
<span class="line-added">486         MallocCallTracker::singleton().recordMalloc(result, size);</span>
<span class="line-added">487 #endif</span>
<span class="line-added">488     return result;</span>
489 }
490 
491 void* fastCalloc(size_t numElements, size_t elementSize)
492 {
493     ASSERT_IS_WITHIN_LIMIT(numElements * elementSize);
494     Checked&lt;size_t&gt; checkedSize = elementSize;
495     checkedSize *= numElements;
496     void* result = fastZeroedMalloc(checkedSize.unsafeGet());
497     if (!result)
498         CRASH();
499     return result;
500 }
501 
502 void* fastRealloc(void* object, size_t size)
503 {
504     ASSERT_IS_WITHIN_LIMIT(size);
<span class="line-modified">505     void* result = bmalloc::api::realloc(object, size);</span>
<span class="line-added">506 #if ENABLE(MALLOC_HEAP_BREAKDOWN) &amp;&amp; TRACK_MALLOC_CALLSTACK</span>
<span class="line-added">507     if (!AvoidRecordingScope::avoidRecordingCount())</span>
<span class="line-added">508         MallocCallTracker::singleton().recordRealloc(object, result, size);</span>
<span class="line-added">509 #endif</span>
<span class="line-added">510     return result;</span>
511 }
512 
513 void fastFree(void* object)
514 {
515     bmalloc::api::free(object);
<span class="line-added">516 #if ENABLE(MALLOC_HEAP_BREAKDOWN) &amp;&amp; TRACK_MALLOC_CALLSTACK</span>
<span class="line-added">517     if (!AvoidRecordingScope::avoidRecordingCount())</span>
<span class="line-added">518         MallocCallTracker::singleton().recordFree(object);</span>
<span class="line-added">519 #endif</span>
520 }
521 
522 size_t fastMallocSize(const void*)
523 {
524     // FIXME: This is incorrect; best fix is probably to remove this function.
525     // Caller currently are all using this for assertion, not to actually check
526     // the size of the allocation, so maybe we can come up with something for that.
527     return 1;
528 }
529 
530 size_t fastMallocGoodSize(size_t size)
531 {
532     return size;
533 }
534 
535 void* fastAlignedMalloc(size_t alignment, size_t size)
536 {
537     ASSERT_IS_WITHIN_LIMIT(size);
<span class="line-modified">538     void* result = bmalloc::api::memalign(alignment, size);</span>
<span class="line-added">539 #if ENABLE(MALLOC_HEAP_BREAKDOWN) &amp;&amp; TRACK_MALLOC_CALLSTACK</span>
<span class="line-added">540     if (!AvoidRecordingScope::avoidRecordingCount())</span>
<span class="line-added">541         MallocCallTracker::singleton().recordMalloc(result, size);</span>
<span class="line-added">542 #endif</span>
<span class="line-added">543     return result;</span>
544 }
545 
546 void* tryFastAlignedMalloc(size_t alignment, size_t size)
547 {
548     FAIL_IF_EXCEEDS_LIMIT(size);
<span class="line-modified">549     void* result = bmalloc::api::tryMemalign(alignment, size);</span>
<span class="line-added">550 #if ENABLE(MALLOC_HEAP_BREAKDOWN) &amp;&amp; TRACK_MALLOC_CALLSTACK</span>
<span class="line-added">551     if (!AvoidRecordingScope::avoidRecordingCount())</span>
<span class="line-added">552         MallocCallTracker::singleton().recordMalloc(result, size);</span>
<span class="line-added">553 #endif</span>
<span class="line-added">554     return result;</span>
555 }
556 
557 void fastAlignedFree(void* p)
558 {
559     bmalloc::api::free(p);
560 }
561 
562 TryMallocReturnValue tryFastMalloc(size_t size)
563 {
564     FAIL_IF_EXCEEDS_LIMIT(size);
565     return bmalloc::api::tryMalloc(size);
566 }
567 
568 TryMallocReturnValue tryFastCalloc(size_t numElements, size_t elementSize)
569 {
570     FAIL_IF_EXCEEDS_LIMIT(numElements * elementSize);
571     Checked&lt;size_t, RecordOverflow&gt; checkedSize = elementSize;
572     checkedSize *= numElements;
573     if (checkedSize.hasOverflowed())
574         return nullptr;
</pre>
</td>
</tr>
</table>
<center><a href="FastBitVector.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FastMalloc.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
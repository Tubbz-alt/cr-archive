<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGInPlaceAbstractState.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGInPlaceAbstractState.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGIntegerCheckCombiningPhase.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGInPlaceAbstractState.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
150         value.makeHeapTop();
151         value.m_effectEpoch = m_effectEpoch;
152     }
153 
154     ALWAYS_INLINE void makeHeapTopForNode(Edge edge)
155     {
156         makeHeapTopForNode(edge.node());
157     }
158 
159     Operands&lt;AbstractValue&gt;&amp; variablesForDebugging();
160 
161     unsigned numberOfArguments() const { return m_variables.numberOfArguments(); }
162     unsigned numberOfLocals() const { return m_variables.numberOfLocals(); }
163 
164     AbstractValue&amp; variableAt(size_t index)
165     {
166         activateVariableIfNecessary(index);
167         return fastForward(m_variables[index]);
168     }
169 
<span class="line-modified">170     AbstractValue&amp; operand(int operand)</span>
171     {
172         return variableAt(m_variables.operandIndex(operand));
173     }
174 
<span class="line-removed">175     AbstractValue&amp; operand(VirtualRegister operand) { return this-&gt;operand(operand.offset()); }</span>
<span class="line-removed">176 </span>
177     AbstractValue&amp; local(size_t index)
178     {
179         return variableAt(m_variables.localIndex(index));
180     }
181 
182     AbstractValue&amp; argument(size_t index)
183     {
184         return variableAt(m_variables.argumentIndex(index));
185     }
186 
187     // Call this before beginning CFA to initialize the abstract values of
188     // arguments, and to indicate which blocks should be listed for CFA
189     // execution.
190     void initialize();
191 
192     // Start abstractly executing the given basic block. Initializes the
193     // notion of abstract state to what we believe it to be at the head
194     // of the basic block, according to the basic block&#39;s data structures.
195     // This method also sets cfaShouldRevisit to false.
196     void beginBasicBlock(BasicBlock*);
</pre>
<hr />
<pre>
240     // that this is automatically called in endBasicBlock() if MergeMode is
241     // MergeToSuccessors.
242     bool mergeToSuccessors(BasicBlock*);
243 
244     void clobberStructures() { m_effectEpoch.clobber(); }
245 
246     void observeInvalidationPoint() { m_effectEpoch.observeInvalidationPoint(); }
247 
248     // Methods intended to be called from AbstractInterpreter.
249     void setClobberState(AbstractInterpreterClobberState state) { m_clobberState = state; }
250     void mergeClobberState(AbstractInterpreterClobberState state) { m_clobberState = mergeClobberStates(m_clobberState, state); }
251     void setStructureClobberState(StructureClobberState value) { m_structureClobberState = value; }
252     void setIsValid(bool isValid) { m_isValid = isValid; }
253     void setBranchDirection(BranchDirection branchDirection) { m_branchDirection = branchDirection; }
254 
255     // This method is evil - it causes a huge maintenance headache and there is a gross amount of
256     // code devoted to it. It would be much nicer to just always run the constant folder on each
257     // block. But, the last time we did it, it was a 1% SunSpider regression:
258     // https://bugs.webkit.org/show_bug.cgi?id=133947
259     // So, we should probably keep this method.
<span class="line-modified">260     void setFoundConstants(bool foundConstants) { m_foundConstants = foundConstants; }</span>
261 
262     void setProofStatus(Edge&amp; edge, ProofStatus status)
263     {
264         edge.setProofStatus(status);
265     }
266 
267 private:
268     ALWAYS_INLINE void activateVariableIfNecessary(size_t variableIndex)
269     {
270         if (!m_activeVariables[variableIndex])
271             activateVariable(variableIndex);
272     }
273 
274     void activateVariable(size_t variableIndex);
275     void activateAllVariables();
276 
277     static bool mergeVariableBetweenBlocks(AbstractValue&amp; destination, AbstractValue&amp; source, Node* destinationNode, Node* sourceNode);
278 
279     Graph&amp; m_graph;
280 
281     FlowMap&lt;AbstractValue&gt;&amp; m_abstractValues;
282     Operands&lt;AbstractValue&gt; m_variables;
283     FastBitVector m_activeVariables;
284     BasicBlock* m_block;
285 
<span class="line-modified">286     bool m_foundConstants;</span>
287 
288     bool m_isValid;
289     AbstractInterpreterClobberState m_clobberState;
290     StructureClobberState m_structureClobberState;
291     AbstractValueClobberEpoch m_epochAtHead;
292     AbstractValueClobberEpoch m_effectEpoch;
293 
294     BranchDirection m_branchDirection; // This is only set for blocks that end in Branch and that execute to completion (i.e. m_isValid == true).
295 };
296 
297 } } // namespace JSC::DFG
298 
299 #endif // ENABLE(DFG_JIT)
</pre>
</td>
<td>
<hr />
<pre>
150         value.makeHeapTop();
151         value.m_effectEpoch = m_effectEpoch;
152     }
153 
154     ALWAYS_INLINE void makeHeapTopForNode(Edge edge)
155     {
156         makeHeapTopForNode(edge.node());
157     }
158 
159     Operands&lt;AbstractValue&gt;&amp; variablesForDebugging();
160 
161     unsigned numberOfArguments() const { return m_variables.numberOfArguments(); }
162     unsigned numberOfLocals() const { return m_variables.numberOfLocals(); }
163 
164     AbstractValue&amp; variableAt(size_t index)
165     {
166         activateVariableIfNecessary(index);
167         return fastForward(m_variables[index]);
168     }
169 
<span class="line-modified">170     AbstractValue&amp; operand(Operand operand)</span>
171     {
172         return variableAt(m_variables.operandIndex(operand));
173     }
174 


175     AbstractValue&amp; local(size_t index)
176     {
177         return variableAt(m_variables.localIndex(index));
178     }
179 
180     AbstractValue&amp; argument(size_t index)
181     {
182         return variableAt(m_variables.argumentIndex(index));
183     }
184 
185     // Call this before beginning CFA to initialize the abstract values of
186     // arguments, and to indicate which blocks should be listed for CFA
187     // execution.
188     void initialize();
189 
190     // Start abstractly executing the given basic block. Initializes the
191     // notion of abstract state to what we believe it to be at the head
192     // of the basic block, according to the basic block&#39;s data structures.
193     // This method also sets cfaShouldRevisit to false.
194     void beginBasicBlock(BasicBlock*);
</pre>
<hr />
<pre>
238     // that this is automatically called in endBasicBlock() if MergeMode is
239     // MergeToSuccessors.
240     bool mergeToSuccessors(BasicBlock*);
241 
242     void clobberStructures() { m_effectEpoch.clobber(); }
243 
244     void observeInvalidationPoint() { m_effectEpoch.observeInvalidationPoint(); }
245 
246     // Methods intended to be called from AbstractInterpreter.
247     void setClobberState(AbstractInterpreterClobberState state) { m_clobberState = state; }
248     void mergeClobberState(AbstractInterpreterClobberState state) { m_clobberState = mergeClobberStates(m_clobberState, state); }
249     void setStructureClobberState(StructureClobberState value) { m_structureClobberState = value; }
250     void setIsValid(bool isValid) { m_isValid = isValid; }
251     void setBranchDirection(BranchDirection branchDirection) { m_branchDirection = branchDirection; }
252 
253     // This method is evil - it causes a huge maintenance headache and there is a gross amount of
254     // code devoted to it. It would be much nicer to just always run the constant folder on each
255     // block. But, the last time we did it, it was a 1% SunSpider regression:
256     // https://bugs.webkit.org/show_bug.cgi?id=133947
257     // So, we should probably keep this method.
<span class="line-modified">258     void setShouldTryConstantFolding(bool tryConstantFolding) { m_shouldTryConstantFolding = tryConstantFolding; }</span>
259 
260     void setProofStatus(Edge&amp; edge, ProofStatus status)
261     {
262         edge.setProofStatus(status);
263     }
264 
265 private:
266     ALWAYS_INLINE void activateVariableIfNecessary(size_t variableIndex)
267     {
268         if (!m_activeVariables[variableIndex])
269             activateVariable(variableIndex);
270     }
271 
272     void activateVariable(size_t variableIndex);
273     void activateAllVariables();
274 
275     static bool mergeVariableBetweenBlocks(AbstractValue&amp; destination, AbstractValue&amp; source, Node* destinationNode, Node* sourceNode);
276 
277     Graph&amp; m_graph;
278 
279     FlowMap&lt;AbstractValue&gt;&amp; m_abstractValues;
280     Operands&lt;AbstractValue&gt; m_variables;
281     FastBitVector m_activeVariables;
282     BasicBlock* m_block;
283 
<span class="line-modified">284     bool m_shouldTryConstantFolding;</span>
285 
286     bool m_isValid;
287     AbstractInterpreterClobberState m_clobberState;
288     StructureClobberState m_structureClobberState;
289     AbstractValueClobberEpoch m_epochAtHead;
290     AbstractValueClobberEpoch m_effectEpoch;
291 
292     BranchDirection m_branchDirection; // This is only set for blocks that end in Branch and that execute to completion (i.e. m_isValid == true).
293 };
294 
295 } } // namespace JSC::DFG
296 
297 #endif // ENABLE(DFG_JIT)
</pre>
</td>
</tr>
</table>
<center><a href="DFGInPlaceAbstractState.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGIntegerCheckCombiningPhase.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/DocumentMarkerController.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
  5  *           (C) 2006 Alexey Proskuryakov (ap@webkit.org)
  6  * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 Apple Inc. All rights reserved.
  7  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  8  * Copyright (C) Research In Motion Limited 2010. All rights reserved.
  9  *
 10  * This library is free software; you can redistribute it and/or
 11  * modify it under the terms of the GNU Library General Public
 12  * License as published by the Free Software Foundation; either
 13  * version 2 of the License, or (at your option) any later version.
 14  *
 15  * This library is distributed in the hope that it will be useful,
 16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 18  * Library General Public License for more details.
 19  *
 20  * You should have received a copy of the GNU Library General Public License
 21  * along with this library; see the file COPYING.LIB.  If not, write to
 22  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 23  * Boston, MA 02110-1301, USA.
 24  *
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;DocumentMarkerController.h&quot;
 29 
 30 #include &quot;Chrome.h&quot;
 31 #include &quot;ChromeClient.h&quot;
 32 #include &quot;Frame.h&quot;
 33 #include &quot;NodeTraversal.h&quot;
 34 #include &quot;Page.h&quot;
 35 #include &quot;Range.h&quot;
 36 #include &quot;RenderBlockFlow.h&quot;
 37 #include &quot;RenderLayer.h&quot;
 38 #include &quot;RenderText.h&quot;
 39 #include &quot;RenderedDocumentMarker.h&quot;
 40 #include &quot;TextIterator.h&quot;
 41 #include &lt;stdio.h&gt;
 42 
 43 namespace WebCore {
 44 
 45 inline bool DocumentMarkerController::possiblyHasMarkers(OptionSet&lt;DocumentMarker::MarkerType&gt; types)
 46 {
 47     return m_possiblyExistingMarkerTypes.containsAny(types);
 48 }
 49 
 50 DocumentMarkerController::DocumentMarkerController(Document&amp; document)
 51     : m_document(document)
 52 {
 53 }
 54 
 55 DocumentMarkerController::~DocumentMarkerController() = default;
 56 
 57 void DocumentMarkerController::detach()
 58 {
 59     m_markers.clear();
 60     m_possiblyExistingMarkerTypes = { };
 61 }
 62 
<a name="1" id="anc1"></a><span class="line-added"> 63 Vector&lt;RefPtr&lt;Range&gt;&gt; DocumentMarkerController::collectTextRanges(const Range&amp; range)</span>
<span class="line-added"> 64 {</span>
<span class="line-added"> 65     Vector&lt;RefPtr&lt;Range&gt;&gt; textRange;</span>
<span class="line-added"> 66     for (TextIterator textIterator(&amp;range); !textIterator.atEnd(); textIterator.advance())</span>
<span class="line-added"> 67         textRange.append(textIterator.range());</span>
<span class="line-added"> 68     return textRange;</span>
<span class="line-added"> 69 }</span>
<span class="line-added"> 70 </span>
 71 void DocumentMarkerController::addMarker(Range&amp; range, DocumentMarker::MarkerType type, const String&amp; description)
 72 {
<a name="2" id="anc2"></a><span class="line-modified"> 73     for (auto textPiece : collectTextRanges(range))</span>

 74         addMarker(textPiece-&gt;startContainer(), DocumentMarker(type, textPiece-&gt;startOffset(), textPiece-&gt;endOffset(), description));
<a name="3" id="anc3"></a>
 75 }
 76 
 77 void DocumentMarkerController::addMarker(Range&amp; range, DocumentMarker::MarkerType type)
 78 {
<a name="4" id="anc4"></a><span class="line-modified"> 79     for (auto textPiece : collectTextRanges(range))</span>

 80         addMarker(textPiece-&gt;startContainer(), DocumentMarker(type, textPiece-&gt;startOffset(), textPiece-&gt;endOffset()));
<a name="5" id="anc5"></a>

 81 }
 82 
 83 void DocumentMarkerController::addMarkerToNode(Node&amp; node, unsigned startOffset, unsigned length, DocumentMarker::MarkerType type)
 84 {
 85     addMarker(node, DocumentMarker(type, startOffset, startOffset + length));
 86 }
 87 
 88 void DocumentMarkerController::addMarkerToNode(Node&amp; node, unsigned startOffset, unsigned length, DocumentMarker::MarkerType type, DocumentMarker::Data&amp;&amp; data)
 89 {
 90     addMarker(node, DocumentMarker(type, startOffset, startOffset + length, WTFMove(data)));
 91 }
 92 
 93 void DocumentMarkerController::addTextMatchMarker(const Range&amp; range, bool activeMatch)
 94 {
<a name="6" id="anc6"></a><span class="line-modified"> 95     for (auto textPiece : collectTextRanges(range)) {</span>

 96         unsigned startOffset = textPiece-&gt;startOffset();
 97         unsigned endOffset = textPiece-&gt;endOffset();
 98         addMarker(textPiece-&gt;startContainer(), DocumentMarker(startOffset, endOffset, activeMatch));
 99     }
100 }
101 
102 #if PLATFORM(IOS_FAMILY)
103 
104 void DocumentMarkerController::addMarker(Range&amp; range, DocumentMarker::MarkerType type, const String&amp; description, const Vector&lt;String&gt;&amp; interpretations, const RetainPtr&lt;id&gt;&amp; metadata)
105 {
<a name="7" id="anc7"></a><span class="line-modified">106     for (auto textPiece : collectTextRanges(range))</span>

107         addMarker(textPiece-&gt;startContainer(), DocumentMarker(type, textPiece-&gt;startOffset(), textPiece-&gt;endOffset(), description, interpretations, metadata));
<a name="8" id="anc8"></a>
108 }
109 
110 void DocumentMarkerController::addDictationPhraseWithAlternativesMarker(Range&amp; range, const Vector&lt;String&gt;&amp; interpretations)
111 {
112     ASSERT(interpretations.size() &gt; 1);
113     if (interpretations.size() &lt;= 1)
114         return;
115 
116     size_t numberOfAlternatives = interpretations.size() - 1;
<a name="9" id="anc9"></a><span class="line-modified">117     for (auto textPiece : collectTextRanges(range)) {</span>

118         DocumentMarker marker(DocumentMarker::DictationPhraseWithAlternatives, textPiece-&gt;startOffset(), textPiece-&gt;endOffset(), emptyString(), Vector&lt;String&gt;(numberOfAlternatives), RetainPtr&lt;id&gt;());
119         for (size_t i = 0; i &lt; numberOfAlternatives; ++i)
120             marker.setAlternative(interpretations[i + 1], i);
121         addMarker(textPiece-&gt;startContainer(), marker);
122     }
123 }
124 
125 void DocumentMarkerController::addDictationResultMarker(Range&amp; range, const RetainPtr&lt;id&gt;&amp; metadata)
126 {
<a name="10" id="anc10"></a><span class="line-modified">127     for (auto textPiece : collectTextRanges(range))</span>

128         addMarker(textPiece-&gt;startContainer(), DocumentMarker(DocumentMarker::DictationResult, textPiece-&gt;startOffset(), textPiece-&gt;endOffset(), String(), Vector&lt;String&gt;(), metadata));
<a name="11" id="anc11"></a>
129 }
130 
131 #endif
132 
133 void DocumentMarkerController::addDraggedContentMarker(Range&amp; range)
134 {
<a name="12" id="anc12"></a><span class="line-modified">135     for (auto textPiece : collectTextRanges(range)) {</span>
<span class="line-modified">136         DocumentMarker::DraggedContentData draggedContentData { textPiece-&gt;firstNode() };</span>

137         addMarker(textPiece-&gt;startContainer(), { DocumentMarker::DraggedContent, textPiece-&gt;startOffset(), textPiece-&gt;endOffset(), WTFMove(draggedContentData) });
138     }
139 }
140 
141 #if ENABLE(PLATFORM_DRIVEN_TEXT_CHECKING)
142 void DocumentMarkerController::addPlatformTextCheckingMarker(Range&amp; range, const String&amp; key, const String&amp; value)
143 {
<a name="13" id="anc13"></a><span class="line-modified">144     for (auto textPiece : collectTextRanges(range)) {</span>

145         DocumentMarker::PlatformTextCheckingData textCheckingData { key, value };
146         addMarker(textPiece-&gt;startContainer(), { DocumentMarker::PlatformTextChecking, textPiece-&gt;startOffset(), textPiece-&gt;endOffset(), WTFMove(textCheckingData) });
147     }
148 }
149 #endif
150 
151 void DocumentMarkerController::removeMarkers(Range&amp; range, OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypes, RemovePartiallyOverlappingMarkerOrNot shouldRemovePartiallyOverlappingMarker)
152 {
<a name="14" id="anc14"></a><span class="line-modified">153     for (auto textPiece : collectTextRanges(range)) {</span>
154         if (!possiblyHasMarkers(markerTypes))
155             return;
156         ASSERT(!m_markers.isEmpty());
<a name="15" id="anc15"></a>

157         unsigned startOffset = textPiece-&gt;startOffset();
158         unsigned endOffset = textPiece-&gt;endOffset();
159         removeMarkers(textPiece-&gt;startContainer(), startOffset, endOffset - startOffset, markerTypes, nullptr, shouldRemovePartiallyOverlappingMarker);
160     }
161 }
162 
163 void DocumentMarkerController::filterMarkers(Range&amp; range, std::function&lt;bool(DocumentMarker*)&gt; filterFunction, OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypes, RemovePartiallyOverlappingMarkerOrNot shouldRemovePartiallyOverlappingMarker)
164 {
<a name="16" id="anc16"></a><span class="line-modified">165     for (auto textPiece : collectTextRanges(range)) {</span>
166         if (!possiblyHasMarkers(markerTypes))
167             return;
168         ASSERT(!m_markers.isEmpty());
169 
<a name="17" id="anc17"></a>
170         unsigned startOffset = textPiece-&gt;startOffset();
171         unsigned endOffset = textPiece-&gt;endOffset();
172         removeMarkers(textPiece-&gt;startContainer(), startOffset, endOffset - startOffset, markerTypes, filterFunction, shouldRemovePartiallyOverlappingMarker);
173     }
174 }
175 
176 static void updateRenderedRectsForMarker(RenderedDocumentMarker&amp; marker, Node&amp; node)
177 {
178     ASSERT(!node.document().view() || !node.document().view()-&gt;needsLayout());
179 
180     // FIXME: We should refactor this so that we don&#39;t use Range (because we only have one Node), but still share code with absoluteTextQuads().
181     auto markerRange = Range::create(node.document(), &amp;node, marker.startOffset(), &amp;node, marker.endOffset());
182     Vector&lt;FloatQuad&gt; absoluteMarkerQuads;
183     markerRange-&gt;absoluteTextQuads(absoluteMarkerQuads, true);
184 
185     Vector&lt;FloatRect&gt; absoluteMarkerRects;
186     absoluteMarkerRects.reserveInitialCapacity(absoluteMarkerQuads.size());
187     for (const auto&amp; quad : absoluteMarkerQuads)
188         absoluteMarkerRects.uncheckedAppend(quad.boundingBox());
189 
190     marker.setUnclippedAbsoluteRects(absoluteMarkerRects);
191 }
192 
193 void DocumentMarkerController::invalidateRectsForAllMarkers()
194 {
195     if (!hasMarkers())
196         return;
197 
198     for (auto&amp; markers : m_markers.values()) {
199         for (auto&amp; marker : *markers)
200             marker.invalidate();
201     }
202 
203     if (Page* page = m_document.page())
204         page-&gt;chrome().client().didInvalidateDocumentMarkerRects();
205 }
206 
207 void DocumentMarkerController::invalidateRectsForMarkersInNode(Node&amp; node)
208 {
209     if (!hasMarkers())
210         return;
211 
212     MarkerList* markers = m_markers.get(&amp;node);
213     ASSERT(markers);
214 
215     for (auto&amp; marker : *markers)
216         marker.invalidate();
217 
218     if (Page* page = m_document.page())
219         page-&gt;chrome().client().didInvalidateDocumentMarkerRects();
220 }
221 
222 static void updateMainFrameLayoutIfNeeded(Document&amp; document)
223 {
224     Frame* frame = document.frame();
225     if (!frame)
226         return;
227 
228     FrameView* mainFrameView = frame-&gt;mainFrame().view();
229     if (!mainFrameView)
230         return;
231 
232     mainFrameView-&gt;updateLayoutAndStyleIfNeededRecursive();
233 }
234 
235 void DocumentMarkerController::updateRectsForInvalidatedMarkersOfType(DocumentMarker::MarkerType markerType)
236 {
237     if (!possiblyHasMarkers(markerType))
238         return;
239     ASSERT(!(m_markers.isEmpty()));
240 
241     bool needsLayoutIfAnyRectsAreDirty = true;
242 
243     for (auto&amp; nodeAndMarkers : m_markers) {
244         Node&amp; node = *nodeAndMarkers.key;
245         for (auto&amp; marker : *nodeAndMarkers.value) {
246             if (marker.type() != markerType)
247                 continue;
248 
249             if (marker.isValid())
250                 continue;
251 
252             // We&#39;ll do up to one layout per call if we have any dirty markers.
253             if (needsLayoutIfAnyRectsAreDirty) {
254                 updateMainFrameLayoutIfNeeded(m_document);
255                 needsLayoutIfAnyRectsAreDirty = false;
256             }
257 
258             updateRenderedRectsForMarker(marker, node);
259         }
260     }
261 }
262 
263 Vector&lt;FloatRect&gt; DocumentMarkerController::renderedRectsForMarkers(DocumentMarker::MarkerType markerType)
264 {
265     Vector&lt;FloatRect&gt; result;
266 
267     if (!possiblyHasMarkers(markerType))
268         return result;
269     ASSERT(!(m_markers.isEmpty()));
270 
271     RefPtr&lt;Frame&gt; frame = m_document.frame();
272     if (!frame)
273         return result;
274     FrameView* frameView = frame-&gt;view();
275     if (!frameView)
276         return result;
277 
278     updateRectsForInvalidatedMarkersOfType(markerType);
279 
280     bool isSubframe = !frame-&gt;isMainFrame();
281     IntRect subframeClipRect;
282     if (isSubframe)
283         subframeClipRect = frameView-&gt;windowToContents(frameView-&gt;windowClipRect());
284 
285     for (auto&amp; nodeAndMarkers : m_markers) {
286         Node&amp; node = *nodeAndMarkers.key;
287         FloatRect overflowClipRect;
288         if (RenderObject* renderer = node.renderer())
289             overflowClipRect = renderer-&gt;absoluteClippedOverflowRect();
290         for (auto&amp; marker : *nodeAndMarkers.value) {
291             if (marker.type() != markerType)
292                 continue;
293 
294             auto renderedRects = marker.unclippedAbsoluteRects();
295 
296             // Clip document markers by their overflow clip.
297             if (node.renderer()) {
298                 for (auto&amp; rect : renderedRects)
299                     rect.intersect(overflowClipRect);
300             }
301 
302             // Clip subframe document markers by their frame.
303             if (isSubframe) {
304                 for (auto&amp; rect : renderedRects)
305                     rect.intersect(subframeClipRect);
306             }
307 
308             for (const auto&amp; rect : renderedRects) {
309                 if (!rect.isEmpty())
310                     result.append(rect);
311             }
312         }
313     }
314 
315     return result;
316 }
317 
318 static bool shouldInsertAsSeparateMarker(const DocumentMarker&amp; newMarker)
319 {
320 #if ENABLE(PLATFORM_DRIVEN_TEXT_CHECKING)
321     if (newMarker.type() == DocumentMarker::PlatformTextChecking)
322         return true;
323 #endif
324 
325 #if PLATFORM(IOS_FAMILY)
326     if (newMarker.type() == DocumentMarker::DictationPhraseWithAlternatives || newMarker.type() == DocumentMarker::DictationResult)
327         return true;
328 #endif
329     if (newMarker.type() == DocumentMarker::DraggedContent) {
330         if (auto targetNode = WTF::get&lt;DocumentMarker::DraggedContentData&gt;(newMarker.data()).targetNode)
331             return targetNode-&gt;renderer() &amp;&amp; targetNode-&gt;renderer()-&gt;isRenderReplaced();
332     }
333 
334     return false;
335 }
336 
337 // Markers are stored in order sorted by their start offset.
338 // Markers of the same type do not overlap each other.
339 
340 void DocumentMarkerController::addMarker(Node&amp; node, const DocumentMarker&amp; newMarker)
341 {
342     ASSERT(newMarker.endOffset() &gt;= newMarker.startOffset());
343     if (newMarker.endOffset() == newMarker.startOffset())
344         return;
345 
346     if (auto* renderer = node.renderer()) {
347         // FIXME: Factor the marker painting code out of InlineTextBox and teach simple line layout to use it.
348         if (is&lt;RenderText&gt;(*renderer))
349             downcast&lt;RenderText&gt;(*renderer).ensureLineBoxes();
350         else if (is&lt;RenderBlockFlow&gt;(*renderer))
351             downcast&lt;RenderBlockFlow&gt;(*renderer).ensureLineBoxes();
352     }
353 
354     m_possiblyExistingMarkerTypes.add(newMarker.type());
355 
356     std::unique_ptr&lt;MarkerList&gt;&amp; list = m_markers.add(&amp;node, nullptr).iterator-&gt;value;
357 
358     if (!list) {
359         list = makeUnique&lt;MarkerList&gt;();
360         list-&gt;append(RenderedDocumentMarker(newMarker));
361     } else if (shouldInsertAsSeparateMarker(newMarker)) {
362         // We don&#39;t merge dictation markers.
363         size_t i;
364         size_t numberOfMarkers = list-&gt;size();
365         for (i = 0; i &lt; numberOfMarkers; ++i) {
366             DocumentMarker marker = list-&gt;at(i);
367             if (marker.startOffset() &gt; newMarker.startOffset())
368                 break;
369         }
370         list-&gt;insert(i, RenderedDocumentMarker(newMarker));
371     } else {
372         RenderedDocumentMarker toInsert(newMarker);
373         size_t numMarkers = list-&gt;size();
374         size_t i;
375         // Iterate over all markers whose start offset is less than or equal to the new marker&#39;s.
376         // If one of them is of the same type as the new marker and touches it or intersects with it
377         // (there is at most one), remove it and adjust the new marker&#39;s start offset to encompass it.
378         for (i = 0; i &lt; numMarkers; ++i) {
379             DocumentMarker marker = list-&gt;at(i);
380             if (marker.startOffset() &gt; toInsert.startOffset())
381                 break;
382             if (marker.type() == toInsert.type() &amp;&amp; marker.endOffset() &gt;= toInsert.startOffset()) {
383                 toInsert.setStartOffset(marker.startOffset());
384                 list-&gt;remove(i);
385                 numMarkers--;
386                 break;
387             }
388         }
389         size_t j = i;
390         // Iterate over all markers whose end offset is less than or equal to the new marker&#39;s,
391         // removing markers of the same type as the new marker which touch it or intersect with it,
392         // adjusting the new marker&#39;s end offset to cover them if necessary.
393         while (j &lt; numMarkers) {
394             DocumentMarker marker = list-&gt;at(j);
395             if (marker.startOffset() &gt; toInsert.endOffset())
396                 break;
397             if (marker.type() == toInsert.type()) {
398                 list-&gt;remove(j);
399                 if (toInsert.endOffset() &lt;= marker.endOffset()) {
400                     toInsert.setEndOffset(marker.endOffset());
401                     break;
402                 }
403                 numMarkers--;
404             } else
405                 j++;
406         }
407         // At this point i points to the node before which we want to insert.
408         list-&gt;insert(i, RenderedDocumentMarker(toInsert));
409     }
410 
411     if (node.renderer())
412         node.renderer()-&gt;repaint();
413 
414     invalidateRectsForMarkersInNode(node);
415 }
416 
417 // copies markers from srcNode to dstNode, applying the specified shift delta to the copies.  The shift is
418 // useful if, e.g., the caller has created the dstNode from a non-prefix substring of the srcNode.
419 void DocumentMarkerController::copyMarkers(Node&amp; srcNode, unsigned startOffset, int length, Node&amp; dstNode, int delta)
420 {
421     if (length &lt;= 0)
422         return;
423 
424     if (!possiblyHasMarkers(DocumentMarker::allMarkers()))
425         return;
426     ASSERT(!m_markers.isEmpty());
427 
428     MarkerList* list = m_markers.get(&amp;srcNode);
429     if (!list)
430         return;
431 
432     bool docDirty = false;
433     unsigned endOffset = startOffset + length - 1;
434     for (auto&amp; marker : *list) {
435         // stop if we are now past the specified range
436         if (marker.startOffset() &gt; endOffset)
437             break;
438 
439         // skip marker that is before the specified range or is the wrong type
440         if (marker.endOffset() &lt; startOffset)
441             continue;
442 
443         // pin the marker to the specified range and apply the shift delta
444         docDirty = true;
445         if (marker.startOffset() &lt; startOffset)
446             marker.setStartOffset(startOffset);
447         if (marker.endOffset() &gt; endOffset)
448             marker.setEndOffset(endOffset);
449         marker.shiftOffsets(delta);
450 
451         addMarker(dstNode, marker);
452     }
453 
454     if (docDirty &amp;&amp; dstNode.renderer())
455         dstNode.renderer()-&gt;repaint();
456 }
457 
458 void DocumentMarkerController::removeMarkers(Node&amp; node, unsigned startOffset, int length, OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypes, std::function&lt;bool(DocumentMarker*)&gt; filterFunction, RemovePartiallyOverlappingMarkerOrNot shouldRemovePartiallyOverlappingMarker)
459 {
460     if (length &lt;= 0)
461         return;
462 
463     if (!possiblyHasMarkers(markerTypes))
464         return;
465     ASSERT(!(m_markers.isEmpty()));
466 
467     MarkerList* list = m_markers.get(&amp;node);
468     if (!list)
469         return;
470 
471     bool docDirty = false;
472     unsigned endOffset = startOffset + length;
473     for (size_t i = 0; i &lt; list-&gt;size();) {
474         DocumentMarker marker = list-&gt;at(i);
475 
476         // markers are returned in order, so stop if we are now past the specified range
477         if (marker.startOffset() &gt;= endOffset)
478             break;
479 
480         // skip marker that is wrong type or before target
481         if (marker.endOffset() &lt;= startOffset || !markerTypes.contains(marker.type())) {
482             i++;
483             continue;
484         }
485 
486         if (filterFunction &amp;&amp; !filterFunction(&amp;marker)) {
487             i++;
488             continue;
489         }
490 
491         // at this point we know that marker and target intersect in some way
492         docDirty = true;
493 
494         // pitch the old marker
495         list-&gt;remove(i);
496 
497         if (shouldRemovePartiallyOverlappingMarker)
498             // Stop here. Don&#39;t add resulting slices back.
499             continue;
500 
501         // add either of the resulting slices that are left after removing target
502         if (startOffset &gt; marker.startOffset()) {
503             DocumentMarker newLeft = marker;
504             newLeft.setEndOffset(startOffset);
505             list-&gt;insert(i, RenderedDocumentMarker(newLeft));
506             // i now points to the newly-inserted node, but we want to skip that one
507             i++;
508         }
509         if (marker.endOffset() &gt; endOffset) {
510             DocumentMarker newRight = marker;
511             newRight.setStartOffset(endOffset);
512             list-&gt;insert(i, RenderedDocumentMarker(newRight));
513             // i now points to the newly-inserted node, but we want to skip that one
514             i++;
515         }
516     }
517 
518     if (list-&gt;isEmpty()) {
519         m_markers.remove(&amp;node);
520         if (m_markers.isEmpty())
521             m_possiblyExistingMarkerTypes = { };
522     }
523 
524     if (docDirty &amp;&amp; node.renderer())
525         node.renderer()-&gt;repaint();
526 }
527 
528 DocumentMarker* DocumentMarkerController::markerContainingPoint(const LayoutPoint&amp; point, DocumentMarker::MarkerType markerType)
529 {
530     if (!possiblyHasMarkers(markerType))
531         return nullptr;
532     ASSERT(!(m_markers.isEmpty()));
533 
534     updateRectsForInvalidatedMarkersOfType(markerType);
535 
536     for (auto&amp; nodeAndMarkers : m_markers) {
537         for (auto&amp; marker : *nodeAndMarkers.value) {
538             if (marker.type() != markerType)
539                 continue;
540 
541             if (marker.contains(point))
542                 return &amp;marker;
543         }
544     }
545 
546     return nullptr;
547 }
548 
549 Vector&lt;RenderedDocumentMarker*&gt; DocumentMarkerController::markersFor(Node&amp; node, OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypes)
550 {
551     if (!possiblyHasMarkers(markerTypes))
552         return { };
553 
554     Vector&lt;RenderedDocumentMarker*&gt; result;
555     MarkerList* list = m_markers.get(&amp;node);
556     if (!list)
557         return result;
558 
559     for (auto&amp; marker : *list) {
560         if (markerTypes.contains(marker.type()))
561             result.append(&amp;marker);
562     }
563 
564     return result;
565 }
566 
567 Vector&lt;RenderedDocumentMarker*&gt; DocumentMarkerController::markersInRange(Range&amp; range, OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypes)
568 {
569     if (!possiblyHasMarkers(markerTypes))
570         return Vector&lt;RenderedDocumentMarker*&gt;();
571 
572     Vector&lt;RenderedDocumentMarker*&gt; foundMarkers;
573 
574     Node&amp; startContainer = range.startContainer();
575     Node&amp; endContainer = range.endContainer();
576 
577     Node* pastLastNode = range.pastLastNode();
578     for (Node* node = range.firstNode(); node != pastLastNode; node = NodeTraversal::next(*node)) {
579         ASSERT(node);
580         for (auto* marker : markersFor(*node)) {
581             if (!markerTypes.contains(marker-&gt;type()))
582                 continue;
583             if (node == &amp;startContainer &amp;&amp; marker-&gt;endOffset() &lt;= range.startOffset())
584                 continue;
585             if (node == &amp;endContainer &amp;&amp; marker-&gt;startOffset() &gt;= range.endOffset())
586                 continue;
587             foundMarkers.append(marker);
588         }
589     }
590     return foundMarkers;
591 }
592 
593 void DocumentMarkerController::removeMarkers(Node&amp; node, OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypes)
594 {
595     if (!possiblyHasMarkers(markerTypes))
596         return;
597     ASSERT(!m_markers.isEmpty());
598 
599     auto iterator = m_markers.find(&amp;node);
600     if (iterator != m_markers.end())
601         removeMarkersFromList(iterator, markerTypes);
602 }
603 
604 void DocumentMarkerController::removeMarkers(OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypes)
605 {
606     if (!possiblyHasMarkers(markerTypes))
607         return;
608     ASSERT(!m_markers.isEmpty());
609 
610     for (auto&amp; node : copyToVector(m_markers.keys())) {
611         auto iterator = m_markers.find(node);
612         if (iterator != m_markers.end())
613             removeMarkersFromList(iterator, markerTypes);
614     }
615 
616     m_possiblyExistingMarkerTypes.remove(markerTypes);
617 }
618 
619 void DocumentMarkerController::removeMarkersFromList(MarkerMap::iterator iterator, OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypes)
620 {
621     bool needsRepainting = false;
622     bool listCanBeRemoved;
623 
624     if (markerTypes == DocumentMarker::allMarkers()) {
625         needsRepainting = true;
626         listCanBeRemoved = true;
627     } else {
628         MarkerList* list = iterator-&gt;value.get();
629 
630         for (size_t i = 0; i != list-&gt;size(); ) {
631             DocumentMarker marker = list-&gt;at(i);
632 
633             // skip nodes that are not of the specified type
634             if (!markerTypes.contains(marker.type())) {
635                 ++i;
636                 continue;
637             }
638 
639             // pitch the old marker
640             list-&gt;remove(i);
641             needsRepainting = true;
642             // i now is the index of the next marker
643         }
644 
645         listCanBeRemoved = list-&gt;isEmpty();
646     }
647 
648     if (needsRepainting) {
649         if (auto renderer = iterator-&gt;key-&gt;renderer())
650             renderer-&gt;repaint();
651     }
652 
653     if (listCanBeRemoved) {
654         m_markers.remove(iterator);
655         if (m_markers.isEmpty())
656             m_possiblyExistingMarkerTypes = { };
657     }
658 }
659 
660 void DocumentMarkerController::repaintMarkers(OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypes)
661 {
662     if (!possiblyHasMarkers(markerTypes))
663         return;
664     ASSERT(!m_markers.isEmpty());
665 
666     // outer loop: process each markered node in the document
667     for (auto&amp; marker : m_markers) {
668         Node* node = marker.key.get();
669 
670         // inner loop: process each marker in the current node
671         bool nodeNeedsRepaint = false;
672         for (auto&amp; documentMarker : *marker.value) {
673             if (markerTypes.contains(documentMarker.type())) {
674                 nodeNeedsRepaint = true;
675                 break;
676             }
677         }
678 
679         if (!nodeNeedsRepaint)
680             continue;
681 
682         // cause the node to be redrawn
683         if (auto renderer = node-&gt;renderer())
684             renderer-&gt;repaint();
685     }
686 }
687 
688 void DocumentMarkerController::shiftMarkers(Node&amp; node, unsigned startOffset, int delta)
689 {
690     if (!possiblyHasMarkers(DocumentMarker::allMarkers()))
691         return;
692     ASSERT(!m_markers.isEmpty());
693 
694     MarkerList* list = m_markers.get(&amp;node);
695     if (!list)
696         return;
697 
698     bool didShiftMarker = false;
699     for (size_t i = 0; i != list-&gt;size(); ) {
700         RenderedDocumentMarker&amp; marker = list-&gt;at(i);
701         // FIXME: How can this possibly be iOS-specific code?
702 #if PLATFORM(IOS_FAMILY)
703         int targetStartOffset = marker.startOffset() + delta;
704         int targetEndOffset = marker.endOffset() + delta;
705         if (targetStartOffset &gt;= node.maxCharacterOffset() || targetEndOffset &lt;= 0) {
706             list-&gt;remove(i);
707             continue;
708         }
709 #endif
710         if (marker.startOffset() &gt;= startOffset) {
711             ASSERT((int)marker.startOffset() + delta &gt;= 0);
712             marker.shiftOffsets(delta);
713             didShiftMarker = true;
714 #if !PLATFORM(IOS_FAMILY)
715         }
716 #else
717         // FIXME: Inserting text inside a DocumentMarker does not grow the marker.
718         // See &lt;https://bugs.webkit.org/show_bug.cgi?id=62504&gt;.
719         } else if (marker.endOffset() &gt; startOffset) {
720             if (marker.endOffset() + delta &lt;= marker.startOffset()) {
721                 list-&gt;remove(i);
722                 continue;
723             }
724             marker.setEndOffset(targetEndOffset &lt; node.maxCharacterOffset() ? targetEndOffset : node.maxCharacterOffset());
725             didShiftMarker = true;
726         }
727 #endif
728         ++i;
729     }
730 
731     if (didShiftMarker) {
732         invalidateRectsForMarkersInNode(node);
733 
734         if (node.renderer())
735             node.renderer()-&gt;repaint();
736     }
737 }
738 
739 void DocumentMarkerController::setMarkersActive(Range&amp; range, bool active)
740 {
741     if (!possiblyHasMarkers(DocumentMarker::allMarkers()))
742         return;
743     ASSERT(!m_markers.isEmpty());
744 
745     Node&amp; startContainer = range.startContainer();
746     Node&amp; endContainer = range.endContainer();
747 
748     Node* pastLastNode = range.pastLastNode();
749 
750     for (Node* node = range.firstNode(); node != pastLastNode; node = NodeTraversal::next(*node)) {
751         unsigned startOffset = node == &amp;startContainer ? range.startOffset() : 0;
752         unsigned endOffset = node == &amp;endContainer ? range.endOffset() : std::numeric_limits&lt;unsigned&gt;::max();
753         setMarkersActive(*node, startOffset, endOffset, active);
754     }
755 }
756 
757 void DocumentMarkerController::setMarkersActive(Node&amp; node, unsigned startOffset, unsigned endOffset, bool active)
758 {
759     MarkerList* list = m_markers.get(&amp;node);
760     if (!list)
761         return;
762 
763     bool didActivateMarker = false;
764     for (auto&amp; marker : *list) {
765         // Markers are returned in order, so stop if we are now past the specified range.
766         if (marker.startOffset() &gt;= endOffset)
767             break;
768 
769         // Skip marker that is wrong type or before target.
770         if (marker.endOffset() &lt; startOffset || marker.type() != DocumentMarker::TextMatch)
771             continue;
772 
773         marker.setActiveMatch(active);
774         didActivateMarker = true;
775     }
776 
777     if (didActivateMarker &amp;&amp; node.renderer())
778         node.renderer()-&gt;repaint();
779 }
780 
781 bool DocumentMarkerController::hasMarkers(Range&amp; range, OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypes)
782 {
783     if (!possiblyHasMarkers(markerTypes))
784         return false;
785     ASSERT(!m_markers.isEmpty());
786 
787     Node&amp; startContainer = range.startContainer();
788     Node&amp; endContainer = range.endContainer();
789 
790     Node* pastLastNode = range.pastLastNode();
791     for (Node* node = range.firstNode(); node != pastLastNode; node = NodeTraversal::next(*node)) {
792         ASSERT(node);
793         for (auto* marker : markersFor(*node)) {
794             if (!markerTypes.contains(marker-&gt;type()))
795                 continue;
796             if (node == &amp;startContainer &amp;&amp; marker-&gt;endOffset() &lt;= static_cast&lt;unsigned&gt;(range.startOffset()))
797                 continue;
798             if (node == &amp;endContainer &amp;&amp; marker-&gt;startOffset() &gt;= static_cast&lt;unsigned&gt;(range.endOffset()))
799                 continue;
800             return true;
801         }
802     }
803     return false;
804 }
805 
806 void DocumentMarkerController::clearDescriptionOnMarkersIntersectingRange(Range&amp; range, OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypes)
807 {
808     if (!possiblyHasMarkers(markerTypes))
809         return;
810     ASSERT(!m_markers.isEmpty());
811 
812     Node&amp; startContainer = range.startContainer();
813     Node&amp; endContainer = range.endContainer();
814 
815     Node* pastLastNode = range.pastLastNode();
816     for (Node* node = range.firstNode(); node != pastLastNode; node = NodeTraversal::next(*node)) {
817         unsigned startOffset = node == &amp;startContainer ? range.startOffset() : 0;
818         unsigned endOffset = node == &amp;endContainer ? static_cast&lt;unsigned&gt;(range.endOffset()) : std::numeric_limits&lt;unsigned&gt;::max();
819         MarkerList* list = m_markers.get(node);
820         if (!list)
821             continue;
822 
823         for (size_t i = 0; i &lt; list-&gt;size(); ++i) {
824             DocumentMarker&amp; marker = list-&gt;at(i);
825 
826             // markers are returned in order, so stop if we are now past the specified range
827             if (marker.startOffset() &gt;= endOffset)
828                 break;
829 
830             // skip marker that is wrong type or before target
831             if (marker.endOffset() &lt;= startOffset || !markerTypes.contains(marker.type())) {
832                 i++;
833                 continue;
834             }
835 
836             marker.clearData();
837         }
838     }
839 }
840 
841 #if ENABLE(TREE_DEBUGGING)
842 void DocumentMarkerController::showMarkers() const
843 {
844     fprintf(stderr, &quot;%d nodes have markers:\n&quot;, m_markers.size());
845     for (auto&amp; marker : m_markers) {
846         Node* node = marker.key.get();
847         fprintf(stderr, &quot;%p&quot;, node);
848         for (auto&amp; documentMarker : *marker.value)
849             fprintf(stderr, &quot; %d:[%d:%d](%d)&quot;, documentMarker.type(), documentMarker.startOffset(), documentMarker.endOffset(), documentMarker.isActiveMatch());
850 
851         fprintf(stderr, &quot;\n&quot;);
852     }
853 }
854 #endif
855 
856 } // namespace WebCore
857 
858 #if ENABLE(TREE_DEBUGGING)
859 void showDocumentMarkers(const WebCore::DocumentMarkerController* controller)
860 {
861     if (controller)
862         controller-&gt;showMarkers();
863 }
864 #endif
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/java/ImageBufferJava.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #include &quot;BufferImageJava.h&quot;
 29 
 30 #include &lt;wtf/text/CString.h&gt;
 31 #include &lt;JavaScriptCore/JSCInlines.h&gt;
 32 #include &lt;JavaScriptCore/TypedArrayInlines.h&gt;
 33 #include &lt;JavaScriptCore/Uint8ClampedArray.h&gt;
 34 #include &quot;GraphicsContext.h&quot;
 35 #include &quot;ImageBuffer.h&quot;
 36 #include &quot;ImageData.h&quot;
 37 #include &quot;MIMETypeRegistry.h&quot;
 38 #include &quot;NotImplemented.h&quot;
 39 
 40 #include &quot;PlatformContextJava.h&quot;
 41 #include &quot;GraphicsContext.h&quot;
 42 #include &quot;IntRect.h&quot;
 43 #include &quot;ImageBufferData.h&quot;
 44 
 45 
 46 
 47 namespace WebCore {
 48 
 49 ImageBufferData::ImageBufferData(
 50     const FloatSize&amp; size,
 51     ImageBuffer &amp;rq_holder,
 52     float resolutionScale)
 53   : m_rq_holder(rq_holder)
 54 {
 55     JNIEnv* env = WTF::GetJavaEnv();
 56 
 57     static jmethodID midCreateImage = env-&gt;GetMethodID(
 58         PG_GetGraphicsManagerClass(env),
 59         &quot;createRTImage&quot;,
 60         &quot;(II)Lcom/sun/webkit/graphics/WCImage;&quot;);
 61     ASSERT(midCreateImage);
 62 
 63     m_image = RQRef::create(JLObject(env-&gt;CallObjectMethod(
 64         PL_GetGraphicsManager(env),
 65         midCreateImage,
 66         (jint) ceilf(resolutionScale * size.width()),
 67         (jint) ceilf(resolutionScale * size.height())
 68     )));
 69     WTF::CheckAndClearException(env);
 70 }
 71 
 72 JLObject ImageBufferData::getWCImage() const
 73 {
 74     return m_image-&gt;cloneLocalCopy();
 75 }
 76 
 77 unsigned char *ImageBufferData::data() const
 78 {
 79     JNIEnv* env = WTF::GetJavaEnv();
 80 
 81     //RenderQueue need to be processed before pixel buffer extraction.
 82     //For that purpose it has to be in actual state.
 83     m_rq_holder.context().platformContext()-&gt;rq().flushBuffer();
 84 
 85     static jmethodID midGetBGRABytes = env-&gt;GetMethodID(
 86         PG_GetImageClass(env),
 87         &quot;getPixelBuffer&quot;,
 88         &quot;()Ljava/nio/ByteBuffer;&quot;);
 89     ASSERT(midGetBGRABytes);
 90 
 91     JLObject byteBuffer(env-&gt;CallObjectMethod(getWCImage(), midGetBGRABytes));
 92     WTF::CheckAndClearException(env);
 93 
 94     return byteBuffer
 95         ? (unsigned char *) env-&gt;GetDirectBufferAddress(byteBuffer)
 96         : NULL;
 97 }
 98 
 99 void ImageBufferData::update()
100 {
101     JNIEnv* env = WTF::GetJavaEnv();
102 
103     static jmethodID midUpdateByteBuffer = env-&gt;GetMethodID(
104         PG_GetImageClass(env),
105         &quot;drawPixelBuffer&quot;,
106         &quot;()V&quot;);
107     ASSERT(midUpdateByteBuffer);
108 
109     env-&gt;CallObjectMethod(getWCImage(), midUpdateByteBuffer);
110     WTF::CheckAndClearException(env);
111 }
112 
113 ImageBuffer::ImageBuffer(
114     const FloatSize&amp; size,
115     float resolutionScale,
116     ColorSpace,
117     RenderingMode,
118     const HostWindow*,
119     bool&amp; success
120 )
121     : m_data(size, *this, resolutionScale)
122     , m_logicalSize(size)
123     , m_resolutionScale(resolutionScale)
124 {
125     // RT-10059: ImageBufferData construction may fail if the requested
126     // image size is too large. In that case we exit immediately,
127     // automatically reporting the failure to ImageBuffer::create().
128     if (!m_data.m_image) {
129         return;
130     }
131 
132     float scaledWidth = ceilf(resolutionScale * size.width());
133     float scaledHeight = ceilf(resolutionScale * size.height());
134 
135     // FIXME: Should we automatically use a lower resolution? //XXX: copy-paste from ImageBufferCG.cpp
136     if (!FloatSize(scaledWidth, scaledHeight).isExpressibleAsIntSize())
137         return;
138 
139     m_size = IntSize(scaledWidth, scaledHeight);
140 
141     JNIEnv* env = WTF::GetJavaEnv();
142     static jmethodID midCreateBufferedContextRQ = env-&gt;GetMethodID(
143         PG_GetGraphicsManagerClass(env),
144         &quot;createBufferedContextRQ&quot;,
145         &quot;(Lcom/sun/webkit/graphics/WCImage;)Lcom/sun/webkit/graphics/WCRenderQueue;&quot;);
146     ASSERT(midCreateBufferedContextRQ);
147 
148     JLObject wcRenderQueue(env-&gt;CallObjectMethod(
149         PL_GetGraphicsManager(env),
150         midCreateBufferedContextRQ,
151         (jobject)m_data.getWCImage()));
152     ASSERT(wcRenderQueue);
153     WTF::CheckAndClearException(env);
154 
155     m_data.m_context = std::make_unique&lt;GraphicsContext&gt;(new PlatformContextJava(wcRenderQueue, true));
156     success = true;
157 }
158 
159 ImageBuffer::~ImageBuffer()
160 {
161 }
162 
163 /*
164 size_t ImageBuffer::dataSize() const
165 {
166     return m_size.width() * m_size.height() * 4;
167 }
168 */
169 
170 GraphicsContext&amp; ImageBuffer::context() const
171 {
172     return *m_data.m_context.get();
173 }
174 
175 RefPtr&lt;Image&gt; ImageBuffer::copyImage(BackingStoreCopy, PreserveResolution) const
176 {
177     //utatodo: seems [copyBehavior] is the rest of [drawsUsingCopy]
178     return BufferImage::create(
179         m_data.m_image,
180         m_data.m_context-&gt;platformContext()-&gt;rq_ref(),
181         m_size.width(), m_size.height());
182 }
183 
<a name="1" id="anc1"></a>




184 void ImageBuffer::platformTransformColorSpace(const std::array&lt;uint8_t, 256&gt;&amp;)
185 {
186     notImplemented();
187 /*
188     uint8* rowData = reinterpret_cast&lt;uint8*&gt;(m_data.m_bitmap.Bits());
189     unsigned bytesPerRow = m_data.m_bitmap.BytesPerRow();
190     unsigned rows = m_size.height();
191     unsigned columns = m_size.width();
192     for (unsigned y = 0; y &lt; rows; y++) {
193         uint8* pixel = rowData;
194         for (unsigned x = 0; x &lt; columns; x++) {
195             // lookUpTable doesn&#39;t seem to support a LUT for each color channel
196             // separately (judging from the other ports). We don&#39;t need to
197             // convert from/to pre-multiplied color space since BBitmap storage
198             // is not pre-multiplied.
199             pixel[0] = lookUpTable[pixel[0]];
200             pixel[1] = lookUpTable[pixel[1]];
201             pixel[2] = lookUpTable[pixel[2]];
202             // alpha stays unmodified.
203             pixel += 4;
204         }
205         rowData += bytesPerRow;
206     }
207 */
208 }
209 
210 RefPtr&lt;Uint8ClampedArray&gt; getImageData(
211     const AlphaPremultiplication multiplied,
212     const ImageBufferData&amp; idata,
213     const IntRect&amp; rect,
214     const IntSize&amp; size)
215 {
216     // This code was adapted from the CG implementation
217 
218     if (!idata.data())
219         return nullptr;
220 
221     Checked&lt;unsigned, RecordOverflow&gt; area = 4;
222     area *= rect.width();
223     area *= rect.height();
224     if (area.hasOverflowed())
225         return nullptr;
226 
227     auto result = Uint8ClampedArray::tryCreateUninitialized(area.unsafeGet());
228     uint8_t* resultData = result ? result-&gt;data() : nullptr;
229     if (!resultData)
230         return nullptr;
231 
232     if (rect.x() &lt; 0 || rect.y() &lt; 0
233             || rect.maxX() &gt; size.width() || rect.maxY() &gt; size.height())
234         result-&gt;zeroFill();
235 
236     int originx = rect.x();
237     int destx = 0;
238     if (originx &lt; 0) {
239         destx = -originx;
240         originx = 0;
241     }
242     int endx = rect.maxX();
243     if (endx &gt; size.width())
244         endx = size.width();
245     int width = endx - originx;
246 
247     int originy = rect.y();
248     int desty = 0;
249     if (originy &lt; 0) {
250         desty = -originy;
251         originy = 0;
252     }
253     int endy = rect.maxY();
254     if (endy &gt; size.height())
255         endy = size.height();
256     int height = endy - originy;
257 
258     if (width &lt;= 0 || height &lt;= 0)
259         return result;
260 
261     unsigned dstBytesPerRow = 4 * rect.width();
262     unsigned char* dstRows = resultData + desty * dstBytesPerRow + destx * 4;
263 
264     unsigned srcBytesPerRow = 4 * size.width();
265     unsigned char* srcRows =
266             idata.data() + originy * srcBytesPerRow + originx * 4;
267 
268     for (int y = 0; y &lt; height; ++y) {
269         unsigned char *pd = dstRows;
270         unsigned char *ps = srcRows;
271         for (int x = 0; x &lt; width; x++) {
272             unsigned char alpha = ps[3];
273             if (multiplied == AlphaPremultiplication::Unpremultiplied &amp;&amp; alpha &amp;&amp; alpha!=255) {
274                 // Unmultiply and convert BGRA to RGBA
275                 pd[0] = (ps[2] * 255) / alpha;
276                 pd[1] = (ps[1] * 255) / alpha;
277                 pd[2] = (ps[0] * 255) / alpha;
278                 pd[3] = alpha;
279             } else {
280                 // Convert BGRA to RGBA
281                 pd[0] = ps[2];
282                 pd[1] = ps[1];
283                 pd[2] = ps[0];
284                 pd[3] = alpha;
285             }
286             pd += 4;
287             ps += 4;
288         }
289         srcRows += srcBytesPerRow;
290         dstRows += dstBytesPerRow;
291     }
292 
293 
294     return result;
295 }
296 
297 RefPtr&lt;Uint8ClampedArray&gt; ImageBuffer::getUnmultipliedImageData(const IntRect&amp; rect, IntSize* pixelArrayDimensions, CoordinateSystem coordinateSystem) const
298 {
299     IntRect srcRect = rect;
300     if (coordinateSystem == LogicalCoordinateSystem)
301         srcRect.scale(m_resolutionScale);
302 
303     if (pixelArrayDimensions)
304         *pixelArrayDimensions = srcRect.size();
305 
306     return getImageData(AlphaPremultiplication::Unpremultiplied, m_data, srcRect, m_size);
307 }
308 
309 RefPtr&lt;Uint8ClampedArray&gt; ImageBuffer::getPremultipliedImageData(const IntRect&amp; rect, IntSize* pixelArrayDimensions, CoordinateSystem coordinateSystem) const
310 {
311     IntRect srcRect = rect;
312     if (coordinateSystem == LogicalCoordinateSystem)
313         srcRect.scale(m_resolutionScale);
314 
315     if (pixelArrayDimensions)
316         *pixelArrayDimensions = srcRect.size();
317 
318     return getImageData(AlphaPremultiplication::Premultiplied, m_data, srcRect, m_size);
319 }
320 
321 void ImageBuffer::putByteArray(
322     const Uint8ClampedArray&amp; source,
323     AlphaPremultiplication multiplied,
324     const IntSize&amp; sourceSize,
325     const IntRect&amp; sourceRect,
326     const IntPoint&amp; destPoint,
327     CoordinateSystem coordinateSystem)
328 {
329     // This code was adapted from the CG implementation
330 
331     IntRect scaledSourceRect = sourceRect;
332     IntSize scaledSourceSize = sourceSize;
333     if (coordinateSystem == LogicalCoordinateSystem) {
334         scaledSourceRect.scale(m_resolutionScale);
335         scaledSourceSize.scale(m_resolutionScale);
336     }
337 
338     ASSERT(scaledSourceRect.width() &gt; 0);
339     ASSERT(scaledSourceRect.height() &gt; 0);
340 
341     int originx = scaledSourceRect.x();
342     int destx = destPoint.x() + scaledSourceRect.x();
343     ASSERT(destx &gt;= 0);
344     ASSERT(destx &lt; m_size.width());
345     ASSERT(originx &gt;= 0);
346     ASSERT(originx &lt;= scaledSourceRect.maxX());
347 
348     int endx = destPoint.x() + scaledSourceRect.maxX();
349     ASSERT(endx &lt;= m_size.width());
350     int width = endx - destx;
351 
352     int originy = scaledSourceRect.y();
353     int desty = destPoint.y() + scaledSourceRect.y();
354     ASSERT(desty &gt;= 0);
355     ASSERT(desty &lt; m_size.height());
356     ASSERT(originy &gt;= 0);
357     ASSERT(originy &lt;= scaledSourceRect.maxY());
358 
359     int endy = destPoint.y() + scaledSourceRect.maxY();
360     ASSERT(endy &lt;= m_size.height());
361     int height = endy - desty;
362 
363     if (width &lt;= 0 || height &lt;= 0)
364         return;
365 
366     unsigned srcBytesPerRow = 4 * scaledSourceSize.width();
367     unsigned char* srcRows =
368             source.data() + originy * srcBytesPerRow + originx * 4;
369     unsigned dstBytesPerRow = 4 * m_size.width();
370     unsigned char* dstRows =
371             m_data.data() + desty * dstBytesPerRow + destx * 4;
372 
373     for (int y = 0; y &lt; height; ++y) {
374         unsigned char *pd = dstRows;
375         unsigned char *ps = srcRows;
376         for (int x = 0; x &lt; width; x++) {
377             int alpha = ps[3]; //have to be [int] for right multiply casting
378             if (multiplied == AlphaPremultiplication::Unpremultiplied &amp;&amp; alpha != 255) {
379                 // Premultiply and convert RGBA to BGRA
380                 pd[0] = static_cast&lt;unsigned char&gt;((ps[2] * alpha + 254) / 255);
381                 pd[1] = static_cast&lt;unsigned char&gt;((ps[1] * alpha + 254) / 255);
382                 pd[2] = static_cast&lt;unsigned char&gt;((ps[0] * alpha + 254) / 255);
383                 pd[3] = static_cast&lt;unsigned char&gt;(alpha);
384             } else {
385                 // Convert RGBA to BGRA
386                 pd[0] = ps[2];
387                 pd[1] = ps[1];
388                 pd[2] = ps[0];
389                 pd[3] = alpha;
390             }
391             pd += 4;
392             ps += 4;
393         }
394         dstRows += dstBytesPerRow;
395         srcRows += srcBytesPerRow;
396     }
397 
398     m_data.update();
399 }
400 
401 void ImageBuffer::drawConsuming(std::unique_ptr&lt;ImageBuffer&gt; imageBuffer, GraphicsContext&amp; destContext, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp; options)
402 {
403     imageBuffer-&gt;draw(destContext, destRect, srcRect, options);
404 }
405 
406 void ImageBuffer::draw(
407     GraphicsContext&amp; context,
408     const FloatRect&amp; destRect,
409     const FloatRect&amp; srcRect,
410     const ImagePaintingOptions&amp; options)
411 {
412     RefPtr&lt;Image&gt; imageCopy = copyImage();
413     context.drawImage(
414         *imageCopy,
415         destRect,
416         srcRect,
417         options
418         );
419 }
420 
421 void ImageBuffer::drawPattern(
422     GraphicsContext&amp; context,
423     const FloatRect&amp; destRect,
424     const FloatRect&amp; srcRect,
425     const AffineTransform&amp; patternTransform,
426     const FloatPoint&amp; phase,
427     const FloatSize&amp; spacing,
428     const ImagePaintingOptions&amp; options) // todo tav new param
429 {
430     RefPtr&lt;Image&gt; imageCopy = copyImage();
431     imageCopy-&gt;drawPattern(
432         context,
433         destRect,
434         srcRect,
435         patternTransform,
436         phase,
437         spacing,
438         options);
439 }
440 
441 RefPtr&lt;Image&gt; ImageBuffer::sinkIntoImage(std::unique_ptr&lt;ImageBuffer&gt; imageBuffer, PreserveResolution preserveResolution)
442 {
443     return imageBuffer-&gt;copyImage(DontCopyBackingStore, preserveResolution);
444 }
445 
446 String ImageBuffer::toDataURL(const String&amp; mimeType, Optional&lt;double&gt;, PreserveResolution) const
447 {
448     if (MIMETypeRegistry::isSupportedImageMIMETypeForEncoding(mimeType)) {
449         // RenderQueue need to be processed before pixel buffer extraction.
450         // For that purpose it has to be in actual state.
451         context().platformContext()-&gt;rq().flushBuffer();
452 
453         JNIEnv* env = WTF::GetJavaEnv();
454 
455         static jmethodID midToDataURL = env-&gt;GetMethodID(
456                 PG_GetImageClass(env),
457                 &quot;toDataURL&quot;,
458                 &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;);
459         ASSERT(midToDataURL);
460 
461         JLString data((jstring) env-&gt;CallObjectMethod(
462                 m_data.getWCImage(),
463                 midToDataURL,
464                 (jstring) JLString(mimeType.toJavaString(env))));
465 
466         WTF::CheckAndClearException(env);
467         if (data) {
468             return String(env, data);
469         }
470     }
471     return &quot;data:,&quot;;
472 }
473 
474 Vector&lt;uint8_t&gt; ImageBuffer::toData(const String&amp; mimeType, Optional&lt;double&gt;) const
475 {
476     if (MIMETypeRegistry::isSupportedImageMIMETypeForEncoding(mimeType)) {
477         // RenderQueue need to be processed before pixel buffer extraction.
478         // For that purpose it has to be in actual state.
479         context().platformContext()-&gt;rq().flushBuffer();
480 
481         JNIEnv* env = WTF::GetJavaEnv();
482 
483         static jmethodID midToData = env-&gt;GetMethodID(
484                 PG_GetImageClass(env),
485                 &quot;toData&quot;,
486                 &quot;(Ljava/lang/String;)[B&quot;);
487         ASSERT(midToData);
488 
489         JLocalRef&lt;jbyteArray&gt; jdata((jbyteArray)env-&gt;CallObjectMethod(
490                 m_data.getWCImage(),
491                 midToData,
492                 (jstring) JLString(mimeType.toJavaString(env))));
493 
494         WTF::CheckAndClearException(env);
495         if (jdata) {
496             uint8_t* dataArray = (uint8_t*)env-&gt;GetPrimitiveArrayCritical((jbyteArray)jdata, 0);
497             Vector&lt;uint8_t&gt; data;
498             data.append(dataArray, env-&gt;GetArrayLength(jdata));
499             env-&gt;ReleasePrimitiveArrayCritical(jdata, dataArray, 0);
500             return data;
501         }
502     }
503     return { };
504 }
505 
506 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
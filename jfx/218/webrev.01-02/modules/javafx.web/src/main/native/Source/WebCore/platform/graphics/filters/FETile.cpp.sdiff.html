<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/filters/FETile.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FELighting.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="FETurbulence.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/filters/FETile.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 47     FilterEffect* in = inputEffect(0);
 48 
 49     ImageBuffer* resultImage = createImageBufferResult();
 50     ImageBuffer* inBuffer = in-&gt;imageBufferResult();
 51     if (!resultImage || !inBuffer)
 52         return;
 53 
 54     setIsAlphaImage(in-&gt;isAlphaImage());
 55 
 56     // Source input needs more attention. It has the size of the filterRegion but gives the
 57     // size of the cutted sourceImage back. This is part of the specification and optimization.
 58     FloatRect tileRect = in-&gt;maxEffectRect();
 59     FloatPoint inMaxEffectLocation = tileRect.location();
 60     FloatPoint maxEffectLocation = maxEffectRect().location();
 61     if (in-&gt;filterEffectType() == FilterEffectTypeSourceInput) {
 62         Filter&amp; filter = this-&gt;filter();
 63         tileRect = filter.filterRegion();
 64         tileRect.scale(filter.filterResolution().width(), filter.filterResolution().height());
 65     }
 66 
<span class="line-modified"> 67     auto tileImage = SVGRenderingContext::createImageBuffer(tileRect, tileRect, ColorSpaceSRGB, filter().renderingMode());</span>
 68     if (!tileImage)
 69         return;
 70 
 71     GraphicsContext&amp; tileImageContext = tileImage-&gt;context();
 72     tileImageContext.translate(-inMaxEffectLocation.x(), -inMaxEffectLocation.y());
 73     tileImageContext.drawImageBuffer(*inBuffer, in-&gt;absolutePaintRect().location());
 74 
 75     auto tileImageCopy = ImageBuffer::sinkIntoImage(WTFMove(tileImage));
 76     if (!tileImageCopy)
 77         return;
 78 
 79     auto pattern = Pattern::create(tileImageCopy.releaseNonNull(), true, true);
 80 
 81     AffineTransform patternTransform;
 82     patternTransform.translate(inMaxEffectLocation - maxEffectLocation);
 83     pattern.get().setPatternSpaceTransform(patternTransform);
 84     GraphicsContext&amp; filterContext = resultImage-&gt;context();
 85     filterContext.setFillPattern(WTFMove(pattern));
 86     filterContext.fillRect(FloatRect(FloatPoint(), absolutePaintRect().size()));
 87 }
</pre>
</td>
<td>
<hr />
<pre>
 47     FilterEffect* in = inputEffect(0);
 48 
 49     ImageBuffer* resultImage = createImageBufferResult();
 50     ImageBuffer* inBuffer = in-&gt;imageBufferResult();
 51     if (!resultImage || !inBuffer)
 52         return;
 53 
 54     setIsAlphaImage(in-&gt;isAlphaImage());
 55 
 56     // Source input needs more attention. It has the size of the filterRegion but gives the
 57     // size of the cutted sourceImage back. This is part of the specification and optimization.
 58     FloatRect tileRect = in-&gt;maxEffectRect();
 59     FloatPoint inMaxEffectLocation = tileRect.location();
 60     FloatPoint maxEffectLocation = maxEffectRect().location();
 61     if (in-&gt;filterEffectType() == FilterEffectTypeSourceInput) {
 62         Filter&amp; filter = this-&gt;filter();
 63         tileRect = filter.filterRegion();
 64         tileRect.scale(filter.filterResolution().width(), filter.filterResolution().height());
 65     }
 66 
<span class="line-modified"> 67     auto tileImage = SVGRenderingContext::createImageBuffer(tileRect, tileRect, ColorSpace::SRGB, filter().renderingMode());</span>
 68     if (!tileImage)
 69         return;
 70 
 71     GraphicsContext&amp; tileImageContext = tileImage-&gt;context();
 72     tileImageContext.translate(-inMaxEffectLocation.x(), -inMaxEffectLocation.y());
 73     tileImageContext.drawImageBuffer(*inBuffer, in-&gt;absolutePaintRect().location());
 74 
 75     auto tileImageCopy = ImageBuffer::sinkIntoImage(WTFMove(tileImage));
 76     if (!tileImageCopy)
 77         return;
 78 
 79     auto pattern = Pattern::create(tileImageCopy.releaseNonNull(), true, true);
 80 
 81     AffineTransform patternTransform;
 82     patternTransform.translate(inMaxEffectLocation - maxEffectLocation);
 83     pattern.get().setPatternSpaceTransform(patternTransform);
 84     GraphicsContext&amp; filterContext = resultImage-&gt;context();
 85     filterContext.setFillPattern(WTFMove(pattern));
 86     filterContext.fillRect(FloatRect(FloatPoint(), absolutePaintRect().size()));
 87 }
</pre>
</td>
</tr>
</table>
<center><a href="FELighting.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="FETurbulence.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
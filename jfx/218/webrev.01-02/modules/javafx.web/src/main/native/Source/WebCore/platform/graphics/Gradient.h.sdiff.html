<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Gradient.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GlyphBuffer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GradientImage.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Gradient.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #pragma once
 29 
 30 #include &quot;AffineTransform.h&quot;
 31 #include &quot;Color.h&quot;
 32 #include &quot;FloatPoint.h&quot;
 33 #include &quot;GraphicsTypes.h&quot;

 34 #include &lt;wtf/RefCounted.h&gt;
 35 #include &lt;wtf/Variant.h&gt;
 36 #include &lt;wtf/Vector.h&gt;
 37 
 38 #if USE(CG)
 39 typedef struct CGContext* CGContextRef;
 40 typedef struct CGGradient* CGGradientRef;
 41 typedef CGGradientRef PlatformGradient;
 42 #elif USE(DIRECT2D)
 43 interface ID2D1Brush;
 44 interface ID2D1RenderTarget;
 45 typedef ID2D1Brush* PlatformGradient;
 46 #elif USE(CAIRO)
 47 typedef struct _cairo_pattern cairo_pattern_t;
 48 typedef cairo_pattern_t* PlatformGradient;
 49 #else
 50 typedef void* PlatformGradient;
 51 #endif
 52 
 53 namespace WebCore {
 54 
 55 class Color;
 56 class FloatRect;
 57 class GraphicsContext;
 58 
 59 class Gradient : public RefCounted&lt;Gradient&gt; {
 60 public:
 61     // FIXME: ExtendedColor - A color stop needs a notion of color space.
 62     struct ColorStop {
 63         float offset { 0 };
 64         Color color;
 65 
 66         ColorStop() = default;
 67         ColorStop(float offset, const Color&amp; color)
 68             : offset(offset)
 69             , color(color)
 70         {
 71         }



 72     };
 73 
 74     using ColorStopVector = Vector&lt;ColorStop, 2&gt;;
 75 
 76     struct LinearData {
 77         FloatPoint point0;
 78         FloatPoint point1;



 79     };
 80 
 81     struct RadialData {
 82         FloatPoint point0;
 83         FloatPoint point1;
 84         float startRadius;
 85         float endRadius;
 86         float aspectRatio; // For elliptical gradient, width / height.



 87     };
 88 
 89     struct ConicData {
 90         FloatPoint point0;
 91         float angleRadians;



 92     };
 93 
 94     using Data = Variant&lt;LinearData, RadialData, ConicData&gt;;
 95 
 96     enum class Type { Linear, Radial, Conic };
 97 
<span class="line-modified"> 98     static Ref&lt;Gradient&gt; create(LinearData&amp;&amp;);</span>
<span class="line-modified"> 99     static Ref&lt;Gradient&gt; create(RadialData&amp;&amp;);</span>
<span class="line-modified">100     static Ref&lt;Gradient&gt; create(ConicData&amp;&amp;);</span>
101 
102     WEBCORE_EXPORT ~Gradient();
103 
<span class="line-modified">104     Type type() const;</span>
105 
106     bool hasAlpha() const;
107     bool isZeroSize() const;
108 
109     const Data&amp; data() const { return m_data; }
110 
111     WEBCORE_EXPORT void addColorStop(const ColorStop&amp;);
112     WEBCORE_EXPORT void addColorStop(float, const Color&amp;);
<span class="line-modified">113     void setSortedColorStops(ColorStopVector&amp;&amp;);</span>
114 
115     const ColorStopVector&amp; stops() const { return m_stops; }
116 
<span class="line-modified">117     void setSpreadMethod(GradientSpreadMethod);</span>
118     GradientSpreadMethod spreadMethod() const { return m_spreadMethod; }
119 
120     // CG needs to transform the gradient at draw time.
<span class="line-modified">121     void setGradientSpaceTransform(const AffineTransform&amp; gradientSpaceTransformation);</span>
122     const AffineTransform&amp; gradientSpaceTransform() const { return m_gradientSpaceTransformation; }
123 
124     void fill(GraphicsContext&amp;, const FloatRect&amp;);
125     void adjustParametersForTiledDrawing(FloatSize&amp;, FloatRect&amp;, const FloatSize&amp; spacing);
126 
127     unsigned hash() const;
128     void invalidateHash() { m_cachedHash = 0; }
129 
130 #if USE(CG)
131     void paint(GraphicsContext&amp;);
132     void paint(CGContextRef);
133 #elif USE(DIRECT2D)
134     PlatformGradient createPlatformGradientIfNecessary(ID2D1RenderTarget*);
135 #elif USE(CAIRO)
136     PlatformGradient createPlatformGradient(float globalAlpha);
137 #endif
138 



139 private:
140     Gradient(LinearData&amp;&amp;);
141     Gradient(RadialData&amp;&amp;);
142     Gradient(ConicData&amp;&amp;);
143 
144     PlatformGradient platformGradient();
145     void platformInit() { m_gradient = nullptr; }
146     void platformDestroy();
147 
148     void sortStopsIfNecessary();
149 
150 #if USE(DIRECT2D)
151     void generateGradient(ID2D1RenderTarget*);
152 #endif
153 
154     Data m_data;
155 
156     mutable ColorStopVector m_stops;
157     mutable bool m_stopsSorted { false };
158     GradientSpreadMethod m_spreadMethod { SpreadMethodPad };
159     AffineTransform m_gradientSpaceTransformation;
160 
161     mutable unsigned m_cachedHash { 0 };
162 
163     PlatformGradient m_gradient;
164 };
165 






















































166 }







































































































































































</pre>
</td>
<td>
<hr />
<pre>
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #pragma once
 29 
 30 #include &quot;AffineTransform.h&quot;
 31 #include &quot;Color.h&quot;
 32 #include &quot;FloatPoint.h&quot;
 33 #include &quot;GraphicsTypes.h&quot;
<span class="line-added"> 34 #include &lt;wtf/EnumTraits.h&gt;</span>
 35 #include &lt;wtf/RefCounted.h&gt;
 36 #include &lt;wtf/Variant.h&gt;
 37 #include &lt;wtf/Vector.h&gt;
 38 
 39 #if USE(CG)
 40 typedef struct CGContext* CGContextRef;
 41 typedef struct CGGradient* CGGradientRef;
 42 typedef CGGradientRef PlatformGradient;
 43 #elif USE(DIRECT2D)
 44 interface ID2D1Brush;
 45 interface ID2D1RenderTarget;
 46 typedef ID2D1Brush* PlatformGradient;
 47 #elif USE(CAIRO)
 48 typedef struct _cairo_pattern cairo_pattern_t;
 49 typedef cairo_pattern_t* PlatformGradient;
 50 #else
 51 typedef void* PlatformGradient;
 52 #endif
 53 
 54 namespace WebCore {
 55 
 56 class Color;
 57 class FloatRect;
 58 class GraphicsContext;
 59 
 60 class Gradient : public RefCounted&lt;Gradient&gt; {
 61 public:
 62     // FIXME: ExtendedColor - A color stop needs a notion of color space.
 63     struct ColorStop {
 64         float offset { 0 };
 65         Color color;
 66 
 67         ColorStop() = default;
 68         ColorStop(float offset, const Color&amp; color)
 69             : offset(offset)
 70             , color(color)
 71         {
 72         }
<span class="line-added"> 73 </span>
<span class="line-added"> 74         template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added"> 75         template&lt;class Decoder&gt; static Optional&lt;ColorStop&gt; decode(Decoder&amp;);</span>
 76     };
 77 
 78     using ColorStopVector = Vector&lt;ColorStop, 2&gt;;
 79 
 80     struct LinearData {
 81         FloatPoint point0;
 82         FloatPoint point1;
<span class="line-added"> 83 </span>
<span class="line-added"> 84         template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added"> 85         template&lt;class Decoder&gt; static Optional&lt;LinearData&gt; decode(Decoder&amp;);</span>
 86     };
 87 
 88     struct RadialData {
 89         FloatPoint point0;
 90         FloatPoint point1;
 91         float startRadius;
 92         float endRadius;
 93         float aspectRatio; // For elliptical gradient, width / height.
<span class="line-added"> 94 </span>
<span class="line-added"> 95         template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added"> 96         template&lt;class Decoder&gt; static Optional&lt;RadialData&gt; decode(Decoder&amp;);</span>
 97     };
 98 
 99     struct ConicData {
100         FloatPoint point0;
101         float angleRadians;
<span class="line-added">102 </span>
<span class="line-added">103         template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">104         template&lt;class Decoder&gt; static Optional&lt;ConicData&gt; decode(Decoder&amp;);</span>
105     };
106 
107     using Data = Variant&lt;LinearData, RadialData, ConicData&gt;;
108 
109     enum class Type { Linear, Radial, Conic };
110 
<span class="line-modified">111     WEBCORE_EXPORT static Ref&lt;Gradient&gt; create(LinearData&amp;&amp;);</span>
<span class="line-modified">112     WEBCORE_EXPORT static Ref&lt;Gradient&gt; create(RadialData&amp;&amp;);</span>
<span class="line-modified">113     WEBCORE_EXPORT static Ref&lt;Gradient&gt; create(ConicData&amp;&amp;);</span>
114 
115     WEBCORE_EXPORT ~Gradient();
116 
<span class="line-modified">117     WEBCORE_EXPORT Type type() const;</span>
118 
119     bool hasAlpha() const;
120     bool isZeroSize() const;
121 
122     const Data&amp; data() const { return m_data; }
123 
124     WEBCORE_EXPORT void addColorStop(const ColorStop&amp;);
125     WEBCORE_EXPORT void addColorStop(float, const Color&amp;);
<span class="line-modified">126     WEBCORE_EXPORT void setSortedColorStops(ColorStopVector&amp;&amp;);</span>
127 
128     const ColorStopVector&amp; stops() const { return m_stops; }
129 
<span class="line-modified">130     WEBCORE_EXPORT void setSpreadMethod(GradientSpreadMethod);</span>
131     GradientSpreadMethod spreadMethod() const { return m_spreadMethod; }
132 
133     // CG needs to transform the gradient at draw time.
<span class="line-modified">134     WEBCORE_EXPORT void setGradientSpaceTransform(const AffineTransform&amp; gradientSpaceTransformation);</span>
135     const AffineTransform&amp; gradientSpaceTransform() const { return m_gradientSpaceTransformation; }
136 
137     void fill(GraphicsContext&amp;, const FloatRect&amp;);
138     void adjustParametersForTiledDrawing(FloatSize&amp;, FloatRect&amp;, const FloatSize&amp; spacing);
139 
140     unsigned hash() const;
141     void invalidateHash() { m_cachedHash = 0; }
142 
143 #if USE(CG)
144     void paint(GraphicsContext&amp;);
145     void paint(CGContextRef);
146 #elif USE(DIRECT2D)
147     PlatformGradient createPlatformGradientIfNecessary(ID2D1RenderTarget*);
148 #elif USE(CAIRO)
149     PlatformGradient createPlatformGradient(float globalAlpha);
150 #endif
151 
<span class="line-added">152     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">153     template&lt;class Decoder&gt; static Optional&lt;Ref&lt;Gradient&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">154 </span>
155 private:
156     Gradient(LinearData&amp;&amp;);
157     Gradient(RadialData&amp;&amp;);
158     Gradient(ConicData&amp;&amp;);
159 
160     PlatformGradient platformGradient();
161     void platformInit() { m_gradient = nullptr; }
162     void platformDestroy();
163 
164     void sortStopsIfNecessary();
165 
166 #if USE(DIRECT2D)
167     void generateGradient(ID2D1RenderTarget*);
168 #endif
169 
170     Data m_data;
171 
172     mutable ColorStopVector m_stops;
173     mutable bool m_stopsSorted { false };
174     GradientSpreadMethod m_spreadMethod { SpreadMethodPad };
175     AffineTransform m_gradientSpaceTransformation;
176 
177     mutable unsigned m_cachedHash { 0 };
178 
179     PlatformGradient m_gradient;
180 };
181 
<span class="line-added">182 template&lt;class Encoder&gt;</span>
<span class="line-added">183 void Gradient::ColorStop::encode(Encoder&amp; encoder) const</span>
<span class="line-added">184 {</span>
<span class="line-added">185     encoder &lt;&lt; offset;</span>
<span class="line-added">186     encoder &lt;&lt; color;</span>
<span class="line-added">187 }</span>
<span class="line-added">188 </span>
<span class="line-added">189 template&lt;class Decoder&gt;</span>
<span class="line-added">190 Optional&lt;Gradient::ColorStop&gt; Gradient::ColorStop::decode(Decoder&amp; decoder)</span>
<span class="line-added">191 {</span>
<span class="line-added">192     Optional&lt;float&gt; offset;</span>
<span class="line-added">193     decoder &gt;&gt; offset;</span>
<span class="line-added">194     if (!offset)</span>
<span class="line-added">195         return WTF::nullopt;</span>
<span class="line-added">196 </span>
<span class="line-added">197     Optional&lt;Color&gt; color;</span>
<span class="line-added">198     decoder &gt;&gt; color;</span>
<span class="line-added">199     if (!color)</span>
<span class="line-added">200         return WTF::nullopt;</span>
<span class="line-added">201 </span>
<span class="line-added">202     return {{ *offset, *color }};</span>
<span class="line-added">203 }</span>
<span class="line-added">204 </span>
<span class="line-added">205 template&lt;class Encoder&gt;</span>
<span class="line-added">206 void Gradient::LinearData::encode(Encoder&amp; encoder) const</span>
<span class="line-added">207 {</span>
<span class="line-added">208     encoder &lt;&lt; point0;</span>
<span class="line-added">209     encoder &lt;&lt; point1;</span>
<span class="line-added">210 }</span>
<span class="line-added">211 </span>
<span class="line-added">212 template&lt;class Decoder&gt;</span>
<span class="line-added">213 Optional&lt;Gradient::LinearData&gt; Gradient::LinearData::decode(Decoder&amp; decoder)</span>
<span class="line-added">214 {</span>
<span class="line-added">215     Optional&lt;FloatPoint&gt; point0;</span>
<span class="line-added">216     decoder &gt;&gt; point0;</span>
<span class="line-added">217     if (!point0)</span>
<span class="line-added">218         return WTF::nullopt;</span>
<span class="line-added">219 </span>
<span class="line-added">220     Optional&lt;FloatPoint&gt; point1;</span>
<span class="line-added">221     decoder &gt;&gt; point1;</span>
<span class="line-added">222     if (!point1)</span>
<span class="line-added">223         return WTF::nullopt;</span>
<span class="line-added">224 </span>
<span class="line-added">225     return {{ *point0, *point1 }};</span>
<span class="line-added">226 }</span>
<span class="line-added">227 </span>
<span class="line-added">228 template&lt;class Encoder&gt;</span>
<span class="line-added">229 void Gradient::RadialData::encode(Encoder&amp; encoder) const</span>
<span class="line-added">230 {</span>
<span class="line-added">231     encoder &lt;&lt; point0;</span>
<span class="line-added">232     encoder &lt;&lt; point1;</span>
<span class="line-added">233     encoder &lt;&lt; startRadius;</span>
<span class="line-added">234     encoder &lt;&lt; endRadius;</span>
<span class="line-added">235     encoder &lt;&lt; aspectRatio;</span>
236 }
<span class="line-added">237 </span>
<span class="line-added">238 template&lt;class Decoder&gt;</span>
<span class="line-added">239 Optional&lt;Gradient::RadialData&gt; Gradient::RadialData::decode(Decoder&amp; decoder)</span>
<span class="line-added">240 {</span>
<span class="line-added">241     Optional&lt;FloatPoint&gt; point0;</span>
<span class="line-added">242     decoder &gt;&gt; point0;</span>
<span class="line-added">243     if (!point0)</span>
<span class="line-added">244         return WTF::nullopt;</span>
<span class="line-added">245 </span>
<span class="line-added">246     Optional&lt;FloatPoint&gt; point1;</span>
<span class="line-added">247     decoder &gt;&gt; point1;</span>
<span class="line-added">248     if (!point1)</span>
<span class="line-added">249         return WTF::nullopt;</span>
<span class="line-added">250 </span>
<span class="line-added">251     Optional&lt;float&gt; startRadius;</span>
<span class="line-added">252     decoder &gt;&gt; startRadius;</span>
<span class="line-added">253     if (!startRadius)</span>
<span class="line-added">254         return WTF::nullopt;</span>
<span class="line-added">255 </span>
<span class="line-added">256     Optional&lt;float&gt; endRadius;</span>
<span class="line-added">257     decoder &gt;&gt; endRadius;</span>
<span class="line-added">258     if (!endRadius)</span>
<span class="line-added">259         return WTF::nullopt;</span>
<span class="line-added">260 </span>
<span class="line-added">261     Optional&lt;float&gt; aspectRatio;</span>
<span class="line-added">262     decoder &gt;&gt; aspectRatio;</span>
<span class="line-added">263     if (!aspectRatio)</span>
<span class="line-added">264         return WTF::nullopt;</span>
<span class="line-added">265 </span>
<span class="line-added">266     return {{ *point0, *point1, *startRadius, *endRadius, *aspectRatio }};</span>
<span class="line-added">267 }</span>
<span class="line-added">268 </span>
<span class="line-added">269 template&lt;class Encoder&gt;</span>
<span class="line-added">270 void Gradient::ConicData::encode(Encoder&amp; encoder) const</span>
<span class="line-added">271 {</span>
<span class="line-added">272     encoder &lt;&lt; point0;</span>
<span class="line-added">273     encoder &lt;&lt; angleRadians;</span>
<span class="line-added">274 }</span>
<span class="line-added">275 </span>
<span class="line-added">276 template&lt;class Decoder&gt;</span>
<span class="line-added">277 Optional&lt;Gradient::ConicData&gt; Gradient::ConicData::decode(Decoder&amp; decoder)</span>
<span class="line-added">278 {</span>
<span class="line-added">279     Optional&lt;FloatPoint&gt; point0;</span>
<span class="line-added">280     decoder &gt;&gt; point0;</span>
<span class="line-added">281     if (!point0)</span>
<span class="line-added">282         return WTF::nullopt;</span>
<span class="line-added">283 </span>
<span class="line-added">284     Optional&lt;float&gt; angleRadians;</span>
<span class="line-added">285     decoder &gt;&gt; angleRadians;</span>
<span class="line-added">286     if (!angleRadians)</span>
<span class="line-added">287         return WTF::nullopt;</span>
<span class="line-added">288 </span>
<span class="line-added">289     return {{ *point0, *angleRadians }};</span>
<span class="line-added">290 }</span>
<span class="line-added">291 </span>
<span class="line-added">292 template&lt;class Encoder&gt;</span>
<span class="line-added">293 void Gradient::encode(Encoder&amp; encoder) const</span>
<span class="line-added">294 {</span>
<span class="line-added">295     auto type = this-&gt;type();</span>
<span class="line-added">296     encoder &lt;&lt; type;</span>
<span class="line-added">297     switch (type) {</span>
<span class="line-added">298     case Type::Linear:</span>
<span class="line-added">299         encoder &lt;&lt; WTF::get&lt;Gradient::LinearData&gt;(m_data);</span>
<span class="line-added">300         break;</span>
<span class="line-added">301     case Type::Radial:</span>
<span class="line-added">302         encoder &lt;&lt; WTF::get&lt;Gradient::RadialData&gt;(m_data);</span>
<span class="line-added">303         break;</span>
<span class="line-added">304     case Type::Conic:</span>
<span class="line-added">305         encoder &lt;&lt; WTF::get&lt;Gradient::ConicData&gt;(m_data);</span>
<span class="line-added">306         break;</span>
<span class="line-added">307     }</span>
<span class="line-added">308     encoder &lt;&lt; m_stops;</span>
<span class="line-added">309     encoder &lt;&lt; m_stopsSorted;</span>
<span class="line-added">310     encoder.encodeEnum(m_spreadMethod);</span>
<span class="line-added">311     encoder &lt;&lt; m_gradientSpaceTransformation;</span>
<span class="line-added">312 }</span>
<span class="line-added">313 </span>
<span class="line-added">314 template&lt;class Decoder&gt;</span>
<span class="line-added">315 Optional&lt;Ref&lt;Gradient&gt;&gt; Gradient::decode(Decoder&amp; decoder)</span>
<span class="line-added">316 {</span>
<span class="line-added">317     Optional&lt;Gradient::Type&gt; type;</span>
<span class="line-added">318     decoder &gt;&gt; type;</span>
<span class="line-added">319     if (!type)</span>
<span class="line-added">320         return WTF::nullopt;</span>
<span class="line-added">321 </span>
<span class="line-added">322     RefPtr&lt;Gradient&gt; gradient;</span>
<span class="line-added">323     switch (*type) {</span>
<span class="line-added">324     case Type::Linear: {</span>
<span class="line-added">325         Optional&lt;LinearData&gt; linearData;</span>
<span class="line-added">326         decoder &gt;&gt; linearData;</span>
<span class="line-added">327         if (!linearData)</span>
<span class="line-added">328             return WTF::nullopt;</span>
<span class="line-added">329 </span>
<span class="line-added">330         gradient = Gradient::create(WTFMove(*linearData));</span>
<span class="line-added">331         break;</span>
<span class="line-added">332     }</span>
<span class="line-added">333     case Type::Radial: {</span>
<span class="line-added">334         Optional&lt;RadialData&gt; radialData;</span>
<span class="line-added">335         decoder &gt;&gt; radialData;</span>
<span class="line-added">336         if (!radialData)</span>
<span class="line-added">337             return WTF::nullopt;</span>
<span class="line-added">338 </span>
<span class="line-added">339         gradient = Gradient::create(WTFMove(*radialData));</span>
<span class="line-added">340         break;</span>
<span class="line-added">341     }</span>
<span class="line-added">342     case Type::Conic: {</span>
<span class="line-added">343         Optional&lt;ConicData&gt; conicData;</span>
<span class="line-added">344         decoder &gt;&gt; conicData;</span>
<span class="line-added">345         if (!conicData)</span>
<span class="line-added">346             return WTF::nullopt;</span>
<span class="line-added">347 </span>
<span class="line-added">348         gradient = Gradient::create(WTFMove(*conicData));</span>
<span class="line-added">349         break;</span>
<span class="line-added">350     }</span>
<span class="line-added">351     }</span>
<span class="line-added">352 </span>
<span class="line-added">353     if (!gradient) {</span>
<span class="line-added">354         ASSERT_NOT_REACHED();</span>
<span class="line-added">355         return WTF::nullopt;</span>
<span class="line-added">356     }</span>
<span class="line-added">357 </span>
<span class="line-added">358     Optional&lt;ColorStopVector&gt; stops;</span>
<span class="line-added">359     decoder &gt;&gt; stops;</span>
<span class="line-added">360     if (!stops)</span>
<span class="line-added">361         return WTF::nullopt;</span>
<span class="line-added">362 </span>
<span class="line-added">363     Optional&lt;bool&gt; stopsSorted;</span>
<span class="line-added">364     decoder &gt;&gt; stopsSorted;</span>
<span class="line-added">365     if (!stopsSorted.hasValue())</span>
<span class="line-added">366         return WTF::nullopt;</span>
<span class="line-added">367 </span>
<span class="line-added">368     if (stopsSorted.value())</span>
<span class="line-added">369         gradient-&gt;setSortedColorStops(WTFMove(*stops));</span>
<span class="line-added">370     else {</span>
<span class="line-added">371         for (auto&amp; stop : *stops)</span>
<span class="line-added">372             gradient-&gt;addColorStop(stop);</span>
<span class="line-added">373     }</span>
<span class="line-added">374 </span>
<span class="line-added">375     GradientSpreadMethod spreadMethod;</span>
<span class="line-added">376     if (!decoder.decodeEnum(spreadMethod))</span>
<span class="line-added">377         return WTF::nullopt;</span>
<span class="line-added">378 </span>
<span class="line-added">379     gradient-&gt;setSpreadMethod(spreadMethod);</span>
<span class="line-added">380 </span>
<span class="line-added">381     Optional&lt;AffineTransform&gt; gradientSpaceTransformation;</span>
<span class="line-added">382     decoder &gt;&gt; gradientSpaceTransformation;</span>
<span class="line-added">383     if (!gradientSpaceTransformation)</span>
<span class="line-added">384         return WTF::nullopt;</span>
<span class="line-added">385 </span>
<span class="line-added">386     gradient-&gt;setGradientSpaceTransform(WTFMove(*gradientSpaceTransformation));</span>
<span class="line-added">387     return gradient.releaseNonNull();</span>
<span class="line-added">388 }</span>
<span class="line-added">389 </span>
<span class="line-added">390 } // namespace WebCore</span>
<span class="line-added">391 </span>
<span class="line-added">392 namespace WTF {</span>
<span class="line-added">393 </span>
<span class="line-added">394 template&lt;&gt; struct EnumTraits&lt;WebCore::Gradient::Type&gt; {</span>
<span class="line-added">395     using values = EnumValues&lt;</span>
<span class="line-added">396     WebCore::Gradient::Type,</span>
<span class="line-added">397     WebCore::Gradient::Type::Linear,</span>
<span class="line-added">398     WebCore::Gradient::Type::Radial,</span>
<span class="line-added">399     WebCore::Gradient::Type::Conic</span>
<span class="line-added">400     &gt;;</span>
<span class="line-added">401 };</span>
<span class="line-added">402 </span>
<span class="line-added">403 } // namespace WTF</span>
</pre>
</td>
</tr>
</table>
<center><a href="GlyphBuffer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GradientImage.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
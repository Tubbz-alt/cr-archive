<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT32_64.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGSpeculativeJIT.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSpeculativeJIT64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT32_64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 196         usedRegisters.set(JSValueRegs(baseTagGPROrNone, basePayloadGPR), false);
 197         usedRegisters.set(JSValueRegs(resultTagGPR, resultPayloadGPR), false);
 198     }
 199 
 200     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
 201     JITGetByIdGenerator gen(
 202         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters, identifierUID(identifierNumber),
 203         JSValueRegs(baseTagGPROrNone, basePayloadGPR), JSValueRegs(resultTagGPR, resultPayloadGPR), type);
 204 
 205     gen.generateFastPath(m_jit);
 206 
 207     JITCompiler::JumpList slowCases;
 208     if (slowPathTarget.isSet())
 209         slowCases.append(slowPathTarget);
 210     slowCases.append(gen.slowPathJump());
 211 
 212     std::unique_ptr&lt;SlowPathGenerator&gt; slowPath;
 213     if (baseTagGPROrNone == InvalidGPRReg) {
 214         slowPath = slowPathCall(
 215             slowCases, this, appropriateOptimizingGetByIdFunction(type),
<span class="line-modified"> 216             JSValueRegs(resultTagGPR, resultPayloadGPR), gen.stubInfo(),</span>
 217             CCallHelpers::CellValue(basePayloadGPR),
 218             identifierUID(identifierNumber));
 219     } else {
 220         slowPath = slowPathCall(
 221             slowCases, this, appropriateOptimizingGetByIdFunction(type),
<span class="line-modified"> 222             JSValueRegs(resultTagGPR, resultPayloadGPR), gen.stubInfo(), JSValueRegs(baseTagGPROrNone, basePayloadGPR), identifierUID(identifierNumber));</span>
 223     }
 224 
 225     m_jit.addGetById(gen, slowPath.get());
 226     addSlowPathGenerator(WTFMove(slowPath));
 227 }
 228 
 229 void SpeculativeJIT::cachedGetByIdWithThis(
 230     CodeOrigin codeOrigin, GPRReg baseTagGPROrNone, GPRReg basePayloadGPR, GPRReg thisTagGPR, GPRReg thisPayloadGPR, GPRReg resultTagGPR, GPRReg resultPayloadGPR,
 231     unsigned identifierNumber, const JITCompiler::JumpList&amp; slowPathTarget)
 232 {
 233     RegisterSet usedRegisters = this-&gt;usedRegisters();
 234 
 235     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
 236     JITGetByIdWithThisGenerator gen(
 237         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters, identifierUID(identifierNumber),
<span class="line-modified"> 238         JSValueRegs(resultTagGPR, resultPayloadGPR), JSValueRegs(baseTagGPROrNone, basePayloadGPR), JSValueRegs(thisTagGPR, thisPayloadGPR), AccessType::GetWithThis);</span>
 239 
 240     gen.generateFastPath(m_jit);
 241 
 242     JITCompiler::JumpList slowCases;
 243     if (!slowPathTarget.empty())
 244         slowCases.append(slowPathTarget);
 245     slowCases.append(gen.slowPathJump());
 246 
 247     std::unique_ptr&lt;SlowPathGenerator&gt; slowPath;
 248     if (baseTagGPROrNone == InvalidGPRReg &amp;&amp; thisTagGPR == InvalidGPRReg) {
 249         slowPath = slowPathCall(
 250             slowCases, this, operationGetByIdWithThisOptimize,
<span class="line-modified"> 251             JSValueRegs(resultTagGPR, resultPayloadGPR), gen.stubInfo(),</span>
 252             CCallHelpers::CellValue(basePayloadGPR),
 253             CCallHelpers::CellValue(thisPayloadGPR),
 254             identifierUID(identifierNumber));
 255     } else {
 256         ASSERT(baseTagGPROrNone != InvalidGPRReg);
 257         ASSERT(thisTagGPR != InvalidGPRReg);
 258 
 259         slowPath = slowPathCall(
 260             slowCases, this, operationGetByIdWithThisOptimize,
<span class="line-modified"> 261             JSValueRegs(resultTagGPR, resultPayloadGPR), gen.stubInfo(), JSValueRegs(baseTagGPROrNone, basePayloadGPR), JSValueRegs(thisTagGPR, thisPayloadGPR), identifierUID(identifierNumber));</span>
 262     }
 263 
 264     m_jit.addGetByIdWithThis(gen, slowPath.get());
 265     addSlowPathGenerator(WTFMove(slowPath));
 266 }
 267 
 268 void SpeculativeJIT::nonSpeculativeNonPeepholeCompareNullOrUndefined(Edge operand)
 269 {
 270     JSValueOperand arg(this, operand, ManualOperandSpeculation);
 271     GPRReg argTagGPR = arg.tagGPR();
 272     GPRReg argPayloadGPR = arg.payloadGPR();
 273 
 274     GPRTemporary resultPayload(this, Reuse, arg, PayloadWord);
 275     GPRReg resultPayloadGPR = resultPayload.gpr();
 276 
 277     JITCompiler::Jump notCell;
 278     JITCompiler::Jump notMasqueradesAsUndefined;
 279     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
 280         if (!isKnownCell(operand.node()))
 281             notCell = m_jit.branchIfNotCell(arg.jsValueRegs());
</pre>
<hr />
<pre>
 399 
 400     JSValueOperand arg1(this, node-&gt;child1());
 401     JSValueOperand arg2(this, node-&gt;child2());
 402     GPRReg arg1PayloadGPR = arg1.payloadGPR();
 403     GPRReg arg2PayloadGPR = arg2.payloadGPR();
 404     JSValueRegs arg1Regs = arg1.jsValueRegs();
 405     JSValueRegs arg2Regs = arg2.jsValueRegs();
 406 
 407     GPRTemporary resultPayload(this, Reuse, arg1, PayloadWord);
 408     GPRReg resultPayloadGPR = resultPayload.gpr();
 409 
 410     arg1.use();
 411     arg2.use();
 412 
 413     if (isKnownCell(node-&gt;child1().node()) &amp;&amp; isKnownCell(node-&gt;child2().node())) {
 414         // see if we get lucky: if the arguments are cells and they reference the same
 415         // cell, then they must be strictly equal.
 416         branchPtr(JITCompiler::Equal, arg1PayloadGPR, arg2PayloadGPR, invert ? notTaken : taken);
 417 
 418         silentSpillAllRegisters(resultPayloadGPR);
<span class="line-modified"> 419         callOperation(operationCompareStrictEqCell, resultPayloadGPR, arg1PayloadGPR, arg2PayloadGPR);</span>
 420         m_jit.exceptionCheck();
 421         silentFillAllRegisters();
 422 
 423         branchTest32(invert ? JITCompiler::Zero : JITCompiler::NonZero, resultPayloadGPR, taken);
 424     } else {
 425         // FIXME: Add fast paths for twoCells, number etc.
 426 
 427         silentSpillAllRegisters(resultPayloadGPR);
<span class="line-modified"> 428         callOperation(operationCompareStrictEq, resultPayloadGPR, arg1Regs, arg2Regs);</span>
 429         m_jit.exceptionCheck();
 430         silentFillAllRegisters();
 431 
 432         branchTest32(invert ? JITCompiler::Zero : JITCompiler::NonZero, resultPayloadGPR, taken);
 433     }
 434 
 435     jump(notTaken);
 436 }
 437 
 438 void SpeculativeJIT::nonSpeculativeNonPeepholeStrictEq(Node* node, bool invert)
 439 {
 440     JSValueOperand arg1(this, node-&gt;child1());
 441     JSValueOperand arg2(this, node-&gt;child2());
 442     GPRReg arg1PayloadGPR = arg1.payloadGPR();
 443     GPRReg arg2PayloadGPR = arg2.payloadGPR();
 444     JSValueRegs arg1Regs = arg1.jsValueRegs();
 445     JSValueRegs arg2Regs = arg2.jsValueRegs();
 446 
 447     GPRTemporary resultPayload(this, Reuse, arg1, PayloadWord);
 448     GPRReg resultPayloadGPR = resultPayload.gpr();
 449 
 450     arg1.use();
 451     arg2.use();
 452 
 453     if (isKnownCell(node-&gt;child1().node()) &amp;&amp; isKnownCell(node-&gt;child2().node())) {
 454         // see if we get lucky: if the arguments are cells and they reference the same
 455         // cell, then they must be strictly equal.
 456         // FIXME: this should flush registers instead of silent spill/fill.
 457         JITCompiler::Jump notEqualCase = m_jit.branchPtr(JITCompiler::NotEqual, arg1PayloadGPR, arg2PayloadGPR);
 458 
 459         m_jit.move(JITCompiler::TrustedImm32(!invert), resultPayloadGPR);
 460         JITCompiler::Jump done = m_jit.jump();
 461 
 462         notEqualCase.link(&amp;m_jit);
 463 
 464         silentSpillAllRegisters(resultPayloadGPR);
<span class="line-modified"> 465         callOperation(operationCompareStrictEqCell, resultPayloadGPR, arg1PayloadGPR, arg2PayloadGPR);</span>
 466         m_jit.exceptionCheck();
 467         silentFillAllRegisters();
 468 
 469         m_jit.andPtr(JITCompiler::TrustedImm32(1), resultPayloadGPR);
 470 
 471         done.link(&amp;m_jit);
 472     } else {
 473         // FIXME: Add fast paths.
 474 
 475         silentSpillAllRegisters(resultPayloadGPR);
<span class="line-modified"> 476         callOperation(operationCompareStrictEq, resultPayloadGPR, arg1Regs, arg2Regs);</span>
 477         silentFillAllRegisters();
 478         m_jit.exceptionCheck();
 479 
 480         m_jit.andPtr(JITCompiler::TrustedImm32(1), resultPayloadGPR);
 481     }
 482 
 483     booleanResult(resultPayloadGPR, node, UseChildrenCalledExplicitly);
 484 }
 485 
 486 void SpeculativeJIT::compileCompareEqPtr(Node* node)
 487 {
 488     JSValueOperand operand(this, node-&gt;child1());
 489     GPRTemporary result(this);
 490     JSValueRegs regs = operand.jsValueRegs();
 491     GPRReg resultGPR = result.gpr();
 492     m_jit.boxBooleanPayload(false, resultGPR);
 493     JITCompiler::JumpList notEqual = m_jit.branchIfNotEqual(regs, node-&gt;cellOperand()-&gt;value());
 494     m_jit.boxBooleanPayload(true, resultGPR);
 495     notEqual.link(&amp;m_jit);
 496     blessedBooleanResult(resultGPR, node);
</pre>
<hr />
<pre>
 567     case DirectTailCall:
 568         callType = CallLinkInfo::DirectTailCall;
 569         isTail = true;
 570         isDirect = true;
 571         break;
 572     case DirectTailCallInlinedCaller:
 573         callType = CallLinkInfo::DirectCall;
 574         isEmulatedTail = true;
 575         isDirect = true;
 576         break;
 577     default:
 578         DFG_CRASH(m_jit.graph(), node, &quot;bad node type&quot;);
 579         break;
 580     }
 581 
 582     Edge calleeEdge = m_jit.graph().child(node, 0);
 583     GPRReg calleeTagGPR = InvalidGPRReg;
 584     GPRReg calleePayloadGPR = InvalidGPRReg;
 585     CallFrameShuffleData shuffleData;
 586 

 587     ExecutableBase* executable = nullptr;
 588     FunctionExecutable* functionExecutable = nullptr;
 589     if (isDirect) {
 590         executable = node-&gt;castOperand&lt;ExecutableBase*&gt;();
 591         functionExecutable = jsDynamicCast&lt;FunctionExecutable*&gt;(vm(), executable);
 592     }
 593 
 594     unsigned numPassedArgs = 0;
 595     unsigned numAllocatedArgs = 0;
 596 
 597     // Gotta load the arguments somehow. Varargs is trickier.
 598     if (isVarargs || isForwardVarargs) {
 599         RELEASE_ASSERT(!isDirect);
 600         CallVarargsData* data = node-&gt;callVarargsData();
 601 
 602         int numUsedStackSlots = m_jit.graph().m_nextMachineLocal;
 603 
 604         if (isForwardVarargs) {
 605             flushRegisters();
 606             if (node-&gt;child3())
</pre>
<hr />
<pre>
 608 
 609             GPRReg scratchGPR1;
 610             GPRReg scratchGPR2;
 611             GPRReg scratchGPR3;
 612 
 613             scratchGPR1 = JITCompiler::selectScratchGPR();
 614             scratchGPR2 = JITCompiler::selectScratchGPR(scratchGPR1);
 615             scratchGPR3 = JITCompiler::selectScratchGPR(scratchGPR1, scratchGPR2);
 616 
 617             m_jit.move(TrustedImm32(numUsedStackSlots), scratchGPR2);
 618             JITCompiler::JumpList slowCase;
 619             InlineCallFrame* inlineCallFrame;
 620             if (node-&gt;child3())
 621                 inlineCallFrame = node-&gt;child3()-&gt;origin.semantic.inlineCallFrame();
 622             else
 623                 inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();
 624             // emitSetupVarargsFrameFastCase modifies the stack pointer if it succeeds.
 625             emitSetupVarargsFrameFastCase(vm(), m_jit, scratchGPR2, scratchGPR1, scratchGPR2, scratchGPR3, inlineCallFrame, data-&gt;firstVarArgOffset, slowCase);
 626             JITCompiler::Jump done = m_jit.jump();
 627             slowCase.link(&amp;m_jit);
<span class="line-modified"> 628             callOperation(operationThrowStackOverflowForVarargs);</span>
 629             m_jit.exceptionCheck();
 630             m_jit.abortWithReason(DFGVarargsThrowingPathDidNotThrow);
 631             done.link(&amp;m_jit);
 632         } else {
 633             GPRReg argumentsPayloadGPR;
 634             GPRReg argumentsTagGPR;
 635             GPRReg scratchGPR1;
 636             GPRReg scratchGPR2;
 637             GPRReg scratchGPR3;
 638 
 639             auto loadArgumentsGPR = [&amp;] (GPRReg reservedGPR) {
 640                 if (reservedGPR != InvalidGPRReg)
 641                     lock(reservedGPR);
 642                 JSValueOperand arguments(this, node-&gt;child3());
 643                 argumentsTagGPR = arguments.tagGPR();
 644                 argumentsPayloadGPR = arguments.payloadGPR();
 645                 if (reservedGPR != InvalidGPRReg)
 646                     unlock(reservedGPR);
 647                 flushRegisters();
 648 
 649                 scratchGPR1 = JITCompiler::selectScratchGPR(argumentsPayloadGPR, argumentsTagGPR, reservedGPR);
 650                 scratchGPR2 = JITCompiler::selectScratchGPR(argumentsPayloadGPR, argumentsTagGPR, scratchGPR1, reservedGPR);
 651                 scratchGPR3 = JITCompiler::selectScratchGPR(argumentsPayloadGPR, argumentsTagGPR, scratchGPR1, scratchGPR2, reservedGPR);
 652             };
 653 
 654             loadArgumentsGPR(InvalidGPRReg);
 655 
 656             DFG_ASSERT(m_jit.graph(), node, isFlushed());
 657 
 658             // Right now, arguments is in argumentsTagGPR/argumentsPayloadGPR and the register file is
 659             // flushed.
<span class="line-modified"> 660             callOperation(operationSizeFrameForVarargs, GPRInfo::returnValueGPR, JSValueRegs(argumentsTagGPR, argumentsPayloadGPR), numUsedStackSlots, data-&gt;firstVarArgOffset);</span>
 661             m_jit.exceptionCheck();
 662 
 663             // Now we have the argument count of the callee frame, but we&#39;ve lost the arguments operand.
 664             // Reconstruct the arguments operand while preserving the callee frame.
 665             loadArgumentsGPR(GPRInfo::returnValueGPR);
 666             m_jit.move(TrustedImm32(numUsedStackSlots), scratchGPR1);
 667             emitSetVarargsFrame(m_jit, GPRInfo::returnValueGPR, false, scratchGPR1, scratchGPR1);
 668             m_jit.addPtr(TrustedImm32(-(sizeof(CallerFrameAndPC) + WTF::roundUpToMultipleOf(stackAlignmentBytes(), 6 * sizeof(void*)))), scratchGPR1, JITCompiler::stackPointerRegister);
 669 
<span class="line-modified"> 670             callOperation(operationSetupVarargsFrame, GPRInfo::returnValueGPR, scratchGPR1, JSValueRegs(argumentsTagGPR, argumentsPayloadGPR), data-&gt;firstVarArgOffset, GPRInfo::returnValueGPR);</span>
 671             m_jit.exceptionCheck();
 672             m_jit.addPtr(TrustedImm32(sizeof(CallerFrameAndPC)), GPRInfo::returnValueGPR, JITCompiler::stackPointerRegister);
 673         }
 674 
 675         DFG_ASSERT(m_jit.graph(), node, isFlushed());
 676 
 677         // We don&#39;t need the arguments array anymore.
 678         if (isVarargs)
 679             use(node-&gt;child3());
 680 
 681         // Now set up the &quot;this&quot; argument.
 682         JSValueOperand thisArgument(this, node-&gt;child2());
 683         GPRReg thisArgumentTagGPR = thisArgument.tagGPR();
 684         GPRReg thisArgumentPayloadGPR = thisArgument.payloadGPR();
 685         thisArgument.use();
 686 
 687         m_jit.store32(thisArgumentTagGPR, JITCompiler::calleeArgumentTagSlot(0));
 688         m_jit.store32(thisArgumentPayloadGPR, JITCompiler::calleeArgumentPayloadSlot(0));
 689     } else {
 690         // The call instruction&#39;s first child is either the function (normal call) or the
</pre>
<hr />
<pre>
 717             calleePayloadGPR = callee.payloadGPR();
 718             if (!isDirect)
 719                 use(calleeEdge);
 720 
 721             shuffleData.numLocals = m_jit.graph().frameRegisterCount();
 722             shuffleData.callee = ValueRecovery::inPair(calleeTagGPR, calleePayloadGPR);
 723             shuffleData.args.resize(numAllocatedArgs);
 724             shuffleData.numPassedArgs = numPassedArgs;
 725 
 726             for (unsigned i = 0; i &lt; numPassedArgs; ++i) {
 727                 Edge argEdge = m_jit.graph().varArgChild(node, i + 1);
 728                 GenerationInfo&amp; info = generationInfo(argEdge.node());
 729                 if (!isDirect)
 730                     use(argEdge);
 731                 shuffleData.args[i] = info.recovery(argEdge-&gt;virtualRegister());
 732             }
 733 
 734             for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
 735                 shuffleData.args[i] = ValueRecovery::constant(jsUndefined());
 736         } else {
<span class="line-modified"> 737             m_jit.store32(MacroAssembler::TrustedImm32(numPassedArgs), m_jit.calleeFramePayloadSlot(CallFrameSlot::argumentCount));</span>
 738 
 739             for (unsigned i = 0; i &lt; numPassedArgs; i++) {
 740                 Edge argEdge = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + 1 + i];
 741                 JSValueOperand arg(this, argEdge);
 742                 GPRReg argTagGPR = arg.tagGPR();
 743                 GPRReg argPayloadGPR = arg.payloadGPR();
 744                 use(argEdge);
 745 
 746                 m_jit.store32(argTagGPR, m_jit.calleeArgumentTagSlot(i));
 747                 m_jit.store32(argPayloadGPR, m_jit.calleeArgumentPayloadSlot(i));
 748             }
 749 
 750             for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
 751                 m_jit.storeTrustedValue(jsUndefined(), JITCompiler::calleeArgumentSlot(i));
 752         }
 753     }
 754 
 755     if (!isTail || isVarargs || isForwardVarargs) {
 756         JSValueOperand callee(this, calleeEdge);
 757         calleeTagGPR = callee.tagGPR();
</pre>
<hr />
<pre>
 787         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 788         // After the calls are done, we need to reestablish our stack
 789         // pointer. We rely on this for varargs calls, calls with arity
 790         // mismatch (the callframe is slided) and tail calls.
 791         m_jit.addPtr(TrustedImm32(m_jit.graph().stackPointerOffset() * sizeof(Register)), GPRInfo::callFrameRegister, JITCompiler::stackPointerRegister);
 792     };
 793 
 794     if (node-&gt;op() == CallEval) {
 795         // We want to call operationCallEval but we don&#39;t want to overwrite the parameter area in
 796         // which we have created a prototypical eval call frame. This means that we have to
 797         // subtract stack to make room for the call. Lucky for us, at this point we have the whole
 798         // register file to ourselves.
 799 
 800         m_jit.emitStoreCallSiteIndex(callSite);
 801         m_jit.addPtr(TrustedImm32(-static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC))), JITCompiler::stackPointerRegister, GPRInfo::regT0);
 802         m_jit.storePtr(GPRInfo::callFrameRegister, JITCompiler::Address(GPRInfo::regT0, CallFrame::callerFrameOffset()));
 803 
 804         // Now we need to make room for:
 805         // - The caller frame and PC of a call to operationCallEval.
 806         // - Potentially two arguments on the stack.
<span class="line-modified"> 807         unsigned requiredBytes = sizeof(CallerFrameAndPC) + sizeof(ExecState*) * 2;</span>
 808         requiredBytes = WTF::roundUpToMultipleOf(stackAlignmentBytes(), requiredBytes);
 809         m_jit.subPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
<span class="line-modified"> 810         m_jit.setupArguments&lt;decltype(operationCallEval)&gt;(GPRInfo::regT0);</span>
 811         prepareForExternalCall();
 812         m_jit.appendCall(operationCallEval);
 813         m_jit.exceptionCheck();
 814         JITCompiler::Jump done = m_jit.branchIfNotEmpty(GPRInfo::returnValueGPR2);
 815 
 816         // This is the part where we meant to make a normal call. Oops.
 817         m_jit.addPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
 818         m_jit.load32(JITCompiler::calleeFrameSlot(CallFrameSlot::callee).withOffset(PayloadOffset), GPRInfo::regT0);
 819         m_jit.load32(JITCompiler::calleeFrameSlot(CallFrameSlot::callee).withOffset(TagOffset), GPRInfo::regT1);
<span class="line-modified"> 820         m_jit.emitDumbVirtualCall(vm(), info);</span>
 821 
 822         done.link(&amp;m_jit);
 823         setResultAndResetStack();
 824         return;
 825     }
 826 
 827     if (isDirect) {
 828         info-&gt;setExecutableDuringCompilation(executable);
<span class="line-modified"> 829         info-&gt;setMaxNumArguments(numAllocatedArgs);</span>
 830 
 831         if (isTail) {
 832             RELEASE_ASSERT(node-&gt;op() == DirectTailCall);
 833 
 834             JITCompiler::PatchableJump patchableJump = m_jit.patchableJump();
 835             JITCompiler::Label mainPath = m_jit.label();
 836 
 837             m_jit.emitStoreCallSiteIndex(callSite);
 838 
 839             info-&gt;setFrameShuffleData(shuffleData);
 840             CallFrameShuffler(m_jit, shuffleData).prepareForTailCall();
 841 
 842             JITCompiler::Call call = m_jit.nearTailCall();
 843 
 844             JITCompiler::Label slowPath = m_jit.label();
 845             patchableJump.m_jump.linkTo(slowPath, &amp;m_jit);
 846 
 847             silentSpillAllRegisters(InvalidGPRReg);
 848             callOperation(operationLinkDirectCall, info, calleePayloadGPR);
 849             silentFillAllRegisters();
 850             m_jit.exceptionCheck();
 851             m_jit.jump().linkTo(mainPath, &amp;m_jit);
 852 
 853             useChildren(node);
 854 
 855             m_jit.addJSDirectTailCall(patchableJump, call, slowPath, info);
 856             return;
 857         }
 858 
 859         JITCompiler::Label mainPath = m_jit.label();
 860 
 861         m_jit.emitStoreCallSiteIndex(callSite);
 862 
 863         JITCompiler::Call call = m_jit.nearCall();
 864         JITCompiler::Jump done = m_jit.jump();
 865 
 866         JITCompiler::Label slowPath = m_jit.label();
<span class="line-removed"> 867         if (isX86())</span>
<span class="line-removed"> 868             m_jit.pop(JITCompiler::selectScratchGPR(calleePayloadGPR));</span>
<span class="line-removed"> 869 </span>
 870         callOperation(operationLinkDirectCall, info, calleePayloadGPR);
 871         m_jit.exceptionCheck();
 872         m_jit.jump().linkTo(mainPath, &amp;m_jit);
 873 
 874         done.link(&amp;m_jit);
 875 
 876         setResultAndResetStack();
 877 
 878         m_jit.addJSDirectCall(call, slowPath, info);
 879         return;
 880     }
 881 
 882     m_jit.emitStoreCallSiteIndex(callSite);
 883 
 884     slowPath.append(m_jit.branchIfNotCell(JSValueRegs(calleeTagGPR, calleePayloadGPR)));
 885     slowPath.append(m_jit.branchPtrWithPatch(MacroAssembler::NotEqual, calleePayloadGPR, targetToCheck));
 886 
 887     if (isTail) {
 888         if (node-&gt;op() == TailCall) {
 889             info-&gt;setFrameShuffleData(shuffleData);
</pre>
<hr />
<pre>
 907         callFrameShuffler.prepareForSlowPath();
 908     } else {
 909         // Callee payload needs to be in regT0, tag in regT1
 910         if (calleeTagGPR == GPRInfo::regT0) {
 911             if (calleePayloadGPR == GPRInfo::regT1)
 912                 m_jit.swap(GPRInfo::regT1, GPRInfo::regT0);
 913             else {
 914                 m_jit.move(calleeTagGPR, GPRInfo::regT1);
 915                 m_jit.move(calleePayloadGPR, GPRInfo::regT0);
 916             }
 917         } else {
 918             m_jit.move(calleePayloadGPR, GPRInfo::regT0);
 919             m_jit.move(calleeTagGPR, GPRInfo::regT1);
 920         }
 921 
 922         if (isTail)
 923             m_jit.emitRestoreCalleeSaves();
 924     }
 925 
 926     m_jit.move(TrustedImmPtr(info), GPRInfo::regT2);

 927     JITCompiler::Call slowCall = m_jit.nearCall();
 928 
 929     done.link(&amp;m_jit);
 930 
 931     if (isTail)
 932         m_jit.abortWithReason(JITDidReturnFromTailCall);
 933     else
 934         setResultAndResetStack();
 935 
 936     m_jit.addJSCall(fastCall, slowCall, targetToCheck, info);
 937 }
 938 
 939 template&lt;bool strict&gt;
 940 GPRReg SpeculativeJIT::fillSpeculateInt32Internal(Edge edge, DataFormat&amp; returnFormat)
 941 {
 942     AbstractValue&amp; value = m_state.forNode(edge);
 943     SpeculatedType type = value.m_type;
 944     ASSERT(edge.useKind() != KnownInt32Use || !(value.m_type &amp; ~SpecInt32Only));
 945 
 946     m_interpreter.filter(value, SpecInt32Only);
</pre>
<hr />
<pre>
1769         m_jit.add32(TrustedImm32(1), propertyReg);
1770         m_jit.store32(propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
1771         m_jit.sub32(TrustedImm32(1), propertyReg);
1772 
1773         inBounds.link(&amp;m_jit);
1774     }
1775 
1776     m_jit.store32(valueTag, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
1777     m_jit.store32(valuePayloadReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
1778 
1779     base.use();
1780     property.use();
1781     value.use();
1782     storage.use();
1783 
1784     if (arrayMode.isOutOfBounds()) {
1785         if (node-&gt;op() == PutByValDirect) {
1786             addSlowPathGenerator(slowPathCall(
1787                 slowCase, this,
1788                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValDirectBeyondArrayBoundsNonStrict,
<span class="line-modified">1789                 NoResult, baseReg, propertyReg, JSValueRegs(valueTag, valuePayloadReg)));</span>
1790         } else {
1791             addSlowPathGenerator(slowPathCall(
1792                 slowCase, this,
1793                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsNonStrict,
<span class="line-modified">1794                 NoResult, baseReg, propertyReg, JSValueRegs(valueTag, valuePayloadReg)));</span>
1795         }
1796     }
1797 
1798     noResult(node, UseChildrenCalledExplicitly);
1799 }
1800 
1801 void SpeculativeJIT::compile(Node* node)
1802 {
1803     NodeType op = node-&gt;op();
1804 
1805 #if ENABLE(DFG_REGISTER_ALLOCATION_VALIDATION)
1806     m_jit.clearRegisterAllocationOffsets();
1807 #endif
1808 
1809     switch (op) {
1810     case JSConstant:
1811     case DoubleConstant:
1812     case PhantomDirectArguments:
1813     case PhantomClonedArguments:
1814         initConstantInfo(node);
1815         break;
1816 
1817     case LazyJSConstant:
1818         compileLazyJSConstant(node);
1819         break;
1820 
1821     case Identity: {
1822         compileIdentity(node);
1823         break;
1824     }
1825 





1826     case GetLocal: {
<span class="line-modified">1827         AbstractValue&amp; value = m_state.operand(node-&gt;local());</span>
1828 
1829         // If the CFA is tracking this variable and it found that the variable
1830         // cannot have been assigned, then don&#39;t attempt to proceed.
1831         if (value.isClear()) {
1832             m_compileOkay = false;
1833             break;
1834         }
1835 
1836         switch (node-&gt;variableAccessData()-&gt;flushFormat()) {
1837         case FlushedDouble: {
1838             FPRTemporary result(this);
1839             m_jit.loadDouble(JITCompiler::addressFor(node-&gt;machineLocal()), result.fpr());
1840             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1841             m_fprs.retain(result.fpr(), virtualRegister, SpillOrderDouble);
1842             generationInfoFromVirtualRegister(virtualRegister).initDouble(node, node-&gt;refCount(), result.fpr());
1843             break;
1844         }
1845 
1846         case FlushedInt32: {
1847             GPRTemporary result(this);
</pre>
<hr />
<pre>
1891             m_gprs.retain(result.gpr(), virtualRegister, SpillOrderJS);
1892             m_gprs.retain(tag.gpr(), virtualRegister, SpillOrderJS);
1893 
1894             generationInfoFromVirtualRegister(virtualRegister).initJSValue(node, node-&gt;refCount(), tag.gpr(), result.gpr(), DataFormatJS);
1895             break;
1896         }
1897 
1898         default:
1899             RELEASE_ASSERT_NOT_REACHED();
1900         }
1901         break;
1902     }
1903 
1904     case MovHint: {
1905         compileMovHint(m_currentNode);
1906         noResult(node);
1907         break;
1908     }
1909 
1910     case ZombieHint: {
<span class="line-modified">1911         recordSetLocal(m_currentNode-&gt;unlinkedLocal(), VirtualRegister(), DataFormatDead);</span>
1912         noResult(node);
1913         break;
1914     }
1915 
1916     case ExitOK: {
1917         noResult(node);
1918         break;
1919     }
1920 
1921     case SetLocal: {
1922         switch (node-&gt;variableAccessData()-&gt;flushFormat()) {
1923         case FlushedDouble: {
1924             SpeculateDoubleOperand value(this, node-&gt;child1());
1925             m_jit.storeDouble(value.fpr(), JITCompiler::addressFor(node-&gt;machineLocal()));
1926             noResult(node);
1927             // Indicate that it&#39;s no longer necessary to retrieve the value of
1928             // this bytecode variable from registers or other locations in the stack,
1929             // but that it is stored as a double.
1930             recordSetLocal(DataFormatDouble);
1931             break;
</pre>
<hr />
<pre>
1988         break;
1989 
1990     case ArithBitAnd:
1991     case ArithBitOr:
1992     case ArithBitXor:
1993         compileBitwiseOp(node);
1994         break;
1995 
1996     case ValueBitNot:
1997         compileValueBitNot(node);
1998         break;
1999 
2000     case ArithBitNot:
2001         compileBitwiseNot(node);
2002         break;
2003 
2004     case ValueBitLShift:
2005         compileValueLShiftOp(node);
2006         break;
2007 
<span class="line-modified">2008     case BitRShift:</span>




2009     case ArithBitLShift:
2010     case BitURShift:
2011         compileShiftOp(node);
2012         break;
2013 
2014     case UInt32ToNumber: {
2015         compileUInt32ToNumber(node);
2016         break;
2017     }
2018 
2019     case DoubleAsInt32: {
2020         compileDoubleAsInt32(node);
2021         break;
2022     }
2023 
2024     case ValueToInt32: {
2025         compileValueToInt32(node);
2026         break;
2027     }
2028 
</pre>
<hr />
<pre>
2193     case SameValue:
2194         compileSameValue(node);
2195         break;
2196 
2197     case StringCharCodeAt: {
2198         compileGetCharCodeAt(node);
2199         break;
2200     }
2201 
2202     case StringCharAt: {
2203         // Relies on StringCharAt node having same basic layout as GetByVal
2204         compileGetByValOnString(node);
2205         break;
2206     }
2207 
2208     case StringFromCharCode: {
2209         compileFromCharCode(node);
2210         break;
2211     }
2212 





2213     case CheckArray: {
2214         checkArray(node);
2215         break;
2216     }
2217 
2218     case Arrayify:
2219     case ArrayifyToStructure: {
2220         arrayify(node);
2221         break;
2222     }
2223 
2224     case GetByVal: {
2225         switch (node-&gt;arrayMode().type()) {
2226         case Array::SelectUsingPredictions:
2227         case Array::ForceExit:
2228             RELEASE_ASSERT_NOT_REACHED();
2229 #if COMPILER_QUIRK(CONSIDERS_UNREACHABLE_CODE)
2230             terminateSpeculativeExecution(InadequateCoverage, JSValueRegs(), 0);
2231 #endif
2232             break;
</pre>
<hr />
<pre>
2234             SpeculateStrictInt32Operand index(this, m_graph.varArgChild(node, 1));
2235             GPRTemporary resultTag(this, Reuse, index);
2236             GPRTemporary resultPayload(this);
2237 
2238             GPRReg indexGPR = index.gpr();
2239             GPRReg resultTagGPR = resultTag.gpr();
2240             GPRReg resultPayloadGPR = resultPayload.gpr();
2241 
2242             speculationCheck(OutOfBounds, JSValueRegs(), node,
2243                 m_jit.branch32(MacroAssembler::LessThan, indexGPR, MacroAssembler::TrustedImm32(0)));
2244 
2245             use(m_graph.varArgChild(node, 0));
2246             index.use();
2247 
2248             m_jit.move(MacroAssembler::TrustedImm32(JSValue::UndefinedTag), resultTagGPR);
2249             m_jit.move(MacroAssembler::TrustedImm32(0), resultPayloadGPR);
2250             jsValueResult(resultTagGPR, resultPayloadGPR, node, UseChildrenCalledExplicitly);
2251             break;
2252         }
2253         case Array::Generic: {
<span class="line-modified">2254             if (m_graph.varArgChild(node, 0).useKind() == ObjectUse) {</span>
<span class="line-modified">2255                 if (m_graph.varArgChild(node, 1).useKind() == StringUse) {</span>
<span class="line-modified">2256                     compileGetByValForObjectWithString(node);</span>
<span class="line-modified">2257                     break;</span>







2258                 }
2259 
<span class="line-modified">2260                 if (m_graph.varArgChild(node, 1).useKind() == SymbolUse) {</span>
<span class="line-modified">2261                     compileGetByValForObjectWithSymbol(node);</span>
<span class="line-modified">2262                     break;</span>
<span class="line-modified">2263                 }</span>









2264             }
2265 
<span class="line-modified">2266             SpeculateCellOperand base(this, m_graph.varArgChild(node, 0)); // Save a register, speculate cell. We&#39;ll probably be right.</span>
<span class="line-modified">2267             JSValueOperand property(this, m_graph.varArgChild(node, 1));</span>
<span class="line-modified">2268             GPRReg baseGPR = base.gpr();</span>






2269             JSValueRegs propertyRegs = property.jsValueRegs();

2270 
<span class="line-modified">2271             flushRegisters();</span>
<span class="line-modified">2272             JSValueRegsFlushedCallResult result(this);</span>
<span class="line-modified">2273             JSValueRegs resultRegs = result.regs();</span>
<span class="line-modified">2274             callOperation(operationGetByValCell, resultRegs, baseGPR, propertyRegs);</span>
<span class="line-modified">2275             m_jit.exceptionCheck();</span>
























2276 
2277             jsValueResult(resultRegs, node);
2278             break;
2279         }
2280         case Array::Int32:
2281         case Array::Contiguous: {
2282             if (node-&gt;arrayMode().isInBounds()) {
2283                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2284                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2285 
2286                 GPRReg propertyReg = property.gpr();
2287                 GPRReg storageReg = storage.gpr();
2288 
2289                 if (!m_compileOkay)
2290                     return;
2291 
2292                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2293 
2294                 GPRTemporary resultPayload(this);
2295                 if (node-&gt;arrayMode().type() == Array::Int32) {
</pre>
<hr />
<pre>
2343 
2344             if (!m_compileOkay)
2345                 return;
2346 
2347             GPRTemporary resultTag(this);
2348             GPRTemporary resultPayload(this);
2349             GPRReg resultTagReg = resultTag.gpr();
2350             GPRReg resultPayloadReg = resultPayload.gpr();
2351 
2352             MacroAssembler::JumpList slowCases;
2353 
2354             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2355 
2356             m_jit.load32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)), resultTagReg);
2357             m_jit.load32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)), resultPayloadReg);
2358             slowCases.append(m_jit.branchIfEmpty(resultTagReg));
2359 
2360             addSlowPathGenerator(
2361                 slowPathCall(
2362                     slowCases, this, operationGetByValObjectInt,
<span class="line-modified">2363                     JSValueRegs(resultTagReg, resultPayloadReg), baseReg, propertyReg));</span>
2364 
2365             jsValueResult(resultTagReg, resultPayloadReg, node);
2366             break;
2367         }
2368         case Array::Double: {
2369             if (node-&gt;arrayMode().isInBounds()) {
2370                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2371                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2372 
2373                 GPRReg propertyReg = property.gpr();
2374                 GPRReg storageReg = storage.gpr();
2375 
2376                 if (!m_compileOkay)
2377                     return;
2378 
2379                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2380 
2381                 FPRTemporary result(this);
2382                 m_jit.loadDouble(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), result.fpr());
2383                 if (!node-&gt;arrayMode().isSaneChain())
</pre>
<hr />
<pre>
2398                 return;
2399 
2400             GPRTemporary resultTag(this);
2401             GPRTemporary resultPayload(this);
2402             FPRTemporary temp(this);
2403             GPRReg resultTagReg = resultTag.gpr();
2404             GPRReg resultPayloadReg = resultPayload.gpr();
2405             FPRReg tempReg = temp.fpr();
2406 
2407             MacroAssembler::JumpList slowCases;
2408 
2409             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2410 
2411             m_jit.loadDouble(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), tempReg);
2412             slowCases.append(m_jit.branchIfNaN(tempReg));
2413             boxDouble(tempReg, resultTagReg, resultPayloadReg);
2414 
2415             addSlowPathGenerator(
2416                 slowPathCall(
2417                     slowCases, this, operationGetByValObjectInt,
<span class="line-modified">2418                     JSValueRegs(resultTagReg, resultPayloadReg), baseReg, propertyReg));</span>
2419 
2420             jsValueResult(resultTagReg, resultPayloadReg, node);
2421             break;
2422         }
2423         case Array::ArrayStorage:
2424         case Array::SlowPutArrayStorage: {
2425             if (node-&gt;arrayMode().isInBounds()) {
2426                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2427                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2428                 GPRReg propertyReg = property.gpr();
2429                 GPRReg storageReg = storage.gpr();
2430 
2431                 if (!m_compileOkay)
2432                     return;
2433 
2434                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::vectorLengthOffset())));
2435 
2436                 GPRTemporary resultTag(this);
2437                 GPRTemporary resultPayload(this);
2438 
</pre>
<hr />
<pre>
2456 
2457             GPRTemporary resultTag(this);
2458             GPRTemporary resultPayload(this);
2459             GPRReg resultTagReg = resultTag.gpr();
2460             GPRReg resultPayloadReg = resultPayload.gpr();
2461 
2462             JITCompiler::Jump outOfBounds = m_jit.branch32(
2463                 MacroAssembler::AboveOrEqual, propertyReg,
2464                 MacroAssembler::Address(storageReg, ArrayStorage::vectorLengthOffset()));
2465 
2466             m_jit.load32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), resultTagReg);
2467             JITCompiler::Jump hole = m_jit.branchIfEmpty(resultTag.gpr());
2468             m_jit.load32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)), resultPayloadReg);
2469 
2470             JITCompiler::JumpList slowCases;
2471             slowCases.append(outOfBounds);
2472             slowCases.append(hole);
2473             addSlowPathGenerator(
2474                 slowPathCall(
2475                     slowCases, this, operationGetByValObjectInt,
<span class="line-modified">2476                     JSValueRegs(resultTagReg, resultPayloadReg),</span>
2477                     baseReg, propertyReg));
2478 
2479             jsValueResult(resultTagReg, resultPayloadReg, node);
2480             break;
2481         }
2482         case Array::String:
2483             compileGetByValOnString(node);
2484             break;
2485         case Array::DirectArguments:
2486             compileGetByValOnDirectArguments(node);
2487             break;
2488         case Array::ScopedArguments:
2489             compileGetByValOnScopedArguments(node);
2490             break;
2491         default: {
2492             TypedArrayType type = node-&gt;arrayMode().typedArrayType();
2493             if (isInt(type))
2494                 compileGetByValOnIntTypedArray(node, type);
2495             else
2496                 compileGetByValOnFloatTypedArray(node, type);
</pre>
<hr />
<pre>
2552                     alreadyHandled = true;
2553                     break;
2554                 }
2555 
2556                 if (child2.useKind() == SymbolUse) {
2557                     compilePutByValForCellWithSymbol(node, child1, child2, child3);
2558                     alreadyHandled = true;
2559                     break;
2560                 }
2561             }
2562 
2563             SpeculateCellOperand base(this, child1); // Save a register, speculate cell. We&#39;ll probably be right.
2564             JSValueOperand property(this, child2);
2565             JSValueOperand value(this, child3);
2566             GPRReg baseGPR = base.gpr();
2567             JSValueRegs propertyRegs = property.jsValueRegs();
2568             JSValueRegs valueRegs = value.jsValueRegs();
2569 
2570             flushRegisters();
2571             if (node-&gt;op() == PutByValDirect)
<span class="line-modified">2572                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectCellStrict : operationPutByValDirectCellNonStrict, baseGPR, propertyRegs, valueRegs);</span>
2573             else
<span class="line-modified">2574                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellStrict : operationPutByValCellNonStrict, baseGPR, propertyRegs, valueRegs);</span>
2575             m_jit.exceptionCheck();
2576 
2577             noResult(node);
2578             alreadyHandled = true;
2579             break;
2580         }
2581         default:
2582             break;
2583         }
2584 
2585         if (alreadyHandled)
2586             break;
2587 
2588         SpeculateCellOperand base(this, child1);
2589         SpeculateStrictInt32Operand property(this, child2);
2590 
2591         GPRReg baseReg = base.gpr();
2592         GPRReg propertyReg = property.gpr();
2593 
2594         switch (arrayMode.type()) {
</pre>
<hr />
<pre>
2666 
2667                     lengthDoesNotNeedUpdate.link(&amp;m_jit);
2668                 }
2669                 notHoleValue.link(&amp;m_jit);
2670             }
2671 
2672             // Store the value to the array.
2673             m_jit.store32(valueTagReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
2674             m_jit.store32(valuePayloadReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
2675 
2676             base.use();
2677             property.use();
2678             value.use();
2679             storage.use();
2680 
2681             if (!slowCases.empty()) {
2682                 if (node-&gt;op() == PutByValDirect) {
2683                     addSlowPathGenerator(slowPathCall(
2684                         slowCases, this,
2685                         m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValDirectBeyondArrayBoundsNonStrict,
<span class="line-modified">2686                         NoResult, baseReg, propertyReg, JSValueRegs(valueTagReg, valuePayloadReg)));</span>
2687                 } else {
2688                     addSlowPathGenerator(slowPathCall(
2689                         slowCases, this,
2690                         m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsNonStrict,
<span class="line-modified">2691                         NoResult, baseReg, propertyReg, JSValueRegs(valueTagReg, valuePayloadReg)));</span>
2692                 }
2693             }
2694 
2695             noResult(node, UseChildrenCalledExplicitly);
2696             break;
2697         }
2698 
2699         default: {
2700             TypedArrayType type = arrayMode.typedArrayType();
2701             if (isInt(type))
2702                 compilePutByValForIntTypedArray(base.gpr(), property.gpr(), node, type);
2703             else
2704                 compilePutByValForFloatTypedArray(base.gpr(), property.gpr(), node, type);
2705         } }
2706         break;
2707     }
2708 
2709     case PutByValWithThis: {
<span class="line-removed">2710 #if CPU(X86)</span>
<span class="line-removed">2711         // We don&#39;t have enough registers on X86 to do this</span>
<span class="line-removed">2712         // without setting up the call frame incrementally.</span>
<span class="line-removed">2713         unsigned index = 0;</span>
<span class="line-removed">2714         m_jit.poke(GPRInfo::callFrameRegister, index++);</span>
<span class="line-removed">2715 </span>
<span class="line-removed">2716         {</span>
<span class="line-removed">2717             JSValueOperand base(this, m_jit.graph().varArgChild(node, 0));</span>
<span class="line-removed">2718             GPRReg baseTag = base.tagGPR();</span>
<span class="line-removed">2719             GPRReg basePayload = base.payloadGPR();</span>
<span class="line-removed">2720 </span>
<span class="line-removed">2721             JSValueOperand thisValue(this, m_jit.graph().varArgChild(node, 1));</span>
<span class="line-removed">2722             GPRReg thisValueTag = thisValue.tagGPR();</span>
<span class="line-removed">2723             GPRReg thisValuePayload = thisValue.payloadGPR();</span>
<span class="line-removed">2724 </span>
<span class="line-removed">2725             JSValueOperand property(this, m_jit.graph().varArgChild(node, 2));</span>
<span class="line-removed">2726             GPRReg propertyTag = property.tagGPR();</span>
<span class="line-removed">2727             GPRReg propertyPayload = property.payloadGPR();</span>
<span class="line-removed">2728 </span>
<span class="line-removed">2729             m_jit.poke(basePayload, index++);</span>
<span class="line-removed">2730             m_jit.poke(baseTag, index++);</span>
<span class="line-removed">2731 </span>
<span class="line-removed">2732             m_jit.poke(thisValuePayload, index++);</span>
<span class="line-removed">2733             m_jit.poke(thisValueTag, index++);</span>
<span class="line-removed">2734 </span>
<span class="line-removed">2735             m_jit.poke(propertyPayload, index++);</span>
<span class="line-removed">2736             m_jit.poke(propertyTag, index++);</span>
<span class="line-removed">2737 </span>
<span class="line-removed">2738             flushRegisters();</span>
<span class="line-removed">2739         }</span>
<span class="line-removed">2740 </span>
<span class="line-removed">2741         JSValueOperand value(this, m_jit.graph().varArgChild(node, 3));</span>
<span class="line-removed">2742         GPRReg valueTag = value.tagGPR();</span>
<span class="line-removed">2743         GPRReg valuePayload = value.payloadGPR();</span>
<span class="line-removed">2744         m_jit.poke(valuePayload, index++);</span>
<span class="line-removed">2745         m_jit.poke(valueTag, index++);</span>
<span class="line-removed">2746 </span>
<span class="line-removed">2747         flushRegisters();</span>
<span class="line-removed">2748         appendCall(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValWithThisStrict : operationPutByValWithThis);</span>
<span class="line-removed">2749         m_jit.exceptionCheck();</span>
<span class="line-removed">2750 #else</span>
2751         static_assert(GPRInfo::numberOfRegisters &gt;= 8, &quot;We are assuming we have enough registers to make this call without incrementally setting up the arguments.&quot;);
2752 
2753         JSValueOperand base(this, m_jit.graph().varArgChild(node, 0));
2754         JSValueRegs baseRegs = base.jsValueRegs();
2755 
2756         JSValueOperand thisValue(this, m_jit.graph().varArgChild(node, 1));
2757         JSValueRegs thisRegs = thisValue.jsValueRegs();
2758 
2759         JSValueOperand property(this, m_jit.graph().varArgChild(node, 2));
2760         JSValueRegs propertyRegs = property.jsValueRegs();
2761 
2762         JSValueOperand value(this, m_jit.graph().varArgChild(node, 3));
2763         JSValueRegs valueRegs = value.jsValueRegs();
2764 
2765         flushRegisters();
2766         callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValWithThisStrict : operationPutByValWithThis,
<span class="line-modified">2767             NoResult, baseRegs, thisRegs, propertyRegs, valueRegs);</span>
2768         m_jit.exceptionCheck();
<span class="line-removed">2769 #endif // CPU(X86)</span>
2770 
2771         noResult(node);
2772         break;
2773     }
2774 
2775     case RegExpExec: {
2776         compileRegExpExec(node);
2777         break;
2778     }
2779 
2780     case RegExpExecNonGlobalOrSticky: {
2781         compileRegExpExecNonGlobalOrSticky(node);
2782         break;
2783     }
2784 
2785     case RegExpMatchFastGlobal: {
2786         compileRegExpMatchFastGlobal(node);
2787         break;
2788     }
2789 
</pre>
<hr />
<pre>
2848                 valuePayloadGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
2849             m_jit.load32(
2850                 MacroAssembler::BaseIndex(storageGPR, valuePayloadGPR, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)),
2851                 valueTagGPR);
2852             MacroAssembler::Jump slowCase = m_jit.branchIfEmpty(valueTagGPR);
2853             m_jit.store32(
2854                 MacroAssembler::TrustedImm32(JSValue::EmptyValueTag),
2855                 MacroAssembler::BaseIndex(storageGPR, valuePayloadGPR, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
2856             m_jit.load32(
2857                 MacroAssembler::BaseIndex(storageGPR, valuePayloadGPR, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)),
2858                 valuePayloadGPR);
2859 
2860             addSlowPathGenerator(
2861                 slowPathMove(
2862                     undefinedCase, this,
2863                     MacroAssembler::TrustedImm32(jsUndefined().tag()), valueTagGPR,
2864                     MacroAssembler::TrustedImm32(jsUndefined().payload()), valuePayloadGPR));
2865             addSlowPathGenerator(
2866                 slowPathCall(
2867                     slowCase, this, operationArrayPopAndRecoverLength,
<span class="line-modified">2868                     JSValueRegs(valueTagGPR, valuePayloadGPR), baseGPR));</span>
2869 
2870             jsValueResult(valueTagGPR, valuePayloadGPR, node);
2871             break;
2872         }
2873 
2874         case Array::Double: {
2875             FPRTemporary temp(this);
2876             FPRReg tempFPR = temp.fpr();
2877 
2878             m_jit.load32(
2879                 MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), valuePayloadGPR);
2880             MacroAssembler::Jump undefinedCase =
2881                 m_jit.branchTest32(MacroAssembler::Zero, valuePayloadGPR);
2882             m_jit.sub32(TrustedImm32(1), valuePayloadGPR);
2883             m_jit.store32(
2884                 valuePayloadGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
2885             m_jit.loadDouble(
2886                 MacroAssembler::BaseIndex(storageGPR, valuePayloadGPR, MacroAssembler::TimesEight),
2887                 tempFPR);
2888             MacroAssembler::Jump slowCase = m_jit.branchIfNaN(tempFPR);
2889             JSValue nan = JSValue(JSValue::EncodeAsDouble, PNaN);
2890             m_jit.store32(
2891                 MacroAssembler::TrustedImm32(nan.u.asBits.tag),
2892                 MacroAssembler::BaseIndex(storageGPR, valuePayloadGPR, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
2893             m_jit.store32(
2894                 MacroAssembler::TrustedImm32(nan.u.asBits.payload),
2895                 MacroAssembler::BaseIndex(storageGPR, valuePayloadGPR, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
2896             boxDouble(tempFPR, valueTagGPR, valuePayloadGPR);
2897 
2898             addSlowPathGenerator(
2899                 slowPathMove(
2900                     undefinedCase, this,
2901                     MacroAssembler::TrustedImm32(jsUndefined().tag()), valueTagGPR,
2902                     MacroAssembler::TrustedImm32(jsUndefined().payload()), valuePayloadGPR));
2903             addSlowPathGenerator(
2904                 slowPathCall(
2905                     slowCase, this, operationArrayPopAndRecoverLength,
<span class="line-modified">2906                     JSValueRegs(valueTagGPR, valuePayloadGPR), baseGPR));</span>
2907 
2908             jsValueResult(valueTagGPR, valuePayloadGPR, node);
2909             break;
2910         }
2911 
2912         case Array::ArrayStorage: {
2913             GPRTemporary storageLength(this);
2914             GPRReg storageLengthGPR = storageLength.gpr();
2915 
2916             m_jit.load32(MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()), storageLengthGPR);
2917 
2918             JITCompiler::JumpList setUndefinedCases;
2919             setUndefinedCases.append(m_jit.branchTest32(MacroAssembler::Zero, storageLengthGPR));
2920 
2921             m_jit.sub32(TrustedImm32(1), storageLengthGPR);
2922 
2923             MacroAssembler::Jump slowCase = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::vectorLengthOffset()));
2924 
2925             m_jit.load32(MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), valueTagGPR);
2926             m_jit.load32(MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)), valuePayloadGPR);
2927 
2928             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()));
2929 
2930             setUndefinedCases.append(m_jit.branchIfEmpty(valueTagGPR));
2931 
2932             m_jit.store32(TrustedImm32(JSValue::EmptyValueTag), MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
2933 
2934             m_jit.sub32(TrustedImm32(1), MacroAssembler::Address(storageGPR, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
2935 
2936             addSlowPathGenerator(
2937                 slowPathMove(
2938                     setUndefinedCases, this,
2939                     MacroAssembler::TrustedImm32(jsUndefined().tag()), valueTagGPR,
2940                     MacroAssembler::TrustedImm32(jsUndefined().payload()), valuePayloadGPR));
2941 
2942             addSlowPathGenerator(
2943                 slowPathCall(
2944                     slowCase, this, operationArrayPop,
<span class="line-modified">2945                     JSValueRegs(valueTagGPR, valuePayloadGPR), baseGPR));</span>
2946 
2947             jsValueResult(valueTagGPR, valuePayloadGPR, node);
2948             break;
2949         }
2950 
2951         default:
2952             CRASH();
2953             break;
2954         }
2955         break;
2956     }
2957 
2958     case ArraySlice: {
2959         compileArraySlice(node);
2960         break;
2961     }
2962 
2963     case ArrayIndexOf: {
2964         compileArrayIndexOf(node);
2965         break;
</pre>
<hr />
<pre>
3060             isBoolean.link(&amp;m_jit);
3061             m_jit.move(TrustedImm32(JSValue::Int32Tag), resultTagGPR);
3062             done.link(&amp;m_jit);
3063 
3064             jsValueResult(resultTagGPR, resultPayloadGPR, node);
3065             break;
3066         }
3067 
3068         default:
3069             RELEASE_ASSERT_NOT_REACHED();
3070             break;
3071         }
3072         break;
3073     }
3074 
3075     case ToPrimitive: {
3076         compileToPrimitive(node);
3077         break;
3078     }
3079 





3080     case ToNumber: {
3081         JSValueOperand argument(this, node-&gt;child1());
3082         GPRTemporary resultTag(this, Reuse, argument, TagWord);
3083         GPRTemporary resultPayload(this, Reuse, argument, PayloadWord);
3084 
3085         GPRReg argumentPayloadGPR = argument.payloadGPR();
3086         GPRReg argumentTagGPR = argument.tagGPR();
3087         JSValueRegs argumentRegs = argument.jsValueRegs();
3088         JSValueRegs resultRegs(resultTag.gpr(), resultPayload.gpr());
3089 
3090         argument.use();
3091 
3092         // We have several attempts to remove ToNumber. But ToNumber still exists.
3093         // It means that converting non-numbers to numbers by this ToNumber is not rare.
3094         // Instead of the slow path generator, we emit callOperation here.
3095         if (!(m_state.forNode(node-&gt;child1()).m_type &amp; SpecBytecodeNumber)) {
3096             flushRegisters();
<span class="line-modified">3097             callOperation(operationToNumber, resultRegs, argumentRegs);</span>
3098             m_jit.exceptionCheck();
3099         } else {
3100             MacroAssembler::Jump notNumber;
3101             {
3102                 GPRTemporary scratch(this);
3103                 notNumber = m_jit.branchIfNotNumber(argument.jsValueRegs(), scratch.gpr());
3104             }
3105             m_jit.move(argumentTagGPR, resultRegs.tagGPR());
3106             m_jit.move(argumentPayloadGPR, resultRegs.payloadGPR());
3107             MacroAssembler::Jump done = m_jit.jump();
3108 
3109             notNumber.link(&amp;m_jit);
3110             silentSpillAllRegisters(resultRegs);
<span class="line-modified">3111             callOperation(operationToNumber, resultRegs, argumentRegs);</span>
3112             silentFillAllRegisters();
3113             m_jit.exceptionCheck();
3114 
3115             done.link(&amp;m_jit);
3116         }
3117 
3118         jsValueResult(resultRegs.tagGPR(), resultRegs.payloadGPR(), node, UseChildrenCalledExplicitly);
3119         break;
3120     }
3121 





3122     case ToString:
3123     case CallStringConstructor:
3124     case StringValueOf: {
3125         compileToStringOrCallStringConstructorOrStringValueOf(node);
3126         break;
3127     }
3128 
3129     case NewStringObject: {
3130         compileNewStringObject(node);
3131         break;
3132     }
3133 
3134     case NewSymbol: {
3135         compileNewSymbol(node);
3136         break;
3137     }
3138 
3139     case NewArray: {
3140         compileNewArray(node);
3141         break;
</pre>
<hr />
<pre>
3180     case ToThis: {
3181         compileToThis(node);
3182         break;
3183     }
3184 
3185     case ObjectCreate: {
3186         compileObjectCreate(node);
3187         break;
3188     }
3189 
3190     case ObjectKeys: {
3191         compileObjectKeys(node);
3192         break;
3193     }
3194 
3195     case CreateThis: {
3196         compileCreateThis(node);
3197         break;
3198     }
3199 















3200     case NewObject: {
3201         compileNewObject(node);
3202         break;
3203     }
3204 




















3205     case GetCallee: {
3206         compileGetCallee(node);
3207         break;
3208     }
3209 
3210     case SetCallee: {
3211         compileSetCallee(node);
3212         break;
3213     }
3214 
3215     case GetArgumentCountIncludingThis: {
3216         compileGetArgumentCountIncludingThis(node);
3217         break;
3218     }
3219 
3220     case SetArgumentCountIncludingThis:
3221         compileSetArgumentCountIncludingThis(node);
3222         break;
3223 
3224     case GetScope:
</pre>
<hr />
<pre>
3230         break;
3231 
3232     case GetGlobalObject:
3233         compileGetGlobalObject(node);
3234         break;
3235 
3236     case GetGlobalThis:
3237         compileGetGlobalThis(node);
3238         break;
3239 
3240     case GetClosureVar: {
3241         compileGetClosureVar(node);
3242         break;
3243     }
3244 
3245     case PutClosureVar: {
3246         compilePutClosureVar(node);
3247         break;
3248     }
3249 










3250     case TryGetById: {
<span class="line-modified">3251         compileGetById(node, AccessType::TryGet);</span>
3252         break;
3253     }
3254 
3255     case GetByIdDirect: {
<span class="line-modified">3256         compileGetById(node, AccessType::GetDirect);</span>
3257         break;
3258     }
3259 
3260     case GetByIdDirectFlush: {
<span class="line-modified">3261         compileGetByIdFlush(node, AccessType::GetDirect);</span>
3262         break;
3263     }
3264 
3265     case GetById: {
<span class="line-modified">3266         compileGetById(node, AccessType::Get);</span>
3267         break;
3268     }
3269 
3270     case GetByIdFlush: {
<span class="line-modified">3271         compileGetByIdFlush(node, AccessType::Get);</span>
3272         break;
3273     }
3274 
3275     case GetByIdWithThis: {
3276         if (node-&gt;child1().useKind() == CellUse &amp;&amp; node-&gt;child2().useKind() == CellUse) {
3277             SpeculateCellOperand base(this, node-&gt;child1());
3278             SpeculateCellOperand thisValue(this, node-&gt;child2());
3279             GPRTemporary resultTag(this);
3280             GPRTemporary resultPayload(this);
3281 
3282             GPRReg baseGPR = base.gpr();
3283             GPRReg thisGPR = thisValue.gpr();
3284             GPRReg resultTagGPR = resultTag.gpr();
3285             GPRReg resultPayloadGPR = resultPayload.gpr();
3286 
3287             cachedGetByIdWithThis(node-&gt;origin.semantic, InvalidGPRReg, baseGPR, InvalidGPRReg, thisGPR, resultTagGPR, resultPayloadGPR, node-&gt;identifierNumber());
3288 
3289             jsValueResult(resultTagGPR, resultPayloadGPR, node);
3290         } else {
3291             JSValueOperand base(this, node-&gt;child1());
</pre>
<hr />
<pre>
3319     case DeleteById: {
3320         compileDeleteById(node);
3321         break;
3322     }
3323 
3324     case DeleteByVal: {
3325         compileDeleteByVal(node);
3326         break;
3327     }
3328 
3329     case CheckCell: {
3330         compileCheckCell(node);
3331         break;
3332     }
3333 
3334     case CheckNotEmpty: {
3335         compileCheckNotEmpty(node);
3336         break;
3337     }
3338 
<span class="line-modified">3339     case CheckStringIdent:</span>
<span class="line-modified">3340         compileCheckStringIdent(node);</span>
3341         break;
3342 
3343     case GetExecutable: {
3344         compileGetExecutable(node);
3345         break;
3346     }
3347 
3348     case CheckStructure: {
3349         compileCheckStructure(node);
3350         break;
3351     }
3352 
3353     case PutStructure: {
3354         RegisteredStructure oldStructure = node-&gt;transition()-&gt;previous;
3355         RegisteredStructure newStructure = node-&gt;transition()-&gt;next;
3356 
3357         m_jit.jitCode()-&gt;common.notifyCompilingStructureTransition(m_jit.graph().m_plan, m_jit.codeBlock(), node);
3358 
3359         SpeculateCellOperand base(this, node-&gt;child1());
3360         GPRReg baseGPR = base.gpr();
</pre>
<hr />
<pre>
3604         booleanResult(result.gpr(), node);
3605         break;
3606     }
3607 
3608     case IsNumber: {
3609         JSValueOperand value(this, node-&gt;child1());
3610         GPRTemporary result(this, Reuse, value, TagWord);
3611 
3612         m_jit.add32(TrustedImm32(1), value.tagGPR(), result.gpr());
3613         m_jit.compare32(JITCompiler::Below, result.gpr(), JITCompiler::TrustedImm32(JSValue::LowestTag + 1), result.gpr());
3614         booleanResult(result.gpr(), node);
3615         break;
3616     }
3617 
3618     case NumberIsInteger: {
3619         JSValueOperand input(this, node-&gt;child1());
3620         JSValueRegs inputRegs = input.jsValueRegs();
3621         flushRegisters();
3622         GPRFlushedCallResult result(this);
3623         GPRReg resultGPR = result.gpr();
<span class="line-modified">3624         callOperation(operationNumberIsInteger, resultGPR, inputRegs);</span>
3625         booleanResult(resultGPR, node);
3626         break;
3627     }
3628 
3629     case IsObject: {
3630         compileIsObject(node);
3631         break;
3632     }
3633 
3634     case IsObjectOrNull: {
3635         compileIsObjectOrNull(node);
3636         break;
3637     }
3638 
3639     case IsFunction: {
3640         compileIsFunction(node);
3641         break;
3642     }
3643 
3644     case IsCellWithType: {
</pre>
<hr />
<pre>
3647     }
3648 
3649     case IsTypedArrayView: {
3650         compileIsTypedArrayView(node);
3651         break;
3652     }
3653 
3654     case TypeOf: {
3655         compileTypeOf(node);
3656         break;
3657     }
3658 
3659     case MapHash: {
3660         JSValueOperand input(this, node-&gt;child1());
3661 
3662         JSValueRegs inputRegs = input.jsValueRegs();
3663 
3664         flushRegisters();
3665         GPRFlushedCallResult result(this);
3666         GPRReg resultGPR = result.gpr();
<span class="line-modified">3667         callOperation(operationMapHash, resultGPR, inputRegs);</span>
3668         m_jit.exceptionCheck();
3669         int32Result(resultGPR, node);
3670         break;
3671     }
3672 
3673     case NormalizeMapKey: {
3674         compileNormalizeMapKey(node);
3675         break;
3676     }
3677 
3678     case GetMapBucket: {
3679         SpeculateCellOperand map(this, node-&gt;child1());
3680         JSValueOperand key(this, node-&gt;child2());
3681         SpeculateInt32Operand hash(this, node-&gt;child3());
3682 
3683         GPRReg mapGPR = map.gpr();
3684         JSValueRegs keyRegs = key.jsValueRegs();
3685         GPRReg hashGPR = hash.gpr();
3686 
3687         if (node-&gt;child1().useKind() == MapObjectUse)
3688             speculateMapObject(node-&gt;child1(), mapGPR);
3689         else if (node-&gt;child1().useKind() == SetObjectUse)
3690             speculateSetObject(node-&gt;child1(), mapGPR);
3691         else
3692             RELEASE_ASSERT_NOT_REACHED();
3693 
3694         flushRegisters();
3695         GPRFlushedCallResult result(this);
3696         GPRReg resultGPR = result.gpr();
3697         if (node-&gt;child1().useKind() == MapObjectUse)
<span class="line-modified">3698             callOperation(operationJSMapFindBucket, resultGPR, mapGPR, keyRegs, hashGPR);</span>
3699         else
<span class="line-modified">3700             callOperation(operationJSSetFindBucket, resultGPR, mapGPR, keyRegs, hashGPR);</span>
3701         m_jit.exceptionCheck();
3702         cellResult(resultGPR, node);
3703         break;
3704     }
3705 
3706     case GetMapBucketHead:
3707         compileGetMapBucketHead(node);
3708         break;
3709 
3710     case GetMapBucketNext:
3711         compileGetMapBucketNext(node);
3712         break;
3713 
3714     case LoadKeyFromMapBucket:
3715         compileLoadKeyFromMapBucket(node);
3716         break;
3717 
3718     case LoadValueFromMapBucket:
3719         compileLoadValueFromMapBucket(node);
3720         break;
</pre>
<hr />
<pre>
3749     case Call:
3750     case TailCall:
3751     case TailCallInlinedCaller:
3752     case Construct:
3753     case CallVarargs:
3754     case TailCallVarargs:
3755     case TailCallVarargsInlinedCaller:
3756     case ConstructVarargs:
3757     case CallForwardVarargs:
3758     case TailCallForwardVarargs:
3759     case TailCallForwardVarargsInlinedCaller:
3760     case ConstructForwardVarargs:
3761     case CallEval:
3762     case DirectCall:
3763     case DirectConstruct:
3764     case DirectTailCall:
3765     case DirectTailCallInlinedCaller:
3766         emitCall(node);
3767         break;
3768 





3769     case LoadVarargs: {
3770         compileLoadVarargs(node);
3771         break;
3772     }
3773 
3774     case ForwardVarargs: {
3775         compileForwardVarargs(node);
3776         break;
3777     }
3778 
3779     case CreateActivation: {
3780         compileCreateActivation(node);
3781         break;
3782     }
3783 
3784     case PushWithScope: {
3785         compilePushWithScope(node);
3786         break;
3787     }
3788 
</pre>
<hr />
<pre>
3799     case PutToArguments: {
3800         compilePutToArguments(node);
3801         break;
3802     }
3803 
3804     case GetArgument: {
3805         compileGetArgument(node);
3806         break;
3807     }
3808 
3809     case CreateScopedArguments: {
3810         compileCreateScopedArguments(node);
3811         break;
3812     }
3813 
3814     case CreateClonedArguments: {
3815         compileCreateClonedArguments(node);
3816         break;
3817     }
3818 





3819     case CreateRest: {
3820         compileCreateRest(node);
3821         break;
3822     }
3823 
3824     case GetRestLength: {
3825         compileGetRestLength(node);
3826         break;
3827     }
3828 
3829     case NewFunction:
3830     case NewGeneratorFunction:
3831     case NewAsyncFunction:
3832     case NewAsyncGeneratorFunction:
3833         compileNewFunction(node);
3834         break;
3835 
3836     case SetFunctionName:
3837         compileSetFunctionName(node);
3838         break;
3839 
3840     case InById:
3841         compileInById(node);
3842         break;
3843 
3844     case InByVal:
3845         compileInByVal(node);
3846         break;
3847 
3848     case HasOwnProperty: {
<span class="line-removed">3849 #if CPU(X86)</span>
<span class="line-removed">3850         ASSERT(node-&gt;child2().useKind() == UntypedUse);</span>
<span class="line-removed">3851         SpeculateCellOperand object(this, node-&gt;child1());</span>
<span class="line-removed">3852         JSValueOperand key(this, node-&gt;child2());</span>
<span class="line-removed">3853         GPRTemporary result(this, Reuse, object);</span>
<span class="line-removed">3854 </span>
<span class="line-removed">3855         JSValueRegs keyRegs = key.jsValueRegs();</span>
<span class="line-removed">3856         GPRReg objectGPR = object.gpr();</span>
<span class="line-removed">3857         GPRReg resultGPR = result.gpr();</span>
<span class="line-removed">3858 </span>
<span class="line-removed">3859         speculateObject(node-&gt;child1());</span>
<span class="line-removed">3860 </span>
<span class="line-removed">3861         flushRegisters();</span>
<span class="line-removed">3862         callOperation(operationHasOwnProperty, resultGPR, objectGPR, keyRegs);</span>
<span class="line-removed">3863         booleanResult(resultGPR, node);</span>
<span class="line-removed">3864 #else</span>
3865         SpeculateCellOperand object(this, node-&gt;child1());
3866         GPRTemporary uniquedStringImpl(this);
3867         GPRTemporary temp(this);
3868         GPRTemporary hash(this);
3869         GPRTemporary structureID(this);
3870         GPRTemporary result(this);
3871 
3872         Optional&lt;SpeculateCellOperand&gt; keyAsCell;
3873         Optional&lt;JSValueOperand&gt; keyAsValue;
3874         JSValueRegs keyRegs;
3875         if (node-&gt;child2().useKind() == UntypedUse) {
3876             keyAsValue.emplace(this, node-&gt;child2());
3877             keyRegs = keyAsValue-&gt;jsValueRegs();
3878         } else {
3879             ASSERT(node-&gt;child2().useKind() == StringUse || node-&gt;child2().useKind() == SymbolUse);
3880             keyAsCell.emplace(this, node-&gt;child2());
3881             keyRegs = JSValueRegs::payloadOnly(keyAsCell-&gt;gpr());
3882         }
3883 
3884         GPRReg objectGPR = object.gpr();
</pre>
<hr />
<pre>
3937         m_jit.urshift32(MacroAssembler::TrustedImm32(StringImpl::s_flagCount), hashGPR);
3938         m_jit.load32(MacroAssembler::Address(objectGPR, JSCell::structureIDOffset()), structureIDGPR);
3939         m_jit.add32(structureIDGPR, hashGPR);
3940         m_jit.and32(TrustedImm32(HasOwnPropertyCache::mask), hashGPR);
3941         m_jit.mul32(TrustedImm32(sizeof(HasOwnPropertyCache::Entry)), hashGPR, hashGPR);
3942         ASSERT(vm().hasOwnPropertyCache());
3943         m_jit.move(TrustedImmPtr(vm().hasOwnPropertyCache()), tempGPR);
3944         slowPath.append(m_jit.branchPtr(MacroAssembler::NotEqual,
3945             MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfImpl()), implGPR));
3946         m_jit.load8(MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfResult()), resultGPR);
3947         m_jit.load32(MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfStructureID()), tempGPR);
3948         slowPath.append(m_jit.branch32(MacroAssembler::NotEqual, tempGPR, structureIDGPR));
3949         auto done = m_jit.jump();
3950 
3951         slowPath.link(&amp;m_jit);
3952         silentSpillAllRegisters(resultGPR);
3953         if (node-&gt;child2().useKind() != UntypedUse) {
3954             m_jit.move(MacroAssembler::TrustedImm32(JSValue::CellTag), tempGPR);
3955             keyRegs = JSValueRegs(tempGPR, keyRegs.payloadGPR());
3956         }
<span class="line-modified">3957         callOperation(operationHasOwnProperty, resultGPR, objectGPR, keyRegs);</span>
3958         silentFillAllRegisters();
3959         m_jit.exceptionCheck();
3960 
3961         done.link(&amp;m_jit);
3962         booleanResult(resultGPR, node);
<span class="line-removed">3963 #endif // CPU(X86)</span>
3964         break;
3965     }
3966 
3967     case StoreBarrier:
3968     case FencedStoreBarrier: {
3969         compileStoreBarrier(node);
3970         break;
3971     }
3972 
3973     case GetEnumerableLength: {
3974         compileGetEnumerableLength(node);
3975         break;
3976     }
3977     case HasGenericProperty: {
3978         compileHasGenericProperty(node);
3979         break;
3980     }
3981     case HasStructureProperty: {
3982         compileHasStructureProperty(node);
3983         break;
</pre>
<hr />
<pre>
4099         compileCheckSubClass(node);
4100         break;
4101 
4102     case Unreachable:
4103         unreachable(node);
4104         break;
4105 
4106     case ExtractCatchLocal: {
4107         compileExtractCatchLocal(node);
4108         break;
4109     }
4110 
4111     case ClearCatchLocals:
4112         compileClearCatchLocals(node);
4113         break;
4114 
4115     case CheckStructureOrEmpty:
4116         DFG_CRASH(m_jit.graph(), node, &quot;CheckStructureOrEmpty only used in 64-bit DFG&quot;);
4117         break;
4118 




4119     case FilterCallLinkStatus:
<span class="line-modified">4120     case FilterGetByIdStatus:</span>
4121     case FilterPutByIdStatus:
4122     case FilterInByIdStatus:
4123         m_interpreter.filterICStatus(node);
4124         noResult(node);
4125         break;
4126 
4127     case LastNodeType:
4128     case Phi:
4129     case Upsilon:
4130     case ExtractOSREntryLocal:
4131     case CheckTierUpInLoop:
4132     case CheckTierUpAtReturn:
4133     case CheckTierUpAndOSREnter:
4134     case Int52Rep:
4135     case FiatInt52:
4136     case Int52Constant:
4137     case CheckInBounds:
4138     case ArithIMul:
4139     case MultiGetByOffset:
4140     case MultiPutByOffset:
4141     case CheckBadCell:
4142     case BottomValue:
4143     case PhantomNewObject:
4144     case PhantomNewFunction:
4145     case PhantomNewGeneratorFunction:
4146     case PhantomNewAsyncFunction:
4147     case PhantomNewAsyncGeneratorFunction:
4148     case PhantomCreateActivation:

4149     case PhantomNewRegexp:
4150     case PutHint:
4151     case CheckStructureImmediate:
4152     case MaterializeCreateActivation:

4153     case PutStack:
4154     case KillStack:
4155     case GetStack:
4156     case GetMyArgumentByVal:
4157     case GetMyArgumentByValOutOfBounds:
4158     case GetVectorLength:
4159     case PhantomCreateRest:
4160     case PhantomSpread:
4161     case PhantomNewArrayWithSpread:
4162     case PhantomNewArrayBuffer:
4163     case AtomicsIsLockFree:
4164     case AtomicsAdd:
4165     case AtomicsAnd:
4166     case AtomicsCompareExchange:
4167     case AtomicsExchange:
4168     case AtomicsLoad:
4169     case AtomicsOr:
4170     case AtomicsStore:
4171     case AtomicsSub:
4172     case AtomicsXor:
4173     case IdentityWithProfile:
4174     case InitializeEntrypointArguments:
4175     case EntrySwitch:
4176     case CPUIntrinsic:
4177     case AssertNotEmpty:
4178     case DataViewGetInt:
4179     case DataViewGetFloat:
4180     case DataViewSet:



4181         DFG_CRASH(m_jit.graph(), node, &quot;unexpected node in DFG backend&quot;);
4182         break;
4183     }
4184 
4185     if (!m_compileOkay)
4186         return;
4187 
4188     if (node-&gt;hasResult() &amp;&amp; node-&gt;mustGenerate())
4189         use(node);
4190 }
4191 
4192 void SpeculativeJIT::moveTrueTo(GPRReg gpr)
4193 {
4194     m_jit.move(TrustedImm32(1), gpr);
4195 }
4196 
4197 void SpeculativeJIT::moveFalseTo(GPRReg gpr)
4198 {
4199     m_jit.move(TrustedImm32(0), gpr);
4200 }
</pre>
</td>
<td>
<hr />
<pre>
 196         usedRegisters.set(JSValueRegs(baseTagGPROrNone, basePayloadGPR), false);
 197         usedRegisters.set(JSValueRegs(resultTagGPR, resultPayloadGPR), false);
 198     }
 199 
 200     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
 201     JITGetByIdGenerator gen(
 202         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters, identifierUID(identifierNumber),
 203         JSValueRegs(baseTagGPROrNone, basePayloadGPR), JSValueRegs(resultTagGPR, resultPayloadGPR), type);
 204 
 205     gen.generateFastPath(m_jit);
 206 
 207     JITCompiler::JumpList slowCases;
 208     if (slowPathTarget.isSet())
 209         slowCases.append(slowPathTarget);
 210     slowCases.append(gen.slowPathJump());
 211 
 212     std::unique_ptr&lt;SlowPathGenerator&gt; slowPath;
 213     if (baseTagGPROrNone == InvalidGPRReg) {
 214         slowPath = slowPathCall(
 215             slowCases, this, appropriateOptimizingGetByIdFunction(type),
<span class="line-modified"> 216             JSValueRegs(resultTagGPR, resultPayloadGPR), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(),</span>
 217             CCallHelpers::CellValue(basePayloadGPR),
 218             identifierUID(identifierNumber));
 219     } else {
 220         slowPath = slowPathCall(
 221             slowCases, this, appropriateOptimizingGetByIdFunction(type),
<span class="line-modified"> 222             JSValueRegs(resultTagGPR, resultPayloadGPR), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(), JSValueRegs(baseTagGPROrNone, basePayloadGPR), identifierUID(identifierNumber));</span>
 223     }
 224 
 225     m_jit.addGetById(gen, slowPath.get());
 226     addSlowPathGenerator(WTFMove(slowPath));
 227 }
 228 
 229 void SpeculativeJIT::cachedGetByIdWithThis(
 230     CodeOrigin codeOrigin, GPRReg baseTagGPROrNone, GPRReg basePayloadGPR, GPRReg thisTagGPR, GPRReg thisPayloadGPR, GPRReg resultTagGPR, GPRReg resultPayloadGPR,
 231     unsigned identifierNumber, const JITCompiler::JumpList&amp; slowPathTarget)
 232 {
 233     RegisterSet usedRegisters = this-&gt;usedRegisters();
 234 
 235     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
 236     JITGetByIdWithThisGenerator gen(
 237         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters, identifierUID(identifierNumber),
<span class="line-modified"> 238         JSValueRegs(resultTagGPR, resultPayloadGPR), JSValueRegs(baseTagGPROrNone, basePayloadGPR), JSValueRegs(thisTagGPR, thisPayloadGPR));</span>
 239 
 240     gen.generateFastPath(m_jit);
 241 
 242     JITCompiler::JumpList slowCases;
 243     if (!slowPathTarget.empty())
 244         slowCases.append(slowPathTarget);
 245     slowCases.append(gen.slowPathJump());
 246 
 247     std::unique_ptr&lt;SlowPathGenerator&gt; slowPath;
 248     if (baseTagGPROrNone == InvalidGPRReg &amp;&amp; thisTagGPR == InvalidGPRReg) {
 249         slowPath = slowPathCall(
 250             slowCases, this, operationGetByIdWithThisOptimize,
<span class="line-modified"> 251             JSValueRegs(resultTagGPR, resultPayloadGPR), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(),</span>
 252             CCallHelpers::CellValue(basePayloadGPR),
 253             CCallHelpers::CellValue(thisPayloadGPR),
 254             identifierUID(identifierNumber));
 255     } else {
 256         ASSERT(baseTagGPROrNone != InvalidGPRReg);
 257         ASSERT(thisTagGPR != InvalidGPRReg);
 258 
 259         slowPath = slowPathCall(
 260             slowCases, this, operationGetByIdWithThisOptimize,
<span class="line-modified"> 261             JSValueRegs(resultTagGPR, resultPayloadGPR), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(), JSValueRegs(baseTagGPROrNone, basePayloadGPR), JSValueRegs(thisTagGPR, thisPayloadGPR), identifierUID(identifierNumber));</span>
 262     }
 263 
 264     m_jit.addGetByIdWithThis(gen, slowPath.get());
 265     addSlowPathGenerator(WTFMove(slowPath));
 266 }
 267 
 268 void SpeculativeJIT::nonSpeculativeNonPeepholeCompareNullOrUndefined(Edge operand)
 269 {
 270     JSValueOperand arg(this, operand, ManualOperandSpeculation);
 271     GPRReg argTagGPR = arg.tagGPR();
 272     GPRReg argPayloadGPR = arg.payloadGPR();
 273 
 274     GPRTemporary resultPayload(this, Reuse, arg, PayloadWord);
 275     GPRReg resultPayloadGPR = resultPayload.gpr();
 276 
 277     JITCompiler::Jump notCell;
 278     JITCompiler::Jump notMasqueradesAsUndefined;
 279     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
 280         if (!isKnownCell(operand.node()))
 281             notCell = m_jit.branchIfNotCell(arg.jsValueRegs());
</pre>
<hr />
<pre>
 399 
 400     JSValueOperand arg1(this, node-&gt;child1());
 401     JSValueOperand arg2(this, node-&gt;child2());
 402     GPRReg arg1PayloadGPR = arg1.payloadGPR();
 403     GPRReg arg2PayloadGPR = arg2.payloadGPR();
 404     JSValueRegs arg1Regs = arg1.jsValueRegs();
 405     JSValueRegs arg2Regs = arg2.jsValueRegs();
 406 
 407     GPRTemporary resultPayload(this, Reuse, arg1, PayloadWord);
 408     GPRReg resultPayloadGPR = resultPayload.gpr();
 409 
 410     arg1.use();
 411     arg2.use();
 412 
 413     if (isKnownCell(node-&gt;child1().node()) &amp;&amp; isKnownCell(node-&gt;child2().node())) {
 414         // see if we get lucky: if the arguments are cells and they reference the same
 415         // cell, then they must be strictly equal.
 416         branchPtr(JITCompiler::Equal, arg1PayloadGPR, arg2PayloadGPR, invert ? notTaken : taken);
 417 
 418         silentSpillAllRegisters(resultPayloadGPR);
<span class="line-modified"> 419         callOperation(operationCompareStrictEqCell, resultPayloadGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1PayloadGPR, arg2PayloadGPR);</span>
 420         m_jit.exceptionCheck();
 421         silentFillAllRegisters();
 422 
 423         branchTest32(invert ? JITCompiler::Zero : JITCompiler::NonZero, resultPayloadGPR, taken);
 424     } else {
 425         // FIXME: Add fast paths for twoCells, number etc.
 426 
 427         silentSpillAllRegisters(resultPayloadGPR);
<span class="line-modified"> 428         callOperation(operationCompareStrictEq, resultPayloadGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs);</span>
 429         m_jit.exceptionCheck();
 430         silentFillAllRegisters();
 431 
 432         branchTest32(invert ? JITCompiler::Zero : JITCompiler::NonZero, resultPayloadGPR, taken);
 433     }
 434 
 435     jump(notTaken);
 436 }
 437 
 438 void SpeculativeJIT::nonSpeculativeNonPeepholeStrictEq(Node* node, bool invert)
 439 {
 440     JSValueOperand arg1(this, node-&gt;child1());
 441     JSValueOperand arg2(this, node-&gt;child2());
 442     GPRReg arg1PayloadGPR = arg1.payloadGPR();
 443     GPRReg arg2PayloadGPR = arg2.payloadGPR();
 444     JSValueRegs arg1Regs = arg1.jsValueRegs();
 445     JSValueRegs arg2Regs = arg2.jsValueRegs();
 446 
 447     GPRTemporary resultPayload(this, Reuse, arg1, PayloadWord);
 448     GPRReg resultPayloadGPR = resultPayload.gpr();
 449 
 450     arg1.use();
 451     arg2.use();
 452 
 453     if (isKnownCell(node-&gt;child1().node()) &amp;&amp; isKnownCell(node-&gt;child2().node())) {
 454         // see if we get lucky: if the arguments are cells and they reference the same
 455         // cell, then they must be strictly equal.
 456         // FIXME: this should flush registers instead of silent spill/fill.
 457         JITCompiler::Jump notEqualCase = m_jit.branchPtr(JITCompiler::NotEqual, arg1PayloadGPR, arg2PayloadGPR);
 458 
 459         m_jit.move(JITCompiler::TrustedImm32(!invert), resultPayloadGPR);
 460         JITCompiler::Jump done = m_jit.jump();
 461 
 462         notEqualCase.link(&amp;m_jit);
 463 
 464         silentSpillAllRegisters(resultPayloadGPR);
<span class="line-modified"> 465         callOperation(operationCompareStrictEqCell, resultPayloadGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1PayloadGPR, arg2PayloadGPR);</span>
 466         m_jit.exceptionCheck();
 467         silentFillAllRegisters();
 468 
 469         m_jit.andPtr(JITCompiler::TrustedImm32(1), resultPayloadGPR);
 470 
 471         done.link(&amp;m_jit);
 472     } else {
 473         // FIXME: Add fast paths.
 474 
 475         silentSpillAllRegisters(resultPayloadGPR);
<span class="line-modified"> 476         callOperation(operationCompareStrictEq, resultPayloadGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs);</span>
 477         silentFillAllRegisters();
 478         m_jit.exceptionCheck();
 479 
 480         m_jit.andPtr(JITCompiler::TrustedImm32(1), resultPayloadGPR);
 481     }
 482 
 483     booleanResult(resultPayloadGPR, node, UseChildrenCalledExplicitly);
 484 }
 485 
 486 void SpeculativeJIT::compileCompareEqPtr(Node* node)
 487 {
 488     JSValueOperand operand(this, node-&gt;child1());
 489     GPRTemporary result(this);
 490     JSValueRegs regs = operand.jsValueRegs();
 491     GPRReg resultGPR = result.gpr();
 492     m_jit.boxBooleanPayload(false, resultGPR);
 493     JITCompiler::JumpList notEqual = m_jit.branchIfNotEqual(regs, node-&gt;cellOperand()-&gt;value());
 494     m_jit.boxBooleanPayload(true, resultGPR);
 495     notEqual.link(&amp;m_jit);
 496     blessedBooleanResult(resultGPR, node);
</pre>
<hr />
<pre>
 567     case DirectTailCall:
 568         callType = CallLinkInfo::DirectTailCall;
 569         isTail = true;
 570         isDirect = true;
 571         break;
 572     case DirectTailCallInlinedCaller:
 573         callType = CallLinkInfo::DirectCall;
 574         isEmulatedTail = true;
 575         isDirect = true;
 576         break;
 577     default:
 578         DFG_CRASH(m_jit.graph(), node, &quot;bad node type&quot;);
 579         break;
 580     }
 581 
 582     Edge calleeEdge = m_jit.graph().child(node, 0);
 583     GPRReg calleeTagGPR = InvalidGPRReg;
 584     GPRReg calleePayloadGPR = InvalidGPRReg;
 585     CallFrameShuffleData shuffleData;
 586 
<span class="line-added"> 587     JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);</span>
 588     ExecutableBase* executable = nullptr;
 589     FunctionExecutable* functionExecutable = nullptr;
 590     if (isDirect) {
 591         executable = node-&gt;castOperand&lt;ExecutableBase*&gt;();
 592         functionExecutable = jsDynamicCast&lt;FunctionExecutable*&gt;(vm(), executable);
 593     }
 594 
 595     unsigned numPassedArgs = 0;
 596     unsigned numAllocatedArgs = 0;
 597 
 598     // Gotta load the arguments somehow. Varargs is trickier.
 599     if (isVarargs || isForwardVarargs) {
 600         RELEASE_ASSERT(!isDirect);
 601         CallVarargsData* data = node-&gt;callVarargsData();
 602 
 603         int numUsedStackSlots = m_jit.graph().m_nextMachineLocal;
 604 
 605         if (isForwardVarargs) {
 606             flushRegisters();
 607             if (node-&gt;child3())
</pre>
<hr />
<pre>
 609 
 610             GPRReg scratchGPR1;
 611             GPRReg scratchGPR2;
 612             GPRReg scratchGPR3;
 613 
 614             scratchGPR1 = JITCompiler::selectScratchGPR();
 615             scratchGPR2 = JITCompiler::selectScratchGPR(scratchGPR1);
 616             scratchGPR3 = JITCompiler::selectScratchGPR(scratchGPR1, scratchGPR2);
 617 
 618             m_jit.move(TrustedImm32(numUsedStackSlots), scratchGPR2);
 619             JITCompiler::JumpList slowCase;
 620             InlineCallFrame* inlineCallFrame;
 621             if (node-&gt;child3())
 622                 inlineCallFrame = node-&gt;child3()-&gt;origin.semantic.inlineCallFrame();
 623             else
 624                 inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();
 625             // emitSetupVarargsFrameFastCase modifies the stack pointer if it succeeds.
 626             emitSetupVarargsFrameFastCase(vm(), m_jit, scratchGPR2, scratchGPR1, scratchGPR2, scratchGPR3, inlineCallFrame, data-&gt;firstVarArgOffset, slowCase);
 627             JITCompiler::Jump done = m_jit.jump();
 628             slowCase.link(&amp;m_jit);
<span class="line-modified"> 629             callOperation(operationThrowStackOverflowForVarargs, TrustedImmPtr::weakPointer(m_graph, globalObject));</span>
 630             m_jit.exceptionCheck();
 631             m_jit.abortWithReason(DFGVarargsThrowingPathDidNotThrow);
 632             done.link(&amp;m_jit);
 633         } else {
 634             GPRReg argumentsPayloadGPR;
 635             GPRReg argumentsTagGPR;
 636             GPRReg scratchGPR1;
 637             GPRReg scratchGPR2;
 638             GPRReg scratchGPR3;
 639 
 640             auto loadArgumentsGPR = [&amp;] (GPRReg reservedGPR) {
 641                 if (reservedGPR != InvalidGPRReg)
 642                     lock(reservedGPR);
 643                 JSValueOperand arguments(this, node-&gt;child3());
 644                 argumentsTagGPR = arguments.tagGPR();
 645                 argumentsPayloadGPR = arguments.payloadGPR();
 646                 if (reservedGPR != InvalidGPRReg)
 647                     unlock(reservedGPR);
 648                 flushRegisters();
 649 
 650                 scratchGPR1 = JITCompiler::selectScratchGPR(argumentsPayloadGPR, argumentsTagGPR, reservedGPR);
 651                 scratchGPR2 = JITCompiler::selectScratchGPR(argumentsPayloadGPR, argumentsTagGPR, scratchGPR1, reservedGPR);
 652                 scratchGPR3 = JITCompiler::selectScratchGPR(argumentsPayloadGPR, argumentsTagGPR, scratchGPR1, scratchGPR2, reservedGPR);
 653             };
 654 
 655             loadArgumentsGPR(InvalidGPRReg);
 656 
 657             DFG_ASSERT(m_jit.graph(), node, isFlushed());
 658 
 659             // Right now, arguments is in argumentsTagGPR/argumentsPayloadGPR and the register file is
 660             // flushed.
<span class="line-modified"> 661             callOperation(operationSizeFrameForVarargs, GPRInfo::returnValueGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), JSValueRegs(argumentsTagGPR, argumentsPayloadGPR), numUsedStackSlots, data-&gt;firstVarArgOffset);</span>
 662             m_jit.exceptionCheck();
 663 
 664             // Now we have the argument count of the callee frame, but we&#39;ve lost the arguments operand.
 665             // Reconstruct the arguments operand while preserving the callee frame.
 666             loadArgumentsGPR(GPRInfo::returnValueGPR);
 667             m_jit.move(TrustedImm32(numUsedStackSlots), scratchGPR1);
 668             emitSetVarargsFrame(m_jit, GPRInfo::returnValueGPR, false, scratchGPR1, scratchGPR1);
 669             m_jit.addPtr(TrustedImm32(-(sizeof(CallerFrameAndPC) + WTF::roundUpToMultipleOf(stackAlignmentBytes(), 6 * sizeof(void*)))), scratchGPR1, JITCompiler::stackPointerRegister);
 670 
<span class="line-modified"> 671             callOperation(operationSetupVarargsFrame, GPRInfo::returnValueGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), scratchGPR1, JSValueRegs(argumentsTagGPR, argumentsPayloadGPR), data-&gt;firstVarArgOffset, GPRInfo::returnValueGPR);</span>
 672             m_jit.exceptionCheck();
 673             m_jit.addPtr(TrustedImm32(sizeof(CallerFrameAndPC)), GPRInfo::returnValueGPR, JITCompiler::stackPointerRegister);
 674         }
 675 
 676         DFG_ASSERT(m_jit.graph(), node, isFlushed());
 677 
 678         // We don&#39;t need the arguments array anymore.
 679         if (isVarargs)
 680             use(node-&gt;child3());
 681 
 682         // Now set up the &quot;this&quot; argument.
 683         JSValueOperand thisArgument(this, node-&gt;child2());
 684         GPRReg thisArgumentTagGPR = thisArgument.tagGPR();
 685         GPRReg thisArgumentPayloadGPR = thisArgument.payloadGPR();
 686         thisArgument.use();
 687 
 688         m_jit.store32(thisArgumentTagGPR, JITCompiler::calleeArgumentTagSlot(0));
 689         m_jit.store32(thisArgumentPayloadGPR, JITCompiler::calleeArgumentPayloadSlot(0));
 690     } else {
 691         // The call instruction&#39;s first child is either the function (normal call) or the
</pre>
<hr />
<pre>
 718             calleePayloadGPR = callee.payloadGPR();
 719             if (!isDirect)
 720                 use(calleeEdge);
 721 
 722             shuffleData.numLocals = m_jit.graph().frameRegisterCount();
 723             shuffleData.callee = ValueRecovery::inPair(calleeTagGPR, calleePayloadGPR);
 724             shuffleData.args.resize(numAllocatedArgs);
 725             shuffleData.numPassedArgs = numPassedArgs;
 726 
 727             for (unsigned i = 0; i &lt; numPassedArgs; ++i) {
 728                 Edge argEdge = m_jit.graph().varArgChild(node, i + 1);
 729                 GenerationInfo&amp; info = generationInfo(argEdge.node());
 730                 if (!isDirect)
 731                     use(argEdge);
 732                 shuffleData.args[i] = info.recovery(argEdge-&gt;virtualRegister());
 733             }
 734 
 735             for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
 736                 shuffleData.args[i] = ValueRecovery::constant(jsUndefined());
 737         } else {
<span class="line-modified"> 738             m_jit.store32(MacroAssembler::TrustedImm32(numPassedArgs), m_jit.calleeFramePayloadSlot(CallFrameSlot::argumentCountIncludingThis));</span>
 739 
 740             for (unsigned i = 0; i &lt; numPassedArgs; i++) {
 741                 Edge argEdge = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + 1 + i];
 742                 JSValueOperand arg(this, argEdge);
 743                 GPRReg argTagGPR = arg.tagGPR();
 744                 GPRReg argPayloadGPR = arg.payloadGPR();
 745                 use(argEdge);
 746 
 747                 m_jit.store32(argTagGPR, m_jit.calleeArgumentTagSlot(i));
 748                 m_jit.store32(argPayloadGPR, m_jit.calleeArgumentPayloadSlot(i));
 749             }
 750 
 751             for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
 752                 m_jit.storeTrustedValue(jsUndefined(), JITCompiler::calleeArgumentSlot(i));
 753         }
 754     }
 755 
 756     if (!isTail || isVarargs || isForwardVarargs) {
 757         JSValueOperand callee(this, calleeEdge);
 758         calleeTagGPR = callee.tagGPR();
</pre>
<hr />
<pre>
 788         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 789         // After the calls are done, we need to reestablish our stack
 790         // pointer. We rely on this for varargs calls, calls with arity
 791         // mismatch (the callframe is slided) and tail calls.
 792         m_jit.addPtr(TrustedImm32(m_jit.graph().stackPointerOffset() * sizeof(Register)), GPRInfo::callFrameRegister, JITCompiler::stackPointerRegister);
 793     };
 794 
 795     if (node-&gt;op() == CallEval) {
 796         // We want to call operationCallEval but we don&#39;t want to overwrite the parameter area in
 797         // which we have created a prototypical eval call frame. This means that we have to
 798         // subtract stack to make room for the call. Lucky for us, at this point we have the whole
 799         // register file to ourselves.
 800 
 801         m_jit.emitStoreCallSiteIndex(callSite);
 802         m_jit.addPtr(TrustedImm32(-static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC))), JITCompiler::stackPointerRegister, GPRInfo::regT0);
 803         m_jit.storePtr(GPRInfo::callFrameRegister, JITCompiler::Address(GPRInfo::regT0, CallFrame::callerFrameOffset()));
 804 
 805         // Now we need to make room for:
 806         // - The caller frame and PC of a call to operationCallEval.
 807         // - Potentially two arguments on the stack.
<span class="line-modified"> 808         unsigned requiredBytes = sizeof(CallerFrameAndPC) + sizeof(CallFrame*) * 2;</span>
 809         requiredBytes = WTF::roundUpToMultipleOf(stackAlignmentBytes(), requiredBytes);
 810         m_jit.subPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
<span class="line-modified"> 811         m_jit.setupArguments&lt;decltype(operationCallEval)&gt;(TrustedImmPtr::weakPointer(m_graph, globalObject), GPRInfo::regT0);</span>
 812         prepareForExternalCall();
 813         m_jit.appendCall(operationCallEval);
 814         m_jit.exceptionCheck();
 815         JITCompiler::Jump done = m_jit.branchIfNotEmpty(GPRInfo::returnValueGPR2);
 816 
 817         // This is the part where we meant to make a normal call. Oops.
 818         m_jit.addPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
 819         m_jit.load32(JITCompiler::calleeFrameSlot(CallFrameSlot::callee).withOffset(PayloadOffset), GPRInfo::regT0);
 820         m_jit.load32(JITCompiler::calleeFrameSlot(CallFrameSlot::callee).withOffset(TagOffset), GPRInfo::regT1);
<span class="line-modified"> 821         m_jit.emitDumbVirtualCall(vm(), globalObject, info);</span>
 822 
 823         done.link(&amp;m_jit);
 824         setResultAndResetStack();
 825         return;
 826     }
 827 
 828     if (isDirect) {
 829         info-&gt;setExecutableDuringCompilation(executable);
<span class="line-modified"> 830         info-&gt;setMaxArgumentCountIncludingThis(numAllocatedArgs);</span>
 831 
 832         if (isTail) {
 833             RELEASE_ASSERT(node-&gt;op() == DirectTailCall);
 834 
 835             JITCompiler::PatchableJump patchableJump = m_jit.patchableJump();
 836             JITCompiler::Label mainPath = m_jit.label();
 837 
 838             m_jit.emitStoreCallSiteIndex(callSite);
 839 
 840             info-&gt;setFrameShuffleData(shuffleData);
 841             CallFrameShuffler(m_jit, shuffleData).prepareForTailCall();
 842 
 843             JITCompiler::Call call = m_jit.nearTailCall();
 844 
 845             JITCompiler::Label slowPath = m_jit.label();
 846             patchableJump.m_jump.linkTo(slowPath, &amp;m_jit);
 847 
 848             silentSpillAllRegisters(InvalidGPRReg);
 849             callOperation(operationLinkDirectCall, info, calleePayloadGPR);
 850             silentFillAllRegisters();
 851             m_jit.exceptionCheck();
 852             m_jit.jump().linkTo(mainPath, &amp;m_jit);
 853 
 854             useChildren(node);
 855 
 856             m_jit.addJSDirectTailCall(patchableJump, call, slowPath, info);
 857             return;
 858         }
 859 
 860         JITCompiler::Label mainPath = m_jit.label();
 861 
 862         m_jit.emitStoreCallSiteIndex(callSite);
 863 
 864         JITCompiler::Call call = m_jit.nearCall();
 865         JITCompiler::Jump done = m_jit.jump();
 866 
 867         JITCompiler::Label slowPath = m_jit.label();



 868         callOperation(operationLinkDirectCall, info, calleePayloadGPR);
 869         m_jit.exceptionCheck();
 870         m_jit.jump().linkTo(mainPath, &amp;m_jit);
 871 
 872         done.link(&amp;m_jit);
 873 
 874         setResultAndResetStack();
 875 
 876         m_jit.addJSDirectCall(call, slowPath, info);
 877         return;
 878     }
 879 
 880     m_jit.emitStoreCallSiteIndex(callSite);
 881 
 882     slowPath.append(m_jit.branchIfNotCell(JSValueRegs(calleeTagGPR, calleePayloadGPR)));
 883     slowPath.append(m_jit.branchPtrWithPatch(MacroAssembler::NotEqual, calleePayloadGPR, targetToCheck));
 884 
 885     if (isTail) {
 886         if (node-&gt;op() == TailCall) {
 887             info-&gt;setFrameShuffleData(shuffleData);
</pre>
<hr />
<pre>
 905         callFrameShuffler.prepareForSlowPath();
 906     } else {
 907         // Callee payload needs to be in regT0, tag in regT1
 908         if (calleeTagGPR == GPRInfo::regT0) {
 909             if (calleePayloadGPR == GPRInfo::regT1)
 910                 m_jit.swap(GPRInfo::regT1, GPRInfo::regT0);
 911             else {
 912                 m_jit.move(calleeTagGPR, GPRInfo::regT1);
 913                 m_jit.move(calleePayloadGPR, GPRInfo::regT0);
 914             }
 915         } else {
 916             m_jit.move(calleePayloadGPR, GPRInfo::regT0);
 917             m_jit.move(calleeTagGPR, GPRInfo::regT1);
 918         }
 919 
 920         if (isTail)
 921             m_jit.emitRestoreCalleeSaves();
 922     }
 923 
 924     m_jit.move(TrustedImmPtr(info), GPRInfo::regT2);
<span class="line-added"> 925     m_jit.move(TrustedImmPtr::weakPointer(m_graph, globalObject), GPRInfo::regT3);</span>
 926     JITCompiler::Call slowCall = m_jit.nearCall();
 927 
 928     done.link(&amp;m_jit);
 929 
 930     if (isTail)
 931         m_jit.abortWithReason(JITDidReturnFromTailCall);
 932     else
 933         setResultAndResetStack();
 934 
 935     m_jit.addJSCall(fastCall, slowCall, targetToCheck, info);
 936 }
 937 
 938 template&lt;bool strict&gt;
 939 GPRReg SpeculativeJIT::fillSpeculateInt32Internal(Edge edge, DataFormat&amp; returnFormat)
 940 {
 941     AbstractValue&amp; value = m_state.forNode(edge);
 942     SpeculatedType type = value.m_type;
 943     ASSERT(edge.useKind() != KnownInt32Use || !(value.m_type &amp; ~SpecInt32Only));
 944 
 945     m_interpreter.filter(value, SpecInt32Only);
</pre>
<hr />
<pre>
1768         m_jit.add32(TrustedImm32(1), propertyReg);
1769         m_jit.store32(propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
1770         m_jit.sub32(TrustedImm32(1), propertyReg);
1771 
1772         inBounds.link(&amp;m_jit);
1773     }
1774 
1775     m_jit.store32(valueTag, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
1776     m_jit.store32(valuePayloadReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
1777 
1778     base.use();
1779     property.use();
1780     value.use();
1781     storage.use();
1782 
1783     if (arrayMode.isOutOfBounds()) {
1784         if (node-&gt;op() == PutByValDirect) {
1785             addSlowPathGenerator(slowPathCall(
1786                 slowCase, this,
1787                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValDirectBeyondArrayBoundsNonStrict,
<span class="line-modified">1788                 NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg, JSValueRegs(valueTag, valuePayloadReg)));</span>
1789         } else {
1790             addSlowPathGenerator(slowPathCall(
1791                 slowCase, this,
1792                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsNonStrict,
<span class="line-modified">1793                 NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg, JSValueRegs(valueTag, valuePayloadReg)));</span>
1794         }
1795     }
1796 
1797     noResult(node, UseChildrenCalledExplicitly);
1798 }
1799 
1800 void SpeculativeJIT::compile(Node* node)
1801 {
1802     NodeType op = node-&gt;op();
1803 
1804 #if ENABLE(DFG_REGISTER_ALLOCATION_VALIDATION)
1805     m_jit.clearRegisterAllocationOffsets();
1806 #endif
1807 
1808     switch (op) {
1809     case JSConstant:
1810     case DoubleConstant:
1811     case PhantomDirectArguments:
1812     case PhantomClonedArguments:
1813         initConstantInfo(node);
1814         break;
1815 
1816     case LazyJSConstant:
1817         compileLazyJSConstant(node);
1818         break;
1819 
1820     case Identity: {
1821         compileIdentity(node);
1822         break;
1823     }
1824 
<span class="line-added">1825     case Inc:</span>
<span class="line-added">1826     case Dec:</span>
<span class="line-added">1827         compileIncOrDec(node);</span>
<span class="line-added">1828         break;</span>
<span class="line-added">1829 </span>
1830     case GetLocal: {
<span class="line-modified">1831         AbstractValue&amp; value = m_state.operand(node-&gt;operand());</span>
1832 
1833         // If the CFA is tracking this variable and it found that the variable
1834         // cannot have been assigned, then don&#39;t attempt to proceed.
1835         if (value.isClear()) {
1836             m_compileOkay = false;
1837             break;
1838         }
1839 
1840         switch (node-&gt;variableAccessData()-&gt;flushFormat()) {
1841         case FlushedDouble: {
1842             FPRTemporary result(this);
1843             m_jit.loadDouble(JITCompiler::addressFor(node-&gt;machineLocal()), result.fpr());
1844             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1845             m_fprs.retain(result.fpr(), virtualRegister, SpillOrderDouble);
1846             generationInfoFromVirtualRegister(virtualRegister).initDouble(node, node-&gt;refCount(), result.fpr());
1847             break;
1848         }
1849 
1850         case FlushedInt32: {
1851             GPRTemporary result(this);
</pre>
<hr />
<pre>
1895             m_gprs.retain(result.gpr(), virtualRegister, SpillOrderJS);
1896             m_gprs.retain(tag.gpr(), virtualRegister, SpillOrderJS);
1897 
1898             generationInfoFromVirtualRegister(virtualRegister).initJSValue(node, node-&gt;refCount(), tag.gpr(), result.gpr(), DataFormatJS);
1899             break;
1900         }
1901 
1902         default:
1903             RELEASE_ASSERT_NOT_REACHED();
1904         }
1905         break;
1906     }
1907 
1908     case MovHint: {
1909         compileMovHint(m_currentNode);
1910         noResult(node);
1911         break;
1912     }
1913 
1914     case ZombieHint: {
<span class="line-modified">1915         recordSetLocal(m_currentNode-&gt;unlinkedOperand(), VirtualRegister(), DataFormatDead);</span>
1916         noResult(node);
1917         break;
1918     }
1919 
1920     case ExitOK: {
1921         noResult(node);
1922         break;
1923     }
1924 
1925     case SetLocal: {
1926         switch (node-&gt;variableAccessData()-&gt;flushFormat()) {
1927         case FlushedDouble: {
1928             SpeculateDoubleOperand value(this, node-&gt;child1());
1929             m_jit.storeDouble(value.fpr(), JITCompiler::addressFor(node-&gt;machineLocal()));
1930             noResult(node);
1931             // Indicate that it&#39;s no longer necessary to retrieve the value of
1932             // this bytecode variable from registers or other locations in the stack,
1933             // but that it is stored as a double.
1934             recordSetLocal(DataFormatDouble);
1935             break;
</pre>
<hr />
<pre>
1992         break;
1993 
1994     case ArithBitAnd:
1995     case ArithBitOr:
1996     case ArithBitXor:
1997         compileBitwiseOp(node);
1998         break;
1999 
2000     case ValueBitNot:
2001         compileValueBitNot(node);
2002         break;
2003 
2004     case ArithBitNot:
2005         compileBitwiseNot(node);
2006         break;
2007 
2008     case ValueBitLShift:
2009         compileValueLShiftOp(node);
2010         break;
2011 
<span class="line-modified">2012     case ValueBitRShift:</span>
<span class="line-added">2013         compileValueBitRShift(node);</span>
<span class="line-added">2014         break;</span>
<span class="line-added">2015 </span>
<span class="line-added">2016     case ArithBitRShift:</span>
2017     case ArithBitLShift:
2018     case BitURShift:
2019         compileShiftOp(node);
2020         break;
2021 
2022     case UInt32ToNumber: {
2023         compileUInt32ToNumber(node);
2024         break;
2025     }
2026 
2027     case DoubleAsInt32: {
2028         compileDoubleAsInt32(node);
2029         break;
2030     }
2031 
2032     case ValueToInt32: {
2033         compileValueToInt32(node);
2034         break;
2035     }
2036 
</pre>
<hr />
<pre>
2201     case SameValue:
2202         compileSameValue(node);
2203         break;
2204 
2205     case StringCharCodeAt: {
2206         compileGetCharCodeAt(node);
2207         break;
2208     }
2209 
2210     case StringCharAt: {
2211         // Relies on StringCharAt node having same basic layout as GetByVal
2212         compileGetByValOnString(node);
2213         break;
2214     }
2215 
2216     case StringFromCharCode: {
2217         compileFromCharCode(node);
2218         break;
2219     }
2220 
<span class="line-added">2221     case CheckNeutered: {</span>
<span class="line-added">2222         compileCheckNeutered(node);</span>
<span class="line-added">2223         break;</span>
<span class="line-added">2224     }</span>
<span class="line-added">2225 </span>
2226     case CheckArray: {
2227         checkArray(node);
2228         break;
2229     }
2230 
2231     case Arrayify:
2232     case ArrayifyToStructure: {
2233         arrayify(node);
2234         break;
2235     }
2236 
2237     case GetByVal: {
2238         switch (node-&gt;arrayMode().type()) {
2239         case Array::SelectUsingPredictions:
2240         case Array::ForceExit:
2241             RELEASE_ASSERT_NOT_REACHED();
2242 #if COMPILER_QUIRK(CONSIDERS_UNREACHABLE_CODE)
2243             terminateSpeculativeExecution(InadequateCoverage, JSValueRegs(), 0);
2244 #endif
2245             break;
</pre>
<hr />
<pre>
2247             SpeculateStrictInt32Operand index(this, m_graph.varArgChild(node, 1));
2248             GPRTemporary resultTag(this, Reuse, index);
2249             GPRTemporary resultPayload(this);
2250 
2251             GPRReg indexGPR = index.gpr();
2252             GPRReg resultTagGPR = resultTag.gpr();
2253             GPRReg resultPayloadGPR = resultPayload.gpr();
2254 
2255             speculationCheck(OutOfBounds, JSValueRegs(), node,
2256                 m_jit.branch32(MacroAssembler::LessThan, indexGPR, MacroAssembler::TrustedImm32(0)));
2257 
2258             use(m_graph.varArgChild(node, 0));
2259             index.use();
2260 
2261             m_jit.move(MacroAssembler::TrustedImm32(JSValue::UndefinedTag), resultTagGPR);
2262             m_jit.move(MacroAssembler::TrustedImm32(0), resultPayloadGPR);
2263             jsValueResult(resultTagGPR, resultPayloadGPR, node, UseChildrenCalledExplicitly);
2264             break;
2265         }
2266         case Array::Generic: {
<span class="line-modified">2267             if (m_graph.m_slowGetByVal.contains(node)) {</span>
<span class="line-modified">2268                 if (m_graph.varArgChild(node, 0).useKind() == ObjectUse) {</span>
<span class="line-modified">2269                     if (m_graph.varArgChild(node, 1).useKind() == StringUse) {</span>
<span class="line-modified">2270                         compileGetByValForObjectWithString(node);</span>
<span class="line-added">2271                         break;</span>
<span class="line-added">2272                     }</span>
<span class="line-added">2273 </span>
<span class="line-added">2274                     if (m_graph.varArgChild(node, 1).useKind() == SymbolUse) {</span>
<span class="line-added">2275                         compileGetByValForObjectWithSymbol(node);</span>
<span class="line-added">2276                         break;</span>
<span class="line-added">2277                     }</span>
2278                 }
2279 
<span class="line-modified">2280                 SpeculateCellOperand base(this, m_graph.varArgChild(node, 0)); // Save a register, speculate cell. We&#39;ll probably be right.</span>
<span class="line-modified">2281                 JSValueOperand property(this, m_graph.varArgChild(node, 1));</span>
<span class="line-modified">2282                 GPRReg baseGPR = base.gpr();</span>
<span class="line-modified">2283                 JSValueRegs propertyRegs = property.jsValueRegs();</span>
<span class="line-added">2284 </span>
<span class="line-added">2285                 flushRegisters();</span>
<span class="line-added">2286                 JSValueRegsFlushedCallResult result(this);</span>
<span class="line-added">2287                 JSValueRegs resultRegs = result.regs();</span>
<span class="line-added">2288                 callOperation(operationGetByValCell, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyRegs);</span>
<span class="line-added">2289                 m_jit.exceptionCheck();</span>
<span class="line-added">2290 </span>
<span class="line-added">2291                 jsValueResult(resultRegs, node);</span>
<span class="line-added">2292                 break;</span>
2293             }
2294 
<span class="line-modified">2295             speculate(node, m_graph.varArgChild(node, 0));</span>
<span class="line-modified">2296             speculate(node, m_graph.varArgChild(node, 1));</span>
<span class="line-modified">2297 </span>
<span class="line-added">2298             JSValueOperand base(this, m_graph.varArgChild(node, 0), ManualOperandSpeculation);</span>
<span class="line-added">2299             JSValueOperand property(this, m_graph.varArgChild(node, 1), ManualOperandSpeculation);</span>
<span class="line-added">2300             GPRTemporary resultTag(this, Reuse, property, TagWord);</span>
<span class="line-added">2301             GPRTemporary resultPayload(this, Reuse, property, PayloadWord);</span>
<span class="line-added">2302 </span>
<span class="line-added">2303             JSValueRegs baseRegs = base.jsValueRegs();</span>
2304             JSValueRegs propertyRegs = property.jsValueRegs();
<span class="line-added">2305             JSValueRegs resultRegs(resultTag.gpr(), resultPayload.gpr());</span>
2306 
<span class="line-modified">2307             CodeOrigin codeOrigin = node-&gt;origin.semantic;</span>
<span class="line-modified">2308             CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());</span>
<span class="line-modified">2309             RegisterSet usedRegisters = this-&gt;usedRegisters();</span>
<span class="line-modified">2310 </span>
<span class="line-modified">2311             JITCompiler::JumpList slowCases;</span>
<span class="line-added">2312             if (!m_state.forNode(m_graph.varArgChild(node, 0)).isType(SpecCell))</span>
<span class="line-added">2313                 slowCases.append(m_jit.branchIfNotCell(baseRegs.tagGPR()));</span>
<span class="line-added">2314 </span>
<span class="line-added">2315             JITGetByValGenerator gen(</span>
<span class="line-added">2316                 m_jit.codeBlock(), codeOrigin, callSite, usedRegisters,</span>
<span class="line-added">2317                 baseRegs, propertyRegs, resultRegs);</span>
<span class="line-added">2318 </span>
<span class="line-added">2319             if (m_state.forNode(m_graph.varArgChild(node, 1)).isType(SpecString))</span>
<span class="line-added">2320                 gen.stubInfo()-&gt;propertyIsString = true;</span>
<span class="line-added">2321             else if (m_state.forNode(m_graph.varArgChild(node, 1)).isType(SpecInt32Only))</span>
<span class="line-added">2322                 gen.stubInfo()-&gt;propertyIsInt32 = true;</span>
<span class="line-added">2323             else if (m_state.forNode(m_graph.varArgChild(node, 1)).isType(SpecSymbol))</span>
<span class="line-added">2324                 gen.stubInfo()-&gt;propertyIsSymbol = true;</span>
<span class="line-added">2325 </span>
<span class="line-added">2326             gen.generateFastPath(m_jit);</span>
<span class="line-added">2327 </span>
<span class="line-added">2328             slowCases.append(gen.slowPathJump());</span>
<span class="line-added">2329 </span>
<span class="line-added">2330             std::unique_ptr&lt;SlowPathGenerator&gt; slowPath = slowPathCall(</span>
<span class="line-added">2331                 slowCases, this, operationGetByValOptimize,</span>
<span class="line-added">2332                 resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(), nullptr, baseRegs, propertyRegs);</span>
<span class="line-added">2333 </span>
<span class="line-added">2334             m_jit.addGetByVal(gen, slowPath.get());</span>
<span class="line-added">2335             addSlowPathGenerator(WTFMove(slowPath));</span>
2336 
2337             jsValueResult(resultRegs, node);
2338             break;
2339         }
2340         case Array::Int32:
2341         case Array::Contiguous: {
2342             if (node-&gt;arrayMode().isInBounds()) {
2343                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2344                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2345 
2346                 GPRReg propertyReg = property.gpr();
2347                 GPRReg storageReg = storage.gpr();
2348 
2349                 if (!m_compileOkay)
2350                     return;
2351 
2352                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2353 
2354                 GPRTemporary resultPayload(this);
2355                 if (node-&gt;arrayMode().type() == Array::Int32) {
</pre>
<hr />
<pre>
2403 
2404             if (!m_compileOkay)
2405                 return;
2406 
2407             GPRTemporary resultTag(this);
2408             GPRTemporary resultPayload(this);
2409             GPRReg resultTagReg = resultTag.gpr();
2410             GPRReg resultPayloadReg = resultPayload.gpr();
2411 
2412             MacroAssembler::JumpList slowCases;
2413 
2414             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2415 
2416             m_jit.load32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)), resultTagReg);
2417             m_jit.load32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)), resultPayloadReg);
2418             slowCases.append(m_jit.branchIfEmpty(resultTagReg));
2419 
2420             addSlowPathGenerator(
2421                 slowPathCall(
2422                     slowCases, this, operationGetByValObjectInt,
<span class="line-modified">2423                     JSValueRegs(resultTagReg, resultPayloadReg), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg));</span>
2424 
2425             jsValueResult(resultTagReg, resultPayloadReg, node);
2426             break;
2427         }
2428         case Array::Double: {
2429             if (node-&gt;arrayMode().isInBounds()) {
2430                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2431                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2432 
2433                 GPRReg propertyReg = property.gpr();
2434                 GPRReg storageReg = storage.gpr();
2435 
2436                 if (!m_compileOkay)
2437                     return;
2438 
2439                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2440 
2441                 FPRTemporary result(this);
2442                 m_jit.loadDouble(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), result.fpr());
2443                 if (!node-&gt;arrayMode().isSaneChain())
</pre>
<hr />
<pre>
2458                 return;
2459 
2460             GPRTemporary resultTag(this);
2461             GPRTemporary resultPayload(this);
2462             FPRTemporary temp(this);
2463             GPRReg resultTagReg = resultTag.gpr();
2464             GPRReg resultPayloadReg = resultPayload.gpr();
2465             FPRReg tempReg = temp.fpr();
2466 
2467             MacroAssembler::JumpList slowCases;
2468 
2469             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2470 
2471             m_jit.loadDouble(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), tempReg);
2472             slowCases.append(m_jit.branchIfNaN(tempReg));
2473             boxDouble(tempReg, resultTagReg, resultPayloadReg);
2474 
2475             addSlowPathGenerator(
2476                 slowPathCall(
2477                     slowCases, this, operationGetByValObjectInt,
<span class="line-modified">2478                     JSValueRegs(resultTagReg, resultPayloadReg), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg));</span>
2479 
2480             jsValueResult(resultTagReg, resultPayloadReg, node);
2481             break;
2482         }
2483         case Array::ArrayStorage:
2484         case Array::SlowPutArrayStorage: {
2485             if (node-&gt;arrayMode().isInBounds()) {
2486                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2487                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2488                 GPRReg propertyReg = property.gpr();
2489                 GPRReg storageReg = storage.gpr();
2490 
2491                 if (!m_compileOkay)
2492                     return;
2493 
2494                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::vectorLengthOffset())));
2495 
2496                 GPRTemporary resultTag(this);
2497                 GPRTemporary resultPayload(this);
2498 
</pre>
<hr />
<pre>
2516 
2517             GPRTemporary resultTag(this);
2518             GPRTemporary resultPayload(this);
2519             GPRReg resultTagReg = resultTag.gpr();
2520             GPRReg resultPayloadReg = resultPayload.gpr();
2521 
2522             JITCompiler::Jump outOfBounds = m_jit.branch32(
2523                 MacroAssembler::AboveOrEqual, propertyReg,
2524                 MacroAssembler::Address(storageReg, ArrayStorage::vectorLengthOffset()));
2525 
2526             m_jit.load32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), resultTagReg);
2527             JITCompiler::Jump hole = m_jit.branchIfEmpty(resultTag.gpr());
2528             m_jit.load32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)), resultPayloadReg);
2529 
2530             JITCompiler::JumpList slowCases;
2531             slowCases.append(outOfBounds);
2532             slowCases.append(hole);
2533             addSlowPathGenerator(
2534                 slowPathCall(
2535                     slowCases, this, operationGetByValObjectInt,
<span class="line-modified">2536                     JSValueRegs(resultTagReg, resultPayloadReg), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)),</span>
2537                     baseReg, propertyReg));
2538 
2539             jsValueResult(resultTagReg, resultPayloadReg, node);
2540             break;
2541         }
2542         case Array::String:
2543             compileGetByValOnString(node);
2544             break;
2545         case Array::DirectArguments:
2546             compileGetByValOnDirectArguments(node);
2547             break;
2548         case Array::ScopedArguments:
2549             compileGetByValOnScopedArguments(node);
2550             break;
2551         default: {
2552             TypedArrayType type = node-&gt;arrayMode().typedArrayType();
2553             if (isInt(type))
2554                 compileGetByValOnIntTypedArray(node, type);
2555             else
2556                 compileGetByValOnFloatTypedArray(node, type);
</pre>
<hr />
<pre>
2612                     alreadyHandled = true;
2613                     break;
2614                 }
2615 
2616                 if (child2.useKind() == SymbolUse) {
2617                     compilePutByValForCellWithSymbol(node, child1, child2, child3);
2618                     alreadyHandled = true;
2619                     break;
2620                 }
2621             }
2622 
2623             SpeculateCellOperand base(this, child1); // Save a register, speculate cell. We&#39;ll probably be right.
2624             JSValueOperand property(this, child2);
2625             JSValueOperand value(this, child3);
2626             GPRReg baseGPR = base.gpr();
2627             JSValueRegs propertyRegs = property.jsValueRegs();
2628             JSValueRegs valueRegs = value.jsValueRegs();
2629 
2630             flushRegisters();
2631             if (node-&gt;op() == PutByValDirect)
<span class="line-modified">2632                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectCellStrict : operationPutByValDirectCellNonStrict, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyRegs, valueRegs);</span>
2633             else
<span class="line-modified">2634                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellStrict : operationPutByValCellNonStrict, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyRegs, valueRegs);</span>
2635             m_jit.exceptionCheck();
2636 
2637             noResult(node);
2638             alreadyHandled = true;
2639             break;
2640         }
2641         default:
2642             break;
2643         }
2644 
2645         if (alreadyHandled)
2646             break;
2647 
2648         SpeculateCellOperand base(this, child1);
2649         SpeculateStrictInt32Operand property(this, child2);
2650 
2651         GPRReg baseReg = base.gpr();
2652         GPRReg propertyReg = property.gpr();
2653 
2654         switch (arrayMode.type()) {
</pre>
<hr />
<pre>
2726 
2727                     lengthDoesNotNeedUpdate.link(&amp;m_jit);
2728                 }
2729                 notHoleValue.link(&amp;m_jit);
2730             }
2731 
2732             // Store the value to the array.
2733             m_jit.store32(valueTagReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
2734             m_jit.store32(valuePayloadReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
2735 
2736             base.use();
2737             property.use();
2738             value.use();
2739             storage.use();
2740 
2741             if (!slowCases.empty()) {
2742                 if (node-&gt;op() == PutByValDirect) {
2743                     addSlowPathGenerator(slowPathCall(
2744                         slowCases, this,
2745                         m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValDirectBeyondArrayBoundsNonStrict,
<span class="line-modified">2746                         NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg, JSValueRegs(valueTagReg, valuePayloadReg)));</span>
2747                 } else {
2748                     addSlowPathGenerator(slowPathCall(
2749                         slowCases, this,
2750                         m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsNonStrict,
<span class="line-modified">2751                         NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg, JSValueRegs(valueTagReg, valuePayloadReg)));</span>
2752                 }
2753             }
2754 
2755             noResult(node, UseChildrenCalledExplicitly);
2756             break;
2757         }
2758 
2759         default: {
2760             TypedArrayType type = arrayMode.typedArrayType();
2761             if (isInt(type))
2762                 compilePutByValForIntTypedArray(base.gpr(), property.gpr(), node, type);
2763             else
2764                 compilePutByValForFloatTypedArray(base.gpr(), property.gpr(), node, type);
2765         } }
2766         break;
2767     }
2768 
2769     case PutByValWithThis: {









































2770         static_assert(GPRInfo::numberOfRegisters &gt;= 8, &quot;We are assuming we have enough registers to make this call without incrementally setting up the arguments.&quot;);
2771 
2772         JSValueOperand base(this, m_jit.graph().varArgChild(node, 0));
2773         JSValueRegs baseRegs = base.jsValueRegs();
2774 
2775         JSValueOperand thisValue(this, m_jit.graph().varArgChild(node, 1));
2776         JSValueRegs thisRegs = thisValue.jsValueRegs();
2777 
2778         JSValueOperand property(this, m_jit.graph().varArgChild(node, 2));
2779         JSValueRegs propertyRegs = property.jsValueRegs();
2780 
2781         JSValueOperand value(this, m_jit.graph().varArgChild(node, 3));
2782         JSValueRegs valueRegs = value.jsValueRegs();
2783 
2784         flushRegisters();
2785         callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValWithThisStrict : operationPutByValWithThis,
<span class="line-modified">2786             TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseRegs, thisRegs, propertyRegs, valueRegs);</span>
2787         m_jit.exceptionCheck();

2788 
2789         noResult(node);
2790         break;
2791     }
2792 
2793     case RegExpExec: {
2794         compileRegExpExec(node);
2795         break;
2796     }
2797 
2798     case RegExpExecNonGlobalOrSticky: {
2799         compileRegExpExecNonGlobalOrSticky(node);
2800         break;
2801     }
2802 
2803     case RegExpMatchFastGlobal: {
2804         compileRegExpMatchFastGlobal(node);
2805         break;
2806     }
2807 
</pre>
<hr />
<pre>
2866                 valuePayloadGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
2867             m_jit.load32(
2868                 MacroAssembler::BaseIndex(storageGPR, valuePayloadGPR, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)),
2869                 valueTagGPR);
2870             MacroAssembler::Jump slowCase = m_jit.branchIfEmpty(valueTagGPR);
2871             m_jit.store32(
2872                 MacroAssembler::TrustedImm32(JSValue::EmptyValueTag),
2873                 MacroAssembler::BaseIndex(storageGPR, valuePayloadGPR, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
2874             m_jit.load32(
2875                 MacroAssembler::BaseIndex(storageGPR, valuePayloadGPR, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)),
2876                 valuePayloadGPR);
2877 
2878             addSlowPathGenerator(
2879                 slowPathMove(
2880                     undefinedCase, this,
2881                     MacroAssembler::TrustedImm32(jsUndefined().tag()), valueTagGPR,
2882                     MacroAssembler::TrustedImm32(jsUndefined().payload()), valuePayloadGPR));
2883             addSlowPathGenerator(
2884                 slowPathCall(
2885                     slowCase, this, operationArrayPopAndRecoverLength,
<span class="line-modified">2886                     JSValueRegs(valueTagGPR, valuePayloadGPR), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR));</span>
2887 
2888             jsValueResult(valueTagGPR, valuePayloadGPR, node);
2889             break;
2890         }
2891 
2892         case Array::Double: {
2893             FPRTemporary temp(this);
2894             FPRReg tempFPR = temp.fpr();
2895 
2896             m_jit.load32(
2897                 MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), valuePayloadGPR);
2898             MacroAssembler::Jump undefinedCase =
2899                 m_jit.branchTest32(MacroAssembler::Zero, valuePayloadGPR);
2900             m_jit.sub32(TrustedImm32(1), valuePayloadGPR);
2901             m_jit.store32(
2902                 valuePayloadGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
2903             m_jit.loadDouble(
2904                 MacroAssembler::BaseIndex(storageGPR, valuePayloadGPR, MacroAssembler::TimesEight),
2905                 tempFPR);
2906             MacroAssembler::Jump slowCase = m_jit.branchIfNaN(tempFPR);
2907             JSValue nan = JSValue(JSValue::EncodeAsDouble, PNaN);
2908             m_jit.store32(
2909                 MacroAssembler::TrustedImm32(nan.u.asBits.tag),
2910                 MacroAssembler::BaseIndex(storageGPR, valuePayloadGPR, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
2911             m_jit.store32(
2912                 MacroAssembler::TrustedImm32(nan.u.asBits.payload),
2913                 MacroAssembler::BaseIndex(storageGPR, valuePayloadGPR, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
2914             boxDouble(tempFPR, valueTagGPR, valuePayloadGPR);
2915 
2916             addSlowPathGenerator(
2917                 slowPathMove(
2918                     undefinedCase, this,
2919                     MacroAssembler::TrustedImm32(jsUndefined().tag()), valueTagGPR,
2920                     MacroAssembler::TrustedImm32(jsUndefined().payload()), valuePayloadGPR));
2921             addSlowPathGenerator(
2922                 slowPathCall(
2923                     slowCase, this, operationArrayPopAndRecoverLength,
<span class="line-modified">2924                     JSValueRegs(valueTagGPR, valuePayloadGPR), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR));</span>
2925 
2926             jsValueResult(valueTagGPR, valuePayloadGPR, node);
2927             break;
2928         }
2929 
2930         case Array::ArrayStorage: {
2931             GPRTemporary storageLength(this);
2932             GPRReg storageLengthGPR = storageLength.gpr();
2933 
2934             m_jit.load32(MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()), storageLengthGPR);
2935 
2936             JITCompiler::JumpList setUndefinedCases;
2937             setUndefinedCases.append(m_jit.branchTest32(MacroAssembler::Zero, storageLengthGPR));
2938 
2939             m_jit.sub32(TrustedImm32(1), storageLengthGPR);
2940 
2941             MacroAssembler::Jump slowCase = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::vectorLengthOffset()));
2942 
2943             m_jit.load32(MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), valueTagGPR);
2944             m_jit.load32(MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)), valuePayloadGPR);
2945 
2946             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()));
2947 
2948             setUndefinedCases.append(m_jit.branchIfEmpty(valueTagGPR));
2949 
2950             m_jit.store32(TrustedImm32(JSValue::EmptyValueTag), MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
2951 
2952             m_jit.sub32(TrustedImm32(1), MacroAssembler::Address(storageGPR, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
2953 
2954             addSlowPathGenerator(
2955                 slowPathMove(
2956                     setUndefinedCases, this,
2957                     MacroAssembler::TrustedImm32(jsUndefined().tag()), valueTagGPR,
2958                     MacroAssembler::TrustedImm32(jsUndefined().payload()), valuePayloadGPR));
2959 
2960             addSlowPathGenerator(
2961                 slowPathCall(
2962                     slowCase, this, operationArrayPop,
<span class="line-modified">2963                     JSValueRegs(valueTagGPR, valuePayloadGPR), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR));</span>
2964 
2965             jsValueResult(valueTagGPR, valuePayloadGPR, node);
2966             break;
2967         }
2968 
2969         default:
2970             CRASH();
2971             break;
2972         }
2973         break;
2974     }
2975 
2976     case ArraySlice: {
2977         compileArraySlice(node);
2978         break;
2979     }
2980 
2981     case ArrayIndexOf: {
2982         compileArrayIndexOf(node);
2983         break;
</pre>
<hr />
<pre>
3078             isBoolean.link(&amp;m_jit);
3079             m_jit.move(TrustedImm32(JSValue::Int32Tag), resultTagGPR);
3080             done.link(&amp;m_jit);
3081 
3082             jsValueResult(resultTagGPR, resultPayloadGPR, node);
3083             break;
3084         }
3085 
3086         default:
3087             RELEASE_ASSERT_NOT_REACHED();
3088             break;
3089         }
3090         break;
3091     }
3092 
3093     case ToPrimitive: {
3094         compileToPrimitive(node);
3095         break;
3096     }
3097 
<span class="line-added">3098     case ToPropertyKey: {</span>
<span class="line-added">3099         compileToPropertyKey(node);</span>
<span class="line-added">3100         break;</span>
<span class="line-added">3101     }</span>
<span class="line-added">3102 </span>
3103     case ToNumber: {
3104         JSValueOperand argument(this, node-&gt;child1());
3105         GPRTemporary resultTag(this, Reuse, argument, TagWord);
3106         GPRTemporary resultPayload(this, Reuse, argument, PayloadWord);
3107 
3108         GPRReg argumentPayloadGPR = argument.payloadGPR();
3109         GPRReg argumentTagGPR = argument.tagGPR();
3110         JSValueRegs argumentRegs = argument.jsValueRegs();
3111         JSValueRegs resultRegs(resultTag.gpr(), resultPayload.gpr());
3112 
3113         argument.use();
3114 
3115         // We have several attempts to remove ToNumber. But ToNumber still exists.
3116         // It means that converting non-numbers to numbers by this ToNumber is not rare.
3117         // Instead of the slow path generator, we emit callOperation here.
3118         if (!(m_state.forNode(node-&gt;child1()).m_type &amp; SpecBytecodeNumber)) {
3119             flushRegisters();
<span class="line-modified">3120             callOperation(operationToNumber, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentRegs);</span>
3121             m_jit.exceptionCheck();
3122         } else {
3123             MacroAssembler::Jump notNumber;
3124             {
3125                 GPRTemporary scratch(this);
3126                 notNumber = m_jit.branchIfNotNumber(argument.jsValueRegs(), scratch.gpr());
3127             }
3128             m_jit.move(argumentTagGPR, resultRegs.tagGPR());
3129             m_jit.move(argumentPayloadGPR, resultRegs.payloadGPR());
3130             MacroAssembler::Jump done = m_jit.jump();
3131 
3132             notNumber.link(&amp;m_jit);
3133             silentSpillAllRegisters(resultRegs);
<span class="line-modified">3134             callOperation(operationToNumber, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentRegs);</span>
3135             silentFillAllRegisters();
3136             m_jit.exceptionCheck();
3137 
3138             done.link(&amp;m_jit);
3139         }
3140 
3141         jsValueResult(resultRegs.tagGPR(), resultRegs.payloadGPR(), node, UseChildrenCalledExplicitly);
3142         break;
3143     }
3144 
<span class="line-added">3145     case ToNumeric: {</span>
<span class="line-added">3146         compileToNumeric(node);</span>
<span class="line-added">3147         break;</span>
<span class="line-added">3148     }</span>
<span class="line-added">3149 </span>
3150     case ToString:
3151     case CallStringConstructor:
3152     case StringValueOf: {
3153         compileToStringOrCallStringConstructorOrStringValueOf(node);
3154         break;
3155     }
3156 
3157     case NewStringObject: {
3158         compileNewStringObject(node);
3159         break;
3160     }
3161 
3162     case NewSymbol: {
3163         compileNewSymbol(node);
3164         break;
3165     }
3166 
3167     case NewArray: {
3168         compileNewArray(node);
3169         break;
</pre>
<hr />
<pre>
3208     case ToThis: {
3209         compileToThis(node);
3210         break;
3211     }
3212 
3213     case ObjectCreate: {
3214         compileObjectCreate(node);
3215         break;
3216     }
3217 
3218     case ObjectKeys: {
3219         compileObjectKeys(node);
3220         break;
3221     }
3222 
3223     case CreateThis: {
3224         compileCreateThis(node);
3225         break;
3226     }
3227 
<span class="line-added">3228     case CreatePromise: {</span>
<span class="line-added">3229         compileCreatePromise(node);</span>
<span class="line-added">3230         break;</span>
<span class="line-added">3231     }</span>
<span class="line-added">3232 </span>
<span class="line-added">3233     case CreateGenerator: {</span>
<span class="line-added">3234         compileCreateGenerator(node);</span>
<span class="line-added">3235         break;</span>
<span class="line-added">3236     }</span>
<span class="line-added">3237 </span>
<span class="line-added">3238     case CreateAsyncGenerator: {</span>
<span class="line-added">3239         compileCreateAsyncGenerator(node);</span>
<span class="line-added">3240         break;</span>
<span class="line-added">3241     }</span>
<span class="line-added">3242 </span>
3243     case NewObject: {
3244         compileNewObject(node);
3245         break;
3246     }
3247 
<span class="line-added">3248     case NewPromise: {</span>
<span class="line-added">3249         compileNewPromise(node);</span>
<span class="line-added">3250         break;</span>
<span class="line-added">3251     }</span>
<span class="line-added">3252 </span>
<span class="line-added">3253     case NewGenerator: {</span>
<span class="line-added">3254         compileNewGenerator(node);</span>
<span class="line-added">3255         break;</span>
<span class="line-added">3256     }</span>
<span class="line-added">3257 </span>
<span class="line-added">3258     case NewAsyncGenerator: {</span>
<span class="line-added">3259         compileNewAsyncGenerator(node);</span>
<span class="line-added">3260         break;</span>
<span class="line-added">3261     }</span>
<span class="line-added">3262 </span>
<span class="line-added">3263     case NewArrayIterator: {</span>
<span class="line-added">3264         compileNewArrayIterator(node);</span>
<span class="line-added">3265         break;</span>
<span class="line-added">3266     }</span>
<span class="line-added">3267 </span>
3268     case GetCallee: {
3269         compileGetCallee(node);
3270         break;
3271     }
3272 
3273     case SetCallee: {
3274         compileSetCallee(node);
3275         break;
3276     }
3277 
3278     case GetArgumentCountIncludingThis: {
3279         compileGetArgumentCountIncludingThis(node);
3280         break;
3281     }
3282 
3283     case SetArgumentCountIncludingThis:
3284         compileSetArgumentCountIncludingThis(node);
3285         break;
3286 
3287     case GetScope:
</pre>
<hr />
<pre>
3293         break;
3294 
3295     case GetGlobalObject:
3296         compileGetGlobalObject(node);
3297         break;
3298 
3299     case GetGlobalThis:
3300         compileGetGlobalThis(node);
3301         break;
3302 
3303     case GetClosureVar: {
3304         compileGetClosureVar(node);
3305         break;
3306     }
3307 
3308     case PutClosureVar: {
3309         compilePutClosureVar(node);
3310         break;
3311     }
3312 
<span class="line-added">3313     case GetInternalField: {</span>
<span class="line-added">3314         compileGetInternalField(node);</span>
<span class="line-added">3315         break;</span>
<span class="line-added">3316     }</span>
<span class="line-added">3317 </span>
<span class="line-added">3318     case PutInternalField: {</span>
<span class="line-added">3319         compilePutInternalField(node);</span>
<span class="line-added">3320         break;</span>
<span class="line-added">3321     }</span>
<span class="line-added">3322 </span>
3323     case TryGetById: {
<span class="line-modified">3324         compileGetById(node, AccessType::TryGetById);</span>
3325         break;
3326     }
3327 
3328     case GetByIdDirect: {
<span class="line-modified">3329         compileGetById(node, AccessType::GetByIdDirect);</span>
3330         break;
3331     }
3332 
3333     case GetByIdDirectFlush: {
<span class="line-modified">3334         compileGetByIdFlush(node, AccessType::GetByIdDirect);</span>
3335         break;
3336     }
3337 
3338     case GetById: {
<span class="line-modified">3339         compileGetById(node, AccessType::GetById);</span>
3340         break;
3341     }
3342 
3343     case GetByIdFlush: {
<span class="line-modified">3344         compileGetByIdFlush(node, AccessType::GetById);</span>
3345         break;
3346     }
3347 
3348     case GetByIdWithThis: {
3349         if (node-&gt;child1().useKind() == CellUse &amp;&amp; node-&gt;child2().useKind() == CellUse) {
3350             SpeculateCellOperand base(this, node-&gt;child1());
3351             SpeculateCellOperand thisValue(this, node-&gt;child2());
3352             GPRTemporary resultTag(this);
3353             GPRTemporary resultPayload(this);
3354 
3355             GPRReg baseGPR = base.gpr();
3356             GPRReg thisGPR = thisValue.gpr();
3357             GPRReg resultTagGPR = resultTag.gpr();
3358             GPRReg resultPayloadGPR = resultPayload.gpr();
3359 
3360             cachedGetByIdWithThis(node-&gt;origin.semantic, InvalidGPRReg, baseGPR, InvalidGPRReg, thisGPR, resultTagGPR, resultPayloadGPR, node-&gt;identifierNumber());
3361 
3362             jsValueResult(resultTagGPR, resultPayloadGPR, node);
3363         } else {
3364             JSValueOperand base(this, node-&gt;child1());
</pre>
<hr />
<pre>
3392     case DeleteById: {
3393         compileDeleteById(node);
3394         break;
3395     }
3396 
3397     case DeleteByVal: {
3398         compileDeleteByVal(node);
3399         break;
3400     }
3401 
3402     case CheckCell: {
3403         compileCheckCell(node);
3404         break;
3405     }
3406 
3407     case CheckNotEmpty: {
3408         compileCheckNotEmpty(node);
3409         break;
3410     }
3411 
<span class="line-modified">3412     case CheckIdent:</span>
<span class="line-modified">3413         compileCheckIdent(node);</span>
3414         break;
3415 
3416     case GetExecutable: {
3417         compileGetExecutable(node);
3418         break;
3419     }
3420 
3421     case CheckStructure: {
3422         compileCheckStructure(node);
3423         break;
3424     }
3425 
3426     case PutStructure: {
3427         RegisteredStructure oldStructure = node-&gt;transition()-&gt;previous;
3428         RegisteredStructure newStructure = node-&gt;transition()-&gt;next;
3429 
3430         m_jit.jitCode()-&gt;common.notifyCompilingStructureTransition(m_jit.graph().m_plan, m_jit.codeBlock(), node);
3431 
3432         SpeculateCellOperand base(this, node-&gt;child1());
3433         GPRReg baseGPR = base.gpr();
</pre>
<hr />
<pre>
3677         booleanResult(result.gpr(), node);
3678         break;
3679     }
3680 
3681     case IsNumber: {
3682         JSValueOperand value(this, node-&gt;child1());
3683         GPRTemporary result(this, Reuse, value, TagWord);
3684 
3685         m_jit.add32(TrustedImm32(1), value.tagGPR(), result.gpr());
3686         m_jit.compare32(JITCompiler::Below, result.gpr(), JITCompiler::TrustedImm32(JSValue::LowestTag + 1), result.gpr());
3687         booleanResult(result.gpr(), node);
3688         break;
3689     }
3690 
3691     case NumberIsInteger: {
3692         JSValueOperand input(this, node-&gt;child1());
3693         JSValueRegs inputRegs = input.jsValueRegs();
3694         flushRegisters();
3695         GPRFlushedCallResult result(this);
3696         GPRReg resultGPR = result.gpr();
<span class="line-modified">3697         callOperation(operationNumberIsInteger, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), inputRegs);</span>
3698         booleanResult(resultGPR, node);
3699         break;
3700     }
3701 
3702     case IsObject: {
3703         compileIsObject(node);
3704         break;
3705     }
3706 
3707     case IsObjectOrNull: {
3708         compileIsObjectOrNull(node);
3709         break;
3710     }
3711 
3712     case IsFunction: {
3713         compileIsFunction(node);
3714         break;
3715     }
3716 
3717     case IsCellWithType: {
</pre>
<hr />
<pre>
3720     }
3721 
3722     case IsTypedArrayView: {
3723         compileIsTypedArrayView(node);
3724         break;
3725     }
3726 
3727     case TypeOf: {
3728         compileTypeOf(node);
3729         break;
3730     }
3731 
3732     case MapHash: {
3733         JSValueOperand input(this, node-&gt;child1());
3734 
3735         JSValueRegs inputRegs = input.jsValueRegs();
3736 
3737         flushRegisters();
3738         GPRFlushedCallResult result(this);
3739         GPRReg resultGPR = result.gpr();
<span class="line-modified">3740         callOperation(operationMapHash, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), inputRegs);</span>
3741         m_jit.exceptionCheck();
3742         int32Result(resultGPR, node);
3743         break;
3744     }
3745 
3746     case NormalizeMapKey: {
3747         compileNormalizeMapKey(node);
3748         break;
3749     }
3750 
3751     case GetMapBucket: {
3752         SpeculateCellOperand map(this, node-&gt;child1());
3753         JSValueOperand key(this, node-&gt;child2());
3754         SpeculateInt32Operand hash(this, node-&gt;child3());
3755 
3756         GPRReg mapGPR = map.gpr();
3757         JSValueRegs keyRegs = key.jsValueRegs();
3758         GPRReg hashGPR = hash.gpr();
3759 
3760         if (node-&gt;child1().useKind() == MapObjectUse)
3761             speculateMapObject(node-&gt;child1(), mapGPR);
3762         else if (node-&gt;child1().useKind() == SetObjectUse)
3763             speculateSetObject(node-&gt;child1(), mapGPR);
3764         else
3765             RELEASE_ASSERT_NOT_REACHED();
3766 
3767         flushRegisters();
3768         GPRFlushedCallResult result(this);
3769         GPRReg resultGPR = result.gpr();
3770         if (node-&gt;child1().useKind() == MapObjectUse)
<span class="line-modified">3771             callOperation(operationJSMapFindBucket, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), mapGPR, keyRegs, hashGPR);</span>
3772         else
<span class="line-modified">3773             callOperation(operationJSSetFindBucket, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), mapGPR, keyRegs, hashGPR);</span>
3774         m_jit.exceptionCheck();
3775         cellResult(resultGPR, node);
3776         break;
3777     }
3778 
3779     case GetMapBucketHead:
3780         compileGetMapBucketHead(node);
3781         break;
3782 
3783     case GetMapBucketNext:
3784         compileGetMapBucketNext(node);
3785         break;
3786 
3787     case LoadKeyFromMapBucket:
3788         compileLoadKeyFromMapBucket(node);
3789         break;
3790 
3791     case LoadValueFromMapBucket:
3792         compileLoadValueFromMapBucket(node);
3793         break;
</pre>
<hr />
<pre>
3822     case Call:
3823     case TailCall:
3824     case TailCallInlinedCaller:
3825     case Construct:
3826     case CallVarargs:
3827     case TailCallVarargs:
3828     case TailCallVarargsInlinedCaller:
3829     case ConstructVarargs:
3830     case CallForwardVarargs:
3831     case TailCallForwardVarargs:
3832     case TailCallForwardVarargsInlinedCaller:
3833     case ConstructForwardVarargs:
3834     case CallEval:
3835     case DirectCall:
3836     case DirectConstruct:
3837     case DirectTailCall:
3838     case DirectTailCallInlinedCaller:
3839         emitCall(node);
3840         break;
3841 
<span class="line-added">3842     case VarargsLength: {</span>
<span class="line-added">3843         compileVarargsLength(node);</span>
<span class="line-added">3844         break;</span>
<span class="line-added">3845     }</span>
<span class="line-added">3846 </span>
3847     case LoadVarargs: {
3848         compileLoadVarargs(node);
3849         break;
3850     }
3851 
3852     case ForwardVarargs: {
3853         compileForwardVarargs(node);
3854         break;
3855     }
3856 
3857     case CreateActivation: {
3858         compileCreateActivation(node);
3859         break;
3860     }
3861 
3862     case PushWithScope: {
3863         compilePushWithScope(node);
3864         break;
3865     }
3866 
</pre>
<hr />
<pre>
3877     case PutToArguments: {
3878         compilePutToArguments(node);
3879         break;
3880     }
3881 
3882     case GetArgument: {
3883         compileGetArgument(node);
3884         break;
3885     }
3886 
3887     case CreateScopedArguments: {
3888         compileCreateScopedArguments(node);
3889         break;
3890     }
3891 
3892     case CreateClonedArguments: {
3893         compileCreateClonedArguments(node);
3894         break;
3895     }
3896 
<span class="line-added">3897     case CreateArgumentsButterfly: {</span>
<span class="line-added">3898         compileCreateArgumentsButterfly(node);</span>
<span class="line-added">3899         break;</span>
<span class="line-added">3900     }</span>
<span class="line-added">3901 </span>
3902     case CreateRest: {
3903         compileCreateRest(node);
3904         break;
3905     }
3906 
3907     case GetRestLength: {
3908         compileGetRestLength(node);
3909         break;
3910     }
3911 
3912     case NewFunction:
3913     case NewGeneratorFunction:
3914     case NewAsyncFunction:
3915     case NewAsyncGeneratorFunction:
3916         compileNewFunction(node);
3917         break;
3918 
3919     case SetFunctionName:
3920         compileSetFunctionName(node);
3921         break;
3922 
3923     case InById:
3924         compileInById(node);
3925         break;
3926 
3927     case InByVal:
3928         compileInByVal(node);
3929         break;
3930 
3931     case HasOwnProperty: {
















3932         SpeculateCellOperand object(this, node-&gt;child1());
3933         GPRTemporary uniquedStringImpl(this);
3934         GPRTemporary temp(this);
3935         GPRTemporary hash(this);
3936         GPRTemporary structureID(this);
3937         GPRTemporary result(this);
3938 
3939         Optional&lt;SpeculateCellOperand&gt; keyAsCell;
3940         Optional&lt;JSValueOperand&gt; keyAsValue;
3941         JSValueRegs keyRegs;
3942         if (node-&gt;child2().useKind() == UntypedUse) {
3943             keyAsValue.emplace(this, node-&gt;child2());
3944             keyRegs = keyAsValue-&gt;jsValueRegs();
3945         } else {
3946             ASSERT(node-&gt;child2().useKind() == StringUse || node-&gt;child2().useKind() == SymbolUse);
3947             keyAsCell.emplace(this, node-&gt;child2());
3948             keyRegs = JSValueRegs::payloadOnly(keyAsCell-&gt;gpr());
3949         }
3950 
3951         GPRReg objectGPR = object.gpr();
</pre>
<hr />
<pre>
4004         m_jit.urshift32(MacroAssembler::TrustedImm32(StringImpl::s_flagCount), hashGPR);
4005         m_jit.load32(MacroAssembler::Address(objectGPR, JSCell::structureIDOffset()), structureIDGPR);
4006         m_jit.add32(structureIDGPR, hashGPR);
4007         m_jit.and32(TrustedImm32(HasOwnPropertyCache::mask), hashGPR);
4008         m_jit.mul32(TrustedImm32(sizeof(HasOwnPropertyCache::Entry)), hashGPR, hashGPR);
4009         ASSERT(vm().hasOwnPropertyCache());
4010         m_jit.move(TrustedImmPtr(vm().hasOwnPropertyCache()), tempGPR);
4011         slowPath.append(m_jit.branchPtr(MacroAssembler::NotEqual,
4012             MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfImpl()), implGPR));
4013         m_jit.load8(MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfResult()), resultGPR);
4014         m_jit.load32(MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfStructureID()), tempGPR);
4015         slowPath.append(m_jit.branch32(MacroAssembler::NotEqual, tempGPR, structureIDGPR));
4016         auto done = m_jit.jump();
4017 
4018         slowPath.link(&amp;m_jit);
4019         silentSpillAllRegisters(resultGPR);
4020         if (node-&gt;child2().useKind() != UntypedUse) {
4021             m_jit.move(MacroAssembler::TrustedImm32(JSValue::CellTag), tempGPR);
4022             keyRegs = JSValueRegs(tempGPR, keyRegs.payloadGPR());
4023         }
<span class="line-modified">4024         callOperation(operationHasOwnProperty, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), objectGPR, keyRegs);</span>
4025         silentFillAllRegisters();
4026         m_jit.exceptionCheck();
4027 
4028         done.link(&amp;m_jit);
4029         booleanResult(resultGPR, node);

4030         break;
4031     }
4032 
4033     case StoreBarrier:
4034     case FencedStoreBarrier: {
4035         compileStoreBarrier(node);
4036         break;
4037     }
4038 
4039     case GetEnumerableLength: {
4040         compileGetEnumerableLength(node);
4041         break;
4042     }
4043     case HasGenericProperty: {
4044         compileHasGenericProperty(node);
4045         break;
4046     }
4047     case HasStructureProperty: {
4048         compileHasStructureProperty(node);
4049         break;
</pre>
<hr />
<pre>
4165         compileCheckSubClass(node);
4166         break;
4167 
4168     case Unreachable:
4169         unreachable(node);
4170         break;
4171 
4172     case ExtractCatchLocal: {
4173         compileExtractCatchLocal(node);
4174         break;
4175     }
4176 
4177     case ClearCatchLocals:
4178         compileClearCatchLocals(node);
4179         break;
4180 
4181     case CheckStructureOrEmpty:
4182         DFG_CRASH(m_jit.graph(), node, &quot;CheckStructureOrEmpty only used in 64-bit DFG&quot;);
4183         break;
4184 
<span class="line-added">4185     case CheckArrayOrEmpty:</span>
<span class="line-added">4186         DFG_CRASH(m_jit.graph(), node, &quot;CheckArrayOrEmpty only used in 64-bit DFG&quot;);</span>
<span class="line-added">4187         break;</span>
<span class="line-added">4188 </span>
4189     case FilterCallLinkStatus:
<span class="line-modified">4190     case FilterGetByStatus:</span>
4191     case FilterPutByIdStatus:
4192     case FilterInByIdStatus:
4193         m_interpreter.filterICStatus(node);
4194         noResult(node);
4195         break;
4196 
4197     case LastNodeType:
4198     case Phi:
4199     case Upsilon:
4200     case ExtractOSREntryLocal:
4201     case CheckTierUpInLoop:
4202     case CheckTierUpAtReturn:
4203     case CheckTierUpAndOSREnter:
4204     case Int52Rep:
4205     case FiatInt52:
4206     case Int52Constant:
4207     case CheckInBounds:
4208     case ArithIMul:
4209     case MultiGetByOffset:
4210     case MultiPutByOffset:
4211     case CheckBadCell:
4212     case BottomValue:
4213     case PhantomNewObject:
4214     case PhantomNewFunction:
4215     case PhantomNewGeneratorFunction:
4216     case PhantomNewAsyncFunction:
4217     case PhantomNewAsyncGeneratorFunction:
4218     case PhantomCreateActivation:
<span class="line-added">4219     case PhantomNewArrayIterator:</span>
4220     case PhantomNewRegexp:
4221     case PutHint:
4222     case CheckStructureImmediate:
4223     case MaterializeCreateActivation:
<span class="line-added">4224     case MaterializeNewInternalFieldObject:</span>
4225     case PutStack:
4226     case KillStack:
4227     case GetStack:
4228     case GetMyArgumentByVal:
4229     case GetMyArgumentByValOutOfBounds:
4230     case GetVectorLength:
4231     case PhantomCreateRest:
4232     case PhantomSpread:
4233     case PhantomNewArrayWithSpread:
4234     case PhantomNewArrayBuffer:
4235     case AtomicsIsLockFree:
4236     case AtomicsAdd:
4237     case AtomicsAnd:
4238     case AtomicsCompareExchange:
4239     case AtomicsExchange:
4240     case AtomicsLoad:
4241     case AtomicsOr:
4242     case AtomicsStore:
4243     case AtomicsSub:
4244     case AtomicsXor:
4245     case IdentityWithProfile:
4246     case InitializeEntrypointArguments:
4247     case EntrySwitch:
4248     case CPUIntrinsic:
4249     case AssertNotEmpty:
4250     case DataViewGetInt:
4251     case DataViewGetFloat:
4252     case DataViewSet:
<span class="line-added">4253     case DateGetInt32OrNaN:</span>
<span class="line-added">4254     case DateGetTime:</span>
<span class="line-added">4255     case StringCodePointAt:</span>
4256         DFG_CRASH(m_jit.graph(), node, &quot;unexpected node in DFG backend&quot;);
4257         break;
4258     }
4259 
4260     if (!m_compileOkay)
4261         return;
4262 
4263     if (node-&gt;hasResult() &amp;&amp; node-&gt;mustGenerate())
4264         use(node);
4265 }
4266 
4267 void SpeculativeJIT::moveTrueTo(GPRReg gpr)
4268 {
4269     m_jit.move(TrustedImm32(1), gpr);
4270 }
4271 
4272 void SpeculativeJIT::moveFalseTo(GPRReg gpr)
4273 {
4274     m_jit.move(TrustedImm32(0), gpr);
4275 }
</pre>
</td>
</tr>
</table>
<center><a href="DFGSpeculativeJIT.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSpeculativeJIT64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSImmutableButterfly.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSImmutableButterfly.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSInternalPromise.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSImmutableButterfly.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (C) 2018 Apple Inc. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (C) 2018-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -36,29 +36,29 @@</span>
  
  class JSImmutableButterfly : public JSCell {
      using Base = JSCell;
  
  public:
<span class="udiff-line-modified-removed">-     static const unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;</span>
<span class="udiff-line-modified-added">+     static constexpr unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;</span>
  
      DECLARE_INFO;
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype, IndexingType indexingType)
      {
          return Structure::create(vm, globalObject, prototype, TypeInfo(JSImmutableButterflyType, StructureFlags), info(), indexingType);
      }
  
<span class="udiff-line-modified-removed">-     ALWAYS_INLINE static JSImmutableButterfly* tryCreate(VM&amp; vm, Structure* structure, unsigned size)</span>
<span class="udiff-line-modified-added">+     ALWAYS_INLINE static JSImmutableButterfly* tryCreate(VM&amp; vm, Structure* structure, unsigned length)</span>
      {
<span class="udiff-line-modified-removed">-         Checked&lt;size_t, RecordOverflow&gt; checkedAllocationSize = allocationSize(size);</span>
<span class="udiff-line-removed">-         if (UNLIKELY(checkedAllocationSize.hasOverflowed()))</span>
<span class="udiff-line-modified-added">+         if (UNLIKELY(length &gt; IndexingHeader::maximumLength))</span>
              return nullptr;
  
<span class="udiff-line-modified-removed">-         void* buffer = tryAllocateCell&lt;JSImmutableButterfly&gt;(vm.heap, checkedAllocationSize.unsafeGet());</span>
<span class="udiff-line-modified-added">+         // Because of the above maximumLength requirement, allocationSize can never overflow.</span>
<span class="udiff-line-added">+         void* buffer = tryAllocateCell&lt;JSImmutableButterfly&gt;(vm.heap, allocationSize(length).unsafeGet());</span>
          if (UNLIKELY(!buffer))
              return nullptr;
<span class="udiff-line-modified-removed">-         JSImmutableButterfly* result = new (NotNull, buffer) JSImmutableButterfly(vm, structure, size);</span>
<span class="udiff-line-modified-added">+         JSImmutableButterfly* result = new (NotNull, buffer) JSImmutableButterfly(vm, structure, length);</span>
          result-&gt;finishCreation(vm);
          return result;
      }
  
      static JSImmutableButterfly* create(VM&amp; vm, IndexingType indexingType, unsigned length)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -66,10 +66,70 @@</span>
          auto* array = tryCreate(vm, vm.immutableButterflyStructures[arrayIndexFromIndexingType(indexingType) - NumberOfIndexingShapes].get(), length);
          RELEASE_ASSERT(array);
          return array;
      }
  
<span class="udiff-line-added">+     ALWAYS_INLINE static JSImmutableButterfly* createFromArray(JSGlobalObject* globalObject, VM&amp; vm, JSArray* array)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         IndexingType indexingType = array-&gt;indexingType() &amp; IndexingShapeMask;</span>
<span class="udiff-line-added">+         unsigned length = array-&gt;length();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // FIXME: JSImmutableButterfly::createFromArray should support re-using non contiguous indexing types as well.</span>
<span class="udiff-line-added">+         if (isCopyOnWrite(indexingType)) {</span>
<span class="udiff-line-added">+             if (hasContiguous(indexingType))</span>
<span class="udiff-line-added">+                 return JSImmutableButterfly::fromButterfly(array-&gt;butterfly());</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         JSImmutableButterfly* result = JSImmutableButterfly::tryCreate(vm, vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get(), length);</span>
<span class="udiff-line-added">+         if (UNLIKELY(!result)) {</span>
<span class="udiff-line-added">+             throwOutOfMemoryError(globalObject, throwScope);</span>
<span class="udiff-line-added">+             return nullptr;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (!length)</span>
<span class="udiff-line-added">+             return result;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (indexingType == ContiguousShape || indexingType == Int32Shape) {</span>
<span class="udiff-line-added">+             for (unsigned i = 0; i &lt; length; i++) {</span>
<span class="udiff-line-added">+                 JSValue value = array-&gt;butterfly()-&gt;contiguous().at(array, i).get();</span>
<span class="udiff-line-added">+                 value = !!value ? value : jsUndefined();</span>
<span class="udiff-line-added">+                 result-&gt;setIndex(vm, i, value);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return result;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (indexingType == DoubleShape) {</span>
<span class="udiff-line-added">+             for (unsigned i = 0; i &lt; length; i++) {</span>
<span class="udiff-line-added">+                 double d = array-&gt;butterfly()-&gt;contiguousDouble().at(array, i);</span>
<span class="udiff-line-added">+                 JSValue value = std::isnan(d) ? jsUndefined() : JSValue(JSValue::EncodeAsDouble, d);</span>
<span class="udiff-line-added">+                 result-&gt;setIndex(vm, i, value);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return result;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         for (unsigned i = 0; i &lt; length; i++) {</span>
<span class="udiff-line-added">+             JSValue value = array-&gt;getDirectIndex(globalObject, i);</span>
<span class="udiff-line-added">+             if (!value) {</span>
<span class="udiff-line-added">+                 // When we see a hole, we assume that it&#39;s safe to assume the get would have returned undefined.</span>
<span class="udiff-line-added">+                 // We may still call into this function when !globalObject-&gt;isArrayIteratorProtocolFastAndNonObservable(),</span>
<span class="udiff-line-added">+                 // however, if we do that, we ensure we&#39;re calling in with an array with all self properties between</span>
<span class="udiff-line-added">+                 // [0, length).</span>
<span class="udiff-line-added">+                 //</span>
<span class="udiff-line-added">+                 // We may also call into this during OSR exit to materialize a phantom fixed array.</span>
<span class="udiff-line-added">+                 // We may be creating a fixed array during OSR exit even after the iterator protocol changed.</span>
<span class="udiff-line-added">+                 // But, when the phantom would have logically been created, the protocol hadn&#39;t been</span>
<span class="udiff-line-added">+                 // changed. Therefore, it is sound to assume empty indices are jsUndefined().</span>
<span class="udiff-line-added">+                 value = jsUndefined();</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
<span class="udiff-line-added">+             result-&gt;setIndex(vm, i, value);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return result;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      unsigned publicLength() const { return m_header.publicLength(); }
      unsigned vectorLength() const { return m_header.vectorLength(); }
      unsigned length() const { return m_header.publicLength(); }
  
      Butterfly* toButterfly() const { return bitwise_cast&lt;Butterfly*&gt;(bitwise_cast&lt;char*&gt;(this) + offsetOfData()); }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -85,11 +145,11 @@</span>
          return jsNumber(value);
      }
  
      static void visitChildren(JSCell*, SlotVisitor&amp;);
  
<span class="udiff-line-modified-removed">-     void copyToArguments(ExecState*, VirtualRegister firstElementDest, unsigned offset, unsigned length);</span>
<span class="udiff-line-modified-added">+     void copyToArguments(JSGlobalObject*, JSValue* firstElementDest, unsigned offset, unsigned length);</span>
  
      template&lt;typename, SubspaceAccess&gt;
      static CompleteSubspace* subspaceFor(VM&amp; vm)
      {
          // We allocate out of the JSValue gigacage as other code expects all butterflies to live there.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -108,16 +168,26 @@</span>
      static constexpr size_t offsetOfData()
      {
          return WTF::roundUpToMultipleOf&lt;sizeof(WriteBarrier&lt;Unknown&gt;)&gt;(sizeof(JSImmutableButterfly));
      }
  
<span class="udiff-line-modified-removed">- private:</span>
<span class="udiff-line-modified-removed">-     static Checked&lt;size_t, RecordOverflow&gt; allocationSize(Checked&lt;size_t, RecordOverflow&gt; numItems)</span>
<span class="udiff-line-modified-added">+     static ptrdiff_t offsetOfPublicLength()</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-added">+         return OBJECT_OFFSETOF(JSImmutableButterfly, m_header) + IndexingHeader::offsetOfPublicLength();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     static ptrdiff_t offsetOfVectorLength()</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         return OBJECT_OFFSETOF(JSImmutableButterfly, m_header) + IndexingHeader::offsetOfVectorLength();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     static Checked&lt;size_t&gt; allocationSize(Checked&lt;size_t&gt; numItems)</span>
      {
          return offsetOfData() + numItems * sizeof(WriteBarrier&lt;Unknown&gt;);
      }
  
<span class="udiff-line-added">+ private:</span>
      JSImmutableButterfly(VM&amp; vm, Structure* structure, unsigned length)
          : Base(vm, structure)
      {
          m_header.setVectorLength(length);
          m_header.setPublicLength(length);
</pre>
<center><a href="JSImmutableButterfly.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSInternalPromise.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
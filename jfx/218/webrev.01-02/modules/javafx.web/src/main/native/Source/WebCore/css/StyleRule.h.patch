diff a/modules/javafx.web/src/main/native/Source/WebCore/css/StyleRule.h b/modules/javafx.web/src/main/native/Source/WebCore/css/StyleRule.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/css/StyleRule.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/css/StyleRule.h
@@ -22,10 +22,11 @@
 #pragma once
 
 #include "CSSSelectorList.h"
 #include "CompiledSelector.h"
 #include "StyleProperties.h"
+#include "StyleRuleType.h"
 #include <wtf/RefPtr.h>
 #include <wtf/TypeCasts.h>
 #include <wtf/UniqueArray.h>
 
 namespace WebCore {
@@ -37,61 +38,45 @@
 class MutableStyleProperties;
 class StyleRuleKeyframe;
 class StyleProperties;
 class StyleRuleKeyframes;
 
+DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(StyleRuleBase);
 class StyleRuleBase : public WTF::RefCountedBase {
-    WTF_MAKE_FAST_ALLOCATED;
+    WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(StyleRuleBase);
 public:
-    enum Type {
-        Unknown, // Not used.
-        Style,
-        Charset, // Not used. These are internally strings owned by the style sheet.
-        Import,
-        Media,
-        FontFace,
-        Page,
-        Keyframes,
-        Keyframe, // Not used. These are internally non-rule StyleRuleKeyframe objects.
-        Namespace,
-        Supports = 12,
-#if ENABLE(CSS_DEVICE_ADAPTATION)
-        Viewport = 15,
-#endif
-    };
-
-    Type type() const { return static_cast<Type>(m_type); }
-
-    bool isCharsetRule() const { return type() == Charset; }
-    bool isFontFaceRule() const { return type() == FontFace; }
-    bool isKeyframesRule() const { return type() == Keyframes; }
-    bool isKeyframeRule() const { return type() == Keyframe; }
-    bool isNamespaceRule() const { return type() == Namespace; }
-    bool isMediaRule() const { return type() == Media; }
-    bool isPageRule() const { return type() == Page; }
-    bool isStyleRule() const { return type() == Style; }
-    bool isSupportsRule() const { return type() == Supports; }
+    StyleRuleType type() const { return static_cast<StyleRuleType>(m_type); }
+
+    bool isCharsetRule() const { return type() == StyleRuleType::Charset; }
+    bool isFontFaceRule() const { return type() == StyleRuleType::FontFace; }
+    bool isKeyframesRule() const { return type() == StyleRuleType::Keyframes; }
+    bool isKeyframeRule() const { return type() == StyleRuleType::Keyframe; }
+    bool isNamespaceRule() const { return type() == StyleRuleType::Namespace; }
+    bool isMediaRule() const { return type() == StyleRuleType::Media; }
+    bool isPageRule() const { return type() == StyleRuleType::Page; }
+    bool isStyleRule() const { return type() == StyleRuleType::Style; }
+    bool isSupportsRule() const { return type() == StyleRuleType::Supports; }
 #if ENABLE(CSS_DEVICE_ADAPTATION)
-    bool isViewportRule() const { return type() == Viewport; }
+    bool isViewportRule() const { return type() == StyleRuleType::Viewport; }
 #endif
-    bool isImportRule() const { return type() == Import; }
+    bool isImportRule() const { return type() == StyleRuleType::Import; }
 
     Ref<StyleRuleBase> copy() const;
 
-    void deref()
+    void deref() const
     {
         if (derefBase())
-            destroy();
+            const_cast<StyleRuleBase&>(*this).destroy();
     }
 
     // FIXME: There shouldn't be any need for the null parent version.
     Ref<CSSRule> createCSSOMWrapper(CSSStyleSheet* parentSheet = nullptr) const;
     Ref<CSSRule> createCSSOMWrapper(CSSRule* parentRule) const;
 
 protected:
-    StyleRuleBase(Type type, bool hasDocumentSecurityOrigin = false)
-        : m_type(type)
+    StyleRuleBase(StyleRuleType type, bool hasDocumentSecurityOrigin = false)
+        : m_type(static_cast<unsigned>(type))
         , m_hasDocumentSecurityOrigin(hasDocumentSecurityOrigin)
     {
     }
 
     StyleRuleBase(const StyleRuleBase& o)
@@ -108,17 +93,18 @@
 private:
     WEBCORE_EXPORT void destroy();
 
     Ref<CSSRule> createCSSOMWrapper(CSSStyleSheet* parentSheet, CSSRule* parentRule) const;
 
-    unsigned m_type : 5;
+    unsigned m_type : 5; // StyleRuleType
     // This is only needed to support getMatchedCSSRules.
     unsigned m_hasDocumentSecurityOrigin : 1;
 };
 
+DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(StyleRule);
 class StyleRule final : public StyleRuleBase {
-    WTF_MAKE_FAST_ALLOCATED;
+    WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(StyleRule);
 public:
     static Ref<StyleRule> create(Ref<StylePropertiesBase>&& properties, bool hasDocumentSecurityOrigin, CSSSelectorList&& selectors)
     {
         return adoptRef(*new StyleRule(WTFMove(properties), hasDocumentSecurityOrigin, WTFMove(selectors)));
     }
@@ -144,11 +130,11 @@
     Ref<StyleRule> copy() const { return adoptRef(*new StyleRule(*this)); }
 
     Vector<RefPtr<StyleRule>> splitIntoMultipleRulesWithMaximumSelectorComponentCount(unsigned) const;
 
 #if ENABLE(CSS_SELECTOR_JIT)
-    CompiledSelector& compiledSelectorForListIndex(unsigned index)
+    CompiledSelector& compiledSelectorForListIndex(unsigned index) const
     {
         if (!m_compiledSelectors)
             m_compiledSelectors = makeUniqueArray<CompiledSelector>(m_selectorList.listSize());
         return m_compiledSelectors[index];
     }
@@ -239,12 +225,12 @@
 
     void wrapperInsertRule(unsigned, Ref<StyleRuleBase>&&);
     void wrapperRemoveRule(unsigned);
 
 protected:
-    StyleRuleGroup(Type, Vector<RefPtr<StyleRuleBase>>&);
-    StyleRuleGroup(Type, std::unique_ptr<DeferredStyleGroupRuleList>&&);
+    StyleRuleGroup(StyleRuleType, Vector<RefPtr<StyleRuleBase>>&);
+    StyleRuleGroup(StyleRuleType, std::unique_ptr<DeferredStyleGroupRuleList>&&);
     StyleRuleGroup(const StyleRuleGroup&);
 
 private:
     void parseDeferredRulesIfNeeded() const;
 

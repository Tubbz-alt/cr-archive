<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/AbstractModuleRecord.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../profiler/ProfilerUID.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AbstractModuleRecord.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/AbstractModuleRecord.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;AbstractModuleRecord.h&quot;
 28 
 29 #include &quot;Error.h&quot;
 30 #include &quot;Interpreter.h&quot;
 31 #include &quot;JSCInlines.h&quot;
 32 #include &quot;JSMap.h&quot;
 33 #include &quot;JSModuleEnvironment.h&quot;
 34 #include &quot;JSModuleNamespaceObject.h&quot;
 35 #include &quot;JSModuleRecord.h&quot;
 36 #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
 37 #include &quot;WebAssemblyModuleRecord.h&quot;
 38 #include &lt;wtf/Optional.h&gt;
 39 
 40 namespace JSC {
 41 namespace AbstractModuleRecordInternal {
<span class="line-modified"> 42 static const bool verbose = false;</span>
 43 } // namespace AbstractModuleRecordInternal
 44 
 45 const ClassInfo AbstractModuleRecord::s_info = { &quot;AbstractModuleRecord&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(AbstractModuleRecord) };
 46 
 47 AbstractModuleRecord::AbstractModuleRecord(VM&amp; vm, Structure* structure, const Identifier&amp; moduleKey)
 48     : Base(vm, structure)
 49     , m_moduleKey(moduleKey)
 50 {
 51 }
 52 
<span class="line-modified"> 53 void AbstractModuleRecord::destroy(JSCell* cell)</span>
<span class="line-removed"> 54 {</span>
<span class="line-removed"> 55     AbstractModuleRecord* thisObject = static_cast&lt;AbstractModuleRecord*&gt;(cell);</span>
<span class="line-removed"> 56     thisObject-&gt;AbstractModuleRecord::~AbstractModuleRecord();</span>
<span class="line-removed"> 57 }</span>
<span class="line-removed"> 58 </span>
<span class="line-removed"> 59 void AbstractModuleRecord::finishCreation(ExecState* exec, VM&amp; vm)</span>
 60 {
 61     Base::finishCreation(vm);
 62     ASSERT(inherits(vm, info()));
 63 
 64     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 65     JSMap* map = JSMap::create(exec, vm, globalObject(vm)-&gt;mapStructure());</span>
 66     scope.releaseAssertNoException();
 67     m_dependenciesMap.set(vm, this, map);
 68     putDirect(vm, Identifier::fromString(vm, &quot;dependenciesMap&quot;_s), m_dependenciesMap.get());
 69 }
 70 
 71 void AbstractModuleRecord::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 72 {
 73     AbstractModuleRecord* thisObject = jsCast&lt;AbstractModuleRecord*&gt;(cell);
 74     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 75     Base::visitChildren(thisObject, visitor);
 76     visitor.append(thisObject-&gt;m_moduleEnvironment);
 77     visitor.append(thisObject-&gt;m_moduleNamespaceObject);
 78     visitor.append(thisObject-&gt;m_dependenciesMap);
 79 }
 80 
 81 void AbstractModuleRecord::appendRequestedModule(const Identifier&amp; moduleName)
 82 {
 83     m_requestedModules.add(moduleName.impl());
 84 }
 85 
</pre>
<hr />
<pre>
124 auto AbstractModuleRecord::ExportEntry::createIndirect(const Identifier&amp; exportName, const Identifier&amp; importName, const Identifier&amp; moduleName) -&gt; ExportEntry
125 {
126     return ExportEntry { Type::Indirect, exportName, moduleName, importName, Identifier() };
127 }
128 
129 auto AbstractModuleRecord::Resolution::notFound() -&gt; Resolution
130 {
131     return Resolution { Type::NotFound, nullptr, Identifier() };
132 }
133 
134 auto AbstractModuleRecord::Resolution::error() -&gt; Resolution
135 {
136     return Resolution { Type::Error, nullptr, Identifier() };
137 }
138 
139 auto AbstractModuleRecord::Resolution::ambiguous() -&gt; Resolution
140 {
141     return Resolution { Type::Ambiguous, nullptr, Identifier() };
142 }
143 
<span class="line-modified">144 AbstractModuleRecord* AbstractModuleRecord::hostResolveImportedModule(ExecState* exec, const Identifier&amp; moduleName)</span>
145 {
<span class="line-modified">146     VM&amp; vm = exec-&gt;vm();</span>
147     auto scope = DECLARE_THROW_SCOPE(vm);
148     JSValue moduleNameValue = identifierToJSValue(vm, moduleName);
<span class="line-modified">149     JSValue entry = m_dependenciesMap-&gt;JSMap::get(exec, moduleNameValue);</span>
150     RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">151     RELEASE_AND_RETURN(scope, jsCast&lt;AbstractModuleRecord*&gt;(entry.get(exec, Identifier::fromString(vm, &quot;module&quot;))));</span>
152 }
153 
<span class="line-modified">154 auto AbstractModuleRecord::resolveImport(ExecState* exec, const Identifier&amp; localName) -&gt; Resolution</span>
155 {
<span class="line-modified">156     VM&amp; vm = exec-&gt;vm();</span>
157     auto scope = DECLARE_THROW_SCOPE(vm);
158 
159     Optional&lt;ImportEntry&gt; optionalImportEntry = tryGetImportEntry(localName.impl());
160     if (!optionalImportEntry)
161         return Resolution::notFound();
162 
163     const ImportEntry&amp; importEntry = *optionalImportEntry;
164     if (importEntry.type == AbstractModuleRecord::ImportEntryType::Namespace)
165         return Resolution::notFound();
166 
<span class="line-modified">167     AbstractModuleRecord* importedModule = hostResolveImportedModule(exec, importEntry.moduleRequest);</span>
168     RETURN_IF_EXCEPTION(scope, Resolution::error());
<span class="line-modified">169     return importedModule-&gt;resolveExport(exec, importEntry.importName);</span>
170 }
171 
172 struct AbstractModuleRecord::ResolveQuery {
173     struct Hash {
174         static unsigned hash(const ResolveQuery&amp;);
175         static bool equal(const ResolveQuery&amp;, const ResolveQuery&amp;);
<span class="line-modified">176         static const bool safeToCompareToEmptyOrDeleted = true;</span>
177     };
178     using HashTraits = WTF::CustomHashTraits&lt;ResolveQuery&gt;;
179 
180     ResolveQuery(AbstractModuleRecord* moduleRecord, UniquedStringImpl* exportName)
181         : moduleRecord(moduleRecord)
182         , exportName(exportName)
183     {
184     }
185 
186     ResolveQuery(AbstractModuleRecord* moduleRecord, const Identifier&amp; exportName)
187         : ResolveQuery(moduleRecord, exportName.impl())
188     {
189     }
190 
191     enum EmptyValueTag { EmptyValue };
192     ResolveQuery(EmptyValueTag)
193     {
194     }
195 
196     enum DeletedValueTag { DeletedValue };
</pre>
<hr />
<pre>
231 }
232 
233 inline bool AbstractModuleRecord::ResolveQuery::Hash::equal(const ResolveQuery&amp; lhs, const ResolveQuery&amp; rhs)
234 {
235     return lhs.moduleRecord == rhs.moduleRecord &amp;&amp; lhs.exportName == rhs.exportName;
236 }
237 
238 auto AbstractModuleRecord::tryGetCachedResolution(UniquedStringImpl* exportName) -&gt; Optional&lt;Resolution&gt;
239 {
240     const auto iterator = m_resolutionCache.find(exportName);
241     if (iterator == m_resolutionCache.end())
242         return WTF::nullopt;
243     return Optional&lt;Resolution&gt;(iterator-&gt;value);
244 }
245 
246 void AbstractModuleRecord::cacheResolution(UniquedStringImpl* exportName, const Resolution&amp; resolution)
247 {
248     m_resolutionCache.add(exportName, resolution);
249 }
250 
<span class="line-modified">251 auto AbstractModuleRecord::resolveExportImpl(ExecState* exec, const ResolveQuery&amp; root) -&gt; Resolution</span>
252 {
<span class="line-modified">253     VM&amp; vm = exec-&gt;vm();</span>
254     auto scope = DECLARE_THROW_SCOPE(vm);
255 
256     if (AbstractModuleRecordInternal::verbose)
257         dataLog(&quot;Resolving &quot;, root, &quot;\n&quot;);
258 
259     // https://tc39.github.io/ecma262/#sec-resolveexport
260 
261     // How to avoid C++ recursion in this function:
262     // This function avoids C++ recursion of the naive ResolveExport implementation.
263     // Flatten the recursion to the loop with the task queue and frames.
264     //
265     // 1. pendingTasks
266     //     We enqueue the recursive resolveExport call to this queue to avoid recursive calls in C++.
267     //     The task has 3 types. (1) Query, (2) IndirectFallback and (3) GatherStars.
268     //     (1) Query
269     //         Querying the resolution to the current module.
270     //     (2) IndirectFallback
271     //         Examine the result of the indirect export resolution. Only when the indirect export resolution fails,
272     //         we look into the star exports. (step 5-a-vi).
273     //     (3) GatherStars
</pre>
<hr />
<pre>
510         RELEASE_ASSERT_NOT_REACHED();
511         return nullptr;
512     };
513 
514     Vector&lt;Task, 8&gt; pendingTasks;
515     ResolveSet resolveSet;
516 
517     Vector&lt;Resolution, 8&gt; frames;
518 
519     bool foundStarLinks = false;
520 
521     frames.append(Resolution::notFound());
522 
523     // Call when the query is not resolved in the current module.
524     // It will enqueue the star resolution requests. Return &quot;false&quot; if the error occurs.
525     auto resolveNonLocal = [&amp;](const ResolveQuery&amp; query) -&gt; bool {
526         // https://tc39.github.io/ecma262/#sec-resolveexport
527         // section 15.2.1.16.3, step 6
528         // If the &quot;default&quot; name is not resolved in the current module, we need to throw an error and stop resolution immediately,
529         // Rationale to this error: A default export cannot be provided by an export *.
<span class="line-modified">530         VM&amp; vm = exec-&gt;vm();</span>
531         auto scope = DECLARE_THROW_SCOPE(vm);
532         if (query.exportName == vm.propertyNames-&gt;defaultKeyword.impl())
533             return false;
534 
535         // Enqueue the task to gather the results of the stars.
536         // And append the new Resolution frame to gather the local result of the stars.
537         pendingTasks.append(Task { query, Type::GatherStars });
538         foundStarLinks = true;
539         frames.append(Resolution::notFound());
540 
541         // Enqueue the tasks in reverse order.
542         for (auto iterator = query.moduleRecord-&gt;starExportEntries().rbegin(), end = query.moduleRecord-&gt;starExportEntries().rend(); iterator != end; ++iterator) {
543             const RefPtr&lt;UniquedStringImpl&gt;&amp; starModuleName = *iterator;
<span class="line-modified">544             AbstractModuleRecord* importedModuleRecord = query.moduleRecord-&gt;hostResolveImportedModule(exec, Identifier::fromUid(vm, starModuleName.get()));</span>
545             RETURN_IF_EXCEPTION(scope, false);
546             pendingTasks.append(Task { ResolveQuery(importedModuleRecord, query.exportName.get()), Type::Query });
547         }
548         return true;
549     };
550 
551     // Return the current resolution value of the top frame.
552     auto currentTop = [&amp;] () -&gt; Resolution&amp; {
553         ASSERT(!frames.isEmpty());
554         return frames.last();
555     };
556 
557     // Merge the given resolution to the current resolution value of the top frame.
558     // If there is ambiguity, return &quot;false&quot;. When the &quot;false&quot; is returned, we should make the result &quot;ambiguous&quot;.
559     auto mergeToCurrentTop = [&amp;] (const Resolution&amp; resolution) -&gt; bool {
560         if (resolution.type == Resolution::Type::NotFound)
561             return true;
562 
563         if (currentTop().type == Resolution::Type::NotFound) {
564             currentTop() = resolution;
</pre>
<hr />
<pre>
611                 bool success = resolveNonLocal(task.query);
612                 EXCEPTION_ASSERT(!scope.exception() || !success);
613                 if (!success)
614                     return Resolution::error();
615                 continue;
616             }
617 
618             const ExportEntry&amp; exportEntry = *optionalExportEntry;
619             switch (exportEntry.type) {
620             case ExportEntry::Type::Local: {
621                 ASSERT(!exportEntry.localName.isNull());
622                 Resolution resolution { Resolution::Type::Resolved, moduleRecord, exportEntry.localName };
623                 //  2. A module that has resolved a local binding is always cacheable.
624                 cacheResolutionForQuery(query, resolution);
625                 if (!mergeToCurrentTop(resolution))
626                     return Resolution::ambiguous();
627                 continue;
628             }
629 
630             case ExportEntry::Type::Indirect: {
<span class="line-modified">631                 AbstractModuleRecord* importedModuleRecord = moduleRecord-&gt;hostResolveImportedModule(exec, exportEntry.moduleName);</span>
632                 RETURN_IF_EXCEPTION(scope, Resolution::error());
633 
634                 // When the imported module does not produce any resolved binding, we need to look into the stars in the *current*
635                 // module. To do this, we append the `IndirectFallback` task to the task queue.
636                 pendingTasks.append(Task { query, Type::IndirectFallback });
637                 // And append the new Resolution frame to check the indirect export will be resolved or not.
638                 frames.append(Resolution::notFound());
639                 pendingTasks.append(Task { ResolveQuery(importedModuleRecord, exportEntry.importName), Type::Query });
640                 continue;
641             }
642             }
643             break;
644         }
645 
646         case Type::IndirectFallback: {
647             Resolution resolution = frames.takeLast();
648 
649             if (resolution.type == Resolution::Type::NotFound) {
650                 // Indirect export entry does not produce any resolved binding.
651                 // So we will investigate the stars.
</pre>
<hr />
<pre>
672 
673         case Type::GatherStars: {
674             Resolution resolution = frames.takeLast();
675             ASSERT_WITH_MESSAGE(resolution.type == Resolution::Type::Resolved || resolution.type == Resolution::Type::NotFound, &quot;When we see Error and Ambiguous, we immediately return from this loop. So here, only Resolved and NotFound comes.&quot;);
676 
677             // Merge the star resolution to the upper frame.
678             if (!mergeToCurrentTop(resolution))
679                 return Resolution::ambiguous();
680             break;
681         }
682         }
683     }
684 
685     ASSERT(frames.size() == 1);
686     //  1. The starting point is always cacheable.
687     if (frames[0].type == Resolution::Type::Resolved)
688         cacheResolutionForQuery(root, frames[0]);
689     return frames[0];
690 }
691 
<span class="line-modified">692 auto AbstractModuleRecord::resolveExport(ExecState* exec, const Identifier&amp; exportName) -&gt; Resolution</span>
693 {
694     // Look up the cached resolution first before entering the resolving loop, since the loop setup takes some cost.
695     if (Optional&lt;Resolution&gt; cachedResolution = tryGetCachedResolution(exportName.impl()))
696         return *cachedResolution;
<span class="line-modified">697     return resolveExportImpl(exec, ResolveQuery(this, exportName.impl()));</span>
698 }
699 
<span class="line-modified">700 static void getExportedNames(ExecState* exec, AbstractModuleRecord* root, IdentifierSet&amp; exportedNames)</span>
701 {
<span class="line-modified">702     VM&amp; vm = exec-&gt;vm();</span>
703     auto scope = DECLARE_THROW_SCOPE(vm);
704 
705     HashSet&lt;AbstractModuleRecord*&gt; exportStarSet;
706     Vector&lt;AbstractModuleRecord*, 8&gt; pendingModules;
707 
708     pendingModules.append(root);
709 
710     while (!pendingModules.isEmpty()) {
711         AbstractModuleRecord* moduleRecord = pendingModules.takeLast();
712         if (exportStarSet.contains(moduleRecord))
713             continue;
714         exportStarSet.add(moduleRecord);
715 
716         for (const auto&amp; pair : moduleRecord-&gt;exportEntries()) {
717             const AbstractModuleRecord::ExportEntry&amp; exportEntry = pair.value;
718             if (moduleRecord == root || vm.propertyNames-&gt;defaultKeyword != exportEntry.exportName)
719                 exportedNames.add(exportEntry.exportName.impl());
720         }
721 
722         for (const auto&amp; starModuleName : moduleRecord-&gt;starExportEntries()) {
<span class="line-modified">723             AbstractModuleRecord* requestedModuleRecord = moduleRecord-&gt;hostResolveImportedModule(exec, Identifier::fromUid(vm, starModuleName.get()));</span>
724             RETURN_IF_EXCEPTION(scope, void());
725             pendingModules.append(requestedModuleRecord);
726         }
727     }
728 }
729 
<span class="line-modified">730 JSModuleNamespaceObject* AbstractModuleRecord::getModuleNamespace(ExecState* exec)</span>
731 {
<span class="line-modified">732     VM&amp; vm = exec-&gt;vm();</span>
733     auto scope = DECLARE_THROW_SCOPE(vm);
734 
735     // http://www.ecma-international.org/ecma-262/6.0/#sec-getmodulenamespace
736     if (m_moduleNamespaceObject)
737         return m_moduleNamespaceObject.get();
738 
<span class="line-removed">739     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
740     IdentifierSet exportedNames;
<span class="line-modified">741     getExportedNames(exec, this, exportedNames);</span>
742     RETURN_IF_EXCEPTION(scope, nullptr);
743 
744     Vector&lt;std::pair&lt;Identifier, Resolution&gt;&gt; resolutions;
745     for (auto&amp; name : exportedNames) {
746         Identifier ident = Identifier::fromUid(vm, name.get());
<span class="line-modified">747         const Resolution resolution = resolveExport(exec, ident);</span>
748         RETURN_IF_EXCEPTION(scope, nullptr);
749         switch (resolution.type) {
750         case Resolution::Type::NotFound:
<span class="line-modified">751             throwSyntaxError(exec, scope, makeString(&quot;Exported binding name &#39;&quot;, String(name.get()), &quot;&#39; is not found.&quot;));</span>
752             return nullptr;
753 
754         case Resolution::Type::Error:
<span class="line-modified">755             throwSyntaxError(exec, scope, makeString(&quot;Exported binding name &#39;default&#39; cannot be resolved by star export entries.&quot;));</span>
756             return nullptr;
757 
758         case Resolution::Type::Ambiguous:
759             break;
760 
761         case Resolution::Type::Resolved:
762             resolutions.append({ WTFMove(ident), resolution });
763             break;
764         }
765     }
766 
<span class="line-modified">767     auto* moduleNamespaceObject = JSModuleNamespaceObject::create(exec, globalObject, globalObject-&gt;moduleNamespaceObjectStructure(), this, WTFMove(resolutions));</span>
768     RETURN_IF_EXCEPTION(scope, nullptr);
769     m_moduleNamespaceObject.set(vm, this, moduleNamespaceObject);
770     return moduleNamespaceObject;
771 }
772 
<span class="line-modified">773 void AbstractModuleRecord::link(ExecState* exec, JSValue scriptFetcher)</span>
774 {
<span class="line-modified">775     VM&amp; vm = exec-&gt;vm();</span>
776     if (auto* jsModuleRecord = jsDynamicCast&lt;JSModuleRecord*&gt;(vm, this))
<span class="line-modified">777         return jsModuleRecord-&gt;link(exec, scriptFetcher);</span>
778 #if ENABLE(WEBASSEMBLY)
779     if (auto* wasmModuleRecord = jsDynamicCast&lt;WebAssemblyModuleRecord*&gt;(vm, this))
<span class="line-modified">780         return wasmModuleRecord-&gt;link(exec, scriptFetcher, nullptr, Wasm::CreationMode::FromModuleLoader);</span>
781 #endif
782     RELEASE_ASSERT_NOT_REACHED();
783 }
784 
<span class="line-modified">785 JS_EXPORT_PRIVATE JSValue AbstractModuleRecord::evaluate(ExecState* exec)</span>
786 {
<span class="line-modified">787     VM&amp; vm = exec-&gt;vm();</span>
788     if (auto* jsModuleRecord = jsDynamicCast&lt;JSModuleRecord*&gt;(vm, this))
<span class="line-modified">789         return jsModuleRecord-&gt;evaluate(exec);</span>
790 #if ENABLE(WEBASSEMBLY)
791     if (auto* wasmModuleRecord = jsDynamicCast&lt;WebAssemblyModuleRecord*&gt;(vm, this))
<span class="line-modified">792         return wasmModuleRecord-&gt;evaluate(exec);</span>
793 #endif
794     RELEASE_ASSERT_NOT_REACHED();
795     return jsUndefined();
796 }
797 
798 static String printableName(const RefPtr&lt;UniquedStringImpl&gt;&amp; uid)
799 {
800     if (uid-&gt;isSymbol())
801         return uid.get();
802     return WTF::makeString(&quot;&#39;&quot;, String(uid.get()), &quot;&#39;&quot;);
803 }
804 
805 static String printableName(const Identifier&amp; ident)
806 {
807     return printableName(ident.impl());
808 }
809 
810 void AbstractModuleRecord::dump()
811 {
812     dataLog(&quot;\nAnalyzing ModuleRecord key(&quot;, printableName(m_moduleKey), &quot;)\n&quot;);
</pre>
</td>
<td>
<hr />
<pre>
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;AbstractModuleRecord.h&quot;
 28 
 29 #include &quot;Error.h&quot;
 30 #include &quot;Interpreter.h&quot;
 31 #include &quot;JSCInlines.h&quot;
 32 #include &quot;JSMap.h&quot;
 33 #include &quot;JSModuleEnvironment.h&quot;
 34 #include &quot;JSModuleNamespaceObject.h&quot;
 35 #include &quot;JSModuleRecord.h&quot;
 36 #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
 37 #include &quot;WebAssemblyModuleRecord.h&quot;
 38 #include &lt;wtf/Optional.h&gt;
 39 
 40 namespace JSC {
 41 namespace AbstractModuleRecordInternal {
<span class="line-modified"> 42 static constexpr bool verbose = false;</span>
 43 } // namespace AbstractModuleRecordInternal
 44 
 45 const ClassInfo AbstractModuleRecord::s_info = { &quot;AbstractModuleRecord&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(AbstractModuleRecord) };
 46 
 47 AbstractModuleRecord::AbstractModuleRecord(VM&amp; vm, Structure* structure, const Identifier&amp; moduleKey)
 48     : Base(vm, structure)
 49     , m_moduleKey(moduleKey)
 50 {
 51 }
 52 
<span class="line-modified"> 53 void AbstractModuleRecord::finishCreation(JSGlobalObject* globalObject, VM&amp; vm)</span>






 54 {
 55     Base::finishCreation(vm);
 56     ASSERT(inherits(vm, info()));
 57 
 58     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 59     JSMap* map = JSMap::create(globalObject, vm, globalObject-&gt;mapStructure());</span>
 60     scope.releaseAssertNoException();
 61     m_dependenciesMap.set(vm, this, map);
 62     putDirect(vm, Identifier::fromString(vm, &quot;dependenciesMap&quot;_s), m_dependenciesMap.get());
 63 }
 64 
 65 void AbstractModuleRecord::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 66 {
 67     AbstractModuleRecord* thisObject = jsCast&lt;AbstractModuleRecord*&gt;(cell);
 68     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 69     Base::visitChildren(thisObject, visitor);
 70     visitor.append(thisObject-&gt;m_moduleEnvironment);
 71     visitor.append(thisObject-&gt;m_moduleNamespaceObject);
 72     visitor.append(thisObject-&gt;m_dependenciesMap);
 73 }
 74 
 75 void AbstractModuleRecord::appendRequestedModule(const Identifier&amp; moduleName)
 76 {
 77     m_requestedModules.add(moduleName.impl());
 78 }
 79 
</pre>
<hr />
<pre>
118 auto AbstractModuleRecord::ExportEntry::createIndirect(const Identifier&amp; exportName, const Identifier&amp; importName, const Identifier&amp; moduleName) -&gt; ExportEntry
119 {
120     return ExportEntry { Type::Indirect, exportName, moduleName, importName, Identifier() };
121 }
122 
123 auto AbstractModuleRecord::Resolution::notFound() -&gt; Resolution
124 {
125     return Resolution { Type::NotFound, nullptr, Identifier() };
126 }
127 
128 auto AbstractModuleRecord::Resolution::error() -&gt; Resolution
129 {
130     return Resolution { Type::Error, nullptr, Identifier() };
131 }
132 
133 auto AbstractModuleRecord::Resolution::ambiguous() -&gt; Resolution
134 {
135     return Resolution { Type::Ambiguous, nullptr, Identifier() };
136 }
137 
<span class="line-modified">138 AbstractModuleRecord* AbstractModuleRecord::hostResolveImportedModule(JSGlobalObject* globalObject, const Identifier&amp; moduleName)</span>
139 {
<span class="line-modified">140     VM&amp; vm = globalObject-&gt;vm();</span>
141     auto scope = DECLARE_THROW_SCOPE(vm);
142     JSValue moduleNameValue = identifierToJSValue(vm, moduleName);
<span class="line-modified">143     JSValue entry = m_dependenciesMap-&gt;JSMap::get(globalObject, moduleNameValue);</span>
144     RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">145     RELEASE_AND_RETURN(scope, jsCast&lt;AbstractModuleRecord*&gt;(entry.get(globalObject, Identifier::fromString(vm, &quot;module&quot;))));</span>
146 }
147 
<span class="line-modified">148 auto AbstractModuleRecord::resolveImport(JSGlobalObject* globalObject, const Identifier&amp; localName) -&gt; Resolution</span>
149 {
<span class="line-modified">150     VM&amp; vm = globalObject-&gt;vm();</span>
151     auto scope = DECLARE_THROW_SCOPE(vm);
152 
153     Optional&lt;ImportEntry&gt; optionalImportEntry = tryGetImportEntry(localName.impl());
154     if (!optionalImportEntry)
155         return Resolution::notFound();
156 
157     const ImportEntry&amp; importEntry = *optionalImportEntry;
158     if (importEntry.type == AbstractModuleRecord::ImportEntryType::Namespace)
159         return Resolution::notFound();
160 
<span class="line-modified">161     AbstractModuleRecord* importedModule = hostResolveImportedModule(globalObject, importEntry.moduleRequest);</span>
162     RETURN_IF_EXCEPTION(scope, Resolution::error());
<span class="line-modified">163     return importedModule-&gt;resolveExport(globalObject, importEntry.importName);</span>
164 }
165 
166 struct AbstractModuleRecord::ResolveQuery {
167     struct Hash {
168         static unsigned hash(const ResolveQuery&amp;);
169         static bool equal(const ResolveQuery&amp;, const ResolveQuery&amp;);
<span class="line-modified">170         static constexpr bool safeToCompareToEmptyOrDeleted = true;</span>
171     };
172     using HashTraits = WTF::CustomHashTraits&lt;ResolveQuery&gt;;
173 
174     ResolveQuery(AbstractModuleRecord* moduleRecord, UniquedStringImpl* exportName)
175         : moduleRecord(moduleRecord)
176         , exportName(exportName)
177     {
178     }
179 
180     ResolveQuery(AbstractModuleRecord* moduleRecord, const Identifier&amp; exportName)
181         : ResolveQuery(moduleRecord, exportName.impl())
182     {
183     }
184 
185     enum EmptyValueTag { EmptyValue };
186     ResolveQuery(EmptyValueTag)
187     {
188     }
189 
190     enum DeletedValueTag { DeletedValue };
</pre>
<hr />
<pre>
225 }
226 
227 inline bool AbstractModuleRecord::ResolveQuery::Hash::equal(const ResolveQuery&amp; lhs, const ResolveQuery&amp; rhs)
228 {
229     return lhs.moduleRecord == rhs.moduleRecord &amp;&amp; lhs.exportName == rhs.exportName;
230 }
231 
232 auto AbstractModuleRecord::tryGetCachedResolution(UniquedStringImpl* exportName) -&gt; Optional&lt;Resolution&gt;
233 {
234     const auto iterator = m_resolutionCache.find(exportName);
235     if (iterator == m_resolutionCache.end())
236         return WTF::nullopt;
237     return Optional&lt;Resolution&gt;(iterator-&gt;value);
238 }
239 
240 void AbstractModuleRecord::cacheResolution(UniquedStringImpl* exportName, const Resolution&amp; resolution)
241 {
242     m_resolutionCache.add(exportName, resolution);
243 }
244 
<span class="line-modified">245 auto AbstractModuleRecord::resolveExportImpl(JSGlobalObject* globalObject, const ResolveQuery&amp; root) -&gt; Resolution</span>
246 {
<span class="line-modified">247     VM&amp; vm = globalObject-&gt;vm();</span>
248     auto scope = DECLARE_THROW_SCOPE(vm);
249 
250     if (AbstractModuleRecordInternal::verbose)
251         dataLog(&quot;Resolving &quot;, root, &quot;\n&quot;);
252 
253     // https://tc39.github.io/ecma262/#sec-resolveexport
254 
255     // How to avoid C++ recursion in this function:
256     // This function avoids C++ recursion of the naive ResolveExport implementation.
257     // Flatten the recursion to the loop with the task queue and frames.
258     //
259     // 1. pendingTasks
260     //     We enqueue the recursive resolveExport call to this queue to avoid recursive calls in C++.
261     //     The task has 3 types. (1) Query, (2) IndirectFallback and (3) GatherStars.
262     //     (1) Query
263     //         Querying the resolution to the current module.
264     //     (2) IndirectFallback
265     //         Examine the result of the indirect export resolution. Only when the indirect export resolution fails,
266     //         we look into the star exports. (step 5-a-vi).
267     //     (3) GatherStars
</pre>
<hr />
<pre>
504         RELEASE_ASSERT_NOT_REACHED();
505         return nullptr;
506     };
507 
508     Vector&lt;Task, 8&gt; pendingTasks;
509     ResolveSet resolveSet;
510 
511     Vector&lt;Resolution, 8&gt; frames;
512 
513     bool foundStarLinks = false;
514 
515     frames.append(Resolution::notFound());
516 
517     // Call when the query is not resolved in the current module.
518     // It will enqueue the star resolution requests. Return &quot;false&quot; if the error occurs.
519     auto resolveNonLocal = [&amp;](const ResolveQuery&amp; query) -&gt; bool {
520         // https://tc39.github.io/ecma262/#sec-resolveexport
521         // section 15.2.1.16.3, step 6
522         // If the &quot;default&quot; name is not resolved in the current module, we need to throw an error and stop resolution immediately,
523         // Rationale to this error: A default export cannot be provided by an export *.
<span class="line-modified">524         VM&amp; vm = globalObject-&gt;vm();</span>
525         auto scope = DECLARE_THROW_SCOPE(vm);
526         if (query.exportName == vm.propertyNames-&gt;defaultKeyword.impl())
527             return false;
528 
529         // Enqueue the task to gather the results of the stars.
530         // And append the new Resolution frame to gather the local result of the stars.
531         pendingTasks.append(Task { query, Type::GatherStars });
532         foundStarLinks = true;
533         frames.append(Resolution::notFound());
534 
535         // Enqueue the tasks in reverse order.
536         for (auto iterator = query.moduleRecord-&gt;starExportEntries().rbegin(), end = query.moduleRecord-&gt;starExportEntries().rend(); iterator != end; ++iterator) {
537             const RefPtr&lt;UniquedStringImpl&gt;&amp; starModuleName = *iterator;
<span class="line-modified">538             AbstractModuleRecord* importedModuleRecord = query.moduleRecord-&gt;hostResolveImportedModule(globalObject, Identifier::fromUid(vm, starModuleName.get()));</span>
539             RETURN_IF_EXCEPTION(scope, false);
540             pendingTasks.append(Task { ResolveQuery(importedModuleRecord, query.exportName.get()), Type::Query });
541         }
542         return true;
543     };
544 
545     // Return the current resolution value of the top frame.
546     auto currentTop = [&amp;] () -&gt; Resolution&amp; {
547         ASSERT(!frames.isEmpty());
548         return frames.last();
549     };
550 
551     // Merge the given resolution to the current resolution value of the top frame.
552     // If there is ambiguity, return &quot;false&quot;. When the &quot;false&quot; is returned, we should make the result &quot;ambiguous&quot;.
553     auto mergeToCurrentTop = [&amp;] (const Resolution&amp; resolution) -&gt; bool {
554         if (resolution.type == Resolution::Type::NotFound)
555             return true;
556 
557         if (currentTop().type == Resolution::Type::NotFound) {
558             currentTop() = resolution;
</pre>
<hr />
<pre>
605                 bool success = resolveNonLocal(task.query);
606                 EXCEPTION_ASSERT(!scope.exception() || !success);
607                 if (!success)
608                     return Resolution::error();
609                 continue;
610             }
611 
612             const ExportEntry&amp; exportEntry = *optionalExportEntry;
613             switch (exportEntry.type) {
614             case ExportEntry::Type::Local: {
615                 ASSERT(!exportEntry.localName.isNull());
616                 Resolution resolution { Resolution::Type::Resolved, moduleRecord, exportEntry.localName };
617                 //  2. A module that has resolved a local binding is always cacheable.
618                 cacheResolutionForQuery(query, resolution);
619                 if (!mergeToCurrentTop(resolution))
620                     return Resolution::ambiguous();
621                 continue;
622             }
623 
624             case ExportEntry::Type::Indirect: {
<span class="line-modified">625                 AbstractModuleRecord* importedModuleRecord = moduleRecord-&gt;hostResolveImportedModule(globalObject, exportEntry.moduleName);</span>
626                 RETURN_IF_EXCEPTION(scope, Resolution::error());
627 
628                 // When the imported module does not produce any resolved binding, we need to look into the stars in the *current*
629                 // module. To do this, we append the `IndirectFallback` task to the task queue.
630                 pendingTasks.append(Task { query, Type::IndirectFallback });
631                 // And append the new Resolution frame to check the indirect export will be resolved or not.
632                 frames.append(Resolution::notFound());
633                 pendingTasks.append(Task { ResolveQuery(importedModuleRecord, exportEntry.importName), Type::Query });
634                 continue;
635             }
636             }
637             break;
638         }
639 
640         case Type::IndirectFallback: {
641             Resolution resolution = frames.takeLast();
642 
643             if (resolution.type == Resolution::Type::NotFound) {
644                 // Indirect export entry does not produce any resolved binding.
645                 // So we will investigate the stars.
</pre>
<hr />
<pre>
666 
667         case Type::GatherStars: {
668             Resolution resolution = frames.takeLast();
669             ASSERT_WITH_MESSAGE(resolution.type == Resolution::Type::Resolved || resolution.type == Resolution::Type::NotFound, &quot;When we see Error and Ambiguous, we immediately return from this loop. So here, only Resolved and NotFound comes.&quot;);
670 
671             // Merge the star resolution to the upper frame.
672             if (!mergeToCurrentTop(resolution))
673                 return Resolution::ambiguous();
674             break;
675         }
676         }
677     }
678 
679     ASSERT(frames.size() == 1);
680     //  1. The starting point is always cacheable.
681     if (frames[0].type == Resolution::Type::Resolved)
682         cacheResolutionForQuery(root, frames[0]);
683     return frames[0];
684 }
685 
<span class="line-modified">686 auto AbstractModuleRecord::resolveExport(JSGlobalObject* globalObject, const Identifier&amp; exportName) -&gt; Resolution</span>
687 {
688     // Look up the cached resolution first before entering the resolving loop, since the loop setup takes some cost.
689     if (Optional&lt;Resolution&gt; cachedResolution = tryGetCachedResolution(exportName.impl()))
690         return *cachedResolution;
<span class="line-modified">691     return resolveExportImpl(globalObject, ResolveQuery(this, exportName.impl()));</span>
692 }
693 
<span class="line-modified">694 static void getExportedNames(JSGlobalObject* globalObject, AbstractModuleRecord* root, IdentifierSet&amp; exportedNames)</span>
695 {
<span class="line-modified">696     VM&amp; vm = globalObject-&gt;vm();</span>
697     auto scope = DECLARE_THROW_SCOPE(vm);
698 
699     HashSet&lt;AbstractModuleRecord*&gt; exportStarSet;
700     Vector&lt;AbstractModuleRecord*, 8&gt; pendingModules;
701 
702     pendingModules.append(root);
703 
704     while (!pendingModules.isEmpty()) {
705         AbstractModuleRecord* moduleRecord = pendingModules.takeLast();
706         if (exportStarSet.contains(moduleRecord))
707             continue;
708         exportStarSet.add(moduleRecord);
709 
710         for (const auto&amp; pair : moduleRecord-&gt;exportEntries()) {
711             const AbstractModuleRecord::ExportEntry&amp; exportEntry = pair.value;
712             if (moduleRecord == root || vm.propertyNames-&gt;defaultKeyword != exportEntry.exportName)
713                 exportedNames.add(exportEntry.exportName.impl());
714         }
715 
716         for (const auto&amp; starModuleName : moduleRecord-&gt;starExportEntries()) {
<span class="line-modified">717             AbstractModuleRecord* requestedModuleRecord = moduleRecord-&gt;hostResolveImportedModule(globalObject, Identifier::fromUid(vm, starModuleName.get()));</span>
718             RETURN_IF_EXCEPTION(scope, void());
719             pendingModules.append(requestedModuleRecord);
720         }
721     }
722 }
723 
<span class="line-modified">724 JSModuleNamespaceObject* AbstractModuleRecord::getModuleNamespace(JSGlobalObject* globalObject)</span>
725 {
<span class="line-modified">726     VM&amp; vm = globalObject-&gt;vm();</span>
727     auto scope = DECLARE_THROW_SCOPE(vm);
728 
729     // http://www.ecma-international.org/ecma-262/6.0/#sec-getmodulenamespace
730     if (m_moduleNamespaceObject)
731         return m_moduleNamespaceObject.get();
732 

733     IdentifierSet exportedNames;
<span class="line-modified">734     getExportedNames(globalObject, this, exportedNames);</span>
735     RETURN_IF_EXCEPTION(scope, nullptr);
736 
737     Vector&lt;std::pair&lt;Identifier, Resolution&gt;&gt; resolutions;
738     for (auto&amp; name : exportedNames) {
739         Identifier ident = Identifier::fromUid(vm, name.get());
<span class="line-modified">740         const Resolution resolution = resolveExport(globalObject, ident);</span>
741         RETURN_IF_EXCEPTION(scope, nullptr);
742         switch (resolution.type) {
743         case Resolution::Type::NotFound:
<span class="line-modified">744             throwSyntaxError(globalObject, scope, makeString(&quot;Exported binding name &#39;&quot;, String(name.get()), &quot;&#39; is not found.&quot;));</span>
745             return nullptr;
746 
747         case Resolution::Type::Error:
<span class="line-modified">748             throwSyntaxError(globalObject, scope, makeString(&quot;Exported binding name &#39;default&#39; cannot be resolved by star export entries.&quot;));</span>
749             return nullptr;
750 
751         case Resolution::Type::Ambiguous:
752             break;
753 
754         case Resolution::Type::Resolved:
755             resolutions.append({ WTFMove(ident), resolution });
756             break;
757         }
758     }
759 
<span class="line-modified">760     auto* moduleNamespaceObject = JSModuleNamespaceObject::create(globalObject, globalObject-&gt;moduleNamespaceObjectStructure(), this, WTFMove(resolutions));</span>
761     RETURN_IF_EXCEPTION(scope, nullptr);
762     m_moduleNamespaceObject.set(vm, this, moduleNamespaceObject);
763     return moduleNamespaceObject;
764 }
765 
<span class="line-modified">766 void AbstractModuleRecord::link(JSGlobalObject* globalObject, JSValue scriptFetcher)</span>
767 {
<span class="line-modified">768     VM&amp; vm = globalObject-&gt;vm();</span>
769     if (auto* jsModuleRecord = jsDynamicCast&lt;JSModuleRecord*&gt;(vm, this))
<span class="line-modified">770         return jsModuleRecord-&gt;link(globalObject, scriptFetcher);</span>
771 #if ENABLE(WEBASSEMBLY)
772     if (auto* wasmModuleRecord = jsDynamicCast&lt;WebAssemblyModuleRecord*&gt;(vm, this))
<span class="line-modified">773         return wasmModuleRecord-&gt;link(globalObject, scriptFetcher, nullptr, Wasm::CreationMode::FromModuleLoader);</span>
774 #endif
775     RELEASE_ASSERT_NOT_REACHED();
776 }
777 
<span class="line-modified">778 JS_EXPORT_PRIVATE JSValue AbstractModuleRecord::evaluate(JSGlobalObject* globalObject)</span>
779 {
<span class="line-modified">780     VM&amp; vm = globalObject-&gt;vm();</span>
781     if (auto* jsModuleRecord = jsDynamicCast&lt;JSModuleRecord*&gt;(vm, this))
<span class="line-modified">782         return jsModuleRecord-&gt;evaluate(globalObject);</span>
783 #if ENABLE(WEBASSEMBLY)
784     if (auto* wasmModuleRecord = jsDynamicCast&lt;WebAssemblyModuleRecord*&gt;(vm, this))
<span class="line-modified">785         return wasmModuleRecord-&gt;evaluate(globalObject);</span>
786 #endif
787     RELEASE_ASSERT_NOT_REACHED();
788     return jsUndefined();
789 }
790 
791 static String printableName(const RefPtr&lt;UniquedStringImpl&gt;&amp; uid)
792 {
793     if (uid-&gt;isSymbol())
794         return uid.get();
795     return WTF::makeString(&quot;&#39;&quot;, String(uid.get()), &quot;&#39;&quot;);
796 }
797 
798 static String printableName(const Identifier&amp; ident)
799 {
800     return printableName(ident.impl());
801 }
802 
803 void AbstractModuleRecord::dump()
804 {
805     dataLog(&quot;\nAnalyzing ModuleRecord key(&quot;, printableName(m_moduleKey), &quot;)\n&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="../profiler/ProfilerUID.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AbstractModuleRecord.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
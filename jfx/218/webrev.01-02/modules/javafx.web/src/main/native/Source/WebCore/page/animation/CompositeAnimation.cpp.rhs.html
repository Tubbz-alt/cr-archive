<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/page/animation/CompositeAnimation.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2007 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;CompositeAnimation.h&quot;
 31 
 32 #include &quot;CSSAnimationControllerPrivate.h&quot;
 33 #include &quot;CSSPropertyAnimation.h&quot;
 34 #include &quot;CSSPropertyNames.h&quot;
 35 #include &quot;ImplicitAnimation.h&quot;
 36 #include &quot;KeyframeAnimation.h&quot;
 37 #include &quot;Logging.h&quot;
 38 #include &quot;RenderElement.h&quot;
 39 #include &quot;RenderStyle.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 40 #include &quot;StyleAdjuster.h&quot;</span>
 41 #include &lt;wtf/NeverDestroyed.h&gt;
 42 #include &lt;wtf/text/CString.h&gt;
 43 
 44 namespace WebCore {
 45 
 46 CompositeAnimation::CompositeAnimation(CSSAnimationControllerPrivate&amp; animationController)
 47     : m_animationController(animationController)
 48 {
 49     m_suspended = m_animationController.isSuspended() &amp;&amp; !m_animationController.allowsNewAnimationsWhileSuspended();
 50 }
 51 
 52 CompositeAnimation::~CompositeAnimation()
 53 {
 54     // Toss the refs to all animations, but make sure we remove them from
 55     // any waiting lists first.
 56 
 57     clearElement();
 58     m_transitions.clear();
 59     m_keyframeAnimations.clear();
 60 }
 61 
 62 void CompositeAnimation::clearElement()
 63 {
 64     if (!m_transitions.isEmpty()) {
 65         // Clear the renderers from all running animations, in case we are in the middle of
 66         // an animation callback (see https://bugs.webkit.org/show_bug.cgi?id=22052)
 67         for (auto&amp; transition : m_transitions.values()) {
 68             animationController().animationWillBeRemoved(*transition);
 69             transition-&gt;clear();
 70         }
 71     }
 72     if (!m_keyframeAnimations.isEmpty()) {
 73         m_keyframeAnimations.checkConsistency();
 74         for (auto&amp; animation : m_keyframeAnimations.values()) {
 75             animationController().animationWillBeRemoved(*animation);
 76             animation-&gt;clear();
 77         }
 78     }
 79 }
 80 
 81 void CompositeAnimation::updateTransitions(Element&amp; element, const RenderStyle* currentStyle, const RenderStyle&amp; targetStyle)
 82 {
 83     // If currentStyle is null or there are no old or new transitions, just skip it
 84     if (!currentStyle || (!targetStyle.transitions() &amp;&amp; m_transitions.isEmpty()))
 85         return;
 86 
 87     // Mark all existing transitions as no longer active. We will mark the still active ones
 88     // in the next loop and then toss the ones that didn&#39;t get marked.
 89     for (auto&amp; transition : m_transitions.values())
 90         transition-&gt;setActive(false);
 91 
 92     std::unique_ptr&lt;RenderStyle&gt; modifiedCurrentStyle;
 93 
 94     // Check to see if we need to update the active transitions
 95     if (targetStyle.transitions()) {
 96         for (size_t i = 0; i &lt; targetStyle.transitions()-&gt;size(); ++i) {
 97             auto&amp; animation = targetStyle.transitions()-&gt;animation(i);
 98             bool isActiveTransition = animation.duration() || animation.delay() &gt; 0;
 99 
100             Animation::AnimationMode mode = animation.animationMode();
101             if (mode == Animation::AnimateNone || mode == Animation::AnimateUnknownProperty)
102                 continue;
103 
104             CSSPropertyID prop = animation.property();
105 
106             bool all = mode == Animation::AnimateAll;
107 
108             // Handle both the &#39;all&#39; and single property cases. For the single prop case, we make only one pass
109             // through the loop.
110             for (int propertyIndex = 0; propertyIndex &lt; CSSPropertyAnimation::getNumProperties(); ++propertyIndex) {
111                 if (all) {
112                     // Get the next property which is not a shorthand.
113                     Optional&lt;bool&gt; isShorthand;
114                     prop = CSSPropertyAnimation::getPropertyAtIndex(propertyIndex, isShorthand);
115                     if (isShorthand &amp;&amp; *isShorthand)
116                         continue;
117                 }
118 
119                 if (prop == CSSPropertyInvalid) {
120                     if (!all)
121                         break;
122                     continue;
123                 }
124 
125                 // ImplicitAnimations are always hashed by actual properties, never animateAll.
126                 ASSERT(prop &gt;= firstCSSProperty &amp;&amp; prop &lt; (firstCSSProperty + numCSSProperties));
127 
128                 // If there is a running animation for this property, the transition is overridden
129                 // and we have to use the unanimatedStyle from the animation. We do the test
130                 // against the unanimated style here, but we &quot;override&quot; the transition later.
131                 auto* keyframeAnimation = animationForProperty(prop);
132                 auto* fromStyle = keyframeAnimation ? &amp;keyframeAnimation-&gt;unanimatedStyle() : currentStyle;
133 
134                 // See if there is a current transition for this prop
135                 ImplicitAnimation* implAnim = m_transitions.get(prop);
136                 bool equal = true;
137 
138                 if (implAnim) {
139                     // If we are post active don&#39;t bother setting the active flag. This will cause
140                     // this animation to get removed at the end of this function.
141                     if (!implAnim-&gt;postActive())
142                         implAnim-&gt;setActive(true);
143 
144                     // This might be a transition that is just finishing. That would be the case
145                     // if it were postActive. But we still need to check for equality because
146                     // it could be just finishing AND changing to a new goal state.
147                     //
148                     // This implAnim might also not be an already running transition. It might be
149                     // newly added to the list in a previous iteration. This would happen if
150                     // you have both an explicit transition-property and &#39;all&#39; in the same
151                     // list. In this case, the latter one overrides the earlier one, so we
152                     // behave as though this is a running animation being replaced.
153                     if (!implAnim-&gt;isTargetPropertyEqual(prop, &amp;targetStyle)) {
154                         // For accelerated animations we need to return a new RenderStyle with the _current_ value
155                         // of the property, so that restarted transitions use the correct starting point.
156                         if (CSSPropertyAnimation::animationOfPropertyIsAccelerated(prop) &amp;&amp; implAnim-&gt;isAccelerated()) {
157                             if (!modifiedCurrentStyle)
158                                 modifiedCurrentStyle = RenderStyle::clonePtr(*currentStyle);
159 
160                             implAnim-&gt;blendPropertyValueInStyle(prop, modifiedCurrentStyle.get());
161                         }
162                         LOG(Animations, &quot;Removing existing ImplicitAnimation %p for property %s&quot;, implAnim, getPropertyName(prop));
163                         animationController().animationWillBeRemoved(*implAnim);
164                         m_transitions.remove(prop);
165                         equal = false;
166                     }
167                 } else {
168                     // We need to start a transition if it is active and the properties don&#39;t match
169                     equal = !isActiveTransition || CSSPropertyAnimation::propertiesEqual(prop, fromStyle, &amp;targetStyle) || !CSSPropertyAnimation::canPropertyBeInterpolated(prop, fromStyle, &amp;targetStyle);
170                 }
171 
172                 // We can be in this loop with an inactive transition (!isActiveTransition). We need
173                 // to do that to check to see if we are canceling a transition. But we don&#39;t want to
174                 // start one of the inactive transitions. So short circuit that here. (See
175                 // &lt;https://bugs.webkit.org/show_bug.cgi?id=24787&gt;
176                 if (!equal &amp;&amp; isActiveTransition) {
177                     // Add the new transition
178                     auto implicitAnimation = ImplicitAnimation::create(animation, prop, element, *this, modifiedCurrentStyle ? *modifiedCurrentStyle : *fromStyle);
179                     if (m_suspended &amp;&amp; implicitAnimation-&gt;hasStyle())
180                         implicitAnimation-&gt;updatePlayState(AnimationPlayState::Paused);
181 
182                     LOG(Animations, &quot;Created ImplicitAnimation %p on element %p for property %s duration %.2f delay %.2f&quot;, implicitAnimation.ptr(), &amp;element, getPropertyName(prop), animation.duration(), animation.delay());
183                     m_transitions.set(prop, WTFMove(implicitAnimation));
184                 }
185 
186                 // We only need one pass for the single prop case
187                 if (!all)
188                     break;
189             }
190         }
191     }
192 
193     // Make a list of transitions to be removed
194     Vector&lt;int&gt; toBeRemoved;
195     for (auto&amp; transition : m_transitions.values()) {
196         if (!transition-&gt;active()) {
197             animationController().animationWillBeRemoved(*transition);
198             toBeRemoved.append(transition-&gt;animatingProperty());
199             LOG(Animations, &quot;Removing ImplicitAnimation %p from element %p for property %s&quot;, transition.get(), &amp;element, getPropertyName(transition-&gt;animatingProperty()));
200         }
201     }
202 
203     // Now remove the transitions from the list
204     for (auto propertyToRemove : toBeRemoved)
205         m_transitions.remove(propertyToRemove);
206 }
207 
208 void CompositeAnimation::updateKeyframeAnimations(Element&amp; element, const RenderStyle* currentStyle, const RenderStyle&amp; targetStyle)
209 {
210     // Nothing to do if we don&#39;t have any animations, and didn&#39;t have any before
211     if (m_keyframeAnimations.isEmpty() &amp;&amp; !targetStyle.hasAnimations())
212         return;
213 
214     m_keyframeAnimations.checkConsistency();
215 
216     if (currentStyle &amp;&amp; currentStyle-&gt;hasAnimations() &amp;&amp; targetStyle.hasAnimations() &amp;&amp; *(currentStyle-&gt;animations()) == *(targetStyle.animations()))
217         return;
218 
219     AnimationNameMap newAnimations;
220 
221     // Toss the animation order map.
222     m_keyframeAnimationOrderMap.clear();
223 
224     static NeverDestroyed&lt;const AtomString&gt; none(&quot;none&quot;, AtomString::ConstructFromLiteral);
225 
226     // Now mark any still active animations as active and add any new animations.
227     if (targetStyle.animations()) {
228         int numAnims = targetStyle.animations()-&gt;size();
229         for (int i = 0; i &lt; numAnims; ++i) {
230             auto&amp; animation = targetStyle.animations()-&gt;animation(i);
231             AtomString animationName(animation.name());
232 
233             if (!animation.isValidAnimation())
234                 continue;
235 
236             // See if there is a current animation for this name.
237             RefPtr&lt;KeyframeAnimation&gt; keyframeAnim = m_keyframeAnimations.get(animationName.impl());
238             if (keyframeAnim) {
239                 newAnimations.add(keyframeAnim-&gt;name().impl(), keyframeAnim);
240 
241                 if (keyframeAnim-&gt;postActive())
242                     continue;
243 
244                 // Animations match, but play states may differ. Update if needed.
245                 keyframeAnim-&gt;updatePlayState(animation.playState());
246 
247                 // Set the saved animation to this new one, just in case the play state has changed.
248                 keyframeAnim-&gt;setAnimation(animation);
249             } else if ((animation.duration() || animation.delay()) &amp;&amp; animation.iterationCount() &amp;&amp; animationName != none) {
250                 keyframeAnim = KeyframeAnimation::create(animation, element, *this, targetStyle);
251                 LOG(Animations, &quot;Creating KeyframeAnimation %p on element %p with keyframes %s, duration %.2f, delay %.2f, iterations %.2f&quot;, keyframeAnim.get(), &amp;element, animation.name().utf8().data(), animation.duration(), animation.delay(), animation.iterationCount());
252 
253                 if (m_suspended) {
254                     keyframeAnim-&gt;updatePlayState(AnimationPlayState::Paused);
255                     LOG(Animations, &quot;  (created in suspended/paused state)&quot;);
256                 }
257 #if !LOG_DISABLED
258                 for (auto propertyID : keyframeAnim-&gt;keyframes().properties())
259                     LOG(Animations, &quot;  property %s&quot;, getPropertyName(propertyID));
260 #endif
261 
262                 newAnimations.set(keyframeAnim-&gt;name().impl(), keyframeAnim);
263             }
264 
265             // Add this to the animation order map.
266             if (keyframeAnim)
267                 m_keyframeAnimationOrderMap.append(keyframeAnim-&gt;name().impl());
268         }
269     }
270 
271     // Make a list of animations to be removed.
272     for (auto&amp; animation : m_keyframeAnimations.values()) {
273         if (!newAnimations.contains(animation-&gt;name().impl())) {
274             animationController().animationWillBeRemoved(*animation);
275             animation-&gt;clear();
276             LOG(Animations, &quot;Removing KeyframeAnimation %p from element %p&quot;, animation.get(), &amp;element);
277         }
278     }
279 
280     std::swap(newAnimations, m_keyframeAnimations);
281 }
282 
283 AnimationUpdate CompositeAnimation::animate(Element&amp; element, const RenderStyle* currentStyle, const RenderStyle&amp; targetStyle)
284 {
285     // We don&#39;t do any transitions if we don&#39;t have a currentStyle (on startup).
286     updateTransitions(element, currentStyle, targetStyle);
287     updateKeyframeAnimations(element, currentStyle, targetStyle);
288     m_keyframeAnimations.checkConsistency();
289 
<a name="2" id="anc2"></a><span class="line-modified">290     OptionSet&lt;AnimationImpact&gt; imapct;</span>

291 
292     std::unique_ptr&lt;RenderStyle&gt; animatedStyle;
293 
294     if (currentStyle) {
295         // Now that we have transition objects ready, let them know about the new goal state.  We want them
296         // to fill in a RenderStyle*&amp; only if needed.
297         bool checkForStackingContext = false;
298         for (auto&amp; transition : m_transitions.values()) {
299             auto changes = transition-&gt;animate(*this, targetStyle, animatedStyle);
300             if (changes.contains(AnimateChange::StyleBlended))
301                 checkForStackingContext |= WillChangeData::propertyCreatesStackingContext(transition-&gt;animatingProperty());
302 
<a name="3" id="anc3"></a><span class="line-modified">303             if (changes.contains(AnimateChange::RunningStateChange) &amp;&amp; transition-&gt;affectsAcceleratedProperty())</span>
<span class="line-added">304                 imapct.add(AnimationImpact::RequiresRecomposite);</span>
305         }
306 
307         if (animatedStyle &amp;&amp; checkForStackingContext) {
<a name="4" id="anc4"></a><span class="line-modified">308             // Note that this is similar to code in Style::Adjuster::adjust() but only needs to consult</span>
309             // animatable properties that can trigger stacking context.
310             if (animatedStyle-&gt;opacity() &lt; 1.0f
311                 || animatedStyle-&gt;hasTransformRelatedProperty()
312                 || animatedStyle-&gt;hasMask()
313                 || animatedStyle-&gt;clipPath()
314                 || animatedStyle-&gt;boxReflect()
315                 || animatedStyle-&gt;hasFilter()
316 #if ENABLE(FILTERS_LEVEL_2)
317                 || animatedStyle-&gt;hasBackdropFilter()
318 #endif
319                 )
<a name="5" id="anc5"></a><span class="line-modified">320             imapct.add(AnimationImpact::ForcesStackingContext);</span>
321         }
322     }
323 
324     // Now that we have animation objects ready, let them know about the new goal state.  We want them
325     // to fill in a RenderStyle*&amp; only if needed.
326     for (auto&amp; name : m_keyframeAnimationOrderMap) {
327         RefPtr&lt;KeyframeAnimation&gt; keyframeAnim = m_keyframeAnimations.get(name);
328         if (keyframeAnim) {
329             auto changes = keyframeAnim-&gt;animate(*this, targetStyle, animatedStyle);
<a name="6" id="anc6"></a><span class="line-modified">330             if (changes.contains(AnimateChange::RunningStateChange) &amp;&amp; keyframeAnim-&gt;affectsAcceleratedProperty())</span>
<span class="line-modified">331                 imapct.add(AnimationImpact::RequiresRecomposite);</span>
<span class="line-added">332 </span>
<span class="line-added">333             if (changes.contains(AnimateChange::StyleBlended) &amp;&amp; keyframeAnim-&gt;triggersStackingContext())</span>
<span class="line-added">334                 imapct.add(AnimationImpact::ForcesStackingContext);</span>
<span class="line-added">335 </span>
336             m_hasAnimationThatDependsOnLayout |= keyframeAnim-&gt;dependsOnLayout();
337         }
338     }
339 
<a name="7" id="anc7"></a><span class="line-modified">340     return { WTFMove(animatedStyle), imapct };</span>









341 }
342 
343 std::unique_ptr&lt;RenderStyle&gt; CompositeAnimation::getAnimatedStyle() const
344 {
345     std::unique_ptr&lt;RenderStyle&gt; resultStyle;
346     for (auto&amp; transition : m_transitions.values())
347         transition-&gt;getAnimatedStyle(resultStyle);
348 
349     m_keyframeAnimations.checkConsistency();
350 
351     for (auto&amp; name : m_keyframeAnimationOrderMap) {
352         RefPtr&lt;KeyframeAnimation&gt; keyframeAnimation = m_keyframeAnimations.get(name);
353         if (keyframeAnimation)
354             keyframeAnimation-&gt;getAnimatedStyle(resultStyle);
355     }
356 
357     return resultStyle;
358 }
359 
360 Optional&lt;Seconds&gt; CompositeAnimation::timeToNextService() const
361 {
362     // Returns the time at which next service is required. WTF::nullopt means no service is required. 0 means
363     // service is required now, and &gt; 0 means service is required that many seconds in the future.
364     Optional&lt;Seconds&gt; minT;
365 
366     if (!m_transitions.isEmpty()) {
367         for (auto&amp; transition : m_transitions.values()) {
368             Optional&lt;Seconds&gt; t = transition-&gt;timeToNextService();
369             if (!t)
370                 continue;
371             if (!minT || t.value() &lt; minT.value())
372                 minT = t.value();
373             if (minT.value() == 0_s)
374                 return 0_s;
375         }
376     }
377     if (!m_keyframeAnimations.isEmpty()) {
378         m_keyframeAnimations.checkConsistency();
379         for (auto&amp; animation : m_keyframeAnimations.values()) {
380             Optional&lt;Seconds&gt; t = animation-&gt;timeToNextService();
381             if (!t)
382                 continue;
383             if (!minT || t.value() &lt; minT.value())
384                 minT = t.value();
385             if (minT.value() == 0_s)
386                 return 0_s;
387         }
388     }
389 
390     return minT;
391 }
392 
393 KeyframeAnimation* CompositeAnimation::animationForProperty(CSSPropertyID property) const
394 {
395     KeyframeAnimation* result = nullptr;
396 
397     // We want to send back the last animation with the property if there are multiples.
398     // So we need to iterate through all animations
399     if (!m_keyframeAnimations.isEmpty()) {
400         m_keyframeAnimations.checkConsistency();
401         for (auto&amp; animation : m_keyframeAnimations.values()) {
402             if (animation-&gt;hasAnimationForProperty(property))
403                 result = animation.get();
404         }
405     }
406 
407     return result;
408 }
409 
410 bool CompositeAnimation::computeExtentOfTransformAnimation(LayoutRect&amp; bounds) const
411 {
412     // If more than one transition and animation affect transform, give up.
413     bool seenTransformAnimation = false;
414 
415     for (auto&amp; animation : m_keyframeAnimations.values()) {
416         if (!animation-&gt;hasAnimationForProperty(CSSPropertyTransform))
417             continue;
418 
419         if (seenTransformAnimation)
420             return false;
421 
422         seenTransformAnimation = true;
423 
424         if (!animation-&gt;computeExtentOfTransformAnimation(bounds))
425             return false;
426     }
427 
428     for (auto&amp; transition : m_transitions.values()) {
429         if (transition-&gt;animatingProperty() != CSSPropertyTransform || !transition-&gt;hasStyle())
430             continue;
431 
432         if (seenTransformAnimation)
433             return false;
434 
435         if (!transition-&gt;computeExtentOfTransformAnimation(bounds))
436             return false;
437     }
438 
439     return true;
440 }
441 
442 void CompositeAnimation::suspendAnimations()
443 {
444     if (m_suspended)
445         return;
446 
447     m_suspended = true;
448 
449     if (!m_keyframeAnimations.isEmpty()) {
450         m_keyframeAnimations.checkConsistency();
451         for (auto&amp; animation : m_keyframeAnimations.values())
452             animation-&gt;updatePlayState(AnimationPlayState::Paused);
453     }
454 
455     if (!m_transitions.isEmpty()) {
456         for (auto&amp; transition : m_transitions.values()) {
457             if (transition-&gt;hasStyle())
458                 transition-&gt;updatePlayState(AnimationPlayState::Paused);
459         }
460     }
461 }
462 
463 void CompositeAnimation::resumeAnimations()
464 {
465     if (!m_suspended)
466         return;
467 
468     m_suspended = false;
469 
470     if (!m_keyframeAnimations.isEmpty()) {
471         m_keyframeAnimations.checkConsistency();
472         for (auto&amp; animation : m_keyframeAnimations.values()) {
473             if (animation-&gt;playStatePlaying())
474                 animation-&gt;updatePlayState(AnimationPlayState::Playing);
475         }
476     }
477 
478     if (!m_transitions.isEmpty()) {
479         for (auto&amp; transition : m_transitions.values()) {
480             if (transition-&gt;hasStyle())
481                 transition-&gt;updatePlayState(AnimationPlayState::Playing);
482         }
483     }
484 }
485 
486 void CompositeAnimation::overrideImplicitAnimations(CSSPropertyID property)
487 {
488     if (!m_transitions.isEmpty()) {
489         for (auto&amp; transition : m_transitions.values()) {
490             if (transition-&gt;animatingProperty() == property)
491                 transition-&gt;setOverridden(true);
492         }
493     }
494 }
495 
496 void CompositeAnimation::resumeOverriddenImplicitAnimations(CSSPropertyID property)
497 {
498     if (!m_transitions.isEmpty()) {
499         for (auto&amp; transition : m_transitions.values()) {
500             if (transition-&gt;animatingProperty() == property)
501                 transition-&gt;setOverridden(false);
502         }
503     }
504 }
505 
506 bool CompositeAnimation::isAnimatingProperty(CSSPropertyID property, bool acceleratedOnly) const
507 {
508     if (!m_keyframeAnimations.isEmpty()) {
509         m_keyframeAnimations.checkConsistency();
510         for (auto&amp; animation : m_keyframeAnimations.values()) {
511             if (animation-&gt;isAnimatingProperty(property, acceleratedOnly))
512                 return true;
513         }
514     }
515 
516     if (!m_transitions.isEmpty()) {
517         for (auto&amp; transition : m_transitions.values()) {
518             if (transition-&gt;isAnimatingProperty(property, acceleratedOnly))
519                 return true;
520         }
521     }
522     return false;
523 }
524 
525 bool CompositeAnimation::pauseAnimationAtTime(const AtomString&amp; name, double t)
526 {
527     m_keyframeAnimations.checkConsistency();
528 
529     RefPtr&lt;KeyframeAnimation&gt; keyframeAnim = m_keyframeAnimations.get(name.impl());
530     if (!keyframeAnim || !keyframeAnim-&gt;running())
531         return false;
532 
533     keyframeAnim-&gt;freezeAtTime(t);
534     return true;
535 }
536 
537 bool CompositeAnimation::pauseTransitionAtTime(CSSPropertyID property, double t)
538 {
539     if ((property &lt; firstCSSProperty) || (property &gt;= firstCSSProperty + numCSSProperties))
540         return false;
541 
542     ImplicitAnimation* implAnim = m_transitions.get(property);
543     if (!implAnim) {
544         // Check to see if this property is being animated via a shorthand.
545         // This code is only used for testing, so performance is not critical here.
546         HashSet&lt;CSSPropertyID&gt; shorthandProperties = CSSPropertyAnimation::animatableShorthandsAffectingProperty(property);
547         bool anyPaused = false;
548         for (auto propertyID : shorthandProperties) {
549             if (pauseTransitionAtTime(propertyID, t))
550                 anyPaused = true;
551         }
552         return anyPaused;
553     }
554 
555     if (!implAnim-&gt;running())
556         return false;
557 
558     if ((t &gt;= 0.0) &amp;&amp; (t &lt;= implAnim-&gt;duration())) {
559         implAnim-&gt;freezeAtTime(t);
560         return true;
561     }
562 
563     return false;
564 }
565 
566 unsigned CompositeAnimation::numberOfActiveAnimations() const
567 {
568     unsigned count = 0;
569 
570     m_keyframeAnimations.checkConsistency();
571     for (auto&amp; animation : m_keyframeAnimations.values()) {
572         if (animation-&gt;running())
573             ++count;
574     }
575 
576     for (auto&amp; transition : m_transitions.values()) {
577         if (transition-&gt;running())
578             ++count;
579     }
580 
581     return count;
582 }
583 
584 } // namespace WebCore
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
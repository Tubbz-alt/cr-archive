<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SamplingProfiler.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RegExpStringIteratorPrototype.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SamplingProfiler.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SamplingProfiler.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 63,12 ***</span>
  static double sNumTotalStackTraces = 0;
  static double sNumTotalWalks = 0;
  static double sNumFailedWalks = 0;
  static const uint32_t sNumWalkReportingFrequency = 50;
  static const double sWalkErrorPercentage = .05;
<span class="line-modified">! static const bool sReportStatsOnlyWhenTheyreAboveThreshold = false;</span>
<span class="line-modified">! static const bool sReportStats = false;</span>
  
  using FrameType = SamplingProfiler::FrameType;
  using UnprocessedStackFrame = SamplingProfiler::UnprocessedStackFrame;
  
  ALWAYS_INLINE static void reportStats()
<span class="line-new-header">--- 63,12 ---</span>
  static double sNumTotalStackTraces = 0;
  static double sNumTotalWalks = 0;
  static double sNumFailedWalks = 0;
  static const uint32_t sNumWalkReportingFrequency = 50;
  static const double sWalkErrorPercentage = .05;
<span class="line-modified">! static constexpr bool sReportStatsOnlyWhenTheyreAboveThreshold = false;</span>
<span class="line-modified">! static constexpr bool sReportStats = false;</span>
  
  using FrameType = SamplingProfiler::FrameType;
  using UnprocessedStackFrame = SamplingProfiler::UnprocessedStackFrame;
  
  ALWAYS_INLINE static void reportStats()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 81,11 ***</span>
      }
  }
  
  class FrameWalker {
  public:
<span class="line-modified">!     FrameWalker(VM&amp; vm, ExecState* callFrame, const AbstractLocker&amp; codeBlockSetLocker, const AbstractLocker&amp; machineThreadsLocker, const AbstractLocker&amp; wasmCalleeLocker)</span>
          : m_vm(vm)
          , m_callFrame(callFrame)
          , m_entryFrame(vm.topEntryFrame)
          , m_codeBlockSetLocker(codeBlockSetLocker)
          , m_machineThreadsLocker(machineThreadsLocker)
<span class="line-new-header">--- 81,11 ---</span>
      }
  }
  
  class FrameWalker {
  public:
<span class="line-modified">!     FrameWalker(VM&amp; vm, CallFrame* callFrame, const AbstractLocker&amp; codeBlockSetLocker, const AbstractLocker&amp; machineThreadsLocker, const AbstractLocker&amp; wasmCalleeLocker)</span>
          : m_vm(vm)
          , m_callFrame(callFrame)
          , m_entryFrame(vm.topEntryFrame)
          , m_codeBlockSetLocker(codeBlockSetLocker)
          , m_machineThreadsLocker(machineThreadsLocker)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 121,10 ***</span>
<span class="line-new-header">--- 121,12 ---</span>
      void recordJITFrame(Vector&lt;UnprocessedStackFrame&gt;&amp; stackTrace)
      {
          CallSiteIndex callSiteIndex;
          CalleeBits unsafeCallee = m_callFrame-&gt;unsafeCallee();
          CodeBlock* codeBlock = m_callFrame-&gt;unsafeCodeBlock();
<span class="line-added">+         if (unsafeCallee.isWasm())</span>
<span class="line-added">+             codeBlock = nullptr;</span>
          if (codeBlock) {
              ASSERT(isValidCodeBlock(codeBlock));
              callSiteIndex = m_callFrame-&gt;unsafeCallSiteIndex();
          }
          stackTrace[m_depth] = UnprocessedStackFrame(codeBlock, unsafeCallee, callSiteIndex);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 166,24 ***</span>
                  sNumFailedWalks++;
              return;
          }
  
          CodeBlock* codeBlock = m_callFrame-&gt;unsafeCodeBlock();
<span class="line-modified">!         if (!codeBlock)</span>
              return;
  
          if (!isValidCodeBlock(codeBlock)) {
              m_bailingOut = true;
              if (sReportStats)
                  sNumFailedWalks++;
              return;
          }
      }
  
<span class="line-modified">!     bool isValidFramePointer(void* exec)</span>
      {
<span class="line-modified">!         uint8_t* fpCast = bitwise_cast&lt;uint8_t*&gt;(exec);</span>
          for (auto&amp; thread : m_vm.heap.machineThreads().threads(m_machineThreadsLocker)) {
              uint8_t* stackBase = static_cast&lt;uint8_t*&gt;(thread-&gt;stack().origin());
              uint8_t* stackLimit = static_cast&lt;uint8_t*&gt;(thread-&gt;stack().end());
              RELEASE_ASSERT(stackBase);
              RELEASE_ASSERT(stackLimit);
<span class="line-new-header">--- 168,24 ---</span>
                  sNumFailedWalks++;
              return;
          }
  
          CodeBlock* codeBlock = m_callFrame-&gt;unsafeCodeBlock();
<span class="line-modified">!         if (!codeBlock || m_callFrame-&gt;unsafeCallee().isWasm())</span>
              return;
  
          if (!isValidCodeBlock(codeBlock)) {
              m_bailingOut = true;
              if (sReportStats)
                  sNumFailedWalks++;
              return;
          }
      }
  
<span class="line-modified">!     bool isValidFramePointer(void* callFrame)</span>
      {
<span class="line-modified">!         uint8_t* fpCast = bitwise_cast&lt;uint8_t*&gt;(callFrame);</span>
          for (auto&amp; thread : m_vm.heap.machineThreads().threads(m_machineThreadsLocker)) {
              uint8_t* stackBase = static_cast&lt;uint8_t*&gt;(thread-&gt;stack().origin());
              uint8_t* stackLimit = static_cast&lt;uint8_t*&gt;(thread-&gt;stack().end());
              RELEASE_ASSERT(stackBase);
              RELEASE_ASSERT(stackLimit);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 201,11 ***</span>
          bool result = m_vm.heap.codeBlockSet().contains(m_codeBlockSetLocker, codeBlock);
          return result;
      }
  
      VM&amp; m_vm;
<span class="line-modified">!     ExecState* m_callFrame;</span>
      EntryFrame* m_entryFrame;
      const AbstractLocker&amp; m_codeBlockSetLocker;
      const AbstractLocker&amp; m_machineThreadsLocker;
      const AbstractLocker&amp; m_wasmCalleeLocker;
      bool m_bailingOut { false };
<span class="line-new-header">--- 203,11 ---</span>
          bool result = m_vm.heap.codeBlockSet().contains(m_codeBlockSetLocker, codeBlock);
          return result;
      }
  
      VM&amp; m_vm;
<span class="line-modified">!     CallFrame* m_callFrame;</span>
      EntryFrame* m_entryFrame;
      const AbstractLocker&amp; m_codeBlockSetLocker;
      const AbstractLocker&amp; m_machineThreadsLocker;
      const AbstractLocker&amp; m_wasmCalleeLocker;
      bool m_bailingOut { false };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 214,11 ***</span>
  
  class CFrameWalker : public FrameWalker {
  public:
      typedef FrameWalker Base;
  
<span class="line-modified">!     CFrameWalker(VM&amp; vm, void* machineFrame, ExecState* callFrame, const AbstractLocker&amp; codeBlockSetLocker, const AbstractLocker&amp; machineThreadsLocker, const AbstractLocker&amp; wasmCalleeLocker)</span>
          : Base(vm, callFrame, codeBlockSetLocker, machineThreadsLocker, wasmCalleeLocker)
          , m_machineFrame(machineFrame)
      {
      }
  
<span class="line-new-header">--- 216,11 ---</span>
  
  class CFrameWalker : public FrameWalker {
  public:
      typedef FrameWalker Base;
  
<span class="line-modified">!     CFrameWalker(VM&amp; vm, void* machineFrame, CallFrame* callFrame, const AbstractLocker&amp; codeBlockSetLocker, const AbstractLocker&amp; machineThreadsLocker, const AbstractLocker&amp; wasmCalleeLocker)</span>
          : Base(vm, callFrame, codeBlockSetLocker, machineThreadsLocker, wasmCalleeLocker)
          , m_machineFrame(machineFrame)
      {
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 303,10 ***</span>
<span class="line-new-header">--- 305,11 ---</span>
          sNumTotalWalks = 0;
          sNumFailedWalks = 0;
      }
  
      m_currentFrames.grow(256);
<span class="line-added">+     vm.heap.objectSpace().enablePreciseAllocationTracking();</span>
  }
  
  SamplingProfiler::~SamplingProfiler()
  {
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 367,19 ***</span>
          auto didSuspend = m_jscExecutionThread-&gt;suspend();
          if (didSuspend) {
              // While the JSC thread is suspended, we can&#39;t do things like malloc because the JSC thread
              // may be holding the malloc lock.
              void* machineFrame;
<span class="line-modified">!             ExecState* callFrame;</span>
              void* machinePC;
              bool topFrameIsLLInt = false;
              void* llintPC;
              {
                  PlatformRegisters registers;
                  m_jscExecutionThread-&gt;getRegisters(registers);
                  machineFrame = MachineContext::framePointer(registers);
<span class="line-modified">!                 callFrame = static_cast&lt;ExecState*&gt;(machineFrame);</span>
                  auto instructionPointer = MachineContext::instructionPointer(registers);
                  if (instructionPointer)
                      machinePC = instructionPointer-&gt;untaggedExecutableAddress();
                  else
                      machinePC = nullptr;
<span class="line-new-header">--- 370,19 ---</span>
          auto didSuspend = m_jscExecutionThread-&gt;suspend();
          if (didSuspend) {
              // While the JSC thread is suspended, we can&#39;t do things like malloc because the JSC thread
              // may be holding the malloc lock.
              void* machineFrame;
<span class="line-modified">!             CallFrame* callFrame;</span>
              void* machinePC;
              bool topFrameIsLLInt = false;
              void* llintPC;
              {
                  PlatformRegisters registers;
                  m_jscExecutionThread-&gt;getRegisters(registers);
                  machineFrame = MachineContext::framePointer(registers);
<span class="line-modified">!                 callFrame = static_cast&lt;CallFrame*&gt;(machineFrame);</span>
                  auto instructionPointer = MachineContext::instructionPointer(registers);
                  if (instructionPointer)
                      machinePC = instructionPointer-&gt;untaggedExecutableAddress();
                  else
                      machinePC = nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 444,37 ***</span>
              stackTraceProcessingTime = endTime - startTime;
          }
      }
  }
  
<span class="line-modified">! static ALWAYS_INLINE unsigned tryGetBytecodeIndex(unsigned llintPC, CodeBlock* codeBlock, bool&amp; isValid)</span>
  {
  #if ENABLE(DFG_JIT)
      RELEASE_ASSERT(!codeBlock-&gt;hasCodeOrigins());
  #endif
  
<span class="line-modified">! #if USE(JSVALUE64)</span>
<span class="line-modified">!     unsigned bytecodeIndex = llintPC;</span>
<span class="line-modified">!     if (bytecodeIndex &lt; codeBlock-&gt;instructionsSize()) {</span>
<span class="line-modified">!         isValid = true;</span>
<span class="line-removed">-         return bytecodeIndex;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     isValid = false;</span>
<span class="line-removed">-     return 0;</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     Instruction* instruction = bitwise_cast&lt;Instruction*&gt;(llintPC);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (codeBlock-&gt;instructions().contains(instruction)) {</span>
<span class="line-removed">-         isValid = true;</span>
<span class="line-removed">-         return codeBlock-&gt;bytecodeOffset(instruction);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     isValid = false;</span>
<span class="line-removed">-     return 0;</span>
<span class="line-removed">- #endif</span>
  }
  
<span class="line-modified">! void SamplingProfiler::processUnverifiedStackTraces()</span>
  {
      // This function needs to be called from the JSC execution thread.
      RELEASE_ASSERT(m_lock.isLocked());
  
      TinyBloomFilter filter = m_vm.heap.objectSpace().blocks().filter();
<span class="line-new-header">--- 447,23 ---</span>
              stackTraceProcessingTime = endTime - startTime;
          }
      }
  }
  
<span class="line-modified">! static ALWAYS_INLINE BytecodeIndex tryGetBytecodeIndex(unsigned llintPC, CodeBlock* codeBlock)</span>
  {
  #if ENABLE(DFG_JIT)
      RELEASE_ASSERT(!codeBlock-&gt;hasCodeOrigins());
  #endif
  
<span class="line-modified">!     unsigned bytecodeOffset = llintPC;</span>
<span class="line-modified">!     if (bytecodeOffset &lt; codeBlock-&gt;instructionsSize())</span>
<span class="line-modified">!         return BytecodeIndex(bytecodeOffset);</span>
<span class="line-modified">!     return BytecodeIndex();</span>
  }
  
<span class="line-modified">! void SamplingProfiler::processUnverifiedStackTraces(const AbstractLocker&amp;)</span>
  {
      // This function needs to be called from the JSC execution thread.
      RELEASE_ASSERT(m_lock.isLocked());
  
      TinyBloomFilter filter = m_vm.heap.objectSpace().blocks().filter();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 482,26 ***</span>
      for (UnprocessedStackTrace&amp; unprocessedStackTrace : m_unprocessedStackTraces) {
          m_stackTraces.append(StackTrace());
          StackTrace&amp; stackTrace = m_stackTraces.last();
          stackTrace.timestamp = unprocessedStackTrace.timestamp;
  
<span class="line-modified">!         auto populateCodeLocation = [] (CodeBlock* codeBlock, unsigned bytecodeIndex, StackFrame::CodeLocation&amp; location) {</span>
<span class="line-modified">!             if (bytecodeIndex &lt; codeBlock-&gt;instructionsSize()) {</span>
                  int divot;
                  int startOffset;
                  int endOffset;
<span class="line-modified">!                 codeBlock-&gt;expressionRangeForBytecodeOffset(bytecodeIndex, divot, startOffset, endOffset,</span>
                      location.lineNumber, location.columnNumber);
                  location.bytecodeIndex = bytecodeIndex;
              }
              if (Options::collectSamplingProfilerDataForJSCShell()) {
                  location.codeBlockHash = codeBlock-&gt;hash();
                  location.jitType = codeBlock-&gt;jitType();
              }
          };
  
<span class="line-modified">!         auto appendCodeBlock = [&amp;] (CodeBlock* codeBlock, unsigned bytecodeIndex) {</span>
              stackTrace.frames.append(StackFrame(codeBlock-&gt;ownerExecutable()));
              m_liveCellPointers.add(codeBlock-&gt;ownerExecutable());
              populateCodeLocation(codeBlock, bytecodeIndex, stackTrace.frames.last().semanticLocation);
          };
  
<span class="line-new-header">--- 471,26 ---</span>
      for (UnprocessedStackTrace&amp; unprocessedStackTrace : m_unprocessedStackTraces) {
          m_stackTraces.append(StackTrace());
          StackTrace&amp; stackTrace = m_stackTraces.last();
          stackTrace.timestamp = unprocessedStackTrace.timestamp;
  
<span class="line-modified">!         auto populateCodeLocation = [] (CodeBlock* codeBlock, BytecodeIndex bytecodeIndex, StackFrame::CodeLocation&amp; location) {</span>
<span class="line-modified">!             if (bytecodeIndex.offset() &lt; codeBlock-&gt;instructionsSize()) {</span>
                  int divot;
                  int startOffset;
                  int endOffset;
<span class="line-modified">!                 codeBlock-&gt;expressionRangeForBytecodeIndex(bytecodeIndex, divot, startOffset, endOffset,</span>
                      location.lineNumber, location.columnNumber);
                  location.bytecodeIndex = bytecodeIndex;
              }
              if (Options::collectSamplingProfilerDataForJSCShell()) {
                  location.codeBlockHash = codeBlock-&gt;hash();
                  location.jitType = codeBlock-&gt;jitType();
              }
          };
  
<span class="line-modified">!         auto appendCodeBlock = [&amp;] (CodeBlock* codeBlock, BytecodeIndex bytecodeIndex) {</span>
              stackTrace.frames.append(StackFrame(codeBlock-&gt;ownerExecutable()));
              m_liveCellPointers.add(codeBlock-&gt;ownerExecutable());
              populateCodeLocation(codeBlock, bytecodeIndex, stackTrace.frames.last().semanticLocation);
          };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 612,22 ***</span>
                  // This might also be false for various reasons (known and unknown), even though
                  // it&#39;s super unlikely. One reason that this can be false is when we throw from a DFG frame,
                  // and we end up having to unwind past an EntryFrame, we will end up executing
                  // inside the LLInt&#39;s handleUncaughtException. So we just protect against this
                  // by ignoring it.
<span class="line-modified">!                 unsigned bytecodeIndex = 0;</span>
                  if (topCodeBlock-&gt;jitType() == JITType::InterpreterThunk || topCodeBlock-&gt;jitType() == JITType::BaselineJIT) {
<span class="line-modified">!                     bool isValidPC;</span>
<span class="line-modified">!                     unsigned bits;</span>
<span class="line-removed">- #if USE(JSVALUE64)</span>
<span class="line-removed">-                     bits = static_cast&lt;unsigned&gt;(bitwise_cast&lt;uintptr_t&gt;(unprocessedStackTrace.llintPC));</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-                     bits = bitwise_cast&lt;unsigned&gt;(unprocessedStackTrace.llintPC);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-                     bytecodeIndex = tryGetBytecodeIndex(bits, topCodeBlock, isValidPC);</span>
  
<span class="line-modified">!                     UNUSED_PARAM(isValidPC); // FIXME: do something with this info for the web inspector: https://bugs.webkit.org/show_bug.cgi?id=153455</span>
  
                      appendCodeBlock(topCodeBlock, bytecodeIndex);
                      storeCalleeIntoLastFrame(unprocessedStackTrace.frames[0]);
                      startIndex = 1;
                  }
<span class="line-new-header">--- 601,16 ---</span>
                  // This might also be false for various reasons (known and unknown), even though
                  // it&#39;s super unlikely. One reason that this can be false is when we throw from a DFG frame,
                  // and we end up having to unwind past an EntryFrame, we will end up executing
                  // inside the LLInt&#39;s handleUncaughtException. So we just protect against this
                  // by ignoring it.
<span class="line-modified">!                 BytecodeIndex bytecodeIndex = BytecodeIndex(0);</span>
                  if (topCodeBlock-&gt;jitType() == JITType::InterpreterThunk || topCodeBlock-&gt;jitType() == JITType::BaselineJIT) {
<span class="line-modified">!                     unsigned bits = static_cast&lt;unsigned&gt;(bitwise_cast&lt;uintptr_t&gt;(unprocessedStackTrace.llintPC));</span>
<span class="line-modified">!                     bytecodeIndex = tryGetBytecodeIndex(bits, topCodeBlock);</span>
  
<span class="line-modified">!                     UNUSED_PARAM(bytecodeIndex); // FIXME: do something with this info for the web inspector: https://bugs.webkit.org/show_bug.cgi?id=153455</span>
  
                      appendCodeBlock(topCodeBlock, bytecodeIndex);
                      storeCalleeIntoLastFrame(unprocessedStackTrace.frames[0]);
                      startIndex = 1;
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 647,20 ***</span>
              UnprocessedStackFrame&amp; unprocessedStackFrame = unprocessedStackTrace.frames[i];
              if (CodeBlock* codeBlock = unprocessedStackFrame.verifiedCodeBlock) {
                  CallSiteIndex callSiteIndex = unprocessedStackFrame.callSiteIndex;
  
                  auto appendCodeBlockNoInlining = [&amp;] {
<span class="line-modified">!                     bool isValidPC;</span>
<span class="line-removed">-                     appendCodeBlock(codeBlock, tryGetBytecodeIndex(callSiteIndex.bits(), codeBlock, isValidPC));</span>
                  };
  
  #if ENABLE(DFG_JIT)
                  if (codeBlock-&gt;hasCodeOrigins()) {
                      if (codeBlock-&gt;canGetCodeOrigin(callSiteIndex))
                          appendCodeOrigin(codeBlock, codeBlock-&gt;codeOrigin(callSiteIndex));
                      else
<span class="line-modified">!                         appendCodeBlock(codeBlock, std::numeric_limits&lt;unsigned&gt;::max());</span>
                  } else
                      appendCodeBlockNoInlining();
  #else
                  appendCodeBlockNoInlining();
  #endif
<span class="line-new-header">--- 630,19 ---</span>
              UnprocessedStackFrame&amp; unprocessedStackFrame = unprocessedStackTrace.frames[i];
              if (CodeBlock* codeBlock = unprocessedStackFrame.verifiedCodeBlock) {
                  CallSiteIndex callSiteIndex = unprocessedStackFrame.callSiteIndex;
  
                  auto appendCodeBlockNoInlining = [&amp;] {
<span class="line-modified">!                     appendCodeBlock(codeBlock, tryGetBytecodeIndex(callSiteIndex.bits(), codeBlock));</span>
                  };
  
  #if ENABLE(DFG_JIT)
                  if (codeBlock-&gt;hasCodeOrigins()) {
                      if (codeBlock-&gt;canGetCodeOrigin(callSiteIndex))
                          appendCodeOrigin(codeBlock, codeBlock-&gt;codeOrigin(callSiteIndex));
                      else
<span class="line-modified">!                         appendCodeBlock(codeBlock, BytecodeIndex());</span>
                  } else
                      appendCodeBlockNoInlining();
  #else
                  appendCodeBlockNoInlining();
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 753,19 ***</span>
  {
      if (!callee)
          return String();
  
      auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!     ExecState* exec = callee-&gt;globalObject(vm)-&gt;globalExec();</span>
      auto getPropertyIfPureOperation = [&amp;] (const Identifier&amp; ident) -&gt; String {
          PropertySlot slot(callee, PropertySlot::InternalMethodType::VMInquiry);
          PropertyName propertyName(ident);
<span class="line-modified">!         bool hasProperty = callee-&gt;getPropertySlot(exec, propertyName, slot);</span>
          scope.assertNoException();
          if (hasProperty) {
              if (slot.isValue()) {
<span class="line-modified">!                 JSValue nameValue = slot.getValue(exec, propertyName);</span>
                  if (isJSString(nameValue))
                      return asString(nameValue)-&gt;tryGetValue();
              }
          }
          return String();
<span class="line-new-header">--- 735,19 ---</span>
  {
      if (!callee)
          return String();
  
      auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!     JSGlobalObject* globalObject = callee-&gt;globalObject(vm);</span>
      auto getPropertyIfPureOperation = [&amp;] (const Identifier&amp; ident) -&gt; String {
          PropertySlot slot(callee, PropertySlot::InternalMethodType::VMInquiry);
          PropertyName propertyName(ident);
<span class="line-modified">!         bool hasProperty = callee-&gt;getPropertySlot(globalObject, propertyName, slot);</span>
          scope.assertNoException();
          if (hasProperty) {
              if (slot.isValue()) {
<span class="line-modified">!                 JSValue nameValue = slot.getValue(globalObject, propertyName);</span>
                  if (isJSString(nameValue))
                      return asString(nameValue)-&gt;tryGetValue();
              }
          }
          return String();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 955,26 ***</span>
  Vector&lt;SamplingProfiler::StackTrace&gt; SamplingProfiler::releaseStackTraces(const AbstractLocker&amp; locker)
  {
      ASSERT(m_lock.isLocked());
      {
          HeapIterationScope heapIterationScope(m_vm.heap);
<span class="line-modified">!         processUnverifiedStackTraces();</span>
      }
  
      Vector&lt;StackTrace&gt; result(WTFMove(m_stackTraces));
      clearData(locker);
      return result;
  }
  
  String SamplingProfiler::stackTracesAsJSON()
  {
      DeferGC deferGC(m_vm.heap);
<span class="line-modified">!     LockHolder locker(m_lock);</span>
  
      {
          HeapIterationScope heapIterationScope(m_vm.heap);
<span class="line-modified">!         processUnverifiedStackTraces();</span>
      }
  
      StringBuilder json;
      json.append(&#39;[&#39;);
  
<span class="line-new-header">--- 937,26 ---</span>
  Vector&lt;SamplingProfiler::StackTrace&gt; SamplingProfiler::releaseStackTraces(const AbstractLocker&amp; locker)
  {
      ASSERT(m_lock.isLocked());
      {
          HeapIterationScope heapIterationScope(m_vm.heap);
<span class="line-modified">!         processUnverifiedStackTraces(locker);</span>
      }
  
      Vector&lt;StackTrace&gt; result(WTFMove(m_stackTraces));
      clearData(locker);
      return result;
  }
  
  String SamplingProfiler::stackTracesAsJSON()
  {
      DeferGC deferGC(m_vm.heap);
<span class="line-modified">!     auto locker = holdLock(m_lock);</span>
  
      {
          HeapIterationScope heapIterationScope(m_vm.heap);
<span class="line-modified">!         processUnverifiedStackTraces(locker);</span>
      }
  
      StringBuilder json;
      json.append(&#39;[&#39;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1011,11 ***</span>
      LockHolder holder(registrationLock);
  
      if (!profilesToReport) {
          profilesToReport = new HashSet&lt;RefPtr&lt;SamplingProfiler&gt;&gt;();
          atexit([]() {
<span class="line-modified">!             for (auto profile : *profilesToReport)</span>
                  profile-&gt;reportDataToOptionFile();
          });
      }
  
      profilesToReport-&gt;add(adoptRef(this));
<span class="line-new-header">--- 993,11 ---</span>
      LockHolder holder(registrationLock);
  
      if (!profilesToReport) {
          profilesToReport = new HashSet&lt;RefPtr&lt;SamplingProfiler&gt;&gt;();
          atexit([]() {
<span class="line-modified">!             for (const auto&amp; profile : *profilesToReport)</span>
                  profile-&gt;reportDataToOptionFile();
          });
      }
  
      profilesToReport-&gt;add(adoptRef(this));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1024,10 ***</span>
<span class="line-new-header">--- 1006,11 ---</span>
  
  void SamplingProfiler::reportDataToOptionFile()
  {
      if (m_needsReportAtExit) {
          m_needsReportAtExit = false;
<span class="line-added">+         JSLockHolder holder(m_vm);</span>
          const char* path = Options::samplingProfilerPath();
          StringPrintStream pathOut;
          pathOut.print(path, &quot;/&quot;);
          pathOut.print(&quot;JSCSampilingProfile-&quot;, reinterpret_cast&lt;uintptr_t&gt;(this), &quot;.txt&quot;);
          auto out = FilePrintStream::open(pathOut.toCString().data(), &quot;w&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1041,16 ***</span>
      reportTopFunctions(WTF::dataFile());
  }
  
  void SamplingProfiler::reportTopFunctions(PrintStream&amp; out)
  {
<span class="line-modified">!     LockHolder locker(m_lock);</span>
      DeferGCForAWhile deferGC(m_vm.heap);
  
      {
          HeapIterationScope heapIterationScope(m_vm.heap);
<span class="line-modified">!         processUnverifiedStackTraces();</span>
      }
  
  
      HashMap&lt;String, size_t&gt; functionCounts;
      for (StackTrace&amp; stackTrace : m_stackTraces) {
<span class="line-new-header">--- 1024,16 ---</span>
      reportTopFunctions(WTF::dataFile());
  }
  
  void SamplingProfiler::reportTopFunctions(PrintStream&amp; out)
  {
<span class="line-modified">!     auto locker = holdLock(m_lock);</span>
      DeferGCForAWhile deferGC(m_vm.heap);
  
      {
          HeapIterationScope heapIterationScope(m_vm.heap);
<span class="line-modified">!         processUnverifiedStackTraces(locker);</span>
      }
  
  
      HashMap&lt;String, size_t&gt; functionCounts;
      for (StackTrace&amp; stackTrace : m_stackTraces) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1063,11 ***</span>
      }
  
      auto takeMax = [&amp;] () -&gt; std::pair&lt;String, size_t&gt; {
          String maxFrameDescription;
          size_t maxFrameCount = 0;
<span class="line-modified">!         for (auto entry : functionCounts) {</span>
              if (entry.value &gt; maxFrameCount) {
                  maxFrameCount = entry.value;
                  maxFrameDescription = entry.key;
              }
          }
<span class="line-new-header">--- 1046,11 ---</span>
      }
  
      auto takeMax = [&amp;] () -&gt; std::pair&lt;String, size_t&gt; {
          String maxFrameDescription;
          size_t maxFrameCount = 0;
<span class="line-modified">!         for (const auto&amp; entry : functionCounts) {</span>
              if (entry.value &gt; maxFrameCount) {
                  maxFrameCount = entry.value;
                  maxFrameDescription = entry.key;
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1094,16 ***</span>
      reportTopBytecodes(WTF::dataFile());
  }
  
  void SamplingProfiler::reportTopBytecodes(PrintStream&amp; out)
  {
<span class="line-modified">!     LockHolder locker(m_lock);</span>
      DeferGCForAWhile deferGC(m_vm.heap);
  
      {
          HeapIterationScope heapIterationScope(m_vm.heap);
<span class="line-modified">!         processUnverifiedStackTraces();</span>
      }
  
      HashMap&lt;String, size_t&gt; bytecodeCounts;
      for (StackTrace&amp; stackTrace : m_stackTraces) {
          if (!stackTrace.frames.size())
<span class="line-new-header">--- 1077,16 ---</span>
      reportTopBytecodes(WTF::dataFile());
  }
  
  void SamplingProfiler::reportTopBytecodes(PrintStream&amp; out)
  {
<span class="line-modified">!     auto locker = holdLock(m_lock);</span>
      DeferGCForAWhile deferGC(m_vm.heap);
  
      {
          HeapIterationScope heapIterationScope(m_vm.heap);
<span class="line-modified">!         processUnverifiedStackTraces(locker);</span>
      }
  
      HashMap&lt;String, size_t&gt; bytecodeCounts;
      for (StackTrace&amp; stackTrace : m_stackTraces) {
          if (!stackTrace.frames.size())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1112,11 ***</span>
          auto descriptionForLocation = [&amp;] (StackFrame::CodeLocation location, Optional&lt;Wasm::CompilationMode&gt; wasmCompilationMode) -&gt; String {
              String bytecodeIndex;
              String codeBlockHash;
              String jitType;
              if (location.hasBytecodeIndex())
<span class="line-modified">!                 bytecodeIndex = String::number(location.bytecodeIndex);</span>
              else
                  bytecodeIndex = &quot;&lt;nil&gt;&quot;;
  
              if (location.hasCodeBlockHash()) {
                  StringPrintStream stream;
<span class="line-new-header">--- 1095,11 ---</span>
          auto descriptionForLocation = [&amp;] (StackFrame::CodeLocation location, Optional&lt;Wasm::CompilationMode&gt; wasmCompilationMode) -&gt; String {
              String bytecodeIndex;
              String codeBlockHash;
              String jitType;
              if (location.hasBytecodeIndex())
<span class="line-modified">!                 bytecodeIndex = toString(location.bytecodeIndex);</span>
              else
                  bytecodeIndex = &quot;&lt;nil&gt;&quot;;
  
              if (location.hasCodeBlockHash()) {
                  StringPrintStream stream;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1143,11 ***</span>
      }
  
      auto takeMax = [&amp;] () -&gt; std::pair&lt;String, size_t&gt; {
          String maxFrameDescription;
          size_t maxFrameCount = 0;
<span class="line-modified">!         for (auto entry : bytecodeCounts) {</span>
              if (entry.value &gt; maxFrameCount) {
                  maxFrameCount = entry.value;
                  maxFrameDescription = entry.key;
              }
          }
<span class="line-new-header">--- 1126,11 ---</span>
      }
  
      auto takeMax = [&amp;] () -&gt; std::pair&lt;String, size_t&gt; {
          String maxFrameDescription;
          size_t maxFrameCount = 0;
<span class="line-modified">!         for (const auto&amp; entry : bytecodeCounts) {</span>
              if (entry.value &gt; maxFrameCount) {
                  maxFrameCount = entry.value;
                  maxFrameDescription = entry.key;
              }
          }
</pre>
<center><a href="RegExpStringIteratorPrototype.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SamplingProfiler.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
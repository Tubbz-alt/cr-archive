<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSModuleLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015-2019 Apple Inc. All Rights Reserved.
  3  * Copyright (C) 2016 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;JSModuleLoader.h&quot;
 29 
 30 #include &quot;BuiltinNames.h&quot;
 31 #include &quot;CatchScope.h&quot;
 32 #include &quot;CodeProfiling.h&quot;
 33 #include &quot;Error.h&quot;
 34 #include &quot;Exception.h&quot;
 35 #include &quot;JSCInlines.h&quot;
 36 #include &quot;JSGlobalObjectFunctions.h&quot;
 37 #include &quot;JSInternalPromise.h&quot;
 38 #include &quot;JSMap.h&quot;
 39 #include &quot;JSModuleEnvironment.h&quot;
 40 #include &quot;JSModuleNamespaceObject.h&quot;
 41 #include &quot;JSModuleRecord.h&quot;
 42 #include &quot;JSSourceCode.h&quot;
 43 #include &quot;JSWebAssembly.h&quot;
 44 #include &quot;ModuleAnalyzer.h&quot;
 45 #include &quot;Nodes.h&quot;
 46 #include &quot;ObjectConstructor.h&quot;
 47 #include &quot;Parser.h&quot;
 48 #include &quot;ParserError.h&quot;
 49 
 50 namespace JSC {
 51 
 52 static EncodedJSValue JSC_HOST_CALL moduleLoaderParseModule(JSGlobalObject*, CallFrame*);
 53 static EncodedJSValue JSC_HOST_CALL moduleLoaderRequestedModules(JSGlobalObject*, CallFrame*);
 54 static EncodedJSValue JSC_HOST_CALL moduleLoaderEvaluate(JSGlobalObject*, CallFrame*);
 55 static EncodedJSValue JSC_HOST_CALL moduleLoaderModuleDeclarationInstantiation(JSGlobalObject*, CallFrame*);
 56 static EncodedJSValue JSC_HOST_CALL moduleLoaderResolve(JSGlobalObject*, CallFrame*);
 57 static EncodedJSValue JSC_HOST_CALL moduleLoaderResolveSync(JSGlobalObject*, CallFrame*);
 58 static EncodedJSValue JSC_HOST_CALL moduleLoaderFetch(JSGlobalObject*, CallFrame*);
 59 static EncodedJSValue JSC_HOST_CALL moduleLoaderGetModuleNamespaceObject(JSGlobalObject*, CallFrame*);
 60 
 61 }
 62 
 63 #include &quot;JSModuleLoader.lut.h&quot;
 64 
 65 namespace JSC {
 66 
 67 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(JSModuleLoader);
 68 
 69 const ClassInfo JSModuleLoader::s_info = { &quot;ModuleLoader&quot;, &amp;Base::s_info, &amp;moduleLoaderTable, nullptr, CREATE_METHOD_TABLE(JSModuleLoader) };
 70 
 71 /* Source for JSModuleLoader.lut.h
 72 @begin moduleLoaderTable
 73     ensureRegistered               JSBuiltin                                  DontEnum|Function 1
 74     forceFulfillPromise            JSBuiltin                                  DontEnum|Function 2
 75     fulfillFetch                   JSBuiltin                                  DontEnum|Function 2
 76     requestFetch                   JSBuiltin                                  DontEnum|Function 3
 77     requestInstantiate             JSBuiltin                                  DontEnum|Function 3
 78     requestSatisfy                 JSBuiltin                                  DontEnum|Function 3
 79     link                           JSBuiltin                                  DontEnum|Function 2
 80     moduleDeclarationInstantiation moduleLoaderModuleDeclarationInstantiation DontEnum|Function 2
 81     moduleEvaluation               JSBuiltin                                  DontEnum|Function 2
 82     evaluate                       moduleLoaderEvaluate                       DontEnum|Function 3
 83     provideFetch                   JSBuiltin                                  DontEnum|Function 2
 84     loadAndEvaluateModule          JSBuiltin                                  DontEnum|Function 3
 85     loadModule                     JSBuiltin                                  DontEnum|Function 3
 86     linkAndEvaluateModule          JSBuiltin                                  DontEnum|Function 2
 87     requestImportModule            JSBuiltin                                  DontEnum|Function 3
 88     dependencyKeysIfEvaluated      JSBuiltin                                  DontEnum|Function 1
 89     getModuleNamespaceObject       moduleLoaderGetModuleNamespaceObject       DontEnum|Function 1
 90     parseModule                    moduleLoaderParseModule                    DontEnum|Function 2
 91     requestedModules               moduleLoaderRequestedModules               DontEnum|Function 1
 92     resolve                        moduleLoaderResolve                        DontEnum|Function 2
 93     resolveSync                    moduleLoaderResolveSync                    DontEnum|Function 2
 94     fetch                          moduleLoaderFetch                          DontEnum|Function 3
 95 @end
 96 */
 97 
 98 JSModuleLoader::JSModuleLoader(VM&amp; vm, Structure* structure)
 99     : JSNonFinalObject(vm, structure)
100 {
101 }
102 
103 void JSModuleLoader::finishCreation(JSGlobalObject* globalObject, VM&amp; vm)
104 {
105     auto scope = DECLARE_CATCH_SCOPE(vm);
106 
107     Base::finishCreation(vm);
108     ASSERT(inherits(vm, info()));
109     JSMap* map = JSMap::create(globalObject, vm, globalObject-&gt;mapStructure());
110     scope.releaseAssertNoException();
111     putDirect(vm, Identifier::fromString(vm, &quot;registry&quot;), map);
112 }
113 
114 // ------------------------------ Functions --------------------------------
115 
116 static String printableModuleKey(JSGlobalObject* globalObject, JSValue key)
117 {
118     VM&amp; vm = globalObject-&gt;vm();
119     auto scope = DECLARE_CATCH_SCOPE(vm);
120     if (key.isString() || key.isSymbol()) {
121         auto propertyName = key.toPropertyKey(globalObject);
122         scope.assertNoException(); // This is OK since this function is just for debugging purpose.
123         return propertyName.impl();
124     }
125     return vm.propertyNames-&gt;emptyIdentifier.impl();
126 }
127 
128 JSArray* JSModuleLoader::dependencyKeysIfEvaluated(JSGlobalObject* globalObject, JSValue key)
129 {
130     VM&amp; vm = globalObject-&gt;vm();
131     auto scope = DECLARE_THROW_SCOPE(vm);
132 
133     JSObject* function = jsCast&lt;JSObject*&gt;(get(globalObject, vm.propertyNames-&gt;builtinNames().dependencyKeysIfEvaluatedPublicName()));
134     RETURN_IF_EXCEPTION(scope, nullptr);
135     CallData callData;
136     CallType callType = JSC::getCallData(vm, function, callData);
137     ASSERT(callType != CallType::None);
138 
139     MarkedArgumentBuffer arguments;
140     arguments.append(key);
141 
142     JSValue result = call(globalObject, function, callType, callData, this, arguments);
143     RETURN_IF_EXCEPTION(scope, nullptr);
144 
145     return jsDynamicCast&lt;JSArray*&gt;(vm, result);
146 }
147 
148 JSValue JSModuleLoader::provideFetch(JSGlobalObject* globalObject, JSValue key, const SourceCode&amp; sourceCode)
149 {
150     VM&amp; vm = globalObject-&gt;vm();
151     auto scope = DECLARE_THROW_SCOPE(vm);
152 
153     JSObject* function = jsCast&lt;JSObject*&gt;(get(globalObject, vm.propertyNames-&gt;builtinNames().provideFetchPublicName()));
154     RETURN_IF_EXCEPTION(scope, { });
155     CallData callData;
156     CallType callType = JSC::getCallData(vm, function, callData);
157     ASSERT(callType != CallType::None);
158 
159     SourceCode source { sourceCode };
160     MarkedArgumentBuffer arguments;
161     arguments.append(key);
162     arguments.append(JSSourceCode::create(vm, WTFMove(source)));
163     ASSERT(!arguments.hasOverflowed());
164 
165     RELEASE_AND_RETURN(scope, call(globalObject, function, callType, callData, this, arguments));
166 }
167 
168 JSInternalPromise* JSModuleLoader::loadAndEvaluateModule(JSGlobalObject* globalObject, JSValue moduleName, JSValue parameters, JSValue scriptFetcher)
169 {
170     VM&amp; vm = globalObject-&gt;vm();
171     auto scope = DECLARE_THROW_SCOPE(vm);
172 
173     JSObject* function = jsCast&lt;JSObject*&gt;(get(globalObject, vm.propertyNames-&gt;builtinNames().loadAndEvaluateModulePublicName()));
174     RETURN_IF_EXCEPTION(scope, nullptr);
175     CallData callData;
176     CallType callType = JSC::getCallData(vm, function, callData);
177     ASSERT(callType != CallType::None);
178 
179     MarkedArgumentBuffer arguments;
180     arguments.append(moduleName);
181     arguments.append(parameters);
182     arguments.append(scriptFetcher);
183     ASSERT(!arguments.hasOverflowed());
184 
185     JSValue promise = call(globalObject, function, callType, callData, this, arguments);
186     RETURN_IF_EXCEPTION(scope, nullptr);
187     return jsCast&lt;JSInternalPromise*&gt;(promise);
188 }
189 
190 JSInternalPromise* JSModuleLoader::loadModule(JSGlobalObject* globalObject, JSValue moduleName, JSValue parameters, JSValue scriptFetcher)
191 {
192     VM&amp; vm = globalObject-&gt;vm();
193     auto scope = DECLARE_THROW_SCOPE(vm);
194 
195     JSObject* function = jsCast&lt;JSObject*&gt;(get(globalObject, vm.propertyNames-&gt;builtinNames().loadModulePublicName()));
196     RETURN_IF_EXCEPTION(scope, nullptr);
197     CallData callData;
198     CallType callType = JSC::getCallData(vm, function, callData);
199     ASSERT(callType != CallType::None);
200 
201     MarkedArgumentBuffer arguments;
202     arguments.append(moduleName);
203     arguments.append(parameters);
204     arguments.append(scriptFetcher);
205     ASSERT(!arguments.hasOverflowed());
206 
207     JSValue promise = call(globalObject, function, callType, callData, this, arguments);
208     RETURN_IF_EXCEPTION(scope, nullptr);
209     return jsCast&lt;JSInternalPromise*&gt;(promise);
210 }
211 
212 JSValue JSModuleLoader::linkAndEvaluateModule(JSGlobalObject* globalObject, JSValue moduleKey, JSValue scriptFetcher)
213 {
214     VM&amp; vm = globalObject-&gt;vm();
215     auto scope = DECLARE_THROW_SCOPE(vm);
216 
217     JSObject* function = jsCast&lt;JSObject*&gt;(get(globalObject, vm.propertyNames-&gt;builtinNames().linkAndEvaluateModulePublicName()));
218     RETURN_IF_EXCEPTION(scope, { });
219     CallData callData;
220     CallType callType = JSC::getCallData(vm, function, callData);
221     ASSERT(callType != CallType::None);
222 
223     MarkedArgumentBuffer arguments;
224     arguments.append(moduleKey);
225     arguments.append(scriptFetcher);
226     ASSERT(!arguments.hasOverflowed());
227 
228     RELEASE_AND_RETURN(scope, call(globalObject, function, callType, callData, this, arguments));
229 }
230 
231 JSInternalPromise* JSModuleLoader::requestImportModule(JSGlobalObject* globalObject, const Identifier&amp; moduleKey, JSValue parameters, JSValue scriptFetcher)
232 {
233     VM&amp; vm = globalObject-&gt;vm();
234     auto scope = DECLARE_THROW_SCOPE(vm);
235 
236     auto* function = jsCast&lt;JSObject*&gt;(get(globalObject, vm.propertyNames-&gt;builtinNames().requestImportModulePublicName()));
237     RETURN_IF_EXCEPTION(scope, nullptr);
238     CallData callData;
239     auto callType = JSC::getCallData(vm, function, callData);
240     ASSERT(callType != CallType::None);
241 
242     MarkedArgumentBuffer arguments;
243     arguments.append(jsString(vm, moduleKey.impl()));
244     arguments.append(parameters);
245     arguments.append(scriptFetcher);
246     ASSERT(!arguments.hasOverflowed());
247 
248     JSValue promise = call(globalObject, function, callType, callData, this, arguments);
249     RETURN_IF_EXCEPTION(scope, nullptr);
250     return jsCast&lt;JSInternalPromise*&gt;(promise);
251 }
252 
253 JSInternalPromise* JSModuleLoader::importModule(JSGlobalObject* globalObject, JSString* moduleName, JSValue parameters, const SourceOrigin&amp; referrer)
254 {
255     dataLogLnIf(Options::dumpModuleLoadingState(), &quot;Loader [import] &quot;, printableModuleKey(globalObject, moduleName));
256 
257     VM&amp; vm = globalObject-&gt;vm();
258     auto throwScope = DECLARE_THROW_SCOPE(vm);
259 
260     if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderImportModule)
261         RELEASE_AND_RETURN(throwScope, globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderImportModule(globalObject, this, moduleName, parameters, referrer));
262 
263     auto* promise = JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());
264 
265     auto catchScope = DECLARE_CATCH_SCOPE(vm);
266     auto moduleNameString = moduleName-&gt;value(globalObject);
267     if (UNLIKELY(catchScope.exception())) {
268         JSValue exception = catchScope.exception()-&gt;value();
269         catchScope.clearException();
270         promise-&gt;reject(globalObject, exception);
271         catchScope.clearException();
272         return promise;
273     }
274     promise-&gt;reject(globalObject, createError(globalObject, makeString(&quot;Could not import the module &#39;&quot;, moduleNameString, &quot;&#39;.&quot;)));
275     catchScope.clearException();
276     return promise;
277 }
278 
279 Identifier JSModuleLoader::resolveSync(JSGlobalObject* globalObject, JSValue name, JSValue referrer, JSValue scriptFetcher)
280 {
281     dataLogLnIf(Options::dumpModuleLoadingState(), &quot;Loader [resolve] &quot;, printableModuleKey(globalObject, name));
282 
283     if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderResolve)
284         return globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderResolve(globalObject, this, name, referrer, scriptFetcher);
285     return name.toPropertyKey(globalObject);
286 }
287 
288 JSInternalPromise* JSModuleLoader::resolve(JSGlobalObject* globalObject, JSValue name, JSValue referrer, JSValue scriptFetcher)
289 {
290     VM&amp; vm = globalObject-&gt;vm();
291 
292     auto* promise = JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());
293 
294     auto catchScope = DECLARE_CATCH_SCOPE(vm);
295 
296     const Identifier moduleKey = resolveSync(globalObject, name, referrer, scriptFetcher);
297     if (UNLIKELY(catchScope.exception())) {
298         JSValue exception = catchScope.exception();
299         catchScope.clearException();
300         promise-&gt;reject(globalObject, exception);
301         catchScope.clearException();
302         return promise;
303     }
304     promise-&gt;resolve(globalObject, identifierToJSValue(vm, moduleKey));
305     catchScope.clearException();
306     return promise;
307 }
308 
309 JSInternalPromise* JSModuleLoader::fetch(JSGlobalObject* globalObject, JSValue key, JSValue parameters, JSValue scriptFetcher)
310 {
311     dataLogLnIf(Options::dumpModuleLoadingState(), &quot;Loader [fetch] &quot;, printableModuleKey(globalObject, key));
312 
313     VM&amp; vm = globalObject-&gt;vm();
314     auto throwScope = DECLARE_THROW_SCOPE(vm);
315 
316     if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderFetch)
317         RELEASE_AND_RETURN(throwScope, globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderFetch(globalObject, this, key, parameters, scriptFetcher));
318 
319     auto* promise = JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());
320 
321     auto catchScope = DECLARE_CATCH_SCOPE(vm);
322 
323     String moduleKey = key.toWTFString(globalObject);
324     if (UNLIKELY(catchScope.exception())) {
325         JSValue exception = catchScope.exception()-&gt;value();
326         catchScope.clearException();
327         promise-&gt;reject(globalObject, exception);
328         catchScope.clearException();
329         return promise;
330     }
331     promise-&gt;reject(globalObject, createError(globalObject, makeString(&quot;Could not open the module &#39;&quot;, moduleKey, &quot;&#39;.&quot;)));
332     catchScope.clearException();
333     return promise;
334 }
335 
336 JSObject* JSModuleLoader::createImportMetaProperties(JSGlobalObject* globalObject, JSValue key, JSModuleRecord* moduleRecord, JSValue scriptFetcher)
337 {
338     if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderCreateImportMetaProperties)
339         return globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderCreateImportMetaProperties(globalObject, this, key, moduleRecord, scriptFetcher);
340     return constructEmptyObject(globalObject-&gt;vm(), globalObject-&gt;nullPrototypeObjectStructure());
341 }
342 
343 JSValue JSModuleLoader::evaluate(JSGlobalObject* globalObject, JSValue key, JSValue moduleRecordValue, JSValue scriptFetcher)
344 {
345     dataLogLnIf(Options::dumpModuleLoadingState(), &quot;Loader [evaluate] &quot;, printableModuleKey(globalObject, key));
346 
347     if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderEvaluate)
348         return globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderEvaluate(globalObject, this, key, moduleRecordValue, scriptFetcher);
349 
350     return evaluateNonVirtual(globalObject, key, moduleRecordValue, scriptFetcher);
351 }
352 
353 JSValue JSModuleLoader::evaluateNonVirtual(JSGlobalObject* globalObject, JSValue, JSValue moduleRecordValue, JSValue)
354 {
355     if (auto* moduleRecord = jsDynamicCast&lt;AbstractModuleRecord*&gt;(globalObject-&gt;vm(), moduleRecordValue))
356         return moduleRecord-&gt;evaluate(globalObject);
357     return jsUndefined();
358 }
359 
360 JSModuleNamespaceObject* JSModuleLoader::getModuleNamespaceObject(JSGlobalObject* globalObject, JSValue moduleRecordValue)
361 {
362     VM&amp; vm = globalObject-&gt;vm();
363     auto scope = DECLARE_THROW_SCOPE(vm);
364 
365     auto* moduleRecord = jsDynamicCast&lt;AbstractModuleRecord*&gt;(vm, moduleRecordValue);
366     if (!moduleRecord) {
367         throwTypeError(globalObject, scope);
368         return nullptr;
369     }
370 
371     RELEASE_AND_RETURN(scope, moduleRecord-&gt;getModuleNamespace(globalObject));
372 }
373 
374 // ------------------------------ Functions --------------------------------
375 
376 EncodedJSValue JSC_HOST_CALL moduleLoaderParseModule(JSGlobalObject* globalObject, CallFrame* callFrame)
377 {
378     VM&amp; vm = globalObject-&gt;vm();
379 
380     auto* promise = JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());
381 
382     auto catchScope = DECLARE_CATCH_SCOPE(vm);
383     auto reject = [&amp;] (JSValue rejectionReason) {
384         catchScope.clearException();
385         promise-&gt;reject(globalObject, rejectionReason);
386         catchScope.clearException();
387         return JSValue::encode(promise);
388     };
389 
390     const Identifier moduleKey = callFrame-&gt;argument(0).toPropertyKey(globalObject);
391     if (UNLIKELY(catchScope.exception()))
392         return reject(catchScope.exception());
393 
394     JSValue source = callFrame-&gt;argument(1);
395     auto* jsSourceCode = jsCast&lt;JSSourceCode*&gt;(source);
396     SourceCode sourceCode = jsSourceCode-&gt;sourceCode();
397 
398 #if ENABLE(WEBASSEMBLY)
399     if (sourceCode.provider()-&gt;sourceType() == SourceProviderSourceType::WebAssembly)
400         return JSValue::encode(JSWebAssembly::instantiate(globalObject, promise, moduleKey, jsSourceCode));
401 #endif
402 
403     CodeProfiling profile(sourceCode);
404 
405     ParserError error;
406     std::unique_ptr&lt;ModuleProgramNode&gt; moduleProgramNode = parse&lt;ModuleProgramNode&gt;(
407         vm, sourceCode, Identifier(), JSParserBuiltinMode::NotBuiltin,
408         JSParserStrictMode::Strict, JSParserScriptMode::Module, SourceParseMode::ModuleAnalyzeMode, SuperBinding::NotNeeded, error);
409     if (error.isValid())
410         return reject(error.toErrorObject(globalObject, sourceCode));
411     ASSERT(moduleProgramNode);
412 
413     ModuleAnalyzer moduleAnalyzer(globalObject, moduleKey, sourceCode, moduleProgramNode-&gt;varDeclarations(), moduleProgramNode-&gt;lexicalVariables());
414     if (UNLIKELY(catchScope.exception()))
415         return reject(catchScope.exception());
416 
417     promise-&gt;resolve(globalObject, moduleAnalyzer.analyze(*moduleProgramNode));
418     catchScope.clearException();
419     return JSValue::encode(promise);
420 }
421 
422 EncodedJSValue JSC_HOST_CALL moduleLoaderRequestedModules(JSGlobalObject* globalObject, CallFrame* callFrame)
423 {
424     VM&amp; vm = globalObject-&gt;vm();
425     auto scope = DECLARE_THROW_SCOPE(vm);
426     auto* moduleRecord = jsDynamicCast&lt;AbstractModuleRecord*&gt;(vm, callFrame-&gt;argument(0));
427     if (!moduleRecord)
428         RELEASE_AND_RETURN(scope, JSValue::encode(constructEmptyArray(globalObject, nullptr)));
429 
430     JSArray* result = constructEmptyArray(globalObject, nullptr, moduleRecord-&gt;requestedModules().size());
431     RETURN_IF_EXCEPTION(scope, encodedJSValue());
432     size_t i = 0;
433     for (auto&amp; key : moduleRecord-&gt;requestedModules()) {
434         result-&gt;putDirectIndex(globalObject, i++, jsString(vm, key.get()));
435         RETURN_IF_EXCEPTION(scope, encodedJSValue());
436     }
437     return JSValue::encode(result);
438 }
439 
440 EncodedJSValue JSC_HOST_CALL moduleLoaderModuleDeclarationInstantiation(JSGlobalObject* globalObject, CallFrame* callFrame)
441 {
442     VM&amp; vm = globalObject-&gt;vm();
443     auto scope = DECLARE_THROW_SCOPE(vm);
444     auto* moduleRecord = jsDynamicCast&lt;AbstractModuleRecord*&gt;(vm, callFrame-&gt;argument(0));
445     if (!moduleRecord)
446         return JSValue::encode(jsUndefined());
447 
448     dataLogLnIf(Options::dumpModuleLoadingState(), &quot;Loader [link] &quot;, moduleRecord-&gt;moduleKey());
449 
450     moduleRecord-&gt;link(globalObject, callFrame-&gt;argument(1));
451     RETURN_IF_EXCEPTION(scope, encodedJSValue());
452 
453     return JSValue::encode(jsUndefined());
454 }
455 
456 // ------------------------------ Hook Functions ---------------------------
457 
458 EncodedJSValue JSC_HOST_CALL moduleLoaderResolve(JSGlobalObject* globalObject, CallFrame* callFrame)
459 {
460     VM&amp; vm = globalObject-&gt;vm();
461     // Hook point, Loader.resolve.
462     // https://whatwg.github.io/loader/#browser-resolve
463     // Take the name and resolve it to the unique identifier for the resource location.
464     // For example, take the &quot;jquery&quot; and return the URL for the resource.
465     JSModuleLoader* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, callFrame-&gt;thisValue());
466     if (!loader)
467         return JSValue::encode(jsUndefined());
468     return JSValue::encode(loader-&gt;resolve(globalObject, callFrame-&gt;argument(0), callFrame-&gt;argument(1), callFrame-&gt;argument(2)));
469 }
470 
471 EncodedJSValue JSC_HOST_CALL moduleLoaderResolveSync(JSGlobalObject* globalObject, CallFrame* callFrame)
472 {
473     VM&amp; vm = globalObject-&gt;vm();
474     auto scope = DECLARE_THROW_SCOPE(vm);
475 
476     JSModuleLoader* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, callFrame-&gt;thisValue());
477     if (!loader)
478         return JSValue::encode(jsUndefined());
479     auto result = loader-&gt;resolveSync(globalObject, callFrame-&gt;argument(0), callFrame-&gt;argument(1), callFrame-&gt;argument(2));
480     RETURN_IF_EXCEPTION(scope, encodedJSValue());
481     return JSValue::encode(identifierToJSValue(vm, result));
482 }
483 
484 EncodedJSValue JSC_HOST_CALL moduleLoaderFetch(JSGlobalObject* globalObject, CallFrame* callFrame)
485 {
486     VM&amp; vm = globalObject-&gt;vm();
487     // Hook point, Loader.fetch
488     // https://whatwg.github.io/loader/#browser-fetch
489     // Take the key and fetch the resource actually.
490     // For example, JavaScriptCore shell can provide the hook fetching the resource
491     // from the local file system.
492     JSModuleLoader* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, callFrame-&gt;thisValue());
493     if (!loader)
494         return JSValue::encode(jsUndefined());
495     return JSValue::encode(loader-&gt;fetch(globalObject, callFrame-&gt;argument(0), callFrame-&gt;argument(1), callFrame-&gt;argument(2)));
496 }
497 
498 EncodedJSValue JSC_HOST_CALL moduleLoaderGetModuleNamespaceObject(JSGlobalObject* globalObject, CallFrame* callFrame)
499 {
500     VM&amp; vm = globalObject-&gt;vm();
501     auto scope = DECLARE_THROW_SCOPE(vm);
502 
503     auto* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, callFrame-&gt;thisValue());
504     if (!loader)
505         return JSValue::encode(jsUndefined());
506     auto* moduleNamespaceObject = loader-&gt;getModuleNamespaceObject(globalObject, callFrame-&gt;argument(0));
507     RETURN_IF_EXCEPTION(scope, encodedJSValue());
508     return JSValue::encode(moduleNamespaceObject);
509 }
510 
511 // ------------------- Additional Hook Functions ---------------------------
512 
513 EncodedJSValue JSC_HOST_CALL moduleLoaderEvaluate(JSGlobalObject* globalObject, CallFrame* callFrame)
514 {
515     // To instrument and retrieve the errors raised from the module execution,
516     // we inserted the hook point here.
517 
518     VM&amp; vm = globalObject-&gt;vm();
519     JSModuleLoader* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, callFrame-&gt;thisValue());
520     if (!loader)
521         return JSValue::encode(jsUndefined());
522     return JSValue::encode(loader-&gt;evaluate(globalObject, callFrame-&gt;argument(0), callFrame-&gt;argument(1), callFrame-&gt;argument(2)));
523 }
524 
525 } // namespace JSC
    </pre>
  </body>
</html>
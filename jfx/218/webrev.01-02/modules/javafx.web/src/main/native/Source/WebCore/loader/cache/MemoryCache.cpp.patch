diff a/modules/javafx.web/src/main/native/Source/WebCore/loader/cache/MemoryCache.cpp b/modules/javafx.web/src/main/native/Source/WebCore/loader/cache/MemoryCache.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/loader/cache/MemoryCache.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/loader/cache/MemoryCache.cpp
@@ -202,56 +202,10 @@
 {
     // Live resource capacity is whatever is left over after calculating dead resource capacity.
     return m_capacity - deadCapacity();
 }
 
-static CachedImageClient& dummyCachedImageClient()
-{
-    static NeverDestroyed<CachedImageClient> client;
-    return client;
-}
-
-bool MemoryCache::addImageToCache(NativeImagePtr&& image, const URL& url, const String& domainForCachePartition, const PAL::SessionID& sessionID, const CookieJar* cookieJar)
-{
-    ASSERT(image);
-    removeImageFromCache(url, domainForCachePartition); // Remove cache entry if it already exists.
-
-    auto bitmapImage = BitmapImage::create(WTFMove(image), nullptr);
-    auto cachedImage = makeUnique<CachedImage>(url, bitmapImage.ptr(), sessionID, cookieJar, domainForCachePartition);
-
-    cachedImage->addClient(dummyCachedImageClient());
-    cachedImage->setDecodedSize(bitmapImage->decodedSize());
-
-    return add(*cachedImage.release());
-}
-
-void MemoryCache::removeImageFromCache(const URL& url, const String& domainForCachePartition)
-{
-    auto* resources = sessionResourceMap(PAL::SessionID::defaultSessionID());
-    if (!resources)
-        return;
-
-    auto key = std::make_pair(url, ResourceRequest::partitionName(domainForCachePartition));
-
-    CachedResource* resource = resources->get(key);
-    if (!resource)
-        return;
-
-    // A resource exists and is not a manually cached image, so just remove it.
-    if (!is<CachedImage>(*resource) || !downcast<CachedImage>(*resource).isManuallyCached()) {
-        remove(*resource);
-        return;
-    }
-
-    // Removing the last client of a CachedImage turns the resource
-    // into a dead resource which will eventually be evicted when
-    // dead resources are pruned. That might be immediately since
-    // removing the last client triggers a MemoryCache::prune, so the
-    // resource may be deleted after this call.
-    downcast<CachedImage>(*resource).removeClient(dummyCachedImageClient());
-}
-
 void MemoryCache::pruneLiveResources(bool shouldDestroyDecodedDataForAllLiveResources)
 {
     unsigned capacity = shouldDestroyDecodedDataForAllLiveResources ? 0 : liveCapacity();
     if (capacity && m_liveSize <= capacity)
         return;
@@ -440,10 +394,12 @@
     // who needed a fresh copy for a reload. See <http://bugs.webkit.org/show_bug.cgi?id=12479#c6>.
     if (auto* resources = sessionResourceMap(resource.sessionID())) {
         auto key = std::make_pair(resource.url(), resource.cachePartition());
 
         if (resource.inCache()) {
+            ASSERT_WITH_MESSAGE(resource.response().source() != ResourceResponse::Source::InspectorOverride, "InspectorOverride responses should not get into the MemoryCache");
+
             // Remove resource from the resource map.
             resources->remove(key);
             resource.setInCache(false);
 
             // If the resource map is now empty, remove it from m_sessionResources.
@@ -465,11 +421,11 @@
 
 auto MemoryCache::lruListFor(CachedResource& resource) -> LRUList&
 {
     unsigned accessCount = std::max(resource.accessCount(), 1U);
     unsigned queueIndex = WTF::fastLog2(resource.size() / accessCount);
-#ifndef NDEBUG
+#if ASSERT_ENABLED
     resource.m_lruIndex = queueIndex;
 #endif
 
     m_allResources.reserveCapacity(queueIndex + 1);
     while (m_allResources.size() <= queueIndex)
@@ -481,11 +437,11 @@
 {
     // If we've never been accessed, then we're brand new and not in any list.
     if (!resource.accessCount())
         return;
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     unsigned oldListIndex = resource.m_lruIndex;
 #endif
 
     LRUList& list = lruListFor(resource);
 

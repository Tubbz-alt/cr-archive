<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/dom/KeyboardEvent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2001 Peter Kelly (pmk@post.com)
  3  * Copyright (C) 2001 Tobias Anton (anton@stud.fbi.fh-darmstadt.de)
  4  * Copyright (C) 2006 Samuel Weinig (sam.weinig@gmail.com)
  5  * Copyright (C) 2003-2018 Apple Inc. All rights reserved.
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  */
 22 
 23 #include &quot;config.h&quot;
 24 #include &quot;KeyboardEvent.h&quot;
 25 
 26 #include &quot;DOMWindow.h&quot;
 27 #include &quot;Document.h&quot;
 28 #include &quot;Editor.h&quot;
 29 #include &quot;EventHandler.h&quot;
 30 #include &quot;EventNames.h&quot;
 31 #include &quot;Frame.h&quot;
 32 #include &quot;PlatformKeyboardEvent.h&quot;
 33 #include &quot;WindowsKeyboardCodes.h&quot;
 34 #include &lt;wtf/IsoMallocInlines.h&gt;
 35 
 36 namespace WebCore {
 37 
 38 WTF_MAKE_ISO_ALLOCATED_IMPL(KeyboardEvent);
 39 
 40 static inline const AtomString&amp; eventTypeForKeyboardEventType(PlatformEvent::Type type)
 41 {
 42     switch (type) {
 43         case PlatformEvent::KeyUp:
 44             return eventNames().keyupEvent;
 45         case PlatformEvent::RawKeyDown:
 46             return eventNames().keydownEvent;
 47         case PlatformEvent::Char:
 48             return eventNames().keypressEvent;
 49         case PlatformEvent::KeyDown:
 50             // The caller should disambiguate the combined event into RawKeyDown or Char events.
 51             break;
 52         default:
 53             break;
 54     }
 55     ASSERT_NOT_REACHED();
 56     return eventNames().keydownEvent;
 57 }
 58 
 59 static inline int windowsVirtualKeyCodeWithoutLocation(int keycode)
 60 {
 61     switch (keycode) {
 62     case VK_LCONTROL:
 63     case VK_RCONTROL:
 64         return VK_CONTROL;
 65     case VK_LSHIFT:
 66     case VK_RSHIFT:
 67         return VK_SHIFT;
 68     case VK_LMENU:
 69     case VK_RMENU:
 70         return VK_MENU;
 71     default:
 72         return keycode;
 73     }
 74 }
 75 
 76 static inline KeyboardEvent::KeyLocationCode keyLocationCode(const PlatformKeyboardEvent&amp; key)
 77 {
 78     if (key.isKeypad())
 79         return KeyboardEvent::DOM_KEY_LOCATION_NUMPAD;
 80 
 81     switch (key.windowsVirtualKeyCode()) {
 82     case VK_LCONTROL:
 83     case VK_LSHIFT:
 84     case VK_LMENU: // Left Option/Alt
 85     case VK_LWIN: // Left Command/Windows key (Natural keyboard)
 86         return KeyboardEvent::DOM_KEY_LOCATION_LEFT;
 87     case VK_RCONTROL:
 88     case VK_RSHIFT:
 89     case VK_RMENU: // Right Option/Alt
 90     case VK_RWIN: // Right Windows key (Natural keyboard)
 91 #if PLATFORM(COCOA)
 92     // FIXME: WebCore maps the right command key to VK_APPS even though the USB HID spec.,
 93     // &lt;https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf&gt;, states that it
 94     // should map to the same key as the right Windows key (VK_RWIN).
 95     case VK_APPS: // Right Command
 96 #endif
 97         return KeyboardEvent::DOM_KEY_LOCATION_RIGHT;
 98     default:
 99         return KeyboardEvent::DOM_KEY_LOCATION_STANDARD;
100     }
101 }
102 
103 inline KeyboardEvent::KeyboardEvent() = default;
104 
105 inline KeyboardEvent::KeyboardEvent(const PlatformKeyboardEvent&amp; key, RefPtr&lt;WindowProxy&gt;&amp;&amp; view)
106     : UIEventWithKeyState(eventTypeForKeyboardEventType(key.type()), CanBubble::Yes, IsCancelable::Yes, IsComposed::Yes,
107         key.timestamp().approximateMonotonicTime(), view.copyRef(), 0, key.modifiers(), IsTrusted::Yes)
108     , m_underlyingPlatformEvent(makeUnique&lt;PlatformKeyboardEvent&gt;(key))
109     , m_key(key.key())
110     , m_code(key.code())
111     , m_keyIdentifier(key.keyIdentifier())
112     , m_location(keyLocationCode(key))
113     , m_repeat(key.isAutoRepeat())
114     , m_isComposing(view &amp;&amp; is&lt;DOMWindow&gt;(view-&gt;window()) &amp;&amp; downcast&lt;DOMWindow&gt;(*view-&gt;window()).frame() &amp;&amp; downcast&lt;DOMWindow&gt;(*view-&gt;window()).frame()-&gt;editor().hasComposition())
115 #if USE(APPKIT) || USE(UIKIT_KEYBOARD_ADDITIONS)
116     , m_handledByInputMethod(key.handledByInputMethod())
117 #endif
118 #if USE(APPKIT)
119     , m_keypressCommands(key.commands())
120 #endif
121 {
122 }
123 
124 inline KeyboardEvent::KeyboardEvent(const AtomString&amp; eventType, const Init&amp; initializer)
125     : UIEventWithKeyState(eventType, initializer)
126     , m_key(initializer.key)
127     , m_code(initializer.code)
128     , m_keyIdentifier(initializer.keyIdentifier)
129     , m_location(initializer.keyLocation ? *initializer.keyLocation : initializer.location)
130     , m_repeat(initializer.repeat)
131     , m_isComposing(initializer.isComposing)
132     , m_charCode(initializer.charCode)
133     , m_keyCode(initializer.keyCode)
134     , m_which(initializer.which)
135 {
136 }
137 
138 KeyboardEvent::~KeyboardEvent() = default;
139 
140 Ref&lt;KeyboardEvent&gt; KeyboardEvent::create(const PlatformKeyboardEvent&amp; platformEvent, RefPtr&lt;WindowProxy&gt;&amp;&amp; view)
141 {
142     return adoptRef(*new KeyboardEvent(platformEvent, WTFMove(view)));
143 }
144 
145 Ref&lt;KeyboardEvent&gt; KeyboardEvent::createForBindings()
146 {
147     return adoptRef(*new KeyboardEvent);
148 }
149 
150 Ref&lt;KeyboardEvent&gt; KeyboardEvent::create(const AtomString&amp; type, const Init&amp; initializer)
151 {
152     return adoptRef(*new KeyboardEvent(type, initializer));
153 }
154 
155 void KeyboardEvent::initKeyboardEvent(const AtomString&amp; type, bool canBubble, bool cancelable, RefPtr&lt;WindowProxy&gt;&amp;&amp; view,
156     const String&amp; keyIdentifier, unsigned location, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, bool altGraphKey)
157 {
158     if (isBeingDispatched())
159         return;
160 
161     initUIEvent(type, canBubble, cancelable, WTFMove(view), 0);
162 
163     m_keyIdentifier = keyIdentifier;
164     m_location = location;
165 
166     setModifierKeys(ctrlKey, altKey, shiftKey, metaKey, altGraphKey);
167 
168     m_charCode = WTF::nullopt;
169     m_isComposing = false;
170     m_keyCode = WTF::nullopt;
171     m_repeat = false;
172     m_underlyingPlatformEvent = nullptr;
173     m_which = WTF::nullopt;
174     m_code = { };
175     m_key = { };
176 
177 #if PLATFORM(COCOA)
178     m_handledByInputMethod = false;
179     m_keypressCommands = { };
180 #endif
181 }
182 
183 int KeyboardEvent::keyCode() const
184 {
185     if (m_keyCode)
186         return m_keyCode.value();
187 
188     // IE: virtual key code for keyup/keydown, character code for keypress
189     // Firefox: virtual key code for keyup/keydown, zero for keypress
190     // We match IE.
191     if (!m_underlyingPlatformEvent)
192         return 0;
193     if (type() == eventNames().keydownEvent || type() == eventNames().keyupEvent)
194         return windowsVirtualKeyCodeWithoutLocation(m_underlyingPlatformEvent-&gt;windowsVirtualKeyCode());
195 
196     return charCode();
197 }
198 
199 int KeyboardEvent::charCode() const
200 {
201     if (m_charCode)
202         return m_charCode.value();
203 
204     // IE: not supported
205     // Firefox: 0 for keydown/keyup events, character code for keypress
206     // We match Firefox, unless in backward compatibility mode, where we always return the character code.
207     bool backwardCompatibilityMode = false;
208     auto* window = view() ? view()-&gt;window() : nullptr;
209     if (is&lt;DOMWindow&gt;(window) &amp;&amp; downcast&lt;DOMWindow&gt;(*window).frame())
210         backwardCompatibilityMode = downcast&lt;DOMWindow&gt;(*window).frame()-&gt;eventHandler().needsKeyboardEventDisambiguationQuirks();
211 
212     if (!m_underlyingPlatformEvent || (type() != eventNames().keypressEvent &amp;&amp; !backwardCompatibilityMode))
213         return 0;
214     return m_underlyingPlatformEvent-&gt;text().characterStartingAt(0);
215 }
216 
217 EventInterface KeyboardEvent::eventInterface() const
218 {
219     return KeyboardEventInterfaceType;
220 }
221 
222 bool KeyboardEvent::isKeyboardEvent() const
223 {
224     return true;
225 }
226 
227 int KeyboardEvent::which() const
228 {
229     // Netscape&#39;s &quot;which&quot; returns a virtual key code for keydown and keyup, and a character code for keypress.
230     // That&#39;s exactly what IE&#39;s &quot;keyCode&quot; returns. So they are the same for keyboard events.
231     if (m_which)
232         return m_which.value();
233     return keyCode();
234 }
235 
236 } // namespace WebCore
    </pre>
  </body>
</html>
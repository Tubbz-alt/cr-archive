<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/CustomElementReactionQueue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ContainerNodeAlgorithms.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CustomElementReactionQueue.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/CustomElementReactionQueue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;CustomElementReactionQueue.h&quot;
 28 
 29 #include &quot;CustomElementRegistry.h&quot;
 30 #include &quot;DOMWindow.h&quot;
 31 #include &quot;Document.h&quot;
 32 #include &quot;Element.h&quot;

 33 #include &quot;HTMLNames.h&quot;
 34 #include &quot;JSCustomElementInterface.h&quot;
 35 #include &quot;JSDOMBinding.h&quot;
<span class="line-modified"> 36 #include &quot;Microtasks.h&quot;</span>
 37 #include &lt;JavaScriptCore/CatchScope.h&gt;
 38 #include &lt;JavaScriptCore/Heap.h&gt;
 39 #include &lt;wtf/NeverDestroyed.h&gt;
 40 #include &lt;wtf/Optional.h&gt;
 41 #include &lt;wtf/Ref.h&gt;
 42 #include &lt;wtf/SetForScope.h&gt;
 43 
 44 namespace WebCore {
 45 
 46 class CustomElementReactionQueueItem {
 47 public:
 48     enum class Type {
 49         ElementUpgrade,
 50         Connected,
 51         Disconnected,
 52         Adopted,
 53         AttributeChanged,
 54     };
 55 
 56     CustomElementReactionQueueItem(Type type)
</pre>
<hr />
<pre>
221     }
222 
223     if (element.isConnected() &amp;&amp; queue.m_interface-&gt;hasConnectedCallback())
224         queue.m_items.append({CustomElementReactionQueueItem::Type::Connected});
225 }
226 
227 bool CustomElementReactionQueue::observesStyleAttribute() const
228 {
229     return m_interface-&gt;observesAttribute(HTMLNames::styleAttr-&gt;localName());
230 }
231 
232 void CustomElementReactionQueue::invokeAll(Element&amp; element)
233 {
234     while (!m_items.isEmpty()) {
235         Vector&lt;CustomElementReactionQueueItem&gt; items = WTFMove(m_items);
236         for (auto&amp; item : items)
237             item.invoke(element, m_interface.get());
238     }
239 }
240 
<span class="line-modified">241 inline void CustomElementReactionQueue::ElementQueue::add(Element&amp; element)</span>
242 {
243     ASSERT(!m_invoking);
244     // FIXME: Avoid inserting the same element multiple times.
245     m_elements.append(element);
246 }
247 
<span class="line-modified">248 inline void CustomElementReactionQueue::ElementQueue::invokeAll()</span>
249 {
250     RELEASE_ASSERT(!m_invoking);
251     SetForScope&lt;bool&gt; invoking(m_invoking, true);
252     unsigned originalSize = m_elements.size();
253     // It&#39;s possible for more elements to be enqueued if some IDL attributes were missing CEReactions.
254     // Invoke callbacks slightly later here instead of crashing / ignoring those cases.
255     for (unsigned i = 0; i &lt; m_elements.size(); ++i) {
256         auto&amp; element = m_elements[i].get();
257         auto* queue = element.reactionQueue();
258         ASSERT(queue);
259         queue-&gt;invokeAll(element);
260     }
261     ASSERT_UNUSED(originalSize, m_elements.size() == originalSize);
262     m_elements.clear();
263 }
264 
<span class="line-modified">265 inline void CustomElementReactionQueue::ElementQueue::processQueue(JSC::ExecState* state)</span>
266 {
267     if (!state) {
268         invokeAll();
269         return;
270     }
271 
272     auto&amp; vm = state-&gt;vm();
273     JSC::JSLockHolder lock(vm);
274 
275     JSC::Exception* previousException = nullptr;
276     {
277         auto catchScope = DECLARE_CATCH_SCOPE(vm);
278         previousException = catchScope.exception();
279         if (previousException)
280             catchScope.clearException();
281     }
282 
283     invokeAll();
284 
285     if (previousException) {
286         auto throwScope = DECLARE_THROW_SCOPE(vm);
287         throwException(state, throwScope, previousException);
288     }
289 }
290 
291 // https://html.spec.whatwg.org/multipage/custom-elements.html#enqueue-an-element-on-the-appropriate-element-queue
292 void CustomElementReactionQueue::enqueueElementOnAppropriateElementQueue(Element&amp; element)
293 {
294     ASSERT(element.reactionQueue());
295     if (!CustomElementReactionStack::s_currentProcessingStack) {
<span class="line-modified">296         auto&amp; queue = ensureBackupQueue();</span>
<span class="line-removed">297         queue.add(element);</span>
298         return;
299     }
300 
301     auto*&amp; queue = CustomElementReactionStack::s_currentProcessingStack-&gt;m_queue;
302     if (!queue) // We use a raw pointer to avoid genearing code to delete it in ~CustomElementReactionStack.
<span class="line-modified">303         queue = new ElementQueue;</span>
304     queue-&gt;add(element);
305 }
306 
<span class="line-modified">307 #if !ASSERT_DISABLED</span>
308 unsigned CustomElementReactionDisallowedScope::s_customElementReactionDisallowedCount = 0;
309 #endif
310 
311 CustomElementReactionStack* CustomElementReactionStack::s_currentProcessingStack = nullptr;
312 
<span class="line-modified">313 void CustomElementReactionStack::processQueue(JSC::ExecState* state)</span>
314 {
315     ASSERT(m_queue);
316     m_queue-&gt;processQueue(state);
317     delete m_queue;
318     m_queue = nullptr;
319 }
320 
<span class="line-modified">321 class BackupElementQueueMicrotask final : public Microtask {</span>
<span class="line-removed">322     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-removed">323 private:</span>
<span class="line-removed">324     Result run() final</span>
<span class="line-removed">325     {</span>
<span class="line-removed">326         CustomElementReactionQueue::processBackupQueue();</span>
<span class="line-removed">327         return Result::Done;</span>
<span class="line-removed">328     }</span>
<span class="line-removed">329 };</span>
<span class="line-removed">330 </span>
<span class="line-removed">331 static bool s_processingBackupElementQueue = false;</span>
<span class="line-removed">332 </span>
<span class="line-removed">333 CustomElementReactionQueue::ElementQueue&amp; CustomElementReactionQueue::ensureBackupQueue()</span>
<span class="line-removed">334 {</span>
<span class="line-removed">335     if (!s_processingBackupElementQueue) {</span>
<span class="line-removed">336         s_processingBackupElementQueue = true;</span>
<span class="line-removed">337         MicrotaskQueue::mainThreadQueue().append(makeUnique&lt;BackupElementQueueMicrotask&gt;());</span>
<span class="line-removed">338     }</span>
<span class="line-removed">339     return backupElementQueue();</span>
<span class="line-removed">340 }</span>
<span class="line-removed">341 </span>
<span class="line-removed">342 void CustomElementReactionQueue::processBackupQueue()</span>
<span class="line-removed">343 {</span>
<span class="line-removed">344     backupElementQueue().processQueue(nullptr);</span>
<span class="line-removed">345     s_processingBackupElementQueue = false;</span>
<span class="line-removed">346 }</span>
<span class="line-removed">347 </span>
<span class="line-removed">348 CustomElementReactionQueue::ElementQueue&amp; CustomElementReactionQueue::backupElementQueue()</span>
349 {
<span class="line-modified">350     static NeverDestroyed&lt;ElementQueue&gt; queue;</span>
<span class="line-removed">351     return queue.get();</span>
352 }
353 
354 }
</pre>
</td>
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;CustomElementReactionQueue.h&quot;
 28 
 29 #include &quot;CustomElementRegistry.h&quot;
 30 #include &quot;DOMWindow.h&quot;
 31 #include &quot;Document.h&quot;
 32 #include &quot;Element.h&quot;
<span class="line-added"> 33 #include &quot;EventLoop.h&quot;</span>
 34 #include &quot;HTMLNames.h&quot;
 35 #include &quot;JSCustomElementInterface.h&quot;
 36 #include &quot;JSDOMBinding.h&quot;
<span class="line-modified"> 37 #include &quot;WindowEventLoop.h&quot;</span>
 38 #include &lt;JavaScriptCore/CatchScope.h&gt;
 39 #include &lt;JavaScriptCore/Heap.h&gt;
 40 #include &lt;wtf/NeverDestroyed.h&gt;
 41 #include &lt;wtf/Optional.h&gt;
 42 #include &lt;wtf/Ref.h&gt;
 43 #include &lt;wtf/SetForScope.h&gt;
 44 
 45 namespace WebCore {
 46 
 47 class CustomElementReactionQueueItem {
 48 public:
 49     enum class Type {
 50         ElementUpgrade,
 51         Connected,
 52         Disconnected,
 53         Adopted,
 54         AttributeChanged,
 55     };
 56 
 57     CustomElementReactionQueueItem(Type type)
</pre>
<hr />
<pre>
222     }
223 
224     if (element.isConnected() &amp;&amp; queue.m_interface-&gt;hasConnectedCallback())
225         queue.m_items.append({CustomElementReactionQueueItem::Type::Connected});
226 }
227 
228 bool CustomElementReactionQueue::observesStyleAttribute() const
229 {
230     return m_interface-&gt;observesAttribute(HTMLNames::styleAttr-&gt;localName());
231 }
232 
233 void CustomElementReactionQueue::invokeAll(Element&amp; element)
234 {
235     while (!m_items.isEmpty()) {
236         Vector&lt;CustomElementReactionQueueItem&gt; items = WTFMove(m_items);
237         for (auto&amp; item : items)
238             item.invoke(element, m_interface.get());
239     }
240 }
241 
<span class="line-modified">242 inline void CustomElementQueue::add(Element&amp; element)</span>
243 {
244     ASSERT(!m_invoking);
245     // FIXME: Avoid inserting the same element multiple times.
246     m_elements.append(element);
247 }
248 
<span class="line-modified">249 inline void CustomElementQueue::invokeAll()</span>
250 {
251     RELEASE_ASSERT(!m_invoking);
252     SetForScope&lt;bool&gt; invoking(m_invoking, true);
253     unsigned originalSize = m_elements.size();
254     // It&#39;s possible for more elements to be enqueued if some IDL attributes were missing CEReactions.
255     // Invoke callbacks slightly later here instead of crashing / ignoring those cases.
256     for (unsigned i = 0; i &lt; m_elements.size(); ++i) {
257         auto&amp; element = m_elements[i].get();
258         auto* queue = element.reactionQueue();
259         ASSERT(queue);
260         queue-&gt;invokeAll(element);
261     }
262     ASSERT_UNUSED(originalSize, m_elements.size() == originalSize);
263     m_elements.clear();
264 }
265 
<span class="line-modified">266 inline void CustomElementQueue::processQueue(JSC::JSGlobalObject* state)</span>
267 {
268     if (!state) {
269         invokeAll();
270         return;
271     }
272 
273     auto&amp; vm = state-&gt;vm();
274     JSC::JSLockHolder lock(vm);
275 
276     JSC::Exception* previousException = nullptr;
277     {
278         auto catchScope = DECLARE_CATCH_SCOPE(vm);
279         previousException = catchScope.exception();
280         if (previousException)
281             catchScope.clearException();
282     }
283 
284     invokeAll();
285 
286     if (previousException) {
287         auto throwScope = DECLARE_THROW_SCOPE(vm);
288         throwException(state, throwScope, previousException);
289     }
290 }
291 
292 // https://html.spec.whatwg.org/multipage/custom-elements.html#enqueue-an-element-on-the-appropriate-element-queue
293 void CustomElementReactionQueue::enqueueElementOnAppropriateElementQueue(Element&amp; element)
294 {
295     ASSERT(element.reactionQueue());
296     if (!CustomElementReactionStack::s_currentProcessingStack) {
<span class="line-modified">297         element.document().windowEventLoop().backupElementQueue().add(element);</span>

298         return;
299     }
300 
301     auto*&amp; queue = CustomElementReactionStack::s_currentProcessingStack-&gt;m_queue;
302     if (!queue) // We use a raw pointer to avoid genearing code to delete it in ~CustomElementReactionStack.
<span class="line-modified">303         queue = new CustomElementQueue;</span>
304     queue-&gt;add(element);
305 }
306 
<span class="line-modified">307 #if ASSERT_ENABLED</span>
308 unsigned CustomElementReactionDisallowedScope::s_customElementReactionDisallowedCount = 0;
309 #endif
310 
311 CustomElementReactionStack* CustomElementReactionStack::s_currentProcessingStack = nullptr;
312 
<span class="line-modified">313 void CustomElementReactionStack::processQueue(JSC::JSGlobalObject* state)</span>
314 {
315     ASSERT(m_queue);
316     m_queue-&gt;processQueue(state);
317     delete m_queue;
318     m_queue = nullptr;
319 }
320 
<span class="line-modified">321 void CustomElementReactionQueue::processBackupQueue(CustomElementQueue&amp; backupElementQueue)</span>



























322 {
<span class="line-modified">323     backupElementQueue.processQueue(nullptr);</span>

324 }
325 
326 }
</pre>
</td>
</tr>
</table>
<center><a href="ContainerNodeAlgorithms.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CustomElementReactionQueue.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
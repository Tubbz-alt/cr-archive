<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FTLOSRExitCompiler.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLOperations.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOperations.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;FTLOperations.h&quot;
 28 
 29 #if ENABLE(FTL_JIT)
 30 
 31 #include &quot;BytecodeStructs.h&quot;
 32 #include &quot;ClonedArguments.h&quot;
 33 #include &quot;CommonSlowPaths.h&quot;
 34 #include &quot;DirectArguments.h&quot;
 35 #include &quot;FTLJITCode.h&quot;
 36 #include &quot;FTLLazySlowPath.h&quot;

 37 #include &quot;InlineCallFrame.h&quot;
 38 #include &quot;Interpreter.h&quot;

 39 #include &quot;JSAsyncFunction.h&quot;
 40 #include &quot;JSAsyncGeneratorFunction.h&quot;
 41 #include &quot;JSCInlines.h&quot;
<span class="line-removed"> 42 #include &quot;JSFixedArray.h&quot;</span>
 43 #include &quot;JSGeneratorFunction.h&quot;
 44 #include &quot;JSImmutableButterfly.h&quot;
 45 #include &quot;JSLexicalEnvironment.h&quot;
 46 #include &quot;RegExpObject.h&quot;
 47 


 48 namespace JSC { namespace FTL {
 49 
<span class="line-modified"> 50 extern &quot;C&quot; void JIT_OPERATION operationPopulateObjectInOSR(</span>
<span class="line-removed"> 51     ExecState* exec, ExitTimeObjectMaterialization* materialization,</span>
<span class="line-removed"> 52     EncodedJSValue* encodedValue, EncodedJSValue* values)</span>
 53 {
 54     using namespace DFG;
<span class="line-modified"> 55     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 56     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>



 57 
 58     // We cannot GC. We&#39;ve got pointers in evil places.
 59     // FIXME: We are not doing anything that can GC here, and this is
 60     // probably unnecessary.
 61     DeferGCForAWhile deferGC(vm.heap);
 62 
 63     switch (materialization-&gt;type()) {
 64     case PhantomNewObject: {
 65         JSFinalObject* object = jsCast&lt;JSFinalObject*&gt;(JSValue::decode(*encodedValue));
 66         Structure* structure = object-&gt;structure(vm);
 67 
 68         // Figure out what the heck to populate the object with. Use
 69         // getPropertiesConcurrently() because that happens to be
 70         // lower-level and more convenient. It doesn&#39;t change the
 71         // materialization of the property table. We want to have
 72         // minimal visible effects on the system. Also, don&#39;t mind
 73         // that this is O(n^2). It doesn&#39;t matter. We only get here
 74         // from OSR exit.
 75         for (PropertyMapEntry entry : structure-&gt;getPropertiesConcurrently()) {
 76             for (unsigned i = materialization-&gt;properties().size(); i--;) {
</pre>
<hr />
<pre>
 97     case PhantomNewArrayWithSpread:
 98     case PhantomNewArrayBuffer:
 99         // Those are completely handled by operationMaterializeObjectInOSR
100         break;
101 
102     case PhantomCreateActivation: {
103         JSLexicalEnvironment* activation = jsCast&lt;JSLexicalEnvironment*&gt;(JSValue::decode(*encodedValue));
104 
105         // Figure out what to populate the activation with
106         for (unsigned i = materialization-&gt;properties().size(); i--;) {
107             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
108             if (property.location().kind() != ClosureVarPLoc)
109                 continue;
110 
111             activation-&gt;variableAt(ScopeOffset(property.location().info())).set(vm, activation, JSValue::decode(values[i]));
112         }
113 
114         break;
115     }
116 













117     case PhantomNewRegexp: {
118         RegExpObject* regExpObject = jsCast&lt;RegExpObject*&gt;(JSValue::decode(*encodedValue));
119 
120         for (unsigned i = materialization-&gt;properties().size(); i--;) {
121             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
122             if (property.location().kind() != RegExpObjectLastIndexPLoc)
123                 continue;
124 
<span class="line-modified">125             regExpObject-&gt;setLastIndex(exec, JSValue::decode(values[i]), false /* shouldThrow */);</span>
126             break;
127         }
128         break;
129     }
130 
131     default:
132         RELEASE_ASSERT_NOT_REACHED();
133         break;
134 
135     }
136 }
137 
<span class="line-modified">138 extern &quot;C&quot; JSCell* JIT_OPERATION operationMaterializeObjectInOSR(</span>
<span class="line-removed">139     ExecState* exec, ExitTimeObjectMaterialization* materialization, EncodedJSValue* values)</span>
140 {
141     using namespace DFG;
<span class="line-modified">142     VM&amp; vm = exec-&gt;vm();</span>


143 
144     // We cannot GC. We&#39;ve got pointers in evil places.
145     DeferGCForAWhile deferGC(vm.heap);
146 
147     switch (materialization-&gt;type()) {
148     case PhantomNewObject: {
149         // Figure out what the structure is
150         Structure* structure = nullptr;
151         for (unsigned i = materialization-&gt;properties().size(); i--;) {
152             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
153             if (property.location() != PromotedLocationDescriptor(StructurePLoc))
154                 continue;
155 
156             RELEASE_ASSERT(JSValue::decode(values[i]).asCell()-&gt;inherits&lt;Structure&gt;(vm));
157             structure = jsCast&lt;Structure*&gt;(JSValue::decode(values[i]));
158             break;
159         }
160         RELEASE_ASSERT(structure);
161 
162         JSFinalObject* result = JSFinalObject::create(vm, structure);
</pre>
<hr />
<pre>
208     }
209 
210     case PhantomCreateActivation: {
211         // Figure out what the scope and symbol table are
212         JSScope* scope = nullptr;
213         SymbolTable* table = nullptr;
214         for (unsigned i = materialization-&gt;properties().size(); i--;) {
215             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
216             if (property.location() == PromotedLocationDescriptor(ActivationScopePLoc)) {
217                 RELEASE_ASSERT(JSValue::decode(values[i]).asCell()-&gt;inherits&lt;JSScope&gt;(vm));
218                 scope = jsCast&lt;JSScope*&gt;(JSValue::decode(values[i]));
219             } else if (property.location() == PromotedLocationDescriptor(ActivationSymbolTablePLoc)) {
220                 RELEASE_ASSERT(JSValue::decode(values[i]).asCell()-&gt;inherits&lt;SymbolTable&gt;(vm));
221                 table = jsCast&lt;SymbolTable*&gt;(JSValue::decode(values[i]));
222             }
223         }
224         RELEASE_ASSERT(scope);
225         RELEASE_ASSERT(table);
226 
227         CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(
<span class="line-modified">228             materialization-&gt;origin(), exec-&gt;codeBlock()-&gt;baselineAlternative());</span>
229         Structure* structure = codeBlock-&gt;globalObject()-&gt;activationStructure();
230 
231         // It doesn&#39;t matter what values we initialize as bottom values inside the activation constructor because
232         // activation sinking will set bottom values for each slot.
233         // FIXME: Slight optimization would be to create a constructor that doesn&#39;t initialize all slots.
234         JSLexicalEnvironment* result = JSLexicalEnvironment::create(vm, structure, scope, table, jsUndefined());
235 
236         RELEASE_ASSERT(materialization-&gt;properties().size() - 2 == table-&gt;scopeSize());
237 
238         // The real values will be put subsequently by
239         // operationPopulateNewObjectInOSR. See the PhantomNewObject
240         // case for details.
241         for (unsigned i = materialization-&gt;properties().size(); i--;) {
242             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
243             if (property.location().kind() != ClosureVarPLoc)
244                 continue;
245 
246             result-&gt;variableAt(ScopeOffset(property.location().info())).set(
247                 vm, result, jsNumber(29834));
248         }
</pre>
<hr />
<pre>
258                         continue;
259                     if (ScopeOffset(property.location().info()) == iter-&gt;value.scopeOffset()) {
260                         found = true;
261                         break;
262                     }
263                 }
264                 ASSERT_UNUSED(found, found);
265             }
266             unsigned numberOfClosureVarPloc = 0;
267             for (unsigned i = materialization-&gt;properties().size(); i--;) {
268                 const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
269                 if (property.location().kind() == ClosureVarPLoc)
270                     numberOfClosureVarPloc++;
271             }
272             ASSERT(numberOfClosureVarPloc == table-&gt;scopeSize());
273         }
274 
275         return result;
276     }
277 






















278     case PhantomCreateRest:
279     case PhantomDirectArguments:
280     case PhantomClonedArguments: {
281         if (!materialization-&gt;origin().inlineCallFrame()) {
282             switch (materialization-&gt;type()) {
283             case PhantomDirectArguments:
<span class="line-modified">284                 return DirectArguments::createByCopying(exec);</span>
285             case PhantomClonedArguments:
<span class="line-modified">286                 return ClonedArguments::createWithMachineFrame(exec, exec, ArgumentsMode::Cloned);</span>
287             case PhantomCreateRest: {
288                 CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(
<span class="line-modified">289                     materialization-&gt;origin(), exec-&gt;codeBlock()-&gt;baselineAlternative());</span>
290 
291                 unsigned numberOfArgumentsToSkip = codeBlock-&gt;numberOfArgumentsToSkip();
292                 JSGlobalObject* globalObject = codeBlock-&gt;globalObject();
293                 Structure* structure = globalObject-&gt;restParameterStructure();
<span class="line-modified">294                 JSValue* argumentsToCopyRegion = exec-&gt;addressOfArgumentsStart() + numberOfArgumentsToSkip;</span>
<span class="line-modified">295                 unsigned arraySize = exec-&gt;argumentCount() &gt; numberOfArgumentsToSkip ? exec-&gt;argumentCount() - numberOfArgumentsToSkip : 0;</span>
<span class="line-modified">296                 return constructArray(exec, structure, argumentsToCopyRegion, arraySize);</span>
297             }
298             default:
299                 RELEASE_ASSERT_NOT_REACHED();
300                 return nullptr;
301             }
302         }
303 
304         // First figure out the argument count. If there isn&#39;t one then we represent the machine frame.
305         unsigned argumentCount = 0;
306         if (materialization-&gt;origin().inlineCallFrame()-&gt;isVarargs()) {
307             for (unsigned i = materialization-&gt;properties().size(); i--;) {
308                 const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
309                 if (property.location() != PromotedLocationDescriptor(ArgumentCountPLoc))
310                     continue;
311                 argumentCount = JSValue::decode(values[i]).asUInt32();
312                 break;
313             }
314         } else
315             argumentCount = materialization-&gt;origin().inlineCallFrame()-&gt;argumentCountIncludingThis;
316         RELEASE_ASSERT(argumentCount);
317 
318         JSFunction* callee = nullptr;
319         if (materialization-&gt;origin().inlineCallFrame()-&gt;isClosureCall) {
320             for (unsigned i = materialization-&gt;properties().size(); i--;) {
321                 const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
322                 if (property.location() != PromotedLocationDescriptor(ArgumentsCalleePLoc))
323                     continue;
324 
325                 callee = jsCast&lt;JSFunction*&gt;(JSValue::decode(values[i]));
326                 break;
327             }
328         } else
329             callee = materialization-&gt;origin().inlineCallFrame()-&gt;calleeConstant();
330         RELEASE_ASSERT(callee);
331 
332         CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(
<span class="line-modified">333             materialization-&gt;origin(), exec-&gt;codeBlock()-&gt;baselineAlternative());</span>
334 
335         // We have an inline frame and we have all of the data we need to recreate it.
336         switch (materialization-&gt;type()) {
337         case PhantomDirectArguments: {
338             unsigned length = argumentCount - 1;
339             unsigned capacity = std::max(length, static_cast&lt;unsigned&gt;(codeBlock-&gt;numParameters() - 1));
340             DirectArguments* result = DirectArguments::create(
341                 vm, codeBlock-&gt;globalObject()-&gt;directArgumentsStructure(), length, capacity);
342             result-&gt;setCallee(vm, callee);
343             for (unsigned i = materialization-&gt;properties().size(); i--;) {
344                 const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
345                 if (property.location().kind() != ArgumentPLoc)
346                     continue;
347 
348                 unsigned index = property.location().info();
349                 if (index &gt;= capacity)
350                     continue;
351 
352                 // We don&#39;t want to use setIndexQuickly(), since that&#39;s only for the passed-in
353                 // arguments but sometimes the number of named arguments is greater. For
</pre>
<hr />
<pre>
359                 // setIndexQuickly() would fail for indices 0, 1, 2 - but we need to recover
360                 // those here.
361                 result-&gt;argument(DirectArgumentsOffset(index)).set(
362                     vm, result, JSValue::decode(values[i]));
363             }
364             return result;
365         }
366         case PhantomClonedArguments: {
367             unsigned length = argumentCount - 1;
368             ClonedArguments* result = ClonedArguments::createEmpty(
369                 vm, codeBlock-&gt;globalObject()-&gt;clonedArgumentsStructure(), callee, length);
370 
371             for (unsigned i = materialization-&gt;properties().size(); i--;) {
372                 const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
373                 if (property.location().kind() != ArgumentPLoc)
374                     continue;
375 
376                 unsigned index = property.location().info();
377                 if (index &gt;= length)
378                     continue;
<span class="line-modified">379                 result-&gt;putDirectIndex(exec, index, JSValue::decode(values[i]));</span>
380             }
381 
382             return result;
383         }
384         case PhantomCreateRest: {
385             unsigned numberOfArgumentsToSkip = codeBlock-&gt;numberOfArgumentsToSkip();
386             JSGlobalObject* globalObject = codeBlock-&gt;globalObject();
387             Structure* structure = globalObject-&gt;restParameterStructure();
388             ASSERT(argumentCount &gt; 0);
389             unsigned arraySize = (argumentCount - 1) &gt; numberOfArgumentsToSkip ? argumentCount - 1 - numberOfArgumentsToSkip : 0;
390 
391             // FIXME: we should throw an out of memory error here if tryCreate() fails.
392             // https://bugs.webkit.org/show_bug.cgi?id=169784
393             JSArray* array = JSArray::tryCreate(vm, structure, arraySize);
394             RELEASE_ASSERT(array);
395 
396             for (unsigned i = materialization-&gt;properties().size(); i--;) {
397                 const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
398                 if (property.location().kind() != ArgumentPLoc)
399                     continue;
400 
401                 unsigned argIndex = property.location().info();
402                 if (numberOfArgumentsToSkip &gt; argIndex)
403                     continue;
404                 unsigned arrayIndex = argIndex - numberOfArgumentsToSkip;
405                 if (arrayIndex &gt;= arraySize)
406                     continue;
<span class="line-modified">407                 array-&gt;putDirectIndex(exec, arrayIndex, JSValue::decode(values[i]));</span>
408             }
409 
<span class="line-modified">410 #if !ASSERT_DISABLED</span>
411             // We avoid this O(n^2) loop when asserts are disabled, but the condition checked here
412             // must hold to ensure the correctness of the above loop because of how we allocate the array.
413             for (unsigned targetIndex = 0; targetIndex &lt; arraySize; ++targetIndex) {
414                 bool found = false;
415                 for (unsigned i = materialization-&gt;properties().size(); i--;) {
416                     const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
417                     if (property.location().kind() != ArgumentPLoc)
418                         continue;
419 
420                     unsigned argIndex = property.location().info();
421                     if (numberOfArgumentsToSkip &gt; argIndex)
422                         continue;
423                     unsigned arrayIndex = argIndex - numberOfArgumentsToSkip;
424                     if (arrayIndex &gt;= arraySize)
425                         continue;
426                     if (arrayIndex == targetIndex) {
427                         found = true;
428                         break;
429                     }
430                 }
431                 ASSERT(found);
432             }
<span class="line-modified">433 #endif</span>
434             return array;
435         }
436 
437         default:
438             RELEASE_ASSERT_NOT_REACHED();
439             return nullptr;
440         }
441     }
442 
443     case PhantomSpread: {
444         JSArray* array = nullptr;
445         for (unsigned i = materialization-&gt;properties().size(); i--;) {
446             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
447             if (property.location().kind() == SpreadPLoc) {
448                 array = jsCast&lt;JSArray*&gt;(JSValue::decode(values[i]));
449                 break;
450             }
451         }
452         RELEASE_ASSERT(array);
453 
<span class="line-modified">454         // Note: it is sound for JSFixedArray::createFromArray to call getDirectIndex here</span>
455         // because we&#39;re guaranteed we won&#39;t be calling any getters. The reason for this is
456         // that we only support PhantomSpread over CreateRest, which is an array we create.
457         // Any attempts to put a getter on any indices on the rest array will escape the array.
<span class="line-modified">458         JSFixedArray* fixedArray = JSFixedArray::createFromArray(exec, vm, array);</span>
459         RELEASE_ASSERT(fixedArray);
460         return fixedArray;
461     }
462 
463     case PhantomNewArrayBuffer: {
464         JSImmutableButterfly* immutableButterfly = nullptr;
465         for (unsigned i = materialization-&gt;properties().size(); i--;) {
466             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
467             if (property.location().kind() == NewArrayBufferPLoc) {
468                 immutableButterfly = jsCast&lt;JSImmutableButterfly*&gt;(JSValue::decode(values[i]));
469                 break;
470             }
471         }
472         RELEASE_ASSERT(immutableButterfly);
473 
474         // For now, we use array allocation profile in the actual CodeBlock. It is OK since current NewArrayBuffer
475         // and PhantomNewArrayBuffer are always bound to a specific op_new_array_buffer.
<span class="line-modified">476         CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(materialization-&gt;origin(), exec-&gt;codeBlock()-&gt;baselineAlternative());</span>
477         const Instruction* currentInstruction = codeBlock-&gt;instructions().at(materialization-&gt;origin().bytecodeIndex()).ptr();
478         if (!currentInstruction-&gt;is&lt;OpNewArrayBuffer&gt;()) {
479             // This case can happen if Object.keys, an OpCall is first converted into a NewArrayBuffer which is then converted into a PhantomNewArrayBuffer.
480             // There is no need to update the array allocation profile in that case.
481             RELEASE_ASSERT(currentInstruction-&gt;is&lt;OpCall&gt;());
<span class="line-modified">482             Structure* structure = exec-&gt;lexicalGlobalObject()-&gt;arrayStructureForIndexingTypeDuringAllocation(immutableButterfly-&gt;indexingMode());</span>
483             return CommonSlowPaths::allocateNewArrayBuffer(vm, structure, immutableButterfly);
484         }
485         auto newArrayBuffer = currentInstruction-&gt;as&lt;OpNewArrayBuffer&gt;();
486         ArrayAllocationProfile* profile = &amp;newArrayBuffer.metadata(codeBlock).m_arrayAllocationProfile;
487 
488         // FIXME: Share the code with CommonSlowPaths. Currently, codeBlock etc. are slightly different.
489         IndexingType indexingMode = profile-&gt;selectIndexingType();
<span class="line-modified">490         Structure* structure = exec-&gt;lexicalGlobalObject()-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingMode);</span>
491         ASSERT(isCopyOnWrite(indexingMode));
492         ASSERT(!structure-&gt;outOfLineCapacity());
493 
494         if (UNLIKELY(immutableButterfly-&gt;indexingMode() != indexingMode)) {
495             auto* newButterfly = JSImmutableButterfly::create(vm, indexingMode, immutableButterfly-&gt;length());
496             for (unsigned i = 0; i &lt; immutableButterfly-&gt;length(); ++i)
497                 newButterfly-&gt;setIndex(vm, i, immutableButterfly-&gt;get(i));
498             immutableButterfly = newButterfly;
499 
500             // FIXME: This is kinda gross and only works because we can&#39;t inline new_array_bufffer in the baseline.
501             // We also cannot allocate a new butterfly from compilation threads since it&#39;s invalid to allocate cells from
502             // a compilation thread.
503             WTF::storeStoreFence();
<span class="line-modified">504             codeBlock-&gt;constantRegister(newArrayBuffer.m_immutableButterfly.offset()).set(vm, codeBlock, immutableButterfly);</span>
505             WTF::storeStoreFence();
506         }
507 
508         JSArray* result = CommonSlowPaths::allocateNewArrayBuffer(vm, structure, immutableButterfly);
509         ArrayAllocationProfile::updateLastAllocationFor(profile, result);
510         return result;
511     }
512 
513     case PhantomNewArrayWithSpread: {
514         CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(
<span class="line-modified">515             materialization-&gt;origin(), exec-&gt;codeBlock()-&gt;baselineAlternative());</span>
516         JSGlobalObject* globalObject = codeBlock-&gt;globalObject();
517         Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous);
518 
519         Checked&lt;unsigned, RecordOverflow&gt; checkedArraySize = 0;
520         unsigned numProperties = 0;
521         for (unsigned i = materialization-&gt;properties().size(); i--;) {
522             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
523             if (property.location().kind() == NewArrayWithSpreadArgumentPLoc) {
524                 ++numProperties;
525                 JSValue value = JSValue::decode(values[i]);
<span class="line-modified">526                 if (JSFixedArray* fixedArray = jsDynamicCast&lt;JSFixedArray*&gt;(vm, value))</span>
<span class="line-modified">527                     checkedArraySize += fixedArray-&gt;size();</span>
528                 else
529                     checkedArraySize += 1;
530             }
531         }
532 
533         // FIXME: we should throw an out of memory error here if checkedArraySize has hasOverflowed() or tryCreate() fails.
534         // https://bugs.webkit.org/show_bug.cgi?id=169784
535         unsigned arraySize = checkedArraySize.unsafeGet(); // Crashes if overflowed.
536         JSArray* result = JSArray::tryCreate(vm, structure, arraySize);
537         RELEASE_ASSERT(result);
538 
<span class="line-modified">539 #if !ASSERT_DISABLED</span>
540         // Ensure we see indices for everything in the range: [0, numProperties)
541         for (unsigned i = 0; i &lt; numProperties; ++i) {
542             bool found = false;
543             for (unsigned j = 0; j &lt; materialization-&gt;properties().size(); ++j) {
544                 const ExitPropertyValue&amp; property = materialization-&gt;properties()[j];
545                 if (property.location().kind() == NewArrayWithSpreadArgumentPLoc &amp;&amp; property.location().info() == i) {
546                     found = true;
547                     break;
548                 }
549             }
550             ASSERT(found);
551         }
<span class="line-modified">552 #endif</span>
553 
554         Vector&lt;JSValue, 8&gt; arguments;
555         arguments.grow(numProperties);
556 
557         for (unsigned i = materialization-&gt;properties().size(); i--;) {
558             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
559             if (property.location().kind() == NewArrayWithSpreadArgumentPLoc) {
560                 JSValue value = JSValue::decode(values[i]);
561                 RELEASE_ASSERT(property.location().info() &lt; numProperties);
562                 arguments[property.location().info()] = value;
563             }
564         }
565 
566         unsigned arrayIndex = 0;
567         for (JSValue value : arguments) {
<span class="line-modified">568             if (JSFixedArray* fixedArray = jsDynamicCast&lt;JSFixedArray*&gt;(vm, value)) {</span>
<span class="line-modified">569                 for (unsigned i = 0; i &lt; fixedArray-&gt;size(); i++) {</span>
<span class="line-modified">570                     ASSERT(fixedArray-&gt;get(i));</span>
<span class="line-modified">571                     result-&gt;putDirectIndex(exec, arrayIndex, fixedArray-&gt;get(i));</span>
572                     ++arrayIndex;
573                 }
574             } else {
575                 // We are not spreading.
<span class="line-modified">576                 result-&gt;putDirectIndex(exec, arrayIndex, value);</span>
577                 ++arrayIndex;
578             }
579         }
580 
581         return result;
582     }
583 
584     case PhantomNewRegexp: {
585         RegExp* regExp = nullptr;
586         for (unsigned i = materialization-&gt;properties().size(); i--;) {
587             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
588             if (property.location() == PromotedLocationDescriptor(RegExpObjectRegExpPLoc)) {
589                 RELEASE_ASSERT(JSValue::decode(values[i]).asCell()-&gt;inherits&lt;RegExp&gt;(vm));
590                 regExp = jsCast&lt;RegExp*&gt;(JSValue::decode(values[i]));
591             }
592         }
593         RELEASE_ASSERT(regExp);
<span class="line-modified">594         CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(materialization-&gt;origin(), exec-&gt;codeBlock()-&gt;baselineAlternative());</span>
595         Structure* structure = codeBlock-&gt;globalObject()-&gt;regExpStructure();
596         return RegExpObject::create(vm, structure, regExp);
597     }
598 
599     default:
600         RELEASE_ASSERT_NOT_REACHED();
601         return nullptr;
602     }
603 }
604 
<span class="line-modified">605 extern &quot;C&quot; void* JIT_OPERATION compileFTLLazySlowPath(ExecState* exec, unsigned index)</span>
606 {
<span class="line-modified">607     VM&amp; vm = exec-&gt;vm();</span>
608 
609     // We cannot GC. We&#39;ve got pointers in evil places.
610     DeferGCForAWhile deferGC(vm.heap);
611 
<span class="line-modified">612     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
613     JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;ftl();
614 
615     LazySlowPath&amp; lazySlowPath = *jitCode-&gt;lazySlowPaths[index];
616     lazySlowPath.generate(codeBlock);
617 
618     return lazySlowPath.stub().code().executableAddress();
619 }
620 
621 } } // namespace JSC::FTL
622 


623 #endif // ENABLE(FTL_JIT)
624 
</pre>
</td>
<td>
<hr />
<pre>
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;FTLOperations.h&quot;
 28 
 29 #if ENABLE(FTL_JIT)
 30 
 31 #include &quot;BytecodeStructs.h&quot;
 32 #include &quot;ClonedArguments.h&quot;
 33 #include &quot;CommonSlowPaths.h&quot;
 34 #include &quot;DirectArguments.h&quot;
 35 #include &quot;FTLJITCode.h&quot;
 36 #include &quot;FTLLazySlowPath.h&quot;
<span class="line-added"> 37 #include &quot;FrameTracers.h&quot;</span>
 38 #include &quot;InlineCallFrame.h&quot;
 39 #include &quot;Interpreter.h&quot;
<span class="line-added"> 40 #include &quot;JSArrayIterator.h&quot;</span>
 41 #include &quot;JSAsyncFunction.h&quot;
 42 #include &quot;JSAsyncGeneratorFunction.h&quot;
 43 #include &quot;JSCInlines.h&quot;

 44 #include &quot;JSGeneratorFunction.h&quot;
 45 #include &quot;JSImmutableButterfly.h&quot;
 46 #include &quot;JSLexicalEnvironment.h&quot;
 47 #include &quot;RegExpObject.h&quot;
 48 
<span class="line-added"> 49 IGNORE_WARNINGS_BEGIN(&quot;frame-address&quot;)</span>
<span class="line-added"> 50 </span>
 51 namespace JSC { namespace FTL {
 52 
<span class="line-modified"> 53 extern &quot;C&quot; void JIT_OPERATION operationPopulateObjectInOSR(JSGlobalObject* globalObject, ExitTimeObjectMaterialization* materialization, EncodedJSValue* encodedValue, EncodedJSValue* values)</span>


 54 {
 55     using namespace DFG;
<span class="line-modified"> 56     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 57     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 58     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added"> 59 </span>
<span class="line-added"> 60     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
 61 
 62     // We cannot GC. We&#39;ve got pointers in evil places.
 63     // FIXME: We are not doing anything that can GC here, and this is
 64     // probably unnecessary.
 65     DeferGCForAWhile deferGC(vm.heap);
 66 
 67     switch (materialization-&gt;type()) {
 68     case PhantomNewObject: {
 69         JSFinalObject* object = jsCast&lt;JSFinalObject*&gt;(JSValue::decode(*encodedValue));
 70         Structure* structure = object-&gt;structure(vm);
 71 
 72         // Figure out what the heck to populate the object with. Use
 73         // getPropertiesConcurrently() because that happens to be
 74         // lower-level and more convenient. It doesn&#39;t change the
 75         // materialization of the property table. We want to have
 76         // minimal visible effects on the system. Also, don&#39;t mind
 77         // that this is O(n^2). It doesn&#39;t matter. We only get here
 78         // from OSR exit.
 79         for (PropertyMapEntry entry : structure-&gt;getPropertiesConcurrently()) {
 80             for (unsigned i = materialization-&gt;properties().size(); i--;) {
</pre>
<hr />
<pre>
101     case PhantomNewArrayWithSpread:
102     case PhantomNewArrayBuffer:
103         // Those are completely handled by operationMaterializeObjectInOSR
104         break;
105 
106     case PhantomCreateActivation: {
107         JSLexicalEnvironment* activation = jsCast&lt;JSLexicalEnvironment*&gt;(JSValue::decode(*encodedValue));
108 
109         // Figure out what to populate the activation with
110         for (unsigned i = materialization-&gt;properties().size(); i--;) {
111             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
112             if (property.location().kind() != ClosureVarPLoc)
113                 continue;
114 
115             activation-&gt;variableAt(ScopeOffset(property.location().info())).set(vm, activation, JSValue::decode(values[i]));
116         }
117 
118         break;
119     }
120 
<span class="line-added">121     case PhantomNewArrayIterator: {</span>
<span class="line-added">122         JSArrayIterator* arrayIterator = jsCast&lt;JSArrayIterator*&gt;(JSValue::decode(*encodedValue));</span>
<span class="line-added">123 </span>
<span class="line-added">124         // Figure out what to populate the iterator with</span>
<span class="line-added">125         for (unsigned i = materialization-&gt;properties().size(); i--;) {</span>
<span class="line-added">126             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];</span>
<span class="line-added">127             if (property.location().kind() != InternalFieldObjectPLoc)</span>
<span class="line-added">128                 continue;</span>
<span class="line-added">129             arrayIterator-&gt;internalField(static_cast&lt;JSArrayIterator::Field&gt;(property.location().info())).set(vm, arrayIterator, JSValue::decode(values[i]));</span>
<span class="line-added">130         }</span>
<span class="line-added">131         break;</span>
<span class="line-added">132     }</span>
<span class="line-added">133 </span>
134     case PhantomNewRegexp: {
135         RegExpObject* regExpObject = jsCast&lt;RegExpObject*&gt;(JSValue::decode(*encodedValue));
136 
137         for (unsigned i = materialization-&gt;properties().size(); i--;) {
138             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
139             if (property.location().kind() != RegExpObjectLastIndexPLoc)
140                 continue;
141 
<span class="line-modified">142             regExpObject-&gt;setLastIndex(globalObject, JSValue::decode(values[i]), false /* shouldThrow */);</span>
143             break;
144         }
145         break;
146     }
147 
148     default:
149         RELEASE_ASSERT_NOT_REACHED();
150         break;
151 
152     }
153 }
154 
<span class="line-modified">155 extern &quot;C&quot; JSCell* JIT_OPERATION operationMaterializeObjectInOSR(JSGlobalObject* globalObject, ExitTimeObjectMaterialization* materialization, EncodedJSValue* values)</span>

156 {
157     using namespace DFG;
<span class="line-modified">158     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">159     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">160     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
161 
162     // We cannot GC. We&#39;ve got pointers in evil places.
163     DeferGCForAWhile deferGC(vm.heap);
164 
165     switch (materialization-&gt;type()) {
166     case PhantomNewObject: {
167         // Figure out what the structure is
168         Structure* structure = nullptr;
169         for (unsigned i = materialization-&gt;properties().size(); i--;) {
170             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
171             if (property.location() != PromotedLocationDescriptor(StructurePLoc))
172                 continue;
173 
174             RELEASE_ASSERT(JSValue::decode(values[i]).asCell()-&gt;inherits&lt;Structure&gt;(vm));
175             structure = jsCast&lt;Structure*&gt;(JSValue::decode(values[i]));
176             break;
177         }
178         RELEASE_ASSERT(structure);
179 
180         JSFinalObject* result = JSFinalObject::create(vm, structure);
</pre>
<hr />
<pre>
226     }
227 
228     case PhantomCreateActivation: {
229         // Figure out what the scope and symbol table are
230         JSScope* scope = nullptr;
231         SymbolTable* table = nullptr;
232         for (unsigned i = materialization-&gt;properties().size(); i--;) {
233             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
234             if (property.location() == PromotedLocationDescriptor(ActivationScopePLoc)) {
235                 RELEASE_ASSERT(JSValue::decode(values[i]).asCell()-&gt;inherits&lt;JSScope&gt;(vm));
236                 scope = jsCast&lt;JSScope*&gt;(JSValue::decode(values[i]));
237             } else if (property.location() == PromotedLocationDescriptor(ActivationSymbolTablePLoc)) {
238                 RELEASE_ASSERT(JSValue::decode(values[i]).asCell()-&gt;inherits&lt;SymbolTable&gt;(vm));
239                 table = jsCast&lt;SymbolTable*&gt;(JSValue::decode(values[i]));
240             }
241         }
242         RELEASE_ASSERT(scope);
243         RELEASE_ASSERT(table);
244 
245         CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(
<span class="line-modified">246             materialization-&gt;origin(), callFrame-&gt;codeBlock()-&gt;baselineAlternative());</span>
247         Structure* structure = codeBlock-&gt;globalObject()-&gt;activationStructure();
248 
249         // It doesn&#39;t matter what values we initialize as bottom values inside the activation constructor because
250         // activation sinking will set bottom values for each slot.
251         // FIXME: Slight optimization would be to create a constructor that doesn&#39;t initialize all slots.
252         JSLexicalEnvironment* result = JSLexicalEnvironment::create(vm, structure, scope, table, jsUndefined());
253 
254         RELEASE_ASSERT(materialization-&gt;properties().size() - 2 == table-&gt;scopeSize());
255 
256         // The real values will be put subsequently by
257         // operationPopulateNewObjectInOSR. See the PhantomNewObject
258         // case for details.
259         for (unsigned i = materialization-&gt;properties().size(); i--;) {
260             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
261             if (property.location().kind() != ClosureVarPLoc)
262                 continue;
263 
264             result-&gt;variableAt(ScopeOffset(property.location().info())).set(
265                 vm, result, jsNumber(29834));
266         }
</pre>
<hr />
<pre>
276                         continue;
277                     if (ScopeOffset(property.location().info()) == iter-&gt;value.scopeOffset()) {
278                         found = true;
279                         break;
280                     }
281                 }
282                 ASSERT_UNUSED(found, found);
283             }
284             unsigned numberOfClosureVarPloc = 0;
285             for (unsigned i = materialization-&gt;properties().size(); i--;) {
286                 const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
287                 if (property.location().kind() == ClosureVarPLoc)
288                     numberOfClosureVarPloc++;
289             }
290             ASSERT(numberOfClosureVarPloc == table-&gt;scopeSize());
291         }
292 
293         return result;
294     }
295 
<span class="line-added">296     case PhantomNewArrayIterator: {</span>
<span class="line-added">297         // Figure out what structure.</span>
<span class="line-added">298         Structure* structure = nullptr;</span>
<span class="line-added">299         for (unsigned i = materialization-&gt;properties().size(); i--;) {</span>
<span class="line-added">300             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];</span>
<span class="line-added">301             if (property.location() == PromotedLocationDescriptor(StructurePLoc)) {</span>
<span class="line-added">302                 RELEASE_ASSERT(JSValue::decode(values[i]).asCell()-&gt;inherits&lt;Structure&gt;(vm));</span>
<span class="line-added">303                 structure = jsCast&lt;Structure*&gt;(JSValue::decode(values[i]));</span>
<span class="line-added">304             }</span>
<span class="line-added">305         }</span>
<span class="line-added">306         RELEASE_ASSERT(structure);</span>
<span class="line-added">307 </span>
<span class="line-added">308         JSArrayIterator* result = JSArrayIterator::createWithInitialValues(vm, structure);</span>
<span class="line-added">309 </span>
<span class="line-added">310         RELEASE_ASSERT(materialization-&gt;properties().size() - 1 == JSArrayIterator::numberOfInternalFields);</span>
<span class="line-added">311 </span>
<span class="line-added">312         // The real values will be put subsequently by</span>
<span class="line-added">313         // operationPopulateNewObjectInOSR. See the PhantomNewObject</span>
<span class="line-added">314         // case for details.</span>
<span class="line-added">315         return result;</span>
<span class="line-added">316     }</span>
<span class="line-added">317 </span>
318     case PhantomCreateRest:
319     case PhantomDirectArguments:
320     case PhantomClonedArguments: {
321         if (!materialization-&gt;origin().inlineCallFrame()) {
322             switch (materialization-&gt;type()) {
323             case PhantomDirectArguments:
<span class="line-modified">324                 return DirectArguments::createByCopying(globalObject, callFrame);</span>
325             case PhantomClonedArguments:
<span class="line-modified">326                 return ClonedArguments::createWithMachineFrame(globalObject, callFrame, ArgumentsMode::Cloned);</span>
327             case PhantomCreateRest: {
328                 CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(
<span class="line-modified">329                     materialization-&gt;origin(), callFrame-&gt;codeBlock()-&gt;baselineAlternative());</span>
330 
331                 unsigned numberOfArgumentsToSkip = codeBlock-&gt;numberOfArgumentsToSkip();
332                 JSGlobalObject* globalObject = codeBlock-&gt;globalObject();
333                 Structure* structure = globalObject-&gt;restParameterStructure();
<span class="line-modified">334                 JSValue* argumentsToCopyRegion = callFrame-&gt;addressOfArgumentsStart() + numberOfArgumentsToSkip;</span>
<span class="line-modified">335                 unsigned arraySize = callFrame-&gt;argumentCount() &gt; numberOfArgumentsToSkip ? callFrame-&gt;argumentCount() - numberOfArgumentsToSkip : 0;</span>
<span class="line-modified">336                 return constructArray(globalObject, structure, argumentsToCopyRegion, arraySize);</span>
337             }
338             default:
339                 RELEASE_ASSERT_NOT_REACHED();
340                 return nullptr;
341             }
342         }
343 
344         // First figure out the argument count. If there isn&#39;t one then we represent the machine frame.
345         unsigned argumentCount = 0;
346         if (materialization-&gt;origin().inlineCallFrame()-&gt;isVarargs()) {
347             for (unsigned i = materialization-&gt;properties().size(); i--;) {
348                 const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
349                 if (property.location() != PromotedLocationDescriptor(ArgumentCountPLoc))
350                     continue;
351                 argumentCount = JSValue::decode(values[i]).asUInt32();
352                 break;
353             }
354         } else
355             argumentCount = materialization-&gt;origin().inlineCallFrame()-&gt;argumentCountIncludingThis;
356         RELEASE_ASSERT(argumentCount);
357 
358         JSFunction* callee = nullptr;
359         if (materialization-&gt;origin().inlineCallFrame()-&gt;isClosureCall) {
360             for (unsigned i = materialization-&gt;properties().size(); i--;) {
361                 const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
362                 if (property.location() != PromotedLocationDescriptor(ArgumentsCalleePLoc))
363                     continue;
364 
365                 callee = jsCast&lt;JSFunction*&gt;(JSValue::decode(values[i]));
366                 break;
367             }
368         } else
369             callee = materialization-&gt;origin().inlineCallFrame()-&gt;calleeConstant();
370         RELEASE_ASSERT(callee);
371 
372         CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(
<span class="line-modified">373             materialization-&gt;origin(), callFrame-&gt;codeBlock()-&gt;baselineAlternative());</span>
374 
375         // We have an inline frame and we have all of the data we need to recreate it.
376         switch (materialization-&gt;type()) {
377         case PhantomDirectArguments: {
378             unsigned length = argumentCount - 1;
379             unsigned capacity = std::max(length, static_cast&lt;unsigned&gt;(codeBlock-&gt;numParameters() - 1));
380             DirectArguments* result = DirectArguments::create(
381                 vm, codeBlock-&gt;globalObject()-&gt;directArgumentsStructure(), length, capacity);
382             result-&gt;setCallee(vm, callee);
383             for (unsigned i = materialization-&gt;properties().size(); i--;) {
384                 const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
385                 if (property.location().kind() != ArgumentPLoc)
386                     continue;
387 
388                 unsigned index = property.location().info();
389                 if (index &gt;= capacity)
390                     continue;
391 
392                 // We don&#39;t want to use setIndexQuickly(), since that&#39;s only for the passed-in
393                 // arguments but sometimes the number of named arguments is greater. For
</pre>
<hr />
<pre>
399                 // setIndexQuickly() would fail for indices 0, 1, 2 - but we need to recover
400                 // those here.
401                 result-&gt;argument(DirectArgumentsOffset(index)).set(
402                     vm, result, JSValue::decode(values[i]));
403             }
404             return result;
405         }
406         case PhantomClonedArguments: {
407             unsigned length = argumentCount - 1;
408             ClonedArguments* result = ClonedArguments::createEmpty(
409                 vm, codeBlock-&gt;globalObject()-&gt;clonedArgumentsStructure(), callee, length);
410 
411             for (unsigned i = materialization-&gt;properties().size(); i--;) {
412                 const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
413                 if (property.location().kind() != ArgumentPLoc)
414                     continue;
415 
416                 unsigned index = property.location().info();
417                 if (index &gt;= length)
418                     continue;
<span class="line-modified">419                 result-&gt;putDirectIndex(globalObject, index, JSValue::decode(values[i]));</span>
420             }
421 
422             return result;
423         }
424         case PhantomCreateRest: {
425             unsigned numberOfArgumentsToSkip = codeBlock-&gt;numberOfArgumentsToSkip();
426             JSGlobalObject* globalObject = codeBlock-&gt;globalObject();
427             Structure* structure = globalObject-&gt;restParameterStructure();
428             ASSERT(argumentCount &gt; 0);
429             unsigned arraySize = (argumentCount - 1) &gt; numberOfArgumentsToSkip ? argumentCount - 1 - numberOfArgumentsToSkip : 0;
430 
431             // FIXME: we should throw an out of memory error here if tryCreate() fails.
432             // https://bugs.webkit.org/show_bug.cgi?id=169784
433             JSArray* array = JSArray::tryCreate(vm, structure, arraySize);
434             RELEASE_ASSERT(array);
435 
436             for (unsigned i = materialization-&gt;properties().size(); i--;) {
437                 const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
438                 if (property.location().kind() != ArgumentPLoc)
439                     continue;
440 
441                 unsigned argIndex = property.location().info();
442                 if (numberOfArgumentsToSkip &gt; argIndex)
443                     continue;
444                 unsigned arrayIndex = argIndex - numberOfArgumentsToSkip;
445                 if (arrayIndex &gt;= arraySize)
446                     continue;
<span class="line-modified">447                 array-&gt;putDirectIndex(globalObject, arrayIndex, JSValue::decode(values[i]));</span>
448             }
449 
<span class="line-modified">450 #if ASSERT_ENABLED</span>
451             // We avoid this O(n^2) loop when asserts are disabled, but the condition checked here
452             // must hold to ensure the correctness of the above loop because of how we allocate the array.
453             for (unsigned targetIndex = 0; targetIndex &lt; arraySize; ++targetIndex) {
454                 bool found = false;
455                 for (unsigned i = materialization-&gt;properties().size(); i--;) {
456                     const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
457                     if (property.location().kind() != ArgumentPLoc)
458                         continue;
459 
460                     unsigned argIndex = property.location().info();
461                     if (numberOfArgumentsToSkip &gt; argIndex)
462                         continue;
463                     unsigned arrayIndex = argIndex - numberOfArgumentsToSkip;
464                     if (arrayIndex &gt;= arraySize)
465                         continue;
466                     if (arrayIndex == targetIndex) {
467                         found = true;
468                         break;
469                     }
470                 }
471                 ASSERT(found);
472             }
<span class="line-modified">473 #endif // ASSERT_ENABLED</span>
474             return array;
475         }
476 
477         default:
478             RELEASE_ASSERT_NOT_REACHED();
479             return nullptr;
480         }
481     }
482 
483     case PhantomSpread: {
484         JSArray* array = nullptr;
485         for (unsigned i = materialization-&gt;properties().size(); i--;) {
486             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
487             if (property.location().kind() == SpreadPLoc) {
488                 array = jsCast&lt;JSArray*&gt;(JSValue::decode(values[i]));
489                 break;
490             }
491         }
492         RELEASE_ASSERT(array);
493 
<span class="line-modified">494         // Note: it is sound for JSImmutableButterfly::createFromArray to call getDirectIndex here</span>
495         // because we&#39;re guaranteed we won&#39;t be calling any getters. The reason for this is
496         // that we only support PhantomSpread over CreateRest, which is an array we create.
497         // Any attempts to put a getter on any indices on the rest array will escape the array.
<span class="line-modified">498         auto* fixedArray = JSImmutableButterfly::createFromArray(globalObject, vm, array);</span>
499         RELEASE_ASSERT(fixedArray);
500         return fixedArray;
501     }
502 
503     case PhantomNewArrayBuffer: {
504         JSImmutableButterfly* immutableButterfly = nullptr;
505         for (unsigned i = materialization-&gt;properties().size(); i--;) {
506             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
507             if (property.location().kind() == NewArrayBufferPLoc) {
508                 immutableButterfly = jsCast&lt;JSImmutableButterfly*&gt;(JSValue::decode(values[i]));
509                 break;
510             }
511         }
512         RELEASE_ASSERT(immutableButterfly);
513 
514         // For now, we use array allocation profile in the actual CodeBlock. It is OK since current NewArrayBuffer
515         // and PhantomNewArrayBuffer are always bound to a specific op_new_array_buffer.
<span class="line-modified">516         CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(materialization-&gt;origin(), callFrame-&gt;codeBlock()-&gt;baselineAlternative());</span>
517         const Instruction* currentInstruction = codeBlock-&gt;instructions().at(materialization-&gt;origin().bytecodeIndex()).ptr();
518         if (!currentInstruction-&gt;is&lt;OpNewArrayBuffer&gt;()) {
519             // This case can happen if Object.keys, an OpCall is first converted into a NewArrayBuffer which is then converted into a PhantomNewArrayBuffer.
520             // There is no need to update the array allocation profile in that case.
521             RELEASE_ASSERT(currentInstruction-&gt;is&lt;OpCall&gt;());
<span class="line-modified">522             Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(immutableButterfly-&gt;indexingMode());</span>
523             return CommonSlowPaths::allocateNewArrayBuffer(vm, structure, immutableButterfly);
524         }
525         auto newArrayBuffer = currentInstruction-&gt;as&lt;OpNewArrayBuffer&gt;();
526         ArrayAllocationProfile* profile = &amp;newArrayBuffer.metadata(codeBlock).m_arrayAllocationProfile;
527 
528         // FIXME: Share the code with CommonSlowPaths. Currently, codeBlock etc. are slightly different.
529         IndexingType indexingMode = profile-&gt;selectIndexingType();
<span class="line-modified">530         Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingMode);</span>
531         ASSERT(isCopyOnWrite(indexingMode));
532         ASSERT(!structure-&gt;outOfLineCapacity());
533 
534         if (UNLIKELY(immutableButterfly-&gt;indexingMode() != indexingMode)) {
535             auto* newButterfly = JSImmutableButterfly::create(vm, indexingMode, immutableButterfly-&gt;length());
536             for (unsigned i = 0; i &lt; immutableButterfly-&gt;length(); ++i)
537                 newButterfly-&gt;setIndex(vm, i, immutableButterfly-&gt;get(i));
538             immutableButterfly = newButterfly;
539 
540             // FIXME: This is kinda gross and only works because we can&#39;t inline new_array_bufffer in the baseline.
541             // We also cannot allocate a new butterfly from compilation threads since it&#39;s invalid to allocate cells from
542             // a compilation thread.
543             WTF::storeStoreFence();
<span class="line-modified">544             codeBlock-&gt;constantRegister(newArrayBuffer.m_immutableButterfly).set(vm, codeBlock, immutableButterfly);</span>
545             WTF::storeStoreFence();
546         }
547 
548         JSArray* result = CommonSlowPaths::allocateNewArrayBuffer(vm, structure, immutableButterfly);
549         ArrayAllocationProfile::updateLastAllocationFor(profile, result);
550         return result;
551     }
552 
553     case PhantomNewArrayWithSpread: {
554         CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(
<span class="line-modified">555             materialization-&gt;origin(), callFrame-&gt;codeBlock()-&gt;baselineAlternative());</span>
556         JSGlobalObject* globalObject = codeBlock-&gt;globalObject();
557         Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous);
558 
559         Checked&lt;unsigned, RecordOverflow&gt; checkedArraySize = 0;
560         unsigned numProperties = 0;
561         for (unsigned i = materialization-&gt;properties().size(); i--;) {
562             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
563             if (property.location().kind() == NewArrayWithSpreadArgumentPLoc) {
564                 ++numProperties;
565                 JSValue value = JSValue::decode(values[i]);
<span class="line-modified">566                 if (JSImmutableButterfly* immutableButterfly = jsDynamicCast&lt;JSImmutableButterfly*&gt;(vm, value))</span>
<span class="line-modified">567                     checkedArraySize += immutableButterfly-&gt;publicLength();</span>
568                 else
569                     checkedArraySize += 1;
570             }
571         }
572 
573         // FIXME: we should throw an out of memory error here if checkedArraySize has hasOverflowed() or tryCreate() fails.
574         // https://bugs.webkit.org/show_bug.cgi?id=169784
575         unsigned arraySize = checkedArraySize.unsafeGet(); // Crashes if overflowed.
576         JSArray* result = JSArray::tryCreate(vm, structure, arraySize);
577         RELEASE_ASSERT(result);
578 
<span class="line-modified">579 #if ASSERT_ENABLED</span>
580         // Ensure we see indices for everything in the range: [0, numProperties)
581         for (unsigned i = 0; i &lt; numProperties; ++i) {
582             bool found = false;
583             for (unsigned j = 0; j &lt; materialization-&gt;properties().size(); ++j) {
584                 const ExitPropertyValue&amp; property = materialization-&gt;properties()[j];
585                 if (property.location().kind() == NewArrayWithSpreadArgumentPLoc &amp;&amp; property.location().info() == i) {
586                     found = true;
587                     break;
588                 }
589             }
590             ASSERT(found);
591         }
<span class="line-modified">592 #endif // ASSERT_ENABLED</span>
593 
594         Vector&lt;JSValue, 8&gt; arguments;
595         arguments.grow(numProperties);
596 
597         for (unsigned i = materialization-&gt;properties().size(); i--;) {
598             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
599             if (property.location().kind() == NewArrayWithSpreadArgumentPLoc) {
600                 JSValue value = JSValue::decode(values[i]);
601                 RELEASE_ASSERT(property.location().info() &lt; numProperties);
602                 arguments[property.location().info()] = value;
603             }
604         }
605 
606         unsigned arrayIndex = 0;
607         for (JSValue value : arguments) {
<span class="line-modified">608             if (JSImmutableButterfly* immutableButterfly = jsDynamicCast&lt;JSImmutableButterfly*&gt;(vm, value)) {</span>
<span class="line-modified">609                 for (unsigned i = 0; i &lt; immutableButterfly-&gt;publicLength(); i++) {</span>
<span class="line-modified">610                     ASSERT(immutableButterfly-&gt;get(i));</span>
<span class="line-modified">611                     result-&gt;putDirectIndex(globalObject, arrayIndex, immutableButterfly-&gt;get(i));</span>
612                     ++arrayIndex;
613                 }
614             } else {
615                 // We are not spreading.
<span class="line-modified">616                 result-&gt;putDirectIndex(globalObject, arrayIndex, value);</span>
617                 ++arrayIndex;
618             }
619         }
620 
621         return result;
622     }
623 
624     case PhantomNewRegexp: {
625         RegExp* regExp = nullptr;
626         for (unsigned i = materialization-&gt;properties().size(); i--;) {
627             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
628             if (property.location() == PromotedLocationDescriptor(RegExpObjectRegExpPLoc)) {
629                 RELEASE_ASSERT(JSValue::decode(values[i]).asCell()-&gt;inherits&lt;RegExp&gt;(vm));
630                 regExp = jsCast&lt;RegExp*&gt;(JSValue::decode(values[i]));
631             }
632         }
633         RELEASE_ASSERT(regExp);
<span class="line-modified">634         CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(materialization-&gt;origin(), callFrame-&gt;codeBlock()-&gt;baselineAlternative());</span>
635         Structure* structure = codeBlock-&gt;globalObject()-&gt;regExpStructure();
636         return RegExpObject::create(vm, structure, regExp);
637     }
638 
639     default:
640         RELEASE_ASSERT_NOT_REACHED();
641         return nullptr;
642     }
643 }
644 
<span class="line-modified">645 extern &quot;C&quot; void* JIT_OPERATION operationCompileFTLLazySlowPath(CallFrame* callFrame, unsigned index)</span>
646 {
<span class="line-modified">647     VM&amp; vm = callFrame-&gt;deprecatedVM();</span>
648 
649     // We cannot GC. We&#39;ve got pointers in evil places.
650     DeferGCForAWhile deferGC(vm.heap);
651 
<span class="line-modified">652     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
653     JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;ftl();
654 
655     LazySlowPath&amp; lazySlowPath = *jitCode-&gt;lazySlowPaths[index];
656     lazySlowPath.generate(codeBlock);
657 
658     return lazySlowPath.stub().code().executableAddress();
659 }
660 
661 } } // namespace JSC::FTL
662 
<span class="line-added">663 IGNORE_WARNINGS_END</span>
<span class="line-added">664 </span>
665 #endif // ENABLE(FTL_JIT)
666 
</pre>
</td>
</tr>
</table>
<center><a href="FTLOSRExitCompiler.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLOperations.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ArgList.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ArrayBuffer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayBuffer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ArrayBuffer.h&quot;
 28 
<span class="line-removed"> 29 #include &quot;ArrayBufferNeuteringWatchpointSet.h&quot;</span>
 30 #include &quot;JSArrayBufferView.h&quot;
 31 #include &quot;JSCInlines.h&quot;
 32 #include &lt;wtf/Gigacage.h&gt;
 33 
 34 namespace JSC {
 35 










 36 SharedArrayBufferContents::SharedArrayBufferContents(void* data, unsigned size, ArrayBufferDestructorFunction&amp;&amp; destructor)
 37     : m_data(data, size)
 38     , m_destructor(WTFMove(destructor))
 39     , m_sizeInBytes(size)
 40 {
 41 }
 42 
 43 SharedArrayBufferContents::~SharedArrayBufferContents()
 44 {
<span class="line-modified"> 45     // FIXME: we shouldn&#39;t use getUnsafe here https://bugs.webkit.org/show_bug.cgi?id=197698</span>
<span class="line-modified"> 46     m_destructor(m_data.getUnsafe());</span>


 47 }
 48 
 49 ArrayBufferContents::ArrayBufferContents()
 50 {
 51     reset();
 52 }
 53 
 54 ArrayBufferContents::ArrayBufferContents(ArrayBufferContents&amp;&amp; other)
 55 {
 56     reset();
 57     other.transferTo(*this);
 58 }
 59 
 60 ArrayBufferContents::ArrayBufferContents(void* data, unsigned sizeInBytes, ArrayBufferDestructorFunction&amp;&amp; destructor)
 61     : m_data(data, sizeInBytes)
 62     , m_sizeInBytes(sizeInBytes)
 63 {
 64     RELEASE_ASSERT(m_sizeInBytes &lt;= MAX_ARRAY_BUFFER_SIZE);
 65     m_destructor = WTFMove(destructor);
 66 }
 67 
 68 ArrayBufferContents&amp; ArrayBufferContents::operator=(ArrayBufferContents&amp;&amp; other)
 69 {
 70     other.transferTo(*this);
 71     return *this;
 72 }
 73 
 74 ArrayBufferContents::~ArrayBufferContents()
 75 {
 76     destroy();
 77 }
 78 
 79 void ArrayBufferContents::clear()
 80 {
 81     destroy();
 82     reset();
 83 }
 84 
 85 void ArrayBufferContents::destroy()
 86 {
<span class="line-modified"> 87     // FIXME: We shouldn&#39;t use getUnsafe here: https://bugs.webkit.org/show_bug.cgi?id=197698</span>
<span class="line-modified"> 88     m_destructor(m_data.getUnsafe());</span>


 89 }
 90 
 91 void ArrayBufferContents::reset()
 92 {
<span class="line-removed"> 93     m_destructor = [] (void*) { };</span>
<span class="line-removed"> 94     m_shared = nullptr;</span>
 95     m_data = nullptr;


 96     m_sizeInBytes = 0;
 97 }
 98 
 99 void ArrayBufferContents::tryAllocate(unsigned numElements, unsigned elementByteSize, InitializationPolicy policy)
100 {
101     // Do not allow 31-bit overflow of the total size.
102     if (numElements) {
103         unsigned totalSize = numElements * elementByteSize;
104         if (totalSize / numElements != elementByteSize || totalSize &gt; MAX_ARRAY_BUFFER_SIZE) {
105             reset();
106             return;
107         }
108     }
109     size_t sizeInBytes = static_cast&lt;size_t&gt;(numElements) * static_cast&lt;size_t&gt;(elementByteSize);
110     size_t allocationSize = sizeInBytes;
111     if (!allocationSize)
112         allocationSize = 1; // Make sure malloc actually allocates something, but not too much. We use null to mean that the buffer is neutered.
113 
114     void* data = Gigacage::tryMalloc(Gigacage::Primitive, allocationSize);
115     m_data = DataType(data, sizeInBytes);
116     if (!data) {
117         reset();
118         return;
119     }
120 
121     if (policy == ZeroInitialize)
122         memset(data, 0, allocationSize);
123 
124     m_sizeInBytes = sizeInBytes;
125     RELEASE_ASSERT(m_sizeInBytes &lt;= MAX_ARRAY_BUFFER_SIZE);
<span class="line-modified">126     m_destructor = [] (void* p) { Gigacage::free(Gigacage::Primitive, p); };</span>
127 }
128 
129 void ArrayBufferContents::makeShared()
130 {
131     m_shared = adoptRef(new SharedArrayBufferContents(data(), sizeInBytes(), WTFMove(m_destructor)));
<span class="line-modified">132     m_destructor = [] (void*) { };</span>
133 }
134 
135 void ArrayBufferContents::transferTo(ArrayBufferContents&amp; other)
136 {
137     other.clear();
138     other.m_data = m_data;
139     other.m_sizeInBytes = m_sizeInBytes;
140     RELEASE_ASSERT(other.m_sizeInBytes &lt;= MAX_ARRAY_BUFFER_SIZE);
141     other.m_destructor = WTFMove(m_destructor);
142     other.m_shared = m_shared;
143     reset();
144 }
145 
146 void ArrayBufferContents::copyTo(ArrayBufferContents&amp; other)
147 {
148     ASSERT(!other.m_data);
149     other.tryAllocate(m_sizeInBytes, sizeof(char), ArrayBufferContents::DontInitialize);
150     if (!other.m_data)
151         return;
152     memcpy(other.data(), data(), m_sizeInBytes);
153     other.m_sizeInBytes = m_sizeInBytes;
154     RELEASE_ASSERT(other.m_sizeInBytes &lt;= MAX_ARRAY_BUFFER_SIZE);
155 }
156 
157 void ArrayBufferContents::shareWith(ArrayBufferContents&amp; other)
158 {
159     ASSERT(!other.m_data);
160     ASSERT(m_shared);
<span class="line-removed">161     other.m_destructor = [] (void*) { };</span>
<span class="line-removed">162     other.m_shared = m_shared;</span>
163     other.m_data = m_data;


164     other.m_sizeInBytes = m_sizeInBytes;
165     RELEASE_ASSERT(other.m_sizeInBytes &lt;= MAX_ARRAY_BUFFER_SIZE);
166 }
167 
168 Ref&lt;ArrayBuffer&gt; ArrayBuffer::create(unsigned numElements, unsigned elementByteSize)
169 {
170     auto buffer = tryCreate(numElements, elementByteSize);
171     if (!buffer)
172         CRASH();
173     return buffer.releaseNonNull();
174 }
175 
176 Ref&lt;ArrayBuffer&gt; ArrayBuffer::create(ArrayBuffer&amp; other)
177 {
178     return ArrayBuffer::create(other.data(), other.byteLength());
179 }
180 
181 Ref&lt;ArrayBuffer&gt; ArrayBuffer::create(const void* source, unsigned byteLength)
182 {
183     auto buffer = tryCreate(source, byteLength);
184     if (!buffer)
185         CRASH();
186     return buffer.releaseNonNull();
187 }
188 
189 Ref&lt;ArrayBuffer&gt; ArrayBuffer::create(ArrayBufferContents&amp;&amp; contents)
190 {
191     return adoptRef(*new ArrayBuffer(WTFMove(contents)));
192 }
193 
194 // FIXME: We cannot use this except if the memory comes from the cage.
195 // Current this is only used from:
196 // - JSGenericTypedArrayView&lt;&gt;::slowDownAndWasteMemory. But in that case, the memory should have already come
197 //   from the cage.
198 Ref&lt;ArrayBuffer&gt; ArrayBuffer::createAdopted(const void* data, unsigned byteLength)
199 {
<span class="line-modified">200     return createFromBytes(data, byteLength, [] (void* p) { Gigacage::free(Gigacage::Primitive, p); });</span>
201 }
202 
203 // FIXME: We cannot use this except if the memory comes from the cage.
204 // Currently this is only used from:
205 // - The C API. We could support that by either having the system switch to a mode where typed arrays are no
206 //   longer caged, or we could introduce a new set of typed array types that are uncaged and get accessed
207 //   differently.
208 // - WebAssembly. Wasm should allocate from the cage.
209 Ref&lt;ArrayBuffer&gt; ArrayBuffer::createFromBytes(const void* data, unsigned byteLength, ArrayBufferDestructorFunction&amp;&amp; destructor)
210 {
211     if (data &amp;&amp; !Gigacage::isCaged(Gigacage::Primitive, data))
212         Gigacage::disablePrimitiveGigacage();
213 
214     ArrayBufferContents contents(const_cast&lt;void*&gt;(data), byteLength, WTFMove(destructor));
215     return create(WTFMove(contents));
216 }
217 
218 RefPtr&lt;ArrayBuffer&gt; ArrayBuffer::tryCreate(unsigned numElements, unsigned elementByteSize)
219 {
220     return tryCreate(numElements, elementByteSize, ArrayBufferContents::ZeroInitialize);
</pre>
<hr />
<pre>
278 }
279 
280 unsigned ArrayBuffer::clampValue(double x, unsigned left, unsigned right)
281 {
282     ASSERT(left &lt;= right);
283     if (x &lt; left)
284         x = left;
285     if (right &lt; x)
286         x = right;
287     return x;
288 }
289 
290 unsigned ArrayBuffer::clampIndex(double index) const
291 {
292     unsigned currentLength = byteLength();
293     if (index &lt; 0)
294         index = currentLength + index;
295     return clampValue(index, 0, currentLength);
296 }
297 
<span class="line-modified">298 Ref&lt;ArrayBuffer&gt; ArrayBuffer::slice(double begin, double end) const</span>
299 {
300     return sliceImpl(clampIndex(begin), clampIndex(end));
301 }
302 
<span class="line-modified">303 Ref&lt;ArrayBuffer&gt; ArrayBuffer::slice(double begin) const</span>
304 {
305     return sliceImpl(clampIndex(begin), byteLength());
306 }
307 
<span class="line-modified">308 Ref&lt;ArrayBuffer&gt; ArrayBuffer::sliceImpl(unsigned begin, unsigned end) const</span>
309 {
310     unsigned size = begin &lt;= end ? end - begin : 0;
<span class="line-modified">311     auto result = ArrayBuffer::create(static_cast&lt;const char*&gt;(data()) + begin, size);</span>
<span class="line-modified">312     result-&gt;setSharingMode(sharingMode());</span>

313     return result;
314 }
315 
316 void ArrayBuffer::makeShared()
317 {
318     m_contents.makeShared();
319     m_locked = true;
320 }
321 
322 void ArrayBuffer::makeWasmMemory()
323 {
324     m_locked = true;
325     m_isWasmMemory = true;
326 }
327 
328 void ArrayBuffer::setSharingMode(ArrayBufferSharingMode newSharingMode)
329 {
330     if (newSharingMode == sharingMode())
331         return;
332     RELEASE_ASSERT(!isShared()); // Cannot revert sharing.
</pre>
<hr />
<pre>
352     if (!m_contents.m_data) {
353         result.m_data = nullptr;
354         return false;
355     }
356 
357     if (isShared()) {
358         m_contents.shareWith(result);
359         return true;
360     }
361 
362     bool isNeuterable = !m_pinCount &amp;&amp; !m_locked;
363 
364     if (!isNeuterable) {
365         m_contents.copyTo(result);
366         if (!result.m_data)
367             return false;
368         return true;
369     }
370 
371     m_contents.transferTo(result);
<span class="line-modified">372     notifyIncommingReferencesOfTransfer(vm);</span>
373     return true;
374 }
375 
376 // We allow neutering wasm memory ArrayBuffers even though they are locked.
377 void ArrayBuffer::neuter(VM&amp; vm)
378 {
379     ASSERT(isWasmMemory());
380     ArrayBufferContents unused;
381     m_contents.transferTo(unused);
<span class="line-modified">382     notifyIncommingReferencesOfTransfer(vm);</span>
383 }
384 
<span class="line-modified">385 void ArrayBuffer::notifyIncommingReferencesOfTransfer(VM&amp; vm)</span>
386 {
387     for (size_t i = numberOfIncomingReferences(); i--;) {
388         JSCell* cell = incomingReferenceAt(i);
389         if (JSArrayBufferView* view = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, cell))
390             view-&gt;neuter();
<span class="line-removed">391         else if (ArrayBufferNeuteringWatchpointSet* watchpoint = jsDynamicCast&lt;ArrayBufferNeuteringWatchpointSet*&gt;(vm, cell))</span>
<span class="line-removed">392             watchpoint-&gt;fireAll();</span>
393     }

394 }
395 
396 ASCIILiteral errorMesasgeForTransfer(ArrayBuffer* buffer)
397 {
398     ASSERT(buffer-&gt;isLocked());
399     if (buffer-&gt;isShared())
400         return &quot;Cannot transfer a SharedArrayBuffer&quot;_s;
401     if (buffer-&gt;isWasmMemory())
402         return &quot;Cannot transfer a WebAssembly.Memory&quot;_s;
403     return &quot;Cannot transfer an ArrayBuffer whose backing store has been accessed by the JavaScriptCore C API&quot;_s;
404 }
405 
406 } // namespace JSC
407 
</pre>
</td>
<td>
<hr />
<pre>
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ArrayBuffer.h&quot;
 28 

 29 #include &quot;JSArrayBufferView.h&quot;
 30 #include &quot;JSCInlines.h&quot;
 31 #include &lt;wtf/Gigacage.h&gt;
 32 
 33 namespace JSC {
 34 
<span class="line-added"> 35 Ref&lt;SharedTask&lt;void(void*)&gt;&gt; ArrayBuffer::primitiveGigacageDestructor()</span>
<span class="line-added"> 36 {</span>
<span class="line-added"> 37     static LazyNeverDestroyed&lt;Ref&lt;SharedTask&lt;void(void*)&gt;&gt;&gt; destructor;</span>
<span class="line-added"> 38     static std::once_flag onceKey;</span>
<span class="line-added"> 39     std::call_once(onceKey, [&amp;] {</span>
<span class="line-added"> 40         destructor.construct(createSharedTask&lt;void(void*)&gt;([] (void* p) { Gigacage::free(Gigacage::Primitive, p); }));</span>
<span class="line-added"> 41     });</span>
<span class="line-added"> 42     return destructor.get().copyRef();</span>
<span class="line-added"> 43 }</span>
<span class="line-added"> 44 </span>
 45 SharedArrayBufferContents::SharedArrayBufferContents(void* data, unsigned size, ArrayBufferDestructorFunction&amp;&amp; destructor)
 46     : m_data(data, size)
 47     , m_destructor(WTFMove(destructor))
 48     , m_sizeInBytes(size)
 49 {
 50 }
 51 
 52 SharedArrayBufferContents::~SharedArrayBufferContents()
 53 {
<span class="line-modified"> 54     if (m_destructor) {</span>
<span class="line-modified"> 55         // FIXME: we shouldn&#39;t use getUnsafe here https://bugs.webkit.org/show_bug.cgi?id=197698</span>
<span class="line-added"> 56         m_destructor-&gt;run(m_data.getUnsafe());</span>
<span class="line-added"> 57     }</span>
 58 }
 59 
 60 ArrayBufferContents::ArrayBufferContents()
 61 {
 62     reset();
 63 }
 64 
 65 ArrayBufferContents::ArrayBufferContents(ArrayBufferContents&amp;&amp; other)
 66 {
 67     reset();
 68     other.transferTo(*this);
 69 }
 70 
 71 ArrayBufferContents::ArrayBufferContents(void* data, unsigned sizeInBytes, ArrayBufferDestructorFunction&amp;&amp; destructor)
 72     : m_data(data, sizeInBytes)
 73     , m_sizeInBytes(sizeInBytes)
 74 {
 75     RELEASE_ASSERT(m_sizeInBytes &lt;= MAX_ARRAY_BUFFER_SIZE);
 76     m_destructor = WTFMove(destructor);
 77 }
 78 
 79 ArrayBufferContents&amp; ArrayBufferContents::operator=(ArrayBufferContents&amp;&amp; other)
 80 {
 81     other.transferTo(*this);
 82     return *this;
 83 }
 84 
 85 ArrayBufferContents::~ArrayBufferContents()
 86 {
 87     destroy();
 88 }
 89 
 90 void ArrayBufferContents::clear()
 91 {
 92     destroy();
 93     reset();
 94 }
 95 
 96 void ArrayBufferContents::destroy()
 97 {
<span class="line-modified"> 98     if (m_destructor) {</span>
<span class="line-modified"> 99         // FIXME: We shouldn&#39;t use getUnsafe here: https://bugs.webkit.org/show_bug.cgi?id=197698</span>
<span class="line-added">100         m_destructor-&gt;run(m_data.getUnsafe());</span>
<span class="line-added">101     }</span>
102 }
103 
104 void ArrayBufferContents::reset()
105 {


106     m_data = nullptr;
<span class="line-added">107     m_destructor = nullptr;</span>
<span class="line-added">108     m_shared = nullptr;</span>
109     m_sizeInBytes = 0;
110 }
111 
112 void ArrayBufferContents::tryAllocate(unsigned numElements, unsigned elementByteSize, InitializationPolicy policy)
113 {
114     // Do not allow 31-bit overflow of the total size.
115     if (numElements) {
116         unsigned totalSize = numElements * elementByteSize;
117         if (totalSize / numElements != elementByteSize || totalSize &gt; MAX_ARRAY_BUFFER_SIZE) {
118             reset();
119             return;
120         }
121     }
122     size_t sizeInBytes = static_cast&lt;size_t&gt;(numElements) * static_cast&lt;size_t&gt;(elementByteSize);
123     size_t allocationSize = sizeInBytes;
124     if (!allocationSize)
125         allocationSize = 1; // Make sure malloc actually allocates something, but not too much. We use null to mean that the buffer is neutered.
126 
127     void* data = Gigacage::tryMalloc(Gigacage::Primitive, allocationSize);
128     m_data = DataType(data, sizeInBytes);
129     if (!data) {
130         reset();
131         return;
132     }
133 
134     if (policy == ZeroInitialize)
135         memset(data, 0, allocationSize);
136 
137     m_sizeInBytes = sizeInBytes;
138     RELEASE_ASSERT(m_sizeInBytes &lt;= MAX_ARRAY_BUFFER_SIZE);
<span class="line-modified">139     m_destructor = ArrayBuffer::primitiveGigacageDestructor();</span>
140 }
141 
142 void ArrayBufferContents::makeShared()
143 {
144     m_shared = adoptRef(new SharedArrayBufferContents(data(), sizeInBytes(), WTFMove(m_destructor)));
<span class="line-modified">145     m_destructor = nullptr;</span>
146 }
147 
148 void ArrayBufferContents::transferTo(ArrayBufferContents&amp; other)
149 {
150     other.clear();
151     other.m_data = m_data;
152     other.m_sizeInBytes = m_sizeInBytes;
153     RELEASE_ASSERT(other.m_sizeInBytes &lt;= MAX_ARRAY_BUFFER_SIZE);
154     other.m_destructor = WTFMove(m_destructor);
155     other.m_shared = m_shared;
156     reset();
157 }
158 
159 void ArrayBufferContents::copyTo(ArrayBufferContents&amp; other)
160 {
161     ASSERT(!other.m_data);
162     other.tryAllocate(m_sizeInBytes, sizeof(char), ArrayBufferContents::DontInitialize);
163     if (!other.m_data)
164         return;
165     memcpy(other.data(), data(), m_sizeInBytes);
166     other.m_sizeInBytes = m_sizeInBytes;
167     RELEASE_ASSERT(other.m_sizeInBytes &lt;= MAX_ARRAY_BUFFER_SIZE);
168 }
169 
170 void ArrayBufferContents::shareWith(ArrayBufferContents&amp; other)
171 {
172     ASSERT(!other.m_data);
173     ASSERT(m_shared);


174     other.m_data = m_data;
<span class="line-added">175     other.m_destructor = nullptr;</span>
<span class="line-added">176     other.m_shared = m_shared;</span>
177     other.m_sizeInBytes = m_sizeInBytes;
178     RELEASE_ASSERT(other.m_sizeInBytes &lt;= MAX_ARRAY_BUFFER_SIZE);
179 }
180 
181 Ref&lt;ArrayBuffer&gt; ArrayBuffer::create(unsigned numElements, unsigned elementByteSize)
182 {
183     auto buffer = tryCreate(numElements, elementByteSize);
184     if (!buffer)
185         CRASH();
186     return buffer.releaseNonNull();
187 }
188 
189 Ref&lt;ArrayBuffer&gt; ArrayBuffer::create(ArrayBuffer&amp; other)
190 {
191     return ArrayBuffer::create(other.data(), other.byteLength());
192 }
193 
194 Ref&lt;ArrayBuffer&gt; ArrayBuffer::create(const void* source, unsigned byteLength)
195 {
196     auto buffer = tryCreate(source, byteLength);
197     if (!buffer)
198         CRASH();
199     return buffer.releaseNonNull();
200 }
201 
202 Ref&lt;ArrayBuffer&gt; ArrayBuffer::create(ArrayBufferContents&amp;&amp; contents)
203 {
204     return adoptRef(*new ArrayBuffer(WTFMove(contents)));
205 }
206 
207 // FIXME: We cannot use this except if the memory comes from the cage.
208 // Current this is only used from:
209 // - JSGenericTypedArrayView&lt;&gt;::slowDownAndWasteMemory. But in that case, the memory should have already come
210 //   from the cage.
211 Ref&lt;ArrayBuffer&gt; ArrayBuffer::createAdopted(const void* data, unsigned byteLength)
212 {
<span class="line-modified">213     return createFromBytes(data, byteLength, ArrayBuffer::primitiveGigacageDestructor());</span>
214 }
215 
216 // FIXME: We cannot use this except if the memory comes from the cage.
217 // Currently this is only used from:
218 // - The C API. We could support that by either having the system switch to a mode where typed arrays are no
219 //   longer caged, or we could introduce a new set of typed array types that are uncaged and get accessed
220 //   differently.
221 // - WebAssembly. Wasm should allocate from the cage.
222 Ref&lt;ArrayBuffer&gt; ArrayBuffer::createFromBytes(const void* data, unsigned byteLength, ArrayBufferDestructorFunction&amp;&amp; destructor)
223 {
224     if (data &amp;&amp; !Gigacage::isCaged(Gigacage::Primitive, data))
225         Gigacage::disablePrimitiveGigacage();
226 
227     ArrayBufferContents contents(const_cast&lt;void*&gt;(data), byteLength, WTFMove(destructor));
228     return create(WTFMove(contents));
229 }
230 
231 RefPtr&lt;ArrayBuffer&gt; ArrayBuffer::tryCreate(unsigned numElements, unsigned elementByteSize)
232 {
233     return tryCreate(numElements, elementByteSize, ArrayBufferContents::ZeroInitialize);
</pre>
<hr />
<pre>
291 }
292 
293 unsigned ArrayBuffer::clampValue(double x, unsigned left, unsigned right)
294 {
295     ASSERT(left &lt;= right);
296     if (x &lt; left)
297         x = left;
298     if (right &lt; x)
299         x = right;
300     return x;
301 }
302 
303 unsigned ArrayBuffer::clampIndex(double index) const
304 {
305     unsigned currentLength = byteLength();
306     if (index &lt; 0)
307         index = currentLength + index;
308     return clampValue(index, 0, currentLength);
309 }
310 
<span class="line-modified">311 RefPtr&lt;ArrayBuffer&gt; ArrayBuffer::slice(double begin, double end) const</span>
312 {
313     return sliceImpl(clampIndex(begin), clampIndex(end));
314 }
315 
<span class="line-modified">316 RefPtr&lt;ArrayBuffer&gt; ArrayBuffer::slice(double begin) const</span>
317 {
318     return sliceImpl(clampIndex(begin), byteLength());
319 }
320 
<span class="line-modified">321 RefPtr&lt;ArrayBuffer&gt; ArrayBuffer::sliceImpl(unsigned begin, unsigned end) const</span>
322 {
323     unsigned size = begin &lt;= end ? end - begin : 0;
<span class="line-modified">324     auto result = ArrayBuffer::tryCreate(static_cast&lt;const char*&gt;(data()) + begin, size);</span>
<span class="line-modified">325     if (result)</span>
<span class="line-added">326         result-&gt;setSharingMode(sharingMode());</span>
327     return result;
328 }
329 
330 void ArrayBuffer::makeShared()
331 {
332     m_contents.makeShared();
333     m_locked = true;
334 }
335 
336 void ArrayBuffer::makeWasmMemory()
337 {
338     m_locked = true;
339     m_isWasmMemory = true;
340 }
341 
342 void ArrayBuffer::setSharingMode(ArrayBufferSharingMode newSharingMode)
343 {
344     if (newSharingMode == sharingMode())
345         return;
346     RELEASE_ASSERT(!isShared()); // Cannot revert sharing.
</pre>
<hr />
<pre>
366     if (!m_contents.m_data) {
367         result.m_data = nullptr;
368         return false;
369     }
370 
371     if (isShared()) {
372         m_contents.shareWith(result);
373         return true;
374     }
375 
376     bool isNeuterable = !m_pinCount &amp;&amp; !m_locked;
377 
378     if (!isNeuterable) {
379         m_contents.copyTo(result);
380         if (!result.m_data)
381             return false;
382         return true;
383     }
384 
385     m_contents.transferTo(result);
<span class="line-modified">386     notifyNeutering(vm);</span>
387     return true;
388 }
389 
390 // We allow neutering wasm memory ArrayBuffers even though they are locked.
391 void ArrayBuffer::neuter(VM&amp; vm)
392 {
393     ASSERT(isWasmMemory());
394     ArrayBufferContents unused;
395     m_contents.transferTo(unused);
<span class="line-modified">396     notifyNeutering(vm);</span>
397 }
398 
<span class="line-modified">399 void ArrayBuffer::notifyNeutering(VM&amp; vm)</span>
400 {
401     for (size_t i = numberOfIncomingReferences(); i--;) {
402         JSCell* cell = incomingReferenceAt(i);
403         if (JSArrayBufferView* view = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, cell))
404             view-&gt;neuter();


405     }
<span class="line-added">406     m_neuteringWatchpointSet.fireAll(vm, &quot;Array buffer was neutered&quot;);</span>
407 }
408 
409 ASCIILiteral errorMesasgeForTransfer(ArrayBuffer* buffer)
410 {
411     ASSERT(buffer-&gt;isLocked());
412     if (buffer-&gt;isShared())
413         return &quot;Cannot transfer a SharedArrayBuffer&quot;_s;
414     if (buffer-&gt;isWasmMemory())
415         return &quot;Cannot transfer a WebAssembly.Memory&quot;_s;
416     return &quot;Cannot transfer an ArrayBuffer whose backing store has been accessed by the JavaScriptCore C API&quot;_s;
417 }
418 
419 } // namespace JSC
420 
</pre>
</td>
</tr>
</table>
<center><a href="ArgList.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ArrayBuffer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
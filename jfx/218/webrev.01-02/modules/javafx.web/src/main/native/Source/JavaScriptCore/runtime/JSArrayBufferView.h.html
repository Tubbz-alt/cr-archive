<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArrayBufferView.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;AuxiliaryBarrier.h&quot;
 29 #include &quot;JSObject.h&quot;
 30 #include &lt;wtf/TaggedArrayStoragePtr.h&gt;
 31 
 32 namespace JSC {
 33 
 34 class LLIntOffsetsExtractor;
 35 
 36 // This class serves two purposes:
 37 //
 38 // 1) It provides those parts of JSGenericTypedArrayView that don&#39;t depend
 39 //    on template parameters.
 40 //
 41 // 2) It represents the DOM/WebCore-visible &quot;JSArrayBufferView&quot; type, which
 42 //    C++ code uses when it wants to pass around a view of an array buffer
 43 //    without concern for the actual type of the view.
 44 //
 45 // These two roles are quite different. (1) is just a matter of optimizing
 46 // compile and link times by having as much code and data as possible not
 47 // be subject to template specialization. (2) is *almost* a matter of
 48 // semantics; indeed at the very least it is a matter of obeying a contract
 49 // that we have with WebCore right now.
 50 //
 51 // One convenient thing that saves us from too much crazy is that
 52 // ArrayBufferView is not instantiable.
 53 
 54 // Typed array views have different modes depending on how big they are and
 55 // whether the user has done anything that requires a separate backing
 56 // buffer or the DOM-specified neutering capabilities.
 57 enum TypedArrayMode : uint32_t {
 58     // Small and fast typed array. B is unused, V points to a vector
 59     // allocated in copied space, and M = FastTypedArray. V&#39;s liveness is
 60     // determined entirely by the view&#39;s liveness.
 61     FastTypedArray,
 62 
 63     // A large typed array that still attempts not to waste too much
 64     // memory. B is initialized to point to a slot that could hold a
 65     // buffer pointer, V points to a vector allocated using fastCalloc(),
 66     // and M = OversizeTypedArray. V&#39;s liveness is determined entirely by
 67     // the view&#39;s liveness, and the view will add a finalizer to delete V.
 68     OversizeTypedArray,
 69 
 70     // A typed array that was used in some crazy way. B&#39;s IndexingHeader
 71     // is hijacked to contain a reference to the native array buffer. The
 72     // native typed array view points back to the JS view. V points to a
 73     // vector allocated using who-knows-what, and M = WastefulTypedArray.
 74     // The view does not own the vector.
 75     WastefulTypedArray,
 76 
 77     // A data view. B is unused, V points to a vector allocated using who-
 78     // knows-what, and M = DataViewMode. The view does not own the vector.
 79     // There is an extra field (in JSDataView) that points to the
 80     // ArrayBuffer.
 81     DataViewMode
 82 };
 83 
 84 inline bool hasArrayBuffer(TypedArrayMode mode)
 85 {
 86     return mode &gt;= WastefulTypedArray;
 87 }
 88 
 89 // When WebCore uses a JSArrayBufferView, it expects to be able to get the native
 90 // ArrayBuffer and little else. This requires slowing down and wasting memory,
 91 // and then accessing things via the Butterfly. When JS uses a JSArrayBufferView
 92 // it is always via the usual methods in the MethodTable, so this class&#39;s
 93 // implementation of those has no need to even exist - we could at any time sink
 94 // code into JSGenericTypedArrayView if it was convenient.
 95 
 96 class JSArrayBufferView : public JSNonFinalObject {
 97 public:
 98     using Base = JSNonFinalObject;
 99 
100     template&lt;typename, SubspaceAccess&gt;
101     static void subspaceFor(VM&amp;)
102     {
103         RELEASE_ASSERT_NOT_REACHED();
104     }
105 
106     static constexpr unsigned fastSizeLimit = 1000;
107     using VectorPtr = CagedBarrierPtr&lt;Gigacage::Primitive, void, tagCagedPtr&gt;;
108 
109     static size_t sizeOf(uint32_t length, uint32_t elementSize)
110     {
111         return (static_cast&lt;size_t&gt;(length) * elementSize + sizeof(EncodedJSValue) - 1)
112             &amp; ~(sizeof(EncodedJSValue) - 1);
113     }
114 
115     static size_t allocationSize(Checked&lt;size_t&gt; inlineCapacity)
116     {
117         ASSERT_UNUSED(inlineCapacity, !inlineCapacity);
118         return sizeof(JSArrayBufferView);
119     }
120 
121 protected:
122     class ConstructionContext {
123         WTF_MAKE_NONCOPYABLE(ConstructionContext);
124 
125     public:
126         enum InitializationMode { ZeroFill, DontInitialize };
127 
128         JS_EXPORT_PRIVATE ConstructionContext(VM&amp;, Structure*, uint32_t length, uint32_t elementSize, InitializationMode = ZeroFill);
129 
130         // This is only for constructing fast typed arrays. It&#39;s used by the JIT&#39;s slow path.
131         ConstructionContext(Structure*, uint32_t length, void* vector);
132 
133         JS_EXPORT_PRIVATE ConstructionContext(
134             VM&amp;, Structure*, RefPtr&lt;ArrayBuffer&gt;&amp;&amp;,
135             unsigned byteOffset, unsigned length);
136 
137         enum DataViewTag { DataView };
138         ConstructionContext(
139             Structure*, RefPtr&lt;ArrayBuffer&gt;&amp;&amp;,
140             unsigned byteOffset, unsigned length, DataViewTag);
141 
142         bool operator!() const { return !m_structure; }
143 
144         Structure* structure() const { return m_structure; }
145         void* vector() const { return m_vector.getMayBeNull(m_length); }
146         uint32_t length() const { return m_length; }
147         TypedArrayMode mode() const { return m_mode; }
148         Butterfly* butterfly() const { return m_butterfly; }
149 
150     private:
151         Structure* m_structure;
152         using VectorType = CagedPtr&lt;Gigacage::Primitive, void, tagCagedPtr&gt;;
153         VectorType m_vector;
154         uint32_t m_length;
155         TypedArrayMode m_mode;
156         Butterfly* m_butterfly;
157     };
158 
159     JS_EXPORT_PRIVATE JSArrayBufferView(VM&amp;, ConstructionContext&amp;);
160     JS_EXPORT_PRIVATE void finishCreation(VM&amp;);
161 
162     static bool put(JSCell*, JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);
163 
164     static void visitChildren(JSCell*, SlotVisitor&amp;);
165 
166 public:
167     TypedArrayMode mode() const { return m_mode; }
168     bool hasArrayBuffer() const { return JSC::hasArrayBuffer(mode()); }
169 
170     bool isShared();
171     JS_EXPORT_PRIVATE ArrayBuffer* unsharedBuffer();
172     inline ArrayBuffer* possiblySharedBuffer();
173     JSArrayBuffer* unsharedJSBuffer(JSGlobalObject* globalObject);
174     JSArrayBuffer* possiblySharedJSBuffer(JSGlobalObject* globalObject);
175     RefPtr&lt;ArrayBufferView&gt; unsharedImpl();
176     JS_EXPORT_PRIVATE RefPtr&lt;ArrayBufferView&gt; possiblySharedImpl();
177     bool isNeutered() { return hasArrayBuffer() &amp;&amp; !hasVector(); }
178     void neuter();
179 
180     bool hasVector() const { return !!m_vector; }
181     void* vector() const { return m_vector.getMayBeNull(length()); }
182 
183     inline unsigned byteOffset();
184     inline Optional&lt;unsigned&gt; byteOffsetConcurrently();
185 
186     unsigned length() const { return m_length; }
187 
188     DECLARE_EXPORT_INFO;
189 
190     static ptrdiff_t offsetOfVector() { return OBJECT_OFFSETOF(JSArrayBufferView, m_vector); }
191     static ptrdiff_t offsetOfLength() { return OBJECT_OFFSETOF(JSArrayBufferView, m_length); }
192     static ptrdiff_t offsetOfMode() { return OBJECT_OFFSETOF(JSArrayBufferView, m_mode); }
193 
194     static RefPtr&lt;ArrayBufferView&gt; toWrapped(VM&amp;, JSValue);
195 
196 private:
197     enum Requester { Mutator, ConcurrentThread };
198     template&lt;Requester, typename ResultType&gt; ResultType byteOffsetImpl();
199     template&lt;Requester&gt; ArrayBuffer* possiblySharedBufferImpl();
200 
201     JS_EXPORT_PRIVATE ArrayBuffer* slowDownAndWasteMemory();
202     static void finalize(JSCell*);
203 
204 protected:
205     friend class LLIntOffsetsExtractor;
206 
207     ArrayBuffer* existingBufferInButterfly();
208 
209     static String toStringName(const JSObject*, JSGlobalObject*);
210 
211     VectorPtr m_vector;
212     uint32_t m_length;
213     TypedArrayMode m_mode;
214 };
215 
216 } // namespace JSC
217 
218 namespace WTF {
219 
220 JS_EXPORT_PRIVATE void printInternal(PrintStream&amp;, JSC::TypedArrayMode);
221 
222 } // namespace WTF
    </pre>
  </body>
</html>
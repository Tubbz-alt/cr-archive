<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITCode.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2008-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JITCode.h&quot;
 28 
 29 #include &quot;JSCInlines.h&quot;
 30 #include &quot;ProtoCallFrame.h&quot;
 31 #include &lt;wtf/PrintStream.h&gt;
 32 
 33 namespace JSC {
 34 
<a name="1" id="anc1"></a><span class="line-added"> 35 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(DirectJITCode);</span>
<span class="line-added"> 36 </span>
 37 JITCode::JITCode(JITType jitType, ShareAttribute shareAttribute)
 38     : m_jitType(jitType)
 39     , m_shareAttribute(shareAttribute)
 40 {
 41 }
 42 
 43 JITCode::~JITCode()
 44 {
 45 }
 46 
 47 const char* JITCode::typeName(JITType jitType)
 48 {
 49     switch (jitType) {
 50     case JITType::None:
 51         return &quot;None&quot;;
 52     case JITType::HostCallThunk:
 53         return &quot;Host&quot;;
 54     case JITType::InterpreterThunk:
 55         return &quot;LLInt&quot;;
 56     case JITType::BaselineJIT:
 57         return &quot;Baseline&quot;;
 58     case JITType::DFGJIT:
 59         return &quot;DFG&quot;;
 60     case JITType::FTLJIT:
 61         return &quot;FTL&quot;;
 62     default:
 63         CRASH();
 64         return &quot;&quot;;
 65     }
 66 }
 67 
 68 void JITCode::validateReferences(const TrackedReferences&amp;)
 69 {
 70 }
 71 
 72 DFG::CommonData* JITCode::dfgCommon()
 73 {
 74     RELEASE_ASSERT_NOT_REACHED();
 75     return 0;
 76 }
 77 
 78 DFG::JITCode* JITCode::dfg()
 79 {
 80     RELEASE_ASSERT_NOT_REACHED();
 81     return 0;
 82 }
 83 
 84 FTL::JITCode* JITCode::ftl()
 85 {
 86     RELEASE_ASSERT_NOT_REACHED();
 87     return 0;
 88 }
 89 
 90 FTL::ForOSREntryJITCode* JITCode::ftlForOSREntry()
 91 {
 92     RELEASE_ASSERT_NOT_REACHED();
 93     return 0;
 94 }
 95 
<a name="2" id="anc2"></a><span class="line-added"> 96 void JITCode::shrinkToFit(const ConcurrentJSLocker&amp;)</span>
<span class="line-added"> 97 {</span>
<span class="line-added"> 98 }</span>
<span class="line-added"> 99 </span>
100 JITCodeWithCodeRef::JITCodeWithCodeRef(JITType jitType)
101     : JITCode(jitType)
102 {
103 }
104 
105 JITCodeWithCodeRef::JITCodeWithCodeRef(CodeRef&lt;JSEntryPtrTag&gt; ref, JITType jitType, JITCode::ShareAttribute shareAttribute)
106     : JITCode(jitType, shareAttribute)
107     , m_ref(ref)
108 {
109 }
110 
111 JITCodeWithCodeRef::~JITCodeWithCodeRef()
112 {
113     if ((Options::dumpDisassembly() || (isOptimizingJIT(jitType()) &amp;&amp; Options::dumpDFGDisassembly()))
114         &amp;&amp; m_ref.executableMemory())
115         dataLog(&quot;Destroying JIT code at &quot;, pointerDump(m_ref.executableMemory()), &quot;\n&quot;);
116 }
117 
118 void* JITCodeWithCodeRef::executableAddressAtOffset(size_t offset)
119 {
120     RELEASE_ASSERT(m_ref);
121     assertIsTaggedWith(m_ref.code().executableAddress(), JSEntryPtrTag);
122     if (!offset)
123         return m_ref.code().executableAddress();
124 
125     char* executableAddress = untagCodePtr&lt;char*, JSEntryPtrTag&gt;(m_ref.code().executableAddress());
126     return tagCodePtr&lt;JSEntryPtrTag&gt;(executableAddress + offset);
127 }
128 
129 void* JITCodeWithCodeRef::dataAddressAtOffset(size_t offset)
130 {
131     RELEASE_ASSERT(m_ref);
132     ASSERT(offset &lt;= size()); // use &lt;= instead of &lt; because it is valid to ask for an address at the exclusive end of the code.
133     return m_ref.code().dataLocation&lt;char*&gt;() + offset;
134 }
135 
136 unsigned JITCodeWithCodeRef::offsetOf(void* pointerIntoCode)
137 {
138     RELEASE_ASSERT(m_ref);
139     intptr_t result = reinterpret_cast&lt;intptr_t&gt;(pointerIntoCode) - m_ref.code().executableAddress&lt;intptr_t&gt;();
140     ASSERT(static_cast&lt;intptr_t&gt;(static_cast&lt;unsigned&gt;(result)) == result);
141     return static_cast&lt;unsigned&gt;(result);
142 }
143 
144 size_t JITCodeWithCodeRef::size()
145 {
146     RELEASE_ASSERT(m_ref);
147     return m_ref.size();
148 }
149 
150 bool JITCodeWithCodeRef::contains(void* address)
151 {
152     RELEASE_ASSERT(m_ref);
153     return m_ref.executableMemory()-&gt;contains(address);
154 }
155 
156 DirectJITCode::DirectJITCode(JITType jitType)
157     : JITCodeWithCodeRef(jitType)
158 {
159 }
160 
161 DirectJITCode::DirectJITCode(JITCode::CodeRef&lt;JSEntryPtrTag&gt; ref, JITCode::CodePtr&lt;JSEntryPtrTag&gt; withArityCheck, JITType jitType, JITCode::ShareAttribute shareAttribute)
162     : JITCodeWithCodeRef(ref, jitType, shareAttribute)
163     , m_withArityCheck(withArityCheck)
164 {
165     ASSERT(m_ref);
166     ASSERT(m_withArityCheck);
167 }
168 
169 DirectJITCode::DirectJITCode(JITCode::CodeRef&lt;JSEntryPtrTag&gt; ref, JITCode::CodePtr&lt;JSEntryPtrTag&gt; withArityCheck, JITType jitType, Intrinsic intrinsic, JITCode::ShareAttribute shareAttribute)
170     : JITCodeWithCodeRef(ref, jitType, shareAttribute)
171     , m_withArityCheck(withArityCheck)
172 {
173     m_intrinsic = intrinsic;
174     ASSERT(m_ref);
175     ASSERT(m_withArityCheck);
176 }
177 
178 DirectJITCode::~DirectJITCode()
179 {
180 }
181 
182 void DirectJITCode::initializeCodeRefForDFG(JITCode::CodeRef&lt;JSEntryPtrTag&gt; ref, JITCode::CodePtr&lt;JSEntryPtrTag&gt; withArityCheck)
183 {
184     RELEASE_ASSERT(!m_ref);
185     m_ref = ref;
186     m_withArityCheck = withArityCheck;
187     ASSERT(m_ref);
188     ASSERT(m_withArityCheck);
189 }
190 
191 JITCode::CodePtr&lt;JSEntryPtrTag&gt; DirectJITCode::addressForCall(ArityCheckMode arity)
192 {
193     switch (arity) {
194     case ArityCheckNotRequired:
195         RELEASE_ASSERT(m_ref);
196         return m_ref.code();
197     case MustCheckArity:
198         RELEASE_ASSERT(m_withArityCheck);
199         return m_withArityCheck;
200     }
201     RELEASE_ASSERT_NOT_REACHED();
202     return CodePtr&lt;JSEntryPtrTag&gt;();
203 }
204 
205 NativeJITCode::NativeJITCode(JITType jitType)
206     : JITCodeWithCodeRef(jitType)
207 {
208 }
209 
210 NativeJITCode::NativeJITCode(CodeRef&lt;JSEntryPtrTag&gt; ref, JITType jitType, Intrinsic intrinsic, JITCode::ShareAttribute shareAttribute)
211     : JITCodeWithCodeRef(ref, jitType, shareAttribute)
212 {
213     m_intrinsic = intrinsic;
214 }
215 
216 NativeJITCode::~NativeJITCode()
217 {
218 }
219 
220 JITCode::CodePtr&lt;JSEntryPtrTag&gt; NativeJITCode::addressForCall(ArityCheckMode arity)
221 {
222     RELEASE_ASSERT(m_ref);
223     switch (arity) {
224     case ArityCheckNotRequired:
225         return m_ref.code();
226     case MustCheckArity:
227         return m_ref.code();
228     }
229     RELEASE_ASSERT_NOT_REACHED();
230     return CodePtr&lt;JSEntryPtrTag&gt;();
231 }
232 
233 NativeDOMJITCode::NativeDOMJITCode(CodeRef&lt;JSEntryPtrTag&gt; ref, JITType type, Intrinsic intrinsic, const DOMJIT::Signature* signature)
234     : NativeJITCode(ref, type, intrinsic)
235     , m_signature(signature)
236 {
237 }
238 
239 #if ENABLE(JIT)
240 RegisterSet JITCode::liveRegistersToPreserveAtExceptionHandlingCallSite(CodeBlock*, CallSiteIndex)
241 {
242     return { };
243 }
244 #endif
245 
246 } // namespace JSC
247 
248 namespace WTF {
249 
250 void printInternal(PrintStream&amp; out, JSC::JITType type)
251 {
252     out.print(JSC::JITCode::typeName(type));
253 }
254 
255 } // namespace WTF
256 
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/filters/FEGaussianBlur.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FEFlood.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="FEGaussianBlur.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/filters/FEGaussianBlur.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
471 
472 IntSize FEGaussianBlur::calculateUnscaledKernelSize(FloatSize stdDeviation)
473 {
474     ASSERT(stdDeviation.width() &gt;= 0 &amp;&amp; stdDeviation.height() &gt;= 0);
475     IntSize kernelSize;
476 
477     if (stdDeviation.width())
478         kernelSize.setWidth(clampedToKernelSize(stdDeviation.width()));
479 
480     if (stdDeviation.height())
481         kernelSize.setHeight(clampedToKernelSize(stdDeviation.height()));
482 
483     return kernelSize;
484 }
485 
486 IntSize FEGaussianBlur::calculateKernelSize(const Filter&amp; filter, FloatSize stdDeviation)
487 {
488     return calculateUnscaledKernelSize(filter.scaledByFilterResolution(stdDeviation));
489 }
490 








491 void FEGaussianBlur::determineAbsolutePaintRect()
492 {
493     IntSize kernelSize = calculateKernelSize(filter(), { m_stdX, m_stdY });
494 
495     FloatRect absolutePaintRect = inputEffect(0)-&gt;absolutePaintRect();
496     // Edge modes other than &#39;none&#39; do not inflate the affected paint rect.
497     if (m_edgeMode != EDGEMODE_NONE) {
498         setAbsolutePaintRect(enclosingIntRect(absolutePaintRect));
499         return;
500     }
501 
502     // We take the half kernel size and multiply it with three, because we run box blur three times.
503     absolutePaintRect.inflateX(3 * kernelSize.width() * 0.5f);
504     absolutePaintRect.inflateY(3 * kernelSize.height() * 0.5f);
505 
506     if (clipsToBounds())
507         absolutePaintRect.intersect(maxEffectRect());
508     else
509         absolutePaintRect.unite(maxEffectRect());
510 
</pre>
<hr />
<pre>
522     setIsAlphaImage(in-&gt;isAlphaImage());
523 
524     IntRect effectDrawingRect = requestedRegionOfInputImageData(in-&gt;absolutePaintRect());
525     in-&gt;copyPremultipliedResult(*resultPixelArray, effectDrawingRect);
526 
527     if (!m_stdX &amp;&amp; !m_stdY)
528         return;
529 
530     IntSize kernelSize = calculateKernelSize(filter(), { m_stdX, m_stdY });
531     kernelSize.scale(filter().filterScale());
532 
533     IntSize paintSize = absolutePaintRect().size();
534     paintSize.scale(filter().filterScale());
535     auto tmpImageData = Uint8ClampedArray::tryCreateUninitialized((paintSize.area() * 4).unsafeGet());
536     if (!tmpImageData)
537         return;
538 
539     platformApply(*resultPixelArray, *tmpImageData, kernelSize.width(), kernelSize.height(), paintSize);
540 }
541 






542 TextStream&amp; FEGaussianBlur::externalRepresentation(TextStream&amp; ts, RepresentationType representation) const
543 {
544     ts &lt;&lt; indent &lt;&lt; &quot;[feGaussianBlur&quot;;
545     FilterEffect::externalRepresentation(ts, representation);
546     ts &lt;&lt; &quot; stdDeviation=\&quot;&quot; &lt;&lt; m_stdX &lt;&lt; &quot;, &quot; &lt;&lt; m_stdY &lt;&lt; &quot;\&quot;]\n&quot;;
547 
548     TextStream::IndentScope indentScope(ts);
549     inputEffect(0)-&gt;externalRepresentation(ts, representation);
550     return ts;
551 }
552 
553 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
471 
472 IntSize FEGaussianBlur::calculateUnscaledKernelSize(FloatSize stdDeviation)
473 {
474     ASSERT(stdDeviation.width() &gt;= 0 &amp;&amp; stdDeviation.height() &gt;= 0);
475     IntSize kernelSize;
476 
477     if (stdDeviation.width())
478         kernelSize.setWidth(clampedToKernelSize(stdDeviation.width()));
479 
480     if (stdDeviation.height())
481         kernelSize.setHeight(clampedToKernelSize(stdDeviation.height()));
482 
483     return kernelSize;
484 }
485 
486 IntSize FEGaussianBlur::calculateKernelSize(const Filter&amp; filter, FloatSize stdDeviation)
487 {
488     return calculateUnscaledKernelSize(filter.scaledByFilterResolution(stdDeviation));
489 }
490 
<span class="line-added">491 IntSize FEGaussianBlur::calculateOutsetSize(FloatSize stdDeviation)</span>
<span class="line-added">492 {</span>
<span class="line-added">493     auto kernelSize = calculateUnscaledKernelSize(stdDeviation);</span>
<span class="line-added">494 </span>
<span class="line-added">495     // We take the half kernel size and multiply it with three, because we run box blur three times.</span>
<span class="line-added">496     return { 3 * kernelSize.width() / 2, 3 * kernelSize.height() / 2 };</span>
<span class="line-added">497 }</span>
<span class="line-added">498 </span>
499 void FEGaussianBlur::determineAbsolutePaintRect()
500 {
501     IntSize kernelSize = calculateKernelSize(filter(), { m_stdX, m_stdY });
502 
503     FloatRect absolutePaintRect = inputEffect(0)-&gt;absolutePaintRect();
504     // Edge modes other than &#39;none&#39; do not inflate the affected paint rect.
505     if (m_edgeMode != EDGEMODE_NONE) {
506         setAbsolutePaintRect(enclosingIntRect(absolutePaintRect));
507         return;
508     }
509 
510     // We take the half kernel size and multiply it with three, because we run box blur three times.
511     absolutePaintRect.inflateX(3 * kernelSize.width() * 0.5f);
512     absolutePaintRect.inflateY(3 * kernelSize.height() * 0.5f);
513 
514     if (clipsToBounds())
515         absolutePaintRect.intersect(maxEffectRect());
516     else
517         absolutePaintRect.unite(maxEffectRect());
518 
</pre>
<hr />
<pre>
530     setIsAlphaImage(in-&gt;isAlphaImage());
531 
532     IntRect effectDrawingRect = requestedRegionOfInputImageData(in-&gt;absolutePaintRect());
533     in-&gt;copyPremultipliedResult(*resultPixelArray, effectDrawingRect);
534 
535     if (!m_stdX &amp;&amp; !m_stdY)
536         return;
537 
538     IntSize kernelSize = calculateKernelSize(filter(), { m_stdX, m_stdY });
539     kernelSize.scale(filter().filterScale());
540 
541     IntSize paintSize = absolutePaintRect().size();
542     paintSize.scale(filter().filterScale());
543     auto tmpImageData = Uint8ClampedArray::tryCreateUninitialized((paintSize.area() * 4).unsafeGet());
544     if (!tmpImageData)
545         return;
546 
547     platformApply(*resultPixelArray, *tmpImageData, kernelSize.width(), kernelSize.height(), paintSize);
548 }
549 
<span class="line-added">550 IntOutsets FEGaussianBlur::outsets() const</span>
<span class="line-added">551 {</span>
<span class="line-added">552     IntSize outsetSize = calculateOutsetSize({ m_stdX, m_stdY });</span>
<span class="line-added">553     return { outsetSize.height(), outsetSize.width(), outsetSize.height(), outsetSize.width() };</span>
<span class="line-added">554 }</span>
<span class="line-added">555 </span>
556 TextStream&amp; FEGaussianBlur::externalRepresentation(TextStream&amp; ts, RepresentationType representation) const
557 {
558     ts &lt;&lt; indent &lt;&lt; &quot;[feGaussianBlur&quot;;
559     FilterEffect::externalRepresentation(ts, representation);
560     ts &lt;&lt; &quot; stdDeviation=\&quot;&quot; &lt;&lt; m_stdX &lt;&lt; &quot;, &quot; &lt;&lt; m_stdY &lt;&lt; &quot;\&quot;]\n&quot;;
561 
562     TextStream::IndentScope indentScope(ts);
563     inputEffect(0)-&gt;externalRepresentation(ts, representation);
564     return ts;
565 }
566 
567 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="FEFlood.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="FEGaussianBlur.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
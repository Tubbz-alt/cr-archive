<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/ASTBuilder.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2010-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #include &quot;BuiltinNames.h&quot;
  29 #include &quot;BytecodeIntrinsicRegistry.h&quot;
  30 #include &quot;MathCommon.h&quot;
  31 #include &quot;NodeConstructors.h&quot;
  32 #include &quot;SyntaxChecker.h&quot;
  33 #include &quot;VariableEnvironment.h&quot;
  34 #include &lt;utility&gt;
  35 
  36 namespace JSC {
  37 
  38 class ASTBuilder {
  39     struct BinaryOpInfo {
  40         BinaryOpInfo() {}
  41         BinaryOpInfo(const JSTextPosition&amp; otherStart, const JSTextPosition&amp; otherDivot, const JSTextPosition&amp; otherEnd, bool rhsHasAssignment)
  42             : start(otherStart)
  43             , divot(otherDivot)
  44             , end(otherEnd)
  45             , hasAssignment(rhsHasAssignment)
  46         {
  47         }
  48         BinaryOpInfo(const BinaryOpInfo&amp; lhs, const BinaryOpInfo&amp; rhs)
  49             : start(lhs.start)
  50             , divot(rhs.start)
  51             , end(rhs.end)
  52             , hasAssignment(lhs.hasAssignment || rhs.hasAssignment)
  53         {
  54         }
  55         JSTextPosition start;
  56         JSTextPosition divot;
  57         JSTextPosition end;
  58         bool hasAssignment;
  59     };
  60 
  61 
  62     struct AssignmentInfo {
  63         AssignmentInfo() {}
  64         AssignmentInfo(ExpressionNode* node, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, int initAssignments, Operator op)
  65             : m_node(node)
  66             , m_start(start)
  67             , m_divot(divot)
  68             , m_initAssignments(initAssignments)
  69             , m_op(op)
  70         {
  71             ASSERT(m_divot.offset &gt;= m_divot.lineStartOffset);
  72             ASSERT(m_start.offset &gt;= m_start.lineStartOffset);
  73         }
  74         ExpressionNode* m_node;
  75         JSTextPosition m_start;
  76         JSTextPosition m_divot;
  77         int m_initAssignments;
  78         Operator m_op;
  79     };
  80 public:
  81     ASTBuilder(VM&amp; vm, ParserArena&amp; parserArena, SourceCode* sourceCode)
  82         : m_vm(vm)
  83         , m_parserArena(parserArena)
  84         , m_sourceCode(sourceCode)
  85         , m_evalCount(0)
  86     {
  87     }
  88 
  89     struct BinaryExprContext {
  90         BinaryExprContext(ASTBuilder&amp;) {}
  91     };
  92     struct UnaryExprContext {
  93         UnaryExprContext(ASTBuilder&amp;) {}
  94     };
  95 
  96     typedef ExpressionNode* Expression;
  97     typedef JSC::SourceElements* SourceElements;
  98     typedef ArgumentsNode* Arguments;
  99     typedef CommaNode* Comma;
 100     typedef PropertyNode* Property;
 101     typedef PropertyListNode* PropertyList;
 102     typedef ElementNode* ElementList;
 103     typedef ArgumentListNode* ArgumentsList;
 104     typedef TemplateExpressionListNode* TemplateExpressionList;
 105     typedef TemplateStringNode* TemplateString;
 106     typedef TemplateStringListNode* TemplateStringList;
 107     typedef TemplateLiteralNode* TemplateLiteral;
 108     typedef FunctionParameters* FormalParameterList;
 109     typedef FunctionMetadataNode* FunctionBody;
 110     typedef ClassExprNode* ClassExpression;
 111     typedef ModuleNameNode* ModuleName;
 112     typedef ImportSpecifierNode* ImportSpecifier;
 113     typedef ImportSpecifierListNode* ImportSpecifierList;
 114     typedef ExportSpecifierNode* ExportSpecifier;
 115     typedef ExportSpecifierListNode* ExportSpecifierList;
 116     typedef StatementNode* Statement;
 117     typedef ClauseListNode* ClauseList;
 118     typedef CaseClauseNode* Clause;
 119     typedef std::pair&lt;ExpressionNode*, BinaryOpInfo&gt; BinaryOperand;
 120     typedef DestructuringPatternNode* DestructuringPattern;
 121     typedef ArrayPatternNode* ArrayPattern;
 122     typedef ObjectPatternNode* ObjectPattern;
 123     typedef BindingNode* BindingPattern;
 124     typedef AssignmentElementNode* AssignmentElement;
 125     static constexpr bool CreatesAST = true;
 126     static constexpr bool NeedsFreeVariableInfo = true;
 127     static constexpr bool CanUseFunctionCache = true;
 128     static constexpr OptionSet&lt;LexerFlags&gt; DontBuildKeywords = { };
 129     static constexpr OptionSet&lt;LexerFlags&gt; DontBuildStrings = { };
 130 
 131     ExpressionNode* makeBinaryNode(const JSTokenLocation&amp;, int token, std::pair&lt;ExpressionNode*, BinaryOpInfo&gt;, std::pair&lt;ExpressionNode*, BinaryOpInfo&gt;);
 132     ExpressionNode* makeFunctionCallNode(const JSTokenLocation&amp;, ExpressionNode* func, bool previousBaseWasSuper, ArgumentsNode* args, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotEnd, size_t callOrApplyChildDepth, bool isOptionalCall);
 133 
 134     JSC::SourceElements* createSourceElements() { return new (m_parserArena) JSC::SourceElements(); }
 135 
 136     int features() const { return m_scope.m_features; }
 137     int numConstants() const { return m_scope.m_numConstants; }
 138 
 139     ExpressionNode* makeAssignNode(const JSTokenLocation&amp;, ExpressionNode* left, Operator, ExpressionNode* right, bool leftHasAssignments, bool rightHasAssignments, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 140     ExpressionNode* makePrefixNode(const JSTokenLocation&amp;, ExpressionNode*, Operator, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 141     ExpressionNode* makePostfixNode(const JSTokenLocation&amp;, ExpressionNode*, Operator, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 142     ExpressionNode* makeTypeOfNode(const JSTokenLocation&amp;, ExpressionNode*);
 143     ExpressionNode* makeDeleteNode(const JSTokenLocation&amp;, ExpressionNode*, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 144     ExpressionNode* makeNegateNode(const JSTokenLocation&amp;, ExpressionNode*);
 145     ExpressionNode* makeBitwiseNotNode(const JSTokenLocation&amp;, ExpressionNode*);
 146     ExpressionNode* makePowNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 147     ExpressionNode* makeMultNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 148     ExpressionNode* makeDivNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 149     ExpressionNode* makeModNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 150     ExpressionNode* makeAddNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 151     ExpressionNode* makeSubNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 152     ExpressionNode* makeBitXOrNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 153     ExpressionNode* makeBitAndNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 154     ExpressionNode* makeBitOrNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 155     ExpressionNode* makeCoalesceNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right);
 156     ExpressionNode* makeLeftShiftNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 157     ExpressionNode* makeRightShiftNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 158     ExpressionNode* makeURightShiftNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 159 
 160     ExpressionNode* createLogicalNot(const JSTokenLocation&amp; location, ExpressionNode* expr)
 161     {
 162         if (expr-&gt;isNumber())
 163             return createBoolean(location, isZeroOrUnordered(static_cast&lt;NumberNode*&gt;(expr)-&gt;value()));
 164 
 165         return new (m_parserArena) LogicalNotNode(location, expr);
 166     }
 167     ExpressionNode* createUnaryPlus(const JSTokenLocation&amp; location, ExpressionNode* expr) { return new (m_parserArena) UnaryPlusNode(location, expr); }
 168     ExpressionNode* createVoid(const JSTokenLocation&amp; location, ExpressionNode* expr)
 169     {
 170         incConstants();
 171         return new (m_parserArena) VoidNode(location, expr);
 172     }
 173     ExpressionNode* createThisExpr(const JSTokenLocation&amp; location)
 174     {
 175         usesThis();
 176         return new (m_parserArena) ThisNode(location);
 177     }
 178     ExpressionNode* createSuperExpr(const JSTokenLocation&amp; location)
 179     {
 180         return new (m_parserArena) SuperNode(location);
 181     }
 182     ExpressionNode* createImportExpr(const JSTokenLocation&amp; location, ExpressionNode* expr, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 183     {
 184         auto* node = new (m_parserArena) ImportNode(location, expr);
 185         setExceptionLocation(node, start, divot, end);
 186         return node;
 187     }
 188     ExpressionNode* createNewTargetExpr(const JSTokenLocation location)
 189     {
 190         usesNewTarget();
 191         return new (m_parserArena) NewTargetNode(location);
 192     }
 193     ExpressionNode* createImportMetaExpr(const JSTokenLocation&amp; location, ExpressionNode* expr) { return new (m_parserArena) ImportMetaNode(location, expr); }
 194     bool isMetaProperty(ExpressionNode* node) { return node-&gt;isMetaProperty(); }
 195     bool isNewTarget(ExpressionNode* node) { return node-&gt;isNewTarget(); }
 196     bool isImportMeta(ExpressionNode* node) { return node-&gt;isImportMeta(); }
 197     ExpressionNode* createResolve(const JSTokenLocation&amp; location, const Identifier&amp; ident, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 198     {
 199         if (m_vm.propertyNames-&gt;arguments == ident)
 200             usesArguments();
 201 
 202         if (ident.isSymbol()) {
 203             auto entry = m_vm.bytecodeIntrinsicRegistry().lookup(ident);
 204             if (entry)
 205                 return new (m_parserArena) BytecodeIntrinsicNode(BytecodeIntrinsicNode::Type::Constant, location, entry.value(), ident, nullptr, start, start, end);
 206         }
 207 
 208         return new (m_parserArena) ResolveNode(location, ident, start);
 209     }
 210     ExpressionNode* createObjectLiteral(const JSTokenLocation&amp; location) { return new (m_parserArena) ObjectLiteralNode(location); }
 211     ExpressionNode* createObjectLiteral(const JSTokenLocation&amp; location, PropertyListNode* properties) { return new (m_parserArena) ObjectLiteralNode(location, properties); }
 212 
 213     ExpressionNode* createArray(const JSTokenLocation&amp; location, int elisions)
 214     {
 215         if (elisions)
 216             incConstants();
 217         return new (m_parserArena) ArrayNode(location, elisions);
 218     }
 219 
 220     ExpressionNode* createArray(const JSTokenLocation&amp; location, ElementNode* elems) { return new (m_parserArena) ArrayNode(location, elems); }
 221     ExpressionNode* createArray(const JSTokenLocation&amp; location, int elisions, ElementNode* elems)
 222     {
 223         if (elisions)
 224             incConstants();
 225         return new (m_parserArena) ArrayNode(location, elisions, elems);
 226     }
 227     ExpressionNode* createDoubleExpr(const JSTokenLocation&amp; location, double d)
 228     {
 229         incConstants();
 230         return new (m_parserArena) DoubleNode(location, d);
 231     }
 232     ExpressionNode* createIntegerExpr(const JSTokenLocation&amp; location, double d)
 233     {
 234         incConstants();
 235         return new (m_parserArena) IntegerNode(location, d);
 236     }
 237 
 238     ExpressionNode* createBigInt(const JSTokenLocation&amp; location, const Identifier* bigInt, uint8_t radix)
 239     {
 240         incConstants();
 241         return new (m_parserArena) BigIntNode(location, *bigInt, radix);
 242     }
 243 
 244     ExpressionNode* createString(const JSTokenLocation&amp; location, const Identifier* string)
 245     {
 246         ASSERT(string);
 247         incConstants();
 248         return new (m_parserArena) StringNode(location, *string);
 249     }
 250 
 251     ExpressionNode* createBoolean(const JSTokenLocation&amp; location, bool b)
 252     {
 253         incConstants();
 254         return new (m_parserArena) BooleanNode(location, b);
 255     }
 256 
 257     ExpressionNode* createNull(const JSTokenLocation&amp; location)
 258     {
 259         incConstants();
 260         return new (m_parserArena) NullNode(location);
 261     }
 262 
 263     ExpressionNode* createBracketAccess(const JSTokenLocation&amp; location, ExpressionNode* base, ExpressionNode* property, bool propertyHasAssignments, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 264     {
 265         if (base-&gt;isSuperNode())
 266             usesSuperProperty();
 267 
 268         BracketAccessorNode* node = new (m_parserArena) BracketAccessorNode(location, base, property, propertyHasAssignments);
 269         setExceptionLocation(node, start, divot, end);
 270         return node;
 271     }
 272 
 273     ExpressionNode* createDotAccess(const JSTokenLocation&amp; location, ExpressionNode* base, const Identifier* property, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 274     {
 275         if (base-&gt;isSuperNode())
 276             usesSuperProperty();
 277 
 278         DotAccessorNode* node = new (m_parserArena) DotAccessorNode(location, base, *property);
 279         setExceptionLocation(node, start, divot, end);
 280         return node;
 281     }
 282 
 283     ExpressionNode* createSpreadExpression(const JSTokenLocation&amp; location, ExpressionNode* expression, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 284     {
 285         auto node = new (m_parserArena) SpreadExpressionNode(location, expression);
 286         setExceptionLocation(node, start, divot, end);
 287         return node;
 288     }
 289 
 290     ExpressionNode* createObjectSpreadExpression(const JSTokenLocation&amp; location, ExpressionNode* expression, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 291     {
 292         auto node = new (m_parserArena) ObjectSpreadExpressionNode(location, expression);
 293         setExceptionLocation(node, start, divot, end);
 294         return node;
 295     }
 296 
 297     TemplateStringNode* createTemplateString(const JSTokenLocation&amp; location, const Identifier* cooked, const Identifier* raw)
 298     {
 299         return new (m_parserArena) TemplateStringNode(location, cooked, raw);
 300     }
 301 
 302     TemplateStringListNode* createTemplateStringList(TemplateStringNode* templateString)
 303     {
 304         return new (m_parserArena) TemplateStringListNode(templateString);
 305     }
 306 
 307     TemplateStringListNode* createTemplateStringList(TemplateStringListNode* templateStringList, TemplateStringNode* templateString)
 308     {
 309         return new (m_parserArena) TemplateStringListNode(templateStringList, templateString);
 310     }
 311 
 312     TemplateExpressionListNode* createTemplateExpressionList(ExpressionNode* expression)
 313     {
 314         return new (m_parserArena) TemplateExpressionListNode(expression);
 315     }
 316 
 317     TemplateExpressionListNode* createTemplateExpressionList(TemplateExpressionListNode* templateExpressionListNode, ExpressionNode* expression)
 318     {
 319         return new (m_parserArena) TemplateExpressionListNode(templateExpressionListNode, expression);
 320     }
 321 
 322     TemplateLiteralNode* createTemplateLiteral(const JSTokenLocation&amp; location, TemplateStringListNode* templateStringList)
 323     {
 324         return new (m_parserArena) TemplateLiteralNode(location, templateStringList);
 325     }
 326 
 327     TemplateLiteralNode* createTemplateLiteral(const JSTokenLocation&amp; location, TemplateStringListNode* templateStringList, TemplateExpressionListNode* templateExpressionList)
 328     {
 329         return new (m_parserArena) TemplateLiteralNode(location, templateStringList, templateExpressionList);
 330     }
 331 
 332     ExpressionNode* createTaggedTemplate(const JSTokenLocation&amp; location, ExpressionNode* base, TemplateLiteralNode* templateLiteral, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 333     {
 334         auto node = new (m_parserArena) TaggedTemplateNode(location, base, templateLiteral);
 335         setExceptionLocation(node, start, divot, end);
 336         setEndOffset(node, end.offset);
 337         return node;
 338     }
 339 
 340     ExpressionNode* createRegExp(const JSTokenLocation&amp; location, const Identifier&amp; pattern, const Identifier&amp; flags, const JSTextPosition&amp; start)
 341     {
 342         if (Yarr::hasError(Yarr::checkSyntax(pattern.string(), flags.string())))
 343             return 0;
 344         RegExpNode* node = new (m_parserArena) RegExpNode(location, pattern, flags);
 345         int size = pattern.length() + 2; // + 2 for the two /&#39;s
 346         JSTextPosition end = start + size;
 347         setExceptionLocation(node, start, end, end);
 348         return node;
 349     }
 350 
 351     ExpressionNode* createNewExpr(const JSTokenLocation&amp; location, ExpressionNode* expr, ArgumentsNode* arguments, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 352     {
 353         NewExprNode* node = new (m_parserArena) NewExprNode(location, expr, arguments);
 354         setExceptionLocation(node, start, divot, end);
 355         return node;
 356     }
 357 
 358     ExpressionNode* createNewExpr(const JSTokenLocation&amp; location, ExpressionNode* expr, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 359     {
 360         NewExprNode* node = new (m_parserArena) NewExprNode(location, expr);
 361         setExceptionLocation(node, start, end, end);
 362         return node;
 363     }
 364 
 365     ExpressionNode* createOptionalChain(const JSTokenLocation&amp; location, ExpressionNode* base, ExpressionNode* expr, bool isOutermost)
 366     {
 367         base-&gt;setIsOptionalChainBase();
 368         return new (m_parserArena) OptionalChainNode(location, expr, isOutermost);
 369     }
 370 
 371     ExpressionNode* createConditionalExpr(const JSTokenLocation&amp; location, ExpressionNode* condition, ExpressionNode* lhs, ExpressionNode* rhs)
 372     {
 373         return new (m_parserArena) ConditionalNode(location, condition, lhs, rhs);
 374     }
 375 
 376     ExpressionNode* createAssignResolve(const JSTokenLocation&amp; location, const Identifier&amp; ident, ExpressionNode* rhs, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end, AssignmentContext assignmentContext)
 377     {
 378         if (rhs-&gt;isBaseFuncExprNode()) {
 379             auto metadata = static_cast&lt;BaseFuncExprNode*&gt;(rhs)-&gt;metadata();
 380             metadata-&gt;setEcmaName(ident);
 381         } else if (rhs-&gt;isClassExprNode())
 382             static_cast&lt;ClassExprNode*&gt;(rhs)-&gt;setEcmaName(ident);
 383         AssignResolveNode* node = new (m_parserArena) AssignResolveNode(location, ident, rhs, assignmentContext);
 384         setExceptionLocation(node, start, divot, end);
 385         return node;
 386     }
 387 
 388     YieldExprNode* createYield(const JSTokenLocation&amp; location)
 389     {
 390         return new (m_parserArena) YieldExprNode(location, nullptr, /* delegate */ false);
 391     }
 392 
 393     YieldExprNode* createYield(const JSTokenLocation&amp; location, ExpressionNode* argument, bool delegate, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 394     {
 395         YieldExprNode* node = new (m_parserArena) YieldExprNode(location, argument, delegate);
 396         setExceptionLocation(node, start, divot, end);
 397         return node;
 398     }
 399 
 400     AwaitExprNode* createAwait(const JSTokenLocation&amp; location, ExpressionNode* argument, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 401     {
 402         ASSERT(argument);
 403         AwaitExprNode* node = new (m_parserArena) AwaitExprNode(location, argument);
 404         setExceptionLocation(node, start, divot, end);
 405         return node;
 406     }
 407 
 408     DefineFieldNode* createDefineField(const JSTokenLocation&amp; location, const Identifier* ident, ExpressionNode* initializer, DefineFieldNode::Type type)
 409     {
 410         return new (m_parserArena) DefineFieldNode(location, ident, initializer, type);
 411     }
 412 
 413     ClassExprNode* createClassExpr(const JSTokenLocation&amp; location, const ParserClassInfo&lt;ASTBuilder&gt;&amp; classInfo, VariableEnvironment&amp; classEnvironment, ExpressionNode* constructor,
 414         ExpressionNode* parentClass, PropertyListNode* classElements)
 415     {
 416         SourceCode source = m_sourceCode-&gt;subExpression(classInfo.startOffset, classInfo.endOffset, classInfo.startLine, classInfo.startColumn);
 417         return new (m_parserArena) ClassExprNode(location, *classInfo.className, source, classEnvironment, constructor, parentClass, classElements);
 418     }
 419 
 420     ExpressionNode* createFunctionExpr(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo)
 421     {
 422         FuncExprNode* result = new (m_parserArena) FuncExprNode(location, *functionInfo.name, functionInfo.body,
 423             m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn));
 424         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 425         return result;
 426     }
 427 
 428     ExpressionNode* createGeneratorFunctionBody(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, const Identifier&amp; name)
 429     {
 430         FuncExprNode* result = static_cast&lt;FuncExprNode*&gt;(createFunctionExpr(location, functionInfo));
 431         if (!name.isNull())
 432             result-&gt;metadata()-&gt;setEcmaName(name);
 433         return result;
 434     }
 435 
 436     ExpressionNode* createAsyncFunctionBody(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, SourceParseMode parseMode)
 437     {
 438         if (parseMode == SourceParseMode::AsyncArrowFunctionBodyMode) {
 439             SourceCode source = m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.body-&gt;isArrowFunctionBodyExpression() ? functionInfo.endOffset - 1 : functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn);
 440             FuncExprNode* result = new (m_parserArena) FuncExprNode(location, *functionInfo.name, functionInfo.body, source);
 441             functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 442             return result;
 443         }
 444         return createFunctionExpr(location, functionInfo);
 445     }
 446 
 447     ExpressionNode* createMethodDefinition(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo)
 448     {
 449         MethodDefinitionNode* result = new (m_parserArena) MethodDefinitionNode(location, *functionInfo.name, functionInfo.body,
 450             m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn));
 451         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 452         return result;
 453     }
 454 
 455     FunctionMetadataNode* createFunctionMetadata(
 456         const JSTokenLocation&amp; startLocation, const JSTokenLocation&amp; endLocation,
 457         unsigned startColumn, unsigned endColumn, int functionKeywordStart,
 458         int functionNameStart, int parametersStart, bool inStrictContext,
 459         ConstructorKind constructorKind, SuperBinding superBinding,
 460         unsigned parameterCount,
 461         SourceParseMode mode, bool isArrowFunctionBodyExpression)
 462     {
 463         return new (m_parserArena) FunctionMetadataNode(
 464             m_parserArena, startLocation, endLocation, startColumn, endColumn,
 465             functionKeywordStart, functionNameStart, parametersStart,
 466             inStrictContext, constructorKind, superBinding,
 467             parameterCount, mode, isArrowFunctionBodyExpression);
 468     }
 469 
 470     ExpressionNode* createArrowFunctionExpr(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo)
 471     {
 472         usesArrowFunction();
 473         SourceCode source = m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.body-&gt;isArrowFunctionBodyExpression() ? functionInfo.endOffset - 1 : functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn);
 474         ArrowFuncExprNode* result = new (m_parserArena) ArrowFuncExprNode(location, *functionInfo.name, functionInfo.body, source);
 475         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 476         return result;
 477     }
 478 
 479     ArgumentsNode* createArguments() { return new (m_parserArena) ArgumentsNode(); }
 480     ArgumentsNode* createArguments(ArgumentListNode* args) { return new (m_parserArena) ArgumentsNode(args); }
 481     ArgumentListNode* createArgumentsList(const JSTokenLocation&amp; location, ExpressionNode* arg) { return new (m_parserArena) ArgumentListNode(location, arg); }
 482     ArgumentListNode* createArgumentsList(const JSTokenLocation&amp; location, ArgumentListNode* args, ExpressionNode* arg) { return new (m_parserArena) ArgumentListNode(location, args, arg); }
 483 
 484     NEVER_INLINE PropertyNode* createGetterOrSetterProperty(const JSTokenLocation&amp; location, PropertyNode::Type type, bool,
 485         const Identifier* name, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, ClassElementTag tag)
 486     {
 487         ASSERT(name);
 488         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 489         functionInfo.body-&gt;setEcmaName(*name);
 490         SourceCode source = m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn);
 491         MethodDefinitionNode* methodDef = new (m_parserArena) MethodDefinitionNode(location, m_vm.propertyNames-&gt;nullIdentifier, functionInfo.body, source);
 492         return new (m_parserArena) PropertyNode(*name, methodDef, type, PropertyNode::Unknown, SuperBinding::Needed, tag);
 493     }
 494 
 495     NEVER_INLINE PropertyNode* createGetterOrSetterProperty(const JSTokenLocation&amp; location, PropertyNode::Type type, bool,
 496         ExpressionNode* name, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, ClassElementTag tag)
 497     {
 498         ASSERT(name);
 499         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 500         SourceCode source = m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn);
 501         MethodDefinitionNode* methodDef = new (m_parserArena) MethodDefinitionNode(location, m_vm.propertyNames-&gt;nullIdentifier, functionInfo.body, source);
 502         return new (m_parserArena) PropertyNode(name, methodDef, type, PropertyNode::Unknown, SuperBinding::Needed, tag);
 503     }
 504 
 505     NEVER_INLINE PropertyNode* createGetterOrSetterProperty(VM&amp; vm, ParserArena&amp; parserArena, const JSTokenLocation&amp; location, PropertyNode::Type type, bool,
 506         double name, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, ClassElementTag tag)
 507     {
 508         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 509         const Identifier&amp; ident = parserArena.identifierArena().makeNumericIdentifier(vm, name);
 510         SourceCode source = m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn);
 511         MethodDefinitionNode* methodDef = new (m_parserArena) MethodDefinitionNode(location, vm.propertyNames-&gt;nullIdentifier, functionInfo.body, source);
 512         return new (m_parserArena) PropertyNode(ident, methodDef, type, PropertyNode::Unknown, SuperBinding::Needed, tag);
 513     }
 514 
 515     PropertyNode* createProperty(const Identifier* propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, InferName inferName, ClassElementTag tag)
 516     {
 517         if (inferName == InferName::Allowed) {
 518             if (node-&gt;isBaseFuncExprNode()) {
 519                 auto metadata = static_cast&lt;BaseFuncExprNode*&gt;(node)-&gt;metadata();
 520                 metadata-&gt;setEcmaName(*propertyName);
 521             } else if (node-&gt;isClassExprNode())
 522                 static_cast&lt;ClassExprNode*&gt;(node)-&gt;setEcmaName(*propertyName);
 523         }
 524         return new (m_parserArena) PropertyNode(*propertyName, node, type, putType, superBinding, tag);
 525     }
 526     PropertyNode* createProperty(ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag)
 527     {
 528         return new (m_parserArena) PropertyNode(node, type, putType, superBinding, tag);
 529     }
 530     PropertyNode* createProperty(VM&amp; vm, ParserArena&amp; parserArena, double propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag)
 531     {
 532         return new (m_parserArena) PropertyNode(parserArena.identifierArena().makeNumericIdentifier(vm, propertyName), node, type, putType, superBinding, tag);
 533     }
 534     PropertyNode* createProperty(ExpressionNode* propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag) { return new (m_parserArena) PropertyNode(propertyName, node, type, putType, superBinding, tag); }
 535     PropertyNode* createProperty(const Identifier* identifier, ExpressionNode* propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag) { return new (m_parserArena) PropertyNode(*identifier, propertyName, node, type, putType, superBinding, tag); }
 536     PropertyListNode* createPropertyList(const JSTokenLocation&amp; location, PropertyNode* property) { return new (m_parserArena) PropertyListNode(location, property); }
 537     PropertyListNode* createPropertyList(const JSTokenLocation&amp; location, PropertyNode* property, PropertyListNode* tail) { return new (m_parserArena) PropertyListNode(location, property, tail); }
 538 
 539     ElementNode* createElementList(int elisions, ExpressionNode* expr) { return new (m_parserArena) ElementNode(elisions, expr); }
 540     ElementNode* createElementList(ElementNode* elems, int elisions, ExpressionNode* expr) { return new (m_parserArena) ElementNode(elems, elisions, expr); }
 541     ElementNode* createElementList(ArgumentListNode* elems)
 542     {
 543         ElementNode* head = new (m_parserArena) ElementNode(0, elems-&gt;m_expr);
 544         ElementNode* tail = head;
 545         elems = elems-&gt;m_next;
 546         while (elems) {
 547             tail = new (m_parserArena) ElementNode(tail, 0, elems-&gt;m_expr);
 548             elems = elems-&gt;m_next;
 549         }
 550         return head;
 551     }
 552 
 553     FormalParameterList createFormalParameterList() { return new (m_parserArena) FunctionParameters(); }
 554     void appendParameter(FormalParameterList list, DestructuringPattern pattern, ExpressionNode* defaultValue)
 555     {
 556         list-&gt;append(pattern, defaultValue);
 557         tryInferNameInPattern(pattern, defaultValue);
 558     }
 559 
 560     CaseClauseNode* createClause(ExpressionNode* expr, JSC::SourceElements* statements) { return new (m_parserArena) CaseClauseNode(expr, statements); }
 561     ClauseListNode* createClauseList(CaseClauseNode* clause) { return new (m_parserArena) ClauseListNode(clause); }
 562     ClauseListNode* createClauseList(ClauseListNode* tail, CaseClauseNode* clause) { return new (m_parserArena) ClauseListNode(tail, clause); }
 563 
 564     StatementNode* createFuncDeclStatement(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo)
 565     {
 566         FuncDeclNode* decl = new (m_parserArena) FuncDeclNode(location, *functionInfo.name, functionInfo.body,
 567             m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn));
 568         if (*functionInfo.name == m_vm.propertyNames-&gt;arguments)
 569             usesArguments();
 570         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 571         return decl;
 572     }
 573 
 574     StatementNode* createClassDeclStatement(const JSTokenLocation&amp; location, ClassExprNode* classExpression,
 575         const JSTextPosition&amp; classStart, const JSTextPosition&amp; classEnd, unsigned startLine, unsigned endLine)
 576     {
 577         ExpressionNode* assign = createAssignResolve(location, classExpression-&gt;name(), classExpression, classStart, classStart + 1, classEnd, AssignmentContext::DeclarationStatement);
 578         ClassDeclNode* decl = new (m_parserArena) ClassDeclNode(location, assign);
 579         decl-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 580         return decl;
 581     }
 582 
 583     StatementNode* createBlockStatement(const JSTokenLocation&amp; location, JSC::SourceElements* elements, int startLine, int endLine, VariableEnvironment&amp; lexicalVariables, DeclarationStacks::FunctionStack&amp;&amp; functionStack)
 584     {
 585         BlockNode* block = new (m_parserArena) BlockNode(location, elements, lexicalVariables, WTFMove(functionStack));
 586         block-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 587         return block;
 588     }
 589 
 590     StatementNode* createExprStatement(const JSTokenLocation&amp; location, ExpressionNode* expr, const JSTextPosition&amp; start, int end)
 591     {
 592         ExprStatementNode* result = new (m_parserArena) ExprStatementNode(location, expr);
 593         result-&gt;setLoc(start.line, end, start.offset, start.lineStartOffset);
 594         return result;
 595     }
 596 
 597     StatementNode* createIfStatement(const JSTokenLocation&amp; location, ExpressionNode* condition, StatementNode* trueBlock, StatementNode* falseBlock, int start, int end)
 598     {
 599         IfElseNode* result = new (m_parserArena) IfElseNode(location, condition, trueBlock, falseBlock);
 600         result-&gt;setLoc(start, end, location.startOffset, location.lineStartOffset);
 601         return result;
 602     }
 603 
 604     StatementNode* createForLoop(const JSTokenLocation&amp; location, ExpressionNode* initializer, ExpressionNode* condition, ExpressionNode* iter, StatementNode* statements, int start, int end, VariableEnvironment&amp; lexicalVariables)
 605     {
 606         ForNode* result = new (m_parserArena) ForNode(location, initializer, condition, iter, statements, lexicalVariables);
 607         result-&gt;setLoc(start, end, location.startOffset, location.lineStartOffset);
 608         return result;
 609     }
 610 
 611     StatementNode* createForInLoop(const JSTokenLocation&amp; location, ExpressionNode* lhs, ExpressionNode* iter, StatementNode* statements, const JSTokenLocation&amp;, const JSTextPosition&amp; eStart, const JSTextPosition&amp; eDivot, const JSTextPosition&amp; eEnd, int start, int end, VariableEnvironment&amp; lexicalVariables)
 612     {
 613         ForInNode* result = new (m_parserArena) ForInNode(location, lhs, iter, statements, lexicalVariables);
 614         result-&gt;setLoc(start, end, location.startOffset, location.lineStartOffset);
 615         setExceptionLocation(result, eStart, eDivot, eEnd);
 616         return result;
 617     }
 618 
 619     StatementNode* createForInLoop(const JSTokenLocation&amp; location, DestructuringPatternNode* pattern, ExpressionNode* iter, StatementNode* statements, const JSTokenLocation&amp; declLocation, const JSTextPosition&amp; eStart, const JSTextPosition&amp; eDivot, const JSTextPosition&amp; eEnd, int start, int end, VariableEnvironment&amp; lexicalVariables)
 620     {
 621         auto lexpr = new (m_parserArena) DestructuringAssignmentNode(declLocation, pattern, nullptr);
 622         return createForInLoop(location, lexpr, iter, statements, declLocation, eStart, eDivot, eEnd, start, end, lexicalVariables);
 623     }
 624 
 625     StatementNode* createForOfLoop(bool isForAwait, const JSTokenLocation&amp; location, ExpressionNode* lhs, ExpressionNode* iter, StatementNode* statements, const JSTokenLocation&amp;, const JSTextPosition&amp; eStart, const JSTextPosition&amp; eDivot, const JSTextPosition&amp; eEnd, int start, int end, VariableEnvironment&amp; lexicalVariables)
 626     {
 627         ForOfNode* result = new (m_parserArena) ForOfNode(isForAwait, location, lhs, iter, statements, lexicalVariables);
 628         result-&gt;setLoc(start, end, location.startOffset, location.lineStartOffset);
 629         setExceptionLocation(result, eStart, eDivot, eEnd);
 630         return result;
 631     }
 632 
 633     StatementNode* createForOfLoop(bool isForAwait, const JSTokenLocation&amp; location, DestructuringPatternNode* pattern, ExpressionNode* iter, StatementNode* statements, const JSTokenLocation&amp; declLocation, const JSTextPosition&amp; eStart, const JSTextPosition&amp; eDivot, const JSTextPosition&amp; eEnd, int start, int end, VariableEnvironment&amp; lexicalVariables)
 634     {
 635         auto lexpr = new (m_parserArena) DestructuringAssignmentNode(declLocation, pattern, nullptr);
 636         return createForOfLoop(isForAwait, location, lexpr, iter, statements, declLocation, eStart, eDivot, eEnd, start, end, lexicalVariables);
 637     }
 638 
 639     bool isBindingNode(const DestructuringPattern&amp; pattern)
 640     {
 641         return pattern-&gt;isBindingNode();
 642     }
 643 
 644     bool isLocation(const Expression&amp; node)
 645     {
 646         return node-&gt;isLocation();
 647     }
 648 
 649     bool isAssignmentLocation(const Expression&amp; node)
 650     {
 651         return node-&gt;isAssignmentLocation();
 652     }
 653 
 654     bool isObjectLiteral(const Expression&amp; node)
 655     {
 656         return node-&gt;isObjectLiteral();
 657     }
 658 
 659     bool isArrayLiteral(const Expression&amp; node)
 660     {
 661         return node-&gt;isArrayLiteral();
 662     }
 663 
 664     bool isObjectOrArrayLiteral(const Expression&amp; node)
 665     {
 666         return isObjectLiteral(node) || isArrayLiteral(node);
 667     }
 668 
 669     bool isFunctionCall(const Expression&amp; node)
 670     {
 671         return node-&gt;isFunctionCall();
 672     }
 673 
 674     bool shouldSkipPauseLocation(StatementNode* statement) const
 675     {
 676         return !statement || statement-&gt;isLabel();
 677     }
 678 
 679     StatementNode* createEmptyStatement(const JSTokenLocation&amp; location) { return new (m_parserArena) EmptyStatementNode(location); }
 680 
 681     StatementNode* createDeclarationStatement(const JSTokenLocation&amp; location, ExpressionNode* expr, int start, int end)
 682     {
 683         StatementNode* result;
 684         result = new (m_parserArena) DeclarationStatement(location, expr);
 685         result-&gt;setLoc(start, end, location.startOffset, location.lineStartOffset);
 686         return result;
 687     }
 688 
 689     ExpressionNode* createEmptyVarExpression(const JSTokenLocation&amp; location, const Identifier&amp; identifier)
 690     {
 691         return new (m_parserArena) EmptyVarExpression(location, identifier);
 692     }
 693 
 694     ExpressionNode* createEmptyLetExpression(const JSTokenLocation&amp; location, const Identifier&amp; identifier)
 695     {
 696         return new (m_parserArena) EmptyLetExpression(location, identifier);
 697     }
 698 
 699     StatementNode* createReturnStatement(const JSTokenLocation&amp; location, ExpressionNode* expression, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 700     {
 701         ReturnNode* result = new (m_parserArena) ReturnNode(location, expression);
 702         setExceptionLocation(result, start, end, end);
 703         result-&gt;setLoc(start.line, end.line, start.offset, start.lineStartOffset);
 704         return result;
 705     }
 706 
 707     StatementNode* createBreakStatement(const JSTokenLocation&amp; location, const Identifier* ident, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 708     {
 709         BreakNode* result = new (m_parserArena) BreakNode(location, *ident);
 710         setExceptionLocation(result, start, end, end);
 711         result-&gt;setLoc(start.line, end.line, start.offset, start.lineStartOffset);
 712         return result;
 713     }
 714 
 715     StatementNode* createContinueStatement(const JSTokenLocation&amp; location, const Identifier* ident, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 716     {
 717         ContinueNode* result = new (m_parserArena) ContinueNode(location, *ident);
 718         setExceptionLocation(result, start, end, end);
 719         result-&gt;setLoc(start.line, end.line, start.offset, start.lineStartOffset);
 720         return result;
 721     }
 722 
 723     StatementNode* createTryStatement(const JSTokenLocation&amp; location, StatementNode* tryBlock, DestructuringPatternNode* catchPattern, StatementNode* catchBlock, StatementNode* finallyBlock, int startLine, int endLine, VariableEnvironment&amp; catchEnvironment)
 724     {
 725         TryNode* result = new (m_parserArena) TryNode(location, tryBlock, catchPattern, catchBlock, catchEnvironment, finallyBlock);
 726         result-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 727         return result;
 728     }
 729 
 730     StatementNode* createSwitchStatement(const JSTokenLocation&amp; location, ExpressionNode* expr, ClauseListNode* firstClauses, CaseClauseNode* defaultClause, ClauseListNode* secondClauses, int startLine, int endLine, VariableEnvironment&amp; lexicalVariables, DeclarationStacks::FunctionStack&amp;&amp; functionStack)
 731     {
 732         CaseBlockNode* cases = new (m_parserArena) CaseBlockNode(firstClauses, defaultClause, secondClauses);
 733         SwitchNode* result = new (m_parserArena) SwitchNode(location, expr, cases, lexicalVariables, WTFMove(functionStack));
 734         result-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 735         return result;
 736     }
 737 
 738     StatementNode* createWhileStatement(const JSTokenLocation&amp; location, ExpressionNode* expr, StatementNode* statement, int startLine, int endLine)
 739     {
 740         WhileNode* result = new (m_parserArena) WhileNode(location, expr, statement);
 741         result-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 742         return result;
 743     }
 744 
 745     StatementNode* createDoWhileStatement(const JSTokenLocation&amp; location, StatementNode* statement, ExpressionNode* expr, int startLine, int endLine)
 746     {
 747         DoWhileNode* result = new (m_parserArena) DoWhileNode(location, statement, expr);
 748         result-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 749         return result;
 750     }
 751 
 752     StatementNode* createLabelStatement(const JSTokenLocation&amp; location, const Identifier* ident, StatementNode* statement, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 753     {
 754         LabelNode* result = new (m_parserArena) LabelNode(location, *ident, statement);
 755         setExceptionLocation(result, start, end, end);
 756         return result;
 757     }
 758 
 759     StatementNode* createWithStatement(const JSTokenLocation&amp; location, ExpressionNode* expr, StatementNode* statement, unsigned start, const JSTextPosition&amp; end, unsigned startLine, unsigned endLine)
 760     {
 761         usesWith();
 762         WithNode* result = new (m_parserArena) WithNode(location, expr, statement, end, end - start);
 763         result-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 764         return result;
 765     }
 766 
 767     StatementNode* createThrowStatement(const JSTokenLocation&amp; location, ExpressionNode* expr, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 768     {
 769         ThrowNode* result = new (m_parserArena) ThrowNode(location, expr);
 770         result-&gt;setLoc(start.line, end.line, start.offset, start.lineStartOffset);
 771         setExceptionLocation(result, start, end, end);
 772         return result;
 773     }
 774 
 775     StatementNode* createDebugger(const JSTokenLocation&amp; location, int startLine, int endLine)
 776     {
 777         DebuggerStatementNode* result = new (m_parserArena) DebuggerStatementNode(location);
 778         result-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 779         return result;
 780     }
 781 
 782     ModuleNameNode* createModuleName(const JSTokenLocation&amp; location, const Identifier&amp; moduleName)
 783     {
 784         return new (m_parserArena) ModuleNameNode(location, moduleName);
 785     }
 786 
 787     ImportSpecifierNode* createImportSpecifier(const JSTokenLocation&amp; location, const Identifier&amp; importedName, const Identifier&amp; localName)
 788     {
 789         return new (m_parserArena) ImportSpecifierNode(location, importedName, localName);
 790     }
 791 
 792     ImportSpecifierListNode* createImportSpecifierList()
 793     {
 794         return new (m_parserArena) ImportSpecifierListNode();
 795     }
 796 
 797     void appendImportSpecifier(ImportSpecifierListNode* specifierList, ImportSpecifierNode* specifier)
 798     {
 799         specifierList-&gt;append(specifier);
 800     }
 801 
 802     StatementNode* createImportDeclaration(const JSTokenLocation&amp; location, ImportSpecifierListNode* importSpecifierList, ModuleNameNode* moduleName)
 803     {
 804         return new (m_parserArena) ImportDeclarationNode(location, importSpecifierList, moduleName);
 805     }
 806 
 807     StatementNode* createExportAllDeclaration(const JSTokenLocation&amp; location, ModuleNameNode* moduleName)
 808     {
 809         return new (m_parserArena) ExportAllDeclarationNode(location, moduleName);
 810     }
 811 
 812     StatementNode* createExportDefaultDeclaration(const JSTokenLocation&amp; location, StatementNode* declaration, const Identifier&amp; localName)
 813     {
 814         return new (m_parserArena) ExportDefaultDeclarationNode(location, declaration, localName);
 815     }
 816 
 817     StatementNode* createExportLocalDeclaration(const JSTokenLocation&amp; location, StatementNode* declaration)
 818     {
 819         return new (m_parserArena) ExportLocalDeclarationNode(location, declaration);
 820     }
 821 
 822     StatementNode* createExportNamedDeclaration(const JSTokenLocation&amp; location, ExportSpecifierListNode* exportSpecifierList, ModuleNameNode* moduleName)
 823     {
 824         return new (m_parserArena) ExportNamedDeclarationNode(location, exportSpecifierList, moduleName);
 825     }
 826 
 827     ExportSpecifierNode* createExportSpecifier(const JSTokenLocation&amp; location, const Identifier&amp; localName, const Identifier&amp; exportedName)
 828     {
 829         return new (m_parserArena) ExportSpecifierNode(location, localName, exportedName);
 830     }
 831 
 832     ExportSpecifierListNode* createExportSpecifierList()
 833     {
 834         return new (m_parserArena) ExportSpecifierListNode();
 835     }
 836 
 837     void appendExportSpecifier(ExportSpecifierListNode* specifierList, ExportSpecifierNode* specifier)
 838     {
 839         specifierList-&gt;append(specifier);
 840     }
 841 
 842     void appendStatement(JSC::SourceElements* elements, JSC::StatementNode* statement)
 843     {
 844         elements-&gt;append(statement);
 845     }
 846 
 847     CommaNode* createCommaExpr(const JSTokenLocation&amp; location, ExpressionNode* node)
 848     {
 849         return new (m_parserArena) CommaNode(location, node);
 850     }
 851 
 852     CommaNode* appendToCommaExpr(const JSTokenLocation&amp; location, ExpressionNode*, ExpressionNode* tail, ExpressionNode* next)
 853     {
 854         ASSERT(tail-&gt;isCommaNode());
 855         ASSERT(next);
 856         CommaNode* newTail = new (m_parserArena) CommaNode(location, next);
 857         static_cast&lt;CommaNode*&gt;(tail)-&gt;setNext(newTail);
 858         return newTail;
 859     }
 860 
 861     int evalCount() const { return m_evalCount; }
 862 
 863     void appendBinaryExpressionInfo(int&amp; operandStackDepth, ExpressionNode* current, const JSTextPosition&amp; exprStart, const JSTextPosition&amp; lhs, const JSTextPosition&amp; rhs, bool hasAssignments)
 864     {
 865         operandStackDepth++;
 866         m_binaryOperandStack.append(std::make_pair(current, BinaryOpInfo(exprStart, lhs, rhs, hasAssignments)));
 867     }
 868 
 869     // Logic to handle datastructures used during parsing of binary expressions
 870     void operatorStackPop(int&amp; operatorStackDepth)
 871     {
 872         operatorStackDepth--;
 873         m_binaryOperatorStack.removeLast();
 874     }
 875     bool operatorStackShouldReduce(int precedence)
 876     {
 877         // If the current precedence of the operator stack is the same to the one of the given operator,
 878         // it depends on the associative whether we reduce the stack.
 879         // If the operator is right associative, we should not reduce the stack right now.
 880         if (precedence == m_binaryOperatorStack.last().second)
 881             return !(m_binaryOperatorStack.last().first &amp; RightAssociativeBinaryOpTokenFlag);
 882         return precedence &lt; m_binaryOperatorStack.last().second;
 883     }
 884     const BinaryOperand&amp; getFromOperandStack(int i) { return m_binaryOperandStack[m_binaryOperandStack.size() + i]; }
 885     void shrinkOperandStackBy(int&amp; operandStackDepth, int amount)
 886     {
 887         operandStackDepth -= amount;
 888         ASSERT(operandStackDepth &gt;= 0);
 889         m_binaryOperandStack.shrink(m_binaryOperandStack.size() - amount);
 890     }
 891     void appendBinaryOperation(const JSTokenLocation&amp; location, int&amp; operandStackDepth, int&amp;, const BinaryOperand&amp; lhs, const BinaryOperand&amp; rhs)
 892     {
 893         operandStackDepth++;
 894         m_binaryOperandStack.append(std::make_pair(makeBinaryNode(location, m_binaryOperatorStack.last().first, lhs, rhs), BinaryOpInfo(lhs.second, rhs.second)));
 895     }
 896     void operatorStackAppend(int&amp; operatorStackDepth, int op, int precedence)
 897     {
 898         operatorStackDepth++;
 899         m_binaryOperatorStack.append(std::make_pair(op, precedence));
 900     }
 901     ExpressionNode* popOperandStack(int&amp;)
 902     {
 903         ExpressionNode* result = m_binaryOperandStack.last().first;
 904         m_binaryOperandStack.removeLast();
 905         return result;
 906     }
 907 
 908     void appendUnaryToken(int&amp; tokenStackDepth, int type, const JSTextPosition&amp; start)
 909     {
 910         tokenStackDepth++;
 911         m_unaryTokenStack.append(std::make_pair(type, start));
 912     }
 913 
 914     int unaryTokenStackLastType(int&amp;)
 915     {
 916         return m_unaryTokenStack.last().first;
 917     }
 918 
 919     const JSTextPosition&amp; unaryTokenStackLastStart(int&amp;)
 920     {
 921         return m_unaryTokenStack.last().second;
 922     }
 923 
 924     void unaryTokenStackRemoveLast(int&amp; tokenStackDepth)
 925     {
 926         tokenStackDepth--;
 927         m_unaryTokenStack.removeLast();
 928     }
 929 
 930     int unaryTokenStackDepth() const
 931     {
 932         return m_unaryTokenStack.size();
 933     }
 934 
 935     void setUnaryTokenStackDepth(int oldDepth)
 936     {
 937         m_unaryTokenStack.shrink(oldDepth);
 938     }
 939 
 940     void assignmentStackAppend(int&amp; assignmentStackDepth, ExpressionNode* node, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, int assignmentCount, Operator op)
 941     {
 942         assignmentStackDepth++;
 943         ASSERT(start.offset &gt;= start.lineStartOffset);
 944         ASSERT(divot.offset &gt;= divot.lineStartOffset);
 945         m_assignmentInfoStack.append(AssignmentInfo(node, start, divot, assignmentCount, op));
 946     }
 947 
 948     ExpressionNode* createAssignment(const JSTokenLocation&amp; location, int&amp; assignmentStackDepth, ExpressionNode* rhs, int initialAssignmentCount, int currentAssignmentCount, const JSTextPosition&amp; lastTokenEnd)
 949     {
 950         AssignmentInfo&amp; info = m_assignmentInfoStack.last();
 951         ExpressionNode* result = makeAssignNode(location, info.m_node, info.m_op, rhs, info.m_initAssignments != initialAssignmentCount, info.m_initAssignments != currentAssignmentCount, info.m_start, info.m_divot + 1, lastTokenEnd);
 952         m_assignmentInfoStack.removeLast();
 953         assignmentStackDepth--;
 954         return result;
 955     }
 956 
 957     const Identifier* getName(const Property&amp; property) const { return property-&gt;name(); }
 958     PropertyNode::Type getType(const Property&amp; property) const { return property-&gt;type(); }
 959 
 960     bool isResolve(ExpressionNode* expr) const { return expr-&gt;isResolveNode(); }
 961 
 962     ExpressionNode* createDestructuringAssignment(const JSTokenLocation&amp; location, DestructuringPattern pattern, ExpressionNode* initializer)
 963     {
 964         return new (m_parserArena) DestructuringAssignmentNode(location, pattern, initializer);
 965     }
 966 
 967     ArrayPattern createArrayPattern(const JSTokenLocation&amp;)
 968     {
 969         return new (m_parserArena) ArrayPatternNode();
 970     }
 971 
 972     void appendArrayPatternSkipEntry(ArrayPattern node, const JSTokenLocation&amp; location)
 973     {
 974         node-&gt;appendIndex(ArrayPatternNode::BindingType::Elision, location, 0, nullptr);
 975     }
 976 
 977     void appendArrayPatternEntry(ArrayPattern node, const JSTokenLocation&amp; location, DestructuringPattern pattern, ExpressionNode* defaultValue)
 978     {
 979         node-&gt;appendIndex(ArrayPatternNode::BindingType::Element, location, pattern, defaultValue);
 980         tryInferNameInPattern(pattern, defaultValue);
 981     }
 982 
 983     void appendArrayPatternRestEntry(ArrayPattern node, const JSTokenLocation&amp; location, DestructuringPattern pattern)
 984     {
 985         node-&gt;appendIndex(ArrayPatternNode::BindingType::RestElement, location, pattern, nullptr);
 986     }
 987 
 988     void finishArrayPattern(ArrayPattern node, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotEnd)
 989     {
 990         setExceptionLocation(node, divotStart, divot, divotEnd);
 991     }
 992 
 993     ObjectPattern createObjectPattern(const JSTokenLocation&amp;)
 994     {
 995         return new (m_parserArena) ObjectPatternNode();
 996     }
 997 
 998     void appendObjectPatternEntry(ObjectPattern node, const JSTokenLocation&amp; location, bool wasString, const Identifier&amp; identifier, DestructuringPattern pattern, ExpressionNode* defaultValue)
 999     {
1000         node-&gt;appendEntry(location, identifier, wasString, pattern, defaultValue, ObjectPatternNode::BindingType::Element);
1001         tryInferNameInPattern(pattern, defaultValue);
1002     }
1003 
1004     void appendObjectPatternEntry(VM&amp; vm, ObjectPattern node, const JSTokenLocation&amp; location, ExpressionNode* propertyExpression, DestructuringPattern pattern, ExpressionNode* defaultValue)
1005     {
1006         node-&gt;appendEntry(vm, location, propertyExpression, pattern, defaultValue, ObjectPatternNode::BindingType::Element);
1007         tryInferNameInPattern(pattern, defaultValue);
1008     }
1009 
1010     void appendObjectPatternRestEntry(VM&amp; vm, ObjectPattern node, const JSTokenLocation&amp; location, DestructuringPattern pattern)
1011     {
1012         node-&gt;appendEntry(vm, location, nullptr, pattern, nullptr, ObjectPatternNode::BindingType::RestElement);
1013     }
1014 
1015     void setContainsObjectRestElement(ObjectPattern node, bool containsRestElement)
1016     {
1017         node-&gt;setContainsRestElement(containsRestElement);
1018     }
1019 
1020     void setContainsComputedProperty(ObjectPattern node, bool containsComputedProperty)
1021     {
1022         node-&gt;setContainsComputedProperty(containsComputedProperty);
1023     }
1024 
1025     BindingPattern createBindingLocation(const JSTokenLocation&amp;, const Identifier&amp; boundProperty, const JSTextPosition&amp; start, const JSTextPosition&amp; end, AssignmentContext context)
1026     {
1027         return new (m_parserArena) BindingNode(boundProperty, start, end, context);
1028     }
1029 
1030     RestParameterNode* createRestParameter(DestructuringPatternNode* pattern, size_t numParametersToSkip)
1031     {
1032         return new (m_parserArena) RestParameterNode(pattern, numParametersToSkip);
1033     }
1034 
1035     AssignmentElement createAssignmentElement(const Expression&amp; assignmentTarget, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
1036     {
1037         return new (m_parserArena) AssignmentElementNode(assignmentTarget, start, end);
1038     }
1039 
1040     void setEndOffset(Node* node, int offset)
1041     {
1042         node-&gt;setEndOffset(offset);
1043     }
1044 
1045     int endOffset(Node* node)
1046     {
1047         return node-&gt;endOffset();
1048     }
1049 
1050     void setStartOffset(CaseClauseNode* node, int offset)
1051     {
1052         node-&gt;setStartOffset(offset);
1053     }
1054 
1055     void setStartOffset(Node* node, int offset)
1056     {
1057         node-&gt;setStartOffset(offset);
1058     }
1059 
1060     JSTextPosition breakpointLocation(Node* node)
1061     {
1062         node-&gt;setNeedsDebugHook();
1063         return node-&gt;position();
1064     }
1065 
1066     void propagateArgumentsUse() { usesArguments(); }
1067 
1068 private:
1069     struct Scope {
1070         Scope()
1071             : m_features(0)
1072             , m_numConstants(0)
1073         {
1074         }
1075         int m_features;
1076         int m_numConstants;
1077     };
1078 
1079     static void setExceptionLocation(ThrowableExpressionData* node, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotEnd)
1080     {
1081         ASSERT(divot.offset &gt;= divot.lineStartOffset);
1082         node-&gt;setExceptionSourceCode(divot, divotStart, divotEnd);
1083     }
1084 
1085     void incConstants() { m_scope.m_numConstants++; }
1086     void usesThis() { m_scope.m_features |= ThisFeature; }
1087     void usesArrowFunction() { m_scope.m_features |= ArrowFunctionFeature; }
1088     void usesArguments() { m_scope.m_features |= ArgumentsFeature; }
1089     void usesWith() { m_scope.m_features |= WithFeature; }
1090     void usesSuperCall() { m_scope.m_features |= SuperCallFeature; }
1091     void usesSuperProperty() { m_scope.m_features |= SuperPropertyFeature; }
1092     void usesEval()
1093     {
1094         m_evalCount++;
1095         m_scope.m_features |= EvalFeature;
1096     }
1097     void usesNewTarget() { m_scope.m_features |= NewTargetFeature; }
1098     ExpressionNode* createIntegerLikeNumber(const JSTokenLocation&amp; location, double d)
1099     {
1100         return new (m_parserArena) IntegerNode(location, d);
1101     }
1102     ExpressionNode* createDoubleLikeNumber(const JSTokenLocation&amp; location, double d)
1103     {
1104         return new (m_parserArena) DoubleNode(location, d);
1105     }
1106     ExpressionNode* createBigIntWithSign(const JSTokenLocation&amp; location, const Identifier&amp; bigInt, uint8_t radix, bool sign)
1107     {
1108         return new (m_parserArena) BigIntNode(location, bigInt, radix, sign);
1109     }
1110     ExpressionNode* createNumberFromBinaryOperation(const JSTokenLocation&amp; location, double value, const NumberNode&amp; originalNodeA, const NumberNode&amp; originalNodeB)
1111     {
1112         if (originalNodeA.isIntegerNode() &amp;&amp; originalNodeB.isIntegerNode())
1113             return createIntegerLikeNumber(location, value);
1114         return createDoubleLikeNumber(location, value);
1115     }
1116     ExpressionNode* createNumberFromUnaryOperation(const JSTokenLocation&amp; location, double value, const NumberNode&amp; originalNode)
1117     {
1118         if (originalNode.isIntegerNode())
1119             return createIntegerLikeNumber(location, value);
1120         return createDoubleLikeNumber(location, value);
1121     }
1122     ExpressionNode* createBigIntFromUnaryOperation(const JSTokenLocation&amp; location, bool sign, const BigIntNode&amp; originalNode)
1123     {
1124         return createBigIntWithSign(location, originalNode.identifier(), originalNode.radix(), sign);
1125     }
1126 
1127     void tryInferNameInPattern(DestructuringPattern pattern, ExpressionNode* defaultValue)
1128     {
1129         if (!defaultValue)
1130             return;
1131 
1132         if (pattern-&gt;isBindingNode()) {
1133             const Identifier&amp; ident = static_cast&lt;BindingNode*&gt;(pattern)-&gt;boundProperty();
1134             tryInferNameInPatternWithIdentifier(ident, defaultValue);
1135         } else if (pattern-&gt;isAssignmentElementNode()) {
1136             const ExpressionNode* assignmentTarget = static_cast&lt;AssignmentElementNode*&gt;(pattern)-&gt;assignmentTarget();
1137             if (assignmentTarget-&gt;isResolveNode()) {
1138                 const Identifier&amp; ident = static_cast&lt;const ResolveNode*&gt;(assignmentTarget)-&gt;identifier();
1139                 tryInferNameInPatternWithIdentifier(ident, defaultValue);
1140             }
1141         }
1142     }
1143 
1144     void tryInferNameInPatternWithIdentifier(const Identifier&amp; ident, ExpressionNode* defaultValue)
1145     {
1146         if (defaultValue-&gt;isBaseFuncExprNode()) {
1147             auto metadata = static_cast&lt;BaseFuncExprNode*&gt;(defaultValue)-&gt;metadata();
1148             metadata-&gt;setEcmaName(ident);
1149         } else if (defaultValue-&gt;isClassExprNode())
1150             static_cast&lt;ClassExprNode*&gt;(defaultValue)-&gt;setEcmaName(ident);
1151     }
1152 
1153     VM&amp; m_vm;
1154     ParserArena&amp; m_parserArena;
1155     SourceCode* m_sourceCode;
1156     Scope m_scope;
1157     Vector&lt;BinaryOperand, 10, UnsafeVectorOverflow&gt; m_binaryOperandStack;
1158     Vector&lt;AssignmentInfo, 10, UnsafeVectorOverflow&gt; m_assignmentInfoStack;
1159     Vector&lt;std::pair&lt;int, int&gt;, 10, UnsafeVectorOverflow&gt; m_binaryOperatorStack;
1160     Vector&lt;std::pair&lt;int, JSTextPosition&gt;, 10, UnsafeVectorOverflow&gt; m_unaryTokenStack;
1161     int m_evalCount;
1162 };
1163 
1164 ExpressionNode* ASTBuilder::makeTypeOfNode(const JSTokenLocation&amp; location, ExpressionNode* expr)
1165 {
1166     if (expr-&gt;isResolveNode()) {
1167         ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(expr);
1168         return new (m_parserArena) TypeOfResolveNode(location, resolve-&gt;identifier());
1169     }
1170     return new (m_parserArena) TypeOfValueNode(location, expr);
1171 }
1172 
1173 ExpressionNode* ASTBuilder::makeDeleteNode(const JSTokenLocation&amp; location, ExpressionNode* expr, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
1174 {
1175     if (expr-&gt;isOptionalChain()) {
1176         OptionalChainNode* optionalChain = static_cast&lt;OptionalChainNode*&gt;(expr);
1177         if (optionalChain-&gt;expr()-&gt;isLocation()) {
1178             ASSERT(!optionalChain-&gt;expr()-&gt;isResolveNode());
1179             optionalChain-&gt;setExpr(makeDeleteNode(location, optionalChain-&gt;expr(), start, divot, end));
1180             return optionalChain;
1181         }
1182     }
1183 
1184     if (!expr-&gt;isLocation())
1185         return new (m_parserArena) DeleteValueNode(location, expr);
1186     if (expr-&gt;isResolveNode()) {
1187         ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(expr);
1188         return new (m_parserArena) DeleteResolveNode(location, resolve-&gt;identifier(), divot, start, end);
1189     }
1190     if (expr-&gt;isBracketAccessorNode()) {
1191         BracketAccessorNode* bracket = static_cast&lt;BracketAccessorNode*&gt;(expr);
1192         return new (m_parserArena) DeleteBracketNode(location, bracket-&gt;base(), bracket-&gt;subscript(), divot, start, end);
1193     }
1194     ASSERT(expr-&gt;isDotAccessorNode());
1195     DotAccessorNode* dot = static_cast&lt;DotAccessorNode*&gt;(expr);
1196     return new (m_parserArena) DeleteDotNode(location, dot-&gt;base(), dot-&gt;identifier(), divot, start, end);
1197 }
1198 
1199 ExpressionNode* ASTBuilder::makeNegateNode(const JSTokenLocation&amp; location, ExpressionNode* n)
1200 {
1201     if (n-&gt;isNumber()) {
1202         const NumberNode&amp; numberNode = static_cast&lt;const NumberNode&amp;&gt;(*n);
1203         return createNumberFromUnaryOperation(location, -numberNode.value(), numberNode);
1204     }
1205 
1206     if (n-&gt;isBigInt()) {
1207         const BigIntNode&amp; bigIntNode = static_cast&lt;const BigIntNode&amp;&gt;(*n);
1208         return createBigIntFromUnaryOperation(location, !bigIntNode.sign(), bigIntNode);
1209     }
1210 
1211     return new (m_parserArena) NegateNode(location, n);
1212 }
1213 
1214 ExpressionNode* ASTBuilder::makeBitwiseNotNode(const JSTokenLocation&amp; location, ExpressionNode* expr)
1215 {
1216     if (expr-&gt;isNumber())
1217         return createIntegerLikeNumber(location, ~toInt32(static_cast&lt;NumberNode*&gt;(expr)-&gt;value()));
1218     return new (m_parserArena) BitwiseNotNode(location, expr);
1219 }
1220 
1221 ExpressionNode* ASTBuilder::makePowNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1222 {
1223     auto* strippedExpr1 = expr1-&gt;stripUnaryPlus();
1224     auto* strippedExpr2 = expr2-&gt;stripUnaryPlus();
1225 
1226     if (strippedExpr1-&gt;isNumber() &amp;&amp; strippedExpr2-&gt;isNumber()) {
1227         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*strippedExpr1);
1228         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*strippedExpr2);
1229         return createNumberFromBinaryOperation(location, operationMathPow(numberExpr1.value(), numberExpr2.value()), numberExpr1, numberExpr2);
1230     }
1231 
1232     if (strippedExpr1-&gt;isNumber())
1233         expr1 = strippedExpr1;
1234     if (strippedExpr2-&gt;isNumber())
1235         expr2 = strippedExpr2;
1236 
1237     return new (m_parserArena) PowNode(location, expr1, expr2, rightHasAssignments);
1238 }
1239 
1240 ExpressionNode* ASTBuilder::makeMultNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1241 {
1242     // FIXME: Unary + change the evaluation order.
1243     // https://bugs.webkit.org/show_bug.cgi?id=159968
1244     expr1 = expr1-&gt;stripUnaryPlus();
1245     expr2 = expr2-&gt;stripUnaryPlus();
1246 
1247     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1248         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1249         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1250         return createNumberFromBinaryOperation(location, numberExpr1.value() * numberExpr2.value(), numberExpr1, numberExpr2);
1251     }
1252 
1253     if (expr1-&gt;isNumber() &amp;&amp; static_cast&lt;NumberNode*&gt;(expr1)-&gt;value() == 1)
1254         return new (m_parserArena) UnaryPlusNode(location, expr2);
1255 
1256     if (expr2-&gt;isNumber() &amp;&amp; static_cast&lt;NumberNode*&gt;(expr2)-&gt;value() == 1)
1257         return new (m_parserArena) UnaryPlusNode(location, expr1);
1258 
1259     return new (m_parserArena) MultNode(location, expr1, expr2, rightHasAssignments);
1260 }
1261 
1262 ExpressionNode* ASTBuilder::makeDivNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1263 {
1264     // FIXME: Unary + change the evaluation order.
1265     // https://bugs.webkit.org/show_bug.cgi?id=159968
1266     expr1 = expr1-&gt;stripUnaryPlus();
1267     expr2 = expr2-&gt;stripUnaryPlus();
1268 
1269     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1270         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1271         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1272         double result = numberExpr1.value() / numberExpr2.value();
1273         if (static_cast&lt;int64_t&gt;(result) == result)
1274             return createNumberFromBinaryOperation(location, result, numberExpr1, numberExpr2);
1275         return createDoubleLikeNumber(location, result);
1276     }
1277     return new (m_parserArena) DivNode(location, expr1, expr2, rightHasAssignments);
1278 }
1279 
1280 ExpressionNode* ASTBuilder::makeModNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1281 {
1282     // FIXME: Unary + change the evaluation order.
1283     // https://bugs.webkit.org/show_bug.cgi?id=159968
1284     expr1 = expr1-&gt;stripUnaryPlus();
1285     expr2 = expr2-&gt;stripUnaryPlus();
1286 
1287     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1288         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1289         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1290         return createIntegerLikeNumber(location, fmod(numberExpr1.value(), numberExpr2.value()));
1291     }
1292     return new (m_parserArena) ModNode(location, expr1, expr2, rightHasAssignments);
1293 }
1294 
1295 ExpressionNode* ASTBuilder::makeAddNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1296 {
1297 
1298     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1299         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1300         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1301         return createNumberFromBinaryOperation(location, numberExpr1.value() + numberExpr2.value(), numberExpr1, numberExpr2);
1302     }
1303     return new (m_parserArena) AddNode(location, expr1, expr2, rightHasAssignments);
1304 }
1305 
1306 ExpressionNode* ASTBuilder::makeSubNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1307 {
1308     // FIXME: Unary + change the evaluation order.
1309     // https://bugs.webkit.org/show_bug.cgi?id=159968
1310     expr1 = expr1-&gt;stripUnaryPlus();
1311     expr2 = expr2-&gt;stripUnaryPlus();
1312 
1313     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1314         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1315         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1316         return createNumberFromBinaryOperation(location, numberExpr1.value() - numberExpr2.value(), numberExpr1, numberExpr2);
1317     }
1318     return new (m_parserArena) SubNode(location, expr1, expr2, rightHasAssignments);
1319 }
1320 
1321 ExpressionNode* ASTBuilder::makeLeftShiftNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1322 {
1323     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1324         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1325         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1326         return createIntegerLikeNumber(location, toInt32(numberExpr1.value()) &lt;&lt; (toUInt32(numberExpr2.value()) &amp; 0x1f));
1327     }
1328     return new (m_parserArena) LeftShiftNode(location, expr1, expr2, rightHasAssignments);
1329 }
1330 
1331 ExpressionNode* ASTBuilder::makeRightShiftNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1332 {
1333     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1334         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1335         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1336         return createIntegerLikeNumber(location, toInt32(numberExpr1.value()) &gt;&gt; (toUInt32(numberExpr2.value()) &amp; 0x1f));
1337     }
1338     return new (m_parserArena) RightShiftNode(location, expr1, expr2, rightHasAssignments);
1339 }
1340 
1341 ExpressionNode* ASTBuilder::makeURightShiftNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1342 {
1343     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1344         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1345         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1346         return createIntegerLikeNumber(location, toUInt32(numberExpr1.value()) &gt;&gt; (toUInt32(numberExpr2.value()) &amp; 0x1f));
1347     }
1348     return new (m_parserArena) UnsignedRightShiftNode(location, expr1, expr2, rightHasAssignments);
1349 }
1350 
1351 ExpressionNode* ASTBuilder::makeBitOrNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1352 {
1353     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1354         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1355         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1356         return createIntegerLikeNumber(location, toInt32(numberExpr1.value()) | toInt32(numberExpr2.value()));
1357     }
1358     return new (m_parserArena) BitOrNode(location, expr1, expr2, rightHasAssignments);
1359 }
1360 
1361 ExpressionNode* ASTBuilder::makeBitAndNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1362 {
1363     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1364         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1365         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1366         return createIntegerLikeNumber(location, toInt32(numberExpr1.value()) &amp; toInt32(numberExpr2.value()));
1367     }
1368     return new (m_parserArena) BitAndNode(location, expr1, expr2, rightHasAssignments);
1369 }
1370 
1371 ExpressionNode* ASTBuilder::makeBitXOrNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1372 {
1373     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1374         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1375         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1376         return createIntegerLikeNumber(location, toInt32(numberExpr1.value()) ^ toInt32(numberExpr2.value()));
1377     }
1378     return new (m_parserArena) BitXOrNode(location, expr1, expr2, rightHasAssignments);
1379 }
1380 
1381 ExpressionNode* ASTBuilder::makeCoalesceNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2)
1382 {
1383     // Optimization for `x?.y ?? z`.
1384     if (expr1-&gt;isOptionalChain()) {
1385         OptionalChainNode* optionalChain = static_cast&lt;OptionalChainNode*&gt;(expr1);
1386         if (!optionalChain-&gt;expr()-&gt;isDeleteNode()) {
1387             constexpr bool hasAbsorbedOptionalChain = true;
1388             return new (m_parserArena) CoalesceNode(location, optionalChain-&gt;expr(), expr2, hasAbsorbedOptionalChain);
1389         }
1390     }
1391     constexpr bool hasAbsorbedOptionalChain = false;
1392     return new (m_parserArena) CoalesceNode(location, expr1, expr2, hasAbsorbedOptionalChain);
1393 }
1394 
1395 ExpressionNode* ASTBuilder::makeFunctionCallNode(const JSTokenLocation&amp; location, ExpressionNode* func, bool previousBaseWasSuper, ArgumentsNode* args, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotEnd, size_t callOrApplyChildDepth, bool isOptionalCall)
1396 {
1397     ASSERT(divot.offset &gt;= divot.lineStartOffset);
1398     if (func-&gt;isSuperNode())
1399         usesSuperCall();
1400 
1401     if (func-&gt;isBytecodeIntrinsicNode()) {
1402         ASSERT(!isOptionalCall);
1403         BytecodeIntrinsicNode* intrinsic = static_cast&lt;BytecodeIntrinsicNode*&gt;(func);
1404         if (intrinsic-&gt;type() == BytecodeIntrinsicNode::Type::Constant &amp;&amp; intrinsic-&gt;entry().type() == BytecodeIntrinsicRegistry::Type::Emitter)
1405             return new (m_parserArena) BytecodeIntrinsicNode(BytecodeIntrinsicNode::Type::Function, location, intrinsic-&gt;entry(), intrinsic-&gt;identifier(), args, divot, divotStart, divotEnd);
1406     }
1407 
1408     if (func-&gt;isOptionalChain()) {
1409         OptionalChainNode* optionalChain = static_cast&lt;OptionalChainNode*&gt;(func);
1410         if (optionalChain-&gt;expr()-&gt;isLocation()) {
1411             ASSERT(!optionalChain-&gt;expr()-&gt;isResolveNode());
1412             // We must take care to preserve our `this` value in cases like `a?.b?.()` and `(a?.b)()`, respectively.
1413             if (isOptionalCall)
1414                 return makeFunctionCallNode(location, optionalChain-&gt;expr(), previousBaseWasSuper, args, divotStart, divot, divotEnd, callOrApplyChildDepth, isOptionalCall);
1415             optionalChain-&gt;setExpr(makeFunctionCallNode(location, optionalChain-&gt;expr(), previousBaseWasSuper, args, divotStart, divot, divotEnd, callOrApplyChildDepth, isOptionalCall));
1416             return optionalChain;
1417         }
1418     }
1419 
1420     if (!func-&gt;isLocation())
1421         return new (m_parserArena) FunctionCallValueNode(location, func, args, divot, divotStart, divotEnd);
1422     if (func-&gt;isResolveNode()) {
1423         ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(func);
1424         const Identifier&amp; identifier = resolve-&gt;identifier();
1425         if (identifier == m_vm.propertyNames-&gt;eval) {
1426             usesEval();
1427             return new (m_parserArena) EvalFunctionCallNode(location, args, divot, divotStart, divotEnd);
1428         }
1429         return new (m_parserArena) FunctionCallResolveNode(location, identifier, args, divot, divotStart, divotEnd);
1430     }
1431     if (func-&gt;isBracketAccessorNode()) {
1432         BracketAccessorNode* bracket = static_cast&lt;BracketAccessorNode*&gt;(func);
1433         FunctionCallBracketNode* node = new (m_parserArena) FunctionCallBracketNode(location, bracket-&gt;base(), bracket-&gt;subscript(), bracket-&gt;subscriptHasAssignments(), args, divot, divotStart, divotEnd);
1434         node-&gt;setSubexpressionInfo(bracket-&gt;divot(), bracket-&gt;divotEnd().offset);
1435         return node;
1436     }
1437     ASSERT(func-&gt;isDotAccessorNode());
1438     DotAccessorNode* dot = static_cast&lt;DotAccessorNode*&gt;(func);
1439     FunctionCallDotNode* node = nullptr;
1440     if (!previousBaseWasSuper &amp;&amp; (dot-&gt;identifier() == m_vm.propertyNames-&gt;builtinNames().callPublicName() || dot-&gt;identifier() == m_vm.propertyNames-&gt;builtinNames().callPrivateName()))
1441         node = new (m_parserArena) CallFunctionCallDotNode(location, dot-&gt;base(), dot-&gt;identifier(), args, divot, divotStart, divotEnd, callOrApplyChildDepth);
1442     else if (!previousBaseWasSuper &amp;&amp; (dot-&gt;identifier() == m_vm.propertyNames-&gt;builtinNames().applyPublicName() || dot-&gt;identifier() == m_vm.propertyNames-&gt;builtinNames().applyPrivateName())) {
1443         // FIXME: This check is only needed because we haven&#39;t taught the bytecode generator to inline
1444         // Reflect.apply yet. See https://bugs.webkit.org/show_bug.cgi?id=190668.
1445         if (!dot-&gt;base()-&gt;isResolveNode() || static_cast&lt;ResolveNode*&gt;(dot-&gt;base())-&gt;identifier() != &quot;Reflect&quot;)
1446             node = new (m_parserArena) ApplyFunctionCallDotNode(location, dot-&gt;base(), dot-&gt;identifier(), args, divot, divotStart, divotEnd, callOrApplyChildDepth);
1447     }
1448     if (!node)
1449         node = new (m_parserArena) FunctionCallDotNode(location, dot-&gt;base(), dot-&gt;identifier(), args, divot, divotStart, divotEnd);
1450     node-&gt;setSubexpressionInfo(dot-&gt;divot(), dot-&gt;divotEnd().offset);
1451     return node;
1452 }
1453 
1454 ExpressionNode* ASTBuilder::makeBinaryNode(const JSTokenLocation&amp; location, int token, std::pair&lt;ExpressionNode*, BinaryOpInfo&gt; lhs, std::pair&lt;ExpressionNode*, BinaryOpInfo&gt; rhs)
1455 {
1456     switch (token) {
1457     case COALESCE:
1458         return makeCoalesceNode(location, lhs.first, rhs.first);
1459 
1460     case OR:
1461         return new (m_parserArena) LogicalOpNode(location, lhs.first, rhs.first, OpLogicalOr);
1462 
1463     case AND:
1464         return new (m_parserArena) LogicalOpNode(location, lhs.first, rhs.first, OpLogicalAnd);
1465 
1466     case BITOR:
1467         return makeBitOrNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1468 
1469     case BITXOR:
1470         return makeBitXOrNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1471 
1472     case BITAND:
1473         return makeBitAndNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1474 
1475     case EQEQ:
1476         return new (m_parserArena) EqualNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1477 
1478     case NE:
1479         return new (m_parserArena) NotEqualNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1480 
1481     case STREQ:
1482         return new (m_parserArena) StrictEqualNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1483 
1484     case STRNEQ:
1485         return new (m_parserArena) NotStrictEqualNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1486 
1487     case LT:
1488         return new (m_parserArena) LessNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1489 
1490     case GT:
1491         return new (m_parserArena) GreaterNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1492 
1493     case LE:
1494         return new (m_parserArena) LessEqNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1495 
1496     case GE:
1497         return new (m_parserArena) GreaterEqNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1498 
1499     case INSTANCEOF: {
1500         InstanceOfNode* node = new (m_parserArena) InstanceOfNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1501         setExceptionLocation(node, lhs.second.start, rhs.second.start, rhs.second.end);
1502         return node;
1503     }
1504 
1505     case INTOKEN: {
1506         InNode* node = new (m_parserArena) InNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1507         setExceptionLocation(node, lhs.second.start, rhs.second.start, rhs.second.end);
1508         return node;
1509     }
1510 
1511     case LSHIFT:
1512         return makeLeftShiftNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1513 
1514     case RSHIFT:
1515         return makeRightShiftNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1516 
1517     case URSHIFT:
1518         return makeURightShiftNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1519 
1520     case PLUS:
1521         return makeAddNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1522 
1523     case MINUS:
1524         return makeSubNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1525 
1526     case TIMES:
1527         return makeMultNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1528 
1529     case DIVIDE:
1530         return makeDivNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1531 
1532     case MOD:
1533         return makeModNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1534 
1535     case POW:
1536         return makePowNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1537     }
1538     CRASH();
1539     return 0;
1540 }
1541 
1542 ExpressionNode* ASTBuilder::makeAssignNode(const JSTokenLocation&amp; location, ExpressionNode* loc, Operator op, ExpressionNode* expr, bool locHasAssignments, bool exprHasAssignments, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
1543 {
1544     if (!loc-&gt;isLocation()) {
1545         ASSERT(loc-&gt;isFunctionCall());
1546         return new (m_parserArena) AssignErrorNode(location, divot, start, end);
1547     }
1548 
1549     if (loc-&gt;isResolveNode()) {
1550         ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(loc);
1551         if (op == OpEqual) {
1552             if (expr-&gt;isBaseFuncExprNode()) {
1553                 auto metadata = static_cast&lt;BaseFuncExprNode*&gt;(expr)-&gt;metadata();
1554                 metadata-&gt;setEcmaName(resolve-&gt;identifier());
1555             } else if (expr-&gt;isClassExprNode())
1556                 static_cast&lt;ClassExprNode*&gt;(expr)-&gt;setEcmaName(resolve-&gt;identifier());
1557             AssignResolveNode* node = new (m_parserArena) AssignResolveNode(location, resolve-&gt;identifier(), expr, AssignmentContext::AssignmentExpression);
1558             setExceptionLocation(node, start, divot, end);
1559             return node;
1560         }
1561         return new (m_parserArena) ReadModifyResolveNode(location, resolve-&gt;identifier(), op, expr, exprHasAssignments, divot, start, end);
1562     }
1563     if (loc-&gt;isBracketAccessorNode()) {
1564         BracketAccessorNode* bracket = static_cast&lt;BracketAccessorNode*&gt;(loc);
1565         if (op == OpEqual)
1566             return new (m_parserArena) AssignBracketNode(location, bracket-&gt;base(), bracket-&gt;subscript(), expr, locHasAssignments, exprHasAssignments, bracket-&gt;divot(), start, end);
1567         ReadModifyBracketNode* node = new (m_parserArena) ReadModifyBracketNode(location, bracket-&gt;base(), bracket-&gt;subscript(), op, expr, locHasAssignments, exprHasAssignments, divot, start, end);
1568         node-&gt;setSubexpressionInfo(bracket-&gt;divot(), bracket-&gt;divotEnd().offset);
1569         return node;
1570     }
1571     ASSERT(loc-&gt;isDotAccessorNode());
1572     DotAccessorNode* dot = static_cast&lt;DotAccessorNode*&gt;(loc);
1573     if (op == OpEqual)
1574         return new (m_parserArena) AssignDotNode(location, dot-&gt;base(), dot-&gt;identifier(), expr, exprHasAssignments, dot-&gt;divot(), start, end);
1575 
1576     ReadModifyDotNode* node = new (m_parserArena) ReadModifyDotNode(location, dot-&gt;base(), dot-&gt;identifier(), op, expr, exprHasAssignments, divot, start, end);
1577     node-&gt;setSubexpressionInfo(dot-&gt;divot(), dot-&gt;divotEnd().offset);
1578     return node;
1579 }
1580 
1581 ExpressionNode* ASTBuilder::makePrefixNode(const JSTokenLocation&amp; location, ExpressionNode* expr, Operator op, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
1582 {
1583     return new (m_parserArena) PrefixNode(location, expr, op, divot, start, end);
1584 }
1585 
1586 ExpressionNode* ASTBuilder::makePostfixNode(const JSTokenLocation&amp; location, ExpressionNode* expr, Operator op, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
1587 {
1588     return new (m_parserArena) PostfixNode(location, expr, op, divot, start, end);
1589 }
1590 
1591 }
    </pre>
  </body>
</html>
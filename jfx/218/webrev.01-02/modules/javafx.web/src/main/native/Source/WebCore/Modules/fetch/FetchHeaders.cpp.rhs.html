<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/fetch/FetchHeaders.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016 Canon Inc.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted, provided that the following conditions
  6  * are required to be met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Canon Inc. nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY CANON INC. AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL CANON INC. AND ITS CONTRIBUTORS BE LIABLE FOR
 21  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 22  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 23  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 24  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 25  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;FetchHeaders.h&quot;
 31 
 32 #include &quot;HTTPParsers.h&quot;
 33 
 34 namespace WebCore {
 35 
<a name="1" id="anc1"></a><span class="line-added"> 36 // https://fetch.spec.whatwg.org/#concept-headers-remove-privileged-no-cors-request-headers</span>
<span class="line-added"> 37 static void removePrivilegedNoCORSRequestHeaders(HTTPHeaderMap&amp; headers)</span>
<span class="line-added"> 38 {</span>
<span class="line-added"> 39     headers.remove(HTTPHeaderName::Range);</span>
<span class="line-added"> 40 }</span>
<span class="line-added"> 41 </span>
 42 static ExceptionOr&lt;bool&gt; canWriteHeader(const String&amp; name, const String&amp; value, const String&amp; combinedValue, FetchHeaders::Guard guard)
 43 {
 44     if (!isValidHTTPToken(name))
 45         return Exception { TypeError, makeString(&quot;Invalid header name: &#39;&quot;, name, &quot;&#39;&quot;) };
 46     if (!isValidHTTPHeaderValue(value))
 47         return Exception { TypeError, makeString(&quot;Header &#39;&quot;, name, &quot;&#39; has invalid value: &#39;&quot;, value, &quot;&#39;&quot;) };
 48     if (guard == FetchHeaders::Guard::Immutable)
 49         return Exception { TypeError, &quot;Headers object&#39;s guard is &#39;immutable&#39;&quot;_s };
 50     if (guard == FetchHeaders::Guard::Request &amp;&amp; isForbiddenHeaderName(name))
 51         return false;
 52     if (guard == FetchHeaders::Guard::RequestNoCors &amp;&amp; !combinedValue.isEmpty() &amp;&amp; !isSimpleHeader(name, combinedValue))
 53         return false;
 54     if (guard == FetchHeaders::Guard::Response &amp;&amp; isForbiddenResponseHeaderName(name))
 55         return false;
 56     return true;
 57 }
 58 
 59 static ExceptionOr&lt;void&gt; appendToHeaderMap(const String&amp; name, const String&amp; value, HTTPHeaderMap&amp; headers, FetchHeaders::Guard guard)
 60 {
 61     String normalizedValue = stripLeadingAndTrailingHTTPSpaces(value);
 62     String combinedValue = normalizedValue;
 63     if (headers.contains(name))
 64         combinedValue = makeString(headers.get(name), &quot;, &quot;, normalizedValue);
 65     auto canWriteResult = canWriteHeader(name, normalizedValue, combinedValue, guard);
 66     if (canWriteResult.hasException())
 67         return canWriteResult.releaseException();
 68     if (!canWriteResult.releaseReturnValue())
 69         return { };
 70     headers.set(name, combinedValue);
<a name="2" id="anc2"></a><span class="line-added"> 71 </span>
<span class="line-added"> 72     if (guard == FetchHeaders::Guard::RequestNoCors)</span>
<span class="line-added"> 73         removePrivilegedNoCORSRequestHeaders(headers);</span>
<span class="line-added"> 74 </span>
 75     return { };
 76 }
 77 
 78 static ExceptionOr&lt;void&gt; appendToHeaderMap(const HTTPHeaderMap::HTTPHeaderMapConstIterator::KeyValue&amp; header, HTTPHeaderMap&amp; headers, FetchHeaders::Guard guard)
 79 {
 80     auto canWriteResult = canWriteHeader(header.key, header.value, header.value, guard);
 81     if (canWriteResult.hasException())
 82         return canWriteResult.releaseException();
 83     if (!canWriteResult.releaseReturnValue())
 84         return { };
 85     if (header.keyAsHTTPHeaderName)
 86         headers.add(header.keyAsHTTPHeaderName.value(), header.value);
 87     else
 88         headers.add(header.key, header.value);
<a name="3" id="anc3"></a><span class="line-added"> 89 </span>
<span class="line-added"> 90     if (guard == FetchHeaders::Guard::RequestNoCors)</span>
<span class="line-added"> 91         removePrivilegedNoCORSRequestHeaders(headers);</span>
<span class="line-added"> 92 </span>
 93     return { };
 94 }
 95 
 96 // https://fetch.spec.whatwg.org/#concept-headers-fill
 97 static ExceptionOr&lt;void&gt; fillHeaderMap(HTTPHeaderMap&amp; headers, const FetchHeaders::Init&amp; headersInit, FetchHeaders::Guard guard)
 98 {
 99     if (WTF::holds_alternative&lt;Vector&lt;Vector&lt;String&gt;&gt;&gt;(headersInit)) {
100         auto&amp; sequence = WTF::get&lt;Vector&lt;Vector&lt;String&gt;&gt;&gt;(headersInit);
101         for (auto&amp; header : sequence) {
102             if (header.size() != 2)
103                 return Exception { TypeError, &quot;Header sub-sequence must contain exactly two items&quot; };
104             auto result = appendToHeaderMap(header[0], header[1], headers, guard);
105             if (result.hasException())
106                 return result.releaseException();
107         }
108     } else {
109         auto&amp; record = WTF::get&lt;Vector&lt;WTF::KeyValuePair&lt;String, String&gt;&gt;&gt;(headersInit);
110         for (auto&amp; header : record) {
111             auto result = appendToHeaderMap(header.key, header.value, headers, guard);
112             if (result.hasException())
113                 return result.releaseException();
114         }
115     }
116 
117     return { };
118 }
119 
120 ExceptionOr&lt;Ref&lt;FetchHeaders&gt;&gt; FetchHeaders::create(Optional&lt;Init&gt;&amp;&amp; headersInit)
121 {
122     HTTPHeaderMap headers;
123 
124     if (headersInit) {
125         auto result = fillHeaderMap(headers, *headersInit, Guard::None);
126         if (result.hasException())
127             return result.releaseException();
128     }
129 
130     return adoptRef(*new FetchHeaders { Guard::None, WTFMove(headers) });
131 }
132 
133 ExceptionOr&lt;void&gt; FetchHeaders::fill(const Init&amp; headerInit)
134 {
135     return fillHeaderMap(m_headers, headerInit, m_guard);
136 }
137 
138 ExceptionOr&lt;void&gt; FetchHeaders::fill(const FetchHeaders&amp; otherHeaders)
139 {
140     for (auto&amp; header : otherHeaders.m_headers) {
141         auto result = appendToHeaderMap(header, m_headers, m_guard);
142         if (result.hasException())
143             return result.releaseException();
144     }
145 
146     return { };
147 }
148 
149 ExceptionOr&lt;void&gt; FetchHeaders::append(const String&amp; name, const String&amp; value)
150 {
151     return appendToHeaderMap(name, value, m_headers, m_guard);
152 }
153 
<a name="4" id="anc4"></a><span class="line-added">154 // https://fetch.spec.whatwg.org/#dom-headers-delete</span>
155 ExceptionOr&lt;void&gt; FetchHeaders::remove(const String&amp; name)
156 {
<a name="5" id="anc5"></a><span class="line-modified">157     if (!isValidHTTPToken(name))</span>
<span class="line-modified">158         return Exception { TypeError, makeString(&quot;Invalid header name: &#39;&quot;, name, &quot;&#39;&quot;) };</span>
<span class="line-modified">159     if (m_guard == FetchHeaders::Guard::Immutable)</span>
<span class="line-modified">160         return Exception { TypeError, &quot;Headers object&#39;s guard is &#39;immutable&#39;&quot;_s };</span>
<span class="line-added">161     if (m_guard == FetchHeaders::Guard::Request &amp;&amp; isForbiddenHeaderName(name))</span>
<span class="line-added">162         return { };</span>
<span class="line-added">163     if (m_guard == FetchHeaders::Guard::RequestNoCors &amp;&amp; !isNoCORSSafelistedRequestHeaderName(name) &amp;&amp; !isPriviledgedNoCORSRequestHeaderName(name))</span>
164         return { };
<a name="6" id="anc6"></a><span class="line-added">165     if (m_guard == FetchHeaders::Guard::Response &amp;&amp; isForbiddenResponseHeaderName(name))</span>
<span class="line-added">166         return { };</span>
<span class="line-added">167 </span>
168     m_headers.remove(name);
<a name="7" id="anc7"></a><span class="line-added">169 </span>
<span class="line-added">170     if (m_guard == FetchHeaders::Guard::RequestNoCors)</span>
<span class="line-added">171         removePrivilegedNoCORSRequestHeaders(m_headers);</span>
<span class="line-added">172 </span>
173     return { };
174 }
175 
176 ExceptionOr&lt;String&gt; FetchHeaders::get(const String&amp; name) const
177 {
178     if (!isValidHTTPToken(name))
179         return Exception { TypeError, makeString(&quot;Invalid header name: &#39;&quot;, name, &quot;&#39;&quot;) };
180     return m_headers.get(name);
181 }
182 
183 ExceptionOr&lt;bool&gt; FetchHeaders::has(const String&amp; name) const
184 {
185     if (!isValidHTTPToken(name))
186         return Exception { TypeError, makeString(&quot;Invalid header name: &#39;&quot;, name, &quot;&#39;&quot;) };
187     return m_headers.contains(name);
188 }
189 
190 ExceptionOr&lt;void&gt; FetchHeaders::set(const String&amp; name, const String&amp; value)
191 {
192     String normalizedValue = stripLeadingAndTrailingHTTPSpaces(value);
193     auto canWriteResult = canWriteHeader(name, normalizedValue, normalizedValue, m_guard);
194     if (canWriteResult.hasException())
195         return canWriteResult.releaseException();
196     if (!canWriteResult.releaseReturnValue())
197         return { };
<a name="8" id="anc8"></a><span class="line-added">198 </span>
199     m_headers.set(name, normalizedValue);
<a name="9" id="anc9"></a><span class="line-added">200 </span>
<span class="line-added">201     if (m_guard == FetchHeaders::Guard::RequestNoCors)</span>
<span class="line-added">202         removePrivilegedNoCORSRequestHeaders(m_headers);</span>
<span class="line-added">203 </span>
204     return { };
205 }
206 
207 void FetchHeaders::filterAndFill(const HTTPHeaderMap&amp; headers, Guard guard)
208 {
209     for (auto&amp; header : headers) {
210         auto canWriteResult = canWriteHeader(header.key, header.value, header.value, guard);
211         if (canWriteResult.hasException())
212             continue;
213         if (!canWriteResult.releaseReturnValue())
214             continue;
215         if (header.keyAsHTTPHeaderName)
216             m_headers.add(header.keyAsHTTPHeaderName.value(), header.value);
217         else
218             m_headers.add(header.key, header.value);
219     }
220 }
221 
222 Optional&lt;WTF::KeyValuePair&lt;String, String&gt;&gt; FetchHeaders::Iterator::next()
223 {
224     while (m_currentIndex &lt; m_keys.size()) {
225         auto key = m_keys[m_currentIndex++];
226         auto value = m_headers-&gt;m_headers.get(key);
227         if (!value.isNull())
228             return WTF::KeyValuePair&lt;String, String&gt; { WTFMove(key), WTFMove(value) };
229     }
230     return WTF::nullopt;
231 }
232 
233 FetchHeaders::Iterator::Iterator(FetchHeaders&amp; headers)
234     : m_headers(headers)
235 {
236     m_keys.reserveInitialCapacity(headers.m_headers.size());
237     for (auto&amp; header : headers.m_headers)
238         m_keys.uncheckedAppend(header.key.convertToASCIILowercase());
239     std::sort(m_keys.begin(), m_keys.end(), WTF::codePointCompareLessThan);
240 }
241 
242 } // namespace WebCore
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
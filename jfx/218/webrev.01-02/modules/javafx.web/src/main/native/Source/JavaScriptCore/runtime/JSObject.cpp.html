<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
   4  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.
   5  *  Copyright (C) 2007 Eric Seidel (eric@webkit.org)
   6  *
   7  *  This library is free software; you can redistribute it and/or
   8  *  modify it under the terms of the GNU Library General Public
   9  *  License as published by the Free Software Foundation; either
  10  *  version 2 of the License, or (at your option) any later version.
  11  *
  12  *  This library is distributed in the hope that it will be useful,
  13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  *  Library General Public License for more details.
  16  *
  17  *  You should have received a copy of the GNU Library General Public License
  18  *  along with this library; see the file COPYING.LIB.  If not, write to
  19  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  20  *  Boston, MA 02110-1301, USA.
  21  *
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;JSObject.h&quot;
  26 
  27 #include &quot;ButterflyInlines.h&quot;
  28 #include &quot;CatchScope.h&quot;
  29 #include &quot;CustomGetterSetter.h&quot;
  30 #include &quot;DatePrototype.h&quot;
  31 #include &quot;ErrorConstructor.h&quot;
  32 #include &quot;Exception.h&quot;
  33 #include &quot;GCDeferralContextInlines.h&quot;
  34 #include &quot;GetterSetter.h&quot;
  35 #include &quot;HeapAnalyzer.h&quot;
  36 #include &quot;IndexingHeaderInlines.h&quot;
  37 #include &quot;JSCInlines.h&quot;
  38 #include &quot;JSCustomGetterSetterFunction.h&quot;
  39 #include &quot;JSFunction.h&quot;
  40 #include &quot;JSGlobalObject.h&quot;
  41 #include &quot;JSImmutableButterfly.h&quot;
  42 #include &quot;Lookup.h&quot;
  43 #include &quot;NativeErrorConstructor.h&quot;
  44 #include &quot;ObjectPrototype.h&quot;
  45 #include &quot;PropertyDescriptor.h&quot;
  46 #include &quot;PropertyNameArray.h&quot;
  47 #include &quot;ProxyObject.h&quot;
  48 #include &quot;SlotVisitorInlines.h&quot;
  49 #include &quot;TypeError.h&quot;
  50 #include &quot;VMInlines.h&quot;
  51 #include &lt;math.h&gt;
  52 #include &lt;wtf/Assertions.h&gt;
  53 
  54 namespace JSC {
  55 
  56 // We keep track of the size of the last array after it was grown. We use this
  57 // as a simple heuristic for as the value to grow the next array from size 0.
  58 // This value is capped by the constant FIRST_VECTOR_GROW defined in
  59 // ArrayConventions.h.
  60 static unsigned lastArraySize = 0;
  61 
  62 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(JSObject);
  63 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(JSFinalObject);
  64 
  65 const ASCIILiteral NonExtensibleObjectPropertyDefineError { &quot;Attempting to define property on object that is not extensible.&quot;_s };
  66 const ASCIILiteral ReadonlyPropertyWriteError { &quot;Attempted to assign to readonly property.&quot;_s };
  67 const ASCIILiteral ReadonlyPropertyChangeError { &quot;Attempting to change value of a readonly property.&quot;_s };
  68 const ASCIILiteral UnableToDeletePropertyError { &quot;Unable to delete property.&quot;_s };
  69 const ASCIILiteral UnconfigurablePropertyChangeAccessMechanismError { &quot;Attempting to change access mechanism for an unconfigurable property.&quot;_s };
  70 const ASCIILiteral UnconfigurablePropertyChangeConfigurabilityError { &quot;Attempting to change configurable attribute of unconfigurable property.&quot;_s };
  71 const ASCIILiteral UnconfigurablePropertyChangeEnumerabilityError { &quot;Attempting to change enumerable attribute of unconfigurable property.&quot;_s };
  72 const ASCIILiteral UnconfigurablePropertyChangeWritabilityError { &quot;Attempting to change writable attribute of unconfigurable property.&quot;_s };
  73 
  74 const ClassInfo JSObject::s_info = { &quot;Object&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(JSObject) };
  75 
  76 const ClassInfo JSFinalObject::s_info = { &quot;Object&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSFinalObject) };
  77 
  78 static inline void getClassPropertyNames(JSGlobalObject* globalObject, const ClassInfo* classInfo, PropertyNameArray&amp; propertyNames, EnumerationMode mode)
  79 {
  80     VM&amp; vm = globalObject-&gt;vm();
  81 
  82     // Add properties from the static hashtables of properties
  83     for (; classInfo; classInfo = classInfo-&gt;parentClass) {
  84         const HashTable* table = classInfo-&gt;staticPropHashTable;
  85         if (!table)
  86             continue;
  87 
  88         for (auto iter = table-&gt;begin(); iter != table-&gt;end(); ++iter) {
  89             if (!(iter-&gt;attributes() &amp; PropertyAttribute::DontEnum) || mode.includeDontEnumProperties())
  90                 propertyNames.add(Identifier::fromString(vm, iter.key()));
  91         }
  92     }
  93 }
  94 
  95 ALWAYS_INLINE void JSObject::markAuxiliaryAndVisitOutOfLineProperties(SlotVisitor&amp; visitor, Butterfly* butterfly, Structure* structure, PropertyOffset maxOffset)
  96 {
  97     // We call this when we found everything without races.
  98     ASSERT(structure);
  99 
 100     if (!butterfly)
 101         return;
 102 
 103     if (isCopyOnWrite(structure-&gt;indexingMode())) {
 104         visitor.append(bitwise_cast&lt;WriteBarrier&lt;JSCell&gt;&gt;(JSImmutableButterfly::fromButterfly(butterfly)));
 105         return;
 106     }
 107 
 108     bool hasIndexingHeader = structure-&gt;hasIndexingHeader(this);
 109     size_t preCapacity;
 110     if (hasIndexingHeader)
 111         preCapacity = butterfly-&gt;indexingHeader()-&gt;preCapacity(structure);
 112     else
 113         preCapacity = 0;
 114 
 115     HeapCell* base = bitwise_cast&lt;HeapCell*&gt;(
 116         butterfly-&gt;base(preCapacity, Structure::outOfLineCapacity(maxOffset)));
 117 
 118     ASSERT(Heap::heap(base) == visitor.heap());
 119 
 120     visitor.markAuxiliary(base);
 121 
 122     unsigned outOfLineSize = Structure::outOfLineSize(maxOffset);
 123     visitor.appendValuesHidden(butterfly-&gt;propertyStorage() - outOfLineSize, outOfLineSize);
 124 }
 125 
 126 ALWAYS_INLINE Structure* JSObject::visitButterfly(SlotVisitor&amp; visitor)
 127 {
 128     static const char* const raceReason = &quot;JSObject::visitButterfly&quot;;
 129     Structure* result = visitButterflyImpl(visitor);
 130     if (!result)
 131         visitor.didRace(this, raceReason);
 132     return result;
 133 }
 134 
 135 ALWAYS_INLINE Structure* JSObject::visitButterflyImpl(SlotVisitor&amp; visitor)
 136 {
 137     VM&amp; vm = visitor.vm();
 138 
 139     Butterfly* butterfly;
 140     Structure* structure;
 141     PropertyOffset maxOffset;
 142 
 143     auto visitElements = [&amp;] (IndexingType indexingMode) {
 144         switch (indexingMode) {
 145         // We don&#39;t need to visit the elements for CopyOnWrite butterflies since they we marked the JSImmutableButterfly acting as out butterfly.
 146         case ALL_WRITABLE_CONTIGUOUS_INDEXING_TYPES:
 147             visitor.appendValuesHidden(butterfly-&gt;contiguous().data(), butterfly-&gt;publicLength());
 148             break;
 149         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 150             visitor.appendValuesHidden(butterfly-&gt;arrayStorage()-&gt;m_vector, butterfly-&gt;arrayStorage()-&gt;vectorLength());
 151             if (butterfly-&gt;arrayStorage()-&gt;m_sparseMap)
 152                 visitor.append(butterfly-&gt;arrayStorage()-&gt;m_sparseMap);
 153             break;
 154         default:
 155             break;
 156         }
 157     };
 158 
 159     if (visitor.mutatorIsStopped()) {
 160         butterfly = this-&gt;butterfly();
 161         structure = this-&gt;structure(vm);
 162         maxOffset = structure-&gt;maxOffset();
 163 
 164         markAuxiliaryAndVisitOutOfLineProperties(visitor, butterfly, structure, maxOffset);
 165         visitElements(structure-&gt;indexingMode());
 166 
 167         return structure;
 168     }
 169 
 170     // We want to ensure that we only scan the butterfly if we have an exactly matched structure and an
 171     // exactly matched size. The mutator is required to perform the following shenanigans when
 172     // reallocating the butterfly with a concurrent collector, with all fencing necessary to ensure
 173     // that this executes as if under sequential consistency:
 174     //
 175     //     object-&gt;structure = nuke(object-&gt;structure)
 176     //     object-&gt;butterfly = newButterfly
 177     //     structure-&gt;m_offset = newMaxOffset
 178     //     object-&gt;structure = newStructure
 179     //
 180     // It&#39;s OK to skip this when reallocating the butterfly in a way that does not affect the m_offset.
 181     // We have other protocols in place for that.
 182     //
 183     // Note that the m_offset can change without the structure changing, but in that case the mutator
 184     // will still store null to the structure.
 185     //
 186     // The collector will ensure that it always sees a matched butterfly/structure by reading the
 187     // structure before and after reading the butterfly. For simplicity, let&#39;s first consider the case
 188     // where the only way to change the outOfLineCapacity is to change the structure. This works
 189     // because the mutator performs the following steps sequentially:
 190     //
 191     //     NukeStructure ChangeButterfly PutNewStructure
 192     //
 193     // Meanwhile the collector performs the following steps sequentially:
 194     //
 195     //     ReadStructureEarly ReadButterfly ReadStructureLate
 196     //
 197     // The collector is allowed to do any of these three things:
 198     //
 199     // BEFORE: Scan the object with the structure and butterfly *before* the mutator&#39;s transition.
 200     // AFTER: Scan the object with the structure and butterfly *after* the mutator&#39;s transition.
 201     // IGNORE: Ignore the butterfly and call didRace to schedule us to be revisted again in the future.
 202     //
 203     // In other words, the collector will never see any torn structure/butterfly mix. It will
 204     // always see the structure/butterfly before the transition or after but not in between.
 205     //
 206     // We can prove that this is correct by exhaustively considering all interleavings:
 207     //
 208     // NukeStructure ChangeButterfly PutNewStructure ReadStructureEarly ReadButterfly ReadStructureLate: AFTER, trivially.
 209     // NukeStructure ChangeButterfly ReadStructureEarly PutNewStructure ReadButterfly ReadStructureLate: IGNORE, because nuked structure read early
 210     // NukeStructure ChangeButterfly ReadStructureEarly ReadButterfly PutNewStructure ReadStructureLate: IGNORE, because nuked structure read early
 211     // NukeStructure ChangeButterfly ReadStructureEarly ReadButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read early
 212     // NukeStructure ReadStructureEarly ChangeButterfly PutNewStructure ReadButterfly ReadStructureLate: IGNORE, because nuked structure read early
 213     // NukeStructure ReadStructureEarly ChangeButterfly ReadButterfly PutNewStructure ReadStructureLate: IGNORE, because nuked structure read early
 214     // NukeStructure ReadStructureEarly ChangeButterfly ReadButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read early
 215     // NukeStructure ReadStructureEarly ReadButterfly ChangeButterfly PutNewStructure ReadStructureLate: IGNORE, because nuked structure read early
 216     // NukeStructure ReadStructureEarly ReadButterfly ChangeButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read early
 217     // NukeStructure ReadStructureEarly ReadButterfly ReadStructureLate ChangeButterfly PutNewStructure: IGNORE, because nuked structure read early
 218     // ReadStructureEarly NukeStructure ChangeButterfly PutNewStructure ReadButterfly ReadStructureLate: IGNORE, because early and late structures don&#39;t match
 219     // ReadStructureEarly NukeStructure ChangeButterfly ReadButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
 220     // ReadStructureEarly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
 221     // ReadStructureEarly NukeStructure ReadButterfly ChangeButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
 222     // ReadStructureEarly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
 223     // ReadStructureEarly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly PutNewStructure: IGNORE, because nuked structure read late
 224     // ReadStructureEarly ReadButterfly NukeStructure ChangeButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
 225     // ReadStructureEarly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
 226     // ReadStructureEarly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly PutNewStructure: IGNORE, because nuked structure read late
 227     // ReadStructureEarly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly PutNewStructure: BEFORE, trivially.
 228     //
 229     // But we additionally have to worry about the size changing. We make this work by requiring that
 230     // the collector reads the size early and late as well. Lets consider the interleaving of the
 231     // mutator changing the size without changing the structure:
 232     //
 233     //     NukeStructure ChangeButterfly ChangeMaxOffset RestoreStructure
 234     //
 235     // Meanwhile the collector does:
 236     //
 237     //     ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate
 238     //
 239     // The collector can detect races by not only comparing the early structure to the late structure
 240     // (which will be the same before and after the algorithm runs) but also by comparing the early and
 241     // late maxOffsets. Note: the IGNORE proofs do not cite all of the reasons why the collector will
 242     // ignore the case, since we only need to identify one to say that we&#39;re in the ignore case.
 243     //
 244     // NukeStructure ChangeButterfly ChangeMaxOffset RestoreStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate: AFTER, trivially
 245     // NukeStructure ChangeButterfly ChangeMaxOffset ReadStructureEarly RestoreStructure ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early
 246     // NukeStructure ChangeButterfly ChangeMaxOffset ReadStructureEarly ReadMaxOffsetEarly RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early
 247     // NukeStructure ChangeButterfly ChangeMaxOffset ReadStructureEarly ReadMaxOffsetEarly ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early
 248     // NukeStructure ChangeButterfly ChangeMaxOffset ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early
 249     // NukeStructure ChangeButterfly ChangeMaxOffset ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early
 250     // NukeStructure ChangeButterfly ReadStructureEarly ChangeMaxOffset RestoreStructure ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early
 251     // NukeStructure ChangeButterfly ReadStructureEarly ChangeMaxOffset ReadMaxOffsetEarly RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early
 252     // NukeStructure ChangeButterfly ReadStructureEarly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early
 253     // NukeStructure ChangeButterfly ReadStructureEarly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early
 254     // NukeStructure ChangeButterfly ReadStructureEarly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early
 255     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ChangeMaxOffset RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early
 256     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early
 257     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early
 258     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early
 259     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early
 260     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early
 261     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early
 262     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early
 263     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early
 264     // NukeStructure ChangeButterfly ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure early
 265     // NukeStructure ReadStructureEarly ChangeButterfly ChangeMaxOffset RestoreStructure ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early
 266     // NukeStructure ReadStructureEarly ChangeButterfly ChangeMaxOffset ReadMaxOffsetEarly RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early
 267     // NukeStructure ReadStructureEarly ChangeButterfly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early
 268     // NukeStructure ReadStructureEarly ChangeButterfly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early
 269     // NukeStructure ReadStructureEarly ChangeButterfly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early
 270     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ChangeMaxOffset RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early
 271     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early
 272     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early
 273     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early
 274     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early
 275     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early
 276     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early
 277     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early
 278     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early
 279     // NukeStructure ReadStructureEarly ChangeButterfly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure early
 280     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ChangeMaxOffset RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early
 281     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ChangeMaxOffset ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early
 282     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ChangeMaxOffset ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early
 283     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ChangeMaxOffset ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early
 284     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ReadButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early
 285     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ReadButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early
 286     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ReadButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early
 287     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early
 288     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early
 289     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure early
 290     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read nuked structure early
 291     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early
 292     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early
 293     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early
 294     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early
 295     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure early
 296     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure early
 297     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure early
 298     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure early
 299     // NukeStructure ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeButterfly ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure early
 300     // ReadStructureEarly NukeStructure ChangeButterfly ChangeMaxOffset RestoreStructure ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate: AFTER, the ReadStructureEarly sees the same structure as after and everything else runs after.
 301     // ReadStructureEarly NukeStructure ChangeButterfly ChangeMaxOffset ReadMaxOffsetEarly RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: AFTER, as above and the ReadMaxOffsetEarly sees the maxOffset after.
 302     // ReadStructureEarly NukeStructure ChangeButterfly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: AFTER, as above and the ReadButterfly sees the right butterfly after.
 303     // ReadStructureEarly NukeStructure ChangeButterfly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure late
 304     // ReadStructureEarly NukeStructure ChangeButterfly ChangeMaxOffset ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure late
 305     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ChangeMaxOffset RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets
 306     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets
 307     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets
 308     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ChangeMaxOffset ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets
 309     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets
 310     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets
 311     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ReadButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets
 312     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets
 313     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets
 314     // ReadStructureEarly NukeStructure ChangeButterfly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late
 315     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ChangeMaxOffset RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets
 316     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ChangeMaxOffset ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets
 317     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ChangeMaxOffset ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets
 318     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ChangeMaxOffset ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets
 319     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ReadButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets
 320     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ReadButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets
 321     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ReadButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets
 322     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets
 323     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets
 324     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ChangeButterfly ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late
 325     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ChangeButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets
 326     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ChangeButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets
 327     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ChangeButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets
 328     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets
 329     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets
 330     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ChangeButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late
 331     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets
 332     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets
 333     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ReadStructureLate ChangeButterfly ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late
 334     // ReadStructureEarly NukeStructure ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeButterfly ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late
 335     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ChangeMaxOffset RestoreStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets
 336     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ChangeMaxOffset ReadButterfly RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets
 337     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ChangeMaxOffset ReadButterfly ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure late
 338     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ChangeMaxOffset ReadButterfly ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure late
 339     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ReadButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets
 340     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ReadButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets
 341     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ReadButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets
 342     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets
 343     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets
 344     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late
 345     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ChangeButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets
 346     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ChangeButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets
 347     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ChangeButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets
 348     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets
 349     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets
 350     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late
 351     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets
 352     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure late
 353     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late
 354     // ReadStructureEarly ReadMaxOffsetEarly NukeStructure ReadButterfly ReadStructureLate ReadMaxOffsetLate ChangeButterfly ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late
 355     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ChangeButterfly ChangeMaxOffset RestoreStructure ReadStructureLate ReadMaxOffsetLate: IGNORE, read different offsets
 356     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ChangeButterfly ChangeMaxOffset ReadStructureLate RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets
 357     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ChangeButterfly ChangeMaxOffset ReadStructureLate ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets
 358     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets
 359     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets
 360     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late
 361     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read nuked structure late
 362     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read nuked structure late
 363     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late
 364     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly NukeStructure ReadStructureLate ReadMaxOffsetLate ChangeButterfly ChangeMaxOffset RestoreStructure: IGNORE, read nuked structure late
 365     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly ChangeMaxOffset RestoreStructure ReadMaxOffsetLate: IGNORE, read different offsets
 366     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly ChangeMaxOffset ReadMaxOffsetLate RestoreStructure: IGNORE, read different offsets
 367     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly ReadMaxOffsetLate ChangeMaxOffset RestoreStructure: BEFORE, reads the offset before, everything else happens before
 368     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate NukeStructure ReadMaxOffsetLate ChangeButterfly ChangeMaxOffset RestoreStructure: BEFORE, reads the offset before, everything else happens before
 369     // ReadStructureEarly ReadMaxOffsetEarly ReadButterfly ReadStructureLate ReadMaxOffsetLate NukeStructure ChangeButterfly ChangeMaxOffset RestoreStructure: BEFORE, trivially
 370     //
 371     // Whew.
 372     //
 373     // What the collector is doing is just the &quot;double collect&quot; snapshot from &quot;The Unbounded Single-
 374     // Writer Algorithm&quot; from Yehuda Afek et al&#39;s &quot;Atomic Snapshots of Shared Memory&quot; in JACM 1993,
 375     // also available here:
 376     //
 377     // http://people.csail.mit.edu/shanir/publications/AADGMS.pdf
 378     //
 379     // Unlike Afek et al&#39;s algorithm, ours does not require extra hacks to force wait-freedom (see
 380     // &quot;Observation 2&quot; in the paper). This simplifies the whole algorithm. Instead we are happy with
 381     // obstruction-freedom, and like any good obstruction-free algorithm, we ensure progress using
 382     // scheduling. We also only collect the butterfly once instead of twice; this optimization seems
 383     // to hold up in my proofs above and I&#39;m not sure it&#39;s part of Afek et al&#39;s algos.
 384     //
 385     // For more background on this kind of madness, I like this paper; it&#39;s where I learned about
 386     // both the snapshot algorithm and obstruction-freedom:
 387     //
 388     // Lunchangco, Moir, Shavit. &quot;Nonblocking k-compare-single-swap.&quot; SPAA &#39;03
 389     // https://pdfs.semanticscholar.org/343f/7182cde7669ca2a7de3dc01127927f384ef7.pdf
 390 
 391     StructureID structureID = this-&gt;structureID();
 392     if (isNuked(structureID))
 393         return nullptr;
 394     structure = vm.getStructure(structureID);
 395     maxOffset = structure-&gt;maxOffset();
 396     IndexingType indexingMode = structure-&gt;indexingMode();
 397     Dependency indexingModeDependency = Dependency::fence(indexingMode);
 398     Locker&lt;JSCellLock&gt; locker(NoLockingNecessary);
 399     switch (indexingMode) {
 400     case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 401         // We need to hold this lock to protect against changes to the innards of the butterfly
 402         // that can happen when the butterfly is used for array storage.
 403         // We do not need to hold this lock for contiguous butterflies. We do not reuse the existing
 404         // butterfly with contiguous shape for new array storage butterfly. When converting the butterfly
 405         // with contiguous shape to array storage, we always allocate a new one. Holding this lock for contiguous
 406         // butterflies is unnecessary since contiguous shaped butterfly never becomes broken state.
 407         locker = holdLock(cellLock());
 408         break;
 409     default:
 410         break;
 411     }
 412     butterfly = indexingModeDependency.consume(this)-&gt;butterfly();
 413     Dependency butterflyDependency = Dependency::fence(butterfly);
 414     if (!butterfly)
 415         return structure;
 416     if (butterflyDependency.consume(this)-&gt;structureID() != structureID)
 417         return nullptr;
 418     if (butterflyDependency.consume(structure)-&gt;maxOffset() != maxOffset)
 419         return nullptr;
 420 
 421     markAuxiliaryAndVisitOutOfLineProperties(visitor, butterfly, structure, maxOffset);
 422     ASSERT(indexingMode == structure-&gt;indexingMode());
 423     visitElements(indexingMode);
 424 
 425     return structure;
 426 }
 427 
 428 size_t JSObject::estimatedSize(JSCell* cell, VM&amp; vm)
 429 {
 430     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
 431     size_t butterflyOutOfLineSize = thisObject-&gt;m_butterfly ? thisObject-&gt;structure(vm)-&gt;outOfLineSize() : 0;
 432     return Base::estimatedSize(cell, vm) + butterflyOutOfLineSize;
 433 }
 434 
 435 void JSObject::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 436 {
 437     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
 438     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 439 #if ASSERT_ENABLED
 440     bool wasCheckingForDefaultMarkViolation = visitor.m_isCheckingForDefaultMarkViolation;
 441     visitor.m_isCheckingForDefaultMarkViolation = false;
 442 #endif
 443 
 444     JSCell::visitChildren(thisObject, visitor);
 445 
 446     thisObject-&gt;visitButterfly(visitor);
 447 
 448 #if ASSERT_ENABLED
 449     visitor.m_isCheckingForDefaultMarkViolation = wasCheckingForDefaultMarkViolation;
 450 #endif
 451 }
 452 
 453 void JSObject::analyzeHeap(JSCell* cell, HeapAnalyzer&amp; analyzer)
 454 {
 455     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
 456     Base::analyzeHeap(cell, analyzer);
 457 
 458     Structure* structure = thisObject-&gt;structure();
 459     for (auto&amp; entry : structure-&gt;getPropertiesConcurrently()) {
 460         JSValue toValue = thisObject-&gt;getDirect(entry.offset);
 461         if (toValue &amp;&amp; toValue.isCell())
 462             analyzer.analyzePropertyNameEdge(thisObject, toValue.asCell(), entry.key);
 463     }
 464 
 465     Butterfly* butterfly = thisObject-&gt;butterfly();
 466     if (butterfly) {
 467         WriteBarrier&lt;Unknown&gt;* data = nullptr;
 468         uint32_t count = 0;
 469 
 470         switch (thisObject-&gt;indexingType()) {
 471         case ALL_CONTIGUOUS_INDEXING_TYPES:
 472             data = butterfly-&gt;contiguous().data();
 473             count = butterfly-&gt;publicLength();
 474             break;
 475         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 476             data = butterfly-&gt;arrayStorage()-&gt;m_vector;
 477             count = butterfly-&gt;arrayStorage()-&gt;vectorLength();
 478             break;
 479         default:
 480             break;
 481         }
 482 
 483         for (uint32_t i = 0; i &lt; count; ++i) {
 484             JSValue toValue = data[i].get();
 485             if (toValue &amp;&amp; toValue.isCell())
 486                 analyzer.analyzeIndexEdge(thisObject, toValue.asCell(), i);
 487         }
 488     }
 489 }
 490 
 491 void JSFinalObject::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 492 {
 493     JSFinalObject* thisObject = jsCast&lt;JSFinalObject*&gt;(cell);
 494     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 495 #if ASSERT_ENABLED
 496     bool wasCheckingForDefaultMarkViolation = visitor.m_isCheckingForDefaultMarkViolation;
 497     visitor.m_isCheckingForDefaultMarkViolation = false;
 498 #endif
 499 
 500     JSCell::visitChildren(thisObject, visitor);
 501 
 502     if (Structure* structure = thisObject-&gt;visitButterfly(visitor)) {
 503         if (unsigned storageSize = structure-&gt;inlineSize())
 504             visitor.appendValuesHidden(thisObject-&gt;inlineStorage(), storageSize);
 505     }
 506 
 507 #if ASSERT_ENABLED
 508     visitor.m_isCheckingForDefaultMarkViolation = wasCheckingForDefaultMarkViolation;
 509 #endif
 510 }
 511 
 512 String JSObject::className(const JSObject* object, VM&amp; vm)
 513 {
 514     const ClassInfo* info = object-&gt;classInfo(vm);
 515     ASSERT(info);
 516     return info-&gt;className;
 517 }
 518 
 519 String JSObject::toStringName(const JSObject* object, JSGlobalObject* globalObject)
 520 {
 521     VM&amp; vm = globalObject-&gt;vm();
 522     const ClassInfo* info = object-&gt;classInfo(vm);
 523     ASSERT(info);
 524     return info-&gt;className;
 525 }
 526 
 527 String JSObject::calculatedClassName(JSObject* object)
 528 {
 529     String constructorFunctionName;
 530     auto* structure = object-&gt;structure();
 531     auto* globalObject = structure-&gt;globalObject();
 532     VM&amp; vm = globalObject-&gt;vm();
 533     auto scope = DECLARE_CATCH_SCOPE(vm);
 534 
 535     // Check for a display name of obj.constructor.
 536     // This is useful to get `Foo` for the `(class Foo).prototype` object.
 537     PropertySlot slot(object, PropertySlot::InternalMethodType::VMInquiry);
 538     if (object-&gt;getOwnPropertySlot(object, globalObject, vm.propertyNames-&gt;constructor, slot)) {
 539         EXCEPTION_ASSERT(!scope.exception());
 540         if (slot.isValue()) {
 541             if (JSObject* ctorObject = jsDynamicCast&lt;JSObject*&gt;(vm, slot.getValue(globalObject, vm.propertyNames-&gt;constructor))) {
 542                 if (JSFunction* constructorFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, ctorObject))
 543                     constructorFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);
 544                 else if (InternalFunction* constructorFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, ctorObject))
 545                     constructorFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);
 546             }
 547         }
 548     }
 549 
 550     EXCEPTION_ASSERT(!scope.exception() || constructorFunctionName.isNull());
 551     if (UNLIKELY(scope.exception()))
 552         scope.clearException();
 553 
 554     // Get the display name of obj.__proto__.constructor.
 555     // This is useful to get `Foo` for a `new Foo` object.
 556     if (constructorFunctionName.isNull()) {
 557         MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
 558         if (LIKELY(structure-&gt;classInfo()-&gt;methodTable.getPrototype == defaultGetPrototype)) {
 559             JSValue protoValue = object-&gt;getPrototypeDirect(vm);
 560             if (protoValue.isObject()) {
 561                 JSObject* protoObject = asObject(protoValue);
 562                 PropertySlot slot(protoValue, PropertySlot::InternalMethodType::VMInquiry);
 563                 if (protoObject-&gt;getPropertySlot(globalObject, vm.propertyNames-&gt;constructor, slot)) {
 564                     EXCEPTION_ASSERT(!scope.exception());
 565                     if (slot.isValue()) {
 566                         if (JSObject* ctorObject = jsDynamicCast&lt;JSObject*&gt;(vm, slot.getValue(globalObject, vm.propertyNames-&gt;constructor))) {
 567                             if (JSFunction* constructorFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, ctorObject))
 568                                 constructorFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);
 569                             else if (InternalFunction* constructorFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, ctorObject))
 570                                 constructorFunctionName = constructorFunction-&gt;calculatedDisplayName(vm);
 571                         }
 572                     }
 573                 }
 574             }
 575         }
 576     }
 577 
 578     EXCEPTION_ASSERT(!scope.exception() || constructorFunctionName.isNull());
 579     if (UNLIKELY(scope.exception()))
 580         scope.clearException();
 581 
 582     if (constructorFunctionName.isNull() || constructorFunctionName == &quot;Object&quot;) {
 583         String tableClassName = object-&gt;methodTable(vm)-&gt;className(object, vm);
 584         if (!tableClassName.isNull() &amp;&amp; tableClassName != &quot;Object&quot;)
 585             return tableClassName;
 586 
 587         String classInfoName = object-&gt;classInfo(vm)-&gt;className;
 588         if (!classInfoName.isNull())
 589             return classInfoName;
 590 
 591         if (constructorFunctionName.isNull())
 592             return &quot;Object&quot;_s;
 593     }
 594 
 595     return constructorFunctionName;
 596 }
 597 
 598 bool JSObject::getOwnPropertySlotByIndex(JSObject* thisObject, JSGlobalObject* globalObject, unsigned i, PropertySlot&amp; slot)
 599 {
 600     VM&amp; vm = globalObject-&gt;vm();
 601 
 602     // NB. The fact that we&#39;re directly consulting our indexed storage implies that it is not
 603     // legal for anyone to override getOwnPropertySlot() without also overriding
 604     // getOwnPropertySlotByIndex().
 605 
 606     if (i &gt; MAX_ARRAY_INDEX)
 607         return thisObject-&gt;methodTable(vm)-&gt;getOwnPropertySlot(thisObject, globalObject, Identifier::from(vm, i), slot);
 608 
 609     switch (thisObject-&gt;indexingType()) {
 610     case ALL_BLANK_INDEXING_TYPES:
 611     case ALL_UNDECIDED_INDEXING_TYPES:
 612         break;
 613 
 614     case ALL_INT32_INDEXING_TYPES:
 615     case ALL_CONTIGUOUS_INDEXING_TYPES: {
 616         Butterfly* butterfly = thisObject-&gt;butterfly();
 617         if (i &gt;= butterfly-&gt;vectorLength())
 618             return false;
 619 
 620         JSValue value = butterfly-&gt;contiguous().at(thisObject, i).get();
 621         if (value) {
 622             slot.setValue(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::None), value);
 623             return true;
 624         }
 625 
 626         return false;
 627     }
 628 
 629     case ALL_DOUBLE_INDEXING_TYPES: {
 630         Butterfly* butterfly = thisObject-&gt;butterfly();
 631         if (i &gt;= butterfly-&gt;vectorLength())
 632             return false;
 633 
 634         double value = butterfly-&gt;contiguousDouble().at(thisObject, i);
 635         if (value == value) {
 636             slot.setValue(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::None), JSValue(JSValue::EncodeAsDouble, value));
 637             return true;
 638         }
 639 
 640         return false;
 641     }
 642 
 643     case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
 644         ArrayStorage* storage = thisObject-&gt;m_butterfly-&gt;arrayStorage();
 645         if (i &gt;= storage-&gt;length())
 646             return false;
 647 
 648         if (i &lt; storage-&gt;vectorLength()) {
 649             JSValue value = storage-&gt;m_vector[i].get();
 650             if (value) {
 651                 slot.setValue(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::None), value);
 652                 return true;
 653             }
 654         } else if (SparseArrayValueMap* map = storage-&gt;m_sparseMap.get()) {
 655             SparseArrayValueMap::iterator it = map-&gt;find(i);
 656             if (it != map-&gt;notFound()) {
 657                 it-&gt;value.get(thisObject, slot);
 658                 return true;
 659             }
 660         }
 661         break;
 662     }
 663 
 664     default:
 665         RELEASE_ASSERT_NOT_REACHED();
 666         break;
 667     }
 668 
 669     return false;
 670 }
 671 
 672 // https://tc39.github.io/ecma262/#sec-ordinaryset
 673 bool ordinarySetSlow(JSGlobalObject* globalObject, JSObject* object, PropertyName propertyName, JSValue value, JSValue receiver, bool shouldThrow)
 674 {
 675     // If we find the receiver is not the same to the object, we fall to this slow path.
 676     // Currently, there are 3 candidates.
 677     // 1. Reflect.set can alter the receiver with an arbitrary value.
 678     // 2. Window Proxy.
 679     // 3. ES6 Proxy.
 680 
 681     VM&amp; vm = globalObject-&gt;vm();
 682     auto scope = DECLARE_THROW_SCOPE(vm);
 683     JSObject* current = object;
 684     PropertyDescriptor ownDescriptor;
 685     while (true) {
 686         if (current-&gt;type() == ProxyObjectType) {
 687             ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(current);
 688             PutPropertySlot slot(receiver, shouldThrow);
 689             RELEASE_AND_RETURN(scope, proxy-&gt;ProxyObject::put(proxy, globalObject, propertyName, value, slot));
 690         }
 691 
 692         // 9.1.9.1-2 Let ownDesc be ? O.[[GetOwnProperty]](P).
 693         bool ownDescriptorFound = current-&gt;getOwnPropertyDescriptor(globalObject, propertyName, ownDescriptor);
 694         RETURN_IF_EXCEPTION(scope, false);
 695 
 696         if (!ownDescriptorFound) {
 697             // 9.1.9.1-3-a Let parent be ? O.[[GetPrototypeOf]]().
 698             JSValue prototype = current-&gt;getPrototype(vm, globalObject);
 699             RETURN_IF_EXCEPTION(scope, false);
 700 
 701             // 9.1.9.1-3-b If parent is not null, then
 702             if (!prototype.isNull()) {
 703                 // 9.1.9.1-3-b-i Return ? parent.[[Set]](P, V, Receiver).
 704                 current = asObject(prototype);
 705                 continue;
 706             }
 707             // 9.1.9.1-3-c-i Let ownDesc be the PropertyDescriptor{[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}.
 708             ownDescriptor = PropertyDescriptor(jsUndefined(), static_cast&lt;unsigned&gt;(PropertyAttribute::None));
 709         }
 710         break;
 711     }
 712 
 713     // 9.1.9.1-4 If IsDataDescriptor(ownDesc) is true, then
 714     if (ownDescriptor.isDataDescriptor()) {
 715         // 9.1.9.1-4-a If ownDesc.[[Writable]] is false, return false.
 716         if (!ownDescriptor.writable())
 717             return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyWriteError);
 718 
 719         // 9.1.9.1-4-b If Type(Receiver) is not Object, return false.
 720         if (!receiver.isObject())
 721             return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyWriteError);
 722 
 723         // In OrdinarySet, the receiver may not be the same to the object.
 724         // So, we perform [[GetOwnProperty]] onto the receiver while we already perform [[GetOwnProperty]] onto the object.
 725 
 726         // 9.1.9.1-4-c Let existingDescriptor be ? Receiver.[[GetOwnProperty]](P).
 727         JSObject* receiverObject = asObject(receiver);
 728         PropertyDescriptor existingDescriptor;
 729         bool existingDescriptorFound = receiverObject-&gt;getOwnPropertyDescriptor(globalObject, propertyName, existingDescriptor);
 730         RETURN_IF_EXCEPTION(scope, false);
 731 
 732         // 9.1.9.1-4-d If existingDescriptor is not undefined, then
 733         if (existingDescriptorFound) {
 734             // 9.1.9.1-4-d-i If IsAccessorDescriptor(existingDescriptor) is true, return false.
 735             if (existingDescriptor.isAccessorDescriptor())
 736                 return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyWriteError);
 737 
 738             // 9.1.9.1-4-d-ii If existingDescriptor.[[Writable]] is false, return false.
 739             if (!existingDescriptor.writable())
 740                 return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyWriteError);
 741 
 742             // 9.1.9.1-4-d-iii Let valueDesc be the PropertyDescriptor{[[Value]]: V}.
 743             PropertyDescriptor valueDescriptor;
 744             valueDescriptor.setValue(value);
 745 
 746             // 9.1.9.1-4-d-iv Return ? Receiver.[[DefineOwnProperty]](P, valueDesc).
 747             RELEASE_AND_RETURN(scope, receiverObject-&gt;methodTable(vm)-&gt;defineOwnProperty(receiverObject, globalObject, propertyName, valueDescriptor, shouldThrow));
 748         }
 749 
 750         // 9.1.9.1-4-e Else Receiver does not currently have a property P,
 751         // 9.1.9.1-4-e-i Return ? CreateDataProperty(Receiver, P, V).
 752         RELEASE_AND_RETURN(scope, receiverObject-&gt;methodTable(vm)-&gt;defineOwnProperty(receiverObject, globalObject, propertyName, PropertyDescriptor(value, static_cast&lt;unsigned&gt;(PropertyAttribute::None)), shouldThrow));
 753     }
 754 
 755     // 9.1.9.1-5 Assert: IsAccessorDescriptor(ownDesc) is true.
 756     ASSERT(ownDescriptor.isAccessorDescriptor());
 757 
 758     // 9.1.9.1-6 Let setter be ownDesc.[[Set]].
 759     // 9.1.9.1-7 If setter is undefined, return false.
 760     JSValue setter = ownDescriptor.setter();
 761     if (!setter.isObject())
 762         return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyWriteError);
 763 
 764     // 9.1.9.1-8 Perform ? Call(setter, Receiver, &lt;&lt; V &gt;&gt;).
 765     JSObject* setterObject = asObject(setter);
 766     MarkedArgumentBuffer args;
 767     args.append(value);
 768     ASSERT(!args.hasOverflowed());
 769 
 770     CallData callData;
 771     CallType callType = setterObject-&gt;methodTable(vm)-&gt;getCallData(setterObject, callData);
 772     scope.release();
 773     call(globalObject, setterObject, callType, callData, receiver, args);
 774 
 775     // 9.1.9.1-9 Return true.
 776     return true;
 777 }
 778 
 779 // ECMA 8.6.2.2
 780 bool JSObject::put(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
 781 {
 782     return putInlineForJSObject(cell, globalObject, propertyName, value, slot);
 783 }
 784 
 785 bool JSObject::putInlineSlow(JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
 786 {
 787     ASSERT(!isThisValueAltered(slot, this));
 788 
 789     VM&amp; vm = globalObject-&gt;vm();
 790     auto scope = DECLARE_THROW_SCOPE(vm);
 791 
 792     JSObject* obj = this;
 793     for (;;) {
 794         Structure* structure = obj-&gt;structure(vm);
 795         if (UNLIKELY(structure-&gt;typeInfo().hasPutPropertySecurityCheck())) {
 796             obj-&gt;methodTable(vm)-&gt;doPutPropertySecurityCheck(obj, globalObject, propertyName, slot);
 797             RETURN_IF_EXCEPTION(scope, false);
 798         }
 799         unsigned attributes;
 800         PropertyOffset offset = structure-&gt;get(vm, propertyName, attributes);
 801         if (isValidOffset(offset)) {
 802             if (attributes &amp; PropertyAttribute::ReadOnly) {
 803                 ASSERT(this-&gt;prototypeChainMayInterceptStoreTo(vm, propertyName) || obj == this);
 804                 return typeError(globalObject, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);
 805             }
 806 
 807             JSValue gs = obj-&gt;getDirect(offset);
 808             if (gs.isGetterSetter()) {
 809                 // We need to make sure that we decide to cache this property before we potentially execute aribitrary JS.
 810                 if (!this-&gt;structure(vm)-&gt;isDictionary())
 811                     slot.setCacheableSetter(obj, offset);
 812 
 813                 bool result = callSetter(globalObject, slot.thisValue(), gs, value, slot.isStrictMode() ? StrictMode : NotStrictMode);
 814                 RETURN_IF_EXCEPTION(scope, false);
 815                 return result;
 816             }
 817             if (gs.isCustomGetterSetter()) {
 818                 // We need to make sure that we decide to cache this property before we potentially execute aribitrary JS.
 819                 if (attributes &amp; PropertyAttribute::CustomAccessor)
 820                     slot.setCustomAccessor(obj, jsCast&lt;CustomGetterSetter*&gt;(gs.asCell())-&gt;setter());
 821                 else
 822                     slot.setCustomValue(obj, jsCast&lt;CustomGetterSetter*&gt;(gs.asCell())-&gt;setter());
 823 
 824                 bool result = callCustomSetter(globalObject, gs, attributes &amp; PropertyAttribute::CustomAccessor, obj, slot.thisValue(), value);
 825                 RETURN_IF_EXCEPTION(scope, false);
 826                 return result;
 827             }
 828             ASSERT(!(attributes &amp; PropertyAttribute::Accessor));
 829 
 830             // If there&#39;s an existing property on the base object, or on one of its
 831             // prototypes, we should store the property on the *base* object.
 832             break;
 833         }
 834         if (!obj-&gt;staticPropertiesReified(vm)) {
 835             if (obj-&gt;classInfo(vm)-&gt;hasStaticSetterOrReadonlyProperties()) {
 836                 if (auto entry = obj-&gt;findPropertyHashEntry(vm, propertyName))
 837                     RELEASE_AND_RETURN(scope, putEntry(globalObject, entry-&gt;table-&gt;classForThis, entry-&gt;value, obj, this, propertyName, value, slot));
 838             }
 839         }
 840         if (obj-&gt;type() == ProxyObjectType) {
 841             ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(obj);
 842             RELEASE_AND_RETURN(scope, proxy-&gt;ProxyObject::put(proxy, globalObject, propertyName, value, slot));
 843         }
 844         JSValue prototype = obj-&gt;getPrototype(vm, globalObject);
 845         RETURN_IF_EXCEPTION(scope, false);
 846         if (prototype.isNull())
 847             break;
 848         obj = asObject(prototype);
 849     }
 850 
 851     if (!putDirectInternal&lt;PutModePut&gt;(vm, propertyName, value, 0, slot))
 852         return typeError(globalObject, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);
 853     return true;
 854 }
 855 
 856 bool JSObject::putByIndex(JSCell* cell, JSGlobalObject* globalObject, unsigned propertyName, JSValue value, bool shouldThrow)
 857 {
 858     VM&amp; vm = globalObject-&gt;vm();
 859     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
 860 
 861     if (propertyName &gt; MAX_ARRAY_INDEX) {
 862         PutPropertySlot slot(cell, shouldThrow);
 863         return thisObject-&gt;methodTable(vm)-&gt;put(thisObject, globalObject, Identifier::from(vm, propertyName), value, slot);
 864     }
 865 
 866     thisObject-&gt;ensureWritable(vm);
 867 
 868     switch (thisObject-&gt;indexingType()) {
 869     case ALL_BLANK_INDEXING_TYPES:
 870         break;
 871 
 872     case ALL_UNDECIDED_INDEXING_TYPES: {
 873         thisObject-&gt;convertUndecidedForValue(vm, value);
 874         // Reloop.
 875         return putByIndex(cell, globalObject, propertyName, value, shouldThrow);
 876     }
 877 
 878     case ALL_INT32_INDEXING_TYPES: {
 879         if (!value.isInt32()) {
 880             thisObject-&gt;convertInt32ForValue(vm, value);
 881             return putByIndex(cell, globalObject, propertyName, value, shouldThrow);
 882         }
 883         FALLTHROUGH;
 884     }
 885 
 886     case ALL_CONTIGUOUS_INDEXING_TYPES: {
 887         Butterfly* butterfly = thisObject-&gt;butterfly();
 888         if (propertyName &gt;= butterfly-&gt;vectorLength())
 889             break;
 890         butterfly-&gt;contiguous().at(thisObject, propertyName).setWithoutWriteBarrier(value);
 891         if (propertyName &gt;= butterfly-&gt;publicLength())
 892             butterfly-&gt;setPublicLength(propertyName + 1);
 893         vm.heap.writeBarrier(thisObject, value);
 894         return true;
 895     }
 896 
 897     case ALL_DOUBLE_INDEXING_TYPES: {
 898         if (!value.isNumber()) {
 899             thisObject-&gt;convertDoubleToContiguous(vm);
 900             // Reloop.
 901             return putByIndex(cell, globalObject, propertyName, value, shouldThrow);
 902         }
 903 
 904         double valueAsDouble = value.asNumber();
 905         if (valueAsDouble != valueAsDouble) {
 906             thisObject-&gt;convertDoubleToContiguous(vm);
 907             // Reloop.
 908             return putByIndex(cell, globalObject, propertyName, value, shouldThrow);
 909         }
 910         Butterfly* butterfly = thisObject-&gt;butterfly();
 911         if (propertyName &gt;= butterfly-&gt;vectorLength())
 912             break;
 913         butterfly-&gt;contiguousDouble().at(thisObject, propertyName) = valueAsDouble;
 914         if (propertyName &gt;= butterfly-&gt;publicLength())
 915             butterfly-&gt;setPublicLength(propertyName + 1);
 916         return true;
 917     }
 918 
 919     case NonArrayWithArrayStorage:
 920     case ArrayWithArrayStorage: {
 921         ArrayStorage* storage = thisObject-&gt;m_butterfly-&gt;arrayStorage();
 922 
 923         if (propertyName &gt;= storage-&gt;vectorLength())
 924             break;
 925 
 926         WriteBarrier&lt;Unknown&gt;&amp; valueSlot = storage-&gt;m_vector[propertyName];
 927         unsigned length = storage-&gt;length();
 928 
 929         // Update length &amp; m_numValuesInVector as necessary.
 930         if (propertyName &gt;= length) {
 931             length = propertyName + 1;
 932             storage-&gt;setLength(length);
 933             ++storage-&gt;m_numValuesInVector;
 934         } else if (!valueSlot)
 935             ++storage-&gt;m_numValuesInVector;
 936 
 937         valueSlot.set(vm, thisObject, value);
 938         return true;
 939     }
 940 
 941     case NonArrayWithSlowPutArrayStorage:
 942     case ArrayWithSlowPutArrayStorage: {
 943         ArrayStorage* storage = thisObject-&gt;m_butterfly-&gt;arrayStorage();
 944 
 945         if (propertyName &gt;= storage-&gt;vectorLength())
 946             break;
 947 
 948         WriteBarrier&lt;Unknown&gt;&amp; valueSlot = storage-&gt;m_vector[propertyName];
 949         unsigned length = storage-&gt;length();
 950 
 951         auto scope = DECLARE_THROW_SCOPE(vm);
 952 
 953         // Update length &amp; m_numValuesInVector as necessary.
 954         if (propertyName &gt;= length) {
 955             bool putResult = false;
 956             bool result = thisObject-&gt;attemptToInterceptPutByIndexOnHole(globalObject, propertyName, value, shouldThrow, putResult);
 957             RETURN_IF_EXCEPTION(scope, false);
 958             if (result)
 959                 return putResult;
 960             length = propertyName + 1;
 961             storage-&gt;setLength(length);
 962             ++storage-&gt;m_numValuesInVector;
 963         } else if (!valueSlot) {
 964             bool putResult = false;
 965             bool result = thisObject-&gt;attemptToInterceptPutByIndexOnHole(globalObject, propertyName, value, shouldThrow, putResult);
 966             RETURN_IF_EXCEPTION(scope, false);
 967             if (result)
 968                 return putResult;
 969             ++storage-&gt;m_numValuesInVector;
 970         }
 971 
 972         valueSlot.set(vm, thisObject, value);
 973         return true;
 974     }
 975 
 976     default:
 977         RELEASE_ASSERT_NOT_REACHED();
 978     }
 979 
 980     return thisObject-&gt;putByIndexBeyondVectorLength(globalObject, propertyName, value, shouldThrow);
 981 }
 982 
 983 ArrayStorage* JSObject::enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(VM&amp; vm, ArrayStorage* storage)
 984 {
 985     SparseArrayValueMap* map = storage-&gt;m_sparseMap.get();
 986 
 987     if (!map)
 988         map = allocateSparseIndexMap(vm);
 989 
 990     if (map-&gt;sparseMode())
 991         return storage;
 992 
 993     map-&gt;setSparseMode();
 994 
 995     unsigned usedVectorLength = std::min(storage-&gt;length(), storage-&gt;vectorLength());
 996     for (unsigned i = 0; i &lt; usedVectorLength; ++i) {
 997         JSValue value = storage-&gt;m_vector[i].get();
 998         // This will always be a new entry in the map, so no need to check we can write,
 999         // and attributes are default so no need to set them.
1000         if (value)
1001             map-&gt;add(this, i).iterator-&gt;value.forceSet(vm, map, value, 0);
1002     }
1003 
1004     DeferGC deferGC(vm.heap);
1005     Butterfly* newButterfly = storage-&gt;butterfly()-&gt;resizeArray(vm, this, structure(vm), 0, ArrayStorage::sizeFor(0));
1006     RELEASE_ASSERT(newButterfly);
1007     newButterfly-&gt;arrayStorage()-&gt;m_indexBias = 0;
1008     newButterfly-&gt;arrayStorage()-&gt;setVectorLength(0);
1009     newButterfly-&gt;arrayStorage()-&gt;m_sparseMap.set(vm, this, map);
1010     setButterfly(vm, newButterfly);
1011 
1012     return newButterfly-&gt;arrayStorage();
1013 }
1014 
1015 void JSObject::enterDictionaryIndexingMode(VM&amp; vm)
1016 {
1017     switch (indexingType()) {
1018     case ALL_BLANK_INDEXING_TYPES:
1019     case ALL_UNDECIDED_INDEXING_TYPES:
1020     case ALL_INT32_INDEXING_TYPES:
1021     case ALL_DOUBLE_INDEXING_TYPES:
1022     case ALL_CONTIGUOUS_INDEXING_TYPES:
1023         // NOTE: this is horribly inefficient, as it will perform two conversions. We could optimize
1024         // this case if we ever cared. Note that ensureArrayStorage() can return null if the object
1025         // doesn&#39;t support traditional indexed properties. At the time of writing, this just affects
1026         // typed arrays.
1027         if (ArrayStorage* storage = ensureArrayStorageSlow(vm))
1028             enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(vm, storage);
1029         break;
1030     case ALL_ARRAY_STORAGE_INDEXING_TYPES:
1031         enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(vm, m_butterfly-&gt;arrayStorage());
1032         break;
1033 
1034     default:
1035         break;
1036     }
1037 }
1038 
1039 void JSObject::notifyPresenceOfIndexedAccessors(VM&amp; vm)
1040 {
1041     if (mayInterceptIndexedAccesses(vm))
1042         return;
1043 
1044     setStructure(vm, Structure::nonPropertyTransition(vm, structure(vm), NonPropertyTransition::AddIndexedAccessors));
1045 
1046     if (!mayBePrototype())
1047         return;
1048 
1049     globalObject(vm)-&gt;haveABadTime(vm);
1050 }
1051 
1052 Butterfly* JSObject::createInitialIndexedStorage(VM&amp; vm, unsigned length)
1053 {
1054     ASSERT(length &lt;= MAX_STORAGE_VECTOR_LENGTH);
1055     IndexingType oldType = indexingType();
1056     ASSERT_UNUSED(oldType, !hasIndexedProperties(oldType));
1057     ASSERT(!needsSlowPutIndexing(vm));
1058     ASSERT(!indexingShouldBeSparse(vm));
1059     Structure* structure = this-&gt;structure(vm);
1060     unsigned propertyCapacity = structure-&gt;outOfLineCapacity();
1061     unsigned vectorLength = Butterfly::optimalContiguousVectorLength(propertyCapacity, length);
1062     Butterfly* newButterfly = Butterfly::createOrGrowArrayRight(
1063         butterfly(), vm, this, structure, propertyCapacity, false, 0,
1064         sizeof(EncodedJSValue) * vectorLength);
1065     newButterfly-&gt;setPublicLength(length);
1066     newButterfly-&gt;setVectorLength(vectorLength);
1067     return newButterfly;
1068 }
1069 
1070 Butterfly* JSObject::createInitialUndecided(VM&amp; vm, unsigned length)
1071 {
1072     DeferGC deferGC(vm.heap);
1073     Butterfly* newButterfly = createInitialIndexedStorage(vm, length);
1074     StructureID oldStructureID = this-&gt;structureID();
1075     Structure* oldStructure = vm.getStructure(oldStructureID);
1076     Structure* newStructure = Structure::nonPropertyTransition(vm, oldStructure, NonPropertyTransition::AllocateUndecided);
1077     nukeStructureAndSetButterfly(vm, oldStructureID, newButterfly);
1078     setStructure(vm, newStructure);
1079     return newButterfly;
1080 }
1081 
1082 ContiguousJSValues JSObject::createInitialInt32(VM&amp; vm, unsigned length)
1083 {
1084     DeferGC deferGC(vm.heap);
1085     Butterfly* newButterfly = createInitialIndexedStorage(vm, length);
1086     for (unsigned i = newButterfly-&gt;vectorLength(); i--;)
1087         newButterfly-&gt;contiguous().at(this, i).setWithoutWriteBarrier(JSValue());
1088     StructureID oldStructureID = this-&gt;structureID();
1089     Structure* oldStructure = vm.getStructure(oldStructureID);
1090     Structure* newStructure = Structure::nonPropertyTransition(vm, oldStructure, NonPropertyTransition::AllocateInt32);
1091     nukeStructureAndSetButterfly(vm, oldStructureID, newButterfly);
1092     setStructure(vm, newStructure);
1093     return newButterfly-&gt;contiguousInt32();
1094 }
1095 
1096 ContiguousDoubles JSObject::createInitialDouble(VM&amp; vm, unsigned length)
1097 {
1098     DeferGC deferGC(vm.heap);
1099     Butterfly* newButterfly = createInitialIndexedStorage(vm, length);
1100     for (unsigned i = newButterfly-&gt;vectorLength(); i--;)
1101         newButterfly-&gt;contiguousDouble().at(this, i) = PNaN;
1102     StructureID oldStructureID = this-&gt;structureID();
1103     Structure* oldStructure = vm.getStructure(oldStructureID);
1104     Structure* newStructure = Structure::nonPropertyTransition(vm, oldStructure, NonPropertyTransition::AllocateDouble);
1105     nukeStructureAndSetButterfly(vm, oldStructureID, newButterfly);
1106     setStructure(vm, newStructure);
1107     return newButterfly-&gt;contiguousDouble();
1108 }
1109 
1110 ContiguousJSValues JSObject::createInitialContiguous(VM&amp; vm, unsigned length)
1111 {
1112     DeferGC deferGC(vm.heap);
1113     Butterfly* newButterfly = createInitialIndexedStorage(vm, length);
1114     for (unsigned i = newButterfly-&gt;vectorLength(); i--;)
1115         newButterfly-&gt;contiguous().at(this, i).setWithoutWriteBarrier(JSValue());
1116     StructureID oldStructureID = this-&gt;structureID();
1117     Structure* oldStructure = vm.getStructure(oldStructureID);
1118     Structure* newStructure = Structure::nonPropertyTransition(vm, oldStructure, NonPropertyTransition::AllocateContiguous);
1119     nukeStructureAndSetButterfly(vm, oldStructureID, newButterfly);
1120     setStructure(vm, newStructure);
1121     return newButterfly-&gt;contiguous();
1122 }
1123 
1124 Butterfly* JSObject::createArrayStorageButterfly(VM&amp; vm, JSObject* intendedOwner, Structure* structure, unsigned length, unsigned vectorLength, Butterfly* oldButterfly)
1125 {
1126     Butterfly* newButterfly = Butterfly::createOrGrowArrayRight(
1127         oldButterfly, vm, intendedOwner, structure, structure-&gt;outOfLineCapacity(), false, 0,
1128         ArrayStorage::sizeFor(vectorLength));
1129     RELEASE_ASSERT(newButterfly);
1130 
1131     ArrayStorage* result = newButterfly-&gt;arrayStorage();
1132     result-&gt;setLength(length);
1133     result-&gt;setVectorLength(vectorLength);
1134     result-&gt;m_sparseMap.clear();
1135     result-&gt;m_numValuesInVector = 0;
1136     result-&gt;m_indexBias = 0;
1137     for (size_t i = vectorLength; i--;)
1138         result-&gt;m_vector[i].setWithoutWriteBarrier(JSValue());
1139 
1140     return newButterfly;
1141 }
1142 
1143 ArrayStorage* JSObject::createArrayStorage(VM&amp; vm, unsigned length, unsigned vectorLength)
1144 {
1145     DeferGC deferGC(vm.heap);
1146     StructureID oldStructureID = this-&gt;structureID();
1147     Structure* oldStructure = vm.getStructure(oldStructureID);
1148     IndexingType oldType = indexingType();
1149     ASSERT_UNUSED(oldType, !hasIndexedProperties(oldType));
1150 
1151     Butterfly* newButterfly = createArrayStorageButterfly(vm, this, oldStructure, length, vectorLength, butterfly());
1152     ArrayStorage* result = newButterfly-&gt;arrayStorage();
1153     Structure* newStructure = Structure::nonPropertyTransition(vm, oldStructure, suggestedArrayStorageTransition(vm));
1154     nukeStructureAndSetButterfly(vm, oldStructureID, newButterfly);
1155     setStructure(vm, newStructure);
1156     return result;
1157 }
1158 
1159 ArrayStorage* JSObject::createInitialArrayStorage(VM&amp; vm)
1160 {
1161     return createArrayStorage(
1162         vm, 0, ArrayStorage::optimalVectorLength(0, structure(vm)-&gt;outOfLineCapacity(), 0));
1163 }
1164 
1165 ContiguousJSValues JSObject::convertUndecidedToInt32(VM&amp; vm)
1166 {
1167     ASSERT(hasUndecided(indexingType()));
1168 
1169     Butterfly* butterfly = this-&gt;butterfly();
1170     for (unsigned i = butterfly-&gt;vectorLength(); i--;)
1171         butterfly-&gt;contiguous().at(this, i).setWithoutWriteBarrier(JSValue());
1172 
1173     setStructure(vm, Structure::nonPropertyTransition(vm, structure(vm), NonPropertyTransition::AllocateInt32));
1174     return m_butterfly-&gt;contiguousInt32();
1175 }
1176 
1177 ContiguousDoubles JSObject::convertUndecidedToDouble(VM&amp; vm)
1178 {
1179     ASSERT(hasUndecided(indexingType()));
1180 
1181     Butterfly* butterfly = m_butterfly.get();
1182     for (unsigned i = butterfly-&gt;vectorLength(); i--;)
1183         butterfly-&gt;contiguousDouble().at(this, i) = PNaN;
1184 
1185     setStructure(vm, Structure::nonPropertyTransition(vm, structure(vm), NonPropertyTransition::AllocateDouble));
1186     return m_butterfly-&gt;contiguousDouble();
1187 }
1188 
1189 ContiguousJSValues JSObject::convertUndecidedToContiguous(VM&amp; vm)
1190 {
1191     ASSERT(hasUndecided(indexingType()));
1192 
1193     Butterfly* butterfly = m_butterfly.get();
1194     for (unsigned i = butterfly-&gt;vectorLength(); i--;)
1195         butterfly-&gt;contiguous().at(this, i).setWithoutWriteBarrier(JSValue());
1196 
1197     WTF::storeStoreFence();
1198     setStructure(vm, Structure::nonPropertyTransition(vm, structure(vm), NonPropertyTransition::AllocateContiguous));
1199     return m_butterfly-&gt;contiguous();
1200 }
1201 
1202 ArrayStorage* JSObject::constructConvertedArrayStorageWithoutCopyingElements(VM&amp; vm, unsigned neededLength)
1203 {
1204     Structure* structure = this-&gt;structure(vm);
1205     unsigned publicLength = m_butterfly-&gt;publicLength();
1206     unsigned propertyCapacity = structure-&gt;outOfLineCapacity();
1207 
1208     Butterfly* newButterfly = Butterfly::createUninitialized(vm, this, 0, propertyCapacity, true, ArrayStorage::sizeFor(neededLength));
1209 
1210     gcSafeMemcpy(
1211         static_cast&lt;JSValue*&gt;(newButterfly-&gt;base(0, propertyCapacity)),
1212         static_cast&lt;JSValue*&gt;(m_butterfly-&gt;base(0, propertyCapacity)),
1213         propertyCapacity * sizeof(EncodedJSValue));
1214 
1215     ArrayStorage* newStorage = newButterfly-&gt;arrayStorage();
1216     newStorage-&gt;setVectorLength(neededLength);
1217     newStorage-&gt;setLength(publicLength);
1218     newStorage-&gt;m_sparseMap.clear();
1219     newStorage-&gt;m_indexBias = 0;
1220     newStorage-&gt;m_numValuesInVector = 0;
1221 
1222     return newStorage;
1223 }
1224 
1225 ArrayStorage* JSObject::convertUndecidedToArrayStorage(VM&amp; vm, NonPropertyTransition transition)
1226 {
1227     DeferGC deferGC(vm.heap);
1228     ASSERT(hasUndecided(indexingType()));
1229 
1230     unsigned vectorLength = m_butterfly-&gt;vectorLength();
1231     ArrayStorage* storage = constructConvertedArrayStorageWithoutCopyingElements(vm, vectorLength);
1232 
1233     for (unsigned i = vectorLength; i--;)
1234         storage-&gt;m_vector[i].setWithoutWriteBarrier(JSValue());
1235 
1236     StructureID oldStructureID = this-&gt;structureID();
1237     Structure* oldStructure = vm.getStructure(oldStructureID);
1238     Structure* newStructure = Structure::nonPropertyTransition(vm, oldStructure, transition);
1239     nukeStructureAndSetButterfly(vm, oldStructureID, storage-&gt;butterfly());
1240     setStructure(vm, newStructure);
1241     return storage;
1242 }
1243 
1244 ArrayStorage* JSObject::convertUndecidedToArrayStorage(VM&amp; vm)
1245 {
1246     return convertUndecidedToArrayStorage(vm, suggestedArrayStorageTransition(vm));
1247 }
1248 
1249 ContiguousDoubles JSObject::convertInt32ToDouble(VM&amp; vm)
1250 {
1251     ASSERT(hasInt32(indexingType()));
1252     ASSERT(!isCopyOnWrite(indexingMode()));
1253 
1254     Butterfly* butterfly = m_butterfly.get();
1255     for (unsigned i = butterfly-&gt;vectorLength(); i--;) {
1256         WriteBarrier&lt;Unknown&gt;* current = &amp;butterfly-&gt;contiguous().atUnsafe(i);
1257         double* currentAsDouble = bitwise_cast&lt;double*&gt;(current);
1258         JSValue v = current-&gt;get();
1259         // NOTE: Since this may be used during initialization, v could be garbage. If it&#39;s garbage,
1260         // that means it will be overwritten later.
1261         if (!v.isInt32()) {
1262             *currentAsDouble = PNaN;
1263             continue;
1264         }
1265         *currentAsDouble = v.asInt32();
1266     }
1267 
1268     setStructure(vm, Structure::nonPropertyTransition(vm, structure(vm), NonPropertyTransition::AllocateDouble));
1269     return m_butterfly-&gt;contiguousDouble();
1270 }
1271 
1272 ContiguousJSValues JSObject::convertInt32ToContiguous(VM&amp; vm)
1273 {
1274     ASSERT(hasInt32(indexingType()));
1275 
1276     setStructure(vm, Structure::nonPropertyTransition(vm, structure(vm), NonPropertyTransition::AllocateContiguous));
1277     return m_butterfly-&gt;contiguous();
1278 }
1279 
1280 ArrayStorage* JSObject::convertInt32ToArrayStorage(VM&amp; vm, NonPropertyTransition transition)
1281 {
1282     DeferGC deferGC(vm.heap);
1283     ASSERT(hasInt32(indexingType()));
1284 
1285     unsigned vectorLength = m_butterfly-&gt;vectorLength();
1286     ArrayStorage* newStorage = constructConvertedArrayStorageWithoutCopyingElements(vm, vectorLength);
1287     Butterfly* butterfly = m_butterfly.get();
1288     for (unsigned i = 0; i &lt; vectorLength; i++) {
1289         JSValue v = butterfly-&gt;contiguous().at(this, i).get();
1290         newStorage-&gt;m_vector[i].setWithoutWriteBarrier(v);
1291         if (v)
1292             newStorage-&gt;m_numValuesInVector++;
1293     }
1294 
1295     StructureID oldStructureID = this-&gt;structureID();
1296     Structure* oldStructure = vm.getStructure(oldStructureID);
1297     Structure* newStructure = Structure::nonPropertyTransition(vm, oldStructure, transition);
1298     nukeStructureAndSetButterfly(vm, oldStructureID, newStorage-&gt;butterfly());
1299     setStructure(vm, newStructure);
1300     return newStorage;
1301 }
1302 
1303 ArrayStorage* JSObject::convertInt32ToArrayStorage(VM&amp; vm)
1304 {
1305     return convertInt32ToArrayStorage(vm, suggestedArrayStorageTransition(vm));
1306 }
1307 
1308 ContiguousJSValues JSObject::convertDoubleToContiguous(VM&amp; vm)
1309 {
1310     ASSERT(hasDouble(indexingType()));
1311     ASSERT(!isCopyOnWrite(indexingMode()));
1312 
1313     Butterfly* butterfly = m_butterfly.get();
1314     for (unsigned i = butterfly-&gt;vectorLength(); i--;) {
1315         double* current = &amp;butterfly-&gt;contiguousDouble().atUnsafe(i);
1316         WriteBarrier&lt;Unknown&gt;* currentAsValue = bitwise_cast&lt;WriteBarrier&lt;Unknown&gt;*&gt;(current);
1317         double value = *current;
1318         if (value != value) {
1319             currentAsValue-&gt;clear();
1320             continue;
1321         }
1322         JSValue v = JSValue(JSValue::EncodeAsDouble, value);
1323         currentAsValue-&gt;setWithoutWriteBarrier(v);
1324     }
1325 
1326     WTF::storeStoreFence();
1327     setStructure(vm, Structure::nonPropertyTransition(vm, structure(vm), NonPropertyTransition::AllocateContiguous));
1328     return m_butterfly-&gt;contiguous();
1329 }
1330 
1331 ArrayStorage* JSObject::convertDoubleToArrayStorage(VM&amp; vm, NonPropertyTransition transition)
1332 {
1333     DeferGC deferGC(vm.heap);
1334     ASSERT(hasDouble(indexingType()));
1335 
1336     unsigned vectorLength = m_butterfly-&gt;vectorLength();
1337     ArrayStorage* newStorage = constructConvertedArrayStorageWithoutCopyingElements(vm, vectorLength);
1338     Butterfly* butterfly = m_butterfly.get();
1339     for (unsigned i = 0; i &lt; vectorLength; i++) {
1340         double value = butterfly-&gt;contiguousDouble().at(this, i);
1341         if (value != value) {
1342             newStorage-&gt;m_vector[i].clear();
1343             continue;
1344         }
1345         newStorage-&gt;m_vector[i].setWithoutWriteBarrier(JSValue(JSValue::EncodeAsDouble, value));
1346         newStorage-&gt;m_numValuesInVector++;
1347     }
1348 
1349     StructureID oldStructureID = this-&gt;structureID();
1350     Structure* oldStructure = vm.getStructure(oldStructureID);
1351     Structure* newStructure = Structure::nonPropertyTransition(vm, oldStructure, transition);
1352     nukeStructureAndSetButterfly(vm, oldStructureID, newStorage-&gt;butterfly());
1353     setStructure(vm, newStructure);
1354     return newStorage;
1355 }
1356 
1357 ArrayStorage* JSObject::convertDoubleToArrayStorage(VM&amp; vm)
1358 {
1359     return convertDoubleToArrayStorage(vm, suggestedArrayStorageTransition(vm));
1360 }
1361 
1362 ArrayStorage* JSObject::convertContiguousToArrayStorage(VM&amp; vm, NonPropertyTransition transition)
1363 {
1364     DeferGC deferGC(vm.heap);
1365     ASSERT(hasContiguous(indexingType()));
1366 
1367     unsigned vectorLength = m_butterfly-&gt;vectorLength();
1368     ArrayStorage* newStorage = constructConvertedArrayStorageWithoutCopyingElements(vm, vectorLength);
1369     Butterfly* butterfly = m_butterfly.get();
1370     for (unsigned i = 0; i &lt; vectorLength; i++) {
1371         JSValue v = butterfly-&gt;contiguous().at(this, i).get();
1372         newStorage-&gt;m_vector[i].setWithoutWriteBarrier(v);
1373         if (v)
1374             newStorage-&gt;m_numValuesInVector++;
1375     }
1376 
1377     // While we modify the butterfly of Contiguous Array, we do not take any cellLock here. This is because
1378     // (1) the old butterfly is not changed and (2) new butterfly is not changed after it is exposed to
1379     // the collector.
1380     // The mutator performs the following operations are sequentially executed by using storeStoreFence.
1381     //
1382     //     CreateNewButterfly NukeStructure ChangeButterfly PutNewStructure
1383     //
1384     // Meanwhile the collector performs the following steps sequentially:
1385     //
1386     //     ReadStructureEarly ReadButterfly ReadStructureLate
1387     //
1388     // We list up all the patterns by writing a tiny script, and ensure all the cases are categorized into BEFORE, AFTER, and IGNORE.
1389     //
1390     // CreateNewButterfly NukeStructure ChangeButterfly PutNewStructure ReadStructureEarly ReadButterfly ReadStructureLate: AFTER, trivially
1391     // CreateNewButterfly NukeStructure ChangeButterfly ReadStructureEarly PutNewStructure ReadButterfly ReadStructureLate: IGNORE, because nuked structure read early
1392     // CreateNewButterfly NukeStructure ChangeButterfly ReadStructureEarly ReadButterfly PutNewStructure ReadStructureLate: IGNORE, because nuked structure read early
1393     // CreateNewButterfly NukeStructure ChangeButterfly ReadStructureEarly ReadButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read early
1394     // CreateNewButterfly NukeStructure ReadStructureEarly ChangeButterfly PutNewStructure ReadButterfly ReadStructureLate: IGNORE, because nuked structure read early
1395     // CreateNewButterfly NukeStructure ReadStructureEarly ChangeButterfly ReadButterfly PutNewStructure ReadStructureLate: IGNORE, because nuked structure read early
1396     // CreateNewButterfly NukeStructure ReadStructureEarly ChangeButterfly ReadButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read early
1397     // CreateNewButterfly NukeStructure ReadStructureEarly ReadButterfly ChangeButterfly PutNewStructure ReadStructureLate: IGNORE, because nuked structure read early
1398     // CreateNewButterfly NukeStructure ReadStructureEarly ReadButterfly ChangeButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read early
1399     // CreateNewButterfly NukeStructure ReadStructureEarly ReadButterfly ReadStructureLate ChangeButterfly PutNewStructure: IGNORE, because nuked structure read early
1400     // CreateNewButterfly ReadStructureEarly NukeStructure ChangeButterfly PutNewStructure ReadButterfly ReadStructureLate: IGNORE, because early and late structures don&#39;t match
1401     // CreateNewButterfly ReadStructureEarly NukeStructure ChangeButterfly ReadButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
1402     // CreateNewButterfly ReadStructureEarly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
1403     // CreateNewButterfly ReadStructureEarly NukeStructure ReadButterfly ChangeButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
1404     // CreateNewButterfly ReadStructureEarly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
1405     // CreateNewButterfly ReadStructureEarly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly PutNewStructure: IGNORE, because nuked structure read late
1406     // CreateNewButterfly ReadStructureEarly ReadButterfly NukeStructure ChangeButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
1407     // CreateNewButterfly ReadStructureEarly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
1408     // CreateNewButterfly ReadStructureEarly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly PutNewStructure: IGNORE, because nuked structure read late
1409     // CreateNewButterfly ReadStructureEarly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly PutNewStructure: BEFORE, trivially.
1410     // ReadStructureEarly CreateNewButterfly NukeStructure ChangeButterfly PutNewStructure ReadButterfly ReadStructureLate: IGNORE, because early and late structures don&#39;t match
1411     // ReadStructureEarly CreateNewButterfly NukeStructure ChangeButterfly ReadButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
1412     // ReadStructureEarly CreateNewButterfly NukeStructure ChangeButterfly ReadButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
1413     // ReadStructureEarly CreateNewButterfly NukeStructure ReadButterfly ChangeButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
1414     // ReadStructureEarly CreateNewButterfly NukeStructure ReadButterfly ChangeButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
1415     // ReadStructureEarly CreateNewButterfly NukeStructure ReadButterfly ReadStructureLate ChangeButterfly PutNewStructure: IGNORE, because nuked structure read late
1416     // ReadStructureEarly CreateNewButterfly ReadButterfly NukeStructure ChangeButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
1417     // ReadStructureEarly CreateNewButterfly ReadButterfly NukeStructure ChangeButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
1418     // ReadStructureEarly CreateNewButterfly ReadButterfly NukeStructure ReadStructureLate ChangeButterfly PutNewStructure: IGNORE, because nuked structure read late
1419     // ReadStructureEarly CreateNewButterfly ReadButterfly ReadStructureLate NukeStructure ChangeButterfly PutNewStructure: BEFORE, CreateNewButterfly is not visible to collector.
1420     // ReadStructureEarly ReadButterfly CreateNewButterfly NukeStructure ChangeButterfly PutNewStructure ReadStructureLate: IGNORE, because early and late structures don&#39;t match
1421     // ReadStructureEarly ReadButterfly CreateNewButterfly NukeStructure ChangeButterfly ReadStructureLate PutNewStructure: IGNORE, because nuked structure read late
1422     // ReadStructureEarly ReadButterfly CreateNewButterfly NukeStructure ReadStructureLate ChangeButterfly PutNewStructure: IGNORE, because nuked structure read late
1423     // ReadStructureEarly ReadButterfly CreateNewButterfly ReadStructureLate NukeStructure ChangeButterfly PutNewStructure: BEFORE, CreateNewButterfly is not visible to collector.
1424     // ReadStructureEarly ReadButterfly ReadStructureLate CreateNewButterfly NukeStructure ChangeButterfly PutNewStructure: BEFORE, trivially.
1425 
1426     ASSERT(newStorage-&gt;butterfly() != butterfly);
1427     StructureID oldStructureID = this-&gt;structureID();
1428     Structure* oldStructure = vm.getStructure(oldStructureID);
1429     Structure* newStructure = Structure::nonPropertyTransition(vm, oldStructure, transition);
1430 
1431     // Ensure new Butterfly initialization is correctly done before exposing it to the concurrent threads.
1432     if (isX86() || vm.heap.mutatorShouldBeFenced())
1433         WTF::storeStoreFence();
1434     nukeStructureAndSetButterfly(vm, oldStructureID, newStorage-&gt;butterfly());
1435     setStructure(vm, newStructure);
1436 
1437     return newStorage;
1438 }
1439 
1440 ArrayStorage* JSObject::convertContiguousToArrayStorage(VM&amp; vm)
1441 {
1442     return convertContiguousToArrayStorage(vm, suggestedArrayStorageTransition(vm));
1443 }
1444 
1445 void JSObject::convertUndecidedForValue(VM&amp; vm, JSValue value)
1446 {
1447     IndexingType type = indexingTypeForValue(value);
1448     if (type == Int32Shape) {
1449         convertUndecidedToInt32(vm);
1450         return;
1451     }
1452 
1453     if (type == DoubleShape) {
1454         convertUndecidedToDouble(vm);
1455         return;
1456     }
1457 
1458     ASSERT(type == ContiguousShape);
1459     convertUndecidedToContiguous(vm);
1460 }
1461 
1462 void JSObject::createInitialForValueAndSet(VM&amp; vm, unsigned index, JSValue value)
1463 {
1464     if (value.isInt32()) {
1465         createInitialInt32(vm, index + 1).at(this, index).set(vm, this, value);
1466         return;
1467     }
1468 
1469     if (value.isDouble()) {
1470         double doubleValue = value.asNumber();
1471         if (doubleValue == doubleValue) {
1472             createInitialDouble(vm, index + 1).at(this, index) = doubleValue;
1473             return;
1474         }
1475     }
1476 
1477     createInitialContiguous(vm, index + 1).at(this, index).set(vm, this, value);
1478 }
1479 
1480 void JSObject::convertInt32ForValue(VM&amp; vm, JSValue value)
1481 {
1482     ASSERT(!value.isInt32());
1483 
1484     if (value.isDouble() &amp;&amp; !std::isnan(value.asDouble())) {
1485         convertInt32ToDouble(vm);
1486         return;
1487     }
1488 
1489     convertInt32ToContiguous(vm);
1490 }
1491 
1492 void JSObject::convertFromCopyOnWrite(VM&amp; vm)
1493 {
1494     ASSERT(isCopyOnWrite(indexingMode()));
1495     ASSERT(structure(vm)-&gt;indexingMode() == indexingMode());
1496 
1497     const bool hasIndexingHeader = true;
1498     Butterfly* oldButterfly = butterfly();
1499     size_t propertyCapacity = 0;
1500     unsigned newVectorLength = Butterfly::optimalContiguousVectorLength(propertyCapacity, std::min(oldButterfly-&gt;vectorLength() * 2, MAX_STORAGE_VECTOR_LENGTH));
1501     Butterfly* newButterfly = Butterfly::createUninitialized(vm, this, 0, propertyCapacity, hasIndexingHeader, newVectorLength * sizeof(JSValue));
1502 
1503     gcSafeMemcpy(newButterfly-&gt;propertyStorage(), oldButterfly-&gt;propertyStorage(), oldButterfly-&gt;vectorLength() * sizeof(JSValue) + sizeof(IndexingHeader));
1504 
1505     WTF::storeStoreFence();
1506     NonPropertyTransition transition = ([&amp;] () {
1507         switch (indexingType()) {
1508         case ArrayWithInt32:
1509             return NonPropertyTransition::AllocateInt32;
1510         case ArrayWithDouble:
1511             return NonPropertyTransition::AllocateDouble;
1512         case ArrayWithContiguous:
1513             return NonPropertyTransition::AllocateContiguous;
1514         default:
1515             RELEASE_ASSERT_NOT_REACHED();
1516             return NonPropertyTransition::AllocateContiguous;
1517         }
1518     })();
1519     StructureID oldStructureID = structureID();
1520     Structure* newStructure = Structure::nonPropertyTransition(vm, structure(vm), transition);
1521     nukeStructureAndSetButterfly(vm, oldStructureID, newButterfly);
1522     setStructure(vm, newStructure);
1523 }
1524 
1525 void JSObject::setIndexQuicklyToUndecided(VM&amp; vm, unsigned index, JSValue value)
1526 {
1527     ASSERT(index &lt; m_butterfly-&gt;publicLength());
1528     ASSERT(index &lt; m_butterfly-&gt;vectorLength());
1529     convertUndecidedForValue(vm, value);
1530     setIndexQuickly(vm, index, value);
1531 }
1532 
1533 void JSObject::convertInt32ToDoubleOrContiguousWhilePerformingSetIndex(VM&amp; vm, unsigned index, JSValue value)
1534 {
1535     ASSERT(!value.isInt32());
1536     convertInt32ForValue(vm, value);
1537     setIndexQuickly(vm, index, value);
1538 }
1539 
1540 void JSObject::convertDoubleToContiguousWhilePerformingSetIndex(VM&amp; vm, unsigned index, JSValue value)
1541 {
1542     ASSERT(!value.isNumber() || value.asNumber() != value.asNumber());
1543     convertDoubleToContiguous(vm);
1544     setIndexQuickly(vm, index, value);
1545 }
1546 
1547 ContiguousJSValues JSObject::tryMakeWritableInt32Slow(VM&amp; vm)
1548 {
1549     ASSERT(inherits(vm, info()));
1550 
1551     if (isCopyOnWrite(indexingMode())) {
1552         if (leastUpperBoundOfIndexingTypes(indexingType() &amp; IndexingShapeMask, Int32Shape) == Int32Shape) {
1553             ASSERT(hasInt32(indexingMode()));
1554             convertFromCopyOnWrite(vm);
1555             return butterfly()-&gt;contiguousInt32();
1556         }
1557         return ContiguousJSValues();
1558     }
1559 
1560     if (structure(vm)-&gt;hijacksIndexingHeader())
1561         return ContiguousJSValues();
1562 
1563     switch (indexingType()) {
1564     case ALL_BLANK_INDEXING_TYPES:
1565         if (UNLIKELY(indexingShouldBeSparse(vm) || needsSlowPutIndexing(vm)))
1566             return ContiguousJSValues();
1567         return createInitialInt32(vm, 0);
1568 
1569     case ALL_UNDECIDED_INDEXING_TYPES:
1570         return convertUndecidedToInt32(vm);
1571 
1572     case ALL_DOUBLE_INDEXING_TYPES:
1573     case ALL_CONTIGUOUS_INDEXING_TYPES:
1574     case ALL_ARRAY_STORAGE_INDEXING_TYPES:
1575         return ContiguousJSValues();
1576 
1577     default:
1578         CRASH();
1579         return ContiguousJSValues();
1580     }
1581 }
1582 
1583 ContiguousDoubles JSObject::tryMakeWritableDoubleSlow(VM&amp; vm)
1584 {
1585     ASSERT(inherits(vm, info()));
1586 
1587     if (isCopyOnWrite(indexingMode())) {
1588         if (leastUpperBoundOfIndexingTypes(indexingType() &amp; IndexingShapeMask, DoubleShape) == DoubleShape) {
1589             convertFromCopyOnWrite(vm);
1590             if (hasDouble(indexingMode()))
1591                 return butterfly()-&gt;contiguousDouble();
1592             ASSERT(hasInt32(indexingMode()));
1593         } else
1594             return ContiguousDoubles();
1595     }
1596 
1597     if (structure(vm)-&gt;hijacksIndexingHeader())
1598         return ContiguousDoubles();
1599 
1600     switch (indexingType()) {
1601     case ALL_BLANK_INDEXING_TYPES:
1602         if (UNLIKELY(indexingShouldBeSparse(vm) || needsSlowPutIndexing(vm)))
1603             return ContiguousDoubles();
1604         return createInitialDouble(vm, 0);
1605 
1606     case ALL_UNDECIDED_INDEXING_TYPES:
1607         return convertUndecidedToDouble(vm);
1608 
1609     case ALL_INT32_INDEXING_TYPES:
1610         return convertInt32ToDouble(vm);
1611 
1612     case ALL_CONTIGUOUS_INDEXING_TYPES:
1613     case ALL_ARRAY_STORAGE_INDEXING_TYPES:
1614         return ContiguousDoubles();
1615 
1616     default:
1617         CRASH();
1618         return ContiguousDoubles();
1619     }
1620 }
1621 
1622 ContiguousJSValues JSObject::tryMakeWritableContiguousSlow(VM&amp; vm)
1623 {
1624     ASSERT(inherits(vm, info()));
1625 
1626     if (isCopyOnWrite(indexingMode())) {
1627         if (leastUpperBoundOfIndexingTypes(indexingType() &amp; IndexingShapeMask, ContiguousShape) == ContiguousShape) {
1628             convertFromCopyOnWrite(vm);
1629             if (hasContiguous(indexingMode()))
1630                 return butterfly()-&gt;contiguous();
1631             ASSERT(hasInt32(indexingMode()) || hasDouble(indexingMode()));
1632         } else
1633             return ContiguousJSValues();
1634     }
1635 
1636     if (structure(vm)-&gt;hijacksIndexingHeader())
1637         return ContiguousJSValues();
1638 
1639     switch (indexingType()) {
1640     case ALL_BLANK_INDEXING_TYPES:
1641         if (UNLIKELY(indexingShouldBeSparse(vm) || needsSlowPutIndexing(vm)))
1642             return ContiguousJSValues();
1643         return createInitialContiguous(vm, 0);
1644 
1645     case ALL_UNDECIDED_INDEXING_TYPES:
1646         return convertUndecidedToContiguous(vm);
1647 
1648     case ALL_INT32_INDEXING_TYPES:
1649         return convertInt32ToContiguous(vm);
1650 
1651     case ALL_DOUBLE_INDEXING_TYPES:
1652         return convertDoubleToContiguous(vm);
1653 
1654     case ALL_ARRAY_STORAGE_INDEXING_TYPES:
1655         return ContiguousJSValues();
1656 
1657     default:
1658         CRASH();
1659         return ContiguousJSValues();
1660     }
1661 }
1662 
1663 ArrayStorage* JSObject::ensureArrayStorageSlow(VM&amp; vm)
1664 {
1665     ASSERT(inherits(vm, info()));
1666 
1667     if (structure(vm)-&gt;hijacksIndexingHeader())
1668         return nullptr;
1669 
1670     ensureWritable(vm);
1671 
1672     switch (indexingType()) {
1673     case ALL_BLANK_INDEXING_TYPES:
1674         if (UNLIKELY(indexingShouldBeSparse(vm)))
1675             return ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm);
1676         return createInitialArrayStorage(vm);
1677 
1678     case ALL_UNDECIDED_INDEXING_TYPES:
1679         ASSERT(!indexingShouldBeSparse(vm));
1680         ASSERT(!needsSlowPutIndexing(vm));
1681         return convertUndecidedToArrayStorage(vm);
1682 
1683     case ALL_INT32_INDEXING_TYPES:
1684         ASSERT(!indexingShouldBeSparse(vm));
1685         ASSERT(!needsSlowPutIndexing(vm));
1686         return convertInt32ToArrayStorage(vm);
1687 
1688     case ALL_DOUBLE_INDEXING_TYPES:
1689         ASSERT(!indexingShouldBeSparse(vm));
1690         ASSERT(!needsSlowPutIndexing(vm));
1691         return convertDoubleToArrayStorage(vm);
1692 
1693     case ALL_CONTIGUOUS_INDEXING_TYPES:
1694         ASSERT(!indexingShouldBeSparse(vm));
1695         ASSERT(!needsSlowPutIndexing(vm));
1696         return convertContiguousToArrayStorage(vm);
1697 
1698     default:
1699         RELEASE_ASSERT_NOT_REACHED();
1700         return 0;
1701     }
1702 }
1703 
1704 ArrayStorage* JSObject::ensureArrayStorageExistsAndEnterDictionaryIndexingMode(VM&amp; vm)
1705 {
1706     ensureWritable(vm);
1707 
1708     switch (indexingType()) {
1709     case ALL_BLANK_INDEXING_TYPES: {
1710         createArrayStorage(vm, 0, 0);
1711         SparseArrayValueMap* map = allocateSparseIndexMap(vm);
1712         map-&gt;setSparseMode();
1713         return arrayStorage();
1714     }
1715 
1716     case ALL_UNDECIDED_INDEXING_TYPES:
1717         return enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(vm, convertUndecidedToArrayStorage(vm));
1718 
1719     case ALL_INT32_INDEXING_TYPES:
1720         return enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(vm, convertInt32ToArrayStorage(vm));
1721 
1722     case ALL_DOUBLE_INDEXING_TYPES:
1723         return enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(vm, convertDoubleToArrayStorage(vm));
1724 
1725     case ALL_CONTIGUOUS_INDEXING_TYPES:
1726         return enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(vm, convertContiguousToArrayStorage(vm));
1727 
1728     case ALL_ARRAY_STORAGE_INDEXING_TYPES:
1729         return enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(vm, m_butterfly-&gt;arrayStorage());
1730 
1731     default:
1732         CRASH();
1733         return 0;
1734     }
1735 }
1736 
1737 void JSObject::switchToSlowPutArrayStorage(VM&amp; vm)
1738 {
1739     ensureWritable(vm);
1740 
1741     switch (indexingType()) {
1742     case ArrayClass:
1743         ensureArrayStorage(vm);
1744         RELEASE_ASSERT(hasAnyArrayStorage(indexingType()));
1745         if (hasSlowPutArrayStorage(indexingType()))
1746             return;
1747         switchToSlowPutArrayStorage(vm);
1748         break;
1749 
1750     case ALL_UNDECIDED_INDEXING_TYPES:
1751         convertUndecidedToArrayStorage(vm, NonPropertyTransition::AllocateSlowPutArrayStorage);
1752         break;
1753 
1754     case ALL_INT32_INDEXING_TYPES:
1755         convertInt32ToArrayStorage(vm, NonPropertyTransition::AllocateSlowPutArrayStorage);
1756         break;
1757 
1758     case ALL_DOUBLE_INDEXING_TYPES:
1759         convertDoubleToArrayStorage(vm, NonPropertyTransition::AllocateSlowPutArrayStorage);
1760         break;
1761 
1762     case ALL_CONTIGUOUS_INDEXING_TYPES:
1763         convertContiguousToArrayStorage(vm, NonPropertyTransition::AllocateSlowPutArrayStorage);
1764         break;
1765 
1766     case NonArrayWithArrayStorage:
1767     case ArrayWithArrayStorage: {
1768         Structure* newStructure = Structure::nonPropertyTransition(vm, structure(vm), NonPropertyTransition::SwitchToSlowPutArrayStorage);
1769         setStructure(vm, newStructure);
1770         break;
1771     }
1772 
1773     default:
1774         CRASH();
1775         break;
1776     }
1777 }
1778 
1779 void JSObject::setPrototypeDirect(VM&amp; vm, JSValue prototype)
1780 {
1781     ASSERT(prototype);
1782     if (prototype.isObject())
1783         asObject(prototype)-&gt;didBecomePrototype();
1784 
1785     if (structure(vm)-&gt;hasMonoProto()) {
1786         DeferredStructureTransitionWatchpointFire deferred(vm, structure(vm));
1787         Structure* newStructure = Structure::changePrototypeTransition(vm, structure(vm), prototype, deferred);
1788         setStructure(vm, newStructure);
1789     } else
1790         putDirect(vm, knownPolyProtoOffset, prototype);
1791 
1792     if (!anyObjectInChainMayInterceptIndexedAccesses(vm))
1793         return;
1794 
1795     if (mayBePrototype()) {
1796         structure(vm)-&gt;globalObject()-&gt;haveABadTime(vm);
1797         return;
1798     }
1799 
1800     if (!hasIndexedProperties(indexingType()))
1801         return;
1802 
1803     if (shouldUseSlowPut(indexingType()))
1804         return;
1805 
1806     switchToSlowPutArrayStorage(vm);
1807 }
1808 
1809 bool JSObject::setPrototypeWithCycleCheck(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype, bool shouldThrowIfCantSet)
1810 {
1811     auto scope = DECLARE_THROW_SCOPE(vm);
1812 
1813     if (this-&gt;structure(vm)-&gt;isImmutablePrototypeExoticObject()) {
1814         // This implements https://tc39.github.io/ecma262/#sec-set-immutable-prototype.
1815         if (this-&gt;getPrototype(vm, globalObject) == prototype)
1816             return true;
1817 
1818         return typeError(globalObject, scope, shouldThrowIfCantSet, &quot;Cannot set prototype of immutable prototype object&quot;_s);
1819     }
1820 
1821     ASSERT(methodTable(vm)-&gt;toThis(this, globalObject, NotStrictMode) == this);
1822 
1823     if (this-&gt;getPrototypeDirect(vm) == prototype)
1824         return true;
1825 
1826     bool isExtensible = this-&gt;isExtensible(globalObject);
1827     RETURN_IF_EXCEPTION(scope, false);
1828 
1829     if (!isExtensible)
1830         return typeError(globalObject, scope, shouldThrowIfCantSet, ReadonlyPropertyWriteError);
1831 
1832     JSValue nextPrototype = prototype;
1833     while (nextPrototype &amp;&amp; nextPrototype.isObject()) {
1834         if (nextPrototype == this)
1835             return typeError(globalObject, scope, shouldThrowIfCantSet, &quot;cyclic __proto__ value&quot;_s);
1836         // FIXME: The specification currently says we should check if the [[GetPrototypeOf]] internal method of nextPrototype
1837         // is not the ordinary object internal method. However, we currently restrict this to Proxy objects as it would allow
1838         // for cycles with certain HTML objects (WindowProxy, Location) otherwise.
1839         // https://bugs.webkit.org/show_bug.cgi?id=161534
1840         if (UNLIKELY(asObject(nextPrototype)-&gt;type() == ProxyObjectType))
1841             break; // We&#39;re done. Set the prototype.
1842         nextPrototype = asObject(nextPrototype)-&gt;getPrototypeDirect(vm);
1843     }
1844     setPrototypeDirect(vm, prototype);
1845     return true;
1846 }
1847 
1848 bool JSObject::setPrototype(JSObject* object, JSGlobalObject* globalObject, JSValue prototype, bool shouldThrowIfCantSet)
1849 {
1850     return object-&gt;setPrototypeWithCycleCheck(globalObject-&gt;vm(), globalObject, prototype, shouldThrowIfCantSet);
1851 }
1852 
1853 JSValue JSObject::getPrototype(JSObject* object, JSGlobalObject* globalObject)
1854 {
1855     return object-&gt;getPrototypeDirect(globalObject-&gt;vm());
1856 }
1857 
1858 bool JSObject::setPrototype(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype, bool shouldThrowIfCantSet)
1859 {
1860     return methodTable(vm)-&gt;setPrototype(this, globalObject, prototype, shouldThrowIfCantSet);
1861 }
1862 
1863 bool JSObject::putGetter(JSGlobalObject* globalObject, PropertyName propertyName, JSValue getter, unsigned attributes)
1864 {
1865     PropertyDescriptor descriptor;
1866     descriptor.setGetter(getter);
1867 
1868     ASSERT(attributes &amp; PropertyAttribute::Accessor);
1869     if (!(attributes &amp; PropertyAttribute::ReadOnly))
1870         descriptor.setConfigurable(true);
1871     if (!(attributes &amp; PropertyAttribute::DontEnum))
1872         descriptor.setEnumerable(true);
1873 
1874     return defineOwnProperty(this, globalObject, propertyName, descriptor, true);
1875 }
1876 
1877 bool JSObject::putSetter(JSGlobalObject* globalObject, PropertyName propertyName, JSValue setter, unsigned attributes)
1878 {
1879     PropertyDescriptor descriptor;
1880     descriptor.setSetter(setter);
1881 
1882     ASSERT(attributes &amp; PropertyAttribute::Accessor);
1883     if (!(attributes &amp; PropertyAttribute::ReadOnly))
1884         descriptor.setConfigurable(true);
1885     if (!(attributes &amp; PropertyAttribute::DontEnum))
1886         descriptor.setEnumerable(true);
1887 
1888     return defineOwnProperty(this, globalObject, propertyName, descriptor, true);
1889 }
1890 
1891 bool JSObject::putDirectAccessor(JSGlobalObject* globalObject, PropertyName propertyName, GetterSetter* accessor, unsigned attributes)
1892 {
1893     ASSERT(attributes &amp; PropertyAttribute::Accessor);
1894 
1895     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
1896         return putDirectIndex(globalObject, index.value(), accessor, attributes, PutDirectIndexLikePutDirect);
1897 
1898     return putDirectNonIndexAccessor(globalObject-&gt;vm(), propertyName, accessor, attributes);
1899 }
1900 
1901 // FIXME: Introduce a JSObject::putDirectCustomValue() method instead of using
1902 // JSObject::putDirectCustomAccessor() to put CustomValues.
1903 // https://bugs.webkit.org/show_bug.cgi?id=192576
1904 bool JSObject::putDirectCustomAccessor(VM&amp; vm, PropertyName propertyName, JSValue value, unsigned attributes)
1905 {
1906     ASSERT(!parseIndex(propertyName));
1907     ASSERT(value.isCustomGetterSetter());
1908     if (!(attributes &amp; PropertyAttribute::CustomAccessor))
1909         attributes |= PropertyAttribute::CustomValue;
1910 
1911     PutPropertySlot slot(this);
1912     bool result = putDirectInternal&lt;PutModeDefineOwnProperty&gt;(vm, propertyName, value, attributes, slot);
1913 
1914     ASSERT(slot.type() == PutPropertySlot::NewProperty);
1915 
1916     Structure* structure = this-&gt;structure(vm);
1917     if (attributes &amp; PropertyAttribute::ReadOnly)
1918         structure-&gt;setContainsReadOnlyProperties();
1919     structure-&gt;setHasCustomGetterSetterPropertiesWithProtoCheck(propertyName == vm.propertyNames-&gt;underscoreProto);
1920     return result;
1921 }
1922 
1923 bool JSObject::putDirectNonIndexAccessor(VM&amp; vm, PropertyName propertyName, GetterSetter* accessor, unsigned attributes)
1924 {
1925     ASSERT(attributes &amp; PropertyAttribute::Accessor);
1926     PutPropertySlot slot(this);
1927     bool result = putDirectInternal&lt;PutModeDefineOwnProperty&gt;(vm, propertyName, accessor, attributes, slot);
1928 
1929     Structure* structure = this-&gt;structure(vm);
1930     if (attributes &amp; PropertyAttribute::ReadOnly)
1931         structure-&gt;setContainsReadOnlyProperties();
1932 
1933     structure-&gt;setHasGetterSetterPropertiesWithProtoCheck(propertyName == vm.propertyNames-&gt;underscoreProto);
1934     return result;
1935 }
1936 
1937 void JSObject::putDirectNonIndexAccessorWithoutTransition(VM&amp; vm, PropertyName propertyName, GetterSetter* accessor, unsigned attributes)
1938 {
1939     ASSERT(attributes &amp; PropertyAttribute::Accessor);
1940     StructureID structureID = this-&gt;structureID();
1941     Structure* structure = vm.heap.structureIDTable().get(structureID);
1942     PropertyOffset offset = prepareToPutDirectWithoutTransition(vm, propertyName, attributes, structureID, structure);
1943     putDirect(vm, offset, accessor);
1944     if (attributes &amp; PropertyAttribute::ReadOnly)
1945         structure-&gt;setContainsReadOnlyProperties();
1946 
1947     structure-&gt;setHasGetterSetterPropertiesWithProtoCheck(propertyName == vm.propertyNames-&gt;underscoreProto);
1948 }
1949 
1950 // HasProperty(O, P) from Section 7.3.10 of the spec.
1951 // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-hasproperty
1952 bool JSObject::hasProperty(JSGlobalObject* globalObject, PropertyName propertyName) const
1953 {
1954     return hasPropertyGeneric(globalObject, propertyName, PropertySlot::InternalMethodType::HasProperty);
1955 }
1956 
1957 bool JSObject::hasProperty(JSGlobalObject* globalObject, unsigned propertyName) const
1958 {
1959     return hasPropertyGeneric(globalObject, propertyName, PropertySlot::InternalMethodType::HasProperty);
1960 }
1961 
1962 bool JSObject::hasPropertyGeneric(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot::InternalMethodType internalMethodType) const
1963 {
1964     PropertySlot slot(this, internalMethodType);
1965     return const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(globalObject, propertyName, slot);
1966 }
1967 
1968 bool JSObject::hasPropertyGeneric(JSGlobalObject* globalObject, unsigned propertyName, PropertySlot::InternalMethodType internalMethodType) const
1969 {
1970     PropertySlot slot(this, internalMethodType);
1971     return const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(globalObject, propertyName, slot);
1972 }
1973 
1974 // ECMA 8.6.2.5
1975 bool JSObject::deleteProperty(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)
1976 {
1977     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
1978     VM&amp; vm = globalObject-&gt;vm();
1979 
1980     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
1981         return thisObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObject, globalObject, index.value());
1982 
1983     unsigned attributes;
1984 
1985     if (!thisObject-&gt;staticPropertiesReified(vm)) {
1986         if (auto entry = thisObject-&gt;findPropertyHashEntry(vm, propertyName)) {
1987             // If the static table contains a non-configurable (DontDelete) property then we can return early;
1988             // if there is a property in the storage array it too must be non-configurable (the language does
1989             // not allow repacement of a non-configurable property with a configurable one).
1990             if (entry-&gt;value-&gt;attributes() &amp; PropertyAttribute::DontDelete &amp;&amp; vm.deletePropertyMode() != VM::DeletePropertyMode::IgnoreConfigurable) {
1991                 ASSERT(!isValidOffset(thisObject-&gt;structure(vm)-&gt;get(vm, propertyName, attributes)) || attributes &amp; PropertyAttribute::DontDelete);
1992                 return false;
1993             }
1994             thisObject-&gt;reifyAllStaticProperties(globalObject);
1995         }
1996     }
1997 
1998     Structure* structure = thisObject-&gt;structure(vm);
1999 
2000     bool propertyIsPresent = isValidOffset(structure-&gt;get(vm, propertyName, attributes));
2001     if (propertyIsPresent) {
2002         if (attributes &amp; PropertyAttribute::DontDelete &amp;&amp; vm.deletePropertyMode() != VM::DeletePropertyMode::IgnoreConfigurable)
2003             return false;
2004         DeferredStructureTransitionWatchpointFire deferredWatchpointFire(vm, structure);
2005 
2006         PropertyOffset offset = invalidOffset;
2007         if (structure-&gt;isUncacheableDictionary())
2008             offset = structure-&gt;removePropertyWithoutTransition(vm, propertyName, [] (const GCSafeConcurrentJSLocker&amp;, PropertyOffset, PropertyOffset) { });
2009         else {
2010             structure = Structure::removePropertyTransition(vm, structure, propertyName, offset, &amp;deferredWatchpointFire);
2011             if (thisObject-&gt;m_butterfly &amp;&amp; !structure-&gt;outOfLineCapacity() &amp;&amp; !structure-&gt;hasIndexingHeader(thisObject)) {
2012                 thisObject-&gt;nukeStructureAndSetButterfly(vm, thisObject-&gt;structureID(), nullptr);
2013                 offset = invalidOffset;
2014                 ASSERT(structure-&gt;maxOffset() == invalidOffset);
2015             }
2016             thisObject-&gt;setStructure(vm, structure);
2017         }
2018 
2019         ASSERT(!isValidOffset(structure-&gt;get(vm, propertyName, attributes)));
2020 
2021         if (offset != invalidOffset)
2022             thisObject-&gt;locationForOffset(offset)-&gt;clear();
2023     }
2024 
2025     return true;
2026 }
2027 
2028 bool JSObject::deletePropertyByIndex(JSCell* cell, JSGlobalObject* globalObject, unsigned i)
2029 {
2030     VM&amp; vm = globalObject-&gt;vm();
2031     JSObject* thisObject = jsCast&lt;JSObject*&gt;(cell);
2032 
2033     if (i &gt; MAX_ARRAY_INDEX)
2034         return thisObject-&gt;methodTable(vm)-&gt;deleteProperty(thisObject, globalObject, Identifier::from(vm, i));
2035 
2036     switch (thisObject-&gt;indexingMode()) {
2037     case ALL_BLANK_INDEXING_TYPES:
2038     case ALL_UNDECIDED_INDEXING_TYPES:
2039         return true;
2040 
2041     case CopyOnWriteArrayWithInt32:
2042     case CopyOnWriteArrayWithContiguous: {
2043         Butterfly* butterfly = thisObject-&gt;butterfly();
2044         if (i &gt;= butterfly-&gt;vectorLength())
2045             return true;
2046         thisObject-&gt;convertFromCopyOnWrite(vm);
2047         FALLTHROUGH;
2048     }
2049 
2050     case ALL_WRITABLE_INT32_INDEXING_TYPES:
2051     case ALL_WRITABLE_CONTIGUOUS_INDEXING_TYPES: {
2052         Butterfly* butterfly = thisObject-&gt;butterfly();
2053         if (i &gt;= butterfly-&gt;vectorLength())
2054             return true;
2055         butterfly-&gt;contiguous().at(thisObject, i).clear();
2056         return true;
2057     }
2058 
2059     case CopyOnWriteArrayWithDouble: {
2060         Butterfly* butterfly = thisObject-&gt;butterfly();
2061         if (i &gt;= butterfly-&gt;vectorLength())
2062             return true;
2063         thisObject-&gt;convertFromCopyOnWrite(vm);
2064         FALLTHROUGH;
2065     }
2066 
2067     case ALL_WRITABLE_DOUBLE_INDEXING_TYPES: {
2068         Butterfly* butterfly = thisObject-&gt;butterfly();
2069         if (i &gt;= butterfly-&gt;vectorLength())
2070             return true;
2071         butterfly-&gt;contiguousDouble().at(thisObject, i) = PNaN;
2072         return true;
2073     }
2074 
2075     case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
2076         ArrayStorage* storage = thisObject-&gt;m_butterfly-&gt;arrayStorage();
2077 
2078         if (i &lt; storage-&gt;vectorLength()) {
2079             WriteBarrier&lt;Unknown&gt;&amp; valueSlot = storage-&gt;m_vector[i];
2080             if (valueSlot) {
2081                 valueSlot.clear();
2082                 --storage-&gt;m_numValuesInVector;
2083             }
2084         } else if (SparseArrayValueMap* map = storage-&gt;m_sparseMap.get()) {
2085             SparseArrayValueMap::iterator it = map-&gt;find(i);
2086             if (it != map-&gt;notFound()) {
2087                 if (it-&gt;value.attributes() &amp; PropertyAttribute::DontDelete)
2088                     return false;
2089                 map-&gt;remove(it);
2090             }
2091         }
2092 
2093         return true;
2094     }
2095 
2096     default:
2097         RELEASE_ASSERT_NOT_REACHED();
2098         return false;
2099     }
2100 }
2101 
2102 enum class TypeHintMode { TakesHint, DoesNotTakeHint };
2103 
2104 template&lt;TypeHintMode mode = TypeHintMode::DoesNotTakeHint&gt;
2105 static ALWAYS_INLINE JSValue callToPrimitiveFunction(JSGlobalObject* globalObject, const JSObject* object, PropertyName propertyName, PreferredPrimitiveType hint)
2106 {
2107     VM&amp; vm = globalObject-&gt;vm();
2108     auto scope = DECLARE_THROW_SCOPE(vm);
2109 
2110     PropertySlot slot(object, PropertySlot::InternalMethodType::Get);
2111     // FIXME: Remove this when we have fixed: rdar://problem/33451840
2112     // https://bugs.webkit.org/show_bug.cgi?id=187109.
2113     constexpr bool debugNullStructure = mode == TypeHintMode::TakesHint;
2114     bool hasProperty = const_cast&lt;JSObject*&gt;(object)-&gt;getPropertySlot&lt;debugNullStructure&gt;(globalObject, propertyName, slot);
2115     RETURN_IF_EXCEPTION(scope, scope.exception());
2116     JSValue function = hasProperty ? slot.getValue(globalObject, propertyName) : jsUndefined();
2117     RETURN_IF_EXCEPTION(scope, scope.exception());
2118     if (function.isUndefinedOrNull() &amp;&amp; mode == TypeHintMode::TakesHint)
2119         return JSValue();
2120     CallData callData;
2121     CallType callType = getCallData(vm, function, callData);
2122     if (callType == CallType::None) {
2123         if (mode == TypeHintMode::TakesHint)
2124             throwTypeError(globalObject, scope, &quot;Symbol.toPrimitive is not a function, undefined, or null&quot;_s);
2125         return scope.exception();
2126     }
2127 
2128     MarkedArgumentBuffer callArgs;
2129     if (mode == TypeHintMode::TakesHint) {
2130         JSString* hintString = nullptr;
2131         switch (hint) {
2132         case NoPreference:
2133             hintString = vm.smallStrings.defaultString();
2134             break;
2135         case PreferNumber:
2136             hintString = vm.smallStrings.numberString();
2137             break;
2138         case PreferString:
2139             hintString = vm.smallStrings.stringString();
2140             break;
2141         }
2142         callArgs.append(hintString);
2143     }
2144     ASSERT(!callArgs.hasOverflowed());
2145 
2146     JSValue result = call(globalObject, function, callType, callData, const_cast&lt;JSObject*&gt;(object), callArgs);
2147     RETURN_IF_EXCEPTION(scope, scope.exception());
2148     ASSERT(!result.isGetterSetter());
2149     if (result.isObject())
2150         return mode == TypeHintMode::DoesNotTakeHint ? JSValue() : throwTypeError(globalObject, scope, &quot;Symbol.toPrimitive returned an object&quot;_s);
2151     return result;
2152 }
2153 
2154 // ECMA 7.1.1
2155 JSValue JSObject::ordinaryToPrimitive(JSGlobalObject* globalObject, PreferredPrimitiveType hint) const
2156 {
2157     VM&amp; vm = globalObject-&gt;vm();
2158     auto scope = DECLARE_THROW_SCOPE(vm);
2159 
2160     // Make sure that whatever default value methods there are on object&#39;s prototype chain are
2161     // being watched.
2162     for (const JSObject* object = this; object; object = object-&gt;structure(vm)-&gt;storedPrototypeObject(object))
2163         object-&gt;structure(vm)-&gt;startWatchingInternalPropertiesIfNecessary(vm);
2164 
2165     JSValue value;
2166     if (hint == PreferString) {
2167         value = callToPrimitiveFunction(globalObject, this, vm.propertyNames-&gt;toString, hint);
2168         EXCEPTION_ASSERT(!scope.exception() || scope.exception() == value.asCell());
2169         if (value)
2170             return value;
2171         value = callToPrimitiveFunction(globalObject, this, vm.propertyNames-&gt;valueOf, hint);
2172         EXCEPTION_ASSERT(!scope.exception() || scope.exception() == value.asCell());
2173         if (value)
2174             return value;
2175     } else {
2176         value = callToPrimitiveFunction(globalObject, this, vm.propertyNames-&gt;valueOf, hint);
2177         EXCEPTION_ASSERT(!scope.exception() || scope.exception() == value.asCell());
2178         if (value)
2179             return value;
2180         value = callToPrimitiveFunction(globalObject, this, vm.propertyNames-&gt;toString, hint);
2181         EXCEPTION_ASSERT(!scope.exception() || scope.exception() == value.asCell());
2182         if (value)
2183             return value;
2184     }
2185 
2186     scope.assertNoException();
2187 
2188     return throwTypeError(globalObject, scope, &quot;No default value&quot;_s);
2189 }
2190 
2191 JSValue JSObject::defaultValue(const JSObject* object, JSGlobalObject* globalObject, PreferredPrimitiveType hint)
2192 {
2193     return object-&gt;ordinaryToPrimitive(globalObject, hint);
2194 }
2195 
2196 JSValue JSObject::toPrimitive(JSGlobalObject* globalObject, PreferredPrimitiveType preferredType) const
2197 {
2198     VM&amp; vm = globalObject-&gt;vm();
2199     auto scope = DECLARE_THROW_SCOPE(vm);
2200 
2201     JSValue value = callToPrimitiveFunction&lt;TypeHintMode::TakesHint&gt;(globalObject, this, vm.propertyNames-&gt;toPrimitiveSymbol, preferredType);
2202     RETURN_IF_EXCEPTION(scope, { });
2203     if (value)
2204         return value;
2205 
2206     RELEASE_AND_RETURN(scope, this-&gt;methodTable(vm)-&gt;defaultValue(this, globalObject, preferredType));
2207 }
2208 
2209 bool JSObject::getPrimitiveNumber(JSGlobalObject* globalObject, double&amp; number, JSValue&amp; result) const
2210 {
2211     VM&amp; vm = globalObject-&gt;vm();
2212     auto scope = DECLARE_THROW_SCOPE(vm);
2213 
2214     result = toPrimitive(globalObject, PreferNumber);
2215     RETURN_IF_EXCEPTION(scope, false);
2216     scope.release();
2217     number = result.toNumber(globalObject);
2218     return !result.isString();
2219 }
2220 
2221 bool JSObject::getOwnStaticPropertySlot(VM&amp; vm, PropertyName propertyName, PropertySlot&amp; slot)
2222 {
2223     for (auto* info = classInfo(vm); info; info = info-&gt;parentClass) {
2224         if (auto* table = info-&gt;staticPropHashTable) {
2225             if (getStaticPropertySlotFromTable(vm, table-&gt;classForThis, *table, this, propertyName, slot))
2226                 return true;
2227         }
2228     }
2229     return false;
2230 }
2231 
2232 Optional&lt;Structure::PropertyHashEntry&gt; JSObject::findPropertyHashEntry(VM&amp; vm, PropertyName propertyName) const
2233 {
2234     return structure(vm)-&gt;findPropertyHashEntry(propertyName);
2235 }
2236 
2237 bool JSObject::hasInstance(JSGlobalObject* globalObject, JSValue value, JSValue hasInstanceValue)
2238 {
2239     VM&amp; vm = globalObject-&gt;vm();
2240     auto scope = DECLARE_THROW_SCOPE(vm);
2241 
2242     if (!hasInstanceValue.isUndefinedOrNull() &amp;&amp; hasInstanceValue != globalObject-&gt;functionProtoHasInstanceSymbolFunction()) {
2243         CallData callData;
2244         CallType callType = JSC::getCallData(vm, hasInstanceValue, callData);
2245         if (callType == CallType::None) {
2246             throwException(globalObject, scope, createInvalidInstanceofParameterErrorHasInstanceValueNotFunction(globalObject, this));
2247             return false;
2248         }
2249 
2250         MarkedArgumentBuffer args;
2251         args.append(value);
2252         ASSERT(!args.hasOverflowed());
2253         JSValue result = call(globalObject, hasInstanceValue, callType, callData, this, args);
2254         RETURN_IF_EXCEPTION(scope, false);
2255         return result.toBoolean(globalObject);
2256     }
2257 
2258     TypeInfo info = structure(vm)-&gt;typeInfo();
2259     if (info.implementsDefaultHasInstance()) {
2260         JSValue prototype = get(globalObject, vm.propertyNames-&gt;prototype);
2261         RETURN_IF_EXCEPTION(scope, false);
2262         RELEASE_AND_RETURN(scope, defaultHasInstance(globalObject, value, prototype));
2263     }
2264     if (info.implementsHasInstance()) {
2265         if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
2266             throwStackOverflowError(globalObject, scope);
2267             return false;
2268         }
2269         RELEASE_AND_RETURN(scope, methodTable(vm)-&gt;customHasInstance(this, globalObject, value));
2270     }
2271 
2272     throwException(globalObject, scope, createInvalidInstanceofParameterErrorNotFunction(globalObject, this));
2273     return false;
2274 }
2275 
2276 bool JSObject::hasInstance(JSGlobalObject* globalObject, JSValue value)
2277 {
2278     VM&amp; vm = globalObject-&gt;vm();
2279     auto scope = DECLARE_THROW_SCOPE(vm);
2280     JSValue hasInstanceValue = get(globalObject, vm.propertyNames-&gt;hasInstanceSymbol);
2281     RETURN_IF_EXCEPTION(scope, false);
2282 
2283     RELEASE_AND_RETURN(scope, hasInstance(globalObject, value, hasInstanceValue));
2284 }
2285 
2286 bool JSObject::defaultHasInstance(JSGlobalObject* globalObject, JSValue value, JSValue proto)
2287 {
2288     VM&amp; vm = globalObject-&gt;vm();
2289     auto scope = DECLARE_THROW_SCOPE(vm);
2290 
2291     if (!value.isObject())
2292         return false;
2293 
2294     if (!proto.isObject()) {
2295         throwTypeError(globalObject, scope, &quot;instanceof called on an object with an invalid prototype property.&quot;_s);
2296         return false;
2297     }
2298 
2299     JSObject* object = asObject(value);
2300     while (true) {
2301         JSValue objectValue = object-&gt;getPrototype(vm, globalObject);
2302         RETURN_IF_EXCEPTION(scope, false);
2303         if (!objectValue.isObject())
2304             return false;
2305         object = asObject(objectValue);
2306         if (proto == object)
2307             return true;
2308     }
2309     ASSERT_NOT_REACHED();
2310 }
2311 
2312 EncodedJSValue JSC_HOST_CALL objectPrivateFuncInstanceOf(JSGlobalObject* globalObject, CallFrame* callFrame)
2313 {
2314     JSValue value = callFrame-&gt;uncheckedArgument(0);
2315     JSValue proto = callFrame-&gt;uncheckedArgument(1);
2316 
2317     return JSValue::encode(jsBoolean(JSObject::defaultHasInstance(globalObject, value, proto)));
2318 }
2319 
2320 void JSObject::getPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)
2321 {
2322     VM&amp; vm = globalObject-&gt;vm();
2323     auto scope = DECLARE_THROW_SCOPE(vm);
2324     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, globalObject, propertyNames, mode);
2325     RETURN_IF_EXCEPTION(scope, void());
2326 
2327     JSValue nextProto = object-&gt;getPrototype(vm, globalObject);
2328     RETURN_IF_EXCEPTION(scope, void());
2329     if (nextProto.isNull())
2330         return;
2331 
2332     JSObject* prototype = asObject(nextProto);
2333     while(1) {
2334         if (prototype-&gt;structure(vm)-&gt;typeInfo().overridesGetPropertyNames()) {
2335             scope.release();
2336             prototype-&gt;methodTable(vm)-&gt;getPropertyNames(prototype, globalObject, propertyNames, mode);
2337             return;
2338         }
2339         prototype-&gt;methodTable(vm)-&gt;getOwnPropertyNames(prototype, globalObject, propertyNames, mode);
2340         RETURN_IF_EXCEPTION(scope, void());
2341         nextProto = prototype-&gt;getPrototype(vm, globalObject);
2342         RETURN_IF_EXCEPTION(scope, void());
2343         if (nextProto.isNull())
2344             break;
2345         prototype = asObject(nextProto);
2346     }
2347 }
2348 
2349 void JSObject::getOwnPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)
2350 {
2351     VM&amp; vm = globalObject-&gt;vm();
2352     if (!mode.includeJSObjectProperties()) {
2353         // We still have to get non-indexed properties from any subclasses of JSObject that have them.
2354         object-&gt;methodTable(vm)-&gt;getOwnNonIndexPropertyNames(object, globalObject, propertyNames, mode);
2355         return;
2356     }
2357 
2358     if (propertyNames.includeStringProperties()) {
2359         // Add numeric properties first. That appears to be the accepted convention.
2360         // FIXME: Filling PropertyNameArray with an identifier for every integer
2361         // is incredibly inefficient for large arrays. We need a different approach,
2362         // which almost certainly means a different structure for PropertyNameArray.
2363         switch (object-&gt;indexingType()) {
2364         case ALL_BLANK_INDEXING_TYPES:
2365         case ALL_UNDECIDED_INDEXING_TYPES:
2366             break;
2367 
2368         case ALL_INT32_INDEXING_TYPES:
2369         case ALL_CONTIGUOUS_INDEXING_TYPES: {
2370             Butterfly* butterfly = object-&gt;butterfly();
2371             unsigned usedLength = butterfly-&gt;publicLength();
2372             for (unsigned i = 0; i &lt; usedLength; ++i) {
2373                 if (!butterfly-&gt;contiguous().at(object, i))
2374                     continue;
2375                 propertyNames.add(i);
2376             }
2377             break;
2378         }
2379 
2380         case ALL_DOUBLE_INDEXING_TYPES: {
2381             Butterfly* butterfly = object-&gt;butterfly();
2382             unsigned usedLength = butterfly-&gt;publicLength();
2383             for (unsigned i = 0; i &lt; usedLength; ++i) {
2384                 double value = butterfly-&gt;contiguousDouble().at(object, i);
2385                 if (value != value)
2386                     continue;
2387                 propertyNames.add(i);
2388             }
2389             break;
2390         }
2391 
2392         case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
2393             ArrayStorage* storage = object-&gt;m_butterfly-&gt;arrayStorage();
2394 
2395             unsigned usedVectorLength = std::min(storage-&gt;length(), storage-&gt;vectorLength());
2396             for (unsigned i = 0; i &lt; usedVectorLength; ++i) {
2397                 if (storage-&gt;m_vector[i])
2398                     propertyNames.add(i);
2399             }
2400 
2401             if (SparseArrayValueMap* map = storage-&gt;m_sparseMap.get()) {
2402                 Vector&lt;unsigned, 0, UnsafeVectorOverflow&gt; keys;
2403                 keys.reserveInitialCapacity(map-&gt;size());
2404 
2405                 SparseArrayValueMap::const_iterator end = map-&gt;end();
2406                 for (SparseArrayValueMap::const_iterator it = map-&gt;begin(); it != end; ++it) {
2407                     if (mode.includeDontEnumProperties() || !(it-&gt;value.attributes() &amp; PropertyAttribute::DontEnum))
2408                         keys.uncheckedAppend(static_cast&lt;unsigned&gt;(it-&gt;key));
2409                 }
2410 
2411                 std::sort(keys.begin(), keys.end());
2412                 for (unsigned i = 0; i &lt; keys.size(); ++i)
2413                     propertyNames.add(keys[i]);
2414             }
2415             break;
2416         }
2417 
2418         default:
2419             RELEASE_ASSERT_NOT_REACHED();
2420         }
2421     }
2422 
2423     object-&gt;methodTable(vm)-&gt;getOwnNonIndexPropertyNames(object, globalObject, propertyNames, mode);
2424 }
2425 
2426 void JSObject::getOwnNonIndexPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)
2427 {
2428     VM&amp; vm = globalObject-&gt;vm();
2429     if (!object-&gt;staticPropertiesReified(vm))
2430         getClassPropertyNames(globalObject, object-&gt;classInfo(vm), propertyNames, mode);
2431 
2432     if (!mode.includeJSObjectProperties())
2433         return;
2434 
2435     object-&gt;structure(vm)-&gt;getPropertyNamesFromStructure(vm, propertyNames, mode);
2436 }
2437 
2438 double JSObject::toNumber(JSGlobalObject* globalObject) const
2439 {
2440     VM&amp; vm = globalObject-&gt;vm();
2441     auto scope = DECLARE_THROW_SCOPE(vm);
2442     JSValue primitive = toPrimitive(globalObject, PreferNumber);
2443     RETURN_IF_EXCEPTION(scope, 0.0); // should be picked up soon in Nodes.cpp
2444     RELEASE_AND_RETURN(scope, primitive.toNumber(globalObject));
2445 }
2446 
2447 JSString* JSObject::toString(JSGlobalObject* globalObject) const
2448 {
2449     VM&amp; vm = globalObject-&gt;vm();
2450     auto scope = DECLARE_THROW_SCOPE(vm);
2451     JSValue primitive = toPrimitive(globalObject, PreferString);
2452     RETURN_IF_EXCEPTION(scope, jsEmptyString(vm));
2453     RELEASE_AND_RETURN(scope, primitive.toString(globalObject));
2454 }
2455 
2456 JSValue JSObject::toThis(JSCell* cell, JSGlobalObject*, ECMAMode)
2457 {
2458     return jsCast&lt;JSObject*&gt;(cell);
2459 }
2460 
2461 void JSObject::seal(VM&amp; vm)
2462 {
2463     if (isSealed(vm))
2464         return;
2465     enterDictionaryIndexingMode(vm);
2466     setStructure(vm, Structure::sealTransition(vm, structure(vm)));
2467 }
2468 
2469 void JSObject::freeze(VM&amp; vm)
2470 {
2471     if (isFrozen(vm))
2472         return;
2473     enterDictionaryIndexingMode(vm);
2474     setStructure(vm, Structure::freezeTransition(vm, structure(vm)));
2475 }
2476 
2477 bool JSObject::preventExtensions(JSObject* object, JSGlobalObject* globalObject)
2478 {
2479     VM&amp; vm = globalObject-&gt;vm();
2480     if (!object-&gt;isStructureExtensible(vm)) {
2481         // We&#39;ve already set the internal [[PreventExtensions]] field to false.
2482         // We don&#39;t call the methodTable isExtensible here because it&#39;s not defined
2483         // that way in the specification. We are just doing an optimization here.
2484         return true;
2485     }
2486 
2487     object-&gt;enterDictionaryIndexingMode(vm);
2488     object-&gt;setStructure(vm, Structure::preventExtensionsTransition(vm, object-&gt;structure(vm)));
2489     return true;
2490 }
2491 
2492 bool JSObject::isExtensible(JSObject* obj, JSGlobalObject* globalObject)
2493 {
2494     return obj-&gt;isStructureExtensible(globalObject-&gt;vm());
2495 }
2496 
2497 bool JSObject::isExtensible(JSGlobalObject* globalObject)
2498 {
2499     VM&amp; vm = globalObject-&gt;vm();
2500     return methodTable(vm)-&gt;isExtensible(this, globalObject);
2501 }
2502 
2503 void JSObject::reifyAllStaticProperties(JSGlobalObject* globalObject)
2504 {
2505     VM&amp; vm = globalObject-&gt;vm();
2506     ASSERT(!staticPropertiesReified(vm));
2507 
2508     // If this object&#39;s ClassInfo has no static properties, then nothing to reify!
2509     // We can safely set the flag to avoid the expensive check again in the future.
2510     if (!TypeInfo::hasStaticPropertyTable(inlineTypeFlags())) {
2511         structure(vm)-&gt;setStaticPropertiesReified(true);
2512         return;
2513     }
2514 
2515     if (!structure(vm)-&gt;isDictionary())
2516         setStructure(vm, Structure::toCacheableDictionaryTransition(vm, structure(vm)));
2517 
2518     for (const ClassInfo* info = classInfo(vm); info; info = info-&gt;parentClass) {
2519         const HashTable* hashTable = info-&gt;staticPropHashTable;
2520         if (!hashTable)
2521             continue;
2522 
2523         for (auto&amp; value : *hashTable) {
2524             unsigned attributes;
2525             auto key = Identifier::fromString(vm, value.m_key);
2526             PropertyOffset offset = getDirectOffset(vm, key, attributes);
2527             if (!isValidOffset(offset))
2528                 reifyStaticProperty(vm, hashTable-&gt;classForThis, key, value, *this);
2529         }
2530     }
2531 
2532     structure(vm)-&gt;setStaticPropertiesReified(true);
2533 }
2534 
2535 NEVER_INLINE void JSObject::fillGetterPropertySlot(VM&amp; vm, PropertySlot&amp; slot, JSCell* getterSetter, unsigned attributes, PropertyOffset offset)
2536 {
2537     if (structure(vm)-&gt;isUncacheableDictionary()) {
2538         slot.setGetterSlot(this, attributes, jsCast&lt;GetterSetter*&gt;(getterSetter));
2539         return;
2540     }
2541 
2542     // This access is cacheable because Structure requires an attributeChangedTransition
2543     // if this property stops being an accessor.
2544     slot.setCacheableGetterSlot(this, attributes, jsCast&lt;GetterSetter*&gt;(getterSetter), offset);
2545 }
2546 
2547 static bool putIndexedDescriptor(JSGlobalObject* globalObject, SparseArrayValueMap* map, SparseArrayEntry* entryInMap, const PropertyDescriptor&amp; descriptor, PropertyDescriptor&amp; oldDescriptor)
2548 {
2549     VM&amp; vm = globalObject-&gt;vm();
2550 
2551     if (descriptor.isDataDescriptor()) {
2552         unsigned attributes = descriptor.attributesOverridingCurrent(oldDescriptor) &amp; ~PropertyAttribute::Accessor;
2553         if (descriptor.value())
2554             entryInMap-&gt;forceSet(vm, map, descriptor.value(), attributes);
2555         else if (oldDescriptor.isAccessorDescriptor())
2556             entryInMap-&gt;forceSet(vm, map, jsUndefined(), attributes);
2557         else
2558             entryInMap-&gt;forceSet(attributes);
2559         return true;
2560     }
2561 
2562     if (descriptor.isAccessorDescriptor()) {
2563         JSObject* getter = nullptr;
2564         if (descriptor.getterPresent())
2565             getter = descriptor.getterObject();
2566         else if (oldDescriptor.isAccessorDescriptor())
2567             getter = oldDescriptor.getterObject();
2568         JSObject* setter = nullptr;
2569         if (descriptor.setterPresent())
2570             setter = descriptor.setterObject();
2571         else if (oldDescriptor.isAccessorDescriptor())
2572             setter = oldDescriptor.setterObject();
2573 
2574         GetterSetter* accessor = GetterSetter::create(vm, globalObject, getter, setter);
2575         entryInMap-&gt;forceSet(vm, map, accessor, descriptor.attributesOverridingCurrent(oldDescriptor) &amp; ~PropertyAttribute::ReadOnly);
2576         return true;
2577     }
2578 
2579     ASSERT(descriptor.isGenericDescriptor());
2580     entryInMap-&gt;forceSet(descriptor.attributesOverridingCurrent(oldDescriptor));
2581     return true;
2582 }
2583 
2584 ALWAYS_INLINE static bool canDoFastPutDirectIndex(VM&amp; vm, JSObject* object)
2585 {
2586     return (isJSArray(object) &amp;&amp; !isCopyOnWrite(object-&gt;indexingMode()))
2587         || jsDynamicCast&lt;JSFinalObject*&gt;(vm, object)
2588         || TypeInfo::isArgumentsType(object-&gt;type());
2589 }
2590 
2591 // Defined in ES5.1 8.12.9
2592 bool JSObject::defineOwnIndexedProperty(JSGlobalObject* globalObject, unsigned index, const PropertyDescriptor&amp; descriptor, bool throwException)
2593 {
2594     VM&amp; vm = globalObject-&gt;vm();
2595     auto scope = DECLARE_THROW_SCOPE(vm);
2596 
2597     ASSERT(index &lt;= MAX_ARRAY_INDEX);
2598 
2599     ensureWritable(vm);
2600 
2601     if (!inSparseIndexingMode()) {
2602         // Fast case: we&#39;re putting a regular property to a regular array
2603         // FIXME: this will pessimistically assume that if attributes are missing then they&#39;ll default to false
2604         // however if the property currently exists missing attributes will override from their current &#39;true&#39;
2605         // state (i.e. defineOwnProperty could be used to set a value without needing to entering &#39;SparseMode&#39;).
2606         if (!descriptor.attributes() &amp;&amp; descriptor.value() &amp;&amp; canDoFastPutDirectIndex(vm, this)) {
2607             ASSERT(!descriptor.isAccessorDescriptor());
2608             RELEASE_AND_RETURN(scope, putDirectIndex(globalObject, index, descriptor.value(), 0, throwException ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow));
2609         }
2610 
2611         ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm);
2612     }
2613 
2614     if (descriptor.attributes() &amp; (PropertyAttribute::ReadOnly | PropertyAttribute::Accessor))
2615         notifyPresenceOfIndexedAccessors(vm);
2616 
2617     SparseArrayValueMap* map = m_butterfly-&gt;arrayStorage()-&gt;m_sparseMap.get();
2618     RELEASE_ASSERT(map);
2619 
2620     // 1. Let current be the result of calling the [[GetOwnProperty]] internal method of O with property name P.
2621     SparseArrayValueMap::AddResult result = map-&gt;add(this, index);
2622     SparseArrayEntry* entryInMap = &amp;result.iterator-&gt;value;
2623 
2624     // 2. Let extensible be the value of the [[Extensible]] internal property of O.
2625     // 3. If current is undefined and extensible is false, then Reject.
2626     // 4. If current is undefined and extensible is true, then
2627     if (result.isNewEntry) {
2628         if (!isStructureExtensible(vm)) {
2629             map-&gt;remove(result.iterator);
2630             return typeError(globalObject, scope, throwException, NonExtensibleObjectPropertyDefineError);
2631         }
2632 
2633         // 4.a. If IsGenericDescriptor(Desc) or IsDataDescriptor(Desc) is true, then create an own data property
2634         // named P of object O whose [[Value]], [[Writable]], [[Enumerable]] and [[Configurable]] attribute values
2635         // are described by Desc. If the value of an attribute field of Desc is absent, the attribute of the newly
2636         // created property is set to its default value.
2637         // 4.b. Else, Desc must be an accessor Property Descriptor so, create an own accessor property named P of
2638         // object O whose [[Get]], [[Set]], [[Enumerable]] and [[Configurable]] attribute values are described by
2639         // Desc. If the value of an attribute field of Desc is absent, the attribute of the newly created property
2640         // is set to its default value.
2641         // 4.c. Return true.
2642 
2643         PropertyDescriptor defaults(jsUndefined(), PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
2644         putIndexedDescriptor(globalObject, map, entryInMap, descriptor, defaults);
2645         Butterfly* butterfly = m_butterfly.get();
2646         if (index &gt;= butterfly-&gt;arrayStorage()-&gt;length())
2647             butterfly-&gt;arrayStorage()-&gt;setLength(index + 1);
2648         return true;
2649     }
2650 
2651     // 5. Return true, if every field in Desc is absent.
2652     // 6. Return true, if every field in Desc also occurs in current and the value of every field in Desc is the same value as the corresponding field in current when compared using the SameValue algorithm (9.12).
2653     PropertyDescriptor current;
2654     entryInMap-&gt;get(current);
2655     bool isEmptyOrEqual = descriptor.isEmpty() || descriptor.equalTo(globalObject, current);
2656     RETURN_IF_EXCEPTION(scope, false);
2657     if (isEmptyOrEqual)
2658         return true;
2659 
2660     // 7. If the [[Configurable]] field of current is false then
2661     if (!current.configurable()) {
2662         // 7.a. Reject, if the [[Configurable]] field of Desc is true.
2663         if (descriptor.configurablePresent() &amp;&amp; descriptor.configurable())
2664             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeConfigurabilityError);
2665         // 7.b. Reject, if the [[Enumerable]] field of Desc is present and the [[Enumerable]] fields of current and Desc are the Boolean negation of each other.
2666         if (descriptor.enumerablePresent() &amp;&amp; current.enumerable() != descriptor.enumerable())
2667             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeEnumerabilityError);
2668     }
2669 
2670     // 8. If IsGenericDescriptor(Desc) is true, then no further validation is required.
2671     if (!descriptor.isGenericDescriptor()) {
2672         // 9. Else, if IsDataDescriptor(current) and IsDataDescriptor(Desc) have different results, then
2673         if (current.isDataDescriptor() != descriptor.isDataDescriptor()) {
2674             // 9.a. Reject, if the [[Configurable]] field of current is false.
2675             if (!current.configurable())
2676                 return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);
2677             // 9.b. If IsDataDescriptor(current) is true, then convert the property named P of object O from a
2678             // data property to an accessor property. Preserve the existing values of the converted property&#39;s
2679             // [[Configurable]] and [[Enumerable]] attributes and set the rest of the property&#39;s attributes to
2680             // their default values.
2681             // 9.c. Else, convert the property named P of object O from an accessor property to a data property.
2682             // Preserve the existing values of the converted property&#39;s [[Configurable]] and [[Enumerable]]
2683             // attributes and set the rest of the property&#39;s attributes to their default values.
2684         } else if (current.isDataDescriptor() &amp;&amp; descriptor.isDataDescriptor()) {
2685             // 10. Else, if IsDataDescriptor(current) and IsDataDescriptor(Desc) are both true, then
2686             // 10.a. If the [[Configurable]] field of current is false, then
2687             if (!current.configurable() &amp;&amp; !current.writable()) {
2688                 // 10.a.i. Reject, if the [[Writable]] field of current is false and the [[Writable]] field of Desc is true.
2689                 if (descriptor.writable())
2690                     return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeWritabilityError);
2691                 // 10.a.ii. If the [[Writable]] field of current is false, then
2692                 // 10.a.ii.1. Reject, if the [[Value]] field of Desc is present and SameValue(Desc.[[Value]], current.[[Value]]) is false.
2693                 if (descriptor.value()) {
2694                     bool isSame = sameValue(globalObject, descriptor.value(), current.value());
2695                     RETURN_IF_EXCEPTION(scope, false);
2696                     if (!isSame)
2697                         return typeError(globalObject, scope, throwException, ReadonlyPropertyChangeError);
2698                 }
2699             }
2700             // 10.b. else, the [[Configurable]] field of current is true, so any change is acceptable.
2701         } else {
2702             ASSERT(current.isAccessorDescriptor() &amp;&amp; current.getterPresent() &amp;&amp; current.setterPresent());
2703             // 11. Else, IsAccessorDescriptor(current) and IsAccessorDescriptor(Desc) are both true so, if the [[Configurable]] field of current is false, then
2704             if (!current.configurable()) {
2705                 // 11.i. Reject, if the [[Set]] field of Desc is present and SameValue(Desc.[[Set]], current.[[Set]]) is false.
2706                 if (descriptor.setterPresent() &amp;&amp; descriptor.setter() != current.setter())
2707                     return typeError(globalObject, scope, throwException, &quot;Attempting to change the setter of an unconfigurable property.&quot;_s);
2708                 // 11.ii. Reject, if the [[Get]] field of Desc is present and SameValue(Desc.[[Get]], current.[[Get]]) is false.
2709                 if (descriptor.getterPresent() &amp;&amp; descriptor.getter() != current.getter())
2710                     return typeError(globalObject, scope, throwException, &quot;Attempting to change the getter of an unconfigurable property.&quot;_s);
2711             }
2712         }
2713     }
2714 
2715     // 12. For each attribute field of Desc that is present, set the correspondingly named attribute of the property named P of object O to the value of the field.
2716     putIndexedDescriptor(globalObject, map, entryInMap, descriptor, current);
2717     // 13. Return true.
2718     return true;
2719 }
2720 
2721 SparseArrayValueMap* JSObject::allocateSparseIndexMap(VM&amp; vm)
2722 {
2723     SparseArrayValueMap* result = SparseArrayValueMap::create(vm);
2724     arrayStorage()-&gt;m_sparseMap.set(vm, this, result);
2725     return result;
2726 }
2727 
2728 void JSObject::deallocateSparseIndexMap()
2729 {
2730     if (ArrayStorage* arrayStorage = arrayStorageOrNull())
2731         arrayStorage-&gt;m_sparseMap.clear();
2732 }
2733 
2734 bool JSObject::attemptToInterceptPutByIndexOnHoleForPrototype(JSGlobalObject* globalObject, JSValue thisValue, unsigned i, JSValue value, bool shouldThrow, bool&amp; putResult)
2735 {
2736     VM&amp; vm = globalObject-&gt;vm();
2737     auto scope = DECLARE_THROW_SCOPE(vm);
2738 
2739     for (JSObject* current = this; ;) {
2740         // This has the same behavior with respect to prototypes as JSObject::put(). It only
2741         // allows a prototype to intercept a put if (a) the prototype declares the property
2742         // we&#39;re after rather than intercepting it via an override of JSObject::put(), and
2743         // (b) that property is declared as ReadOnly or Accessor.
2744 
2745         ArrayStorage* storage = current-&gt;arrayStorageOrNull();
2746         if (storage &amp;&amp; storage-&gt;m_sparseMap) {
2747             SparseArrayValueMap::iterator iter = storage-&gt;m_sparseMap-&gt;find(i);
2748             if (iter != storage-&gt;m_sparseMap-&gt;notFound() &amp;&amp; (iter-&gt;value.attributes() &amp; (PropertyAttribute::Accessor | PropertyAttribute::ReadOnly))) {
2749                 scope.release();
2750                 putResult = iter-&gt;value.put(globalObject, thisValue, storage-&gt;m_sparseMap.get(), value, shouldThrow);
2751                 return true;
2752             }
2753         }
2754 
2755         if (current-&gt;type() == ProxyObjectType) {
2756             scope.release();
2757             ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(current);
2758             putResult = proxy-&gt;putByIndexCommon(globalObject, thisValue, i, value, shouldThrow);
2759             return true;
2760         }
2761 
2762         JSValue prototypeValue = current-&gt;getPrototype(vm, globalObject);
2763         RETURN_IF_EXCEPTION(scope, false);
2764         if (prototypeValue.isNull())
2765             return false;
2766 
2767         current = asObject(prototypeValue);
2768     }
2769 }
2770 
2771 bool JSObject::attemptToInterceptPutByIndexOnHole(JSGlobalObject* globalObject, unsigned i, JSValue value, bool shouldThrow, bool&amp; putResult)
2772 {
2773     VM&amp; vm = globalObject-&gt;vm();
2774     auto scope = DECLARE_THROW_SCOPE(vm);
2775 
2776     JSValue prototypeValue = getPrototype(vm, globalObject);
2777     RETURN_IF_EXCEPTION(scope, false);
2778     if (prototypeValue.isNull())
2779         return false;
2780 
2781     RELEASE_AND_RETURN(scope, asObject(prototypeValue)-&gt;attemptToInterceptPutByIndexOnHoleForPrototype(globalObject, this, i, value, shouldThrow, putResult));
2782 }
2783 
2784 template&lt;IndexingType indexingShape&gt;
2785 bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes(JSGlobalObject* globalObject, unsigned i, JSValue value)
2786 {
2787     VM&amp; vm = globalObject-&gt;vm();
2788     auto scope = DECLARE_THROW_SCOPE(vm);
2789 
2790     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!isCopyOnWrite(indexingMode()));
2791     ASSERT((indexingType() &amp; IndexingShapeMask) == indexingShape);
2792     ASSERT(!indexingShouldBeSparse(vm));
2793 
2794     Butterfly* butterfly = m_butterfly.get();
2795 
2796     // For us to get here, the index is either greater than the public length, or greater than
2797     // or equal to the vector length.
2798     ASSERT(i &gt;= butterfly-&gt;vectorLength());
2799 
2800     if (i &gt; MAX_STORAGE_VECTOR_INDEX
2801         || (i &gt;= MIN_SPARSE_ARRAY_INDEX &amp;&amp; !isDenseEnoughForVector(i, countElements&lt;indexingShape&gt;(butterfly)))
2802         || indexIsSufficientlyBeyondLengthForSparseMap(i, butterfly-&gt;vectorLength())) {
2803         ASSERT(i &lt;= MAX_ARRAY_INDEX);
2804         ensureArrayStorageSlow(vm);
2805         SparseArrayValueMap* map = allocateSparseIndexMap(vm);
2806         bool result = map-&gt;putEntry(globalObject, this, i, value, false);
2807         RETURN_IF_EXCEPTION(scope, false);
2808         ASSERT(i &gt;= arrayStorage()-&gt;length());
2809         arrayStorage()-&gt;setLength(i + 1);
2810         return result;
2811     }
2812 
2813     if (!ensureLength(vm, i + 1)) {
2814         throwOutOfMemoryError(globalObject, scope);
2815         return false;
2816     }
2817     butterfly = m_butterfly.get();
2818 
2819     RELEASE_ASSERT(i &lt; butterfly-&gt;vectorLength());
2820     switch (indexingShape) {
2821     case Int32Shape:
2822         ASSERT(value.isInt32());
2823         butterfly-&gt;contiguous().at(this, i).setWithoutWriteBarrier(value);
2824         return true;
2825 
2826     case DoubleShape: {
2827         ASSERT(value.isNumber());
2828         double valueAsDouble = value.asNumber();
2829         ASSERT(valueAsDouble == valueAsDouble);
2830         butterfly-&gt;contiguousDouble().at(this, i) = valueAsDouble;
2831         return true;
2832     }
2833 
2834     case ContiguousShape:
2835         butterfly-&gt;contiguous().at(this, i).set(vm, this, value);
2836         return true;
2837 
2838     default:
2839         CRASH();
2840         return false;
2841     }
2842 }
2843 
2844 // Explicit instantiations needed by JSArray.cpp.
2845 template bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes&lt;Int32Shape&gt;(JSGlobalObject*, unsigned, JSValue);
2846 template bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes&lt;DoubleShape&gt;(JSGlobalObject*, unsigned, JSValue);
2847 template bool JSObject::putByIndexBeyondVectorLengthWithoutAttributes&lt;ContiguousShape&gt;(JSGlobalObject*, unsigned, JSValue);
2848 
2849 bool JSObject::putByIndexBeyondVectorLengthWithArrayStorage(JSGlobalObject* globalObject, unsigned i, JSValue value, bool shouldThrow, ArrayStorage* storage)
2850 {
2851     VM&amp; vm = globalObject-&gt;vm();
2852     auto scope = DECLARE_THROW_SCOPE(vm);
2853 
2854     ASSERT(!isCopyOnWrite(indexingMode()));
2855     // i should be a valid array index that is outside of the current vector.
2856     ASSERT(i &lt;= MAX_ARRAY_INDEX);
2857     ASSERT(i &gt;= storage-&gt;vectorLength());
2858 
2859     SparseArrayValueMap* map = storage-&gt;m_sparseMap.get();
2860 
2861     // First, handle cases where we don&#39;t currently have a sparse map.
2862     if (LIKELY(!map)) {
2863         // If the array is not extensible, we should have entered dictionary mode, and created the sparse map.
2864         ASSERT(isStructureExtensible(vm));
2865 
2866         // Update m_length if necessary.
2867         if (i &gt;= storage-&gt;length())
2868             storage-&gt;setLength(i + 1);
2869 
2870         // Check that it is sensible to still be using a vector, and then try to grow the vector.
2871         if (LIKELY(!indexIsSufficientlyBeyondLengthForSparseMap(i, storage-&gt;vectorLength())
2872             &amp;&amp; isDenseEnoughForVector(i, storage-&gt;m_numValuesInVector)
2873             &amp;&amp; increaseVectorLength(vm, i + 1))) {
2874             // success! - reread m_storage since it has likely been reallocated, and store to the vector.
2875             storage = arrayStorage();
2876             storage-&gt;m_vector[i].set(vm, this, value);
2877             ++storage-&gt;m_numValuesInVector;
2878             return true;
2879         }
2880         // We don&#39;t want to, or can&#39;t use a vector to hold this property - allocate a sparse map &amp; add the value.
2881         map = allocateSparseIndexMap(vm);
2882         RELEASE_AND_RETURN(scope, map-&gt;putEntry(globalObject, this, i, value, shouldThrow));
2883     }
2884 
2885     // Update m_length if necessary.
2886     unsigned length = storage-&gt;length();
2887     if (i &gt;= length) {
2888         // Prohibit growing the array if length is not writable.
2889         if (map-&gt;lengthIsReadOnly() || !isStructureExtensible(vm))
2890             return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyWriteError);
2891         length = i + 1;
2892         storage-&gt;setLength(length);
2893     }
2894 
2895     // We are currently using a map - check whether we still want to be doing so.
2896     // We will continue  to use a sparse map if SparseMode is set, a vector would be too sparse, or if allocation fails.
2897     unsigned numValuesInArray = storage-&gt;m_numValuesInVector + map-&gt;size();
2898     if (map-&gt;sparseMode() || !isDenseEnoughForVector(length, numValuesInArray) || !increaseVectorLength(vm, length))
2899         RELEASE_AND_RETURN(scope, map-&gt;putEntry(globalObject, this, i, value, shouldThrow));
2900 
2901     // Reread m_storage after increaseVectorLength, update m_numValuesInVector.
2902     storage = arrayStorage();
2903     storage-&gt;m_numValuesInVector = numValuesInArray;
2904 
2905     // Copy all values from the map into the vector, and delete the map.
2906     WriteBarrier&lt;Unknown&gt;* vector = storage-&gt;m_vector;
2907     SparseArrayValueMap::const_iterator end = map-&gt;end();
2908     for (SparseArrayValueMap::const_iterator it = map-&gt;begin(); it != end; ++it)
2909         vector[it-&gt;key].set(vm, this, it-&gt;value.getNonSparseMode());
2910     deallocateSparseIndexMap();
2911 
2912     // Store the new property into the vector.
2913     WriteBarrier&lt;Unknown&gt;&amp; valueSlot = vector[i];
2914     if (!valueSlot)
2915         ++storage-&gt;m_numValuesInVector;
2916     valueSlot.set(vm, this, value);
2917     return true;
2918 }
2919 
2920 bool JSObject::putByIndexBeyondVectorLength(JSGlobalObject* globalObject, unsigned i, JSValue value, bool shouldThrow)
2921 {
2922     VM&amp; vm = globalObject-&gt;vm();
2923     auto scope = DECLARE_THROW_SCOPE(vm);
2924 
2925     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!isCopyOnWrite(indexingMode()));
2926 
2927     // i should be a valid array index that is outside of the current vector.
2928     ASSERT(i &lt;= MAX_ARRAY_INDEX);
2929 
2930     switch (indexingType()) {
2931     case ALL_BLANK_INDEXING_TYPES: {
2932         if (indexingShouldBeSparse(vm)) {
2933             RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithArrayStorage(
2934                 globalObject, i, value, shouldThrow,
2935                 ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm)));
2936         }
2937         if (indexIsSufficientlyBeyondLengthForSparseMap(i, 0) || i &gt;= MIN_SPARSE_ARRAY_INDEX) {
2938             RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithArrayStorage(globalObject, i, value, shouldThrow, createArrayStorage(vm, 0, 0)));
2939         }
2940         if (needsSlowPutIndexing(vm)) {
2941             // Convert the indexing type to the SlowPutArrayStorage and retry.
2942             createArrayStorage(vm, i + 1, getNewVectorLength(vm, 0, 0, 0, i + 1));
2943             RELEASE_AND_RETURN(scope, putByIndex(this, globalObject, i, value, shouldThrow));
2944         }
2945 
2946         createInitialForValueAndSet(vm, i, value);
2947         return true;
2948     }
2949 
2950     case ALL_UNDECIDED_INDEXING_TYPES: {
2951         CRASH();
2952         break;
2953     }
2954 
2955     case ALL_INT32_INDEXING_TYPES:
2956         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithoutAttributes&lt;Int32Shape&gt;(globalObject, i, value));
2957 
2958     case ALL_DOUBLE_INDEXING_TYPES:
2959         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithoutAttributes&lt;DoubleShape&gt;(globalObject, i, value));
2960 
2961     case ALL_CONTIGUOUS_INDEXING_TYPES:
2962         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithoutAttributes&lt;ContiguousShape&gt;(globalObject, i, value));
2963 
2964     case NonArrayWithSlowPutArrayStorage:
2965     case ArrayWithSlowPutArrayStorage: {
2966         // No own property present in the vector, but there might be in the sparse map!
2967         SparseArrayValueMap* map = arrayStorage()-&gt;m_sparseMap.get();
2968         bool putResult = false;
2969         if (!(map &amp;&amp; map-&gt;contains(i))) {
2970             bool result = attemptToInterceptPutByIndexOnHole(globalObject, i, value, shouldThrow, putResult);
2971             RETURN_IF_EXCEPTION(scope, false);
2972             if (result)
2973                 return putResult;
2974         }
2975         FALLTHROUGH;
2976     }
2977 
2978     case NonArrayWithArrayStorage:
2979     case ArrayWithArrayStorage:
2980         RELEASE_AND_RETURN(scope, putByIndexBeyondVectorLengthWithArrayStorage(globalObject, i, value, shouldThrow, arrayStorage()));
2981 
2982     default:
2983         RELEASE_ASSERT_NOT_REACHED();
2984     }
2985     return false;
2986 }
2987 
2988 bool JSObject::putDirectIndexBeyondVectorLengthWithArrayStorage(JSGlobalObject* globalObject, unsigned i, JSValue value, unsigned attributes, PutDirectIndexMode mode, ArrayStorage* storage)
2989 {
2990     VM&amp; vm = globalObject-&gt;vm();
2991     auto scope = DECLARE_THROW_SCOPE(vm);
2992 
2993     // i should be a valid array index that is outside of the current vector.
2994     ASSERT(hasAnyArrayStorage(indexingType()));
2995     ASSERT(arrayStorage() == storage);
2996     ASSERT(i &gt;= storage-&gt;vectorLength() || attributes);
2997     ASSERT(i &lt;= MAX_ARRAY_INDEX);
2998 
2999     SparseArrayValueMap* map = storage-&gt;m_sparseMap.get();
3000 
3001     // First, handle cases where we don&#39;t currently have a sparse map.
3002     if (LIKELY(!map)) {
3003         // If the array is not extensible, we should have entered dictionary mode, and created the spare map.
3004         ASSERT(isStructureExtensible(vm));
3005 
3006         // Update m_length if necessary.
3007         if (i &gt;= storage-&gt;length())
3008             storage-&gt;setLength(i + 1);
3009 
3010         // Check that it is sensible to still be using a vector, and then try to grow the vector.
3011         if (LIKELY(
3012                 !attributes
3013                 &amp;&amp; (isDenseEnoughForVector(i, storage-&gt;m_numValuesInVector))
3014                 &amp;&amp; !indexIsSufficientlyBeyondLengthForSparseMap(i, storage-&gt;vectorLength()))
3015                 &amp;&amp; increaseVectorLength(vm, i + 1)) {
3016             // success! - reread m_storage since it has likely been reallocated, and store to the vector.
3017             storage = arrayStorage();
3018             storage-&gt;m_vector[i].set(vm, this, value);
3019             ++storage-&gt;m_numValuesInVector;
3020             return true;
3021         }
3022         // We don&#39;t want to, or can&#39;t use a vector to hold this property - allocate a sparse map &amp; add the value.
3023         map = allocateSparseIndexMap(vm);
3024         RELEASE_AND_RETURN(scope, map-&gt;putDirect(globalObject, this, i, value, attributes, mode));
3025     }
3026 
3027     // Update m_length if necessary.
3028     unsigned length = storage-&gt;length();
3029     if (i &gt;= length) {
3030         if (mode != PutDirectIndexLikePutDirect) {
3031             // Prohibit growing the array if length is not writable.
3032             if (map-&gt;lengthIsReadOnly())
3033                 return typeError(globalObject, scope, mode == PutDirectIndexShouldThrow, ReadonlyPropertyWriteError);
3034             if (!isStructureExtensible(vm))
3035                 return typeError(globalObject, scope, mode == PutDirectIndexShouldThrow, NonExtensibleObjectPropertyDefineError);
3036         }
3037         length = i + 1;
3038         storage-&gt;setLength(length);
3039     }
3040 
3041     // We are currently using a map - check whether we still want to be doing so.
3042     // We will continue  to use a sparse map if SparseMode is set, a vector would be too sparse, or if allocation fails.
3043     unsigned numValuesInArray = storage-&gt;m_numValuesInVector + map-&gt;size();
3044     if (map-&gt;sparseMode() || attributes || !isDenseEnoughForVector(length, numValuesInArray) || !increaseVectorLength(vm, length))
3045         RELEASE_AND_RETURN(scope, map-&gt;putDirect(globalObject, this, i, value, attributes, mode));
3046 
3047     // Reread m_storage after increaseVectorLength, update m_numValuesInVector.
3048     storage = arrayStorage();
3049     storage-&gt;m_numValuesInVector = numValuesInArray;
3050 
3051     // Copy all values from the map into the vector, and delete the map.
3052     WriteBarrier&lt;Unknown&gt;* vector = storage-&gt;m_vector;
3053     SparseArrayValueMap::const_iterator end = map-&gt;end();
3054     for (SparseArrayValueMap::const_iterator it = map-&gt;begin(); it != end; ++it)
3055         vector[it-&gt;key].set(vm, this, it-&gt;value.getNonSparseMode());
3056     deallocateSparseIndexMap();
3057 
3058     // Store the new property into the vector.
3059     WriteBarrier&lt;Unknown&gt;&amp; valueSlot = vector[i];
3060     if (!valueSlot)
3061         ++storage-&gt;m_numValuesInVector;
3062     valueSlot.set(vm, this, value);
3063     return true;
3064 }
3065 
3066 bool JSObject::putDirectIndexSlowOrBeyondVectorLength(JSGlobalObject* globalObject, unsigned i, JSValue value, unsigned attributes, PutDirectIndexMode mode)
3067 {
3068     VM&amp; vm = globalObject-&gt;vm();
3069     ASSERT(!value.isCustomGetterSetter());
3070 
3071     if (!canDoFastPutDirectIndex(vm, this)) {
3072         PropertyDescriptor descriptor;
3073         descriptor.setDescriptor(value, attributes);
3074         return methodTable(vm)-&gt;defineOwnProperty(this, globalObject, Identifier::from(vm, i), descriptor, mode == PutDirectIndexShouldThrow);
3075     }
3076 
3077     // i should be a valid array index that is outside of the current vector.
3078     ASSERT(i &lt;= MAX_ARRAY_INDEX);
3079 
3080     if (attributes &amp; (PropertyAttribute::ReadOnly | PropertyAttribute::Accessor))
3081         notifyPresenceOfIndexedAccessors(vm);
3082 
3083     switch (indexingType()) {
3084     case ALL_BLANK_INDEXING_TYPES: {
3085         if (indexingShouldBeSparse(vm) || attributes) {
3086             return putDirectIndexBeyondVectorLengthWithArrayStorage(
3087                 globalObject, i, value, attributes, mode,
3088                 ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));
3089         }
3090         if (indexIsSufficientlyBeyondLengthForSparseMap(i, 0) || i &gt;= MIN_SPARSE_ARRAY_INDEX) {
3091             return putDirectIndexBeyondVectorLengthWithArrayStorage(
3092                 globalObject, i, value, attributes, mode, createArrayStorage(vm, 0, 0));
3093         }
3094         if (needsSlowPutIndexing(vm)) {
3095             ArrayStorage* storage = createArrayStorage(vm, i + 1, getNewVectorLength(vm, 0, 0, 0, i + 1));
3096             storage-&gt;m_vector[i].set(vm, this, value);
3097             storage-&gt;m_numValuesInVector++;
3098             return true;
3099         }
3100 
3101         createInitialForValueAndSet(vm, i, value);
3102         return true;
3103     }
3104 
3105     case ALL_UNDECIDED_INDEXING_TYPES: {
3106         convertUndecidedForValue(vm, value);
3107         // Reloop.
3108         return putDirectIndex(globalObject, i, value, attributes, mode);
3109     }
3110 
3111     case ALL_INT32_INDEXING_TYPES: {
3112         ASSERT(!indexingShouldBeSparse(vm));
3113         if (attributes)
3114             return putDirectIndexBeyondVectorLengthWithArrayStorage(globalObject, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));
3115         if (!value.isInt32()) {
3116             convertInt32ForValue(vm, value);
3117             return putDirectIndexSlowOrBeyondVectorLength(globalObject, i, value, attributes, mode);
3118         }
3119         putByIndexBeyondVectorLengthWithoutAttributes&lt;Int32Shape&gt;(globalObject, i, value);
3120         return true;
3121     }
3122 
3123     case ALL_DOUBLE_INDEXING_TYPES: {
3124         ASSERT(!indexingShouldBeSparse(vm));
3125         if (attributes)
3126             return putDirectIndexBeyondVectorLengthWithArrayStorage(globalObject, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));
3127         if (!value.isNumber()) {
3128             convertDoubleToContiguous(vm);
3129             return putDirectIndexSlowOrBeyondVectorLength(globalObject, i, value, attributes, mode);
3130         }
3131         double valueAsDouble = value.asNumber();
3132         if (valueAsDouble != valueAsDouble) {
3133             convertDoubleToContiguous(vm);
3134             return putDirectIndexSlowOrBeyondVectorLength(globalObject, i, value, attributes, mode);
3135         }
3136         putByIndexBeyondVectorLengthWithoutAttributes&lt;DoubleShape&gt;(globalObject, i, value);
3137         return true;
3138     }
3139 
3140     case ALL_CONTIGUOUS_INDEXING_TYPES: {
3141         ASSERT(!indexingShouldBeSparse(vm));
3142         if (attributes)
3143             return putDirectIndexBeyondVectorLengthWithArrayStorage(globalObject, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));
3144         putByIndexBeyondVectorLengthWithoutAttributes&lt;ContiguousShape&gt;(globalObject, i, value);
3145         return true;
3146     }
3147 
3148     case ALL_ARRAY_STORAGE_INDEXING_TYPES:
3149         if (attributes)
3150             return putDirectIndexBeyondVectorLengthWithArrayStorage(globalObject, i, value, attributes, mode, ensureArrayStorageExistsAndEnterDictionaryIndexingMode(vm));
3151         return putDirectIndexBeyondVectorLengthWithArrayStorage(globalObject, i, value, attributes, mode, arrayStorage());
3152 
3153     default:
3154         RELEASE_ASSERT_NOT_REACHED();
3155         return false;
3156     }
3157 }
3158 
3159 bool JSObject::putDirectNativeIntrinsicGetter(VM&amp; vm, JSGlobalObject* globalObject, Identifier name, NativeFunction nativeFunction, Intrinsic intrinsic, unsigned attributes)
3160 {
3161     JSFunction* function = JSFunction::create(vm, globalObject, 0, makeString(&quot;get &quot;, name.string()), nativeFunction, intrinsic);
3162     GetterSetter* accessor = GetterSetter::create(vm, globalObject, function, nullptr);
3163     return putDirectNonIndexAccessor(vm, name, accessor, attributes);
3164 }
3165 
3166 void JSObject::putDirectNativeIntrinsicGetterWithoutTransition(VM&amp; vm, JSGlobalObject* globalObject, Identifier name, NativeFunction nativeFunction, Intrinsic intrinsic, unsigned attributes)
3167 {
3168     JSFunction* function = JSFunction::create(vm, globalObject, 0, makeString(&quot;get &quot;, name.string()), nativeFunction, intrinsic);
3169     GetterSetter* accessor = GetterSetter::create(vm, globalObject, function, nullptr);
3170     putDirectNonIndexAccessorWithoutTransition(vm, name, accessor, attributes);
3171 }
3172 
3173 bool JSObject::putDirectNativeFunction(VM&amp; vm, JSGlobalObject* globalObject, const PropertyName&amp; propertyName, unsigned functionLength, NativeFunction nativeFunction, Intrinsic intrinsic, unsigned attributes)
3174 {
3175     StringImpl* name = propertyName.publicName();
3176     if (!name)
3177         name = vm.propertyNames-&gt;anonymous.impl();
3178     ASSERT(name);
3179 
3180     JSFunction* function = JSFunction::create(vm, globalObject, functionLength, name, nativeFunction, intrinsic);
3181     return putDirect(vm, propertyName, function, attributes);
3182 }
3183 
3184 bool JSObject::putDirectNativeFunction(VM&amp; vm, JSGlobalObject* globalObject, const PropertyName&amp; propertyName, unsigned functionLength, NativeFunction nativeFunction, Intrinsic intrinsic, const DOMJIT::Signature* signature, unsigned attributes)
3185 {
3186     StringImpl* name = propertyName.publicName();
3187     if (!name)
3188         name = vm.propertyNames-&gt;anonymous.impl();
3189     ASSERT(name);
3190 
3191     JSFunction* function = JSFunction::create(vm, globalObject, functionLength, name, nativeFunction, intrinsic, callHostFunctionAsConstructor, signature);
3192     return putDirect(vm, propertyName, function, attributes);
3193 }
3194 
3195 void JSObject::putDirectNativeFunctionWithoutTransition(VM&amp; vm, JSGlobalObject* globalObject, const PropertyName&amp; propertyName, unsigned functionLength, NativeFunction nativeFunction, Intrinsic intrinsic, unsigned attributes)
3196 {
3197     StringImpl* name = propertyName.publicName();
3198     if (!name)
3199         name = vm.propertyNames-&gt;anonymous.impl();
3200     ASSERT(name);
3201     JSFunction* function = JSFunction::create(vm, globalObject, functionLength, name, nativeFunction, intrinsic);
3202     putDirectWithoutTransition(vm, propertyName, function, attributes);
3203 }
3204 
3205 JSFunction* JSObject::putDirectBuiltinFunction(VM&amp; vm, JSGlobalObject* globalObject, const PropertyName&amp; propertyName, FunctionExecutable* functionExecutable, unsigned attributes)
3206 {
3207     StringImpl* name = propertyName.publicName();
3208     if (!name)
3209         name = vm.propertyNames-&gt;anonymous.impl();
3210     ASSERT(name);
3211     JSFunction* function = JSFunction::create(vm, static_cast&lt;FunctionExecutable*&gt;(functionExecutable), globalObject);
3212     putDirect(vm, propertyName, function, attributes);
3213     return function;
3214 }
3215 
3216 JSFunction* JSObject::putDirectBuiltinFunctionWithoutTransition(VM&amp; vm, JSGlobalObject* globalObject, const PropertyName&amp; propertyName, FunctionExecutable* functionExecutable, unsigned attributes)
3217 {
3218     JSFunction* function = JSFunction::create(vm, static_cast&lt;FunctionExecutable*&gt;(functionExecutable), globalObject);
3219     putDirectWithoutTransition(vm, propertyName, function, attributes);
3220     return function;
3221 }
3222 
3223 // NOTE: This method is for ArrayStorage vectors.
3224 ALWAYS_INLINE unsigned JSObject::getNewVectorLength(VM&amp; vm, unsigned indexBias, unsigned currentVectorLength, unsigned currentLength, unsigned desiredLength)
3225 {
3226     ASSERT(desiredLength &lt;= MAX_STORAGE_VECTOR_LENGTH);
3227 
3228     unsigned increasedLength;
3229     unsigned maxInitLength = std::min(currentLength, 100000U);
3230 
3231     if (desiredLength &lt; maxInitLength)
3232         increasedLength = maxInitLength;
3233     else if (!currentVectorLength)
3234         increasedLength = std::max(desiredLength, lastArraySize);
3235     else {
3236         increasedLength = timesThreePlusOneDividedByTwo(desiredLength);
3237     }
3238 
3239     ASSERT(increasedLength &gt;= desiredLength);
3240 
3241     lastArraySize = std::min(increasedLength, FIRST_ARRAY_STORAGE_VECTOR_GROW);
3242 
3243     return ArrayStorage::optimalVectorLength(
3244         indexBias, structure(vm)-&gt;outOfLineCapacity(),
3245         std::min(increasedLength, MAX_STORAGE_VECTOR_LENGTH));
3246 }
3247 
3248 ALWAYS_INLINE unsigned JSObject::getNewVectorLength(VM&amp; vm, unsigned desiredLength)
3249 {
3250     unsigned indexBias = 0;
3251     unsigned vectorLength = 0;
3252     unsigned length = 0;
3253 
3254     if (hasIndexedProperties(indexingType())) {
3255         if (ArrayStorage* storage = arrayStorageOrNull())
3256             indexBias = storage-&gt;m_indexBias;
3257         vectorLength = m_butterfly-&gt;vectorLength();
3258         length = m_butterfly-&gt;publicLength();
3259     }
3260 
3261     return getNewVectorLength(vm, indexBias, vectorLength, length, desiredLength);
3262 }
3263 
3264 template&lt;IndexingType indexingShape&gt;
3265 unsigned JSObject::countElements(Butterfly* butterfly)
3266 {
3267     unsigned numValues = 0;
3268     for (unsigned i = butterfly-&gt;publicLength(); i--;) {
3269         switch (indexingShape) {
3270         case Int32Shape:
3271         case ContiguousShape:
3272             if (butterfly-&gt;contiguous().at(this, i))
3273                 numValues++;
3274             break;
3275 
3276         case DoubleShape: {
3277             double value = butterfly-&gt;contiguousDouble().at(this, i);
3278             if (value == value)
3279                 numValues++;
3280             break;
3281         }
3282 
3283         default:
3284             CRASH();
3285         }
3286     }
3287     return numValues;
3288 }
3289 
3290 unsigned JSObject::countElements()
3291 {
3292     switch (indexingType()) {
3293     case ALL_BLANK_INDEXING_TYPES:
3294     case ALL_UNDECIDED_INDEXING_TYPES:
3295         return 0;
3296 
3297     case ALL_INT32_INDEXING_TYPES:
3298         return countElements&lt;Int32Shape&gt;(butterfly());
3299 
3300     case ALL_DOUBLE_INDEXING_TYPES:
3301         return countElements&lt;DoubleShape&gt;(butterfly());
3302 
3303     case ALL_CONTIGUOUS_INDEXING_TYPES:
3304         return countElements&lt;ContiguousShape&gt;(butterfly());
3305 
3306     default:
3307         CRASH();
3308         return 0;
3309     }
3310 }
3311 
3312 bool JSObject::increaseVectorLength(VM&amp; vm, unsigned newLength)
3313 {
3314     ArrayStorage* storage = arrayStorage();
3315 
3316     unsigned vectorLength = storage-&gt;vectorLength();
3317     unsigned availableVectorLength = storage-&gt;availableVectorLength(structure(vm), vectorLength);
3318     if (availableVectorLength &gt;= newLength) {
3319         // The cell was already big enough for the desired length!
3320         for (unsigned i = vectorLength; i &lt; availableVectorLength; ++i)
3321             storage-&gt;m_vector[i].clear();
3322         storage-&gt;setVectorLength(availableVectorLength);
3323         return true;
3324     }
3325 
3326     // This function leaves the array in an internally inconsistent state, because it does not move any values from sparse value map
3327     // to the vector. Callers have to account for that, because they can do it more efficiently.
3328     if (newLength &gt; MAX_STORAGE_VECTOR_LENGTH)
3329         return false;
3330 
3331     if (newLength &gt;= MIN_SPARSE_ARRAY_INDEX
3332         &amp;&amp; !isDenseEnoughForVector(newLength, storage-&gt;m_numValuesInVector))
3333         return false;
3334 
3335     unsigned indexBias = storage-&gt;m_indexBias;
3336     ASSERT(newLength &gt; vectorLength);
3337     unsigned newVectorLength = getNewVectorLength(vm, newLength);
3338 
3339     // Fast case - there is no precapacity. In these cases a realloc makes sense.
3340     Structure* structure = this-&gt;structure(vm);
3341     if (LIKELY(!indexBias)) {
3342         DeferGC deferGC(vm.heap);
3343         Butterfly* newButterfly = storage-&gt;butterfly()-&gt;growArrayRight(
3344             vm, this, structure, structure-&gt;outOfLineCapacity(), true,
3345             ArrayStorage::sizeFor(vectorLength), ArrayStorage::sizeFor(newVectorLength));
3346         if (!newButterfly)
3347             return false;
3348         for (unsigned i = vectorLength; i &lt; newVectorLength; ++i)
3349             newButterfly-&gt;arrayStorage()-&gt;m_vector[i].clear();
3350         newButterfly-&gt;arrayStorage()-&gt;setVectorLength(newVectorLength);
3351         setButterfly(vm, newButterfly);
3352         return true;
3353     }
3354 
3355     // Remove some, but not all of the precapacity. Atomic decay, &amp; capped to not overflow array length.
3356     DeferGC deferGC(vm.heap);
3357     unsigned newIndexBias = std::min(indexBias &gt;&gt; 1, MAX_STORAGE_VECTOR_LENGTH - newVectorLength);
3358     Butterfly* newButterfly = storage-&gt;butterfly()-&gt;resizeArray(
3359         vm, this,
3360         structure-&gt;outOfLineCapacity(), true, ArrayStorage::sizeFor(vectorLength),
3361         newIndexBias, true, ArrayStorage::sizeFor(newVectorLength));
3362     if (!newButterfly)
3363         return false;
3364     for (unsigned i = vectorLength; i &lt; newVectorLength; ++i)
3365         newButterfly-&gt;arrayStorage()-&gt;m_vector[i].clear();
3366     newButterfly-&gt;arrayStorage()-&gt;setVectorLength(newVectorLength);
3367     newButterfly-&gt;arrayStorage()-&gt;m_indexBias = newIndexBias;
3368     setButterfly(vm, newButterfly);
3369     return true;
3370 }
3371 
3372 bool JSObject::ensureLengthSlow(VM&amp; vm, unsigned length)
3373 {
3374     if (isCopyOnWrite(indexingMode())) {
3375         convertFromCopyOnWrite(vm);
3376         if (m_butterfly-&gt;vectorLength() &gt;= length)
3377             return true;
3378     }
3379 
3380     Butterfly* butterfly = this-&gt;butterfly();
3381 
3382     ASSERT(length &lt;= MAX_STORAGE_VECTOR_LENGTH);
3383     ASSERT(hasContiguous(indexingType()) || hasInt32(indexingType()) || hasDouble(indexingType()) || hasUndecided(indexingType()));
3384     ASSERT(length &gt; butterfly-&gt;vectorLength());
3385 
3386     unsigned oldVectorLength = butterfly-&gt;vectorLength();
3387     unsigned newVectorLength;
3388 
3389     Structure* structure = this-&gt;structure(vm);
3390     unsigned propertyCapacity = structure-&gt;outOfLineCapacity();
3391 
3392     GCDeferralContext deferralContext(vm.heap);
3393     DisallowGC disallowGC;
3394     unsigned availableOldLength =
3395         Butterfly::availableContiguousVectorLength(propertyCapacity, oldVectorLength);
3396     Butterfly* newButterfly = nullptr;
3397     if (availableOldLength &gt;= length) {
3398         // This is the case where someone else selected a vector length that caused internal
3399         // fragmentation. If we did our jobs right, this would never happen. But I bet we will mess
3400         // this up, so this defense should stay.
3401         newVectorLength = availableOldLength;
3402     } else {
3403         newVectorLength = Butterfly::optimalContiguousVectorLength(
3404             propertyCapacity, std::min(length * 2, MAX_STORAGE_VECTOR_LENGTH));
3405         butterfly = butterfly-&gt;reallocArrayRightIfPossible(
3406             vm, deferralContext, this, structure, propertyCapacity, true,
3407             oldVectorLength * sizeof(EncodedJSValue),
3408             newVectorLength * sizeof(EncodedJSValue));
3409         if (!butterfly)
3410             return false;
3411         newButterfly = butterfly;
3412     }
3413 
3414     if (hasDouble(indexingType())) {
3415         for (unsigned i = oldVectorLength; i &lt; newVectorLength; ++i)
3416             butterfly-&gt;indexingPayload&lt;double&gt;()[i] = PNaN;
3417     } else {
3418         for (unsigned i = oldVectorLength; i &lt; newVectorLength; ++i)
3419             butterfly-&gt;indexingPayload&lt;WriteBarrier&lt;Unknown&gt;&gt;()[i].clear();
3420     }
3421 
3422     if (newButterfly) {
3423         butterfly-&gt;setVectorLength(newVectorLength);
3424         WTF::storeStoreFence();
3425         m_butterfly.set(vm, this, newButterfly);
3426     } else {
3427         WTF::storeStoreFence();
3428         butterfly-&gt;setVectorLength(newVectorLength);
3429     }
3430 
3431     return true;
3432 }
3433 
3434 void JSObject::reallocateAndShrinkButterfly(VM&amp; vm, unsigned length)
3435 {
3436     ASSERT(length &lt;= MAX_STORAGE_VECTOR_LENGTH);
3437     ASSERT(hasContiguous(indexingType()) || hasInt32(indexingType()) || hasDouble(indexingType()) || hasUndecided(indexingType()));
3438     ASSERT(m_butterfly-&gt;vectorLength() &gt; length);
3439     ASSERT(m_butterfly-&gt;publicLength() &gt;= length);
3440     ASSERT(!m_butterfly-&gt;indexingHeader()-&gt;preCapacity(structure(vm)));
3441 
3442     DeferGC deferGC(vm.heap);
3443     Butterfly* newButterfly = butterfly()-&gt;resizeArray(vm, this, structure(vm), 0, ArrayStorage::sizeFor(length));
3444     newButterfly-&gt;setVectorLength(length);
3445     newButterfly-&gt;setPublicLength(length);
3446     WTF::storeStoreFence();
3447     m_butterfly.set(vm, this, newButterfly);
3448 
3449 }
3450 
3451 Butterfly* JSObject::allocateMoreOutOfLineStorage(VM&amp; vm, size_t oldSize, size_t newSize)
3452 {
3453     ASSERT(newSize &gt; oldSize);
3454 
3455     // It&#39;s important that this function not rely on structure(), for the property
3456     // capacity, since we might have already mutated the structure in-place.
3457 
3458     return Butterfly::createOrGrowPropertyStorage(butterfly(), vm, this, structure(vm), oldSize, newSize);
3459 }
3460 
3461 static JSCustomGetterSetterFunction* getCustomGetterSetterFunctionForGetterSetter(JSGlobalObject* globalObject, PropertyName propertyName, CustomGetterSetter* getterSetter, JSCustomGetterSetterFunction::Type type)
3462 {
3463     VM&amp; vm = globalObject-&gt;vm();
3464     auto key = std::make_pair(getterSetter, (int)type);
3465     JSCustomGetterSetterFunction* customGetterSetterFunction = vm.customGetterSetterFunctionMap.get(key);
3466     if (!customGetterSetterFunction) {
3467         customGetterSetterFunction = JSCustomGetterSetterFunction::create(vm, globalObject, getterSetter, type, propertyName.publicName());
3468         vm.customGetterSetterFunctionMap.set(key, customGetterSetterFunction);
3469     }
3470     return customGetterSetterFunction;
3471 }
3472 
3473 bool JSObject::getOwnPropertyDescriptor(JSGlobalObject* globalObject, PropertyName propertyName, PropertyDescriptor&amp; descriptor)
3474 {
3475     VM&amp; vm = globalObject-&gt;vm();
3476     auto scope = DECLARE_THROW_SCOPE(vm);
3477     JSC::PropertySlot slot(this, PropertySlot::InternalMethodType::GetOwnProperty);
3478 
3479     bool result = methodTable(vm)-&gt;getOwnPropertySlot(this, globalObject, propertyName, slot);
3480     EXCEPTION_ASSERT(!scope.exception() || !result);
3481     if (!result)
3482         return false;
3483 
3484 
3485     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=200560
3486     // This breaks the assumption that getOwnPropertySlot should return &quot;own&quot; property.
3487     // We should fix DebuggerScope, ProxyObject etc. to remove this.
3488     //
3489     // DebuggerScope::getOwnPropertySlot() (and possibly others) may return attributes from the prototype chain
3490     // but getOwnPropertyDescriptor() should only work for &#39;own&#39; properties so we exit early if we detect that
3491     // the property is not an own property.
3492     if (slot.slotBase() != this &amp;&amp; slot.slotBase()) {
3493         JSProxy* jsProxy = jsDynamicCast&lt;JSProxy*&gt;(vm, this);
3494         if (!jsProxy || jsProxy-&gt;target() != slot.slotBase()) {
3495             // Try ProxyObject.
3496             ProxyObject* proxyObject = jsDynamicCast&lt;ProxyObject*&gt;(vm, this);
3497             if (!proxyObject || proxyObject-&gt;target() != slot.slotBase())
3498                 return false;
3499         }
3500     }
3501 
3502     if (slot.isAccessor())
3503         descriptor.setAccessorDescriptor(slot.getterSetter(), slot.attributes());
3504     else if (slot.attributes() &amp; PropertyAttribute::CustomAccessor) {
3505         descriptor.setCustomDescriptor(slot.attributes());
3506 
3507         JSObject* thisObject = this;
3508         if (auto* proxy = jsDynamicCast&lt;JSProxy*&gt;(vm, this))
3509             thisObject = proxy-&gt;target();
3510 
3511         CustomGetterSetter* getterSetter;
3512         if (slot.isCustomAccessor())
3513             getterSetter = slot.customGetterSetter();
3514         else {
3515             JSValue maybeGetterSetter = thisObject-&gt;getDirect(vm, propertyName);
3516             if (!maybeGetterSetter) {
3517                 thisObject-&gt;reifyAllStaticProperties(globalObject);
3518                 maybeGetterSetter = thisObject-&gt;getDirect(vm, propertyName);
3519             }
3520 
3521             ASSERT(maybeGetterSetter);
3522             getterSetter = jsDynamicCast&lt;CustomGetterSetter*&gt;(vm, maybeGetterSetter);
3523         }
3524         ASSERT(getterSetter);
3525         if (!getterSetter)
3526             return false;
3527 
3528         if (getterSetter-&gt;getter())
3529             descriptor.setGetter(getCustomGetterSetterFunctionForGetterSetter(globalObject, propertyName, getterSetter, JSCustomGetterSetterFunction::Type::Getter));
3530         if (getterSetter-&gt;setter())
3531             descriptor.setSetter(getCustomGetterSetterFunctionForGetterSetter(globalObject, propertyName, getterSetter, JSCustomGetterSetterFunction::Type::Setter));
3532     } else {
3533         JSValue value = slot.getValue(globalObject, propertyName);
3534         RETURN_IF_EXCEPTION(scope, false);
3535         descriptor.setDescriptor(value, slot.attributes());
3536     }
3537 
3538     return true;
3539 }
3540 
3541 static bool putDescriptor(JSGlobalObject* globalObject, JSObject* target, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, unsigned attributes, const PropertyDescriptor&amp; oldDescriptor)
3542 {
3543     VM&amp; vm = globalObject-&gt;vm();
3544     if (descriptor.isGenericDescriptor() || descriptor.isDataDescriptor()) {
3545         if (descriptor.isGenericDescriptor() &amp;&amp; oldDescriptor.isAccessorDescriptor()) {
3546             JSObject* getter = oldDescriptor.getterPresent() ? oldDescriptor.getterObject() : nullptr;
3547             JSObject* setter = oldDescriptor.setterPresent() ? oldDescriptor.setterObject() : nullptr;
3548             GetterSetter* accessor = GetterSetter::create(vm, globalObject, getter, setter);
3549             target-&gt;putDirectAccessor(globalObject, propertyName, accessor, attributes | PropertyAttribute::Accessor);
3550             return true;
3551         }
3552         JSValue newValue = jsUndefined();
3553         if (descriptor.value())
3554             newValue = descriptor.value();
3555         else if (oldDescriptor.value())
3556             newValue = oldDescriptor.value();
3557         target-&gt;putDirect(vm, propertyName, newValue, attributes &amp; ~PropertyAttribute::Accessor);
3558         if (attributes &amp; PropertyAttribute::ReadOnly)
3559             target-&gt;structure(vm)-&gt;setContainsReadOnlyProperties();
3560         return true;
3561     }
3562     attributes &amp;= ~PropertyAttribute::ReadOnly;
3563 
3564     JSObject* getter = descriptor.getterPresent()
3565         ? descriptor.getterObject() : oldDescriptor.getterPresent()
3566         ? oldDescriptor.getterObject() : nullptr;
3567     JSObject* setter = descriptor.setterPresent()
3568         ? descriptor.setterObject() : oldDescriptor.setterPresent()
3569         ? oldDescriptor.setterObject() : nullptr;
3570     GetterSetter* accessor = GetterSetter::create(vm, globalObject, getter, setter);
3571 
3572     target-&gt;putDirectAccessor(globalObject, propertyName, accessor, attributes | PropertyAttribute::Accessor);
3573     return true;
3574 }
3575 
3576 bool JSObject::putDirectMayBeIndex(JSGlobalObject* globalObject, PropertyName propertyName, JSValue value)
3577 {
3578     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
3579         return putDirectIndex(globalObject, index.value(), value);
3580     return putDirect(globalObject-&gt;vm(), propertyName, value);
3581 }
3582 
3583 // 9.1.6.3 of the spec
3584 // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-validateandapplypropertydescriptor
3585 bool validateAndApplyPropertyDescriptor(JSGlobalObject* globalObject, JSObject* object, PropertyName propertyName, bool isExtensible,
3586     const PropertyDescriptor&amp; descriptor, bool isCurrentDefined, const PropertyDescriptor&amp; current, bool throwException)
3587 {
3588     VM&amp; vm = globalObject-&gt;vm();
3589     auto scope = DECLARE_THROW_SCOPE(vm);
3590 
3591     // If we have a new property we can just put it on normally
3592     // Step 2.
3593     if (!isCurrentDefined) {
3594         // unless extensions are prevented!
3595         // Step 2.a
3596         if (!isExtensible)
3597             return typeError(globalObject, scope, throwException, NonExtensibleObjectPropertyDefineError);
3598         if (!object)
3599             return true;
3600         // Step 2.c/d
3601         PropertyDescriptor oldDescriptor;
3602         oldDescriptor.setValue(jsUndefined());
3603         // FIXME: spec says to always return true here.
3604         return putDescriptor(globalObject, object, propertyName, descriptor, descriptor.attributes(), oldDescriptor);
3605     }
3606     // Step 3.
3607     if (descriptor.isEmpty())
3608         return true;
3609     // Step 4.
3610     bool isEqual = current.equalTo(globalObject, descriptor);
3611     RETURN_IF_EXCEPTION(scope, false);
3612     if (isEqual)
3613         return true;
3614 
3615     // Step 5.
3616     // Filter out invalid changes
3617     if (!current.configurable()) {
3618         if (descriptor.configurable())
3619             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeConfigurabilityError);
3620         if (descriptor.enumerablePresent() &amp;&amp; descriptor.enumerable() != current.enumerable())
3621             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeEnumerabilityError);
3622     }
3623 
3624     // Step 6.
3625     // A generic descriptor is simply changing the attributes of an existing property
3626     if (descriptor.isGenericDescriptor()) {
3627         if (!current.attributesEqual(descriptor) &amp;&amp; object) {
3628             object-&gt;methodTable(vm)-&gt;deleteProperty(object, globalObject, propertyName);
3629             RETURN_IF_EXCEPTION(scope, false);
3630             return putDescriptor(globalObject, object, propertyName, descriptor, descriptor.attributesOverridingCurrent(current), current);
3631         }
3632         return true;
3633     }
3634 
3635     // Step 7.
3636     // Changing between a normal property or an accessor property
3637     if (descriptor.isDataDescriptor() != current.isDataDescriptor()) {
3638         if (!current.configurable())
3639             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);
3640 
3641         if (!object)
3642             return true;
3643 
3644         object-&gt;methodTable(vm)-&gt;deleteProperty(object, globalObject, propertyName);
3645         RETURN_IF_EXCEPTION(scope, false);
3646         return putDescriptor(globalObject, object, propertyName, descriptor, descriptor.attributesOverridingCurrent(current), current);
3647     }
3648 
3649     // Step 8.
3650     // Changing the value and attributes of an existing property
3651     if (descriptor.isDataDescriptor()) {
3652         if (!current.configurable()) {
3653             if (!current.writable() &amp;&amp; descriptor.writable())
3654                 return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeWritabilityError);
3655             if (!current.writable()) {
3656                 if (descriptor.value()) {
3657                     bool isSame = sameValue(globalObject, current.value(), descriptor.value());
3658                     RETURN_IF_EXCEPTION(scope, false);
3659                     if (!isSame)
3660                         return typeError(globalObject, scope, throwException, ReadonlyPropertyChangeError);
3661                 }
3662             }
3663         }
3664         if (current.attributesEqual(descriptor) &amp;&amp; !descriptor.value())
3665             return true;
3666         if (!object)
3667             return true;
3668         object-&gt;methodTable(vm)-&gt;deleteProperty(object, globalObject, propertyName);
3669         RETURN_IF_EXCEPTION(scope, false);
3670         return putDescriptor(globalObject, object, propertyName, descriptor, descriptor.attributesOverridingCurrent(current), current);
3671     }
3672 
3673     // Step 9.
3674     // Changing the accessor functions of an existing accessor property
3675     ASSERT(descriptor.isAccessorDescriptor());
3676     if (!current.configurable()) {
3677         if (descriptor.setterPresent() &amp;&amp; !(current.setterPresent() &amp;&amp; JSValue::strictEqual(globalObject, current.setter(), descriptor.setter())))
3678             return typeError(globalObject, scope, throwException, &quot;Attempting to change the setter of an unconfigurable property.&quot;_s);
3679         if (descriptor.getterPresent() &amp;&amp; !(current.getterPresent() &amp;&amp; JSValue::strictEqual(globalObject, current.getter(), descriptor.getter())))
3680             return typeError(globalObject, scope, throwException, &quot;Attempting to change the getter of an unconfigurable property.&quot;_s);
3681         if (current.attributes() &amp; PropertyAttribute::CustomAccessor)
3682             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);
3683     }
3684 
3685     // Step 10/11.
3686     if (!object)
3687         return true;
3688     JSValue accessor = object-&gt;getDirect(vm, propertyName);
3689     if (!accessor)
3690         return false;
3691     JSObject* getter = nullptr;
3692     JSObject* setter = nullptr;
3693     bool getterSetterChanged = false;
3694 
3695     if (accessor.isCustomGetterSetter()) {
3696         auto* customGetterSetter = jsCast&lt;CustomGetterSetter*&gt;(accessor);
3697         if (customGetterSetter-&gt;setter())
3698             setter = getCustomGetterSetterFunctionForGetterSetter(globalObject, propertyName, customGetterSetter, JSCustomGetterSetterFunction::Type::Setter);
3699         if (customGetterSetter-&gt;getter())
3700             getter = getCustomGetterSetterFunctionForGetterSetter(globalObject, propertyName, customGetterSetter, JSCustomGetterSetterFunction::Type::Getter);
3701     } else {
3702         ASSERT(accessor.isGetterSetter());
3703         auto* getterSetter = jsCast&lt;GetterSetter*&gt;(accessor);
3704         getter = getterSetter-&gt;getter();
3705         setter = getterSetter-&gt;setter();
3706     }
3707     if (descriptor.setterPresent()) {
3708         setter = descriptor.setterObject();
3709         getterSetterChanged = true;
3710     }
3711     if (descriptor.getterPresent()) {
3712         getter = descriptor.getterObject();
3713         getterSetterChanged = true;
3714     }
3715 
3716     if (current.attributesEqual(descriptor) &amp;&amp; !getterSetterChanged)
3717         return true;
3718 
3719     GetterSetter* getterSetter = GetterSetter::create(vm, globalObject, getter, setter);
3720 
3721     object-&gt;methodTable(vm)-&gt;deleteProperty(object, globalObject, propertyName);
3722     RETURN_IF_EXCEPTION(scope, false);
3723     unsigned attrs = descriptor.attributesOverridingCurrent(current);
3724     object-&gt;putDirectAccessor(globalObject, propertyName, getterSetter, attrs | PropertyAttribute::Accessor);
3725     return true;
3726 }
3727 
3728 bool JSObject::defineOwnNonIndexProperty(JSGlobalObject* globalObject, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool throwException)
3729 {
3730     VM&amp; vm  = globalObject-&gt;vm();
3731     auto throwScope = DECLARE_THROW_SCOPE(vm);
3732 
3733     // Track on the globaldata that we&#39;re in define property.
3734     // Currently DefineOwnProperty uses delete to remove properties when they are being replaced
3735     // (particularly when changing attributes), however delete won&#39;t allow non-configurable (i.e.
3736     // DontDelete) properties to be deleted. For now, we can use this flag to make this work.
3737     VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);
3738     PropertyDescriptor current;
3739     bool isCurrentDefined = getOwnPropertyDescriptor(globalObject, propertyName, current);
3740     RETURN_IF_EXCEPTION(throwScope, false);
3741     bool isExtensible = this-&gt;isExtensible(globalObject);
3742     RETURN_IF_EXCEPTION(throwScope, false);
3743     RELEASE_AND_RETURN(throwScope, validateAndApplyPropertyDescriptor(globalObject, this, propertyName, isExtensible, descriptor, isCurrentDefined, current, throwException));
3744 }
3745 
3746 bool JSObject::defineOwnProperty(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool throwException)
3747 {
3748     // If it&#39;s an array index, then use the indexed property storage.
3749     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName)) {
3750         // c. Let succeeded be the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing P, Desc, and false as arguments.
3751         // d. Reject if succeeded is false.
3752         // e. If index &gt;= oldLen
3753         // e.i. Set oldLenDesc.[[Value]] to index + 1.
3754         // e.ii. Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, oldLenDesc, and false as arguments. This call will always return true.
3755         // f. Return true.
3756         return object-&gt;defineOwnIndexedProperty(globalObject, index.value(), descriptor, throwException);
3757     }
3758 
3759     return object-&gt;defineOwnNonIndexProperty(globalObject, propertyName, descriptor, throwException);
3760 }
3761 
3762 void JSObject::convertToDictionary(VM&amp; vm)
3763 {
3764     DeferredStructureTransitionWatchpointFire deferredWatchpointFire(vm, structure(vm));
3765     setStructure(
3766         vm, Structure::toCacheableDictionaryTransition(vm, structure(vm), &amp;deferredWatchpointFire));
3767 }
3768 
3769 void JSObject::shiftButterflyAfterFlattening(const GCSafeConcurrentJSLocker&amp;, VM&amp; vm, Structure* structure, size_t outOfLineCapacityAfter)
3770 {
3771     // This could interleave visitChildren because some old structure could have been a non
3772     // dictionary structure. We have to be crazy careful. But, we are guaranteed to be holding
3773     // the structure&#39;s lock right now, and that helps a bit.
3774 
3775     Butterfly* oldButterfly = this-&gt;butterfly();
3776     size_t preCapacity;
3777     size_t indexingPayloadSizeInBytes;
3778     bool hasIndexingHeader = this-&gt;hasIndexingHeader(vm);
3779     if (UNLIKELY(hasIndexingHeader)) {
3780         preCapacity = oldButterfly-&gt;indexingHeader()-&gt;preCapacity(structure);
3781         indexingPayloadSizeInBytes = oldButterfly-&gt;indexingHeader()-&gt;indexingPayloadSizeInBytes(structure);
3782     } else {
3783         preCapacity = 0;
3784         indexingPayloadSizeInBytes = 0;
3785     }
3786 
3787     Butterfly* newButterfly = Butterfly::createUninitialized(vm, this, preCapacity, outOfLineCapacityAfter, hasIndexingHeader, indexingPayloadSizeInBytes);
3788 
3789     // No need to copy the precapacity.
3790     void* currentBase = oldButterfly-&gt;base(0, outOfLineCapacityAfter);
3791     void* newBase = newButterfly-&gt;base(0, outOfLineCapacityAfter);
3792 
3793     gcSafeMemcpy(static_cast&lt;JSValue*&gt;(newBase), static_cast&lt;JSValue*&gt;(currentBase), Butterfly::totalSize(0, outOfLineCapacityAfter, hasIndexingHeader, indexingPayloadSizeInBytes));
3794 
3795     setButterfly(vm, newButterfly);
3796 }
3797 
3798 uint32_t JSObject::getEnumerableLength(JSGlobalObject* globalObject, JSObject* object)
3799 {
3800     VM&amp; vm = globalObject-&gt;vm();
3801     Structure* structure = object-&gt;structure(vm);
3802     if (structure-&gt;holesMustForwardToPrototype(vm, object))
3803         return 0;
3804     switch (object-&gt;indexingType()) {
3805     case ALL_BLANK_INDEXING_TYPES:
3806     case ALL_UNDECIDED_INDEXING_TYPES:
3807         return 0;
3808 
3809     case ALL_INT32_INDEXING_TYPES:
3810     case ALL_CONTIGUOUS_INDEXING_TYPES: {
3811         Butterfly* butterfly = object-&gt;butterfly();
3812         unsigned usedLength = butterfly-&gt;publicLength();
3813         for (unsigned i = 0; i &lt; usedLength; ++i) {
3814             if (!butterfly-&gt;contiguous().at(object, i))
3815                 return 0;
3816         }
3817         return usedLength;
3818     }
3819 
3820     case ALL_DOUBLE_INDEXING_TYPES: {
3821         Butterfly* butterfly = object-&gt;butterfly();
3822         unsigned usedLength = butterfly-&gt;publicLength();
3823         for (unsigned i = 0; i &lt; usedLength; ++i) {
3824             double value = butterfly-&gt;contiguousDouble().at(object, i);
3825             if (value != value)
3826                 return 0;
3827         }
3828         return usedLength;
3829     }
3830 
3831     case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
3832         ArrayStorage* storage = object-&gt;m_butterfly-&gt;arrayStorage();
3833         if (storage-&gt;m_sparseMap.get())
3834             return 0;
3835 
3836         unsigned usedVectorLength = std::min(storage-&gt;length(), storage-&gt;vectorLength());
3837         for (unsigned i = 0; i &lt; usedVectorLength; ++i) {
3838             if (!storage-&gt;m_vector[i])
3839                 return 0;
3840         }
3841         return usedVectorLength;
3842     }
3843 
3844     default:
3845         RELEASE_ASSERT_NOT_REACHED();
3846         return 0;
3847     }
3848 }
3849 
3850 void JSObject::getStructurePropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)
3851 {
3852     VM&amp; vm = globalObject-&gt;vm();
3853     object-&gt;structure(vm)-&gt;getPropertyNamesFromStructure(vm, propertyNames, mode);
3854 }
3855 
3856 void JSObject::getGenericPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)
3857 {
3858     VM&amp; vm = globalObject-&gt;vm();
3859     auto scope = DECLARE_THROW_SCOPE(vm);
3860     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, globalObject, propertyNames, EnumerationMode(mode, JSObjectPropertiesMode::Exclude));
3861     RETURN_IF_EXCEPTION(scope, void());
3862 
3863     JSValue nextProto = object-&gt;getPrototype(vm, globalObject);
3864     RETURN_IF_EXCEPTION(scope, void());
3865     if (nextProto.isNull())
3866         return;
3867 
3868     JSObject* prototype = asObject(nextProto);
3869     while (true) {
3870         if (prototype-&gt;structure(vm)-&gt;typeInfo().overridesGetPropertyNames()) {
3871             scope.release();
3872             prototype-&gt;methodTable(vm)-&gt;getPropertyNames(prototype, globalObject, propertyNames, mode);
3873             return;
3874         }
3875         prototype-&gt;methodTable(vm)-&gt;getOwnPropertyNames(prototype, globalObject, propertyNames, mode);
3876         RETURN_IF_EXCEPTION(scope, void());
3877         nextProto = prototype-&gt;getPrototype(vm, globalObject);
3878         RETURN_IF_EXCEPTION(scope, void());
3879         if (nextProto.isNull())
3880             break;
3881         prototype = asObject(nextProto);
3882     }
3883 }
3884 
3885 // Implements GetMethod(O, P) in section 7.3.9 of the spec.
3886 // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-getmethod
3887 JSValue JSObject::getMethod(JSGlobalObject* globalObject, CallData&amp; callData, CallType&amp; callType, const Identifier&amp; ident, const String&amp; errorMessage)
3888 {
3889     VM&amp; vm = globalObject-&gt;vm();
3890     auto scope = DECLARE_THROW_SCOPE(vm);
3891 
3892     JSValue method = get(globalObject, ident);
3893     RETURN_IF_EXCEPTION(scope, JSValue());
3894 
3895     if (!method.isCell()) {
3896         if (method.isUndefinedOrNull())
3897             return jsUndefined();
3898 
3899         throwVMTypeError(globalObject, scope, errorMessage);
3900         return jsUndefined();
3901     }
3902 
3903     callType = method.asCell()-&gt;methodTable(vm)-&gt;getCallData(method.asCell(), callData);
3904     if (callType == CallType::None) {
3905         throwVMTypeError(globalObject, scope, errorMessage);
3906         return jsUndefined();
3907     }
3908 
3909     return method;
3910 }
3911 
3912 bool JSObject::anyObjectInChainMayInterceptIndexedAccesses(VM&amp; vm) const
3913 {
3914     for (const JSObject* current = this; ;) {
3915         if (current-&gt;structure(vm)-&gt;mayInterceptIndexedAccesses())
3916             return true;
3917 
3918         JSValue prototype = current-&gt;getPrototypeDirect(vm);
3919         if (prototype.isNull())
3920             return false;
3921 
3922         current = asObject(prototype);
3923     }
3924 }
3925 
3926 bool JSObject::prototypeChainMayInterceptStoreTo(VM&amp; vm, PropertyName propertyName)
3927 {
3928     if (parseIndex(propertyName))
3929         return anyObjectInChainMayInterceptIndexedAccesses(vm);
3930 
3931     for (JSObject* current = this; ;) {
3932         JSValue prototype = current-&gt;getPrototypeDirect(vm);
3933         if (prototype.isNull())
3934             return false;
3935 
3936         current = asObject(prototype);
3937 
3938         unsigned attributes;
3939         PropertyOffset offset = current-&gt;structure(vm)-&gt;get(vm, propertyName, attributes);
3940         if (!JSC::isValidOffset(offset))
3941             continue;
3942 
3943         if (attributes &amp; (PropertyAttribute::ReadOnly | PropertyAttribute::Accessor))
3944             return true;
3945 
3946         return false;
3947     }
3948 }
3949 
3950 bool JSObject::needsSlowPutIndexing(VM&amp; vm) const
3951 {
3952     return anyObjectInChainMayInterceptIndexedAccesses(vm) || globalObject(vm)-&gt;isHavingABadTime();
3953 }
3954 
3955 NonPropertyTransition JSObject::suggestedArrayStorageTransition(VM&amp; vm) const
3956 {
3957     if (needsSlowPutIndexing(vm))
3958         return NonPropertyTransition::AllocateSlowPutArrayStorage;
3959 
3960     return NonPropertyTransition::AllocateArrayStorage;
3961 }
3962 
3963 } // namespace JSC
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/ElementAndTextDescendantIterator.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Element.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ElementData.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/ElementAndTextDescendantIterator.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 60     ElementAndTextDescendantIterator&amp; traversePreviousSibling();
 61 
 62     unsigned depth() const { return m_depth; }
 63 
 64 private:
 65     static bool isElementOrText(const Node&amp; node) { return is&lt;Element&gt;(node) || is&lt;Text&gt;(node); }
 66     static Node* firstChild(Node&amp;);
 67     static Node* nextSibling(Node&amp;);
 68     static Node* previousSibling(Node&amp;);
 69 
 70     void popAncestorSiblingStack();
 71 
 72     Node* m_current;
 73     struct AncestorSibling {
 74         Node* node;
 75         unsigned depth;
 76     };
 77     Vector&lt;AncestorSibling, 16&gt; m_ancestorSiblingStack;
 78     unsigned m_depth { 0 };
 79 
<span class="line-modified"> 80 #if !ASSERT_DISABLED</span>
 81     ElementIteratorAssertions m_assertions;
 82 #endif
 83 };
 84 
 85 class ElementAndTextDescendantIteratorAdapter {
 86 public:
 87     explicit ElementAndTextDescendantIteratorAdapter(ContainerNode&amp; root);
 88     ElementAndTextDescendantIterator begin();
 89     ElementAndTextDescendantIterator end();
 90 
 91 private:
 92     ContainerNode&amp; m_root;
 93 };
 94 
 95 ElementAndTextDescendantIteratorAdapter elementAndTextDescendants(ContainerNode&amp;);
 96 
 97 // ElementAndTextDescendantIterator
 98 
 99 inline ElementAndTextDescendantIterator::ElementAndTextDescendantIterator()
100     : m_current(nullptr)
101 {
102 }
103 
104 inline ElementAndTextDescendantIterator::ElementAndTextDescendantIterator(ContainerNode&amp; root, FirstChildTag)
105     : m_current(firstChild(root))
<span class="line-modified">106 #if !ASSERT_DISABLED</span>
107     , m_assertions(m_current)
108 #endif
109 {
110     if (!m_current)
111         return;
112     m_ancestorSiblingStack.uncheckedAppend({ nullptr, 0 });
113     m_depth = 1;
114 }
115 
116 inline ElementAndTextDescendantIterator::ElementAndTextDescendantIterator(ContainerNode&amp; root, Node* current)
117     : m_current(current)
<span class="line-modified">118 #if !ASSERT_DISABLED</span>
119     , m_assertions(m_current)
120 #endif
121 {
122     if (!m_current)
123         return;
124     ASSERT(isElementOrText(*m_current));
125     if (m_current == &amp;root)
126         return;
127 
128     Vector&lt;Node*, 20&gt; ancestorStack;
129     auto* ancestor = m_current-&gt;parentNode();
130     while (ancestor != &amp;root) {
131         ancestorStack.append(ancestor);
132         ancestor = ancestor-&gt;parentNode();
133     }
134 
135     m_ancestorSiblingStack.uncheckedAppend({ nullptr, 0 });
136     for (unsigned i = ancestorStack.size(); i; --i) {
137         if (auto* sibling = nextSibling(*ancestorStack[i - 1]))
138             m_ancestorSiblingStack.append({ sibling, i });
139     }
140 
141     m_depth = ancestorStack.size() + 1;
142 }
143 
144 inline void ElementAndTextDescendantIterator::dropAssertions()
145 {
<span class="line-modified">146 #if !ASSERT_DISABLED</span>
147     m_assertions.clear();
148 #endif
149 }
150 
151 inline Node* ElementAndTextDescendantIterator::firstChild(Node&amp; current)
152 {
153     auto* node = current.firstChild();
154     while (node &amp;&amp; !isElementOrText(*node))
155         node = node-&gt;nextSibling();
156     return node;
157 }
158 
159 inline Node* ElementAndTextDescendantIterator::nextSibling(Node&amp; current)
160 {
161     auto* node = current.nextSibling();
162     while (node &amp;&amp; !isElementOrText(*node))
163         node = node-&gt;nextSibling();
164     return node;
165 }
166 
167 inline Node* ElementAndTextDescendantIterator::previousSibling(Node&amp; current)
168 {
169     auto* node = current.previousSibling();
170     while (node &amp;&amp; !isElementOrText(*node))
171         node = node-&gt;previousSibling();
172     return node;
173 }
174 
175 inline void ElementAndTextDescendantIterator::popAncestorSiblingStack()
176 {
177     m_current = m_ancestorSiblingStack.last().node;
178     m_depth = m_ancestorSiblingStack.last().depth;
179     m_ancestorSiblingStack.removeLast();
180 
<span class="line-modified">181 #if !ASSERT_DISABLED</span>
182     // Drop the assertion when the iterator reaches the end.
183     if (!m_current)
184         m_assertions.dropEventDispatchAssertion();
185 #endif
186 }
187 
188 inline ElementAndTextDescendantIterator&amp; ElementAndTextDescendantIterator::traverseNext()
189 {
190     ASSERT(m_current);
191     ASSERT(!m_assertions.domTreeHasMutated());
192 
193     auto* firstChild = ElementAndTextDescendantIterator::firstChild(*m_current);
194     auto* nextSibling = ElementAndTextDescendantIterator::nextSibling(*m_current);
195     if (firstChild) {
196         if (nextSibling)
197             m_ancestorSiblingStack.append({ nextSibling, m_depth });
198         ++m_depth;
199         m_current = firstChild;
200         return *this;
201     }
</pre>
<hr />
<pre>
213     ASSERT(m_current);
214     ASSERT(!m_assertions.domTreeHasMutated());
215 
216     auto* nextSibling = ElementAndTextDescendantIterator::nextSibling(*m_current);
217     if (!nextSibling) {
218         popAncestorSiblingStack();
219         return *this;
220     }
221 
222     m_current = nextSibling;
223     return *this;
224 }
225 
226 inline ElementAndTextDescendantIterator&amp; ElementAndTextDescendantIterator::traverseNextSibling()
227 {
228     ASSERT(m_current);
229     ASSERT(!m_assertions.domTreeHasMutated());
230 
231     m_current = nextSibling(*m_current);
232 
<span class="line-modified">233 #if !ASSERT_DISABLED</span>
234     if (!m_current)
235         m_assertions.dropEventDispatchAssertion();
236 #endif
237     return *this;
238 }
239 
240 inline ElementAndTextDescendantIterator&amp; ElementAndTextDescendantIterator::traversePreviousSibling()
241 {
242     ASSERT(m_current);
243     ASSERT(!m_assertions.domTreeHasMutated());
244 
245     m_current = previousSibling(*m_current);
246 
<span class="line-modified">247 #if !ASSERT_DISABLED</span>
248     if (!m_current)
249         m_assertions.dropEventDispatchAssertion();
250 #endif
251     return *this;
252 }
253 
254 inline Node&amp; ElementAndTextDescendantIterator::operator*()
255 {
256     ASSERT(m_current);
257     ASSERT(isElementOrText(*m_current));
258     ASSERT(!m_assertions.domTreeHasMutated());
259     return *m_current;
260 }
261 
262 inline Node* ElementAndTextDescendantIterator::operator-&gt;()
263 {
264     ASSERT(m_current);
265     ASSERT(isElementOrText(*m_current));
266     ASSERT(!m_assertions.domTreeHasMutated());
267     return m_current;
</pre>
</td>
<td>
<hr />
<pre>
 60     ElementAndTextDescendantIterator&amp; traversePreviousSibling();
 61 
 62     unsigned depth() const { return m_depth; }
 63 
 64 private:
 65     static bool isElementOrText(const Node&amp; node) { return is&lt;Element&gt;(node) || is&lt;Text&gt;(node); }
 66     static Node* firstChild(Node&amp;);
 67     static Node* nextSibling(Node&amp;);
 68     static Node* previousSibling(Node&amp;);
 69 
 70     void popAncestorSiblingStack();
 71 
 72     Node* m_current;
 73     struct AncestorSibling {
 74         Node* node;
 75         unsigned depth;
 76     };
 77     Vector&lt;AncestorSibling, 16&gt; m_ancestorSiblingStack;
 78     unsigned m_depth { 0 };
 79 
<span class="line-modified"> 80 #if ASSERT_ENABLED</span>
 81     ElementIteratorAssertions m_assertions;
 82 #endif
 83 };
 84 
 85 class ElementAndTextDescendantIteratorAdapter {
 86 public:
 87     explicit ElementAndTextDescendantIteratorAdapter(ContainerNode&amp; root);
 88     ElementAndTextDescendantIterator begin();
 89     ElementAndTextDescendantIterator end();
 90 
 91 private:
 92     ContainerNode&amp; m_root;
 93 };
 94 
 95 ElementAndTextDescendantIteratorAdapter elementAndTextDescendants(ContainerNode&amp;);
 96 
 97 // ElementAndTextDescendantIterator
 98 
 99 inline ElementAndTextDescendantIterator::ElementAndTextDescendantIterator()
100     : m_current(nullptr)
101 {
102 }
103 
104 inline ElementAndTextDescendantIterator::ElementAndTextDescendantIterator(ContainerNode&amp; root, FirstChildTag)
105     : m_current(firstChild(root))
<span class="line-modified">106 #if ASSERT_ENABLED</span>
107     , m_assertions(m_current)
108 #endif
109 {
110     if (!m_current)
111         return;
112     m_ancestorSiblingStack.uncheckedAppend({ nullptr, 0 });
113     m_depth = 1;
114 }
115 
116 inline ElementAndTextDescendantIterator::ElementAndTextDescendantIterator(ContainerNode&amp; root, Node* current)
117     : m_current(current)
<span class="line-modified">118 #if ASSERT_ENABLED</span>
119     , m_assertions(m_current)
120 #endif
121 {
122     if (!m_current)
123         return;
124     ASSERT(isElementOrText(*m_current));
125     if (m_current == &amp;root)
126         return;
127 
128     Vector&lt;Node*, 20&gt; ancestorStack;
129     auto* ancestor = m_current-&gt;parentNode();
130     while (ancestor != &amp;root) {
131         ancestorStack.append(ancestor);
132         ancestor = ancestor-&gt;parentNode();
133     }
134 
135     m_ancestorSiblingStack.uncheckedAppend({ nullptr, 0 });
136     for (unsigned i = ancestorStack.size(); i; --i) {
137         if (auto* sibling = nextSibling(*ancestorStack[i - 1]))
138             m_ancestorSiblingStack.append({ sibling, i });
139     }
140 
141     m_depth = ancestorStack.size() + 1;
142 }
143 
144 inline void ElementAndTextDescendantIterator::dropAssertions()
145 {
<span class="line-modified">146 #if ASSERT_ENABLED</span>
147     m_assertions.clear();
148 #endif
149 }
150 
151 inline Node* ElementAndTextDescendantIterator::firstChild(Node&amp; current)
152 {
153     auto* node = current.firstChild();
154     while (node &amp;&amp; !isElementOrText(*node))
155         node = node-&gt;nextSibling();
156     return node;
157 }
158 
159 inline Node* ElementAndTextDescendantIterator::nextSibling(Node&amp; current)
160 {
161     auto* node = current.nextSibling();
162     while (node &amp;&amp; !isElementOrText(*node))
163         node = node-&gt;nextSibling();
164     return node;
165 }
166 
167 inline Node* ElementAndTextDescendantIterator::previousSibling(Node&amp; current)
168 {
169     auto* node = current.previousSibling();
170     while (node &amp;&amp; !isElementOrText(*node))
171         node = node-&gt;previousSibling();
172     return node;
173 }
174 
175 inline void ElementAndTextDescendantIterator::popAncestorSiblingStack()
176 {
177     m_current = m_ancestorSiblingStack.last().node;
178     m_depth = m_ancestorSiblingStack.last().depth;
179     m_ancestorSiblingStack.removeLast();
180 
<span class="line-modified">181 #if ASSERT_ENABLED</span>
182     // Drop the assertion when the iterator reaches the end.
183     if (!m_current)
184         m_assertions.dropEventDispatchAssertion();
185 #endif
186 }
187 
188 inline ElementAndTextDescendantIterator&amp; ElementAndTextDescendantIterator::traverseNext()
189 {
190     ASSERT(m_current);
191     ASSERT(!m_assertions.domTreeHasMutated());
192 
193     auto* firstChild = ElementAndTextDescendantIterator::firstChild(*m_current);
194     auto* nextSibling = ElementAndTextDescendantIterator::nextSibling(*m_current);
195     if (firstChild) {
196         if (nextSibling)
197             m_ancestorSiblingStack.append({ nextSibling, m_depth });
198         ++m_depth;
199         m_current = firstChild;
200         return *this;
201     }
</pre>
<hr />
<pre>
213     ASSERT(m_current);
214     ASSERT(!m_assertions.domTreeHasMutated());
215 
216     auto* nextSibling = ElementAndTextDescendantIterator::nextSibling(*m_current);
217     if (!nextSibling) {
218         popAncestorSiblingStack();
219         return *this;
220     }
221 
222     m_current = nextSibling;
223     return *this;
224 }
225 
226 inline ElementAndTextDescendantIterator&amp; ElementAndTextDescendantIterator::traverseNextSibling()
227 {
228     ASSERT(m_current);
229     ASSERT(!m_assertions.domTreeHasMutated());
230 
231     m_current = nextSibling(*m_current);
232 
<span class="line-modified">233 #if ASSERT_ENABLED</span>
234     if (!m_current)
235         m_assertions.dropEventDispatchAssertion();
236 #endif
237     return *this;
238 }
239 
240 inline ElementAndTextDescendantIterator&amp; ElementAndTextDescendantIterator::traversePreviousSibling()
241 {
242     ASSERT(m_current);
243     ASSERT(!m_assertions.domTreeHasMutated());
244 
245     m_current = previousSibling(*m_current);
246 
<span class="line-modified">247 #if ASSERT_ENABLED</span>
248     if (!m_current)
249         m_assertions.dropEventDispatchAssertion();
250 #endif
251     return *this;
252 }
253 
254 inline Node&amp; ElementAndTextDescendantIterator::operator*()
255 {
256     ASSERT(m_current);
257     ASSERT(isElementOrText(*m_current));
258     ASSERT(!m_assertions.domTreeHasMutated());
259     return *m_current;
260 }
261 
262 inline Node* ElementAndTextDescendantIterator::operator-&gt;()
263 {
264     ASSERT(m_current);
265     ASSERT(isElementOrText(*m_current));
266     ASSERT(!m_assertions.domTreeHasMutated());
267     return m_current;
</pre>
</td>
</tr>
</table>
<center><a href="Element.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ElementData.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorStyleSheet.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2010, Google Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1.  Redistributions of source code must retain the above copyright
   8  *     notice, this list of conditions and the following disclaimer.
   9  * 2.  Redistributions in binary form must reproduce the above copyright
  10  *     notice, this list of conditions and the following disclaimer in the
  11  *     documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  15  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  16  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  17  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  18  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  19  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  20  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  21  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  22  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;InspectorStyleSheet.h&quot;
  27 
  28 #include &quot;CSSImportRule.h&quot;
  29 #include &quot;CSSKeyframesRule.h&quot;
  30 #include &quot;CSSMediaRule.h&quot;
  31 #include &quot;CSSParser.h&quot;
  32 #include &quot;CSSParserObserver.h&quot;
  33 #include &quot;CSSPropertyNames.h&quot;
  34 #include &quot;CSSPropertyParser.h&quot;
  35 #include &quot;CSSPropertySourceData.h&quot;
  36 #include &quot;CSSRule.h&quot;
  37 #include &quot;CSSRuleList.h&quot;
  38 #include &quot;CSSStyleRule.h&quot;
  39 #include &quot;CSSStyleSheet.h&quot;
  40 #include &quot;CSSSupportsRule.h&quot;
  41 #include &quot;ContentSecurityPolicy.h&quot;
  42 #include &quot;Document.h&quot;
  43 #include &quot;Element.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  44 #include &quot;ExtensionStyleSheets.h&quot;</span>
  45 #include &quot;HTMLHeadElement.h&quot;
  46 #include &quot;HTMLNames.h&quot;
  47 #include &quot;HTMLParserIdioms.h&quot;
  48 #include &quot;HTMLStyleElement.h&quot;
  49 #include &quot;InspectorCSSAgent.h&quot;
  50 #include &quot;InspectorDOMAgent.h&quot;
  51 #include &quot;InspectorPageAgent.h&quot;
  52 #include &quot;MediaList.h&quot;
  53 #include &quot;Node.h&quot;
  54 #include &quot;SVGElement.h&quot;
  55 #include &quot;SVGStyleElement.h&quot;
  56 #include &quot;StyleProperties.h&quot;
  57 #include &quot;StyleResolver.h&quot;
  58 #include &quot;StyleRule.h&quot;
  59 #include &quot;StyleRuleImport.h&quot;
  60 #include &quot;StyleSheetContents.h&quot;
  61 #include &quot;StyleSheetList.h&quot;
  62 #include &lt;JavaScriptCore/ContentSearchUtilities.h&gt;
  63 #include &lt;JavaScriptCore/RegularExpression.h&gt;
  64 #include &lt;wtf/text/StringBuilder.h&gt;
  65 
  66 using JSON::ArrayOf;
  67 using WebCore::RuleSourceDataList;
  68 using WebCore::CSSRuleSourceData;
  69 
  70 class ParsedStyleSheet {
  71     WTF_MAKE_FAST_ALLOCATED;
  72 public:
  73     ParsedStyleSheet();
  74 
  75     const String&amp; text() const { ASSERT(m_hasText); return m_text; }
  76     void setText(const String&amp; text);
  77     bool hasText() const { return m_hasText; }
  78     RuleSourceDataList* sourceData() const { return m_sourceData.get(); }
  79     void setSourceData(std::unique_ptr&lt;RuleSourceDataList&gt;);
  80     bool hasSourceData() const { return m_sourceData != nullptr; }
  81     WebCore::CSSRuleSourceData* ruleSourceDataAt(unsigned) const;
  82 
  83 private:
  84 
  85     String m_text;
  86     bool m_hasText;
  87     std::unique_ptr&lt;RuleSourceDataList&gt; m_sourceData;
  88 };
  89 
  90 ParsedStyleSheet::ParsedStyleSheet()
  91     : m_hasText(false)
  92 {
  93 }
  94 
  95 void ParsedStyleSheet::setText(const String&amp; text)
  96 {
  97     m_hasText = true;
  98     m_text = text;
  99     setSourceData(nullptr);
 100 }
 101 
 102 static void flattenSourceData(RuleSourceDataList&amp; dataList, RuleSourceDataList&amp; target)
 103 {
 104     for (auto&amp; data : dataList) {
<a name="2" id="anc2"></a><span class="line-modified"> 105         if (data-&gt;type == WebCore::StyleRuleType::Style)</span>
 106             target.append(data.copyRef());
<a name="3" id="anc3"></a><span class="line-modified"> 107         else if (data-&gt;type == WebCore::StyleRuleType::Media)</span>
 108             flattenSourceData(data-&gt;childRules, target);
<a name="4" id="anc4"></a><span class="line-modified"> 109         else if (data-&gt;type == WebCore::StyleRuleType::Supports)</span>
 110             flattenSourceData(data-&gt;childRules, target);
 111     }
 112 }
 113 
 114 void ParsedStyleSheet::setSourceData(std::unique_ptr&lt;RuleSourceDataList&gt; sourceData)
 115 {
 116     if (!sourceData) {
 117         m_sourceData.reset();
 118         return;
 119     }
 120 
 121     m_sourceData = makeUnique&lt;RuleSourceDataList&gt;();
 122 
 123     // FIXME: This is a temporary solution to retain the original flat sourceData structure
 124     // containing only style rules, even though CSSParser now provides the full rule source data tree.
 125     // Normally, we should just assign m_sourceData = sourceData;
 126     flattenSourceData(*sourceData, *m_sourceData);
 127 }
 128 
 129 WebCore::CSSRuleSourceData* ParsedStyleSheet::ruleSourceDataAt(unsigned index) const
 130 {
 131     if (!hasSourceData() || index &gt;= m_sourceData-&gt;size())
 132         return nullptr;
 133 
 134     return m_sourceData-&gt;at(index).ptr();
 135 }
 136 
 137 
 138 namespace WebCore {
 139 
 140 using namespace Inspector;
 141 
 142 static CSSParserContext parserContextForDocument(Document* document)
 143 {
 144     return document ? CSSParserContext(*document) : strictCSSParserContext();
 145 }
 146 
 147 class StyleSheetHandler : public CSSParserObserver {
 148 public:
 149     StyleSheetHandler(const String&amp; parsedText, Document* document, RuleSourceDataList* result)
 150         : m_parsedText(parsedText)
 151         , m_document(document)
 152         , m_ruleSourceDataResult(result)
 153     {
 154         ASSERT(m_ruleSourceDataResult);
 155     }
 156 
 157 private:
<a name="5" id="anc5"></a><span class="line-modified"> 158     void startRuleHeader(StyleRuleType, unsigned) override;</span>
 159     void endRuleHeader(unsigned) override;
 160     void observeSelector(unsigned startOffset, unsigned endOffset) override;
 161     void startRuleBody(unsigned) override;
 162     void endRuleBody(unsigned) override;
 163     void observeProperty(unsigned startOffset, unsigned endOffset, bool isImportant, bool isParsed) override;
 164     void observeComment(unsigned startOffset, unsigned endOffset) override;
 165 
 166     Ref&lt;CSSRuleSourceData&gt; popRuleData();
 167     template &lt;typename CharacterType&gt; inline void setRuleHeaderEnd(const CharacterType*, unsigned);
 168     void fixUnparsedPropertyRanges(CSSRuleSourceData*);
 169 
 170     const String&amp; m_parsedText;
 171     Document* m_document;
 172 
 173     RuleSourceDataList m_currentRuleDataStack;
 174     RefPtr&lt;CSSRuleSourceData&gt; m_currentRuleData;
 175     RuleSourceDataList* m_ruleSourceDataResult { nullptr };
 176 };
 177 
<a name="6" id="anc6"></a><span class="line-modified"> 178 void StyleSheetHandler::startRuleHeader(StyleRuleType type, unsigned offset)</span>
 179 {
 180     // Pop off data for a previous invalid rule.
 181     if (m_currentRuleData)
 182         m_currentRuleDataStack.removeLast();
 183 
 184     auto data = CSSRuleSourceData::create(type);
 185     data-&gt;ruleHeaderRange.start = offset;
 186     m_currentRuleData = data.copyRef();
 187     m_currentRuleDataStack.append(WTFMove(data));
 188 }
 189 
 190 template &lt;typename CharacterType&gt; inline void StyleSheetHandler::setRuleHeaderEnd(const CharacterType* dataStart, unsigned listEndOffset)
 191 {
 192     while (listEndOffset &gt; 1) {
 193         if (isHTMLSpace&lt;CharacterType&gt;(*(dataStart + listEndOffset - 1)))
 194             --listEndOffset;
 195         else
 196             break;
 197     }
 198 
 199     m_currentRuleDataStack.last()-&gt;ruleHeaderRange.end = listEndOffset;
 200     if (!m_currentRuleDataStack.last()-&gt;selectorRanges.isEmpty())
 201         m_currentRuleDataStack.last()-&gt;selectorRanges.last().end = listEndOffset;
 202 }
 203 
 204 void StyleSheetHandler::endRuleHeader(unsigned offset)
 205 {
 206     ASSERT(!m_currentRuleDataStack.isEmpty());
 207 
 208     if (m_parsedText.is8Bit())
 209         setRuleHeaderEnd&lt;LChar&gt;(m_parsedText.characters8(), offset);
 210     else
 211         setRuleHeaderEnd&lt;UChar&gt;(m_parsedText.characters16(), offset);
 212 }
 213 
 214 void StyleSheetHandler::observeSelector(unsigned startOffset, unsigned endOffset)
 215 {
 216     ASSERT(m_currentRuleDataStack.size());
 217     m_currentRuleDataStack.last()-&gt;selectorRanges.append(SourceRange(startOffset, endOffset));
 218 }
 219 
 220 void StyleSheetHandler::startRuleBody(unsigned offset)
 221 {
 222     m_currentRuleData = nullptr;
 223     ASSERT(!m_currentRuleDataStack.isEmpty());
 224 
 225     // Skip the rule body opening brace.
 226     if (m_parsedText[offset] == &#39;{&#39;)
 227         ++offset;
 228 
 229     m_currentRuleDataStack.last()-&gt;ruleBodyRange.start = offset;
 230 }
 231 
 232 void StyleSheetHandler::endRuleBody(unsigned offset)
 233 {
 234     ASSERT(!m_currentRuleDataStack.isEmpty());
 235     m_currentRuleDataStack.last()-&gt;ruleBodyRange.end = offset;
 236     auto rule = popRuleData();
 237     fixUnparsedPropertyRanges(rule.ptr());
 238     if (m_currentRuleDataStack.isEmpty())
 239         m_ruleSourceDataResult-&gt;append(WTFMove(rule));
 240     else
 241         m_currentRuleDataStack.last()-&gt;childRules.append(WTFMove(rule));
 242 }
 243 
 244 Ref&lt;CSSRuleSourceData&gt; StyleSheetHandler::popRuleData()
 245 {
 246     ASSERT(!m_currentRuleDataStack.isEmpty());
 247     m_currentRuleData = nullptr;
 248     auto data = WTFMove(m_currentRuleDataStack.last());
 249     m_currentRuleDataStack.removeLast();
 250     return data;
 251 }
 252 
 253 template &lt;typename CharacterType&gt;
 254 static inline void fixUnparsedProperties(const CharacterType* characters, CSSRuleSourceData* ruleData)
 255 {
 256     Vector&lt;CSSPropertySourceData&gt;&amp; propertyData = ruleData-&gt;styleSourceData-&gt;propertyData;
 257     unsigned size = propertyData.size();
 258     if (!size)
 259         return;
 260 
 261     unsigned styleStart = ruleData-&gt;ruleBodyRange.start;
 262 
 263     CSSPropertySourceData* nextData = &amp;(propertyData.at(0));
 264     for (unsigned i = 0; i &lt; size; ++i) {
 265         CSSPropertySourceData* currentData = nextData;
 266         nextData = i &lt; size - 1 ? &amp;(propertyData.at(i + 1)) : nullptr;
 267 
 268         if (currentData-&gt;parsedOk)
 269             continue;
 270         if (currentData-&gt;range.end &gt; 0 &amp;&amp; characters[styleStart + currentData-&gt;range.end - 1] == &#39;;&#39;)
 271             continue;
 272 
 273         unsigned propertyEnd;
 274         if (!nextData)
 275             propertyEnd = ruleData-&gt;ruleBodyRange.end - 1;
 276         else
 277             propertyEnd = styleStart + nextData-&gt;range.start - 1;
 278 
 279         while (isHTMLSpace&lt;CharacterType&gt;(characters[propertyEnd]))
 280             --propertyEnd;
 281 
 282         // propertyEnd points at the last property text character.
 283         unsigned newRangeEnd = (propertyEnd - styleStart) + 1;
 284         if (currentData-&gt;range.end != newRangeEnd) {
 285             currentData-&gt;range.end = newRangeEnd;
 286             unsigned valueStart = styleStart + currentData-&gt;range.start + currentData-&gt;name.length();
 287             while (valueStart &lt; propertyEnd &amp;&amp; characters[valueStart] != &#39;:&#39;)
 288                 ++valueStart;
 289 
 290             // Shift past the &#39;:&#39;.
 291             if (valueStart &lt; propertyEnd)
 292                 ++valueStart;
 293 
 294             while (valueStart &lt; propertyEnd &amp;&amp; isHTMLSpace&lt;CharacterType&gt;(characters[valueStart]))
 295                 ++valueStart;
 296 
 297             // Need to exclude the trailing &#39;;&#39; from the property value.
 298             currentData-&gt;value = String(characters + valueStart, propertyEnd - valueStart + (characters[propertyEnd] == &#39;;&#39; ? 0 : 1));
 299         }
 300     }
 301 }
 302 
 303 void StyleSheetHandler::fixUnparsedPropertyRanges(CSSRuleSourceData* ruleData)
 304 {
 305     if (!ruleData-&gt;styleSourceData)
 306         return;
 307 
 308     if (m_parsedText.is8Bit()) {
 309         fixUnparsedProperties&lt;LChar&gt;(m_parsedText.characters8(), ruleData);
 310         return;
 311     }
 312 
 313     fixUnparsedProperties&lt;UChar&gt;(m_parsedText.characters16(), ruleData);
 314 }
 315 
 316 void StyleSheetHandler::observeProperty(unsigned startOffset, unsigned endOffset, bool isImportant, bool isParsed)
 317 {
 318     if (m_currentRuleDataStack.isEmpty() || !m_currentRuleDataStack.last()-&gt;styleSourceData)
 319         return;
 320 
 321     ASSERT(endOffset &lt;= m_parsedText.length());
 322 
 323     // Include semicolon in the property text.
 324     if (endOffset &lt; m_parsedText.length() &amp;&amp; m_parsedText[endOffset] == &#39;;&#39;)
 325         ++endOffset;
 326 
 327     ASSERT(startOffset &lt; endOffset);
 328     String propertyString = m_parsedText.substring(startOffset, endOffset - startOffset).stripWhiteSpace();
 329     if (propertyString.endsWith(&#39;;&#39;))
 330         propertyString = propertyString.left(propertyString.length() - 1);
 331     size_t colonIndex = propertyString.find(&#39;:&#39;);
 332     ASSERT(colonIndex != notFound);
 333 
 334     String name = propertyString.left(colonIndex).stripWhiteSpace();
 335     String value = propertyString.substring(colonIndex + 1, propertyString.length()).stripWhiteSpace();
 336 
 337     // FIXME-NEWPARSER: The property range is relative to the declaration start offset, but no
 338     // good reason for it, and it complicates fixUnparsedProperties.
 339     SourceRange&amp; topRuleBodyRange = m_currentRuleDataStack.last()-&gt;ruleBodyRange;
 340     m_currentRuleDataStack.last()-&gt;styleSourceData-&gt;propertyData.append(CSSPropertySourceData(name, value, isImportant, false, isParsed, SourceRange(startOffset - topRuleBodyRange.start, endOffset - topRuleBodyRange.start)));
 341 }
 342 
 343 void StyleSheetHandler::observeComment(unsigned startOffset, unsigned endOffset)
 344 {
 345     ASSERT(endOffset &lt;= m_parsedText.length());
 346 
 347     if (m_currentRuleDataStack.isEmpty() || !m_currentRuleDataStack.last()-&gt;ruleHeaderRange.end || !m_currentRuleDataStack.last()-&gt;styleSourceData)
 348         return;
 349 
 350     // The lexer is not inside a property AND it is scanning a declaration-aware
 351     // rule body.
 352     String commentText = m_parsedText.substring(startOffset, endOffset - startOffset);
 353 
 354     ASSERT(commentText.startsWith(&quot;/*&quot;));
 355     commentText = commentText.substring(2);
 356 
 357     // Require well-formed comments.
 358     if (!commentText.endsWith(&quot;*/&quot;))
 359         return;
 360     commentText = commentText.substring(0, commentText.length() - 2).stripWhiteSpace();
 361     if (commentText.isEmpty())
 362         return;
 363 
 364     // FIXME: Use the actual rule type rather than STYLE_RULE?
 365     RuleSourceDataList sourceData;
 366 
 367     StyleSheetHandler handler(commentText, m_document, &amp;sourceData);
 368     CSSParser::parseDeclarationForInspector(parserContextForDocument(m_document), commentText, handler);
 369     Vector&lt;CSSPropertySourceData&gt;&amp; commentPropertyData = sourceData.first()-&gt;styleSourceData-&gt;propertyData;
 370     if (commentPropertyData.size() != 1)
 371         return;
 372     CSSPropertySourceData&amp; propertyData = commentPropertyData.at(0);
 373     bool parsedOk = propertyData.parsedOk || propertyData.name.startsWith(&quot;-moz-&quot;) || propertyData.name.startsWith(&quot;-o-&quot;) || propertyData.name.startsWith(&quot;-webkit-&quot;) || propertyData.name.startsWith(&quot;-ms-&quot;);
 374     if (!parsedOk || propertyData.range.length() != commentText.length())
 375         return;
 376 
 377     // FIXME-NEWPARSER: The property range is relative to the declaration start offset, but no
 378     // good reason for it, and it complicates fixUnparsedProperties.
 379     SourceRange&amp; topRuleBodyRange = m_currentRuleDataStack.last()-&gt;ruleBodyRange;
 380     m_currentRuleDataStack.last()-&gt;styleSourceData-&gt;propertyData.append(CSSPropertySourceData(propertyData.name, propertyData.value, false, true, true, SourceRange(startOffset - topRuleBodyRange.start, endOffset - topRuleBodyRange.start)));
 381 }
 382 
 383 static RefPtr&lt;Inspector::Protocol::CSS::SourceRange&gt; buildSourceRangeObject(const SourceRange&amp; range, const Vector&lt;size_t&gt;&amp; lineEndings, int* endingLine = nullptr)
 384 {
 385     if (lineEndings.isEmpty())
 386         return nullptr;
 387 
 388     TextPosition start = ContentSearchUtilities::textPositionFromOffset(range.start, lineEndings);
 389     TextPosition end = ContentSearchUtilities::textPositionFromOffset(range.end, lineEndings);
 390 
 391     if (endingLine)
 392         *endingLine = end.m_line.zeroBasedInt();
 393 
 394     return Inspector::Protocol::CSS::SourceRange::create()
 395         .setStartLine(start.m_line.zeroBasedInt())
 396         .setStartColumn(start.m_column.zeroBasedInt())
 397         .setEndLine(end.m_line.zeroBasedInt())
 398         .setEndColumn(end.m_column.zeroBasedInt())
 399         .release();
 400 }
 401 
 402 static RefPtr&lt;CSSRuleList&gt; asCSSRuleList(CSSStyleSheet* styleSheet)
 403 {
 404     if (!styleSheet)
 405         return nullptr;
 406 
 407     auto list = StaticCSSRuleList::create();
 408     Vector&lt;RefPtr&lt;CSSRule&gt;&gt;&amp; listRules = list-&gt;rules();
 409     for (unsigned i = 0, size = styleSheet-&gt;length(); i &lt; size; ++i)
 410         listRules.append(styleSheet-&gt;item(i));
 411     return list;
 412 }
 413 
 414 static RefPtr&lt;CSSRuleList&gt; asCSSRuleList(CSSRule* rule)
 415 {
 416     if (!rule)
 417         return nullptr;
 418 
 419     if (is&lt;CSSMediaRule&gt;(*rule))
 420         return &amp;downcast&lt;CSSMediaRule&gt;(*rule).cssRules();
 421 
 422     if (is&lt;CSSKeyframesRule&gt;(*rule))
 423         return &amp;downcast&lt;CSSKeyframesRule&gt;(*rule).cssRules();
 424 
 425     if (is&lt;CSSSupportsRule&gt;(*rule))
 426         return &amp;downcast&lt;CSSSupportsRule&gt;(*rule).cssRules();
 427 
 428     return nullptr;
 429 }
 430 
 431 static Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::CSS::Grouping&gt;&gt; buildArrayForGroupings(CSSRule&amp; rule)
 432 {
 433     auto groupingsPayload = JSON::ArrayOf&lt;Inspector::Protocol::CSS::Grouping&gt;::create();
 434 
 435     auto* parentRule = &amp;rule;
 436     while (parentRule) {
 437         RefPtr&lt;Inspector::Protocol::CSS::Grouping&gt; ruleGroupingPayload;
 438 
 439         if (is&lt;CSSMediaRule&gt;(parentRule)) {
 440             auto* media = downcast&lt;CSSMediaRule&gt;(parentRule)-&gt;media();
 441             if (media &amp;&amp; media-&gt;length() &amp;&amp; media-&gt;mediaText() != &quot;all&quot;) {
 442                 ruleGroupingPayload = Inspector::Protocol::CSS::Grouping::create()
 443                     .setText(media-&gt;mediaText())
 444                     .setType(Inspector::Protocol::CSS::Grouping::Type::MediaRule)
 445                     .release();
 446             }
 447         } else if (is&lt;CSSImportRule&gt;(parentRule)) {
 448             auto&amp; media = downcast&lt;CSSImportRule&gt;(parentRule)-&gt;media();
 449             if (media.length() &amp;&amp; media.mediaText() != &quot;all&quot;) {
 450                 ruleGroupingPayload = Inspector::Protocol::CSS::Grouping::create()
 451                     .setText(media.mediaText())
 452                     .setType(Inspector::Protocol::CSS::Grouping::Type::MediaImportRule)
 453                     .release();
 454             }
 455         } else if (is&lt;CSSSupportsRule&gt;(parentRule)) {
 456             ruleGroupingPayload = Inspector::Protocol::CSS::Grouping::create()
 457                 .setText(downcast&lt;CSSSupportsRule&gt;(parentRule)-&gt;conditionText())
 458                 .setType(Inspector::Protocol::CSS::Grouping::Type::SupportsRule)
 459                 .release();
 460         }
 461 
 462         if (ruleGroupingPayload) {
 463             if (auto* parentStyleSheet = parentRule-&gt;parentStyleSheet()) {
 464                 String sourceURL = parentStyleSheet-&gt;contents().baseURL();
 465                 if (sourceURL.isEmpty()) {
 466                     if (auto* ownerDocument = parentStyleSheet-&gt;ownerDocument())
 467                         sourceURL = InspectorDOMAgent::documentURLString(ownerDocument);
 468                 }
 469                 if (!sourceURL.isEmpty())
 470                     ruleGroupingPayload-&gt;setSourceURL(sourceURL);
 471             }
 472 
 473             groupingsPayload-&gt;addItem(WTFMove(ruleGroupingPayload));
 474         }
 475 
 476         if (parentRule-&gt;parentRule()) {
 477             parentRule = parentRule-&gt;parentRule();
 478             continue;
 479         }
 480 
 481         auto* styleSheet = parentRule-&gt;parentStyleSheet();
 482         while (styleSheet) {
 483             auto* media = styleSheet-&gt;media();
 484             if (media &amp;&amp; media-&gt;length() &amp;&amp; media-&gt;mediaText() != &quot;all&quot;) {
 485                 auto sheetGroupingPayload = Inspector::Protocol::CSS::Grouping::create()
 486                     .setText(media-&gt;mediaText())
 487                     .setType(is&lt;HTMLStyleElement&gt;(styleSheet-&gt;ownerNode()) ? Inspector::Protocol::CSS::Grouping::Type::MediaStyleNode: Inspector::Protocol::CSS::Grouping::Type::MediaLinkNode)
 488                     .release();
 489 
 490                 String sourceURL;
 491                 if (auto* ownerDocument = styleSheet-&gt;ownerDocument())
 492                     sourceURL = ownerDocument-&gt;url();
 493                 else if (!styleSheet-&gt;contents().baseURL().isEmpty())
 494                     sourceURL = styleSheet-&gt;contents().baseURL();
 495                 if (!sourceURL.isEmpty())
 496                     sheetGroupingPayload-&gt;setSourceURL(sourceURL);
 497 
 498                 groupingsPayload-&gt;addItem(WTFMove(sheetGroupingPayload));
 499             }
 500 
 501             parentRule = styleSheet-&gt;ownerRule();
 502             if (parentRule)
 503                 break;
 504 
 505             styleSheet = styleSheet-&gt;parentStyleSheet();
 506         }
 507     }
 508 
 509     return groupingsPayload;
 510 }
 511 
 512 Ref&lt;InspectorStyle&gt; InspectorStyle::create(const InspectorCSSId&amp; styleId, Ref&lt;CSSStyleDeclaration&gt;&amp;&amp; style, InspectorStyleSheet* parentStyleSheet)
 513 {
 514     return adoptRef(*new InspectorStyle(styleId, WTFMove(style), parentStyleSheet));
 515 }
 516 
 517 InspectorStyle::InspectorStyle(const InspectorCSSId&amp; styleId, Ref&lt;CSSStyleDeclaration&gt;&amp;&amp; style, InspectorStyleSheet* parentStyleSheet)
 518     : m_styleId(styleId)
 519     , m_style(WTFMove(style))
 520     , m_parentStyleSheet(parentStyleSheet)
 521 {
 522 }
 523 
 524 InspectorStyle::~InspectorStyle() = default;
 525 
 526 RefPtr&lt;Inspector::Protocol::CSS::CSSStyle&gt; InspectorStyle::buildObjectForStyle() const
 527 {
 528     Ref&lt;Inspector::Protocol::CSS::CSSStyle&gt; result = styleWithProperties();
 529     if (!m_styleId.isEmpty())
 530         result-&gt;setStyleId(m_styleId.asProtocolValue&lt;Inspector::Protocol::CSS::CSSStyleId&gt;());
 531 
 532     result-&gt;setWidth(m_style-&gt;getPropertyValue(&quot;width&quot;));
 533     result-&gt;setHeight(m_style-&gt;getPropertyValue(&quot;height&quot;));
 534 
 535     RefPtr&lt;CSSRuleSourceData&gt; sourceData = extractSourceData();
 536     if (sourceData)
 537         result-&gt;setRange(buildSourceRangeObject(sourceData-&gt;ruleBodyRange, m_parentStyleSheet-&gt;lineEndings()));
 538 
 539     return result;
 540 }
 541 
 542 Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSComputedStyleProperty&gt;&gt; InspectorStyle::buildArrayForComputedStyle() const
 543 {
 544     auto result = JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSComputedStyleProperty&gt;::create();
<a name="7" id="anc7"></a><span class="line-modified"> 545     for (auto&amp; property : collectProperties(true)) {</span>



 546         const CSSPropertySourceData&amp; propertyEntry = property.sourceData;
 547         auto entry = Inspector::Protocol::CSS::CSSComputedStyleProperty::create()
 548             .setName(propertyEntry.name)
 549             .setValue(propertyEntry.value)
 550             .release();
 551         result-&gt;addItem(WTFMove(entry));
 552     }
<a name="8" id="anc8"></a>
 553     return result;
 554 }
 555 
 556 ExceptionOr&lt;String&gt; InspectorStyle::text() const
 557 {
 558     // Precondition: m_parentStyleSheet-&gt;ensureParsedDataReady() has been called successfully.
 559     auto sourceData = extractSourceData();
 560     if (!sourceData)
 561         return Exception { NotFoundError };
 562 
 563     auto result = m_parentStyleSheet-&gt;text();
 564     if (result.hasException())
 565         return result.releaseException();
 566 
 567     auto&amp; bodyRange = sourceData-&gt;ruleBodyRange;
 568     return result.releaseReturnValue().substring(bodyRange.start, bodyRange.end - bodyRange.start);
 569 }
 570 
 571 static String lowercasePropertyName(const String&amp; name)
 572 {
 573     // Custom properties are case-sensitive.
 574     if (name.startsWith(&quot;--&quot;))
 575         return name;
 576     return name.convertToASCIILowercase();
 577 }
 578 
<a name="9" id="anc9"></a><span class="line-modified"> 579 Vector&lt;InspectorStyleProperty&gt; InspectorStyle::collectProperties(bool includeAll) const</span>
 580 {
<a name="10" id="anc10"></a><span class="line-added"> 581     Vector&lt;InspectorStyleProperty&gt; result;</span>
 582     HashSet&lt;String&gt; sourcePropertyNames;
 583 
 584     auto sourceData = extractSourceData();
 585     auto* sourcePropertyData = sourceData ? &amp;sourceData-&gt;styleSourceData-&gt;propertyData : nullptr;
 586     if (sourcePropertyData) {
 587         auto styleDeclarationOrException = text();
 588         ASSERT(!styleDeclarationOrException.hasException());
 589         String styleDeclaration = styleDeclarationOrException.hasException() ? emptyString() : styleDeclarationOrException.releaseReturnValue();
 590         for (auto&amp; sourceData : *sourcePropertyData) {
 591             InspectorStyleProperty p(sourceData, true, sourceData.disabled);
 592             p.setRawTextFromStyleDeclaration(styleDeclaration);
<a name="11" id="anc11"></a><span class="line-modified"> 593             result.append(p);</span>
 594             sourcePropertyNames.add(lowercasePropertyName(sourceData.name));
 595         }
 596     }
 597 
 598     for (int i = 0, size = m_style-&gt;length(); i &lt; size; ++i) {
 599         String name = m_style-&gt;item(i);
 600         if (sourcePropertyNames.add(lowercasePropertyName(name)))
<a name="12" id="anc12"></a><span class="line-modified"> 601             result.append(InspectorStyleProperty(CSSPropertySourceData(name, m_style-&gt;getPropertyValue(name), !m_style-&gt;getPropertyPriority(name).isEmpty(), false, true, SourceRange()), false, false));</span>
 602     }
<a name="13" id="anc13"></a><span class="line-added"> 603 </span>
<span class="line-added"> 604     if (includeAll) {</span>
<span class="line-added"> 605         for (auto i = firstCSSProperty; i &lt; lastCSSProperty; ++i) {</span>
<span class="line-added"> 606             auto id = convertToCSSPropertyID(i);</span>
<span class="line-added"> 607             if (isInternalCSSProperty(id) || !isEnabledCSSProperty(id))</span>
<span class="line-added"> 608                 continue;</span>
<span class="line-added"> 609 </span>
<span class="line-added"> 610             auto name = getPropertyNameString(id);</span>
<span class="line-added"> 611             if (!sourcePropertyNames.add(lowercasePropertyName(name)))</span>
<span class="line-added"> 612                 continue;</span>
<span class="line-added"> 613 </span>
<span class="line-added"> 614             auto value = m_style-&gt;getPropertyValue(name);</span>
<span class="line-added"> 615             if (value.isEmpty())</span>
<span class="line-added"> 616                 continue;</span>
<span class="line-added"> 617 </span>
<span class="line-added"> 618             result.append(InspectorStyleProperty(CSSPropertySourceData(name, value, !m_style-&gt;getPropertyPriority(name).isEmpty(), false, true, SourceRange()), false, false));</span>
<span class="line-added"> 619         }</span>
<span class="line-added"> 620     }</span>
<span class="line-added"> 621 </span>
<span class="line-added"> 622     return result;</span>
 623 }
 624 
 625 Ref&lt;Inspector::Protocol::CSS::CSSStyle&gt; InspectorStyle::styleWithProperties() const
 626 {
<a name="14" id="anc14"></a><span class="line-modified"> 627     auto properties = collectProperties(false);</span>

 628 
 629     auto propertiesObject = JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSProperty&gt;::create();
 630     auto shorthandEntries = ArrayOf&lt;Inspector::Protocol::CSS::ShorthandEntry&gt;::create();
 631     HashMap&lt;String, RefPtr&lt;Inspector::Protocol::CSS::CSSProperty&gt;&gt; propertyNameToPreviousActiveProperty;
 632     HashSet&lt;String&gt; foundShorthands;
 633     String previousPriority;
 634     String previousStatus;
 635     Vector&lt;size_t&gt; lineEndings = m_parentStyleSheet ? m_parentStyleSheet-&gt;lineEndings() : Vector&lt;size_t&gt; { };
 636     auto sourceData = extractSourceData();
 637     unsigned ruleBodyRangeStart = sourceData ? sourceData-&gt;ruleBodyRange.start : 0;
 638 
 639     for (Vector&lt;InspectorStyleProperty&gt;::iterator it = properties.begin(), itEnd = properties.end(); it != itEnd; ++it) {
 640         const CSSPropertySourceData&amp; propertyEntry = it-&gt;sourceData;
 641         const String&amp; name = propertyEntry.name;
 642 
 643         auto status = it-&gt;disabled ? Inspector::Protocol::CSS::CSSPropertyStatus::Disabled : Inspector::Protocol::CSS::CSSPropertyStatus::Active;
 644 
 645         auto property = Inspector::Protocol::CSS::CSSProperty::create()
 646             .setName(name.convertToASCIILowercase())
 647             .setValue(propertyEntry.value)
 648             .release();
 649 
 650         propertiesObject-&gt;addItem(property.copyRef());
 651 
 652         CSSPropertyID propertyId = cssPropertyID(name);
 653 
 654         // Default &quot;parsedOk&quot; == true.
 655         if (!propertyEntry.parsedOk || isInternalCSSProperty(propertyId))
 656             property-&gt;setParsedOk(false);
 657         if (it-&gt;hasRawText())
 658             property-&gt;setText(it-&gt;rawText);
 659 
 660         // Default &quot;priority&quot; == &quot;&quot;.
 661         if (propertyEntry.important)
 662             property-&gt;setPriority(&quot;important&quot;);
 663 
 664         if (it-&gt;hasSource) {
 665             // The property range is relative to the style body start.
 666             // Should be converted into an absolute range (relative to the stylesheet start)
 667             // for the proper conversion into line:column.
 668             SourceRange absolutePropertyRange = propertyEntry.range;
 669             absolutePropertyRange.start += ruleBodyRangeStart;
 670             absolutePropertyRange.end += ruleBodyRangeStart;
 671             property-&gt;setRange(buildSourceRangeObject(absolutePropertyRange, lineEndings));
 672         }
 673 
 674         if (!it-&gt;disabled) {
 675             if (it-&gt;hasSource) {
 676                 ASSERT(sourceData);
 677                 property-&gt;setImplicit(false);
 678 
 679                 // Parsed property overrides any property with the same name. Non-parsed property overrides
 680                 // previous non-parsed property with the same name (if any).
 681                 bool shouldInactivate = false;
 682 
 683                 // Canonicalize property names to treat non-prefixed and vendor-prefixed property names the same (opacity vs. -webkit-opacity).
 684                 String canonicalPropertyName = propertyId ? getPropertyNameString(propertyId) : name;
 685                 HashMap&lt;String, RefPtr&lt;Inspector::Protocol::CSS::CSSProperty&gt;&gt;::iterator activeIt = propertyNameToPreviousActiveProperty.find(canonicalPropertyName);
 686                 if (activeIt != propertyNameToPreviousActiveProperty.end()) {
 687                     if (propertyEntry.parsedOk) {
 688                         bool successPriority = activeIt-&gt;value-&gt;getString(Inspector::Protocol::CSS::CSSProperty::Priority, previousPriority);
 689                         bool successStatus = activeIt-&gt;value-&gt;getString(Inspector::Protocol::CSS::CSSProperty::Status, previousStatus);
 690                         if (successStatus &amp;&amp; previousStatus != &quot;inactive&quot;) {
 691                             if (propertyEntry.important || !successPriority) // Priority not set == &quot;not important&quot;.
 692                                 shouldInactivate = true;
 693                             else if (status == Inspector::Protocol::CSS::CSSPropertyStatus::Active) {
 694                                 // Inactivate a non-important property following the same-named important property.
 695                                 status = Inspector::Protocol::CSS::CSSPropertyStatus::Inactive;
 696                             }
 697                         }
 698                     } else {
 699                         bool previousParsedOk;
 700                         bool success = activeIt-&gt;value-&gt;getBoolean(Inspector::Protocol::CSS::CSSProperty::ParsedOk, previousParsedOk);
 701                         if (success &amp;&amp; !previousParsedOk)
 702                             shouldInactivate = true;
 703                     }
 704                 } else
 705                     propertyNameToPreviousActiveProperty.set(canonicalPropertyName, property.copyRef());
 706 
 707                 if (shouldInactivate) {
 708                     activeIt-&gt;value-&gt;setStatus(Inspector::Protocol::CSS::CSSPropertyStatus::Inactive);
 709                     propertyNameToPreviousActiveProperty.set(canonicalPropertyName, property.copyRef());
 710                 }
 711             } else {
 712                 bool implicit = m_style-&gt;isPropertyImplicit(name);
 713                 // Default &quot;implicit&quot; == false.
 714                 if (implicit)
 715                     property-&gt;setImplicit(true);
 716                 status = Inspector::Protocol::CSS::CSSPropertyStatus::Style;
 717 
 718                 String shorthand = m_style-&gt;getPropertyShorthand(name);
 719                 if (!shorthand.isEmpty()) {
 720                     if (!foundShorthands.contains(shorthand)) {
 721                         foundShorthands.add(shorthand);
 722                         auto entry = Inspector::Protocol::CSS::ShorthandEntry::create()
 723                             .setName(shorthand)
 724                             .setValue(shorthandValue(shorthand))
 725                             .release();
 726                         shorthandEntries-&gt;addItem(WTFMove(entry));
 727                     }
 728                 }
 729             }
 730         }
 731 
 732         // Default &quot;status&quot; == &quot;style&quot;.
 733         if (status != Inspector::Protocol::CSS::CSSPropertyStatus::Style)
 734             property-&gt;setStatus(status);
 735     }
 736 
 737     return Inspector::Protocol::CSS::CSSStyle::create()
 738         .setCssProperties(WTFMove(propertiesObject))
 739         .setShorthandEntries(WTFMove(shorthandEntries))
 740         .release();
 741 }
 742 
 743 RefPtr&lt;CSSRuleSourceData&gt; InspectorStyle::extractSourceData() const
 744 {
 745     if (!m_parentStyleSheet || !m_parentStyleSheet-&gt;ensureParsedDataReady())
 746         return nullptr;
 747     return m_parentStyleSheet-&gt;ruleSourceDataFor(m_style.ptr());
 748 }
 749 
 750 ExceptionOr&lt;void&gt; InspectorStyle::setText(const String&amp; text)
 751 {
 752     return m_parentStyleSheet-&gt;setStyleText(m_style.ptr(), text);
 753 }
 754 
 755 String InspectorStyle::shorthandValue(const String&amp; shorthandProperty) const
 756 {
 757     String value = m_style-&gt;getPropertyValue(shorthandProperty);
 758     if (!value.isEmpty())
 759         return value;
 760     StringBuilder builder;
 761     for (unsigned i = 0; i &lt; m_style-&gt;length(); ++i) {
 762         String individualProperty = m_style-&gt;item(i);
 763         if (m_style-&gt;getPropertyShorthand(individualProperty) != shorthandProperty)
 764             continue;
 765         if (m_style-&gt;isPropertyImplicit(individualProperty))
 766             continue;
 767         String individualValue = m_style-&gt;getPropertyValue(individualProperty);
 768         if (individualValue == &quot;initial&quot;)
 769             continue;
 770         if (!builder.isEmpty())
 771             builder.append(&#39; &#39;);
 772         builder.append(individualValue);
 773     }
 774     return builder.toString();
 775 }
 776 
 777 String InspectorStyle::shorthandPriority(const String&amp; shorthandProperty) const
 778 {
 779     String priority = m_style-&gt;getPropertyPriority(shorthandProperty);
 780     if (priority.isEmpty()) {
 781         for (unsigned i = 0; i &lt; m_style-&gt;length(); ++i) {
 782             String individualProperty = m_style-&gt;item(i);
 783             if (m_style-&gt;getPropertyShorthand(individualProperty) != shorthandProperty)
 784                 continue;
 785             priority = m_style-&gt;getPropertyPriority(individualProperty);
 786             break;
 787         }
 788     }
 789     return priority;
 790 }
 791 
 792 Vector&lt;String&gt; InspectorStyle::longhandProperties(const String&amp; shorthandProperty) const
 793 {
 794     Vector&lt;String&gt; properties;
 795     HashSet&lt;String&gt; foundProperties;
 796     for (unsigned i = 0; i &lt; m_style-&gt;length(); ++i) {
 797         String individualProperty = m_style-&gt;item(i);
 798         if (foundProperties.contains(individualProperty) || m_style-&gt;getPropertyShorthand(individualProperty) != shorthandProperty)
 799             continue;
 800 
 801         foundProperties.add(individualProperty);
 802         properties.append(individualProperty);
 803     }
 804     return properties;
 805 }
 806 
 807 Ref&lt;InspectorStyleSheet&gt; InspectorStyleSheet::create(InspectorPageAgent* pageAgent, const String&amp; id, RefPtr&lt;CSSStyleSheet&gt;&amp;&amp; pageStyleSheet, Inspector::Protocol::CSS::StyleSheetOrigin origin, const String&amp; documentURL, Listener* listener)
 808 {
 809     return adoptRef(*new InspectorStyleSheet(pageAgent, id, WTFMove(pageStyleSheet), origin, documentURL, listener));
 810 }
 811 
 812 String InspectorStyleSheet::styleSheetURL(CSSStyleSheet* pageStyleSheet)
 813 {
 814     if (pageStyleSheet &amp;&amp; !pageStyleSheet-&gt;contents().baseURL().isEmpty())
 815         return pageStyleSheet-&gt;contents().baseURL().string();
 816     return emptyString();
 817 }
 818 
 819 InspectorStyleSheet::InspectorStyleSheet(InspectorPageAgent* pageAgent, const String&amp; id, RefPtr&lt;CSSStyleSheet&gt;&amp;&amp; pageStyleSheet, Inspector::Protocol::CSS::StyleSheetOrigin origin, const String&amp; documentURL, Listener* listener)
 820     : m_pageAgent(pageAgent)
 821     , m_id(id)
 822     , m_pageStyleSheet(WTFMove(pageStyleSheet))
 823     , m_origin(origin)
 824     , m_documentURL(documentURL)
 825     , m_listener(listener)
 826 {
 827     m_parsedStyleSheet = new ParsedStyleSheet();
 828 }
 829 
 830 InspectorStyleSheet::~InspectorStyleSheet()
 831 {
 832     delete m_parsedStyleSheet;
 833 }
 834 
 835 String InspectorStyleSheet::finalURL() const
 836 {
 837     String url = styleSheetURL(m_pageStyleSheet.get());
 838     return url.isEmpty() ? m_documentURL : url;
 839 }
 840 
 841 void InspectorStyleSheet::reparseStyleSheet(const String&amp; text)
 842 {
 843     {
 844         // Have a separate scope for clearRules() (bug 95324).
 845         CSSStyleSheet::RuleMutationScope mutationScope(m_pageStyleSheet.get());
 846         m_pageStyleSheet-&gt;contents().clearRules();
 847     }
 848     {
 849         CSSStyleSheet::RuleMutationScope mutationScope(m_pageStyleSheet.get());
 850         m_pageStyleSheet-&gt;contents().parseString(text);
 851         m_pageStyleSheet-&gt;clearChildRuleCSSOMWrappers();
 852         fireStyleSheetChanged();
 853     }
 854 
 855     // We just wiped the entire contents of the stylesheet. Clear the mutation flag.
 856     m_pageStyleSheet-&gt;clearHadRulesMutation();
 857 }
 858 
 859 ExceptionOr&lt;void&gt; InspectorStyleSheet::setText(const String&amp; text)
 860 {
 861     if (!m_pageStyleSheet)
 862         return Exception { NotSupportedError };
 863 
 864     m_parsedStyleSheet-&gt;setText(text);
 865     m_flatRules.clear();
 866 
 867     return { };
 868 }
 869 
 870 ExceptionOr&lt;String&gt; InspectorStyleSheet::ruleSelector(const InspectorCSSId&amp; id)
 871 {
 872     CSSStyleRule* rule = ruleForId(id);
 873     if (!rule)
 874         return Exception { NotFoundError };
 875     return rule-&gt;selectorText();
 876 }
 877 
 878 static bool isValidSelectorListString(const String&amp; selector, Document* document)
 879 {
 880     CSSSelectorList selectorList;
 881     CSSParser parser(parserContextForDocument(document));
 882     parser.parseSelector(selector, selectorList);
 883     return selectorList.isValid();
 884 }
 885 
 886 ExceptionOr&lt;void&gt; InspectorStyleSheet::setRuleSelector(const InspectorCSSId&amp; id, const String&amp; selector)
 887 {
 888     if (!m_pageStyleSheet)
 889         return Exception { NotSupportedError };
 890 
 891     // If the selector is invalid, do not proceed any further.
 892     if (!isValidSelectorListString(selector, m_pageStyleSheet-&gt;ownerDocument()))
 893         return Exception { SyntaxError };
 894 
 895     CSSStyleRule* rule = ruleForId(id);
 896     if (!rule)
 897         return Exception { NotFoundError };
 898 
 899     CSSStyleSheet* styleSheet = rule-&gt;parentStyleSheet();
 900     if (!styleSheet || !ensureParsedDataReady())
 901         return Exception { NotFoundError };
 902 
 903     // If the stylesheet is already mutated at this point, that must mean that our data has been modified
 904     // elsewhere. This should never happen as ensureParsedDataReady would return false in that case.
 905     ASSERT(!styleSheetMutated());
 906 
 907     rule-&gt;setSelectorText(selector);
 908     auto sourceData = ruleSourceDataFor(&amp;rule-&gt;style());
 909     if (!sourceData)
 910         return Exception { NotFoundError };
 911 
 912     String sheetText = m_parsedStyleSheet-&gt;text();
 913     sheetText.replace(sourceData-&gt;ruleHeaderRange.start, sourceData-&gt;ruleHeaderRange.length(), selector);
 914     m_parsedStyleSheet-&gt;setText(sheetText);
 915     m_pageStyleSheet-&gt;clearHadRulesMutation();
 916     fireStyleSheetChanged();
 917     return { };
 918 }
 919 
 920 ExceptionOr&lt;CSSStyleRule*&gt; InspectorStyleSheet::addRule(const String&amp; selector)
 921 {
 922     if (!m_pageStyleSheet)
 923         return Exception { NotSupportedError };
 924 
 925     if (!isValidSelectorListString(selector, m_pageStyleSheet-&gt;ownerDocument()))
 926         return Exception { SyntaxError };
 927 
 928     auto text = this-&gt;text();
 929     if (text.hasException())
 930         return text.releaseException();
 931 
 932     auto addRuleResult = m_pageStyleSheet-&gt;addRule(selector, emptyString(), WTF::nullopt);
 933     if (addRuleResult.hasException())
 934         return addRuleResult.releaseException();
 935 
 936     StringBuilder styleSheetText;
 937     styleSheetText.append(text.releaseReturnValue());
 938 
 939     if (!styleSheetText.isEmpty())
 940         styleSheetText.append(&#39;\n&#39;);
 941 
 942     styleSheetText.append(selector);
 943     styleSheetText.appendLiteral(&quot; {}&quot;);
 944 
 945     // Using setText() as this operation changes the stylesheet rule set.
 946     setText(styleSheetText.toString());
 947 
 948     // Inspector Style Sheets are always treated as though their parsed data is ready.
 949     if (m_origin == Inspector::Protocol::CSS::StyleSheetOrigin::Inspector)
 950         fireStyleSheetChanged();
 951     else
 952         reparseStyleSheet(styleSheetText.toString());
 953 
 954     ASSERT(m_pageStyleSheet-&gt;length());
 955     unsigned lastRuleIndex = m_pageStyleSheet-&gt;length() - 1;
 956     CSSRule* rule = m_pageStyleSheet-&gt;item(lastRuleIndex);
 957     ASSERT(rule);
 958 
 959     CSSStyleRule* styleRule = InspectorCSSAgent::asCSSStyleRule(*rule);
 960     if (!styleRule) {
 961         // What we just added has to be a CSSStyleRule - we cannot handle other types of rules yet.
 962         // If it is not a style rule, pretend we never touched the stylesheet.
 963         m_pageStyleSheet-&gt;deleteRule(lastRuleIndex);
 964         return Exception { SyntaxError };
 965     }
 966 
 967     return styleRule;
 968 }
 969 
 970 ExceptionOr&lt;void&gt; InspectorStyleSheet::deleteRule(const InspectorCSSId&amp; id)
 971 {
 972     if (!m_pageStyleSheet)
 973         return Exception { NotSupportedError };
 974 
 975     RefPtr&lt;CSSStyleRule&gt; rule = ruleForId(id);
 976     if (!rule)
 977         return Exception { NotFoundError };
 978     CSSStyleSheet* styleSheet = rule-&gt;parentStyleSheet();
 979     if (!styleSheet || !ensureParsedDataReady())
 980         return Exception { NotFoundError };
 981 
 982     auto sourceData = ruleSourceDataFor(&amp;rule-&gt;style());
 983     if (!sourceData)
 984         return Exception { NotFoundError };
 985 
 986     auto deleteRuleResult = styleSheet-&gt;deleteRule(id.ordinal());
 987     if (deleteRuleResult.hasException())
 988         return deleteRuleResult.releaseException();
 989 
 990     // |rule| MAY NOT be addressed after this!
 991 
 992     String sheetText = m_parsedStyleSheet-&gt;text();
 993     sheetText.remove(sourceData-&gt;ruleHeaderRange.start, sourceData-&gt;ruleBodyRange.end - sourceData-&gt;ruleHeaderRange.start + 1);
 994     setText(sheetText);
 995     fireStyleSheetChanged();
 996     return { };
 997 }
 998 
 999 CSSStyleRule* InspectorStyleSheet::ruleForId(const InspectorCSSId&amp; id) const
1000 {
1001     if (!m_pageStyleSheet)
1002         return nullptr;
1003 
1004     ASSERT(!id.isEmpty());
1005     ensureFlatRules();
1006     return id.ordinal() &gt;= m_flatRules.size() ? nullptr : m_flatRules.at(id.ordinal()).get();
1007 }
1008 
1009 RefPtr&lt;Inspector::Protocol::CSS::CSSStyleSheetBody&gt; InspectorStyleSheet::buildObjectForStyleSheet()
1010 {
1011     CSSStyleSheet* styleSheet = pageStyleSheet();
1012     if (!styleSheet)
1013         return nullptr;
1014 
1015     RefPtr&lt;CSSRuleList&gt; cssRuleList = asCSSRuleList(styleSheet);
1016 
1017     auto result = Inspector::Protocol::CSS::CSSStyleSheetBody::create()
1018         .setStyleSheetId(id())
1019         .setRules(buildArrayForRuleList(cssRuleList.get()))
1020         .release();
1021 
1022     auto styleSheetText = text();
1023     if (!styleSheetText.hasException())
1024         result-&gt;setText(styleSheetText.releaseReturnValue());
1025 
1026     return result;
1027 }
1028 
1029 RefPtr&lt;Inspector::Protocol::CSS::CSSStyleSheetHeader&gt; InspectorStyleSheet::buildObjectForStyleSheetInfo()
1030 {
1031     CSSStyleSheet* styleSheet = pageStyleSheet();
1032     if (!styleSheet)
1033         return nullptr;
1034 
1035     Document* document = styleSheet-&gt;ownerDocument();
1036     Frame* frame = document ? document-&gt;frame() : nullptr;
1037     return Inspector::Protocol::CSS::CSSStyleSheetHeader::create()
1038         .setStyleSheetId(id())
1039         .setOrigin(m_origin)
1040         .setDisabled(styleSheet-&gt;disabled())
1041         .setSourceURL(finalURL())
1042         .setTitle(styleSheet-&gt;title())
1043         .setFrameId(m_pageAgent-&gt;frameId(frame))
1044         .setIsInline(styleSheet-&gt;isInline() &amp;&amp; styleSheet-&gt;startPosition() != TextPosition())
1045         .setStartLine(styleSheet-&gt;startPosition().m_line.zeroBasedInt())
1046         .setStartColumn(styleSheet-&gt;startPosition().m_column.zeroBasedInt())
1047         .release();
1048 }
1049 
1050 static bool hasDynamicSpecificity(const CSSSelector&amp; simpleSelector)
1051 {
1052     // It is possible that these can have a static specificity if each selector in the list has
1053     // equal specificity, but lets always report that they can be dynamic.
1054     for (const CSSSelector* selector = &amp;simpleSelector; selector; selector = selector-&gt;tagHistory()) {
1055         if (selector-&gt;match() == CSSSelector::PseudoClass) {
1056             CSSSelector::PseudoClassType pseudoClassType = selector-&gt;pseudoClassType();
1057             if (pseudoClassType == CSSSelector::PseudoClassMatches)
1058                 return true;
1059             if (pseudoClassType == CSSSelector::PseudoClassNthChild || pseudoClassType == CSSSelector::PseudoClassNthLastChild) {
1060                 if (selector-&gt;selectorList())
1061                     return true;
1062                 return false;
1063             }
1064         }
1065     }
1066 
1067     return false;
1068 }
1069 
1070 static Ref&lt;Inspector::Protocol::CSS::CSSSelector&gt; buildObjectForSelectorHelper(const String&amp; selectorText, const CSSSelector&amp; selector, Element* element)
1071 {
1072     auto inspectorSelector = Inspector::Protocol::CSS::CSSSelector::create()
1073         .setText(selectorText)
1074         .release();
1075 
1076     if (element) {
1077         bool dynamic = hasDynamicSpecificity(selector);
1078         if (dynamic)
1079             inspectorSelector-&gt;setDynamic(true);
1080 
1081         SelectorChecker::CheckingContext context(SelectorChecker::Mode::CollectingRules);
1082         SelectorChecker selectorChecker(element-&gt;document());
1083 
1084         unsigned specificity;
1085         bool okay = selectorChecker.match(selector, *element, context, specificity);
1086         if (!okay)
1087             specificity = selector.staticSpecificity(okay);
1088 
1089         if (okay) {
1090             auto tuple = JSON::ArrayOf&lt;int&gt;::create();
1091             tuple-&gt;addItem(static_cast&lt;int&gt;((specificity &amp; CSSSelector::idMask) &gt;&gt; 16));
1092             tuple-&gt;addItem(static_cast&lt;int&gt;((specificity &amp; CSSSelector::classMask) &gt;&gt; 8));
1093             tuple-&gt;addItem(static_cast&lt;int&gt;(specificity &amp; CSSSelector::elementMask));
1094             inspectorSelector-&gt;setSpecificity(WTFMove(tuple));
1095         }
1096     }
1097 
1098     return inspectorSelector;
1099 }
1100 
1101 static Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSSelector&gt;&gt; selectorsFromSource(const CSSRuleSourceData* sourceData, const String&amp; sheetText, const CSSSelectorList&amp; selectorList, Element* element)
1102 {
1103     static NeverDestroyed&lt;JSC::Yarr::RegularExpression&gt; comment(&quot;/\\*[^]*?\\*/&quot;, JSC::Yarr::TextCaseSensitive, JSC::Yarr::MultilineEnabled);
1104 
1105     auto result = JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSSelector&gt;::create();
1106     const CSSSelector* selector = selectorList.first();
1107     for (auto&amp; range : sourceData-&gt;selectorRanges) {
1108         // If we don&#39;t have a selector, that means the SourceData for this CSSStyleSheet
1109         // no longer matches up with the actual rules in the CSSStyleSheet.
1110         ASSERT(selector);
1111         if (!selector)
1112             break;
1113 
1114         String selectorText = sheetText.substring(range.start, range.length());
1115 
1116         // We don&#39;t want to see any comments in the selector components, only the meaningful parts.
1117         replace(selectorText, comment, String());
1118         result-&gt;addItem(buildObjectForSelectorHelper(selectorText.stripWhiteSpace(), *selector, element));
1119 
1120         selector = CSSSelectorList::next(selector);
1121     }
1122     return result;
1123 }
1124 
1125 Ref&lt;Inspector::Protocol::CSS::CSSSelector&gt; InspectorStyleSheet::buildObjectForSelector(const CSSSelector* selector, Element* element)
1126 {
1127     return buildObjectForSelectorHelper(selector-&gt;selectorText(), *selector, element);
1128 }
1129 
1130 Ref&lt;Inspector::Protocol::CSS::SelectorList&gt; InspectorStyleSheet::buildObjectForSelectorList(CSSStyleRule* rule, Element* element, int&amp; endingLine)
1131 {
1132     RefPtr&lt;CSSRuleSourceData&gt; sourceData;
1133     if (ensureParsedDataReady())
1134         sourceData = ruleSourceDataFor(&amp;rule-&gt;style());
1135     RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSSelector&gt;&gt; selectors;
1136 
1137     // This intentionally does not rely on the source data to avoid catching the trailing comments (before the declaration starting &#39;{&#39;).
1138     String selectorText = rule-&gt;selectorText();
1139 
1140     if (sourceData)
1141         selectors = selectorsFromSource(sourceData.get(), m_parsedStyleSheet-&gt;text(), rule-&gt;styleRule().selectorList(), element);
1142     else {
1143         selectors = JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSSelector&gt;::create();
1144         const CSSSelectorList&amp; selectorList = rule-&gt;styleRule().selectorList();
1145         for (const CSSSelector* selector = selectorList.first(); selector; selector = CSSSelectorList::next(selector))
1146             selectors-&gt;addItem(buildObjectForSelector(selector, element));
1147     }
1148     auto result = Inspector::Protocol::CSS::SelectorList::create()
1149         .setSelectors(WTFMove(selectors))
1150         .setText(selectorText)
1151         .release();
1152     if (sourceData)
1153         result-&gt;setRange(buildSourceRangeObject(sourceData-&gt;ruleHeaderRange, lineEndings(), &amp;endingLine));
1154     return result;
1155 }
1156 
1157 RefPtr&lt;Inspector::Protocol::CSS::CSSRule&gt; InspectorStyleSheet::buildObjectForRule(CSSStyleRule* rule, Element* element)
1158 {
1159     CSSStyleSheet* styleSheet = pageStyleSheet();
1160     if (!styleSheet)
1161         return nullptr;
1162 
1163     int endingLine = 0;
1164     auto result = Inspector::Protocol::CSS::CSSRule::create()
1165         .setSelectorList(buildObjectForSelectorList(rule, element, endingLine))
1166         .setSourceLine(endingLine)
1167         .setOrigin(m_origin)
1168         .setStyle(buildObjectForStyle(&amp;rule-&gt;style()))
1169         .release();
1170 
<a name="15" id="anc15"></a><span class="line-modified">1171     if (m_origin == Inspector::Protocol::CSS::StyleSheetOrigin::Regular || m_origin == Inspector::Protocol::CSS::StyleSheetOrigin::User)</span>

1172         result-&gt;setSourceURL(finalURL());
1173 
1174     if (canBind()) {
1175         InspectorCSSId id(ruleId(rule));
1176         if (!id.isEmpty())
1177             result-&gt;setRuleId(id.asProtocolValue&lt;Inspector::Protocol::CSS::CSSRuleId&gt;());
1178     }
1179 
1180     auto groupingsPayload = buildArrayForGroupings(*rule);
1181     if (groupingsPayload-&gt;length())
1182         result-&gt;setGroupings(WTFMove(groupingsPayload));
1183 
1184     return result;
1185 }
1186 
1187 RefPtr&lt;Inspector::Protocol::CSS::CSSStyle&gt; InspectorStyleSheet::buildObjectForStyle(CSSStyleDeclaration* style)
1188 {
1189     RefPtr&lt;CSSRuleSourceData&gt; sourceData;
1190     if (ensureParsedDataReady())
1191         sourceData = ruleSourceDataFor(style);
1192 
1193     InspectorCSSId id = ruleOrStyleId(style);
1194     if (id.isEmpty()) {
1195         return Inspector::Protocol::CSS::CSSStyle::create()
1196             .setCssProperties(ArrayOf&lt;Inspector::Protocol::CSS::CSSProperty&gt;::create())
1197             .setShorthandEntries(ArrayOf&lt;Inspector::Protocol::CSS::ShorthandEntry&gt;::create())
1198             .release();
1199     }
1200     RefPtr&lt;InspectorStyle&gt; inspectorStyle = inspectorStyleForId(id);
1201     RefPtr&lt;Inspector::Protocol::CSS::CSSStyle&gt; result = inspectorStyle-&gt;buildObjectForStyle();
1202 
1203     // Style text cannot be retrieved without stylesheet, so set cssText here.
1204     if (sourceData) {
1205         auto sheetText = text();
1206         if (!sheetText.hasException()) {
1207             auto&amp; bodyRange = sourceData-&gt;ruleBodyRange;
1208             result-&gt;setCssText(sheetText.releaseReturnValue().substring(bodyRange.start, bodyRange.end - bodyRange.start));
1209         }
1210     }
1211 
1212     return result;
1213 }
1214 
1215 ExceptionOr&lt;void&gt; InspectorStyleSheet::setStyleText(const InspectorCSSId&amp; id, const String&amp; text, String* oldText)
1216 {
1217     auto inspectorStyle = inspectorStyleForId(id);
1218     if (!inspectorStyle)
1219         return Exception { NotFoundError };
1220 
1221     if (oldText) {
1222         auto result = inspectorStyle-&gt;text();
1223         if (result.hasException())
1224             return result.releaseException();
1225         *oldText = result.releaseReturnValue();
1226     }
1227 
1228     auto result = inspectorStyle-&gt;setText(text);
1229     if (!result.hasException())
1230         fireStyleSheetChanged();
1231     return result;
1232 }
1233 
1234 ExceptionOr&lt;String&gt; InspectorStyleSheet::text() const
1235 {
1236     if (!ensureText())
1237         return Exception { NotFoundError };
1238     return String { m_parsedStyleSheet-&gt;text() };
1239 }
1240 
1241 CSSStyleDeclaration* InspectorStyleSheet::styleForId(const InspectorCSSId&amp; id) const
1242 {
1243     CSSStyleRule* rule = ruleForId(id);
1244     if (!rule)
1245         return nullptr;
1246 
1247     return &amp;rule-&gt;style();
1248 }
1249 
1250 void InspectorStyleSheet::fireStyleSheetChanged()
1251 {
1252     if (m_listener)
1253         m_listener-&gt;styleSheetChanged(this);
1254 }
1255 
1256 RefPtr&lt;InspectorStyle&gt; InspectorStyleSheet::inspectorStyleForId(const InspectorCSSId&amp; id)
1257 {
1258     CSSStyleDeclaration* style = styleForId(id);
1259     if (!style)
1260         return nullptr;
1261 
1262     return InspectorStyle::create(id, *style, this);
1263 }
1264 
1265 InspectorCSSId InspectorStyleSheet::ruleOrStyleId(CSSStyleDeclaration* style) const
1266 {
1267     unsigned index = ruleIndexByStyle(style);
1268     if (index != UINT_MAX)
1269         return InspectorCSSId(id(), index);
1270     return InspectorCSSId();
1271 }
1272 
1273 Document* InspectorStyleSheet::ownerDocument() const
1274 {
1275     return m_pageStyleSheet-&gt;ownerDocument();
1276 }
1277 
1278 RefPtr&lt;CSSRuleSourceData&gt; InspectorStyleSheet::ruleSourceDataFor(CSSStyleDeclaration* style) const
1279 {
1280     return m_parsedStyleSheet-&gt;ruleSourceDataAt(ruleIndexByStyle(style));
1281 }
1282 
1283 Vector&lt;size_t&gt; InspectorStyleSheet::lineEndings() const
1284 {
1285     if (!m_parsedStyleSheet-&gt;hasText())
1286         return { };
1287     return ContentSearchUtilities::lineEndings(m_parsedStyleSheet-&gt;text());
1288 }
1289 
1290 unsigned InspectorStyleSheet::ruleIndexByStyle(CSSStyleDeclaration* pageStyle) const
1291 {
1292     ensureFlatRules();
1293     unsigned index = 0;
1294     for (auto&amp; rule : m_flatRules) {
1295         if (&amp;rule-&gt;style() == pageStyle)
1296             return index;
1297 
1298         ++index;
1299     }
1300     return UINT_MAX;
1301 }
1302 
1303 bool InspectorStyleSheet::styleSheetMutated() const
1304 {
1305     return m_pageStyleSheet &amp;&amp; m_pageStyleSheet-&gt;hadRulesMutation();
1306 }
1307 
1308 bool InspectorStyleSheet::ensureParsedDataReady()
1309 {
1310     bool allowParsedData = m_origin == Inspector::Protocol::CSS::StyleSheetOrigin::Inspector || !styleSheetMutated();
1311     return allowParsedData &amp;&amp; ensureText() &amp;&amp; ensureSourceData();
1312 }
1313 
1314 bool InspectorStyleSheet::ensureText() const
1315 {
1316     if (!m_parsedStyleSheet)
1317         return false;
1318     if (m_parsedStyleSheet-&gt;hasText())
1319         return true;
1320 
1321     String text;
1322     bool success = originalStyleSheetText(&amp;text);
1323     if (success)
1324         m_parsedStyleSheet-&gt;setText(text);
1325     // No need to clear m_flatRules here - it&#39;s empty.
1326 
1327     return success;
1328 }
1329 
1330 bool InspectorStyleSheet::ensureSourceData()
1331 {
1332     if (m_parsedStyleSheet-&gt;hasSourceData())
1333         return true;
1334 
1335     if (!m_parsedStyleSheet-&gt;hasText())
1336         return false;
1337 
1338     auto newStyleSheet = StyleSheetContents::create();
1339     auto ruleSourceDataResult = makeUnique&lt;RuleSourceDataList&gt;();
1340 
1341     CSSParserContext context(parserContextForDocument(m_pageStyleSheet-&gt;ownerDocument()));
1342     StyleSheetHandler handler(m_parsedStyleSheet-&gt;text(), m_pageStyleSheet-&gt;ownerDocument(), ruleSourceDataResult.get());
1343     CSSParser::parseSheetForInspector(context, newStyleSheet.ptr(), m_parsedStyleSheet-&gt;text(), handler);
1344     m_parsedStyleSheet-&gt;setSourceData(WTFMove(ruleSourceDataResult));
1345     return m_parsedStyleSheet-&gt;hasSourceData();
1346 }
1347 
1348 void InspectorStyleSheet::ensureFlatRules() const
1349 {
1350     // We are fine with redoing this for empty stylesheets as this will run fast.
1351     if (m_flatRules.isEmpty())
1352         collectFlatRules(asCSSRuleList(pageStyleSheet()), &amp;m_flatRules);
1353 }
1354 
1355 ExceptionOr&lt;void&gt; InspectorStyleSheet::setStyleText(CSSStyleDeclaration* style, const String&amp; text)
1356 {
1357     if (!m_pageStyleSheet)
1358         return Exception { NotFoundError };
1359     if (!ensureParsedDataReady())
1360         return Exception { NotFoundError };
1361 
1362     String patchedStyleSheetText;
1363     bool success = styleSheetTextWithChangedStyle(style, text, &amp;patchedStyleSheetText);
1364     if (!success)
1365         return Exception { NotFoundError };
1366 
1367     InspectorCSSId id = ruleOrStyleId(style);
1368     if (id.isEmpty())
1369         return Exception { NotFoundError };
1370 
1371     auto setCssTextResult = style-&gt;setCssText(text);
1372     if (setCssTextResult.hasException())
1373         return setCssTextResult.releaseException();
1374 
1375     m_parsedStyleSheet-&gt;setText(patchedStyleSheetText);
1376     return { };
1377 }
1378 
1379 bool InspectorStyleSheet::styleSheetTextWithChangedStyle(CSSStyleDeclaration* style, const String&amp; newStyleText, String* result)
1380 {
1381     if (!style)
1382         return false;
1383 
1384     if (!ensureParsedDataReady())
1385         return false;
1386 
1387     RefPtr&lt;CSSRuleSourceData&gt; sourceData = ruleSourceDataFor(style);
1388     unsigned bodyStart = sourceData-&gt;ruleBodyRange.start;
1389     unsigned bodyEnd = sourceData-&gt;ruleBodyRange.end;
1390     ASSERT(bodyStart &lt;= bodyEnd);
1391 
1392     String text = m_parsedStyleSheet-&gt;text();
1393     ASSERT_WITH_SECURITY_IMPLICATION(bodyEnd &lt;= text.length()); // bodyEnd is exclusive
1394 
1395     text.replace(bodyStart, bodyEnd - bodyStart, newStyleText);
1396     *result = text;
1397     return true;
1398 }
1399 
1400 InspectorCSSId InspectorStyleSheet::ruleId(CSSStyleRule* rule) const
1401 {
1402     return ruleOrStyleId(&amp;rule-&gt;style());
1403 }
1404 
1405 bool InspectorStyleSheet::originalStyleSheetText(String* result) const
1406 {
<a name="16" id="anc16"></a><span class="line-modified">1407     if (!m_pageStyleSheet || m_origin == Inspector::Protocol::CSS::StyleSheetOrigin::UserAgent)</span>
<span class="line-modified">1408         return false;</span>
<span class="line-modified">1409     return inlineStyleSheetText(result) || resourceStyleSheetText(result) || extensionStyleSheetText(result);</span>

1410 }
1411 
1412 bool InspectorStyleSheet::resourceStyleSheetText(String* result) const
1413 {
<a name="17" id="anc17"></a><span class="line-modified">1414     if (!ownerDocument() || !ownerDocument()-&gt;frame())</span>



1415         return false;
1416 
1417     String error;
1418     bool base64Encoded;
1419     InspectorPageAgent::resourceContent(error, ownerDocument()-&gt;frame(), URL({ }, m_pageStyleSheet-&gt;href()), result, &amp;base64Encoded);
1420     return error.isEmpty() &amp;&amp; !base64Encoded;
1421 }
1422 
1423 bool InspectorStyleSheet::inlineStyleSheetText(String* result) const
1424 {
<a name="18" id="anc18"></a><span class="line-modified">1425     auto* ownerNode = m_pageStyleSheet-&gt;ownerNode();</span>



1426     if (!is&lt;Element&gt;(ownerNode))
1427         return false;
<a name="19" id="anc19"></a>
1428 
<a name="20" id="anc20"></a><span class="line-added">1429     auto&amp; ownerElement = downcast&lt;Element&gt;(*ownerNode);</span>
1430     if (!is&lt;HTMLStyleElement&gt;(ownerElement) &amp;&amp; !is&lt;SVGStyleElement&gt;(ownerElement))
1431         return false;
<a name="21" id="anc21"></a><span class="line-added">1432 </span>
1433     *result = ownerElement.textContent();
1434     return true;
1435 }
1436 
<a name="22" id="anc22"></a><span class="line-added">1437 bool InspectorStyleSheet::extensionStyleSheetText(String* result) const</span>
<span class="line-added">1438 {</span>
<span class="line-added">1439     if (!ownerDocument())</span>
<span class="line-added">1440         return false;</span>
<span class="line-added">1441 </span>
<span class="line-added">1442     auto content = ownerDocument()-&gt;extensionStyleSheets().contentForInjectedStyleSheet(m_pageStyleSheet);</span>
<span class="line-added">1443     if (content.isEmpty())</span>
<span class="line-added">1444         return false;</span>
<span class="line-added">1445 </span>
<span class="line-added">1446     *result = content;</span>
<span class="line-added">1447     return true;</span>
<span class="line-added">1448 }</span>
<span class="line-added">1449 </span>
1450 Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSRule&gt;&gt; InspectorStyleSheet::buildArrayForRuleList(CSSRuleList* ruleList)
1451 {
1452     auto result = JSON::ArrayOf&lt;Inspector::Protocol::CSS::CSSRule&gt;::create();
1453     if (!ruleList)
1454         return result;
1455 
1456     RefPtr&lt;CSSRuleList&gt; refRuleList = ruleList;
1457     CSSStyleRuleVector rules;
1458     collectFlatRules(WTFMove(refRuleList), &amp;rules);
1459 
1460     for (auto&amp; rule : rules)
1461         result-&gt;addItem(buildObjectForRule(rule.get(), nullptr));
1462 
1463     return result;
1464 }
1465 
1466 void InspectorStyleSheet::collectFlatRules(RefPtr&lt;CSSRuleList&gt;&amp;&amp; ruleList, CSSStyleRuleVector* result)
1467 {
1468     if (!ruleList)
1469         return;
1470 
1471     for (unsigned i = 0, size = ruleList-&gt;length(); i &lt; size; ++i) {
1472         CSSRule* rule = ruleList-&gt;item(i);
1473         CSSStyleRule* styleRule = InspectorCSSAgent::asCSSStyleRule(*rule);
1474         if (styleRule)
1475             result-&gt;append(styleRule);
1476         else {
1477             RefPtr&lt;CSSRuleList&gt; childRuleList = asCSSRuleList(rule);
1478             if (childRuleList)
1479                 collectFlatRules(WTFMove(childRuleList), result);
1480         }
1481     }
1482 }
1483 
1484 Ref&lt;InspectorStyleSheetForInlineStyle&gt; InspectorStyleSheetForInlineStyle::create(InspectorPageAgent* pageAgent, const String&amp; id, Ref&lt;StyledElement&gt;&amp;&amp; element, Inspector::Protocol::CSS::StyleSheetOrigin origin, Listener* listener)
1485 {
1486     return adoptRef(*new InspectorStyleSheetForInlineStyle(pageAgent, id, WTFMove(element), origin, listener));
1487 }
1488 
1489 InspectorStyleSheetForInlineStyle::InspectorStyleSheetForInlineStyle(InspectorPageAgent* pageAgent, const String&amp; id, Ref&lt;StyledElement&gt;&amp;&amp; element, Inspector::Protocol::CSS::StyleSheetOrigin origin, Listener* listener)
1490     : InspectorStyleSheet(pageAgent, id, nullptr, origin, String(), listener)
1491     , m_element(WTFMove(element))
1492     , m_ruleSourceData(nullptr)
1493     , m_isStyleTextValid(false)
1494 {
1495     m_inspectorStyle = InspectorStyle::create(InspectorCSSId(id, 0), inlineStyle(), this);
1496     m_styleText = m_element-&gt;getAttribute(&quot;style&quot;).string();
1497 }
1498 
1499 void InspectorStyleSheetForInlineStyle::didModifyElementAttribute()
1500 {
1501     m_isStyleTextValid = false;
1502     if (&amp;m_element-&gt;cssomStyle() != &amp;m_inspectorStyle-&gt;cssStyle())
1503         m_inspectorStyle = InspectorStyle::create(InspectorCSSId(id(), 0), inlineStyle(), this);
1504     m_ruleSourceData = nullptr;
1505 }
1506 
1507 ExceptionOr&lt;String&gt; InspectorStyleSheetForInlineStyle::text() const
1508 {
1509     if (!m_isStyleTextValid) {
1510         m_styleText = elementStyleText();
1511         m_isStyleTextValid = true;
1512     }
1513     return String { m_styleText };
1514 }
1515 
1516 ExceptionOr&lt;void&gt; InspectorStyleSheetForInlineStyle::setStyleText(CSSStyleDeclaration* style, const String&amp; text)
1517 {
1518     ASSERT_UNUSED(style, style == &amp;inlineStyle());
1519 
1520     {
1521         InspectorCSSAgent::InlineStyleOverrideScope overrideScope(m_element-&gt;document());
1522         m_element-&gt;setAttribute(HTMLNames::styleAttr, text);
1523     }
1524 
1525     m_styleText = text;
1526     m_isStyleTextValid = true;
1527     m_ruleSourceData = nullptr;
1528 
1529     return { };
1530 }
1531 
1532 Vector&lt;size_t&gt; InspectorStyleSheetForInlineStyle::lineEndings() const
1533 {
1534     return ContentSearchUtilities::lineEndings(elementStyleText());
1535 }
1536 
1537 Document* InspectorStyleSheetForInlineStyle::ownerDocument() const
1538 {
1539     return &amp;m_element-&gt;document();
1540 }
1541 
1542 bool InspectorStyleSheetForInlineStyle::ensureParsedDataReady()
1543 {
1544     // The &quot;style&quot; property value can get changed indirectly, e.g. via element.style.borderWidth = &quot;2px&quot;.
1545     const String&amp; currentStyleText = elementStyleText();
1546     if (m_styleText != currentStyleText) {
1547         m_ruleSourceData = nullptr;
1548         m_styleText = currentStyleText;
1549         m_isStyleTextValid = true;
1550     }
1551 
1552     if (m_ruleSourceData)
1553         return true;
1554 
1555     m_ruleSourceData = ruleSourceData();
1556     return true;
1557 }
1558 
1559 RefPtr&lt;InspectorStyle&gt; InspectorStyleSheetForInlineStyle::inspectorStyleForId(const InspectorCSSId&amp; id)
1560 {
1561     ASSERT_UNUSED(id, !id.ordinal());
1562     return m_inspectorStyle.copyRef();
1563 }
1564 
1565 CSSStyleDeclaration&amp; InspectorStyleSheetForInlineStyle::inlineStyle() const
1566 {
1567     return m_element-&gt;cssomStyle();
1568 }
1569 
1570 const String&amp; InspectorStyleSheetForInlineStyle::elementStyleText() const
1571 {
1572     return m_element-&gt;getAttribute(&quot;style&quot;).string();
1573 }
1574 
1575 Ref&lt;CSSRuleSourceData&gt; InspectorStyleSheetForInlineStyle::ruleSourceData() const
1576 {
1577     if (m_styleText.isEmpty()) {
<a name="23" id="anc23"></a><span class="line-modified">1578         auto result = CSSRuleSourceData::create(StyleRuleType::Style);</span>
1579         result-&gt;ruleBodyRange.start = 0;
1580         result-&gt;ruleBodyRange.end = 0;
1581         return result;
1582     }
1583 
1584     CSSParserContext context(parserContextForDocument(&amp;m_element-&gt;document()));
1585     RuleSourceDataList ruleSourceDataResult;
1586     StyleSheetHandler handler(m_styleText, &amp;m_element-&gt;document(), &amp;ruleSourceDataResult);
1587     CSSParser::parseDeclarationForInspector(context, m_styleText, handler);
1588     return WTFMove(ruleSourceDataResult.first());
1589 }
1590 
1591 } // namespace WebCore
<a name="24" id="anc24"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="24" type="hidden" />
</body>
</html>
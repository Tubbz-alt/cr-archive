<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/ViewportArguments.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
  5  *           (C) 2006 Alexey Proskuryakov (ap@webkit.org)
  6  * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2011 Apple Inc. All rights reserved.
  7  * Copyright (C) 2008 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  8  * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
  9  * Copyright (C) 2012 Intel Corporation. All rights reserved.
 10  *
 11  * This library is free software; you can redistribute it and/or
 12  * modify it under the terms of the GNU Library General Public
 13  * License as published by the Free Software Foundation; either
 14  * version 2 of the License, or (at your option) any later version.
 15  *
 16  * This library is distributed in the hope that it will be useful,
 17  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 18  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 19  * Library General Public License for more details.
 20  *
 21  * You should have received a copy of the GNU Library General Public License
 22  * along with this library; see the file COPYING.LIB.  If not, write to
 23  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 24  * Boston, MA 02110-1301, USA.
 25  *
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;ViewportArguments.h&quot;
 30 
 31 #include &quot;Document.h&quot;
 32 #include &quot;Frame.h&quot;
 33 #include &quot;IntSize.h&quot;
<a name="1" id="anc1"></a>
 34 #include &quot;ScriptableDocumentParser.h&quot;
 35 #include &quot;Settings.h&quot;
 36 #include &lt;wtf/text/TextStream.h&gt;
 37 
 38 namespace WebCore {
 39 
 40 typedef WTF::Function&lt;void(ViewportErrorCode, StringView, StringView)&gt; InternalViewportErrorHandler;
 41 
 42 #if PLATFORM(GTK)
 43 const float ViewportArguments::deprecatedTargetDPI = 160;
 44 #endif
 45 
 46 static const float&amp; compareIgnoringAuto(const float&amp; value1, const float&amp; value2, const float&amp; (*compare) (const float&amp;, const float&amp;))
 47 {
 48     ASSERT(value1 != ViewportArguments::ValueAuto || value2 != ViewportArguments::ValueAuto);
 49 
 50     if (value1 == ViewportArguments::ValueAuto)
 51         return value2;
 52 
 53     if (value2 == ViewportArguments::ValueAuto)
 54         return value1;
 55 
 56     return compare(value1, value2);
 57 }
 58 
 59 static inline float clampLengthValue(float value)
 60 {
 61     ASSERT(value != ViewportArguments::ValueDeviceWidth);
 62     ASSERT(value != ViewportArguments::ValueDeviceHeight);
 63 
 64     // Limits as defined in the css-device-adapt spec.
 65     if (value != ViewportArguments::ValueAuto)
 66         return std::min&lt;float&gt;(10000, std::max&lt;float&gt;(value, 1));
 67     return value;
 68 }
 69 
 70 static inline float clampScaleValue(float value)
 71 {
 72     ASSERT(value != ViewportArguments::ValueDeviceWidth);
 73     ASSERT(value != ViewportArguments::ValueDeviceHeight);
 74 
 75     // Limits as defined in the css-device-adapt spec.
 76     if (value != ViewportArguments::ValueAuto)
 77         return std::min&lt;float&gt;(10, std::max&lt;float&gt;(value, 0.1));
 78     return value;
 79 }
 80 
 81 ViewportAttributes ViewportArguments::resolve(const FloatSize&amp; initialViewportSize, const FloatSize&amp; deviceSize, int defaultWidth) const
 82 {
 83     float resultWidth = width;
 84     float resultMaxWidth = maxWidth;
 85     float resultMinWidth = minWidth;
 86     float resultHeight = height;
 87     float resultMinHeight = minHeight;
 88     float resultMaxHeight = maxHeight;
 89     float resultZoom = zoom;
 90     float resultMinZoom = minZoom;
 91     float resultMaxZoom = maxZoom;
 92 
 93     switch (int(resultWidth)) {
 94     case ViewportArguments::ValueDeviceWidth:
 95         resultWidth = deviceSize.width();
 96         break;
 97     case ViewportArguments::ValueDeviceHeight:
 98         resultWidth = deviceSize.height();
 99         break;
100     }
101 
102     switch (int(resultHeight)) {
103     case ViewportArguments::ValueDeviceWidth:
104         resultHeight = deviceSize.width();
105         break;
106     case ViewportArguments::ValueDeviceHeight:
107         resultHeight = deviceSize.height();
108         break;
109     }
110 
111     if (type == ViewportArguments::CSSDeviceAdaptation) {
112         switch (int(resultMinWidth)) {
113         case ViewportArguments::ValueDeviceWidth:
114             resultMinWidth = deviceSize.width();
115             break;
116         case ViewportArguments::ValueDeviceHeight:
117             resultMinWidth = deviceSize.height();
118             break;
119         }
120 
121         switch (int(resultMaxWidth)) {
122         case ViewportArguments::ValueDeviceWidth:
123             resultMaxWidth = deviceSize.width();
124             break;
125         case ViewportArguments::ValueDeviceHeight:
126             resultMaxWidth = deviceSize.height();
127             break;
128         }
129 
130         switch (int(resultMinHeight)) {
131         case ViewportArguments::ValueDeviceWidth:
132             resultMinHeight = deviceSize.width();
133             break;
134         case ViewportArguments::ValueDeviceHeight:
135             resultMinHeight = deviceSize.height();
136             break;
137         }
138 
139         switch (int(resultMaxHeight)) {
140         case ViewportArguments::ValueDeviceWidth:
141             resultMaxHeight = deviceSize.width();
142             break;
143         case ViewportArguments::ValueDeviceHeight:
144             resultMaxHeight = deviceSize.height();
145             break;
146         }
147 
148         if (resultMinWidth != ViewportArguments::ValueAuto || resultMaxWidth != ViewportArguments::ValueAuto)
149             resultWidth = compareIgnoringAuto(resultMinWidth, compareIgnoringAuto(resultMaxWidth, deviceSize.width(), std::min), std::max);
150 
151         if (resultMinHeight != ViewportArguments::ValueAuto || resultMaxHeight != ViewportArguments::ValueAuto)
152             resultHeight = compareIgnoringAuto(resultMinHeight, compareIgnoringAuto(resultMaxHeight, deviceSize.height(), std::min), std::max);
153 
154         if (resultMinZoom != ViewportArguments::ValueAuto &amp;&amp; resultMaxZoom != ViewportArguments::ValueAuto)
155             resultMaxZoom = std::max(resultMinZoom, resultMaxZoom);
156 
157         if (resultZoom != ViewportArguments::ValueAuto)
158             resultZoom = compareIgnoringAuto(resultMinZoom, compareIgnoringAuto(resultMaxZoom, resultZoom, std::min), std::max);
159 
160         if (resultWidth == ViewportArguments::ValueAuto &amp;&amp; resultZoom == ViewportArguments::ValueAuto)
161             resultWidth = deviceSize.width();
162 
163         if (resultWidth == ViewportArguments::ValueAuto &amp;&amp; resultHeight == ViewportArguments::ValueAuto)
164             resultWidth = deviceSize.width() / resultZoom;
165 
166         if (resultWidth == ViewportArguments::ValueAuto)
167             resultWidth = resultHeight * deviceSize.width() / deviceSize.height();
168 
169         if (resultHeight == ViewportArguments::ValueAuto)
170             resultHeight = resultWidth * deviceSize.height() / deviceSize.width();
171 
172         if (resultZoom != ViewportArguments::ValueAuto || resultMaxZoom != ViewportArguments::ValueAuto) {
173             resultWidth = compareIgnoringAuto(resultWidth, deviceSize.width() / compareIgnoringAuto(resultZoom, resultMaxZoom, std::min), std::max);
174             resultHeight = compareIgnoringAuto(resultHeight, deviceSize.height() / compareIgnoringAuto(resultZoom, resultMaxZoom, std::min), std::max);
175         }
176 
177         resultWidth = std::max&lt;float&gt;(1, resultWidth);
178         resultHeight = std::max&lt;float&gt;(1, resultHeight);
179     }
180 
181     if (type != ViewportArguments::CSSDeviceAdaptation &amp;&amp; type != ViewportArguments::Implicit) {
182         // Clamp values to a valid range, but not for @viewport since is
183         // not mandated by the specification.
184         resultWidth = clampLengthValue(resultWidth);
185         resultHeight = clampLengthValue(resultHeight);
186         resultZoom = clampScaleValue(resultZoom);
187         resultMinZoom = clampScaleValue(resultMinZoom);
188         resultMaxZoom = clampScaleValue(resultMaxZoom);
189     }
190 
191     ViewportAttributes result;
192 
193     // Resolve minimum-scale and maximum-scale values according to spec.
194     if (resultMinZoom == ViewportArguments::ValueAuto)
195         result.minimumScale = float(0.25);
196     else
197         result.minimumScale = resultMinZoom;
198 
199     if (resultMaxZoom == ViewportArguments::ValueAuto) {
200         result.maximumScale = 5;
201         result.minimumScale = std::min&lt;float&gt;(5, result.minimumScale);
202     } else
203         result.maximumScale = resultMaxZoom;
204     result.maximumScale = std::max(result.minimumScale, result.maximumScale);
205 
206     // Resolve initial-scale value.
207     result.initialScale = resultZoom;
208     if (resultZoom == ViewportArguments::ValueAuto) {
209         result.initialScale = initialViewportSize.width() / defaultWidth;
210         if (resultWidth != ViewportArguments::ValueAuto)
211             result.initialScale = initialViewportSize.width() / resultWidth;
212         if (resultHeight != ViewportArguments::ValueAuto) {
213             // if &#39;auto&#39;, the initial-scale will be negative here and thus ignored.
214             result.initialScale = std::max&lt;float&gt;(result.initialScale, initialViewportSize.height() / resultHeight);
215         }
216     }
217 
218     // Constrain initial-scale value to minimum-scale/maximum-scale range.
219     result.initialScale = std::min(result.maximumScale, std::max(result.minimumScale, result.initialScale));
220 
221     // Resolve width value.
222     if (resultWidth == ViewportArguments::ValueAuto) {
223         if (resultZoom == ViewportArguments::ValueAuto)
224             resultWidth = defaultWidth;
225         else if (resultHeight != ViewportArguments::ValueAuto)
226             resultWidth = resultHeight * (initialViewportSize.width() / initialViewportSize.height());
227         else
228             resultWidth = initialViewportSize.width() / result.initialScale;
229     }
230 
231     // Resolve height value.
232     if (resultHeight == ViewportArguments::ValueAuto)
233         resultHeight = resultWidth * (initialViewportSize.height() / initialViewportSize.width());
234 
235     if (type == ViewportArguments::ViewportMeta) {
236         // Extend width and height to fill the visual viewport for the resolved initial-scale.
237         resultWidth = std::max&lt;float&gt;(resultWidth, initialViewportSize.width() / result.initialScale);
238         resultHeight = std::max&lt;float&gt;(resultHeight, initialViewportSize.height() / result.initialScale);
239     }
240 
241     result.layoutSize.setWidth(resultWidth);
242     result.layoutSize.setHeight(resultHeight);
243 
244     // FIXME: This might affect some ports, but is the right thing to do.
245     // Only set initialScale to a value if it was explicitly set.
246     // if (resultZoom == ViewportArguments::ValueAuto)
247     //    result.initialScale = ViewportArguments::ValueAuto;
248 
249     result.userScalable = userZoom;
250     result.orientation = orientation;
251     result.shrinkToFit = shrinkToFit;
252     result.viewportFit = viewportFit;
253 
254     return result;
255 }
256 
257 static FloatSize convertToUserSpace(const FloatSize&amp; deviceSize, float devicePixelRatio)
258 {
259     FloatSize result = deviceSize;
260     if (devicePixelRatio != 1)
261         result.scale(1 / devicePixelRatio);
262     return result;
263 }
264 
265 ViewportAttributes computeViewportAttributes(ViewportArguments args, int desktopWidth, int deviceWidth, int deviceHeight, float devicePixelRatio, IntSize visibleViewport)
266 {
267     FloatSize initialViewportSize = convertToUserSpace(visibleViewport, devicePixelRatio);
268     FloatSize deviceSize = convertToUserSpace(FloatSize(deviceWidth, deviceHeight), devicePixelRatio);
269 
270     return args.resolve(initialViewportSize, deviceSize, desktopWidth);
271 }
272 
273 float computeMinimumScaleFactorForContentContained(const ViewportAttributes&amp; result, const IntSize&amp; visibleViewport, const IntSize&amp; contentsSize)
274 {
275     FloatSize viewportSize(visibleViewport);
276     return std::max&lt;float&gt;(result.minimumScale, std::max(viewportSize.width() / contentsSize.width(), viewportSize.height() / contentsSize.height()));
277 }
278 
279 void restrictMinimumScaleFactorToViewportSize(ViewportAttributes&amp; result, IntSize visibleViewport, float devicePixelRatio)
280 {
281     FloatSize viewportSize = convertToUserSpace(visibleViewport, devicePixelRatio);
282 
283     result.minimumScale = std::max&lt;float&gt;(result.minimumScale, std::max(viewportSize.width() / result.layoutSize.width(), viewportSize.height() / result.layoutSize.height()));
284 }
285 
286 void restrictScaleFactorToInitialScaleIfNotUserScalable(ViewportAttributes&amp; result)
287 {
288     if (!result.userScalable)
289         result.maximumScale = result.minimumScale = result.initialScale;
290 }
291 
292 static float numericPrefix(StringView key, StringView value, const InternalViewportErrorHandler&amp; errorHandler, bool* ok = nullptr)
293 {
294     size_t parsedLength;
295     float numericValue;
296     if (value.is8Bit())
297         numericValue = charactersToFloat(value.characters8(), value.length(), parsedLength);
298     else
299         numericValue = charactersToFloat(value.characters16(), value.length(), parsedLength);
300     if (!parsedLength) {
301         errorHandler(UnrecognizedViewportArgumentValueError, value, key);
302         if (ok)
303             *ok = false;
304         return 0;
305     }
306     if (parsedLength &lt; value.length())
307         errorHandler(TruncatedViewportArgumentValueError, value, key);
308     if (ok)
309         *ok = true;
310     return numericValue;
311 }
312 
313 static float findSizeValue(StringView key, StringView value, const InternalViewportErrorHandler&amp; errorHandler, bool* valueWasExplicit = nullptr)
314 {
315     // 1) Non-negative number values are translated to px lengths.
316     // 2) Negative number values are translated to auto.
317     // 3) device-width and device-height are used as keywords.
318     // 4) Other keywords and unknown values translate to 0.0.
319 
320     if (valueWasExplicit)
321         *valueWasExplicit = true;
322 
323     if (equalLettersIgnoringASCIICase(value, &quot;device-width&quot;))
324         return ViewportArguments::ValueDeviceWidth;
325 
326     if (equalLettersIgnoringASCIICase(value, &quot;device-height&quot;))
327         return ViewportArguments::ValueDeviceHeight;
328 
329     float sizeValue = numericPrefix(key, value, errorHandler);
330 
331     if (sizeValue &lt; 0) {
332         if (valueWasExplicit)
333             *valueWasExplicit = false;
334         return ViewportArguments::ValueAuto;
335     }
336 
337     return sizeValue;
338 }
339 
340 static float findScaleValue(StringView key, StringView value, const InternalViewportErrorHandler&amp; errorHandler)
341 {
342     // 1) Non-negative number values are translated to &lt;number&gt; values.
343     // 2) Negative number values are translated to auto.
344     // 3) yes is translated to 1.0.
345     // 4) device-width and device-height are translated to 10.0.
346     // 5) no and unknown values are translated to 0.0
347 
348     if (equalLettersIgnoringASCIICase(value, &quot;yes&quot;))
349         return 1;
350     if (equalLettersIgnoringASCIICase(value, &quot;no&quot;))
351         return 0;
352     if (equalLettersIgnoringASCIICase(value, &quot;device-width&quot;))
353         return 10;
354     if (equalLettersIgnoringASCIICase(value, &quot;device-height&quot;))
355         return 10;
356 
357     float numericValue = numericPrefix(key, value, errorHandler);
358 
359     if (numericValue &lt; 0)
360         return ViewportArguments::ValueAuto;
361 
362     if (numericValue &gt; 10.0)
363         errorHandler(MaximumScaleTooLargeError, { }, { });
364 
365     return numericValue;
366 }
367 
368 static bool findBooleanValue(StringView key, StringView value, const InternalViewportErrorHandler&amp; errorHandler)
369 {
370     // yes and no are used as keywords.
371     // Numbers &gt;= 1, numbers &lt;= -1, device-width and device-height are mapped to yes.
372     // Numbers in the range &lt;-1, 1&gt;, and unknown values, are mapped to no.
373 
374     if (equalLettersIgnoringASCIICase(value, &quot;yes&quot;))
375         return true;
376     if (equalLettersIgnoringASCIICase(value, &quot;no&quot;))
377         return false;
378     if (equalLettersIgnoringASCIICase(value, &quot;device-width&quot;))
379         return true;
380     if (equalLettersIgnoringASCIICase(value, &quot;device-height&quot;))
381         return true;
382     return std::abs(numericPrefix(key, value, errorHandler)) &gt;= 1;
383 }
384 
385 static ViewportFit parseViewportFitValue(StringView key, StringView value, const InternalViewportErrorHandler&amp; errorHandler)
386 {
387     if (equalLettersIgnoringASCIICase(value, &quot;auto&quot;))
388         return ViewportFit::Auto;
389     if (equalLettersIgnoringASCIICase(value, &quot;contain&quot;))
390         return ViewportFit::Contain;
391     if (equalLettersIgnoringASCIICase(value, &quot;cover&quot;))
392         return ViewportFit::Cover;
393 
394     errorHandler(UnrecognizedViewportArgumentValueError, value, key);
395 
396     return ViewportFit::Auto;
397 }
398 
399 static const char* viewportErrorMessageTemplate(ViewportErrorCode errorCode)
400 {
401     static const char* const errors[] = {
402         &quot;Viewport argument key \&quot;%replacement1\&quot; not recognized and ignored.&quot;,
403         &quot;Viewport argument value \&quot;%replacement1\&quot; for key \&quot;%replacement2\&quot; is invalid, and has been ignored.&quot;,
404         &quot;Viewport argument value \&quot;%replacement1\&quot; for key \&quot;%replacement2\&quot; was truncated to its numeric prefix.&quot;,
405         &quot;Viewport maximum-scale cannot be larger than 10.0. The maximum-scale will be set to 10.0.&quot;
406     };
407 
408     return errors[errorCode];
409 }
410 
411 static MessageLevel viewportErrorMessageLevel(ViewportErrorCode errorCode)
412 {
413     switch (errorCode) {
414     case TruncatedViewportArgumentValueError:
415         return MessageLevel::Warning;
416     case UnrecognizedViewportArgumentKeyError:
417     case UnrecognizedViewportArgumentValueError:
418     case MaximumScaleTooLargeError:
419         return MessageLevel::Error;
420     }
421 
422     ASSERT_NOT_REACHED();
423     return MessageLevel::Error;
424 }
425 
426 static String viewportErrorMessage(ViewportErrorCode errorCode, StringView replacement1, StringView replacement2)
427 {
428     String message = viewportErrorMessageTemplate(errorCode);
429     if (!replacement1.isNull())
430         message.replace(&quot;%replacement1&quot;, replacement1.toStringWithoutCopying());
431     // FIXME: This will do the wrong thing if replacement1 contains the substring &quot;%replacement2&quot;.
432     if (!replacement2.isNull())
433         message.replace(&quot;%replacement2&quot;, replacement2.toStringWithoutCopying());
434 
435     if ((errorCode == UnrecognizedViewportArgumentValueError || errorCode == TruncatedViewportArgumentValueError) &amp;&amp; replacement1.contains(&#39;;&#39;))
436         message.append(&quot; Note that &#39;;&#39; is not a separator in viewport values. The list should be comma-separated.&quot;);
437 
438     return message;
439 }
440 
441 static void reportViewportWarning(Document&amp; document, ViewportErrorCode errorCode, const String&amp; message)
442 {
443     // FIXME: Why is this null check needed? Can&#39;t addConsoleMessage deal with this?
444     if (!document.frame())
445         return;
446 
447     // FIXME: This message should be moved off the console once a solution to https://bugs.webkit.org/show_bug.cgi?id=103274 exists.
448     document.addConsoleMessage(MessageSource::Rendering, viewportErrorMessageLevel(errorCode), message);
449 }
450 
451 void setViewportFeature(ViewportArguments&amp; arguments, StringView key, StringView value, bool viewportFitEnabled, const ViewportErrorHandler&amp; errorHandler)
452 {
453     InternalViewportErrorHandler internalErrorHandler = [&amp;errorHandler] (ViewportErrorCode errorCode, StringView replacement1, StringView replacement2) {
454         errorHandler(errorCode, viewportErrorMessage(errorCode, replacement1, replacement2));
455     };
456 
457     if (equalLettersIgnoringASCIICase(key, &quot;width&quot;))
458         arguments.width = findSizeValue(key, value, internalErrorHandler, &amp;arguments.widthWasExplicit);
459     else if (equalLettersIgnoringASCIICase(key, &quot;height&quot;))
460         arguments.height = findSizeValue(key, value, internalErrorHandler);
461     else if (equalLettersIgnoringASCIICase(key, &quot;initial-scale&quot;))
462         arguments.zoom = findScaleValue(key, value, internalErrorHandler);
463     else if (equalLettersIgnoringASCIICase(key, &quot;minimum-scale&quot;))
464         arguments.minZoom = findScaleValue(key, value, internalErrorHandler);
465     else if (equalLettersIgnoringASCIICase(key, &quot;maximum-scale&quot;))
466         arguments.maxZoom = findScaleValue(key, value, internalErrorHandler);
467     else if (equalLettersIgnoringASCIICase(key, &quot;user-scalable&quot;))
468         arguments.userZoom = findBooleanValue(key, value, internalErrorHandler);
469 #if PLATFORM(IOS_FAMILY)
470     else if (equalLettersIgnoringASCIICase(key, &quot;minimal-ui&quot;)) {
471         // FIXME: Ignore silently for now. This code should eventually be removed
472         // so we start giving the warning in the web inspector as for other unimplemented keys.
473     }
474 #endif
475     else if (equalLettersIgnoringASCIICase(key, &quot;shrink-to-fit&quot;))
476         arguments.shrinkToFit = findBooleanValue(key, value, internalErrorHandler);
477     else if (equalLettersIgnoringASCIICase(key, &quot;viewport-fit&quot;) &amp;&amp; viewportFitEnabled)
478         arguments.viewportFit = parseViewportFitValue(key, value, internalErrorHandler);
479     else
480         internalErrorHandler(UnrecognizedViewportArgumentKeyError, key, { });
481 }
482 
483 void setViewportFeature(ViewportArguments&amp; arguments, Document&amp; document, StringView key, StringView value)
484 {
485     setViewportFeature(arguments, key, value, document.settings().viewportFitEnabled(), [&amp;](ViewportErrorCode errorCode, const String&amp; message) {
486         reportViewportWarning(document, errorCode, message);
487     });
488 }
489 
490 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ViewportArguments&amp; viewportArguments)
491 {
492     TextStream::IndentScope indentScope(ts);
493 
494     ts &lt;&lt; &quot;\n&quot; &lt;&lt; indent &lt;&lt; &quot;(width &quot; &lt;&lt; viewportArguments.width &lt;&lt; &quot;, minWidth &quot; &lt;&lt; viewportArguments.minWidth &lt;&lt; &quot;, maxWidth &quot; &lt;&lt; viewportArguments.maxWidth &lt;&lt; &quot;)&quot;;
495     ts &lt;&lt; &quot;\n&quot; &lt;&lt; indent &lt;&lt; &quot;(height &quot; &lt;&lt; viewportArguments.height &lt;&lt; &quot;, minHeight &quot; &lt;&lt; viewportArguments.minHeight &lt;&lt; &quot;, maxHeight &quot; &lt;&lt; viewportArguments.maxHeight &lt;&lt; &quot;)&quot;;
496     ts &lt;&lt; &quot;\n&quot; &lt;&lt; indent &lt;&lt; &quot;(zoom &quot; &lt;&lt; viewportArguments.zoom &lt;&lt; &quot;, minZoom &quot; &lt;&lt; viewportArguments.minZoom &lt;&lt; &quot;, maxZoom &quot; &lt;&lt; viewportArguments.maxZoom &lt;&lt; &quot;)&quot;;
497 
498     return ts;
499 }
500 
501 } // namespace WebCore
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
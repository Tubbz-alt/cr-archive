diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/GCAwareJITStubRoutine.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/GCAwareJITStubRoutine.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/GCAwareJITStubRoutine.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/GCAwareJITStubRoutine.h
@@ -32,10 +32,11 @@
 #include "WriteBarrier.h"
 #include <wtf/Vector.h>
 
 namespace JSC {
 
+class CallLinkInfo;
 class JITStubRoutineSet;
 
 // Use this stub routine if you know that your code might be on stack when
 // either GC or other kinds of stub deletion happen. Basicaly, if your stub
 // routine makes calls (either to JS code or to C++ code) then you should
@@ -50,10 +51,15 @@
 class GCAwareJITStubRoutine : public JITStubRoutine {
 public:
     GCAwareJITStubRoutine(const MacroAssemblerCodeRef<JITStubRoutinePtrTag>&, VM&);
     virtual ~GCAwareJITStubRoutine();
 
+    static Ref<JITStubRoutine> create(const MacroAssemblerCodeRef<JITStubRoutinePtrTag>& code, VM& vm)
+    {
+        return adoptRef(*new GCAwareJITStubRoutine(code, vm));
+    }
+
     void markRequiredObjects(SlotVisitor& visitor)
     {
         markRequiredObjectsInternal(visitor);
     }
 
@@ -74,29 +80,30 @@
 // Use this if you want to mark one additional object during GC if your stub
 // routine is known to be executing.
 class MarkingGCAwareJITStubRoutine : public GCAwareJITStubRoutine {
 public:
     MarkingGCAwareJITStubRoutine(
-        const MacroAssemblerCodeRef<JITStubRoutinePtrTag>&, VM&, const JSCell* owner, const Vector<JSCell*>&);
+        const MacroAssemblerCodeRef<JITStubRoutinePtrTag>&, VM&, const JSCell* owner, const Vector<JSCell*>&, Bag<CallLinkInfo>&&);
     virtual ~MarkingGCAwareJITStubRoutine();
 
 protected:
     void markRequiredObjectsInternal(SlotVisitor&) override;
 
 private:
     Vector<WriteBarrier<JSCell>> m_cells;
+    Bag<CallLinkInfo> m_callLinkInfos;
 };
 
 
 // The stub has exception handlers in it. So it clears itself from exception
 // handling table when it dies. It also frees space in CodeOrigin table
 // for new exception handlers to use the same DisposableCallSiteIndex.
 class GCAwareJITStubRoutineWithExceptionHandler : public MarkingGCAwareJITStubRoutine {
 public:
     typedef GCAwareJITStubRoutine Base;
 
-    GCAwareJITStubRoutineWithExceptionHandler(const MacroAssemblerCodeRef<JITStubRoutinePtrTag>&, VM&, const JSCell* owner, const Vector<JSCell*>&, CodeBlock*, DisposableCallSiteIndex);
+    GCAwareJITStubRoutineWithExceptionHandler(const MacroAssemblerCodeRef<JITStubRoutinePtrTag>&, VM&, const JSCell* owner, const Vector<JSCell*>&, Bag<CallLinkInfo>&&, CodeBlock*, DisposableCallSiteIndex);
 
     void aboutToDie() override;
     void observeZeroRefCount() override;
 
 private:
@@ -123,11 +130,11 @@
 // this function using varargs, I ended up with more code than this simple
 // way.
 
 Ref<JITStubRoutine> createJITStubRoutine(
     const MacroAssemblerCodeRef<JITStubRoutinePtrTag>&, VM&, const JSCell* owner, bool makesCalls,
-    const Vector<JSCell*>& = { },
-    CodeBlock* codeBlockForExceptionHandlers = nullptr, DisposableCallSiteIndex exceptionHandlingCallSiteIndex = DisposableCallSiteIndex());
+    const Vector<JSCell*>&, Bag<CallLinkInfo>&& callLinkInfos,
+    CodeBlock* codeBlockForExceptionHandlers, DisposableCallSiteIndex exceptionHandlingCallSiteIndex);
 
 } // namespace JSC
 
 #endif // ENABLE(JIT)

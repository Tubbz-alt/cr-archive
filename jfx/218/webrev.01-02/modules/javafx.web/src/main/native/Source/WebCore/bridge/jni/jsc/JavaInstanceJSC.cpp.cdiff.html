<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bridge/jni/jsc/JavaInstanceJSC.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JavaFieldJSC.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="JavaInstanceJSC.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bridge/jni/jsc/JavaInstanceJSC.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 63,13 ***</span>
  JavaInstance::~JavaInstance()
  {
      delete m_class;
  }
  
<span class="line-modified">! RuntimeObject* JavaInstance::newRuntimeObject(ExecState* exec)</span>
  {
<span class="line-modified">!     return JavaRuntimeObject::create(exec, exec-&gt;lexicalGlobalObject(), this);</span>
  }
  
  #define NUM_LOCAL_REFS 64
  
  void JavaInstance::virtualBegin()
<span class="line-new-header">--- 63,13 ---</span>
  JavaInstance::~JavaInstance()
  {
      delete m_class;
  }
  
<span class="line-modified">! RuntimeObject* JavaInstance::newRuntimeObject(JSGlobalObject* globalObject)</span>
  {
<span class="line-modified">!     return JavaRuntimeObject::create(globalObject, this);</span>
  }
  
  #define NUM_LOCAL_REFS 64
  
  void JavaInstance::virtualBegin()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 89,15 ***</span>
          m_class = new JavaClass(m_instance-&gt;instance(), rootObject(), acc);
      }
      return m_class;
  }
  
<span class="line-modified">! JSValue JavaInstance::stringValue(ExecState* exec) const</span>
  {
<span class="line-modified">!     JSLockHolder lock(exec);</span>
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      jobject obj = m_instance-&gt;instance();
      // Since m_instance-&gt;instance() is WeakGlobalRef, creating a localref to safeguard instance() from GC
      JLObject jlinstance(obj, true);
<span class="line-new-header">--- 89,15 ---</span>
          m_class = new JavaClass(m_instance-&gt;instance(), rootObject(), acc);
      }
      return m_class;
  }
  
<span class="line-modified">! JSValue JavaInstance::stringValue(JSGlobalObject* globalObject) const</span>
  {
<span class="line-modified">!     JSLockHolder lock(globalObject);</span>
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      jobject obj = m_instance-&gt;instance();
      // Since m_instance-&gt;instance() is WeakGlobalRef, creating a localref to safeguard instance() from GC
      JLObject jlinstance(obj, true);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 116,14 ***</span>
                                      NULL, result, acc);
      if (ex != 0) {
          // FIXME duplicates code in JavaInstance::invokeMethod
          JSValue exceptionDescription
              = (JavaInstance::create(ex, rootObject(), accessControlContext())
<span class="line-modified">!                -&gt;createRuntimeObject(exec));</span>
<span class="line-modified">!         throwException(exec, scope, createError(exec,</span>
<span class="line-modified">!                                 (exceptionDescription.toString(exec)</span>
<span class="line-modified">!                                     -&gt;value(exec))));</span>
          return jsUndefined();
      }
  
      jstring stringValue = (jstring) result.l;
      JNIEnv* env = getJNIEnv();
<span class="line-new-header">--- 116,14 ---</span>
                                      NULL, result, acc);
      if (ex != 0) {
          // FIXME duplicates code in JavaInstance::invokeMethod
          JSValue exceptionDescription
              = (JavaInstance::create(ex, rootObject(), accessControlContext())
<span class="line-modified">!                -&gt;createRuntimeObject(globalObject));</span>
<span class="line-modified">!         throwException(globalObject, scope, createError(globalObject,</span>
<span class="line-modified">!                                 (exceptionDescription.toString(globalObject)</span>
<span class="line-modified">!                                     -&gt;value(globalObject))));</span>
          return jsUndefined();
      }
  
      jstring stringValue = (jstring) result.l;
      JNIEnv* env = getJNIEnv();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 158,11 ***</span>
  
      return jsNumber(callJNIMethod&lt;jdouble&gt;(obj, &quot;doubleValue&quot;, &quot;()D&quot;));
  }
  
  
<span class="line-modified">! JSValue JavaInstance::numberValue(ExecState*) const</span>
  {
      jobject obj = m_instance-&gt;instance();
      // Since obj is WeakGlobalRef, creating a localref to safeguard instance() from GC
      JLObject jlinstance(obj, true);
  
<span class="line-new-header">--- 158,11 ---</span>
  
      return jsNumber(callJNIMethod&lt;jdouble&gt;(obj, &quot;doubleValue&quot;, &quot;()D&quot;));
  }
  
  
<span class="line-modified">! JSValue JavaInstance::numberValue(JSGlobalObject*) const</span>
  {
      jobject obj = m_instance-&gt;instance();
      // Since obj is WeakGlobalRef, creating a localref to safeguard instance() from GC
      JLObject jlinstance(obj, true);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 199,18 ***</span>
  
  class JavaRuntimeMethod : public RuntimeMethod {
  public:
      typedef RuntimeMethod Base;
  
<span class="line-modified">!     static JavaRuntimeMethod* create(ExecState* exec, JSGlobalObject* globalObject, const String&amp; name, Bindings::Method *method)</span>
      {
          VM&amp; vm = globalObject-&gt;vm();
          // FIXME: deprecatedGetDOMStructure uses the prototype off of the wrong global object
          // We need to pass in the right global object for &quot;i&quot;.
<span class="line-modified">!         Structure* domStructure = WebCore::deprecatedGetDOMStructure&lt;JavaRuntimeMethod&gt;(exec);</span>
<span class="line-modified">!         JavaRuntimeMethod* _method = new (NotNull, allocateCell&lt;JavaRuntimeMethod&gt;(vm.heap)) JavaRuntimeMethod(globalObject, domStructure, method);</span>
<span class="line-modified">!         _method-&gt;finishCreation(exec-&gt;vm(), name);</span>
          return _method;
      }
  
      static Structure* createStructure(VM&amp; globalData, JSGlobalObject* globalObject, JSValue prototype)
      {
<span class="line-new-header">--- 199,18 ---</span>
  
  class JavaRuntimeMethod : public RuntimeMethod {
  public:
      typedef RuntimeMethod Base;
  
<span class="line-modified">!     static JavaRuntimeMethod* create(JSGlobalObject* globalObject, const String&amp; name, Bindings::Method *method)</span>
      {
          VM&amp; vm = globalObject-&gt;vm();
          // FIXME: deprecatedGetDOMStructure uses the prototype off of the wrong global object
          // We need to pass in the right global object for &quot;i&quot;.
<span class="line-modified">!         Structure* domStructure = WebCore::deprecatedGetDOMStructure&lt;JavaRuntimeMethod&gt;(globalObject);</span>
<span class="line-modified">!         JavaRuntimeMethod* _method = new (NotNull, allocateCell&lt;JavaRuntimeMethod&gt;(vm.heap)) JavaRuntimeMethod(vm, domStructure, method);</span>
<span class="line-modified">!         _method-&gt;finishCreation(globalObject-&gt;vm(), name);</span>
          return _method;
      }
  
      static Structure* createStructure(VM&amp; globalData, JSGlobalObject* globalObject, JSValue prototype)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 218,12 ***</span>
      }
  
      static const ClassInfo s_info;
  
  private:
<span class="line-modified">!     JavaRuntimeMethod(JSGlobalObject* globalObject, Structure* structure, Bindings::Method *method)</span>
<span class="line-modified">!         : RuntimeMethod(globalObject, structure, method)</span>
      {
      }
  
      void finishCreation(VM&amp; globalData, const String&amp; name)
      {
<span class="line-new-header">--- 218,12 ---</span>
      }
  
      static const ClassInfo s_info;
  
  private:
<span class="line-modified">!     JavaRuntimeMethod(VM&amp; vm, Structure* structure, Bindings::Method *method)</span>
<span class="line-modified">!         : RuntimeMethod(vm, structure, method)</span>
      {
      }
  
      void finishCreation(VM&amp; globalData, const String&amp; name)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 232,26 ***</span>
      }
  };
  
  const ClassInfo JavaRuntimeMethod::s_info = { &quot;JavaRuntimeMethod&quot;, &amp;RuntimeMethod::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JavaRuntimeMethod) };
  
<span class="line-modified">! JSValue JavaInstance::getMethod(ExecState* exec, PropertyName propertyName)</span>
  {
      JavaClass* aClass = static_cast&lt;JavaClass*&gt;(getClass());
      Method *method = aClass-&gt;methodNamed(propertyName, this);
<span class="line-modified">!     return JavaRuntimeMethod::create(exec, exec-&gt;lexicalGlobalObject(), propertyName.publicName(), method);</span>
  }
  
<span class="line-modified">! JSValue JavaInstance::invokeMethod(ExecState* exec, RuntimeMethod* runtimeMethod)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     ASSERT(exec-&gt;vm().apiLock().currentThreadIsHoldingLock());</span>
  
      if (!asObject(runtimeMethod)-&gt;inherits(vm, &amp;JavaRuntimeMethod::s_info))
<span class="line-modified">!         throwException(exec, scope, createTypeError(exec, &quot;Attempt to invoke non-Java method on Java object.&quot;));</span>
  
  #if 0
      const MethodList&amp; methodList = *runtimeMethod-&gt;methods();
      size_t numMethods = methodList.size();
  
<span class="line-new-header">--- 232,26 ---</span>
      }
  };
  
  const ClassInfo JavaRuntimeMethod::s_info = { &quot;JavaRuntimeMethod&quot;, &amp;RuntimeMethod::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JavaRuntimeMethod) };
  
<span class="line-modified">! JSValue JavaInstance::getMethod(JSGlobalObject* globalObject, PropertyName propertyName)</span>
  {
      JavaClass* aClass = static_cast&lt;JavaClass*&gt;(getClass());
      Method *method = aClass-&gt;methodNamed(propertyName, this);
<span class="line-modified">!     return JavaRuntimeMethod::create(globalObject, propertyName.publicName(), method);</span>
  }
  
<span class="line-modified">! JSValue JavaInstance::invokeMethod(JSGlobalObject* globalObject, CallFrame* callFrame, RuntimeMethod* runtimeMethod)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     ASSERT(globalObject-&gt;vm().apiLock().currentThreadIsHoldingLock());</span>
  
      if (!asObject(runtimeMethod)-&gt;inherits(vm, &amp;JavaRuntimeMethod::s_info))
<span class="line-modified">!         throwException(globalObject, scope, createTypeError(globalObject, &quot;Attempt to invoke non-Java method on Java object.&quot;));</span>
  
  #if 0
      const MethodList&amp; methodList = *runtimeMethod-&gt;methods();
      size_t numMethods = methodList.size();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 293,35 ***</span>
          return jsUndefined();
      }
  
      LOG(LiveConnect, &quot;JavaInstance::invokeMethod call %s %s on %p&quot;, String(jMethod-&gt;name().impl()).utf8().data(), jMethod-&gt;signature(), m_instance-&gt;instance());
  
<span class="line-modified">!     const int count = exec-&gt;argumentCount();</span>
      if (jMethod-&gt;numParameters() != count) {
          LOG(LiveConnect, &quot;JavaInstance::invokeMethod unable to find an appropriate method with specified signature&quot;);
          return jsUndefined();
      }
  
      Vector&lt;jobject&gt; jArgs(count);
  
      for (int i = 0; i &lt; count; i++) {
          CString javaClassName = jMethod-&gt;parameterAt(i).utf8();
          JavaType jtype = javaTypeFromClassName(javaClassName.data());
<span class="line-modified">!         jvalue jarg = convertValueToJValue(exec, m_rootObject.get(),</span>
<span class="line-modified">!             exec-&gt;argument(i), jtype, javaClassName.data());</span>
          jArgs[i] = jvalueToJObject(jarg, jtype);
<span class="line-modified">!         LOG(LiveConnect, &quot;JavaInstance::invokeMethod arg[%d] = %s&quot;, i, exec-&gt;argument(i).toString(exec)-&gt;value(exec).ascii().data());</span>
      }
  
      jvalue result;
  
      // Try to use the JNI abstraction first, otherwise fall back to
      // normal JNI.  The JNI dispatch abstraction allows the Java plugin
      // to dispatch the call on the appropriate internal VM thread.
      RootObject* rootObject = this-&gt;rootObject();
      if (jMethod-&gt;isStatic())
<span class="line-modified">!         return throwException(exec, scope, createTypeError(exec, &quot;invoking static method&quot;));</span>
      if (!rootObject)
          return jsUndefined();
  
      // bool handled = false;
      if (rootObject-&gt;nativeHandle()) {
<span class="line-new-header">--- 293,35 ---</span>
          return jsUndefined();
      }
  
      LOG(LiveConnect, &quot;JavaInstance::invokeMethod call %s %s on %p&quot;, String(jMethod-&gt;name().impl()).utf8().data(), jMethod-&gt;signature(), m_instance-&gt;instance());
  
<span class="line-modified">!     const int count = callFrame-&gt;argumentCount();</span>
      if (jMethod-&gt;numParameters() != count) {
          LOG(LiveConnect, &quot;JavaInstance::invokeMethod unable to find an appropriate method with specified signature&quot;);
          return jsUndefined();
      }
  
      Vector&lt;jobject&gt; jArgs(count);
  
      for (int i = 0; i &lt; count; i++) {
          CString javaClassName = jMethod-&gt;parameterAt(i).utf8();
          JavaType jtype = javaTypeFromClassName(javaClassName.data());
<span class="line-modified">!         jvalue jarg = convertValueToJValue(globalObject, m_rootObject.get(),</span>
<span class="line-modified">!             callFrame-&gt;argument(i), jtype, javaClassName.data());</span>
          jArgs[i] = jvalueToJObject(jarg, jtype);
<span class="line-modified">!         LOG(LiveConnect, &quot;JavaInstance::invokeMethod arg[%d] = %s&quot;, i, globalObject-&gt;argument(i).toString(globalObject)-&gt;value(globalObject).ascii().data());</span>
      }
  
      jvalue result;
  
      // Try to use the JNI abstraction first, otherwise fall back to
      // normal JNI.  The JNI dispatch abstraction allows the Java plugin
      // to dispatch the call on the appropriate internal VM thread.
      RootObject* rootObject = this-&gt;rootObject();
      if (jMethod-&gt;isStatic())
<span class="line-modified">!         return throwException(globalObject, scope, createTypeError(globalObject, &quot;invoking static method&quot;));</span>
      if (!rootObject)
          return jsUndefined();
  
      // bool handled = false;
      if (rootObject-&gt;nativeHandle()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 335,20 ***</span>
          }
  
          // const char *callingURL = 0; // FIXME, need to propagate calling URL to Java
          jmethodID methodId = getMethodID(obj, jMethod-&gt;name().utf8().data(), jMethod-&gt;signature());
  
<span class="line-modified">!         jthrowable ex = dispatchJNICall(exec-&gt;argumentCount(), rootObject,</span>
                                          obj, jMethod-&gt;isStatic(),
                                          jMethod-&gt;returnType(), methodId,
                                          jArgs.data(), result,
                                          accessControlContext());
          if (ex != NULL) {
              JSValue exceptionDescription
                = (JavaInstance::create(ex, rootObject, accessControlContext())
<span class="line-modified">!                  -&gt;createRuntimeObject(exec));</span>
<span class="line-modified">!             throwException(exec, scope, exceptionDescription);</span>
              return jsUndefined();
          }
      }
  
      JSValue resultValue;
<span class="line-new-header">--- 335,20 ---</span>
          }
  
          // const char *callingURL = 0; // FIXME, need to propagate calling URL to Java
          jmethodID methodId = getMethodID(obj, jMethod-&gt;name().utf8().data(), jMethod-&gt;signature());
  
<span class="line-modified">!         jthrowable ex = dispatchJNICall(callFrame-&gt;argumentCount(), rootObject,</span>
                                          obj, jMethod-&gt;isStatic(),
                                          jMethod-&gt;returnType(), methodId,
                                          jArgs.data(), result,
                                          accessControlContext());
          if (ex != NULL) {
              JSValue exceptionDescription
                = (JavaInstance::create(ex, rootObject, accessControlContext())
<span class="line-modified">!                  -&gt;createRuntimeObject(globalObject));</span>
<span class="line-modified">!             throwException(globalObject, scope, exceptionDescription);</span>
              return jsUndefined();
          }
      }
  
      JSValue resultValue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 365,11 ***</span>
      // Since we can&#39;t convert java.lang.Character to any JS primitive, we have
      // to treat it as JS foreign object.
      case JavaTypeChar:
          {
              JNIEnv* env = getJNIEnv();
<span class="line-modified">!             resultValue = toJS(exec, WebCore::Java_Object_to_JSValue(env, toRef(exec), rootObject, result.l, accessControlContext()));</span>
          }
          break;
  
      case JavaTypeBoolean:
          {
<span class="line-new-header">--- 365,11 ---</span>
      // Since we can&#39;t convert java.lang.Character to any JS primitive, we have
      // to treat it as JS foreign object.
      case JavaTypeChar:
          {
              JNIEnv* env = getJNIEnv();
<span class="line-modified">!             resultValue = toJS(globalObject, WebCore::Java_Object_to_JSValue(env, toRef(globalObject), rootObject, result.l, accessControlContext()));</span>
          }
          break;
  
      case JavaTypeBoolean:
          {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 421,20 ***</span>
      }
  
      return resultValue;
  }
  
<span class="line-modified">! JSValue JavaInstance::defaultValue(ExecState* exec, PreferredPrimitiveType hint) const</span>
  {
      if (hint == PreferString)
<span class="line-modified">!         return stringValue(exec);</span>
      if (hint == PreferNumber)
<span class="line-modified">!         return numberValue(exec);</span>
  
      JavaClass* aClass = static_cast&lt;JavaClass*&gt;(getClass());
      if (aClass-&gt;isStringClass())
<span class="line-modified">!         return stringValue(exec);</span>
  
      jobject obj = m_instance-&gt;instance();
      // Since m_instance-&gt;instance() is WeakGlobalRef, creating a localref to safeguard instance() from GC
      JLObject jlinstance(obj, true);
  
<span class="line-new-header">--- 421,20 ---</span>
      }
  
      return resultValue;
  }
  
<span class="line-modified">! JSValue JavaInstance::defaultValue(JSGlobalObject* globalObject, PreferredPrimitiveType hint) const</span>
  {
      if (hint == PreferString)
<span class="line-modified">!         return stringValue(globalObject);</span>
      if (hint == PreferNumber)
<span class="line-modified">!         return numberValue(globalObject);</span>
  
      JavaClass* aClass = static_cast&lt;JavaClass*&gt;(getClass());
      if (aClass-&gt;isStringClass())
<span class="line-modified">!         return stringValue(globalObject);</span>
  
      jobject obj = m_instance-&gt;instance();
      // Since m_instance-&gt;instance() is WeakGlobalRef, creating a localref to safeguard instance() from GC
      JLObject jlinstance(obj, true);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 445,14 ***</span>
  
      if (aClass-&gt;isNumberClass())
          return numberValueForNumber(m_instance-&gt;instance());
      if (aClass-&gt;isBooleanClass())
          return booleanValue();
<span class="line-modified">!     return valueOf(exec);</span>
  }
  
<span class="line-modified">! JSValue JavaInstance::valueOf(ExecState* exec) const</span>
  {
<span class="line-modified">!     return stringValue(exec);</span>
  }
  
  #endif // ENABLE(JAVA_BRIDGE)
<span class="line-new-header">--- 445,14 ---</span>
  
      if (aClass-&gt;isNumberClass())
          return numberValueForNumber(m_instance-&gt;instance());
      if (aClass-&gt;isBooleanClass())
          return booleanValue();
<span class="line-modified">!     return valueOf(globalObject);</span>
  }
  
<span class="line-modified">! JSValue JavaInstance::valueOf(JSGlobalObject* globalObject) const</span>
  {
<span class="line-modified">!     return stringValue(globalObject);</span>
  }
  
  #endif // ENABLE(JAVA_BRIDGE)
</pre>
<center><a href="JavaFieldJSC.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="JavaInstanceJSC.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
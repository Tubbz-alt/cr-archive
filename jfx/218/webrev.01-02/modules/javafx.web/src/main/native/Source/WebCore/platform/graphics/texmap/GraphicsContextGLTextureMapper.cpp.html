<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/GraphicsContextGLTextureMapper.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2010 Apple Inc. All rights reserved.
  3  * Copyright (C) 2010 Google Inc. All rights reserved.
  4  * Copyright (C) 2011 Igalia S.L.
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above copyright
 12  *    notice, this list of conditions and the following disclaimer in the
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 
 30 #if ENABLE(GRAPHICS_CONTEXT_GL) &amp;&amp; USE(TEXTURE_MAPPER)
 31 #include &quot;GraphicsContextGLOpenGL.h&quot;
 32 
 33 #include &quot;GraphicsContextGLOpenGLPrivate.h&quot;
 34 #include &quot;TextureMapperGC3DPlatformLayer.h&quot;
 35 #include &lt;ANGLE/ShaderLang.h&gt;
 36 #include &lt;wtf/Deque.h&gt;
 37 #include &lt;wtf/NeverDestroyed.h&gt;
 38 
 39 #if USE(ANGLE)
 40 #define EGL_EGL_PROTOTYPES 0
 41 // Skip the inclusion of ANGLE&#39;s explicit context entry points for now.
 42 #define GL_ANGLE_explicit_context
 43 #define GL_ANGLE_explicit_context_gles1
 44 typedef void* GLeglContext;
 45 #include &lt;ANGLE/egl.h&gt;
 46 #include &lt;ANGLE/eglext.h&gt;
 47 #include &lt;ANGLE/eglext_angle.h&gt;
 48 #include &lt;ANGLE/entry_points_egl.h&gt;
 49 #include &lt;ANGLE/entry_points_gles_2_0_autogen.h&gt;
 50 #include &lt;ANGLE/entry_points_gles_ext_autogen.h&gt;
 51 #include &lt;ANGLE/gl2ext.h&gt;
 52 #include &lt;ANGLE/gl2ext_angle.h&gt;
 53 #if defined(Above)
 54 #undef Above
 55 #endif
 56 #if defined(Below)
 57 #undef Below
 58 #endif
 59 #if defined(None)
 60 #undef None
 61 #endif
 62 #elif USE(LIBEPOXY)
 63 #include &lt;epoxy/gl.h&gt;
 64 #elif !USE(OPENGL_ES)
 65 #include &quot;OpenGLShims.h&quot;
 66 #endif
 67 
 68 #if USE(ANGLE)
 69 #include &quot;ExtensionsGLANGLE.h&quot;
 70 #elif USE(OPENGL_ES)
 71 #include &quot;ExtensionsGLOpenGLES.h&quot;
 72 #else
 73 #include &quot;ExtensionsGLOpenGL.h&quot;
 74 #endif
 75 
 76 #if USE(NICOSIA)
 77 #if USE(ANGLE)
 78 #include &quot;NicosiaGC3DANGLELayer.h&quot;
 79 #else
 80 #include &quot;NicosiaGC3DLayer.h&quot;
 81 #endif
 82 #endif
 83 
 84 namespace WebCore {
 85 
 86 static const size_t MaxActiveContexts = 16;
 87 static Deque&lt;GraphicsContextGLOpenGL*, MaxActiveContexts&gt;&amp; activeContexts()
 88 {
 89     static NeverDestroyed&lt;Deque&lt;GraphicsContextGLOpenGL*, MaxActiveContexts&gt;&gt; s_activeContexts;
 90     return s_activeContexts;
 91 }
 92 
 93 RefPtr&lt;GraphicsContextGLOpenGL&gt; GraphicsContextGLOpenGL::create(GraphicsContextGLAttributes attributes, HostWindow* hostWindow, GraphicsContextGLOpenGL::Destination destination)
 94 {
 95     // This implementation doesn&#39;t currently support rendering directly to the HostWindow.
 96     if (destination == Destination::DirectlyToHostWindow)
 97         return nullptr;
 98 
 99     static bool initialized = false;
100     static bool success = true;
101     if (!initialized) {
102 #if !USE(OPENGL_ES) &amp;&amp; !USE(LIBEPOXY) &amp;&amp; !USE(ANGLE)
103         success = initializeOpenGLShims();
104 #endif
105         initialized = true;
106     }
107     if (!success)
108         return nullptr;
109 
110     auto&amp; contexts = activeContexts();
111     if (contexts.size() &gt;= MaxActiveContexts)
112         contexts.first()-&gt;recycleContext();
113 
114     // Calling recycleContext() above should have lead to the graphics context being
115     // destroyed and thus removed from the active contexts list.
116     if (contexts.size() &gt;= MaxActiveContexts)
117         return nullptr;
118 
119     // Create the GraphicsContextGLOpenGL object first in order to establist a current context on this thread.
120     auto context = adoptRef(new GraphicsContextGLOpenGL(attributes, hostWindow, destination));
121 
122 #if USE(LIBEPOXY) &amp;&amp; USE(OPENGL_ES)
123     // Bail if GLES3 was requested but cannot be provided.
124     if (attributes.isWebGL2 &amp;&amp; !epoxy_is_desktop_gl() &amp;&amp; epoxy_gl_version() &lt; 30)
125         return nullptr;
126 #endif
127 
128     contexts.append(context.get());
129     return context;
130 }
131 
132 #if USE(ANGLE)
133 GraphicsContextGLOpenGL::GraphicsContextGLOpenGL(GraphicsContextGLAttributes attributes, HostWindow*, GraphicsContextGLOpenGL::Destination destination, GraphicsContextGLOpenGL* sharedContext)
134     : GraphicsContextGL(attributes, destination, sharedContext)
135 {
136     ASSERT_UNUSED(sharedContext, !sharedContext);
137 #if USE(NICOSIA)
138     m_nicosiaLayer = WTF::makeUnique&lt;Nicosia::GC3DANGLELayer&gt;(*this, destination);
139 #else
140     m_texmapLayer = WTF::makeUnique&lt;TextureMapperGC3DPlatformLayer&gt;(*this, destination);
141 #endif
142     makeContextCurrent();
143 
144     validateAttributes();
145     attributes = contextAttributes(); // They may have changed during validation.
146 
147     if (destination == Destination::Offscreen) {
148         // Create a texture to render into.
149         gl::GenTextures(1, &amp;m_texture);
150         gl::BindTexture(GL_TEXTURE_RECTANGLE_ANGLE, m_texture);
151         gl::TexParameterf(GL_TEXTURE_RECTANGLE_ANGLE, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
152         gl::TexParameterf(GL_TEXTURE_RECTANGLE_ANGLE, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
153         gl::TexParameteri(GL_TEXTURE_RECTANGLE_ANGLE, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
154         gl::TexParameteri(GL_TEXTURE_RECTANGLE_ANGLE, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
155         gl::BindTexture(GL_TEXTURE_RECTANGLE_ANGLE, 0);
156 
157         // Create an FBO.
158         gl::GenFramebuffers(1, &amp;m_fbo);
159         gl::BindFramebuffer(GL_FRAMEBUFFER, m_fbo);
160 
161 #if USE(COORDINATED_GRAPHICS)
162         gl::GenTextures(1, &amp;m_compositorTexture);
163         gl::BindTexture(GL_TEXTURE_RECTANGLE_ANGLE, m_compositorTexture);
164         gl::TexParameterf(GL_TEXTURE_RECTANGLE_ANGLE, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
165         gl::TexParameterf(GL_TEXTURE_RECTANGLE_ANGLE, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
166         gl::TexParameteri(GL_TEXTURE_RECTANGLE_ANGLE, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
167         gl::TexParameteri(GL_TEXTURE_RECTANGLE_ANGLE, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
168 
169         gl::GenTextures(1, &amp;m_intermediateTexture);
170         gl::BindTexture(GL_TEXTURE_RECTANGLE_ANGLE, m_intermediateTexture);
171         gl::TexParameterf(GL_TEXTURE_RECTANGLE_ANGLE, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
172         gl::TexParameterf(GL_TEXTURE_RECTANGLE_ANGLE, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
173         gl::TexParameteri(GL_TEXTURE_RECTANGLE_ANGLE, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
174         gl::TexParameteri(GL_TEXTURE_RECTANGLE_ANGLE, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
175 
176         gl::BindTexture(GL_TEXTURE_RECTANGLE_ANGLE, 0);
177 #endif
178 
179         // Create a multisample FBO.
180         if (attributes.antialias) {
181             gl::GenFramebuffers(1, &amp;m_multisampleFBO);
182             gl::BindFramebuffer(GL_FRAMEBUFFER, m_multisampleFBO);
183             m_state.boundFBO = m_multisampleFBO;
184             gl::GenRenderbuffers(1, &amp;m_multisampleColorBuffer);
185             if (attributes.stencil || attributes.depth)
186                 gl::GenRenderbuffers(1, &amp;m_multisampleDepthStencilBuffer);
187         } else {
188             // Bind canvas FBO.
189             gl::BindFramebuffer(GL_FRAMEBUFFER, m_fbo);
190             m_state.boundFBO = m_fbo;
191 #if USE(OPENGL_ES)
192             if (attributes.depth)
193                 gl::GenRenderbuffers(1, &amp;m_depthBuffer);
194             if (attributes.stencil)
195                 gl::GenRenderbuffers(1, &amp;m_stencilBuffer);
196 #endif
197             if (attributes.stencil || attributes.depth)
198                 gl::GenRenderbuffers(1, &amp;m_depthStencilBuffer);
199         }
200     }
201 
202     gl::ClearColor(0, 0, 0, 0);
203 }
204 #else
205 GraphicsContextGLOpenGL::GraphicsContextGLOpenGL(GraphicsContextGLAttributes attributes, HostWindow*, GraphicsContextGLOpenGL::Destination destination, GraphicsContextGLOpenGL* sharedContext)
206     : GraphicsContextGL(attributes, destination, sharedContext)
207 {
208     ASSERT_UNUSED(sharedContext, !sharedContext);
209 #if USE(NICOSIA)
210     m_nicosiaLayer = makeUnique&lt;Nicosia::GC3DLayer&gt;(*this, destination);
211 #else
212     m_texmapLayer = makeUnique&lt;TextureMapperGC3DPlatformLayer&gt;(*this, destination);
213 #endif
214 
215     makeContextCurrent();
216 
217     validateAttributes();
218     attributes = contextAttributes(); // They may have changed during validation.
219 
220     if (destination == Destination::Offscreen) {
221         // Create a texture to render into.
222         ::glGenTextures(1, &amp;m_texture);
223         ::glBindTexture(GL_TEXTURE_2D, m_texture);
224         ::glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
225         ::glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
226         ::glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
227         ::glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
228         ::glBindTexture(GL_TEXTURE_2D, 0);
229 
230         // Create an FBO.
231         ::glGenFramebuffers(1, &amp;m_fbo);
232         ::glBindFramebuffer(GL_FRAMEBUFFER, m_fbo);
233 
234 #if USE(COORDINATED_GRAPHICS)
235         ::glGenTextures(1, &amp;m_compositorTexture);
236         ::glBindTexture(GL_TEXTURE_2D, m_compositorTexture);
237         ::glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
238         ::glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
239         ::glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
240         ::glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
241 
242         ::glGenTextures(1, &amp;m_intermediateTexture);
243         ::glBindTexture(GL_TEXTURE_2D, m_intermediateTexture);
244         ::glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
245         ::glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
246         ::glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
247         ::glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
248 
249         ::glBindTexture(GL_TEXTURE_2D, 0);
250 #endif
251 
252         // Create a multisample FBO.
253         if (attributes.antialias) {
254             ::glGenFramebuffers(1, &amp;m_multisampleFBO);
255             ::glBindFramebuffer(GL_FRAMEBUFFER, m_multisampleFBO);
256             m_state.boundFBO = m_multisampleFBO;
257             ::glGenRenderbuffers(1, &amp;m_multisampleColorBuffer);
258             if (attributes.stencil || attributes.depth)
259                 ::glGenRenderbuffers(1, &amp;m_multisampleDepthStencilBuffer);
260         } else {
261             // Bind canvas FBO.
262             glBindFramebuffer(GraphicsContextGLOpenGL::FRAMEBUFFER, m_fbo);
263             m_state.boundFBO = m_fbo;
264 #if USE(OPENGL_ES)
265             if (attributes.depth)
266                 glGenRenderbuffers(1, &amp;m_depthBuffer);
267             if (attributes.stencil)
268                 glGenRenderbuffers(1, &amp;m_stencilBuffer);
269 #endif
270             if (attributes.stencil || attributes.depth)
271                 glGenRenderbuffers(1, &amp;m_depthStencilBuffer);
272         }
273     }
274 
275 #if !USE(OPENGL_ES)
276     ::glEnable(GL_VERTEX_PROGRAM_POINT_SIZE);
277 
278     if (GLContext::current()-&gt;version() &gt;= 320) {
279         m_usingCoreProfile = true;
280 
281         // From version 3.2 on we use the OpenGL Core profile, so request that ouput to the shader compiler.
282         // OpenGL version 3.2 uses GLSL version 1.50.
283         m_compiler = ANGLEWebKitBridge(SH_GLSL_150_CORE_OUTPUT);
284 
285         // From version 3.2 on we use the OpenGL Core profile, and we need a VAO for rendering.
286         // A VAO could be created and bound by each component using GL rendering (TextureMapper, WebGL, etc). This is
287         // a simpler solution: the first GraphicsContextGLOpenGL created on a GLContext will create and bind a VAO for that context.
288         GCGLint currentVAO = 0;
289         getIntegerv(GraphicsContextGLOpenGL::VERTEX_ARRAY_BINDING, &amp;currentVAO);
290         if (!currentVAO) {
291             m_vao = createVertexArray();
292             bindVertexArray(m_vao);
293         }
294     } else {
295         // For lower versions request the compatibility output to the shader compiler.
296         m_compiler = ANGLEWebKitBridge(SH_GLSL_COMPATIBILITY_OUTPUT);
297 
298         // GL_POINT_SPRITE is needed in lower versions.
299         ::glEnable(GL_POINT_SPRITE);
300     }
301 #else
302     // Adjust the shader specification depending on whether GLES3 (i.e. WebGL2 support) was requested.
303     m_compiler = ANGLEWebKitBridge(SH_ESSL_OUTPUT, attributes.isWebGL2 ? SH_WEBGL2_SPEC : SH_WEBGL_SPEC);
304 #endif
305 
306     // ANGLE initialization.
307     ShBuiltInResources ANGLEResources;
308     sh::InitBuiltInResources(&amp;ANGLEResources);
309 
310     getIntegerv(GraphicsContextGLOpenGL::MAX_VERTEX_ATTRIBS, &amp;ANGLEResources.MaxVertexAttribs);
311     getIntegerv(GraphicsContextGLOpenGL::MAX_VERTEX_UNIFORM_VECTORS, &amp;ANGLEResources.MaxVertexUniformVectors);
312     getIntegerv(GraphicsContextGLOpenGL::MAX_VARYING_VECTORS, &amp;ANGLEResources.MaxVaryingVectors);
313     getIntegerv(GraphicsContextGLOpenGL::MAX_VERTEX_TEXTURE_IMAGE_UNITS, &amp;ANGLEResources.MaxVertexTextureImageUnits);
314     getIntegerv(GraphicsContextGLOpenGL::MAX_COMBINED_TEXTURE_IMAGE_UNITS, &amp;ANGLEResources.MaxCombinedTextureImageUnits);
315     getIntegerv(GraphicsContextGLOpenGL::MAX_TEXTURE_IMAGE_UNITS, &amp;ANGLEResources.MaxTextureImageUnits);
316     getIntegerv(GraphicsContextGLOpenGL::MAX_FRAGMENT_UNIFORM_VECTORS, &amp;ANGLEResources.MaxFragmentUniformVectors);
317 
318     // Always set to 1 for OpenGL ES.
319     ANGLEResources.MaxDrawBuffers = 1;
320 
321     GCGLint range[2], precision;
322     getShaderPrecisionFormat(GraphicsContextGLOpenGL::FRAGMENT_SHADER, GraphicsContextGLOpenGL::HIGH_FLOAT, range, &amp;precision);
323     ANGLEResources.FragmentPrecisionHigh = (range[0] || range[1] || precision);
324 
325     m_compiler.setResources(ANGLEResources);
326 
327     ::glClearColor(0, 0, 0, 0);
328 }
329 #endif
330 
331 #if USE(ANGLE)
332 GraphicsContextGLOpenGL::~GraphicsContextGLOpenGL()
333 {
334     makeContextCurrent();
335     if (m_texture)
336         gl::DeleteTextures(1, &amp;m_texture);
337 #if USE(COORDINATED_GRAPHICS)
338     if (m_compositorTexture)
339         gl::DeleteTextures(1, &amp;m_compositorTexture);
340 #endif
341 
342     auto attributes = contextAttributes();
343 
344     if (attributes.antialias) {
345         gl::DeleteRenderbuffers(1, &amp;m_multisampleColorBuffer);
346         if (attributes.stencil || attributes.depth)
347             gl::DeleteRenderbuffers(1, &amp;m_multisampleDepthStencilBuffer);
348         gl::DeleteFramebuffers(1, &amp;m_multisampleFBO);
349     } else if (attributes.stencil || attributes.depth) {
350 #if USE(OPENGL_ES)
351         if (m_depthBuffer)
352             glDeleteRenderbuffers(1, &amp;m_depthBuffer);
353 
354         if (m_stencilBuffer)
355             glDeleteRenderbuffers(1, &amp;m_stencilBuffer);
356 #endif
357         if (m_depthStencilBuffer)
358             gl::DeleteRenderbuffers(1, &amp;m_depthStencilBuffer);
359     }
360     gl::DeleteFramebuffers(1, &amp;m_fbo);
361 #if USE(COORDINATED_GRAPHICS)
362     gl::DeleteTextures(1, &amp;m_intermediateTexture);
363 #endif
364 
365 #if USE(CAIRO)
366     if (m_vao)
367         deleteVertexArray(m_vao);
368 #endif
369 
370     auto* activeContext = activeContexts().takeLast([this](auto* it) {
371         return it == this;
372     });
373     ASSERT_UNUSED(activeContext, !!activeContext);
374 }
375 #else
376 GraphicsContextGLOpenGL::~GraphicsContextGLOpenGL()
377 {
378     makeContextCurrent();
379     if (m_texture)
380         ::glDeleteTextures(1, &amp;m_texture);
381 #if USE(COORDINATED_GRAPHICS)
382     if (m_compositorTexture)
383         ::glDeleteTextures(1, &amp;m_compositorTexture);
384 #endif
385 
386     auto attributes = contextAttributes();
387 
388     if (attributes.antialias) {
389         ::glDeleteRenderbuffers(1, &amp;m_multisampleColorBuffer);
390         if (attributes.stencil || attributes.depth)
391             ::glDeleteRenderbuffers(1, &amp;m_multisampleDepthStencilBuffer);
392         ::glDeleteFramebuffers(1, &amp;m_multisampleFBO);
393     } else if (attributes.stencil || attributes.depth) {
394 #if USE(OPENGL_ES)
395         if (m_depthBuffer)
396             glDeleteRenderbuffers(1, &amp;m_depthBuffer);
397 
398         if (m_stencilBuffer)
399             glDeleteRenderbuffers(1, &amp;m_stencilBuffer);
400 #endif
401         if (m_depthStencilBuffer)
402             ::glDeleteRenderbuffers(1, &amp;m_depthStencilBuffer);
403     }
404     ::glDeleteFramebuffers(1, &amp;m_fbo);
405 #if USE(COORDINATED_GRAPHICS)
406     ::glDeleteTextures(1, &amp;m_intermediateTexture);
407 #endif
408 
409 #if USE(CAIRO)
410     if (m_vao)
411         deleteVertexArray(m_vao);
412 #endif
413 
414     auto* activeContext = activeContexts().takeLast([this](auto* it) {
415         return it == this;
416     });
417     ASSERT_UNUSED(activeContext, !!activeContext);
418 }
419 #endif // USE(ANGLE)
420 
421 bool GraphicsContextGLOpenGL::makeContextCurrent()
422 {
423 #if USE(NICOSIA)
424     return m_nicosiaLayer-&gt;makeContextCurrent();
425 #else
426     return m_texmapLayer-&gt;makeContextCurrent();
427 #endif
428 }
429 
430 void GraphicsContextGLOpenGL::checkGPUStatus()
431 {
432 }
433 
434 PlatformGraphicsContextGL GraphicsContextGLOpenGL::platformGraphicsContextGL() const
435 {
436 #if USE(NICOSIA)
437     return m_nicosiaLayer-&gt;platformContext();
438 #else
439     return m_texmapLayer-&gt;platformContext();
440 #endif
441 }
442 
443 PlatformGLObject GraphicsContextGLOpenGL::platformTexture() const
444 {
445     return m_texture;
446 }
447 
448 bool GraphicsContextGLOpenGL::isGLES2Compliant() const
449 {
450 #if USE(OPENGL_ES)
451     return true;
452 #else
453     return false;
454 #endif
455 }
456 
457 PlatformLayer* GraphicsContextGLOpenGL::platformLayer() const
458 {
459 #if USE(NICOSIA)
460     return &amp;m_nicosiaLayer-&gt;contentLayer();
461 #else
462     return m_texmapLayer.get();
463 #endif
464 }
465 
466 #if PLATFORM(GTK) &amp;&amp; !USE(ANGLE)
467 ExtensionsGL&amp; GraphicsContextGLOpenGL::getExtensions()
468 {
469     if (!m_extensions) {
470 #if USE(OPENGL_ES)
471         // glGetStringi is not available on GLES2.
472         m_extensions = makeUnique&lt;ExtensionsGLOpenGLES&gt;(this,  false);
473 #else
474         // From OpenGL 3.2 on we use the Core profile, and there we must use glGetStringi.
475         m_extensions = makeUnique&lt;ExtensionsGLOpenGL&gt;(this, GLContext::current()-&gt;version() &gt;= 320);
476 #endif
477     }
478     return *m_extensions;
479 }
480 #endif
481 
482 } // namespace WebCore
483 
484 #endif // ENABLE(GRAPHICS_CONTEXT_GL) &amp;&amp; USE(TEXTURE_MAPPER)
    </pre>
  </body>
</html>